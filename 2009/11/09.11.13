00:00:21 <ivanm> > -3 `rem` 2
00:00:22 <lambdabot>   -1
00:00:29 <ivanm> > -3 `mod` 1
00:00:30 <lambdabot>   0
00:00:31 <ivanm> > -3 `mod` 2
00:00:32 <lambdabot>   -1
00:00:38 <ivanm> bah, stupid example
00:00:42 <copumpkin> lol
00:00:42 <ivanm> > -5 `mod` 3
00:00:43 <lambdabot>   -2
00:00:44 <dolio> That doesn't do what you think it does.
00:00:45 <ivanm> > -5 `rem` 3
00:00:46 <lambdabot>   -2
00:00:54 <ivanm> dolio: obviously not...
00:00:54 <dolio> That's - (5 `rem` 3)
00:00:59 <ivanm> *groan*
00:01:03 <dolio> Due to the ridiculous parser.
00:01:03 <ivanm> > (-5) `rem` 3
00:01:05 <lambdabot>   -2
00:01:08 <ivanm> > (-5) `mod` 3
00:01:09 <lambdabot>   1
00:01:13 <copumpkin> @check \x y -> x `mod` y == x `rem` y
00:01:15 <lambdabot>   "* Exception: divide by zero
00:01:15 <ivanm> Reshure: ^^
00:01:17 <copumpkin> lol
00:01:19 <ivanm> copumpkin: heh
00:01:25 <copumpkin> @check \x y -> y /= 0 ==> x `mod` y == x `rem` y
00:01:27 <lambdabot>   No instance for (Test.QuickCheck.Testable
00:01:27 <lambdabot>                     (Test.QuickCh...
00:01:33 <copumpkin> **** YOU LAMBDABOT
00:02:06 <ivanm> since my QC-fu is weak, what's wrong with that?
00:02:33 <Reshure> Thanks.
00:02:47 <copumpkin> ivanm: beats me
00:02:49 <Cale> @check \x y -> y /= 0 ==> x `mod` y == x `rem` (y :: Integer)
00:02:50 <lambdabot>   No instance for (Test.QuickCheck.Testable
00:02:51 <lambdabot>                     (Test.QuickCh...
00:02:52 <Cale> hmm
00:02:57 <copumpkin> maybe it must be Int
00:03:11 <ivanm> @type rem
00:03:12 <lambdabot> forall a. (Integral a) => a -> a -> a
00:03:12 <ivanm> @type mod
00:03:12 <Cale> too bad we can't see the interesting part of the error ;)
00:03:13 <lambdabot> forall a. (Integral a) => a -> a -> a
00:03:21 <ivanm>  @more doens't work for it?
00:03:23 <copumpkin> @check \x y -> y /= 0 ==> x `mod` y == x `rem` (y :: Int)
00:03:27 <lambdabot>   No instance for (Test.QuickCheck.Testable
00:03:30 <lambdabot>                     (Test.QuickCh...
00:03:31 <Cale> Oh, maybe it would
00:03:31 <copumpkin> well then
00:03:36 <Cale> @more
00:03:39 <copumpkin> I reiterate my earlier sentiment
00:03:39 <Cale> nope
00:03:53 <Asztal> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4922#a4922
00:04:00 <ivanm> copumpkin: heh
00:06:36 <Cale> Asztal: huh, that is extremely ironic. Isn't there supposed to be an instance of that?
00:06:57 <copumpkin> "In the theory of programming languages in computer science, parametricity is a theoretical result that states that functions that have types that are related to each other share certain properties in common."
00:07:00 <copumpkin> nice one wikipedia
00:07:22 <ivanm> so they're related to each other and thus share certain properties in common
00:07:32 <ivanm> how about the property THAT THEY"RE RELATED TO EACH OTHER?!?!?!?!?!
00:07:38 <ivanm> silly wikipedia
00:07:38 <kmc> @where TaPL
00:07:39 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
00:07:55 <copumpkin> it's also on my bookshelf over there
00:08:26 <kmc> yeah my copy was stolen by hippies
00:08:29 * ivanm reaches through the intertubes, snags TaPL off copumpkin's bookshelf and takes it back
00:08:30 <kmc> by which i mean, fellow CS students
00:08:34 <ivanm> s/back/
00:08:37 <ivanm> kmc: heh
00:08:43 <copumpkin> kmc: my copy isn't mine O:-)
00:08:46 <Cale> I hate that about Wikipedia. It's something that a lot of the math articles have. They'll write all this nonsense which is impossible to understand at the top, and then finally give you a definition halfway down the page.
00:08:55 <mmorrow> copumpkin: hippy!
00:08:57 <copumpkin> Cale: well this one doesn't even do that
00:09:09 <copumpkin> http://en.wikipedia.org/wiki/Parametricity
00:09:29 <kmc> but i just found a copy of _Basic Category Theory for Computer Scientists_ by the same author
00:11:12 <dolio> That article is something...
00:11:38 <copumpkin> so before we lose it, can someone tell me what kind of fancy things of beauty we can do with impredicativity in haskell?
00:11:45 <copumpkin> runST $ ...
00:11:50 <mmorrow> kmc: a finite category is representable as a graph
00:11:50 <copumpkin> what else?
00:12:10 <mmorrow> kmc: e.g. a monoid/group is a category with a single object, etc
00:12:11 <EnglishGent> hi all :)
00:12:23 <copumpkin> allo EnglishGent
00:12:24 <dolio> runST $ ... is unrelated to the impredicativity flag.
00:12:30 <copumpkin> dolio: really?
00:12:42 <copumpkin> I guess you wouldn't have said it otherwise :)
00:12:42 <dolio> Should be. I thought they disallowed that, actually.
00:12:47 * EnglishGent notes Cale's complaint about wikipedia - I agree, trying to learn math from wikipedia is hard work :|
00:12:55 <EnglishGent> hi copumpkin :)
00:12:57 <kmc> mmorrow, a multigraph, with morphisms as edges rather than paths, correct?
00:13:20 <EnglishGent> you also need a set of pairs of paths indicating which paths are equal
00:13:21 <copumpkin> kmnope
00:13:28 <mmorrow> kmc: right, i'm defining "graph" := directed, and can has multiple edges between vertices
00:13:29 <EnglishGent> there's more information that just the multigraph
00:13:34 <EnglishGent> than*
00:13:49 * EnglishGent has thought about this before :)
00:14:06 * copumpkin has to stop himself from typing open import on haskell imports now :(
00:14:16 <mmorrow> EnglishGent: all isomorphic morphisms/objects are collapsed into a single morphism/object
00:14:23 <dolio> copumpkin: The flag enables something like "Maybe (forall a. a)" I believe.
00:14:39 <dolio> Or something along those lines.
00:15:01 <EnglishGent> ah I'm thinking of category diagrams mmorrow :)
00:15:07 <mmorrow> EnglishGent: or equivalently, these things are /defined/ up to isomorphism
00:15:07 <copumpkin> dolio: how come runST $ ... works with no additional flags? it seems scary
00:15:15 <kmc> shouldn't that need Rank2Types?
00:15:22 <kmc> but i think that's on by default because it's still decidable?
00:15:22 <copumpkin> I just typed it in and loaded it
00:15:26 <copumpkin> with no LANGUAGE pragmas at all
00:15:29 <kmc> whereas RankN isn't
00:15:34 <kmc> and because ST is bloody useful ;)
00:15:37 <dolio> @type Nothing :: Maybe (forall a. a)
00:15:39 <lambdabot> Maybe (forall a. a)
00:15:48 <copumpkin> oh, lambdabot has it turned on?
00:15:56 <dolio> copumpkin: Anyhow, that doesn't work without -XImpredicativeTypes.
00:16:03 <copumpkin> yeah, I can see why that wouldn't
00:16:13 <copumpkin> @type [] :: [forall a. Show a => a]
00:16:14 <lambdabot> [forall a. (Show a) => a]
00:16:18 <copumpkin> @type [1, True] :: [forall a. Show a => a]
00:16:20 <EnglishGent> you know we could really do with having something on the wiki - a crash course in category theory for people learning Haskell -- even if it isnt necessary, lots of people studying Haskell would at least like to know it
00:16:20 <lambdabot>     Could not deduce (Num a) from the context (Show a)
00:16:21 <lambdabot>       arising from the literal `1' at <interactive>:1:1
00:16:21 <lambdabot>     Possible fix:
00:16:25 <dolio> Actually, it's somewhat weird, because Haskell's type system is already, technically, impredicative.
00:16:31 <copumpkin> @type [1 :: Int, True] :: [forall a. Show a => a]
00:16:32 <dolio> @kind forall a. a -> a
00:16:32 <lambdabot>     Couldn't match expected type `a' against inferred type `Int'
00:16:33 <lambdabot>       `a' is a rigid type variable bound by
00:16:33 <lambdabot>           the polymorphic type `forall a. (Show a) => a' at <interactive>:1:0
00:16:34 <lambdabot> *
00:16:40 <EnglishGent> and it is _not_ an easy subject to teach yourself
00:17:07 <dolio> But not all things of type * are treated equally.
00:17:09 <kmc> what does "impredicative" mean, briefly?
00:17:33 <copumpkin> you can have polymorphic instantiations of type variables?
00:17:42 <kmc> ah
00:17:48 <copumpkin> not entirely sure :)
00:17:56 <copumpkin> I just know various "symptoms" it allows
00:17:58 <dolio> It means that a definition of something quantifies over the entire set of things in which it lives.
00:18:11 <kmc> does it have to do with the quantifiers not being all at the front?
00:18:20 <copumpkin> dolio: does set in set in agda qualify?
00:18:28 <copumpkin> or type in type
00:18:37 <dolio> So in "forall a. a -> a", a ranges over all types, including "forall a. a -> a" itself.
00:18:55 <kmc> aha
00:19:11 <copumpkin> @type [True] :: [forall a. Show a => a]
00:19:12 <lambdabot>     Couldn't match expected type `a' against inferred type `Bool'
00:19:12 <lambdabot>       `a' is a rigid type variable bound by
00:19:12 <lambdabot>           the polymorphic type `forall a. (Show a) => a' at <interactive>:1:0
00:19:17 <dolio> It may, but you can have impredicativity that's weaker than Set : Set.
00:19:18 <copumpkin> aha, I see
00:19:38 <copumpkin> it's not an existential
00:20:07 <kmc> you can't have contexts without a datatype to wrap them
00:20:29 <kmc> @type [('x', id)] :: [forall a. (a, a -> Char)]
00:20:30 <lambdabot>     Couldn't match expected type `a' against inferred type `Char'
00:20:31 <lambdabot>       `a' is a rigid type variable bound by
00:20:31 <lambdabot>           the polymorphic type `forall a. (a, a -> Char)'
00:20:53 <copumpkin> nah, it really wants a forall there
00:20:56 <kmc> what's wrong there?
00:21:09 <kmc> @type [('x', id)] :: forall a. [(a, a -> Char)]
00:21:09 <copumpkin> it's like f :: (forall a. a -> a) -> Int
00:21:10 <lambdabot>     Couldn't match expected type `a' against inferred type `Char'
00:21:10 <lambdabot>       `a' is a rigid type variable bound by
00:21:10 <lambdabot>           an expression type signature at <interactive>:1:22
00:21:27 <copumpkin> still too forall'd
00:21:31 <kmc> :t let f :: (forall a. a -> a) -> Int; f _ = 0 in f
00:21:33 <lambdabot> (forall a. a -> a) -> Int
00:21:49 <copumpkin> kmc: that f will only accept id for its first argument
00:22:11 <dolio> Anyhow, GHC seems to fill in quantifications involving just functions regardless, so it allows going from "forall a. (a -> a)" to "(forall a. a -> a) -> (forall a. a -> a)" if you tell it to for id.
00:22:15 <kmc> yeah
00:22:29 <kmc> copumpkin, so is that Rank2Types, or impredicativity, or both?
00:22:35 <copumpkin> Rank2Types for f
00:22:43 <kmc> :t let f :: (forall a. a -> a) -> Int; f _ = 0 in f id
00:22:45 <lambdabot> Int
00:22:47 <kmc> :t let f :: (forall a. a -> a) -> Int; f _ = 0 in f succ
00:22:48 <lambdabot>     Could not deduce (Enum a) from the context ()
00:22:48 <lambdabot>       arising from a use of `succ' at <interactive>:1:49-52
00:22:48 <lambdabot>     Possible fix:
00:22:57 <kmc> :t let f :: (forall a. (Enum a) => a -> a) -> Int; f _ = 0 in f succ
00:22:58 <lambdabot> Int
00:23:02 <dolio> However, if you try to use impredicativity with a variable that has a data type constructor applied to it, it complains unless -XImpredicativeTypes is enabled.
00:23:31 <copumpkin> dolio: do you have an example?
00:23:45 <dolio> Which, I don't really understand what the difference is as far as GHC is concerned, but there must be one.
00:24:02 <dolio> Nothing :: Maybe (forall a. a -> a) was my example.
00:24:10 <dolio> Just id :: Maybe (forall a. a -> a) also doesn't work.
00:24:15 <copumpkin> oh
00:24:18 <copumpkin> I see
00:24:33 <dolio> Or [id] :: [forall a. a -> a]
00:24:45 <copumpkin> it's interesting that it requires impredicativity there
00:25:08 <copumpkin> the example on the ghc manual feels very much like a rank2types situation, except it involves a constructor
00:25:25 <copumpkin>   f (Just g) = Just (g [3], g "hello")
00:25:43 <copumpkin> (that needs   f :: Maybe (forall a. [a] -> [a]) -> Maybe ([Int], [Char]))
00:25:55 <dolio> Weirdly enough, it doesn't complain if you just ask it the kind of Maybe (forall a. a -> a)
00:27:18 <copumpkin> the first couple of paragraphs of http://research.microsoft.com/en-us/um/people/simonpj/papers/boxy/boxy-icfp.pdf cover more or less this
00:28:05 <dolio> Yeah, I can't reach research.microsoft.com for some reason.
00:28:32 <dolio> Is the problem inference?
00:29:40 <copumpkin> http://dl.dropbox.com/u/361503/boxy-icfp.pdf
00:30:01 <copumpkin> http://snapplr.com/zfwx
00:30:01 <mmorrow> from the new ghc status report:
00:30:06 <mmorrow> "We've concluded that the implementation of impredicative polymorphism is unsustainably complicated, so we are re-trenching. It'll be deprecated in 6.12 (but will still work), and will be either removed or replaced with something simpler in 6.14."
00:30:09 <ivanm> dolio: :o
00:30:14 <mmorrow> http://hackage.haskell.org/trac/ghc/wiki/Status/Oct09
00:30:15 <ivanm> dolio: as a test, does something like wget work?
00:30:26 <copumpkin> they banned him for reading too many papers
00:30:31 <mmorrow> i'm not sure exactly what that means though
00:30:37 <ivanm> dolio: because dibblego and I can't reach MSR either, and we thought it was the fault of our ISP...
00:30:48 <Cale> Banned from reading too many papers?
00:30:50 <mmorrow> like, if it's "removed", does that mean abandoned?
00:30:53 <ivanm> mmorrow: what is "impredicative polymorphism"?
00:30:55 <ivanm> Cale: heh
00:31:00 <dolio> ivanm: Yes, it does. Weird.
00:31:02 <ivanm> mmorrow: deprecated? *shrug*
00:31:08 <copumpkin> mmorrow: eradicated!
00:31:10 <ivanm> dolio: right, so it _could_ be a proxy issue...
00:31:31 <dolio> I don't think I use a proxy...
00:31:32 <Cale> ivanm: Basically, the ability to apply type constructors to polymorphic parameters
00:31:32 <copumpkin> mmorrow: it sure sounds like SPJ wants to pull out all the typechecking code bloat and just erase it
00:31:38 <mmorrow> ivanm: i believe it's what dolio and copumpkin have been talking about
00:31:47 <ivanm> dolio: http://forums.whirlpool.net.au/forum-replies.cfm?t=1311734
00:31:47 <Cale> ivanm: Like  Maybe (forall a. [a] -> [a])
00:31:55 <ivanm> dolio: your ISP might...
00:32:00 <dolio> Ah.
00:32:09 <ivanm> Cale: ahhh, foralls inside rather than outside
00:32:27 <Cale> at least, if I'm remembering things correctly, yeah
00:32:34 <copumpkin> inside type constructor parameters
00:32:39 <copumpkin> that aren't function types
00:32:45 <Cale> yeah
00:33:14 <Cale> You would think that doing it in general would not be too much harder than doing it just for function types
00:33:22 <Cale> But apparently so.
00:33:39 <copumpkin> ah, the mysteries of hardcore type theory
00:34:00 <mmorrow> or more probably, the mysteries of interaction with existing machinery
00:34:08 <shellsage> Does anyone know what provides ConnError for this example?  It's preventing me from using it:  http://darcs.haskell.org/http/test/get.hs
00:34:37 <copumpkin> http://martijn.van.steenbergen.nl/journal/2009/11/12/gadts-in-haskell-98/ :o
00:36:52 * Cale watches as his cheap router chokes on the torrent he's downloading and starts taking ages to connect to websites.
00:37:01 <ivanm> heh
00:37:12 <copumpkin> @ARR
00:37:13 <Cale> shellsage: I will look at the code when it loads anyway ;)
00:37:13 <lambdabot> Unknown command, try @list
00:37:15 <ivanm> Cale: you are of course torrenting a new linux distro or something like that, aren't you? :p
00:37:17 <copumpkin> @YARR
00:37:18 <lambdabot> Unknown command, try @list
00:37:20 <shellsage> ty Cale
00:37:21 <copumpkin> damn :(
00:37:28 <Cale> The Office, actually :)
00:37:40 <copumpkin> @arr
00:37:41 <lambdabot> Swab the deck!
00:37:45 <copumpkin> damn, it's case-sensitive?
00:37:47 <kmc> @. elite arr
00:37:48 <lambdabot> kEEl|-|4U| 7|-|3 sWa8S!
00:37:48 <Cale> I watch all my TV by downloading it.
00:37:50 <kmc> @. elite arr
00:37:51 <lambdabot> driNx uP, Me 'e4R+ie$
00:37:54 <ivanm> Cale: ssshhh!
00:38:30 <ivanm> Cale: we actually have a court case going on down here with the record/motion-picture industry claiming that ISPs should filter out all torrents (or something like that), and they're claiming that torrents are good because you can use them to get linux...
00:38:44 <kmc> @. pl djinn (a, a -> b) -> b
00:38:44 <lambdabot> f = uncurry (flip id)
00:38:45 <Cale> It's a whole lot nicer than watching it on an actual TV, since there are no ads. Not to mention the freedom to watch things whenever you want.
00:39:11 <ivanm> Cale: but are you watching the original Office or the butchered american copy?
00:39:17 <ivanm> ;-)
00:39:23 <Cale> ivanm: I finished watching the original first.
00:39:26 * ivanm didn't watch either one, but still...
00:39:55 <ivanm> but I can't believe they wanted to re-make Kath and Kim... that show was bad enough here :s
00:41:15 <dolio> copumpkin: That blurb doesn't really enlighten me as to what's hard. In my pure type system interpreter, making the lambda cube impredicative is just adding the rule ([],*,*) instead of ([],*,[]). Then forall a. a -> a is judged to have kind *, and you can plug it in anywhere a boring old monotype would go.
00:41:48 <copumpkin> dolio: beats me then :) probably as mmorrow said and a pain to do in their existing typechecking framework
00:42:12 <dolio> And the fact that "forall a. a -> a" is judged to have kind * even in rank-2 types is technically impredicative, regardless of what that paper may say. :)
00:42:35 <dolio> If it were predicative, it would have type [], but of course there's no box in GHC.
00:42:48 <copumpkin> ah
00:42:58 <copumpkin> maybe once they rework the kind system they can work impredicative types back in
00:43:10 <Cale> THER IS TEH BOXY TYPEZ
00:43:13 <copumpkin> I must admit, I'm not sure what I'd need a Maybe (forall a. a -> a) for
00:43:15 <mmorrow> dolio: write a haskell frontend!
00:43:20 * mmorrow tries to get out of the eventually having to do that
00:43:22 <shellsage> Cale, any luck?
00:43:40 <dolio> I guess you could just *say* that a ranges over monotypes, but then you're making distinctions that aren't represented anywhere in your kind system.
00:43:59 <Cale> shellsage: Google loaded :)  ConnError looks like maybe something from the HTTP package?
00:44:13 <shellsage> Cale, yeah but I'm importing Network.HTTP
00:44:16 <Cale> Network.Stream perhaps
00:44:25 <shellsage> hm
00:44:48 <kmc> what would a box kind mean?
00:44:48 <Cale> ghci> :m + Network.Stream
00:44:48 <Cale> ghci> :info ConnError
00:44:48 <Cale> data ConnError
00:44:48 <Cale>   = ErrorReset | ErrorClosed | ErrorParse String | ErrorMisc String
00:44:48 <Cale>   	-- Defined in Network.Stream
00:44:49 <Cale> instance Eq ConnError -- Defined in Network.Stream
00:44:50 <Cale> instance Show ConnError -- Defined in Network.Stream
00:45:01 <shellsage> Cale, got it, thanks
00:45:08 <copumpkin> gio12345: hi
00:45:24 <shellsage> man for an example this thing is buggy as hell
00:46:51 <copumpkin> @djinn (m a, a -> m b) -> (m b, b -> m a)
00:46:51 <lambdabot> -- f cannot be realized.
00:47:37 <copumpkin> @free wtf :: (m a, a -> m b) -> (m b, b -> m a)
00:47:38 <lambdabot> Plugin `free' failed with: Plugin/Free/Type.hs:(152,16)-(160,44): Non-exhaustive patterns in case
00:47:43 <Cale> shellsage: Could it be bitrot?
00:47:55 <mmorrow> haha, @free fail
00:47:57 <shellsage> Cale, idk, just starting out w/ haskell
00:48:19 <mmorrow> @free asdf :: m a
00:48:19 <lambdabot> Extra stuff at end of line
00:48:24 <mmorrow> @free asdf :: m a -> m a
00:48:25 <lambdabot> Extra stuff at end of line
00:48:33 <mmorrow> @free asdf :: m a -> (m a)
00:48:34 <lambdabot> Extra stuff at end of line
00:48:38 <mmorrow> oo
00:49:22 <shellsage> Cale, having trouble now w/ Request: `Request' is not applied to enough type arguments.  Expected kind `?', but `Request' has kind `* -> *'.  In the type `URI -> Request'.  In the type signature for `request': request :: URI -> Request
00:49:37 <mmorrow> @free asdf :: (m a)
00:49:37 <lambdabot> Plugin `free' failed with: Plugin/Free/Type.hs:(152,16)-(160,44): Non-exhaustive patterns in case
00:49:46 <shellsage> so no idea what a kind ? is
00:50:07 <shellsage> Cale_, you see my last two messages?
00:50:19 <Cale_> perhaps not
00:51:44 <copumpkin> shellsage: what code generated that error o.O?
00:52:19 <shellsage> copumpkin, http://darcs.haskell.org/http/test/get.hs
00:52:27 <shellsage> line 42
00:53:10 <copumpkin> it's probably out of date
00:53:16 <copumpkin> examples of library usage often are
00:53:27 <copumpkin> sadly
00:53:32 <ComonadDessert> In oleg's haskell compiler, haskell programs replace the real world with a new real world in which they have been executed.
00:53:55 <shellsage> copumpkin, yeah
00:54:24 <dibblego> ivanm, I can reach it using konqueror, but only the front page -- I can't reach it at all with firefox
00:56:18 <copumpkin> that might be cached?
00:59:54 <dibblego> copumpkin, it's not -- I can also reach it with wget
00:59:59 <copumpkin> ah weird
01:03:45 <dolio> copumpkin: I guess that blurb explains the weird behavior in GHC if you think about the actual kinds it would imply.
01:04:03 <dolio> forall a. a -> a : []
01:04:14 <dolio> So Maybe : * -> * won't accept it.
01:05:13 <dolio> But, (->) is usually special cased.
01:05:41 <copumpkin> ah
01:05:53 <dolio> And the rules ([],[],[]) and ([],*,[]) together for (->) can handle arbitrary rank polymorphism.
01:06:20 <kmc> what's this hypothetical kind [] mean? or should i just read the paper?
01:06:20 <dolio> Which is Fw.
01:06:25 <dolio> * : []
01:06:35 <dolio> It's the level above kinds.
01:07:06 <kmc> what are they good for?
01:07:24 <dolio> Classifying kinds.
01:07:25 <kmc> why do you need them, if you have no kind constructors?
01:07:42 <dolio> (->) is a kind constructor.
01:08:11 <kmc> ah, right
01:08:59 <dolio> Anyhow, in predicative F2, 'forall a b. a -> b' isn't even an acceptable type.
01:09:45 <dolio> Because forall b. a -> b : [], and you don't have the rule ([],[],[]) to allow for the outer quantification.
01:11:16 <dolio> In any case, this sort of stuff is apparently going on in GHC, but it displays [] as *, making it look impredicative.
01:11:31 <copumpkin> weird
01:12:17 <mmorrow> PTS seems imo like a much better system that Fw to do this in
01:13:16 <mmorrow> well, i guess Fw is one of the possible PTSs right?
01:13:19 <dolio> Well, Fw is a corner of the lambda cube, so you can implement it as a pure type system.
01:14:09 <dolio> System F as traditionally presented is impredicative.
01:14:12 <mmorrow> ah right. so i guess rather i mean, having the machinery of PTS in general available seems much more powerful/simple/flexible than choosing a particular one
01:14:13 <dolio> I assume Fw is, too.
01:14:55 <mmorrow> or am i misunderstanding what the fundamental problem is here wrt GHC's implem
01:14:56 <mmorrow> ?
01:15:01 <dolio> Presenting F2 directly makes you write a particular rule twice.
01:15:06 <dolio> Fw probably three times.
01:15:11 <dolio> Multiple rules, actually.
01:15:14 <mmorrow> grr
01:15:39 <dolio> \ vs /\, (->) vs forall.
01:15:48 <mmorrow> oh! right totally
01:18:16 <mmorrow> wait, i want to be sure i'm understanding something. so suppose you were using PTS machinery to implement this /for/ haskell. does that mean you necessarily have to choose *one* particular PTS to work in? or does that mean you're somehow using "PTS in general" to structure the problem/situation?
01:18:58 <dolio> mmorrow: The issue is that GHC (without -XImpredicativeTypes) uses the PTS rule ([],*,[]), but the kinds it displays when you ask it questions make it look like the rule ([],*,*).
01:19:31 <dolio> And the difference only shows up when you try to use the consequences of the latter rule with datatypes.
01:20:19 <mmorrow> oh. ok, it just clicked i think.
01:20:59 <mmorrow> so then -XImpredicativeTypes essentially implies that you need to be using a /different/ PTS than the usual one GHC uses?
01:21:08 <dolio> Yes.
01:21:19 <dolio> -XimpredicativeTypes makes the rule actually ([],*,*).
01:21:30 <mmorrow> ah, ok gotcha.
01:22:43 <mmorrow> dolio: so then using "PTS in general" would simplify this greatly, in that it provides the language to even express what's going on here
01:23:19 <mmorrow> s/the language/a language/
01:23:36 <dolio> Maybe.
01:23:51 <dolio> I don't know what the actual problem with GHC's implementation is.
01:23:59 <dolio> What makes it complicated.
01:24:19 <mmorrow> well, wouldn't you just swap out the PTS as defined by that 3-tuple, then proceed as usual?
01:24:21 <mmorrow> ah
01:24:31 <dolio> It is quite simple changing the rule in a PTS. But if the problem is inference or something, I don't think using a pure type system will help.
01:24:41 <mmorrow> oh, i see
01:25:16 <mmorrow> well, but inference is separate from all this really
01:25:47 <dolio> http://code.haskell.org/~dolio/pts/Language/PTS/Systems.hs
01:25:59 <dolio> I mean, that defines most of the lambda cube there.
01:25:59 <mmorrow> in that your choice of how to structure the typesystem at the implementation level shouldn't influence things wrt inference?
01:27:04 <mmorrow> smallI2C _ = '☹'
01:28:27 <mmorrow> you can either infer something or you can't, but how you structure your system to represent all of this shouldn't change what you can or can't infer, right?
01:29:14 <mmorrow> dolio: so given that, what i'm trying to determine is whether using PTS (in your opinion) would simplify matters here greatly
01:29:17 <mmorrow> ?
01:29:51 <dolio> If it's just a matter of changing the typing rules, pure types systems seem pretty easy for that.
01:30:43 <dolio> But it's hard for me to imagine that making GHC's type checker handle a slightly different rule like that causes a lot of complication.
01:31:39 <ManateeLazyCat> mmorrow: http://farm3.static.flickr.com/2700/4099665305_dda7db11b4_o.png
01:32:17 <ManateeLazyCat> mmorrow: That's Wave, very cool. I use Haskell as my face icon. :)
01:32:30 <mmorrow> , fmap ((text "-X"<>) . parens . hcat . punctuate comma . fmap (text . utf8enc . (:[]))) (replicateM 3 "*◻")
01:32:31 <lunabot>  [-X(*,*,*),-X(*,*,◻),-X(*,◻,*),-X(*,◻,◻),-X(◻,*,*),-X(◻,*,◻),-X(◻,◻,*),-X...
01:32:37 <mmorrow> dolio: ;)
01:33:00 <mmorrow> ManateeLazyCat: ah cool
01:33:09 <dolio> @type Just (id :: forall a. a -> a)
01:33:11 <lambdabot> forall a. Maybe (a -> a)
01:33:21 <mmorrow> :o
01:33:35 <copumpkin> ManateeLazyCat: did you send mmorrow an invite? :o
01:33:39 <dolio> Now, without -XImpredicativeTypes, it can't infer Maybe (forall a. a -> a).
01:33:45 <ivanm> dibblego: weird :s
01:33:54 <dolio> Because that type isn't allowed.
01:33:59 <ManateeLazyCat> copumpkin: No, i try to do that, but Google don't allow send invite now.
01:34:04 <copumpkin> aw
01:34:17 <dolio> So what types it's allowed to infer are affected by whether your rule is impredicative.
01:34:30 <ManateeLazyCat> copumpkin: My American friend give me an account.
01:34:36 <mmorrow> dolio: ahh, ok i see
01:34:37 <copumpkin> I see
01:34:52 <ivanm> ManateeLazyCat: as opposed to your non-American friend? :p
01:35:05 <ManateeLazyCat> mmorrow: Found it, i try to send message to you through Wave, but i think you haven't get an account.
01:35:18 <ManateeLazyCat> ivanm: No. :)
01:35:37 <dolio> mmorrow: It's inferring that type even with -XImpredicativeTypes on, though. So I don't know what the difference is.
01:35:38 <ManateeLazyCat> ivanm: I like your guys.
01:35:49 <ivanm> which guys do you think are mine?
01:36:03 <fasta> What exactly is gpsvc.dll and why is it missing according to Dependency Walker in the GHC created dll? There is a google result, but there is no answer.
01:36:11 <ManateeLazyCat> ivanm: You have Wave account?
01:36:16 <ivanm> nope
01:36:21 <ivanm> and I don't plan on getting one
01:36:28 <ManateeLazyCat> ivanm: I just have three friend in it.
01:36:40 <mmorrow> fasta: welcome to the botnet
01:36:45 <ManateeLazyCat> ivanm: It's mix mail, mail-list, wiki, IM, in it.
01:36:49 <mmorrow> oh, missing..
01:36:51 <ManateeLazyCat> ivanm: And all is real-time.
01:37:03 <ManateeLazyCat> ivanm: you can see my words when i typing.
01:37:06 <ivanm> why would you want to mix them? *shrug*
01:37:13 <ivanm> ManateeLazyCat: yeah, IMHO that's bad
01:37:15 <mmorrow> dolio: oh, hrm
01:37:30 <fasta> mmorrow, well, if it is a botnet dll, why does GHC want to link it in?
01:37:37 <ivanm> after all, did you just see me calling you an idiot even though I deleted it before hitting enter?
01:37:38 <ivanm> :p
01:37:48 <fasta> mmorrow, and what makes you think it is a virus?
01:37:58 <mmorrow> fasta: the .dll on the end ;)
01:38:08 <ManateeLazyCat> ivanm: Real time is not friendly sometimes. :)
01:38:16 <fasta> mmorrow, uh, that doesn't make sense.
01:38:18 <ivanm> exactly my point
01:38:20 <ivanm> ;-)
01:38:48 <fasta> mmorrow, ah, a bad attempt at a joke, never mind.
01:40:27 <dolio> mmorrow: Anyhow, it's time for me to sleep. I'll catch you later.
01:41:09 <mmorrow> fasta: haha
01:41:17 <mmorrow> dolio: catcha later
01:41:36 <fasta> mmorrow, :)
01:41:42 <mmorrow> :)
01:47:03 <copumpkin> damn it's late
01:48:10 <ivanm> copumpkin: is it?
01:48:12 <ivanm> @time
01:48:12 <lambdabot> Local time for ivanm is Fri Nov 13 19:48:09
01:48:20 <luite> @time
01:48:23 <lambdabot> Local time for luite is Fri Nov 13 10:48:18 2009
01:48:25 <copumpkin> over here it is
01:51:08 <ivanm> yes, but who says I care about you? :p
01:51:54 <copumpkin> I actually intended that message for the other 600-or-so people in here who aren't you!
01:52:23 <ivanm> oh, you should have said so then
01:55:40 <Jafet> It's never too late to be early
01:58:16 <sinelaw> what's your opinion - do non-pure functional languages deserve the name "functional programming language"?
01:58:28 <nainaide> Anybody tried hplip on Gentoo recently? I can not install HP M1005.  Thanks!
01:58:35 <Jafet> There are at least three meanings of the word "functional"; which do you mean?
01:58:36 <sinelaw> once you allow side effects through the back door, what's "functional" here?
01:58:36 <shambler> @time
01:58:38 <lambdabot> Local time for shambler is Fri Nov 13 11:58:19
01:58:46 <sinelaw> Jafet, ok, so what's the common meaning?
01:59:08 <sinelaw> (for "functional programming")
01:59:09 <Jafet> A complicated amalgam of some subset of the above.
01:59:39 <sinelaw> ah, inprecise definitions. hooray
01:59:45 <ivanm> nainaide: do you really want to be asking that here?
01:59:54 <nainaide> ivanm, sure
02:00:07 <ivanm> nainaide: rather than say #gentoo, #gentoo-desktop, etc.?
02:00:18 <sinelaw> #hpm1005
02:00:30 <nainaide> ivanm, sorry , wrong channel! :)
02:00:35 <ivanm> sinelaw: you really think they have per-model channels?
02:00:38 <ivanm> nainaide: no, really? :p
02:00:42 <sinelaw> #hpm1005x-2006b
02:00:51 <ivanm> heh
02:01:18 <nainaide> :t ord
02:01:19 <Jafet> "What is the sound of one person joining?"
02:01:19 <lambdabot> Char -> Int
02:01:54 <sinelaw> Jafet, Char -> Int
02:02:20 <sinelaw> so how do you define "functional programming"? I need to introduce it to electrical engineers
02:02:20 <ivanm> does it hurt to have text being moved around in handles which are set to being in binary mode?
02:02:57 <Jafet> I would break the "functional" part into its constituent definitions
02:03:06 <fasta> sinelaw, functional programming stops being functional programming if you cannot replace equals with equals anymore.
02:03:18 <sinelaw> Jafet, fasta, both good ideas.
02:03:33 <Jafet> fasta, there exist people who disagree with you
02:03:42 <ivanm> Jafet: you mean "func", "tion" and "al" ? :p
02:03:46 <Jafet> (Of course, they are wrong!!1)
02:04:04 <sinelaw> Jafet, so what are they?
02:04:20 <Jafet> Yo yo, it's Funk Shawn Al
02:04:27 <fasta> Jafet, it would be more fun if those people would say that.
02:05:04 <Jafet> fasta, yes, then I could do something better with these goddam strawmen
02:05:13 <fasta> sinelaw, so, using this idea you can argue that the ST monad is functional.
02:05:42 <fasta> sinelaw, you can also say that this is a kind of "cheating" in that you don't have concrete values anymore, but functions.
02:06:04 <Jafet> What is a concrete value?
02:06:15 <fasta> sinelaw, most people refer to a functional algorithm as one which doesn't use references or mutable arrays.
02:06:30 <fasta> sinelaw, so, the terminology is kind of inconsistent there.
02:06:30 <Jafet> A functional algorithm is one that functions!
02:06:41 <Jafet> ...as compared to dysfunctional ones
02:06:51 <sinelaw> Jafet, heh that definition rocks
02:07:18 <sinelaw> fasta, i guess i should define it in terms of what i'm talking about (i'm talking about paradigms that encourage precise simple semantics)
02:07:27 <sinelaw> immutability is one
02:07:39 <fasta> sinelaw, anyway, the only thing which is worth mentioning about Haskell is that you can program like you are doing stream processing for a lot of stuff.
02:07:51 <fasta> sinelaw, well, that and the type-inference.
02:08:02 <sinelaw> the type system
02:08:19 <fasta> sinelaw, and you might want to say that it can run acceptably fast when needed.
02:08:20 <sinelaw> which is what allows monads in the first place
02:08:44 <fasta> sinelaw, well, you can also do it in a dynamic language.
02:08:56 <fasta> sinelaw, but then it would be terribly slow.
02:08:56 <sinelaw> fasta, true but i'm not really concerned with performance so i'd rather not go into that.
02:09:16 <sinelaw> fasta, dynamical languages don't offer the type safety and encourage messy designs
02:09:45 <fasta> sinelaw, they do offer type safety, just not at compile time, although, even that is possible.
02:10:06 <Jafet> Oh, you just wanted to introduce Haskell? That's easy, start by saying how mind-blowing the semantics are, how it can do type inference and polymorphism and give you a blowjob at the same time, then move on to fib
02:10:19 <sinelaw> i wouldn't call that safety. you don't really know what types are even going to exist
02:10:25 <fasta> sinelaw, and the messy designs depends on whether you build software like 99.99% of the people do in dynamic languages.
02:10:42 <fasta> sinelaw, ah, so, I agree on point 2 I guess ;)
02:11:01 <sinelaw> fasta, right, it depends on the programmer. but it's a question of what the language encourages you to do
02:11:27 <sinelaw> anyway, i think i got it. thanks for invoking useful ideas :)
02:11:37 <Jafet> sinelaw, a dynamic typing system is a typing system that allows names to refer to values of unknown type.
02:12:16 <sinelaw> Jafet, yes, and that opens the door to inprecise semantics
02:12:21 <sinelaw> imprecise
02:12:22 <Jafet> Haskell isn't fully statically typed either, that would be pretty useless
02:12:42 <sinelaw> Jafet, in what sense it isn't?
02:13:03 <Jafet> sinelaw, nonsense. It just means certain parts of the semantics cannot (and do not have to be) checked by a preprocessor
02:13:19 <Jafet> Polymorphic types.
02:13:38 <sinelaw> that's static, no?, the types are determined at compile time.
02:14:58 <Jafet> A name may refer to a value from one of several types.
02:15:14 <mmorrow> @src map
02:15:15 <lambdabot> map _ []     = []
02:15:15 <lambdabot> map f (x:xs) = f x : map f xs
02:15:28 <mmorrow> @type map
02:15:29 <Jafet> You are confusing static type checking with static typing, sinelaw
02:15:29 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
02:15:54 <Jafet> Despite what 1970 wants you to believe, they are not the same thing
02:15:58 <mmorrow> map is statically typed
02:16:03 <sinelaw> Jafet, so what are they?
02:16:05 <mmorrow> map is polymorphic
02:17:33 <mmorrow> Jafet: i think you mean s/statically typed/monomorphic/ ?
02:18:26 <Jafet> So as I was saying previously, computer science terms often have imprecise definitions that hinder communication...
02:19:24 <dibblego> wait what? polymorphism negates static typing? I think that beats the recent Scala list episode!
02:19:36 <ivanm> dibblego: what's this?
02:20:26 <dibblego> ivanm, "(a -> b) -> (b -> c) -> a -> c is once-inhabited (assuming termination, no lying in the types)" is a false statement, easily falsified by a counter-example, but apparently also falsified by "because I said so!"
02:21:20 <ivanm> what does "once-inhabited" mean?
02:21:35 <Jafet> Oh, we have episodes? Cool
02:21:37 <dibblego> only one function inhabits this type
02:22:18 <ivanm> how is it not once-inhabited?
02:22:42 <dibblego> ivanm, because! that's why! so there!
02:22:54 <ivanm> ...
02:23:38 <ivanm> dibblego: I know someone (copumpkin?) was commenting on you not liking the statement that "(a -> a) -> a -> a" having infinitely many possible realisations...
02:23:56 * ivanm feels safe in pointing the finger at copumpkin since he's apparently asleep atm...
02:24:00 <dibblego> ivanm, I don't like or dislike it -- it's just not true within certain constraints
02:24:12 <ivanm> such as?
02:24:24 <dibblego> wait, different signature
02:24:31 <dibblego> I don't know what you are talking about
02:24:32 <ivanm> yeah
02:24:44 <ivanm> dibblego: maybe he was generalising from that (.) definition...
02:24:57 <ivanm> s/definition/type-sig/
02:27:32 <mmorrow> @tell dolio @telling you so i remember. when i said "can or can't infer", i meant "infer" in the sense that "there's enough information there to figure something (whatever happens to need figuring) out", but i just realized you were (i think) using "infer" in a different sense
02:27:32 <lambdabot> Consider it noted.
02:27:57 <sinelaw> heh
02:28:02 <sinelaw> Jafet, so what do YOU mean when you say that static typing is not static type checking?
02:29:04 <Jafet> I think I meant monomorphism, as mmorrow crystalballed
02:32:31 <sg> hi
02:56:32 <zong_sharo> i get to all my random-related code is like :: RandT StdGen (Reader r) (a -> b). it's randomly produces pure functions
02:56:56 <zong_sharo> looks like i'm fighting against Rand monad, not using it
02:58:27 <zong_sharo> supposedly i can use something more straightforward in this case, but i dunno what
03:23:21 <ksf> http://shootout.alioth.debian.org/u64/benchmark.php?test=all&lang=ghc&lang2=go&box=1
03:24:23 <ksf> why's fasta that slow?
03:24:49 <SamB_XP_> lack of RAM?
03:26:39 <sinelaw> do I need to capitalize Lambda Calculus?
03:26:44 <sinelaw> i guess not
03:27:58 <ksf> ghc uses 1/3 the memory...
03:28:10 <SamB_XP_> sinelaw: just capitalize *on* it
03:28:25 <SamB_XP_> ksf: since when is fasta something besides a person ?
03:28:29 <sinelaw> SamB_XP_, working on that
03:28:46 <fasta> SamB_XP_, the benchmark was first ;)
03:29:04 <SamB_XP_> fasta: and how is that relevant ?
03:29:29 <SamB_XP_> fasta: don't tell me you *are* the benchmark
03:29:38 <SamB_XP_> that would sure explain why it's so slow ;-P
03:30:11 <fasta> SamB_XP_, well, it is valid to refer to fasta, since it is the name of a benchmark.
03:30:30 <SamB_XP_> don't bother me with your facts!
03:30:44 <ksf> strange enough, issue9 is en par with gcc with fasta
03:32:49 <zygoloid> looks like ghc fasta is slow because it uses a stupid method
03:33:43 <zygoloid> it's got a list of [(Word8, Float)] (xi,yi) and wants to know the xn where sum_i=0 to n <= f < sum_i=0 to n+1
03:33:49 <zygoloid> and it does it by scanning through the list
03:34:06 <zygoloid> http://shootout.alioth.debian.org/u64/benchmark.php?test=fasta&lang=ghc&id=2
03:35:12 <zygoloid> i wonder how much faster that'd go if a map were used instead.
03:38:25 * hackagebot upload: flite 0.1 - f-lite compiler, interpreter and libraries (JasonReich)
03:38:54 <ksf> iobs and homs is quite small, though.
03:41:27 <zygoloid> ksf: you're right. i'm guessing; i've not profiled it. but that would be the first place i'd look
03:41:29 <ksf> oh, but it's actually done in a tight loop.
03:41:36 <zygoloid> yeah
03:43:34 <zygoloid> you could easily precompute a map and look up the values in it (using Data.Map.split i guess)
03:43:46 <zygoloid> i'd guess that'd be faster but who knows...
03:44:14 <zygoloid> ideally i guess you'd want to build some code which unrolls the map lookup
03:44:40 <ksf> ouch. choose 48%, rand 12%
03:44:55 * ksf wonders whether that's allowed.
03:44:56 <zygoloid> i find myself unsurprised by this result :)
03:45:21 <zygoloid> ksf: you may have to write it so it's generated at compile time by either aggressive optimization, REWRITE rules or TH...
03:46:46 <SamB_XP_> zygoloid: could be tricky!
03:47:30 <SamB_XP_> zygoloid: well, C compilers are allowed to implement *switch* any way they like, yes ? as long as it actually works ;-P
03:47:36 <ksf> that linear search is really strange.
03:48:07 <ksf> why are the probabilities represented as deltas in the first place?
03:49:25 <SamB_XP_> ksf: 'cause it's funnnn!
03:49:36 <SamB_XP_> is that \delta or \Delta, anyway?
03:49:41 <ksf> add each n_i to each n_i+1 , then do some sane lookup.
03:50:06 <zygoloid> ksf: i guess the problem spec requires it; the other impls represent it the same way
03:50:37 <zygoloid> but the C impl starts by computing the partial sums.
03:50:57 <ksf> yep.
03:51:11 <zygoloid> the problem spec doesn't appear to require a linear search but i can't see an implementation which doesn't use one
03:51:25 <SamB_XP_> wonder why it's not called "slowa" if it's so slow?
03:52:33 <ksf> that'd be because the lookup is surjective.
03:52:38 * SamB_XP_ just accidentally mixed the titles "Ask Dr. Eldritch" and "Evil Inc." to get "Ask Dr. Evil"
03:53:08 <zygoloid> ksf: ?
03:53:26 <ksf> more than one value maps to a single result.
03:53:37 <zygoloid> ksf: that's not what surjective means, and it's not a problem
03:54:00 <zygoloid> ksf: in c++ you can use lower_bound, in haskell you can use Data.Map.split
03:54:13 <zygoloid> you want the first map entry with a key >= the given value
03:54:50 <zygoloid> (surjective means that the codomain is the range)
03:55:22 <ksf> but the diagrams look exactly like what I mean.
03:55:36 <zygoloid> :D
03:55:50 <zygoloid> i could easily believe that using a map would make the lookup slower, though...
03:55:54 * SamB_XP_ wonders how to get the freenet wrapper to stop being so trigger-happy
03:57:05 <ksf> I'm also suspicious of -via-C
03:57:32 <SamB_XP_> what do you suspect it of?
03:57:33 <SamB_XP_> murder?
03:57:36 <SamB_XP_> rape?
03:57:38 <SamB_XP_> pillaging?
03:57:53 <SamB_XP_> writing overly-imperative code behind your back?
03:58:14 <ksf> I suspect the gcc devs disabling opitmisations for ghc for the benchmark.
03:58:49 <Gracenotes> heh.. I fell asleep to a Google Tech Talk last night :/ trying again
03:59:25 <koala_man> at least it wasn't during the day
04:00:07 <Gracenotes> what the speaker has to say is interesting.. but.. eh...
04:00:23 <zygoloid> -via-C guarantees that for every haskell program we write for the shootout there's a C program which goes at least as fast :)
04:00:53 <SamB_XP_> zygoloid: not quite
04:02:02 <SamB_XP_> zygoloid: the mangler messes with your assertion, in theory ;-P
04:02:31 * hackagebot upload: optimusprime 0.0.1.20091113 - A supercompiler for f-lite (JasonReich)
04:12:53 <ivanm> do I dare ask why optimusprime? :s
04:15:44 <Gracenotes> hmmm.
04:17:14 <ksf> down to 5.88 from 6.26
04:26:22 <ksf> uh.
04:26:56 <ksf> well, yes, there's a speedup, but choose takes more time.
04:27:04 <ksf> that's prolly the inlining to look, though.
04:27:23 <ksf> or I'm missing some detail about how stuff is attributed to cost centres.
04:28:28 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12111#a12111
04:28:35 <ksf> gotta try that map thing, too.
04:29:19 <maartenm> any work on multi-agent systems in haskell?
04:29:41 <ksf> but coffee is more important.
04:30:51 * SamB_XP_ ponders the possible meanings of cofree
04:32:16 <Botje> it's something you do to avoid memory waste
04:32:36 <Botje> and of course, freeing twice is an error, so you have to insert a cofree :]
04:38:18 <maartenm> or it "undoes" a free in fault-tolerant transactions
04:41:44 * SamB_XP_ wants a Windows equiv. of 'tail -f' ...
04:42:14 <maartenm> SamB_XP_: baretail
04:42:58 <maartenm> it has multiple tabs too, I use it all the time
04:47:07 <Lexclu> Sponsorised by TOTAL : Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll !
04:47:10 <Lexclu> Sponsorised by TOTAL : Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll !!
04:47:13 <Lexclu> Sponsorised by TOTAL : Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll !
04:47:17 <Lexclu> Sponsorised by TOTAL : Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll !!
04:47:17 <ivanm> @where ops
04:47:17 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
04:47:20 <Lexclu> Sponsorised by TOTAL : Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll !
04:47:24 <Lexclu> Sponsorised by TOTAL : Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll !!
04:47:27 <Lexclu> Sponsorised by TOTAL : Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll !
04:47:30 <Lexclu> Sponsorised by TOTAL : Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll !!
04:47:33 <Lexclu> Sponsorised by TOTAL : Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll !
04:47:36 <Lexclu> Sponsorised by TOTAL : Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll !!
04:47:39 <Lexclu> Sponsorised by TOTAL : Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll !
04:47:41 <Lexclu> Sponsorised by TOTAL : Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll Troll P Troll !!
04:47:42 --- mode: ChanServ set +o dcoutts
04:47:43 --- mode: dcoutts set +b *!*n=Lexclu@124.238-67-87.adsl-static.isp.belgacom.be
04:47:43 --- kick: Lexclu was kicked by dcoutts (dcoutts)
04:47:55 <ivanm> obvious troll was obvious...
04:47:58 <ivanm> thanks dcoutts
04:48:07 <mxc> ty
04:48:21 <maartenm> is Sponsorised a word?
04:48:33 <ivanm> maartenm: heh, I was about to comment on that ;-)
04:48:38 <ivanm> @wn sponsorised
04:48:39 <lambdabot> No match for "sponsorised".
04:48:45 <bastl> separated by whitespace... yes !?
04:48:45 <ivanm> maartenm: lambdabot says it isn't
04:48:54 <shambler> @wn what
04:48:54 <maartenm> such a shame
04:48:55 <lambdabot> No match for "what".
04:48:57 <dcoutts> ivanm: sounds like a George Bushism
04:48:58 <dqd> Maybe in some troll dictionary...
04:49:14 --- mode: ChanServ set -o dcoutts
04:49:53 <maartenm> @wn you
04:49:54 <lambdabot> No match for "you".
04:50:04 <maartenm> indeed
04:51:07 <ivanm> dcoutts: heh
04:51:16 <ivanm> @wn lambda
04:51:17 <lambdabot> *** "lambda" wn "WordNet (r) 2.0"
04:51:17 <lambdabot> lambda
04:51:17 <lambdabot>      n 1: the 11th letter of the Greek alphabet
04:51:17 <lambdabot>      2: the craniometric point at the junction of the sagittal and
04:51:17 <lambdabot>         lamboid sutures of the skull
04:51:27 <ivanm> maartenm: I'm guessing it's too short
04:51:34 <ivanm> @wn Haskell
04:51:35 <lambdabot> No match for "Haskell".
04:51:38 <ivanm> :o
04:52:17 <mlesniak> Is anyone using ghc 6.10.4 with Ubuntu Karmic and programs with explicit threading? It seems that only one core is used (I tested the same program on another machine with some old redhat and all cores are used)
04:52:33 <mlesniak> (yes, did not forget +RTS -N<foo> -RTS ;-))
04:55:35 <ksf> mlesniak, and compiled with -threaded?
04:56:10 <ksf> check --info and look whether your ghc comes with threading.
04:57:01 <mlesniak> ksf: yes, of course, I copied Makefiles etc... on the other machine and have perfect speedup (trivial test using independent tasks out of a queue), no speedup (since only one core is used) on my karmic-machine
04:57:13 <mlesniak> ghc comes with threading, its the one from the website
04:57:27 <mlesniak> did not have these problems with the older ubuntu version, everything else is the same
04:57:41 <ksf> is your ubuntu kernel smp?
04:57:43 <mlesniak> (That's why I am asking... seems very strange)
04:57:50 <ksf> .../proc/cpuinfo
04:57:51 <mlesniak> Linux platon 2.6.31-14-generic #48-Ubuntu SMP Fri Oct 16 14:05:01 UTC 2009 x86_64 GNU/Linux
04:58:03 <ksf> hum.
04:58:13 <koeien37> could you boot the older kernel?
04:58:15 <mlesniak> proc/cpuinfo says I have two cores ;)
04:58:57 <mlesniak> koeien37: unforunately no, I made a clean install; but Ubuntu is quite a often-used distribution, hence I thought I should not be the first one having such problems, should I?
04:59:07 <koeien37> no, definitely not
04:59:32 <koeien37> i use debian myself (ubuntu VM has only 1 core designated to it), so i can't try it
05:00:06 <mlesniak> Ok, I'll look further into the problem (and maybe write a blog post about it, its quite irritating, especially since the code runs perfectly on the other machine)
05:04:02 <Saizan_> mlesniak: did you remember to use +RTS -Nn with n > 1 ?
05:04:13 <bastl> how can I derive Show for GADTs ?
05:04:53 <Saizan_> with 6.12 iirc, or asking mmorrow for his TH code
05:05:35 <mlesniak> Saizan_: Yes, on both machines
05:07:12 <mlesniak> Whats really strange is, on of the two cores seems ot be *not* used at all
05:07:31 <koeien37> also not by other processes? that would explain a lot
05:08:04 <mlesniak> No, no load no both machines, as said, its really(!) strange that one core is not used at all
05:08:29 <mlesniak> (at least by Haskells RTS, it is used by the general linux system)
05:08:58 <mlesniak> I'm really irritated but do not want to install ubuntu 9.04 (or any other distribution) just to test it out. And we still do not have a haskell live cd, do we? ;-)
05:09:29 <ksf> we have house boot disks.
05:09:56 <ksf> but, tbh, you should just exorcise ubunto and switch to gentoo.
05:10:14 <koeien37> erm, no
05:10:41 <mlesniak> ksf: I "had" them all, arch, redhat, suse, debian, gentoo and ubuntu just works (i need to work, not play around -- those were the times when I was a student with a lot of free time ;-))
05:11:01 <ivanm> work? what's that? :p
05:11:07 <koeien37> i had the opposite experience actually -- but hey, if it works for you
05:11:09 <ksf> http://www.reddit.com/r/programming/comments/a3l91/what_is_so_special_about_google_go/c0fql3s
05:11:14 <ksf> ooooh someone reply to this.
05:11:20 <mlesniak> ksf: btw, house uses ghc 6.8.2, which would introduce (probably) a lot of other problems ;-)
05:11:25 <ksf> I would write too nasty stuff right now.
05:17:36 <donri> fedora has a haskell "spin", i think
05:18:17 <ivanm> preflex: seen Baughn
05:18:17 <preflex>  Baughn was last seen on ##c++ 14 hours and 54 seconds ago, saying: Kind of odd that I didn't get an error for the other files that include that header.. well, nm.
05:18:22 <donri> https://fedoraproject.org/wiki/Haskell_Spin
05:19:30 <ivanm> @tell Baughn slight problem with Haskell-mode: when I want to explicitly import a few things, I have something like "import Foo( blah\n, baz)", where the , is aligned with the ( ... the indenter in indentation doesn't like that :s
05:19:30 <lambdabot> Consider it noted.
05:20:26 <Saizan_> ksf: i would, but i'm not subscribed!
05:20:29 <ivanm> @hoogle forkIO
05:20:29 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
05:20:46 <ivanm> is there any reason why it needs IO () ?
05:20:46 <ksf> Saizan_, making an acount is trivial.
05:20:50 <ivanm> rather than IO a ?
05:20:52 <donri> mlesniak, i didn't follow everything you said but anyway fedora has plans for a haskell "spin" https://fedoraproject.org/wiki/Haskell_Spin
05:21:00 <ivanm> it obviously doesn't return anything...
05:21:16 <koeien37> ivanm: i like it, it makes sure that you don't ignore the return value
05:21:26 <koeien37> forkIO getLine -- whoops, where is my output now?
05:21:27 <ksf> heh he edited it.
05:21:47 <ivanm> koeien37: ummmm.... so I need to explicitly add a return () because the type sig says it doesn't return a value?
05:21:53 <koeien37> yep.
05:21:55 <ivanm> s/a value/the value/
05:22:00 <ivanm> ... that's crazy talk!
05:22:14 <ksf> It's not going to work out that way though, his ego is going to stick to the notion that readLine isn't referentially transparent.
05:22:28 <koeien37> you mean the reddit link?
05:22:40 <ivanm> donri: by "spin", you mean a liveCD?
05:22:47 <ksf> yep.
05:23:03 <ivanm> yes, lazy IO isn't fully referentially transparent, etc.
05:23:05 <ivanm> blah, blah, blah
05:23:06 <ivanm> next!
05:23:07 <mlesniak> donri: Well, looks, that the project is in an early stage, but thanks :)
05:23:07 <koeien37> ksf: i couldn't find the comment after i clicked "view whole thread", so i didn't bother
05:23:10 <ksf> wait I should just pl that.
05:23:11 <Saizan_> it seems the same to me, and still horribly wrong
05:24:47 <cathper> Now I have some Haskell code that solves some task, but I'm pretty sure it can be beautified a lot since this is my first real Haskell program ever: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4926#a4926
05:25:00 <cathper> Hints, tips, tricks, ... are more than welcome!
05:25:01 <mmorrow> bastl: i've got a package on hackage that derives Show,Read,Eq,Ord for a restricted subset of GADTs. well, it'll actually derive Show/Read for _parts of_ a single GADT, it's kind of off-the cuff (wrt the subset of GADTs it can handle), but it does a couple non-trivial things to do so, so it makes a decent effort
05:25:02 <donri> ivanm, i think spins are (installable) live cds, yes
05:25:19 <donri> more specifically, topic-oriented ones
05:25:25 <mmorrow> bastl: one of the "non-trivial" things being grouping the constructors into equivalence classes via unification
05:25:34 <koeien37> cathper: your maximize function uses explicit recursion
05:25:50 <koeien37> cathper: can you solve this using higher order functions, such as maximum, map, fold ?
05:26:11 <cathper> koeien37: Right.
05:26:23 <cathper> koeien37: I probably can. Let me think.
05:26:24 <koeien37> the same for sumMult basically
05:26:43 <Jafet> :t max
05:26:44 <lambdabot> forall a. (Ord a) => a -> a -> a
05:29:24 <ksf> koeien37, http://www.reddit.com/r/programming/comments/a3l91/what_is_so_special_about_google_go/c0fqawj
05:29:30 <Gracenotes> hm. how is it even remotely possible to hook up something like Haskell into C, anyway. o_o  is there something special about C calling conventions?
05:29:59 <ksf> well, they're standardised.
05:30:06 <Gracenotes> rather, hooking C into Haskell.. but the reverse seems equally impossible
05:30:12 <ksf> ...at least on a per-machine basis, that is.
05:30:22 <Gracenotes> er, actually, once it gets compiled down to STG, it must not be so hard.
05:30:26 <ksf> and the rts can speak c.
05:30:27 <Gracenotes> -> Cmm
05:30:52 <Jafet> To call Haskell from C, use Haskell-to-C FFI; to call C from Haskell, use C-to-Haskell FFI...
05:31:08 <Gracenotes> mere black boxes, Jafet! -.-
05:31:08 <cathper> koeien37: maximize f xs = maximum $ map f xs
05:31:19 <mmorrow> bastl: here's an example of the derive-gadt cli tool http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4927
05:31:27 <Gracenotes> hm. so a Haskell-to-some-other-language bridge would go through C, most likely
05:31:34 <Jafet> I paint mine black just to call them black boxes!
05:31:37 <ivanm> Gracenotes: that's what hubris does
05:31:42 <ivanm> preflex: seen blackdog
05:31:42 <preflex>  blackdog was last seen on #haskell 13 hours, 25 minutes and 17 seconds ago, saying: has anyone attempted the C10K problem in haskell?
05:32:07 <koeien37> cathper: that's better, yes, only maximize _ [] is different still. that returns 0 in your case, and for this maximize it would crash
05:32:09 <koeien37> > maximum []
05:32:11 <lambdabot>   * Exception: Prelude.maximum: empty list
05:32:57 <mmorrow> bastl: the annoying thing is that, e.g. in this example, the "Lit" con having type "Exp Int" ruins it for the others wrt instances, because any further instances for (Exp a) would overlap with (Exp Int)
05:33:00 <cathper> koeien37: Right, but I'm sure that the list is not empty, so that's not a problem.
05:33:00 <Jafet> You can pretty much rewrite it as a fold
05:33:35 <Gracenotes> both map and maximum are. the latter doesn't have an implicit default value, though..
05:33:36 <zygoloid> Gracenotes: for FFI functions :: ... -> IO a, it's pretty easy to see how they might work, isn't it?
05:33:41 <mmorrow> but you can't use the "Lit" con /unless/ it's (Exp Int), which (Exp a) covers, but you have no way of knowing when `a' is Int
05:34:10 <mmorrow> s/no way of knowing/can't express this constraint to the type system in the context of typeclass instances/
05:34:21 <ksf> :t replicateM
05:34:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
05:34:29 <Gracenotes> zygoloid: I've worked with the FFI, called md5 for instance. I just realized that compiled GHC *would* follow C calling conventions pretty closely, because that's how it compiles down for the most part :)
05:35:02 <cathper> koeien37: Could it be even better?
05:35:30 <koeien37> cathper: i prefer maximize f = maximum . map f
05:35:44 * ksf has had some looks at compiled haskell, and it didn't appear to care for c calling conventions.
05:35:53 <zygoloid> Gracenotes: well, for FFI functions it needs to follow the appropriate calling convention, certainly. but it can generate some haskell code to wrap the FFI call, so if f is a foreign import, that doesn't mean that code which calls f has to use a special calling convention
05:36:12 <cathper> koeien37: I see.
05:37:08 <mmorrow> zygoloid: it uses libffi to dynamically generate stubs for the C callconv on whatever your machine at runtime
05:37:14 <cathper> koeien37: To potentially avoid using anonymous functions.
05:37:21 <zygoloid> eg. strlen p = do withCStack (\pStack -> poke pStack p; call strlen_address)
05:37:21 <cathper> koeien37: Or for some other reason?
05:37:26 <zygoloid> mmorrow: right, that makes sense.
05:38:21 <koeien37> cathper: it is slightly clearer than   maximize f xs = maximum (map f xs)  imo
05:38:44 <mmorrow> zygoloid: err, actually libffi doesn't dynamically generate code iirc, but takes type descriptors and the args, then makes the ccall correctly (iirc)
05:38:50 <cathper> koeien37: Okay.
05:39:09 <cathper> koeien: Okay.
05:39:13 <cathper> ...
05:40:31 <desp> Is it possible to write this more succintly?
05:40:39 <desp> x <- action
05:40:42 <desp> case x of ...
05:41:35 <desp> I'm hoping for something like "case \/ action of"
05:41:56 <mmorrow> zygoloid: if you're curious, i happen to have an unpacked tarball of the libffi from ghc here (e.g. unix64.S) http://moonpatio.com/repos/LIBS/Language/ghc.old/libffi/libffi-3.0.6/src/x86/unix64.S
05:42:35 <mmorrow> zygoloid: i guess it does dyngen some code for "closures", but i'm not sure if ghc uses this part of libffi
05:43:34 <Gracenotes> hm. that's pretty cool
05:43:52 <mmorrow> and for foreign export it uses http://moonpatio.com/repos/LIBS/Language/ghc/rts/Adjustor.c
05:44:14 <mmorrow> ah, ok
05:44:17 <mmorrow> #if defined(USE_LIBFFI_FOR_ADJUSTORS)
05:44:17 <mmorrow> #include "ffi.h"
05:44:18 <mmorrow> ..
05:44:26 <Gracenotes> desp: explicit case statements pretty much have one form. most useful would be to shorten \x -> case x of { ... }, to say 'case of {...}', so you could do action >>= case of {...}
05:44:38 <Gracenotes> but this is not the case
05:44:43 <Gracenotes> (no pun intended)
05:45:09 <cathper> Is there a "mergeBy" thing? mergeBy f (x:xs) (y:ys) = (x `f` y) : (mergeBy f xs ys)
05:45:23 <Gracenotes> zipWith
05:45:34 <desp> Gracenotes: :D
05:45:46 <Gracenotes> @src zipWith
05:45:47 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
05:45:47 <lambdabot> zipWith _ _      _      = []
05:46:26 <Gracenotes> doesn't do merging in the mergesort sense, but, effectively it's like map (\(a, b) -> f a b) (zip xs ys)
05:46:45 <cathper> Gracenotes: I searched for [a] -> [a] -> [a] ... and obviously didn't find it, because it's more general than I thought of.
05:46:48 <cathper> Gracenotes: I see.
05:48:23 <Gracenotes> @hoogle (a -> a -> a) -> [a] -> [a] -> [a]
05:48:25 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
05:48:25 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
05:48:25 <lambdabot> Prelude scanr :: (a -> b -> b) -> b -> [a] -> [b]
05:48:30 <zygoloid> "case <- action of ... " seems available in the grammar...
05:48:48 <Stephan202> Does anybody else have issues with ghc 6.10.4 since the upgrade to Ubuntu 9.10? If I write something of any complexity compilation fails with "ghc: panic! (the 'impossible' happened)"
05:48:52 <Gracenotes> o-o
05:49:12 <desp> Huh.
05:49:29 <Gracenotes> available, but not implemented in any way/shape/form, then
05:49:36 <zygoloid> right :)
05:49:44 <ksf> > Just 2 >> Just 4
05:49:45 <lambdabot>   Just 4
05:49:58 <ksf> > Nothing >> Just 4
05:49:59 <lambdabot>   Nothing
05:50:04 <ksf> > Just 2 >> Nothing
05:50:05 <lambdabot>   Nothing
05:50:10 <Gracenotes> a translation of \x -> case x of {...}, though, would be more general
05:50:14 <ksf> > Nothing `mappend` Just 4
05:50:14 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:50:14 <lambdabot>    `GHC.Num.Num a' arising ...
05:50:19 <ksf> > Nothing `mplus` Just 4
05:50:20 <lambdabot>   Just 4
05:50:25 <ksf> > Just 3 `mplus` Just 4
05:50:26 <lambdabot>   Just 3
05:50:26 <zygoloid> Gracenotes: still not quite as nice though imo for the monadic case
05:50:33 <ksf> that's what I want.
05:51:29 <Gracenotes> in both the monadic and general case, there's something on the argument 'stack' (still need to look at how GHC does this nowadays), and both are similar enough..
05:51:55 <Gracenotes> case <- action of {...} looks a bit like an ugly amalgamation.. not sure how many grammar rules we'd need to change for it :P
05:53:01 <Jafet> New in Haskell: point-free syntax!
05:53:19 <zygoloid> Gracenotes: probably no more than 'case of ' would require
05:54:30 <desp> Gracenotes: worked around this using when
05:54:47 <desp> Even more succint.
05:55:18 <Gracenotes> well, once it gets to case, it is already in a rule for it specifically. from that point is likely easy to distinguish between an "of" token, and any other token, which would indicate an expression followed by "of" at some point
05:57:18 <Gracenotes> vs. in a monad, when it parses x <- y, it looks for x being a pattern.. and something that's already classified as a 'case' token can't be read as an expression
05:57:34 <Gracenotes> or as a pattern. since it doesn't tokenize like that in the tokenization.
06:01:35 <Gracenotes> of course, that's more an argument from the way things currently are in the parser (changes that alter it minimally seem to be preferred). syntactic sugar is nice, though, so long as you don't get functional hyperglycemia
06:03:35 <ivanm> is there a pre-defined alias for "Either String a" ?
06:05:07 <Twey> Monad m => m a
06:05:13 <Twey> Thanks to ‘fail’
06:05:24 <ivanm> I meant more along the lines of "type Foo a = EIther String a" ;-)
06:08:13 * hackagebot upload: bindings-DSL 1.0.2 - Domain specific language for FFI description, on top of hsc2hs. (MauricioAntunes)
06:08:43 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12112#a12112
06:08:51 <ksf> the map version is clearly slower.
06:08:55 <ksf> any other ideas?
06:11:20 <ksf> well I guess someone could implement a FloatMap that exploits the binary representation.
06:11:56 <ksf> though floating point compares should be pretty fast in the first place.
06:12:11 <ksf> must be the map overhead for such small n that's killing things.
06:15:39 <Gracenotes> there is always IntMap and unsafePerformIO.. or decodeFloat, for the less unscrupulous among us
06:15:45 <Gracenotes> *unsafeCoerce, I mean
06:16:07 <ksf> well the original idea behing using map was to use it because it has split.
06:16:22 <Gracenotes> IntMap does too, doesn't it?
06:16:48 <ksf> dunno. but all would depend on the binary representation of floats preserving the ordering.
06:18:10 <ksf> ...and seriously, n=4 and n=15 aren't really what map was made for.
06:19:23 <ksf> especially because the lookup consist of solely < in the list case.
06:21:01 <Gracenotes> well.. if all the numbers are positive, the binary representation should preserve ordering
06:22:15 <Gracenotes> that was part of IEEE design. a bit hacky, but bit representation is still IntMap's strong point. I guess.
06:23:02 <ksf> all the others seem to do linear search, too, at least the fast ones.
06:23:30 <Gracenotes> if the map is fixed-size, a hand-crafted (huffman-esque) one might be better
06:23:32 <zygoloid> Gracenotes: it's no harder to recognise '->' after case than it is to recognise 'of' after case
06:23:59 <Gracenotes> but if the other ones are stored in arrays, they do have the benefit of cache-friendly locality..
06:24:17 <zygoloid> Gracenotes: and you'd desugar 'case <- x of y' into "x >>= \x' -> case x' of y", so there's no need to worry about reclassifying anything
06:24:30 <ksf> can huffman be made to work to match like that?
06:24:46 <ksf> i.e. there's less result values than possible inputs.
06:25:32 <Gracenotes> oh, so it is not specific item lookup. well, tries generally can handle ranges..
06:25:54 <Gracenotes> zygoloid: how are you defining hardness? :) In terms of rules in the parser that need to be changed, case <- x seems not-so-simple
06:25:59 <ksf> but we don't have tries in the standard lib in 6.10 afair.
06:26:13 <zygoloid> Gracenotes: how is it any harder than recognising 'case of'?
06:27:34 <ksf> also, linear search is O(n/2) as the distribution should be even.
06:28:09 <ksf> that's seven and a half times (<) you'd have to beat.
06:28:25 <Jafet> O(n/2) is O(n)...
06:30:52 <Gracenotes> zygoloid: so there is a specific rule in the parser for an expression that recognizes 'case expr of alts', with expression and alts being their own rules. You just need to change that to 'case (nil | expr) of alts', ebnf-style. What rules would have to be changed to allow case <- expr of alts, and only in monads specifically?
06:30:57 <Gracenotes> do notation, rather
06:31:20 <zygoloid> Gracenotes: who said only in do notation? i gave a translation that will work anywhere
06:31:34 <zygoloid> Gracenotes: case (nil | expr | <- expr) of alts
06:31:50 <zygoloid> expr and nil can't start with <-
06:31:53 <Gracenotes> your notation allows mine, you know :)
06:32:20 <Gracenotes> okay, that is the main problem, I think. I assumed you'd only want to put it in do notation. in my opinion, it is very inconsistent to put it anywhere else
06:33:11 <zygoloid> whenM b x = case <- b of True -> x; False -> return ()
06:33:40 <zygoloid> it'd be inconsistent to /not/ have it anywhere else i think, since it means you can't just drop the 'do' off a 1-line do expression
06:34:09 <Gracenotes> you can't just drop the do off of x <- y generally
06:34:13 <zygoloid> perhaps "whenM b x = if <- b then x else return ()" even
06:34:19 <zygoloid> Gracenotes: that's not a one-line do-expression
06:35:16 <Gracenotes> right. so why should <- be one if it uses the same syntax? it disobeys the division between one half of =<< being on one side, and one half being on the other side
06:35:42 <zygoloid> why should what be one?
06:36:30 <zygoloid> do { x } = x for all x, unless x contains a top-level semicolon.
06:36:31 <Gracenotes> sorry, it's not that it's not useful, but it seems like a hapless amalgamation of syntax, thrown together because we-felt-like-it and it-looks-pretty...
06:37:12 <Gracenotes> to me, it violates some principles I have when trying to read Haskell code, like the control flow of do blocks happening from right to left on a given line
06:37:21 <Gracenotes> when a <- is present
06:39:55 <Gracenotes> </biased aesthetic argument>
06:40:03 <zygoloid> Gracenotes: what do you mean by control flow going from right to left?
06:40:26 <zygoloid> can you give an example of that?
06:40:51 <ivanm> would postscript be considered text or binary data?
06:42:08 <Zao> Is it all in one encoding? Is there binary dung spread out in it occasionally? Hand-written PS tends to be human-readable and thus considered text.
06:42:32 <Gracenotes> e.g., I write foo <- bar. or I might write foo <- bar <$> baz, or foo <- bar =<< baz. That translates to "baz >>= return . baz >>= \foo -> ..." or "baz >>= bar >>= \foo -> .." respectively, where the control flow *there* left-to-right, as opposed to opposite in monadic <-ing
06:42:50 <ivanm> Zao: well, it's not hand-written...
06:43:07 <ivanm> and I'd also have eps to deal with
06:43:26 <zygoloid> =<< is not a valid argument since >>= is common too. <$> has no control flow since it only performs a single action. <*> is left-to-right.
06:43:46 <zygoloid> foo <- bar likewise performs a single action so there's no control flow
06:44:28 <zygoloid> in "foo <- bar; baz <- quux" control goes from bar to quux, left-to-right. "when b foo" is when, then foo. "mapM f" is mapM, then f...
06:44:32 <Gracenotes> where do you think the action is placed? :P
06:44:53 <zygoloid> to the left of / above things which happen next?
06:45:02 <gio123>  however few of them realize exactly what it is like
06:45:03 <zygoloid> fsvo happen nex
06:45:03 <gio123> to be a professional model. it is not so all gamour and riches
06:45:11 <gio123> can one correct that sentence in a vew english for me?
06:45:19 <Gracenotes> and, what do you mean, valid argument? it is my aesthetics of code.. personally, it is odd for people to write foo <- bar >>= baz. And I'm not the only one with that opinion.
06:45:58 <zygoloid> Gracenotes: aesthetics are one thing, principles used when reading general haskell code are another
06:46:10 <ksf> zomg
06:46:10 <zygoloid> i thought we were talking about the latter :)
06:46:32 <zygoloid> to be honest i'm only playing devil's advocate here; i don't really think we need to change case at all
06:46:48 <ksf> I inlined look into unroll and got down to 3.6 from 6.10
06:47:02 <Gracenotes> to further explain, though: the way I read monads is right-to-left, top-to-bottom. in your "foo <- bar; baz <- quux", foo and quux are closely bound in a single lambda abstraction, so I group them mentally
06:47:05 <zygoloid> but if we wanted a monadic case syntax, i think "case <- action of ..." whould be quite nice
06:47:15 <Gracenotes> of course, foo is also closely bound to everything *below* it
06:47:31 <mlesniak> What is the estimated time from sending a mail to haskell-cafe until it is distributed? /me wonders if sending a mail to haskell-cafe works.
06:47:33 <mtnviewmark> Gracenotes - perhaps you'd like Beta --- it's assignment construct (I know, I know, silly imperatives!)  was    <expr> -> <var>
06:47:40 <Gracenotes> so that's why I see a directionality towards the left, since it is really bound to the code below it, as things go top-to-bottom
06:47:55 <mtnviewmark> actually, I like Beta for many many reasons ---- but that was a hard one to swallow
06:48:12 <Gracenotes> mtnviewmark: personally, I like right-to-left in imperative code. in (.) chaining, as well
06:48:43 <Gracenotes> there are times left-to-right is definitely appropriate, for example when you're feeling more, well, declarative.
06:49:21 <mtnviewmark> actually, I suppose I most perfer a variant on Smalltalk's   ;  syntax
06:49:56 <ksf> I guess that's the factor 2 that I was initially worried about...
06:50:06 <mtnviewmark> Smalltalk:    msg1: rcvr and: thing and: thing; msg2
06:50:11 <Gracenotes> ah, messaging.. I hardly ever think of it any more. but that is like >>> in a sense
06:50:28 <mtnviewmark> msg2 is applied to rcvr
06:50:29 <mtnviewmark> Glyphic Script:   msg1: rcv blah blah; msg2 blah blah
06:50:34 <mtnviewmark> msg2 is applied to result of first message
06:50:42 <mtnviewmark> (;) = flip ($)
06:51:09 <mtnviewmark> only with the precedence set so it parenthesizes to the left
06:51:18 <mtnviewmark> ooo... kids are up --- laters!@
06:51:51 <Gracenotes> zygoloid: then there is still the unresolved difference, either with you or the devil's advocate, about allowing <- outside of do blocks. I see the merits of it, but also the wtf-y disadvantages
06:58:11 <infinity0> anyone here a debian haskell maintainer?
06:59:31 <ksf> is there a reason to use readIO over read?
06:59:41 <Twey> :t readIO
06:59:42 <lambdabot> forall a. (Read a) => String -> IO a
06:59:44 <Twey> :t read
06:59:45 <lambdabot> forall a. (Read a) => String -> a
06:59:52 * Twey scratches his head.
06:59:56 <ksf> maybe fail?
06:59:59 <Twey> > readIO "5"
07:00:00 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:00:01 <lambdabot>    `GHC.Read.Read a'
07:00:01 <lambdabot>      a...
07:00:05 <Twey> > readIO "5" :: IO Int
07:00:06 <lambdabot>   <IO Int>
07:00:19 <jmcarthur_work> o_O
07:00:20 <Twey> Maybe readIO can do IO in the parsing functions?
07:00:26 <Twey> No, it's still plain old Read
07:00:29 <Twey> Hmn :-\
07:00:34 <jmcarthur_work> @src readIO
07:00:35 <lambdabot> Source not found. You type like i drive.
07:00:49 <Saizan_> it just calls ioError instead of error when the parsing fails
07:01:24 <Saizan_> so it's easier to catch errors
07:04:31 <ksf> I can also do main = getArgs >>= readIO . head >>= fasta
07:04:46 <flazz> installing the haskell platform 2009.2.02 on Snow Leopard failed at the end said to contact software manufacturer. how can I figure out and possibly solve the problem?
07:05:02 <zygoloid> Gracenotes: that part i don't see. case <- and if <- would both be useful for small combinators and it would seem to make things inconsistent to forbid them...
07:06:07 <Gracenotes> I suppose they would be useful, but the only combinators they would be useful with are monadic ones
07:07:03 <ksf> hmmm. I shouldn't be adding type signatures.
07:07:13 <ksf> amount of source counts, after all.
07:07:14 * ski wonders why lambdabot has voice
07:07:19 <ksf> I should be deleting comments, too.
07:07:27 <Gracenotes> you could a more general version for applicatives, e.g. liftA (case of Omg x -> .. Wtf y -> ...) a1
07:07:33 <ksf> or do those get stripped?
07:08:01 <ksf> I bet they get stripped
07:08:23 <Gracenotes> again, with the idea in mind that the pattern \x -> case x of {...} covers a lot, and even more cases than x <- y; case x of {...} covers. *plus* it includes those latter cases, via y >>= \x -> case x of {...}
07:08:27 <ski> zygoloid : what do you mean by `case'-`<-' and `if'-`<-' ?
07:08:30 <Gracenotes> I'm not sure if I'm really saying anything new
07:08:49 <Gracenotes> what did this start about? lol ;)
07:10:39 <zygoloid> no idea :)
07:11:05 <zygoloid> ski: the idea came up that 'case <- x of y' could be sugar for "x >>= x' -> case x' of y"
07:11:25 <ski> ok
07:12:09 * ski 's (currently non-existent) "reflective syntax" cover's this use case
07:12:24 <zygoloid> ski: example?
07:12:35 <gio123> ski: i am back
07:12:52 <zygoloid> fwiw, i think if we get a 'case of' construct, we should have an 'if then' construct
07:13:59 <ski> zygoloid : sure .. but i haven't really decided on a concrete syntax
07:14:19 <zygoloid> alas :)
07:14:25 <ski> but, something with the same shape as
07:14:51 <ski>   ..(case <x> of y)..
07:15:19 <ski> (where `<x>' is what i haven't decided on syntax yet for)
07:15:30 <zygoloid> Gracenotes: i find it interesting that your suggested replacement of 'case <- act of' into 'act >>= case of' is also left-to-right :)
07:15:40 <flazz> could a borked installation of ghc messup an installation of the platform? the error i get from the failing postflight is that base-4.1.0.0 doesn't exist
07:15:48 <ski> zygoloid : the idea is to introduce *local* side-effects
07:15:58 <zygoloid> ski: idiom brackets or something?
07:16:34 <ski> so if `x :: m a' for a monad (or actually applicative functor or just functor, in some cases), then `<x> :: a' with `m'-side-effects
07:17:03 <ski> zygoloid : it was inspired by the idiom brackets, yes. but (imho) better than those
07:17:20 <Gracenotes> zygoloid: because it matches case the statements operate
07:17:37 <Gracenotes> whereas, if you have a <- present, I expect it to be right-to-left. it is a left-pointing arrow (!)
07:17:54 <Saizan_> flazz: doesn't the installer include its own ghc? /me not an OS X user
07:18:02 <Gracenotes> *matches how
07:18:37 <flazz> Saizan_: no idea, i do have a version of 6.10.1 installed
07:18:41 <Saizan_> flazz: maybe you need to unistall any previous installed ghc
07:18:48 <flazz> maybe
07:18:53 <Saizan_> "The MacOS X installer provides GHC 6.10.4 and the full tool and library suite:"
07:19:10 <ski> zygoloid : with idiom brackets, you have that  <f x0 .. xn>  translates to  pure f `ap` x0 `ap` .. `ap` xn
07:20:15 <ski> zygoloid : with my "refective syntax",  `(f x0 .. xn)  translates to  `(f) `ap` `(x0) `ap` .. `ap` `(xn)
07:20:30 <Gracenotes> otherwise, sans arrows, any direction that's consistent is nice
07:21:20 <ski> where  `(...)  is a kind of quotation operator, (it's mostly the same as the inverse to  <...>  namely  >...<  ;  i might merge them)
07:21:46 <zygoloid> Gracenotes: in "do x <- action; foo x", you don't expect foo before action. why would you in "case <- action of A -> foo x"?
07:22:11 <ski> Gracenotes : so you'd prefer `case x -> of ...' ?
07:22:13 <zygoloid> Gracenotes: in both cases let's assume the 'foo' is on the next line
07:22:32 <ski> (er, hm .. ignore that)
07:23:01 <Gracenotes> expect foo?
07:23:15 <zygoloid> ... before action
07:24:01 <Gracenotes> I would expect x before action, if there's a <-
07:24:07 <Gracenotes> among other things
07:24:24 <zygoloid> there's no 'before' relationship between x and action. x isn't an action, it's just a value
07:24:51 <zygoloid> in the left-hand case, action 'happens before' foo. and in the proposed right-hand case it does too
07:25:09 <Gracenotes> I mean syntatically
07:25:25 <Gracenotes> didn't you mean syntactically as well? :/
07:25:25 <zygoloid> syntactically the arrow points left in both cases :)
07:25:52 <Gracenotes> 'action
07:25:59 <Gracenotes> 'action' is just a value too, as well..
07:26:01 <zygoloid> in the existing case the arrow points to the left but the next thing to happen is the thing on the right
07:26:21 <zygoloid> that is, that's just not what the <- arrow means.
07:26:24 <Gracenotes> why right? code is two-dimensional, you know.
07:27:04 <zygoloid> *sigh* i was hoping you'd understand what i meant. but i can write 'to the right or below' if you prefer
07:27:10 <Twey> Unless you program in 4D
07:27:16 <Gracenotes> those two are not interchangeable in my mind
07:27:39 <Gracenotes> that is the point of asserting the left directionality of <-, based on what I said about the lambda abstraction
07:28:13 <Gracenotes> you know how there are psycholinguistics? I think we need the same thing, but for programming languages :P
07:28:26 <zygoloid> i still really don't follow your objection; what i'm suggesting works the same way as "do"
07:37:29 <Gracenotes> zygoloid: perhaps I haven't fully communicated the implicit boundaries that do blocks have for me, and implicit directionality. not sure if I can. There is still the issue of not being able to have special cases for applicative or just normal argument-stack-taking (aka application)
07:39:55 <ski> zygoloid : would you like some more explanation/example of my syntax, or are you satisfied
07:40:10 <gwern> hm. suppose I have N numbers, and I am independently running a program for each N searching a very large array.  the programs are not allowed to communicate in anyway except knowing which N they are. I was thinking of having each one get a random number and start iterating through the (unsorted) array, but is there something smarter I could do with hashes or something?
07:40:53 <Gracenotes> ski: your syntax is similar to the one in the original applicative paper?
07:41:37 <ski> Gracenotes : i would not say it is that similar (ymmv), but it was inspired by it (specifically, inspired by an idea of how to improve on it)
07:41:52 * hackagebot upload: chp 1.6.0 - An implementation of concurrency ideas from Communicating Sequential Processes (NeilBrown)
07:41:56 <gwern> I guess I want a surjective mapping from agent/N to index in the array, where each index is as far away from other indexes as possible
07:42:27 <ski> Gracenotes : the idiom/applicative brackets only translate a single "node" in the expression tree
07:43:10 <Gracenotes> ski: how would you translate, for instance, liftA2 (g . f) (foo x y) z?
07:43:57 <ski> well, i would translate code in my syntax *to* something like that, not the other way around :)
07:44:03 <ski> but like
07:44:23 <trofi^w> hia. where is 'show' package for lambdabot hosted?
07:44:32 <gwern> trofi^w: in lambdabot
07:44:34 <trofi^w> it does not compile on ghc-6.12
07:44:38 <Gracenotes> ski: the reverse translation, I (think I) mean
07:44:50 <trofi^w> same repo?
07:44:57 <Saizan_> trofi^w: yeah, a subdirectory
07:45:01 <gwern> hm. I could just divide the length by the N # of agents, and have each agent go to their fraction, but the agents don't know the total number N...
07:45:02 <trofi^w> ok
07:45:11 <gwern> huh. so I guess that doesn't work
07:45:39 <ski> like
07:45:41 <ski>   `(g (f ,(foo x y)) ,z)
07:45:55 <ski> or, using another variant
07:46:08 <ski>   > g (f <foo x y>) <z> <
07:46:26 <ski> should i step through the typing of this ?
07:46:33 <fasta> gwern, what do the "agents" know?
07:46:36 <trofi^w> my lambdabot repo contains show-0.3.1, while hackage has-0.3.3. did \bot repo moved while ago?
07:46:51 <gwern> fasta: they know their individual m, where m is a number from 0-N, let's say
07:47:16 <gwern> "I'm agent 3 and I'm searching this array, but where to start? I don't know how many other agents there are or even if there are any others!"
07:47:22 <Saizan_> gwern: do each have the full array?
07:47:37 <gwern> Saizan_: yeah, but it's read-only, so no modifications to communicate :)
07:47:45 <trofi^w> @version
07:47:45 <lambdabot> lambdabot 4.2.2.1
07:47:46 <lambdabot> darcs get http://code.haskell.org/lambdabot
07:47:47 <Saizan_> each could look at the i-th indexes
07:47:57 <Saizan_> not quite locality friendly i guess though
07:48:15 <fasta> gwern, then all they can do is look in some kind of environment and if this environment is read-only there is nothing they can do, so they all have to start at 1.
07:48:50 <gwern> Saizan_: but if agents 1-5 look at 0-4, and the target is actually way the hell down at length-1, then we'll get something like 5*(length-6) useless array searches because they'll repeat each other
07:48:54 <ski> Gracenotes : i'll do it anyway :)
07:49:03 <fasta> gwern, if you don't know whether some work has already been performed, and it has to be done, there is only one thing it can do.
07:49:13 <gwern> Saizan_: at that point they might as well ask their random source for an index to start at
07:49:16 <fasta> gwern, since, as you said, it doesn't know about any other agents.
07:49:18 <ski> assume
07:49:23 <ski>   Applicative i
07:49:26 <ski>   x :: a
07:49:31 <ski>   y :: b
07:49:52 <fasta> gwern, it sounds like a very artificial restriction.
07:49:58 <Gracenotes> hm
07:49:59 <ski>   foo :: a -> b -> i c
07:50:03 <gwern> fasta: why start at 1? a random index is superior to that, I'd think
07:50:10 <ski>   f :: c -> d
07:50:18 <Saizan_> gwern: i wasn't suggesting that, but now i realize what i was suggesting needs to know the number of agents, so nvm
07:50:19 <ski>   z :: i e
07:50:27 <ski>   g :: d -> e -> f
07:50:28 <ski> then
07:50:38 <gwern> fasta: well, it is very artificial since it's a thought problem on when/whether randomness can make a better algorithm than a deterministic one
07:50:38 <ski>   foo x y :: i c
07:50:48 <fasta> gwern, how does the agent know it is done?
07:50:50 <ski>   <foo x y> :: c  -- with `i'-side-effects
07:50:52 <CosmicRay> cabal install question.  over at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12094#a12094 I see that EnglishGent was trying to install HDBC, and cabal pulled convertible 1.0.5, even though 1.0.6 has been in hackage for a week or so.  any ideas why?
07:51:03 <ski>   f <foo x y> :: d  -- with `i'-side-effects
07:51:05 <fasta> gwern, you just don't have a well-specified problem.
07:51:11 <gwern> fasta: ah, well I guess besides the array and its number the agent also knows the target
07:51:13 <ski>   <z> :: e  -- with `i'-side-effects
07:51:24 <Saizan_> trofi^w: i guess someone forgot to record the version bump
07:51:28 <ski>   g (f <foo x y>) <z> :: e  -- with `i'-side-effects
07:51:37 <ski>   > g (f <foo x y>) <z> < :: i e
07:51:45 <trofi^w> Saizan_: ? they even have different source file count
07:51:46 <fasta> gwern, so, you have a bunch of blind agents who open boxes and when their hand is bitten off, they yell "eureka"?
07:51:53 <ski> Gracenotes : that's the types
07:52:03 <fasta> gwern, and you want to get a band bitten off as fast as possible?
07:52:04 <Gracenotes> hm, I see
07:52:06 <gwern> three blind mice, three blind mice...
07:52:06 <trofi^w> Saizan_: looks like lambdabot's one is older
07:52:26 <gwern> fasta: well, that's one way of putting it...
07:52:32 <Gracenotes> ski so it's hardly just syntactical
07:52:47 <fasta> gwern, CS people like examples with violence ;)
07:52:54 <ski> Gracenotes : now, i have typing rules, and translation rules for other constructions than variables and applications too, of course
07:53:13 <bastl> how can I direct cabal /ghc/whatever to use such compiler flags and libs: https://wiki.ubuntu.com/XulrunnerGecko#Standalone%20Applications ? (I'm having very technical problems with ubuntu 9.10 and gtk2hs/html-embedding ... )
07:53:20 <ski> Gracenotes : yes. side-effects is just a POV, a matter of which syntax you use :)
07:53:28 <dcoutts> CosmicRay: two possible reasons: if HDBC-2.2.1 was uploaded before convertible-1.0.6 and he updated his package list between then convertible-1.0.5 may have been the latest version for him. If he already had convertible-1.0.5 installed then cabal will prefer the installed one, but it may have decided that it needed to be rebuilt to get consistent dependencies.
07:53:53 <dcoutts> CosmicRay: if HDBC-2.2.1 actually needs convertible-1.0.6 and will not work with convertible-1.0.5 then it should say so in the .cabal file.
07:53:54 <ski> (Gracenotes : or did i misunderstand what you meant ?)
07:54:05 <gwern> I was thinking about a hash of the agent's number, but then I realized I don't know if a hash would be surjective (assuming the right length to turn it into an index)
07:54:11 <fasta> gwern, starting at a random index will probably help, yes, but you cannot pick a random index all the time.
07:54:26 <fasta> gwern, if you do, it will only terminate with probability 1.
07:54:27 <CosmicRay> dcoutts: ok.  I'm pretty sure convertible 1.0.6 was uploaded first.  no, HDBC doesn't require convertible 1.0.6, but that version of convertible fixes the infamously annoying time instances bug
07:54:44 <dcoutts> CosmicRay: the behaviour of "cabal install" is to use already installed packages when possible, "cabal upgrade" will try to use the latest versions of dependencies
07:55:00 <Gracenotes> ski: well, it's not just copy+pasting parts of the parse tree, right?
07:55:01 <CosmicRay> ok.
07:55:06 <gwern> fasta: true enough. I figured that what one would do is take a random index and then go down the array, wrapping around.
07:55:12 <ski> Gracenotes : the translation rules are guided by the abstract syntax, however there's are a few cases where you need some help from type-system if you want a nice general syntax
07:55:13 <dcoutts> CosmicRay: though the current problem with upgrade is it's a bit too eager and will try to upgrade your core packages :-)
07:55:22 <dankna> ah, somebody ran into the time instances problem yesterday
07:55:30 <CosmicRay> dcoutts: fun :-)
07:55:36 <ski> Gracenotes : i'm not sure what you mean by "copy+pasting parts of the parse tree" ?
07:55:43 <fasta> gwern, does this have anything to do with the real world?
07:55:54 <CosmicRay> dankna: if that comes up again, make sure they've got the latest convertible and HDBC versions from hackage.  1.0.6 and 2.2.1.
07:55:58 <dankna> will do
07:56:02 <CosmicRay> thanks
07:56:04 <gwern> fasta: I suppose it might be a relevant question in massively parallel systems
07:56:13 <fasta> gwern, not really.
07:56:17 <gwern> where one cannot afford communication
07:56:21 <Gracenotes> ski: ah.. that answers my question :)
07:56:26 <CosmicRay> I had EnglishGent cabal-install convertible-1.0.6 and retry his HDBC install.  I think that'll get it.
07:56:27 <zygoloid> ski: yes, i think i understand what your syntax would mean, and i think i like it. i guess there'll be cases where the translation is impossible for non-obvious reasons though?
07:56:37 <dankna> gotcha, sounds good
07:56:42 <Gracenotes> that's pretty neat. might take some practice used to it.
07:56:45 <Gracenotes> +to
07:56:46 * gwern finds it funny fasta asks about practicality. practicality? THIS IS #HASKELL!!!
07:56:51 <fasta> gwern, in massively parallel systems you would just tell every agent the space it has to search.
07:56:52 <Gracenotes> er, +to get
07:57:09 <ski> zygoloid : well, translating lambda expressions is a bit tricky .. but i think my solution will work
07:57:17 <fasta> gwern, or you would have an operation to see whether a box has already been opened.
07:57:20 <dcoutts> CosmicRay: I bet what is happening is that chap had convertible-1.0.5 built against time-1.1.3+ but then when he installs HDBC-2.2.1, that version of HDBC requires time<1.1.3 and so cabal-install rebuilds convertible against time-1.1.2.4 in an attempt to get consistent deps.
07:57:31 <gwern> fasta: well to know that you need to know N, right? but what if N is dependent on how many servers get freed up during your long-running search of the array?
07:57:38 <gwern> you couldn't know that beforehand
07:57:42 <zygoloid> Gracenotes: fair enough. i think the 'what about applicative?' argument is a good one, fwiw
07:57:59 <CosmicRay> dcoutts: understandable but weird.  so should I make HDBC dep on convertible >= 1.0.6 even though it doesn't strictly need it?
07:58:06 <zygoloid> although the answer is, this isn't possible with applicative, i think ;)
07:58:19 <fasta> gwern, what exactly is N here?
07:58:23 <ski> zygoloid,Gracenotes : btw, note that i'm not at all suggesting that a function of type `A -> B' could now have `i'-side-effects .. this implies that in `\x -> ..x..', the `..x..' must be pure (which can be achieved by using `>...<' inside it)
07:58:29 <gwern> fasta: the total number of agents running on the array
07:58:32 <zygoloid> ie, branching based on a wrapped value is exactly what monad gives over applicative
07:58:45 <fasta> gwern, so, N is dynamic.
07:58:56 <zygoloid> ski: it sounds a lot like an explicit effects typing system. (have you seen disciple?)
07:59:17 <gwern> we might start off with just a few servers available, N=5, but suddenly it's 1AM and the whole east coast has dropped off to sleep and now a couple thousand servers are availble and N shoots up to >1k (though we're still searching the array because it's a very big array)
07:59:20 <ski> zygoloid,Gracenotes : so, effect-ful computations will still have types like `A0 -> A1 -> ... i An' .. it's just that "locally" inside a single expression, you may have (delimited) side-effects
07:59:23 <Gracenotes> zygoloid: oh, you can still branch with applicative. it's not an effectful branching, but if you're using applicative, you're not interested in effectful branching so much
07:59:59 <zygoloid> Gracenotes: right, but "case <-" /is/ effectful branching since the branch values must be in the monad
08:00:18 <ski> zygoloid : what isn't possible with applicative ?
08:00:26 <fasta> gwern, well, it really depends on a lot of things, but I am pretty sure these problems have already all been solved.
08:00:37 <Gracenotes> yes.. and perhaps too specific a case
08:00:55 <ski> zygoloid : no, i haven't seen disciple (i've looked at a few effect systems, if that helps)
08:01:01 <fasta> gwern, it is basically a scheduling system and those have elaborate solutions already.
08:02:27 <zygoloid> ski: branching the computation depending on a value produced by it. that is, 'do x <- action; case x of ...'
08:02:51 <ski> Gracenotes : one nice thing is that if you have `> ..(f x).. <' where the path down to `f x' doesn't contain a `<...>' or `>...<'; then if you find you need to use an effect in place of `f x', you can change it into `<g x>'
08:03:29 <ski> Gracenotes : whereas if you used `liftA2' and friends, you would need to annotate the whole path down to the sub-expression with lifting functions
08:04:03 <ski> (this probably matter most for large expressions, though .. maybe like a large single parser definition)
08:04:19 <ski> zygoloid : ok
08:05:51 <IceDane> Am I mistaken by thinking that if I have a function defined as such: function :: (Integral a) => a -> a, and it returns a length of a list, it should work?
08:05:52 <ski> in my syntax `do x <- action; ..x..' can be written as `let x = <translated_action> in ..x..' (all within some outer `>...<' to delimit the effects)
08:06:13 <IceDane> Because i'm getting complaints from ghci about the inferred type Int not matching my rigid type signature 'a'
08:06:16 <Saizan_> IceDane: yes, because length :: [a] -> Int
08:06:38 <Saizan_> IceDane: your function promises to be able to return any type that is an instance of Integral
08:06:44 <IceDane> I thought so
08:06:50 <Saizan_> IceDane: not just a particular instance
08:06:51 <ski> if the applicative functor (or monad) isn't "commutative", then `f <x> <y>' and `flip f <y> <x>' need not be the same, though
08:07:13 <IceDane> But it isn't working for some reason. If I post my code, will you be willing to look at it?
08:07:15 <Saizan_> IceDane: you can use fromIntegral to convert an Int to any Num, so also any Integral
08:07:33 <yesmanreturns> hello
08:07:39 <Saizan_> IceDane: when i said "yes" i meant that you're mistaken
08:07:42 <ski>   fmap f <x> = <f x>  -- circular definition, via the translation :)
08:08:11 <IceDane> Saizan_: How so?
08:08:19 <yesmanreturns> asd
08:08:26 <Saizan_> IceDane: have you read my lines above?
08:08:50 <IceDane> Yes, but I don't know what you mean by "not just a particular instance"
08:09:14 <IceDane> This is how i'm looking at it: Int is a subclass of Integral, length returns int thus it should work?
08:09:26 <Saizan_> no Int is not a subclass of Integral
08:09:34 <Saizan_> Integral is not a type
08:09:52 <ski> and `Int' is not a class
08:10:07 <Saizan_> Integral is a typeclass, i.e. a set of types if you want
08:10:16 <IceDane> Yes, that's pretty much what I meant
08:10:35 <IceDane> I read somewhere that Integral co
08:10:39 <IceDane> 'contains' Int and Integer
08:10:40 <IceDane> no?
08:10:46 <ski> yes
08:10:53 <Saizan_> your type signature Integral a => a -> a, says that your function has to work for any type that's an instance of Integral
08:11:06 <Saizan_> so it should work for e.g. both Integer and Int
08:11:10 <Saizan_> not just one of them
08:11:22 <IceDane> Ah..
08:11:26 <IceDane> Oh, I see
08:11:26 <Saizan_> it will be the caller to choose which type it wants
08:11:37 <ski> but `function :: (Integral a) => a -> a' promises to return a value of type `a', (for a type `a' in class `Integer',) for any type `a' the *caller* of `function' wants
08:12:00 <IceDane> i see..
08:12:01 <IceDane> Hmm.
08:12:05 <ski> if you want `function' to decide what type `a' to use, then either say which type you want
08:12:12 <Saizan_> s/class `Integer'/class `Integral'/
08:12:27 <ski> ty
08:13:12 <ski> otherwise, you might want `function :: exists a. Integral a *> a -> a' .. but that syntax doesn't work, but it can be emulated more or less, if you need the behaviour
08:13:12 <EnglishGent> is there a way to get a list of all the modules cabal has obtained?
08:13:20 <Saizan_> ?type fromIntegral (length [])
08:13:21 <lambdabot> forall b. (Num b) => b
08:13:33 <Saizan_> ?type fromIntegral (length []) :: Integer
08:13:34 <lambdabot> Integer
08:13:37 <Saizan_> ?type fromIntegral (length []) :: Int
08:13:38 <lambdabot> Int
08:13:47 <dancor> ?type fromIntegral (length []) :: String
08:13:48 <lambdabot>     No instance for (Num String)
08:13:48 <lambdabot>       arising from a use of `fromIntegral' at <interactive>:1:0-23
08:13:48 <lambdabot>     Possible fix: add an instance declaration for (Num String)
08:14:02 <franksh> http://www.youtube.com/watch?v=O2rGTXHvPCQ my next haskell project has to be writing an irc client true to this clip.
08:14:04 <ski> (that latter type promises that `function' will choose some type `a' that lies in class `Integral', and expect you to pass an element of that type, and it will return a new element of the same type)
08:16:53 <dancor> franksh: z0mg
08:19:58 <franksh> you can't find me, i'm using hundreds of IPs. but please don't screenshot.
08:20:37 <IceDane> I've been reading what you guys said, but I'm not sure I understand yet.. http://icedane.pastebin.com/m494f6f45, here's the code. Why is it that I cannot return an int when it's a 'subclass' of Integral ?
08:21:32 <IceDane> Keep in mind I've been doing haskell for a couple of days
08:21:38 <IceDane> And I'm coming from C/C++
08:21:47 <bastl> mmorrow: thanks for the hint. sadly it doesnt work for me: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4927#a4932
08:22:01 <dancor> IceDane: would you rather your function work with both Int and Integer, or just Int?
08:22:11 <dancor> you have to make that decision
08:22:23 <Lemmih> IceDane: You're saying that 'countDivisors' can return any Integral. However, 'length' doesn't return any Integral. It returns an Int.
08:22:44 <EnglishGent> yay!
08:22:52 <Cale> IceDane: You can convert an Int to any numeric type (type which is in the class Num) using fromIntegral
08:23:04 <Cale> IceDane: But it doesn't happen automatically.
08:23:10 * EnglishGent succeeds in persuading Haskell & Postgres to play nice together (with help from CosmicRay) :)
08:23:10 <IceDane> Oh, so it's ambiguity?
08:23:13 <Cale> IceDane: and Integral isn't itself a type
08:23:22 <CosmicRay> EnglishGent: yay :-)
08:23:26 <EnglishGent> hi IceDane :)
08:23:28 <Cale> IceDane: It's a condition which may or may not be true for any given type
08:23:35 <EnglishGent> welcome to the wonderful world of Haskell!
08:23:37 <Lemmih> IceDane: It's more of a type error.
08:23:38 <ksf> does anyone know who wrote the writeFasta routine?
08:23:40 <IceDane> I guess just Int works, how can I make it to return just Int?
08:23:45 <IceDane> EnglishGent: Haha, thansk =)
08:23:45 * EnglishGent still quite a newbie himself :)
08:24:06 <ksf> I'm wondering why it's that complex, it's manually reimplementing a lot of functionality that's in lazy bytestrings.
08:24:16 <Lemmih> IceDane: countDivisors :: (Integral a) =>  a -> Int
08:24:30 <ksf> one possible reason might be that using Int64 on 32 bit architectures is slow.
08:24:40 <Cale> IceDane: Ah, the problem is that length is stupidly not polymorphic
08:24:41 <ksf> but I'd be surprised if that were a big factor
08:25:15 <Cale> IceDane: So if you want that type, you need genericLength or apply fromIntegral to the whole thing
08:25:50 <ksf> Cale, thanks for the hint.
08:26:10 <ksf> ...but lazy bytestrings don't come with generic*
08:26:12 <Cale> ksf: oh!
08:26:13 <IceDane> Cale: I see.. Thanks =)
08:26:19 <Cale> ksf: heh, I was talking to IceDane
08:26:56 <Cale> ksf: I think the fasta stuff maybe grew out of stuff written for the shootout?
08:27:05 <IceDane> There we go - I guess all the intense reading caused me to forget the fact that I could put -> Int directly
08:27:25 <Cale> IceDane: another option is to delete the type signature and see what ghci infers
08:28:00 <IceDane> That works as well, I see
08:28:05 <IceDane> well, thank you very much =)
08:28:36 <ksf> Cale, yes I'm working on it.
08:28:45 <ksf> it's already about twice as fast.
08:29:02 <ksf> and now I'm cleaning up the code while waiting for inspiration.
08:33:22 <ksf> wait tuples aren't unboxed.
08:35:34 <IceDane> Is it possible to use function composition on comparative operators and a custom function? I'm trying to use takeWhile (500> . countDivisors) setOfNumbers
08:35:37 <IceDane> Basically
08:36:00 <ksf> > (>) 10 2
08:36:01 <lambdabot>   True
08:36:13 <ksf> > (not . (>)) 10 2
08:36:15 <lambdabot>   Couldn't match expected type `t1 -> t'
08:36:15 <lambdabot>         against inferred type `GHC.B...
08:36:23 <ksf> > (not . (>10 )) 2
08:36:25 <lambdabot>   True
08:36:33 <idnar> IceDane: I think that's fine, except you need extra parens around (500>)
08:36:37 <ksf> well pointless pain always wins.
08:36:41 <IceDane> I see
08:36:42 <dancor> > ((not .) . (>)) 10 2
08:36:43 <lambdabot>   False
08:36:44 <idnar> @type ((500>) . ?f)
08:36:46 <lambdabot> forall t (f :: * -> *). (Num t, Ord t, ?f::f t, Functor f) => f Bool
08:36:55 <IceDane> Holy ****
08:36:56 <dancor> it's too bad that (f .) . is so arcane looking
08:36:58 <IceDane> I have so much to learn
08:36:59 <IceDane> man.
08:37:03 <idnar> bah
08:37:05 <idnar> @type takeWhile ((500>) . ?f)
08:37:07 <lambdabot> forall t a. (Num t, Ord t, ?f::a -> t) => [a] -> [a]
08:37:15 <dancor> idk if i should just internalize it or not
08:38:33 <jmcarthur_work> dancor, result = (.)
08:39:05 <jmcarthur_work> @where SEC
08:39:05 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
08:39:07 <dancor> > (result not . (>)) 10 2
08:39:09 <lambdabot>   Not in scope: `result'
08:39:32 <jmcarthur_work> it's not defined anywhere common afaik except internally sometimes
08:39:42 <dancor> @let result = (.)
08:39:43 <lambdabot>  Defined.
08:39:45 <dancor> how would you use it here
08:40:03 <jmcarthur_work> you could either do it the way you just tried, or you could do (result.result) (>)
08:40:21 <jmcarthur_work> i recommend reading the SEC link above
08:40:40 <dancor> (result.result) (>)  has no not in it..
08:40:45 <jmcarthur_work> err
08:40:52 <jmcarthur_work> (result.result) not (>)
08:41:49 <jmcarthur_work> "apply not to the result after applying two arguments to (>)" or something like that, is how i would read it
08:42:13 <IceDane> Since I'm here, do you guys have any favorite text editors for haskell?
08:42:17 <gwern> hm. would it be correct to say that 'given a fixed string n, and a set of unique bitstrings m..z, xoring each of m..z by n will not create any duplicates'?
08:42:30 <jmcarthur_work> IceDane, i use emacs with haskell-mode
08:42:33 <gwern> IceDane: emacs, yi
08:42:37 <jmcarthur_work> it's my favorite for haskell
08:42:37 <gwern> leksah seems good too
08:42:44 <IceDane> Hmm
08:42:44 * alvarezp is away: 
08:42:48 <IceDane> I'll have to check emacs out
08:43:11 <dancor> i think almost everyone uses emacs,vim,leksah,yi
08:43:25 <jmcarthur_work> probably in that order
08:43:36 <dancor> probably
08:43:41 <jmcarthur_work> there might be a few textmate users
08:45:06 <tromp_> there may well be more vi than emacs users
08:45:10 <IceDane> I should so have started looking at this language a long time ago
08:45:19 <burp> vim,emacs,leksah,yi
08:45:23 <burp> maybe in that order?
08:45:25 <tromp_> emacs not installed everywhere
08:46:47 <ksf> oh hell xs == [] requires Eq a => [a]
08:46:51 <ksf> the pattern match doesn't.
08:47:07 <jmcarthur_work> generally, sure, but i think a larger number of haskell users install and use emacs than just stick with vi/vim
08:47:22 * dancor doesn't know either way
08:47:29 <jmcarthur_work> i'm just guessing
08:47:33 <Saizan_> ksf: null
08:47:42 <dancor> everyone not using yi is a traitor to the cause anyway ;)
08:47:43 <burp> don't know either ;-)
08:47:56 <jmcarthur_work> or leksah, you mean?
08:48:01 <ksf> Saizan_, thanks
08:48:30 <tromp_> ok, i'll try install yi right now
08:48:34 <Kim^Walkman> Texmate after using emacs for a month (installed it purely for haskell)
08:48:58 <ksf> hell 2.27s
08:49:20 <jmcarthur_work> Kim^Walkman, how is textmate for haskell? i tried it a few years ago and the haskell plugin from svn wasn't very polished, imo
08:49:44 <jmcarthur_work> ksf, what are you optimizing?
08:49:55 <mreh> @seen Cale
08:49:56 <lambdabot> Unknown command, try @list
08:50:04 <jmcarthur_work> seen is fail right now
08:50:09 <mreh> whoes bot likes @seen?
08:50:15 <ksf> jmcarthur_work, the fasta benchmark.
08:50:19 <jmcarthur_work> ah
08:50:24 <ksf> I started out with 6.27 seconds
08:50:25 <jmcarthur_work> yeah, i avoid that one ;)
08:50:33 <jmcarthur_work> ooh, nice improvement then
08:50:45 <Kim^Walkman> There's nothing wrong with emacs, I just found that some things in textmate (project drawer, rectangular selection and editing on the top of my head) is so easy to use that it made me switch, but it was a nice battle
08:50:51 <jmcarthur_work> you working a fresh implementation or optimizing the existing?
08:50:57 <ksf> optimizing.
08:50:59 <Cale> hello
08:51:15 <Cale> preflex: seen Cale
08:51:16 <mreh> Cale: hello
08:51:16 <preflex>  Cale was last seen on #haskell 16 seconds ago, saying: hello
08:51:32 <mreh> Cale: I need Mathematica debugging
08:51:38 <Cale> :)
08:51:40 <Kim^Walkman> jmcarthur_work: I only use… well… syntax highlightning and that's about it; has some quirks but not enough to make me switch
08:51:51 <jmcarthur_work> ah
08:51:52 <mreh> the thing wont break on a "Message"
08:52:12 <tromp_> darn; install failed
08:52:18 <jmcarthur_work> i don't even code on my mac that much anymore, so textmate just fell completely off my radar
08:52:51 <tromp_> cabal: alex version >=2.0.1 && <3 is required but it could not be found.
08:53:07 <jmcarthur_work> woah, textmate 2.0 is *still* not done? did the developer abandon it or something?
08:53:07 <tromp_> well, i just did a cabal update?!
08:53:11 <ksf> ah the joy of looking at core and seeing a field of #s
08:53:12 <dcoutts> tromp_: check the cabal bin dir is on your $PATH
08:53:55 <Kim^Walkman> jmcarthur_work: Naw, he's just slow
08:54:12 <tromp_> the dir of binary /home/tromp/opt/bin/cabal is on my path
08:54:12 * ksf should switch those lists over to UArrays
08:54:27 <dcoutts> tromp_: then cabal install alex
08:54:38 <jmcarthur_work> ksf, you are allowed to import non-base libraries like that?
08:54:47 <tromp_> i thought cabal was alrd trying to do that
08:54:52 <jmcarthur_work> oh wait, nevermind
08:54:56 <jmcarthur_work> i was thinking uvector
08:55:08 <tromp_> hmm, apparently not
08:55:09 <dcoutts> tromp_: it only does deps on libs at the moment, not deps on tools like alex
08:55:14 <Kim^Walkman> It was the first time I used emacs (ever) though, so it was a nice experience and on any other platform than Mac that's what I use nowadays
08:55:34 <dcoutts> tromp_: so you've changed the cabal config to install (or symlink) binaries into /home/tromp/opt/bin/ then?
08:55:38 <ksf> everything that ships with ghc should be fine.
08:55:55 <tromp_> yes
08:56:16 <tromp_> wait
08:56:25 <tromp_> Installing executable(s) in /home/tromp/.cabal/bin
08:56:32 <ksf> should I investigate how to make UArray eat (Word8,Float) or just use two?
08:56:40 * ksf guesses using two.
08:56:45 <ksf> alignment and everything.
08:56:46 <tromp_> so i need that in my path?!
08:57:35 <dcoutts> tromp_: or configure cabal's bindir or symlink-bindir to somewhere that is on your $PATH
08:57:44 <dcoutts> tromp_: the setting is in the ~/.cabal/config
08:57:58 <mtnviewmark> is the expectation that instances of Show use show (or showPrec) to produce human readable or Haskell compilable strings or things that can be Read?
08:58:13 <tromp_> thanks, dcoutts
08:58:30 <tromp_> oops, another failure
08:58:51 <ksf> @hoogle unsafeAt
08:58:51 <lambdabot> No results found
08:59:06 <tromp_> Yi/Prelude.hs:182:9: Duplicate instance declarations: instance Category Accessor.T -- Defined at Yi/Prelude.hs:182:9-38
08:59:07 <tromp_>       instance Category Accessor.T
08:59:07 <tromp_>         -- Defined in data-accessor-0.2.1:Data.Accessor.Private
09:00:22 <Saizan_> tromp_: i'd try with --contraint="data-accessor < 0.2.1"
09:00:30 <gwern> http://www.reddit.com/r/compsci/comments/a2zow/ask_compsci_what_is_the_smallest_or_easiest_or/c0fqvn0 <-- I can't believe I've been working on this comment for 3 days
09:00:31 <byorgey> tromp_: looks like probably your version of data-accessor is too new, and Yi doesn't specify an upper bound on the version
09:00:38 <ksf> so, how do I unsafely index an array?
09:00:38 <byorgey> yeah, what Saizan_ said
09:00:48 <ksf> If you aren't stopping me I'm going to use peek!
09:00:57 <gwern> ksf: just stick it in, cowboy
09:01:31 <jmcarthur_work> mtnviewmark, if it can't be read i usually consider it flawed, and i generally prefer that it mirror haskell syntax. i don't know about whether there is an *official* rule about this
09:01:45 <tromp_> specifying an upper bound wold be weird; you expect future versions to be backward compatible
09:01:58 <mtnviewmark> "can't be read" - you mean by humans, yes?
09:02:22 <mtnviewmark> or do you mean "read" function?
09:02:44 <byorgey> tromp_: that's not true at all.
09:02:50 <jmcarthur_work> i mean read function
09:02:54 <dcoutts> tromp_: that's what the PVP is for, to say what future versions are not expected to be compatible
09:03:03 <IceDane> When you guys have haskell-mode installed for emacs, is the "haskell" menu at the top supposed to be.. empty? E.g. no items?
09:03:06 <IceDane> heh
09:03:19 <mtnviewmark> got it - thanks -
09:03:25 <jmcarthur_work> mtnviewmark, i usually reserve show/read for debugging and use other functions for pretty printing
09:03:26 <fasta> mtnviewmark, there have been lots of discussions about it. If you do (read.show) x == x then you can be sure it is ok, but if you don't, what are they going to do to you?
09:03:29 <tromp_> ah, ok
09:03:30 <ksf> ah it's just undocumented in the haddock.
09:04:14 <mtnviewmark> okay, for now I did a pretty print implementation and had   show = render . prettyThing
09:04:45 <mtnviewmark> which is nice for humans, but would never read back in --- and, fie, pretty print rendering isn't (can't be) lazy
09:04:59 <mtnviewmark> BUT - I've got a type with hidden constructors
09:05:12 <mtnviewmark> so I can't do the simple thing....
09:05:27 <jmcarthur_work> mtnviewmark, you could compromise and do what Set and Map do, maybe
09:05:31 <mmorrow> @tell bastl RE: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4927#a4932 , it's not smart enough to recongize higher-kinded type arguments (like the first arg of your "PFAST" datatype, but i think doing s/(Show a_2)/(Show (a_2 Expr))/ in the instance constraint would work (?)
09:05:32 <lambdabot> Consider it noted.
09:05:38 <jmcarthur_work> mtnviewmark, they show as fromList [...]
09:05:46 <mtnviewmark> ah -
09:06:11 <jmcarthur_work> you can't derive Read if you implement Show like that, of course
09:06:19 <jmcarthur_work> would have to write both manually
09:06:31 <mtnviewmark> seems odd that if one goes to the trouble to make sure that show produces a valid haskell expression --- that then you have to go to the trouble to hand parse that in read!
09:06:40 <jmcarthur_work> yeah
09:06:44 <mtnviewmark> but I suppose at run time there isn't a haskell compiler....
09:06:53 <luqui> how do I fork a process and send it some data I have via stdin?
09:06:54 <mmorrow> (you just have to make a matching Read of course)
09:06:56 <Cale> mtnviewmark: You could of course link against GHC ;)
09:07:06 <jmcarthur_work> i think the idea is you can copy something from Show and then eval it in ghci by pasting
09:07:06 <Cale> mtnviewmark: Or use something like hint
09:07:14 <Cale> But yes, that would be overkill :)
09:07:14 <doublethink_work> luqui: System.Process.readProcess will work probably
09:07:21 <doublethink_work> @hoogle readProcess
09:07:22 <lambdabot> No results found
09:07:23 <doublethink_work> :(
09:07:34 <luqui> doublethink_work, thanks :-)
09:07:36 <jmcarthur_work> there's always a cost though
09:07:41 <doublethink_work> http://hackage.haskell.org/packages/archive/process/1.0.1.1/doc/html/System-Process.html#v%3AreadProcess
09:07:46 <jmcarthur_work> i have made "bad" Show instances and don't regret it
09:07:52 <jmcarthur_work> would have been too difficult otherwise
09:08:29 <mtnviewmark> oooo --- it's like Haskellers Anonymous: "Hi, my name is Clark, and I've made a Show instance that doesn't Read..."
09:08:43 <fasta> It's also not a very important question. It's not like parsing something is difficult.
09:11:06 <gwern> doublethink_work: hoogle doesn't cover unix/windows-specific libs, I think
09:11:31 <doublethink_work> gwern: that's the process library though; it works on windows and linux
09:12:57 <Saizan_>  @hoogle doesn't query the website, it uses a local index
09:13:47 <gwern> hm. ok, so then it's that ndm doesn't bundle all the .hoos from the server into the hoogle sdist
09:15:03 <aug_triad> Hi. Does anybody knows which representation for the key signature in Codec.Midi? The key of the midi file should be located in KeySignature !Int !Int, but the source code it very hard to understand and there are no documentation. http://hackage.haskell.org/packages/archive/HCodecs/0.1/doc/html/Codec-Midi.html
09:15:35 <aug_triad> E.g. what is the representation of the key C?
09:17:04 <Twey> Don't think MIDI works like that
09:17:29 <Twey> It gives integers representing frequency, IIRC
09:17:53 <c_wraith> maybe I'll have more luck at this time of day.  Anyone know how to optionally match oef in uu-parsinglib?  pEnd swallows the parser state if it succeeds, which isn't what I want.
09:18:26 <aug_triad> Hmm... Ok, so there are no easy way of getting the key of a midi file?
09:18:50 <aug_triad> *is
09:19:08 <c_wraith> err.  that should have been *eof.  Man, my typing is bad in the morning
09:22:59 <Vanadium> öf
09:24:12 <c_wraith> I thought uu was in holland. :P
09:26:29 <ksf> ...unsafely indexed uarrays seem to be _slower_ than a list of unboxed tuples.
09:27:36 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12116#a12116
09:27:41 <ksf> or am I doing something wrong?
09:29:10 <ksf> well I could count from the top and compare with zero...
09:34:31 * hackagebot upload: wxcore 0.12.1.1 - wxHaskell core (JeremyODonoghue)
09:36:11 <ski> mtnviewmark : it would be nice with a combined parsing and (possibly pretty-) printing library, which creates both a parser and a printer (compatible), with a single source
09:41:04 * cads has fallen in love with the G-code language
09:41:48 <burp> G is an alias for haskell?
09:41:56 <cads> who needs turing completeness when you can write code converts titanium into $$$
09:43:08 <Baughn> burp: It.. /shouldn't/ be, but it might be
09:43:08 <lambdabot> Baughn: You have 1 new message. '/msg lambdabot @messages' to read it.
09:43:12 <Baughn> @messages
09:43:13 <lambdabot> ivanm said 4h 23m 41s ago: slight problem with Haskell-mode: when I want to explicitly import a few things, I have something like "import Foo( blah\n, baz)", where the , is aligned with the ( ...
09:43:13 <lambdabot> the indenter in indentation doesn't like that :s
09:43:33 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12117#a12117
09:43:44 <cads> burp, g-code is an old language for controlling machines that cut materials according to tool paths that are programmed
09:44:06 <ksf> there's some inefficiency left while passing the data between unroll and look/choose/rand, but I'm not sure how to tackle it best
09:44:11 <burp> ok
09:44:35 <ksf> and I'm quite annoyed by the fact that the shorter version of writeFasta is slower.
09:47:46 <ksf> in fact, the program is heavily IO-bound.
09:48:26 <ksf> nope
09:48:31 <ksf> I'm talking nonsense
09:48:59 <Cale> aug_triad: hmm
09:49:42 <Cale> aug_triad: Actually MIDI represents notes as positive integers in terms of a semitone scale starting from some note... I think it was some low C.
09:50:18 <ksf> yep if there's a key, it's metadata.
09:50:42 <Cale> I think the fields labelled "key" actually mean which key on a keyboard :)
09:51:01 <ksf> but I can octave-switch mine.
09:51:18 <ksf> and there's a funky pitch and effect wheel.
09:51:22 <Cale> To *discover* the key of a midi file by doing analysis on what notes occur in it would be interesting.
09:51:27 <aug_triad> Cale: Yes, the notes are represented in that way, but the key signature is the key of the overall melody
09:51:41 <ksf> I wouldn't trust that data.
09:52:13 <aug_triad> But Sibelius knows the key when importing a midi file...
09:52:18 <Cale> hmm
09:52:36 <Cale> It might do something like work out which key would require the fewest accidentals.
09:52:50 <ksf> iirc detection is ambigious
09:52:52 <Cale> Or, maybe there really is something I don't know about :)
09:53:04 <ksf> though you can make a best effort.
09:53:10 <Eduard_Munteanu> Hi.
09:53:23 <aug_triad> But what is KeySignature then?
09:53:24 <ksf> musical notation is a complete and utter mess.
09:53:40 <Cale> oh, yes, that looks hopeful
09:53:47 <Eduard_Munteanu> Can anyone recommend a Haskell book, preferably math-oriented (category theory etc.)?
09:54:12 <aug_triad> http://hackage.haskell.org/packages/archive/HCodecs/0.1/doc/html/Codec-Midi.html -> Message -> KeySignature
09:54:15 <Cale>  KeySignature !Int !Int | -- -7 - 7  0 - 1
09:54:24 <Cale> That's a rather vague comment
09:54:32 <aug_triad> Hehe, yes
09:54:42 <Cale> However, it's better than nothing
09:55:02 <mercury^> -7 - 7 0 - 1?
09:55:03 <aug_triad> I I have been looking in the source code, but I don't understand what going on at all
09:55:54 <Cale> http://faydoc.tripod.com/formats/mid.htm
09:55:56 * Eduard_Munteanu knows some music theory :D
09:55:56 <Cale> aha
09:56:20 <Cale> -7 is 7 flats, 7 is seven sharps, 0 is key of C
09:56:25 <Cale> 0 is major, 1 is minor
09:56:28 <rasfar> [-7..7] [0,1] i expect (probably major/minor the latter)
09:56:36 <aug_triad> Ah
09:56:57 <IceDane> ugh.. Linux in a nutshell. I want to get a better editor for some task, and before i know it I'm knee-deep in getting xft to work with it and installing fonts and whatnot
09:57:06 <Cale> Silly not to represent that as an algebraic datatype, but I guess they didn't feel like going to the trouble
09:57:19 <IceDane> Does anyone here use emacs with xft?
09:57:24 <Eduard_Munteanu> Is this about chords? Because to MIDI-like notation it shouldn't matter if it's major or minor.
09:57:45 <Cale> IceDane: I have, but I just used someone else's .deb for it
09:58:13 <Cale> Eduard_Munteanu: This is about the MIDI metadata field
09:58:14 <Vanadium> Is there some env varaible I can stick ghc options in similar to CFLAGS for gcc?
09:58:16 <aug_triad> How did you figure that out? Just guessing? I think you are right :)
09:58:25 <Cale> http://faydoc.tripod.com/formats/mid.htm
09:58:27 <Eduard_Munteanu> Cale, oh.
10:00:47 <ksf> Vanadium, how about putting them into your .hs file?
10:01:09 <Cale> (alternately, your .cabal file)
10:01:17 <Cale> (depending on which options)
10:02:40 <aug_triad> There are 15 different ways of representing key with [-7..7], but there are 17 different keys...? And how should I know what representation e.g. Db has...?
10:02:47 <dcoutts> Vanadium: what sort of cc options?
10:02:52 <Vanadium> -Wall
10:03:04 <Vanadium> I was not using a .cabal file so far :(
10:03:06 <aug_triad> 17 different keys in the real world
10:03:33 <ksf> why do you want to enable -Wall?
10:03:44 <dcoutts> ksf: presumably he's compiling .c files
10:04:08 <ksf> well in that case, I'd recommend calling gcc, not ghc...
10:04:08 <Vanadium> ksf: It warns me!
10:04:09 <sproingie> -Wall is a ghc option too
10:04:13 <Eduard_Munteanu> dcoutts, well if he's calling gcc, then why not CFLAGS?
10:04:24 <sproingie> enabling all warnings is not necessarily a bad thing
10:04:31 <aavogt> aug_triad: 12 different notes to start on for major, and then the second entry is for starting at a lower note for minor
10:04:40 <sproingie> though some are spurious
10:04:40 <Eduard_Munteanu> I'd say -Wall is a must.
10:04:46 <Vanadium> I figure if it turns out that -Wall is too much, I can turn it off again and look for fewer warnings.
10:04:57 <dcoutts> Eduard_Munteanu: indeed, I would use in my .cabal file: cc-options: -Wall
10:05:00 <Vanadium> But I still want a place to put them that is not the commandline, every time.
10:05:08 <Cale> aug_triad: Circle of fifths
10:05:09 <aug_triad> aavogt: Db and C# are two different keys
10:05:10 <aavogt> that gives more than the 17 keys you say
10:05:49 <ksf> hell adding strictness and/or -funbox-strict-fields makes the code slower, so I guess I'm at the end of the rope
10:06:13 <Cale> Db major would be (-5,0)
10:06:36 <Cale> Because Db has 5 flats, and major is represented by 0
10:07:24 <dcoutts> Vanadium: this is partly what .cabal projects are for
10:07:30 <ksf> Cale, the key progression is a helix revolving around the circle of fifth, due to the octave of a perfect fifth not being a perfect fith of an octave.
10:07:40 <ksf> welcome in logarithmic land
10:07:48 <lament> representing keys by the number of flats they have seems like a bad idea.
10:07:58 <aug_triad> No, since Cb, Fb and Gb, E#, B# are not keys
10:07:59 <Cale> Yeah, that would be the universal covering space ;)
10:08:19 <lament> aug_triad: of course they are, and so are Cbb, Cbbbbbb, etc
10:08:33 <aug_triad> Yes, they are notes, but not keys
10:08:48 <lament> why not?
10:08:56 <ksf> you're trying to regularize a thing that can't be regularized because it has to stick to physics, not your wishes for abstraction.
10:09:11 <lament> they're keys with very nasty looking signatures
10:09:44 <lament> wikipedia puts it like this: "Theoretical keys or impossible keys are keys which exist in music theory, but are not actually used in music because they have an impractical key signature."
10:10:00 <ksf> but in practice I couldn't care less, as it's just physically impossible to tune a guitar to something consistent.
10:10:02 <lament> but who cares what's actually used, right? :)
10:10:22 <aug_triad> Though, you are right about that there are only 12 keys
10:10:24 <lament> in practice people often even avoid C# major, replacing it by Db major, even though C# major only has 7 sharps
10:10:43 <aug_triad> Since there are no key D# either :)
10:10:54 <ksf> yep after 12 the helix repeats itself.
10:11:33 <lament> ksf: you're aware there used to be, for example, keyboard instruments with separate sharp and flat keys?
10:11:52 <lament> not something some theorist came up with, but actual historical practice
10:11:59 <ksf> yep, but the world has switched to equal temper
10:12:05 <ksf> ...or whatever that's called in english.
10:12:23 <lament> it's called equal temper, but the world certainly hasn't switched to it - for example, not string quartets
10:12:23 <Cale> I want to see a semitone scale piano with all white keys :)
10:12:38 <ksf> back in the days they were trading usability of keys for sound.
10:12:49 <aug_triad> lament: but you can't see if a tune is in major or minor from the signs, you have to analyse the tune then
10:13:05 <ksf> there's even midi synths that do local pitch optimization to tune the thing to the key that's played atm.
10:13:09 <lament> the violin family remains naturally tuned
10:13:20 <Cale> aug_triad: You can tell from the MIDI metadata though, because it tells you.
10:13:23 <aug_triad> Yes
10:13:31 <ksf> well yes it's easy, those beasts are fretless.
10:13:49 <lament> aug_triad: major and minor are not the only possible modes
10:13:50 <ksf> on a guitar, D maj is the saddest chord you can play.
10:14:07 <aug_triad> No, phrygian etc can also be used
10:14:14 <Cale> 12 tones is also rather arbitrary
10:14:24 <ksf> well ok standard chord.
10:14:25 <lament> a bunch of blues music is ambiguous between major and minor
10:15:03 <Vanadium> ... is alias ghc=ghc\ -Wall frowned upon?
10:15:11 <lament> a bunch of rock is mixolydian, a bunch of flamenco is phrygian, modern classical is not even tonal but is usually written as if it were in some key
10:15:19 <aug_triad> Yes, or alternating between mixolydian and dorian f.x.
10:15:21 <lament> so it has a key signature
10:15:37 <lament> debussy is all over the place
10:16:14 * ksf oscillates between power chords and not knowing what key
10:16:15 <Cale> MUSIC IS NOT PARTICLES, MUSIC IS A WAVE
10:16:17 <gwern> Vanadium: no, not really
10:16:21 <lament> the concept of major and minor keys is only really good for things like mozart :)
10:16:34 <jonafan> debussy rules
10:16:36 <lament> and mid-20-century pop
10:16:44 <gwern> Vanadium: -Werror is though, and it's worth remembering that -Wall isn't omniscient - it has both false positives and false negatives
10:16:51 <jonafan> i'm been struggling my way through the suite bergamasque for about 8 months now
10:17:07 <medfly> I wonder when will be the day that #haskell will discuss Haskell
10:17:14 <medfly> like, in 20 years when people realise Haskell is great/
10:17:24 <Cale> We all know Haskell is great here :)
10:17:25 <jonafan> passapied is killing me
10:17:32 <Vanadium> gwern: Right, I am googling up some reddit discussions on it, including comments from you :)
10:17:45 <medfly> and then we'd have people like how do I use recursionzzz
10:17:46 <ksf> Vanadium, try hlint
10:17:47 * gwern is caught in an eternal loop!
10:18:06 <Vanadium> When I remembered that ghc *had* -Wall last night, I found a few places in my code that made me wonder why I did not notice them to begin with
10:18:16 <aug_triad> Ok, then I have a Haskell question :). what does the ! in ! Int mean?
10:18:19 <gwern> perhaps I ought to dump everything I've ever written into a markov chain bot and let it lurk in IRC for me...
10:18:27 <gwern> aug_triad: bang pattern, forces evaluation
10:18:27 <Eduard_Munteanu> Can anyone recommend a Haskell book, preferably math-oriented (category theory etc.)?
10:18:38 <gwern> Eduard_Munteanu: haskell road to mathematics?
10:18:57 <lament> medfly: hi i need 2 do my hmwkr culd u do it plz?? prime numbr funkshon wuts even a prime number lol??
10:19:02 <Eduard_Munteanu> gwern, lemme look it up.
10:19:16 <Cale> medfly: Oh, you get recursion by taking initial objects in the category of F-algebras for a suitable functor F.
10:19:18 <medfly> iunno lol I think it's lyk an important number?
10:19:25 <aavogt> > 2 -- even prime number
10:19:26 <lambdabot>   2
10:19:28 <gwern> lament: a prime number is the fancy name for an even number, so the answer is [0,2..]
10:19:36 <ksf> ./fasta-orig 10000000 > /dev/null  12.37s user 0.07s system 99% cpu 12.550 total     ./fasta 10000000 > /dev/null  7.15s user 0.04s system 99% cpu 7.243 total
10:19:40 <Cale> aug_triad: Strict
10:20:00 <aug_triad> Cale: And what does Strict mean...
10:20:06 <Eduard_Munteanu> gwern, is it this one? open http://www.amazon.com/Haskell-Logic-Maths-Programming-Computing/dp/0954300696/ref=sr_1_1?ie=UTF8&s=books&qid=1258136360&sr=1-1
10:20:08 <Cale> aug_triad: Basically, if you try to pattern match a value constructed by that constructor, it will force the evaluation of the fields marked by !
10:20:12 <ksf> whom should I send the code so it gets commited?
10:20:16 <gwern> Eduard_Munteanu: dunno, I just have a PDF
10:20:21 <Cale> aug_triad: even if you don't use them
10:20:34 <jlouis> gwern: you sound like the TDD crowd...
10:20:36 <Eduard_Munteanu> gwern, well, the title I mean... "The Haskell Road to Logic, Maths and Programming"
10:20:46 <Cale> aug_triad: This helps to prevent large expressions from accumulating in the fields of the structure
10:20:53 <Cale> (large unevaluated expressions)
10:21:11 <gwern> jlouis: if you have objections, please submit them in the form of a unit test I can mock
10:21:30 <jlouis> gwern: hahah
10:21:34 <medfly> I can't wait for the day this channel starts to resemble ##php
10:21:37 <aug_triad> Cale: ok, thanks
10:21:40 <Vulpyne> Sweet, I just got GHC to say "My brain just exploded."
10:21:43 <Cale> Semantically, it just means that if any of the fields marked with ! is undefined, then the whole structure is undefined.
10:22:10 <Cale> Vulpyne: Trying to pattern-bind an existential?
10:22:11 <Baughn> Vulpyne: Next up, actually crashing it. :P
10:22:18 <Vulpyne> Cale: Yep.
10:22:28 <Vulpyne> Baughn: Been there, done that. :)
10:22:50 <medfly> I think I got a segmentation fault once
10:22:59 <Cale> medfly: Oh? How?
10:23:22 <Cale> medfly: It should be hard to get one without using the FFI.
10:23:41 <Cale> (typically they indicate bugs in GHC, so it's good to report them)
10:23:42 <medfly> I think my computer was really slow (normal so far) and I was trying to ^C and ^D the crap out of it, and I ended up with that.
10:23:46 <Cale> oh
10:23:47 <gwern> it's pretty easy with profiling to get segfault
10:23:48 <Cale> hmm
10:24:03 <gwern> ghc api and profiling = insta-segfault
10:24:13 <Cale> heh, that's interesting
10:24:23 <gwern> and a long-standing bug...
10:24:34 <gwern> (makes it difficult to optimize things like mueval)
10:29:49 <Vanadium> When hlint is all "Why not:", is there actually a button to tell it why not?
10:34:29 <tommd> @src or
10:34:30 <lambdabot> or    =  foldr (||) False
10:35:45 <lilac> ksf: how much of a speedup did you manage?
10:36:20 <mmorrow> Cale: re: computing stuff from a MIDI file, here's something possibly useful (and amusing/addictive in general;) if you pursue that http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4534
10:36:40 <mmorrow> that'd be cool to play a midi file with the pcspkr
10:36:48 <ksf> >  12.37 /  7.15
10:36:49 <lambdabot>   1.7300699300699298
10:36:55 <tommd> Why do I get "No instance for (Data.String.IsString B.ByteString)" ?  I've used overloaded strings w/ bytestring before.  What am I suddenly doing wrong?
10:37:00 <mmorrow> it should actually be trivial given that module now that i think about it
10:37:07 * mmorrow puts that on his todo list
10:37:28 <jlouis> ksf: not bad
10:37:30 <ksf> still have to clean it up a bit though.
10:37:49 <ksf> I'm currently letting ghc thrash my system for hlint...
10:37:51 <lilac> > 17.24 / 1.73
10:37:52 <lambdabot>   9.965317919075144
10:38:03 <mmorrow> haha, and the second paste is legend of zelda themesong via pcspkr, from mauke's zel.c
10:38:05 <lilac> still slower than issue 9 :(
10:38:33 <ksf> there's a bit slack left.
10:38:40 <ksf> some stuff that could be unboxed isn't.
10:38:53 <ksf> I wish I could just say "unbox all tuples"
10:39:44 <lilac> i assume that's not what -XUnbuxedTuples does
10:39:53 <Cale> mmorrow: Oh, I think I remember this
10:40:04 <mmorrow> gah, there're like 4 different "T" types/cons in the midi pkg
10:40:13 <Cale> mmorrow: At least, I remember when there was a discussion on #haskell about these ioctls.
10:40:35 <mmorrow> Cale: totally, this is that original module + some hackery
10:40:47 <Cale> mmorrow: Is it by Henning Thielemann?
10:40:50 <mmorrow> well, 10% original module, 90% hackery ;)
10:40:50 <Eduard_Munteanu> ioctl? Sounds awfully familiar, though the context is way off.
10:40:51 <lilac> ksf: did you try experimenting with the -via-C flag?
10:40:59 <mmorrow> Cale: haha, it is
10:41:13 <ksf> it already was enabled, and it's faster.
10:41:16 <Cale> mmorrow: You can pretty much assume from the outset that any package written by him will have absolutely inane conventions like that.
10:41:28 <mmorrow> Eduard_Munteanu: it's used here to play and control the pitch of the pc speaker
10:41:29 <ksf> and -optc-O3 doesn't give an inch over -O2
10:41:34 <Cale> mmorrow: Which is upsetting, since he otherwise produces lots of good code.
10:41:55 <Cale> mmorrow: It's almost enough to make me want to produce <packagename>-sane versions of packages that he maintains.
10:42:17 <Eduard_Munteanu> mmorrow, pulse width modulation? Fine hack.
10:42:22 <lilac> ksf: well, the C version uses evil such as: "Integer to float conversions are faster if the integer is signed"
10:42:27 <Cale> I wonder if he's formulaic enough that we could write a Haskell program to satitise his work.
10:42:28 <Eduard_Munteanu> Or should I say... bit-banging?
10:42:32 <Cale> sanitise*
10:42:50 <mmorrow> heh
10:43:19 <Eduard_Munteanu> ksf, don't use -O3 with GCC unless you know what you're doing. Stick with -O2 usually.
10:43:37 <Cale> mmorrow: He names all his types T and all his typeclasses C
10:43:57 <Cale> and it makes the haddock absolutely impossible to read
10:44:06 <mmorrow> hehe, it took me a second to realize what was happening there in the haddocks
10:44:11 <mmorrow> yeah
10:44:50 <Cale> It's like, yeah, sure, you can do that, but c'mon, don't be a dick.
10:45:44 <ksf> ...now if unboxed tuples had an arrow interface...
10:46:00 <Cale> heh, good luck with that one
10:46:29 <Cale> I think you might run into some kinding issues there
10:46:33 <ski> (maybe if haddock could be configured to show longer paths to identifiers when needed/wanted ..)
10:47:18 <Cale> Or: just obey the sane convention of naming your types properly.
10:48:00 <Cale> I have a distaste for anything requiring qualified imports. The Set and Map libraries are bad enough in that regard.
10:48:55 <Cale> I actually kind of liked the Data.FiniteMap way of doing things, since I didn't have to type two lines to import it just the way I want.
10:49:09 <ski> i think it would be nice, if both conventions are supported
10:49:20 <Cale> Well, yeah, Haddock could be smarter.
10:49:44 <jmcarthur_work> i don't mind qualified imports. there isn't much difference between S.map and smap
10:49:46 <Cale> It should qualify any names which are ambiguous in context.
10:49:54 <kmc_> jmcarthur, except that you can drop the former if you like
10:49:58 <kmc_> so it's strictly better
10:49:59 <ski> @kind Data.STRef.Lazy.STRef
10:50:00 <jmcarthur_work> exactly
10:50:00 <ski> @kind Data.STRef.Strict.STRef
10:50:00 <lambdabot> * -> * -> *
10:50:02 <lambdabot> * -> * -> *
10:50:10 <Cale> kmc_: Except that there's already something called map
10:50:21 <jmcarthur_work> Cale, so you prefer smap to S.map?
10:50:37 <Cale> jmcarthur_work: To the extent that it doesn't take me two lines to import the module every time, yeah.
10:50:45 <ksf> why am I trying to optimize the return type of a function that's completely inlined?
10:50:53 <jmcarthur_work> i think our qualified import syntax could be better
10:51:04 <Cale> jmcarthur_work: It would be nice if we could write modules which re-exported qualified names. That would effectively fix my problem.
10:51:11 <kmc_> yeah
10:51:21 <kmc_> but i think regardless of that, qualified names are a good thing
10:51:27 <kmc_> even C++ advises their use...
10:51:44 <kmc_> in a lot of other languages it's the default or only way to import
10:51:48 <Cale> I dislike them, and think that they're a workaround for those times when namespaces actually clash.
10:51:51 <kmc_> from Data import Map
10:53:30 <ski> Cale : "modules which re-exported qualified names" meaning ?
10:54:01 <jmcarthur_work> would be nice if import qualified only required qualification on the names that are actually ambiguous in context, which i think is something that was already said earlier
10:54:09 <ski>   module Foo (Bar.frob as barf)
10:54:11 <ski>     where
10:54:20 <ski>     import Bar (frob)
10:54:21 <ski> ?
10:54:33 <Cale> So long as namespaces are not colliding, I will always import things unqualified, because it's easier to read things Language.English.Adverb.when Language.English.Pronoun.they're Language.English.Adverb.not Language.English.Adverb.like Language.English.Pronoun.this.
10:55:47 <Eduard_Munteanu> When compiling Agda, it can't find Control.Monad.Reader. I have GHC 6.8.2. Any tips?
10:56:02 <Cale> Eduard_Munteanu: ghc-pkg list mt
10:56:04 <Cale> oops
10:56:05 <Cale> Eduard_Munteanu: ghc-pkg list mtl
10:56:22 <Eduard_Munteanu> $ ghc-pkg list mtl
10:56:22 <Eduard_Munteanu> /usr/lib64/ghc-6.8.2/package.conf:
10:56:28 <Eduard_Munteanu> Cale, I suppose I should install it.
10:56:30 <Cale> Eduard_Munteanu: also, that version of GHC is really old.
10:57:01 <Eduard_Munteanu> Cale, hm, I'll unmask newer packages in my Gentoo repo.
10:57:09 <Eduard_Munteanu> s/my//
10:57:22 <Cale> Eduard_Munteanu: Try to avoid compiling GHC yourself if you can avoid it.
10:57:27 <jmcarthur_work> how soon until we 6.12.1 is released?
10:57:31 <jmcarthur_work> -we
10:57:37 <copumpkin> jmcarthur_work: a few months
10:57:40 <kmc_> Cale, but you can also design a module such that it's *easier* to read uses qualified
10:57:51 <Eduard_Munteanu> Cale, I have mtl 1.1.0.0.
10:57:54 <copumpkin> maybe 3 or 4, if you mean the full user-level release :)
10:57:56 <Eduard_Munteanu> Cale, Gentoo does it :)
10:58:08 <jmcarthur_work> Eduard_Munteanu, it's to save time, not effort :P
10:58:12 <Cale> Eduard_Munteanu: I just mean that compiling GHC is a waste of time.
10:58:55 <Cale> Eduard_Munteanu: because you need to have a GHC binary to compile GHC anyway, so you might as well get yourself the right version of that GHC binary to begin with.
10:59:41 <Vanadium> Man, why do I have to write my dependencies into my .cabal file
10:59:47 <Vanadium> Why can cabal not write them down for me :<
10:59:54 <ksf> >  12.37 /  6.81
10:59:55 <lambdabot>   1.816446402349486
10:59:59 <Cale> The only valid excuses for compiling GHC yourself is that there's no existing binary for your platform, or you're hacking on it. The former implies the latter in most cases too.
11:00:17 <Cale> (since bootstrapping GHC on a new platform is nontrivial)
11:00:33 <dcoutts> Vanadium: partly because finding them automatically is a bit tricky and partly because there are genuine choices that you need to think about
11:00:55 <Eduard_Munteanu> Cale, well, I use Gentoo. I suppose I could use the binary USE flag, but then I don't get any optimization and customization.
11:00:56 <Vanadium> But I have no idea what I depend on, I just import and then cabal-install when that does not work :<
11:01:02 <Vanadium> ghc can figure out where to get the imports from, so :<
11:01:05 <Cale> Eduard_Munteanu: You don't want any for GHC.
11:01:08 <Eduard_Munteanu> And besides I have a quad core, so compliling it doesn't take that much.
11:01:36 <sproingie> make -j4 never worked that well for me when compiling ghc
11:01:43 <Cale> I'm of the firm opinion that the people who write the software should get to decide what flags it's compiled with.
11:01:43 <sproingie> buggy makefile i guess
11:01:52 <sproingie> so quad core won't mean a whole lot
11:01:59 <Cale> and that messing with that sort of thing is just asking for problems.
11:01:59 <medfly> what you say
11:02:11 <Eduard_Munteanu> Cale, well the people who write the software can't possible provide builds optimized for all CPUs.
11:02:20 <Eduard_Munteanu> and besides I'm not doing anythign funny.
11:02:23 <ksf> er no that used an overlapped pattern match.
11:02:33 <Eduard_Munteanu> $ grep CFLAGS /etc/make.conf
11:02:34 <Eduard_Munteanu> CFLAGS="-O2 -march=native -msse4a -pipe"
11:02:37 <sproingie> i compiled 6.12 so i could install it on my dinky 256M VPS
11:02:55 <sproingie> linking has gone from tectonic to merely glacial
11:03:23 <Cale> heh
11:04:14 <IceDane> Is there a function that basically takes the first elements in a list that satisfies a condition?
11:04:17 <ksf> but it turns out that I don't need to handle the [] case.
11:04:24 <Eduard_Munteanu> Cale, is Control.Monad.Reader not implemented on GHC 6.8.2 and/or mtl-1.1.0.0 ?
11:04:27 <sproingie> IceDane: takeWhile
11:04:31 <kmc_> :t takeWhile
11:04:32 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
11:04:34 <maltem> :t find
11:04:35 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
11:04:40 <IceDane> Oh, find is what I need
11:04:40 <IceDane> thanks
11:04:50 <kmc_> it's safer than head and takeWhile too
11:04:56 <Cale> There's also various combinations of take and filter
11:04:56 <kmc_> that is, unsafeHead and takeWhile
11:04:59 <tromp_> i see you found find
11:05:15 <sproingie> isn't head normally unsage?
11:05:17 <sproingie> unsafe
11:05:19 <philed> Is there a general rule in the language report saying what type should be chosen for x when defined by "x = fromInteger 0"?
11:05:21 <sproingie> :t head
11:05:22 <lambdabot> forall a. [a] -> a
11:05:26 <Cale> > take 2 . filter even $ [3,5,6,7,9,10,11,12]
11:05:26 <kmc_> yes
11:05:28 <lambdabot>   [6,10]
11:05:39 <kmc_> > take 2 . filter even $ []
11:05:40 <lambdabot>   []
11:05:43 <ksf> @hoogle unsafeHead
11:05:44 <lambdabot> Data.ByteString.Unsafe unsafeHead :: ByteString -> Word8
11:05:47 <ksf> ah.
11:05:52 <kmc_> philed, it depends on the context
11:05:56 <kmc_> that's type inference
11:05:57 <Cale> philed: That is equivalent to x = 0
11:06:03 <kmc_> in fact, all numerical literals resolve that way
11:06:13 <Cale> philed: and yeah, it's complicated by the fact that there's numeric defaulting
11:06:35 <Cale> philed: initially, x gets the inferred type signature  x :: forall a. (Num a) => a
11:07:17 <philed> Cale: But when you evaluate at the toplevel, GHCi defaults it to Integer?
11:07:19 <Cale> philed: but if x is not required to be polymorphic by any hand-written signatures, and remains polymorphic to the top of the module, it will be defaulted to Integer
11:07:34 <IceDane> In what module to I find find? :P
11:07:39 <Cale> IceDane: Data.List
11:07:40 <kmc_> @hoogle find
11:07:41 <lambdabot> Data.ByteString find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
11:07:41 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
11:07:41 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
11:07:45 <IceDane> Ah, thanks
11:07:52 <IceDane> I'll use the bot next time
11:08:23 <kmc_> philed, but if you used x somewhere else in the module, say as a Double, it'd resolve it that way
11:08:23 <Cale> philed: The report describes the rule better than I have
11:08:56 <kmc_> type inference is a process of solving constraints over many equations
11:09:07 <kmc_> it can't be decided locally what the type of a binding is, if it's not given a signature
11:09:11 <Baughn> http://www.skytopia.com/project/fractal/mandelbulb.html <-- Have some lovely 3D fractals
11:09:59 <philed> kmc_: If I ask for the type of x at the GHCi toplevel, it reports that it's Integer. I just wanted to know if the report requires this.
11:10:03 <Cale> Actually, it resolves the ambiguity by picking the first type in a list of types which is set by a 'default' declaration that satisfies the constraints, and which defaults to [Integer, Double]. It also only does this if the type variable is constrained by prelude classes.
11:10:12 <philed> When if you examine the type of fromInteger, it clearly should be Num a => a.
11:10:12 <Cale> It's a really awkward hacky rule
11:10:14 <kmc_> yeah, that's form the defaulting
11:10:16 <kmc_> from*
11:10:19 <Cale> But it tends to do what you want.
11:10:24 <kmc_> :t 3
11:10:25 <lambdabot> forall t. (Num t) => t
11:10:29 <philed> Ah okay.
11:10:30 <kmc_> :t let x = 3 in x
11:10:31 <lambdabot> forall t. (Num t) => t
11:10:40 <Cale> philed: The report doesn't discuss interactive behaviour
11:10:43 <philed> Yeah, I noticed lambdabot is more intuitive.
11:10:48 <kmc_> philed, try those in ghci
11:11:01 <kmc_> i get the same results
11:11:02 <Cale> philed: GHCi does aggressive defaulting of everything.
11:11:11 <kmc_> it's only when x is a top-level bind in a file you load into ghci, that it does defaulting
11:11:15 <Cale> @let xx = 3
11:11:17 <lambdabot>  Defined.
11:11:19 <Cale> :t xx
11:11:20 <lambdabot> forall t. (Num t) => t
11:11:30 <Cale> ah, I must have monomorphism turned off :)
11:11:50 <philed> Cheers for the info guys!
11:12:03 <philed> I just wanted to know why ghci was behaving that way.
11:12:26 <kmc_> :t let x = True in x == x == True
11:12:27 <lambdabot>     Precedence parsing error
11:12:27 <lambdabot>         cannot mix `==' [infix 4] and `==' [infix 4] in the same infix expression
11:13:03 <Cale> philed: You can use {-# LANGUAGE NoMonomorphismRestriction #-} to reduce the extent to which it forces things to monomorphic types
11:13:15 <Cale> philed: Or in ghci  :set -XNoMonomorphismRestriction
11:13:27 <Cale> I really wish that had a shortcut...
11:13:44 <kmc_> you can define one
11:14:17 <Eduard_Munteanu> Doesn't -fglasgow-exts enable all sort of stuff?
11:14:32 <kmc_> isn't it deprecated in favor of specificity?
11:14:39 <sproingie> -fglasgow-exts is deprecated
11:14:45 <Eduard_Munteanu> I see.
11:15:51 <tommd> Yeah, use -XSomeLanugageExtension instead.
11:16:12 <tommd> Or the {-# LANGUAGE SomeLanguageExtenstion #-} pragma.
11:16:33 <kmc_> what's the point of having a conditional "if .. then .. else" built into Haskell?
11:16:49 <Eduard_Munteanu> kmc_, syntactic sugar?
11:16:51 <sproingie> because it looks nice
11:17:02 <kmc_> it's usually overused by beginners
11:17:05 <kmc_> i don't think it looks that nice
11:17:11 <BONUS> it's useful with do notation
11:17:31 <kmc_> with "do" notation i usually want when or unless, or guard
11:17:32 <lament> kmc_: what do you want instead?
11:17:32 <BONUS> and for checking intermediate boolean results where you don't want to do a case statement or a helper function with guards
11:17:44 <copumpkin> kmc: yeah, I'd kill it
11:17:45 <medfly> CANCEL IF TO MAEK HASKELL EVEN MORE ALIEN TO IMPERATIVE PROGRAMMERS! HURRAH!
11:17:54 <copumpkin> exactly
11:17:57 <copumpkin> no crutches
11:18:01 <copumpkin> also, return is a bad name :)
11:18:02 <sproingie> it is pretty trivial to create a ternary operator if you use $ instead of :
11:18:11 <copumpkin> it doesn't behave like imperative return
11:18:12 <kmc_> lament, it could be an ordinary function in some module
11:18:18 <maltem> The most useful thing about if-then-else is that it's highlighted in my editor
11:18:36 <kmc_> :t let cond True x y = x; cond False x y = y in cond
11:18:37 <lambdabot> forall t. Bool -> t -> t -> t
11:18:37 <copumpkin> having a ($) with flipped associativity would help get rid of if syntax
11:18:53 <kmc_> this would also drive home early the idea that laziness gets you more power to define control structures
11:18:56 <Eduard_Munteanu> BTW, is '$' haskell's way of avoiding being just another Lisp? :P
11:19:02 <kmc_> haha
11:19:09 <medfly> yes. it works!
11:19:10 <lament> kmc_: but if...then...else looks nice :(
11:19:12 <sproingie> Eduard_Munteanu: it's useful in a section too
11:19:17 <kmc_> i disagree
11:19:32 <lament> kmc_: i'd get lost otherwise, it would be hard to see where the then- and else-clauses are
11:19:35 <copumpkin> lament: I hate the look of it :)
11:19:50 <BONUS> bikeshedding, bikeshedding
11:19:54 <copumpkin> yep
11:20:03 <kmc_> i'd give it up just so i don't have to see beginners writing "if (length xs) > 0 then head xs else 0"
11:20:03 <jasonmay> hehe
11:20:08 * ksf doesnt' get that memory profile
11:20:22 <Eduard_Munteanu> kmc_, :)
11:20:51 <maltem> Better ban length from the Prelude
11:21:04 <kmc_> better rename head to unsafeHead
11:21:09 <sproingie> you'd also get 'if' and 'then' back as identifiers
11:21:17 <maltem> (Makes it even easier to have it define in exercises)
11:21:20 <sproingie> then = >>
11:21:26 <kmc_> of course the better thing is to add Agda-style mixfix
11:21:30 <sproingie> (>>)
11:21:38 <kmc_> then you can have your if_then_else_ any way you like it
11:21:49 <Eduard_Munteanu> :t >>
11:21:50 <sproingie> i usually pronounce >> as "then"
11:21:51 <lambdabot> parse error on input `>>'
11:21:53 <kmc_> :t (>>)
11:21:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
11:21:59 <Eduard_Munteanu> :t (>>=)
11:22:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:22:52 <BONUS> anyone know of a shorter definition for length than foldl' (flip $ const (+1)) 0
11:23:15 <Twey> kmc_: You mean if (length(xs) > 0) then head(xs) else 0
11:23:17 <Twey> :þ
11:23:23 <kmc_> haha
11:23:25 <fmannan> etpace: where's benmachine?
11:23:50 <Eduard_Munteanu> BONUS, length [] = 0, length x:xs = 1 + length xs
11:23:55 <Eduard_Munteanu> Blah, not shorter.
11:23:56 <ksf> http://img697.imageshack.us/i/fasta.pdf/
11:24:04 <kmc_> @pl \xs -> if (length(xs) > 0) then head(xs) else 0
11:24:04 <ksf> someone tell me what that means?
11:24:05 <lambdabot> flip (ap (if' . (> 0) . length) head) 0
11:24:05 <BONUS> haha
11:24:13 <kmc_> :t if'
11:24:15 <lambdabot> Not in scope: `if''
11:24:18 <BONUS> also with the foldl' thing it's stricter
11:24:24 <Twey> BONUS: foldl'(flip$const(+1))0
11:24:25 <BONUS> so it doesn't stack overflow
11:24:27 <Twey> ;)
11:24:28 <BONUS> lol
11:24:30 <dancor> @let if' c t e = if c then t else e
11:24:31 <Eduard_Munteanu> BONUS, yeah.
11:24:33 <lambdabot>  Defined.
11:24:37 <dancor> :t if'
11:24:39 <lambdabot> forall t. Bool -> t -> t -> t
11:24:52 <kmc_> ksf, what kind of program generates those graphs?
11:25:11 <Twey> :t flip $ const (+ 1)
11:25:11 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12117#a12117  , more or less.
11:25:12 <lambdabot> forall a a1. (Num a1) => a1 -> a -> a1
11:25:16 <Vulpyne> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=12119 - Can this type with existential variables ever work the want I want it to? I'm thinking not...
11:25:22 * hackagebot upload: hsdns 1.4.1 - Asynchronous DNS Resolver (PeterSimons)
11:25:32 <Twey> > (flip $ const (+ 1)) 5 6
11:25:33 <lambdabot>   6
11:25:35 <ksf> like, the null test in choose is gone. nothing drastic.
11:25:37 <Twey> > (flip $ const (+ 1)) 5 7
11:25:38 <lambdabot>   6
11:26:05 <dancor> BONUS: shortest number of characters?  or something else
11:26:31 <Twey> > ((+ 1) . const) 5 7
11:26:32 <lambdabot>   No instance for (GHC.Num.Num (b -> a))
11:26:32 <lambdabot>    arising from the literal `1' at <...
11:26:32 <BONUS> yeah like most code golfish
11:26:33 <BONUS> hehe
11:26:41 <kmc_> Vulpyne, well, how do you want it to work?
11:26:52 <BONUS> but i think foldl'(flip$const(+1))0 is pretty short
11:26:56 <Vulpyne> kmc: I want to stick the new state back into the EventHandlerFunc.
11:26:57 <Twey> > (const . (+ 1)) 5 7
11:26:58 <lambdabot>   6
11:27:06 <kmc_> i'm suspicious because the existentially quantified variable "a" appears in the result of ehfFunc
11:27:08 <Twey> That's a little shorter
11:27:14 <dancor> BONUS: and it must have the same strictness properties as (length)?
11:27:20 <BONUS> ya
11:27:28 <kmc_> that part of the tuple will have type forall a. a
11:27:36 <Cale> That shouldn't be a problem.
11:27:55 <monoidal> why GHC gives let (a,b) = (b,a) the type GHC.Prim.Any, not a?
11:27:58 <Cale> oh
11:28:01 <Vulpyne> kmc: I'm trying to make an event handler with private state. So that state will never be used outside of the function.
11:28:06 <kmc_> but you can still use the result by way of the monad
11:28:10 <Cale> But you're trying to stick *fst* into that spot
11:28:16 <Vulpyne> kmc: But I do have to run the function, extract the new state, and then update the session (and event handlers) with the new state.
11:28:17 <Twey> > length "foldl'(const.(+1))0"
11:28:18 <lambdabot>   19
11:28:19 <Cale> and there's no guarantee here that fst has the same type
11:28:38 <Cale> (btw, it's kind of evil to name your local variables after prelude functions)
11:28:52 <Twey> Cale: I disagree
11:28:55 <kmc_> :t let x@(a,b) = (b,a) in x
11:28:56 <lambdabot> forall t. (t, t)
11:29:02 <Twey> Oh, wait, local variables
11:29:04 <dancor> Twey: ghc warnings agree! :)
11:29:08 <Vulpyne> Cale: I didn't even realize I did that, I've just been messing around with it.
11:29:08 <Twey> Module names are okay.
11:29:13 <Twey> (module-level)
11:29:20 <kmc_> monoidal, woah, very strange
11:29:23 <kmc_> i got it in ghci
11:29:25 <Twey> 's what namespacing is for, after all.  ;)
11:29:30 <kmc_> i guess it's monomorphism gone awry?
11:29:37 <Cale> Twey: I also think that's kind of evil, but others disagree with me :)
11:29:39 <kmc_> it "defaults" to Any
11:29:43 <Twey> monoidal: Defaulting
11:29:46 <monoidal> seems to be monomorphism restriction
11:29:50 <kmc_> but i still get it with -XNoMonomorphismRestriction
11:30:01 <Twey> Cale: If that's evil, we should just abolish the module system
11:30:02 <monoidal> hugs gives a
11:30:13 <Vulpyne> I don't think there's a way I can tell it that they are the same type.
11:30:15 <kmc_> but not with "let .. in"
11:30:16 <Cale> Twey: I think namespacing is for resolving ambiguities when they accidentally occur, not so that people can go making ambiguities happen as much as possible :)
11:30:16 <Twey> kmc_: Defaulting isn't the MMR, AIUI
11:30:17 <kmc_> only with the do-level let
11:30:33 * kmc_ hates defaulting
11:30:38 <Twey> Cale: Namespacing is so that people don't have to worry about clashing with things
11:30:45 <monoidal> also, when (a,b)=(b,a) is in a file
11:30:54 <kmc_> Namespacing is so people can choose the most concise interface they can, and not worry about collisions
11:31:02 <Twey> Aye
11:31:04 <kmc_> otherwise everyone just prepends the module name to everything
11:31:12 <kmc_> which is just like namespacing but worse
11:31:18 <Twey> You write your own code your own way, and let whoever's using it worry about collisions their preferred way (qualification, hiding, whatever)
11:31:23 <ksf> kmc_, concise names like T and C?
11:31:26 <monoidal> Twey, when defaulting happens?
11:31:32 <Twey> monoidal: No idea!
11:31:38 <kmc_> ksf, those are pathological cases i'd say
11:31:52 <ksf> yep.
11:32:04 <Vulpyne> I wonder if something like forall a. EventHandlerFunc { ehfState :: a, ehfFunc :: a -> EventSocketMessage -> EventSocketT h m (EventHandlerFunc h m,EventHandlerResult) } could work.
11:32:22 <jlouis> you need qualified names for any project above a certain size. But the base libraries should try to keep themselves free of the need of qualification i'd say.
11:32:22 <ksf> I rather import Data.Map qualified and then import Data.Map(Map) unqualified.
11:32:25 <Twey> monoidal: http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html
11:32:25 <Vulpyne> Probably not because the a still wouldn't be known to be the same.
11:32:37 <kmc_> i don't mind writing Map.Map
11:32:48 <Cale> ksf: I hate the fact that I have to do that though.
11:32:59 <mauke> Map.T is clearly superior
11:33:05 <Twey> ‘T’ and ‘C’ are bad because they essentially *force* qualification.  It takes choice away from the user.
11:33:14 <Cale> I liked Data.FiniteMap which went to the trouble of naming its functions so that they didn't collide with prelude functions.
11:33:25 <monoidal> Twey, thanks
11:33:36 <Twey> Cale: ‘dataFiniteMapLookup’ ;)
11:33:43 <Cale> lookupFM
11:33:47 <mauke> ew
11:33:48 <Cale> mapFM
11:33:50 <Cale> etc.
11:33:53 <kmc_> import Data.FiniteMap as FM
11:33:56 <jlouis> FM.map
11:34:04 <Twey> Right
11:34:05 <Cale> kmc_: Yes, I know you can do that.
11:34:06 <jlouis> it is one character more
11:34:08 <Twey> You might as well go back to C if you're going to do that, Cale
11:34:22 <Twey> It defeats the point of namespacing
11:34:25 <kmc_> actually the obvious solution is first-class modules + overloading the module-qualification operator
11:34:29 <Cale> But then you import infix operators and type names on a separate line
11:34:33 <Twey> (since you're doing your own mangling, too)
11:34:44 <Cale> and it just becomes a big hassle to import the library so that you can use it sanely
11:34:49 <mauke> Cale: I don't
11:34:52 <ksf> first-class modules yay.
11:34:56 <Twey> I don't
11:35:00 <mauke> I just use single-character module aliases
11:35:04 <Cale> Infix operators look *horrible* when qualified.
11:35:04 <Twey> Yeah
11:35:08 <kmc_> Cale, it seems you have some valid complaints about flexibility of import and export declarations, and you're using them to argue against qualified names in general
11:35:11 <ksf> let me define a renaming function and type conversions.
11:35:11 <mauke> M.Map, M.!, etc
11:35:19 <Twey> M.! isn't bad
11:35:20 <ksf> I want proper functors over modules.
11:35:21 <Cale> kmc_: I don't have anything against qualified names in general.
11:35:24 <Twey> And M.Map is just fine
11:35:37 <kmc_> but as soon as you have shit like lookupFM you've given up on qualified names
11:35:43 <jlouis> I usually import Data.Map as M and Data.Set as S
11:35:48 <ksf> actually, forget about both modules and records, we need mocords.
11:35:50 <Twey> And namespace resolution in general
11:35:54 <Cale> I just think we should only use the qualified names to make up for genuine accidental collisions, and otherwise design our modules so that they don't collide.
11:35:57 <Twey> ksf: Haha
11:36:12 <ksf> only serious
11:36:24 <jlouis> Cale: I agree that one should attempt that for the base. It is more convenient.
11:36:29 <Twey> Cale: But that's just redundant.
11:36:29 <kmc_> Cale, so given the half-dozen or so standard associative containers, what do you name "lookup" in each of them?
11:36:35 <jlouis> what constitutes the base is up for grabs of course
11:36:42 <mauke> I think we should choose the most sensible names within the scope of a module and ignore everything else
11:36:43 <ksf> more typeclasses
11:36:47 <Twey> And also requires that the user memorise more names
11:36:53 <ksf> that's why we need kindschools.
11:36:59 <Cale> Yeah, and we ought to be making better use of typeclasses here.
11:37:07 <Twey> That's a fair point
11:37:12 <ksf> at least I think so.
11:37:24 <ksf> I find it quite hard to imagine kindschools
11:37:30 <Twey> But the problem with typeclasses is that they break interfaces
11:37:39 <Cale> hm?
11:37:43 <ksf> how's that?
11:38:46 <Twey> If you have a :: Ord k => k -> Map k v -> Maybe v, changing it to a :: (Lookupable l, Ord k) => k -> l k v -> Maybe v breaks existing code
11:39:07 <ksf> but not badly
11:39:20 <ksf> that is, types change, not code.
11:39:27 <Cale> class families are going to fix a lot of issues with constrained containers too
11:39:36 <kmc_> Twey, that'll break things like IntMap where the key and/or value is not a type parameter
11:39:37 <Cale> So that hopefully Set will finally be a monad
11:39:40 <Twey> You've got a whole bunch of functions that are built on top of Map, and that would function exactly the same for any lookupable type, but that have to be rewritten.
11:39:43 <kmc_> it'll definitely break lookup on [(a,b)]
11:39:48 <ksf> kind tribes!
11:39:49 <kmc_> what you need is fundeps or asstypes
11:39:49 <Twey> kmc_: That too
11:40:00 <kmc_> in fact this is a common motivating example for both
11:40:08 <mauke> asstypes ~̈
11:40:15 <Cale> IntMap is something which shouldn't be visible to the programmer
11:40:19 <Twey> Haha, asstypes?
11:40:20 <kmc_> that's my name and i'm sticking to it
11:40:24 <Twey> Cale: *nod*
11:40:41 <Cale> Though, it actually takes a lot of work to do that right
11:40:53 <ksf> it's already been done.
11:40:54 <Cale> Because sometimes Map Int is better than IntMap
11:40:56 <gr00vy> hello
11:41:05 <dancor> Cale: when
11:41:10 <kmc_> data family Map k :: * - > *; data instance Map Int v = IntMap ...
11:41:12 <kmc_> like that?
11:41:18 <kmc_> hi gr00vy
11:41:27 <Cale> dancor: When you're doing something that uses parametricity
11:41:30 <ksf> ...but yes, I guess there should be a way to override the magic.
11:41:46 <kmc_> the way is just to provide two levels
11:41:46 <ksf> which, if everything else fails, can be done by newtyping.
11:41:49 <kmc_> yes
11:42:00 <Cale> dancor: So imagine that you're going from Map String to Map Int to Map SomethingElse by applying monotone functions to the keys
11:42:08 <Cale> Then you don't have to rearrange the datastructure
11:42:10 <kmc_> if all access is typeclass-based, then you shouldn't care about the newtype wrapper anyway
11:42:17 <dancor> ah
11:43:15 <ksf> maybe there should be newtypeCoerce :: a -> b
11:43:21 <ksf> ...or with a better type.
11:43:27 <ksf> or as a typeclass.
11:43:39 <ksf> to have a common interface to wrap and unwrap newtypes.
11:43:41 <kmc_> ffs no
11:44:04 <ksf> ...iff you've got the constructor visible.
11:44:07 <Cale> Though I admit the advantage is a minor one (just a little log factor)
11:44:08 <kmc_> not if it works on any newtype
11:44:12 <ksf> granted, a lot of black magic there.
11:44:18 <Cale> So probably just going via IntMap is not going to be bad
11:44:39 <ksf> you could just give type sigs and cut through gazillions of newtypes in one go
11:44:57 <kmc_> class Unwrap a where type Underlying a; unwrap :: a -> Underlying a
11:45:06 <ksf> IntMap should'nt work on Ints but on any Bits a
11:45:14 <kmc_> data MyNewtype = MyNewtype MyUnderlying deriving (Unwrap)
11:45:21 <kmc_> err, s/data/newtyp/e
11:45:23 <kmc_> err, fail
11:45:32 <BONUS> hmm
11:45:36 <BONUS> htat's a cool idea though
11:45:45 <ksf> class Burrito a
11:45:50 <BONUS> class Newtyped a b | a -> b where unwrap :: a -> b
11:46:10 <kmc_> you can define "wrap" as well
11:46:16 <BONUS> instance Newtyped State (s -> (a,s)) where unwrap = getState
11:46:20 <kmc_> actually, a more general name would be "Isomorphic"
11:46:26 <BONUS> yah
11:46:33 <kmc_> because e.g. Isomorphic (a,b) (b,a)
11:46:38 <BONUS> but!
11:46:48 <BONUS> what would you wrap, say, (a,w) to
11:46:49 <BONUS> Writer?
11:47:00 <kmc_> well, the fundep only goes one way
11:47:11 <ksf> you have to give annotations
11:47:12 <kmc_> or the asstype
11:47:30 <Cale> It can get confusing if you choose a non-coherent bunch of isomorphisms in your instances though.
11:47:34 <copumpkin> asstype?
11:47:34 <ksf> and ghc then does some a* magic to find the path.
11:47:42 <BONUS> lol
11:47:44 <Cale> You want every diagram of isomorphisms constructed from instances of Isomorphism to commute.
11:48:24 <copumpkin> I hate it when my diagrams don't commute
11:48:41 <Cale> copumpkin: associated type, presumably
11:48:47 <copumpkin> ah
11:48:56 <kmc_> associated type
11:49:09 <copumpkin> aha
11:49:09 <dancor> if you have n isomorphic types, and you want the compiler to have a length 1 path between any two of them, aren't you going to end up writing a lot of extra stuff?
11:49:33 <Cale> dancor: yeah, n^2 instances
11:49:41 <dancor> and is that acceptable
11:49:52 <gnut> how can I specify the entry point of a shared object if I don't want it to be named "main"?
11:49:53 <Cale> dancor: But you can get many of them from composing others.
11:49:56 <gnut> hello all :)
11:49:57 <copumpkin> why the fundep?
11:50:19 <Cale> copumpkin: Probably in the general case you wouldn't have it
11:50:31 <dancor> O(n^2) instances, a little less than n^2 :)
11:50:34 <Cale> copumpkin: But a newtype is only a newtype of one particular type
11:50:39 <copumpkin> ah, fair enough
11:50:43 <kmc_> shared objects have entry points?
11:50:57 <gnut> kmc_: maybe I'm mistaken :)
11:51:02 <kmc_> i'm not sure
11:51:03 <dancor> don't shared objects just contain functions?
11:51:11 <kmc_> they can have init code as well
11:51:13 <Cale> dancor: Well, if you write Isomorphic A B, you probably also want Isomorphic B A
11:51:16 <ksf> prolly static inits
11:51:17 <gnut> okay.. maybe I'm not correct then in my thinking :)
11:51:18 <kmc_> not sure if there's a way to define that with ghc
11:51:30 <Cale> I suppose you can use overlapping instances
11:51:44 <Cale> ...maybe :)
11:51:49 <dancor> hm
11:52:09 <dancor> but i mean you don't have Isomorphic A A
11:52:12 <maltem> class InverseIso b a | a -> b where wrap :: b -> a
11:52:15 <Baughn> "fromADB (lines -> ((words -> (tag:(read -> code):(unwords->str))):fields)) = Reply{..}" <-- This may be how /not/ to use view patterns.
11:52:16 <dancor> so it's n^2 - n
11:52:57 <ksf> instance a ~ a => Isomoprhic a a
11:53:42 <maltem> It gets hairy when you ask if (Isomorphic a b, Monoid a, Monoid b) implies something interesting
11:53:43 <jlouis> @src init
11:53:45 <lambdabot> init [x]    = []
11:53:45 <lambdabot> init (x:xs) = x : init xs
11:53:45 <lambdabot> init []     = undefined
11:55:13 <dancor> maltem: i would say it doesn't, since i thought this was all about passing data around efficiently
11:55:35 <kmc_> maltem, it doesn't imply that wrap / unwrap is a monoid homomorphism
11:55:40 <kmc_> but it might be
11:55:57 <kmc_> Baughn, nice
11:55:58 <maltem> I know, you really shouldn't ask that question ;)
11:56:18 <Baughn> kmc_: I'm not sure "nice" is the appropriate word, but I'm not sure how to do that more elegantly either
11:56:27 <Baughn> At least this way, I don't need to name the intermediates
11:56:38 <kmc_> it's a very uncommon Haskell style
11:56:43 <kmc_> but perhaps a good one
11:56:47 <dancor> there are probably all kinds of things you could tell the compiler that might help it speed things up
11:56:49 <Baughn> View patterns are very new
11:57:58 <dancor> but you also might want it to check the things you say and a dependent type language might be better for that kind of thing
11:59:00 <monoidal> djinn can tell if there's a function of a given polymorphic type. Is it possible to list them all? (For example, a -> a -> a are const and flip const.)
11:59:02 <Vulpyne> Epigram time!
12:00:37 <copumpkin> monoidal: not in its current form, but I imagine it wouldn't be impossible to modify @djinn's source code to do that
12:00:47 <JohnnyL> if Haskell only uses one argument. Why is there are functions like 'break odd [2,4,5,6,8]
12:00:48 <JohnnyL> ' with two arguments?
12:00:56 <JohnnyL> > break odd [2,4,5,6,8]
12:00:58 <lambdabot>   ([2,4],[5,6,8])
12:01:01 <copumpkin> break odd gives a new function
12:01:05 <copumpkin> that takes one argument, a list
12:01:12 <mauke> JohnnyL: that's actually f x y is actually ((f x) y)
12:01:15 <mauke> er
12:01:19 <Baughn> @index fix
12:01:20 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
12:01:21 <mauke> +grammar
12:01:33 <JohnnyL> o hok
12:01:41 <Vulpyne> JohnnyL: Say you have a function f :: Int -> Int -> Int ; f x y = x + y
12:01:41 <copumpkin> hok hok
12:01:50 <mauke> say f is called (+)
12:01:51 <Vulpyne> f 1 :: Int -> Int
12:01:54 <mauke> > (+) 1 2
12:01:56 <lambdabot>   3
12:02:02 <JohnnyL> mauke thats composition?
12:02:16 <JohnnyL> or just 'order of precedence'?
12:02:20 <mauke> > let f = (+) 1; g = (+) 2  in  (f 1, g 1, f 10, g 10)
12:02:22 <lambdabot>   (2,3,11,12)
12:02:27 <mauke> JohnnyL: associativity
12:02:34 <JohnnyL> okay
12:02:51 <mauke> sort of
12:03:02 <monoidal> remember to read Int -> Int -> Int as Int -> (Int -> Int)
12:03:02 <Vulpyne> JohnnyL: The very simple way to look at it is if you call a function with less arguments than it wants, you get back a function that wants the remaining arguments.
12:03:54 <Jedai> JohnnyL: "Int -> Int -> Int" has implicit parenthesis due to the right-associativity of (->), explicitly it is "Int -> (Int -> Int)"
12:04:23 <JohnnyL> Jedai ok, Vulpyne ok
12:04:44 <Jedai> JohnnyL: That is "a function that takes one Int argument and evaluates to a function (that takes one Int argument and evaluate to an Int)"
12:05:07 <kmc_> :t break odd
12:05:09 <lambdabot> forall a. (Integral a) => [a] -> ([a], [a])
12:05:10 <kmc_> :t break
12:05:11 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:05:17 <JohnnyL> Jedai yah I am familiar with types.
12:05:28 <JohnnyL> or rather interpretation of them.
12:05:54 <JohnnyL> ah ok kmc_!
12:05:58 <Jedai> JohnnyL: Actually any function with several arguments can be turned into a function that takes only one argument and return a function, the process is called curryfication
12:06:13 <kmc_> i think it's called currying ;)
12:06:27 <Jedai> JohnnyL: thus the curry() and uncurry() functions in Haskell
12:06:48 <kmc_> :t let curryify = curry in curryify \(a,b) -> a+b
12:06:49 <lambdabot> parse error on input `\'
12:06:52 <Jedai> kmc_: Right, sorry curryfication is the french for currying
12:07:01 <kmc_> haha
12:07:06 <Jedai> :t curry
12:07:07 <kmc_> didn't know it was a different term
12:07:08 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
12:07:10 <Jedai> :t uncurry
12:07:11 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
12:07:52 <Jedai> kmc_: Just a different language and I sure meant to put currying but as a native french speaker I'm sometimes a bit confused...
12:08:56 <JohnnyL> Jedai Are you of the French Jedi Order?
12:08:59 <JohnnyL> haha jk!
12:09:00 <Baughn> Does "instance (Alternative a, Monad b) => Alternative (b a)" make sense?
12:09:20 <Jedai> JohnnyL: Not to the best of my knowledge...
12:09:31 <Baughn> ..no. It doesn't. Hm..
12:09:55 <Cale> Is "curryifique" the French translation for "curried"? :)
12:10:03 <jmcarthur_work> Baughn, what is it supposed to do?
12:10:56 <Cale> Ah, curryfiée
12:11:21 <Baughn> jmcarthur_work: Generalize 'instance Alternative (IO (Maybe a))'
12:11:29 <Baughn> jmcarthur_work: But it's the latter I'd actually want to use
12:12:52 <kmc_> :t liftA2
12:12:53 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
12:13:03 <kmc_> @src liftA2
12:13:04 <lambdabot> liftA2 f a b = f <$> a <*> b
12:14:02 <Cale> I find it interesting that on the French Wikipedia page for Curryfication the exposition is in French, and the identifiers in the code are in English. I suppose that makes sense.
12:15:23 <kmc_> in Spanish it's Currificación
12:16:17 <Cale> I like where the French Wikipedia puts the [modifier] links. On the English Wikipedia the [edit] links are way off on the right.
12:16:30 <kmc_> > let каррирование = curry in каррирование (\(a,b) -> a+b) 2 3
12:16:31 <lambdabot>   5
12:17:20 <kmc_> and naturally the French page has an example in Caml
12:19:44 * Baughn grumbles at Parsec's nonuse of Alternative
12:19:57 <jmcarthur_work> Baughn, parsec 3 uses it
12:20:12 <Baughn> jmcarthur_work: That'll be handy in ghc 6.12
12:20:42 <Baughn> It's a core library. Upgrading those is /never/ a good idea.
12:21:17 <Cale> It's also curious that they went with the cognate of modify rather than éditer.
12:21:39 <jmcarthur_work> for whatever reason, parsec 2 is the default if i don't specify which version to use in the cabal file and i have had no problems with 2 and 3 living side by side for a long time
12:23:38 <ksf> Baughn, try uu-parsinglib.
12:23:42 <ksf> you won't miss a thing
12:23:54 <ksf> ...unless you use those language-lex modules.
12:24:18 <ksf> in fact, you gain features by switching to uu
12:24:28 <kmc_> any good tutorials on uu?
12:24:32 <ksf> yep.
12:24:49 <ksf> it builds up the whole implementation from scratch.
12:24:53 <ksf> appplicatively, btw.
12:25:41 <ksf> those utrecht guys got stuff figured out
12:27:18 <chrisdone> (22:26:09) Chris : google search for 'recursion'
12:27:18 <chrisdone> (22:26:53) Paul : what am i looking for kid
12:27:18 <chrisdone> (22:27:00) Paul : eh
12:27:18 <chrisdone> (22:27:02) Paul : is google confused
12:27:21 <chrisdone> tee hee
12:28:01 <fmannan> lol
12:28:08 <Vanadium> Is cabal not supposed to yell at me if I import modules from packages that I do not explicitly depend on...?
12:28:19 <Baughn> ksf: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12121#a12121 <-- Oh, and this is what I had in mind. Can you think of a way to generalize that further?
12:29:31 <JohnnyL> is a curry like a 'signal' to xfer contentsts (say in a list) from the rightmost side to the leftmost side for each datum on the rightmost side?
12:29:41 <ksf> parsec comes with its own <|>, you can use that one with the applicative interface.
12:29:43 <mauke> huh?
12:30:16 <ksf> currying is the name for the isomorphism between (a,b) -> c and a -> b -> c
12:30:19 <ksf> that's all there is to it.
12:30:34 <mmx166mhz> I have a question: GHCi complains about " | " which I need for guards.
12:30:45 <mauke> mmx166mhz: then you're doing it wrong
12:30:52 <ksf> well, you can generalize it to n-tuples, but that's more or less obvious
12:31:04 <mmx166mhz> Ok, how should I do it? GHC says: parse error on input " | "
12:31:14 <ksf> then you're doing it wrong.
12:31:16 <chrisdone> foo x y | x > y = ..
12:31:22 <ksf> especially you're not pasting code.
12:31:42 <chrisdone> ksf: yeah, covered the "doing it wrong" part by GHC complaining.. sheesh
12:32:06 <mmx166mhz> Well, how should I type "|" otherwise?
12:32:15 <mauke> mmx166mhz: ...
12:32:20 <Twey> It's not how you type it, it's where you type it.
12:32:25 <mauke> mmx166mhz: are you new to this whole programming thing?
12:32:26 <ksf> in a way that's readable from my machine on hpaste.org
12:32:58 <mmx166mhz> Aha, well I made a file function.hs in which I tried to define a function, but got the parse error thing.
12:33:07 <ksf> yep.
12:33:07 <ski> @paste
12:33:08 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
12:33:18 <ski> mmx166mhz : paste your code there ?
12:33:19 <mauke> so you did something wrong
12:33:26 <ksf> and pasting that file would be a way to get answers that are actually helpful.
12:33:39 <mauke> why so vague? :-(
12:33:46 <mmx166mhz> signum x 	| x<0 =-1
12:33:46 <mmx166mhz> 	| x==0 =0
12:33:46 <mmx166mhz> 	| x>0 =1
12:33:50 <ksf> zomg
12:34:15 <monochrom> align all three |'s vertically. use space, no tab. shaken, not stirred.
12:34:15 <ksf> you don't need guards for that.
12:34:24 <mauke> alignment is optional
12:34:32 <chrisdone> ``=-''?
12:34:34 <ksf> well at least not for the zero case, and only for one ord case
12:34:45 <monochrom> Oh haha =-, good eyes
12:35:03 <mauke> @index signum
12:35:04 <lambdabot> Prelude
12:35:04 <mmx166mhz> Ok, but it is not wrong, right? I did them all on seperate line, aligned using tab
12:35:16 <ksf> tabs are considered evil.
12:35:17 <mauke> mmx166mhz: don't align with tabs. it doesn't work.
12:35:22 <mmx166mhz> ok
12:35:27 <ksf> they're going to be outlawed in h'.
12:35:28 <mauke> mmx166mhz: fortunately, they don't have to be aligned to work :-)
12:35:38 <mauke> mmx166mhz: your problem is =-1
12:35:49 <monochrom> For future reference, please do not respond to vague questions that don't come with actual code or reproducible experiment procedures. Don't answer to answer, just don't answer.
12:36:14 <mmx166mhz> Ok, what is the trouble with =-1?
12:36:23 <ksf> =- is an operator.
12:36:24 <mmx166mhz> (-1)
12:36:26 <mmx166mhz> aha
12:36:37 <ksf> not a = that'd define a function.
12:36:37 <chrisdone> monochrom: indeed
12:36:37 <mauke> mmx166mhz: put spaces around your ='s
12:36:49 <mauke> it looks better anyway
12:36:51 <mmx166mhz> Now it works :')
12:36:52 <ksf> so ghc is seeing two | without a = in between, and that doesnt' parse.
12:37:06 <mauke> mmx166mhz: also, 'signum' already exists in the standard library
12:37:20 <mmx166mhz> Pfff, I am new to Haskell, so just forget to enter neg. numbers with ()..
12:37:29 <mauke> mmx166mhz: what?
12:37:37 <mauke> no one said you should use ()
12:37:50 <mmx166mhz> It works now.
12:37:56 <mauke> yeah, just ignore me
12:38:13 <ksf> yep, because () aren't valid characters for operators.
12:38:15 <ksf> = is.
12:38:29 <ksf> like,
12:38:33 <ksf> :t (==)
12:38:34 <lambdabot> forall a. (Eq a) => a -> a -> Bool
12:40:16 <tensorpudding> @src (==)
12:40:16 <lambdabot> x == y = not (x /= y)
12:40:23 <tensorpudding> @src (/=)
12:40:23 <lambdabot> x /= y = not (x == y)
12:42:32 <chrisdone> wind blown
12:42:37 <chrisdone> mind too
12:43:15 <doublethink_work> minds are blown frequently in #haskell
12:43:19 <tensorpudding> it's the magic of typeclasses
12:43:24 <chrisdone> tensorpudding: guessing that's just filler for ghc to replace
12:43:33 <mauke> s/ghc/the programmer/
12:43:36 <chrisdone> tensorpudding: oh wait. one of them is optional
12:43:40 <tensorpudding> yes
12:43:41 <mauke> @src Eq
12:43:42 <lambdabot> class  Eq a  where
12:43:43 <lambdabot>     (==), (/=)   :: a -> a -> Bool
12:43:49 <tensorpudding> you define one, and the other is defined for you
12:43:49 <kmc_> those are default implementations
12:43:55 <chrisdone> ja
12:44:28 <chrisdone> I retract the mind blowing and replace it with a sense of familiarity
12:44:40 <ksf> we are #haskell. your mind will be blown.
12:46:21 <chrisdone> Haskell is like the raptor from Jurassic Park. it surprises you and all you can utter is "clever girl"
12:46:51 <ksf> it's also best harnessed by a good ole trusty model m.
12:46:54 <tensorpudding> haskell is a strict lazy velociraptor
12:47:06 <tensorpudding> err, static lazy velociraptor
12:47:48 <IceDane> (^2) . sum([1..100]) - doesn't work, why? o.o
12:48:11 <ksf> because the types don't match.
12:48:14 <tensorpudding> put a space between sum and its argument for one
12:48:23 <tensorpudding> :t sum [1..100]
12:48:23 <lambdabot> forall t. (Num t, Enum t) => t
12:48:31 <ksf> > (^2) . sum $ [1..100]
12:48:32 <lambdabot>   25502500
12:48:43 <IceDane> huh
12:48:46 <mauke> > ((^2) . sum) [1 .. 100]
12:48:48 <lambdabot>   25502500
12:48:48 <monochrom> > (^2) $ sum [1..100]
12:48:49 <ksf> note: $ isn't the same as brackets to the end of the line
12:48:50 <lambdabot>   25502500
12:49:01 <ksf> @src $
12:49:01 <lambdabot> f $ x = f x
12:49:05 <tensorpudding> > (^2) $ sum [1..100]
12:49:05 <lambdabot>   25502500
12:49:13 <monochrom> Why do you think you want . there?
12:49:28 <ksf> because what I wrote is good style.
12:49:40 <monochrom> I mean in (^2) . sum([1..100])
12:49:48 <IceDane> I have no idea.
12:49:48 <ksf> because you can delete the [1..100] and it's a curried function.
12:49:49 <tensorpudding> composition is nice but in this case unecessary
12:49:57 <Cale> Two guys are sitting on a bench and one says to the other "Hey, do you remember the time -" and the other guy cuts him off and says "I used to, but it just kept changing."
12:50:04 <shellsage> Can someone help me fix this Maybe:  http://haskell.pastebin.com/d6d10bbdd
12:50:08 <shellsage> lines 12 & 13
12:50:21 <tensorpudding> > let f = (^2) . sum in f [1..100]
12:50:23 <lambdabot>   25502500
12:50:24 <chrisdone> http://img269.imageshack.us/img269/3640/haskell.png
12:50:26 <monochrom> OK, "no idea" = "randomly generated code" = high probability of compiler error for obvious reasons.
12:50:49 <Cale> shellsage: return is not a keyword, it is a normal function
12:50:57 <tensorpudding> :t return
12:50:58 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
12:51:03 <IceDane> monochrom: I thought I was doing function composition as I thought it was the proper thing to do in the case
12:51:09 <IceDane> either way, I've been doing the language for.. 2 days
12:51:19 <IceDane> no, since yesterday, even
12:51:20 <shellsage> Cale, so you're saying I need another $?
12:51:22 <Cale> shellsage: So it has the same syntax properties as all other functions. You want  return . Just $ decode ...
12:51:29 <shellsage> ah ok
12:51:47 <Cale> Or, I might push the composition further:  return . Just . decode . rspBody $ resp
12:52:02 <ksf> wth is the type of a Text.JSON.Result?
12:52:09 <tensorpudding> return takes an x : Foo, and gives a monad-wrapped Foo
12:52:15 <ksf> and the error ghc gives would help trendemously.
12:52:19 <Cale> It had better be a type synonym for Maybe Something
12:52:43 <tensorpudding> > return 5 :: Maybe Int
12:52:45 <lambdabot>   Just 5
12:52:46 <monochrom> IceDane: Then what mauke said. ((^2) . sum) [1 .. 100]
12:53:22 <ksf> line 8 won't compile.
12:53:24 <Cale> For example, in the case of IO,  return v  is the IO action which does nothing when executed except to produce the result v
12:53:33 <ksf> it'd have to be return . Just $ ...
12:53:36 <Cale> yeah
12:53:43 <shellsage> I'm trying to figure out if the extra Maybe is superfluous, because http://hackage.haskell.org/packages/archive/json/0.4.3/doc/html/Text-JSON.html#t%3AResult is kind of like a Maybe
12:54:02 <shellsage> I think it is, so I guess I'm trying to figure out how to unwrap the result
12:54:03 <tensorpudding> > return 5 :: [a]
12:54:04 <lambdabot>   Could not deduce (GHC.Num.Num a) from the context ()
12:54:04 <lambdabot>    arising from the li...
12:54:10 <Cale> oh,  data Result a = Ok a | Error String
12:54:14 <tensorpudding> hmm
12:54:17 <shellsage> Cale, yeah
12:54:23 <Cale> So, it's not the same as Maybe
12:54:24 <tensorpudding> > return 5 :: [Int]
12:54:25 <ksf> well, obviously, Result /= Maybe.
12:54:25 <lambdabot>   [5]
12:54:36 <Cale> You should replace Just with Ok and Nothing with Error "foo"
12:54:38 <ksf> in fact, Result is isomorphic to Either.
12:54:39 <shellsage> but aren't their intents similar? success or error
12:54:45 <Cale> yes
12:54:47 <shellsage> ah ok
12:54:49 <Cale> But they're not the same type
12:54:51 <ksf> but you're going to have to use Result, not Maybe or Either.
12:54:54 <shellsage> right I get that
12:55:17 <ksf> er no isomorphic to Either String
12:55:17 <Cale> (Beats me why the author of the JSON library thought it would be a good idea to reinvent Either String)
12:55:51 <chrisdone> Cale: yeah I see that a lot
12:55:52 <Cale> I guess the syntax reads a little more nicely for the specialised usage.
12:56:07 <Cale> But still... it's inconvenient to lose all the library functions which work on Either
12:56:15 <ksf> but two functions would suffice to do that
12:56:18 <Cale> I guess it has all the requisite instances
12:56:29 <pythonista> Does haskell have a higher sexyness/usefulness ratio than erlang? I'm trying to decide which one to learn...
12:56:39 <ksf> definitely.
12:56:42 <kmc_> haskell is sexy and useful
12:56:52 <kmc_> furthermore it's the Way of the Future
12:56:52 <Kim^Walkman> You're asking in a #haskell-channel :p
12:56:57 <kmc_> due to purity
12:57:04 <mauke> pythonista: learn all of them
12:57:08 <chrisdone> pythonista: I would learn both
12:57:11 <jelly12gen> haskell is nice
12:57:14 <Axman6> pythonista: i'd say so, and the typing of haskell makes it much easier for the compiler to find your bugs for you
12:57:14 <jmcarthur_work> pythonista, yes. erlang has a niche for which i believe it to be superior to haskell, but for anything outside of that (rather small) niche, i think haskell is the clear winner
12:57:17 <jelly12gen> and XMonad is godlike
12:57:22 <pythonista> yes but the ratio? is erlang more useful?
12:57:22 <kmc_> Erlang syntax has weird syntax, and no static typing
12:57:28 <ksf> and if you still have doubts, haskell even comes with a library so you can code erlang nodes in it.
12:57:34 <jelly12gen> haskell has nice docs
12:57:40 <chrisdone> pythonista: more useful for the niche, probably
12:57:44 <Cale> pythonista: I don't think so, but I think *possibly* it's more widely used.
12:57:45 <chrisdone> (that's why it's a niche)
12:57:45 <jmcarthur_work> oh wait, a ratio
12:57:45 <Axman6> pythonista: i wouldn't say so, and you can use haskell as an erlang node anyway ;)
12:57:49 <ksf> possibly if you intend to program a telecom switch. otherwise, no.
12:57:52 <jelly12gen> pythonista: hoogle is nice
12:57:54 <kmc_> at this point Haskell is getting more industrial attention than Erlang
12:57:54 <jmcarthur_work> sexiness:usefulness?
12:58:05 <jelly12gen> jmcarthur_work: it's like your vpenis
12:58:05 <kmc_> dons said there were more Haskellites than Erlangistas at the most recent CUFP
12:58:10 <Kim^Walkman> Haskell documentation is horrible imo, but hte community support is nice
12:58:16 <jelly12gen> Kim^Walkman: WUT
12:58:18 <kmc_> the documentation is really good
12:58:19 <gnut> Is there a way to have functions in haskell appear with a certain name in a shared object? i.e., I'm trying to make a shared object so that another program (which is used to calling shared objects written in C) can call my haskell function.
12:58:21 <jmcarthur_work> i'm not sure that makes sense. sexy and useful are very much not at odds with one another
12:58:22 <pythonista> wow guys, I'm just gonna catch up on your answers for a while :D thanks for the great input!
12:58:23 <Cale> pythonista: Erlang was practical first, Haskell was theoretical first. Haskell has been moving in the direction of practicality though.
12:58:23 <jelly12gen> the docs are great
12:58:24 <kmc_> http://www.haskell.org/ghc/docs/latest/html/libraries/
12:58:32 <mauke> @where ffi
12:58:33 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
12:58:33 <Axman6> nah, i don't think our docs are that great
12:58:34 <kmc_> ^^^ bookmark this, or tattoo the URL on your forehead
12:58:39 <jelly12gen> i do
12:58:43 <ksf> especially if it uses clear terminology like zygohisomorphic prepromorphism.
12:58:44 <kmc_> and anything else is on hackage
12:58:45 <jmcarthur_work> pythonista, haskell is both sexy and useful ;)
12:58:48 <Kim^Walkman> The docs say what things are, not how you use them
12:58:48 <mauke> gnut: I think the FFI lets you "export" functions
12:59:07 <Cale> pythonista: and there are now enough libraries for Haskell that I can't possibly hope to learn the ideas behind them all, so that's more than enough for me ;)
12:59:10 <jelly12gen> Kim^Walkman: so
12:59:11 <chrisdone> kmc_: I wonder if that is mutually exclusive
12:59:25 <Kim^Walkman> I can't count the times I've had to read the source instead of the documentation to understand how to use a library
12:59:28 * FunctorSalad is going crazy trying to write the TH for bind_n
12:59:31 <chrisdone> kmc_: wouldn't be surprised if some erlangers became haskellites or vise versa
12:59:33 <gnut> mauke: I am trying that. will it have the modulename prepended?
12:59:39 <kmc_> yeah me either
12:59:40 <FunctorSalad> I can do it with "do", but that's cheating ;)
12:59:41 <Axman6> Kim^Walkman: that's not necessarilly a bad thing
12:59:46 <mauke> gnut: very unlikely
12:59:58 <kmc_> Haskell has lightweight threads, channels, and software transactional memory
13:00:04 <chrisdone> @users
13:00:05 <lambdabot> Unknown command, try @list
13:00:05 <Cale> Kim^Walkman: That is mildly unfortunate. I usually get by on the types and function names at first :)
13:00:08 <Axman6> Kim^Walkman: haskell code is clear anc concise enough that it can be used as its own documentation
13:00:09 <kmc_> but it doesn't have the distributed features of Erlang, to my knowledge
13:00:14 <gnut> mauke: okay. I'll continue trying that then until I get it to compile :)
13:00:14 <kmc_> Axman6, haha
13:00:18 * SubStack thinks it'd be awesome to have transactional IO
13:00:23 <Axman6> and*
13:00:24 <kmc_> people have been saying that about programming languages since the dawn of time
13:00:27 <Axman6> kmc_: ?
13:00:31 <Kim^Walkman> Don't get me wrong, I love the language, and reading source *is* educational
13:00:32 <SubStack> but that would require massive amounts of plumbing
13:00:35 <kmc_> we may be closer but it's still hilariously false
13:00:38 <Axman6> yeah, but it's true with haskell :P
13:00:49 <Cale> SubStack: Rolling back a transaction in which you've read input from the user is also tricky.
13:01:03 <kmc_> with good design, function names and types will give you *most* of the documentation
13:01:07 <SubStack> can't exactly take packets back off the network either
13:01:08 <Kim^Walkman> But documentation for most packages still have a lot to offer; maybe because it's written by programmers ^.-
13:01:17 <kmc_> SubStack, you can unsend email in MS Exchange :)
13:01:24 <SubStack> tehe
13:01:32 <chrisdone> types in Haskell are brilliant documentation mostly because it can described functions and has aliases
13:02:15 <chrisdone> type UserName = String -- brilliant
13:02:28 <monochrom> PHP libs have vague and wrong docs. OK, this doesn't defend haskell lib docs. :)
13:02:31 <chrisdone> what other languages do that?
13:02:37 <ksf> and because you can have haddock comments for every -> in the type, which most people don't seem to know.
13:02:45 <Cale> One simple thing which really helps in using types as documentation is to always remember that if you need a value of type A, don't just look for functions of type (... -> A), but also functions of type ((A -> ...) -> ...)
13:02:51 <kmc_> types are great because they're like comments that can't be wrong
13:02:54 <ksf> chrisdone, C?
13:03:03 <jmcarthur_work> Kim^Walkman, i think most haskell documentation is excellent. i think the biggest thing lacking is example code, most of the time
13:03:09 <ksf> not every language has newtypes.
13:03:11 <monochrom> I forgot the exact example I saw but it is on the order of "float_to_int: this function converts float to int. any question?"
13:03:16 <jmcarthur_work> and that is nothing unique to haskell, although some cultures encourage it more than others
13:03:17 <kmc_> Cale, a good point.  which makes me wonder if Hoogle has a mode to search by contravariance
13:03:28 <Kim^Walkman> jmcarthur_work: I'd go as far as saying example code almost is a part of the documentation, but maybe that's just me :p
13:03:40 <kmc_> int x = y + 3;  // Set the variable 'x' to be equal to the value in the variable 'y' plus four.
13:03:48 <jmcarthur_work> Kim^Walkman, i'm not sure how else to see example code
13:04:09 <kmc_> some modules do have examples in their haddock
13:04:16 <jmcarthur_work> Kim^Walkman, oh, you thought i was saying it was not documentation
13:04:19 <Cale> monochrom: ahahaha
13:04:21 <jmcarthur_work> that's not what i meant ;)
13:04:32 <Kim^Walkman> jmcarthur_work: Naw, just further emphasizing what you said ;)
13:04:44 <Kim^Walkman> or something
13:05:06 <monochrom> I agree with Kim^Walkman for haskell, much more than for other languages. Haskell encourages combinator libs, and these need examples the most. (In fact, can't really explain individual combinators and expect to make sense. The devil is in the compositions.)
13:05:47 <gnut> is it possible to write C-callable haskell functions without writing any glue code in C?
13:05:49 <chrisdone> the parsec library is an example of superb example-based documentation
13:05:52 <lispy> Haskell is meant to be very compositional
13:05:55 <shellsage> Based on the Text.JSON library, can someone help me figure out how to make this of the type [(String, SomeStandardType)]:    http://haskell.pastebin.com/d2fb60090
13:05:56 <Cale> monochrom: If that was the spec, I would have it take the mantissa and exponent, and return 3^exponent * 5^mantissa mod 2^32
13:05:58 <gnut> in a shared object?
13:06:13 <Heffalump> can anyone point me to some good references on testing asynchronous code?
13:06:23 <kmc_> gnut, does a normal foreign export not do what you want
13:06:30 <gnut> I got my function to export the write symbol name, but the calling program is crashing saying RTS is not initialized.
13:06:40 <lispy> oh
13:06:43 <gnut> kmc_: it does export the function name, so that's great.
13:06:50 <kmc_> that's because you gotta initialize the RTS first ;)
13:06:53 * Cale follows the principle of maximal surprise in implementing vague specifications
13:07:06 <lispy> gnut: yeah, you probably need to call a bit of C code to init the run-time in your process
13:07:07 <gnut> kmc_: but it says newBoundTask: RTS not initialized..
13:07:25 <lispy> gnut: is this GHC?
13:07:28 <gnut> okay... hrm... that's what I wanted to do away with... :)
13:07:32 <gnut> yeah.. ghc
13:07:56 <gnut> I have gotten the thing to work by having some glue code in C using startupHaskell()
13:08:13 <gnut> but I just want to avoid C since I would like everything to be in haskell :)
13:08:14 <Cale> gnut: You must call the rts init function first.
13:08:16 <lispy> gnut: are you using DLLs or .so?
13:08:22 <gnut> .so
13:08:37 <gnut> Cale: okay... and I suppose the only way to do that is in C. okay okay... shucks.
13:08:58 <FunctorSalad> isn't there some neat recursive definition for bind_m ? (without making the list of needed variables upfront)
13:09:06 <lispy> Yeah, I can't imagine how the Haskell RTS would init itself from Haskell :)
13:09:20 <Cale> gnut: Well, you just need whoever is using your library to call hs_init somewhere near the start of their program.
13:09:23 <FunctorSalad> I mean the function of type:
13:09:32 <doublethink_work> seeing all the stuff on -cafe about ghc's sometimes ridiculous linking speed makes me happy that 6.12 will finally ship stock with dynamic library support
13:09:37 <Cale> Or else, maybe .so has a way to add a main procedure to run when it's loaded?
13:09:38 <FunctorSalad> (a1 -> a2 -> ..... -> m y) -> m a1 -> m a2 -> ... m y
13:10:04 <gnut> lispy: heh... yeah. I was just hoping that perhaps if they look the same, the calling program wouldn't care if it's written in haskell or C, but I guess it needs the RTS to be initialized to interpret the exported symbols written in haskell?
13:10:13 <lispy> doublethink_work: I still think someone should improve GNU ld...Maybe it's not that hard?
13:10:40 <lispy> gnut: it needs the RTS for garbage collection and laziness, among other things
13:10:46 <Cale> gnut: Haskell code is native code, but it uses a lot of facilities (like the garbage collector, thread scheduler, etc.) which have to be started up before it can execute
13:10:49 <lispy> IO is probably in that bag too
13:10:56 <gnut> ah...okay.
13:11:02 <FunctorSalad> @djinn Monad m => (a1 -> a2 -> a3 -> m y) -> m a1 -> m a2 -> m a3  -> m y
13:11:02 <lambdabot> -- f cannot be realized.
13:11:09 <Cale> I think laziness doesn't really require the RTS, does it?
13:11:15 <FunctorSalad> lambdabot: that's not true
13:11:26 <Cale> (apart from the fact that everything would go to hell very quickly without a GC)
13:11:29 <lispy> Cale: depends on what you consider the RTS.  Note that C has an RTS.
13:11:41 <doublethink_work> lispy: ld is a bit old and crazy from what I understand, which is what motivated ian taylor to write gold
13:11:43 <lispy> (under my definition of RTS that is)
13:12:00 <FunctorSalad> @undo do { w1 <- x1; w2 <- x2; w3 <- x3; f x1 x2 x3 }
13:12:00 <lambdabot> x1 >>= \ w1 -> x2 >>= \ w2 -> x3 >>= \ w3 -> f x1 x2 x3
13:12:05 * lispy has an appointment to catch.  Cheers!
13:12:14 <doublethink_work> lispy: and gold can't be used for everything even still; there are a lot of projects that really abuse ld in crazy ways (linux is one i think,) so who knows how much effort improving link-times could take :/
13:12:23 <gnut> there's no way to export functions such that when they're called, they automatically start up the RTS?
13:12:32 <FunctorSalad> @pl \f x1 x2 x3 -> x1 >>= \ w1 -> x2 >>= \ w2 -> x3 >>= \ w3 -> f x1 x2 x3
13:12:32 <lambdabot> ap ((.) . (.) . (>>=)) . ((((const .) .) . liftM2 (.) (>>=) . (((const .) . ap (>>=) . (const .)) .)) .)
13:12:37 <FunctorSalad> :)
13:12:40 <doublethink_work> on that note I wonder if anybody has tried using GHC + gold for linking
13:13:06 <Cale> Multiple invocations of hs_init() are permitted, provided that they are followed by an equal number of calls to hs_exit() and that the first call to hs_exit() is after the last call to hs_init().
13:14:35 <FunctorSalad> @pl \x1 x2 x3 -> x1 >>= \ w1 -> x2 >>= \ w2 -> x3 >>= \ w3 -> f x1 x2 x3
13:14:35 <lambdabot> ap ((.) . (.) . (>>=)) (((const .) .) . liftM2 (.) (>>=) . (((const .) . ap (>>=) . (const .)) .) . f)
13:14:39 <gnut> Cale: is there a way where each exported haskell function is sandwiched by hs_init() and hs_exit() automatically (added during the linking/compiling phase) without having to explicitly write C code to do this sandwich?
13:14:40 <Cale> gnut: So... I think that's hard. It would be an awfully nice thing to have.
13:15:08 <gnut> Cale: yeah. it would be nice :)
13:15:22 <Cale> I mean, where the first call to a haskell function would start the RTS, and somehow automagically it would shut down properly when the C program is exiting.
13:15:25 <gnut> maybe inefficient if you want to run several functions to have to start up a new RTS each time
13:15:47 <Cale> But my understanding is that C programmers are used to bad APIs which force you to do this stuff. ;)
13:15:48 <shellsage> With Text.JSON, if I have the type: fromJSObject val :: [(String, JSValue)], how do I convert JSValues into something more primitive?  I can't find a function to do it, so I'd like to write one, but I don't know what type sig to give it because I want it to return some arbitrary type that is String, Bool, Array, etc.
13:15:48 <mauke> where automagically = atexit(hs_exit);
13:16:27 <gnut> it would make writing plugins in haskell less cumbersome if you could stay wholly in haskell and not have to write C wrappers to handle the RTS init/exit
13:16:40 <Cale> plugins?
13:16:42 <gnut> which is what I'm doing now :)
13:16:48 <gnut> well, shared objects that get called
13:16:54 <Cale> ah
13:17:00 <gnut> maybe plugins is not the right term
13:17:07 <Cale> If they were plugins to a Haskell program, you could do something nicer.
13:17:25 <Cale> Actually, there's an idea.
13:17:40 <gnut> yeah.. but most commercial software that we may want to add functionality to are written in C :)
13:17:54 <Cale> You could write a single .so wrapper plugin which uses hint/GHC API to build or link Haskell code dynamically.
13:18:04 <gnut> hmmm
13:18:06 <bran> shellsage: i believe with the readJSON Typeclass
13:19:40 <shellsage> bran, Ambiguous type variable `a' in the constraint:      `JSON a' arising from a use of `readJSON' at <interactive>:1:0-58
13:19:59 <shellsage> but I'm not sure what is ambiguous here
13:20:11 <shellsage> that came from running:  readJSON (fromJust (lookup "following" (fromJSObject val)))
13:20:14 <gnut> Cale: so you write a C wrapper that is not specific to your haskell code, and then link it in so that when the commercial app wants to call your function, the wrapper starts the RTS beforehand... but you write this wrapper only once?
13:20:52 <mauke> shellsage: it doesn't know which type you want to read
13:21:03 <mauke> apparently
13:21:13 <shellsage> mauke, neither do I, so do I have to write a function to do this conversion, and switch on the type I get?
13:21:50 <gnut> oh wait... no. I guess you write C code to call a function, and then you write haskell functions with that specific name.. and you link them together... ah.. sounds like an idea
13:22:17 <blackh> shellsage: You need to decide what type you want it to convert to and put a type signature on for that type.
13:24:56 <pythonista> Does haskell provide the same level of (dare I say dynamic?) runtime distribution over a network as erlang? If so, is there a de facto way of doing it in haskell?
13:25:26 <doublethink_work> not natively, no
13:26:07 <pythonista> any good paste?
13:26:14 <copumpkin> @hpaste
13:26:15 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
13:26:22 <gwern> mmm... paste
13:26:28 <copumpkin> lol
13:26:56 <Gracenotes> I have some good copypasta recipes
13:27:07 <Gracenotes> close enough, right
13:29:55 <yamafaktory> Hi everybody, i'm currently trying to understand monads
13:31:06 <yamafaktory> so I try to compute these two functions :
13:31:18 <yamafaktory> power :: Num a => a -> a
13:31:26 <yamafaktory> power x = x^2
13:31:33 <yamafaktory> minus :: Num a => a -> a
13:31:40 <gwern> :t (^)
13:31:41 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
13:31:48 <yamafaktory> minus x = x-10
13:32:06 <yamafaktory> mymona x = power x >>= minus
13:32:23 <gwern> ?
13:32:24 <yamafaktory> but I don't find the type of it
13:32:41 <yamafaktory> mymona :: ??
13:32:41 <kmc_> :t let power x = x^2; minus x = x-10 in power x >>= minus
13:32:43 <lambdabot>     Couldn't match expected type `m a' against inferred type `Expr'
13:32:43 <lambdabot>     In the first argument of `(>>=)', namely `power x'
13:32:43 <lambdabot>     In the expression: power x >>= minus
13:32:46 <gwern> because that doesn't check
13:32:52 <tensorpudding> :t (>>=)
13:32:52 <gwern> :t (>>=)
13:32:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:32:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:32:57 <kmc_> yamafaktory, are you sure you want to use monads rather than simple function application / composition?
13:32:57 <Gracenotes> :o
13:33:04 <Gracenotes> you're trying to understand the function monad in particular?
13:33:10 <kmc_> if you're learning monads i suggest you start with Maybe or [], not the ((->) e) monad
13:33:11 <yamafaktory> in fact I just want to understand it
13:33:17 <gwern> yamafaktory: a -> a is not m a -> m a
13:33:22 <JohnnyL> whats the difference between composition and currying?
13:33:33 <kmc_> JohnnyL, everythingh
13:33:47 <kmc_> in what way do you think they're the same?
13:33:54 <Gracenotes> I'm not sure composition and currying exist on the same level of.. conceptualness..
13:33:55 <Cale> currying is taking functions (a,b) -> c and turning them into functions a -> (b -> c)
13:33:59 <JohnnyL> >:t (.)
13:34:06 <kmc_> :t (.)
13:34:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:34:08 <kmc_> :t curry
13:34:09 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
13:34:13 <kmc_> so yeah, pretty different
13:34:20 <tensorpudding> composition is taking two functions and applying one after the other
13:34:23 <kmc_> for (.) you can read (a -> b) -> (c -> a) -> (c -> b)
13:34:23 <Cale> composition is taking a function (b -> c), and a function (a -> b), and turning them into a function (a -> c)
13:34:23 <gwern> @wn katzenjammer
13:34:25 <lambdabot> *** "katzenjammer" wn "WordNet (r) 2.0"
13:34:25 <lambdabot> katzenjammer
13:34:25 <lambdabot>      n 1: disagreeable aftereffects from the use of drugs (especially
13:34:25 <lambdabot>           alcohol) [syn: {hangover}]
13:34:25 <lambdabot>      2: loud confused noise from many sources [syn: {hubbub}, {uproar},
13:34:27 <lambdabot>          {brouhaha}]
13:34:33 <Gracenotes> of course, currying is often abused to mean "partial application"..
13:34:44 <ystael> Gracenotes: really?  :X
13:34:46 <kmc_> right, partial application is something you can do to a curried function
13:35:11 <Gracenotes> it is like automatic currying/uncurrying, sort of. but it is also a lot more.
13:35:14 <tensorpudding> (f . g) x means, take the result of g x, and use that as input for f, and return the result
13:35:57 <Cale> Are people enjoying my blog articles? I have a feeling that I should cover some more introductory material about natural transformations as well (well, I will, the question is about when)
13:35:59 <tensorpudding> or is it the other way around
13:36:13 <gwern> yamafaktory: you want something like 'mymona = minus . power' or 'mymona x = minus (power x)' or 'mymona x = minus $ power x'
13:36:17 <kmc_> one definition of partial application would be an application that reduces to another abstraction in one  step
13:36:18 <IceDane> Cale: Link?
13:36:23 <doublethink_work> Cale: it's about time you got a blog to post all your awesome stuff on :) searching reddit comments can get tiring!
13:36:27 <tensorpudding> > ((+2) . (*3)) 5
13:36:27 <Cale> http://analogical-engine.com/wordpress/
13:36:28 <lambdabot>   17
13:36:34 <tensorpudding> ah, i am right
13:36:53 <Cale> doublethink_work: Just to be clear, it's not all mine though. I'm writing it with my friend Robin.
13:36:54 <IceDane> esult of g x, and use that as  input for f, and return th
13:37:16 <dancor> among FRP libs that actually work, which is the fastest
13:37:30 <tensorpudding> composition of haskell function is exactly the same as composition of functions in maths
13:37:36 <Cale> tensorpudding: indeed
13:37:36 <IceDane> eh, sorry
13:37:48 <IceDane> Cale: You studying computer science?
13:37:54 <Cale> tensorpudding: and we tend to think of Haskell types as arranged into a category
13:38:21 <Cale> IceDane: Insofar as it is a branch of mathematics, sure :)
13:38:23 <tensorpudding> compositions of arrows in a category are important
13:39:10 <yamafaktory> @gwern -> I understand what you're showing with your example, something like f°g. But In fatc, I want to do it with monad, maybe I'm totally wrong :p
13:39:11 <lambdabot> Unknown command, try @list
13:39:27 <Cale> IceDane: Eventually there will be some posts more closely linked to Haskell
13:39:34 <yamafaktory> gwern -> I understand what you're showing with your example, something like f°g. But In fatc, I want to do it with monad, maybe I'm totally wrong :p
13:39:49 <IceDane> I see.
13:40:04 <gwern> yamafaktory: well, I'm not really sure how you could do that monadically. a monad must have a type like 'm a', and you just have 'a'
13:40:15 <gwern> are you doing it in the list monad? a state monad?
13:40:35 <gwern> you need to choose your m
13:40:52 <yamafaktory> ok
13:41:55 <JohnnyL> Cale hm, does that mean any compositions evaluated have to be done so serially?
13:42:31 <yamafaktory> after having looked at the awesome beckman video, I thought that it was possible to do something like that.
13:42:53 <ksf> nope, it isn't, Num isn't meant to be used monadically.
13:43:12 <kmc_> what's this video?
13:43:25 <yamafaktory> ok, thanks for your answer
13:43:36 <yamafaktory> just a second
13:43:36 <kmc_> yamafaktory, monads are not everything
13:43:56 <FunctorSalad> I have -Wall on but get no "defined but not used" warning for unused and unexported toplevel decls
13:44:08 <FunctorSalad> (I do have an explicit export list)
13:44:18 <kmc_> they're an extremely powerful tool for structuring computation
13:44:28 <gwern> FunctorSalad: and yet if you remove the unused, compilation fails?
13:44:30 <tensorpudding> monads allow you to sequence actions
13:44:37 <kmc_> but in some sense, functions are a more powerful tool
13:44:51 <FunctorSalad> gwern: no, other way around :) they *are* unused but I get no warning
13:44:59 <kmc_> in that monads are not a special language feature; they're implmented using ordinary higher-order functions plus algebraic data types
13:45:04 <gwern> FunctorSalad: hm. you sure?
13:45:05 <ksf> tensorpudding, nope, applicative functors allow you to do that.
13:45:11 <kmc_> http://haskell.org/haskellwiki/What_a_Monad_is_not
13:45:18 <yamafaktory> http://channel9.msdn.com/shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads/
13:45:20 <tensorpudding> yes, applicative can do that as well
13:45:30 <FunctorSalad> gwern: well when I search for the name of the function in the buffer, I get only the decl itself as hit
13:45:48 <ksf> monads additionally allow you to influence the rest of the sequence by matching on intermediate results...
13:45:53 <ksf> notice the contravariance of
13:45:58 <ksf> :t (>>=)
13:45:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:46:01 <gwern> FunctorSalad: well, if nothing is using it, and you're not exporting it, and it doesn't cause compilation to fail, then maybe it is a ghc issue
13:46:12 <tensorpudding> a monad is just a monoid on the category of endofunctors
13:46:15 <ksf> _that's_ what monads are about.
13:46:25 <dancor> FunctorSalad: i get the warning.  -fforce-recomp?
13:46:34 <FunctorSalad> dancor: it's ghci
13:46:41 <FunctorSalad> (emacs)
13:46:53 <copumpkin> that's got to be one of the most common sentences in this channel
13:47:06 <jmcarthur_work> copumpkin, it's ghci?
13:47:11 <Cale> JohnnyL: actually they're evaluated in exactly the opposite order you might expect
13:47:12 <FunctorSalad> I get it in other files too, but not in this one :)
13:47:19 <ksf> in short, monads allow you to define the rest of the computation by inspecting the result of the computation up to the point you're currently at.
13:47:22 <copumpkin> the monoid object in the category of endofunctors
13:47:28 * dcolish wonders if he should learn emacs
13:47:28 <dancor> Lol.hs:7:0: Warning: Defined but not used: `b'
13:47:32 <ksf> ...and also recursively if you happen to have a MonadFix at hand.
13:47:32 <dancor> Ok, modules loaded: Main, Lol.
13:47:34 <tensorpudding> dcolish: do it
13:47:37 <dcolish> heh
13:47:44 <FunctorSalad> well a monoid object in a  category of endofunctors is just a ...
13:47:46 <Cale> JohnnyL: it goes (f . g) x --> f (g x) --> ...the body of f with g x substituted for the parameter ...
13:47:56 <jmcarthur_work> FunctorSalad, toxic waste bin!
13:47:59 <dcolish> i've been pretty hardcore vim, but i've also been seeing a lot of nice features in emacs recently
13:48:02 * copumpkin rips FunctorSalad's tongue out
13:48:07 <FunctorSalad> oh no
13:48:14 <Cale> JohnnyL: Of course, it doesn't actually matter what order things are evaluated, you'll get the same result
13:48:17 <copumpkin> FunctorSalad: surely you mean ".. .."
13:48:23 <jmcarthur_work> FunctorSalad, you mean "oh ro"
13:48:25 <dancor> FunctorSalad: maybe you should paste a minimal example then?
13:48:27 <yamafaktory> thanks for your help ! I'll read more about monad
13:48:28 <kmc_> yamafaktory, do you understand the Maybe monad?
13:48:31 <doublethink_work> HI GUYS HOW DOES I MONOID IN THE ENDOFUCTOR CAT?!!?
13:48:31 <gwern> it's funny how these days, the scheme style of list functions which go 'function list int' looks so odd and alien to me
13:48:35 <tensorpudding> emacs and vim appeal to different ideas of what an editor can do
13:48:36 <dcolish> Maybe...
13:48:42 <dcolish> tensorpudding: yes
13:48:44 <JohnnyL> Cale I am assuming they are not parallelizable?
13:48:45 <gwern> doublethink_work: might work as a lambdabcat
13:48:55 <Cale> JohnnyL: evaluation steps?
13:48:55 <tensorpudding> i use both
13:49:02 <JohnnyL> Cale yah
13:49:04 <doublethink_work> gwern: would need work
13:49:05 <kmc_> yamafaktory, i think Maybe is the simplest useful monad and a great place to start.  in particular, you can define it yourself in a few lines of code
13:49:15 <dcolish> tensorpudding: that sounds like a good approach
13:49:19 <FunctorSalad> doublethink_work: U CAN HAS STARTS WITH MONOIDAL PRODUCKT
13:49:33 <doublethink_work> ORLY? THNX
13:49:38 <Cale> JohnnyL: You could do something like  let y = g x in y `par` f y
13:49:41 <copumpkin> kmc_: I still think one should go through Functor, Pointed, Applicative first
13:49:55 <ksf> typeclassopedia ftw
13:50:01 <ksf> @where typeclassopedia
13:50:01 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
13:50:02 <FunctorSalad> dancor: hmm the module is pretty big :)
13:50:04 <Cale> JohnnyL: and provided that maybe f doesn't need its parameter right away, but only maybe later on in its evaluation
13:50:09 <mauke> typeclassiopeia
13:50:10 <tensorpudding> though i think of myself as primarily an emacs user because i never learned any of the masterful vim tricks
13:50:11 <FunctorSalad> dancor: maybe it's one of the language extensions
13:50:14 <copumpkin> lol
13:50:21 <kmc_> copumpkin, that's decent advice
13:50:31 <kmc_> unfortunately for historical reasons the stdlib is not structured that way
13:50:35 <yamafaktory> kmc_ something like data Maybe a = Just a | Nothing   deriving (Eq, Show) ?
13:50:37 <copumpkin> starting with Monad seems like getting thrown in the deep end
13:50:40 <Cale> JohnnyL: that would put y (= g x) into a queue of things to be evaluated in parallel, so that maybe by the time f needs it, g x will have been evaluated
13:50:45 <copumpkin> and people will get put off with all these scary abstract methods
13:50:48 <kmc_> yamafaktory, sure, you've defined Maybe
13:50:55 <dancor> FunctorSalad: you either have to shrink it down and debug it, paste it for someone else to, or give up ;)
13:50:59 <kmc_> now you can write a typeclass instance to make it a Monad
13:51:00 <JohnnyL> Cale: Damn son, you be droppin' some science on me!
13:51:06 <ksf> ...but not the monad over Maybes.
13:51:18 <ksf> let's start with return.
13:51:21 <ksf> :t return
13:51:22 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
13:51:32 <mauke> JohnnyL: http://i37.tinypic.com/24fwsn8.jpg
13:51:46 <ksf> and assum that we already have written "instance Monad Maybe where"
13:51:50 <FunctorSalad> copumpkin: I wouldn't say Monad is more abstract than Applicative
13:51:57 <FunctorSalad> at least not in a didactic sense
13:52:12 <ksf> yamafaktory, if you have an a, how do you get a value that is a Maybe a?
13:52:30 <copumpkin> FunctorSalad: maybe not, but I think it's a nice gradual walk to phrase it in terms of adding additional requirements, from fmap, pure, ap, and finally join
13:52:31 <ksf> (there's only one way)
13:52:54 <copumpkin> FunctorSalad: >>= has a really scary type signature for a newbie
13:53:08 <ksf> "contravariance" is a scary word.
13:53:09 <FunctorSalad> copumpkin: yeah, maybe join is better
13:53:10 <Cale> JohnnyL: For the typical strict function which pattern matches on its argument right away that would indeed be a waste though
13:53:15 <ksf> too many syllables.
13:53:21 <JohnnyL> :t par
13:53:23 <lambdabot> forall a b. a -> b -> b
13:53:28 <tensorpudding> :t join
13:53:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:53:39 <FunctorSalad> ksf: maybe have cute "covariance cat" and "contravariance cat" next to the text
13:53:45 <yamafaktory> ksf using Nothing and Just ?
13:53:45 <copumpkin> lol
13:53:54 <ksf> er yes, one of those two.
13:53:55 <Cale> You can think of x `par` y as something which evaluates to y, but suggests to the runtime that maybe evaluating x would be a good idea now, if you have time available on some processor
13:53:57 <ksf> :t Nothing
13:53:58 <lambdabot> forall a. Maybe a
13:54:02 <ksf> :t Just
13:54:03 <JohnnyL> mauke holy shit! hahah lmfao.
13:54:03 <lambdabot> forall a. a -> Maybe a
13:54:24 <ksf> see, Just has just the right type to fit there. so we can say
13:54:33 <ksf> return = Just
13:54:34 <yamafaktory> Just a ok
13:54:38 <ksf> (or return x = Just x)
13:54:55 <JohnnyL> mauke gotta love that GMC air filter he is wearing. It be stylin'!
13:55:09 <ksf> now we have to think about what should happen if we tie up two Maybe values with >>=
13:55:09 <yamafaktory> ksf => like here : http://ertes.de/articles/monads.html#section-4
13:55:40 <JohnnyL> Cale perfect , thanks!
13:55:43 <ksf> yeah.
13:55:49 <ksf> well.
13:55:54 <ksf> I wanted to explain that.
13:56:23 <ksf> but first I wanted to get started on the monad laws, which are important.
13:56:39 <yamafaktory> ok, the three laws ?
13:56:45 <ksf> yes.
13:56:59 <ksf> we have the left identity: return a >>= f == f a
13:57:01 <ksf> let's try.
13:57:41 <ksf> Just 3 >>= f
13:57:44 <IceDane> If I found an ebook that uses hugs, and I have ghc, will I experience any compatibility issues between the two?
13:57:58 <ksf> inserting the second equation of >>= , we get f 3
13:58:06 <ksf> which matches with the law, so we're fine
13:58:28 <ksf> ...which also means that you could have derived the second equation from the first law.
13:58:43 <ksf> next the right identity.
13:58:53 <Vanadium> IceDane: If you do, we can probably help you out.
13:58:56 <ksf> m >>= return == m
13:59:08 <ksf> first, let's consider m == Nothing:
13:59:28 <ksf> Nothing >>= return == Nothing
13:59:34 <IceDane> Alright, cool =)
13:59:54 <ksf> that's written in the first equation, literally., by replacing f with return.
14:00:20 <JohnnyL> mauke: http://www.blackdynamitemovie.com/
14:00:32 <yamafaktory> ok
14:00:46 <ksf> Just x >>= return == Just x holds too, from the second equation, as f is return, and return is Just.
14:00:59 <ksf> so we've got the second law.
14:01:30 <ksf> the third one is more involved, associativity: (m >>= f) >>= g == m >> (\x -> f x >>= g)
14:01:40 <ksf> er s/>>/>>=/
14:02:19 <ksf> actually, I should be a good teacher and let you walk through it.
14:02:21 * aavogt wonders, is there some tendency towards 3 laws?
14:02:24 <kmc_> @src (>=>)
14:02:24 <lambdabot> Source not found. :(
14:02:39 <aavogt> ie. monads, thermodynamics, robots...
14:02:44 <yamafaktory> thanks for your help
14:02:47 <ksf> aavogt, yes, because theres two states attached: fullfilling them, and not.
14:02:59 <ksf> 2+3 is 5, which means that it's true.
14:03:32 <aavogt> ksf: that doesn't seem to address why 3 and not 5 laws?
14:03:43 <ksf> no, 5 is _the_ law.
14:03:46 <Vanadium> newton!
14:03:55 <Vanadium> robocop!
14:04:02 <ksf> >=> is good to understand associativity.
14:04:17 <Vanadium> I keep forgetting what >=> does.
14:04:20 <monochrom> 1 law.
14:04:26 <aavogt> it's . for monads
14:04:32 <ksf> the same law then becomes (f >=> g) >=> h == f >=> (g >=> h)
14:04:36 <Cale> <=< makes a better analogy
14:04:37 <ksf> :t (>=>)
14:04:38 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
14:04:39 <aavogt> (excuse my abuse of terminology)
14:04:42 <Vanadium> <_<
14:04:43 <Vanadium> >_>
14:04:46 <Cale> :t (<=<)
14:04:47 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
14:04:51 <Cale> :t (.)
14:04:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:04:59 <Cale> hehe
14:05:03 <kmc_> aavogt, it's not very abusive.  if (.) is a member of Category as it should be, then it *is* (.) for the Kleisli category
14:05:04 <yamafaktory> http://members.chello.nl/hjgtuyl/tourdemonad.html
14:05:04 <Cale> :t (Prelude..)
14:05:06 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
14:05:19 <kmc_> :t Prelude.(.)
14:05:20 <lambdabot> Not in scope: data constructor `Prelude'
14:06:00 <Cale> The parens have to go around the whole qualified name
14:06:27 <aavogt> so can we go over why most things have 3, rather than 1 law as monochrom wants?
14:07:06 <Cale> aavogt: Identity on the left, identity on the right, associativity.
14:07:17 <aavogt> in general ;)
14:07:19 <Cale> At least for all things which are categories in disguise.
14:07:33 <ksf> I thought the issue has been settled by reducing it to THE UNIVERSIAL LAW
14:08:21 <monochrom> my armchair theory: the maximum short-term memory capacity is 7, so the average is 3 if you take floor, so people aim at 3 to entice the "average person".
14:09:09 <aavogt> I agree that there is some freedom in splitting up laws
14:09:11 <FunctorSalad> I thought 7 was average
14:09:23 <FunctorSalad> average over ppl or average within a person?
14:09:33 <dancor> monochrom can't be expected to remember that
14:09:43 <aavogt> well, what's the number for vector spaces?
14:09:53 <Cale> Vector spaces have something like 7 or 8
14:10:00 <monochrom> 10
14:10:02 <dancor> see, you aren't sure
14:10:03 <aavogt> exactly, nobody remembers!
14:10:12 <Cale> It depends on how you write them down.
14:10:31 <dancor> write them down hypothallamically
14:10:34 <FunctorSalad> obviously you can write it as one conjunction
14:10:50 <FunctorSalad> you can also define groups with one axiom even without propositional connectives, but that's just obfuscation
14:10:59 <Cale> Let's count. You have operations +: V x V -> V and *: F x V -> V (not usually considered axioms on their own) such that:
14:11:11 <Cale> 1) + is associative
14:11:18 <Cale> 2) + has an identity
14:11:29 <monochrom> that is the problem. some people count them as "closure" axioms.
14:11:33 <Cale> 3) + is commutative
14:11:34 <dancor> i just became bored
14:11:38 <dancor> between 3 and 4..
14:11:46 <Cale> heh
14:11:47 <ksf> looks like a communtative monoid to me
14:12:02 <Cale> yeah, V is a commutative monoid under +
14:12:12 <Cale> actually, more:
14:12:12 <burp> @hoogle Codec.Binary.Base64
14:12:13 <lambdabot> No results found
14:12:18 <Cale> 4) + has inverses
14:12:23 <Cale> (commutative group)
14:12:31 <Cale> 5) * is associative
14:12:31 <monochrom> this is a way to use just one axiom: a vector space is a module over a field.
14:12:41 <ksf> now we're getting into fields.
14:13:01 <poe> ksf no, * is scalar product
14:13:09 <ksf> oh.
14:13:11 <dancor> the module is worse than the field
14:13:24 <Cale> 6) (1 *) is the identity map (for 1 in F)
14:13:49 <Cale> 7) (a+b)*v = a*v + b*v
14:14:00 <Cale> 8) a*(v+w) = a*v + a*w
14:14:27 <ksf> those look the same
14:14:32 <monochrom> module VectorSpace(x) where data D = { x :: D }  -- a module over a field
14:14:37 <Cale> They are very much not the same. Consider the types
14:14:41 <aavogt> 8) seems to be redundant when you have * being commutative
14:14:49 <Cale> But * can't be commutative
14:14:56 <FunctorSalad> it's heterogenous
14:15:04 <ksf> er well your syntax looks like value level
14:15:13 <Cale> Unless you're talking about a boring vector space which is just the field.
14:15:22 <poe> the first thing he said was +:VxV -> V and * : FxV->V
14:15:30 <FunctorSalad> you can also define a module as a ring homomorphism from teh ring into the endo group of an abelian group
14:15:42 <FunctorSalad> *into the endo monoid
14:15:52 <FunctorSalad> err or endo ring evenj
14:15:55 <poe> Cale which is not boring in case of field extensions, though (:
14:15:56 <Cale> Yeah, a vector space is an Abelian group with a field action on it.
14:16:10 <Cale> poe: Yeah, that's true.
14:16:30 <Cale> poe: But to some extent there's a stronger law not quite covered by those two then.
14:16:39 <ksf> wait there's a new pratchett?
14:16:50 <ksf> "unseen academicals"
14:16:57 <poe> yeah (but the V.S. structure per-se is important too)
14:17:02 <Cale> right
14:17:39 <Cale> poe: btw, I put up a new article or two regarding adjunctions right after we talked about them
14:17:46 <Cale> http://analogical-engine.com/wordpress/
14:17:58 <poe> Cale oh nice.
14:18:13 <poe> I've started reading Awodey
14:19:03 <Cale> cool, Awodey is really good :)
14:23:16 <ski> ooh, adjunctions :)
14:23:35 <EvanCarroll> is there something like `perldoc -f ` for haskell, to get a quick desc and syntax of the functions
14:23:38 <EvanCarroll> ?
14:23:55 <Vulpyne> There's :t in ghci. :)
14:24:18 <kmc_> every function has the same syntax
14:24:24 <mauke> heh
14:24:29 <Vulpyne> EvanCarroll: If you mean standard functions (and assuming you use ghc) there's documentation: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
14:24:31 <poe> ?docs
14:24:32 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
14:24:55 <tensorpudding> you can use hoogle and the haddock docs
14:28:46 <Cale> EvanCarroll: If you'd like to build documentation for your own libraries, haddock is pretty simple to learn to use.
14:29:48 <ksf> sometimes I really _don't_ get haskell.
14:30:03 <ksf> like, why stuff gets slower when I do a manual worker/wrapper conversion.
14:30:31 <Cale> Maybe you picked the wrong worker/wrapper?
14:30:41 <ksf> choose ((P b f):xs) p | p < f  = b
14:30:41 <ksf>                       | otherwise = choose xs p
14:30:43 <ksf> to
14:30:48 <EvanCarroll> Cale: thanks that was the next question
14:30:49 <ksf> --choose xs p = go xs where
14:30:50 <ksf> --    go ((P b f):xs) | p < f  = b
14:30:50 <ksf> --                    | otherwise = go xs
14:30:57 <EvanCarroll> Vulpyne: that's i guess "the answer" but I wanted a perldoc -f
14:31:03 <EvanCarroll> I sleep with my perldoc -f
14:31:11 <mauke> EvanCarroll: Haskell has no built-in functions
14:31:21 <mauke> well, except (:) maybe
14:31:25 <Cale> mauke: uh, it sort of does
14:31:25 <kmc_> that's a constructor
14:31:27 <ksf> that's 7.18 vs. 6.84
14:31:31 <kmc_> as are (,), (,,), etc
14:31:35 <mauke> yeah, ok
14:31:40 <copumpkin> I find it odd that it has a website, btw: http://www.workerwrapper.com/
14:31:41 <kmc_> [] is a nullary constructor
14:31:46 <Cale> mauke: Like, implementing putChar is pretty hard in terms of normal stuff.
14:31:51 <mtnviewmark> actually - those are constructors defined in teh Prelude, no?
14:31:57 <mauke> Cale: it's still in a library
14:32:03 <FunctorSalad> EvanCarroll: you needn't even bother to call haddock directly -- just mkcabal and then cabal haddock
14:32:12 <EvanCarroll> mauke: you need to level up your inferences.
14:32:15 <Cale> true, I guess it depends on what you mean by built-in
14:32:22 <kmc_> haskell *especially* doesn't ever need you to look up the "syntax" of a function call
14:32:26 <dancor> copumpkin: that's awesome!  the future of ideas in on the web
14:32:34 <mauke> Cale: perldoc -f is for functions built into perl, i.e. hardwired in the parser, and often with custom syntax
14:32:38 <ksf> I don't see how there could be another sensible worker.
14:32:49 <Cale> mtnviewmark: The special syntax for them means that you can't define anything else like that though.
14:33:01 <Guest6801> hey guys
14:33:02 <mtnviewmark> oh - are they special?
14:33:06 <Cale> ksf: no, you're right, that is strange
14:33:12 <mtnviewmark> I thought any operator that starts with a : has the same "specialness"
14:33:16 <Guest6801> do you know where I can read about 'data'?
14:33:19 <mtnviewmark> er' any constructor
14:33:28 <mauke> Guest6801: any haskell tutorial :-)
14:33:29 <kmc_> mtnviewmark, infix ctors all start with :
14:33:33 <kmc_> but that's an extension
14:33:33 <FunctorSalad> constructors starting with : are infix
14:33:35 <Cale> mtnviewmark: well, you can't call something (:) normally
14:33:36 <mauke> Guest6801: also, the language definition
14:33:41 <kmc_> the report says (:) is special
14:33:45 <kmc_> because it lacks this extension
14:33:47 <Cale> mtnviewmark: and (,) is right out :)
14:33:54 <mtnviewmark> heh
14:34:01 <tensorpudding> @src (:)
14:34:02 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
14:34:08 <kmc_> data (a,b) = (a,b)
14:34:18 <mauke> data [] a = [] | (:) a ([] a)  -- not actually valid syntax
14:34:20 <kmc_> i think that is actually in the GHC lib source somewhere
14:34:23 <mtnviewmark> and reall, if the Prelude is part of the language def -- there isn't a practical distinction
14:34:31 <kmc_> there is a huge distinction
14:34:35 <mtnviewmark> between what is and what ins't part of the "language"
14:34:39 <mauke> mtnviewmark: yes, there is
14:34:41 <kmc_> a built in function can have magic properties, e.g. syntax
14:34:47 <mauke> mtnviewmark: you can choose not to use the Prelude
14:34:49 <Cale> mtnviewmark: Yeah, but there's a part of the prelude which is more primitive, and a part which is less primitive
14:35:12 <mtnviewmark> hmmm.... okay -
14:35:32 <tromp_> @src Enum
14:35:32 <lambdabot> class  Enum a   where
14:35:32 <lambdabot>     succ                     :: a -> a
14:35:32 <lambdabot>     pred                     :: a -> a
14:35:32 <lambdabot>     toEnum                   :: Int -> a
14:35:32 <lambdabot>     fromEnum                 :: a -> Int
14:35:34 <lambdabot> [3 @more lines]
14:37:47 <monochrom> Some people even define the community to be part of the language.
14:37:47 * ksf wants mixfix syntax.
14:37:56 <ksf> but with better whitespace rules than agda.
14:37:59 <Guest6801> mauke: thanks!
14:38:00 <mauke> mixfix--
14:38:05 <mauke> circumfix++
14:38:06 <ksf> and knowledge about what types are.
14:38:17 <ksf> well yes exactly.
14:38:32 <ksf> s/types/parens
14:38:50 <nolrai_FG> Is there a way to have ghc put its binarys in a differnt folder then it looks for files in?
14:38:58 * ksf doesn't even want to try to understand how that typo came about.
14:39:13 <Vulpyne> It's okay, the types key is right next to the parens key.
14:39:22 <ksf> nolrai_FG, do you mean the binaries or the wrapper script?
14:39:26 <mauke> data () = (()) () (())
14:39:28 <sg> hi
14:39:42 <ksf> anyway, yes, you can customize pretty much anything by editing the wrapper scripts.
14:39:56 <nolrai_FG> ksf: What wraper script?
14:39:58 <Guest6801> I'm defining stuff from a picture
14:40:04 <ksf> /usr/bin/ghc and stuff
14:40:20 <Guest6801> in this case, directions
14:40:23 <ksf> mine says exec /usr/lib64/ghc-6.10.4/ghc -B/usr/lib64/ghc-6.10.4/. -dynload wrapped ${1+"$@"}
14:40:40 <Guest6801> liek data Direction = North | South | East | West | Center
14:40:43 <nolrai_FG> which means?
14:41:04 <mauke> nolrai_FG: that the ghc binaries are in /usr/lib64/ghc-6.10.4/
14:41:14 <lament> > open mailbox
14:41:15 <lambdabot>   Not in scope: `open'Not in scope: `mailbox'
14:41:25 <ksf> I'm not sure at all what ${1+"$@"} means.
14:41:40 <mauke> same as "$@", basically
14:41:41 <nolrai_FG> Oh, sorry I spoke confusingly, by its binarys I ment my binarys, the ones ghc makes.
14:41:59 <mauke> nolrai_FG: look for -o and friends
14:42:02 <ksf> oh, yes, there is.
14:42:10 <nolrai_FG> thanks!
14:42:12 <ksf> that, and cabal does it.
14:42:25 <ksf> which is probably what you want to use if you're worried about it.
14:42:38 <mauke> I think there's a -ohi option (-ohai?)
14:42:46 <monochrom> o hi!
14:43:41 <Twey> ghc -ohi mu_xagji_sofybakni
14:44:03 <eivuokko> You likely want to use -outputdir instead of that
14:44:39 <nolrai_FG> cool -outputdir looks like what I was looking for!
14:49:54 <Toteter> online boxing game http://www.kobox.org/kobox-fande-Nourine.html sorry im just testing my page. enter if you want
14:50:34 <monochrom> haha what a lame excuse
14:50:50 <ksf> @src replicateM
14:50:51 <lambdabot> replicateM n x = sequence (replicate n x)
14:51:10 <donri> Twey, y ba'e mo u'i
14:51:52 * hackagebot upload: hpage 0.4.4 - A scrapbook for Haskell developers (FernandoBenavides)
14:52:22 <Taejo_> dcoutts: thanks for the push. http://hackage.haskell.org/trac/hackage/ticket/330 is on my TODO list (not going to assign myself the bug until it gets closer to the top, though)
14:53:18 <dcoutts> Taejo_: as I mentioned, the main thing is to think of (and discuss with others) a consistent design
14:53:37 <dcoutts> what the .cabal file syntax should be and what it should mean / how it should behave
14:54:25 <Taejo_> dcoutts: sure, I'll be thinking about it, and when I have some ideas I'll post them
14:54:39 <dcoutts> Taejo_: things to think about: can we use conventions to reduce the amount that has to be explicitly listed in the .cabal file
14:54:59 <dcoutts> eg for source files we work out what to do mostly automatically based on file extensions
14:55:33 <dcoutts> then there's the cross-platform issue, on unix people want man pages, on windows they still want that info, but in a different format
14:56:14 <Taejo_> good point
14:57:49 <IceDane> Why is it that the modulus operator isn't defined as % as in so many other languages?
14:59:24 <tensorpudding> is there really that many languages that use % for modulus?
14:59:32 <Kim^Walkman> PHP
14:59:48 <IceDane> I think so, yes
14:59:49 <tensorpudding> i know that C does, I thought maybe Perl did too
14:59:59 <Kim^Walkman> python I believe
15:00:09 <IceDane> C++, C, C# as far as I know
15:00:22 <IceDane> I don't know, I just somehow consider it the default operator for modulus in programming languages
15:00:25 <lament> Python, Java
15:00:26 <tensorpudding> mod is more mathy
15:00:31 <IceDane> tensorpudding: hehe, yeah
15:01:11 <monochrom> % is very poor choice for mod. far from remotely suggestive of mod.
15:01:17 <Taejo> also, all of those languages to a certain extent are either part of the "C-like" tradition or the "Unix" tradition, both of which are centered on C
15:01:18 <IceDane> I know that haskell is especially lenient on what characters are used for functions and so on, so I just tried defining it and it worked
15:01:56 <monochrom> Data.Ratio uses % for fractions. I still think it is a poor choice.
15:02:09 <monochrom> > 1%2 + 1%2
15:02:10 <lambdabot>   1 % 1
15:02:20 <IceDane> monochrom: Yes, I understand as much, but I don't see why it isn't there along with mod, so people can choose whatever they want. It's not a huge  thing, I guess, but I don't know
15:02:24 <IceDane> oh, there it was
15:02:24 <IceDane> so it's used
15:02:50 <monochrom> But I think yet poorer is blindly following conventions set by "most languages" especially when the conventions are arbitrary.
15:03:01 <ksf> @src sequence
15:03:01 <lambdabot> sequence []     = return []
15:03:01 <Taejo> IceDane: in general I think having two names for the same thing is not a good idea
15:03:01 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
15:03:01 <lambdabot> --OR
15:03:01 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
15:03:50 <IceDane> Taejo: I just thought it wasn't used. I wasn't sure if it was in another module
15:04:33 <Taejo> what I'm saying is just because something isn't used, doesn't mean you should use it as a synonym for something else
15:04:53 <Taejo> the costs of global synonyms usually outweigh the benifits, IMO
15:04:57 <Cale> Taejo: Finally someone with the same idea about naming as I have
15:05:30 <IceDane> Perhaps not. I was merely wondering about the reason. I got it; it's used somewhere else where it is perhaps more logical
15:05:37 <Cale> I think that just because we have modules doesn't mean we should go trying to cause naming conflicts
15:06:40 <tensorpudding> it's nice having different implementations of a function though
15:06:57 <chrisdone> `mod` is awesome
15:07:56 * hackagebot upload: wxcore 0.12.1.2 - wxHaskell core (JeremyODonoghue)
15:07:57 <Taejo> Cale: one thing I think Python got right is the philosophy that one (right) way to do it is better TIMTOWDI
15:08:50 <chrisdone> "TIMTOWDI"?? jesus. give it a couple years we'll have whole paragraphs shortened. (GIACYAWHWPSIMHOBTW)
15:08:56 * hackagebot upload: wx 0.12.1.2 - wxHaskell (JeremyODonoghue)
15:09:08 <mauke> NYJMUA
15:09:12 <Vanadium> chrisdone: "there is more than one way to do it"
15:09:17 <Taejo> chrisdone: obviously not a perl hacker
15:09:19 <Vanadium> pretty much as old as perl
15:09:22 <WheelJack> Hello, everybudy
15:09:23 <mauke> missing T
15:09:34 <Taejo> oh, yeah, sorry
15:09:35 <WheelJack> someone here speak spanish
15:09:37 <WheelJack> ?
15:09:52 <Taejo> I think there's #haskell.es, isn't there?
15:09:52 <chrisdone> sorry, Perl makes me sick and I avoid it as such =)
15:09:58 <Vanadium> 'Recently this motto has been very much discussed in the Perl community, and eventually extended to There's more than one way to do it, but sometimes consistency is not a bad thing either (TIMTOWTDIBSCINABTE, pronounced "Tim Toady Bicarbonate")'
15:10:08 <mauke> don't make me link to my polyglot
15:10:09 <WheelJack> I would like to know a book about haskell for dummies
15:10:16 <IceDane> hahaha..
15:10:21 <WheelJack> jeah
15:10:24 <WheelJack> yeah
15:10:28 <WheelJack> it funny
15:10:38 <WheelJack> sorry for my english
15:10:40 <Vanadium> WheelJack: Try http://learnyouahaskell.com/
15:10:43 <WheelJack> is not so good
15:10:44 <chrisdone> WheelJack: seems like an oxymoron
15:10:52 <chrisdone> oh, n/m
15:10:56 <Taejo> I think the text of "haskell for dummies" would be shorter than the title: "Rather don't"
15:11:36 <chrisdone> Recondite Studies For Dummies
15:11:55 <WheelJack> thanks for the help
15:12:07 <WheelJack> I need learn haskell really fast
15:12:15 <Taejo> WheelJack: exam time?
15:12:26 <chrisdone> in that regard I think your hopes are too high
15:12:54 <WheelJack> yeah?
15:12:58 <monochrom> If you are a clean slate, you can learn haskell really fast.
15:13:24 <WheelJack> if you say
15:13:39 <Taejo> WheelJack: do you know another programming language?
15:13:40 <chrisdone> monochrom: conjecture! pure conjecture!!1
15:13:40 <kmeyer> it's hard for anyone to truly be a clean slate
15:13:59 <WheelJack> swi prolog
15:14:03 <monochrom> OTOH if you "dive in" and have an agenda like "I want to learn haskell and write a web app really fast", your dive-in strategy will confound yourself.
15:14:05 <WheelJack> pic simulator ide
15:14:10 <WheelJack> mplab
15:14:15 <WheelJack> c ansi
15:14:23 <WheelJack> matlab
15:14:33 <monochrom> chrisdone: I think Cale has preliminary evidence.
15:14:37 <WheelJack> i guess
15:14:38 <WheelJack> more
15:14:45 <Taejo> if you handled prolog, you might cope with Haskell
15:14:47 <WheelJack> basic
15:14:53 <WheelJack> really
15:14:54 <tensorpudding> prolog is fun
15:14:55 <monochrom> He even has preliminary evidence for clean slate and calculus, analysis...
15:14:58 <eivuokko> Hang tight on things you learnt from prolog.
15:15:09 <WheelJack> ok
15:15:11 <Taejo> WheelJack: you're best off forgetting basic, C and most of matlab
15:15:51 <chrisdone> monochrom: define "clean", please
15:16:03 <derrida> Could anyone reccomend a web framework they think would be fun for someone that is still learning haskell? I've been looking at Happstack
15:16:06 <dancor> what do ppl think about the "compilation should be fast" idea of Go/Issue9
15:16:08 <nolrai_FG> Okay when darcs asks for a password, its just asking for the same password you would give to scp right?
15:16:41 * ksf thinks the only haskell beginners that are able to consider happstack fun are category theorists
15:16:48 <derrida> :)
15:16:49 <WheelJack> really
15:17:00 <WheelJack> I need forget that to laern haskell
15:17:02 <WheelJack> why?
15:17:11 <Cale> chrisdone: I taught monads for programming to 11 year old kids :)
15:17:24 <Cale> chrisdone: Mind you, they were smart 11 year old kids.
15:17:26 <Taejo> ksf: well the only category theorist I know would say, it is not by Mac Lane, it is not good.
15:17:34 <derrida> ksf: i don't want to be a category theorist though ..
15:17:35 <nolrai_FG> WheelJack: too imperative/state based.
15:17:38 <Twey> WheelJack: Because it does things in confusing ways that clutter your thinking and make it harder for you to grasp other ways of doing them.
15:17:38 <derrida> ksf: :)
15:18:12 <chrisdone> Cale: how did you do that?
15:18:19 <copumpkin> jacques?
15:18:20 <ksf> there are some new web frameworks, but since they came out _after_ I learned how to deal with happstack-like libraries the only thing that comes to mind is wash
15:18:30 <Twey> dibblego taught an eight-year-old, IIRC
15:18:38 <ksf> ...apart from the low-level ones for fastcgi and such.
15:19:07 <WheelJack> mmmm
15:19:19 <WheelJack> ok
15:19:19 <ksf> in general, http://hackage.haskell.org/packages/archive/pkg-list.html#cat:web
15:19:22 <monochrom> @quote unlearning
15:19:23 <lambdabot> monochrom says: Learning is unlearning. Intuition is experience. Understanding is feeling.
15:19:32 <ksf> lots of small pieces there that hide the trees, though.
15:19:33 <Cale> chrisdone: When I was working at McMaster on the pipeline scheduler for PPC/Altivec, there was a group of young kids in an experimental teaching project who often came to the same lab, and they were doing Haskell Road.
15:19:34 <monochrom> ha ha ha ...
15:19:35 <lament> Freedom is slavery. War is peace.
15:19:41 <ksf> hsp is another older one
15:19:44 <mauke> Ketchup is a vegetable.
15:19:55 <chrisdone> Twey: call me cynical but people tend to exaggerate claims of teaching people things
15:20:05 <Cale> chrisdone: and I gave them some explanation about various things from time to time, and they tended to pick things up rather quickly.
15:20:09 <dancor> culinarily it's vegtabular..
15:20:14 <Twey> chrisdone: *shrug* I wouldn't be surprised
15:20:19 <jaj> 2+2=5
15:20:22 <Twey> It's not really a hard concept
15:20:28 <mauke> > let 2+2=5 in 2+2
15:20:30 <lambdabot>   5
15:20:30 <samnardoni> i have   data Set = Set Selector [Attribute] [Set] ... is there a way to somehow have .... data CSS = Whatever | Set ?
15:20:33 <Cale> chrisdone: At least, I've seen imperative programmers struggle a heck of a lot more than these kids did.
15:20:56 <mauke> samnardoni: no, you need data constructors
15:20:57 <Twey> I think that anybody who can grasp addition can grasp monads
15:20:57 <dancor> > let 2+2=5 in 2+2+2
15:20:59 <lambdabot>   * Exception: <interactive>:1:157-161: Non-exhaustive patterns in function +
15:21:05 <dancor> > let 2+2=5 in 2+2+1
15:21:07 <lambdabot>   * Exception: <interactive>:1:161-165: Non-exhaustive patterns in function +
15:21:11 <dancor> uh huh..
15:21:21 <chrisdone> Cale: nice. I hadn't heard of that HR series
15:21:22 <samnardoni> mauke, which would be the best way around this?
15:21:24 <Twey> dancor: 2+2+1 = 5+1 = ?!?!
15:21:46 <dancor> Twey: i'm trying to figure out how this works
15:21:51 <Twey> > let 2 + 2 = 5; 5 + 1 = 3 in 2 + 2 + 1
15:21:52 <lambdabot>   3
15:22:02 <Twey> dancor: You're redefining (+)
15:22:05 <kmeyer> heh
15:22:11 <Twey> So the patterns you provide for it are all there are
15:22:14 <dancor> ok
15:22:17 <derrida> ksf:  interesting, i'm just reading over this stuff.
15:22:30 <ksf> derrida, if everything else fails, just try to use a dozen of them, see how far you come with each of them and how much you like them. in case you fail to get stuff done, you succeed in learning a lot.
15:22:33 <chrisdone> Twey: import NineteenEightyFour
15:22:38 <samnardoni> basically i want:    data Something = Something | Else | Set String [Set]
15:22:41 <derrida> ksf: what do you think about using fastcgi?
15:22:52 <chrisdone> Cale: what did the kids do with their monad knowledge?
15:22:57 <derrida> ksf: story of my life :)
15:23:51 <ksf> If you know how to set up apache, I think it's the fastest way to get started.
15:24:06 <derrida> chrisdone: solve world hunger?
15:24:17 <derrida> ksf: i have nginx and apache running
15:24:27 <Cale> chrisdone: Well, I wasn't always watching them, but they had no trouble with doing stuff using IO and the list and Maybe monads. I'm not sure any of them defined their own monads or anything.
15:24:32 <dancor> if i want to do interactive/auto-gen audio stuff, am i better off starting with csound bindings or supercollider bindings?
15:24:38 <derrida> i have a LAMP stack running, wsgi, fcgi, etc. so it's easy for me to test stuff out
15:24:48 <ksf> otoh, you could download gitit, run it and learn from its source.
15:24:57 <derrida> i was looking at that
15:25:03 <ksf> it's a wiki based on happstack, using gits or darcs as backend.
15:25:04 <derrida> it looked pretty cool
15:25:05 <Taejo> Cale: so they couldn't teach me about the Kleisli category of a monad for my exam on monday? :(
15:25:16 <Cale> Taejo: hehe
15:28:34 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
15:28:34 --- topic: set by mauke on [Mon Nov 02 11:41:43 2009]
15:28:34 --- names: list (clog aug_triad wpm83 Trafalgard cying samnardoni amiri lurkymclurklet-1 peaker_ derrida Smokey` dpratt71 jsgf WheelJack viator_sg amz ben_m Pthing tibbe jan____ Keiya noteventime iago tensorpudding hansfbaier Philonous Raynes sprang segoe shambler ClaudiusMaximus nolrai_FG anRch dolio pao Guest6801 arsenm trie sohum Philippa bohanlon Beelsebob whoppix bos noisetonepause Taejo gerritw mattrepl vili1 pythonista Gracenotes novas0x2a mrsolo_)
15:28:34 --- names: list (nlogax tommd paulvisschers Mowah FunctorSalad sigh bgs100 gnuvince thotypous monochrom XGas red-agent njbartlett Asztal BurgessShale booxter oubiwann proq Bassetts tov JohnnyL trin_cz adept watermind jimfear diltsman_ gr00vy trofi monoidal mrbluesky floodleboodle shellsage lpeterse Mortomes fihi09 flippo Stefa1 dancor Cthulhon _andre ChthonLaptop jmelesky saint_cypher cygnus Wild_Cat gbeshers Tomas_ mlesniak rey_ Eduard_Munteanu jtra sioraiocht)
15:28:34 --- names: list (QplQyer BCoppens kynky newsham dschoepe fracture ddarius eivuokko Aikawa_ aiko nathanic_work jbauman nominolo_ sm phyrex1an ski_ skeeterbug gbacon int-e shintah anders^^ levitation[A] macron shapr baaba meridion IceDane voker57 boogyman Apocalisp THC4k hgolden gogonkt_ epmf_ rickasaurus sudharsh triplez clanehin jmcarthur jelly12gen gbeshers_home mak__ miccm Guest75642 zakwilson SamB_XP Ornedan mxc Kambus ksf ttmrichter zhijie nvoorhies)
15:28:34 --- names: list (TML flibbertigibbet RayNbow O_4 zong_sharo deavid DekuNut hrehf blackh linkinus carlocci Cale revertTS hd_ twanvl Associat0r thoughtpolice hackagebot augur smg Neronus jix dmwit zachk dejones m-i-l-a-n Colours otto_s burp malie qz kmc Pewpewarrows necrobious Vanadium copumpkin spoop ve StoneToad_ pixel5 pifish Axman6 jaj mm_freak Cobra| TR2N lispy hazridi alexbobp peddie lisptastic nathanic PsiOmega loupgaroublond karihre Whitesquall tessier)
15:28:34 --- names: list (smorg clarkb jamwt Draconx crem_ mulletron soduko iaefai cognominal hiredman allbery_b trez jimmyjazz14 eno Optimo jkramer eldragon ahf eelco Saizan_ jontore earthy ToRA dankna eek thingwath MyCatVerbs leadnose zax mreggen glith AnMaster eagletmt rasfar kadoban_ ath nwf onodrim Nereid caligula__ ksandstr rdd noZone gwern mmorrow Taggnostr amuck leoncamel Alpounet nipuL sjanssen jml duairc xinming wisemanby reltuk fnord123 +lunabot saccade)
15:28:34 --- names: list (erk guerby alexsuraci majoh Elly wang cods wimt Sisu dreixel SmurfOR __marius__ teneighty tromp_ dcoutts_ davidL PHO_ koninkje_away inimino nablaa orbitz idnar endojelly desp bockmabe_ beibmozoi hesselink_ bd_ sebas__ Laney tew88 _Jordan_ geoaxis_ dilinger_ mauke tilman mml`_ rapacity theclaw mux mokus_ LeoD jnwhiteh equanimity erg SeaPrior _br_ bran BrianHV fryguy nimred boyscared franksh heaumer mattam dumael sproingie stroan r0bby thomastc)
15:28:34 --- names: list (mshaw glitch qm13_ sgf_ lavish ned mrd willb ski drbean Vulpyne electrogeek +preflex Paradox924X luite Nafai hellige mercury^ mle olsner shortcircuit shachaf BONUS djinni jahgru wormwood jrockway integral eyck_ shepheb Milo- snorble fxr cdfh_ emma Heffalump jones- tkr inhortte kolmodin snhmib Jedai pikhq sereven taruti jlouis aempirei kanalj karld MacCoaster dons byorgey Jiten kalven Exteris igorgue jlaire raim0 kuningas Bleadof arkx Raevel)
15:28:34 --- names: list (ibid jvoorhis wornof BONUS_ samulihs M| And[y] canvon neurocyte felipe_ drspider Badger DrSyzygy deiga tamiko geir_ Nanar danderson Aisling emias edwtjo fnordus kmeyer pcc1 poucet wharrgarble jvogel_ wdonnelly harlekin lanaer ac sbok sieni Khisanth phr ido FauxFaux disgrntld dek5 Poeir hsaliak_ sunnavy dcoutts nasloc__ Lycurgus ystael jfhall kmc_ andun t dibblego PeakerWork lilac Liskni_si McManiaC ^Einstein kw317 jayne blackdog rgr opqdonut)
15:28:34 --- names: list (saiam anji_ mapreduce joed Eelis ahihi greap nothingmuch Stephan202 mmmulani kosmikus agemo wolverian rdrake etpace aleator prigaux SimonRC koeien pettter Annie|Home mornfall impl skaar _plcs_ GNU\colossus sebbe1991 blalb stoop ggreg_ da-x andrewsw-afk pantsd_pcf Lemmih mjv da-xw tavelram donri stepnem wagle_home alexander2 gdsx Megant magicman sior|oifig thorkilnaur mahogny Tobsan webframp Paks dino- Jaak mikm suiside kakeman Esmil dogmaT)
15:28:34 --- names: list (jfredett srcerer jystic EvanCarroll int_e jre2 Counter-Strike LeCamarade tumult joga netcat xian jfoutz cathper SubStack dcolish droidcore nornagon mlh kar-1 desu EvanRWork tmug qed koala_man quicksilver qebab Deewiant pragma_ malouin mmmdonuts Boney Nereid_ therp anekos Raku^ jql Innominate authentic dionoea companion_square ertai_ yahooooo angelixd avysk ath^ flux det ville doublethink_work jims sunfun jonafan stalker thedward poe @ChanServ)
15:28:34 --- names: list (Baughn zygoloid nominolo|uni birkenfeld Valodim Warrigal Ferdirand marmolak tarbo_ laz0r dqd maskd absentia zaarg icee Twigathy scree ps-auxw thetallguy1 Gilly cjay dixie Blaketh lefant Veinor p_l aavogt cygnus_ jasonmay mikste danopia` sevvie guerrilla osfameron ehamberg flori profmakx lsthemes arjanoosting Maddas JaffaCake mw493 liff ray nnunley epokal gOcOOl mjrosenb dfeuer Zao midnite bolrod Elench chrisdone noddy regulate araujo mfp)
15:28:34 --- names: list (OnionKnight tuukkah mfoemmel mdordal2 tltstc arcatan qwr helge Vq welterde lament Gabbie drhodes Botje ziman AndyP loop Blub\0 bind_return alpheccar alip thetallguy periodic brx daed +lambdabot noj)
15:28:38 <dcoutts> derrida: indeed the default is to use per-user installation
15:28:57 <derrida> dcoutts: i see
15:29:02 <WheelJack> of Introduction to functional programming using haskell by Bird R j
15:29:36 <derrida> dcoutts: it makes more sense to use cabal directly? pkg manager is just an added layer it seems like?
15:30:01 <WheelJack> I can put my mail here
15:30:09 <WheelJack> maybe someone
15:30:13 <WheelJack> could help me
15:30:31 <Taejo> if I spoke to a category theorist about the powerset monad, would he understand something analogous to our list monad?
15:30:38 <copumpkin> WheelJack: realworldhaskell.com
15:30:44 <copumpkin> @where lyah
15:30:45 <lambdabot> www.learnyouahaskell.com
15:30:47 <copumpkin> @where rwh
15:30:47 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:31:06 <Taejo> for fast learning, lyah is probably better
15:31:07 <mauke> copumpkin: that's not "Introduction to functional programming using Haskell" by Bird
15:31:12 <Taejo> rwh is more in depth
15:31:12 <copumpkin> I know :P
15:31:15 <dcoutts> derrida: it's fine to use your system package manager for the stable core packages
15:31:25 <ksf> category theorists understand everything up to isomoprmism.
15:31:55 <copumpkin> mauke: he said he wanted to pick up haskell quickly so I figured a legally available tutorial/book might be quicker than sitting around waiting for someone to email him a pdf of a book
15:32:04 <ksf> that's why they can't tell their cup of coffee from their donut as soon as they heard about topology.
15:32:06 <Taejo> ksf: you mean category theorists are isomorphic to computer scientists, and thus will understand everything I say, up to isomorphism?
15:32:46 <WheelJack> yea
15:32:50 <WheelJack> that is the name
15:32:56 <WheelJack> mauke>	copumpkin: that's not "Introduction to functional programming using Haskell" by Bird
15:33:23 * copumpkin shrugs
15:34:44 <ben_m> Learning Parsec is like learning another entirely new language :/
15:34:57 <Vanadium> It is not :<
15:35:05 <Vanadium> It is just monads! And/or applicatives!
15:35:35 <derrida> ksf: lmao
15:36:45 <ksf> Taejo, you should probably describe the isomorphism between the internet and a series of tubes.
15:37:04 <ksf> there's got to be some local similarity there that you could exploit.
15:37:35 <Taejo> ksf: unfortunately the level is a bit above merely knowing what an isomorphism is and some examples
15:39:01 <ksf> well, it's an arbitrary graph on the one side, and some pipes held together by duct tape on the other side. I can't imagine the connection to be trivial.
15:39:15 <Taejo> :)
15:39:28 <Taejo> lambdabot: ksf++
15:39:29 <ksf> especially abstracting over the fact that packets could take multiple paths.
15:39:39 <mauke> preflex: karma ksf
15:39:39 <preflex>  ksf: 2
15:39:53 <ksf> that's a serious sign of deep understanding of abstractions.
15:40:02 <ksf> that senator should get a nobel prize.
15:40:36 <Taejo> ksf: you should get a prize for making me smile when I'm being slowly crushed between my project deadline and my category theory exam
15:40:44 <monochrom> No, you don't get a nobel prize for just deep understanding of abstractions. You have to invent things.
15:41:23 <Taejo> monochrom: "invention *or discovery* that made the greatest contribution (in the field) to mankind during the preceding year"
15:41:28 <Taejo> I believe
15:43:01 <Taejo> ah, it's more complex: in physics, it's for "the most important discovery or invention within the field"; in chem it's for "the most important chemical discovery or improvement"
15:43:16 <Taejo> in physiology and medicine, it's only for discovery
15:43:30 <ksf> http://plumbercon.org/
15:43:37 <ksf> you could give a talk there.
15:43:47 <ksf> oh it's already past.
15:44:09 <monochrom> "information warriors"??!!
15:44:36 <WheelJack> thanks for all
15:45:04 <dpratt71> preflex: seen kmc
15:45:05 <preflex>  kmc was last seen on #haskell 14 hours, 36 minutes and 32 seconds ago, saying: ah, right
15:45:18 <ksf> well, it's not an academic con.
15:45:33 --- mode: ChanServ set +o mauke
15:45:33 --- mode: mauke set +v hackagebot
15:45:55 <ksf> guys from the ccc and similar are doing these things.
15:46:33 --- mode: mauke set -o mauke
15:47:24 <monochrom> No conference whatsoever should coin the term "information warrior". I mean, what's next, a whole information RPG game? information clergy? information dragon? information lord brittania?
15:47:39 <mauke> "math angel"
15:47:49 <tensorpudding> information pope
15:47:50 <ben_m> SocialStudiesWizard
15:47:50 <Taejo> monochrom: I wanna play!
15:47:52 <Vulpyne> I'm an information paladin.
15:47:59 * Taejo InformationPope
15:48:19 <ksf> heck they chose that name because the toilet of some hackerspace broke and the guys there then indulged in hacking their new one...
15:48:23 <tensorpudding> information messiah
15:48:40 <mauke> ben_m++  # doing it right
15:49:14 <Vanadium> Lawful neutral haskell wizards waging eternal war against the chaotic evil perl monks~
15:49:29 <InformationPope> as InformationPope, I declare that the Information Messiah has come and gone, only to return in 2012 to take the righteous along the Information Highway to the bitbucket
15:49:35 <ksf> lawful neutral?
15:49:46 <ksf> more like chaotic neutral.
15:49:54 <ksf> pascal is lawful evil.
15:49:58 <Vanadium> Static typing is clearly lawful
15:49:59 <ben_m> Maybe I'm just too tired today, but I just fail at reading the Parsec documentation
15:50:02 <monochrom> We are lawful because our monads have laws.
15:50:09 <ben_m> See, even my sentence structure fails.
15:50:27 <Vanadium> Maybe we ought to be good, too, because of the whole purity thing we have going
15:50:32 <ksf> but our type system is expressive enough to be unlawful in lawfulness. therefore, chaotic.
15:50:43 <mauke> Vanadium: what if I use both Perl and Haskell?
15:50:47 <Vulpyne> It's turing complete!
15:50:49 <ben_m> How would I parse a polynomial? (e.g. "2 * (3 + 4)")
15:50:55 <mauke> (sometimes in the same program?)
15:51:10 <Vanadium> mauke: Then you are prohibited from gaining any more monk levels, and probably lose all your paladin spells and abilities if any
15:51:18 <JohnnyL> @hoogle comparing
15:51:18 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
15:51:19 <ksf> parsec even comes with an expression parser and an example in its tutorial.
15:51:27 <Vulpyne> ben_m: http://hoc.sourceforge.net/examples.html - Does that help you?
15:51:32 <dcolish> tensorpudding: yeah haskell-emacs-mode blows the vim haskell-mode out of the water
15:51:37 <ksf> if that fails, try the uu-parsinglib one, it describes their operator mode in excessive detail.
15:51:41 <samnardoni> is there a way to have .. "hello %x", name .. style without using printf?
15:51:45 <ben_m> Vulpyne: I think it does, thanks!
15:51:54 <ksf> samnardoni, yes, and no.
15:52:04 <mauke> samnardoni: why "without using printf"?
15:52:09 <tensorpudding> dcolish: i've never used the vim haskell mode, but i've always been very fond of emacs haskell mode
15:52:16 <samnardoni> because i don't want to print the text...
15:52:18 <ksf> yes because such a beast is possible to type in haskell, and no because you can't use strings to do it.
15:52:25 <Vanadium> samnardoni: printf can be used to create strings
15:52:26 <ksf> well at least without resorting to template haskell.
15:52:43 <tensorpudding> you can use M-x run-haskell to open an inferior ghci in emacs
15:52:44 <mauke> samnardoni: so use printf
15:52:48 <InformationPope> ksf: why can you do printf and not sprintf
15:52:50 <Vanadium> > printf "hello %x" 1337 :: String
15:52:51 <lambdabot>   "hello 539"
15:52:53 <ksf> samnardoni, google for "fun with type functions", that paper gives it as an example
15:52:56 <dcolish> theres a HStringtemplate
15:53:01 <dcolish> its pretty nice
15:53:09 <tensorpudding> if you like having your interpreter running inside your editor
15:53:12 <ksf> Taejo, you can and can't do both.
15:53:20 <samnardoni> mauke, even if i don't want to print the value?
15:53:24 <mauke> samnardoni: yes
15:53:34 <ksf> you can't take a format string as you can't influence your function's type with it.
15:53:37 <dcolish> tensorpudding: yeah C-c C-z also does that, and C-c C-l loads the current *.hs
15:53:48 <tensorpudding> ah
15:53:50 <Taejo> ksf: explain what Vanadium did, then
15:54:09 <ksf> but you can take e.g. an gadt that describes the format
15:54:11 <ksf> :t printf
15:54:12 <lambdabot> forall r. (PrintfType r) => String -> r
15:54:15 <tensorpudding> in emacs, M-x allows you to run any defined function emacs knows, but sometimes these functions have direct keybindings
15:54:26 <ksf> > printf "%s" 43
15:54:26 <samnardoni> well, i'm not even too bothered about the types... i just don't like a ++ ": " ++ b + ";"
15:54:27 <lambdabot>   Ambiguous type variable `a' in the constraints:
15:54:27 <lambdabot>    `Text.Printf.PrintfType ...
15:54:32 <tensorpudding> i rarely remember keybindings to functions i don't use often though
15:54:32 <ksf> > printf "%s" 43 :: String
15:54:33 <lambdabot>   "* Exception: Printf.printf: bad argument
15:54:36 <JohnnyL> @src break
15:54:36 <lambdabot> break p =  span (not . p)
15:54:42 <dcolish> tensorpudding: ah, i'll have to read up more on emacs... i went through the tutorial
15:54:46 <ksf> Taejo, break totality, that's what he did.
15:54:53 <monochrom> ben_m: I have example too in http://www.haskell.org/haskellwiki/Parsing_expressions_and_statements
15:54:54 <ksf> > printf "%s" 43  3 :: String
15:54:55 <lambdabot>   "* Exception: Printf.printf: bad argument
15:54:55 <JohnnyL> @src span
15:54:56 <lambdabot> Source not found. Are you on drugs?
15:54:59 <tensorpudding> C-h f describes a function by name
15:54:59 <ksf> > printf "%s" :: String
15:55:00 <lambdabot>   "* Exception: Printf.printf: argument list ended prematurely
15:55:07 <Taejo> ksf: that's part of the specification of printf, same as in C :)
15:55:17 <ksf> well yes but haskell can do better.
15:55:21 <ben_m> monochrom: Great :)
15:55:22 <dcolish> tensorpudding: cool thanks for the hints
15:55:23 <tensorpudding> C-h k describes what function a key combination is  bound to
15:55:52 <dcolish> i need to start messing with my .emacs too
15:55:53 <samnardoni> basically, is there a better way of writing:  a ++ ": " ++ b + ";"
15:55:57 <tensorpudding> yeah
15:56:04 <mauke> printf "%s: %s;" a b
15:56:08 <tensorpudding> i have a decent .emacs
15:56:14 <ksf> that's not typesafe.
15:56:20 <mauke> ksf: I don't care
15:56:25 <mauke> this is about convenience
15:56:38 <Vanadium> Hey, *I* did not break totality :<
15:56:47 <Vulpyne> samnardoni: You could also do concatMap [a,": ",b,";"]
15:56:55 <Vulpyne> Er, concat.
15:56:55 <samnardoni> ahh
15:56:56 <tensorpudding> i really like ido mode
15:57:07 <Vulpyne> Not concatMap.
15:57:16 <ksf> concat == concatMap id
15:57:19 <samnardoni> that looks nicer anyway :)
15:57:27 <ksf> wait
15:57:31 <ksf> :t concatMap
15:57:32 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
15:57:51 <Taejo> > concat ["my", "name", "is", "taejo"]
15:57:52 <lambdabot>   "mynameistaejo"
15:58:02 <mauke> [ x | y <- [a, ": ", b, ";"], x <- y ]
15:58:11 <Vulpyne> samnardoni: If you want to compose a bunch of things with a separator, you can also do: intercalate ", " ["hello","there"]
15:58:11 <ksf> > concatMap pure ["ab", "cd"]
15:58:12 <lambdabot>   ["ab","cd"]
15:58:17 <ksf> > concatMap join ["ab", "cd"]
15:58:18 <lambdabot>   Couldn't match expected type `[b]'
15:58:18 <lambdabot>         against inferred type `GHC.Types...
15:58:22 <ksf> no that's nonsense
15:58:25 <ksf> > concatMap id ["ab", "cd"]
15:58:26 <lambdabot>   "abcd"
15:58:32 <ksf> I shouldn't doubt.
15:58:40 <mauke> > ["ab", "cd"] >>= ask
15:58:41 <lambdabot>   "abcd"
15:59:06 <mauke> why does this make me giggle?
15:59:07 <ksf> > join ["ab", "cd"]
15:59:08 <lambdabot>   "abcd"
15:59:28 <ksf> so now there's a real question.
15:59:36 <Taejo> > ["ab", "cd"] >>= id
15:59:37 <lambdabot>   "abcd"
15:59:41 <ksf> why do we have concat, when join is perfectly ideomatic?
15:59:42 <Taejo> ask == id?
15:59:55 <mauke> Taejo: yes
16:00:01 <ksf> Reader is isomorphic to ->
16:00:19 <Taejo> @src ask
16:00:20 <lambdabot> Source not found. :(
16:00:42 <monochrom> ask is a typeclass method
16:00:44 <mauke> it's a method
16:00:48 <tensorpudding> @src concat
16:00:48 <lambdabot> concat = foldr (++) []
16:01:22 <ksf> :t join [[a]] -> [a]
16:01:23 <lambdabot> parse error on input `->'
16:01:30 <ksf> :t join :: [[a]] -> [a]
16:01:31 <lambdabot> forall a. [[a]] -> [a]
16:01:37 <ksf> :t join :: [a] -> a
16:01:38 <lambdabot>     Couldn't match expected type `a1' against inferred type `[a]'
16:01:38 <lambdabot>       `a1' is a rigid type variable bound by
16:01:38 <lambdabot>            an expression type signature at <interactive>:1:9
16:01:53 <ksf> :t join
16:01:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:01:58 <ksf> well duh.
16:02:06 <ksf> :t join :: [[[a]]] -> [[a]]
16:02:07 <lambdabot> forall a. [[[a]]] -> [[a]]
16:02:35 <ksf> @ask cale can we have concat = join?
16:02:36 <lambdabot> Consider it noted.
16:02:36 <Taejo> :t \x -> const (join x) (head x)
16:02:37 <lambdabot> forall a. [[a]] -> [a]
16:02:44 <mauke> ksf: ew
16:02:52 <mauke> ksf: we already have join = concat
16:03:11 <ksf> :t concat
16:03:12 <lambdabot> forall a. [[a]] -> [a]
16:03:18 <ksf> no we don't.
16:03:19 <tensorpudding> we could define join and have concat = join, but why is that better?
16:03:34 <mauke> @src [] join
16:03:34 <lambdabot> Source not found. Do you think like you type?
16:03:37 <mauke> er, no :-)
16:03:42 <mauke> join is constant
16:03:45 <copumpkin> yep
16:03:53 <ksf> the point is that concat is []'s join in the same way that (.) is (->)'s fmap
16:03:55 <monochrom> I think there is always a tension between "for teaching" and "for professional"
16:04:17 <ksf> and lambdabot speaks caleskell.
16:04:27 <tensorpudding> why do we have map when fmap would do just as well?
16:04:36 <copumpkin> I think fmap should be renamed to map
16:04:58 <ksf> > toUpper . "amazing"
16:05:00 <lambdabot>   "AMAZING"
16:05:09 <monochrom> heh
16:05:23 <Cale> But there's another option for concat too, the monoid concat
16:05:23 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
16:05:27 <tensorpudding> the problem is that, concat and map have noob-friendly types, but  join and fmap don't
16:05:32 <Cale> choices, choices :)
16:05:39 <Taejo> I think join is the right choice here
16:05:50 <Cale> join is already a rather nice name
16:05:58 <tensorpudding> i like fmap
16:06:07 <tensorpudding> because of how funny it sounds
16:06:16 <Cale> I would like (++) to be the general monoid operation
16:06:26 <tensorpudding> mappend is really long
16:06:27 <ksf> definitely.
16:06:28 <Cale> and then concat to be foldr of that and zero
16:06:41 <Taejo> Haskellers are a bunch of wankers: they just sit at their computers fmapping all day
16:06:45 <Cale> heh
16:06:55 <mauke> .oO( wmankers? )
16:07:03 <ksf> and <+ and +> for left- and rightassociative monoids
16:07:33 <Taejo> ksf: what do you mean by a "right associative" monoid?
16:07:40 <Twey> WM anchors — they keep xmonad steady
16:07:40 <ksf> commutative?
16:07:42 <Vanadium> Cannot wait thinking of something cool to do with /* */ operators
16:07:45 <ski> > printf "%s" "a" :: String
16:07:46 <ksf> I always mix those up.
16:07:46 <lambdabot>   "a"
16:08:18 <Taejo> ksf: never heard of left or right commutativity
16:08:25 <ksf> > Just 2 `mplus` Just 4
16:08:26 <lambdabot>   Just 2
16:08:35 <ksf> that one. in a left and right version.
16:08:55 <ksf> I think applicative comes with those.
16:08:58 <Cale> If the monoid is noncommutative then you could have the straight monoid operation, and the flipped over one
16:09:02 <ski> Vanadium : polyglot ?
16:09:13 <Cale> > flip mplus (Just 2) (Just 4)
16:09:14 <lambdabot>   Just 4
16:09:19 <Taejo> monoid operation and its opposite (haskell calls this Dual, but there are good reasons not to)
16:09:20 <tensorpudding> :t mplus
16:09:21 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
16:09:30 <Vanadium> ski: aw, i need enough focus to not fuck up a single language
16:09:30 <tensorpudding> :t mappend
16:09:31 <lambdabot> forall a. (Monoid a) => a -> a -> a
16:09:43 <tensorpudding> i confuse those two sometimes
16:09:49 <ksf> yep so (<+) = flip (+>) and vica versa.
16:09:53 <Cale> actually, Dual is a perfect name, apart from the fact that it steals that name
16:10:11 <mauke> http://mauke.ath.cx/stuff/haskell/yes.hs <- polyglot
16:10:24 <Cale> It is the opposite/dual category treating monoids as categories
16:10:24 <mauke> couldn't use /* because that's not valid in a regex :/
16:10:33 <Taejo> Cale: good point
16:10:46 <Vanadium> \/*?
16:10:50 <ksf> ...using the usual convention that the < points to the value returned
16:10:54 <ksf> well if it exists.
16:11:01 <ksf> (in the case of Maybes, that is)
16:11:04 <Taejo> I guess if it's the categorical dual, I have no argument against it
16:11:21 <mauke> Vanadium: /\*, but that's not a valid comment start in C
16:11:35 <poe> mauke how many languages in 1 file?
16:11:40 <mauke> Vanadium: and /\<newline>* is valid C and Perl but doesn't work in Haskell
16:11:50 <ksf> > Just 2 `mappend` Just 4
16:11:52 <lambdabot>   Ambiguous type variable `t' in the constraints:
16:11:52 <mauke> poe: yes.hs is Haskell, Perl and C
16:11:52 <lambdabot>    `GHC.Num.Num t' arising ...
16:11:55 <Vanadium> Can you use a regexp that is not delimited by //?
16:11:55 <ksf> huh.
16:12:02 <Vanadium> I am not very familiar with how they work in perl :(
16:12:26 <mauke> the C was an afterthought, but the Perl part mimics the structure of the Haskell algorithm (and shares the main program)
16:12:39 <Taejo> Vanadium: I think it's the same as sed and vim: as long as they match, you can delimit regexes any way you like
16:12:44 <mauke> Vanadium: yes, with an explicit m
16:12:48 <Vanadium> mhm
16:13:08 <ksf> monoid's can't express sequences, can they?
16:14:11 <Taejo> ksf: what do you mean by "express"? Most sequence types are monoids
16:14:22 <ksf> directionality.
16:14:34 <ski> Cale,(Taejo) : i'm not sure i agree calling it the "dual category" ..
16:14:44 <ksf> iirc the monoidal operation is defined to be communative.
16:14:53 <ski> nope
16:14:54 <Taejo> ksf: you don't rc
16:15:12 <mauke> ksf: that would break everything
16:15:12 <Taejo> > "abc" `mappend` "def"
16:15:14 <lambdabot>   "abcdef"
16:15:20 <Taejo> > "def" `mappend` "abc"
16:15:21 <lambdabot>   "defabc"
16:15:26 <ksf> then it might be that I meant associative.
16:15:36 <Taejo> yes, it is associative
16:16:01 <ksf> which is why we should have that expressed in typeclasses, so I don't mess it up all the time.
16:16:11 <Taejo> hehe, yeah
16:16:55 <tensorpudding> > mappend 1 1
16:16:56 <lambdabot>   Ambiguous type variable `t' in the constraints:
16:16:57 <lambdabot>    `GHC.Num.Num t' arising ...
16:17:07 <ksf> learning such strange words in primary school really didn't work out.
16:17:11 <tensorpudding> > "foo" "bar"
16:17:12 <lambdabot>   Couldn't match expected type `t1 -> t'
16:17:12 <lambdabot>         against inferred type `[GHC....
16:17:18 <tensorpudding> > mappend "foo" "bar"
16:17:19 <lambdabot>   "foobar"
16:17:28 <ski> > getSum (Sum 1 `mappend` Sum 2)
16:17:29 <lambdabot>   3
16:17:29 <ksf> hey they called verbs "do-words" so why...
16:19:55 <shellsage> what's the best way in haskell to have an optional function argument
16:20:05 * ksf thinks doing a proper typeclass hierarchy is really the best way to teach the ignorant masses algebra. some will hate it, some will love it, and a great majority will be intrigued as they scratch the surface.
16:20:15 <mauke> my first thought would be: Maybe a
16:20:17 <ksf> shellsage, a reader monad
16:20:22 <mauke> whoa
16:20:32 <ksf> you can default it, and you can set it.
16:20:37 <ksf> voila, an option type.
16:20:39 <Eduard_Munteanu> Or use a list :P
16:20:39 <shellsage> ksf, can you give an example
16:20:44 <mauke> ksf: he said optional
16:20:55 <mauke> a reader isn't optional, it's just an argument
16:21:05 <Eduard_Munteanu> like fun :: [a] -> ...
16:21:06 <ksf> yep but you don't have to mention it.
16:21:12 <Eduard_Munteanu> and pass all args in the list :P
16:21:13 <mauke> that doesn't make it optional
16:21:16 <shellsage> Eduard_Munteanu, yeah
16:21:22 <ksf> sure it does, you optionally mention it.
16:21:34 <ksf> we're just talking different things here.
16:21:36 <mauke> BUT IT'S STILL PASSED IN AND YOU HAVE TO SET IT ELSEWHERE
16:21:37 <shellsage> is there another way?  can I say myfunction 1, and myfunction 1 2
16:21:44 <mauke> shellsage: no
16:21:50 <ksf> ...the same goes for a maybe
16:21:52 <shellsage> mauke, so I need 2 functions?
16:22:02 <mauke> you can say myfunction 1 Nothing, and myfunction 1 (Just 2)
16:22:08 <mauke> ksf: no
16:22:09 <ksf> except that it's not optional whether you mention it.
16:22:38 <shellsage> ksf, are you saying that the word Nothing in what mauke said is optional?
16:22:38 <lament> shellsage: the safest and probably best solution is to not even think about default arguments.
16:22:45 <ksf> in the sense of s/ELSE/SOME/
16:22:50 <mauke> shellsage: no, the opposite
16:22:54 <lament> shellsage: I noticed that this is also the case in languages which do explicitly support default arguments.
16:23:00 <ksf> no, that Maybe is an option type.
16:23:14 <shellsage> lament, should I just use a helper function?
16:23:15 <ksf> which is very, very distinct from optionally mentioning an argument.
16:23:29 <mauke> shellsage: it depends on what your function does
16:23:41 <lament> shellsage: what is it you actually want to do?
16:23:45 <shellsage> my function creates a URI, and I need to be able to optionally pass in authentication credentials
16:23:50 <ksf> and we won't get to the solution until we know what of both we want.
16:23:55 <ksf> or even both at the same time.
16:24:14 <ksf> sounds like a case for Maybe
16:24:19 <mauke> ah, as in http://foo:bar@baz?
16:24:23 <shellsage> mauke, yeah
16:24:28 <shellsage> mauke, or http://baz
16:24:30 <mauke> I'd use Maybe
16:24:36 <shellsage> can someone give an example
16:24:55 <ksf> data URI = URI (Maybe String) String ...
16:25:03 <mauke> @src Maybe
16:25:04 <lambdabot> data Maybe a = Nothing | Just a
16:25:06 <ksf> there's an URI package on hackage, btw.
16:25:14 <shellsage> I'm using the URI package
16:25:18 <ksf> oh.
16:25:53 <ivanm> heh
16:26:54 <ksf> then you have something like mkURI = URI { uriScheme = "foo", uriPath = "bar", uriQuery = "baz", uriFragment = "quux"}
16:27:01 <shellsage> http://haskell.pastebin.com/d79170893 I want to change this function to take an argument, called cred, so that if cred is provided, I can set the username/password in the parsed URI
16:27:06 <Eduard_Munteanu> Perhaps GADTs allow optional args?
16:27:13 <ksf> where mkURI :: Maybe URIAuth -> URI
16:27:19 <ksf> due to record goodness.
16:27:37 <Eduard_Munteanu> or at least emulate them.
16:28:05 <ksf> and then you either pass in Nothing or Just <your auth>, and you're set.
16:28:19 <ksf> :t uriScheme
16:28:20 <lambdabot> Not in scope: `uriScheme'
16:29:35 <ksf> or wait.
16:29:52 <ksf> what you want is to optionally pass uriUSerInfo, but not uriRegName?
16:30:07 <shellsage> I have my own Credentials object w/ a username and password
16:30:25 <shellsage> I just want to take its username and password and apply it to the URI
16:31:05 <ksf> oh. now I get it.
16:31:21 <ksf> you pass an optional argument like this:
16:31:25 <ksf> :t showFFloat
16:31:26 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
16:31:33 <ksf> see it takes maybe an Int.
16:31:37 <shellsage> yeah
16:31:57 <ksf> > showFFloat Nothing 3.333333333 "foo"
16:31:58 <lambdabot>   "3.333333333foo"
16:32:06 <ksf> > showFFloat (Just 2) 3.333333333 "foo"
16:32:07 <lambdabot>   "3.33foo"
16:32:47 <copumpkin> that's an astoundingly ugly function
16:32:48 <ksf> that was an utter and complete collective crystal ball fail.
16:32:59 <ksf> > showFFloat (Just 0) 3.333333333 "foo"
16:33:00 <lambdabot>   "3foo"
16:33:06 <ksf> it has to take a maybe.
16:33:22 <ksf> and it takes another string due to String having the wrong type
16:33:31 <ksf> [Char] that is, instead of Seq Char
16:37:00 <Eduard_Munteanu> Wow, the Agda 2 wiki has a lot of nice info.
16:37:32 <Eduard_Munteanu> http://code.haskell.org/Agda/examples/Introduction/Basics.agda
16:37:39 <Eduard_Munteanu> Very Haskell-ish.
16:37:43 <copumpkin> there's also a channel, #agda
16:37:52 <Eduard_Munteanu> copumpkin, thanks, didn't try yet.
16:38:01 <copumpkin> :)
16:38:05 <dolio> Haskell-ish was the goal, I think.
16:38:05 <lambdabot> dolio: You have 1 new message. '/msg lambdabot @messages' to read it.
16:38:05 <Eduard_Munteanu> I wish Haskell and Agda would merge in the future.
16:38:09 <ksf> I'm in there so it doesn't run empty.
16:38:31 <copumpkin> Eduard_Munteanu: they're quite different once you get past the apparent similarity, I think
16:39:12 <Eduard_Munteanu> copumpkin, yeah, but I wish I could flip a cmdline switch and make Haskell total and use some of that Agda pattern matching.
16:39:20 <copumpkin> :)
16:40:03 <shellsage> ksf, ok I'll use the maybe
16:41:46 <shellsage> How do I set the URIAuth of an existing URI?
16:41:57 <shellsage> Meaning how do I create a new URI with some parts of the old one
16:42:52 <Eduard_Munteanu> copumpkin, I wonder if Agda could ever be an evolution of Haskell. It seems very useful for general programming, plus you can import Haskell functions.
16:43:22 <ksf> ...coming back to the optional arguments: the True, Right And Proper way to optionally pass an argument in haskell is to wrap the function into Optional o f, where o is a heterogenous record of bindings having an default that you can override, f being the function type and Optional o being a reader monad providing the arguments to f.
16:43:36 <ksf> or something like that, depending on how it fits into the type system.
16:44:11 <ksf> shellsage, oldURI { uriAuth = newAuth }
16:44:20 <ksf> that's standard record syntax
16:44:25 <shellsage> ok
16:45:39 <ksf> ...which is creating a new one, defaulting the not mentioned fields, not setting a field.
16:46:02 <shellsage> ugh, this is so frustrating having to ask a question for doing every single little thing
16:46:13 <shellsage> but how do I get a parameter out of URIAuth
16:46:17 <shellsage> out of an existing one
16:46:31 <ksf> in a pattern match.
16:47:33 <shellsage> ksf, can you give an example
16:47:38 <ksf>   case auth of wholeAuth@URIAuth{ port = uriPort }
16:47:50 <shellsage> ksf, I just want to get the port out
16:48:02 <shellsage> is there not a simpler way
16:48:06 <ksf> you can leave out the wholeAuth@ part
16:48:17 <ksf>   case auth of wholeAuth@URIAuth{ uriPort } should work too, with recent ghc's.
16:48:22 <shellsage> ksf, I want to actually fetch the current port
16:48:26 <shellsage> into a new variable
16:48:31 <shellsage> I want to be able to print the port to the screen
16:48:38 <ksf> "port" is the new variable.
16:48:44 <shellsage> ok
16:48:49 <ksf> "uriPort" in the second example.
16:49:23 <ksf> maybe you need to enable a language feature to enable that syntax, though
16:49:46 <shellsage> is there not a simpler way to fetch the port out of this thing?
16:49:52 <shellsage> w/o having to do a whole case statement
16:49:52 <ksf> ah there it is http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#record-puns
16:49:58 <ksf> it's called record funs
16:50:02 <ksf> er puns
16:50:19 * ksf facepalms
16:50:22 <Saizan_> can't you just the record name as an accessor?
16:50:26 <Saizan_> éuse
16:50:30 <ksf> yep, exacty.
16:51:00 <ksf> uriPort :: URIAuth -> String
16:51:15 <shellsage> ksf, I understand that to you, these are idiotic questions worthy of flaming and everything, but to someone who has never worked with Haskell this is pretty standard stuff
16:51:29 <ksf> no worries
16:51:32 <Saizan_> you can just use "uriPort yourAuth"
16:51:37 <shellsage> thankyou
16:51:54 <ksf> Right now, I'm certainly looking more like a fool than you.
16:52:17 <copumpkin> Eduard_Munteanu: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=8890#a8890
16:52:41 <Saizan_> we actually try to be helpful for newbies, though following a good tutorial helps too
16:53:29 * ksf suddenly understands why salesmen always want to sell you an assembly line when all you need is a can opener.
16:53:40 <Eduard_Munteanu> copumpkin, seems a mix with Agda :)
16:54:06 <shellsage> Saizan_, I've yet to find a tutorial that shows things being used together, every tutorial introduces monads separately from everything else, and doesn't show someone using a monad plus data plus other stuff all at once to do something real
16:54:18 <Eduard_Munteanu> copumpkin, can it do proofs and detect partiality? :)
16:54:23 <ksf> shellsage, try rwh
16:54:25 <ksf> @where rwh
16:54:25 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
16:54:27 <copumpkin> Eduard_Munteanu: nah, very simple
16:54:33 <shellsage> ok
16:54:37 <copumpkin> Eduard_Munteanu: well, you can do proofs using standard haskell machinery
16:54:39 <Saizan_> shellsage: rwh has plenty of examples like that
16:55:07 <copumpkin> Eduard_Munteanu: you'll see I already defined an induction function in there, but here's more on proofs in haskell: http://www.haskell.org/pipermail/haskell-cafe/2009-June/062690.html
16:55:24 <Eduard_Munteanu> copumpkin, as I've been explained to by some, that's not entirely true. As Haskell can't tell you if you screwed up by providing partial function definitions.
16:55:31 <copumpkin> Eduard_Munteanu: that link is all regular haskell with a few GHC extensions
16:55:49 <copumpkin> Eduard_Munteanu: true, but if you trust yourself not to do that, it can check your proofs ;)
16:55:50 <Eduard_Munteanu> copumpkin, like non monomorphism restriction I guess.
16:55:56 <Eduard_Munteanu> copumpkin, I see.
16:56:09 <ksf> @where+ next okmij.org/ftp/ , and you won't get further.
16:56:09 <lambdabot> I will remember.
16:57:03 <Eduard_Munteanu> copumpkin, any "theorems" libs for Haskell?
16:57:08 <copumpkin> nope
16:57:10 <copumpkin> :)
16:57:10 <ksf> hey oleg has a c2 page
16:57:14 <Eduard_Munteanu> :(
16:57:23 <copumpkin> Eduard_Munteanu: well, there might be some stuff in
16:57:26 <copumpkin> @hackage type-level
16:57:26 <lambdabot> http://hackage.haskell.org/package/type-level
16:57:39 <Eduard_Munteanu> copumpkin, nice, will put Cabal to look into that
16:57:39 <copumpkin> but I doubt there's much
16:58:43 <__JN> Hi, I need a little help, can I use some monadic approach with splitAt to part a list in different pieces to avoid a lot of "(a,rest) = splitAt 5 list ; (b,rest2) = splitAt 8 rest ..." functions, to collect the results a,b,c,d,...?
16:59:14 <Saizan_> yes, the State monad
16:59:21 <Saizan_> ?type splitAt
16:59:21 <lambdabot> forall a. Int -> [a] -> ([a], [a])
16:59:27 <Saizan_> ?type State
16:59:28 <lambdabot> forall s a. (s -> (a, s)) -> State s a
16:59:45 <Saizan_> ?type \n -> State (splitAt n)
16:59:46 <lambdabot> forall a. Int -> State [a] [a]
16:59:59 <Eduard_Munteanu> copumpkin, anyway, SHE provides a nice perspective. Hope SPJ and others get involved with that stuff too.
17:00:59 <__JN> Saizan_: thank you, I will investigate the State monad then
17:01:06 <Saizan_> ?type split n = State (splitAt n) in flip runState "qwertyuiop" $ do a <- split 3; b <- split 2; return (a,b)
17:01:07 <lambdabot> parse error on input `='
17:01:14 <Saizan_> ?type let split n = State (splitAt n) in flip runState "qwertyuiop" $ do a <- split 3; b <- split 2; return (a,b)
17:01:15 <lambdabot> (([Char], [Char]), [Char])
17:01:18 <Saizan_> > let split n = State (splitAt n) in flip runState "qwertyuiop" $ do a <- split 3; b <- split 2; return (a,b)
17:01:19 <lambdabot>   (("qwe","rt"),"yuiop")
17:01:33 <ksf> @remember c2.com If you can program anything in HappS you actually already learned Haskell
17:01:33 <lambdabot> Good to know.
17:01:36 <__JN> Great, thank you!
17:02:00 <Saizan_> np :)
17:05:31 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
17:05:31 --- topic: set by mauke on [Mon Nov 02 11:41:43 2009]
17:05:31 --- names: list (clog_ tov cygnus diltsman_ ville Keiya_ cying baddog pao astrocub jbauman Zeiris novas0x2a __JN blackdog Mortomes juhp roconnor Keiya Peaker jcapper hape_ ivanm levitation_ seanstickle Taggnostr redline6561 kpreid Cobra^^_ cloudhead copumpkin bak aluink jethomas Kim^Walkman doserj waern dolio Twey clog Trafalgard samnardoni amiri derrida Smokey` jsgf amz Pthing jan____ noteventime iago tensorpudding Philonous Raynes sprang segoe sohum Philippa)
17:05:31 --- names: list (whoppix noisetonepause mattrepl vili1 pythonista Gracenotes nlogax tommd paulvisschers FunctorSalad bgs100 gnuvince thotypous monochrom XGas red-agent njbartlett Asztal BurgessShale booxter proq Bassetts JohnnyL trin_cz adept watermind jimfear mrbluesky floodleboodle shellsage fihi09 flippo Stefa1 dancor Cthulhon _andre ChthonLaptop jmelesky saint_cypher gbeshers Tomas_ mlesniak rey_ Eduard_Munteanu jtra sioraiocht BCoppens kynky newsham)
17:05:31 --- names: list (dschoepe fracture ddarius Aikawa_ aiko nathanic_work nominolo_ sm ski_ skeeterbug gbacon int-e anders^^ macron shapr baaba IceDane voker57 boogyman Apocalisp THC4k hgolden gogonkt_ epmf_ rickasaurus sudharsh triplez clanehin jelly12gen gbeshers_home mak__ miccm Guest75642 zakwilson SamB_XP Ornedan mxc Kambus ksf ttmrichter zhijie TML flibbertigibbet RayNbow O_4 zong_sharo deavid DekuNut hrehf blackh linkinus Cale revertTS hd_ twanvl thoughtpolice)
17:05:31 --- names: list (+hackagebot augur smg Neronus jix dmwit zachk dejones m-i-l-a-n Colours otto_s burp malie qz kmc Pewpewarrows Vanadium spoop ve StoneToad_ pixel5 pifish Axman6 jaj mm_freak TR2N lispy hazridi alexbobp peddie lisptastic nathanic PsiOmega loupgaroublond karihre Whitesquall tessier smorg clarkb jamwt Draconx crem_ mulletron soduko iaefai cognominal hiredman allbery_b trez jimmyjazz14 eno Optimo jkramer eldragon ahf eelco Saizan_ jontore earthy)
17:05:31 --- names: list (ToRA dankna eek thingwath MyCatVerbs leadnose zax mreggen glith AnMaster eagletmt rasfar kadoban_ ath nwf onodrim Nereid caligula__ ksandstr rdd noZone gwern amuck leoncamel Alpounet nipuL sjanssen jml duairc xinming wisemanby reltuk fnord123 +lunabot saccade erk guerby alexsuraci majoh Elly wang cods wimt Sisu dreixel SmurfOR __marius__ teneighty tromp_ dcoutts_ davidL PHO_ inimino nablaa orbitz hesselink_ koninkje_away idnar endojelly)
17:05:31 --- names: list (desp bockmabe_ beibmozoi bd_ sebas__ Laney tew88 _Jordan_ geoaxis_ mml`_ dilinger_ rapacity theclaw mux mokus_ mauke tilman noj +lambdabot daed brx periodic thetallguy alip alpheccar bind_return Blub\0 loop AndyP ziman Botje drhodes Gabbie lament welterde Vq helge qwr arcatan tltstc mdordal2 mfoemmel tuukkah OnionKnight mfp araujo regulate noddy chrisdone Elench bolrod midnite Zao dfeuer mjrosenb gOcOOl epokal nnunley ray liff mw493 JaffaCake)
17:05:31 --- names: list (Maddas Baughn zygoloid nominolo|uni birkenfeld Valodim Warrigal Ferdirand marmolak tarbo_ laz0r dqd maskd absentia zaarg icee Twigathy scree ps-auxw thetallguy1 Gilly cjay dixie Blaketh lefant Veinor p_l aavogt cygnus_ jasonmay mikste danopia` sevvie guerrilla osfameron ehamberg flori profmakx lsthemes arjanoosting poe thedward stalker jonafan sunfun jims doublethink_work det flux ath^ avysk angelixd yahooooo ertai_ companion_square dionoea)
17:05:31 --- names: list (authentic Innominate jql Raku^ anekos therp Nereid_ Boney mmmdonuts malouin pragma_ Deewiant qebab quicksilver koala_man qed tmug desu kar-1 mlh nornagon droidcore dcolish SubStack jfoutz cathper xian netcat joga tumult LeCamarade Counter-Strike jre2 int_e EvanCarroll jystic srcerer jfredett dogmaT Esmil kakeman suiside mikm Jaak dino- Paks webframp Tobsan mahogny thorkilnaur sior|oifig magicman Megant gdsx alexander2 wagle_home stepnem)
17:05:31 --- names: list (donri tavelram da-xw mjv Lemmih pantsd_pcf andrewsw-afk da-x ggreg_ stoop blalb sebbe1991 GNU\colossus _plcs_ skaar impl mornfall pettter koeien Annie|Home prigaux aleator SimonRC etpace rdrake wolverian agemo kosmikus mmmulani Stephan202 nothingmuch greap ahihi Eelis mapreduce joed anji_ saiam opqdonut rgr jayne kw317 ^Einstein McManiaC Liskni_si lilac PeakerWork dibblego t andun kmc_ jfhall ystael Lycurgus nasloc__ dcoutts sunnavy hsaliak_)
17:05:31 --- names: list (Poeir dek5 disgrntld FauxFaux ido phr Khisanth sieni sbok ac lanaer harlekin wdonnelly jvogel_ wharrgarble poucet pcc1 kmeyer fnordus edwtjo emias Aisling danderson Nanar geir_ LeoD jnwhiteh equanimity erg SeaPrior _br_ bran BrianHV fryguy nimred boyscared franksh heaumer mattam dumael sproingie stroan r0bby thomastc mshaw glitch qm13_ sgf_ lavish ned mrd willb ski drbean Vulpyne electrogeek +preflex Paradox924X luite Nafai hellige mercury^)
17:05:31 --- names: list (mle olsner shortcircuit shachaf BONUS djinni jahgru wormwood jrockway integral eyck_ shepheb Milo- snorble fxr cdfh_ emma @ChanServ Heffalump jones- tkr inhortte kolmodin snhmib Jedai pikhq sereven taruti jlouis aempirei kanalj karld MacCoaster dons byorgey Jiten kalven Exteris igorgue jlaire raim0 And[y] canvon neurocyte felipe_ drspider Badger DrSyzygy deiga tamiko samulihs BONUS_ wornof jvoorhis ibid Raevel arkx Bleadof kuningas)
17:05:59 <copumpkin> too many people think monads are about state
17:06:13 <Saizan_> i blame YAHT
17:06:13 <ksf> the stuff they have about monads oscillates between brilliant and naive
17:06:15 <monochrom> Then I am a member of the ignorant masses.
17:06:20 <copumpkin> not sure if that's better than thinking monads are mysterious beings
17:06:30 <ksf> having it all in one place gives a much better view than just the brilliant stuff.
17:06:41 <ivanm> Saizan_: you mean I was pre-emptively saved by never reading YAHT? :o
17:06:44 <ivanm> \o/
17:07:05 * copumpkin is a product of #haskell
17:07:25 <ivanm> @hoogle #Haskell -> copumpkin
17:07:25 <lambdabot> Parse error:
17:07:26 <lambdabot>   --count=20 "#Haskell -> copumpkin"
17:07:26 <lambdabot>              ^
17:07:28 <ivanm> :(
17:07:37 <copumpkin> not an exponential
17:07:49 <ivanm> heh
17:07:56 <copumpkin> sorry :P
17:08:39 <ddarius> YAHT didn't exist when I started learning Haskell.
17:09:11 <Eduard_Munteanu> What's YAHT?
17:09:13 <Twey> Old-school
17:09:14 <MyCatVerbs> type copumpkin = (#haskell, human)
17:09:19 <ivanm> Yet Another Haskell Tutorial
17:09:25 <ivanm> ddarius: did any tutorial exist? :p
17:09:29 <Eduard_Munteanu> Oh.
17:09:38 <copumpkin> ddarius didn't learn haskell, haskell learned him
17:09:46 <monochrom> The Gentle Introduction existed. It was great.
17:09:51 <Eduard_Munteanu> The monad - space-suit analogy is funny and instructive.
17:09:52 <ivanm> s/him/to put up with him/
17:09:53 <ivanm> ;-)
17:09:54 <dancor> did it learn you ..a haskell
17:10:00 <ivanm> monochrom: and not so gentle? :p
17:10:00 <monochrom> haha
17:10:14 <ksf> Oh I'm a http://c2.com/cgi/wiki?OnceAndOnlyOnce addict
17:10:37 <monochrom> I don't care about the title. It was to the point. No idle chattery.
17:10:53 <ivanm> monochrom: unlike BONUS' work?
17:11:02 <copumpkin> no list monsters? :(
17:11:17 <monochrom> I don't know bonus's work. Or maybe I know but too chattery.
17:11:17 * ivanm learnt Haskell via craft and hacking on Bird/Hutton's sudoku solver
17:11:29 <ivanm> monochrom: LYAH is what I'm referring to
17:11:46 <Peaker> I learned from Gentle+YAHT+#haskell
17:11:53 <ksf> the best tutorial when I started out was all about monads
17:12:11 <ksf> then reading haddock.
17:12:17 <ksf> and not being afraid of pdfs.
17:12:43 <ddarius> ivanm: Indeed, the Gentle Introduction is what I read firsth.
17:12:48 <ksf> I'm actually one of those people that wonder what monads are and then set out and read the STG paper.
17:13:00 <monochrom> LYAH is entertaining. Since it's entertaining, its chattery has achieved its purpose and not idle.
17:13:05 <ksf> not that I learned much about monads there, but I couldn't know that beforehand.
17:13:14 <Saizan_> if you read YAHT you get IO explained via the GHC's cheating implementation, and the impression that the relevant difference between foldl and foldr is the direction of the nesting
17:13:44 <ivanm> "cheating implementation"?
17:13:50 <Eduard_Munteanu> "impression"?
17:13:52 <Eduard_Munteanu> :P
17:13:54 <ksf> oh yes and that wiki page about folds was _really_ important.
17:14:04 <ksf> ...as it's the other way round than scheme.
17:14:35 <Saizan_> ivanm: State RealWord#
17:14:40 <Eduard_Munteanu> BTW, is anybody aware of any functional computer model?
17:14:45 <ksf> and excetpions not being thrown where you'd expect them to be thrown, from a call by value point of view
17:14:47 <Eduard_Munteanu> I mean down to the bones.
17:14:53 <ivanm> Saizan_: so the inner details?
17:15:10 <copumpkin> Eduard_Munteanu: http://www.cs.york.ac.uk/fp/reduceron/ ?
17:15:18 <Eduard_Munteanu> copumpkin, I think I remember that.
17:15:25 <Eduard_Munteanu> Was something Lisp-ish IIRC>
17:15:34 <Saizan_> ivanm: it actually uses State RealWord where the RealWord type is supposed to really represent the state of the world, but it's still fishy
17:15:44 <copumpkin> http://en.wikipedia.org/wiki/Lisp_machine
17:16:08 <copumpkin> RealWorld is just to create a dummy data dependency
17:16:13 <copumpkin> nobody ever looks inside it
17:16:19 <ksf> but "GHC threads the real world through your program" makes for great mindbenders.
17:16:37 <ksf> you just have to keep on insisting that it's really the world.
17:16:50 <ksf> it's a matter of inside vs. outside.
17:17:07 <ksf> I prefer to be in the program, looking out, not outside, looking in.
17:17:19 <Saizan_> but the world contains your program too!
17:17:21 <monochrom> Gives a whole new meaning to "hello, is that Dell tech support? oh good, I call because *my* internet is broken..."
17:17:28 <copumpkin> Saizan_: impredicativity!
17:17:41 <ksf> Saizan_, so what, your notion of reality includes you.
17:17:58 <ksf> it's the basis of self-awareness.
17:18:00 <wagle_home> my phone operates over the same fiber as my internet
17:18:04 <Saizan_> ksf: i don't thread all of reality inside me!
17:18:13 <copumpkin> I beg to differ
17:18:22 <monochrom> and also "how do I download the internet?"
17:18:25 <lament> Saizan_: clearly you have never taken LSD
17:18:26 <ksf> all the reality you can percieve, at least.
17:18:34 <ksf> and you can't tell anything about the rest.
17:18:40 <monochrom> Haskell IO lets you download the whole internet!
17:18:43 <wagle_home> obvious answer is "work for google"
17:19:06 <copumpkin> or archive.org
17:19:11 <monochrom> haha wagle_home
17:19:31 <wagle_home> copumpkin, thanks, i was trying to remember the name of that one
17:19:35 <ksf> in fact, the inside perspective and zoning in are one and the same thing for me
17:19:40 <ivanm> monochrom: even better, lazily! :p
17:20:04 <ksf> so, people, stare at those hypercubes, they teach you important things.
17:20:27 <ksf> http://www.dimensions-math.org/Dim_E.htm
17:20:55 <lament> my favourite hypercube is http://en.wikipedia.org/wiki/File:10cube_ortho_polygon.svg
17:21:04 <Eduard_Munteanu> http://en.wikipedia.org/wiki/Reversible_computing
17:21:15 <Eduard_Munteanu> Am I the only one who sees a connection between this and purity?
17:21:22 <Twey> I have that as my desktop background, lament
17:21:29 <Twey> Minus the blue vertex labels
17:22:09 <lament> is your monitor square?
17:22:30 <lament> or circular?
17:22:36 <Twey> Rectangular :þ
17:22:44 <lament> aw
17:24:12 <copumpkin> Eduard_Munteanu: nope :)
17:24:23 <copumpkin> by the way, http://www.iai.uni-bonn.de/~jv/popl09-2.pdf might be interesting
17:24:32 <monochrom> Eduard_Munteanu: http://article.gmane.org/gmane.comp.lang.haskell.cafe/22537/
17:24:57 <eldragon> reversible computing is useless
17:25:08 <Eduard_Munteanu> copumpkin, basically purity ensures you don't destroy information, so it seems a better description of reversible computers, if they exist.
17:25:27 <copumpkin> eldragon: that's a fairly strong thing to say out of the blue :)
17:25:38 <Twey> No it's not!
17:25:49 <IceDane> I've been looking at custom types and such a bit just now, I'm wondering if Integrals and other typeclasses are basically done like this: data Integral = Integer | Int
17:25:50 <ksf> eldragon, ever used the undo function?
17:25:51 <Twey> They're ever so energy-efficient
17:25:55 <IceDane> is that correct thinking?
17:26:03 <monochrom> haha
17:26:04 <Twey> You can calculate things, using some energy, store the result, then uncalculate it to get the energy back
17:26:13 <Eduard_Munteanu> monochrom, wow.
17:26:21 <eldragon> ksf, redo, redo, redo, ... from the breakpoint.
17:26:30 <ksf> IceDane, nope
17:27:02 <monochrom> Of course, I am hardly the first one to speculate molecular computers for haskell.
17:27:24 <Eduard_Munteanu> copumpkin, I'll take a look at it.
17:27:31 <ksf> can someone point IceDane to that nice spj talk where he explains how to express typeclasses in haskell without typeclasses?
17:27:31 <Saizan_> IceDane: Integral is nothing like a datatype, and also typeclasses are open, you could make your own new type and define an Integral instance for it
17:27:49 <IceDane> hehe, I guess i?ll read further then
17:28:31 <Saizan_> ksf: translating to dictionaries?
17:28:33 <monochrom> But probably I am the first one to write it with fun. I mean, "C programmers have to consult us for performance tips" and "Campbell soup". :)
17:28:43 <ksf> Saizan_, that one, yes.
17:28:48 <Eduard_Munteanu> monochrom, heh
17:28:59 <ksf> although I heard they're going to change the implementation
17:29:05 <ksf> it's still a good way to grok them
17:29:34 <eldragon> before of crash, it's interesting to "dump" to the circular 10 heaps in each step. Once crashed, you can start to see from the 1st 10th heap how the next 10 steps drive to crash.
17:29:56 <copumpkin> change the implementation to what?
17:30:07 <ksf> eldragon, something like happstack's transactions?
17:30:23 <ksf> something that doesn't require as many dictionaries to be passed at run time.
17:30:30 <ksf> I don't recall the details.
17:31:15 <copumpkin> http://fml.madsravn.dk/
17:33:10 * ksf just read "a thunk is a lot of noodles linked up"
17:33:18 * monochrom jokes: just replace dictionary by hash table
17:33:27 <monochrom> heheheh
17:36:07 <ksf> I always imagine a native stg box to be an fpga of sorts.
17:36:59 <ksf> ...you have the graph represented directly in hardware, and it can reduce itself in parallel at all possible points.
17:37:30 <ksf> propably needs to be at least 4-dimensional to be efficcient, though.
17:38:26 <monochrom> So every evaluation step rewires the fpga internal circuit a bit? Isn't that slow?
17:38:52 <ksf> I don't think so.
17:39:09 <ksf> it's locally self-modifying hardware. there's no central control.
17:39:15 <ksf> everything's asynchronous.
17:39:34 <Eduard_Munteanu> I was under the impression programming a FPGA is kinda slow.
17:40:16 <ksf> fpgas might be slow if you use them to emulate traditional cpus, but not at all if you compile your algorithm down directly to configware.
17:40:17 <Eduard_Munteanu> Unless you're suggesting some new sort of FPGA.
17:40:22 <monochrom> I have not heard of FPGA as locally self-modifying hardware. I have only heard of needing an external circuit board 5 times bigger than the FPGA chip to modify the FPGA chip.
17:40:23 <gwern> oh dear, icann is allowing UTF domain names?
17:40:26 <Peaker> Eduard_Munteanu, FPGA is faster than software for the things its good at
17:40:27 <gwern> this is not going to end well
17:40:30 <ksf> you get a complexity reduction for free.
17:40:38 <Eduard_Munteanu> monochrom, exactly.
17:40:41 <eldragon> it's interesting to enable periodic checkpoints for dumping all, e.g. alpha=1% of the time is checkpointing & dumping, ... until the last moment that it's crashed. Then restart to the last checkpoint with higher alpha=30% of the time until the crash. The sucessive last checkpoint is for step to step how the code drived to the crash.
17:40:56 <Eduard_Munteanu> Peaker, I didn't mean slow at running things.
17:41:03 <ksf> gwern, DENIC has had that for some time now.
17:41:03 <Eduard_Munteanu> "Slow" as in slow at programming the FPGA.
17:43:02 <ksf> well, loading the bios out of the eeprom is also only comparable in speed to hurd's pace of progress.
17:44:31 <teatimer> why is haskell so cool?
17:44:56 <eldragon> teatimer, haskell isn't cool
17:44:57 <monochrom> No, haskell is not cool. haskell is hot!
17:45:26 <eldragon> the ghc binary is titanic, >100 MB
17:45:26 <Eduard_Munteanu> teatimer, probably to compensate for the geeks using it :P
17:45:35 <Cale> teatimer: There are many reasons.
17:45:47 <eldragon> you can't fit ghc in 640 KB
17:45:48 <Peaker> teatimer, strong type system, purity, novel ways of collapsing tons of primitives from other languages into much fewer in Haskell
17:46:00 <gnut> hi all
17:46:06 <sproingie> laziness
17:46:13 <Eduard_Munteanu> ksf, lol
17:46:20 <Eduard_Munteanu> I presume you meant the Hurd kernel.
17:46:48 <eldragon> ghc is collapsed for nothing.
17:47:06 <Cale> teatimer: The stuff that Peaker said, plus awesome concurrency and parallelism support. :)
17:47:50 <IceDane> What is a way of going about finding the index of an element in a sequence? E.g., let's say I want to find a number that satisfies a predicate in a list, how do I find its index?
17:48:05 <Cale> :t findIndex
17:48:06 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
17:48:21 <Cale> It's in Data.List
17:48:28 <IceDane> oh, sweet
17:48:29 <IceDane> thanks
17:48:30 <Eduard_Munteanu> And because it forces you to learn useless exciting math concepts that a C programmer doesn't know. :
17:48:33 <Eduard_Munteanu> :P
17:48:38 <Cale> Eduard_Munteanu: hehe
17:48:39 <IceDane> Eduard_Munteanu: that is too right
17:48:41 <monochrom> haha
17:48:46 <Cale> I wouldn't say *forces*
17:48:49 <teatimer> hhahaha
17:48:49 <IceDane> I've been living on wikipedia since I started to look at haskell
17:48:54 <Eduard_Munteanu> :)
17:48:55 <Peaker> teatimer, laziness lets you express things in really modular ways you wouldn't expect are even possible :)
17:48:56 <monochrom> and I wouldn't say "exciting"
17:48:57 <teatimer> "exciting math concepts"
17:49:02 <Cale> But it certainly seems to get its hooks into your mind.
17:49:22 <Peaker> I still miss decent stack traces in Haskell, and hate N-tuples
17:49:28 <Cale> Mathematics can indeed be exciting :)
17:49:41 <gnut> Cale: indeed it is :)
17:49:42 <Eduard_Munteanu> monochrom, well, category theory is some enjoyable babble.
17:49:57 <mauke> enjoybable
17:50:03 <Eduard_Munteanu> :P
17:50:11 <Saizan_> IceDane: LYAH or RWH are better sources to learn haskell :)
17:50:19 <Saizan_> ?where LYAH
17:50:20 <lambdabot> www.learnyouahaskell.com
17:50:23 <sproingie> ejoybably yable
17:50:24 <monochrom> OK, I confess it's exciting, I was hiding my feeling!
17:50:56 <mauke> search your feelings. you know it to be true
17:50:57 <IceDane> Saizan_: First site I found
17:50:58 <Cale> I've begun to see it as more than just abstraction. There's actually content to category theory as you push further in fairly natural directions. It overlaps with a lot of stuff from topology, logic and computation in a nice way.
17:51:00 <IceDane> ?where RWH
17:51:01 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
17:51:13 <IceDane> And I'm reading the RWH book as we speak
17:51:32 <gnut> I use some commercial code which calls function f1, which I've implemented in C, then f1 calls f2, which is implemented in haskell. I want to make all this a shared object so I don't need to compile it each time. How do I make f2 call f3 which I can then implement for each plugin?
17:51:32 <Peaker> There's Data.Binary and lens's and pickler combinators and cool stuff like that.  Is there anything, however, that lets you specify an exact format (e.g: CSV, binary formats) and get a 2-way parser/builder? If the encoding is lossy (for example, multiple ways to encode CSV escapes) its Ok if the lost data is stored in the unpacked value
17:51:34 <Cale> (Especially higher-dimensional category theory)
17:51:41 <tensorpudding> n-categories?
17:51:59 <Cale> tensorpudding: yeah
17:51:59 <Peaker> I hate that people are composing parsers, rather than parser-builders
17:52:19 <Peaker> I think the delta in effort between the 2 should be minimal, but the delta in usefulness pretty huge
17:52:22 <Cale> Peaker: Aren't they doing a bit of that too?
17:52:33 <tensorpudding> i first learned about category theory from john baez
17:52:36 <Peaker> Cale, with Data.Binary, unless they derive it, they're still writing both parser and builder..
17:52:55 <Peaker> Cale, Where are people composing parser/builders?
17:53:01 <tensorpudding> and his crazy posts about n-categories
17:53:07 <gnut> awodey has a good book on category theory. nice and succinct.
17:53:18 <Peaker> I once tried to tackle the issue of parser-builder combinators but got nowhere. I should re-try now that I have much more Haskell mojo
17:53:20 <monochrom> But Cale, that's just because "push further" entails adding more axioms (such as those of topos), which are the ones giving content. It is like saying "ring theory has content because you add the noetherian ring assumption"
17:53:39 <tensorpudding> awodey's book has a non-rigorous feel to it in some way i can't put my finger on
17:53:47 <Peaker> I remember I silly-ily focused on type-classes like ReversibleApplicative, which has little to do with the problem
17:53:55 <tensorpudding> he really likes putting things in "quotation marks"
17:54:00 <Peaker> (or at least, its better to figure out the classes a little later in this case)
17:54:17 <Cale> monochrom: Well, just considering different variations of higher-dimensional categories and then collapsing different dimensions gives you a lot of interesting stuff on its own.
17:54:21 <gnut> tensorpudding: hmmm... I don't recall seeing tons of quotation marks. I understand it's not as rigorous, but it's light bathroom reading.
17:54:32 <tensorpudding> yeah
17:54:49 <tensorpudding> i want a book as readable as awodey's, but at least half as rigorous as mac lane's
17:54:54 <Peaker> Cale, so is anyone doing it in a way that allows me to declaratively specify what the CSV format *is* and get both a parser and a builder for it?
17:55:17 <Cale> Peaker: Oh, I see what you mean
17:55:47 <Eduard_Munteanu> The best example of useless math in Haskell is that factorial implementation using catamorphisms and anamorphisms :P
17:55:57 <Cale> Peaker: There was a paper and library of "pickler/unpickler combinators"
17:56:01 <gnut> tensorpudding: read awodey and mac lane and interpolate :)
17:56:07 <Cale> Peaker: which did just that sort of thing
17:56:07 <Peaker> Cale, when I tried it last time, I got stuck at the point where I was wondering how to specify escapers
17:56:36 <Cale> Eduard_Munteanu: There's really not a whole lot to that in the end.
17:56:48 <Peaker> Cale, Its very nice, yeah, except for: A) Requiring lots of boilerplate (though TH could probably help there)  and B) It lets you specify which data-types to pickle/unpickle easily, but it doesn't let you specify how the pickled data looks..
17:57:00 <Cale> Eduard_Munteanu: It's just a fancy way of saying that you can write the factorial by making a list of numbers to multiply and then multiplying them :)
17:57:06 <Peaker> Cale, You can specify how to P/U a [[String]] with it, but not how to access the CSV format
17:57:12 <Cale> Eduard_Munteanu: I guess the fancy terminology can be imposing
17:57:35 <IceDane> @hoogle uniq
17:57:36 <lambdabot> Language.Haskell.TH.Syntax type Uniq = Int
17:57:36 <lambdabot> module Data.Unique
17:57:36 <lambdabot> Data.Unique data Unique
17:57:37 <Cale> Peaker: ah, hmm
17:57:38 <Eduard_Munteanu> Cale, yeah, but certainly turns it in a way bigger code.
17:57:40 <Peaker> At least that's the impression I got. Though maybe I should toy with it to see if it can be made to do that and if TH can automate the boilerplate
17:57:52 <tensorpudding> gnut: that's what i'm doing
17:58:01 <tensorpudding> gnut: though they cover different material it seems
17:58:29 <Cale> Eduard_Munteanu: Well, not *that* much bigger, though I guess if you wanted to write a cata / ana which was polymorphic in the structure type, that's hard to do in Haskell
17:58:30 <tensorpudding> slightly different so far
17:58:35 <Eduard_Munteanu> I mean the example from "The Evolution of a Haskell Programmer"
17:58:44 <Cale> Eduard_Munteanu: If you do it just for list, it's just writing unfold and foldr
17:58:50 <Eduard_Munteanu> Cale, yeah.
17:58:53 <tensorpudding> mac lane is so dense
17:59:10 <eldragon> can category theory simplify the function factoring a natural? hehehehe, it's hard (:
17:59:33 <Cale> eldragon: It can give you some interesting ways to look at that.
17:59:35 <Eduard_Munteanu> See last example from this... http://www.willamette.edu/~fruehr/haskell/evolution.html :)
18:00:00 <Cale> eldragon: Like, there's a category of natural numbers whose arrows are the divisibility relations.
18:00:28 <gnut> tensorpudding: yeah. it's slower reading.
18:01:08 <tensorpudding> well, it's reads like a grad math textbook
18:01:13 <tensorpudding> because that is what it is
18:01:14 <gnut> is there a way to build a shared object that calls another function that's not yet defined in that shared object?
18:01:16 <eldragon> Cale, i don't know how the cloud of arrows does miscomputation or inefficient computation.
18:02:10 <FunctorSalad> Eduard_Munteanu: actually I thought factorial was the basic example for paramorphisms
18:02:15 <Cale> eldragon: Well, I guess that's not directly related to computation.
18:02:44 <FunctorSalad> btw I can autogenerate catas and anas for GADTs now :)
18:03:36 <FunctorSalad> does anyone have an example of a complicated family of GADTs handy as a test case?
18:05:04 <Peaker> those evolution examples are pretty crazy.. I liked the in/out phi/psi points-free combinators
18:05:07 <Peaker> (For Mu)
18:05:29 <Peaker> its funny how the more advanced the solution is, the slower its probably going to be (except the last one)
18:05:48 <Peaker> gnut, sure, it just needs to be available at dynamic load time
18:05:58 <Peaker> gnut, or the dlopen will fail
18:06:16 <Cale> FunctorSalad: How are you doing it? Template Haskell?
18:06:48 <Cale> FunctorSalad: I would really like to see a syntax for cata/ana which mimicked the syntax of case
18:06:51 <Peaker> Why do you need anas, btw? Aren't the constructors themselves the anas?
18:07:03 <Cale> Peaker: not quite, ana is recursive
18:07:04 <Peaker> or, what would be the ana of Maybe, for example?
18:07:12 <Peaker> is ana of list the unfoldr?
18:07:15 <Cale> yeah
18:07:18 <Peaker> ah
18:07:37 <FunctorSalad> Cale: TH doesn't support GADTs :) so I'm generating haskell-src-exts AST
18:07:43 <Cale> ah
18:08:16 <Peaker> s/:)/:( ?
18:08:48 <Cale> FunctorSalad: actually, even without support for GADTs, quasiquoter support for such a thing would be pretty cool
18:09:14 <gnut> Peaker: any hints? :) I'm writing some code to call function f, which is not defined, and so it says not in scope... I want to compile this as a shared object so that although f is not defined when the .so is built, it will be linked to other code which must implement f.
18:09:22 <FunctorSalad> here's a ridiculously artificial example input... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12129#a12129
18:09:31 <FunctorSalad> but real-world input would probably make it more understandable
18:09:40 <Peaker> gnut, in C, you need the function to be prototype'd, and you need it available at link time (which is when you load the shared object)
18:09:54 <Peaker> gnut, You can place a prototype of the function in some header file
18:10:01 <Peaker> gnut, that represents the Haskell code (iiuc) and #include that
18:10:17 <Cale> FunctorSalad: haha, wow
18:10:51 <FunctorSalad> "PF" is the pattern functor
18:11:02 <FunctorSalad> Φ plays the same role as in multirec
18:11:07 <FunctorSalad> (defines the family)
18:11:30 <gnut> Peaker: what about in haskell? my .so is written in haskell.
18:11:31 <Cale> FunctorSalad: How does it look for, say, a simple SK-calculus term language, or typed lambda calculus?
18:12:04 <Cale> (steal the one from http://www.haskell.org/haskellwiki/GADT maybe)
18:12:07 <Peaker> gnut, I don't know about Haskell shared object code.. Maybe you just need to import the function from a module that exports it via FFI?
18:12:09 <gnut> Peaker: although I can use extern to define a prototype for my haskell function, to call haskell from C, I would need a _stub.h, and that doesn't exist...
18:12:12 <Peaker> gnut, I'm not sure
18:12:21 <FunctorSalad> Cale: I'll try
18:12:32 <gnut> okay.
18:12:48 <Peaker> gnut, You can write your own _stub.h to export Haskell to C, I suppose, and perhaps writing FFI imports is the opposite
18:13:04 <Peaker> gnut, I have done only a bit of FFI, its just a guess
18:13:23 <gnut> okay. thanks for your suggestions. let me see what I can do.
18:15:15 <eldragon> did anybody get the idea of training the reduction strategy of (lambda calculus, combinatory logic, whatever) with machine learning for picking the order evaluation (applicative, normal, whatever between shallow and deep) for the nearly optimal shortest reduction way to its sooner termination?
18:15:57 <Cale> eldragon: It would be interesting to have some statistical information about that
18:20:02 <EvanCarroll> how do you see all typeclasses something belongs too?
18:20:10 <Cale> EvanCarroll: :info Foo
18:20:31 <Cale> EvanCarroll: but of course, you need to have loaded all the modules containing the instances
18:23:55 <FunctorSalad> Cale: hmm for SKK the reachability information becomes trivial, since the App constructor of SKK makes any type reachable from any type http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12130#a12130
18:25:06 <Draconx> isn't SKK just the identity function? :P
18:26:04 <FunctorSalad> here's an example (untyped lambdacalculus with type-level bruijn) where the reachability information is important http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12131#a12131
18:26:06 <zygoloid> @type ap const const
18:26:08 <lambdabot> forall b. b -> b
18:26:14 <zygoloid> looks like
18:26:46 <FunctorSalad> (if you want to show a `Term a', your show function needs no know that it will only have to recurse on a Maybe-tower over `a')
18:27:31 <FunctorSalad> Draconx: yes
18:27:36 <FunctorSalad> I meant SKI-calculus ;)
18:28:22 <gnut> can you link code that's partially dependent on dynamic code, and static code for the rest?
18:44:13 <gnut> cool.. I got it to work!
18:50:43 <ijnek> is there any faster alternative for Image widget in gtk2hs?
18:52:41 <programble> can someone tell me where to download lambdabot ?
18:53:19 <wdonnelly> @hackage lambdabot
18:53:20 <lambdabot> http://hackage.haskell.org/package/lambdabot
18:54:14 <JohnnyL> > a = 1
18:54:15 <lambdabot>   <no location info>: parse error on input `='
18:54:21 <JohnnyL> > let a = 1
18:54:23 <lambdabot>   not an expression: `let a = 1'
18:54:38 <programble> ty wdonnelly
18:55:18 <wdonnelly> programble: no problem, good luck building the package
18:55:36 <programble> lol, not cooperative?
18:56:12 <wdonnelly> it wasn't last time I tried to get it working, but that was a while ago, and I think some of it was my fault
18:56:28 <programble> not even a README to tell me how... :(
18:56:49 <programble> i assume i try to build lambdabot.hs?
18:56:58 <wdonnelly> it's cabalized
18:57:14 <wdonnelly> so running 'cabal install lambdabot' should download, build, and install it for you
18:57:24 <programble> cabal doesnt exist
18:57:58 <wdonnelly> if you already downloaded the source, it'd be 'runhaskell Setup.hs configure --user && runhaskell Setup.hs build && runhaskell Setup.hs install --user'
18:58:18 <programble> ok ty
18:58:36 * programble doesn't have the dependencies
18:58:40 <wdonnelly> (although I really advise you to install cabal-install, because lambdabot seems to have a fairly hefty dependency list to install by hand)
18:59:08 <wdonnelly> what platform are you running?
18:59:16 <programble> im telling you, cabal doesnt exist
18:59:22 <programble> Ubuntu
18:59:30 <wdonnelly> hmm
19:00:01 <programble> Ubuntu has literally never heard of cabal
19:00:07 <wdonnelly> yeah, cabal isn't packaged for ubuntu yet
19:00:21 <wdonnelly> there's a pretty good guide to building it...
19:00:25 <wdonnelly> http://sporkcode.wordpress.com/2009/07/05/haskell-cabal-in-ubuntu/ <- here
19:00:35 <programble> ugh i cant be bothered just for a stupid bot
19:01:02 <ygd-coder> what does | do outside of a list comprehension?
19:01:14 <wdonnelly> guards?
19:01:25 <ygd-coder> oh yeah
19:01:27 <ygd-coder> i forgot that
19:01:30 <ygd-coder> thanks
19:01:41 <wdonnelly> no problem
19:02:13 * programble thinks it would be easier to write an IRC bot in python which simply pipes back and forth from the GHCi
19:02:21 <programble> thats kinda blasphemous though
19:02:38 <wdonnelly> hey, whatever gets the job done easiest ;)
19:03:03 <ygd-coder> that's actually a pretty good idea
19:03:10 <programble> i want it just to show off my cool haskell stuff in IRC =P
19:03:20 <ygd-coder> but doesn't lambdabot have some of that functionality?
19:03:32 <ygd-coder> > [1..4]
19:03:33 <lambdabot>   [1,2,3,4]
19:03:33 <programble> ygd-coder: thats why i wanted lambdabot
19:03:52 <ygd-coder> ? didn't you just say you wanted to use a python bot as a pipe to GHCi?
19:03:57 <programble> but ill have no hair left by the time i get it installed
19:04:08 <programble> ygd-coder: yes
19:04:30 <ygd-coder> programble: I'm thouroughly confused now
19:04:41 <Saizan_> installing cabal-install is a matter of running the boostrap.sh script, and then "cabal install lambdabot" should work
19:05:08 <wdonnelly> Saizan_: assuming there's no readline issues, at least
19:05:22 <programble> screw it
19:05:30 <wdonnelly> the same issue has gotten me both times I last tried to install lambdabot
19:05:39 <wdonnelly> and it's annoying because it's hardly even lambdabot's fault
19:05:52 <programble> do they not distribute binaries? (make our lives so much easier)
19:06:21 <Saizan_> wdonnelly: ah, that shouldn't be a problem on unix
19:06:26 <Saizan_> wdonnelly: or is it?
19:06:35 <wdonnelly> Saizan_: and yet somehow it is
19:06:45 <Saizan_> fun.
19:06:52 <wdonnelly> programble: there are actually ubuntu packages for the haskell platform
19:07:13 <programble> you know what...
19:07:19 <wdonnelly> which includes cabal-install
19:07:19 <programble> i was very impressed with haskell....
19:07:37 <programble> up to the point in Learn You a Haskell when you start using I/O
19:07:44 <programble> then i almost vomitted
19:08:12 <wdonnelly> hmm, I *thought* there were binary packages for ubuntu
19:08:18 <programble> lol
19:08:18 <wdonnelly> seems like a common thing to want
19:08:50 <wdonnelly> ah, now I see why there aren't
19:08:53 <wdonnelly> http://davidsiegel.org/haskell-platform-in-karmic-koala/
19:09:13 <wdonnelly> it's only seven commands to install the whole thing
19:09:15 <c_wraith> preflex: seen byorgey
19:09:15 <preflex>  byorgey was last seen on #haskell 10 hours, 6 minutes and 10 seconds ago, saying: tromp_: that's not true at all.
19:09:23 <c_wraith> preflex: seen gwern
19:09:23 <preflex>  gwern was last seen on #haskell 1 hour, 28 minutes and 55 seconds ago, saying: this is not going to end well
19:09:33 <programble> wdonnelly: im running Jaunty though
19:09:55 <wdonnelly> no issues there, it builds on both I hear
19:10:07 <wdonnelly> the instructions weren't as nicely formatted for jaunty though
19:10:43 <wdonnelly> oh, wait
19:10:51 <wdonnelly> you need a more recent compiler version on jaunty
19:10:55 <c_wraith> that appears to be a blog that's totally broken without javascript
19:10:57 <c_wraith> brilliant
19:11:23 <wdonnelly> so you'd have to add a couple of lines to your sources list to get the newer GHC
19:11:26 <c_wraith> oh, it's just that post.
19:11:28 <Saizan_> wdonnelly: what was the problem with readline btw? it builds fine here
19:11:41 <programble> scrwe it
19:11:57 <programble> if Haskell people wanted me to use their stuff, they would make it easy
19:12:10 <wdonnelly> Saizan_: it informs me that the .so for ncurses is too short
19:12:24 <wdonnelly> yet most ncurses applications seem to get along just fine with it
19:12:43 <Saizan_> wdonnelly: ah, that's the standard problem with the ghci linker and linker scripts
19:12:57 <c_wraith> the problem is that new haskell doesn't even need readline anymore.  why does it want to link against it?
19:13:04 <Saizan_> wdonnelly: if you symlink your .so to the real shared object it works
19:13:12 <wdonnelly> really? i've never seen it mentioned anywhere
19:13:15 <wdonnelly> thanks for the tip
19:13:27 <Saizan_> c_wraith: lambdabot uses it for the repl
19:13:28 <programble> so...
19:13:34 <programble> i did the most useless thing ever
19:13:45 <programble> i implemented multiplication recursively
19:13:50 <programble> using only addition
19:14:03 <Saizan_> wdonnelly: yup http://hackage.haskell.org/trac/ghc/ticket/2615
19:14:13 <c_wraith> sounds potentially slow, depending on your algorithm
19:14:54 <programble> c_wraith: boils down to x `mult` y = x + x `mult` (y-1)
19:15:00 <wdonnelly> Saizan_: thanks! I knew i couldn't be the only one affected
19:15:24 <Saizan_> np
19:15:26 <programble> c_wraith: obviously with the edge condition of multiplying by 0
19:15:48 <c_wraith> programble: sounds like a good case for foldl'
19:16:12 <programble> c_wraith: would still be just as useless
19:16:28 <c_wraith> programble:  and replicate.  There we go.  Then it would be useles, but idiomatic!
19:16:52 * programble recursively makes himself bored
19:17:34 <c_wraith> > scanr ((++) . reverse) ["one", "two", "three"]
19:17:35 <lambdabot>   []->
19:17:36 <lambdabot>    [["one","two","three"]]
19:17:36 <lambdabot>  [[]]->
19:17:36 <lambdabot>    [["one","two","three"],["one","t...
19:17:41 <c_wraith> heh, oops
19:17:48 <c_wraith> > scanr ((++) . reverse) "" ["one", "two", "three"]
19:17:49 <lambdabot>   ["enoowteerht","owteerht","eerht",""]
19:18:13 <c_wraith> ...  are there real uses for scanr?
19:18:21 <programble> isBored x = isBored x
19:18:36 <programble> oh wait lets make mutually recursive
19:19:10 <wdonnelly> > let f x = sum . replicate x in f 3 7
19:19:12 <lambdabot>   21
19:19:23 <programble> isBored x = not isHavingFun x
19:19:33 <programble> isHavingFun x = not isBored x
19:19:39 <JohnnyL> :t (&&&)
19:19:40 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
19:19:53 <c_wraith> > let f x = sum . replicate x in f -3 7
19:19:54 <lambdabot>   Ambiguous type variable `t' in the constraint:
19:19:55 <lambdabot>    `GHC.Num.Num t' arising f...
19:20:02 <c_wraith> > let f x = sum . replicate x in f (-3) 7
19:20:03 <lambdabot>   0
19:20:08 <c_wraith> new math!
19:20:18 <programble> 0_o
19:21:08 <JohnnyL> :djinn
19:21:15 <JohnnyL> >djinn
19:21:27 <monochrom> @djinn a->a
19:21:27 <lambdabot> f a = a
19:21:32 <wdonnelly> > let f x y = if x < 0 then 0 - f (-x) y else sum . replicate x $ y in f (-3) 7
19:21:33 <lambdabot>   -21
19:21:41 <c_wraith> @djinn a -> a -> Bool
19:21:41 <lambdabot> f _ _ = False
19:21:45 <programble> > let programbleIsBored = not (1 == 6)
19:21:46 <lambdabot>   not an expression: `let programbleIsBored = not (1 == 6)'
19:21:57 <programble> > let programbleIsBored = not (1 == 6) in print programbleIsBored
19:21:59 <lambdabot>   <IO ()>
19:22:02 <programble> lol
19:22:03 <programble> fail
19:22:07 <JohnnyL> @djinn (Num a)=> [a]-> bool
19:22:08 <programble> > let programbleIsBored = not (1 == 6) in show programbleIsBored
19:22:08 <lambdabot> Error: Undefined type []
19:22:09 <lambdabot>   "True"
19:22:13 <programble> =P
19:22:23 <c_wraith> @djinn doesn't handle recursive types like []
19:22:23 <lambdabot> Cannot parse command
19:22:32 <c_wraith> heh.  nor does it handle english sentences
19:23:34 <monochrom> @djinn fun
19:23:34 <lambdabot> -- f cannot be realized.
19:24:03 <c_wraith> it's a tragedy.  you can't summon fun
19:24:09 <programble> lambdabot doesnt have memory?
19:24:30 <c_wraith> @let fun = 5
19:24:31 <lambdabot>  Defined.
19:24:36 <c_wraith> > fun ^ 2
19:24:36 <lambdabot>   Ambiguous occurrence `fun'
19:24:37 <lambdabot>  It could refer to either `L.fun', defined at <l...
19:24:42 <programble> lol?
19:24:49 <monochrom> There is another fun?
19:25:00 <c_wraith> I see the problem.  lambdabot has too much fun
19:25:06 <programble> @let _ `mult` 0 = 0
19:25:06 <monochrom> hahahaha
19:25:07 <lambdabot>  Defined.
19:25:24 <programble> @let x `mult` y = x + x `mult` (y-1)
19:25:25 <lambdabot>  Defined.
19:25:35 <programble> > 6 `mult` 7
19:25:36 <lambdabot>   42
19:25:39 <programble> =D
19:25:43 <programble> there is my algorithm
19:26:07 <programble> > 99 `mult` 7
19:26:09 <lambdabot>   693
19:27:13 <programble> hrm...
19:27:17 <programble> > 0 `mult` 7
19:27:19 <lambdabot>   0
19:27:35 <programble> > :type mult
19:27:37 <lambdabot>   <no location info>: parse error on input `:'
19:27:43 <programble> how do you do that?
19:27:49 <NEEDMOAR> @type mult
19:27:51 <lambdabot> forall a t. (Num t, Num a) => a -> t -> a
19:28:15 <c_wraith> heh.  it doesn't need the same Num instance for each with that definition.  I suppose that's useful! :)
19:28:17 <programble> pfft
19:28:35 <programble> it won't work on fractional numbers
19:28:40 <Draconx> although the second argument should be a positive integer :P
19:28:43 <Draconx> er, non-negative
19:28:57 <c_wraith> nah, it just might not terminate
19:28:57 <programble> and can't handle negatives
19:29:08 <c_wraith> > .23 `mult` *5
19:29:09 <lambdabot>   <no location info>: parse error on input `.'
19:29:13 <Draconx> it'll work if the left argument is negative or fractional, as long as the right is a non-negative integer.
19:29:15 <c_wraith> > .23 `mult` .5
19:29:15 <lambdabot>   <no location info>: parse error on input `.'
19:29:20 <c_wraith> > .23 `mult` 0.5
19:29:20 <lambdabot>   <no location info>: parse error on input `.'
19:29:25 <programble> 0.
19:29:25 <c_wraith> > 0.23 `mult` 0.5
19:29:27 <lambdabot>   * Exception: stack overflow
19:29:30 <programble> lol
19:29:36 <Draconx> so this "mult" definition is not commutative :P
19:29:39 <programble> > 0.24 `mult` 5
19:29:40 <lambdabot>   1.2
19:30:07 <programble> Draconx: if say, the right arg is negative, if we switch the args...
19:30:34 <NEEDMOAR> > 1.0 `mult` 5.0
19:30:35 <lambdabot>   5.0
19:30:55 <programble> > map (mult 5) [1.1,1.2..10]
19:30:57 <lambdabot>   [* Exception: stack overflow
19:31:03 <c_wraith> it's commutative in the cases where it halts both ways. :)
19:31:06 <NEEDMOAR> > 1.0 `mult` 5.0000001
19:31:09 <lambdabot>   * Exception: stack overflow
19:31:11 <programble> > map (5 `mult`) [1.1,1.2..10]
19:31:13 <lambdabot>   [* Exception: stack overflow
19:31:16 <programble> :(
19:31:27 <programble> > map (`mult` 5) [1.1,1.2..10]
19:31:28 <lambdabot>   [5.5,6.0,6.499999999999999,6.999999999999998,7.499999999999998,7.9999999999...
19:31:31 <programble> there
19:31:36 <c_wraith> yay, fp error! :)
19:32:04 <programble> hrm...
19:32:12 <programble> we could actually make the edge condition 1
19:32:19 <shellsage> any ideas on this error?  http://haskell.pastebin.com/d7fae6c1c
19:32:34 <programble> @let x `mult` 1 = x
19:32:35 <lambdabot>  <local>:13:0:
19:32:35 <lambdabot>      Warning: Pattern match(es) are overlapped
19:32:35 <lambdabot>               I...
19:32:45 <Draconx> programble, probably easier to just define the function for Integral types only.
19:32:55 <programble> Draconx: thats how i have it
19:33:06 <dibblego> shellsage, that error message is not for that code
19:33:22 <shellsage> dibblego, oops yep sorry one sec
19:33:45 <c_wraith> @undefine
19:33:54 <shellsage> http://haskell.pastebin.com/d71e8119c
19:33:55 <c_wraith> or was it @unlet?
19:33:58 <c_wraith> @unlet
19:33:59 <lambdabot>  Defined.
19:34:07 <programble> that makes sense
19:34:07 <c_wraith> @type mult
19:34:08 <lambdabot> Not in scope: `mult'
19:34:17 <programble> @x `mult` 1 = x
19:34:18 <lambdabot> Maybe you meant: . ? @ v
19:34:25 <programble> @let x `mult` 1 = x
19:34:27 <lambdabot>  Defined.
19:34:36 <dibblego> shellsage, remove the return
19:34:42 <programble> @let x `mult` y = x + x `mult` (y-1)
19:34:43 <lambdabot>  Defined.
19:34:49 <programble> > 6 `mult` 7
19:34:50 <lambdabot>   42
19:35:01 <shellsage> dibblego, perfect thank you
19:35:05 <programble> but then multiply by 0 wont work lol
19:35:10 <programble> > 6 `mult` 0
19:35:12 <lambdabot>   * Exception: stack overflow
19:36:23 <tensorpudding> @src (+)
19:36:23 <lambdabot> Source not found. Maybe you made a typo?
19:36:36 <c_wraith> @src Int (+)
19:36:36 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
19:36:48 <c_wraith> @src (+) Int
19:36:48 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
19:36:51 <tensorpudding> @src succ
19:36:52 <lambdabot> Source not found. My pet ferret can type better than you!
19:36:56 <c_wraith> hmm.  I forgot the order it wants them in
19:37:08 <c_wraith> @src [] (>>=)
19:37:08 <copumpkin> (I# a) + (I# b) = I# (a +# b)
19:37:08 <lambdabot> xs >>= f     = concatMap f xs
19:37:28 <c_wraith> ok...  @src instance function
19:38:11 <c_wraith> @src Natural (+)
19:38:11 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
19:38:32 <c_wraith> oh, right.  @src is also hand-fed, and therefore rather limited
19:38:48 <copumpkin> yep
19:38:52 <copumpkin> @src length
19:38:53 <lambdabot> Source not found. Take a stress pill and think things over.
19:39:00 <copumpkin> that's a particularly odd omission
19:39:43 <ivanm> well, it's not that hard...
19:39:58 <ivanm> length [] = 0; length (_:xs) = succ $ length xs
19:39:59 <copumpkin> neither are lots of the things that @src knows
19:40:14 <Saizan_> ivanm: that's wrong!
19:40:22 <copumpkin> fail
19:40:26 <ivanm> Saizan_: :o why?
19:40:34 <ivanm> it might not be _the_ definition
19:40:39 <ivanm> it's _a_ definition
19:40:41 <Saizan_> it'd stack overflow on long lists
19:40:43 <copumpkin> epic fail
19:40:45 <ivanm> heh
19:40:50 <copumpkin> kthx
19:41:12 <copumpkin> it's more like genericLength on Enum
19:41:18 <ivanm> OK, s/$/$!/ ;-)
19:41:28 <Saizan_> that won't help
19:41:30 <ivanm> copumpkin: I find succ easier/nicer than 1+
19:41:34 <Saizan_> succ is already strict.
19:41:43 <ivanm> Saizan_: OK, what _is_ the definition then?
19:42:12 <dolio> Saizan_: That is, in fact, the definition, according to the report.
19:42:20 <Saizan_> "foldl' (\l _ -> l + 1) 0" is one
19:42:30 <dolio> Modulo succ vs. (1 +)
19:42:43 <Saizan_> dolio: good thing GHC didn't stick to the report on this one then :)
19:42:45 <ivanm> how is doing it with foldl' better?
19:42:57 <copumpkin> foldr is cuter, allows me to ask for the length of an infinite list with a lazy natural
19:42:59 <ivanm> > foldl' (\l _ -> l + 1) 0
19:43:01 <lambdabot>   {[]->0;[()]->1;[(),()]->2;[(),(),()]->3}
19:43:03 <Saizan_> it uses constant stack because of the tail recursion
19:43:22 <ivanm> copumpkin: yes, the one sample usage/advantage...
19:44:23 <copumpkin> moo
19:44:32 <dolio> Saizan_: Obviously the report expects compilers to figure out that that function can be transformed to use an accumulator. :)
19:44:36 <Saizan_> yeah, it makes sense to use foldr for a length you with to use that way, but length :: [a] -> Int
19:45:05 <ddarius> foldl is tail recursive too
19:45:07 * copumpkin mutters something about that being a shitty default
19:45:23 * ivanm mutters something about vegetables shouldn't be able to talk
19:45:40 <shellsage> ok 2 more errors that are related:  http://haskell.pastebin.com/d4f16c028
19:45:43 * copumpkin mutters something that will not make it into text because it is too obscene to be typed
19:46:04 <ddarius> copumpkin mutters in an untyped language.
19:46:12 <copumpkin> lol
19:46:20 <Saizan_> dolio: yeah, that was always quite funny, they don't expect compilers to deal with instance Foo (T A B C) but expect that kind of strictness analysis
19:46:48 <monochrom> covegetables are able to talk
19:47:21 <monochrom> @src genericLength
19:47:22 <lambdabot> genericLength []    = 0
19:47:22 <lambdabot> genericLength (_:l) = 1 + genericLength l
19:47:25 <doserj> shellsage: what is the type of createURI?
19:47:32 <tensorpudding> are covegetables delicious?
19:47:44 <monochrom> Use genericLength if you prefer the foldr way.
19:47:45 <shellsage> doserj, createURI :: String -> Maybe Credentials -> URI
19:48:03 <monochrom> some covegetables are not delicious.
19:48:13 <doserj> shellsage: and why are you using it in a monadic context?
19:48:22 <shellsage> doserj, the uri?
19:48:32 <Veinor> so can anybody give me an example of a Functor whose fmap isn't just fmap f (a x) = a (f x) ?
19:48:37 <Veinor> I mean I know they exist
19:48:56 <doserj> shellsage: uri <- createURI addr creds
19:48:58 <dibblego> Veinor, which Functor has that?
19:48:58 <monochrom> Who is "a"?
19:49:03 <shellsage> doserj, aren't I required to use it that way here?
19:49:08 <Veinor> the functor :D
19:49:08 <dolio> @src (->) fmap
19:49:09 <lambdabot> fmap = (.)
19:49:24 <dibblego> Veinor, it's almost the ((->) t) functor, but otherwise, I've no idea what it is
19:49:30 <Veinor> hm
19:49:35 <Veinor> maybe I'm thinking about something wrong
19:49:36 <monochrom> So you mean like for example for IO, fmap f (IO x) = IO (f x)?
19:49:39 <doserj> shellsage: no. createURI creates a URI. so let uri = createURI addr creds in ...
19:49:40 <Veinor> Yeah, that
19:49:57 <monochrom> But there is no such thing as "IO x".
19:50:07 <Veinor> hmm
19:50:16 <Veinor> I must be thinking about Functors wrong then. back to learning.
19:50:31 <monochrom> I guess this means IO is already an example you look for.
19:50:32 <copumpkin> Veinor: the Identity functor works that way
19:50:44 <dibblego> think of functor as values for f in f a -> (a -> b) -> f b
19:50:55 <copumpkin> Veinor: and Maybe/Either do on one of their constructors
19:50:57 <shellsage> doserj, ok got new errors now
19:51:53 <shellsage> doserj, nvm, resolving them
19:52:10 <Veinor> @src Maybe fmap
19:52:11 <lambdabot> fmap _ Nothing       = Nothing
19:52:11 <lambdabot> fmap f (Just a)      = Just (f a)
19:52:17 <Veinor> yeah, that's what I was thinking of.
19:52:46 <monochrom> So now what is "a"?
19:53:05 <Veinor> Just.
19:53:25 <monochrom> Alright, then "fmap _ Nothing       = Nothing" is an example.
19:53:38 <Veinor> Right, right.
19:53:47 <gio123> is there any brazilian or portugues?
19:54:26 <ivanm> is there any brazilian or portugese what?
19:55:17 <gio123> is there any brazilian or portugues person?
19:57:14 <tensorpudding> no one
19:57:18 <tensorpudding> anywhere
19:57:24 <gio123> very goof
19:57:29 <gio123> very good
20:04:23 <shapr> oi, como vai?
20:05:36 <ddarius> shapr: Are you back in Alabama?
20:06:50 <shapr> Yes!
20:07:35 <Nafai> Hey shapr!
20:07:41 <Nafai> How goes the getting into school?
20:07:56 <ddarius> shapr: What prompted that?
20:08:08 <programble> @unlet
20:08:09 <lambdabot>  Defined.
20:08:14 <ivanm> @undefine
20:08:19 <ivanm> @clear
20:08:19 <lambdabot> Messages cleared.
20:08:30 <ivanm> blah, whatever the command is
20:09:15 <shapr> ddarius: I got unhappy with Boston, my mother needs help because of health problems, I wanted to finish my degree.
20:09:54 <shapr> ddarius: I live 4.5 miles from the university.
20:10:24 <ivanm> shapr: heh, I had a friend who had the option of either going to alabama or british columbia for his PhD and chose the latter due to fewer rednecks :p
20:10:27 <programble> @let programbleSort xs = xs ++ 6
20:10:28 <lambdabot>  Defined.
20:10:35 <ivanm> wtf?
20:10:40 <copumpkin> o.O
20:10:44 <programble> > programbleSort [5,4,36,75,3,32,57,8,76,3]
20:10:46 <lambdabot>   No instance for (GHC.Num.Num [t])
20:10:46 <lambdabot>    arising from a use of `L.programbleSor...
20:10:56 <programble> wut?
20:11:04 <ivanm> programble: it doesn't typecheck
20:11:08 <ivanm> @type programbleSort
20:11:09 <lambdabot> forall m. (Num m, Monoid m) => m -> m
20:11:10 <ddarius> shapr: Why were you unhappy with Boston?
20:11:18 <ivanm> @slap Caleskell
20:11:18 * lambdabot smacks Caleskell about with a large trout
20:11:42 <shapr> ddarius: Crappy weather, painful job, didn't like the accent, never seemed to build up a social circle.
20:12:05 <ddarius> shapr: *nod*
20:12:08 <shapr> ddarius: How's the job?
20:12:23 <ddarius> shapr: Slower than usual lately.
20:12:41 <derrida> i used to live in Boston!
20:12:44 <shapr> Still in the same place?
20:12:44 <programble> @unlet
20:12:45 <lambdabot>  Defined.
20:12:56 <derrida> we could have hung out ;)
20:13:15 <shapr> derrida: Did you go to the Boston Haskell User's Group?
20:13:39 <derrida> ivanm: BC is pretty
20:13:45 <programble> @let programbleSort [] = []
20:13:46 <lambdabot>  <local>:1:0:
20:13:46 <lambdabot>      Warning: Pattern match(es) are overlapped
20:13:46 <lambdabot>               In...
20:13:52 <derrida> shapr: i did not
20:13:54 <programble> @unlet programbleSort
20:13:54 <lambdabot>   Parse error: SemiColon
20:13:58 <ivanm> derrida: wouldn't know, never been there
20:13:59 <nolrai_FG> :t msum
20:14:01 <shapr> Ah, you would have met me if you had!
20:14:01 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
20:14:03 <artagnon> I had Cale's blog bookmarked but I seem to have lost it. Does anyone remember it? The fold illustrations on the Wikipedia Fold page is from there.
20:14:07 <copumpkin> programble: maybe do that in pm or in your ghci?
20:14:08 <artagnon> Cale: Ping
20:14:15 <derrida> ivanm: the parts nearest seattle are quite nice
20:14:17 <copumpkin> analogical-machine.com
20:14:17 <nolrai_FG> @list
20:14:19 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
20:14:31 <copumpkin> I mean engine
20:14:35 <copumpkin> analogical-engine.com :)
20:14:37 <nolrai_FG> @bable
20:14:39 <lambdabot>   bzzt.
20:14:41 <nolrai_FG> @bable
20:14:42 <derrida> is anyone else familiar with processing?
20:14:42 <lambdabot>   bzzt.
20:14:45 <ivanm> derrida: I don't even have a clue about where Seattle is ;-)
20:14:47 <nolrai_FG> @bable bob
20:14:48 <lambdabot>   bzzt.
20:14:52 <nolrai_FG> @bable song
20:14:53 <lambdabot>   bzzt.
20:14:54 <programble> wouldnt be so bad copumpkin if lambdabot wasnt retarded
20:15:08 <derrida> s/processing/Processing
20:15:19 <copumpkin> programble: you'd still be showing 600 people your syntax errors unnecessarily :)
20:15:26 <derrida> http://processing.org/
20:15:43 <ivanm> @slap programble
20:15:44 * lambdabot decomposes programble into several parts using the Banach-Tarski theorem and reassembles them to get two copies of programble!
20:15:50 <ivanm> how dare you call lambdabot retarded!
20:15:51 <derrida> i wanted to see if haskell has something similar and if not possibly port the api
20:16:14 <monochrom> Why do I want two copies of programble. I don't zero copies.
20:16:28 <programble> agh fml everyone hates me already
20:16:29 * ddarius is going to meet shapr one day, but it will be a complete accident.
20:16:37 <programble> why do i even attempt life?
20:16:46 <shapr> ddarius: Ooh, I can barely wait!
20:16:47 <copumpkin> programble: we don't hate you :P
20:16:52 <shapr> ddarius: Will you be in Denver next weekend?
20:16:58 <FunctorSalad> lambdabot is cute
20:17:00 <derrida> programble: someday they might not :)
20:17:03 <shapr> Hm, I'm almost afraid to ask if anyone here lives in Denver.
20:17:05 <FunctorSalad> not retarded :(
20:17:06 <SamB_XP> programble: I've never even heard of you, how could I hate you?
20:17:15 <ddarius> shapr: Um... no.
20:17:15 <derrida> nyc to the fullest!
20:17:16 <monochrom> lambdabot is sacred.
20:17:18 <copumpkin> programble: we want to help you :) but not everyone needs to see every little attempt you make, unless you're actively trying to show us something
20:17:20 <programble> mixed replies
20:17:21 <sereven> derrida: only slight familiarity with processing, but hierogliphics might be closest. could browse packages on hackage too.
20:17:24 <nolrai_FG> @src msum
20:17:24 <ivanm> FunctorSalad: exactly!
20:17:25 <lambdabot> msum =  foldr mplus mzero
20:17:39 <shapr> Anyway, I'll be in Denver next weekend...
20:17:51 <nolrai_FG> I whant to know what module it is in what comand does that?
20:18:00 <derrida> sereven: cool, i'll check that out. i'm very new to haskell so it will definitely be a challenge. :)
20:18:15 <derrida> sereven: thought it might be a fun way to get acquainted though.
20:18:40 <sereven> derrida: there's also diagrams which is simpler way into haskell graphics. might save the frp stuff till later.
20:18:57 <ivanm> anyone else here planning on going to POPL in madrid in January?
20:19:07 <programble> Raynes: OMG
20:19:12 <derrida> sereven: i basically want something that will get me a canvas i can give instructions to.
20:19:21 <Raynes> programble: Why, hello there.
20:19:21 <derrida> i'm doing all kinds of crazy visualizations
20:19:30 <nolrai_FG> @b52s
20:19:31 <lambdabot> Watch out for that piranha. There goes a narwhale. HERE COMES A BIKINI WHALE!
20:19:36 <FunctorSalad> there's graphics-drawingcombinators but lately it doesn't work for me :(
20:19:47 <programble> Raynes: just as i get your PM on DIC... then i realize your here
20:19:50 <nolrai_FG> @protontorpedo
20:19:51 <lambdabot> hey guys can haskeel be used to produce fast webapps?
20:20:08 <FunctorSalad> it's nice you can make a psychedelic self-similar thingy in one line ;)
20:20:09 <nolrai_FG> @protontorpedo
20:20:10 <lambdabot> so there is no database, monitoring system, web browser, webserver, or scheduling ssytem in haskell?
20:20:12 <monochrom> haskeal?
20:20:22 <ivanm> heh
20:20:36 <Raynes> programble: I didn't know you were a Haskell guy of any sort. (/me suggests you /join #haskell-blah (off topic channel) as well)
20:20:36 <ivanm> after all, all the cool languages have all those things!
20:20:43 <nolrai_FG> @hoogle msum
20:20:44 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
20:20:44 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
20:20:57 <ddarius> ivanm: Smalltalk probably has all those things...
20:21:10 <ivanm> ddarius: since when was smalltalk cool? ;-)
20:21:18 <ddarius> ivanm: It was cool in the 80's
20:21:26 <ivanm> fair enough
20:21:27 <Null-A> Where is haskell not very useful?
20:21:47 <monochrom> haskell is not very useful where people don't write programs.
20:22:00 <tommd> And when you must write assembly...
20:22:03 <FunctorSalad> in the desert...?
20:22:06 <derrida> lol
20:22:08 <SamB_XP> it's also a bit painful to write ASM in Haskell
20:22:10 <Null-A> assembly is one, what else?
20:22:15 <derrida> in the desert it might be good
20:22:16 <ddarius> SamB_XP: Really?
20:22:17 <SamB_XP> yeah, what tommd said ;-)
20:22:22 <derrida> you need something complicated to think about
20:22:36 <SamB_XP> ddarius: well, you can do C I guess, but assembly, again, is tricky
20:22:36 <tommd> But seriously - any time you need to control allocation or use specific ASM such as for extensions or coprocessors the Haskell compiler doesn't use.
20:22:42 <derrida> my brain is by far my favorite interpreter
20:23:03 <FunctorSalad> derrida: really? I avoid doing calculations in my brain at all costs
20:23:07 <ddarius> SamB_XP: http://uebb.cs.tu-berlin.de/harpy/
20:23:22 <Null-A> Is the memory footprint of haskell larger than C?
20:23:23 <tommd> Well, harpy is an awesome exception.
20:23:26 <derrida> FunctorSalad: ok let me revise.
20:23:42 <SamB_XP> ddarius: I'm pretty sure it mostly makes more sense to just write the stuff I'm thinking of in an actual assembler
20:23:45 <pikhq> Null-A: "It depends".
20:23:56 <ddarius> SamB_XP: Who said anything about making sense?
20:24:01 <tommd> Null-A: Typically, yes.  Also, Haskell is not useful if a compiler does not produce code for your desired target - most low-memory environments are such targets.
20:24:03 <derrida> my brain is my only interpreter when i don't have a computer.
20:24:07 <derrida> :)
20:24:09 <SamB_XP> ddarius: "useful" involves making sense, doesn't it?
20:24:10 <FunctorSalad> hehe
20:24:20 <ddarius> SamB_XP: No.
20:24:21 <pikhq> The minimum memory footprint in Haskell is larger than that of C.
20:24:22 <Null-A> *nods* tommd
20:24:38 <pikhq> However, it is much easier to waste memory in C.
20:24:40 <SamB_XP> ddarius: you don't think there's a pragmatic element to this "useful"?
20:24:47 <Null-A> Aren't there situations where you really need state mutation? e.g. string manipulation?
20:24:55 <SamB_XP> Null-A: ... noooo.
20:24:55 <pikhq> Null-A: No.
20:24:59 <tommd> Null-A: But you can do that in Haskell.
20:25:02 <SamB_XP> Null-A: even Python has immutable strings!
20:25:05 <ddarius> SamB_XP: I didn't say that.  I just denied that "useful" (necessarily) involves making sense.
20:25:16 <Null-A> Hmh
20:25:23 <pikhq> There is no mutation of state. There are only functions.
20:25:29 <pikhq> And data.
20:26:02 <Null-A> I mean obviously your mutating state when you write to disk in haskell..
20:26:09 <monochrom> Some past financial products were useful but made no sense. This is why they are now past products.
20:26:09 <Null-A> and when you read it back..
20:26:11 <pikhq> No you're not.
20:26:16 <SamB_XP> it always bugs me when lisps don't have immutable strings :-(
20:26:17 <tommd> Well.. you can have state mutation via a state monad so from the programmer stand point it is mutating.  I usually think this is what people want, not to ensure the underlying bytes of the same memory location are changing.
20:26:32 <Null-A> Not in the haskell environment, but the overall application depends on disk state mutation
20:26:34 <pikhq> You are merely applying a function from RealWorld to RealWorld. :P
20:26:58 <derrida> Fundamentally, programming is about algorithms, i try to appreciate the different ways of expressing these rather than looking at a language as being fundamentally one thing or another
20:27:15 <derrida> fundamentally.
20:27:25 <FunctorSalad> Null-A: it's the recipe for mutating the disk that's pure. obviously at some point it does interact with teh real world
20:28:04 <Null-A> So state mutation on a design sense seems necessary even for haskell developers, haskell's strength is that it isolates this?
20:28:12 <FunctorSalad> (physical models are pure too... they simply make time explicit)
20:28:26 <FunctorSalad> Null-A: yes
20:28:44 <pikhq> Null-A: Haskell lets you completelyt and utterly ignore the entire concept of "state" for 99% of your program.
20:29:03 <FunctorSalad> and the points where  you do need it are explicit
20:29:06 <Null-A> interesting
20:29:39 <pikhq> The "state" using code can often consist of, say, main = getArgs >>= yourFunction . head >>= putStrLn
20:30:05 <Cale> Well, the proportion is different from program to program, but usually it is easy to ensure that the only thing you do in the IO monad is actual I/O.
20:30:06 <nolrai_FG> I have {-# LANGUAGE ScopedTypeVariables #-} why is "(whenInOptions :: Option -> (IO ()) -> (IO ()) )" giving a parse error?
20:30:08 <EvanCarroll> why doesn't this work let foo :: (Int a) => a -> Int; foo x = 5
20:30:24 <Null-A> theoritically haskell programs could be heavily paralellized?
20:30:29 <Cale> EvanCarroll: Int is not a typeclass
20:30:32 <pikhq> EvanCarroll: Int is a type, not a typeclass.
20:30:56 <Cale> EvanCarroll: maybe you're thinking of Integral?
20:31:03 <tommd> EvanCarroll: Perhaps you ment "Integral a => a -> Int"
20:31:22 <Null-A> Why would I learn haskell over F#?
20:31:28 <Cale> Null-A: Yes, generally, though it's still not 100% trivial.
20:31:28 <pikhq> Null-A: Sure. Implicit parallelism is nigh-impossible, though, so Haskell lets you just say that something is meant to be done in parallel.
20:31:33 <tommd> EvanCarroll: But you can make this more general "a -> Int"
20:31:34 <EvanCarroll> I'm conuyea.
20:31:41 <tensorpudding> Null-A: at the very least, F# is .NET only
20:31:58 <EvanCarroll> is there a list of typeclasses?
20:31:59 <Null-A> that's okay for my purposes
20:32:03 <nolrai_FG> F# is also not pure, right?
20:32:05 <tommd> Null-A: As I understand it F# is basically Windows only, has a smaller community, and is very OCaml like in syntax and restrictions.
20:32:12 <tensorpudding> Null-A: haskell is pure, and i don't think F# is
20:32:18 <tommd> Right, purity would be the biggest issue.
20:32:20 <Cale> Null-A: Haskell doesn't have to make as many concessions to run on the .NET platform which imposes lots of restrictions on what your programming language can really look like to interface nicely with .NET.
20:32:29 <Null-A> hm, I'm not sure, they use monad's heavily I beleive
20:32:32 <monochrom> Why would you mutual-exclusively choose between F# and Haskell?
20:32:41 <Raynes> @quote Raynes
20:32:42 <lambdabot> Raynes says: F# isn't a cousin [of Haskell], it's the retarded son in law.
20:32:42 <monochrom> I mean, what a pseudoquestion.
20:33:08 <tommd> Who is Raynes, Raynes?
20:33:12 <monochrom> I propose that we classify pseudoquestion askers as trolls.
20:33:13 <Null-A> monochrom: not really, I have limited resources for learning
20:33:14 <pikhq> Null-A: ... I didn't think they had the type system for it?
20:33:18 <tensorpudding> monochrom: it looks like a question but doesn't transform like a question under rotations?
20:33:21 <Cale> They do use monads to some extent, but F# is strict and impure as well. So, if I remember correctly, they're not using a monad to describe IO actions.
20:33:26 <Raynes> I am Raynes,  Raynes.
20:33:26 <impl> since F# compiles to MSIL it has nullable types
20:33:27 <Raynes> :D
20:33:28 <impl> how do you feel about this
20:33:58 <Cale> Null-A: F# is a lot closer to the ML family of languages than it is to Haskell
20:34:04 <tensorpudding> does F# have the option for laziness?
20:34:18 <tommd> tensorpudding: Only if you don't learn it...
20:34:23 <Cale> tensorpudding: I think that's probably hard to do effectively.
20:34:30 <tensorpudding> i would imagine so
20:34:41 <monochrom> Everyone has limited resource. But if you don't state your goals, "why would I choose x over y" is still a pseudoquestion.
20:34:44 <Null-A> tensorpudding: yes
20:35:20 <derrida> what is a nice way to peruse hackage?
20:35:29 <Cale> tensorpudding: Of course, you always have the "I can do laziness, see, I'll make functions with no parameters and call them explicitly all over the place!" answer.
20:35:37 <tensorpudding> is there any signficant software apps out there written in F#?
20:35:46 <Cale> derrida: http://hackage.haskell.org/packages/archive/pkg-list.html
20:35:57 <FunctorSalad> it isn't even properly released yet, is it...
20:36:07 <Null-A> If I use F#, I would make heavy usage of the .NET libraries which make GUI design, network interaction extremely trivial. I don't know if haskell has similarly powerful libraries, or as nice developer tools..
20:36:07 <FunctorSalad> (didn't keep track)
20:36:10 <copumpkin> anyone have any haskelly google waves going?
20:36:11 <tensorpudding> it's included in VS 2009 I thought
20:36:23 <derrida> Cale: does the tree sit anywhere in the filesystem?
20:36:35 <Veinor> copumpkin: I don't like public waves, they lag like whoa.
20:36:37 <Cale> derrida: Oh, you mean the packages that you've downloaded?
20:36:49 <copumpkin> Veinor: I haven't even noticed an option to make them unpublic
20:36:50 <derrida> Cale: the ones i have not downloaded
20:36:53 <Cale> derrida: If you cabal-install things as user, then you can look inside ~/.cabal
20:36:58 <pikhq> Null-A: ... At which point you're using F# as essentially C# with a different syntax.
20:37:15 <Veinor> I guess I'll get into google wave once it's more polished.
20:37:33 <copumpkin> I'm using it as a notebook for now
20:37:34 <Null-A> pikhq: Well my end goal is to build a GUI / network intensive app
20:37:38 <copumpkin> seeing what comes of it
20:37:39 <derrida> Cale: like the bsd ports system or archlinux abs if you are familiar? (probably others and i'm ignorant :).)
20:38:12 <FunctorSalad> Null-A: GUI is a bit of a weak point, but with networking many utils are there
20:38:31 <Null-A> *nods* thx
20:38:35 <Saizan_> derrida: also, cabal list
20:38:35 <Cale> Null-A: It's pretty safe to say that if you get comfortable with Haskell, you won't be completely at sea with F# either. Haskell takes things a little bit farther as far as purity is concerned, but they have a fairly close common ancestry.
20:38:41 <pikhq> Null-A: When learning a language, don't have an "end goal".
20:38:43 <FunctorSalad> (not because "haskell can't do state or anything", I think there just hasn't been that much attention)
20:38:59 <pikhq> AT best, that makes you write some really *absurdly* bad code.
20:39:03 <FunctorSalad> we do have GTK bindings though
20:39:23 <derrida> Cale: i looked through .cabal/, doesn't seem to be what i was looking for.
20:39:28 <Null-A> I saw cocoa bindings too
20:39:32 <Cale> derrida: I don't know what you mean. I look at packages on the hackage website, and when I want one, I cabal install it. Usually the documentation is available online.
20:39:34 <derrida> Cale: stubs! thats the word i was looking for
20:39:46 <tensorpudding> Is there bindings for making windows gui applications?
20:39:53 <Cale> derrida: I think it makes a list of the packages somewhere.
20:40:08 <derrida> Cale: of all available packages?
20:40:12 <Cale> yeah
20:40:16 <derrida> cool
20:40:19 <Cale> derrida: But I can't imagine it's any nicer than just looking at that webpage.
20:40:36 <derrida> easier for me to mess with
20:40:38 <derrida> scripting
20:41:05 <tensorpudding> i wonder if they could make Haskell.NET
20:41:12 <Saizan_> Cale, derrida: all the .cabal files are tarred in ~/.cabal/packages/$repo/00-index.tar
20:41:33 <tensorpudding> or IronHaskell
20:41:40 <pikhq> tensorpudding: Theoretically possible.
20:41:41 <derrida> Saizan_: that is just what is installed though?
20:41:46 <pikhq> But what would be the point?
20:41:47 <nolrai_FG> is "msum $ mcat f x" something standard?
20:41:56 <nolrai_FG> Iron?
20:42:01 <Saizan_> derrida: and you can get the source for a particular package with cabal unpack, or you can use "cabal list" to list infos about packages
20:42:07 <Saizan_> derrida: no, the ones available
20:42:09 <pikhq> It's not like Haskell has issues with memory safety or anything, and Haskell has its own libraries...
20:42:13 <tensorpudding> well, so that you could mix and match haskell code with the .NET and JVM
20:42:21 <FunctorSalad> Null-A: but I'm not an expert with Haskell GUI libs really, don't know what's the current state :)
20:42:26 <Saizan_> derrida: it's what "cabal update" downloads
20:42:32 <derrida> Saizan_: cabal list seems to be what i want :)
20:42:38 <Cale> derrida: The cabal-install program contains code for getting a list of all available packages in a nice Haskell datatype.
20:42:40 <SamB_XP> pikhq: there are a lot more libraries for Java than for Haskell
20:42:49 <tensorpudding> I suppose there is Clojure and F# already
20:42:50 <Null-A> FunctorSalad: *nods*, one thing that .NET made easy was GUI
20:42:57 <Cale> derrida: Frankly, I'm a bit unsure about why it's not in a separate library. :)
20:43:01 <tensorpudding> but neither of those languages are very similar to Haskell's brand of FP
20:43:07 <pikhq> SamB_XP: And there are a lot more libraries for C than there are for anything else.
20:43:09 <SamB_XP> more to the point, there are a lot of libraries for Java that are actually useful and that deal with things we could really use Haskell libraries for too
20:43:13 <derrida> Cale: :)
20:43:29 <SamB_XP> and some of these libraries really aren't as moronic as you'd expect
20:43:54 <tensorpudding> There is a strong desire to use Java, and having it connect to the JVM is a big win for those people
20:44:13 <SamB_XP> tensorpudding: do you speak of JNI ?
20:44:21 <FunctorSalad> SamB_XP: assimilate! :o
20:44:22 <Saizan_> Cale: you reminded me i should work on splitting an hackage-client lib out of cabal-install code :)
20:44:28 <derrida> I've seen some very nice java code
20:44:46 <derrida> it's just not what most people do :)
20:44:49 <SamB_XP> FunctorSalad: yes, I believe that was the thing I was indicating would be nice to be able to do!
20:44:51 <Cale> Null-A: For simple GUI stuff, I've found that it's nice to use Glade to put something together, and then use Gtk2Hs, which makes it relatively simple to load up an interface designed in Glade and hook up functionality to the various controls.
20:45:11 <tensorpudding> I don't know that acronym
20:45:15 <SamB_XP> Cale: isn't Glade like the VB of GTK ?
20:45:38 <Null-A> Cale: Yeah that looks like a nice way to do it
20:45:38 <tensorpudding> Glade is kinda lame
20:45:48 <Cale> SamB_XP: Yes, somewhat. Except that it just designs interfaces and stores descriptions of them into files which you load into your program.
20:45:50 <tensorpudding> but it does make GUI's a lot easier
20:45:51 <SamB_XP> only I think VB's .FRM files are perhaps easier to edit ;-P
20:45:53 <derrida> What is the absolute thinnest layer one can add to get a coordinate graphing / pixel drawing system?
20:46:05 <Cale> Yeah, this is an XML format :P
20:46:21 <SamB_XP> yeah, VB's .FRMs were/are plain text
20:46:28 <tensorpudding> XML = xxxxtreme markup language
20:46:30 <SamB_XP> none of those superfluous closing tags ;-P
20:46:37 <Cale> Glade is also generally nicer than VB in that you don't give controls absolute positioning
20:46:41 <SamB_XP> I guess they've moved on now, though
20:46:48 <SamB_XP> Cale: yes, there is that one advantage
20:47:03 <kohwj> hi :)
20:47:10 <FunctorSalad> how about a fuzzy GUI where the widgets communicate via simulated neurotransmitters?
20:47:15 <monochrom> I know people who love absolute positioning.
20:47:20 <SamB_XP> which is what comes of using GTK instead of win32's widget "framework"
20:47:26 <tensorpudding> some people love absolute truths
20:47:26 <derrida> FunctorSalad: i like it.
20:47:28 <Cale> Well, you *can* do absolute positioning.
20:47:31 <SamB_XP> monochrom: you *can* do it in GTK
20:47:40 <FunctorSalad> derrida: in OpenGL ^^
20:47:41 <SamB_XP> monochrom: you just don't have to unless you actually feel like it
20:47:52 <monochrom> I mean I look down upon them.
20:48:11 <derrida> FunctorSalad: O O
20:48:26 <SamB_XP> I sure know when I was trying to do VB, I really disliked the absolute positioning
20:48:27 <tensorpudding> how is haskell's glut bindings
20:48:34 <derrida> OpenGL is what i should probably be looking at!
20:48:44 <tensorpudding> i have an inkling of interest in using them
20:48:49 <pikhq> tensorpudding: IIRC, they're decent but not very Haskell-ish.
20:48:54 <SamB_XP> because it meant if you wanted to make your forms resizable, you needed to write all manner of boilerplate to do the resizing!
20:48:57 <FunctorSalad> derrida: yes, it's not that thick to get some 2d drawing going
20:49:08 <Cale> FunctorSalad: How about a gui where the widgets which are not directly under the mouse cursor rearrange themselves continuously in a misguided effort to be helpful?
20:49:18 <tensorpudding> but as i have no knowledge of opengl yet i'm trying to learn a bit
20:49:18 <FunctorSalad> (or basic 3d for that matter)
20:49:19 <derrida> FunctorSalad: i'll look in hackage for some bindings.
20:49:20 <pikhq> (largely consisting of statements & functions in the IO monad)
20:49:29 <SamB_XP> Cale: reminds me of some CSS I've seen
20:49:38 <derrida> i have much more knowledge of opengl than haskell :)
20:49:40 <tensorpudding> since haskell's glut docs aren't a good opengl tutorial
20:49:55 <derrida> which is why i know i enjoy haskell much more than opengl
20:50:00 <FunctorSalad> Cale: ?
20:50:07 <mwc> control.appliative rocks. now to conver this beautiful three liner into some horrible C monstrosity
20:50:17 <monochrom> haha
20:50:27 <mwc>   4 fftord [] = []
20:50:27 <mwc>   5 fftord [n] = [0..n-1]
20:50:28 <mwc>   6 fftord (n:ns) = (\i x -> n*x + i) <$> [0..n-1] <*> fftord ns
20:50:31 <monochrom> @remember mwc control.appliative rocks. now to conver this beautiful three liner into some horrible C monstrosity
20:50:31 <lambdabot> Done.
20:50:46 <derrida> opengl is .. verbose
20:51:00 <dibblego> @type join (***) -- is this in the library?
20:51:01 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
20:51:01 <mwc> derrida: ot
20:51:06 <FunctorSalad> but now you have haskle to control it =)
20:51:14 <monochrom> oh all imperative programming is verbose. almost in the definition.
20:51:15 <tensorpudding> it appears that there is no way to learn opengl without learning C
20:51:20 <jasonmay> oh man
20:51:33 <derrida> FunctorSalad: i am very excited about this :)
20:51:33 <jasonmay> how easy is matrix math in haskell?
20:51:39 <SamB_XP> tensorpudding: huh
20:51:41 <SamB_XP> that's possible!
20:51:51 <SamB_XP> but it's really not that bad an idea to learn C, is it?
20:51:51 <mwc> derrida: it's a state machine, so it looks more verbose than an OO-style API like DirectX. To use OpenGL effectively, you'll want to create your own monad with some sort of stack discipline for managing the states. Then it will be beautiful
20:51:57 <tensorpudding> i don't suppose so
20:52:06 <tensorpudding> i know enough C to make broken things
20:52:17 <SamB_XP> I mean, it's not like you're then going to be forced to write things in it.
20:52:20 <derrida> mwc: hmmm
20:52:29 <SamB_XP> tensorpudding: that's about all most people ever learn!
20:52:37 <tensorpudding> but C is so unlike what I actually want to code
20:52:44 <monochrom> interesting
20:53:10 <pikhq> C is very hard to program well in.
20:53:54 <tensorpudding> i want to code in a language that is fun to code in
20:53:58 <mwc> my biggest gripe with C at the moment is writing my own explicit stack unwinding code for error cases.
20:54:25 <tensorpudding> i don't think i can get around my lack of programming skills though
20:54:26 <derrida> until you get into that sort of stuff, C is very nice language to work in though.
20:54:29 <mwc> just a pile of boiler plate that would go away with C++ and RAII, but I know better than to go that road
20:54:42 <derrida> learning C is a must imho
20:54:43 <tensorpudding> and i don't have time to learn a million languages
20:54:50 <derrida> get started!
20:54:51 <derrida> :)
20:54:58 <tensorpudding> because programming is far outside of my area
20:55:05 <SamB_XP> tensorpudding: oh?
20:55:10 <tensorpudding> i'm a math student
20:55:17 <SamB_XP> pshh
20:55:20 <SamB_XP> not *that* far
20:55:26 <FunctorSalad> tensorpudding: me too but I got very distracted with haskell :o
20:55:38 <SamB_XP> you don't need to buy into that whole "math is best when useless" crap
20:55:39 <monochrom> depends on which side of math. there is a far side, and it is very far
20:55:48 <tensorpudding> math is not useless
20:55:55 <mwc> tensorpudding: I started out as a physics/math double major. Haskell turns you into a closet CS geek
20:56:01 <tensorpudding> yes
20:56:05 <tensorpudding> that sounds like me right now
20:56:12 <FunctorSalad> I started out with CS and changed to math =)
20:56:13 <tensorpudding> actually, i'm not closeted so much
20:56:19 <FunctorSalad> but I still like haskell
20:56:24 <tensorpudding> i did convince many CS friends to dual in math
20:56:24 <SamB_XP> well, some people seem to intentionally try to work on math that they percieve as being the least useful ;-P
20:56:29 <FunctorSalad> the stuff at the CS department was more applied
20:56:30 <mwc> I wrote a 2D FEM code entirely in Haskell for my senior year :)
20:56:45 <SamB_XP> tensorpudding: better would be if you got them to duel in math!
20:56:47 <tensorpudding> this school is Java centric
20:56:52 <mwc> not an unsafe call in the whole thing, all the linear algebra wrapped into the ST monad
20:57:20 <FunctorSalad> tensorpudding: yes here too. I never heard of haskell at CS. in fact my category prof told me of it ;)
20:57:56 <koninkje_away> Hmm, Haskell turned me into a closet logic geek. I wonder if I got a bad dose or something
20:57:57 <derrida> i study architecture, read about math/philosophy/music/programming/art, hack on those things in all my spare time.
20:58:15 <SamB_XP> koninkje_away: you mean the part where you stay in the closet?
20:58:20 <IceDane> why is it that [(x, y) | x <- [0..20], y <- [20..0]] returns an empty list?
20:58:27 <SamB_XP> you're supposed to be willing to *admit* these things
20:58:32 <FunctorSalad> > [20..0]
20:58:33 <lambdabot>   []
20:58:37 <SamB_XP> that's the way the formula is *supposed* to work
20:58:42 <FunctorSalad> something × 0 = 0
20:58:53 <IceDane> so I take it [20..0] doesn't work?
20:58:56 <derrida> mwc: so, do you have any suggestions on where to begin with this opengl stack?
20:59:06 <FunctorSalad> > [20,19,..]
20:59:06 <lambdabot>   <no location info>: parse error on input `..'
20:59:09 <FunctorSalad> > [20,19..]
20:59:11 <lambdabot>   [20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,...
20:59:12 <IceDane> ah
20:59:12 <IceDane> yeah
20:59:17 <IceDane> thanks =)
20:59:21 <koninkje> SamB_XP: more the part where it took me away from CS geekdom
20:59:49 <SamB_XP> koninkje: that's just because the CS guys are insufficiently geeky ;-P
21:00:07 <SamB_XP> they might catch up eventually
21:00:17 <koninkje> (and when I say "logic", I mean type theory, category theory, and the like. Classical logic still annoys me)
21:00:21 <FunctorSalad> SamB_XP: hmm IIRC hardy was proud of useless math
21:00:28 <FunctorSalad> but I don't agree much with that sentiment
21:00:35 <SamB_XP> FunctorSalad: indeed!
21:00:36 <FunctorSalad> ideally I'd like something that's both nice and useful
21:01:03 <SamB_XP> also, those who continue to pursue it will continue to be chased by people with applications ;-P
21:01:15 <FunctorSalad> I think he was worrying about applications in war though
21:01:18 <FunctorSalad> (IIRC)
21:01:34 <SamB_XP> ah, well, obviously it's nicer not to have those
21:01:39 <EvanCarroll> what function uppercases ?
21:01:40 <SamB_XP> all other things equal
21:02:04 <Cale> :t toUpper
21:02:05 <lambdabot> Char -> Char
21:02:09 <Cale> :t map toUpper
21:02:10 <lambdabot> [Char] -> [Char]
21:02:23 <mwc> derrida: well, with opengl, there are basically two matrices to concern yourself with, project and modelview. projection is generally set at the top of your render loop (you won't change it unless you're writing a portal engine). The modelview matrix is used to translate the camera's view position and then to translate model geometry. So as you walk down your object, have something like renderObj :: GL () which will recu
21:02:39 <mwc> this is for immediate mode rendering
21:03:15 <mwc> similar considerations apply to retained mode, but you'll need to prerender geometry using a similar approach. Keeping track of these display lists is a good application for some monadic state
21:03:29 <mwc> I'd check the openGL bindings which already exist for haskell and see how much of this is implemented for you
21:04:40 <mwc> Hmm, looks like almost none
21:04:40 <EvanCarroll> Cale: says not in scope
21:04:45 <EvanCarroll> Cale: do i have to load something?
21:05:59 <Cale> ah, Data.Char
21:06:08 <Cale> @hoogle toUpper
21:06:08 <lambdabot> Data.Char toUpper :: Char -> Char
21:06:24 <Cale> @hoogle Char -> Char
21:06:25 <lambdabot> Data.Char toLower :: Char -> Char
21:06:25 <lambdabot> Data.Char toTitle :: Char -> Char
21:06:25 <lambdabot> Data.Char toUpper :: Char -> Char
21:10:29 <EvanCarroll> I juts need to bugger off, until i get the basics.
21:11:07 <EvanCarroll> I'm just trying to write things dirt simple in perl, in haskell for simple exercises, without a single idea of what the language has
21:11:13 <EvanCarroll> I assume Data.Char is some kind of module.
21:11:59 <SamB_XP> EvanCarroll: quite so
21:20:41 <EvanCarroll> is there LYAH guy here?
21:21:51 <copumpkin> BONUS
21:21:56 <copumpkin> probably asleep
21:22:10 <EvanCarroll> BONUS_: ah, I'd just like to say great tutorial.
21:22:35 <EvanCarroll> i'm liking it. i wish there was a wiki place for me to give input
21:22:57 <tommd> EvanCarroll: You can also "@tell BONUS <some message>" and lambdabot will tell him when he speaks next.
21:23:11 <EvanCarroll> nifty!
21:24:29 <EvanCarroll> @tell BONUS nice tut, quick observation you introduce a typeclass RealFloat in Syntax In Functions not previously mentioned elsewhere, and that doesn't occur on the site, google.com/search?q=site:learnyouahaskell.com%20realfloat
21:24:29 <lambdabot> Consider it noted.
21:25:54 <Apocalisp> Leave BONUS a message, for great good!
21:27:32 <ivanm> *groan*
21:35:17 <Veinor> bah, I got my twitter password phished :(
21:35:46 <dibblego> @type Infinity
21:35:48 <lambdabot> Not in scope: data constructor `Infinity'
21:36:32 <copumpkin> Veinor: how?
21:36:39 <Veinor> DM linked me to a fake twitter.
21:36:45 <ivanm> DM?
21:37:00 <Veinor> and I've had problems with twitter logging me out for no good reason.
21:37:02 <copumpkin> Veinor: lame, and it's someone you follow cause they can't DM you otherwise?
21:37:06 <Veinor> correct.
21:38:00 <Veinor> Changed the password to something random, though.
21:39:13 <dibblego> where is a floating point NaN literal?
21:39:35 <copumpkin> there isn't one
21:39:35 <Draconx> @let nan = 0/0
21:39:36 <lambdabot>  Defined.
21:39:37 <Draconx> > nan
21:39:39 <lambdabot>   NaN
21:39:44 <copumpkin> there wasn't one
21:42:08 <Veinor> copumpkin: this is why I hate twitter's locking-out thing.
21:42:19 <copumpkin> locking-out thing?
21:42:36 <copumpkin> (we should probably move to #haskell-blah btw)
21:42:58 <Veinor> heh
21:42:59 <kohwj> http://www.randomhacks.net/articles/2007/02/02/divide-infinity-by-2
21:46:02 <junmin> hello, how to input the NOT operator? http://img25.imageshack.us/img25/9203/20091113234314244x160sc.png is it ¬??
21:46:30 <Lemmih> :t not
21:46:32 <lambdabot> Bool -> Bool
21:46:35 <Lemmih> :t not False
21:46:36 <lambdabot> Bool
21:46:56 <EvanCarroll>  if let statements are just expressions, and where statements are syntactic constructs, that can an let statement be placed in a where construct?
21:47:06 <copumpkin> yeah
21:47:13 <copumpkin> @let (¬) = not
21:47:14 <lambdabot>  Defined.
21:47:21 <junmin> thanks!
21:47:31 <copumpkin> unfortunately you can't do what you want with that :(
21:47:33 <EvanCarroll> let foo :: Int -> String; foo x | j > 5 = "foo" where let j = 10 in j
21:47:38 <EvanCarroll> copumpkin: explain
21:47:51 <EvanCarroll> copumpkin: can you shouw and example of a let in a where
21:48:09 <copumpkin> > x + 1 where x = let y = 4 in y - 3
21:48:10 <lambdabot>   <no location info>: parse error on input `where'
21:48:34 <EvanCarroll> why the syntax error?
21:48:46 <dolio> > (True ¬)
21:48:47 <lambdabot>   False
21:48:57 <EvanCarroll> i got it working
21:48:58 <EvanCarroll> ;)
21:49:01 <Veinor> >  ¬ True
21:49:02 <lambdabot>   <no location info>: parse error on input `¬'
21:49:08 <Veinor> > not True
21:49:09 <lambdabot>   False
21:49:19 <copumpkin> you can't have prefix operators in haskell :/
21:49:24 <copumpkin> ¬_
21:49:37 <Veinor> why can't you just say > let  ¬ = not in  ¬ True
21:49:48 <copumpkin> because it doesn't know how to parse that
21:50:01 <ivanm> copumpkin: well, you can... - is the only prefix operator
21:50:04 <copumpkin> even if you did put (¬) there
21:50:11 <copumpkin> ivanm: not sure I'd call it an operator
21:50:14 <Veinor> > let symbol = not in symbol True
21:50:14 <lambdabot>   False
21:50:17 <ivanm> Veinor: there's an extension to have suffix operators, that's about it
21:50:19 <ivanm> copumpkin: it is
21:50:28 <ivanm> that's how the report describes it IIRC
21:50:56 <monochrom> ¬ is an infix operator
21:51:05 <monochrom> infix and binary
21:51:26 <copumpkin> well right now it's unary
21:51:43 <copumpkin> > (False ¬)
21:51:45 <lambdabot>   True
21:52:27 <monochrom> But you can't use it as ¬ False, can you?
21:52:46 <Veinor> you can use not False though :P
21:53:02 <monochrom> If you have to write (False ¬) it is still binary infix, since you have to use a section.
21:53:35 <Lemmih> > (¬) False
21:53:36 <copumpkin> basically it's a hack :P
21:53:37 <lambdabot>   True
21:54:04 <copumpkin> even lambdabot agrees
21:55:58 <kmeyer> wait, we have a not operator?
21:56:18 <monochrom> "we have an operator not" :)
21:57:07 <dolio> > let x ¬¬¬~!¬ y = x + y in 5 ¬¬¬~!¬ 6
21:57:08 <lambdabot>   11
21:57:22 <copumpkin> lol
21:57:33 <dolio> > let x --¬¬¬~!¬ y = x + y in 5 --¬¬¬~!¬ 6 -- even better
21:57:35 <lambdabot>   11
21:57:52 <monochrom> ¬_¬
21:58:55 <Veinor> we have an operator..... NOT!
21:59:06 <monochrom> yeah :)
21:59:55 <dolio> @let t = 2
21:59:56 <lambdabot>  Defined.
22:00:07 <dolio> @let defaul t = t + 2
22:00:08 <lambdabot>  Defined.
22:00:16 <dolio> > L.default
22:00:17 <lambdabot>   Not in scope: `L.default'
22:00:23 <copumpkin> lol
22:01:03 <dolio> > L.defaul t
22:01:04 <lambdabot>   Ambiguous occurrence `t'
22:01:04 <lambdabot>  It could refer to either `L.t', defined at <local...
22:01:23 <dolio> @undef
22:08:08 <iaefai> "Because, depressingly, state-of-the-art in programming languages hasn't moved much in those 41 years."   A guy compares Algol 68 to 'Go', but that statements sounds like not admitting to any of the haskell.
22:08:43 <c_wraith> most people don't know about haskell
22:08:54 <c_wraith> or they're told about it and say "sounds too esoteric to be useful"
22:09:13 <c_wraith> It's only taken me several months, but I no longer see why anyone thinks it's hard to understand. :)
22:09:22 <iaefai> I should probably talk about the link: http://lua-users.org/lists/lua-l/2009-11/msg00576.html
22:09:22 <luite> most people don't know about algol 68 either :p
22:09:25 <c_wraith> like...  8 months
22:09:49 <c_wraith> lua is a very well-designed language for its niche.  I do have to give it credit.
22:10:18 <iaefai> A friend who has criticized it became more interested today after he saw the function type specification looking exactly like set theory as described in his princeton published math book.
22:11:57 <iaefai> I have wondered why we haven't seen partial function application 'imported' into some of the more 'mainstream' languages like C# or Python. Python at least has list comprehensions and some others, C# is getting STM, etc.
22:12:17 <c_wraith> python has partial function application!  But only under very special circumstances. :)
22:12:20 <dolio> Non-strict evaluation? Bah, algol had that!
22:12:43 <c_wraith> In particular, you can bind self to a function.  And that's it.  :)
22:13:04 <iaefai> Would it really be hard to support partial function application in those languages?
22:13:21 <c_wraith> Actually, it's sort of unclear how it would work in a language with named parameters, like python.
22:13:27 <c_wraith> The type would become a horrible mess
22:13:57 <eldragon> you don't Go when you've Sather
22:14:07 <EvanCarroll> STM?
22:14:24 <iaefai> EvanCarroll: Software Transactional Memory
22:14:30 <eldragon> Go hasn't GC, Sather has it.
22:14:40 <dolio> Go has GC.
22:14:48 <eldragon> Go is green, Sather is rock.
22:15:06 <eldragon> dolio, GCC's Go hasn't GC.
22:15:07 <c_wraith> STM in a language without provable purity of functions is tricky, to say the least.
22:15:38 <pikhq> eldragon: ... Then the Go frontend for GCC is obviously not useful for much any Go code.
22:16:08 <pikhq> I mean, god -- not having GC in a language that assumes it? I haven't a clue how that works.
22:16:28 <EvanCarroll> >  let × :: (Integral a) :: a -> a -> a; × a b = a * b
22:16:29 <lambdabot>   <no location info>: parse error on input `×'
22:16:33 <eldragon> the performance of unmodified archaic Sather is going superior daily as the GCC is evolving.
22:16:33 <EvanCarroll> why doesn't that work?
22:16:50 <EvanCarroll> >  let × :: (Integral a) => a -> a -> a; × a b = a * b
22:16:52 <lambdabot>   <no location info>: parse error on input `×'
22:16:54 <c_wraith> EvanCarroll: It's malformed
22:16:57 <eldragon> GCC is the backend of Sather
22:16:59 <iaefai> What precisely is the difference between coq and agda?
22:17:16 <dolio> × is an infix operator character.
22:17:34 <EvanCarroll> I can't define × to be a multiplication operator?
22:17:42 <pikhq> EvanCarroll: Sure you can.
22:17:49 <dolio> You can if you make it infix.
22:17:52 <c_wraith> EvanCarroll: the type should be specified as (Integral a) => a -> a -> a
22:17:54 <pikhq> It's just a function name that must be infix.
22:18:15 <EvanCarroll> how do i it, i just c_wraith I tried that.
22:18:28 <EvanCarroll> >  let × :: (Integral a) => a -> a -> a; × a b = a * b
22:18:29 <lambdabot>   <no location info>: parse error on input `×'
22:18:44 <pikhq> > let × :: (Integral a) => a -> a -> a; a × b = a * b
22:18:45 <c_wraith> You also need to listen to what everyone else is telling you
22:18:46 <lambdabot>   <no location info>: parse error on input `×'
22:18:56 <pikhq> > let × :: (Integral a) => a -> a -> a; a × b = a * b in 1 × 2
22:18:57 <lambdabot>   <no location info>: parse error on input `×'
22:18:58 <pikhq> Erm.
22:19:02 <pikhq> > let (×) :: (Integral a) => a -> a -> a; a × b = a * b in 1 × 2
22:19:04 <lambdabot>   2
22:19:12 <pikhq> Equivalently:
22:19:25 <pikhq> > let (×) :: (Integral a) => a -> a -> a; (×) = a * b in 1 × 2
22:19:26 <lambdabot>   Couldn't match expected type `a -> a -> a'
22:19:27 <lambdabot>         against inferred type `S...
22:19:35 <pikhq> ... Thinko.
22:19:40 <pikhq> > let (×) :: (Integral a) => a -> a -> a; (×) = (*) in 1 × 2
22:19:41 <lambdabot>   2
22:20:15 <EvanCarroll> i'm confused now
22:20:22 <EvanCarroll> ah
22:20:30 <EvanCarroll> something special about operators?
22:20:40 <c_wraith> They have different syntax
22:20:46 <EvanCarroll> this i didn not know
22:20:59 <pikhq> Alphanumeric function names are prefix. Symbolic function names are infix.
22:21:05 <EvanCarroll> so could you define a function name × and call it (× a b)
22:21:11 <pikhq> No.
22:21:14 <c_wraith> :t + --- syntax error
22:21:16 <lambdabot> parse error on input `+'
22:21:22 <c_wraith> :t (+) -- just fine
22:21:23 <lambdabot> forall a. (Num a) => a -> a -> a
22:21:24 <pikhq> However, you could define a function named × and call it ((x) a b)
22:21:42 <EvanCarroll> interesting
22:22:16 <EvanCarroll> so could you make * + using the same method (+) = (*) ?
22:22:59 <pikhq> > let (+) = (*) in 3 + 4
22:23:00 <c_wraith> > let (+) = (*) in 5 + 7
22:23:00 <lambdabot>   12
22:23:01 <lambdabot>   35
22:23:04 <pikhq> Yes.
22:23:16 <EvanCarroll> =/ cool
22:23:27 <c_wraith> It's useful to turn on the compiler flag that warns you about shadowing, so you don't do stuff like that accidently
22:23:54 <EvanCarroll> then you avoid the learning experience of having done it
22:23:56 <EvanCarroll> that's no fun.
22:24:08 <c_wraith> for some definitions of fun.  :)
22:24:13 <pikhq> But, but let 2 + 2 = 5 in 2 + 2!
22:24:53 <c_wraith> > let (+) = const . const $ 5 in 37 + 54
22:24:54 <lambdabot>   5
22:25:10 <dolio> iaefai: There are a lot of differences between Coq and Agda.
22:25:22 <dolio> It'd be difficult to list them all.
22:25:37 <iaefai> dolio: Can it be summarized, like what each are meant for?
22:25:49 <koninkje> dibblego: You may want to look into the Transfinite class in the logfloat package
22:26:14 <dolio> Well, I suppose you could say Coq is more focused on theorem proving, whereas Agda is focused toward being a usable programming language.
22:26:30 <dolio> But you could do both in both.
22:28:22 <dolio> Coq has a much larger community, too, some of which works on the actual-programming-in-coq end, so there's probably a smaller gap on that end than on the convenient theorem proving end.
22:29:02 <dolio> I'm pretty sure it's been around a lot longer, too.
22:29:08 <iaefai> I hear about Coq occasionally and somebody mentioned agda a few days ago.
22:29:51 <sohum> pikhq: you can do that
22:29:58 <sohum> > let 2 + 2 = 5 in 2 + 2
22:29:58 <lambdabot>   5
22:30:28 <sohum> or wait, were you being sarcastic?
22:31:36 <c_wraith> preflex: seen gwern
22:31:36 <preflex>  gwern was last seen on #haskell 4 hours, 51 minutes and 8 seconds ago, saying: this is not going to end well
22:31:44 <c_wraith> preflex: seen byorgey
22:31:44 <preflex>  byorgey was last seen on #haskell 13 hours, 28 minutes and 40 seconds ago, saying: tromp_: that's not true at all.
22:33:36 <jfredett> someone shout when they get the HWN
22:33:48 <c_wraith> Haskell Whenever News?
22:33:59 <jfredett> something weid has been happening with email exiting my network...
22:34:02 <jfredett> weird even.
22:34:22 <jfredett> c_wraith: hey- I got it out on time! (mostly, it's up on sequence...)
22:34:34 <jfredett> today is saturday, right?
22:34:35 <ivanm> jfredett: well, I get the mailing lists digested, so I don't know when I'll get it...
22:34:39 <ivanm> jfredett: all day!
22:34:43 <c_wraith> it's strill friday in my timezone!
22:34:52 <ivanm> c_wraith: yes, but who cares about you? :p
22:34:53 <c_wraith> "strill"?  how odd.
22:34:55 <jfredett> c_wraith: so I'm early then, phsaw!
22:35:08 <jfredett> ivanm: when are you going to release more packages?
22:35:22 <jfredett> HWN is anemic w/o your steady deluge...
22:35:37 <ivanm> jfredett: *sigh* I was too smart for myself... I used cabal-1.8 for sourcegraph already
22:35:44 <ivanm> so I can't release it until that comes out
22:35:49 <jfredett> ahhh.
22:35:54 <c_wraith> I feel like uu-parsinglib provides the tools to do what I want to do...  But it's an intelligence test to figure out how to combine them.
22:35:59 <ivanm> jfredett: not that it's anywhere close to being ready to release though ;-)
22:36:10 <jfredett> ivanm: so there's a bit of a dam built... and I'll get them all at once...
22:36:16 <ivanm> jfredett: I'll make a blog post about my paper being accepted so you can mention me in that sense next week :p
22:36:23 <ivanm> jfredett: well, all 3...
22:36:28 <jfredett> nifty!
22:38:04 <jfredett> I actually thought of something I'm going to bake into the new HWN tools, I call it the "IvanM parameter" -- basically, any post tagged with "ANN" or similar will be automatically searched for a poser-supplied "{hwn-blurb: <string>}" -- so that I get something a little nicer to edit... :)
22:38:20 <ivanm> heh
22:38:22 <jfredett> rather than having to read the post proper... :)
22:39:19 <jfredett> my goal is to put myself out of a job... I'm thinking markov chains + neural nets ought to be able to write summaries for things...
22:39:29 <ivanm> jfredett: won't really work for mailing list threads
22:39:31 <jfredett> the Editorial is the tough part...
22:39:45 <ivanm> or blog posts unless you get all planet posts
22:40:30 <jfredett> ivanm: it's going to aggregate all the ML posts and any RSS feed I throw at it. :)
22:40:49 <jfredett> first I have to get all the Email backend done though...
22:41:01 <ivanm> heh
22:41:06 <jfredett> jfredett: and that is a pain in the butt.
22:42:16 <jfredett> ... apparently I'm talking to myself now... I must be tired...
22:42:59 <jfredett> pshaw if you folks don't get HWN via email, I'll confirm it's there later...
22:43:12 <jfredett> gnite/morning/whatever the heck time it is people!
22:43:28 <ivanm> jfredett: s/tired/insane/
22:43:29 <ivanm> ;-)
22:43:48 <jfredett> ivanm: I am not insane! The voices in my head are my friends!
22:43:54 <ivanm> heh
22:43:56 <ivanm> @time jfredett
22:43:58 <lambdabot> Local time for jfredett is Sat Nov 14 03:14:20 2009
22:44:01 * jfredett dances with pink elephants.
22:44:02 <iaefai> In the history of haskell pdf, there is a statement: "We are urged to return to the mind-numbing syntax of Lisp (a language that held back the pursuit of functional programming for over a decade)."   Would anyone agree with that, and if so, why?
22:44:04 <ivanm> jfredett: anyway, got it
22:44:18 <ivanm> iaefai: ask dons, the quote is attributed to him IIRC
22:44:42 <ivanm> iaefai: my guess is because it was the first semi-functional language, but people went "uggh, parens!" and wouldn't touch it
22:44:47 <ivanm> and associated lambdas with lisp
22:44:53 <jfredett> iaefai: The syntax of lisp is atrocious and beautiful at the same time.
22:45:20 <jfredett> ivanm: it's actually 1:41 here, my system clock has never kept good time...
22:45:23 <iaefai> parenthical waste product
22:45:35 <ttmrichter> The syntax of Lisp has been, accurately, I think, described as "fingernail parings in oatmeal".
22:45:38 <ivanm> jfredett: heh
22:45:50 <ivanm> jfredett: beautiful in the sense that it is its own AST?
22:46:32 <iaefai> ttmrichter: nice
22:46:50 <jfredett> iaefai: also, lisp is not pure functional, which makes for ugly imperative things on occasion. It thus also stifles the creation of solutions like Monads et al because a programmer would never need them
22:46:56 <jfredett> he could just fall back on bad habits
22:47:17 <aavogt> is there some way to convince vim to match the parentheses (with the % command) when using a lambda:   \(Constructor x y z) ->
22:47:30 <jfredett> ivanm: yes, Lisp is beautiful because it is it's own AST, and ugly as sin because it is it's own AST
22:47:34 <aavogt> and I don't want to write  \ (C x y z)
22:47:35 <ivanm> heh
22:47:37 <jfredett> it's a walking contradiction.
22:47:46 <jfredett> well, REPLing contradiction...
22:47:50 <ttmrichter> jfredett: This is why I've always admired Lisps, but rarely liked them.
22:48:05 <ttmrichter> I liked the "un-Lisp" Dylan and I'm warming up to Clojure.
22:48:13 <ivanm> you can do cool stuff with lisp, but it's a PITA to read IMHO
22:48:14 <jfredett> ttmrichter: ibid, I love me some scheme, but only in small doses.
22:48:21 <ivanm> even just the little elisp I know...
22:48:22 <ttmrichter> In both cases, though, precisely because they break away from the "everything is wrapped in parens" syndrome.
22:48:34 <shachaf> aavogt: Yes.
22:48:39 <jfredett> ivanm: it takes some getting used to. I hate emacs to much to learn elisp
22:48:48 <sereven> aavogt: they to for me without the extra space with recent haskellmode
22:48:49 <ivanm> heh
22:48:51 <iaefai> ttmrichter: Just add { } and [ ] and you don't have everything wrapped strictly in parens
22:49:01 <jfredett> I know just enough to get through Proof General...
22:49:03 <ttmrichter> jfredett: What's wrong with emacs?  It's a great operating system whose sole downfall is the crappy editor.
22:49:12 <shachaf> aavogt: :set cpoptions+=M
22:49:20 <ivanm> @slap ttmrichter
22:49:21 * lambdabot beats up ttmrichter
22:49:21 <jfredett> ttmrichter: indeed. :)
22:49:26 <shachaf> aavogt: (See ":help %").
22:49:30 <jfredett> @slap ivanm
22:49:31 * lambdabot beats up ivanm
22:49:37 <jfredett> Vim 4 Lyfe.
22:49:37 <ivanm> @slap lambdabot
22:49:37 * lambdabot puts on her slapping gloves, and slaps lambdabot
22:49:38 <ttmrichter> If someone would make a good editor for emacs, it could tackle Linux as a hacker's OS.
22:49:45 <ivanm> *groan*
22:49:45 <dolio> Its other downfall is that it makes people repeat that crappy joke over and over.
22:49:47 <shachaf> ttmrichter: Is VIPER that bad?
22:49:56 <aavogt> shachaf: thanks
22:49:57 <ttmrichter> Not familiar with VIPER.
22:50:00 <jfredett> shachaf: I can't stand it.
22:50:02 <ivanm> emacs' problem is that it focuses too much on text stuff so that its image, document, etc. support is so poor
22:50:09 <ivanm> dolio: heh
22:50:32 <jfredett> shachaf: I tried using it, it never quite worked right, it's a bit like they took vim and gave it a lobotomy.
22:50:46 <shachaf> jfredett: Did you try vimpulse?
22:50:51 <ttmrichter> Ah.  Just looked it up.
22:50:53 <jfredett> it's a strawman so that regular emacsers can pretend they know something about the other editor... :)
22:51:07 <ttmrichter> Yeah, you see, I'm not a huge fan of vi either.
22:51:09 <c_wraith> I know :q
22:51:15 <ttmrichter> Except in a strictly text-based environment.
22:51:40 <ttmrichter> Since every computer I use has this wonderful "GUI" thing on it nowadays, vi is ... not my cuppa either.
22:51:40 * shachaf isn't about to invest enormous amounts of energy in customizing any editor whose language uses dynamic scoping.
22:51:43 <jfredett> shachaf: no- I gave up and learned enough emacs to live -- I only need it for Proof General + Isabelle...
22:52:13 <jfredett> shachaf: Someday, Yi will be stable and sensical and I'll spend some time learning it and all will be well.
22:52:32 <shachaf> Someday.
22:52:54 <jfredett> but until those pigs start flying p51s, I'm stuck with what I have...
22:53:41 <koala_man> how about gvim?
22:54:18 <jfredett> koala_man: never used it, don't plan too, I'm strictly on the CL.
22:54:27 <nolrai_FG> Is there a name for the "::" symbol?
22:54:33 <c_wraith> jfredett:  didn't you say something about sleep?
22:54:38 <jfredett> nolrai_FG: "has type" usually.
22:54:40 <koala_man> I meant ttmrichter
22:54:45 <jfredett> c_wraith: when I'm dead, evidently... :)
22:54:56 <c_wraith> jfredett:  you didn't check the zombie option?
22:54:59 <jfredett> koala_man: oh. :)
22:55:05 <jfredett> c_wraith: BRAINS...
22:55:22 <nolrai_FG> hmm
22:55:23 <shachaf> nolrai_FG: I tend to read it as "grunt".
22:55:30 <ivanm> shachaf: :/
22:55:32 <ttmrichter> koala_man: gvim is an abomination.  If you offer a "GUI" it would behoove you to conform to the standards of said GUI environment instead of forcing your users to switch between two key mappings constantly.
22:55:33 <nolrai_FG> Realy?
22:55:44 <shachaf> nolrai_FG: Or "colon colon". But then, I read "!!" as "not not"; I'm not a very good source for pronunciations.
22:55:59 <shachaf> ttmrichter: Two key mappings?
22:56:13 <nolrai_FG> I guess ColonColon it is.
22:56:15 <ivanm> shachaf: vim's and gtk's
22:56:22 <ivanm> nolrai_FG: there is no real name for it
22:56:27 <iaefai> Before monads, was there any way of making practical programs with haskell?
22:56:31 <ttmrichter> Try Ctrl+C in one window, shachaf, then Ctrl+V in gvim to see what happens.
22:56:37 <ivanm> but it means "has type" or similar
22:56:47 <ivanm> similar how >>= is pronounced "bind" ;-)
22:56:53 <jfredett> shachaf: I usually read "!!" as "pickpick" (when in haskell) otherwise as "bangbang", "**" is "kisskiss", so thusly, (**) . (!!) is "Kiss kiss bang bang".
22:56:54 <shachaf> Oh, that. Well, if you use vim, use it all the way! No point in messing with GTK bindings.
22:57:04 <shachaf> Oh, ugh.
22:57:17 <c_wraith> how should I pronounce <- in do notation?
22:57:18 <shachaf> I still read ">>=" as "bind bind equals". I know that's ridiculous.
22:57:20 <ivanm> ttmrichter: does gtk support vim keybindings?
22:57:28 <ivanm> it has limited support for emacs-style keybindings IIRC...
22:57:34 <ttmrichter> shachaf: Exactly.  If I'm in a pure CL environment, I use vim.  I do not use gvim.  Ever.
22:57:41 <jfredett> c_wraith: "yanks", eg, 'x yanks (the value of) foo"
22:57:50 <c_wraith> I like that.
22:57:52 <ivanm> shachaf: I read ">>=" as ">>=" (as in the actual symbol)
22:57:53 <IceDane> How does one define datatypes in the interpreter?
22:57:53 <c_wraith> I should use it
22:57:57 <koala_man> I read it as "much greater than or equal"
22:57:58 <shachaf> ttmrichter: It sometimes has better support for color schemes, or clipboards, or something. But I don't use it any differently from a command line editor.
22:58:00 <IceDane> data *etc* doesn't seem to work
22:58:03 <ivanm> I don't read code aloud though...
22:58:05 <ivanm> ;-)
22:58:08 <ivanm> IceDane: you can't
22:58:08 <jfredett> ivanm: one doesn't.
22:58:12 <jfredett> ooops
22:58:12 <ivanm> not in ghci and hugs though
22:58:20 <ivanm> IceDane: write them in a file, and load the file
22:58:22 <jfredett> s/ivanm/IceDane/
22:58:30 <ttmrichter> shachaf: The problem is that in a GUI environment I generally don't stick in one application only.
22:58:30 <IceDane> I see, thanks.
22:58:40 <ivanm> one of the original Haskell interpreters (HBC?) used to let you IIRC...
22:58:46 <ivanm> jfredett: heh, wondering what you were talking about...
22:59:02 <ttmrichter> Switching back and forth from modal editing with bizarre keystrokes and (relatively) standard UI structures just interferes with my work.
22:59:11 <jfredett> okay, now for sleeping, now for wrath, onward riders of Rohan, onward to the blood red dawn!
22:59:29 <ivanm> jfredett: what's that from?
22:59:38 <IceDane> LOTR?
22:59:44 <jfredett> it's a bastardization of two quotes from LotR.
22:59:52 * ivanm wonders if jfredett is noticing the "let's keep jfredett awake" conspiracy...
22:59:53 <ttmrichter> ivanm: I'd guess Lord of the Rings.
22:59:57 <jfredett> Theoden says both, iirc.
23:00:05 <jfredett> ivanm: you bastards!
23:00:05 <ivanm> eh, that explains it... I hate LoTR
23:00:11 * ivanm whistles
23:00:12 <jfredett> ivanm: BLASHPHEMY!
23:00:17 <shachaf> ttmrichter: Aw, vim isn't modal.
23:00:25 <ivanm> which is weird since I'm a big fantasy/sci-fi reader
23:00:27 <IceDane> jfredett: I somehow knew you'd call blasphemy.. don't ask me how
23:00:31 * shachaf decides this probably isn't a good place to get into that.
23:00:43 <shachaf> What with this channel being so on-topic right now and all.
23:00:49 <ttmrichter> shachaf: I must be imagining the monotone symphony whenever I type things after having forgotten the all-important "i" key then.  :)
23:00:51 <jfredett> IceDane: I worship at the feet of Tolkien.
23:00:58 <ivanm> IceDane: he called "blashphemy", which indicates he's either drunk or has no teeth...
23:01:00 <c_wraith> > text "Who's Tolkien?"
23:01:01 <lambdabot>   Who's Tolkien?
23:01:03 <IceDane> I see
23:01:13 <shachaf> ttmrichter: Hm? "i" is a command, terminated by "escape". There is no "insert mode".
23:01:19 <ivanm> jfredett: have you read Raymond E Feist's books?
23:01:22 <jfredett> ivanm: shutup... its way past my bedtime...
23:01:24 <dolio> @remember JonHarrop What are the features of this languages [Go] in the context of FP?
23:01:24 <lambdabot> I will never forget.
23:01:28 <ivanm> jfredett: heh
23:01:29 <jfredett> ivanm: I don't remember...
23:01:36 <ivanm> dolio: he actually said that? :o
23:01:40 <ivanm> dolio: link?
23:02:09 <dolio> It's on comp.lang.functional. He started a new thread with just that (and an ad for his business, of course) in the post.
23:02:24 <ivanm> heh
23:02:28 <jfredett> okay, sleep time. for reals.
23:02:33 <ivanm> dolio: can anyone say "grammatically incorrect"? :p
23:02:36 <ivanm> g'night jfredett
23:02:43 <jfredett> gnite haskellers.
23:03:04 <koala_man> ttmrichter:  totally. and sometimes I forget to type "vim" first and just get a bunch of "command not found" errors for all my editing commands
23:03:16 <ttmrichter> shachaf: That is one (very creative) way around admitting it's a modal editor, I have to say.
23:03:25 <shachaf> ttmrichter: It's the only way to think of it!
23:03:35 <IceDane> If I have a type constructed, in a file and loaded, as such: data Tree a = Node (Tree a) (Tree a)\n| Empty\nderiving (Show), why isn't let myTree = Node "foo" Empty Empty working?
23:03:36 <shachaf> Come on, you can type "5i...<Esc>" to enter text five times.
23:03:38 <dolio> ivanm: I was more amused with the "do research for me" demand. :)
23:03:44 <IceDane> It's basically an example from RWH
23:03:52 <ivanm> dolio: heh
23:03:58 <shachaf> A vi-er would never be caught "leaving the editor in insert mode", because it's like not terminating a command.
23:04:02 <ttmrichter> The more conventional way of thinking about it is "i" switches into INSERT mode (which is conveniently identified at the bottom left of the screen on my implementation) and that Esc switches back to command mode.
23:04:04 <ivanm> IceDane: what's the error?
23:04:15 <IceDane> sec
23:04:24 <koala_man> ttmrichter: excel and ms word are modal editors too. you can be in cell editing mode vs sheat editing mode, or in insert mode vs replace mode
23:04:27 <IceDane> ugh
23:04:28 <IceDane> ivanm: sorry
23:04:32 <IceDane> It seems to work
23:04:38 <IceDane> I may not have loaded it before trying the last time
23:04:45 <ivanm> heh
23:04:54 <IceDane> that's what all-nighters do to you, I guess
23:06:01 <ttmrichter> koala_man, shachaf: It really doesn't matter what semantic games you try to play with this.  Nobody views, say, Word as a modal editor (except vi fans) and nobody views vi as anything but a modal editor (except vi fans).  I'm not saying vi is a bad editor.  It's my editor of choice in a pure text environment.  It just doesn't play nicely with others in a GUI environment.
23:06:07 <sereven> ttmrichter: "must use mouse" is not a mode in gtk?
23:07:23 <sereven> not that I don't use gtk apps, just always frustrating when there's no reasonable way to navigate the various widgets efficiently.
23:07:29 <IceDane> ivanm: actually, it doesn't work. I was wrong, sorry again. while let myTree = Empty Empty works, let myTree = "foo" Empty Empty doesn't, when it's clearly indicated that it should in RWH
23:07:30 <shachaf> ttmrichter: Calling it a "modal editor" is a bit of a semantic game! The editor doesn't operate in those terms (see 5i...<esc> and so on).
23:07:46 <shachaf> Anyway, I don't disagree that it's not very GTK-integrated. :-)
23:07:52 <shachaf> (Excuse the triple negative.)
23:08:01 <ivanm> IceDane: which page/chapter/whatever of RWH is this?
23:08:04 * ivanm grabs his copy
23:08:09 <IceDane> ivanm: 3.7
23:08:43 <ivanm> which heading?
23:08:46 <IceDane> ivanm: file is ch03/Tree.hs, then he uses that tree in an example further down
23:09:07 <IceDane> ivanm: Have this on .chm format, it only says 3.7 Recursive types, and then it's all one page
23:09:26 <ivanm> recursive types, got it
23:10:03 <ivanm> OK, the sample tree is:
23:10:23 <ivanm> Node "parent" (Node "left child" Empty Empty) (Node "right child" Empty Empty)
23:10:37 <IceDane> Yes.
23:10:40 <ivanm> saying "let myTree = Empty Empty" doesn't make sense
23:11:07 <IceDane> That works, though
23:11:23 <IceDane> eh
23:11:24 <IceDane> sec
23:11:35 <IceDane> no
23:11:38 <IceDane> I mean Node Empty Empty
23:11:51 <IceDane> let myTree = Node Empty Empty
23:11:51 <ivanm> IceDane: check your definition of the Tree
23:12:00 <ivanm> it should be: Node a (Tree a) (Tree a)
23:12:06 <IceDane> Oh
23:12:06 <ivanm> I'm guessing you're missing that `a' in there
23:12:10 <ivanm> ;-)
23:12:26 <BMeph> IceDane: In " data Tree a = Node (Tree a) (Tree a)", add an 'a' between Node and the first tree. :)
23:12:30 <IceDane> yeah, thanks. Seems to be a typo in my chm, directly copied
23:12:43 <ivanm> where did you get the chm from?
23:12:53 <ivanm> didn't know they made MS Help document versions of RWH...
23:13:22 <IceDane> In an alternate universe where I would have gotten a copy of this book illegally, I might have gotten it from a site called warez-bb.org
23:13:31 <ivanm> @slap IceDane
23:13:31 * lambdabot places her fist firmly on IceDane's jaw
23:13:39 <ivanm> IceDane: if all else fails, you can read it online for free
23:13:43 <IceDane> I can?
23:13:44 <IceDane> lol
23:13:49 <ivanm> @where rwh
23:13:50 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
23:13:51 <IceDane> My default mode is pirace
23:13:53 <IceDane> y
23:13:54 <IceDane> *
23:14:05 <ivanm> admittedly, the final book has a few touches not online
23:14:09 <ivanm> but even google books has it
23:14:20 <ivanm> IceDane: which isn't a good thing to admit in this channel for this book
23:14:33 <ivanm> since all three authors frequent this channel (well, not CosmicRay as much)
23:14:39 <IceDane> Heh, oops.
23:15:03 <IceDane> I guess they'll have to hunt me down through the abstractions of the internet and sue me for the couple of hundred bucks I have.
23:15:10 <IceDane> I'll buy it when I have money, probably
23:15:51 <c_wraith> I think I'm about to cause serious insanity to uu-parsinglib while I struggle with implementing a feature I feel it left out.  >_>
23:16:14 <ivanm> what?
23:16:38 <c_wraith> The ability to match eof
23:16:45 <c_wraith> ...  conditionally
23:17:16 <c_wraith> pEnd fails at the conditionally part.  Since if it matches, it eats the error list
23:23:07 <c_wraith> huh....  data .... where?  I've never seen that syntax before
23:23:34 <c_wraith> that appears to be a list of constructors and their type?
23:26:10 <aavogt> c_wraith: look up GADTs
23:26:10 <ddarius> c_wraith: That's GADT syntax.
23:41:25 <tensorpudding> i'm amused when this paper on agda refers to haskell's type system as "simple"
23:41:34 <dmwit> hahaha, http://hackage.haskell.org/packages/archive/acme-dont/1.0/doc/html/Acme-Dont.html
23:44:05 <tensorpudding> :)
23:51:56 <ivanm> dmwit: yeah, you're at least a day late ;-)
23:53:06 <dmwit> I know.
23:53:18 <tensorpudding> it's kinda annoying that haskell uses a :: Foo to denote type instead of a : Foo
23:53:18 <dmwit> I just thought it was funny that somebody thought that was useless enough to copy. =)
23:53:53 <dmwit> Personally, I find it annoying that OCaml uses a :: b to denote list prefixing rather than a : b.
23:58:04 <tensorpudding> i don't like the way :: looks
23:58:29 <ivanm> tensorpudding: what's wrong with it?
23:58:36 <ivanm> the double colon makes it stand out
23:59:21 <tensorpudding> using : for typing seems to be what most of the literature uses, only haskell uses :: that i know of
23:59:43 <ivanm> right, but we use : for list construction
23:59:55 <tensorpudding> yes, we can't use it for both
23:59:55 <junmin> cd/quit
