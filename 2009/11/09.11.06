00:00:20 <FunctorSalad_> maybe add to the topic that this is not the java channel?
00:00:22 <FunctorSalad_> ;)
00:05:54 <jinjing> bot
00:06:23 <jinjing> @bot
00:06:23 <lunabot>  :o
00:06:27 <lambdabot> :)
00:06:32 <Phyx-> how can anyone think this is the java channel?
00:12:13 * hackagebot upload: criterion 0.2.0 - Robust, reliable performance measurement and analysis (BryanOSullivan)
00:12:58 <ivanm> bos: *sigh* what did you do wrong this time?
00:12:59 <ivanm> ;-)
00:15:08 <luite> ooh a new uvector too, hopefully the Bool instance is fixed now
00:15:38 <bos> ivanm: API improvements
00:15:44 <ivanm> *nod*
00:15:54 <bos> see http://www.reddit.com/r/haskell/comments/a1jr6/criterion_02_an_improved_benchmarking_library/ for deets
00:16:41 <ivanm> so, reddit is your new announcement page rather than your blog?
00:16:55 <ivanm> why don't you just do what most people do and send an email to haskell{,-cafe}? :p
00:17:06 <ivanm> oh, you gave me a reddit link to your blog
00:17:14 <luite> hmm, it still doesn't compile with 6.12
00:17:26 <ivanm> luite: because of gtk2hs?
00:17:30 <ivanm> or even if chart is disabled?
00:19:02 <luite> no I mean uvector 0.1.0.5, a dependency of criterion, because of a change in Handle (that's System.IO.Handle I think)
00:19:18 <quicksilver> Phyx-: it comes up first in some clients when you search for "programming" or something like that.
00:25:34 <reltuk> I'm looking for a function like map but that takes multiple functions...something like [a -> b] -> [a] -> [[b]]
00:25:53 <dibblego> reltuk, zip or ap?
00:26:26 <reltuk> probably ap...
00:26:35 <dibblego> (<*>) (aka ap)
00:26:50 <dibblego> why [[b]] and not [b] ?
00:27:06 <dibblego> (s/zip/zipWith ($)
00:28:05 <reltuk> I wanted [b] but was willing to settle for something like a fold of a map
00:28:06 <c_wraith> :t concat . ap
00:28:09 <lambdabot>     Couldn't match expected type `[[a]]'
00:28:13 <lambdabot>            against inferred type `m a1 -> m b'
00:28:17 <lambdabot>     Probable cause: `ap' is applied to too few arguments
00:28:19 <reltuk> but I think ap is what I want
00:29:14 <c_wraith> :t map ap
00:29:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => [m (a -> b)] -> [m a -> m b]
00:38:14 <quicksilver> reltuk: if the lists are the same length and you want each function applied to each corresponding argument, then it's zipWith ($). if you want every function applied to every argument it's ap.
00:43:01 <reltuk> quicksilver: thanks :-)
00:44:20 <Phyx-> quicksilver: lol
00:54:31 <fasta> Why do people write software that says stuff for which only one followup action will make it continue?
00:55:22 <fasta> If there is only one thing to do, just do it.
01:20:57 <Phyx-> weee think i just lost a drive..
01:24:36 <Phyx-> spins down when plugged in, nice
01:37:12 <reltuk> has anyone ever used (flip $ foldr ($)) before?
01:38:15 <reltuk> I have a [a->a] and I want to apply them successively to an a in order to get the final value
01:38:48 <reltuk> but now I want to do the same thing but with a list of [a->Maybe a]...
01:39:09 <c_wraith> :t (<*>)
01:39:10 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
01:39:28 <c_wraith> :t foldr (<*>)
01:39:29 <opqdonut> foldr (>>=) ?
01:39:30 <lambdabot> forall (f :: * -> *) b. (Applicative f) => f b -> [f (b -> b)] -> f b
01:39:47 <opqdonut> :t foldr (>>=)
01:39:48 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
01:39:48 <lambdabot>     Probable cause: `>>=' is applied to too many arguments
01:39:48 <lambdabot>     In the first argument of `foldr', namely `(>>=)'
01:39:56 <opqdonut> :t foldr (>=>)
01:39:57 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m c) -> [a -> m a] -> a -> m c
01:39:58 <opqdonut> there
01:40:13 <opqdonut> :t foldr (>=>) return
01:40:14 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
01:40:17 <opqdonut> reltuk: how's that?
01:40:32 <reltuk> opqdonut: looks perfect...
01:40:46 * reltuk boggles
01:40:47 <opqdonut> the whole result is Nothing if any of the functions in the list returns Nothing
01:40:53 <opqdonut> otherwise it's the chained operation
01:40:58 <opqdonut> this is all using the Maybe monad
01:41:06 <opqdonut> >=> is monadic . essentially
01:41:09 <reltuk> exactly what I wanted
01:41:11 <opqdonut> :t (>=>)
01:41:11 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
01:41:30 <c_wraith> actually, it's monadic flip (.)
01:41:40 <opqdonut> that, yeah
01:48:42 <Hunner> heh. someone just asked how he can delete elements from his arrays in haskell
01:48:54 <Hunner> 1. No.
01:49:00 <Hunner> 2. Lists, not arrays
01:49:11 <fasta> Hunner, ?
01:49:17 <fasta> Hunner, you can.
01:49:28 <arcatan> well, you can have mutable arrays in Haskell if you want.
01:49:32 <c_wraith> > deleteAt 3 [0..5]
01:49:34 <lambdabot>   Not in scope: `deleteAt'
01:49:39 <c_wraith> boo.  I was sure that was it.
01:49:43 <c_wraith> > delete 3 [0..5]
01:49:45 <lambdabot>   [0,1,2,4,5]
01:49:49 <fasta> Hunner, and deleting from a list is constructing a new one.
01:49:50 <c_wraith> But that's a reasonable facsimile
01:50:21 <fasta> Hunner, you can do every dirty trick that you can do in C in Haskell too.
01:50:38 <fasta> Hunner, doesn't mean that you have to, but don't say things cannot be done.
01:50:49 <luite> hm, deleteAt is in Data.Map
01:51:06 <c_wraith> :t Data.Map.deleteAt
01:51:07 <lambdabot> forall k a. Int -> M.Map k a -> M.Map k a
01:51:16 <c_wraith> Huh.  strange.
01:51:21 <luite> would make more sense for a list
01:51:27 <c_wraith> Yes, it would.
01:51:46 <c_wraith> I'm sure there's an equivalent list function, though.
01:51:49 <c_wraith> somewhere. :)
01:52:01 <reltuk> :t delete
01:52:03 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
01:53:38 <c_wraith> Yes, delete works on equality rather than index
01:53:44 <c_wraith> It's also O(n)
01:53:56 <c_wraith> Though I suppose deleting an element from an array is also O(n)
01:54:38 <fasta> c_wraith, there is no such thing as "an array" in Haskell. There are lots of different array like things.
01:54:40 <arcatan> > (\n x -> take (n-1) x ++ drop n x) 3 "abcde"
01:54:41 <lambdabot>   "abde"
01:54:59 <c_wraith> fasta:  I wasn't talking about haskell
01:55:36 <fasta> c_wraith, well, that particular problem has already been figured out a long time ago. See CLRS.
01:56:11 <fasta> Basically you get amortized O(1).
01:56:12 <arcatan> hey, an acronym book I've actually read!
01:56:19 <c_wraith> s?  What edition added a 4th author?
01:56:29 <dibblego> CLRS is not an acronym
01:56:47 <arcatan> 2nd edition
01:57:18 <fasta> http://highered.mcgraw-hill.com/sites/0070131511/
01:57:37 <c_wraith> I've got the 1st edition around somewhere.
01:57:47 <fasta> @go define CLRS
01:57:48 <lambdabot> Maybe you meant: google googleit do
01:57:53 <fasta> @google define CLRS
01:57:55 <lambdabot> http://whatis.techtarget.com/definition/0,,sid9_gci860097,00.html
01:57:55 <lambdabot> Title: What is Common Language Runtime? Definition from WhatIs.com - see also: CLR
01:58:06 <fasta> Oh, I get a different result.
01:58:17 <fasta> Anyway, it does exist.
01:58:18 <c_wraith> language setting, maybe?
01:58:31 <fasta> No, it's just because I trained Google.
01:58:47 <c_wraith> ah
01:59:38 <fasta> The website of universal truth: http://en.wikipedia.org/wiki/CLRS
02:00:42 * Baughn monadically replicates a zygohistomorphic prepromorphism
02:01:06 <c_wraith> in front of the children?
02:01:40 <Baughn> The children will just have to deal.
02:01:51 <quicksilver> dibblego: yes it is. Merriam Webster: acronym, noun, .... also : an abbreviation (as FBI) formed from initial letters.
02:02:13 <quicksilver> pedantry is annoying enough, incorrect pedantry more so.
02:02:14 <Baughn> Initialism
02:02:44 <dibblego> no it isn't
02:03:56 <c_wraith> Is there any good tool for analyzing memory use by an algorithm?
02:04:19 <Baughn> A profiler?
02:05:12 <fasta> c_wraith, in Haskell, see GHC manual.
02:05:55 <c_wraith> Hmm.  I'd like...  max actual memory use and amount of garbage collected, I think.  Does that sound right?
02:06:09 <fasta> c_wraith, Highwatermark program on Hackage.
02:06:22 <Baughn> Perhaps. You can get both of those from any ghc program with +RTS -sstderr
02:06:23 <fasta> c_wraith, oh, sorry, that's wrong.
02:07:02 <fasta> c_wraith, that is also a useful program, but you want RTS options, as Baughn says. +RTS --help, IIRC.
02:08:08 <c_wraith> I'm curious to see how successfully lazy various algorithms are.  They generate O(n!) output, but there's no need for more than O(n) memory actually being in use.
02:09:23 <c_wraith> But that's not a project for tonight.  I'll take a look at the RTS flags when I'm more awake.
02:19:14 <Phyx-> heh, linking just took nearly a minute..
02:20:21 * int-e wonders what the  Includes: sqlite3.6  line in sqlite-0.4.2 was meant to do.
02:20:46 <Phyx-> hey int-e , got that paste yesterday?
02:21:18 <int-e> yes, I did
02:21:24 <int-e> thanks
02:21:38 <Phyx-> np
02:31:20 <Phyx-> yeah :(
02:41:27 <quicksilver> @remember DanWeston Bottom has only one value, not two. Otherwise bottom would have been called buttocks.
02:41:29 <lambdabot> It is forever etched in my memory.
02:45:19 <Axman6> blackdog: you around?
02:51:40 <ivanm> hey Axman6
02:51:46 <Axman6> 'lo
02:51:47 <ivanm> he was around before...
02:51:49 <ivanm> preflex: seen blackdog
02:51:49 <preflex>  blackdog was last seen on #haskell 4 hours, 31 minutes and 7 seconds ago, saying: can you expose an IORef to an external C function?
03:00:28 <dancor> i want to have addition of triples but abs/signum wouldn't make sense for Num
03:00:32 <dancor> what should i do
03:00:54 <reltuk> > pl splitPilesAtCard card = break ((==) card . fst)
03:00:55 <lambdabot>   <no location info>: parse error on input `='
03:00:58 <ivanm> dancor: either undefined, error "not defined", or do abs for each value?
03:01:01 <Zao> Define a shiny non-+ addition operator.
03:01:01 <ivanm> @type signum
03:01:02 <lambdabot> forall a. (Num a) => a -> a
03:01:13 <ivanm> dancor: I'd be tempted to do it on a per-part basis
03:01:14 <Zao> > signum -9001
03:01:15 <lambdabot>   No instance for (GHC.Num.Num (a -> a))
03:01:15 <lambdabot>    arising from the literal `9001' a...
03:01:17 <dancor> ivanm: right..
03:01:29 <reltuk> pl \card -> break ((==) card . fst)
03:01:40 <reltuk> > pl \card -> break ((==) card . fst)
03:01:42 <lambdabot>   <no location info>: parse error on input `\'
03:01:52 <Zao> > signum (-9001)
03:01:53 <lambdabot>   -1
03:02:01 <Zao> Blargh, those silly rules about negative literals.
03:02:03 <reltuk> @pl \card -> break ((==) card . fst)
03:02:04 <lambdabot> break . (. fst) . (==)
03:04:52 <quicksilver> dancor: use another operator?
03:05:00 <quicksilver> dancor: e.g. ^+ or .+
03:05:00 <dancor> {-# LANGUAGE UndecidableNegations #-}
03:05:07 <dancor> ya i might do that
03:05:54 * Zao recalls long and harsh discussions on -cafe about whether symmetric operators should look symmetric.
03:06:10 <Zao> Surely it should be ^+^ :)
03:06:19 <dancor> -cafe-
03:07:20 <fasta> Zao, (-) is already an exception to the rule ;)
03:07:46 <quicksilver> I use ^+^ and ^*^ for vector-vector ops
03:07:51 <quicksilver> and .*^ for scalar/vector
03:08:07 <quicksilver> or maybe just *^ for scalar/vector or reflection
03:09:32 <ivanm> dancor: well, that's not an operator...
03:11:01 <dancor> i'm sure we can approximate with unicode
03:12:18 <dancor> > let (-<@/<-) = (+) in 4 -<@/<- 5
03:12:19 <lambdabot>   9
03:13:54 <zygospasm> Zao: do not try to understand the silly rules about negative literals -- that's impossible. instead, only try to realize the truth: there are no negative literals.
03:14:28 <dancor> it is merely your number line that bends
03:20:00 <porcotino> sup haskell people
03:21:38 <porcotino> will someone help me with a diferente version of maximum?
03:21:46 <dancor> i will
03:21:57 <porcotino> thank you dancor
03:22:40 <porcotino> I am making a diferente maximum in a way that if you receive an empty list, it returns 0 instead of an error
03:23:04 <dancor> @let max0 x = if null x then 0 else maximum x
03:23:05 <lambdabot>  Defined.
03:23:07 <dancor> > max0 []
03:23:09 <lambdabot>   0
03:23:12 <dancor> > max0 [4, 5]
03:23:13 <lambdabot>   5
03:23:32 <porcotino> uhm
03:23:41 <porcotino> yeah, this is what I made
03:23:52 <porcotino> so I guess it's fine :D
03:24:05 <porcotino> thanks dancor
03:24:14 <dancor> thank you
03:51:18 <knobo> I ofthen run in to this situation: head []
03:51:49 <ivanm> knobo: well, don't!
03:51:56 <ivanm> > listToMaybe [1..]
03:51:56 <lambdabot>   Just 1
03:51:58 <knobo> How do I avoid it?
03:51:58 <ivanm> > listToMaybe []
03:51:59 <lambdabot>   Nothing
03:52:09 <Lemmih> knobo: It's a good idea not to use head when it can be avoided.
03:52:15 <ivanm> knobo: make sure you never call head on an empty list, or use listToMaybe
03:52:37 <ivanm> Lemmih: well, if you know that it's a non-empty list (e.g. one of the sublists returned from group)...
03:53:05 <Lemmih> ivanm: It's still bad. If you know the list is non-empty, prove it.
03:53:16 * hackagebot upload: mpppc 0.1.0 - Multi-dimensional parametric pretty-printer with color (DarinMorrison)
03:53:23 <ivanm> Lemmih: group never returns empty sub-lists? *shrug*
03:53:43 <ivanm> I don't know why, but the description of that package scares me...
03:54:12 <aleator> Hey! Help me make this fast: naive = map head . sortBy (compare `on` length) . group . sort
03:54:42 <aleator> Already tried withMap = sort . M.keys . foldl (\m e -> M.insertWith (+) e 1 m) M.empty using intmap, but that is only 50% faster
03:55:06 <knobo> How do I include a module?
03:55:11 <ivanm> aleator: replace (compare `on` length) with map fst . sortBy (compare `on` snd) . map (\xs -> (xs, length xs))
03:55:15 <ivanm> knobo: import
03:55:34 <ivanm> aleator: any particular reason for having to make it that fast?
03:55:37 <quicksilver> aleator: IntMap has toAscList which is faster than sort . keys
03:55:48 <ivanm> aleator: how about Set.toList . Set.fromList
03:55:49 <aleator> ivanm: That is exactly same speed. Which is nice and strange
03:56:07 <ivanm> aleator: which one?
03:57:02 <ivanm> aleator: how are you timing and comparing these?
03:58:05 <aleator> ivanm: see http://haskell.pastebin.com/d119b2ee3
03:58:28 <aleator> ivanm: I meant map length can compare on length seem to give same results. Which is bit odd
03:58:35 <ivanm> oh, you are using criterion...
03:58:50 <ivanm> aleator: you must have either 1) short lists, or 2) not many lists
03:59:08 <ivanm> but I'm a bit surprised that quicksilver's beloved schwarzian transform didn't improve anything...
03:59:18 <ivanm> aleator: any particular reason for your current version not being good enough?
03:59:18 <Chase|shigoto> short question: is there some kind of tuple unrolling operator in haskell, as pythons * ?
03:59:42 <ivanm> what does it do?
03:59:53 <Chase|shigoto> so i'm having a function  "fun a b"  and want to pass the tuple "c = (1,2)"
03:59:57 <aleator> ivanm: or a bug. I test with 1M random elements in range [0,500000]
03:59:58 <SamB_XP_> Chase|shigoto: python's what ?
04:00:08 <Chase|shigoto> i want to "unroll" the tuple c to be passed as parameters
04:00:12 <ivanm> aleator: probably not many repeats
04:00:16 <aleator> ivanm: It's not good enoough because java version by coworker is faster.
04:00:18 <ivanm> Chase|shigoto: uncurry
04:00:23 <SamB_XP_> ivanm: why would turning your ring into a lazer sword be useful in this case ?
04:00:26 <ivanm> @type uncurry
04:00:27 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
04:00:41 <ivanm> SamB_XP_: hmmm?
04:00:50 <ivanm> aleator: how are you compiling?
04:01:05 <ivanm> aleator: and I'm guessing that your inputs aren't the same
04:01:14 <SamB_XP_> ivanm: bad spaceballs joke
04:01:16 <ivanm> or in different formats
04:01:21 <aleator> ivanm:  ghc -O2 -fvia-c --make WithMap
04:01:21 <ivanm> SamB_XP_: O...K... then...
04:01:32 <SamB_XP_> ivanm: may the shwartz be with you!
04:01:47 <ivanm> aleator: try -funbox-strict-fields as well, and without the -fvia-c
04:01:51 <ivanm> SamB_XP_: heh
04:01:59 <dancor> can't we just call it a decorated sort
04:02:05 <dancor> i've had it with names
04:02:10 <dancor> proper names that is
04:02:24 <dancor> Names
04:02:30 <ivanm> heh
04:02:36 <SamB_XP_> dancor: that works for me
04:02:39 <dancor> Namings Complaint
04:02:41 <SamB_XP_> I can actually remember what that means
04:02:42 <dancor> 's
04:02:44 <ivanm> dancor: that's how I first heard of it, so I'm used to referring to it that way
04:02:48 <aleator> ivanm: No effect :/
04:03:13 * ivanm is guessing that the comparison between Java and Haskell isn't fair, or that aleator is doing something wrong
04:03:31 <ivanm> dancor: give it the proper terminology! decorate-sort-undecorate!
04:03:39 <dancor> he's using the wrong language, this problem could never be fast without bytecode
04:03:42 <SamB_XP_> dancor: did you know that's the way the Python manual suggests to do any sorting based on selected components of a value?
04:04:03 <ivanm> dancor: :o
04:04:31 <aleator> ivanm: Maybe. But the scales here are staggering. I get 6 seconds. He gets 0.3 seconds. About
04:04:32 <Saizan_> SamB_XP_: projections are so slow?
04:04:35 <Chase|shigoto> nobody got any idea on the tuple unrolling ?
04:04:37 <SamB_XP_> apparantly their list.sort method is extremely less efficient when given a comparison function
04:04:55 <ivanm> aleator: right, which makes me assume that the comparison isn't fair
04:05:09 <ivanm> aleator: what is that 6 seconds comparing? reading data in as well? producing the random values?
04:05:11 <SamB_XP_> Saizan_: I think they have to use a different algorithm if you pass in a comparison function or something
04:05:19 <Saizan_> Chase|shigoto: for 2-tuples there's uncurry, for 3 uncurry3, nothing beyond that
04:05:26 <SamB_XP_> either that, or *calls* are that slow
04:05:42 <dancor> :t uncurry3
04:05:43 <lambdabot> Not in scope: `uncurry3'
04:05:46 <ivanm> Saizan_: he never mentiond 3-tuples
04:05:48 <ivanm> @hoogle uncurry3
04:05:49 <lambdabot> No results found
04:05:55 <ivanm> Chase|shigoto: and I already mentioned uncurry to you
04:06:00 <ivanm> @type uncurry
04:06:01 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
04:06:02 <ivanm> Chase|shigoto: ^^
04:06:12 <aleator> ivanm: Only extras I have is extra calculation of length and show of one number. Otherwise the amount of data is the same, and in same range.
04:06:14 <ivanm> uncury foo (a,b) == foo a b
04:06:16 <Chase|shigoto> wtf, uncurry takes a function, doesn't it ?!
04:06:19 <Saizan_> so uncurry3 is only in my dreams?
04:06:24 <ivanm> aleator: so you're reading the data in?
04:06:27 <ivanm> Chase|shigoto: yes
04:06:29 <dancor> i think hoogle has the optimal coverage to keep anyone still using it while frustrating them as often as possible
04:06:33 <ivanm> isn't that what you wanted?
04:06:35 <ivanm> dancor: heh
04:06:37 <Chase|shigoto> nope
04:06:41 <ivanm> Saizan_: possibly
04:06:45 <ivanm> Chase|shigoto: then what do you want?
04:06:50 <Saizan_> Chase|shigoto: can you give an example in haskell?
04:07:02 <Chase|shigoto> i want to pass a tuple "c = (2,3)"  to a function that takes parameters "fun a b = .."
04:07:08 <aleator> ivanm: See http://haskell.pastebin.com/d119b2ee3, I'm using Statistics.RandomVariate to generate it
04:07:11 <ivanm> Chase|shigoto: uncurry fun
04:07:15 <Saizan_> Chase|shigoto: uncurry fun c
04:07:20 <ivanm> Chase|shigoto: there's no automatagic way of doing it
04:07:26 <dancor> > uncurry (*) (2, 3)
04:07:27 <Chase|shigoto> oh, that's weird
04:07:27 <lambdabot>   6
04:07:46 <ivanm> aleator: right, so the thing to test is whether the random data generation between Java and Haskell is being considered/is biased
04:07:48 <Chase|shigoto> i'm used to doing something like fun(*c)  in python,  * unrolling the tuple
04:07:51 <Chase|shigoto> but thanks!
04:08:07 <ivanm> aleator: the only fair way to compare them is to have the values to use inbuilt to test only the functions themselves
04:08:15 <jogla> Hello
04:08:22 <jogla> How can I express something like this:
04:08:22 <ivanm> Chase|shigoto: Haskell's strong static typing disallows that
04:08:24 <jogla> mapTree (a -> c) (b -> d) (Node a l r) = Node (f(a)) (mapTree f g l) (mapTree f g r)
04:08:34 <ivanm> jogla: what do you mean?
04:08:44 <jogla> Its about the a in (a -> c) and (Node a l r) have to be the same type
04:09:01 <ivanm> jogla: you're mixing your type sig with your implementation...
04:09:13 <jogla> yeah
04:09:24 <ivanm> what data structure is this?
04:09:26 <ivanm> Data.Tree ?
04:09:30 <dancor> aleator: ya what you're seeing here is that the random number generation takes 6s
04:09:31 <Saizan_> no.
04:09:36 <jogla> No, that's something I made
04:09:43 <ivanm> dancor: which I was trying to get at ;-)
04:10:07 <ivanm> jogla: well, I'm not sure what you're trying to do there
04:10:17 <ivanm> jogla: can you paste your data structure up somewhere?
04:10:34 <Chase|shigoto> oh, something else: is there an easy way of converting lists into tuples, and vice-versa ?
04:10:41 <Saizan_> Chase|shigoto: no
04:10:57 <jogla> http://pastebin.com/m638e1aca
04:10:57 <Saizan_> aside from pattern matching
04:11:05 <Chase|shigoto> so i guess only one of both should make sense, at a given situation
04:11:09 <aleator> dancor: I measured. Takes 1.6sec. Already subtracted that
04:11:15 <Saizan_>  let [a,b,c] = [1,2,3] in (a,b,c)
04:11:19 <Saizan_> > let [a,b,c] = [1,2,3] in (a,b,c)
04:11:20 <dancor> > map (\ (x, y) -> [x, y]) [(2, 3), (4, 5)]
04:11:21 <lambdabot>   (1,2,3)
04:11:21 <lambdabot>   [[2,3],[4,5]]
04:11:22 * hackagebot upload: hoauth 0.1.7 - A Haskell implementation of OAuth 1.0a protocol. (DiegoSouza)
04:11:39 <dancor> ho tho?
04:11:39 <ivanm> jogla: OK, so you're wanting a map
04:11:56 <ivanm> jogla: why two Node versions of mapTree ?
04:12:14 <jogla> Hmm
04:12:16 <ivanm> aleator: *cough* laziness *cough*
04:12:31 <ivanm> jogla: that's probably your problem
04:12:34 <Saizan_> jogla: i think your Tree definition is wrong, you don't use 'b'
04:12:39 <jogla> There different types of Nodes
04:12:43 <ivanm> Saizan_: agreed
04:12:54 <dancor> aleator: you're going to have to break things down to profile everything.  pregen the numbers
04:12:55 <jogla> a and b aren't the same
04:13:00 <Saizan_> jogla: also you don't put type signatures in patterns, you have to use variables there
04:13:08 <ivanm> jogla: you need different Node types then
04:13:13 <ivanm> NodeA, NodeB, etc.
04:13:18 <Saizan_> jogla: right, but you never use 'b' in the rhs
04:13:19 <jogla> ahh, ok
04:13:35 <Saizan_> however, i'd think the 'b' goes in the leafs
04:13:37 <ivanm> jogla: why do you need alternating node types?
04:13:49 <ivanm> Saizan_: look at Node: he switches a and b around for Tree
04:14:01 <Saizan_> ivanm: right, but i think that's wrong :)
04:14:04 <ivanm> dancor: now, why didn't I think of that? :p
04:14:08 <ivanm> Saizan_: agreed
04:14:10 <jogla> Because some of them are Int, and some are Bool
04:14:24 <ivanm> Saizan_: either b refers to edge labels, or it's for leaves as opposed to internal nodes
04:14:28 <ivanm> jogla: always alternating?
04:14:34 <jogla> Yes
04:14:44 <ivanm> jogla: co-recursive data structure then
04:14:58 <ivanm> probably the only type-safe way of doing this
04:14:59 <jogla> That sounds like black magic
04:15:04 <ivanm> not really
04:15:34 <aleator> ivanm: Really? If I print sum of the random numbers it still can be lazy somehow?
04:16:03 <ivanm> jogla: http://pastebin.com/d55027d30
04:16:09 <ivanm> the names could be better...
04:16:22 <Saizan_> ivanm: the term is "mutually recursive" i'd think, co-recursive looks related to codata
04:16:23 <jogla>    1.
04:16:23 <jogla>       data TreeA a b = EmptyA | NodeA a (TreeB b a) (TreeB b a)
04:16:23 <jogla>    2.
04:16:23 <jogla>        
04:16:23 <jogla>    3.
04:16:24 <jogla>       data TreeB b a = EmptyB | NodeB b (TreeA a b) (TreeA a b)
04:16:26 <jogla> sorry
04:16:36 <ivanm> Saizan_: whatever the term is ;-)
04:16:45 <ivanm> (though I thought co- just meant 2...)
04:16:57 <ivanm> aleator: I'm guessing that they're not fully evaluated
04:17:01 <Saizan_> jogla: ah, those are mutually recursive types
04:17:07 <ivanm> aleator: maybe use rnf from strategies?
04:17:14 <ivanm> Saizan_: yeah, whatever ;-)
04:17:28 <Saizan_> ivanm: co has nothing to do with 2 :)
04:17:52 <ivanm> jogla: the reason being, there's no way of telling with how you had it whether an arbitrary level had as or bs as the node type
04:17:58 <Saizan_> jogla: you've to define a mapTreeA and a mapTreeB
04:17:59 <ivanm> so you can't pick the right function to use
04:18:44 <Saizan_> jogla: that call each other
04:18:52 <jogla> I have to meditate over it
04:19:53 <Saizan_> jogla: were those data definitions given to you?
04:20:07 <jogla> yes
04:20:14 <ivanm> Saizan_: I gave them to him
04:20:31 <Saizan_> ops
04:27:09 <ivanm> @hoogle partitionEither
04:27:10 <lambdabot> Data.Either partitionEithers :: [Either a b] -> ([a], [b])
04:32:38 * pakaran guesses "either" is something he hasn't read about yet that consists of exactly one of its arguments?
04:33:10 <byorgey> @type either
04:33:11 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
04:33:25 <byorgey> pakaran: either is for dealing with things of type  Either a b
04:33:25 <lambdabot> byorgey: You have 2 new messages. '/msg lambdabot @messages' to read them.
04:33:37 <jogla> can i check the type a function will take in haskell at runtime somehow?
04:33:50 <byorgey> you tell it how to deal with the a  (a -> c)  and how to deal with the b  (b -> c)  and it does whichever is appropriate.
04:34:06 <Chase|shigoto> I'm not really getting this with uncurry:  let's say i want to do something simple like this "zipWith (-) [1,2,3] [3,2,1]".  But those two lists are in a tuple. "(uncurry zipWith) (-) ([1,2,3], [3,2,1])" is not working out
04:34:27 <pakaran> thanks byorgey
04:35:02 <byorgey> Chase|shigoto: I think you want  (uncurry (zipWith (-)))
04:35:05 <quicksilver> > uncurry (zipWith (-)) ([1,2,3],[3,2,1])
04:35:07 <lambdabot>   [-2,0,2]
04:35:09 <byorgey> Chase|shigoto: it's not the (-) that's in a tuple!
04:35:18 <quicksilver> Chase|shigoto: "zipWith(-)" was the function which operated on two parameters
04:35:26 <quicksilver> Chase|shigoto: ...which you wanted to alter to operate on a pair
04:35:34 <byorgey> jogla: I'm not sure what you mean.
04:35:37 <pakaran> so (as a simple example) you could make a statistics function that works on either ints or doubles, without a lot of casting in the middle?
04:36:02 <quicksilver> well you could make one which operates on all Nums
04:36:06 <quicksilver> which includes Int and Double
04:36:14 <jogla> like foo a b c = if (a c) works do (a c) else do (b c)
04:36:17 <pakaran> dear gods
04:36:24 <quicksilver> but it might be a bit tricky because Int doesn't support (/) which is needed for most statistics.
04:36:25 <byorgey> pakaran: that's probably not the best example =)
04:36:27 <pakaran> this is how programming should work
04:38:07 <pakaran> and i'm sorry - i'm reading tutorials slowly
04:38:34 <pakaran> because when i read references, they start talking about nonlinear vulcan type classes and things and my brain starts hurting
04:38:58 <Saizan_> jogla: no, you can't check types at runtime, unless you use Data.Typeable, but i doubt you want it here
04:40:16 <pakaran> (exaggerating, sorry)
04:41:10 <fadax> hi
04:41:23 <fadax> i have a list of functions.. fList1 :: Num a => [ ( String, a -> a -> a ) ]
04:41:32 <fadax> with these functions in: fList1 = ("+", (+)) : ("-", (-)) : ("*", (*)) : []
04:41:33 <ivanm> pakaran: heh
04:41:35 <fadax> does anyone know how I can add a divide function to the list?
04:41:49 <fadax> I tried "/", (/)  but it gives an error
04:41:56 <ivanm> fadax: division isn't for all numbers
04:42:03 <ivanm> @type (/)
04:42:04 <lambdabot> forall a. (Fractional a) => a -> a -> a
04:42:17 <fadax> oh..
04:42:20 <ivanm> fadax: if you had Fractional a => [(String, a -> a -> a)], then you could
04:42:21 <fadax> so i can't add to this list
04:42:22 <fadax> ?
04:42:28 <ivanm> fadax: division doesn't make sense for integers ;-)
04:42:33 <Saizan_> ?type ("/",(/)) : ("+", (+)) : ("-", (-)) : ("*", (*)) : []
04:42:35 <lambdabot> forall a. (Fractional a) => [([Char], a -> a -> a)]
04:42:46 <Saizan_> fadax: you can, but the type changes, like above
04:42:48 <fadax> oh..
04:43:01 <fadax> so i can change Num to Fractional
04:43:05 <fadax> and the whole list will work? :)
04:43:09 <Saizan_> yes
04:43:17 <fadax> o ok i'll do that thanks
04:43:42 <Saizan_> ?type div
04:43:44 <lambdabot> forall a. (Integral a) => a -> a -> a
04:43:55 <quicksilver> fadax: are imperial using haskell for teaching now?
04:44:31 * hackagebot upload: hpage 0.3.4 - A scrapbook for Haskell developers (FernandoBenavides)
04:44:35 <fadax> lol yes
04:44:44 <fadax> i think they have for years
04:44:56 <fadax> it's the first language we learn
04:45:00 <ivanm> a scrapbook?
04:45:54 * pakaran learned java as a freshman, then c++ as a sophomore, and came to the conclusion that c++ makes programs crash for no reason, without meaningful messages, because they hate you.
04:47:46 <fadax> quicksilver how do you know i'm from imperial
04:48:07 <pakaran> fadax, probably your hostname
04:48:23 <fadax> o ok
04:48:31 <benmachine> my friend at imperial is doing haskell
04:48:36 <benmachine> some
04:48:48 <benmachine> that was entirely redundant information
04:48:52 <benmachine> but true anyway
04:48:55 <fadax> lol
04:48:57 <fadax> are they first year ?
04:49:28 <benmachine> yes
04:50:04 <benmachine> ksf has an ipv6 address :o
04:50:15 <fadax> oh.. maybe i know them
04:50:19 <benmachine> maybe
04:50:22 <fadax> probably not though
04:50:26 <benmachine> aren't there hundreds of people on your course though
04:50:31 <fadax> i only know like 20 people out of my 150 class
04:50:31 <benmachine> odds are not that high :P
04:50:44 <fadax> lol
04:53:32 <quicksilver> fadax: hmm, I don't think they did last time I talked to someone about it
04:53:36 <quicksilver> you used to use miranda :)
04:53:47 <quicksilver> changed in the last 9 years or so I guess
04:54:03 <ivanm> quicksilver: changed for the better? ;-)
04:54:14 <quicksilver> yes, although miranda is a fine language
04:54:32 <quicksilver> but it's proprietary, and it lacks the interesting community around haskell.
04:54:46 <ivanm> exactly
04:54:51 <ivanm> I can't believe it's still proprietary
04:55:00 <ivanm> then again, with Haskell there, what's the point? *shrug*
04:55:07 <ivanm> (of opening it, that is)
04:55:21 <jogla> I have a question again
04:55:22 <jogla> 	interpret :: Polynomial -> (String -> a) -> a
04:55:22 <jogla> 	interpret (Const a) _ = a
04:55:26 <jogla> I know why this doesn't work
04:55:31 <jogla> But i don't understand how to fix it
04:55:40 <jogla> (Const a), a ist an Int every time
04:55:44 <ivanm> well, seeing as how I have no idea what you're doing there...
04:55:57 <jogla> but i don't care about the function that's reached in
04:56:22 <jogla> Polynomial is a data structure, Const Int is one of the constructors
04:56:38 <jogla> interpret interprets Polynomials, and the Polynomial 4 should give just 4
04:56:47 <jogla> e.g.:
04:56:52 <jogla> 	interpret (Var a) f = f a
04:56:53 <jogla> is the next line
04:57:11 <jogla> so the function evaluates the variables
04:57:28 <ivanm> jogla: is `a' a String for Var?
04:57:37 <jogla> yes
04:57:37 <ivanm> are you sure you're getting the right line with the error?
04:57:43 <jogla> I think so
04:57:49 <benmachine> interpret needs to be consistent in the type that it outputs
04:57:50 <jogla> the error is:
04:57:51 <jogla> *** Expected type : Interpretable a => Polynomial -> (String -> a) -> a
04:57:51 <jogla> *** Inferred type : Interpretable Int => Polynomial -> (String -> Int) -> Int
04:58:14 <ivanm> jogla: right, it has to be Int not a
04:58:15 <jogla> I think the problem is that the function doesn't necessarly point to Int
04:58:19 <ivanm> since the value of Const forces it
04:58:23 <benmachine> so if you are asking it to return the a in Const a then you need a to be an Int
04:58:23 <jogla> ahh, ok
04:58:25 <jogla> Hmm
04:58:29 <benmachine> so you need the return type to be an Int
04:58:34 <ivanm> (unless you use GADTS or something... >_>)
04:58:49 <Saizan_> or maybe Interpretable has a way to make an 'a' out of an Int?
04:58:50 <benmachine> you could change the Polynomial type so that Polynomial a contained constants of type a
04:59:12 <bastl> hiho
04:59:55 <bastl> Im installing ghc on a server where i dont have "root". GHC installed smoothly. What do I need to do to install cabal ?
04:59:57 <jogla> Hmm
05:00:07 <bastl> is Cabal itself delivered with ghc ?
05:00:16 <ivanm> bastl: you meant he library or cabal-install?
05:00:22 <bastl> the lib
05:00:27 <ivanm> it comes with ghc
05:00:33 <bastl> ok
05:00:38 <jogla> http://pastebin.com/d215483c9
05:00:42 <jogla> It doesn't work for Int either
05:01:12 <fasta> bastl, I have root, but I always install stuff from source as user, because that way I make sure the system isn't messed up.
05:01:12 <jogla> that's the hole thing:
05:01:14 <jogla> http://pastebin.com/d31882c34
05:01:57 <bastl> ah, bootstrap is running.
05:02:45 <ivanm> fasta: well, I build everything as root...
05:02:49 <ivanm> yay for gentoo! \o/
05:03:04 <bastl> whenever I use this incredible infrastrure things, I ask myself: what companies are sponsoring this. This cant be community-based open-source or academia work ... Does anyone know ?
05:03:27 <dancor> aleator: hm pastebin overwrote your post..  anyway hth: http://haskell.pastebin.com/m704646a8
05:03:47 <ivanm> bastl: which things?
05:04:30 <bastl> haddock, hackage, cabal
05:04:32 <Saizan_> jogla: you are confused about what classes in haskell are
05:04:32 <bastl> gtk2hs
05:04:38 <bastl> all the big, cool things
05:04:41 <Saizan_> jogla: they are nothing like OO classes
05:04:53 <ivanm> bastl: cabal 1.8 was partially sponsored by IHG
05:05:02 <jogla> I had to do it this way
05:05:03 <ivanm> bastl: hackage is hosted by galois
05:05:21 <bastl> but are the developers full-time employees as with common linux-distributors ?
05:05:27 <jogla> my exercise says pretty concrete to do it this way if i understand it correctly
05:05:34 <Saizan_> jogla: a class declaration is only about specifying an interface, not implementation, and you need it only if you want a function to work over multiple types
05:05:41 <ivanm> bastl: otherwise, there's some libs coming out of galois, work done by the IHG, and everythign else is us peons doing it for the lulz
05:05:42 <ivanm> ;-)
05:05:59 <dancor> aleator: ah it didn't overwrite your original post.  i'm just easily confused.
05:06:15 <bastl> ivanm: doing things for the lolz seldom produces really high quality ...
05:06:16 <ivanm> bastl: the IHG pays WellTyped to do stuff full time; dons, etc. at Galois use Haskell, and produce libs as a side effect
05:06:17 <jogla> Saizan_: Where would i put the interpret method?
05:06:19 <fasta> ivanm, are you sure gentoo does that?
05:06:22 <luite> ghc itself has some paid developers
05:06:31 <fasta> ivanm, in Debian there is this thing called fakeroot.
05:06:33 <ivanm> fasta: ummm, Gentoo is a source-based-distro
05:06:39 <Saizan_> jogla: outside of the class completely
05:06:40 <fasta> ivanm, that has nothing to do with it.
05:06:43 <ivanm> fasta: oh, it uses a sandbox for compiling usually
05:06:49 <Saizan_> jogla: as a stand-alone function
05:06:52 <jogla> ah, ok
05:06:57 <jogla> is that the error?
05:07:08 <ivanm> <fasta> bastl, I have root, but I always install stuff from source as user, because that way I make sure the system isn't messed up. <--- I interpreted that as "I install things as user"
05:07:27 <ivanm> luite: well, to add functionality, yes
05:07:38 <ivanm> luite: but bastl seemed to be askign about libs and tools, not ghc
05:07:52 <Saizan_> jogla: i don't see where you pasted the error
05:08:05 <dcoutts> ivanm: I think that's putting it a bit strongly
05:08:06 <fasta> ivanm, I install it as user, yes. For packages libraries only apt as root works.
05:08:09 <jogla> <jogla> the error is:
05:08:09 <jogla>  *** Expected type : Interpretable a => Polynomial -> (String -> a) -> a
05:08:09 <jogla>  *** Inferred type : Interpretable Int => Polynomial -> (String -> Int) -> Int
05:08:11 <fasta> packaged*
05:08:21 <fasta> I would live to see apt for normal users.
05:08:21 <ivanm> dcoutts: which statement?
05:08:30 <dcoutts> ivanm: cabal 1.8 and ihg
05:08:37 <ivanm> dcoutts: well, didn't you?
05:08:40 <bastl> ivanm: the whole infratsructure. it's very professional. I like it (not only the langauge itself)
05:08:51 <dcoutts> ivanm: worked on one small feature
05:08:55 <ivanm> fasta: well, I install everything as root on my machine from source (except for OO.org and proprietary blogs, etc.)
05:09:03 <ivanm> dcoutts: I suppose...
05:09:21 <ivanm> dcoutts: I did say partially ;-)
05:09:22 <fasta> bastl, there are still a lot of things broken. It's still quite far from my ideal.
05:09:29 <Saizan_> jogla: that error should be gone when you changed the type signature
05:09:40 <fasta> bastl, that said, I don't know the quality of commerical C++ compilers.
05:09:42 <jogla> Saizan_: from a to Int?
05:09:43 <bastl> fasta any software that gets near to your ideal ?
05:09:44 <luite> bastl: it's so professional that a server crash in the weekend will only be fixed on the next monday, during working hours ;)
05:09:55 <jogla> i changed it to 	interpret :: Polynomial -> (String -> Int) -> Int
05:10:07 <Saizan_> jogla: yes
05:10:08 <ivanm> fasta: icc is meant to be pretty good IIRC...
05:10:14 <fasta> bastl, Coq, but I haven't used enough to have a good opinion on it.
05:10:15 <ivanm> luite: heh
05:10:32 <fasta> bastl, of course Coq does no shared libraries or FFI with C either ;)
05:10:40 <Saizan_> jogla: though i'm not sure if that's really what you want, because you won't be able to use interpret with Tropical then
05:10:54 <jogla> yeah
05:10:56 <jogla> that's true
05:11:14 <fasta> bastl, for "almost Haskell 98" GHC is quite good.
05:11:21 <Jafet> fasta, the idea is that your algorithms are proven to work all the way until you actually link them
05:11:28 <Saizan_> jogla: maybe you need a fromInt :: Int -> a method in the Interpretable class, that can be instantiated differently for Int and for Tropical
05:11:35 <pakaran> ok, as part of a toy example, i'm trying to write a function to interpret a list of bools as a binary number using foldl.  so i need a helper function that does something like the following pseudo-c help(a,b) {return 2*a+b).  How would I write this?
05:11:56 <pakaran> no, that's not what i want...
05:12:01 <Jafet> \a b -> 2*a + b
05:12:24 <bastl> fasta: i think in terms of packaging, documentation etc. hoogle and hayoo are so cool. I dont know of any other api-searchengines that get near to that ...
05:12:35 <fasta> bastl, hayoo is down way too much.
05:12:37 <pakaran> it would work in c because a and b are already integer
05:12:40 <jogla> Saizan_: Where would i use it?
05:12:41 <pakaran> well, i'll think about it
05:12:42 <bastl> fasta: true
05:12:47 <pakaran> i on't need the keyboard to think =)
05:12:57 <fasta> bastl, Squeak has a method finder which is better than Hayoo.
05:13:00 <bastl> fasta: thats akademia
05:13:04 <Saizan_> jogla: "interpret (Cont i) = fromInt i"
05:13:36 <fasta> bastl, Squeak has some other tools which don't exist in Haskell development environments, like who calls certain functions and jump to definition.
05:13:44 <Saizan_> interpret shouldn't be a method of Interpretable even in this case
05:13:44 <fasta> bastl, what is?
05:14:00 <bastl> ?
05:14:14 <fasta> bastl, "thats akademia"
05:14:29 <bastl> fasta: the downtime of hayoo
05:14:41 <fasta> bastl, Ok, what do you mean by that?
05:14:56 <fasta> bastl, Just because it is academia the hosting is bad?
05:15:15 <bastl> yep. they are not "professional" sysadmins.
05:15:15 <fasta> bastl, a useful tool runs locally and never breaks, imho.
05:15:21 <dancor> ha
05:15:22 <bastl> but researchers and lecturers
05:15:34 <luite> hackage is run by galois
05:15:38 <dancor> and it never breaks!
05:15:45 <fasta> bastl, if you build a system the system administration is part of it.
05:15:47 <Saizan_> is hayoo code available?
05:15:57 <dancor> Saizan_: i couldn't find it the one time i looked
05:16:01 <fasta> bastl, removing any kind of administration should be the goal.
05:16:22 <ivanm> Saizan_: I think so...
05:16:30 <ivanm> Saizan_: at least the server it runs on is IIRC
05:16:32 <dancor> fasta: that's a little naive..
05:16:56 <ivanm> Saizan_: Holumbus stuff is on hackage, hayoo itself isn't... :(
05:16:56 <Saizan_> ivanm: i could find only the Holumbus libs, not the hayoo code itself
05:17:05 <ivanm> luite: s/run/hosted/
05:17:07 <fasta> dancor, a system administrator needs to execute adduser and change /etc/fstab and stay the hell away from the system for the rest.
05:17:09 <ivanm> Saizan_: yeah :(
05:17:24 <fasta> dancor, you don't really need admin rights for anything else.
05:17:43 <dancor> you have to monitor for eventual bad disks and other kinds of necessarily expected failures
05:17:49 <fasta> dancor, yes, I know about priv. ports etc.
05:18:11 <dancor> you also have to realize that haskell does not prevent all possible bugs
05:18:12 <jogla> thanks
05:18:34 <dancor> in programs without proofs etce tec
05:18:37 <fasta> dancor, system administration can also swap out harddisks if they want.
05:18:49 <luite> ivanm: yes, but I don't think anyone outside galois currently has administrative access to the server?
05:18:54 <fasta> dancor, but otherwise there is no need to have system administrators.
05:19:05 <dancor> this is a contentless discussion, and hackage went down very recently for a very long time
05:19:34 <fasta> dancor, Hackage has been designed in a way such that it can have catastrophic failure.
05:19:42 <fasta> dancor, so, it only proves my point.
05:19:54 <gressvol-> how do I interpret this lambda expression: \x -> \y -> \f -> f x y ?
05:19:56 <fasta> dancor, design your system well and there is no need for a system administrator.
05:20:07 <ivanm> luite: *shrug* dunno about others having access, but IIUC they don't have anything to do with the design, etc. of hackage
05:20:15 <Jafet> "What if we don't want catastrophic failures"
05:20:18 <ivanm> fasta: well, _someone_ has to install it!
05:20:36 <fasta> ivanm, sure, normal users can do that, since they know what they need.
05:20:46 <eevar2> yup. whoever "designs the system well" is a sysadmin
05:21:08 <ivanm> @. pl undo \ cmd -> putStrLn cmd >> runCommand cmd
05:21:08 <lambdabot> liftM2 (>>) putStrLn runCommand
05:21:12 <dancor> i agree with bastl that academics tend to have worse uptime
05:21:26 <fasta> I also agree.
05:21:33 <Jafet> :t \x -> \y -> \f -> f x y
05:21:34 <lambdabot> forall t t1 t2. t -> t1 -> (t -> t1 -> t2) -> t2
05:21:36 <dancor> probably bc they are spending their time envisioning a perfect utopian monitoringless future
05:22:06 <bastl> it's simply not their job to "produce" or "serve" something. (but research and teaching are ...)
05:22:09 <quicksilver> gressvol-: a function which, when given three parameters x, y and f returns the value (f x y) ?
05:22:55 <fasta> bastl, the discussion began with you pointing out how great Hayoo was.
05:23:21 <bastl> fasta: right, we're loosing focus :-)
05:23:29 <gressvol-> and (f x y) is x and y sent to f?
05:24:14 <fasta> gressvol-, x is send to f. Then the resulting thing gets y and processes it.
05:24:43 <fasta> gressvol-, or (f x) y == f x y
05:25:15 <fasta> gressvol-, but only when actually needed are x and y evaluated.
05:26:44 <pakaran> ok, i'm trying to enter ackermann function examples from the web line-by-line into the interpreter, and it's not working
05:26:50 <pakaran> not sure why it's not working
05:27:08 <pakaran> but p 0 n = n+1 gives parse errors
05:27:20 <zygospasm> pakaran: ghci isn't exactly an interpreter
05:27:26 <pakaran> ah
05:27:31 <ivanm> pakaran: you normally don't define functions in ghci
05:27:33 <pakaran> so i need something which is?
05:27:39 <bastl> Where does Cabal look for the happy binary, when it finds "extraSrc" .y files? I installed happy via cabal, but my (custom) build doesnt find the binary ...
05:27:50 <zygospasm> you need to add 'let' to the start of function definitions
05:27:51 <fasta> pakaran, ghci is inside a do block.
05:27:57 <zygospasm> you'll also get problems if they span multiple lines
05:27:57 <Saizan_> bastl: in the $PATH
05:28:13 <ivanm> bastl: is it in $PATH ?
05:28:13 <zygospasm> pakaran: it's easiest to put the stuff in a file and import it in ghci
05:28:21 * quicksilver would like to campaign for people to stop saying 'ghci is inside a do block'
05:28:33 <ivanm> quicksilver: isn't it though?
05:28:40 <quicksilver> (3+4) is not a valid statement in an IO do block
05:28:45 <zygospasm> it's closer to a do-block than it is to an interpreter
05:28:46 <quicksilver> but it is precisely the kind of thing I often type in ghci
05:28:48 <pakaran> if it's in a do block, won't the function just be undefined for some values until i enter other cases?
05:28:59 <pakaran> and in particular give errors when i haven't yet typed cases in?
05:29:03 <ivanm> quicksilver: fair enough
05:29:09 <bastl> strange, its in .cabal/bin which is in my $PATH, but still i get "command not found"
05:29:10 <zygospasm> ghci is an interactive expression evaluator :)
05:29:15 <ivanm> ghci is in a do-block with automagic lifting into IO! :p
05:29:27 <quicksilver> ghci evaluations expressions (which in my opinion is its primary purpose) and also executes IO actions (useful but for me secondary)
05:29:50 <bastl> hm, i had to source my .cshrc again ...
05:30:10 <pakaran> lol.
05:30:22 <Saizan_> maybe you're missing an export, or there's something fishy going on with interpreting ~?
05:30:23 <pakaran> so it's an infinite list of expressions with show (write (...)) mapped over it?
05:30:26 <bastl> now it's on the path, but cabal still doesnt find it.
05:30:31 <ivanm> that's weird... I use Paths_ to get the version of my app, but when running it in ghci with :main it reports the wrong version number...
05:30:31 <pakaran> erm, otherway around
05:31:03 <Saizan_> ivanm: maybe it's loading an old Paths_?
05:31:08 <Jafet> IO eval IO loop!
05:31:12 <ivanm> Saizan_: yeah, just figured that out...
05:31:42 <fasta> x <- return 1 also works in ghci. Ok, so ghci: ghci evaluated expressions if they are just expressions and otherwise treats whatever the user inputted as something to be evaluated as a do block. The return value then gets printed to the user by using the print function.
05:31:53 <pakaran> so if i can write the function on one line, i can run it in ghci?
05:31:59 <Saizan_> bastl: you can use --with-happy=path/to/happy as a workaround, though it'd be nice if you could find the cause of the problem
05:32:04 <fasta> quicksilver, can you find yourself in that description?
05:32:06 <pakaran> i'm on my windows laptop and don'tt have a text editor other than notepad :(
05:32:14 <quicksilver> pakaran: and you can write all functions on one line.
05:32:38 <pakaran> without them reading like the usual perl attempt to implement something on one line?
05:32:39 <quicksilver> pakaran: let f [] = 0; f (x:xs) = 1 + f xs
05:32:47 <pakaran> ah!
05:32:49 <quicksilver> pakaran: is an example of how to write a multi-line definitioin on one line
05:32:52 <Saizan_> fasta: it doesn't get printed if the type is IO ()
05:32:53 <pakaran> so one line line, not one logical line
05:32:55 <dcoutts> bastl: are you sure? it's not doing anything magic, it's just getting the $PATH and looking in there
05:33:02 <fasta> Saizan_, ah, right.
05:33:04 <quicksilver> fasta: and it doesnt' get printed if the type has no Show instance.
05:33:09 <quicksilver> fasta: (but, there is no error either)
05:33:34 <quicksilver> however if you have an *expression* (not action) of a non-Show type
05:33:40 <quicksilver> then you do indeed get the "no Show instance" error.
05:33:48 <fasta> Maybe it would be better to just fix ghci instead of writing the current exceptions down.
05:33:51 <pakaran> but what i can't do is implement a function for some cases, then continue the function on another line?
05:34:09 <fasta> The problem is that new users think it is a problem, while other users are already used to it.
05:34:12 <bastl> dcoutts: i have a _heavily_ tweaked Setup.hs. Can that be the cause ?
05:34:32 <bastl> remember, i build the PackageDescription myself
05:35:10 <Saizan_> pakaran: right
05:35:34 <Saizan_> fasta: it's quite convenient this way though
05:36:07 <bastl> Saizan: --with happy worked well.
05:37:10 <dcoutts> bastl: my guess would be that the $PATH has not been updated
05:37:32 <Saizan_> so, either the $PATH doesn't get propagated properly to cabal, or it contains something that's not interpreted by it
05:37:43 <tibbe> The dates for the ZuriHac hackathon have now been set: http://haskell.org/haskellwiki/ZuriHac
05:37:50 <dcoutts> $ bastl: test with $ ghc -e 'System.Directory.findExecutable "foobar" >>= print'
05:37:57 <dcoutts> tibbe: woo!
05:39:10 * tibbe runs to the airport
05:39:21 <ivanm> tibbe: bah, I was hoping for something in January since I was going to be in the northern hemisphere then anyway...
05:39:22 <pakaran> alright
05:39:29 <pakaran> i entered the function, a nd didn't get errors
05:39:33 <pakaran> hoping this means it's correct
05:40:46 <bastl> Saizan, dcoutts: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4843#a4843
05:41:45 <bastl> when I append --with-happy/alex option it works out
05:43:06 <dcoutts> bastl: oh, you just need to re-configure
05:43:09 <pakaran> and it's working
05:43:19 <bastl> ah, how dumb ...
05:43:21 <bastl> :-/
05:43:24 <pakaran> though by the amount of time it's taking, i am guessing that ghci defaults to no optimization?
05:44:18 <Saizan_> pakaran: right
05:45:27 <Saizan_> bastl: you could add happy to build-tools so the error will be catched by configure
05:46:50 <pakaran> hmm
05:46:59 <pakaran> is there a simple method to see how functions work?
05:47:06 <pakaran> something like trace in python?
05:47:16 <fasta> pakaran, Debug.Trace.trace
05:47:32 <fasta> pakaran, but it's probably not the same.
05:47:54 <pakaran> ah
05:48:01 <pakaran> trying to figure out the syntax for i
05:48:02 <pakaran> t
05:48:17 <fasta> pakaran, it's not syntax.
05:48:50 <pakaran> ...
05:48:56 <pakaran> how can it not be syntax?
05:48:56 <fasta> pakaran, import Debug.Trace and then somewhere trace ("Oh, wow, thunk was dereferenced") x
05:49:14 <fasta> pakaran, it's just a function.
05:49:48 <fasta> pakaran, for the same reason you can define if' to be a function.
05:50:04 <fasta> pakaran, which is that it is built-in to the evaluation model.
05:50:33 <bastl> ok, next problem: without root, i cant (dont know how) build sdist or install with my custom build. I use "withArgs cabalargs (defaultMainWithHooks (hooks lang))" where the whole cabal-file (PackageDescription) is built inside (hooks lang). (lang is the name of a BNFC-grammar). Here is my "Setup.hs": http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4844#a4844
05:50:40 <fasta> pakaran, so, if trace didn't exist, you could write it yourself, but I admit it does depend on unsafePerformIO.
05:51:03 <fasta> pakaran, that is a primitive that sort of destroys any guarantees you might believe to have.
05:51:11 <bastl> at the sametime I could append options like "--with-alex" Whats the difference to --prefix ?
05:51:42 <pakaran> yeah, most things i've seen about unsafePerformIO are pretty much "don't use it, it isn't actually what you want"
05:52:02 <fasta> pakaran, but trace is perfectly safe for debugging.
05:52:15 <fasta> pakaran, if you want to have actual log functionality, you should use something else.
05:52:28 <pakaran> i mostly want to see how this function calls itself
05:52:42 <pakaran> out of curiousity - i'm still in the playing phase
05:53:13 <Saizan_> bastl: --prefix is about where to install, not where to find tools, and you might also need --package-db to avoid registering into the global package db
05:53:42 <Saizan_> bastl: though, what error are you getting while building without root?
05:55:16 <bastl> it says unrecodinzed option "--prefix"
05:55:22 <bastl> unrecognized*
05:56:15 <pakaran> sigh
05:57:26 <Saizan_> bastl: --prefix is only for configure
05:57:31 <pakaran> even "trace (1 + 1)" gives me a ton of errors that make little sense
05:57:47 <pakaran> about wanting strings - fair enough, but why would someone debug a string?
05:57:54 <bastl> cabal help install
05:58:33 <Saizan_> pakaran: let d = trace s e just prints 's' when 'd' gets evaluated and returns 'e'
05:58:49 <fasta> pakaran, you didn't do exactly like I said.
05:59:00 <Saizan_> pakaran: it doesn't print the steps needed to evaluate 'e'
05:59:10 <pakaran> sorry
05:59:11 <Zao> I had to try three times to spell "cable" today. I kept typing "cabal".
05:59:17 <pakaran> so it's not like trace in prolog then
05:59:49 <pakaran> and also not like putting a print statemet iin the function saying "f called with args..."
05:59:59 <dcoutts> Zao: tab completion ftw!
06:00:08 <Saizan_> bastl: are you going via cabal-install? "cabal install" and "runghc Setup install" aren't the same
06:00:11 <bastl> Saizan: it was not configured with the prefix. im not used to being not root :-)
06:00:37 <bastl> Saizan: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4844#a4844
07:07:11 <byorgey> anyone know the whereabouts of a repository for the MonadRandom package?
07:07:28 <byorgey> Cale?
07:07:54 <byorgey> it says the maintainer is ekidd but I haven't seen him around here in a long time.
07:08:16 <Cale> byorgey: I think we've effectively just been using hackage for that purpose.
07:08:43 <byorgey> Cale: ok.  I'm asking because I want to submit a patch adding an Applicative instance for Rand.
07:08:52 <byorgey> or you could just add it =)
07:09:02 <Cale> byorgey: Feel free to just push the new version to hackage :)
07:09:07 <byorgey> heh, ok =)
07:09:14 <byorgey> will do
07:11:37 * hackagebot upload: hpage 0.4 - A scrapbook for Haskell developers (FernandoBenavides)
07:12:52 <quicksilver> "....The library fills some of the gaps in JavaScript and has features that ameliorate a number of the language's historical weaknesses. For example, it has a mechanism that brings conventional object-oriented inheritance to JavaScript....
07:13:11 <quicksilver> great! so let's "improve" our language by importing mistakes from other systems!
07:13:20 <quicksilver> we should do that in haskell too :)
07:13:59 <Rotaerk> conventional object oriented inheritance is a mistake?
07:14:18 <Rotaerk> I dunno... seems better than the prototyping pattern
07:14:28 <quicksilver> yes, one of the greatest mistakes of the mainstream languages
07:14:44 <Rotaerk> hmm.. howso?
07:14:49 <quicksilver> abuses of implementation inheritance are an even worse problem than abuses of typeclasses :)
07:15:06 <Rotaerk> prevalence of abuse of X doesn't make X a mistake
07:15:13 <quicksilver> erm, well the short version is that there is no abstraction
07:15:26 <zygospasm> only if you do it wrong :)
07:15:30 <quicksilver> you can't usefully subclass something without knowing pretty much internal details of it
07:15:48 <zygospasm> but yeah, it's done wrong a lot (most?) of the time :)
07:15:58 <Rotaerk> quicksilver, no, you only need to know the preconditions and postconditions of the methods you're overriding
07:16:12 <Rotaerk> so that you can require at most that much and guarantee at least that much
07:16:19 <zygospasm> people think about the interface they expose to users of their class, but often don't think about the interface they expose to inheritors
07:16:34 <quicksilver> well the problematic case is when you call the inherited method, Rotaerk
07:16:41 <quicksilver> if you overide the inherited method completely that's not so bad.
07:16:56 <quicksilver> but if you call the inherited case, you need to know how much work to do before you call it, and how much after
07:17:12 <quicksilver> but, what zygospasm said too.
07:17:41 <aug_triad> Hi. I have installed the C++ library libsvm-2.9 and the bindings for Haskell HSvm-0.1.0.2.89. When using the library, I get the following error: Loading package HSvm-0.1.0.2.89 ... can't load .so/.DLL for: stdc++ (dlopen(libstdc++.dylib, 9): image not found). I have these files in usr/lib I have the following files: libstdc++.6.0.9.dylib, libstdc++.6.dylib (using Mac OS 10.6) Can anybody help me?
07:17:46 <zygospasm> a common bug is (in a base class member) 1) mess with members and break class invariant, 2) call virtual function, 3) do stuff to restore invariant
07:18:05 <zygospasm> then 2 calls back into the base class, and all hell breaks loose because the class invariant doesn't hold
07:18:15 <Rotaerk> quicksilver, what do you mean "if you override the inherited method completely"?  that's how overrides work
07:18:19 <Rotaerk> you don't partially override a method
07:18:55 <zygospasm> i think quicksilver is talking about the opposite bug, where a derived class member breaks the derived class invariant, then calls the base class member (which calls back into the derived class)
07:19:06 <byorgey> hmm, hackage gives me a "400 Error in upload"
07:19:06 <ski> (iirc Eiffel has the idea of allowing extendable methods to mark where derived classes may add functionality, instead of vice versa)
07:19:41 <byorgey> is this a known issue at the moment?
07:19:51 <quicksilver> Rotaerk: I mean foo() { .. do some stuff ...; inherited::foo(); ... do some more stuff .. }
07:20:22 <quicksilver> Rotaerk: getting the safe point for that call to inherited::foo is difficult with virtual calls going 'back and forth' between base and derived.
07:20:34 <fasta> Is there an easy way to do regular expressions without putting it in a file using ghc from the command line?
07:20:43 <quicksilver> ...and, ultimately, to get it perfectly right you need to understand the internals of the code you're deriving from.
07:20:52 <byorgey> aug_triad: it seems like it's looking specifically for a file called  libstdc++.dylib;  maybe try making that a symlink to one of the existing .dylib files?
07:21:04 <byorgey> aug_triad: I have no idea, really, but perhaps worth trying =)
07:21:23 <Rotaerk> quicksilver, all you need to know is the same things that public users of the base class know: its pre and post conditions
07:21:43 <aug_triad> fasta: yes, look at http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
07:21:59 <zygospasm> quicksilver: i don't think that's completely true. there's another approach, which is simple: your class's invariant must hold at any point you call unknown code. calls to the base class count as unknown code.
07:22:12 <quicksilver> zygospasm: simple to state, yes.
07:22:26 <quicksilver> zygospasm: not necessarily simple to follow and certainly not followed in practice by plenty of real code
07:22:29 <aug_triad> byorgey: ok, I'll try
07:22:32 <zygospasm> yeah, sorry, simple to state is all i meant by simple ;-)
07:22:44 <zygospasm> simple but hard
07:22:45 <quicksilver> zygospasm: including code in books and tutorials and places which teach people "how to do" inheritance :)
07:22:58 <quicksilver> Rotaerk: zygospasm stated it better than me.
07:23:04 <fasta> aug_triad, where does that say how to use it as a script replacement. I am well aware of the library.
07:23:07 <quicksilver> IIRC there are some reasonable discussions in http://lambda-the-ultimate.org/node/2103
07:23:47 <fasta> aug_triad, I know I can ghc -e '3 +3'. I want to do ghc -e 'import Foo; foo'
07:25:20 <aug_triad> fasta: sorry, I don't know :(
07:25:28 <Rotaerk> quicksilver, zygospasm described a policy that prevents the problem you were describing
07:26:10 <Rotaerk> OO mechanisms in mainstream languages *can* be abused, and your problem is just one possible abuse; to use them correctly you have to follow certain policies
07:26:15 <Rotaerk> such as the SOLID principles of OO
07:26:54 <quicksilver> Rotaerk: Yes, agreed. Simply highlighting a common abuse does not invalidate a paradigm.
07:26:58 <Saizan_> Rotaerk: http://okmij.org/ftp/Computation/Subtyping/ <- about solid priciples of OO :)
07:27:09 <quicksilver> of course you have to balance the common abuse against the advantages
07:27:27 <quicksilver> which is an interesting discussion, although not one I have time to run through today :)
07:27:46 <Rotaerk> Saizan_, I think I've read that article before
07:27:55 <Saizan_> if you always think like zygospasm suggests you're getting something much more similar to typeclasses
07:27:59 <Rotaerk> and iirc they don't understand the SOLID principles
07:28:13 <Rotaerk> particularly liskov substitution
07:29:10 <Saizan_> Rotaerk: the idea of that page is that OO is not teached talking about liskov substitution, and that guaranteeing it with the usual OO style is pretty hard
07:29:50 <Rotaerk> Saizan_, the same problems occur with typeclasses
07:30:12 <Rotaerk> liskov substitution is important with TC's and it's easy to mess that up
07:30:40 <Rotaerk> I mean, monads for instance have certain implicit requirements/expectations for HOW you implement the monad type class
07:30:40 <Saizan_> an example? typeclasses don't provide subtyping
07:31:35 <Rotaerk> Saizan_, liskov substitution is about requiring no more than the interface you're implementing guarantees, and providing no less than the interface promises
07:31:45 <Rotaerk> subtyping is just one way to implement an interface
07:31:55 <Saizan_> right, if i write code using Monad m => i can't pretend it's using the implementation of some base monad, that shifts the paradigm consistently
07:32:51 <aug_triad> member:byorgey: thank you, that worked!
07:32:53 <Rotaerk> point is that the language can never guarantee liskov substitution unless all semantics are represented by the language
07:32:57 <byorgey> aug_triad: great!
07:33:04 <Saizan_> OTOH if my monad is a concrete type it won't use code from some other instance
07:33:33 <Rotaerk> separate issue entirely from liskov substitution
07:33:37 <cepstrum> Øv!
07:33:52 <Rotaerk> but perhaps an advantage of typeclasses over OO inheritance
07:34:33 <Saizan_> my point is that you've to worry much more about liskov substitution using OO inheritance than typeclasses
07:35:05 <Rotaerk> I don't agree; it doesn't address the issue any better than OO inheritance
07:35:35 <Saizan_> it's getting less often into it :)
07:35:59 <Rotaerk> perhaps because haskell is brainy, and brainy people tend to make the mistake less often :P
07:36:47 * hackagebot upload: hlint 1.6.12 - Source code suggestions (NeilMitchell)
07:37:31 <Rotaerk> trying to find those implicit requirements of monads to be more specific
07:37:44 <Saizan_> the crucial point seems to be that you don't have open recursion, so you don't have to worry about if this.foo() is overridable or not everytime you make a call
07:38:03 <Saizan_> you mean the monad laws?
07:38:23 <Rotaerk> ah yea those
07:38:34 <Rotaerk> if you break those laws, you're breaking liskov substitution
07:38:42 <Saizan_> the fact that typeclasses often have laws and OO classes don't is due to their different focus, imo.
07:38:58 <Rotaerk> which is the same exact problem with OO inheritance
07:39:08 <Saizan_> typeclasses need to have laws, since there's not base class to refer to
07:39:15 <Rotaerk> i.e. that you have to have laws rather than code that enforce rules for how you can override
07:39:15 <Saizan_> *no
07:39:38 <Rotaerk> base classes have "laws" too, called their contract
07:39:48 <Saizan_> in practice they often don't
07:40:10 <Saizan_> and it's not even what's commonly teached as OO good style
07:40:33 <Rotaerk> I'm not saying OO is taught well
07:41:42 <Saizan_> well, the idea is that it's harder to make that mistake with typeclasses
07:41:53 <Saizan_> i.e. not specifying laws
07:42:07 <Rotaerk> I'm still not seeing why; the monad typeclass doesn't specify laws
07:42:13 <Saizan_> it does
07:42:27 <Saizan_> they are in the official documentation
07:42:39 <Rotaerk> right, the documentation isn't the typeclass
07:42:53 <Rotaerk> but that's how the "laws" of a base class are also specified... through its documentation
07:43:09 <Rotaerk> the compiler can't enforce it any better in either case
07:43:09 <Saizan_> i'm saying that in OO you often don't get even that :)
07:43:19 <Rotaerk> they simply have to be understood by the writer of the derived class
07:43:31 <Saizan_> i'm not talking about what the compiler can enforce
07:43:39 <Rotaerk> Saizan_, so you're saying it's OO's fault that most developers don't document their code?
07:43:39 <Saizan_> i'm talking about how programmers use them
07:43:58 <Saizan_> Rotaerk: OO inheritance let you do this because there's a base class
07:44:23 <Rotaerk> lets you do what?
07:44:26 <Rotaerk> not document?
07:44:30 <Saizan_> right
07:44:34 <jeltsch> Does anyone know what !! means in data declarations?
07:44:35 <Rotaerk> I'm not sure what you mean
07:44:43 <dolio> You could express the laws as code in a dependently typed language.
07:44:59 <Rotaerk> how does the presence of a base class "let" you not document any more than typeclasses?
07:45:21 <Saizan_> Rotaerk: if Monad had no laws, code that's polymorphic over the monad type would me meaningless, if you have a base class instead you can always refer to its behaviour
07:45:51 <jeltsch> The Haddock documentation for Bytestring shows the following data constructor specification:
07:45:54 <jeltsch> PS !!(ForeignPtr Word8) !!Int !!Int
07:45:55 <zygospasm> one problem is that typeclass laws, or class/function contracts, imply a proof obligation, and most programming languages aren't amenable to writing of proofs
07:45:56 <dolio> jeltsch: It's a Haddock oddity. It's what it generates when a field is marked "{-# UNPACK #-} !a".
07:46:08 <Rotaerk> zygospasm, exactly
07:46:36 <Rotaerk> our disagreement is that I don't think either one handles it any better than the other, but he thinks that typeclasses are somehow better at guaranteeing the contract/laws are followed
07:47:16 <jeltsch> dolio: So it’s on purpose but not valid GHC Haskell?
07:47:46 <Saizan_> Rotaerk: no
07:47:54 <Saizan_> Rotaerk: did you read my last line?
07:48:27 <jmcarthur_work> when i subclass a class or conform to an interface, i make sure i follow whatever "laws" are required to be a good citizen. the same thing applies to type classes. i don't really think there is much difference in that regard
07:49:42 <dolio> jeltsch: I don't know if it's on purpose or a bug.
07:49:51 <dolio> But it isn't valid Haskell.
07:49:58 <Rotaerk> Saizan_, I'm not really sure what that means "you can always refer to its behavior"
07:50:05 <zygospasm> Saizan_: i think there's only a difference there if the base class has some associated state. otherwise its members are no different from mapM on a lawless Monad
07:50:13 <Rotaerk> I agree about "if monad had no laws, code ... meaningless" thoguh
07:50:19 <Rotaerk> which is also true of base classes
07:50:26 <Rotaerk> and interfaces
07:50:55 <Saizan_> i can make an object of the base class and use its methods
07:51:20 <Saizan_> that will probably do something more specific than what the contracts would specify
07:51:24 <zygospasm> Saizan_: can you? it's a fairly common practice that only leaf classes are instantiable
07:52:15 <Rotaerk> it's possible to have a non-abstract base class, but it's all the same
07:52:34 <Saizan_> zygospasm: ok, i can make a leaf class and infer from that
07:52:35 <zygospasm> Saizan_: in principle i agree, though -- because base classes can hold state they can give richer semantics than an interface or a typeclass
07:52:44 <Rotaerk> the base class's behavior will do no less than it guarantees, and require no more than it specifies, if done right
07:53:49 <Rotaerk> subclassing is done when you want to relieve some requirements or provide more guarantees
07:57:01 <Rotaerk> or I guess... the same requirements/guarantees but different side effects
07:57:18 <Rotaerk> which I guess is a guarantee in itself
08:58:52 <fasta> Has anyone actually tested 6.12.1 with packages from Hackage?
08:59:09 <sproingie> i'm about to
08:59:12 <fasta> Or is there a thread somewhere that talks about it?
08:59:27 <sproingie> er nvm i have a 6.12.0 snapshot
08:59:39 <fasta> sproingie, good enough for me.
09:00:04 <sproingie> getting ready to build cabal-install, so just doing the builds by hand i need to do
09:00:12 <sproingie> it'd be nice if cabal-install bundled those actually
09:00:37 <fasta> sproingie, can you try to install parsec3?
09:00:54 <fasta> sproingie, I wrote a script which converts an ordinary Linux machine into a Haskell powered one.
09:01:13 <fasta> sproingie, it only assumes ghc-6.8.2
09:01:37 <fasta> sproingie, but that's because that one was in Jaunty.
09:01:46 * Saizan_ generally upgrades cabal-install with the older ghc first
09:02:07 <benmachine> ghc -e '()' takes about a quarter of a second
09:02:10 <Saizan_> fasta: installing parsec-3.0.1 worked here on the rc1
09:02:19 <benmachine> are there any ways to run haskell with lower overheads?
09:02:27 <fasta> Saizan_, can I give you a list?
09:02:41 <seanmcl> is there a way to run two commands in a row in ghci.  I want to do ":stepmodule ; :list" over and over
09:02:46 <Saizan_> fasta: if it's not too long :P
09:02:58 <fasta> Saizan_, about 20.
09:03:02 <fasta> Saizan_, quite long.
09:03:41 <Saizan_> fasta: this machine is not so stable atm, so i'd pass
09:04:16 <sproingie> bleh, there's a whole hairball of dependencies to do yet, but seeing's how parsec is among them...
09:04:30 <fasta> Saizan_, ok, sure. I think I will just stick to 6.10.4 to be on the safe side for a while then.
09:05:07 <fasta> Did they bump base btw?
09:05:22 <fasta> Or anything which affects Cabal?
09:05:30 * benmachine wonders how invoking ghc with no arguments manages to take 140 milliseconds
09:05:48 <fasta> benmachine, initializing the RTS?
09:05:59 <fasta> benmachine, c.f. Java.
09:06:00 <benmachine> guess so
09:06:04 <Saizan_> bumped base yeah
09:06:14 <Saizan_> benmachine: reading the package db is a big one
09:06:20 <fasta> Saizan_, ok, so all package managers that don't pay attention don't work.
09:06:27 <benmachine> Saizan_: why's it need to do that if it has no input files
09:06:34 <fasta> all the packages by package maintainers*
09:06:48 <Saizan_> fasta: not 4 to 5, only 4.1 to 4.2, maybe the changes are not so dramatic :)
09:07:06 <fasta> So, what do most packages specify?
09:07:33 <Saizan_> most just >=3 i think, but "good policy" was >= 4 && < 5
09:07:45 <sproingie> fasta: parsec builds without a hitch
09:08:11 <fasta> Saizan_, oh, so besides real API breakages it should just work. Nice.
09:08:16 <fasta> That changes things.
09:08:59 <Saizan_> fasta: actually, i generally found more cases where the specified deps were too optimistic than the other way around
09:09:14 <Saizan_> but i see your point :)
09:21:18 <mreh> hello gang
09:22:00 <mreh> my systems administrator was installing the haskell platform system wide, couldn't find any pages for installing cabal
09:22:42 <mreh> I was assuming that if he installs it that cabal is smart enough to work in each users individual workspace, that has atleast been my experience on my own system
09:22:44 <copumpkin> haskell platform comes with cabal install
09:23:00 <fasta> mreh, *nix?
09:23:06 <mreh> fasta: yes
09:23:08 <mreh> os 2
09:23:10 <Vulpyne> Yeah, unless you specify --global it'll try to use the user's home directory.
09:23:19 <Vulpyne> When you use cabal install.
09:23:48 <mreh> does GHC 6.10 not come with cabal?
09:24:15 <sproingie> comes with the cabal library, not cabal install
09:24:30 <fasta> mreh, no experience iwth os 2, sorry.
09:24:47 <mreh> right, of course, everything you need atleast to get it started
09:26:36 <Saizan_> cabal the executable comes from the cabal-install package which is included in the haskell platform, and not in the ghc distribution
09:27:54 <mreh> he has installed the platform, so he should be able to follow the instructions for cabal
09:30:19 <Saizan_> by "for cabal" you mean to use cabal or to install it?
09:30:52 <Saizan_> because if he has installed the platform, anything called cabal should be already installed :)
09:32:29 <Vulpyne> Hmm. If I've created a monad transformer that does networkish stuff, and I want to be able to bind event handlers when certain things happen, what sort of type could it have? For example an event handler could have type "EventSocketT (StateT TestState IO) ()" but normal functions in the transformer have "EventSocket m ()".
09:32:51 <Vulpyne> I'm not sure if it's even possible to run something at a different level of the stack.
09:34:10 <Saizan_> running something at a different level is done by appropriate use of "lift"
09:34:22 <Saizan_> though i'm not sure how that fits with the rest
09:34:23 <SubStack> IT'S A UNIX SYSTEM. I KNOW THIS.
09:34:28 <SubStack> wups
09:34:42 <Vulpyne> I'm not sure I explained what I was trying to do clearly. :/
09:35:04 <sproingie> SubStack: cut from the final reel was "oh wait, it's IRIX, never mind, I don't know this"
09:35:18 <Vulpyne> But something using my stack could run like "runStateT (runEventSocketT func) somestate"
09:35:19 <SubStack> heh
09:35:38 <Vulpyne> And I want to register a monadic action in that context, inside EventSocketT to run when the appropriate event is triggered.
09:35:56 <Vulpyne> EventSocketT is basically ErrorT (StateT IO)
09:36:11 <Vulpyne> So I would need to store that action that runs at a different level inside my state.
09:37:11 <Saizan_> you mean MonadIO m => ErrorT e (StateT s m)?
09:38:13 <Vulpyne> As the type of EventSocketT?
09:38:47 <Saizan_> as its definition, yeah
09:39:14 <Saizan_> i don't see how it can have IO there since it's a tranformer
09:39:27 <Vulpyne> It is that type, although e and s and bound to specific types. It's a newtype: newtype EventSocketT m a = EventSocketT { unEventSocketT ::  ErrorT EventSocketError (StateT EventSocketState m) a } deriving (Monad, MonadIO, MonadState EventSocketState, MonadError EventSocketError)
09:40:19 <Vulpyne> Which is run like: runEventSocketT (EventSocketT ma) s = runStateT (runErrorT ma) s
09:40:25 <Saizan_> k
09:40:37 <Vulpyne> But stuff that uses it make wrap it in other monads, like their own state.
09:40:56 <Vulpyne> I have that much working.
09:40:58 <Saizan_> should the callbacks have access to the EvenSocketT features when run, or not?
09:41:15 <Saizan_> ok
09:41:28 <Vulpyne> Well, they should run like they ran at the lowest level of the stack.
09:41:36 <Vulpyne> ie, they wouldn't have access to EventSocketT's internal state.
09:41:55 <Vulpyne> But they would have access to the state of the enclosing monads (if there were any)
09:42:08 <Vulpyne> So they'd basically run in the same context as the routine that registered them.
09:42:59 <Saizan_> ok, then i'd make them live in the "m" monad, and let the registering code deal with stripping the higher layers
09:44:16 <Saizan_> though that's not so nice actually, since it won't work well for transformers like StateT
09:44:32 <Saizan_> Vulpyne: are you using threads here?
09:45:07 <Vulpyne> Not within a context.
09:45:33 <Vulpyne> It's basically for a network server type thing (for the FreeSwitch telephony software EventSocket interface).
09:45:44 <Vulpyne> So it'll forkIO a handler for each one, but each one will have a new state, etc.
09:46:50 <Saizan_> Vulpyne: it seems you're in this situation http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
09:48:23 <Vulpyne> Yikes, that is complicated.
09:48:34 <Phyx-> wow, using the ghc api just added an extra 22mb to my program size
09:48:34 <Phyx-> lol
09:48:44 <Vulpyne> Did you try stripping? :)
09:48:58 <sproingie> oh my
09:49:39 <Vulpyne> Saizan_: I think forgetting about event handlers may be the best plan in this situation. :)
09:49:41 <Jafet> Stripping? Remember to share links!
09:49:58 <Saizan_> Vulpyne: well, if the callbacks don't have to communicate back to the code that registered them via e.g. StateT then it's easy
09:50:14 <Vulpyne> Unfortunately, I don't think they would be very useful if they didn't.
09:50:39 <Saizan_> the short answer is that they can by using an IORef
09:50:41 <Vulpyne> It all happens synchronously, so I'm not sure why it should be so hard.
09:50:51 <sproingie> isn't FRP considered the usual approach to this problem?
09:51:13 <Saizan_> sproingie: yes, given a working implementation
09:51:14 <sproingie> tho i guess that's hard to keep synchronous
09:51:16 <Vulpyne> Like the thing using EventSocketT will call registerevent blah, then it will call readevents, and during readevents, the handlers could be triggered.
09:51:19 <Phyx-> Jafet: speak for yourself!
09:51:20 <Vulpyne> So there's no asynchrony at all.
09:52:07 <Saizan_> Vulpyne: the problem is making the EventSocketT >>= know that it also should deal with threading someone's else state
09:53:44 <Vulpyne> Yeah...
09:54:10 <Vulpyne> Well, I appreciate the help.
09:54:18 <Saizan_> so, you can work around that by using an IORef
09:54:46 <Vulpyne> I think I will just scrap the idea of callbacks.
09:55:21 <Vulpyne> The routine can return the list of messages it got, and the person using the monad can write their own event triggering thing from that if they want.
10:29:15 <defun> Hi. Is anyone here (or not here) working on DTrace Probes/Providers for GHC/Haskell? Want to check that I'm not duplicating effort.
10:30:58 <seanmcl> I'm trying to build a library that uses Template Haskell with profiling on.  I get the following error message.  I have no idea what it means
10:30:59 <seanmcl> Dynamic linking required, but this is a non-standard build (eg. prof).
10:30:59 <seanmcl>     You need to build the program twice: once the normal way, and then
10:31:00 <seanmcl>     in the desired way using -osuf to set the object file suffix.
10:31:02 <Phyx-> Is there such a thing as a "
10:31:05 <Phyx-> Is there such a thing as a "change log"
10:31:12 <Phyx-> Is there such a thing as a "change log" for haskell packages?
10:31:16 <seanmcl> any ideas
10:31:17 <seanmcl> ?
10:31:47 <defun> I guess not :)
10:32:20 <maltem> Phyx-, you mean on hackage? no afaik, and that's quite of a pity. Sometimes you keep googling for release notes
10:32:39 <seanmcl> sorry
10:32:40 <seanmcl> http://haskell.org/ghc/docs/6.10.2/html/users_guide/template-haskell.html
10:32:57 <Phyx-> maltem: yeah, I think it's a shame too, would be a nice addition
10:34:22 <zygospasm> Phyx-: has someone fmapped inits into your IRC client? :)
10:35:20 <Phyx-> zygospasm: nah, I was suffering from premature enter-pressing
10:35:39 <zygospasm> Phyx-: i keep getting spam about pills that'll sort that out...
10:36:21 <Phyx-> zygospasm: lol
10:36:35 * Phyx- upgrades his haskell-src-exts
10:36:53 <Phyx-> hope the GSOC was successful in that it has usefull comments now
10:37:52 <Phyx-> hrm.. it's really hard to see what's changed... if any
10:39:08 <nibro> Phyx-: there's a lot of change :)
10:39:36 <nibro> Phyx-: feel free to ask me if there's anything particular you're looking for
10:40:07 <nibro> Phyx-: but yes, there's comment support, albeit nothing fancy
10:42:39 <Phyx-> nibro: i'm  basically using it in a pre-processor of mine, and there were 2 things that where kinda odd. in the SrcLoc of almost everything (had version 1.1.0) it seemed to report "<unknown.hs>" as the source file
10:43:18 <Phyx-> and the numbering of the linenumbers of the comments were a bit odd, i was expecting them to still be the line numbers they were in the original file
10:43:37 <Phyx-> those were my two issues mostly
10:44:04 <reltuk> what is an idiomatic way to apply a (a->b,c->d) to a (a,c) and get a (b,d)?
10:44:20 <nibro> Phyx-: the source file reported will be the source file given to the parse state, which when using parseFile et al will be the filename given
10:44:58 <nibro> Phyx-: the line number issue sounds odd indeed - do you have an example file that shows the problem?
10:45:03 <Saizan_> reltuk: (***)
10:45:14 <zygospasm> @type uncurry (***)
10:45:15 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
10:45:20 <nibro> Phyx-: (or perhaps file a bug report? :-))
10:45:23 <benmachine> > uncurry (***) (succ, pred) (1, 10)
10:45:24 <lambdabot>   (2,9)
10:45:41 <zygospasm> @type uncurry (***) :: (a->b, c->d) -> (a, c) -> (b, d)
10:45:42 <Phyx-> nibro: :) where do i file one for src-exts?
10:45:42 <lambdabot> forall a b c d. (a -> b, c -> d) -> (a, c) -> (b, d)
10:45:53 <nibro> http://trac.haskell.org/haskell-src-exts
10:46:05 <reltuk> brilliant...how do you learn all these :-p
10:46:16 <benmachine> slowly
10:46:18 <benmachine> but surely
10:46:19 <zygospasm> reltuk: there aren't all that many which are actually useful :)
10:46:21 <nibro> Phyx-: you'll need an account due to spam issues
10:46:50 <Phyx-> nibro: ah ok, i've just updated to the 1.3.0 i'll test and see if the problem still exists if so, i'll file it
10:47:04 <nibro> Phyx-: :)
10:50:01 <Phyx-> heheh
10:50:04 <Phyx-> i can see that alot changed
10:50:09 <Phyx-> my code no longer compiles
10:50:09 <Phyx-> :P
10:52:09 <Phyx-> nibro: small question, in the new Command adt, there's no multiline and single line constructor anymore. does the new boolean indicate which it was? or? there's no comment there :P
10:52:41 <nibro> Phyx-: oops :)
10:52:49 <nibro> yes, the boolean indicates which is which
10:53:18 <Phyx-> ah cool :) let me test the comment numbering now
10:59:03 <mtnviewmark> wonders if there is some similar "clever" way to get the equivalent of this function
10:59:09 <mtnviewmark> swap (a, b) = (b, a)
10:59:21 <mtnviewmark> (similar to the uncurry (***) thing)
10:59:34 <Cale> :t uncurry . flip (,)
10:59:35 <lambdabot>     Couldn't match expected type `b -> c'
10:59:35 <lambdabot>            against inferred type `(a, b1)'
10:59:35 <lambdabot>     In the first argument of `flip', namely `(,)'
10:59:37 <Cale> er
10:59:42 <camio> @pl \(a,b) -> (b,a)
10:59:43 <lambdabot> uncurry (flip (,))
10:59:46 <Cale> :t uncurry (flip (,))
10:59:47 <lambdabot> forall b a. (a, b) -> (b, a)
10:59:49 <Cale> yeah
11:00:17 <mtnviewmark> what is @pl ?
11:00:29 <camio> @help
11:00:30 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:00:35 <koeien> tries to give a pointfree representation of a function
11:00:37 <camio> @help pl
11:00:38 <lambdabot> pointless <expr>. Play with pointfree code.
11:00:38 <koeien> @pl (\x -> x + 37)
11:00:38 <lambdabot> (37 +)
11:00:53 <kmc_> hmm, it knows (+) is commutative?
11:00:59 <kmc_> @pl (\x y -> y + x)
11:01:00 <lambdabot> (+)
11:01:00 <mtnviewmark> hmm,,, seems a little magical that it could infer uncury (flip (,))
11:01:05 <koeien> kmc_: no, this is incorrect
11:01:14 <koeien> it is a heuristic i guess
11:01:15 <ben_m> Haskell is backed on magic
11:01:56 <mtnviewmark> well, I have to say,    uncurry (flip (,)) somePair     is pretty bad on the readability front
11:01:58 <absentia> I like how Haskell is named Haskell and not Curry becausae of the Rocky Horror Picture Show.
11:02:01 <mtnviewmark> and if I'm going to define a func
11:02:03 <camio> @pl \x y -> x (x y)
11:02:04 <lambdabot> join (.)
11:02:10 <absentia> sounds like an awesome interview question.
11:02:13 <mtnviewmark> swap = uncurry (flip (,))
11:02:19 <mtnviewmark> is not nearly and simple as
11:02:23 <kmc_> absentia, didn't know that
11:02:23 <mtnviewmark> swap (a,b) = (b,a)
11:02:27 <kmc_> mtnviewmark, agreed
11:02:31 <absentia> although, if you're lucky enough to get ANYONE who knows haskell... who's looking for a job... you're probably better off grabbing them while you ahve a chance.
11:02:35 <koeien> mtnviewmark: no, that's why "pointfree" is sometimes called "pointless"
11:02:58 <kmc_> it's a fine line
11:03:06 <camio> There are several who really love pointless code way better than code with a point.
11:03:09 <mtnviewmark> heh - though *sometimes* I think something looks really clear when pointfree
11:03:21 <koeien> yes, most certainly
11:03:50 <mtnviewmark> really - I bet there would be less arguments, had Haskell not choosen such an ugly typographic glyph for ($)
11:04:06 <camio> indeed
11:04:10 <Cale> The glyph is not the problem with $
11:04:19 <Cale> The choice of associativity is worse ;)
11:04:23 <kmc_> it's a fine glyph
11:04:30 <lament> i like money
11:04:40 <mtnviewmark> well... when I see arguments like  (a . b . c . d) x    vs.   a $ b $ c $ d x
11:04:49 <camio> I was a member of the pointless fan club for a while. It was very useful in learning lots of nice combinators. I think most could benefit from going through a pointless stage.
11:04:55 <mtnviewmark> I think -- ya know, we wouldn't dislike the later so much if $ wasn't so darn ugly
11:05:00 <Cale> mtnviewmark: Normally I'd write  a . b . c . d $ x
11:05:00 <kmc_> > let (£) = ($) in succ £ succ 0
11:05:02 <lambdabot>   2
11:05:22 <idnar> hahaha
11:05:27 <Cale> mtnviewmark: The important thing is that b . c in that is a well-typed expression, while b $ c is meaningless.
11:05:34 <Vanadium> > let (€) = flip ($) in 0 € succ € succ
11:05:36 <lambdabot>   2
11:05:41 <ben_m> ... wtf
11:05:51 <kmc_> > let (€) = elem in 2 € [1..4]
11:05:52 <lambdabot>   True
11:05:58 <Vanadium> noo :,
11:06:04 <mtnviewmark> heh
11:06:14 <ben_m> can't load .so/.DLL for: ncurses (/usr/lib/libncurses.so: file too short)
11:06:15 <Vanadium> ∈
11:06:21 <ben_m> hscurses fail :(
11:06:38 <mtnviewmark> tries to imagine what the rupee ₨ operator would do....
11:07:37 <kmc_> > let (¥) = fix in
11:07:39 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:07:41 <monochrom> I suggest the crazy idea of using both U+0020 (space) and U+00A0 (&nbsp;) for application, with different precedences, let's say U+00A0 replaces $
11:07:41 <kmc_> :)
11:07:50 <aleator> This is really silly question, but how do you read criterions csv output?
11:08:17 <zygospasm> swap (a, b) = (b, a) should really be in the Prelude
11:08:34 <koeien> zygospasm: i seldom find the need for this
11:08:59 <twanvl> it should at least be in Data.Tuple
11:09:05 <mtnviewmark> when dealing with Data.Map --- I found it sometimes comes in quite handy
11:09:11 <monochrom> Every function implemantable in 140 words or less should be in the Prelude.
11:09:41 <mtnviewmark> can you write a function that generates them all?  in 140 words or less???
11:10:17 <lament> what about "the function with the smallest definition not expressible in 140 words???"
11:10:34 <zygospasm> lament: that's in the prelude, under the name 'undefined'.
11:10:38 <int-e> how do you count string constants?
11:11:27 <int-e> i.e. is "asdoiaoicjopcodipeqaaydjadiaoieuyneuiwdbhyoaeiu" a word?
11:12:13 <jfoutz> > words "asdoiaoicjopcodipeqaaydjadiaoieuyneuiwdbhyoaeiu"
11:12:14 <lambdabot>   ["asdoiaoicjopcodipeqaaydjadiaoieuyneuiwdbhyoaeiu"]
11:12:17 <jfoutz> yup.
11:12:32 <zygospasm> are these 140 words allowed to include other Prelude functions of under 140 words?
11:12:42 <lament> yes.
11:12:43 <jfoutz> yes.
11:13:16 * int-e ponders building a UTM ... or universal lambda term, as it may be. The type system will get in the way though.
11:14:11 <int-e> foo :: a; foo = unsafeCoerce $ utm "descriptionoffunction" ?
11:15:39 <kmc_> , pp [| "asdoiaoicjopcodipeqaaydjadiaoieuyneuiwdbhyoaeiu" |]
11:15:41 <lunabot>  luna: No instances for (Data.Data.Data Language.Haskell.TH.Lib.ExpQ,
11:15:50 <kmc_> , pp $ runQ [| "asdoiaoicjopcodipeqaaydjadiaoieuyneuiwdbhyoaeiu" |]
11:15:51 <lunabot>  luna: No instances for (Data.Data.Data
11:15:55 <kmc_> fuck it
11:16:08 * shapr boings cheerfully
11:16:17 * sproingie sproings
11:16:27 <shapr> hiya sproingie !
11:16:47 * sproingie is a sad sproingie.  kitty is very sick.
11:16:59 * int-e throws a broken sugar lambda at shapr (it's missing a leg so it looks like a backslash)
11:19:00 <spink> hi, I have 2 questions. 1) Are guards with ghc && flag -O3 faster that if-then-else. 2)If in a bigger function I use some smaller functions of mine, should I declare the small ones inside the body of the bigger on with a let or not ?
11:19:24 <koeien> 1. probably not. 2. probably not
11:19:37 <koeien> although let x = f y in (x,x) may be faster than (f y, f y)
11:19:58 <Twey> Depends how useful they are
11:19:59 <Gracenotes> what's the current state of the new code generator in GHC?
11:20:01 <kmc_> in that simple case it seems unlikely
11:20:08 <centrinia> What about f y `seq` (f y, f y) ?
11:20:12 <kmc_> for (2) "where" is also an option
11:20:14 <Twey> If they're helpers whose use is limited solely to that function, a where would be appropriate
11:20:30 <Twey> If they're generally handy, I'd advise making them top-level and just hiding them when it comes to exporting
11:20:36 <kmc_> with (1) i seriously doubt there's a difference, but of course you should appeal to the almighty benchmark
11:20:39 <koeien> yes. although on toplevel you can test them using ghci
11:20:43 <Twey> (or even exposing them, if they're useful enough that other people might want to use them too)
11:20:57 <Gracenotes> the only problem with some functions is that the where clauses are a couple of screenfuls down, if you have some lengthy series of monad operations to do
11:21:08 <kmc_> pattern matching on constructors is likely to be faster than guards, if you can express your condiiton that way
11:21:12 <Gracenotes> really long functions.
11:21:31 <kmc_> the problem with "let" and "where" is that both will only attach to a single function equation
11:22:05 <Twey> ‘where’ doesn't
11:22:10 <Twey> ‘where’ attaches to all of them…
11:22:38 <Twey> Gracenotes: If you have a function that long, you're Doing It Wrong
11:22:38 <ryanc_> hey, I'm trying to build a haskell program on ubuntu and i get this: base ==4.* && ==4.* && ==4.* && ==4.* for missing dependencies.  What do i need to install?
11:22:59 <Twey> ryanc_: A newer version of GHC
11:23:00 <kmc_> Twey, no, but it attaches to all guards on a single equation
11:23:07 <Gracenotes> Twey: I'm running into this a bit in GHC compiler source code
11:23:12 <Twey> kmc_: Doesn't it attach to all equations?
11:23:16 <kmc_> not in the test i just ran
11:23:20 <Gracenotes> ("compiler" here modifying "source code", not "GHC")
11:23:22 <Twey> Gracenotes: Nobody said GHC was pretty :þ
11:23:22 <spink>  was trying pattern matching but in haskell the with function "f limit couter" I cannot match "f limit limit". I am only interested in speed for the program I write know and not in the readability of the code
11:23:36 <Twey> Gracenotes: Hyphens love you
11:23:41 <ryanc_> Twey, how do i check the version?
11:23:50 <Twey> GHC compiler–source-code
11:24:00 <Twey> ryanc_: ghc --version would be a start
11:24:01 <kmc_> spink, that's fine, i'd use the guard | counter == limit
11:24:08 <kmc_> but perhaps you can count down and pattern match against 0 instead
11:24:14 <Twey> kmc_: Hum.
11:24:14 <Gracenotes> even with dashes, it's still a bit ambiguous
11:24:21 <ryanc_> Twey, it says 6.8.2
11:24:22 <Twey> Gracenotes: Nope
11:24:23 <Gracenotes> er, hyphens
11:24:41 <Twey> Not if one places the en dash properly
11:25:00 <Phyx-_> nibro: ah, seems the comment lines were fixed somewhere between 1.1.0 and the 1.3.0 :) guess i should update often
11:25:12 <kmc_> spink, do you have profiling results to suggest that this is a speed bottleneck?
11:25:16 <spink> kmc_, that's why I wanted to know if the if-then-else is any faster that guards to replace the guards I use now
11:25:32 * shapr throws sugar omegas at int-e
11:26:10 <Gracenotes> Twey: nonetheless, it looks very unnatural, given that noun modifiers of "source code" rarely occur with hyphens
11:26:19 <BONUS> ls
11:26:22 <BONUS> whoops!
11:26:53 <Gracenotes> awesome-lyah-chapter.htm
11:26:56 <ryanc_> hmm.  crap, well I also have another dependency...  Is there a tutorial anywhere for setting up ghc and everything from source?
11:27:04 <BONUS> haha
11:27:08 <kmc_> ryanc_, did you try the Haskell Platform first?
11:27:17 <Gracenotes> moving GHC a few words forward and putting it in a prepositional phrase would resolve any ambiguity, anyway :
11:27:20 <Gracenotes> :o
11:27:25 <Cale> spink: I would expect if/then/else and an equivalent guard to be compiled to the exact same thing
11:27:25 <spink> kmc_, No I haven't done any profiling, I was more in a way to learn to write faster code
11:27:34 <kmc_> ah
11:27:38 <Cale> spink: they're both translated into case expressions on Bool values
11:27:59 <kmc_> in Haskell, writing faster code is often about unboxing and strictifying stuff
11:28:00 <reltuk> if I've got a data type that has a closed set of instances, and it has functions as members, so can't derive show/read/eq, is it ok to make instances of those classes which return the correct instances based on tags in the datatype?
11:28:05 <kmc_> and using datastrucutres which have done the same
11:28:11 <ryanc_> I am a total n00b to haskell.  I want to use a program called arbtt that's written in haskell.
11:28:16 <kmc_> data types don't have instances (unless you mean type families)
11:28:40 <ryanc_> i will try platform
11:28:52 <kmc_> @where platform
11:28:53 <lambdabot> http://hackage.haskell.org/platform/
11:28:58 <reltuk> kmc_: I mean "values"?
11:29:04 <spink> Cale, I suspect that with the -O3 flag, only little details matter since the compiler does some good work
11:29:15 <ryanc_> kmc, I found it thanks.  the ubuntu packages are too old for the program i want to run
11:29:17 * reltuk hangs head against the oo wall
11:29:20 <Gracenotes> so, what *is* the current state of the 'new' code generator in GHC?
11:29:31 <kmc_> anyway, i'm not sure what you propose about how your show/read would work
11:29:46 <kmc_> if you have an example, you can hpaste it and i'll take a look
11:29:57 <kmc_> in general the type clasess are there for you to define behavior which is useful for your type
11:30:10 <kmc_> they don't have to correspond to what an auto-derived instance would do
11:30:18 <Cale> spink: -O2 you mean :)
11:30:32 <spink> Cale, I use -O3 , is that bad ;
11:30:32 <kmc_> but i doubt you can define a useful Eq for a type holding functions, unless the functions are somehow secondary to what the type represents
11:30:36 <ryanc_> hmm.  It says I need ghc installed first.  will the platform install build a new version of ghc?
11:30:41 <Cale> spink: I think it'll clip to -O2 anyway
11:30:46 <kmc_> -O999
11:30:52 <Cale> spink: In the past, -O3 used to just do nothing at all :P
11:31:04 <Vanadium> -O`fix (+1)`
11:31:40 <kmc_> > fix (+1)
11:31:44 <lambdabot>   mueval-core: Time limit exceeded
11:31:45 <kmc_> > fix (+1) :: Natural
11:31:49 <lambdabot>   mueval-core: Time limit exceeded
11:31:53 <Gracenotes> Vanadium: you'd need -XUndecidableCompilerOptions for that
11:31:54 <kmc_> > fix (1+) :: Natural
11:31:55 <lambdabot>   * Exception: stack overflow
11:32:06 <reltuk> kmc_: I was just wondering if it was idioimatic...it seems to work.  basically there is a finite set of values of this type, so I print out a tag which identifies the value for show and for read I lookup up the value corresponding to that tag
11:32:25 <kmc_> hmm, why are you storing functions then?
11:32:31 <kmc_> can you hpaste your code?
11:32:46 <spink> kmc_, I have for all my functions the type signature and using unboxed arrays. So 2 more questions of mine: Are there unboxed lists like the UArrays and Can I limit my Integer to certain bytes ? e.g. Int4, Int8 etc..
11:33:03 <kmc_> there's Word8, Word16 etc
11:33:04 <kmc_> for bits
11:33:13 <kmc_> you should probably try Int first
11:33:18 <ryanc_> oi, i need ghc to compile ghc? :(
11:33:23 <spink> I use Int now
11:33:30 <kmc_> ah, you said Integer
11:33:31 <koeien> ryanc_: yes
11:33:45 <kmc_> ryanc_, yes, but there's a binary distro of Platform
11:33:47 <spink> kmc_, sorry that was fast typing
11:34:04 <spink> Int == big int in haskell ?
11:34:09 <kmc_> Integer is bigint
11:34:10 <ryanc_> can i build ghc 6.10.4 with 6.8.2?
11:34:11 <kmc_> Int is machine size
11:34:30 <koeien> ryanc_: you can. there is a binary though, that is easier i guess
11:34:38 <kmc_> > maxBound :: Int
11:34:40 <lambdabot>   9223372036854775807
11:35:01 <kmc_> > (log $ fromIntegral (maxBound :: Int)) / (log 2.0)
11:35:03 <lambdabot>   63.0
11:35:04 <spink> oh, got it know :) And [Int] is the faster list type of Int's ?
11:35:10 <kmc_> ?
11:35:19 <kmc_> [Int] is a regular list of Ints
11:35:28 <kmc_> an array is totally different from a list
11:35:55 <kmc_> if you are looking up values by their numerical index, a list is probably terrible
11:36:02 <kmc_> also if you are concatencating sequences
11:36:18 <Gracenotes> Integer operations tend to be pretty fast, since they default to Int operations if they're small enough
11:36:21 <reltuk> kmc_ http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11909
11:36:50 <koeien> Gracenotes: i guess ghc uses gmp for this
11:36:53 <Gracenotes> still, in tight loops you can't entirely remove the wrapper, because it could always be > maxBound::Int
11:37:03 <spink> Actually I update my UArray using a regular list and the '//' operator, because regular lists are easy to handle
11:37:13 <kmc_> reltuk, ah, i see
11:37:22 <Gracenotes> koeien: yeah. though there's a been a push for a home-grown bignum library
11:37:36 <spink> that's the combination of the two that I use , which is fast enough
11:37:51 <Cale> There is a home-grown bignum library which is not so bad, and it's been around quite a while
11:37:57 <Cale> But it's not as fast as GMP
11:38:04 <koeien> what's wrong with GMP?
11:38:09 <kmc_> it seems all right, assuming there will only be one Card structure per cName
11:38:09 <monochrom> license
11:38:12 <Cale> koeien: Licensing.
11:38:13 <koeien> LGPL?
11:38:15 <Cale> yeah
11:38:19 <kmc_> but you could also make that association more explict
11:38:35 <nibro> Phyx-: updating is good :)
11:38:50 <kmc_> pass around CardNames, and rewrite the field accessors cType etc. to take a CardName instead of a Card, and look it up in some single global map
11:39:27 <reltuk> and then card wouldn't ever need read/show/eq
11:39:46 <kmc_> which you have as getCardByName, but that's a linear search
11:39:52 <reltuk> that seems better
11:40:01 <kmc_> which is probably fast enough anyway but you should probably use a Data.Map instead
11:40:27 <defun> Hey, which would be faster? An explicit recursion or mapping over a list? i.e. funcList (x:xs) = func x : funcList xs        OR          funcList list = func <$> list
11:40:37 <reltuk> yeah, this is my first decent sized haskell program so I wasn't worrying too much about efficient :-)
11:40:52 <koeien> defun: probably doesn't matter, but using higher-order functions is preferrable
11:40:58 <kmc_> defun, doubt there's any difference in speed
11:41:03 <kmc_> don't worry about it until you profile
11:41:09 <reltuk> but I like the idea of always using CardNames...right now there's a hodge podge...sometimes they get used, sometimes not
11:41:09 <kmc_> since it's also a simple localized change
11:41:26 <defun> thanks
11:41:51 <monochrom> funcList list = func <$> list  is easier to debug.
11:42:15 <reltuk> also, they shouldn't be records if I really want the set of values to be closed...exposing record accessors is like exposing the constructor
11:43:44 <monochrom> Here is why funcList (x:xs) = func x : funcList xs is harder to debug. So one day you decide to rename funcList to ahYes and at the same time use the name funcList for another function of the same type. So you modify to ahYes (x:xs) = func x : funcList xs  can you see the bug? Will you always see the bug?
11:44:12 <koeien> it is obscuring not to use 'map' here imo
11:47:04 <sproingie> primitive recursion is generally harder to get at a glance.  tho perhaps not for something that trivial.
11:47:08 <FabioTheApe> Do you guys like newbs? I am reading this tutorial that says you do...
11:47:21 <sproingie> FabioTheApe: taste like chicken
11:47:21 <ben_m> I do.
11:47:25 <ben_m> om nom nom
11:47:31 <monochrom> Yes we eat them everyday, they're delicious.
11:47:37 <FabioTheApe> wow...
11:47:44 * FabioTheApe leaves before being consumed
11:47:48 * Twey laughs.
11:47:48 <sproingie> aw
11:47:52 <koeien> lol
11:48:00 <sproingie> we'll just take a little nibble, promise :)
11:48:11 <ben_m> I eat them whole.
11:48:15 <ben_m> don't even chew
11:48:19 <sproingie> well save some for the rest of us
11:48:32 <ben_m> Plenty of newbs for everyone
11:48:35 <sproingie> yay
11:48:39 <ben_m> The feast shall begin!
11:49:00 <sproingie> 'course i'm a noob comparatively speaking
11:49:06 <ben_m> I am too :)
11:49:07 * FabioTheApe hides in a dark place and closes the door...
11:49:25 * FabioTheApe notices how warm it is getting...thinks is this the oven...
11:49:32 <sproingie> man, existential types are about a hojillion times easier to get with GADT syntax
11:49:47 <ben_m> FabioTheApe: You are likely to be eaten by a grue.
11:49:59 <FabioTheApe> grue?
11:50:23 <ben_m> Nevermind :)
11:50:29 <Twey> Heh
11:51:07 <sproingie> i guess one still has to learn the "forall" business since that's what :t will show
11:51:23 <monochrom> You have to learn at least one quantifier.
11:52:08 <sproingie> still, it's nice to declare with GADT syntax then see how it desugars into forall
11:52:52 <sproingie> so how should i describe 'a' in a plain old type Foo a?  monomorphic?  or just "not polymorphic"?
11:53:13 <mauke> Foo a is forall a. Foo a
11:53:32 <sproingie> or just "not polymorphic when instantiated in a list" ... i only sort of get the mechanism that disallows [Just 1, Just "foo"]
11:54:04 <mauke> [Just 1, Just "foo"] is Just 1 : (Just "foo" : [])
11:54:09 <mauke> (:) :: a -> [a] -> [a]
11:54:12 <monochrom> I describe 'a' as type variable. It has all the consequences of variables.
11:54:20 <sproingie> > [Just 1, Just "foo"]
11:54:22 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
11:54:22 <lambdabot>    arising from the literal ...
11:54:40 <mauke> Just :: a -> Maybe a
11:54:57 <mauke> so the type of the list is [Maybe t] for some t
11:55:03 <monochrom> [x,y] :: [Foo a]  implies x::Foo a and y::Foo a, same a. Consequence of being variable.
11:55:05 <sproingie> and only one t
11:55:17 <mauke> "foo" :: [Char] and 1 :: (Num a) => a
11:55:39 <sproingie> so it infers the most specific t it can?
11:55:40 <mauke> so the whole type is (Num [Char]) => [Maybe [Char]]
11:55:45 <mauke> no, the most generic
11:55:50 <koeien> sproingie: no, on the contrary
11:56:04 <mauke> but "foo" is completely monomorphic; it has no variables
11:56:59 <sproingie> so it infers the most generic concrete type then?
11:57:07 <mauke> no, the most generic type
11:57:49 <koeien> :t let len [] = 0; len (_:xs) = 1 + len xs in len -- see how general this is
11:57:50 <lambdabot> forall t t1. (Num t1) => [t] -> t1
11:59:30 <sproingie> ahh, i'm confusing type with class
11:59:51 <jmcarthur_work> you can think of the forall as creating a type level lambda expression which is automatically applied to the appropriate type by the type inference engine
12:00:01 <sproingie> Just 1 and Just "foo" have Show in common, but Show is a class
12:00:01 <FabioTheApe> So a variable is a constan in Haskell?
12:00:07 <jmcarthur_work> forall a . Foo a  ==>  \a -> Foo a
12:00:08 <FabioTheApe> contant*
12:00:16 <koeien> it is a variable
12:00:25 <mauke> depends on your definition of "constant"
12:00:25 <FabioTheApe> but it never changes?
12:00:27 <jmcarthur_work> then the type inference engine would apply it to Int or something
12:00:33 <koeien> but in e.g. a -> a -> a  all a's refer to tyhe same thing, yes
12:00:35 <mauke> FabioTheApe: foo x = 2 * x + 1
12:00:38 <jmcarthur_work> (\a -> Foo a) Int  ==>  Foo Int
12:00:52 <mauke> FabioTheApe: here 'x' is a variable that changes to whatever you call foo with
12:01:06 <FabioTheApe> wth?? lol
12:01:14 <mauke> English, please
12:01:28 <sproingie> FabioTheApe: variables don't vary :)
12:01:36 <FabioTheApe> so they are a cosntant?
12:01:42 <mtnviewmark> x is not a variable - it is an argument
12:01:44 <mauke> > let foo x = 2 * x + 1 in [foo 1, foo 2, foo 3]
12:01:45 <lambdabot>   [3,5,7]
12:01:53 <jmcarthur_work> FabioTheApe, variables are placeholders to be filling in later
12:01:53 <mauke> mtnviewmark: it's a parameter, actually
12:01:56 <jmcarthur_work> *filled
12:01:56 <mtnviewmark> as in the formal name of a parameter to a function
12:01:57 <koeien> > [id "string", id 37]
12:01:58 <mauke> mtnviewmark: and parameters are variables
12:01:58 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
12:01:58 <lambdabot>    arising from the literal ...
12:01:59 <koeien> :t id
12:02:00 <mtnviewmark> heh
12:02:00 <lambdabot> forall a. a -> a
12:02:00 <FabioTheApe> you are frying my brain
12:02:11 <koeien> > (id "string", id 37)
12:02:12 <lambdabot>   ("string",37)
12:02:16 <jmcarthur_work> this is variable in the mathematical sense, not in the C sense
12:02:19 <mauke> FabioTheApe: what programming languages do you know?
12:02:30 <Botje> they should really be called invariable.
12:02:36 <sproingie> FabioTheApe: whether you treat a variable as a placeholder for a pattern or as a constant binding will depend on where and how you use it
12:02:40 <FabioTheApe> java, c++, pascal, VB.net
12:02:47 <mtnviewmark> well, let's ask then -- FabioTheApe - are you coming at this as a Mathematician or a Programmer
12:02:48 <mauke> er, so you should be familiar with functions
12:02:54 <mtnviewmark> and then let's use the appropriate terminology
12:02:55 <sproingie> FabioTheApe: it's just that the one thing you can't treat it as is a box that you can put something else in later
12:03:10 <sproingie> FabioTheApe: haskell has those boxes, it just puts some extra syntax and restrictions on using them
12:03:23 <FabioTheApe> mauke, i always strugled with functon in programming
12:03:26 <koeien> and we try not to use them that often
12:03:33 <mtnviewmark> haskell has those boxes, but we try not to use 'em!
12:03:57 <sproingie> you could write a totally imperative program in the IO monad, it would just look really fugly
12:04:01 <mauke> FabioTheApe: then you don't really know java, c++, or pascal
12:04:19 <jmcarthur_work> FabioTheApe, what would you say is the value of x in "foo x = x + 1"?
12:04:36 <FabioTheApe> well I know the concept, just the syntax screws me up
12:04:54 <sproingie> that just takes a little practice to get used to
12:04:54 <FabioTheApe> we can't deteremine what x is?
12:04:56 <ryanc_> make clean does not in fact clean up haskell platform :(
12:05:05 <sproingie> FabioTheApe: have you read Learn You A Haskell?
12:05:15 <FabioTheApe> sproingie, i am right now
12:05:17 <jmcarthur_work> FabioTheApe, we can when the function is applied, but you are right that we can't determine it just from that definition
12:05:25 <jmcarthur_work> FabioTheApe, that is the sense in which it is a variable
12:06:19 <FabioTheApe> okay
12:06:38 <monochrom> "variable" in haskell is "mathematical variable" rather than "register"
12:07:10 <sproingie> like a variable in algebra
12:07:17 <FabioTheApe> okay
12:09:57 <FabioTheApe> so you don't have to declare your types?
12:10:12 <FabioTheApe> you just say hey a = 4 and it knows that 4 is a integer?
12:10:13 <Phyx-> is there a function, that given a full filepath gives the filename only? no extensions?
12:10:18 <monochrom> correct. optional usually.
12:10:18 <koeien> FabioTheApe: yes
12:10:22 <FabioTheApe> awesome
12:10:23 <tensorpudding> type inference will guess types for you
12:10:30 <koeien> FabioTheApe: it knows that 4 is a "number" in a more general sense
12:10:36 <fax> it does not guess
12:10:46 <FabioTheApe> what about floats, doubles?
12:10:55 <Phyx-> @hoogle "filename"
12:10:56 <lambdabot> Parse error:
12:10:56 <lambdabot>   --count=20 "filename"
12:10:56 <lambdabot>              ^
12:10:56 <FabioTheApe> or should i refer to them as floating point numbers?
12:11:00 <koeien> FabioTheApe: 4 is also a float
12:11:03 <Phyx-> @hoogle filename
12:11:03 <lambdabot> System.Console.Editline.Readline filenameCompletionFunction :: String -> IO [String]
12:11:04 <lambdabot> System.FilePath.Posix dropFileName :: FilePath -> FilePath
12:11:04 <lambdabot> System.FilePath.Windows dropFileName :: FilePath -> FilePath
12:11:11 <koeien> > 4 + 37.5
12:11:12 <lambdabot>   41.5
12:11:13 <tensorpudding> FabioTheApe: there is a large heirarchy of numeric datatypes, organized by typeclasses
12:11:21 <Phyx-> > dropFileName "C:\Foo.hs"
12:11:22 <Gracenotes> data IntList = IntNil | IntCons Int# IntList .. somewhat interesting
12:11:22 <lambdabot>   <no location info>:
12:11:23 <lambdabot>      lexical error in string/character literal at chara...
12:11:27 <ryanc_> trying to make install platform gives me 'The mtl-1.1.0.2/Setup script does not exist or cannot be run' :(
12:11:31 <Phyx-> > dropFileName "Foo.hs"
12:11:33 <lambdabot>   Not in scope: `dropFileName'
12:11:57 <FabioTheApe> tensorpudding, but i don't have to know that? it will take care of it on its own?
12:12:07 <Phyx-> > System.FilePath.Windows.dropFileName "Foo.hs"
12:12:08 <lambdabot>   Not in scope: `System.FilePath.Windows.dropFileName'
12:12:08 <defun> Hey does anyone know of a good 'editor'/'viewer' for editing or viewing raw assembly code?
12:12:20 <defun> Or object code?
12:12:44 <tensorpudding> FabioTheApe: sometimes you have to know that
12:12:50 <tensorpudding> @type sqrt
12:12:51 <lambdabot> forall a. (Floating a) => a -> a
12:13:26 <tensorpudding> sqrt's type signature works on types which are instances of the Floating class
12:13:58 <tensorpudding> @type 5
12:13:59 <lambdabot> forall t. (Num t) => t
12:14:22 <tensorpudding> @type sqrt 5
12:14:24 <lambdabot> forall t. (Floating t) => t
12:14:53 <FabioTheApe> well chapter two.... wish me luck
12:15:53 <tensorpudding> the result of sqrt gives you a type that is an instance of Floating, which is more specific than the class Num
12:15:53 <ryanc_> fount a patch...
12:15:53 <tensorpudding> > (sqrt 5) / 2
12:15:53 <lambdabot>   1.118033988749895
12:15:53 <tensorpudding> hmm, wait, that's not an error...
12:15:53 <tensorpudding> @type (/)
12:15:53 <lambdabot> forall a. (Fractional a) => a -> a -> a
12:15:57 <tensorpudding> @type quot
12:15:59 <lambdabot> forall a. (Integral a) => a -> a -> a
12:16:01 <tensorpudding> ah
12:16:04 <idnar> @type div
12:16:06 <lambdabot> forall a. (Integral a) => a -> a -> a
12:16:13 <tensorpudding> > (sqrt 5) `quot` 2
12:16:15 <lambdabot>   Ambiguous type variable `t' in the constraints:
12:16:15 <lambdabot>    `GHC.Float.Floating t'
12:16:15 <lambdabot>  ...
12:17:06 <ryanc_> yay, cabal install worked :D
12:17:14 <tensorpudding> Integral is a different typeclass, and the type of sqrt 5 is not in Integral
12:17:49 <tensorpudding> there are coersion functions for changing numeric types, like fromIntegral
12:17:50 <koeien> tensorpudding: how do you know this?
12:18:03 <koeien> i could make my own type
12:18:33 <tensorpudding> you are right
12:18:47 <koeien> it would be somewhat perverse
12:18:47 <tensorpudding> you could make a type that is an instance of both Floating and Integral
12:19:59 <tensorpudding> @type fromIntegral
12:20:01 <lambdabot> forall a b. (Integral a, Num b) => a -> b
12:20:57 <FabioTheApe> why is 5 /= 5 false? what does the /= mean?
12:21:05 <tensorpudding> it would seem that this function takes an instance of Integral and returns an instance of Num
12:21:09 <koeien> it is not false
12:21:13 <doublethink_work> FabioTheApe: not equal
12:21:18 <koeien> not equal*
12:21:22 <FabioTheApe> oh okay that is what i thought
12:22:27 <tensorpudding> @type (/=)
12:22:28 <lambdabot> forall a. (Eq a) => a -> a -> Bool
12:25:27 <kmc_> defun, objdump ?
12:25:48 <defun> thanks, will look into it.
12:26:14 <defun> what do the ghc devs use? I've heard that they constantly look at the raw output of ghc...
12:26:32 <Phyx-> @src (/=)
12:26:33 <lambdabot> x /= y = not (x == y)
12:26:37 <Phyx-> :)
12:26:44 <tensorpudding> @src (==)
12:26:45 <lambdabot> x == y = not (x /= y)
12:26:46 <kmc_> FabioTheApe, yes, type inference is awesome
12:26:58 <Phyx-> when it works
12:27:04 <kmc_> types in Haskell exist to help us prove correctness properties about our programs
12:27:08 <FabioTheApe> kmc_ right...
12:27:15 <kmc_> inference means that we only need to specify the properties we care about
12:29:13 <kmc_> much of the arguing you see about static vs. dynamic types is actually about manifest vs. inferred types
12:30:11 <kmc_> Phyx-, when doesn't it work?
12:30:34 <Phyx-> kmc_: higher rank types for instance
12:30:48 <kmc_> yeah
12:30:57 <kmc_> inference should work for just about anything in H98 though
12:31:17 <raim0> what's the current state of ghc and os x 10.6?
12:31:19 <doublethink_work> defun: you have to spend a lot of time looking at Core output, yes
12:31:28 <raim0> do I still need to patch something if I install the haskell platform?
12:31:33 <doublethink_work> defun: i like 'ghc-core' on hackage
12:31:49 <kmc_> inference does make error messages less comprehensible, but you can always put annotations back in
12:31:58 <doublethink_work> raim0: yes, if you install 6.10.x on snow leopard you will have to patch the ghc wrapper and the hsc2hs wrapper
12:32:01 <doublethink_work> but that's all
12:32:24 <doublethink_work> raim0: i'm currently the owner of the bug responsible for porting GHC to snow leopard as 64bit.
12:32:41 <doublethink_work> which is proving to be difficult, apparently according to g-h-u the porting is slightly broken right now
12:33:00 <doublethink_work> which isn't surprising; porting is left to few people, so the code involved in it bitrots quickly and mostly goes untested
12:33:00 <raim0> so isn't ghc currently able to generate 64-bit code or what is this about?
12:33:20 <doublethink_work> ghc can emit 64bit code, it just does not handle the combination of OS X and 64bit, yet
12:33:50 <raim0> what kind of things in the combination are causing problems?
12:34:07 <doublethink_work> there are parts of the RTS that might need to be modified, parts of the compiler, etc.
12:35:17 <doublethink_work> raim0: you see, GHC's RTS etc uses #ifdef a lot :) there are parts that will likely end up slightly broken because the RTS hasn't been modified to work as 64bit on OS X yet
12:35:41 * absentia is on leopard of snow.
12:35:46 <absentia> what's holding it up on 10.6?
12:36:15 <doublethink_work> it works fine as a 32bit application
12:36:16 <benhiller> I've been having some issues with ghci on snow leopard. for some reason the result is printed on the same like as whatever I just typed, any idea what could be causing that?
12:36:28 <absentia> yup. I'm using it as such.
12:36:32 <koeien> benhiller: there was a thread on -cafe about that
12:36:48 <benhiller> ah, thanks, i'll look for that
12:36:50 <doublethink_work> absentia: you need to patch ghc & hsc2hs. ghc 6.12 will not need this and will work out of the box on snow leopard as 32-bit
12:37:08 <doublethink_work> my hopes are to have 64bit snow leopard support in a bugfix release, e.g. 6.12.2
12:37:19 <doublethink_work> because 6.12.1 is pretty much done atm
12:37:38 <benhiller> wow, that was a simple fix, awesome
12:37:40 <absentia> dw: you control that?
12:37:58 <absentia> dw: ya, I read the posts on how to patch, etc.
12:38:27 <doublethink_work> absentia: i'm holding the 64bit OS X ticket, yes
12:38:35 <absentia> cool.
12:38:46 <cocon> Hi, I'm getting "Missing header file: HsDirectory.h" when building 6.12 rc1 from source
12:39:43 <Axman6> benhiller: what was the fix?
12:40:25 <benhiller> oh, in your terminal go to preferences -> settings -> choose your default profile and click the advanced tab, then change what you declare the terminal as, it seems like ansi doesn't work
12:40:29 <FabioTheApe> so in the real world do people write real programs with Haskell?
12:40:41 <arcatan> at least Haskell compilers :)
12:40:45 <Botje> what do you call real programs? :)
12:41:08 <Axman6> FabioTheApe: you haven't heard of Xmonad? Darcs?
12:41:19 <FabioTheApe> like that you would pick up off a shelf and purchase or download
12:41:24 <Axman6> House? (An operating system written in haskell)
12:41:24 <FabioTheApe> Axman6, no
12:41:40 <absentia> house? where?
12:42:05 <tensorpudding> an operating system in haskell?
12:42:12 <Axman6> well, Xmonad is a pretty popular tiling window manager, and Darcs is a distributed revision control system, somewhat like git
12:42:14 <absentia> I would love to boot up into forth w/ tcp support.  gimme that in < 2048bytes and I'm sold.
12:42:16 <FabioTheApe> http://programatica.cs.pdx.edu/House/
12:42:28 <tensorpudding> i googled "house" on accident, that wasn't very helpful
12:42:34 <Axman6> http://programatica.cs.pdx.edu/House/
12:42:44 <absentia> heheh.. pdx.
12:42:52 <tensorpudding> darcs is kinda like a friendlier git
12:43:39 <absentia> nice.
12:43:43 <Axman6> FabioTheApe: GHC is also written in Haskell
12:43:56 <FabioTheApe> GHC being the compiler?
12:43:57 <absentia> I think there's a vast chasm between the complexity of a forth compiler and a haskell compiler :-)
12:44:12 <Twey> GHC being a compiler
12:44:21 <Twey> absentia: Just a little, yes :þ
12:45:03 <tensorpudding> GHC isn't the only Haskell compiler out there...but I can't name any others
12:45:21 <FabioTheApe> hmm so everything is a function, and a variable, and a constant...
12:45:30 <Axman6> nhc, yhc, hugs (not exactly a compiler)
12:45:37 <koeien> uhc :P
12:45:47 <shambler_> or "statement"
12:45:53 <tensorpudding> i remembered hugs but i thought hugs just had an interpreter
12:46:03 <Axman6> it is
12:46:17 <Twey> Jhc
12:46:33 <FabioTheApe> this is messed up
12:46:55 <Axman6> ?
12:47:02 <programble> what is FabioTheApe
12:47:17 <absentia> a user in this channel ?
12:47:19 <FabioTheApe> the whole functional programming language thing...
12:47:28 <FabioTheApe> absentia, i am pretty messed up yes
12:47:38 * absentia is literal to a fault.
12:47:41 <Axman6> haskell's based on lambda calculus, which doesn't require mutable state
12:47:58 <Axman6> FabioTheApe: have you been following a tutorial?
12:48:03 <tensorpudding> haskell is all category-theoretical
12:48:16 <copumpkin> category theory is all haskelly
12:48:16 <shambler_> read about lambda calculus, this is will clear up things a bit
12:48:20 <Axman6> i don't know an ounce of category theory
12:48:25 <FabioTheApe> Axman6, yes learnyouahaskell
12:48:27 <tensorpudding> you have to eat so many bananas your lenses will fall out
12:49:05 <Axman6> FabioTheApe: good choice, keep reading ;) and stick around and ask questions
12:49:05 * programble too
12:49:05 <kmc_> it's worth noting that most of the software in the world is never publically released, let alone for end-user purchase or download
12:49:05 <programble> Learn you a haskell
12:49:05 <FabioTheApe> Axman6, I have been asking lots of questions lol
12:49:13 <Axman6> good!
12:49:58 <kmc_> haskell is still a niche language but it is used for real things, especially implementing domain-specific languages for things like hardware design, cryptography, embedded systems programming, and financial derivatives pricing
12:50:21 <tensorpudding> there's that cryptographic language
12:50:28 <tensorpudding> that is implemented in haskell
12:50:28 <Axman6> cryptol
12:50:31 <tensorpudding> yeah
12:50:33 <Phyx-> niche? i'd think that's as far as you think functional languages are a niche
12:50:33 <tensorpudding> and agda
12:50:45 <kmc_> FabioTheApe, not everything is a function... functions are a subset of all values
12:51:00 <kmc_> a variable is just a name for a value, a name which applies within a certain scope
12:51:06 <tensorpudding> haskell is maybe less well known than erlang, but i'm not sure
12:51:14 <kmc_> it doesn't mean "a box whose value we can update" like in other languages
12:51:26 <kmc_> tensorpudding, someone was saying that there were more Haskellers than Erlangoids at the latest CUFP
12:51:29 <Axman6> tensorpudding: possibly, but it's more popular ;)
12:51:37 <FabioTheApe> heck i barely know spoken languages why am i trying to learn a programming language?
12:51:38 <tensorpudding> i remember hearing about that
12:51:47 <koeien> FabioTheApe: programming languages are easier
12:51:53 <Axman6> FabioTheApe: because they will expant your mind
12:52:00 <monochrom> haskell is more well-known than erlang. proof: reddit members talk about "who hates haskell" but not "who hates erlang"
12:52:02 <FabioTheApe> that was  a joke
12:52:02 <absentia> to me, erlang seems much more problem domain limited .. than haskell
12:52:03 <Axman6> expand*
12:52:03 <koeien> but i recommend to also learn natural languages ;)
12:52:19 <tensorpudding> reddit is not really a great slice of the population...
12:52:20 <monochrom> slashdot has a "haskell again" tag but no "erlang again" tag.
12:52:22 <Axman6> absentia: i agree
12:52:32 <koeien> monochrom: well, there are the languages that everybody complains about, and...
12:52:35 <FabioTheApe> I speak in binary only
12:52:43 <sproingie> slashdot's tags make no sense anyway
12:52:51 <FabioTheApe> 010100101
12:52:57 <kmc_> "binary" is not a complete language unless the only concepts you want to express are "one" and "zero"
12:53:04 <absentia> haskell's main/only issue I see is barrier to entry.
12:53:08 <jmcarthur_work> 00000010000001000011111001001001001
12:53:17 <sproingie> jmcarthur_work: watch yo mouth!
12:53:25 <lament> absentia: that's not an issue, that's a consequence of issues
12:53:27 <tensorpudding> haskell is different enough from other popular languages to be confusing
12:53:43 <kmc_> i think the issue is more the difficulty of finding good haskell programmers to employ
12:53:48 <monochrom> It is not barrier. It is advancedness.
12:53:50 <tensorpudding> but RWH seems to do a good job of explaining it so far, as far as I've read
12:53:51 <Zao> kmc_: Even more so amusing is when they use silly encodings.
12:53:52 * Axman6 thinks other languages are different enough from haskell to be confusing
12:53:55 <absentia> lament:  Ya, I'm not lamenting on the cause... just stating.
12:54:05 <kmc_> you can't develop in haskell in the usual style of "hire 100 average programmers and throw them at it"
12:54:06 <Cale> Heh, Haskell's barrier to entry problem is a consequence of not having all the problems that the other languages have.
12:54:18 <koeien> it has other problems
12:54:24 <kmc_> you have to hire 5 geniuses and expect better results but with more investment
12:54:30 <tensorpudding> Cale: that's a nice way of thinking about it :)
12:54:47 <Axman6> kmc_: and 95 of them sit around watching dons write the whole thing in an hour, while the other 4 make coffee :P
12:55:14 <sproingie> arguably, people are still figuring out the "best" idioms for for solving various problems that other languages settled on long ago
12:55:16 <shambler_> but it's cool, let men to advance rather than languages to degrade
12:55:21 <tensorpudding> they haven't yet published a Learn Haskell in 24 Hours book have they
12:55:23 <lament> sexist
12:55:27 <sproingie> not that the other languages have better idioms, but the ones in haskell are sometimes still a work in progress
12:55:29 <pikhq> kmc_: Hmm. 100 programmers? Don't they know that productivity on a single program goes down as you add programmers (after a certain point)? :P
12:55:45 <kmc_> pikhq, yeah everyone knows that but it's still a popular development method
12:55:50 <pikhq> True.
12:55:55 <kmc_> also a lot of organizations require tons of similar but mostly separate programs
12:55:56 <absentia> cale: no, I think lament had it right... it's only due to other languages being taught as first languages for so long.
12:56:07 <Cale> absentia: Well, right, that's the real reason
12:56:15 <Axman6> ok, i have an exam, time to get ready!
12:56:19 <monochrom> There is something wrong about the statement about settling on an idiom.
12:56:22 <kmc_> so you can hire smart guys and spend the time to factor, build libs and do it right... or you can just spawn 10 different development processes and not care that they duplicate effort
12:56:23 <Cale> absentia: But it's dissimilar from those other languages because it solves many problems with them.
12:56:34 <pikhq> kmc_: Well, in that case, throwing 100 programmers at the problems at least isn't a major failure...
12:56:47 <tensorpudding> Haskell is a lot older than you might expect looking at how it's suddenly become popular
12:56:47 <medfly> who is being sexist?
12:56:51 <kmc_> the sad thing is that it's often not cost effective to factor out common code
12:56:57 <FabioTheApe> are lists evil?
12:57:01 <sproingie> hardly
12:57:03 <medfly> no.
12:57:06 <koeien> FabioTheApe: not at all, why would you think that?
12:57:11 <tensorpudding> lists are kinda important in Haskell
12:57:11 <sproingie> they're fundamental to haskell
12:57:15 <Axman6> tensorpudding: its advantages are becoming more creitical
12:57:21 <FabioTheApe> oh wait no i am thinking of arrays
12:57:21 <Axman6> critical*
12:57:22 <pikhq> Lists are one of the more fundamental types.
12:57:27 <lament> haskell suddenly became popular?
12:57:31 <sproingie> what they aren't any good at is random access, so you don't use lists everywhere C uses arrays
12:57:32 <shambler_> yeah
12:57:33 <absentia> haskell for dummies: 1 page.... "Haskell does not suffer idiots." ... and revision 2 would be "Haskell does not suffer idiots, perhaps try Java."
12:57:37 <Axman6> lament: we failed :(
12:57:43 <sproingie> absentia: that's not very nice
12:57:47 <pikhq> lament: It's becoming popular.
12:57:55 <kmc_> they're fundamental but not special.  you can define lists as normal algebraic data (aside from the special synatx)
12:58:01 <medfly> hey, I'm not the brightest person but I didn't have trouble with Haskell.
12:58:04 <koeien> absentia: there are very competent java programmers
12:58:07 <Axman6> FabioTheApe: lists are awesome, they can be infinite!
12:58:08 <monochrom> One thing wrong is that the statement is partly wrong. Every 4 years they change idioms in mainstream languages. Last time it was "inversion of control", "generator", "yield". The next one is likely "C# monad comprehension for sql".
12:58:08 <sproingie> sure, but lists belong to a lot of convenient type classes
12:58:26 <FabioTheApe> are there arrays in haskell?
12:58:31 <sproingie> there sure are
12:58:32 <Axman6> yes
12:58:32 <kmc_> koeien, yes.  the point is that you don't *need* to be smart to program Java
12:58:34 <kmc_> yes, many kinds
12:58:35 <absentia> you miss my point.. it was   java = any_other_language ... to start a language war.. that's why the first edition didn't have that.
12:58:42 <koeien> kmc_: i would consider that a feature
12:58:43 <kmc_> if you need constant-time access to an element by index, an array is good
12:58:55 <monochrom> Another thing wrong is that settling is stagnation.
12:59:00 <koeien> kmc_: unfortunately it is not true :( you need to be smart to program correct Java programs
12:59:01 <sproingie> there's the standard Data.Array, and ghc has unboxed types for people who want to do naughty things with the raw bits
12:59:03 <shambler_> if constant is small enough hehe
12:59:06 <tensorpudding> you need to be pretty smart to write good Java
12:59:18 <Axman6> FabioTheApe: randing from actual C arrays (yuck), to lovely parallel arrays, where you can perform data parallel computations without having to worry about how to make them parallel at all
12:59:22 <medfly> but you don't need to be pretty smart to write Java, and that's the point
12:59:28 <fax> yes you do
12:59:29 <shapr> Yay NDP!
12:59:32 <p_l> tensorpudding: and resilient....
12:59:32 <benmachine> I have long string constants in my files so I was wondering if I could put them in external files and then splice them in with template haskell
12:59:41 <benmachine> I've never really used template haskell before, is it easily done?
12:59:48 <absentia> correct.  ther are some very many programmers.. in any language .. who are smart.. java.. php..   competent programmers.. etc.     but for a title like "Haskell for idiots"  ...  the first step is not overcoming thenot knowing haskell... part of the equation.
12:59:52 <FabioTheApe> wth does that mean?
12:59:54 <kmc_> benmachine, sure can, template haskell's Q monad can run IO actions
13:00:00 <sproingie> TH has a severe lack of good tutorials
13:00:02 <koeien> benmachine: it is quite doable
13:00:11 <benmachine> kmc_: I thought it might be able to
13:00:19 <kmc_> :t qIO
13:00:21 <lambdabot> Not in scope: `qIO'
13:00:23 <mije> java doesn't challenge you the same way haskell does
13:00:24 <koeien> you can liftIO i guess
13:00:32 <absentia> I've used java.. seems to work good enough.  There's ... clojure?  scala?  lots of nifty stuff.
13:00:34 * benmachine pokes through the module
13:00:38 <sproingie> mije: really?  i find java's limitations quite challenging
13:00:44 <Vanadium> @type liftIO
13:00:45 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
13:00:46 <Axman6> FabioTheApe: say i have 1 billion elements in an array, and i needed to square them all, and add 17. doing that sequencially on one core would be very slow.
13:00:56 <Axman6> and... i need to go, someone else finish my example!
13:01:00 <mauke> haha
13:01:02 <kmc_> fun how JVM can't support proper tail calls without a severalfold performance hit
13:01:02 <jasonmay> @type zipWith
13:01:03 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
13:01:06 <absentia> mije: once you can do if ( nil != blah) .. you're pretty safe in java.. then it's just getting enough time using enough frameworks to become useful.
13:01:07 <Cale> Axman6: however, the parallel arrays aren't really ready yet...
13:01:15 <kmc_> FabioTheApe, one advantage of programming in terms of values and pure functions, is that you can easily execute them in parallel
13:01:36 <shambler_> hm, nice
13:01:43 <absentia> haskell to FGPA  :-) yay
13:02:03 <mije> java is challenging, but not in the same way, it's different, not more or less difficult
13:02:28 <mije> writing java is easy, writing good java is less easy
13:02:28 <benmachine> :t runIO
13:02:29 <lambdabot> Not in scope: `runIO'
13:02:30 <sproingie> haskell is a more quickly evolving language and the documentation tends to suffer for it
13:02:30 <absentia> to me, it's only different becauase there are so many frameworks to learn.
13:02:34 <benmachine> bah, whatever
13:02:38 <tensorpudding> i find java's verbose syntax a bit tedious sometimes
13:02:42 <lament> when was the last time haskell evolved?
13:02:43 * benmachine gets ghci to tell him
13:02:52 <mauke> last ghc release
13:03:04 <absentia> when is the next haskell standard coming out?  isn't C++A coming out?
13:03:11 <tensorpudding> haskell prime?
13:03:13 <sproingie> absentia: 2010 supposedly
13:03:14 <monochrom> do { x<-m; rec { y<-n z; z<- k y}; ... }
13:03:15 <absentia> ya
13:03:21 <absentia> cool
13:03:32 <mije> i write java at work, and since i know a little haskell, java syntax seems really tedious for sure
13:03:35 <sproingie> Haskell' is always the bleeding edge draft standard.  Haskell 2010 will be whatever graduates out of Haskell'
13:03:36 <absentia> haskell prime...   battling optimus prime.  ug.
13:03:45 <Cale> absentia: Though, it's not that interesting from a programmer perspective.
13:04:06 <kmc_> haskell prime vs. c++1x
13:04:07 <tensorpudding> haskell prime is a haskell derivative :p
13:04:07 <absentia> mije: just a sh!tton of boilerplate.
13:04:07 <Cale> absentia: The goal of the new Haskell standard is to standardise already implemented changes to the language
13:04:19 <absentia> I will take `par` anyday over the lower level c++ 1/2 parallelisms....
13:04:21 <timemage> we have our own planet now? =)
13:04:43 <monochrom> f (r@MyRecordConstructor{ field0, field1=x }) = field0 + x + field2 r
13:04:51 <mije> absentia: build a good object domain remains an interesting thing to do, but the language is so dirty, sort of
13:05:13 <mije> my eyes bleed each time i use an iterator
13:05:23 <absentia> in C++ or java?
13:05:27 <mije> java
13:05:30 <mauke> YES
13:05:34 <sproingie> really?  i find C++'s syntax even worse
13:05:39 <kmc_> C++ iterators are terrible
13:05:39 <monochrom> you should use foreach
13:05:43 <absentia> I don't mind:  for ( x in xs)  type iterators
13:05:50 <kmc_> typedef typename typedef typename typedef typename typedef typename ...
13:05:51 <sproingie> abusing operator overloads to make it look like C
13:05:56 <tensorpudding> When it comes to syntax, C++ gets worst marks almost everywhere
13:06:01 <mije> it's a long time i don't write C++, and i'm really fine with it :)
13:06:10 <Cale> (haskell)' = askell + hskell + hakell + hasell + haskll + 2*haskel
13:06:11 <reltuk> for error signaling in pure code, is Either a reasonable way to go?
13:06:20 <absentia> hey, doesn't c++ 2010 have a special compiler case for >> at the end of template declaractions :-)
13:06:21 <absentia> h0h0h0
13:06:21 <kmc_> yes
13:06:21 <Vanadium> Cale: hahaha
13:06:21 <sproingie> stl has for_each which isn't terribly bad until you try to create binders
13:06:23 <Cale> reltuk: generally, yeah
13:06:26 <monochrom> haha Cale
13:06:29 <dibblego> foreach doesn't work on Java iterators, only Java iterable
13:06:43 <mauke> for (::std::map< ::std::string, ::std::vector< ::std::string > >::const_iterator i = map.begin();
13:06:43 <dibblego> (and array)
13:06:56 <kmc_> yes, it's great, they have map but no way to easily construct functions to pass to it...
13:06:57 <sproingie> i see nothing wrong with special-casing that
13:06:58 <mauke> i != map.end(); i++)
13:06:59 <mije> in fact knowing haskell cripples my motivation to write java at work
13:07:11 <mije> bad haskell, bad
13:07:19 <kmc_> is there a guide to coping with Java and C++ after learning Haskell?
13:07:27 <absentia> sproingie: me either.  I love it, in fact.  just funny.
13:07:43 <absentia> sort of like haskell's CONSCIOUS decision for (-1)
13:07:44 <reltuk> Cale: is there anything like Either that has Maybe's nice monadic composable failure property?
13:07:45 <sproingie> what gets me is why they didn't think of special-casing it in the first place
13:07:48 <Raevel> kmc_: illegal substances?
13:07:50 <absentia> which is fine... by me.
13:08:07 <mauke> reltuk: yes, Either
13:08:08 <Cale> reltuk: yeah, Either ;)
13:08:12 <sproingie> not only (-1) but how loosely unary - actually binds
13:08:21 <kmc_> Raevel, that's how i got into haskell actually...
13:08:29 <Cale> reltuk: Unfortunately, the instance which you'll get from Control.Monad.Error is stupid
13:08:32 <absentia> er, right... mine was just an example
13:08:35 <Vanadium> Pft, no such thing as an Ether
13:09:16 <reltuk> ahh, that's where the instance is...
13:09:18 <shambler_> int x=10; while (x --> 0) {}; // behold! operator "goes to" -->
13:09:25 <reltuk> I was looking at Data.Either and it didn't have the instance :-p
13:10:08 <sproingie> is it just me or is Either badly named?  Left and Right don't imply much in the way of differing treatment, yet they're quite different
13:10:13 <sproingie> i'd have called them Failure and Success
13:10:16 <Vanadium> shambler_: clever
13:10:27 <koeien> Right = "correct" in another meaning of Right
13:10:42 <koeien> and Either's use is more than only failure/success
13:10:43 <abemud> does cabal install --user or --prefix works on Windows at all?
13:11:04 <sproingie> sure, but as a monad, Left gets very different treatment than Right
13:11:22 <sproingie> tho i could see a case where the failure is Right
13:11:29 <sproingie> (short-circuiting)
13:11:40 <koeien> that is unavoidable, you cannot define an instance that way
13:12:04 <Cale> sproingie: A nice thing about Left and Right is that they explain the relationship to the type parameters, but yeah...
13:12:45 <Vanadium> @type either
13:12:46 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
13:12:57 <Vanadium> pft, should have used A and B
13:13:11 <reltuk> Cale: specific greivances with the Either Monad instance in Control.Monad.Error?  it seems to do what I want...
13:14:29 <Cale> reltuk: It requires an instance of Error for the first type parameter
13:14:37 <Cale> reltuk: Which isn't really something that ought to be required.
13:20:40 <cocon> Hi, I'm getting "Missing header file: HsDirectory.h" when building
13:20:40 <cocon> 	6.12 rc1 from source
13:21:11 <cocon> please help
13:21:58 <benmachine> hmm
13:22:11 <benmachine> so I have my template haskell that reads in a file working
13:22:25 <benmachine> trouble is, cabal doesn't realise that the compilation now depends on that file
13:22:30 <benmachine> is there a clever way to tell it?
13:23:39 <doublethink_work> add a 'data-files' to your .cabal file?
13:23:39 <kmc_> i think it's unfortunate that Either ended up with the  Monad instance, rather than a different isomorphic type
13:23:53 <doublethink_work> that's about the only way to make sure it's included, at least if you do an 'sdist'
13:24:00 <kmc_> we definitely should not shy away from implementing isomorphic types as a way to encode more program properties
13:24:41 <benmachine> doublethink_work: the issue that I'm having is when I edit a file and rebuild, cabal doesn't know what modules need redoing
13:25:33 <benmachine> but the actual issue I'm having is that I'm playing with haskell instead of doing any work
13:25:36 <benmachine> again.
13:25:38 * benmachine disappears
13:27:43 * hackagebot upload: NetSNMP 0.1.6 - Bindings for net-snmp's C API for clients (JohnDorsey)
13:40:03 <EvanCarroll> does haskell have a central repository of code?
13:40:09 <mauke> hackage
13:40:15 <EvanCarroll> nift.
13:40:19 <EvanCarroll> does it have a build system?
13:40:22 <kmc_> cabal
13:40:22 <koeien> cabal
13:40:23 <ben_m> cabal
13:40:25 <kmc_> cabal
13:40:27 <ben_m> Die!
13:40:27 <koeien> cabal
13:40:29 <kmc_> > text "cabal"
13:40:30 <lambdabot>   cabal
13:40:31 <mauke> contrapuntal fugues
13:40:41 <EvanCarroll> does it have wings?
13:40:45 <kmc_> @faq
13:40:46 <lambdabot> The answer is: Yes! Haskell can do that.
13:41:24 <ben_m> haha
13:41:36 <mauke> LaBrassBanda++
13:42:00 <shambler_> ca
13:42:02 <shambler_> bal
13:42:11 <Phyx-> @faq
13:42:11 <lambdabot> The answer is: Yes! Haskell can do that.
13:42:20 <Phyx-> @quote Phyx-
13:42:21 <lambdabot> No quotes match. My mind is going. I can feel it.
13:42:23 <shambler_> @yarrr
13:42:24 <lambdabot> Keelhaul the swabs!
13:42:25 <Phyx-> @quote Phyx
13:42:26 <lambdabot> No quotes match. Sorry.
13:42:27 <kmc_> @nixon
13:42:28 <lambdabot> Castro couldn't even go to the bathroom unless the Soviet Union put the nickel in the toilet.
13:42:32 <Phyx-> @quote kmc_
13:42:33 <lambdabot> No quotes match.
13:42:38 <Phyx-> @quote kmc
13:42:38 <lambdabot> No quotes match. You speak an infinite deal of nothing
13:42:41 <kmc_> @quote lambdabot
13:42:42 <lambdabot> lambdabot says: [in #haskell] there are a lot of weirdos on here
13:42:47 <kmc_> @quote bot
13:42:49 <lambdabot> dons says: I think Pseudonym should submit some more @free patches, instead of breaking poor lambdabot. Why do we always hurt the ones we love?
13:42:53 <kmc_> @quote bot
13:42:54 <lambdabot> sarahbot says: sarahbot: later tell lambdabot @quote sarahbot
13:42:57 <kmc_> @quote faq
13:42:57 <EvanCarroll> mauke: do you have +o here?
13:42:58 <lambdabot> FliPPeh says: @faq Can Conficker be rewritten in Haskell? <lambdabot> <no location info>: parse error on input `:'
13:43:01 <mauke> EvanCarroll: yes
13:43:22 <EvanCarroll> is this evil rumor true?
13:43:29 <EvanCarroll> has someone fowled the op list?
13:43:41 <tensorpudding> fowled?
13:43:43 <Phyx-> "fowled" ?
13:43:44 <lambdabot> has anyone really been far even as decided to use even go want to do look more like?
13:43:59 <sproingie> say what?
13:44:01 <Botje> EvanCarroll! miss you man!
13:44:04 <EvanCarroll> i think i wanted fouled
13:44:08 <tensorpudding> yes
13:44:25 <tensorpudding> i don't know many ducks on IRC
13:44:33 <sproingie> quack
13:44:38 <mauke> no quack!
13:44:39 <Phyx-> oink
13:44:39 <EvanCarroll> Botje: yes, yes i know.
13:45:05 <tensorpudding> > text "moo"
13:45:06 <lambdabot>   moo
13:45:21 <EvanCarroll> Botje: p.s. IO::File is still > CORE::open() ;)))
13:45:30 <Botje> :)
13:45:51 <EvanCarroll> I was telling buu about that when he came down just a few weeks ago in fact
13:45:52 * mauke calls open(2) via CORE::syscall
13:46:36 * Phyx- goes to play farmville
13:47:20 <EvanCarroll> Botje: you know I got a bribe from stevan to talk to mst about not using coercive means to keep me banned, if I downed the wikibook
13:47:39 <EvanCarroll> that was my yestdays personal wtf
13:47:46 <Botje> who's stevan? and which wikibook :p
13:48:13 <EvanCarroll> create of moose, the wikibook i created about moose, that I have stoped maintaining since mst klined me from irc.perl.org
13:48:45 <EvanCarroll> http://en.wikibooks.org/wiki/Programming_with_Moose
13:49:04 <Botje> it's a wikibook, anyone can edit?
13:49:20 <Phyx-> what's mst?
13:49:42 <EvanCarroll> Botje: yes
13:49:53 <EvanCarroll> Phyx-: a demon from the 7th layer of hell.
13:50:08 <EvanCarroll> You kill him at the end of the Diablo III
13:50:21 <ben_m> spoiler
13:50:25 <Botje> aww, that's not nice :)
13:50:34 <jasonmay> HALLO EVAN
13:50:48 <EvanCarroll> HALLO JASONMAY!!
13:50:57 <EvanCarroll> btw, I'm still in #perlcafe
13:51:03 <Phyx-> EvanCarroll: lol
13:51:39 <EvanCarroll> we use Apple's I-garlic to keep the evil demons out of that channel.
13:51:44 <EvanCarroll> it comes in a pretty white glossy containers.
14:01:44 <aavogt> hmm, is there some way to convert between the AST parsed by parseExp in haskell-src exts and some representation that can match on another AST that is similar?
14:02:46 <sproingie> way too much inside baseball in that moose wikibook.  people wanting a tutorial don't really want an airing of the complaints about NEXT
14:02:56 <sproingie> anyway that's about as much as i'll say here
14:03:11 <aavogt> or in other words, I want to write a dsl for expressing changes in haskell syntax
14:03:56 * hackagebot upload: MonadRandom 0.1.4 - Random-number generation monad. (BrentYorgey)
14:04:03 <aavogt> where say the transformation is  ("functionName x y z","changedFunctionName (otherFunction z) y x")
14:04:35 <aavogt> which then generates a pattern to match on functionName applied to 3 variables, and then threads those variables to the changed version
14:05:59 <aavogt> this process seems to work if I do it manually and write case exprs changing, say  (Var (UnQual (Ident "x")) to x in the source and destination patterns
14:06:58 <aavogt> I hope this process can be done robustly, automatically (as long as the people changing these library functions define their changes properly)
14:07:18 <aavogt> if anybody is interested, this would be used for a config updater for xmonad
14:08:44 <aavogt> but in any case, it does not appear to be the case that I can easily (as in 1 predefined function) convert the haskell-src-exts Exp into a Pat with the one letter variables as holes
14:09:55 <pchiusano> I'd like to learn more about category theory... can anyone recommend a good resource?
14:10:12 <koeien> what is your background?
14:10:20 <sg> hi
14:10:22 <Cale> pchiusano: Awodey's book is great
14:10:25 <koeien> i've read something by barr & wells
14:10:29 <koeien> sg: hello
14:10:34 <sg> hi koeien
14:10:41 <Cale> pchiusano: let me get you a link
14:10:47 <pchiusano> koeien: I have a CS background
14:11:04 <Cale> http://www.math.uchicago.edu/~may/VIGRE/VIGRE2009/Awodey.pdf
14:11:34 <pchiusano> koeien: does your answer change depending on my background?
14:11:47 <pchiusano> Cale: cool!
14:12:05 <koeien> pchiusano: not really, but it may help others answer :)
14:13:35 <FauxFaux> I'm trying to install multiset-0.2, "Could not find module `Data.Data': it is a member of the hidden package `base'".  The internets seem to think that this is a 6.10 problem, but the hackage page says "Built on: ghc-6.10, Dependencies: base (>=2 && <5), containers" which sounds like it should've fixed the problem.  Any suggestions, ignoring my backwards platform? :) http://pastie.org/687150
14:14:51 <Cale> pchiusano: I particularly like to recommend this book because it's written with nonmathematicians in mind.
14:15:15 <Eftarjin> hi everyone. BONUS: Underscores in http://learnyouahaskell.com/ code examples are not visible on firefox 3.5/linux.  Changing the CSS to .dp-highlighter ol li, .dp-highlighter .columns div { line-height: 17px; } (instead of 16px) fixes this.
14:15:32 <pchiusano> Cale: I am reading the beginning... do you think it is easy to translate the concepts to programming?
14:15:47 <aavogt> FauxFaux: are you using Setup.lhs?
14:15:52 <Cale> pchiusano: So, while it follows a somewhat traditional mathematical style, it doesn't demand too much in terms of prerequisites like many books on CT do, and develops many of the important examples inside the book itself.
14:16:21 <FauxFaux> aavogt: "cabal install multiset"?  I'll try it by hand.
14:16:25 <Phyx-> learnyouhaskell
14:16:26 <Phyx-> hmm
14:16:29 <Cale> pchiusano: It's reasonably easy, though it depends on which concepts.
14:16:59 <shambler_> @where LYAH
14:17:00 <lambdabot> www.learnyouahaskell.com
14:17:13 <shambler_> oh my god
14:17:18 <shambler_> an elephant!
14:17:33 <aavogt> FauxFaux: well, cabal install supposedly defaults to base-3 which includes Data.Data. Somehow cabal ends up picking base-4 for you, with which the Data.Data module has been moved out to the 'syb' package
14:17:39 <mtnviewmark> wants to create packages called "ruthless-dictator" and "puppet-president"
14:17:54 <mtnviewmark> cabal install ruthless-dictator
14:17:58 <mtnviewmark> :-)
14:17:59 <dreixel> base-3 does not have Data.Data
14:18:21 <aavogt> there's some kind of --constraint or --preference you can give that say to use base-3
14:18:26 <aavogt> dreixel: why do you say that?
14:18:34 <dreixel> that package should depend on base-4
14:18:45 <Phyx-> according to my ghc-pkg
14:18:48 <dreixel> aavogt: I created the Data.Data module for base-4
14:18:50 <Phyx-> Data.Data is in 4.1.0.0
14:19:07 <FauxFaux> aavogt: Mmm, it 'build's fine from Setup.hs. :/
14:19:09 <reltuk> does (foldr (>=>) return) have a name?
14:19:10 <dreixel> it came out from the syb modules, which were all in base-3
14:19:32 <Cale> reltuk: not in the libraries
14:19:36 <dreixel> thsi explains it: http://www.cs.uu.nl/wiki/bin/view/GenericProgramming/SYB#Handling_the_6_10_base_split
14:19:42 <pchiusano> koeien: just curious, what was the book you recommended?
14:19:49 <pchiusano> bart and wells?
14:19:51 <aavogt> ah, I guess I was thinking about Data.Generics ;)
14:19:57 <reltuk> Cale: it's all over my code...I gota call it something :-p
14:19:57 <dreixel> yes
14:20:05 <dreixel> Data.Generics is in base-3, and not in base-4
14:20:14 <gOcOOl> like in map fusion, where you can merge something like map f (map g xs) to map (f . g) xs, is there any way to merge an adjacent map and filter together? map f (filter g xs) to something?
14:20:15 <Cale> kleisli?
14:20:23 <Cale> chain ? :)
14:20:31 <Phyx-> @pl (foldr (>=>) return
14:20:31 <lambdabot> (line 1, column 20):
14:20:32 <lambdabot> unexpected end of input
14:20:32 <lambdabot> expecting variable, "(", operator or ")"
14:20:34 <aavogt> hmm, so in this case, cabal defaults to a base that doesn't work
14:20:34 <Phyx-> @pl (foldr (>=>) return)
14:20:35 <lambdabot> foldr (>=>) return
14:20:40 <koeien> pchiusano: i've read a part of toposes, triples & theories
14:20:48 <aavogt> err, cabal install defaults
14:21:05 <dreixel> well, in theory it should try both...
14:21:14 <aavogt> @hackage ruthless-dictator mtnviewmark
14:21:15 <lambdabot> http://hackage.haskell.org/package/ruthless-dictator mtnviewmark
14:21:21 <dreixel> but the package is wrong, if it says it is compatible with base > 2 and it uses Data.Data.
14:21:26 <dreixel> then it should say base >= 4
14:22:21 <FauxFaux> aavogt: Thanks, anyway. :)
14:22:40 <aavogt> dreixel: cabal install chooses base-3 over base-4 when it gets the choice. This change was apparently made to reduce the breakage due to all these packages saying base > 2.
14:22:48 <aavogt> but yeah, the package should be fixed
14:23:02 * Phyx- wonders how he can trim the fat from his 25mb program that ghc spits out
14:23:22 <aavogt> don't use the ghc-api?
14:23:23 <dreixel> but on Hackage it says it was built successfully?
14:23:25 <mtnviewmark> aavogt, I see the cabal has yet to act in the matter of leading the country!  ;-)
14:23:41 <Phyx-> aavogt: but i need the api, lol
14:23:57 <luite> upx? :p
14:24:03 <aavogt> you can remove a bit by stripping the binary
14:26:04 <aavogt> dreixel: I guess hackage uses the runhaskell Setup method
14:30:22 <aavogt> @remember mtnviewmark cabal install ruthless-dictator
14:30:23 <lambdabot> I will never forget.
14:30:56 <mtnviewmark> @remember mtnviewmark cabal install puppet-president
14:30:56 <lambdabot> Done.
14:31:08 <mtnviewmark> whew
14:31:58 <aavogt> well they aren't saved until somebody important does @flush
14:33:25 * mtnviewmark wonders if the cabal includes "somebody important"
14:33:44 <leimy_> Ugh
14:33:47 <mtnviewmark> i know, i know, I should stop it already with the cabal jokes
14:33:51 <leimy_> Could not find module `Text.Regex.Posix':
14:33:51 <leimy_>       Perhaps you haven't installed the profiling libraries for package `regex-posix-0.72.0.3'?
14:34:05 <leimy_> I've got a space leak, and will not be able to find out where now :-(
14:34:19 <leimy_> or rather, I can't use the profiler
14:34:28 <koeien> cabal install X -p
14:34:41 <leimy_> yeah but this is a standard one isn't it?
14:34:58 <leimy_> I guess it doesn't matter
14:35:03 <leimy_> as long as hackage is up
14:36:40 <leimy_> why aren't the profiling versions in the haskell platform there by default?
14:38:11 <aavogt> they double the space needed?
14:38:25 <aavogt> perhaps it was not really considered?
14:38:37 <newsham> only developers would want em anyway! ;-)
14:38:45 <leimy_> LOL
14:38:53 <leimy_> yeah no one using haskell is a developer :-)
14:42:06 <SubStack> are hackers disjoint from developers?
14:42:53 <Badger> hackskell ones certain't aren't
14:43:22 <Vanadium> I think the idea is that you develop on a custom setup and deploy the platform
14:43:45 <aavogt> I think that makes it easy to accidentally use non-platform dependencies
14:44:12 <aavogt> if the developers can't say, I'm using platform-only... oops I need to profile
14:44:37 <leimy_> can I get a Haskell Platform for developers then?
14:44:40 <leimy_> as a different version?
14:44:55 <kyagrd> what command was lambdabot's message box? I forgot it and I don't find it in http://code.haskell.org/lambdabot/COMMANDS either
14:45:10 <aavogt> I think there's a trac for the platform, unless dons can answer you first
14:45:11 <Vanadium> @tell kyagrd wasn't it this?
14:45:12 <lambdabot> Consider it noted.
14:45:26 <kyagrd> oh ... there was it now I see
14:45:27 <lambdabot> kyagrd: You have 1 new message. '/msg lambdabot @messages' to read it.
14:46:00 <kyagrd> Vanadium: thanks!
14:46:07 <Vanadium> No problem :>
14:50:24 <leimy_> I wonder if there's a way to tell Haskell to stop being so lazy and consuming so many resources
14:50:39 <leimy_> It's clearly a very American Patriotic language
14:50:41 <leimy_> :-)
14:58:18 <b6> ghci is complaining it can't find atexit when i try to use something in a module built with c2hs.
14:59:56 <leimy_> What's ticky ticky profiling?
15:01:07 <b6> leimy_: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Profiling
15:01:08 <Vulpyne> http://www.haskell.org/ghc/docs/6.10-latest/html/users_guide/ticky-ticky.html
15:01:46 <leimy_> thank you!
15:02:33 <Vulpyne> Be glad you didn't get a LMGTFY link. :)
15:02:49 <medfly> but lmgtfy is so cool!
15:02:55 <Vulpyne> It certainly is.
16:04:26 <medfly> I love Haskell.
16:04:53 <reltuk> any advice on how I can learn to get rid of an "illegal overloaded type signature in a binding group for ... that falls under the monomorphism restriction" type error?
16:05:04 <aavogt> ?quote barney
16:05:04 <lambdabot> No quotes match. It can only be attributed to human error.
16:07:04 <kmc> reltuk, -XNoMonomorphismRestriction?
16:09:25 <seanmcl> what is a shrink in QuickCheck?
16:09:56 <aavogt> it is used to produce smaller values
16:10:01 <skorpan> that's what happens to you when you realise your arbitrary instances generate nothing but ()
16:10:16 <aavogt> which hopefully also cause your test to fail
16:10:42 <seanmcl> so if it fails on 10^10, it will try 10^9, etc?
16:11:07 <reltuk> kmc: is something wrong with my program if I have to use that?
16:11:11 <kmc> no
16:11:14 <kmc> not necessarily
16:11:30 <kmc> monomorphism restriction is considered sort of an ugly part of the haskell standard that's not necessary
16:11:31 <skorpan> seanmcl: i think it means that if it fails on lists of length greater than 10, and the test case had length 30, it would shrink it down to 10
16:11:40 <skorpan> (pure guess, as always)
16:11:45 <aavogt> seanmcl: depends on the coarbitrary function/instance
16:12:12 <seanmcl> ok, thanks!
16:12:31 <seanmcl> kmc: can't you just give a type signature for your function to get rid of the monomorphism warning?
16:12:36 <kmc> maybe?
16:13:04 <seanmcl> it can be a pain if you're in a monad, but I've usually got it to work with explicit quantifiers
16:13:05 <reltuk> it's ok...I borked it up
16:14:09 <kmc> explicit forall?  that's an extension too
16:15:16 <travisbrady> could you have built Hadoop with Haskell? would it be harder/easier than with Java? would it be fun? crazy?
16:16:01 <reltuk> I was trying to go from not being in a monad to being in a monad
16:16:02 <dpratt71> (what I think is) an easy question about type familes...
16:16:23 <dpratt71> reading this: http://www.haskell.org/haskellwiki/GHC/Indexed_types#What_are_type_families.3F ...
16:16:57 <ben_m> Data.Sequence length and append is O(1), right?
16:17:09 <mtnviewmark> are FlexibleInstances, OverlappingInstances, TypeSynonymInstances considered reasonable for general use in libraries?
16:17:15 <mtnviewmark> or should one avoid some or all of them?
16:17:26 <kmc> ben_m, the docs say
16:17:34 <Phyx-> I would avoid overlapping instances
16:17:41 <Phyx-> but the rest are ok imho
16:17:42 <aavogt> if you would avoid one do it for OverlappingInstances
16:17:55 <dpratt71> ...and not fully understanding this syntax:
16:17:55 <dpratt71> class GMapKey k where
16:17:55 <dpratt71>   data GMap k :: * -> *
16:17:55 <dpratt71>   ...
16:18:04 <kmc> dpratt71, which part?
16:18:09 * hackagebot upload: XMPP 0.0.4 - XMPP library (OlegIvanov)
16:18:10 <ben_m> kmc: Alright, I'll just trust the docs then :D
16:18:10 <dpratt71> * -> *
16:18:19 <kmc> that's a "kind"
16:18:22 <mtnviewmark> sigh -- I want to define an instance for Class String, and for (Thing a) => Class [a]
16:18:24 <kmc> do you know how those work?
16:18:32 <kmc> they're like the types of types
16:18:40 <kmc> :k Maybe
16:18:41 <lambdabot> * -> *
16:18:43 <kmc> :k Maybe Int
16:18:44 <lambdabot> *
16:18:57 <dpratt71> kmc: I see...sorta
16:18:59 <kmc> :k StateT
16:19:00 <lambdabot> * -> (* -> *) -> * -> *
16:19:17 <dpratt71> do the * represent types?
16:19:25 <kmc> anything of kind * is a type, proper
16:19:28 <skorpan> :t StateT
16:19:30 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
16:19:39 <kmc> that is, you could make a value with the type if it has kind *
16:19:49 <kmc> if the kind is not *, then it wants more type arguments
16:19:51 <kmc> like Maybe there
16:20:03 <dpratt71> kmc: ok, that's making some sense, thanks
16:20:08 <kmc> you can't have a value of type Maybe, because it's * -> *.  you have to give a type argument, like Maybe Int or Maybe [Bool]
16:20:20 <dpratt71> kmc: gotcha
16:20:29 <kmc> kinds are pretty simple -- there's no quantification, polymorphism, kind variables, etc
16:20:54 <kmc> so it's saying that (GMap k) will take one more type arg, so a full type would be something like GMap k v
16:21:12 <dpratt71> so usually the signature is implicit, but in a type family it needs to be explicit?
16:21:24 <kmc> there are various places where the compiler assumes kind *
16:21:31 <kmc> if you have otherwise you have to say so
16:21:32 <kmc> @src StateT
16:21:33 <lambdabot> Source not found. It can only be attributed to human error.
16:23:19 <dpratt71> is it not possible to express it as GMap k v? why do it that way?
16:24:38 <fujisan> Twey is gay
16:24:52 <fujisan> :D
16:25:23 <Vanadium> What.
16:39:22 <Gracenotes> hm.. are matrices generally 0-indexed or 1-indexed?
16:40:12 <kmc> in math?
16:40:21 <mmorrow> are we using FORTRAN, C, or math?
16:41:05 <mmorrow> FORTRAN is 1-indexed an column-major
16:41:07 <Gracenotes> math
16:41:10 <werejmcarthur> man, i'm looking back at some code that i wrote a while back and i feel like i was olegging at the time, because it looks elegant but i still have no idea how it works
16:41:13 <mmorrow> C is 0-indexed an row-major
16:41:38 <fujisan> does Twey chat here a lot?
16:41:47 <Gracenotes> matrices as orthogonal from multidimensional arrays -- meaning just what linear algebraists enjoy
16:41:56 <Gracenotes> or don't enjoy.
16:42:04 <Gracenotes> use -_-
16:44:36 <ben_m> Is "hot code swapping" (changing a function while the program runs, with immediate effect) like in Erlang possible in Haskell?
16:45:08 <mmorrow> Gracenotes: math is like fortran
16:45:18 <monochrom> if you use a plug-in framework like what lambdabot does
16:45:39 <ben_m> hmm
16:45:50 <Gracenotes> ah. I see. so what I have already is good by mathy standards. great :)
16:47:26 <mmorrow> Gracenotes: actually, this whole business is so confusing i have no idea what is what anymore, but this is math http://upload.wikimedia.org/wikipedia/commons/thumb/b/bb/Matrix.svg/247px-Matrix.svg.png
16:48:33 <Gracenotes> oooh, I vaguely recall that diagram from linear algebra course.
16:49:02 <Gracenotes> yes, now I remember, we did it 1-indexed. I should really review my textbook though -- don't remember much. despite the tedious exercises.
16:49:29 <mmorrow> math is usually 1-indexed with everything
16:49:55 <mmorrow> it's just whether (i,j) is (col,row) or (row,col) that becomes confusing
16:50:12 <Gracenotes> yes, mathematicians don't like to tolerate (m-1) and (n-1). Computer scientists have a greater tolerance nowadays, if only because they already have to deal with it in their code
16:50:22 <mmorrow> (which gets confusing if you have to move in between C, fortran/matlab, and math)
16:50:35 <Gracenotes> hm. I like the convention (row, col)
16:50:54 <aavogt> it's more like (x,y)
16:50:54 <mmorrow> yeah, (n-1) gets annoying if you have to constantly be writing it manually
16:51:22 <mmorrow> manually := pencil/chalk
16:51:32 <aavogt> but for some reason they fliped the y axis
16:51:56 <Gracenotes> coordinate systems and indexing systems should be disparate. usually :)
16:52:14 <aavogt> Gracenotes: why not?
16:52:33 <aavogt> they are the same concept (at least as I see it)
16:52:36 <Phyx-> hrm
16:52:42 <Phyx-> think i'm going to bad
16:52:44 <Gracenotes> well. if only because my ways of perceiving them two-dimensionally are disparate.
16:52:48 <mmorrow> aavogt: spherical coordinates?
16:52:54 <mmorrow> etc
16:53:00 <fujisan> Twey banned me about 8 months ago in february, he banned my hostmask at that time: 'unaffiliated/fujisan', weeks/months later i joined the room after i lost my hostmask, and immediately other people in ##japanese accused me of banevading, but Twey knew i lost my hostmask so according to him i wasnt really banevading, so i kept chatting in ##japanese of and on, but i hadnt been on there for several weeks/months, so today i came in ##japa
16:53:27 <Gracenotes> ..I think this is not the channel for that, Mr. Fuji
16:53:36 <mmorrow> fujisan: why are you telling us this?
16:53:40 <Phyx-> lol
16:53:42 <aavogt> mmorrow: those ones don't exist: they are just change of variables ;)
16:53:48 <Phyx-> mmorrow: he probably needed to vent :P
16:54:06 <mmorrow> aavogt: :)
16:54:10 <mmorrow> Phyx-: i guess
16:54:15 <Gracenotes> Twey: anyway, should probably take care of that..? >_>
16:54:21 <Phyx-> lol
16:54:52 <Gracenotes> aavogt: when I'm writing a game like Tetris, I store the rows and columns, which I make into y and x for displaying time, respectively
16:54:59 <Twey> Gracenotes: *shrug* Nothing I can do, really
16:55:45 <Gracenotes> after all, the fundamental axis of Tetris is a row. hence, array[row, col]. There is no fundamental axis in pixels, so I just map them onto whatever they happen to be mapped onto
16:55:51 <Phyx-> Gracenotes: well, for tetris you could technically store just a 1D array
16:56:02 <seanmcl> kmc: yes, explicit forall is an extension, but there's no runtime penalty, as there can be if you ignore the monomorphism restriction
16:56:12 <Gracenotes> Phyx-: that is technically what Haskell did.
16:56:24 <Gracenotes> instance (Ix a, Ix b) -> Ix (a, b)
16:56:29 <Gracenotes> * =>
16:57:23 <Gracenotes> although even if you are doing manual conversion, you do have to decide what dimension to traverse across
16:58:26 <aavogt> mmorrow: by the way, is there some way to take two Exp(ressions) parsed by haskell-src-meta and construct some kind of function from one to the other (assuming certain variable names actually refer to arbitrary subexpressions)?
16:59:00 <mmorrow> aavogt: hmm, so you essentially are looking to unify the two expressions i guess
16:59:23 <mmorrow> unify in the sense that you unify types, just with expressions
16:59:53 <mmorrow> aavogt: so one type of a function that would do that that would be reasonable would be
17:00:03 <aavogt> well, I'm thinking only on the syntax level
17:00:23 <aavogt> assuming that whoever feeds those two strings (parsed as expressions) are well-typed
17:00:39 <mmorrow> unify :: Exp -> Exp -> Maybe [Either (Id,Exp) (Exp,Id)]
17:00:56 <mmorrow> where Id is just a place-holder for whatever type you're using for vars
17:01:18 <mmorrow> also, you probably want to rename both expressions uniquely wrt each other first
17:01:48 <mmorrow> and give back a (Map Id Id, Map Id Id) as well so you know what the new vars map to
17:02:31 <mmorrow> aavogt: so if the expressions are exactly the same
17:02:32 <mmorrow> err
17:02:42 <aavogt> mmorrow: if I did this without much typing, I would take the result of parseExp, replace all of the short litterals with variables, and change it to a case expression
17:02:48 <mmorrow> you'd probably want a case for (Id,Id) too
17:02:58 <aavogt> but converting from an Exp to a Pat doesn't seem to be supported
17:03:07 <mmorrow> aavogt: i'd say this would take hundreds of lines to implement
17:03:14 <aavogt> the Pat being a pattern which matches on ExpS
17:03:16 <mmorrow> possibly 1000-2000
17:03:19 <aavogt> :(
17:03:32 <aavogt> that will take quite a while
17:03:52 <mmorrow> i'm actually doing something similar to this for another AST i'm working with in a project
17:04:04 <mmorrow> it's somewhat of a pita
17:04:07 <aavogt> interesting
17:04:28 <mmorrow> so you'd need basically to do this
17:05:28 <mmorrow> (1) a way to rename an Exp with unique vars, (2) a functions that walks down two expressions in lockstep, and matches up vars with Exp or Exp with vars, or var with var
17:06:06 <mmorrow> well, technically i guess you don't need to rename expressions i guess
17:06:59 <mmorrow> you'd just need to make sure you don't treat the two "x"s as the same "x" in ("x", "f x")
17:07:18 <mmorrow> (those ".." being Exp rather than String)
17:08:02 <mmorrow> oh, and you *also* need to remember which vars match up to which expressions and vice-versa
17:08:39 <mmorrow> so you can e.g. make sure that vars that occur more than once match up with the /same/ expression each time
17:09:22 <mmorrow> aavogt: basically, it's not difficult or extremely mentally challenging, it's just tedious and has gotchas everywhere
17:09:32 <aavogt> so you wouldn't be using something like syb to apply a transformation everywhere in the AST?
17:10:10 <mmorrow> i'm not using syb for anything, but maybe maybe you could somehow
17:10:21 <aavogt> so the  ("f1 var1 var2","f2 var2 var1") would just be sugar for some more nasty transformation on the AST
17:10:46 <aavogt> in my case the important things for deciding when to make a substitution is the name of f1
17:11:33 <aavogt> another pitfall is that in haskell names can be shadowed
17:12:04 <mmorrow> aavogt: here's some code that does unification like this for a Type type which is a clone (for the most part) of TH's Type type http://moonpatio.com/repos/derive-gadt/lib/Language/Haskell/Derive/Gadt/Unify.hs
17:12:19 <mmorrow> so you'd be doing basically exactly this, but s/Type/Exp/
17:12:38 <aavogt> is there some easy way to determine that the "f1" I refer to is actually one imported (from a module whose interface has changed), instead of one made in a local binding?
17:12:56 <aavogt> ie. use the ghc api to rename everything to be fully qualified
17:12:59 <mmorrow> that module though is doing unification kind of non-standardly
17:13:04 <aavogt> but there doesn't seem to be such an ability
17:13:06 <mmorrow> via that T type
17:13:44 <mmorrow> aavogt: oh, so you want semantic equality too
17:14:05 <aavogt> if easily possible ;)
17:14:12 <mmorrow> aavogt: err, well stepping back, what are you trying to do?
17:15:01 <aavogt> mmorrow: update xmonad config files in the face of incompatible library changes (which are made in the name of cleanliness)
17:15:02 <mmorrow> because the actual syntactic unification you'd need to do is separate from any additional processing of the result
17:15:42 <mmorrow> aavogt: hmm, so what would be an example transformation you'd make
17:15:43 <mmorrow> ?
17:15:45 <aavogt> I suspect that a simple textual substitution can probably take care of 80% of cases, but people are allowed (and do) do anything
17:16:06 <aavogt> mmorrow: a function is changed to take more or less arguments
17:16:55 <mmorrow> so, knowing that Foo.bar how takes three params instead of two, you'd find all occurrences of bar in a file and "fix" them?
17:17:00 <mmorrow> s/how/now/
17:17:24 <mmorrow> you'd also need code to do substitution on the Exp AST
17:17:43 <aavogt> more examples are the style of changes here: http://www.haskell.org/haskellwiki/Xmonad/Notable_changes_since_0.8#Updates_that_require_changes_in_xmonad.hs
17:17:58 <mmorrow> so you need to keep track of bound-vars as you descend the Exp, etc
17:18:06 <mmorrow> syb is basically out for that
17:18:27 <aavogt> I was hoping to do the renaming of vars (to fully qualified) before doing the syb stuff
17:18:28 <mmorrow> (\fmap -> (fmap,fmap)) 42
17:18:40 <aavogt> exactly
17:19:14 <mmorrow> given an AST, you usually need these, in order to manipulate it:
17:19:17 <aavogt> so when we change Control.Monad.fmap, we refer to it as such when specifying those rewrite rules
17:19:48 <mmorrow> rename_ :: _ -> M _
17:19:56 <mmorrow> where _ is each of the AST types
17:20:03 <mmorrow> so Exp, Stmt, Dec, Pat, ...
17:20:17 <mmorrow> subst_ :: [(Var,_)] -> _ -> M _
17:20:21 <mmorrow> where _ is the same
17:20:34 <mmorrow> (M here is some monad you can get uniq vars from)
17:20:43 <mmorrow> um, hmm what else
17:20:47 <aavogt> I think that Exp covers most of changes, but yeah, other types are possible
17:20:57 <mmorrow> oh
17:21:04 <mmorrow> freeVars :: Exp -> Set Var
17:21:20 <mmorrow> aavogt: you need it for everything reachable from the Exp type though
17:21:28 <mmorrow> so Stmt, Dec, ...
17:21:59 <mmorrow> and you need to be able to traverse Pats to extract the being-bound-vars
17:22:08 <mmorrow> to add them to your current in-scope set
17:22:12 <mmorrow> during renaming
17:22:57 <aavogt> this is turning into a pretty serious project
17:23:41 * aavogt wonders if it is still possible to estimate bound variables using syb
17:23:56 <aavogt> stiill wonders
17:24:15 <mmorrow> the difficulty with syb for stuff like this is that the things you need to do are context-dependent
17:24:30 <aavogt> mmorrow: thanks for being helpful as usual
17:24:31 <mmorrow> and syb is more for doing mass context-inseneitive things
17:24:42 <mmorrow> aavogt: no problem, good luck :)
17:32:56 <aavogt> I guess I'll skip the context sensitive stuff first, since that can be substituted with a warning that some locally bound variable shadows an import, so no fixes for than name are applied
17:33:33 <aavogt> which means writing a   desugarTrans :: (String,String) -> (Exp -> Exp)
17:33:39 <aavogt> and then doing the syb
17:51:47 <det> Can someone explain to me what a constructor class is?
17:53:10 <kmc> det, a typeclass where one of the type parameters has kind not *
17:53:14 <kmc> do you know how kinds work?
17:53:20 <det> No :-)
17:53:28 <det> I don't know what the kind "*" is, either
17:53:39 <aavogt> do you know what types are for values?
17:53:43 <Cale> det: The kind * is the kind which has all the types in it
17:53:47 <seanmcl> Type :: *
17:53:48 <sjanssen> det: in this context, "constructor" means "type constructor"
17:53:50 <Cale> (well, all the normal types)
17:53:54 <kmc> :k Maybe
17:53:55 <lambdabot> * -> *
17:53:58 <seanmcl> Monad :: * -> *
17:54:05 <Cale> * -> * is the kind for things which take types and construct other types from them
17:54:05 <seanmcl> oops
17:54:06 <kmc> Maybe has kind * -> *, because you need to apply a type (*) to get another type (*)
17:54:10 <kmc> Maybe is not a type; Maybe Int is
17:54:16 <kmc> kinds are like the types for types and type-constructors
17:54:32 <det> ok
17:54:35 <kmc> so for example, Monad is a constructor class, because you'd say "instance Monad Maybe", and Maybe :: * -> *, which is not *
17:55:28 <det> Is there a simple example of something that can only be done using constructor classes?
17:55:36 <kmc> Monads
17:55:51 <aavogt> am I wrong if I call Monad a type class?
17:55:59 <aavogt> instead of a constructor class
17:56:07 <kmc> so haskell is a bit inconsistent about what "type" means
17:56:18 <aavogt> ... maybe the correct term is  type constructor class
17:56:19 <kmc> sometimes it means kind *; sometimes it means any term at type-level
17:56:24 <det> I mean, an example of maybe 2 lines of code :-)
17:56:38 <aavogt> @src Monad Maybe
17:56:38 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
17:56:43 <kmc> det, you can define Monad in 3 lines, and declare Maybe as a Monad in 3 more
17:56:45 <aavogt> @src Maybe Monad
17:56:45 <lambdabot> Source not found.
17:57:45 <det> so
17:57:50 <det> without constructor classes
17:57:58 <Draconx> aavogt, I don't think the difference between "type class" and "constructor class" matters much anymore.  Afaik, the terms came about in earlier (before haskell 98) versions of the language, where the two concepts were separate.
17:57:59 <BMeph> Do Functor, it's funnerer. ;)
17:58:05 <Philonous> det: Functor. class Functor f where fmap :: (a->b) -> f a -> f b
17:58:06 <det> you could only write "instance Monad (Maybe int)"
17:58:20 <kmc> det, yeah, and the monad operators would look different
17:58:24 <kmc> it wouldn't really work at all
17:58:34 <kmc> det, Philonous's example of Functor is better and simpler than Monad
17:58:49 <kmc> @src Maybe Functor
17:58:49 <lambdabot> Source not found. My pet ferret can type better than you!
17:58:54 <BMeph> ...and, funnerer! ;p0
17:59:02 <kmc> is there any way to get \bot to print instances?
17:59:12 <det> @src Functor Maybe
17:59:13 <lambdabot> Source not found. Sorry.
17:59:48 <aavogt> there is a way
17:59:53 <aavogt> @src [] fmap
17:59:53 <lambdabot> fmap = map
18:00:02 <aavogt> @src Maybe (>>=)
18:00:03 <lambdabot> (Just x) >>= k      = k x
18:00:03 <lambdabot> Nothing  >>= _      = Nothing
18:00:23 <Philonous> det. Problem in both cases is, that you have multiple types involved. fmap really works on all types a and b, you can't express that when you have to mention every type explicitly in the instance header.
18:00:55 <seanmcl> Is there a notation for classes?  For instance, types are Int, Int -> Int, kinds are  *, and (* -> *) -> *.  But how do you succinctly write a constructor class's "kind"?  Monad :: (* -> *) -> ???.
18:01:09 <aavogt> well you could write the a if you had some kind of quantification
18:01:19 <aavogt> universal quantification on that variable
18:01:47 <aavogt> ie. class forall a. Functor (f a) where fmap :: ...
18:02:12 <aavogt> but that's probably bad for some other reason. Or it's isomorphic to whatever we already have
18:02:13 <det> I think I understand constructor classes now, thanks
18:02:19 <BMeph> aavogt: Except, that isn't a Functor. It's a Functor applied to a type. :)
18:02:37 <det> The whole * -> * think leaves me confused though
18:02:42 <det> thing*
18:02:52 <kmc> :k Maybe
18:02:53 <lambdabot> * -> *
18:03:05 <kmc> Maybe is not a type.  It takes a type (kind *) and produces another type (kind *)
18:03:07 <Philonous> aavogt: Type level lambdas would be really great to have.
18:03:09 <kmc> So it's like a type-level "function"
18:03:22 <kmc> Philonous, they exist in Core iirc
18:03:33 <BMeph> That reminds me; I'm going to try my hand at a Monad tutorial. I think it's time I failed in a more spectacular fashion. :)
18:03:36 <kmc> and type families are like type-level functions
18:04:00 <det> Maybe is like ML option, right ?
18:04:06 <kmc> yes
18:04:07 <kmc> @src Maybe
18:04:08 <lambdabot> data Maybe a = Nothing | Just a
18:04:15 <BMeph> det: It is Exactly like it. :)
18:04:18 <kmc> so "Maybe" is not a type, because its kind is not *
18:04:24 <kmc> you can't have a value of type "Maybe"
18:04:36 <kmc> you can have a value of type "Maybe Int" or even "Maybe a", which means "forall a. Maybe a"
18:04:39 <kmc> :t Nothing
18:04:40 <lambdabot> forall a. Maybe a
18:04:50 <BMeph> kmc: ...except for when you can. ;)
18:04:54 <det> I dont understand why you assign Maybe any type at all
18:05:04 <kmc> BMeph, explain?
18:05:29 <kmc> det, you need a way to say "Maybe is a type parametrized on exactly one other type"
18:05:32 <kmc> :k Either
18:05:33 <lambdabot> * -> * -> *
18:05:40 <kmc> so Either is parametrized on two types
18:05:42 <BMeph> kmc:  class Functor f where fmap :: (a->b) -> f a -> f b; instance Functor Maybe
18:05:55 <det> ok
18:05:57 <kmc> BMeph, that doesn't create any values of type Maybe
18:06:01 <kmc> that's definitely a kind error
18:06:08 <kmc> > Just 3 :: Maybe
18:06:09 <lambdabot>   `Data.Maybe.Maybe' is not applied to enough type arguments
18:06:09 <lambdabot>  Expected kind `...
18:06:19 <kmc> :k StateT
18:06:20 <lambdabot> * -> (* -> *) -> * -> *
18:06:20 <det> so "* -> * -> *" is like "'a 'b t" in Ocaml ?
18:06:26 <kmc> yes
18:06:36 <kmc> so StateT expects a type, and a one-type-expecting constructor, and another type
18:06:45 <kmc> :k StateT Int IO
18:06:46 <lambdabot> * -> *
18:07:19 <kmc> the first type parameter represents the type of the state; the second is the monad you're wrapping (which is itself kind * -> *, like all Monads)
18:07:28 <BMeph> kmc: What _is_ "a value of type Maybe"?
18:07:36 <kmc> BMeph, that's my point, there's no such thing
18:08:42 <BMeph> kmc: But if there is such a thing, you've just shot down anyone's attempt to inform you about it, because you claim it doesn't exist. :\
18:10:01 <kmc> ?
18:10:02 <det> This is such a helpful channel, I seem to always get the answers I am looking for, Thanks!
18:10:13 <kmc> i'm confused
18:10:39 <kmc> BMeph, if there is such a thing, i expect someone would give an example and i would stand corrected and be enlightened by it
18:10:48 <det> What's the point of using * for kinds
18:10:57 <kmc> det, * is just a convenient name for "type"
18:10:58 <kmc> :k Int
18:10:59 <lambdabot> *
18:11:07 <kmc> "Int :: *" means "Int is a type"
18:11:09 <det> why not "a -> b -> c" for the kind of Either
18:11:21 <kmc> because that would imply that a, b, c are some unknown kinds
18:11:25 <kmc> that they're variables
18:12:00 <kmc> it's like the difference between function types "a -> b -> c" and "() -> () -> ()"
18:12:05 <det> Do you ever need to use "*" in the rhs of "::" in Haskell ?
18:12:10 <kmc> doubtful
18:12:15 <kmc> but you might need to use * -> *
18:12:15 <FunctorSalad_> -XKindSignatures
18:12:22 <kmc> it's really rare to need to specify kinds
18:12:25 <kmc> now, the *types* of the constructors for Either are another matter
18:12:26 <FunctorSalad_> -XEvilSignatures
18:12:26 <kmc> :t Left
18:12:27 <lambdabot> forall a b. a -> Either a b
18:12:29 <kmc> :t Right
18:12:30 <lambdabot> forall b a. b -> Either a b
18:12:39 <det> I dont understand why you would ever need to specify kinds
18:12:42 <kmc> there, you have variables, because there's polymorphism
18:12:54 <BMeph> :k Right
18:12:55 <kmc> det, in certain fancy cases like declaring type families
18:12:55 <lambdabot> Not in scope: type constructor or class `Right'
18:12:58 <FunctorSalad_> det: to leave out bogus parameters in GADT decls
18:13:21 <det> ok, I am not very familiar with GADTs, maybe that is my confusion
18:13:28 <FunctorSalad_> it bugs some people that the variable name in the head of a gadt decl doesn't have any meaning (as opposed to normal data decls)
18:13:29 <kmc> det, are you a haskell beginner?
18:13:34 <FunctorSalad_> (i.e. me)
18:13:52 <det> FunctorSalad_, what is the head of a gadt decl
18:14:23 <FunctorSalad_> data Stream a where Cons :: a -> Stream a -> Stream a
18:14:31 <FunctorSalad_> I mean the "data Stream a" part
18:14:40 <FunctorSalad_> you can change it to
18:14:41 <det> kmc, I am not very interested in Haskell TBH, I have serious reservations about certain properties of the language, but I am interested in many of its features
18:14:44 <FunctorSalad_> data Stream b where Cons :: a -> Stream a -> Stream a
18:14:47 <FunctorSalad_> same meaning
18:14:57 <FunctorSalad_> or you can do:
18:15:04 <FunctorSalad_> data Stream :: * -> * where Cons :: a -> Stream a -> Stream a
18:15:11 <det> kmc, I would like to implement a toy ML language with type classes
18:15:31 <FunctorSalad_> a heretic :o
18:15:46 <mrbluesky> ML
18:15:48 <mrbluesky> ?
18:15:58 <det> ML is a family of languages
18:16:07 <det> including Ocaml and SML
18:16:16 <mrbluesky> Oh, you mean functional?
18:16:22 <det> no
18:17:02 <det> ML is a functional language, but ML does not mean "functional"
18:17:18 <mrbluesky> ok.
18:17:35 <kmc> Haskell has some ML heritage but is not a member of the ML family by any means
18:17:38 <det> kmc, but yeah, I haven't had very much experience with Haskell
18:17:55 <kmc> i was just wondering, because it's uncommon that beginners have to think much about kinds
18:18:05 <kmc> perhaps if you're doing fancy things with typeclasses, it's a different issue
18:18:13 <kmc> anyway it is good to know
18:18:15 <det> someone else brought them up
18:18:39 <det> mostly I just didnt understand the notation
18:18:50 <BMeph> det: Just curious, but do you have a blog or somewhere that you list those reservations you have, or are they succinct enough to mention here? :)
18:19:24 <det> purity and lazy evaluation are big ones :-)
18:19:48 <kmc> det, what's wrong with purity?
18:19:49 <FunctorSalad_> purity is the best thing ever
18:19:53 <kmc> we still have a way to do side effects
18:19:56 <kmc> it's just more principled
18:20:11 <kmc> we've disentangled the concepts of "function" and "side-effect-having thing", which are muddled in most languages
18:20:17 <BMeph> det: ...and by "purity" you mean what, exactly? (Since there are multiple definitions of the term.)
18:20:37 <kmc> so e.g. something with side effects but no arguments is not a function at all
18:20:46 <kmc> it makes no sense for that to be a function in a mathematical sense
18:21:04 <mmorrow> http://www.cse.unsw.edu.au/~pls/thesis/davidt-thesis.pdf
18:21:23 <camio> kmc, well aside from a function of type a -> IO b.
18:21:24 <mmorrow> "Given the LLVM optimiser is one of LLVM’s most publicised features, its current complete uselessness is surprising."
18:21:40 <kmc> hehe
18:21:49 <det> lazy evaluation is more of a problem for me
18:21:53 <kmc> camio, that's a function which returns a side-effect-having thing
18:22:08 <det> I am not very familiar with how Haskell handles side effects
18:22:09 <kmc> they're still totally separate
18:22:10 * mmorrow isn't surprised, because most optimizations that need to be done on haskell code really need the information that's present at the Core level
18:22:15 <camio> kmc, That's what I think of when I see void f( int i ).
18:22:31 * FunctorSalad_ seconds kmc about the disentangling
18:22:39 <mmorrow> low-level optims can't really restructure the entire program's control flow
18:22:43 <kmc> there is no such thing as an "impure function" in haskell.   only a pure function which returns an impure non-function
18:23:26 <SubStack> -_-
18:23:32 <det> what would the type of "print_string" be in Haskell
18:23:36 <kmc> :t putStrLn
18:23:36 <lambdabot> String -> IO ()
18:23:44 <kmc> takes a string, returns a "recipe" which does IO
18:24:02 <kmc> "IO ()" means "recipe which does IO and produces no useful value"
18:24:10 <kmc> because () is a useless type with only one value, which is also named ()
18:24:12 <SubStack> kmc: as I understand it that is not entirely correct
18:24:22 <Cale> Compare and contrast:
18:24:25 <Cale> :t getLine
18:24:26 <lambdabot> IO String
18:24:31 <det> () is unit ?
18:24:33 <kmc> yes
18:24:39 <Cale> det: yeah, or empty tuple
18:24:45 <kmc> getLine is not even a function.  it's just a recipe which gives you a string.  it doesn't need any arguments to do that
18:25:25 <det> why does unsafePerformIO exist
18:25:37 <kmc> for black magic
18:25:38 <aavogt> for foreign functions
18:25:48 <Cale> det: In order to allow for a way to extend Haskell's evaluation mechanism without rebuilding the compiler.
18:25:53 <kmc> for implementing libraries that have a pure API using an impure implementation
18:26:09 <kmc> basically when you use unsafePerformIO you take on a large personal responsibility which is usually handled by the compiler
18:26:20 <Cale> But you should still treat using unsafePerformIO with the same gravity as making a change to your compiler.
18:26:20 <camio> det, it doesn't exist as part of the Haskell 98 standard.
18:26:28 <BMeph> Or, as a Java programmer might say, "obviously, it's for performing IO unsafely! Geesh!" ;p
18:26:29 <noknok> Hi there, I just became quite frustrated after destroying the Haskell system on my Ubuntu machine. I wrote some modules and now I started to study the Cabal docs to find out how to properly package them. But I didn't have cabal available. So I thought I simply install the whole new Haskell platform to have all the goodies in one go. But when following the instructions, it complained that it would need GHC 6.10.4 and I only had 6.8.x. (There
18:26:30 <noknok> was a flag for unsupported versions, but that failed as well.) So I tried to update GHC, but the ubuntu repositories seem to think of 6.8 as the latest version, at least that's what synaptic told me. So I simply removed the whole GHC (vie synaptic).
18:27:01 <Cale> noknok: Don't compile the Haskell platform yourself
18:27:12 <trin_cz> Hi all, I'm trying to use MonadReader and I'd like to call ask several levels of function calls below runReader. All examples I find use only 1 level (fi RWH chapter 15 ).
18:27:25 <luite> noknok: ubuntu 9.10 has ghc 6.10.4
18:27:26 <noknok> Cale: What do you mean?
18:27:27 <Cale> noknok: For Ubuntu, I would just get the generic linux binary of GHC.
18:27:28 <SubStack> noknok: also don't get the OS to handle haskell packages
18:27:34 <mrbluesky> Ubuntu Repos are shit
18:27:35 <det> so, I dont understand the significance of returning "IO ()"
18:27:57 <Cale> noknok: The Haskell platform is something designed to be made into packages by the people who make various distributions.
18:28:32 <det> is it just telling you that the function performs IO ?
18:28:38 <kmc> det, the function doesn't really do IO
18:28:38 <Cale> noknok: I'm guessing the reason that it complained you don't have 6.10 was that you got the source?
18:28:45 <kmc> the function computes a recipe for doing IO
18:28:50 <kmc> which has type IO ()
18:28:59 <det> so when is the recipe executed
18:29:07 <kmc> when you glue it onto other recipes
18:29:12 <Cale> det: In a compiled program, main gets executed.
18:29:12 <kmc> and name the outer thing "main"
18:29:20 <kmc> or, when you type it at the prompt in GHCi
18:29:29 <Cale> Actually, we usually call these things 'actions'
18:29:40 <Cale> But 'recipe' isn't a bad description :)
18:29:45 <kmc> thanks
18:29:48 <det> so, if I add a debugging statement to a function, it can break a function that is calling it ?
18:30:01 <kmc> det, you can't add a debugging statement to a function
18:30:07 <noknok> Cale: I installed the original Haskell systems (also Hugs etc) via the Synaptic package manager. I never did things via source code.
18:30:10 <FunctorSalad_> we use an unsafe function for tracing
18:30:15 <kmc> if your function returns an IO-recipe, you can add a debugging statement to that recipe
18:30:19 <Cale> det: You can't have the evaluation of a function print things normally.
18:30:25 <FunctorSalad_> which is fine, since you *want* execution of that statement to depend on eval order
18:30:31 <Cale> det: Only executing an IO action can print something.
18:30:53 <Cale> noknok: hmm
18:30:56 <kmc> in Haskell there are two orthogonal worlds: functions, which have arguments and are applied like (f x), and IO recipes, which don't have arguments and are glued together like (a >> b)
18:30:58 <det> Couldnt some kind of effect inference get all the same information as monads ?
18:31:04 <kmc> det, what do you mean?
18:31:07 <Cale> noknok: I mean for the Haskell platform, how did you get it? Was it as .deb packages?
18:31:27 <FunctorSalad_> det: classes of monads get you that essentially
18:31:37 <FunctorSalad_> @type liftIO (putStrLn "foo")
18:31:38 <lambdabot> forall (m :: * -> *). (MonadIO m) => m ()
18:31:48 <kmc> and of course these worlds interact: you can have a function which returns an IO action (an "impure function"), or an IO action which (when executed) produces a function
18:31:48 <FunctorSalad_> @type put 10
18:31:49 <lambdabot> forall t (m :: * -> *). (Num t, MonadState t m) => m ()
18:32:53 <kmc> anyway it's fine to think about "impure functions" in an informal sense, but really there are these two orthogonal concepts of "function" and "impurity"
18:33:11 <kmc> now that's the semantics
18:33:18 <kmc> syntax-wise, IO actions look very much like normal imperative code
18:33:34 <noknok> Cale: no, the Haskell platform is the only Haskell component I installed after unpack the tar.gz file and following the instructions.
18:33:36 <kmc> thanks to the "do" notation, which desugars into applications of the basic monad combinators, which are named "return" and "(>>=)"
18:33:48 <kmc> and in fact that notation generalizes to all monads
18:34:08 <asitdepends> Hey, is this illegal ?
18:34:10 <asitdepends> read "string" :: String
18:34:11 <kmc> in general monads are not just for side effects, they're also used to model things like parsers, continuations, software transactional memory, nondeterminism, ...
18:34:14 <asitdepends> ghci says that "*** Exception: Prelude.read: no parse
18:34:14 <det> what is the benefit of jumping through all these hoops ?
18:34:17 <kmc> > read "string" :: String
18:34:18 <lambdabot>   "* Exception: Prelude.read: no parse
18:34:22 <FunctorSalad_> like the reverse state monad *runs*
18:34:23 <kmc> > read "\"string\"" :: String
18:34:24 <lambdabot>   "string"
18:34:35 <asitdepends> oh thanks
18:34:38 <Cale> asitdepends: The string must be quoted, like what happens with show
18:34:44 <kmc> > show "string"
18:34:45 <lambdabot>   "\"string\""
18:34:49 <kmc> > text $ show "string"
18:34:49 <lambdabot>   "string"
18:35:01 <asitdepends> thank you
18:35:01 <Cale> asitdepends: Of course, if you don't want that, the identity function will work just fine ;)
18:35:43 <FunctorSalad_> > ( foldr (.) id (replicate 10 show) ) "string"
18:35:44 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
18:35:46 <Cale> det: Preserving referential transparency
18:35:50 <noknok> Just found out about a special link for haskell in ubuntu https://wiki.ubuntu.com/MOTU/Teams/UncommonProgrammingLanguages/Haskell
18:36:00 <Saizan> det: the point is that code with some effect has it documented in the types, so it's much easier to reason about your programs
18:36:34 <det> Saizan, that makes sense
18:36:37 <Cale> noknok: you can get a binary of GHC from http://haskell.org/ghc/download_ghc_6_10_4.html
18:36:47 <BMeph> det: Which is what we (Haskell-users in general) mean when we say "purity"; referential transparency.
18:36:50 <kmc> you can also make more fine-grained, or just different "effect worlds"
18:36:51 <Cale> noknok: The generic linux binary works rather well
18:37:07 <kmc> like STM, which encompasses atomic operation groups within concurrent programs
18:37:09 <det> BMeph, I am just trying to understand practical benefits
18:37:38 <det> effects being documented by types is a nice practical advantage
18:37:46 <Cale> det: In Haskell if you have a function, say f, and you apply it to some value while testing it, and it produces the correct result, you have a guarantee that it will actually produce that result when you use it in a program.
18:37:58 <Cale> det: and every time you call it with the same parameters in the future
18:38:15 <det> oh right, you need this for lazy evaluation
18:38:29 <Cale> det: You also know that it didn't do anything sneaky behind your back, like talk to some machine over the network.
18:38:38 <det> probably why I dont see much importance as a proponent of strict languages
18:39:30 <Saizan> yeah, effects don't mix well with a loose evaluation order
18:39:35 <Cale> det: Well, there's that too, but there's a lot more benefits to referential transparency on its own
18:40:04 <Cale> det: Lazy evaluation may be the reason that Haskell managed to figure out a good way to preserve referential transparency though.
18:41:03 <det> What about this
18:41:21 <camio> Cale, Could it be stated that Haskell isn't really all lazy, but lazy by default?
18:41:25 <Cale> Well, actually, it's worse than that, you could almost reasonably do I/O in a language which was just lazily evaluated (but it would be strange). Haskell isn't defined to be lazily evaluated, it's defined to have nonstrict semantics, and any implementation which has the same termination behaviour as lazy evaluation is fine.
18:41:35 <BMeph> det: So by "purity" what do you mean? :)
18:42:13 <Cale> So, a Haskell implementation is free to choose the order of reduction, as long as it isn't so strict that it results in taking forever on some program which should terminate.
18:42:21 <det> Let's say I wanted to write a function that takes a list and returns the nth greatest element
18:42:45 <kmc> Int -> [a] -> a
18:42:54 <det> still yping
18:42:57 <Cale> > \n xs -> sortBy (flip compare) xs !! n
18:42:57 <det> Now let's say I have written this in a referentially transparent way
18:42:58 <lambdabot>   * Exception: Prelude.(!!): negative index
18:43:06 <Cale> er, heh
18:43:18 <Cale> Didn't mean to ask lambdabot to work on that :)
18:43:28 <det> but somewhere along the long I decide it is best to convert to an array, do in place quicksort and then index
18:43:32 <noknok> Cale (and others): thanks for your time. I think I install the binary from your mentioned link tomorrow. For now I call it a day, it's late here in Amsterdam. Cheers..
18:43:33 <Cale> (the error is from the Show instance which applies the function to various small values)
18:43:50 <Cale> det: You would use the ST monad.
18:44:02 <det> wouldnt that change how callers must use this function ?
18:44:19 <luite> why would it?
18:44:26 <Cale> det: ST lets you have mutation and memory effects locally, but no other side effects. It provides a function which produces a pure result.
18:44:32 <Zao> @type runST
18:44:34 <lambdabot> forall a. (forall s. ST s a) -> a
18:44:40 * FauxFaux stalks Zao.
18:45:02 <Zao> FauxFaux: I'll turn you into WHNF!
18:45:26 <det> so, my convert to array, mutate array function could still have type: [a] -> Int -> a ?
18:45:34 <FauxFaux> Zao: Nooo!
18:45:35 <luite> yes
18:45:35 <Cale> det: yeah
18:45:57 <det> Interesting
18:46:14 <Cale> Well, (Ord a) => [a] -> Int -> a   ;)
18:46:19 <Zao> Pay no attention to the awesome monads behind the curtains.
18:46:21 <det> well sure :-)
18:46:28 <aavogt> but you don't get to modify the [a] in-place
18:46:42 <Cale> You'll still have to pack the list into an array, of course.
18:46:46 * BMeph wonders: Is he Friend...or Faux? ;p
18:47:35 <det> so, if it took an array as an argument, the type would have to reflect that it mutated the array ?
18:47:46 <kmc> yeah
18:47:53 <kmc> there are immutable arrays and mutable arrays
18:48:02 <Cale> Well, more importantly if it produced an array as a result.
18:48:02 <det> SML has same
18:48:03 <kmc> the latter are always modified in-place, within some particular monad
18:48:12 <kmc> immutable arrays are only "modified" by producing a new one
18:48:14 <det> calls immutable arrays "vectors"
18:48:20 <kmc> (of course, the implementation is free to share data where possible)
18:48:24 <luite> det: yes, the actual type of runST is not really important now, but the important thing is that it does not let you mix 'side effects' from different ST calculations together. so a mutable array in one ST calculation can never escape to another
18:48:56 <Cale> :t runST
18:48:58 <lambdabot> forall a. (forall s. ST s a) -> a
18:49:18 <Cale> :t newSTArray
18:49:19 <lambdabot> Not in scope: `newSTArray'
18:49:22 <Cale> :t newSTRef
18:49:24 <lambdabot> forall a s. a -> ST s (STRef s a)
18:49:25 <aavogt> where does the initial state come from?
18:49:32 <aavogt> :t runState
18:49:34 <lambdabot> forall s a. State s a -> s -> (a, s)
18:49:34 <kmc> aavogt, ST uses IORef-like references
18:49:37 <kmc> in fact, STRefs
18:49:41 <kmc> so you create them within the monad
18:49:57 <aavogt> ah
18:50:01 <kmc> on GHC, ST is actually in-place, like IO, and unlike State, which is just sugar for passing state around functionally
18:50:10 <det> how about this: what would be the type of a function that takes a list, converts to array, sorts array, returns array ?
18:50:12 <kmc> in fact IO on GHC is just ST RealWorld
18:50:20 <kmc> det, mutable array?
18:50:21 <Saizan> 's' is a tag identifying a single runST invocation, rather then the type of the state
18:50:28 <Cale> [a] -> ST s (STArray s a)
18:50:29 <luite> det: no problem at all, you can return immutable arrays in pure code
18:50:30 <Saizan> in fact ST has a whole heap as state
18:50:31 <det> kmc, yes, to do in place quicksort
18:50:46 <Cale> Or yeah, you could freeze the STArray
18:50:50 <det> Could it be just Ord a => [a] -> Array a ?
18:51:09 <kmc> [a] -> IO (IOArray a)
18:51:12 <luite> yes, but your array would be immutable
18:51:50 <Saizan> it could use mutation in the sorting, and then freeze it in an immutable one, and have that type
18:52:05 <det> can you unfreeze a mutable array
18:52:11 <det> I mean, immutable
18:52:11 <kmc> the more general type: (Monad m, MArray a e m, Ix i) => [e] -> m (a i e)
18:52:19 <Cale> det: yeah, by copying it
18:52:30 <kmc> probably copy-on-write
18:52:40 <luite> det: it is possible, but it's either an unsafe operation, or you copy it
18:52:51 <det> well, that makes sense
18:53:16 <det> but I dont like that you must return an IO monad to return a mutable array
18:53:27 <Cale> det: ST monad.
18:53:35 <kmc> you return an IO action
18:53:41 <Cale> (or ST action)
18:53:45 <kmc> "IO monad" describes a type constructor, not a value
18:54:04 <reltuk> ok, I'm writing this server / simulation arena for a card game
18:54:04 <Cale> Yeah, that's a good point of terminology :)
18:54:16 <luite> det: freezing is usually unsafe too (unless you have a special wrapper, like runSTArray instead of runST), because you must make sure that you don't modify the mutable array after you have frozen it (because changes would be reflected in the contents of the immutable one)
18:54:24 <reltuk> and so I need to have different ais which compete with each other...
18:54:47 <det> luite, I guess you would need linear types to be safe
18:55:09 <reltuk> as a first stab I made the ais have type PublicGameState -> PlayerAction
18:55:18 <Cale> det: Well, this use of monads effectively is a lot like linear types packaged up in a different way.
18:55:32 <luite> det: runSTArray is actually safe, the last action in your ST computation returns a mutable array. because the ST computation is finished at that point, it is safe to freeze that result
18:55:38 <reltuk> but of course they need mutable state, so need to thread some state along
18:55:52 <reltuk> but they different state...the functoin should have complete control over it
18:56:11 <det> do you always need to pass IO actions around to pass mutable arrays around, even if you dont mutate it ?
18:56:27 <Cale> reltuk: Use a type parameter?
18:56:36 <luite> det: you need IO or ST yes
18:56:37 <Cale> det: No.
18:56:38 <reltuk> Cale: can they go in a list together?
18:56:47 <luite> oops, I guess Cale knows better :p
18:56:50 <Cale> det: Not when you pass them as parameters.
18:57:04 <det> ok, what about this function:
18:57:15 <Cale> You need IO/ST where you make use of IO or ST arrays.
18:57:16 <reltuk> Cale: if they're parameterized on their state type, I mean
18:57:26 <Cale> reltuk: Oh, no.
18:57:32 <Cale> reltuk: You might want to use existentials.
18:57:40 <det> take an array, return a tuple of the 10th element and the array
18:57:51 <det> do you need to involve an IO action for that ?
18:58:15 <Cale> det: what kind of array?
18:58:38 <det> mutable
18:58:39 <luite> det: depends, if the array is an IOArray, the result would be an IO action that gets as an argument the array, and retrieves the value
18:58:55 <Cale> For IOArray, you do, because reading the array is an IO action.
18:59:08 <Cale> and so any computation you build up from that will be an IO action
18:59:26 <reltuk> Cale: the gross solution I was considering was to serialize the state into strings
18:59:33 <Cale> However, you could write an IO action which reads the 10 element of the array, and passes it to a pure function which you wrote somewhere.
18:59:58 <det> Ok, I think I understand now
18:59:59 <det> thanks
19:00:02 <reltuk> Cale: I basically want something like that...the only thing that will ever look at it is a function which knows what it is...maybe Dynamic?
19:00:17 <Cale> reltuk: Dynamic can work.
19:00:36 <Cale> reltuk: That'll restrict them to Typeable state, but for the most part that's okay.
19:00:58 * hackagebot upload: filestore 0.3.2.2 - Interface for versioning file stores. (JohnMacFarlane)
19:01:12 <reltuk> what kinds of things aren't typable?
19:01:22 <mmorrow> polymorphic things
19:01:40 <det> do all side effects act upon IO?
19:01:46 <mmorrow> , toDyn id
19:01:47 <lunabot>  luna: Ambiguous type variable `a' in the constraint:
19:01:52 <mmorrow> , toDyn (id::Int->Int)
19:01:54 <lunabot>  <<Int -> Int>>
19:02:01 <mmorrow> , toDyn (id::()->())
19:02:02 <lunabot>  <<() -> ()>>
19:02:13 <Cale> det: You can think of a value of type (IO t) as being an abstract representation of an imperative program which can do anything that, say, a C program could do.
19:02:17 <reltuk> I think this will be alright as a start...
19:02:18 <mmorrow> , toDyn (id::forall a. Typeable a => a -> a)
19:02:19 <lunabot>  luna: Ambiguous type variable `a' in the constraint:
19:02:25 <Cale> det: (before producing a result of type t)
19:02:37 <Cale> det: So, like, the source code of such a program, perhaps.
19:02:48 <mmorrow> you can wrap in an existential though to get some polymorphism back
19:03:12 <mmorrow> data Box = forall a. Typeable a => Box a
19:03:28 <mmorrow> or something
19:03:31 <Cale> det: and of course, whose behaviour can depend on the result of pure Haskell evaluation :)
19:03:31 <det> Cale, but do all side effects go into IO?
19:03:37 <Cale> det: effectively, yeah.
19:03:47 <Cale> det: Well, IO or ST or STM
19:04:01 <Cale> Or some other monad built from those.
19:04:15 <Cale> Printing a string? It needs to be IO
19:04:36 <Cale> Basically, everything which does real input or output needs to be in IO.
19:04:46 <FunctorSalad_> ContT r (StateT S (ZygoT IO))
19:05:08 <mmorrow> @unmtl ContT r (StateT S (ZygoT IO))
19:05:08 <lambdabot> err: `ContT r (StateT S (ZygoT IO))' is not applied to enough arguments, giving `/\A. (A -> S -> ZygoT IO (r, S)) -> S -> ZygoT IO (r, S)'
19:05:10 <det> I would think that you could annotate all side-effecting primitives/FFI of a ML lanaguage and get the same information as Haskell monads
19:05:17 <mmorrow> @unmtl ContT r (StateT S (ZygoT IO)) a
19:05:17 <lambdabot> (a -> S -> ZygoT IO (r, S)) -> S -> ZygoT IO (r, S)
19:05:28 <FunctorSalad_> mmorrow: doesn't exist :)
19:05:40 <mmorrow> ContT and StateT do however
19:05:48 <Cale> det: Only by imposing exactly the same inconvenience.
19:06:40 <Cale> det: (which isn't much inconvenience at all)
19:06:57 <Cale> But yeah, you could do the same thing in the type system of ML, sure.
19:07:50 * BMeph wonders if augussts would try to write a Haskell interpreter in LML today...
19:08:00 <det> I mean, you could get the type system to tell you "Hey, this function mutates this value", but it wouldnt affect how you use the that value
19:08:04 <shapr> Hii! I'm looking for anyone here who might know of Haskellers in Alabama, particularly in Huntsville Alabama.
19:08:26 <Nafai> shapr: I know of one in Alabama
19:08:31 <shapr> Nafai: Who?
19:08:31 <Nafai> shapr: But you already know him
19:08:35 <shapr> oh
19:08:35 <shapr> right
19:08:38 <Cale> det: Of course that would affect how you can use a value, because things which use that value would require the same annotation.
19:08:39 <Nafai> :)
19:08:50 <shapr> You mean geezusfreek, yeah?
19:09:02 <det> shapr, ltns, did you move to the USA?
19:09:24 <Cale> det: Or else, just like in Haskell, you can, from within an IO action, pass the result of another IO action to a pure function and compute a pure result.
19:09:29 <shapr> det: dude! Yeah, I've moved ... three times? inside the USA already!
19:09:55 <mmorrow> reltuk: err, actually that Box example doesn't add much. there's a "trick" though wrt getting some limited form of polymorphic things into/outof dynamic, i don't recall exactly the method though
19:09:59 <det> shapr, Were you from Finland or did you move there, I dont remember
19:10:05 <shapr> Nah, I'm from Alabama!
19:10:05 <Cale> shapr: I know a second one in Alabama. (It's you.)
19:10:11 <shapr> Jag är Alabamsk!
19:10:16 <BMeph> Ah, Huntsville, where NASCAR and NASA collide (but, hopefully, not literally, 'cause that'd be a Huge explosion, y'know)... ;)
19:10:21 <spink> Is there a way to use sequence and maps to create a 3 nested loop that does array updates without using mutable arrays ? What I have in mind is this code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4847#a4847
19:10:31 <shapr> Right, so I'd like to know any NASA contacts if possible.
19:10:43 <det> shapr, how did you find y ourself in Finland before ? :-)
19:10:47 <shapr> I want to start up a Haskell User's Group, as always, but I need to find programming language theory people.
19:10:51 <gokul> how do i partially apply the tuple constructor (,)? I want to be able to do something like this: "let x = (, 1)" and then "x 5" should return "(5, 1)"
19:10:53 <shapr> det: There was this woman...
19:11:00 <det> I see :-)
19:11:01 * Cale is always surprised at how much people care about mutating arrays
19:11:10 <Cale> Personally, I mostly use Data.Map
19:11:13 <det> Cale, quicksort is important :-)
19:11:13 <camio> gouk let x = (,) 1
19:11:18 <shapr> det: And that got me from Seattle to Finland, and then to Sweden, and then the woman thing stopped happening, and I came back to the USA.
19:11:29 <camio> oops
19:11:30 <Cale> det: Not really. It's not even optimal.
19:11:31 <mmorrow> spink: either an (IntMap a) or a (Seq a) are two ways to simulate a mutable array with an immutable data structure
19:11:36 <ttmrichter> shapr: Because you want a job with NASCAR?
19:11:43 <camio> gouk, let x = flip (,) 1
19:11:43 <Cale> det: For lists, a mergesort is usually more effective.
19:12:06 <det> Cale, you mean, compared to converting to an array first?
19:12:08 <Cale> det: But even on mutable arrays, it's only *average* case O(n log n)
19:12:09 <shapr> ttmrichter: Uh, yeah. No, wait... I lived in Alabama and had a Haskell job for awhile, then I moved to Boston and got a C# job, and now I'm an unemployed student in Alabama again.
19:12:15 <Nafai> shapr: I've started an alt-lang group here, that is working well.  We discuss Common Lisp, Factor, Scala, Clojure, at some point Haskell
19:12:20 <mmorrow> spink: i'd use IntMap personally, unless you need to append two of these things, in which case i'd use Seq
19:12:21 <shapr> Nafai: awesome!
19:12:23 <Cale> It's worst case O(n^2), and you can do better than that
19:12:47 <shapr> But I think I got a job offer last night, for writing C and C++
19:12:59 <dolio> If we can't mutate arrays, how will we implement our hash tables?
19:13:08 * hackagebot upload: filestore 0.3.3 - Interface for versioning file stores. (JohnMacFarlane)
19:13:10 <mmorrow> spink: because "appending" two IntMaps that are being treated semantically as ordered sequences/arrays would make it necessary to change all the keys of one of them
19:13:27 <shapr> det: What's up with you these days?
19:13:42 <mmorrow> but Data.Sequence is made for this
19:13:49 <Nafai> shapr: Lucky!  I'm having problems finding a job these days, not sure if I should just resign myself to Java or what
19:14:13 <mmorrow> however, IntMap lookup/delete/replace/modify may be faster than the equiv with Seq
19:14:26 <det> Cale, comparison sorting cant beat O(n log n) though..
19:14:27 <mmorrow> faster in clock time
19:14:55 <Cale> det: Yes, but there are comparison sorting methods which are worst case O(n log n), rather than just average case.
19:14:59 <det> Cale, and there are tricks of changing algorithm to get rid of worst case
19:15:13 <spink> mmorrow, Is ther any way to avoid IntMap and use Unboxed Arrays with the  // operator ?
19:15:15 <mmorrow> dolio: the horror!!@
19:15:15 <Cale> and you don't even need mutation
19:15:28 <det> Cale, in place array sorting is low memory usage and fast in practive
19:15:46 <mmorrow> spink: oh sure, you can use unboxed arrays, which'd be much faster than using an IntMap or Sequence
19:15:46 <Cale> det: Yes, but it also destroys the original, which is quite inconvenient.
19:15:57 <det> Cale, it all depends on what you want
19:15:58 <dolio> mmorrow: Hash tables are the single most important factor for choosing a programming language.
19:15:58 <mmorrow> spink: you have to be in a monad then though
19:16:07 <mmorrow> dolio: seconded.
19:16:17 <det> Cale, and you can always copy the array and then sort if you need a copy
19:16:26 <Cale> det: But yeah, Haskell's Data.List.sort is a merge sort.
19:16:37 <Cale> and it's always O(n log n) time.
19:16:55 <mmorrow> spink: which is fine (i was answering the (maybe i misunderstood) question of how to approximate this with immutable datastructures)
19:16:55 <det> Cale, and sorting a list isnt exactly going to share any data with the original
19:17:08 <Cale> and I believe it's also lazy, so that you can get the first k elements in O(n log k) time.
19:17:10 <det> Cale, so it has no advantage of array copy
19:17:40 <Cale> (so sort degrades to O(n) minimum if you take the head)
19:17:42 <mmorrow> det: that pre-supposes there aren't multiple references to the array already
19:18:02 <det> mmorrow, I am talking about copying, then sorting the copy
19:18:18 <det> You can quicksort the first or last N elements too
19:18:29 <shapr> Yeesh, University of Alabama at Huntsville doesn't appear to have a single PLT guy on the faculty.
19:18:49 <mmorrow> det: oh, well what is the issue then? (i'm confused about what we're talking about)
19:18:50 <sg> Cale: yesterday i've read about the concepts you suggested on haskell
19:19:04 <sg> i found the algebraic datatypes thing a lot interesting, thanks :)
19:19:22 <spink> mmorrow, to be specific I am trying to write the floyd algo with an Unboxed array. The problem for me is how to simulate the nested loops.
19:19:27 <det> mmorrow, Im saying quicksort is of large practical importance and is a very good reason why mutating arrays is important
19:19:28 <spink> I tried that with the sequence in the code I posted but the map gives back a list which destroys the thing
19:19:42 <mmorrow> det: ok, so use a mutable array
19:19:55 <det> sure
19:20:12 <mmorrow> spink: hmm ok, /me looks at the code more closely
19:20:23 <leimy_> having a heck of a time trying to find a space leak
19:20:30 <mmorrow> @hoogle (//)
19:20:30 <lambdabot> Data.Array.IArray (//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
19:20:45 <leimy_> wish I knew how to read Core :-)
19:20:52 <mmorrow> arg, personally i never use IArray
19:21:11 <mmorrow> only unboxed mutable arrays
19:21:18 <mmorrow> otherwise i don't really see the point
19:21:32 <spink> I wanna keep a low mem
19:21:39 <leimy_> I'm trying to understand if this can leak
19:21:46 <spink> the ST monad explodes the mem usage
19:21:49 <dolio> I thought timsort was the bee's knees.
19:21:52 <leimy_> forever (doSomthingThatReturnsStuff >> return ())
19:22:16 <spink> mmorrow, in case you were refering to an IO/ST monad mutable solution
19:22:52 <spink> plus since it's FP I prefer the immutable data.
19:25:05 <spink> plus some more I find a good way to understand the whole sequence-update-your-immutable-array thing
19:33:33 <Cale> det: Oh, I feel like I should have mentioned, the standard libraries have data structures which incur only an additional logarithmic time/space cost and which are immutable.
19:34:18 <Cale> det: For example, Data.Sequence can be indexed, split and concatenated in O(log n) time, read from either end in O(1) time, and is immutable
19:34:50 <Apocalisp> I <3 Data.Sequence
19:35:07 <Cale> det: and that means you can update the value at the kth index in O(log n) time (actually O(log(min(k,n-k)))
19:35:36 <ManateeLazyCat> I'm thinking about Haskell/IPC in my project, any idea ?
19:35:37 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
19:35:42 <det> Cale, I totally understand the greatness of immutable data structures, I just see *zero* benefit about preserving the original for a sort
19:35:45 <Cale> det: Also, there are Data.Set and Data.Map which are surprisingly efficient set and map structures which are immutable :)
19:36:00 <Cale> det: Well, it's often important for testing.
19:36:22 <det> if you need to preserve, you copy, if not you dont
19:36:53 <det> merge sort is going to reallocate your entire list anyways
19:37:14 <Cale> det: When you test programs which are doing mutable updates here and there, you have to be careful to copy everything you need, and ensure that the state is set up just right, then run the program, and then check not only the result of the program, but that the state was updated properly too, which may involve ensuring that you've copied just the right things beforehand.
19:37:17 <mmorrow> spink: i'd do something like this http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4847#a4848
19:37:43 <ManateeLazyCat> I have plan to implement Gtk+ program, that have RootProcess and ChildProcess, i want use RootProcess maintain many ChildProcess, so i want know some IPC information with Haskell.
19:37:47 <ManateeLazyCat> mmorrow: Hi
19:37:51 <narens> hey, can someone explain how the memocombinator works because i tried using it inside a map and it didn't recall the values, but on a fold it did. I can't seem to figure out why that is. When can I expect a memoized function to return the comptuted value?
19:37:59 <mmorrow> spink: (note that i switched to using Int as index so i could use unsafeRead/Write, but you could ditch that if you wanted)
19:38:04 <mmorrow> ManateeLazyCat: hi
19:38:10 <Cale> det: But when you know that there's no mutation involved, you just apply the function to whatever parameters it needs (which are the only things it can depend on), and check the result, (which is the only thing which could possibly be affected by it)
19:38:14 <mmorrow> ManateeLazyCat: so you got the recursive modules sorted out then
19:38:20 <mmorrow> ManateeLazyCat: nice!
19:38:29 <ManateeLazyCat> mmorrow: Thanks for your help, now i haven't any .hs-boot file in my project, happy now. :)
19:38:32 <Cale> det: and there's no need to copy any parameters to the program or worry about hidden global variables :)
19:38:37 <mmorrow> ManateeLazyCat: heh, awesome.
19:38:54 <mmorrow> ManateeLazyCat: how'd you end up organizing the modules?
19:38:59 <ManateeLazyCat> mmorrow: But i got two file: Manatee.Types and Manatee.Manager.
19:39:08 <spink> mmorrow, thanks, I am going to take a look at it now
19:39:13 <mmorrow> ManateeLazyCat: ah, nice
19:39:29 <mmorrow> spink: no problem (untested)
19:39:37 <ManateeLazyCat> mmorrow: I make all types that need communication all in Manatee.Types.hs
19:39:41 <det> Cale, you could just make array sort always copy for the same guarentees, but it still beats merge sort :-)
19:40:00 <mmorrow> spink: so additionally you'd need to create the STUArray inside the ST monad, then dump it to a list or something before you return
19:40:06 <mmorrow> spink: then wrap all that in runST
19:40:11 <narens> anyone? :-)
19:40:26 <ManateeLazyCat> mmorrow: Then i split functions with `module functions` and `communication functions`, then i throw all `communication functions` to Manatee/Manager.hs to handle modules communication.
19:40:28 <Cale> det: Not necessarily.
19:40:44 <mmorrow> ManateeLazyCat: nice
19:40:49 <Cale> det: Quicksort has some bad cases.
19:41:02 <ManateeLazyCat> mmorrow: And i add some layout, every layout have a Manager.hs
19:41:04 <spink> mmorrow, I myself had tried an ST implementation I found, and It was pretty memory consumive, but going to check out your version
19:41:25 <det> Cale, when I say quicksort, I mean quicksort that does median of three and bounds worst case by changing to heapsort
19:41:29 <Cale> det: You can also do an immutable quicksort of course, though the constant factors and asymptotic worst case are not as good as for immutable mergesort.
19:41:40 <ManateeLazyCat> mmorrow: I can use different layout Manager.hs to split different layout in my project.
19:41:51 <det> Cale, and mutable heapsort itself beats immutable sorts and has same worst case
19:41:56 <mmorrow> spink: hmm, if it is super memory-consuming that'd be surprising
19:42:34 <mmorrow> ManateeLazyCat: ah nice, so (Manager.hs, rest...)
19:43:02 <mmorrow> ManateeLazyCat: yeah i like organizing stuff like that, where every subunit of a certain "type" has a given "interface" module
19:43:06 <ManateeLazyCat> mmorrow: Example, i have Manatee/Manager.hs and Manatee/UI/Manager.hs, UI/Manager.hs control UI modules communication, Manatee/Manager.hs control higher abstract
19:43:16 <mmorrow> cool
19:43:22 <Cale> det: While I'll admit that there's obviously some performance benefit to mutation, the main thing which I disagree with about it is that there's an unacceptable maintainence penalty for using mutation. It makes programs harder to understand and reason about to the extent that I would do almost anything to avoid it.
19:44:00 <det> It often makes programs easier to work with
19:44:23 <Cale> It pretty much never makes them easier to understand.
19:44:25 <ManateeLazyCat> mmorrow: Infact, Types.hs make all module won't avoid recursive reference, Manager.hs control module communication, we add layout with different Manager.hs to avoid Manager.hs too big.
19:44:31 <det> I think it can
19:44:42 <det> for example, an IRC client, that keeps a set of users in a channel
19:44:54 <ManateeLazyCat> mmorrow: And different Manager.hs will give me better hierarchy for my project.
19:44:56 <mmorrow> Map Channel (Set User)
19:45:00 <det> you'd have to be constantly passing and returning the state without mutation
19:45:15 <luite> det: you can make a monad for that
19:45:17 <Cale> det: There are ways to wrap that parameter passing up.
19:45:18 <mmorrow> MVar (Map Channel (Set User)
19:45:20 <mmorrow> )
19:45:46 <det> Ok, maybe Haskell has nice ways of dealing with that
19:46:03 <Cale> det: I've also found that explicitly passing parameters is often nicer, because it makes the code easier to test, and it's easy to see what things depend on and affect.
19:46:10 <det> maybe this is the greatness of Monads I always hear about :-)
19:46:20 <ManateeLazyCat> mmorrow: No .hs-boot file crazy me now, it's unbelievable after i refactory all code.
19:46:33 <mmorrow> ManateeLazyCat: nice, i think it'll be way more maintainable now too
19:47:00 <Cale> But yeah, you can also wrap that parameter passing using (say) the State s monad, which is not really using mutation, but wrapping the typical functional idiom for simulating state by passing parameters.
19:47:22 <Cale> and the nice thing about that is that the types still explain what's going on
19:48:05 <O_4> Hi all
19:48:05 <ManateeLazyCat> mmorrow: Yeah, i try to split Manager.hs code to below modules, make communication code simple.
19:48:10 <mmorrow> det: in (pure) functional language, recursing with a modified parameter *is* how you mutate things
19:48:14 <sohum> I've never quite figured out how to use the State monad
19:48:18 <Cale> It's really important that the types explain as much as reasonable about what the program does (without becoming too inconvenient that you don't want to use them :)
19:48:26 <sohum> I always end up rolling my own, or passing parameters explicitly
19:48:34 <mauke> sohum: why?
19:48:38 <sohum> this is an idiocy on my part, of course
19:48:40 <det> mmorrow, it is straightforward with a fold sure
19:48:43 <ManateeLazyCat> mmorrow: That's a really big refactory to remove all IORefObject.
19:48:44 <mmorrow> det: if you're familiar with SSA form at all, SSA is the same thing as having a bunch of mutually recursive functions
19:48:51 <mauke> sohum: there's get and put; what more do you need?
19:49:02 <Cale> Yeah, to be fair, I usually pass the parameters explicitly myself, unless the algorithm is very naturally suited to the State monad.
19:49:05 <O_4> I'm trying to install Hieroglyph via cabal, and I'm getting errors saying "There is no available version of cairo that satisfies -any"
19:49:18 <sohum> mauke: I dunno, I think I just get confused on how it interacts with bind
19:49:30 <mauke> the obvious way :-)
19:49:32 <mmorrow> it's just that instead of having all the values a given variable might take in a phi function, you instead have "goto with arguments"
19:49:34 <ManateeLazyCat> mmorrow: Now i got some *long* argument list functions, but i think it's better than IORefObect, because it give me clearer logic.
19:49:37 <O_4> Cairo is installed, via MacPorts, but I don't have any Haskell-Cairo bindings AFAIK
19:49:41 <Cale> When I start seeing things like  let (s',v) = foo s; (s'',w) = bar s' v in ...
19:49:47 <sohum> mauke: heh :P
19:49:51 <Cale> then I switch to using the state monad :)
19:50:05 <mmorrow> ManateeLazyCat: you could always wrap up the common args in a record data type
19:50:07 <Cale> (if I have to tuple up results too often, basically)
19:50:18 <sohum> (I don't like haskell's tuples)
19:50:32 <mauke> > runState (do { x <- get; put (x + 1); x <- get; put (x + 1); return "toodles" }) 40
19:50:34 <lambdabot>   ("toodles",42)
19:50:36 <sohum> (2-tuples are okay, but it's not general enough)
19:50:47 <FunctorSalad_> det: yep, you'd make an IRCMonad
19:50:59 <ManateeLazyCat> mmorrow: Yeah, now i try to do that.
19:51:12 <FunctorSalad_> such monads are a bit like languages built on top of haskell really
19:51:36 <sohum> sometimes I use (,) arg1 arg2 to avoid the psychological bracket tax
19:51:40 <sohum> :t (,,,)
19:51:42 <lambdabot> forall a b c d. a -> b -> c -> d -> (a, b, c, d)
19:51:44 <ManateeLazyCat> mmorrow: I'm thinking about IPC with Haskell, any idea?
19:51:52 <mmorrow> det: so a labeled block corresponds to a function, each of the phi functions correspond to a formal param, and "goto l" becomes "goto(x1,..xn)", where xi are each of the vars assigned to with a phi function at the beginning of the block labeled with l
19:51:58 <Cale> But of course, the exact thing that IRCMonad would be (or if it would be a monad at all) is best understood in terms of what it is that you're computing.
19:52:23 <ManateeLazyCat> mmorrow: Yesterday, my file-manager crash because some Gtk+ code exception, so i want implement multi-process module in my project.
19:52:51 <sohum> mauke: well it seems obvious /now/ :P
19:52:52 <mmorrow> det: so a given C function with a bunch of labeled blocks and gotos (we've desugared all the for/while/etc already) corresponds to a bunch of mutually recursive functions
19:52:59 <Cale> If you're writing an IRC server, and it needs to be concurrent, go ahead and use concurrency abstractions which involve mutation. But you might mix them a bit with immutable structure too. So you might choose to go with an MVar with a Map Channel (Set User) in it.
19:53:04 <ManateeLazyCat> mmorrow: Even file-manager or any modules crash, i just close it's tab, then others modules in my project continue work.
19:53:25 <mmorrow> det: so a functional function /= a C function, rather a functional function if more like a block of statements
19:53:36 <Cale> Or you might break that up a bit, and go with Map Channel (MVar (Set User))
19:53:51 <mmorrow> it just gets confusing since all constructs are expressed with functions
19:54:18 <mmorrow> for/while/function in C <====> function/function/function in haskell
19:54:28 <ManateeLazyCat> mmorrow: What do you thinking? Multi-Process with my project.
19:54:29 <rasfar> 0_4: someone was just saying the other day that cairo is in gtk2hs.  Maybe if you cabal install gtk2hs ... oh wait, you can't can you?  But it's at http://www.haskell.org/gtk2hs/
19:54:55 <det> I just benchmarked merge sorting a list of 10000000 ints
19:54:56 <rasfar> Or are you O_4?
19:55:06 <O_4> rasfar: the second one :-)
19:55:16 <det> converting to an array and then using heapsort was 2x as fast
19:55:32 <mmorrow> ManateeLazyCat: ohh, so you're talking about multiple OS probesses
19:55:35 <mmorrow> *processes
19:55:44 <det> (I used ocaml, I'm not sure if the stdlib offers quicksort)
19:56:03 <mmorrow> ManateeLazyCat: yeah, that could be good for ensuring that nothing can completely kill your prog
19:56:05 <det> and the total time for merge sort included converting to an array
19:56:13 <ManateeLazyCat> mmorrow: If you think multi-process is OS something, yes, my project is try to because OS.
19:56:36 <ManateeLazyCat> mmorrow: Yeah,
19:56:41 <mmorrow> ManateeLazyCat: oh, i meant you spreading your program across multiple OS processes, but sure that too.
19:56:42 <luite> det: 2 times as fast is often not very important though, for example if you just sort some (less than 100) items in a drop-down menu
19:57:04 <ManateeLazyCat> mmorrow: That's why i write it, that's why i leave Emacs, Emacs will crash even just some module crash.
19:57:13 <mmorrow> ManateeLazyCat: for instance, isn't firefox planning on having each tab be a separate OS process?
19:57:20 <det> luite, ya, completely depends on what you are doing
19:57:29 <det> also, I would expect quicksort would beat heapsort too
19:57:33 <ManateeLazyCat> mmorrow: Yeah, like Google Chome design model.
19:57:42 <ManateeLazyCat> mmorrow: You compile my project?
19:58:07 <mmorrow> ManateeLazyCat: i wasn't able too, since i don't have a new enough version of gtk
19:58:07 <ManateeLazyCat> mmorrow: If so, i plan make every tab in one process.
19:58:16 <mmorrow> ah, interesting
19:59:12 <ManateeLazyCat> mmorrow: If one module (such as file-manager) crash, rootProcess catch childProcess exception then close tab. Others module work continue.
20:00:07 <ManateeLazyCat> mmorrow: Yeah, i want to make every tab in single `OS process`.
20:00:14 <O_4> rasfar: thanks for the tipoff, ./configure does report that cairo will be installed
20:00:21 <luite> hmm, bah, I need to reinstall windows, it says that I have made an unautorized change :(
20:00:26 <O_4> I'll try it and see what happens...
20:01:24 <FunctorSalad_> mmorrow: omgwtf ZygoT does exist after all
20:02:23 <mmorrow> det: you could do this with ST, just build an array from a list, do in-place sort, dump the array to a list, runST
20:02:27 <ManateeLazyCat> mmorrow: I can't promise code always stable in every module, so it's will crash prog when i use Single-Process model. But i can keep RootProcess code Simple and Stable, then make RootProcess crash free.
20:03:12 <ManateeLazyCat> mmorrow: Have you use chrome in Linux?
20:03:46 <mmorrow> ManateeLazyCat: you could do something like lighttpd does too, it has a separate "angel" process running as root, and if the server dies for some reason, then angel process restarts it (but this doesn't help with loosing your state)
20:03:59 <mmorrow> ManateeLazyCat: i haven't
20:04:43 <ManateeLazyCat> mmorrow: I can use Core.hs and Reboot.hs keep State even "angel process" reboot.
20:06:48 <ManateeLazyCat> mmorrow: Looks like OS?
20:06:58 <mmorrow> :)
20:09:05 <ManateeLazyCat> mmorrow: Lunch now, see you later. :)
20:11:50 <mmorrow> ManateeLazyCat: bye :)
20:12:36 <mmorrow> det: also, using an array to sort a list isn't the same thing as sorting the the list directly in a lazy language
20:12:53 <det> mmorrow, good point
20:13:05 <det> mmorrow, but I really dislike lazy by default
20:13:18 <mmorrow> det: mutable unboxed arrays though could *definitely* be easier to work with in haskell
20:14:04 <mmorrow> a <- unsafeCautionDangerReadAtThisIndex arr i
20:14:06 <mmorrow> ....
20:14:41 <mmorrow> a[i+9] := a[i+4*j] + a[i-3]
20:14:58 <mmorrow> that would need 3 lines in haskell
20:15:18 <mmorrow> one for each read
20:15:22 <mmorrow> then one for the write
20:15:59 <mmorrow> unless you made some crazy (.+.) function
20:16:16 <mauke> <^(+)^>
20:16:22 <mmorrow> but even then you couldn't quite get the conciseness of
20:16:24 <mmorrow> a[i+9] := a[i+4*j] + a[i-3]
20:16:27 <mmorrow> mauke: heh
20:19:07 <mauke> let rww k f i j = do x <- a `readAt` i; y <- a `readAt` j; writeAt a k (f x y)
20:19:19 <mauke> rww (i+9) (+) (i+4*j) (i-3)
20:19:57 <mmorrow> a[i+9] := a[i+4*j] + a[i-3] - b[i*j] + a[b[4]]
20:20:25 <mauke> that never happens
20:20:29 <mmorrow> haha
20:24:02 <mogunus> Is there a "symbol" type? Or do I just use strings?
20:26:34 <rasfar> O_4: I'm very glad to be of help.  Hope it works out.
20:27:40 <O_4> mogunus: what are you trying to do?
20:28:26 <wdonnelly> mogunus: if the set of 'symbols' is finite, you usually create a custom datatype enumerating them, otherwise strings are probably the way to go
20:28:28 <mogunus> O_4: Represent strings of symbols in predicate logic, so I can implement the unification algorithm
20:29:32 <O_4> Oh, I guess I'd use strings then, without knowing much about what you're doing.
20:31:24 <mogunus> And the thing is, symbols have types? They're either constants, or predicate symbols, or function symbols, or variables. I was thinking I would define a "symbol" type, and each string in the logic would be a list of these symbols, composite types with a "tag" for what they are.
20:32:22 <wdonnelly> mogunus: something like 'data Symbol = Constant String | Predicate String | Function String | Variable String' might be what you want, then?
20:32:39 <mauke> type Symbol = (Tag, String)
20:38:24 <mogunus> mauke: Ah, a synonym for tuples? If I know the values for the Tags ahead of time, is it better style to define an explicit algebraic data type?
20:38:53 <mauke> data Tag = Constant | Predicate | Symbol | Variable
20:39:05 <mauke> deriving (Eq, Ord, Read, Show, Enum, Bounded)
20:41:04 <kmc> unless there's some tuple function you want to use, i'd define a new type
20:41:09 <kmc> even if it's isomorphic to (,)
20:42:08 <wdonnelly> using 'type Symbol = (Tag, String)' will cause GHC to output the type as '(Tag, String)', whereas making a new type for it will cause the type to be simply 'Symbol'
20:43:57 <mauke> :t "x"
20:43:58 <lambdabot> [Char]
20:44:26 <mauke> :t let f :: String -> String; f = id in f "x"
20:44:27 <lambdabot> String
20:44:40 <mauke> then why doesn't that say [Char]?
20:45:03 <kmc> :t return 'x'
20:45:04 <lambdabot> forall (m :: * -> *). (Monad m) => m Char
20:45:06 <wdonnelly> probably because you explicitly told it to say 'String' in the type annotation
20:45:15 <kmc> :t (return :: a -> [a]) 'x'
20:45:16 <lambdabot> [Char]
20:45:26 <wdonnelly> if you let it infer the type, though, i bet it would give you [Char] again
20:45:50 <wdonnelly> :t let f :: String -> [Char]; f = id in f "x"
20:45:52 <lambdabot> [Char]
20:46:04 <wdonnelly> :t let f = id in f "x"
20:46:06 <lambdabot> [Char]
21:10:37 * hackagebot upload: gitit 0.6.6 - Wiki using happstack, git or darcs, and pandoc. (JohnMacFarlane)
21:10:46 <kmc> ooh
21:15:13 <fnord123> Academic haskellers, what do you use in latex for formatting blocks of code?
21:15:54 <kmc> lhs2tex?
21:16:09 <kmc> it has the super pretty mode that uses real \lambda, \circ for (.), etc
21:16:16 <kmc> kinda showoffy but cool
21:16:38 <kmc> i like that haskell is the de facto language of much of PL research and can be used without mentioning what the notation is
21:16:43 <kmc> it's just an extension of math syntax now :)
21:18:04 <fnord123> cmon, scheme is another lingua franca of PL research. :)
21:18:42 <absentia> does anyone use latex formatting?
21:18:51 <absentia> seems like a really lame thing to have part of a language core.
21:19:08 <joed> For books? Sure
21:19:31 <fnord123> absentia: I'm writing a document where I'd like to have blocks of code. Not writing a program where I'll have comments made into a pdf
21:19:33 <p_l> absentia: I have seen it used quite often
21:19:39 <trin_cz> hi all, I'm trying to sort a 10^7 item list of tuples using sortBy. It's eating all my 2GB of ram. Any ideas why?
21:19:47 <fnord123> though doxygen and javadoc et al work this way with tex inspired macros
21:19:54 <kmc> trin_cz, runaway laziness?
21:20:45 <trin_cz> ok, how can I call it strict?
21:28:36 <Cale> trin_cz: hmm... tuples of what?
21:30:02 <trin_cz> kmc: the tuples are just (Integer,Integer).
21:30:12 <trin_cz> im sorting on the second one
21:30:21 <kmc> trin_cz, simple hack... print the list out before sorting
21:30:28 <kmc> if it gets way better, then consider some strictness annotations
21:32:07 <trin_cz> kmc: ... i'm reading the list from disk ... so write it somewhere else and then sort it ... lets see
21:35:05 <trin_cz> kmc: printing "last" should have the same effect ,right?
21:35:46 <kmc> it won't force every element, just the spine of the list + the last element
21:36:12 <kmc> anyway you don't really have to print, it's just an easy way to force
21:36:14 <kmc> @hoogle rnf
21:36:15 <lambdabot> Control.Parallel.Strategies rnf :: NFData a => Strategy a
21:36:24 <kmc> you could call rnf on the list
21:38:00 <kmc> > rnf [1..]
21:38:03 <lambdabot>   mueval-core: Time limit exceeded
21:38:11 <kmc> > rnf [1..100000]
21:38:12 <lambdabot>   ()
21:38:14 <kmc> > rnf [1..1000000]
21:38:15 <lambdabot>   ()
21:38:41 <trin_cz> kmc: and do it before or after the sort?
21:38:47 <kmc> before, let's say
21:38:59 <kmc> i don't know, if you're reading from disk this might not be the problem
21:39:02 <kmc> i'm just speculating
21:39:07 <kmc> you could try heap profiling as well
21:41:05 <Cale> trin_cz: Integer values can be arbitrarily large...
21:41:17 <Cale> trin_cz: How big are these ones, roughly, will that matter?
21:41:34 <trin_cz> no, same size 10^7
21:42:27 <trin_cz> kmc,Cale: I'll continue tomorrow, thanks for the tips.
21:43:03 <Cale> Let's see, you have... at least 12 bytes per cons, and then maybe another 12 bytes per pair, and then if the Integer values are let's say an average of 40 bytes, you're well over a gig.
21:43:12 <Cale> ah
21:43:42 <Cale> I forget how big list cells really are...
21:43:56 <kmc> you can save space by using a pair of unboxed strict Int#
21:44:00 <Cale> I suppose a 32 bit tag + two 32 bit pointers?
21:44:11 <kmc> Cale, or double that on 64-bit
21:44:14 <Cale> right
21:45:38 <voidprayer> Excuse me. I have a problem with building GHC on Gentoo. While processing Apply.cmm, it says "<built-in>:0:1: lexical error" and stopped. Anyone can help? Thanks.
21:49:29 <kmc> suppose i want to write a little haskell program to lurk in some IRC channels and listen to messages
21:49:41 <kmc> i see a simple IRC parser and a couple of bots on hackage
21:49:47 <kmc> any suggestions for where to start?
21:50:26 <jfredett> kmc: there is a haskellwiki page about this somewhere
21:50:32 <jfredett> I think under the lambdabot page.
21:50:46 <jfredett> but I can't remember exactly where.
21:51:10 <kmc> aha i found it
21:51:15 <mauke> my suggestion: take an existing IRC client and script it
21:51:28 <kmc> actually just by googling "irc protocol" :)
21:55:21 <kmc> @hoogle forever
21:55:22 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
21:55:43 <Axman6> > forever [1]
21:55:45 <lambdabot>   * Exception: stack overflow
21:56:37 <copumpkin> > forever []
21:56:38 <lambdabot>   []
21:56:43 <copumpkin> w00t :)
21:59:06 <jfredett> > forever "young"
21:59:08 <lambdabot>   * Exception: stack overflow
21:59:09 <jfredett> ...
21:59:17 <kmc> i used to be able to speak IRC protocol
21:59:19 <kmc> wasted youth...
22:01:18 <leimy_> anyone know a good tutorial for finding space leaks.  I'm pretty much lost.
22:02:10 <leimy_> the profiling tools basically tell me "Main" is eating the memory. However, I kind of figured that out already :-)
22:04:22 <kmc> > product [1..6]
22:04:23 <lambdabot>   720
22:05:34 <copumpkin> leimy_: did you read tutorials on profiling? you need to add cost centers to get more granularity
22:05:54 <leimy_> I saw -hc
22:06:01 <leimy_> is that not usable with -hm
22:06:02 <leimy_> ?
22:06:08 <leimy_> or can you put a bunch together?
22:06:09 <Gracenotes> I was looking at STG representation in GHC. SCCs are a big part of it.
22:06:27 <copumpkin> leimy_: I'm talking about cost center annotations in your code
22:06:39 <copumpkin> leimy_: you should check out a tutorial on this, or the RWH chapter
22:06:39 <leimy_> no idea about that stuff
22:06:54 <Gracenotes> SCC = set cost center
22:06:59 <leimy_> oh
22:07:01 <leimy_> hmm
22:07:07 <kmc> :t (!!)
22:07:08 <lambdabot> forall a. [a] -> Int -> a
22:07:12 <kmc> @hoogle [a] -> Int -> Maybe a
22:07:13 <lambdabot> Prelude (!!) :: [a] -> Int -> a
22:07:13 <lambdabot> Data.List (!!) :: [a] -> Int -> a
22:07:13 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
22:07:16 <copumpkin> it allows you to say "measure stuff about this expression"
22:07:34 <Gracenotes> it is a comment to put right before an expression.. a pragma, I guess.. no, more general than pragma
22:08:38 <mmorrow> Cale: yeah, a list node would is 3 ptrs (unless it's [], in which case it's 1)
22:10:15 <mmorrow> , let sizeOfList elemSize len = 3*len*elemSize+1; sizeOfInt = 1+1 in sizeOfList sizeOfInt 1000 {- in words -}
22:10:16 <lunabot>  6001
22:10:37 <mmorrow> , 6001 * 4 {- 32 bit -}
22:10:38 <lunabot>  24004
22:11:03 <mmorrow> , 24004 * 2
22:11:05 <lunabot>  48008
22:11:05 <leimy_> Oh wow
22:11:06 <mmorrow> for 64
22:11:17 <leimy_> $dRegexContext1_rb45
22:11:20 <leimy_> is my big consumer
22:11:28 <leimy_> I guess I should be pre-compiling patterns?
22:11:31 <mmorrow> preflex: zdec $dRegexContext1_rb45
22:11:31 <preflex>  $dRegexContext1_rb45
22:11:38 <leimy_> instead of just sitting on =~
22:12:36 <leimy_> Well through hours of trial and error I got it down to one function causing my problems
22:12:56 <leimy_> and it uses a list comprehension with one pattern in two places (I was lazy)
22:13:03 <leimy_> it appears that's kicking my ass.
22:13:15 <mmorrow> , let sizeOfList wordSize elemSize len = wordSize*3*len*elemSize+1; sizeOfInt = 1+1 in sizeOfList 8 sizeOfInt 1000000 / (1000*1000)
22:13:16 <lunabot>  48.000001
22:13:28 <mmorrow> 48MB for a 1million element [Int]
22:13:52 <Voting> what are good examples of apps I should write in haskell?
22:14:10 <copumpkin> Voting: I'd start with simple algorithmic stuff that doesn't involve much IO
22:14:15 <copumpkin> in fact, I did
22:14:16 <mmorrow> Voting: what's an app you want to write regardless of language?
22:14:41 <Apocalisp> A Scheme interpreter, naturally.
22:14:46 <mauke> Hello World
22:14:56 <Voting> thanks, folks. mmorrow - I want to write ETL software for one.
22:15:26 <mmorrow> Voting: so i suppose start getting familiar with the database packages
22:15:32 <Cale> A new web browser and HTML rendering engine, just for the sheer hell of it. ;)
22:15:48 <mauke> engineering technical letter
22:15:49 <copumpkin> HTML sounds like one of the most painful things to parse ever
22:15:58 <copumpkin> since you need to deal with malformed html
22:15:59 <mmorrow> let alone render..
22:16:00 <mauke> copumpkin: try English ツ
22:16:04 <copumpkin> lol
22:16:08 <copumpkin> or japanese?
22:16:20 <copumpkin> シツ
22:16:55 <copumpkin> cute smiley though :)
22:17:13 <mauke> I also have ヾ
22:17:25 <Apocalisp> Is there one for high-five?
22:17:49 <copumpkin> 上五
22:17:59 <pikhq> copumpkin: *groan*
22:18:17 <copumpkin> すまない
22:18:40 <Axman6> preflex: seen ChilliX
22:18:40 <preflex>  ChilliX was last seen on #ghc 23 hours, 47 minutes and 35 seconds ago, saying: copumpkin: :P
22:18:42 <pikhq> 'sokay.
22:18:55 <copumpkin> aw, 'tis an honor to be the last thing ChilliX said
22:19:16 <Axman6> better not be the last thing he says :P
22:19:25 <mauke> Apocalisp: ⁵
22:19:26 <copumpkin> well you know what I mean :P
22:25:57 <medfly> haha
22:29:26 <mauke> ✌
22:33:12 <ezyang> I'm building a Parsec parser and I want to generate one adt if an '@' is present in the string to be parsed, and a different adt if another '@' is present.  Should I be using try?
22:33:34 <ezyang> s/if another/if no/
22:35:16 <Apocalisp> @hoogle a -> [a] -> [a]
22:35:16 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
22:35:17 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
22:35:17 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
22:39:52 <travisbrady> is there a more idiotmatic way to do this type of thing? loop n = if n==0 then return () else (print n) >> (loop $ pred n)
22:40:32 <ezyang> Sure
22:41:27 <copumpkin> first of all, if you wanted to do that, you could pattern match instead of using if
22:41:46 <copumpkin> mapM_ print [1..n] is probably better though
22:42:11 <mauke> still ew
22:42:12 <Apocalisp> @type let f a [] = [a]; f a x = x in f
22:42:13 <ezyang> > let loop n = mapM_ print [n,pred n..0] in loop 3
22:42:14 <lambdabot>   <IO ()>
22:42:14 <lambdabot> forall t. t -> [t] -> [t]
22:42:36 <Apocalisp> feels like I'm transforming list to maybe
22:42:46 <copumpkin> mauke: how would you do it?
22:43:05 <mauke> putStr . unlines . map show $ [n, n-1 .. 0]
22:43:18 <mauke> s/0/1/
22:43:21 <ezyang> Heh
22:43:28 <copumpkin> ah, I assumed his operation was going to be monadic and that his print was just an exampl :P
22:45:20 <leimy_> > "serialNumber is blah" =~ "serialNumber is " :: (String, String, String)
22:45:22 <lambdabot>   ("","serialNumber is ","blah")
22:45:25 <leimy_> wow
22:45:34 <leimy_> ok that causes a stack overflow in ghci on Mac OS X Snow Leopard
22:45:58 <leimy_> Looks like I should be developing on linux :-(
22:46:14 <ezyang> Dev on linux is sooo much better
22:46:30 <medfly> JOIN US!!!!!
22:46:33 <ezyang> (than Windows, I hear Macs are more acceptable)
22:46:33 <leimy_> lol no :-)
22:46:49 <copumpkin> macs are fine
22:46:55 <leimy_> As soon as linux dumps X11 I'll use it for dev :-)
22:46:59 <copumpkin> only advantage linux has for haskell dev is x86_64 support
22:47:05 <medfly> what should it use, XFree??
22:47:23 <copumpkin> -X
22:47:25 <leimy_> nothing of the xorg, Xfree/X11 family should be used by anyone ever anywhere :-)
22:47:34 <medfly> what should it use?
22:47:38 <leimy_> something else
22:47:42 <copumpkin> command-line
22:47:51 <leimy_> X11 proves that even when you fill a vacuum it can still suck
22:47:52 <sjanssen> leimy_: X11 is awesome
22:47:53 <copumpkin> real coders don't need no fucking graphics
22:48:00 <ezyang> Serial all the way
22:48:10 <copumpkin> real coders use ed
22:48:22 * leimy_ knows how to use ed
22:48:27 <medfly> leimy, but, what?
22:48:35 <leimy_> nothing preferably
22:48:42 <medfly> we should make something else instead of Xfree/Xorg in Haskell! ... or not
22:48:49 <leimy_> when I use linux for dev, I typically use Emacs on mac os x to connect via tramp mode
22:49:00 <leimy_> medfly: I think Qt worked on the linux framebuffer :-)
22:49:04 <leimy_> may still
22:49:10 <leimy_> In fact, I think KDE worked on the linux framebuffer :-)
22:49:15 <leimy_> not that I'd recommend that
22:49:27 <leimy_> I'd be ok with a framebuffer version of Rio from Plan 9 honestly
22:49:41 * sjanssen is once again annoyed that X11 hate is so fashionable
22:49:49 <leimy_> it's not fashionable
22:49:57 <leimy_> if it were, people would replace it successfully
22:50:14 <leimy_> X11 is the #1 reason I bought a mac :-)
22:50:28 <copumpkin> because you can run it anyway?
22:50:29 <medfly> I don't think it's fashionable, I think most people don't even know enough about X11 to hate it
22:50:36 <leimy_> I can run it, but never do :-)
22:50:36 <sjanssen> people in the know understand that X11 is pretty good, everybody else hates on it for no reason
22:50:49 <leimy_> medfly: I think most people don't know enough about X to know why they should hate it.
22:50:57 <medfly> isn't that what I said?
22:50:58 <copumpkin> no true scotsman?
22:51:11 <leimy_> almost :-)
22:51:16 <copumpkin> medfly: he added a "should"
22:51:27 <medfly> oh, right
22:51:48 <leimy_> I'm fairly certain I've never seen more lines of code that don't really do anything than in the X11 implementations I've looked at
22:51:58 <leimy_> I'm not alone in this observation
22:52:06 <leimy_> Rob Pike and Ken Thompson seem to agree :-)
22:53:07 <leimy_> I mean, Rio is a concurrent window manager that one person can read and understand and modify
22:53:15 <leimy_> I can't say the same for X11... I get lost.
22:53:36 <leimy_> but then, that's true with me and most of linux :-)
22:53:38 <medfly> X11 is a window manager?
22:53:42 * copumpkin pulls out his sjanssen placator
22:54:00 <leimy_> medfly: no.  but what do you *really* use it for?
22:54:03 * hackagebot upload: SDL 0.5.7 - Binding to libSDL (DavidHimmelstrup)
22:54:04 <medfly> I always thought things like twm and openbox are window managers.
22:54:06 <copumpkin> that doesn't sound good, does it
22:54:08 <p_l> medfly: nope, but it includes "windows" at all, just the control is outsourced
22:54:12 <copumpkin> I didn't mean it to sound rude :)
22:54:12 <leimy_> I'd say most people use X11 as a window manager :-)
22:54:18 <p_l> Rio otoh works directly on framebuffers
22:54:42 <leimy_> Rio works on /dev/draw :-)
22:54:45 <leimy_> on Plan 9 anyway
22:54:51 <leimy_> and libdraw on unix/Mac OS X
22:55:00 <p_l> leimy_: which isn't far from "framebuffer" ;P
22:55:07 <leimy_> no it's damn close :-)
22:55:18 <leimy_> also Rio both reads and exports the keyboard and mouse as files
22:55:38 <leimy_> which is also kind of nice.... especially with a good filesystem protocol like 9p :-)
22:55:42 <p_l> and definitely prefers a chording keyboard
22:55:49 <leimy_> chording mouse :-)
22:55:56 <leimy_> you should have 3 buttons to use Rio
22:56:14 <ezyang> To interrupt this conversation, I'm currently converting a bunch of Haskell code that did manual parsing to now use Parsec, and I'm wondering how to structure my parsers
22:56:22 <leimy_> yeah we're way OT :-)
22:56:40 <p_l> leimy_: chording keyboard + mouse, so you can keep writing while keeping a hand on the mouse (which is what peeves me the most about Rio)
22:57:01 <leimy_> Yeah, it takes some getting used to
22:57:09 <leimy_> I couldn't figure out why it was any good for like a month
22:57:57 <medfly> I guess a conversation like this fits a channel like #haskell, a discussion of obscure things on obscure operation systems... suitable for a channel for an obscure language
22:58:06 <leimy_> linux even has v9fs now in the kernel, you pretty much really wouldn't even need X11 as a protocol anymore :-)
22:58:11 <leimy_> in fact... hang on
22:58:20 <Gracenotes> @src nubBy
22:58:21 <lambdabot> nubBy eq []             =  []
22:58:21 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
22:58:33 <leimy_> http://wmii.suckless.org/  <-- there's an X11 window manager that talks 9p :-)
22:58:35 <leimy_> oddly enough
22:58:43 <Gracenotes> hrm -.-
23:03:00 <leimy_> anyone happen to know how to figure out exactly how much physical memory a given process is really actually using on linux?
23:03:52 <upsh9401> Okay I have a list of type [a->a] I want to aplie each eliment of the list inturn to an item of type a. How do I do so?
23:04:05 <sjanssen> upsh9401: map ($ x) xs
23:04:08 * hackagebot upload: SDL 0.5.8 - Binding to libSDL (DavidHimmelstrup)
23:04:45 <upsh9401> sjanssen: I mean in turn as in [f,g] x -> f $ g x
23:05:32 <sjanssen> foldr ($) x xs
23:06:39 <kmc> :t foldr ($)
23:06:40 <lambdabot> forall b. b -> [b -> b] -> b
23:07:29 * hackagebot upload: SDL 0.5.9 - Binding to libSDL (DavidHimmelstrup)
23:07:44 <upsh9401> Thanks, was trying to use foldl and it jus refused to work. not sure why.
23:08:03 <kmc> :t foldl (flip ($))
23:08:04 <lambdabot> forall b. b -> [b -> b] -> b
23:08:16 <upsh9401> hmm
23:08:24 <kmc> > foldr ($) x [f,g,h]
23:08:25 <lambdabot>   f (g (h x))
23:08:31 <upsh9401> Oh well it wroks now.
23:08:32 <kmc> > foldl (flip ($)) x [f,g,h]
23:08:33 <lambdabot>   h (g (f x))
23:09:16 <upsh9401> The r order actualy makes slightly moresense for what I am doing.
23:09:54 <kmc> it usually does
23:09:58 <kmc> :t foldr (:) []
23:09:59 <lambdabot> forall a. [a] -> [a]
23:13:27 <sjanssen> foldr is the One True Fold
23:13:34 <ezyang> there's gotta be a better way of doing this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11917#a11917
23:14:52 <ezyang> I guess I'm looking for some sort of "concatenate" operator
23:16:57 <kmc> ezyang, concatenating parsers is what the monad does
23:17:31 <ezyang> Ohhh
23:17:35 <ezyang> ok, then I want >>=
23:17:41 <kmc> you're already using it though
23:18:45 <ezyang> But... if I get rid of the assignments then it'll be using >>, no?
23:18:56 <kmc> yes
23:19:01 <kmc> which is fine if this is just a validator
23:19:11 <ezyang> Ah, I see.
23:19:29 <ezyang> Ok. It's not just a validator; I need the string that was consumed
23:20:38 <ezyang> and so, while the chain of >>= will fail if it fails to validate, it doesn't keep around the consumed strings?
23:20:46 <ezyang> Maybe... I want a nested do block
23:21:02 <kmc> you're binding the consumed strings with <-
23:21:23 <ezyang> yes.
23:21:32 <ezyang> But then I go ahead and concatenate them again
23:21:37 <kmc> :t concatM
23:21:38 <lambdabot> Not in scope: `concatM'
23:22:13 <ezyang> :t mconcat
23:22:14 <lambdabot> forall a. (Monoid a) => [a] -> a
23:22:16 <ezyang> perhaps?
23:22:38 <kmc> concat $ sequence [many1 (alphaNum <|> oneof "._%+-"), string "@", many1 (alphaNum <|> oneof ".-")]
23:23:01 <kmc> @pl concat . sequence
23:23:01 <lambdabot> join . sequence
23:23:49 <ezyang> Hmmm
23:24:06 <ezyang> That's prettier syntax, but I'm still concatenating the strings together behind the scenes
23:24:15 <kmc> err i think that $ should be a <$> or so
23:24:17 <ezyang> I guess I should resign myself to that fact
23:24:58 <kmc> ezyang, you have to know how much to consume
23:25:13 <kmc> you can optimize that a bit but i think this is easiest
23:25:21 <ezyang> k
23:35:29 <Gracenotes> substituting the sequence call, you get: concat . foldr (\m1 m2 -> concatMap (flip map m2 . (:)) m1) [[]]
23:37:14 <Gracenotes> actually, that'd only be sequence for the list monad. that was silly.
23:38:18 <Gracenotes> but actually, given that concat is foldr (++) and sequence is foldr (liftM2 (:)), those will probably be fused by GHC, so.. eh, I like kmc's version :o
23:40:43 <kmc> :t liftM2 (:)
23:40:44 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m [a1] -> m [a1]
23:42:05 <kmc> :t foldr (liftM2 (:))
23:42:06 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m [a1] -> [m a1] -> m [a1]
23:42:16 <kmc> :t foldr (liftM2 (:)) (return [])
23:42:17 <lambdabot> forall a1 (m :: * -> *). (Monad m) => [m a1] -> m [a1]
23:42:34 <ray> :t liftM2 (::)
23:42:34 <lambdabot> parse error on input `::'
23:42:38 <ray> i can dream
23:42:41 <kmc> hehe
23:42:54 <Gracenotes> actually, you might need <$> for concatenating rather than $..
23:43:06 <Gracenotes> so scratch that anyway -o-
23:44:43 <ezyang> le new code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11918#a11918
23:47:45 <kmc> i like that a lot
23:49:42 <kmc> :t \xs -> concat <$> sequence xs
23:49:43 <lambdabot> forall a (f :: * -> *). (Monad f, Functor f) => [f [a]] -> f [a]
23:50:37 <copumpkin> :t liftM concat . sequence
23:50:38 <lambdabot> forall a (m :: * -> *). (Monad m) => [m [a]] -> m [a]
23:51:19 <rasfar> why is the foldr more natural than the foldl?  Given [f,g,h,...] and x, ...(h(g(f(x))) seems at least as natural as f(g(h(...(x))).
23:51:46 <copumpkin> rasfar: think of foldr f z xs as replacing every (:) in xs with f and [] in xs with z
23:51:54 <copumpkin> rasfar: it "preserves" the structure
23:52:14 <copumpkin> > foldr (:) [] [1..5]
23:52:15 <lambdabot>   [1,2,3,4,5]
23:52:21 <copumpkin> > foldr (flip (:)) [] [1..5]
23:52:22 <lambdabot>   Occurs check: cannot construct the infinite type: b = [b]
23:52:25 <rasfar> okay hang on
23:52:28 <copumpkin> > foldl (flip (:)) [] [1..5]
23:52:29 <lambdabot>   [5,4,3,2,1]
23:52:38 <copumpkin> see, foldl is basically backwards! :P
23:52:39 <sjanssen> rasfar: it is possible to write foldl in terms of foldr, but it isn't possible to write foldr in terms of foldl
23:52:46 <rasfar> i know (knew) all about folds, this observation I made pertains to kmc's point above
23:52:47 <kmc> @check \xs -> foldr (:) xs == xs
23:52:48 <lambdabot>   Couldn't match expected type `[a] -> [a]'
23:53:17 <rasfar> okay, that justifies "One True Fold" :)  But I still think
23:53:18 <copumpkin> missing a []
23:53:18 <kmc> @check \xs -> foldr (:) [] xs == xs
23:53:19 <lambdabot>   "OK, passed 500 tests."
23:53:39 <rasfar> in the case of a list of functions to be applied, it makes more sense for the head to be applied first.
23:53:40 <kmc> those are probably :: [()] though
23:53:50 <kmc> @check \(xs :: [Char]) -> foldr (:) [] xs == xs
23:53:50 <lambdabot>   Parse error in pattern at "->" (column 17)
23:54:09 <copumpkin> rasfar: it's only more natural as far as the structure of the list is concerned... it says nothing of being more practical for everyday operations or stuff
23:54:24 <rasfar> fair enough!
23:54:40 <copumpkin> it does make a difference for laziness though
23:54:48 <copumpkin> since foldr gives "control" to the function
23:54:59 <copumpkin> and foldl charges on like a steamroller regardless of what the function wants
23:55:02 <sjanssen> rasfar: it is true that if you can arrange for a foldl when applying a list of functions, it has the opportunity to be more efficient (but only if you use foldl')
23:55:19 <copumpkin> > foldl (+) (0 :: Natural) [1..] > 0
23:55:25 <lambdabot>   mueval: ExitFailure 1
23:55:28 <copumpkin> > foldr (+) (0 :: Natural) [1..] > 0
23:55:31 <lambdabot>   True
23:55:38 <josephholsten> [random newbie question] is there any place doing haskell tutorial screencasts?
23:55:52 <rasfar> interesting.  i was afraid to ask, but i'm glad i did.  i had in mind an infinite list of data transformers, say (like animation), but of course how will you ever observe intermediate results?
23:55:54 <copumpkin> josephholsten: might be helpful for some kinds of people :)
23:55:54 <kmc> this IRC channel :)
23:56:09 <sjanssen> josephholsten: I've never seen any, no
23:56:11 <kmc> rasfar, use scanr instead of foldr
23:56:13 <copumpkin> josephholsten: oh I see what you mean
23:56:27 <copumpkin> josephholsten: the only screencasts I've seen in haskell were demonstrations of vacuum, a particular haskell package
23:56:51 <kmc> > scanr ($) x [f, g, h]
23:56:53 <lambdabot>   [f (g (h x)),g (h x),h x,x]
23:57:07 <kmc> > scanl (flip ($)) x [f, g, h]
23:57:07 <rasfar> kmc: lol
23:57:08 <lambdabot>   [x,f x,g (f x),h (g (f x))]
23:57:10 <sjanssen> kmc: actually, you'd probably want scanl
23:57:18 <kmc> yeah that makes more sense
23:57:41 <josephholsten> that's too bad. though I guess I could just keep my eye on usage around here and see plenty of example code
23:57:44 <kmc> is there a scan which would produce [x, h x, g (h x), f (g (h x))]
23:57:46 <copumpkin> > scanl1 (+) [1,3..]
23:57:47 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
23:58:01 <copumpkin> kmc:  . reverse
23:58:08 <kmc> won't that be slower though
23:58:28 <sjanssen> kmc: it's not hard to write with foldr
23:58:33 <copumpkin> kmc: look at it though
23:58:35 <kmc> josephholsten, out of curiosity, what do you find valuable about screencasts?
23:58:39 * kmc looks
23:58:43 <copumpkin> kmc: it's applying the functions in reverse
23:59:38 <josephholsten> kmc: they keep me from getting distracted while I've yet to learn enough to get through a project
