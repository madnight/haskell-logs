00:00:10 <HayashiRazan> mmorrow
00:00:15 <HayashiRazan> whats a good haskell book
00:00:30 <mmorrow> hmm
00:00:46 <mmorrow> what are you looking for?
00:01:12 <HayashiRazan> just learn haskell
00:01:15 <HayashiRazan> i need a good book
00:01:19 <mmorrow> an examples-and-stuff book? realworld haskell would probably be good for that type
00:01:33 <HayashiRazan> is that what you used?
00:02:02 <mmorrow> or if you're looking for functional programming/data-structures in general, the okasaki Purely functional data-structures is good
00:02:26 <mmorrow> there's an appendix with the haskell-equivalent of the SML code that's given in the book
00:02:44 <HayashiRazan> ah i gotcha
00:02:49 <HayashiRazan> its good
00:02:52 <HayashiRazan> thx
00:03:47 <mmorrow> HayashiRazan: i'd definitely get purely-functional data-structures
00:04:56 <mmorrow> it's good as reference, for skipping around, and for seeing how to use abstract datatypes to make composite ones
00:07:00 <mmorrow> data Seq a = Tip a | Two (Seq (a,a)) {- perfectly balanced binary trees -}
01:10:56 <dcoutts> cjs: the darcs version of cabal-install works with Cabal-1.8
01:11:25 <dcoutts> technically we've not released either version yet
01:21:38 <blackh> dcoutts: I've gotta fix ticket #89 on cabal-install before you release it.
01:21:56 <dcoutts> blackh: ah yes
01:22:41 <blackh> I heard cabal-install is working again, so I'll see if my patch still works, and email you the results.
01:22:47 * Cyneox re
01:27:40 <PeakerWork> I read some Yi code today, looks like a really nice project. Love how emacs (interactive) becomes YiM :)
01:33:13 <ivanm> blackh: why, what's that ticket for?
01:33:47 <blackh> ivanm: You know when you build a library and an executable in the same cabal package, and it builds everything twice? It's to fix that.
01:34:13 <ivanm> blackh: I thought cabal-1.8 fixed that already...
01:34:56 <dcoutts> blackh: right, but cabal-install needs to be taught to take that into account
01:35:13 <ivanm> dcoutts: you meant that for me?
01:35:15 <ivanm> ;-)
01:35:37 <blackh> cabal install needs a tiny little bit of extra lurve
01:35:51 <dcoutts> ivanm: oops, yes
01:36:03 <ivanm> heh
01:36:06 <dcoutts> blackh knows that already of course :-)
01:36:08 <ivanm> blackh: heh
01:58:24 <dancor> s/\(Data.Set.intersect\)ion/\1/
01:58:37 <dancor> instance BugReport Regex
01:59:51 <ivanm> can anyone suggest a cleaner way of writing combineActions? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11779#a11779
02:00:28 <ivanm> I don't particularly want to do "combineActions Help _ = ..." as well as "combineActions _ Help = ...", but using the guard there looks wrong
02:01:13 <quicksilver> I have to admit personally I'd just write the two cases for Help _ and _ Help
02:01:16 <quicksilver> and align everythign nicely.
02:01:19 <Botje> ivanm: case (a1 `min` a2) of ... ?
02:01:32 <ivanm> quicksilver: *nod*
02:01:38 <Botje> then you can case the Build first, and return the variable you match otherwise
02:01:46 <ivanm> Botje: hmmmm...
02:02:09 <ivanm> quicksilver: problem with that is I might be adding more Actions later on, and that doubles the workload
02:02:15 <ivanm> Botje's suggestion has merit...
02:03:17 <quicksilver> I don't really think adding two lines counts as 'doubling the workload' for all that I appreciate what you're saying.
02:03:29 <quicksilver> and obviously exhaustive case analysis is more obviously total, too.
02:29:38 <Cale> Heh, enough netsplits?
02:29:56 <ivanm> for now... ;-)
02:31:16 <Cale> That's number 15
02:31:34 <Cale> ...and split 15 is done :)
02:33:15 <eevar2> time for google wave? ;)
02:34:06 <fasta> eevar2, when hell freezes over?
02:38:26 <dolio> So, how much faster does GHC have to be before people don't use Clean's speed advantages for 4 out of their 10 bullet points? :)
02:38:47 <Cale> dolio: People still mention Clean?
02:38:58 <dolio> They do in threads about Clean.
02:39:02 <Cale> :)
02:39:14 <cjs> Any thoughts on what "Conflicting definitions for `pun-right-hand-side'" means when I'm using something like "where Quote{dir} = someQuote" to pattern match out a named field using named field puns? This happens to me in 6.12 with code that compiles fine in 6.10.
02:39:36 <Cale> cjs: Maybe a bug in 6.12
02:39:56 <cjs> This close to release?
02:40:04 <Cale> Might be a good idea to report it
02:41:15 <Saizan> the rcN are for finding these bugs!
02:41:27 <cjs> It might well be a bug. Just changing the it to Quote{dir=dir} lets it compile.
02:43:07 <cjs> Hm. Sometimes I need to do it; somtimes it's ok.
02:44:26 <Cale> cjs: See if you can make a minimal testcase
02:44:27 <quicksilver> cjs: sounds like a valuable one to report, to me.
02:44:45 <Cale> and yeah, report it, since it's certainly supposed to work :)
02:44:55 <cjs> Yeah, I'll get to a test case in a bit. Lemmie see what else in my trader breaks as well.
02:45:04 * quicksilver refrains from embarking on his torrent about field puns and using record notation at all :)
02:46:31 <cjs> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11780#a11780
02:46:35 * Baughn wants better record notation in 6.14. Please?
02:46:54 <cjs> Yeah, so it's the pun-right-hand-side appearing twice there that seems to be the problem. If I reduce it to one, it's fine.
02:47:04 <cjs> Baughn: Such as?
02:47:16 <quicksilver> Baughn: not going to happen until somebody actually makes a working "better" proposal.
02:47:45 <Baughn> cjs: I'm not quite sure. I'd make suggestions, but there are so many already..
02:48:48 <cjs> I'd be interested in references to those, sent to cjs@cynic.net.
02:51:45 <dolio> Someone needs to put a bullet in zelazny.
02:52:32 <fasta> dolio, that still assumes it is faster, which has never been proven beyond doubt for idiomatic programs.
02:53:05 <ivanm> dolio: who is zelazny, and why should they get a bullet?
02:53:07 <dolio> Assumes which is faster?
02:53:23 <dolio> ivanm: It's the server that's been repeatedly splitting for the past hour.
02:53:23 <fasta> If you write loops with bang-patterns everywhere and the compiler does _not_ compile it to register operations than the compiler is just terribly stupid, not smart when it does do it.
02:53:38 <fasta> dolio, GHC
02:53:41 <quicksilver> dolio: freenode lies about netsplits so you can't deduce its topology (or not so easily)
02:53:56 <ivanm> dolio: AFAICT from the split messages here, it's wolfe...
02:54:03 <fasta> quicksilver, why does it do that?
02:54:13 <quicksilver> I just answered that didn't I?
02:54:17 <ivanm> oh, wait, that's who _I'm_ connected to...
02:54:24 <quicksilver> they don't want you to be able to reason about their topology.
02:54:26 <ivanm> quicksilver: yes, after I hit enter ;-)
02:54:34 <fasta> quicksilver, but why don't they want that?
02:54:43 <ivanm> fasta: security through obscurity?
02:54:45 <Baughn> ivanm: For all your packaging purposes, I'm pretty sure 1.6.2 will be the last version of haskell-mode for a while.
02:54:46 <quicksilver> because it would help your learn where to attack
02:54:55 <quicksilver> it's a fairly dull kind of security through obscurity, yes.
02:55:04 <fasta> If you have a lot of bandwidth, you can destroy everything.
02:55:16 <quicksilver> correct.
02:55:27 <fasta> If it can be broken in any other way, then the system just needs to be fixed.
02:55:37 <ivanm> Baughn: \o/
02:55:42 <fasta> I think the Internet has to be redesigned for that.
02:55:43 <ivanm> is that the latest one out?
02:55:51 <Baughn> Right
02:56:01 <ivanm> quicksilver: what's an exciting security-through-obscurity?
02:56:08 <fasta> Basically, you should be able to tell your ISP: "I don't want to receive anything from IP XYZ for the next 5 minutes".
02:56:14 <ivanm> Baughn: because you're sick of it, you have no time or you think it's good-enough for now? ;-)
02:56:23 <fasta> Some kind of separate control channel.
02:56:32 <Baughn> ivanm: Storing the root password to your nuclear weapons in a web browser and not telling anyone about it
02:56:42 <Baughn> ivanm: Because I'm out of serious bugs. ;)
02:56:44 <fasta> That way DOS attacks cannot happen or you can do a lot about it.
02:57:25 <ivanm> Baughn: heh (for both)
02:57:26 <fasta> Maybe this is already possible, but AFAIK, ISPs are just stupid bit movers to which the end point cannot communicate back.
02:57:35 <ivanm> Baughn: you want more serious bugs? :p
02:57:37 <dolio> fasta: Is there evidence that idiomatic clean programs are faster than idiomatic haskell programs?
02:57:45 <Baughn> ivanm: Not particularily. ;_;
02:57:51 <dolio> Because clean programs on the shootout don't look very good, either.
02:57:54 <fasta> dolio, I have that belief.
02:58:01 <quicksilver> fasta: big ISPS do that all the time (for big customers, for big cost)
02:58:11 <quicksilver> fasta: they're not very interested in doing it for small ones.
02:58:19 <quicksilver> but DDOS mitigation is big business.
02:58:39 <fasta> quicksilver, ah, so they are basically criminals themselves (the ISPs).
02:59:03 <quicksilver> protection has always been a chargeable service :)
02:59:10 <fasta> quicksilver, yes, see governments.
02:59:16 <ivanm> Baughn: awwww... ;-)
02:59:48 <fasta> Mafia,  and so on.
03:00:26 <fasta> quicksilver, ok, well, nice to know people already do it, not so nice it's not just part of the protocol.
03:03:59 <Baughn> ivanm: What, do you have any?
03:04:05 <ivanm> nah
03:04:30 <Athas> How well does GHC run on OpenBSD?
03:04:43 <Athas> OpenBSD/AMD64.
03:08:59 <quicksilver> fasta: it's too expensive to make it a default option, currently.
03:09:16 <quicksilver> fasta: economics change, though. It may one day be too expensive *not* to make it default :)
03:10:49 <Cale> Athas: I seem to recall that at one point dons was keeping things going on OpenBSD, but he's switched to Arch Linux. I don't see any OpenBSD binaries on the GHC page, but I wonder if there are some out there somewhere.
03:13:32 <Cale> Athas: It would be a tremendous amount of hassle, but you might be able to compile your way up from an old version.
03:13:47 <Cale> (probably better than bootstrapping :)
03:14:58 <Athas> Cale: hm, I see.
03:15:05 <Athas> Probably not worth the effort.
03:17:10 <quicksilver> I have a vague memory of some problems on BSD/64bit
03:17:33 <quicksilver> I'm not sure if anyone spent the time trackin it down
03:20:58 <Cale> hehe, "The I/O libraries are now Unicode-aware, so your Haskell programs should now handle text files containing weird characters."
03:22:10 <jinjing> is there a way to define a function in unicode char, but make it an infix operator by default?
03:24:04 <quicksilver> jinjing: if it falls in certain unicode class it will be infix.
03:24:43 <cjs> Now that was a fun bug report. I got to name functions "goodPun" and "badPun". :-)
03:24:54 <jinjing> quicksilver: thx, is this class referenced somewhere?
03:26:19 <Cale> > isSymbol 'âˆ«'
03:26:20 <lambdabot>   True
03:26:41 <Cale> > filter isSymbol [minBound..maxBound]
03:26:42 <lambdabot>   "$+<=>^`|~\162\163\164\165\166\167\168\169\172\174\175\176\177\180\182\184\...
03:26:49 <Cale> blah :P
03:27:08 <jinjing> quicksilver: thx, nvm i think i can get around it by using another unicode function helper
03:27:11 <Cale> hmm, that doesn't seem to catch things like - and *
03:27:34 <jinjing> oh
03:27:38 <jinjing> thankx Cale
03:27:58 <Cale> jinjing: I would think it's roughly what isSymbol gives you anyway
03:28:17 <jinjing> @t isSymbol
03:28:17 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
03:28:23 <Cale> :t isSymbosl
03:28:24 <Cale> :t isSymbol
03:28:24 <lambdabot> Not in scope: `isSymbosl'
03:28:25 <lambdabot> Char -> Bool
03:29:34 <jinjing> thanks Cale
03:29:50 <jinjing> :i isSymbol
03:30:29 <Cale> It's in Data.Char
03:31:23 <zjr1113> hi
03:33:43 <jinjing> > isSymbol ã‹¶
03:33:44 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
03:34:00 <jinjing> > isSymbol 'ã‹¶'
03:34:02 <lambdabot>   True
03:34:07 <jinjing> lol
03:34:19 <zjr1113> ?
03:36:08 <zjr1113> hi
03:36:40 <SamB_XP> jinjing: what's so funny ?
03:37:37 <jinjing> trying to do something like this
03:37:39 <jinjing> http://www.csse.monash.edu.au/~damian/papers/HTML/Perligata.html
03:37:43 <jinjing> http://github.com/audreyt/lingua-sinica-perlyuyan
03:50:12 <jinjing> gotta use TH i guess
03:50:24 <ivanm> jinjing: what character was that? my font displays it as an empty box...
03:51:07 <ivanm> oh, that whole "let's use a non-English language for programming!" garbage :s
03:51:22 <ivanm> (OK, Chinese might make sense... but _Latin_? :s )
03:53:03 <jinjing> ivanm: just some random unicode
03:53:38 <jinjing> it's good for job security
03:53:45 <ivanm> so, which spoken language are you planning on using/butchering (presumably for Haskell)?
03:54:44 <jinjing> oh ancient chinese, just like andreyt
03:54:52 <jinjing> audreyt
03:55:30 <mxc> i have a question about Control.Concurrent.Chan - the way its implemented, each value written to the chan is wrapped in its own MVar..  can anyone think of an obvious problem with reimplemnting it with an IORef (Data.Sequence) and using atomicModifyIORef to acheive atomicity?
03:56:01 <RayNbow> "but we expect to release GHC 6.12 during November or December 2009" <-- can we have it on December 25th? would be a nice Christmas present :p
03:56:17 <ivanm> heh
03:56:25 <ivanm> RayNbow: I'm sure most people would want it _before_ then
03:56:27 <Botje> christmas is reserved for perl 6, sorry :
03:56:40 <ivanm> besides, wouldn't that ruin boxing day for the GHC team with all the bug reports, etc.? :p
03:56:46 <ivanm> Botje: :o
03:56:47 <RayNbow> December 5th then for all the Dutch users? :p
03:56:59 <ivanm> that's St. Nicholas' day?
03:57:01 <SamB_XP> Botje: when does that come out? Dec. 25, 2020 ?
03:57:06 <RayNbow> ivanm: yes :)
03:57:10 <Botje> SamB_XP: "christmas" :)
03:57:14 <ivanm> Botje: heh
03:58:46 <dcoutts> mxc: you mean a single MVar holding a Data.Sequence ?
03:59:18 <mxc> dcoutts : could you do it with a single IORef?
03:59:21 <dcoutts> mxc: you need readers to be able to block in a read while writers never block
03:59:40 <dcoutts> mxc: you could not get readers to block if you used a single IORef
03:59:55 <Taejo> is there a substring-replacement function somewhere in the standard libraries? I want to do something like (escape s = replace ">" "&gt;" s).
04:00:03 <mxc> fair point
04:00:42 <dcoutts> mxc: the more interesting Q is if you can do it with a single MVar holding a normal queue data structure, and if not why not
04:00:45 <mxc> would using a single MVar guard and an IORef for the data solve it?
04:00:47 <EddyDean> Rounding errors are just mean :(
04:01:03 <mxc> doesn't seem too hard to do, i was going to do just that and see how it compared
04:01:22 <mxc> the followup question is, am I accomplishing anything in that case?
04:01:55 * hackagebot upload: language-python 0.2 - Parsing and pretty printing of Python code. (BerniePope)
04:03:00 <dcoutts> mxc: I think it needs at least two MVars
04:03:38 <dcoutts> mxc: consider the case of an empty queue and one reader blocking trying to read, then two writers trying to write
04:03:52 <mxc> yeah
04:04:22 <mxc> oh well, just a thought
04:05:25 <dcoutts> mxc: a potential advantage of using a normal data structure protected by an MVar is that you might be able to make a limited size queue more easily
04:06:54 <quicksilver> Taejo: no, although that example is fairly trivial in concatMap.
04:07:10 <Taejo> quicksilver: ah, good point
04:07:15 <Taejo> thanks
04:07:35 <mxc> dcoutts - thats actually what got me looking at it originally
04:07:41 <quicksilver> Taejo: for a more general solution, see http://www.haskell.org/pipermail/haskell-cafe/2007-July/028032.html
04:08:02 <quicksilver> Taejo: (which notably failed to attract any interesting responses, as always happens when I spend time writing a detailed email to the -cafe ;)
04:08:39 <SamB_XP> quicksilver: you should have cc'd it to libraries, I guess ;-P
04:08:40 <mxc> somewhere i have code that is writing to a chan and nothing is reading off of it so getting leaks
04:09:25 <quicksilver> SamB_XP: perhaps. I wasn't subscribed to libraries@ in July 2007 ;)
04:09:33 <SamB_XP> oh, right
04:17:09 <sieni> Ok, so now I asked ftp.funet.fi to mirror Hackage. Let's see what happens.
04:17:47 <Taejo> :t toEnum
04:17:49 <lambdabot> forall a. (Enum a) => Int -> a
04:18:10 <Taejo> am I the only one who is never sure which is toEnum and which is fromEnum?
04:22:54 <quicksilver> Taejo: toEnum converts "to" an "Enum"
04:23:19 <RayNbow> Taejo: you're not the only one, I recently made a mistake with those two functions
04:23:31 <yitz> quicksilver: morph is a really nice function!
04:24:05 <Taejo> quicksilver: yeah, so I see, but I sometimes think it should go to the enumeration rather than the thing enumberated
04:24:12 <Taejo> *enumerated
04:24:45 <yitz> quicksilver: why not package it together with a few basic selectors and put it on hackage?
04:25:17 <RayNbow> yitz: what's this morph function you're talking about?
04:25:29 <quicksilver> RayNbow: http://www.haskell.org/pipermail/haskell-cafe/2007-July/028032.html
04:25:45 <quicksilver> yitz: I used to be opposed to hackage filling up with a multitude of small packages
04:25:53 <yitz> quicksilver: too late
04:25:55 <quicksilver> yitz: I think I now concede that battle is lost :)
04:26:10 <quicksilver> yitz: perhaps I will, then.
04:26:12 * RayNbow adds that Haskell cafe post to his reading queue
04:26:28 <quicksilver> RayNbow: it's a generalised search-and-replace or search-and-transform.
04:26:55 <yitz> quicksilver: you're right. but it has the advantage of little useful things like that getting forgotten in the cafe archive. now they can get forgotten in the mess that hackage has become.
04:27:42 <RayNbow> hmm, wouldn't it be better to have a wiki page dedicated to small functions?
04:28:07 <SamB_XP> RayNbow: no!
04:28:10 <yitz> RayNbow: there should be, in addition to making it available on hackage
04:28:17 <SamB_XP> do you have any idea how long such a page would be ?
04:28:34 <RayNbow> SamB_XP: no, I don't :p
04:28:48 <yitz> it was once suggested to have a standard place to find a wiki page for each package
04:29:07 <SamB_XP> yitz: that surely is not a bad idea
04:29:33 <quicksilver> yitz: my preference was to submit it for inclusion in Data.List
04:29:39 <yitz> i guess you can create such a page, and point the cabal home page attribute to it. but the idea was that this would happen automatically.
04:29:42 <quicksilver> yitz: but I first hoped to get some discussion of it.
04:29:50 <quicksilver> yitz: no significant discussion resulted.
04:30:06 <SamB_XP> quicksilver: libraries@ is the place for that kind of bikeshedding, you know ;-P
04:30:12 <yitz> quicksilver: if you post an official proposal, then no significant discussion will get it into Data.List by default.
04:31:09 <yitz> quicksilver: but in this case, a separate module might actually be better. that allows it to grow in various directions - various kinds of selectors, support for text and bytestrings, etc.
04:33:42 <quicksilver> yitz: well, I'd like to answer the criticism "haskell doesn't have string replace in its standard library)
04:34:25 <yitz> quicksilver: it does now, there is (at least one) package on hackage. if you can find it.
04:34:47 <yitz> it's not as good as your morph though.
04:35:25 <yitz> it's also nice that morph is similar to a corresponding facility in Data.Map
04:35:30 <SamB_XP> yitz: Hackage /= standard library ;-P
04:36:09 <yitz> SamB_XP: true. it probably will be considered for inclusion in HP though - unless quicksilver beats them to it.
04:41:09 * hackagebot upload: language-python-colour 0.1 - Generate coloured XHTML for Python code. (BerniePope)
04:43:28 <gressvol-> I want to create a date datatype, data Date = Day Month, the Month datatype i can get to work with Month =   Jan | Feb etc. but not Day
04:43:43 <gressvol-> I tried data Day = Integer
04:43:50 <koeien> gressvol-: try something like data Date = Date Day Month
04:43:56 <ivanm> gressvol-: type Day = Word8
04:44:04 <ivanm> (or Integer if you insist...)
04:44:11 <koeien> the first should be a constructor, e.g. data Maybe a = Just a | Nothing
04:44:11 <ivanm> data requires a new constructor
04:44:14 <ivanm> type is for aliases
04:44:45 <koeien> if you do data Month = Jan | Feb, you introduce new constructors "Jan" and "Feb". Similarly, when you say data Date = Day Month, you introduce a new constructor named "Day"
04:45:03 <koeien> e.g. (Day Jan) :: Date
04:46:44 <ivanm> can someone please shut that Shelby Moore person up on -cafe?
04:47:14 <gressvol-> okey, I added the constructor to Date, the problem now is if I want to create a new variable of the type Date, how do I do it? testDate = 20 Feb gives me error
04:47:28 <koeien> what is your definition of Date now?
04:47:38 <gressvol-> data Day = Integer
04:47:39 <gressvol-> 	deriving Show
04:47:51 <koeien> this is a really strange definition
04:47:56 <sinelaw> Integer?
04:48:12 <sinelaw> Today is 54
04:48:19 <koeien> gressvol-: you probably want data Day = Day Integer
04:48:38 <koeien> it can be confusing that the constructors can have the same name as types, but that is a coincidence
04:48:50 <koeien> if this confuses you, try data Day = DayC Integer
04:49:20 <burp> some type/newtype stuff might also work, depends on what you need
04:49:21 <yitz> koeien: it's not exactly a coincidence. once you get used to it, it is actually quite convenient
04:49:29 <koeien> yitz: sure, i use this all the time :)
04:49:34 <gressvol-> what is the DayC for constructor?
04:49:49 <koeien> yitz: but it can be confusing
04:49:52 <koeien> (in the beginning)
04:50:03 <gressvol-> I am thinking of data Day = Day Integer as a recursive definition, is that correct?
04:50:09 <koeien> no, this is not recursive
04:50:19 <gressvol-> :(
04:50:30 <koeien> take your example data Month = Jan | Feb | ...
04:50:31 <sinelaw> does Agda
04:50:45 <koeien> then Jan :: Month, Feb :: Month
04:51:00 <sinelaw> does Agda allow something like Day "0 < Integer  < 32"?
04:51:08 <koeien> another example is data MyInt = MyInt Integer
04:51:15 <burp> and Int will be enough :>
04:51:17 <koeien> then MyInt 37 :: MyInt, MyInt 42 :: MyInt, and so on
04:52:31 <koeien> or data T = X Int | Y String
04:52:43 <koeien> then X 37 :: T, but also Y "Hello" :: T
04:52:46 <Axman6> ivanm: yeah i keep hearing peopletalk about them, and whenever i go to check it out... i get so bored by the content of what they'resaying
04:58:57 <quicksilver> ivanm: no, it's a cafe. Just go and sit at a different table and concentrate on your latte :)
04:59:30 <Axman6> half the time i have no idea wth they're even talking about
04:59:50 <ivanm> quicksilver: but I don't like coffee!
05:00:06 <ivanm> Axman6: talk about what?
05:00:24 <Axman6> ivanm: Shelby Moore
05:00:29 <ivanm> "them"? ;-)
05:00:40 <Axman6> (couldn't tell their sex,so played it safe)
05:00:44 <ivanm> heh
05:01:47 <Baughn> ivanm: I've just told gmail to mark shelby moore threads as read
05:01:48 <ivanm> Axman6: well, I just saw recently that despite only starting to learn FP a week ago, [s]he "was able to condense Category theory and implementation of Monads to one screen" :s
05:02:00 <Axman6> yeah
05:02:04 <ivanm> Baughn: I get digest for -cafe... so I can't really do that :s
05:02:13 <Axman6> hey guess what
05:02:19 <Baughn> ivanm: So you mentioned. I don't really understand the purpose of digests, myself.
05:02:32 <ivanm> Baughn: to avoid getting so many emails ;-)
05:02:39 <Axman6> i'm now officially 20!
05:02:41 <ivanm> (tbh, it's mainly because of laziness atm)
05:02:44 <ivanm> Axman6: \o/
05:02:53 <Baughn> ivanm: In 2009? :P
05:02:58 <ivanm> Axman6: wait, you have the same birthday as my dad? :o
05:03:02 <Baughn> ivanm: The number of emails shouldn't matter
05:03:08 <Axman6> bloody hell, another one?
05:03:32 <ivanm> Baughn: it's easier to mark one -cafe email as read and skip all the boring messages than have to read through a bunch of emails
05:03:33 <Axman6> there'sa guy at the SES with a birthdat on the 4th, another on the 5th with me, and another on the 6th
05:03:44 <ivanm> Axman6: umm.... it's still the 4th :p
05:03:54 <ivanm> (well, here it is... just because you artificially change the time down there...)
05:03:55 <ivanm> ;-)
05:04:05 <ivanm> so you're not the same as my dad...
05:04:06 <Axman6> spewsforyou then :P
05:04:09 <Baughn> ivanm: A threaded reader helps.
05:04:09 <Axman6> fucking spacebar!
05:04:39 <ivanm> Baughn: yeah, now that I'm using gnus it'd probably be easier to manage
05:04:54 <ivanm> but I'm lazy... that's apparently an advantage in programming... ;-)
05:05:21 <koeien> yes, i just press R to mark a thread as read
05:05:33 * RayNbow uses his gmail account to read the Haskell Cafe list
05:05:50 * Baughn uses gmail for everything. It's not ideal, but he's lazy.
05:05:50 <RayNbow> it's nice to have a rule to do the auto-archiving and labeling :p
05:06:23 <Baughn> (Anyway, gmail cooperates nicely with smartphones)
05:06:23 <koeien> yeah, i have procmail set up, but this is a pain in comparison of course
05:06:37 <RayNbow> Baughn: does it?
05:07:00 <ivanm> RayNbow/Baugh: I use gmail; I've just times in the past where I've been saved by having my emails cached on my computer
05:07:05 * RayNbow only syncs his Gmail's inbox on his smartphone... not the other folders
05:07:21 <fbru02> fmap . fmap over a ADT will give me the constructor let's say W two times ? as : W W Value ?
05:07:22 <RayNbow> (don't want my phone to be flooded with all the mailing list messages :p)
05:07:28 <ivanm> Baughn: not really... it's still a PITA to use, and the Java GMail client doesn't launch attachments properly, etc.
05:07:28 <Baughn> RayNbow: Its html-lite webmail mode works better on my phone than any actual imap program I've found
05:07:36 <ivanm> (on my WM5 smartphone anyway)
05:07:41 <gressvol-> lets say that I changes data Day = Numerical Int, this means I uses Numerical as constructor and thus I can use the Int for calculations?
05:07:51 <Baughn> ivanm: Right. I don't use a client, I just use my web browser.
05:07:59 <Axman6> fbru02: it shouldn't
05:08:03 <koeien> fbru02: i think so
05:08:06 <koeien> :t fmap . fmap
05:08:07 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
05:08:08 <Baughn> ivanm: That does work better if said browser supports local website databases, as mine does
05:08:11 <ivanm> RayNbow: heh, yeah, I filtered -cafe to its own folder to stop getting so many when I used my phone to check emails that came in overnight before I headed off to uni ;-)
05:08:18 <Axman6> > fmap (fmap (+2)) $ Just [1..10]
05:08:19 <koeien> :t fmap . fmap :: [Maybe a]
05:08:19 <lambdabot>   Just [3,4,5,6,7,8,9,10,11,12]
05:08:21 <lambdabot>     Couldn't match expected type `Maybe a'
05:08:21 <lambdabot>            against inferred type `f a1 -> f b'
05:08:21 <lambdabot>     In the first argument of `(.)', namely `fmap'
05:08:30 <koeien> :t fmap . fmap :: a -> b -> [Maybe a] -> [Maybe b]
05:08:32 <lambdabot>     Occurs check: cannot construct the infinite type:
05:08:32 <lambdabot>       b = [Maybe (a -> Maybe b)] -> [a]
05:08:32 <lambdabot>     In the expression: fmap . fmap :: a -> b -> [Maybe a] -> [Maybe b]
05:08:37 <koeien> hmm, i am stupid
05:08:41 <ivanm> Baughn: isn't webmail-lite shite in phone mode? :o
05:08:47 <koeien> aw, extra parens
05:08:51 <ivanm> gressvol-: yes
05:08:53 <RayNbow> Baughn: hmm, it's been a while I've used the html lite mode... but I remember not liking it because I couldn't access a certain page/folder...
05:09:02 <ivanm> gressvol-: but Numerical is a bad name for the constructor in that case ;-)
05:09:08 <Baughn> ivanm: No, it's actually very good. Caches everything, supports threading, etc.
05:09:10 <ivanm> gressvol-: why not "data Day = Day Int" ?
05:09:13 <Baughn> ivanm: Well..
05:09:22 <ivanm> Baughn: how does it cache? gears support?
05:09:26 <koeien> :t fmap . fmap :: (a->b) -> [Maybe a] -> [Maybe b]
05:09:28 <lambdabot> forall a b. (a -> b) -> [Maybe a] -> [Maybe b]
05:09:32 <Baughn> ivanm: No. I'm not sure about the details.
05:09:37 <ivanm> heh
05:09:45 <Baughn> ivanm, RayNbow: Gmail actually has /three/ modes. There's full mode, html-lite, and a specialized phone mode
05:10:02 <ivanm> Baughn: right, I was talking about the phone mode
05:10:10 <ivanm> last I tried it, it wasn't that great
05:10:13 <fbru02> koeien: Axman6 : thanks ... i guessed it was like koeien said, and then you can use join maybe to clear out one level of construction
05:10:23 <Baughn> ivanm: Much better than the built-in imap app. :/
05:10:44 <Axman6> fbru02: you'd have to make your type a monad then
05:10:50 <Baughn> ivanm: When was the last time you checkedit, anyway?
05:11:01 <ivanm> Baughn: a couple of years ago probably ;-)
05:11:12 <ivanm> Baughn: "built-in imap app"? I use WM5! ;-)
05:11:37 <Baughn> fbru02: The key method that makes a functor a monad is the ability to join multiple layers like you want. But it still needs to be an applicative functor first.
05:11:41 <fbru02> Axman6:  no probem in making that happen but now i wonder in which case the W start to pile up ? let me check TM13
05:11:41 <Axman6> ivanm: shame on you
05:11:51 <ivanm> Axman6: hey, it was about 5 years ago...
05:11:55 <ivanm> not many options back then
05:12:03 * RayNbow is waiting for his WM6.5 update for his phone :p
05:12:04 * ivanm is eagerly waiting for the Nokia N900 to come down under...
05:12:11 <Axman6> ok,sleeptime. night all!
05:12:17 <ivanm> cya Axman6
05:12:23 <fbru02> Baughn: Applicative means if i can recall to have return function
05:12:25 <Baughn> ivanm: Well, the N900 doesn't have very many extra apps yet. :P
05:12:36 <ivanm> Baughn: I don't care about apps that much
05:12:48 <vegai> I wish it wasn't so damned expensive...
05:12:56 <ivanm> it has a full keyboard and wifi support
05:12:56 <Baughn> I wish it had more memory. :/
05:13:01 <ivanm> pretty much all I want :p
05:13:05 <Baughn> I'm just borrowing this one.. which is good
05:13:17 <sinelaw> might as well by a laptop
05:13:20 <Baughn> Because it's running at 50% memory use with basically nothing loaded
05:13:20 <ivanm> Baughn: I thought the N900 had heaps of memory...
05:13:20 <sinelaw> *buy
05:13:24 <Baughn> ivanm: No, only 256MB
05:13:33 <ivanm> sinelaw: well, I _do_ need to make calls sometimes...
05:13:39 <Botje> that would be "heaps of memory" in 1995 :)
05:13:42 <vegai> 256MB is huge for a such a small device
05:13:47 <sinelaw> that's what a phone is for
05:13:49 <ivanm> Botje: heh
05:13:52 <vegai> but that's what GNU is for!
05:13:54 <RayNbow> Botje: ah, 1995... :)
05:13:59 <Baughn> vegai: Maybe if you install Gentoo on it.. ^^;
05:14:04 <gressvol-> Instance of Num Month required for definition of daysInMonth - this is the error message I get when I try extract the Int in Month to check if it is equal to some other Int
05:14:16 <vegai> we had 64MB when we coded for the N770...
05:14:20 <Baughn> vegai: Look. It runs *Mozilla*.
05:14:20 <ivanm> sinelaw: right, but I want my phone to be able to check my emails as well over wifi, and to use a real keyboard whilst I'm doing it
05:14:29 <Baughn> vegai: Once Opera has a version for it, things might get better.
05:14:29 <ivanm> since a laptop's rather heavy to hang off a belt...
05:14:44 <gressvol-> do I need to derive something?
05:14:47 <RayNbow> 1995... the time when I thought a 2 GB SCSI hard disk was plenty of space :p
05:14:51 <vegai> Baughn: perhaps some webkit thing?
05:14:52 <ivanm> gressvol-: "instance Num Month where ... "
05:15:03 <ivanm> Baughn: I wouldn't bother installing Gentoo on something that small...
05:15:15 <fasta> RayNbow, how much do you think is plenty now?
05:15:16 <Baughn> ivanm: Heh. Would be fun, though. :P
05:15:18 <ivanm> besides, can't you install normal Debian ARM packages on it?
05:15:21 <ivanm> Baughn: nah
05:15:27 <Baughn> vegai: That'd work as a renderer, but Opera has much better touch-screen/small-device support
05:15:32 <ivanm> I think those people that install Gentoo on an eee or something are stupid
05:15:49 <fasta> Gentoo -O99!
05:15:52 <ivanm> Baughn: I thought the mozilla browser had touch support in it...
05:15:57 <ivanm> *browser they use
05:16:01 <Baughn> ivanm: Not /good/ support
05:16:02 <RayNbow> fasta: I'm happy with a 1 TB drive I put in an external enclosure and the 7200 rpm 200 GB disk in my laptop
05:16:03 <ivanm> @slap fasta
05:16:04 * lambdabot secretly deletes fasta's source code
05:16:08 <ivanm> Baughn: define "good"
05:16:11 <nominolo> @seen kmett
05:16:11 <lambdabot> Unknown command, try @list
05:16:18 <fbru02> ivanm : you cant install gentoo on eee ?
05:16:22 <Baughn> ivanm: Capable of utilizing multitouch
05:16:25 <fasta> RayNbow, you won't be in a few years.
05:16:33 <Baughn> fbru02: ..not sanely. 4GB disk space?
05:16:44 <RayNbow> fasta: then I'd probably also have a newer computer :p
05:17:06 <vegai> Baughn: I wonder why they didn't get opera in the earlier Nxxx models
05:17:08 <fbru02> Baughn:  gentoo wheighs 4gb now ?
05:17:08 <ivanm> RayNbow: I have 250 GB in my laptop, and I'm kinda running out... (I wanted to install UT2004 on it, but barely any of my parititons had enough support to copy over and extract the 6 CDs of content, let alone install them somewhere as well.... :( )
05:17:16 <ivanm> fbru02: you can, but why would you?
05:17:20 <vegai> I hope there's no corporate idiocy involved there
05:17:24 <ivanm> Baughn: I thought resistive screens couldn't do multitouch
05:17:31 <RayNbow> fasta: for example, I'm currently not interested in 1080p since my display is only 1680x1050 :p
05:17:34 <fbru02> ivanm: because i prefer it than xp ?
05:17:34 <fasta> I hope I can use mine until I decide that I want a newer one, and not that the hardware just breaks down.
05:17:35 <ivanm> Baughn: besides, isn't there patent problems with Apple for multitouch?
05:17:36 <Baughn> ivanm: You can bind gestures to event inputs that mozilla *can* understand, but you lose details. For example, if you pinch a document in opera, the bits of text you're actually touching will stay under your fingers
05:17:41 <nominolo> @seen edwardk
05:17:41 <lambdabot> Unknown command, try @list
05:17:52 <ivanm> fbru02: get linux on it... there's various binary distros
05:17:56 <ivanm> doesn't have to be gentoo...
05:17:58 <fasta> RayNbow, even then, it doesn't really matter.
05:17:59 <RayNbow> ivanm: ah, but I'm not really interested in new games... I play old games :p
05:18:00 <ivanm> preflex: seen edwardk
05:18:01 <preflex>  edwardk was last seen on ##logic 1 day, 17 hours, 57 minutes and 26 seconds ago, saying:  /j #lock-free
05:18:02 <Baughn> ivanm: Not so much. Broadcom's technology works fine; you don't have to use apple's methods.
05:18:04 <ivanm> nominolo: ^^
05:18:12 <RayNbow> like CS, UT99, Curse of Monkey Island... :p
05:18:15 <ivanm> RayNbow: heh
05:18:19 <fbru02> ivanm: yeah you might be right , binary sounds better
05:18:21 <nominolo> ah, I have to remember the name of that bot
05:18:25 <fasta> RayNbow, the only ones who truly like HD are the TV-salesmen ;)
05:18:25 * hackagebot upload: HGL 3.2.0.2 - A simple graphics library based on X11 or Win32 (ChristophLueth)
05:18:37 <fbru02> what is the best distro for haskell apart from gentoo?
05:18:49 <Baughn> ivanm: ..now, as to whether the N900 can do multitouch... I don't know. This is an early prototype I'm borrowing; it's missing quite a lot.
05:18:49 <gju> archlinux
05:18:50 <nlogax> arch seems good
05:18:57 <ivanm> nominolo: in case you didn't know, @seen was disabled for leaking too much memory (and was the chief cause of lambdabot continually dying IIRC)
05:18:58 <ivanm> @uptime
05:18:59 <lambdabot> uptime: 2d 18h 57m 50s, longest uptime: 1m 10d 23h 44m 29s
05:19:26 <fasta> fbru02, arch probably, but it is quite easy to make any Linux Haskell aware these days.
05:20:00 <fasta> fbru02, the thing about arch is that certain other parts are probably less well developed.
05:20:05 <ivanm> fasta: well, distro support is easier than installing it all yourself in ~/
05:20:17 <gju> fasta: wich are?
05:20:17 <ivanm> fasta: like the pkg manager? :p
05:20:27 <fbru02> fasta: never tried arch but people say that pacman is quite good
05:20:39 <fasta> fbru02, pacman is quite good.
05:20:42 * ivanm really wishes the portage devs would let the PMS specify usage of bounded deps in ebuilds...
05:21:04 <ivanm> fasta: but don't you need a separate PM just for non-official packages?
05:21:09 <fasta> fbru02, but like any package manager it is dependent on packages. Debian/Ubuntu just have tons of maintainers.
05:21:17 <gju> ivanm: no, you dont.
05:22:10 <gju> you can download pkgbuilds from an user repository and istall them. the tool you mean is called yaourt and is a "pacman-clone" wich also searches the user-repos.
05:22:22 <ivanm> oh, it's just for searching?
05:22:33 <gju> no you can also install via yaourt.
05:22:45 <gju> but you dont need to install yaourt to use 3rd party pkgs.
05:22:48 <fasta> Especially for companies it's kind of insecure to rely on other users for packages.
05:22:52 <ivanm> in gentoo, if you use portage then you just use layman for syncing external repos (paludis supports external repo syncing inbuilt)
05:23:10 <ivanm> gju: so why _do_ you need yaourt?
05:23:20 <ivanm> (and is that meant to look/sound like "yoghurt"? :p )
05:23:44 <ivanm> fasta: you mean that companies want "official" packages?
05:23:57 <gju> you don't. it's a tool developed by uses wich were too lazy to look up the pkgs at the aur-site, i think. :)
05:24:03 <fasta> With Debian you also depend on some 3rd party, but there are quite some obstacles before you can maintain an important package.
05:24:06 <gju> *users
05:24:20 <fasta> ivanm, yes.
05:24:41 <ivanm> gju: OK
05:24:46 <fasta> ivanm, in reality probably there isn't a single company that has any meaningful security.
05:25:12 <fasta> ivanm, e.g. they will probably build something from a non-encrypted source some day.
05:25:29 <ivanm> gentoo has eix for searching, though the latest version is a PITA to setup for external repos...
05:25:35 <ivanm> fasta: yeah
05:26:01 <ivanm> and with the debacles debian and fedora have had semi-recently, it goes to show that "official" packages can't always be guaranteed to be reliable
05:26:03 <fasta> It would be nice to work for a security agency that actually does this for a few weeks ;)
05:32:13 <PetRat> When I try to import Control.Monad.Identity, I get the error message it was found in multiple packages (transformers and mtl) --- how do I pick one to load?
05:33:51 <fasta> PetRat, you do the opposite, hide-package
05:35:27 <SamB_XP> argh, stupid septa strike ...
05:35:33 <PetRat> fasta: is that a cmd line argument to ghci?
05:36:11 <fasta> PetRat, -hide-package transformers -hide-package monads-fd -hide-package mtl-tf-0.1
05:36:27 <fasta> PetRat, that's what I use as part of a ghc command, yes.
05:36:36 <fasta> PetRat, ghci == ghc with a flag
05:37:09 <SamB_XP> fasta: strangely, that flag is -i
05:37:15 <SamB_XP> iirc
05:37:52 <fasta> SamB_XP, yes, -i is used for two things, then.
05:38:05 <SamB_XP> could be wrong ;-)
05:38:13 <SamB_XP> it might just be --interactive
05:39:09 <ivanm> what else is -i used for apparently?
05:39:22 <SamB_XP> ivanm: something to do with includes, I imagine ?
05:39:26 <PetRat> fasta: all I needed to hide was transfomers. It didn't know about the other packages. I'm running the latest Haskell Platform configuration.
05:39:42 <fasta> PetRat, it was an example of use.
05:40:03 <fasta> ivanm, include dirs
05:40:37 <ivanm> ahhh
05:40:49 <PetRat> fasta: ok, thanks. I'm trying to run a bit of code that someone gave me on beginners@haskell.org, and it runs now.
05:40:57 <ivanm> yeah, it's a flag to ghci
05:41:03 <ivanm> not sure if it's a flag to ghc though...
05:41:12 <fasta> ivanm, ghc and ghci are the same binary.
05:41:20 <ivanm> -i /= --interactive here...
05:41:27 <ivanm> fasta: yes, but they might accept different flags...
05:41:38 <fasta> ivanm, no, they don't.
05:41:41 <ivanm> SamB_XP: so no, -i isn't interactive
05:41:52 <ivanm> fasta: well, I didn't know, which is why I said "not sure ... " ;-)
05:42:10 <fasta> ivanm, I removed the doubts then.
05:42:12 <SamB_XP> yeah, I also said iirc for a reason ;-P
05:42:21 <ivanm> fasta: yay! :p
05:42:36 <SamB_XP> anyway, GHCi and GHC take the same flags with mostly the same effects
05:42:56 <SamB_XP> --help has a somewhat-less-helpful effect with ghci, though, iirc
05:43:52 <ivanm> SamB_XP: only gives you ghci specific help
05:43:56 <ivanm> which I would find more helpful ;-)
05:44:07 <SamB_XP> ivanm: but it gives you about 4 lines of it!
05:44:17 <ivanm> SamB_XP: more here
05:44:19 <ivanm> with 6.10.4
05:44:25 <ivanm> 26 lines!
05:44:35 <ivanm> so 6.5 times as much help as you get! :p
05:44:50 <peterklo> When I try to use module Graphics.UI.Gtk.OpeGL in fedora I get that the module cannot be found, I have installed ghc-gtk2hs is that not enough?
05:44:51 <SamB_XP> ivanm: it gives me more than that many lines of output
05:45:00 <ivanm> oh...
05:45:21 <SamB_XP> but that's about how many lines of information I remember it giving
05:45:54 <ivanm> well, it tells you of the 4 most helpful options for ghci
05:46:01 <ivanm> and which file types are accepted
05:50:34 <SamB_XP> yeah, the lines about those 4 options are the four I was referring to ;-)
05:51:52 <SamB_XP> hmm, what's "buzz" ...?
05:53:51 * hackagebot upload: haskell-src-exts 1.3.0 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer (NiklasBroberg)
05:54:00 <ziman_> @src either
05:54:00 <lambdabot> either f _ (Left x)     =  f x
05:54:00 <lambdabot> either _ g (Right y)    =  g y
05:55:45 <gressvol-> how do I match the a datatype that looks like this? data Date = Date Day Month Year
05:56:16 <sioraiocht> gressvol-: you mean pattern match one?
05:56:22 <gressvol-> yes
05:56:23 <sioraiocht> foo (Date d m y) = ...
05:56:32 <gressvol-> okey
05:57:05 <gressvol-> i was testing something with (_ m _) but I guess the interpreter doesn't know that it is of Date
05:57:55 <sioraiocht> gressvol-: if you want to do that you can do (Date _ m _), but you have to specify the constructor in the pattern =)
05:59:57 <Vanadium> If you used type Date = (Day, Month, Year), you could match against it as (_, m, _)
06:03:26 <gressvol-> how do I extract the Int from this structure: data Year = Year Int ?
06:03:33 <gressvol-> "extract"*
06:03:54 <kamatsu> gressvol-: with a pattern match
06:03:55 <kamatsu> e.g
06:04:03 <kamatsu> \(Year v) -> v
06:04:35 <yitz> extract (Year v) = "The year is " ++ show v
06:13:23 <EnglishGent> @hoogle [[a]] -> [a]
06:13:24 <lambdabot> Prelude concat :: [[a]] -> [a]
06:13:24 <lambdabot> Data.List concat :: [[a]] -> [a]
06:13:24 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
06:15:07 <det> Is it possible for a type parameter of a function to be parameterized by 2 unrelated classes ?
06:15:16 <det> For example:
06:15:17 <det> Prelude> let f i = show (i+1)
06:15:17 <det> Prelude> :type f
06:15:17 <det> f :: (Num a) => a -> String
06:15:43 <det> is it necessary that Num must be a subclass of Show in order for this to work ?
06:18:35 <Vanadium> yes, otherwise you would need f :: (Num a, Show a) => a -> String?
06:19:19 <det> is that a valid Haskell type
06:19:26 <det> or is that hypothetical
06:19:27 <koeien> it is, but redundant
06:19:56 <det> I am trying to understand the need for hierarchies of type classes
06:20:05 <det> is it just to make types easier to write ?
06:20:18 <Vanadium> I believe that Num being dependent on Show is considered a mistake
06:20:23 <koeien> RealFloat might need + to define its operators
06:20:28 <koeien> its functions*
06:21:34 <koeien> numeric-prelude is supposed to solve some of the problems, but it is more complex
06:22:41 <det> Well, I am mostly curious about the language level design decisions
06:23:15 <det> In general, when is it useful or required to subclass another type class
06:24:20 <koeien> i don't think it is required
06:24:34 <koeien> but it can be useful if you provide defaults in terms of the superclass
06:24:34 <zygospasm> det: (1) when you use members of that type class in your subclass's defaults (2) when you use members of that type class in your typeclass's laws (3) when there's a unique free instance of that type class given your one
06:24:39 <Gilly> does there exist `mod` for fractionals?
06:24:49 <Gilly> like 3.4 `mod` 3 = 0.4
06:25:17 <Gilly> (i know i can easily implement it using floor :))
06:25:47 <det> zygospasm, Thanks, I think I understand all points except (3)
06:26:37 <zygospasm> det: (3) is the argument for Applicative being a superclass of Monad; every Monad has an Applicative instance given by (<*>) = ap; pure = return
06:27:06 <zygospasm> det: but it's pretty common for superclasses to be used solely to reduce the sizes of contexts
06:27:19 <det> sizes of the contexts ?
06:27:22 <zygospasm> for instance, Show and Eq are superclasses of Num for basically that reason AIUI
06:27:28 <koeien> i think that is the rationale for Num & Show
06:27:46 <det> sizes of the contexts means simplify the types ?
06:27:52 <koeien> less keyboarding
06:28:02 <zygospasm> det: if Eq weren't a superclass of Num, then: "f 3 = True; f _ = False" would have "f :: (Num a, Eq a) => a -> Bool" rather than "f :: (Num a) => a -> Bool"
06:28:22 <det> I see
06:28:44 <det> Maybe a different notation the types would be useful
06:28:48 <zygospasm> the argument for "Show a => Num a" seems much weaker
06:29:35 <koeien> wlel, instance Eq Double may be considered harmful
06:29:48 <koeien> but Show is not really required for something to be a number, that's true
06:30:18 <fasta> How do I get GLU on Windows? C:\Program Files (x86)\Haskell Platform\2009.2.0.2\gcc-lib\ld.exe: cannot find -lGLU
06:30:18 <zygospasm> det: there's a trick, by the way, for simplifying contexts. if you have a long boring context "C a b c", you can write "class C a b c => MyClass a b c; instance C a b c => MyClass a b c" and then use MyClass a b c as a synonym
06:30:43 <det> zygospasm, I'm sorry, I dont know what "context" means
06:30:52 <zygospasm> det: the context is the thing to the left of the =>
06:30:54 <koeien> "the thing before the =>"
06:30:56 <det> ok
06:31:04 <det> why not call that a constraint
06:31:19 <zygospasm> det: well, a context is a set of constraints i think
06:31:24 <det> oh, ok
06:34:39 <det> "(3) is the argument for Applicative being a superclass of Monad; every Monad has an Applicative instance given by (<*>) = ap; pure = return"
06:34:44 <det> I still dont understand that
06:34:52 <det> I'm not really familiar with Haskell TBH
06:35:01 <koeien> if something is a Monad, it is also an Applicative functor
06:35:27 <koeien> (in Haskell, this is not enforced btw)
06:36:59 <det> Ok
06:37:22 <koeien> but there are applicative functors which are not monads
06:37:31 <det> so that means that if you define an instance of a Monad, you can use the Applicative class on it as well
06:37:46 <zygospasm> there are also monads whose Applicative instance doesn't match the free one from Monad, and that sucks too ;-)
06:37:55 <koeien> ah yes
06:38:08 <det> I should have added a ? after my statement, I meant to ask if I was correct :-)
06:38:55 <zygospasm> @type \f x -> do y <- f <$> x; return y
06:38:56 <lambdabot> forall a b (f :: * -> *). (Functor f, Monad f) => (a -> b) -> f a -> f b
06:38:58 <koeien> what it would mean is that programmers cannot forget to define Applicative for Monads, and that (Monad m) => would also be enough to use "pure"
06:39:34 <zygospasm> ^^ that type "should" not have Functor in it, and wouldn't if Functor were a superclass of Monad
06:39:57 <zygospasm> koeien: if that were the case i'd hope that pure would be renamed return :)
06:39:59 <koeien> yes, the hierarchy would be Functor -> Applicative -> Monad
06:40:03 <koeien> zygospasm: sure ;)
06:40:12 <zygospasm> or Functor -> Pointed -> Applicative -> Monad
06:40:24 <zygospasm> but this'd break loads of code if we don't have something like type class aliases
06:40:43 <koeien> yes, maybe something for haskell'
06:40:47 <det> Sounds like there is a lot of bureaucracy in the definition of the classes :-)
06:41:00 <koeien> what do you mean?
06:41:23 <koeien> it entails some design decisions, yes :)
06:41:25 <det> I mean, the hierarchies
06:41:41 <zygospasm> det: it's more history. fixing this particular hierarchy isn't /that/ controversial
06:42:21 <koeien> that's why need to avoid success at all costs :(
06:43:35 <fasta> The aviod success argument is really silly. Implement program transformations to port one version to the other and there is no problem.
06:44:15 <koeien> that makes changes more expensive
06:44:20 <zygospasm> fasta: How do you do that in the case of changing the Applicative (Either e) instance to have a different context?
06:45:18 <fasta> koeien, given a suitable expressive language the costs should be far lower than discussing every minor detail.
06:46:49 <mxc> if anyone's curious about the chan talk from earlier..  I did a trial run implementing with sempahores (QSem) and Data.Sequence.Seq
06:47:19 <mxc> performance was abou 5-10 times worse than Control.Concurrent.Chan on writing and reading 1mm values in 2 sep threads
06:51:15 <det> Could someone give me a small example of why MPTC can be ambiguous ? :-)
06:53:37 <zygospasm> det: given: "class Container c a where singleton :: a -> c; instance Container [a] a where singleton = (:[])", "singleton 5 :: [Double]" is ambiguous
06:54:25 <zygospasm> "clearly" it should use the Container [Double] Double instance. but what if there were a Container [Double] Int instance?
06:56:13 <fasta> Why can't I use if os(windows)<newline><4 spaces> extra-lib-dirs: <some windows path> anywhere in a .cabal file? I get some internal error saying I cannot use an IfBlock there.
06:56:47 <dcoutts> fasta: conditionals are only valid in lib and exe sections
06:57:11 <det> zygospasm, I dont understand what "singleton 5 :: [Double]" is supposed to do
06:57:45 <gressvol-> when using quickCheck, how do I add a condition to the values generated e.g. only even numbers?
06:58:25 <int-e> @check even x ==> x `mod` 13 /= 3
06:58:26 <lambdabot>   No instance for (Test.QuickCheck.Testable
06:58:26 <lambdabot>                     Test.QuickChe...
06:58:28 <koeien> gressvol-: simplest is adding   even x ==>
06:58:35 <int-e> @check even x ==> (x :: Int) `mod` 13 /= 3
06:58:36 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
06:58:54 <int-e> @check \x -> even x ==> (x :: Int) `mod` 13 /= 3
06:58:56 <lambdabot>   No instance for (Test.QuickCheck.Testable
06:58:56 <lambdabot>                     (Test.QuickCh...
06:59:16 <dcoutts> fasta: does that fix it, or are you wondering why that restriction is there?
06:59:35 <fasta> dcoutts: it does fix it.
06:59:55 <det> When you write "5" in Haskell, is that a literal for an Integer or something else ?
06:59:58 <stroan> is Bryan O'Sullivan, one of the authors of RWH, in this channel?
07:00:13 <fasta> dcoutts: I wasn't usingthe "new" Executable syntax.
07:00:22 <dcoutts> ah
07:00:24 <int-e> det: it is  fromInteger 5  (and *that* 5 is a literal)
07:00:28 <det> stroan, maybe try: /who #haskell
07:00:42 <peterklo> When I try to use module Graphics.UI.Gtk.OpeGL in fedora I get that the module cannot be found, I have installed ghc-gtk2hs is that not enough?
07:01:24 <det> int-e, interesting
07:02:24 <det> Prelude> let f = 5
07:02:24 <det> Prelude> :type f
07:02:24 <det> f :: Integer
07:02:34 <det> how is ghc able to know f is an Integer then ?
07:03:00 <det> couldn't it be any one of the types that implement fromInteger ?
07:04:43 <fbru02> anyone can help me on deciding why e is not working .. see : http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4578#a4578
07:04:44 <det> Do type classes have a notion of a "default" in the case of ambiguity ?
07:04:50 <zygospasm> det: in certain cases 'defaulting' kicks in, and chooses a specific type rather than a polymorphic one. ghci has different defaulting rules from normal haskell, which confuses things further
07:05:54 <det> I see
07:06:40 <det> that sounds really messy
07:07:12 <fasta> det, if they didn't you couldn't write 1 + 1 and get an answer back.
07:07:39 <zygospasm> @type 1 + 1
07:07:40 <lambdabot> forall t. (Num t) => t
07:07:46 <fasta> > 1 + 1
07:07:47 <lambdabot>   2
07:07:56 <det> fasta, the alternative is for "5" to be a literal for Integer
07:08:01 <det> and 5.0 for float, etc
07:08:18 <fasta> det, yes, but some people want 5 to mean succ(succ(succ and so on)
07:08:49 <fasta> det, so, then it would still be a ghci specific hack.
07:08:54 <det> those people could use "fromInteger" 5 :-)
07:09:52 <fbru02> anyone can take a look at my doubt ?
07:10:18 <det> fbru02, maybe you should be more specific than "why isnt this working"
07:10:25 <fasta> How do I get GLU to work on Windows?
07:10:30 <Badger> fbru02: Yep, that's definitely doubt.
07:10:48 <jix> det: well most of the time you have some type signatures that allows ghc to infer the type you want... and having 5 default to fromInteger 5 makes it easier to write polymorphic functions dealing with numbers
07:11:12 <Taejo> is it possible to include text from an external file into a haddock file (I'd like to include a short example.hs into my library docs)
07:11:46 <fbru02> det: Badger : thanks , I don't know how to explain it better i have 2 ADTs and want to fmap on the second on the result of another fmap on the first
07:14:06 <zygospasm> fbru02: i'm not sure what you're trying to do. but 'fmap (+2) a :: Num n => W n", and that's not a function, so can't be the first argument to fmap.
07:14:10 <det> I think that:
07:14:12 <det> e = fmap (fmap (+2) a) b
07:14:26 <det> (fmap (+2) a) isnt a function type
07:15:06 <int-e> @type fmap (fmap (+2) ?a) ?b
07:15:07 <lambdabot> forall a a1 (f :: * -> *). (Num a, ?a::a1 -> a, ?b::f a1, Functor f) => f a
07:15:40 <fbru02> det with your code i still get  Couldn't match expected type `a -> a1' against inferred type `W a2'
07:15:54 <det> fbru02, that is *your* code
07:16:07 <int-e> > fmap (fmap (+2) (ask >>= \n -> return (2*n))) [1]
07:16:09 <lambdabot>   [4]
07:16:23 <fbru02> det i know :)
07:16:28 <det> fbru02, use the REPL
07:16:31 <zygospasm> int-e: we have 'data W x = W x; a = W 1'.
07:16:36 <det> and see the types of the subexpressions
07:17:01 <int-e> zygospasm: ok, that's different then :)
07:17:28 <det> *Main> let x = fmap (+2) a
07:17:28 <det> *Main> :type x
07:17:28 <det> x :: W Integer
07:18:44 <gressvol-> Eq a => [a] -> [a], how is this read? I read [a] -> [a] as input of a list containing types "a" I get back a list containing "a"
07:19:39 <det> gressvol-, for all types where a supports equality
07:20:08 <gressvol-> okey, I see, its like a property
07:20:16 <det> property ?
07:20:25 <det> what language are you coming from?
07:20:26 <sproingie> "where a is an instance of Eq, list of a to list of a"
07:20:55 <fbru02> det and all maybe i should drop the idea of fmapping and go to a normal function (maybe i can annotate this function)
07:21:00 <fbru02> im still lost :(
07:22:09 <gressvol-> det: o-o
07:22:25 <sproingie> @hoogle Eq a => [a] -> [a]
07:22:26 <lambdabot> Data.List nub :: Eq a => [a] -> [a]
07:22:26 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
07:22:26 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
07:22:54 <sproingie> my first guess was nub
07:22:57 <fasta> gressvol-, if the type a has an instance Eq a, then this particular function takes a list of values of type a and returns a list of the same type.
07:23:03 <jasonmay> is there docs for using this bot anywhere
07:23:25 <det> gressvol-, what ?
07:23:35 <fasta> gressvol-, a is a concrete type when it is called.
07:23:42 <fasta> gressvol-, like Int
07:23:44 <sproingie> jasonmay: /msg lambdabot help
07:23:56 <gressvol-> det: Java/c#/c++
07:24:16 <sproingie> the 'a' is a type variable, you can tell that because it's lowercase
07:24:17 <det> gressvol-, that function is like a C# Generic
07:24:39 <jasonmay> sproingie: thanks!
07:24:39 <fasta> gressvol-, so, for a list of Int, which is [Int] we have Eq Int => [Int] -> [Int]. Since Eq Int is True, we get as a type just [Int] -> [Int].
07:25:35 <shellsage> blackh, you around?
07:26:15 <fasta> This is not the complete truth, but it works for 100% of all useful Haskell98 programs, I think.
07:26:38 <sproingie> where is it not true?
07:26:49 <zygospasm> sproingie: existentials, for instance
07:27:11 <Taejo> I'm writing a notifications library (to send notifications to Ubuntu's NotifyOSD and others supporting the same protocol). The protocol allows images in messages, but I don't want to turn my library into an image-processing library. Is there any library that provides a widely-used, flexible Image type (like Python's PIL)
07:27:31 <fasta> sproingie, well, I said that everything was a concrete type when it is called.
07:27:36 <zygospasm> sproingie: or impredicative polymorphism
07:27:49 <fasta> sproingie, I was thinking of something less advanced, being a list of undefined.
07:28:04 <sproingie> the behavior of undefined is of course, undefined :)
07:28:18 <fasta> sproingie, but it's type is defined.
07:28:28 <shellsage> Can someone help me figure out what's wrong with the "w/ State Monad" version here:  http://pastebin.com/d6dcf5954
07:28:30 <fasta> its*
07:28:52 <sproingie> > :t undefined
07:28:53 <lambdabot>   <no location info>: parse error on input `:'
07:28:58 <sproingie> @type undefined
07:29:00 <lambdabot> forall a. a
07:29:15 <sproingie> formal way of saying "it could be anything"
07:29:17 <zygospasm> sproingie: f :: Show x => (x, x) -> String; f x = show x ++ f (x, x)
07:29:52 <arcatan> blaarg. why snow leopard breaks everything :(
07:31:14 <det> gressvol-,  "Eq a => [a] -> [a]" is like "static System.Collections.Generic.List<T> someFunction<T>(List<T> list) where T : IEquatable<T>"
07:31:50 <shellsage> Actually, I fixed some small bugs in the monadic version, can someone help me take a look at this:   http://pastebin.com/d18c41e2
07:32:45 <quicksilver> det: aren't you missing a 'Factory' from that somewhere? ;)
07:33:14 <m0nkfish> is there a predefined function that does this: iterate f x !! n
07:33:27 <sproingie> @type iterate f x !! n
07:33:28 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
07:33:28 <lambdabot>     In the second argument of `(!!)', namely `n'
07:33:28 <lambdabot>     In the expression: iterate f x !! n
07:33:35 <byorgey> shellsage: change things like   newCount <- (count + 1)  to   let newCount = count + 1
07:33:41 <sproingie> 8-)=
07:33:46 <byorgey> shellsage: <- is only for binding the results of *monadic* actions
07:33:51 <jix> @type \f x n -> iterate f x !! n
07:33:52 <shellsage> byorgey, ah ok
07:33:52 <byorgey> shellsage: which (count + 1) is not
07:33:53 <lambdabot> forall a. (a -> a) -> a -> Int -> a
07:34:01 <m0nkfish> yeah that
07:34:05 <sproingie> @hoogle forall a. (a -> a) -> a -> Int -> a
07:34:06 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
07:34:06 <lambdabot> Data.IntMap adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
07:34:06 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
07:34:15 <koeien> m0nkfish: not that i know of, i would define a function "iterated f n :: (a -> a) -> Int -> a -> a"
07:34:48 <koeien> :t \f n -> foldr (.) id (replicate n f)
07:34:50 <lambdabot> forall b. (b -> b) -> Int -> b -> b
07:35:01 <shellsage> byorgey, but (nextCount, newProc) <- alpha bound count proc is correct right?
07:35:09 <byorgey> shellsage: yes.
07:35:17 <jasonmay> sproingie: he didn't respond with anything
07:35:23 <jasonmay> lambdabot: help
07:35:38 <byorgey> shellsage: if I were you I'd also abstract incrementing the count into a separate action   inc :: Num a => State a a
07:35:47 <byorgey> since you do it in three separate places
07:35:58 <sproingie> i always use the feminine pronoun for lambdabot for some odd reason
07:36:20 <sproingie> probably picked up from others
07:36:22 <byorgey> sproingie: that's not odd, it's correct =)
07:36:26 <jasonmay> yeah
07:36:29 <jasonmay> my mistake
07:36:30 <shellsage> byorgey, yeah, wasn't sure how to do that so I just pasted
07:36:32 <det> quicksilver, it's not that bad, main problem is you have to pass the types explicitly
07:36:40 <jasonmay> all irc bots are implicitly female
07:36:44 <m0nkfish> isnt the feminine pronoun supposed to be for vehicles
07:36:45 <shellsage> byorgey, it's incorrect for me to call alpha directly here right?  I should be using evalState?
07:36:46 <sproingie> jasonmay: try @help
07:36:48 <m0nkfish> boats, cars etc
07:36:50 <jasonmay> @help
07:36:50 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:37:00 <jasonmay> ok I'll do that in PMs then thanks!
07:37:02 <sproingie> heh all it does is give you a url
07:37:25 <sproingie> i think you can still get individual module help that way tho
07:37:43 <byorgey> shellsage: no, using evalState in the definition of alpha doesn't make sense, if that's what you're asking
07:37:48 <byorgey> what you have looks fine
07:38:07 <byorgey> but to use alpha elsewhere you may want to use evalState, it depends what you want to do
07:38:13 <shellsage> byorgey, well I'm getting: Couldn't match expected type `t -> t1'
07:38:13 <shellsage>            against inferred type `State a (a, LExpr (a, t2))'
07:38:13 <shellsage>     In the expression: alpha [] count arg
07:38:22 <byorgey> evalState takes a computation in the state monad and actually runs it by supplying an initial state
07:38:52 <byorgey> shellsage: oh, this is somewhere else where you're trying to use alpha?
07:39:11 <byorgey> then yes, you should use evalState, or execState, or runState (depending on what output you want)
07:39:16 <shellsage> byorgey, yeah sorry, should've pasted it too
07:39:20 <byorgey> that's ok
07:39:35 <lispy> ?where pastepipe
07:39:36 <lambdabot> I know nothing about pastepipe.
07:39:41 <lispy> ?hackage pastepipe
07:39:41 <lambdabot> http://hackage.haskell.org/package/pastepipe
07:39:57 <lispy> shellsage: ^^ that lowers the barrier to pasting a tiny bit
07:40:00 <byorgey> shellsage: by the way, what is 'alpha' supposed to do?
07:40:50 <shellsage> lispy, 404
07:41:07 <sproingie> runState/evalState/execState are fairly trivial, but also have the nice property of causing the expression to be run in the State monad in the first place
07:41:15 <sproingie> the magic of inference
07:41:18 <lispy> shellsage:  sorry! http://hackage.haskell.org/package/PastePipe
07:41:28 <shellsage> lispy, np thanks
07:41:43 <shellsage> byorgey, it performs an alpha conversion in lambda calculus
07:41:46 <sproingie> 'course as soon as you use get/put that sort of makes it obvious too
07:42:30 <byorgey> oh, I see
07:43:20 <JoePeck> shellsage: RIT student too eh =)
07:43:30 <shellsage> JoePeck, lol yeah, I'm in your class I bet
07:43:47 <JoePeck> shellsage: from the pastie above you return the count
07:43:55 <shellsage> JoePeck, I asked ats these same questions and couldnt understand his answer
07:44:15 <shellsage> JoePeck, return just the count?  not a tuple?
07:44:50 <JoePeck> shellsage: no, you should just return the SExpr/LExpr and keep the count inside the State Monad (hidden in the state)
07:45:05 <shellsage> JoePeck, oh, right
07:45:33 <shellsage> JoePeck, did you have to change anything else then besides rswa?
07:45:35 <JoePeck> shellsage: which would simplify a lot of your calls to alpha which bridge (<-) to a tuple, would now bridge to a single SExpr/LExpr
07:46:14 <JoePeck> shellsage: certainly. Since alpha actually returns a Monad of the form => State (SExpr/LExpr)
07:46:15 <shellsage> because rswa returns the tuple, so anything using rswa would have to no longer use the tuple
07:46:43 <JoePeck> shellsage: you have to keep using the State Monad (because it contains the count) in beta
07:47:15 <shellsage> JoePeck, right, got that, but the type of rswa returns the tuple from alpha
07:47:26 <shellsage> so anything using rswa is expecting a tuple
07:48:22 <JoePeck> shellsage: Yes, I mentioned you had to change at least one other function
07:48:37 <shellsage> JoePeck, ah, sorry didn't see you say that
07:51:17 <JoePeck> shellsage: for the most part, alpha looks good. Just get rid of passing the count around (count, SExpr) should just be an SExpr
07:51:54 <JoePeck> shellsage: the type signature of alpha would change, the type signature of rswa would change
07:52:08 <shellsage> JoePeck, yeah I dropped most of the count tuples
07:52:36 <shellsage> just trying to figure out how to call this, because the current uses . notation
07:53:15 <JoePeck> shellsage: if you don't like the dot notation then you can throw an extra param at the function and use $ notation (if that made sense)
07:53:25 <shellsage> didn't make sense
07:54:16 <JoePeck> shellsage: well, what do you have now (it wasn't included in the pastie)
07:54:40 <shellsage> rswa macros = alpha [] 0 . rsw macros
07:54:50 <shellsage> didn't change it yet, trying to figure out where to put evalState
07:55:26 <JoePeck> shellsage: well, for starters you removed that 0 parameter
07:55:32 <shellsage> right, yeah
07:56:07 <JoePeck> shellsage: now the signature has changed, so you'll want to comment out things that depend on it and see the new type signature.
07:56:08 <shellsage> JoePeck, so is it just:  evalState (alpha []) 0 . rsw macros
07:56:32 <JoePeck> shellsage: hint, you might want to hold off on the evalState because that is going to rip apart the State Monad
07:56:40 <JoePeck> shellsage: you still have the count in the State Monad
07:56:52 <JoePeck> shellsage: which you need for beta (because that runs sub which again calls alpha)
07:57:03 <shellsage> JoePeck, I dropped the count out of the state monad
07:58:19 <JoePeck> shellsage: you dropped it out of the "payload" of the State Monad, but it is still in the state of the Monad (via your "put" calls)
07:58:31 <shellsage> JoePeck, yeah, that's correct though
08:04:24 <shellsage> JoePeck, per his email
08:13:54 * hackagebot upload: fdo-notify 0.1 - Desktop Notifications client (MaxRabkin)
08:17:01 <FunctorSalad> are there any characters still unused in printf? ;)
08:17:18 <FunctorSalad> I think it would be nice to have one like %H in Printf-TH, but with a custom preprocessor function
08:17:47 <FunctorSalad> (which would have some fixed magic name... you don't want to put the name into the format string ;))
08:18:22 <Jafet> Yay printf
08:18:38 <FunctorSalad> irony?
08:19:16 <FunctorSalad> I'm writing an exporter for some text format and I don't want to write out a zillion recursive calls ;)
08:19:33 <FunctorSalad> so there should be something like %H that calls the exporter function
08:24:32 <lavish> hi all!
08:26:22 <lavish> can you recommend me a short introduction to haskell? I just need to learn to read simple programs atm
08:26:54 <Tobsan> is there a way to, with arrows, write a function that runs another function on both arguments in a tuple? like: second f $ first f $ (a,b)
08:27:53 <ToRA> > (succ *** succ) (1,1)
08:27:54 <fluxxen> hi everyone, Im sitting with a exercise that I really can't get pass. How can I create pattern matching for a List of the type in the url, http://pastebin.com/m5e670814 ? I have been sitting for hours trying things like (Add x : ( Add xs Empty))... but won't work, please give me a kick in the right direction
08:27:54 <lambdabot>   (2,2)
08:28:05 <Tobsan> ToRA: Oh, sweet!
08:28:09 <ToRA> (join (***) succ) (2,2)
08:28:12 <ToRA> > (join (***) succ) (2,2)
08:28:14 <lambdabot>   (3,3)
08:29:35 <quicksilver> fluxxen: don't use :
08:29:51 <quicksilver> fluxxen: : are part of the syntax of the built-in lists, they're not involved in that custom type
08:31:27 <fluxxen> quicksilver ok. any other tips how I could do it?
08:32:13 <MoALTz> :t (***)
08:32:14 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
08:32:40 <quicksilver> fluxxen: tips? I don't know. I could jsut tell you.
08:32:59 <quicksilver> fluxxen: I can't think how to give you a tip except by telling you
08:33:01 <fluxxen> quicksilver yes please. driving crazy
08:33:24 <quicksilver> multiply Empty = 0
08:33:47 <sm> morning all
08:33:48 <quicksilver> multiply (Add x xs) = x * multiply xs
08:34:23 <mxc> good morning
08:35:07 <maartenm> Prelude> succ 1.1 :: Float
08:35:08 <maartenm> 2.1
08:35:16 <maartenm> Prelude> succ 1.11 :: Float
08:35:21 <maartenm> 2.1100001
08:35:24 <maartenm> I don't understand this
08:35:34 <maartenm> (I'm learnign about types from lyah)
08:35:35 <quicksilver> maartenm: floating point maths is inaccurate
08:35:43 <m0nkfish> can lambdabot tell me which module *** is in
08:35:43 <quicksilver> maartenm: learn to love the fact.
08:35:53 <maartenm> ok, no problem.. it's the way in any language
08:35:55 <quicksilver> @index (***)
08:35:55 <lambdabot> Control.Arrow
08:35:56 <fluxxen> thanks quicksilver
08:36:00 <m0nkfish> :)
08:36:01 <fluxxen> quicksilver really! thank :)
08:36:07 <quicksilver> fluxxen: you're welcome.
08:36:23 <maartenm> but I was expecting succ to behave differently when I annotated the type
08:36:46 <quicksilver> well in a sense it does, and in a sense it doesn't.
08:37:05 <quicksilver> it behaves differently in that adding one to a floating point number is different, technically, from adding one to an integer
08:37:12 <quicksilver> but at an abstract level, they are the same operation
08:37:28 <maartenm> Prelude> succ 1.11 :: Double 2.1100000000000003
08:37:31 <quicksilver> that's what typeclasses are about - abstracting over different implementations of the same concept.
08:37:35 <maartenm> why does it add that 1 ?
08:37:43 <quicksilver> because that's what succ does
08:37:45 <quicksilver> succ adds one
08:37:48 <maartenm> ah, ok
08:38:09 <maartenm> so the 3e-15 or something isn't the "next" precision segment after 2.1100000000..
08:38:13 <maartenm> that confused me
08:38:13 <quicksilver> no
08:38:22 <quicksilver> yeah, Enum is a ridiculous class
08:38:25 <dolio> > 1.11
08:38:26 <lambdabot>   1.11
08:38:32 <dolio> > succ 1.11
08:38:33 <lambdabot>   2.1100000000000003
08:38:35 <dolio> Huh.
08:38:36 <quicksilver> and lots of people think the floating instances for Enum are stupid.
08:38:44 <quicksilver> the reason it works like that, is so you can do
08:38:49 <quicksilver> > [1..6] :: Double
08:38:50 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
08:38:50 <lambdabot>         against inferred ty...
08:38:55 <maartenm> yeah I wasn't attempting to critisize haskell or anything, just confused about the enum
08:39:00 <maartenm> it doesn't matter
08:39:02 <quicksilver> > [1..6] :: [Double]
08:39:03 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0]
08:39:07 <ray> yes, succ should add float epsilon
08:39:21 <quicksilver> if succ added float epsilon then [1..6] would be a rather long list ;)
08:39:28 <maartenm> ah
08:39:30 <maartenm> yeah
08:39:40 <quicksilver> really the class shouldn't be called Enum
08:39:48 <quicksilver> it should be called InaneRangeSyntaxHackClass
08:39:55 <maartenm> I also think adding the epsilons would provoke unpredictable behaviour
08:39:59 <mxc> quicksilver : and yet, even in that case, let a = [1..6] in head a wouldn't be  aproblem :)
08:40:10 <ray> well, if you want that list, you want map fromIntegral [1..6]
08:40:10 <mxc> yeay lazyness
08:40:45 <ray> there are other problems with Enum to be sure but this one is the instance's fault
08:40:53 <ray> it's an Enum instance that doesn't enumerate
08:40:58 <sproingie> huh, getting errors trying to build 6.12, paths seem to be messed up
08:41:03 <sproingie> cd libffi && /bin/tar -zxf ../ghc-tarballs/libffi/libffi*.tar.gz
08:41:03 <sproingie> /bin/tar: ../ghc-tarballs/libffi/libffi*.tar.gz: Cannot open: No such file or directory
08:41:14 <dolio> Well, not just one.
08:41:20 <dolio> > [1..6] :: Rational
08:41:22 <lambdabot>   Couldn't match expected type `GHC.Real.Rational'
08:41:22 <lambdabot>         against inferred t...
08:41:25 <quicksilver> ray: no, the instance is correct.
08:41:29 <dolio> > [1..6] :: [Rational]
08:41:31 <lambdabot>   [1 % 1,2 % 1,3 % 1,4 % 1,5 % 1,6 % 1]
08:41:32 <sproingie> there is a ./libffi/tarball/libffi-3.0.8.tar.gz tho
08:41:32 <quicksilver> ray: it's the specification that is broken.
08:41:46 <quicksilver> the instance does exactly what the haskell report says it must
08:41:55 <kmc> @tell kmc_ http://research.microsoft.com/en-us/um/people/simonpj/papers/c--/
08:41:56 <lambdabot> Consider it noted.
08:41:59 <dolio> Rational obviously shouldn't be enumerable.
08:42:05 <quicksilver> the bug is in call this class Enum when it really isn't about enumerations, it's about the inane range syntax
08:42:16 <ray> so if the specification says "add one", then True - False = 1? :)
08:42:48 <ray> the range syntax has no excuse anyway
08:43:25 <maartenm> it's not mathematically correct but at least it's usable
08:43:36 <ray> not very usable
08:43:46 <malie> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4579#a4579
08:43:51 <maartenm> well, the False < True is kidne stupid, yes
08:43:55 <malie> trying to get a generic pretty printer working
08:43:55 <ray> i hope you don't use it
08:43:59 <maartenm> at least it's not as 'bad' as with Erlang
08:43:59 <ray> i'm talking about floats
08:44:03 <maartenm> but that is also done by design
08:44:06 <maartenm> ah
08:44:06 <ray> False < True makes a kind of sense
08:44:16 <maartenm> well, adding the epsilon would just be as stupid
08:44:17 <ray> that's not Enum anyway
08:44:31 <Cale> quicksilver: How is the range syntax inane?
08:44:42 <Cale> The range syntax is really convenient :)
08:44:45 <malie> but tuple can't be added via extQ nor ext1Q
08:45:04 <ray> floats why do you RUIN EVERYTHING
08:45:09 * hackagebot upload: hpage 0.3.3 - A scrapbook for Haskell developers (FernandoBenavides)
08:45:12 <quicksilver> Cale: the inanity is relative to the rather nice concept of enumeration.
08:45:13 <Jafet> "Rate the inaneness of range syntax, on a scale of [1..10]"
08:45:17 <ray> you're not invited to my dinner party
08:45:47 <quicksilver> Cale: or possibly in the attempt to unify the trivial syntactic convenience of ranges with the more mathematically obvious concept of enumerability.
08:47:04 <Cale> quicksilver: Well, yeah, it might be nice to have a class which was *actually* for bijections between various types and Natural
08:47:09 <Cale> (or Integer)
08:47:40 <Cale> The instance of Enum for Floats is specified incorrectly, too, because they don't even make the range syntax make sense.
08:47:48 <benmachine> someone once said a nice name for Enum would be FromThenTo
08:48:04 <Cale> There are cases where [n,n'..m] will contain an element larger than m, which is just ridiculous
08:49:08 <benmachine> there's no way to do ranges for floats that make everone happy, I think
08:49:23 <Cale> There ought to be.
08:49:46 <Cale> Well, apart from the people who really think they want [u..v] to generate *every* float in that interval
08:49:49 <Jafet> What kind of restrictions does Haskell place on floats?
08:50:06 <ray> i don't see any reason why that shouldn't generate every float in that interval :)
08:50:21 <Cale> ray: because in general there are a hopelessly large number of them
08:50:33 <ray> well, it's finite, isn't it?
08:50:36 <Cale> sure
08:50:37 <fasta> Is there a way to see which library causes -lGLU to be needed for ld.exe?
08:50:44 <maartenm> isn't that also completely unpredictable, form mahcine to machine?
08:50:53 <fasta> I thought I had eliminated everything that depends on it.
08:50:57 <Cale> maartenm: It's standard enough.
08:51:01 <benmachine> ray: how would you like [a,b .. n] to be done?
08:51:03 <Raevel> i assume it's ieee floats
08:51:16 <maartenm> but then Float is just a human abstraction of Ints
08:51:22 <ray> consistently
08:51:29 <ray> skip the same number of floats each time
08:51:34 <Cale> That's practically the only thing floats have going for them. They're standardised.
08:51:46 <Twey> > [0, 0.01, .. 0.06]
08:51:47 <lambdabot>   <no location info>: parse error on input `..'
08:51:47 <maartenm> ah, Float ok, not Double
08:51:52 <Cale> (oh, and fast, they're fast and standardised)
08:51:53 <Twey> > [0, 0.01 .. 0.06]
08:51:54 <lambdabot>   [0.0,1.0e-2,2.0e-2,3.0e-2,3.9999999999999994e-2,4.999999999999999e-2,5.9999...
08:51:55 <Saizan> fasta: you could search for GLU in the output of ghc-pkg dump
08:51:59 <benmachine> ray: then you get inconsistent spacing
08:52:04 <Twey> Aw.  Not that one.
08:52:09 <ray> well, you get consistent spacing
08:52:12 <Twey> Cale: Are there any real alternatives?
08:52:18 <maartenm> no you don't
08:52:18 <ray> it might seem inconsistent in the decimal representation?
08:52:19 <benmachine> and hence a sequence that I don't think anyone ever needs ever
08:52:23 <Jafet> Well, you'd end up with a geometric distribution.
08:52:27 <maartenm> then [1..2] would contain more elements than [3..4]
08:52:40 <maartenm> or less
08:52:43 <ray> oh, right
08:53:04 <fasta> Saizan, thanks. That's probably enough to solve it.
08:53:09 <maartenm> you would onyl use it for GPU stuff or s'thing
08:53:11 <benmachine> because floats are more dense close to zero
08:53:12 <ray> i revise my opinion, it should set your cpu on fire
08:53:17 <benmachine> heh
08:53:36 <malie> dear #haskell, I was looking at how difficult it would be to write a generic pretty printer using SYB. I can get nice lists and numbers, but I'm somewhat blocked at tuples.  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4579#a4579
08:53:54 <ray> maybe they should be treated as their internal representations
08:53:55 <napsy> Hello. I've coded a naive fibonacci algorithm but now I don't know how to get output from the function. I tried to call putStrLn fib 5 but I gen a error.
08:53:59 <benmachine> does seem we could just disallow float ranges since you can't really rely on them anyway
08:54:05 <Cale> Twey: That is a good question. I've heard people who were adamant that we should all be using interval arithmetic.
08:54:10 <benmachine> listcomps can usually do just as well
08:54:20 <Twey> napsy: â€˜putStrLn fib 5â€™ is calling â€˜putStrLnâ€™ with two arguments, â€˜fibâ€™ and â€˜5â€™
08:54:36 <ray> putStrLn (fib 5)
08:54:50 <Twey> You need to put brackets around them to make the order clear: putStrLn (fib 5)
08:54:56 <napsy> hm I sill get errors
08:55:02 <napsy> *still
08:55:04 <Cale> Twey: It would be really nice if there were a representation of computable reals which was anywhere near as efficient for low-precision tasks.
08:55:04 <Twey> However, fib probably returns a number of some kind, so you'll also want to â€˜showâ€™ it to convert it into a string
08:55:18 <Cale> (like, within a constant factor, even.)
08:55:18 <Twey> putStrLn (show (fib 5))
08:55:40 <Twey> We have a helper function â€˜printâ€™ which is basically just putStrLn . show, so we can write: print (fib 5)
08:55:43 <Cale> and then putStrLn . show = print, so you can use  print (fib 5)
08:55:57 <napsy> oh it works now
08:55:59 <napsy> thanks
08:56:07 <Twey> Also, instead of using brackets, we can use the helper operator ($) to make the order of application clear: print $ fib 5
08:56:24 <Twey> Cale: Hmm
08:56:43 <Jafet> I thought it's just to make Haskell programmers feel better about there never being any jobs offered to them
08:56:45 <Twey> Cale: Performance is the main problem with using reals?
08:57:01 <Cale> Twey: In my experience it is.
08:57:12 <dolio> > chowCReal 1000 pi
08:57:14 <lambdabot>   Not in scope: `chowCReal'
08:57:17 <dolio> > showCReal 1000 pi
08:57:19 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
08:58:01 <Cale> You can compute pi really fast, but take a sum of a few thousand CReals, even if they happen all to be integers, and the result will be a CReal which is really slow.
08:58:28 <Jafet> It'd be interesting to see lots of floating point in Haskell programs. They are notoriously hard to reason about.
08:58:29 <dolio> Yeah, I couldn't remember how slow pi was.
08:58:51 <Cale> > sum [1..1000] :: CReal
08:58:51 <fasta> C:\Users\bar\AppData\Roaming\cabal\Codec-Image-DevIL-0.1\ghc-6.10.4/libHSCodec-Image-DevIL-0.1.a(DevIL.o):fake:(.text+0x121a): undefined reference t                             o `ilDeleteImages@8'
08:58:51 <fasta>  <- any idea about this one?
08:58:55 <lambdabot>   mueval-core: Time limit exceeded
08:59:05 <ray> > sum [1..50] :: CReal
08:59:06 <lambdabot>   1275.0
08:59:08 <malie> is SYB one of the bad words?
08:59:14 <Twey> @index CReal
08:59:15 <lambdabot> bzzt
08:59:17 <Twey> :<
08:59:17 <dolio> Wow, hackage has a library named Numbers and a library named numbers.
08:59:21 <maartenm> isn't the problem with floats just that human maths is 10-base while computers work 2-base
08:59:23 <Cale> malie: What's the problem you seem to be having?
08:59:26 <ray> hmm, that doesn't sound goo
08:59:26 <ray> d
08:59:32 <Twey> Where's CReal defined?
08:59:33 <maartenm> they're basically a device for humans to tlak with computers
08:59:37 <ray> maartenm: that's a lot of it
08:59:40 <maartenm> with quality loss
08:59:50 <Cale> malie: To be honest, I'm not really all that comfortable with SYB, but I can try to help
09:00:01 <ray> it's not as simple as a base-2 fixed point number would be though
09:00:09 <malie> Cale, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4579#a4579
09:00:11 <Twey> maartenm: Yes, and you can represent the numbers in BCD (with some redundancy), but then you get exactly the same problem on things like 1/3
09:00:18 <maartenm> true
09:00:21 <malie> Cale, I can't "special case" tuples
09:00:36 <Twey> maartenm: Most programming languages have a Decimal type (or so) that does that
09:00:44 <Twey> I think we have one in Haskell.  I just can't remember what it's called.
09:00:47 <Jafet> IEEE 754 is actually quite well designed, it preserves many useful properties of R
09:00:48 <malie> Cale, Ambiguous type variable `a' in the constraint: `Data a' arising from a use of `t2' at t3.hs:26:13-14
09:01:07 <benmachine> â„?
09:01:09 <benmachine> :P
09:01:11 <dolio> > sum [1..1000] :: CReal
09:01:15 <lambdabot>   mueval-core: Time limit exceeded
09:01:19 <Twey> Yikes
09:01:21 <maartenm> heh
09:01:21 <Jafet> Showoff.
09:01:23 <dolio> > sum [1..1000] :: Double
09:01:25 <Twey> > sum [1 .. 1000] :: Integer
09:01:25 <lambdabot>   500500.0
09:01:26 <lambdabot>   500500
09:01:29 <Twey> Hmn :-\
09:01:32 <Jafet> > sum [1..100] :: CReal
09:01:33 <lambdabot>   5050.0
09:01:47 <ray> > sum [1..300] :: CReal
09:01:49 <lambdabot>   45150.0
09:01:53 <benmachine> binary search woo
09:02:08 <benmachine> > sum [1 .. 700]
09:02:09 <lambdabot>   245350
09:02:14 <benmachine> oops
09:02:14 <Cale> malie: Okay, what triggers that?
09:02:14 <m0nkfish> so: concatMap f = concat . map f
09:02:19 <benmachine> > sum [1 .. 700] :: CReal
09:02:24 <lambdabot>   mueval-core: Time limit exceeded
09:02:27 <ray> =o
09:02:39 <malie> Cale, as soon as   >`extQ` t2< is not commented
09:02:44 <benmachine> m0nkfish: yep
09:02:58 <Cale> ah, okay
09:03:34 <dolio> > sum [1..10] :: Fixed Prec50
09:03:35 <lambdabot>   Ambiguous occurrence `Fixed'
09:03:35 <lambdabot>  It could refer to either `Data.Fixed.Fixed', ...
09:04:01 <Twey> concatMap = (concat .) . map
09:04:09 <dolio> > sum [1..10] :: Pico
09:04:14 <lambdabot>   mueval-core: Time limit exceeded
09:04:27 <dolio> > [1..10] :: [Pico]
09:04:31 <lambdabot>   [1.000000000000,1.000000000001,1.000000000002,1.000000000003,1.000000000004...
09:04:33 <dolio> Hah!
09:04:41 <m0nkfish> how come 'concatMap = concat . map' doesn't hold?
09:04:49 <Cale> malie: So, it seems like we need an ext2Q
09:04:51 <m0nkfish> i desperately misunderstand currying :(
09:04:53 <zygospasm> > [1,2..10] :: [Pico]
09:04:54 <lambdabot>   [1.000000000000,2.000000000000,3.000000000000,4.000000000000,5.000000000000...
09:04:55 <Cale> malie: but that doesn't exist?
09:04:57 <malie> Cale, which there isn't
09:05:07 <dolio> > sum [1,2..1000] :: Pico
09:05:09 <lambdabot>   500500.000000000000
09:05:28 <benmachine> m0nkfish: just look at the types of (.), concat, and map
09:05:41 <zygospasm> > length ([1..2] :: [Micro])
09:05:42 <lambdabot>   1000001
09:05:49 <benmachine> @type (concat .)
09:05:52 <lambdabot> forall a (f :: * -> *). (Functor f) => f [[a]] -> f [a]
09:06:01 <benmachine> bah.
09:06:09 <Cale> malie: hmm
09:06:13 <jmcarthur_work> :t concat . map
09:06:14 <lambdabot>     Couldn't match expected type `[[a]]'
09:06:14 <lambdabot>            against inferred type `[a1] -> [b]'
09:06:14 <lambdabot>     Probable cause: `map' is applied to too few arguments
09:06:25 <benmachine> :t concat
09:06:26 <lambdabot> forall a. [[a]] -> [a]
09:06:27 <benmachine> :t map
09:06:27 <dolio> augustss' Fixed uses Rational for some reason.
09:06:29 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:06:38 <sproingie> @pointy concatMap = (concat .) . map
09:06:39 <lambdabot> concatMap d g = concat (map d g)
09:06:50 <malie> Cale, thanks still, I'll try the papers ...
09:06:51 <jmcarthur_work> :t let result = (.) in result concat . map
09:06:52 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
09:06:55 <benmachine> map applied to something produces an ([a] -> [b]), which . tries to feed into concat
09:06:57 <m0nkfish> so concat requires a list of lists but map only returns a list
09:06:58 <Cale> malie: It seems crazy to do it, since you'd figure that if this was really the right way then it would already be there in the library, but it shouldn't be hard to parallel the construction of ext1Q from dataCast1 using dataCast2 instead.
09:07:11 <benmachine> but ([a] -> [b]) doesn't match [[a]]
09:07:16 <sproingie> m0nkfish: is the pointy version clearer?
09:07:38 <benmachine> (which is what concat is expecting to see)
09:07:47 <malie> Cale, haven't yet looked at ext1Q's source
09:07:53 <m0nkfish> i understand the function of concatMap but some things are still mystifying to me
09:07:54 <jmcarthur_work> :t (. map)
09:07:55 <lambdabot> forall b a b1. (([a] -> [b1]) -> b) -> (a -> b1) -> b
09:08:24 <sproingie> (concat .) . map is not the most advanced point-free style around but it's still a bit confusing
09:08:41 <m0nkfish> yeah i dont really understand the usage of the dot operator there
09:08:57 <jmcarthur_work> i like to define result = (.) for those cases
09:09:16 <benmachine> I just put the f in :P
09:09:26 <m0nkfish> yeah maybe that is preferable ;)
09:09:37 <sproingie> (concat .) expects a single function, and will compose concat with it
09:10:16 <fasta> Is there a package that does not depend on any C library that computes the convex hull in 2d?
09:10:19 <Cale> malie: okay, I got that to work
09:10:19 <sproingie> imho it's needlessly pointfree notation
09:10:26 <benmachine> so give f to map and you get a single function [a] -> [b]
09:10:33 <benmachine> which then gets fed to (concat .)
09:10:34 <Cale> ghci> gpp (1,2)
09:10:34 <Cale> (1, 2)
09:10:57 <benmachine> which then forces b to be [a]
09:11:14 <sproingie> i wonder if it'd look nicer with applicative
09:11:16 <benmachine> and concats the resulting [[a]] into [a]
09:11:35 <sproingie> gotta go, no time to experiment with that
09:12:00 <Cale> malie: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4579#a4580
09:12:10 <m0nkfish> why does it force b to be [a] :(
09:12:21 <m0nkfish> doesnt it depend on the function
09:12:49 <benmachine> yes
09:12:56 <benmachine> it depends on the function concat
09:13:01 <benmachine> oh
09:13:02 <benmachine> wait
09:13:07 <benmachine> it forces it to be [c] sorry
09:13:14 <benmachine> concat wants a list of lists
09:13:16 <malie> Cale, thanks
09:13:19 <benmachine> so b has got to be a list
09:13:56 <m0nkfish> essentially i dont see why you can omit the list itself but not the function
09:14:04 <m0nkfish> (in the definition that includes f)
09:14:22 <m0nkfish> concatMap f l = concat . map f l
09:14:26 <m0nkfish> concatMap f = concat . map f
09:14:39 <m0nkfish> to me it seems that you should be able to reduce further in the same way
09:14:57 <Cale> oh, but that first equation was wrong
09:15:04 <dolio> concatMap f l = (concat . map f) l
09:15:31 <dolio> "concat . map f l" is something else (a type error).
09:15:42 <Cale> concatMap f l = concat (map f l) = concat ((map f) l) = (concat . map f) l
09:15:49 <Cale> (if more steps would help)
09:16:10 <BONUS> find (concat .) . map easier to understand if you write it as ((.).(.)) concat map and treat (.) as unary
09:16:11 <Cale> and now you can cancel the l's
09:16:12 <Twey> :t concatMap
09:16:13 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
09:16:19 <Twey> :t (concat .) . map
09:16:20 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
09:16:23 <zygospasm> m0nkfish: concatMap f = concat . map f => concatMap f l = (concat . map f) l = concat (map f l)
09:16:29 <Cale> :t fmap concat . map
09:16:30 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
09:16:30 <Twey> Hum.  Not quite the same.
09:16:38 <Twey> Ah
09:16:42 <dolio> Yes, and then: concat . map f = (concat .) (map f) = ((concat .) . map) f
09:16:43 <BONUS> :t (fmap.fmap) concat map
09:16:44 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
09:16:48 <Twey> Wait
09:17:04 <Twey> I thought (concat .) \equiv fmap concat
09:17:18 <Cale> it is
09:17:31 <Twey> Oh!
09:17:32 <Twey> Yes
09:17:38 <Twey> Just confusing type names.  I see.  â˜º
09:17:42 <dolio> > succ . [1..10]
09:17:44 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
09:18:22 <BONUS> wait, what
09:18:24 <m0nkfish> ok i will come back to this another day when my head is less exploded
09:18:27 <Cale> :t lines . getContents
09:18:28 <lambdabot> IO [String]
09:18:44 * benmachine still thinks <$> is better
09:18:46 <BONUS> > succ . [1..10]
09:18:48 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
09:18:56 <Cale> m0nkfish: If you're confused by our generalised (.), it's been redefined in lambdabot :)
09:19:04 <BONUS> :t (.)
09:19:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:19:08 <Twey> benmachine: (concat <$>) . map?
09:19:10 <BONUS> ah
09:19:12 <m0nkfish> i thought i understood function composition lol
09:19:15 <Twey> How is that better than (concat .) . map?  :Ã¾
09:19:15 <m0nkfish> evidently not :<
09:19:15 <BONUS> . is <$> here
09:19:29 <Cale> m0nkfish: Well, sections of function composition are still a bit complicated
09:19:41 <Cale> m0nkfish: Let's try applying (concat .) . map to some parameters
09:19:43 <benmachine> Twey: I mean in reference to lines . getContents and friends
09:19:48 <Twey> Aha
09:19:54 <Cale> m0nkfish: ((concat .) . map) f l
09:20:10 <Twey> Yes.  â˜º
09:20:13 <Cale> = (concat .) (map f) l
09:20:26 <malie> @src (.)
09:20:27 <lambdabot> (f . g) x = f (g x)
09:20:27 <Cale> = (concat . map f) l
09:20:42 <Cale> = concat (map f l)
09:20:44 <Twey> = concat $ map f l
09:20:47 <Twey> Hehe.
09:21:07 <Cale> malie: In lambdabot right now, it's (.) = fmap
09:21:22 <Cale> malie: With the instance of fmap for functions providing normal function composition :)
09:22:22 <Cale> fmap :: (a -> b) -> (f a -> f b)
09:22:47 <Cale> when f = (->) e, that becomes  fmap :: (a -> b) -> ((e -> a) -> (e -> b))
09:22:56 <Cale> which of course must be function composition :)
09:23:17 <m0nkfish> so is $ the same as .
09:23:25 <Cale> No, $ is different
09:23:40 <Cale> f $ x = f x
09:23:59 <m0nkfish> f . g = f g
09:24:00 <Cale> It takes a function and a parameter for that function and just applies the function to the parameter
09:24:00 <m0nkfish> ?
09:24:06 <Cale> (f . g) x = f (g x)
09:24:15 <m0nkfish> ah ok
09:24:28 <Cale> Composition takes two functions, and sticks them together into a new function which does one following the other
09:24:29 <m0nkfish> cale your example up there ^ makes sense to me :)
09:24:41 <m0nkfish> where you gradually phased out composition
09:24:50 <Cale> yeah
09:24:58 <Cale> I tried to stick to the plain definition
09:25:11 <m0nkfish> Cale » = (concat .) (map f) l
09:25:16 <m0nkfish> why is the concat in brackets here?
09:25:27 <m0nkfish> is that the same as concat . (map f) l
09:25:29 <Cale> (concat .) is an operator section
09:25:38 <Cale> (concat .) f = concat . f
09:26:01 <Twey> (.) concat (map f) l
09:26:08 <Cale> It's not the same as concat . map f l, because that would be a type error
09:26:23 <Cale> But it is the same as (concat . map f) l
09:26:54 <Cale> Note that  (concat .) (map f) l  really means  ((concat .) (map f)) l
09:27:00 <m0nkfish> ahhhhh ok
09:27:06 <m0nkfish> i think that is where i was getting stuck
09:27:12 <Cale> Because  f x y z  always really means  ((f x) y) z
09:27:21 <m0nkfish> yes i see left-association
09:27:36 <Twey> (((.) concat) (map f)) l
09:27:48 * Twey finds it less confusing to think of operators as functions, often.
09:28:19 <BONUS> (.) takes a function and transforms it to a function that operates on results of functions
09:28:25 <Cale> :)
09:28:37 * Cale wonders if he should upgrade to Ubuntu 9.10
09:28:53 * Twey wonders if he should upgrade his mother to Fedora 12.
09:28:58 <Cale> I always end up upgrading too soon, and end up with a flaky system for a few weeks.
09:29:05 <Twey> Yeah.  Probably best to leave it.
09:29:19 <flux> I'm waiting for my current important projects to finish befere doing it :)
09:29:23 <Cale> Oh, but I will grab the new rc of deluge :)
09:29:41 <Twey> Huh, new BitTorrent client.
09:29:55 <BONUS> i like that. so then if you have ((.).(.)) concat, we first upgrade concat to operate on functions and get (a -> [[b]]) -> (c -> [b]) and then if you (.) that again you get (a -> a' -> [[b]]) -> (c -> c' -> [b])
09:29:57 <BONUS> that's it! :D
09:30:01 <Twey> Oh, that's nice
09:30:25 <Twey> (torrent client and ((.) . (.)) explanation both)
09:30:33 <BONUS> haha
09:30:53 <Cale> Yeah, I find it simpler to think of ((.).(.)) as a special case of (fmap . fmap)
09:31:09 <BONUS> ya imo2
09:32:06 <zygospasm> @type (?torrent ?client and ((.) . (.)) ?explanation ?both)
09:32:08 <lambdabot> forall t t1 t2 t3 (f :: * -> *) a b (f1 :: * -> *). (?torrent::t -> ([Bool] -> Bool) -> ((a -> b) -> f (f1 a) -> f (f1 b)) -> t1 -> t2 -> t3, ?client::t, Functor f, Functor f1, ?explanation::t1, ?
09:32:08 <lambdabot> both::t2) => t3
09:32:48 <conal> also handy as a special case of (result.result) (deep-arrow rather than functor)
09:34:11 <sproingie> Cale: i'm running 9.10, have had no problems.  one's an upgrade from 9.06, the other's a fresh install
09:34:43 <malie> what's the reason to write ((->)a) instead of (a->)
09:34:52 <sproingie> (a->) isn't valid syntax
09:34:54 <BONUS> no syntax support
09:35:05 <BONUS> for sectioned type things
09:35:12 <malie> ok
09:35:40 <BONUS> i'd like implicit type parameters like
09:35:40 <Cale> sproingie: Cool, so maybe they got it right this time. :)
09:35:47 <conal> malie: my guess is that people would see (a ->) and assume they could write (-> b), which leads the compiler's type pattern-matching from 1st order to higher-order.
09:35:54 <Cale> sproingie: My last few Ubuntu upgrades seemed to be getting worse and worse.
09:36:02 <BONUS> instance Monad (r -> ?a) where ..
09:36:04 <sproingie> Cale: it's linux, so as always it depends on your hardware
09:36:09 <BONUS> that would decrease the need for a lot of newtypes
09:36:37 <sproingie> nvidia drivers never detected on my laptop, i had to use envyNG to install them
09:36:39 <BONUS> like, instance Monoid w => Monad (?a, w) where
09:36:41 <BONUS> etc.
09:37:19 <sproingie> then again windows 7 didn't offer the nvidia driver via update either, so i blame nvidia
09:37:19 <zygospasm> Cale: i've found that Ubuntu likes to be installed clean rather than upgraded
09:37:50 <sproingie> if you've installed a lot of gnome stuff, a fresh install is best
09:37:55 <malie> zygospasm, but it can keep your /home even if it's on the same partition
09:37:57 <Nafai> zygospasm: odd.  I've never had problems with the upgrade.
09:37:57 <luite> hm, I also had some issues with the nvidia drivers when upgrading to 9.10
09:37:59 * benmachine forgot to upgrade while he was at home and isn't keen on chewing all the way through his university bandwidth quite yet
09:38:15 <Nafai> I'm on my fourth upgrade on the same original install
09:38:15 <luite> I mean after upgrading
09:38:24 <zygospasm> malie: yeah. the clean-install-but-keep-my-/home is a really nice feature of the installer
09:38:36 <benmachine> if at any time my computer is completely working I tend to take it as a sign I'm not trying hard enough
09:38:55 <Nafai> benmachine: heh
09:39:03 <zygospasm> Nafai: i've had all sorts of problems. xorg.conf hacks stopped working, the transition to upstart went wrong, pulseaudio broke my audio output, ...
09:39:38 <quicksilver> the precise moment that people started recommending installing linux from scratch to solve problems was when everything started going irretrievably wrong.
09:39:42 <kmc_> lambdabot, messages for me?
09:39:50 <quicksilver> reinstalling the OS should never be the right solution to any problem.
09:40:01 <zygospasm> Nafai: and yet i have one Ubuntu machine which has been upgraded in steps all the way from Breezy to Karmic and has never had any problems :)
09:40:07 <kmc_> @nixon
09:40:07 <lambdabot> I played by the rules of politics as I found them.
09:40:11 <Nafai> zygospasm: weird :(
09:40:13 <quicksilver> this machiine has been upgraded all the way from debian 2.0, IIRC
09:40:24 <quicksilver> which involved two major libc upgrades in place
09:40:55 <benmachine> nice thing about arch is that upgrades tend to be more incremental
09:40:56 <Cale> quicksilver: Protip: Never hit ctrl-C in the middle of a libc upgrade.
09:40:58 <zygospasm> quicksilver: if you go on to say you've upgraded from x86 to x86_64 i'll be really impressed ;-)
09:41:03 <benmachine> so you don't tend to break things all at the same time
09:41:41 <KaLPo> I have a problem with quickCheck
09:41:53 <KaLPo> everytime I load a file
09:41:55 <KaLPo> I get
09:42:18 <KaLPo> Warning: No explicit method nor default method for Test.QuickCheck.coarbitrary
09:42:30 <KaLPo> In the instance declaration for Arbitrary Prop
09:42:58 <Cale> KaLPo: That would be because there's no implementation of coarbitrary in your instance.
09:43:21 <KaLPo> I know, but it has to be something with quickCheck
09:43:41 <KaLPo> because I have run the same code in another machine and it worked without warnings
09:43:42 <Cale> Which version of QuickCheck are you using?
09:44:00 <Cale> coarbitrary was split into its own class in newer versions
09:44:14 <KaLPo> I dont know
09:44:24 <Cale> ghc-pkg list QuickCheck
09:45:09 <KaLPo> 1.2.0.0
09:45:16 <Cale> okay, so that's the old version
09:45:24 <KaLPo> how can I upgrade it?
09:45:32 <Cale> Do you have cabal install?
09:45:43 <Cale> Try  cabal install QuickCheck
09:45:46 <KaLPo> yes
09:46:10 <Cale> and if it complains that it's already installed,  cabal install QuickCheck-2.1.0.2
09:46:15 <KaLPo> All the requested packages are alredy installed
09:46:21 <dcoutts> Cale: you need to use cabal install 'quickcheck >= 2'
09:46:21 <KaLPo> ok
09:46:32 <dcoutts> since the default version is still 1.2.x
09:46:57 <KaLPo> looks doing fine
09:47:07 <KaLPo> Ok
09:47:12 <KaLPo> thanks
09:47:18 <KaLPo> let see if this works now
09:53:58 <PeakerWork> its a bit sad that the optimizer doesn't eat monad transformers too well, that people need stuff like RWS combinations
09:54:07 <KaLPo> yes, it works
09:54:07 <KaLPo> thank you
09:54:10 <PeakerWork> the opposite of code composability/re-use
09:55:20 <Baughn> Is there any way I can look up a typclass function by, um, type name? At runtime?
09:55:28 <Baughn> ..yeah, I know that's an awful thing to do. I still want to.
09:56:04 <Baughn> (Specifically, trying to Show a type that may or may not be an instance of Show)
09:56:25 <spink> hi, does anyone know if DiffU arrays are any faster thatn STU Arrays in term of mutations ;
09:56:47 <Baughn> spink: Diff is generally the slowest arrays around, by any measure. IntMap is faster.
09:57:21 <Baughn> spink: If you want speed, you may want to look up storablevector
09:57:51 <spink> Thanks Baughn, I'm going to check those 2
09:58:07 <Baughn> spink: IntMap isn't even an array type. It /is/ fast, though
09:59:27 <spink> Baughn, to tell you the truth I was using STU Arrays for an algo I am writing and it goes fast but I was searching to see if there is something faster
10:00:29 <PeakerWork> Baughn: why can't you know it is Showable?
10:01:31 <PeakerWork> Baughn: with overlapping+flexible instances and yucky things maybe you can have a HasShow class that returns True for Showables and False otherwise (and has an instance for all types), + unsafeCoerce, yuck
10:01:40 <Apocalisp> Sheesh. Is there a better way to say: maybe Nothing (maybe (Just "foo") (const Nothing) . find (> 10))
10:02:15 <Apocalisp> hang on
10:02:18 <Apocalisp> @type maybe Nothing
10:02:20 <lambdabot> forall a a1. (a1 -> Maybe a) -> Maybe a1 -> Maybe a
10:02:25 <Apocalisp> ah hah!
10:02:28 <Baughn> PeakerWork: I don't even have the type, really. Let's see..
10:03:15 <Baughn> PeakerWork: I've got a ByteString which I know is an instance of Binary, and a textual (via show) representation of its typeOf.
10:03:15 <DrSyzygy> The whole 'monads are sequencing' meme, can that be derived from the categorical viewpoint?
10:03:31 <Baughn> PeakerWork: And.. yeah... I want to show that. If it happens to be an instance of Show.
10:04:10 <Apocalisp> (maybe (Just "foo") (const Nothing) . find (> 10) =<<)
10:04:28 <Baughn> PeakerWork: This /would/ be trivial in common lisp, you know. :P
10:06:18 <Cale> Apocalisp: You could have invented the Maybe monad! ;)
10:06:28 <PeakerWork> Baughn: I am not sure it would work, but maybe:  class HasShow a where hasShow :: a -> Bool ; instance Show a => HasShow a where hasShow _ = True ; instance HasShow a where hasShow _ = False :-)
10:06:31 <Apocalisp> Cale: maybe.
10:06:31 <Baughn> @type runMaybeT
10:06:32 <lambdabot> Not in scope: `runMaybeT'
10:07:08 <Baughn> PeakerWork: No.. that should work, actually, if I understand the type system right
10:07:20 <Baughn> PeakerWork: Um..
10:07:24 * Baughn probably doesn't.
10:09:23 <PeakerWork> Baughn: apparently it refuses because of the same head, even though overlapping instances is on
10:10:38 <Baughn> PeakerWork: hen matching, GHC takes no account of the context of the instance declaration <-- ;_;
10:13:58 <PeakerWork> Baughn: yeah, overlaps are allowed between more general/more specific types, not between same heads
10:16:51 * lispy never noticed that anagram before
10:18:28 <zygospasm> , [w | w <- words, sort w == "aelmnt"]
10:18:31 <lunabot>  luna: Couldn't match expected type `[t]'
10:18:34 <byorgey> DrSyzygy: well, a monad is just a monoid in the appropriate category, and monoids are sequencing... ?
10:21:15 <DrSyzygy> byorgey: It really is that simple?
10:21:34 <byorgey> DrSyzygy: I don't know, isn't it?
10:21:38 <DrSyzygy> byorgey: I've been trying to put words on that for a while now, and haven't gotten it to look good.
10:21:44 <byorgey> DrSyzygy: I don't particularly buy into the "monads are sequencing" meme anyway
10:21:58 <DrSyzygy> byorgey: So maybe the right thing for me to do is to _not_ perpetuate it. :-)
10:22:08 <shellsage> blackh, you around?
10:23:19 <lispy> Something that always gets me about monads is I find myself wanting to do, join g (f `fmap` x)
10:23:29 <lispy> Then I have to remember that is bind
10:23:50 <byorgey> DrSyzygy: the problem is that many people seem to think that monads are what let you determine the order in which things should happen
10:23:55 <zygospasm> , [w | w <- dict, sort w == "aelmnt"]
10:23:56 <PeakerWork> a function that takes  m a    and (a -> m b)   and then fuses the (m a) and (m b) together into an (m b)  seems to be fusing/collapsing  action (m a), then pure computation (a -> m b), and then action (m b)   into one single action..  -- is this not sequencing?
10:23:58 <byorgey> DrSyzygy: but it isn't monads that do that, it's data dependencies.
10:24:01 <lunabot>  Killed.
10:24:16 <zygospasm> , [w | w <- dict, sort w == "aelmnt"]
10:24:21 <lunabot>  ["lament","manlet","mantel","mantle","mental"]
10:24:37 <byorgey> DrSyzygy: consider for example Cont, or that crazy reverse-state-time-travel monad.
10:25:33 <PeakerWork> where's the reverse state monad? How does it work?   (m a -> (a -> m b) ...) kind of forces the ordering between (m a) and (m b)
10:25:59 <byorgey> DrSyzygy: so in my opinion the sense in which 'monads are about sequencing' is no more (and no less) interesting than the sense in which monoids are about sequencing.
10:26:19 <zygospasm> PeakerWork: it's a special case of the fifo monad :)
10:26:23 <byorgey> that is, they are about sequencing on a *semantic* level but not an *operational* level.
10:26:29 <PeakerWork> zygospasm: what's the fifo monad?
10:26:56 <zygospasm> PeakerWork: you have a push operation and a pop operation. the nth pop returns the value given to the nth push
10:27:24 <byorgey> and you can pop before you push! =D
10:28:03 <zygospasm> PeakerWork: really it's just a combination of a writer and a supply monad, with the loop tied by the run function
10:28:15 <tdrgabi> hi everybody. i'm trying to learn haskell but I'm struggling with this compilation error for two hours. http://haskell.pastebin.com/d210eeae7 What did I do wrong?
10:28:23 <PeakerWork> zygospasm: say you have   (get >>= (\x -> if x == 0 then put 1 else put 0)) what happens?
10:28:37 <PeakerWork> zygospasm: time-paradox? :-)
10:28:41 <zygospasm> PeakerWork: well that's _|_ :)
10:28:59 <PeakerWork> zygospasm: oh its a MonadFix-alike kind of thing?
10:29:00 <tdrgabi> i imagined that because solveRPN get's a string and I used the x:xs pattern, xs would also be a String
10:29:21 <zygospasm> tdrgabi: (a, b) creates a tuple, and isnt' part of the function call syntax
10:29:43 <zygospasm> tdrgabi: so you should have: solveRPN (x:xs) = _solveRPN xs [read [x]]
10:29:44 <byorgey> tdrgabi: first, you call functions of multiple arguments in Haskell like this:  f x y  not like this:  f(x,y)
10:30:12 <tdrgabi> zygospasm: byorgey: thank you, will try your suggestions
10:30:18 <Baughn> (Except when you do. Both ways are supported, kind of; the former is just much more common)
10:31:07 <zygospasm> Baughn: well, the latter wouldn't be callign a function of multiple arguments. but there are no functions of mulitple arguments, so... ;-)
10:31:20 <byorgey> tdrgabi: and yes, you are correct that if  (x:xs) is a String, then xs is also a String
10:31:46 <zygospasm> tdrgabi: it's not entirely easy to understand what GHC's type errors are telling you sometimes
10:32:03 <Baughn> zygospasm: Heh. Physically speaking, you're right; in f :: a -> b -> c, f never even starts running before both a and b are present
10:32:26 <zygospasm> tdrgabi: in this case it's saying that _solveRPN expected its first argument to be of type String, but when you called it, you gave it a first argument of type (String, [a])
10:32:32 <Baughn> Er. Physically speaking, you're /wrong/, I meant. ^^;
10:32:52 <Baughn> (a,b) is a single parameter, a -> b -> c is definitely two
10:33:19 <tdrgabi> zygospasm: I understood, it was because of the come, he took it as a tuple instead. thank you again, it works now
10:33:27 <zygospasm> > let f a = undefined `seq` (\b -> 42) in f 10 `seq` True
10:33:27 <tdrgabi> zygospasm: *coma
10:33:28 <lambdabot>   * Exception: Prelude.undefined
10:33:46 <zygospasm> Baughn: ^^ some parts of f can run before it gets all its arguments ;-)
10:33:58 <Cale> Sometimes functions of type a -> b -> c can do some work after getting just their first parameter
10:34:03 <Baughn> zygospasm: Not if it's defined like "f a b = ..."
10:34:20 <Baughn> Wait..
10:34:22 <Cale> f a = let ... in \b -> ...
10:34:26 <Baughn> ...right.
10:34:35 <zygospasm> Baughn: sure, but you said "in f :: a -> b -> c" :) if i'm gonna be wrong i'm taking you down with me! :D
10:35:04 <Baughn> zygospasm: Ah, but /that/ a -> b -> c is actually a a -> (b -> c). ^_^
10:35:07 <Cale> Normally GHC won't lift definitions in such a way that they split up adjacent lambda abstractions.
10:35:14 <Cale> But it could.
10:35:45 <Cale> (Whether it would be advisable for it to do this is another matter)
10:35:57 <zygospasm> Cale: that isn't enough for extra work to be allowed when f gets its first argument, unless that extra work is provably terminating
10:36:30 <Cale> zygospasm: If f x is undefined, then surely f x y will be as well.
10:36:39 <zygospasm> Cale: f x y might never happen.
10:36:55 <Cale> Well, true.
10:36:57 <DrSyzygy> byorgey: Gotcha.
10:37:06 <Cale> seq makes the picture a little bit messy
10:37:16 <DrSyzygy> (delayed reaction, since my wikiediting happens strictly disjoint from IRC)
10:37:21 <Cale> But I don' the behaviour of seq on functions
10:37:22 <Cale> er
10:37:39 <Cale> But I don't think the behaviour of seq on functions should govern how the rest of the language works :)
10:38:12 <Cale> (It's debatable whether seq should even be a valid thing to apply to functions)
10:38:48 <byorgey> DrSyzygy: hehe, no problem =)  How's the class going, by the way?
10:39:09 <shellsage> byorgey, can you give me a hand identifying any obvious issues you see with my changes here:  http://pastebin.com/d76bba631
10:39:28 <byorgey> shellsage: sure, let me take a look
10:39:32 <shellsage> byorgey, thanks
10:39:49 <shellsage> byorgey, I'm trying to remove count altogether, and make the count managed by the State monad
10:40:07 <Cale> shellsage: You *desperately* need to define a State monad computation which just increments the state :)
10:40:15 <shellsage> Cale, I know, I can't figure out how
10:40:38 <Cale> inc = do count <- get; put (count + 1); return count
10:40:53 <shellsage> Cale, I just define that at the top and then call inc everywhere?
10:40:54 <byorgey> shellsage: sure, you should just be able to change all the (a,t)'s in the types to  t
10:40:54 <PeakerWork> for counters, use Writer monad with (Sum) newtype no?
10:40:59 <Cale> shellsage: yeah
10:41:09 <PeakerWork> if you don't need to read the counter..
10:41:19 <byorgey> PeakerWork: shellsage does need to read the counter.
10:41:33 <benmachine> get >>= put . succ
10:41:48 <shellsage> byorgey, I think LExpr is still defined for a, t
10:41:51 <shellsage> I can't change LExpr
10:41:59 <benmachine> gets (+1) >>= put
10:42:04 <byorgey> shellsage: ok, maybe
10:42:05 <benmachine> the possibilities are endless
10:42:06 <Baughn> shellsage: You could also write that as 'modify succ'
10:42:12 <benmachine> oh yeah modify
10:42:13 <benmachine> even better
10:42:29 <shellsage> Baughn, what does that do
10:42:35 <byorgey> @type modify
10:42:36 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
10:42:47 <byorgey> it takes a function which it applies to the old state to make a new state
10:42:53 <Baughn> shellsage: modify f = get >>= put . f
10:42:58 <byorgey> so 'modify succ' means 'add one to the state'
10:43:03 <shellsage> ok
10:43:17 <Baughn> shellsage: 'succ' is just a more general version of (+1), by the way
10:43:25 <Baughn> > succ . "HAL"
10:43:26 <lambdabot>   "IBM"
10:43:36 <benmachine> :O
10:43:53 <byorgey> Baughn: shame on you! don't confuse newbies with Caleskell
10:43:53 <shellsage> Baughn, I want to get the two values back still
10:44:04 <shellsage> so can I do: inc = do count <- get; put (count + 1); return (count, count + 1)
10:44:09 <shellsage> and then
10:44:15 <shellsage> (count, newCount) <- inc
10:44:15 <shellsage> ?
10:44:21 <byorgey> shellsage: sure!
10:44:22 <Twey> succ increments enums
10:44:26 <shellsage> ok cool
10:44:28 <dolio> > succ (maxBound :: Int)
10:44:29 <Baughn> shellsage: Well, sure, that should work
10:44:30 <lambdabot>   * Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
10:44:38 <byorgey> shellsage: but why do you need (count, count + 1)?  can't you just compute one from the other?
10:44:38 <Twey> Hehe, it's clever
10:44:50 <shellsage> byorgey, yeah, but I wanted to keep it as a one liner
10:45:12 <shellsage> so I'm pasting less code
10:45:13 <Baughn> > second succ $ join (,) $ 2
10:45:14 <lambdabot>   (2,3)
10:45:21 <byorgey> shellsage: ?  I mean just do   newCount <- inc    and then wherever you had 'count' just use 'newCount - 1'
10:45:32 <byorgey> or something like that
10:45:34 <benmachine> (,) <*> succ $ 2
10:45:34 <shellsage> byorgey, ah, yeah I could do that
10:45:37 <benmachine> > (,) <*> succ $ 2
10:45:39 <lambdabot>   (2,3)
10:45:40 <byorgey> it doesn't really matter that much I guess =)
10:46:05 <Twey> > id &&& succ $ 2
10:46:06 <lambdabot>   (2,3)
10:46:15 <Cale> shellsage: Are you certain that you ever need both? Usually if you're just using it to generate fresh names or something, you should only need one of the two
10:46:16 <Baughn> > (,) . succ $ 42
10:46:18 <lambdabot>   {()->(43,())}
10:46:25 <Twey> Woah
10:46:27 <Twey> What's *that*?
10:46:30 <byorgey> hehe, awesome
10:46:30 <Baughn> Ha. Caleskell fail
10:46:42 <benmachine> some silly function show
10:46:43 <Twey> > succ 42
10:46:43 <byorgey> Twey: a show instance for functions!
10:46:44 <lambdabot>   43
10:46:44 <Baughn> Incoherent instances, I think. :P
10:46:46 <Twey> Ohh
10:46:48 <byorgey> > succ
10:46:49 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
10:46:52 <Twey> Interesting
10:46:55 <byorgey> > show succ
10:46:56 <lambdabot>   "* Exception: Prelude.Enum.().succ: bad argument
10:47:00 <Cale> Baughn: huh? It's just doing normal function composition there.
10:47:01 <Twey> Haha
10:47:04 <byorgey> hrmph
10:47:05 <Baughn> > const (succ 42) :: Expr
10:47:05 <shellsage> Cale, actually I think you're right
10:47:06 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
10:47:06 <lambdabot>         against inferred ...
10:47:10 <Twey> > (+2)
10:47:11 <lambdabot>   {-3->-1;-2->0;-1->1;0->2;1->3;2->4;3->5}
10:47:11 <byorgey> , succ
10:47:13 <lunabot>  luna: No instance for (GHC.Show.Show (a -> a))
10:47:17 <Twey> It maps?
10:47:17 <Baughn> Cale: How come substituting <$> for . didn't give me the same result?
10:47:25 <Baughn> > succ <$> (,) $ 2
10:47:26 <lambdabot>   No instance for (GHC.Enum.Enum (b -> (a, b)))
10:47:26 <lambdabot>    arising from a use of `GHC...
10:47:41 <Baughn> ..er. Wait. He used <*>. My bad.
10:47:45 <con> let - = +
10:47:52 <Baughn> @let (-) = (+)
10:47:53 <lambdabot>  Defined.
10:47:55 <Cale> Yeah, I was about to ask
10:47:57 <Cale> ;)
10:48:05 <con> 4+4
10:48:07 <Cale> > (,) <$> succ $ 42
10:48:08 <lambdabot>   {()->(43,())}
10:48:21 <benmachine> Baughn: unfortunately not as fun as it sounds
10:48:23 <benmachine> because
10:48:25 <benmachine> > 4 - 3
10:48:26 <lambdabot>   Ambiguous occurrence `-'
10:48:27 <lambdabot>  It could refer to either `L.-', defined at <local...
10:48:34 <Cale> con: If you want lambdabot to evaluate something you need to put "> " before it
10:48:41 <Asztal> > (=<<) :: (a -> [a]) -> [a] -> [a] -- it generates arbitrary functions too?
10:48:41 <Baughn> > 4 L.- 3
10:48:42 <lambdabot>   {()->[]}->
10:48:42 <lambdabot>    {[]->[];[()]->[];[(),()]->[];[(),(),()]->[]}
10:48:42 <lambdabot>  {()->[()]}->
10:48:42 <lambdabot>   ...
10:48:42 <lambdabot>   7
10:48:50 <con> thanks
10:48:54 <benmachine> > let a - b = a + b in 3 - 2
10:48:55 <lambdabot>   5
10:49:04 <Baughn> @undefine
10:49:08 <con> > let x = 20
10:49:09 <lambdabot>   not an expression: `let x = 20'
10:49:19 <con> > @let x = 20
10:49:20 <lambdabot>   <no location info>: parse error on input `@'
10:49:20 <Baughn> > x + 20
10:49:21 <lambdabot>   x + 20
10:49:25 <tommd> @let x = 20
10:49:26 <lambdabot>  Defined.
10:49:33 <tommd> > x + 20
10:49:34 <lambdabot>   Ambiguous occurrence `x'
10:49:34 <lambdabot>  It could refer to either `L.x', defined at <local...
10:49:36 <Cale> > L.x
10:49:37 <lambdabot>   20
10:49:43 <Baughn> @undefine
10:49:45 <tommd> Yeah, that
10:49:50 <tommd> > L.x + 20
10:49:54 <Baughn> > iterate f x
10:49:54 <lambdabot>   Not in scope: `L.x'
10:49:56 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
10:49:57 <tommd> damn that undefine
10:50:05 <shellsage> byorgey, in my new beta function, why is the line: return $ (expr, tf)  giving me a Parse error in pattern?
10:50:06 <Cale> Try to stay away from @let'ing single-letter names, because they're all taken by simplereflect
10:50:22 <Baughn> > iterate x x
10:50:22 <tommd> ah, I see.
10:50:25 <lambdabot>   Couldn't match expected type `a -> a'
10:50:29 <lambdabot>         against inferred type `Simple...
10:50:32 <Baughn> > iterate x f
10:50:33 <lambdabot>   Couldn't match expected type `a -> a'
10:50:34 <lambdabot>         against inferred type `Simple...
10:50:34 <benmachine> > expr $ iterate f f
10:50:35 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
10:50:37 <lambdabot>         against inferred ...
10:50:41 <benmachine> oh
10:50:44 * DrSyzygy grumbles.
10:50:46 <benmachine> > map expr $ iterate f f
10:50:48 <lambdabot>   [f,f f,f (f f),f (f (f f)),f (f (f (f f))),f (f (f (f (f f)))),f (f (f (f (...
10:50:58 <Baughn> > expr . iterate f f
10:50:59 <lambdabot>   [f,f f,f (f f),f (f (f f)),f (f (f (f f))),f (f (f (f (f f)))),f (f (f (f (...
10:51:17 <DrSyzygy> If A+B is a coproduct of A, B; there is Haskell-wise an easy construction to map A+B+B -> A+B : you just 'fuse' the constructors for the equal summands.
10:51:17 <benmachine> > f ()
10:51:18 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:51:19 <lambdabot>    `GHC.Show.Show a'
10:51:19 <lambdabot>      a...
10:51:19 <Baughn> > iterate f f
10:51:20 <lambdabot>   Ambiguous type variable `a' in the constraints:
10:51:20 <lambdabot>    `GHC.Show.Show a'
10:51:20 <lambdabot>      a...
10:51:23 <benmachine> > expr $ f ()
10:51:25 <lambdabot>   f ()
10:51:27 <DrSyzygy> I wonder whether there is a good way to describe this categorically.
10:51:32 <benmachine> > expr $ f id
10:51:34 <lambdabot>   f {()->()}
10:51:43 <benmachine> > expr $ f . id
10:51:44 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
10:51:44 <lambdabot>         against inferred ...
10:51:53 <benmachine> > f . id :: Expr -> Expr
10:51:55 <lambdabot>   No instance for (Test.SmallCheck.Serial SimpleReflect.Expr)
10:51:55 <lambdabot>    arising from...
10:51:58 <benmachine> aw
10:52:10 <byorgey> shellsage: it is expecting another branch of the case expression there
10:52:21 <FunctorSalad> DrSyzygy: Left ||| Right ||| Right
10:52:28 <shellsage> byorgey, oh, so I gotta tab out
10:52:30 <DrSyzygy> FunctorSalad: What do you mean by |||?
10:52:42 <benmachine> :t (|||)
10:52:43 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
10:53:02 <DrSyzygy> Oh wait... this is the induced map from the coproduct given maps on each?
10:53:04 <benmachine> :t Left ||| Right ||| Right
10:53:05 <lambdabot> forall b b1. Either b (Either b1 b1) -> Either b b1
10:53:16 <Baughn> @type (|||)
10:53:17 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
10:53:18 <FunctorSalad> DrSyzygy: (|||) from Arrow, which happens to be the adjoint isomorphism of the coproduct adjunction
10:53:33 <byorgey> shellsage: well, I'm not sure what you need to do... that 'return' seems strange.
10:53:33 <Baughn> FunctorSalad: That what what of the what?
10:53:44 * benmachine agrees with Baughn 
10:53:48 <con> Can anybody give me a little help, i need to write a function to insert an integer into a list then reverse it
10:53:50 <shellsage> byorgey, I'm trying to get my beta function to return (LExpr, Bool)
10:54:01 <FunctorSalad> Baughn: you have categories Hask, and Hask * Hask
10:54:07 <shellsage> byorgey, and in do notation, I need a return, yes?
10:54:10 <con> its got to be recursive and i'm having a lot of trouble withit
10:54:12 <DrSyzygy> FunctorSalad: Gotcha.
10:54:15 <FunctorSalad> you have a functor Hask -> Hask * Hask, which takes the diagonal
10:54:16 <Baughn> FunctorSalad: ..no, I don't believe I do. Don't bother. ;_;
10:54:16 <byorgey> shellsage: probably in each of the case branches you need to add a 'return' before the results, like  (Proc parm body, _) -> return (expr, True)
10:54:26 <byorgey> shellsage: and then get rid of the 'return $ (expr, tf)'
10:54:31 <FunctorSalad> this functor has a left adjoint: the coproduct
10:54:43 * DrSyzygy groans. And of course, I haven't talked about products and coproducts as adjoints. >.<
10:54:45 <byorgey> shellsage: I'm not 100% sure though, I haven't looked at it carefully enough...
10:54:46 <shellsage> byorgey, how do I add the return after the where statement
10:54:55 <FunctorSalad> DrSyzygy: :)
10:55:00 <byorgey> shellsage: sorry, I need to go right now, hopefully someone else can continue helping you
10:55:01 <shellsage> byorgey, wouldn't it be considered another case if it was the same tab level?
10:55:07 <shellsage> byorgey, ok thanks
10:55:21 <benmachine> tabsareevil
10:55:48 * Baughn bakes delicious carrot cake. You can have (undefined :: CarrotCake), but don't look at it.
10:55:52 <shellsage> ok #haskell, how do I fix the return statements in the last case: http://pastebin.com/d243c0cd0
10:56:05 <DrSyzygy> FunctorSalad: While I have your attention, is there a nice, illustrative and easy way to wrap the State monad in a categorical description?
10:56:20 <shellsage> I need a return statement for each case
10:56:31 <shellsage> but the first case is a where statement
10:57:50 <FunctorSalad> DrSyzygy: hmm it has to do with the product/arrow adjunction ( Hask(a * b, c) ~ Hask(a, b -> c) )
10:58:02 <Cale> shellsage: isn't s = beta in the end?
10:58:15 <FunctorSalad> DrSyzygy: I think it's the monad arising from that adjunction
10:58:17 <Cale> shellsage: Why not just lift the whole definition of s up and rename it to beta?
10:58:32 <con> > @ let (+) = (-)
10:58:33 <lambdabot>   <no location info>: parse error on input `@'
10:58:41 <FunctorSalad> if you set c = a*b, then: Hask(a*b,a*b) ~ Hask(a, b -> (a*b))
10:58:42 <con> > @let (+) = (-)
10:58:43 <lambdabot>   <no location info>: parse error on input `@'
10:58:46 <Cale> shellsage: The other thing which you're confused about is that 'where' is not an expression form
10:58:46 <FunctorSalad> which is the type of 'return' for state
10:58:59 <DrSyzygy> Right...
10:59:19 <Cale> shellsage: If you want to make definitions which are local to an expression, use 'let'
10:59:29 <Cale> shellsage: 'where' is part of the syntax of declarations
11:01:58 <dolio> In the natural transformation defintion, eta : I -> GF = I -> b -> (- * b)
11:03:01 <dolio> = a -> b -> (a * b)
11:03:11 <shellsage> Cale, I'm not completely following you
11:03:39 <shellsage> Cale, is there a simple way to just throw return statements into this case statement?
11:03:43 <shellsage> or do I have to change it all around
11:05:06 <Cale> shellsage: You should be aware that return is not a statement, it's just a function.
11:05:22 <Cale> shellsage: return :: a -> State s a
11:05:27 <Cale> (in this case)
11:06:20 <Cale> shellsage: return v is the State s action which does nothing except to return v
11:06:59 <Cale> (that is, it just passes the initial state through to the final state, and results in v)
11:07:39 <shellsage> Cale, ok sorry for misuse of terminology
11:07:44 <tristes_tigres> hello
11:07:48 <shellsage> but how do I do the return function there
11:08:23 <tristes_tigres> isn't there some parameter to make Cabal install html help files in addition to compiled binaries ?
11:08:45 <dcoutts> tristes_tigres: yep
11:09:07 <tristes_tigres> dcoutts: it doesn't do that by default ?
11:09:37 <dcoutts> tristes_tigres: no, if you always want docs then change the setting in the ~/.cabal/config
11:11:00 <tristes_tigres> runhaskell Setup.lhs setup haddock ?
11:11:47 <dcoutts> tristes_tigres: I'd use the cabal program to automate it all, but if you want to use the lower level "runhaskell Setup" interface then you can do that instead.
11:16:24 <tristes_tigres> dcoutts: use cabal program by altering config file &
11:16:28 <tristes_tigres> ?
11:16:58 <dcoutts> tristes_tigres: the config file is so that you can make some settings persistent rather than using command line flags all the time
11:17:13 <dcoutts> tristes_tigres: you can do $ cabal install foobar --enable-documentation
11:17:36 <dcoutts> but if you always want to use the --enable-documentation  then you can set that persistently in the ~/.cabal/config
11:18:28 <con> can anybody help me with this
11:18:30 <con> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11793#a11793
11:18:58 <con> its an insert function but i cant get it to place the variable at the right place
11:19:36 <tristes_tigres> dcoutts: cabal command doesn't seem to be there in windows version of ghc
11:19:43 <int-e> con: what is the idea behind the reverse calls?
11:19:58 <dcoutts> tristes_tigres: it's part of the Haskell Platform, or you can download is separately from the Cabal home page
11:20:03 <dcoutts> is/it
11:20:17 <con> i don't know, i wanted the list to be reversed when it came out of the ins function
11:20:22 <tristes_tigres> dcoutts: thanks
11:21:52 <EvilTerran> con, but you're reversing at every recursive step
11:21:57 <Cale> shellsage: assuming that you don't have more State transformations to do, you can just write  return $ ...  where ... is an expression as complicated as you like describing what it is that you'd like to return
11:22:58 <zygospasm> con: try removing the word reverse and all parentheses apart from those on line 3 :)
11:23:08 <shellsage> Cale, ah ok
11:23:13 <con> ok
11:23:57 <zygospasm> con: if you want to reverse the resulting list, it would be clearer to do that as a separate step.
11:24:00 <EvilTerran> con, for example, ins 3 [0,2,4,6] = reverse (0 : ins 3 [2,4,6]) = reverse (0 : reverse (2 : ins 3 [4,6])) = reverse (0 : reverse (2 : reverse (3 : [4,6])))
11:24:45 <zygospasm> > reverse (0 : reverse (2 : reverse (3 : [4,6])))
11:24:46 <lambdabot>   [2,6,4,3,0]
11:25:23 <EvilTerran> that's not even inserting in the wrong place, that's just chaos
11:25:26 <con> ouch, thats pretty bad
11:26:03 <con> i got told it was to be defined in the function but i couldnt figure out anyway to reverse it
11:26:51 <EvilTerran> con, so you want some function "ins x xs = reverse (insert x xs)", but (presumably) written without using insert?
11:27:05 <con> yes
11:27:21 <con> amd its got to be recursive
11:27:58 <EvilTerran> ... i guess you could write it with an accumulating parameter
11:28:01 <con> but xs:x doesnt work
11:28:03 <EvilTerran> seems a little odd, though
11:28:09 <con> a what?
11:28:12 <con> lol
11:28:31 <con> i'm fairly new to haskell
11:28:40 <EvilTerran> basically, when a function builds up its result in a parameter as it recurses
11:28:51 <EvilTerran> that parameter can be called an accumulating parameter
11:29:30 <con> i could, i'll give that a try
11:31:13 <FunctorSalad> would you unsafePerformIO a library that communicates with another program's REPL? (assuming the other program doesn't perform IO)
11:31:26 <EvilTerran> the standard example i've seen for an accumulating parameter in haskell is writing a function revAppend that satisfies "revAppend xs ys = reverse xs ++ ys"
11:32:14 <EvilTerran> revAppend [] ys = ys; revAppend (it:xs) ys = revAppend xs (it:ys) -- the second parameter is the accumulating one (con)
11:32:36 <con> ok,
11:33:10 <Cale> FunctorSalad: Are you certain that you're going to get the same result from the other program every single time?
11:33:23 <EvilTerran> that's why i mentioned accumulating parameters -- the example i know of them involves reversing a list, and doing something else to it while you're at it
11:33:31 <EvilTerran> so i thought it might be relevant
11:34:02 <con> it looks like it could well be
11:34:04 <BONUS> given a data type: data Foo a b = Foo a b, is it possible to make a function (forall a. Foo a b) -> b
11:34:07 <FunctorSalad> Cale: it's not a one-shot communication; the underlying program is stateful -- so I will thread around the handle to it. But to read/write to the handle, I'd *also* need IO
11:34:10 <BONUS> or is that just an ST thing with the special implementation
11:34:18 <con> ;) thanks for your help EvilTerran
11:34:24 <EvilTerran> no worries :)
11:34:37 <Cale> FunctorSalad: Sounds like it ought to be in IO to me.
11:34:43 <EvilTerran> BONUS, that looks entirely possible to me
11:34:56 <BONUS> i tried to implement it but the type system kept nagging at me
11:35:05 <zygospasm> con: the idea would be that ins 3 [0,2,4,6] would proceed as follows: ([0,2,4,6], [], NotAdded) ~> ([2,4,6], [0], NotAdded) ~> ([4,6], [2,0], NotAdded) ~> ([4,6], [3,2,0], Added) ~> ([6], [4,3,2,0], Added) ~> ([], [6,4,3,2,0], Added) ~> [6,4,3,2,0]
11:35:13 <BONUS> like foo (Foo a b) = b
11:35:15 <FunctorSalad> Cale: hmm wouldn't a State MaudeHandle ensure the ordering of communications?
11:35:22 <EvilTerran> ?type (\(_,y) -> y) :: (forall a. (a,b)) -> b
11:35:23 <FunctorSalad> (even with unsafePerformIO)
11:35:23 <lambdabot>     Couldn't match expected type `forall a. (a, b)'
11:35:23 <lambdabot>            against inferred type `(a, b1)'
11:35:23 <lambdabot>     In the pattern: (_, y)
11:35:29 <EvilTerran> uh
11:36:27 <EvilTerran> BONUS, i don't think STRef is shaped like "data Foo a b = Foo a b"
11:36:33 <Cale> FunctorSalad: No, because you'd be giving your user the ability to duplicate the handle.
11:36:55 <Cale> FunctorSalad: Unless you mean wrapping that all up into a newtype and hiding the State interface
11:37:02 <dolio> @type (\p -> case p of (_,y) -> y) :: (forall a. (a, b)) -> b
11:37:03 <lambdabot> forall b. (forall a. (a, b)) -> b
11:37:10 <Cale> FunctorSalad: In which case, it's probably more convenient just to newtype IO
11:37:13 <FunctorSalad> Cale: good point, thanks
11:37:37 <FunctorSalad> Cale: though I could still do what you just said and unsafePerformIO the runMyMonad
11:38:20 <dolio> That example makes more sense if you're explicit about type passing.
11:38:40 <HayashiRazan> dolio whats a good book to learn haskell from
11:38:43 <dolio> Because then it's "\p -> case p <whatever> of (_, y) -> y"
11:38:44 <doublethink_work> preflex: seen copumpkin
11:38:44 <preflex>  copumpkin was last seen on #haskell-blah 2 days, 15 hours, 31 minutes and 25 seconds ago, saying: http://vaultoz.com/
11:38:46 <FunctorSalad> (I think the underlying program is pure in the sense that the same session with it will produce the same result every time (it's a term rewriting engine))
11:38:54 <doublethink_work> preflex: seen pumpkin
11:38:54 <preflex>  pumpkin was last seen on #haskell 12 days, 21 hours, 54 minutes and 34 seconds ago, saying: ugh :)
11:39:38 <dolio> HayashiRazan: I've heard Learn You a Haskell is a good online reference.
11:41:07 * EvilTerran wonders if there's a TS monad like the Etats monad
11:42:25 <dolio> It'd be even weirder.
11:42:38 <Botje> l'etats, c'est moi
11:43:09 <Botje> (i know it's Ã©tat)
11:43:58 <EvilTerran> Etats is remarkably succinct for describing certain things
11:44:24 <dolio> At least, it's kind of weird for you to be declaring a reference that sucks up state from the future.
11:44:59 <dolio> But, obviously, you can't declare it at the end of the computation.
11:45:31 <EvilTerran> BONUS, in "ST r a", i believe the r is a phantom type parameter; ie, it wouldn't appear in the type of a constructor parameter
11:45:52 <EvilTerran> BONUS, as the whole point of the r there is to stop STRefs leaking between seperate runSTs
11:46:03 <EvilTerran> (likewise the r in STRef r a)
11:46:09 <PeakerWork> EvilTerran: what is Etats good for?
11:46:16 <FunctorSalad> what is Etats?
11:46:23 <tristes_tigres> but when cabal installs documentation, it doesn't link it frjv the "ghc libraries" help page, does it ?
11:46:27 <EvilTerran> PeakerWork, i'm trying to find the file i was tinkering with it in
11:46:35 <EvilTerran> FunctorSalad, backwards State :P
11:46:49 <dolio> Well, the problem with "foo (Foo a b) = b" is that the argument to foo isn't a Foo a b, it's a function from types to Foos.
11:47:35 <EvilTerran> ?type \m f -> f . runState m
11:47:37 <lambdabot> forall b s a. State s a -> ((a, s) -> b) -> s -> b
11:47:42 <dolio> PeakerWork: mapAccumR is mapM in reverse state.
11:47:56 <PeakerWork> @hoogle mapAccumR
11:47:57 <lambdabot> Data.ByteString mapAccumR :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
11:47:57 <lambdabot> Data.List mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
11:47:57 <lambdabot> Data.Traversable mapAccumR :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
11:48:00 <dcoutts> tristes_tigres: it does not modify the help files installed by ghc, no. The dev version has a feature to maintain an html index file.
11:48:55 <Egg_> can someone help with my code please?
11:49:00 <dolio> > mapAccumR (\i _ -> (i+1, i)) 0 [1..10]
11:49:02 <lambdabot>   (10,[9,8,7,6,5,4,3,2,1,0])
11:49:43 <Egg_> I'm trying to zip 3 lists together, using the zip function but not zip3
11:49:45 <Egg_> http://pastebin.com/m5b38bf23
11:49:49 <Egg_> is my code
11:50:09 <PeakerWork> dolio: Etats is weird.
11:50:09 <EvilTerran> PeakerWork, compare State: (m >>= f) s = let (x, s') = m s; (y, s'') = f x s in (y, s''); and Etats: (m >>= f) s = let (x,s'') = m s'; (y,s') = f x s in (y,s'')
11:50:10 <EvilTerran> iirc
11:50:44 <blackh> shellsage: I woke up!
11:50:46 <EvilTerran> so the state parameter flows in the opposite direction to bound values
11:51:03 <PeakerWork> EvilTerran: and you get "time paradoxes" :-)
11:51:10 <EvilTerran> (both written more verbosely than necessary to accentuate the simularity)
11:51:16 <EvilTerran> yeah :D
11:52:06 <dcoutts> Egg_: I suspect the task is to think more and code less
11:52:13 <dolio> > let r a s = (s,a) ; b m f s = let (a,s'') = m s' ; (b,s') = f a s in (b,s'') ; g s = (s,s) ; p s = (s,()) ; mM f [] = r [] ; mM f (x:xs) = f x `b` \y -> mM f xs `b` \ys -> r (y:ys) in mM (g `b` \i -> p (i+1) `b` \_ -> r i) [1..10]
11:52:15 <lambdabot>   Couldn't match expected type `t2 -> (t1, t)'
11:52:15 <lambdabot>         against inferred type ...
11:52:24 <Egg_> hah oh
11:53:58 <dcoutts> Egg_: consider that zip lets you zip two lists together, but you've got three. Similarly, + lets me add two numbers but if I've got three numbers then I can still add them all together...
11:59:04 <Egg_> i still don't really see how to do it
11:59:05 <Egg_> :/
12:00:25 <jlouis> foo (ps, qs) = (snd ps, snd qs) ... some Arrow combinator can do this, right?
12:01:16 <PeakerWork> @type snd *** snd
12:01:17 <lambdabot> forall a c a1 b. ((a, c), (a1, b)) -> (c, b)
12:01:24 <jlouis> mmm, thanks
12:01:31 <PeakerWork> I like:
12:01:34 <PeakerWork> @let both = join (***)
12:01:35 <lambdabot>  Defined.
12:01:37 <PeakerWork> @type both snd
12:01:38 <lambdabot> forall a c. ((a, c), (a, c)) -> (c, c)
12:01:53 <jlouis> @type join
12:01:53 <PeakerWork> oh damn, that screws up the type
12:01:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:02:08 <jlouis> PeakerWork: it works for this case though
12:02:10 <con> Hey egg
12:02:11 <FunctorSalad> funny how 99% of Arrow use is for (->) ;)
12:02:12 <PeakerWork> jlouis: for functions: join f x = f x x
12:02:16 <Egg_> yeah?
12:02:19 <con> are you at university
12:02:21 <con> ?#
12:02:21 <lambdabot> Maybe you meant: . ? @ v
12:02:23 <Egg_> yeah
12:02:38 <con> do you have a lecurer called patricia johann
12:02:43 <Egg_> haha yeah
12:02:46 <jlouis> PeakerWork: is that when the monad is instantiated as a Reader_
12:02:46 <con> lol
12:02:47 <jlouis> ?
12:02:50 <Egg_> how did you guess that?
12:03:01 <con> why do you think i'm here :D
12:03:08 <Egg_> hahaha
12:03:09 <Egg_> smooth
12:03:26 <PeakerWork> jlouis: As a function, like:  (r->)
12:03:36 <jlouis> I see.
12:04:07 <jlouis> FunctorSalad: yes. Not so in Category theory though :)
12:04:45 <con> @egg: you'll hate the palindrome question
12:04:45 <lambdabot> Unknown command, try @list
12:05:04 <Egg_> oh no I've done that one
12:05:13 <jlouis> con: the @ is something our bot, lambdabot understands
12:05:13 <Egg_> Only need to do 5b and 7, done the rest
12:05:45 <con> jlouis: just figured that out :D
12:06:18 <con> i need to do 4,6 7 and 5b
12:06:31 <Taejo> can somebody explain http://hackage.haskell.org/packages/archive/dbus-core/0.5/logs/failure/ghc-6.10 -- there's a version conflict, but it builds fine for me with only bytestring-0.9.1.4
12:06:55 <Egg_> 6 is kinda hard, I got my code for that from here
12:07:03 <Egg_> with some tweaking from myself
12:07:06 <jlouis> Egg_: what does 6 say?
12:07:20 <Taejo> I'd like haddocks for fdo-notify, but it can't be compiled until dbus-core is
12:07:30 <Egg_> 6 was some function to check whether a string was a palindrome
12:07:31 <jlouis> Also, you ought to attempt homework yourself before asking questions :)
12:07:41 <Egg_> haha I did!
12:07:45 <Egg_> just I suck at this
12:08:06 <con> as do i
12:08:29 <con> We've kind of been just droped in it
12:08:56 <Egg_> yeah it's gotten so hard so fast
12:08:57 <HayashiRazan> Egg_ is like the Michael Jordan of Haskell
12:09:26 <con> I done last weeks one no problem
12:10:18 <Egg_> well boo at you
12:10:29 <Egg_> and I only know about michael jordan from Space Jam
12:10:34 <Egg_> so I guess that is cool
12:10:35 <Egg_> :x
12:10:46 <con> lol
12:13:33 <jimmyjazz14> I have a question...
12:14:00 <jimmyjazz14> I have function getPassword with the type: IO (String -> (User -> a) -> a)
12:14:12 <FunctorSalad> @unmtl ErrorT e (State s) a
12:14:12 <lambdabot> s -> (Either e a, s)
12:14:29 <FunctorSalad> @unmtl StateT s (Either e) a
12:14:30 <lambdabot> s -> Either e (a, s)
12:14:34 <FunctorSalad> :o
12:14:38 <Baughn> jimmyjazz14: Okay?
12:14:43 <jimmyjazz14> if I do something like a <- getPasswd
12:14:54 <jimmyjazz14> a will have the type: String -> (User -> GHC.Prim.Any) -> GHC.Prim.Any
12:15:02 <jimmyjazz14> whats the deal?
12:15:03 <mauke> unlikely
12:15:10 <Baughn> jimmyjazz14: Well, probably that type is wrong
12:15:25 <mauke> a will have the type String -> (User -> a) -> a
12:15:38 <Baughn> jimmyjazz14: ..and it certainly won't have /that/; that just happens in ghci sometimes when you ask for a concrete type and it doesn't know which to pick
12:15:40 <Lemmih> mauke: He's typing it into ghci.
12:16:05 <jimmyjazz14> Baughn: ah so this is because of ghci
12:16:10 <jimmyjazz14> good to know
12:16:12 <jimmyjazz14> thanks
12:16:25 <Baughn> jimmyjazz14: It's type defaulting of a particularily annoying kind, but the alternative would be to refuse your a <- getPasswd input
12:16:39 <Baughn> jimmyjazz14: GHCi /cannot/ execute any command without first knowing its concrete type
12:17:08 <jimmyjazz14> Baughn: ah that kinda makes sense
12:17:25 <Baughn> jimmyjazz14: That is, you'd get an error like this:
12:17:31 <Baughn> > read "42"
12:17:33 <lambdabot>   * Exception: Prelude.read: no parse
12:17:36 <Baughn> Um.
12:17:44 <Baughn> Like the error you'd get from using that in GHCi.
12:18:03 * Baughn punches in Cale's general direction
12:20:13 <ben_m> Something I read a lot is the "reader monad". Can someone explain what that is?
12:20:28 <mauke> @src Reader
12:20:28 <lambdabot> Source not found. Take a stress pill and think things over.
12:20:31 <mauke> :-(
12:20:39 <Baughn> @src (->r)
12:20:39 <lambdabot> Source not found. Take a stress pill and think things over.
12:20:42 <Baughn> @src Monad (->r)
12:20:43 <lambdabot> Source not found. The more you drive -- the dumber you get.
12:20:50 <pikhq> @instances Monad
12:20:51 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
12:20:53 <Baughn> @src Monad (->) r
12:20:53 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
12:20:59 <pikhq> @src Monad ((->) r)
12:20:59 <lambdabot> Source not found. You speak an infinite deal of nothing
12:21:01 <Baughn> @src (->) r
12:21:01 <mauke> ben_m: newtype Reader e a = Reader { runReader :: e -> a }
12:21:01 <lambdabot> Source not found. I am sorry.
12:21:22 <ben_m> That doesn't say anything to me, sorry :(
12:21:32 <ben_m> I mean, I can read it.
12:21:33 <mauke> ben_m: do you know newtype?
12:21:36 <ben_m> yeah
12:21:36 <mauke> ok
12:21:39 <ben_m> But I don't see how it's useful.
12:21:40 <Baughn> ben_m: A monad value in Reader is a function that takes the monads's parametrized type and returns whatever
12:21:49 <mauke> ben_m: implicit function arguments
12:22:09 <mauke> that is, it provides an invisible environment
12:22:36 <ben_m> Got a basic example?
12:22:41 <mauke> actions in Reader can use 'ask' to read the environment
12:22:54 <mauke> and runReader takes an environment to provide to its action
12:23:32 <ben_m> So Reader is to Monads what Monads are to regular values?
12:23:34 <mauke> > runReader 42 (do { x <- ask; return ("I got " ++ show x) })
12:23:35 <lambdabot>   Ambiguous type variables `m', `r' in the constraint:
12:23:36 <lambdabot>    `Control.Monad.Read...
12:23:42 <mauke> > runReader (do { x <- ask; return ("I got " ++ show x) }) 42
12:23:43 <lambdabot>   "I got 42"
12:23:46 <mauke> huh?
12:23:57 <ben_m> Oh I understand it.
12:24:08 <Baughn> > (do x <- id; return ("I got " ++ show x)) 42
12:24:09 <lambdabot>   "I got 42"
12:24:13 <mauke> shh
12:24:44 <Baughn> Well, it does explain how ask is implemented. :P
12:24:53 <ben_m> I think I understand it :)
12:24:57 <ben_m> Thanks.
12:25:00 <ben_m> Seems quite useful.
12:25:11 <Baughn> > join (,) 42 -- Also the reader monad. Kinda.
12:25:12 <lambdabot>   (42,42)
12:25:19 <mauke> instance Monad Reader where return x = Reader (\_ -> x); mx >>= f = Reader (\e -> runReader (f (runReader mx e)) e)
12:25:38 <ben_m> sigh
12:26:10 <paolino> :t local
12:26:11 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
12:26:12 <mauke> instance Monad (->)   where return x =        (\_ -> x); mx >>= f =        (\e ->           (f (          mx e)) e)
12:26:22 <ben_m> I'm too tired for this today :D
12:26:27 <mauke> well, almost
12:26:29 <ben_m> But I got the basic idea of it I think.
12:26:40 <mauke> I forgot the e in the instance Monad (Reader e) part
12:27:32 <PeakerWork> ben_m: its about automating the passing/receiving of argument[s]
12:28:21 <mauke> in my last Haskell program I actually used RWST
12:28:54 <PeakerWork> mauke: because you're afraid of the performance issues of composing ReaderT, WriterT, StateT ?
12:29:09 <mauke> because it's shorter
12:29:28 <Baughn> type RWST a b c = ReaderT a WriterT b StateT c?
12:29:52 <EvilTerran> Baughn, i don't think that'd work
12:30:12 <Baughn> You're probably right. Still..
12:30:29 <Baughn> mauke: Using an RWST type, or just wrapping the other three?
12:30:35 <PeakerWork> RWST r w s m a = ReaderT r (WriterT w (StateT s m)) a
12:30:38 <EvilTerran> it'd have to be "type RWST r w s m = ReaderT r (WriterT w (StateT s m))"
12:30:59 <PeakerWork> mauke: did you implement it as a composition of those?
12:31:15 <mauke> newtype M a = M{ unM :: RWST XEnvironment (DList String) Generator (Either String) a }
12:31:21 <mauke> deriving (Monad)
12:31:59 <PeakerWork> mauke: how did you implement RWST though?
12:32:03 <con> ok, i'm cpmpletly confused, i'm trying to get the Nth item of a list and return it. can anybody give me any clues
12:32:09 <mauke> import Control.Monad.RWS
12:32:16 <con> I've got this so Far
12:32:18 <con> returnNth a b =[(x,y) | x <- [1..a], y <- b]
12:32:33 <PeakerWork> mauke: btw I think RWST exists somewhere in hackage
12:32:35 <con> which does completly the wrong thing
12:32:51 <mauke> PeakerWork: uh, it exists in mtl (and came with my ghc)
12:33:03 <PeakerWork> mauke: oh, for some reason a thought (that you implemented, not used) RWST had injected itself into my mind in the last 5 minutes
12:33:07 <mauke> con: I'd just recurse on the number
12:33:34 <con> i'm not allowed to recurse for the answer which sucks cuz that'd be really easy
12:33:41 <mauke> what, no recursion?
12:33:45 <con> yep
12:33:53 <mauke> what library functions can you use?
12:33:59 <con> zip and head
12:34:04 <mauke> lol wut
12:34:11 <con> and list comprehension
12:34:18 <con> its so confusing
12:34:27 <mauke> ah, no, it isn't :-)
12:34:43 <con> can you give me a small clue
12:35:04 <mauke> ok, what you have is wrong because a list comprehension like that gives you all combinations of x and y
12:35:12 <con> yep
12:35:21 <mauke> > [(x, y) | x <- [1 .. 3], y <- "abc"]
12:35:22 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
12:35:37 <mauke> you need to walk both lists in parallel, and that's what zip is for
12:35:40 <Baughn> > [(x,y) | x <- [1..3] | y <- "abc"]
12:35:41 <lambdabot>   [(1,'a'),(2,'b'),(3,'c')]
12:35:51 <EvilTerran> Baughn, shush, no extensions :P
12:35:57 <mauke> what Baughn wrote is a language extension that's equivalent to zip
12:36:17 <Baughn> It's handy when composing more than two lists, which practically never happens
12:36:26 <Baughn> Personally, I almost never use list comprehensions
12:36:33 <con> ok, i'll guess i'm not allowed to use that one :P
12:36:43 <mauke> con: but you can use zip
12:36:58 <PeakerWork> con: list comprehensions can filter out elements
12:37:05 <Baughn> (Since list comprehensions use so many points, I might run out)
12:37:29 <PeakerWork> Baughn: I don't like them either, they seem less composable/refactorable than map/filter
12:37:37 <Baughn> Right
12:37:46 <PeakerWork> I find them redundant to "do" syntax, too.
12:38:12 <Baughn> PeakerWork: The one case I /might/ find useful is zip3 and up
12:38:24 <Baughn> ..specifically, up
12:39:14 <PeakerWork> Baughn: N-tuples :-((
12:39:31 <PeakerWork> which is really a result of lifted type products, which I also don't like...
12:39:57 <con> ok, i'm not really getting anywhere
12:40:01 <con> :P
12:40:17 <PeakerWork> what's the status of Haskell web development? How much does it cover? Can I avoid writing html/css altogether, in favor of some web design DSL?
12:40:51 <Baughn> PeakerWork: We'd all like to know. There are at least a dozen web frameworks; I haven't seen anyone make an overview lately.
12:41:12 <arcatan> somebody should! too bad i don't have time :|
12:41:35 <PeakerWork> I don't know almost anything about web development (the html/css/javascript side) and would like to keep it that way if possible :)
12:41:43 <PeakerWork> If a DSL can generate Javascript/AJAX for me, that would be awesome
12:42:23 <Baughn> There's one for that, yes
12:42:44 <Baughn> Um
12:42:44 <Baughn> Five
12:42:52 * Baughn twitches
12:43:05 <Baughn> PeakerWork: Just search hackage for "javascript", will you?
12:43:10 <PeakerWork> ;)
12:43:42 <Egg_> hey con, I took your code for 7 and played with it
12:43:47 <Egg_> seems to compile for me now
12:43:53 <Egg_> but it fails when you actually use it
12:43:58 <con> does it work?
12:44:07 <Egg_> I'll test some more
12:44:09 <con> I guessed so :P
12:45:00 <Egg_> I get a no instance of blah blah blah when I try to run it
12:45:09 <Egg_> >   returnNth xs ys n = [(x, y) | x <- zip xs ys, y <- zip xs ys, y == n]
12:45:10 <lambdabot>   <no location info>: parse error on input `='
12:45:14 <Egg_> is what I tried
12:45:18 <Egg_> yeah it fails
12:45:54 * con shrugs
12:45:58 <mauke> :t let returnNth xs ys n = [(x, y) | x <- zip xs ys, y <- zip xs ys, y == n] in returnNth
12:45:59 <lambdabot> forall a b. (Eq b, Eq a) => [a] -> [b] -> (a, b) -> [((a, b), (a, b))]
12:46:12 <mauke> why the double zip?
12:46:26 <Egg_> didn't know how else to do it
12:46:30 <mauke> do what?
12:46:32 <Egg_> tbh I want to use length for y
12:46:37 <Egg_> or ys even
12:46:47 <Egg_> but I'd rather get my code working before I try be clever
12:46:50 <mauke> that's easy, just use [0 ..] instead of ys
12:47:00 <mauke> but that doesn't explain the double zip
12:47:10 <con> Soooo confusing
12:47:33 <Egg_> i was thinking that y would need to get it's own copy of zipped xs ys
12:47:35 <Egg_> if that makes sense
12:47:42 <Egg_> it wouldn't be able to use the one made for x
12:47:45 <mauke> why?
12:47:53 <con> ahh
12:47:55 <Egg_> just thought that's how this stuff worked
12:47:56 <Egg_> :/
12:47:57 <jimmyjazz14> is there a haskell module that contains non infix versions of common operators (like add for (+))
12:48:17 <mauke> (+) is already non-infix
12:48:32 <con> > returnNth a b =[(x,y) | x <- zip(1..a,b)]
12:48:33 <lambdabot>   <no location info>: parse error on input `='
12:48:35 <jimmyjazz14> mauke: well yes when you user the para
12:48:42 <pikhq> jimmyjazz14: No, because there's no point in it.
12:48:48 <mauke> con: zip takes two arguments, not one
12:49:07 <pikhq> That's like asking if there's a haskell module that contains infix versions of common functions.
12:49:07 <jimmyjazz14> pikhq: I'm not a big fan of parentheses
12:49:16 <pikhq> Even the `foo` is the infix version.
12:49:17 <ben_m> @pl not (elem x xs)
12:49:18 <lambdabot> not (elem x xs)
12:49:18 <con> > returnNth a b =[(x,y) | x <- zip[1..a] b]
12:49:19 <lambdabot>   <no location info>: parse error on input `='
12:49:28 <ben_m> :/
12:49:29 <jimmyjazz14> but yeah not a big deal, just though I would ask
12:49:41 <mauke> con: better, but y is undefined there
12:49:50 <pikhq> s/the/though/
12:50:16 <con> > returnNth a b =[x | x <- zip[1..a] b]
12:50:17 <lambdabot>   <no location info>: parse error on input `='
12:50:21 <mauke> dude
12:50:23 <con> You make a good poing
12:50:29 <mauke> will you stop annoying the bot?
12:50:35 <con> will do
12:50:39 <tommd> poor bot
12:50:40 <tommd> @botsnack
12:50:40 <lunabot>  :o
12:50:40 <lambdabot> :)
12:50:46 <jimmyjazz14> it would be nice if (+ 10) just kinda worked
12:50:48 <mauke> it only evaluates expressions; you can't just put a function definition in ">"
12:50:51 <pikhq> con > let returnNth a b = [x | x <- zip [1..a] b] in returnNth 10 2
12:50:55 <pikhq> > let returnNth a b = [x | x <- zip [1..a] b] in returnNth 10 2
12:50:56 <lambdabot>   No instance for (GHC.Num.Num [b])
12:50:56 <lambdabot>    arising from the literal `2' at <inter...
12:51:08 <pikhq> > let returnNth a b = [x | x <- zip [1..a] b] in returnNth 1 [2..]
12:51:10 <lambdabot>   [(1,2)]
12:51:14 <Egg_> He's only copy pasting code I should imagine
12:51:19 <PeakerWork> con: [x | x <- blah] == blah
12:51:21 <pikhq> con: ^
12:51:22 <Egg_> and ignores the bot
12:51:29 <con> yep
12:51:53 <PeakerWork> con: you can chat with lambdabot privately, if you need a "private" moment, if you know what I mean
12:52:10 <Egg_> con have you done 5b?
12:52:19 <con> nope :D
12:52:23 <Egg_> hah
12:52:30 <con> its a lot harder than 5a
12:52:38 <Egg_> yeah
12:52:39 <mauke> what's 5b?
12:52:51 <dolio> Peaker talks to @vixen privately all the time. :)
12:52:52 <Egg_> what I asked about like 2 hours ago D:
12:53:04 <mauke> ...
12:53:04 <Egg_> have to zip 3 lists using only zip
12:53:10 <PeakerWork> dolio: who's that? :)
12:53:21 <mauke> oh, ok
12:53:21 <dolio> @vixen What the dilly, yo?
12:53:22 <lambdabot> hiya
12:54:04 <mauke> Egg_: wait, only zip? can I use list comprehensions?
12:54:17 <Egg_> lemme check
12:54:37 <con> yes
12:54:45 <con> just no recursion
12:54:49 <con> i think
12:54:50 <Egg_> yeah that
12:54:51 <mauke> ok, easy then
12:56:08 <mauke> > zip "foo" (zip "bar" "baz")
12:56:09 <lambdabot>   [('f',('b','b')),('o',('a','a')),('o',('r','z'))]
12:56:28 <Egg_> that's it?!
12:56:39 <Egg_> I could have sworn I tried that as my first go D:
12:56:44 <mauke> probably not
12:56:50 <Egg_> haha oh
12:57:04 <ben_m> @pl \x y -> filter (not . flip elem x) y
12:57:05 <lambdabot> filter . (not .) . flip elem
12:57:05 <con> I tried it the other way around lol
12:57:14 <ben_m> ugh, not much clearer
12:57:15 <mauke> I assume the intended result is [('f', 'b', 'b'), ('o', 'a', 'a'), ('o', 'r', 'z')]
12:57:22 <Egg_> yeah
12:57:46 <mauke> @pl \x y -> filter (`notElem` x) y
12:57:46 <lambdabot> filter . flip notElem
12:58:00 <ben_m> I'm stupid :D
12:58:21 <ben_m> Could use \\ too ...
12:58:40 <mauke> well, then the remaining task is to transform the first list into the second
12:59:27 <Egg_> tbh I don't think it will matter
12:59:50 <Egg_> unless it won't compile without it or something
13:00:07 <Egg_> hah oh it doesn't
13:01:20 <con> really?
13:01:47 <Egg_> really what?
13:01:49 <con> so it doesnt
13:02:00 <con> zip3l x y z = zip x (zip y z)
13:02:46 <con> ahh type error
13:03:00 <Egg_> yeah
13:03:07 <Egg_> from the a(b,c) thing
13:03:14 <con> yep
13:03:23 <con> compiles fine now
13:03:31 <Egg_> eh what
13:03:31 <Egg_> how
13:03:41 <con> just got to finish 7 then I'm calling it a night
13:03:47 <Egg_> TELL ME 5B
13:03:48 <Egg_> Also
13:03:56 <Egg_> assuming you are in my class and not just doing haskell
13:04:01 <Egg_> we have logic assingment 2
13:04:03 <con> zip3l x y z = zip x (zip y z)
13:04:06 <Egg_> to do for friday
13:04:09 <con> I know
13:04:13 <Egg_> oh
13:04:18 <Egg_> well i did not
13:04:23 <con> I'm doing that tomorrow in my 4 hour gap
13:04:45 <Egg_> hah
13:05:01 <con> Yay functional programming at 9 tomorrow
13:05:21 <Egg_> aljgasufga;usgfowbfabouwofug
13:05:26 <Egg_> Mine hasn't been working all this time
13:05:27 <Egg_> cause
13:05:33 <Egg_> my empty list statement
13:05:34 <Egg_> was wrong
13:05:38 <PeakerWork> guys maybe you can discuss tomorrow's assignments privately? :)
13:06:14 <Egg_> haha yeah sprry
13:06:47 <con> sorry
13:07:20 <FunctorSalad> control-monad-exception depends on either mtl or monads-fd....
13:07:43 <FunctorSalad> so you can't rely on it having declared instances for either? :(
13:08:08 <FunctorSalad> even if you depend on mtl, the user might have compiler c-m-e for monads-fd
13:08:17 <con> Egg_ for some reason i cannot start a private chat
13:08:34 <PeakerWork> con: try /query Egg_
13:08:49 <Egg_> I started one with you
13:08:51 <Egg_> get it?
13:09:06 <jlouis> It might require nickserv identification
13:09:14 <Egg_> we got it
13:15:14 <absentia> I'm going to start using notification center.. vs delegates...
13:15:17 <leimy> 666 members!
13:15:19 <leimy> @users
13:15:19 <lambdabot> Unknown command, try @list
13:15:20 <absentia> argh. sorry, wrong channel
13:15:23 <leimy> doh
13:15:58 <leimy> I've got a value of type IO (Maybe (IO ()))
13:16:11 <leimy> I'm not sure how to "run the action" in the Maybe :-)
13:16:26 <mauke> well, first you run the first action, giving you Maybe (IO ())
13:16:36 <mauke> then you decide what to do in the case of Nothing
13:16:43 <mauke> but if it's Just x, you run x
13:16:58 <PeakerWork> m >>= maybe (return ()) id
13:17:07 <PeakerWork> is a possibility
13:17:20 <PeakerWork> m >>= fromMaybe (return ())
13:17:33 <mauke> :t (>>= fromMaybe (return ()))
13:17:34 <lambdabot> forall (m :: * -> *). (Monad m) => m (Maybe (m ())) -> m ()
13:18:39 <mauke> :t \m -> do { q <- m; case q of { Nothing -> return (); Just x -> x } }
13:18:40 <lambdabot> forall (m :: * -> *). (Monad m) => m (Maybe (m ())) -> m ()
13:19:08 <leimy> PeakerWork: nice :-)
13:19:27 <mauke> @undo \m -> do { q <- m; case q of { Nothing -> return (); Just x -> x } }
13:19:27 <lambdabot> \ m -> m >>= \ q -> case q of { Nothing -> return (); Just x -> x}
13:19:38 <fluxxen> if I got a list of for example [1,2,1,3,4] and I want to return an Integer with the value of the number of "1" from that List. what function should I use?
13:19:57 <fluxxen> with value of the number of times "1" is present in that list..
13:19:58 <mauke> @hoogle [a] -> a -> Int
13:19:59 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
13:19:59 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
13:19:59 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
13:20:14 <mauke> oh, you want a count
13:20:23 <mauke> fluxxen: length and filter
13:20:54 <fluxxen> mauke ah that's true. I filter all the ones except the 1's and then do length on that! thanks smart!
13:28:09 <fluxxen> mauke If I got a custom type list, I can't use filter and length right?
13:28:26 <mauke> depends on your definition of "custom type list"
13:28:40 <mauke> if it's [T] for some type T, then yes
13:28:55 <mauke> if it's List T where List is your own invention, then no
13:29:37 <fluxxen> mauke ok I think it's the last one. gonna do some thinking. Thnaks
13:29:38 <fluxxen> thanks
13:29:49 <Heffalump> why did you invent your own list type?
13:29:49 <lispy> mauke: But then isn't edison supposed to make those list ops general?
13:30:01 <mauke> oh, I haven't used edison
13:30:18 <mauke> I'd probably look in Foldable first, actually
13:30:25 <lispy> Neither have I, but I thought some one told me it used type classes for the different collection interfaces
13:31:34 <fluxxen> Heffalump Im making an exercise, making a card game and the list is a hand with different cards.
13:31:34 <lispy> It would be an interesting project to make a version of the Prelude that had a List type class of which [] is the main instance
13:31:51 <fluxxen> Heffalump and I want to check if I got more then ex 1 ace
13:32:20 <lispy> I wonder  how frequently people would specialize to [] to avoid type class overhead
13:33:05 <Heffalump> fluxxen: that doesn't really explain why you need your own list type
13:33:47 <fluxxen> Heffalump it's predefined in the exercise, nothing I can do about it :/
13:38:56 <sioraiocht> is it possible to define lists in djinn at all?
13:39:02 <adimit> Hello there. Can someone help me track down a space leak, related to lazy file IO? This is the program: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11799#a11799 (I've highlighted the main cost centre) and this is the profiling output: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11800#a11800
13:39:38 <adimit> I've tried adding strictness annotations, because, clearly, it's allocating too much memory (input file is 25M,) but somehow to no effect.
13:47:56 <slowriot> I'm trying to figure out why the complement of an NP language is not necessarily a member of NP.
13:49:35 <slowriot> It seems like if you have a polynomial-time deciding NDTM for a language, you can construct a polynomial time deciding NDTM for its complement by running the NDTM and then rejecting if it accepts and accepting if it rejects.
13:50:06 <Gracenotes> perhaps said complement is not decidable
13:50:31 <slowriot> wouldn't my construction be a decider for said complement, though?
13:51:09 <Gracenotes> oh, that's true.. complements of decidable languages are the same
13:51:32 <FunctorSalad> how should you handle lifting of MonadError if your transformer adds a new exception type?
13:51:42 <slowriot> not non-deterministic decidible languages, though
13:51:58 <FunctorSalad> I think the new error type should be (Either InnerError NewError)
13:52:10 <Gracenotes> slowriot: and you mean NP-hard, right?
13:52:21 <FunctorSalad> but then in 'catchError' you have some choices
13:52:26 <leimy> Ok this is weird...
13:52:35 <slowriot> I think the problem is that I don't know how to frame my constructions in terms of an NDTM. NDTMs can't wait for either an accept or a reject and then respond based on the results.
13:52:52 <slowriot> Gracenotes: I think I mean NP
13:52:55 <luite> slowriot: the problem is that NP says that you can only verify yes instances in polynomial time
13:53:01 <leimy> I don't know why IO (Maybe (IO ())) is so much easier to deal with than IO (Maybe (String, IO ()))
13:53:16 <slowriot> luite: ah, thanks
13:53:16 <leimy> I can't simply use fromMaybe like I do in the first case
13:53:20 <Gracenotes> well, verification for NP-complete
13:53:29 <Gracenotes> for just NP-hard, well, meh
13:53:47 <Axman6> leimy: write a new function that makes it easy
13:54:19 <luite> slowriot: sorry, I meant "NP only says that ..."
13:54:27 <FunctorSalad> (what if the handler for the NewError throws an OldError? should you feed it to the handler for OldError?)
13:54:44 <slowriot> luite: if you have a polynomial time verifier, you can create a nondeterministic polynomial time decider, though
13:54:56 <slowriot> luite: And vice versa
13:55:09 <FunctorSalad> hmm think I will do this differently
13:55:23 <Gracenotes> I shouldn't give advice on this, though... I can't say I know much computational complexity theory beyond regular computation theory. outside of the whole reduction bit, it's mostly esoteric nonsense
13:55:41 <leimy> Axman6: huh? :-)
13:56:07 <Gracenotes> and "mostly" is giving it too much slack, maybe..
13:56:27 <Axman6> leimy: can'tyou write a function like fromMaybe that will do what you want?
13:56:48 <leimy> Oh that's not the problem :-)
13:56:52 <leimy> fromMaybe is fine
13:56:55 <slowriot> Gracenotes: Really? I think it's pretty important to have a mathematically simple model of computation so that you can reason about it.
13:56:58 <leimy> I'm trying to compose it with snd or something :-)
13:57:10 <leimy> I'm probably doing something really dumb
13:57:13 <leimy> as usual
13:57:33 <leimy> and yes, I was :-(
13:57:37 <leimy> oh well
13:58:05 <leimy> fromMaybe used with System.timeout is a nice way to deal with timeouts actually
13:58:21 <leimy> because the "fallback behavior" is the first parameter to fromMaybe then.
13:58:50 <Gracenotes> slowriot: automatons are great, finite to turing. I just don't like the complexity extensions so much, the gluttonous mass of computational complexity classes
13:58:54 <FunctorSalad> Gracenotes: but isn't it useful if some problem pops up in your project and someone has already determined the complexity...?
13:59:17 <MyCatVerbs> Gracenotes: but it's fun.
13:59:45 <FunctorSalad> (if you think complexity is esoteric, what about the super-turing arithmetical hierarchy? ;))
13:59:49 <MyCatVerbs> And they're all baby steps to chipping away at the evil bastard of nondeterministic polynomial-time versus deterministic polynomial time. :)
14:00:11 <Gracenotes> time and space reductions of complexity, for perhaps a few classes, have yielded useful results
14:00:30 <Gracenotes> I say we vote everything else out Survivor-style >_>
14:00:46 <MyCatVerbs> Gracenotes: Also, in their defense, some of the circuit complexity families are exceedingly good models of what you can actually do fast with cheap silicon. :)
14:00:57 <jimmyjazz14> I just noticed that if you flip ($) you get something that look a lot like calling methods on an object in OO
14:01:11 <FunctorSalad> @ty flip ($)
14:01:12 <lambdabot> forall b b1. b -> (b -> b1) -> b1
14:01:24 <FunctorSalad> hehehe
14:01:56 <Gracenotes> > let (.) = flip ($) in [4, 6, 4, 2, 2, 3, 1, 1].sort.groupBy(==).length
14:01:58 <lambdabot>   5
14:02:39 <pfo> hey guys - what's the state of haskell on snow loepard?
14:02:45 <pfo> still broken?
14:02:46 <Axman6> jimmyjazz14: if you make (.) = fmap,you can do things like: sum.(+2).[1..10]
14:02:48 <tommd> jimmyjazz14: Back when I was still learning Haskell (before breaking bad habits) I redefined (.) to perform record field selection so I could access my Haskell records much like my C structures.
14:02:51 <burp> snowy
14:03:01 <Axman6> >let (.) = fmap in sum.(+2).[1..10]
14:03:08 <Axman6> > let (.) = fmap in sum.(+2).[1..10]
14:03:10 <lambdabot>   Couldn't match expected type `[a] -> [a]'
14:03:10 <lambdabot>         against inferred type `[a...
14:03:13 <jimmyjazz14> Axman6: interesting
14:03:14 <Axman6> bah
14:03:21 <pfo> the ghc backend is only able to generate 32bit code? why this?
14:03:32 <jimmyjazz14> tommd: that is exactly how I discovered this
14:03:41 <Axman6> pfo: because no one's written a 64 but version for OSX yet
14:03:52 <pikhq> pfo: Presumably because nobody's bothered doing the work on supporting x86_64-pc-darwin yet.
14:04:14 <pikhq> I can't imagine it being *too* much work, since there's already support for x86_64-pc-linux-gnu.
14:04:38 <pikhq> ABI work rather than new architecture work.
14:04:57 <Axman6> pikhq: it is a lot of work apparently, and none of the main developers are interested in doing it
14:05:11 <pikhq> Axman6: Hmm.
14:05:27 <Axman6> it's a big pain in the arse to be honest :)
14:05:31 <pikhq> I'd be willing if I had the knowledge. Unfortunately, code generators are not exactly my forte.
14:05:42 <pikhq> And I'm not at all familiar with the Darwin ABI stuff.
14:06:29 <Axman6> pikhq: me too
14:08:24 <jimmyjazz14> tommd: do you still consider that a bad habit?
14:17:13 <tommd> jimmyjazz14: I certainly do.
14:17:43 <jimmyjazz14> do you consider flipping ($) a bad habit ?
14:18:56 <malie> Axman6, seems 'infix 9 .' is lost after binding (.) in a let
14:19:20 <malie> ahm infixr 9 .
14:29:07 <byorgey> malie: yes, because the (.) bound in the let is a *different* (.)
14:29:08 <lavish> hi all! Can you give an help to a bl00dy n00b? I'm trying simple stuff under ghci. Why do I get "*** Exception: user error (Prelude.readIO: no parse)" using "do { n <- readLn ; print (n) }"?
14:29:36 <lavish> this works very well:
14:29:36 <lavish> Prelude> do { n <- readLn ; print (n+1) }
14:29:36 <lavish> 2
14:29:36 <lavish> 3
14:29:52 <byorgey> malie: you can actually put fixity declarations in a let too
14:29:55 <lavish> Is not possible to just print the value I wrote?
14:30:10 <byorgey> so you can say   let { (.) = fmap; infixr 9 .  in  succ . "HI" }
14:30:25 <Lemmih> lavish: It is if you use 'getLine'.
14:30:26 <byorgey> whoops, sorry, that should be   let { (.) = fmap; infixr 9 . } in  succ . "HI"
14:30:27 <malie> interesting
14:31:35 <ben_m> lavish
14:31:38 <ben_m> :t readLn
14:31:40 <lambdabot> forall a. (Read a) => IO a
14:31:53 <ben_m> readLn doesn't know what type you expect in the first example
14:32:01 <ben_m> In the second example it can infer the type, because you use it with (+)
14:32:08 <malie> :t (+)
14:32:09 <lambdabot> forall a. (Num a) => a -> a -> a
14:32:18 <lavish> ben_m: oh thanks!
14:32:18 <ben_m> You'd have to write print (n :: Int)
14:32:42 <byorgey> in practice in the first example I think it chooses the type ()
14:32:52 <byorgey> which is why you get a 'no parse' error, because "2" does not parse as a value of type ()
14:33:29 <lavish> got it
14:33:32 <lavish> thank you all
14:34:21 <malie> if you use the parse result in + how does read know what kind of Num to parse?
14:34:46 <Lemmih> malie: It defaults to Integer.
14:36:18 <jimmyjazz14> so I make (|-) = flip ($) , so now I can do: users |- getUser "andrea" |- home_dir |- takeBaseName
14:36:23 <jimmyjazz14> am I a bad person?
14:37:30 <gOcOOl> how do I concatenate 2 bytetsring? For plain stings I can use (++) but not sure what to use for bytestrings
14:37:40 <gOcOOl> *bytestrings
14:38:16 <Lemmih> gOcOOl: Data.ByteString.append
14:39:09 <gOcOOl> perfect, thank you!
14:44:39 <Axman6> @hoogle ByteString -> ByteString -> ByteString
14:44:40 <lambdabot> Data.ByteString append :: ByteString -> ByteString -> ByteString
14:44:40 <lambdabot> Data.ByteString.Char8 append :: ByteString -> ByteString -> ByteString
14:44:40 <lambdabot> Data.ByteString.Lazy append :: ByteString -> ByteString -> ByteString
14:45:14 <Axman6> :t (>>>)
14:45:15 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
14:52:13 <thoughtpolice> copumpkin: i think i might have a bit of time this weekend to work on GHC if you'd like :P
14:52:19 <copumpkin> yayayay
14:52:34 <jmcarthur_work> whatcha doing to it?
14:52:47 <thoughtpolice> although I read a mail on ghu about validate being broken for OSX/linux HEAD right now
14:52:50 <thoughtpolice> 64bit port
14:52:53 <thoughtpolice> it is too long overdue
14:53:07 <jmcarthur_work> you must mean for os x?
14:53:10 <copumpkin> yeah
14:53:11 <thoughtpolice> i'm kind of over the hump with some of my projects right now so it would be a good time
14:55:38 <Axman6> thoughtpolice: hooray :D
14:56:41 <thoughtpolice> if only I used haskell@work, then I could hack on GHC all day long and just say that i'm "writing compiler magics!" to my boss :)
14:58:33 <thoughtpolice> also my machines at work are badass so build times would be very quick which would rock for fast turn around :)
14:59:53 * mmorrow thinks that companies that use haskell need to start shelling out money for people to work on ghc
14:59:58 <copumpkin> damn right
15:00:06 <copumpkin> they already kinda do, through the IHG
15:00:23 <mmorrow> 3 paid developers is pretty ridiculous, given the expectations put on ghc
15:00:32 <Axman6> indeed
15:00:48 <copumpkin> I'd contribute some dough of my own towards projects I'm interested in
15:00:48 <fbru02> i have a question : i have two ADTs and two instances a = W1 3 b = W2 6  ... i want to obtain the sum of both as in c = a + b = W1 W2 9 .. how can i do this ?
15:00:51 <copumpkin> not that I have very much of it
15:01:00 <kmc_> how hard is it to start contributing to ghc?
15:01:15 <copumpkin> kmc_: depends what part... it's mostly very well documented, but it's still a massive project
15:01:17 <skorpan> if i could get my name in the docstring for Data.Map.map i'd donate ;P
15:01:29 <Axman6> fbru02: i'm not sure what you asked made any sense :\
15:02:33 <fbru02> Axman6:  i mean is there a way to "lift" into both types so i can get a sum of what is inside (in this case integers)
15:02:54 <fbru02> about ghc , the wisest decision the can make for more contributions is go to git IMHO
15:02:58 <copumpkin> so you want some sort of common supertype?
15:03:11 <Axman6> fbru02: i'd need to know what your types are, and what results you'd expect for what inputs
15:03:59 <fbru02> Axman6: something like data W1 x = W1 x deriving Show data W2 y = W2 y deriving Show
15:04:08 <Axman6> fbru02: they already use darcs (i think)
15:04:20 <fbru02> copumpkin : yes
15:04:32 <copumpkin> I don't think converting to git would help much, and I'm primarily a git user
15:04:39 <Axman6> fbru02: and what do you want the result to be from (W1 1) + (W2 2)?
15:04:48 <copumpkin> bbiab
15:04:57 <fbru02> W1 W2 3
15:04:58 * Axman6 refuses to use git because of its namesake
15:05:15 <Axman6> fbru02: W1 (W2 3)?
15:05:24 * jmcarthur_work switched from primarily git to primarily darcs
15:05:26 <fbru02> yes
15:05:51 <blackdog> copumpkin: I think it could help, but mostly because of github and all the nice tools you get there... i should really check out patch-tag.com, i suppose.
15:06:17 <Axman6> well, you could easily write that function: myPlus (W1 x) (W2 y) = W1 (W2 (x+y))
15:06:30 <jmcarthur_work> patch-tag is not anywhere near as nice as github :(
15:06:53 <fbru02> Axman6: thanks i was wondering if somehow i could fmap-it or make instance of monad and return it
15:07:09 <fbru02> Axman6: i don't why i got it in my head to do it one of those ways
15:07:12 <Axman6> sounds needlessly complicated
15:07:59 <blackdog> Axman6: its namesake?
15:08:11 <Axman6> blackdog: linus, who is a complete git :)
15:08:44 <leimy> Hmmm
15:08:52 <blackdog> jmcarthur_work: yeah, it was surprising to me how helpful it was to have all the stuff github puts up - of course you could put up your own bug tracker etc, but to get it for no effort is fantastic.
15:09:00 <leimy> I've somehow gotten myself into a place where I now have IO (IO ())
15:09:07 <leimy> oopsie!
15:09:11 <Axman6> join!
15:09:13 <mmorrow> join FTW!
15:09:22 <blackdog> Axman6: I bet you use Linux somewhere, though
15:09:34 <Axman6> i have fedora on my thinkpad
15:09:39 <Axman6> but i never use my thinkpad
15:09:45 <mmorrow> i have fedora on my thinkpad
15:09:52 <mmorrow> i always use my thinkpad
15:09:53 <fbru02> Axman6: you use windows?
15:09:53 <mmorrow> :)
15:09:56 <kmc_> leimy, there's an obligatory meme... i will spare you all
15:10:03 <leimy> heh
15:10:05 <Axman6> fbru02: god no... well only for gaming
15:10:12 <fbru02> Axman6: osx?
15:10:16 <Axman6> of course ;)
15:10:22 <zygospasm> fbru02: you can do that with fmap.
15:10:33 <leimy> well I figured I could use join or "id <$>
15:10:34 <kmc_> anyway there are things you can do with IO (IO ()) other than join it
15:10:35 <fbru02> :) have tried compiling 6.12 under SN ?
15:10:44 <mmorrow> Axman6: what kind of thinkpad do you have
15:10:45 <mmorrow> ?
15:10:45 <fbru02> zygospasm: really ? :) :)
15:10:47 <leimy> In this case I think I want to join it.
15:11:10 <kmc_> :t (id <$>)
15:11:11 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
15:11:13 <leimy> Oh I can't do applicative stuff here :-)
15:11:19 <Axman6> mmorrow: R51. old skool IBM one
15:11:21 <leimy> it won't undo my need to join :-)
15:11:25 <mmorrow> @pl \f m -> join (fmap f m)
15:11:25 <lambdabot> (=<<)
15:11:26 <Berengal> Will learning agda turn me away from haskell the way haskell turned me away from other languages?
15:11:27 <leimy> applicative doesn't cut deeply enough
15:11:38 <mmorrow> Axman6: ah nice
15:11:48 <Axman6> it's chunky
15:11:54 <mmorrow> Axman6: i've got an X301 with a solid-state drive.. soo nice
15:12:09 <kmc_> mmorrow, is that one of the 1.8" drives?
15:12:13 <mmorrow> and an X60 (which was my previous main)
15:12:21 <kmc_> i have an X200s with SSD
15:12:24 <zygospasm> fbru02: one plan of attack would be: (W1 a, W2 b) ~> W1 (a, W2 b) ~> W1 (W2 (a+b))
15:12:30 <kmc_> iirc the lenovo OEM SSDs are the crap Samsung ones
15:12:41 * mmorrow checks
15:13:01 <kmc_> Intel makes a nice SSD for cheap, but the 1.8" are impossible to find, which is frustrating a friend of mine who has a T400s
15:13:07 <fbru02> zygospasm: sorry if i'm a noob ~> is an arrow right ?
15:13:20 <zygospasm> fbru02: it's just exposition about how we're doing it
15:13:21 <Axman6> morning ChilliX
15:13:29 <zygospasm> fbru02: ~> roughly means "do something with fmap"
15:13:31 <ChilliX> Heya Axman6
15:13:36 <zygospasm> fbru02: in this particular usage :)
15:14:18 <fbru02> zygospasm: thanks i will try that :)
15:14:29 <FunctorSalad> why does System.Process.readProcess fork a thread to read from the program's stdout, then starts writing to the stdin?
15:14:43 <FunctorSalad> (why can't you just write to stdin, then read from stdout?)
15:14:44 <mmorrow> [m@monire ~]$ cat /proc/scsi/scsi Attached devices: Host: scsi0 Channel: 00 Id: 00 Lun: 00 Vendor: ATA      Model: SAMSUNG MMCQE28G Rev: VAM0 Type:   Direct-Access                    ANSI  SCSI revision: 05
15:14:49 <zygospasm> fbru02: spoiler: \w1 w2 -> fmap (\a -> fmap (\b -> a + b))
15:14:51 <mmorrow> kmc_: yeah, samsung
15:15:07 <fbru02> zygospasm: nice :)
15:15:18 <zygospasm> @type \w1 w2 -> fmap (\a -> fmap (\b -> a + b) w2) w1
15:15:19 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *). (Num a, Functor f, Functor f1) => f1 a -> f a -> f1 (f a)
15:15:30 <mmorrow> kmc_: i dunno about whether it's an 1.8" or not
15:16:53 <thoughtpolice> mmorrow: ooo! i just ordered an X200
15:16:58 <thoughtpolice> it should be here friday at the latest :)
15:17:23 * thoughtpolice went for thinkpads because they have quality linux support as far as wireless drivers etc. go
15:18:39 <mmorrow> thoughtpolice: yeah, thinkpads are awesome, although on my X60 and X301 i've got the intel wifi card whose driver fedora doesn't have by default, so i have to compile it every time i upgrade my kernel
15:18:46 <blackdog> thoughtpolice: I've got a lot of affection for the old thinkpads. solid machines...
15:19:02 <mmorrow> the keyboards are really nice too
15:19:06 <blackdog> got a macbook pro now, and i'm still horribly precious about it
15:19:41 <thoughtpolice> mmorrow: those 301s look nice, but I went for the x200 because I wanted something that was lighter than my MBP, and roughly as powerful. i also personally like the trackballs more than touchpads, and i'll be installing xmonad anyway so it's used space for the most part I think :)
15:19:58 <mmorrow> thoughtpolice: *compile it + need the binary blob
15:20:10 <fbru02> to all of haskell programmers under osx ? did you try to build 6.12 on SL ?
15:20:10 <thoughtpolice> mmorrow: what wireless card?
15:20:12 <mmorrow> i hate the touchpad, never use it
15:20:30 <blackdog> fbru02: deliberately avoided upgrading because i didn't want to go through the hassle...
15:20:47 <kmc_> it's amazing how well a machine designed to run Vista + OEM bloatware runs GNU/Linux with XMonad
15:20:53 <mmorrow> thoughtpolice: the X60 has the iw3945, the X301 iirc has an iw59something
15:21:20 <jlouis> I am on a T500 here. Heavy, but fast.
15:21:38 <kmc_> also, Kingston is selling a rebranded 40GB Intel X25 SSD for under $100.  40GB is of course sheer madness if you run Windows, but my enitre system is using about 8GB right now
15:22:32 <thoughtpolice> mmorrow: even though I will be developing for work etc on it I think the screen size is good enough. my MBP is technically *less* powerful anyway, so it's lighter and faster :P
15:22:45 <MyCatVerbs> kmc_: I run XP inside of 40GB. It's merely very annoying when swapping between videogames. :)
15:23:03 <thoughtpolice> but it has a decent mobile graphics card + much better resolution which is preferrable for some stuff
15:23:09 * MyCatVerbs steals Â½ and hugs.
15:23:13 <mmorrow> thoughtpolice: MBP? /me scans brain store of acronyms..
15:23:16 <MyCatVerbs> Wrong window, oops.
15:23:18 <thoughtpolice> (the x200 comes with a 12.1" i think)
15:23:22 <thoughtpolice> mmorrow: macbook pro
15:23:25 <mmorrow> ah
15:24:33 <thoughtpolice> but yes, i have heard mostly nothing but praise for the thinkpad line wrt quality. the price was decent too, cheaper than this thing actually
15:24:51 <kmc_> i have had bad experiences with their service people
15:24:58 <kmc_> but it's not like a Dell where you have to send it in every few months
15:25:07 <thoughtpolice> mmorrow: re: wireless, I ordered a intel wifi link 5300, which has kernel support in 2.6.27+ i think: http://lkml.org/lkml/2008/8/13/435
15:25:33 <kmc_> also, you can't blame the communists... service is still handled right here in the U S of A, specifically the South
15:25:42 <thoughtpolice> mmorrow: how old is your x301? on the site it looks like they come with the exact same card?
15:26:17 <kmc_> thoughtpolice, i have the 5300 or perhaps 5100, worked out of the box in debian unstable with iwlwifi.ko
15:26:22 <kmc_> err, iwlagn.ko
15:26:46 <mmorrow> thoughtpolice: just looked, mine has an "Intel PRO/Wireless 5350"
15:27:00 <mmorrow> thoughtpolice: so i guess iw5350
15:27:08 <thoughtpolice> "Note: The iwlwifi driver has been merged into mainline kernel since 2.6.24. If you are using kernels after this release, please use the intree (drivers/net/wireless/iwlwifi) driver directly. After 2.6.26 the intree driver iwlagn also supports the new 5100BG, 5100ABG, 5100AGN, 5300AGN, 5350AGN, 5150AGN, 1000BGN, and 6000AGN series hardwares. " -- intelllinuxwireless.org
15:27:16 <mmorrow> thoughtpolice: i got it in march
15:27:38 <mmorrow> thoughtpolice: yeah, that's so annoying. apparently fedora's kernels don't have that module by default
15:27:43 <thoughtpolice> :(
15:28:40 <mmorrow> thoughtpolice: so i have to get the binary blob and kernel module from <i don't recall.com> (i always just compile the same one i have saved in a directory) and build it every time i get a new kernel via yum
15:28:58 <mmorrow> well, you only need to get the binary blob once, and all kernels will use it
15:29:47 <mmorrow> kmc_: yeah, debian and ubuntu have the needed driver (and the binary blob) by default
15:30:18 <thoughtpolice> well, good :)
15:30:30 <thoughtpolice> i was pretty much going to have to go debian i think
15:30:51 <thoughtpolice> i would like archlinux but i need my linux machine to support our product and installers aren't build for archlinux ;(
15:31:11 <kw317> hmm.. I'm trying to guild GHC from sources and I'm getting Undefined symbols error with "_base_GHCziConc_ioManagerThread_closure" missing.. any ideas what should I try to do about it?
15:31:30 <jlouis> thoughtpolice: paravirtualization and buildbot :P
15:31:32 <mmorrow> kw317: what version are you building what version with?
15:31:53 <thoughtpolice> jlouis: if xen would get merged mainline that would be awesome
15:32:04 <jlouis> Does the GHC project have a buildbot?
15:32:10 <jlouis> KVM :)
15:32:13 <mmorrow> jlouis: yeah
15:32:14 <jlouis> screw Xen
15:32:16 <kw317> mokus: I'm using 6.12 to build HEAD
15:32:22 <thoughtpolice> there was talk about it for the 2.6.30 merge window but there was never a conclusion i think, after the person proposing it made some very good points I think the thread died :(
15:32:35 <kw317> mmorrow: ^^
15:32:39 <mmorrow> kw317: hmm, ask in #ghc
15:32:53 <kw317> OK
15:32:55 <kw317> thanks
15:32:58 <mmorrow> :)
15:33:10 <thoughtpolice> jlouis: there seemed to be some good reasons for xen to be desirable, let me see if I can find the link...
15:33:27 <jlouis> I've head of an impressive buildbot setup where each build on a "foreign" architecture happens inside a KVM virtualized box
15:34:00 <jlouis> thoughtpolice: thanks
15:35:27 <luite> is there a way to make this kind of thing less 'indenty'? http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=11803#a11803
15:36:02 <thoughtpolice> jlouis: http://lwn.net/Articles/321696/
15:36:05 <kmc_> luite, none of that indentation is mandatory
15:36:14 * thoughtpolice should really buy a lwn subscriber link, their articles are so informative...
15:36:20 <luite> kmc_: yes I know, but not indenting doesn't change the structure
15:36:32 <kmc_> so you want a different structure as well?
15:36:54 <kmc_> where is withArray defined?
15:37:01 <tommd> @hoogle withArray
15:37:02 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
15:37:02 <lambdabot> Foreign.Marshal.Array withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
15:37:02 <lambdabot> Foreign.Marshal.Array withArrayLen :: Storable a => [a] -> (Int -> Ptr a -> IO b) -> IO b
15:37:07 <tommd> there
15:37:09 <Saizan> luite: you could use ContT and do-notation :)
15:37:31 <kmc_> Saizan, woah, i'd like to see that if you've got a sec
15:37:48 <thoughtpolice> jlouis: here's the one that seemed to be real significant: " Xen's approach to page tables eliminates the need for shadow page tables or page table nesting in the guests; that, in turn, allows for significantly better performance for many workloads. "
15:38:05 <luite> Saizan: ah that is one monad I haven't dared touching yet :p
15:38:50 <jlouis> thoughtpolice: interesting
15:38:58 <thoughtpolice> jlouis: unfortunately it was not merged :(
15:39:09 <jlouis> thoughtpolice: Though I would have to look into what a client like KVM does instead
15:39:15 <mmorrow> @type ContT . Foreign.withArray
15:39:16 <lambdabot> forall r a. (Foreign.Storable.Storable a) => [a] -> ContT r IO (GHC.Ptr.Ptr a)
15:39:24 <tommd> thoughtpolice: It still isn't dead and even if it does die atleast it lived long enough to spawn HaLVM.
15:39:27 <thoughtpolice> kvm seems really simple though, which is useful :)
15:39:44 <thoughtpolice> tommd: when will halvm be available?! :)
15:40:00 <Saizan> kmc_, luite: something like this http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=11803#a11804
15:40:09 <mmorrow> @type let withA = ContT . Foreign.withArray in \f -> do a1 <- withA [0..9]; a2 <- withA [0..42]; f a1 a2
15:40:09 <tommd> toughtpolice: I used to ask that every month.  The answer has been "Its up to dons" for a long time.
15:40:09 <lambdabot> forall t r b t1. (Foreign.Storable.Storable t, Foreign.Storable.Storable t1, Num t, Enum t, Num t1, Enum t1) => (GHC.Ptr.Ptr t -> GHC.Ptr.Ptr t1 -> ContT r IO b) -> ContT r IO b
15:40:27 <tommd> Bug him enough and reap the rewards.
15:40:41 <tommd> (hopefully he doesn't read this and kill me over it ;-)
15:40:46 <thoughtpolice> :(
15:41:14 <kmc_> Saizan, thanks
15:41:32 <tommd> thoughtpolice: You wouldn't happen to have any time for extra projects, would you?
15:42:13 <Saizan> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=11803#a11806 <- this one actually typechecks :)
15:43:49 <mmorrow> @type let withA = ContT . Foreign.withArray in \f -> f <$> withA [0..9] a2 <*> withA [0..42]
15:43:50 <lambdabot> Not in scope: `a2'
15:43:56 <mmorrow> @type let withA = ContT . Foreign.withArray in \f -> f <$> withA [0..9] <*> withA [0..42]
15:43:57 <lambdabot> forall b t r t1. (Foreign.Storable.Storable t, Foreign.Storable.Storable t1, Num t, Enum t, Applicative (ContT r IO), Num t1, Enum t1) => (GHC.Ptr.Ptr t -> GHC.Ptr.Ptr t1 -> b) -> ContT r IO
15:43:57 <lambdabot> b
15:44:53 <Saizan> + a join, since f is monadic
15:45:00 <mmorrow> ah, right
15:45:15 <mmorrow> @let f <!> a = join (f <*> a)
15:45:16 <lambdabot>  Defined.
15:45:18 <kmc_> :t ContT . Foreign.withArray
15:45:19 <lambdabot> forall r a. (Foreign.Storable.Storable a) => [a] -> ContT r IO (GHC.Ptr.Ptr a)
15:45:21 <mmorrow> @type let withA = ContT . Foreign.withArray in \f -> f <$> withA [0..9] <!> withA [0..42]
15:45:22 <lambdabot>     Couldn't match expected type `a1 -> ContT r IO a'
15:45:22 <lambdabot>            against inferred type `GHC.Ptr.Ptr t'
15:45:22 <lambdabot>       Expected type: ContT r IO (a1 -> ContT r IO a)
15:45:26 <mmorrow> grr
15:45:38 <kmc_> @unmtl ContT
15:45:38 <lambdabot> err: `ContT' is not applied to enough arguments, giving `/\A B C. (C -> B A) -> B A'
15:45:44 <kmc_> @unmtl ContT r IO
15:45:45 <lambdabot> err: `ContT r IO' is not applied to enough arguments, giving `/\A. (A -> IO r) -> IO r'
15:45:53 <mmorrow> @type \f a b c -> f <$> a <*> b <!> c
15:45:54 <lambdabot> forall a a1 b (f :: * -> *) a2. (Applicative f, Monad f) => (a -> a1 -> b) -> f a -> f (a2 -> f a1) -> f a2 -> f b
15:46:05 <mmorrow> gah
15:46:05 <kmc_> :t (<!>)
15:46:07 <lambdabot> forall (m :: * -> *) a a1. (Applicative m, Monad m) => m (a -> m a1) -> m a -> m a1
15:46:16 <mmorrow> i botched (<!>)
15:46:28 <luite> Saizan: thanks :)
15:46:29 <kmc_> @unmtl ContT r IO a
15:46:30 <lambdabot> (a -> IO r) -> IO r
15:46:34 <mmorrow> @undefine
15:46:36 <mmorrow> sry
15:47:58 <mmorrow> gah, i can't remember (<!>) was
15:48:01 <mmorrow> *what
15:48:39 <mmorrow> (\f a b c -> f <$> a <*> b <!> c) :: (a -> b -> c -> m d) -> m a -> m b -> m c -> m d
15:48:50 <mmorrow> + the typeclass constraints
15:49:20 <benmachine> 23:45:15 < mmorrow> @let f <!> a = join (f <*> a)
15:49:25 <benmachine> that looks silly though
15:49:30 <benmachine> if you're using join, why not use ap
15:49:37 <mmorrow> right but that didn't work i thought
15:49:51 <benmachine> I don't know I only just got here
15:49:56 <benmachine> but in most cases they are the same
15:50:15 <benmachine> er
15:50:18 <mmorrow> right, ap or <*>, but that didn't give me the type i was going for
15:50:18 <benmachine> by which I mean
15:50:22 <benmachine> oh ok
15:50:29 <mmorrow> i thought
15:50:35 <benmachine> @type \f a -> join (f <*> a)
15:50:37 <lambdabot> forall (m :: * -> *) a a1. (Applicative m, Monad m) => m (a -> m a1) -> m a -> m a1
15:50:40 <benmachine> @type \f a -> join (f `ap` a)
15:50:41 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m (a -> m a1) -> m a -> m a1
15:51:04 <mmorrow> @type let f <!> a = join (f `ap` a) in (\f a b c -> f <$> a <*> b <!> c)
15:51:05 <lambdabot> forall a a1 b (f :: * -> *) a2. (Monad f, Applicative f) => (a -> a1 -> b) -> f a -> f (a2 -> f a1) -> f a2 -> f b
15:51:41 <benmachine> o'course, if you wanted it to actually make a difference you'd need to use liftM and ap for those other things as well
15:52:04 <jlouis> (f :: * -> *) is a kind description, right?
15:52:08 <Saizan> @type let f <!> a = join (f `ap` a) in (\f a b c -> ((f <$> a) <*> b) <!> c)
15:52:09 <lambdabot> forall a a1 a2 (m :: * -> *) a3. (Monad m, Applicative m) => (a -> a1 -> a2 -> m a3) -> m a -> m a1 -> m a2 -> m a3
15:52:20 <mmorrow> ohhh, right
15:52:32 <benmachine> oh heh
15:52:32 <mmorrow> i forgot that it needed the appropriate fixity decl too
15:52:39 <Saizan> jlouis: yeah, a kind signature
15:52:41 <benmachine> <$> and <*> are both infixl 4 I think
15:53:26 <mmorrow> @let f <!> a = join (f `ap` a); infixl 4 <!>
15:53:27 <lambdabot>  Defined.
15:53:36 <mmorrow> @type (\f a b c -> f <$> a <*> b <!> c)
15:53:37 <lambdabot> forall a a1 a2 (m :: * -> *) a11. (Applicative m, Monad m) => (a -> a1 -> a2 -> m a11) -> m a -> m a1 -> m a2 -> m a11
15:53:40 <mmorrow> wee
15:56:58 <benmachine> a11 :o
15:57:13 * benmachine 'd've thought a3 would have been just fine
15:58:08 <Axman6> > let findDups [] = []; findDups (x:xs) = if x `elem` xs then x : findDups (filter (/=x) xs) else findDups xs in findDups (maxBound:[0..maxBound :: Word8])
15:58:10 <lambdabot>   [255]
15:58:16 <Axman6> > let findDups [] = []; findDups (x:xs) = if x `elem` xs then x : findDups (filter (/=x) xs) else findDups xs in findDups (maxBound:[0..maxBound :: Word16])
15:58:22 <lambdabot>   mueval: ExitFailure 1
15:58:32 <Axman6> O(n^2)++!
15:58:38 <acowley> Can someone with uvector experience please help me figure out what's wrong here: http://haskell.pastebin.com/m4e64c6ba
16:01:42 <Axman6> hmm, does Bool have a UA instance? (or whatever it is)
16:01:49 <acowley> Yes
16:02:08 <acowley> http://hackage.haskell.org/packages/archive/uvector/0.1.0.4/doc/html/Data-Array-Vector-UArr.html
16:02:41 <Axman6> hmm, time to talk to dons/copumpkin i think
16:03:43 <acowley> okay, thanks
16:04:03 <luite> acowley: you might want to reinstall uvector with -fsafe for debugging
16:05:14 <acowley> I'll give that a shot
16:05:23 <acowley> This originally started because I was getting a seg fault in some code
16:05:28 <luite> don't know if that can catch where this goes wrong though
16:05:39 <acowley> and I shrunk my test case down to this, which doesn't segfault, but does give erroneous output
16:09:01 <luite> hm, are you allowd to memcpyOffMU from and to the same array?
16:09:41 <luite> assuming bools are stored packed, you could end up working on the same word
16:11:28 <luite> acowley: ah it is, you should use mmoveOffMU
16:11:38 <luite> memmoveOffMU
16:12:17 <acowley> I tried that luite
16:13:34 <acowley> I agree that the possibility of overlapped words for bit-packed data seems the likely culprit here
16:13:46 <acowley> but neither option is working for me
16:17:05 <luite> ok, I can reproduce it
16:23:50 <luite> acowley: there appears to be some bug in calculating the offsets
16:25:11 <luite> the second example copies bytes 0..3 from the source array, the first copies bytes 3..7
16:27:30 <acowley> Wow, that's not at all what I would have expected the problem to be
16:27:49 <acowley> so it copied the wrong number of bytes from the wrong offset?
16:28:52 <luite> acowley: oh sorry, the number of bytes seems correct
16:29:05 <luite> so it copies bytes 3..6
16:29:26 <acowley> that's still an odd place for it to start copying from
16:30:29 <mmorrow> um, what are the Int args for memmove/memcpy there? (size,off1,off2) or (off1,off2,size) ?
16:30:43 <mmorrow> it doesn't seem to say in the docs
16:30:52 <mmorrow> (just eliminating trivial possibilities)
16:30:53 <acowley> I assumed the latter from a quick look at the source
16:32:18 <acowley> The variable names are "s", "d", and "l"
16:32:30 <acowley> which I took to be sourceOffset, destOffset, length
16:32:35 <luite> source, destination, length
16:33:18 <luite> do you mean the C function memcpy or the uvector one? :)
16:33:51 <acowley> hah, uvector
16:34:29 <luite> I'm pretty sure though that this will be a problem, because ultimately, uvector (BUArr.hs) calls the C function memmove or memcpy on some calculated offset and byte range
16:35:21 <acowley> You mean the problem that memmoveOffMU must be used?
16:36:32 <luite> oh wait, I doesn't seem to be a problem, I think it packs only 1 bit per byte
16:37:16 <luite> oh it doesn't :p
16:37:27 <luite> hmm, let me load it in ghci before making too many assumptions :)
16:37:37 <mmorrow> uhoh, either i'm missing something or the uvector code isn't doing byteArrayContents# before passing the MutableByteArray# to C memmove/memcpy
16:38:17 <mmorrow> so it's overwriting the one-word infoptr if this is really what's happening
16:38:45 <acowley> Which would explain my segfaults in the larger program
16:39:00 <mmorrow> (i'm looking in Data.Array.Vector.Prim.BUArr and memcpy_extra.c)
16:39:22 <Axman6> sounds like a patch is coming...
16:40:19 <mmorrow> yeah, it looks like this is what's happening (unless GHC implicitly does a byteArrayContents# when an arg to an ffi-imported C function is a MutableByteArray#, which i don't think is the case)
16:40:53 <Boney> I'm trying to build ThreadScope, it required gtk glade and cairo
16:41:05 <Boney> I can't find these on the Hackage website.
16:41:08 <Boney> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:gui
16:41:12 <Boney> where can I get them?
16:41:15 <Axman6> they're part of gtk2hs
16:41:32 <luite> mmorrow: but it doesn't appear to cause this specific problem
16:41:59 <mmorrow> luite: right
16:42:19 <Boney> Axman6: that doesn't appear to be listed only gtk2hs-cast-* and gtk2hsGenerics
16:42:40 <Axman6> gtk2hs isn't on hackage
16:42:44 <Axman6> http://www.haskell.org/gtk2hs/
16:42:48 <Boney> thanks.
16:43:13 <mmorrow> luite: err, actually i was just trying to figure that out, are you sure it isn't?
16:43:20 <Boney> How are people expected to find this?  And to know that, for example, cairo is provided by gtkhs
16:43:26 <Boney> err, gtk2hs
16:43:48 <mmorrow> it's non-trivial to tell since the rep is determined by the type
16:43:56 <acowley> mmorrow: Where exactly are you looking?
16:44:09 * mmorrow is sifting through the Int and Bool instances of UAE/etc to see
16:44:17 <luite> mmorrow: I'm not sure anymore now :p
16:44:37 <acowley> memcpyOffMBU pattern matches the MutableByteArray# out of the MBUArr data, doesn't it?
16:45:13 <dcolish> is there a prefered lib for working with restful apis?
16:45:16 <mmorrow> acowley: trying to figure out if, given the instances for Bool and for Word8, the behavior in your paste is cause by not doing byteArrayContents# on the MutableByteArray# that gets passed to the C memmove wrapper in memcpy_extra.c
16:45:30 <mmorrow> or whether it's caused by another bug completely
16:46:18 <mmorrow> acowley: right
16:46:24 <acowley> I see, but what's confusing me is that the imported memcpyOffset function takes  MutableByteArray# as parameters
16:46:59 <mmorrow> acowley: the sOff and dOff though are determined by sizeBU, which in turn is provided by the particular instances
16:47:09 <acowley> so I don't really understand why the byteArrayContents# would be needed (Note: I have no knowledge of byteArrayContents#)
16:47:29 <mmorrow> acowley: a MutableByteArray# (and a ByteArray#, same layout) are
16:47:39 <mmorrow> {infoptr,contents}
16:47:54 <acowley> ah
16:48:05 <mmorrow> and an (a :: MutableByteArray# s) if a ptr to the start
16:48:05 <acowley> but then the types for the imported functions are wrong?
16:48:15 <luite> ghci complains about unacceptable argument types for the ffi functions
16:48:16 <mmorrow> acowley: exactly
16:48:16 <luite> :(
16:48:29 <luite> (which are the MutableByteArray arguments)
16:48:34 <mmorrow> acowley: the imports should really be taking Addr#'s
16:49:28 <mmorrow> luite: iirc you need either -fglasgow-exts or another extension + -fobject-code for ghci
16:49:55 <luite> mattam: ah that did the trick
16:49:58 <luite> sorry mmorrow
16:49:58 <mmorrow> -XUnboxedForeignTypes or something
16:50:03 <mmorrow> nice
16:52:03 <mmorrow> err, the header for a (Mutable)ByteArray# actually also includes the length iirc, but that doesn't change anything here
16:53:51 <mmorrow> so the fix here for this particular bit would be to s/MutableByteArray# s/Addr#/ in the ffi imports
16:54:11 <acowley> Yeah, I'm in the midst of trying that
16:54:11 <mmorrow> and to do byteArrayContents# on the MutableByteArray#'s before handing them to C
16:54:29 <mmorrow> you'll have to unsafeCoerce# the MutableByteArray#s though to use them with byteArrayContents#
16:54:42 <mmorrow> since it's :: ByteArray# -> Addr#
16:54:48 <acowley> mmorrow: I was about to ask you that
16:54:51 <acowley> mmorrow: :)
16:54:57 <mmorrow> the layouts are exactly the same
16:54:58 <mmorrow> :)
16:57:03 <benmachine> ohh dang it
16:57:20 <benmachine> I clicked reply instead of reply-to-all when sending a response to a haskell-cafe email
16:57:28 <benmachine> what is the usual protocol for such a situation
16:57:46 <benmachine> (it only went to the original poster)
16:57:54 <benmachine> do I re-send it to the list so some guy gets two copies
16:57:57 <lament> make a scene
16:57:58 <mmorrow> i always just resend the exact same thing with a reply-to-all
16:58:04 <medfly> it's just one guy
16:58:06 <mmorrow> (since i do that all the time)
16:58:11 <benmachine> heh okay
16:58:27 * Axman6 is a 90's kid, he doesn't understand email
16:58:41 <acowley> mmorrow: didn't seem to fix the small test case program, assuming I'm getting my latest build linked in
16:59:10 <mmorrow> acowley: dang, well at least that's one bug down, one to go ;)
16:59:19 <dancor> tweetman
16:59:46 <zygospasm> benmachine: i think... if you have a decent email client you might have a 'resend' button which will send with the same message-id; if the other guy also has a decent email client he won't get it twice
17:00:03 <mmorrow> acowley: does it change the behavior of the test-prog at all though?
17:00:35 <benmachine> zygospasm: wups too late
17:00:43 <benmachine> zygospasm: will keep that in mind for another time though
17:00:51 <benmachine> (email client: gmail)
17:01:00 <mmorrow> acowley: i'm 99.99% positive that ghc doesn't implicitly do a byteArrayContents# implicitly when a MutableByteArray# gets passed to a foreign import
17:01:18 <mmorrow> but if i'm wrong, then we just introduced rather than fixed a bug
17:01:29 <zygospasm> benmachine: the other guy is probably subscribed to -cafe so was likely to get two copies anyway ;-)
17:01:42 <acowley> mmorrow: well I'm stumped because I'm getting the same behavior
17:01:49 <acowley> mmorrow: which doesn't seem possible
17:02:02 <mmorrow> err, even if i'm wrong, then we'd still be ok
17:02:12 <mmorrow> since we'd just be making the byteArrayContents# explicit
17:02:20 <mmorrow> acowley: hmm, weird
17:02:38 <ivanm> you're allowed to have multiple modules in the same source file? :o
17:03:01 <benmachine> I've tried doing that
17:03:03 <mmorrow> acowley: are you sure you're using the newly built lib?
17:03:05 <luite> hmm, it really packs 8 bits per byte
17:03:05 <benmachine> I could never make it work
17:03:20 <luite> so copying 4 bits using memcpy or memmove will always be a problem
17:03:26 <mmorrow> luite: yeah, it's gotta be something to do with that
17:03:51 <mmorrow> some error computing the size in bytes to copy/move for a Bool UArr, since Bool uses bits
17:04:46 <mmorrow> oh. actually memcpy/memove can't really be used (exclusively) with Bool at all, since you'd still have to manually go in an flip/swap the bits
17:05:08 <luite> but even then, the implementation clearly does nothing to fix the issues at the ends of the boundaries, if you don't copy a whole number of bytes (or indeed shift all bytes if you copy/move over a nonintegral offset)
17:05:08 <acowley> usually this is done with masks and moves
17:05:24 <acowley> but, if it makes you guys feel any better, I still get the segfault in my larger program that uses UArr Bool
17:06:27 <mmorrow> hmm, so i think maybe a solution would be to provide a custom mem{cpy,move}OffMU methods in the Bool instance of UArr
17:06:31 <mmorrow> s/UArr/UA/
17:06:36 <mmorrow> that actually work :)
17:06:53 <luite> yes, or at least an error for now :)
17:08:03 <acowley> mmorrow: okay, I *am* using my fresh build
17:08:15 <acowley> mmorrow: and with 8 bits, it still doesn't work
17:08:21 <acowley> mmorrow: so it's not just a bit-packing issue
17:08:32 <luite> acowley: the calculated offsets are also strange
17:09:21 <mmorrow> there must be other parts of the Bool instance that rely on some default that doesn't take into account that the elements could be bits
17:09:23 <luite> it calculates 3 for the source offset, I guess because it is a 32 bit word and the first Bool is in the last byte of that word in my little endian machine :p
17:12:13 <luite> no that doesn't seem to be the case
17:12:27 <luite> it just increases to 4,5 etc
17:14:58 <luite> the pointers passed to the memcpy_offset or memmove_offset do seem to point to the correct information
17:15:32 <acowley> luite: The indexing code is taking me a while to grok
17:16:07 <luite> it has lots of # :p
17:16:14 <acowley> yeah :(
17:18:51 <acowley> so... indexBU looks strange to me
17:19:17 <copumpkin> I've spent quite a bit of time looking at that code
17:19:20 <copumpkin> if you have any particular questions
17:19:37 <acowley> Ah, a potential savior!
17:19:44 <luite> bOOL_SCALE 0 really should return 0 looking at the pointed data
17:19:58 <acowley> copumpkin: The original question is why this doesn't work: http://haskell.pastebin.com/m4e64c6ba
17:20:10 <luite> but it returns (0 + 4 * 8 - 1) >> 3 = 3
17:20:12 <copumpkin> oh yeah, there was a bug in that
17:20:20 <copumpkin> I thought it had been patched though
17:20:45 <luite> (on 32 bit, SIZEOF_HSWORD == 4)
17:20:52 <mmorrow> copumpkin: we just realized that the code was passing a ptr to the /start/ of the MutableByteArray#s to C memmove/cpy rather than the contents
17:21:07 <acowley> I just pulled the darcs from http://code.haskell.org/~dons/code/uvector
17:21:14 <copumpkin> I'm pretty sure I remember that bug and that it got patched, but maybe it got lost somehow?
17:21:35 <luite> mmorrow: that actually seems to work fine, if I dump the data when the memmove is called, the first byte contains the correct packed bools
17:21:39 <mmorrow> copumpkin: oh, if so then hackage still has the old version
17:21:44 <copumpkin> hmm
17:22:39 <mmorrow> luite: err, but without byteArrayContents# we'd be overwriting the header if the offset happened to fall within it
17:23:07 <mmorrow> (and the offsets would be wrong by sizeof(bytearray_header)
17:23:52 <luite> mmorrow: I just checked the bytes in the arrays. src[0] == 0xFF if I fill the UArr with replicate 8 True, and 0x00 with False
17:24:54 <acowley> mmorrow: and me fixing that problem didn't fix the test program
17:26:49 <FunctorSalad> can I wrap a forkIO in a 'catch' to handle things thrown from that thread in the main thread?
17:26:50 <mmorrow> typedef struct {StgHeader  header; StgWord    words; StgWord    payload[FLEXIBLE_ARRAY];} StgArrWords;
17:27:01 <mmorrow> copumpkin: yeah, there's another bug lurking in the Bool instance
17:27:08 <copumpkin> ah
17:27:13 <copumpkin> lots of bugs in there :)
17:27:16 <copumpkin> I never used the bool instance
17:27:26 <luite> apparently few people do :)
17:27:33 * acowley hides
17:28:00 <mmorrow> copumpkin: my guess is that the bug(s) are all caused by relying on some default functions that don't take into account that the elements could be bits (or that simply are incompatible with bit elements)
17:28:17 <acowley> What tempted me was the presence of andU and orU
17:28:33 <copumpkin> mmorrow: you might also want to check if they're present in the latest DPH code, which is what uvector is based on
17:29:08 <mmorrow> ah, i've been meaning to look at that code, now i have an excuse! :)
17:33:46 <kmc_> > map (fromEnum &&& id) ['A'..'Z']
17:33:47 <lambdabot>   [(65,'A'),(66,'B'),(67,'C'),(68,'D'),(69,'E'),(70,'F'),(71,'G'),(72,'H'),(7...
17:34:31 <performance> has any one here used Io the programming language?
17:35:17 <lament> if you count "played with it for five minutes"...
17:36:25 <luite> acowley: replacing where I# last# = SIZEOF_HSWORD * 8 - 1 by  where #I last# = 0 seems to fix the case where you copy a number of elements that is a multiple of 8
17:36:34 <luite> and the offset is also a multiple of 8
17:37:03 <lament> performance: ultimately I realized that Io had just too many brackets to be useful.
17:37:10 <luite> (that's line 922 in BUArr.hs)
17:38:38 <luite> acowley: replacing where I# last# = SIZEOF_HSWORD * 8 - 1 by  where #I last# = 0 seems to fix the case where you copy a number of elements that is a multiple of 8 (and the offsets are also a multiple of 8)
17:38:52 <luite> line 922
17:39:01 <acowley> luite: for bOOL_SCALE or bOOL_WORD_SCALE or both?
17:39:11 <luite> bOOL_SCALE
17:39:23 <luite> I'm not yet sure waht bOOL_WORD_SCALE should do :)
17:40:23 <acowley> luite: what's your interpretation of what bOOL_SCALE is doing, though?
17:40:39 <performance> i saw it for the first time today and just read their guide.  its amusing though:)
17:40:40 <luite> bOOL_WORD_SCALE doesn't seem to be used anywhere
17:40:57 <mmorrow> FunctorSalad: that'd only catch if the forkIO itself threw an exception
17:41:30 <luite> acowley: converts n (Int#), to the offset in bytes where element n of the Bool array can be fount
17:41:36 <luite> in the packed byte array
17:41:37 <mmorrow> FunctorSalad: you'd need to catch it in the forked thread, and propogate that to the main-thread somehow
17:41:58 <acowley> luite: right
17:42:25 <mmorrow> FunctorSalad: hmm, actually i don't think there's any way to catch an exception thrown in a forked thread in the main thread, other than to use the global uncaughtExceptionHandlere
17:42:28 <mmorrow> s/e//
17:42:49 <mmorrow> (or to just catch it in the forked thread)
17:42:55 <acowley> luite: oh my
17:42:59 <acowley> luite: this made things worse for me!
17:43:08 <luite> oh, which platform?
17:43:15 <FunctorSalad> mmorrow: there is this 'throwTo' thing... but yeah I could just catch in the forced thread and store the exception in an mvar
17:43:19 <FunctorSalad> *forked
17:43:21 <luite> oh wait, your test case copies only 4 bits
17:43:22 <acowley> luite: Now test1 doesn't work at all. Even the first 4 data are wrong.
17:43:29 <luite> yes that's correct
17:43:31 <acowley> luite: x86, 32-bit, ghc 10.6.4
17:43:36 <acowley> luite: oops
17:43:42 <acowley> luite: yup
17:43:47 <mmorrow> FunctorSalad: that or have a (Chan SomeException)
17:43:49 <acowley> luite: my new test3 (8 bits) works
17:43:52 <luite> the original implementation didn't touch the first byte of the array
17:43:57 <acowley> luite: my larger program still segfaults
17:44:01 <luite> because it would just write to the wrong offset
17:44:40 <mmorrow> FunctorSalad: since if you throw it to your main thread, i'm not positive the semantics of catching the resulting exception that gets raised in the main thread
17:44:42 <acowley> luite: that makes sense
17:45:05 <luite> yes I didn't claim that this fixes the whole Bool array, it just seems to make a very specific case a little better :p
17:45:29 <mmorrow> like,    main = do ...here[0]?...; catch (..here[1]?...) (..here[2]?...); .....here[3]?...
17:45:43 <luite> acowley: does it produce the correct result for you, if all offsets and lengths are multiples of 8?
17:45:45 <mmorrow> FunctorSalad: what  happens if the throwTo happens at here[i]?
17:45:52 <acowley> luite: well, mission accomplished then
17:45:53 <mmorrow> FunctorSalad: i'm not sure
17:45:54 <acowley> luite: no
17:46:01 <luite> really?
17:46:04 <acowley> luite: I'm working with a 128x128 vector
17:46:09 <acowley> luite: ah, wait
17:46:23 <acowley> luite: nm, some of the processing is done off of byte boundaries
17:46:34 <acowley> luite: so everything is up for grabs then
17:46:35 <FunctorSalad> mmorrow: I don't know. but explicit propagation does sound simplest
17:46:44 <mmorrow> FunctorSalad: yeah it does
17:47:28 <luite> that would be bad :p I can't explain the segfaults though, because the code, even though utterly broken, doesn't seem to write or read outside the bounds
17:48:28 <luite> so, where's dons :)
17:48:59 <acowley> luite: I messaged him earlier and he asked me to pull from darcs (so I did)
17:50:18 <gOcOOl> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11818#a11818 -> fails with this error message: "Not in scope: `line'" at the very last line, line 13
17:50:35 <gOcOOl> anybody know how to correct it?
17:51:19 <luite> gOcOOl: add another where before xs
17:51:22 <acowley> gOcOOl: you need another where
17:51:26 <luite> indented more than the previous one
17:51:56 <byorgey> or use   where extract line = let xs = LB.words line in LB.unwords ...
17:53:00 <acowley> luite: well it's better now than it was
17:53:06 <acowley> luite: it only segfaults when built with -O2
17:53:12 <luite> hehe
17:53:47 <acowley> luite: I think I'm going to patch my uvector to error when UArr Bool is encountered just to warn me away from this :P
17:54:03 <luite> you could just remove some instances
17:54:10 <luite> so Bool is not UA anymore
17:54:34 <acowley> Then I'll be tempted to add it back; I need something more forceful.
17:54:49 <luite> I think it would work if you used only indexU, writeMU etc for UArr Bool
17:55:27 <acowley> Perhaps, but the segfault with O2 is disconcerting
17:55:46 <luite> or you could temporarily replace the Bool instance by one based on Word8
17:55:54 <gOcOOl> I modified it like so, still no luck: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11818#a11819
17:56:29 <luite> gOcOOl: it should be indented more than 'extract'
17:56:48 <luite> or as least as much I guess
17:56:52 <acowley> gOcOOl: byorgey's suggestion may be prettier here
17:56:53 <gOcOOl> ah ok, got it
17:57:01 <gOcOOl> thanks all
17:57:06 <luite> but a let ... in would look prettier indeed
17:57:29 <monochrom> I use one single line. extract line = stuff stuff xs stuff where xs = stuff
17:58:23 <monochrom> since everybody and his/her grandmother uses a colourful editor that gives "where" a weird colour, the single line will not be unreadable.
17:58:51 <aavogt> so using 'where' actually takes up less characters than let in
17:58:53 <fnord123> wow. ghc on 800mhz ppc chips is slowwwwwwwwww
17:59:30 <aavogt> but 'where' won't work inside a lambda
18:00:18 <monochrom> > (\x -> let {z=y where y=0} in x+z) 4
18:00:19 <lambdabot>   4
18:00:25 <monochrom> tee hee hee
18:01:01 <monochrom> please slap me. :)
18:01:14 <copumpkin> @slap monochrom
18:01:14 * lambdabot smashes a lamp on monochrom's head
18:01:23 * copumpkin smacks his hands and walks away
18:01:37 * cjs slaps monochrom.
18:01:51 <cjs> And that was for the incorrect statement that everybody uses syntax colouring.
18:02:06 <acowley> fnord123: It's not terribly fast on 2Ghz PPC either :/
18:02:48 <ivanm> monochrom: why do you suddenly have masochistic tendencies?
18:12:24 <jimmyjazz14> @hoogle a -> Bool
18:12:25 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
18:12:25 <lambdabot> Network.BufferType buf_isEmpty :: BufferOp a -> a -> Bool
18:12:25 <lambdabot> Network.BufferType buf_isLineTerm :: BufferOp a -> a -> Bool
18:13:44 <copumpkin> yay http://www.cs.kuleuven.be/%7Etoms/Research/papers/constraint_families.pdf
18:14:02 <kmc_> @tell kmc http://www.cs.kuleuven.be/%7Etoms/Research/papers/constraint_families.pdf
18:14:02 <lambdabot> Consider it noted.
18:16:35 <monochrom> hahaha that is a great idea.
18:16:45 <copumpkin> I can't really tell if they've actually written a patch for GHC with it though
18:17:27 <monochrom> (Advertisement) "Forget Delicious. Forget Google Bookmarks. The next generation of mobile, cloud-computing, pervasive personal assistant is the lambdabot!"
18:17:56 <kmc_> "3 From now on, reference to Haskell means the Haskell language as accepted by GHC."
18:18:39 <monochrom> That means no TREX. :)
18:24:42 <jimmyjazz14> would this be considered bad form: readFile "/etc/passwd" % lines % filter ((/=) "") where (%) = flip . fmap
18:25:09 <copumpkin> why not just (.) then?
18:25:24 <mmorrow> (filter (not . null) . lines) <$> readFile "/etc/passwd"
18:25:31 <copumpkin> (readFile "/etc/passwd").lines.filter((/=) "")
18:25:41 <copumpkin> you can be just like the imperative language of your choice then!
18:26:41 <byorgey> copumpkin: no, you need the fmap
18:26:51 <jimmyjazz14> copumpkin: is that valid?
18:27:04 <copumpkin> jimmyjazz14: no, I meant using (.) instead of your (%)
18:27:10 <copumpkin> I didn't mean use the vanilla (.) :P
18:27:17 <copumpkin> just hide the default implementation
18:27:20 <mmorrow> import Prelude hiding ((.))
18:27:29 <jimmyjazz14> copumpkin: oh because I use (.) a lot for other things
18:27:34 <byorgey> that sounds like... a terrible idea
18:27:43 <copumpkin> yep!
18:27:44 <mmorrow> what's wrong with Prelude.. ?!
18:27:45 <byorgey> !
18:27:48 <monochrom> readFile "/etc/passwd" % lines % filter ((/=) "") where (.) = flip . fmap  -- tee hee hee
18:27:53 <monochrom> err
18:28:02 <monochrom> readFile "/etc/passwd" . lines . filter ((/=) "") where (.) = flip . fmap  -- tee hee hee
18:28:08 <byorgey> hehe, I see what you did there =)
18:28:26 <copumpkin> jimmyjazz14: now you don't have to choose!
18:28:30 <mmorrow> , let a + b = 2 * (a + b) in 4 + 7
18:28:32 <lunabot>  Stack space overflow: current size 8388608 bytes.
18:28:32 <lunabot>  Use `+RTS -Ksize' to increase it.
18:28:37 <copumpkin> nice
18:28:44 <sproingie> > let 2 = 3 in 1 + 2
18:28:45 <lambdabot>   3
18:28:48 <mmorrow> , let a + b = 2 * (a Prelude.+ b) in 4 + 7
18:28:49 <lunabot>  22
18:29:02 <monochrom> Don't you miss ocaml's let which doesn't recurse.
18:29:09 <byorgey> no.
18:29:14 <sproingie> so it let me set 2, but ignored it
18:29:19 <copumpkin> how would we confuse newbies without it?
18:29:23 <mmorrow> but we accept do instead of mdo!
18:29:29 <byorgey> sproingie: technically, it let you pattern match 3 against 2
18:29:32 <byorgey> lazily
18:29:41 <monochrom> "let 2=3" does not set 2.
18:29:50 * mmorrow want mdo as default, degenerating to do only when there's no MonadFix instance
18:30:00 <sproingie> ahhh
18:30:15 <byorgey> sproingie: but since you didn't use the value of any variables bound by the pattern match (of course, there aren't any) it didn't actually do the pattern match =)
18:30:23 <sproingie> just named my site monadfix.com
18:30:26 <monochrom> Only variables are "set", or bound. Literals are matched, not set.
18:30:37 <mmorrow> sproingie: heh, nice
18:31:10 <sproingie> let 1 = 2 in 1
18:31:14 <sproingie> > let 1 = 2 in 1
18:31:15 <lambdabot>   1
18:31:19 <sproingie> meh
18:31:28 <mmorrow> , let !1 = 2 in 1
18:31:29 <lunabot>  luna: <interactive>:1:54-59: Non-exhaustive patterns in pattern binding
18:31:40 <jimmyjazz14> seems like having the flipped version of fmap is handy quite often, not really sure why its not seen in some form
18:31:41 <mmorrow> , case 2 of 1 -> 1
18:31:43 <lunabot>  luna: <interactive>:1:50-65: Non-exhaustive patterns in case
18:31:53 <jimmyjazz14> or perhaps I am still to naive
18:32:33 <sproingie> , case Black of White -> getRunOver . zebraCrossing
18:32:34 <lunabot>  luna: Not in scope: data constructor `Black'
18:32:36 <mmorrow> @pl (\f a -> join (fmap f a))
18:32:36 <lambdabot> (=<<)
18:32:52 <mmorrow> @pl (\a f -> join (flip fmap a f))
18:32:52 <lambdabot> (join .) . flip fmap
18:33:00 <mmorrow> @type (\a f -> join (flip fmap a f))
18:33:00 <lambdabot> forall a (f :: * -> *) a1. (Functor f, Monad f) => f a -> (a -> f a1) -> f a1
18:33:05 <mmorrow> @type (>>=)
18:33:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:33:16 <mmorrow>  @pl couldn't figure that one out..
18:33:38 <mmorrow> so, in other words (>>=) is kind of like flip fmap
18:33:49 <mmorrow> it just joins in addition
18:34:21 <jimmyjazz14> mmorrow: yeah I can see that but it generally require a return to be used
18:34:26 <mmorrow> @type \m f -> m >>= return . f
18:34:28 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a -> (a -> a1) -> m a1
18:34:28 <mmorrow> heh, right
18:34:51 <jimmyjazz14> where as fmap doesn't
18:35:09 <monochrom> use the do notation.
18:35:17 <mmorrow> jimmyjazz14: i think there's no existing def for that because you're writing the pipeline in the opposite direction it's usually written in haskell
18:35:37 <acowley> thanks all for the help with my uvector problem
18:35:40 <copumpkin> a partially applied fmap, on the other hand (a bit like <=<) would be very nice
18:35:44 <jimmyjazz14> mmorrow: right I pretty sure I just determined that I simply read backwards
18:36:00 <copumpkin> jimmyjazz14: it might help you in the long run to not fight the current
18:36:13 <mmorrow> main = putStr . unlines . fmap (\line -> (show . length) line ++ ":" ++ line) . lines =<< getContents
18:36:23 <mmorrow> acowley: no problem :)
18:36:37 <monochrom> don't fight the current. drain it.
18:37:00 <mmorrow> or swim in the sideways-to-the-current direction
18:37:24 <mmorrow> geez, how do you guys survive rip currents
18:37:53 <FunctorSalad> hmm my hGetLine ignores (chr 32)
18:37:59 <acowley> byorgey: I've got a fairly Haskelly iPhone-controlled robot with lots of lasers and fancy visualization stuff down in our lab. If you see me in the hall with one of them, I can give you a tour (and get the tour of diagrams I'm still lacking :) !
18:38:03 <mmorrow> , chr 32
18:38:04 <lunabot>  ' '
18:38:24 <jmcarthur> i just float downstream. it's just laziness
18:38:52 <monochrom> I fear robots with lots of lasers. will they kill me?
18:38:54 <mmorrow> jmcarthur: well, in the case of rip currents it'd be out to sea TO YOUR DOOM!!@
18:39:08 <FunctorSalad> is this some dos/unix thing? but (chr 32) is unix, isn't it?
18:39:22 <mmorrow> i agree, lasers are a nice touch
18:39:30 <monochrom> torch too
18:39:38 <monochrom> I first saw "chr" in basic.
18:40:07 <jmcarthur> mmorrow: that brings closure to my story, i guess
18:40:16 <FunctorSalad> , ord "\n"
18:40:18 <lunabot>  luna: Couldn't match expected type `GHC.Types.Char'
18:40:25 <FunctorSalad> , fmap ord "\n"
18:40:27 <lunabot>  [10]
18:40:33 <FunctorSalad> , fmap ord "\r"
18:40:34 <lunabot>  [13]
18:41:00 <FunctorSalad> err... sorry it's late (spaces aren't linebreaks)
18:41:17 <mmorrow> i was about to ask you whattf you meant by "ignore" :)
18:41:45 <FunctorSalad> which raises the question why this program I'm reading form outputs spaces when in the terminal it outputs linebreaks...
18:41:54 <FunctorSalad> hehe
18:42:23 <jmcarthur> your program suffers from a space leak
18:43:24 <FunctorSalad> ^^
18:45:25 <p_l> ... I guess Yake Haskell would have some problems running modern examples? ^^;
18:45:46 <FunctorSalad> ah it probably switches off its readline variant when not on a terminal
18:46:28 <mmorrow> jmcarthur: hah
18:49:14 <FunctorSalad> meh so it seems I'll have to find the prompt without linebreaks
18:50:09 <FunctorSalad> so I should just add to the documentation "Warning: Having the string 'Maude>' in any identifiers passed to Maude will cause catastrophic failure"? ^^
18:51:50 <FunctorSalad> (trying to talk to the Maude REPL from haskell)
18:52:18 <dancor> just make the prompt include an ascii string randomized per invocation ;)
18:52:24 <dancor> Maude-51TNHNO57INTH>
18:53:01 <FunctorSalad> dancor: there doesn't seem to be a way to change it
18:53:56 <dancor> where there's an information-theoretic-proof-than-its-algorithmically-possible, there's a way
18:59:42 <Lycurgus> *that
19:01:49 <Lycurgus> and my admittedly non-expert knowledged of coding leads me to think not
19:01:57 <Lycurgus> *knowledge
19:02:07 <Lycurgus> *coding theory
19:02:56 <dancor> *it's
19:04:30 <segoe> hi
19:04:42 <byorgey> hi segoe
19:04:54 <dancor> @vixen say hi
19:04:54 <lambdabot> hiya
19:05:12 <Lycurgus> yo segoe
19:12:05 <ccasin> can I statically link against a C library with cabal?
19:12:54 <ccasin> I only see discussion of dynamic libraries in the docs
19:13:56 <bd_> :t flip fmap
19:13:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
19:14:03 <bd_> @hoogle  (Functor f) => f a -> (a -> b) -> f b
19:14:04 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
19:14:04 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
19:14:04 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
19:14:09 <bd_> :|
19:17:22 <bd_> :t (<**>)
19:17:23 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
19:17:29 <bd_> is there any reason this isn't defined for Functor?
19:17:40 <aavogt> that function?
19:17:47 <aavogt> @hoogle <$$>
19:17:47 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
19:17:47 <lambdabot> Text.ParserCombinators.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
19:18:32 <bd_> moreover, is there a difference between <*> and fmap? from the type signature I can't see how it'd be different...
19:18:58 <bd_> oh wait, I see.
19:19:02 <aavogt> > [(+1),(*2)] <*> [1..3]
19:19:03 <lambdabot>   [2,3,4,2,4,6]
19:19:39 <bd_> yeah, missed the extra f :)
19:23:07 * SamB_XP has nearly managed to hack an export tabel back into the ida.wll from IDA Free such that it can use plain-old IDA plugins
19:24:23 <mmorrow> SamB_XP: haha, using IDA Free to do it i hope
19:25:13 <SamB_XP> mmorrow: well, certainly looking at it with itself, yes
19:26:03 <SamB_XP> but the actual hack is done with a Python script and a table of names and ordinals I got from someone's tool for hacking the import library from the SDK
19:28:53 --- mode: irc.freenode.net set +o ChanServ
19:32:03 <SamB_XP> hmm, it looks like it neeedz moar underscores
19:33:54 <ivanm> what does?
19:33:57 <ivanm> the net split?
19:33:58 <ivanm> ;-)
19:34:17 <SamB_XP> no, ida.wll's export table ;-)
19:34:27 <Gracenotes> that more-than-filled my line buffer
19:34:46 <copumpkin> SamB_XP: PIRATE
19:34:51 <SamB_XP> Gracenotes: that split nearly filled mine
19:34:59 <copumpkin> SamB_XP: or are you just patching a legit IDA to accept pirated idbs?
19:35:38 <SamB_XP> copumpkin: I'm not pirating, I'm attempting to uncripple IDA Free to work with the plugins from the 4.9 SDK
19:35:57 <ivanm> what's IDA?
19:36:11 <Gracenotes> 1/6th of the 500-line buffer at the top is all that's left of the split part. tis not sufficient :'(
19:36:15 <copumpkin> the reverser's favorite tool
19:36:31 <Gracenotes> I've always been suspicious of reversi players
19:37:16 <SamB_XP> see, the basic problem is that they hacked the included plugins to import ida.wll (just an oddly-named DLL) by ordinal, and then hacked ida.wll to remove all but 3 of the export names
19:37:38 <SamB_XP> thankfully, this leaves plenty of room in .edata to rebuild the export table ;-)
19:37:51 <copumpkin> omgwtfhax
19:38:19 <ivanm> SamB_XP: what's IDA?
19:38:35 <SamB_XP> ivanm: it's the Interactive Disassembler
19:38:35 <copumpkin> Interactive DisAssembler
19:39:00 <ivanm> bah, it isn't listed on wikipedia's disambiguation page :@
19:39:29 <SamB_XP> @wikipedia IDA Pro
19:39:31 <lambdabot> http://wikimediafoundation.org/wiki/Special:Search?search=IDA%2520Pro
19:46:02 <FunctorSalad> can you just make a file Handle an instance of Parsec's Stream?
19:46:11 <FunctorSalad> or is there some pitfall
19:46:20 <FunctorSalad> since the instance isn't included
19:47:17 <FunctorSalad> err it's a pipe Handle actually
19:48:14 <gressvol-> what does the , mean in (digitval d,s') ?
19:48:25 <byorgey> gressvol-: it's constructing a tuple
19:48:28 <byorgey> > (2,3)
19:48:29 <lambdabot>   (2,3)
19:50:15 <Cale> gressvol-: specifically, a tuple whose first component is digitval d, and whose second component is s'
19:50:18 <m3ga> Oops : http://hackage.haskell.org/trac/ghc/wiki/Status/Oct09 -> Trac detected an internal error
19:50:39 <Cale> sweet
19:50:55 <m3ga>          No space left on device
19:52:25 <luite> @seen dons
19:52:26 <lambdabot> Unknown command, try @list
19:52:39 <ivanm> preflex_: seen dons
19:52:39 <preflex_>  dons was last seen on #ghc 3 hours, 45 minutes and 49 seconds ago, saying: have done so :)
19:52:39 <luite> hm, oh it was removed
19:52:40 <ivanm> luite: ^^
19:52:46 <monochrom> FunctorSalad: The pitfall is that when parsec backtracks it reads the old stream again, expecting the same character read again. If you use Handle, "old" and "new" Handle are the same, but old characters are not read again. If you don't understand this sentence, I'll re-word.
19:52:52 <luite> thanks ivanm
19:53:03 <ivanm> maybe the @seen plugin should be replaced with a message telling people to ask preflex_
19:53:09 <ivanm> or even get lambdabot to ask preflex_... ;-)
19:53:36 <FunctorSalad> monochrom: are you sure it doesn't buffer the result and just backtracks in its buffer?
19:53:55 <monochrom> I am sure. I tried it.
19:53:56 <FunctorSalad> monochrom: Stream's uncons method is monadic, so it should kinda expect it
19:54:21 <FunctorSalad> I see. thanks
19:57:03 <Gracenotes> yeah, getting no space left on device error... that's disappointing :/ why not try deleting some bug reports, then? :P
19:57:09 <ivanm> heh
20:01:58 <Warrigal> @type toUpper
20:01:59 <lambdabot> Char -> Char
20:02:12 <Warrigal> > toUpper 'ÃŸ'
20:02:13 <lambdabot>   '\223'
20:02:35 <Warrigal> > 'ÃŸ'
20:02:36 <lambdabot>   '\223'
20:02:49 <Warrigal> Well, that's not very wrong.
20:03:07 <sproingie> > toUpper 'A'
20:03:08 <lambdabot>   'A'
20:03:25 <FunctorSalad> monochrom: confirmed
20:03:39 <FunctorSalad> monochrom: (just in case your test was with an older version)
20:06:18 <monochrom> I used to play games with using the delimited continuation monad to give parsec a stream that inverts control. It was fun discovering that parsec revives old stream states for backtracking. I had to add memory to my stream states for that.
20:10:28 <FunctorSalad> newtype MemoHandle = IORef (Either Char MemoHandle)
20:10:28 <FunctorSalad> ?
20:10:59 <FunctorSalad> +constructor name
20:11:12 <monochrom> (Handle, IORef (Maybe Char))
20:12:32 <FunctorSalad> err right I lost the Handle ;)
20:15:04 <gressvol-> I have a datatype: type Parser a = String -> [(a,String)] and two functions: satisfy :: (Char -> Bool) -> Parser Char and many :: Parser a -> Parser [a]. Should I not be able to take return value from satisfy and insert into many?
20:17:30 <dobblego> gressvol-, yes you can do exactly that
20:17:32 <Lemmih> gressvol-: Your terminology is a bit off, but yes you should.
20:17:41 <dobblego> let manyx = satisfy (many x)
20:17:58 <dobblego> or let manyx = satisfy . many $ x -- I prefer
20:18:04 <Lemmih> dobblego: Eh?
20:18:22 <Lemmih> dobblego: many . satisfy, no?
20:18:35 <dobblego> oh yeah sorry
20:18:52 <dobblego> I have an awesome excuse --- I just got out of hospital after an anaesthetic
20:19:12 <Lemmih> gressvol-: So, 'many (satisfy isSpace)' should work.
20:19:55 <gressvol-> I get this error when I try it: *** Type : [(Char,[Char])]
20:19:55 <gressvol-> *** Does not match : [Char] -> [(a,[Char])]
20:20:08 <copumpkin> oh no, not hugs!
20:20:14 <Lemmih> gressvol-: Did you remember the argument to 'satisfy'?
20:20:54 <gressvol-> Lemmih: yes, many (satisfy isDigit ['5'])
20:21:07 <copumpkin> moar parentheses needed
20:21:08 <Lemmih> gressvol-: Just 'many (satisfy isDigit)'.
20:21:20 <copumpkin> oh whoops
20:21:28 * copumpkin has no excuse, unlike dobblego
20:21:59 <Lemmih> gressvol-: That gives you a Parser which you can then run.
20:24:36 <gressvol-> i dont know if it is my interpreter, but i dont get it to work.
20:24:57 <gressvol-> e.g. isDigit '6' works
20:25:08 <copumpkin> yeah, but satisfy wants a function
20:25:09 <gressvol-> but later it asks for [char]
20:25:10 <Lemmih> gressvol-: 'many (satisfy isDigit) "5"' doesn't work?
20:25:51 <gressvol-> Lemmih: yes i did
20:26:56 <Lemmih> gressvol-: Do you see why?
20:27:44 <gressvol-> Maybe, satisfy requires 2 in parameters?
20:28:45 <Lemmih> gressvol-: Yes but it help not to think of it like that.
20:29:01 <gressvol-> ok
20:29:06 <Lemmih> gressvol-: 'satisfy' takes a single parameter and gives you a Parser.
20:29:42 <gressvol-> When I see (a -> b) I thought it was a function that takes a and gives b
20:29:49 <copumpkin> it is
20:29:59 <kmc> @messages
20:29:59 <lambdabot> kmc_ said 2h 15m 57s ago: http://www.cs.kuleuven.be/%7Etoms/Research/papers/constraint_families.pdf
20:30:00 <Lemmih> gressvol-: A Parser takes an input stream and gives you a list of parsed values.
20:34:25 <gressvol-> I still didnt get why the paranthasis was moved
20:34:52 <Lemmih> gressvol-: The implementation details of the 'Parser' type is irrelevant when writing/combining parsers so it is usually ignored.
20:35:37 <Lemmih> gressvol-: 'satisfy isDigit' is a 'Parser'. 'many' takes a Parser and gives you a new one.
20:36:06 <gressvol-> okey
20:36:09 <Lemmih> gressvol-: It might help if you defined 'runParser :: Parser a -> String -> [(a,String)]'.
20:36:47 <Lemmih> gressvol-: let myParser = many (satisfy isDigit)
20:36:54 <Lemmih> gressvol-: in runParser myParser
20:37:28 <Lemmih> Err, with the appropriate input stream.
20:37:36 <Lemmih> gressvol-: in runParser myParser "5"
20:37:38 <dcolish> Network.Curl is kinda hard to use
20:37:53 <dcolish> I just dont grok it
20:39:08 <gressvol-> dont think let works in WinHugs :/
20:40:37 <Lemmih> gressvol-: You can put it in a file if you want. Or write it in a single line.
20:41:12 <Lemmih> gressvol-: It was more to get you to think about combining parsers and running parsers as two separate actions.
20:42:04 <Lemmih> dcolish: What seems to be the problem?
20:43:40 <dcolish> well i dont quite see how you'd construct the CurlPost object with a ContentFile and marshall that to do a full post
20:43:50 <dcolish> the examples dont ever talk about file uploads
20:45:43 <Lemmih> dcolish: Have you read the haddock documentation?
20:45:53 <dcolish> i have
20:47:10 <huntse> Style question:  I have some big table-driven functions.  Is it better to write them as a series of equations, or as a bigass case?
20:47:36 <Lemmih> dcolish: curlMultiPost doesn't do it?
20:47:59 <byorgey> huntse: I'd write it as a series of equations.
20:48:49 <monochrom> I would dump the table into a Data.Map.
20:48:57 <huntse> byorgey: thanks.  And does ghc turn that into basically a lookup table?  One of them is going to have about 4million entries.
20:49:08 <byorgey> four MILLION?
20:49:08 <dcolish> Lemmih: hmm it could, i thought it ment do mutliple posts... must read moar docs
20:49:10 <huntse> monochrom: speed is of the absolute essense.
20:49:19 <kmc> building the latest dev snapshot of ghc i get: /bin/tar: ../ghc-tarballs/libffi/libffi*.tar.gz: Cannot open: No such file or directory
20:49:23 <kmc> anyone know where to get this file?
20:49:27 <monochrom> Data.Map is the fastest.
20:49:31 <copumpkin> huntse: you should definitely design your own hardware then
20:49:34 <huntse> byorgey: yeah, it's a precomputed lookup function.
20:49:38 <dcolish> Lemmih: if you've got a quick example of what its invocation might be i'd really appreciate it
20:49:44 <copumpkin> huntse: general purpose hardware is not as fast as specialized
20:49:48 <Lemmih> dcolish: It just does a multi-part post.
20:49:52 <huntse> monochrom: not for what I'm doing.
20:49:58 <byorgey> huntse: Data.Map is your best bet then; writing a list of equations will be a linear-time lookup
20:50:05 <byorgey> since it will try matching against each equation in turn
20:50:17 <dcolish> Lemmih: ok so if i set my file in CurlOpts it should handle it?
20:50:19 <monochrom> OK, Data.Map is faster than both pattern matching and case.
20:50:20 <huntse> copumpkin: that's a bit extreme.  You can get acceptable performance from this thing in C.
20:50:28 <dcolish> or do I need to define the file as a ContentFile
20:50:40 <copumpkin> huntse: oh
20:50:41 <SamB_XP> copumpkin: but the economies of scale tend to even things out a lot of the time
20:50:43 <huntse> byorgey: OK that's interesting to know.  I'll  write the algo differently.
20:50:52 <monochrom> If you can phrase it as array indexing, that is of course even better than Data.Map.
20:51:07 <huntse> You can write this algo as 7 array index ops.
20:51:11 <Lemmih> dcolish: I'd use a ContentFile.
20:51:32 <huntse> (into a very large and craftily-designed array)
20:51:36 <SamB_XP> i.e. you're probably not going to be able to afford to create the specialized hardware at such a small size / high speed as you would be able to purchase generalized hardware at
20:51:37 <Lemmih> dcolish: I have some code that upload a public key file using curl. I can hpaste it.
20:51:50 <ivanm> preflex_: seen Baughn
20:51:51 <preflex_>  Baughn was last seen on #ghc 6 hours, 26 minutes and 52 seconds ago, saying: Which would be nice.
20:51:56 <SamB_XP> in terms of clocks
20:52:07 <dcolish> Lemmih: i would definitely appreciate that ! Thank you
20:52:09 <SamB_XP> so it depends on how much better the design can be for your problem ;-)
20:52:21 <huntse> OK thanks guys.  A big array is going to do the thing.
20:52:50 <kmc> ah, found it
20:52:54 <Lemmih> dcolish: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11830#a11830
20:54:18 <dcolish> oh i see, i was missing the part where i formed the HttpPost
20:54:50 <dcolish> i think i mixed up the Network.Curl.Easy calls with the calls I was supposed to make
20:54:55 <Lemmih> dcolish: 'curlMultiPost' just sets the 'CurlHttpPost' option.
20:55:02 <monochrom> These days I always knee-jerk to Data.Map whenever I want associative memory. Switching to an array is an optimization after other design decisions are settled.
20:55:50 <monochrom> Not to mention that sometimes some design decision rules out array already.
20:56:04 <dcolish> Lemmih: ah ha! so i'd pass a HttpPost to curlMultiPost and it handles it
20:56:37 <luite> kmc: it's in the tar.gz, but in the wrong directory, look in libffi
20:56:44 <monochrom> (Or in fact some requirements early on already rules out array, e.g., known sparseness.)
20:56:45 <luite> kmc: just copy (or move) that file
20:56:58 <Lemmih> dcolish: 'curlMultiPost' does that for you. (:
20:57:07 <Lemmih> dcolish: Oh wait, yes.
20:57:37 <Lemmih> dcolish: I misread, HttpPost/CurlHttpPost.
20:57:44 <dcolish> no worries
20:58:07 <dcolish> ok i think i can figure out what to do from here
20:58:10 <Lemmih> dcolish: You can't do any error handling with 'curlMultiPost', though.
20:59:42 <dcolish> hmm, that does kinda suck
21:02:43 <sohum> I wonder what happens if...
21:02:48 <sohum> preflex_: seen sohum
21:02:49 <preflex_>  sohum was last seen on #haskell 6 seconds ago, saying: I wonder what happens if...
21:02:59 <sohum> ah, so it ignores your current post
21:03:45 <dolio> preflex_: seen dolio
21:03:45 <preflex_>  dolio was last seen on #haskell-blah 12 minutes and 46 seconds ago, saying: Man, I feel bad for the guy who asked about a thesis topic, and the only response he's getting is Shelby Moore and John A. de Goes.
21:03:48 <dolio> preflex_: seen dolio
21:03:48 <preflex_>  dolio was last seen on #haskell 3 seconds ago, saying: preflex_: seen dolio
21:04:17 <sohum> haskell-blah?
21:04:23 <copumpkin> preflex_: 6st 1
21:04:23 <preflex_>  1st
21:18:31 <dcolish> Lemmih: so when curlMultiPost returns (), does that mean it returns nothing?
21:19:29 <MoALTz> i wonder there should be a "guess the purpose!" competition. someone pastes the contents of a function and the other have to guess what the function does (and what it's name should be)
21:20:26 <sjanssen> MoALTz: first submission: f = filterM (const [False ..])
21:20:40 <MoALTz> mine is "??? se le = length se == length le && and [count c le == count c se | c <- le]"
21:21:48 <sjanssen> MoALTz: I'd write that as samestuff xs ys = sort xs == sort ys
21:23:32 <monochrom> I wonder who judge or how to judge in such a competition.
21:25:48 <monochrom> "f _ = True" is this a function that returns true, a function that returns the bit 1 then casts it to boolean, or a function that returns false but has a bug?
21:26:48 <roconnor> monochrom: a)
21:26:52 <huntse> monochrom: It's a function which takes a function and tells you whether it probably has a bug.
21:27:02 <kmc> dcolish, () is a useless value.  its type is also written ()
21:27:03 <kmc> :t ()
21:27:04 <lambdabot> ()
21:27:49 <dcolish> ah
21:28:02 <dcolish> yeah so i gotta figure out what do with that
21:28:22 <roconnor> case () of { () -> <whatever> }
21:28:36 <kmc> why do you need to use it?
21:28:42 <roconnor> :P
21:28:50 <dcolish> its what curlMultiPost returns
21:28:52 <kmc> curlMultiPost returns a value of type IO (), not ()
21:29:06 <kmc> IO () is not a useless value -- it's a "recipe" for performing some IO
21:29:31 <kmc> you'll probably use it by gluing it onto some other IO actions
21:30:16 <sjanssen> monochrom: that function is actually the core of lambdabot's @faq command
21:30:16 <dcolish> so there is a CurlResponse Constructor i've seen used
21:30:24 <MoALTz> that filterM trick is pretty strange (didn't know about it before)
21:31:23 <roconnor> dcolish: you probably want to "bind" it into your main program (possibly indirectly).
21:31:59 <dcolish> so i'm doing:  r <- curlMultiPost x y z
21:32:06 <roconnor> main = do { foo; bar; curlMultiPost baz; quux }
21:32:09 <kmc> dcolish, "r" is useless there
21:32:20 <roconnor> dcolish: you can just drop the "r <-"
21:32:29 <dcolish> then it just spits out IO
21:32:40 <kmc> you already know that r is (), because it's the only value of type () (other than errors)
21:32:45 <roconnor> then it just sequences the IO into place, ya.
21:33:15 <kmc> a value of type "IO ()" is a recipe for performing IO, without producing any new values
21:33:23 <roconnor> dcolish: even if it did return a value, you can still drop the "r <-" if you don't care about it.
21:33:32 <roconnor> though that might be considered bad form to some.
21:33:56 <dcolish> sure, i just want to take the response from that curlMultiPost call and do stuff to it
21:34:00 <kmc> there is no response
21:34:09 <dcolish> why does IO happen then?
21:34:15 <iaefai> If I have a url request (webserver) that I want to provide some special functionality, and need to tell if it contains certain sequences, would it be wise to use parsec for that? For example, I would like  / or /index.html to receive a file, but perhaps /ajax/... to mean something entirely different - something to call in the program.
21:34:16 <kmc> to send out the post
21:34:25 <kmc> probably the curl library wants you to make a separate call to get the response back
21:34:28 <roconnor> @type putStrLn
21:34:29 <lambdabot> String -> IO ()
21:34:29 <dcolish> but i see a xml response on my screen
21:35:04 <dcolish> hmm maybe i need to use WriteFunction
21:35:30 <kmc> iaefai, sounds like parsec is overkill
21:35:33 <monochrom> (Another guessing puzzle entry) http://pastebin.com/m15ca3fdd  what does it do to variable r at the end?
21:35:54 <iaefai> kmc, might be
21:36:09 <kmc> iaefai, the "network" package provides Network.URI with some tools for manipulating URIs
21:36:16 <kmc> (actually, using parsec behind the scenes)
21:36:28 <roconnor> monochrom: ackermann of p and q ?
21:36:43 <monochrom> You are fast. How did you find out?
21:36:55 <roconnor> monochrom: random guess
21:37:00 <monochrom> haha
21:37:03 <roconnor> well not entirely random.
21:37:14 <roconnor> it looked very vaguely ackermannish
21:38:10 <iaefai> kmc, I will take a quick look
21:38:13 <monochrom> I copied it from a paper. It uses transfinite ordinals to prove termination.
21:38:17 <roconnor> monochrom: presumably it runs very slowly
21:38:22 <kmc> iaefai, once you have the uriPath you can split on '/' and pattern match the head of the list of dir components
21:39:01 <roconnor> monochrom: how big of an ordinal?
21:39:27 <monochrom> I only recall a stack of omega exponents.
21:39:30 <iaefai> kmc, I will try it
21:39:48 <roconnor> monochrom: a small stack or an infinite stack?
21:39:55 <monochrom> I forgot.
21:40:28 <roconnor> monochrom: I think you should be able to do it with omega^omega.
21:40:38 <roconnor> monochrom: er, paper proof?
21:40:45 <monochrom> Yes.
21:40:52 <kmc> dcolish, did you already consider the curl "easy" API?
21:41:02 <roconnor> monochrom: aw, I'd like to see the proof.
21:42:45 <monochrom> H. J. Boom.  A weaker precondition for loops.  ACM Transactions on Programming Languages and Systems, 4(4):668--677, 1982.
21:42:56 <kmc> dcolish, out of curiosity, what are you using curl for?
21:49:13 <dcolish> kmc: yeah the easy api doesnt work for file uploads
21:49:23 <dcolish> i'm making a imgur uploader
21:49:28 <dcolish> or at least trying to
21:49:57 <dcolish> so right now it works, but i'd like to handle the server response better
21:51:21 <kmc> ah
21:53:06 <dcolish> sadly this can be done with a simple curl command, but i wanted it in haskell
22:11:21 <kmc> whee, installed ghc 6.13
22:11:23 <kmc> the future is here
22:11:34 <monochrom> woah
22:12:59 <dcolish> do they still have beer in the future?
22:13:30 <copumpkin> preflex_: seen luqui
22:13:30 <preflex_>  luqui was last seen on #haskell 2 days, 9 hours, 3 minutes and 25 seconds ago, saying: maybe that's the way to go
22:14:27 <ivanm> dcolish: http://www.ctrlaltdel-online.com/comic.php?d=20041204 ;-)
22:14:51 <ivanm> dcolish: actually, the one before it is even more relevant: http://www.ctrlaltdel-online.com/comic.php?d=20041203
22:18:05 <dcolish> heh, thats pretty funny
22:18:34 <kmc> CAD sucks
22:18:36 <kmc> just saying
22:18:37 <iaefai> I seem to be missing Data-String-UTF8.html
22:19:21 <ivanm> iaefai: utf8-string?
22:19:28 <ivanm> oh, just the doc page?
22:19:32 <iaefai> right
22:19:32 <mmorrow> wow, evince has some serious memory leak problems
22:19:38 <ivanm> mmorrow: :o
22:19:46 <mmorrow> i've got 3 pdf's open and it's 400MB+ resident
22:19:53 <iaefai> mmorrow: Get Preview.app it works great
22:20:15 <ivanm> iaefai: even in linux? :p
22:20:15 <mmorrow> linux?
22:20:40 <ivanm> mmorrow: wait, you're using OSX, and yet you use evince
22:20:41 <iaefai> ivanm: Perhaps with some hackingâ€¦â€¦â€¦
22:20:42 <ivanm> ?
22:20:46 <ivanm> iaefai: heh
22:20:52 <mmorrow> ivanm: wut?
22:20:55 <mmorrow> i'm using linux
22:21:11 <ivanm> mmorrow: oh, right, the question was to iaefai, not me ;-)
22:21:15 <mmorrow> oh, yeah wa
22:21:17 <mmorrow> yeah
22:21:19 <ivanm> heh
22:21:24 <kmc> a gnome program with memory leaks
22:21:26 <kmc> shocking
22:24:59 <kmc> ghc 6.13 did not magically make my parallel program faster :/
22:25:18 <copumpkin> aw
22:25:21 <copumpkin> no magick 4 u
22:26:17 <ivanm> kmc: steal some magic from copumpkin... as a speaking vegetable, he probably has way more than he needs (how much magic does a pumpkin need, really? :P )
22:26:18 <ivanm> ;-)
22:26:38 <kmc> a co-speaking vegetable, or perhaps a speaking co-vegetable?
22:26:58 <ivanm> heh
22:27:34 <dcolish> ok i can get at just the xml i want now. what is the best way to parse that so i can format it and make it look pretty
22:28:37 <ivanm> dcolish: looked at the different xml packages on hackage?
22:28:48 <dcolish> i am but there are a lot to choose from
22:29:27 <ivanm> what are you wanting to do? parse xml?
22:29:37 <iaefai> kmc, 6.13/
22:29:38 <iaefai> ?
22:29:45 <kmc> yeah
22:29:54 <ivanm> iaefai: the branch they're working on for 6.14 release
22:29:54 <iaefai> I thought they hadn't even done 6.12 yet
22:29:56 <kmc> 6.12 is coming out soon but this is... one better
22:29:59 <dcolish> yeah its being returned as a string, so i want to pull out the values
22:30:14 <iaefai> kmc, read: less stable than unstable?
22:30:27 <kmc> i guess the switch from 6.11 to 6.13 happens before the official release of 6.12
22:30:34 <kmc> maybe at some release-candidate or freeze stage?
22:30:43 <ivanm> dcolish: you have haxml, hxt, tagsoup, wraxml and xml for "pure" haskell
22:30:49 <ivanm> others for C lib wrapping
22:31:13 <dcolish> yes, so which is good for a simple parse of a string?
22:31:17 <iaefai> I saw the email on the beginner list where a guy asks if System.Directory works on windows. Part of his output: GHC Interactive, version 6.4.2, for Haskell 98.
22:32:11 <ivanm> dcolish: you want a simple lib or an all-in-one lib?
22:32:19 * ivanm has never done any xml before...
22:32:26 <dcolish> ivanm: definitely simple
22:32:27 <ivanm> actually, IIRC RWH does some xml stuff...
22:32:37 <iaefai> What is the function I want to split a string by '/'?
22:32:43 <kmc> i remember 6.4
22:32:55 <iaefai> kmc, when do we get 7 :P
22:33:22 <ivanm> dcolish: well, RWH uses HaXml (probably go with the 1.13 "stable" branch) if you want a tutorial for the lib
22:33:52 <dcolish> ok i'll  check that out
22:34:37 <ivanm> xml looks too light, hxt doesn't look appropriate for what you want, wraxml is a wrapper lib, tagsoup is more for html
22:34:42 <ivanm> so haxml looks like the best bet
22:38:44 <Hugglesworth> how does one access the last returned value in ghci? kinda like how _ does in python
22:38:51 <mtnviewmark> it
22:38:51 <ivanm> it
22:39:07 * ivanm didn't know you could do it in python...
22:39:08 <iaefai> I see the split functions in ByteString, but how do you make a ByteString from a String?
22:39:19 <MoALTz> me neither
22:39:23 <Hugglesworth> much thanks
22:39:35 <kmc> :t ByteString.pcak
22:39:36 <lambdabot> Couldn't find qualified module.
22:39:37 <kmc> :t ByteString.pack
22:39:38 <lambdabot> Couldn't find qualified module.
22:40:20 <ivanm> @hoogle pack
22:40:21 <lambdabot> Data.ByteString pack :: [Word8] -> ByteString
22:40:21 <iaefai> pack is for CStrings
22:40:21 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
22:40:21 <lambdabot> Data.ByteString.Lazy pack :: [Word8] -> ByteString
22:40:35 <ivanm> iaefai: depends which ByteSTring you use
22:40:46 <iaefai> oh
22:40:52 <ivanm> well, bytestring "interface"
22:41:11 <kmc> the Char8 flavor works with standard Char, so long as their unicode values are under 256
22:41:52 <ivanm> hmmm, the utf8-string has romString
22:42:08 <iaefai> I can't get any docs for the utf8 one
22:42:16 <ivanm> iaefai: install utf8-string itself?
22:42:36 <iaefai> already did that, but the docs are put in a weird place and have no time to hunt
22:42:40 <ivanm> if you're trying to use docs from ghc, I find that on my machine they're a bit screwed up and have docs for packages that aren't actually available...
22:42:49 <iaefai> I'll just use the Char8 one
22:42:52 <ivanm> iaefai: /usr/share/docs/utf8-string-<version>/html/index.html
22:43:21 <iaefai> You mean this? file:///Library/Frameworks/GHC.framework/Versions/610/usr/share/doc/ghc/libraries/utf8-string/Data-ByteString-UTF8.html
22:44:05 <iaefai> I would like a central document index to be updated when I install package
22:44:54 <iaefai> I am rather surprised List doesn't have a split function
22:45:15 <monochrom> This comes up every two days, actually. :)
22:45:22 <iaefai> heh
22:45:27 <iaefai> I saw it on google too
22:45:35 <Raevel> iaefai: Data.List.Split
22:46:16 <iaefai> Raevel: it has a splitAt in the List module, never saw a Split module
22:46:24 <kmc> it's in the "split" package
22:48:37 <Baughn> ivanm: Hm?
22:49:33 <hexpuem> whats a good way to score/rank how sorted a list is? edit distance?
22:49:57 <vegai> does anyone still have the code for this? http://vcolin.com/2009/01/06/creating-minimal-http-server-haskell/
22:50:09 <vegai> I mean code for the bytestring http server that dons wrote in the comments section
22:52:26 <kmc> > let smet xs = length $ filter (uncurry >=) $ zip xs $ tail xs in smet [1,2,3,5,4]
22:52:27 <lambdabot>   Couldn't match expected type `(a -> b -> c) -> (a, b) -> c'
22:52:27 <lambdabot>         against...
22:52:57 <kmc> > let smet xs = length $ filter (uncurry (>=)) $ zip xs $ tail xs in smet [1,2,3,5,4]
22:52:59 <lambdabot>   1
22:53:06 <kmc> > let smet xs = length $ filter (uncurry (>=)) $ zip xs $ tail xs in smet [1,2,3,5,4,6,7,3,9]
22:53:07 <lambdabot>   2
22:53:19 <iaefai> emoticons off - some how after uncurry there was a dragon in there
22:53:27 <kmc> haha
22:53:36 <iaefai> kmc, what was the dragon you typed?
22:54:18 <kmc> > let smet xs = length $ filter (uncurry (>=)) $ zip xs $ tail xs in smet [1,2,3,5,4,6,7,3,9]
22:54:19 <lambdabot>   2
22:54:28 <kmc> i guess (>=) is a dragon?
22:54:46 <iaefai> probably :P
22:54:58 <iaefai> nope (>=))
22:55:12 <kmc> i don't see it
22:55:20 <iaefai> What client do you use?
22:55:24 <kmc> xchat
22:55:33 <iaefai> I use colloquy
22:56:25 <iaefai> @src return
22:56:25 <lambdabot> Source not found. Are you on drugs?
22:56:50 <kmc> @list
22:56:51 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
22:57:00 <kmc> @src Monad
22:57:01 <lambdabot> class  Monad m  where
22:57:01 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
22:57:01 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
22:57:01 <lambdabot>     return      :: a -> m a
22:57:01 <lambdabot>     fail        :: String -> m a
22:57:21 <kmc> @src Monad Maybe
22:57:21 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
22:57:27 <iaefai> Would  x <- return y  be the same as let x = y
22:57:34 <kmc> no
22:57:58 <kmc> err, sort of
22:58:23 <iaefai> RWH says return is the opposite of <-
22:58:24 <mtnviewmark> wouldn't it depend on the monad?
22:58:27 <kmc> the latter is definitely preferred
22:59:17 <kmc> there's a monad law:  return a >>= f  â‰¡  f a
22:59:30 <ivanm> iaefai: yeah, but I don't think that it's a complete opposite, as it could indeed depend on what the monad does
23:00:07 <ivanm> I'm sure it's possible to have some dynamic typing thing set up for a random monad where if the value is an integer, return adds one to it...
23:00:11 <copumpkin> kmc: that's a small =
23:00:43 <kmc> meaning?
23:00:43 <iaefai> yes it is - where did that come from
23:00:51 <kmc> http://www.haskell.org/haskellwiki/Monad_Laws
23:00:58 <copumpkin> kmcit's not the regular = sign
23:01:06 <copumpkin> oh it's ===
23:01:07 <kmc> it's a triple-bar equals sign, for extensional equivalence?
23:01:41 <ivanm> kmc: so you're the latest to hop on the "let's show off by using unicode characters" band-wagon? ;-)
23:01:49 <Baughn> ivanm: Type families could do that, I'm pretty sure
23:01:56 <Baughn> ivanm: Also, what was it?
23:02:06 <copumpkin> ivanm: I take it you're not a fan of agda?
23:02:10 <kmc> i'm the latest to hop on the "let's copy paste from the wiki to look knowledgeable without effort" bandwagon
23:02:12 <iaefai> triple bar isn't a good idea because it looks blurry here
23:02:24 <kmc> wow such controversy
23:02:24 <Baughn> ivanm: (Hm. But so could ordinary typeclasses)
23:02:25 <iaefai> ===================================}
23:03:18 <kmc> iaefai, anyway, you can write instances of Monad that violate the laws
23:03:21 <kmc> you're just not supposed to
23:03:29 <copumpkin> SPJ will slap you on the wrist
23:03:44 <iaefai> Can I have a case as the last expression in a do block if the result of it is a return call?
23:03:59 <kmc> you can have a case as the last expression in a do block, period
23:04:04 <kmc> a do block doesn't have to end in "return"
23:04:11 <kmc> "return" is really poorly named, imo
23:04:21 <iaefai> What was that error you can get if you don't end it properly?
23:04:29 <iaefai> I have had it before, I just can't remember it
23:05:24 <kmc> the things in a do block are expressions of monadic type.  you can build those any way you like -- function calls, case, nested do blocks, etc
23:05:37 <kmc> nesting do blocks with combinators in between is a really powerful technique
23:07:30 <iaefai> kmc, I might using STM soon
23:07:40 <Baughn> iaefai: "Do block must end in a expression", or so
23:07:52 <iaefai> What isn't an expression
23:07:58 <Baughn> "x <- foo"
23:08:06 <Baughn> "let x = foo"
23:08:28 <kmc> but "let x = foo in bar" is an expression
23:08:45 <kmc> that's the more typical form; the "let x = foo" form is provided for convenience within do
23:09:09 <ivanm> copumpkin: never used it
23:09:20 <copumpkin> ivanm: it's pretty interesting :)
23:09:28 <ivanm> Baughn: nvm, emacs fixed itself
23:09:55 <luite> it has self-healing powers?
23:09:58 <ivanm> for some reason after I first started using --daemon, it seemed to refuse to load indent (haven't annoyed the emacs dev to get 2.6.1 into gentoo yet and thus try indentation)
23:10:04 <ivanm> luite: restarted it ;-)
23:10:27 <Baughn> ivanm: 2.6.2. :P
23:10:37 <Baughn> ivanm: You know, you could just download into ~/haskell-mode
23:10:38 <ivanm> I thought you weren't going to release another one...
23:10:47 <Baughn> Sure. After 2.6.2, I said.
23:10:52 <ivanm> ahhh
23:11:01 <ivanm> Baughn: I can create my own local version of the ebuild as well, but can't be bothered atm ;-)
23:11:05 <Baughn> It's just some bugfixes anyway
23:12:44 <ivanm> *nod*
23:16:48 <jystic> will threads started using forkIO be killed when the main thread exits?
23:16:56 <ivanm> yes
23:16:56 <Baughn> Yes
23:16:59 <ivanm> except for in ghci
23:17:06 <Baughn> No, it does that in ghci too
23:17:11 <jystic> perfect :)
23:17:23 <Baughn> "Main thread" just refers to the REPL, not anything you explicitly start
23:17:45 <ivanm> Baughn: well, I meant when running :main or something in ghci
23:17:57 <Baughn> main /= main thread
23:17:58 <ivanm> and I'm guessing you knew that and was being deliberately obtuse ;-)
23:18:24 <jystic> so there's no problems with forking a few threads that recurse forever
23:18:44 <jystic> as long as they can handle being killed arbitrarily
23:18:46 <Baughn> jystic: Nope, although instead of using recursion you should use Control.Monad.forever
23:18:50 <iaefai> What would be a better name for return?
23:18:54 <Baughn> jystic: And either StateT or ReaderT, or..
23:19:07 <Baughn> iaefai: pure
23:19:21 <jystic> Baughn: ok, why's that?
23:19:22 * Cale disagrees about that
23:19:25 <Baughn> iaefai: You see, class Applicative a => Monad a
23:19:31 <Cale> I think return is a perfectly good name
23:19:43 <ivanm> Cale: agreed
23:19:55 <ivanm> just because some other languages use it to mean something else entirely is irrelevant
23:19:56 <cjs> I find it extremely annoying the way monadic return is confused with, e.g., the Java or Ruby return statement.
23:20:12 <Baughn> jystic: If you use explict recursion, it's very easy to get random memory leaks if you call yourself in anything but the tail position. Honestly, it's just too tempting..
23:20:22 <Cale> cjs: Yeah, why should anyone expect it to mean anything similar in the first place? :)
23:20:22 <Baughn> jystic: If you use forever, that's simply impossible
23:20:36 <iaefai> Does ghc do cons tail call optimization?
23:20:38 <vegai> main = return 1 >> putStrLn "foo"
23:20:42 <Baughn> jystic: A combination of forever and STM, or forever and StateT, will do nicely
23:20:47 <Baughn> iaefai: No
23:20:54 <jystic> Baughn: I
23:20:56 <iaefai> Is there a reason why?
23:21:03 <jystic> Baughn: I'm using STM so that will be a good fit
23:21:08 <Baughn> iaefai: It has no need. ;)
23:21:17 <Baughn> iaefai: GHC doesn't use a stack
23:21:22 <Cale> iaefai: Tail call optimisation doesn't really make sense in the context of a lazy evaluator.
23:21:36 <iaefai> no stack?
23:21:36 <Cale> So it's more like the answer is mu.
23:21:39 <monochrom> (x,y) of haskell is unrelated to (x,y) of C, if anyone wants to complain.
23:21:41 <cjs> Cale: Well, I'm always speaking of functions "returning foo", and it's a bit more awkward always to have to say not "f returns 3" but "f evaluates to 3".
23:21:52 <Cale> It does use a stack, but it doesn't use it for what a strict evaluator uses it for :)
23:22:06 <cjs> (Though I try my best.)
23:22:07 <Baughn> iaefai: If you like, you can think of it as the stack frames being heap-allocated. That's almost, but not quite, entirely incorrect.
23:22:18 <Cale> cjs: Or 'results in'
23:22:23 <iaefai> ok
23:22:29 <cjs> Still two words rather than one.
23:22:40 <ivanm> Cale: heh (about "mu")
23:22:41 <Baughn> iaefai: And, okay, there /is/ a C-style stack in there, but that's an implementation detail; it's only used for evaluating nested thunks
23:23:08 <Baughn> iaefai: (Which is what foldl likes to make, which is why it produces stack overflows)
23:23:15 <cjs> So is it possible to half-close a Handle? Or, if I'm going to work with handles, do I want to get separate readable and writable handles from a Socket?
23:23:23 <Cale> iaefai: Lazy evaluation is outermost first.
23:23:26 <iaefai> So foldl is bad?
23:23:33 <Baughn> Almost always.
23:23:41 <Cale> iaefai: yes, without extra strictness, usually.
23:23:41 <c_wraith> You almost always want foldl' or foldr
23:23:52 <c_wraith> (depending on what data types your function results in)
23:24:12 <Cale> Let's watch what happens :)
23:24:15 <Cale> @src foldl
23:24:16 <lambdabot> foldl f z []     = z
23:24:16 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:24:23 <Cale> foldl (+) 0 [1,2,3]
23:24:33 <Cale> -> foldl (+) (0 + 1) [2,3]
23:24:39 <Cale> -> foldl (+) ((0 + 1) + 2) [3]
23:24:45 <Cale> -> foldl (+) (((0 + 1) + 2) + 3) []
23:24:51 <Cale> No stack usage there
23:25:06 <Cale> foldl always succeeds in pattern matching right away
23:25:09 <Cale> but then
23:25:15 <Cale> -> ((0 + 1) + 2) + 3
23:25:32 <Cale> Now, the (...) + 3 can't evaluate without knowing what the (...) is
23:25:41 <Cale> So GHC will put that on a stack
23:26:15 * copumpkin still thinks Cale should write an automatic step-by-step symbol expression reducer for haskell
23:26:37 <luite> and add it to lambdabot :)
23:26:57 <Cale> and you'll get a couple of stack entries until you reach 0 + 1 which reduces to 1, and then that's added to 2 giving 3, which is added to 3 giving 6
23:27:03 <medfly> what do you think Cale is?
23:27:15 <Cale> I *am* the evaluator!
23:27:17 <luite> in the end, it would save him work :p
23:27:22 <Cale> hehe
23:27:25 <ivanm> medfly: the maths master of #haskell!
23:27:31 <Baughn> medfly: Using an AI to evaluate haskell is very inefficient. ;_;
23:27:31 <luite> he's done the foldl reduction quite a few times here
23:28:09 <Cale> Evaluating Haskell code by hand is a good way to get a feel for how things will perform.
23:28:10 <monochrom> Cale evades all attempts at reducing work.
23:28:15 <iaefai> It is interesting :p
23:28:40 <MoALTz> wish there was a macroexpander (for stuff like do blocks)
23:28:46 <iaefai> It seems like whenever I get a parse error, I have no idea what I did wrong...   http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11840#a11840  <-- Chess.hs:41:1: parse error on input `case'
23:28:49 <copumpkin> MoALTz: there is
23:28:58 <Baughn> @undo do foo <- bar; return (1+foo)
23:28:58 <lambdabot> bar >>= \ foo -> return (1 + foo)
23:29:00 <Cale> monochrom: I'll reduce it when a case expression forces me to!
23:29:09 <Baughn> @. pl undo do foo <- bar; return (1+foo)
23:29:09 <lambdabot> (1 +) `fmap` bar
23:29:45 <MoALTz> ?
23:30:15 <mauke> 'exists == False' better written as 'not exists'
23:30:32 <copumpkin> exists -> _|_
23:31:19 <Cale> MoALTz: you're indenting if/then/else incorrectly
23:31:21 <Cale> if foo
23:31:23 <Cale>    then bar
23:31:26 <Cale>    else quux
23:31:32 <Cale> ^^ it should be like that :)
23:31:35 <iaefai> mauke: I'll take that :P
23:31:57 <Cale> The important thing there being that the 'then' and 'else' start on a deeper column than the 'if'
23:32:05 <Cale> But secondarily, they should also line up.
23:32:20 <iaefai> Cale, isn't that stylistic
23:32:30 <Cale> iaefai: Not entirely.
23:32:38 <Cale> iaefai: In particular, writing it like:
23:32:41 <Cale> if foo then
23:32:42 <Cale>   bar
23:32:46 <Cale> else quux
23:32:54 <Cale> Will bite you if you try that inside a do-block
23:33:06 <iaefai> I am doing it inside a do block doesn't seem to be a problem
23:33:10 <Baughn> It also looks worse
23:33:16 <Cale> (because the 'else' starts a new statement of the do-block)
23:33:17 <Baughn> if foo
23:33:17 <iaefai> But I have 'fixed' it
23:33:18 <Baughn>   then bar
23:33:22 <Baughn>   else baz
23:33:25 <Baughn> - Much nicer
23:33:47 <ivanm> Baughn: nah, I prefer them on the same indentation level
23:33:57 <iaefai> Baughn: It is a little more tighter, making less use of whitespace
23:34:06 <ivanm> Baughn: oh, does -indentation deal properly with if statements in do-blocks? that was one thing that indent always failed at...
23:34:33 <Cale> I actually wish the rules regarding indentation of if were stricter.
23:34:38 <Baughn> ivanm: Kind of. There's an annoyance there, but it deals well with them.
23:34:44 <ivanm> *nod*
23:34:53 <Baughn> ivanm: In particular, a bare "then" is indented one column deeper than a "then foo"
23:34:55 <Cale> The 'then' and 'else' should either be on the same line, or they should be aligned with each other.
23:34:59 * Baughn is unsure if that is deliberate or not
23:35:03 <Cale> (start in the same column)
23:35:15 <Cale> But the current rule is way more lax
23:35:15 <ivanm> Baughn: weird :s
23:35:25 <MoALTz> copumpkin: i cannot find it
23:35:44 <copumpkin> MoALTz: someone used it right after I said it... @undo
23:35:47 <Baughn> ivanm: Still, the rule is that haskell-indentation Just Works. :3
23:35:48 <ivanm> Cale: oh? it allows then to be on the same line as if but else to be on a separate line?
23:35:54 <ivanm> Baughn: heh
23:36:07 <ivanm> Baughn: but indent still has fancier auto-insert features, etc.?
23:36:55 <Cale> ivanm: The indentation sensitivity doesn't really care too much about how you lay out if/then/else, so long as you continue the expression in a deeper column than the overall expression started on.
23:37:11 <Cale> (and in fact, even that is saying more than the real rule says)
23:37:12 <ivanm> *nod*
23:37:23 <iaefai> Cale, some how that has fixed the parse error- I don't know how
23:37:26 <Cale> That only applies inside one of the layout keywords
23:37:47 <Cale> iaefai: your 'else' was on a separate line of the do-block, so it was sitting off in its own statement
23:37:50 <Baughn> ivanm: True. I never used any of those, but it does.
23:38:30 <Cale> iaefai: The thing which translates the indentation sensitivity would have inserted a semicolon just before the else, effectively.
23:38:37 <iaefai>     The section `== '/'' takes one argument,    but its type `[a]' has none    In the first argument of `splitOn', namely `(== '/')'  In the expression: splitOn (== '/') uri
23:38:56 <iaefai> :t (=='/')
23:38:57 <lambdabot> Char -> Bool
23:39:21 <iaefai> my fault :-(
23:39:33 <iaefai> I should have used splitwhen if I wanted that
23:40:54 <iaefai> I don't allow for failure of the openFile
23:41:09 <iaefai> :t readFile
23:41:10 <lambdabot> FilePath -> IO String
23:42:29 <iaefai> ok, this is a rather bad pickle - I have a configuration sitting in the main function and this is a request function that needs to get a value from it. How can I structure this? I don't think I can pass a data paramter
23:43:01 <iaefai> hmm, I could use currying
23:43:36 <iaefai> I love this
23:44:20 <cjs> So if I want to be able to half-close a socket, I must do all IO with send and recv, and never turn it into a handle, is that right?
23:45:49 <iaefai> How can I walk through a function in a debug mode?
23:46:58 <blackdog> iaefai: ask Cale
23:47:13 <iaefai> Cale, How can I walk through a function in a debug mode? :p
23:47:28 <blackdog> iaefai: more seriously, it's not hugely easy - better to try to test your functions in small chunks
23:47:52 <iaefai> blackdog: I am not sure how I can test this...
23:48:03 <iaefai> Have this:     server <- initServer 6666 (request config)
23:48:15 <iaefai> Which the first line of the request function is     putStrLn $ "Recieved " ++ (show $ uriPath $ reqURI req)
23:48:40 <iaefai> So I should be able to see that printed out, I usually can until I added the config parameter in there, but it shouldn't have made any difference
23:49:15 <iaefai> Unless there is some laziness that is getting in the way that I don't know enough about
23:53:17 <cjs> Ah, no, I can still use shutdown on a socket even after I've made a Handle from it.
23:54:15 <luite> what is the best way to handle long running algorithms? I currently have something that just prints status updates to the terminal, but I'd like to have a bit more interaction, like for example pausing the algorithm or have it save the current result to a file.
23:54:32 <cjs> I often do that with a server listening on a socket.
23:55:03 <cjs> For very simple poking of the daemon, signals (such as SIGUSR1) are often used, but I've not tried this with ghc. I think that should work, too, though.
23:55:20 <luite> I just want something simple to add to my (terminal) program, networking would probably unnecessarily complicate things
23:55:31 <sanxiyn> What happened to GHC Trac?
23:55:43 <luite> unless there is some framework that already does this
23:57:24 <iaefai> Does this make any sense as to why "" is at the beginning of the results? > splitOn "/" "/ajax/index.html"
23:57:25 <iaefai> ["","ajax","index.html"]
23:58:12 <c_wraith> yes.  it splits out the empty prefix string before the first /
23:58:45 <c_wraith> that's so you can distinguish the output from that of splitOn "/" "ajax/index.html"
23:59:31 <iaefai> drop 1 $ splitOn "/" "/ajax/index.html"   it is then
23:59:35 <c_wraith> also, it makes it an exact inverse of intercalate
