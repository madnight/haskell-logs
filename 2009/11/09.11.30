00:00:56 <desp> Any haddock experts?  Is there any way to document portions of a type synonym declaration using haddock?  I tried doing it like it's done for functions, etc, but it doesn't work.
00:02:20 <EnglishGent> hi copumpkin :)
00:02:26 <copumpkin> hi :)
00:03:45 <EnglishGent> how's things? :)
00:04:20 <copumpkin> not bad, doing real work and trying to stop thinking about CT :P
00:05:16 <EnglishGent> CT = Category Theory? :)
00:05:39 <copumpkin> yep
00:06:10 <EnglishGent> that stuff will drive you bonkers! :P
00:06:28 <copumpkin> yep!
00:17:27 * EnglishGent encounters an particularly nasty type error :|
00:17:34 <EnglishGent> expected Coffee
00:17:41 <EnglishGent> inferred EmptyJar
00:17:53 * copumpkin rubs his eyes and rereads Cofree as Coffee
00:18:03 <copumpkin> terrible!
00:18:16 <idnar> haha
00:18:23 <EnglishGent> indeed!
00:18:25 <copumpkin> Sounds like you found the free monad instead of the cofree comonad :(
00:18:59 * EnglishGent would need more coffee to have a hope in hell of understanding that! :P
00:20:03 <copumpkin> given a functor, you can get a really easy monad out of it
00:20:03 <copumpkin> it's called the free monad! cause you get it with no extra effort ;)
00:20:13 <shachaf> copumpkin: What about the freako monad?
00:20:25 <copumpkin> you can also get a really easy comonad out of a functor
00:20:30 <endojelly> copumpkin, where binding is just subsequent application?
00:21:08 <copumpkin>  Free F A = mu X. A + FX (from category-extras)
00:22:47 <copumpkin> Cofree H A = nu X. A * HX (also from category-extras)
00:22:58 <nolrai_FG> > 1 2
00:22:58 <EnglishGent> what's a comonad? I've heard the term - but dont know what one is
00:22:59 <lambdabot>   Ambiguous type variable `t' in the constraint:
00:22:59 <lambdabot>    `GHC.Num.Num t' arising f...
00:23:38 <copumpkin> EnglishGent: it's like a monad, but instead of join :: f (f a) -> f a, you get f a -> f (f a), and instead of return :: a -> f a you have f a -> a
00:23:44 <copumpkin> so it's "backwards"
00:24:03 <copumpkin> extend and extract are the names of those methods
00:24:39 <nolrai_FG> Its an interesting idea for somethings.
00:24:51 <copumpkin> the cofree comonad itself is quite interesting
00:25:04 <EnglishGent> can you give me an example of one?
00:25:11 <copumpkin> Cofree Identity
00:25:14 <endojelly> copumpkin, what is mu and nu?
00:25:27 <copumpkin> mu is the least fixed point and nu is the greatest fixed point
00:25:29 <desp> copumpkin: are you doing arrows?
00:25:31 <endojelly> ah
00:25:34 <endojelly> thx
00:25:38 <copumpkin> desp: nope
00:25:44 <desp> endojelly: great nick.
00:25:50 <copumpkin> mu and nu are the same thing in haskell
00:25:56 <nolrai_FG> greatest fixed point? that seems strange.
00:26:01 <EnglishGent> hello drwho
00:26:10 <nolrai_FG> copumpkin: when are they differnt?
00:26:20 <copumpkin> nolrai_FG: in languages that make a distinction between data and codata
00:26:24 <drwho> hi
00:26:48 <nolrai_FG> ah, it be nice if haskell did that better.
00:26:50 <copumpkin> that is, data defined inductively (by providing constructors) and data defined coinductively (by providing destructors)
00:27:04 <nolrai_FG> destructors?
00:27:11 <endojelly> desp, thanks!
00:27:16 <copumpkin> well, "deconstructors"
00:27:18 <copumpkin> observers
00:27:22 <EnglishGent> things which take a value apart into other values - *not* C++ style destructors
00:27:31 <copumpkin> yeah
00:27:35 <EnglishGent> (I found that term confusing for a while)
00:27:54 <nolrai_FG> hmm so what would that be for an infinte list?
00:27:58 <copumpkin> so anyway, Cofree is the fixpoint (over X) of A * FX
00:28:02 <ddarius> eliminators
00:28:08 <copumpkin> yeah
00:28:28 <copumpkin> so Cofree Identity would be the fixpoint of A * Identity X
00:28:45 <copumpkin> (a, (a, (a, (a, (a, ...
00:29:07 <desp> I've been doing arrows for the past week.
00:29:35 <nolrai_FG> copumpkin: are those differnt values of type A?
00:29:38 <copumpkin> EnglishGent: so you get infinite streams with the cofree comonad of identity
00:29:49 <desp> Having reread the relevant papers several times, and implemented my own continuation arrows in three different ways, I finally think I start to understand.
00:29:57 <copumpkin> nolrai_FG: yeah, that's the effective type (with appropriate Identity noise in between)
00:30:08 <nolrai_FG> cool I think I get it.
00:30:13 <copumpkin> EnglishGent: if instead you ask for cofree of Maybe
00:30:31 <copumpkin> EnglishGent: you get (a, Just (a, Just (a, Nothing)))
00:30:37 <copumpkin> or things of that "shape"
00:30:40 <nolrai_FG> Posibly finite lists?
00:30:53 <copumpkin> yeah, basically non-empty lists
00:30:54 <desp> Is there anyone here who's familiar with the proc/<-/-< notation for arrows?
00:31:02 <copumpkin> they can be infinite or finite, but cannot be empty
00:31:16 <endojelly> copumpkin, could you write out the example for Free Identity?
00:31:27 <desp> I found that writing things using the sugarful arrow notation increases the CPU usage of my arrow-based sound synthesizer by 10%.
00:31:28 <copumpkin> (this is because it's a comonad, so must have a meaningful extract :: f a -> a)
00:31:34 <EnglishGent> oh that's handy - I've often wanted the type of non-empty lists
00:31:52 <copumpkin> endojelly: you'd have mu X. A + Identity X
00:31:54 <ddarius> type NonEmptyList a = (a, [a])
00:32:15 <EnglishGent> yes - that's how I thought of doing it ddarius
00:32:26 <EnglishGent> but then you need to overload 'head', 'tail', etc
00:32:28 <copumpkin> endojelly: which is Either A (Either A (Either A ...
00:32:33 <EnglishGent> it would be pretty tedious
00:32:40 <endojelly> copumpkin, aah. Either. that's what was missing. thanks
00:33:09 <nolrai_FG> copumpkin: can you make a graph comonad?
00:33:22 <copumpkin> nolrai_FG: well, Cofree [] is a tree
00:33:40 <copumpkin> I was just asking recently if there's a way to express a general graph as the fixed point of a functor
00:33:41 <toast-opt> copumpkin?  is that nick related to comonads?
00:33:44 <copumpkin> but nobody replied
00:34:00 <nolrai_FG> hmm. Interesting.
00:34:06 <copumpkin> toast-opt: vaguely :P I used to be pumpkin but people were spouting so much category theory and co-this and co-that that I changed to copumpkin
00:34:17 <copumpkin> now I've caught the bug too
00:34:20 <toast-opt> copumpkin, i feel quite accomplished for having understood that question.  no where near starting to answer it
00:34:29 <toast-opt> or, at least i think i understand.
00:34:34 <copumpkin> :)
00:34:38 <EnglishGent> dont worry toast-opt - that's about the level I'm at
00:34:54 <toast-opt> englishgent, eh, thx
00:35:00 <EnglishGent> but this channel is full of people who try to warp your brain^H^H^H teach you more
00:35:01 <EnglishGent> :)
00:35:09 <toast-opt> i've noticed it's a cult :)
00:35:15 <toast-opt> they're WAY too helpful not to be one
00:35:26 <ddarius> copumpkin: Perhaps look at Martin Erwig's inductive graph type.
00:35:28 <copumpkin> lol
00:35:33 <toast-opt> "sure, right this way.  would you like a sip of this pure lazy evaluation?"
00:35:47 <ddarius> That said, I doubt it is a free algebra.
00:35:56 <toast-opt> "trust me, it won't hurt you at all.  it's side-effect free"
00:36:20 <copumpkin> ddarius: yeah :/ I'll check out the paper though, thanks
00:36:32 <EnglishGent> but sometimes we want things with side effects! caffine:: IO Bloodstream -> IO Bloodstream
00:36:44 <nolrai_FG> ghc wont try to use litterals as constructors right? this is a silly question, I think.
00:36:47 * EnglishGent would sort of like to evalutate that now!
00:36:49 <bastl> dcoutts: are you there? I have a question regarding cabals preprocessing.
00:37:05 <ddarius> copumpkin: If you don't care about something naturally implementable in Haskell, you can represent the category of graphs as a presheaf category and it forms a topos.
00:37:21 <copumpkin> ack :) haven't explored sheaves yet
00:37:32 <copumpkin> ddarius: any references for that when I get there?
00:37:46 <ddarius> Presheafs are trivial.  The entire definition is: a contravariant set-valued functor.
00:37:56 <EnglishGent> ddarius - can you explain quickly what a sheaf is? I actually know what a topos is!
00:38:11 * EnglishGent has yet to encounter anything about sheafs that makes any kind of sense though
00:38:14 <ddarius> EnglishGent: A sheaf is more complicated.
00:38:19 <copumpkin> ok, seems simple enough
00:38:58 <ddarius> copumpkin: Barr and Wells ESSLLI lecture notes goes over the subobject classifier for graphs and some other things, though it doesn't present graphs as presheaves.
00:39:17 <ddarius> John Baez has an article where he covers some presheaves including graphs.
00:39:46 <ddarius> Technically, that the category of graphs forms a topos is a corollary to its representation as a presheaf category.
00:41:09 <ddarius> Anyway, consider the category with two objects and two non-identity arrows both going from the first object to the second, call it C.  The presheaves over that category, i.e. the functors C^op -> Set, are graphs.
00:41:57 <copumpkin> hm
00:42:27 <ddarius> copumpkin: I could make it more clear to you, or I can leave you to unfold the definitions and work out the details and see how it all comes together.
00:44:24 * copumpkin is thinking about it
00:45:56 <Cale> Hint: It doesn't correspond *exactly* to the classical definition of a graph. The arrows are sent to source and target functions from a set of objects to an abstract set of edges.
00:46:38 <EnglishGent> hi Cale :)
00:46:39 <Cale> (Which is about the best you're going to do from a category theoretic standpoint :)
00:46:41 <Cale> Hi :)
00:47:50 <Cale> Er, from a set of *edges* to an abstract set of *vertices*
00:50:02 <Cale> I just woke up, and right before I got up, I was looking around my room and staring at the ceiling, and I see that it's morning and light out, and so I decide to get up. So I open my eyes (!) and find out that it's 3am and dark in my room.
00:50:31 <cizra> Uh.. foldr is fold TO right, not fold from right, right?
00:50:51 <Cale> cizra: It produces a right-associated expression.
00:50:57 <Cale> > foldr f z [1..5]
00:50:59 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 z))))
00:51:04 <dibblego> cizra, do you know that a list such as [1,2,3] is syntactic for 1:2:3:[] ?
00:51:40 <Cale> foldr f z is the natural one because all it does is replace each (:) in the list with f and the [] at the end with z
00:52:01 <cizra> dibblego: yes
00:52:04 <Cale> foldl also flips the list around a bit.
00:52:14 <Cale> > foldl f z [1..5]
00:52:16 <lambdabot>   f (f (f (f (f z 1) 2) 3) 4) 5
00:52:29 <dibblego> cizra, foldr f z [1,2,3] does 1 `f` 2 `f` 3 `f` z
00:52:45 <Cale> So now the 5 which was at the end of the list is near the top of the expression, and the 1 is buried deep inside it.
00:52:53 * cizra ponders
00:53:14 <cizra> I just wrote successfully a function that checks if a string is full o' digits, using folds. But I'm not sure I grok them completely.
00:53:31 <dibblego> @type all
00:53:33 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
00:53:37 <Cale> dibblego: 1 `f` (2 `f` (3 `f` z)) of course, rather than ((1 `f` 2) `f` 3) `f` z   ;)
00:53:52 <EnglishGent> Cale - perhaps you woke up during co-morning :)
00:53:52 <dibblego> Cale, yeah I wondered whether to correct it, sorry :)
00:53:57 <copumpkin> ddarius, Cale: okay, I'm not seeing where the "edges" are coming from :/
00:54:20 <ddarius> copumpkin: What's the typical set theoretic definition of a graph?
00:54:45 <birdy_> if I have a [[Integer]] like [[1,2,3,4,3,3,7,8,9], [3,3,3,4,5,6,7,8,9]] and I want to return the index of each element that is 3 so like I get a list of that in a structure like this [(0,2), (0,4),(0,5), (1,0)(1,1),(1,2)]  what functions should I look into?
00:54:45 <copumpkin> set of vertices and set of edges?
00:54:46 <Cale> copumpkin: Suppose you have two sets, say, V and E, and a pair of functions s,t: E -> V
00:54:51 <ddarius> copumpkin: Yep.
00:55:01 <EnglishGent> @hoogle (Eq a) => a -> (a -> a) -> a
00:55:02 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
00:55:02 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
00:55:02 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
00:55:32 <Cale> copumpkin: The s function associates each edge to a source vertex, and the t function associates it with a target vertex.
00:55:38 <copumpkin> ah
00:55:52 <copumpkin> I'm assuming the two objects in C have something to do with that
00:56:17 <Cale> Not much, and the fact that it was C^op doesn't really do anything here.
00:56:26 <ddarius> C^op = C in this case.
00:56:27 <copumpkin> oh
00:56:48 <Cale> The fact that there were two objects is important
00:56:51 <ddarius> And there are no, non-trivial, composable arrows.
00:57:27 <copumpkin> it feels vaguely subobjecty but my only real knowledge of topoi is the definition, so I'm not exactly comfortable with finding them or working with the definitions much
00:57:39 <copumpkin> subobject-classifier-y, rather :P
00:57:40 <ddarius> copumpkin: Don't worry about the topos aspect yet.
00:57:43 <copumpkin> ok
00:57:48 <Saizan_> birdy_: findIndex
00:58:19 <ddarius> copumpkin: The subobject classifier makes sense when you see it but is not something you'd immediately come up with unless you were pretty familiar with subobject classifiers.
00:58:28 <copumpkin> I see
00:59:32 <ddarius> (The subobject classifier is a graph with two nodes and 5 edges.)
00:59:46 <copumpkin> :o
01:01:04 <birdy_> @src [a] -> a
01:01:04 <lambdabot> Source not found. :(
01:01:15 <Veinor> I got quoted in HWN :O
01:01:15 <birdy_> @hoogle [a] -> a
01:01:16 <lambdabot> Prelude head :: [a] -> a
01:01:16 <lambdabot> Prelude last :: [a] -> a
01:01:16 <lambdabot> Data.List head :: [a] -> a
01:02:05 <Veinor> cizra: well, strictly speaking the best way to do that is using all :P
01:02:13 <Veinor> @hoogle all
01:02:14 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
01:02:14 <lambdabot> Data.ByteString all :: (Word8 -> Bool) -> ByteString -> Bool
01:02:14 <lambdabot> Data.Foldable all :: Foldable t => (a -> Bool) -> t a -> Bool
01:02:25 <Veinor> @src all
01:02:25 <lambdabot> all p =  and . map p
01:03:06 <Veinor> > all even [2, 4, 6, 8]
01:03:08 <lambdabot>   True
01:03:10 <Veinor> > all even [2, 4, 6, 7]
01:03:12 <lambdabot>   False
01:03:54 <EnglishGent> @djinn (a -> b ) -> (b -> c) -> (a -> c)
01:03:55 <lambdabot> f a b c = b (a c)
01:03:56 <yitz> birdy_: you could also transform the matrix into a flat list labeled with coordinates [((Int, Int), a)], then just use fst . filter
01:04:05 * EnglishGent just demoing djinn for someone :)
01:04:18 <Veinor> also, is hoogle not working for anybody else?
01:04:27 <birdy_> ye hoogle is down :/
01:04:29 <copumpkin> Veinor: at least a dozen people ;)
01:04:38 <Veinor> :(
01:04:50 <Veinor> @djinn a -> a
01:04:51 <lambdabot> f a = a
01:05:00 <Veinor> so @djinn takes a signature and tries to guess what you want?
01:05:16 <copumpkin> well, gives a function that has the type
01:05:16 <Veinor> @djinn [a] -> a
01:05:17 <lambdabot> Error: Undefined type []
01:05:22 <mxc> veinor - yeah, its pretty cool
01:05:22 <MoALTz> @djinn a -> (a,a)
01:05:23 <lambdabot> f a = (a, a)
01:05:34 <Veinor> @djinn a -> b
01:05:34 <lambdabot> -- f cannot be realized.
01:05:38 <Veinor> heheh
01:05:38 <copumpkin> @djinn (a -> a -> b) -> a -> b
01:05:39 <lambdabot> f a b = a b b
01:05:40 <yitz> Veinor: hoogle does that. djinn actually tries to create the function itself.
01:05:45 <mxc> @djinn [Maybe (a,b)] -> [a]
01:05:46 <lambdabot> Error: Undefined type []
01:05:52 <copumpkin> djinn doesn't know about lists
01:06:01 <mxc> right
01:06:11 <Veinor> @djinn Maybe a -> a
01:06:11 <lambdabot> -- f cannot be realized.
01:06:18 <Veinor> @djinn a -> Maybe a
01:06:18 <lambdabot> f = Just
01:06:35 <MoALTz> @djinn Just a -> a
01:06:36 <lambdabot> Error: Undefined type Just
01:06:53 <copumpkin> it's pretty smart
01:07:00 <cjs> Is there a form of 'bracket' where the computation to be run last is passed arguments that will tell it if the "computation to run in-between" threw an exception or not?
01:07:05 <Veinor> @djinn a -> Either a b
01:07:05 <lambdabot> f = Left
01:07:08 <Veinor> :D
01:07:14 <Veinor> @djinn a -> a -> a
01:07:15 <lambdabot> f _ a = a
01:07:41 <copumpkin> give it something harder :P
01:07:50 <mxc> anyone know why cabal install XX --enable-documentation woudl run fine, but when I try to run runghc Setup.hs haddock --executables , I get a bunch of system errors like "32-bit absolute addressing is not supported for x86-64" and "suffix or operands invalid for `push'"   (this is GHC 6.10.4 on OS X Snow Leopard)
01:07:58 <yitz> cjs: no, but it's easy to do that with try
01:08:06 <mxc> seems like its trying to run some bit of 64-bit code somewhere, but can't figure out where
01:08:12 <copumpkin> @djinn Either a b -> (b -> c) -> (c -> d) -> (b -> d -> e) -> e
01:08:12 <lambdabot> -- f cannot be realized.
01:08:13 <cjs> Right. I just didn't want to have to write the extra code. :-)
01:08:18 <Veinor> @djinn a -> b -> a -> (a -> b) -> Bool
01:08:19 <lambdabot> f _ _ _ _ = False
01:08:24 <Veinor> that's cheating :(
01:08:35 <copumpkin> @djinn (a, b) -> (b -> c) -> (c -> d) -> (a -> b -> d -> e) -> e
01:08:36 <lambdabot> f (a, b) c d e = e a b (d (c b))
01:08:54 <ddarius> Veinor: That's the only total definition for that other than return True.
01:08:59 <ddarius> s/return/returning
01:09:07 <mxc> @djinn-add data R a c = R ((String -> c) -> (a -> c) -> c))
01:09:07 <lambdabot> Cannot parse command
01:09:12 <Veinor> @djinn  a -> (a -> b) -> b -> Bool
01:09:13 <lambdabot> f _ _ _ = False
01:09:20 <mxc> @djinn data R a c = R ((String -> c) -> (a -> c) -> c))
01:09:20 <lambdabot> Cannot parse command
01:09:23 <ddarius> Veinor: What else are you expecting?
01:09:23 <Veinor> what about f a g b = (g a) == b
01:09:31 <copumpkin> Veinor: no Eq
01:09:32 <mxc> how do you hadd datatypes to the lambdabot djinn?
01:09:36 <ddarius> That doesn't have type a -> (a -> b) -> b -> Bool
01:09:36 <Veinor> ahhhhhhh, yeah
01:09:39 <mxc> @djinnadd data R a c = R ((String -> c) -> (a -> c) -> c))
01:09:39 <lambdabot> Cannot parse command
01:09:44 <Veinor> forgot about typeclasses
01:09:57 <Veinor> it's 4:15 >_>
01:10:01 <copumpkin> djinn could probably be augmented with them
01:10:05 <yitz> @djinn Bool -> Bool -> Bool
01:10:05 <copumpkin> but I don't think it knows about them now
01:10:05 <lambdabot> f a b =
01:10:05 <lambdabot>     case a of
01:10:05 <lambdabot>     False -> b
01:10:05 <lambdabot>     True -> False
01:10:06 <ddarius> @djinn Eq a => a -> b -> a -> (a -> b) -> Bool
01:10:06 <lambdabot> f a _ b _ = a == b
01:10:09 <mxc> oh well, i was trying to implement a CPS style either the other day and needed Applicative instances
01:10:15 <ddarius> @djinn Eq a => a -> b -> (a -> b) -> Bool
01:10:16 <lambdabot> f a _ _ = a == a
01:10:18 <copumpkin> oh, it knows about them!
01:10:32 <Veinor> @djinn Eq b => a -> (a -> b) -> b -> Bool
01:10:34 <lambdabot> f a b = (==) (b a)
01:10:39 <kmc> anyone read this _Pattern Calculus_ book by Barry Jay?
01:10:39 <Veinor> :D
01:10:41 <ddarius> copumpkin: It can handle type classes in the restricted, Haskell 1.0 sense of the term.
01:10:41 <kmc> it was on LTU or something
01:10:48 <copumpkin> ah, nice
01:10:56 <MoALTz> > (\a b -> b) 1 2
01:10:58 <lambdabot>   2
01:11:11 <Veinor> step 2 for djinn: making it use f and g for functions :P
01:11:13 <ddarius> kmc: I've read the intro which is available and many of the surrounding papers but not the book.
01:11:18 <yitz> hmm, why in the world did it pick a || (not b) ?
01:11:19 <mxc> @djinn R ((String -> c) -> ((a -> b) -> c) -> c)) ->  R ((String -> c) -> ((a -> b) -> c) -> c)) ->  R ((String -> c) -> ((b -> b) -> c) -> c))
01:11:20 <lambdabot> Cannot parse command
01:11:20 <ddarius> kmc: I wouldn't mind reading the book.
01:11:32 <copumpkin> yitz: it had to pick something :P
01:11:35 <mxc> @djinn  ((String -> c) -> ((a -> b) -> c) -> c)) ->   ((String -> c) -> ((a -> b) -> c) -> c)) ->   ((String -> c) -> ((b -> b) -> c) -> c))
01:11:35 <lambdabot> Cannot parse command
01:11:37 <Veinor> @djinn a -> R a
01:11:38 <lambdabot> Error: Undefined type R
01:11:43 <copumpkin> yitz: it's not really thinking about the booleanness of the types
01:11:52 <mxc> @djinn  ((String -> c) -> ((a -> b) -> c) -> c) ->   ((String -> c) -> ((a -> b) -> c) -> c) ->   ((String -> c) -> ((b -> b) -> c) -> c)
01:11:52 <lambdabot> Error: Undefined type String
01:11:56 <yitz> @djinn Int -> Int -> Int
01:11:56 <lambdabot> Error: Undefined type Int
01:12:00 <ddarius> yitz: It tries to use each variable once.
01:12:06 <mxc> @djinn  ((s -> c) -> ((a -> b) -> c) -> c) ->   ((s -> c) -> ((a -> b) -> c) -> c) ->   ((s -> c) -> ((b -> b) -> c) -> c)
01:12:07 <lambdabot> f a _ b c = a b (\ _ -> c (\ d -> d))
01:12:08 <yitz> @djinn Integer -> Integer -> Integer
01:12:08 <lambdabot> Error: Undefined type Integer
01:12:15 <Veinor> @djinn Eq a -> a -> a -> Bool -> Bool
01:12:15 <lambdabot> Error: Undefined type Eq
01:12:19 <Veinor> @djinn Eq a => a -> a -> Bool -> Bool
01:12:20 <lambdabot> f a _ b =
01:12:20 <lambdabot>     case a == a of
01:12:20 <lambdabot>     False -> b
01:12:20 <lambdabot>     True -> False
01:12:25 <MoALTz> > let tttt :: a -> (a -> a -> a) -> a -> a; tttt a f b = a * b; in tttt 2 + 3
01:12:27 <lambdabot>   Could not deduce (GHC.Num.Num a) from the context ()
01:12:28 <lambdabot>    arising from a use ...
01:12:39 <copumpkin> @djinn Not (Not (Not a)) -> Not a
01:12:40 <lambdabot> f a b = void (a (\ c -> c b))
01:12:46 <Veinor> I don't know why but that function amuses me
01:12:51 <yitz> @djinn Num a => a -> a -> a
01:12:51 <lambdabot> Error: Class not found: Num
01:13:01 <MoALTz> void?
01:13:05 <Veinor> :t void
01:13:06 <lambdabot> Not in scope: `void'
01:13:10 <Veinor> ...
01:13:11 <manju> how do I make a program quit after a list reaches a certain length ?
01:13:24 <manju> rather a function should return
01:13:25 <copumpkin> :k Not
01:13:26 <lambdabot> Not in scope: type constructor or class `Not'
01:13:29 <kmc> ddarius, okay.  wondering whether to drop $80 on it
01:13:37 <ddarius> yitz: Given a Bool, 'a', all proofs using it are of the form: case a of False -> ...; True -> ... and then it had to use b so it stuck that in the first branch, then it needed a boolean so it chose False because data Bool = False | True.
01:13:38 <kmc> i guess i can feel warm & fuzzy about supporting PL research ;P
01:13:41 <Peaker> manju, what do you want it to do?
01:13:51 <blackh> manju: Pass a number along with your recursion (that's one way)
01:13:54 <MoALTz> manju: take MYLENGTH ?
01:14:05 <MoALTz> take 101 myListGen
01:14:15 <yitz> manju: hit ctrl-C
01:14:19 <yitz> sorry
01:14:23 <Veinor> haha
01:14:26 <Veinor> okay... press it NOW
01:14:29 <copumpkin> :t let f a b = ?void (a (\ c -> c b)) :: (((a -> Void) -> Void) -> Void) -> a -> Void in f
01:14:31 <lambdabot> Not in scope: type constructor or class `Void'
01:14:31 <lambdabot> Not in scope: type constructor or class `Void'
01:14:31 <lambdabot> Not in scope: type constructor or class `Void'
01:14:31 <MoALTz> yitz has the best answer
01:14:34 <manju> yitz: no I understand it is a dumb question
01:14:43 <yitz> manju: no no i didn't mean that
01:14:44 <Veinor> I still hav eno clue what the hell Void is
01:15:02 <copumpkin> :t let f a b = ?void (a (\ c -> c b)) :: (((a -> ()) -> ()) -> ()) -> a -> () in f
01:15:03 <Veinor> google says it's bottom
01:15:04 <manju> I am kind of stuck in thinking in recursive way :-(
01:15:04 <lambdabot>     Could not deduce (?void::t1
01:15:04 <lambdabot>                              -> (((a2 -> ()) -> ()) -> ())
01:15:04 <lambdabot>                              -> a2
01:15:05 <ddarius> kmc: The content its covering is definitely interesting, but probably not too directly relevant unless you are planning on making a language.  The presentation going by the introduction is fairly readable and comprehensive.  However, you can probably get most of what you want from the papers with a bit more effort but for free.
01:15:08 <MoALTz> Veinor: i think it used to be part of the language until haskell 98 revised?
01:15:14 <MoALTz> no idea what it did
01:15:30 <Veinor> according to wikibooks it has no values
01:15:31 <copumpkin> Veinor: it's an empty type
01:15:34 <copumpkin> except not really empty
01:15:35 <yitz> manju: the point is, it depends on the context. in Haskell you don't think about "doing" something, like quitting. you think about what value will be the result.
01:15:37 <Veinor> so, _|_ ?
01:15:45 <MoALTz> http://haskell.cs.yale.edu/definition/aboutHaskell98.html  "Chapter 6: basic types" "Remove the Void type."
01:15:46 <copumpkin> Veinor: for some definitions of that, yep
01:15:46 <osaunders> Am I right in saying a single function can't accept a list or atom, even with :: a?
01:15:49 <JohnnyL> are there such a thing as functional databases?
01:15:59 <Peaker> @djinn (forall a. a -> b) -> b
01:16:00 <lambdabot> -- f cannot be realized.
01:16:11 <Peaker> sure it can! give it ()
01:16:14 <copumpkin> lol
01:16:21 <Veinor> haha, so void :: Void -> a
01:16:22 <Veinor> awesome
01:16:40 <yitz> manju: so one way to do what you are saying would be first apply "take n" to the list, so you are only looking at the first n elements, then apply the rest of your calculation.
01:16:48 <copumpkin> Veinor: if this stuff interests you, need I remind you which channel you should join? ;)
01:17:13 <Veinor> :P
01:17:18 <Veinor> tempter!
01:17:32 <Veinor> I might read http://en.wikibooks.org/wiki/Haskell/The_Curry-Howard_isomorphism actually
01:17:32 <ddarius> JohnnyL: I think those would roughly correspond to network databases.
01:17:50 <Veinor> not terribly complete, but it still looks interesting
01:18:32 <copumpkin> Veinor: yeah, it's sadly incomplete
01:19:26 <manju> yitz: I figured it was the wrong question to ask after I asked it
01:19:52 <manju> I have a function to which I pass a number it says if it is prime or not
01:20:01 <yitz> manju: hehe, ok. but are we moving in the right direction towards what you are looking for?
01:20:09 <manju> I want to generate the first 10001 prime numbers
01:20:29 <manju> I wrote something like
01:20:50 <manju> [x | x <- [2..], isPrime x]
01:20:59 <manju> but I don't how to stop at 10001
01:21:04 <manju> don't know*
01:21:06 <ddarius> Peaker: Djinn doesn't handle higher rank polymorphism so I'm not sure how it is viewing (forall a. a -> b) -> b.
01:21:17 <Veinor> well, actually you'd want to write take 10001 $ filter isPrime [2..]
01:21:29 <yitz> manju: write primes = <compute *all* primes>, then write take 10001 primes
01:21:30 <Veinor> filter isPrime [2..] basically does what that list comprehension does, and is more standard
01:21:49 <ddarius> @djinn (a + b -> a) -> (a + b) -> a
01:21:50 <lambdabot> Cannot parse command
01:22:00 <manju> I don't $ or filter, so maybe I need to go back to the book :-)
01:22:01 <Veinor> ... the hell?
01:22:07 <manju> Veinor: thanks
01:22:20 <Veinor> well, $ is really simple; f $ x = f x
01:22:21 <yitz> take 10001 (filter isPrime [2..])
01:22:29 <Veinor> it just makes code look nicer sometimes
01:22:40 <yitz> > filter even [0..10]
01:22:41 <lambdabot>   [0,2,4,6,8,10]
01:22:42 <manju> ah...
01:23:02 <manju> filter is like filter in lambda functions ?
01:23:25 <Baughn> manju: filter is a function. It's the same function everywhere.
01:23:35 <yitz> take 10001 $ filter isPrime [2..] <-- manju, if you want to look like a Haskell geek :)
01:23:36 <manju> the hard part of haskell is unlearning the bad habits
01:23:44 <kmc> yes
01:23:52 <Baughn> ..no
01:23:55 <manju> yitz: cool :-)
01:24:16 <Baughn> That's /a/ hard part, but there are plenty of others. Like figuring out nine-level monad transformers and whatnot..
01:24:42 <yitz> take 10001 . filter isPrime $ 2:[3,5..] <-- manju, even geekier
01:24:46 <manju> Baughn: my brain will probably give up and explode before that
01:24:54 <ddarius> @google monad transformers and modular interpreters
01:24:59 <lambdabot> http://citeseer.ist.psu.edu/liang95monad.html
01:25:05 <manju> yitz: is the . part of the code ?
01:25:18 <Veinor> yitz: hehe
01:25:21 <yitz> manju: it's ok, we have a special bot on this channel that cleans up exploded brain matter
01:25:41 <Veinor> yeah, the . is part of the code
01:25:52 <yitz> manju: yes. f . g means composition - first apply g, then apply f to the result
01:25:54 <Veinor> @src (.)
01:25:55 <lambdabot> (f . g) x = f (g x)
01:25:56 <yitz> @src (.)
01:25:57 <lambdabot> (f . g) x = f (g x)
01:26:06 <Veinor> it's another one of those 'there mostly for making code look nicer
01:26:12 <Veinor> things
01:26:18 <ski> @quote gooey
01:26:19 <lambdabot> Botje says: the faster your brain blows, the faster we can get at the gooey insides!
01:26:24 <osaunders> Why doesn't this work? ....
01:26:28 <osaunders> > [1] :: [a]
01:26:29 <ddarius> Veinor: (.) is pretty fundamental.
01:26:30 <lambdabot>   Could not deduce (GHC.Num.Num a) from the context ()
01:26:30 <lambdabot>    arising from the li...
01:26:48 <ski> osaunders : `a' is a type variable
01:27:12 <ski> use a definite type (or use it in a context where `a' is bound and where `Num a' is assumed)
01:27:14 <Veinor> because these both work
01:27:14 <ddarius> Veinor: ($) is just id (which is also fundamental, but also trivial)
01:27:14 <Veinor> > [1] :: [Double]
01:27:14 <lambdabot>   [1.0]
01:27:14 <Veinor> > [1] :: [Int]
01:27:14 <lambdabot>   [1]
01:27:14 <osaunders> Ah.
01:27:15 <osaunders> OK.
01:27:23 <ski> > [1] :: Num a => [a]
01:27:26 <lambdabot>   [1]
01:27:54 <Veinor> > "sdf" :: [a]
01:27:54 <lambdabot>   Couldn't match expected type `a'
01:27:54 <lambdabot>         against inferred type `GHC.Types.C...
01:27:54 <ddarius> :t [1]
01:27:54 <lambdabot> forall t. (Num t) => [t]
01:27:54 <manju> take 10001 (filter (isPrime [2..])) <- I can also write like this and look like a n00b and it would still work right ?
01:27:55 <Baughn> > (`id` 3) . [(+1),(*2)]
01:27:55 <lambdabot>   [4,6]
01:27:59 <ski> > ([1] :: Num a => [a]) :: [Integer]
01:28:01 <lambdabot>   [1]
01:28:11 <Veinor> manju: you can't use filter (isPrime [2..])
01:28:22 <Veinor> you have to say filter isPrime [2..]
01:28:23 <ski> > ([1] :: [Integer]) :: Num a => [a]
01:28:25 <lambdabot>   Couldn't match expected type `a'
01:28:25 <lambdabot>         against inferred type `GHC.Integer...
01:28:29 <Veinor> because filter is taking  isPrime and [2..] as arguments
01:28:41 <manju> ah
01:28:49 <ski> (so the `a' there is implicitly universally quantified ..)
01:28:55 <yitz> > "sdf" :: Show a => [a]
01:28:56 <lambdabot>   Couldn't match expected type `a'
01:28:57 <lambdabot>         against inferred type `GHC.Types.C...
01:28:58 <Baughn> manju: filter is a combination of map and.. um, filter id. It's a HOF.
01:29:00 <copumpkin> Cale, ddarius: sleep time for me, I'll think more about that presheaf graph category stuff tomorrow :) thanks for the explanations + hints so far!
01:29:10 <manju> Baughn: HOF ?
01:29:27 <Baughn> manju: Higher-order function; function that takes another function as parameter(s)
01:29:58 <Baughn> manju: ..a concept that is pretty fundamental here, and used /all/ over the place, including in syntax
01:31:33 <manju> Baughn: ah...ok I am one chapter before HOFs I think
01:32:58 <ski> (Cale : maybe a "false awakening" ?)
01:33:46 <Baughn> > fix ((1:) . (0:)  . curry (zipWith (+) . second tail . join (,))
01:33:46 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:34:10 <Baughn> > fix ((1:) . (0:)  . uncurry (zipWith (+)) . second tail . join (,))
01:34:11 <lambdabot>   [1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
01:34:27 <Baughn> manju: Well, here's an extreme case. Have fun figuring out that line. :3
01:34:52 <MoALTz> :t second
01:34:54 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
01:35:04 <manju> Baughn: what `is` that ? o_0
01:35:11 <manju> let me copy it
01:35:24 <osaunders> It's adding the two last
01:35:25 <yitz> Baughn: why mess with tuples? just use zipWith uncurried
01:35:28 <osaunders> 1 and 0 is 1
01:35:33 <osaunders> 0 1
01:35:37 <osaunders> and 1 is 1
01:35:46 <osaunders> 1 1 -> 2
01:35:51 <osaunders> 1 2 -> 3
01:36:01 <osaunders> 2 3 -> 5 etc.
01:36:07 <manju> fibonacci
01:36:12 <Baughn> Righto
01:36:20 <manju> my fibonacci was half a page
01:36:21 <Baughn> I got the initial 0 and 1 backwards. :P
01:36:36 <Baughn> ..how do you manage /that/?
01:36:40 <Saizan_> yeah, zipWith (+) `ap` tail, ftw
01:36:50 <osaunders> :t ap
01:36:50 <yitz> Baughn: it's ok. fibonacci figured out what you wanted anyway
01:36:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
01:36:58 <Baughn> yitz: Yeah, I saw
01:37:04 <ski> > fix ((0:) . (1:)  . uncurry (zipWith (+)) . second tail . join (,))
01:37:04 <manju> heh
01:37:05 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
01:37:23 <Baughn> yitz: And I'm not quite sure how to do it without uncurry. I could figure it out, but it'd probably take a few tries.
01:37:23 <ski> Baughn : that is actually readable
01:37:38 <Baughn> ski: Well, of course, what did you expect?
01:37:42 <shachaf> ski: "ap" is readable!
01:37:44 <osaunders> What does . do?
01:37:52 <Saizan_> ?src .
01:37:52 <lambdabot> (f . g) x = f (g x)
01:37:53 <Baughn> osaunders: ..function composition
01:38:01 <Baughn> osaunders: (+1) . (+3) = (+4)
01:38:02 <shachaf> ski: Going through the tuple only obscures things.
01:38:22 <osaunders> > ((+1) . (+3)) 1
01:38:24 <lambdabot>   5
01:38:33 <Saizan_> > fix ((0:) . (1:) . zipWith (+) `ap` tail)
01:38:33 <ski> (well, i read "Have fun figuring out that line." as implying that it would be harder to read .. but maybe that was intended as practice for manju)
01:38:34 <lambdabot>   Precedence parsing error
01:38:34 <lambdabot>      cannot mix `L..' [infixr 9] and `Control.Mona...
01:38:44 <Saizan_> > fix ((0:) . (1:) . (zipWith (+) `ap` tail))
01:38:44 <ski> shachaf : may well be
01:38:45 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
01:38:47 <manju> ski: it was
01:38:48 <yitz> Baughn: hmm, people usually use <*> or ap. Without that you might need a lambda, in which case you might as well stick with the tuples.
01:39:07 <Baughn> ski: I dare say manju would see that as an eldritch horror from out of space. :P
01:39:16 <dibblego> > let fibs a b = a : fibs b (a + b) in fibs 0 1
01:39:17 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
01:39:21 <manju> heh
01:39:27 <yitz> > fix ((0:).(1:).(zipWith ,*> tail))
01:39:28 <ski> Baughn : maybe .. you could ask her/him :)
01:39:29 <lambdabot>   A section must be enclosed in parentheses thus: (*> tail)
01:39:43 <manju> him
01:39:44 <yitz> > fix ((0:).(1:).(zipWith <*> tail))
01:39:46 <lambdabot>   Couldn't match expected type `[t]'
01:39:46 <lambdabot>         against inferred type `a -> b ->...
01:39:58 <ski> (+)
01:40:01 <yitz> > fix ((0:).(1:).(zipWith (+) <*> tail))
01:40:03 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
01:40:05 <yitz> thanks
01:40:15 <Saizan_> (i actually think <*> is more obscure than the tuple way)
01:40:30 <MoALTz> > fix ((-3:).(-2:).(zipWith (+) <*> tail))
01:40:31 <shachaf> Saizan_: Just because of the name, no? S is a pretty standard function.
01:40:32 <lambdabot>   [-3,-2,-5,-7,-12,-19,-31,-50,-81,-131,-212,-343,-555,-898,-1453,-2351,-3804...
01:40:34 <Baughn> yitz: What I always forget is that, in the context of exploiting lazy evaluation, a chain of (.)s is executed /from left to right/
01:40:36 <yitz> Saizan_: yeah
01:40:39 <MoALTz> > fix ((-3:).(2:).(zipWith (+) <*> tail))
01:40:41 <lambdabot>   [-3,2,-1,1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,...
01:41:26 <yitz> > fix ((1:).(3:).(zipWith (+) <*> tail))
01:41:27 <lambdabot>   [1,3,4,7,11,18,29,47,76,123,199,322,521,843,1364,2207,3571,5778,9349,15127,...
01:41:29 <fasta> <*> is a method, which resolves to some concrete function. So, by definition it is more obscure.
01:42:05 <Baughn> @oeis 1 3 4 7 11
01:42:06 <lambdabot>  Lucas numbers (beginning at 2): L(n) = L(n-1) + L(n-2). (Cf. A000204.)
01:42:06 <lambdabot>  [2,1,3,4,7,11,18,29,47,76,123,199,322,521,843,1364,2207,3571,5778,9349,15127...
01:42:13 <yitz> fasta: <*> is applicative, so by definition it is more obscure
01:42:41 <Saizan_> i wouldn't say that
01:42:48 <Baughn> Applicative is obscure? Every. Single. One. of my files start with "import Control.Applicative"
01:43:06 <manju> if I see a couple of more perl like one liners, I've had it :-)
01:43:19 <fasta> Baughn, if you don't need it, it is, imho.
01:43:20 <dibblego> perl-like?
01:43:25 <Baughn> manju: Oh, I forgot to show you the definition of fix..
01:43:27 <Baughn> @src fix
01:43:27 <lambdabot> fix f = let x = f x in x
01:43:38 <manju> ah
01:45:14 <osaunders> You could use . to emulate do.
01:45:20 <osaunders> It ensures sequence, right?
01:45:24 <osaunders> > ((\x -> [x]) . (+3)) 9
01:45:26 <lambdabot>   [12]
01:45:53 <osaunders> works but the other way round you'll get a type error.
01:45:53 <osaunders> > ((+3) . (\x -> [x])) 9
01:45:53 <lambdabot>   No instance for (GHC.Num.Num [t])
01:45:53 <lambdabot>    arising from the literal `3' at <inter...
01:46:04 <Saizan_> . has not the type of >>= for e.g. the list monad
01:46:09 <Saizan_> it doesn't do the same at all
01:47:12 <osaunders> Well not the same but you can use to . execute pure functions sequentially.
01:47:18 <Saizan_> no
01:47:36 <osaunders> But it strings them together no?
01:47:46 <Baughn> Hey.. could someone try to cabal-install AES? See if the build failure is just on hackage?
01:48:01 <osaunders> Baughn: What's AES?
01:48:17 <Baughn> osaunders: A hackage package. It does what it says on the box.
01:48:35 <Saizan_> osaunders: yes, it composes them, and the data flows in a certain direction, it doesn't add more sequencing than what you get with application though
01:48:55 <osaunders> Baughn: Alright, I'm giving it a whirl now.
01:49:43 <osaunders> Baughn: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13394#a13394
01:49:54 <osaunders> Saizan_: With application?
01:50:14 <Baughn> osaunders: Hm. It's odd how it compiles locally, but..
01:50:21 <Baughn> osaunders: 0.0.3 coming up, I guess. I missed a header.
01:50:38 <fasta> Baughn, it doesn't work on Windows.
01:50:38 <Baughn> osaunders: Also, it's amazing how noisy that package is on 6.10. ^^;
01:50:49 <Saizan_> osaunders: in (f (g x)), the f takes the result of g applied to x, if you call that sequencing than . sequences, otherwise not
01:51:04 <Baughn> fasta: It doesn't work anywhere, at the moment. Still.. in what manner does it fail to work, exactly?
01:51:31 <fasta> Baughn,  cbits\aeskey.c:32:27:  aes_via_ace.h: No such file or directory
01:51:37 <Saizan_> osaunders: in particular, there's no sequencing of evaluation, but monads don't necessarily sequence that either
01:51:40 <osaunders> Saizan_: Yeah, I still that sequence but I guess I'm stretching the terminology.
01:51:44 <fasta> Baughn, I don't see why people upload broken stuff.
01:51:47 <osaunders> *I call that sequence
01:51:51 * hackagebot upload: AES 0.0.3 - Fast AES encryption/decryption for bytestrings (SveinOveAas)
01:51:54 <Baughn> fasta: It, um, worked here?
01:52:02 * Baughn has no idea why
01:52:24 <fasta> Baughn, on which Windows?
01:53:07 <Baughn> fasta: The error happens on unix as well, just not mine, apparently
01:53:12 <Saizan_> osaunders: anyhow, even monads compose only the "side effects" in that particular order (and even here what that means depends on the monad), not evaluation
01:53:12 <Baughn> fasta: Anyway, could you try now?
01:53:31 <manju> fasta: are you working on BLAST ?
01:53:39 <fasta> manju, no.
01:53:47 <manju> ok
01:54:10 <manju> http://en.wikipedia.org/wiki/FASTA_format
01:54:38 <fasta> Baughn, now it works and I probably have a virus on my machine now...
01:54:56 <osaunders> Saizan_: OK. I haven't really used monads yet.
01:55:08 <Baughn> fasta: It's cryptography. Which means, it's security! And the opposite of a virus!
01:55:43 <osaunders> Baughn: Opposites and neighbors simultaneously.
01:55:49 <Baughn> fasta: ..I'm not quite sure how fast that implementation is, really, but it should be pretty good. I managed to do it without a single copy on the haskell side of things. :3
01:55:50 <fasta> Baughn, well, how can I know that if I didn't inspect it?
01:56:16 <Baughn> fasta: You could trust me. You're running enough of my code already. :P
01:56:16 <fasta> Baughn, and besides cryptography can be used to create a super-virus.
01:56:35 <fasta> Baughn, like what?
01:56:37 <fasta> Baughn, GHC?
01:56:44 * Baughn sweatdrops
01:56:49 <Baughn> I was thinking of haskell-mode, actually
01:57:11 <fasta> Baughn, ah, you are the new maintainer.
01:57:31 <fasta> Baughn, you supposedly have fixed the "cannot enter newline"-mega annoyance.
01:57:36 <birdy_> if I have a list [1,2,4,5,3,3,] how can I return the number of like all the threes? so that I get [4,5] ?
01:57:47 <birdy_> I mean the index of thoose 3's
01:57:58 <Baughn> fasta: Now with both a proper parser fix as well as the emergency fallback hard-newline
01:58:17 <shachaf> @hoogle [a] -> a -> [Int]
01:58:18 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
01:58:18 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
01:58:18 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
01:58:26 <fasta> Baughn, you could also add an auto-updater.
01:58:27 <Cale> > elemIndices 3 [1,2,4,5,3,3]
01:58:28 <shachaf> > elemIndices 3 [1,2,4,5,3,3]
01:58:29 <lambdabot>   [4,5]
01:58:30 <lambdabot>   [4,5]
01:59:00 <birdy_> cool gonna try it thanks
01:59:03 <fasta> Baughn, not a very Emacsy thing to do, though.
01:59:28 <Baughn> fasta: Well, it's bundled with most distributions. I see no reason to do it myself.
01:59:38 <fasta> Baughn, distros lag.
01:59:54 <fasta> Baughn, on Linux I just use the darcs version. Much easier.
02:00:57 <ivanm> darcs version of what?
02:01:00 <ivanm> haskell-mode?
02:01:04 <Baughn> fasta: That, and the darcs version now has a bunch of stuff not in the latest version. I should fix that.
02:01:05 <fasta> ivanm, yes
02:01:42 * ivanm doesn't, because he has enough trouble prompting the emacs devs to bump haskell-mode without trying to get them to provide a darcs ebuild
02:02:38 <Baughn> Well, there's really no need for a darcs ebuild now
02:02:56 <ivanm> because you haven't done anything lately? :p
02:03:16 <Baughn> Because there are no.. hm....
02:03:30 <Baughn> ...1.6.5 coming up.
02:04:53 <fasta> Baughn, oh, I see  you fixed quite some stuff. Nice.
02:05:21 <Baughn> There's one outstanding ticket on the bug-tracker. I'll fix that, then release.
02:07:13 <fasta> Has anyone ever initialized the GHC RTS, deinitialized and then repeated that operation two times in a row?
02:07:49 <ivanm> Baughn: the comment one?
02:08:04 <Baughn> It's the only applicable one
02:08:09 <ivanm> Baughn: how many indentation/parsing fixes have you fixed?
02:08:22 <Baughn> ivanm: No comment.
02:08:27 <ivanm> heh
02:08:31 <Saizan_> fasta: i hear that you can spawn a black hole that way
02:09:10 <fasta> Saizan_, well, there must be a few ones in the room then. I will alert my colleagues.
02:09:38 <Baughn> fasta: No, don't bother; they'll have evaporated by now
02:09:57 <Baughn> Either that, or they've fallen to the center of the earth and is eating it, in which case they'd appreciate not knowing.
02:10:12 <fasta> Baughn, I love Hawking radiation on my skin.
02:10:38 <Raynes> Baughn: Read Digital Fortress by Dan Brown. Awesome book.
02:11:36 <sohum> if a black hole /did/ spontaneously form at the center of the earth, how long would we have until we noticed it?
02:12:04 <ivanm> Baughn: so the first case in a case statement still needs to be manually aligned?
02:12:06 <Baughn> Raynes: I can't quite get around the silliness of the central plot
02:12:18 <kmc> is that the one where evil scientists plot to blow up the vatican
02:12:19 <Baughn> Raynes: ..encryption is a /solved problem/, for most purposes
02:12:39 <fasta> Baughn, just the devices that do the encryption are not.
02:12:40 <Baughn> And it should hardly be a shocker for the NSA to run into a code they can't break. You know, like RSA? Or AES?
02:12:45 <Trollinator> does anybody know why hoogle doesn't work?
02:12:57 <Baughn> Trollinator: Nope, but cabal install hoogle will.
02:13:21 <fasta> Baughn, RSA can probably be broken by the NSA.
02:13:23 <Raynes> Baughn: But for them to run into a code that TRANSLTR can't break is absolutely insane.
02:13:49 <Trollinator> cabal, isn't that the sect from "Blood"?
02:13:51 <Baughn> fasta: Only if there is a fast way to factor primes, which is highly doubtful. They can't brute-force it.
02:14:04 <ivanm> Trollinator: because the web-site is down? :p
02:14:10 <ivanm> @wn cabal
02:14:12 <lambdabot> *** "cabal" wn "WordNet (r) 2.0"
02:14:12 <Baughn> Raynes: No. No, it isn't.
02:14:12 <lambdabot> cabal
02:14:12 <lambdabot>      n 1: a clique (often secret) that seeks power usually through
02:14:12 <lambdabot>           intrigue [syn: {faction}, {junto}, {camarilla}]
02:14:12 <lambdabot>      2: a plot to carry out some harmful or illegal act (especially
02:14:13 <fasta> Baughn, they can just try all the programs on specific problems and even find incomputable ways to factor.
02:14:14 <lambdabot> [5 @more lines]
02:14:30 <Raynes> My favorite parts of the book were the reactions of the people who found out that TRANSLTR couldn't break the code.
02:14:34 <Baughn> fasta: I have no idea what that even means
02:14:48 <Raynes> Baughn: I was being sarcastic.
02:14:50 <fasta> Baughn, if you have a program which does that on a gigantic cluster which has been doing that since WW2, then you basically have world domination.
02:14:58 <Baughn> fasta: And in the interest of maintaining your credibility, you shall not attempt to explain it.
02:15:00 <Trollinator> Baughn: thank you, i'll try that.
02:15:17 <ivanm> Raynes: I didn't think that much of it
02:15:24 <fasta> Baughn, ? Do you want me to explain or not?
02:15:28 <ivanm> then again, I don't think much of _any_ of Dan Browne's books
02:15:48 <Raynes> ivanm: I'm reading The Da Vinci code right now.
02:15:50 <Baughn> fasta: If there isn't a fast way to factor primes, then there isn't.
02:16:16 <fasta> Baughn, sure, but there has already been sub-exponential ways found.
02:16:17 <Raynes> Code*
02:16:18 <Baughn> fasta: And unless they've got hardware capable of running Shor's algorithm, I very much doubt the NSA can break RSA
02:16:47 <ivanm> shor's algorithm is the quantum one?
02:16:48 <osaunders> Primes and the Da Vinci code, I feel like I'm living in a clich√©.
02:16:49 <fasta> Baughn, why wouldn't there by algorithms for specific problems which are way faster?
02:16:55 <Trollinator> ivanm: yes
02:16:56 <fasta> be*
02:17:02 <Trollinator> i had to look it up too ;)
02:17:03 <Baughn> fasta: What specific problem, exactly?
02:17:16 <fasta> Baughn, a specific factoring problem in a sequence of factoring problems.
02:17:22 <fasta> Baughn, for example by using OOPS.
02:17:25 <ivanm> fasta: well, if NSA has developed an efficient factorisation algorithm, they've certainly kept it quite...
02:17:38 <Trollinator> quiet, not quite
02:17:47 <fasta> ivanm, well, it is kind of a _huge_ competetive advantage.
02:17:58 <ivanm> true
02:18:04 <ivanm> Trollinator: my most humble apologies
02:18:16 <Trollinator> I forgive you.
02:18:23 <Baughn> fasta: Such an advantage would not outweigh the disadvantage of having their own industries' communications breached by other countries
02:18:35 <Baughn> Never mind that the NSA still /uses/ RSA for their own communications..
02:18:46 <fasta> Baughn, they do?
02:18:51 <sohum> Baughn: that doesn't necessarily mean they haven't cracked it, though
02:19:04 <fasta> Baughn, that would be very interesting.
02:19:05 * Raynes points to #Haskell-blah as a possibly more suited area for this conversation.
02:19:08 <ivanm> Baughn: do we really _know_ that for certain?
02:19:14 <Baughn> fasta: They officially recommend elliptic-curve, but they use a lot of off-the-shelf software that uses RSA
02:19:19 <Baughn> fasta: Like OpenSSH
02:19:28 <ivanm> don't forget that the brits sold their colonies enigma machines after WWII for "secure" communications...
02:19:34 <Trollinator> sohum: huh? If they'd know of a weakness, why would they use it?
02:19:44 <Trollinator> i mean RSA, not the weakness.
02:19:48 <ivanm> Raynes: as soon as someone actually says something on topic... ;-)
02:19:58 <sohum> Baughn, Trollinator: basic information theory. if you're trying to keep the fact that you've cracked RSA secret, then it's not in your best interest to suddenly swap your internal encryptions away from RSA
02:20:04 <Raynes> I don't mind. Just sayin'.
02:20:23 <fasta> Baughn, it is basically the question what they use for the most vital data they have.
02:20:44 <kmc> setec astronomy
02:20:45 <fasta> Baughn, for low-grade security they might use RSA; I mean you are not a top NSA guy.
02:20:47 <osaunders> Question in comment in pastie: http://codepad.org/BPOJp5y4
02:20:57 <Baughn> sohum: They officially recommend elliptic-curve. I doubt anyone would wonder if they actually /used/ it, instead of RSA.
02:21:18 <fasta> Baughn, if you actually knew something, they would put you behind bars ;)
02:21:22 <kmc> osaunders, just drop your _ <-
02:21:26 <kmc> just end with "endWin"
02:21:31 <kmc> same for sleep
02:21:32 <Baughn> fasta: Unlikely. I'm not american.
02:21:39 <kmc> you don't have to bind a name if you don't want to
02:21:40 <osaunders> kmc: I thought that wouldn't execute it though.
02:21:44 <kmc> it will
02:21:52 <kmc> do { a; b }   desugars to  a >> b
02:21:56 <kmc> @src (>>)
02:21:57 <lambdabot> m >> k      = m >>= \_ -> k
02:21:57 <fasta> Baughn, welll, then you don't know anything about internal procedures.
02:22:05 <kmc> osaunders, so in a sense it's equivalent to your _ <-
02:22:07 <osaunders> kmc: Ah, thanks kmc.
02:22:22 <kmc> also, if you do need a do-nothing action, in any monad, it'd be "return ()"
02:22:29 <fasta> Baughn, although, I can imagine that the NSA also uses off-the-shelf stuff.
02:22:36 <kmc> which despite the name does not "return" from the current function in any sense
02:22:39 <sohum> Baughn: true, there is a bit of an embarrasment of riches thing going on
02:22:48 <kmc> > do { return (); x <- [1,2,3]; return (); return x }
02:22:49 <lambdabot>   [1,2,3]
02:22:54 <osaunders> kmc: Yes, I've read about return.
02:23:06 <Baughn> fasta: There have been plenty of leaks; I'd be surprised if /all/ of them were deliberate and orchestrated
02:23:40 <Baughn> fasta: And they all say pretty much the same thing - RSA and AES remain unbroken, although elliptic curves have a slight robustness advantage
02:23:48 <Baughn> ..elliptic curves are just a generalization of RSA anyway
02:25:26 <Raynes> This is all assuming they even rebuilt the Cryptology department after the events of Digital Fortress.
02:25:30 * Raynes snickers at his cleverness.
02:25:57 <Baughn> Raynes: ..please don't tell me it had cryptology geeks being shot up
02:26:19 <Raynes> Baughn: No, TRANSLTR had a meltdown at the end, blew that shit up.
02:26:53 <Baughn> Raynes: I keep telling people to keep backups, but do they listen?
02:27:27 * Baughn wonders what insane impulse made firefox decide that GIMP made a decent viewer for PDF files
02:27:49 <Raynes> Baughn: They lost their Databank firewalls at the end, hackers got through momentarily, but not long enough to rape their files.
02:28:10 <Baughn> Raynes: OFFLINE backups.
02:28:16 <fasta> Raynes, this is fiction?
02:28:21 <Baughn> On WORM media.
02:28:23 <Raynes> fasta: Yessir.
02:28:47 <birdy_> why can't I do this? [x ++ y | x <- [1..10] | y <- [20..40]] it says Illegal parallel list comprehension: use -XParallelListComp
02:28:50 <Baughn> Raynes: Look, if you want an actual /good/ story, look up The Daemon and Freedom(tm).
02:28:59 <Baughn> birdy_: What do you expect it to do?
02:29:41 <Raynes> Incidentally, the genius computer programmer that designed the Gauntlet virus detector shit for TRANSLTR was depicted as a huge fat guy named Jabba.
02:29:58 <fasta> birdy_, it is simply not the syntax for list comprehensions.
02:29:59 <Baughn> birdy_: You've accidentally(?) stumbled across parallel list comprehension syntax, but even if you turned that off - or replaced it with a standard one - that use of ++ wouldn't work. ++ is for lists, and x and y are integers.
02:30:01 <birdy_> oh stupid me I wanted a + :)
02:30:11 <birdy_> and it worked
02:30:28 <yitz> > [x ++ y | x <- [1..3], y <- [100,110,120]]
02:30:29 <lambdabot>   Ambiguous type variable `t' in the constraints:
02:30:30 <lambdabot>    `GHC.Num.Num t' arising ...
02:30:42 <yitz> > [x ++ y | x <- [1..3], y <- [100,110,120]] :: [Int]
02:30:43 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
02:30:43 <lambdabot>    arising from a use of...
02:30:51 <yitz> > [x + y | x <- [1..3], y <- [100,110,120]] :: [Int]
02:30:53 <lambdabot>   [101,111,121,102,112,122,103,113,123]
02:30:58 <yitz> he
02:34:00 <kmc> > liftM2 (+) [1..3] [100,110,120]
02:34:01 <lambdabot>   [101,111,121,102,112,122,103,113,123]
02:39:17 <osaunders> Code run with runhaskell won't find modules.
02:40:12 <cjs> You mean compiled modules, or ones you want to interpret?
02:40:48 <osaunders> Well UI.HSCurses.Curses
02:41:04 <osaunders> It says: snake.hs: snake.hs: unable to load package `hscurses-1.3.0.2'
02:41:37 <cjs> It does if things are configured correctly. Do you have the package installed? What does ghc-pkg list say?
02:41:38 <osaunders> $ cat $(which runhaskell) is interesting.
02:41:42 <osaunders> exec /opt/local/lib/ghc-6.10.4/runghc -f /opt/local/bin/ghc ${1+"$@"}
02:42:29 <Saizan_> osaunders: is that the whole error?
02:42:46 <osaunders> $ runhaskell snake.hs
02:42:46 <osaunders> snake.hs:
02:42:46 <osaunders> unknown symbol `_iconv'
02:42:46 <osaunders> snake.hs: snake.hs: unable to load package `hscurses-1.3.0.2'
02:43:20 <osaunders> $ ghc-pkg list hscurses # => hscurses-1.3.0.2 along with some paths, I think that means it's there.
02:43:23 <cjs> Oh, wait, that's probably problems linking to your C iconv library.
02:43:24 <Saizan_> ok, so the problem is with linking in the ncurses library, probably
02:43:35 <osaunders> No problems with ghc --make
02:43:43 <cjs> Maybe you're using the wrong haskell. Does ghci work?
02:43:51 <osaunders> cjs: Yeah.
02:43:54 <cjs> s/wrong haskell/wrong build/
02:44:00 <Saizan_> ghc --make uses ld for linking, runhaskell uses the ghci linker, which is far less robust
02:44:13 <osaunders> Saizan_: Ahh.
02:47:55 <birdy_> if I use elemIndices and I don't find what I am looking for iam returned with a [] and I am doing elemIndices with map over a [[a]] so if it doesn't find it in a [a] it returns a [] . Is there any function that removes all the empty lists? now I get like [[],[4,8],[],[6],[],[],[6],[],[]] where I really only want [[4,8], [6]]
02:48:13 <Cale> filter (not . null)
02:48:29 <Cale> > filter (not . null) [[],[4,8],[],[6],[],[],[6],[],[]]
02:48:30 <lambdabot>   [[4,8],[6],[6]]
02:48:59 <birdy_> cool thanks =)
02:49:24 <Cale> and if you want to remove the duplicates, you can either use nub, or map head . group . sort
02:49:48 <birdy_> yeah I have stumbled across nub it's cool
02:50:34 <Cale> The latter is asymptotically faster when considering the whole list, though it can take longer to produce the first element, and obviously sorts the entries.
02:55:22 <CalJohn> @src nub
02:55:23 <lambdabot> nub = nubBy (==)
02:55:29 <CalJohn> @src nubBy
02:55:30 <lambdabot> nubBy eq []             =  []
02:55:30 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
02:56:24 <osaunders> @src True
02:56:25 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
02:56:35 <Beelsebob> @src Bool
02:56:35 <lambdabot> data Bool = False | True deriving (Eq, Ord)
02:57:41 <CalJohn> I really wish that Haskell library functions had docstrings sometimes, like CL or Python
02:58:22 <Beelsebob> @. src type True
02:58:55 <Saizan_> CalJohn: there's the haddock documentation
02:59:21 <HugoDaniel> hi
02:59:24 <CalJohn> that's true, there's just no way to retrieve that from ghci
02:59:43 <CalJohn> (describe-function #'sort-lines)
02:59:52 <Saizan_> hoogle --info
02:59:56 <osaunders> Is there even any reflection at all?
03:01:28 <Saizan_> what do you mean by reflection, specifically?
03:01:51 <CalJohn> hey, thanks Saizan_
03:02:06 <Cale> Typeclasses give you something which is a little bit like reflection.
03:02:27 <osaunders> http://en.wikipedia.org/wiki/Reflection_(computing)
03:02:29 <Cale> (Depending on what you mean by that)
03:02:53 <Saizan_> CalJohn: it's still a bit painful to keep an hoogle index of all the installed libs though
03:02:54 <Cale> "Reflection" is too general a term to really say much though :)
03:03:17 <napping> :info True in ghci works fine
03:03:21 <Saizan_> osaunders: i know the general idea, but it's quite broad
03:04:08 <osaunders> Saizan_: I wouldn't have said so but I suspect this is might be another case of you knowing something I don't.
03:04:09 <Cale> CalJohn: Personally, I just keep a web browser open with the haddock for whatever libraries I'm using :)
03:04:50 <napping> osaunders: Data.Typeable gives you a bit, Data.Data gives you just about everything
03:05:30 <napping> well, at least as far as inspecting non-functional data
03:05:52 <osaunders> napping: Nice one.
03:06:01 <Saizan_> if by reflection you mean only inspecting some information about datatypes/types then what napping said, if you also mean something like modifying the implementation of some method etc.. then no, there's nothing built-in to change
03:06:48 <osaunders> Check this out: (Data a, Data b, Data c, Data d, Data e, Data f, Data g) => Data ((,,,,,,) a b c d e f g)
03:07:02 <osaunders> On this page file:///opt/local/share/ghc-6.10.4/doc/ghc/libraries/base/Data-Data.html#t%3AData 2/3rds down
03:07:42 <napping> there's not a lot more you can get at at runtime, like classes and so on
03:08:02 <osaunders> Saizan_: I wouldn't consider making changes part of reflection.
03:08:04 <kmc> osaunders, yup
03:08:21 <Saizan_> osaunders: the article you linked includes it though :)
03:08:23 <osaunders> Although you might use information gained from reflection to define new things.
03:08:26 <kmc> fortunately for theory but unfortunately for practice, each tuple-size is an unrelated type
03:08:42 <kmc> so you can't write an instance for all tuples at once
03:09:14 <Cale> Has anyone else seen the bizarre messages by John D. Earle to the Haskell Prime list? :)
03:09:24 <osaunders> Saizan_: Whereabouts?
03:09:43 <Saizan_> osaunders: first sentence
03:10:03 <napping> if you want to look over classes, module and package of definition and so on are not really included, but you can get time at compile time in TH
03:10:11 <osaunders> Saizan_: Nah, I don't agree with that then.
03:10:12 <ski> ("what is it with haskell and the mad monologues?","there's someone doing them on the haskell' mailing list now")
03:10:21 <ski> (from #haskell-blah)
03:10:29 <napping> well, you might be able to parse some of that from Data.Typeable type names
03:10:55 <osaunders> Saizan_: Someone else disagrees http://en.wikipedia.org/wiki/Talk:Reflection_(computer_science)#Self-modifying_code
03:10:56 <Cale> osaunders: The thing about reflection is that everyone has a different idea of what counts.
03:11:09 <Saizan_> Cale: yeah, use of layout as an example of bravery, wtf? :)
03:11:11 <Cale> It's not really a well-defined term.
03:11:17 <osaunders> Cale: It would seems so. I wasn't aware of such a problem until now.
03:13:58 <ski> "Types and Reflection" by Lauri Emil Alanko <http://lambda-the-ultimate.org/node/219>
03:15:15 <osaunders> Does Haskell attract language designers?
03:19:47 <Twey> Cale: Heh, he's written a long series of monologues, all neatly numbered‚Ä¶
03:19:49 <osaunders> ski: That guy thinks refection is used to alter at runtime. I don't share that view and, frankly, I'm surprised that others do.
03:20:03 <osaunders> We've a word for that... meta-programming.
03:20:28 * ski would have thought meta-programming is making programs that create and analyze programs
03:20:31 <napping> I'd certainly consider runtime modification a reflective facility
03:21:09 <ski> (which is different from analyzing and modifying the environment a (sub-)program finds itself it)
03:22:55 <osaunders> I'm endlessly disappointed about how imprecise words turn out to be.
03:23:30 <Twey> And what's this about if-then-else being more powerful than case-of?  if-then-else is a subset of case-of.
03:23:56 <Twey> osaunders: .e'u ko cilre tu'a la .lojban. ‚Äî I suggest you learn Lojban :√æ
03:24:26 <napping> Is your semantics so precise, or just grammar?
03:24:35 <Saizan_> how do you say reflection in lojban, and what does it mean?:)
03:25:18 <napping> I'd say reflection is like an API providing access to the structure of the running program
03:25:42 <Twey> Saizan_: Good question.  I don't think we have a term for it yet.  Merits some discussion, probably.
03:26:08 <Twey> napping: Well, semantics can never be 100% precise, but they're moreso than in English
03:26:17 <napping> so runtime modification by direct replacement of stuff in e.g. javascript wouldn't be reflection, or module reloading stuff like in Erlang
03:26:30 <Baughn> > 4 + {- foo {- bar -} -} 2
03:26:31 <lambdabot>   6
03:26:36 <Baughn> > 4 + {- foo {- bar..-}..-} 2
03:26:37 <lambdabot>   6
03:26:51 <Twey> Experimenting with comments?  :√æ
03:27:12 <Cale> > let x --> y = x + y in 4 --> 2
03:27:14 <lambdabot>   6
03:27:24 <napping> but reflection is probably not what you usually want in Haskell
03:28:35 <osaunders> Twey: I've never heard of Lajban before. It sounds interesting but the usefulness of human languages has a lot to do with how many people speak them.
03:29:10 <napping> rather, being able to assemble useful functions at runtime from descriptions, or passing things around with descriptions like the typeclasses do
03:29:30 <Twey> osaunders: Well, there's only one way to solve that problem.  ‚ò∫
03:29:35 <HugoDaniel> hi
03:29:36 <HugoDaniel> :D
03:29:45 <osaunders> hi
03:29:55 <napping> of course, that doesn't go nearly as far in Haskell as with dependent types
03:29:56 <Twey> Hullo
03:29:56 <osaunders> Twey: Yeah.
03:30:39 <osaunders> napping: Your definition of reflection sounds as if you're doing something homoiconic.
03:31:03 <napping> no, not at all
03:31:19 <osaunders> napping: It's that word "structure".
03:31:32 <Cale> When the Moon punches you in the face like a piece of focaccia bread, that is a type of eel.
03:31:47 <napping> rather, things like "what methods does this class have"
03:32:22 <napping> for some reason I guess I only think of it as reflection if you have to use some special API
03:32:46 <osaunders> Yeah, me too.
03:33:07 <osaunders> If you're just looking at a normal data structure it doesn't seem to deserve any special distinction.
03:33:09 <Twey> Cale: Hahaha
03:33:14 <HugoDaniel> i have this problem: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5197#a5197
03:33:21 <HugoDaniel> how do i convert UTF8 to String ?
03:33:22 <HugoDaniel> in haskell ?
03:33:37 <HugoDaniel> i have a bytestring UTF-8 encoded
03:33:40 <napping> have you checked hackage?
03:33:40 <HugoDaniel> and it does not print well
03:33:52 <Twey> HugoDaniel: Try the utf8-string package, or GHC .12, which has built-in conversion facilities.
03:35:34 <HugoDaniel> i think im already using that
03:39:31 <napping> osaunders: do you know about the free theorems?
03:39:46 <osaunders> No. What are they?
03:40:41 <napping> look up "Theorems for Free"
03:41:29 <napping> basically, if you don't make stuff like equality and reflection available everywhere you know lots of things about polymorphic functions
03:41:36 <HugoDaniel> cabal: Error: some packages failed to install:
03:41:38 <HugoDaniel> utf8-string-0.3.6 failed while downloading the package.
03:41:46 <HugoDaniel> why is this ? :)
03:42:00 <napping> swap :: (a,b) -> (b,a) must really be swap
03:42:28 <dcoutts> HugoDaniel: try cabal fetch utf8-string -v3
03:42:35 <dcoutts> that should shed some light on it
03:43:14 <HugoDaniel> "Creating new connection to hackage.haskell.org" it halts on this
03:43:38 <Twey> HugoDaniel: Your connection is broken ;)
03:43:44 <osaunders> napping: Referring to this: http://lambda-the-ultimate.org/node/1924 ?
03:43:44 <HugoDaniel> :) not its not
03:43:58 <HugoDaniel> does cabal honor the $HTTP_PROXY environment values ?
03:44:12 <dcoutts> HugoDaniel: yep
03:44:35 <napping> that's talking about similar things
03:45:16 <napping> there's Wadler's paper by the title "Theorems for Free"
03:45:29 <osaunders> http://homepages.inf.ed.ac.uk/wadler/topics/parametricity.html ?
03:45:36 <napping> yeah
03:45:52 <napping> and it all breaks down if you can do anything on values of unknown types
03:46:12 <napping> or at least gets a lot hairier
03:46:16 <osaunders> Why do functional programmers like papers so much. What's with that?
03:46:31 <dcoutts> osaunders: FP comes from academia
03:46:45 <napping> e.g. in Java you could write method like <A,B> Pair<B,A> swap(Pair<A,B> x)
03:47:13 <dcoutts> osaunders: whereas the historically popular mainstream languages were designed by engineers (and it shows ;-) )
03:47:19 <napping> which didn't actually swap when A=B
03:48:02 <napping> papers are designed to be a relatively self-contained presentation of an idea
03:48:15 <Raynes> Hoogle is down.
03:48:23 <Raynes> Life as we know it has come to a bitter end.
03:48:26 <osaunders> dcoutts: And more recently, just plain programmers (Ruby, Python, UScript)
03:48:53 <osaunders> Raynes: I think we're approaching 3 day of down-ness.
03:48:59 <osaunders> *third day
03:49:06 <Raynes> I'm scared.
03:49:21 <dcoutts> it's not clear why hoogle needs to write files when serving requests
03:50:35 <napping> dcoutts: I'd say it's not clear why it fails to serve requests when writing files fails
03:51:00 * Raynes prepares to down an entire bottle of pain medication if Hoogle isn't fixed within 24 hours.
03:51:02 <Raynes> @_@
03:51:16 <napping> if that's really what's going on, but I'm not surprised if it tries to write logs and stuff
03:51:24 <osaunders> dcoutts: I'm not a fan of academia for academica's sake. It seems steeped in dated tradition and is stuffy at times. Despite this I am an enormous fan of good reason and intelligent decision making. I like Haskell a lot but I'm not sure I like reading papers about it.
03:52:11 <osaunders> The other thing is I find them very difficult to read, which is just a personal incapability that may be contributing to my view.
03:52:12 <dcoutts> osaunders: sure, that's just the traditional mutual mistrust and ignorance between academia and practise.
03:52:19 <Axman6> osaunders: well, that's where all the interexsting stuff is
03:52:22 <Axman6> -x
03:52:28 <napping> I think papers are generally better at building up an idea, justifying it and giving examples and so on than most documentation
03:52:36 <osaunders> dcoutts: Yeah, something really needs to be done about that.
03:52:46 <Axman6> osaunders: also, some papers are far better written than others
03:52:58 <osaunders> Axman6: Yeah.
03:53:17 <osaunders> OK, well I'll save this one for when I'm more awake and I'll give it a shot.
03:53:22 <Axman6> i've seen some horrible ones, and just didn't read them. SPJ's papers are usually very approachable
03:53:34 <dcoutts> osaunders: thing is, the really good ideas, like cunning static type systems, would never have grown up in the mainstream tradition
03:53:52 <dcoutts> that really does require the ivory tower
03:54:04 <napping> The only thing I can think of that's similar in usual programming language documentation would be the bit in the tutorual/language reference
03:54:15 <Cale> osaunders: Don't worry about the fact that they're papers. Think of them like blog postings by really smart people, and you'll be fine ;)
03:54:17 <osaunders> dcoutts: What makes you say that?
03:54:39 <dcoutts> osaunders: because the mainstream people do not have the grounding in logic and mathematics to do it
03:54:48 <osaunders> Cale: A lot of them use notation I just don't know.
03:55:01 <osaunders> This one does, now that I look at it.
03:55:10 <Cale> What notation in particular?
03:55:13 <osaunders> I've no idea what an upside-down A means.
03:55:20 <Cale> Oh, that means 'for all'
03:55:28 <Axman6> osaunders: haskell is so awesome and well thought out because the people who designed it were extremely well educated in the theory side of programming languages
03:55:31 <Cale> :t map
03:55:33 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
03:55:45 <Cale> It's what that 'forall' is meant to look like ;)
03:55:46 * dcoutts notes hoogle is back
03:56:04 <Axman6> osaunders: upside down A is forall, and backwards E is exists
03:56:17 <dcoutts> Raynes: so, fear not :-)
03:56:51 <osaunders> Axman6: These are symbols from lambda calculus?
03:56:56 <Raynes> Yay!
03:56:57 <Cale> They're standard notation in logic, which everyone *ought* to know, but no highschools teach any logic anymore.
03:57:02 <Axman6> predicate calculus i think
03:57:08 <osaunders> Right.
03:57:19 <osaunders> Maybe I should pick up a book on that.
03:57:20 <Axman6> osaunders: but in general, you can ignore them
03:57:26 <osaunders> Oh.
03:57:32 <osaunders> Wow. Really?
03:58:02 <Cale> osaunders: Well, in particularly restricted context of Haskell types, you can ignore any forall which shows up at the outermost level
03:58:02 <Axman6> osaunders: if you're interested, i've just done a course covering a lot of this stuff, and the slides are available online
03:58:02 <osaunders> I saw "Logic for Dummies" in my local library once and it made me laugh.
03:58:34 <Cale> osaunders: Because every type variable is implicitly forall'd if you leave out the quantifier.
03:58:58 <napping> by the way, everything from the fourth section onwards is explaining how to prove these theorems actually hold'\
03:58:59 <Cale> In general, it would be unwise to ignore quantifiers
03:59:05 <osaunders> So, err, what does forall mean, besides the words for and all?
03:59:09 <napping> and that is a bit tricky
03:59:23 <dcoutts> osaunders: here's a good example: you know how type signatures in Haskell are optional? how types are inferred, so you don't have to annotate types everywhere like you do in Java?
03:59:35 <Axman6> osaunders: it mean, no matter what the forall thing is, the function will work
03:59:42 <Axman6> so..
03:59:44 <Axman6> :t map
03:59:45 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
03:59:48 <Cale> osaunders: Well, in the case of the type of map, it means that for all types a and b, map will take a function of type (a -> b) and a value of type [a], and produce a value of type [b]
03:59:55 <osaunders> dcoutts: Yep, I'm familiar with that.
03:59:55 <dcoutts> osaunders: so that's a really practical benefit, but there's some hard-core theory and proofs behind that.
04:00:25 <napping> I'd say actually proving your type system works all the time is a pretty academic thing to do, compared to just throwing together some rules that mostly seem to work and maybe doing some runtime checks
04:00:59 <dcoutts> right, and those proofs are not really optional
04:01:08 <dcoutts> you would not trust it at all otherwise
04:01:31 <ben> Is there a version of doesFileExist that just checks whether the file named to it exists?
04:01:40 <Axman6> osaunders: check out these, they cover a lot of things used in haskell, but i found the course quite difficult, so feel free to ask for help here. http://cs.anu.edu.au/students/comp2600/lectures.php
04:01:46 <dcoutts> ben: isn't that what doesFileExist does?
04:01:48 <Cale> osaunders: In logic, if P(x) is any statement about x (a predicate which might be true or false about any particular x, like for example, "x is unmarried"), then the assertion forall x. P(x) says that this is true for every value x
04:02:00 <ben> No, it follows symlinks too and lies to me in case of a symlink pointing to a non-existent file :(
04:02:04 <Cale> Something like "everyone is unmarried"
04:02:14 <p4p800> what is the function const usefull for?
04:02:22 <Cale> p4p800: making constant functions
04:02:26 <dcoutts> ben: ah, then you want getSymbolicLinkStatus
04:02:43 <osaunders> Axman6: OK, thanks
04:03:10 <ben> dcoutts: Does that not throw an exception?
04:03:12 <osaunders> Cale: OK. I understand that. I'm not sure I'll remember it though.
04:03:20 <Axman6> osaunders: i personally found that course easier as it went along, but that's because it gets more haskell like as you go on
04:03:31 <dcoutts> ben: I don't think so
04:03:33 <blackh> p4p800: It's useful for things like   if reset then const 0 else (1+)
04:03:51 <Cale> osaunders: By contrast, exists x. P(x) is the assertion that P is true for some x.  "someone is unmarried"
04:04:01 <ben> I mean, on non-existent files.
04:04:04 <osaunders> Hanging out on this channel has really made me realize how little I know :-S
04:04:16 <koeien37> haha, me too :/
04:04:30 <blackh> osaunders: I think the feeling of not knowing anything is more or less permanent with Haskell
04:04:33 <Axman6> osaunders: that's what we're here for :P (i still feel the same after 2 years being here)
04:04:36 <napping> Cardelli's typeful programming is the most extreme example I remember of a paper with a really good prefix and not so good stuff afterwords (not that "Theroems for free" gets bad, just technical)
04:04:49 <dcoutts> ben: oh, yes, you're right.
04:05:00 <Axman6> blackh: hey, do you know if this talk you'll be doing will be taped?
04:05:09 <Cale> osaunders: In classical logic, exists x. not P(x) is equivalent to not (forall x. P(x)), and forall x. not P(x) is equivalent to not (exists x. P(x))
04:05:16 <zygoloid> i admire sigfpe's new approach to monad tutorials: "how to get along without monads... haha tricked you it's monads really"
04:05:25 <blackh> Axman6: I had to agree for it to be videoed, so it seems like it will be.
04:05:35 <Axman6> hoorah
04:05:41 <napping> the introduction is basically a manifesto setting out much of what's good about modern type systems, then a really dated language design
04:06:07 <blackh> Axman6: I'm really going to enjoy myself!
04:06:13 <Axman6> :D
04:06:18 <Axman6> i hope so :)
04:06:30 <koeien37> zygoloid: hehe, i noticed that too
04:06:46 <p4p800> can sb explain informally what ">>=" actually does?
04:07:15 <Cale> osaunders: Note that it also makes a big difference in general what order different quantifiers come in...  forall x. exists y. x + y = 0  is the assertion that every number has a negative which cancels it out when added to it.  exists y. forall x. x + y = 0  is the assertion that there's a number which when added to anything at all gives 0, which is typically false.
04:07:20 <koeien37> takes an action, and a function taking the result of an action returning a new action, to combine it in one action
04:07:25 <Axman6> p4p800: chains two monadic actions, with the second one relying on the result of the first
04:07:47 <osaunders> Cale: I'm saving everything you're saying for later because I'm about to go to bed.
04:07:51 <p4p800> okay: An action is a function?
04:07:58 <blackh> p4p800: It pulls a value out of a monad, for example, it might be used to pull a line out of 'getLine' and feeds it into another function belonging to the same monad, e.g. putStrLn
04:08:06 <koeien37> p4p800: no, a monadic value.
04:08:09 <Cale> osaunders: okay. Let me know if you have any questions about this stuff later :)
04:08:20 <dcoutts> ben: so you'd need to catch the "does not exist" IO error
04:08:22 <osaunders> Thanks, I will.
04:08:38 <ben> Right, I need the file status as well anyway :]
04:09:06 <dcoutts> ben: what use case requires that you distinguish broken symbolic links?
04:09:14 <osaunders> OK, I'm going now.
04:09:17 <osaunders> Goodnight all.
04:09:36 <benmachine> does describing monadic values as actions really make sense for e.g. Maybe or []
04:09:36 <dcoutts> ben: of course it's possible to open and write through a broken symlink to create the target file
04:09:58 * zygoloid is very tempted to explain >>= in terms of choose-your-own-adventure books. but it's time for a burrito!
04:10:06 <dcoutts> benmachine: no, only for types that do describe actions, not all monadic types represent actions.
04:10:07 <Botje> benmachine: i think it does
04:10:12 <ben> dcoutts: I have a series of names that I want to unlink and then replace with symbolic links. Apparently my program has a bug that produces symlinks pointing to non-existant files, and in that case they will not get cleaned up because either because I was going filterM doesFileExist myListOfNames
04:10:21 <Cale> benmachine: yes
04:10:28 <benmachine> yes no maybe
04:10:31 <benmachine> excellent.
04:10:35 <Botje> benmachine: you only find out about the value it returns if you "run" the monad by accessing it outside of the monad interface
04:10:44 <Cale> benmachine: An action in the list monad is a choice between the values of that list.
04:10:48 <benmachine> oh, that makes sense I suppose
04:11:19 <dcoutts> I guess it's just terminology, I think it's misleading to describe them as actions
04:11:33 <benmachine> I think that the term action tends to make people think of the most boring onad
04:11:34 <benmachine> monad
04:11:46 <blackh> Axman6: I'm also giving a general talk about Haskell for the programming languages miniconf - 20 mins long.
04:11:52 <Botje> the action monad?!
04:11:56 <benmachine> (i.e. IO)
04:12:05 <Cale> benmachine: an action in the Maybe monad is either a single value or abject failure -- kind of like you have a machine which either gives the same result every time, or it explodes, destroying the entire factory.
04:12:16 <benmachine> I like those kinds of machines
04:12:18 <Axman6> blackh: sounds good :D what sort of stuff are you going to talk about?
04:12:33 <Axman6> and when are you coming to australia to say hi and give more talks? :P
04:13:26 <Botje> the Maybe monad should come with a blast-proof suit, then
04:13:58 <Cale> It does, the blast proof suit is a case expression which handles the Nothing case safely. :)
04:14:24 <benmachine> I tend to find myself compulsively turning case into maybe
04:14:28 <Cale> (or the maybe function which is equivalent)
04:14:34 <benmachine> possibly this is a bad habit when taken to extreme
04:14:50 <Cale> Sometimes one is clearer than the other.
04:14:50 <ben> If only there was mapMMaybe
04:15:13 <Cale> If you find the expressions you're putting in the parameters to maybe are getting large and complicated, switch to using case
04:15:26 <benmachine> can't I just where them
04:15:34 <byorgey> ben: what would mapMMaybe do?
04:15:42 <Cale> You could do that too, if they have good names.
04:15:48 <blackh> Axman6: purity, low signal-to-noise ratio, the "wow this program works first time" factor, parallelism (briefly), laziness and its costs/benefits, how I/O is modelled, factoring I/O out of your logic, all leading up to the assertion that Haskell gives a quantum leap in your ability to deal with software complexity - or did you want the short answer?
04:16:12 <ben> mapMaybe is (a -> Maybe b) -> [a] -> [b], I would want something that is (a -> m (Maybe b)) -> [a] -> m [b] :)
04:16:29 <ben> basically (catMaybes .) . mapM, I think
04:16:34 <blackh> Axman6: I hate travelling.  I go to Wellington once a month and that's far enough!
04:16:36 <ben> err, fmap instead of composition
04:16:42 <benmachine> :T (.)
04:16:42 <Axman6> blackh: excellent answer. though, don't use the term quantum leap to mean something big ;)
04:16:44 <benmachine> :t (.)
04:16:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:16:51 <byorgey> ben: yes, that ought to work
04:16:57 <ben> benmachine: Not in my prelude :'(
04:17:00 * Axman6 rages at Cale again
04:17:02 <benmachine> heh
04:17:03 <Botje> blackh: but a quantum leap is very small!
04:17:11 <Cale> I hate time travelling. I go back a month once a Wellington, and that's far enough!
04:17:15 <Axman6> Botje: my point exactly :)
04:17:25 <blackh> Axman6, Botje: I speak English, not academicese
04:17:42 <benmachine> quantum leap is still a silly phrase
04:17:53 <Axman6> blackh: well, a quantum leap is basically the smallest possible distance anything can move i believe
04:18:16 <benmachine> it is just leap, only with added quantum
04:18:44 <Cale> A quantum leap is large in comparison to the infinitesimal leaps one would make in continuous motion.
04:19:09 <Axman6> Cale: is it not possible that there is no such thing? :o
04:19:30 <blackh> Axman6, Botje: "quantum leap - n : a sudden large increase or advance (WordNet)" In case you're unfamiliar with it, this language is called "English". :)
04:19:35 <ben> @pl \f a b -> a >>= \a' -> b >>= \b' -> f a' b'
04:19:35 <lambdabot> flip ((.) . (>>=)) . flip ((.) . (>>=))
04:19:39 <ben> @pl \f a b -> a >>= \a' -> b >>= \b' -> return $ f a' b'
04:19:39 <lambdabot> liftM2
04:19:42 <ben> :/
04:19:47 <Botje> english is wrong! :)
04:19:52 <ben> Clearly I need unsafePerformIO $ liftM2
04:19:55 <ben> [...]
04:20:02 <Axman6> no...
04:20:13 <Cale> blackh: They're not arguing with whether the word is used, they're arguing that it's an incorrect coinage to begin with.
04:20:14 <Botje> ben: don't say that word!
04:20:18 <Axman6> you do need something else though...
04:20:27 <Axman6> :t  \f a b -> a >>= \a' -> b >>= \b' -> f a' b'
04:20:27 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => (a -> a1 -> m b) -> m a -> m a1 -> m b
04:20:30 <Botje> you'll attract beings from the seventeenth dimension!
04:20:35 <ben> I suspect join would do, but it woul have the same effect
04:20:45 <Axman6> :t  \f a b -> f <$> a <*> b
04:20:46 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
04:20:50 <gemie> If I got [0..8] `zip` map head(filter (not . null) (map (elemIndices Nothing) m)) where m is a [[a]] and this work as I want only that I use head so I only get the first pair. what insteed of head can I use to get pairs (int, int)?
04:20:59 <Axman6> almost
04:21:06 <Axman6> :t  \f a b -> f <*> a <*> b
04:21:07 <lambdabot> forall (f :: * -> *) a a1 b. (Applicative f) => f (a -> a1 -> b) -> f a -> f a1 -> f b
04:21:08 <blackh> Botje, Axman6: Small is the new big.
04:22:02 <benmachine> map head . filter (not . null) = catMaybes . listToMaybe -- I think
04:22:06 <Botje> gemie: you'll have to push the zip inside, i think
04:22:21 <gemie> hm ok
04:22:22 <Botje> blackh: agreed :)
04:22:36 <Axman6> blackh: but big is still big too
04:23:00 <ben> Oh, look, hoogle is back.
04:23:16 <blackh> Axman6: Now I'm really confused. Well, I'll catch you guys later!
04:23:18 <Axman6> yup
04:23:23 <Axman6> o/ blackh
04:25:32 <gemie> Botje any idea where I should put it?
04:26:09 <gemie> without map head I get like [(0,[0,8]),(1,[3,5])] where I want [(0,0), (0,8)... etc
04:26:26 <Botje> between the filter and the map, maybe?
04:26:37 <Botje> or you could just expand the tuples ..
04:26:57 <gemie> what do you mean with expand the tuples?
04:27:04 <Botje> concatMap (\(prefix, list) -> zip (repeat prefix) list)
04:27:56 <gemie> hm ok
04:33:49 * hackagebot upload: either-unwrap 1.1 - Functions for probing and unwrapping values inside of Either. (GregoryCrosswhite)
04:55:19 <gemie> If I got something like this [(0,[0,8]),(1,[3,5])] but want something like this [(0,0), (0,8), (1,3), (1,5)] what function can I use? tried alot :/
04:56:17 <benmachine> 12:32:54 < Botje> concatMap (\(prefix, list) -> zip (repeat prefix) list)
04:56:19 <benmachine> that?
04:56:40 <koeien371> map (uncurry (:))
04:56:50 <koeien371> oh no
04:57:26 <Botje> > concatMap (\(prefix, list) -> zip (repeat prefix) list) [(0,[0,8]),(1,[3,5])]
04:57:27 <lambdabot>   [(0,0),(0,8),(1,3),(1,5)]
04:57:33 <Botje> it even works!
04:57:49 <gemie> hm
04:58:08 <gemie> I don't get how to use itr
04:58:22 <napping> or just [(a,b) | (a,bs) <- inputList, b <- bs]
04:58:50 <napping> concatMap (uncurry (map . (,))) if you want to go the other way
04:58:56 <Botje> what do you mean "how to use it: ?
04:59:01 <Botje> i just showed you :)
04:59:09 <Botje> put it in place of the map head you had before.
04:59:48 <gemie> worked =)
05:00:00 <Botje> yay!
05:01:56 * Axman6 prefers napping's first version
05:09:29 <mreh> I'm compiling a two dimensional list, about 300x300, it's taking ages
05:09:49 <mreh> and now GHC had a panic
05:10:14 <mreh> ghc: panic! (the 'impossible' happened)
05:11:38 <ivanm> mreh: why are you using lists? :s
05:11:38 <ivanm> sounds like something you'd want an array for
05:11:52 <Twey> So don't do that :√æ
05:12:01 <napping> mreh: Is the list that big in the source?
05:12:08 <mreh> napping: es
05:12:10 <mreh> yes
05:12:21 <napping> cause weird things happen if you have patterns with too many variables
05:12:42 <napping> or is this a value?
05:13:06 <mreh> i have to turn off syntax highlighting, the thing struggles
05:13:34 <BONUS> the question is, why do you have a 300x300 list in your source file
05:13:47 <mreh> BONUS: Machine learning
05:13:59 <mreh> it's an online algorithm, but i need to keep the data somewhere
05:14:10 <mreh> i suppose parsing the file is too much for me right now
05:14:15 <BONUS> why not load it fro a file
05:14:16 <mreh> i'm inexperienced
05:14:16 <BONUS> a
05:14:34 <BONUS> it's not heard, really.
05:14:54 <napping> sounds like something you should send in, it's really not supposed to break like that
05:15:09 <BONUS> > read "[[1,2,3],[1,2,3,4],[3,2,3]]"  :: [[Int]]
05:15:10 <lambdabot>   [[1,2,3],[1,2,3,4],[3,2,3]]
05:15:30 <mreh> the data is line separated, and it consist of a label and a 16x16 bitmap as a list of real numbers between -1 and 1
05:16:16 <Axman6> http://cryptnet.net/mirrors/texts/kissedagirl.html bwahahaha XD
05:16:46 <mreh> BONUS: oh, that's clever
05:17:27 <mreh> can I use laziness to read a wohle file?
05:17:34 <BONUS> sure
05:17:57 <BONUS> do contents <- readFile "blah.txt" and it will read the file as you request its contents
05:17:57 <napping> hmm, that is strange
05:18:05 <napping> I'm seeing long compile times here
05:19:33 <napping> just with a 300x300 list of integers
05:23:59 <mreh> :t readFile
05:24:00 <lambdabot> FilePath -> IO String
05:24:21 <napping> panic is a bit strange of an error
05:24:49 <mreh> isn't there a FilePath -> IO [String]?
05:25:02 <mreh> @hoogle FilePath -> IO [String]
05:25:03 <lambdabot> System.Console.Editline.Readline filenameCompletionFunction :: String -> IO [String]
05:25:03 <lambdabot> System.Console.Editline.Readline usernameCompletionFunction :: String -> IO [String]
05:25:03 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
05:25:07 <napping> map lines . readFile ?
05:25:19 <napping> fmap lines . readFile, I mean
05:25:22 <mreh> :t lines
05:25:23 <BONUS> if you write it as a nested list in your file, you just call read on it
05:25:23 <lambdabot> String -> [String]
05:25:25 <napping> what list of strings do you want out?
05:25:34 <Kim^Walkman> :t fmap lines readFile
05:25:37 <lambdabot>     Couldn't match expected type `[Char]'
05:25:37 <lambdabot>            against inferred type `IO String'
05:25:37 <lambdabot>       Expected type: FilePath -> String
05:25:38 <napping> a list of directory entries? Lines in a file?
05:25:49 <mreh> i want to read a large list from a file and pass it to a function
05:26:04 <napping> oh, then you want to use "read" on the string you get from the file
05:26:11 <BONUS> just write the list in your file and pass it to read
05:26:12 <napping> like contents <- readFile "dataFile.txt"
05:26:22 <napping> let myData = read contents :: [[Integer]]
05:26:23 <BONUS> and then read contents :: [[Int]] or something
05:26:27 <mreh> BONUS: gotcha
05:26:31 <seanmcl> When making haddock docs, I get the message, no documentation for library rts-1.0.  But rts is not on hackage.  I suspect it is the GHC runtime system, but am not sure.  Is there some way (or need) to install docs for rts?
05:26:52 <ksf> not really.
05:26:52 <mreh> :t readFile
05:26:56 <gemie> is the a function for replace an elment in an list? like if I got ["foo","boo"]!!0 and then I want to replace foo with something new. searched but didn't found any replace function
05:26:57 <lambdabot> FilePath -> IO String
05:27:02 <ksf> it has to be built+installed alongside with ghc
05:27:17 <napping> seanmcl: that means you won't get nice linkification for things from the rts package used in the thing being documented
05:27:20 <ksf> ...but chances are that you won't find it exeedingly interesting, anyway.
05:27:29 <napping> seanmcl: but it's not fatal, and yes rts is a pretty internal thing
05:28:01 <Axman6> > read "12345678899294987239745" :: Int
05:28:01 <lambdabot>   4807113983297208641
05:28:03 <seanmcl> ok, thanks.
05:28:28 <Kim^Walkman> gemie: it's because to replace an item you have to build a new list, identical to the old one except for the item you want to replace (it's inefficient)
05:29:10 <Kim^Walkman> gemie: If you want to replace items from a collection chances are there's more suited data structures available
05:29:17 <ksf> let baz = ("bar":) in baz . tail ["foo","bar"]
05:29:19 <ksf> > let baz = ("bar":) in baz . tail ["foo","bar"]
05:29:21 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
05:29:21 <lambdabot>         against inferred ty...
05:29:32 <ksf> > let baz = ("bar":) in baz . tail $ ["foo","bar"]
05:29:34 <lambdabot>   ["bar","bar"]
05:29:52 <Kim^Walkman> gemie: And to my knowledge; if you want a replace function for lists you have to make it yourself :)
05:29:53 <ksf> :t ("bar":)
05:29:54 <lambdabot> [[Char]] -> [[Char]]
05:29:57 <Axman6> ["black","sheep"]
05:30:26 <gemie> Kim^Walkman oh okey =) then I will do that
05:30:49 <mreh> :t read
05:30:51 <lambdabot> forall a. (Read a) => String -> a
05:32:10 <Kim^Walkman> gemie: You could look at Data.Sequence, for example
05:36:40 <Twey> > foldr (\x t -> if x == "foo" then "bar" : t else x : t) [] ["foo", "baz", "foo", "quux"]
05:36:41 <lambdabot>   ["bar","baz","bar","quux"]
05:37:08 <Twey> @let (y ?? n) p = if p then y else n
05:37:08 <lambdabot>  Defined.
05:38:15 <Twey> > foldr ((const ("bar" :) ?? (:)) . (== "foo")) [] ["foo", "baz", "foo", "quux"]
05:38:17 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
05:38:17 <lambdabot>         against inferred ty...
05:38:45 <gemie> Kim^Walkman hm ok
05:39:11 <Axman6> why do we as haskell programmers seem to have a fetish for writing confusing code?
05:39:52 <BONUS> we're more like poeats
05:39:53 <ivanm> Axman6: well, we have to to make it look serious!
05:39:55 <BONUS> poets*
05:40:08 <ivanm> Axman6: after all, C, Java, etc. code looks confusing _for free_!
05:40:16 <Axman6> BONUS: hmm, that's a good way of looking at it
05:40:21 <ivanm> whereas _we_ have to work hard at it!
05:40:21 <Axman6> ivanm: ha :)
05:40:31 <gemie> thanks guys gonna check it up
05:40:36 <ivanm> you disagree?
05:40:44 <BONUS> haha
05:41:01 <Axman6> ivanm: only a little :)
05:41:16 <Twey> Hmm
05:41:36 <Cale> Axman6: What do you mean confusing?
05:41:43 * ivanm has once again come to the stage of where he thinks his code is ready to release upon the unsuspecting public, but isn't quite sure...
05:41:58 <ivanm> Cale: well, your constant attempts at setting (.) = fmap don't help... :p
05:41:59 <Axman6> ivanm: well, it was Twey's code above that got me thinking about it
05:42:07 <ivanm> the ?? one?
05:42:09 <ivanm> @type (??)
05:42:11 <lambdabot> forall t. t -> t -> Bool -> t
05:42:11 <Axman6> uhm Cale, not ivanm
05:42:12 <Cale> ivanm: Is that confusing?
05:42:22 <ivanm> Cale: the resulting types can be
05:42:29 <Cale> It's not confusing if you think about it a bit.
05:42:33 <ivanm> where is (??) defined?
05:42:34 <Axman6> Cale: to beginners, yes, it is
05:42:43 <Axman6> ivanm: it was @let
05:42:47 <ivanm> ahhh
05:42:56 <Cale> Axman6: Well *everything* is confusing to beginners. They wouldn't be beginners otherwise ;)
05:43:07 <ivanm> Cale: in general, I agree that (++) for example should be generalised; except that IIRC, haskell was also designed as a _teaching_ language
05:43:17 <Axman6> Cale: but you're increasing the barrier to entry
05:43:25 <ivanm> Cale: but is there any value to generalising (.) ?
05:43:29 <tromp__> :t mappend
05:43:30 <Cale> You disagree that generalising (++) makes it a better teaching language?
05:43:31 <lambdabot> forall a. (Monoid a) => a -> a -> a
05:43:32 <ivanm> I mean, do you use (.) _as_ fmap?
05:43:51 <ivanm> Cale: yes; it's harder to pick up in the beginning then when looking at the type
05:43:58 <Cale> ivanm: I would, were it not necessary to awkwardly import the Prelude in a strange way every time.
05:43:59 <Axman6> Cale: when lambdabot tells them something works that doesn't work in ghci, then you're not helping them one bit
05:44:15 <ivanm> Cale: since you get that weird-looking Monoid thingy there, plus having to bring type classes in earlier
05:44:20 <Cale> Axman6: Lambdabot has hundreds of modules loaded...
05:44:25 <ivanm> Cale: :o
05:44:32 <ivanm> even over <$> ?
05:44:34 <Cale> well, maybe not *hundreds*
05:44:45 <Cale> ivanm: yeah, unless I was using <*> at the same time
05:44:46 <Axman6> Cale: yes, it does. but when code works in lambdabot that doesn't work for them, they'll get pissed off and confused
05:44:49 * ivanm finds the mathematical link for (.) good enough without generalising it
05:45:00 * Axman6 does too
05:45:01 <Twey> @pl \x t -> if x == "foo" then "bar" : t else x : t
05:45:01 <lambdabot> ap (ap . (. ("bar" :)) . if' . ("foo" ==)) (:)
05:45:02 <ivanm> Cale: since by using (.) as fmap, it doesn't look as maths-y
05:45:04 <Twey> Ewww
05:45:15 <ivanm> @type (.)
05:45:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:45:21 <Twey> I'm sure there's a nicer way of doing that‚Ä¶
05:45:25 <Cale> I should remove *all* the module imports from lambdabot and see if people complain ;)
05:46:01 <Cale> After all, that'd reduce things to just the stuff which works by default in ghci
05:46:02 <ivanm> Cale: heh, nah, keep Data.{Set,Map,List} in (with the first two qualified and aliased)
05:46:08 <Axman6> Cale: i do like the idea of using (.) as fmap, i think it's really cool, but i do wish you wouldn't confuse beginners, and those trying to teach them, by making the type errors even more cryptic
05:46:22 <ivanm> @pl \ t -> if x == "foo" then "bar : t else x : t
05:46:23 <lambdabot> (line 1, column 27):
05:46:23 <lambdabot> unexpected "\""
05:46:23 <lambdabot> expecting lambda abstraction or expression
05:46:28 <burp> lol
05:46:34 <ivanm> @pl \ t -> if x == "foo" then "bar" : t else x : t
05:46:35 <lambdabot> ap (if' (x == "foo") . ("bar" :)) (x :)
05:46:44 <ivanm> Twey: there, one point removed
05:46:54 <Twey> Hah
05:47:17 <Cale> Axman6: Well, to change the errors, I'd need to modify GHC.
05:47:24 <ivanm> > succ . Just 3
05:47:26 <lambdabot>   Just 4
05:47:35 <Cale> (or do some horrible error message parsing and replacement)
05:47:35 <ivanm> Cale: ^^ to me, that just looks wrong...
05:47:45 <Cale> ivanm: why?
05:47:59 <Cale> ivanm: You don't think it's an appropriate notation?
05:47:59 <ivanm> because . is representing the open circle used for function composition
05:48:03 <Axman6> Cale: no, you could just stop redefining Prelude functions. the Prelude is what we all learn first, and it's supposed to be standard
05:48:21 <Axman6> again, i agree with ivanm
05:48:24 <Twey> @pl \x -> (f x) x
05:48:24 <lambdabot> join f
05:48:32 * Eelis confesses to being a  (.) = fmap  user
05:48:36 <burp> it behaves the same, doesn't it?
05:48:37 <ivanm> Cale: and it's hard enough explaining to newbies that they need to end a chain of compositions with a ($), without having to work out when you do and when you don't (that is, when you're composing functions and when you're fmapping)
05:48:49 <tromp__> > succ $ Just 3
05:48:50 <ivanm> @slap Eelis
05:48:50 <lambdabot>   No instance for (GHC.Enum.Enum (Data.Maybe.Maybe t))
05:48:51 <lambdabot>    arising from a use ...
05:48:51 * lambdabot hits Eelis with a hammer, so they breaks into a thousand pieces
05:48:58 <burp> in cases where one could use .
05:48:59 <Twey> If we designed our language based on what was easy to explain to newbies, we'd have COBOL.
05:49:09 <ivanm> Twey: really?
05:49:20 <Axman6> Eelis: i don't have a problem with doing it. i have a very large problem with doing in in lambdabot
05:49:22 <Twey> Or something far too much like it for comfort.  :√æ
05:49:38 <Cale> ivanm: Well, you just explain what fmap is.
05:49:48 <Cale> ivanm: and what it means for functions
05:49:55 <ivanm> Cale: how does it work with mixing function composition with fmapping?
05:49:59 <Cale> ivanm: f . x is never equivalent to f $ x
05:50:00 <tromp__> it helps understanding other ppl's code to know that (.) is mere function composition
05:50:11 <ivanm> Cale: right
05:50:43 <ivanm> @type \ f g x -> f . g $ x
05:50:45 <lambdabot> forall a b a1. (a -> b) -> (a1 -> a) -> a1 -> b
05:50:50 <Axman6> Cale: but that involves learning both function composition AND what functors at the same time, AND trying to figure out how functions are functors... and if i were beginning with the language, i would honestly say fuck it, and not bother. it's too much work
05:50:58 <ivanm> hmmm, OK, it defaults to function composition when using a $
05:51:15 <ivanm> Axman6: agreed; you can't teach them everything at once!
05:51:38 <Cale> Well, it's not like you have to learn how every overloading of a polymorphic thing works at once.
05:51:50 <ivanm> Cale: if it wasn't that function-composition _is_ fmap for ((->) a), would you use it for fmap?
05:51:55 <Cale> You can learn that (.) for functions is composition before you learn what it means for other values.
05:52:06 <ivanm> I mean, would you choose (.) as the fmap operator?
05:52:41 <ivanm> Cale: if it is generalised, then you have more stuff that you hand-wave away for now when students look at a type sig
05:52:46 <Cale> ivanm: If it didn't have the nice correspondence that (f . g) . x = f . (g . x), perhaps I wouldn't advocate it.
05:52:54 <ivanm> *nod*
05:53:37 <Cale> But that is *so* nice, that I think it deserves to be possible to write it that way :)
05:53:43 <ivanm> heh
05:53:55 <ivanm> > (*2) . succ . Just 3
05:53:57 <lambdabot>   Just 8
05:53:58 <Axman6> Cale: if you honestly want to avoid success at all costs, then keep it that way. i do honestly, truly believe it is enough to make users turn away
05:54:06 <Cale> > ((*2) . succ) . Just 3
05:54:08 <lambdabot>   Just 8
05:54:13 <Cale> > (*2) . (succ . Just 3)
05:54:15 <lambdabot>   Just 8
05:54:22 <ivanm> Cale: I think another possible source of confusion is that if (.) = fmap, then you don't have to end function composition with a $ in cases where the final value is a functor
05:54:35 <koeien371> does lambdabot now seriously have (.) = fmap?
05:54:37 <Cale> ivanm: You do if you want it to mean the same thing.
05:54:40 <Axman6> koeien371: yes
05:54:44 <koeien371> wargh
05:54:44 <Cale> ivanm: and usually only one way will typecheck
05:54:46 <ivanm> Axman6: especially if some want to leave because of unary minus... ;-)
05:54:56 <ivanm> koeien371: exactly
05:54:57 <koeien371> :t (++)
05:54:57 <Axman6> ivanm: heh, yeah
05:54:58 <lambdabot> forall m. (Monoid m) => m -> m -> m
05:55:03 <koeien371> ha. good
05:55:36 <Cale> > sortBy (comparing length ++ compare) (words "here are some words to sort first by length and then alphabetically")
05:55:37 <ivanm> Cale: it gets to even more of a special case though
05:55:38 <lambdabot>   ["by","to","and","are","here","some","sort","then","first","words","length"...
05:55:49 <Axman6> Cale: if you want it changed in the language, then get it added to Haskell 2011. but don't go confusing people who are trying to learn by giving them inconsistent definitions
05:56:00 <Twey> @pl \x -> f x (g x)
05:56:01 <lambdabot> ap f g
05:56:24 <Cale> ivanm: special case?
05:56:41 <ivanm> Cale: I still think the major drawback to the general definitions of (.) and (++) is that users wanting to (or forced to) learn haskell, when playing with :type in ghci/hugs will get confused with the type-class stuff
05:56:56 <Cale> ivanm: f . x applies f under the functor, f $ x applies it at the outer level
05:57:02 <ivanm> Cale: if it happens to work in cases where the final value is a functor, then someone might expect that it will always work
05:57:12 <Cale> this is true even when the functor happens to be a function type :)
05:57:16 <Axman6> Cale: i don't mind the (++) so much, as it doesn't shoot people in the foot that much (and i do like the idea of using (++) for mappend, and would like to see that happen in the language)
05:57:17 <ivanm> Cale: true
05:57:26 <Eelis> ivanm: even ":t 4" will show type classes, so i think your battle was lost a long time ago :)
05:57:46 <ivanm> Axman6: except that lists are so ubiquitous when teaching pattern matching, functioin definitions, etc. that again, it might cause confusion
05:58:07 <ivanm> Eelis: heh, true; but how many people will try to find the type of a number?
05:58:17 <Axman6> Cale: so how do i explain to someone who is learning haskell why (+3) . (^2) . [1..10] works, but (+3) . (^2) . 10 doesn't?
05:58:17 <Twey> Woohoo!
05:58:20 <napping> ivanm: that's the sort of stuff Helium is for
05:58:20 <Cale> Yeah, typeclasses are essential to programming in Haskell, and understanding how they work is one of the first things you *must* learn as a beginner. (I usually put it on day one of teaching a new Haskell programmer)
05:58:25 <Eelis> ivanm: i think it was the first code i wrote in ghci :)
05:58:47 <ivanm> napping: except last I checked, helium dind't build too well anymore
05:58:50 <ivanm> Eelis: heh
05:58:55 <napping> if you realy think you need more restricted types for everything to teach
05:58:56 <Cale> Axman6: You explain that [] is an instance of Functor
05:58:57 <Twey> > let replace x y = foldr (ap (((y :) ??) . (:)) (== x)) [] in replace "foo" "bar" ["foo", "baz", "foo", "quux"]
05:58:58 <lambdabot>   ["bar","baz","bar","quux"]
05:59:00 <Twey> \o/
05:59:20 <BONUS> i think making (.) work on functors and (++) on monoids would make things hell of a lot more confusing for beginners, but i still support it
05:59:28 <Twey> @let replace x y = foldr (ap (((y :) ??) . (:)) (== x)) []
05:59:29 <lambdabot>  Defined.
05:59:45 <ivanm> BONUS: yes, but you'd just draw another silly picture to explain it...
05:59:46 <ivanm> ;-)
05:59:49 <napping> (++) for monoids is good, not so sure aboud (.)
05:59:51 <Twey> Hehehe.
05:59:54 <BONUS> beginners shouldn't be holding the language back imo, it's our job to kind of deliver the language to beginners
05:59:57 <BONUS> ivanm: haha, probably!
06:00:00 <napping> that seems more like some kind of fibration thingy
06:00:00 <Twey> BONUS: <3
06:00:05 <Axman6> Cale: and they'll say 'what the fuck is a functor?', and i'll then have t5o go and explain to them all about types, and all about this and all about that, and finally be able to tell them what a functor is. by this time, they've stopped paying attention, and their brain feels like mush. i am saying this from experience
06:00:17 <Cale> napping: It's a consequence of the covariant hom functor ;)
06:00:29 <napping> when do you use fmap on arrow types for?
06:00:38 <Cale> Axman6: Yes, and that's the appropriate state to be in for a beginner.
06:00:46 <Twey> Axman6: Or they could just spend some leisure time with BONUS's pretty pictures.  Or the typeclassopaedia.  Whichever takes their fancy.  :√æ
06:00:50 <napping> except for pointsfree stuff?
06:00:53 <Cale> napping: fmap on function types is composition
06:00:53 <Axman6> Cale: no, it isn't, because you don't learn anything then!
06:00:55 <BONUS> if we make (++) work on monoids and such, there will be a lot of more "trust me on this for now" while explaining
06:01:08 <Cale> Axman6: If your brain doesn't feel like mush, you're not learning.
06:01:21 <Twey> Axman6: I can certainly say that I spent a fair amount of time in the mush state when entering Haskell.
06:01:22 <Cale> (at least you're not learning at an appropriate pace ;)
06:01:23 <BONUS> like when you're explaining java to someone (lol) and they just have to trust you blindly that they're supposed to write public static void main(String args[]) without knowing what any of it means
06:01:32 <Axman6> no, you're learning when you're saying 'Ah HA!, not when you're saying uh huh...
06:01:54 <Axman6> small steps are far more effective in my experience than large ones
06:01:58 <Cale> Why do I have to write static there?
06:02:02 <Cale> ;)
06:02:11 <BONUS> haha
06:02:17 <Twey> Heh
06:02:19 <ivanm> Axman6: especially if they're predisposed to hating Haskell
06:02:25 <BONUS> yeah then you have to explain Java's half assed OP to them or just say trust me
06:03:00 <napping> is there a faster xpath library than HXT on hackage?
06:03:13 * hackagebot upload: graphviz 2999.7.0.0 - Graphviz bindings for Haskell. (IvanMiljenovic)
06:03:29 <Cale> "It's because... you know how if you walk across the carpet wearing socks, you can zap someone with static? It's like that. If you don't put static there, there won't be enough electricity to run your program."
06:03:37 * Twey laughs.
06:03:41 <Saizan> if you get exposed to typeclasses early on you'll probably have much less problems with the mystical "Monad"
06:03:49 <Twey> Saizan: Aye
06:04:08 <Axman6> Saizan: i didn't find that was the case when i was learning haskell
06:04:18 <napping> a little more defaulting might help
06:04:40 <napping> if :t 1 gave you (Num a) => a (default Integer)
06:04:55 * Cale feels it's safe to assume that Haskell beginners are very smart.
06:05:01 <napping> and :t (++) (Monoid m) => m -> m -> m (default [a] -> [a] -> [a])
06:05:04 <Twey> Or at least moderately smart.
06:05:05 <Saizan> anyhow, what's so hard about typeclasses?:)
06:05:05 <Cale> They *will* figure it out. ;)
06:05:25 <Twey> And if they're not, we don't want them anyway!
06:05:25 <ivanm> Cale: I don't
06:05:28 <Axman6> urgh
06:05:29 <BONUS> Cale: yeah i agree. people generally figure stuff out
06:05:31 <Axman6> this is hopeless
06:05:37 <ivanm> Cale: because of how many of them are "forced" to do it in first year university
06:05:47 <ivanm> when they just want to be happy little blub programmers
06:05:48 <BONUS> i managed to figure out a good part of haskell and im not smart
06:05:58 <Cale> ivanm: Well, they'll figure it out, or else go use another language ;)
06:06:01 <ivanm> BONUS: right, but you _wanted_ to figure it out!
06:06:07 <Twey> Or another university
06:06:08 <ivanm> Cale: after failing their exam...
06:06:14 <ivanm> and blaming it on the language rather than themselves
06:06:20 <Cale> ivanm: Fine with me :)
06:06:25 <Axman6> >_<
06:06:32 <BONUS> oh yeah, that's true. if haskell was forced upon me by my uni, i'd probably hate it by now
06:06:32 <ivanm> Cale: heh
06:06:38 <Axman6> just put lambdabot back to how it's supposed to be >_<
06:06:38 <Twey> ivanm: Hint: making exams easier doesn't magically increase the students' level of ability, it just hides their deficiencies.
06:06:54 <Twey> It's an easy mistake to make.  Our government's been doing it for years.  :√æ
06:06:54 <ivanm> Cale: I just remember how many people instantly hated scheme even before our first lecture in first year...
06:06:55 <ivanm> Twey: I know
06:07:02 <BONUS> that's why i'm sort of against teaching haskell at schools :)
06:07:02 <ben> Is there any interest in making the fancy operators operate on type classes, and provide verbosely named aliases for specific types?
06:07:09 <BONUS> teach them java and make them hate it
06:07:20 <Axman6> BONUS: they did both here
06:07:24 <ivanm> Twey: but for the projects and assignments I've been writing, I've been told to make them _simpler_ a few times :(
06:07:29 <napping> what's the point of making verbose aliases?
06:07:30 <koeien371> we got Delphi and later one course on Haskell
06:07:35 <Twey> ivanm: Ack!
06:07:37 <Cale> People will hate whatever language you force them to use in first year uni. Maybe that's why Java is a good choice for that.
06:07:41 <ivanm> napping: for imports?
06:07:48 <napping> when they are already spelled (foo :: SpecificType)
06:07:49 <koeien371> heh. I hate Delphi now =)
06:07:55 <Axman6> made me love haskell, but only becausew it was taught by someone who understood the mond of someone who doesn't already know haskell, which i feel Cale does not
06:07:58 <Twey> This is why I'm sort of against forcing students to use a programming language in schools ;)
06:08:15 <BONUS> i also hate matlab, which i was forced to use in my second year of uni but i resisted and i still have my numerical methods class to finish
06:08:24 <Cale> Axman6: I really do understand what it's like not to know Haskell. I just have different standards about what it should feel like to learn something.
06:08:29 <ivanm> Twey: well, its for a subject for first-year science students, teaching them math and python; I have a tendency to make the math and code a bit harder than they should be for first year biologists... >_>
06:08:42 * ivanm isn't prejudiced against biologists, honest!
06:08:42 <Twey> ivanm: Ah, that makes sense then :√æ
06:08:47 <napping> so, no better xpath?
06:08:55 * Twey imagines ivanm's poor biology teacher's eyes boggling.
06:09:02 <Axman6> Cale: i don't think we should be basically going out of our way to make haskell harder to learn.
06:09:04 <napping> It's taking a second or so to parse some things, which is a bit too long
06:09:19 <Twey> ‚ÄòZygo‚Ä¶histo‚Ä¶morphic‚Ä¶ pre-prow-morph-isms‚ÄΩ‚ÄΩ‚Äô
06:09:31 <koeien371> Axman6: i don't think that is Cale's point :)
06:09:31 <Cale> Axman6: I don't think we should be so concerned about how hard/easy it is to learn, and just focus on what's useful.
06:09:38 <ivanm> Twey: I never did any biology after grade 10, when it was part of the general science curriculum
06:09:45 <Axman6> >_<
06:09:50 <napping> oh, and all the paths are the sort that can be processed on an event stream
06:09:54 <koeien371> what about Helium? is it widely used?
06:09:55 <Twey> ivanm: You're teaching?
06:09:56 <Cale> If we design things to be useful, then we can explain why we did that to the beginners.
06:09:58 <Twey> Wait, what?  :√æ
06:10:10 <ivanm> Twey: nope
06:10:25 <napping> Cale: have you written much code with (.) = fmap?
06:10:28 <Cale> Give me 10 or 15 minutes, and I can explain how (.) works to someone who knows about typeclasses.
06:10:28 <Axman6> which reminds me, i need to see if i can be a tutor for the course that teaches haskell to people at uni this coming semester
06:10:44 <Axman6> and what about someone who doesn't?
06:10:48 <ivanm> I was just helping to do the administrative side of this course (that is, checking and writing lecture notes, tutorials and assessment, and being the first point of contact with students)
06:10:52 * koeien371 fell instantly in love with Haskell
06:10:55 <Cale> napping: Not *a lot*, since it's a bit of a pain to set it up every time. But for the code where I've tried it, it's been nice and convenient.
06:10:56 <Axman6> basic understanding of typeclasses is easy
06:11:08 <Axman6> koeien371: i was the same
06:11:16 <koeien371> maybe because of my math background
06:11:20 <napping> Cale: did it make type errors a bit more ambiguous?
06:11:22 <koeien371> most of the CS students hated it
06:11:23 <ben> Cale: Are you still using an infixl $?
06:11:25 <ivanm> Cale: only because . is five characters shorter than `fmap` ?
06:11:49 <Zao> That sentence didn't read right until I noticed the backticks.
06:12:11 <Saizan> ivanm: <$> btw
06:12:12 <Cale> napping: not really. It's rare that something is polymorphic in the type of functorial value that it is.
06:12:18 <ivanm> Saizan: I know...
06:12:25 <napping> I suppose it shouldn't be that hard to do something like s/`fmap`/./g s/fmap/(.)/g
06:12:31 <Cale> napping: That is, it's hard to put the (.) in a place where its type is ambiguous
06:12:32 <Twey> ivanm: Aha
06:12:33 <ivanm> Saizan: but Cale said before that he doesn't like importing that in unless he also uses <*>
06:13:07 <ivanm> @tell jfredett there, I've released something for you... happy now?
06:13:08 <lambdabot> Consider it noted.
06:13:10 <Cale> ivanm: I meant that I don't like using <$> unless I'm also using <*> (or other applicative operators) around the same expression
06:13:21 <ivanm> ahhh
06:13:25 <Cale> I'll just use fmap in that case.
06:14:00 <ivanm> *nod*
06:14:14 <Cale> Or *gasp* do-notation ;)
06:14:23 <Cale> (when it applies)
06:14:29 <napping> so, no suggestions for xpath or xpathis-on-sax libraries?
06:14:37 <ivanm> heh
06:14:48 <Cale> napping: I'd help if I had the first idea about what that was.
06:14:51 <Axman6> Cale: if you want to teach people to use (.) = fmap, then fine, go for it. but i don't want to have to, so could you please stop making my life harder when trying to help people?
06:14:59 <Cale> Axman6: hehe
06:15:05 <Axman6> i'm not joking
06:15:15 <Saizan> napping: istr Haxml has some support for it
06:15:31 <Cale> Axman6: By the way, the Prelude version of (.) is available
06:15:35 <napping> I'm using the xpath stuff in HXT, it's just too short
06:15:39 <napping> slow, rather
06:15:44 <Axman6> keep (++) = mappend, that's fine, and makes a lot of sense, and is fairly easily explained. but (.) = fmap is not
06:15:52 <koeien371> > (+1) Prelude.. Just 1
06:15:52 <lambdabot>   Not in scope: `Prelude..'
06:15:55 <ivanm> Cale: but the prelude version of (.) isn't (.) ...
06:16:00 <koeien371> > (+1) Prelude.(.) Just 1
06:16:01 <lambdabot>   Not in scope: data constructor `Prelude'
06:16:17 <koeien371> how?
06:16:19 <Axman6> (+1) (Prelude..) 1
06:16:20 <Cale> > (+1) Prelude.. Just 1
06:16:22 <lambdabot>   Not in scope: `Prelude..'
06:16:22 <Axman6> > (+1) (Prelude..) 1
06:16:23 <lambdabot>   Not in scope: `Prelude..'
06:16:23 <koeien371> argh
06:16:25 <Cale> > (+1) P.. Just 1
06:16:27 <lambdabot>   Couldn't match expected type `a -> b'
06:16:27 <lambdabot>         against inferred type `Data.M...
06:16:28 <ivanm> @type succ P.. pred
06:16:29 <lambdabot> Couldn't find qualified module.
06:16:34 <Cale> There it is :)
06:16:37 <ivanm> Cale: heh, see? even you get mixed up!
06:16:52 <Cale> ivanm: Just had to recall what the Prelude had been imported as :)
06:16:54 <ivanm> Cale: and @type doesn't seem to know about it...
06:17:05 <napping> @type (succ P.. pred)
06:17:07 <Axman6> oh hoorah
06:17:08 <lambdabot> Couldn't find qualified module.
06:17:17 <Cale> Yeah, @type unfortunately is using a completely different facility for some reason now. That's not my doing.
06:17:19 <ivanm> Cale: ummm... isn't (+1) P.. Just 1 using your definition?
06:17:26 <Cale> ivanm: no
06:17:28 <napping> probably wants one name
06:17:32 <Cale> Mine is L..
06:17:33 <koeien371> it givesa  type error
06:17:33 <napping> @type P..
06:17:35 <lambdabot> parse error on input `P..'
06:17:40 <ivanm> oh, wait, it complained
06:17:41 <napping> @type (P..)
06:17:43 <lambdabot> Couldn't find qualified module.
06:17:45 <koeien371> > (+1) P.. (+2) $ 3
06:17:46 <lambdabot>   6
06:17:50 <Cale> @type (L..)
06:17:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:17:54 <napping> wierd
06:17:55 <Cale> ah, hmm
06:18:01 <Cale> That *is* weird.
06:18:08 <Axman6> see, even you can't make it work nicely!
06:18:15 <Cale> Why is L available if @type doesn't know about P?
06:18:17 * hackagebot upload: Blueprint 0.1 - Preview of a new build system. (GregoryCrosswhite)
06:18:30 <Cale> Axman6: I didn't write all this.
06:18:30 <ivanm> not another one...
06:18:32 <Axman6> who knows!
06:18:34 <Axman6> who cares!
06:18:46 <Axman6> Cale: yes, but you DID break it
06:18:52 <Cale> Axman6: Oh?
06:18:55 <napping> well, guess I can try rewriting the queries with something like TagSoup
06:19:06 <BONUS> whatever happened to "avoid success at all costs" :)
06:19:07 <Axman6> what's the type of the prelude (.) Cale?
06:19:12 <Axman6> show me, without you writing it
06:19:27 <Axman6> BONUS: it's a raging success at the moment
06:19:28 <Cale> Why without me writing it?
06:19:28 <ivanm> @type (.)
06:19:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:19:34 <Axman6> no!
06:19:35 <Cale> It's (b -> c) -> (a -> b) -> (a -> c)
06:19:38 <koeien371> :t (.) :: (b->c) -> (a -> b) -> (a->c)
06:19:39 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
06:19:41 <ivanm> Axman6: that was my point
06:19:47 <ivanm> :type (.)
06:19:49 <Axman6> Cale: i said without you writing it
06:19:54 <ivanm> koeien371: cheater!
06:19:58 <Cale> Axman6: and I asked why not?
06:20:00 <ivanm> Cale: he means get lambdabot to type it
06:20:07 <ivanm> :t (.)
06:20:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:20:10 <napping> Cale: xpath is a pretty nice notation for getting nodes from HTML or XML by parents and stuff, if you haven't heard of it
06:20:17 <ivanm> why does :t work but not :type ?
06:20:18 <napping> :t P.head
06:20:19 <Axman6> because i shouldn't have to write out the types of Prelude functions
06:20:20 <lambdabot> Couldn't find qualified module.
06:20:22 <Cale> napping: ah
06:20:37 <napping> seems like it can't find anything in the prelude
06:20:45 <napping> it's not like . is special
06:20:50 <Cale> :t Prelude.head
06:20:51 <lambdabot> forall a. [a] -> a
06:20:55 <koeien371> :t Prelude..
06:20:55 <Cale> ah, hmm
06:20:56 <lambdabot> parse error on input `Prelude..'
06:20:58 <koeien371> :t (Prelude..)
06:20:59 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
06:21:03 <koeien371> yay
06:21:07 <Cale> Well, that's interesting.
06:21:13 <Axman6> Cale: i don't see what your problem is with fixing it. it's causing a lot of people problems when trying to help people, and it doesn't gain very much
06:21:25 <Cale> Why doesn't it use the qualified name if the Prelude is imported qualified?
06:21:31 <ivanm> fixing it == removing Caleskell
06:21:32 <ivanm> ;-)
06:21:51 * ivanm hits the sack
06:21:52 <ivanm> g'night all
06:22:00 <shambler> hehe
06:22:01 <shambler> gn
06:22:10 <burp> oh, right there are ppl in other timezones
06:22:16 <Cale> I don't see how modifying a couple definitions means it's not "Haskell" anymore. Haskell is still Haskell if you replace a few Prelude definitions :P
06:22:16 <koeien371> they exist! zomg
06:22:22 * Axman6 goes back to watching http://channel9.msdn.com/shows/Going+Deep/C9-Lectures-Dr-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-8-of-13/ to avoid getting more pissed off
06:22:27 <shambler> a lot of, this channel is alive 24|7
06:22:39 <Axman6> Cale: because it's making my life needlessly difficult!
06:22:45 <Cale> Axman6: how so?
06:22:58 <Axman6> i've already explained many times now
06:23:23 <shambler> Axman6, thx for the link tho
06:23:28 <Axman6> i don't want to have to explain what Functors are to someone who just wants to know why their function composition isn't working
06:23:45 <BONUS> it's a trade-off, i guess. it makes it harder to explain, but easier to write code once you know how
06:24:06 <Axman6> sure
06:24:27 <Axman6> it's like sex. do it at home, and i won't complain. but when you do it in my lap, i'll get pissed off
06:24:55 <shambler> why?
06:25:01 <shambler> i wont
06:25:03 <shambler> :<
06:25:12 <Twey> Hehehe
06:25:13 <Axman6> s/sex/masturbation
06:25:21 <Axman6> better
06:25:22 <shambler> ok, now I understand
06:25:23 <Axman6> ?
06:25:27 <shambler> yeah :)
06:25:51 <Cale> Axman6: I don't see what lambdabot's definition has to do with that.
06:26:14 <Cale> Unless code is working in lambdabot and they want it to work the same way in their own code.
06:26:33 <Cale> In which case your best bet is to just tell them how to redefine (.) to do what they want
06:26:38 <BONUS> @botsnack
06:26:38 <lunabot>  :o
06:26:38 <lambdabot> :)
06:26:46 <BONUS> , :t (.)
06:26:47 <lunabot>  luna: Couldn't match expected type `((b -> c) -> (a1 -> b) -> a1 -> c)
06:26:49 <Axman6> it has to do with you pleasuring yourself in public, using a public resource. lambdabot is here as a learning and teaching tool
06:27:11 <Axman6> and you chainging it from the standard people are trying to learn from is confusing
06:28:20 <Cale> Axman6: Well, help me change the standard then :)
06:28:20 <Saizan> #ty :t
06:28:23 <lunabot>  luna: Exception when trying to run compile-time code:
06:28:26 <napping> code from lambdabot hasn't been the same as ghci for years
06:28:36 <Axman6> Cale: go for it
06:28:42 <napping> and anything that works in ghci should work in lambdabot
06:29:00 <Cale> Axman6: Though to be fair, I don't think Haskell 20x6 is relevant. What's really relevant is what's in GHC.
06:29:17 <Axman6> Cale: is (.) = fmap in GHC?
06:29:22 <zygoloid> Cale: consider: newbie: "why is (succ . (+)) 1 2) not working?"  someone-on-#haskell: "@type succ . (+)"  lambdabot: lies  someone-on-#haskell: "@type (succ . (+)) 1 2"  lambdabot: more lies
06:29:28 <Cale> Axman6: No, but let's write a new base package :)
06:29:32 <zygoloid> newbie: confused
06:29:49 <napping> consider newbie asking why code with ap in it isn't working
06:29:59 <Axman6> zygoloid: thankyou for coming up with an example, i wanted to, but couldn't be bothered
06:30:00 <zygoloid> Cale: (.) is not fmap for the same reason that map is not fmap and mappend is not (++) -- to keep the language simpler for people learning it
06:30:22 <Cale> :t (succ . (+))
06:30:24 <lambdabot> forall a. (Enum (a -> a), Num a) => a -> a -> a
06:30:33 <Cale> That's exactly the same as in ghci
06:30:40 <Cale> :t (succ . (+)) 1 2
06:30:42 <lambdabot> forall a. (Enum (a -> a), Num a) => a
06:30:48 <zygoloid> Cale: ok, so i picked a bad example
06:30:48 <Cale> ghci> :t (succ . (+)) 1 2
06:30:48 <Cale> (succ . (+)) 1 2 :: (Enum (a -> a), Num a) => a
06:31:14 <Cale> It's hard to construct examples where you expose the general type of (.) without just putting (.) on its own
06:31:19 <napping> well, time to be off. bye
06:31:19 <Cale> (or partially applying it)
06:31:30 <zygoloid> @type fromMaybe 0 . Just 42
06:31:32 <lambdabot> forall t. (Num t, Num (Maybe t)) => Maybe t
06:31:46 <Cale> See, there it's being used monomorphically for Maybe
06:32:13 <Cale> and in ghci, that just doesn't work because (.) is less general
06:32:16 <gemie> if I got a (a,b) and use guards and check like a > 1 isn'at that possible?
06:32:21 <Axman6> "why doesn't (+1) . 7 work?" "> (+1) . 7" "lambdabot:  8" "what the fuck?"
06:32:29 <zygoloid> Cale: right, and a newbie might ask "why does this not work?"
06:32:31 <Cale> > (+1) . 7
06:32:33 <lambdabot>   No instance for (GHC.Num.Num (f a))
06:32:33 <lambdabot>    arising from the literal `7' at <int...
06:32:39 <Cale> ^^ doesn't work
06:32:43 <zygoloid> Cale: we try to show in lambdabot and lambdabot says something different from ghci
06:32:57 <Cale> Please try to understand the generalisation yourself before complaining about it ;)
06:33:02 <Axman6> "why doesn't (+1) . Just 7 work?" "> (+1) . Just 7" "lambdabot:  8" "what the fuck?"
06:33:08 <Axman6> Just 8
06:33:34 <zygoloid> Cale: please try to understand the argument against, rather than presenting an argument for
06:33:35 <gemie> why won't this work? abc (x:xs) (i, b) =
06:33:35 <gemie>  | i > 0 =
06:33:39 <Cale> Axman6: then explain that lambdabot has a more general definition of (.) that they can use to make it work
06:33:41 <BONUS> what's with the GHC.type.type thingy in lambdabot again?
06:33:44 <gemie> I get parse error on input `|'
06:33:54 <koeien371> gemie: remove the =
06:33:56 <Cale> gemie: guards come before the =
06:33:58 <koeien371> e.g.
06:34:12 <koeien371> f a | a > 0 = a ^ 2
06:34:19 <koeien371>    | a < 0 = - a^2
06:34:40 <Twey>     | a == 0 = error "EXPLODE"
06:34:41 <zygoloid> Cale: that answer is only good if we presuppose that you're right and the haskell standard is wrong about the "best" definition of (.)
06:34:48 <Axman6> Cale: and then explain to them that i can't really help them, because what i show them might not actually work for them? i can't show them why their code is broken when i can't show them that their code is broken
06:35:32 <Axman6> it's just making life harder for both those learning, and teaching (which many us are both!)
06:35:42 <Cale> Axman6: Well, this is supposing that they actually want (.) to be functorial application, which seems to be the case if they're wondering why  f . Just 6  doesn't work.
06:35:46 <gemie> oh :)
06:35:50 <gemie> thanks
06:36:25 <zygoloid> those of us in the know can just say "hmm, Caleskell" again every time this crops up, but i doubt newbies can just say "oh, right, (.) == fmap for the (->) r Functor anyway, so that's a reasonable generalization"
06:36:31 <Cale> (not something I've run into a whole lot myself)
06:37:02 <Cale> zygoloid: But those of us who know can explain that (.) = fmap for the (->) r functor :)
06:37:10 <BONUS> i haven't run into it, but if i would i'd just type out the type of (.) myself or tell them to do :t (.) in ghci
06:37:18 <Axman6> Cale: I DON'T WANT TO HAVE TO!
06:37:20 <poe> What about having two '> '? A 'ghci> ' one which is note Caleskell.
06:37:23 <zygoloid> Cale: and then we have to explain to someone who is struggling with function composition what a Functor is?!
06:37:24 <Axman6> for fuck sake
06:37:26 <Cale> Axman6: why not?
06:37:31 <poe> s/note/not/
06:37:48 <Cale> zygoloid: It's really not that complicated.
06:37:58 <Axman6> poe: that doesn't get in the way though
06:38:00 <Cale> (I've done it a number of times)
06:38:08 <BONUS> anyone got a newbie handy?
06:38:15 <Axman6> Cale: so we should send everyone who has problems your way?
06:38:16 <BONUS> haha
06:38:22 <Cale> Axman6: go for it :)
06:38:46 <Cale> That's what I'm mainly here for anyway
06:38:55 <Cale> hehe
06:38:58 <NEWBIE_> Hello. Why doesn't (+1) . Just 7 work ????
06:39:05 <NEWBIE_> > (+1) . Just 7
06:39:07 <lambdabot>   Just 8
06:39:08 <NEWBIE_> zomg
06:39:18 <BONUS> lol
06:39:38 <zygoloid> Cale: to be honest, i think my biggest objection is that you're pushing your own agenda and library changes onto newbies who come here to learn haskell
06:40:07 <poe> But that isn't a good objection, since the generalization makes much sense!
06:40:15 <Axman6> Cale: how many people do you get saying to you "oh hey Cale, thanks for making (.) = fmap, it makes life so much easier for beginners to learn haskell, and i use it all the time", and how many people have you had rather strongly protest it?
06:40:26 <zygoloid> Cale: not that i think that (.) == fmap is a bad change per se, but i don't think you're the authority who should be making that choice
06:40:30 <Cale> Axman6: There are people who like it :)
06:40:33 * koeien371 is ambivalent
06:40:40 <BONUS> all changes to the language result in having to alter your explanations to newbies.
06:40:40 <mreh> remember my long list that I want to read at runtime from a file, will read only read one part at a time as it is required
06:41:00 <BONUS> and i think cale is just trying to make the language more like he wants it, which is not bad. why not?
06:41:06 <Axman6> yes, there are. and i would bet that absolutely none of them would be as pissed off if you removed it, as i am that you won't.
06:41:30 <mreh> @src read
06:41:31 <lambdabot> read s = either error id (readEither s)
06:41:39 <Axman6> o.O
06:41:44 <zygoloid> i for one would not mind too much if the Prelude were changed to have (++) = mappend; (.) = fmap; map = fmap, but that's not the language we have today, and it's not the language people will be tested on in CS exams, and so on
06:41:52 <Cale> mreh: read is actually a typeclass method
06:42:00 <Cale> mreh: It's implemented differently for every type
06:42:18 <mreh> Cale: so for a list it is done recursively
06:42:30 <mreh> and therefore lazily
06:42:56 <Cale> mreh: by parsing the initial [ and then comma separated readable values, yes
06:43:02 <Cale> (and lastly a ] of course)
06:43:07 <zygoloid> (i /slightly/ mind using the (.) symbol as functorial application because it means composition in mathematics, and I much prefer <$>, but...)
06:43:22 <Axman6> Cale: if you want to make the change, and have us all live by it, then do it through the appropriate people. don't force it upon us because you think it's neat
06:43:34 <mreh> Cale: how does it know you have a complete list if it's done lazily
06:43:42 <mreh> it might be missing a terminating ]
06:43:55 <Axman6> mreh: then it won't terminate/it will error
06:43:57 <Asztal> > read "[1,2,3" :: [Int]
06:43:59 <lambdabot>   * Exception: Prelude.read: no parse
06:44:04 * BONUS wishes fmap was named <$> from the start
06:44:05 <koeien371> > head (read "[1,2,") :: Int
06:44:06 <lambdabot>   * Exception: Prelude.read: no parse
06:44:13 <stroan> show $ read "[1,2,3" :: [Int]
06:44:16 <stroan> > show $ read "[1,2,3" :: [Int]
06:44:17 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
06:44:18 <lambdabot>         against inferred type ...
06:45:01 <Saizan> :: spans over the whole expression
06:45:01 <Cale> mreh: Oh, it's not done lazily.
06:45:12 <Cale> > read ('[' : intercalate "," (map show [1..])) :: [Integer]
06:45:16 <lambdabot>   mueval-core: Time limit exceeded
06:46:53 <zygoloid> Cale: also it's a bit horrible that Caleskell says (.) == fmap, whereas Control.Category says (.) = (<<<). and it's unnecessary since we already have a standard operator name for fmap: (<$>).
06:47:04 <Axman6> Cale: why can't you add a new library to lambdabot that lets you use Cale.., and Cale.++? then people can play to their hearts content, and newbies don't get confused
06:47:17 <Saizan> to get online parsers you either need to report failures as pure excpetions, or have a correcting parser like uu-parsinglib
06:47:34 <Cale> zygoloid: I would prefer that Category use (<<<) myself.
06:47:55 <Axman6> @let (.) = (<<<)
06:47:56 <lambdabot>  <local>:36:0:
06:47:56 <lambdabot>      Multiple declarations of `L..'
06:47:56 <lambdabot>      Declared at: .L.hs:79...
06:48:00 <Axman6> what a shame
06:48:08 <zygoloid> Cale: and that's exactly the point. your preferences should be yours alone, and not enforced on those learning haskell here.
06:48:38 <Cale> zygoloid: I'm the one who makes sure the bot stays running though :)
06:48:40 <zygoloid> Cale: i quite like that the category-theoretical composition, written as a dot, is expressed as a dot in askell
06:48:48 <Cale> zygoloid: People can run other bots if they want to.
06:49:02 <Axman6> Cale: well take the bot out then. i'll host it, and not do things that piss people off. how does that sound?
06:49:13 <Cale> zygoloid: Except that Control.Category isn't really a proper general definition of category.
06:49:41 <zygoloid> Cale: obviously i'm completely powerless to make you change your bot (and actually grateful for it)
06:49:41 <zygoloid> Cale: well, sure ;-)
06:50:36 <BONUS> why can't there be several bots
06:50:37 <Axman6> @let map = const
06:50:38 <lambdabot>  <local>:5:41:
06:50:38 <lambdabot>      Ambiguous occurrence `map'
06:50:38 <lambdabot>      It could refer to either ...
06:50:40 <zygoloid> #ty (.)
06:50:43 <lunabot>  forall a c b . (b -> c) -> (a -> b) -> a -> c
06:50:47 <Cale> zygoloid: I think there are not enough examples of good uses of the Control.Category definition of "category" to make it worthwhile to use the (.) notation for it.
06:51:09 <Axman6> BONUS: there can be, but then they'll all be saying different, conflicting things
06:51:17 <Axman6> lambdabot: > 2
06:51:27 <zygoloid> Cale: I completely agree with that. However... it is in base, and your definition is not.
06:51:28 <Axman6> see, there's no way for me to just call lambdabot
06:51:35 <Saizan> > 2
06:51:36 <lambdabot>   2
06:51:38 <Saizan> , 2
06:51:39 <lunabot>  2
06:51:41 <Cale> lambdabot: @eval 2
06:51:50 <Cale> er, I think it's @run actually
06:51:52 <Cale> lambdabot: @run 2
06:51:54 <lambdabot>   2
06:52:13 <Cale> I wonder why it's @run and not @eval. Oh well :)
06:52:23 <zygoloid> @help eval
06:52:24 <lambdabot> eval. Do nothing (perversely)
06:52:36 <mreh> Cale, doesnt lambdabot try to perform show on all function results?
06:52:45 <koeien371> > \x -> x^2
06:52:46 <lambdabot>   {-3->9;-2->4;-1->1;0->0;1->1;2->4;3->9}
06:52:48 <zygoloid> > (+)
06:52:50 <lambdabot>   -3->
06:52:50 <Cale> mreh: that it does
06:52:50 <lambdabot>    {-3->-6;-2->-5;-1->-4;0->-3;1->-2;2->-1;3->0}
06:52:50 <lambdabot>  -2->
06:52:50 <lambdabot>    {-3->-5;-2->...
06:53:00 <mreh> read ('[' : intercalate "," (map show [1..])) :: [Integer], so this would be evaluated
06:53:22 <Saizan> mreh: it doesn't try to show everything
06:53:23 <Axman6> mreh: it's not read lazily
06:53:52 <zygoloid> , take 10 (read ('[' : intersperse ',' (map show [1..])) :: [Integer])
06:53:54 <lunabot>  luna: Couldn't match expected type `GHC.Types.Char'
06:53:56 <Saizan> mreh: you can also try in ghci, [1..] gets printed as constructed, that expression never prints anything
06:54:42 <PeakerWork> @hoogle (a -> Bool) -> [a] -> ([a], [a])
06:54:44 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
06:54:44 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
06:54:44 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
06:54:49 <Saizan> , take 10 (read ('[' : intercalate "," (map show [1..])) :: [Integer])
06:54:55 <lunabot>  Killed.
06:55:08 <mreh> I see
06:55:21 <zygoloid> mreh: essentially, reads is a backtracking parser, and as such it needs to determine whether the parse succeeds or fails to determine whether it should backtrack, before producing a value
06:55:46 <mreh> so I can't compile this list, how will I ever read it?
06:55:52 <zygoloid> so it must parse a /complete/ value before it decides between [] and [(...)]
06:55:54 <mreh> i'll see what happens
06:56:24 <mreh> zygloid, thanks, I understand
06:56:52 <Saizan> i'm not sure the backtracking part actually matters, any parser that reports error failures will have this behaviour (as opposed to e.g. binary)
06:57:09 <Saizan> and you can have a backtracking parser like uu-parsinglib which is instead online
06:59:15 <HugoDaniel> oading package text-icu-0.1 ... linking ... <interactive>: /usr/lib/text-icu-0.1/ghc-6.10.4/HStext-icu-0.1.o: unknown symbol `ucnv_getAlias_4_0'
06:59:21 <Saizan> (i should have said "reports error failures and returns a single result as opposed to a stream of intermediate ones", like you get from tagsoup)
06:59:23 <HugoDaniel> what do i have to do to solve this ?
07:00:18 <Saizan> HugoDaniel: does compiling work?
07:00:28 <HugoDaniel> let me try it
07:01:37 <rumata> Hello. I have a problem. I have html page that I want to parse with "Text.XML.HaXml.Html" module. I parse the page and get "Document Posn". Is there any convinient way to find some elements in the document? Something like JQuery's selector 'table tr td.my_class'.
07:01:51 <zygoloid> Saizan: doesn't uu-parsinglib only give online results if it can determine that it won't have to backtrack?
07:03:39 <Baughn> @tell ivanm http://www.haskell.org/pipermail/haskell-cafe/2009-November/069845.html <-- Here you go.
07:03:39 <lambdabot> Consider it noted.
07:03:57 <jbe> Does GHC.List.foldl fix the space leak on foldl (+) 0 xs ?  Its code comments imply so, but I can't make it work.
07:05:26 <zygoloid> jbe: you want foldl' not foldl for that.
07:05:43 <HugoDaniel> http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=5198#a5198
07:05:49 <HugoDaniel> Saizan, it doesnt link
07:05:53 <jbe> zygoloid: Sure, but I'd rather have the strictness analyzer do the right thing automatically.
07:05:56 <HugoDaniel> what lib am i missing for these symbols ?
07:06:27 <jmcarthur_work> jbe, with optimizations, foldl usually is fine. without, you definitely need foldl'
07:06:27 <jmcarthur_work> jbe, most say to just use foldl'
07:07:09 <Saizan> zygoloid: afaiu, you can inspect the outer constructors of the result before the backtracking about the inner parts is resolved
07:07:13 <Baughn> (Haskell-mode 2.7 out, if anyone's interested. It now understands hlint output.)
07:08:54 <zygoloid> jbe: the foldl in Prelude is imported from Data.List. the foldl in Data.List is imported from GHC.List. it's all the same function.
07:09:14 <Saizan> (meaning? i can apply suggestions automatically?)
07:09:28 <scree> HugoDaniel: unicode libs?
07:09:38 <zygoloid> Saizan: hmm, that sounds pretty neat :)
07:10:04 <rumata> Hello. I have a problem. I have html page that I want to parse with "Text.XML.HaXml.Html" module. I parse the page and get "Document Posn". Is there any convenient way to find some elements in the document? Something like JQuery's selector 'table tr td.my_class'.
07:10:11 <Saizan> it's a pretty neat lib :)
07:10:24 <zygoloid> presumably it reports errors with exceptions, though?
07:10:42 * zygoloid should read the rest of the paper :)
07:10:55 <Saizan> zygoloid: no, it autocorrects the input, and reports the corrections made as a separate list
07:11:08 <zygoloid> what!
07:11:16 <fasta> If you have two completely different kinds of things for which a "width" is defined, would you introduce two type-classes, or just one?
07:11:38 <fasta> That is, two different groups of things.
07:11:56 <zygoloid> fasta: two different names, in different modules, for the different semantics.
07:11:57 <jbe> I tried "-O2" and I still have the space leak (using foldl -- not foldl').  Is there a further optimization I need to turn on to get the strictness analyzer to do its magic?
07:12:08 <fasta> zygoloid, yes, that's what I was about to do.
07:12:14 <fasta> zygoloid, thanks.
07:13:20 <Axman6> jbe: start using ghc 6.13 (ie, HEAD)
07:13:32 <Saizan> jbe: maybe annotate with :: Int
07:13:37 <Axman6> apparently the strictness analyser has got a hell of a lot better
07:13:48 <jbe> Axman6: Ah.  I will wait patiently. :)
07:14:08 <Axman6> :)
07:14:22 <Axman6> probably at least a year until we get it in a release
07:23:35 <Cale> mreh: You could write the values into a file one-per-line and use map read . lines or something?
07:23:48 <Cale> mreh: at least, if you have control over the file format
07:23:54 <mreh> Cale, okay
07:23:56 <mreh> :t lines
07:23:58 <lambdabot> String -> [String]
07:24:08 <mreh> that works
07:26:36 <mreh> :t map read . lines
07:26:38 <lambdabot> forall a. (Read a) => String -> [a]
07:27:20 <mreh> i can't parse that
07:27:39 <mreh> :t readFile
07:27:40 <Cale> For any type which is readable, it turns a String into a list of values of that type
07:27:41 <lambdabot> FilePath -> IO String
07:27:56 <mreh> nah the map read . lines
07:28:12 <mreh> it splits the arg into lines then maps read to it
07:28:15 <mreh> got it
07:28:20 <Cale> yeah
07:28:28 <Cale> It's just the composite function
07:29:48 <gressvol-> Hi, im trying to brutforce solve a sudoku, But I can't seem to get it to work if the "greedy" first solution isn't correct i.e. I don't generate all possibilites. My code recursive loop looks like this | otherwise = head $ filter (\n -> n /= Nothing) $ map solve [ x | b <- blanks sud, c <- candidates sud b, x <- [update sud b (Just c)]]
07:30:10 <gressvol-> where blanks gives all blanks in the sudoku and candidates gives all numbers that can be written in a position
07:32:34 <mreh> gressvol- by creating every sudoku and seeing if it matches yours? that'll take to the end of the universe
07:32:52 <Axman6> gressvol-: just quickly, (\x -> x /= Nothing) = (/= Nothing)
07:33:09 <gressvol-> Axman6: okey
07:34:05 <ben> There is an end of the universe?
07:34:24 <gressvol-> mreh: hmm? Im selecting the first blank in a sudoku and then try all numbers that can be written in that position and try to solve the "new" sudoku
07:34:33 <gressvol-> which has one blank less
07:34:40 <mreh> gressvol- i see
07:35:05 <Cale> Better to use isJust than (/= Nothing) though.
07:35:05 <tensorpudding> ben: sure
07:35:13 <mreh> are you using laziness to simulate backtracking?
07:35:26 <Cale> Or pattern match inside the list comprehension
07:35:42 <HugoDaniel> yes, im installing the icu lib, i didn't had it installed
07:35:43 <HugoDaniel> :)
07:35:50 <gressvol-> mreh: yes that is the idea anyway, but I dont think I'm generating all possibilities since it doesnt work :)
07:35:50 <HugoDaniel> i hope it will work
07:36:00 <Baughn> ben: It should be possible to compute the complete history of the universe with finite resources, assuming the universe is in fact finite in spatial extent. Close enough?
07:36:06 <mreh> gressvol- oh
07:36:35 <ben> Baughn: But it keeps expanding! It might be finite now, but not given infinite time!
07:37:03 <zygoloid> gressvol-: when you say "it doesn't work" do you mean it gives no results, or that it hangs?
07:37:26 <gressvol-> zygoloid: error with head on empty list
07:37:30 <Baughn> ben: Which doesn't matter, since the computation can be optimized. Spatial or temporal extent don't really matter, only the amount of CPU time required to compute them..
07:37:50 <mreh> are list comprehensions implement with the list monad?
07:38:12 <Baughn> ben: I.e. if the entire history of the universe from year 19,000,000,000,000,000 on consists of "nothing happens", I'd argue that only a finite amount of effort is required to compute that
07:38:41 <ben> But you will continuously have quark/antiquark pairs being created and annihilated in the what-passes-for-vacuum
07:38:55 <zygoloid> gressvol-: ok, that makes sense. i guess you've entered the 'guess' case, constructed an impossible sudoku, then landed in the 'guess' case again with no solutions
07:39:18 <gressvol-> I posted the it here so it is easier to read. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5199#a5199
07:39:52 <CptPicard> hmm... is there a way to define a fallback default implementation in a type class... in a way, that would let you handle "any type" that does not have an implementation?
07:40:00 <zygoloid> gressvol-: that's not your actual code. "head map" is a type error all by itself :)
07:40:08 <Baughn> ben: Which corresponds to a steady state when you look at the complete wavefunction instead of invidual branches of time
07:40:30 <gressvol-> zygoloid: you are correct I removed the lambda expression
07:41:33 <zygoloid> gressvol-: that code confirms my guess. suppose solve' picks a non-solution, then recursively calls itself. suppose it then lands in the third case.
07:41:40 <BONUS> CptPicard: you can do that with UndecidableInstances, I think
07:41:58 <BONUS> instance Class a where ...
07:42:07 <BONUS> although i'm not sure
07:42:10 <zygoloid> gressvol-: since none of the guesses the third case makes are correct, each of them will eventually return Nothing (if they don't bottom out) and you'll filter out all elements of the list
07:42:16 <zygoloid> @type catMaybes
07:42:18 <lambdabot> forall a. [Maybe a] -> [a]
07:42:19 <CptPicard> let's see
07:42:30 <zygoloid> @type mconcat :: [Maybe a] -> Maybe a
07:42:31 <lambdabot>     Could not deduce (Monoid a) from the context ()
07:42:32 <lambdabot>       arising from a use of `mconcat' at <interactive>:1:0-6
07:42:32 <lambdabot>     Possible fix:
07:42:38 <HugoDaniel> still nothing, i installed the icu lib, and it still breaks with linking errors :/
07:42:50 <zygoloid> @type listToMaybe . catMaybes
07:42:52 <lambdabot> forall a. [Maybe a] -> Maybe a
07:43:31 <zygoloid> gressvol-: you could use (listToMaybe . catMaybes) instead of head, or you could use (getFirst . mconcat . map First)
07:43:36 <Rotaerk> meowbe
07:43:37 <Cale> CptPicard: It gets weird, because when GHC is compiling a module, it's never quite certain that it knows about all the instances which will eventually be available.
07:43:37 <zygoloid> @hoogle First a -> Maybe a
07:43:38 <lambdabot> Data.Monoid getFirst :: First a -> Maybe a
07:43:39 <lambdabot> Prelude Just :: a -> Maybe a
07:43:39 <lambdabot> Data.Maybe Just :: a -> Maybe a
07:44:09 <zygoloid> gressvol-: or you could use (join . listToMaybe)
07:44:12 <Cale> CptPicard: and there are some flags to make it less careful about instance selection, but they can end up doing strange things.
07:44:35 <BONUS> yeah, using UndecidableInstances is generally not recommended
07:45:21 <gressvol-> zygoloid: okey will try
07:46:17 <CptPicard> ok, just got curious as to how to "identify" types like this, and "if it's something else, then.."
07:46:26 <gressvol-> Okey, It seems as I have entered an infinite loop now
07:47:29 <Twey> What is a First?  I haven't seen that before.
07:47:55 <holmak> Question: suppose i have a list, and i want to apply a function to each element, but i want to get back a list of lists, where one element is changed in each
07:48:08 <holmak> mapEach :: (a -> b) -> [a] -> [[b]]
07:48:11 <Cale> Twey: It's a newtype of Maybe for which the monoid instance selects the first non-Nothing value
07:48:15 <Twey> Ah
07:48:35 <holmak> as if i were perturbing one element at a time
07:48:45 <Cale> holmak: That type is inappropriate
07:48:55 <holmak> could be
07:48:58 <Cale> holmak: because where are the rest of the elements of type b coming from?
07:49:01 <holmak> that may be my problem
07:49:11 <holmak> all right, they should all be a's, then
07:49:12 <koeien371> map :: (a -> a) -> [a] -> [[a]] is better
07:49:13 <Twey> holmak: So, for example, mapEach (+ 2) [1 .. 3] yields [[3, 2, 3], [1, 4, 3], [1, 2, 5]]?
07:49:25 <holmak> exactly
07:49:55 <Twey> Hm
07:50:02 <holmak> its kind of like scan, but not
07:50:09 <holmak> thats what i thought of at first, anyway
07:50:14 <Cale> I might just write it recursively.
07:50:22 <Twey> Looks like a fold to me.
07:50:32 <Twey> Oh gods, I'm turning into vixie
07:50:37 <holmak> haha, everything is a fold, that doesn't help!
07:50:41 <Twey> Haha
07:50:41 <Cale> Yeah, it's a foldr, but not a particularly easy one
07:50:45 <Twey> Yeah, true
07:52:08 <HugoDaniel> grrr
07:52:20 <HugoDaniel> has anyone managed to install and use the text-icu bindings ?
07:52:20 <holmak> maybe something with inits...
07:52:24 <koeien371> > let mapEach _ [] = []; mapEach f (x:xs) = (f x:xs) : map (x:) (mapEach f xs) in mapEach (+2) [1..3]
07:52:25 <lambdabot>   [[3,2,3],[1,4,3],[1,2,5]]
07:52:30 <HugoDaniel> im having some problems using it on arch linux
07:52:33 <Twey> Ooh, beaten
07:52:48 <Twey> Nicer than what I was doing, too.
07:53:02 <fasta> Isn't it just iterate with take?
07:53:03 <Cale> hmm... *is* it a foldr?
07:53:03 <HugoDaniel> i have installed the icu package from pacman, and tried both the text-icu from cabal, aur, and from source... no linking with the icu
07:53:05 <HugoDaniel> :(
07:53:29 <Cale> You need xs there, so it's not looking good.
07:53:45 <Twey> Cale: It is with a tuple of (prefix, rest, counter)
07:54:15 <zygoloid> > let mapEach f = tail . foldr (\a (as:ass) -> (a:as):(f a:as):map (a:) ass) [[]] in mapEach (+1) [1,2,3]
07:54:17 <lambdabot>   [[2,2,3],[1,3,3],[1,2,4]]
07:54:39 <HugoDaniel> help!! :)
07:54:41 <Cale> Yeah, if you can stick stuff on the end, or I suppose you could work with continuations and apply it to some more parameters to prune off the extra junk :)
07:54:44 <Twey> 's the one
07:54:45 <zygoloid> it might not be, but the function which returns xs:mapEach f xs /is/ a fold
07:55:15 <zygoloid> plus, any excuse to use a variable called 'ass', right? ;-)
07:55:21 <Twey> Heh
07:55:22 <koeien371> heh
07:55:31 <Twey> Everybody loves donkeys!
07:55:40 <holmak> you guys are champs
07:55:46 <holmak> i was stuck on that one
07:56:12 <koeien371> although in this case i think explicit recursion is more transparent
07:56:17 <Twey> I concur
07:56:57 <zygoloid> using [[x]] when one means ([x], [[x]]) is pretty nasty ;-)
07:58:16 <Twey> > listToTuple [a, b] = (a, b)
07:58:17 <lambdabot>   <no location info>: parse error on input `='
07:58:17 <Twey> :√æ
07:58:17 <holmak> now that i read koeien371's, it seems so straightforward...
07:59:47 <Cale> > let mapEach f xs = foldr (\a k (as:ass) -> k ((a:as):(f a:as):map (a:) ass)) tail xs [[]] in mapEach (*10) [1,2,3]
07:59:48 <lambdabot>   [[30,2,1],[3,20,1],[3,2,10]]
08:00:45 <Cale> We can move the post-processing step around at least so the thing starts with foldr :)
08:00:47 <koeien371> ah. nice.
08:00:56 <koeien371> for some warped sense of "nice" ;)
08:03:29 <EvanCarroll> http://www.haskell.org/tutorial/numbers.html
08:03:32 <EvanCarroll> that is a great tutorial
08:03:52 <EvanCarroll> exactly what i was looking for last night, someone linked it, and i put it on my list of things to read
08:06:21 <zygoloid> > let mapEach f = init . uncurry (zipWith (\a (b:bs) -> a++f b:bs)) . (inits &&& tails) in mapEach (+1) [1,2,3]
08:06:23 <lambdabot>   [[2,2,3],[1,3,3],[1,2,4]]
08:06:44 <koeien371> oh god i love #haskell :)
08:08:03 <jmcarthur_work> @pl \f xs -> foldr (\a k (as:ass) -> k ((a:as):(f a:as):map (a:) ass)) tail xs [[]]
08:08:06 <lambdabot> flip flip [[]] . flip foldr tail . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .) . flip ((.) . (.))) .) . ap (ap . (((.) . (:)) .) . (:)) . (`ap` (map . (:))) . ((flip . ((
08:08:06 <lambdabot> (.) . (:)) .) . (:)) .)
08:08:10 <jmcarthur_work> O_o
08:08:39 <zygoloid> @pl mapEach f = init . liftA2 (zipWith (\a (b:bs) -> a++f b:bs)) inits tails
08:08:40 <lambdabot> mapEach = (init .) . flip (flip liftA2 inits . zipWith . flip flip tail . (ap .) . flip flip head . ((.) .) . flip ((.) . (.) . (++)) . ((:) .)) tails
08:08:43 <holmak> what have you done?!
08:08:49 <nlogax> *head asplodes*
08:09:09 <zygoloid> > let mapEach = (init .) . flip (flip liftA2 inits . zipWith . flip flip tail . (ap .) . flip flip head . ((.) .) . flip ((.) . (.) . (++)) . ((:) .)) tails in mapEach (+1) [1,2,3]
08:09:11 <lambdabot>   [[2,2,3],[1,3,3],[1,2,4]]
08:09:26 <Cale> > let mapEach f xs = [[if k == n then f x else x | (k,x) <- zip [0..] xs] | (n,y) <- zip [0..] xs] in mapEach (*10) [1,2,3]
08:09:27 <lambdabot>   [[10,2,3],[1,20,3],[1,2,30]]
08:09:30 <jmcarthur_work> i have a personal preference for point free code because in my experience if pointed code doesn't translate to point free code well it probably means there is a good refactoring opportunity
08:10:02 <zygoloid> flip flip head, flip flip tail... lambdabot is tossing coins?
08:10:11 <jmcarthur_work> :t flip flip
08:10:13 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
08:10:31 <zygoloid> #ty flip flip head
08:10:33 <lunabot>  forall a1 c a . (a -> ([] a1 -> a1) -> c) -> a -> c
08:11:17 <holmak> I have to oppose this particular pointfree version on principle
08:11:45 <ben> @type iterate flip
08:11:45 <jmcarthur_work> holmak, i would consider this a case of not translating very well without some refactoring or additional combinators
08:11:45 <lambdabot> forall b c. (b -> b -> c) -> [b -> b -> c]
08:11:52 <Cale> There's my extra-pointy indexed version :)
08:12:57 <Cale> @undo [[if k == n then f x else x | (k,x) <- zip [0..] xs] | (n,y) <- zip [0..] xs]
08:12:58 <lambdabot> concatMap (\ (n, y) -> [concatMap (\ (k, x) -> [if k == n then f x else x]) zip [0 ..] xs]) zip [0 ..] xs
08:13:22 <Cale> That looks incorrect...
08:13:38 <Cale> yep, it's missing some required parens
08:14:15 <Cale> @undo [[if k == n then f x else x | (k,x) <- (zip [0..] xs)] | (n,y) <- (zip [0..] xs)]
08:14:16 <lambdabot> concatMap (\ (n, y) -> [concatMap (\ (k, x) -> [if k == n then f x else x]) (zip [0 ..] xs)]) (zip [0 ..] xs)
08:14:22 <Cale> hehe, that fixed it ;)
08:14:40 <Cale> Clearly, @undo is implemented in perl via a series of regular expressions
08:14:58 <ben> @src @undo
08:14:58 <lambdabot> Source not found. I've seen penguins that can type better than that.
08:14:59 <ben> aw.
08:16:16 <Cale> @pl (\f xs -> concatMap (\ (n, y) -> [concatMap (\ (k, x) -> [if k == n then f x else x]) (zip [0 ..] xs)]) (zip [0 ..] xs))
08:16:19 <lambdabot> flip ap (zip [0..]) . ((=<<) .) . flip flip snd . (ap .) . flip flip fst . (((.) . (const .)) .) . flip flip [] . ((flip . ((:) .)) .) . (. zip [0..]) . flip . ((=<<) .) . flip flip snd . (ap .) .
08:16:19 <lambdabot> flip flip fst . ((.) .) . flip flip [] . (flip .) . ((flip .) .) . ((((:) .) .) .) . flip flip id . (flip .) . ((ap .) .) . flip (flip . ((.) .) . (if' .) . (==))
08:16:19 <lambdabot> optimization suspended, use @pl-resume to continue.
08:16:25 <Cale> ahaha
08:16:53 <koeien371> there should be a program that takes a Haskell program and makes it pointless
08:17:36 <ben> In other languages, people just replace the variable names with gibberish to obfuscate their code! We remove them altogether!
08:17:49 <Twey> Heheh
08:18:17 <Rotaerk> that is scary..
08:18:32 <ben> @src liftM
08:18:32 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:18:55 <ben> @. pl src liftM
08:18:56 <lambdabot> (line 1, column 1):
08:18:56 <lambdabot> unexpected end of input
08:18:56 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
08:18:57 <ben> :<
08:19:19 <ben> @. pl . undo src liftM
08:19:20 <lambdabot> (line 1, column 3):
08:19:20 <lambdabot> unexpected "\n"
08:19:20 <lambdabot> expecting variable, "(", operator or end of input
08:19:21 <Cale> hmm
08:19:32 <Cale> @undo do { x1 <- m1; return (f x1) }
08:19:33 <lambdabot> m1 >>= \ x1 -> return (f x1)
08:19:38 <Cale> @pl m1 >>= \ x1 -> return (f x1)
08:19:39 <lambdabot> f `fmap` m1
08:19:56 <Cale> interesting that it prefers to write fmap infix
08:20:14 <Twey> It assumes that Functor a => Monad a
08:20:17 <koeien371> like ap
08:20:37 <ben> Cale: It is for you to s/`fmap`/./
08:20:47 <Cale> ben: :)
08:20:53 <koeien371> no, that would be pointless
08:21:04 <zygoloid> @@ @pl @undo liftM = do { x <- m; return (f x) }
08:21:06 <lambdabot>  liftM = f `fmap` m
08:21:18 <zygoloid> @@ @pl @undo liftM f m = do { x <- m; return (f x) }
08:21:19 <lambdabot>  liftM = fmap
08:21:30 <EvanCarroll> Integral is a subclass of Enum?
08:21:44 <Twey> Of course
08:22:02 <Twey> It's not very integral if you can't increment/decrement it :√æ
08:22:31 <EvanCarroll> so you can create a type of Enum without explicitly stating what your enumerating over?
08:22:45 <EvanCarroll> you're*
08:23:04 <poe> ?type (fromEnum, toEnum)
08:23:06 <lambdabot> forall a a1. (Enum a, Enum a1) => (a -> Int, Int -> a1)
08:23:24 <Cale> :t toEnum 0
08:23:25 <lambdabot> forall a. (Enum a) => a
08:23:46 * Twey notes that +, -, *, /, ^, ‚Üë‚Üë, &c. can all be defined in terms of succ, repetition, and negative numbers
08:23:56 <holmak> how can i get the cartesian product of a series of lists?
08:23:58 * Twey thinks that mathematics is way more complicated than it needs to be
08:24:03 <Cale> holmak: sequence
08:24:04 <zygoloid> #ty [toEnum 0, 0]
08:24:06 <EvanCarroll> what does double arrow up mean?
08:24:07 <lunabot>  forall a . (Enum a, Num a) => [] a
08:24:13 <poe> > sequence [[1..3],[4..6]]
08:24:13 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
08:24:14 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
08:24:14 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
08:24:15 <Twey> EvanCarroll: Tetration
08:24:19 <holmak> ah, the list monad, i should have known
08:24:21 <holmak> thanks
08:24:54 <ben> obligatory ‚Üë ‚Üë ‚Üì ‚Üì ‚Üê ‚Üí ‚Üê ‚Üí B A
08:25:24 <Twey> n^n^n^n ‚â° n ‚Üë‚Üë 4
08:25:24 <fasta> Twey, mathematics is all that is made up.
08:25:35 * koeien371 thought that that was religion ...
08:25:37 <koeien371> confused :(
08:25:41 <Twey> Heheh
08:26:17 <poe> ben B A ?
08:26:21 <fasta> koeien371, you should just interpret it in the right way.
08:26:36 <Cale> All things that we know are made up.
08:26:45 <zygoloid> poe: yellow button, red button?
08:26:50 <Cale> Whether it's a good idea to believe them or not.
08:26:51 <rwx> cale, i'm enjoying awodey a lot! thanks
08:26:57 <Cale> rwx: cool! :)
08:27:22 <poe> zygoloid ah-ha cheat codes.
08:27:39 <zygoloid> @go Konami code
08:27:40 <lambdabot> Maybe you meant: google googleit do
08:27:49 <rwx> in comparison to set theory, i like how it focuses on the relationships between objects, not on the objects themselves (although that's a false dichotomy at some point, i'm sure)
08:27:54 <absentia> xn/me konami codes all his aophone apps
08:28:18 <fasta> @where awodey
08:28:18 <lambdabot> http://www.math.uchicago.edu/~may/VIGRE/VIGRE2009/Awodey.pdf
08:29:00 <koeien371> rwx: that is CT is general
08:29:34 <koeien371> oh that's what you meant probably. nm
08:30:01 * Cale googles for Haskell cheat codes.
08:30:34 <ben> unsafePerformIO to skip the current level
08:31:24 <Twey> I thought Haskell *was* a cheat code
08:31:26 <oteren> category theory is a CS course here
08:31:43 <oteren> instead of math
08:31:51 <Cale> oteren: interesting
08:31:59 <bos> nintendo cheat codes for category theory: adjunct, adjunct, natural transformation, natural transformation, initial algebra, final object, initial algebra, final object, cohomology!
08:32:02 <oteren> i'm doing it next semester :p
08:32:07 <Twey> Hehehe
08:32:33 <Cale> oteren: I highly recommend that Awodey book linked above, btw.
08:32:58 <oteren> yeah, skimming it now
08:33:04 <oteren> *through it
08:33:16 <ben> Can I follow along without a formal training in algebra?
08:33:45 <oteren> looks like discrete math and calculus is what it builds on, from page downing through the first few chapters
08:34:33 <rwx> oteren, where is "here"?
08:34:35 <Cale> ben: It's written in a somewhat traditional mathematical style, but it develops most of the prerequisites internally.
08:35:14 <oteren> university of bergen
08:35:18 <oteren> norway
08:35:25 <rwx> oh nice
08:35:43 <rwx> i get the sense that western european universities do more interesting CS theory work than USA ones
08:35:49 <oteren> the prereq class for the course
08:35:52 <oteren> is a course using haskell
08:35:54 <oteren> :)
08:35:54 <Cale> ben: Of course, the more of the rest of mathematics you pick up, the more that everything in category theory will make sense, because you'll have more and more examples.
08:36:02 <oteren> (which is why i'm in here)
08:36:22 <Cale> A lovely thing about category theory is all the nice connections with topology and order theory and well, everything else :)
08:36:38 <ben> Right
08:36:59 <ben> I should probably not pile stuff on my reading list while failing classes left and right, though :)
08:37:18 <Cale> oteren: I think it would also be really cool to have a course on topology as given by the CS department :)
08:37:44 <rwx> i'm keen on the logic connections with category theory
08:37:48 <Cale> oteren: After all, computability theory is really just topology in disguise :)
08:37:56 <oteren> yeah, this course is angled towards formalizing data
08:37:59 <poe> Cale in what sense?
08:38:05 <oteren> and programming
08:38:13 <rwx> stuff like second order quantification is equivalent to NP problems, or whatever that idea is-- i don't know what that means yet at all and i REALLY want to
08:38:19 <oteren> but its mainly a math course
08:38:28 <Cale> poe: If you take the semidecidable subsets of a datatype, they give a topology on that type.
08:38:37 <oteren> i'm just taking it for fun, i'm majoring in algorithms :)
08:38:40 <Cale> poe: and computable functions are continuous maps
08:39:56 <rwx> cale who/what talks about that? topology & computability
08:40:10 <Cale> One moment, I'll get you a thesis :)
08:40:30 <Cale> http://www.cs.bham.ac.uk/~mhe/papers/entcs87.pdf
08:40:57 <rwx> thanks!
08:41:19 <fasta> Cale, in what sense are computable functions continuous maps?
08:41:22 <poe> What kind of results does it develop?
08:41:43 <rwx> serious question guys: i've never taken a CS course, i studied econ in school (graduated last spring), and i want to get a phd in CS in a few years from a great university. am i screwed?
08:41:44 <Cale> That is, the open subsets of a datatype are the subsets which you can computably test membership in.
08:42:03 <Cale> Well, where your program is allowed to nonterminate when the answer is false :)
08:42:34 <oteren> shouldnt you focus on getting a masters degree first?
08:42:39 <Twey> rwx: No
08:42:50 <oteren> and i'd worry more about lacking the math than the CS courses
08:43:17 <oteren> unless you want to do development CS
08:43:30 <Twey> Most CS courses are pretty low-level.  You'll be fine.  Give it a bit of preparational study and you should breeze through.
08:43:38 <koeien371> look at complexity theory imo
08:44:08 <rwx> oteren, i took the math necessary, although i'd like more (up to a masters level)
08:44:18 <rwx> Twey, thanks
08:44:32 <rwx> koeien, i can read the mit complexity theory final exams and basically know what the question is asking :-)
08:44:38 <oteren> you need discrete math
08:44:45 <oteren> and calculus
08:44:52 <rwx> i took disrete and set theory concurrently (did better in ST, irony)
08:45:00 <oteren> ok, should be ok then
08:45:02 <rwx> my situation is that i LOVE this stuff
08:45:05 <fasta> For a PhD you need to have the motivation for the particular subject some professor is interested in; not what your own interests are.
08:45:19 <Twey> I've never heard of a CS course that involved calculus (except as an entry requirement)
08:45:20 <mercury^> That's not true.
08:45:28 <mercury^> You can write about what you are interested in.
08:45:31 <rwx> but my grades weren't stellar, and i do all my work outside of class
08:45:45 <fasta> mercury^, tell me a university where I can do want whatever I want.
08:45:49 <oteren> Twey: i'd say its useful for basic math understanding
08:45:49 <rwx> i appreciate the tips
08:45:58 <oteren> all degrees should involve calculus in some way ;)
08:46:06 <Cale> Twey: There are some courses on numerical analysis at Waterloo which I haven't taken, but I can imagine needing calculus for.
08:46:07 <rwx> oteren / Twey / fasta / koeien thanks
08:46:16 <Twey> Should, maybe, but if you just want the qualification I doubt it would be necessary
08:46:27 <oteren> if he's going to go to the phd level
08:46:30 <Twey> Cale: Are they required for a CS degree?
08:46:39 <oteren> i'd say basic calculus knowlegde will be more than a little useful :)
08:46:48 <Cale> I think they're elective.
08:46:48 <Twey> Well, yes :√æ
08:46:49 <oteren> you need calculus for your bachelors degree at my uni
08:46:57 <oteren> linear algebra, discrete math and calculus
08:47:05 <koeien371> lin. alg. is very useful everywhere too
08:47:08 <oteren> and preferably a numerical discrete math course
08:47:13 <oteren> but thats optional
08:47:15 <fasta> mercury^, ?
08:47:43 <Cale> At Waterloo, the CS department/school is part of the mathematics faculty, and so all CS students end up taking a fair number of mathematics courses.
08:47:52 <Twey> Nice.
08:48:20 <absentia> why does CS try to turn people into mathematicians who can program?
08:48:30 <koeien371> because CS is not about programming?
08:48:34 <koeien371> but about mathematics?
08:48:40 <oteren> CS is about the mathematics behind programming
08:48:45 <oteren> so that would make perfect sense ;)
08:48:48 <rwx> cale, did you know scott aaronson? his blog gave me a lot of motivation for complexity theory
08:48:55 <copumpkin> damn right
08:49:04 <copumpkin> rwx: I went to a great talk by him a few weeks ago
08:49:11 <Cale> rwx: I don't
08:49:13 <absentia> no, seriously... you don't need a Phd in math.. to program.
08:49:21 <koeien371> absentia: i am dead serious.
08:49:27 <absentia> me too
08:49:27 <koeien371> absentia: CS != programming
08:49:29 <Twey> absentia: And that's not what CS attempts to teach you.
08:49:39 <copumpkin> absentia: of course you don't, but acknowledging and recognizing the math behind much of what you do will help you spot patterns better
08:49:40 <absentia> not once has differential calculus helped me in coding.
08:49:41 <Twey> I think it's generally assumed that anybody taking a CS course can already program.
08:49:49 <fasta> Twey, I disagree.
08:50:00 <absentia> twey: yet another bad assumption.
08:50:20 <fasta> I would say that CS is very much about programming.
08:50:21 <copumpkin> absentia: just wait until you see zippers ;)
08:50:27 <|Jedai|> absentia: That depends a lot on which field you're programming for
08:50:35 <fasta> It might be that you program with oracles sometimes, but it is still programming.
08:50:35 <Twey> Entering a CS course without knowing how to program is kind of like entering a mathematics course without knowing basic arithmetic
08:51:00 <absentia> twey: that's shortsighted.
08:51:06 <dayz> hi
08:51:21 <Twey> absentia: How so?
08:51:21 <oteren> you have to start somewhere Twey
08:51:21 <brx> Twey: not that basic arithmetic is necessary to begin studying math.
08:51:21 <absentia> people go into CS to learn to program.
08:51:22 <oteren> we have introductory java courses here
08:51:25 <Twey> oteren: Yes, but degree level is not the place :√æ
08:51:26 <copumpkin> #haskell-controversy
08:51:27 <lunabot>  luna: A section must be enclosed in parentheses
08:51:37 <Twey> Haha
08:51:39 <mercury^> What is up with that bot?
08:51:40 <|Jedai|> Twey: I disagree as well, first years in CS should introduce programming as well as the fundamental mathematics behind it
08:51:41 <dayz> i'm trying to compile something and i'm getting the error: "Module `Control.Exception' does not export `Exception(IOException)'" i'm using ghc version 6.10.4. does anyone know what's wrong?
08:51:48 <absentia> exactly.
08:51:50 <jfoutz> i think mit assumes zero knowledge of programming.
08:52:08 <Twey> This is very strange to me.
08:52:15 <koeien371> dayz: try Control.OldException instead. The exception handling has changed  from ghc 6.8.x to 6.10.x
08:52:17 <oteren> most first years in CS do exactly that
08:52:22 <oteren> so thats a moot point imo
08:52:51 <oteren> most start off in c++ or java, and expand through courses in other languages or steamrolled paradigm courses
08:52:52 <dayz> koeien371, you mean change the code?
08:52:57 <fasta> oteren, yes, you need it to get accreditation.
08:53:02 <koeien371> dayz: yes.
08:53:03 <oteren> is my general impression from a couple of years of talking to other people on irc about CS studies
08:53:25 <copumpkin> two of the prerequisites for a CS major here (that is, before you can start taking the "real" courses) are a java course and a haskell course (along with a math course or two)
08:53:29 <dayz> koeien371, ok thanks
08:53:38 <absentia> haskell? wtf.  wow.
08:53:44 <tensorpudding> copumpkin: haskell is required?
08:53:47 <copumpkin> yeah, it used to be scheme
08:53:55 <copumpkin> it was a SICP-based course when I did it
08:53:58 <tensorpudding> ah
08:53:59 <copumpkin> but they moved to haskell a couple of years ago
08:54:03 <fasta> Maybe people are confused by what a CS course is.
08:54:04 <copumpkin> (SOE as the book)
08:54:06 <oteren> prereq here is a combined prolog and haskell course
08:54:10 <absentia> nice.  sicp was ok... but... alas... very academic.
08:54:12 <oteren> with some backus-neur tossed into it
08:54:21 <fasta> I define it as anything taught by the CS department.
08:54:29 <oteren> that too
08:54:30 <oteren> hehe
08:54:43 <fasta> absentia, what is academic about SICP?
08:54:52 <tensorpudding> the introductory programming class here teaches Java
08:54:54 <oteren> i think its perfectly acceptable to do a bachelor in CS if you want to become a programmer
08:55:03 <oteren> it just gives you a slightly more theoretic perspective
08:55:12 <tensorpudding> it uses deitel's doorstop of a bok
08:55:14 <tensorpudding> book*
08:55:19 <oteren> and if you want to go the academic way, you're already halfway there
08:55:28 <oteren> compared to the more engineer biased educations
08:57:05 <tensorpudding> there is a desire to make the introductory programming course accessible while also being "useful"
08:57:06 <absentia> fasta:  I'm just more of a practical kind of guy.  not a lot of scheme 'round these days, eh?
08:57:25 <copumpkin> absentia: what's your favorite language for "gettin stuff done"?
08:57:52 <fasta> A programmer creating PHP programs requires a different skill-set from someone who is building the next Captcha cracker.
08:58:26 <copumpkin> fasta: sorry for the unpleasantness the other day, by the way. I was in a funny mood
08:58:29 <fasta> Someone who works on security professionally probably also needs a degree.
08:58:47 <absentia> I'm hoping to make it haskell... but I'm not there yet.  Use to be perl.  then C++.  Now... my "stuff to get done" is pretty much forced to be Objective-C  (altough I could do Objective-C++) -- and, if I work on android... java.  Alhough I don't really consider java much of anything.
08:59:14 <oteren> why not?
08:59:20 <absentia> security was a hobby of mine for a while -- but that whole industry is very very very very very very very very lame.
08:59:38 <oteren> lemme guess: you dont like object.veryVerboseFunctionNamesForAnythingInTheAPI() ?
08:59:49 <dayz> does anyone know where i can find aterm?
09:00:07 <fasta> absentia, what do you mean? Some security stuff in quite interesting.
09:00:18 <fasta> absentia, e.g. using theorem provers to crack banking systems.
09:00:23 <absentia> why not -- me.. java?  well, I can get stuff done with java.. but it's not my first choice.  I wrote some CGIs in java back in the 90s.. nice small programs.. was fast to code in... but the runtime was like 40MB.  lovely.   I don't want to get into a language/religious war ...
09:00:36 <fasta> absentia, did you also read that? I mean, you can do boring stuff in any area.
09:00:46 <oteren> hehe
09:00:48 <oteren> was just curious
09:00:59 <absentia> ot:  well, I use to be tcsh/emacs/gcc ... now, with the iPhone, I tend to just use xcode.. and the length of selector names doesn't bother me.
09:01:00 <oteren> there is almost a fanatical fervor towards hating java in a lot of people
09:01:08 <oteren> i find it amusing :)
09:01:18 <copumpkin> java the language is rather ugly, a bit like frankenstein's monster
09:01:31 <oteren> because of the verbosity?
09:01:32 <copumpkin> clojure and scala don't look bad, although the latter feels rather hodgepodge too
09:01:45 <absentia> fasta:  no, more practical.   attempting to "secure" unix machines.. networks... etc.
09:01:59 <fasta> absentia, right, that stuff is boring.
09:02:10 <absentia> I looked at scala... weee... unicode variable names!  that'll help readability.. when you try to print that out.
09:02:19 <fasta> Imho, computers should be secure by default, like OpenBSD.
09:02:29 <oteren> that was a question for you btw copumpkin
09:02:35 <absentia> fasta: exactly.. and the math behind breaking encryption is far far far more boring (*TO* *ME*)
09:03:08 <absentia> secure... security.. is relative... anyway.
09:03:28 <oteren> nothing is more secure than the monkey behind the keyboard
09:03:38 <absentia> but this is neither here nor there for haskell.  I am here for haskell  (but not math)
09:03:41 <copumpkin> oteren: the ad-hoc way generics were thrown in (behaving strangely once you try to do anything interesting with them), the ugly autoboxing stuff & the common use of both boxed and unboxed types I guess
09:04:21 <m0nkfish> is it pronounced moenad or monnad
09:04:47 <tromp__> moe
09:05:00 <fasta> absentia, good security requires a military.
09:05:10 <tromp__> as in moped
09:05:29 <absentia> fasta:  eh?  you're talkin'bout physical security?
09:05:33 <absentia> c
09:05:48 <fasta> absentia, encryption is used to keep secrets. No secrets with EM-radition.
09:06:01 <fasta> radiation*
09:06:04 <zygoloid> i say mon as in monoid
09:06:11 <oteren> i dont think the autoboxing stuff is so horribad copumpkin
09:06:56 <copumpkin> oteren: I'm just not a fan of the heterogeneous boxed/unboxed situation in the first place, and I think the autoboxing is an ugly hack to make up for it
09:08:13 <copumpkin> but an understandable one
09:08:27 <copumpkin> bad decisions early on + large user base = ugly hacks
09:08:42 <Cale> m0nkfish: The word is a portmanteau of monoid and triad, so I pronounce the mon part like other words with mono- prefixes
09:10:01 <byorgey> Cale: really, that's the etymology of 'monad'?
09:10:15 <zygoloid> Cale: i thought it was from the ancient greek monas ?
09:10:20 <absentia> A large leather suitcase that opens into two hinged compartments?
09:10:35 <byorgey> me too
09:10:37 <zygoloid> Cale: monas meaning "unit" or monadikos meaning "single"
09:10:50 <Cale> zygoloid: That's the philosophical sense of monad, which is something different
09:11:15 <byorgey> ah, fair enough, it's a different word that happens to be spelled the same, eh?
09:11:18 <Cale> yeah
09:12:15 <Lycurgus> it's one common mathematico-philosophical gestalt
09:12:15 <zygoloid> Cale: got a reference for that? wiktionary seems to think they're the same thing
09:13:52 <Cale> hmm, I can't remember exactly where I learned that. A lot of the early works on monads called them triples or triads.
09:14:31 <zygoloid> the CT sense seems to not be in very many dictionaries yet :(
09:15:45 <zygoloid> wiktionary will have to go uncorrected for now then :(
09:15:56 <Cale> I'm going to go look in OED.
09:16:38 <Cale> Nope, they only have the old one
09:16:54 <zygoloid> dictionary.reference.com says /mo'nad/ but doesn't give an etymology
09:17:29 <Twey> Don't use that piece of junk
09:17:44 <Cale> In any case, the naming of CT monads makes no sense if it were meant to refer to the philosophical term.
09:17:47 <roconnor> triples, triads or my favourite: standard construction
09:17:52 <copumpkin> http://www.cs.aau.dk/~uli/Teaching/09/Fall/CatFunc/Mac_Lane-4.pdf has a brief suggestion of that
09:18:00 <copumpkin> even though it doesn't really explicitly say it's a portmanteau of them
09:18:03 <copumpkin> it hints at it
09:18:04 <mercury^> I heard some american professor say /mo'nad/ for the philosophical meaning.
09:18:13 <zygoloid> "Monads have no true causal relation with other monads, but all are perfectly synchronized with each other by God in a preestablished harmony. The objects of the material world are simply appearances of collections of monads."
09:18:14 <rwx> is there a dominant haskell forum ?
09:18:18 <zygoloid> I always suspected as much
09:18:36 <Lycurgus> ur soaking in it
09:18:40 <Twey> It's never /moÀànad/
09:19:02 * CalJohn wants to learn more CT, but needs to get abstract algebra under his belt and a little more mathematical maturity before most of Awodey becomes possible
09:19:02 <Twey> Usually /Ààm…ôunad/, sometimes /Ààm…ínad/
09:19:12 <CalJohn> rwx: the haskell reddit, really
09:19:20 <Twey> dictionary.reference.com thinks that /y/ is a consonant.
09:20:02 <zygoloid> "Each monad is a unique, indestructible, dynamic, soullike entity whose properties are a function of its perceptions and appetites." -- sounds about right to me :)
09:20:24 <Twey> Hehe
09:22:02 <Twey> (notably, English practically never uses /o/ as a vowel outside of diphthongs ‚Äî /…í/ or [American] /…ë/ is used for the ‚Äòshort O‚Äô sound)
09:22:14 <copumpkin> Twey, the resident linguist
09:22:28 <mux> arg, it seems the GHC docs on how to get a source tree are out-of-date, shouldn't one use l
09:22:36 <mux> shouldn't one use darcs --lazy these days?
09:22:42 <mux> even darcs --partial took ages
09:22:56 <Twey> Sorry.  dictionary.com's horrendous mangling of the IPA is a pet peeve of mine.  :√æ
09:23:06 <mercury^> Twey: did you study that "professionally"?
09:23:15 <Twey> No
09:23:22 <Twey> I'm not a linguist.
09:23:52 <mercury^> But a lojbanist.
09:24:45 <Lycurgus> *neo-platonic gestalt
09:24:57 <Twey> Well, yes, but that's a lifestyle choice, not a professional capacity either.  :√æ
09:25:54 <fasta> mercury^, could you please answer my question?
09:26:49 <EvanCarroll> I like mo'nad
09:27:07 <EvanCarroll> kind of sounds like go'nad and that makes me laugh.
09:27:07 <copumpkin> that's how mrs. catster says it
09:29:01 <mercury^> fasta: you pick a topic you are interested in, then you pick a professor that does something close to it, go to his uni and do what you like.
09:29:13 <mercury^> You are never forced to work on anything specific.
09:30:00 <fasta> mercury^, well, I only see professors asking for people within specific EU projects.
09:31:03 <absentia> so you slave away and do a bunch of work .. and the prof takes and gets all the credit?   good plan.
09:31:12 <fasta> mercury^, I don't know about any professor which can just spend 200K on anything he wants to be researched.
09:31:25 <fasta> mercury^, but apparently you come from a different world.
09:31:30 <copumpkin> absentia: it isn't that bad
09:32:26 <allbery_b> am I supposed to care about these "future of Haskell" screeds?
09:32:27 <copumpkin> on bad days disgruntled grad students will describe it that way
09:32:48 <copumpkin> allbery_b: probably not :) but he was invited to haskell-cafe by Simon Marlow so maybe there will be more discussion
09:33:58 <allbery_b> sorry, "meaning of Haskell".  I can't help but read one particular response as "so go elsewhere"
09:34:54 <copumpkin> yeah :P
09:35:05 <Twey> Heheh.
09:35:08 <copumpkin> we seem to be getting lots of monologues recently
09:35:39 <jeff_s_> I can break the monologues trend with a couple of questions! ...
09:35:40 <Twey> EvanCarroll: ‚ÄòGonad‚Äô is also /Àà…°…ô änad/.
09:35:41 <fasta> mercury^, so where are these professors that still support actual research as opposed to industry research carried out at a university?
09:36:00 <jeff_s_> I can compile this function with "let ... in" but not "where", I can't figure out why http://pastebin.com/d5b4eadb4
09:36:24 <Twey> jeff_s_: ‚Äòwhere‚Äôs bind to function definitions, not expressions
09:36:50 <jeff_s_> Huh, I read the same about "let ... in" but I guess that was bad info.
09:37:06 <byorgey> jeff_s_: if you want to use 'where', you should give the lambda a name as well.
09:37:11 <mercury^> fasta: Here in Goettingen one can do actual mathematical research. I don't know of any Phd student being forced to do anything.
09:37:23 <Twey> ‚Äòlet .. in ..‚Äô is an expression.  ‚Äòwhere‚Äô is magic syntax.
09:37:37 <byorgey> jeff_s_: oh, hmm, but then you'd need nested where's which is sort of ugly
09:37:56 <lispy> > let a = 1 in a
09:37:58 <lambdabot>   1
09:37:58 * Twey doesn't mind nested wheres
09:38:07 <jeff_s_> OK so when it works, I'm not sure how to use it or if I'm writing my function the right way. I have a bunch of functions that need to pass around a StdGen for making random numbers, so I figured the State monad would work.
09:38:36 <lispy> jeff_s_: doesn't monad random do this?
09:38:48 <byorgey> jeff_s_: your type looks strange.  I would expect it to be  chooseFrom :: [a] -> RState a
09:39:11 <gbacon> @botsnack
09:39:11 <lunabot>  :o
09:39:12 <lambdabot> :)
09:39:21 <byorgey> jeff_s_: i.e. 'chooseFrom xs' is a State computation which returns an element of xs and updates the StdGen state.
09:39:34 <jeff_s_> Oh see, that's where I get confused. I'm stuck with this notion that StdGen has to appear in chooseFrom's argument list.
09:39:46 <jeff_s_> but I'll try that and see what happens
09:39:55 <Twey> Yeah, the point of the State monad is that it doesn't :√æ
09:40:06 * copumpkin grabs Twey's funny tongue
09:40:22 <Twey> Oyh!
09:40:42 <copumpkin> now you must figure out how to type in such a way that it sounds like someone's holding your tongue
09:40:42 <Twey> 'ass myh 'ung!
09:40:43 <copumpkin> good luck
09:40:50 <copumpkin> lol
09:41:11 <Twey> Ihs prihy eahy
09:41:24 <byorgey> jeff_s_: you shouldn't need 'mapState', just use 'get' to extract the StdGen and 'put' to put back the new StdGen
09:41:30 * copumpkin releases Twey's tongue
09:41:37 <EvanCarroll> Twey: yea it sounds to me more like go'nad
09:41:41 <copumpkin> :t mapState
09:41:42 <lambdabot> forall a s b. ((a, s) -> (b, s)) -> State s a -> State s b
09:41:43 <Twey> All the hard consonants just get turned into ‚Äòh‚Äô.  ;)
09:41:44 <jeff_s_> Thanks, I'm playing with that now with a bit of do-syntax.
09:41:54 <byorgey> jeff_s_: but an even better idea (unless you are doing this specifically to learn about the State monad) is to use MonadRandom
09:42:12 <byorgey> jeff_s_: which defines a monad specifically for carrying around a random generator and gives you a nicer interface to it.
09:42:16 <jeff_s_> I'll try that later. Right now I'm learning :-)
09:42:23 <byorgey> http://hackage.haskell.org/package/MonadRandom
09:42:25 <byorgey> jeff_s_: ok =)
09:42:29 <byorgey> learning is always good =)
09:42:30 <EvanCarroll> kind of like goa'old, except with less 'a', and with nad, rather than old.
09:42:35 <copumpkin> I HATE LEARNING!
09:42:46 <byorgey> @slap copumpkin
09:42:46 <lambdabot> why on earth would I slap copumpkin?
09:42:57 <copumpkin> muahahahaha
09:43:02 <copumpkin> lambdabot agrees
09:43:03 <byorgey> sigh, lambdabot hates learning too
09:43:12 <copumpkin> that's why she forgets quotes and @seen times and so on all the time
09:43:17 <Twey> EvanCarroll: The long ‚Äòo‚Äô sound in English is a diphthong, /…ô ä/ (or /o ä/ or / å ä/, depending on region and so on)
09:43:17 <byorgey> good point.
09:43:25 <copumpkin> @users
09:43:26 <lambdabot> Unknown command, try @list
09:43:34 <copumpkin> she even forgets whole commands!
09:43:48 <Twey> And the stress is on the first syllable in all dialects I know of, though it's possible you're from somewhere very obscure :√æ
09:44:03 <EvanCarroll> teXAS
09:44:11 <copumpkin> teHAS
09:44:19 <Twey> Haha
09:44:38 <Twey> Something like /…°…ëÀànad/ would practically never happen, since the first vowel would generally be reduced if not stressed
09:44:41 <zygoloid> tet'thus?
09:55:39 <copumpkin> Cale: any more hints on that graph 2 -> Set functor?
09:58:51 <Cale> copumpkin: Well... consider the traditional definition of a directed graph with a set of vertices and a set of ordered pairs
09:59:04 <copumpkin> yeah
09:59:50 <gressvol-> Hi, I'm still having the problem with my sudoku solving program:), code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5199#a5201 the program should select all the blanks in a sudoku and for each blank spot try every possible number that can be written in that spot and create a "new" sudoku with 1 less blank spot and then recursivly solve it for the rest of the blank spots. My function does not converge and it gets into an infinite loop,
10:00:30 <copumpkin> well, I'm not sure of whether my traditional definition matches The Traditional Definition. I've typically heard of it as just a set of vertices and a set of unordered/ordered pairs for edge (with some sort of implicit proof I guess that the pairs contain elements from the set of vertices)
10:00:30 <Cale> copumpkin: and then the projection maps on the ordered pairs
10:00:39 <Cale> right
10:00:58 <copumpkin> yeah, those are the source/destination projections you mentioned yesterday
10:01:32 <Cale> So you have some set of vertices, say {1,2,3,4,5}, and some set of ordered pairs, say {(1,2),(1,3),(2,4),(2,5),(3,4),(4,5)}
10:01:40 <copumpkin> yeah
10:02:09 <Cale> Now, suppose we want to make the edges into an abstract set.
10:02:34 <copumpkin> abstract set in what sense? just removing the "names" and leaving some sort of abstract concept of identity?
10:02:40 <Cale> So we won't be able to use ordered pairs, but what we can do instead is to encode the source and target of each as a function
10:02:45 <Cale> yeah
10:02:52 <Cale> a bag of points, essentially :)
10:03:06 <copumpkin> ok
10:03:13 <gemie> the same you do like !!1 can you write so it takes all except 1?
10:03:38 <koeien371> \ (x:_:xs) -> x:xs
10:04:01 <Cale> copumpkin: So I'm going to label my edges there
10:04:24 <Cale> {a=(1,2),b=(1,3),c=(2,4),d=(2,5),e=(3,4),f=(4,5)}
10:04:35 <copumpkin> yeah
10:04:54 <Cale> So that we'll be able to "forget" the original ordered pairs and just consider the arbitrary set of 6 values {a,b,c,d,e,f}
10:04:59 <copumpkin> yeah
10:05:10 <Cale> and now we'll define two functions: s and t
10:05:17 <copumpkin> and you can say s(a) = s(b)
10:05:22 <copumpkin> and so on
10:05:23 <Cale> s(a) = 1, t(a) = 2
10:05:28 <Cale> and so on, yeah
10:05:43 <sepp2k_> gemie: except i lst = take i lst ++ drop (i+1) lst
10:06:03 <gemie> koeien ok cool. because I have [[a]] and I have a function for replacing an element in the inner list but If I do that then I only get the inner list as a result where I want the [[a]] so I need to make my replace and then lap them together again or something
10:06:04 <Cale> So a pair of arbitrary functions from a set of "edges" to a set of "vertices" is as good as a set of vertices and a set of ordered pairs
10:06:21 <gemie> sepp2k_cool gonna check it up
10:06:53 <copumpkin> Cale: I see. That would suggest Set -> C to me though, rather than C -> Set, but maybe I'm thinking about it backwards
10:07:54 <Cale> Okay, so suppose that C has objects 0 and 1 and has two arrows s and t from 0 to 1
10:08:00 <gemie> sepp2k_ or would you recomand another way of doing it?
10:08:01 <copumpkin> ok
10:08:15 <Cale> Then in C^op they go from 1 to 0
10:08:52 <Cale> (not that this matters all that much, but I'm including that bit of silliness anyway for some reason ;)
10:09:04 <copumpkin> ok :)
10:09:11 <copumpkin> it hasn't detracted from the explanation so far :P
10:09:20 <Cale> and a functor C^op -> Set will assign to 0 some set (of 0-dimensional vertices), and to 1 some set (of 1-dimensional edges)
10:09:40 <copumpkin> oh
10:10:01 <copumpkin> and the morphisms do the obvious thing
10:10:06 <Cale> and to the arrows s,t : 1 -> 0 some functions Fs: F1 -> F0, and Ft: F1 -> F0
10:10:12 <Cale> which are source and target functions
10:10:17 <copumpkin> fair enough :)
10:10:19 <copumpkin> I see it now
10:11:00 * copumpkin feels silly for not seeing it sooner
10:11:10 <Cale> By contrast, a functor Set -> C would try to assign every set to one of the two objects, and every set function to one of the two arrows
10:11:22 <copumpkin> yeah, that would be silly
10:11:25 <Cale> (well, one of the four arrows)
10:12:16 <copumpkin> yeah, but the identity arrows are boring
10:13:30 <Cale> Well, sort of boring, but maybe lots of stuff gets mapped to them anyway
10:13:46 <copumpkin> yeah
10:14:52 <copumpkin> well thanks for that :) it was a lot simpler than I thought it would be
10:15:10 <Cale> yeah, it's not so bad
10:15:10 <copumpkin> but I guess there's not much room for complexity in such a small category :P
10:15:27 <copumpkin> what's the 2-vertex 5-edge subobject classifier ddarius mentioned yesterday?
10:15:43 <Cale> I missed that part of the discussion.
10:15:45 <copumpkin> oh
10:16:46 <copumpkin> well, that's all he really said about it
10:16:54 <copumpkin> I guess I'll ask him when he comes back :)
10:16:56 <Cale> copumpkin: So anyway, these functors C^op -> Set are actually really super nice things.
10:17:08 <copumpkin> how so?
10:17:36 <copumpkin> it seems like you could encode many of the "X is an n-tuple such that ..." constructions into such a thing
10:17:57 <copumpkin> obviously with more objects and so on
10:18:07 <Cale> If C is an arbitrary category, the category of functors C^op -> Set, is in some sense the "completion" of C
10:18:43 <copumpkin> completion?
10:18:45 <Cale> You'd have to go a little further and think about what a natural transformation between two such functors is :)
10:19:30 <Cale> But, for instance, no matter how ugly a category C is, C^op -> Set will have all limits, all colimits, in fact, it'll be Cartesian closed...
10:19:42 <copumpkin> interesting
10:19:54 <Cale> and C embeds into it in a natural way
10:20:19 <copumpkin> so the ^op is important?
10:20:29 <Cale> such that each arrow between two objects in the image of C really came from an arrow in C
10:20:42 <Cale> Yeah, the ^op is because...
10:20:54 <Cale> Well, okay, C -> Set is nice on its own
10:21:34 <Cale> but C^op -> Set is natural because if you take any object X in C, then you can send it to the functor Hom(A,X)
10:21:55 <Cale> and then you get all the nice embedding property
10:22:19 <Cale> Hom(-,X) rather
10:23:13 <Cale> That is, the functor which sends an object A to Hom(A,X), and an arrow f: A -> B to the function Hom(B,X) -> Hom(A,X) which takes g: B -> X to g . f: A -> X
10:23:31 <copumpkin> I think I see :)
10:24:49 <Cale> Things work out particularly nicely in this direction because you get a result that the natural transformations from Hom(-,A) to Hom(-,B) are exactly in correspondence with arrows Hom(B,A)
10:25:02 <maciej`> hello
10:25:23 * hackagebot upload: shana 2009.12.1 - treat haskell functions as unix pipes (JinjingWang)
10:25:44 <Cale> and because of that flippyness, taking the opposite category makes things work out
10:26:15 <copumpkin> I see :)
10:26:25 * copumpkin needs to work through some of this on paper
10:26:32 <copumpkin> but I think I get the general idea
10:26:48 <Cale> copumpkin: Read through the part of Awodey's book on Yoneda's lemma :)
10:27:04 <copumpkin> have yet to make it that far :P
10:27:38 <copumpkin> but I'll make an effort to
10:27:55 <Cale> copumpkin: in any case, the nice thing is that if you're in a 'bad' category with not many nice constructions in it, you can embed your category in a much larger one with everything you could possibly imagine, use the constructions in that big category to prove that there are certain arrows between the images of objects in your original category, and those arrows must really have been there
10:28:24 <copumpkin> sounds handy :)
10:28:26 <copumpkin> what's an example of such a bad category?
10:28:36 <maciej`> I have a putStr "|" inside an IO monad which is called multiple times, each call separated by a noticeable time delay. So i'm expecting to see "|" .. delay "|" .. delay .. "|" etc. But i'm seeing a much longer delay and "||||||..." printed all at once. When I use putStrLn instead of putStr it works as expected. It looks like putStr is not printed until a call to putStrLn. Any ideas why?
10:28:50 <Cale> Well, Hask is actually pretty nice, but it doesn't have things like equalisers or coequalisers
10:28:51 <copumpkin> maciej`: line buffering?
10:29:02 <copumpkin> :t hSetBuffering
10:29:03 <lambdabot> Not in scope: `hSetBuffering'
10:29:09 <copumpkin> @hoogle hSetBuffering
10:29:09 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
10:29:18 <maciej`> ha, great, will give it a try!
10:29:21 <maciej`> thanks
10:29:31 <Cale> hSetBuffering stdout NoBuffering
10:30:54 <Cale> (and certainly not all limits or colimits exist in Hask)
10:31:13 <maciej`> hSetBuffering did it, thanks
10:31:15 <copumpkin> yeah
10:31:33 <copumpkin> seems like Agda would make a prettier category
10:31:42 <Cale> Perhaps :)
10:32:04 <jeff_s_> I have a chooseFrom that compiles, but I'm really not sure why I needed "return $ " on line 8. I tried unrolling it into regular notation (with >>= etc) but it just showed how much I really don't know what's going on.
10:32:09 <Cale> If you can do all of Set in Agda by introducing the right axioms, then it might have a lot of things indeed.
10:32:22 <jeff_s_> http://pastebin.com/d7a9d5f95
10:33:00 <copumpkin> Cale: is there something "greater" than Set? how might one deal with universe polymorphism?
10:33:02 <Cale> jeff_s_: you want  let (r,g') = randomR (0, length list - 1) g
10:33:15 <Cale> copumpkin: that's a good point.
10:33:30 <jeff_s_> I've been mucking around in the Control.Monad.State source code, it's quite the jungle.
10:33:40 <Cale> copumpkin: Well, when I say "Set" there, I mean ZFC
10:33:45 <copumpkin> ah
10:33:53 <jeff_s_> "let" inside of "do" notation... ok I think I get that
10:33:57 <Cale> copumpkin: But yeah, talking about the category of categories and such is hard in ZFC.
10:34:25 <Cale> copumpkin: There are a lot of formal details which become a nuisance with really large constructions.
10:34:30 <copumpkin> doesn't ZFC need LEM?
10:34:36 <Cale> Yeah.
10:34:58 <jeff_s_> Cale: thanks that works
10:35:10 <Cale> Well, I don't know how LEM impacts all this.
10:35:22 <Cale> Choice might be important somewhere, I'm not sure.
10:36:10 <Cale> Oh, I guess without choice, you'd still have some limits but they might turn out empty.
10:36:25 <Cale> Like certain infinite products
10:36:52 <Cale> er, hmm
10:37:11 <Cale> no, if they were empty, that would be bad :)
10:39:21 <copumpkin> :)
10:46:37 <gemie> is there a function like If I want to take the 5th element of a list without using drop and take? but with using index insteed
10:46:49 <tromp__> :t (!!)
10:46:50 <lambdabot> forall a. [a] -> Int -> a
10:46:51 <idnar> > [1..] !! 5
10:46:51 <lambdabot>   6
10:46:53 <benmachine> bah, looks like the HTTP library ignores the protocol on redirects
10:46:58 <idnar> > [0..] !! 5
10:46:59 <lambdabot>   5
10:47:07 * benmachine is 302'ing it to https: but it keeps trying http:
10:47:17 <gemie> hm well I already use that
10:47:21 <gemie> i should explain better
10:47:22 <tromp__> you cldnt do it with just take and drop:(
10:47:27 <oteren> g =  \y -> \z -> y (y z)
10:47:31 <benmachine> (you are allowed to 302 across protocols, aren't you?)
10:47:41 <oteren> can someone derive that for me? :p
10:47:50 <oteren> i havent looked at lambda functions before
10:47:55 <gemie> like if I have let x = [[a]] and then I want a specifc element from that i can do like x!!0 to get the first list but then I want to show from a element from that row
10:48:18 <benmachine> :t \y -> \z -> y (y z)
10:48:20 <lambdabot> forall t. (t -> t) -> t -> t
10:48:31 <idnar> can you give an example of a specific [[a]] and the result you're expecting?
10:49:12 <idnar> because I still don't really understand what you mean
10:49:15 <tromp__> > http://en.wikipedia.org/wiki/Special:Search?go=Go&search=0!!0!!0
10:49:17 <lambdabot>   <no location info>: parse error on input `='
10:49:32 <oteren> he's trying to have a matrix array in haskell
10:49:32 <oteren> i think
10:49:33 <absentia> ug
10:49:40 <oteren> and go to position x and then to y
10:49:43 <gemie> let's say [[1,2,3], [2,3,4]] and then I would for example want to get the second inside list and the second element that would be 3
10:49:47 <tromp__> > [ [0] ] !!0 !!0
10:49:49 <lambdabot>   0
10:49:56 <gemie> oh you can have double
10:50:03 <tromp__> triple even
10:50:06 <idnar> > [[1,2,3], [2,3,4]] !! 1
10:50:07 <lambdabot>   [2,3,4]
10:50:09 <idnar> that gives you a list
10:50:11 <tromp__> but quadruple is out
10:50:14 <idnar> so you use !! again to pull an element out of that list
10:50:24 <gemie> oh
10:50:32 <tromp__> no wait, that was monty python
10:50:48 <gemie> haha I have a rather ugly solution but now when I know i can do !! !! twice that makes things alot easier
10:50:53 <gemie> thanks guys!
10:50:56 <gemie> that was really helpful
10:52:39 <poe> ?type \xxs -> xxs !! ?n !! ?m
10:52:40 <lambdabot> forall a. (?m::Int, ?n::Int) => [[a]] -> a
10:55:02 <oteren> benmachine: hmm
10:55:54 <jmcarthur_work> indexing into a list is usually a sign that you are doing something wrong, IMO
11:03:11 <Cale> gemie: anything which uses !! too much is a little bit suspicious
11:03:23 <jeff_s_> So I have a value with type State StdGen Integer in my ghci toplevel, and I want to print the Integer. Is there a simple way to do that or do I need to use something complicated like lift?
11:03:36 <Cale> gemie: Normally we try to avoid any operations on lists which discuss particular elements of the list
11:03:55 <Cale> jeff_s_: There isn't just one integer inside that
11:04:05 <Cale> jeff_s_: You have to run the State computation with a StdGen
11:04:05 <Philonous1> That's what arrays are for
11:04:54 <jeff_s_> Cale: thanks, I suspected maybe that was the case, though I thought I ran it with a StdGen ><
11:05:26 <benmachine> evalState is the usual way to run state thing
11:05:27 <benmachine> s
11:05:43 <benmachine> well, if you only want the value
11:05:57 <PeakerWork> execState if you want only the state, runState if you want both
11:05:58 <Cale> jeff_s_: From your main, you'll write something like:
11:06:23 <Cale> main = do g <- newStdGen; let n = evalState foo g; print n
11:07:06 <ben> PeakerWork: Is that arbitrary or am I supposed to see an inherent connection between exec <-> state, run <-> state,value?
11:07:41 * Twey . o O (‚Ä¶ print . evalState foo g =<< newStdGen ‚Ä¶)
11:07:52 <Twey> s/ g//
11:09:32 <PeakerWork> ben: well, run* or un* usually just unpacks the data constructor, in State's case that is (s -> (s, a)) or StateT's (s -> m (s, a)).  exec/eval are somewhat arbitrary, "eval" associated perhaps with getting a value out of it, and "exec" with just making it execute, but its kind of subjective/loose interpreting :)
11:12:03 <zygoloid> ben: i think of it as: "exec" is somewhat akin to running a state-modifying program. it modifies the state and you ignore the output. like the exec* syscalls.
11:12:15 <ben> Hm
11:12:34 <zygoloid> ben: eval is like evaluating a value; you want the value and don't care about side-effects. like the eval construct in some langyages
11:15:10 <PeakerWork> I like how Python are consistently calling their dicts pairs "items", the keys "keys", and the mapped valued "values".  In Data.Map there's "elems" for pairs, most functions don't really name the part you work on. Of course its not so bad because the type is all you need :)
11:15:59 <jeff_s_> i'm working in ghci, I'm not sure why I'm getting a parsing error on ';' from "do {g <- newStdGen; let n = evalState (chooseFrom [1,2,3] g; print n}"
11:16:19 <zygoloid> jeff_s_: because let starts a block
11:16:21 <Cale> you have an open paren with no close paren
11:16:30 <zygoloid> oh, yeah, what cale said too
11:16:34 <mmorrow> bos: how did you end up doing concat for Text?
11:16:34 <Cale> and yeah, let starts a block, so you need to use layout (sorry!)
11:16:38 <Cale> Or braces
11:16:59 <jeff_s_> ok I got it, thanks! (was "do {g <- newStdGen; let n = evalState (chooseFrom [1,2,3]) g in print n}")
11:16:59 <zygoloid> > do { n <- Just 12; let k = n + 1; return k }
11:17:01 <lambdabot>   <no location info>: parse error on input `}'
11:17:04 <zygoloid> ^^ that's the error i thought you had :)
11:17:08 <PeakerWork> btw: conal's TCM paper (http://conal.net/papers/type-class-morphisms/) establishes a really nice alternative model for Map (partial Map on top of a total TMap). I'd like to see it as an alternative to Data.Map
11:17:24 <zygoloid> > do { n <- Just 12; let {k = n + 1}; return k } -- and how to fix it if you don't want to use layout
11:17:26 <lambdabot>   Just 13
11:17:47 <jeff_s_> oh I see, thanks zygoloid
11:17:49 <Cale> Yeah, the other option is to turn the let statement into a let expression
11:17:57 * zygoloid redirects thanks to Cale
11:18:04 <benmachine> everyone wants to use layout!
11:18:42 <jeff_s_> layout is neat but I like playing with ghci, and I'm not sure how to use layout there (it seems impossible)
11:19:04 <conal> PeakerWork: thx for the Map plug.   i've also spelled out a proposal in http://trac.haskell.org/alt-stdlib/ticket/1
11:19:05 <Philonous1> Just write your definition in a file and load it into ghci
11:19:18 <jeff_s_> I've been doing that too.
11:19:52 <PeakerWork> conal: Is it a plug if its for my own selfish needs of a nicer Map? :-)
11:20:13 <conal> PeakerWork: you bet.  a multi-purpose plug :)
11:21:05 <jmcarthur_work> PeakerWork, conal: and the alt-stdlib project has been moving slowly lately because i have been trying to stay dedicated to a potentially money-making project. i would like to keep some small amount of time for alt-stdlib, but i just need to work out some way to manage my time better
11:21:34 <PeakerWork> jmcarthur_work: did you read the TCM paper?
11:21:46 <mmorrow> conal: couldn't it also be thought of as adjoining an "identity"/"empty" element to the `a' and `b' in (Map a b) ==> (Map (Maybe a) (Maybe b)) (or s/Nothing/mempty/ is it's (at least) a monoid)?
11:21:48 <Cale> conal: It makes things like union strange.
11:21:53 <conal> jmcarthur_work: np.  good luck with your venture!
11:22:11 <jmcarthur_work> PeakerWork, yes. i design many of my APIs by the idea now
11:22:22 <jmcarthur_work> or try to, at least
11:22:33 <mmorrow> so in the case it's at least a monoid, lookup becomes ==>  (\a m -> maybe mempty id . M.lookup a m)
11:23:30 <jeff_s_> I'll figure the haskell way of things eventually, I'm still stuck to my ocaml workflow. For instance, while making modules I feel like it's too tedious because in ocaml the types are separated from the definitions, but in Haskell it looks to me like they all have to be in one place. I'm used to having all the exports written for me, and then I delete the ones I don't want. When a module has say, 100 functions, typing which 50 I wan
11:23:30 <jeff_s_> exported manually would be tedious. Maybe there's an easier way, but I haven't figured it out yet.
11:23:38 <PeakerWork> conal: btw, I forget, did you have the semantic model of Map include a list of keys? I think that would ruin the morphisms, yet you want to be able to implement Map.keys, no?
11:24:18 <bos> mmorrow: i bypassed the fusion system entirely
11:24:26 <conal> PeakerWork: i don't think i did.  maybe a problem.
11:24:36 <bos> mmorrow: it's just a big pile of memcpy goodness now
11:24:42 <mmorrow> bos: hehe
11:24:46 <bos> preflex: seen dcoutts_
11:24:46 <preflex>  dcoutts_ was last seen on #ghc 32 days, 2 hours, 23 minutes and 24 seconds ago, saying: oh, probably using ghc-pkg
11:24:53 <bos> preflex: seen dcoutts
11:24:54 <preflex>  dcoutts was last seen on #ghc 5 hours, 31 minutes and 43 seconds ago, saying: :-)
11:25:19 <phpDeveloper> I am new to Haskell language. can anyone help me out?
11:25:38 <jmcarthur_work> PeakerWork, how does it ruin the TCMs?
11:25:53 <jmcarthur_work> phpDeveloper, just ask
11:25:54 <dqd> phpDeveloper: Sure, what is your problem?
11:26:14 <conal> phpDeveloper: *lots* of info at http://haskell.org
11:26:27 <phpDeveloper> why Haskell was developed? I meant, was it developed for special purpose?
11:27:04 <PeakerWork> jmcarthur_work: well, if the semantic model of   Map k v = TMap k (Monoid.First v)   (then you get all of the instances for Map for free from TMap)  If you have  Map k v = ([k], TMap k (Monoid.First v))  then suddenly,  Map's instances aren't simply those of TMap, but those of a (,)
11:27:13 <jfoutz> phpDeveloper: this might help with that question, http://www.haskell.org/haskellwiki/History_of_Haskell
11:27:25 <phpDeveloper> thanks :)
11:27:26 <mmorrow> conal: oh, reading the ticket that's basically what you're suggesting..
11:27:53 <conal> mmorrow: i think so.
11:27:54 <jmcarthur_work> PeakerWork, i see how we can't write something like (a ‚Üí b) ‚Üí [a], but i'm not so sure that the same limitation must apply just because that's the model
11:28:03 <PeakerWork> jmcarthur_work: and since "fst" and "snd" are not in any type-class, you can't have an abstract type behave exactly like a tuple, while not actually being one. OTOH, you could just have a tuple here, and have your morphisms be those of the tuple, I guess
11:28:27 <jmcarthur_work> PeakerWork, couldn't the keys list be included in the implementation of TMap?
11:28:37 <jmcarthur_work> PeakerWork, it's not a part of the model, just a convenience
11:28:56 <PeakerWork> jmcarthur_work: if its not part of the model, what is the model of the "keys" function?
11:29:08 <jmcarthur_work> PeakerWork, we could try coming up with one
11:29:28 <Paczesiowa> do PackageImports work with 6.10 ?
11:29:32 <PeakerWork> jmcarthur_work: For TMap, I don't think it can be very meaningful
11:29:48 <jmcarthur_work> my point is just that we can still respect the TCMs since it's a separate piece of functionality
11:29:51 <copumpkin> Paczesiowa: yep
11:30:36 <PeakerWork> jmcarthur_work: If we completely ignore the implementation and talk purely about semantics now, how can you define any meaningful semantics for "keys" on TMap?
11:30:36 <jmcarthur_work> maybe conal could help clarify our dispute a bit? i'm not entirely sure who is closer to the ideal
11:30:43 <Paczesiowa> copumpkin: I get parse error on from
11:31:04 <copumpkin> import "moo" Data.Moo ?
11:31:17 * conal reads above ...
11:31:28 <Paczesiowa> copumpkin: import Text.ParserCombinators.Parsec from "parsec-2.1.0.1"
11:31:38 <copumpkin> Paczesiowa: I don't think that's the syntax for it is it?
11:31:43 <PeakerWork> jmcarthur_work: I think you can only define a meaningful "keys" for Map, something like:  [k | forall k. isJust (m k)]
11:31:46 <Paczesiowa> http://hackage.haskell.org/trac/ghc/wiki/PackageImports
11:31:49 * hackagebot upload: mtlx 0.1.2 - Monad transformer library with type indexes,  providing 'free' copies. (MarkSnyder)
11:31:49 <jmcarthur_work> PeakerWork, it's not explained by the TMap model as we have described it already, sure. if we are to stick to the principle that *everything* must be described by TCMs, we have a problem (unless we can come up with something)
11:32:10 <mmorrow> conal: hehe, "priority: major"
11:32:30 <PeakerWork> jmcarthur_work: even if you ignore TCM for a moment -- and simply talk about denotational design -- you still cannot assign a meaning to a "keys" function on TMap, I don't think
11:32:37 <jmcarthur_work> PeakerWork, that's a reasonable specification, i guess not a model though
11:32:43 <conal> mmorrow: oops. maybe i left the default.
11:33:04 <Paczesiowa> copumpkin: ok, your syntax works, but now I get that this is hidden package (it works with -package:/)
11:33:06 <PeakerWork> jmcarthur_work: I think its a valid model - since it only needs to be valid mathematically, not necessarily computationally possible :)
11:33:07 <mmorrow> conal: seems correctly prioritized to me ;)
11:33:13 <jmcarthur_work> PeakerWork, i do not disagree
11:33:20 <copumpkin> Paczesiowa: by the end of that, they explain that the "from" keyword is redundant
11:33:24 <copumpkin> and give a more specific syntax
11:33:49 <copumpkin> Paczesiowa: package imports are still subject to package hiddenness, so you'll need to unhide it using a -package or a .cabal file
11:34:20 <Paczesiowa> copumpkin: why are packages hidden?
11:34:44 <copumpkin> to stop their modules from polluting the flat module namespace, usually
11:34:45 <Paczesiowa> copumpkin: no .cabal, just silly 50 loc app
11:34:54 <PeakerWork> jmcarthur_work, conal: so actually, if we define "keys" on a Map as   [k | forall k. isJust (m k)]   then we don't need to complicate our semantic model:  TMap k (First v)
11:35:23 <copumpkin> if there are two packages that contain Data.Monoid, you'd need to use package imports (nonstandard) or hide one of them to stop getting conflicts
11:36:08 <conal> PeakerWork: makes sense to me, noting that keys is not defined on all TMaps.  just Maybe-valued ones.  also, the fiddly bit about the order of the list of keys.
11:36:08 * FunctorSalad questions the policy of version hard upper bounds
11:36:14 <FunctorSalad> nothing builds with ghc 6.12 :|
11:36:22 <PeakerWork> maybe there wasn't any problem -- though "keys" would not be in any class or a TCM.  I do think Haskell needs a *lot* more type-classes than it has now, and "keys" could be in the class of functions that have an enumerable domain, perhaps
11:36:26 <FunctorSalad> (because of not even trying, due to the bounds)
11:36:38 <FunctorSalad> maybe these should be soft bounds.
11:36:41 <PeakerWork> conal: well, fortunately keys is a set, not an ordered list :)
11:36:42 <jmcarthur_work> PeakerWork, that's the right track, i think!
11:36:50 <conal> PeakerWork: great.
11:36:56 <mmorrow> Peaker: the asymmetry here between "map" in the math sense and Map in this sense is that math maps are usually defined on a particular "type" (for lack of a better english word, but not in the type type sense) of objects, and "type" in haskell (or whatever) doesn't capture this
11:37:28 <PeakerWork> mmorrow: You mean the domain is already captured by the type, which is more precise in math?
11:37:37 <conal> one tricky bit: we can't distinguish between Nothing by default and an explicit Nothing.
11:37:57 <PeakerWork> conal: do we want to?
11:38:01 <FunctorSalad> mmorrow: "Set"? ;)
11:38:05 <mmorrow> PeakerWork: something like that. for instance, a map of groups ==> the inverse image of the identity element is a union of subgroups
11:38:06 <conal> PeakerWork: i hope not.
11:38:26 <mmorrow> (union of subgroups == subgroup == group)
11:38:41 <conal> PeakerWork: i'd start with not being able to, for semantic simplicity.  see how that constraint goes.
11:38:57 <mmorrow> (kernel := inverse image of the identity element (which is also a subgroup))
11:39:28 <Cale> In math, we can use any set as the domain of a function already
11:40:00 <jmcarthur_work> i'm not sure i like keys being tied to Maybe. is there anything more general?
11:40:22 <FunctorSalad> oO ( characterisation of the class of sets that can be described with non-dependent types? )
11:40:31 <gwern> wonder if there's any cool LaTeX markup for Big-O notation
11:41:00 <byorgey> gwern: you mean besides  $O(n^2)$ ?
11:41:12 <gwern> byorgey: does it render special?
11:41:31 <jmcarthur_work> should render at least the way i am used to seeing it, i think
11:41:39 <byorgey> gwern: no.  in what way should it appear special, beyond what LaTeX math mode already does?
11:41:40 <PeakerWork> conal: I suspect there wouldn't be a problem -- if you look at what happens to a Map when you use alter :: (Maybe a -> Maybe a) -> k -> Map k a -> Map k a, for example, the Nothing's you provide "disappear"
11:41:40 <copumpkin> does the big O need to look special?
11:41:42 <gwern> hm, nope, just the usual text
11:41:45 <copumpkin> I've always just used a regular O
11:42:07 <conal> PeakerWork: oh yeah.  a handy way to delete.
11:42:07 <byorgey> CLR use a normal capital O
11:42:11 <gwern> byorgey: I dunno. I just expect every branch of amth to have superspecial cool versions they like to use instead of humdrum ASCII
11:42:14 <FunctorSalad> \mathcal{O}
11:42:18 <gwern> they usually do
11:42:22 <FunctorSalad> looks fancy but I don't know if it's more proper ;)
11:42:30 <byorgey> as does GKP, I think, although I have seen some people use a fancy scripty-O
11:42:52 <gwern> hm \bigoplus looks like the XOR symbol
11:43:08 <BONUS> \mathcal{O} makes that really nice big O
11:43:09 <copumpkin> \mathcal always looks pretentious to me :P
11:43:14 <benmachine> in my maths course we have had three different O meaning three different things they were all apparently indistinguisable
11:43:17 <copumpkin> but I love its L
11:43:24 <PeakerWork> conal: Oh I was actually meaning to talk about mapMaybe :: (a -> Maybe b) -> Map k a -> Map k b (same idea, though)
11:43:30 <FunctorSalad> copumpkin: lol
11:43:31 <FunctorSalad> :)
11:44:04 <conal> PeakerWork: yeah.  i like that type as a general alternative to filtering.  wrote a blog post about that type some while ago.
11:44:12 <copumpkin> \mathfrak!
11:44:13 <copumpkin> :P
11:44:18 <Cale> \mathscr with the mathrsfs package is even more pretentious.
11:44:27 <Cale> Oh, \mathfrak is great :)
11:44:34 <FunctorSalad> pics?
11:44:39 <copumpkin> it's just fraktur
11:44:39 <FunctorSalad> (or ...)
11:44:47 <gwern> huh. that certainly is a fancy O
11:44:47 <monochrom> in my maths course we have had three different juxtapositions meaning three different things they were all apparently indistinguishable.
11:44:56 <Cale> I use \mathfrak{S} for the symmetric group and \mathfrak{A} for the alternating group
11:45:15 <Cale> (even when writing by hand ;)
11:45:23 <FunctorSalad> is that that A that looks like an U? :o
11:45:26 <Cale> yeah
11:45:49 <copumpkin> FunctorSalad: http://snapplr.com/31pg
11:46:24 <FunctorSalad> copumpkin: thx
11:46:33 <gemie> I have a function which test if a value is okey. If I want to test for example 1-5 and for each value that are True for that function I get in a list.
11:46:34 <Cale> I love the Fraktur S. It's such a clever way of writing an S.
11:46:46 <FunctorSalad> hmm I don't like Fraktur much
11:46:59 <copumpkin> lol
11:47:03 <PeakerWork> conal: What type-class can we have for "keys"?  A class of explicitly partial (a -> Maybe b) functions (or those whose model is such) that can tell what they're partial about?  Perhaps something more general (a bijective function would be more elegant and too powerful, for example)
11:47:05 <FunctorSalad> cal isn't bad :)
11:47:09 <copumpkin> fractur S is ridiculous
11:47:28 <ziman> it looks more like an `f'
11:47:30 <ziman> (to me)
11:47:40 <copumpkin> http://en.wikipedia.org/wiki/File:Gebrochene_Schriften.png
11:47:40 <jmcarthur_work> let's see... keys ‚à∑ [a] ‚Üí [Int] ‚Ä¶ keys ‚à∑ Map k a ‚Üí [k] ‚Ä¶ anything else, and could it be written more generally?
11:47:43 <copumpkin> more like a G to me
11:47:55 <Cale> Let's do the top of the S, okay... what next? The bottom! Oops, better get the middle in there.
11:48:07 <jmcarthur_work> and those should actually be Sets, not lists, i think
11:48:09 <FunctorSalad> ziman: the `S'? :o
11:48:27 <jmcarthur_work> or maybe the choice of either for performance reasons, but that's besides the point
11:48:29 <Vulpyne> gemie: filter
11:48:39 <ziman> oh, the capital S
11:48:46 <ziman> FunctorSalad, i meant the `s'
11:48:50 <FunctorSalad> :)
11:49:05 <gemie> Vulpyne hm so like filter myFunctionToTestTrue [1..5] ?
11:49:26 <Vulpyne> gemie: Yep, and that will return only the items from the list where your function returned True.
11:49:41 <gemie> cool thanks =)
11:49:45 <Vulpyne> Sure.
11:50:26 <PeakerWork> jmcarthur_work: would a keys instance for lists be useful?
11:50:40 <jmcarthur_work> probably not, but it might fit whatever model we come up with
11:51:21 <jmcarthur_work> really it should return naturals instead of integers, but we don't have that as a standard type :(
11:51:25 <Cale> keys = zipWith const [0..] ?
11:51:32 <jmcarthur_work> yeah basically
11:51:37 <copumpkin> Oh God: "This may be the last in the series given that Simon Marlow feels that I am being non-sequitur. I on the other hand feel that I am being very much on topic. "
11:51:49 <copumpkin> JaffaCake: so unreasonable of you!
11:51:50 <copumpkin> ;)
11:52:14 <Cale> copumpkin: haha
11:52:37 <Cale> I on the other hand feel that I am being very much on topic. To quote Dune, "They move in mysterious ways."
11:52:56 <PeakerWork> jmcarthur_work: perhaps the class here is Indexable or Subscriptable (for partial maps, as said above), something like:  class Indexable a where { type Key a ; type Value a ; (!) :: Key a -> Maybe (Subscript a) ; keys :: a -> [Key a] }  where [Key a] has an arbitrary order
11:53:17 <PeakerWork> oops, s/Subscript/Value
11:53:45 <jmcarthur_work> PeakerWork, i think what we want is more general. i can foresee situations where we can define (!) but not keys
11:53:54 <jmcarthur_work> err
11:53:56 <jmcarthur_work> not more general
11:54:02 <jmcarthur_work> but (!) can be more general
11:54:40 <jmcarthur_work> actually, maybe that could be ($)  :)
11:55:05 <jmcarthur_work> i meant that smiley to be ;)
11:55:12 <Cale> I was a bit jealous about clojure using application syntax for list and map lookups.
11:55:25 <jmcarthur_work> there is an appeal to it, i have to admit
11:55:47 <KragenSitaker> > 3 + 4
11:55:49 <lambdabot>   7
11:55:53 <KragenSitaker> > pl
11:55:55 <lambdabot>   Not in scope: `pl'
11:56:22 <KragenSitaker> @pl \x y -> x y
11:56:24 <lambdabot> id
11:56:32 <jmcarthur_work> we could write things like ([1,2,3] $ 2) this way!
11:56:55 <PeakerWork> jmcarthur_work: Maybe ($) should be a class method, then it would also have more obvious usefulness :)
11:56:58 <jmcarthur_work> or do something really horrible if normal function application could be overloaded...  ([1,2,3] 2)
11:57:04 <PeakerWork> f $ x = f x   -- true for the function instance
11:57:07 <Cale> and once that's the case, how could you turn down (.) = fmap? :)
11:57:17 <KragenSitaker> @pl \xs -> all (== head xs) xs
11:57:18 <lambdabot> all =<< (==) . head
11:57:31 <jmcarthur_work> PeakerWork, exactly!
11:57:32 <PeakerWork> jmcarthur_work: I really like ($) replacing (!) for Map :)
11:58:00 <koeien371> (!) is partial, ($) is normally isn't
11:58:13 <ben> Partial?
11:58:18 <PeakerWork> koeien371: well, ($) would be defined on a TMap, so it would be total still
11:58:33 <jmcarthur_work> koeien, we are talking about a total (!) anyway
11:58:38 <koeien371> ok, never mind me
11:58:55 <PeakerWork> koeien371: but you're right, it doesn't replace (!) because (!) hides the partiality as a pure exception, rather than a Nothing
11:59:11 <PeakerWork> ($) would replace Map.lookup
11:59:17 <KragenSitaker> hmm, that doesn't work in either Hugs or GHCi
11:59:23 <PeakerWork> @type Data.Map.lookup
11:59:25 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
11:59:32 <PeakerWork> (flipped args, though)
11:59:41 <KragenSitaker> because "No instance for (Monad ((->) [a]))"
11:59:50 <jmcarthur_work> hehe, if we had normal application overloaded we could even have abominations like m "foo" where m ‚à∑ Map String a
12:00:35 <PeakerWork> jmcarthur_work: ok so we can agree on: class Map a where type Domain a ; type Range a ; ($) :: Domain a -> Range a
12:00:39 <jmcarthur_work> the type signatures for that kind of thing would be horrible though :P
12:00:46 <FunctorSalad> jmcarthur_work: why abomination?
12:00:48 <FunctorSalad> coq has it
12:00:55 <PeakerWork> jmcarthur_work: we could swap the syntax for ($) and normal application
12:01:02 <FunctorSalad> (via coercion to funclass)
12:01:18 <PeakerWork> jmcarthur_work: so the more general one is the easy to use one, but you still have the function-instance one
12:01:24 <jmcarthur_work> FunctorSalad, i am not familiar with that trick
12:01:42 <jmcarthur_work> PeakerWork, heh, it would start to get ugly, perhaps
12:02:00 <FunctorSalad> you coluld also do "instance IsString (Map String a -> a)"
12:02:03 <FunctorSalad> and write "foo" m
12:02:04 <FunctorSalad> :D
12:02:17 <jmcarthur_work> okay, *that's* an abomination
12:02:28 <FunctorSalad> hehe
12:02:59 <jmcarthur_work> PeakerWork, but yes, i think we can agree on that class for ($)
12:03:23 <jmcarthur_work> i think maybe that's written out wrong though
12:03:49 <jmcarthur_work> ($) ‚à∑ a ‚Üí Domain a ‚Üí Range a
12:04:01 <KragenSitaker> so what is this about a "(->) a" monad that @pl is using?
12:04:10 <PeakerWork> jmcarthur_work: oops, ya
12:04:11 <jmcarthur_work> KragenSitaker, it's the same as the Reader monad
12:04:34 <PeakerWork> KragenSitaker: if Haskell had type section syntax, that would be spelled (a ->)  which is easier to understand :)
12:04:49 <benmachine> KragenSitaker: return = const; f >>= g = \x -> g (f x) x
12:05:03 <PeakerWork> btw: Why didn't all the value syntax fun (sections, backquotes, operators, etc) apply to types too? Wasn't it pretty clearly useful there too?
12:05:22 <FunctorSalad> operators exist
12:05:29 <FunctorSalad> backquotes too IIRC
12:05:30 <jmcarthur_work> i thought all those applied
12:05:31 <PeakerWork> FunctorSalad: with   LANGUAGE TypeOperators pragma
12:05:35 <KragenSitaker> benmachine: that >>= looks like the S combinator backwards?
12:05:43 <FunctorSalad> @kind Int `Map` Int
12:05:43 <jmcarthur_work> -> is the special one
12:05:45 <lambdabot> Not in scope: type constructor or class `Map'
12:05:49 <FunctorSalad> @kind Int `M.Map` Int
12:05:51 <lambdabot> *
12:06:01 <KragenSitaker> benmachine: does that mean that (=<<) is just the S combinator?
12:06:25 <jmcarthur_work> KragenSitaker, one of many examples of why =<< is my preference
12:06:31 * benmachine shrugs
12:06:43 <FunctorSalad> KragenSitaker: `ap` is the S combinator
12:06:49 <FunctorSalad> for the function monad
12:06:49 <jmcarthur_work> and yeah, that
12:06:57 <KragenSitaker> FunctorSalad: thanks!
12:07:13 <PeakerWork> KragenSitaker: wikipedia says  s :: (a ‚Üí (b ‚Üí c)) ‚Üí ((a ‚Üí b) ‚Üí (a ‚Üí c))
12:07:21 <KragenSitaker> FunctorSalad: (ap) doesn't exist in Hugs?
12:07:21 <PeakerWork> @type (=<<)
12:07:23 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
12:07:24 <jmcarthur_work> in my eagerness to promote =<< i forgot to fact check the claim
12:07:37 <FunctorSalad> KragenSitaker: hmm dunno, in GHC you need to import Control.Monad
12:07:42 <KragenSitaker> sorry, I'm pretty ignorant about this stuff
12:07:50 <PeakerWork> so (=<<) :: (a -> r -> b) -> ((r -> a) -> (r -> b))
12:08:18 <PeakerWork> or (=<<) :: (a -> b -> c) -> ((b -> a) -> (b -> c))
12:08:31 <PeakerWork> KragenSitaker: its quite similar, but the first function is flipped
12:08:42 <FunctorSalad> @type ap
12:08:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:09:42 <PeakerWork> @let argument = flip (.)
12:09:44 <lambdabot>  Defined.
12:09:47 <PeakerWork> @type argument flip (=<<)
12:09:49 <lambdabot> forall a b c. (a -> b -> c) -> (a -> b) -> a -> c
12:09:58 <PeakerWork> KragenSitaker: there's your S combinator :)
12:10:02 <Philonous1> @djinn (a -> b -> c) -> ( a-> b) -> (a->c)
12:10:03 <lambdabot> f a b c = a c (b c)
12:10:04 <KragenSitaker> (=<<) :: (a -> b -> c) -> ((b -> a) -> (b -> c)) ‚àß (ap) :: (a -> b -> c) -> ((a -> c) -> (b -> c))?
12:10:38 <PeakerWork> @type argument (flip . flip) ap
12:10:40 <lambdabot> forall a b c. (b -> a -> c) -> (b -> a) -> b -> c
12:10:44 <aempirei> arrowsabound
12:11:46 <PeakerWork> well it does seem that   argument flip (=<<) == ap
12:11:52 <KragenSitaker> sigh. I am having a hard time keeping track of all of this...
12:13:23 <KragenSitaker> let's see.
12:13:38 <KragenSitaker> @type argument \a b c -> a b a c
12:13:39 <lambdabot> parse error on input `\'
12:13:47 <PeakerWork> @type argument flip (=<<) id
12:13:49 <KragenSitaker> @type argument (\a b c -> a b a c)
12:13:50 <lambdabot> forall b c. ((b -> c) -> b) -> (b -> c) -> c
12:13:51 <lambdabot>     Occurs check: cannot construct the infinite type:
12:13:51 <lambdabot>       t = t2 -> t -> t3 -> t1
12:13:51 <lambdabot>     Probable cause: `a' is applied to too many arguments
12:14:04 <Taejo> > sqrt (1 :+ 0)
12:14:06 <lambdabot>   1.0 :+ 0.0
12:14:16 <Taejo> > sqrt (-1 :+ 0)
12:14:17 <lambdabot>   Precedence parsing error
12:14:17 <lambdabot>      cannot mix prefix `-' [infixl 6] and `Data.Co...
12:14:22 <Taejo> > sqrt (-1) :+ 0
12:14:23 <lambdabot>   NaN :+ 0.0
12:14:26 <PeakerWork> @type (argument flip (=<<) id, ap id)
12:14:28 <lambdabot> forall b c a b1. (((b -> c) -> b) -> (b -> c) -> c, ((a -> b1) -> a) -> (a -> b1) -> b1)
12:14:28 <jmcarthur_work> @type argument (\a b c -> a b $ a c)
12:14:30 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
12:14:30 <Taejo> > sqrt $ (-1) :+ 0
12:14:30 <lambdabot>     Probable cause: `a' is applied to too few arguments
12:14:30 <lambdabot>     In the second argument of `($)', namely `a c'
12:14:31 <lambdabot>   0.0 :+ 1.0
12:14:42 <KragenSitaker> oh
12:14:48 <KragenSitaker> I didn't import your argument
12:14:49 <jmcarthur_work> eh fail anyway
12:15:53 <kolmodin> how do I 'darcs get' ghc without actually pulling all 16000+ patches? there used to be some tarballs with snapshots of the darcs repo, but I can't find it any more
12:16:06 <mmorrow> :o
12:16:29 <mmorrow> i do darcs get --partial, which is more reasonable (but a non-option if you actually need all the patches)
12:16:45 <KragenSitaker> hmm, so I can write (\ m f xs -> m (f xs) xs) all ((==) . head) and get a function with the right type
12:17:09 <KragenSitaker> and which seems to do the right thing
12:17:15 <kolmodin> monochrom: they say I need all patches if I'm going to contribute, because darcs has bugs
12:17:20 <kolmodin> mmorrow: ^^
12:17:26 <mmorrow> kolmodin: :(
12:17:30 <kolmodin> monochrom: sorry, that wasn't for you :)
12:17:33 <PeakerWork> @pl  (\ m f xs -> m (f xs) xs) all ((==) . head)
12:17:34 <mmorrow> heh
12:17:35 <lambdabot> all =<< (==) . head
12:17:41 <KragenSitaker> but I'm still sort of mystified how to write (\ m f xs -> m (f xs) xs) in point-free style using the standard combinators, although I have the feeling that someone gave me the answer above
12:17:44 <jmcarthur_work> what about darcs get --lazy?
12:17:59 <PeakerWork> @type all =<< (==) . head
12:18:01 <lambdabot> forall a. (Eq a) => [a] -> Bool
12:18:26 <KragenSitaker> yeah, you can see from the @pl output that this is the same thing, but I don't know how to get the (->) a monad
12:18:31 <mmorrow> jmcarthur_work: i'm always hesitant to do that in case i end up needing a part of it when i don't have internet
12:18:55 <kolmodin> ah, the tarballs seems to be on the root of darcs.haskell.org
12:18:57 <PeakerWork> KragenSitaker: The (a->) monad passes an input argument ("environment", sometimes its called) to everyone implicitly
12:19:02 <gwern> mmorrow: so install pl
12:19:03 <PeakerWork> KragenSitaker: Do you get the State monad?
12:19:07 <gwern> or lambdabot same thing
12:19:07 <monochrom> (\ m f xs -> m (f xs) xs) is a tough one. Don't feel bad if you don't convert it to pointfree.
12:19:13 <KragenSitaker> PeakerWork: I am not sure
12:19:22 <KragenSitaker> monochrom: this is not about my self-esteem! :)
12:19:27 <mmorrow> gwern: does that give me magic internets?!
12:19:30 <monochrom> @pl (\ m f xs -> m (f xs) xs)
12:19:32 <lambdabot> flip flip id . liftM2
12:19:39 <monochrom> No, I wouldn't use that.
12:19:40 <KragenSitaker> haha
12:19:44 <gwern> mmorrow: lambabot gives you offline pl
12:20:00 <mmorrow> gwern: i've got a pl QuasiQuoter for that ;)
12:20:00 <monochrom> No, I am not talking about self-esteem either in "don't feel bad".
12:20:04 <PeakerWork> KragenSitaker: why did you use: (\ m ... ) all ...   and not simply m=all ?
12:20:13 <KragenSitaker> I'm surprised it doesn't just say (=<<)
12:20:22 <PeakerWork> @pl \f xs -> all (f xs) xs
12:20:24 <lambdabot> (all =<<)
12:20:34 <PeakerWork> @pl \f xs m -> m (f xs) xs
12:20:35 <KragenSitaker> PeakerWork: I was directly translating lambdabot's earlier solution
12:20:35 <lambdabot> (flip . flip id =<<)
12:20:43 <Vulpyne> I wonder if you could do something with arrow operators.
12:21:06 <mmorrow> gwern: oh, i think you meant to say "so install pl" to someone else (i was confused for a second there..)
12:21:27 <PeakerWork> @unpl (=<<)
12:21:29 <lambdabot> (\ b c -> c >>= b)
12:21:36 <KragenSitaker> it's true that (\ f xs -> all (f xs) xs) ((==) . head) works too
12:21:42 <gwern> mmorrow: oh, I see. you were talking about incomplete darcs repos, not making use of pl
12:21:54 <mmorrow> gwern: heh
12:21:55 <KragenSitaker> @pl (\ f xs -> all (f xs) xs)
12:21:56 <lambdabot> (all =<<)
12:22:06 <KragenSitaker> oh, you jsut did that one minute ago
12:22:07 <PeakerWork> KragenSitaker: its the kind of function that you know works if it type-checks :)
12:22:13 <KragenSitaker> PeakerWork: heh
12:22:18 <KragenSitaker> yes
12:22:34 <KragenSitaker> I really love "flip flip id . liftM2"
12:22:54 <jmcarthur_work> :t flip flip id . liftM2
12:22:55 <lambdabot> forall a1 a2 r. (a1 -> a2 -> r) -> (a2 -> a1) -> a2 -> r
12:22:57 <monochrom> It's a limerick
12:23:37 <sproingie> there once was a man from peru
12:23:42 <sproingie> whose limericks stopped at line two
12:24:57 <KragenSitaker> so is there some S-like combinator in the standard prelude?
12:25:02 <KragenSitaker> other than monad instances.
12:25:22 <KragenSitaker> you can write it just as S (flip all) ((==) . head)
12:25:53 <mmorrow> s/S/s/
12:26:10 <KragenSitaker> didn't Church write it as S?
12:26:21 <mmorrow> S in haskell is a type or a data con
12:26:29 <KragenSitaker> well, sure
12:26:46 <mmorrow> and "s" you probably wouldn't want to use..
12:26:51 <KragenSitaker> no, probably not
12:27:10 <mmorrow> dilemma!
12:27:19 <mmorrow> :)
12:27:29 <zygoloid> @type let s = ap in s :: (a -> b -> c) -> (a -> b) -> (a -> c)
12:27:30 <lambdabot> forall a b c. (a -> b -> c) -> (a -> b) -> a -> c
12:27:32 <KragenSitaker> what I really want to use is somethign that already exists ;)
12:27:38 <zygoloid> ^^ like that?
12:27:50 <KragenSitaker> zygoloid: Not in scope: `ap'
12:27:58 <mmorrow> , 'ap
12:27:59 <lunabot>  Control.Monad.ap
12:28:00 <KragenSitaker> (is what I get from GHCi)
12:28:07 <zygoloid> , '(<*>)
12:28:09 <lunabot>  Control.Applicative.<*>
12:28:27 <PeakerWork> @type flip flip
12:28:29 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
12:28:47 <PeakerWork> @type flip flip id
12:28:49 <lambdabot> forall a c a1. (a -> (a1 -> a1) -> c) -> a -> c
12:29:08 <KragenSitaker> yeah, if I import Control.Monad, instead I get, "No instance for (Monad ((->) [a]))"
12:29:28 <zygoloid> you need Control.Monad.Instances too
12:29:38 <zygoloid> or you can use <*> from Control.Applicative
12:29:39 <KragenSitaker> flip and id are both linear, so you can't get to S from them
12:29:45 <mmorrow> someone sneakily re-exports Control.Monad.Instances, but i don't know who
12:30:05 <mmorrow> "someone" := some module
12:30:08 <mauke> C.M.Reader?
12:30:23 <Baughn> Oh, I knew him. He's a great guy.
12:30:39 <KragenSitaker> yeah, that seems to work
12:30:41 <mmorrow> mauke: perhaps
12:31:02 <GrayShade> Does Haskell support corecursive type classes?
12:31:04 <mauke> import M.C.Escher
12:31:08 <KragenSitaker> is there some S-like combinator in the standard prologue?
12:31:08 <PeakerWork> mmorrow: anyone who'd import it re-exports it whether he wants to or not, no?
12:31:20 <mmorrow> Peaker: heh, true
12:31:41 <PeakerWork> KragenSitaker: s/prologue/Prelude
12:31:43 <PeakerWork> @type ap
12:31:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:31:50 <KragenSitaker> PeakerWork: thanks, yes, the Prelude
12:31:58 <KragenSitaker> no wonder nobody understood me
12:32:11 <KragenSitaker> all =<< ((==) . head) works if I import Control.Monad.Instances too
12:32:18 <PeakerWork> KragenSitaker: didn't we establish before that functions' ap was the S combinator?
12:32:45 <KragenSitaker> PeakerWork: yes, I just couldn't previously get it to run
12:32:50 <PeakerWork> @type (flip all) `ap` ((==) . head)
12:32:52 <lambdabot> forall a. (Eq a) => [a] -> Bool
12:32:53 <zygoloid> KragenSitaker: no, i don't think there's an S combinator in the Prelude.
12:32:59 <PeakerWork> @type all =<< ((==) . head)
12:33:00 <KragenSitaker> zygoloid: thanks!
12:33:01 <lambdabot> forall a. (Eq a) => [a] -> Bool
12:33:17 <PeakerWork> zygoloid: ap?
12:33:20 <zygoloid> KragenSitaker: my favourite S is (<*>) in Control.Applicative
12:33:31 <zygoloid> PeakerWork: that's not in the prelude, and the Monad (->) r instance isn't either
12:33:32 <KragenSitaker> zygoloid: why do you like it better?
12:33:46 <PeakerWork> zygoloid: ah, I see
12:33:46 <mmorrow> ap is shorter..
12:33:57 <PeakerWork> mmorrow: `ap` is longer
12:34:08 <zygoloid> KragenSitaker: because (1) it's infix, and (2) it's more general since it requires only Applicative not Monad
12:34:22 <sproingie> <*> makes me lean on the shift key
12:34:33 <mmorrow> Peaker: (<*>) is longer!
12:34:54 <mmorrow> ;)
12:34:59 <KragenSitaker> zygoloid: I think =<< is also infix
12:35:23 <KragenSitaker> as is >>=
12:35:59 <zygoloid> doesn't (=<<) take the arguments in a different order from the normal S combinator?
12:36:15 <mauke> yes, it's flipped
12:37:10 <PeakerWork> the first arg is a flipped func
12:37:16 <zygoloid> it's (b -> a -> c) -> (a -> b) -> (a -> c), so it's (. flip)'d not flipped
12:37:24 <PeakerWork> ap = argument flip (=<<) = S combinator
12:37:35 <PeakerWork> zygoloid: ya
12:38:02 <GNU\colossus> I've got a custom Data Somename = ‚Ä¶ type, and want to make it member of the classes Eq and Ord. I need to redefine some of the functions that are defined for those classes. please, please, pretty please guide me to an understandable tutorial that shows me how to do that.
12:38:21 <mauke> GNU\colossus: data Somename = ... deriving (Eq, Ord)
12:38:22 <mauke> :-)
12:38:27 <zygoloid> it and const are probably still universal, i would guess?
12:38:31 <PeakerWork> GNU\colossus: is this for an assignment or can you just use "deriving" like mauke suggested?
12:38:37 <zygoloid> (it == (=<<) for (->) r monad)
12:38:42 <Taejo> @pl slice im (x :+ y) = im (P3 x y 0)
12:38:43 <lambdabot> (line 1, column 19):
12:38:43 <lambdabot> unexpected "="
12:38:43 <lambdabot> expecting variable, "(", operator or end of input
12:39:09 <GNU\colossus> PeakerWork: the former; I actually need to redefine (at least some of) those functions
12:39:23 <PeakerWork> GNU\colossus: http://learnyouahaskell.com/
12:39:42 <mauke> GNU\colossus: define, not redefine
12:40:02 <mauke> GNU\colossus: instance Eq Somename where (==) = ...
12:40:09 <mauke> GNU\colossus: instance Ord Somename where compare = ...
12:40:24 <mmorrow> @src Maybe (==)
12:40:25 <lambdabot> Source not found. I am sorry.
12:40:41 <mmorrow> Nothing == Nothing = True
12:40:44 <KragenSitaker> @pl \xs -> all (== head xs) xs
12:40:46 <lambdabot> all =<< (==) . head
12:40:46 <mmorrow> Just a == Just b = a == b
12:40:52 <mmorrow> _ == _ = False
12:41:04 <GNU\colossus> mauke, PeakerWork: thanks to both of you
12:41:41 <lispy> (==) = fmap (==)
12:42:14 <lispy> I don't think that actually type checks though
12:42:43 <lispy> :t maybe
12:42:44 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
12:43:05 <KragenSitaker> "it"?
12:43:44 <KragenSitaker> @pl all id [x == head xs | x <- xs]
12:43:45 <lambdabot> and [x == head xs | x <- xs]
12:44:10 <KragenSitaker> oh
12:44:14 <mmorrow> @. undo pl all id [x == head xs | x <- xs]
12:44:14 <lambdabot> and concatMap (\ x -> [x == head xs]) xs
12:44:22 <KragenSitaker> @pl \xs -> all id [x == head xs | x <- xs]
12:44:23 <lambdabot> and . return . (x ==) . ((<-) =<< (| x) . head)
12:44:24 <mmorrow> gah, parens fail
12:44:36 <mmorrow> (@undo)
12:44:46 <lispy> And list comp fail
12:44:49 <lispy> (<-)
12:44:50 <mmorrow> KragenSitaker: heh, @pl fail too
12:44:53 <mmorrow> yeah
12:44:55 <mmorrow> (| x)
12:44:57 <KragenSitaker> yeah, that doesn't look pointless to me!
12:45:06 <lispy> You need an @unlistcomp
12:45:20 <mmorrow> @. pl undo all id [x == head xs | x <- xs]
12:45:21 <lambdabot> and (=<<) (return . (head xs ==)) xs
12:45:27 <KragenSitaker> thanks for all the help everybody!
12:45:27 <zygoloid> @pl \xs -> and $ filter (== head xs) xs
12:45:28 <lambdabot> and . (filter =<< (==) . head)
12:46:05 <mmorrow> @. pl undo \xs -> all id [x == head xs | x <- xs]
12:46:06 <lambdabot> and (=<<) =<< flip flip [] . ((:) .) . (==) . head
12:46:20 <zygoloid> hold on, isn't that function just 'head'?
12:46:31 <mmorrow> at this point i have no idea
12:46:48 <KragenSitaker> haha
12:47:00 <mmorrow> undo also botches parens too, so that may be borked
12:47:17 <gwern> @src fromJust
12:47:18 <lambdabot> fromJust Nothing  = undefined
12:47:18 <lambdabot> fromJust (Just x) = x
12:47:32 <gwern> oh, I was wondering how fromJust didn't make the compile complain >.<
12:47:53 <jmcarthur_work> fromJust is a partial function. it should return a Maybe instead!
12:47:57 <jmcarthur_work> ;)
12:47:59 <zygoloid> \xs -> all id [x == head xs | x <- xs]  ==  (==1) . length . group
12:48:17 <KragenSitaker> oh, I didn't know about group
12:48:19 <gwern> jmcarthur_work: I thought it was using a pragma to hush ghc up or maybe something fancy with typeclasses
12:48:39 <zygoloid> well, not quite; the former can terminate early on infinite lists, the latter cannot
12:48:49 <KragenSitaker> oh, Not in scope: `group'
12:48:50 <zygoloid> though that's a problem caused by length, not group
12:48:52 <jmcarthur_work> gwern, to do what?
12:48:57 <zygoloid> KragenSitaker: Data.List
12:49:16 <gwern> jmcarthur_work: have default values - like a Maybe String would see a Nothing become ""
12:49:22 <jmcarthur_work> ah
12:49:28 <gwern> although I didn't seriously expect that that to be what it did
12:49:35 <jmcarthur_work> that would be nice
12:49:44 <ezyang> Hmm, I wonder when I should genericize "just because I can"
12:49:48 <ezyang> *shouldn't
12:49:52 <KragenSitaker> gwern: maybe it should become a ">>>>>>> YOUR PROGRAM HAS A BUG <<<<<<<\0\0\0"
12:50:15 <Twey> Haha, why the NULs?
12:50:17 <gwern> KragenSitaker: nah. "YOU ARE A FOOL AND WRITE INCORRECT CODE"
12:50:18 <netinho2lol> can someone explain me what scan(r or l) does?
12:50:34 <DrSyzygy> netinho2lol: generalize the way you build 'sum' from '+'.
12:50:37 <DrSyzygy> No wait.
12:50:41 <Twey> netinho2lol: It's like a fold, but it saves the intermediate results.
12:50:42 <jmcarthur_work> :t fromMaybe
12:50:44 <lambdabot> forall a. a -> Maybe a -> a
12:50:44 <DrSyzygy> Do that, and keep intermediates.
12:50:49 <tromp__> it lets you write a funky fibonacci
12:50:53 <Twey> > foldr (+) 0 [1 .. 5]
12:50:54 <lambdabot>   15
12:50:57 <DrSyzygy> > scanl (+) 0 [1..5]
12:50:59 <lambdabot>   [0,1,3,6,10,15]
12:51:04 <Twey> > scanr (+) 0 [1 .. 5]
12:51:05 <zygoloid> netinho2lol: it means 'fold, but show your working' :)
12:51:05 <lambdabot>   [15,14,12,9,5,0]
12:51:11 <KragenSitaker> Twey: to decrease the probability that whatever comes after it will handle the string without complaint :)
12:51:12 <Twey> Basically.  ‚ò∫
12:51:13 <netinho2lol> oh
12:51:13 <jmcarthur_work> class Unital a where unit ‚à∑ a ; fromJust = fromMaybe unit
12:51:19 <Twey> KragenSitaker: Haha.  Nice.
12:51:22 <netinho2lol> like, it saves what you do
12:51:31 <jmcarthur_work> fromJust might be a bad name for that though
12:51:33 <KragenSitaker> netinho2lol: the name comes from APL
12:51:57 <netinho2lol> apl is an old programming language, right?
12:52:02 <KragenSitaker> ancient
12:52:07 <KragenSitaker> netinho2lol: one example of where this is useful is when you want to be able to find the sum of the values inside some region of pixels quickly
12:52:25 <DrSyzygy> netinho2lol: In fact, that's what the name APL comes from: Ancient Programming Language. *nods convincingly*
12:52:32 <mmorrow> gwern, KragenSitaker: i've always like "Segmentation fault" myself
12:52:46 <KragenSitaker> scanl (+) on a row of pixels gives you a "sum table", and subtracting two values in it gives you the sum of all the values in between
12:52:59 <gwern> jmcarthur_work: I suspect Unital overlaps with Monoid or something
12:53:17 <DrSyzygy> Unital looks like just 'pointed type'.
12:53:27 <DrSyzygy> As in type with an explicit member picked out.
12:53:36 <jmcarthur_work> gwern, it's a superclass of monoid
12:53:50 <netinho2lol> KragenSitaker: this is probably useful in a function I'm making
12:53:55 <netinho2lol> still thinking on how to do it
12:54:00 <gwern> DrSyzygy: do we have a standard typeclass for pointed types?
12:54:32 <jmcarthur_work> http://en.wikipedia.org/wiki/Unital
12:54:32 <KragenSitaker> netinho2lol: it makes more sense for this purpose in a vector instead of a linked list though
12:54:32 <mmorrow> , ''Pointed
12:54:34 <lunabot>  Control.Functor.Pointed.Pointed
12:54:39 <mmorrow> , src ''Pointed
12:54:41 <lunabot>  class (Functor f) => Pointed f where
12:54:41 <lunabot>          point :: forall a . a -> f a
12:54:51 <DrSyzygy> Ahhh.
12:55:09 <mmorrow> err, not quite what you're looking for i suppose gwern
12:55:10 <DrSyzygy> jmcarthur_work: But doesn't Monoid already come with a unit?
12:55:11 <KragenSitaker> I actually just read an algorithm this weekend for doing median-filtering using a sort of sum table
12:55:14 <jmcarthur_work> that type class is perhaps too restrictive (laws) for the application i just demonstrated. a more general unit might be jsut as good
12:55:26 <gwern> mmorrow: don't see any unit in there, no
12:55:29 <DrSyzygy> jmcarthur_work: ...
12:55:48 <jmcarthur_work> i think i messed something up
12:55:49 <DrSyzygy> jmcarthur_work: HOW is Monoid too restrictive? And what does this Unital give you that monoid doesn't?
12:55:58 <KragenSitaker> in time constant in the kernel size for sufficiently large rows, proportional only to the number of different pixel values
12:56:00 <mmorrow> jmcarthur_work: yeah, actually do    instance Monoid a => Unital a where unit = mempty   to force unit and mempty to agree on any monoid
12:56:07 <mmorrow> s/actually/I'd actually/
12:56:21 <PeakerWork> a lazy bytestring's chunks have a fixed size? I thought the size could vary
12:57:15 <jmcarthur_work> DrSyzygy, unital was the wrong direction for me to go, but monoid is too restrictive because we dont' actually need to require a binary operation for fromJust
12:57:40 <jmcarthur_work> mmorrow, yeah, you're right
12:57:41 <zygoloid> mmorrow: you want only Monoids to be Unitals? or undecidable instances?
12:57:58 <mmorrow> zygoloid: (that was an instance decl)
12:58:00 <PeakerWork> is it possible to parametrize ByteString over non-Word8 without losing the efficiency involved?
12:58:03 * zygoloid can never remember which instance extension you need for that sort of thing
12:58:10 <DrSyzygy> jmcarthur_work: In that case, I'd be tempted to say that 'unit' is a somewhat misleading term for what you need, since _that_ evokes it's relationship to a binary operation
12:58:16 <DrSyzygy> Hence me talking about it being a pointed type.
12:58:27 <zygoloid> mmorrow: yes, but it doesn't say whatyou wnat it to say
12:58:34 <jmcarthur_work> DrSyzygy, exactly, hence the reason i now think it was the wrong thing for me to suggest
12:58:50 <mmorrow> zygoloid: ah, i wanted to make it so that it's impossible to make a monoid an instance of Unital where unit /= mempty
12:58:57 <DrSyzygy> jmcarthur_work: Basically you're trying to make something like a class Pointed a where point :: a; fromMaybe :: Maybe a -> a
12:59:00 <DrSyzygy> Maybe?
12:59:02 <mmorrow> zygoloid: heh, actually you're right.. sigh
12:59:03 <zygoloid> mmorrow: yeah, i think that's not possible :(
12:59:08 <mmorrow> zygoloid: :((((
12:59:16 <jmcarthur_work> DrSyzygy, that was the original intent
12:59:18 <pastah_rhymez> @type msum
12:59:19 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
12:59:24 <zygoloid> at least, not without some scary-sounding language extension
12:59:39 <pastah_rhymez> > msum [Nothing, Just 1, Just 3, Nothing]
12:59:40 <lambdabot>   Just 1
13:00:01 <mmorrow> zygoloid: i think this goes in the opposite direction that all related extensions do though
13:00:06 <PeakerWork> DrSyzygy: Pointed seems like a Zero class and then it makes sense to take fromMaybe out to be a normal function for all Zero instances?
13:00:35 <mmorrow> zygoloid: it's actually trying to restrict you, whereas all the extension try to *add* things you can do (i think?)
13:00:39 <DrSyzygy> PeakerWork: I don't REALLY think that fromMaybe should belong to 'Pointed', nor that pointed necessarily is the best name for it.
13:00:39 <PeakerWork> oh wait, I didn't read the context, nm
13:00:47 <DrSyzygy> PeakerWork: Or even that it doesn't yet exist. :-D
13:01:08 <DrSyzygy> Basically, with a class PointedType t where point :: t
13:01:27 <zygoloid> mmorrow: right. OverlappingInstances lets you say that, but doesn't stop you giving other instances for types which are Monoid
13:01:36 <PeakerWork> > mconcat [First Nothing, First (Just 1), First (Just 3), First Nothing]
13:01:39 <lambdabot>   First {getFirst = Just 1}
13:01:43 <DrSyzygy> you can write fromMaybe :: PointedType t => Maybe t -> t; fromMaybe Nothing = point; fromMaybe x = fromJust x
13:01:47 <PeakerWork> > mconcat [Last Nothing, Last (Just 1), Last (Just 3), Last Nothing]
13:01:50 <lambdabot>   Last {getLast = Just 3}
13:02:28 <netinho2lol> how do i stop an iterate cycle?
13:02:37 <seanmcl> is there a way to make haddock not generate instance documentation for non-exported types?  Right now for instance, if there is class A in module A, and I have a hidden type B in module B and I have instance A.A B, then in the documentation for module A, the (supposedly hidden) type B shows up.
13:02:37 <Twey> You don't
13:02:51 <Twey> Just ‚Äòtake‚Äô what you need
13:02:59 <zygoloid> mmorrow: i think what you want is 'mempty = unit; class Unital a => Monoid a where mappend :: a -> a -> a'
13:02:59 <Twey> Or, if you need more flexibility, use a fold
13:03:00 <netinho2lol> well
13:03:02 <mmorrow> zygoloid: wait, are you sure this wouldn't work as-is?
13:03:21 <mmorrow> zygoloid: yeah, i wanted to avoid constraning Monoid
13:03:38 <netinho2lol> Twey: I have to store everything until 2 elements are ==
13:04:12 <mmorrow> zygoloid: and also, even then you couldn't enforce that someone doesn't just not do mempty = unit
13:04:12 <zygoloid> mmorrow: 'instance Monoid a => Unital a where unit = mempty; instance Unital [a] where unit = [undefined, undefined]' will be accepted with OverlappingInstances
13:04:20 <jmcarthur_work> a Monoid is a Unital Semigroup
13:04:22 <jmcarthur_work> so there
13:04:45 <Twey> netinho2lol: takeWhile (not . uncurry (==)) . zip
13:04:45 <zygoloid> mmorrow: i think the Right Answer is some form of type class alias mechanism
13:05:12 * copumpkin NEEDS MOAR KNOWLEDGE
13:05:13 <Twey> > takeWhile (not . uncurry (==)) . zip [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]
13:05:14 <lambdabot>   <no location info>: parse error on input `,'
13:05:16 <Twey> Er
13:05:23 <Twey> > takeWhile (not . uncurry (==)) $ zip [1, 2, 3, 4, 5] [5, 4, 3, 2, 1]
13:05:25 <lambdabot>   [(1,5),(2,4)]
13:05:28 <mmorrow> jmcarthur_work: and maybe also some way to say "if a type is an instance of A, then it is *also* and instance of B, and here's how"
13:05:49 <mmorrow> s/jmcarthur_work/zygoloid/
13:05:56 <zygoloid> mmorrow: so you can say 'class Unital a where mempty :: a; class SemiGroup a where mappend :: a -> a -> a; class Monoid a = (Unital a, SemiGroup a)'
13:06:02 <jmcarthur_work> mmorrow, isn't that the class aliases proposal or somesuch?
13:06:12 <netinho2lol> uncurry?
13:06:34 <zygoloid> mmorrow: you can say 'a type is an instance of B iff it is an instance of A' already
13:06:43 * DrSyzygy thinks that using 'Unital' here jars.
13:06:53 <benmachine> superclass defaults are separate from class aliases imo
13:06:53 * zygoloid agrees with the good doctor
13:07:01 <DrSyzygy> Because there are MORE pointed semigroups out there than monoids!!
13:07:05 <mmorrow> zygoloid: i just want one-way implication here though
13:07:05 <benmachine> the class alias proposal had superclass defaults but meh
13:07:08 <jmcarthur_work> oh i was wrong
13:07:13 <jmcarthur_work> a Monoid is a Unital Loop
13:07:16 <DrSyzygy> So strictly, (Unital a, SemiGroup a) shouldn't have to imply Monoid a.
13:07:18 <jmcarthur_work> dangit
13:07:29 <jmcarthur_work> something that is both a Semigroup and a Loop
13:07:31 <benmachine> (superclass defaults is my current favourite thing)
13:07:38 <benmachine> (apaprently unimplemented though)
13:07:44 <benmachine> apap.
13:07:45 <netinho2lol> :t uncurry
13:07:46 <jmcarthur_work> and a Loop is a Unital Quasigroup
13:07:47 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
13:08:04 <jmcarthur_work> okay ignore me forever
13:08:09 <jmcarthur_work> i was right before. i misread wikipedia
13:08:29 <zygoloid> benmachine: the trouble with superclass defaults without aliases is that you can't be sure which instances an 'instance' declaration is defining
13:08:30 <Twey> netinho2lol: uncurry converts a function of two arguments into a function of one argument that is a pair
13:08:33 <Twey> :t uncurry
13:08:34 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
13:08:44 <jmcarthur_work> class (Semigroup a, Unital a) ‚áí Monoid a
13:08:45 <benmachine> zygoloid: isn't that sort of the point
13:08:48 <zygoloid> benmachine: at least, that was the problem with the proposal i saw a while back
13:08:59 <Twey> [read: (a -> b -> c) -> ((a, b) -> c)]
13:09:07 <benmachine> the idea being that you can change how methods are distributed between classes without changing the instances
13:09:27 <benmachine> so long as the inheritance all makes sense
13:09:30 <DrSyzygy> jmcarthur_work: Ouch. You _really_ want to work in non-associative worlds?!?
13:09:33 <zygoloid> benmachine: you need to somehow distinguish between 'i'm defining Monad and i have a separate Applicative instance' and 'i'm defining Monad and I want Applicative too please'
13:09:59 <jmcarthur_work> DrSyzygy, i'm not *wanting* to do anything. this whole thing sparked as a tangent from something that i don't event remember now
13:10:01 <DrSyzygy> jmcarthur_work: Actually, a Monoid is an associative loop. Unitality is already implied in loop.
13:10:03 <benmachine> zygoloid: just... don't define <*> in the Monad instance?
13:10:06 <netinho2lol> Twey: iter f p = [p] ++ takeWhile (not . uncurry (==)) $ (iterate f p) ?
13:10:09 <DrSyzygy> jmcarthur_work: OIC.
13:10:21 <zygoloid> benmachine: you assume my Applicative instance is in the same module
13:10:26 <copumpkin> does anyone know of a nice elegant DPH raytracer?
13:10:27 <jmcarthur_work> DrSyzygy, a Loop requires inverses, so a Monoid needn't be a Loop
13:10:28 <benmachine> no I don't
13:10:36 <DrSyzygy> Point.
13:10:42 <zygoloid> benmachine: then how do i say 'no applicative please'?
13:10:43 <Twey> netinho2lol: What are you trying to do?
13:10:47 <mmorrow> copumpkin: no, but that'd be an awesome thing to see
13:10:48 <DrSyzygy> Associative unital magma. :-D
13:10:57 <opqdonut> :D
13:11:04 <jmcarthur_work> DrSyzygy, that describes a Monoid, yes ;)
13:11:06 <copumpkin> mmorrow: it seems like an ideal application of it, I'm surprised nobody's done it
13:11:14 <benmachine> zygoloid: what do you mean?
13:11:16 <mmorrow> copumpkin: both in terms of being able to see how DPH performs, and as an example of how to use DPH itself
13:11:22 <jmcarthur_work> unital already requires magma though
13:11:25 <mmorrow> copumpkin: do eet!1
13:11:28 <copumpkin> lol
13:11:38 <jmcarthur_work> and "associative"
13:11:41 <mmorrow> copumpkin: the choppah!
13:11:44 <zygoloid> benmachine: how do i give a Monad instance which doesn't generate an Applicative instance, if we use superclass defaults and add an Applicative superclass to Monad?
13:11:50 <copumpkin> mmorrow: the choppah??
13:11:56 <mmorrow> copumpkin: (arnold in predator)
13:11:57 <copumpkin> is that a FMA reference?
13:11:58 <copumpkin> oh
13:12:08 <copumpkin> lol
13:12:12 <DrSyzygy> jmcarthur_work: Saying that you have a Magma, though, really doesn't say very much at all.
13:12:18 <jmcarthur_work> i guess associative doesn't require magma
13:12:20 <mmorrow> copumpkin: 2 governators in one movie!
13:12:32 <jmcarthur_work> DrSyzygy, indeed
13:12:40 <DrSyzygy> jmcarthur_work: Conventionally it does, but only because you have to have a bin.op. to be associative.
13:12:40 <jmcarthur_work> i'm not sure what point you are trying to make?
13:12:48 <netinho2lol> f is a function that receives a p and deliver a transformation of p (another p) ; basicly my iter function receive that f and a p, then it delivers this lis: first element is p, then the iterations of f with p until the last 2 iterations are equal
13:12:53 <benmachine> zygoloid: only define Monad methods in it
13:12:54 <jmcarthur_work> DrSyzygy, a magma must be total, too
13:12:58 <DrSyzygy> Mainly that these things are so flabby that most of them get algebraically boring to the point of being bizarre. :-)
13:13:05 <jmcarthur_work> agreed
13:13:07 <zygoloid> benmachine: then how /do/ i say i want an applcative instance?
13:13:09 <Baughn> Shouldn't MTL have an ST class to go with its IO class?
13:13:09 <DrSyzygy> Total? As in it really is defined on all inputs?
13:13:20 <benmachine> then the Applicative methods will either take the default definitions from the class, or from any instance in scope
13:13:32 <mmorrow> jmcarthur_work: usually math constructions are "total" a-prori
13:13:36 <benmachine> hmm
13:13:45 <jmcarthur_work> DrSyzygy, the difference between a category and a monoid
13:13:47 <zygoloid> benmachine: that doesn't make sense. either this module defines the Applicative instance or it doesn't.
13:13:56 <DrSyzygy> jmcarthur_work: Ah. Yeah.
13:14:17 <DrSyzygy> jmcarthur_work: Just like mmorrow says, non-totality is also something quite bizarre mathematically.
13:14:29 <benmachine> zygoloid: hmm I guess you're right
13:14:29 <jmcarthur_work> but we have a Category class!
13:14:36 <DrSyzygy> Sure.
13:14:36 <jmcarthur_work> and it's somewhat useful :)
13:14:42 <DrSyzygy> And categories are _Really_ useful.
13:14:57 <zygoloid> benmachine: the nice thing about the class aliases thing is that it says 'instance Num a' is defining instances for these other typeclasses explicitly
13:15:02 <netinho2lol> Twey: basicly it's [p] ++ until the last two elements are equal (iterate f p)
13:15:05 * DrSyzygy points to his own recent research (homological algebra and higher order associativity among other stuff) and recent teaching (category theory). 
13:15:08 <DrSyzygy> I like categories.
13:15:19 <netinho2lol> I'm now going to decompose it in several functions
13:15:37 <jmcarthur_work> me too, but i don't know enough to make arguments about category theory
13:15:38 <benmachine> zygoloid: okay, but can we at least have default implementations for Applicative methods in the monad *class*?
13:15:41 <DrSyzygy> But categorifying well-known Stuff tends to turn bizarre - which in turn tends to make it good stuff for contemporary research.
13:15:50 <jmcarthur_work> heh
13:15:57 <benmachine> and then we can decide how best to do instances
13:16:23 <zygoloid> benmachine: yeah, i think that's sensible.
13:16:54 <zygoloid> benmachine: but there's still the problem of the "Either e" Monad / Applicative instances being incompatible
13:17:09 <zygoloid> (though that's mostly caused by fail) :(
13:17:11 <benmachine> I think that argument can be solved with newtypes
13:18:01 <zygoloid> i think the (Error e) => should only be on the MonadFail instance :)
13:18:25 <zygoloid> (and that fail should be moved into its own typeclass)
13:18:27 <benmachine> that'd also work
13:18:53 <zygoloid> still doesn't quite solve the problem of what <*> does to combine errors
13:19:02 <zygoloid> but as you say, newtypes are handy for that
13:21:06 <mreh> @pl \a -> (>0) f a
13:21:07 <lambdabot> f > 0
13:21:23 <mreh> @pl \a -> (>0) (f a)
13:21:24 <lambdabot> (> 0) . f
13:22:00 <dpratt71> it appears I'm in need of a bit of newbie guidance for haskelldb (actually this is probably more of a general question)...
13:22:26 <dpratt71> ...I installed the Haskell Platform recently (on Windows)...
13:23:06 <dpratt71> ...and I just ran "cabal install haskelldb", which appeared to do a bunch of stuff and complete without errors
13:24:09 <dpratt71> ...now I'm looking for a "dbdirect" utilityn referenced in the haskelldb docs and having trouble identifying something I can "run"
13:24:35 <dpratt71> that's it in a nutshell - any takers? :)
13:26:25 <BONUS> i heard something about mtl being deprecated
13:26:41 <BONUS> i heard there were rumors on the internets
13:26:56 <jmcarthur_work> in favor of transformers?
13:27:06 <Twey> We haets teh mtl
13:27:33 <BONUS> gonna start writing a bit about monad transformers for LYAH now
13:27:43 <ben> :O!
13:27:51 <BONUS> just wondering whether to write about mtl or transformers or what. transformers isn't even in the standard library!
13:28:15 <ben> What about monadlib
13:28:15 <birdiee> If I have a function that I want to check if inputs for another function is okey (where I have another function which tests that and the inputs are integers from 1-5) how can I do that? I have tried with filter like "filter isOkay (myfunction someinputs (map [1..5])) but that only gives me back the result of the function which are valid with the inputs but it's the input 1..5 I want back as a reuslt
13:28:19 <jmcarthur_work> monadLib! nobody uses it even though it rocks. spread the love a bit! ;)
13:28:21 <skorpan`> BONUS: are the interfaces that different?
13:28:34 <BONUS> i don't know honestly i haven't czeched out transformers that much
13:29:28 <jmcarthur_work> my understanding is that transformers is evolutionary, so not too different
13:29:29 * netinho2lol hi5's BONUS
13:29:37 <BONUS> hi5!
13:30:09 <birdiee> BONUS do you have any suggestions for me?
13:30:27 <ben> hmmm monadLib has not updated since august 2008
13:30:41 <BONUS> always brush your teeth in a smooth, circular motion
13:30:58 <birdiee> :)
13:31:38 <skorpan`> people actually do that
13:31:54 <opqdonut> people do weirder stuff
13:31:59 <opqdonut> like program haskell ;)
13:32:38 <mmorrow> or program haskell in a smooth, circular motion!
13:32:38 <netinho2lol> takeWhile (last == last init)
13:32:38 <dpratt71> at the risk of sounding like a jerk, can someone confirm that my recent question about haskelldb actually appears in this channel? often I seem to lose a connection, with no apparent indication, other than lack of activity
13:32:40 <netinho2lol> lol
13:32:43 <BONUS> looking through the transformers documentation now, i can't seem to find anything resembling the MonadTrans class
13:33:11 <mauke> dpratt71: I confirm thee
13:33:18 <dpratt71> mauke: ok, thanks
13:33:31 <ben> BONUS: googling for 'transformers', I cannot either
13:33:31 <poe> birdiee "all predicate list" instead of "filter predicate list" gives you a bool
13:34:45 <dpratt71> what is a ".o" file as it relates to Haskell?
13:34:57 <mauke> object code (result of compilation)
13:35:08 <netinho2lol> like in c
13:35:14 <mauke> I think they're usually called .obj on windows
13:35:16 <BONUS> ah, found it. the interfaces seem similar enough
13:35:41 <BONUS> anyone know where i could find exactly what's different between transformers and mtl?
13:35:42 <dpratt71> mauke: thanks; it would need to be linked before it was any real use, yes?
13:36:39 <mauke> dpratt71: yes
13:37:44 <dpratt71> mauke: ok, that's a clue; thanks again
13:38:42 <abuiles> Hi guys, I'm trying to do implement some code written usign functional dependencies, using type families, but I got an error which I haven't been able to fix, could someone give me a hand with this.. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5202#a5202
13:38:55 <abuiles> thanks  :)
13:39:58 <Twey> 21:38:44 < netinho2lol> takeWhile (last == last init)
13:40:25 <Twey> netinho2lol: Invalid; takeWhile . liftM2 (==) last $ last init)
13:40:29 <Twey> s/\)//
13:41:08 <netinho2lol> :t liftM2
13:41:10 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:41:15 <netinho2lol> :|
13:42:50 <skorpan`> find :: (Cantor -> Bool) -> Cantor
13:42:50 <skorpan`> find = find_i
13:42:57 <skorpan`> taken from: http://math.andrej.com/wp-content/uploads/2007/09/seemingly-impossible.hs
13:43:03 <skorpan`> any particular reason to do so?
13:43:36 <shachaf> skorpan`: I remember that article.
13:43:43 <shachaf> skorpan`: That was *two years* ago?
13:43:50 <skorpan`> here's the full article: http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
13:43:59 <birdiee> If I have a function that I want to check if inputs for another function is okey (where I have another function which tests that and the inputs are integers from 1-5) how can I do that? I have tried with filter like "filter isOkay (myfunction someinputs (map [1..5])) but that only gives me back the result of the function which are valid with the inputs but I want back the inputs (1..5) that where valid.
13:44:07 <skorpan`> uh, never mind my question
13:45:04 <Vulpyne> birdiee: How about mapMaybe?
13:45:22 <poe> skorpan` specialize a function to a type?
13:46:15 <netinho2lol> Twey: something like this? iter f p = [p] ++ (takeWhile . liftM2 (==) last $ last init) iterate f p
13:46:51 <Twey> netinho2lol: Again, what on Earth are you trying to do?
13:47:18 <Vulpyne> birdiee: Your question kind of doesn't make sense to me, actually. Are you trying to apply a function to each item in a list, and only return those items from the list where your function returned True?
13:47:36 <skorpan`> poe: no, he just wanted to stress that there are several implementations and he calls his own find_i
13:48:14 <netinho2lol> Twey: <netinho2lol> f is a function that receives a p and deliver a transformation of p ; basicly my iter function receive that f and a p, then it delivers this list: first element is p, then the iterations of f with p until the last 2 iterations are equal
13:48:23 <birdiee> Vulpyne yes
13:48:33 <Vulpyne> birdiee: That is exactly what filter does.
13:48:35 <Vulpyne> :t filter
13:48:36 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
13:48:50 <Twey> Ah
13:49:43 <Twey> map head . takeWhile ((== 1) . length) . group $ iterate f p
13:49:50 <netinho2lol> :|
13:50:24 <birdiee> Vulpyne yeah you told me before and I tried it out. But for example "filter (isOkay) (thefunctionToTest someInputs) but the last of "someInputs" i want to try between 1..5 and if the thefunctionToTest with someInputs where example 1 was used and it was true I want to return 1 and if 3 and for was valid aswell i want [1,3]
13:50:51 <Twey> > map head . takeWhile ((== 1) . length) . group $ iterate (min 0 . subtract 1) 10
13:50:53 <lambdabot>   [10,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-2...
13:51:01 <Twey> Oops
13:51:04 <Twey> > map head . takeWhile ((== 1) . length) . group $ iterate (max 0 . subtract 1) 10
13:51:08 <lambdabot>   mueval-core: Time limit exceeded
13:51:14 <skorpan`> O_O
13:51:15 <Twey> Hum
13:51:22 <Twey> Well, that idea, anyway
13:51:29 <Ferdirand> filter (isOkay . thefunctionToTest) someInputs ?
13:51:50 <netinho2lol> :t group
13:51:54 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
13:52:04 <Vulpyne> birdiee: "thefunctionToTest" is a function that takes a list called "someInputs". You want to filter that list ("someinputs") using isOkay before passing it to "thefunctionToTest"?
13:52:11 <birdiee> Ferdirand well thefunctionToTest takes more then 1 inputs but I only want to test 1 of them, the last
13:52:42 <Twey> Oh, right.  Yeah.
13:52:50 <birdiee> Vulpyne no, it takes a bunch of stuff but I am only want to try with different for the last, for the others I want the same
13:52:58 <Twey> length traverses the whole list, which is not useful
13:53:09 <Ferdirand> birdiee: you want partial application then ?
13:53:25 <Vulpyne> birdiee: I'm afraid I still don't understand what you are trying to do then.
13:53:37 <Ferdirand> filter (isOkay . theFunction a b c) [d1,d2,...]
13:53:37 <birdiee> so it's more like "filter (isOkay) (functionToTest someinputs) (theInputsIreallyWantToTest) where theInputsI.. will be 1..5
13:53:43 <dfdf> birdee: what are the types of your functions?
13:53:45 <Twey> @let lengthIs 0 [] = True; lengthIs 0 _ = False; lengthIs n (_ : xs) = lengthIs (n - 1) xs
13:53:47 <lambdabot>  Defined.
13:54:06 <Twey> > map head . takeWhile (lengthIs 1) . group $ iterate (max 0 . subtract 1) 10
13:54:08 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
13:54:12 <Twey> There we go
13:54:43 <Twey> Bed for me.  'night!
13:55:24 <netinho2lol> :|
13:55:36 <netinho2lol> you haskell people are like, crazy
13:55:36 <birdiee> Ferdirand hm ok gonna try it out
13:55:43 <netinho2lol> good night Twey!
13:55:46 <netinho2lol> and thanks!
13:56:15 <birdiee> Vulpyne hehe I am so bad to explain. gonna try out what Ferdirand said about the partial application see if It works.
13:56:38 <birdiee> Vulpyne but you are sure right with the filter . maybe if this doesn't work I can make a helper function that don't make it so messy
13:56:48 <Vulpyne> birdiee: Hopefully he understood what you were trying to do. :) If not, try to break down the problem into smaller parts.
13:57:02 <Vulpyne> birdiee: If you show us the types of the functions you are using, it would help.
13:57:37 <birdiee> Vulpyne =) yes gonna try out the thing he did with partial application if it doesn't work I prepare a little better in pastebin and so. thanks alot man
13:57:47 <birdiee> and thanks Ferdirand gonna try it out
13:58:12 <Vulpyne> Sure.
13:58:42 <Vulpyne> hpaste.org is the Haskell paste site, by the way.
13:58:55 <Twey> Also moonpatio.com
13:59:07 <Twey> Oh, hpaste.org runs two now
14:04:29 <birdiee> Ferdirand it worked, thanks =)
14:05:10 <cx> I wonder if there is a function that can check if I have two lists with identical ints but in diffrent index, like [1,2,3], [3,2,1] then it should return true
14:05:22 <aavogt> sort them first
14:05:32 <cx> aah :)
14:05:37 <cx> clever
14:05:38 <cx> thx
14:06:05 <aavogt> no problem
14:06:18 <tensorpudding> this works for any list of any type that is an instance of ord
14:06:44 <aavogt> you could do a terribly inefficient variation that only needs Eq
14:06:44 <holmak> or you could use sets, depending on how you are using the lists elsewhere
14:09:00 <mmorrow> zygoloid, et al: i was thinking about our previous discussion about Unital, Monoid, and the desire to be able to do "If a type T is an instance of class A then it is also an instance of class B, and here's how". what do you think of this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5203 ?
14:09:20 <mmorrow> i think that would work, no?
14:09:25 <osaunders> What is predicate logic for, exactly?
14:10:12 <monochrom> for saying parameterized statements and for "all" and "some" statements.
14:10:15 <tensorpudding> proving things, vaguely
14:10:38 <osaunders> What do people mean when they say proving things?
14:10:44 <osaunders> And "proofs"?
14:10:51 <mauke> deriving stuff from axioms
14:10:57 <monochrom> note that "exactly" is not what you want. almost never.
14:11:09 <tensorpudding> the language of the axioms is best described formally using the predicate calculus
14:11:15 <osaunders> monochrom: Yes. I mean roughly.
14:11:20 <zygoloid> mmorrow: what happens if i also give 'implication Applicative f => Functor f'?
14:11:36 <mauke> .oO( a syntax error )
14:11:48 <mmorrow> zygoloid: how would you define fmap where?
14:12:03 <mreh> I need to test my perceptron
14:12:08 <zygoloid> fmap = liftA1 ;-)
14:12:12 <mreh> how can I do this?
14:12:16 <mmorrow> @src liftA1
14:12:17 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
14:12:20 <zygoloid> i'm imagining a hypothetical world where it's not already asuperclass
14:12:21 <mauke> why, fmap f x = pure f <*> x
14:12:53 <mmorrow> zygoloid: i think a resolution or appropriate restriction for stuff like that would be relatively easy to come up with
14:13:14 <tensorpudding> i've matched wits against a rutabaga once
14:13:15 <mmorrow> zygoloid: but how to phrase that i'm not sure off-hand
14:13:20 <tensorpudding> those things are hard to prepare
14:13:46 <mmorrow> zygoloid: that doesn't seem like an obstacle or a huge problem though to me
14:14:01 <zygoloid> mmorrow: a new top-level keyword seems too much to me for this problem
14:14:24 <aavogt> class implication ...
14:14:37 <mmorrow> zygoloid: i determined, after reading the relevant part of the haskell98 report, that this is explicitly disallowed for instances
14:15:01 <mmorrow> zygoloid: so i figured a new keyword was needed, since this would have to be a new concept
14:15:17 <zenzike> I'm trying to decode a binary file, and so I'm creating a data type that represents it. Some of the fields are 2 bytes long, so I'm using Word16 for those, while others are much bigger, like 80 bytes. I have two questions: 1. should I be using Word16 types for 2 byte values, or am I better off with CUShort types? 2. What is the best way of having an 80 byte long value? Should I just use a list of bytes, and maintain the 80 byte invariant myself, or is th
14:15:19 <zenzike> ere a way of enforcing that in the actual type?
14:15:45 <mauke> zenzike: 1) CUShort has no guaranteed size, so probably not
14:16:02 <zenzike> mauke: thanks, I suspected that would be the case.
14:16:09 <zygoloid> zenzike: what semantics do the 80 bytes have?
14:16:11 <mauke> zenzike: 2) you could use a terrible tuple of 80 Word8's
14:16:13 <mmorrow> zygoloid: (well, it's disallowed that "instance (Foo a) => Bar a" means that "a" is /"automatically"/ (literal quote) an instance of Bar)
14:16:19 <ben> ahaha
14:16:32 <mmorrow> zygoloid: but in addition to this, ghc complains about the instance head being no smaller than something or other
14:16:35 <zenzike> mauke: the 80 bytes represent a string
14:16:36 <benmachine> array of 80 bytes?
14:16:41 <mauke> zenzike: Data.ByteString
14:16:54 <mmorrow> so the algo needed would also need to be a different algorithm than that that instance resolution uses
14:17:01 <zenzike> mauke: but ByteString and arrays don't enforce the 80 byte length do they?
14:17:06 <mauke> zenzike: right
14:17:21 <zygoloid> mmorrow: sounds like a termination condition to me :)
14:17:23 <zenzike> ok. so there's no way of using length restrictions in the type?
14:17:38 <mmorrow> zygoloid: given the instance resolution algorithm, yes
14:17:55 <mmorrow> zygoloid: but you'd use a different algo for "implication"
14:18:32 <ski> mmorrow : that paste sounds quite strange
14:18:39 <dubhrosa_> newb question: can someone explain why something like main = do  let a = take 100000000 $ repeat 5   let s= sum a results in a stack overflow - I understand that because of laziness the implementation of sum must be building up masses of thunks, what I'm asking is whether there is any possible way to detect that and implement "just in time" strictness, rather than blowing up the stack and taking the program out.
14:18:51 <mmorrow> (namely, searching exhaustively the defined instances to determine whether a type T is such that the conditions are met for a particular implication
14:18:59 <ski> mmorrow : why is `D' not mentioned in the explanation of `implication (A a, B (f a) b, C b) => D a where ....' ?
14:19:04 <mauke> dubhrosa_: you could compile with optimizations enabled
14:19:05 <mmorrow> and if so, making that so
14:19:24 <mmorrow> ski: because it is what's being implied
14:19:24 <zygoloid> ski: it is, near the bottom
14:19:26 <benmachine> just-in-time strictness sounds interesting
14:19:29 <benmachine> but also: difficult
14:19:37 <mauke> just-out-of-time laziness :-(
14:19:46 <zygoloid> ski: 'instance D T'
14:19:46 <benmachine> could involve the semantics of your program being dependent on available memory
14:19:48 <benmachine> which would be ew
14:19:56 <benmachine> but I suppose they already are in a sense
14:20:29 <aavogt> benmachine: there was a paper about adding such a thing to ghc... called optimistic evaluation or something like that
14:20:34 <mmorrow> ski: (oh, yeah it's mentioned near the bottom if that's how you meant)
14:21:15 <aavogt> some performance improvements, but supposedly not enough to justify the complexity
14:21:39 <zygoloid> mmorrow: it seems suspect to me that type-class resolution will depend on the set of  suchthings in scope (and not just ina  pass/fail way)
14:22:00 <mmorrow> ski, zygoloid: hmm. you'd need to reject that though (as an artifact of typeclasses) if (in this particular example) there exists /more/ than one such (f,b) pair
14:22:03 <ski> oh .. the indentation suggested to me that the "For *every*" quantification was closed when "The compiler" started
14:22:19 <mmorrow> zygoloid: this could be done after instance resolution i think
14:22:31 <dubhrosa_> right... it just seems like a potentially big problem for any program that is hooked up to data feeds from the real world - i.e. there is a latent crash due to stack exhaustion waiting to happen - can we trust the optimizations to always take care of this?
14:23:22 <mmorrow> zygoloid: oh hmm, yeah you may have to interleave it with instance resolution possibly
14:23:39 <dubhrosa_> and do experienced haskellers generally always compile with -O2?
14:24:04 <mmorrow> zygoloid: would have to pin down exactly the combined algo, but i think there's at least a chance it would work
14:24:12 <ben> According to legend, some of the greatest haskellers compile with -O3
14:24:33 <zygoloid> mmorrow: if i have 'implication (Applicative a, Monoid m) => Monoid (a m)' in file A, and I have 'implication (Monad m) => Monoid (m ())' in file B...
14:25:03 <mmorrow> zygoloid: well, you obviously can't have two inconsistent implications in a program
14:25:05 <dubhrosa_> I heard -O3 was a myth...
14:25:12 <zygoloid> then the meaning of Just () `mappend` Nothing might depend on which module I imported
14:25:17 <zygoloid> mmorrow: what does inconsistent mean?
14:26:11 <zygoloid> ben: haskell old-timers avoid -O3 and above since some optimizations in GHC6.2 or 6.4 were only enabled in -O2 (and no other level)
14:26:19 <mmorrow> zygoloid: (i haven't worked out exactly what your example means in its entirety, but) i just mean you can't have (A and B => C) and (B => C) unless (B => A) as well
14:26:28 <zygoloid> (according to legend)
14:26:29 <ben> zygoloid: Maybe it *is* just a legend!
14:26:59 <ski> mmorrow : well, even if you have `B => A', there's still a choice, no ?
14:27:10 <mauke> ben: only -O0, -O1 and -O2 exist. earlier ghcs didn't check the number after -O, which resulted in -O3 being worse than -O1
14:27:14 <mmorrow> ski: a choice of what?
14:27:55 <mmorrow> (in case this was unclear, i meant the parens to be ((A and B) => C))
14:27:58 <ski> whether to use the `B => C' instance or the `A and B => C' together with the `B => A' instance
14:28:03 <zygoloid> ben: i was laughed at for using -O9. "Why not use -O99, or -O999," they said in scorn. Then i was enlightened, and now use -Oaleph_0
14:28:05 <ski> (those might have different semantics)
14:28:23 <ski> (mmorrow : that's how i parsed it anyway :)
14:28:29 <mmorrow> ok good :)
14:28:29 <sproingie> -OMG
14:28:38 <mmorrow> ski: hmm, thinking about that..
14:28:42 <ben> zygoloid: :D
14:29:16 <ski> it's basically the same problem as `instance Foo Int where foo = 42; instance Foo Int where foo = 17'
14:29:25 <ski> i.e. non-unique instances
14:29:41 <mmorrow> ski: oh, ok. well if (B => A) and (A and B => C), then (B => C)
14:29:55 <ddarius> -O‚Ñµ_0
14:30:10 <mmorrow> ski: so they would have to be consistent, and if the compiler couldn't determine that for whatever reason, it would have to reject the program
14:30:37 <roconnor> -O‚Ñµ‚Çí
14:31:02 <roconnor> damn wrong
14:31:10 <roconnor> -O‚Ñµ‚ÇÄ
14:31:14 <ski> well, it would usually not be able to determine coherence
14:31:17 <roconnor> o vs 0
14:31:21 <stoop> preflex, seen edwardk
14:31:21 <preflex>  edwardk was last seen on #haskell 6 days, 2 hours, 21 minutes and 50 seconds ago, saying: cale: what i currently do is i allow do foo; bar; baz on one line, but in essence with my layout if you break it across multiple lines (and need indentation control) you need to move it down, since i don't know that the width of space, d, and o are the same.
14:31:30 <ski> (unless you plug in a theorem prover)
14:31:30 <sproingie> -Oo.oO
14:32:01 <mmorrow> ski: right, so it would fall on the programmer to ensure the compiler can determine it (or it's trivially so) or the program would be rejected
14:32:33 <ski> so then the choice is whether to try to formalize some not-too-complicated rules into the type system, so that people can determine in their head whether the program will be accepted or not
14:32:58 <mmorrow> ski: right, it'd be interesting to do exactly that
14:32:59 <ski> or to always approximate it as "not coherent" as soon as there's several "paths"
14:33:06 <mmorrow> s/interesting/a prerequisite/
14:33:39 <ski> i'm not convinced the former here is doable in a reasonable way
14:34:01 <ski> (well, reasonable, and not almost trivial)
14:34:06 <cx> aavogt, there?
14:34:14 <ski> one could have the system check aliases, e.g.
14:34:22 <mmorrow> ski: i'm not sure exactly how much leeway you could manage here, but i'd like to believe you could manage at least a little bit more than the compiler/algorithm being capable of "exactly NO non-trivial coherence resolution"
14:34:39 <ski> mmorrow : example ?
14:34:52 <mmorrow> ski: an example of what?
14:35:19 <mmorrow> of a situation exhibiting non-trivial coherence resolution, but that *is* actually coherent?
14:35:37 <ski> of a case where you'd want to allow a bit of overlap, but where you can determine that the overlap is coherent
14:35:40 <mmorrow> i'm not sure yet off-hand, but that's the next step i suppose
14:35:42 <ski> yes
14:36:44 <mmorrow> (and also bear in mind, there are many cases where you know something is ok, but the typeclass instance resolution can't figure it out, but typeclasses are useful nonetheless)
14:37:01 <ivanm> Baughn: ta
14:37:10 <ski> yes, but noncoherence is bad
14:37:22 <azm> kittens are good
14:37:28 <Baughn> ivanm: Have fun.
14:37:35 <ski> different implementations might decide to pick different instances
14:37:39 <mmorrow> ski: right, anything that's either non-coherent or that you can't determine coherency would have to be rejected
14:37:39 <ivanm> Baughn: though is the hlint stuff optional?
14:38:02 <ski> even if they don't, the programmer might pick a different one (in head) than the implementation does
14:38:03 <ivanm> Baughn: also, IIRC the "default" hlint command is C-c l ...
14:38:12 <mmorrow> ski: ah good point, and exactly /how/ things are chosen along the way would also have to be specified
14:38:18 <cx> I want to return a boolean if two list contains the same int, like [1,2,3] [3,2,1] I've tried isInfixOf  (sort [1,2,3]) (sort [2,1,3]) but I have to use this definition fish :: Eq a => [a] -> [a] -> Bool, when I use sort i have to implement Ord :/
14:38:22 <ski> and specifying rules for which to prefer are complicated and ad hoc
14:38:44 <mmorrow> ski: oh. yes, if there is more than one choice, immediate rejection.
14:38:56 <mmorrow> ski: but this is really the fault of typeclasses here
14:38:56 <ski> imo, it is better to refuse to choose if there is an ambiguity
14:39:03 <mmorrow> ski: right
14:39:03 <ski> yes
14:39:05 <mmorrow> i agree
14:41:07 <Vulpyne> cx: Maybe: or (map (`elem`list1) list2)
14:41:09 * ski has pondered a related problem in LP, a little
14:42:05 <ski> basically if you have propositions relating a bunch of relations, in some cases such a proposition can act as a definition of either one or another relation
14:42:22 <Vulpyne> cx: Actually: any (`elem` list1) list2
14:42:28 <ezyang> I can use typeclasses like MonadWrite and MonadFailure to specify that a particular monad m has certain capabilities. Is there a way to specify that these capabilities have to be in a certain order?
14:42:39 <ezyang> (where order = order of monad transformers)
14:42:40 <ski> e.g. `all [X,Y] foo(X,Y) <=> bar(Y,X).' can act as a definition of foo/2, given bar/2, or vice versa
14:43:15 <Boney> is there a ctags-ish tool for Haskell?
14:43:37 <ivanm> Boney: yes, it comes with ghc IIRC
14:43:39 <Vulpyne> Boney: http://hackage.haskell.org/package/hasktags-0.68
14:43:40 <ski> so the problem then is, to determine whether there is any non-trivial loops around the relation nodes, that might indicate a possible inconsistency
14:43:41 <poe> > S.fromList [1,2,3] == S.fromList [3,2,1] -- cx probably better?
14:43:42 <lambdabot>   True
14:43:59 <Boney> thanks.
14:44:02 <ivanm> hasktags
14:44:23 <aavogt> ezyang: while still leaving the possibility open that those transformers are not the last ones applied?
14:44:27 <poe> cx S is Data.Set
14:44:33 <ezyang> aavogt: yup
14:44:45 <aavogt> how is this flexibility actually a problem for you?
14:45:14 <ezyang> Otherwise I can do something like Monad m => ErrorT MyError (ReaderT Environment m)
14:45:25 <ski> mmorrow : btw, maybe i've mentioned this before, but i've pondered having
14:45:26 <ezyang> aavogt: Idle curiosity :-)
14:45:37 <ski>   class Functor m => Monad m
14:45:38 <ezyang> I mean, monad transformer order does matter, no?
14:45:39 <ski>     where
14:45:42 <aavogt> @type runErrorT . runWriterT
14:45:43 <lambdabot> forall e (m :: * -> *) w a. WriterT w (ErrorT e m) a -> m (Either e (a, w))
14:45:45 <ski>     instance Functor f
14:45:47 <ski>       where
14:45:53 <aavogt> @type runWriterT . runErrorT
14:45:54 <lambdabot> forall w (m :: * -> *) e a. ErrorT e (WriterT w m) a -> m (Either e a, w)
14:46:03 <ski>       fmap f ma = ma >>= return . f
14:46:14 <ski>     return :: a -> m a
14:46:14 <dcoutts> bos: pong
14:46:23 <ski>     (>>=) :: m a -> (a -> m b) -> m b
14:47:13 <ski> as specifying a default `Functor m' instance whenever we get (e.g. write) a 'Monad m' instance
14:47:29 <ski> (s/Functor f/Functor m/)
14:47:31 <mmorrow> ski: hmm, interesting
14:47:58 <mmorrow> ski: what prompted this "implication" thing is the situation where (e.g.) you have
14:48:06 <mmorrow> class Unit a where unit :: a
14:48:07 <aavogt> ezyang: perhaps something can be done with -XFlexibleContexts... but I'm not sure
14:48:23 <mmorrow> and then, you want to make it *impossible* for a type that's an instance of Monoid
14:48:31 <mmorrow> to be such that mempty /= unit
14:48:39 <mmorrow> which is currently not possible
14:48:51 <ski> does that mean you want to force the same implementation ?
14:49:03 <mmorrow> you want to make *one* implementation
14:49:04 <ski> (i assume so)
14:49:38 <ski> hm
14:49:39 <mmorrow> (unit::a) = (mempty::a), forall a | instance Monoid (a)
14:49:53 <mmorrow> s/Monoid (a)/Monoid a/
14:50:12 <aavogt> ezyang: t :: (MonadWriter String m, MonadError String (WriterT String m), Monad m) => m ()
14:50:14 <ski> what does `| instance Monoid a' mean ?
14:50:20 <mmorrow> "such that"
14:50:27 <mmorrow> "|" := "such that"
14:50:38 <ski> why not just `| Monoid a', then ?
14:50:50 <mmorrow> that'd work too
14:51:14 <mmorrow> (just wanted to emphasize the forall, but as you say it really is already implicit i suppose)
14:52:03 <aavogt> hmm, that doesn't restrict the order of transformers as I thought it would
14:52:50 <aavogt> ghc simplifies the class constraints
14:53:07 <ski> mmorrow : hm, any reason not to just use a single identifier in that case ?P
14:53:17 <mmorrow> ski: oh, and additionally you want any type that's an instance of Monoid to *automatically* be an instance of Unit
14:53:21 <mmorrow> with unit = mempty
14:53:53 <mmorrow> ski: you could have instances of Unit that aren't Monoid
14:54:08 <benmachine> if you require unit = mempty why do you have two names for it
14:54:22 <mmorrow> but the moment a type becomes a Monoid, you lose the ability to specify the Unit instance
14:54:29 <ski> mmorrow : so why do you want `mempty' in addition to `unit' ?
14:54:52 <mmorrow> ski: because Monoid already exists
14:55:27 <ezyang> aavogt: ooh clever!
14:55:32 <mmorrow> (and Unit doesn't)
14:55:37 <ski> so are you saying the writer of `Unit' should make sure to play well with a preexisting `Monoid'
14:55:41 <aavogt> but it doesn't work :(
14:55:42 <ski> or vice versa
14:56:01 <ezyang> oh. Hmm.
14:56:03 <ski> or a third-party declaring the coherence between those two
14:56:05 <mmorrow> ski: right! and additionally can ensure that it agrees with mempty when `a' is a Monoid
14:56:30 <ski> which ? :)
14:56:43 <mmorrow> oh
14:56:56 <mmorrow> neither i think
14:57:34 <mmorrow> rather, the writer of Unit can make Monoid play well with Unit, and ensure that they are mutually coherent wrt mempty/unit
14:57:53 <haole> hello there ... i'm a lisp programming and i'm thinking of migrating to haskell, but i really like the idea of lisp that everything evaluates to something, and then you get closure and so on... is hakell like this too?
14:58:11 <mmorrow> also, you can give *every* monoid an *automatic* Unit instance
14:58:21 <osaunders> haole: Where it matters, yes.
14:58:26 <mmorrow> that can't be overridden
14:58:49 <osaunders> haole: But Haskell gives you a lot more.
14:59:54 <mmorrow> ski: oh, i missed "or vice-versa"
15:00:06 <mmorrow> ski: the former of your two
15:00:30 <mmorrow> but also, you ensure coherence by definition (:= because you say so)
15:00:40 <mmorrow> and it's globally enforced
15:01:04 <haole> osaunders, i was thinking about this because a statement that i read about the Yi editor... that it is entirely written in its scripting language (that is haskell) and i was curious about the language itself... seems very different from everything i saw so far, including lisp
15:01:48 <osaunders> haole: Haskell isn't conventionally thought of as a scripting language.
15:02:20 <osaunders> haole: What's different about Haskell, that I think you're referring to, is that it is *purely* functional.
15:02:35 <ski> if the same programmer has control over both classes, then the programmer can choose the same name
15:03:09 <osaunders> The definition of a functional language is vague but a purely functional language is much more definite.
15:03:20 <osaunders> (the definition of one).
15:03:26 <mmorrow> ski: but Monoid => Unit, but Unit doesn't imply Monoid
15:03:35 <osaunders> haole: Do you know what a pure function is?
15:04:01 <mmorrow> ski: and i'm assuming the general case where you don't have control over every class definition in your program (e.g. Num, Monad, etc)
15:04:06 <ski> mmorrow : the direction of the implication doesn't matter here, i think
15:04:19 <mmorrow> ski: in what sense?
15:04:36 <ski> with `class Eq a => Ord a', the programmer who defined `Ord' must know about `Eq', but not vice versa
15:04:39 <mmorrow> implication (Unit a) => Monoid a where mempty = unit; mappend = ????
15:04:59 <mmorrow> ski: right, implication Ord a => Eq a
15:05:15 <tommysfu> um
15:05:27 <tommysfu> is anyone willing to help me out with python?
15:05:36 <tommysfu> i cant seem to find a python channel
15:05:40 <ski> with JohnMeachams superclass proposal, `class Monad m <= Pointed m' the programmer who defines `Pointed' must know about `Monad', but not vice versa
15:05:42 <Botje> uh
15:05:45 <Botje> tommysfu: how about ##python?
15:05:52 <ski> in the first case, `Ord' is constructed as an extension of `Eq'
15:06:06 <tommysfu> theres like 2 people in there
15:06:09 <ski> in the second case, `Pointed' is created as a restriction of `Monad'
15:06:32 <ski> so which implies which is unrelated to which has to know about which
15:06:33 <Botje> tommysfu: and there's 700+ in #python
15:06:35 <haole> osaunders, i think that it is a function that, for every input, produces the same output for each instance of this input
15:06:37 <tommysfu> really?
15:06:45 <haole> osaunders, don't know if i expressed myself in a good way
15:06:53 <Botje> yes, the number of #'s matters :)
15:07:07 <osaunders> haole: Yeah I think you got it.
15:07:09 <tommysfu> oh
15:07:14 <tommysfu> i see why i need to be identified
15:07:21 <haole> osaunders, like a spreadsheet! lol :D
15:07:32 <osaunders> haole: Yep. Spreadsheets are purely functional.
15:07:54 <ski> but if two independent programmers have defined `Monoid' and `Unit', then one can't in general expect that they choose the same name for `mempty'/`unit' .. so in this case, i see a use for a third party specifying that those must be the same
15:08:03 <haole> osaunders, thanks for the info... i guess i won't regret to learn haskell... :)
15:08:09 <mmorrow> ski: ah, ok. implication is more about defining a family of instances for a collection of types which are such that the classes they are already instances of are sufficient to completely determine the instance for each of those of this new class, and additionally you want to enforce that this instance is the one that's used if any is used at all. furthermore, you only want to define it in one place
15:08:20 <Botje> tommysfu: but stay here and learn about haskell! :)
15:08:40 <osaunders> haole: If you go to infoq there are a bunch of talks there about why functional programming is good.
15:09:00 <osaunders> http://www.infoq.com/Haskell
15:09:04 <mmorrow> <ski> but if two independent programmers have defined `Monoid' and `Unit', then one can't in general expect that they choose the same name for `mempty'/`unit' .. so in this case, i see a use for a third party specifying that those must be the same
15:09:17 <haole> osaunders, thanks for the tip
15:09:21 <mmorrow> ski: ahh, yes. i think i may have misunderstood your two classifications possibly
15:10:46 <ski> > (flip . flip) undefined `seq` ()
15:10:49 <lambdabot>   ()
15:10:49 <osaunders> haole: Also http://learnyouahaskell.com/ is great.
15:11:02 <ben> Waiting until it gets a chapter on monad transformers
15:11:12 <osaunders> ben: Yeah, I'd like that too.
15:11:20 <osaunders> But I'm not that far yet anyway.
15:11:29 <seanmcl> Is there any way to make Set a Monad?  The obvious definition (http://pastebin.ca/1694595) doesn't work because it requires a (of Set a) to be an Ord instance.  Is there a way to use Set as a Monad at type Int but to raise a type error if I try to use Set as a Monad at type a?
15:11:29 <Cale> Jeez, people keep asking preflex when edwardk was last seen, and his last message to the channel had my name in it, so I get highlighted every single time
15:11:34 <ski> (mmorrow : of course, the two programmers may even have given the operation with differing order of arguments ..)
15:11:44 <Cale> hmm
15:11:59 <ben> Cale: Can you just /nick edwardk and say something that does not have your name in it
15:12:02 <osaunders> Cale: I've started taking a look at that course.
15:12:08 <Cale> He's still online apparently
15:12:10 <mmorrow> ski: heh
15:12:15 <ben> oh :<
15:12:16 <eugenn> @pl paresElementos grupo = filter (perteneceAlGrupo grupo . fst) todosLosElementos
15:12:18 <lambdabot> paresElementos = flip filter todosLosElementos . (. fst) . perteneceAlGrupo
15:12:29 <Cale> osaunders: Awodey's book?
15:12:32 <mmorrow> ski: (<*) and (*>) in Monoid ftw!
15:12:42 <eugenn> @pl paresElementos' grupo = filter (\(elemento, _) -> elem elemento (elementos grupo)) todosLosElementos
15:12:43 <lambdabot> paresElementos' = flip filter todosLosElementos . (`ap` snd) . (. fst) . (const .) . flip elem . elementos
15:12:46 <mmorrow> ski: (or s/*/whatever/)
15:12:56 <ski> mmorrow : i meant "the same" operation, but in different classes
15:12:57 <Cale> Oh, right, I should add preflex to my list of nonhighlighting nicks
15:13:04 <mauke> I was about to ask that :-)
15:13:10 <ski> (like `Monoid' and `Unit' in your example)
15:13:15 <osaunders> Cale: Oh yeah it was Axman6 who send me the link not you. http://cs.anu.edu.au/Student/comp2600/lectures.php
15:13:16 <mmorrow> ski: oh, right.
15:13:39 <fritschy_> hello everybody... i am havin a curious problem; i have a long lazily generated list of things, generated through Prelude.iterate. When i just take N from it and (show.map show) them it's fine, when i reverse those N elements, or access a specific one of them, the stack wil overflow - there is docs on it ( http://haskell.org/haskellwiki/Stack_overflow ), but poor me doesn't really understand it...
15:13:40 <Cale> osaunders: ah, that is quite different ;)
15:13:48 <mmorrow> ski: yes, "the same" being key there, but also only the same /if A, B, and C/ are true of the type
15:14:04 <mmorrow> (where A, B, and C are existing instances)
15:14:11 <osaunders> Cale: Actually there is so much to learn I'd appreciate some advice on what I should do first and what is most important.
15:14:12 <ski> ok
15:14:23 * ski needs to get some sleep ..
15:14:30 <mmorrow> ski: night!
15:14:36 <ski> ttyl
15:14:46 <Cale> fritschy_: It's because the list produced by iterate, when you walk down the spine and don't look at any of the elements, ends up looking like [x, f x, f (f x), ...]
15:14:53 <ben> Maybe I should reread rwh now that I do not mentally collapse at the mention of multi-parameter typeclasses
15:14:57 <osaunders> Cale: Do you think I should just work through LYAH before getting deep into this more mathematical stuff?
15:15:10 <fritschy_> Cale, only that 'looking at them' is the key to understand this?
15:15:11 <Cale> fritschy_: and so if you just look at the millionth one, it's something like f (f (... (f x)...))
15:15:39 <fritschy_> so... i need something like $! or seq - which i too haven't yet understood :)
15:15:50 <Cale> fritschy_: and if f is strict in its parameter, then the Haskell evaluator has to walk all the way to the middle of that expression
15:16:11 <Cale> It's a bad interaction of strictness and laziness
15:16:22 <Cale> f is too strict and what you're looking at the list with is too lazy
15:16:58 <Cale> So, you can fix it by forcing the list to evaluate as you walk down it. I believe there are some ready-made things in Control.Parallel.Strategies
15:17:00 * fritschy_ is thinking... slowly
15:18:02 <Cale> > iterate (+1) 0 !! 1000000
15:18:04 <lambdabot>   * Exception: stack overflow
15:18:46 <Cale> > let xs = iterate (+1) 0 in seqListN xs 1000000 `seq` xs !! 1000000
15:18:48 <lambdabot>   No instance for (GHC.Num.Num
15:18:48 <lambdabot>                     (Control.Parallel.Strategi...
15:18:51 <Cale> er
15:18:57 <Cale> > let xs = iterate (+1) 0 in seqListN 1000000 xs `seq` xs !! 1000000
15:18:59 <lambdabot>   Couldn't match expected type `Control.Parallel.Strategies.Strategy
15:18:59 <lambdabot>         ...
15:19:14 <Cale> d'oh
15:19:21 * Cale should read the types carefully ;)
15:19:23 <birdiee> can someone tell me why this is wrong? http://privatepaste.com/01c3291dc0 I get ** Exception: Sudoku.hs:(201,0)-(202,54): Non-exhaustive patterns in function insertAt
15:19:33 <Cale> > let xs = iterate (+1) 0 in seqListN 1000000 whnf xs `seq` xs !! 1000000
15:19:34 <lambdabot>   Not in scope: `whnf'
15:19:45 <Cale> > let xs = iterate (+1) 0 in seqListN 1000000 rwhnf xs `seq` xs !! 1000000
15:19:47 <lambdabot>   1000000
15:19:51 <Cale> *there*
15:19:53 <Cale> heh
15:19:54 <benmachine> hurrah
15:19:56 <fritschy_> :D
15:20:00 <osaunders> birdiee: No patterns are matching for however you've applied it.
15:20:04 <Cale> Sorry about the messing around
15:20:15 <fritschy_> ... Cale, wt.?! ;)
15:20:17 <birdiee> osaunders hm ok
15:20:23 <Cale> but anyway, what that does is tells it to first *evaluate* the first million elements of the lsit
15:20:25 <Cale> list*
15:20:32 <tromp__> your first inserAt already covers all cases
15:20:39 <Cale> and then ask for the millionth
15:20:41 <tromp__> oops, no
15:20:43 <osaunders> birdiee: That's what non-exhaustive patterns means.
15:20:58 <Cale> There are some other things you could write which might help some too...
15:21:01 <tromp__> you miss the case insertAt (>0) cs []
15:21:02 <benmachine> insertAt n xs [] == ??
15:21:12 <fritschy_> Cale: thinking about it makes my head feal like pudding...
15:21:33 <birdiee> oh I see
15:21:39 <Cale> fritschy_: It helps to try to see how things evaluate step by step on small examples.
15:21:56 <GNU\colossus> I'm kind of stuck with my assignment, I tried to sum up the problem here: http://pasted.at/d8f641b6ec.html - is anyone of you able to help?
15:21:57 <fritschy_> Cale: SimpleReflect ;) still it needs getting used too
15:22:08 <Cale> fritschy_: let's try evaluating  iterate (+1) 0 !! 3
15:22:12 <Cale> by hand :)
15:22:18 <fritschy_> :)
15:22:22 <Cale> @src !!
15:22:23 <lambdabot> xs     !! n | n < 0 = undefined
15:22:23 <lambdabot> []     !! _         = undefined
15:22:23 <lambdabot> (x:_)  !! 0         = x
15:22:23 <lambdabot> (_:xs) !! n         = xs !! (n-1)
15:22:44 <tromp__> try insertAt n x ys = firstn ++ x:rest where (firstn,rest) = splitAt n ys
15:22:56 <Cale> 3 isn't negative or 0, so we need to check if the list is not empty
15:23:09 <Cale> and so we need to evaluate iterate (+1) 0 by one step
15:23:12 <Cale> @src iterate
15:23:13 <lambdabot> iterate f x =  x : iterate f (f x)
15:23:20 <Cale> Well, that's easy:
15:23:24 <Cale> iterate (+1) 0 !! 3
15:23:41 <Cale> -> (0 : iterate (+1) ((+1) 0)) !! 3
15:23:58 <Cale> okay, and now !! can pattern match, so it's happy
15:24:08 <Cale> and it evaluates to:
15:24:17 <Cale> -> (iterate (+1) ((+1) 0)) !! (3-1)
15:24:29 <benmachine> are there any tools around for doing these sorts of subsitutions in a step-by-step manner?
15:24:38 <luite> Cale :p
15:24:43 <Cale> and then !! immediately forces the 3-1 to evaluate by pattern matching it
15:24:54 <Cale> -> (iterate (+1) ((+1) 0)) !! 2
15:25:02 <Cale> and then again it needs to know if the list is empty or not
15:25:19 <osaunders> benmachine: I think what you're talking about is a graph reduction.
15:25:38 <benmachine> osaunders: sounds likely
15:25:42 <fritschy_> Cale: feels to me like i have to catch up on the basics of lazy vs. strict
15:25:44 <Cale> -> (((+1) 0) : iterate (+1) ((+1) ((+1) 0))) !! 2
15:25:57 <osaunders> benmachine: Wait, do you mean seeing them done step-by-step?
15:25:58 <Cale> fritschy_: okay
15:26:04 <benmachine> osaunders: yes
15:26:04 <fritschy_> Cale: ack, that's what i was wriging down ;)
15:26:12 <birdiee> tromp__ ok thanks gonna test let's see
15:26:13 <fritschy_> writing*
15:26:14 <birdiee> brb
15:26:15 <Cale> fritschy_: So the main difference is that lazy is outermost first
15:26:16 <benmachine> there is a program that doesn't show you the steps
15:26:18 <benmachine> it is called ghc
15:26:25 <Cale> fritschy_: whereas strict is innermost first
15:26:44 <osaunders> benmachine: http://en.wikibooks.org/wiki/Haskell/Graph_reduction#Reductions
15:26:52 <fritschy_> sick'n twisted... :)
15:26:55 <Cale> fritschy_: In strict evaluation, you evaluate the arguments, then substitute the resulting values into the function body.
15:27:12 <fritschy_> i see... that's exactly what's causing the trouble in my head
15:27:17 <Cale> fritschy_: In lazy evaluation you just substitute the expressions that a function has been applied to into its function body
15:27:17 <fritschy_> and then in my code
15:27:29 <Cale> (well, with a slight wibble/optimisation)
15:27:33 <osaunders> benmachine: If you find out how to do it, I'd like to know. I've asked here before but I think it got lost in the stream of chats.
15:28:00 <benmachine> osaunders: yeah, that can happen
15:28:10 <Cale> The slight optimisation that I haven't explained will explain why iterate works fine when you print the first million values in order
15:28:14 <mmorrow> Cale: you might want to let-bind each non-trivial arg, then substitute the let-bound var
15:28:22 <Cale> mmorrow: exactly
15:28:37 <Cale> That's the difference between lazy evaluation and plain outermost first evaluation
15:29:03 <Cale> If a parameter to a function occurs more than once in the body, any evaluation done to the copies is shared between them
15:29:07 <mmorrow> (and if the arg is used exactly once, it's always ok to inline it)
15:29:08 <mmorrow> right
15:29:16 <osaunders> I wish they'd called outermost eval, breath-first eval.
15:29:26 <Cale> oh, I have to go to supper
15:29:27 <osaunders> Makes more sense to me.
15:29:33 <Cale> bbiab
15:29:58 <dibblego> @type zipWithM -- can this be generalised to any Applicative, not just ZipList?
15:29:59 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
15:30:08 <osaunders> I should eat too. Can I get anybody anything? :-P
15:30:26 * osaunders likes eating.
15:30:37 <ben> I am eating chocolate.
15:30:42 <ben> I find chocolate and #haskell go well together.
15:30:45 <benmachine> I am envious
15:30:49 <benmachine> I finished my chocolate :(
15:30:54 <benmachine> apart from crappy biscuits
15:30:57 <benmachine> but they're crappy
15:31:15 <cx> How can I do this recursivly, elem 5 [2,3,4,5] ?
15:31:24 <mmorrow> @src elem
15:31:24 <ben> @src elem
15:31:24 <lambdabot> elem x    =  any (== x)
15:31:24 <lambdabot> elem x    =  any (== x)
15:31:29 <mmorrow> @src any
15:31:29 <lambdabot> any p =  or . map p
15:31:32 <mmorrow> @src or
15:31:33 <lambdabot> or    =  foldr (||) False
15:31:36 <mmorrow> @src map
15:31:37 <lambdabot> map _ []     = []
15:31:37 <lambdabot> map f (x:xs) = f x : map f xs
15:31:38 <ben> okay let's not
15:31:41 <mmorrow> @src foldr
15:31:42 <lambdabot> foldr f z []     = z
15:31:42 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:31:44 <mmorrow> had to finish :)
15:31:54 <ben> stop pretending to reduce the graph!
15:31:55 <mmorrow> </transitive closure>
15:32:09 <monochrom> Two cases.  elem 5 [] = ?   elem 5 (x:xs) = ?
15:32:52 <fritschy_> Cale: thank you
15:33:14 <mmorrow> cx: the basic pattern with a given type, is to do what you need to do with the non-recursive parts of that type, then simply recurse of the recursive parts
15:33:28 <monochrom> To understand recursion, first ignore recursion. Just do your job by cases.
15:34:50 <birdiee> tromp__  and osaunders insertAt seems to work good it's the things I do with it that is weird :/
15:35:52 <cx> ok, this is what i got so far
15:35:52 <cx> (x:xs) = (x `elem` xs)
15:35:58 <cx> but it only checks the first item
15:36:04 <cx> now i want this recursivly
15:36:11 <cx> :D
15:36:13 <tromp__> that's just cause you do weird things with it:)
15:39:50 <monochrom> Recursion is divide and conquer. How to sum up 10 numbers? It is the 1st number + sum up 9 numbers.
15:40:26 <ben> How to sum up 0 numbers? It is the 0th number + sum up -1 numbers.
15:40:45 <monochrom> (Oh, you could (sum up the 1st 5 numbers) + (sum up the last 5 numbers) too, if the container of the numbers let you make that split easily.)
15:40:49 <tromp__> no it's not
15:41:32 <jmcarthur> dangit. i hate it when quickcheck tests fail due to int overflow because it generated cases which will never happen in real life
15:41:45 <Vulpyne> cx: Did you try what I said before? any (`elem`[1,2,3]) [3,2,1]
15:42:11 <cx> Vulpyne missed that, gonna try it now
15:42:15 <cx> 1 sewc
15:42:23 <Vulpyne> It should return true if either list has any item in common.
15:42:31 <monochrom> How to determine whether 5 occurs in a list of 10 numbers?  It is (5 == the 1st number) || (determine whether 5 occurs in the remaining list of 9 numbers)
15:43:11 <MoALTz> well, if you are going to divide and conquer (presumably for multi-core/-processor/-machine) then presumably you'd want to frame the solution in a way so that the best choice of processing it can be choosen later (say, by the compiler...)
15:43:38 <ben> (sum up the 10/n first numbers) + (sum up the 10/n second numbers) + (sum up the 10/n last numbers), where n is the amount of cores~
15:43:46 <ben> + ... +, I mean
15:44:26 <monochrom> I am going to divide and conquer (presumably for freshman recursion exercises, not multicore whatever), then presumably I want to frame the solution to fit the data structure.
15:44:57 <MoALTz> ok point taken :)
15:45:09 <cx> Vulpyne it returns alwas true :)
15:45:35 <Vulpyne> > any (`elem`[1,2,3]) [4,5,6]
15:45:35 <lambdabot>   False
15:45:59 <Vulpyne> cx: It returns True if there's an item in common, otherwise False.
15:46:09 <Vulpyne> > any (`elem`[1,2,3]) [4,5,6,1]
15:46:10 <lambdabot>   True
15:46:10 <monochrom> I don't understand why people keep thinking that concurrency implies parallelism, divide and conquer implies parallelism, matrix implies parallelism, vector implies parallelism...
15:46:27 <mauke> > intersect [1,2,3] [2,4,6]
15:46:29 <lambdabot>   [2]
15:46:33 <Cale> fritschy_: I'm back, in case you'd like any more detail on how things happen.
15:47:20 <monochrom> I for one use divide and conquer when there is one single processor, and it is human, it is me. I have 40 student assigments to sort to alphabetical order, I do divide and conquer, and it is me working alone, single human.
15:47:27 <Vulpyne> Yeah, not . null . intersect would do the same thing I guess.
15:47:54 <Cale> monochrom: It's because they're mostly imperative programmers, and for them, parallelism implies concurrency, and nobody's very good at logic, so they get the arrows backwards.
15:49:42 <pikhq> monochrom: Well, because they'd generally not use any of them outside of parallelism. For no really good reason.
15:50:24 <pikhq> Though they really should be *aware* of vector stuff outside of that...
15:50:44 <pikhq> Considering that most CPUs have vector units these days.
15:51:22 <monochrom> Is there a lambdabot's record of Simon Marlow's karma? Under what name?
15:51:33 <poe> ?karma JaffaCake
15:51:33 <lambdabot> JaffaCake has a karma of 0
15:51:44 <mauke> preflex: karma JaffaCake
15:51:44 <preflex>  JaffaCake: 3
15:52:13 <poe> karma potential difference (karma current?)
15:52:14 <monochrom> Sweet. Thanks.
15:52:20 <monochrom> JaffaCake++
15:54:59 <monochrom> Simon Marlow is so brave as to say the inconvenient truth and be made martyr.
15:55:48 <Cale> monochrom: Are you referring to the Haskell Prime list?
15:56:10 <monochrom> I am referring to concurrency does not imply parallelism.
15:56:10 <cx> is there a function that checks for duplicates in a list?
15:56:40 <Cale> oh
15:56:40 <Cale> Where is that?
15:56:41 <poe> ?google ghcmutterings concurrency
15:56:41 <Vulpyne> cx: nub will remove them.
15:56:41 <lambdabot> http://ghcmutterings.wordpress.com/2009/10/06/parallelism-concurrency/
15:56:41 <lambdabot> Title: Parallelism /= Concurrency ¬´ GHC Mutterings
15:56:49 <dibblego> @type nub >>= (==)
15:56:50 <lambdabot> forall a. (Eq a) => [a] -> Bool
15:56:55 <poe> i'm feeling lucky.
15:57:01 <monochrom> Ha thanks poe.
15:57:23 <Vulpyne> :t nub
15:57:24 <lambdabot> forall a. (Eq a) => [a] -> [a]
15:57:34 <cx> Vulpyne oki :)
15:57:54 <monochrom> The whole blog-reading programmer community literally threw stones at him for saying it loud.
15:58:31 <mauke> "literally"?
15:58:47 <monochrom> how about virtually?
15:59:03 <mauke> figuratively
15:59:31 <dibblego> Cale, have you a moment to help me write spanM please?
15:59:42 <Cale> sure
15:59:48 <dibblego> @type let spanM _ [] = return ([], []); spanM p x@(h:t) = p h >>= \b -> if b then first (h:) `liftM` spanM p t else return ([], x) in spanM -- this is not right
15:59:49 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m ([a], [a])
16:00:07 <dibblego> I am in a tanlge
16:00:42 <Cale> @paste
16:00:43 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
16:01:18 <Cale> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5204#a5204
16:01:43 <cx> Vulpyne it solved the problem, thank you
16:01:50 <Vulpyne> cx: Swee.t
16:02:20 <dibblego> Cale, thanks
16:02:43 <Cale> @src span
16:02:44 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
16:02:47 <Cale> hmm
16:03:07 <Cale> dibblego: I seem to recall cheating and translating the code from the Report to write that :)
16:03:14 <dibblego> heh
16:03:44 <dibblego> I think that's the same as what I have
16:03:48 <ben> why are we not using regular hpaste.org again?
16:03:51 <Cale> span p []            = ([],[])
16:03:51 <Cale> span p xs@(x:xs')
16:03:51 <Cale>             | p x       =  (x:ys,zs)
16:03:51 <Cale>             | otherwise =  ([],xs)
16:03:51 <Cale>                            where (ys,zs) = span p xs'
16:04:17 <dibblego> maybe I was right then
16:06:22 <Cale> dibblego: Perhaps you were? Is it behaving strangely in any way?
16:06:37 <dibblego> Cale, no, it just didn't look right to me, but maybe that's me, not the code :)
16:07:41 <Jonty> Sorry if this is a stupid question, but could someone explain to me why the code here is giving the error beneath it? I can't see the problem. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13417#a13417
16:08:24 <mauke> precedence
16:08:26 <ivanm> Jonty: I think it's applying bSort to y
16:08:28 <monochrom> bSort y:xs  should be  bSort (y:xs)
16:08:33 <mauke> function application binds tighter than operators
16:08:33 <ivanm> yeah, that's it
16:08:41 <ivanm> x : bSort (y:xs)
16:09:03 <mauke> are you trying to write bubblesort?
16:09:18 <Jonty> ahh, thanks!
16:09:30 <Jonty> mauke: yes, I'm aware that's only one iteration of it though
16:09:51 <shrughes> :t mapAccumL
16:09:51 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
16:10:18 <monochrom> OK good, I was thinking "this is too fast to be correct" :)
16:13:15 <shrughes> > iterate (uncurry mapAccumL (min &&& max) . (head &&& tail)) [5,4,10,2,3,9,8,7,6,1] !! 9
16:13:16 <lambdabot>   Couldn't match expected type `(b -> x -> (b, y), c)'
16:13:16 <lambdabot>         against inferr...
16:13:51 <shrughes> > iterate (snd . uncurry mapAccumL (min &&& max) . (head &&& tail)) [5,4,10,2,3,9,8,7,6,1] !! 9
16:13:52 <lambdabot>   Couldn't match expected type `(b -> x -> (b, y), c)'
16:13:52 <lambdabot>         against inferr...
16:14:33 * lispy begins to realize that Pidgin has some annoying misfeatures when used as an IRC client for a busy channel.
16:15:17 <akappa> lispy, what about xchat?
16:15:41 <luqui> i think google wave, with a lot of polish, could be good for channels like this
16:15:55 <akappa> luqui, wave?
16:15:55 <luqui> captures its kind of nonlinear nature
16:16:00 <akappa> wave is SLOW
16:16:09 <lispy> akappa: may be worse?  I'm sort of picky.  I probably need to switch back to erc or irissi
16:16:12 <luqui> yeah that's part of the lot of polish that it needs
16:16:18 <akappa> and the fact that you can edit someone's post is really annoying
16:16:32 <akappa> lispy, worse? why?
16:17:20 <dibblego> @src mapAccumR
16:17:21 <lambdabot> Source not found. It can only be attributed to human error.
16:17:23 <lispy> akappa: #haskell is the wrong place to get into it.  But, I have certain expectations for noise / information management with respect to irc.  As far as I know, xchat doesn't support the interface I want.
16:17:52 <akappa> noise management?
16:18:12 <Jonty> luqui: I always thought threaded IRC could be useful for cases like this, then I saw Google Wave and thought 'mind thieves!'
16:20:26 <Botje> > tyConString . typeRepTyCon . typeOf . Just 42
16:20:28 <lambdabot>   Just "Integer"
16:20:41 <Botje> > tyConString . typeRepTyCon . typeOf . Just $ 42
16:20:42 <lambdabot>   "Maybe"
16:25:18 <rgrinberg> hi guys, i don't mean to sound like an idiot but how come this type signature doesn't work: :: (Int a) => (a -> b) -> (a -> b) -> [a] -> [b]. I'm going over my first haskell tutorial, go easy. I want a function that accepts two functions and a list of integers and returns a list of whatever type the functions returns.
16:26:50 <copumpkin> @oeis [0,1,4,15,64,325]
16:26:51 <lambdabot>  Sequence not found.
16:27:16 <Lemmih> rgrinberg: Did you mean 'Num' instead of 'Int'?
16:27:33 <mauke> rgrinberg: Int is a type, not a class
16:27:40 <poe> Or maybe Integral
16:27:50 <rgrinberg> what's the difference between the two
16:27:54 <rgrinberg> *three
16:28:29 <osaunders> To say side effects are not allowed in a functional language isn't correct is it? Because you do have them, they're just achieved through monads, righ?
16:28:31 <benmachine> type classes are basically groups of types that share common behaviour
16:28:44 <osaunders> s/functional/purely functional/
16:28:49 <benmachine> osaunders: referential transparency holds even for monads
16:29:04 <osaunders> But they do have side-effects.
16:29:06 <poe> osaunders functional languages have functions as first-class citizens, that's it
16:29:26 <mauke> osaunders: no
16:29:36 <osaunders> poe: I meant purely functional.
16:29:38 <benmachine> rgrinberg: so a type class is a group of types: Num is a group of types that do number things, Integral is a group of types that exhibit integral behaviour
16:29:39 <mauke> side effects are not achieved through monads
16:29:56 <jmelesky> osaunders: there are purely functional ways of handling side effects aside from monads
16:30:12 <rgrinberg> benmachine: and an Int?
16:30:36 <benmachine> rgrinberg: Int is a type
16:30:38 <osaunders> Are you telling me there are no side-effects in Haskell?
16:30:42 <poe> rgrinberg types are sets of values, classes are sets of types.
16:30:42 <mauke> osaunders: yes
16:30:52 <osaunders> mauke: How am I able to print to the screen then?
16:30:54 <benmachine> so Int can be in the Num group, or the Integral group (it's actually in both)
16:31:07 <mauke> osaunders: that's not you, it's the runtime system
16:31:12 <benmachine> in terms of function signatures, you have typeclasses on the left of => and types on the right
16:31:21 <benmachine> the left is called the context
16:31:25 <osaunders> mauke: That's Haskell.
16:31:31 <rgrinberg> benmachine: thanks that clears it up somewhat
16:31:34 * copumpkin just wrote factorial as both a hylomorphism and a paramorphism
16:31:35 <jmelesky> mauke: i'm not sure the distinction is relevant
16:31:37 <osaunders> mauke: Ergo Haskell has a side-effect.
16:31:39 <mauke> osaunders: it's not really in the language
16:31:53 <mauke> that is, you can't write code to manipulate it directly
16:31:53 <poe> rgrinberg ad a type signature has form  (constraint, ...) => type  where  constraint = classes applied to type variables that occur in the type
16:32:31 <osaunders> mauke: Does that really mean it's not part of the language?
16:32:35 <rgrinberg> poe: thanks
16:32:39 <osaunders> mauke: I wrote the code in the language and then it does it.
16:33:13 <mauke> osaunders: no, you wrote code to generate a description of the side effects you want to have performed
16:33:20 <mauke> that description is a data structure
16:33:35 <mauke> and then the runtime system goes and actually runs that stuff
16:33:48 <poe> I'd say the effects you want to have performed, since you've been so clear in your specification, since you've written them in haskell :()
16:33:48 <mauke> but the code you write just sees data structures
16:33:56 <poe> (one paren too many.)
16:34:02 <benmachine> side effects are where a function has effects other than its return value; that doesn't happen in haskell
16:34:20 <osaunders> OK.
16:34:29 <tensorpudding> copumpkin: classy!
16:34:29 <benmachine> that is my reading of it anyway
16:34:45 <copumpkin> tensorpudding: yep!
16:34:49 <copumpkin> tensorpudding: exciting!
16:35:00 <osaunders> So when we say purely functional we me a) values cannot be altered and b) functions have no side effects.
16:35:18 <byorgey> copumpkin: you're well on your way through "Evolution of a Haskell programmer"!!
16:35:27 <copumpkin> byorgey: yeah! I feel so evolved!
16:35:33 <osaunders> Whether or not the language has side-effects is confusing because you have to decide whether the runtime is part of the language.
16:35:54 <copumpkin> one of these days I'll find an actual use for a zygohistomorphic prepromorphism
16:35:57 <byorgey> osaunders: additionally, functions must always give the same results for the same inputs; they cannot depend on any external state
16:36:20 <osaunders> byorgey: I think that's implied by b.
16:36:28 <osaunders> Oh wait, it isn't.
16:36:31 <osaunders> OK, thanks.
16:36:35 <benmachine> the language doesn't have side effects even if the runtime is part of the language
16:36:40 <benmachine> it just has effects :P
16:36:42 <byorgey> osaunders: well, it depends what you mean by (b), I was just clarifying =)
16:36:55 <osaunders> byorgey: Yes, I appreciate that.
16:37:13 <osaunders> benmachine: Right, so purely functional language do have effects but not side-effects.
16:37:48 <byorgey> osaunders: yes, that's a good way to put it.
16:38:29 <osaunders> OK so I'm changing my definition of a purely function language to: Functions are first class objects and all functions are pure.
16:38:32 <tromp__> they have explicitly described effects
16:38:41 <osaunders> s/function/functional
16:38:54 <poe> osaunders in some sense referential transparency is implied by a) if a language is also functional :)
16:42:01 <osaunders> Right, well I'm glad we got that straightened out xD
16:43:27 <anavarro> hi
16:43:43 <anavarro> I have a very beginner question
16:43:44 <anavarro> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13418#a13418
16:44:18 <anavarro> I have this exercise
16:44:43 <byorgey> anavarro: ok, you have to figure out the type of h?
16:44:54 <anavarro> yes
16:45:12 <anavarro> I think that was (Integer -> Integer) -> Integer
16:45:27 <anavarro> but is not
16:45:34 <byorgey> anavarro: almost, but not quite
16:45:45 <byorgey> anavarro: what was your reasoning that led you to that type?
16:46:17 <anavarro> h x y
16:46:52 * mauke observes that applications of f are irrelevant wrt types
16:46:53 <anavarro> so the function accept two parameters
16:47:02 <anavarro> isn't it?
16:47:08 <mauke> yes
16:47:18 <mauke> but (Integer -> Integer) is one parameter
16:47:26 <byorgey> anavarro: yes.
16:47:33 <anavarro> ok
16:47:35 <byorgey> anavarro: but what mauke said.
16:48:12 <byorgey> anavarro: what are the types of h's parameters?
16:48:15 <anavarro> this is a function that accept one integer and returns another
16:48:51 <anavarro> two Integers
16:48:55 <byorgey> anavarro: right.
16:49:02 <anavarro> ok
16:49:03 <byorgey> anavarro: and how do you know they are Integers?
16:49:34 <anavarro> because they are used in g
16:49:48 <mauke> dingo
16:49:54 <byorgey> right.
16:49:59 <anavarro> and the type of g is
16:50:11 <anavarro> Integer -> (Integer -> Integer)
16:50:16 <byorgey> exactly
16:50:25 <byorgey> and what type does h return?
16:50:26 <anavarro> mmm
16:50:41 <anavarro> g gets an integer and return a function
16:50:45 <anavarro> isn't it?
16:50:58 <mauke> yes
16:51:01 <byorgey> anavarro: right, and that function takes another Integer and returns an Integer
16:51:17 <byorgey> it's the same as if g took two Integers as parameters
16:51:18 <anavarro> aha
16:51:22 <byorgey> this is called 'currying'
16:51:31 <anavarro> yes
16:51:45 <anavarro> this is the main topic of the chapter
16:51:57 <mauke> the cheap version to solves this (without thinking) is: f turns Integer into Integer, so it has no effect on the types
16:52:03 <anavarro> but I didn't get it very well
16:52:09 <osaunders> Would you say the ability to omit type declarations does anything besides reducing the amount of typing?
16:52:10 <mauke> so you can remove all calls to f without changing the types
16:52:25 <byorgey> anavarro: also, this is why  Integer -> Integer -> Integer   is really just an abbreviation for  Integer -> (Integer -> Integer)
16:52:27 <mauke> we get h x y = g x y, so the type of h is the type of g
16:52:29 <mauke> the end
16:52:30 <byorgey> we say that  ->  'associates to the right'
16:52:51 * Cale makes a parody of "A Softer World" out of a quote from IRC. http://cale.yi.org/share/ASWParody.png
16:53:09 <anavarro> yes
16:53:18 <anavarro> I understand that
16:53:37 <anavarro> so Integer -> (Integer -> Integer)
16:53:41 <anavarro> is the same as
16:53:52 <anavarro> Integer -> Integer -> Integer
16:54:02 <byorgey> yep
16:54:38 <zygoloid> Cale: that's pretty good :) mouseover text?
16:54:48 <byorgey> yeah, needs moar mouseover
16:54:50 <fritschy_> soo... is it bad coding style when one has to resort to "strict" folding and friends?
16:54:54 <byorgey> =)
16:55:09 <byorgey> fritschy_: no, it's good coding style when appropriate =)
16:55:34 <lispy> Usually if you don't need a strict foldl, you often want the lazy foldr
16:55:47 * lispy usually needs the strict foldl
16:56:00 <fritschy_> byorgey: it might take me some time (years?) to decide what's appropriate in haskell ;)
16:56:14 <byorgey> fritschy_: yes, that's normal =)
16:56:35 <anavarro> but is the role of f in here?
16:56:40 <zygoloid> fritschy_: it's an optimization, and as Knuth said: "[...] we should not pass up our opportunities in that critical 3% [...]" ;-)
16:56:45 <byorgey> fritschy_: but I can easily tell you when a strict fold is appropriate: when you are producing a single summary value that cannot be computed lazily
16:56:56 <byorgey> fritschy_: for example, adding up a list of Integers
16:58:06 <byorgey> anavarro: ok, so h takes two Integers, that's  h :: Integer -> Integer -> ...
16:58:13 <byorgey> anavarro: and what type does h return?
16:58:23 <anavarro> yes
16:58:26 <anavarro> Integer
16:58:33 <byorgey> right, why?
16:58:33 <anavarro> so the return is Integer -> Integer -> Integer
16:58:36 <byorgey> yes
16:58:39 <byorgey> the type
16:58:43 <anavarro> yes
16:58:45 <anavarro> the type
16:58:48 <byorgey> =)
16:59:08 <anavarro> because f returns a Integer?
17:00:31 <anavarro> an Integer
17:00:34 <anavarro> sorry
17:00:59 <osaunders> Would you say the ability to omit type declarations does anything besides reducing the amount of typing?
17:01:48 <Philonous1> It increases the risk of incorrect code
17:02:36 <sjanssen> osaunders: it makes rapid prototyping easier
17:03:12 <osaunders> Good, good.
17:03:20 <sjanssen> osaunders: it also reduces the amount of code one needs to read
17:03:33 <osaunders> sjanssen: Yes! Good point.
17:03:38 <byorgey> anavarro: indeed
17:05:57 <Philonous1> osaunders: Types make code easier to read. They are a form of documentation because they describe what you mean to do rather than how you do it. And they are checked by the compiler. So you miss a great opportunity for documentation by leaving them out.
17:06:47 <sjanssen> Philonous1: types make code easier to read to a point.  You don't add an explicit signature to every subexpression, do you?
17:06:55 <aavogt> leaving signatures off makes tracking type errors down difficult sometimes
17:07:06 <aavogt> but you can just add them in
17:07:17 <osaunders> Philonous1: Yes.
17:07:20 <osaunders> sjanssen: Also, yes.
17:07:54 <sjanssen> good release quality code will have a type signature for each top-level binding
17:07:55 <monochrom> When I wrote in Lisp, I wrote types in comments anyway.
17:08:09 <Philonous1> sjanssen: Of course not. I often even write code without types and later add them (or ask ghci), But once the code is stable I type at least top-level definitions
17:08:32 <sjanssen> but the ability to skip the signatures can be a life saver
17:08:35 <Philonous1> add types to*
17:08:51 <sjanssen> Philonous1: we basically agree
17:10:14 <anavarro> byorgey++
17:11:09 * Cale considers posting his ASW parody to the Haskell Prime mailing list and claiming that it's really important.
17:11:19 <byorgey> hahaha
17:11:52 <byorgey> that sounds a bit mean, although I'm sure most people would get a laugh out of it =)
17:12:20 <monochrom> What is ASW?
17:12:27 <Cale> A Softer World
17:12:40 <Cale> http://www.asofterworld.com/
17:12:52 <Cale> http://cale.yi.org/share/ASWParody.jpeg
17:13:50 <anavarro> byorgey: I read it on the wiki.
17:14:33 <osaunders> I stopped writing cards in Anki, I think it may have been a mistake.
17:14:49 <anavarro> byorgey: It's not a good idea?
17:15:01 <Cale> osaunders: cards for what?
17:15:05 <anavarro> :)
17:15:07 <osaunders> Haskell.
17:15:14 <Cale> Oh, interesting idea.
17:15:53 <osaunders> People have been critical because flashcards sound too simple to learn a PL but they aren't really flashcards (the way I've been doing them).
17:16:17 <Cale> Well, if they work for other languages...
17:16:34 <Cale> I've only ever thought about using anki to study Japanese, but never really considered using it to memorise details about a programming language.
17:16:38 <byorgey> anavarro: you read what on the wiki?
17:16:42 <osaunders> It's not exactly a fast process but it's thorough and pretty rigorous.
17:17:20 <McManiaC> hi
17:17:20 <osaunders> Cale: The other thing I like is that process of having to write the cards means I need to have a good understanding of stuff.
17:17:27 <byorgey> anavarro: oh, the ++ thing?
17:17:31 <osaunders> Otherwise the card is wrong or misleading.
17:17:37 <byorgey> anavarro: I was responding to Cale, not to you.  Thanks for the ++!
17:18:04 <McManiaC> I got a lot of IO (Maybe a) functions and always call it like "foo <- myIOMaybe; case foo of Nothing -> return (); Just a -> do ..."
17:18:09 <anavarro> ohhh
17:18:11 <anavarro> sorry
17:18:15 <McManiaC> is there any way to do this like the maybe monad?
17:18:17 <anavarro> :S
17:18:23 <byorgey> anavarro: heh, no problem =)
17:19:33 <Cale> McManiaC: You could MaybeT-transform the IO monad if you get the MaybeT package from Hackage.
17:19:34 <byorgey> McManiaC: you should make a function  whenJust :: Maybe a -> (a -> m ()) -> m ()
17:19:42 <Cale> McManiaC: however, you should do what byorgey says
17:19:49 <byorgey> IIRC it is defined in the IfElse package
17:20:14 <Cale> Actually, perhaps even  m (Maybe a) -> (a -> m ()) -> m () ?
17:20:27 <McManiaC> does this avoid that ugly "rightshift" of my function?
17:20:28 <byorgey> oh, sure
17:20:39 <byorgey> in IfElse they are called awhen and awhenM respectively
17:21:04 <byorgey> apparently the 'a' stands for 'anaphoric', whatever that means =)
17:21:08 <Peaker_> why is that preferred to using MaybeT?
17:21:16 <osaunders> When you say 5 + "foo" you get error that says "No instance for (Num [Char])" why does it say (Num [Char]) and not Num -> [Char] -> Bool or something.
17:21:54 <copumpkin> :t 5
17:21:56 <lambdabot> forall t. (Num t) => t
17:22:03 <copumpkin> that's why!
17:22:04 <byorgey> McManiaC: not really, for that you would have to use MaybeT IO I think
17:22:05 <Cale> osaunders: Because in order to treat 5 as a [Char], it would need an instance of Num for that
17:22:21 <Philonous> :t (+)
17:22:22 <osaunders> What's an instance?
17:22:23 <lambdabot> forall a. (Num a) => a -> a -> a
17:22:25 <Cale> osaunders: and it would have to do that because the parameters to + must have the same type
17:22:35 <Peaker_> > fromInteger 5 :: String
17:22:37 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
17:22:37 <lambdabot>    arising from a use of `GHC...
17:22:41 <byorgey> osaunders: have you learned about type classes?
17:22:45 <Cale> osaunders: An instance defines the methods of a typeclass at a specific type
17:22:51 <McManiaC> byorgey: okay, gonna take a look
17:22:52 * copumpkin is trying to write a histomorphism now!
17:23:03 <byorgey> go go go!
17:23:13 <osaunders> OK. I think I need to read more on typeclasses.
17:23:16 <Cale> osaunders: A typeclass captures a property that some type might have along with methods that it ought to have if that property is true
17:23:32 <McManiaC> byorgey: is there a "EitherT" also? ^^
17:23:44 <Cale> For example, Eq is a class to which types where (==) and (/=) make sense belong
17:24:16 <Peaker_> McManiaC: There should be, but unfortunately there's ErrorT instead (which is like a broken EitherT, heh)
17:24:24 <Cale> and Ord is a subclass of Eq for (<), (>), (<=), (>=), compare
17:24:50 <Cale> (being a subclass just means that if you want to write an instance of Ord, you must also provide an instance of Eq somewhere)
17:24:51 <McManiaC> Peaker_: why broken?
17:25:20 <byorgey> osaunders: type classes are kind of (but not exactly) like Java interfaces, if you are familiar with Java
17:25:26 <Cale> osaunders: typeclasses are used to constrain the types over which type variables range
17:25:38 <Peaker_> McManiaC: Because of the "Error" context of the Monad, which IMO doesn't belong there at all -- EitherT without it would be more useful
17:25:44 <Cale> For example, if you want to write a function to sort lists, it can't *quite* have the type [a] -> [a]
17:25:45 <osaunders> Cale: (Num a) => a
17:25:52 <osaunders> Yeah I know some of this.
17:25:57 <Cale> because you need to be able to compare values of type a in order to sort the list
17:26:08 <Cale> and so  sort :: (Ord a) => [a] -> [a]
17:26:11 <poe> Do you know if it is possible to devise a generic fold that ought to search for a specific constructor in a value of a type of class Data?
17:26:22 <Cale> Num is a typeclass for number-like types
17:26:49 <Cale> and has the operations (+), (*), fromIntegral, and a couple of other things which probably should be in another class
17:26:54 <osaunders> Cale: OK thanks. Don't say any more. :-)
17:27:07 <Cale> okay
17:27:17 <Cale> :t fromIntegral
17:27:19 <lambdabot> forall a b. (Integral a, Num b) => a -> b
17:27:27 <Cale> ^^ I will give you that to stare at though ;)
17:27:30 <Cale> er
17:27:33 <Cale> :t fromInteger
17:27:34 <lambdabot> forall a. (Num a) => Integer -> a
17:27:39 <Cale> sorry, that's the one :)
17:28:01 <mightybyte> Is quickcheck 2 available from cabal?
17:29:29 <McManiaC> Peaker_: ErrorT looks like what I've been looking for tho
17:29:30 <McManiaC> :)
17:29:38 <Cale> anaphora. 1. a. Rhet. The repetition of the same word or phrase in several successive clauses. b. Gram. The use of a word which refers to, or is a substitute for, a preceding word or group of words. 2. [late Gr., f. Gr. {alenis}{nu}{alpha}{phi}{omicron}{rho}{gaacu} offering.] Liturgiol. That part of the Eucharistic service which includes the consecration, oblation, and communion; in the Western Church, the canon of th
17:29:38 <Cale> e mass. Hence a'naphoral a.  anaphoric, a. (and n.) Of, pertaining to, or constituting anaphora (sense 1b); referring to or standing for a preceding word or group of words. Hence as n., an anaphoric word.
17:30:02 * Cale does not understand the sense in which awhen is anaphoric.
17:30:03 <McManiaC> although I dont think I really understood it yet
17:30:04 <McManiaC> ^^
17:31:12 <poe> Cale maybe that's for another meaning of anaphoric
17:31:32 <poe> http://www.bookshelf.jp/texi/onlisp/onlisp_15.html
17:32:04 <roconnor> > replicateM 2 [0..3]
17:32:05 <lambdabot>   [[0,0],[0,1],[0,2],[0,3],[1,0],[1,1],[1,2],[1,3],[2,0],[2,1],[2,2],[2,3],[3...
17:33:42 <Cale> poe: ah, okay, I understand how it relates to the English definition now.
17:33:49 <poe> Yeah it makes sense
17:35:31 <copumpkin> my fibonacci hylomorphism doesn't terminate!
17:35:50 <McManiaC> damn, ErrorT is cool :)
17:37:48 <copumpkin> yeehaw
17:37:49 * BMeph much prefers an amphora to an anaphjora. "But I digress..." ;)
17:37:53 <copumpkin> I'm on a rollomorphism
17:38:54 <BMeph> @hoogle gfold
17:38:56 <lambdabot> Data.Graph.Inductive.Basic gfold :: Graph gr => (Context a b -> [Node]) -> (Context a b -> c -> d) -> (Maybe d -> c -> c, c) -> [Node] -> gr a b -> c
17:38:56 <lambdabot> Data.Data gfoldl :: Data a => (c (d -> b) -> d -> c b) -> (g -> c g) -> a -> c a
17:38:56 <lambdabot> Data.Generics.Twins gfoldlAccum :: Data d => (a -> c (e -> r) -> e -> (a, c r)) -> (a -> g -> (a, c g)) -> a -> d -> (a, c d)
17:39:19 <poe> BMeph lots going on in those types :^)
17:39:27 <copumpkin> ddarius: I gave in and asked Cale to explain the presheaf functor on C to me :) it's pretty neat though
17:45:09 <BMeph> poe: True, true. However, you were asking about Data, right? :)
17:46:36 <poe> Yes. Consider an adbritrarily complex type deriving Data, possibly containing other ones inside (also deriving Data), I'd like to search for one instance of a constructor or perhaphs all instances as well
17:49:24 <mmorrow> @remember copumpkin I'm on a rollomorphism
17:49:25 <lambdabot> Okay.
17:49:31 <copumpkin> :P
17:49:35 <mmorrow> :)
17:50:27 <tensorpudding> that's terrible
17:50:46 <copumpkin> hmm, my histomorphism is wrong
17:51:11 <centrinia> What is a histomorphism?
17:51:32 <copumpkin> I have just the slides for you! http://www.cs.ioc.ee/~tarmo/tday-viinistu/kabanov-slides.pdf
17:51:51 <dolio> histomorphisms remember the recursion tree, so you can refer to the results of all recursive calls you make.
17:52:46 <centrinia> Hmm.
17:52:57 <copumpkin> it's pretty fun stuff
17:53:00 <copumpkin> I'm doing it all from scratch
17:53:12 <dolio> For instance, for writing a more efficient fibonacci algorithm.
17:53:21 <copumpkin> category-extras is rather painful
17:53:33 <copumpkin> yeah! that's what I'm doing now! my hylo-based fibonacci is slow
17:54:04 <copumpkin> (slower than it should be even given the unary numbers)
17:54:04 <poe> If only I understood the syntax of those slides... :)
17:54:40 <poe> BMeph anyway, it feels to me possible, but it's also complicated to approach.
17:55:28 <abuiles> Hi guys, I'm trying to implement some code written using functional dependencies, but using type families, an I got an error which I haven't been able to fix, doesn't some know what's going ong? .. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5202#a5202   thanks  :)
18:01:12 <osaunders> Will the next version of GHC implement Haskell 2010?
18:01:40 <ClaudiusMaximus> anyone used any of those "generate low-level dsp code from haskell" thingies (atom, feldspar, probably some more exist...)?  i'm getting fed up with FAuSt's limitations and bugs
18:01:43 <centrinia> I thought it already does.
18:01:49 <MarcWeber> Is there a haskell library which can apply patch files to bytestrings or such?
18:02:17 <BMeph> poe: You're talking about having the compiler auto-derive gfoldl for you, right? :)
18:02:48 <BMeph> To the channel: Is there a reason why Data.Data et al. uses gfoldl and not gfoldr? :)
18:03:53 <mightybyte> Can quickcheck 2 be installed with cabal-install or do you have to do it manually?
18:04:44 <BMeph> osaunders: The last version of GHC does, and there's no plans I know of to quit doing so. "Haskell 2010" is just so folks quit whinging about "Haskell 98? But '98 was so long ago, that standard is ancient!" :)
18:05:15 <tensorpudding> oh man, whinging
18:05:35 <osaunders> BMeph: Its the topic of the channel. Makes it seem important.
18:05:38 <dpratt71> taking Cabal for a spin for the first time (via HaskellDB) and I'm having a spot of trouble; presently, I'm just trying to figure out if the problem is me, the package, the platform I'm using, or...?
18:06:30 <dpratt71> did "cabal install haskelldb", which generated a lot of output, but no obvious errors
18:06:32 <McManiaC> http://npaste.de/67/ why does this give me an exception anyway instead of a "Left ..."?
18:06:43 <MarcWeber> McManiaC: Which exception?
18:07:02 <McManiaC> well, the usual "file does not exist"
18:07:30 <BMeph> McManiaC:  Here's a hint: Why do you expect it NOT to give you an exception? ;)
18:07:52 <poe> BMeph no no
18:08:06 <McManiaC> because it is the Error monad and theres an errort instance for IO
18:08:24 <BMeph> poe: Okay, then I misunderstood. What are you asking for, again? ;)
18:09:00 <ivanm> McManiaC: my guess is that its the wrong type of exception
18:09:16 <poe> BMeph I'm happy that it does derive instances for Data, I'm not sure about how to use the (quite complicated at first sight) primitives to do the equivalent of  find  and  filter  for a certain constructor.
18:09:20 <dpratt71> is Cabal used much by experienced Haskellers?
18:09:23 <ivanm> McManiaC: because AFAIK, exceptions in IO don't automatically become Left
18:09:32 <ivanm> dpratt71: almost all Haskell apps use Cabal
18:09:39 <ivanm> (at least the ones that are publically released)
18:09:53 <Peaker> McManiaC: liftIO <something>  cannot affect the outer monads (e.g ErrorT) - its only doing something in IO
18:10:05 <ivanm> dpratt71: the only ones that aren't are those that were from before Cabal, or have weird build requirements that Cabal can't cope with
18:10:27 <McManiaC> http://hackage.haskell.org/packages/archive/monads-tf/0.0.0.1/doc/html/Control-Monad-Error.html#4
18:10:28 <dpratt71> ivanm: ok, thanks; maybe I'll try to sort out what the package is instructing Cabal to do during an install
18:10:32 <McManiaC> i dont see the difference :S
18:10:37 <Peaker> McManiaC: there can be a combinator:  ErrorT IO a -> ErrorT IO a that converts IO exceptions to Left, though
18:11:17 <dpratt71> wasn't my goal to learn all about Cabal, but...oh well, probably a worthwhile enterprise :)
18:11:26 <ivanm> dpratt71: try pasting the entire build log up somewhere for us to look at if you can't work it out
18:11:27 <Peaker> McManiaC: to raise an Error in ErrorT, you have to have an action in the ErrorT monad, not in some inner monad
18:11:59 <McManiaC> hmmm
18:12:10 <dpratt71> ivanm: will do; is such a log generated by default?
18:12:24 <ivanm> dpratt71: nope; copy-paste what it spits out
18:12:28 <poe> I suppose you can catch the IO Exception and recast it with throwError ?
18:12:34 <ivanm> dpratt71: if you're using *nix, then apps like wgetpaste are good for this kind of stuff
18:12:40 <Peaker> poe: that's what I meant by the combinator above
18:12:40 <ivanm> poe: yup
18:12:59 <McManiaC> gotta go, nn
18:12:59 <Peaker> perhaps its wrong to call such an effectful beast a "combinator"
18:13:04 <dpratt71> ivanm: not *nix; wondering if that may be part of the issue, actually
18:13:07 <poe> But then using two different exception mechanisms is not pretty :/
18:13:08 <osaunders> Does the author of en.wikibooks.org/wiki/Haskell hang on this channel?
18:13:20 <osaunders> s/hang on/hang out/
18:13:48 <Peaker> poe: I wish IO was split to EitherT for errors, some reference-state monad instead of IORefs, etc
18:14:00 <osaunders> s/author/principal author/
18:14:06 <ivanm> dpratt71: quite possibly...
18:14:15 <ivanm> osaunders: any idea who it is?
18:15:42 <osaunders> ivanm: http://en.wikibooks.org/wiki/User:Kowey ?
18:16:27 <ivanm> ahhh
18:16:33 <ivanm> preflex: seen kowey
18:16:34 <preflex>  kowey was last seen on #haskell 47 days, 12 hours, 49 minutes and 59 seconds ago, saying: mystery left unsolved, but who cares!
18:16:39 <ivanm> osaunders: he's sometimes here
18:19:01 <osaunders> preflex: help
18:19:02 <preflex>  try 'help help' or see 'list' for available commands
18:19:08 <osaunders> preflex: list
18:19:09 <preflex>  Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen]; ZCode: [zdec, zenc]
18:19:21 <osaunders> preflex: help help
18:19:21 <preflex>  help COMMAND - show help for a command
18:19:56 <osaunders> preflex: help Karma
18:19:57 <preflex>  unknown command: Karma
18:20:02 <osaunders> preflex: help karma
18:20:02 <preflex>  karma NICK - print a user's karma
18:20:09 <ivanm> osaunders: /msg preflex help foo
18:20:09 <BMeph> osaunders: I'd've figured you'd already been told this, but: "This is #haskell. Don't ask to ask, just ask." :)
18:20:10 <ivanm> ;-)
18:20:17 <dpratt71> as requested, the output generated by "cabal install haskelldb": http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5205#a5205
18:20:26 <ivanm> BMeph: which is the usual policy for IRC AFAIK
18:20:47 <ivanm> dpratt71: ghc-pkg list doesn't contain haskelldb?
18:20:53 <ivanm> because it sure looks like it works...
18:21:00 <osaunders> BMeph: Why are you saying that to me?
18:21:01 <ivanm> does ghc-pkg check say anything?
18:21:43 <BMeph> ivanm: O RLY? I thought the usual policy for IRC was "Hurl abuse at the first question, and if they ask again, THEN answer. Usually, with a raspy 'F--- u!'" ;)
18:21:58 <dpratt71> ghc-pkg complains about Haddock
18:22:03 <ivanm> BMeph: heh
18:22:11 <ivanm> dpratt71: oh? what does it say?
18:23:12 <dpratt71> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5206#a5206
18:23:27 <ivanm> >_>
18:23:29 <ivanm> <_<
18:23:34 <dpratt71> note: it may simply be my expectations that need adjusting
18:23:39 * ivanm has no idea what's happening there
18:23:45 <ivanm> dpratt71: nope, looks like breakage to me
18:23:53 <BMeph> osaunders: Sorry, I thought you had a Wikibook-related question. I'll go back to my usual oddball off-the-cuff (and -wall) remarks. :)
18:24:07 <copumpkin> BMeph: carry on
18:24:08 <dpratt71> ivanm: ok, I'll investigate, thanks much
18:24:24 <BMeph> copumpkin:  o7
18:24:27 * dpratt71 runs away
18:24:55 <osaunders> BMeph: OK.
18:25:04 <osaunders> BMeph: I don't really have anything to ask.
18:25:12 <osaunders> But I'm sure I will soon :-)
18:25:22 <roconnor> @src sequence
18:25:23 <lambdabot> sequence []     = return []
18:25:23 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
18:25:23 <lambdabot> --OR
18:25:23 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
18:25:32 <roconnor> @src mapM
18:25:33 <lambdabot> mapM f as = sequence (map f as)
18:38:51 <kmc_> preflex, be lambdabot
18:38:52 <preflex>  no quotes found for lambdabot
18:39:51 <osaunders> I'm so easily distracted.
18:50:13 <ddarius> Werner Forssmann is a badass.
18:51:14 <copumpkin> yay, I figured out fibonacci using a histomorphism
18:51:20 <copumpkin> as the hylomorphism was unsatisfactory
18:52:00 <copumpkin> http://snapplr.com/zn4w
18:53:05 <ddarius> copumpkin: Did you work out the subobject classifier for the topos of graphs?
18:53:51 <copumpkin> ddarius: nope, was trying to figure out where you got that 2-node 5-edge graph from yesterday, but I don't even really understand what the subobject classifier "means" in the context of that category/topos
18:53:57 <copumpkin> so that's a bit of a hindrance
18:57:38 <ddarius> copumpkin: It's a wonderful example that is covered in the Barr and Wells lecture notes, or I could cover it briefly here.
18:58:57 <Thomas2> hey all
18:59:11 <Thomas2> would you expect (a `div` b) to do the same thing as (div a b)?
18:59:21 <jmillikin> Yes
18:59:23 <ddarius> Thomas2: They mean the exact same thing.
18:59:57 <Thomas2> aha, I might have figured it out
19:00:11 <Thomas2> oops, my bad
19:00:23 <Thomas2> -13 `div` 3 parses as - (13 `div` 3)
19:00:45 <Thomas2> which is just about loopy enough to consider a feature
19:01:10 <idnar> ugh what
19:01:38 <idnar> unary minus is so awful
19:01:59 <copumpkin> ddarius: found the example in barr & wells, seeing if I can soak it in :)
19:02:27 <ddarius> copumpkin: It's a good example for demonstrating subobject classifier.  Very visceral, but not so pedestrian as Set's.
19:03:02 <copumpkin> yeah, the only subobject classifiers I've come across so far have been Set and the odd thing from psykotic about Bayes
19:05:05 <ddarius> Now I need to derive the graph subobject classifier from the general definition of a subobject classifier for a presheaf.  I thought about it last night, but it was like 3:30 AM and I needed to get up at 6:30.
19:05:36 <copumpkin> I think I get it!
19:05:44 <copumpkin> ack, 6:30 is rough
19:05:56 <tensorpudding> lol
19:06:00 <tensorpudding> get more sleep
19:06:53 <roconnor> > transpose [[
19:06:54 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:06:59 <roconnor> > transpose http://en.wikipedia.org/wiki/Special:Search?go=Go&search=],[
19:07:00 <lambdabot>   <no location info>: parse error on input `='
19:07:06 <copumpkin> nice
19:07:08 <roconnor> huh?
19:07:11 <roconnor> > transpose http://en.wikipedia.org/wiki/Special:Search?go=Go&search=],[
19:07:12 <lambdabot>   <no location info>: parse error on input `='
19:07:14 <copumpkin> lol
19:07:15 <roconnor> grrr
19:07:27 <copumpkin> when doubting referential transparency, try again
19:07:29 <roconnor> > transpose [[] , []]
19:07:30 <lambdabot>   []
19:07:53 <roconnor> [[magic double square brackets in IRC client]]
19:08:02 <roconnor> hmm
19:08:23 <roconnor> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=magic-double-square-brackets-in-IRC-client
19:09:12 <roconnor> I guess lists and vectors are not quite the same
19:09:14 * ddarius dislikes magic.
19:09:30 <copumpkin> those barr & wells notes actuall seem quite clear
19:09:40 <copumpkin> I've avoided them so far because I'm impatient and such a large chunk of stuff is daunting
19:09:41 <ddarius> copumpkin: They are definitely one of my favorites.
19:09:44 <copumpkin> but I may give it a real go
19:10:40 <ddarius> copumpkin: The only thing that makes them less than perfect is the complete lack of coverage of (co)ends, indexed (co)limits, and Kan extensions.
19:11:54 * roconnor makes 12x12 colouring challenges
19:11:56 <copumpkin> I'll survive for now :) I doubt I'll come across those for another little while though, at the level I'm at right now
19:13:27 * osaunders is saturated with Haskell (Hasturated?)
19:13:37 <ddarius> In my opinion, it's highly helpful to have a grasp of, particularly, (co)ends and indexed (co)limits, early on as they are much more manipulable and about as simple from a representability perspective.
19:13:50 <copumpkin> oh
19:13:57 <copumpkin> what do you recommend for good coverage of them then?
19:14:33 <copumpkin> TTT covers Kan extensions I think
19:15:41 <ddarius> There is no good introductory coverage.  I believe Daniell Turi (or someone) has a CT introduction that covers them to some extent, but the only good comprehensive account (freely available) is "Basic Concepts of Enriched Category Theory"  Which is really good but has a bunch of extraneous stuff and is pretty imposing.
19:15:51 <copumpkin> hah, I just randomly came across "free triples" in TTT and just wrote them earlier in the module I'm working on earlier
19:15:53 <ddarius> I'd highly recommend reading it at some point.
19:16:30 <ddarius> copumpkin: I've read TTT several times.  The last time it was because I really wanted specific results in it.
19:17:00 <ddarius> copumpkin: The exercises in the first chapter of TTT are excellent though.
19:17:12 <copumpkin> cool, I'll give those a go too
19:17:17 <copumpkin> christmas break is coming up :D
19:17:20 <copumpkin> http://www.dcs.ed.ac.uk/home/dt/CT/categories.pdf ?
19:17:48 <copumpkin> hmm, doesn't seem to contain the word coend
19:18:48 <dibblego> what other [] Applicatives are there besides the standard one and ZipList?
19:18:58 <copumpkin> all Monad instances
19:19:00 <roconnor> dibblego: how many do you want?
19:19:01 <copumpkin> oh wait
19:19:03 <copumpkin> lol
19:19:07 <dibblego> roconnor, a billion!
19:19:11 <copumpkin> dibblego: there's the Omega one, sort of
19:19:17 <dibblego> copumpkin, oh?
19:19:25 <copumpkin> @hackage control-monad-omega
19:19:25 <lambdabot> http://hackage.haskell.org/package/control-monad-omega
19:19:38 <roconnor> dibblego: there is the one that always returns []
19:19:42 <copumpkin> it's only a monad if you look through a blurry lens
19:19:57 * roconnor thinks that is a monad
19:20:06 <ddarius> copumpkin: That may or may not cover Kan extensions.  I'd have to look around to find the particular one that also covered ends and such, but (in my opinion) it wasn't a terribly good introduction.
19:20:09 <dibblego> yeah good point
19:20:29 <copumpkin> yeah :) but maybe a newtype around [] called UnorderedList or something would make it less questionable
19:20:52 <copumpkin> ddarius: I'll read up on whatever I can find, in the meantime
19:21:01 <roconnor> return x = []
19:21:09 <roconnor> y >>= f = []
19:21:11 <roconnor> :)
19:21:26 <path[l]_> are there video lectures on haskell?
19:21:30 <roconnor> yes
19:21:38 <path[l]_> :o
19:21:39 <copumpkin> are the number of monads on [] finite? countable?
19:21:48 <copumpkin> *is
19:21:51 <xternal> there's a series of lectures based around the Haskell book
19:22:08 <xternal> at msdn, iirc.  I think it's posted like mad on the haskell subreddit
19:22:23 <path[l]_> oh
19:22:31 <path[l]_> on msdn ... heh interesting
19:22:40 <ddarius> I can give you a site with a lot of (shorter) introductions to CT, but most of them are pretty repetitive.  The Awodey book is a pretty good introduction but also doesn't cover ends and co.
19:23:00 <copumpkin> yeah, I already have the awodey book, and am slowly making my way through it
19:23:10 <copumpkin> but sure, any additional material you have would be very helpful
19:23:44 <xternal> http://www.reddit.com/r/haskell/search?q=erik+meijer
19:24:11 <ddarius> copumpkin: I really like the exercise in TTT called "Coequalizers can be big"
19:24:30 <xternal> first video: http://channel9.msdn.com/shows/Going+Deep/Lecture-Series-Erik-Meijer-Functional-Programming-Fundamentals-Chapter-1/
19:24:41 <xternal> I think they all chain off that one.
19:25:01 <roconnor> copumpkin: I suspect that the number of polymorpic functions of type return and bind are finite.
19:25:07 <sshc> how would Either be defined as a functor?
19:25:10 <roconnor> copumpkin: making the number of possible monads finite.
19:25:33 <roconnor> djinn can probably enumareate all the return and bind functions
19:25:55 <copumpkin> can djinn enumerate functions outside of lambdabot?
19:26:06 <copumpkin> I've wanted that
19:26:09 <roconnor> I am lead to believe so
19:26:10 <copumpkin> but never used it on its own
19:26:13 <roconnor> but I have never tried
19:26:24 <copumpkin> and it can deal with recursive datatypes?
19:26:32 <roconnor> I'm told that it might
19:26:38 <copumpkin> :)
19:26:39 <path[l]> thanks xternal
19:26:48 <xternal> you're welcome
19:26:53 <path[l]> hmm this is a functional programming fundamentals
19:26:54 <roconnor> I could be sadly mistaken
19:27:06 <xternal> he goes through the Haskell book though, path[l]
19:27:18 <ddarius> copumpkin: http://www.cs.le.ac.uk/people/akurz/books.html
19:27:23 <xternal> I haven't watched them all, but, it may prove interesting
19:27:26 <roconnor> copumpkin: oh crap
19:27:34 <roconnor> copumpkin: there are an infintie number of return functions :(
19:27:42 <ddarius> djinn is a separate commandline tool
19:27:52 <copumpkin> roconnor: [], [a], [a,a], [a,a,a] ?
19:27:55 <ddarius> roconnor: Now apply the monad/functor laws.
19:27:55 <roconnor> yep
19:27:59 <copumpkin> roconnor: the question is, how many of those satisfy the laws?
19:28:21 <copumpkin> I'd imagine most of them would get pruned
19:28:31 <copumpkin> unless there's some sort of fancy construction
19:28:34 <ddarius> copumpkin: Computational Category Theory is an interesting read.
19:28:35 <Thomas2> i convinced myself a while ago that the list monad was the only possible monad within its type
19:28:44 <roconnor> are there fewer bind functions?
19:28:53 <poe> so another is return x = [[]] = y >>= f and so on
19:28:58 <copumpkin> roconnor: it also seems like enumerating join functions would be easier than thinking about bind
19:30:06 <roconnor> copumpkin: ah, there are even more join functions
19:30:18 <roconnor> map (!!0)
19:30:20 <roconnor> map (!!1)
19:30:21 <ddarius> Thomas2: I'm pretty sure there are a few other possibilities.
19:30:22 <roconnor> ...
19:30:34 <roconnor> suitably fixed up to handle errors gracefully
19:30:36 <copumpkin> roconnor: but none of those would satisfy the laws
19:30:44 <ddarius> roconnor: Again, the monad laws will significantly constrain the possibilities.
19:31:12 <copumpkin> it'd be interesting to see if we can enumerate the possible monads over a type in a principled way
19:31:13 <poe> anybody has the laws handy?
19:31:21 <copumpkin> rather than just pruning them off from the space of all possible functions
19:31:24 <ddarius> copumpkin: Incidentally, this NUMDAM site http://www.numdam.org/ is handy for finding several older CT papers.
19:31:25 <copumpkin> (of that type)
19:31:28 <lazni> @src ??
19:31:28 <lambdabot> Source not found. :(
19:31:30 <Thomas2> ddarius: that's what I thought to begin with
19:31:36 <copumpkin> ddarius: merci beaucoup
19:32:25 <ddarius> join . fmap join = join . join, join . return = join . fmap return plus the functor laws fmap id = id, fmap (f . g) = fmap f . fmap g
19:32:51 <ddarius> Thomas2: The differences would correspond roughly to different search orders.
19:33:48 <poe> OK constant functions satisfy all of those, [] [[]] [[[]]] ...
19:33:49 <path[l]> ugh
19:33:51 <path[l]> dced
19:34:19 <path[l]> xternal: I might be wrong but I think I know whats usually covered in these introduction to functional programming things. I was hoping more for a lecture series from a university
19:34:27 <copumpkin> poe: those have different types
19:34:44 <xternal> Ah, I see.  well, if I think of anything, I'll post it
19:34:54 <path[l]> oh it's 1 of 13
19:34:56 <poe> copumpkin right, different monads, not different instance of []
19:34:56 <xternal> might try the haskell subreddit, if such a thing exists, I'm sure it's there.
19:35:00 <copumpkin> oh
19:35:06 <path[l]> maybe I underestimated it
19:35:10 <path[l]> 13 lectures is a lot
19:35:55 <nnyby> i don't have much experience with the IO monad.. can someone tell me what's going on here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13422#a13422
19:36:49 <mmorrow> this is kind of neat: all paths through (this particular) control-flow-graph starting at the entry and either ending in (1) and exit, or (2) a loop,  http://moonpatio.com/images/CFG_0-800_600.png
19:37:02 <mmorrow> s/and exit/an exit/
19:37:21 <copumpkin> mmorrow: cool, what made those?
19:37:50 <mmorrow> copumpkin: i just made them using a combo of andyjgill's dotgen and imagemagick montage
19:37:55 <copumpkin> you gonna solve the halting problem next?
19:38:13 <mmorrow> copumpkin: yes, but after i get a snickers icecream bar
19:38:16 <mmorrow> :)
19:38:19 <copumpkin> mmm, I want one too
19:38:22 <mmorrow> sooo good
19:40:10 <copumpkin> http://snapplr.com/pgbd
19:41:51 <jmillikin> Is there any way to find out which changes were made between different versions of "base"?
19:42:18 <jmillikin> I'm extracting / modifying some code from a library which is "base >= 2", and would like to make sure I don't accidentally add dependencies on a more modern version.
19:43:50 <mmorrow> copumpkin: here's the code + exactly the ghci+sh i used to make that one http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5207
19:44:08 <copumpkin> nice
19:44:42 <dfdf> nnyby: the last line is not a IO command, just a bool value.
19:44:44 <mmorrow> copumpkin: i hacked Text.Dot minorly though, since i needed to add "graph"/"edge"/"node" attrs + regular attrs, and some other misc and it didn't do that
19:44:53 <mmorrow> i can stick that somewhere too if you're interested
19:45:08 <dfdf> nnyby : try return ((matchResult r1 r2) : scores)
19:45:12 <mmorrow> @type Data.Tree.unfoldTreeM_BF
19:45:14 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (b -> m (a, [b])) -> b -> m (Tree a)
19:45:15 <mmorrow> @type Data.Tree.unfoldForestM_BF
19:45:17 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (b -> m (a, [b])) -> [b] -> m (Forest a)
19:45:22 <mmorrow> and the goods!
19:45:39 <mmorrow> a/and/are/
19:45:40 <mmorrow> !
19:46:24 <mmorrow> gah, my muscle memory for the word "and" seems to overpower any other a<one-three-letter> word
19:47:03 <mmorrow> oh, and
19:47:11 <mmorrow> (‚àà) = IS.member
19:47:18 <mmorrow> (<<) = flip IS.insert
19:47:49 <ddarius> @hoogle (<<)
19:47:50 <lambdabot> Text.Html (<<) :: HTML a => (Html -> b) -> a -> b
19:47:50 <lambdabot> Text.XHtml.Frameset (<<) :: HTML a => (Html -> b) -> a -> b
19:47:50 <lambdabot> Text.XHtml.Strict (<<) :: HTML a => (Html -> b) -> a -> b
19:50:33 <mmorrow> copumpkin: and here's that slightly modified Dot module http://moonpatio.com/repos/Dot.hs
19:50:48 <copumpkin> cool
19:50:53 <mmorrow> copumpkin: i think that's everything needed to reproduce that image, should you be so inclined
19:50:54 <copumpkin> I vaguely remember modifying dot myself a while back
19:51:32 <mmorrow> oh, last this is  (!) = IM.!
19:51:39 <mmorrow> s/this/thing/
19:52:48 <mmorrow> copumpkin: i've been meaning to use ivanm's lib for a while now
19:52:50 <copumpkin> @check \(Positive x) (Positive y) -> gcd x y * lcm x y == x * y
19:52:51 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary
19:52:52 <lambdabot>                     (Test.QuickC...
19:53:06 <copumpkin> @check \(Positive x) (Positive y) -> gcd x y * lcm x y == (x * y :: Int)
19:53:07 <lambdabot>   No instance for (Test.QuickCheck.Arbitrary
19:53:07 <lambdabot>                     (Test.QuickC...
19:53:12 <mmorrow> dotgen is just so tempting because it's a single hackable module..
19:53:21 <copumpkin> yeah
19:57:38 <roconnor> > product [1..17]
19:57:40 <lambdabot>   355687428096000
19:57:48 <roconnor> > (product [1..17])^2
19:57:50 <lambdabot>   126513546505547170185216000000
19:58:01 <roconnor> > logBase 10 (product [1..17])^2
19:58:03 <lambdabot>   211.73359493281072
19:58:07 <roconnor> > logBase 10 ((product [1..17])^2)
19:58:09 <lambdabot>   29.102137030315195
19:58:57 <mmorrow> copumpkin: oh cool, just noticed http://snapplr.com/pgbd
19:59:03 <mmorrow> copumpkin: are you using category-extras?
19:59:11 <copumpkin> mmorrow: nope, rewrote it all from scratch
19:59:19 <copumpkin> even the number addition used there is using catamorphisms :P
19:59:19 <mmorrow> copumpkin: nice
19:59:24 <copumpkin> it's a morphism overload
19:59:24 <mmorrow> hehe
19:59:38 <mmorrow> a morphasm?
19:59:43 <copumpkin> lol
19:59:53 <mmorrow> :)
20:00:25 <copumpkin> @remember mmorrow [regarding excessive use of categorical recursion schemes] a morphasm?
20:00:26 <lambdabot> I will never forget.
20:03:38 * hackagebot upload: failable-list 0.1 - A list-like type for lazy streams, which might terminate with an error. (JohnMillikin)
20:04:36 <copumpkin> @hackage failable-list
20:04:36 <lambdabot> http://hackage.haskell.org/package/failable-list
20:05:03 <jmillikin> It's dcoutts' ``Events'' type, extracted to a generic library.
20:05:09 <copumpkin> ah
20:05:16 <Veinor> @djinn (Eq a) => a -> a -> a -> Bool
20:05:17 <lambdabot> f a b _ = a == b
20:05:17 <copumpkin> looks neat :)
20:05:28 <Veinor> @djinn (Eq a) => a -> a -> a -> a -> Bool
20:05:29 <lambdabot> f a b _ _ = a == b
20:05:32 * copumpkin is trying to figure out how to do levenstein as a histomorphism now
20:05:39 <Veinor> @djinn (Eq a) => (a -> a) -> (a -> a) -> a -> Bool
20:05:39 <lambdabot> f a _ b = b == a b
20:06:17 <ddarius> Veinor: Djinn tries to use each variable exactly once before moving on to other solutions (lambdabot only shows the first solution)
20:06:29 <Veinor> ahh.
20:06:42 <Veinor> I was expecting \f g x -> f x == g x
20:06:57 <ddarius> Veinor: Use a more general type.
20:07:04 <ddarius> :t \f g x -> f x == g x
20:07:06 <lambdabot> forall t a. (Eq a) => (t -> a) -> (t -> a) -> t -> Bool
20:07:15 <ddarius> @djinn Eq a => (t -> a) -> (t -> a) -> t -> Bool
20:07:16 <lambdabot> f a b c = b c == a c
20:07:19 <Veinor> ahhh.
20:07:39 <Veinor> @unpl \f g x -> f x == g x
20:07:40 <lambdabot> \ f g x -> (f x) == (g x)
20:07:47 <ddarius> The more general your types are, the less possible implementations.
20:07:47 <Veinor> whoops
20:07:51 <Veinor> @pl \f g x -> f x == g x
20:07:52 <lambdabot> liftM2 (==)
20:08:07 <copumpkin> @@ @pl @djinn Eq a => (t -> a) -> (t -> a) -> t -> Bool
20:08:07 <Veinor> I need to understand the Arrow and List monad sometime :./
20:08:08 <lambdabot>  f = flip (liftM2 (==))
20:08:13 <roconnor> @type zipWith (++)
20:08:15 <lambdabot> forall a. (Monoid a) => [a] -> [a] -> [a]
20:08:18 <Veinor> what does @@ do?
20:08:24 <copumpkin> Veinor: composes lambdabot plugins
20:08:27 <Veinor> ahh.
20:08:59 <Veinor> I'm trying to imagine a useful instance of Eq where == is not commutative now :P
20:08:59 <copumpkin> some of them are misbehaved though
20:09:09 <copumpkin> :O
20:09:20 <copumpkin> symmetric?
20:09:34 <Veinor> if you view it as a statement, it'd be symmetric
20:09:43 <Veinor> if you view it as function, commutative :P
20:10:07 <roconnor> Veinor: acutally when I was developing my theory of metric spaces in coq, it really looked like I could dispense with symmetry.
20:10:27 <roconnor> But I would have to be more careful than I was willing to be.
20:10:29 <Veinor> ?
20:10:41 <roconnor> symmetry of the metric
20:10:48 <Veinor> well, that's metric.
20:11:08 <Veinor> I don't think == is really a metric. :P
20:11:12 <roconnor> equality is just points that are within 0 of each other.
20:11:28 <Veinor> true
20:12:19 <Veinor> but can you define it usefully where a == b doesn't imply b == a?
20:12:21 <roconnor> not sure
20:12:23 <roconnor> I suspect
20:12:33 <roconnor> though I wold hesiate to use the == symbol.
20:12:38 <Veinor> well, yeah.
20:13:05 <Veinor> > let (==) = (-) in 2 == 3
20:13:06 <lambdabot>   -1
20:13:10 <Veinor> :P
20:14:00 <copumpkin> > let (‚Äì) = (-) in -2 == (‚Äì2) 0
20:14:01 <lambdabot>   True
20:14:54 <shepheb> for extra credit, abuse overriding on >>= and abuse do-notation too.
20:17:20 <mmorrow> i always forget that you can do that
20:17:42 <mmorrow> (that := ghc'll use whatever (>>=) is in scope for desugaring do)
20:18:17 <mmorrow> that could be interesting
20:19:17 <mmorrow> import qualified Prelude as P; (>>=) = unsafeFireMissiles; return = breathingMachineOff; foo = do ....
20:19:23 <KitB> Quick (and I'm sure trivial) question: How does one take something of type "IO a" and return the equivalent something of type "a" classically?
20:19:43 <dmwit> KitB: You don't.
20:19:53 <KitB> Okey dokey
20:19:59 <KitB> How do you avoid it?
20:20:11 <mmorrow> KitB: you push the entire rest of the program that needs that `a' /inside/ the IO
20:20:12 <dmwit> You lift the function you were going to apply to the 'a' into IO instead.
20:20:36 <mmorrow> @type \f m -> return . f =<< m
20:20:37 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> a) -> m a1 -> m a
20:20:40 <dmwit> :t (=<<)
20:20:43 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
20:21:04 <mmorrow> @type \f m -> f =<< m
20:21:06 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
20:21:11 <dmwit> (=<<) is a function that takes another function that should apply to pure values, and applies it to IO values instead. =)
20:21:39 <dmwit> :t liftM -- another kind of lifting that is also often handy
20:21:41 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
20:21:48 <KitB> Thanks for the help, I'll see if I can find a prettier way of doing this particular instance
20:21:53 <mmorrow> main = return . anotherPurePart =<< myIOPart . myPureProgram =<< getLine
20:21:58 <dmwit> ew, why such a horrible type for liftM?
20:22:12 <dmwit> KitB: I would also suggest
20:22:19 <dmwit> ?go the io monad for people who just don't care
20:22:21 <lambdabot> Maybe you meant: google googleit do
20:22:25 <dmwit> ?google the io monad for people who just don't care
20:22:27 <lambdabot> No Result Found.
20:22:35 <mmorrow> (or equivalently) main = getLine >>= myIOPart . myPureProgram >>= return . anotherPurePart
20:22:52 <KitB> Considering this is working within an algebraic data type
20:22:55 <mmorrow> but using (.) makes (>>=) backwards
20:22:55 <dmwit> KitB: ...that (which does exist, despite what lambdabot says), and saying here what you're trying to achieve and what you've tried, since we like helping with that kind of thing. =)
20:23:18 <ddarius> lambdabot's @google is finnicky.
20:27:00 <mmorrow> KitB: one way to see why "getting the a out of (m a)" for some monoid m doesn't make sense in general is to consider the list or Maybe monads. in the first case, how do you choose which elem of the list to take? what if it's empty? in the second case,   whhhat if it's Nothing?
20:27:07 <mmorrow> h-stick
20:28:08 <KitB> Ok that makes sense (somewhat, I'm a little too tired for real learning atm)
20:28:39 <mmorrow> in IO the case is slightly different, but analogous. if you unsafePerformIO then you lose all information about how computing that `a' in (IO a) should be ordered wrt other IO computations, which in some cases may be exactly what you want, but very rarely
20:29:45 <Veinor> mmorrow: fromJust :P
20:30:16 <mmorrow> also, then you also (usually) need to know how the particular compiler you're using implements the IO monad, and how it might reorder/whatnot that unsafePerformIO'ed value to be able to make sure that you're ok
20:30:32 <Veinor> basically, unsafePerformIO is evil.
20:30:55 <dmwit> unsafePerformIO is merely unsafe.  unsafeInterleaveIO is evil.
20:31:03 <mmorrow> Veinor: it's like a gun
20:31:05 <Veinor> what's that do?
20:31:29 <ivanm> mmorrow: well, I have even more goodness in my latest release if you're wanting to start using it... >_>
20:31:37 <mmorrow> gun's are useful or dangerous depending on the situation
20:31:46 <mmorrow> ivanm: :)
20:32:47 <KitB> Right, I think I have it right :P
20:33:19 <Philonous> I like unsafeInterleaveIO. It let's you do stuff like an infinite list of empty MVars
20:36:31 <KitB> Woop woop, it worked
20:36:39 <KitB> Thanks for the help
20:36:57 <mmorrow> :)
20:37:14 <ivanm> Philonous: which you sould need _why_?
20:37:17 <KitB> I see what you mean about taking it all into the IO
20:38:02 <mmorrow> KitB: nice, imo that's the fundamental thing that once you understand, everything else falls into place
20:38:21 <KitB> I wouldn't say I quite understand it yet
20:38:26 <KitB> But I'm getting there
20:39:04 <mmorrow> KitB: well, you just shifted your point of view, which is the actual realization i mean
20:39:36 <mmorrow> you don't take it /out/, you put everything /in/
20:39:57 <KitB> But not quite understand I mean: what I did wasn't so much solved it as just hacked at it until it worked
20:40:05 <KitB> The code that came out is clean and concise
20:40:15 <KitB> So I suspect it's the intended way of doing things
20:40:40 <KitB> And I have an idea of why it worked
20:40:48 <mmorrow> cool
20:41:35 <KitB> I'm very glad the limit of knowledge of Haskell I will be examined on is algebraic data types.
20:45:08 <copumpkin> mmhmm: http://snapplr.com/apnv
20:45:47 <dmwit> uh
20:46:01 <shepheb> isn't the distance 4?
20:46:05 <dmwit> half a second to compute levenshtein distance of 3... isn't that pretty horrible?
20:46:22 <dmwit> 3 looks right to me
20:46:34 <copumpkin> dmwit: this is built from the very basics :P
20:46:36 <shepheb> oh, reusing the n.
20:46:49 <copumpkin> but yeah, it does seem a little slow even given that
20:46:58 <copumpkin> but it's uncompiled ghci so I'm going to leave it
20:47:03 <dmwit> =)
20:47:22 * dmwit spawns "diff" to compute his levenshtein distances ;-)
20:47:30 <copumpkin> :)
20:47:42 <copumpkin> I bet it doesn't (knowingly) use a histomorphism though! (that's my next objective)
20:47:56 <dmwit> I will not take that bet!
20:48:28 <orbisvicis> hello: ctrl-direction in ~/.haskeline seems only to cause a bell
20:48:43 <abuiles> someone around to talk about type-families ?
20:48:56 <copumpkin> also, having the extra slow hylomorphism-based one will only make me appreciate the histomorphism better
20:49:50 * hackagebot upload: snow-white 2009.12.1 - encode any binary instance to white space (JinjingWang)
20:56:06 <dmwit> oh now
20:56:12 <dmwit> ?hackage snow-white
20:56:13 <lambdabot> http://hackage.haskell.org/package/snow-white
20:57:14 <dmwit> > length "                                                                                 "
20:57:16 <lambdabot>   81
20:57:16 <copumpkin> looks really useful, that
20:57:22 <dmwit> > length "hello"
20:57:24 <Draconx> that package is kind of awesome.
20:57:24 <lambdabot>   5
20:57:43 <copumpkin> probably more useful than the crap I'm doing right now, at least
21:00:03 <ivanm> what is snow-white meant to do?
21:00:20 <copumpkin> encodes binary instances to whitespace?
21:01:30 <ivanm> yes, but what does that _mean_?
21:01:38 <ivanm> does it use spaces and tabs for 0s and 1s or something?
21:02:15 <ivanm> @slap date-based-versions
21:02:16 * lambdabot submits date-based-versions' email address to a dozen spam lists
21:02:29 <dmwit> ivanm: I think pretty much yes, exactly that.
21:02:38 <dmwit> ivanm: Also, what's wrong with date-based versions?
21:02:47 <ivanm> that JinJing guy writes pretty annoying packages
21:02:52 <ivanm> dmwit: they don't follow the PVP
21:03:27 <ivanm> and he seems to be obsessed with his MPS library, which I can never seem to understand the point of...
21:04:04 <dmwit> Google's results for PVP are swamped by "player vs. player", care to help me out?
21:04:20 <ddarius> Package Versioning Policy
21:04:37 <ivanm> @where pvp
21:04:38 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
21:04:41 <ivanm> dmwit: ^^
21:05:24 <dmwit> ah
21:05:38 * rasfar loves Haskell, oh so much!! wow
21:06:06 <copumpkin> yay
21:06:15 <ivanm> dmwit: basically, it defines a simple way of working out when the API of a library changes
21:06:20 <dmwit> yep
21:06:48 <dmwit> That doesn't make date-based versions inherently bad, of course.
21:07:35 * copumpkin has had enough morphisms for tonight
21:07:38 <dmwit> You could still do major.minor.year.month.day or so.
21:08:34 <ddarius> Holy crap he redefined (>)
21:08:51 <ivanm> ddarius: exactly, he redefined everything and didn't bother to even provide documentation
21:08:57 <ivanm> dmwit: yes, you could
21:09:02 <ivanm> but why would you?
21:09:02 <copumpkin> who did?
21:09:14 <ivanm> copumpkin: the author behind snow-white
21:09:17 <copumpkin> oh
21:09:17 <ivanm> in his mps library
21:09:52 <ddarius> ivanm: Redefining (.) is annoying but arguable.  Redefining (>) is just insanity.
21:10:02 <ivanm> ddarius: agreed
21:10:17 <copumpkin> I dunno, I've wanted a MPTC for Ord and Eq before (with another parameter for the return type)
21:10:34 <ddarius> copumpkin: He redefined it into something like flip ($).
21:10:39 <copumpkin> oh :P
21:10:50 <copumpkin> to look like ML or something?
21:11:09 <ddarius> copumpkin: No, because there's something wrong with his head.
21:11:36 <copumpkin> (>) :: (Category cat) => cat a b -> cat b c -> cat a c
21:11:37 <copumpkin> (>) = (>>>)
21:11:39 <copumpkin> wow, looks awesome
21:11:52 <ddarius> copumpkin: Um, until you want to say, if x > y then ...
21:12:02 <copumpkin> (-) :: (a -> b) -> a -> b
21:12:03 <copumpkin> f - x =  f x
21:12:04 <Asztal> also / and ^ (when there's already </> for combining paths)
21:12:22 <ddarius> Great googly moogly.
21:12:31 <copumpkin> wow, this is pretty impressive
21:12:36 <ddarius> How do you do comparisons then?  Prelude.> ?
21:12:39 <copumpkin> first, second, third, forth, fifth :: [a] -> a
21:13:14 <copumpkin> I guess this is intended as an alternate prelude
21:13:28 <dmwit> no documentation =(
21:13:31 <ivanm> ddarius: or using compare
21:13:37 <ivanm> dmwit: there's a users guide someone else did
21:13:39 <copumpkin> eq, is, is_not, isn't, aren't :: (Eq a) => a -> a -> Bool
21:13:43 <ivanm> http://www.maztravel.com/haskell/MPSexamples.html
21:13:59 <ivanm> but I still think its only impressive in its stupidity and wtf-ness
21:14:02 <j2j> Hello, does somebody knows why this code fails?
21:14:02 <j2j> Prelude Data.Array.IO Data.Array> (newListArray (1,10) [3] :: IO (IOArray Int Int)) >>= freeze :: IO (Array Int Int)
21:14:02 <j2j> array (1,10) [(1,3),(2,*** Exception: MArray: undefined array element
21:14:02 <j2j> Should not the function newListArray initialize the entire array with value 3?
21:14:23 <copumpkin> because you only gave it one element?
21:14:25 <copumpkin> nope
21:14:29 <copumpkin> give it repeat 3
21:14:29 <dmwit> j2j: No, it should initialize it with the list you gave. =)
21:14:49 <Asztal> I think plain old newArray initializes it all to one value.
21:14:55 <dmwit> :t newArray
21:14:57 <lambdabot> Not in scope: `newArray'
21:15:04 <dmwit> :t Data.Array.newArray
21:15:04 <copumpkin> 1.upto 3
21:15:05 <j2j> But should not the function newListArray be strict? Fail during the call?
21:15:06 <lambdabot> Not in scope: `Data.Array.newArray'
21:15:10 <copumpkin> seems to be trying to look like ruby
21:15:23 <dmwit> j2j: No again!  Arrays are lazy.
21:15:43 <copumpkin> AKHG! is_palindrom :: (Eq a) => [a] -> Bool
21:15:46 <ddarius> copumpkin: I guess.  The only thing from ruby that I've seen that I really prefer is 'select'
21:15:49 <copumpkin> I hate abbreviations that leave out one letter from the end
21:16:13 <copumpkin> ddarius: yeah, I'm not sure why he'd want to, but a lot of this stuff reminds me of it (inject for fold, etc.)
21:16:54 <monochrom> for example monochrom :)
21:17:07 <copumpkin> I HATE YOUU
21:17:10 <monochrom> haha
21:17:30 <j2j> dmwit: Even IOArrays? Even storable arrays?
21:17:38 <dmwit> j2j: Even those!
21:17:44 <copumpkin> j2j: only UArrays are strict
21:17:51 <copumpkin> and other similar structures
21:17:54 <ivanm> monochrom: aren't you missing 4 letters though?
21:18:01 <monochrom> no, 1.
21:18:02 <dmwit> j2j: They are spine-strict (i.e. they need to know how much space to allocate), but each element is lazsy.
21:18:03 <Asztal> Are storable arrays really lazy?
21:18:06 <manju> movingWin :: [a] -> Int -> [a]
21:18:13 <manju> movingWin (xs :: [a], winSize) =
21:18:14 <manju>   tail xs
21:18:18 <manju> why is this wrong ?
21:18:19 <copumpkin> 8 letters
21:18:21 <ivanm> monochrom: monochromATIC <--- see? 4 letters!
21:18:26 <monochrom> monochrome
21:18:38 <copumpkin> ivanm: monochrom monochromATICALLY <---- see? 8 letters!
21:18:42 <dmwit> manju: movingWin xs winSize = ...
21:18:43 <ivanm> heh
21:18:48 <manju> ah
21:19:04 <manju> Couldn't match expected type `[a]' against inferred type `(a1, b)'
21:19:08 <manju> same error
21:19:16 <dmwit> copumpkin: monochromEPAINTINGSAREAWESOME <--- see? a whole sentence!
21:19:19 <j2j> dmwit: But if I pass lazy array to C code, I would expect that elements are filled in? Liek in withStorableArray ?
21:19:27 * copumpkin remembers bugging dmwit a while ago with a similar problem about moving windows (and then going on to bug him about classification)
21:19:36 <copumpkin> lol
21:19:43 <copumpkin> j2j: nothing is magic
21:19:52 <mtnviewmark> did you mean     moving Win (x:xs) winSize = ....?
21:20:01 <ddarius> copumpkin: You had a problem with moving windows due to a complete lack of understanding of syntax?
21:20:11 <manju> mtnviewmark: yes..
21:20:12 <copumpkin> well, no
21:20:29 <copumpkin> I may have been (be) annoying but I got the syntax pretty quickly :P
21:20:31 <dmwit> manju: I don't believe you actually made the change I suggested.
21:20:31 <mtnviewmark> no need to repeat the type info -- you already told Haskell what the type of the arguments are!
21:20:48 <copumpkin> monochromATIC ELECTROMAGNETIC PLANE WAVE
21:21:00 <dmwit> manju: Or, perhaps: I don't believe that error applies to the line you fixed.
21:21:15 <manju> movingWin h:xs winSize = xs
21:21:19 <manju> is this correct ?
21:21:26 <dmwit> movingWin (h:xs) winSize = xs
21:21:33 <dmwit> gotta watch that precedence =)
21:22:01 <copumpkin> what the hell? http://github.com/nfjinjing/mps/blob/master/src/MPS/Math.hs he's got number theory in the same library as (>) as (>>>)
21:22:05 <j2j> copumpkin: I am still a little bit confused about stricness of the arrays that are passed as pointer to C code. What guarantees are there if all arrays are lazy?
21:22:21 <manju> dmwit: ah..thanks
21:22:22 <ddarius> copumpkin: J has a built-in to generate primes...
21:22:39 <copumpkin> j2j: that if you explicitly wrap a c call in something saying "yo, I need my array in C code now, please make sure it works", then it'll work
21:23:25 <copumpkin> ddarius: fair enough, but that's a pretty explicitly mathematical language, not one that relegates (-) to <->
21:23:36 <copumpkin> (numerically mathematical, I might say)
21:23:51 <ddarius> copumpkin: You don't use Dirichlet series in your day-to-day ruby coding?
21:23:55 <j2j> copumpkin: Thanks.
21:24:08 <copumpkin> can't say I do
21:24:16 <copumpkin> but I haven't touched ruby since I discovered haskell :(
21:24:18 <copumpkin> I bet it feels lonely
21:24:39 <manju> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=5208#a5208
21:24:55 <ddarius> copumpkin: Yeah, I imagine a lot of programming languages call Haskell a skanky slut.
21:25:05 <manju> what is wrong with that code ?
21:25:08 <dmwit> Text.HTML.Moe.DSL.Kawaii ?
21:25:25 <copumpkin> manju: without an error, you're going to have to tell us
21:25:27 <dmwit> manju: now it's too many parentheses =)
21:25:40 <copumpkin> or that :)
21:25:43 <dmwit> manju: movingWin ((tail xs) winSize) means...
21:25:43 <manju> ah
21:25:44 <manju> ok
21:25:47 <manju> gak
21:25:49 <monochrom> change movingWin ((tail xs) winSize) to movingWin (tail xs) winSize
21:25:52 <dmwit> apply "tail" to "xs", then to "winSize".
21:26:37 <dmwit> > map (take 3) (tails [1..10])
21:26:39 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10],[1...
21:26:50 <monochrom> This is why window managers should not be programmable.
21:26:52 <manju> noooooooo.......
21:27:00 <manju> I want to write moving window :-(
21:27:07 <copumpkin> lol
21:27:08 <dmwit> err...
21:27:09 <dmwit> whoops
21:27:20 <manju> now brain is contaminated
21:27:23 <manju> :-)
21:27:27 <dmwit> Don't worry, it's subtly wrong. =)
21:27:44 <manju> anyway I am going to write using recursion
21:27:48 <copumpkin> ideally, you'd write a moving window that takes smarter functions that deal with marginal updates rather than the entire window
21:28:01 <copumpkin> "explicit recursion is the goto of functional programming" -someone
21:28:03 <manju> copumpkin: ok
21:28:14 <bitstream0101> What's the best/most efficient way to determine if two IOUArrays are equal? The Eq class seems to be an internal implementation and I don't think I'm supposed to use it.
21:29:01 <bitstream0101> er, Eq instance, that is ;)
21:29:02 <manju> copumpkin: but I am trying to learn recursion :-|
21:29:02 <mtnviewmark> do you mean you think instances of Eq are just for internal use?
21:29:14 <ddarius> "To iterate is illiterate / to recurse worse / to avoid this trap see / instructions on MAPC"
21:29:15 <copumpkin> manju: I'll avoid the cliche and tell you to carry on :)
21:29:30 <monochrom> haha ddarius
21:29:34 <j2j> f
21:29:34 <manju> what is MAPC ?
21:29:38 <mtnviewmark> aw shucks, dive in - the water's warm and the Eq is gooooooooooooooood
21:29:43 <ddarius> bitstream0101: Presumably the Eq instance is reference equality.
21:29:59 <bitstream0101> ddarius: that would make sense, then :)
21:30:25 <bitstream0101> so I'm looking for the best way to do value equality over an array of Bools
21:30:25 <mtnviewmark> ah - teh Eq instance of IOUArrays... <little voice> never mind...<//little voice>
21:31:01 <ddarius> bitstream0101: You'll have to write your own equality function.
21:31:26 <manju> sorry but MAPC haskell returns nothing relevant on google
21:31:34 <ddarius> bitstream0101: Do it however you like.  Find out if its a problem later.
21:32:02 <bitstream0101> ddarius: have more-or-less done that, and it works. just don't like having two huge lists of bools and was hoping for a more compact rep, that's all.
21:32:09 <bitstream0101> something like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=13428#a13428 is the situation i'm dealing with
21:32:11 <Philonous1> "mapc is like mapcar except that function is used for side-effects only--the values it returns are ignored, not collected into a list.  mapc always returns sequence. "
21:32:15 <manju> Michigan Arson Prevention Committee
21:32:48 <Philonous1> mapc is Lisps way of saying mapM_
21:33:01 <ddarius> manju: That's an old LISP function.  That little poem is from 1978.
21:33:02 <bitstream0101> so I have things like do bnds <- getBounds bmap ; bs <- mapM (checkBit bmap) [fst bnds .. snd bnds] and the like.
21:33:17 <Gracenotes> in some imperative languages it's called "each"
21:33:24 <copumpkin> bitstream0101: you could use a foldM
21:34:15 <bitstream0101> copumpkin: wow, i'm tired. thanks =)
21:34:45 <copumpkin> probably still isn't ideal but best not be premature :P
21:34:49 <ddarius> It's almost certainly older than most of the people here.  It predates Haskell.  It predates Common Lisp.  It almost predates Scheme.
21:35:12 <bitstream0101> copumpkin: Yeah, I'm pretty sure it's still not ideal, but it's closer to what I was looking for. I was debating packing bits and comparing integers or something.
21:36:15 * BMeph nudges copumpkin to suggest using uvectors...
21:36:23 <copumpkin> use uvector!
21:36:33 <dmwit> no no
21:36:37 <BMeph> copumpkin: Wink, wink, say-no-more... ;p
21:36:38 <dmwit> You have to *suggest* using uvector.
21:36:38 <ddarius> copumpkin: Actually, you might want to read this, it will entice you and break your heart.  http://www.seas.upenn.edu/~sweirich/types/archive/1989/msg00043.html
21:36:51 <copumpkin> oh
21:36:59 <bitstream0101> copumpkin: actually, maybe i -am- just tired, but i don't think foldM really gives me what I want, as I'm comparing two of these guys, and foldM over obvious boolean operators is going to yield false positives.
21:37:00 <copumpkin> bitstream0101: you might want to use uvector, but it's just a suggestion
21:37:06 <bitstream0101> copumpkin: hehe
21:39:46 <copumpkin> ddarius: well things like Mu exist to get the (explicit) recursion out of types in the first place, but is he talking about avoiding even that?
21:40:03 <ddarius> copumpkin: Yes.
21:40:36 <ddarius> copumpkin: But that isn't really the aspect I was referring to.
21:40:37 <copumpkin> I'm not sure I really understand his justification for it at the beginning beyond "recursion is uncool and unmathematical"
21:40:57 <ddarius> copumpkin: The "side" comments are much more interesting.
21:41:31 <copumpkin> the sub-2-category thing?
21:41:39 <ddarius> copumpkin: Among other things, yes.
21:41:53 <BMeph> There are no lists, only partial functions with Nat as codomain... omnomnomnomnom! ;)
21:42:40 <copumpkin> :o
21:42:41 <ddarius> BMeph: There's actually a paper on the relation between initial algebras in the codomain and the result coalgebras (which is basically just continuity)
21:42:55 <bradfordstephens> holy crap there's a lot of people
21:43:02 <ddarius> Nat -> X ~ Stream X is such an example.
21:44:24 <jmcarthur> bradfordstephens: :)
21:44:48 <Apocalisp> @users
21:44:49 <lambdabot> Unknown command, try @list
21:44:56 <jmcarthur> the users plugin is defunct
21:45:03 <Apocalisp> oh right
21:45:07 * copumpkin will ruminate on his way to CVS to get a snack
21:45:07 <manju> I figured, I am not divine.
21:45:26 * Apocalisp thinks about starting up SVN Pharmacy
21:45:37 <ddarius> I'm pretty sure it was this paper: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.7939
21:46:04 <monochrom> Syntax and semantics is an invention of logic, not mathematics. Real programmers don't care about semantics, and real mathematicians don't care about syntax. Computer science is the last refuge of syntax and semantics. The writing is on the wall.
21:46:10 <ddarius> copumpkin: That little mailing list post from 1989 sent me on a long chase for the details of that comment.
21:46:29 <bradfordstephens> O_o wow, you guys are hella esoteric. I like this place already
21:47:13 <dolio> Stream X is likely to be nicer to program with in many cases than Nat -> X.
21:47:26 <dolio> Of course, the reverse is also true.
21:48:47 <blackdog> is there a monadic equivalent of 'all'?
21:49:02 <ddarius> blackdog: Maybe in Data.Traversable or Foldable
21:49:04 <ivanm> liftM all ?
21:49:24 <monochrom> ruleTM all
21:49:31 <blackdog> ivanm: ah, that's the one
21:49:35 <BMeph> bradfordstephens: Actually, we're kinda slacking tonight. Usually or convos are much more abstract than this... ;)
21:49:37 <mtnviewmark> yikes! under what condition dose cabal buid invoke perl?!?!
21:49:42 <BMeph> *our
21:50:12 <bradfordstephens> BMeph: Hehehe.
21:50:34 <ddarius> mtnviewmark: Any time GHC compiles stuff via GCC...
21:50:57 <mtnviewmark> how does perl get involved? gcc's pipeline now uses perl?
21:51:12 <blackdog> ivanm: ah, actually no. that's m (a->Bool) -> m([a]->Bool)
21:51:18 <ddarius> mtnviewmark: No, GHC uses Perl in the Evil Mangler to mangle the assembly output by GCC.
21:51:34 <ivanm> blackdog: oh, right
21:51:41 <ivanm> you'd probably need to construct it yourself then
21:51:48 <monochrom> a perl script muddles with the assembly code to change some gosub's to goto's.
21:51:57 <BMeph> @ty liftM2 all
21:51:58 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> Bool) -> m [a] -> m Bool
21:52:26 <mtnviewmark> ah - okay - fie - when I use -via-C and am building from Leksah -- the environment isn't properly propigated and perl complains bitterly about the locale not being set
21:52:30 <ddarius> If you want (a -> m Bool), you'll have to reimplement all, but you can probably do that with foldrM or somesuch.
21:53:12 <ddarius> Perl and Haskell have had a strangely intertwined history...
21:53:23 <mtnviewmark> (if I could only get Leksah to compile on my system, I'd poke around and try to fix that...)
21:54:02 <roconnor> > 17*17
21:54:04 <lambdabot>   289
21:54:09 <roconnor> > 74*4
21:54:10 <lambdabot>   296
21:54:15 <mtnviewmark> (but gtk+ and gtk2hs and Mac is a subtle brew that not many are willing to divulge)
21:55:30 <dfrey> I need a reminder.  What's the name for the automatically generated functions you can get by naming the components of data declarations in Haskell?
21:55:46 <monochrom> deriving
21:55:57 <allbery_b> I think he means destructors
21:55:57 <monochrom> maybe not
21:56:05 <monochrom> fields
21:56:07 <dfrey> no, the ones for accessing the components of the data type
21:56:35 <qwr> probably fields :)
21:56:49 <BMeph> ddarius: I'm currently puttering through http://cseweb.ucsd.edu/~goguen/pps/utyop.pdf  it seems interesting... :)
21:57:05 <dfrey> Yeah, I think fields is correct
21:57:15 <ddarius> The Report calls them "selector functions"
21:57:25 <monochrom> labelled fields. http://haskell.org/onlinereport/decls.html#sect4.2  then scroll down
21:58:17 <ddarius> BMeph: I don't recall being terribly compelled when I read that years ago, but that reminds me.  copumpkin, at some point you should read Goguen's "Categorical Manifesto"
22:00:06 <BMeph> ddarius: I'm curious: Besides attractive cliffs, what *does* compel you? ;)
22:03:38 * BMeph opens http://charlotte.ucsd.edu/~goguen/pps/manif.ps and starts reading...
22:07:43 <ddarius> BMeph: There's a saying that mathematicians(?) are not supposed to climb mountains but to reduce them to mole hills.  Things that actually do that compel me.
22:08:08 <ddarius> I have several example of varying extremity.
22:13:27 <BMeph> ddarius: I'd say that you are one of varying extremity. :)
22:25:57 * copumpkin downloads Goguen's Categorical Manifesto, now equipped with iced tea and dry-roasted peanuts
22:26:29 <MarcWeber> Is there any library providing kind of glob function such as **/*.hs ?
22:27:21 <ddarius> MarcWeber: Probably...
22:27:26 <ddarius> @hoogle glob
22:27:27 <lambdabot> Language.Haskell.TH global :: Name -> ExpQ
22:27:27 <lambdabot> Language.Haskell.TH.Lib global :: Name -> ExpQ
22:27:41 <MarcWeber> ddarius: :-) I found it myself now. Great
22:27:57 <ddarius> MarcWeber: Where?
22:28:43 <MarcWeber> ddarius: While looking at hackage
22:29:04 <MarcWeber> ddarius: hoogle didn't show anything usable when searching for glob
22:30:56 <endojelly> MarcWeber, **/*.hs, you mean the zsh glob syntax for "files that match the pattern *.hs in *all* subdirectories recursively"?
22:31:16 <endojelly> MarcWeber, don't know if you'll readily find that in any standard library
22:31:25 <ddarius> MarcWeber: I meant to ask what package/module.
22:31:38 <MarcWeber> http://hackage.haskell.org/packages/archive/Glob/0.4/doc/html/System-FilePath-Glob.html#v%3AglobDir
22:32:12 <endojelly> MarcWeber, but that's probably without **
22:32:21 <endojelly> have to go, bye
22:32:25 <ddarius> endojelly: Looks like it has it.
22:32:33 <MarcWeber> endojelly: There is a recursive option
22:33:03 <endojelly> **/
22:33:04 <endojelly>     Matches any number of characters, including path separators, excluding the empty string.
22:33:09 <endojelly> ddarius, it's something else
22:33:16 <endojelly> MarcWeber, ah, then you can easily simulate it
22:33:17 <endojelly> nice!
22:33:25 <endojelly> anyway, off now, cu later 8)
22:33:50 <endojelly> ddarius, actually, with the recursive options it's exactly what he wants 8)
22:33:59 <endojelly> -options+option
22:34:41 <endojelly> so I stand corrected
22:34:42 <endojelly> but
22:34:44 <endojelly> shower
22:34:44 <endojelly> NOW
22:34:45 <endojelly> 8)
22:38:09 <copumpkin> this manifesto is very clear
22:38:36 <ray> i guess you're not reading the unabomber's manifesto or timecube.com then
22:39:22 <copumpkin> not quite :)
22:39:26 <copumpkin> gonna go home now and ponder
22:39:35 <copumpkin> ddarius: thanks again for the reading list
22:40:53 <ray> speaking of that, gene ray seems angrier than usual lately
23:01:38 <Veinor> ... OKAY! Don't do /names **
23:18:49 <copumpkin> has anyone here used scapy?
23:26:02 <ivanm> copumpkin: never heard of it
23:26:27 <copumpkin> it's a network protocol suite in python that I think could be done a lot more nicely in haskell
23:26:37 <copumpkin> not just another example of "let's do it better in our language"
23:27:00 <ddarius> Let's do it better in our language.
23:27:04 <copumpkin> lol
23:28:39 <MarcWeber> http://darcs.haskell.org/bytestring/Data/ByteString/Char8.hs Is dropSpace exported? If so why?
23:29:17 <copumpkin> it's exported as dropWhile isSpace ;)
23:31:25 <MarcWeber> copumpkin: I‚ê£got it now. Why isn't it exported then? This doesn't make much sense to me because typing dropSpace is faster than dropWhile isSpace.
23:31:43 <copumpkin> you shouldn't have to know about specialized functions like that
23:31:55 <copumpkin> you should write what you mean and it should deal with the details
23:32:04 <MarcWeber> copumpkin: Why does php have ltrim etc? Because it's used often
23:32:49 <copumpkin> pretty sure anything PHP does we should strive for the opposite of ;)
23:33:14 <copumpkin> but anyway, if you use it often, write an alias
23:33:14 <MarcWeber> copumpkin: *lol*. What does this mean? Never become main stream? Never write web applications ? Be careful!
23:33:25 <MarcWeber> copumpkin: Of course I can.
23:33:25 <copumpkin> our motto is "avoid success at all costs"
23:33:45 <copumpkin> MarcWeber: bytestring isn't actually the best choice for human-readable text in the first place
23:33:49 <copumpkin> it's used more for binary data
23:34:05 <copumpkin> so I'd think that whitespace-aware specialized functions aren't really an objective
23:38:58 <mtnviewmark> MarcWeber -- text package FTW!
23:41:46 <manju> 2 + 3
23:42:11 <manju> how do I send haskell code to lambdabot ?
23:42:14 <MarcWeber> mtnviewmark What do you want to tell me ? I don't get it.
23:42:16 <copumpkin> > 2 + 3
23:42:18 <lambdabot>   5
23:42:25 <manju> > 2 + 3
23:42:26 <copumpkin> MarcWeber: the text package, it's good for text
23:42:27 <lambdabot>   5
23:42:28 <copumpkin> @hackage text
23:42:28 <lambdabot> http://hackage.haskell.org/package/text
23:42:38 <manju> ah...cool
23:42:46 <mtnviewmark> if you are processing text for the web, or any text really, you want the text package, not ByteString
23:42:54 <manju> > let s0 = "manju"
23:42:56 <lambdabot>   not an expression: `let s0 = "manju"'
23:42:58 <manju> s0
23:43:05 <manju> > s0
23:43:07 <lambdabot>   Not in scope: `s0'
23:43:09 <copumpkin> it does unicode correctly for you, without you having to worry about anything
23:43:21 <copumpkin> including things like case folding and normalization
23:43:37 <copumpkin> it also has a more text-oriented API
23:43:40 <mtnviewmark> > let s0 = "manju" in s0 ++ " rulz"
23:43:42 <lambdabot>   "manju rulz"
23:43:46 <copumpkin> and avoids numeric indices and such where possible
23:44:33 <mtnviewmark> and.... has the strip function!
23:45:07 <copumpkin> and deals with all whitespace characters
23:45:13 <mtnviewmark> http://hackage.haskell.org/packages/archive/text/0.5/doc/html/Data-Text.html#v%3Astrip
23:54:07 <aeron> can anyone explain why in Text.ParserCombinators.Parsec, skipMany1 has the 1 in its name?
23:54:43 <cnwdup> Because it skips one or more.
23:54:58 <cnwdup> skipMany would even succeed if nothing has been skipped.
23:55:02 <path[l]> lol
23:55:05 <copumpkin> skipMany1 p         = do{ p; skipMany p }
23:55:11 <aeron> ah, silly me
23:55:21 <aeron> thanks :)
23:58:19 <manju> haskell people in the euler project just seem to show off :-)
23:58:43 <manju> lots of code are one-liners
23:58:59 <aeron> manju: maybe haskell is just that expressive. look at all the APL/j/k entries
23:59:02 <aeron> :)
23:59:10 <manju> APL ?
23:59:39 <manju> yeah haskell is expressive, only if you know haskell, otherwise it is line noise :)
