00:05:52 * Axman6 wonders if dons still reads his blog
01:06:10 <fasta> Is there a function in TH to display a list of methods of a particular class that is in scope with their types etc?
01:06:22 <Warrigal> What's our off-topic channel?
01:06:41 <ivanm> -blah
01:07:08 <ivanm> Warrigal: ^^
01:08:10 <Warrigal> Grazie.
01:08:24 <mreh> where's the hackage mirror again?
01:09:06 <ivanm> mreh: there's no mirror per-se
01:09:12 <ivanm> there's a torrent in the topic
01:09:24 <mreh> someone set up a mirror of the API database
01:10:53 <ivanm> mreh: they did?
01:11:00 <ivanm> I don't recall hearing about that...
01:11:03 <mreh> i'll check my chat logs
01:11:22 <ivanm> ahhh, think I've found it: http://www.lama.univ-savoie.fr/~meunier/archive/
01:14:21 * Cyneox re
01:16:06 <mreh> i can always generate haddock doc from source right?
01:16:11 <mreh> i think i'll just do that
01:16:41 * Baughn wonders who this "Shelby Moore" fellow is
01:16:58 <skyhawk> whats up with hackage?
01:17:15 <gju> see topic
01:17:16 <Baughn> mreh: Well, unless haddock decides it can't. But then hackage wouldn't have docs either.
01:17:31 <mreh> gah!
01:17:31 <ivanm> mreh: yes
01:17:32 <Baughn> It's down, yeah. We haven't yet been told /why/.
01:17:37 <ivanm> mreh: but I gave you the link
01:17:41 <ivanm> http://www.lama.univ-savoie.fr/~meunier/archive/
01:17:46 <mreh> do you think it's CERN
01:17:48 <ivanm> mreh: ^^
01:17:53 <Hunner> How is () pronounced?
01:17:53 <fasta> It's down because Haskell was getting too popular.
01:17:56 <mreh> ivanm, that contrains nothing useful
01:17:59 <fasta> That just cannot happen.
01:18:00 <ivanm> Baughn: it's s sinister galois conspiracy!
01:18:07 <skyhawk> how long have it been down?
01:18:21 <ivanm> mreh: :o I just went there and it had stuff!
01:18:28 <fasta> Or it is a good way to make sure competitors cannot use Haskell.
01:18:30 <Baughn> ivanm: Of doom!
01:18:38 * Baughn hugs himself in fear
01:18:49 <ivanm> Baughn: what other kind of sinister conspiracies are there?
01:18:59 <fasta> Or <insert more conspiracies that are easy to think of>
01:19:06 <ivanm> mreh: must have died from the #haskell effect ;-)
01:19:19 <Baughn> ivanm: Well, you'd be hard pressed to claim that the Divine Conspiracy to Make Better Peanut Butter is of Doom
01:19:21 <ivanm> fasta: galois hosts it, so it must be a galoi problem...
01:19:28 <mreh> super intelligent computers vying world domination?
01:19:32 <ivanm> Baughn: is it really a conspiracy though?
01:19:48 <mreh> is it a DOS attack?!
01:19:55 <ivanm> doubt it
01:19:58 <Baughn> ivanm: There are multiple people working on it. Did you previously know abou tit?
01:19:59 <fasta> ivanm, did I suggest that it wasn't? From my POV the "problem" is anywhere between here and there.
01:20:00 <dolio> It's a CPM attack.
01:20:04 <skyhawk> the backup torrent link doesnt work either...
01:20:13 <mreh> OH GOD!
01:20:15 <ivanm> skyhawk: :o there's no torrent?
01:20:28 <mreh> they're shutting us down
01:20:30 <ivanm> hmmmm, galois is up...
01:20:43 <cjs> Hm. Both with and without -threaded, my different threads appear not to share the contents of an IORef, despite using atomicModifyIORef. After doing the modify, the modifying thread sees the new value, but any other threads see the olld. Is there some obvious error one makes that causes this sort of behaviour?
01:20:57 <Baughn> ivanm: Anyway, better peanut butter counts as "potentially harmful to others" because of the people who are allergic, so yeah, conspiracy.
01:21:18 <skyhawk> ok, got the link to work now, my irc webclient added a quotation mark
01:21:24 <ivanm> Baughn: but "better peanut butter" doesn't mean we're going to force everyone to _eat_ it...
01:21:31 <ivanm> skyhawk: yeah, a lot of them do that
01:22:14 <Baughn> cjs: How do you make the IORefs? unsafePerformIO?
01:22:47 <mreh> :t linspace
01:22:48 <cjs> No, no; I just do "clientHandles <- newMVar []" before forking off separate threads.
01:22:48 <lambdabot> Not in scope: `linspace'
01:23:11 <ivanm> cjs: oh, I'm hoping to have a new release of SourceGraph out in the next week or so that will differentiate functions only accessible via underscored functions from those not accessible at all
01:23:14 <Baughn> cjs: ..that's not even an MVar
01:23:19 <Baughn> Er. IORef
01:23:36 <cjs> Oh, I mean IORef. I'm just switching to MVars right now just to see if it makes any difference. Channels seem fine.
01:24:08 <Baughn> cjs: Although I'd probably use a TVar.. hm, IORefs should be fine, if you use them right. If you could make a minimal program.. bug reports might be the thing.
01:24:20 <Baughn> cjs: If IORefs couldn't be used across threads, atomicModifyIORef wouldn't even exist
01:25:15 <cjs> Nope, same problem.
01:25:32 <cjs> Wouldn't be anything to do with it being a list of handles, would it? Though still, the important thing is that it's a list....
01:25:46 <Baughn> cjs: ..nope, you /have/ to be doing something wrong
01:25:59 <Baughn> That, or there's a Boojum nearby, messing you up
01:26:50 <cjs> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11468#a11468
01:27:08 <cjs> I'd love to vote for Boojum, but past experience indicates that the other option is far more likely.
01:28:45 <cjs> It wouldn't be related to the bracket_ call, would it?
01:28:59 <cjs> Oh, wait....
01:29:38 <cjs> Yeah, I'm just removing it right away for whatever reason.
01:29:47 <Baughn> It definitely shouldn't be the problem
01:31:18 <Baughn> cjs: I'm having a hard time figuring out if this is supposed to be local or remote
01:31:49 <ski> Hunner : e.g. "empty tuple"
01:32:38 <Baughn> cjs: ..but I think you should try something simpler, until you understand variables properly. Also, look into STM.
01:33:05 <Baughn> cjs: (Which is my way of saying "I can't see the error")
01:33:06 <ski> (/me wonders whether the word you get from combining "ni" and "ple" has any precedent)
01:33:13 <cjs> Baughn: I understand them quite well. I've written far more sophisticated multithreaded stuff than this in Haskell.
01:33:20 <Baughn> ski: Apple.
01:33:36 <Baughn> cjs: ..never mind, then.
01:33:39 <ski> "Apple" is a word for the empty tuple ?
01:33:40 <cjs> The error is quite obviously one of wrong types; I've swapped an IO b and an IO c. :-)
01:33:58 <cjs> In other words, wrong order of arguments to bracket_.
01:34:31 <Baughn> Aha!
01:34:36 <cjs> flip the second and third and everything works just fine.
01:34:42 <cjs> Oh yeah, I forgot to mention:
01:34:44 <cjs> Doh!
01:34:55 <Baughn> Pity the type-checker couldn't catch that
01:35:44 <cjs> Indeed, just what I was thinking.
01:35:45 <mreh> plot.o: In function `s19K_srt':
01:35:45 <mreh> (.data+0x1e4): undefined reference to `hmatrixzm0zi5zi2zi2_GraphicsziPlot_mplot_closure'
01:35:45 <mreh> collect2: ld returned 1 exit status
01:35:51 <mreh> what kind of output is that?
01:36:11 <cjs> mreh: Pretty standard C compiler error output.
01:36:13 <opqdonut> mreh: are you using ghc --make
01:36:17 <cjs> (Well, linker, actually.)
01:36:27 <mreh> opqdonut: no
01:36:33 <opqdonut> try it :)
01:36:51 <Baughn> mreh: Either use --make, or use cabal. Manual use of ghc is pretty much for the dogs..
01:37:39 <mreh> Baughn: what doesn't cabal do?
01:38:13 <Cale> mreh: cabal is the more elaborate way to build things, and requires you to create a file describing your project
01:38:37 <mreh> Cale: oh i know, I just couldn't see how in this case, there's no cabal file
01:38:48 <mreh> there are so example files they left in hmatrix
01:39:04 <Cale> right, you would need to write one, so ghc --make is the way to go then
01:40:23 <mreh> > let f x = x^2; xs = [1..10] in [f xs]
01:40:24 <lambdabot>   No instance for (GHC.Num.Num [t])
01:40:24 <lambdabot>    arising from a use of `f' at <interact...
01:40:45 <Cale> > let f x = x^2; xs = [1..10] in [f x | x <- xs]
01:40:46 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
01:40:58 <mreh> Cale: look at this
01:41:08 <mreh> let x = linspace 1000 (-4,4)
01:41:08 <mreh>     mplot [f x]
01:41:13 <mreh> this is from h matrix code
01:41:18 <Cale> okay
01:41:30 <Cale> that's... a bit odd
01:41:40 <mreh> why does mplot take a list of functions?
01:41:53 <Cale> Multiple plots on one graph?
01:42:05 <mreh> might be..
01:42:14 <mreh> i can't get to the API :(
01:42:19 <Cale> What's more strange though is why that expression is sitting in the middle of the let
01:42:44 <mreh> Cale: it isn't
01:42:59 <Cale> Well, it's Monday here now, maybe the Galois people will get up and get to work in a few hours and start fixing their server ;)
01:43:00 <mreh> it got screwed up, it shouldn't be offside, it should be inline
01:43:21 <mreh> it's been Monday for 45 minutes here
01:43:26 <Cale> mreh: ah, okay, that makes sense
01:44:16 <mreh> Cale: the strangest thing about that is that f is a function that takes a single element
01:44:24 <mreh> maybe linspace isn't a list
01:44:33 <Cale> In Portland, Oregon, apparently it's 1:44. :)
01:45:06 <Cale> mreh: This stuff is usable from ghci isn't it?
01:45:14 <Cale> mreh: What's the type of linspace?
01:45:25 <mreh> i'm trying to find out, it's in Graphics.Plot
01:45:33 <mreh> i think that's in the hmatrix package
01:45:54 <Cale> ghci should know if you type :m + Graphics.Plot
01:46:10 <mreh> linspace :: Int -> (Double, Double) -> Vector Double
01:46:34 <Cale> Okay, so x :: Vector Double
01:46:59 <mreh> it's in Numeric.LinearAlgebra
01:47:14 <Cale> Probably just a linear interpolation with 1000 points between -4 and 4
01:47:22 <mreh> that's what I thought
01:47:29 <mreh> but f x =  sin x + 0.5 * sin (5*x)
01:47:34 <mreh> :t sin
01:47:36 <lambdabot> forall a. (Floating a) => a -> a
01:47:41 <Cale> :info Vector
01:47:49 <Cale> Is it an instance of Floating?
01:47:55 <Cale> (probably is)
01:48:16 <mreh> yes
01:48:20 <Cale> Probably it's an instance of Num and Floating, etc. where the operations all act pointwise on the elements of the vector
01:48:38 <Cale> and, for instance, 5 will be the vector which is filled with 5's
01:49:07 <mreh> i think I understand what's going on
01:49:28 <mreh> how would you implement this? it's like vectorisation in MATLAB
01:49:35 <Cale> Well... maybe something a little funky there to handle the fact that vectors have different sizes.
01:50:32 <Cale> You just define a new datatype and write instances of those classes implementing the operations however you like
01:51:03 <Cale> fromInteger is used to interpret integer literals, and fromRational is used to interpret fractional literals
01:51:21 <Cale> and of course, all the other numeric operations are in typeclasses too
02:02:22 <fasta> Is there a function in TH to display a list of methods of a particular class that is in scope with their types etc?
02:25:38 <mreh> can I inspect a module interface using ghc or cabal?
02:25:48 <mreh> i suppose I can just open up the source code
02:29:49 <Cale> mreh: You can inspect it with ghci
02:29:54 <Cale> With :browse
02:29:56 <Cale> and :type
02:36:10 <Peaker> mreh, cabal info tells you which modules it exports
02:36:20 <mreh> yeah I just thought of that
02:36:24 <mreh> thx
02:38:30 <mreh> if I have just one action, I don't even need a "do ..." do I?
02:38:36 <Cale> Right
02:38:44 <Cale> do is only for gluing together multiple actions
02:41:17 <malosh> With -XRecordWildCards, how to avoid "conflicting definitions" in patterns such as (A{..}, A{..}) ?
02:41:46 <Cale> malosh: By not using wildcards for one of the two
02:42:27 <malosh> are you meaning that -XRecordWildCards is useless :-) ?
02:42:44 <Cale> Well, do you really want to bind those variables twice?
02:43:21 <Cale> If you don't care what fields the records have, you don't need -XRecordWildCards at all, and you can just write (A {}, A {})
02:44:00 <malosh> I just want to match my couple against (A, A), my type is data T=A { a::x, b::y } | B
02:44:16 <Cale> Yeah, then you don't need that extension
02:44:17 <malosh> ah ok, thanks
02:44:54 <Cale> By the way, that syntax even works when they don't use record syntax
02:45:21 <Cale> because it was realised that it's useful to have a way to match a constructor without implying anything about the number of fields.
02:46:25 <dolio> Is that why it works? I figured it was an accident.
02:47:07 <Cale> The report explicitly mentions it
02:47:12 <dolio> Ah.
02:47:30 <ivanm> yeah, it's easier than doing (Foo _ _ _ _ _ _ _ _)
02:47:34 <ivanm> ;-)
03:23:03 <dsouza> howdy folks ... is hackage.haskell.org down for anyone else or it is just me?
03:23:40 <ben_m> Read the topic
03:23:45 <ben_m> :)
03:23:52 <dsouza> hehehe ... thx :-)
03:24:14 <HugoDaniel> oh
03:24:18 <HugoDaniel> what is a backup torrent ?
03:24:41 <mreh> > take 10 $ zipWith (*) (cycle [0,1]) [1..]
03:24:43 <lambdabot>   [0,2,0,4,0,6,0,8,0,10]
03:24:55 <mreh> is there a way to do this without leaving ther zeros in the list?
03:25:17 <mreh> forget the numbers, i need to filter a list with an adjancency matrix
03:26:05 <HugoDaniel> i can create a mirror of hackage here...
03:26:06 <Peaker> > filter (/=0) [0,2,0,4,0,6]
03:26:07 <lambdabot>   [2,4,6]
03:26:12 <HugoDaniel> in the university
03:26:17 <ClaudiusMaximus> something like concat . zipWith (\b x -> if b then ... else ...)
03:26:36 <mreh> Peaker: i thought of that, but i'm using vectors instead of Integers
03:26:52 <ClaudiusMaximus> maybe catMaybes would be more appropriate
03:27:15 <mreh> Data.Packed.Vector, although they do implement Eq
03:28:01 <mreh> > take 10 $ zipWith (\a b -> if a then Just b else Nothing) (cycle [0,1]) [1..]
03:28:03 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
03:28:03 <lambdabot>    arising from the literal `0'...
03:28:22 <mreh> > take 10 $ zipWith (\a b -> if (a/=0) then (Just b) else Nothing) (cycle [0,1]) [1..]
03:28:23 <lambdabot>   [Nothing,Just 2,Nothing,Just 4,Nothing,Just 6,Nothing,Just 8,Nothing,Just 10]
03:28:35 <mreh> > catMaybes $ take 10 $ zipWith (\a b -> if (a/=0) then (Just b) else Nothing) (cycle [0,1]) [1..]
03:28:37 <lambdabot>   [2,4,6,8,10]
03:28:39 <mreh> woo
03:28:55 <mreh> easier to do a filter though
03:29:30 <Peaker> @src catMaybes
03:29:31 <lambdabot> catMaybes ls = [x | Just x <- ls]
03:30:23 <ClaudiusMaximus> (/= 0) on a big vector might take some time
03:30:44 <Peaker> mreh, there's toList and fromList too
03:30:52 <mreh> :t toList
03:30:53 <lambdabot> Not in scope: `toList'
03:31:05 <mreh> yeah mean toList :: -> Vector a -> [a]
03:31:19 <mreh> you mean*
03:31:29 <Peaker> |> seems like fromList . take  -- why is it there?
03:31:48 <Axman6> mreh: i'd use (\a b -> if a then ...) (cycle [True,False]) imo
03:34:06 <mreh> Axman6: the data is in Integer form, and I have to use Maybe, other wise what else do I put in the empty spaces
03:34:22 <mreh> :i catMaybes
03:34:29 <Axman6> mreh: i meant instead of doing a /= 0
03:34:38 <Peaker> > zipWith ($) (cycle [Just, const Nothing]) [1..10]
03:34:39 <lambdabot>   [Just 1,Nothing,Just 3,Nothing,Just 5,Nothing,Just 7,Nothing,Just 9,Nothing]
03:34:44 <Axman6> which is likely to be much more costly
03:34:54 <Axman6> well, somewhat more costly
03:35:10 <Peaker> > catMaybes . zipWith ($) (cycle [Just, const Nothing]) $ [0..9]
03:35:12 <lambdabot>   [0,2,4,6,8]
03:35:16 <mercury^> hackage still down?
03:35:20 <Peaker> Ideally, enough inlining and some compiler magic would fix that
03:35:26 <Peaker> why does a server go down? :-(
03:35:39 <Botje> stack overflow :)
03:35:40 <Peaker> and no ssh access to anyone who can fix it?
03:35:40 <mreh> ever server must go down eventually
03:35:46 <mreh> it's a fact of life
03:35:57 <Axman6> Peaker: power failure?
03:36:17 <ben_m> But can't it go down once we all moved on to the next functional language? :P
03:36:19 <Peaker> Axman6, blaming hardware, huh :-)
03:36:21 <mercury^> Axman6: it failed two times in a suspiciously interval.
03:36:31 <mercury^> short*
03:36:40 <Peaker> you accidentally a word yeah
03:37:16 <ben_m> a whole word?
03:38:02 <mercury^> Yep. Lucky I didn't accidentally the whole sentence.
03:38:44 <ben_m> repetition :: Meme -> Unfunny Meme
03:39:26 <mercury^> fix repetition
03:39:43 <mercury^> mfix*
03:39:56 <Beelsebob> Meme a => a -> Unfunny a surely
03:40:25 <Beelsebob> then one can define instance Meme a => Meme (Unfunny a) and repeat becomes fixable
03:40:39 <ben_m> I don't even know what fix does
03:40:47 <Beelsebob> computes the fixed point of a function
03:40:52 <Beelsebob> > fix (1:)
03:40:53 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
03:41:03 <SamB_XP_> meaning that any meme has unfunny instances ?
03:41:06 <zygospasm> > take 5 . map head . takeWhile (not.null) . flip map (iterate (drop 2 .) id) . flip id $ [1..]
03:41:07 <lambdabot>   [1,3,5,7,9]
03:41:18 <Axman6> SamB_XP_: oh yes
03:41:23 <Beelsebob> SamB_XP_: indeed – and that you can generate them by repeating them enough
03:41:33 <SamB_XP_> true enough ;-)
03:42:10 <SamB_XP_> but lots of them have funny ones too, even if the meme itself is really boring!
03:42:49 <mercury^> SamB_XP_: funnies have an unfunny fixpoint and unfunnies have a funny fixpoint.
03:42:53 <mercury^> Is that what you're saying?
03:43:12 <SamB_XP_> no, you don't get it by repetition!
03:43:29 <ben_m> Joke died a couple lines ago!
03:43:55 <SamB_XP_> joke ?
03:43:58 <Cale> Wow, today's xkcd must have been quite a bit of work.
03:44:05 <Beelsebob> Cale: no kidding
03:44:12 <Beelsebob> especially the last pane
03:44:14 <Beelsebob> >.>
03:44:21 <Cale> heh
03:44:32 <Cale> I don't know what that's referring to
03:44:37 <SamB_XP_> s/pane/pain/ ?
03:44:37 <mercury^> It's wrong though. I checked.
03:44:45 <zygospasm> > fix (\s -> "Sup dawg, we herd you like " ++ show s ++ " so we put \"show s\" in your " ++ show s ++ " so you can \"show s\" while you " ++ show s)
03:44:49 <lambdabot>   "Sup dawg, we herd you like \"Sup dawg, we herd you like \\\"Sup dawg, we h...
03:44:50 <ben_m> I wasted quite some time on that LotR timeline
03:44:55 <titanicheart> wat are applications of Haskell?
03:45:08 <ben_m> titanicheart: Proving when memes become unfunny
03:45:10 <Beelsebob> titanicheart: anything you care to write a program in
03:45:12 <Cale> titanicheart: What are applications of any general purpose programming language?
03:45:42 <mercury^> titanicheart: the largest application of haskell is to compile haskell.
03:45:44 <EvilTerran> titanicheart, if you're looking for specific examples, ghc, xmonad, and yi are all written in haskell
03:45:56 <EvilTerran> @@ (@where ghc); (@where xmonad); (@where yi)
03:45:56 <lambdabot>  http://haskell.org/ghc; http://xmonad.org/; http://www.haskell.org/haskellwiki/Yi
03:46:42 <Cale> There are also a number of companies which use Haskell for various things.
03:47:35 <Cale> Notably financial applications, and high-assurance applications to things like cryptography.
03:47:55 <titanicheart> will haskell be dere in 2011?
03:48:02 <Cale> "dere"?
03:48:08 <mercury^> thare
03:48:13 <ben_m> dare
03:48:24 <ben_m> deer!
03:48:41 <Cale> dear? :)
03:48:41 <hiredman> it will be if you burn it to a dvd
03:48:48 <titanicheart> will haskell be dere in 2011?
03:49:12 <Cale> titanicheart: I don't understand your question. "dere" is not an English word with which I am familiar.
03:49:22 <Axman6> titanicheart: dere isn't an english word...
03:50:03 <mercury^> titanicheart: That is currently very uncertain. A group of haskell supporters is trying to protect the last surviving haskell, but the unscrupulous haskellers are driving it to extinction.
03:50:12 <titanicheart> will haskell be there in 2011?
03:50:24 <Cale> titanicheart: Will it be where exactly?
03:50:25 <Axman6> titanicheart: haskell is 20 years old, i'm sure it will be around in 2011
03:50:33 <jlouis_> titanicheart: yes, don't be silly
03:50:48 <titanicheart> ok...but what are modern substitutes of Haskell?
03:50:56 <vegai> what if Haskell gets run over by a bus next month?
03:51:08 <Cale> titanicheart: Haskell isn't about to be replaced, or I would be programming in something else.
03:51:08 <Beelsebob> titanicheart: there are none
03:51:11 <HugoDaniel> :P
03:51:12 <Beelsebob> well, there are sum
03:51:14 <Beelsebob> some*
03:51:18 <Cale> There's Agda.
03:51:18 <Axman6> Haskell doesn't need modern substitutes, it's far more advanced than most languages out there
03:51:20 <Beelsebob> but they’re not the samething
03:51:31 <Cale> and Epigram
03:51:37 <HugoDaniel> and Java :)
03:51:42 <Beelsebob> I wouldn’t call them modern substitutes of Haskell
03:51:42 <ben_m> ... haha
03:51:51 <SamB_XP_> lol@vegai
03:52:00 <HugoDaniel> it seems like java would be a nice language for you :)
03:52:11 <Cale> There's O'Caml
03:52:11 <titanicheart> HugoDaniel: i m learning java
03:52:12 <ben_m> Don't be mean :P
03:52:16 <Beelsebob> I’d call them yet more {advanced | experimental} languages
03:52:18 <Cale> It's not too far from Haskell
03:52:20 <SamB_XP_> HugoDaniel: why -- 'cause it has modern substitutes ?
03:52:23 <sinelaw> does Galois, Inc. have anything to do with Galois, Fields?
03:52:24 <Cale> and there's Clean
03:52:27 <Axman6> titanicheart: java is a terrible language compared to haskell
03:52:29 <koeien> Agda!
03:52:34 <Cale> sinelaw: They share the same namesake.
03:52:35 <HugoDaniel> :)
03:52:36 <SamB_XP_> sinelaw: named after the same guy
03:52:38 <Cale> sinelaw: That's about it.
03:52:39 <titanicheart> i wonder how haskell implements things!
03:52:49 <sinelaw> SamB_XP_, Cale  that much I can guess.
03:52:54 <Cale> @where lyah
03:52:55 <lambdabot> www.learnyouahaskell.com
03:52:58 <Cale> titanicheart: ^^
03:53:15 <Cale> titanicheart: Or you mean, you wonder how ghc is implemented?
03:53:17 <sinelaw> titanicheart, http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/index.htm
03:53:18 <koeien> i wouldn't name my company after a guy that died being 20, but that's just me ;)
03:53:19 <SamB_XP_> sinelaw: but they for some reason won't take my suggestion that they form a field hockey team seriously!
03:53:23 <Beelsebob> is O’Caml more recent than Haskell?
03:53:29 <Beelsebob> blimeh
03:53:31 <Cale> Beelsebob: No, less recent.
03:53:32 <koeien> Beelsebob: no
03:53:35 <Beelsebob> oh, okay
03:53:41 <Beelsebob> was wondering where that came from
03:53:42 <titanicheart> lol
03:53:55 <SamB_XP_> who cares when the language was begun?
03:54:06 <titanicheart> im an engineering student..so i was wondering whether i shud b wasting my time in haskell or not
03:54:07 <Cale> koeien: He's immortal though, don't you know that?
03:54:08 <Beelsebob> SamB_XP_: point
03:54:16 <sinelaw> titanicheart, so am I, and you should.
03:54:21 <Axman6> titanicheart: where are you a student?
03:54:22 <Beelsebob> titanicheart: absolutely you should
03:54:34 <Axman6> titanicheart: i am tool, and i'd highly recommend haskell
03:54:34 <kakin> anyone know how can apply that in haskell :   int Code(int len) { int val = 0,i; for(i=0; i<len; i++) { val = val*2;} } ??
03:54:37 <koeien> titanicheart: :( me too
03:54:38 <Beelsebob> noting of course that it’s not a waste of time
03:54:39 <sinelaw> engineering completely misses this huge gem called functional programming
03:54:40 <SamB_XP_> titanicheart: how would you prefer to waste your time ?
03:54:41 <mercury^> Cale: You mean Haskell 98? Because Haskell is older than Ocaml.
03:54:50 <Cale> mercury^: hmm.
03:55:08 <Beelsebob> kakeman: lengthTimes2 = (*2) . length
03:55:10 <Cale> mercury^: Perhaps I have the timeline wrong :)
03:55:13 <Axman6> koeien: code = const 0
03:55:14 <Axman6> >_>
03:55:26 <Cale> mercury^: I figured that most of the ML languages were around well before Haskell.
03:55:27 <Beelsebob> kakeman: oh wait, you were given the length
03:55:29 <Beelsebob> it’s (*2)
03:55:39 <sinelaw> at my place they teach us to be satisfied with matlab / vhdl / verilog / c
03:55:42 <profmakx> :( still hackage grief. any news about that?
03:55:43 <titanicheart> SamB_XP_: i dont know
03:55:44 <Cale> mercury^: But yeah, perhaps O'Caml in particular is newer than Haskell 1.
03:56:01 <Beelsebob> oh, and that’s a * not a +, so it’s (^2)
03:56:05 <Cale> profmakx: It's still 3:55am in Portland.
03:56:07 <Beelsebob> (2^) even
03:56:10 * Beelsebob failing today
03:56:15 <Axman6> Beelsebob: val = 0 >_>
03:56:15 <Cale> profmakx: Wait until people make it into work ;)
03:56:21 <Axman6> > 0^12355
03:56:22 <lambdabot>   0
03:56:23 <profmakx> pf. usa
03:56:32 <sinelaw> hackage is kaput?
03:56:32 <Beelsebob> Axman6: oh, rofl
03:56:33 <mreh> > let xs = [1..10] in map (catMaybes . zipWith $ (\a b -> if b == 0 then Nothing else Just a) xs) (repeat . cycle $ [0,1])
03:56:34 <lambdabot>   Couldn't match expected type `[Data.Maybe.Maybe a]'
03:56:34 <lambdabot>         against inferre...
03:56:35 <Beelsebob> I really am failing today
03:56:35 <profmakx> okay, thanks Cale, i didnt think about that ;)
03:57:06 <sinelaw> they should have a backup team in europe or somewhere
03:57:10 <Axman6> mreh: why aren't you using [True,False]?
03:57:11 <SamB_XP_> Cale: what be they doing there? raiding the Pattern Repository?
03:57:11 <sinelaw> on mars perhaps
03:57:23 <Beelsebob> Axman6: your const 0 doesn’t generate the compiler warning that his should though
03:57:25 <Cale> Or, you know, they could prove that their server wasn't going to go down. ;)
03:57:26 <SamB_XP_> sinelaw: mars is too inaccessible
03:57:27 <Beelsebob> (no return value)
03:57:34 <sinelaw> SamB_XP_, that's the point
03:57:35 <Axman6> Beelsebob: ha, true
03:57:35 <SamB_XP_> also, the lag is kind of bad
03:57:43 <Cale> SamB_XP_: Er, aren't they out in that direction?
03:57:50 <mreh> Axman6 because my data is represented as Double in the adjacency matrix, it's
03:57:54 <ben_m> kakin: would've went with "code = undefined"
03:57:59 <mreh> i'd have to convert them all to Bools
03:58:03 <dolio> Everyone's going to switch to Idris in a month or two. Just watch.
03:58:04 <SamB_XP_> Cale: dunno!
03:58:06 <sinelaw> there are a few hackage mirrors, no?
03:58:12 <sinelaw> dolio, Idris?
03:58:16 <Axman6> kakin: your C program doesn't make any sense at all
03:58:16 <dolio> :)
03:58:21 <mercury^> ben_m: const undefined
03:58:33 <titanicheart> how can i install haskell in Ubuntu 9.04
03:58:34 <Cale> SamB_XP_: I was pretty sure that Galois was in Portland, but I could be wrong :)
03:58:40 <SamB_XP_> I'm just coming up with silly jokes based on the fact that c2.com, home of WikiWiki, is also in portland
03:58:58 <mercury^> titanicheart: Your best option is to download the GHC binary and then install cabal.
03:58:58 <Cale> "The Galois mission is to create trustworthiness in critical systems" *jab* *jab*
03:59:03 <SamB_XP_> or at least used to be
03:59:07 <Beelsebob> kakin: a better question would be “I would like to calculate this, how might I do it in Haskell”, (a) because your C program is broken (b) because translitterating C in Haskell is the wrong way to approach the problem
03:59:16 <titanicheart> mercury^: guide me
03:59:22 <sinelaw> titanicheart, follow instructions for haskell-platform, but it's down currently. http://hackage.haskell.org/platform/
03:59:23 <ben_m> Beelsebob: I don't think he reads/cares at all
03:59:25 <Axman6> Cale: ha, yeah be sure to bring that up with dons or whoever next time they're around :P
03:59:47 <sinelaw> I thought hackage was maintained by Yale, no?
04:00:00 <mreh> can someone show me what's wrong with this?
04:00:03 <mreh> > let xs = [1..10] in map (catMaybes . zipWith $ (\a b -> if b == 0 then Nothing else Just a) xs) (repeat . cycle $ [0,1])
04:00:04 <Axman6> kakin: can you please pick a nick and stick to it?
04:00:04 <lambdabot>   Couldn't match expected type `[Data.Maybe.Maybe a]'
04:00:05 <lambdabot>         against inferre...
04:00:09 <SamB_XP_> sinelaw: well, they don't host the site!
04:00:13 <mreh> I just can't see it
04:00:26 <Axman6> mreh: repeat . cycle? 0.)
04:00:27 <SamB_XP_> the physical location of the server is what's relevant here, we think?
04:00:29 <Axman6> o.O*
04:00:29 <Cale> sinelaw: It was the Galois people who fixed it when it went down last week or something.
04:00:38 <titanicheart> the last version released was in 2004
04:00:39 <Axman6> > cycle [0,1]
04:00:40 <lambdabot>   [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,...
04:00:45 <SamB_XP_> Cale: I think that was more than a week ago ...
04:00:47 <Axman6> titanicheart: last version of what?
04:00:50 <mreh> repeat . cycle $ [0,1]
04:00:51 <titanicheart> haskell
04:00:55 <mreh> > repeat . cycle $ [0,1]
04:00:56 <lambdabot>   [[0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0...
04:00:59 <mreh> hmm
04:01:00 <SamB_XP_> but possibly it's recurred that I haven't known of.
04:01:03 <titanicheart> what is this cycle/
04:01:04 <titanicheart> ?
04:01:05 <mreh> but that's what I want
04:01:10 <Cale> titanicheart: "Haskell" is a programming language. There are a few implementations of it.
04:01:11 <mreh> a list of lists
04:01:18 <kakin> sry, that is the C program http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=11405
04:01:33 <SamB_XP_> but then, there aren't many implementations of C# either
04:01:36 <sinelaw> titanicheart, i suggest you start with RWH
04:01:37 <sinelaw> @where rwh
04:01:38 <lambdabot> is http://www.realworldhaskell.org/blog/
04:01:42 <Beelsebob> kakin: what’s the problem you’re trying to solve
04:01:48 <SamB_XP_> in fact, I think there are more of Haskell than of C# ?
04:01:52 <Cale> titanicheart: The most popular implementation is GHC, and the latest version of that was released last July.
04:01:56 <Beelsebob> i.e. I’m not going to sit and try to read a horribly messy C program
04:01:58 <koeien> yhc, hugs, uhc, jhc, ghc ?
04:02:01 <mreh> > let xs = [1..10] in map (catMaybes . zipWith $ (\a b -> if b == 0 then Nothing else Just a) xs) (repeat . take 10 . cycle $ [0,1])
04:02:03 <lambdabot>   Couldn't match expected type `[Data.Maybe.Maybe a]'
04:02:03 <lambdabot>         against inferre...
04:02:10 <kakin> the Code () function, I dunno how implement i and initialize
04:02:12 <Cale> titanicheart: GHC is about to release a new major version soon, too.
04:02:15 <titanicheart> can u get me link to thing released last july
04:02:17 <mreh> > repeat . cycle . take 10 $ [0,1]
04:02:18 <lambdabot>   [[0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0...
04:02:20 <ben_m> Wow, that's some horrible C code
04:02:23 <ben_m> :/
04:02:23 <SamB_XP_> not that most of the implementations of Haskell actually work or anything
04:02:25 <Cale> http://haskell.org/ghc/download_ghc_6_10_4.html
04:02:27 <Axman6> kakin: have you actually taken anyone's advice? i've been trying to help you for a few days, and you just don't listen
04:02:29 <SamB_XP_> ben_m: what is ?
04:02:30 <fasta> koeien, and none of them implement Haskell 98 + Addendum.
04:02:37 <mreh> > repeat . take 10 . cycle  $ [0,1]
04:02:38 <lambdabot>   [[0,1,0,1,0,1,0,1,0,1],[0,1,0,1,0,1,0,1,0,1],[0,1,0,1,0,1,0,1,0,1],[0,1,0,1...
04:02:43 <ben_m> SamB_XP_: What kakin just pasted
04:02:51 <SamB_XP_> C code ???
04:02:59 <SamB_XP_> -> ##c ;-P
04:03:11 <kakin> yes I taked, but im new and dunno how do that
04:03:12 <titanicheart> do u guys hate C ?
04:03:16 <mreh> yes
04:03:18 <SamB_XP_> }:->
04:03:26 <mreh> > let xs = [1..10] in map (catMaybes . zipWith $ (\a b -> if b == 0 then Nothing else Just a) xs) (repeat . cycle $ [0,1])
04:03:27 <lambdabot>   Couldn't match expected type `[Data.Maybe.Maybe a]'
04:03:27 <lambdabot>         against inferre...
04:03:27 <fasta> titanicheart, I mostly hate 'u'.
04:03:28 <sinelaw> kakin if you're working on C, try the channel ##c
04:03:29 <SamB_XP_> titanicheart: no, we just know it's place ;-P
04:03:40 <ben_m> its*
04:03:40 <Axman6> titanicheart: u isn't a word
04:03:41 <Cale> titanicheart: C is a fine target language for a compiler.
04:03:45 <Beelsebob> kakin: I didn’t ask for an explanation of your C code – I asked for an explanation of the problem
04:03:48 <sinelaw> Axman6, C isn't a word
04:03:52 <Cale> titanicheart: But it is not something that I would want to program in by hand.
04:03:58 <SamB_XP_> also, ##c is notoriously rough on newbies
04:03:58 <sinelaw> well, at least in English
04:04:05 <Axman6> sinelaw: luckily it wasn't being used as one, as such.
04:04:08 <SamB_XP_> C is a word
04:04:09 <Jafet> C is notoriously rough on newbies.
04:04:16 <SamB_XP_> Jafet: this is true
04:04:19 <sinelaw> newbies are notoriously rough on u
04:04:19 <fasta> Just like English is a word, C is too.
04:04:23 <Jafet> So...... monomorphisms!
04:04:26 <Jafet> Discuss.
04:04:44 <ben_m> I can't, I have no idea what that is.
04:04:49 * sinelaw </troll mode>
04:04:52 <SamB_XP_> but ##c could be a bit nicer about it -- tell them kindly to please try another language instead until they are no longer newbies to programming ...
04:04:55 <kakin> the problem is that I dunno how use the i variable in haskell
04:05:04 <SamB_XP_> like, oh, 6502 assember or so
04:05:09 <ben_m> kakin: The problem is that you don't read what we write.
04:05:13 <sieni> titanicheart: C is quite fine for some low-level and performance-critical stuff
04:05:13 <Beelsebob> kakin: that’s because Haskell doesn’t have variables that you can change
04:05:20 <ben_m> kakin: Try to tell us what the code is supposed to do
04:05:22 <Beelsebob> kakin:  what is the *problem* you are trying to solve
04:05:22 * vegai thinks stereomorphism has a better zinq to it
04:05:23 <zygospasm> Jafet: monomorphism: the belief that parametricity is evil?
04:05:24 <Axman6> kakin: please, go and read a tutorial!
04:05:33 <koeien> sieni: as long as you see it as "portable assembly"
04:05:35 <sinelaw> kakin, you need to use a tutorial or a book. read through carefully and follow the instructions, and you'll get the hang of it very quickly.
04:05:37 <SamB_XP_> zygospasm: or at least that it should be intentional ;-P
04:05:44 <SamB_XP_> and explicit
04:05:46 <Cale> kakin: and... learn to indent your C code properly. ;)
04:05:50 <sinelaw> kakin, to learn haskell you can try one of these:
04:05:53 <sinelaw> @where rwh
04:05:54 <lambdabot> is http://www.realworldhaskell.org/blog/
04:05:59 <sinelaw> @where lyah
04:05:59 <lambdabot> www.learnyouahaskell.com
04:05:59 <Axman6> @where lyah
04:05:59 <lambdabot> www.learnyouahaskell.com
04:06:03 <Axman6> ^^^^^^^^^^^^^^^^^^^
04:06:03 <ben_m> spam
04:06:05 <SamB_XP_> heck, yeah, indent C code properly
04:06:10 <ben_m> indeed
04:06:16 <SamB_XP_> it's trivial to do that
04:06:18 <ben_m> SamB_XP_: Now you know what I meant with horrible C
04:06:29 <ben_m> gg=G
04:06:35 <SamB_XP_> it can be done by a fairly dumb program
04:06:42 <sinelaw> Now, is it worth learning about Galois fields?
04:06:56 <sinelaw> rather than, e.g. writing my next haskell program
04:06:57 <Jafet> You should already know about Galois fields
04:07:00 <SamB_XP_> Haskell is impossible to indent automatically without extra information ;-)
04:07:02 <koeien> sinelaw: yes!
04:07:12 <titanicheart> sieni: and haskell is good for?
04:07:19 <SamB_XP_> sinelaw: I believe they are useful for Forward Error Coding
04:07:21 <sieni> koeien: of course. C neatly combines elegance of Fortran with the portability of assembler.
04:07:24 <Axman6> titanicheart: everything
04:07:29 <fasta> SamB_XP_, can you prove that?
04:07:48 <sinelaw> SamB_XP_, that's exactly why i'm learning about them, but i'm hoping they are more useful than that
04:07:51 <koeien> SamB_XP_: ammong other things. they are used heavily in coding theory and cryptography
04:07:57 <SamB_XP_> fasta: well, how do you know how to indent the where clauses ?
04:08:05 <SamB_XP_> if you have nested ones ?
04:08:09 <sieni> titanicheart: whatever you wish to use it. Haskell is a general purpose programming language.
04:08:12 <titanicheart> can u send an sms using Haskell?
04:08:18 <fasta> SamB_XP_, in particular, that for any collection of chars in a certain order, inserting white-space will return at least two different meanings of a program.
04:08:31 <SamB_XP_> titanicheart: I'm sure that you can, however the way you would do it is probably not very closely related to Haskell
04:08:37 <koeien> also in combinatorial proofs, and so on
04:08:38 <Jafet> A Galois field is a goddam finite field
04:08:42 <sinelaw> titanicheart, can you transport mice with a car?
04:09:05 <fasta> Can we just ban titanicheart?
04:09:17 <sinelaw> in haskell
04:09:18 <Axman6> i'd rather ban kakin
04:09:22 <ben_m> Both!
04:09:24 <SamB_XP_> in fact, the only way I know to send an SMS to myself programmatically involves an SMS gateway from my providers provider ;-P
04:09:51 <Jafet> sinelaw, best done in Squeak
04:09:53 <zygospasm> titanicheart: i wrote a program in python once to send sms messages by sending HTTP POST messages to a web SMS provider. it would be straightforward to port that to haskell.
04:09:56 <sinelaw> Jafet, that's it?
04:10:14 <sinelaw> (galois fields = finite fields)
04:10:16 <Jafet> "In abstract algebra, a finite field or Galois field..."
04:10:25 <Jafet> Hey, it's edited by thousands of people.
04:10:40 <sinelaw> including thousands of idiots. but yes, it's right.
04:10:54 <titanicheart> ok
04:10:55 <SamB_XP_> sinelaw: it's possibly not the only kind of finite field
04:11:06 <titanicheart> i m a child..i m a begineer..you can ban me
04:11:07 <koeien> ??
04:11:15 <Cale> kakin: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=11472#a11472 <-- here is the indented version of your code, btw.
04:11:18 <koeien> finite field = GF
04:11:32 <Jafet> There is only one kind of finite field.
04:11:35 <sinelaw> what's this "Monster group" my book mentions
04:11:36 <SamB_XP_> okay, okay
04:11:36 <Cale> titanicheart: We won't ban you for that. Ask any questions that you like.
04:11:45 <koeien> sinelaw: it's the largest finite simple group
04:11:48 <mreh> can I "import" things into scope with ghci?
04:11:49 <SamB_XP_> but that seems to be a thing that must be shown by proof ?
04:11:52 <Jafet> sinelaw, #math is -->
04:11:59 <Axman6> titanicheart: how old are you?
04:12:02 <Cale> titanicheart: However, it's less useful asking these general sorts of things than just learning the language ;)
04:12:05 <SamB_XP_> Jafet: I heard it was broken
04:12:15 <sinelaw> Jafet, ok :)
04:12:16 <kakin> oh yes Cale, but I didnt paste that
04:12:21 <Cale> kakin: oh, okay
04:12:21 <koeien> SamB_XP_: that is by definition
04:12:32 <quicksilver> mreh: :m
04:12:34 <byorgey> sinelaw: it's the largest sporadic simple group
04:12:41 <Jafet> SamB, it?
04:12:46 <SamB_XP_> koeien: you can't define it to be the only kind of finite field can you?!?
04:12:50 <Cale> kakin: I indented it for you anyway :)
04:12:50 <netinho> sup guys
04:12:59 <SamB_XP_> Jafet: #math
04:13:07 <SamB_XP_> how come #math doesn't need another # ?
04:13:17 <sinelaw> that's redundant.
04:13:25 <SamB_XP_> surely it's not an official channel of the mathematics project ?
04:13:25 <ben_m> The inventor of math approved of the channel
04:13:27 <sinelaw> c has redundancies, math doesn't like them
04:13:36 <Cale> SamB_XP_: the ## thing is retarded
04:13:45 <SamB_XP_> Cale: I don't know ...
04:13:48 <Jafet> SamB, and this is the official Haskell channel
04:13:54 <Cale> SamB_XP_: I think that when it came to mathematics they realised that it was a stupid idea to apply it.
04:13:55 <SamB_XP_> Jafet: yes, it is
04:13:55 <Jafet> Approved by what, spj?
04:14:04 <netinho> does anyone know the fibonacci sequence?
04:14:05 <SamB_XP_> approved by consensus
04:14:09 <Cale> SamB_XP_: We had at least one IRC operator on our side, iirc.
04:14:11 <titanicheart> ok
04:14:12 <sinelaw> heh, but not for ##physics
04:14:15 <nlogax> shouldn't it be #maths ?
04:14:17 <koeien> netinho: yes, i think most of us know. what is your question?
04:14:19 <Axman6> nlogax: well yes
04:14:27 <Axman6> uh, netinho
04:14:28 <Jafet> Clearly there is only one kind of math.
04:14:29 <SamB_XP_> sinelaw: so I guess god liked #math better than #physics ?
04:14:51 <sinelaw> SamB_XP_, as i'm not an abstract group, i'd doubt that
04:14:56 <netinho> I made a fibonacci sequence in linear time with a infinite list, and made the same with a tribonacci too :)
04:14:56 <ben_m> You will be redirected to the correct channel anyways, so it's not really a problem, is it?
04:15:08 <Cale> netinho: yep
04:15:17 <Cale> > fix ((0:) . scanl (+) 1)
04:15:17 <netinho> but now I read somewhere that you can both in log time, instead of linear
04:15:22 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
04:15:26 <koeien> netinho: yes, you can!
04:15:32 <Cale> netinho: yeah, "log time"
04:15:42 <koeien> it's very easy using linear algebra
04:15:47 <Cale> It's not really log time, but relative to the "linear time" version, it is ;)
04:15:47 <Jafet> netinho, derive identities for F_2n and F_2n+1
04:15:50 <netinho> koeien: matrixes?
04:15:56 <SamB_XP_> you can't generate the first n elements of a sequence in log time!
04:16:05 <koeien> netinho: yes
04:16:18 <mercury^> netinho: calculating a single number is easier than evaluating the whole chain leading up to it.
04:16:20 <koeien> SamB_XP_: no, correct, but calculating fib(n) can be faster
04:16:25 <Jafet> Matrices have nothing to do with it
04:16:32 <mercury^> Jafet: yes, they do.
04:16:38 <SamB_XP_> koeien: possibly, yes ;-)
04:16:39 <koeien> Jafet: you can derive the identities easily using matrices
04:16:46 <Cale> Jafet: they help explain one of the ways of speeding up the computation
04:16:49 <sinelaw> i stopped visiting #math when someone came in saying "hi" and the repsonse was: "off topic! #not-math"
04:16:59 <SamB_XP_> sinelaw: lol
04:17:01 <Jafet> You can express it with matrix multiplication, but they're not particularly relevant to the main idea
04:17:06 <Cale> sinelaw: Yeah, we have some idiots there. Luckily they are not ops.
04:17:07 <sieni> nlogax: I guess it depends where you are from (the math/maths thingie)
04:17:10 <Axman6> isn't there a O(1) approximation for the fibonacci sequence?
04:17:17 <netinho> Axman6: :P
04:17:22 <Axman6> it involved sqrt 5
04:17:31 <Cale> Axman6: That isn't O(1) to compute.
04:17:31 <netinho> oh, right
04:17:32 <SamB_XP_> oh, the golden ratio maybe ?
04:17:32 <mercury^> Axman6: you still need to exponentiate.
04:17:33 <koeien> Axman6: as long as you are willing to accept square roots of 5 :P
04:17:33 <sinelaw> you mean the golden ratio
04:17:37 <Jafet> My program runs in O(1) program invocations!
04:17:42 <mercury^> Axman6: and it's exact.
04:17:51 <nlogax> sieni: oh i see, american english and british english
04:17:53 <Cale> Axman6: You have to compute sqrt(5) to enough precision, which takes a nontrivial amount of time
04:17:55 * nlogax is neither
04:18:03 <SamB_XP_> Cale: it does ?
04:18:05 <Axman6> Cale: detsails!
04:18:09 <sinelaw> Cale, but only once
04:18:13 <SamB_XP_> how much precision do you seriously need?
04:18:15 <Cale> and then exponentiate real numbers with enough digits to maintain precision
04:18:17 <Jafet> Write the program in Joy and prepend it to the input!
04:18:24 <SamB_XP_> hmm.
04:18:24 <sieni> nlogax: http://en.wiktionary.org/wiki/maths
04:18:29 <Cale> SamB_XP_: larger and larger amounts depending on n
04:18:34 <medfly> good morning
04:18:38 <sinelaw> well i guess the further down the seuqence you go, the more precision is needed
04:18:50 <Cale> medfly: good... afternoon :)
04:18:51 <sinelaw> hey medfly, you call this morning?
04:18:52 <sinelaw> :)
04:18:59 <medfly> not really :)
04:19:03 <Jafet> On a Blum real number machine, one may take square roots in unit time.
04:19:03 <netinho> http://mathforum.org/library/drmath/view/51576.html
04:19:07 <SamB_XP_> well, what if you don't actually need the exact sequence ?
04:19:17 <SamB_XP_> Jafet: that doesn't actually exist
04:19:17 <quicksilver> Cale: erm, you don't need real numbers do you? not really
04:19:24 <sinelaw> SamB_XP_, won't it diverge completely past some n?
04:19:25 <mercury^> Jafet: cool. Where do I order?
04:19:34 <quicksilver> Cale: it's a calculation in Q[sqrt(5)] and it always results in an integer
04:19:42 <quicksilver> Cale: so it's purely formal expansion.
04:19:46 <quicksilver> Cale: I agree it's not O(1) though.
04:19:55 <Jafet> They ran out of business; apparently people preferred their computers to not include rational functions.
04:20:45 <SamB_XP_> huh, why the heck does TAOCP only list the first 31 numbers of the fibonacci sequence in the back ?
04:20:52 <medfly> :)
04:21:24 <heaumer> an pet ash pait lolooooolll
04:21:26 <heaumer> sorry
04:21:27 <SamB_XP_> it should list some ajacent pairs further in ;-P
04:21:36 <Jafet> In the back of what...?
04:21:44 <SamB_XP_> Jafet: volume 1
04:21:49 <SamB_XP_> at least
04:21:54 <Jafet> lolwut
04:22:08 <Vanadium> Maybe they wanted to keep more numbers as a hook for latter volumes
04:22:47 <Axman6> "To see how the story ends, just send $49.95
04:22:50 <Axman6> ...
04:22:56 <Axman6> bah, stupid enter key :(
04:22:56 <medfly> what story?
04:23:05 <Axman6> mercury^: the fibonacci story!
04:23:06 <medfly> shit, now I'm curious!
04:23:11 * medfly sends $49.95
04:23:41 <Jafet> Zees Canadian dollarses are ze virtless!
04:23:43 <Axman6> your fibonacci sequence, indicies 32 - 1000 will arive in 4-6 weeks! Congratulations!
04:23:46 <Cale> quicksilver: Oh, well, that is true.
04:24:28 <Cale> (but yeah, no matter how you do it, it's not constant time ;)
04:24:34 <jkramer> Hi
04:24:50 <Cale> In fact, the analyses which just count the number of multiplies and adds are also sorely incorrect
04:25:01 <Cale> Because the numbers get very large very quickly.
04:25:03 <jkramer> Is there a hackage mirror somewhere that I can use with cabal while hackage is down?
04:25:12 <Cale> and so the performance of multiplication actually matters.
04:25:17 <burp> http://upload.wikimedia.org/math/c/f/9/cf9e689b7872d81c0655a10eaf38aa32.png
04:25:17 <mreh> it doesn't appear that I can do a scatter plot with Graphics.Plot
04:25:22 <sinelaw> I've just invented a new language, called "Maskell", which is completely equivalent to Haskell except that imports are qualified by default. Sue me.
04:25:26 <Cale> jkramer: there is a torrent in the topic
04:25:47 <Cale> jkramer: We're hoping that the Galois people will wake up in a few hours and fix things
04:26:04 <SamB_XP_> Cale: for all of hackage's packages?
04:26:06 <sinelaw> Speaking of SMS's, maybe we should send them a few
04:26:07 <Cale> sinelaw: Ew, I'll stick to Haskell :)
04:26:10 * Vanadium applies Control.Law.Court.sue to sinelaw 
04:26:16 <Cale> SamB_XP_: I'm not sure, I think so :)
04:27:21 <Vanadium> ... maybe that ought to have gone into System.Legal.
04:27:41 * SamB_XP_ wants to see one of those string charts of To Say Nothing of the Dog
04:27:50 <sinelaw> Data.People.Vanadium, Control.Adjectives.Your Control.Law.Court Data.Adjective.Doesnt Prelude.($)
04:27:53 <burp> @let f n = (1/(sqrt 5)) * ( ((1+ (sqrt 5)) / 2)^n - ((1- (sqrt 5)) / 2)^n  )
04:27:55 <lambdabot>  Defined.
04:27:55 <burp> > f 20
04:27:57 <lambdabot>   Ambiguous occurrence `f'
04:27:57 <lambdabot>  It could refer to either `L.f', defined at <local...
04:28:02 <burp> woops
04:28:06 <burp> @let fibs n = (1/(sqrt 5)) * ( ((1+ (sqrt 5)) / 2)^n - ((1- (sqrt 5)) / 2)^n  )
04:28:08 <lambdabot>  Defined.
04:28:09 <burp> > fibs 20
04:28:10 <lambdabot>   6765.0
04:28:11 <SamB_XP_> sinelaw: his court doesn't apply ?
04:28:17 <burp> > fibs 200
04:28:18 <lambdabot>   2.8057117299250997e41
04:28:21 <burp> > fibs 200 :: CReal
04:28:24 <lambdabot>   280571172992510140037611932413038677189525.0
04:28:38 <SamB_XP_> > fibs 200000
04:28:40 <lambdabot>   Infinity
04:28:44 <SamB_XP_> > fibs 200000 :: CReal
04:28:45 <medfly> :)
04:28:46 <sinelaw> > fibs 1.2
04:28:47 <lambdabot>   Ambiguous type variable `t' in the constraints:
04:28:47 <lambdabot>    `GHC.Real.Fractional t'
04:28:47 <lambdabot> ...
04:28:49 <lambdabot>   mueval-core: Time limit exceeded
04:28:53 <SamB_XP_> > fibs 20000 :: CReal
04:28:57 <lambdabot>   mueval-core: Time limit exceeded
04:28:59 <Cale> CReal is teh expensive
04:29:01 <SamB_XP_> > fibs 2000 :: CReal
04:29:05 <sinelaw> > fibs (1%3)
04:29:06 <lambdabot>   mueval-core: Time limit exceeded
04:29:07 <lambdabot>   No instance for (GHC.Real.Integral (GHC.Real.Ratio t))
04:29:07 <lambdabot>    arising from a us...
04:29:12 <SamB_XP_> > fibs 2000
04:29:14 <lambdabot>   Infinity
04:29:14 <Axman6> :t (^)
04:29:15 <Jafet> > gamma 1.2
04:29:15 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
04:29:16 <lambdabot>   Not in scope: `gamma'
04:29:17 <sinelaw> > fibs 0
04:29:18 <lambdabot>   0.0
04:29:19 <Jafet> Pft
04:29:20 <sinelaw> > fibs -1
04:29:21 <lambdabot>   No instance for (GHC.Num.Num (b -> t))
04:29:22 <lambdabot>    arising from the literal `1' at <...
04:29:23 <SamB_XP_> well, that's useful!
04:29:29 <SamB_XP_> > fibs (-1)
04:29:30 <Jafet> @hoogle gamma
04:29:30 <lambdabot> Test.QuickCheck.Poly type GAMMA = Poly GAMMA_
04:29:31 <lambdabot> Test.QuickCheck.Poly type OrdGAMMA = Poly OrdGAMMA_
04:29:31 <lambdabot>   * Exception: Negative exponent
04:29:43 <Axman6> > map fibs [1..10] :: [CReal]
04:29:44 <lambdabot>   [1.0,1.0,2.0,3.0,5.0,8.0,13.0,21.0,34.0,55.0]
04:29:46 <sinelaw> haskell doesn't have the gamma function?
04:29:52 <Axman6> > map fibs [90..100] :: [CReal]
04:29:56 <lambdabot>   mueval-core: Time limit exceeded
04:29:59 <burp> sinelaw: hmatrix
04:30:01 <Axman6> -_-
04:30:04 <Cale> There are implementations available if I recall. But not in the Prelude.
04:30:08 <sinelaw> > fibs fibs 5
04:30:09 <lambdabot>   No instance for (GHC.Real.Integral (b -> t))
04:30:09 <lambdabot>    arising from a use of `L.fi...
04:30:13 <sinelaw> > fibs . fibs 5
04:30:14 <lambdabot>   No instance for (GHC.Float.Floating (f a))
04:30:14 <lambdabot>    arising from a use of `L.fibs...
04:30:16 <sinelaw> > fibs . fibs $ 5
04:30:17 <lambdabot>   Ambiguous type variable `a' in the constraints:
04:30:17 <lambdabot>    `GHC.Real.Integral a'
04:30:17 <lambdabot>   ...
04:30:25 <Axman6> :t fibs
04:30:26 <lambdabot> forall b t. (Floating t, Integral b) => b -> t
04:30:48 <sinelaw> @hoogle Real -> Int
04:30:49 <lambdabot> Warning: Unknown type Real
04:30:49 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
04:30:49 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
04:30:53 <sinelaw> @hoogle Double -> Int
04:30:54 <burp> I used (^)
04:30:59 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
04:30:59 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
04:30:59 <lambdabot> Prelude exponent :: RealFloat a => a -> Int
04:31:20 <sinelaw> @hoogle hmatrix
04:31:21 <lambdabot> No results found
04:31:51 <sinelaw> btw, is there a library for error correcting codes?
04:32:28 <ivanm> sinelaw: it's a package on hackage
04:32:37 <ivanm> and I doubt there's an error correcting code package
04:32:38 <quicksilver> fibs 365 seems to be about the CReal time limit for fibs on lambdabot's current host.
04:32:45 <ivanm> especially since, which error correcting code would you want?
04:32:48 <quicksilver> but I guess that CReal is not precisely optimised for speed?
04:32:54 <Axman6> no
04:32:59 <ivanm> quicksilver: definitely not ;-)
04:33:07 <ivanm> why CReal for an integral function?
04:33:07 <Cale> quicksilver: It's terribly terribly slow for anything requiring more than a handful of operations
04:33:18 <quicksilver> I bet there is a package for formal computations of polynomials, too
04:33:31 <Cale> ivanm: they're using the formula with the Golden ratio.
04:33:31 <quicksilver> which would be faster if you wrote up the Q[/5] I was talking about.
04:33:34 <sinelaw> ivanm, for example, repetitions codes, hamming codes, golay codes, .... just for fun
04:33:39 <burp> one could use libgmp
04:33:42 <quicksilver> but you'd need Integer coefficients.
04:33:52 <ivanm> Cale: ahhh
04:34:06 <ivanm> sinelaw: probably no-one needed it yet ;-)
04:34:06 <Jafet> @let fibs = [0, 1] ++ zipWith (+) fibs (tail fibs)
04:34:07 <lambdabot>  <local>:2:0:
04:34:07 <lambdabot>      Equations for `fibs' have different numbers of arguments
04:34:07 <lambdabot>  ...
04:34:12 <quicksilver> Cale: is it one of these calculations which uses intermediate values far far larger than the result?
04:34:19 <ivanm> burp: isn't that integers only?
04:34:21 <Jafet> Blah
04:34:25 <burp> ivanm: I think not
04:34:29 <Cale> The only way to do it efficiently is to do what quicksilver is suggesting and make use of the fact that all the numbers involved are in Q[sqrt(5)] which has a simpler multiplication.
04:34:31 <sinelaw> ivanm, could be a nice excercise. maybe i'll do it
04:34:39 <sinelaw> exercise is better.
04:34:48 <burp> "GMP is a free library for arbitrary precision arithmetic, operating on signed integers, rational numbers, and floating point numbers. There is no practical limit to the precision except the ones implied by the available memory in the machine GMP runs on. "
04:34:55 <Jafet> @undefine fibs
04:35:00 <Cale> libgmp has arbitrary precision reals, but they don't grow automatically, so you'd have to work out the bound ahead of time
04:35:07 <ivanm> right, GHC just uses it for integers
04:35:11 <Axman6> Jafet: that undefines everything
04:35:20 <Zao> MPFR looks nice.
04:35:20 <burp> "GMP is faster than any other bignum library. The advantage for GMP increases with the operand sizes for many operations, since GMP uses asymptotically faster algorithms."
04:35:47 <Jafet> Axman6, ...lies?
04:36:04 <Axman6> nope. @undefine undefines all @lets
04:36:11 <Cale> burp: Yeah, but it's tricky to work out the exact number of digits you'll need to compute ahead of time here.
04:36:17 <Jafet> burp, however most people don't really multiply five million digit numbers very often
04:36:33 <sinelaw> Windows7ucks, really?
04:36:47 <Jafet> And woe be you if you have to take the gcd of five million digit numbers (GMP still uses suboptimal algorithms)
04:36:48 <Windows7ucks> oh yeah
04:37:02 <Jafet> > fibs 10
04:37:03 <lambdabot>   Not in scope: `fibs'
04:37:12 <burp> Cale: hm, maybe there is also some relation for fibonacci numbers?
04:37:27 <Cale> Jafet: Is there a better algorithm than the Euclidean one?
04:37:29 <oteren> dont think there is
04:37:31 <Jafet> Axman6, I suck then
04:37:36 <oteren> fastest way is the matrix way
04:37:37 <oteren> afaik
04:37:46 <Jafet> Cale, numerous, GMP uses an old one by Lehmer now I think
04:37:56 <Jafet> But there are improved ones
04:38:04 <sinelaw> speaking of fibs, the euclidean one is slowest on a pair of conseq. fibs
04:38:09 <mercury^> Cale: binary GCD is sometimes faster.
04:38:19 <sinelaw> just happens to say this in the book i'm reading
04:38:22 <mercury^> Depends very much on the architecture.
04:39:07 <Jafet> Not asymptotically faster though
04:39:13 <mercury^> Yep.
04:39:27 <mreh> what do I do if I really need a package and don't have darcs installed
04:39:57 <mercury^> install darcs?
04:40:03 <mreh> from where?
04:40:07 <Cale> heh
04:40:07 <mreh> cabal is dead
04:40:14 <mreh> hackage*
04:40:16 <Cale> hackage is down, so everyone has to wait
04:40:19 <mercury^> mreh: see the topic.
04:40:22 <mreh> i know
04:40:26 <Warrigal> Install darcs, use wget instead, download every file manually, do without the package, write a script...
04:40:28 <Cale> But you can get that torrent if you need.
04:40:28 <sieni> single point of failure for the win!
04:40:43 <malosh__> or configure ~/.cabal/config to point to http://www.lama.univ-savoie.fr/~meunier/archive
04:40:46 <mreh> Cale: what's in the torrent? all the data?
04:40:51 <mreh> even the code
04:40:53 <Cale> yeah
04:41:02 <Cale> well, I haven't checked
04:41:08 <Cale> But it's supposed to be a mirror of Hackage
04:41:10 <mreh> oh, i'll use that then
04:41:25 <mreh> why doesn't hackage use the torrent network?
04:41:28 <Jafet> ...why don't they just... mirror hackage?
04:41:29 <Cale> "The Galois mission is to create trustworthiness in critical systems."
04:41:30 <mreh> that's an interestingi idea
04:41:36 <ivanm> Jafet: because they haven't yet
04:41:43 <ivanm> Jafet: hackage-2 is planning on doing so IIRC
04:41:43 <Jafet> Funny.
04:41:58 <burp> hackage is critical :p
04:42:06 <ivanm> up until the last month or so, I don't recall hackage ever being down for more than a few hours
04:42:09 <Jafet> Host hackage on sourceforge!
04:42:15 <ivanm> hmmm.... when did galois take over hosting it? :p
04:42:26 <dcoutts> ivanm: they've always hosted it
04:42:29 <ivanm> Jafet: ummm... we can't because hackage is a limited competitor to sf?
04:42:29 <Cale> Yeah, Galois has been having a surprising amount of trouble with their servers just lately.
04:42:31 <ivanm> dcoutts: oh
04:42:56 <dcoutts> Jafet: and because you can't just host random things on sourceforge, it has to be a specific project
04:43:20 <mercury^> Could move it to UbuntuOne!
04:43:23 <Jafet> dcoutts, oh, you would think so.
04:43:37 <dsouza> or move to something like amazon ec2
04:43:57 <burp> torrentize cabal
04:44:00 <mreh> has someone tried phoning Galois?
04:44:14 <ivanm> mreh: dons knows
04:44:25 <ivanm> burp: you mean have torrents for each individual package file?
04:44:29 <ivanm> wouldn't that be a waste?
04:44:36 <dcoutts> mreh: I've emailed the IT admin, he'll be there in the morning US Pacific time
04:44:36 <burp> ivanm: hm, not exactly sure how to do it
04:44:48 <dcoutts> more realistically, I think we should just make a mirror on sparky.haskell.org
04:44:52 <mercury^> It's not cabal is giant.
04:44:52 <mreh> oh, I thought they were European servers
04:45:04 <dcoutts> mreh: nope
04:45:12 <ivanm> dcoutts: where is sparky hosted?
04:45:18 <dcoutts> community.h.o might be, I'm not sure where that it exactly
04:45:20 <dcoutts> ivanm: chalmers
04:45:39 <ivanm> *nod*
04:45:54 <burp> debian has some experimental aproch, to torrentize apt
04:45:57 <burp> http://wiki.debian.org/DebTorrent
04:46:40 <ivanm> possible problem with torrent: what happens if you want an uncommon package?
04:46:52 <ivanm> torrenting packages doesn't help with the hackage index and docs
04:46:58 <Jafet> The server acts as a seed.
04:47:10 <ivanm> Jafet: I meant if hackage is down
04:47:24 <ivanm> possibly use torrent as a way of keeping servers in sync, but I'm sure there'd be better ways
04:47:30 <Jafet> Well, torrents don't work then
04:47:31 <mreh> if you want a rare package it's no worse than the system we have now
04:47:34 <burp> one has to locally sync filehashes
04:47:35 <Jafet> Hope the developers are online!
04:47:44 <burp> and lookup the torrents via dht or something
04:47:44 <Jafet> Or use a distributed filesystem
04:50:58 <burp> or just kick the hackage server admin's asses ;)
04:51:02 <ivanm> or just have a mirror? :p
04:51:04 <burp> might be the simplest way
04:51:06 <fasta> I am all for any solution that still works after you nuke one continent.
04:51:07 <ivanm> (or three)
04:51:28 <medfly> you can nuke antartica
04:51:37 <SamB_XP_> medfly: a REAL continent
04:51:41 <quicksilver> torrent might work if you had 3 or 4 servers guaranteed to seed *every* package *all* the time.
04:51:47 <dsouza> there won't be left many more continents after nuking 3 conts.
04:51:58 <quicksilver> but... that would probably be much harder to set up than just getting 3 or 4 mirrors.
04:52:00 <dsouza> :-)
04:52:13 <jlouis_> ivanm: you don't need to have individual files for each torrent
04:52:17 <quicksilver> I would just try to persuade one of the big mirrors to mirror it
04:52:23 <ivanm> medfly: OK, which country's zone do you want to nuke?
04:52:24 <jlouis_> ehm, that came out wrong
04:52:26 <quicksilver> mirror.ac.uk would probably do it, if the right person asked.
04:52:41 <burp> or any university
04:52:50 <burp> as they mirror linux distros
04:52:50 <ivanm> jlouis_: well, one big package for the entire thing is harder to automate and update
04:52:56 <jlouis_> You will have multiple files in several torrents and only choose to download part of those torrents. As long as someone has everything in the torrent it works
04:53:03 <medfly> ivanm, the international thing in the middle
04:53:03 <ivanm> jlouis_: (automate in the sense of having tools like cabal-install use it)
04:53:14 <jlouis_> ivanm: true, do something similar to a merke-tree-hash
04:53:22 <jlouis_> merkle*
04:53:27 <ivanm> medfly: "in the middle"? the south pole is owned by USA IIRC...
04:53:52 <jlouis_> the problem with that approach is that when you update something, a torrent has to change
04:53:55 <ivanm> burp: not all unis do it, and they don't typically mirror websites, just the tarballs,e tc.
04:53:56 <EvilTerran> quicksilver, you could get on mirror.ac.uk by putting the project on sourceforge, couldn't you?
04:54:01 <ivanm> jlouis_: as I said
04:54:24 <jlouis_> on the other hand, if you rewrite bittorrent to use merkle-tree-hashes instead, it is trivial
04:54:29 <Jafet> Tarball the website
04:55:02 <jlouis_> It isn't that hard to write a bittorrent client in Haskell with all the new cool concurrency stuff
04:55:29 <jlouis_> I Remember we tried several years ago. In the meantime, I wrote one in Erlang as well
04:55:57 <Jafet> You didn't succeed?
04:56:18 <medfly> then bomb the US part of it
04:56:23 <jlouis_> Jafet: with more patience, we would have
04:56:29 <medfly> colonial bastards!
04:57:15 <jlouis_> Erlang is an obvious choice for a bittorrent client. But 99/100 errors I fixed in the code would have been trivially caught by a type system
04:58:08 <Vanadium> sounds like you need moer unit tests :V
04:58:12 <oteren> how many files / traffic are we talking quicksilver?
04:58:20 <Cale> If not the actual south pole, then something close to it is where a whole bunch of countries' territories meet.
04:58:37 <Cale> http://en.wikipedia.org/wiki/File:Antarctica,_territorial_claims.svg
04:58:37 <quicksilver> oteren: I dunno actually. I'd be surprised if it's more than a few 100 M
04:58:44 <quicksilver> dcoutts: how large is hackage?
04:59:08 <fasta> Cale, good reason to start a war, or so multiple countries believe.
04:59:13 <burp> the torrent is ~80M
04:59:23 <ivanm> has anyone here used haslicer before?
05:00:02 <jlouis_> Vanadium: yeah, definitely. Although some parts of a higly concurrent system is hard to test in isolation.
05:00:15 <fasta> Isn't this "automatic robustness" stuff in Erlang really a myth? You still have to understand exactly what it is that Erlang does, exactly like you would in any other programming language with sufficiently good socket libries and concurrency APIs.
05:00:37 <Vanadium> "sufficiently good socket libraries" sounds like an oxymoron :<
05:01:04 <jlouis_> fasta: come again, I am not sure I understand the question..
05:01:18 <Jafet> Hmm, 80M is... miniscule
05:01:18 <quicksilver> fasta: exceptions caught locally by default and code modules upgradable without bringing hte system down
05:01:25 <quicksilver> fasta: is what they mean by 'robust'
05:01:39 <quicksilver> fasta: it's a fairly risky kind of robustness but I can imagine it can be useful.
05:01:45 <Cale> Jafet: In absolute terms, but it's a lot of plaintext :)
05:01:50 <fasta> jlouis_, re: Erlang being obvious.
05:01:51 <Jafet> Also, robust implementations
05:01:59 <Jafet> Cale, compared to other torrents, that is
05:02:03 <Cale> yeah :)
05:02:22 <fasta> quicksilver, yes, so you can also do the same in Haskell, it's just less popular.
05:02:43 <fasta> Or in whatever programming language that is sufficiently flexible.
05:02:44 <jlouis_> well, Erlang won't work for problems where an error means the MIRV launches on an error
05:02:46 <dcoutts> quicksilver: probably less than a Gb
05:02:55 <quicksilver> fasta: right. "by default" being the point.
05:02:58 <Jafet> Such less popular, it isn't implemented?
05:03:08 <Jafet> An unimplemented feature isn't terribly useful.
05:03:17 <fasta> Jafet, AFAIK, xmonad uses it all the time.
05:03:18 <quicksilver> dcoutts: should definitely get a couple of good mirrors to mirror it.
05:03:48 <Vanadium> What does locally mean there, with exceptions?
05:03:50 <jlouis_> It works brilliantly when you can tolerate that part of the system has an error but it is important to ensure continuity in the application as a whole
05:04:38 <jlouis_> in the torrent client for instance, when an error occurs in the peer protocal communication, that peer goes down, but it does not affect other peers unless they stump into the same bug
05:04:39 <Vanadium> Is that not trivially achieved in Haskell by starting all kinds of erroring stuff in threads that do not propagate exceptions?
05:04:42 <sieni> quicksilver: well, it shouldn't be that difficult to find places to mirror hackage
05:04:50 <quicksilver> sieni: agreed.
05:05:34 <jlouis_> Vanadium: there is no magic to their approach. In their system they just have a concept of "supervisors" which does nothing but keep other processes alive, restarting them when they die
05:06:05 <jlouis_> and an intricate logging system on top of that so you can fix the bug.
05:06:12 <Jafet> Erlang's strengths are sort of orthogonal to the language, really
05:06:17 <jlouis_> indeed
05:06:31 <Jafet> It's the existing implementation that provides its famed flexibility
05:06:36 <koeien> what does #haskell think of scala?
05:06:46 <Jafet> So you can't really compare it to Haskell
05:06:52 <fasta> koeien, a mistake, but that's just me.
05:06:52 <koeien> i looked at it but found it pretty complex
05:06:57 <jlouis_> Jafet: exactly. And there are a *lot* of things they did right in that implementation
05:07:06 <sieni> quicksilver: For example http://ftp.funet.fi/
05:07:18 <Cale> koeien: If you have to program for the JVM, it seems like it's a reasonably decent choice.
05:07:28 <jlouis_> epoll, immutable byte sequences (Data.BitString more or less), async I/O threads etc
05:07:31 <Cale> koeien: But I haven't really tried writing anything in it.
05:07:39 <sieni> quicksilver: http://ftp.sunet.se/
05:07:52 <Jafet> Scala for JVM and F# for .NET, it's a massive conspiracy
05:08:00 <sieni> quicksilver: both have fat pipes
05:08:14 <sieni> quicksilver: and loads of disk
05:09:42 <Cale> It will be nice if we can convince someone to put kqueue/epoll support into GHC's concurrency implementation :)
05:09:58 <oteren> fat tubes are more important sieni
05:10:05 <oteren> or they might clog
05:10:21 <Cale> Well, if that happens, you can always use a truck.
05:11:08 <Cale> Oh wait, the Internet is not a truck.
05:13:58 <sieni> Cale: what would that need?
05:14:06 <Cale> I just the other day got...an Internet was sent by my staff at 10 o'clock in the morning on Friday.
05:14:07 <sieni> Cale: well, I guess I can rtfs
05:14:16 <RayNbow> :t zip
05:14:17 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
05:14:22 <RayNbow> :t uncurry zip
05:14:23 <lambdabot> forall a b. ([a], [b]) -> [(a, b)]
05:14:44 <Cale> sieni: Oh, the epoll/kqueue stuff? I'm not familiar enough with GHC to know.
05:15:02 <quicksilver> Cale: in spite of that, an important part of the internet has in fact been containerised and can be put on the back of a suitable size truck :)
05:15:06 <Cale> sieni: Presumably it would go wherever we're currently using select.
05:15:36 <sieni> Cale: hmm... let's see
05:16:26 <Vanadium> The whole IO machinery in ghc seems pretty strange compared to the single-threaded synchronous standard behaviour in most languages that I am aware of :<
05:16:32 <Vanadium> Where do I read up on it? :V
05:16:50 <Cale> Vanadium: There are a number of papers which you can find from SPJ's website.
05:17:03 <Cale> Vanadium: But, I'm not sure what level of detail you're interested in.
05:17:05 <fasta> Vanadium, I don't think GHC does anything out of standard accepted computer science concepts.
05:17:11 <mux> Cale: it would be a bit annoying to have support for all the various stateful multiplexing syscalls/frameworks in all the OSes, maybe we should have GHC use libevent
05:17:38 <quicksilver> Vanadium: surely GHC has prexisely a single-threaded synchronous IO model?
05:17:50 <ivanm> we need to boost HCAR up in google to refer to our HCAR...
05:17:54 <quicksilver> Vanadium: the point is just that it lets you use threads to get outside that synchrony
05:18:18 <Vanadium> fasta: I did not mean to insult it or anything :<
05:18:57 <Vanadium> quicksilver: Well, there is stuff like being unable to fork (unix-)processes and do standard IO, because the IO manager thread does not get forked along
05:19:31 <quicksilver> Vanadium: haskell doesn't really support process fork at all, no.
05:20:17 <Vanadium> Since most usecases seem to be exec'ing to something else, it does not seem to be a big deal, just a bit peculiar and indicative that it is not entirely like C
05:20:42 <Cale> Vanadium: It's generally far more convenient than C when it comes to threaded IO.
05:21:06 <Vanadium> Cale: Yeah, that seems to be a general theme with Haskell.
05:22:03 <Cale> Vanadium: You run forkIO x where x is some IO action, and that IO action runs in a new lightweight thread which is automatically migrated across cores, and you just use IO from that thread like normal. GHC implements the IO primitives such that they're selected between automatically.
05:22:22 <fasta> Vanadium, I don't believe you did for one second.
05:22:54 <Vanadium> Cale: 'across cores' means 'across system threads', right?
05:23:01 <Cale> Vanadium: yeah
05:23:27 <Vanadium> I do not doubt that ghc is doing a clever thing with its io primitives but I figure I would want to understand what it does in detail in case I want to hook IO from C libraries into it or something :\
05:23:57 <ivanm> Cale, quicksilver: either of you heard of/used haslicer?
05:23:57 <Cale> Well, yeah, if you need to do blocking FFI calls, then things don't work as smoothly.
05:24:04 <Cale> ivanm: no, what is it?
05:24:17 <ivanm> well, it's meant to slice haskell code...
05:24:21 <ivanm> except I can't get it to work
05:24:35 <Cale> Vanadium: Basically, all the IO stuff in Haskell which looks like it blocks is implemented at a lower level with nonblocking IO.
05:24:53 <ivanm> (and reviewers of my paper complained that I didn't reference it when I've never heard of it before, since they have never seemed to really mention it in the normal haskellian channels...)
05:25:01 <ivanm> Cale: http://labdotnet.di.uminho.pt/HaSlicer/HaSlicer.aspx
05:25:12 <ivanm> the Java visualiser doesn't seem to work for me...
05:25:58 <Cale> Heh, I'm downloading the latest Dexter at ~500KiB/s, and the two seeds that represent >90% of that speed are both in Korea. :)
05:26:08 <Vanadium> Cale: I am used to being supposed to use nonblocking IO myself, so the idea hereis that I do not have to because just throwing threads at everything is fast enough?
05:26:22 <ben_m> What's the most elegant way of checking if what the user entered (getLine) is equal to some string?
05:26:32 <Cale> Clearly we need some Korean Haskellers to host mirrors of hackage ;)
05:26:44 <Cale> Vanadium: right.
05:26:47 <Vanadium> liftM (== "some string") getLine?
05:26:53 <jlouis_> Cale: in addition to epoll/kqueue, we also need some mmap(2) access and some pool of I/O threads to handle blocking calls gracefully. Then we can take on any C program
05:26:54 <ben_m> doh :/
05:27:00 <Cale> Vanadium: and if it's not fast enough yet, it's the GHC people's job to fix that for you
05:27:02 <ben_m> Thanks :D
05:27:08 <quicksilver> ivanm: my comment to the haslicer team: code or it doesn't exist ;)
05:27:20 <quicksilver> ivanm: but I have a nasty feeling the code will turn out to be in C#?
05:27:24 <burp> fmap (== "x") getLine
05:27:30 <Vanadium> Cale: So do "safe" ffi calls get hooked into the magical async stew somehow?
05:27:31 <ivanm> quicksilver: there is a website
05:27:31 <Cale> jlouis_: well, the first of those is coming in the new IO library
05:27:35 <ivanm> with Java graphs
05:27:39 <ivanm> but it doesn't seem to work
05:27:41 <jlouis_> Cale: yes!
05:27:56 <ivanm> and I find it a bit weird to get called to task over not mentioning it if it doesn't even work...
05:28:00 <Cale> (so, even earlier than the better event support)
05:28:12 <ivanm> I apparently should also have mentioned programmatica, which also seems to be dead :s
05:28:40 <Vanadium> ivanm: Start your paper with "unlike haslice, this paper offers an actually functioning [...]"
05:28:51 <ivanm> Vanadium: heh
05:29:20 <Vanadium> I suspect SPJ is giving me plenty of reading material. Thanks, Cale. :)
05:29:28 <Cale> Vanadium: I don't think so. If FFI calls block, then they block the OS threads that they get called from, unfortunately.
05:29:28 <ivanm> Vanadium: part of the problem was, I was coming from analysing Haskell from a mathematical perspective; as such, I didn't know the right places to look for existing CS-based analysis tools (working or not) :s
05:29:57 <Cale> Vanadium: The "safe"ness of FFI calls has to do with whether it's okay to call back into Haskell code from the FFI call, iirc.
05:30:46 <ivanm> anyone know if HaRe works/is maintained?
05:31:00 <Cale> ivanm: istr someone got it working with 6.8 not too long ago
05:31:11 <Vanadium> Oh, I suppose I misread the forkOS haddock stuff.
05:31:13 <ivanm> yeah, latest release I can find on the kent site seems to be for 6.8.2...
05:31:26 <ivanm> so I take it this means it won't work with 6.10 let alone 6.12?
05:32:17 <jlouis_> ivanm: Coq/Twelf/Isabelle ?
05:32:23 <ivanm> wow, it's build setup looks fugly...
05:32:30 <ivanm> jlouis_: hmmm?
05:32:44 <Cale> Vanadium: Oh perhaps you're right.
05:32:44 <jlouis_> I mostly do Twelf these days of those. And a bit of Coq. No isabelle.
05:33:24 <Vanadium> No, I do not think so - it refers to not blocking the entire haskell runtime, I assumed it would magically not block a given OS thread somehow.
05:33:37 <Cale> Vanadium: Perhaps the same mechanism which makes it safe to call back into Haskell code ensures that other Haskell code is migrated to other threads before the call.
05:33:44 <Cale> (other OS threads)
05:34:02 <ivanm> Cale: looks like they've dumped it for erlang refactoring...
05:34:06 <jlouis_> ivanm: CS-based analysis tools of mathematics, so to speak
05:34:18 <jlouis_> Coq has the most mathematical approach, perhaps
05:34:20 <Vanadium> Ah, right.
05:34:23 <jlouis_> Twelf is ... different
05:34:24 <ivanm> jlouis_: ahhh, no, I'm talking about mathematical analysis of code ;-)
05:34:36 <Saizan> jlouis_: what did you use to learn twelf?
05:34:37 <jlouis_> ivanm: Coq can do that
05:34:38 <Vanadium> Yeah, I was definitely confused there. We are calling too many things threads :<
05:34:44 <ivanm> jlouis_: from a graph perspective
05:34:47 <ivanm> not a proof one
05:35:09 <Cale> Vanadium: Yeah, there are Haskell threads, and there are OS threads, and an N:M scheduler in between them
05:35:14 <jlouis_> Saizan: twelf.plparty.org -- and having some users nearby at the University :P
05:35:25 <jlouis_> ivanm: ah!
05:35:32 <Vanadium> This is entirely the kind of stuff I was supposed to have learned from my one year of CS classes :]
05:35:59 <ivanm> jlouis_: I'd give you the hackage link, but since we should all know by now that hackage is down...
05:36:04 <Vanadium> Does forkOS actually build a new OS thread or does it just do the same thing as forkIO except it is always running on the same OS thread?
05:36:09 <ivanm> Vanadium: at least you had some CS classes...
05:36:52 <Vanadium> ivanm: I am a shameful physics student and went to two semesters of CS as a side-subject thing, because I did not like engineering or chemistry
05:37:01 <ivanm> heh
05:37:02 <Cale> Vanadium: good question, all that the documentation says is that it always runs in the same OS thread, not that it makes a new one.
05:37:15 <ivanm> bah, the hare darcs repo is dead :@
05:37:42 <oteren> if it runs in the same os thread
05:37:57 <oteren> then it cant branch out to other cores can it?
05:38:23 <oteren> and that does not make any sense
05:38:48 <Cale> oteren: Well, normally Haskell threads are moved around between OS threads which are created when the program starts
05:39:16 <Cale> oteren: But sometimes you want a Haskell thread to always be scheduled on the same OS thread
05:39:17 <Axman6> oteren: forkOS threads are assigned to a core, and stick to that core (not necessarilly the same core they were forked from)
05:39:39 <Axman6> (actually, that probably isn't true. but when threads move, it's the OS moving them, not the RTS)
05:39:40 <Cale> So forkOS guarantees that, but I'm not sure it does so by starting a fresh OS thread, or just using one of the existing ones consistently.
05:40:07 <ivanm> @hoogle ioErrors
05:40:07 <lambdabot> Control.OldException ioErrors :: Exception -> Maybe IOError
05:40:17 <Axman6> Cale: i believe it is a new OS thread
05:40:34 <Axman6> so, you don't want to use forkOS a lot if you can avoid it
05:40:54 <ivanm> hey, HaRe builds with only 3 lines changed!
05:41:03 <ivanm> Cale: ^^ in case you care ;-)
05:41:11 <Cale> ivanm: that's cool
05:41:22 <Vanadium> Yeah, it calls into pthread_create on unix
05:41:37 <ivanm> Cale: they've hard-coded their build script to use 6.8.2, and need to use OldException rather than Exception
05:41:43 <Vanadium> foreign import ccall forkOS_createThread :: StablePtr (IO ()) -> IO CInt
05:41:52 <Vanadium> int result = pthread_create(&tid, NULL, forkOS_createThreadWrapper, (void*)entry);
05:41:55 <dcoutts> Vanadium: technically I don't think it is specified, and indeed it should not matter when using forkOS
05:41:55 <Vanadium> etc
05:41:56 <ivanm> ghc spits out a lot of deprecation warnings (extension changes), but shmeh
05:42:11 <dcoutts> Vanadium: usually forkOS is not what you want, even when you think is it what you want :-)
05:42:41 <dcoutts> in particular it gives you no more parallelism than normal forkIO
05:42:45 <ivanm> Cale: now I've just got to work out how to install/use it ;-)
05:42:55 <Cale> (and possibly less)
05:42:55 <Vanadium> It has not been what I want so far, so I am inclined to agree, but I kind of want to be aware of those fringe cases when I might want it
05:43:24 <dcoutts> Vanadium: essentially the only thing it's useful for is using OpenGL which uses thread-local state, so it's important there to keep the same OS thread.
05:44:29 <Vanadium> I am curious if I might want to use forkOS to use C APIs that go "only call us from the main GUI thread"
05:44:44 <dcoutts> Vanadium: nope, does not help
05:45:03 <Vanadium> and, uh, make the forkOS'd thread the main gui thread by calling gtk_init from there
05:45:33 <dcoutts> Vanadium: sure, you start gtk_init on your "main" GUI OS thread, but then what
05:45:48 <dcoutts> Vanadium: all other Haskell threads will not run on that GUI OS thread
05:46:18 <dcoutts> so you still have to do something to get your GUI actions to run on the same GUI OS thread
05:46:22 <Vanadium> At some point I probably figure out how to make gtk callbacks call haskell code, which would then be run in the gui thread :<
05:46:53 <dcoutts> Vanadium: exactly, that's what gtk2hs does. It provides postGUISync and postGUIASync which posts the action to the GUI thread
05:47:20 <dcoutts> Vanadium: and as you guessed, it does that by initiating a gtk callback from the GUI thread (by posting a callback onto the glib event loop)
05:47:27 <Vanadium> Right
05:47:45 <Vanadium> So all the "okay run this is one thread" stuff happens in C space anyway, duh
05:48:05 <dcoutts> Vanadium: but if you forget to use postGUI* then all hell breaks loose
05:48:28 <dcoutts> Vanadium: if you're using the multi-threaded RTS
05:49:14 <dcoutts> which is partly why I stick to the single threaded rts for GUI programming, it lets you use multiple Haskell threads and they all run on the same OS thread
05:49:29 <seanmcl> is there any performance problem with orphan instances, or is it just harder for the compiler?
05:49:55 <Vanadium> but my precious two cores :<
05:49:58 <dcoutts> seanmcl: just longer compile times, since the compiler has to go looking through more modules for all the instances
05:51:02 <dcoutts> Vanadium: given the time, one could redesign gtk2hs using a GUI monad that guarantees that when you enter the GUI monad, that you're running on the main GUI thread
05:51:05 <Vanadium> The gtk2hs demo for concurrency for the single-threaded rts has to install a timeout handler to yield to the rts?
05:51:11 <dcoutts> Vanadium: right
05:51:21 <dcoutts> Vanadium: to get cooperative concurrency
05:51:24 <Vanadium> Right
05:51:52 <Vanadium> At some point I would probably just try to get the whole gdk locking thing right
05:52:10 <dcoutts> Vanadium: that's possibly even more expensive
05:52:24 <dcoutts> Vanadium: depends on the level of granularity you do the locking at
05:52:28 <seanmcl> dcoutts: How does this work?  For instance, how can ghc know when there are *not* orphan instances?  It only flags them as warnings.  Since they're not errors, it seems that the compiler would have to search all files anyway.
05:52:30 <Vanadium> Yeah :I
05:52:57 <dcoutts> Vanadium: you'd want the same GUI monad trick, so that programmers are encouraged to make longer sequences of GUI actions
05:53:02 <seanmcl> I mean, how can compile times be faster, even without instances
05:53:16 <Vanadium> Would your GUI monad basically check if it has the lock and if not, use postGUI*?
05:53:19 <dcoutts> Vanadium: then entering/leaving the GUI monad either posts the action into the GUI thread, or it takes the GDK lock.
05:53:25 <Vanadium> right
05:54:02 <dcoutts> Vanadium: on Win32 the impl would have to use the postGUI approach since Win32 GDI rules require access only from the same thread.
05:54:11 <Vanadium> aah
05:54:12 <Vanadium> okay
05:54:33 <dcoutts> then it's just a question of whether on X11, it's faster to use the GDK lock approach or not
05:56:23 <dcoutts> seanmcl: it records when there are orphan instances
05:57:09 <dcoutts> seanmcl: so then all modules that depend (indirectly) on that module have to check it each time they do a (compile-time) instance lookup
05:57:42 <seanmcl> why indirectly?  I thought instances only enter the scope when you directly include the module
05:57:56 <dcoutts> seanmcl: no, instances are always re-exported
05:58:01 <dcoutts> see H98 spec
05:58:07 <koeien> yes, there is no way to avoid it :( unfortunately
05:58:13 <seanmcl> ouch
05:58:18 <seanmcl> ok, so orphans are a bad idea then
05:58:27 <dcoutts> they're certainly discouraged
05:58:30 <dcoutts> especially in libraries
05:58:33 <seanmcl> since as a reader of code, it would be hard to tell when an instance is in scope
05:58:35 <dcoutts> in apps it's pretty much ok
05:58:58 <seanmcl> I see.  Are they planning on making scoped instances for the next haskell version?
05:58:59 <Vanadium> Help me follow along here, what are orphaned instances again? :]
05:59:02 <seanmcl> this seems like a bug
05:59:28 <dcoutts> Vanadium: instances defined in a module other than the one defining the data type or the class
05:59:31 <seanmcl> Vanadium:  it's when you say instance C D where ... and neither the class C nor the type D are defined in the module
05:59:42 <Vanadium> Right
06:05:39 <Vanadium> "A person who has learned the discipline of Karate finds it directly applicable even in bar-room brawls where no one else knows Karate. Can the same be said of functional programming?" hahaha
06:07:44 <quicksilver> seanmcl: No. Scoped instances break *EVERYTHING*.
06:07:57 <quicksilver> seanmcl: scoped instances tear the class system from its roots and replace it with something else.
06:08:15 <seanmcl> but the resulting thing would probably be better, right?
06:08:41 <seanmcl> It probably wouldn't be too hard to fix existing code
06:08:50 <seanmcl> you could have a global export declaration or something
06:09:30 <koeien> uhc has local instances
06:09:33 <twanvl> scoped instances would allow conflicting instances, which in turn could break lots of things
06:09:36 <seanmcl> there are also the issues Hughes points out in his Arrows paper.  Seems like the class system could use an overhaul
06:09:39 <koeien> ... where instance Num X ...
06:10:09 <quicksilver> seanmcl: it would be very hard to fix existing code
06:10:18 <quicksilver> seanmcl: it would no longer be fit for the purpose type classes are for
06:10:24 <quicksilver> you'd have something new - something fit for a different purpose
06:10:31 <quicksilver> and really, why not use explicit dictionaries for that?
06:10:45 <quicksilver> the globality of typeclasses allows us to use them to guarantee invariants
06:10:45 <twanvl> messWithMap :: Map Int -> ...; messWithMap = Map.lookup 123 where instance Ord Int .. -- oops, I broke the map
06:10:57 <quicksilver> and, really, most of the interesting uses of typeclasses relate to that one way or another.
06:11:10 <quicksilver> hmm. surfeit of "and-really"s. My apologise.
06:11:55 <jeltsch> Does anyone know what the last papers about data type families are?
06:11:56 <seanmcl> I don't think that's right.  In 'Modular Type Classes'  by Harper and Dreyer it seems that the theory is well worked out, and they give ample instances where global classes are a bad idea
06:12:46 <quicksilver> it's not about theory, really, it's about practice.
06:12:47 <seanmcl> why not use explicit dictionaries: for the same reason you don't want them for classes now.  extra typing
06:12:57 <quicksilver> I use explicit dictionaries all the time
06:13:01 <quicksilver> the typing doesn't bother me in the slightest
06:13:13 <quicksilver> certainly it's no more typing than the suggested "with instance Fooble"...
06:13:21 <twanvl> One thing that could be easily added to haskell is local instances for local types
06:13:26 <seanmcl> so what do you have against scoped classes.
06:13:36 <quicksilver> in practice, typeclasses guarantee invariants like Data.Map, Binary, and so on
06:13:40 <quicksilver> (Typeable is another)
06:13:49 <seanmcl> invariants like what?
06:14:13 <quicksilver> the strucutre of the Tree in Data.Map
06:14:17 <quicksilver> the format of the data in Data.Binary
06:14:18 <koeien> in a tree, all elements in left are smaller, all elements in right are larger than the current node
06:14:30 <quicksilver> the type of the existential, in Dynamic/Typeable
06:14:34 <seanmcl> how would scoped classes break that?
06:14:36 <quicksilver> local instances would break all three of those
06:14:46 <quicksilver> because you could put another instance in scope and you then have an invalid structure.
06:14:59 <FunctorSal> seanmcl: explicit dicts and implicit params.......?
06:15:04 <seanmcl> but Data.Map doesn't export any classes...
06:15:15 <quicksilver> the class in question is Ord.
06:15:26 <FunctorSal> but I heard implicit params are evil
06:15:48 <seanmcl> no, it wouldn't break them
06:15:55 <seanmcl> oh
06:15:57 <seanmcl> hmm
06:16:06 <seanmcl> right
06:16:10 <seanmcl> I see
06:16:20 <seanmcl> ok, you just need dependent types
06:16:23 <quicksilver> typeclasses give us a kind of type function.
06:16:30 <seanmcl> to ensure ord satisfies those laws
06:16:42 <seanmcl> :)
06:16:43 <quicksilver> if you stop typeclasses being global, then the function stops being a function
06:16:59 <quicksilver> it becomes something different in different lexical scopes
06:17:01 <quicksilver> which makes it less useful.
06:17:40 <FunctorSal> mappend = getMappend ?monoid
06:17:41 <seanmcl> but it doesn't bother you at all that importing modules changes the context without telling you?
06:17:51 <seanmcl> I find that kind of disconcerting
06:18:00 <seanmcl> especially if they are transitive
06:18:05 <FunctorSal> let ?monoid = sumMonoid in ........
06:18:45 <seanmcl> also, declaring an instance of class Monad assumes return and bind satisfy the monad laws
06:18:50 <Berengal> seanmcl, if it still compiles after importing a module, nothing is changed
06:18:51 <seanmcl> I don't see why it shouldn't be the same with Ord
06:19:09 <seanmcl> Berengal: that's true.  Still, seems a bit creepy
06:19:09 <FunctorSal> Berengal: overlappinginstances?
06:19:14 <Saizan> seanmcl: you can have two different instances of Ord both satisfying the laws
06:19:28 <seanmcl> but if they both satisfy, the tree is balanced
06:19:32 <seanmcl> so why should you care?
06:19:37 <koeien> seanmcl: the opposite order always satisfies the laws too, but would invalidate the Data.Map's assumptions
06:19:37 <Saizan> that's false.
06:19:43 <Berengal> FunctorSal, true, but that's in the "eeh, scary" extensions
06:20:07 <quicksilver> seanmcl: I would prefer it if all instances were automatically visible everywhere the types are
06:20:13 <Saizan> seanmcl: well, maybe balanced, but it won't be a valid search tree under the other instance
06:20:16 <quicksilver> (since instances are global anyway, they might as well be)
06:20:26 <quicksilver> it's just a compiler implementation detail.
06:20:38 <FunctorSal> how would it know where to look?
06:20:59 <seanmcl> Saizan: what is false?  that the tree is balanced?
06:21:10 <koeien> seanmcl: that the tree still satisfies its invariant
06:21:29 <seanmcl> then the Ord laws aren't strong enough
06:21:32 <koeien> seanmcl: e.g. all nodes in the left branch are less than (in the Ord sense) the current node
06:21:34 <seanmcl> to be basing a data structure on them
06:21:35 <Saizan> seanmcl: it's false that the tree will work as a search tree, i.e. that less than equal elements are on the left and greater elements are on the right
06:21:55 <Saizan> seanmcl: they are perfectly fine if you always use the same ordering.
06:22:45 <seanmcl> But there are lots of interesting Ords on Ints
06:22:57 <seanmcl> and I don't see why whoever is first to define an Int Map should win
06:23:09 <koeien> newtype?
06:23:20 <koeien> there is only one noncontroversial order on Int imo
06:23:30 <Berengal> That's exactly what newtypes are for
06:23:36 <seanmcl> I guess you'd have to have the instance along with the type
06:23:40 <koeien> the larger problem would be a monoid for Int
06:23:57 <koeien> it would be immoral to define one in a library
06:24:15 <seanmcl> koeien: mod N
06:24:23 <seanmcl> oh
06:24:30 <seanmcl> I guess that doesn't work as an order
06:24:31 <seanmcl> my bad
06:24:39 <seanmcl> ok, pick something better... :)
06:24:45 <seanmcl> than int
06:27:08 <koeien> i don't know what you are trying to say?
06:27:23 <FunctorSal> divisibility (but that's just a preorder)
06:27:42 <koeien> yeah, not total
06:27:47 <seanmcl> koeien:  on trees, you could have two different orders, depth and size.  None is better per se
06:28:11 <seanmcl> but if I were to define Ord as size first, you'd have to use a newtype to define it if you actually wanted depth
06:28:36 <Saizan> those wouldn't be very useful orders, actually
06:28:59 <FunctorSal> I didn't mean to say that it'd be useful as an instance ;)
06:29:01 <Saizan> not for using them with Map, at least
06:29:13 <seanmcl> Saizan: are you objecting to my example, or the idea that multiple interesting orders are ever possible
06:29:58 <Saizan> seanmcl: for Ord it seems there's often a very natural choice
06:33:19 <avital> Hi. I'm just starting to figure out Haskell (coming from Clojure). If I rewrite something like 2 + 3 in monad style using the Writer monad, but don't actually call tell (meaning in effect I'm not "gaining" anything from using the monad) [http://paste.pocoo.org/show/148241/], will the code still run more slowly? Does anyone know by how much?
06:33:38 <seanmcl> I guess the problem as I see it is that a type class is not really just a type.  it's the type together with the operations.  Basing an invariant on the type alone forces there to be at most one instance.  If an instance were actually the type together with the operations then you could maintain the invariants regardless of the scoping of the classes.  I don't know a good way to do this, just a thought.
06:35:04 <quicksilver> seanmcl: so, don't use typeclasses for that.
06:35:05 <quicksilver> :)
06:35:10 <seanmcl> :)
06:35:13 <quicksilver> seanmcl: typeclasses are for things which are global.
06:35:20 <quicksilver> other things - structures - should be structures.
06:35:36 <quicksilver> data Monoid a = (a,a -> a -> a)
06:35:55 <quicksilver> then a type "a" together with an object "Monoid a" is a monoid structure.
06:36:00 <seanmcl> yeah, I guess I should just switch to Agda
06:36:07 <quicksilver> or just write this in haskell.
06:36:09 <seanmcl> then I could do what i want
06:36:11 <quicksilver> it's not hard.
06:36:48 <Saizan> you could imagine a Map parametrized be the Ord instance "identity", it's less easy to imagine a ByteString parametrized by the Binary instance
06:37:06 <Saizan> s/be/by/
06:38:28 <fasta> How do I get Haskell-mode 2.6.1 to work on Windows? Symbol's function definition is void: inferior-haskell-load-file
06:38:33 <mreh> :t (^=)
06:38:34 <lambdabot> Not in scope: `^='
06:39:17 <jix> is there a class for types that can be zipped?
06:39:36 <Saizan> there's one in category-extras
06:39:59 <Saizan> and you can do something like zip with Traversable, iirc
06:39:59 <fasta> Ok, I got it. The README file simply is not complete.
06:40:49 <jix> Saizan: thanks
06:41:01 <jix> the thing in category-extras seems to be exactly what i want
06:44:25 <mreh> what is (^=)
06:44:54 <mreh> hehe, it looks like a face
06:44:57 <koeien> some function defined by a module
06:45:00 <koeien> look at the imports
06:45:31 <mreh> have they woken up at hackage HQ yet?
06:45:38 <koeien> dons has reported it
06:45:51 <mreh> it must be at least 9am there
06:46:33 <mreh> hang on, what coast is it, it's pacific standard time there isnt it
06:46:33 <Zao> <insert lazy joke here>
06:46:39 <Zao> Portland, isn't it?
06:46:43 <Vanadium> Zao: goddamn
06:50:51 <Hunner> 6:50am in portland, land of the dons
06:51:13 <quicksilver> Saizan: yes. The bytestring would have to be tagged by the Binary instances of all the types which were - or might be - involved in creation of it
06:52:51 <mreh> i think (^=) might be something to do with template Haskell
06:52:58 <mreh> is that the Data.Accessor module?
06:55:22 <fasta> Hmm, Bittorrent is faster than Hackage has ever been ;)
06:55:45 <fasta> 1MB/s :)
06:56:12 <jmcarthur_work> yeah the torrent works nice
06:56:42 <fasta> At this speed I don't even have to select which package I want. I just get all of them.
06:56:47 <Saizan> mreh: http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:^%3D
06:57:00 <jmcarthur_work> would be nice if cabal supported local mirrors of hackage
06:57:13 <dcoutts> jmcarthur_work: it does
06:57:17 <jmcarthur_work> oh?
06:57:22 <jmcarthur_work> oh i get it
06:57:23 <fasta> I only think there is no concept of uploading on this network.
06:57:28 <sjanssen> jmcarthur_work: it does, sort of.  Drop all of your tarballs into .cabal/packages/hackage.haskell.org
06:57:28 <HugoDaniel> :D
06:57:38 <dcoutts> sjanssen: nooo!
06:57:49 <fasta> Unless nobody is downloading.
06:57:52 <jmcarthur_work> didn't think of that
06:58:00 <dcoutts> you can specify multiple hackage servers in the ~/.cabal/config
06:58:33 <sjanssen> dcoutts: but won't you need HTTP, a package manifest, etc.?
06:58:49 <dcoutts> sjanssen: sure, but that's what a mirror would have
06:59:05 <dcoutts> sjanssen: and further, you can specify local archives
06:59:10 <dcoutts> sjanssen: ie not http
06:59:45 <dcoutts> that's what local-repo is for
07:00:48 <fasta> Is there a way to get the method list with TH?
07:02:20 <FunctorSal> fasta: reify
07:02:47 <fasta> FunctorSal, so, the method list of let's say Monad can be obtained in that way?
07:02:56 <FunctorSal> fasta: yes
07:03:12 <fasta> FunctorSal, I tried to do some simple stuff with TH, and if everything is setup, it's quite nice, yes.
07:03:14 <FunctorSal> , reify ''Monad
07:03:16 <lunabot>  luna: No instance for (GHC.Show.Show
07:03:40 <FunctorSal> , [| litE . stringL . show $ reify ''Monad |]
07:03:41 <lunabot>  luna: Illegal bracket at level Brack 2
07:04:14 <FunctorSal> , [| (litE . stringL . show) (reify ''Monad) |]
07:04:15 <lunabot>  luna: Illegal bracket at level Brack 2
07:04:23 <fasta> The level of concrete syntax can still be improved, I think. E.g. myFun n = [d} x<n> = 1 ] should also work, imho. That is a way to get outside variables into TH code.
07:05:02 <fasta> It appears that when you want to something you almost always end up with using the abstract syntax.
07:05:15 <FunctorSal> mmorrow: lunabot doesn't like me :o
07:05:21 <fasta> The abstract syntax is a lot more difficult to read, imho.
07:05:40 <FunctorSal> yes, I usually use the abstract syntax
07:05:40 <fasta> Er [d|
07:05:41 <Saizan> , $((litE . stringL . show) (reify ''Monad))
07:05:43 <lunabot>  luna: No instance for (GHC.Show.Show
07:05:57 <koeien> fasta: yes i noticed this too, but this could very well be my inexperience with TH
07:06:02 <Saizan> , $((lift . show) =<< (reify ''Monad))
07:06:03 <lunabot>  "ClassI (ClassD [] GHC.Base.Monad [m_1627417930] [] [SigD GHC.Base.>>= (F...
07:06:40 <fasta> koeien, it's not impossible to build a layer on top of TH which does this however. It just needs a compiler flag to get it perfect.
07:06:41 <FunctorSal> fasta: I can't parse your example
07:06:58 <fasta> FunctorSal,  myFun n = [d| x<n> = 1 ]
07:07:19 <fasta> FunctorSal, basically it generates a function x1 = 1, and x2 = 1 etc. Completely trivial.
07:07:50 <FunctorSal> myFun is the TH function, not the code using it?
07:07:50 <fasta> FunctorSal, and the <n> syntax doesn't actually exist.
07:08:07 <fasta> FunctorSal, to use it you would have to splice it using $.
07:08:18 <FunctorSal> yes
07:08:31 <fasta> FunctorSal, in real TH, you end up with makeName and ++ and all kinds of abstract syntax useless crap.
07:09:12 <FunctorSal> hmm I'd like "name backquote" too, yes
07:12:29 <FunctorSal> fasta: the 'useless crap' like NormalB, empty where clause etc can be cut down with wrapper functions though
07:13:03 <fasta> FunctorSal, yes, it's all possible, but the real solution has already been demonstrated and it's called MetaBorg.
07:13:21 <FunctorSal> !
07:13:29 <fasta> FunctorSal, ?
07:13:38 <FunctorSal> sounds scary
07:13:39 <FunctorSal> :)
07:14:04 <Pellwurst> is http://hackage.haskell.org/ down?
07:14:13 <fasta> FunctorSal, it basically does the "sum two  context free grammars"-theoretical trick.
07:14:51 <jre2> is there a standard lib function like maybeToMPlus :: MonadPlus m => Maybe a -> m a
07:14:53 <fasta> FunctorSal, for Haskell that doesn't quite work without some preprocessing, I admit that, but Stratego for program transformation is really nice.
07:15:27 <fasta> jre2, I don't know, I defined it myself. Feel free to send a mail to libraries to propose it.
07:16:11 <FunctorSal> jre2: (maybe mzero return) ;)
07:17:26 <jre2> FunctorSal: that's better than the one I wrote
07:20:38 <seanmcl> When I change the methods in a file, but none of its types, sometimes ghc recompiles a lot of files that depend on that one.  Is this because of inlining or optimizations?  I can't think of another reason.
07:20:39 <fasta> The hackage tarball for the numbers package contains both 0.2.1 and 2009.8.9, which one is the newest?
07:21:25 <fasta> seanmcl, or it just doesn't do a very extensive analysis.
07:21:36 <jlouis_> seanmcl: or because it is lazy and just looks at what files changed in the dependency graph
07:23:04 <noZone> Any reason ghc -threaded would create problems when programs compiled under ghc w/o the -threaded option works fine?
07:23:29 <jre2> noZone: yes
07:23:33 <roconnor> preflex: seen @ivanm
07:23:33 <preflex>  Sorry, I haven't seen @ivanm
07:23:37 <roconnor> preflex: seen ivanm
07:23:37 <preflex>  ivanm was last seen on #xmonad 1 hour, 34 minutes and 2 seconds ago, saying: @tell blazzy to get xmonad to translate keybindings for chrome, have a look at XMonad.Util.Paste
07:24:04 <jre2> noZone: iirc, if your main thread dies (even if workers are busy) the program will exit with one and not the other
07:25:45 <noZone> jre2: in my case the main thread is waiting patiently for other threads to finish, but things behave very badly.
07:28:02 <fasta> Where is the cabal .config file located on Windows Vista?
07:28:19 <dcoutts> fasta: home directory
07:28:30 <dcoutts> fasta: well, that's what it is on XP
07:28:56 <fasta> dcoutts: but shouldn't it create a default configuration file there then?
07:29:03 <dcoutts> it does
07:29:09 <fasta> Ok, looks again.
07:29:25 <lpjhjdh> so what are TyVarBndr's?
07:29:36 <dcoutts> fasta: or perhaps I'm mis-remembering, check under AppData or something like that
07:29:52 <dcoutts> fasta: inside the user's documents and settings dir
07:30:46 <fasta> dcouttss: appdata/roaming
07:31:45 <dcoutts> fasta: oh, that's a new vista thing
07:32:17 <fasta> dcoutts: Vista has been released for 3 years, not that I have used it for more than a week ;)
07:32:30 <Baughn> So I'm trying to teach haskell-indentation about qualified importans and hierarchical module names..
07:32:46 <Baughn> I know the latter is a ghc extension, but when were qualified imports added?
07:32:49 <dcoutts> fasta: it's whatever is returned by getAppUserDataDirectory "cabal"
07:33:27 <fasta> dcoutts: in which module?
07:33:44 <__JN> Hello, if I have a list of lists, and I want a list with all lists from the original that has A as the first element, how can I do that?
07:34:47 <Exteris> filter isA list where isA (x:xs) = x == 'A'
07:35:10 <Exteris> but you shouldnt trust me because i'm not that good at this yet
07:35:14 <Exteris> can someone check this?
07:36:04 <Baughn> filter ((== Just 'A') . listToMaybe) list
07:36:19 <Baughn> Handles the case of empty sublists too
07:36:28 <Exteris> nice
07:36:52 <__JN> thank you! I will try that
07:36:52 <ToRA> > filter ("A" `isPrefixOf`) ["hello", "Awoo!"]
07:36:53 <lambdabot>   ["Awoo!"]
07:37:34 <JRabbit2307> hi everyone
07:37:38 <Exteris> hi!
07:38:00 <JRabbit2307> is anyone familiar with java programming i'm stuck on particular area
07:38:11 <ben_m> Perfect channel to ask.
07:38:19 <Exteris> try ##java
07:39:15 <JRabbit2307> i'm stuck on getting an initial from a fullname i'm trying to obtain it from a charAt method
07:39:42 <ben_m> JRabbit2307: Is this a Java question, or a Haskell question?
07:39:45 <JRabbit2307> its giving me an incompatible type error
07:39:53 <JRabbit2307> Java....
07:39:59 <ben_m> Why are you asking in #haskell then?
07:40:02 <fasta> JRabbit2307, I think you are stuck in the belief that Haskell and Java have anything to do with eachother.
07:40:06 <JRabbit2307> haskell wow am I in the wrong chat maybe?
07:40:12 <medfly> probably :-)
07:40:12 <JRabbit2307> my bad
07:40:14 <JRabbit2307> prob
07:40:18 <ben_m> You're in #haskell, you should be in ##java :D
07:40:21 <fasta> @remember haskell wow am I in the wrong chat maybe?
07:40:22 <lambdabot> Nice!
07:40:32 <JRabbit2307> ok lemme find a way to get htere
07:40:34 <JRabbit2307> lol
07:40:36 <JRabbit2307> *there
07:41:12 <burp> how is this possible? o0
07:41:51 <fasta> Can I list somehow what identifiers a particular package exports?
07:42:19 <fasta> In particular I don't see why Data.Number.CReal isn't found.
07:43:44 <burp> are you sure you have "numbers" installed?
07:44:00 <burp> ghc-pkg list | grep numbers
07:44:05 <fasta> burp, well, I have Numbers installed, so that might be the problem.
07:44:51 <burp> oh, especially with windows, and case insensitive filesystem, yes
07:44:57 <jkff> Hi. Can anyone help me understand the difference between impredicative and higher-rank polymorphism? It appears to me that both mean simply the ability to quantify over a polymorphic type, but I am certainly wrong.
07:44:59 <fasta> burp, the package I have is called Numbers-0.2.1.
07:45:09 <burp> that's the wrong one
07:45:25 <fasta> burp, the directory from the torrented hackage dump only contains a directory called numbers with lower case letters.
07:45:55 <burp> fasta: my torrent has two
07:45:59 <burp> "Numbers" and "numbers"
07:46:06 <burp> but as I said, windows fs is case insensitive
07:46:09 <burp> so there might be problems
07:46:46 <dcoutts> fasta: that's System.Directory
07:46:47 <jkff> It also seems to me from wikipedia that rankn polymorphism deals with which types are well-formed, whereas impredicativity concerns typing rules. But I can't see why they don't mean the same thing anyway. Does one maybe imply the other?
07:47:20 <burp> http://tobias-neumann.eu/tmp/numbers-2009.8.9.tar.gz
07:47:25 <burp> if you have problems getting it
07:48:09 <Asztal> jkff: as an example, [forall a. a] is illegal without impredicative types
07:48:48 <jkff> Aah, I start getting it!
07:48:59 <jkff> Thanks!
07:49:46 <noZone> ... I found a doc on the problem with -threaded and forkProcess. It's an old bug that several people are still (as of Oct 20 2009) waiting for a fix. *bleh*
07:50:18 <quicksilver> noZone: basically, forkProcess is a train wreck.
07:50:21 <quicksilver> noZone: don't use it :)
07:50:35 <noZone> Good luck on that... some things require it.
07:51:02 <jkff> OK, List (forall a. a) is illegal without impredicativity but legal without higher-rankness. So, impredicativity does NOT imply higher-rankedness.
07:51:05 <quicksilver> noZone: like what?
07:51:20 <jkff> But it seems to me that higher-rankedness implies impredicativity, does it?
07:52:03 <jkff> (At least if N>2) Because we could not instantiate a higher-ranked polymorphic type if we did not have support for instantiating anything with polymorphic types.
07:52:14 <noZone> quicksilver: see this: http://74.125.95.132/search?q=cache:-6LWWowa4awJ:hackage.haskell.org/trac/ghc/ticket/1185+ghc+%2B%27threaded%27+problems+forkProcess+getProcessStatus&hl=en&gl=us&strip=1
07:52:28 <jkff> Well, the N>2 restriction can be omitted. So, looks like RankNTypes indeed imply impredicativity.
07:52:47 <quicksilver> noZone: you don't need to fork to daemonize, I don't think
07:52:51 <quicksilver> noZone: you just setpgrp
07:53:21 <noZone> Yes. for simple stuff, but not if you need to monitor multiple daemon threads from a master.
07:53:38 <quicksilver> noZone: then use threads, not processes?
07:53:51 <quicksilver> or just devise a way of communicating through unix sockets or whatever.
07:54:05 <noZone> No, because the threads must change user ids, etc. to avoid security problems.
07:54:08 <quicksilver> I know that occasionally fork() is convenient but I doubt it's ever necessary.
07:54:25 <quicksilver> windows appears to manage without it, for example...
07:55:26 <quicksilver> still, it looks like JaffaCake thinks he has a solution.
07:55:43 <JaffaCake> we're talking about fork()
07:55:44 <lambdabot> JaffaCake: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:55:45 <JaffaCake> ?
07:56:04 <noZone> A classic example is a web server that launches an unprivileged thread (OS process) to service requests. Changing group/user ids is a must.
07:56:56 <quicksilver> JaffaCake: yes.
07:57:18 <dcoutts> quicksilver: windows lets you change or impersonate other users on the fly, within a single thread
07:57:35 <JaffaCake> so AFAIK the only reason to want fork() is so that you can start a server, parse its configuration files (emitting errors to stderr) and then go into the background
07:58:03 <dcoutts> JaffaCake: or for self-imposed ulimits
07:58:15 <fasta> dcoutts: I updated http://www.haskell.org/haskellwiki/Cabal-Install for generic Windows.
07:58:16 <quicksilver> JaffaCake: or, in the case being discussed here, to change user ids
07:58:20 <JaffaCake> you can't do ulimit without forking?
07:58:28 <quicksilver> JaffaCake: (whilst keeping a controlling server privileged)
07:58:40 <dcoutts> JaffaCake: but I don't want to ulimit myself, just this sub-action
07:58:46 <JaffaCake> I thought you could drop privs temporarily in Unix?
07:58:51 <noZone> No
07:58:57 <noZone> Sadly
07:59:02 <quicksilver> you can, but not just for one thread
07:59:06 <quicksilver> AFAIK
07:59:10 <noZone> Yes!
07:59:16 <noZone> That's the problem.
07:59:18 <JaffaCake> isn't that what all this effective-user-id stuff is for?
07:59:24 <JaffaCake> oh, I see
07:59:41 <Pellwurst> can anybody access http://hackage.haskell.org/ ?
07:59:49 <jix> no
07:59:53 <noZone> Only the Haskell gods.
07:59:58 <fasta> Pellwurst, do you always read /topic ?
08:00:13 <Pellwurst> d'oh.... sry
08:00:13 <JaffaCake> dcoutts: ok, I see
08:00:14 * dcoutts never reads the topic
08:00:20 <jkff> Hm, there is some very strong theoretical evidence against my claim that rank-n types imply impredicativity: in GHC, the corresponding flags are independent!
08:00:52 <Asztal> jkff: In 6.12, ImpredicativeTypes will imply RankNTypes
08:00:57 <quicksilver> jkff: well a higher rank type is one thing; using a polymorphic function instantiated with a non-simple type is another
08:01:15 <JaffaCake> so I did have a solution for the fork() issue, but it unfortunately broke something in GHCi
08:01:17 <fasta> Pellwurst, I am mostly joking, I also don't always read the topic ;)
08:01:19 <quicksilver> jkff: so, with higher rank types, I can define (forall a . a) -> (forall b . b)
08:01:31 <quicksilver> jkff: but if I want to use "map" with that parameter type, that's impredicative
08:01:33 <JaffaCake> I was halfway through fixing it when I had to go on holiday. :)
08:01:33 <quicksilver> jkff: I think.
08:01:37 <dcoutts> JaffaCake: it's somewhat like what I was talking about the other day, launching some sandboxed action in a sub-heap and if that heap overflows a limit then well nevermind it fails but doesn't kill off the whole program.
08:01:42 <jkff> Asztal: Thanks again :) Is this descibed in some paper maybe?
08:01:52 <ksf> how does local-repo in ~/.cabal-config work?
08:02:17 <dcoutts> ksf: the local repo look just like the local cache for a remote repo
08:02:21 <Asztal> jkff: Impredicative types is definitely described in a paper, but I don't know which one. The note about ghc 6.12 was from the release notes.
08:02:47 <ksf> I pointed it to the location of the data dir of the hackage archive torrent, but cabal claims it's invalid.
08:02:52 <jkff> quicksilver: well, I'm saying that rankn must imply impredicativity because rankn types can't be used without it
08:03:00 <fasta> dcoutts: custodians in PLT do exactly that.
08:03:07 <jkff> Asztal: Oh, the implication is THAT way? I thought of the opposite!
08:03:13 <ksf> so I have to prepent hackage.haskell.org/ to the path?
08:03:42 <quicksilver> jkff: no, you can use explicitly annotated rank n-types without it
08:03:42 <dcoutts> fasta: how to they handle mutation? like a mutable var ending up pointing into the sub-heap?
08:03:44 <jkff> But [undefined :: forall a . a] is OK with impredicative types and does not require rankntypes, does it?
08:03:54 <ksf> ...or is it the missing index.tar?
08:04:14 <quicksilver> jkff: you just can't instantiation polymorphic functions at higher order types without it.
08:04:20 <fasta> dcoutts: good question, and I have no idea. You should read the paper or implementation I guess. It is documented by a lot of text ;)
08:04:28 <dcoutts> ksf: I don't now remember if it's expecting a 00-index.tar or a 00-index.tar.gz
08:05:01 <ksf> '/home/ksf/.cabal/2009-10-19-hackage-archive' is missing. The repo is invalid.
08:05:27 <fasta> dcoutts: I would guess that the semantics of a custodian are simply to erase all memory after the limit has been exceeded without any further complex things.
08:05:36 <jkff> quicksilver: That's what I'm thinking, but Asztal says that the dependency is the other way round: like if you could not use impredicativity without rankn types.
08:05:40 <dcoutts> fasta: the issue is with dangling references
08:05:54 <ksf> dcoutts, well, neither is there.
08:06:03 <quicksilver> jkff: [forall a. a] is higher rank
08:06:03 <fasta> dcoutts: well, maybe just don't allow that to happen?
08:06:06 <dcoutts> ksf: it must be, or it's not a valid repo
08:06:13 <quicksilver> jkff: (by one possible definition of higher rank)
08:06:24 <ksf> I never said it was, but it's got the same directory structure as the cache.
08:06:24 <quicksilver> jkff: antyhign with a quantifier not at the outermost level is higher rank.
08:06:38 <jkff> Is (a->a, a->a) higher rank?
08:06:42 <quicksilver> yes.
08:06:43 <dcoutts> ksf: so the mirror you've got does not have and 00-index.* file at all?
08:06:46 <quicksilver> well
08:06:49 <quicksilver> depends where the forall is.
08:06:53 <jkff> But it does not require the higher-rank types type system extension.
08:06:56 <Philippa> quicksilver: missing foralls are always on the outside
08:06:57 <quicksilver> forall a . (a -> a, a -> a) is not
08:07:07 <quicksilver> (forall a . a -> a, forall a .  a-> a) is.
08:07:20 <jkff> Ah, I see. That's a bit of an ad hoc definition, anyways..
08:07:38 <ksf> dcoutts, no, the torrent does'nt come with them. Copying them over works, though.
08:07:42 <dcoutts> ksf: gah, what a useless "mirror", missing the most critical file.
08:07:55 <jkff> It defines what is "higher rank", but does not define what the rank of a type is.
08:07:58 <ksf> ...might be a bit out of date, but it's better than installing manually.
08:08:01 <fasta> ksf, which file is that?
08:08:07 <jkff> ...However, it is easily extended to do so.
08:08:39 <ksf> http://www.haskell.org/pipermail/haskell-cafe/2009-November/068398.html
08:08:54 <ksf> mauke!
08:09:02 <ksf> go, repent, ye sinner!
08:09:05 <ksf> repair your torrent!
08:09:10 <quicksilver> jkff: the rank of a type with all foralls at the top level is 1. The rank of a type with foralls at nested levels is 1 + (maximum rank of nested bits)
08:09:13 <shapr> Is there any incremental way to update torrents? The hackage torrent seems like a great way to distribute packages.
08:09:23 <jkff> Precisely.
08:09:30 <ksf> afaik no
08:09:43 <burp>  already seeded ~300MB :D
08:09:57 <fasta> I seeded 0, the leecher that I am.
08:10:01 <Heffalump> if you download a new torrent and point it at the same root, it'll check the hashes of the already present content
08:10:02 <quicksilver> the debian guys went to some great lengths to make a CD image which could be 'rsynced' from a mirror of packages
08:10:03 <dcoutts> fasta: looks like custodians cannot guarantee to release memory, only to close down IO resources
08:10:16 <quicksilver> I think it depended on thinking about block boundaries and aligning stuff carefully
08:10:22 <quicksilver> presumably similar techniques apply to torrents
08:10:40 <quicksilver> you can do it, but you have to try to keep units "likely to change" aligned to the hash-block boundaries
08:10:55 <fasta> dcoutts: that's odd. There are bots that rely on it, I thought.
08:11:13 <fasta> dcoutts: otherwise it should be possible to DOS the bots then.
08:11:16 <jkff> So... Well. Impredicativity imples RankNTypes because without RankNTypes you can't define a type that gives you a chance of trying out impredicativity (you have no rank-n-polymorphic types to instantiate with rank-(n-1) ones). But aren't RankNTypes also useless without impredicativity?
08:11:29 <ksf> the current torrent uses 64k-chunks, which is significantly larger than most of the packages.
08:11:37 <quicksilver> jkff: no.
08:11:38 <jkff> Ah, sorry, of course they are not.
08:11:38 <ksf> ...I think the biggest ones are still < 300k
08:11:39 <dcoutts> fasta: it requires the code to be written properly, so it's ok for things where you're sure you know what it's doing
08:11:45 <dcoutts> fasta: but no guarantees
08:11:50 <quicksilver> jkff: runST works fine without imprediciativity.
08:11:52 <jkff> The (forall a.a, forall a.a) examples shows that.
08:12:05 <quicksilver> jkff: but, you'd need impredicativity to use ($) with runST
08:12:06 <ksf> and using an even smaller granularity is insanity, as the protocol overhead increases
08:12:08 <quicksilver> as many people have found.
08:12:22 <jkff> You mean, runST $ foo ?
08:12:23 <Heffalump> if you have all the data for a chunk then utorrent at least seems to recognise this
08:12:26 <quicksilver> unfortunately, GHC's imprediciative instantiation isn't the right algorithm to use ($) with runST anyway
08:12:29 <quicksilver> so it doesn't
08:12:32 <quicksilver> jkff: yes precisely.
08:12:35 <Heffalump> so I don't think alignment is too crucial
08:12:44 <jkff> Heh, that's funny.
08:12:57 <Heffalump> quicksilver: the left-to-right algorithm it had briefly was :-)
08:13:03 <ksf> ...I don't think vanilla torrents are the best tool for the job.
08:13:17 <ksf> they are, for example, exclusively pull-based.
08:13:35 <Heffalump> are we trying to solve the mirroring problem, or the end-user download problem?
08:13:43 <quicksilver> Heffalump: I did wonder what happened there, since I'm sure runST $ is given as an example in one of the motivational papeprs.
08:14:35 <ksf> I bet some script kiddie is banging away on hackage to make us implement the p2p network to obsolete them all.
08:15:50 <medfly> aww
08:15:56 <medfly> we're being pwned by a script kiddie
08:16:04 <ksf> does anybody know the size of the whole archive, including old package versions, that is?
08:16:08 <Asztal> http://research.microsoft.com/en-us/um/people/simonpj/papers/boxy/ (the first one does mention runST)
08:16:43 <EvanCarroll> wtf head/tail/last/init
08:17:10 <EvanCarroll> that has got to be the absolute worst naming scheme for functions, even taking the lead from PHP
08:17:27 <Rotaerk> EvanCarroll, what's wrong with it?
08:18:11 <quicksilver> EvanCarroll: that has go to be the absolute worst trolling attempt I've seen for days ;P
08:18:21 <EvanCarroll> head retuns one element, tails returns all but one, last logically returns just one (making the exception in this group), and init returns all but the first (eh?)
08:18:24 <edwardk__> Would you rather we had car/cdr? And made up something for last/init?
08:18:55 <EvanCarroll> no, I would prefer first/last, top, bottom, or something
08:18:56 <Rotaerk> EvanCarroll, the only one that's even a little ambiguous is init, imo
08:18:58 <ksf> :t init
08:18:59 <lambdabot> forall a. [a] -> [a]
08:19:05 <ksf> > init [1..]
08:19:06 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
08:19:12 <ksf> > init [1..3]
08:19:13 <lambdabot>   [1,2]
08:19:50 <jkff> > let x=[1..5] in ((head x,tail x), (init x,last x))
08:19:51 <ksf> ...all but the last.
08:19:51 <lambdabot>   ((1,[2,3,4,5]),([1,2,3,4],5))
08:19:54 <EvanCarroll> why would you have a last without a first?
08:19:57 <Rotaerk> EvanCarroll, head and tail are common parlance
08:19:59 <jkff> > first [1..5]
08:20:00 <lambdabot>   Couldn't match expected type `a b c' against inferred type `[a1]'
08:20:03 <jkff> Hm
08:20:16 <Rotaerk> last .. is of course... the last element
08:20:18 <quicksilver> yes, head and tail are idiomatic terms that's all
08:20:20 <Rotaerk> init is a little ambiguous
08:20:32 <Rotaerk> but I can't think of anything better
08:20:32 * ksf agrees that head/neck/back/tailbone would be clearer.
08:20:43 <ClaudiusMaximus> > first last ("abc", 10)
08:20:44 <lambdabot>   ('c',10)
08:20:46 <Rotaerk> the head-bone's connected to the... tail-bone
08:20:58 <EvanCarroll> gah, head to me doesn't imply just one, any more than tail implies more than one.
08:21:20 <quicksilver> EvanCarroll: then you lack the background.
08:21:21 <Rotaerk> EvanCarroll, it's not like haskell made up that term.
08:21:27 <quicksilver> EvanCarroll: it's been used to mean exactly that for many years
08:21:35 <quicksilver> so haskell is just using the accepted term.
08:21:38 <ksf> head /= car
08:21:49 <ksf> car/cdr are primitives for binary trees, not lists.
08:22:01 <EvanCarroll> /bin/head defaults to 10
08:22:08 <lpjhjdh> is there a way to pass in just a type synonym (without arguments) where a functor is expected?
08:22:19 <jkff> http://learnyousomeerlang.com/static/img/worm.png
08:22:25 <quicksilver> lpjhjdh: where is a functor expected?
08:22:36 <jkff> EvanCarroll: A very pedagogical picture, should clarify everything!
08:22:43 <Rotaerk> jkff, lol.
08:22:54 <lpjhjdh> in a data type Fix which is my name for Mu
08:23:25 <lpjhjdh> type T = Fix (Statement expr), where type Statement expr x = stuff
08:24:13 <quicksilver> lpjhjdh: ok, you didn't mean 'functor' you meant 'type constructor' or 'type of kind * -> *'
08:24:21 <lpjhjdh> functor in the mathematic sense
08:24:27 <quicksilver> lpjhjdh: and the answer is, no, you can't use type synonyms in that way.
08:24:37 <lpjhjdh> quicksilver: damn, thanks :(
08:24:39 <quicksilver> (not everything of kind * -> * is necessarily a functor)
08:24:39 <EvanCarroll> take/drop hahahaha kind of rips off shift/pop
08:24:48 <skyhawk_> the cabal local-repo setting in the config file didnt work because the torrent didnt include a package list file
08:25:38 <edwardk_> lpjhjdh: you MAY be able to if the type synonym is just a partial application
08:25:54 <temoto> Hello. I have a matrix [[Cell]]. I need to iterate it line by line, but i need indexes not the actual values. How to write a function which would call f x y on evey cell?
08:25:54 <lambdabot> temoto: You have 1 new message. '/msg lambdabot @messages' to read it.
08:26:09 <edwardk_> lpjhjdh: type Foo a = (,) a -- can work. Foo Int :: * -> *
08:26:25 <ksf> true p2p cabal would surely rock. e.g. foo could pack up a sdist of his package bar, copy it over to somewhere, and tell people to cabal install foo:bar-0.1.2 and try it before pushing it to hackage.
08:26:40 <edwardk_> so if you can write type Statement expr = ... and not have to mention the x then you can use your Fix is fine
08:26:45 <ksf> "somewhere" being "the place where cabald expects it to be"
08:30:57 <bsod666> can someone tell me how i make an infinite list of numbers using map and recursion?
08:31:15 <medfly> ?
08:31:19 <mreh> I'm generating two separate numbers with the same random number generator, but they come back as the same number
08:31:20 <medfly> what kind of infinite list of numbers?
08:31:33 <Rotaerk> bsod666, [1..]
08:31:34 <jre2> ksf: I'm a fan
08:31:39 <Rotaerk> you don't even need map and recursion! :D
08:31:40 <bsod666> with []
08:31:49 <medfly> generate a new one mreh
08:31:52 <bsod666> without that i mean
08:31:54 <Beelsebob> bsod666: with recursion only: inf x = x : inf x
08:31:55 <mreh> what would you map it to?
08:32:24 <mreh> medfly: it's not that simple, it's something to with state monads that I don't understand
08:32:34 <bsod666> i want to apply a function say +1 to a sequence of numbers
08:32:39 <Beelsebob> @src enumFrom
08:32:39 <lambdabot> Source not found. Wrong!  You cheating scum!
08:32:42 <jkff> bsod666: map (+1) sequenceOfNumbers
08:32:53 <skyhawk_> is there a way to use the hackage torrent as a local repo with cabal-install?
08:32:54 <bsod666> i dont know the sequence of numbers
08:32:55 * Beelsebob pokes lambdabot with a stick
08:32:58 <bsod666> i want to generate them
08:33:00 <mreh> i'm trying to plot points to a gaussian distribution in 2d space, but I get a single line of points such that x = y
08:33:10 <bsod666> by starting at say 0 then using recursion
08:33:17 <jkff> iterate (+1) 0
08:33:31 <Beelsebob> bsod666: map (+1)
08:33:37 <ziman> bsod666, an list consists of a head and a tail. When defining it, you just define what the head of the list is and what the tail of the list is, usually using the list itself in the definition of the tail. Therefore you can say: ones = 1 : map id ones, where "1" is the head and "map id ones" (which is ones itself) is the tail, for example.
08:33:57 <ziman> *a list
08:34:09 <sieni> mreh: http://www.random.org/analysis/dilbert.jpg
08:34:36 <mreh> sieni: i must be the luckiest man alive, it keeps on happening!
08:36:19 <bsod666> im confused so doi need 0:map (+1)?
08:36:40 <bsod666> say i start from 0 and im creating an infinite list
08:37:05 <Cale> > let xs = 0 : map (+1) xs in xs
08:37:06 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
08:37:29 <bsod666> error
08:37:29 <edwardk_> another way to generate that is to say something like
08:37:40 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11479#a11479 -- I think the problem must be at line 161 because I'm using the same generator twice
08:37:42 <edwardk_> > let from n = n : from (n + 1) in from 0
08:37:43 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
08:37:57 <Cale> > iterate (+1) 0
08:37:59 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
08:38:38 <bsod666> iterate (+1) 0 doesnt work
08:38:44 <Cale> oh?
08:38:46 <bsod666> unless im typing it wrong
08:38:47 <medfly> it only works for Cale
08:39:05 <bsod666> the let xs=0 didnt work either
08:39:33 <medfly> are you another person which is actually using Java and somehow ended up here :p
08:39:57 <ziman> bsod666, where are you typing these pieces of code?
08:39:57 <edwardk_> bsod666: you are using a _haskell_ compiler/interpreter, aren't you? =)
08:40:07 <medfly> it was worth asking =)
08:40:09 <bsod666> lol
08:40:13 <bsod666> yeah winhugs
08:40:30 <Cale> bsod666: Okay, so at the winhugs prompt, you're typing  iterate (+1) 0  ?
08:40:31 <edwardk_> that thing is still around?
08:40:35 <mreh> is anyone looking at my more complicated problem? it has moands
08:40:40 <bsod666> yeah
08:40:40 <Cale> What does it say?
08:41:02 <bsod666> type error
08:41:26 <Cale> bsod666: What type error?
08:41:36 <bsod666> erm sorry guys
08:41:37 <ziman> hugs is quite spartan when it comes to error messages
08:41:48 <bsod666> i was working on a file eearlier
08:41:55 <bsod666> forgot to clear the  modules
08:42:06 <sshc> why is hackage down?
08:42:12 <Cale> ah, so it might have had a pre-existing definition of iterate or something
08:42:37 <Cale> sshc: We should know soon. It's 8:42 in Portland, which I believe is where the server is.
08:42:38 <mreh> sshc: server down
08:42:40 <Cale> (am)
08:42:47 <mreh> the server has VANISHED!
08:43:07 <Cale> sshc: So when someone at Galois gets in, perhaps they will let us know :)
08:43:28 <Cale> "Our entire building burnt down" or something.
08:43:40 <mreh> I've been sending signals to it all day, hence I have concluded that the server has disintegrated into thin air
08:43:46 <jre2> Cale: yes, the only acceptable answer
08:44:35 * shapr throws lambdas at edwardk_ 
08:44:51 <ksf> skyhawk_, yes, there is.
08:45:37 <ksf> edit ~/.cabal/config, set localrepo to the path, comment the global repo and its cache out, copy over the index from your old cache to the torrent.
08:45:42 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11479#a11479 <--- run this code, look at 161, and tell me what on earth is going on here
08:45:46 * edwardk dodges by changing nicks.
08:45:47 <ben_m> lala
08:45:51 <ben_m> hello]
08:45:53 <skyhawk_> ksf, I tried put the torrent content i various folders as pointed to in cabal conf to no avail
08:45:54 <ben_m> bluuP\
08:46:09 <ksf> the index is the key.
08:46:14 <Baughn> @ask #haskell Have any of you seen parse errors when using haskell-indentation.el? (Kuribas' mode)
08:46:15 <lambdabot> Consider it noted.
08:46:25 <ben_m> damn kids abusing my keyboard
08:46:27 <ksf> dunno how to create one, mauke should have included one when setting up the torrent.
08:46:29 <skyhawk_> ksf, yes, I dont have the index
08:46:32 <benmachine> @help ask
08:46:33 <lambdabot> ask <nick> <message>. When <nick> shows activity, ask them <message>.
08:46:46 <benmachine> so when #haskell shows up, they'll be asked that?
08:46:50 <Baughn> Yes
08:46:51 <Cale> mreh: Let me guess, you're somehow getting a straight line?
08:46:55 <ben_m> @ask god "Why exactly 42?"
08:46:55 <lambdabot> Consider it noted.
08:46:59 <mreh> Cale: yes!
08:47:10 <ksf> skyhawk_, you should have one in ~/.cabal/packages/hackage.haskell.org/ . use that.
08:47:10 <mreh> x = y
08:47:21 <Baughn> benmachine: The thing is, of course, that"#haskell" is an invalid nick. I was wondering if it'd catch that.
08:47:30 <benmachine> clearly not.
08:47:31 <Cale> mreh: That is because you are passing the exact same generator state to both calls to normalDist
08:47:31 <mreh> clearly these two generators are making the same "random" numbers
08:47:48 <skyhawk_> ksf, my timing is bad, I'm learning haskell and is about to start using cabal now when hackage is down and I dont have a previous index file to fall back on
08:47:54 <NEEDMOAR> Is there any language with the syntax of Haskell but untyped?
08:47:57 <ksf> arrrrr
08:48:00 <mreh> Cale: i thought that might be the case, is that because they're evaluated at the same time
08:48:01 <edwardk> When #haskell logs in, it is going to get flooded with messages
08:48:03 <mreh> like graph reduction
08:48:04 <Cale> mreh: It is like mathematics. If two things are textually equal, they will be equal.
08:48:20 <Baughn> NEEDMOAR: There are no untyped languages. Perhaps you mean dynamically typed?
08:48:26 <edwardk> NEEDMOAR: i've ben working on one, but it is tricky. you lose type classes.
08:48:33 <Baughn> NEEDMOAR: Speaking for myself, I'd really hate to have all the type errors show up at runtime
08:48:36 <Cale> mreh: Since we're talking about expressions here, and not the results of actions.
08:48:54 <dcoutts> Baughn: oh there are untyped ones, like assembler or C--
08:48:57 <skyhawk_> ksf, the torrent should include it really I suppose, maybe I can use yours index file?
08:49:07 <edwardk> Baughn: or the untyped lambda calculus =)
08:49:10 <Baughn> dcoutts: No, assembler is typed. Atleast, x86_64 assembly is.
08:49:11 <mreh> Cale: is this no place for an expression then? should I perform the random generation in an action of some kind
08:49:32 <Baughn> dcoutts: It's even statically typed - it's physically impossible to ask for an SSE operation on a general-purpose register
08:49:32 <Cale> mreh: Yeah, that's why it's all in the ST monad, so that you can sequence the generator state along.
08:49:43 <dcoutts> Baughn: very loosely, signed, unsigned, floating point, anything else, so long as the width is right
08:50:03 <Baughn> dcoutts: I didn't say they were the kinds of types we're used to
08:50:17 <edwardk> NEEDMOAR: that said, even in my 'untyped/dynamically typed/whatever phrase I need to use today to avoid the jihad' language has a type system  for a class system for code reuse.
08:50:22 <dcoutts> Baughn: fine, it's typed if we redefine types
08:50:26 <Baughn> dcoutts: Anyhow, it doesn'thave integers; it has bags-of-bits, and operations that implictly treat them as integers
08:50:29 <jre2> it just doesn't have a very interesting or useful type heigharchy
08:50:32 <shapr> edwardk, how's code?
08:50:59 <edwardk> shapr: going well actually. i need to integrate all of the fixes/ideas from the gsoc mentor summit
08:51:00 <Baughn> dcoutts: Well, I didn't claim it's a very useful or structured type hierarchy, but it's more than just /one/ type
08:51:01 <Cale> mreh: But even though ST computations might internally use mutable state, they have a guarantee: from the perspective outside of a runST, they are referentially transparent
08:51:14 <Cale> mreh: Define the same action, get the same result.
08:51:17 <dcoutts> Baughn: the untyped lambda calculus is typed too! it has one type and everything is of the same type
08:51:19 <NEEDMOAR> edwardk: is your language avaible on internet?
08:51:33 <bsod666> say i have a list and i want to find whether a number occurs only once in that list
08:51:38 <shapr> edwardk: Yeah, how's that kata thing doing? :-)
08:51:45 <Baughn> dcoutts: I think I'd have to draw the line there. You need more than one type. :P
08:51:49 <edwardk> NEEDMOAR: it will be eventually. i'll admit it risks becoming the duke nuken forever of functional programming languages ;)
08:51:49 <bsod666> occurs (x:rs) n = (x==n) || (occurs rs n)
08:51:53 <dcoutts> Baughn: heh :-)
08:52:02 <bsod666> that woild test if a number occurs
08:52:03 <mreh> non trivial programs in haskell aren't... trivial
08:52:09 <NEEDMOAR> edwardk: haha :-)
08:52:13 <ksf> skyhawk_, http://rapidshare.com/files/301439131/indices.tar.bz2.html
08:52:35 <bsod666> is there a cleaner way or an inbuilt function for checking whether a number exists a certain number of times in a list
08:52:36 <Baughn> mreh: Only because of the IO monad. Once I've figured out my commutative IO package, we'll forever be freed of the scourge of imperative programming.
08:52:39 <edwardk> NEEDMOAR: there is #kata where I usually ramble on about it ;)
08:52:45 <skyhawk_> ksf, thx
08:52:48 <ksf> ...which contains way more pacakge versions than the torrent, and possibly not the most recent ones.
08:52:51 <ksf> but it's a start.
08:52:58 <Cale> bsod666: occusOnce (x:xs) n = (x == n && not (occurs xs n)) || occursOnce xs n
08:52:59 <NEEDMOAR> edwardk: thanks.
08:53:00 <dcoutts> Baughn: right, it starts to become a much less useful thing to talk about when we get to assembler and similar languages
08:53:06 <Cale> bsod666: oh, sure
08:53:20 <Cale> bsod666: filter (== n) will pick out just the ns
08:53:26 <ksf> ...if anybody else asks, I'm going to ask him to write a shell script to generate that stuff.
08:53:33 <skyhawk_> ksf, yes, better than nothing
08:54:14 <Cale> > filter (== 'a') "abracadabra"
08:54:16 <lambdabot>   "aaaaa"
08:54:24 <Cale> > length . filter (== 'a') $ "abracadabra"
08:54:26 <lambdabot>   5
08:54:55 <bsod666> sweet
08:54:57 <mreh> Baughn: commutative? I thought IO was all about order
08:55:11 <bsod666> how can i do if statements in haskell as well?
08:55:11 <Baughn> mreh: That's what they want you to think
08:55:12 <Cale> bsod666: careful about this use of length though
08:55:18 <bsod666> how so?
08:55:30 <Baughn> > if 1 > 2 then undefined else print 42
08:55:32 <lambdabot>   <IO ()>
08:55:34 <Cale> bsod666: It'll always go through the whole list, regardless of whether you're just testing if there's more than 1 or whatever
08:55:46 <ksf> > length [1..] > 2
08:55:50 <lambdabot>   mueval-core: Time limit exceeded
08:55:51 <Cale> bsod666: You might want to go with pattern matching if you'd like to test that there's exactly one
08:55:52 <Baughn> mreh: IO has /dependencies/, but the IO monad puts more dependencies than actually exist into it
08:56:09 <ksf> > length [1..] > (2 :: Natural)
08:56:10 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
08:56:10 <lambdabot>         against inferred type ...
08:56:14 <Cale> > case filter (== 'a') "abracadabra" of [x] -> True; _ -> False
08:56:16 <lambdabot>   False
08:56:17 <ksf> > genericLength [1..] > (2 :: Natural)
08:56:18 <lambdabot>   True
08:56:20 <Baughn> mreh: ..I think I can do some interesting things with FRP. It's still just a vague idea, though.
08:56:22 <Cale> > case filter (== 'c') "abracadabra" of [x] -> True; _ -> False
08:56:24 <lambdabot>   True
08:56:39 <ksf> > 2 :: Natural
08:56:39 <benmachine> or define lenatleast n = not . null . drop (n - 1)
08:56:40 <lambdabot>   2
08:56:48 <Cale> Yeah, or you can use lazy naturals, but that involves installing a package from Hackage which is down.
08:57:13 <ksf> there's a torrent. and an opportunity to write a shell script to generate a package index.
08:57:27 <bsod666> say i run a haskell command
08:57:31 <lpjhjdh> So I guess I don't really understand splice that well, where in ghc 6.12 is it legal?  [t| Fix (Data.Set.Set String :*: $(expandTySyn ''LetExpr []) |] fails :(
08:57:39 <bsod666> how can i store the output of say length to a value
08:57:46 <bsod666> do i just put like x=length..
08:57:51 <lpjhjdh> my thinking was splice just jams the AST into the source
08:57:53 <Cale> bsod666: from where?
08:58:01 <Cale> bsod666: on the ghci commandline?
08:58:06 <ksf> let x = length [1..5] in x + 4
08:58:10 <ksf> >let x = length [1..5] in x + 4
08:58:13 <ksf> > let x = length [1..5] in x + 4
08:58:14 <Cale> oh, hugs
08:58:14 <lambdabot>   9
08:58:27 <Cale> With hugs you can't define new values at all from the interpreter
08:58:40 <Cale> You have to put definitions in a file, and it'll only accept expressions
08:58:44 <Cale> However, you can use let
08:58:48 <Cale> let x = ... in ...
08:58:55 <Cale> (the in is required in hugs)
08:59:04 <ksf> @let answer = length [1..42]
08:59:05 <lambdabot>  Defined.
08:59:10 <ksf> > answer
08:59:11 <lambdabot>   42
08:59:18 <bsod666> what i basically want to do is using the length check with it is x length if so return a bool value
08:59:54 <Cale> bsod666: Right, so the right hand side of whatever function you're defining is just a Bool expression.
09:00:29 <Cale> bsod666: If you really feel the need to define x, you might use a where clause, or a let expression
09:00:44 <Cale> But it shouldn't be necessary here
09:00:55 <bsod666> so say with your abracadabra example
09:01:24 <Cale> exactlyOne xs n = case filter (== n) xs of [x] -> True; _ -> False
09:01:25 <bsod666> how can i check if it is x long
09:01:30 <Cale> oh
09:01:50 <bsod666> return true if matches x else false
09:01:55 <Cale> exactly xs y m = length (filter (== y) xs) == m
09:02:05 <Cale> ?
09:02:07 <Cale> like that?
09:02:31 <Cale> That will be True if there are exactly m y's in xs
09:02:52 <Cale> Probably the opposite parameter order would make more sense ;)
09:03:18 <Cale> Is that what you want?
09:03:36 <seanmcl> someone mentioned earlier today that 'OverlappingInstances' is a "scary" extension.  Why is it scary?
09:03:53 <seanmcl> Seems perfectly reasonable to treat String differently from [a]
09:03:54 <mreh> Cale: my plots are round again!!!
09:04:08 <Cale> seanmcl: I guess because it makes the criteria for selecting instances a good deal more complicated.
09:04:09 <bsod666> so do i need these types
09:04:30 <bsod666> [Int]->Int->Bool?
09:04:38 <quicksilver> seanmcl: because it breaks composability of programs
09:04:43 <Taejo> seanmcl: but is (String, String) a (String, b) or (a, String)?
09:04:49 <quicksilver> seanmcl: and, to some extent, it even breaks separate compilation.
09:04:51 <bsod666> [Int]->Int->Int->Bool?
09:05:03 <bsod666> if im testing a sequence of numbers
09:05:04 <quicksilver> seanmcl: suppose you have polymorphic code dealing with [a]
09:05:13 <seanmcl> quicksilver: would you expand on composiblity
09:05:23 <quicksilver> seanmcl: that code could be called (by another module) in a way which happens to set a to Char and thus it's really a string
09:05:44 <quicksilver> in which case (if there are different instances) it would have to behave differently.
09:05:54 <quicksilver> which means the compiler would have to compile two copies of it
09:05:56 <ksf> the morale of the story: use newtypes for your instances.
09:06:02 <ziman> seanmcl, newtyping String would give you the behavior I believe you're thinking of
09:06:06 <Cale> bsod666: You never have to type the types :)
09:06:16 <Cale> bsod666: Check out what hugs infers for the type
09:06:22 <temoto> How to expand [[1,2],[3,4]] into [1,2,3,4] ?
09:06:26 <Cale> bsod666: :t exactly
09:06:32 <Cale> temoto: concat
09:06:33 <ksf> > concat [[1,2],[3,4]]
09:06:34 <lambdabot>   [1,2,3,4]
09:06:41 <temoto> Cale, ksf: thank you
09:06:47 <jkff> Oh, hi temoto
09:07:02 <ksf> > concatMap pure [[1,2],[3,4]]
09:07:03 <lambdabot>   [[1,2],[3,4]]
09:07:14 <jkff> > join [[1,2], [3,4]]
09:07:15 <lambdabot>   [1,2,3,4]
09:07:19 <ksf> > concatMap join [[1,2],[3,4]]
09:07:20 <lambdabot>   No instance for (GHC.Num.Num [b])
09:07:20 <lambdabot>    arising from the literal `1' at <inter...
09:07:29 <ksf> gragh.
09:07:31 <temoto> jkff: hello Eugene :)
09:07:53 <Cale> > concatMap id [[1,2],[3,4]]
09:07:54 <fasta> What does Cabal do when a local-repo is specified? Does it override the remote-repo always or is there more complex logic?
09:07:54 <lambdabot>   [1,2,3,4]
09:07:57 <ksf> @check \xs -> join xs == concat xs
09:07:58 <lambdabot>   "OK, passed 500 tests."
09:08:04 <jkff> > do x <- [[1,2],[3,4]]; x
09:08:05 <seanmcl> quicksilver,ksf,cale,ziman: thanks
09:08:06 <lambdabot>   [1,2,3,4]
09:08:15 <sw17ch> is hackage still explodified?
09:08:26 <bsod666> im trying to define it as a hugs function test::
09:08:27 <jkff> > [[1,2],[3,4]] >>= id
09:08:28 <lambdabot>   [1,2,3,4]
09:08:31 <fasta> @remember is hackage still explodified?
09:08:31 <lambdabot> It is forever etched in my memory.
09:08:34 <jkff> Oh well, enough ways of concatenation.
09:08:47 <sw17ch> :)
09:09:02 <ksf> sw17ch, there's a torrent.
09:09:03 <jkff> I bet Perl has more.
09:09:18 <sw17ch> ksf: yes, i did see that on -cafe
09:09:25 <sw17ch> is the server hard-down, then?
09:09:30 <sw17ch> that comma wasn't necessary...
09:09:39 <Cale> > foldr (++) [] [[1,2],[3,4]] -- can there ever really be enough?
09:09:40 <lambdabot>   [1,2,3,4]
09:09:43 <jix> is there some type for infinite lists?
09:09:52 <ksf> :t [1..]
09:09:53 <lambdabot> forall t. (Num t, Enum t) => [t]
09:09:57 <fasta> jix, streams
09:10:03 <jkff> jix: how about data IL a = IL a (IL a) ?
09:10:25 <fasta> jix, which is isomorphic to what jkff said.
09:10:43 <jkff> Yes. I was going to have a look at a stream package at hackage, but alas.
09:10:56 <jix> i'll have a look at the stream package
09:11:03 <dcoutts> fasta: local package repos mask global ones
09:11:16 <dcoutts> fasta: erm remote, not global
09:11:23 <Cale> jix: For lists guaranteed to be infinite?
09:11:36 <Cale> jix: because, the normal list type allows for infinite lists of course ;)
09:11:41 <dcoutts> fasta: apart from that it's the order in which repos are listed which determines how they mask each other
09:11:42 <ksf> dcoutts, cabal-install should come with a command to generate a package cache.
09:11:46 <jix> Cale: yeah guaranteed
09:11:58 <fasta> dcoutts: ok, so like everything that can be improved.
09:12:02 <dcoutts> ksf: patches accepted
09:12:04 <Cale> Yeah, not in the standard library
09:12:12 <jix> ... but i guess with the stream package i won't get stream fusion ^^
09:12:12 <jkff> jix: JFYI, that's a co-inductive type.
09:12:13 <Cale> However, you can easily define one for yourself
09:12:29 <Cale> data Stream a = Cons a (Stream a)
09:12:32 <dcoutts> fasta: I'm not sure what you're referring to
09:12:45 <dcoutts> fasta: seems sensible that local repos mask remote ones
09:12:53 <jix> Cale: i know... but i don't want to reimplement Data.List for my own type
09:13:06 <Cale> That is a good point
09:13:14 <Cale> Usually I just do without the compile-time guarantee
09:13:20 <fasta> dcoutts: oh, it has no further meaning or something like that. Basically, what I meant was that when the local-repo is older than a possible remote one, we could download the newer one interactively.
09:13:41 <jix> Cale: the stream package on hackage defines functions like those of Data.List...
09:13:44 <dcoutts> fasta: oh I see, well it will do that
09:13:54 <dcoutts> fasta: they only mask when they're the exact same versions
09:14:06 <fasta> dcoutts: ok, so it takes the newest one otherwise?
09:14:09 <jix> but i think that loosing stream fusion might be a problem... i want to do audio stuff so performance might get a problem
09:14:24 <dcoutts> fasta: the default behaviour of cabal is to prefer later versions
09:14:27 <fasta> dcoutts: nice
09:15:33 <jix> hmmm i could try to create a modified copy of stream-fusion for streams instead of lists
09:16:45 <temoto> In ghci, when i do   :l corners   without .hi file, it loads everything from that module, also shows "interpreted".
09:17:24 <temoto> When i do   :l corners    after ghc --make corners.hs, so there is .hi file, ghci :l corners loads only main from module, also shows "compiled".
09:17:43 <Cale> ... what is with this? People are asking me questions about Haskell in PM and then just leaving without saying anything about my reply.
09:18:07 <quicksilver> Cale: abuse, it's called :)
09:18:08 <temoto> Which command in ghci would always load everything from module? E.g. how to ignore .hi file?
09:19:21 <Cale> System.Directory.removeFile "foo.o" -- ;)
09:19:45 <quicksilver> you can ignore .o files by adding * to the module name I think
09:19:49 <quicksilver> (force interpretation)
09:19:56 <quicksilver> I don't think you can ever ignore .hi files?
09:20:01 <Cale> ah, so that's what that is :)
09:20:31 <temoto> Ignoring .hi is one of possible solutions. The aim is to always load all functions from module, not just 'main'.
09:20:34 <Cale> Surely if it ignores the .o it also ignores the .hi?
09:21:19 <Cale> I usually just delete all my .o files, but maybe next time I'll try that * trick.
09:21:37 <temoto> Yeah :l *corners works. Thanks quicksilver.
09:22:44 <int-e> temoto: maybe ghci -hidir /x (/x being some nonexistent directory)
09:25:31 <skorpan> i want to learn parsec (3).  where do i start?
09:30:01 <aavogt> skorpan: ignore the types?
09:30:21 <skorpan> my first question is what's the "run" function in parsec? :P
09:30:40 <skorpan> runParser?
09:31:00 <skorpan> damn you hackage!
09:31:12 <Kagami`> Hi. What should I use as the alternative of Data.HashTable mutable arrays. Judy? Are there any other implementations?
09:32:04 <aavogt> skorpan: or parse if you don't have any parser state
09:32:19 <skorpan> downloading hackage atm...
09:32:59 <aavogt> parsec 2 code isn't much different from parsec 3 code in my experience
09:34:22 <Beelsebob> parsec 3 has an applicative instance
09:34:28 <Beelsebob> so can be very very different
09:37:47 <ziman> do you mean the implementation and performance?
09:39:06 <ziman> (parsec2 is a moanad, thus Applicative is easy to write)
09:41:47 <benmachine> the type you often work with in parsec 3 is Parsec rather than Parser
09:46:53 <benmachine> actually I'm not sure if that's true
09:47:02 * benmachine has a type synonym for Parser String Bool a
09:48:16 <aavogt> Beelsebob: well I define an applicative instance for parsec 2, or use  (<*>) = ap; (*>) = (>>), (<*) = liftM2 const... and so on
09:51:22 <temoto> foldl (++) ""   is what?
09:51:29 <benmachine> concat
09:51:37 <benmachine> isn't it?
09:51:39 <koeien> > foldl (++) "" ["hello", ", cruel", " world"]
09:51:39 <benmachine> I think maybe
09:51:41 <lambdabot>   "hello, cruel world"
09:52:04 <koeien> :t foldl (++) ""
09:52:05 <temoto> But i've been told that concat is for something other.
09:52:06 <lambdabot> [[Char]] -> [Char]
09:52:12 <koeien> temoto: it is almost concat
09:52:21 <temoto> > concat [[1,2],[3,4]]
09:52:23 <lambdabot>   [1,2,3,4]
09:52:38 <koeien> > concat [[x] | x <- [1..]]
09:52:39 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:52:56 <koeien> > foldl (++) []    [[x] | x <- [1..]]
09:53:02 <lambdabot>   mueval: ExitFailure 1
09:53:17 <temoto> So isn't there a short common used alias for 'foldl (++) ""' ?
09:53:21 <benmachine> oh, true
09:53:22 <koeien> also, foldl (++) "" only works for lists of strings
09:53:36 <koeien> temoto: 'concat' is more general and better
09:53:50 <koeien> (or "join", but if you use that incorrectly you get more obscure error messages, because it is more general)
09:53:53 <temoto> koeien: concat works with that too?
09:54:06 <koeien> > concat ["hello, ", cruel", "world"]
09:54:09 <lambdabot>   <no location info>:
09:54:09 <lambdabot>      lexical error in string/character literal at end o...
09:54:15 <koeien> > concat ["hello", ", cruel", "world"]
09:54:17 <lambdabot>   "hello, cruelworld"
09:54:31 <stoop> :t ""
09:54:33 <lambdabot> [Char]
09:54:34 <stoop> :t []
09:54:35 <lambdabot> forall a. [a]
09:54:46 <stoop> temoto.
09:54:55 <koeien> yes, that is one difference (and the fact that it doesnot work for infinite lists is another)
09:54:59 <koeien> @src concat
09:55:00 <lambdabot> concat = foldr (++) []
09:55:09 <temoto> Aha.
09:56:49 <temoto> http://codepad.org/ZCVJlTVy  please tell, why putStrBoard prints [(),(),...] after correctly printing the field?
09:58:43 <temoto> Also i'd be glad if anyone told if that's a good implementation of makeMove.
09:59:49 <ccasin> is there an eta on the return of hackage?
10:00:10 <koeien> temoto: ah yes, i see
10:00:34 <aavogt> eta reduce!
10:00:36 <benmachine> temoto: it is related to the way ghci prints IO actions
10:00:55 <koeien> temoto: yes, if you do this noninteractively there will be no problem
10:00:59 <rupert88> can someone tell me whats wrong with name <-getline
10:01:00 <benmachine> (note that runhaskell/runghc are just ways of running a script in ghci)
10:01:06 <benmachine> rupert88: getLine?
10:01:22 <koeien> temoto: you will get the result of your IO action too. look at the type of putStrBoard board, that is IO [()]
10:01:26 <rupert88> yeah in the real program its like that
10:01:29 <koeien> temoto: so ghci will happily print the result for you
10:01:44 <koeien> temoto: which is a list of ()'s. to drop this, try mapM_ instead of mapM
10:01:50 <medfly> rupert88, I don't see a problem with it.
10:01:51 <temoto> koeien: ah, understand, thanks.
10:01:56 <rupert88> im getting syntax input error
10:02:09 <rupert88> name
10:02:16 <medfly> maybe you should show us the entire thing
10:03:13 <rupert88> test =do putStrLn "Your name"
10:03:13 <rupert88> name <- getLine
10:03:13 <rupert88> putStrLn ("Your name is: " ++ name ++ "!")
10:03:22 <temoto> koeien: what about makeMove, please?
10:04:12 <benmachine> rupert88: you need to indent it properly if you're using the layout rule
10:04:27 <rupert88> layout rule
10:04:34 <benmachine> you are using the layout rule
10:04:37 <benmachine> all the cool kids do
10:04:40 <rupert88> i just have a hs file with that in it
10:04:45 <benmachine> so indent the second and third lines a bit
10:04:54 <benmachine> it doesn't matter how much
10:05:01 <aavogt> more that just a bit
10:05:07 <benmachine> as long as they are indented by the same amount, and more than test is
10:05:20 <aavogt> if you put a newline after the do, then all 3 lines must be the same
10:05:26 <rupert88> Syntax error in input (unexpected symbol "name")
10:05:37 <benmachine> aavogt: don't do that then? :P
10:05:38 <aavogt> otherwise you have to align to to the column that has the first 'p'
10:05:59 <benmachine> oh, I didn't know that
10:06:02 <mauke> ksf: hmm?
10:06:03 <aavogt> benmachine: or does it work otherwise?
10:06:07 <benmachine> aavogt: testing now
10:06:44 <benmachine> aavogt: oh, you're right
10:06:52 <benmachine> all the statements of the do have to be at the same level
10:06:59 <benmachine> even ifthe first is on the same line as the do
10:07:04 <skorpan> what's the command to generate haddock documentation from Setup.l?hs?
10:07:16 <aavogt> runghc Setup haddock
10:07:26 <skorpan> thanks
10:07:31 <aavogt> possibly add --hyperlink-source
10:07:36 <aavogt> that's one is nice
10:07:36 <skorpan> that sounds nice
10:07:41 <aavogt> methinks it should be the default
10:07:52 <aavogt> at least if hscolour can be found
10:07:55 * benmachine usually does test =\n do foo\n    bar\n
10:08:16 <aavogt> benmachine: find that you end up surpassing 80 cols?
10:08:20 <benmachine> nah
10:08:22 * mmorrow uses ./Setup haddock --hyperlink-source --hoogle --haddock-options=--html
10:08:32 <benmachine> the reason I have it on a new line is so that if I change the name of the function
10:08:35 <benmachine> I don't have to re-indent
10:08:38 <skorpan> well aren't we just fancy!
10:08:44 <mmorrow> :)
10:08:44 <temoto> What's haddock?
10:08:47 <rupert88> erm my cursor is moving arround now rather fast
10:08:49 <aavogt> documentation
10:09:12 <skorpan> temoto: javadoc for haskell ;P
10:09:31 <benmachine> rupert88: doesn't sound like a haskell problem?
10:09:31 <aavogt> benmachine: well that your whole block has to be reindented if you move the 'do' right?
10:09:41 <benmachine> aavogt: why would I move the do?
10:09:47 <aavogt> if you add more parameters
10:09:54 <aavogt> or make a shorter or longer function name
10:10:12 <benmachine> but
10:10:16 <benmachine> the do is on the next line
10:10:18 <benmachine> so it doesn't care
10:10:20 <aavogt> ah
10:10:25 <rupert88> weird but it works now
10:10:26 <aavogt> that wastes space ;)
10:10:29 <mladens> hi guys, is there any info on when will hackage be online again?
10:10:34 <rupert88> hugs must have screwed up
10:10:40 <benmachine> depends on your definition of waste
10:10:51 * aavogt doesn't like wasting two columns with the 'do'
10:11:02 <benmachine> if the function is big enough it's not noticeable; if it's small then don't use do notation :P
10:11:05 <aavogt> instead it belongs on the previous line
10:11:07 <benmachine> oh you mean
10:11:16 <benmachine> hmm that's a point
10:11:28 <rupert88> i know its a bit of a gimmick but is there any way to display pictures in haskell terminal
10:11:29 <benmachine> but I quite like having space there
10:11:34 <rupert88> i mean other than ascii one
10:11:50 <benmachine> terminals are not good at displaying pictures
10:12:00 <temoto> rupert88: terminal is ascii thing.
10:12:04 <benmachine> you can display pictures with haskell, but you need something more interesting than a terminal
10:12:14 <benmachine> like SDL or gtk or whatever
10:12:17 <aavogt> rupert88: there's modes to substitute characters like \ and -> for the real symbols in emacs, vim or yi
10:12:18 <temoto> rupert88: do you mean framebuffer? That's not a terminal.
10:12:39 <aavogt> (but those aren't pictures)
10:12:57 <rupert88> just like show a jpeg or something
10:12:59 <rupert88> lol
10:13:17 <temoto> rupert88: that's not possible in terminal.
10:13:32 <rupert88> when i say terminal i mean the hugs command line
10:13:49 <benmachine> same thing applies
10:13:52 <temoto> Which is run inside a terminal.
10:13:52 <benmachine> you need to use a library
10:13:54 <mmorrow> rupert88: use an image viewing program
10:14:10 <rupert88> is it easy to integrate haskell with other languages
10:14:22 <rupert88> say if i want haskell for its number sorting abilities etc
10:14:27 <benmachine> it is fairly easy to integrate it with C
10:14:28 <benmachine> although
10:14:29 <luite> rupert88: depends on what the other language is
10:14:31 <benmachine> easy is a relative term
10:14:51 <rupert88> java / C / C#
10:14:57 <benmachine> integrating it with other languages would probably mean
10:15:02 <mmorrow> luite: cool re: sumQ
10:15:21 <benmachine> integrating both with C and then writing some C to bridge the gap
10:15:32 <mmorrow> luite: you can prettyprint the TH code if you like
10:15:41 <sm> @seen hackagebot
10:15:41 <lambdabot> Unknown command, try @list
10:15:45 <mmorrow> luite: i use the `ppDoc' function from haskell-src-meta
10:16:01 <rupert88> just wondering
10:16:05 <benmachine> preflex: seen hackagebot
10:16:06 <luite> mmorrow: ah, I'll try it when hackage is back
10:16:06 <preflex>  hackagebot was last seen on #haskell 1 day, 14 hours, 56 minutes and 47 seconds ago, saying: * hackagebot upload: bamboo-launcher 2009.11.1 - bamboo-launcher (JinjingWang)
10:16:16 <sm> thanks
10:16:17 <rupert88> i have seen quite a few cases where some numbers have been sorted with haskell then with c
10:16:24 <skorpan> "No instance for (Applicative (GenParser Char Int))"... que?
10:16:24 <rupert88> and haskell seems to be more concise
10:16:41 <benmachine> skorpan: parsec2 doesn't come with an applicative instance
10:16:43 <rupert88> just wondering if an application would benefit from it
10:16:47 <benmachine> you can make yourself one if you like?
10:16:52 <skorpan> benmachine: i'm using parsec 3 :| (x-files theme playing...)
10:17:03 <mmorrow> luite: although i'm not sure how you're using sumQ, ppDoc only works for prettyprinting e.g. and ExpQ or a Q [Dec]
10:17:11 <sm> oh, trouble at hackage eh
10:17:13 <benmachine> skorpan: pretty sure GenParser isn't in parsec3
10:17:18 <benmachine> are you importing Text.Parsec?
10:17:21 <skorpan> uhm, yeah, i'm using 2...
10:17:27 <mmorrow> luite: as opposed to    "....code .... $(sumQ 42) ... code ... "
10:17:31 <skorpan> NEVER MIND! =)
10:17:38 * benmachine never minds
10:18:04 <skorpan> well i guess that sucks because now i have parsec 2 but the docs for 3
10:18:14 <luite> mmorrow: I only use it to splice some code using $(..), but I have used pretty printing for debugging
10:18:34 <mmorrow> luite: ah nice
10:18:35 <benmachine> skorpan: how are you importing/using it?
10:18:46 <skorpan> benmachine: import Text.ParserCombinators.Parsec
10:18:58 <benmachine> skorpan: I think parsec3 has moved to Text.Parsec
10:18:59 <aavogt> you can't import Text.Parsec?
10:19:08 <skorpan> but i'm not using parsec 3 :(
10:19:22 <benmachine> okay now I'm confused
10:19:27 <skorpan> 19:17 <skorpan> uhm, yeah, i'm using 2...
10:19:30 <benmachine> yes
10:19:39 <benmachine> but I thought that was unintentional :P
10:19:53 <benmachine> because you thought you were using parsec3 originally
10:20:03 <aavogt> aren't there parsec docs outside of hackage?
10:20:04 <skorpan> you are correct
10:20:12 <luite> mmorrow: one thing though, if I use $(sumQ ..) I need the RelaxedPolyRec extension to make it compile, when I replace the TH expression by its output the code compiles fine without. do you know why?
10:20:13 <benmachine> so, what do you want to use
10:20:19 <skorpan> benmachine: i want to use 3
10:20:22 <benmachine> right
10:20:30 <benmachine> so import Text.Parsec?
10:20:45 <skorpan> well, that fails, because i don't have parsec 3 :)
10:20:49 <benmachine> ah
10:20:50 <skorpan> Could not find module `Text.Parsec':
10:20:52 <benmachine> but you have the docs
10:20:56 <skorpan> indeed!
10:21:04 <benmachine> right
10:21:04 <rupert88> how can i pause after a putstrln
10:21:07 <benmachine> I see
10:21:13 <benmachine> rupert88: how long for
10:21:16 <aavogt> is there some way to query ghc-pkg which package owns which module?
10:21:18 <rupert88> and wait for user to press key to continue
10:21:24 <skorpan> rupert88: you don't pause, you just read from stdin :)
10:21:25 <benmachine> aavogt: yes but I can't remember how
10:21:28 <aavogt> in particular, I have this Text.Parse
10:21:43 <skorpan> rupert88: readLine i think
10:21:46 <skorpan> :t readLine
10:21:47 <lambdabot> Not in scope: `readLine'
10:21:49 <benmachine> ghc-pkg --help
10:21:50 <skorpan> :t readLn
10:21:51 <lambdabot> forall a. (Read a) => IO a
10:21:55 <skorpan> okay, that's not it
10:21:57 <skorpan> :t getLine
10:21:57 <aavogt> benmachine: thanks, I'll take a closer look
10:21:58 <lambdabot> IO String
10:22:09 <skorpan> rupert88: getLine! :)
10:22:22 <benmachine> aavogt: find-module is probably what you want
10:22:24 <aavogt> ah, ghc-pkg find-module
10:22:28 <aavogt> yeah :)
10:22:34 <skorpan> aavogt: i think you want find-module
10:22:38 <skorpan> oops har har
10:22:41 <skorpan> ;-) ;-) ;-) ;-)
10:23:23 <EvanCarroll> anyone have a list of all of the core functions in haskell?
10:23:40 <aavogt> EvanCarroll: what's your definition of core?
10:23:43 <aavogt> Prelude
10:23:44 <aavogt> base?
10:23:52 <edwardk> EvanCarroll: you can find the Prelude in the Haskell 98 report
10:23:54 <aavogt> you can get a list from haddock
10:24:15 <aavogt> when it produces an index
10:24:27 <benmachine> or you can start a ghci prompt and press tab twice :P
10:24:32 <edwardk> but practically, we as a community tend to take a much larger set of functions as primitive/core.
10:24:34 <benmachine> er, once
10:24:59 <benmachine> you might get everything twice but that is just how we roll
10:25:02 <Apocalisp> Yea, whatever you do, don't press it twice
10:25:44 <Baughn> EvanCarroll: But seriously, how do you define "core"?
10:25:46 <rupert88> how does haskell deal with input types
10:25:50 <benmachine> huh, ghci -XNoImplicitPrelude doesn't do what I'd expect
10:25:54 <rupert88> i mean say i enter[2,3,4,5]
10:25:57 <EvanCarroll> Baughn: keywords
10:26:02 <Baughn> EvanCarroll: It used to be just "whatever GHC ships with". Nowadays.. it's more like "what's in the haskell platform standard"
10:26:04 <rupert88> will it be treated as a list by getLinw
10:26:07 <rupert88> getLine
10:26:13 <Baughn> EvanCarroll: Oh. Um.. that's...
10:26:14 <aavogt> rupert88: you input String or some binary data
10:26:16 <dschoepe> rupert88: getLine always returns a IO String
10:26:26 <dschoepe> read can convert it to a list
10:26:26 <benmachine> getLine *is* an IO String :p
10:26:31 <aavogt> @type readLine
10:26:33 <lambdabot> Not in scope: `readLine'
10:26:38 <aavogt> @type readLn
10:26:38 <benmachine> :t readLn
10:26:39 <lambdabot> forall a. (Read a) => IO a
10:26:40 <lambdabot> forall a. (Read a) => IO a
10:26:40 <EvanCarroll> Baughn: http://learnyouahaskell.com/starting-out
10:26:42 <EvanCarroll> anything in red.
10:26:59 <EvanCarroll> fst/snd/repeat/cycle etc.
10:27:01 <rupert88> so if i want to get a list from user is binary what i want?
10:27:01 <Baughn> EvanCarroll: if, then, else (for some reason), let, in, do, case, of, where, module, deriving, data, type, newtype, class, instance, <-, ->, \
10:27:15 <mauke> EvanCarroll: none of those are keywords
10:27:18 <skorpan> for some reason?
10:27:31 <aavogt> rupert88: so if you use readLn, the input string will be converted to the one you use it as, if possible
10:27:57 <benmachine> EvanCarroll: nor are any of them red?
10:28:00 <benmachine> ohh
10:28:02 <benmachine> those
10:28:06 <Baughn> EvanCarroll: "Keywords" means basically "words that are explicitly mentioned in the Haskell'98 syntax"
10:28:07 <benmachine> yeah, they're just functions
10:28:11 <aavogt> so if you have   main = do { x <- readLn; print (x+1) }
10:28:19 <Baughn> EvanCarroll: That's not very much. The ones you're thinking of are just functions.
10:28:20 <mmorrow> luite: hmm, weird
10:28:22 <aavogt> rupert88: then you will get 2 if you type 1
10:28:39 <rupert88> readLn gives 2 if you type 1?
10:28:41 <aavogt> and return
10:28:46 <Baughn> main = print =<< fmap succ readLn
10:28:56 <benmachine> print <*> (+1) <$> readLn
10:29:00 <benmachine> wait no
10:29:01 <benmachine> gmm
10:29:02 <Baughn> rupert88: No, but (x + 1) does
10:29:02 <benmachine> hmm
10:29:04 <aavogt> rupert88: if you use the code I last pasted
10:29:11 <mmorrow> luite: is sumQ even using polymorphic recursion?
10:29:18 <rupert88> ok
10:29:20 <aavogt> or any of the variations that Baughn or benmachine pasted
10:29:28 <aavogt> (which are supposed to do the same thing
10:29:31 <rupert88> im getting type error in function binding
10:29:36 <Baughn> Mine wouldn't actually work, though. Too much polymorphism.
10:29:41 <aavogt> , well other than benmachine's error)
10:29:43 <lunabot>  luna: parse error on input `)'
10:29:56 <benmachine> mine doesn't work anyway
10:30:01 <benmachine> at all
10:30:18 <aavogt> pint . (+1) =<< readLn
10:30:29 <benmachine> yeah that's what I meant to do
10:30:30 <benmachine> ish
10:30:33 <zygospasm> Baughn: you forgot 'default', as i always do ;-)
10:30:38 <benmachine> (heh, pint)
10:30:44 <benmachine> default can diaf
10:30:45 <aavogt> yeah, one too many ;)
10:30:53 <Baughn> zygospasm: I don't think there's defaulting on Enum
10:30:56 * benmachine thinks there should be an extension to turn off defaulting
10:31:16 <zygospasm> Baughn: in your list of keywords
10:31:18 <Baughn> zygospasm: ..not even in ghci, so definitely not in ghc
10:31:18 <aavogt> I think default declarations are per module
10:31:21 <Baughn> Oh
10:31:33 <aavogt> so maybe there's some way to say default nothing
10:31:36 <luite> mmorrow: I use $(sumQ p q) f g   in a function that is used both as  UArr Double -> Double and UArr D -> D  (where D is my own dual number type for automatic differentiation, actually a strict pair wrapped in a newtype), both f and g depend on the input
10:31:38 <Baughn> zygospasm: Um. What does that do? I don't think I've ever seen it.
10:31:52 <zygospasm> Baughn: it overrides the defaulting order
10:31:59 <aavogt> benmachine: there's also -Werror which tells you whenever stuff defaults
10:32:01 <zygospasm> i've used it precisely once i think
10:32:05 <Baughn> zygospasm: And now I don't /want/ to see it
10:32:14 <luite> mmorrow: I don't think it does, but I don't have much experience with these things :)
10:32:19 <benmachine> aavogt: does it?
10:32:24 <aavogt> and by tell, I mean fail to compile
10:32:27 <benmachine> heh
10:33:03 <aavogt> it's pretty pointless because it results in defaulting of  the second argument of ^ to integer
10:33:34 <mmorrow> luite: ah, hmm. i'm not sure, the best i can figure is that somehow the type checking/whatever needed for sumQ in combo with those particular f and g requires polymorphic recursion somehow, but i'm not sure exactly how/why
10:34:22 <mmorrow> *"needed" during the splicing stage
10:38:36 <luite> mmorrow: I'll upload the code when it's done, I can give you a link if you're interested (I can't upload the whole program at the moment, because I use some newton raphson code (in C, called through FFI) from numerical recipes)
10:38:40 <jfhall> what are the conventions for module naming when extending an already existing module, like making some new Data.List functions
10:39:02 <mmorrow> luite: cool, i'd like to see that for sure
10:40:36 <mmorrow> luite: re: numerical code and TH, i've got some fft-generating code (uses TH, then prettyprints) i've been experimenting with that you might find interesting http://moonpatio.com/repos/hsfft_vec/
10:40:49 <mmorrow> http://moonpatio.com/repos/hsfft_vec/GenFFTVec.hs  is the generator
10:41:08 <mmorrow> http://moonpatio.com/repos/hsfft_vec/FFTVec64.hs is the generated ppring dump
10:41:23 <mmorrow> and this is the "Vec" type it's using http://moonpatio.com/repos/hsfft_vec/Vec.hs
10:41:34 <mmorrow> s/ppring/pprint/
10:42:19 <mmorrow> i find it neat how you can see the structure of the fft in the fully unrolled code
10:42:51 <mmorrow> (if you make the text reaaaallllly small, that is ;)
10:44:21 <infrared> hackage was one machine?
10:44:26 <infrared> is*
10:45:24 <mmorrow> infrared: yup
10:45:47 <skorpan> how do you pass the state around in parsec 2?
10:46:12 <mmorrow> skorpan: iirc parsec2 has getState, setState or some such
10:46:19 <skorpan> ah, yes, thanks
10:47:19 <skorpan> so what do the emacs guys think of the new indentation module in haskell-mode?  it's not as nice as i had hoped.
10:48:01 <infrared> why aren't there any hackage mirrors? no donations?
10:48:06 <Apocalisp> Wow, here's something satisfying. When Church-encoding a singly-linked list, the empty list is (return . return), and cons is (.).(.)
10:48:15 <skorpan> infrared: there's a hackage torrent
10:50:15 <luite> mmorrow: hehe :) thanks, looks interesting (though I can't make the text small enough in my browser)
10:50:34 <mmorrow> heh
10:52:11 <PeakerWork> skorpan: its unpredictable to me, but nicer than what I had
10:52:17 <PeakerWork> skorpan: I have barely used it yet though
10:52:32 <luite> mmorrow: what is this instr_histo program?
10:52:45 <skorpan> i love some parts of its indentation but other parts not so much
10:53:53 <mmorrow> luite: oh, it's an alex/happy asm (att) parser, and some misc code dealing with the resulting AST. i should package it.
10:54:10 <aavogt> infrared: people have offered to set up mirrors but there isn't any code in hackage to handle distributing state to mirrors yet
10:54:10 <mmorrow> prettyprinter too
10:54:55 <mmorrow> luite: the instr_histo being a misc "main = do..." util that uses that code
10:56:14 <infrared> aavogt: NFS or crontab'd rsync for quick fixes?
10:56:24 <infrared> *shrug*
10:56:36 <mmorrow> luite: yeah, it's amazing at how much better the asm is using Vec rather than list (not surprising though)
10:56:55 <aavogt> infrared: there's some dynamic component
10:57:01 <aavogt> I dunno about the details
10:57:08 <infrared> ok. :)
10:57:19 <mmorrow> 5435 indirect jumps vs. 37
10:57:53 <mmorrow> and a ton of less shuffling of stuff around
10:59:13 <luite> yes huge difference :)
10:59:38 <sw17ch> It is tremendously difficult to prevent a presentation which references Haskell in some capacity but is about a different topic from devolving into a discussion of Haskell.
11:00:02 <sw17ch> i've attempted to give this talk twice, and both times the original topic is tossed out the window, and every one wants to hear about haskell
11:00:45 <absentia> what about haskell?
11:00:56 <sw17ch> hmm?
11:01:07 <aavogt> sw17ch: what's the related topic?
11:01:08 <skorpan> haskell sucks
11:01:14 <luite> sw17ch: perhaps make your original topic more interesting, or choose a less interesting language for illustration ;)
11:01:18 <sw17ch> aavogt, LwDSL/EDSLs
11:01:37 <PeakerWork> skorpan: relatively to the ideal programming environment, all known languages suck, of course :)
11:02:03 <sw17ch> luite, this time, i'm actually putting Haskell in the title of the talk, and making a case for its use
11:02:18 <sw17ch> but the primary goal is to convince an audience of people who have not been using EDSLs to begin considering them
11:02:25 <dons> we'll have a mirroring system for hackage -- just as soon as the hackage servers are back up and stable.
11:02:32 <skorpan> i'm going to write an english -> arm compiler, who's up for a challenge?
11:03:19 <sw17ch> skorpan, i'd be happy with a Haskell -> arm compiler
11:03:38 <absentia> I think I've seen haskell -> arm
11:04:08 <sw17ch> absentia, actually, waht i really want is Haskell -> bare-metal-arm
11:04:13 <absentia> wht'as LwDSL/EDSL?
11:04:25 <lollan> hi
11:04:32 <absentia> I thought I saw some haskell for the iPHone.. but I haven't tried it yet.
11:04:38 <lollan> I want to inst
11:04:40 <lollan> sorry
11:04:46 <absentia> someone on here was working for a company that made it.
11:04:47 <luite> sw17ch: hm, I can imagine people being interested in haskell itself after you show them how easy it is to make EDSL's.
11:04:48 <sw17ch> absentia, Embedded Domain Specific Language or Lightweight Domain Specific Language
11:04:52 <lollan> does anybody here has ubuntu and installed haskell on it ?
11:05:07 <skorpan> haskell is not compatible with ubuntu
11:05:12 <luite> hehe
11:05:13 <skorpan> you have to get slackware or freebsd
11:05:18 <lollan> skorpan: lol
11:05:19 <sw17ch> luite, i expect it entirely
11:05:24 <luite> ubuntu currently has the latest ghc
11:05:27 <lollan> nope seriously
11:05:30 <sw17ch> luite, i have 45 minutes and i'm targeting a talk of 30 min to leave 15 for questions
11:05:44 <zygospasm> lollan: i do
11:05:51 <sw17ch> lollan, usually i install the binary package and build the platform myself
11:05:56 <lament> just remember to ask, "What are your questions", as opposed to "Do you have any questions"
11:06:04 <PeakerWork> In Ubuntu, just download the binaries
11:06:10 <sw17ch> lament, good point
11:06:27 <lollan> zygospasm: what package did you install ?
11:06:40 <lollan> sw17ch: I'll do that when I get some level with haskell
11:06:42 <lollan> ^^
11:06:43 <sw17ch> lollan, oh right... there are a ton of dependencies on C-libs aren't there
11:06:48 <sinelaw> preflex, seen mbot
11:06:49 <preflex>  Sorry, I haven't seen mbot
11:06:50 <absentia> I have haskell for snow leopard
11:06:52 <absentia> and it's not compatible
11:06:56 <lollan> sw17ch: ^^
11:07:07 <crash[`]> I know it's silly to ask this here of all places, but considering the intellectual quality around these parts I felt it appropriate :P Can someone give a real argument in favor of dynamic typing as opposed to static typing + inference?
11:07:14 <absentia> (unless something changed last week while IW as on vacation)
11:07:38 <absentia> inference at compile time?
11:08:11 <luite> sw17ch: but at least you get questions about things the people are actually interested in, not just questions vaguely related to the subject, by people who feel they have to have a question and pick one that would not show if they haven't understood the talk at all :p
11:08:24 <crash[`]> i suppose
11:09:05 <zygospasm> lollan: ghc6 libghc6-*-dev
11:10:26 <mmorrow> @remember lament just remember to ask, "What are your questions", as opposed to "Do you have any questions"
11:10:27 <lambdabot> It is forever etched in my memory.
11:10:33 <lament> crash[`]: type system not expressive enough to describe some relationship
11:10:59 <PeakerWork> Functor can only be implemented in exactly 0 or 1 ways (semantic meaning, not implementation method) for any given type, abiding by the rules, right?
11:11:17 <lament> crash[`]: I can't think of any specific cases, but Helium (Haskell without type classes) is a good example of an overly restrictive type system
11:11:25 <edwardk> mmorrow: but doesn't that presuppose that they have some?
11:11:36 <zygospasm> PeakerWork: if your stance is 'tough on bottoms, tough on laws applied to bottoms' then yes, i believe so
11:12:02 <zygospasm> helium has some type classes, but only built-in ones
11:12:13 <zygospasm> and even those you can turn off
11:12:13 <Guest4645> any "dynamic" type system that isn't outright untyped (like forth) can be represented as some kind of degenerate static unityped system
11:12:15 <lollan> thanks zygospasm
11:12:19 <PeakerWork> zygospasm: are there more classes like Functor that can only be implemented in 1 way?
11:12:39 <Guest4645> and what happened to my nick
11:12:45 <zygospasm> PeakerWork: ContravariantFunctor? :)
11:12:49 <PeakerWork> zygospasm: :-)
11:12:51 <PeakerWork> zygospasm: what else?
11:13:16 <aavogt> does covariant and contravariant have any meaning in haskell?
11:13:26 <lament> crash[`]: i guess, for example, the use of + in Haskell in restricted to Num, so you can't use it for string concatenation for example
11:13:53 <lament> crash[`]: with dynamic typing of course this is not an issue
11:14:08 <edwardk> aavogt: sure it does. not in the c# 4.0 sense, but it is a meaningful concept.
11:14:09 <crash[`]> lament: alright thank you. the more I've worked with F#/type inference in C#/haskell/etc, the more I question the merit of dynamic typing
11:14:10 <zygospasm> aavogt: yes; there are still subtyping relationships. every value in type 'forall a. a' is a value in type 'X' and every value in type 'X' is a value in type 'exists a. a'
11:14:22 <sproingie> haskell's lack of ad-hoc overloading isn't really related to static vs dynamic typing
11:14:31 <mmorrow> edwardk: exactly!
11:15:14 <lament> crash[`]: in C#, I had problems when there were two different, unrelated classes, each with a method Children with the same type signature, and an object that could belong to either class that I wanted to call Children on
11:15:33 <zygospasm> aavogt: there's more structure than that when type constructors come into play
11:15:44 <lament> crash[`]: since I didn't have access to the source code for the classes, I had to write a very ugly if statement where all I needed was one dynamic call
11:15:51 <edwardk> crash[`]: sok, once you get used to higher order types and parametric polymorphism, you'll come to hate working in weaker-but-still-strongly typed languages and come to see having some global object type to upcast to and more hackishly downcast from as a crutch ;)
11:16:02 <lament> crash[`]: needless to say, the classes are from Microsoft... :\
11:16:26 <edwardk> lament: playing with buttons or images?
11:16:26 <lament> (the classes SHOULD have implemented a common interface, they just didn't, because Microsoft is not very good with APIs)
11:16:33 <lament> edwardk: something like that.
11:16:40 <zygospasm> PeakerWork: well, you can presumably apply laws to all sorts of typeclasses to make the instances unique. fmap is only unique because we require fmap id = id
11:17:12 <aavogt> zygospasm, edwardk: I'm wondering since I know haskell reasonably well, but I'm not well versed with OO inheritance things
11:17:28 <lament> edwardk: i think one was Canvas and the other was Panel, or something like that. Both are UIElements and both can contain children, but Microsoft somehow didn't see the similarity
11:17:44 <edwardk> lament: alas, until they come up with some notion of an 'extension interface' to complement 'extension methods' their choice of nominal subtyping will require you to use that sort of stupidcast or reflection based dodge.
11:17:59 <lament> edwardk: they seem to encourage it, given things like "final"
11:18:08 <edwardk> yeah
11:18:14 <lament> really, why is "final" even in the language? It is only there to piss people off
11:18:18 <edwardk> heh
11:18:23 <zygospasm> aavogt: well, as normal, the LHS of an -> is contravariant and the RHS is covariant.
11:18:43 <edwardk> mostly because due to reflection they leave so many things open that they have no real optimization opportunities in the compiler without it
11:19:20 <lament> this justification doesn't help much when you're forced to make a complete wrapper class instead of a simple subclass
11:19:28 <aavogt> zygospasm: and that's all there is to that concept?
11:19:33 <lament> i've seen that in microsoft's own code
11:19:46 <lament> so at least they suffer too
11:19:56 <zygospasm> aavogt: every function of type "forall a. [a] -> Int" is also of type "forall a. [Bool] -> Int" because every value of type [Bool] is also of type "exists a. [a]"
11:20:08 <zygospasm> aavogt: note that forall turns into exists in a contravariant position.
11:20:57 <mmorrow> does exists turn into forall in a contravariant position as well?
11:21:22 <Philippa> yep, they're dual
11:21:37 <tommd> oooOhhh, hackage up!
11:21:44 <tommd> You probably already heard though.
11:21:49 <mmorrow> Philippa: is the dual^2 iso the id?
11:21:53 <mmorrow> s/the/to/
11:23:26 * mmorrow tries to come up with an example type sig to decide
11:25:13 <mmorrow> @djinn Not(Not(Not a)) -> Not a
11:25:13 <lambdabot> f a b = void (a (\ c -> c b))
11:25:18 <mmorrow> @djinn Not a -> Not(Not(Not a))
11:25:18 <lambdabot> f a b = void (b a)
11:25:27 <mmorrow> @djinn Not(Not a) -> a
11:25:27 <lambdabot> -- f cannot be realized.
11:25:31 <mmorrow> @djinn a -> Not(Not a)
11:25:31 <lambdabot> f a b = b a
11:25:45 <mmorrow> maybe dual^3 == dual
11:26:15 <mmorrow> i'm still struggling to come up with a type sig example though
11:27:23 <aavogt> zygospasm: makes sense
11:27:25 <aavogt> thanks
11:27:27 <aavogt> !
11:27:53 <AMDO> try this
11:27:54 <AMDO> http://sites.google.com/site/gpspath/
11:28:07 <mmorrow> AMDO: ok!!
11:28:20 <AMDO> hi am I alone here?
11:28:30 <mmorrow> AMDO: ok!!
11:28:42 <skorpan> AMDO: am i allowed to click the ads?
11:28:48 <AMDO> sure
11:30:15 <Baughn> Hackage is back up
11:30:17 <skorpan> i have this: ruleName = oneOf $ ".#" ++ ['a'..'z'] ++ ['A'..'Z']
11:30:24 <skorpan> will it be optimized when compiling?
11:30:42 <skorpan> i.e. will it be ".#abcdef..."?
11:30:47 <Baughn> Most likely.
11:31:07 <Baughn> ..hm, but I don't actually /know/. Huh. Let's see.
11:31:17 <Vanadium> How do we find out?
11:31:23 <AMDO> http://sites.google.com/site/gpspath/
11:31:38 <Baughn> Vanadium: -ddump-core, or some such
11:32:15 <AMDO> hi guys i need a feedback
11:32:16 <AMDO> http://sites.google.com/site/gpspath/
11:32:21 <AMDO> pls
11:32:30 <AMDO> http://sites.google.com/site/gpspath/
11:32:31 <AMDO> http://sites.google.com/site/gpspath/
11:32:32 <AMDO> http://sites.google.com/site/gpspath/
11:32:32 <AMDO> http://sites.google.com/site/gpspath/
11:32:33 <AMDO> http://sites.google.com/site/gpspath/
11:32:34 <AMDO> http://sites.google.com/site/gpspath/
11:32:34 <AMDO> http://sites.google.com/site/gpspath/
11:32:35 <AMDO> http://sites.google.com/site/gpspath/
11:32:37 <AMDO> http://sites.google.com/site/gpspath/
11:32:39 <AMDO> http://sites.google.com/site/gpspath/
11:32:41 <AMDO> http://sites.google.com/site/gpspath/
11:32:51 <Baughn> @ops
11:32:52 <lambdabot> Maybe you meant: docs oeis pl
11:33:01 <Baughn> ..no, that's not it.
11:33:02 <Baughn> @list
11:33:03 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:33:16 <lament> AMDO: do you need a feedback on each of those sites in turn?
11:33:19 <Baughn> @fact ops
11:33:20 <lambdabot> I know nothing about ops
11:33:31 <scott____> hello
11:33:51 <GNU\colossus> hi all
11:33:51 <PeakerWork> AMDO: do you know if people repeatedly click your ads, google cancels your ad account
11:33:51 <Baughn> @where ops
11:33:52 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
11:33:52 <scott____> can someone maybe help me with some haskell work? I'm kinda dumb at this sorta thing
11:33:59 <Baughn> Ah. There we go.
11:34:03 <AMDO> really?
11:34:03 --- mode: ChanServ set +o dcoutts
11:34:06 --- mode: ChanServ set +o mauke
11:34:06 --- mode: mauke set +b *!*@87.69.54.117.cable.012.net.il
11:34:16 <Baughn> Thanks! :)
11:34:18 <GNU\colossus> my question might seem a little dumb, but I'd be happy if someone answered, anyway: how can I convert a (potentially) fractional number to Integer?
11:34:31 --- mode: ChanServ set -o dcoutts
11:34:37 <Baughn> @src Fractional
11:34:37 <lambdabot> class  (Num a) => Fractional a  where
11:34:37 <lambdabot>     (/)             :: a -> a -> a
11:34:37 <lambdabot>     recip           :: a -> a
11:34:37 <lambdabot>     fromRational    :: Rational -> a
11:34:41 <mauke> GNU\colossus: round it?
11:34:43 <luite> :t round
11:34:45 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
11:34:56 <azumanga> What's the best way of storing a string as I'm generating it? I imagine lots of concatination calls would be O(n^2) for a large string? Or does standard string use a rope implementation with O(1) joining?
11:35:06 --- mode: mauke set -o mauke
11:35:10 <mauke> azumanga: standard string is a singly linked list of characters
11:35:14 <shapr> yay, bannage
11:35:24 <scott____> How would I keep track of how many counts of a certain Int there is in a list using recursion?
11:35:28 <scott____> my code so far is
11:35:29 <Baughn> skorpan: So, getting back to our regularly scheduled core dumps...
11:35:30 <scott____> http://pastebin.com/m6b819f6
11:35:40 <scott____> but I dunno what to return for n == xs =
11:35:40 <PeakerWork> azumanga: you can use ShowS representation (String -> String) which allows for O(1) appending
11:35:59 <mauke> available on hackage (hah) as DList
11:36:03 <scott____> sorry, n == x =
11:36:06 <luite> GNU\colossus: or truncate perhaps
11:36:29 <lispy> BTW, I'm no longer an op
11:36:33 <mauke> scott____: elemNum n (x : xs) = (if n == x then 1 else 0) + elemNum n xs
11:36:38 <skorpan> Baughn: what's up? :)
11:36:39 <Baughn> skorpan: GHC collapses ++ chains at -O1 and up
11:36:40 <PeakerWork> when did Hackage come back?
11:36:48 <lispy> So maybe @where ops should be modified...
11:36:55 <mauke> lispy: so modify it :-)
11:36:57 <Baughn> skorpan: In the simplifier pass
11:37:00 <PeakerWork> Baughn: They have a special ++ rule or is it just a rewrite rule/compile-time inlining?
11:37:01 <GNU\colossus> luite: mauke: I'm trying "floor(sqrt(my_number))"
11:37:02 <scott____> alright
11:37:02 <scott____> thanks!
11:37:06 <GNU\colossus> hugs barfs at that though
11:37:06 <skorpan> Baughn: thanks!
11:37:14 <mauke> GNU\colossus: what's the type of my_number?
11:37:32 <Baughn> PeakerWork: I'm not sure, but -ddump-rules shows nothing
11:37:34 <GNU\colossus> mauke: Integer
11:37:36 <lispy> ?where ops shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
11:37:37 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
11:37:39 <Baughn> skorpan: -ddump-simpl is fairly.. simple to read
11:37:40 <luite> GNU\colossus: haskell will not automatically 'promote' Int to Double like some other languages do
11:37:43 <PeakerWork> Baughn: I really hope they did it the right way :)
11:37:45 <lispy> ?help where
11:37:46 <lambdabot> where <key>. Return element associated with key
11:37:57 <shapr> lispy: eh?
11:38:01 <lispy> mauke: no idea how to change it
11:38:04 <mauke> GNU\colossus: floor (sqrt (fromInteger my_number))
11:38:06 <zygospasm> GNU\colossus: in what context is this? are you testing for primality / factorizing?
11:38:20 <GNU\colossus> zygospasm: exactly
11:38:28 <mauke> @where+ ops shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
11:38:29 <lambdabot> Okay.
11:38:38 <lispy> mauke:  thanks!
11:38:39 <mauke> @slush
11:38:39 <lambdabot> Not enough privileges
11:38:48 <zygospasm> @flesh
11:38:48 <lambdabot> Not enough privileges
11:38:58 <GNU\colossus> mauke: that worked; thanks a bunch
11:39:06 <Baughn> @mush
11:39:07 <lambdabot> Maybe you meant: flush msg
11:39:11 <mauke> @slush
11:39:23 <GNU\colossus> zygospasm: might I ask why you asked? ;)
11:39:28 <mauke> hmm, maybe I should automate that
11:39:44 <PeakerWork> an automated script to spam-click ads on a given site from many IP addresses might be a nicer counter to the site spammers
11:39:54 <zygospasm> GNU\colossus: i'm just worried that you'll get numerical problems if you use 'floor'
11:39:56 <Baughn> PeakerWork: It's the result of /multiple/ rewrite rules, but they did it the right way. :)
11:40:05 <PeakerWork> (most advertiser services will decide its a cheat and cancel his account)
11:40:25 <GNU\colossus> zygospasm: could you please provide an example?
11:40:52 <PeakerWork> Baughn: cool
11:41:08 <Baughn> PeakerWork: Try -ddump-simpl -ddump-simpl-stats. :)
11:41:43 --- mode: ChanServ set +o mauke
11:41:43 --- topic: set to '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]' by mauke
11:42:43 --- mode: mauke set -o mauke
11:43:49 <zygospasm> > floor (sqrt (fromInteger (9007199254740993 ^ 2))) -- GNU\colossus
11:43:50 <lambdabot>   9007199254740992
11:44:05 <zygospasm> GNU\colossus: admittedly that's a pretty big number to be factorizing ;-)
11:44:58 <GNU\colossus> zygospasm: I see. well, since this isn't something to be used in real world, I think it's ok to ignore the issue.
11:45:07 <Baughn> PeakerWork: -ddump-simpl-stats is actulaly really interesting. Try it on something big, and marvel
11:45:54 <lollan> hello is there a module like php-elispe for haskell with emacs ?
11:46:07 <lollan> hello is there a module like php-elispe for haskell with emacs ?
11:46:09 <Baughn> Why, yes! Yes, there is!
11:46:15 <lollan> hello is there a module like php-elispe for haskell with emacs ?
11:46:17 <Baughn> lollan: http://projects.haskell.org/haskellmode-emacs/
11:46:19 <lollan> hello
11:46:21 <sinelaw> oy vey....
11:46:22 <Baughn> ..um...
11:46:22 <shambler_> oh god...
11:46:25 <PeakerWork> Baughn: nice
11:46:29 <lollan> thanks Baughn
11:46:44 <PeakerWork> lollan: please don't repeat your questions
11:46:44 <Baughn> lollan: ..for future reference, we're not deaf.
11:46:51 <sinelaw> it's rise of the zombie users
11:47:26 <ehamberg> i get the following problem when loading CountEntriesT.hs from RWH into ghci:
11:47:27 <ehamberg> Could not find module `Control.Monad.Trans': it was found in multiple packages: transformers-0.1.4.0 mtl-1.1.0.2
11:47:27 <lament> brains! brains!
11:47:51 <ehamberg> i tried hiding transformers, but then i got Module imports form a cycle for modules
11:48:02 <Heffalump> that is odd
11:48:26 <sinelaw> Baughn, that 'tidy core' output looks nice
11:48:32 <lollan> Baughn: I had a problem with irssi,sorry about that
11:48:37 <lollan> sorry PeakerWork
11:48:41 <Heffalump> ehamberg: which modules form the cycle?
11:48:44 <lollan> sorry all
11:48:47 <ehamberg> the code is here http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11485
11:48:56 <Baughn> sinelaw: Tidy core? What, now?
11:49:19 <sinelaw> -ddump-simpl
11:49:21 <ehamberg> Heffalump: Control.Monad.Writer Control.Monad.Trans Control.Monad
11:49:43 <azumanga> In general in haskell, how is the problem of generating large structures without copying them each time you add something to them handled? If I just add lots of elements to a Map can I expect it to just be fast :)
11:49:57 <mauke> azumanga: haskell never copies
11:50:01 <ehamberg> Heffalump: error message: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11486
11:50:03 <Heffalump> azumanga: it'll share most of the data
11:50:12 <Heffalump> sorry, all of the data and most of the Map structure
11:50:44 <Heffalump> ehamberg: oh, the cycle is in CountEntries itself
11:50:59 <Heffalump> importing yourself is a trivial cycle, the error message is just including superfluous stuff
11:51:36 <bauchus> stupid question: how do I convert a String to a Bytestring? my best guess is: > pack $ Prelude.map (fromIntegral.fromEnum) "A"
11:51:46 <azumanga> Heffalump: Good, I'm sure this is a solved problem, I just wanted to get a feel for the 'right way' of doing things. I come from a C++ background where you either change variables in place, or use a file buffer of some kind which you fill up. obviously neither is a nice way of doing things in haskell, but I have just found my code has a problem where I was doing too much string concatination
11:51:48 <sinelaw> what does the I combinator do?
11:51:49 <ehamberg> Heffalump: d'oh. the module was supposed be named CreateEntriesT. thanks! :)
11:52:24 <Heffalump> azumanga: string concatenation should be arranged so that it brackets to the right, then it'll run in linear time
11:52:49 <mauke> bauchus: ByteString.Char8.pack
11:52:54 <skorpan> does this parser make any sense for parsing "period or hash or nothing followed by only letters"?  optional (oneOf ".#") `mappend` many1 letter
11:52:58 <Heffalump> ehamberg: no problem. it's easy to be diverted by red herrings when you've already had one problem with that area.
11:53:30 <Saizan_> skorpan: why mappend?
11:54:03 <skorpan> Saizan_: i used (>>) before but with that the ".#" wasn't included in the result
11:54:13 <bauchus> mauke: thanks, i was in the wrong module (Data.ByteString.Lazy)
11:54:25 <skorpan> Saizan_: i figured maybe mappend would include it somehow...
11:54:48 <mauke> lern2monads
11:54:57 <skorpan> :(
11:55:38 <skorpan> would you believe me if i said my master thesis was about incremental parsing?
11:55:39 <mauke> do { x <- optional (oneOf ".#"); y <- many1 letter; return $ x ++ y }
11:55:40 <skorpan> in haskell
11:56:05 <bauchus> but now i get: couldn't match Data.ByteString.Lazy.Internal.ByteString againts Data.ByteString.Char8.ByteString :-(
11:56:07 <Baughn> skorpan: Want to help me on haskell-mode?
11:56:07 <Saizan_> doesn't optional return a Maybe?
11:56:13 <Baughn> skorpan: It's about incremental parsing. Of haskell.
11:56:36 <mauke> @hoogle Maybe a -> [a]
11:56:37 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
11:56:37 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
11:56:37 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
11:56:41 <Saizan_> bauchus: you want Data.ByteString.Lazy.Char8.pack then
11:56:45 <skorpan> mauke: i actually did that, but it failed.. probably because i was using "parse"
11:56:53 <mauke> skorpan: how did it fail?
11:57:08 <bauchus> indeed! thanks
11:57:26 <skorpan> mauke: http://pastebin.com/d2c87332a
11:57:52 <mauke> you did it wrong
11:58:04 <skorpan> Baughn: i would if i had the time
11:58:32 <skorpan> Baughn: oh, what, you're svein? :)
11:58:39 <Baughn> Yep
11:59:00 <skorpan> i was the guy who reported those installation problems in both 2.5 and 2.6
11:59:04 <skorpan> i am*
11:59:19 <Baughn> Ah. All fixed now, I hope?
11:59:26 <skorpan> yep :)
11:59:56 <skorpan> mauke: how?
12:00:15 <mauke> skorpan: I don't know, you didn't show the code that binds 'first'
12:00:40 <skorpan> mauke: http://pastebin.com/d25c3805a
12:01:06 <mauke> that doesn't contain 'first'
12:01:27 <skorpan> okay... let me undo then
12:02:23 <sinelaw> Yi failed building.
12:02:24 <sinelaw> http://paste2.org/p/495664
12:02:26 <skorpan> whaddya know, i had let-bound them instead of <-ed them
12:02:39 <mauke> excellent
12:02:42 <sinelaw> ah stupid paste.
12:02:47 <mauke> my work here is done
12:02:52 <skorpan> mauke: what i pasted failed as well though
12:03:38 <sinelaw> ok, here's the log: Yi fails building http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11487#a11487
12:04:02 <skorpan> sinelaw: there's #yi btw
12:04:22 <sinelaw> oh
12:07:24 <nlogax> sinelaw: i had that too, got a newer version and built it and it worked
12:08:15 <sinelaw> nlogax, you got from darcs?
12:08:40 <nlogax> sinelaw: yes
12:08:47 <sinelaw> ok
12:09:08 <Baughn> ..what the heck, is openssl a dead project?
12:09:43 <mauke> yeah, all the cool kids use openrot13 now
12:09:57 <mmorrow> yeh, so leet
12:10:15 <Baughn> Well, I'll admit it seems implausible, but..
12:10:26 <Phyx-> hello, question, is there a nicer way to write  (\(a,b,c)->a++b++c) . unzip3
12:10:37 <Baughn> Bug reports (even with patches) aren't being touched, documentation isn't being updated, and obviou AES functions are missing
12:10:48 <Baughn> Actually, openssl's AES library doesn't /have/ documentation. At all.
12:11:07 <idnar> @type unzip2
12:11:08 <lambdabot> Not in scope: `unzip2'
12:11:08 <idnar> er
12:11:09 <idnar> @type unzip3
12:11:10 <lambdabot> forall a b c. [(a, b, c)] -> ([a], [b], [c])
12:11:25 <skorpan> why does parsec2's "optional" return ()?
12:11:38 <PeakerWork> yuck @ N-tuples again :-(
12:11:54 <Phyx-> :(
12:12:13 <Vanadium> @type optional
12:12:14 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f (Maybe a)
12:13:02 <skorpan> :tText.ParserCombinators.Parsec.Combinator.optional
12:13:05 <skorpan> :t Text.ParserCombinators.Parsec.Combinator.optional
12:13:06 <lambdabot> forall tok st a. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st ()
12:13:17 <mauke> wat
12:13:31 <skorpan> that's what the error was about... i don't get it. WHY
12:13:41 <mauke> I think it's because parsec hates you
12:13:47 <skorpan> who doesn't
12:13:56 <mauke> parsec hates me too :-(
12:14:35 <mauke> optional p = liftM Just p <|> return Nothing  -- fixed
12:14:37 <Phyx-> maybe you've been rude to it
12:14:41 <skorpan> :t Text.ParserCombinators.Parsec.Combinator.optionMaybe
12:14:43 <lambdabot> forall tok st a. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st (Maybe a)
12:14:44 <skorpan> is that it?
12:14:53 <mauke> oh, yes
12:16:32 <Phyx-> @pl unlines . join . (\(a,b,c)->a++b++c) . unzip3 . map generateCCode
12:16:33 <lambdabot> (line 1, column 24):
12:16:33 <lambdabot> unexpected ","
12:16:33 <lambdabot> expecting letter or digit, operator or ")"
12:16:33 <lambdabot> ambiguous use of a non associative operator
12:16:37 <Phyx-> :P
12:16:38 <skorpan> quiz time: what's prettier than (:[])?
12:16:49 <Phyx-> guess @pl still can't handle tupples
12:17:12 <mauke> skorpan: return
12:17:25 <skorpan> cool
12:17:38 <mauke> :t maybeToList
12:17:39 <lambdabot> forall a. Maybe a -> [a]
12:17:52 <skorpan> ... that's actually what i needed.
12:17:57 <skorpan> maybe "" return x
12:18:01 <skorpan> is that the same?
12:18:05 <skorpan> (but less general?)
12:18:12 <skorpan> @src maybeToList
12:18:12 <lambdabot> maybeToList  Nothing   = []
12:18:12 <lambdabot> maybeToList  (Just x)  = [x]
12:18:20 <skorpan> it is
12:18:53 <sproingie> it's listToMaybe that drives me nuts.  i guess it represents "first right answer"
12:19:12 <skorpan> @src listToMaybe
12:19:13 <lambdabot> listToMaybe []        =  Nothing
12:19:13 <lambdabot> listToMaybe (a:_)     =  Just a
12:19:27 <skorpan> i think that's a reasonable definition
12:19:50 <PeakerWork> > let listToMaybe x = do { a:_ <- x ; return x } in map listToMaybe [[], [1]]
12:19:51 <lambdabot>   No instance for (GHC.Num.Num [t])
12:19:51 <lambdabot>    arising from the literal `1' at <inter...
12:20:08 <PeakerWork> > let listToMaybe xs = do { x:_ <- xs ; return x } in map listToMaybe [[], [1]]
12:20:09 <lambdabot>   No instance for (GHC.Num.Num [b])
12:20:09 <lambdabot>    arising from the literal `1' at <inter...
12:20:34 <sproingie> Num.Num.Num.Num
12:22:06 <Phyx-> aww my program died
12:22:23 <mauke> killall killall
12:23:39 <sproingie> psycho killall, out to get ya, buh buh buh BUH buh
12:24:16 <mmorrow> you forgot to mention your -9mm
12:24:36 <skorpan> related: http://www.youtube.com/watch?v=Fow7iUaKrq4
12:24:39 <sproingie> that's the "bustacap" command
12:25:40 <absentia> monzy is lame
12:27:19 <skorpan> "i'm like dot slash configure, my package is bigger"
12:27:51 <mreh> is there a list "minus"? like minus for sets
12:27:54 <mreh> set difference
12:28:02 <skorpan> :t (\\)
12:28:03 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
12:28:06 <Phyx-> hrm.. I hate it when GHC is right :P
12:28:25 <mreh> > [1,2,3,3,4] \\ [1,2,3]
12:28:26 <lambdabot>   [3,4]
12:28:27 <sproingie> \\ does assume your list is set-like
12:28:30 <mreh> awesome stuff
12:28:34 <sproingie> > "foobar" \\ "o"
12:28:35 <lambdabot>   "fobar"
12:28:38 <sproingie> > "foobar" \\ "oo"
12:28:40 <lambdabot>   "fbar"
12:28:52 <mreh> sproingie, it's precisely what I need
12:28:56 <sproingie> cool
12:29:08 <sproingie> otherwise you can just nub the first list
12:29:24 <sproingie> > nub "foobar" \\ "o"
12:29:25 <lambdabot>   "fbar"
12:29:38 <PeakerWork> Can cabal-install fetch all the packages in the background while compiling the first ones?
12:30:31 <sproingie> i should probably use nub and \\ for my hangman example
12:30:55 <sproingie> all $ map (`elem` guessed) word isn't so bad tho
12:31:00 <Phyx-> isn't (\\) . nub terribly inefficient?
12:31:14 <sproingie> probably
12:32:12 <byorgey> Phyx-: it's O(n^2).  I wouldn't describe it as "terribly" inefficient.
12:32:39 <byorgey> Phyx-: (\\) is O(n^2) anyway.
12:33:19 <byorgey> well, actually, (\\) is O(mn) where m and n are the lengths of the two lists.
12:33:33 <sproingie> embarassingly enough searching for "haskell hangman" pulls up a post of mine complaining that the example didn't show stateful programs
12:33:33 <byorgey> (\\) . nub  is  O(m^2 + mn).
12:33:52 <byorgey> so it's inefficient if the list you're removing is much smaller than the list you're removing from.
12:34:06 <sproingie> oh well, everyone was a noob once.  for me, that's a moving window of 2 years back
12:34:06 --- mode: ChanServ set +o mauke
12:34:06 --- mode: mauke set -b *!*@87.69.54.117.cable.012.net.il
12:34:31 <temoto> sproingie: hello there! Didn't expect to see you on #haskell.
12:34:41 <byorgey> > nub "foobar" \\ "b"   -- not quite... =)
12:34:42 <lambdabot>   "foar"
12:34:54 <sproingie> temoto: i have the memory of a guppy, what other channel have i seen you on?
12:35:01 <temoto> sproingie: #python
12:35:03 <sproingie> ah
12:35:06 --- mode: mauke set -o mauke
12:35:19 <Phyx-> byorgey: yeah, i didn't do the calculations, I just wondered :P
12:35:21 <sproingie> there's a fair overlap between haskell and python communities
12:35:41 <sproingie> personally i think #haskell got the best parts, myself perhaps not included :)
12:35:48 <temoto> Please help to make partial application right way:
12:35:51 <temoto> -- Try all four directions in up-right-down-left order.
12:35:53 <temoto> tryAllDirs board from state = map (\dir -> tryDir dir board from state) [DirUp, DirRight, DirDown, DirLeft]
12:35:54 <bauchus> ghci complains, that Control.Monad.Trans was found in tranformers and mtl
12:36:04 <bauchus> :-(
12:36:16 <temoto> i feel that it can be written w/o board,from,state args at all
12:36:17 <sproingie> bauchus: you probably need to hide transformers
12:36:28 <PeakerWork> I left #python as I realized how many of the claims people make in there (including myself, before I knew better) are really baseless.. After learning Haskell, it became painful to listen to #python
12:36:29 <bauchus> with ghc-pkg?
12:36:51 <temoto> PeakerWork: baseless is a good word.
12:36:53 <paper_cc> bauchus: ghc-pkg hide transformers
12:37:08 <Phyx-> actually
12:37:11 <paper_cc> bauchus: (you'll probably need to sudo it)
12:37:11 <Phyx-> there was another way
12:37:15 <byorgey> temoto: well, first, if tryDir took dir as its last argument instead of its first, you could write that as   map (tryDir board from state) [DirUp, ...
12:37:18 <sproingie> PeakerWork: you left there too, eh?
12:37:27 <PeakerWork> sproingie: arkanes was especially painful
12:37:37 <PeakerWork> sproingie: Being wrong is OK, but being wrong with an attitude, man
12:37:40 <sproingie> PeakerWork: yunno i think he may have been why i left too
12:37:45 <bauchus> hey, Control.Monad.Trans is also in monads-fd
12:37:57 <sproingie> PeakerWork: there's several clones of him there tho.  the worst part was i was becoming that way too
12:38:05 <Phyx-> import "mtl" Control.Monad.Trans or something
12:38:12 <Phyx-> which needed a language extension
12:38:16 <PeakerWork> sproingie: can you come to #haskell-blah ?
12:38:19 <paper_cc> bauchus: you've got every MTL out there =) hide all that you don't need
12:38:27 <temoto> byorgey: well dir isn't the problem. Other 3 arguments are.
12:38:29 <paper_cc> bauchus: or use -hide-package on the ghc command line
12:38:37 <paper_cc> bauchus: or build with cabal
12:38:41 <Phyx-> bauchus: use
12:38:46 <Phyx-> import "mtl" Control.Monad.Trans
12:38:50 <byorgey> temoto: then you can change it to   tryAllDirs = flip map [DirUp, ...] #$&% tryDir,  where #$&% is an appropriate composition combinator that gives the second function three arguments before composing
12:38:57 <Phyx-> and add to the top of the file {-# LANGUAGE PackageImports #-}
12:38:59 <bauchus> thanks for the hints! #haskell is great.
12:39:13 <Phyx-> you don't need to globally hide it then using the package manager
12:39:44 <byorgey> @pl \f g x y z = f (g x y z)
12:39:44 <lambdabot> (line 1, column 12):
12:39:45 <lambdabot> unexpected "="
12:39:45 <lambdabot> expecting pattern or "->"
12:39:49 <byorgey> @pl \f g x y z -> f (g x y z)
12:39:50 <lambdabot> (.) . (.) . (.)
12:40:08 <byorgey> so #$&% = (.).(.).(.), but I don't recommend actually using that.
12:40:25 <temoto> byorgey: so better leave it as is?
12:40:49 <byorgey> temoto: that, or put  board, from and state  together into some data type.
12:40:54 <sinelaw> how to install gtk2hs?
12:41:06 <skorpan> impossible
12:41:13 <byorgey> then you only need one parameter instead of three and you can just say  tryAllDirs = flip map [DirUp, ...] . tryDir
12:41:13 <skorpan> the few who managed to don't remember
12:41:23 <Phyx-> lol
12:41:24 <Vanadium> cabal install gtk2haaaaargh
12:41:25 <temoto> byorgey: thanks.
12:41:30 <Phyx-> sinelaw: which platform?
12:42:03 <byorgey> temoto: whenever you are taking multiple parameters and then just passing them all on as parameters to something else, it probably means they should be encapsulated in a new data type
12:42:03 <Phyx-> hrm.. still no 6.10.4 binaries :P
12:42:29 <Phyx-> sinelaw: anyway, this should have all you need http://www.haskell.org/gtk2hs/download/
12:42:38 <mreh> who else finds nesting maps really horrible to read?
12:43:42 <BONUS> @pl \f -> let result = (.) in (result.result.result) f
12:43:42 <lambdabot> (.) . (.) . (.)
12:43:56 <BONUS> semantic editor combinators woot
12:44:05 <byorgey> ah, yes =)
12:44:19 <temoto> byorgey: thanks for hint.
12:45:24 <sinelaw> Phyx-, no cabal? :( :(
12:46:39 * hackagebot upload: tkhs 0.2.1 - Simple Presentation Utility (YusakuHashimoto)
12:46:41 * hackagebot upload: multiset 0.2 - The Data.MultiSet container type (TwanVanLaarhoven)
12:46:50 <BONUS> :t (first.fmap.fmap.second) chr (\x y -> (GT, x*y), "hah")
12:46:51 <lambdabot> (Int -> Int -> (Ordering, Char), [Char])
12:47:06 <BONUS> :t (\x y -> (GT, x*y), "hah")
12:47:08 <lambdabot> forall a. (Num a) => (a -> a -> (Ordering, a), [Char])
12:47:20 <Phyx-> sinelaw: nafaik, but I think that's because it's not that easy to compile, which is why I think they pre-compile the binaries for you
12:48:20 <Phyx-> grrr hate it when i buy a dvd, and first thing i see when i pop it in "DON'T STEAL THIS MOVIE"
12:48:20 <PeakerWork> mreh: let each = map in (each . first . each . result) (*2)      -- [([a->b], c)] applies a function on the b  -- just follow it like a path
12:48:31 <PeakerWork> mreh: (map . map . map) -- nested maps, but readable (apply a function 3 lists deep)
12:48:33 <byorgey> sinelaw, Phyx- : gtk2hs isn't cabalized because Cabal doesn't yet have the features necessary to do it.
12:48:52 <byorgey> sinelaw, Phyx- : it isn't actually that hard to compile.  at least, I've never had any problems.  it just takes a while.
12:49:02 <mreh> Would you steal a car?!
12:49:12 <Phyx-> byorgey: but you need the developers version of gtk don't you?
12:49:14 <Phyx-> to compile?
12:49:16 <mreh> Would you kill a baby?
12:49:22 <mreh> Then don't steal movies
12:49:31 <Phyx-> mreh: but i just bought it.
12:49:42 <mreh> it's so over the top
12:50:01 <byorgey> Phyx-: well, yeah, you need the dev versions of various things.  but those should all be available from your package manager if you're on Linux.
12:50:04 <Badger> I would kill a baby, but, stealing movies? That's just sick and wrong.
12:50:10 <mreh> yeah, the government thinks making everyone suffer is the right idea
12:50:29 <mreh> even more incentive to steal move movies
12:50:30 <byorgey> I have no idea what the state of play is on OSX or Windows.
12:50:32 <Phyx-> byorgey: true, I only tried compiling it on windows
12:50:52 <byorgey> Phyx-: ok, it may very well be difficult to compile on Windows, I don't know =)
12:51:29 <Phyx-> btw, while i'm here
12:51:36 <mreh> how can I apply a function to every permutation of a list?
12:51:44 <mauke> map f . permutations
12:51:44 <mreh> map a function sorry
12:52:04 <Phyx-> does anyone know, if there's a flag or something for ghc, to get it to print out the optimization it's applying in each step and the core code till that point?
12:52:31 <mreh> :t map f . permutations
12:52:32 <lambdabot> forall b a. (Show a, SimpleReflect.FromExpr b) => [a] -> [b]
12:52:50 <Phyx-> or do i need to hack it in and re-compile ghc?
12:52:54 <Phyx-> :t f
12:52:55 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
12:52:56 <mreh> I meant, map a function to every element in every permutation of a list
12:53:00 <Phyx-> lol
12:53:03 <Phyx-> mreh: it is
12:53:10 <Phyx-> :\f -> map f . permutations
12:53:11 <mauke> map (map f) . permutations
12:53:15 <Phyx-> ::t \f -> map f . permutations
12:53:19 <Phyx-> :t \f -> map f . permutations
12:53:20 <lambdabot> forall b a. ([a] -> b) -> [a] -> [b]
12:53:34 <Phyx-> :t a
12:53:35 <lambdabot> Expr
12:53:51 <Phyx-> is every single letter variable taken by Expr?
12:53:53 <Phyx-> lol
12:53:58 <Phyx-> :t l
12:53:59 <lambdabot> Expr
12:54:00 <mreh> just ones not in scope
12:54:02 <mreh> :t hello
12:54:03 <lambdabot> Not in scope: `hello'
12:54:05 <mreh> doh!
12:54:08 <mreh> yeah,
12:54:23 <mreh> single letters seem the way to go
12:54:37 <mreh> what if I want more than 26
12:54:54 <Phyx-> use another alphabet
12:55:12 <mauke> spoken like a true mathematician
12:55:21 <mreh> heh
12:55:33 <mreh> what are the rules, mathematicians are never consitant
12:56:59 * Phyx- has to find out why he's getting garbage from FFI
12:57:05 <Phyx-> think the alignment is off
12:57:15 <Warrigal> These are the rules of mathematics: A, A => B |- B
12:58:22 <Botje> don't forget ¬¬ A |- A
13:00:08 <Phyx-> what, no contraposition ?
13:06:50 <PeakerWork> does yi have something like ido?
13:06:55 <PeakerWork> emacs ido, that is
13:07:10 <luqui> I'm working in C#, and I have a generic class which really wants a Monoid constraint on one of its parameters.
13:07:19 <luqui> But C#'s type system doesn't seem good at modeling such a thing
13:07:21 <skorpan> PeakerWork: no, not afaix
13:07:24 <skorpan> afaik*
13:07:28 <luqui> does anyone know a good way to model that?
13:07:29 <PeakerWork> hmm.. sounds like a nice project
13:07:48 <PeakerWork> luqui: IIRC you can have subclass constraints
13:08:06 <PeakerWork> luqui: maybe it can subclass from a class that has a class-method for mempty and mappend as a method?
13:08:13 <PeakerWork> s/a class/an interface
13:08:35 <luqui> i don't think class methods can be overridden
13:09:57 <luqui> I can't think of anything except for explicitly passing a monoid dictionary
13:10:05 <luqui> maybe that's the way to go
13:10:43 <PeakerWork> luqui: probably
13:12:21 * Saizan_ just realized that Comparator objects are the OO version of explicit dictionaries
13:15:10 <Botje> except not compiled away. *shivers*
13:19:27 <Phyx-> :ghc
13:20:47 <Phyx-> if -M the only way to get the depencies from ghc? i would rather have it on the stdout
13:21:25 <Phyx-> is*
13:21:33 <skorpan> what is the function which "looks" at the current token in parsec2?
13:21:38 <skorpan> i want to know where it is so to speak
13:22:32 <sinelaw> does anybody have a nify Yi config to sell for free?
13:22:44 <sinelaw> (at least with dark background...)
13:22:49 <sinelaw> *nifty
13:23:46 <anders^^> sinelaw: there are a couple included when you download yi
13:30:14 <gOcOOl> anyone have any luck dpkg installing the haskell-platform debian .deb file on an ubuntu (9.10) system?
13:31:21 <gOcOOl> I tired it and am getting a whole bunch of dependency errors :(
13:32:04 <skorpan> in parsec2 i want to check how many (char ' ') that will succeed, but not consume them.  how do i do that?
13:32:20 <skorpan> lookAhead?
13:33:29 <Baughn> skorpan: Seems obvious, yes
13:33:58 <skorpan> didn't quite do the trick, but i guess i'm doing it wrong (tm)
13:35:33 <Baughn> skorpan: It should be pretty foolproof. 'lookAhead foo' returns whatever foo would, without consuming input. It works the same way try does.
13:35:42 <skorpan> fixed it
13:36:04 <skorpan> weird error really...
13:36:38 <mmorrow> , readP_to_S ((length . takeWhile (==' ')) <$> look) (replicate 42 ' ' ++ "aaaaaaaaahhhhhhhhhhhhh")
13:36:39 <lunabot>  [(42,"                                          aaaaaaaaahhhhhhhhhhhhh")]
13:37:11 * mmorrow prefers readP
13:37:26 <skorpan> it was a operator precedence error
13:45:28 <mreh> what causes a haskell program to suddenly take ages when you increase the size of the data set by a little bit
13:45:56 <medfly> switching from int to integral
13:46:00 <medfly> I guess
13:46:11 <medfly> or anything of that sort
13:46:26 <stepcut> mreh: if the program requires a lot of memory, and you suddenly hit the barrier where you start swapping
13:46:43 <mreh> stepcut: hmmm, maybe I should profile this mother
13:46:50 <stepcut> haskell apps tends to make swap go crazy
13:47:16 <mreh> 45 runs of a test takes 2 seconds, 50 takes an infinite amount of time
13:47:27 <mreh> not infinite, but so long I gave up
13:47:53 <stepcut> mreh: yeah, easiest thing to do is, +RTS -s
13:48:00 <mreh> with ghci?
13:48:03 <stepcut> you don't have to compile with profiling or anything special
13:48:16 <stepcut> are you using ghci, or running your app compiled ?
13:48:32 <mreh> using ghci
13:48:46 <stepcut> hrm, trying compiling with, ghc --make -O2, and see if that helps?
13:48:53 <stepcut> ghci does not optimize at all
13:49:16 <mreh> :O
13:49:28 <sproingie> not only not optimized, it's bytecode
13:50:05 <stepcut> ghci will, however, load compiled modules if they are available and up-to-date
13:50:22 <mreh> is that 02 or O2
13:50:26 <mreh> oh
13:50:27 <stepcut> zero two
13:50:34 <stepcut> no wait
13:50:37 <stepcut> oh two
13:50:38 <stepcut> :p
13:50:40 <stepcut> gotta run
13:50:41 * qwr . o O ( swapoff -a should cure the swapping... but not the excessive memory use )
13:50:57 <stepcut> qwr: indeed
13:51:23 <mreh> woo, it works now
13:51:55 <stepcut> mreh: in general, using ghci should not suddenly start sucking like that
13:52:19 <mreh> stepcut: what is your diagnosis?
13:52:23 <mreh> inefficient coding?
13:52:31 <stepcut> mreh: maybe you are hitting some barrier where it generates enough garbage that the garbage collector starts fighting with it or something
13:52:46 <mreh> there is literally a boundary between 45 and 46 test runs where it suddenly take ages
13:52:54 <stepcut> laziness and garbage collection are cruel mistresses
13:53:11 <mreh> atleast they are easier to reason with than Java
13:53:26 <stepcut> mreh: yeah, if you have a small, but runnable test case which demos this, you can ask on haskell-cafe
13:53:33 <mreh> I had to make a chess algorithm in Java, and it could only do 5 ply with 2GB!
13:53:43 <qwr> Java has gc, btw.
13:53:45 <mreh> stepcut, it's a 200 line program
13:53:50 <stepcut> if you just care about getting it to run, compiling with -O2 is a good approach
13:54:16 <stepcut> mreh: probably small enough, though you may want to upload the source somewhere and not email it directly to the list
13:55:01 <stepcut> mreh: such as, hpaste.org
13:55:19 <stepcut> I have to leave in a minute, so I can't look at it right now
13:58:54 <mreh> stepcut, thanks anway
14:00:08 <mreh> it's really inconsistant in its habits too
14:00:16 <mreh> sometimes no problem, sometimes it takes ages
14:01:06 <mreh> something is vibrating inside my computer, and it isn't the head on my disk
14:03:34 <EvanCarroll> how do i get ghci to recognize basic term stuff, like home and end
14:05:40 <Saizan_> ?go haskeline wiki
14:05:40 <lambdabot> Maybe you meant: google googleit do
14:05:44 <Saizan_> ?google haskeline wiki
14:05:45 <lambdabot> No Result Found.
14:07:10 * hackagebot upload: monadloc 0.1 - A class for monads which can keep a stack trace (PepeIborra)
14:07:12 * hackagebot upload: control-monad-failure 0.1 - A class for monads which can fail with an error. (PepeIborra)
14:07:56 <aavogt> failure monads, eh?
14:09:10 * hackagebot upload: safe-failure 0.1 - Library for safe functions (PepeIborra)
14:09:40 <mreh> stepcut, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11489#a11489
14:10:00 <mreh> have a quick look, look at the function test1Loop
14:10:00 <mmorrow> seems like someone got pushed over the edge by mysterious and untraceable "error: .." messages
14:10:12 * hackagebot upload: control-monad-exception 0.5 - Explicitly typed, checked exceptions with stack traces (PepeIborra)
14:10:18 <mreh> it's recursive and generates large datasets, any suggestions for optimisation?
14:11:21 <mreh> I suppose repeatM might be better than a recursive function
14:11:24 <mreh> :t repeatM
14:11:25 <lambdabot> Not in scope: `repeatM'
14:11:25 <Saizan_> does it eventually terminate? are you sure you don't have an infinite loop bug that gets triggered only with certain values of the random seed?
14:11:39 <sproingie> :t replicateM
14:11:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
14:11:57 <sproingie> huh but no repeatM?
14:12:05 <sproingie> @src replicateM
14:12:06 <lambdabot> replicateM n x = sequence (replicate n x)
14:12:10 <Saizan_> ?type forever
14:12:11 * hackagebot upload: dataenc 0.13.0.2 - Data encoding library (MagnusTherning)
14:12:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
14:12:23 <mreh> Saizan_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11489#a11489 look at the loop1Test function, that's were it isn't coming back from
14:12:29 <mmorrow> @let forever' m a = forever' m =<< m a
14:12:30 <lambdabot>  Defined.
14:12:31 <mreh> it's run successfully at 100 once
14:12:47 <mreh> with no code changes
14:13:27 <Saizan_> i'd investigate the thing with reproducible seeds
14:16:12 * hackagebot upload: CheatSheet 2.0 - A Haskell cheat sheet in PDF and literate formats. (JustinBailey)
14:16:27 <mreh> Saizan_: what kind of seeds?
14:20:11 <Saizan_> mreh: i guess you could just getStdGen at the start to log it, so that you can use it to reproduce with setStdGen
14:23:38 <jlouis> Say I have functions embed :: a -> b and project :: b -> a with id === embed . project === project . embed ; what abstract structure in Haskell does this fit into?
14:24:04 <jlouis> In other words, an iso
14:25:14 <lament> no structure
14:26:10 <lament> this is one of those laws that never make it to the compiler
14:26:24 <mmorrow> well, you can then map functions (a -> a) -> (b -> b) and vice-versa, so if you have, say, union for [a] and (Set a), and you have a [a], you could do (unionListBetter = project . unionSet . embed)
14:27:11 <mmorrow> so even though unionList and unionListBetter are equivalent result-wise, they're not equivalent complexity-wise
14:27:54 <mmorrow> jlaire: http://www.workerwrapper.com/
14:28:20 <mmorrow> oops
14:28:25 <mmorrow> jlouis: http://www.workerwrapper.com/
14:28:38 <jlaire> :P
14:28:42 <mmorrow> :)
14:29:56 <sproingie> anyone have a link to that list of different morphisms?  thinking of the one that was on reddit
14:30:26 <mmorrow> "different morphisms"?
14:30:58 <mmorrow> like a list of some examples of categories that like "_ is a category with objects _ and morphisms _"?
14:31:20 <jlouis> mmorrow: oh. I was thinking about it in the context of a class of reversible functions, ie, zip/unzip, parse/unparse, etc
14:31:32 <jlouis> encode/decode in general
14:31:44 <mmorrow> jlaire: the worker wrapper paper is interesting
14:31:46 <jlouis> but granted, perhaps the id only works one way for some of those
14:31:54 <sproingie> ah found it. http://comonad.com/reader/category/category-theory/
14:32:16 <mmorrow> jlouis: it's still useful if only one of (embed . project) or (project . embed) are id
14:32:17 * sproingie sees a page on the wiki for "Zygohistomorphic prepromorphisms"
14:32:20 <jlouis> mmorrow: oh, it is recent
14:32:26 <sproingie> for some reason i want to add "expialidocious" to that
14:32:35 <jlouis> mmorrow: I'll read that, thanks!
14:32:46 <mmorrow> jlaire: no problem :)
14:32:58 <jlouis> jlaire will go nuts, hehe
14:33:00 <mmorrow> gah!
14:33:01 <mmorrow> heh
14:33:15 <mmorrow> jlaire: my tab key hates you :)
14:33:22 <mmorrow> or likes you?
14:33:32 <jlouis> love at first tab?
14:33:41 <mmorrow> oh yes
14:37:58 <Phyx-> love at first tab?
14:38:01 <Phyx-> rofl
14:38:45 <mmorrow> no matter how many times i see "roflcopter", it still makes me laugh
14:39:36 <Phyx-> i never got that
14:40:24 <andun> "My brain just exploded." that GHC error message is hilarious :-P
14:40:39 <aavogt> @quote ghc
14:40:39 <lambdabot> ghc says: No parameters for class
14:40:42 <aavogt> @quote ghc
14:40:42 <lambdabot> ghc says: Malformed context in instance header
14:40:51 <Phyx-> ...
14:41:01 <aavogt> most of those aren't as funny as the brain exploding one
14:41:05 <Phyx-> you seriously need to get out more if you find those funny
14:41:37 <sproingie> i like some of the old unix error messages
14:41:43 <andun> no, no, compilers are the best source of entertainment
14:41:45 <sproingie> "lp0 on fire"
14:41:51 <sproingie> "you don't exist. go away."
14:43:27 <milaz> > 2 + 2
14:43:28 <lambdabot>   4
14:43:33 <milaz> wooooooooooow!
14:43:42 <milaz> Hi everybody!
14:44:42 <Paczesiowa> @src foldl1
14:44:42 <lambdabot> foldl1 f (x:xs) = foldl f x xs
14:44:42 <lambdabot> foldl1 _ []     = undefined
14:45:09 <Paczesiowa> @src foldl
14:45:10 <lambdabot> foldl f z []     = z
14:45:10 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:45:21 * hackagebot upload: monadloc 0.2 - A class for monads which can keep a stack trace (PepeIborra)
14:45:49 <byorgey> hey milaz
14:46:17 <milaz> can anybody explain me, what does such costruct as (# a, b #) mean?
14:46:28 <Paczesiowa> milaz: unboxed tuple
14:46:47 <milaz> can ordinary users make use of it?
14:47:15 <Paczesiowa> milaz: yes, you have to enable MagicHash or smth like that
14:47:42 <byorgey> milaz: it's not very common to need it unless you care very very much about optimization.
14:49:24 <milaz> oh, I see. thanks.
14:50:05 <aavogt> the compiler can usually do those optimizations for you, if it can recognize that certain fields are always evaluated
14:50:11 <aavogt> or if you specify that they are strict
14:52:21 <milaz> is there a way to see if compiler made these optimizations?
14:52:31 <Paczesiowa> ghc-core
14:53:06 <aavogt> or treat it like a black box and just look at the profiling results
14:53:32 <milaz> ah, there's something like disassembler... cool!
14:57:56 <milaz> @src mapM_
14:57:56 <lambdabot> mapM_ f as = sequence_ (map f as)
14:58:11 <milaz> @src sequence_
14:58:11 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
14:58:24 * hackagebot upload: HDBC 2.2.0 - Haskell Database Connectivity (JohnGoerzen)
14:58:28 <milaz> @src mapM
14:58:28 <lambdabot> mapM f as = sequence (map f as)
14:58:38 <milaz> @src sequence
14:58:38 <lambdabot> sequence []     = return []
14:58:39 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:58:39 <lambdabot> --OR
14:58:39 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
14:58:49 * aavogt wonders how it would turn out if lambdabot had  sequence = mapM id
14:59:59 <PeakerWork> aavogt: yuck
15:00:14 <milaz> lol, I'd end up in an endless loop
15:02:32 <GNU\colossus> is there a statement that instructs Haskell to do nothing at all? like "pass" in python?
15:02:49 <Vulpyne> In what case are you trying to do that?
15:02:59 <GNU\colossus> I'd like to get rid of th else clause of an if
15:03:07 <Vulpyne> Are you in a monad?
15:03:08 <GNU\colossus> if that makes sense
15:03:12 <blackh1> GNU\colossus: return()
15:03:14 <GNU\colossus> not that I'd know
15:03:15 <Vulpyne> If so, you can use "when" or "unless".
15:03:25 <Vulpyne> If you're in a "do" block, you're in a monad.
15:03:39 <GNU\colossus> then I am not
15:03:53 <camio> undefined might be what you're looking for.
15:03:54 <andun> GNU\colossus: in general it doesn't make sense. you need the else clause because you *must* return the same type even if the condition is false
15:04:14 <Vulpyne> Let's say you have this function: blah :: Int -> Int ; blah x = if x > 10 then x * 10
15:04:23 <Vulpyne> If there was no "else" what could the function return?
15:04:52 <GNU\colossus> is it ok to paste 3 lines here?
15:04:53 <milaz> it would be very nice on your part to think what will happen else
15:05:19 <Vulpyne> I'm not sure, if you want to be safe, use hpaste.org
15:05:32 <Vulpyne> Or combine them onto a line, separated by semicolons possibly.
15:05:41 <GNU\colossus> hm well, I guess it's best to move all this to tomorrow. I'm way tootired to fink sensible right now anyway.
15:05:50 <lament> Vulpyne: if there's no 'else', your program wouldn't compile.
15:05:52 <GNU\colossus> good night all, and thanks for your efforts :)
15:06:04 <Vulpyne> Think about my little example. :)
15:06:16 <camio> :/ I was looking forward to seeing the context.
15:06:20 <Vulpyne> Yeah, it wouldn't compile. But if it was legally permissible, it still would't make sense.
15:06:36 <Vulpyne> Because every expression has a type, and it needs to evaluate to that type.
15:06:44 <Vulpyne> So blah must return an int.
15:10:19 <EvanCarroll> how do i get ghci to recognize basic term stuff, like home and end
15:10:24 <EvanCarroll> keys
15:10:42 <Vulpyne> Have you tried ^a and ^e?
15:11:02 <milaz> I run it from Emacs, and almost happy :)
15:11:15 <EvanCarroll> Vulpyne: that works =(
15:11:22 <EvanCarroll> why doesn't end/home work
15:11:29 <Vulpyne> EvanCarroll: It uses the normal Unix-y shortcuts.
15:11:39 <Vulpyne> There may be some way to make it use other keys, but I don't know how.
15:11:44 <EvanCarroll> those are emacs keybindings
15:11:50 <EvanCarroll> bleh
15:12:08 <Vulpyne> Anything that uses/emulates readline usually uses those keys.
15:12:14 <milaz> No, I made it run from Emacs for the sole purpose of using home, end, and other normal keys!
15:12:15 <EvanCarroll> what?
15:12:16 <Vulpyne> Are you actually using it in Unix?
15:12:32 <EvanCarroll> no, I'm using it in linux.
15:13:11 <EvanCarroll> but the a/e/u are emacs keybinds, i don't think they have anything to do with readline.
15:13:35 <Vulpyne> They've worked in everything using readline that I've tried.
15:13:47 <Vulpyne> sh and Bash also.
15:13:58 <EvanCarroll> no you're right
15:14:00 <EvanCarroll> they are in readlie
15:14:03 <Vulpyne> I don't think ghci actually uses readline anymore, but it uses a library that emulates that.
15:14:04 <sproingie> readline will use either emacs or vi keybindings depending on what's in .inputrc
15:14:05 <EvanCarroll> bash has vim keybindings too
15:14:09 <milaz> I also run ghci from gnome-terminal in Ubuntu, and home/end work ok
15:14:11 <sproingie> it defaults to emacs
15:14:21 <EvanCarroll> yea, maybe that's why home/end are broken only in ghci
15:14:22 <milaz> it looks like it's you terminal settings
15:14:24 <Vulpyne> Yeah, home and end work in my xterm al.
15:14:25 <Vulpyne> also.
15:14:31 <Vulpyne> ghci running in an xterm.
15:14:34 <EvanCarroll> milaz: thats my environment, unmodified gnome-terminal in ubuntu
15:14:51 <sproingie> wonder if ghci can be made to not use its emulation, then you could run it under rlwrap
15:14:59 <milaz> urr... um... Ubuntu 9.04 + ghc installed from apt-get
15:15:06 <EvanCarroll> 9.10
15:15:12 <milaz> I didn't modify anything
15:15:40 <Vulpyne> You'd have to recompile it without haskeline.
15:15:47 <EvanCarroll> ghci 6.10.4
15:16:03 <milaz> ghci 6.8.2
15:16:07 <Vulpyne> http://www.hypexr.org/linux_ruboff.php - maybe the last part there will help you.
15:16:20 <Vulpyne> What happens when you hit HOME or END? Does it print out a control key?
15:16:34 <EvanCarroll> just puts H or F on the screen
15:17:06 <Vulpyne> Have you tried it in a plain xterm?
15:17:14 <EvanCarroll> same thing
15:17:16 <EvanCarroll> yea
15:17:51 <Vulpyne> http://trac.haskell.org/haskeline/wiki/UserPrefs
15:18:00 <Vulpyne> I *think* ghci uses haskeline.
15:18:31 <Vulpyne> The customkeybindings link is probably what will be useful to you.
15:18:50 <milaz> anyway, is it practical to run ghci from terminal? do people usually integrate it into more umm... specialized environment?
15:19:14 <Vulpyne> I do my programming in emacs but I just run ghci from the terminal.
15:19:27 <EvanCarroll> no one would integrate ghci into an application
15:19:40 <EvanCarroll> it is just an interactive terminal
15:19:44 <Vulpyne> Only thing I hate about it is I usually write network servers and I have to restart ghci each time I run it since the port will be in use. :(
15:20:06 <PeakerWork> Vulpyne: maybe you can pass the REUSE_PORT/REUSE_ADDR flags to socket?
15:20:09 <milaz> EvanCarroll: I mean haskell-mode in emacs
15:20:23 <Vulpyne> Peaker: I've tried, the problem is the socket is actually still open.
15:20:30 <PeakerWork> Vulpyne: oh, why can't you close it?
15:20:30 <Vulpyne> It's not just that it was recently closed.
15:20:41 <Vulpyne> Well, I hit ^C to terminate my application.
15:20:55 <p_l> Vulpyne: are you on linux?
15:21:05 * FunctorSalad wonders under which conditions an ADT has a monad instance
15:21:08 <Vulpyne> I guess I could make it actually read keyboard input and shut down cleanly.
15:21:13 <milaz> Yes, it is a problem. Even after being closed, server socket appears being used fro some time.
15:21:20 <Vulpyne> But that won't always work when testing. (I'm on FreeBSD.)
15:21:27 <p_l> Set sysctls net.ipv4.tcp_tw_reuse=1 net.ipv4.tcp_tw_recycle=1
15:21:36 <Vulpyne> That's not the problem.
15:21:40 <p_l> at least on linux :)
15:21:47 <PeakerWork> Vulpyne: which code opens the socket? If its Haskell, can it be put in a bracket?
15:21:48 <Vulpyne> If I ^C it, exit ghci and immediately re run it, I have no problem binding the port.
15:21:59 <dancor> if i need to do independent IO on thousands of files on a multicore system, should i just forkIO all of them and let haskell figure out it should do one per core?  or should i forkIO equal to the number of cores
15:22:02 <Vulpyne> The problem is, no exception handlers get called when you ^C in ghci.
15:22:08 <Vulpyne> At least not that I've seen.
15:22:19 <Vulpyne> It already is in a bracket that closes the socket.
15:23:09 <milaz> By the way, about network :)
15:23:16 <PeakerWork> Vulpyne: how come it remains actually open then?
15:23:42 <PeakerWork> Vulpyne: Sorry if you already answered that before, and I wasn't reading yet
15:23:44 <Vulpyne> ghci doesn't really kill the process.
15:23:53 <p_l> dancor: I'd probably use a pool of system threads and "submit" jobs to it
15:24:01 <Vulpyne> What's kind of funny is if you ^C and there are forkIO'd threads doing stuff, they'll sometimes continue to print stuff out and run.
15:24:03 <dancor> p_l: ok
15:24:22 <PeakerWork> Vulpyne: ah, sounds like a FreeBSD port problem then?
15:24:37 <Vulpyne> Maybe... It's behaved like that for a lonnnng time.
15:25:11 <milaz> Is there some generally accepted practice of generating HTML from Haskell?
15:25:15 <Vulpyne> Try it on Linux and see if you get the same problem. :)
15:27:40 <gOcOOl> do I need anything special to make the -prof flag work with ghc? 'ghc -O2 --make perf-agg.hs' complies/links and works perfectly fine. the moment I do: "ghc -O2 --make perf-agg.hs -prof" it complains "Could not find module `Data.ByteString.Lazy.Char8'" which makes no sense at all
15:27:56 <dancor> milaz: idk, i last used Text.XHtml with happstack..
15:28:32 <dancor> has stuff like concatHtml, br, anchor, toHtml
15:28:40 <sshc> hackage is back up now, yes?
15:28:50 <roconnor> preflex: seen ivanm
15:28:50 <preflex>  ivanm was last seen on #xmonad 9 hours, 39 minutes and 15 seconds ago, saying: @tell blazzy to get xmonad to translate keybindings for chrome, have a look at XMonad.Util.Paste
15:29:01 <dancor> sshc: this loads for me: http://hackage.haskell.org/packages/archive/pkg-list.html
15:29:03 <sshc> what happened to it?
15:30:01 <Gracenotes> hm. I wonder what Haskell would look like if there were no garbage collection. (having to explicitly free objects from the heap)
15:30:21 <Nafai> Gracenotes: how would you know when to do so?
15:30:28 <dancor> withObject ..
15:30:40 <p_l> Gracenotes: maybe like even more crazy variant of first few iterations of original LISP
15:30:52 <Gracenotes> that's the tricky part. even a declared object might have several implicit closures
15:32:20 <PeakerWork> Gracenotes: Pure functions' evaluation would be very problematic
15:32:38 <Gracenotes> and speaking of "when" to do so, that might involve sequencing. something along the lines of dancor's suggestion, a la RAII
15:33:01 <Gracenotes> that would not necessarily require strictness
15:33:06 <Nafai> makes sense but sounds very painful
15:33:19 <milaz> dancor: thanks, i'm looking on it now :)
15:33:53 <jfhall> what are the conventions for module naming when extending an already existing module, like making some new Data.List functions
15:34:41 <PeakerWork> jfhall: Sometimes, Some.Module.Utils
15:36:56 <jfhall> PeakerWork: if I have functions that pertain only to Lists it seems like extending Data.List would be better, but I didn't know if that was possible
15:38:48 <PeakerWork> jfhall: I don't think two packages can export the same module (and co-exist)
15:39:57 <jfhall> PeakerWork: thats what I was afraid of... I'll just come up with some name, I was just looking for an accepted naming convention for extending a module... Thanks though
15:44:57 <PeakerWork> jfhall: it might be a mess if multiple packages could mix into the same namespace, especially considering their own imports and possibility for clashes between those.  It should be possible though
15:47:02 <coco> my parallel program runs slower with +RTS -H1000M -RTS (using 6.12.1)... what does this mean?
15:50:34 <jfhall> PeakerWork: I agree with you there
15:54:18 <sjanssen> coco: what do you expect that to mean?
15:54:33 <sjanssen> all sorts of programs might run more slowly with a heap that large
15:55:35 <milaz> is heap limited in ghc?
15:55:46 <milaz> or it can be extended when needed?
15:56:05 <sjanssen> milaz: the heap grows as needed, but you can tweak various settings as well
15:56:33 <coco> sjanssen: I misunderstand something then... why does a big heap make a program slow?
15:56:48 <milaz> the setting -H1000M means to pre-allocate 1Gb of heap on startup?
15:57:02 <sjanssen> coco: several smaller GCs might be faster than fewer very large ones
15:57:18 <sjanssen> coco: or -H1000M might mean you're hitting virtual memory
15:57:28 <sjanssen> or that less of your data is staying in the CPU's cache
15:57:38 <coco> sjanssen: the machine has 16GB so that's unlikely
15:57:43 <jlouis> Cache is probably the culprit
15:57:44 <sjanssen> milaz: yes, -H sets the minimum heap size
15:57:48 <Paczesiowa> @src init
15:57:48 <lambdabot> init [x]    = []
15:57:48 <lambdabot> init (x:xs) = x : init xs
15:57:48 <lambdabot> init []     = undefined
15:58:10 <coco> sjanssen: GC is indeed very different, without -H1000M threadscope looks like a millipede, with it not
15:58:24 <coco> sjanssen: however, when I do profiling the big difference is in the MUT
15:58:49 <coco> sjanssen: and GC is actually faster with -H1000M, according to the profile
15:59:19 <jlouis> coco: so your mutator spends more time waiting for the cache to load data?
15:59:51 <coco> jlouis: I had a similar thought, but -H500M, -H200M etc all give the same result
16:00:41 <coco> when the CPU is waiting for RAM, does that get counted as MUT?
16:00:59 <jlouis> coco: I have no idea, somebody else might
16:03:14 <sjanssen> coco: I would assume so
16:04:36 <milaz> good-bye!
16:10:31 <coco`> if a larger heap increases MUT time, is that likely to be due to worse locality?
16:11:48 <soduko> is there a way to make cabal install in a different location than the default ?
16:12:12 <dcoutts> soduko: yes, see cabal install --help
16:12:13 <Lemmih> soduko: Yes.
16:13:17 <soduko> do i have to specify the --prefix every time? how can i put that in the config file?
16:14:01 <mmorrow> coco`: it's because with a larger heap the GC has to run less, and i guess that the additional time per collection it takes with a larger heap times the number of times it runs is less than the same number with a smaller heap
16:14:13 <mmorrow> or something
16:14:47 <mmorrow> coco`: oh wait, /increases/ MUT time?
16:14:52 <mmorrow> coco`: dunno
16:15:14 <mmorrow> or increases the /ratio/ of MUT to GC time?
16:16:31 <mmorrow> coco`: maybe that's it if it's the former ("that" := cache interaction)
16:22:42 <coco`> mmorrow: it increases the MUT time and decreases the GC time (in absolute terms)
16:23:41 <coco`> mmorrow: this is in 6.12.1rc1 with -RTS -N6
16:25:05 <mmorrow> coco`: how many cores do you have?
16:25:14 <coco`> mmorrow: 8
16:25:33 <mmorrow> try with 8 (just because i'm curious :)
16:25:42 <coco`> ok
16:25:51 <mmorrow> but yeah, i dunno what could be causing the increase in MUT time
16:33:17 <coco`> mmorrow: same phenomenon with -N8
16:34:24 <eevar> tries -N16 ?
16:34:26 <eevar> *d
16:35:01 <mmorrow> coco`: yeah, maybe it's to do with the cache
16:36:38 <coco`> when is GC normally triggered?
16:39:43 <sproingie> when you're out of memory ;)
16:40:06 <mmorrow> coco`: there's generation 1 collection, and generation >1 (2 generations by default)
16:40:30 <mmorrow> coco`: generation 1 is per-thread and is usually the size of your datacache
16:40:45 <mmorrow> generation >1 needs to stop every thread before it can start
16:40:53 <coco`> datacache = L2cache in the CPU?
16:40:59 <mmorrow> then it collects in parallel (with itself)
16:41:18 <qwr> so, per-thread gc is triggered whenever its minor heap is full
16:41:19 <mmorrow> coco`: i believe so
16:42:45 <coco`> from the manual: "The allocation area (actually generation 0 step 0) is fixed and is never resized (unless you use -H, below)."
16:42:45 <coco`>  
16:42:45 <coco`>  
16:43:07 <coco`> but then "-H" doesn't explain how it affects -A...
16:49:02 <mmorrow> coco`: well, say you have two cores, and are running with -N2, so a major collection will collect with two threads. depending on which thread/core copied the particular piece of data that your thread running on core1 is reading, you could either hit or miss the cache
16:49:26 <mmorrow> also ghc migrates user threads between cores
16:49:46 <mmorrow> so there're a crapload of variables here that could be causing this
16:49:57 * hackagebot upload: mecha 0.0.2 - Mecha is a solid modeling language geared for machine design. (TomHawkins)
16:51:02 <coco`> mmorrow: I agree, but that would suggest that fewer garbage collections are better, no?
16:51:16 <mmorrow> *.. you could either hit or miss the cache (of core1, assuming that that data is even in the cache of either core)
16:51:30 <mmorrow> coco`: i'd have thought so too, yeah
16:52:07 <coco`> well, here -H1000M increases MUT time, decreases GC time, and also (dramatically) decreases the number of garbage collections
16:52:34 <EvanCarroll> oh my god.
16:52:55 <mmorrow> i don't get how it could _increase_ MUT time
16:53:11 <mmorrow> the only cause i can think of would be it missing the cache more
16:53:20 <mmorrow> so that must be it?
16:53:29 <sjanssen> wait, does -H change the initial generation?
16:53:38 <mmorrow> i dunno
16:53:40 <gOcOOl> I keep getting "Perhaps you haven't installed the profiling libraries for package bytestring ..." when using the -prof flag to ghc --make
16:53:40 <sjanssen> seems like that would have massive implications for cache
16:53:44 <gOcOOl> am I missing something?
16:53:50 <mmorrow> yeah, if -H is first gen
16:53:55 <Axman6> gOcOOl: reinstall bytestring
16:54:01 <mmorrow> but i thought from coco` that -H is gen 2
16:54:02 <sjanssen> gOcOOl: you're missing the profiling libraries for package bytestring, of course
16:54:12 <Axman6> gOcOOl: cabal install bytestring --reinstall -prof
16:54:21 <sjanssen> gOcOOl: cabal install bytestring --enable-library-profiling
16:54:21 <mmorrow> if gen 1 is larger than your datacache, bad news
16:54:25 <gOcOOl> but I'm just using the default build og ghc for my OS (ubuntu)
16:54:44 <gOcOOl> *of
16:54:47 <sjanssen> gOcOOl: apt-get install libghc6-bytestring-prof
16:54:48 <Axman6> gOcOOl: yes, which doesn't come with the profiling libraries for bytestring
16:55:09 <gOcOOl> ah ok
16:55:23 <sjanssen> they're split like this because the -prof versions more than double the disk used
16:55:47 <coco`> mmorrow: I think that my gen 1 is indeed larger than the data cache
16:55:55 <coco`> but how does this explain what's going on?
16:56:31 <sjanssen> coco`: gen 1 is for recently created objects, most use patterns touch recently created objects more frequently, giving good locality
16:56:39 <darkscythe> y
16:56:56 <darkscythe> keyboard slipped
16:57:00 <mmorrow> coco`: wow, i was under the impression from what i've read that having the first gen fit completely in the cache was crucial (or at least hugely desireable) for generational gc
16:57:28 <mmorrow> coco`: i really don't know how to explain what's going on, though
16:57:44 <coco`> oh, so does -H affect the size of the gen 1 cache?
16:57:48 <coco`> isn't that -A?
16:57:54 <mmorrow> i don't think so it does
16:58:01 <mmorrow> i don't think -A does that either
16:58:29 <mmorrow> from the output of +RTS -help, i don't think there's any option to change the first gen size
16:59:28 <mmorrow> coco`: heh, half-relevant but fully-amusing is to run your prog with +RTS -B
17:00:01 <coco`> I did the visual equivalent, i.e. threadscope
17:00:11 <coco`> without -H1000M it looks like a millipede
17:00:12 <mmorrow> coco`: oh nice, i've been meaning to build that
17:00:16 <mmorrow> heh
17:00:51 <coco`> I should also have mentioned that the phenomenon occurs with 6.12.1rc1, but not 6.10.4
17:01:01 <mmorrow> coco`: i'd ask JaffaCake about what could be happening here, if anyone has some sort of explanation it'd be him
17:02:05 <coco`> JaffaCake: can you help? :)
17:02:28 <mmorrow> coco`: he's usually in #ghc during work hours england-time
17:03:33 <coco`> hq time?
17:04:13 <mmorrow> that too
17:05:20 <dancor> does anything already exist to do a fixed-size m of forkIO threads and execute n tasks on them in first-come-first-served order
17:06:22 <EvanCarroll> http://hackage.haskell.org/trac/ghc/ticket/2606
17:06:23 <EvanCarroll> that is my bug with the control characters
17:06:23 <EvanCarroll> already reporteed
17:06:55 <Cale> dancor: is n >> m?
17:06:59 <dancor> Cale: yes
17:07:01 <mmorrow> dancor: so something like spawning n threads, and having them sit on a Chan?
17:07:12 <mmorrow> oh, missed the n,m
17:07:17 <dancor> n = 20k, m = 8
17:07:34 <dancor> they are independent IO
17:07:38 <dancor> on separate files
17:07:59 <Cale> 20k is small enough that I would consider just putting every one of them in its own thream
17:08:03 <Cale> thread*
17:08:03 <mmorrow> i'd forkIO m threads that readChan a Chan (IO ())
17:08:04 <dancor> hm
17:08:07 <mmorrow> then repeat
17:08:19 <mmorrow> and just fill the Chan with the n tasks
17:08:35 <dancor> Cale: ok i'll try that first
17:08:36 <Cale> Though yeah, you could do stuff with a Chan
17:08:36 <EvanCarroll> In 6.10 ghci uses the editline (libedit) package instead of readline, so only the former is distributed by default. The readline package can still be downloaded from hackage.haskell.org if needed.
17:08:40 <dancor> mmorrow: ya that seems like a good way to do it
17:09:00 <Cale> EvanCarroll: Only in 6.10.1 and 6.10.2 though
17:09:07 <dancor> i think ghc will probably naively run out of file descriptors or something
17:09:16 <Cale> EvanCarroll: Thankfully 6.10.3 did away with that nonsense
17:09:17 <mmorrow> heh, yeah that'd be amusing/interesting at the least to forkIO 20K threads too
17:09:58 <mmorrow> although maybe bad news if they're touching disk or doing file/socket IO
17:10:08 <dancor> ya i don't like it with touching disk
17:10:46 <dancor> @vixen do you think touching disk is going to be a problem?
17:10:47 <lambdabot> i do occassionally, i guess
17:13:47 <EvanCarroll> Cale: excellent, I'm running 6.10.1, and not having delete/home/end is a real pita =(
17:15:32 <EvanCarroll>    1. addThree :: Int -> Int -> Int -> Int
17:15:33 <EvanCarroll>    2. addThree x y z = x + y + z
17:15:47 <EvanCarroll> that doesn not work in ghci
17:15:52 <jix> is there some unsafe way to check whether an expression is already in whnf without forcing it?
17:15:55 <EvanCarroll> getting Not in scope: `addThree'
17:18:04 <EvanCarroll> hrm
17:18:22 <EvanCarroll> my ghci doesn't let me define any funcitons
17:19:12 <dancor> let f x = x + 1
17:19:20 <dancor> ghci is crazy
17:19:33 <dancor> and you must use let.  it's like you are stuck in IO
17:19:40 <dancor> do notation
17:20:01 <EvanCarroll> but ghc doesn't require the let?
17:20:03 <darkscythe> sudo /etc/rc.d/httpd restart
17:20:03 <EvanCarroll> what does let do?
17:20:14 <darkscythe> oops damn I keep typing in this thing.
17:20:16 <EvanCarroll> darkscythe: restarting httpd ...
17:20:35 <dancor> do {let f x = x + 1; print $ f 24}
17:21:41 <PeakerWork> dancor: it makes senses that in ghci you're in IO, no?
17:21:43 <Paczesiowa> is it possible to write a function list, that would work like (list 1 2 3) = 1 .*. 2 .*. 3 .*. HNil ?
17:21:55 <PeakerWork> Paczesiowa: See HList
17:21:58 <EvanCarroll> dancor: you're way above me
17:22:22 <EvanCarroll> dancor: I'm just asking what does let mean? is it implicit outside of ghci
17:22:34 <dancor> EvanCarroll: i'm just saying that the use of let in ghci is like the use of let inside a do block
17:22:35 <mmorrow> dancor: i'm thinking of something like http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4563#a4563
17:22:37 <Axman6> EvanCarroll: it's how you make definitions in GHCi
17:22:49 <Axman6> dancor: stop being confusing :P
17:22:52 <Paczesiowa> PeakerWork: anything more specific? I've read it a few times
17:23:00 <dancor> i've never been clearer!
17:23:05 <dancor> i'm not even making jokes
17:23:19 <EvanCarroll> Axman6: does it only exist in ghci
17:23:19 <EvanCarroll> danc	not sure what a do block does...
17:23:30 <dancor> mmorrow: nice
17:23:32 <EvanCarroll> dancor: I assume it is an eval block, but I don't *know* it.
17:23:43 <Axman6> EvanCarroll: no, but you'll learn about it later, when you start using IO
17:23:59 <Axman6> EvanCarroll: are you following a tutorial at the moment?
17:24:04 <PeakerWork> Paczesiowa: http://homepages.cwi.nl/~ralf/HList/
17:24:10 <LordMetroid> Do haskell have arbitrary precision floats?
17:24:16 <EvanCarroll> so tell me about let, is it specific to a do block which is what I'm executing in ghci?
17:24:21 <EvanCarroll> Axman6: yes, http://learnyouahaskell.com/types-and-typeclasses
17:24:41 <Axman6> EvanCarroll: good place to start. keep going :)
17:25:06 <PeakerWork> EvanCarroll: you might want to put your definitions in a file, and use :load filename.hs
17:25:15 <PeakerWork> :load filename would also work, I believe
17:25:25 <mmorrow> jix: there's a package on hackage called isevaluated that uses vacuum to do that
17:25:30 <Axman6> EvanCarroll: let isn't sopecific to do blocks. you can use them a lot of places, like: f x = let x' = x^214 in sqrt x
17:25:45 <Axman6> specific*
17:25:54 <jix> mmorrow: yeah found that one.. thanks
17:25:56 <Axman6> > let f x = let x'  = x^214 in sqrt x
17:25:57 <lambdabot>   not an expression: `let f x = let x'  = x^214 in sqrt x'
17:26:03 <Axman6> > let f x = let x'  = x^214 in sqrt x in f 12
17:26:04 <lambdabot>   3.4641016151377544
17:26:10 <mmorrow> jix: i don't recall if it gives you the result in IO or not though, but you could just unsafePerformIO it (since you're already breaking referential transparency ;)
17:26:15 <Axman6> > let f x = let x'  = x^214 in sqrt x' in f 12
17:26:16 <lambdabot>   2.967517762021717e115
17:26:20 <Axman6> >_>
17:26:37 <Axman6> EvanCarroll: did you start the tutorial from the beginning by the way?
17:26:39 <LordMetroid> > 0.0000000000000000000000001 + 0.0000000000000000000000001
17:26:40 <lambdabot>   2.0e-25
17:26:44 <jix> mmorrow: yeah ... i plan to use it for something similar to unamb
17:26:52 <mmorrow> jix: if you're doing this sort of thing, the vacuum package directly might be useful
17:26:55 <LordMetroid> > 0.000000000001 + 0.000000000001
17:26:57 <lambdabot>   2.0e-12
17:27:01 <mmorrow> jix: ah nice
17:27:06 <EvanCarroll> Axman6: yes.
17:27:20 <mmorrow> jix: Baughn might have something interesting to say wrt this, he was trying to do the same
17:27:28 <Axman6> EvanCarroll: righto. well stick around here, and keep asking questions. we're more than happy to help :)
17:27:38 <jix> but what i want to do won't race threads in parallel
17:27:41 <Axman6> > 0.0000000000000000000000001 + 0.00000000000000000000000001
17:27:42 <lambdabot>   1.1e-25
17:28:18 <mmorrow> jix: here's a sample use of vacuum fwiw http://www.haskell.org/pipermail/haskell-cafe/2009-October/067929.html
17:28:59 <jix> i basically have a list and item i can be computed from any item < i .... but computing i from i-1 is faster than computing i from i-2 ... but computing i from i-2 is still faster than computing i-1 from i-2 and then i from i-1
17:29:05 <mmorrow> jix: basically, to check evaluatedness you case on the closure type, and if it's THUNK* or AP, then it's not evaluated
17:29:29 <jix> and items are "processed" sequentially, potentially skipping some
17:29:36 <mmorrow> jix: hmm, interesting
17:29:54 <stroan> hackage is back up <3
17:30:25 <jix> i have no idea whether that has any real world usage... or whether there are real world problems similar to that... just a thing i was thinking about
17:31:12 <mmorrow> jix: i don't really follow the connection of that to checking evaluatedness (not to say it's not evaluated)
17:31:17 <mmorrow> heh
17:31:21 <mmorrow> s/evaluated/related/
17:31:36 <mmorrow> jix: what do you have in mind?
17:31:52 <jix> well if i-1 is evaluated compute i from that... else compute it from i-2 if that is evaluated... else from i-3....
17:32:33 <mmorrow> jix: ah, ok. so you have some way to determine the `n' in (i-n) of a computation then
17:32:41 <jix> yeah
17:33:13 <mmorrow> i see. well, that would be an interested experiment however it turns out
17:33:35 <mmorrow> if you play around with it, that'd be interesting to read about it somewhere
17:34:00 <mmorrow> like haskell-cafe or whatever
17:34:20 <Axman6> stroan: hooray!
17:34:52 <stroan> just leaving it out there, that if hackage mirrors are being put up I can host one
17:34:56 <jix> mmorrow: yeah i should become more active there
17:36:08 <jix> .. i think something similar to what i described can be of use for datastructures used in raytracing of animated scenes or in physics engines... but i don't remember what structures...
17:48:17 <mmorrow> stroan: the current bandwidth usage for hackage is somewhere around 500GB per month (although the more mirrors there are, the smaller that number would be)
17:48:37 <mmorrow> *500GB outgoing
17:48:47 <stroan> mmorrow: that'd be fine
17:48:58 <mmorrow> awesome
17:49:29 <mmorrow> what's the standard bandwidth quote for your average hosted server package?
17:49:37 <mmorrow> i can't remember what mine have
17:49:45 <stroan> last two servers I've had have had 2TB a month
17:50:00 <mmorrow> holy crap, if that's the case then i can mirror hackage too
17:51:54 <stroan> I think my current package is "unlimited" for a very narrow definition of unlimited
17:53:39 <zzzs> so I have <code> cal initial years rate = foldr (*) initial (take years $ repeat (1 + rate)) </code>
17:55:22 <zzzs> ghc's interprete this as a->int->a->a
17:56:06 <zzzs> why is that? i.e., why does rate and initial needs to be the same type?
17:56:25 <zzzs> as long as (*) and (+) works
17:57:01 <Axman6> zzzs: take x . repeat $ y = replicate x y
17:57:26 <Axman6> zzzs: also, i'm not sure i understand your question
17:57:30 <camio> > (2::Double)*(3::Int)
17:57:31 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
17:57:31 <lambdabot>         against inferred ty...
17:57:54 <Axman6> zzzs: haskell doesn't do automatic type conversion (nor should it)
17:58:43 <zzzs> Axman6, thanks for the replicate tip
17:59:11 <zzzs> Axman6, i was thinking that it would just figure out the typing based on the input
17:59:34 <Axman6> @check \x y -> take x (repeat y) == replicate x y
17:59:35 <lambdabot>   "OK, passed 500 tests."
17:59:47 <zzzs> i.e. if i input initial to be Int, and rate to be Float, it should type cal to be Float
17:59:58 <Axman6> zzzs: it did. and it has figured out that initial and rate have to be the same type
18:00:06 <Axman6> zzzs: no
18:00:15 <Axman6> zzzs: look at the type of (+):
18:00:17 <Axman6> :t (+)
18:00:18 <lambdabot> forall a. (Num a) => a -> a -> a
18:00:20 <Axman6> :t (*)
18:00:22 <lambdabot> forall a. (Num a) => a -> a -> a
18:00:41 <Axman6> so, you obviously can't multiply an Int by a Float
18:00:49 <Axman6> as camio showed earlier
18:02:57 <zzzs> ah, i see, i think i understand
18:03:02 <zzzs> thanks Axman6
18:03:49 <zzzs> so the other question is how do you convert input from string to int? is using read(s)::Int the only option?
18:04:19 <camio> zzzs: What were you thinking for another option?
18:04:48 <Axman6> zzzs: it's not the only option, but it's probably the best one for you right now
18:05:02 <Axman6> > read "123" :: Int
18:05:03 <lambdabot>   123
18:05:15 <Axman6> zzzs: are you following a tutorial by the way?
18:06:31 <zzzs> i read some of the real world haskell, any other would you recommend?
18:07:31 <Axman6> @where lyah
18:07:32 <lambdabot> www.learnyouahaskell.com
18:07:42 <Axman6> zzzs: that's a better introduction to haskell imo
18:08:15 <Axman6> once you've read what's there, you can skip some of the initial parts of RWH and get onto the more advanced stuff
18:08:54 <Axman6> (also, with RWH, i suggest you just read the chapters you're interested in. i found that reading it cover to cover was somewhat annoying, since there was a lot i wasn't interested in)
18:09:58 <zzzs> thanks for the recommendation
18:10:20 <zzzs> i tried my cal function with take.repeat vs replicate
18:10:24 <zzzs> the results are a bit different
18:11:40 <zzzs> cal 880 8 0.05 --> 1300.160790...
18:11:59 <zzzs> cal2 880 8 0.05 --> 1300.1603
18:12:07 <mightybyte> I've been playing around with HXT and learning its arrow interface, but I'm struggling to see the benefit of using arrows.  Can anyone enlighten me?
18:12:26 <zzzs> is it a bug in floating point calculation in ghc?
18:12:55 <shepheb> more like floating point being a horrible, horrible thing
18:13:21 <monochrom> arrow for hxt is like pipelining in unix shell scripting
18:13:30 <zzzs> but still, changing take.repeat to replicate shouldn't have caused different result
18:13:58 <mightybyte> monochrom: Yes, and that makes it awkward when you want to create arrows that take multiple arguments.
18:14:22 <FunctorSalad_> , length (show [$ty| $(fmaps 20) |])
18:14:25 <lunabot>  1573
18:14:58 <FunctorSalad_> oO ( make a graph of number-of-fmaps -> length of type )
18:15:27 <Axman6> @check \x y -> take x (repeat y) == replicate x (y :: Double)
18:15:28 <lambdabot>   "OK, passed 500 tests."
18:15:32 <mightybyte> monochrom: ...although it may be worse in my case since I'm not using the arrow "do" notation.
18:15:46 <Axman6> @check \x y -> sum (take x (repeat y)) == sum (replicate x (y :: Double))
18:15:47 <lambdabot>   "OK, passed 500 tests."
18:16:13 <Axman6> zzzs: it shouldn't cause any problems, that is somwehat odd
18:16:18 <Axman6> somewhat*
18:16:18 <zzzs> cal initial years rate = foldr (*) initial (replicate years (1 + rate))
18:16:19 <zzzs>  
18:16:27 <Axman6> wait, foldr?
18:16:31 <zzzs> cal2 initial years rate = foldr (*) initial (take years $ repeat (1 + rate))
18:16:31 <zzzs>  
18:16:35 <Axman6> any reason you're not using foldl?
18:16:53 <zzzs> any difference in this case?
18:16:59 <Axman6> there shouldn't be
18:17:10 <dibblego> runs in constant space
18:17:29 <Axman6> zzzs: mind changing that to foldl? it seems like it should be a left fold to me (more efficient)
18:17:49 <Lemmih> zzzs: I get the same answer with both functions.
18:18:17 <Lemmih> zzzs: You most likely messed up the types, using Double one place and Float another.
18:18:24 <Axman6> zzzs: are you using Float or Double by the way?
18:18:35 <zzzs> Axman6, foldl doesn't make any difference
18:18:46 <Axman6> zzzs: it does in how it's computed
18:18:58 <zzzs> cal 880 8 0.05
18:19:04 <Axman6> > foldl (+) z (replicate 4 x)
18:19:05 <lambdabot>   z + x + x + x + x
18:19:09 <Axman6> > foldr (+) z (replicate 4 x)
18:19:10 <lambdabot>   x + (x + (x + (x + z)))
18:19:13 <Lemmih> zzzs: Using Float the answer is '1300.1603'. With Double it is '1300.1607905343756'.
18:20:51 <Axman6> zzzs: anyway, trust me, foldl is likely to be more efficient
18:20:57 <monochrom> mightybyte: The proc->do notation is indispensible if your dataflow is more interesting than linear.
18:21:03 <zzzs> I had declared cal to be using float, and cal2's type is inferred by ghc, so i guess it must have decided to type it as double
18:21:13 <zzzs> Axman6, i understand
18:21:32 <zzzs> is it generally recommend to use foldl?
18:21:41 <mightybyte> monochrom: Ok, that may be my problem.
18:21:47 <Axman6> ghc defaults to Double for floating point numbers, and Integer for integral ones
18:21:54 <c_wraith> if it's an efficiency thing, and you're working with strict types, foldl' is better yet.
18:22:34 <Axman6> zzzs: it very much depends on that you're doing. they can be equivalent functions, but they do serve different purposes
18:22:52 <Axman6> > foldl (:) [] [1..10]
18:22:53 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
18:23:00 <Axman6> > foldl (flip (:)) [] [1..10]
18:23:02 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
18:23:07 <c_wraith> foldr is better for lazy data types
18:23:07 <Axman6> > foldr (flip (:)) [] [1..10]
18:23:08 <lambdabot>   Occurs check: cannot construct the infinite type: b = [b]
18:23:12 <mightybyte> monochrom: I'm working on building a library on top of HXT, and my other worry is that if I use HXT and therefore force my users to use it, users might be scared away by the arrows.
18:23:13 <Axman6> > foldr ((:)) [] [1..10]
18:23:14 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
18:23:45 <c_wraith> But the fact is, for non-associative operations, foldl and foldr have different results.
18:24:05 <Cale> So, hackage is back up, what happened?
18:24:14 <c_wraith> apparently raid errors on monk
18:24:14 <Axman6> monday happened!
18:24:25 <c_wraith> and galois is looking to replace the machine soon.
18:24:28 <Axman6> > foldl f z [a,b,c]
18:24:29 <lambdabot>   Ambiguous occurrence `f'
18:24:30 <lambdabot>  It could refer to either `L.f', defined at <local...
18:24:40 <Axman6> > foldl L.f z [a,b,c]
18:24:41 <lambdabot>   Couldn't match expected type `b -> [t]' against inferred type `[t]'
18:24:44 <Axman6> bah
18:24:47 <Axman6> @undefine
18:24:54 <Axman6> > foldl f z [a,b,c]
18:24:55 <lambdabot>   f (f (f z a) b) c
18:24:59 <Axman6> > foldr f z [a,b,c]
18:25:01 <lambdabot>   f a (f b (f c z))
18:25:06 <Axman6> zzzs: ^^^^^^^^^^^^^^^
18:25:27 <zzzs> thanks Axman6, and c_wraith, i need to digest this a bit :)
18:25:44 <Cale> EvanCarroll: by the way, the way you're generally expected to use ghci is to keep your text editor open in another window. Put all your definitions in a file and test them in ghci. Whenever you update the file, :r from ghci will reload it.
18:26:56 <Axman6> zzzs: with foldr f z, all :'s are replaced with `f`, and the [] is replaced with z. foldl is more often used when you need a function with an accumulating parameter
18:30:12 <roconnor> > realToFrac 0.3 :: CReal
18:30:13 <lambdabot>   0.2999999999999999888977697537484345957637
18:31:01 <roconnor> > (realToFrac 0.3 :: CReal)*10^20
18:31:02 <lambdabot>   29999999999999998889.7769753748434595763683319091796875
18:31:14 <roconnor> > (realToFrac 0.3 :: CReal)*10^30
18:31:15 <lambdabot>   299999999999999988897769753748.434595763683319091796875
18:31:40 <roconnor> ah right
18:31:43 <roconnor> 2 divides 10
18:32:56 <Axman6> > realToFrac (0.3 :: CReal) :: CReal
18:32:57 <lambdabot>   * Exception: CReal.toRational
18:33:02 <Axman6> -_-
18:33:27 <roconnor> CReal really ought not to be a member of that class.
18:34:03 <roconnor> but I think there are some unreasonable type constraints in some functions that make that happen, ... or some reason like that.
18:35:25 <ACSpike[Home]> I'm not very familiar with emacs keybindings. can I make the home, end and delete keys work in ghci?
18:35:47 <Cale> ACSpike[Home]: Do they not just work?
18:35:54 <Cale> ACSpike[Home]: Which version of ghci is it?
18:36:10 <ACSpike[Home]> Sorry, no. They don't do what I want.
18:36:31 <ACSpike[Home]> delete gives 3~
18:36:41 <Cale> Is it 6.10.1 or 6.10.2? If so, just replace it.
18:36:56 <juhp> who votes for #hackage ? :-)
18:37:16 <ACSpike[Home]> home = H, end = F, version 6.10.4
18:37:34 <Cale> ACSpike[Home]: hmm, strange. What platform is this on?
18:37:35 * Axman6 votes for #haskage
18:37:41 <Axman6> #hackage*
18:37:45 <ACSpike[Home]> Cale: ubuntu 9.10
18:38:50 <ACSpike[Home]> Cale: maybe its just me. I get something similar with vi in putty at work.
18:42:53 <dancor> i don't know, #hackage would probably just go down a lot D;
18:44:09 <davidL> ACSpike[Home]: that's a problem with putty, not ghci
18:46:50 <dons> ?yow
18:46:50 <lambdabot> Couldn't find fortune file
18:48:18 <ACSpike[Home]> davidL: sorry, this is not a problem with putty. I'm on an ubuntu desktop. I was just saying I have a similar problem at work.
18:48:48 <davidL> ACSpike[Home]: what terminal are you using?
18:49:20 <ACSpike[Home]> davidL: Gnome Terminal 2.28.1
18:58:17 <elias_vc> hello?
18:58:56 <blackh1> elias_vc: Hello!
18:59:35 <elias_vc> Hi! I'm a haskell newbie
18:59:44 <absentia> <-- me too
18:59:46 <elias_vc> I have a question
18:59:53 <blackh1> elias_vc: Great! Ask away.
19:00:41 <elias_vc> I get "parse error on input '='" when I type something like:
19:00:44 <elias_vc> slice (a,b) xs = reversed
19:00:44 <elias_vc> 	where chopped 	= drop a xs
19:00:44 <elias_vc> 		  reversed = reverse chopped
19:01:04 <wdonnelly> are you using tabs for alignment?
19:01:11 <elias_vc> indeed
19:01:19 <wdonnelly> there's your problem
19:01:20 <Cale> elias_vc: Yeah, make sure there are no tabs in your source files
19:01:34 <Cale> elias_vc: and line up the left hand columns of the definitions inside the 'where'
19:02:03 <Cale> elias_vc: any decent text editor will have an option to replace tabs with spaces automatically
19:02:16 <juhp> join us on #hackage if you care to
19:02:24 <elias_vc> ooh now I get it
19:02:34 <elias_vc> thank you very much guys
19:03:20 <blackh1> elias_vc: Welcome to Haskell land
19:04:15 <Cale> Yeah, don't be afraid to ask questions, beginners are welcome here :)
19:04:32 <absentia> is there 64bit osx yet?
19:04:37 <absentia> (haskell support)
19:04:45 <elias_vc> Oh thank you for the warm welcome
19:04:47 <ACSpike[Home]> I tried `bind: "\ESC[3~" Delete` in ~/haskeline (didn't work)
19:05:24 <elias_vc> I'm learning haskell because of a programming languages class
19:05:40 <elias_vc> and I think is kind of cool
19:05:48 <Axman6> kind of? bah
19:06:53 <Axman6> absentia: nope :(
19:07:00 <SamB_XP_> Axman6: hey, give a newb some time!
19:07:04 <Axman6> :P
19:07:24 * Axman6 thinks that lots of people should come and join #hackage
19:08:07 <byorgey> why, what's on #hackage?
19:08:15 <Axman6> anything you want there to be
19:08:48 <Cale> It's kind of like #zombo.com then
19:08:48 <byorgey> elias_vc: where is the class and who is teaching it?
19:08:49 <Axman6> seems that #haskell isn't really the place to ask about hackage problems (be them the server, or making hackage packages)
19:08:50 <byorgey> just curious
19:09:24 <elias_vc> Utah State University, Curtis Dyreson
19:12:13 <Cale> Hey, interesting, I can electronically submit assignments for the people in your clas ;)
19:12:32 <Cale> class*
19:13:19 <Axman6> ha
19:13:23 <elias_vc> lol
19:13:25 <elias_vc> yeah
19:13:54 <elias_vc> his system is not very secure
19:14:28 <elias_vc> as in no security whatsoever
19:14:53 <absentia> most cs students.. as their first "unoffocial" assignment.. hack the homework submission system.
19:15:29 <SamB_XP_> hmm, yeah, I've heard talk of that sort of thing before ...
19:15:48 <sbok> That sounds ripe for an honor code violation
19:15:50 <SamB_XP_> actually, I think they usually do that as a class project ?
19:15:57 <absentia> for me, we had to have the prnter header.. time/date stamp on the printout.. and we could slid our assignments under the prof's office door.  first thing we did was copy the header format.. so we could print out anything we wanted.
19:16:38 <Axman6> blackdog: #hackage! gogogo! >_>
19:16:44 <SamB_XP_> well, it would totally make sense for a security class ;-P
19:17:27 <absentia> the internet worm hit 2 months after I became root at the uni for the first time... (studen admin) ..  we WANTED the worm to hit us.  we left messages for it, and waited..  but nada.
19:17:43 <Axman6> :(
19:20:53 <Apocalisp> Strict languages suck.
19:21:13 <Apocalisp> That is all.
19:21:14 <Axman6> sometimes
19:21:25 <ACSpike[Home]> Cale, davidL: `keyseq: "\ESC[3~" delete` in ~/.haskeline fixed it
19:26:31 <davidL> ACSpike[Home]: good to hear
19:29:27 <dons> i don't languages forcing me into an evaluation straategy
19:29:48 <absentia> such as?
19:30:08 <dons> s/want//
19:30:32 <absentia> xn/last 19
19:30:50 <EvanCarroll> why doesn't tihs work take 2 reverse [2,1,0]
19:31:09 <wdonnelly> > take 2 . reverse $ [2,1,0]
19:31:10 <lambdabot>   [0,1]
19:31:17 <Axman6> because you're applying take 2 to reverse
19:31:25 <absentia> :-)
19:31:29 <Axman6> which is a function, not a list
19:31:43 <Axman6> it's like asking what the length of (+) is
19:31:48 <Axman6> > length (+)
19:31:49 <lambdabot>   Couldn't match expected type `[a]'
19:31:49 <lambdabot>         against inferred type `a1 -> a1 ...
19:32:01 <EvanCarroll> how do i hrm I don't know what # i$ is yet.
19:32:13 <Axman6> @src ($)
19:32:14 <lambdabot> f $ x = f x
19:32:22 <hexpuem> are those ghc plugins like that strict-mode-haskell one that was in some zine a few billion years ago
19:32:41 <absentia> @src ($ . $)
19:32:42 <lambdabot> Source not found. stty: unknown mode: doofus
19:32:42 <Axman6> EvanCarroll: anyway, what you want to do, for now at least, is use brackets: take 4 (reverse [2,1,0])
19:34:49 <camio> Anyone know of a haskell tutorial out there that introduces functions with lambda syntax instead of pattern syntax? (f = \a ->... vs. f a = ...)
19:36:00 <hexpuem> whats the reason?
19:36:11 <augur> i just stumbled across the Omega monad. sexiness.
19:36:12 <augur> that is all.
19:36:30 <absentia> eh?
19:36:36 <Elly> Omega monad?
19:36:37 <camio> I'm looking to teach an employee haskell and I'd really like to teach him the core of the language first and then those little syntax sugars.
19:36:41 <SamB_XP_> is that the monad that never ends ?
19:36:53 <SamB_XP_> ... it just goes on and on, my friends ...
19:37:05 <SamB_XP_> some people started binding it not knowing where it goes ...
19:37:25 <SamB_XP_> ...  and they'll continue binding it forever just because ...
19:37:25 <augur> the omega monad is sort of like the list monad
19:37:27 <augur> only
19:37:50 <augur> its a diagonalized version
19:38:00 <augur> so like, the example given on the site for it is
19:38:54 <augur> if you do something like [ (x,y) : x <- [0..], y <- [0..] ]
19:39:12 <augur> you never get the pair (1,0)
19:39:17 <augur> not in any finite amount of time, anyway
19:39:34 <augur> because you first have to enumerate all (x,y) where x = 0, from y = 0 to infinity
19:40:20 <hexpuem> what are you using it for
19:40:23 <augur> and so despite the fact that the set is countably infinite, and thus each element should be reachable in a finite amount of time
19:40:28 <augur> you cant do that with the list monad
19:40:44 <Axman6> http://www.reddit.com/r/haskell/comments/a0dbw/announcement_hackage_a_new_as_yet_unofficial_irc/ if anyone's interested
19:40:44 <augur> because you enumerate /all/ the (0,y)'s first, then all the (1,y)'s, then ...
19:41:12 <augur> hexpuem: im not using it for anything. i just happened across the omega monad, which is cool
19:41:30 <hexpuem> yea im just having trouble thinking of what i would use it for haha
19:41:34 <Axman6> augur: got a link to it?
19:41:34 <augur> because it makes it possible to enumerate the same set of elements in such a way that every element is infact reachable in finite time
19:41:49 <augur> http://hackage.haskell.org/packages/archive/control-monad-omega/0.2/doc/html/Control-Monad-Omega.html
19:41:50 <ivanm> preflex: seen roconnor
19:41:50 <preflex>  roconnor was last seen on #haskell 1 hour, 7 minutes and 47 seconds ago, saying: but I think there are some unreasonable type constraints in some functions that make that happen, ... or some reason like that.
19:41:53 <ivanm> hey Axman6
19:41:57 <BMeph> you can't do that /naively/ with the list monad, anyhow. :)
19:42:09 <augur> BMeph true :p
19:42:14 <Axman6> ivanm: o/ join #hackage! gogogo! :P
19:42:24 <ivanm> we have a separate channel for hackage now?
19:42:27 <ivanm> do I dare ask why?
19:42:28 <hexpuem> whats the purpose of #hackage?
19:42:31 <augur> the example i saw originally was using the Omega monad to enumerate all the possible sentences of some CFG
19:42:42 <patch-tag> I'm getting negged by hackage when I attempt to upload FileManipCompat (find file for windows basically) because "The dependency 'build-depends: base' does not specify an upper bound on the version number." cabal file is http://patch-tag.com/r/tphyahoo/FileManipCompat/snapshot/current/content/pretty/FileManipCompat.cabal
19:42:47 <patch-tag> any idea what I'm doing wrong?
19:42:54 <EvanCarroll> can someone describe what the . and $ do in take 2 . reverse $ [2,1,0]
19:43:00 <hexpuem> what does this look like? #hackage?
19:43:01 <augur> which leeds to similar problems as enumerating (x,y) for x,y in N
19:43:03 <hexpuem> harhar
19:43:04 <Axman6> hexpuem: so people can have a place where they can ask hackage and cabal questions without filling up #haskell
19:43:13 <augur> at least in many cases
19:43:21 <EvanCarroll> . joins functions and $ seperates argument lists?
19:43:26 <patch-tag> Evan: this is the same as take 2 $ reverse [2,1,0]
19:43:49 <kmc> :t (.)
19:43:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:43:50 <augur> http://lukepalmer.wordpress.com/2008/05/02/enumerating-a-context-free-language/
19:43:51 <kmc> :t ($)
19:43:52 <lambdabot> forall a b. (a -> b) -> a -> b
19:43:55 <patch-tag> Evan: . is just the infix version of (.)
19:43:56 <kmc> @src (.)
19:43:56 <lambdabot> (f . g) x = f (g x)
19:43:57 <kmc> @src ($)
19:43:58 <lambdabot> f $ x = f x
19:44:03 <ivanm> patch-tag: you have < 5 or something?
19:44:07 <Axman6> EvanCarroll: . is function composition, and $ is just there to stop you having to use lots of brackets: (f . g . h) x == f . g . h $ x
19:44:19 <ivanm> patch-tag: hackage now needs upper bounds on base
19:44:22 <patch-tag> yeah, it's in there
19:44:30 <ivanm> patch-tag: nope, it isn't...
19:44:34 <ivanm> you just say "base"
19:44:40 <patch-tag> wait... wat?
19:44:50 <BMeph>   Build-Depends: base, bytestring, directory, filepath, mtl, unix-compat
19:44:50 <BMeph>   else
19:44:50 <BMeph>     Build-Depends: base, filepath, mtl, unix-compat
19:45:09 <ivanm> patch-tag: any particular reason for supporing base < 3 ?
19:45:11 <patch-tag> I was editing the wrong cabal fle
19:45:15 <EvanCarroll> Axman6: nifty
19:45:17 <BMeph> patch-tag: There are NO upper limits on any of those packages... :\
19:45:21 <ivanm> patch-tag: heh
19:45:42 <patch-tag> Evan: there's nothing magical about . or $, they are both functions, and the non-infix version is (.) and ($)
19:45:43 <ivanm> @ask roconnor you've lost me... which bug did I apparently find?
19:45:43 <lambdabot> Consider it noted.
19:45:49 <patch-tag> so you could rewrite using them
19:45:56 <EvanCarroll> how come take 2 . reverse $ [2,1,0] and take 2 $ reverse [2,1,0]
19:45:59 <SamB_XP_> ivanm: you mean there was base < 3 ?
19:46:06 <Axman6> EvanCarroll: what i showed you is basically how you always use ($)
19:46:09 <ivanm> SamB_XP_: 6.6 had base-2 IIRC
19:46:12 <SamB_XP_> I thought base 3 was the first revision!
19:46:16 <kmc> (take 2 . reverse) [2,1,0]
19:46:19 <ivanm> SamB_XP_: that's what all the split base stuff was about
19:46:22 <kmc> take 2 (reverse [2,1,0])
19:46:25 <Axman6> EvanCarroll: both are fine, but the first one is preferred
19:46:28 <kmc> :t take 2 . reverse
19:46:29 <lambdabot> forall a. [a] -> [a]
19:46:36 <patch-tag> (.) (take 2) reverse $ [2,1,0]
19:46:40 <patch-tag> > (.) (take 2) reverse $ [2,1,0]
19:46:41 <lambdabot>   [0,1]
19:46:44 <kmc> > let { f = take 2 . reverse } in f [1..10]
19:46:45 <lambdabot>   [10,9]
19:46:58 <BMeph> Huh, that's a nice way to sum up the similarities/differences between (.) and ($)... :)
19:47:20 <patch-tag> > ($) ( (.) (take 2) reverse ) [2,1,0]
19:47:30 <Axman6> oi, guys, quit confusing the newbie
19:47:31 <sproingie> yeah that's readable
19:47:34 <Axman6> seriously
19:47:44 <lambdabot>   [0,1]
19:47:44 <BMeph> ($) is (.) with the Identity Functor! ;)
19:47:46 <patch-tag> > ( (.) (take 2) reverse ) [2,1,0]
19:47:47 <lambdabot>   [0,1]
19:48:05 * Axman6 hates it when people do that, it makes being a newbie extremely hard
19:48:13 <sproingie> . and $ do different things but sometimes give you the same result, so sometimes it's a matter of style
19:48:25 <patch-tag> sproingie: now that's confusing :)
19:48:38 <wdonnelly> the important thing about the difference between $ and .
19:48:55 <SamB_XP_> patch-tag: your nick sounds familiar ... where have I heard it before ?
19:48:55 <kmc> EvanCarroll:  f . g . h $ x    is    (f . g . h) x
19:48:57 <patch-tag> how about this, think about how you read it: f . g . h . k $ something
19:49:02 <wdonnelly> is if you have a very long sequence of functions, like f . g . h . i . j . k . l $ m
19:49:06 <patch-tag> you "read it" from right to left
19:49:08 <kmc> EvanCarroll: f $ g $ h $ x    is    f (g (h x))
19:49:11 <hexpuem> just use $ in the rightmost part of an expression: d . c . b . a $ 9
19:49:19 <wdonnelly> you can pull out any subsequence into a 'let' or 'where' clause
19:49:19 <patch-tag> first you apply k, then h, then g, then f
19:49:29 <hexpuem> its like a unix pipeline but backwards
19:49:36 <hexpuem> or monad do notation backwards
19:49:52 <wdonnelly> like 'let foo = h . i . j . k in f . g . foo . l $ m'
19:50:05 <patch-tag> evan: exactly,  f( g ( h x) )
19:50:19 <Axman6> EvanCarroll: do you know about unix pipes?
19:50:21 <patch-tag> I don't know if you would read that from right to left or left to write but whatever, it's the same damn thing
19:50:30 * BMeph mentally translates (.) as "after" and ($) as "of"
19:51:02 * Axman6 usually translates (.) to 'of', but probably shouldn't
19:51:15 <hexpuem> i like to think of it as a breast
19:51:32 <sproingie> (.)$(.)
19:51:33 <patch-tag> hexpuem: (.) (.)
19:51:46 <SamB_XP_> (.).(.)
19:51:51 <BMeph> hexpuem: Please, the "proper" term is "boob". ;p
19:51:56 <hexpuem> haha
19:51:57 <sproingie> (.)(.)(.)
19:52:01 <hexpuem> total recall
19:52:10 <sproingie> hhgtg
19:52:11 <SamB_XP_> sproingie: that's the hitchhiker boobs ?
19:52:12 <EvanCarroll> Axman6: yes
19:52:19 <BMeph> Hitchhiker's Guide to a Good Time? ;)
19:52:32 <Axman6> EvanCarroll: well, (.) is like |, but backwards
19:52:37 <SamB_XP_> what's the name of that planet again ?
19:52:41 <absentia> Douglas Adams was a user of mine once.  :-)
19:52:42 <wdonnelly> meditating on the type of the (.).(.) operator can teach you a lot about how haskell's types work
19:52:46 <BMeph> Eroticon 6
19:52:53 <absentia> I introduced him to alt.fan.d.a
19:53:04 <Axman6> so, if you had functions cat and echo, in unix you'd write cat foo | echo, and in haskell, you'd write echo . cat $ foo
19:53:07 <absentia> marsboobs?
19:53:08 <BMeph> SamB_XP_: As in "The triple-breasted whore of..." :)
19:53:16 <SamB_XP_> BMeph: no duh
19:53:17 <sproingie> but what was her name?
19:53:28 <SamB_XP_> I didn't think she HAD a name!
19:53:31 <SamB_XP_> I forget
19:53:37 <EvanCarroll> doesn't f.g.h $ x, execute f(g(h(x))) still though?
19:53:45 <wdonnelly> sproingie: Eccentrica Gallumbits, IIRC
19:53:45 <ivanm> is this "Shelby Moore" person that's just joined -cafe a bot or something?
19:53:46 <SamB_XP_> EvanCarroll: yeah
19:53:46 <Axman6> EvanCarroll: yep
19:53:49 <hexpuem> @src ($)
19:53:50 <lambdabot> f $ x = f x
19:53:52 <sproingie> ah yes
19:54:03 <SamB_XP_> ivanm: could be!
19:54:03 <absentia> @arc ($ . $ . $)
19:54:04 <lambdabot> Maybe you meant: arr rc src
19:54:05 <ivanm> she keeps replying to herself, and none of the responses actually make sense...
19:54:11 <absentia> @arc ($ . $)
19:54:11 <lambdabot> Maybe you meant: arr rc src
19:54:23 <sproingie> how many haskell channels are there?
19:54:25 <absentia> @src ($ . $)
19:54:25 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
19:54:36 <ivanm> sproingie: a lot
19:54:43 <EvanCarroll> Axman6: so there is no difference?
19:54:51 <kmc> EvanCarroll, in haskell we'd almost never write h(x)
19:54:51 <sproingie> i like how the bottom symbol looks like a bottom if you put it in parens
19:54:54 <kmc> the parentheses there do nothing
19:54:56 * hackagebot upload: FileManipCompat 0.14 - Expressive file and directory manipulation for Haskell. (ThomasHartman)
19:54:57 <sproingie> (_|_)
19:55:04 <EvanCarroll> the composition bit is just sugar
19:55:09 <Axman6> EvanCarroll: no difference to what?
19:55:15 <Axman6> EvanCarroll: yeah
19:55:29 <Axman6> EvanCarroll: composition is a pretty big part of haskell though
19:55:35 <SamB_XP_> EvanCarroll: it's not *just* sugar
19:55:41 <Berengal> Well, composition is in some way sugar, but in other ways not. You can't fold sugar, usually...
19:55:51 <SamB_XP_> it's just if you then immediately apply it that it's sugar
19:55:51 <Axman6> @src (.)
19:55:52 <lambdabot> (f . g) x = f (g x)
19:55:52 <Berengal> (But you can fold using composition)
19:55:55 <sproingie> well technically it's all sugar over lambda calculus or sk combinators
19:55:58 <dibblego> EvanCarroll, f . g $ x is preferred to f $ g $ x
19:56:13 <ivanm> SamB_XP_: know, if only we had ops on the mailing list level... ;-)
19:56:21 * Axman6 used to write f $ g $ h $ x a lot -_-
19:56:28 <hexpuem> yea thats what i did at first too
19:56:30 <SamB_XP_> ivanm: JaffaCake is an op
19:56:32 <SamB_XP_> I believe
19:56:35 <kmc> me too
19:56:42 <SamB_XP_> at the @ level
19:56:53 <Berengal> (f . g) x vs f . g $ x?
19:56:58 * BMeph used to Hate Axman6 a lot, too... >:(
19:57:10 <ivanm> BMeph: why?
19:57:15 <Axman6> ... :o
19:57:16 <Axman6> :(
19:57:19 <Axman6> :'(
19:57:24 <ivanm> Berengal: latter
19:57:28 <ivanm> or even f $ g x
19:57:36 <ivanm> well, that's what I do...
19:57:49 * BMeph got over it, though, once he realized Axman6 is an Aussie, though, so... "no worries"! ;)
19:57:52 <Berengal> ivanm, f $ g $ h x even?
19:57:59 <Axman6> >_<
19:58:03 <Axman6> i/m so confused now
19:58:06 <Axman6> '*
19:58:16 <ivanm> BMeph: heh
19:58:20 <BMeph> Axman6: I win, then? ;)
19:58:53 <jre2> @pl f x y = -(+4 y)
19:58:53 <lambdabot> (line 1, column 7):
19:58:53 <lambdabot> unexpected "="
19:58:53 <lambdabot> expecting variable, "(", operator or end of input
19:59:02 * hackagebot upload: HStringTemplateHelpers 0.0.14 - Convenience functions and instances for HStringTemplate (ThomasHartman)
19:59:10 <andun> Berengal: I would write f (g x) in that case
19:59:21 <jre2> @pl f x y = -(4+y)
19:59:22 <lambdabot> (line 1, column 7):
19:59:22 <lambdabot> unexpected "="
19:59:22 <lambdabot> expecting variable, "(", operator or end of input
19:59:32 <EvanCarroll> dibblego: fair enough, what is the advantage of ever doing f $ g $ x
19:59:42 <dibblego> EvanCarroll, nothing
20:00:03 * hackagebot upload: happstack-helpers 0.42 - Convenience functions for Happstack. (ThomasHartman)
20:00:52 <Axman6> EvanCarroll: when you're new, you'll often find that f $ g $ h fixed problems (but that's just because you don't understand the problem yet :))
20:01:22 <Berengal> > fix error
20:01:24 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
20:01:34 <SamB_XP_> Berengal: nope, still errors!
20:01:41 <Berengal> :(
20:01:42 <EvanCarroll> Axman6: that sounds vague, why would i think that?
20:02:28 <Axman6> EvanCarroll: well, i'm just talking from experience. i often found that when i was trying to use (.) as a newbie, i often got it wrong, but using $ worked
20:02:36 <hexpuem> yea haha
20:02:50 <kmc> Berengal, haha
20:02:52 <Axman6> EvanCarroll: but, they're semantically different things
20:05:46 <EvanCarroll> explain, the symantics result in the same evaluation, f.g.h is composed by doing f(g(h()))?
20:06:09 <kmc> EvanCarroll, function application is not written f(x) in Haskell
20:06:22 <kmc> in particular "h()" is something probably different from what you want
20:06:24 <hexpuem> composition is more when you want to combine two functions without having knowing the input yet
20:06:28 <hexpuem> like x = a . b
20:06:32 <hexpuem> then later x 1
20:06:40 <kmc> ((f . g . h) x)  is f (g (h x))
20:06:54 <kmc> :t let h() = 3 in h
20:06:55 <lambdabot> forall t. (Num t) => () -> t
20:07:30 <kmc> EvanCarroll, () is the empty tuple value.  it's almost never useful to pass it to a function
20:07:41 <sproingie> aka "unit"
20:07:54 <kmc> since Haskell is lazy, there's no need to make functions with trivial arguments just to delay evaluation
20:08:17 <kmc> and a thing which has side effects but takes no arguments is not a function at all
20:10:30 <kmc> also it's "semantics"
20:12:17 <sproingie> i always have fun talking about latent semantic indexing to co-workers (at symantec)
20:12:29 <sproingie> they keep mis-hearing the second word
20:12:45 <hexpuem> lol
20:12:57 <EvanCarroll> how would you declare a type signature and function in ghci
20:13:13 <EvanCarroll> I can declare a function without a type signature
20:13:25 <EvanCarroll> is the signature implied, and just explicit in this tutorial?
20:13:27 <sproingie> > let mult a b :: Int -> Int -> Int = a * b in mult 2 3
20:13:28 <lambdabot>   <no location info>: Parse error in pattern
20:13:32 <sproingie> meh
20:14:05 <kmc> EvanCarroll, typically you wouldn't declare sigs in GHCi, unless it's necessary
20:14:09 * hackagebot upload: happstack-helpers 0.43 - Convenience functions for Happstack. (ThomasHartman)
20:14:10 <kmc> but you can
20:14:24 <EvanCarroll> how?
20:14:25 <kmc> > let f :: Int -> Int -> Int; f = (+) in f 2 3
20:14:26 <lambdabot>   5
20:14:32 <EvanCarroll> ah
20:14:33 <EvanCarroll> semicolon
20:14:44 <EvanCarroll> you know this tutorial would be a /ton/ better if it just covered some of this stuff
20:14:46 <sproingie> you pretty much don't do it in ghci tho
20:14:53 <Axman6> EvanCarroll: which tutorial?
20:14:56 <sproingie> what tutorial are you following telling you to do signatures in ghci?
20:14:59 <EvanCarroll> http://learnyouahaskell.com/syntax-in-functions
20:15:03 <Axman6> hmm
20:15:06 <BMeph> I want a function that evaluates and removes viruses. Doesn't that have "symantics"? ;p
20:15:10 <kmc> EvanCarroll, Haskell's whitespace-sensitive layout is just sugar on top of syntax which uses explicit braces and semicolons
20:15:14 <EvanCarroll> it doesn't say ghci, but the early examples use ghci and we never transitioned off of it in the tutorial
20:15:18 <sproingie> i think lyah wants you to use source files at that point, not ghci
20:15:37 <roconnor> ivanm: the spelling error in readColourName
20:15:37 <EvanCarroll> he should be explicit, I missed that ;(
20:15:37 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
20:15:45 <Axman6> EvanCarroll: well, be sure to tell BONUS next time you see him on here
20:15:56 <ivanm> roconnor: ahh, right...
20:15:58 <EvanCarroll> it is still a /great/ tutorial
20:16:01 <ivanm> I was reading the source ;-)
20:16:24 <EvanCarroll> I would love a list of all of the CORE functions of ghci, and a brief description
20:16:26 <roconnor> ivanm: okay.  I have a patch in the works to turn the result type from (m a) to (Maybe a)
20:16:30 <Axman6> EvanCarroll: BONUS is always after suggestions though :)
20:16:35 <sproingie> lyah is pretty darn nice.  i learned from the gentle tutorial, i was scared off for years :p
20:16:42 <EvanCarroll> I don't want to debate the meaning of what I'm asking for, I'm sure I'm not using the right term "CORE functions" but I think you know what I'm looking for
20:16:46 <ivanm> roconnor: you're ignoring arbitrary monads?
20:16:51 <ivanm> due to fail not being reliable?
20:16:53 <andun> EvanCarroll: you are looking for the Prelude
20:17:06 <andun> EvanCarroll: http://www.cs.mu.oz.au/172/Haskell/tourofprelude.html
20:17:08 <ivanm> Axman6: well, he didn't like mine...
20:17:09 <ivanm> ;-)
20:17:10 <roconnor> ivanm: there is a lot of debate on the Maybe a vs m a issue.
20:17:17 <ivanm> roconnor: yeah
20:17:18 <roconnor> ivanm: I was swayed
20:17:21 <ivanm> heh
20:17:22 <Axman6> ivanm: yeah, but your suggestions suck :P
20:17:26 <ivanm> Axman6: :o
20:17:29 <Axman6> :P
20:17:38 <ivanm> my suggestion was to be grammatically correct! :p
20:17:51 <Axman6> lol
20:17:55 <roconnor> ivanm: I will keep the fail in the code
20:17:56 <EvanCarroll> andun++
20:17:58 <Axman6> yeah, crappy suggestion!
20:17:58 <EvanCarroll> andun: exactl
20:18:04 <roconnor> ivanm: I'll just change the type :)
20:18:18 <ivanm> roconnor: well, the fail message is then useless...
20:18:28 <roconnor> ivanm: true
20:18:45 <ivanm> roconnor: unless you use that ErrorMonad class or whatever it is that is supposed to let fail = error ...
20:18:56 <ivanm> Axman6: I beg to differ
20:18:57 <roconnor> ivanm: it does make for documentation.
20:19:02 <ivanm> true
20:19:32 <BMeph> @remember roconnor ivanm: I will keep the fail in the code
20:19:32 <lambdabot> Done.
20:19:47 <ivanm> BMeph: heh
20:19:49 <BMeph> Mis-qutoed for "the lulz"
20:20:04 <roconnor> :D
20:20:11 <ivanm> BMeph: mis-spelt for "the lulz" as well? :p
20:20:31 <ivanm> well, I suppose I'm going to be mentioned in the next HWN even if I don't make a release this week...
20:20:35 <BMeph> Darn it, that should be "teh lulz", sorry for the misspelling... ;p
20:20:43 <Axman6> so, who here uses hackage?
20:20:49 <sproingie> everyone
20:20:59 <BMeph> ivanm: ;)
20:21:05 <Axman6> well! everyone should join #hackage then :P
20:21:11 <sproingie> if you use cabal install you use hackage
20:21:16 <ivanm> BMeph: heh...
20:21:27 <ivanm> BMeph: but not the spelling problem I was alluding to...
20:21:35 <ivanm> Axman6: you still haven't said _why_ we'd want to...
20:21:36 <EvanCarroll> is there anyway to define a unicode function in haskell?
20:21:37 <BMeph> Axman6: Better to ask, "Who here (presumably besides you) doesn't use hackage?" :)
20:21:53 <dons> EvanCarroll: a unicode function?
20:21:59 <dons> you mean, one whose name is a unicode character?
20:22:06 <dons> --> if so, yes, that's perfectly legit.
20:22:21 <Axman6> > let () = (+) in 1  2
20:22:22 <lambdabot>   <no location info>: lexical error at character '\63743'
20:22:25 <Axman6> :(
20:22:27 <EvanCarroll> I'm using -XUnicodeSyntax
20:22:34 <dons> see e.g. http://hackage.haskell.org/packages/archive/unicode-prelude/0.1.1/doc/html/Prelude-Unicode.html#2
20:22:35 <Axman6> > let (å) = (+) in 1 å 2
20:22:36 <lambdabot>   Ambiguous type variable `a' in the constraint:
20:22:36 <lambdabot>    `GHC.Num.Num a'
20:22:36 <lambdabot>      aris...
20:22:37 <BMeph> Axman6: ...unless that isn't what you meant, which I now suspect not. :)
20:22:40 <EvanCarroll> but i can't do `let ¬ = "Not"`
20:22:51 <dons> (¬)
20:22:52 <kmc> EvanCarroll, you can in Agda :)
20:22:53 <SamB_XP_> > map ord "å"
20:22:54 <hexpuem> in source code you can, maybe ghci is wierd
20:22:54 <lambdabot>   [229]
20:22:55 <sproingie>  and å are word characters
20:22:58 <EvanCarroll> ah you need parens
20:23:00 <EvanCarroll> then it works
20:23:09 <dons> that's a varsym
20:23:13 <blackdog> Axman6: did you know it was melbourne cup day? i think i just managed to disqualify myself as an australian...
20:23:16 <dons> inspect http://hackage.haskell.org/packages/archive/unicode-prelude/0.1.1/doc/html/src/Prelude-Unicode.html#%AC
20:23:20 <dons> blackdog: me too
20:23:23 <Axman6> blackdog: of course i did
20:23:25 <dons> but i might have an excuse
20:23:46 <sproingie> > let å = (+) in 1 `å` 2
20:23:48 <lambdabot>   3
20:23:50 <blackdog> dons: you didn't realise either?
20:23:50 <SamB_XP_> > let å = 42 in å^2
20:23:51 <lambdabot>   1764
20:23:53 <dons> nope.
20:24:14 <blackdog> ok. now i just need to claim that i'm as isolated from the australian mainstream as you are in Portland :)
20:24:14 <Axman6> blackdog: i always remember it, because it;s right around my birthday (thursday)
20:24:17 <dons> hehe
20:24:21 * dons lives in a bubble
20:24:31 <hexpuem> is it true that there are some roads in the outback that are so repetitive that its impossible to stay awake due to sensory deprivation
20:24:36 <SamB_XP_> blackdog: juts claim that you live in #haskell! ;-P
20:24:37 <dons> yeah
20:24:46 <sproingie> let a » b = a * b in 2 » 3
20:24:47 <Axman6> hexpuem: impossible, no
20:24:49 <dons> you can do it on google maps street view
20:24:50 <sproingie> argh
20:24:51 <sproingie> > let a » b = a * b in 2 » 3
20:24:53 <lambdabot>   <no location info>: lexical error at character '\187'
20:24:57 <blackdog> I wish I lived in a bubble. it'd have to be cooler than sydney. feels like about 35 degrees and epic humidity
20:25:12 <Axman6> blackdog: i hear ya :(
20:25:14 <dons> ah. well its maybe 8C here, and sunny today, so i claimed it was a lovely day
20:25:22 <Axman6> 27C here atm
20:25:27 <sproingie> meh.  i'd prefer «» as some kind of constructor like [] anyway
20:25:27 <Axman6> but probably ghotter in my room
20:25:29 <Axman6> -g
20:25:44 <Axman6> sproingie: i take it you're a mac user?
20:25:55 <sproingie> Axman6: why on earth would you think that?
20:26:09 <ivanm> blackdog: I'm aware that it's cup day; I'm just ignoring the Race that Robs the Nation
20:26:18 <blackdog> ivanm: ah, a political stance
20:26:24 <Axman6> well, those characters are all standard ones on Apple keyboards, with the option key
20:26:38 <sproingie> compose key
20:26:46 <blackdog> ok, now i know which large mammal ran faster than all the other large mammals. off the tv goes again
20:26:55 <Axman6> opt-shift-k = , opt-shift-\ = »
20:27:12 * hackagebot upload: happs-tutorial 0.9.3 - A Happstack Tutorial that is its own web 2.0-type demo. (ThomasHartman)
20:27:16 <ivanm> blackdog: more moral than political
20:27:16 <sproingie> i doubt i have a compose sequence for 
20:27:28 <sproingie> not even sure what that is, some isolated hebrew character?
20:27:54 <kmc> heh
20:28:48 <ivanm> sproingie: it's a box, duh ;-)
20:29:03 <dons> go hackage
20:29:07 <Axman6> sproingie: apple logo
20:29:31 <sproingie> not in utf8 it ain't
20:29:37 <Axman6> indeed
20:29:39 <ivanm> dons: so when is galois going to get a new box?
20:29:40 <EvanCarroll> addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)
20:29:41 <lament> yes it ai
20:29:45 <ivanm> sproingie: or it could be your font doesn't have it?
20:29:48 <EvanCarroll> why is that `Num a` in there?
20:29:55 <EvanCarroll> to say  all a's are numbers?
20:29:56 <kmc> EvanCarroll, it requires that "a" is a numeric type
20:29:58 <sproingie> or it could be i have a proper font not mangled by apple
20:29:59 <ivanm> EvanCarroll: because you have to add them?
20:30:00 <ivanm> EvanCarroll: yes
20:30:13 <ivanm> EvanCarroll: and the same type of numberic type for all of them
20:30:16 <kmc> the thing to the left of "=>" is called a "typeclass context"
20:30:16 <Axman6> :t (+)
20:30:18 <lambdabot> forall a. (Num a) => a -> a -> a
20:30:20 <Axman6> EvanCarroll: ^^^^^^^^^^^^^^^^^^^^^^^
20:31:09 <dons> ivanm: this week?
20:31:18 <ivanm> dons: hmmm?
20:31:22 <dons> serve you up all the hackages you want .. at a low low price.
20:31:29 <ivanm> oh, wait, you were responding to me
20:31:33 <ivanm> forgot I asked ;-)
20:31:35 <dons> hehe
20:32:35 <ivanm> especially how you cunningly turned your response into a question by the simple inclusion of a question mark on the end...
20:32:35 <ivanm> ;-)
20:32:36 <EvanCarroll> why doesn't this work let addVectors :: (a) => (a, a) -> (a, a) -> (a, a)  ; addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)
20:32:48 <EvanCarroll> simply because haskell knows not everything supports +
20:32:52 <kmc> "(a) =>" doesn't mean anything
20:33:00 <kmc> try "(Num a) =>"
20:33:09 <EvanCarroll> I had Num a
20:33:13 <EvanCarroll> i'm asking why it is required
20:33:16 <dons> EvanCarroll: you can add an instance for Num Vector if you like (and can come up with a sensible defin)
20:33:23 <kmc> because (+) does not exist for every type
20:33:25 <kmc> :t (+)
20:33:25 <lambdabot> forall a. (Num a) => a -> a -> a
20:33:34 <Axman6> > 'a' + 'b'
20:33:35 <kmc> you're using (+) on things of type a
20:33:35 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
20:33:36 <lambdabot>    arising from a use of `GHC....
20:33:44 <EvanCarroll> kmc: that was my guess
20:33:50 <EvanCarroll> 22:33 < EvanCarroll> simply because haskell knows not everything supports +
20:33:55 <kmc> yeah
20:34:05 <dons> ?instance Num
20:34:06 <lambdabot> Maybe you meant: instances instances-importing
20:34:09 <dons> ?instances Num
20:34:10 <lambdabot> Double, Float, Int, Integer
20:34:54 <EvanCarroll> cool thats enough for tongight
20:34:56 <EvanCarroll> i'm going to bed
20:34:57 <EvanCarroll> later all
20:35:04 <Axman6> EvanCarroll: come back soon
20:35:05 <kmc> laters
20:35:44 <sproingie> ah.   is private use
20:35:50 <kmc> it's a euro sign here
20:36:08 <sproingie> it also does weird-ass things to width when i edit a line containing it
20:36:16 <sproingie> tho it isn't rtl
20:36:25 <kmc> does IRC use a standard Unicode encoding?
20:36:36 <sproingie> it doesn't.  utf8 is de facto standard tho
20:36:52 <dibblego> is foldr (:) in the library?
20:37:03 <kmc> :t foldr (:)
20:37:04 <lambdabot> forall a. [a] -> [a] -> [a]
20:37:18 <kmc> > foldr (:) "abc" "def"
20:37:19 <lambdabot>   "defabc"
20:37:27 <kmc> > (flip (++)) "abc" "def"
20:37:28 <lambdabot>   "defabc"
20:38:02 <sproingie> rfc2812 describes the protocol clients have to speak, and "utf" and "unicode" doesn't appear anywhere
20:38:27 <dibblego> @check \x y -> foldr (:) x y == y ++ x
20:38:28 <lambdabot>   "OK, passed 500 tests."
20:38:28 <kmc> sure, that's a trivial presentation issue ;)
20:38:33 <sproingie> further underscoring what a crappy ad-hoc protocol it is
20:38:33 <kmc> does the term "ASCII" appear?
20:38:35 <Axman6> @src (++)
20:38:35 <lambdabot> []     ++ ys = ys
20:38:36 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
20:38:36 <lambdabot> -- OR
20:38:36 <lambdabot> xs ++ ys = foldr (:) ys xs
20:38:42 <sproingie> irc is largely an oral tradition
20:38:42 <Axman6> dibblego: ^^^^^^^^^
20:38:43 <dibblego> yeah duh thanks
20:40:25 <HaudRex> @type foldr const undefined
20:40:26 <lambdabot> forall a. [a] -> a
20:40:44 <Cale> kmc: No, but there's a particular character equivalence defined for nicknames which is based on some funky Scandinavian keyboard.
20:41:15 <Cale> Actually, now that I look at it, it's not *too* strange
20:41:29 <Cale> It's just that {}| are considered the lowercase versions of []\
20:41:35 <ray> rfc 2812? are you serious?
20:41:42 <Cale> 1459
20:41:51 <sproingie> that scandanavian stuff is obsolete
20:41:58 <HaudRex> dsint evrvon hev a skandineivan kbor?
20:42:03 <sproingie> hardly anything ever followed it in the first place
20:42:42 <Cale> I think we should have UTF-8 nicknames :)
20:42:43 <ray> you're lucky i'm limited in what i can spew at you on a haskell channel
20:42:46 <sproingie> HaudRex: møøse bites kån be pretti nåsti
20:42:57 <ray> well, there's plenty of abuse potential in that, cale
20:43:06 <ray> not utf8 per se, unicode
20:44:43 <ray> how does one tell "Cale" apart from "Cаle"
20:45:54 <Cale> By copy & paste and/or right click menus :)
20:46:34 <Cale> Though yeah, that makes a pretty good means of impersonation.
20:46:35 <ray> let's not even get into combining marks, normal forms, zero-width spaces
20:47:14 <Cale> Someone down at the Unicode committee must have figured out a good display equivalence relation?
20:47:28 <ray> domain registrars blacklist some characters, but they can't well blacklist cyrillic lowercase a
20:47:39 <ray> paypаl.com
20:48:19 <Cale> Yeah, I'm saying don't blacklist characters. Define nicks to be equivalent modulo a relation which goes by character similarity.
20:48:51 <ray> that's one of those fun problems
20:49:01 <Cale> (and well, blacklist things like zero-width characters)
20:49:50 <sproingie> if they render exactly identically in, say, Courier New, it doesn't take a very sophisticated language analysis to discover that
20:50:11 <hgolden> @tell _Ray_. FYI, here's a simpler searchLongest: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11376#a11495
20:50:12 <lambdabot> Consider it noted.
20:50:46 <ivanm> I take it we're talking about non-latin characters in URLs?
20:51:07 <ray> irc nicks
20:51:11 <ivanm> ahhh
20:51:15 <_Ray_> :o *reads*
20:51:35 * ivanm goes off to register cyrrilic character versions of his nick...
20:51:36 <ivanm> ;-)
20:52:00 <ivanm> hey, maybe I can get іvаn !
20:52:01 <hgolden> ivanm: elvish?
20:52:11 <ivanm> hgolden: why elvish?
20:52:18 <hgolden> why not?
20:52:32 <ray> i am pretty sure elvish script is in private use
20:52:39 <ivanm> because elvish doesn't look like English, and I don't have any Elvish heritage...
20:52:52 <hgolden> ray: elvish is in Unicode
20:53:36 <sproingie> it's in the private use area
20:53:54 <sproingie> been proposed for unicode, but got shot down
20:54:04 <hgolden> sproingle: too bad
20:54:16 <ray> that is what private use is for
20:54:50 <sproingie> my font in firefox renders most of the codepoints for tengwar as miscellaneous chinese characters and combining marks
20:54:52 <ray> conlangers, go CRAZY
20:55:13 <sproingie> actually wait it's not chinese it's cunieform
20:55:36 <ray> cuneiform has a legit block
20:57:29 * Axman6 pokes blackdog with a horse
21:00:05 <ivanm> Axman6: leave that poor defenseless livestock alone!
21:06:01 <blackdog> <orcish>Stop poking me!</orcish>
21:06:20 <blackdog> ivanm: were you referring to me or the horse? :)
21:06:28 <ivanm> the horse
21:06:38 <Axman6> hey, don't change your mind now
21:06:41 <ivanm> just because you think you're an animal doesn't mean you're an animal
21:06:45 <Axman6> we all know what you meant
21:06:55 <Axman6> well, we are animals...
21:07:37 * kmc is a great ape
21:08:53 * ivanm pushes kmc back into his cage and makes sure the door is locked shut this time
21:09:10 * kmc is a great ape who can pick locks
21:09:15 <kmc> (not that well)
21:10:10 <c_wraith> I'm more of the "gnaw through it" type.
21:12:49 <dancor> if a thread in a thread pool throws an exception, is it better to just (error . show) right way (which halts all the threads right?) or halt all the threads and re-throw the exception?
21:15:00 <pifish> > (\x -> x x) (\x -> x x)
21:15:01 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
21:15:16 <Cale> @djinn (((((u -> v) -> ((Not c) -> (Not h))) -> c) -> t) -> Not (Not ((t -> u) -> (h -> u))))
21:15:17 <lambdabot> f a b =
21:15:17 <lambdabot>     void (b (\ _ c ->
21:15:17 <lambdabot>              void (b (\ d ->
21:15:17 <lambdabot>                       void (b (\ _ _ ->
21:15:17 <lambdabot>                                d (a (\ e ->
21:15:19 <lambdabot>                                      void (e (\ f -> void (b (\ _ _ -> f))) (\ g ->
21:15:21 <lambdabot>                                                                              void (b (\ h ->
21:15:23 <lambdabot>                                                                                       void (b (\ _
21:15:25 <lambdabot>                                                                                                  _ ->
21:15:26 <Cale> ...
21:15:27 <lambdabot>                                                                                                h (a (\ _ ->
21:15:29 <Axman6> you're a monster!
21:15:29 <dolio> Nice.
21:15:29 <lambdabot>                                                                                                      g))))))) c)))))))))
21:15:29 <kmc> lambdabot, hpaste please
21:17:59 <morganson> hello
21:18:07 <Cale> hello!
21:18:07 <Axman6> 'lo morganson
21:18:35 * hackagebot upload: BlogLiterately 0.2 - A tool for posting Haskelly articles to blogs (RobertGreayer)
21:19:28 <Axman6> @hackage BlogLiterately
21:19:28 <lambdabot> http://hackage.haskell.org/package/BlogLiterately
21:19:51 <Axman6> hmmm, looks very interesting
21:20:06 <morganson> I am getting a little bit better at Haskell now. one thing that I can't seem to understand is the concept of fold, foldr etc. I can't understand what it does. What are the possibilities with that kind of function? thank you!
21:21:04 <Cale> morganson: Okay, you know how lists are built up from [] and (:)?
21:21:14 <tommd> morganson: for(i=0; i<max; i++) sum += i;
21:21:24 <morganson> Cale yes
21:21:24 <Cale> What foldr f z does is to replace each (:) with f and the [] with z
21:21:31 <tommd> morganson: foldl (+) 0 [0..max-1]
21:21:46 <Cale> > foldr (:) [] [1,2,3,4] -- so this does nothing to the list :)
21:21:48 <lambdabot>   [1,2,3,4]
21:21:55 <Cale> > foldr (+) 0 [1,2,3,4] -- sum
21:21:56 <lambdabot>   10
21:22:00 <Cale> > foldr (*) 1 [1,2,3,4] -- sum
21:22:01 <lambdabot>   24
21:22:10 <Cale> Er, didn't edit the comment ;)
21:22:15 <Cale> That's the product of course
21:22:34 <Cale> > foldr (++) [] [[1,2,3],[4,5],[6,7,8]]
21:22:35 * Axman6 thinks that sum and product are better as left folds
21:22:36 <lambdabot>   [1,2,3,4,5,6,7,8]
21:22:36 <dancor> @src product
21:22:37 <lambdabot> product = foldl (*) 1
21:22:47 <morganson> allright so it does a function to every element in a list?
21:22:57 <Cale> morganson: not exactly...
21:23:03 <Cale> > foldr f z [1,2,3]
21:23:04 <lambdabot>   f 1 (f 2 (f 3 z))
21:23:08 <Cale> ^^ it does that
21:23:15 <Cale> I have some diagrams which might help
21:23:22 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
21:23:28 <HayashiRazan> oh so it does a curried function to the list
21:23:33 <morganson> I would appreciate that. thank yout
21:23:37 <dancor> how much did yi.org cost
21:23:40 <sproingie> foldr is easy to think of as a replacement for : on a list
21:23:41 <morganson> I will check it now
21:23:51 <Cale> It replaces the constructors of the list with the function/value provided
21:24:04 <Cale> dancor: I don't own yi.org, but cale.yi.org was free
21:24:06 <morganson> allright
21:24:11 <sproingie> you can think of foldl that way too but the associativity is all wrong
21:24:40 <Cale> foldl does some more transformation, so it's a little harder to define, but it also follows a clear pattern as you see from the diagram
21:25:10 <sproingie> rwh has some pretty mind-bendy exercises for foldr
21:25:13 <Cale> morganson: Basically, if you get sick of writing recursive programs which look like:
21:25:17 <Cale> concat [] = []
21:25:22 <Cale> concat (x:xs) = x ++ concat xs
21:25:43 <Cale> Well, you'll notice that lots of programs do this sort of recursion over a list
21:25:52 <morganson> yes
21:25:56 <Cale> So the natural thing to try to do is abstract that away
21:25:58 <jeff_s_> Not a haskell specific question: is it right that +, - and * are the same for unsigned integers and 2's complement integers, but / and mod are not?
21:26:12 <Cale> So that you can't get it wrong, and you don't have to repeat yourself.
21:26:23 <HayashiRazan> cale what would be the edge condition in the new abstraction?
21:26:25 <kmc> jeff_s_, think so
21:26:29 <HayashiRazan> [] = [] ?
21:26:32 <Axman6> jeff_s_: div and mod?
21:26:41 <kmc> at least based on cpu architectures i know
21:26:42 <Cale> HayashiRazan: Well, we have a parameter z which handles that
21:26:52 <Cale> foldr f z [] = z
21:26:58 <jeff_s_> axman ya
21:27:04 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
21:27:11 <jeff_s_> thanks
21:27:20 <kmc> @src foldr
21:27:21 <lambdabot> foldr f z []     = z
21:27:21 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:27:24 <Cale> Maybe it helps here to wrap each foldr f z in an extra set of parens
21:27:37 <Cale> So that it looks even more like the definition of concat, etc.
21:27:42 <morganson> thank you. I will try it out in ghci
21:28:14 <Cale> morganson: In general, if you define a new datatype, it can be very useful to define a 'fold' function which simply replaces each constructor of the datatype with a different function or value.
21:28:27 <Cale> For example...
21:28:36 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
21:28:40 <kmc> indeed, if your language lacks the "data" declaration, you can define datatypes this way
21:28:42 <Cale> treeFold t b = f
21:29:01 <Cale>   where f Tip = t; f (Branch x l r) = b x (f l) (f r)
21:29:25 <Cale> treeFold t b will replace each Tip with t and each Branch with b
21:29:33 <morganson> ok
21:29:42 <Cale> and then we can do fun things like
21:30:01 <Cale> flipTree = treeFold Tip (\x l r -> Branch x r l)
21:30:08 <Cale> or
21:30:09 <morganson> I am actually doing this from a tutorial now... http://learnyouahaskell.com/making-our-own-types-and-typeclasses
21:30:21 <Cale> sumTree = treeFold 0 (\x l r -> x + l + r)
21:30:41 <morganson> allright
21:31:13 <Cale> inorder t = treeFold id (\x l r -> l . (x:) . r) t []
21:31:32 <Cale> So, you can get a lot of mileage out of that function :)
21:33:56 <dancor> is  ErrorT e IO a  strictly better than exceptions?
21:36:24 <c_wraith> dancor:  I don't like the interaction between fail and ErrorT
21:38:58 <dancor> c_wraith: it seems to be sane?
21:40:39 <c_wraith> You really expect the result of hitting a non-exhaustive pattern match to vary depending on e?
21:42:33 <dancor> well i think e has to be String or there has to be an EOfType String in there
21:42:42 <dancor> idk
21:42:48 <c_wraith> e is any instance of Error, for ErrorT
21:42:54 <c_wraith> @src Error
21:42:55 <lambdabot> class Error a where
21:42:55 <lambdabot>     noMsg  :: a
21:42:55 <lambdabot>     strMsg :: String -> a
21:43:16 <c_wraith> fail calls strMsg for e
21:43:21 <c_wraith> Which I don't like at all
21:43:45 <dancor> i mean i think in a _sane_ use of ErrorT e IO a, for the reason you bring up e has to be String or ..
21:52:57 <hexpuem_> does ghc work for anyone on OSX 10,6,1?
21:53:30 <Axman6> my install from 10.5 works fine :\
21:54:00 <Axman6> hexpuem_: try installing one of the binaries (you'll need to edit the ghc, ghci and hsc2hs scripts to make them work in SL
21:54:20 <orbitz> is literate haskell 'literate' in teh sense of knuths 'literate programming'?
21:54:43 <hexpuem_> im using a binary install
21:54:52 <ivanm> orbitz: yes
21:54:54 <Axman6> if literate means that comments are the default, then yes
21:55:02 <hexpuem_> the .pkg
21:55:21 <Axman6> hexpuem_: ok, well you need to edit `which ghc`, `which ghci` and `which hsc2hs`
21:55:57 <Axman6> you need to add this to the end of the exec line in ghc and ghci: -opta-m32 -optl-m32 -optc-m32
21:56:13 <hexpuem_> ok thanks
21:56:20 <Axman6> and this to the end of the exec line in hsc2hs: C -m32 -L -m32
21:56:26 <orbitz> Axman6: i think it means alitlt ebit more
21:59:07 <hexpuem_> is that -C or just C
21:59:21 <Axman6> -C
21:59:23 <Axman6> sorry
21:59:28 <hexpuem_> thanks
21:59:49 <malie> @pl \a b c-> f a (f b c)
21:59:49 <lambdabot> (. f) . (.) . f
22:00:02 <malie> @pl \a b c-> f (f a b) c
22:00:02 <lambdabot> (f .) . f
22:00:44 <hgolden> orbitz: some of knuth's literate programming ideas aren't as relevant for haskell. for example, haskell is naturally in chunks (functions)
22:00:58 <Axman6> @pl \f a b c -> f a (f b c)
22:00:58 <lambdabot> flip =<< (((.) . (.)) .)
22:01:02 <Axman6> o.O
22:01:08 * ddarius thought every (sane) language was "naturally in chunks"
22:01:11 <orbitz> hgolden: yeah in looking at an example it seemed like macros ~= functions
22:01:12 <Axman6> flip cannon!
22:02:04 <hgolden> ddarius: have you read knuth's paper. he wrote it at a time when structured programming was the state of the art
22:03:48 <dolio> Knuth doesn't need to program in a sane language. :)
22:04:05 <hgolden> dolio: ?
22:04:07 <ddarius> dolio: True, hence TeX.
22:04:14 <dolio> hgolden: He's that good.
22:05:11 <orbitz> i heard at this point knuth just concentrats hard enough and computers bend ot his swill
22:05:29 <hgolden> orbitz: swill?
22:05:31 <ddarius> orbitz: We have the technology to do that.
22:05:45 <rasfar> if his swill is that potent...
22:06:11 <sproingie> i think the main idea was that the code and spec couldn't go out of sync
22:06:42 <kmc> that's what types are for :D
22:06:45 <sproingie> because, yunno, every programmer loves to have pages and pages of spec interleaved in the code
22:06:46 <orbitz> do many people write code in lhs? all the stdlibs are in .hs right?
22:07:05 * ddarius wishes he had pages of pages of spec...
22:07:09 <kmc> orbitz, i find lhs (both styles) to be too ugly to read, and there's the issue of editor support
22:07:09 <sproingie> lhs is occasionally useful for long-winded documents that intersperse a few examples
22:07:15 <kmc> i used it for a school project to show off, but not since
22:07:22 <kmc> i like the movement towards literate blog posts
22:07:33 <sproingie> bird-style lhs isn't terrible for that.  tex-style lhs is dreadful no matter how you slice it
22:07:33 <orbitz> yeah the blog posts thing is nice
22:07:45 <sproingie> yeah it's really nice for wiki markup
22:07:47 <ddarius> sproingie: Unless you are making a paper.
22:07:48 <kmc> http://greayer.wordpress.com/2009/10/26/blogging-literately-in-haskell/
22:07:53 <sproingie> in a way it is a degenerate sort of wiki markup
22:08:06 <kmc> imo all wiki markup is degenerate
22:08:08 <kmc> at least the common ones
22:08:11 <kmc> which are frustratingly not the same
22:08:21 <kmc> moving between mediawiki and docuwiki bugs the hell out of me
22:08:26 <sproingie> wiki markup is just interface.  the great sin is only supporting one interface
22:08:37 <kmc> i like Markdown
22:08:40 <ivanm> kmc: degenerate compared to... ?
22:08:49 <kmc> hmm good question
22:08:56 <sproingie> i like my own markup which is a mix of markdown and bbcode
22:08:57 <ddarius> ivanm: SGML
22:08:59 <ivanm> orbitz: some stdlibs are in .lhs IIRC
22:09:10 <kmc> docuwiki has awful things where the amount of whitespace on a whitespace-only line is important
22:09:26 <sproingie> i use socialtext at work, the markup for that is just awful
22:09:32 <kmc> or the amount of padding you give on a cell in a grid determines its alignment
22:11:34 <sproingie> i had this silly thing in python called nom that let you bash together markup engines pretty easy
22:12:17 <ddarius> "The Next 700 Markup Languages"
22:12:36 <sproingie> as in bash together existing ones
22:12:49 <sproingie> write bits of your pages in markdown, rst, raw html, wikicreole, etc
22:13:01 <sproingie> kinda like wml except it didn't suck
22:18:32 <hgolden> sproingle: knuth's main point is that we should write programs to be read by humans
22:22:45 <hgolden> great resource for literate programming: http://literateprogramming.com
22:24:10 <Nafai> hgolden: Perhaps I am use to more imperative and mundane programming, but Knuth was doing more "algorithmic" programming -- even when writing TeX -- and thus it makes sense that he would use more explanations and so forth
22:24:34 <Nafai> hgolden: But it seems like overkill in most of the run-of-the-mill get-stuff-done programs I've written
22:25:07 <Cale> Nafai: If the syntax is lightweight enough, it's not so bad.
22:25:32 <hgolden> Nafai: I agree when you're writing scripts. It really helps when what you're doing is complicated (algorithmic as you say).
22:26:23 <hgolden> my simple explanation is: don't just explain the how. explain the why/why not as well.
22:26:35 <sproingie> assuming i can get an editor to fold it all away, since all that "literate" stuff has zero semantic value on my actual code
22:26:46 <sproingie> at which point one wonders why not just maintain a separate doc
22:27:21 <hgolden> sproingle: you could, but the docs always get out of sync with the code.
22:27:48 <Nafai> hgolden: I admit I'm knocking it without trying it, so perhaps literate programming could be a useful practice, given the right tools
22:27:55 <sproingie> and it's only the "keep it in sync" argument at that point.  which is reasonable enough, but it's not like inlined docs are always necessarily in sync either
22:29:08 <hgolden> I agree about docs not matching the code. this is a problem. the unix guys recommended doing away with comments. i think this was terrible advice.
22:29:42 <kmc> document as much as possible in the types
22:29:47 <kmc> so the compiler keeps you honest
22:30:17 <kmc> many functions in a haskell program are perfectly well-documented from a good name and the type signature
22:30:22 <hgolden> the types really help, but they don't explain "why" you're doing something
22:30:26 <kmc> not all
22:30:37 <kmc> "why" is often clear as well
22:30:39 <kmc> but not always
22:30:54 <kmc> this is maybe an argument against pointsfree style and for giving more things names
22:31:02 <hgolden> kmc: right.
22:32:47 <hgolden> have you tried to understand someone else's code? have you tried to understand your own code months later? i think you should comment based on your experience with these situations.
22:33:24 <Warrigal> @type par
22:33:26 <lambdabot> forall a b. a -> b -> b
22:33:53 <Nafai> hgolden: It's that reflection that makes me think that literate programming just might be useful, even though my knee-jerk reaction is to say no
22:33:58 <Nafai> hgolden: Have you used it much?
22:35:04 <hgolden> Nafai: i haven't used knuth's tools, but i try to explain my code when it isn't obvious
22:35:05 <Warrigal> http://www.yip.org/neighbor.html
22:35:08 <Warrigal> ...oops.
22:35:12 <kmc> hgolden, i think literate programming may encourage overcommentin
22:35:25 <Warrigal> I should set PuTTY so that right-click doesn't do that.
22:35:31 <kmc> int x = a + b;  // add a and b and assign the result to the variable x
22:35:33 <kmc> doesn't help anyone
22:35:36 <hgolden> kmc: then comment sparingly
22:35:49 <kmc> but then your program doesn't read properly as a human text
22:36:02 <Axman6> i tend to comment what functions do, not how they do them
22:36:05 <hgolden> kmc: as i said, document the "why"
22:36:23 <kmc> how can matter.  hopefully "how" is an obvious composition of the "what" of some smaller things
22:36:26 <Nafai> hgolden: Have you read the TeX source or any of Knuth's literate stuff -- I mean code he wrote in that style?
22:37:12 <hgolden> Nafai: i read it a long time ago. i have knuth's book on my shelf and refer to it occasionally
22:38:11 <hgolden> remember that knuth uses some pretty sophisticated algorithms. explaining them really helps!
22:38:24 <kmc> s/used/invented/
22:38:35 <Nafai> indeed
22:38:36 <kmc> :)
22:41:03 <hgolden> basically, you need to identify your audience. if you're writing to novices, you need more detail. but try the experiment of looking at some code you wrote months ago. if you can't understand it easily, you need more comments. however, you don't need to make a fetish out of it.
22:43:51 <hgolden> i think this is especially important when using haskell. what is the knowledge level of your assumed reader? clearly, it will be much higher than the average reader of an imperative language. but how high is too much to expect?
22:51:04 <ivanm> @tell roconnor well, I was working on the X11 colours before I realised that different people have different definitions of the colours (e.g. I don't have crimson here; wikipedia + graphviz do) :s
22:51:05 <lambdabot> Consider it noted.
22:52:17 <travisbrady> > fst `fmap` Data.ByteString.Char8.readInt
22:52:18 <lambdabot>   Not in scope: `Data.ByteString.Char8.readInt'
22:55:44 <hgolden> have you see the book: "The Haskell Road to Logic, Maths and Programming"? the whole book is literate haskell
23:07:07 <ivanm> Axman6: ping!
23:07:12 <Axman6> :o
23:07:43 <ivanm> does OSX have an rgb.txt file anywhere?
23:08:20 <Axman6> /usr/X11/share/X11/rgb.txt
23:08:33 <ivanm> can you see if it has a colour called crimson in there please?
23:08:37 <Axman6> there's a few others, but i probably installed them with other software (emacs has its own too)
23:08:51 <Axman6> nope
23:09:33 * ivanm wonders which stupid X11 versions have it...
23:18:27 * hackagebot upload: Lucu 0.3.3 - HTTP Daemonic Library (MasatakeDaimon)
23:58:48 * hackagebot upload: mecha 0.0.3 - Mecha is a solid modeling language geared for machine design. (TomHawkins)
