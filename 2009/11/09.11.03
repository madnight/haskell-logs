00:06:12 <Axman6> http://www.bustedtees.com/helvetica XD bwahaha
00:07:23 <kmc> http://www.youtube.com/watch?v=aY7XH2ulTEU
00:11:43 <Axman6> kmc: wth?
00:15:23 <Cale> Axman6: It's from this episode of Look Around You: http://www.youtube.com/watch?v=n2k9JwGpm1w
00:16:25 <ehamberg> Axman6: haha, if it wasn't for the fact that i often have to walk through the department of product design at my university, i would totally buy that. my life is worth a little bit more, though.
00:16:45 <Axman6> lol
00:16:49 <Axman6> do it!
00:17:03 <Taejo> in infix{l,r} is a lower number tighter or looser binding?
00:17:33 <Cale> low numbers are looser
00:17:39 <Taejo> thanks
00:18:41 * Lemmih had to look twice when he read that as 'low numbers are losers'.
00:19:40 <ivanm> Axman6: I don't get it... what's so funny?
00:19:55 <Axman6> Helvetica... written in Comic Sans
00:19:59 <ivanm> ahhh
00:20:01 <Axman6> guess you're not a font geek
00:20:05 * ivanm preferred "Who killed the serif"
00:20:10 <Taejo> Lemmih: I hate that stupid 0; it's so low!
00:30:48 <Cale> ehamberg: Yeah, it's dangerous enough walking around with a shirt that says Helvetica in Helvetica, let alone in Comic Sans.
00:33:44 <gour> hiya, i'm curious if there are some LP fans here using Leo for haskell programming?
00:34:05 <opqdonut> LP? Literate programming?
00:34:43 <Lemmih> Lumbar Puncture?
00:35:01 * Lemmih has watched too much House.
00:35:12 <gour> nope ;)
00:35:28 <Lemmih> You're right. There's no such thing as too much House.
00:36:10 <gour> Lemmih: you're still on the north?
00:36:26 <gour> opqdonut: yes
00:38:11 <opqdonut> Lemmih: i just finished S05, it was great
00:38:30 <omes> i thought season 4 was sooo bad
00:38:32 <opqdonut> I quite disliked seasons 3 and 4
00:38:40 <opqdonut> 4 was the worst, yes
00:38:41 <omes> then in the end it turned out to be really good
00:45:10 <ehamberg> Cale: :-)
00:48:58 <Axman6> Cale: "The calcium is then heated to 12,000bc before being cooled" XD
00:54:59 <sieni> I'm trying to install yi with "cabal install yi" on Windows. I have Haskell Platform 2009.2.0.2 installed. I get the following error:
00:55:16 <sieni> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11497#a11497
00:56:52 <sieni> Any ideas what to fix?
01:09:43 <ManateeLazyCat> mmorrow: Are you there?
01:10:12 <ManateeLazyCat> @seen mmorrow
01:10:12 <lambdabot> Unknown command, try @list
01:10:17 <ManateeLazyCat> @list
01:10:18 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
01:12:57 <Phyx-> Lemmih: well, You're right, House is a consistent show
01:13:10 <Phyx-> in quality atleast, i liked the season premier
01:13:15 <Phyx-> it was awesome
01:19:51 <ManateeLazyCat> mmorrow: After *big* refactory with your model (unit/layout := Foo.Manager + Foo.Types + Foo.*), i have fix "recursive reference problem" completely, no any .hs-boot file in my project now, sweet.... Thanks for your help! :)
01:20:02 <omes> i like how house's in-your-face approach :P
01:20:08 <fasta> Where do I need to install C library headers such that any random Windows user will be able to use them with cabal?
01:20:49 <Baughn> fasta: Windows has no default search path for headers..
01:21:01 <fasta> I know I can distribute the headers myself, but I would rather not do that.
01:21:11 <fasta> Baughn, is there anything Windows does have?
01:21:17 <Baughn> fasta: Bugs.
01:21:24 <fasta> Oh, and "market share".
01:21:32 <Phyx-> *sigh*
01:21:49 * Phyx- points his remote at the haters
01:22:06 <Baughn> fasta: Point is, you can't install headers in any default location and expect the compiler to see them
01:22:17 <Baughn> fasta: ..well, not a C compiler. GHC might have one.
01:22:37 <fasta> Baughn, doesn't GHC ship gcc?
01:22:47 <paolino> hi, is there an obvious way to parallelize a "concatMap f" ?
01:22:48 <fasta> Baughn, so, it could just make up a standard.
01:22:53 * ManateeLazyCat brb
01:23:02 <Baughn> fasta: Possibly it does. I don't use GHC on windows.
01:23:32 <Phyx-> fasta: the ghc folder does have an Includes folder for things it searches for
01:24:10 <Phyx-> include*
01:24:25 <Phyx-> which is used by the gcc it ships with
01:24:28 <paolino> :t parMap
01:24:29 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
01:24:56 <Taejo> paolino: I don't think you can easily parallelise the concat, unfortunately
01:25:32 <paolino> Taejo: sounds correct
01:25:45 <paolino> and what is this Strategy ?
01:26:00 <Axman6> @hoogle Strategy
01:26:01 <lambdabot> Control.Parallel.Strategies type Strategy a = a -> Done
01:26:02 <lambdabot> Codec.Compression.GZip data CompressionStrategy
01:26:02 <lambdabot> Codec.Compression.Zlib data CompressionStrategy
01:26:22 <Axman6> Done is just ()
01:26:24 <paolino> Axman6: at least obscure
01:27:05 <Axman6> paolino: it's something that takes an a, and evaluates it i believe. go and read the Control.Parallel.Strategies docs
01:27:12 <paolino> it seems , it's not parMap  the same as map
01:27:19 <Axman6> it's ot
01:27:20 <namor> So I wrote this function "j (Maybe x) = x" to unwrap a Maybe x data, is that bad style?
01:27:22 <Axman6> not*
01:27:33 <Axman6> paolino: (parMap rnf) == map
01:27:43 <Axman6> :t rnf
01:27:44 <lambdabot> forall a. (NFData a) => a -> Done
01:28:02 <paolino> :t parMap rnf
01:28:04 <lambdabot> forall b a. (NFData b) => (a -> b) -> [a] -> [b]
01:28:36 <paolino> this implies the list element are fully evaluated ?
01:28:42 <Axman6> no
01:28:52 <Axman6> it will fully evaluate the elements of the resulting list
01:29:21 <paolino> ok
01:29:46 <Axman6> namor: well, that function doesn't make any sensew
01:29:49 <Axman6> sense*
01:29:59 <Taejo> namor: you mean j (Just x) = x?
01:30:06 <namor> Ah... yes, sorry.
01:30:24 <Taejo> that's better known as Data.Maybe.fromJust
01:30:31 <Axman6> namor: it's only bad to do that because there's already a function, fromJust, that does that
01:30:49 <namor> Oh, good to know!
01:30:59 <namor> Is there a similar thing for Either and Right?
01:31:14 <Taejo> fromRight I think
01:31:53 <Taejo> @hoogle Either a b -> b
01:31:54 <lambdabot> Data.Either rights :: [Either a b] -> [b]
01:31:54 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
01:31:54 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
01:32:09 <Taejo> :t fromRight
01:32:09 <lambdabot> Not in scope: `fromRight'
01:32:15 <Taejo> @hoogle fromRight
01:32:16 <lambdabot> No results found
01:32:24 <Taejo> looks like I'm mistaken
01:32:52 <dolio> Might be for the best, since functions like that are evil.
01:33:28 <Taejo> | fromRight = either undefined id | would do it, but you can see from the undefined that it might be, as dolio says, evil
01:33:50 <paolino> Axman6: so using Parallel.Strategies is also destroying lazyness ?
01:34:05 <Taejo> paolino: it has to
01:34:06 <Axman6> well... sort of
01:34:20 <Axman6> Taejo: parallelism and laziness doesn't really make much sense together
01:34:36 <Axman6> when you do something in paralle, you want everything done in parallel, as quickly as possible
01:34:53 <Taejo> that's why I said it has to
01:34:54 <namor> Taejo, is there a way to preserve the "Left" error message when using that? undefined just absorbs the "Left" error msg..
01:35:30 <Vanadium> either error id?
01:35:36 <Taejo> that'll do it
01:35:41 <Vanadium> > either error id $ Left "oh no"
01:35:42 <lambdabot>   * Exception: oh no
01:36:00 <namor> Ok.. what is that "id"?
01:36:04 <Axman6> :t id
01:36:06 <lambdabot> forall a. a -> a
01:36:10 <Axman6> > id 1
01:36:11 <lambdabot>   1
01:36:13 <Axman6> > id "hello"
01:36:13 <Taejo> > id "roflcopter"
01:36:14 <lambdabot>   "hello"
01:36:15 <lambdabot>   "roflcopter"
01:36:17 <Axman6> > is ()
01:36:18 <lambdabot>   Not in scope: `is'
01:36:21 <Axman6> > id ()
01:36:22 <lambdabot>   ()
01:36:37 <Axman6> namor: id = identity
01:36:47 <namor> Ok, I think I get it. Thanks.
01:37:21 <Axman6> :t either
01:37:23 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
01:37:34 <Axman6> @src either
01:37:35 <lambdabot> either f _ (Left x)     =  f x
01:37:35 <lambdabot> either _ g (Right y)    =  g y
01:37:58 <paolino> Axman6: I have some problem understanding why parallelism and lazyness don't go together, but it's obvous that cases when I see I need parallelization are always for things to be computed
01:38:50 <paolino> :t parFlatMap
01:38:51 <lambdabot> forall b a. Strategy [b] -> (a -> [b]) -> [a] -> [b]
01:39:15 <Axman6> paolino: well... with laziness, you want to leave computation until as late as possible right? so, if parMap were lazy, you'd be doing a lot of nothing in parallel
01:39:16 <Taejo> paolino: laziness is "compute this when I need it". parallelism is "compute these all at the same time because it's faster than doing them one-by-one"
01:39:30 <Axman6> well put Taejo
01:45:05 <Botje> i astrive to do a lot of nothing in parallel.
01:45:10 <Botje> s/astrive/strive
01:47:11 <paolino> instance NFData (GSstate g v) where
01:47:11 <paolino> 	rnf (GState v g) = GState (rwhnf v) (rnf g)
01:47:31 <paolino> is this correct in the meaning ?
01:48:18 <paolino> this will leave v values to be computed lazily and sequentially ?
01:48:33 <Vanadium> Looks like you would need more $! here
01:48:53 <quicksilver> making a broken instance of NFData is the wrong way to leave some part lazy.
01:49:11 <quicksilver> if you want to explicitly leave some part lazy, don't use rnf - use the right strategy for the job.
01:49:32 <Baughn> In fact, don't use rnf at all, unless you really want to
01:49:47 <Baughn> Half the time it's shooting sparrows with ICBMs, and ICBMs are expensive
01:50:56 <paolino> ok, I'm confused now
01:51:57 <paolino> http://github.com/paolino/burraco/blob/master/Enumeration.hs
01:52:43 <paolino> this is the module. I'd like to parallelize concatMap core in sviluppo
01:54:08 <paolino> if someone would help, please, I need some
01:56:22 <Phyx-> hrm.. why is http://hackage.haskell.org/packages/bin/pkg-list a binary file... i was just expecting a list
01:58:47 <Axman6> paolino: what's your question then?
01:59:35 <paolino> how use Parallel.Strategies for that
01:59:53 <Phyx-> is it documented anywhere what that pkg-list format is?
02:00:36 <paolino> Axman6: and be sure the attach function is computed the sparks
02:01:06 <Axman6> how to do what?
02:01:14 <Axman6> you're going to need to give examples
02:01:21 <mmorrow> @tell ManateeLazyCat awesome!!
02:01:22 <lambdabot> Consider it noted.
02:01:42 <luite> Phyx-: it looks like an ELF executable
02:01:57 <luite> for linux
02:02:01 * Axman6 FFTs mmorrow 
02:02:12 <Phyx-> luite: which confused me to it's purpose
02:02:27 * mmorrow FFTs morrow
02:02:30 <mmorrow> m
02:02:35 <Phyx-> i wanted a list of all packages much like cabal downloads.. wonder where it gets the list
02:02:52 <mmorrow> woot, just got the nested case sorted out http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4565
02:02:55 <minike> Free signup ingyencset Limko everyone is welcome to the clipboard works   http://gollgabor.atw.hu/sex
02:03:02 <mmorrow> .. it only took two-three weeks :/
02:03:10 <Axman6> spam...
02:03:17 --- mode: ChanServ set +o quicksilver
02:03:20 --- mode: quicksilver set +b *!*=mapbc000@*.pool.t-online.hu
02:03:20 --- kick: minike was kicked by quicksilver (quicksilver)
02:03:30 <paolino> Axman6: see core function has a lot of call to attach function inside
02:03:45 <Axman6> ta quicksilver
02:04:02 <paolino> and I concatMap core in function line
02:04:26 <Axman6> paolino: where am i looking?
02:04:43 <paolino> http://github.com/paolino/burraco/blob/master/Enumeration.hs
02:04:49 <Axman6> yes, but where in the file
02:04:57 <luite> Phyx-: I think it downloads 00-index.tar.gz from this directory: http://hackage.haskell.org/packages/archive
02:05:13 <paolino> function core
02:05:19 <paolino>  46
02:05:26 <Phyx-> luite: ah, ok, cool, thanks :)
02:05:35 <Axman6> paolino: ok, so what do you want?
02:05:46 <sieni> who's responsible for yi nowadays?
02:06:15 <paolino> Axman6, have these calls to attach happen in parallel
02:06:16 <sieni> oh, there's #yi
02:06:56 <Axman6> paolino: ah, i see now. give me a few mins, and i'll see what i can do for you
02:07:11 <Phyx-> question, every package on Hackage automatically gets passed through haddock right? so there's always a "latest/doc/html/src" ?
02:07:11 <paolino> thanks
02:07:41 <Axman6> paolino: don't use tabs by the way, use spaces
02:10:45 <Axman6> paolino: how's this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11499#a11499
02:10:52 <Axman6> (the second one)
02:11:14 <Axman6> not sure if it's right...
02:11:31 <Axman6> uh, yeah, it's not right
02:11:58 <Axman6> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11499#a11500
02:12:45 <Axman6> mmorrow: ... what is that code :O
02:13:16 <dancor> is it just me or is binary-strict more useful than binary
02:13:40 <dancor> if you are pulling blobs off disk anyway
02:13:41 <Botje> i .. think it's a blog engine.
02:14:12 <dancor> really strict disk io seems better more often than lazy..
02:15:08 <Phyx-> @hoogle tempdir
02:15:09 <lambdabot> No results found
02:15:11 <Phyx-> @hoogle temp
02:15:12 <lambdabot> package template-haskell
02:15:12 <lambdabot> Foreign.C.Error eNOTEMPTY :: Errno
02:15:12 <lambdabot> System.Console.Editline.Readline getAttemptedCompletionOver :: IO Bool
02:15:19 <Phyx-> @hoogle temp dir
02:15:20 <lambdabot> System.Directory getTemporaryDirectory :: IO FilePath
02:15:27 <mmorrow> Axman6: it's from the compiler/interpreter that i'm working on
02:15:43 <Axman6> mmorrow: is it supposed to be readable?
02:16:02 <mmorrow> Axman6: it is if you stare at it long enough ;)
02:16:07 <Axman6> heh
02:16:14 * mmorrow has spent way too long staring at that
02:16:32 <allbery_b> the first part is readable, seems to be a list implementation.  the rest is some variant of Core, I think
02:16:33 <Axman6> "All sufficiently unreadable code approaches readability when stared at long enough"
02:17:44 <paolino> Axman6: which constraint this will put on g c v  ?
02:18:10 <Axman6> i'm not sure. remove the type signature, ans ask ghci :)
02:18:21 <fasta> Why do type-theory papers use 4 languages to do denote concatenating a list? (See the original calculus of constructions paper) That's just ridiculous.
02:18:28 <allbery_b> well, not GHC's core.  intermediate language of his compiler, I guess
02:24:29 <mmorrow> Axman6: so this is what it did http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4565#a4566
02:25:19 <mmorrow> (\m -> sum [product [1..n] | n <- [1..m]]) to a register-only nested loop
02:25:29 <Axman6> mmorrow: fantastic :D
02:25:40 <Axman6> just the sort of code i like to see!
02:25:47 <mmorrow> yay!
02:26:02 <fasta> Can I _compute_ the include dirs at cabal install time using Cabal using the Cabal library?
02:26:16 <paolino> Axman6: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11499#a11501
02:26:37 <dcoutts> fasta: depends where you're getting the info from
02:26:59 <Axman6> paolino: hmm, yeah. well can you see what i was trying to do at least?
02:27:02 <fasta> dcoutts: basically, I want to refer to C:/libraries/*IL*
02:27:18 <Axman6> oh! dcoutts!
02:27:39 <dcoutts> Axman6: yarr?
02:28:00 <fasta> dcoutts: so, when the version of the IL library changes, I don't want to have to change anything to the Cabal file.
02:28:02 <Axman6> dcoutts: would you perhaps like to come and join us in #hackage? we've started it us as a place where people can ask questions about haskage and cabal, and you would be an extremely valuable asset :)
02:28:28 <paolino> Axman6: yes
02:28:40 <Axman6> paolino: well, go off and make a version that works :D
02:28:58 <paolino> it's just the error is telling me f is not what I thought
02:29:01 <dcoutts> fasta: you can programitcally modify the package description in the Setup.hs if that'd help
02:29:15 <Axman6> Cale: are you around? if so, would you perhaps be able to make lambdabot join #hackage permanantly?
02:29:19 <fasta> dcoutts: and I can use the full IO monad there?
02:29:59 <paolino> Axman6: shouldn't f be a function from a tuple to a list ?
02:30:12 <Axman6> paolino: probably, you tell me ;)
02:30:30 <paolino> mhh
02:31:12 <fasta> dcoutts: ok, I can. I thought the idea was that you could only do a few specific things for safety.
02:33:26 <dcoutts> fasta: you can do whatever you like
02:33:50 <dcoutts> fasta: you have the power to break all the rules :-)
02:34:21 <fasta> Yes, otherwise people will just use unsafePerformIO ;)
02:34:21 <uhu> why does my ghci does not find the parsec module on import on a debian machine where i aptituded libghc-parsec?
02:34:41 <fasta> uhu, probably because there are different parsecs.
02:35:02 <fasta> uhu, so, which one exactly do you need and which one do you actually have?
02:36:15 <uhu> i need text.parsercombinators.parsec.language and i have in /ust/lib/parsec-2.1.0.0/ghc-6.8.2/text/parsercombinators/parsec/...
02:36:33 <uhu> in usr of course
02:38:54 <fasta> uhu, and which version of ghci are you using?
02:39:29 <uhu> ghci 6.8.2, in emacs, everything right out of the box on a current debian lenny
02:40:20 <fasta> uhu, case matters in module names.
02:40:56 <quicksilver> uhu: whether it is in /usr matters less than whether ghc-pkg can see it
02:41:01 <quicksilver> uhu: is it in ghc-pkg list ?
02:41:14 <quicksilver> did you restart ghci since you installed?
02:41:14 <fasta> uhu, also, I don't think using 6.8.2 is a good idea. It's horribly buggy if you go outside H98.
02:41:24 <quicksilver> which module did you try to import?
02:41:30 <quicksilver> what exact error message did you see?
02:41:39 <quicksilver> (I don't think the bugs in 6.8.2 will bother most users)
02:41:45 <uhu> I have a code from somewhere with import Text.ParserCombinators.Parsec.Language (emptyDef)
02:43:06 <uhu> the output is Could not find module 'Text.ParserCo....Language' .... Failed, modules loaded: none
02:43:25 <quicksilver> check ghc-pkg list
02:43:38 <paolino> quicksilver: what does it mean using the right strategies instead of making broken NFData instances ? Can you explain more , plase ?
02:44:13 <quicksilver> paolino: an NFData instance should reduce a value to full Normal Form
02:44:18 <quicksilver> that's the purpose of the class.
02:44:37 <quicksilver> if you want something else, rather than writing a broken NFData instance, you should combine strategies using the combinators in Control.Parallel.Strategies.
02:45:15 <paolino> mh, so not using rnf I suppose
02:45:20 <uhu> what should ghc-pkg list? text... ?
02:46:11 <quicksilver> uhu: it's fairly self explanatory
02:46:25 <quicksilver> uhu: it shows a list of packagse. You want ot check parsec-2.1.0.0 is in that list.
02:46:31 <quicksilver> and not in () .
02:46:49 <uhu> yes parsec is listed
02:47:36 <abtronic> does anyone here happen to know how to get 'ghc --make' to stop sending normal progress output to stderr? this is kind of trivial, but annoying
02:48:35 <uhu> if I import Text.ParserCombinators.Parsec.Language do I need parsec-2.1.0.0?
02:48:43 <blackh> uhu: Not sure if this is useful, but there are two major versions of parsec with lots of incompatibilities between them.  It could be that whatever you're building wants version 3 (iirc).
02:49:03 <quicksilver> no, Text.ParserCombinators.Parsec.Language is in 2.1.0.0
02:49:14 <quicksilver> and his erro message says it can't find the module
02:49:17 <viator_sg> abtronic: ghc -make xxx 2> /dev/null
02:49:36 <quicksilver> uhu: my other question - did you restart ghci since installing the package?
02:49:39 <abtronic> viator_sg, yes, but that throws away error output in the case there really is an error
02:50:26 <abtronic> I would like to redirect stdout, but capture stderr for actual errors. most build tools usually have this behaviour
02:50:58 <sohum> why would I be getting an overlapping instances error even when I've enabled -XOverlappingInstances?
02:51:08 <uhu> aha....good point....stupid me
02:51:09 <viator_sg> abtronic: sorry, i cant help then. You can try using a pipe and a script
02:51:28 <abtronic> viator_sg, np, thanks
02:53:58 <quicksilver> sohum: depends on the error, and which modules you enabled the extension for.
02:55:12 <sohum> quicksilver: which modules?
02:56:11 <sohum> quicksilver: both overlapping instances mentioned in the error are defined in the file which has -XOverlappingInstances enabled, if that helps.
02:57:09 <jlouis_> abtronic: I guess your problem is not solved by 2>&1 either then
02:58:38 <abtronic> jlouis, no. I think it can only be solved outside ghc by a filter that can decide which stderr output is really errors and which is just progress (or perhaps throws away stderr if ghc exits with 0)
02:59:23 <abtronic> but it would make more sense to me if ghc just sent its progress output to stdout like sane programs :) never mind I guess I am the only one who is pedantic enough to be bothered by it
03:02:05 <paolino> I don't see a parSort, is this a difficult task ?
03:02:29 <quicksilver> sohum: I think you probably need the extension at the point of use, too. I'm not sure.
03:02:41 <Axman6> paolino: not at all, it's rather easy in fact :)
03:02:50 <sohum> quicksilver: hm. well, the point of use is in ghci....
03:02:57 <Axman6> paolino: but, it can consume a lot of memory
03:03:11 <quicksilver> sohum: I think ghci inherits the flags of the module you :load
03:03:35 <paolino> Axman6: I cannot guess it
03:04:54 <sohum> quicksilver: yep. also, moving the definition to the same file doesn't help.
03:05:36 <Axman6> paolino: hmm, i had a rather nice version of it somewhere a while ago, but i seem to have deleted it. i'll try and write it again if you like :)
03:05:36 <quicksilver> sohum: then we need to see the source and the error to help you I think.
03:06:00 <jlouis_> abtronic: I don't think the fix is trivial
03:06:09 <jlouis_> abtronic: But I only glanced at the code
03:06:14 <paolino> Axman6: my code spends most of the time in sorting
03:06:22 <paolino> I found out
03:06:23 <Axman6> paolino: well, maybe i can help you :)
03:06:36 <quicksilver> sohum: overlapping instances can't necessary resolve all cases
03:06:43 <paolino> I found this http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg14381.html
03:08:17 * hackagebot upload: Chart 0.12 - A library for generating 2D Charts and Plots (TimDocker)
03:10:22 <paolino> Axman6: it is better then sort in CPU usage, but CPU's are used unsymmetrically, strang
03:11:09 <flw> @pt
03:11:10 <lambdabot> Maybe you meant: ft pl
03:11:18 <flw> ft pl
03:11:26 <flw> @ft
03:11:28 <lambdabot> Done.
03:11:47 <flw> @pl func1 x l = map ( \y -> y*x ) l
03:11:47 <lambdabot> func1 = map . (*)
03:12:01 <flw> @pt func1 x l = map ( \y -> y*x ) l1
03:12:02 <lambdabot> Maybe you meant: ft pl
03:12:05 <flw> @pl func1 x l = map ( \y -> y*x ) l
03:12:05 <lambdabot> func1 = map . (*)
03:12:22 <flw> @pl func2 f g l = filter f (map g l)
03:12:23 <lambdabot> func2 = (. map) . (.) . filter
03:12:40 <flw> func3 f l = l ++ map f
03:12:46 <flw> @pl func3 f l = l ++ map f
03:12:46 <lambdabot> func3 = flip (++) . map
03:13:43 <sinelaw> i love it when someone sends an email "Although I never send spam, this is really important......"
03:18:04 <sohum> quicksilver: http://haskell.pastebin.com/d4c5cce4c
03:18:38 <sohum> quicksilver: sorry, http://haskell.pastebin.com/d2cbd31a2
03:21:20 <quicksilver> sohum: neither of those instances is "more specific" than the other in the sense that overlapping instances require.
03:21:53 <quicksilver> for the purposes of overlapping instances, "more specific" means, roughly, more concrete types.
03:22:01 <quicksilver> like, [a] is more specific than b
03:22:09 <quicksilver> "m f" is not more specific than "a"
03:22:10 <sohum> I see
03:22:38 <sohum> is there a way to get it to pick arbitrarily in that case?
03:22:47 <sohum> alternatively, what would you suggest?
03:22:53 <quicksilver> IncoherentInstances
03:23:03 <quicksilver> not strictly arbitrary, I don't think.
03:23:22 * hackagebot upload: moe 2009.11.3 - html with style (JinjingWang)
03:23:23 <sohum> Incoherent doesn't help
03:23:28 <quicksilver> I don't claim to understand either of Overlapping/Incoherent very well, I consider them both badly broken.
03:23:36 <Axman6> paolino: ok... i think i finally have something that might work...
03:24:14 <sohum> quicksilver: broken?
03:24:36 <sohum> and yea, -XIncoherentInstances changes nothing
03:24:52 <quicksilver> sohum: yes, broken.
03:25:03 <quicksilver> they are incompatible with polymorphism, and they break composability.
03:25:23 * hackagebot upload: bamboo-theme-mini-html5 2009.11.3 - bamboo mini html5 theme (JinjingWang)
03:25:41 <dancor> whatever they've saved my life
03:25:53 <Axman6> paolino: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11502#a11502
03:26:25 <sohum> quicksilver: hmm.
03:27:12 <Axman6> anyone have any suggestions to make about http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11502#a11502 ?
03:27:27 <sohum> quicksilver: my eventual goal is to show that type constructors are in most cases unnecessary
03:27:36 <sohum> quicksilver: well, attempt to show
03:27:43 <quicksilver> I can see vaguely what you're doing.
03:27:51 <quicksilver> I think you might get a little further using type families
03:28:06 <quicksilver> I'm not sure if you'll manage to get all the way without a few newtypes to help things along
03:28:20 <sohum> quicksilver: like, with the current code and datatypes, you can say (c "foo") :: Maybe [Json] and get back Just [JsonString "foo"]
03:28:26 <Jafet> Axman6, using the built-in sort where possible?
03:28:40 <Axman6> heh
03:28:54 <sohum> quicksilver: the idea being that the Just, the [], and the JsonString are all unnecessary for the user to specify
03:29:01 <Axman6> actually, last time i wrote that function, it ended up being faster than the built in one, for random lists at least
03:29:26 <Jafet> Of course, life is made of random lists
03:29:29 <Jafet> So that's ok
03:29:33 <Axman6> yup
03:29:44 <sohum> quicksilver: this is meant to work in a context where the compiler does something similar to how ghci wraps fromIntegral around numeric literals, and creates the instances when a type is defined
03:30:21 <Axman6> hmm, if i replaced qsort with Data.List.sort in the < threshhold case, that would give the same results right?
03:30:24 <Jafet> @hoogle sort
03:30:25 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
03:30:25 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
03:30:25 <lambdabot> Data.ByteString.Char8 sort :: ByteString -> ByteString
03:30:31 <Jafet> I would hope so.
03:30:36 <Axman6> me too
03:30:46 <Jafet> Is it an exact replacement though wrt. stability?
03:30:52 <sohum> Axman6: the only differences might be issues of stability
03:31:13 <Axman6> bah! stability is overrated ;)
03:31:23 <Jafet> Exercise for the reader!
03:31:37 <Jafet> > sort [1..100000]
03:31:39 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
03:31:42 <Jafet> > sort [1..1000000]
03:31:45 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
03:32:02 <Jafet> Strange, it seems slower here
03:34:12 <Axman6> well, this one isn't tested, and i wrote it from memory
03:35:57 <Axman6> Jafet: well, replacing qsort with Data.List.sort seems to produce the same results
03:36:05 <Axman6> which makes sense...
03:36:25 * hackagebot upload: timeplot 0.1 - A tool for visualizing time series from log files. (EugeneKirpichov)
03:36:43 <Axman6> but... i'd need to test something that might not be stable when sorted..
03:37:41 <quicksilver> take a bunch of random floating point numbers and sort them by their integer comopnent?s
03:37:46 --- mode: quicksilver set -o quicksilver
03:40:26 * hackagebot upload: timeplot 0.1.1 - A tool for visualizing time series from log files. (EugeneKirpichov)
03:42:10 <paolino> Axman6: still uneven CPU usage
03:42:44 <Axman6> are you compiling with -threaded, and running your program with +RTS -N2 -RTS?
03:43:04 <paolino> ah, not setting the RTS
03:43:09 <paolino> :-/
03:43:27 * hackagebot upload: timeplot 0.1.2 - A tool for visualizing time series from log files. (EugeneKirpichov)
03:43:44 <Axman6> well, you'll need to do that to get the parallel runtime :)
03:44:26 <paolino> no difference
03:44:34 <Axman6> really? how odd
03:44:49 <eevar2> might want to run with N being 2-4x the # of cores you have
03:46:09 <eevar2> there might be a little more context switching, yea, but overall it still yields better paralellization for me
03:46:16 <Axman6> with 6.10 at least, it's often better to use <num cores>-1 (seems slow down a lot when you have -N<num cores>
03:46:30 <luite> eevar2: you may want to try ghc 6.12 then
03:46:33 <fasta> The Windows version of GHC only searches in \bar\foo directories, not in /bar/foo. Is there a flag to tell it that it should?
03:46:43 <Axman6> but, if you only have two cores, it's best to use -N2
03:47:11 <paolino> 2 cores here
03:47:21 <paolino> 6.10.4
03:47:37 <luite> eevar2: it has more efficient sparks, I get better performance with -N4 on 6.12 than with -N8 on 6.10  (quad core)
03:47:57 <Axman6> luite: hooray :)
03:47:59 <eevar2> okies. looking forward to 6.12
03:48:19 * Axman6 isn't game enough to try 6.12, especially without cabal-install
03:48:55 <luite> yeah it's somewhat annoying, having to install packages by hand for each new build
03:50:15 <paolino> mh, I havo no difference in CPU usage with or without -threaded also
03:50:42 <XXcXX> ? want to use ie tab on opera
03:50:57 <XXcXX> how am i use
03:51:07 <Axman6> XXcXX: i think you're in the wrong place
03:51:09 <sohum> hm. ok, using typeable is probably not the best idea.
03:51:24 <Axman6> this is a channel about the programming language Haskell, and has nothing to do with IE or opera
03:51:26 <sohum> what are the haskell basetypes? Char, Bool, some stuff in the Num hierarchy...
03:52:09 <Axman6> paolino: if you're using my code, try changing threshhold to be 2^6 or something
03:52:13 <Axman6> > 2^6
03:52:15 <lambdabot>   64
03:52:17 <jlouis_> sohum: I think that is somewhat floating. Is forall a . [a] a base type?
03:52:18 <Axman6> yeah...
03:52:28 <ivanm> preflex: seen dcoutts
03:52:29 <preflex>  dcoutts was last seen on #haskell 1 hour, 18 minutes and 38 seconds ago, saying: fasta: you have the power to break all the rules :-)
03:53:05 <Axman6> hello again XXcXX
03:53:25 <sohum> jlouis_: hm. it isn't, I'd say, because it builds on other types
03:53:38 <Axman6> sohum: but it's built into the language
03:53:56 <sohum> and so is Maybe a
03:53:57 <paolino> Axman6: not better
03:54:08 <sohum> but Maybe a is clearly a non-base type around a
03:54:16 <sohum> I'd say, if you could build an ADT for the type, then it's not a base type.
03:54:26 <sohum> the axioms of the type system, if you will.
03:54:29 <ivanm> sohum: I would say the unboxed types are the base types ;-)
03:54:36 <Axman6> would you conside Bool to be a base type then?
03:54:36 <sohum> :P
03:54:38 <Axman6> @src Bool
03:54:39 <lambdabot> data Bool = False | True deriving (Eq, Ord)
03:54:51 <ivanm> Axman6: don't be ridiculous!
03:54:58 <quicksilver> you could build an ADT for Int, syntax issues aside
03:55:03 <ivanm> it's obvious that they're just wrappers around integers like in all other languages! :p
03:55:08 <Axman6> booleans aren't even fundamental to computer science!
03:55:09 <ivanm> quicksilver: an infinite ADT?
03:55:09 <paolino> Axman6: with -N9 it uses both evenly
03:55:10 <quicksilver> data Int = I0 | I1 | I2 | I3 | I4 | I5 .....
03:55:15 <ivanm> Axman6: of course not!
03:55:15 <quicksilver> ivanm: no, Int is a finite type.
03:55:17 <Axman6> paolino: good!
03:55:22 <ivanm> quicksilver: oh, right
03:55:23 <ivanm> duh
03:55:29 <sohum> hrrrm. good point
03:55:34 <ivanm> quicksilver: OK, with a hell of a lot of constructors then ;-)
03:55:39 <quicksilver> yes.
03:55:50 <sohum> ok, new definition
03:55:55 <ivanm> Axman6: I note that no-one has thought it worth responding to your #hackage post on reddit ;-)
03:56:39 <Axman6> ivanm: it's such a fantastic idea, no one's questioning it
03:56:53 <sohum> anything which can't be built as an ADT without type variables is a basetype
03:57:08 <ivanm> Axman6: heh
03:57:11 <sohum> bah. anything that needs type variables isn't.
03:57:13 <jlouis_> I am mostly with ivanm here. The unboxed types can be seen as the primitive base types of the language
03:57:20 <ivanm> so how many people have actually been conned^W converted into joining? ;-)
03:57:33 <jlouis_> but it really depends on what king of type system encoding you layer on top of Haskell
03:57:36 <jlouis_> kind
03:57:51 <Axman6> jlouis_: unboxed types aren't really part of the language though, they're primitives to the compiler
03:58:04 <sohum> jlouis_: unboxed typ - ninja'd
03:58:42 <coco`>  I'm seeing this on 6.12.1rc1: /usr/bin/ld: cannot find -lHSffi_p
04:00:02 <sohum> I guess what I'm looking for is Typeable0
04:01:11 <jlouis_> Had this been SML, I would just have pointed you to the definition :)
04:02:25 <jlouis_> http://www.haskell.org/onlinereport/basic.html is a start, but lacks formalism :)
04:05:25 <sohum> I think this list of instances, at http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html , is what I'm looking for
04:05:46 <sohum> but Typeable a brings in higher order Typeables as well
04:06:07 <jlouis_> first order typeables then, hehe
04:06:31 <sohum> yep.
04:06:50 <sohum> hm, source
04:07:29 <sohum> @source Data.Typeable
04:07:30 <lambdabot> http://darcs.haskell.org/packages/base/Data/Typeable.hs
04:09:56 <sohum> macros what
04:24:55 <mxc> ?pl   liftIO getFastTimeOfDay >>= \t -> modify (\s -> s { lastSentMsg = t })
04:24:56 <lambdabot> (line 1, column 51):
04:24:56 <lambdabot> unexpected "{"
04:24:56 <lambdabot> expecting variable, "(", operator or ")"
04:25:20 <mxc> ?pl   liftIO getFastTimeOfDay >>= (\t -> modify (\s -> s { lastSentMsg = t }))
04:25:20 <lambdabot> (line 1, column 52):
04:25:20 <lambdabot> unexpected "{"
04:25:20 <lambdabot> expecting variable, "(", operator or ")"
04:25:53 <mxc> ?pl   liftIO getFastTimeOfDay >>=  \t -> modify \s -> (s { lastSentMsg = t })
04:25:53 <lambdabot> (line 1, column 43):
04:25:54 <lambdabot> unexpected "\\"
04:25:54 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
04:25:58 <ivanm> mxc: doens't recognise records
04:26:08 <mxc> ah
04:26:31 <burp> @hoogle cairo
04:26:33 <lambdabot> No results found
04:26:37 <ivanm> burp: gtk2hs
04:26:56 <burp> ah ok
04:28:13 <mxc> can haskeline and multithreaded hscurses drawing play nicely together, or is that  lost cause?
04:28:37 <ivanm> no idea
04:28:39 <Jafet> curses is a lost cause
04:28:48 <Axman6> long live guis?
04:29:01 <mxc> GUIs are great, for the user
04:29:06 <KaLPo> Hi!
04:29:09 <KaLPo> How should I configure my .emacs file in arch linux for gettin haskell-mode to work
04:29:13 <mxc> but for hte programmer... i'm still a fan of CLIs
04:29:15 <KaLPo> I have installed the packages from pacman
04:29:24 <Jafet> Programmers are users too!
04:29:33 <Jafet> http://www.ok-cancel.com/comic/4.html
04:29:41 <ivanm> KaLPo: read the README that comes with it
04:29:51 <KaLPo> where can I find it
04:29:57 <KaLPo> I mean
04:30:02 <KaLPo> the installation is automatic
04:30:05 <jlouis_> guess: /usr/share/doc/haskell-mode
04:30:12 <blackdog> curses _is_ a gui, isn't it?
04:30:21 <KaLPo> All right I'll see
04:30:41 <Jafet> curses is named after what it causes the programmer to produce when he is forced to write against it.
04:30:51 <SamB_XP> mxc: ever heard of an orthodox file manager ?
04:31:03 * ivanm refrains from fully mentioning the acronym that starts with RT and ends with M
04:31:04 <ivanm> ;-)
04:31:22 <SamB_XP> read the fine manual ?
04:31:30 <SamB_XP> Jafet: uh oh
04:31:36 <Axman6> Jafet: heh
04:31:39 <SamB_XP> the "write against" language is a bad sign!
04:31:40 <mxc> samb_xp: nope, whats that?
04:31:58 <mxc> jafet - i'm actually the primary user
04:32:01 * mux ponders replacing xhtml with moe, since the latter supports bytestrings
04:32:04 <mxc> primary/only
04:32:10 <ivanm> SamB_XP: yeah, that one
04:32:20 <SamB_XP> mxc: it's a file manager that uses BOTH a CLI and a GUI
04:32:43 <SamB_XP> like Midnight Commander
04:32:51 <Exteris> or gnome commander ;p
04:32:58 <mxc> ah
04:33:17 <mxc> i was thinking of having one terminal window for control (haskeline) and one for the live updating
04:33:22 <KaLPo> There is no /usr/share/doc/haskell-mode or similar :(
04:33:28 <mxc> just communicate w/ a messaging system i already have in place
04:33:33 <Jafet> It's Norton Commander, good sirs
04:33:59 <SamB_XP> Jafet: but the Windows version is no good :-(
04:34:02 <jlouis_> KaLPo: you can grab one from the 'net: http://www.haskell.org/haskell-mode/
04:34:03 <KaLPo> I have got a folder /usr/share/emacs/site-lisp/haskell-mode
04:34:20 <KaLPo> full if .el files
04:34:27 <jlouis_> It should be KaLPo !
04:34:28 <mxc> right now, i handle each input char manually w/ curses
04:34:33 <mxc> PITA
04:34:35 <KaLPo> but i have no idea of how to link them with emacs
04:35:04 <ivanm> KaLPo: did you install it via pacman (or whatever the PM is called in arch)?
04:35:40 <KaLPo> yes
04:35:42 <KaLPo> pacman
04:35:50 <SamB_XP> ivanm: Supreme Dictator, I think
04:36:04 * ivanm doesn't get it...
04:36:14 <SamB_XP> think about other meanings of PM ;-P
04:36:28 <ivanm> prime minister?
04:36:28 <byorgey> KaLPo: there's no README file in there?
04:36:35 <SamB_XP> ;-)
04:36:42 <ivanm> KaLPo: this? http://www.archlinux.org/packages/community/any/emacs-haskell-mode/
04:37:27 <byorgey> KaLPo: http://code.haskell.org/haskellmode-emacs/README
04:39:48 <ivanm> @tell roconnor I might give up on X11Colours and specifically use the ones that graphviz accepts in graphviz itself since there seems to be no clear consensus about what those colours are (since I need it for graphviz, and it has about another 80 than what the actual X11 colour files contain...)
04:39:48 <lambdabot> Consider it noted.
04:40:40 <SamB_XP> ivanm: doesn't it accept RGB triples as well ?
04:40:50 <KaLPo> I've got it!!!!
04:40:53 <ivanm> SamB_XP: graphviz? yes
04:41:01 <KaLPo> thank you, i just forgot the (load)
04:41:04 <ivanm> but I wanted the library to have a type-safe way of using the named colours
04:41:07 <KaLPo> thanks a lot!
04:44:50 <Jafet> ...why does ubuntu's haskell-mode package depend on it's ghc package
04:48:47 <fasta> Jafet, because they are not aware that hugs exists?
04:50:00 <Jafet> Well, the actual reason is probably related to the fact that their packages system is retarded, but I'm mostly annoyed because they haven't even updated ghc yet
04:52:51 <byorgey> anyone else having trouble with cabal-install not seeing the latest packages from hackage?
04:52:59 <byorgey> yes, I did 'cabal update'
04:58:21 <ivanm> byorgey: what kind of latest?
05:00:59 <ivanm> byorgey: "cabal list timeplot" says 0.1.2; AFAIK that's the latest...
05:01:47 <ivanm> yup, it is
05:01:52 <ivanm> byorgey: so it works here
05:07:27 <Jafet> The awkward squad paper is surprisingly good reading
05:08:14 <Jafet> Of course I skipped all the formal grammar, but that's just details.
05:08:45 <atollena> hi
05:09:18 <SamB_XP> Jafet: I was thinking of the "functional semantics for the awkward squad" paper
05:09:28 <quicksilver> Jafet: it is, yes.
05:09:37 <quicksilver> Jafet: there are lots of surprisingly readable papers in the haskell canon.
05:09:46 <SamB_XP> note: that isn't the actual title, in all likelyhood
05:09:57 <ivanm> Jafet: so.... you skipped half the paper? :p
05:10:09 <SamB_XP> oh ... I was thinking that in #coq, though ;-)
05:10:24 <Jafet> Uhh, the less important half!
05:10:31 <Jafet> I concern myself with ideas!
05:10:57 <fasta> quicksilver, the fundeps paper is not one of them, and the practical rank-n paper is full of bugs.
05:11:10 <fasta> quicksilver, but otherwise, most of it is quite comprehensible.
05:11:22 <byorgey> ivanm: yeah, it turns out for some reason 'cabal update' SAYS it's downloading a new package index file... but doesn't actually save it anywhere.
05:11:29 <byorgey> I still have no idea why this is happening.
05:11:32 <quicksilver> full of bugs doesn't make things unreadable though :)
05:11:43 <quicksilver> it is a shame I agree.
05:12:10 <SamB_XP> fasta: that's probably why Haskell' was postponed indefinately ;-P
05:12:32 <ivanm> byorgey: heh
05:12:42 <SamB_XP> the fundeps paper not being readable, I mean
05:13:05 <atollena> i'm trying to use three monad transformers at a time, but in a function that takes this monad as parameter one of the monad operation ('get' from Reader) I get an error  "No instance for (Monoid SomeType)"
05:13:11 <ivanm> byorgey: is your saved one read-only for some reason?
05:13:37 <atollena> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11503#a11503
05:14:13 <byorgey> ivanm: nope, I checked that
05:14:20 <burp> rounding up the first digit, any elegant solution ideas? I can just think about some crappy read, show, read combination ... 230 -> 300, 1200 -> 2000 , 30900 -> 40000
05:14:30 <quicksilver> atollena: please add the error to the paste
05:14:40 <ivanm> byorgey: you didn't change your .config to use a mirror when hackage was down?
05:14:41 <Axman6> burp: if it works...
05:14:55 <quicksilver> atollena: but I suspect the problem is that AppResult is not a Monoid.
05:14:59 <atollena> quicksilver: ok
05:15:13 <fasta> There are a bunch of categories: - papers written by a true computer scientist with the utmost care for detail who takes pride in that - papers written by industry as a kind of white paper/advertisement - papers written to get to the quota of publishing - rush jobs - papers that are published because there was nothing else published - papers containing lots of symbols, but when you peel of all the layers of obfuscation are naked of any value - I am probably
05:15:13 <fasta>  missing a bunch of them. I obviously like the first category.
05:15:43 <quicksilver> I think its possible to have the utmost care for detail and still have mistakes
05:15:48 <quicksilver> humans are after all human
05:15:57 <oteren> about the detail and stuff
05:16:00 <fasta> quicksilver, ok, well, some guys appear to be quite inhuman.
05:16:08 <byorgey> ivanm: nope, I didn't touch anything as far as I know
05:16:14 <oteren> a great saying (imo), "if you cant write the algorithm on the back of a beer pad, its too complicated"
05:16:20 <oteren> ref: fibonacci heaps etc
05:16:20 <oteren> :p
05:16:33 <Botje> burp: divide by 10^(pred . length . show), round up, multiply?
05:16:43 <ivanm> byorgey: try mv ~/.cabal ~/.cabal-backup && cabal update ?
05:16:43 <quicksilver> atollena: you might try "instance Monoid AppResult where mempty = AppResult []; mappend (AppResult a) (AppResult b) = AppResult (a++b)
05:16:47 <Jafet> How much microdot print fits on the back of a beer pad?
05:16:49 <Botje> scrap the pred :)
05:16:50 <atollena> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11503
05:16:58 <oteren> haha Jafet :D
05:17:30 <quicksilver> atollena: yes, read m previous comments :) AppResult needs to be a Monoid to use it in WriterT.
05:17:31 <atollena> quicksilver: OK... but I don't get why AppResult should be a monoid in this case
05:17:39 <quicksilver> atollena: because that's how WriterT works.
05:17:41 <ivanm> oteren: so the alg behind nauty is too complicated? so we should dump it despite it being the best graph isomorphism alg for general graphs AFAIK?
05:17:41 <ivanm> ;-)
05:17:56 <oteren> i dont know what nauty is
05:18:02 <quicksilver> atollena: the Writer monad works with monoids.
05:18:05 <burp> Botje: that's fine, thx
05:18:07 <atollena> quicksilver: Ho... I see. Maybe I should read more about WriterT
05:18:14 <ivanm> @google nauty
05:18:16 <lambdabot> http://cs.anu.edu.au/~bdm/nauty/
05:18:17 <lambdabot> Title: The nauty page
05:18:19 <fasta> I don't subscribe to the beer pad saying. Some stuff simply is complicated.
05:18:20 <quicksilver> atollena: fortunately the monoid instancse for AppResult is obvious.
05:18:21 <ivanm> oteren: ^^
05:18:33 <SamB_XP> atollena: it, too, works with Monoids, if that isn't obvious ;-)
05:18:43 <fasta> Basically everything related to graphs and geometry is.
05:18:54 <Baughn> I've got some functions which do not actually do any IO, but do invoke STM and (notionally pure, but with state) foreign functions a lot. Is there any way to QuickCheck them?
05:19:06 <Baughn> unsafePerformIO is not an option, due to the STM
05:19:11 <fasta> 10KLOC of C++ to implement one conceptual efficient function is not odd.
05:19:14 <SamB_XP> what's a beer pad ?
05:19:22 <SamB_XP> fasta: hmm ?
05:19:27 <atollena> quicksilver: SamB_XP: Thanks, it helped.
05:19:43 <Baughn> SamB_XP: An apartment full of beer in various shapes and forms, usually including empty bottles
05:19:54 <SamB_XP> atollena: but Monoid is something you probably learned at your mother's knee, so don't worry about it ;-)
05:20:14 <Baughn> SamB_XP: http://images.absoluteanime.com/neon_genesis_evangelion/misato3.jpg <-- This would be a prime example
05:20:21 <SamB_XP> Baughn: lol
05:20:32 <SamB_XP> I don't even need to look at that to get it ;-)
05:20:35 <SamB_XP> the URL is enough
05:20:42 <Baughn> Yeah..
05:20:51 <fasta> SamB_XP, http://t3.gstatic.com/images?q=tbn:zSYLC2PrbubKIM:http://beercansrus.com/mcart/images/eaglealecoaster.jpg
05:20:57 <atollena> SamB_XP: actually I did.
05:22:13 <SamB_XP> like "oh, it doesn't matter whether I put (the blue lego on the red lego) on the green lego or the blue lego on (the red lego on the green lego)
05:22:29 <Baughn> Oh. Also, I'd like to quickcheck polymorphic functions that, by use of typeOf, behave quite differently depending on the passed type. Any way to autogenerate the quickcheck types?
05:22:45 * Baughn is plotting to take the "quickcheck abuser of the month" award
05:23:12 <SamB_XP> Baughn: huh -- you want to autogenerate the *types*?
05:23:45 <SamB_XP> fasta: ah. where is there room to write on that thing ?
05:23:59 <SamB_XP> Baughn: who got it last month ?
05:24:26 <Baughn> SamB_XP: A mister UnsafeLaunchMissles, I believe
05:24:48 <SamB_XP> what now ?
05:24:59 <Baughn> SamB_XP: It's not all too important - the typeOf code is "obviously correct", but.. yeah.
05:25:24 * Baughn is running out of haskell-mode bugs to fix, too. Whee!
05:25:25 <SamB_XP> how many different types does this work on, and does it conditionalize on the types ?
05:25:43 <Baughn> It works on all types, no conditionalizing. It's basically..
05:25:48 <fasta> SamB_XP, uh, are you joking?
05:26:00 <Baughn> send :: Binary a => a -> IO (), recv :: Binary a => IO a
05:26:08 <fasta> SamB_XP, I suggest you find a bar and find out. Bars are fun.
05:26:12 <SamB_XP> fasta: maybe I just don't have the scale right ...
05:26:33 <SamB_XP> I don't want to go to a bar. Also, I have no money.
05:26:33 <Baughn> They tag the messages with their type, the actual listener showes the messages into a Map Type TChan for recv to get
05:31:27 <Phyx->  hrm.. thinking of relavent tests to do is hard sometimes...
05:33:28 <temoto> !ping
05:34:20 <temoto> What's the name of   f n a = take n $ repeat a    ?
05:34:39 <Axman6> replicate
05:34:44 <temoto> Axman6: thank you.
05:34:48 <Axman6> > replicate 10 1
05:34:50 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
05:35:13 <EnglishGent> replicate money
05:35:18 <EnglishGent> (hey - it's worth a try!) :)
05:35:26 <Vanadium> illegal operation :<
05:35:29 <Axman6> > repeat "money"
05:35:30 <lambdabot>   ["money","money","money","money","money","money","money","money","money","m...
05:35:36 <EnglishGent> :/
05:35:41 <Axman6> > unwords . repeat $ "money"
05:35:43 <lambdabot>   "money money money money money money money money money money money money mo...
05:35:59 <temoto> > replicate 10 "-"
05:35:59 <Phyx-> isn't that the lyrics to the song of the apprentice?
05:36:00 <Baughn> > sequence $ repeat "money"
05:36:01 <lambdabot>   ["-","-","-","-","-","-","-","-","-","-"]
05:36:02 <lambdabot>   * Exception: stack overflow
05:36:14 <EnglishGent> replicate tea (earl_grey . hot)
05:36:16 <EnglishGent> :)
05:36:26 <Vanadium> :D
05:36:31 <burp> lol
05:36:36 <Phyx-> > replicate 10 "Phyx-"
05:36:37 <lambdabot>   ["Phyx-","Phyx-","Phyx-","Phyx-","Phyx-","Phyx-","Phyx-","Phyx-","Phyx-","P...
05:36:40 <burp> just like picard
05:36:47 <Phyx-> CLONES ATTACK!!!
05:36:53 <temoto> > putStrLn $ replicate 10 "-"
05:36:55 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
05:36:55 <lambdabot>         against inferred type...
05:37:01 <burp> tea, earl grey, hot .. bzzt
05:37:07 <temoto> What am doing wrong?
05:37:15 <temoto> ahh concat
05:37:20 <temoto> > putStrLn $ concat $ replicate 10 "-"
05:37:22 <lambdabot>   <IO ()>
05:37:26 <temoto> Great.
05:37:37 <oteren> Sam_XP: i believe its called a coaster as well
05:37:49 <Baughn> > print $ replicate 10 "-"
05:37:50 <burp> > concat $ replicate 10 "-"
05:37:50 <lambdabot>   <IO ()>
05:37:51 <lambdabot>   "----------"
05:37:56 <Zao> > 'l' : (concat $ replicate 3 "ol")
05:37:58 <lambdabot>   "lololol"
05:38:01 <temoto> Axman6: why did you use unwords, not concat?
05:38:11 <burp> > replicate 10 '-' -- why not
05:38:11 <Baughn> > sequence ["coffee","bar"]
05:38:12 <lambdabot>   ["cb","ca","cr","ob","oa","or","fb","fa","fr","fb","fa","fr","eb","ea","er"...
05:38:12 <lambdabot>   "----------"
05:38:15 <Axman6> > concat . repeat $ "money"
05:38:16 <lambdabot>   "moneymoneymoneymoneymoneymoneymoneymoneymoneymoneymoneymoneymoneymoneymone...
05:38:22 <Axman6> temoto: that's why
05:38:28 <temoto> I see, thanks.
05:38:49 <Baughn> > join . succ . replicate "money"
05:38:51 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
05:38:51 <lambdabot>         against inferred type ...
05:38:54 <Axman6> > unwords . words $ "hello there   this is an           odd sentense    "
05:38:56 <lambdabot>   "hello there this is an odd sentense"
05:39:02 <Baughn> > join . fmap succ . replicate "money"
05:39:03 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
05:39:03 <lambdabot>         against inferred type ...
05:39:15 <Axman6> Baughn: $
05:39:27 <Baughn> Axman6: I'm using . as fmap, there
05:39:30 <Baughn> BUt yeah
05:39:58 <Axman6> ... you're using replicate "money" ...
05:40:01 <Axman6> :t replicate
05:40:03 <lambdabot> forall a. Int -> a -> [a]
05:40:09 <Baughn> Er
05:40:14 <Baughn> I meant to repeat
05:45:34 <temoto> :t enumerate
05:45:35 <lambdabot> Not in scope: `enumerate'
05:45:59 <byorgey> ivanm: thanks for the suggestions, turns out it was a bug in the latest darcs version of cabal-install ;)
05:47:09 <temoto> Looking for something like   f xs = [ (n, x) | x -> xs, n -> [0..(length xs)] ]
05:47:36 <temoto> f [ "a", "b" ] = [ (0, "a"), (1, "b") ]
05:49:06 <quicksilver> > zip ["a","b"] [0..]
05:49:08 <lambdabot>   [("a",0),("b",1)]
05:49:13 <Axman6> temoto: f = zip [0..]
05:49:14 * quicksilver is not sure what temoto wants
05:49:16 <temoto> Oh great, thanks.
05:49:33 <Axman6> > zip [0..] ["1","2"]
05:49:34 <lambdabot>   [(0,"1"),(1,"2")]
05:49:53 <temoto> Yeah, this.
05:50:11 <quicksilver> > zip ["hi","temoto"] ["there","how are you?"]
05:50:12 <lambdabot>   [("hi","there"),("temoto","how are you?")]
05:50:56 <temoto> I got it, honestly. :)
05:52:05 * hackagebot upload: hsc3-process 0.2.0 - Create and control scsynth processes (StefanKersten)
05:52:47 <quicksilver> temoto: but I'm still having fun! Never stop while you're still having fun...
05:53:04 * Axman6 thinks this is good advice
05:53:32 * Botje waits for the arrival of cgizmo
05:56:24 <oteren> i need an online organizer
05:56:26 <temoto>     mapM_ (\(y,s) -> putStrLn $ (show y) ++ " |" ++ s) $ zip [0..] (ppBoard board)
05:56:34 <temoto> This crazy line works as i wanted.
05:56:38 <oteren> someone gimme an url
05:57:05 <temoto> I guess something could be extracted to `where` part.
05:57:25 <temoto> oteren: google.com/calendar ?
05:57:41 <oteren> yeah, was considering it
05:57:51 <oteren> are there no alternatives?
05:58:09 <infrared> oteren: like something from 37signals.com ?
05:58:51 <oteren> thats maybe a little heavy duto
05:58:58 <oteren> *duty
05:59:18 <oteren> something in between
05:59:24 <oteren> with more text storage capabilites than google calendar
05:59:31 <oteren> but less than that whole suite you just pasted
05:59:40 <infrared> private pastebin?
05:59:46 <oteren> :D
06:00:00 <eevar2> iCal! :p
06:00:10 <quicksilver> temoto: zipWith
06:00:18 <quicksilver> temoto: zip + map is zipWith
06:00:29 <quicksilver> temoto: zip + mapM_ is zipWithM_
06:00:37 <quicksilver> I think :) assuming that exists.
06:00:43 <quicksilver> @hoogle zipWithM_
06:00:44 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
06:00:48 <burp> good guess
06:00:53 <infrared> oteren: pastebin.com has private pastebins. and i also think the source is available if you want to host your own
06:01:07 <infrared> although private pastebins aren't passwd protected (i just read)
06:01:18 <quicksilver> temoto: zipWithM_ (\y s -> putStrLn $ show y ++ " | " ++ s) [0..] (ppBoard board)
06:05:24 <temoto> quicksilver: thank you!
06:06:04 <temoto> Do i need to import Control.Monad?
06:07:05 <quicksilver> yes
06:11:38 <temoto> http://codepad.org/1QdIWbf8  is this wrong or very wrong?
06:11:59 <temoto> I'm not sure i had to define instance of Eq.
06:12:19 <burp> you can derive it
06:12:31 <burp> and that show instance is not good
06:12:45 <burp> better also just derive it
06:13:38 <Axman6> temoto: data Step = StepStart | StepEmpty | StepHang | StepNo deriving (Eq)
06:13:42 <burp> if you need descriptions, do it with something else
06:16:12 <temoto> Axman6: deriving (Eq, Show) ?
06:16:20 <Axman6> yep
06:17:08 <temoto> Cool.
06:19:13 <temoto> deriving is great, i removed even more code.
06:19:17 * hackagebot upload: HDBC 2.2.1 - Haskell Database Connectivity (JohnGoerzen)
06:40:12 <Phyx-> I wonder how Haskell would fit into http://www.thealmightyguru.com/Humor/Docs/ShootYourselfInTheFoot.html
06:41:21 * hackagebot upload: HDBC-postgresql 2.2.0.0 - PostgreSQL driver for HDBC (JohnGoerzen)
06:41:36 <ToRA> I thought the standard one was you fire the gun, but nothing happens until you try and walk on your foot, at which point it explodes...
06:41:37 <Jafet> Shooting your foot is considered a side effect, so you end up creating a shot copy of your foot.
06:42:38 <Phyx-> LOL
06:42:50 <Baughn> You clone your foot, and put it in a box. When you open the box, the foot explodes.
06:43:22 <Jafet> Explodes? Sounds like the bullet semantics went awry.
06:43:46 <Phyx-> well. they weren't clearly defined! clearly, there needed to be some bullet laws
06:43:58 <ToRA> You want to test that the gun really does shoot your foot off, so you use quickcheck, and end up with a machine gun and 1000 different shot feet...
06:44:34 <Jafet> Then you move it to hugs, where it shoots you in the bottom.
06:44:43 <jystic> Jafet: lol
06:45:50 <jystic> You can't shoot yourself in the foot, but some of the cells inside your foot have a space leak, so your foot grows until it explodes.
06:46:03 <Baughn> unsafePerformIO shoot Foot: You shoot your foot. It works normally, until you try to look at it, at which point it acquires one or more bullet holes.
06:46:28 <Baughn> jystic: ..that calls for a cancer analogy
06:46:45 <jystic> Baughn: :)
06:46:53 <ToRA> unsafeInterleaveIO shoot Foot: Nothing happens, later you try printing to the console and OUCH
06:50:03 <Phyx-> hrm
06:57:58 <jlouis_> Haskell shoot foot could also be that you decide the foot is not monadic enough and hence use genetic engineering on it until it fits into the monad template library :)
06:59:56 <eldragon> jlouis_, is not genetic algorithm that you're saying? the computation of genetic algorithm is costuous, impredictable its termination.
07:01:56 <zygospasm> parse error: expected English, found Yoda
07:05:48 <fasta> dcoutts:  I get c2hs.exe: does not exist when I do cabal install hgeometric. When I do c2hs.exe enter, I see c2hs output. So, what's going on?
07:06:34 <dcoutts> fasta: you can see how cabal calls c2hs using -v, also check that your c2hs is a recent version
07:09:03 <fasta> dcoutts: the basic problem is that I run it in Cygwin. As a result Windows style paths are not being found.
07:09:35 <dcoutts> fasta: cabal and c2hs use windows style paths, so they should be compatible
07:09:53 <dcoutts> but if you pass it on the command line some non-path, then yes, that'd be a problem
07:11:07 <fasta> dcoutts: the issue is that it tries to call C:\foo\bar\c2hs.exe instead of some path of the form /foo/bar/c2hs.exe
07:11:22 <dcoutts> fasta: but that's correct
07:11:40 <dcoutts> fasta: cabal is calling c2hs directly, not through any shell
07:11:49 <dcoutts> so it must use windows paths
07:12:06 <fasta> dcoutts: ok, let me try it in cmd.exe
07:12:33 <fasta> dcoutts: when I run it in cmd.exe it is being found.
07:12:45 <dcoutts> run what exactly?
07:12:57 <fasta> c:\Users\fasta\AppData\Roaming\cabal\bin\c2hs.exe
07:13:15 <fasta> That's what cabal -v install shows
07:13:37 <dcoutts> presumably with some args, otherwise c2hs would not run
07:13:50 <dcoutts> and c2hs would not report "c2hs.exe: does not exist"
07:14:02 <dcoutts> it's a file that c2hs cannot find
07:14:10 <dcoutts> not that c2hs itself cannot be found
07:14:26 <fasta> dcoutts: ok, so why doesn't it say which file it cannot find?
07:14:35 <dcoutts> perhaps because the file is ""
07:14:45 <dcoutts> or because the error reporting is crap
07:14:49 <dcoutts> one or the other :-)
07:15:10 <fasta> c2hs.exe --include=dist\build --cppopts=-D__GLASGOW_HASKELL__=610 --cppopts=-Iincludes --output-dir=dist\build --output=Algebra\Geometric\Strip.hs .\Algebra\Geometric\Strip.chs
07:15:39 <fasta> That's the whole command, but I don't know how it interprets the \.
07:16:11 <fasta> If it just goes and look in exactly \ then it won't be found within Cygwin.
07:16:30 <dcoutts> fasta: my guess is that the gcc c2hs is using is different when you run it from cygwin
07:17:16 <dcoutts> fasta: if you run c2hs with -d trace it might give more insight
07:17:20 <fasta> dcoutts: good guess.
07:20:32 * hackagebot upload: delimited-text 0.1.5 - Parse character delimited textual data (StefanKersten)
07:21:34 * hackagebot upload: delimited-text 0.1.6 - Parse character delimited textual data (StefanKersten)
07:23:27 <skorpan> why has CharParser been removed in parsec3?
07:29:28 * CosmicRay uploads new HDBC packages.
07:29:33 <CosmicRay> finally the time issue is behind me.  I think.
07:30:35 * hackagebot upload: HDBC-sqlite3 2.2.0.0 - Sqlite v3 driver for HDBC (JohnGoerzen)
07:30:37 <Taejo> are there haskell bindings for libnotify?
07:30:46 <Taejo> or a Haskell implementation?
07:30:49 <dcoutts> Taejo: yes, kolmodin wrote some
07:31:00 <dcoutts> oh, wait, sorry, I read that as inotify
07:31:20 <dcoutts> CosmicRay: what trick did you go for in the end?
07:31:39 <CosmicRay> dcouts: dep on base >= 3 && <5, time >= 1.1.2.4 && < 1.1.3
07:31:44 <CosmicRay> err dcoutts even
07:31:59 <CosmicRay> then removed all the conditional compilation stuff.
07:32:14 <dcoutts> CosmicRay: nice, simple.
07:32:19 <CosmicRay> if I had known it was that simple I would have done it earlier ;-)
07:32:30 <Taejo> dcoutts: the protocol seems pretty simple, and we have a dbus library now, so I'm thinking of doing a pure-haskell implementation
07:32:31 <CosmicRay> I was confused about what the issue was.
07:32:40 <dcoutts> CosmicRay: I had assumed you were trying to support a wide range of versions
07:32:56 <CosmicRay> dcoutts: I am.  I guess I said "f*** that" finally :-)
07:33:02 <dcoutts> :-)
07:33:23 <CosmicRay> hdbc 2.1 still works on GHC 6.8
07:33:45 <CosmicRay> and hdbc 2.2 still would if you grab time 1.1.2.4 from cabal, in fact.
07:33:51 <dcoutts> CosmicRay: right
07:33:58 <dcoutts> which is what cabal install will do
07:34:04 <CosmicRay> right
07:34:27 <fasta> dcoutts: hmm, even using cmd.exe it doesn't work. Any other debugging options?
07:34:43 <dcoutts> fasta: did you try the c2hs -d trace one?
07:34:58 <fasta> dcoutts: yes, but it didn't help.
07:35:35 <dcoutts> fasta: so it fails immediately before running cpp/gcc ?
07:36:48 <fasta> c2hs -d trace ExpandedTypes.chs
07:36:48 <fasta> Attempting to read file `ExpandedTypes.chs'...
07:36:48 <fasta> ...parsing `ExpandedTypes'...
07:36:48 <fasta> ...successfully loaded `ExpandedTypes'.
07:36:48 <fasta> Invoking cpp as `cpp -x c ExpandedTypes.chs.h'...
07:36:49 <fasta> c2hs: does not exist
07:37:10 <fasta> dcoutts: that's where it fails.
07:37:40 <fasta> Maybe cpp doesn't exist.
07:38:27 <fasta> It's not in my path at least, but I am not sure whether that is needed. Still, it should simply say that cpp cannot be found then.
07:41:26 <dcoutts> fasta: ok, so the problem is that c2hs only reports part of the exception
07:42:51 <fasta> dcoutts: to know the exact problem would require an easy way to load it into ghci to see exactly what it is doing.
07:43:17 <dcoutts> fasta: on windows if you do System.Process.runProcess "foobar" [] Nothing Nothing Nothing Nothing Nothing
07:44:04 <fasta> dcoutts: ah, right, it should say foobar does not exist.
07:44:21 <fasta> dcoutts: oh, it does say that.
07:44:47 <dcoutts> fasta: but c2hs is currently just using ioeGetErrorString
07:44:56 <dcoutts> which actually only gives us a part of the error
07:45:17 <dcoutts> in particular it misses off the "runProcess: " bit
07:45:33 <dcoutts> which would have been the giveaway
07:45:52 <fasta> dcoutts: so, do you know what the real error message is that we are not seeing?
07:46:42 <dcoutts> fasta: yes: "cpp.exe: runProcess: does not exist (No such file or directory)"
07:47:00 <dcoutts> fasta: that's roughly what yoy get if you call show on the exception
07:47:15 <dcoutts> but c2hs calls ioeGetErrorString which only gives the "does not exist" bit
07:48:40 * hackagebot upload: HDBC-odbc 2.2.0.0 - ODBC driver for HDBC (JohnGoerzen)
08:12:45 <temoto> [corners game] There is a field [[Cell]]. I'm iterating all cells, looking for ways to make a move. Have function tryAllDirs which tries to make a move to all 4 directions, it returns tuple (StepEmpty, Just Coord) if destination coord is empty cell.
08:13:12 <fasta> dcoutts: the --with-PROG option is also not really clear: I expected this to work: cabal install --with-cpp=`which cpp-3.exe` hgeometric, but apparently --with-cpp means cpphs.
08:13:44 <dcoutts> fasta: cabal does not call cpp directly
08:13:46 <temoto> So filtering tryAllDirs by StepEmpty, i get all "simple" moves. That is move made by moving by single cell in some direction.
08:14:24 <fasta> dcoutts: no, I expected that it would just pass it on to other programs that might need it.
08:14:33 <dcoutts> fasta: right, file a ticket
08:14:44 <temoto> Now "complex" moves consist of StepStart - (StepHang-StepEmpty-StepHang...) - StepEmpty. StepHang is returned if destination cell is occupied.
08:14:50 <temoto> How to express that?
08:15:11 <dcoutts> fasta: ah, that's a "feature" of the command line parsing that unique prefixes are accepted, but it's perhaps not appropriate for program names to be completed in that way
08:15:19 <temoto> This possibly must be some kind of fold, but i can't make it.
08:15:40 <mnislaih> Why does haddock eat my curly brackets {} ?
08:15:54 <temoto> mnislaih: maybe shell does?
08:16:08 <mnislaih> temoto: shell ?
08:16:25 <temoto> mnislaih: i don't know how you use haddock.
08:16:35 <mnislaih> temoto: via Cabal
08:16:48 <temoto> If you run it like  program argument  , then shell may interpret braces.
08:16:52 <fasta> dcoutts: is there any alternative to specify a different cpp?
08:17:10 <quicksilver> mnislaih: it's a bug.
08:17:17 <quicksilver> mnislaih: I saw someone else complaining of it recently.
08:17:22 <quicksilver> mnislaih: I don't know if there is a workaround.
08:17:34 <dcoutts> fasta: sure, pass flags to c2hs, via cabal if necessary --c2hs-options=...
08:17:49 <mnislaih> quicksilver: probably there isn't, I 've tried all the combinations of markup
08:19:19 * int-e wonders how to make Cabal pass on -prof to ghc when compiling C files.
08:20:39 <int-e> (The C file in question would be code that uses Rts.h and depends on the RTS' closure layout)
08:21:16 <dcoutts> int-e: how about --ghc-options=-optc-prof ?
08:21:35 <dcoutts> easy! that's only two levels of escaping :-)
08:21:37 <int-e> dcoutts: I need the ghc option, -prof.
08:22:14 <dcoutts> int-e: oh, ok there's no way to tell cabal to use a flag but only when it's running commands in some context but not another
08:22:21 <int-e> dcoutts: and preferably it would do the right thing whether --enable-executable/library-profiling is turned on or off.
08:23:38 <dcoutts> int-e: so what's the problem exactly? you need to know when compiling .c files whether we want to talk to a profiling rts or a normal one?
08:25:01 <dcoutts> int-e: and how would passing -prof to ghc help with that? does it pass some extra cpp define to C code in that case?
08:25:26 <int-e> dcoutts: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11508#a11508
08:25:31 <int-e> dcoutts: yes it does
08:26:55 <dcoutts> int-e: ok then the solution is to make cabal call ghc with the -prof flag when cabal calls ghc to compile .c files
08:27:12 <dcoutts> int-e: if you write the patch now it can be included in version 1.8
08:27:55 <dcoutts> int-e: and add a comment to explain why the -prof for .c files, so that if/when we switch to compiling .c files with gcc directly then we'll pass the appropriate cpp defines too.
08:29:21 <skyhawk> cabal install network fails on windows box, error in configure step in network package, sh:runprocess: does not exist
08:29:41 <dcoutts> skyhawk: meaning you don't have msys's sh.exe available
08:29:50 <dcoutts> to be able to run the ./configure script
08:30:22 <skyhawk> dcoutts: ok thx, this channel is great
08:30:46 <dcoutts> skyhawk: the trick is not to recompile network, since you've got it installed already
08:31:21 <fasta> Invoking cpp as `/usr/bin/cpp-3.exe -x c Algebra/Geometric/Strip.chs.h'...
08:31:21 <fasta> c2hs.exe: does not exist
08:32:12 <fasta> dcoutts: I think mixing Windows and Cygwin applications is just asking for trouble.
08:32:24 <fasta> dcoutts: it would be nice if it would work, though.
08:32:25 <dcoutts> fasta: indeed, I don't use cygwin
08:32:35 <dcoutts> fasta: I use mingw and msys
08:33:01 <fasta> dcoutts: does that mix better?
08:33:04 <dcoutts> much
08:38:56 <EddyDean> I'm confused. There is a function that I can just call from GHCi, and it will print the results I need to the console, but when I put the function in main = do print fun it will complain about an ambiguous type variable
08:39:43 <travisbrady> EddyDean: print a $ between the print and fun
08:40:04 <EddyDean> Nope, doesn't solve it
08:40:21 <BONUS> what's the code
08:40:23 <EddyDean> also shouldn't be necessary, because it doesn't take any parameters
08:40:24 <travisbrady> can you paste the actual code?
08:40:26 <stepcut> I am recieving a file as a lazy bytestring over the network and saving to disk. What is the best way to limit the filesize, and return an error if the file turns out to be too big. I could use, L.take maxLength, to simply truncate the file, but that does not let me return an error....
08:41:15 <camio> stepcut, which network library are you using?
08:41:16 <EddyDean> The code is at http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4570#a4570
08:41:18 <Berengal> EddyDean, ghci does some extra defaulting that ghc doesn't. Your value is probably something like (Num a) => a
08:41:27 <EddyDean> I apologise for the mess :)
08:42:16 <EddyDean> Berengal: Nope, *Main> :t euler
08:42:16 <EddyDean> euler :: [[[([Int], [a])]]]
08:42:27 <stepcut> camio: hrm. I don't even know :) I am using happstack, so whatever it uses. I just end up with a Lazy.ByteString that I have to save to disk...
08:42:29 <benmachine> EddyDean: it's a good idea to add explicit type signatures to stuff
08:42:40 <benmachine> just, in general
08:42:48 <stepcut> I think I can just make a derivative of hPut that does what I want
08:42:54 <benmachine> what's your exact error message
08:43:18 <EddyDean>     Ambiguous type variable `a' in the constraint:
08:43:18 <EddyDean>       `Show a' arising from a use of `print' at 60.hs:6:8-18
08:43:18 <EddyDean>     Probable fix: add a type signature that fixes these type variable(s)
08:43:41 <camio> stepcut, I'm not familiar with that lib. If you don't find help here, haskell-cafe might be a better place to ask.
08:43:44 <EddyDean> Added type signature to the "euler" function, didn't solve anything
08:44:11 <EddyDean> Umm... Damn
08:44:11 <benmachine> hmm
08:44:24 <EddyDean> It did solve it, I messed up
08:44:29 <benmachine> aha
08:44:44 <stepcut> camio: well, it's mostly a bytestring question -- have to save a lazy bytestring with out forcing the whole thing first. I think I figured it out though
08:44:45 <EddyDean> Thanks for your help (again) :)
08:45:14 <EddyDean> Although my program still doesn't do what it's supposed to do :)
08:46:29 <camio> stepcut, was the idea to do the "take" at the same time counting how many elements were left?
08:48:48 <stepcut> camio: no, I am just going to use foldrChunks to walk over the chunks in the lazy bytestring. I'll have an accumulator that tells me how many I have seen.
09:02:29 <int-e> dcoutts: ok, patch sent. It's lightly tested - i.e. I have tested that it has the desired effect with the cabal file I pasted.
09:02:45 <dcoutts> int-e: ta
09:07:19 <dcoutts> int-e: I wonder if longer term we should just call your kind of .c files as .hc files
09:07:29 <dcoutts> that depend on rts layout etc info
09:08:04 <int-e> dcoutts: that sounds reasonable. (and is probably easy to do along with adding support for CMM files, which seems to be related)
09:08:11 <dcoutts> right
09:08:30 <dcoutts> int-e: a tracker ticket to remind us is probably a good idea
09:09:33 <int-e> dcoutts: ok, will do that tomorrow.
09:09:41 <dcoutts> ta
09:10:12 * dcoutts pushes int-e's patch
09:13:38 <int-e> thanks
09:21:10 * hackagebot upload: monadloc 0.3 - A class for monads which can keep a monadic call trace (PepeIborra)
09:36:16 <Taejo> I'm using ghc 6.10.4 on ubuntu, and ghci doesn't handle home, delete and end keys (but up, down, left, right work as expected). Any ideas?
09:40:44 <dsouza> i believe this is not really related to ghci itself, but readline, isn't it? not sure if ghci uses readline, but I guess it does
09:40:58 <benmachine> depends on your version
09:41:04 <benmachine> recently switched to editline
09:41:07 <benmachine> err
09:41:08 <benmachine> haskeline
09:41:09 <benmachine> or
09:41:10 <benmachine> something
09:41:12 * benmachine doesn't remember
09:41:17 <benmachine> some switching was involved
09:41:25 <benmachine> editline is something completely unrelated I think
09:41:56 <Taejo> well I don't have the same problem with other programs that use readline, but I don't know about editline
09:42:05 <benmachine> ignore editline
09:42:09 <benmachine> I didn't say editline
09:42:11 <c_wraith> ghci used editline for a couple versions
09:42:12 <benmachine> I meant haskeline
09:42:14 <benmachine> oh
09:42:14 <benmachine> ok
09:42:19 <c_wraith> but for most of its history, it used readline
09:42:19 <benmachine> I'm confused
09:42:22 <c_wraith> and it uses haskeline now
09:42:26 <benmachine> right
09:42:53 <dsouza> now = >=ghc-10.x?
09:43:08 <Taejo> ldd /usr/lib/ghc-6.10.4/ghc doesn't mention either readline or editline
09:45:49 <c_wraith> I think 6.10.1 and 6.10.2 used editline
09:46:01 <c_wraith> Because those were when I was finding bugs with the ctrl-c handler
09:46:09 <c_wraith> (which editline didn't cooperate with)
09:46:22 <c_wraith> but 6.10.3 and 6.10.4 both use haskeline
09:49:28 <dsouza> ok. well, not sure if haskeline provides an .inputrc. I just noticed my HOME keys also don't work, but I'm so used to C-A, C-E etc. that i didn't noticed until now
09:55:57 <Saizan_> dsouza: http://trac.haskell.org/haskeline/wiki/UserPrefs
09:57:10 <dsouza> Saizan_: nice, thx. i googled for it and found a thread stating this was a feature to be added, obviously that was outdated already
09:58:28 <cygnus_> hi, i am wondering is haskell losing some popularity lately?
09:58:41 <cygnus_> i see a lot more stuff on python and ruby because of web sevices
09:59:04 <stoop> There was always a lot more Python an Ruby things when it comes to web applications, cygnus.
09:59:16 <stoop> Python and Ruby are both immensely more popular than Haskell.
09:59:20 <Saizan_> maybe dons stopped posting everything on programming.reddit now that there's haskell.reddit? :)
10:00:36 <cygnus_> is haskell having a good ws library?
10:00:49 <cygnus_> i really wanna get into haskell but i am not sure of the application
10:00:58 <byorgey> cygnus_: what is "ws" ?
10:01:26 <stoop> cygnus_, you should "get into" Haskell and make a decision for yourself.
10:01:39 <stoop> byorgey, "web services".
10:01:54 <cygnus_> well my primary interest at the moment is web services
10:07:13 <shaleny> hello, does anybody know a beautiful way of handling following situation?
10:07:13 <shaleny> suppose, I have record describing UI of a program. something like
10:07:13 <shaleny> data UI = UI { uiMain :: Window, uiButton :: Button }
10:07:13 <shaleny> There can be about 20 controls I want to control.
10:07:13 <shaleny> And I want to have a function getUI :: IO UI which returns this record populated with actual controls.
10:07:13 <shaleny> and I don't want to write following:
10:07:15 <shaleny>   getUI = do
10:07:17 <shaleny>      main' <- getMain
10:07:19 <shaleny>      button' <- getButton
10:07:21 <shaleny>      return UI { uiMain = main', uiButton = button' }
10:07:23 <shaleny> Is there a better way to do it ?
10:08:04 <ddarius> What do you want to write?
10:09:21 <shaleny> nothing so special, just a simple program using gtk2hs
10:11:12 <shaleny> I mean that I want a beautiful way of getting a IO UI when I have only functions that return IO values for each field of UI record
10:11:37 <ddarius> getUI = UI <$> getMain <*> getButton
10:12:03 <sproingie> <3 applicative functors
10:12:27 <saml> hola. is there pure haskell mp3 encoder?
10:12:27 <shaleny> oh, thanks
10:12:27 <shaleny> shame on me )
10:12:38 <saml> that is fast enough
10:12:55 <saml> or is it illegal to write an mp3 encoder?
10:13:07 <sproingie> don't frauenhofer's patents expire soon?
10:13:15 <blackh> saml: No and not in a civilized society
10:13:44 <blackh> saml: What I mean is ... no there isn't one written in Haskell as far as I know.
10:14:04 <Rotaerk> and if it's illegal in your country, that country isn't civilized?
10:14:20 <blackh> Rotaerk: Civilized countries are hard to find these days.
10:14:24 <sproingie> it's certainly not illegal to write one under any circumstances
10:14:31 <sproingie> distributing one might be a sticky wicket
10:17:29 <sproingie> hm, looks like some of the mp3 patents don't expire til 2017
10:18:39 <sproingie> tho 2012 looks like the cutoff date for the "legitimate" ones, the rest seem to be submarine patents
10:19:25 <Rotaerk> uh oh, they end in 2012??
10:19:31 <Rotaerk> another sign that the end is coming !!
10:20:01 <sproingie> mayan patent attorneys
10:20:13 <Rotaerk> :P
10:20:32 <sproingie> woot, haskell platform in debian
10:20:53 <sproingie> wonder if there's a repo for ubuntu?
10:21:10 <sproingie> otherwise it's another 6 months wait
10:24:40 <stepcut> is it possible to implement 'take' using 'foldr' such that it works on infinite lists?
10:24:47 <blackh> sproingie: You can install the Debian packages in Ubuntu with dpkg -i - at least the two that I tried worked OK.
10:26:30 <jlouis> stepcut: foldl perhaps
10:26:49 <roconnor> stepcut: take does recursion on 'n' not on the input list.  It doesn't seem right to use folds here.
10:26:51 <jlouis> stepcut: with some way to escape the the fold.
10:27:17 * roconnor ponders that
10:27:33 <roconnor> actually maybe I'm wrong
10:27:43 <roconnor> take is sort of a glorified zipWith
10:28:00 <roconnor> I guess it could do recursion on either parameter
10:28:11 <stepcut> jlouis: yes, it does not seem natural. :)
10:28:50 <stepcut> jlouis: ultimately, I am trying to figure how how to write, writeFileLimit :: Int -> FilePath -> Lazy.ByteString -> IO ()
10:28:58 <sproingie> blackh: those might work all right, i'm just wary of installing "foreign" packages in general though because the deps tend to get screwed up
10:29:12 <stepcut> well, it should return, IO Bool, indicating if the output was truncated or not
10:29:24 <blackh> sproingie: Another way would be to build it from source.  This should "just work".
10:29:55 <jlouis> stepcut: What is it supposed to do?
10:30:00 <blackh> sproingie: Perhaps I could just do it and then post the result. Are you on 9.10?
10:30:26 <stepcut> jlouis: write a lazy bytestring to disk, truncating it if it is longer than the specified length
10:32:15 <jlouis> stepcut: why won't BS.take n bs work ?
10:32:22 <jlouis> and then writing it
10:32:57 <twanvl> > let myTake = flip $ foldr (\x r n -> if n == 0 then [] else x : r (n-1)) (const []) in myTake 3 "abcdefg"
10:32:58 <lambdabot>   "abc"
10:34:05 <jlouis> I ponder of ByteString has something equal to Splices/Substrings in SML?
10:34:11 <jlouis> of/if
10:35:35 <sproingie> blackh: yep, i do at home.  here on my vps from work i have sid
10:35:40 <stepcut> jlouis: because I want to return a Bool indicating if it was truncated or not.
10:36:01 <sproingie> tho i can't really do serious haskell on my vps because it's only 256M
10:36:26 <sproingie> linker just kills it
10:36:32 <CosmicRay> heh
10:37:49 <sproingie> i tried a 6.12 binary, it wants libtinfo.so, and damned if i can find it
10:39:34 <Saizan_> there are two binary packages, and one doesn't need libtinfo, iirc
10:39:54 <ehamberg> had the same experience. i ended up building it from source which was *less* painful. :/
10:40:22 <blackh> sproingie: I'm on x86_64.  What are you using?  If you're on i686 you can build it for that.
10:40:32 <blackh> sproingie: I'll see if I can make a script.
10:40:33 <stepcut> twanvl: clever..
10:40:39 <sproingie> building it from source runs into similar problems as compiling anything else.  it never ends.
10:40:57 <jlouis> stepcut: is length too expensive for you?
10:40:58 <sproingie> i could probably build it offline and upload it, i just haven't gotten to it yet
10:41:21 <stepcut> jlouis: yes. It would force the whole lazy string into memory
10:41:36 <sproingie> blackh: x86_64 here too
10:46:03 <jlouis> stepcut: BS.splitAt n bs and then check if the snd is the empty string?
10:47:00 <stepcut> jlouis: hrm, that could work.
10:48:55 <stepcut> jlouis: assuming that writeFile does not return until the lazy string is written :-/
10:50:50 <Guest48445> hi, I'm working my way through RWH and I've got a newbie question, if anyone is willing to help
10:50:57 <ben_m> ask away
10:51:08 <zygospasm> > let take = flip $ foldr (\x f k -> case k of 0 -> []; (k' + 1) -> x:f k') (const []) in take 3 "foobar"
10:51:09 <lambdabot>   "foo"
10:51:14 <Guest48445> Basically, the question is, why won't this work: http://pastebin.com/d5239b5e5
10:51:21 <Guest48445> it's an exercise from the book
10:51:37 <Guest48445> I know I don't 'get it' yet, and am kind of floundering
10:51:55 * zygospasm notes that twanvl got largely the same answer :)
10:52:01 <stepcut> zygospasm: :p
10:52:41 <zygospasm> in my defence i got pulled into a meeting for about 25 minutes :)
10:53:35 <benmachine> nickknw: that won't work?
10:53:42 <benmachine> looks sensible to me
10:54:01 <benmachine> (excessive parentheses though: (xs) is fine as xs)
10:54:23 <nickknw> no, I get this error: "Couldn't match expected type `List t` against inerred type `a -> List a -> list a`"
10:54:30 <nickknw> inferred*
10:54:50 <ben_m> nickknw: Loads fine for me
10:55:05 <nickknw> yikes
10:55:07 <nickknw> oh
10:55:09 <ben_m> Maybe you specified incorrect types for the functions?
10:55:22 <nickknw> it only gives that error when you try to use toList
10:55:34 <nickknw> e.g.:   toList Cons 'a' Nil
10:55:48 <ben_m> Needs parantheses
10:55:49 <nickknw> which should return...  um, "a", I think
10:55:52 <ben_m> toList (Cons 'a' Nil)
10:56:04 <benmachine> or toList $ Cons 'a' Nil
10:56:08 <nickknw> holy crap
10:56:21 <nickknw> thank you very much
10:56:26 <nickknw> I feel very silly :)
10:57:03 <Vulpyne> If it helps, when you don't use the parenthesis, it's interpreted like: (((toList Cons) 'a') 'Nil')
10:57:31 <m0nkfish> can someone help me out
10:57:34 <m0nkfish> whats wrong with this:
10:57:35 <nickknw> that does help... now the error message actually makes sense to me too!
10:57:36 <m0nkfish> concatMap = concat . map
10:58:11 <monochrom> :t concat . map
10:58:13 <lambdabot>     Couldn't match expected type `[[a]]'
10:58:13 <lambdabot>            against inferred type `[a1] -> [b]'
10:58:13 <lambdabot>     Probable cause: `map' is applied to too few arguments
10:58:20 <jlouis> :t concatMap
10:58:21 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
10:58:37 <Will06> pl \x y -> x y
10:58:49 <Will06> > pl \x y -> x y
10:58:50 <lambdabot>   <no location info>: parse error on input `\'
10:59:10 <ben_m> @src concatMap
10:59:10 <lambdabot> concatMap f = foldr ((++) . f) []
10:59:40 <sproingie> @pl  \x y -> x y
10:59:41 <lambdabot> id
10:59:52 <Will06> > pl \x y -> (liftM x) . y
10:59:53 <lambdabot>   <no location info>: parse error on input `\'
10:59:57 <EvanCarroll> how come i can't do this in ghci "let factorial :: (Integral a) => a -> a; let factorial 0 = 1; let factorial n = n * factorial (n - 1)"
11:00:04 <sproingie> it's @pl
11:00:09 <Will06> ty
11:00:17 <Will06> @pl \x y -> (liftM x) . y
11:00:18 <lambdabot> (.) . fmap
11:00:27 <Will06> very interesting
11:00:44 <sproingie> you don't really want to double up on compose like that
11:00:48 <jlouis> :t \f -> concat . (map f)
11:00:49 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
11:00:50 <monochrom> let { factorial :: (Integral a) => a -> a; factorial 0 = 1; factorial n = n * factorial (n - 1) }
11:00:56 <Taejo> how do I generate haddocks with source links?
11:01:20 <sproingie> it'd be neat if there were an iterative @pl that did just one transformation at a time
11:01:45 <Will06> I just don't like liftM
11:01:51 <Will06> adds brackets to my code
11:02:04 <jlouis> sproingie: IIRC, and that is 4-6 years back, @pl actually just applies transformations iteratively
11:02:04 <shaleny> Taejo, --hyperlink-source
11:02:08 <monochrom> so you just don't like brackets
11:02:25 <Taejo> shaleny: thanks. can I put that in .cabal/config?
11:02:29 <Will06> good point
11:03:16 <jlouis> m0nkfish: your answer is partially hidden in the lambdabot interactions :)
11:04:09 <monochrom> I prefer to say "it is wrong because you didn't think through it"
11:04:37 <Hiato> Hello all, this should be a fairly painless one for ye haskell journeymen: I'm having typical noob typecasting problems, with IO stuff. If you can, please take a look: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11513#a11513
11:05:06 <Vulpyne> Hiato: You're not quoting your strings.
11:05:10 <dschoepe> Hiato: you need " around Current: and Count:
11:05:12 <Vulpyne> putStrLn "Current:" etc
11:05:15 <zygospasm> m0nkfish: concatMap f xs = concat $ map f xs
11:05:25 <Will06> @pl \x y z = x z (y z)
11:05:25 <lambdabot> (line 1, column 8):
11:05:26 <lambdabot> unexpected "="
11:05:26 <lambdabot> expecting pattern or "->"
11:05:36 <null_ptr> he. I have a newbie question: I want to write a function to sum two 8bit bins. So I have two lists as parameter and I compare every bit (step trough the list). But I cant find the way to hold the carry bit, and it's messy anyway. Any tips?
11:05:40 <Will06> @pl \x y z -> x z (y z)
11:05:40 <lambdabot> ap
11:05:42 <Hiato> Vulpyne: heh, nope, those are there, must've slipped up in the paste. The issue is with the (pp count) curr
11:06:08 <null_ptr> through
11:06:15 <shaleny> Taejo, unfortunately I don't know. Just looked at PKGBUILDS of haskell packages in arch linux. runhaskell Setup.hs haddock is called there explicitly.
11:06:18 <Botje> null_ptr: zip the two lists together, and use foldr.
11:06:27 <Botje> wait, no
11:06:28 <Botje> use foldl
11:06:28 <Vulpyne> What is the actual issue?
11:06:35 <Taejo> shaleny: thanks. I'll just have to try it.
11:06:44 <Hiato> Couldn't match expected type `IO b' against inferred type `[Int]'
11:06:46 <Will06> :t  \x y z -> x z (y z)
11:06:47 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
11:06:50 <Will06> :t ap
11:06:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:07:18 <Vulpyne> Oh yeah, cause you're in IO. You probably want to do return $ pp count curr
11:07:25 <Will06> @pl \x y z -> x z (y z)
11:07:25 <lambdabot> ap
11:07:36 <Vulpyne> Or return ((pp count) curr) if you want to keep your funky function invocation.
11:07:51 <Hiato> Vulpyne: Thank you so very much :)
11:08:01 <null_ptr> Botje: I have to implement it. fold is no option
11:08:38 <Botje> null_ptr: then use explicit recursion
11:08:53 <Vulpyne> hiato: That code probably won't do too much though.
11:08:55 <Botje> null_ptr: or reverse both lists, use a recursive procedure to make a new list, and reverse again
11:09:09 <Hiato> Vulpyne: nope. No output, any ideas?
11:09:09 <Vulpyne> Cause the result of pp isn't used.
11:09:22 <jlouis> null_ptr: it is a fairly cool exercise
11:09:24 <Vulpyne> What do you want it to do? Print out the result?
11:09:26 <zygospasm> m0nkfish: concatMap f xs = concat $ map f xs = concat $ map f $ xs = concat . map f $ xs; concatMap f = concat . map f = (concat .) (map f) = (concat .) . map $ f; concatMap f = (concat .) . map
11:09:32 <Hiato> Vulpyne: yep
11:09:51 <Vulpyne> blah blah in putStrLn $ show $ pp count curr
11:09:58 <jlouis> zygospasm: no f in the last expression
11:10:01 <jlouis> decl even
11:10:11 <Vulpyne> Or: blah blah in putStrLn (show (pp count curr))
11:10:49 <Hiato> Thank you, it all works now. Heh, I dig haskell
11:11:00 <Vulpyne> It's pretty sweet.
11:11:21 <null_ptr> jlouis: I feel more like ramming my head against a wall
11:11:42 <Hiato> Went from ~40 lines in py that took about 30secs to about ten in Haskell that takes about half that. Plus, it just looks and feels so much better
11:11:43 <Botje> null_ptr: the type sig for the explicit recursion thing would be [Int] -> [Int] -> (Int, [Int])
11:12:14 <Botje> of course reverse--sum--reverse is a lot easier :)
11:13:20 <Taejo> :t fromMaybe
11:13:21 <lambdabot> forall a. a -> Maybe a -> a
11:13:27 <jlouis> null_ptr: If i were to do it, I would probably begin with defining a 1-bit full adder in haskell and then put recursion on top of that
11:13:36 <jlouis> and use rev . sum . rev
11:14:06 <monochrom> f x y = g 0 x y where { g c (x:xs) (y:ys) = c `xor` x `xor` y : g (((x `xor` y) `and` c) `or` (x `and` y)) xs ys }
11:14:06 <adept> question: i know how to define (some) recursive functions using "fix". Am I right that I can't define with "fix" functions that follow the lines of "result is Map X Y. For all x if x is in result then leave it as is, otherwise x = someComputationInvolvingResult"?
11:14:09 <null_ptr> Botje: I do already reverse my numbers, so I will think about that again. Thanks for your ideas. Maybe I come back later to cry..
11:14:18 <monochrom> c plays the role of the carry bit
11:14:25 <Botje> null_ptr: keep it up, haskell is fun!
11:14:46 <null_ptr> Botje: That's so hard to believe
11:15:05 <Botje> ask anyone in this channel >:)
11:15:14 <Botje> @vixen is haskell fun?
11:15:15 <lambdabot> Ooh, functional programmers are so hot!
11:15:33 <jlouis> mmm
11:15:39 <jlouis> @vixen is haskell hard?
11:15:39 <lambdabot> church is my favourite computer scientist.
11:15:59 <monochrom> church is not even a computer scientist
11:16:12 <jlouis> monochrom: it is vixen, she is only 19
11:16:29 <camio> adept: As far as I understand every recursive function can be defined in terms of fix. That's how the meaning of recursive functions is determined.
11:16:59 <jlouis> adept: I am not sure I understand your example as is notated
11:17:00 * hackagebot upload: hesql 0.0 - Haskell's embedded SQL (ChristophBauer)
11:17:05 <mmorrow> , fix (k n -> if n < 10 then k (n+3) else n) 2
11:17:07 <lunabot>  luna: Pattern syntax in expression context:
11:17:12 <mmorrow> , fix (\k n -> if n < 10 then k (n+3) else n) 2
11:17:13 <lunabot>  11
11:17:17 <adept> adept will trie with more definite example. observe:
11:17:24 <adept> I want to color a graph
11:17:35 <adept> result would be Map Node Color
11:17:48 <adept> without fix, I proceed as following:
11:17:57 <adept> runStateT colorize Map.empty
11:18:10 <mmorrow> there're two uses of fix that should be distinguished, value recursion and "regular" recursion
11:18:20 <mmorrow> value recursion is like doing this
11:18:36 <adept> where colorize will mapM_ over all nodes, and for each node will look it up in state, and if it's not already there - color it and adjacent nodes using some rules.
11:18:41 <mmorrow> void *x[2]; x[0] = (void*)42; x[1] = x;
11:18:47 <adept> repeat until all nodes are iterated over.
11:18:56 <adept> I tried to do this with fix and failed :(
11:19:15 <mmorrow> that is, the value that "x" really is is a ptr to the as-of-yet-undefined piece of memory what you eventually compute will occupy
11:19:24 <mmorrow> , fix (\x -> 0 : x)
11:19:25 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
11:19:30 <mmorrow> , vacuum (fix (\x -> 0 : x))
11:19:34 <lunabot>  [(0,[1,0]),(1,[])]
11:19:58 <mmorrow> all that is is a ptr to an Int, and Int, and a ptr to []
11:20:02 <monochrom> http://www.vex.net/~trebla/haskell/fix.xhtml  tells you more or less mechanically how to convert code to use fix. Alternatively if you paste actual code (no natural language) I can do it  for you.
11:20:04 <adept> jlouis: does this make any sense?
11:20:52 <adept> monochrom: http://pastebin.com/f21910064
11:21:02 <mmorrow> adept: if you're using a monad, you'll probably want mfix
11:22:15 <monochrom> Only spread needs conversion.
11:22:31 <mmorrow> > let m = M.fromList [("a",["b","c"]),("b",[]),("c",["a"]))] in fix (\result -> foldl' (
11:22:32 <lambdabot>   <no location info>: parse error on input `)'
11:22:34 <mmorrow> crap
11:22:49 <jlouis> adept: much more than before
11:22:58 <mmorrow> > let m = M.fromList [("a",["b","c"]),("b",[]),("c",["a"]))] in fix (\result ->
11:22:59 <lambdabot>   <no location info>: parse error on input `)'
11:23:03 <mmorrow> grr, i can't remember that one
11:23:12 <monochrom> spread = fix (\s k v -> whenM (paint k v)              $ mapM_ (s (not k)) (g!v))
11:23:35 <mmorrow> i stumbled on a neat use of fix to eliminate a traversal over a Map when converting from a (Map a (Set a)) to an (IntMap (String,[Int]))
11:24:11 <mmorrow> with fix you only need a single traversal, because you can use the final result to look up, oh!
11:24:32 <mmorrow> gah, i'll just find it
11:25:01 <HayashiRazan> gah
11:26:36 <mmorrow> found it http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4571#a4571
11:27:14 <HayashiRazan> thx
11:28:03 <mmorrow> HayashiRazan: noprob
11:28:34 <monochrom> All dynamic programming examples in http://www.haskell.org/haskellwiki/Dynamic_programming_example can be written like that too. It's the same deal.
11:28:51 <mmorrow> totally
11:28:55 <adept> mmorrow: thnx, i'l try to understand that
11:29:25 <adept> monochrom: i have no problems with "ordinary" dynamic programming problems (that is, how to write them with fix)
11:30:04 <adept> @index mfix
11:30:05 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
11:30:08 <mmorrow> i realized i could just be using fix to eliminate a traversal when i found myself wishing i already had the result to be able to look up <i forget what exactly>
11:30:25 <adept> @src mfix
11:30:26 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
11:31:47 <trofi> :t (Control.Monad.mfix)
11:31:48 <lambdabot> Not in scope: `Control.Monad.mfix'
11:32:16 <adept> :t Control.Monad.Fix.mfix
11:32:17 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
11:34:37 <mmorrow> , runST (mdo x <- newSTRef 3; go <- newSTRef (do y <- readSTRef x; if y < 10243 then writeSTRef x (y+6) >> join (readSTRef go) else return y); join (readSTRef go))
11:34:38 <lunabot>  10245
11:35:29 <mmorrow> you can do stuff like read the STRef you're currently defining inside of its definition
11:36:15 <monochrom> http://www.haskell.org/haskellwiki/MonadFix  has more examples of mfix and mdo
11:50:15 <Egg_> can someone help me with a palindrom function I am writing please?
11:50:34 <mauke> preflex: 8ball can someone help Egg_?
11:50:34 <preflex>  it is decidedly so
11:50:49 <Egg_> haha
11:51:16 <Egg_> http://pastebin.com/m35dd7a2b
11:51:18 <Egg_> is my code
11:51:29 <Egg_> checvking if a string is a palindrome
11:51:32 <Egg_> with recursion
11:51:33 <mauke> wow, looks complicated
11:51:40 <mauke> doesn't work on empty strings
11:51:46 <Botje> Egg_: what's wrong with xs == reverse xs? :)
11:51:55 <mauke> head x:xs makes no sense
11:52:07 <Egg_> that's a good point
11:52:09 <Egg_> hahaha
11:52:33 <Botje> Egg_: also, why the x:xs everywhere?
11:52:39 <Botje> at a minimum it should be (x:xs)
11:52:51 <mauke> and then head (x : xs) = x
11:52:58 <Egg_> yeah
11:53:02 <Egg_> I'm not great at this :p
11:53:02 <mauke> head (reverse (x : xs)) = head (reverse xs) = last xs
11:53:21 <mauke> you can't add lists with +
11:53:29 <Egg_> does last xs return the last element in a list?
11:53:33 <mauke> yes
11:53:36 <Botje> what's remove supposed to di?
11:53:37 <Egg_> sweet
11:53:39 <Botje> *do
11:53:46 <mauke> length (x : xs) = 1 + length xs
11:53:47 <Egg_> it is checking if a string is a palindrome
11:53:49 <mauke> i.e. it's never 0
11:53:52 <Egg_> with recursion
11:54:00 <mauke> Egg_: no, that's not what remove does
11:54:15 <Botje> Egg_: a much much much easier approach would be isPalin xs = go xs (reverse xs)
11:54:29 <zygospasm> > let palin xs = and $ zipWith (\n x -> xs!!n == x) [length xs - 1, length xs - 2..0] xs in palin "foof"
11:54:30 <lambdabot>   True
11:54:33 <Botje> where go walks the lists in parallel and returns false if one of the head of the lists is different
11:54:33 <mauke> where go = (==)? :-)
11:54:39 <Botje> mauke: shh! :)
11:55:05 <Egg_> woah woah
11:55:09 <mauke> (if X then True else False) better written as X
11:55:53 <upsh9401> Is there a way to do a groupby that groups non-adjacent items?
11:56:01 <mauke> removeHead = tail
11:56:21 <Botje> upsh9401: there's partition, but it's strictly binary.
11:56:23 <adept> monochrom: what do you think, could I use the fix/mfix trick with whole isBipartite function, or fix-ing "spread" is all i'll get?
11:56:37 <zygospasm> mauke: except when it's not... :-)
11:56:39 <zygospasm> > let f n = if toEnum n then True else False; g n = toEnum n in (f 0, g 0)
11:56:40 <lambdabot>   (False,())
11:57:05 <mauke> > let f n = if toEnum n then True else False; g n = toEnum n in [f 0, g 0]
11:57:06 <lambdabot>   [False,False]
11:59:23 <upsh9401> guess I just have to write it my self, shouldn't be too hard. I could sort them first, instead, but then they have to be in Ord. hmm
12:00:04 <Botje> if you're lazy you could just run filter a couple of times
12:00:23 <Botje> or if you know in advance how many groups you'll have, you can write a fold with a "throw X into bucket Y" function
12:01:20 <upsh9401> recusive partion should work I think.
12:04:45 <upsh9401> Botje: thanks!
12:06:44 <upsh9401> @pointless g f (a,b) = (f a, f b)
12:06:45 <lambdabot> g = (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
12:06:52 <upsh9401> Yikes!
12:07:07 <upsh9401> @pointless h g f (a,b) = g (f a, f b)
12:07:08 <lambdabot> h = flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (flip =<< (((.) . (,)) .))) . (.) . (.)
12:07:47 <upsh9401> @t flip flip
12:07:47 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
12:07:52 <upsh9401> @type flip flip
12:07:54 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
12:11:52 <Egg_> ok so I had another go at the palindrome thing
12:12:02 <Egg_> using your ideas
12:12:03 <Egg_> I hope
12:12:08 <Egg_> still got an error though
12:12:33 <Egg_> lexical error in string/character literal at character i
12:12:39 <Egg_> I'll pastebin the code
12:12:58 <Egg_> http://pastebin.com/m3352e5a7
12:13:09 <mauke> ` is not '
12:13:21 <mauke> you're still doing this x:xs stuff
12:13:39 <Egg_> what do I do instead?
12:13:53 <BONUS> does your code have to be explicitly recursive?
12:13:53 <mauke> isPalin xs = xs == reverse xs
12:14:02 <Egg_> yeah
12:14:33 <Egg_> but without the x: bit, how does it check the head of the list?
12:14:40 <Egg_> forgive me if these are dumb questions btw
12:14:46 <BONUS> nah, no question is dumb
12:14:52 <mauke> how can it check the head of an empty list?
12:15:04 <nickknw> Would someone mind pointing out what I'm doing wrong in this exercise?    http://pastebin.com/d39dd78c6
12:15:10 <Raynes> BONUS: I beg to differ. Someone once asked me how to spell 'the'.
12:15:14 <BONUS> lol
12:15:31 <Egg_> I though x:xs represented the entire list though?
12:15:41 <mauke> Egg_: no
12:15:58 <Egg_> oh
12:15:59 <Egg_> haha
12:16:02 <mauke> x : xs represents the (:) operator applied to x and xs
12:16:06 <BONUS> ayway, here's how i would think about this problem recursively. first, i'd define the base and say that the empty string is a palindrome and that the string made up of only one character is a palindrom
12:16:07 <Egg_> ahhh
12:16:08 <Egg_> right
12:16:12 <BONUS> makes scents, right?
12:16:13 <nickknw> I'm trying to understand how to use maybe, in that example
12:16:24 <Egg_> yeah
12:16:27 <mauke> nickknw: you're missing Just
12:16:41 <BONUS> then i'd just say that if you have a string with a first character, a last character and the characters between them
12:16:49 <sinelaw> scents :)
12:16:51 <mauke> nickknw: you're trying to call MNode with an MTree a, not a Maybe (Mtree a)
12:16:55 <BONUS> if the characters between them are a palindrome and the first and last are the same, then it's a palindrome
12:17:32 <Egg_> yeah
12:18:10 <BONUS> so just try splitting it up into two characters and a string between them imo
12:19:02 <Egg_> right
12:19:47 <nickknw> mauke:  So...  when I create the MTree, for each child node I should be saying `Maybe (MNode "lc" Nothing Nothing)` then?
12:20:03 <mauke> nickknw: data Maybe a = Nothing | Just a
12:20:11 <mauke> i.e. the data constructor is called Just, not Maybe
12:20:13 <benmachine> @src asks
12:20:14 <lambdabot> asks f = do
12:20:14 <lambdabot>     r <- ask
12:20:14 <lambdabot>     return (f r)
12:20:21 <nickknw> oh
12:20:29 <nickknw> OHHHHH
12:20:54 <benmachine> @. pl undo \f -> do { r <- ask; return (f r); }
12:20:54 <lambdabot> (ask >>=) . (return .)
12:21:14 <BONUS> Egg_: this http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4572#a4572 is how i would do it (watch out, it basically spoils the whole thing for you :)
12:21:37 <benmachine> @undo \f -> do { r <- ask; return (f r); }
12:21:38 <lambdabot> \ f -> ask >>= \ r -> return (f r)
12:21:49 <null_ptr> hmm, even though I know what I want / have to do, I cannot find the way to express that in Haskell syntax..
12:21:56 <benmachine> that is just fmap f ask isn't it
12:22:10 <mauke> yes, and ask = id
12:22:12 <Egg_> what is that init function?
12:22:34 <mauke> > init "everything but the last element"
12:22:35 <lambdabot>   "everything but the last elemen"
12:22:41 <Egg_> ah right
12:22:46 <monochrom> <monochrom> f x y = g 0 x y where { g c (x:xs) (y:ys) = c `xor` x `xor` y : g (((x `xor` y) `and` c) `or` (x `and` y)) xs ys }
12:22:49 <monochrom> almost an hour ago
12:23:13 <null_ptr> monochrom: I saw that. Thanks. But I dont understand it
12:23:27 <upsh9401> @pointless h g f a b = g (f a) (f b)
12:23:29 <lambdabot> h = join . ((flip . ((.) .)) .) . (.)
12:23:31 <BONUS> init (tail "12345")
12:23:32 <drhodes> @hoogle (a -> b) -> [m a] -> m [b]
12:23:33 <BONUS> > init (tail "12345")
12:23:33 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
12:23:33 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
12:23:33 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
12:23:34 <lambdabot>   "234"
12:24:02 <upsh9401> "h g f a b = g (f a) (f b)" is named something right? in Arrow maybe?
12:24:13 <Egg_> ah right
12:24:21 <Egg_> ok thanks for your helps guys!
12:24:21 <null_ptr> monochrom: For example the zero between g and x y. what's that?
12:24:25 <monochrom> use an auxilliary function. use an extra parameter for carry.
12:24:34 <Egg_> I'll probs be in tomorrow asking about the next question mind
12:24:35 <Egg_> D:
12:24:35 <monochrom> initial value of carry
12:24:38 <Egg_> see ya
12:24:43 <nickknw> mauke: (it works!) I think I understand it a lot bettter now, thank you!
12:24:52 <mauke> excellent
12:25:44 <upsh9401> @hoogle (a -> a -> b) -> (c -> a) -> c -> c -> b
12:25:45 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
12:25:45 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (d -> r') -> a -> r
12:25:45 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (d -> r') -> a -> r
12:25:56 <upsh9401> hoogle is sweet!
12:26:16 <mauke> hoogle++
12:26:49 <monochrom> Maybe you need: http://groups.google.com/group/comp.lang.functional/msg/5d794a3194702607
12:28:21 <monochrom> Maybe you need a more toy example.
12:28:41 <temoto> How to delete duplicates from list?
12:28:49 <BONUS> Data.List.nub
12:28:49 <mauke> nub
12:28:57 <temoto> :t nub
12:29:00 <lambdabot> forall a. (Eq a) => [a] -> [a]
12:29:04 <temoto> Thanks.
12:29:36 <null_ptr> monochrom: when I try to load your source code, xor is out of scope. Isnt that part of some std lib?
12:29:40 <monochrom> "I want to generate the list of numbers 0,1,2,3... how do I translate the imperative counter idea to haskell?"  mylist = f 0 where f counter = counter : f (c+1)
12:29:59 <monochrom> You will define your xor, or, and.
12:30:11 <upsh9401> > ((,) 1) 2
12:30:12 <lambdabot>   (1,2)
12:30:26 <monochrom> This is because I don't know what your type for your bits is. But you know.
12:36:46 <temoto> How to find minimum of list of numbers?
12:36:49 <paolino> temoto, nub is quadratic, if you have Ord a it's better sorting
12:37:15 <paolino> :t minimum
12:37:17 <lambdabot> forall a. (Ord a) => [a] -> a
12:37:19 <temoto> paolino: thanks, i didn't had Ord, but i can do it.
12:37:24 <temoto> Thank you.
12:38:07 <paolino> :t map head . group . sort
12:38:08 <lambdabot> forall a. (Ord a) => [a] -> [a]
12:38:25 <mauke> :t S.toList . S.fromList
12:38:26 <lambdabot> forall a. (Ord a) => [a] -> [a]
12:40:00 <camio> :t nub
12:40:01 <lambdabot> forall a. (Eq a) => [a] -> [a]
12:51:35 <sinelaw> @let Y = (\h -> (\x -> h (x x)) (\x -> h (x x)))
12:51:36 <lambdabot>  <local>:1:0: Not in scope: data constructor `Y'
12:51:55 <sinelaw> @let Y' = (\h -> (\x -> h (x x)) (\x -> h (x x)))
12:51:55 <lambdabot>  <local>:1:0: Not in scope: data constructor `Y''
12:52:50 <sinelaw> let Y = (\h -> (\x -> h (x x)) (\x -> h (x x)))  in Y (const 1)
12:52:53 <sinelaw> > let Y = (\h -> (\x -> h (x x)) (\x -> h (x x)))  in Y (const 1)
12:52:54 <lambdabot>   Not in scope: data constructor `Y'Not in scope: data constructor `Y'
12:53:04 <sinelaw> > (\h -> (\x -> h (x x)) (\x -> h (x x)))  (const 1)
12:53:05 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
12:53:09 <sinelaw> ah.
12:53:35 <kyagrd> sinelaw: Y cannot be typed unless you define Y itself as a recursive function.
12:54:10 <kyagrd> And its syntax incorrect since variables cannot capital letters in Haskell
12:54:17 <kyagrd> cannot start with
12:54:24 <tromp_> :t fix
12:54:25 <lambdabot> forall a. (a -> a) -> a
12:54:30 <kyagrd> @src fix
12:54:31 <lambdabot> fix f = let x = f x in x
12:55:22 <tromp_> > fix (const 1)
12:55:24 <lambdabot>   1
12:55:37 <sinelaw> ok Agda, here I come.
12:55:43 <temoto> I have hm.. a generator of list of my type. Then i have an "evaluator" of this type, showing how good an item is. Having a list of items, how to get the best item?
12:56:03 <temoto> boards :: [Board]
12:56:09 <temoto> evalBoard :: Board -> Int
12:56:33 <tromp_> :t sortBy
12:56:34 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
12:56:50 <temoto> uh.. a-> a?
12:57:07 <mauke> :t maximumBy
12:57:08 <null_ptr> monochrom: ok, I wrote xor etc. when I run your function, I get: Non-exhaustive patterns in function g
12:57:08 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
12:57:36 <mauke> :t maximumBy (comparing ?evalBoard)
12:57:37 <temoto> Yeah, minimumBy is what i need, it seems. But i don't understand the first argument.
12:57:38 <lambdabot> forall a a1. (?evalBoard::a -> a1, Ord a1) => [a] -> a
12:57:44 <monochrom> Because I leave  out the base case for you.
12:57:56 <tromp_> :t cmp
12:57:57 <lambdabot> Not in scope: `cmp'
12:58:01 <null_ptr> ok
12:58:05 <tromp_> :t compare
12:58:06 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
12:58:06 <monochrom> I also don't know what you want to do if the two lists have different lengths.
12:59:06 <monochrom> My answers are always as open-ended as the questions they answer.
12:59:11 <tromp_> > sortBy compare [-5..5]
12:59:12 <lambdabot>   [-5,-4,-3,-2,-1,0,1,2,3,4,5]
12:59:20 <equaeghe> I have the follozing in my program:
12:59:25 <equaeghe>   if inspectArgs args
12:59:25 <equaeghe>        then let n = readCardinality args
12:59:25 <equaeghe> 		values = generateValues $ readStep args
12:59:25 <equaeghe>        else printHelpText
12:59:29 <tromp_> > sortBy (compare `on` sqr)  [-5..5]
12:59:30 <lambdabot>   Not in scope: `sqr'
12:59:46 <equaeghe> but it gives an error:
12:59:47 <tromp_> :t on
12:59:48 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
13:00:04 <tromp_> let square x = x *x
13:00:12 <tromp_> @let square x = x *x
13:00:13 <lambdabot>  Defined.
13:00:15 <tromp_> > sortBy (compare `on` )  [-5..5]
13:00:16 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
13:00:19 <mauke> > maximumBy (comparing length) ["none", "shall", "apply", "here"]
13:00:20 <lambdabot>   "apply"
13:00:24 <equaeghe> constraints.hs:15:5: parse error on input `let'
13:00:24 <tromp_> > sortBy (compare `on` square)  [-5..5]
13:00:25 <lambdabot>   [0,-1,1,-2,2,-3,3,-4,4,-5,5]
13:00:35 <mauke> tromp_: lern2comparing
13:00:55 <Botje> equaeghe: can you please put your entire program and the error you get on a paste bin?
13:01:02 <tromp_> :t comparing
13:01:03 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
13:01:08 <Botje> equaeghe: hpaste.org will do nicely
13:01:19 <temoto> I guess i need some import for comparing and ? operator.
13:01:27 <mauke> the ? wasn't an operator
13:01:30 <temoto> and minimumBy
13:01:30 <mauke> @index comparing
13:01:31 <lambdabot> bzzt
13:01:38 <mauke> temoto: IT IS MAXIMUMBY
13:01:44 <temoto> oh
13:01:57 <mauke> temoto: Data.Ord, Data.List
13:01:58 <monochrom> Why is reading so hard?
13:02:00 <Botje> :t maukeBy
13:02:01 <lambdabot> Not in scope: `maukeBy'
13:02:27 <temoto> I thought there must be an opposite of maximum.
13:03:02 <mauke> well, there is a mimimumBy but I've only used maximumBy here
13:03:20 <temoto> ah, great.
13:03:40 <monochrom> The opposite of maximum is "anything but maximum"
13:03:40 <null_ptr> monochrom: I have noticed that ;) Fortunately, I can expect nothing but two 8 bit values.
13:03:55 <equaeghe> Botje: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11516#a11516
13:03:56 <Botje> equaeghe: but your paste on irc (please don't do that next time) shows you have a line with tab characters instead of spaces.
13:04:12 <Botje> equaeghe: line 25 has tabs instead of spaces :)
13:04:16 <monochrom> :t two 8 bit values
13:04:18 <lambdabot> Not in scope: `two'
13:04:18 <lambdabot> Not in scope: `values'
13:04:23 <mauke> line 14 looks wrong
13:04:25 <monochrom> Sorry, syntax error.
13:05:32 <monochrom> But I guess I don't want to know.
13:06:06 <Botje> equaeghe: uh, maybe it's line 15 in your paste. hpaste does not align the lines for some strange reason.
13:06:34 <monochrom> align "n" and "v"
13:06:46 <monochrom> Oh I see, not that.
13:07:02 <monochrom> Can't use this kind of "let" in if-then-else.
13:07:04 <Botje> the line that starts with values has two tab characters
13:09:12 <monochrom> The idea behind the code makes no sense either. Under one condition, n is bound. But under the other condition, n is not bound. This is not allowed.
13:10:22 <monochrom> And don't use tabs.
13:11:00 <SubStack> it's true, tabs are naughty
13:11:26 <equaeghe> ok, trying to parse all your input (thanks)
13:12:22 <monochrom> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11516#a11518
13:13:30 <monochrom> tabs are fine if you stick with the standard meaning of tab. but most editors don't, and most users aren't educated about it.
13:14:32 <monochrom> Anyway the culprit is the whole idea of plain text file.
13:16:08 <equaeghe> my editor seems to handle tabs correctly together with the haskell syntax highlighting
13:16:39 <equaeghe> I solved the problesm thanks to you all: separate the ifthenelse check from the lets
13:18:28 <temoto> mauke: thanks again, minimumBy is working great.
13:18:46 <mauke> cool
13:19:16 <mauke> > sortBy (comparing length `mappend` compare) $ words "thanks again, minimumBy is working great."
13:19:17 <lambdabot>   ["is","again,","great.","thanks","working","minimumBy"]
13:19:34 <null_ptr> monochrom: I miss the point. Probably I have to epext two empty lists in the last round, but I don't know how to take care of that
13:19:46 <monochrom> g c [] [] = ...
13:19:48 <SubStack> :t mappend
13:19:49 <lambdabot> forall a. (Monoid a) => a -> a -> a
13:19:55 <SubStack> monoids!
13:20:00 <gOcOOl> is it true that when evaluating a string (say, list of 10 chars) we end up, depending on the evaluation ofcourse, having as many thunks as the number of elements in the list. but when evaluating a bytestring, we end up having (size of bytestring/64k) number of thunks, roughly speaking?
13:20:10 <Cale> equaeghe: regardless, you should ensure that your editor is configured never to put tab characters into source files. Any decent text editor has an option to automatically convert them to spaces.
13:20:36 <monochrom> Yes gOcOOl
13:20:37 <drhodes> I've got a data T = T ... constructor which takes 9 values.  I know there's a why though repeated partial applications to chomp the list down and build up the final result, but I forgot how I did it :/
13:20:39 <Cale> gOcOOl: Uh, sort of?
13:20:44 <kmc_> g0c00l, with lazy bytestring
13:20:47 <Cale> gOcOOl: You won't have them all at the same time.
13:20:52 <aavogt> does ghc have a mode to spit out a file with all the identifiers fully qualified?
13:21:01 <kmc_> strict bytestring doesn't use this 64k chunking
13:21:07 <Cale> gOcOOl: and once the string is completely evaluated of course you will not have any thunks
13:21:16 <gOcOOl> yeah, sorry, forgot to mention, i'm talking abt lazy bytestrings
13:21:45 <Cale> I don't really like the term 'thunk' anyway. I prefer 'unevaluated expression'.
13:21:53 <aavogt> I want to read a haskell source, and do variable renames iff that identifer actually refers to an imported value that has been changed
13:22:27 <kmc_> Cale, because "thunk" is an implementation representation of an unevaluated expression?
13:22:32 <Cale> kmc_: right.
13:22:53 <Cale> It's fine to use the term 'thunk', but I don't typically think at that level.
13:22:58 <kmc_> would you similarly not refer to function values as "closures"?
13:23:08 <Cale> That one I am even more adamant about.
13:23:28 <gOcOOl> in that case, once i use bytestrings to read/process a huge file, it doesn;t matter then if i unpack it and just work with strings as long as i'm using bytetsrings to read the file?
13:23:32 <kmc_> it is part of the semantics that they close over free variables, though
13:23:50 <gOcOOl> bascially, somthing along the lines of:
13:23:53 <Cale> Because they are not really closures unless you can separate them into code and a mapping from variables to values.
13:23:55 <monochrom> I use "thunk" as a shorthand for "unevaluated expression". This is consistent with people using "strict" as a shorthand for "eager".
13:24:27 <Cale> Closures are pairs, and pairs must come with projection maps.
13:24:34 <blackh> sproingie: Good progress on the Haskell platform for Ubuntu.  I had to patch one package because it depends on ghc-6.8 as bootstrap compiler but Ubuntu 9.10 has ghc-6.10.4
13:24:36 <aavogt> > (length "strict",length "eager")
13:24:37 <lambdabot>   (6,5)
13:24:39 <gOcOOl> contents <- LB.readFile "input.txt"; let x = map (LB.unpack) . LB.lines $ contents; some processing on x ...
13:24:53 <Nafai> blackh, sproingie: You guys making a PPA for the platform? :)
13:25:10 <koeien> debian sid has the packages now, isn't ubuntu going to steal them?
13:25:28 <Nafai> well, sure, I hope.
13:25:30 <koeien> s/steal/copy of course, ;)
13:25:31 <blackh> koeien: I'm building it for the people who can't wait that long.
13:25:35 <Nafai> But it won't be until next release
13:25:43 <Nafai> Since Karmic just came out, that's 6 months
13:25:59 <koeien> ok, ic
13:25:59 <koeien> nice
13:26:09 <blackh> koeien: Do you want to test it for me?
13:26:16 <koeien> blackh: i do not have ubuntu
13:26:31 <koeien> debian stable here
13:32:20 <blackh> Nafai: Ah - now thanks to you I know what a PPA is - I should make it into a PPA!
13:32:51 <Nafai> Yes, indeed.  It takes a bit to figure out, but the process isn't too bad
13:33:06 <Nafai> I'm just asking because it would be nice to install something with apt :)
13:33:36 <null_ptr> monochrom: Got it. Thank you. Something else: I still don't see "the power" of Haskell. What makes you people so encouraged about it?
13:34:10 <koeien> null_ptr: functional programming in general is more efficient and is more declarative (say "what" instead of "how")
13:35:03 <koeien> ~haskell's type system is strong, and there can be no type errors at run-time, but it doesn't get in my way (in fact, the type system often helps to drive development and fix bugs)
13:36:25 <null_ptr> Yeah, that's what I can read everywhere. But, from my point of view, it's just PITA. Do you think, that's just because I was socialised with non functional programming?
13:36:36 <koeien> what is PITA?
13:36:41 <null_ptr> pain in the ass
13:36:46 <koeien> the type system, or the fact that you cannot say x := x + 1 ?
13:37:23 <null_ptr> probably the latter
13:37:25 <camio> null_ptr, have you seen the parsec library?
13:37:32 <null_ptr> no
13:37:59 <camio> That was a library I learned about early on that helped the light turn on for me.
13:38:02 <kmc_> the point of the type system is a little pain now (compiler errors) to save a lot of pain later (crashes in production)
13:38:04 <koeien> hmm, i think it is far easier to write, for example, a binary search in a functional language than in an imperative language
13:38:27 <camio> null_ptr, for appreciation of the beauty of Haskell
13:39:18 <null_ptr> yeah, maybe I just have to be patient. I will have a look on parsec
13:39:31 <koeien> i think most of us started with imperative programming (there are some exceptions, i know), and this is a radically different paradigm
13:40:06 <Saizan_> null_ptr: in general it takes a while to change your way you think about programming, so you stop fighting the functional style and the type system and instead start to exploit their strength
13:40:23 <drhodes> @hoogle (a -> b) -> [a] -> b
13:40:24 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
13:40:24 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
13:40:24 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
13:40:34 <kmc_> it's important to remember that types exist to help you prove properties of your program, *not* to specify what representation the machine should use
13:40:46 <null_ptr> Saizan_: yes, I hope so
13:41:08 <mmorrow> null_ptr: basically it's awesome because once you can write it with flow and not be erroring out type-wise or constantly referencing something, you get like 10x more productive, and write 10x less code
13:41:33 <mmorrow> well, you actually write the same amount of code
13:41:41 <mmorrow> you just get 10x as much done ;)
13:42:14 <camio> I've personally found that Haskell actually has killed my productivity because I think and program at such a higher level of abstraction now.
13:42:29 <koeien> why would that kill your productivity?
13:42:41 <gwern> koeien: maybe he realized that all is vanity
13:43:05 <camio> koeien, because I don't like programming specialized solutions any more.
13:43:12 <gwern> at a high enough level of abstraction, everything exists already, so writing code to actually compute something is pointless
13:43:28 <gwern> at an even higher level, you realize life is suffering, and cease to desire to code
13:43:29 <koeien> gwern: are you, by any chance, a mathematician? :P
13:44:29 <gwern> koeien: 'every educated man is a theologian, even if he is an atheist'
13:47:52 <drhodes> some_function f [1,2,3] = (((f 1) 2) 3)
13:48:18 <drhodes> what is some_function, please?
13:48:26 <koeien> what would be the type of it?
13:48:48 <Saizan_> you've just defined it :)
13:48:49 <gwern> looks like he's groping towards a fold
13:49:05 <byorgey> that's not a fold.  it's 'apply' in lisp
13:49:07 <drhodes> it's a data construct from data T = T ...., but takes 9 values
13:49:27 <byorgey> drhodes: there can't be such a generic function in Haskell, because you can't give it a type
13:49:27 <gwern> drhodes: incidentally, how can 'f 1' be legit when you defined 'f' as taking a [Int]?
13:49:30 <koeien> drhodes: then this is probably not going to work (and it is unsafe anyway)
13:49:34 <Saizan_> drhodes: you can only do it in an ad-hoc way like that
13:49:53 <Cale> gwern: ?
13:50:02 <byorgey> gwern: ?  'some_function' takes two arguments, f and a list
13:50:18 <gwern> oh, sorry. I misread some_function
13:50:18 <Cale> drhodes: someFunction f [x,y,z] = f x y z
13:50:40 <Cale> drhodes: Of course, it will fail if you pass it a list of the wrong length...
13:50:42 <gwern> (missed the underscore)
13:51:02 <koeien> Cale: yes, that's what i meant by "unsafe"
13:51:09 <drhodes> Cale: ! thanks.
13:51:36 <Cale> drhodes: and that one only works for functions taking (at least) 3 parameters.
13:52:20 <Cale> It's possible to do better than this using typeclasses, but the result still has a lot of failure cases
13:52:38 <drhodes> it's just a data constructor, so it only makes sense for it to take set X number of args.
13:52:46 <Cale> drhodes: ah, okay
13:53:37 <mightybyte> I'm trying to run cabal from a local repo, and it says "~/.cabal/packages/local is missing.  The repo is invalid."  However, that directory is not missing.  Any idea what the problem might be?
13:56:25 <monochrom> There is no power in Haskell. Its attraction is it gets many more things right than many other languages.
13:57:21 <sm> no power ?
13:57:33 <gwern> monochrom: phew! with great power, comes great responsibility, and we want to avoid success at all costs
13:57:39 <monochrom> Translating "data T a = X a Int | B Bool (T a)" to many other languages is a PITA.
13:59:04 <koeien> well, translating some OO-isms directly to haskell is a PITA too...  ;)
13:59:50 * gwern beseechs St. Oleg from smiting koeien. forgive him, he knows not what he says!
14:00:31 <koeien> well, yeah, Pascal has 'case ...' in records, and then you can have adt's too :P
14:00:57 <gwern> koeien: is pascal case as limited as java switch?
14:01:07 <monochrom> A grad student had been in deep debt for several years, i.e., he had -10000 dollars. One day, he got a teaching contract and he could pay his debt, so now he had 0 dollars. He said, "I feel so rich!"
14:01:09 <koeien> in records (i.e. in what C calls "structs")
14:01:42 <koeien> it's a bit like a safe 'union'
14:01:50 <gwern> monochrom: a gain of a loss is as bad as a loss of a gain!
14:01:55 <monochrom> But he was not rich, he just had 0 dollars. He felt rich because of the 10000 jump. But it was a jump from the way negative to zero, not from zero to the way positive.
14:02:11 <gwern> all economics is relative
14:02:13 <koeien> but, of course, Haskell is nicer :) but just saying "this does not translate to $OTHER_LANGUAGE" is not the reason imo
14:02:18 <Rotaerk> class T<a> {}  class X<a> : T<a> { public a p1 { get; set; }  public int p2 { get; set; } }  class B<a> : T<a> { public bool p1 { get; set; }  public T<a> p2 { get; set; } }
14:02:26 <monochrom> The same grad student found "so much power" in Haskell when he switched from C to Haskell.
14:02:32 <Rotaerk> discriminated unions in C# are awesome and concise like that .. *cough*
14:02:37 <koeien> Rotaerk: this is "open" instead of "closed" ?
14:02:44 <gwern> (absolute numbers are irrelevant; rational agents maximize their end state, which may not be positive)
14:02:57 <Rotaerk> koeien, what?
14:02:58 <koeien> i.e. i could add another class inheriting from T<a> somewhere else
14:02:59 <Vanadium> now if only they got around to porting object oriented programming to haskell, so we could start getting work done
14:04:02 <Rotaerk> koeien, hmm, true, it's not quite as restricting
14:04:11 <Rotaerk> haskell's definitely safer about it
14:04:24 <Rotaerk> though I wonder if there's a way I can prevent *further* derivations of that class
14:04:44 <koeien> there is something like "sealed", maybe you can seal the package?
14:04:54 <Rotaerk> sealed would prevent any derivation
14:04:56 * koeien doesn't know a lot of C#
14:05:19 <Rotaerk> though there may be a mechanism that prevents *public* derivation or something
14:05:31 <gwern> koeien: oh, you do. just take your haskell code, switch everything to braces syntax, dumb it down a bit, add some gratuitious IO, and bam! there you are
14:05:53 <monochrom> add existential types
14:05:59 <kmc_> haskell already has braces.  invisible ones!
14:06:03 <koeien> gwern: you forgot the part where you have to turn every type a into something of type () -> a
14:06:14 <monochrom> () -> IO a
14:06:19 <koeien> ah yes, of course, IO a
14:06:34 <monochrom> (b, c, d) -> IO a
14:06:57 <koeien> but what about global variables?!?!?!?! they should be passed to every function!
14:07:06 <monochrom> (b, c, d) is important because people understand f(x,y,z) but not f x y z
14:07:14 <koeien> lol
14:08:06 * gwern 's head asplodes at the ambiguity of 'f x y z' HOW WILL I KNOW WHAT IS WHAT
14:08:21 <monochrom> haha
14:08:24 <kmc_> that's right, understanding a language is driven solely by its syntax
14:08:45 <monochrom> @quote monochrom semantics
14:08:46 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
14:08:53 <gwern> kmc_: well, sure, don't you know every language is turing-complete and so all there is to know is syntax?
14:09:03 <kmc_> Agda isn't Turing complete
14:09:08 <koeien> "every language is turing-tomplete"? Agda!
14:09:11 <Rotaerk> html isn't turing complete
14:09:22 <aavogt> you're not turing complete
14:09:25 <Rotaerk> your mom?
14:09:28 <gwern> kmc_: there you go, with your fancy academic nonsense. us industry programmers down in the trenches need real solutions now!
14:09:30 <koeien> the regular language {a, aa, aaa, aaaa, ...} is not turing complete (what would it even mean?)
14:09:42 <monochrom> every program is a plain text file, so all there is to know is which column does what, which symbol to put in the 5th column to make that line a comment.
14:09:42 <endojelly> well, you can make agda turing complete by disabling the termination checker
14:09:42 <sproingie> your mom is turing complete, she can compute any position
14:09:45 <aavogt> > repeat 'a'
14:09:46 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
14:09:47 <blackdog> Rotaerk: i'm at your mum's house, making her turing-complete...
14:09:59 <Rotaerk> lol
14:10:31 <monochrom> ...
14:11:23 <blackh> repeat 'a' ++ "rgh!!"
14:11:41 <monochrom> is bisimilar to repeat 'a'
14:12:05 <blackh> Amazing the things you can express in Haskell!
14:12:07 <monochrom> which is Turing-complete as we discussed.
14:12:32 <Rotaerk> koeien, you can have runtime checks easily that prevent other derivations from working but no... no compile time mechanism for selective sealing
14:13:07 <skorpan> is repeat 'a' ++ "rgh!!" any slower than repeat 'a'?
14:13:29 <benmachine> probably imperceptibly so
14:13:45 <skorpan> if it is slower, it's definitely imperceptibly so
14:13:46 <aavogt> so how do you know?
14:13:55 <benmachine> aavogt: hence probably :P
14:14:18 <blackh> Is rnf (repeat 'a' ++ "rgh!!") any slower than rnf (repeat 'a') ?
14:14:21 <benmachine> reimplement ++ with unsafePerformIO threadDelay 1000000 in it
14:14:31 <benmachine> that might be illustrative
14:14:43 <aavogt> I mean, if it is impreciptibly slower, then for all practical purposes it is not slower.
14:14:58 <benmachine> aavogt: mm, depends
14:15:02 <koeien> that depends on how often you are going to execute the program
14:15:13 <benmachine> taking 10ms is not perceptibly slower than taking 5 ms
14:15:21 <benmachine> but do it 1000 times and it shows
14:15:59 <kmc_> > rnf [1..]
14:16:03 <lambdabot>   mueval-core: Time limit exceeded
14:16:19 <benmachine> > rwhnf [1 ..]
14:16:21 <lambdabot>   ()
14:16:24 <benmachine> woo
14:16:33 <kmc_> :t rnf
14:16:34 <lambdabot> forall a. (NFData a) => a -> Done
14:16:34 <aavogt> @type rwhnf
14:16:35 <lambdabot> forall a. a -> Done
14:16:36 <kmc_> :t rwhnf
14:16:37 <lambdabot> forall a. a -> Done
14:16:44 <kmc_> @src rwhnf
14:16:45 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:16:48 <aavogt> rwhnf is like seq?
14:16:51 <kmc_> yeah
14:16:59 <benmachine> I think it's pretty much rwhnf a = seq a ()
14:17:04 <aavogt> @type flip seq ()
14:17:05 <lambdabot> forall a. a -> ()
14:17:15 <benmachine> Done is a type synonym for ()
14:18:47 <Dunb> Hello. Could you suggest a fun haskell interpreter for Windows?
14:19:20 <kmc_> Dunb, does it have to be an interpreter?
14:19:22 <koeien> Dunb: i would suggest ghc, it comes with an interpreter
14:19:29 <kmc_> Haskell is usually implemented by compilation
14:19:50 <kmc_> ghc is a great Haskell compiler that comes with a read-evaluate-print loop.  it probably doesn't matter to you if that loop is implemented by compilation or interpretation
14:20:00 <kmc_> (for ghc it's sort of halfway between)
14:20:09 <Dunb> I would prefer an interpreter. I don't have to write complex programs. I'd like to play with the language for a while
14:20:18 <koeien> you can use ghc for thatt
14:20:23 <Dunb> ok
14:20:28 <Dunb> I'll try it
14:20:29 <Dunb> thanks
14:20:38 <koeien> it has an "interactive environment", called ghci
14:21:18 <aavogt> aka interpreter
14:21:19 <sm> you can used ghci (comes with ghc), or hugs (less used), or helium (still less used, but specifically designed for learning)
14:21:24 <Dunb> cool. I'm downloading the "haskell platform" for Windows
14:21:33 <sm> +1
14:21:38 <benmachine> so my question for #haskell this evening is
14:21:42 <benmachine> is this interesting: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11520#a11520
14:22:07 * hackagebot upload: XMPP 0.1.0 - XMPP library (GregoriKholomyev)
14:22:25 <kmc_> Dunb, why do you prefer an interpreter?
14:22:52 <koeien> kmc_: "to play around", it makes sense to have an interpreter then
14:23:03 <kmc_> it makes sense to have an interactive read-evaluate-print loop
14:23:08 <koeien> sure
14:23:12 <kmc_> it probably doesn't matter to you if that's interpreted or compiled, behind the scenes
14:23:47 <benmachine> I think lots of people equate interpreter with repl
14:24:03 <kmc_> yeah, but i'd rather they didn't
14:24:12 <sm> "runhaskell" is an interpreter comes with ghc
14:24:16 <sm> that
14:24:33 <koeien> doesn't compile to bytecode first?
14:24:37 <Dunb> kmc_; yeah, I just wanted a nice interactive environment. If it's compile behind the scenes, it's not a problem
14:24:43 <sm> probably, so does python
14:25:03 <koeien> then the line between "compiler" and "interpreter" is blurry
14:25:07 <kmc_> Dunb, then i think you will enjoy ghci
14:25:14 <Taejo> @hoogle Int32
14:25:15 <lambdabot> Data.Int data Int32
14:25:22 <Taejo> @hoogle Word32
14:25:23 <lambdabot> Data.Word data Word32
14:25:29 <Dunb> benmachine: ok. I will try ghci and the helium thing
14:25:32 <sm> yes, I think ghc can both interpret and compile. But if I'm wrong, never mind, it's boring details
14:25:49 <Dunb> thanks to everybody
14:25:50 <kmc_> Dunb, are you a beginner learning haskell?
14:25:55 <Dunb> yeah
14:25:57 <kmc_> cool
14:25:59 <kmc_> welcome :)
14:26:01 <Dunb> :)
14:26:05 <kmc_> feel free to ask questions here anytime
14:26:09 <kmc_> also play with lambdabot
14:26:11 <kmc_> > 2 + 3
14:26:12 <lambdabot>   5
14:26:22 <koeien> > product [1..37]
14:26:23 <skorpan> but if you ask, you must begin by asking "may i ask"!
14:26:25 <lambdabot>   13763753091226345046315979581580902400000000
14:26:25 <sm> has anyone tried the new Advgame package ? is it useful for learning at all ?
14:26:25 <Rotaerk> > 1 + 1
14:26:26 <lambdabot>   2
14:26:29 * Rotaerk claps
14:26:30 <kmc_> > let fibs = 1 : 1 : (zipWith (+) fibs $ tail fibs) in fibs
14:26:32 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
14:26:44 <kmc_> :t fix
14:26:46 <lambdabot> forall a. (a -> a) -> a
14:27:03 <sm> http://jpmoresmau.blogspot.com/2006/11/my-first-haskell-adventure-game.html
14:27:12 <Dunb> Rotaerk: what are you doing in here?
14:27:14 <Dunb> :)
14:27:21 <Rotaerk> :P
14:29:59 <Dunb> thanks, kmc
14:30:14 <Dunb> see you laters!
14:30:35 <sm> I guess not so much.. it's just an implementation of the final game, not a port of the (brilliant) tutorial
14:32:53 <sm> confusing that you deal with both functions and SPELs. In haskell it's just functions, which should make it easier
14:33:13 <sproingie> the heck is a SPEL?
14:34:22 <sproingie> sm: note the date, that's not new.  the author went on to write some more advanced stuff like MazesOfMonad
14:34:45 <sm> sproingie: oh, good point
14:34:49 <monochrom> Mazes of Monad sounds fun!
14:34:49 <sm> SPEL == macro
14:34:55 <sproingie> which is on hackage.  also the only roguelike of the bunch to actually compile out of the box
14:35:08 <sproingie> curses seems to have broken on 6.10
14:35:30 <sproingie> or at least became incompatible, i never dug that much into it
14:39:08 <sm> vty works, at least
14:39:17 <gwern> vty isn't curses though, I thought
14:40:05 <sm> no, it's pretty similar though
14:40:26 <sm> as far as I can tell
14:40:34 <sm> just a lot simpler
14:42:55 <kosmikus> sproingie: LambdaHack doesn't compile out of the box?
14:54:05 <sshc> is there a function I can use to replace all substrings within a string with another string (such as escaping all quotes or backslashes with another backslash by passing "\\" "\\\\" to the replace function)
14:55:21 <Vulpyne> sshc: Single character changes would be pretty easy.
14:56:12 <Vulpyne> sshc: For example: concat $ map (\c -> case c of { '\\' -> ["\\\\"]; _ -> [c] } "my string with a \\slash."
14:56:44 <Vulpyne> Actually, there's a concatMap you should use instead.;
14:56:51 <Vulpyne> :t concatMap
14:56:52 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
15:00:14 <gwern> sproingie: hscurses seems to compile here
15:05:10 <kamatsu> can anyone explain why the type (Foo -> a) -> (Foo -> a -> Foo) -> a -> State Foo Bool triggers the occurs check?
15:05:37 <skorpan> occurs check?
15:05:44 <kmc_> kamatsu, that type itself is fine
15:05:47 <sshc> occurs check?
15:05:49 <kmc_> something is *failing* to have that type
15:05:50 <koeien> kamatsu: the error is probably somewhere else
15:05:57 <koeien> :t (\x -> x x)
15:05:58 <kamatsu>     Occurs check: cannot construct the infinite type:
15:05:58 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
15:05:59 <lambdabot>     Probable cause: `x' is applied to too many arguments
15:05:59 <lambdabot>     In the expression: x x
15:06:04 <kmc_> kamatsu, can you hpaste the error msg and the code it refers to?
15:06:59 <mmorrow> @pl (\x -> x x) (\x -> x x)
15:07:02 <lambdabot> ap id id (ap id id)
15:07:03 <lambdabot> optimization suspended, use @pl-resume to continue.
15:07:22 <Botje> that looks halfway decent :)
15:07:28 <Botje> :t ap id id (ap id id)
15:07:29 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
15:07:30 <lambdabot>     Probable cause: `id' is applied to too few arguments
15:07:30 <lambdabot>     In the second argument of `ap', namely `id'
15:07:35 <Botje> aww
15:07:40 <mmorrow> @pl (\f -> (\x -> f (x x)) (\x -> f (x x)))
15:07:40 <lambdabot> ap (. join id) (. join id)
15:07:53 <kmc_> :T app id id
15:07:55 <kmc_> :t app id id
15:07:57 <lambdabot>     Couldn't match expected type `a -> a'
15:07:57 <lambdabot>            against inferred type `(b -> c, b)'
15:07:57 <lambdabot>     Probable cause: `app' is applied to too many arguments
15:07:58 <mmorrow> , ap(++)show"ap(++)show"
15:07:59 <lunabot>  "ap(++)show\"ap(++)show\""
15:08:17 <kamatsu> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11521#a11521
15:08:20 <dmwit_> ?. pl src fix
15:08:20 <lambdabot> (line 1, column 1):
15:08:20 <lambdabot> unexpected end of input
15:08:20 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
15:09:18 <kamatsu> kmc_: okay, i hpasted it
15:09:30 <kamatsu> this for a happstack data store
15:09:36 <dmwit_> :t M.member
15:09:37 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Bool
15:09:39 <mmorrow> @pl (\x -> app x (quote x)) (quote (\x -> app x (quote x)))
15:09:39 <lambdabot> ap app quote (quote (ap app quote))
15:09:41 <mmorrow> , ap(++)show"ap(++)show"
15:09:43 <lunabot>  "ap(++)show\"ap(++)show\""
15:10:05 <Badger> @hoogle quote
15:10:05 <lambdabot> Text.XHtml.Frameset quote :: Html -> Html
15:10:06 <lambdabot> Text.XHtml.Strict quote :: Html -> Html
15:10:06 <lambdabot> Text.XHtml.Transitional quote :: Html -> Html
15:11:09 <dmwit_> kamatsu: You're inserting an 'a' into a CompClub?  That sounds suspicious to me.
15:11:23 <dmwit_> (because CompClub has no type variable)
15:11:42 <kamatsu> dmwit_: hm?
15:11:55 <kamatsu> the putter function does the actual insertion
15:12:00 <dmwit_> kamatsu: Perhaps you mean merely "dat `putter` addition" on line 7.
15:12:02 <kamatsu> i was trying to generalize 3 very similar functions
15:12:23 <kamatsu> the getters and putters just retrieve and insert a map
15:12:30 <kamatsu> oh wait
15:12:33 <kamatsu> i screwed up the types
15:12:40 <kamatsu> right, i see now
15:12:55 * dmwit_ nods sagely
15:16:28 <skorpan> ...sagaciously...
15:19:27 <dmwit_> I'd rather be wise than shrewd.
15:20:43 <__ent__> hi
15:20:53 <koeien> hello __ent__
15:21:12 <__ent__> may i ask a newbie question?
15:21:15 <kmc_> certainly
15:21:17 <koeien> of course, fire it
15:21:30 <dmwit_> The minority report is NO! ;-)
15:22:05 <__ent__> what kind of real haskell program would you recommend to try writing?
15:22:14 <__ent__> for starters
15:22:15 <kmc_> __ent__, have you seen Real World Haskell?
15:22:19 <kmc_> @where rwh
15:22:19 <lambdabot> is http://www.realworldhaskell.org/blog/
15:22:27 <__ent__> well, i know about it
15:22:31 <dmwit_> What kind of real program are you interested in writing?  I recommend that.
15:22:39 <kmc_> @where write yourself a scheme
15:22:39 <lambdabot> I know nothing about write.
15:22:41 <koeien> dmwit_: precisely
15:22:51 <kmc_> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
15:22:52 <ddarius> You all hash to dark blue.
15:22:59 <zrbecker_> __ent__:  Program something that interests you, or work through Real World Haskell.
15:23:03 <koeien> maybe a network client, something with parsing, something with a GUI, ...
15:23:09 <__ent__> i just like to explore haskell now
15:23:09 <koeien> a game
15:23:15 <SubStack> hopengl is fun times
15:23:18 <medfly> I'm writing a chess game
15:23:19 <kmc_> i wrote a 3D renderer
15:23:23 <dmwit_> Some people explore Haskell via Project Euler.
15:23:25 <__ent__> nic tips
15:23:32 <__ent__> yes, i do euler too
15:23:46 <kmc_> (rendering to raster images directly, nt through OpenGL)
15:23:49 <kmc_> but OpenGL is fun too
15:23:54 <__ent__> but euler seems to be a little artificial, cause it's math
15:24:01 <kmc_> unfortunately not a great way to learn functional-programming style
15:24:12 <kmc_> haskell is a great imperative language too, but that's not why most of us are so excited about it
15:24:31 <koeien> kmc_: well, maybe not the OpenGL parts, but the surrounding infrastructure of the program can certainly be
15:24:34 <__ent__> in fact, i love things like referential transparency
15:24:45 <kmc_> that depends on what else you're doing
15:24:52 <__ent__> and i try to broaden my views about pure functional style etc.
15:25:04 <__ent__> i do python at work
15:25:11 <kmc_> my program (for a graphics class) was just to load a model from file and render it with OpenGL and some interactive camera manipulations
15:25:16 <koeien> we sympathize ;)
15:25:16 <__ent__> internet applications, client-server
15:25:35 <koeien> __ent__: i would suggest to take a look at RWH too, there are some examples there too
15:25:37 <kmc_> i like python.  it's quite functional, although the lambda syntax is broken
15:25:50 <koeien> kmc_: i hate the dynamic typing
15:25:54 * ddarius uses C# which doesn't have a broken lambda.
15:26:06 <__ent__> ok, i think i will look at real work haskell
15:26:09 <medfly> C# has a more obvious flaw :)
15:26:10 <__ent__> world
15:26:37 * ddarius is not sure what that is compared to python.
15:26:39 <__ent__> i read learn haskell for greater good and it's neat
15:26:48 <kmc_> python is also how i learned that OO needn't be tremendously painful
15:26:50 <medfly> learn you a haskell for greater good
15:26:57 <__ent__> yes, sorry
15:27:05 <mrbluesky> I'm four chapers into great greater good
15:27:18 <JoePeck> Hello guys. I'm learning Monads and I'm trying to figure out how "runCont" for the Cont Monad is implemented
15:27:26 <medfly> great
15:27:27 <ddarius> :t runCont
15:27:28 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
15:27:30 <kmc_> @unmtl Cont r a
15:27:31 <lambdabot> (a -> r) -> r
15:27:40 <ddarius> @djinn Cont r a -> (a -> r) -> r
15:27:40 <lambdabot> Error: Undefined type Cont
15:27:43 <JoePeck> ddarius: is that the implementation? I thought it was just a type signature
15:27:55 <dmwit_> ?djinn ((a -> r) -> r) -> (a -> r) -> r
15:27:56 <lambdabot> f a = a
15:28:02 <ddarius> JoePeck: The type completely determines the implementation in this case.
15:28:03 <kmc_> JoePeck, data Cont r a = Cont ((a -> r) -> r)
15:28:22 <kmc_> runCont is just the field accessor
15:28:34 <kmc_> runCont (Cont f) = f
15:28:50 <JoePeck> ohhhh
15:29:01 <dmwit_> so simple, no? =)
15:30:25 <BONUS> @djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
15:30:26 <lambdabot> f a b c = a (\ d -> b d c)
15:30:27 <JoePeck> it is simple, I was actually doing runCont (Cont f) = f id, which was silly
15:30:42 <kmc_> so a value of type "Cont r a" represents... a computation resulting in a value of type a, on the way to an eventual result of type r?
15:31:25 <Saizan_> fsvo resulting
15:31:28 <kmc_> that's not right
15:31:43 <dmwit_> Cont r a is a closure around a value of type a.
15:31:43 <JoePeck> result type is a
15:31:47 <BONUS> a Cont r a is an ((a -> r) -> r)
15:31:52 <BONUS> so instead of just being a value of a
15:31:54 <Saizan_> dmwit_: not necessarily
15:32:09 <BONUS> it's a value that says: give me a function that takes an a (the continuation) and i'll plug that a in
15:32:21 <kmc_> return a = Cont ($ a)
15:32:22 <Saizan_> ?type \r -> Cont $ \_ -> r
15:32:23 <dmwit_> Saizan_: hum, enlighten me?
15:32:23 <lambdabot> forall a r. r -> Cont r a
15:32:45 <JoePeck> okay. Can anyone explain this syntax => "Cont x = do return 1" why is "Cont x" on the left side legal?
15:32:53 <__ent__> maybe i would be interested in parsing and stuff. any experience with parsec and happy?
15:32:59 <ddarius> JoePeck: Why wouldn't it be?
15:33:05 <kmc_> __ent__, yes, parsec is nice
15:33:25 <kmc_> JoePeck, where does it appear?
15:33:39 <Lemmih> JoePeck: It's like: Just x = do return 1
15:33:44 <dmwit_> Saizan_: Yes, okay, it's a closure that almost certainly closes around an 'a'. =P
15:33:47 <JoePeck> kmc_: its a simplification of homework that I'm trying to understand
15:33:57 <JoePeck> ddarius: well, my thoughts are that Cont x is like a constructor
15:33:58 <kmc_> the LHS of a bind like that is an arbitrary pattern
15:34:12 <kmc_> yeah, "Cont" is a constructor
15:34:14 <ddarius> Cont is a constructor.  What can you do with constructors.
15:34:15 <kmc_> so you can pattern match against it
15:34:26 <JoePeck> okay
15:34:30 <aavogt> :t "Cont"
15:34:31 <lambdabot> [Char]
15:34:38 <JoePeck> and the results I see in GHC
15:35:04 <BONUS> we call an ((a -> r) -> r) a CPS transformed a
15:35:13 <JoePeck> are that x (from the pattern) becomes visible to the entire scope of the rest of the file?
15:35:33 <kmc_> yeah, i was confused by a being doubly-contravariant
15:35:45 <kmc_> i see now that most values of Cont will close over a value of type a
15:35:51 <ddarius> JoePeck: If "rest" means "all," then yes.
15:35:53 <koeien> JoePeck: yes
15:36:15 <JoePeck> ddarius: koeien: wow, thanks guys =)
15:36:23 <JoePeck> kmc_: same to you =)
15:36:52 <__ent__> thank all for suggestions
15:37:14 <kmc_> a value of type "Cont r a" is an argument-provider
15:37:29 <kmc_> it provides the argument to a function of type (a -> r) and gives you the result
15:37:31 <kmc_> okay
15:38:23 <BONUS> it pays to look at first how CPS works without the Cont newtyping and monad
15:38:24 <BONUS> like
15:38:31 <kmc_> yeah, i'm familiar with CPS
15:38:38 <dmwit_> Saizan_: Out of curiosity, are there any other (where "other" means in the extensional sense) continuations that do not close over an 'a' value?
15:38:40 <BONUS> ah
15:38:43 <__ent__> bye
15:41:44 <Saizan_> dmwit_: you either apply the continuation or have an 'r' already, though talking about closures feels quite lowlevel
15:42:44 <dmwit_> I haven't had much sleep lately; I apologize if my questions are ill-conceived.
15:42:49 <Saizan_> ?type \f -> Cont . (. f)
15:42:50 <lambdabot> forall a a1 b. ((a -> b) -> a1) -> (a1 -> b) -> Cont b a
15:43:11 <Saizan_> uhm, disregard that
15:43:24 <blackh> Nafai, sproingie: I'm beginning to regret this.  I can't figure out how to sign my .changes files. Argh.
15:43:35 <Saizan_> dmwit_: ah, nothing to apologize for :)
15:43:51 <Nafai> blackh: for the PPA?
15:44:15 <Nafai> blackh: just a second, I think I had some explanations on that
15:44:21 <blackh> Nafai: Yes - dput wants the .changes files to be signed but it disregards anything I try to do.
15:44:59 <Nafai> hrm
15:46:05 <blackh> Nafai: None of the documentation tells me how to make a signature that dput will accept
15:46:41 <Nafai> blackh: Have you created your PPA?  It should have generated the key for you.  I think you need to import that key into your gpg keylist.  After that, I'm not sure
15:47:07 <blackh> Nafai: Ah - It said it was going to take hours to generate a key for me.  I don't see what that's all about, because I've already got a key!
15:47:20 <Nafai> :)
15:47:21 <blackh> Nafai: (That I generated myself.)
15:47:50 <blackh> Nafai: Also, how the hell do I "activate" it?? There's no link saying how to do this, even though the documentation says I can do it on the pfoiel page.
15:48:06 <blackh> Nafai: I've signed the code of conduct. Gah.
15:48:37 <blackh> Nafai: What a bloody waste of time.  I should put it on my own server.
15:48:50 <Nafai> :(
15:49:00 <Nafai> Sorry this has been so frustrating
15:51:12 <Vanadium> man, lambdacats never updates anymore
16:00:33 <blackh> Nafai: Nearly there!
16:00:40 <Nafai> yay
16:00:51 <blackh> Nafai: Just have to change the 'distroseries'
16:00:53 <Nafai> btw, #launchpad is the place to go complain about these problems I just found out
16:00:56 <Nafai> Ah
16:46:36 <ludflu> is anyone willing to do a code review for a haskell noob? http://github.com/ludflu/snapback/blob/master/snapback.hs
16:47:37 <ludflu> I just want to make sure I'm headed in the right direction
16:47:49 <mrbluesky> cd .xmonad
16:48:01 <mrbluesky> woops
16:48:07 <seanmcl> ludflu: small point, foldr (++) "" is List.concat
16:49:01 <ludflu> seanmcl: I know that's costly. But I'm not quite sure what to do instead
16:49:44 <seanmcl> oh, I just meant your program would be shorter (and a tiny bit more clear) if you use concat rather than foldr (++) ""
16:49:57 <dcoutts> mightybyte: your local repo is probably missing the 00-index.tar file
16:50:40 <ludflu> seanmcl: oh, I see. gotcha
16:51:12 <seanmcl> ludflu: I'm a bit nervous about the fromJusts in enemyNeighbors
16:51:40 <seanmcl> I find that when I use fromJust it probably means I could change the types around for better code
16:52:28 <blackdog> anyone know if it's possible to enumerate the symbols in a dynamic library? Obviously 'nm' can do it, but there doesn't seem to be an API call to do so - just dlopen and dlsym
16:52:41 <blackdog> (this is haskell related, promise:)
16:52:43 <seanmcl> ludflu: loadLib would be more clear as a fold (imo)
16:53:15 <ludflu> seanmcl: I just today figured out how to get the plain value out of the Maybe context when looking in a map. So....I need to think about how it could be better
16:53:17 <seanmcl> ludflu: I'd write more types for top level functions.  (I'd personally do all of them)
16:53:49 <ludflu> seanmcl: re: a fold for loadLib - thats just the kind of feedback I was hoping for
16:53:58 <seanmcl> ludflu: the code looks quite nice though.
16:54:14 <ludflu> seanmcl: thanks for taking a look
16:54:32 <seanmcl> ludflu: my pleasure
16:55:14 <ludflu> seanmcl: can you give me an example of a type you would add for a top level function?
16:55:46 <seanmcl> oh, like countLiberties :: [ ?? ] -> Int
16:56:04 <seanmcl> as a reader, I don't know what the type of the ?? is.  It would be nice to know that reading the code
16:56:16 <ludflu> seanmcl: oh I see - add signatures for all top level functions. gotacha
16:57:31 <seanmcl> a comment here and there wouldn't hurt :)
16:59:20 <ludflu> seanmcl: thanks again
17:00:50 <kmc_> :t ""
17:00:51 <lambdabot> [Char]
17:00:55 <soduko> cabal install --prefix=[my path] --extra-lib-dirs=[path to dir containing libsqlite3.so.0] --extra-include-dirs=[path to dir contianing sqlite3.h] but i still get errors about not being able to access the shared lib
17:01:14 <soduko> im on linux RHEL4
17:04:08 <soduko> what could i be missing?
17:08:35 <Axman6> :t par par par
17:08:36 <lambdabot> forall a b. a -> b -> b
17:08:40 <Axman6> :t par par par par
17:08:42 <lambdabot> forall b. b -> b
17:08:48 <Axman6> :t par par par par par
17:08:50 <lambdabot> forall a b. a -> b -> b
17:08:53 <aavogt> :t arr par
17:08:54 <lambdabot> forall b b1 (a :: * -> * -> *). (Arrow a) => a b (b1 -> b1)
17:09:01 <Axman6> :r arr par arr
17:09:07 <Axman6> :t arr par arr
17:09:08 <lambdabot>     Ambiguous type variable `a' in the constraint:
17:09:09 <lambdabot>       `Arrow a' arising from a use of `arr' at <interactive>:1:8-10
17:09:09 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
17:09:14 <Axman6> :(
17:09:23 <aavogt> @type par
17:09:24 <lambdabot> forall a b. a -> b -> b
17:09:35 <aavogt> @type flip const
17:09:36 <lambdabot> forall a b. b -> a -> a
17:09:41 <jasonmay> this bot is interesting
17:09:50 <mrbluesky> Does anyone here know how to change the default terminal in xmonad?
17:09:58 <aavogt> mrbluesky: to #xmonad !
17:10:07 <mrbluesky> righteo!
17:10:22 <aavogt> though the config file is a haskell program...
17:10:25 <Axman6> mrbluesky: i believe it's in the xmonad config file, you specify the terminal to use for the terminal command
17:10:33 <mrbluesky> yep I did that
17:10:51 <Axman6> reloaded xmonad?
17:10:55 <mrbluesky> and reloaded xmonad, but it's still opening xterm when I alt+shift+return
17:11:05 <Axman6> how odd
17:13:26 <mrbluesky> import XMonad
17:13:27 <mrbluesky>  
17:13:27 <mrbluesky> main = xmonad defaultConfig
17:13:27 <mrbluesky>         { terminal = "urxvt"
17:13:31 <mrbluesky> }
17:13:34 <mrbluesky> is my code
17:13:44 <mrbluesky> anything wrong with that?
17:14:23 <aavogt> that's good
17:14:39 <lgas> is there a de facto haskell regular expression library?
17:17:13 <MyCatVerbs> mrbluesky: Not at all if you happen to like most of XMonad's defaults. :)
17:17:32 <tommd> Anyone have a working e-mail for pngload package maintainer Marko Lauronen?  The one on hackage is bouncing.
17:18:00 <mrbluesky> urxvt is the default? oh, well that explains a bit.
17:18:05 <ac> is there a standard library function yet to break a list in to a list of lists N long?
17:18:14 <tommd> ac: no
17:18:17 <MyCatVerbs> mrbluesky: No, I said most of XMonad's defaults. :)
17:18:23 <ac> there really should be. I want to do that a lot
17:18:33 <tommd> Everyone agrees.  Not sure why it hasn't happened.
17:18:34 <kmc_> > map (take 3) $ iterate (drop 3) [1..]
17:18:34 <MyCatVerbs> mrbluesky: as in, terminal="urxvt" is the one thing in there that isn't set to the default value. :)
17:18:35 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23...
17:18:43 <kmc_> should be standard, and faster
17:18:52 <ac> kmc_: yeah, I have that or something real similar in a lot of programs
17:19:13 <kmc_> there are various improved-prelude projects aren't there?
17:19:27 <mrbluesky> Oh yeah, I just installed xmonad yesterday. I'm just digging into configging it today so I'll probably change more defaults later on.
17:20:11 <ac> kmc_: though I generally want takeWhile (not.null)
17:20:18 <MyCatVerbs> mrbluesky: cool. Really, there isn't anything wrong with leaving it at the defaults. :)
17:24:24 <MyCatVerbs> > (\n -> fix (\r l -> case splitAt n l of { ([],_) -> []; (h,t) -> h : r t)) 4 ['a'..'z']
17:24:24 <lambdabot>   <no location info>: parse error on input `)'
17:24:36 <MyCatVerbs> > (\n -> fix (\r l -> case splitAt n l of { ([],_) -> []; (h,t) -> h : r t; })) 4 ['a'..'z']
17:24:37 <lambdabot>   ["abcd","efgh","ijkl","mnop","qrst","uvwx","yz"]
17:26:53 <MyCatVerbs> I'm beginning to suspect that the real reason why (chunklist :: Int -> [a] -> [[a]]) isn't in the Prelude is because it makes a good introduction-to-Haskell exercise. ;P
17:28:19 <ac> is there a generalization of words that lets you specify a character to split on?
17:30:47 <ac> the definition of words should be: listSplit isSpace
17:32:04 <MyCatVerbs> Also not in the Prelude.
17:32:49 <ac> :'(
17:35:28 <seanmcl> is there a way to get a, say, dot graph of your module hierarchy?
17:36:07 <MyCatVerbs> > (\p -> fix (\r l -> case break p l of { (h,[]) -> [h]; (h,t) -> h : r t; })) isUpper "fooXbarZbazABCdef"
17:36:08 <lambdabot>   ["foo","","","","","","","","","","","","","","","","","","","","","","",""...
17:36:20 <MyCatVerbs> That isn't correct. :)
17:37:04 <dancor> how can something be IO-bound off of tmpfs?  memcopy is hard?
17:37:20 <ac> thhere should also be a function: splitOnce :: [a] -> (a -> Bool) -> ([a], [a])
17:38:07 <ac> ah partition
17:39:08 <dancor> ac: sounds more like span
17:39:24 <dancor> > span (== 'w') "hello world"
17:39:25 <lambdabot>   ("","hello world")
17:39:32 <dancor> > span (/= 'w') "hello world"
17:39:33 <lambdabot>   ("hello ","world")
17:39:39 <dancor> > partition (/= 'w') "hello world"
17:39:40 <lambdabot>   ("hello orld","w")
17:39:53 <ac> yeah, I don't get the usefulness of partition
17:39:55 <dancor> > break (== 'w') "hello world"
17:39:56 <lambdabot>   ("hello ","world")
17:40:16 <ac> what's the difference between break and span?
17:40:33 <ac> it just inverts the predicate?
17:40:36 <dancor> yes
17:40:39 <dancor> pretty lame huh
17:40:43 <ac> yeah
17:40:46 <dancor> partition is useful
17:41:42 <MyCatVerbs> > (\p -> fix (\r l -> case break p l of { (h,[]) -> [h]; ([],[]) -> []; ([],(_:xs) -> r xs; (h,t) -> h : r t; })) isUpper "fooXbarZbazABCdef"
17:41:43 <lambdabot>   <no location info>: parse error on input `;'
17:41:52 <MyCatVerbs> > (\p -> fix (\r l -> case break p l of { (h,[]) -> [h]; ([],[]) -> []; ([],(_:xs)) -> r xs; (h,t) -> h : r t; })) isUpper "fooXbarZbazABCdef"
17:41:54 <lambdabot>   ["foo","bar","baz","def"]
17:42:59 <ac> > break (== 'a') []
17:43:00 <lambdabot>   ("","")
17:43:10 <MyCatVerbs> Oh wait, that second pattern was kind of redundant.
17:43:28 <dancor> i always thought it should be breakMb :: (a -> Bool) -> [a] -> Maybe ([a], [a])
17:43:31 <ac> > break (== 'a') "bla"
17:43:32 <lambdabot>   ("bl","a")
17:44:07 <dancor> maybe there's an efficiency reason for the less-cool-type-safety-wise form of break
17:44:41 <ac> > break (== 'a') "blahblah"
17:44:42 <lambdabot>   ("bl","ahblah")
17:45:16 <aavogt> @type (\x -> guard (not $ null $ snd x) >> Just x) . break ?p
17:45:17 <lambdabot> forall a. (?p::a -> Bool) => [a] -> Maybe ([a], [a])
17:52:45 <MyCatVerbs> > fix (\r l -> case l of {[] -> [];(e:es) -> uncurry ((++) `on` r) . partition (>=e) $ l;}) [1,3,2,4,6,5,7,-7,3]
17:52:48 <lambdabot>   * Exception: stack overflow
17:53:00 <MyCatVerbs> ...oops?
17:54:04 <MyCatVerbs> > fix (\r l -> case l of {[] -> [];[e] -> [e];(e:es) -> uncurry ((++) `on` r) . partition (>=e) $ l;}) [1,3,2,4,6,5,7,-7,3]
17:54:09 <lambdabot>   mueval-core: Time limit exceeded
18:01:22 <MyCatVerbs> @pl \a b -> r a ++ e:r b
18:01:23 <lambdabot> (. ((e :) . r)) . (++) . r
18:03:23 <MyCatVerbs> > fix (\r l -> case l of {[] -> [];[e] -> [e];(e:es) -> (\(u,l) -> r u++[e]++r l) . partition (<e) $ es;}) [1,3,2,4,6,5,7,-7,3]
18:03:24 <lambdabot>   [-7,1,2,3,3,4,5,6,7]
18:13:28 <cjs> So, is there a version of the platform (alpha is fine) that includes GHC 6.12?
18:13:48 <blackdog> cjs: don't think so. I thought you were a 6.8 man, anyway :)
18:13:56 <cjs> No, I moved to 6.10 ages ago.
18:14:35 <cjs> I can't live without NamedFieldPuns any more. :-)
18:14:55 <blackdog> i think the idea is to let the library authors fix stuff with 6.12 first, so individual cabal packages will probably work
18:15:47 <blackdog> what does NamedFieldPuns do?
18:17:34 <sm> cjs not until january
18:17:56 <cjs> data Pair { x, y : Int }; add Pair{x,y} = x + y
18:18:28 <cjs> Right, so basically I want to get 6.12 and use it to build the Platform from source?
18:19:02 <blackdog> you'll get pretty mixed results
18:19:06 <blackdog> it certainly won't all compile...
18:19:17 <cjs> Really? Hmmm.
18:19:37 <cjs> I don't need the entire Platform, actually, just what came with ghc-extralibs.
18:20:08 <cjs> Where do I even get a build of 6.12 for Linux x86_64? Or do I need to build it myself?
18:20:29 <cjs> I thought for some reason 6.12 had been released.
18:20:36 <blackdog> need to build. it's still in release-candidate mode, i think
18:20:36 <cjs> Or is that January?
18:20:41 <cjs> Ah, ok.
18:21:23 <cjs> Ah, release is now "September-November 2009". :-)
18:21:44 <blackh> cjs: There is a ghc 6.12rc1 binary for Linux x86_64
18:21:57 <cjs> Ah, one of the nightly builds?
18:23:37 <blackh> cjs: http://darcs.haskell.org/~ghc/dist/6.12.1rc1/
18:24:03 <blackh> cjs: For the difference between the -n and other version, see haskell.org/ghc/
18:26:10 * hackagebot upload: ipc 0.0.4 - High level inter-process communication library (ThomasDuBuisson)
18:26:49 <blackh> sproingie, Nafai: Time to give up.  I've got the Haskell Platform built for Ubuntu - the only problem is that PPA wants source archives, so effectively I have to start again from the beginning.
18:27:35 <shellsage> Can someone help me convert this code to use the State monad?  http://pastebin.com/d7bf1cb9a
18:30:04 <blackh> shellsage: Do you want to pass macros as state?
18:30:33 <cjs> I think that the current SExpr is supposed to be the state.
18:31:50 <cjs> It could be as simple as just sexpr <- get; modify; put sexpr.
18:32:25 <blackh> This code is great the way it is. :)
18:34:33 <fbru02_> my problem with haskell is that the error messages are scary :(
18:35:01 <blackh> fbru02_: What about "brain exploded" - that's a good one. :)
18:35:05 <shellsage> blackh, yeah, I want to pass macros as state
18:35:28 <blackh> shellsage: Since you're not modifying it you could use a Reader monad.
18:35:58 <fbru02_> blackh: yeah, sometimes when im about to compile/run the program , i pray for my program to match the types i annotated but rarely happens
18:36:06 <shellsage> blackh, I'm trying to get more familiar with the State monad
18:36:21 <blackh> shellsage: Well, the state monad will work fine.
18:36:37 <shellsage> blackh, I'm having trouble figuring out how to apply it in this context
18:37:18 <blackh> shellsage: So you want your type to be substitute :: (Eq a, Show a) => SExpr a -> State (LMacros a) SExpr a
18:37:21 <fbru02_> :r Proc
18:37:25 <fbru02_> :t Proc
18:37:26 <lambdabot> Not in scope: data constructor `Proc'
18:37:30 <blackh> I mean... substitute :: (Eq a, Show a) => SExpr a -> State (LMacros a) (SExpr a)
18:38:42 <blackh> shellsage: s (Proc parm body) = ... becomes:   s (Proc parm body) = do ; body' <- s body ; return $ Proc parm body'
18:39:44 <blackh> You can shorten this to 'Proc parm <$> s body' but best to make sure you understand the simple way first.
18:40:43 <cjs> Agh! ghc-pkg list output is coloured!
18:40:59 <blackh> AND: s var@.. = do ; macros <- get ; case .. of ; .. = s expr ;  .. = return $ var
18:41:02 <blackh> ^ Very mangled
18:41:50 <shellsage> blackh, ok let me try that
18:42:06 <shellsage> what's the diff between <$> and $
18:42:19 <blackh> shellsage: This whole business of converting between monadic and non-monadic code is fine once you get used to it.
18:42:42 <Vanadium> <$> is fmap
18:42:48 <Vanadium> $ is id
18:43:00 <blackh> shellsage: f <$> y is equivalent to z <- y ; return $ f z
18:43:35 <blackh> shellsage: <$> "lifts" a pure function into a monad
18:47:50 <fbru02> blackh: i have a question
18:48:20 <BMeph> s/monad/functor/ , but why quibble? ;)
18:48:45 <cjs> Hm. So, there aren't too many packages I need beyond the standard ones in 6.12, just a few things like network, HUnit, and so on. Would it be best to just grab these invidually and build them, or to grab the platform and pull out the parts I don't need and/or don't build?
18:49:11 <blackdog> cabal-install them. i haven't bothered with the Platform at all, to be honest.
18:49:33 <blackh> cjs: As far as I know, you have to do it all the hard way using 'runhaskell Setup'.
18:50:40 <blackdog> blackh: dcoutts has patched cabal-install to work with ghc 6.12. you just have to get the darcs version.
18:51:16 <cjs> Ah, of course, because cabal-install fetches the source and builds it, right?
18:51:26 <cjs> (I use my own build system, so I'm not so familiar with cabal.)
18:51:34 <blackh> blackdog: I'm pleased about that. Unfortunately it means I have to do some work on cabal-install myself!
18:51:41 <blackh> while it was broken I was off the hook
18:51:54 <blackdog> blackh: heh. for the mac dylib stuff?
18:52:26 <blackh> blackdog: No - this is some older stuff I did - ticket #89 - to do with that problem of everything getting built twice.
18:53:32 <ac> is there a standard library function to display doubles without scientific notation?
18:54:14 <ac> I want to give it a decimal precision
18:54:14 <blackh> ac: Numeric package - showFFloat does it if you give it a number of decimal places
18:54:59 <aavogt> > showFFloat 1e10 ""
18:55:00 <lambdabot>   No instance for (GHC.Real.Fractional
18:55:00 <lambdabot>                     (Data.Maybe.Maybe ...
18:55:07 <aavogt> > showFFloat Nothing 1e10 ""
18:55:08 <lambdabot>   "10000000000.0"
18:55:18 <aavogt> > showFFloat (Just 10) 1e10 ""
18:55:19 <lambdabot>   "10000000000.0000000000"
18:55:26 <ac> cool
18:55:36 <aavogt> > showFFloat (Just 10) 1e10 " this is a string to which the number is appended"
18:55:37 <lambdabot>   "10000000000.0000000000 this is a string to which the number is appended"
18:56:11 <kmc> :t showFFloat
18:56:12 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
18:56:34 <aavogt> it's just an optimization thing, since that kind of appending is constant time, instead of linear in the length of the first string
18:57:19 <kmc> > showFFloat (Just 2) pi ""
18:57:20 <lambdabot>   "3.14"
18:57:25 <kmc> > showFFloat (Just 0) pi ""
18:57:26 <lambdabot>   "3"
18:57:31 <kmc> > showFFloat (Just -4) pi ""
18:57:32 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe GHC.Types.Int'
18:57:32 <lambdabot>         again...
18:57:38 <kmc> > showFFloat (Just (-4)) pi ""
18:57:39 <lambdabot>   "3"
18:57:44 <kmc> > showFFloat Nothing pi ""
18:57:45 <lambdabot>   "3.141592653589793"
18:57:46 <ac> those arguments are on a number of functions that return strings. It annoys me
18:59:02 <aavogt> ac: what do you mean?
18:59:20 <ac> the argument that's just appended to the return value
19:00:37 <aavogt> @let showF prec n = showFFloat (Just prec) n ""
19:00:38 <lambdabot>  Defined.
19:00:46 <aavogt> > showF 10 pi
19:00:47 <lambdabot>   "3.1415926536"
19:03:20 * hackagebot upload: feldspar-language 0.1 - A functional embedded language for DSP and parallelism (EmilAxelsson)
19:05:32 <kmc> [citation needed]
19:06:57 <aavogt> > show (pi :: CReal)
19:06:57 <lambdabot>   "3.1415926535897932384626433832795028841972"
19:08:10 <shellsage> blackh, so this? http://pastebin.com/d5ce1feab
19:09:36 <shellsage> hm, getting a parse error
19:10:02 <shellsage> after the of
19:10:04 * stroan just noticed he'd been talking to himself for the last ten minutes while solving this problem...
19:10:08 <blackh> shellsage: return $ Proc parm body <- add '
19:10:20 <blackh> shellsage: indent your [ lines
19:10:29 <shellsage> ah right
19:10:42 <aavogt> @arr
19:10:43 <lambdabot> Har de har har!
19:10:53 <kmc> @nixon
19:10:54 <lambdabot> If you think the United States has stood still, who built the largest shopping center in the world?
19:11:14 <shellsage> blackh, [(macro, L(expr))] = s expr
19:11:26 <shellsage> parse error on input `='
19:23:27 <sjanssen> is there a good data structure for recording a "stacking" order of items?  The best I can come up with is a a mutable linked list, but that's obviously undesirable
19:23:55 <Axman6> stacking how?
19:24:04 <sjanssen> like windows in X11 :)
19:24:18 <Axman6> had a look at how Xmonad does it?
19:24:37 <blackh> shellsage: Should be ->, not =
19:24:42 <Axman6> it used something like data Stack a = Stack [a] a [a]
19:24:45 <shellsage> oh oops
19:24:45 <sjanssen> Axman6: xmonad doesn't do it, I'm working on that
19:24:51 <SamB_XP> sjanssen: hmm ?
19:25:02 * Axman6 doesn't know what's going on then
19:25:04 <SamB_XP> what's wrong with the zipper ?
19:25:13 <SamB_XP> sjanssen: what kind of stacking do you mean ?
19:25:21 <sjanssen> I want to maintain z-order on the windows, if that's more clear
19:25:31 <shellsage> blackh, what was the get you were referring to?
19:26:02 <SamB_XP> sjanssen: that doesn't sound very Xmonady ;-P
19:26:06 <blackh> shellsage: 15 mins ago you said [(macro, L(expr))] = s expr / parse error on input `='
19:26:07 <sjanssen> I think mathy types would call this a "total order", each window has one sibling immediately above and below
19:26:15 <blackh> I expect you got it by now anyway
19:26:22 <SamB_XP> sjanssen: yeah
19:26:31 <sjanssen> SamB_XP: tiling WMs can ignore z-order most of the time, but it gets ugly when you mix in floating windows
19:26:42 <SamB_XP> sjanssen: yeah ...
19:26:44 <Axman6> sjanssen: how does that type i wrote not do that?
19:26:54 <shellsage> blackh, no what was the get
19:27:07 <shellsage> macros <- get
19:27:07 <Axman6> the first list is the list of windows abode the current one, and the second is the ones below
19:27:11 <sjanssen> Axman6: I guess it does sort of do that, but doesn't support the queries I'd like efficiently
19:27:21 <SamB_XP> sjanssen: what queries are those ?
19:27:59 <sjanssen> SamB_XP: I want a stackAbove function, changes the stacking order such that a window is immediately above another
19:28:21 <sjanssen> should be possible to do that in O(log n) time, I just can't think of a nice way
19:28:43 <SamB_XP> well, when are you going to need to do this ?
19:29:28 <sjanssen> SamB_XP: whenever the X server tells me that stacking order has changed
19:30:38 <blackh> shellsage: Sorry - got confused.
19:31:29 <blackh> shellsage: No - still confused - you might have to start from the beginning.
19:31:39 <Axman6> heh
19:31:39 <SamB_XP> hmm, in that case, my brain is going to explode trying to figure out an approach
19:32:04 <aavogt> @quote brain.explode
19:32:05 <lambdabot> No quotes match. stty: unknown mode: doofus
19:32:09 <aavogt> @quote brain*.explode
19:32:10 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
19:32:18 <SamB_XP> @quote brain.*
19:32:18 <lambdabot> HarriKiiskinen says: banging my head against Haskell, but liking the feeling of hurting brains
19:32:24 <SamB_XP> @quote brain.*
19:32:25 <lambdabot> _Stinger_ says: sometimes Haskell seems like an arms race between weird mathematical constructs and my brain
19:32:38 <aavogt> @quote brain.just
19:32:38 <lambdabot> ghc says: My brain just exploded.
19:32:50 <shellsage> blackh, in the code you wrote, you had a line that said " macros <- get"
19:32:52 <sjanssen> one can emulate a doubly linked list with a Map Window (Prev, Next), but that's pretty ugly (even more ugly than the C version with pointers)
19:33:05 <shellsage> blackh, s var@.. = do ; macros <- get ; case .. of ; .. = s expr ;  .. = return $ var
19:33:08 <cjs> What does cabal-setup do?
19:33:42 <blackh> shellsage: That's it - that pulls the value of macros out of the state monad's state.  Your code is exactly what I intended.
19:33:56 <blackh> shellsage: Do you know how to run this state monad?
19:34:00 <sjanssen> cjs: I believe it's a pre-compiled generic 'Setup.hs'.  I think it's deprecated
19:34:42 <aavogt> sjanssen: does X just give a number for which position each window has?
19:34:45 <cjs> Heh. The entirety of it is "main = getArgs >>= flip setupWrapper Nothing" :-)
19:35:11 <aavogt> maybe it's a justification to have Window be some more complicated object
19:35:31 <SamB_XP> aavogt: what, mutability ?
19:35:53 <sjanssen> aavogt: ConfigureNotify events give "above-sibling", another window that the window is now above
19:36:21 <aavogt> no, immutable, but have the ordering built into the contents of the zipper
19:36:30 <aavogt> but I guess that information isn't immediately available
19:36:41 <sjanssen> aavogt: actually, I'm thinking of a structure divorced from the zipper
19:36:45 <shellsage> blackh, seemingly not because it's telling me get is not in scope
19:37:09 <sjanssen> StackSet would be for an xmonad-ish view of the world, then we'd have ServerCache (or whatever) that keeps an X11-ish view
19:37:12 <cjs> Grr. Can't cabal-install network.
19:37:18 <blackh> shellsage: get comes from Control.Monad.State
19:37:32 <aavogt> is there really a need to have a different swaping order for floating windows than the z-order?
19:38:00 <sjanssen> aavogt: swapping order should be stack order, I think.  There are other reasons we want z-order
19:38:02 <aavogt> perhaps it would just be better to synchronize them (but knowing when to update one or the other seems like a tricky business)
19:38:17 <sjanssen> for example, xmonad makes way more configure requests on the windows than necessary thanks to stacking
19:38:55 <sjanssen> getting pretty xmonad-specific now, move to #xmonad?
19:39:39 <SamB_XP> well, you're still talking about data structures ...
19:39:57 <sjanssen> okay, if people are interested
19:40:28 <aavogt> another point of view is that we need a zipper with two elements in focus
19:41:17 <sjanssen> here's the state of affairs now: high level xmonad code determines geometry -> our 'windows' function turns high level geometry into medium-level X11 library calls
19:41:59 <mxc> anyone ever see this when compiling for profiling:      Dynamic linking required, but this is a non-standard build (eg. prof).
19:42:01 <mxc>     You need to build the program twice: once the normal way, and then
19:42:01 <mxc>     in the desired way using -osuf to set the object file suffix.
19:42:03 <sjanssen> with much redundancy, as windows is fairly ignorant of current X11 state, and because xmonad's view of the world is different from the X11 protocol
19:42:24 <sjanssen> aavogt: the problem I'm talking about is different from the floating/tiled focus thing
19:43:00 * aavogt does a refresher of what 'windows' actually does
19:43:20 <sjanssen> aavogt: everything.  And I'm not even joking
19:43:22 <SamB_XP> mxc: never!
19:44:02 <mxc> comes up after the Loading package XXX ... linking ... done output when its about to run TH code
19:44:10 <SamB_XP> mxc: GHC's plan sounds rather implausible to me, as well!
19:44:13 <SamB_XP> oh
19:44:15 <SamB_XP> for TH code
19:44:36 <SamB_XP> mxc: it needs a non-profiling build so that it can load the modules in GHCi
19:44:54 <SamB_XP> so that it can use them to run the TH
19:44:56 <mxc> yeah, so i built it once w/out -prof
19:45:00 <SamB_XP> okay ...
19:45:02 <mxc> this came up the second time too
19:45:02 <mxc> w
19:45:06 <mxc> hen all the .o files were there
19:45:34 <SamB_XP> well, you do need to use suffixes or something so that they stick around ...
19:45:48 <sjanssen> so I want to add a step to that flow chart: high level geom. -> windows massages that into X-like requests -> a server state cache consolidates requests and only executes the real changes
19:46:12 <SamB_XP> ... because you need those vanilla .os/.his for TH to load in GHCi
19:46:22 <sjanssen> eg. if a window doesn't change geometry between two calls to 'windows', we should be able to avoid making two configure requests on that window
19:46:26 <aavogt> is most of the problem caused by the use of restackWindows :: Display -> [Window] -> IO () ?
19:46:48 <sjanssen> aavogt: restackWindows is a problem, yes
19:47:50 <mxc> ok, so when i run with -prof, i should also add -osuf o_p or something so it doesn't overwrite the vanilla obj files
19:47:54 <Lemmih> mxc: Cabal can do it for you.
19:50:12 <mxc> ah
19:50:14 <mxc> got it
19:50:19 <mxc> need ot add --enable-executable-profiling when you configure
19:50:23 <mxc> not sure why that slipped my mind
19:50:25 <mxc> thanks
19:51:36 <shellsage> blackh, ok I think this is the last error:  Kind error: `State' is applied to too many type arguments
19:51:36 <shellsage>     In the type `State (LMacros a) SExpr a'
19:51:36 <shellsage>     In the type `SExpr a -> State (LMacros a) SExpr a'
19:51:36 <shellsage>     In the type `(Eq a, Show a) =>
19:51:36 <shellsage>                  SExpr a -> State (LMacros a) SExpr a'
19:52:02 <blackh> shellsage: State (LMacros a) (SExpr a)
19:52:59 <travisbrady> anyone have thoughts on parsing a length prefixed ASCII wire protocol with Haskell? I'm trying to decide if I should using Parsec and also if I should mix the parsing code with the socket reads
19:53:25 <shellsage> ah, right
19:53:46 <aavogt> sjanssen: for the z-order Data.Sequence is probably cleaner (and just as fast) as rolling something with  Map x (next,prev). The previous geometry can be a (Map Window Rectangle), sort of like PositionStore from Jan's bluetile branch
19:54:26 <sjanssen> aavogt: so how do we support locating a window in a Seq?  Wouldn't that be O(n)?
19:54:41 <aavogt> my guess is that the two things to cache aren't going to fit nicely in a single data structure
19:55:16 <Dunb> Hello. Is this thing good: http://sourceforge.net/projects/eclipsefp/ ?
19:55:37 <stroan> Dunb: I found it pretty much unusable, but that could have been my fault
19:56:10 <kmc> travisbrady, if it's length prefixed, i would grab a whole chunk then parse it
19:56:18 <aavogt> sjanssen: ah, I was wrongly assuming that we knew the index
19:56:38 * hackagebot upload: feldspar-compiler 0.1 - Compiler for the Feldspar language (EmilAxelsson)
19:56:39 <aavogt> which could be stored in a Map, and still preserve overall log(n) lookup / update
19:57:23 <Dunb> mmh ok.
19:57:25 <Dunb> thanks
19:57:35 <sjanssen> aavogt: actually, integral indexes makes it O(n) as well, when moving a window from bottom to top every index will change
19:57:51 <travisbrady> kmc: each bit is length prefixed, a list of values looks like "$1\r\n$3\r\nfoo\r\n" where the first 1 refers to the total record count
19:58:51 <shellsage> blackh, so if the type sig is now different, how do I call this?
19:58:57 <shellsage> I don't pass in macros anymore right?
20:00:07 <aavogt> ah, that map of indices doesn't cut it
20:00:11 <blackh> shellsage: You have to say ... let expr' = evalState (substitute expr) macros
20:00:28 <kmc> travisbrady, i don't see a role for parsec here, unless the individual values have further structure
20:00:36 <shellsage> blackh, ok I think I'm getting it
20:01:03 <travisbrady> kmc: ok yeah it seems like overkill, but maybe I was sort of hoping to have a chance to play with parsec
20:01:06 <blackh> shellsage: Cool!
20:02:16 <kmc> hmm i'm not saying it can't be done, but i don't think you'll really use its capabilities either
20:02:22 <blackh> shellsage: Note that your state monad is completely pure.  Don't associate monads with impure code.
20:02:24 <aavogt> sjanssen: well in the worst case you brought up, one could leave the indices as-is and offset them by whatever the current min/max is. But that seems to occur a cost when inserting stuff in the middle.
20:02:39 <aavogt> however, is it even possible to raise a window not to the top?
20:02:44 <shellsage> blackh, not quite sure what that means, but I won't, heh
20:02:58 <sjanssen> aavogt: in the X11 protocol, yes
20:03:07 <aavogt> in practice?
20:03:33 <Dunb> I don't understand how to run the program in eclipse
20:03:36 <sjanssen> aavogt: one can request that a window goes to the top, bottom, or immediately above/below a given sibling
20:03:46 <sjanssen> aavogt: yeah, we'd see it in practice too
20:03:55 <blackh> shellsage: Well, the IO monad is not pure.  Sometimes people don't realize that monads are often completely pure.
20:04:01 <shellsage> ah ok
20:04:08 <aavogt> ah, so it isn't fully random access
20:04:11 <cjs> Is parsc-3 backwards-compatible with parsec-2, at least enough for cabal-install?
20:04:21 <shellsage> blackh, ghci is giving me some beef about the type sig of substitute
20:04:38 <shellsage> Couldn't match expected type `SExpr a'
20:04:38 <shellsage>            against inferred type `LMacros Symbol'
20:04:38 <shellsage>     In the first argument of `substitute', namely `macros'
20:04:56 <shellsage> I did:
20:04:57 <cjs> Oh, it's network that needs it.
20:04:58 <shellsage> > rs :: LMacros Symbol -> String -> SExpr Symbol
20:05:00 <lambdabot>   Not in scope: type constructor or class `LMacros'Not in scope: type constru...
20:05:03 <shellsage> > rs macros = evalState (substitute (. r)) macros
20:05:04 <lambdabot>   <no location info>: parse error on input `='
20:06:05 <blackh> shellsage: Did you type "evalState (substitute expr) macros" ?
20:06:31 <blackh> shellsage: Oh, I see what you typed.
20:06:43 <shellsage> blackh, my r function returns a SExpr
20:07:10 <blackh> shellsage: That . doesn't make any sense to me
20:07:18 <shellsage> blackh, you and me both
20:07:18 <shellsage> heh
20:07:45 * aavogt wonders how it would work to have one queue (as in two regular lists) for the above windows and the same for the windows below, with the focused as a separate field
20:07:59 <shellsage> blackh, the original was: rs macros = substitute macros . r
20:08:30 <blackh> shellsage: That means... rs macros x = substitute macros (r x)
20:08:43 <aavogt> sjanssen: in other words  type Queue a = ([a],[a]);  data ZOrder = ZOrder { up :: Queue a, foc :: a, down :: Queue a }
20:08:46 <blackh> shellsage: So you want rs macros x = evalState (substitute (r x)) macros
20:08:50 <shellsage> blackh, ok
20:08:50 <Dunb> How do I install the "scion server" thing
20:09:04 <sjanssen> aavogt: what is 'foc'?  The window with keyboard focus?
20:09:22 <aavogt> the current level of z-focus
20:09:34 <Dunb> is it the same as the scion library?
20:09:37 <aavogt> keyboard focus makes sense
20:10:14 <aavogt> I'm just hypothesizing that such a thing behaves ok, since a queue made from two lists ends up being ok after the occasional reverses are ammortized
20:10:16 <shellsage> blackh, ok got past that hurtle
20:10:35 <shellsage> blackh, now it's saying that the type for substitute has only one arg, but we're passing it 2
20:10:49 <aavogt> obviously there are some pathological usage patterns that are still O(n_in_queue)
20:10:56 <blackh> shellsage: In an earlier version you had an extra 'macros' argument - you want ot get rid of that
20:11:16 <shellsage> > rs :: LMacros Symbol -> String -> SExpr Symbol
20:11:16 <shellsage> > rs macros expr = evalState (substitute (r expr)) macros
20:11:17 <lambdabot>   <no location info>: parse error on input `='
20:11:17 <lambdabot>   Not in scope: type constructor or class `LMacros'Not in scope: type constru...
20:11:27 <shellsage> - > substitute :: (Eq a, Show a) => LMacros a -> SExpr a -> SExpr a
20:11:27 <shellsage> - > substitute macros expr = s expr where
20:11:38 <shellsage> wait oops
20:11:44 <shellsage> the last 2 lines were the orig
20:11:49 <shellsage> > substitute :: (Eq a, Show a) => SExpr a -> State (LMacros a) (SExpr a)
20:11:49 <shellsage> > substitute macros expr = s expr where
20:11:51 <lambdabot>   Not in scope: type constructor or class `SExpr'Not in scope: type construct...
20:11:51 <lambdabot>   <no location info>: parse error on input `='
20:12:03 <Axman6> shellsage: are you doing this in ghci?
20:12:29 <sjanssen> interesting notion: X11 configure requests are monoids!
20:12:47 <shellsage> Axman6, yeah
20:12:54 <Axman6> shellsage: well, you'll need to use let
20:13:08 <shellsage> Axman6, where
20:13:09 <Axman6> let substitute :: (Eq a, Show a) => SExpr a -> State (LMacros a) (SExpr a); substitute macros expr = s expr where
20:13:23 <shellsage> Axman6, let me rephrase, I'm writing this in an lhs file and loading it w/ ghci
20:13:37 <Axman6> ah, well, that's different then
20:14:22 <shellsage> blackh, ^
20:14:45 <sjanssen> aavogt: I think Map Window (Prev, Next) really is the best we can do
20:15:12 <blackh> shellsage: It should say substitute expr = s expr where
20:15:35 <shellsage> blackh, holy crap it works
20:15:45 <aavogt> so you have to go updating quite a bit of elements when the current gets changed
20:15:53 <shellsage> blackh, now can you explain how exactly macros is used here?
20:16:10 <shellsage> is it fetched by macros <- get
20:16:14 <shellsage> from the State monad?
20:16:39 <blackh> shellsage: That's what happens with Haskell.  You fight the compiler until you are just about ready to delete your GHC installation and warn everyone off this terrible language.  Then finally it compiles, and ... IT WORKS!
20:16:54 <aavogt> well you have to modify no more than three members
20:16:55 <shellsage> blackh, yeah no kidding lol
20:17:02 <blackh> shellsage: And it works with 400-line programs and sometimes with 1000-line programs!
20:17:26 <aavogt> sjanssen: yeah, I doubt that there's something more efficient
20:18:11 <blackh> shellsage: Exactly - 'macros <- get' pulls it out of the state monad
20:18:13 <aavogt> actually make that four when swapping
20:19:43 <shellsage> blackh, ok the real test, to see if I can do this with another function
20:22:31 <Dunb> I think I'll try again haskell in a linux virtual machine
20:22:43 <Dunb> making this thing work in Windows is just boring
20:23:27 <shellsage> blackh, in the type sig, why did you say:  State (LMacros a) (SExpr a)
20:23:33 <shellsage> what's w/ the second param
20:24:29 <blackh> shellsage: The first param is the type of the state value, and the second param is the type of the return value of the function.  So, you're putting "State (LMacros a)" before the return type you had before.
20:24:34 <Dunb> Oh, I actually have vm
20:25:01 <shellsage> blackh, ok that makes sense
20:25:03 <aavogt> sjanssen: actually, using two queues should be O(1) for all the Z order changes, since all we do is either prepend or append to one of them (possibly twice). (the queue could be Data.Sequence)
20:25:49 <aavogt> hmm, sorry that doesn't allow for lookup
20:25:51 <blackh> shellsage: Types work like functions - "State (LMacros a)" can be thought of as a type-level function that turns a pure value into a state monad wrapping that value.
20:26:15 <blackh> shellsage: Or rather, a state monad returning a value of that type
20:26:46 <aavogt> hmm, but one can do a binary search on a Seq
20:27:04 <aavogt> actually no, since they aren't ordered
20:27:39 <sjanssen> it may be possible to do this with a single FingerTree, but that's approaching overkill
20:27:52 <shellsage> blackh, ok
20:28:24 <shellsage> blackh, so here's a question:  I've got a function I'm converting to use State monad, but this function only takes one parameter.  The thing is, based on this parameter's type, I want to do something different
20:28:54 <sjanssen> or we could use infinite precision rationals
20:29:06 <blackh> shellsage: Do you mean that you're pattern matching the parameter?  This works just the same in a monad.
20:29:42 <dancor> is it feasible to make a binary serializer that just amounts to a memcopy and setting a pointer to the beginning of it for loading the data structure
20:29:53 <shellsage> blackh, yeah, so:  wrap (Name name) = something;   wrap (Proc parm body) = something else;
20:30:31 <ACSpike[Home]> I'm working through YAHT and trying the exercises, but I don't want to look at the solutions, because I want a second change to get it right. would anyone be willing to look at my answers and give me a hint for improvement if I'm way off? (no spoilers please)
20:30:59 <blackh> shellsage: Yes... as far as the type of your function goes, all you're changing is the _return type_ when you convert it to use a state monad.  So all the pattern matching is the same on the parameters.
20:31:28 <kmc> ACSpike[Home], sure
20:31:33 <kmc> i haven't read YAHT
20:31:42 <shellsage> blackh, but how do I fetch the state param from the State monad if there is only this one parameter and I still need to pattern match?
20:32:11 <ACSpike[Home]> kmc: I wouldn't be spoiling it for you would I?
20:32:18 <kmc> nope
20:33:24 <blackh> shellsage: if the type is "SomeArg -> State (LMacros a) SomeReturnType" then that's all you need.
20:33:44 <blackh> shellsage: In that function you can say do ; x <- get and it'll get your 'LMacros a' value
20:33:59 <shellsage> blackh, unfortunately it's not, it's:  wrap :: (Eq t, Show t, Num t1) => LExpr t -> LExpr (t1, t)
20:34:15 <blackh> shellsage: Then that's not a state monad.
20:34:17 <shellsage> so only one arg, but also need to pattern match the same arg that will be used for state
20:34:37 <shellsage> blackh, so a state monad needs at least 2 args if you're going to pattern match?
20:34:42 <ACSpike[Home]> kmc: exercise 4.6 http://haskell.pastebin.com/m34404a7e I am a little confused about what the author wants but I think the behaves well. wondering if there is some clever and more succinct way
20:35:06 <shellsage> blackh, assuming one of the args is going to turn into the state
20:36:21 <cjs> Agh. Where does one get a cabal-install that works with Cabal 1.8?
20:36:26 <kmc> ACSpike[Home], it looks good
20:36:44 <blackh> shellsage: If you want wrap to have access to 'macros' you'll need to either 1. pass it explicitly as an extra arg, 2. take it from the enclosing context, or 3. change wrap into a state monad.  Do you want the first one?
20:36:49 <cjs> Not to mention base-3 or base-4.
20:37:02 <shellsage> blackh, sorry, should've explained
20:37:05 <blackh> cjs: the darcs repo
20:37:09 <kmc> ACSpike[Home], it's usually good to give type signatures for all top-level values
20:37:15 <ACSpike[Home]> kmc: are you willing and able to compare with the YAHT author's proposed solution?
20:37:25 <cjs> Really? They've done a release of Cabal 1.8 but not of a cabal-install that works with it?
20:37:26 <shellsage> blackh, wrap doesn't need macros, its state is controlled by its only param
20:37:40 <ACSpike[Home]> kmc: what is a top-level value?
20:37:45 <shellsage> the current implementation does pattern matching
20:37:53 <cjs> Or they've not done a release of 1.8 and something resembling 1.8 is just included in GHC anyway?
20:37:59 <kmc> sorry "top-level binding" is a better term
20:38:18 <kmc> anything which is defined at the "outermost" layer of your program, as opposed to in a "let" or "where" construct
20:38:25 <kmc> here tuple1 through tuple4
20:38:26 <porges> what does aleph_0 ^ aleph_0 equal?
20:39:00 <ACSpike[Home]> kmc: got it. I have to be careful because I keep finding that normal english words are being re-purposed all around me :-)
20:39:03 <kmc> ACSpike[Home], the solution the YAHT author gives is more general
20:39:04 <blackh> shellsage: Sounds like wrap can stay the same.
20:39:15 <shellsage> blackh, yeah...
20:39:15 <ACSpike[Home]> kmc: hint as to how?
20:39:42 <kmc> is this a valid value in your program?  Tuple2 'x' 3
20:39:55 <ACSpike[Home]> kmc: nope
20:40:17 <kmc> in their version it is
20:40:58 <ACSpike[Home]> kmc: I considered that, but I didn't know how to make a type with a varying number of type parameters
20:41:09 <kmc> ACSpike[Home], you can't
20:41:17 <kmc> but you don't need to use every parameter in every constructor
20:41:35 <kmc> indeed, you can have parameters which are not used at all, although the practical uses for that are a bit more advanced
20:41:40 <ACSpike[Home]> ah hah! like Nothing in Maybe
20:41:46 <kmc> yes, exactly
20:41:53 <ACSpike[Home]> heh
20:41:54 <kmc> :t Nothing
20:41:55 <lambdabot> forall a. Maybe a
20:42:17 <kmc> @src Maybe
20:42:18 <lambdabot> data Maybe a = Nothing | Just a
20:42:49 <ACSpike[Home]> yeah, I've seen that forall in docs, but my ghci just says "Nothing :: Maybe a"
20:43:15 <kmc> yeah, the "forall a" bit is an extension, not part of standard haskell 98
20:43:31 <kmc> in h98, every type variable implicitly gets a "forall"
20:43:43 <ACSpike[Home]> is there anything special about whether ghci picks a and b or t and t1 for type place holders?
20:43:50 <kmc> no
20:44:21 <kmc> any identifier starting with a lowercase character can serve as a type variable
20:44:34 <kmc> same as for value-level variables, but the syntax keeps them separate
20:45:05 <ACSpike[Home]> ok
20:47:37 <ACSpike[Home]> kmc: http://haskell.pastebin.com/m220d0bba
20:48:00 <kmc> looks good
20:48:07 <kmc> can you write type signatures for tuple1 through tuple4?
20:50:54 <ACSpike[Home]> kmc: http://haskell.pastebin.com/m3417f247
20:53:54 <ACSpike[Home]> kmc: Thanks. now, I'm completely lost on ex 4.7 unless I nest the Either like "Left Left a" or "Left Right (a,b)" or "Right Left (a,b,c)" or "Right Right (a,b,c,d)"
20:55:56 <kmc> yeah, i think that's the idea
20:56:00 <kmc> not something i'd ever do in real code
20:56:34 <kmc> if you find yourself nesting Either like that, it's usually better to define your own type... which you already did
20:56:59 <allbery_b> but there is at least one haskell tutorial which asks you to do that
20:57:14 <ACSpike[Home]> so the function type would be something like "myfun :: Tuple a b c d -> Either (Either a (a,b)) (Either (a,b,c) (a,b,c,d))"
20:57:15 <allbery_b> (note your parens are wrong though)
20:58:14 <ACSpike[Home]> allbery_b: "Left (Left a)" "Left (Right (a,b))" ?
20:58:18 <allbery_b> yes
20:58:25 <allbery_b> :t Left Left ??a
20:58:26 <lambdabot> Not in scope: `??'
20:58:30 <allbery_b> whoops
20:58:31 <allbery_b> :t Left Left ?a
20:58:33 <lambdabot>     Couldn't match expected type `t1 -> t'
20:58:33 <lambdabot>            against inferred type `Either (a -> Either a b1) b'
20:58:33 <lambdabot>     In the expression: Left Left ?a
20:59:00 <ACSpike[Home]> what's ? do there?
20:59:15 <kmc> :t Left (Left ?a)
20:59:16 <lambdabot> forall a b b1. (?a::a) => Either (Either a b) b1
20:59:29 <allbery_b> implicit parameter.  in this case it's used as a hack to sneak a value in without typing it
20:59:38 <kmc> :t \a -> Left (Left a)
20:59:39 <lambdabot> forall a b b1. a -> Either (Either a b) b1
20:59:46 <allbery_b> thus asking ghc to type it for me
20:59:47 <ACSpike[Home]> ah, I get it
21:00:22 <ACSpike[Home]> like you're type checking the type by asking it to create a value
21:01:27 <ACSpike[Home]> kmc, allbery_b: much thanks. I think I'll be able to complete 4.7 tomorrow now.
21:06:34 <ACSpike[Home]> good night!
21:29:51 <Gracenotes> hm.. just what is Eager Haskell?
21:30:04 <Gracenotes> simply Haskell sans laziness?
21:30:31 <Berengal> Gracenotes, no, it's haskell with speculative evaluation, I think. I may be wrong
21:30:56 <Gracenotes> as in, some of the eagerness happens at compile time? hm..
21:31:16 <Berengal> No, as in some of the thunks are speculatively evaluated
21:31:55 <Gracenotes> hm. so how does that differ from not having laziness.
21:32:06 <ivanm> Berengal: that sounds about right
21:32:16 <ivanm> Gracenotes: no laziness == everything evaluated right away
21:32:25 <ivanm> laziness == evaluate only when it really has to
21:32:25 <aavogt> well if you think about it, a given about of strictness gets assumed at compile time already
21:32:33 <ivanm> eager == evaluate a couple of things in advance just in case
21:33:01 <Berengal> Gracenotes, still reduces to normal form if at all possible, unlike strict evaluation
21:33:09 <ivanm> so eager can over-evalute items, but it may lead to improved performance by having less thunks floating around (whilst still having most of the lazy goodness)
21:33:19 <ivanm> that's how I understand it, anyway
21:33:21 <aavogt> by assumed I mean that the compiler recognizes that a value is going to have to be calculated
21:33:22 <Gracenotes> okay, I get how it differs from Haskell.. but this isn't clarifying the distinction between it and function behavior in mainstream imperative programming languages
21:33:46 <ivanm> Gracenotes: evaluate a few things in advance rather than evaluating the whole damn thing
21:34:15 <Berengal> It's not strict. Think of it like thunks spontaneously evaluating themselves, but nothing bad happens unless it was a "real" evaluation
21:34:17 <Gracenotes> :/ can you give an example?
21:34:21 <ivanm> so for [1..], "mainstream" langs try to get the whole infinite list; lazy will maybe know in advance that it starts with a 1; IIRC, eager will evaluate the first few
21:34:27 <ivanm> Gracenotes: so it kind of buffers values
21:34:59 <Gracenotes> ah. it won't just evaluate to the first constructor; it will work several constructors in. but how does it know where to stop?
21:35:13 <Berengal> Timeout, work done, etc.
21:36:21 <lispy|web> Are you talking about haskell?
21:36:43 <Gracenotes> that's interesting. so, the main advantage being, perhaps, the elimination of much overhead from lazy updates and of going back and forth between layered lazy calls. right?
21:37:15 * lispy|web suspects this a discussion about strictness optimizations
21:37:32 <Berengal> Overhead elimination is indeed the main purpose
21:37:36 <Berengal> lispy|web, eager haskell
21:38:14 <lispy|web> Great, I leave the channel for a few hours and suddenly Haskell has a new found work ethic.
21:39:12 <ivanm> lispy|web: heh
21:39:33 <ivanm> lispy|web: you want that @remember'd under lispy or lispy|web?
21:39:51 <lispy|web> oh, lispy please :)
21:39:57 <ivanm> @remember lispy Great, I leave the channel for a few hours and suddenly Haskell has a new found work ethic.
21:39:57 <lambdabot> It is stored.
21:40:33 <Gracenotes> <on a discussion about Eager Haskell>
21:41:27 <Gracenotes> must be some interesting optimizations. according to the MIT page, it uses resource-bound execution
21:42:13 <lispy|web> So, Eager Haskell goes beyond strictness analysis?
21:42:41 <lispy|web> My (vague) understanding of strictness analysis is that it is hard to due because of that whole undecidable thing
21:43:11 <Berengal> I think eager haskell just evaluates function arguments a bit before entering the function
21:44:58 <lispy|web> Berengal: and hides the result of bad things until they are demanded?
21:45:32 <lispy|web> It seems kind of arbitrary doesn't it?
21:45:57 <Berengal> It does, but so does strict evaluation too, in a way
21:46:36 <lispy|web> I should go to bed
21:46:38 <lispy|web> g'night
21:48:17 <Gracenotes> if lazy execution is carefully taking one step at a time through a minefield, then speculative eager execution is blindly taking one sprint at a time
21:48:29 <Gracenotes> *cough*badanalogy*cough*
21:49:13 <mxc> ?pl  (\a -> (a + 1, ()))
21:49:13 <lambdabot> flip (,) () . (1 +)
21:59:25 <dancor> can i get ghc to leave c symbols in my executable so a i can profile it at the c function level?
22:00:12 <kmc> can someone help me with a hint error?
22:00:13 <kmc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11721#a11721
22:00:20 <kmc> i don't know if i have to tell it to import Prelude or what
22:01:10 <kmc> ah it seems a 'setImports ["Prelude"]' will do it
22:08:06 <orbitz> ghc 6.12 sounds pretty sweeeeeet
22:14:23 <cjs> Woo! We have tuple sections in 6.12!
22:14:48 <cjs> dancor: ghc normally does that. Are you sure you're not doing a strip on the binary after it's built?
22:15:18 <vegai> cjs: what were those again?
22:15:36 <dancor> i'm getting very slow perf with the binary package and multithreaded IO.  i want to try forcing evaluation of reading the bytestrings before doing the binary decoding; what's the best way to do that?
22:15:36 <cjs> Tuple sections? (,True) = \x -> (x,True)
22:15:55 <vegai> ah
22:15:57 <cjs> dancor: Use strict bytestrings?
22:16:01 <dancor> cjs: hm i definitely not stripping.  maybe it does have symbols and something else is going wrong with my c-level debugging attempt..
22:16:10 <dancor> cjs: binary inherently uses lazy bytestrings
22:16:12 <cjs> What does nm <binary> say?
22:16:20 <dancor> you mean read strict then convert?
22:16:51 <cjs> dancor: Ah. Well, evaulating "length" applied to the bytestring will force the spine. Otherwise you need to do a length on every chunk.
22:17:22 <cjs> But if you're just trying to force an otherwise lazy read, getting the last char should do the trick.
22:17:39 <dancor> mm.  oh i might be able to use bang patterns too
22:17:53 <cjs> But again, if you're doing network I/O, for example, you really want to be reading strict bytestrings and converting them to lazy ones before passing them to whatever.
22:18:12 <cjs> I don't think a bang pattern will do it; a lazy bytestring is a linked list.
22:21:50 <cjs> Ah, we've got unicode syntax now, too. I need to figure out to generate left arrow and forall and all of those symbols, now.
22:22:12 <cjs> (I'm really keen on the little things, obviously. :-))
22:26:14 <dancor> You need to build the program twice: once the normal way, and then in the desired way using -osuf to set the object file suffix.
22:26:22 <dancor> i've already built without -prof
22:29:41 <dancor> i guess i just needed an "-osuf p_o".  why isn't that just the default behavior?
22:30:56 <cjs> What if you want to build just the profiled version all the time, or something? Though I guess -osuf o would do the trick there....
22:32:35 <dancor> next it's going to make you type "Yes, I am sure I want profiling." to continue
22:36:27 <SmurfOR> how do get the svgcairo package.  i have gtk2hs installed (i assumed it came with that) do i have to point cabal to it or something?
22:42:41 <aleator> Hi. Is there any way of making TH add object files to linkage when it is compiled with --make?
22:50:38 <mxc> dancor - if you're using cabal, you can add --enable-library-profiling and  --enable-executable-profiling  to the arguments to runghc Setup.hs configure
22:51:40 <dancor> mm
22:52:10 <travisbrady> is there a standard way to pass a bunch of optional flags to a function? I'm thinking: data Option = ..., then [Option], but I'm stuck as some flags exclude others
22:52:41 <mxc> dancor - much easier tyhat way
22:59:08 <MoALTz> doesn't loading a source file in ghc wipe the defines and values already there? if so, why doesn't the gc clear out the old stuff properly (which it doesn't seem to do, as even after reloading my src the interpretor is still slow)
23:05:39 <CakeProphet> what's the best haskell tutorial out there?
23:05:45 <ivanm> MoALTz: ummm... what?
23:05:49 <ivanm> CakeProphet: book or online?
23:05:55 <CakeProphet> online.
23:06:06 <ivanm> @where LYAH
23:06:06 <lambdabot> www.learnyouahaskell.com
23:06:08 <ivanm> @where wikibook
23:06:08 <lambdabot> http://en.wikibooks.org/wiki/Haskell
23:06:12 <ivanm> @where YAHT
23:06:12 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
23:06:29 <ivanm> CakeProphet: most people nowadays recommend LYAH; I find it overly silly and grammatically incorrect
23:07:49 <shambler> rwh is also good imo
23:08:10 <shambler> YAHT requires some haskell-or-fp background afair
23:08:51 <shambler> @where rwh
23:08:51 <lambdabot> is http://www.realworldhaskell.org/blog/
23:09:00 <ivanm> shambler: I doubt it, but YAHT isn't the easiest tutorial IIRC
23:09:07 <ivanm> and RWH is probably too advanced
23:09:14 <ivanm> it's more of an "advanced topics tutorial"
23:09:20 <ivanm> there's also haskell for C programmers, etc.
23:09:23 <ivanm> @where tutorial
23:09:23 <lambdabot> http://www.haskell.org/tutorial/
23:09:25 <ivanm> :o
23:09:32 <ivanm> it worked! \o/
23:09:42 <kmc> the "gentle" introduction to haskell
23:09:44 <ivanm> bah, it's the (not-so-) gentle intro
23:09:47 <ivanm> @where tutorials
23:09:48 <lambdabot> I know nothing about tutorials.
23:10:07 <ivanm> @where+ tutorials http://haskell.org/haskellwiki/Books_and_tutorials
23:10:08 <lambdabot> Nice!
23:10:11 <kmc> @where love
23:10:12 <lambdabot> http://en.wikipedia.org/wiki/Where_Is_Love%3F
23:10:19 <ivanm> nope, wrong one
23:10:22 <kmc> ha
23:10:23 <shambler> :)
23:10:26 <ivanm> @where+ tutorials http://haskell.org/haskellwiki/Tutorials
23:10:27 <lambdabot> Nice!
23:10:31 <ivanm> @where tutorials
23:10:31 <lambdabot> http://haskell.org/haskellwiki/Tutorials
23:10:33 <ivanm> good-o
23:10:53 <ivanm> kmc: do I dare ask why lambdabot knows that link?
23:11:10 <MoALTz> if you generate a large list in ghc it will work for awhile, return it, then continue to eat 20% of my cpu time due to the gc being run ever second or so. when i load a source file it seems that all previous definitions are lost,
23:11:11 <MoALTz> 036+/
23:11:19 <MoALTz> arg cat sorry
23:11:28 <MoALTz> wasn't finished writing that
23:13:32 <CakeProphet> ...okay, so. Tonight I'm going to see if I can figure out arrows.
23:13:38 <MoALTz> continuing: prelude and your sourcefile definitions are loaded. surely the gc could stop running with 20% of the cpu as it could clear the large lists that were generated before, but alas it does not seem to. the only way i can get ghc to stop eating cpu like this is to close and rerun ghc
23:13:40 <CakeProphet> can someone attempt to explain them?
23:13:46 <kmc> @where brooklyn
23:13:46 <lambdabot> I know nothing about brooklyn.
23:13:49 <CakeProphet> is there a reference/tutorial for them.
23:15:12 <Adamant> @where sleep on route to Brooklyn
23:15:12 <lambdabot> I know nothing about sleep.
23:15:38 <kmc> @where haskell
23:15:38 <lambdabot> http://haskell.org
23:16:17 <Adamant> @where waldo
23:16:18 <lambdabot> I know nothing about waldo.
23:22:22 <ivanm> criterion doesn't like chart-0.12 :(
23:25:06 <cjs> @where lambdabot
23:25:06 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
23:32:09 <mr_ank> Hi! I was looking for any examples of commercial applications (hopefully with a GUI) built with haskell? thanks!
23:34:04 <mr_ank> http://www.haskell.org/haskellwiki/Haskell_in_industry << seems to be focused on web stuff
23:39:08 <mmorrow> travisbrady: i *hate* that situation. it seems to constantly come up, but there's no way that i've been able to think of that's not ugly or lacking in terms of any language constructs
23:39:17 * mmorrow was scrolled up an hour
23:39:47 <mmorrow> <travisbrady> is there a standard way to pass a bunch of optional flags to a function? I'm thinking: data Option = ..., then [Option], but I'm stuck as some flags exclude others
23:40:29 <mmorrow> mutual exclusions and/or certain contructors/subsets-of restrict the legal possible subset of the constructors in some way
23:41:47 <mmorrow> i feel like there could/should be some way to use a programming language to express/organize/enforce that
23:45:34 <mmorrow> (some way other than writing a program that verifies that for you (but someone would have to write it..))
23:46:05 * hackagebot upload: bert 1.0 - BERT implementation (MariusEriksen)
23:46:57 <mmorrow> i mean, if you could come up with a nice syntax for encoding whatever things you need to encode about it, you'd be halfway there to having it
23:47:52 <GNU\colossus> true; but I don't see a way to do this in an elegant manner :)
23:48:36 <mmorrow> i wonder how possible it is to determine when your code does something that would violate some rules like that
23:49:52 <mmorrow> like,  data A = A | B | C; data Two = (A,A) such that (C|B,x) ==> x `in` {(_,A|C),(A,B)}
23:50:18 <mmorrow> clearly  foo _ = (C,B) is illegal
23:50:35 <mmorrow> so the trivial case is easy enough
23:51:27 <mmorrow> and also there'd be situation where you don't know the values statically
23:52:13 <mmorrow> but when you *do* know enough info statically to be able to tell if this too-complicated-to-do-in-your-head piece of code violates any of the exclusions
23:56:00 <mmorrow> (actually foo _ = (C,B) isn't illegal there..)
23:56:24 <mmorrow> which only speaks to the point!
23:56:59 <mmorrow> err, that's not even the right type..
23:57:15 <mmorrow> :)
23:57:50 <mmorrow> oh no, it is, but the definition i gave doesn't make sense
23:58:14 <mmorrow> data A = A | B | C; data s/Two/Three/ = (A,(A,A)) such that (C|B,x) ==> x `in` {(_,A|C),(A,B)}
