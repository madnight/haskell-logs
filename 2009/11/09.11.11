00:01:04 <Jeb> how would I use a constructor with foldr1?
00:01:13 <copumpkin> hm?
00:01:22 <copumpkin> what's the type of the constructor?
00:01:44 <Jeb> not sure what you mean
00:01:48 <Jeb> I'm trying to do something like this
00:02:01 <Jeb> foldr (TheNode) list
00:02:08 <Gracenotes> depends on whether you want to make a constructor or take apart a constructor
00:02:11 <Jeb> it takes two parameters
00:02:23 <Gracenotes> for the purpose of foldr, or any higher-order function, constructors can be treated as just functions
00:02:29 <jmcarthur> what are the parameters?
00:03:02 <Gracenotes> (:) :: a -> [a] -> [a], where data [a] = [] | a:[a]. for instance. and you can do foldr (:) [1,2,3] [4,5,6]
00:03:15 <Jeb> sorry,    foldr1 I'm using
00:03:22 <jmcarthur> :t foldr1
00:03:23 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
00:03:45 <Gracenotes> or (,) is a constructor to form an (a, b). You can do:
00:03:47 <Gracenotes> > liftM2 (,) [1,2] [3,4]
00:03:48 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
00:03:50 <jmcarthur> Jeb: what do you intend the result to be?
00:04:44 <jmcarthur> note that unless the constructor has a type like Foo âˆ· Foo â†’ Foo â†’ Foo, it's probably an incompatible type with foldr1
00:05:04 <Jeb> ya, its recursive
00:05:25 <jmcarthur> and the list you apply the fold to will have to have type [Foo]
00:05:27 <copumpkin> oh my, look at that unicodey goodness
00:05:37 <jmcarthur> copumpkin: auto replace :)
00:05:43 <copumpkin> fancy!
00:05:47 <Jeb> Suppose I'm implimenting boolean expressions    data Expression = And Expression Expression
00:06:17 <Jeb> so I want to use foldr1 to combine a list of expressions into one expression
00:06:20 <jmcarthur> should work fine as you write it then
00:06:24 <jmcarthur> *wrote it
00:06:28 <Jeb> foldr1 (And) list
00:06:32 <jmcarthur> yup
00:06:40 <jmcarthur> the parens are technically not necessary, btw
00:06:41 <copumpkin> don't need no parentheses
00:06:44 <Jeb> alright, thanks...something else is fishy then
00:06:46 <Gracenotes> foldr1 And [a, b, c, d] -> And a (And b (And c d))
00:06:59 <Jeb> ya, that's the intended result
00:07:05 <copumpkin> you can name it :& btw
00:07:05 <jmcarthur> > foldr1 f [a, b, c, d, e]
00:07:07 <lambdabot>   Ambiguous occurrence `f'
00:07:07 <Gracenotes> for these sorts of things, though, foldl1 has a different result..
00:07:07 <lambdabot>  It could refer to either `L.f', defined at <local...
00:07:14 <copumpkin> @undef
00:07:22 <copumpkin> > foldr1 f [a, b, c, d, e]
00:07:23 <jmcarthur> grr
00:07:23 <lambdabot>   f a (f b (f c (f d e)))
00:07:28 <jmcarthur> yay
00:07:34 <copumpkin> never fear, copumpkin is here
00:07:47 <Jeb> I'm getting    couldn't match expected type 'Expression', against inferred type [a]
00:07:50 <chrisdone> to fix his mistakes
00:08:01 <Gracenotes> to find the kin of things which are co-pumped
00:08:23 <jmcarthur> Jeb: unfortunately error messages aren't very useful without seeing the code it points to
00:08:37 <chrisdone> Jeb: are you giving foldr1 [Expression] or Expression perhaps?
00:08:38 <Jeb> alright
00:08:53 <Jeb> it should be a list
00:08:56 <jmcarthur> > foldr f [Î±, Î², Î³]
00:08:58 <lambdabot>   Not in scope: `Î±'Not in scope: `Î²'Not in scope: `Î³'
00:09:01 <jmcarthur> aw
00:09:12 <Gracenotes> the result of foldr1 should be an Expression
00:09:23 <Gracenotes> the input (after the function) should be a list of Expressions
00:09:45 <Jeb> ya, it's supposed to be (based on what my code does, it should be)
00:09:53 <copumpkin> @let Î± = var "Î±"
00:09:54 <Jeb> is there an easy way to debug haskell?
00:09:54 <lambdabot>  Defined.
00:09:58 <Jeb> I'm pretty new at all of this
00:10:02 <jmcarthur> :t var
00:10:04 <lambdabot> forall a. String -> Sym a
00:10:04 <copumpkin> @let Î² = var "Î²"
00:10:05 <lambdabot>  Defined.
00:10:06 <jmcarthur> ooh
00:10:13 <copumpkin> @let Î³ = var "Î³"
00:10:14 <lambdabot>  Defined.
00:10:15 <jmcarthur> > foldr1 f [Î±, Î², Î³]
00:10:17 <lambdabot>   No instance for (SimpleReflect.FromExpr
00:10:17 <lambdabot>                     (Data.Number.Sy...
00:10:19 <chrisdone> Jeb: just test the types of the values that you're working with
00:10:20 <copumpkin> bah!
00:10:25 <jmcarthur> :(
00:10:28 <copumpkin> must be a different var :(
00:10:39 <reltuk> `par` is handled b ya fixed pool of worker threads, right?
00:10:49 <jmcarthur> what input method do you use for unicode, copumpkin?
00:11:14 <copumpkin> I just copied and pasted your letters :) I do have a japanese IME within easy reach though
00:11:18 <copumpkin> otherwise, I don't type much unicode
00:11:19 <jmcarthur> ah
00:11:33 <jmcarthur> i thought i remembered you typing a lot of unicode here before
00:11:47 <copumpkin> oh, hmm
00:11:55 <copumpkin> maybe, but if so that was probably using a palette
00:12:31 <jmcarthur> oh well. i've been filling out xchat's replace.conf with some tex-/agda-style autoreplacements
00:12:33 <Gracenotes> > var "why" + var "not" :: Expr
00:12:34 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
00:12:35 <lambdabot>         against inferred ...
00:13:10 <Gracenotes> odd. works for me.
00:13:15 <chrisdone> :t msum
00:13:16 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
00:13:18 <Gracenotes> @type var
00:13:19 <lambdabot> forall a. String -> Sym a
00:13:27 <Gracenotes> oh. *shakes fist*
00:13:30 <chrisdone> :t mappend
00:13:31 <lambdabot> forall a. (Monoid a) => a -> a -> a
00:13:33 <copumpkin> yeah, not sure where that var comes from
00:13:37 <copumpkin> but it isn't the right one
00:13:46 <Gracenotes> Data.Number.Symbolic
00:13:52 <copumpkin> :t reduction
00:13:52 <lambdabot> Not in scope: `reduction'
00:13:57 <copumpkin> ah
00:14:29 * jmcarthur should never have coffee in the evening
00:14:36 <copumpkin> tsk tsk
00:14:59 <jmcarthur> it's 2:15 am, the wife has been in bed for a few hours, and i'm still not sleepy
00:17:40 <Gracenotes> > subst "a" (con 4) (var "a" + var "b" + con 2)
00:17:41 <lambdabot>   6+b
00:18:12 <Jeb> is anyone familiar with parsec's   sepBy1 function
00:19:24 <Gracenotes> I used it somewhat recently
00:20:07 <Jeb> nvm, I figured it out
00:20:26 <Jeb> stupid typo took me almost an hour to figure out...always fun
00:21:00 <Gracenotes> in my case, it was something like: liftA2 (,) (many1 letter) (spaces >> optionMaybe (char '=' >> spaces >> expression)) `sepBy1` (char ',' >> spaces)
00:21:55 <Gracenotes> for declarations. type var1 = expr1, var2, var3 = expr3; ... I probably should do some kind of tokenization beforehand, really...
00:23:21 <copumpkin> subst!
00:23:30 <copumpkin> reminds me of agda :)
00:25:09 <Gracenotes> reminds me of MediaWiki
00:25:25 <Jeb> how do i change scope in ghc?
00:25:35 <dmwit> eh?
00:26:07 <Jeb> how do I switch to a different module?
00:26:11 <dmwit> :m
00:26:13 <Jeb> or is there no way to do that
00:26:16 <dmwit> in ghci
00:26:20 <Jeb> thanks
00:26:41 <dmwit> (You can tell the ghci authors had good taste in editors. ;-)
00:26:57 <Gracenotes> to load your own module, :l MyFile.hs
00:27:18 <ray> :m + Data.Seinfeld
00:27:43 <dmwit> Data.Seinfeld: module not found (use --funny to see the list of files searched)
00:28:02 <Jeb> thanks
00:29:01 <mmorrow> copumpkin, Gracenotes: yay! i've finally got optimization working and (for now) done, now i can finally move on. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4902
00:29:22 <int-e> dmwit: By picking a command syntax that had no chance of ever colliding with emacs? I agree ;-)
00:29:28 <copumpkin> oh is this your secret super bytecode?
00:29:48 <Gracenotes> your own backend, so to speak?
00:30:04 <mmorrow> copumpkin: oh yesh
00:30:16 <mmorrow> i think i'm gonna generate C code too for now
00:30:32 <mmorrow> it should be easy enough to hook the GC/etc into that
00:30:39 <mmorrow> "easy enough" ;)
00:30:45 <Gracenotes> some simple compile-time evaluation. sweet.
00:30:54 <dmwit> hmm
00:30:56 <copumpkin> thoughtpolice had a package called generate-c
00:31:00 * mmorrow has started getting hesitant to say "oh, that'll be easy..."
00:31:05 <mmorrow> ... 4 weeks later...
00:31:10 <dmwit> fourtytwo() = CONT(_(Cons{I#{84},Nil{}})|)
00:31:13 <dmwit> I think you have a bug.
00:31:18 <copumpkin> the U?
00:31:21 <copumpkin> http://github.com/thoughtpolice/generate-c
00:31:27 <mmorrow> heh, should've named it eightyfour
00:31:40 <mmorrow> U?
00:31:45 <copumpkin> fortytwo
00:31:50 <copumpkin> :)
00:31:53 <mmorrow> copumpkin: ah nice
00:31:56 <mmorrow> (@generate-c)
00:32:00 <mmorrow> copumpkin: lol
00:32:13 <mmorrow> spelling is overatted
00:32:14 <copumpkin> gotta love irregular languages
00:32:15 <copumpkin> yeah
00:32:46 <dmwit> hmm, isn't there a Language.C already with some fancy stuff in?
00:32:55 <copumpkin> it's a pain to generate c with it
00:32:57 <copumpkin> last time I tried
00:33:05 <dmwit> ah
00:33:12 <copumpkin> although it does supposedly support it
00:33:16 <mmorrow> yeah, it's more oriented at parsing
00:33:21 <Gracenotes> mmorrow: this is whole-program compilation essentially?
00:33:35 <copumpkin> it's just a pretty-printer for the AST, which contains all sorts of nasty file position stuff that you don't want to deal with if you're generating code
00:33:39 <mmorrow> Gracenotes: not necessarily, it'll use what it has available to it
00:33:41 <Gracenotes> I don't see many remnants of your prelude :)
00:33:59 <mmorrow> so depending on what you make available, it'll use that for inlining
00:34:03 <copumpkin> this can become mhc
00:34:14 <int-e> language-c should support round-tripping (losing comments, I guess), but it's more about parsing and analysing C code than generating C code.
00:34:51 <mmorrow> copumpkin: typechecking/inference is painful
00:34:53 <int-e> (and it's still somewhat geared towards c2hs I guess)
00:34:56 <Gracenotes> this is quite cool
00:35:16 <copumpkin> mmorrow: oh yeah, I don't think new haskell compilers should have to deal with that stuff anyway
00:35:46 <mmorrow> copumpkin: well, if they ever want to be self-hosting..
00:36:09 <mmorrow> which imo is the baseline for leetness ;)
00:36:25 <copumpkin> lol
00:38:13 <mmorrow> <Gracenotes> I don't see many remnants of your prelude :)
00:38:19 <mmorrow> Gracenotes: oh, i just realized what you meant
00:38:32 <mmorrow> yeah, i just omitted those defs in the optimized output
00:38:36 <mmorrow> but they're there..
00:39:26 * mmorrow starts breaking up/organizing the 2500 line beast module in front of him
00:40:40 <mmorrow> well, at least a lot of that if from copy/pasting similar stuff, and some parts aren't used anymore
00:41:19 <mmorrow> *2875
00:42:14 <Gracenotes> I've been thinking.. I need to learn more about functional reactive programming, particularly with gaming. But the Yampa arcade paper has proven somewhat impenetrable for me :/
00:43:11 <Gracenotes> the operational meaning of the code is utterly lost on me. just that it uses certain combinators that do... uh... who knows what
00:44:53 <Gracenotes> well, I guess I should try staring at the source code until it makes sense :)
00:47:20 <null_ptr> he. Is there any way of defining a namespace for my code?
00:48:29 <cathper> I was quite surprised about this:
00:48:33 <cathper> > min 3 2^2
00:48:34 <lambdabot>   4
00:48:49 <tensorpudding> @src min
00:48:50 <lambdabot> min x y = if x <= y then x else y
00:49:08 <cathper> Until I realized that it's equivalent to
00:49:14 <cathper> > (min 3 2)^2
00:49:15 <lambdabot>   4
00:49:23 <cathper> Rather than
00:49:28 <cathper> > min 3 (2^2)
00:49:30 <lambdabot>   3
00:50:13 <cathper> It's kinda weird that min "binds" stronger than ^.
00:50:14 <tensorpudding> that's odd, though if you think about it, not so much
00:50:45 <copumpkin> functions always bind super strong
00:50:58 <tensorpudding> > min 3 2+2
00:51:00 <lambdabot>   4
00:51:00 <cathper> I know. But it's rather counterintuitive to the Haskell n00b like me, I'd say.
00:51:11 <cathper> Exactly.
00:51:16 <donri> > min 3 $ 2^2
00:51:17 <lambdabot>   3
00:51:27 * donri hearts "$"
00:51:45 <cathper> :-)
00:52:03 <tensorpudding> > min 3 + 2
00:52:05 <lambdabot>   No instance for (GHC.Num.Num (t -> t))
00:52:05 <lambdabot>    arising from the literal `2' at <...
00:52:46 <tensorpudding> > min 3 + 2 $ 6
00:52:47 <lambdabot>   No instance for (GHC.Num.Num (t -> t))
00:52:47 <lambdabot>    arising from the literal `2' at <...
00:53:08 <tensorpudding> > min $ 3 + 2 $ 6
00:53:09 <Gracenotes> whitespace is basically the function application operator :P so we do sacrifice some more intuitive meanings of it.. no ambiguity though
00:53:10 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
00:53:10 <lambdabot>    arising from the literal `3' at <...
00:53:48 <Gracenotes> intuitive in quotes.. eh, I should really go to sleep soon..
00:53:52 <tensorpudding> yeah, my haskell code has probably more $'s than it needs
00:54:03 <tensorpudding> because i'm careful to never run into situations like that
00:54:43 <cathper> I'd rather use parenthesis for readability.
00:55:12 <Gracenotes> that is what many LISPers say :)
00:56:08 <Gracenotes> all parenthesization styles are acquired tastes. But, perhaps, LISP moreso than others..
00:56:10 <cathper> I'm a mathematician so that's my usual style of writing/reading.
00:56:34 <tensorpudding> I prefer $'s for brevity and readability
00:58:39 <tensorpudding> and lisp's parens don't make things more readable...without an editor that matched parens you'd surely go mad
00:58:44 <andrejbauer> Can someone tell me if I am doing something wrong with pragmas here, or is the sort of monad instance I want inherently impossible: http://haskell.pastebin.com/d6246040b
00:59:23 <_plcs_> tensorpudding: depends, i have this built in habit to count up with open and down with closed, as i read so i notice most of the time
01:00:58 <tensorpudding> hmm, should i go back to reading EoPL or should I start reading this type theory book
01:03:18 <tensorpudding> peirce's types and programming languages, i hear it's intense
01:03:37 <MacCoaster> how do i convert from ["1", "2"] to [1,2] ? somehow using read?
01:04:04 <ivanm> MacCoaster: map read
01:04:22 <ivanm> which might throw an error if they're not all the same type of number
01:04:42 <MacCoaster> i tried that simple thing but its saying ambiguous type variable a in the constraint Read a .. :\
01:04:57 <MacCoaster> oh!
01:04:58 <ziman> you might need to type the expression implicitly if its type cannot be inferred from the contexxt
01:04:59 <MacCoaster> : [Int]
01:05:00 <ivanm> MacCoaster: right, you might need to specify a type
01:05:00 <MacCoaster> ::
01:05:03 <ivanm> MacCoaster: yup
01:05:08 <ziman> *explicitly
01:05:15 * MacCoaster smacks himself. so simple. silly him.
01:05:49 <andrejbauer> So, any ideas about getting a monad instance for a type that is not inductive (data)?
01:07:36 <ivanm> andrejbauer: ummm, monads can contain any type
01:08:35 <andrejbauer> look at my example please, what am I doing wrong?
01:08:44 <andrejbauer> http://haskell.pastebin.com/d6246040b
01:09:01 <null_ptr> No namespaces? I do always get "Ambiguous occurrence". Is the only way to prevent this, using Main. as function prefix?
01:14:15 <ivanm> andrejbauer: what are you referring to as "inductive"?
01:14:46 <ivanm> andrejbauer: you can't create monad instances for type definitions
01:15:02 <ivanm> you need either data or type
01:15:15 <andrejbauer> I suppose that's what I am asking
01:15:19 <ivanm> right
01:15:21 <ivanm> you can't
01:15:27 <andrejbauer> so I can't have a monad instance for something like Int -> a ?
01:15:29 <ivanm> because it overlaps ((->) a) I think...
01:15:43 <andrejbauer> ok
01:15:44 <ivanm> andrejbauer: obviously not ;-)
01:15:47 <ivanm> @instances Monad
01:15:48 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
01:15:54 <ray> well, that's the wrong kind
01:15:59 <donri> crazy curiosity: could do-notation be used for function composition?
01:16:05 <ray> but you couldn't have one for ((->) Int) either
01:16:08 <ray> that overlaps
01:16:14 <andrejbauer> that's hardly obvious :-)
01:16:16 <ivanm> ray: right, that was my point
01:16:30 <ray> wrong kinds are obvious
01:16:40 <andrejbauer> e.g., the natural type for continations is (a -> b) -> b, but the continuation monad wraps that up in a record
01:16:45 <andrejbauer> must go
01:16:53 <andrejbauer> bye
01:16:57 <andrejbauer> thanks for the answer
01:17:08 <ivanm> preflex: seen quicksilver
01:17:09 <preflex>  quicksilver was last seen on #haskell 21 hours, 3 minutes and 58 seconds ago, saying: ]yup
01:17:10 <ray> that record syntax stuff is basically to get a free runCont
01:17:15 <ray> or whatever it happens to be with that
01:17:24 <ray> it'd work without it
01:17:29 <ivanm> yeah
01:19:24 <Jeb> is there an easy way to print in haskell?
01:19:43 <ivanm> record syntax gets you a free accessor function, and a semi-free setter (semi-free in that you have to wrap it in foo { ... }, which isn't always that helpful)
01:19:47 <Jeb> (for debugging purposes)
01:19:48 <ivanm> Jeb: as in to a printer?
01:19:51 <ivanm> Jeb: trace
01:19:54 <Jeb> just to screen
01:19:55 <ivanm> Debug.Trace.trace IIRC
01:20:04 <ivanm> that's for tracing inside pure functions
01:20:14 <ivanm> otherwise, if it's in IO you have putStrLn, etc.
01:20:27 <Jeb> thanks
01:20:33 <ivanm> no worries
01:29:11 <ivanm> did anyone know that inkscape seems to use haskell? http://www.google.com/codesearch?q=lang%3Ahaskell&hl=en&btnG=Search+Code
01:29:15 <ivanm> second result
01:31:00 <shambler> wow
01:31:00 <shambler> cool
01:31:58 <donri> any example use of the ((->) r) Monad instance?
01:32:05 <ivanm> experimental trunk
01:32:40 <ivanm> > (do x <- (+1); y <- (*2); return (x+y)) 3
01:32:42 <lambdabot>   10
01:32:45 <ivanm> donri: ^^
01:32:48 <donri> thanks
01:32:49 <opqdonut> > (join (*) >>= (+)) $ 2
01:32:50 <lambdabot>   6
01:32:52 <Baughn> ivanm: Hey!
01:32:57 <ivanm> hey Baughn
01:33:05 <ivanm> Baughn: I found a bug in haskell-mode!
01:33:11 * Baughn slinks away
01:33:11 <ivanm> with both indentors!
01:33:15 <opqdonut> > sequence [(+1),(*2)] 3
01:33:16 <lambdabot>   Not in scope: `ï¿½'
01:33:23 <ivanm> Baughn: heh
01:33:23 <Baughn> ivanm: Okay, what did they do?
01:33:24 <opqdonut> > sequence [(+1),(*2)] 3
01:33:25 <lambdabot>   [4,6]
01:33:29 <opqdonut> woops, had weird whitespace there
01:33:42 <donri> > (do return (+1)) 3
01:33:43 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
01:33:46 <ivanm> Baughn: if you have a list spread over multiple lines [ a\n, b\n ... \n], etc.
01:33:48 <donri> huh
01:34:04 <ivanm> then you try and have an operator on the next line, the indentors want to move it to the first column rather than indented
01:34:17 <opqdonut> donri: return takes a pure value and not a monadic one
01:34:29 <ivanm> Baughn: e.g. the way keybindings are defined in the default xmonad config, there's an explicit list and then some list comprehensions with ++ used to join them
01:34:53 <ivanm> donri: you returned the function (+1)
01:35:04 <ivanm> @type (do return (+1)) 3
01:35:06 <lambdabot> forall a. (Num a) => a -> a
01:35:15 <Baughn> ivanm: And pressing tab doesn't get you to the right column?
01:35:15 <ivanm> @type (do return (+1))
01:35:17 <lambdabot> forall a (m :: * -> *). (Num a, Monad m) => m (a -> a)
01:35:19 <ivanm> Baughn: nope
01:35:29 <ivanm> Baughn: it keeps wanting it at the start of the line
01:35:35 <Baughn> ivanm: Can't quite replicate it, can you hpaste an example?
01:35:44 <ivanm> Baughn: I take it back
01:35:53 <Baughn> Aww
01:35:57 <ivanm> Baughn: it will let you put it in the correct spot (at least the new one will)
01:36:26 <ivanm> must have been indent that wouldn't do it
01:36:33 <Baughn> ivanm: Ideally, something like "[1,2,3] ++\n" would /only/ allow the right spot, but that requires more type information than I currently have
01:36:42 <ivanm> Baughn: yeah, it seems that was what I was seeing
01:36:45 <ivanm> just didn't realise it
01:37:47 <Baughn> Right. In that particular case, with the operator on the second line, there's really nothing whatsoever I can do other than start at column 1
01:37:51 <Baughn> Although..
01:38:21 <Baughn> ivanm: Would be neat if I could have it reindent once you start entering code, and it notices that the code ('++') definitely doesn't belong on column 1
01:38:41 <ivanm> yeah
01:39:28 <Baughn> That would require.. hooking self-insert-command. Wonder if that's possible.
01:39:58 <ivanm> Baughn: so 2.7 will be coming out in the next few days? :p
01:40:20 <Baughn> ivanm: No, this is a long-term project.
01:40:31 <Baughn> ivanm: I need to connect it to Scion to get the type information first, too
01:40:34 <ivanm> heh
01:40:42 <ivanm> Baughn: oh, so integrate scion into haskell-mode?
01:40:43 <ivanm> nice!
01:41:29 <tlidomir> hi I did "cabal fetch yi", now have to configure. but where is the directory? (plattform at windows)
01:42:13 <ivanm> tlidomir: don't know where the cabal directory is for windows, but wherever the cabal user directory is, there's a packages subdir
01:42:23 <ivanm> eventually you'll find the yi tarball in there
01:42:35 <ivanm> tlidomir: easier way: "cabal install yi" rather than configuring it if you can
01:42:58 <ivanm> tlidomir: maybe "cabal unpack yi" would work...
01:43:39 <tlidomir> ah unpack sounds good - found a zip ;)
01:45:52 <muri_one> is there some ready made ubuntu package that will give me cabal-install?
01:46:21 <Taejo> muri_one: unfortunately not in the standard repositories yet
01:47:11 <ivanm> muri_one: you could always use the bootstrap script to install it per-user...
01:47:12 <Taejo> but there is a PPA that provides the haskell-platform package, which includes cabal-install
01:48:30 <Taejo> muri_one: http://sitr.us/2009/07/02/how-to-install-haskell-platform-on-ubuntu-jaunty.html
01:48:38 <Taejo> should work on Karmic too
01:49:11 <Taejo> I was mistaken: the PPA contains GHC 6.10, with which you can build the platform from source
01:49:53 <tlidomir> ivanm I did unpack. but don't find anything unpacked. hm.
01:50:40 <ivanm> tlidomir: cabal unpack --destdir
01:50:49 <ivanm> it's meant to unpack it to the current directory
01:50:54 <ivanm> sure there's nothing there?
01:51:44 <tlidomir> ivanm oh. yes. thanks.
01:52:04 <mlesniak> Anyone know how far the development of GHC6.12 (final) is? I downloaded the RC but have troubles because the idea (as I understand) is, that all additional packages are provided by haskell-batteries; which is of course not ready for 6.12 (right?).
01:54:29 <ivanm> mlesniak: there won't be a platform release containing/supporting 6.12 until next year
01:54:41 <ivanm> probably around March/April if they keep to a 4 month release schedule
01:57:47 <mlesniak> ivanm: Ok, what about cabal-support?
01:58:03 <mlesniak> (I remember reading about problems with cabal, don't know where)
01:58:18 <ivanm> mlesniak: cabal-install you mean?
01:58:26 <mlesniak> ivanm: Yes
01:58:30 <ivanm> darcs repo has support, there won't be a release until 6.12 itself is released
01:58:41 <ivanm> since it requires cabal 1.8, which won't be released until 6.12 is released
01:58:44 <tlidomir> yi (for win) requires gtk and glib. both not at hackage.
01:58:44 <ivanm> (AFAIK, anyway)
01:59:41 <mlesniak> ivanm: argh :), so as far as I understand the RC is quite "unusable" without a lot of effort since packages of hackage have do be installed manually (if at all)?
02:00:56 <ivanm> tlidomir: they're both gtk2hs
02:01:06 <ivanm> tlidomir: which isn't on hackage because it isn't/can't be cabalised yet
02:01:17 <ivanm> mlesniak: right, the RC is there for testing purposes only
02:01:40 <ivanm> for devs of packages, for distro maintainers and most importantly, for the GHC devs to try and get bugs found ;-)
02:02:12 <ivanm> and there's obviously plenty with the new build system, etc.: at ICFP, they were talking about releasing 6.12 soon; that was early september :s
02:02:18 <tlidomir> ivanm: thanks for the help.
02:02:37 <mlesniak> Does "if it compiles it has no bugs" not apply to GHC? :-)
02:03:00 <mlesniak> ivanm: yes, that's why I'm wondering
02:03:03 <SAiNT_JiMMiE> hey
02:03:12 <ivanm> mlesniak: heh
02:03:14 <SAiNT_JiMMiE> i am studing haskell
02:03:22 <ivanm> mlesniak: the problem is, it doesn't reliably compile ;-)
02:03:24 <ivanm> tlidomir: no worries
02:03:30 <ivanm> SAiNT_JiMMiE: \o/
02:03:35 <SAiNT_JiMMiE> in computer languages and compilators
02:03:43 <SAiNT_JiMMiE> this is the course
02:04:11 <SAiNT_JiMMiE> want to ask somebody who can help me... my project is to create a parser
02:04:14 <SAiNT_JiMMiE> a compilator
02:04:30 <SAiNT_JiMMiE> someone knows some resources that can help me??
02:04:37 <FunctorSalad_> ivanm: though I think more people would be inclined to test it if cabal worked ;)
02:04:43 <FunctorSalad_> (but you say it does now?)
02:04:54 <ivanm> SAiNT_JiMMiE: there's a tutorial on building scheme in haskell that might help...
02:05:04 <ivanm> FunctorSalad_: IIRC, darcs cabal-install works
02:18:11 <mmorrow> SAiNT_JiMMiE: (compilERS) :)
02:20:30 <shambler> SAiNT_JiMMiE, http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
02:20:45 <shambler> @where WYS48H
02:20:46 <lambdabot> I know nothing about wys48h.
02:20:49 <shambler> :(
02:20:51 <ivanm> shambler: yeah, I gave him a link to one (not sure if the content was the same, but the name was)
02:21:11 <ivanm> shambler: missing the 'A' there ;-)
02:21:41 <shambler> :)
02:43:54 <FunctorSalad_> meh I'm tired of writing a zillion "Var[ETP]" and "Con[ETP]" when building ASTs
02:44:10 <FunctorSalad_> should be polymorphic somehow
02:46:03 <FunctorSalad_> defining "vars = fmap var" is a start I guess
03:04:38 <bastl> FunctorSalad_: I played arounf with multirec-alt-deriver. worked quite well ... http://moonpatio.com/fastcgi/hpaste.fcgi/raw?id=4904 http://moonpatio.com/fastcgi/hpaste.fcgi/raw?id=4903
03:04:44 <bastl> Though it consumes a lot of memory for larger families . :-/
03:07:14 <quicksilver> ivanm: hi, sorry, had a mad day yesterday
03:07:20 <quicksilver> ivanm: I assume it's too late now anyway?
03:09:04 <ivanm> quicksilver: actually, not
03:09:08 <ivanm> I got the day wrong
03:09:13 <ivanm> bit less than 3 hours to go
03:09:17 * hackagebot upload: Measure 0.0.1 - A library for units of measurement (TonyMorris)
03:10:18 * hackagebot upload: Measure 0.0.2 - A library for units of measurement (TonyMorris)
03:10:40 <flx_> :)
03:11:14 <quicksilver> ivanm: anyhow, it looked better to me
03:11:51 <cathper> I have a list (which resembles a 4-dimensional matrix). Can I somehow split the list into list of lists, where the inner list have a given length?
03:12:33 <FunctorSalad_> bastl: nice. you mean ghc, when compiling?
03:12:44 <Botje> while (my @row = splice @list, 0, 4) { push @matrix, \@row }
03:12:45 <bastl> yes
03:14:16 <cathper> Botje: I'm lost.
03:14:21 <FunctorSalad_> bastl: yes, noticed that too. I don't know what's up with that, but isn't ghc generally like that with huge sets of types?
03:14:29 <quicksilver> Botje was telling you how to do it in perl.
03:14:32 <quicksilver> not entirely helpful :)
03:14:57 <FunctorSalad_> bastl: you could compile it into a seperate package so you don't have to rebuild it all the time during development
03:15:09 <quicksilver> > let chunksOf n = takeWhile (not.null) . map (take n) . iterate (drop n) in chunksOf 4 [1,3..27]
03:15:11 <lambdabot>   [[1,3,5,7],[9,11,13,15],[17,19,21,23],[25,27]]
03:15:22 <quicksilver> cathper: thats how I would do it.
03:15:25 <jelly12gen> is haskell nice with a DB?
03:15:45 <cathper> quicksilver: Woa. I'll read carefully.
03:15:59 <sohum> :t in
03:16:00 <lambdabot> parse error on input `in'
03:16:14 <jelly12gen> currently i have a bot in haskell, servingas a loggingbot, i am thinking of moving the data into a DB :)
03:16:16 <sohum> oh, let .. in
03:16:30 <bastl> FunctorSalad_ good idea. Ill try that.
03:17:03 <bastl> BTW, i wrote a preprocessor that creates your macro-call from a hs-file with data and newtype declarations.
03:17:41 <Athas> What's the newest version of cabal?
03:17:53 <cathper> quicksilver: I understand. Elegant :-)
03:17:54 <Athas> The home page doesn't seem to say.
03:18:07 <Athas> Oh, there it is.
03:18:09 <quicksilver> cathper: good. It should probably be in Data.List really but it isn't.
03:19:31 <cathper> quicksilver: I searched, but couldn't find it.
03:20:00 <cathper> quicksilver: Then I started to hack my own solution, but it went like crap.
03:20:03 <vegai> jelly12gen: HDBC is quite ok
03:20:16 <jelly12gen> ok :)
03:20:33 <jelly12gen> thanks
03:20:45 <ivanm> quicksilver: \o/
03:20:52 <ivanm> dibblego: isn't there already a units package on hackage?
03:21:01 <dibblego> is there?
03:21:30 <ivanm> sure there is, can't think of the name though...
03:21:48 <dibblego> is Vincenty's ellipsoid algorithms on there?
03:22:32 <ivanm> dibblego: dimensional
03:22:36 <Botje> cathper: uh. woah. wrong channel for me, sorry :D
03:22:58 <Botje> cathper: Data.List.Split has some splitting functions
03:23:13 <dibblego> ivanm, oh well
03:25:32 <Athas> When I try to compile the Darcs version of GHC I get an error 'Could not find module `Distribution.Simple.Program.HcPkg'; what do I need to install to fix this?  Cabal 1.7?
03:26:18 <mmorrow> yes
03:29:38 <Athas> I have, but I think my /usr/local/lib/ghc-6.10.1/package.conf (which specifies Cabal 1.6) takes priority over my ~/.ghc/x86_64-linux-6.10.1/package.conf; is this fixable?
03:33:16 <Athas> Oh, wait, that's not it.
03:48:25 <ivanm> when writing a bibliography, would you normally include the ISBN, DOI, etc. numbers as well?
03:48:32 <ivanm> or just author, title, how published, etc.?
03:48:57 <sohum> :t iterate
03:48:59 <lambdabot> forall a. (a -> a) -> a -> [a]
03:49:00 <mlesniak> ivanm: I normally use the bibtex published by the authors
03:49:13 <sohum> > iterate (const 1)
03:49:21 <lambdabot>   mueval: ExitFailure 1
03:49:22 <ivanm> mlesniak: well, I got the bibtex from acm, etc. and for those articles, I have a DOI, etc.
03:49:23 <sohum> > iterate (const 1) 2
03:49:31 <ivanm> but do you usually include them in the final document?
03:49:32 <lambdabot>   mueval-core: Time limit exceeded
03:49:35 <sohum> > iterate (+1) 2
03:49:37 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
03:50:01 <mlesniak> ivanm: yes, since I use the bibliography style plainnat they are included if they exists
03:51:34 <ivanm> well, for some of them that I found, the doi includes the doi link; others just the number :s
04:08:31 * FunctorSalad_ wonders whether *anyone* understands this RegexMaker / RegexContext mess
04:09:07 <FunctorSalad_> I'd use Text.Regex, but I heard there are faster ones? but they use this horrible Text.Regex.Base interface
04:09:56 <ivanm> FunctorSalad_: there's pcre-light
04:10:06 <ivanm> FunctorSalad_: but RWH has a good chapter explaining the regex stuff
04:10:10 <quicksilver> you don't have to use the overloading
04:10:12 <ivanm> the globbing chapter IIRC
04:10:19 <quicksilver> there are non-overloaded versions of everythign IIRC
04:10:21 <FunctorSalad_> I think it's emotional now. I hate it ;)
04:10:28 <FunctorSalad_> quicksilver: not that I knew of
04:10:33 <quicksilver> that's what I was told.
04:10:41 <ivanm> FunctorSalad_: the overloading lets you automagically get different types of results, such as number of occurrences vs the occurrences themselves IIUC
04:10:46 <FunctorSalad_> example package using Text.Regex.Base interface: http://hackage.haskell.org/packages/archive/regex-tdfa/1.1.2/doc/html/Text-Regex-TDFA.html
04:11:22 <ivanm> I really wish people would check their haddock markup before submitting packages...
04:11:37 <FunctorSalad_> ivanm: right, let's make the easy things impossible just so you don't need an extra name for the hard things
04:11:54 <FunctorSalad_> :)
04:12:12 <ivanm> FunctorSalad_: heh
04:14:47 <FunctorSalad_> or let's have just *one* function in the whole program `foo :: Convert a b => a -> b' and write everything as an instance (with newtypes)...
04:14:52 <FunctorSalad_> ;)
04:15:46 <ivanm> heh
04:15:55 * ivanm writes that idea down for his next project
04:15:55 <FunctorSalad_> ok end of rant
04:15:56 <ivanm> ;-)
04:16:18 <ivanm> FunctorSalad_: thing is, you'd need a hell of a lot of newtypes to get that to work...
04:16:39 <ivanm> since if you have multiple Int -> Int functions for example, you'd need seperate newtypes just for that... :s
04:17:16 <int-e> yay! instance Ord a => Convert [a] (Sorted [a]) where convert = Sorted . sort
04:17:27 <FunctorSalad_> ivanm: not that many. one newtype with n phantom params gives you 2^n types in total (if you just have 2 phantom types)
04:17:36 <FunctorSalad_> :)
04:17:44 <ivanm> heh
04:17:57 <ivanm> FunctorSalad_: so then you need a data structure representing all your possible functions...
04:18:01 <ivanm> ;-)
04:18:28 <ivanm> so we have an explicit dictionary of functions with an algebraic type as the key!
04:18:30 <int-e> just until you have a universal turing machine
04:18:44 <FunctorSalad_> :D
04:19:05 <ivanm> \o/
04:19:14 <ivanm> oh, wait, is that meant to be bad?
04:19:15 <ivanm> ;-)
04:19:53 <int-e> Sacrificing performance and readability for ... no gain? nah, that is not bad.
04:20:47 <FunctorSalad_> is it ok to use md5 to make fresh names if you can't be bothered to make the whole thing monadic just for freshes?
04:21:08 <FunctorSalad_> the probability of collision is kinda low
04:21:38 <FunctorSalad_> (and it is intended that the same context gives the same name)
04:23:52 <FunctorSalad_> I mean I show the context and md5 that
04:24:46 <Cale> FunctorSalad_: That's an interesting approach, if conceptually kind of hairy :)
04:25:04 <donri> is functor salad anything like spaghetti code?
04:25:42 <dblhelix> donri: I'd say it's far more healty
04:25:43 * Cale .oO( String diagrams! )
04:25:46 <dblhelix> healthy
04:26:03 <donri> ;)
04:26:24 * Cale really needs to finish his articles up and post them :)
04:26:38 <cathper> Botje: Thanks for pointing to Data.List.Split!
04:26:51 <FunctorSalad_> donri: actually yes, I think I meant it as "a confusing tangle of functors" or something
04:26:55 * dblhelix really needs to finish his thesis
04:27:02 <Cale> actually, I should just post the one about diagrams now, if I can just get mathTeX running on my machine to render the diagrams for the blog :)
04:27:06 * FunctorSalad_ needs to get a topic for his thesis :-(
04:27:29 <FunctorSalad_> Cale: that'd be interesting. I never quite understood these string diagrams
04:27:41 <FunctorSalad_> are they actually unambiguous?
04:27:44 <Cale> yes
04:27:51 <Cale> actually, maybe I should write a bit more about why
04:27:58 <FunctorSalad_> by whitespace-sensitivity?
04:28:05 <Cale> It's because of the interchange law
04:28:31 <Botje> cathper: least i could do :)
04:29:26 <Cale> The interchange law says that if you start with 4 diagrams, and you paste them in pairs horizontally first, and then vertically, then you get the same thing as if you paste vertically first and then horizontally.
04:30:02 <FunctorSalad_> *nod*
04:30:17 <Cale> In symbols, if a,b,c,d are natural transformations, (a * b) . (c * d) = (a . c) * (b . d)
04:30:32 <SamB_XP> Cale: are you talking about category theory or lout ?
04:30:34 <FunctorSalad_> âŠ› ? :)
04:30:36 <cathper> Botje: Nontheless very usefull for me (AKA a n00b) :-)
04:30:38 <Cale> category theory :)
04:30:49 <SamB_XP> thought so
04:30:58 <SamB_XP> I don't think lout quite has that property ;-P
04:31:11 <Cale> I find it amusing though that there would be an analogy :)
04:31:46 <Cale> FunctorSalad_: those are intended to be vertical (.) and horizontal (*) composition
04:32:05 <FunctorSalad_> or maybe âŠš :)
04:32:17 <Cale> and from that, you get various things about how it's okay to slide natural transformations up and down past each other
04:32:53 <Cale> I've been using â€¢ and âˆ˜ in my TeX
04:33:11 <SamB_XP> well, wait a minute, I think lout may actually have a property like that, with those alignment thingies it has ...
04:33:20 <FunctorSalad_> lout?
04:33:28 <Cale> It's a typesetting language
04:33:44 <SamB_XP> FunctorSalad_: a self-proclaimed "purely functional"  functional typesetting language
04:33:48 <SamB_XP> er.
04:33:51 <Cale> lout's implementation makes me sad
04:33:53 <SamB_XP> why did I write functional twice ?
04:33:56 <SamB_XP> Cale: yeah, me too
04:34:00 <FunctorSalad_> hehe self-proclaimed?
04:34:05 <SamB_XP> but I can't see how to nicify it
04:34:20 <SamB_XP> FunctorSalad_: well, it's written in C and it's not obvious to me how to prove that it really is pure
04:34:21 <Cale> Aside from completely rewriting it, me neither.
04:34:31 <SamB_XP> but it's certainly intended to be
04:34:55 <knobo> Can I write libraries in haskell that I can use in common lisp?
04:35:03 <Cale> TeX's syntax is at the same time so ugly and so convenient.
04:35:08 <FunctorSalad_> your double use of 'functional' wasn't redundant actually =)
04:35:19 <SamB_XP> FunctorSalad_: I suppose
04:35:25 <SamB_XP> but I didn't mean to do it
04:35:30 <Cale> knobo: Circuituously, given that your implementation of Common lisp can import C functions.
04:35:32 <SamB_XP> knobo: why would you *want* to ?
04:36:28 <SamB_XP> most CL implementations can do FFI, yes, and there is a library that even lets you use the same syntax for basically all of them
04:36:45 <knobo> Ok, so if it is as simple as using FFI, then it's ok.
04:37:02 * FunctorSalad_ thinks it still sounds very scary
04:37:09 <FunctorSalad_> (via C)
04:37:10 <Cale> knobo: It does mean that you tend to have to do lots of wrapping on the Haskell side.
04:37:20 <SamB_XP> knobo: so, basically the code in each language would pretend it was interfacing with C
04:37:22 <Cale> knobo: To package things like lists up into arrays and so on.
04:37:44 <Axman6> what a gross idea :(
04:37:48 <Cale> (and obviously higher order stuff is much more hairy)
04:38:10 <SamB_XP> FunctorSalad_: well, I'm not sure how else you could do it ;-)
04:38:21 <knobo> maybe it is better to make two programs talk to each other over a socket.
04:38:49 <SamB_XP> well, yeah, I was just about to say that you *could* use a textual protocol instead
04:38:51 <Axman6> sounds more useful
04:38:59 <SamB_XP> and that it would probably be a lot nicer, really
04:39:32 <FunctorSalad_> for higher-order you probably want explicit lambda expressions
04:39:44 <knobo> There probably already exist a good sexp reader for haskell
04:39:45 <FunctorSalad_> I mean a lambda ADT
04:40:11 <SamB_XP> knobo: assuming you aren't going to expect it to handle wild reader macros, sure ;-P
04:40:18 <FunctorSalad_> my favourite one: data E a = Var a | App (E a) (E a) | Lam (E (Maybe a))
04:40:19 <FunctorSalad_> :)
04:40:39 <SamB_XP> hmm, how do I find my IP address in Windows ...
04:40:47 <FunctorSalad_> it's a monad and you get name-safeness for free
04:40:58 <Axman6> shaniaki: ipconfig i believe
04:41:05 <Younder> SamB_XP, use ipconfig
04:41:16 <Axman6> hooray, CCNA payed off!
04:41:22 <SamB_XP> ah, thanks
04:42:39 <SamB_XP> huh ... what kind of address is fe80::2b0:d0ff:fe2a:6b98%4 ???
04:42:48 <SamB_XP> I mean, what's with the %4 at the end ?
04:43:58 <Jafet> Port
04:44:06 <SamB_XP> port ?
04:44:11 <Jafet> Or not.
04:45:55 <knobo> SamB_XP: zone index?
04:45:59 <koeien37> subnet?
04:46:09 <Jafet> #windows?
04:46:48 <knobo> http://en.wikipedia.org/wiki/IPv6_Addresses#Link-local_addresses_and_zone_indices
04:50:35 <ivanm> dibblego: still around?
05:09:54 <mreh> is there a ZipWith of Mathematica?
05:11:31 <m0nkfish> eh
05:12:14 <earthy> @hoogle zipwith
05:12:15 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
05:12:15 <lambdabot> Data.ByteString zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
05:12:15 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
05:12:59 <koeien37> > zipWith id [(+1), (+2)] [1,2]
05:13:00 <lambdabot>   [2,4]
05:13:39 <mreh> i know of zipWith, i was just wondering if any Haskellers knew of a similar thing in Mathematica.
05:13:49 <earthy> > zipWith ($) [(*2), (*4)] [1,2]
05:13:51 <lambdabot>   [2,8]
05:14:11 <ivanm> mreh: I went to go learn mathematica once... saw the syntax, and ran away as fast as I could!
05:14:24 <ivanm> (and this is after I'd learnt - and liked - scheme as well as Haskell)
05:14:25 <koeien37> mreh: in general, i find the mathematica functions for lists lacking (could also be my inexperience). easy to write yourself though
05:14:28 <earthy> I've had to decipher some mathematica code
05:14:36 <Cale> Mathematica's syntax is actually one of its saner bits.
05:14:37 <mreh> ivanm: it isn't all that bad actually
05:14:43 <ivanm> Cale: :o
05:14:43 <mreh> it's purely functional
05:14:48 <earthy> that let me quickly see mathematica was not for me
05:14:49 <koeien37> mreh: not pure
05:14:50 <Cale> Though there are people who abuse the infix operators
05:14:57 <koeien37> heh. ~Join~ and so on
05:14:59 <Cale> which makes for horrifying code
05:15:01 <ivanm> I found it weird that they decided to have completely different syntax from other langs...
05:15:17 <Jafet> ivanm, speak for yourself
05:15:28 <ivanm> Jafet: I was!
05:15:30 <koeien37> which he did... right?
05:15:30 <int-e> ((??)????(???)?????(?)!)
05:15:31 <ivanm> Cale: doesn't it use square brackets for function params?
05:15:37 <koeien37> ivanm: yeah
05:15:44 <koeien37> f[3,5]
05:15:50 <mreh> Cale: do you know of a zipWith in Mathematica?
05:15:54 <Cale> ivanm: yes. That's one nice thing about it. It uses each type of bracket for only one thing.
05:15:58 <Cale> mreh: yeah, one sec
05:16:03 <ivanm> right; they can't even use the excuse of that being more mathematical (like using { } for lists are)
05:16:11 <ivanm> Cale: hmmmm, fair enough
05:16:21 <mreh> what is ZipWith?
05:16:33 <mreh> i dont suppose it's hard to implement
05:16:36 <int-e> > zipWith (*) [1..3] [2..4]
05:16:37 <lambdabot>   [2,6,12]
05:16:39 <Jafet> @src zipWith
05:16:39 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
05:16:39 <lambdabot> zipWith _ _      _      = []
05:16:44 <Jafet> Yep
05:16:47 <Cale> MapThread[f, {{a, b, c}, {x, y, z}}]
05:17:08 <mreh> MapThread... mmm rolls of the tongue
05:17:54 <ivanm> mreh: heh
05:18:05 <knobo> How to rcurry?
05:18:17 <ivanm> Cale: so mathematica uses () solely for grouping?
05:18:23 <Cale> ivanm: right
05:19:31 <Cale> ivanm: Mathematica is a lisp with M-expression syntax (from the original papers about lisp)
05:20:09 <Cale> f[x,y,z] <--> (f x y z)
05:20:25 <Cale> (as a translation between M-expressions and S-expressions :)
05:20:53 <int-e> +[1,2] hmmm.
05:21:13 <Cale> 1 + 2 is Plus[1,2]
05:21:59 <Cale> Infix operators all have prefix names
05:22:15 <Cale> and they're translated into that form as a first step
05:23:11 <koeien37> Cale: do you generally write Mathematica in a functional way, or more imperative?
05:23:15 <Cale> functional
05:23:33 <Cale> There's lots of imperative facilities, but I never use them.
05:23:37 <koeien37> all my profs seems to like an imperative approach :/
05:23:39 <koeien37> unreadable
05:24:18 <koeien37> but the few that i have subjected to a mathematica notebook written by me say the same thing about my code :)
05:24:22 <ivanm> Cale: yeah, I know that much (about M-expression syntax)
05:24:38 <Cale> Mathematica's evaluation model is its strangest feature. It lets you do things like write Cos[a] ^= 2, which defines a as a value which if you apply Cos to it will give you 2.
05:24:50 <ivanm> Cale: but probably the biggest disadvantage of mathematica is that it's proprietary
05:24:55 <ivanm> i.e. it wants my money
05:24:58 <Cale> hehe, yes
05:25:00 <Jafet> Pattern matching on steroids!
05:25:10 <ivanm> and I'm quite happy keeping my money where it is, thank you very much
05:25:14 <ivanm> ;-)
05:25:16 <Cale> Yeah, it only lets you have one-level of nesting like that though
05:25:27 <Jafet> "let cos a = 2 in ..."
05:25:29 <Cale> If you want Cos[Cos[a]] = 2, you're out of luck.
05:25:40 <Cale> Well, not entirely.
05:25:54 <Jafet> Now a is multivalued though
05:25:54 <Cale> You could say  Cos[a] ^= b; Cos[b] ^= 2, perhaps
05:26:08 <Cale> No, a is just a symbol
05:26:20 <Jafet> What happens when you evaluate a?
05:26:29 <Cale> nothing. It evaluates to itself.
05:26:53 <Jafet> Then this makes less sense to me than I thought
05:26:59 <Cale> heh
05:27:05 <Cale> Yeah, it doesn't actually solve the equation
05:27:27 <Cale> It's like you're defining a value which gets to co-opt the function which is applied to it so that function's definition doesn't get used.
05:27:28 <koeien37> if you apply Cos to it, it will give 2
05:28:02 <Cale> So the evaluation model has this extra step where it checks the parameters of a function first for any "upvalues"
05:28:13 <Cale> and only then applies the function to its parameters
05:28:24 <Cale> (if there were none)
05:29:18 * Jafet installs mathematica now...
05:30:59 <ivanm> Jafet: it just happened to magically appear on your computer, did it?
05:31:21 <Jafet> Yes, a fantastic coincidence.
05:31:31 <Jafet> Hmm, shiny text editor
05:31:34 <Cale> Ah, the magic of the Internet. Where would we be without you, Internet piracy?
05:31:55 <Cale> Jafet: You have mathematica 7?
05:32:09 <Jafet> That's what it says on the can, yes
05:33:18 <ivanm> it came in a can? :o
05:33:44 <Jafet> What were you expecting, RPM?
05:34:33 <Cale> Manipulate[ContourPlot3D[a x^2 + b y^2 + c z^2 + d x^2 y + e y^2 z + f z^2 x + g x^3 + h y^3 + i z^3 == 1, {x, -2, 2}, {y, -2, 2}, {z, -2, 2}, Mesh -> None, ContourStyle -> Directive[Opacity[0.8]]], {{a, 1}, -2, 2}, {{b, 1}, -2, 2}, {{c, 1}, -2, 2}, {{d, 0}, -2, 2}, {{e, 0}, -2, 2}, {{f, 0}, -2, 2}, {{g, 0}, -2, 2}, {{h, 0}, -2, 2}, {{i, 0}, -2, 2}, ControlPlacement -> Right]
05:34:35 <ivanm> 1s and 0s ;-)
05:34:43 <Cale> Put that in a cell and evaluate it :)
05:34:51 <Cale> (Shift-Enter)
05:35:47 <Cale> (and then play with the sliders, and you get a nice continuously-updated 3D plot of that polynomial surface :)
05:36:23 <Cale> You can also grab the 3D plot with the mouse and spin it.
05:36:33 <det> Do all Haskell compilers implement type classes by passing dictionaries? Do any do it by specialization ?
05:36:56 <Cale> Maybe JHC to some extent?
05:36:57 <int-e> det: jhc does it by specialization
05:37:25 <Cale> But to do it by specialisation sort of breaks separate compilation, so you need a whole-program compiler.
05:37:26 <int-e> det: and some variant of run time type info, I believe.
05:37:56 <det> Cale, I would think you really only need to recompile dependencies
05:38:17 <det> but yeah, the whole program would need to be available
05:39:06 <det> similar to C++ templates
05:39:18 <Cale> Also, there are things like...
05:39:23 <det> I was thinking about how closures could be implemented as a "Callable" type class
05:39:45 <det> and along with specialization it could be really efficient
05:39:46 * ivanm read that as "Cale-able" type class ...
05:41:28 <Cale> > let f :: (Show a) => Integer -> a -> String; f 0 x = show x; f n x = f (n-1) (x,x) in f 5 ()
05:41:29 <lambdabot>   "((((((),()),((),())),(((),()),((),()))),((((),()),((),())),(((),()),((),()...
05:41:45 <Cale> This f uses arbitrarily many instances of Show at runtime.
05:42:07 <det> polymorphic recursion ?
05:42:11 <Cale> yeah
05:42:16 <Cale> (consider that the 5 there might come from user input)
05:42:25 <det> Yeah, that is kind of out of the question for a language that did this
05:43:11 <det> A function "apply f x = f x" would have a type like "Callable a b c => a -> b -> c"
05:44:44 <det> and passing it a closure would specialize it on the environment of the closure, so no need for boxing
05:45:02 <opqdonut> that feels pretty ugly
05:45:10 <benmachine> am I right in thinking that any FFI call that has side effects should be in the IO monad?
05:45:14 <opqdonut> because the type classes aren't really integrated into the type system
05:45:17 <opqdonut> benmachine: yes
05:45:18 <det> but you would need existential types to store a closure in a list or something
05:45:22 <benmachine> isn't this what the medical instruments guy on -cafe is doing wrong?
05:45:27 * benmachine is kind of surprised no-one has mentioned it
05:45:37 <int-e> Cale: you can associate each type constructor with a data constructor describing the type (data TypeInfo = TI_Integer | TI_Unit | TI_Pair TypeInfo TypeInfo | ...), and pass that along with the values, and pattern match on it where type class instances are needed. Then rely on the optimizer to get rid of the type info where it isn't needed. I believe that's what jhc does, but it's been a while since I read the GRIN paper.
05:46:21 <benmachine> oh he already tried doing it as IO ()
05:46:24 * benmachine hmms
05:46:28 <knobo> aha.. uncurry, it is called.
05:47:25 <knobo> nope. it's not what I was thinking of.
05:50:48 <knobo> I was wondering if there was some built inn cool way to do transform (f a b) to (f b a)?
05:51:55 <int-e> flip
05:52:16 <int-e> > ((-) 4 3, flip (-) 4 3)
05:52:17 <lambdabot>   (1,-1)
05:53:05 <benmachine> @src flip
05:53:05 <lambdabot> flip f x y = f y x
05:57:25 <knobo> thanx
06:09:05 <McManiaC> can you use functions in a case construct?
06:09:18 <McManiaC> case foo of doSomething -> bar... ?
06:09:19 <burp> sure
06:09:23 <jmcarthur> in what sense do you mean?
06:09:25 <jmcarthur> not like that
06:09:31 <burp> case odd x of ..
06:09:34 <int-e> McManiaC: not in patterns (unless you enable view patterns)
06:09:45 <jmcarthur> doSomething is a binding, not an expression
06:10:07 <int-e> McManiaC: what would you expect that to do anyway?
06:10:10 <jmcarthur> and view patterns is a little different
06:10:38 <McManiaC> if foo would be "bar" and doSomething returns "bar" then it should match ^^
06:10:46 <int-e> jmcarthur: but if I hadn't mentioned them somebody else would've pointed out that I'm wrong for sure. :)
06:11:06 <int-e> McManiaC: case foo of x | x == doSomething -> ...
06:16:19 * hackagebot upload: data-aviary 0.1.0 - Combinator birds. (StephenTetley)
06:23:05 <Younder> finallly a group I cant contribute anthing intelligent whatsoever
06:23:22 <Younder> Just finished 'Real World Haskell'..
06:23:54 <Younder> Strill trying to figure out monads etc.
06:24:17 <jasonmay> RWH is in the mail for me :)
06:25:41 <medfly> grats
06:26:20 <watermind> slightly of topic but maybe you guys know... have you look into Google's Go language? Does it have sum types?
06:26:35 <watermind> I can't find them in the language description, but find it kind of surprising
06:26:55 <koeien37> watermind: i read somewhere that there was no equivalent of C's union yet, which would amount to this
06:27:10 <watermind> koeien37: ah ok air enough, thanks
06:29:13 <SAiNT_JiMMiE> if i may i would ask if someone knows something similar to:
06:29:22 <SAiNT_JiMMiE> define haskell datatypes for representing CFG grammars and LL(1) parsing tables
06:29:38 <SAiNT_JiMMiE> this was the first part
06:29:40 <SAiNT_JiMMiE> 2.define lexical/syntax analyzer for parsing a CFG grammar
06:29:50 <SAiNT_JiMMiE> 3.define a set of functions for computing the LL(1) parsing table corresponding to the
06:29:50 <SAiNT_JiMMiE> CFG grammar returned by the parser
06:30:00 <SAiNT_JiMMiE> define a set of functions for printing out the LL(1) parsing table on the terminal
06:30:04 <SAiNT_JiMMiE> this was 4
06:30:29 <SAiNT_JiMMiE> something around these topics
06:31:12 <SAiNT_JiMMiE> PM me if someone can help
06:33:16 <Younder> homework?
06:33:45 <SAiNT_JiMMiE> haha no it's last years project
06:33:49 <SAiNT_JiMMiE> for compilators
06:34:01 <SAiNT_JiMMiE> wanna find smth very similar
06:34:10 <SAiNT_JiMMiE> to prepare for the exam
06:34:22 <SAiNT_JiMMiE> it's the most difficult and it's the last one
06:37:49 <desp> I have a FFI-related problem.  I'm passing a wrapped Haskell function to a C library, as a callback.  This mostly works, but at non-deterministic times I get an unusual error:
06:37:52 <desp> Main: schedule: re-entered unsafely. Perhaps a 'foreign import unsafe' should be 'safe'?
06:38:16 <desp> All my foreign imports are marked as 'safe'.
06:38:39 <desp> I'm not sure what's happening.
06:39:00 <anakreon> I am testing the flow2dot program. It doesn't work on the sample.flow file provided by the author.
06:39:06 <mlesniak> Are there any rules/conventions for multi-line type signatures (i.e. they can become quite long sometimes)?
06:40:56 <koeien37> :: X \n -> Y \n -> Z     is pretty common i think
06:42:40 <mlesniak> koeien37: Hmm, yes, saw this sometimes, but (unfortunately I forgot where) some other conventions. I'll stick to this, thanks
06:46:59 <desp> Is threaded RTS the default?
06:48:10 <int-e> no. you can check which RTS is used in a program by running   program +RTS --info
06:48:28 <int-e> (the threaded rts is rts_thr, the normal one is just rts)
06:48:35 <desp> ("RTS way", "rts")
06:49:16 <int-e> And you need to use -threaded while linking to link to the threaded rts.
06:49:39 <desp> int-e: top shows a variable number of threads in my program, though. 3, 3/1, 4
06:50:03 <int-e> is the C library threaded?
06:50:16 <desp> I don't think so.
06:50:38 <desp> Checking.
06:50:57 <desp> It's PortAudio, btw.
06:51:28 <desp> Ah, my bad, it is.
06:52:11 <desp> int-e: do you have any ideas re: the unsafe thing?  I'm thinking, perhaps I need to make all FFI calls from a single bound thread.
06:53:02 <desp> But no, if I'm not using the threaded RTS, then I already am making all FFI calls from a single OS thread.
06:53:42 <int-e> desp: I'm not sure what happens if another thread calls back into the RTS while its running.
06:56:03 <mmorrow> desp: maybe have more luck in ghc#
06:56:14 <desp> int-e: using the threaded RTS seems to fix the crashes... and using a bound thread seems to fix a hang I've been experiencing on close.
06:56:19 <desp> mmorrow: thanks
06:58:28 <int-e> desp: that vaguely makes sense.
06:58:45 <int-e> (I'll follow the #ghc discussion)
07:20:04 * Cale slowly but surely wins the battle against pulseaudio in Ubuntu Karmic.
07:26:33 <Gracenotes> \o/
07:26:57 * hackagebot upload: mathlink 2.0.1.1 - Write Mathematica packages in Haskell (TracyWadleigh)
07:27:21 <Cale> I'm currently rebuilding the gnome-media package from source in order to remove the pulseaudio requirement.
07:27:41 <koeien37> that is kind of drastic
07:28:03 <Cale> Basically have to do it if I want a gnome audio mixer that doesn't just hang.
07:28:49 <Cale> Though I did get the panel applet working (by compiling that from source) already.
07:30:00 <Cale> Yay! It works :)
07:30:48 <koeien37> so much for a noob-friendly distro ;)
07:30:56 <Cale> yeah
07:31:11 <Cale> I guess ordinary users are just expected not to care about having their headphones work.
07:31:27 <Cale> Or having more than one volume control knob.
07:31:49 <Cale> (despite the fact that they have a sound card with dozens)
07:32:08 <opqdonut> ubuntu is horrible
07:32:15 <opqdonut> i try to stay away from it as much as possible
07:32:17 <ehamberg> #ubuntu-talk? :)
07:32:30 <Cale> It's gotten successively worse in each of the last 3 or 4 versions.
07:32:34 <opqdonut> indeed
07:32:44 <opqdonut> they can't keep up with this release-every-six-months thing
07:32:51 <koeien37> of course not
07:32:53 <opqdonut> larger changes need more maturing time
07:33:05 <koeien37> we will have fun with gnome 3.0 i suppose
07:33:16 <opqdonut> and most of the problems that caused ubuntu to fork from debian are gone from debian
07:33:22 <opqdonut> slowness of release cycle etc
07:33:28 <koeien37> except the installer
07:33:33 <opqdonut> it's ok
07:33:38 <koeien37> for me, it's ok too
07:33:40 <opqdonut> of course, the .deb-distros don't have proper multilib
07:33:43 <koeien37> but it can be friendlier
07:33:44 <opqdonut> which is a PITA
07:34:08 <opqdonut> at least for me, I use a lot of 32-bit only proprietary libs at work
07:37:48 <Cale> The other weird thing about installing Karmic was that it removed my Japanese input support and replaced it with Russian. I reconfigured things and it works, but that's still pretty stupid.
07:37:52 <donri> i love you haskell, but why must you have so many ugly names. "mapM_"? :(
07:38:04 * Tobsan likes mapM_
07:38:14 <ehamberg> i have ghc 6.10.4 installed and i can't get ghci to use the vi editing mode. i have set this in both .inputrc and .editrc (does it use editline or readline?). how can i debug this? :/
07:38:22 * quicksilver has a naming scheme
07:38:29 <donri> Tobsan, what it does or the name itself?
07:38:37 <Gracenotes> Cale: ah, I found that annoying
07:38:38 <Zao> ehamberg: Doesn't it use some fancypants haskelline nowadays?
07:38:38 <quicksilver> mapM_ -> translateFuzzyNeat
07:38:39 <Tobsan> donri: both ofcourse!
07:38:40 <opqdonut> mapM_ is nice
07:38:56 <opqdonut> quicksilver: :D
07:39:00 <Gracenotes> Cale: I've uninstalled it, and when I log out/log in sometime, I'll reinstall it, with anthy
07:39:01 <donri> it's probably a nice function as such, but names like that are just ugleh *shiver*
07:39:21 <Gracenotes> it is probably the mix of camel case and underscore?
07:39:29 <Cale> Gracenotes: you're expected to use ibus now (which supports anthy)
07:39:31 <Gracenotes> it is only a trailing underscore, though..
07:39:37 <ehamberg> Zao: oh? how can i find out? it used to use editline, but it does not seem to link against either editline or readline.
07:39:42 <Gracenotes> Cale: ah. is that a component of SCIM..?
07:39:46 <Gracenotes> or entirely different
07:39:58 <Cale> Gracenotes: ibus is similar to SCIM in functionality, but a different piece of software
07:40:13 <donri> Gracenotes, because mapM exists and does something similar but different
07:40:19 <Cale> Gracenotes: It also has a nice LaTeX mode and all.
07:40:33 <Cale> Gracenotes: A little less featureful, but also looks a bit nicer.
07:40:45 <Zao> ehamberg: It's probably configurable when building it, perhaps?
07:40:56 <Cale> (and it uses anthy for japanese conversion, just like scim)
07:41:29 <Gracenotes> hm. more importantly: can you activate it anywhere with Ctrl+Space, like you can SCIM?
07:41:54 <Cale> ehamberg: ghci dropped editline support because it sucked. It uses Haskeline now. That does have a configuration file, one moment :)
07:42:03 <ehamberg> i now put "editMode: Vi" in ~/.haskelline, still no luck. (this is openSuse packages, btw.)
07:42:47 <Gracenotes> ah yes. haskeline. speaking of which.. why does it not work for Delete, Home, and End? :/ it is really annoying.. I use these keys a lot in ghci navigation
07:43:02 <Cale> Gracenotes: It really should
07:43:10 <Gracenotes> should? O_O
07:43:50 <Cale> Gracenotes: (I mean, regarding Delete/Home/End -- they work here)
07:44:09 <Cale> and yeah, you can activate ibus from anywhere with Ctrl-Space
07:44:49 <ehamberg> maybe i should build ghc myself, then, with readline or editline. :/
07:44:51 <Gracenotes> so, my configuration is abnormal -- is there a way to fix it?
07:47:05 <Vanadium> ghci does not seem to do the Vi thing correctly :(
07:47:22 <Vanadium> Gracenotes: Try adjusting your TERM environment variable
07:47:50 <Vanadium> I used to have rxvt-unicode, which ghci did not know how to handle home/end for, but it does for rxvt, which is apparently compatible...
07:48:38 <Gracenotes> hm. I guess that means no pasting Japanese characters in ghci, then
07:48:59 <Gracenotes> mine just says "xterm", really..
07:49:18 <Vanadium> :[
07:53:24 <Cale> Mine says xterm too, and Japanese input works.
07:53:45 <Vanadium> Mine says rxvt and I do not know any japanese
07:54:09 <Vanadium> It seems to do just fine, though
07:56:00 <Gracenotes> Japanese is just fine at the moment. I don't care about that, so long as Home/End/Delete work. thankfully haskeline source isn't that huge, so I'll dive into it.. sometime..
07:58:07 <Vanadium> Does upgrading haskeline actually affect ghci or does it use an internal version it ships with ghc or something?
08:00:41 <Cale> It would be statically linked against it
08:00:56 <Cale> So if you want to update which version you're using, you'd have to rebuild ghci
08:02:41 <Gracenotes> from source? :/
08:03:12 <Gracenotes> given that I'm currently using the Ubuntu-packaged version. well, that would be a total nightmare.
08:04:33 <Cale> Yeah, I wouldn't bother. If you're using the Ubuntu version of GHC though, you might like to try the generic linux binary package from the GHC website.
08:04:36 <Gracenotes> interestingly, I don't have libghc6-haskeline-dev installed. but if it's statically linked in the binaries, well, don't 'need' it. technically :/
08:05:02 <Gracenotes> to my Home/End/Delete detriment
08:05:17 <Jafet> preflex, nickometer {}_
08:05:17 <preflex>  {}_ is 75% lame
08:06:19 <{}_> Jafet, you had a point?
08:07:33 <Gracenotes> lameness is not pathological!
08:08:18 <{}_> just using this nick for a change.  Will probably go back next time my bouncer naturally looses connection
08:08:24 <jasonmay> preflex, nickometer jasonmay
08:08:24 <preflex>  jasonmay is 0% lame
08:08:31 <jasonmay> oooh!
08:10:00 <Jafet> Nah, nickometer is pointfree
08:10:33 <jasonmay> preflex: nickometer jamp
08:10:33 <preflex>  jamp is 0% lame
08:12:20 <Gracenotes> preflex is strongly alphanormative
08:18:50 <Maddas> preflex: nickometer pointfree
08:18:50 <preflex>  pointfree is 0% lame
08:28:13 <leimy_> http://golang.org looks cool to me.
08:31:52 <Maddas> leimy_: I was rather disappointed, really, but I haven't given it an in-depth look.
08:32:04 <leimy_> What disappointed you?
08:32:14 * leimy_ is used to Limbo and such, so maybe it's not as much of a shock :-)
08:32:19 * Maddas never saw Limbo
08:32:26 <Maddas> leimy_: I expected more radical changes :-)
08:32:29 <leimy_> Limbo is the language for coding stuff on the Inferno operating system.
08:35:11 <poucet> preflex: nickometer 1337
08:35:11 <preflex>  1337 is 63% lame
08:46:58 <Baughn> When would you use ReaderT instead of passing in parameters classically? When not every function in the chain cares about the parameters?
08:48:36 <quicksilver> when you keep mentioning the same parameter *so* often you get bored of it / make mistakes
08:48:37 <leimy_> If you have a program like I did, where you have little functions like "logit" which just take a string, look up a Reader contained handle, and do hPutStr to it.  You will appreciate not passing that argument to every function :-)
08:48:55 <Baughn> leimy_: I just use hslogger instead. :P
08:49:11 <leimy_> Yeah well you'd still be missing the point.
08:49:18 <Baughn> Yeah, I get the idea.
08:49:20 <leimy_> it's about avoiding boilerplate and not doing cut and paste :-)
08:49:35 <leimy_> because I've found MANY code bugs over the years that are the result of cut and paste
08:49:48 <leimy_> also, consider if you have to change a part of your program later in those arguments that have to be passed everywhere
08:49:57 <leimy_> how many lines of code do you change to refactor?
08:50:00 <leimy_> Reader makes it a lot easier.
08:50:05 * Baughn nods
08:50:18 <leimy_> dons had a great example of an ircbot using reader IMO
08:50:21 <Gracenotes> it is really just comparing the noisiness of parameter-passing vs. the noisiness of ReaderT-ing -.-
08:50:33 <Baughn> leimy_: Oh, and I've gotten in the habit of, if I ever /move/ code, to rewrite the whole thing instead. Paste, comment out pasted block - rewrite.
08:50:35 <leimy_> I find "ask"ing is nicer :-)
08:50:40 <Baughn> Catches errors nicely. ;)
08:50:44 <leimy_> heh
08:50:47 <leimy_> yes that can help
08:50:50 <Gracenotes> oftentimes when I want to use Reader I really need State, and when I use State all I need is Reader..
08:51:06 <Baughn> Gracenotes: Bad grace! No cookie!
08:51:10 <leimy_> I've found Reader to be really valuable
08:51:39 <Gracenotes> nay, cookies for all
08:51:50 <Baughn> newCookie :: IO Cookie?
08:52:16 <Baughn> Ooh. I just had an evil idea: Reverse implicit parameters: Implicit return values.
08:52:25 <int-e> newCookie :: UserPermission -> IO Cookie
08:52:30 <int-e> (EU version)
08:52:39 <Gracenotes> Baughn: comonad :)
08:52:45 <Baughn> Let functions return values by name, and have them shadow the corresponding value in the calling function
08:53:13 <Baughn> So, "do bar; print foo" could print an alternate value for foo simply by altering bar
08:53:23 <Gracenotes> although, I think someone has worked on reverse state, and succeeded..
08:53:37 * Baughn will be over here, working on merging Haskell and Perl. No need to thank me.
08:54:34 <Saizan> we will be the ones under your house with torches and pitchforks
08:54:35 <preflex>  Saizan: you have 1 new message. '/msg preflex messages' to read it.
08:54:37 <quicksilver> Gracenotes: occasionally it's useful to have functions to run a reader action in a state monad
08:54:51 <quicksilver> Gracenotes: so you can distinguish in the type syatem functions that chagne the s and those that don't
08:55:27 <Gracenotes> mm. I haven't gotten to the point I need the type system for it, though ;) (using 'gets' works)
08:55:50 <Gracenotes> although, gets doesn't allow monadic actions therein
08:56:20 <fentiman> can anyone tell me is there a way to import modules together e.g "import Data.List, Data.Char" or do you have to write each one seperately?
08:56:21 <quicksilver> you never need the type system, Gracenotes . Sometimes it's handy though.
08:56:32 <Gracenotes> heh. yeah.
08:59:00 <Kim^Walkman> fentiman: You *could* import them all in one module and export them from there together
09:00:30 <fentiman> ah ok, so there is no single declaration, thanks
09:06:10 <leimy_> anyone seen ooc? http://ooc-lang.org/
09:07:29 <Athas> I'm trying to build GHC from Darcs, but I get this following error: 'utils/ghc-cabal/ghc-cabal.hs:235:22: Not in scope: `libraryConfig''.  I'm using Cabal 1.8.0.1 from the Cabal darcs directory.
09:08:26 <fentiman> leimy_: looks interesting, how long has it been around?
09:08:32 <leimy_> No idea
09:08:39 <leimy_> I showed "go" to someone, they said "check out ooc"
09:08:41 <leimy_> I just saw it :-)
09:09:22 <Athas> Ooc is really bad, unfortunately.
09:09:48 <fentiman> Athas: how so?
09:10:27 * CalJohn doesn't like Go much, either
09:12:13 <Athas> fentiman: the designer doesn't seem to appreciate the nuances of the features he adopts.  For example, he made a blog post about "pattern matching" that was really just Lisp-style COND.
09:12:40 <Athas> And the implementation is not very good either.
09:13:17 <Athas> This Reddit comment thread has a few points: http://www.reddit.com/r/programming/comments/9wj1r/ooc_the_soft_point_between_haskell_python_and_c/
09:19:56 <fentiman> ok thanks for the information
09:20:51 <fentiman> sounds like a nice concept though
09:25:41 <maurer_> Hey, I'm implementing backprop in a neural net in haskell. I've got it implemented, and it goes, but I'm trying to figure out how to make it more eleagant.
09:25:56 <maurer_> I can't easily map, because each node depends on some set of other nodes.
09:26:13 <maurer_> Fold has a similar problem because this particular net system can't be segmented into layers.
09:27:03 <maurer_> Any idea on how to do walking on a graph in a similar function to fold?
09:28:12 <gal_bolle> is your graph acyclic oriented?
09:32:24 <maurer_> gal_bolle: No, it's a slight modification of backprop, so it does contain cyles.
09:32:44 <maurer_> gal_bolle: Otherwise I could decompose it into layers, and everything would be much easier.
09:36:23 <c_wraith> maurer_:  you could just use a BFS.
09:36:53 <c_wraith> maurer_: or iterative deepening, if you're willing to sacrifice a bit of speed for less memory use
09:37:20 <maurer_> c_wraith: The problem is that each node's results depend on all the nodes that feed into it.
09:39:57 <c_wraith> maurer_: oh, so you're talking about the actual operation of the network...  that's not really a fold or an fmap, exactly.
09:40:56 <maurer_> c_wraith: Not the operation, the error propogation, but it still has the dependency. I know it isn't a fold or map, which is why I'm wondering if there's something like a fold, but over a generalized graph instead of a list.
09:42:25 <c_wraith> maurer_: Is the propogation a fixed-point operation, or is it a single step from the previous state?
09:43:09 <maurer_> c_wraith: Fixed point
09:43:22 <maurer_> Essentially I want something of the form:
09:44:14 * hackagebot upload: bindings-common 1.3.4 - This package is obsolete. Look for bindings-DSL instead. (MauricioAntunes)
09:44:23 <c_wraith> maurer_:  actually, iterated fmap might give you what you want in a sufficiently elegant manner.
09:45:03 <c_wraith> maurer_: But that would require that each node knows what its neighbors are.
09:45:17 <maurer_> c_wraith: Yeah, you need to feed in the graph to do this
09:45:21 <maurer_> But I just came up with an idea:
09:45:59 <maurer_> thisThingImean graph f = fmap (f graph) graph
09:46:01 <maurer_> likely works
09:46:13 <maurer_> Assuming f does the walking the graph itself
09:46:30 <gal_bolle> this will only do one step
09:46:40 <gal_bolle> won't it
09:47:07 <maurer_> The idea is that we have f :: Graph -> Node -> Node
09:47:19 <maurer_> So that f wanders around the graph to update the node.
09:47:26 <maurer_> It will result in a LOT of duplicated effort
09:47:36 <maurer_> but if I memoize f that should be solved.
09:48:04 <c_wraith> :t iterateM
09:48:05 <lambdabot> Not in scope: `iterateM'
09:48:10 <c_wraith> @hoogle iterateM
09:48:11 <lambdabot> No results found
09:48:17 <c_wraith> bah.  That really should exist
09:49:36 <kmc_> @type sequence . iterate
09:49:37 <lambdabot>     Couldn't match expected type `[m a]'
09:49:37 <lambdabot>            against inferred type `a1 -> [a1]'
09:49:37 <lambdabot>     Probable cause: `iterate' is applied to too few arguments
09:50:09 <FunctorSalad_> hmm is "catch" inside Template Haskell's runIO inert?
09:50:44 <mr_ank> hmm... when i do something like (read "5")::Integer - isn't the :: analogous to casting?
09:50:51 <kmc_> no
09:50:58 <kmc_> it specifies what the type already is
09:50:59 <c_wraith> :t iterateM f a = do { x <- f a ; return $ x : iterateM f x }
09:51:00 <lambdabot> parse error on input `='
09:51:01 <Botje> it's a hint to the type system :)
09:51:06 <c_wraith> boo
09:51:06 <kmc_> it doesn't result in any kind of conversion
09:51:22 <c_wraith> :t let iterateM f a = do { x <- f a ; return $ x : iterateM f x } in iterateM
09:51:23 <kmc_> > (0 :: Int) :: Char
09:51:23 <lambdabot>     Occurs check: cannot construct the infinite type: b = [b]
09:51:24 <lambdabot>       Expected type: [b]
09:51:24 <lambdabot>       Inferred type: [[b]]
09:51:24 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
09:51:25 <lambdabot>         against inferred type...
09:51:27 <mr_ank> hm
09:51:30 <kmc_> see, it's a type error
09:51:43 <mr_ank> > :type (read "5")
09:51:44 <lambdabot>   <no location info>: parse error on input `:'
09:51:51 <kmc_> :t read "5"
09:51:52 <lambdabot> forall a. (Read a) => a
09:52:01 <kmc_> > read "5"
09:52:02 <lambdabot>   * Exception: Prelude.read: no parse
09:52:17 <kmc_> you need the signature because it doesn't know what result type it should have
09:52:21 * hackagebot upload: bindings-DSL 1.0 - Domain specific language for FFI description, on top of hsc2hs. (MauricioAntunes)
09:52:23 * hackagebot upload: bindings-gsl 0.1 - Low level bindings to GNU GSL. (MauricioAntunes)
09:52:24 <mr_ank> oh so i'm setting the value of a?
09:52:27 <c_wraith> :t let iterateM f a = do { x <- f a ; xs <- iterateM f x ; return $ x : xs } in iterateM
09:52:29 <lambdabot> forall t (m :: * -> *). (Monad m) => (t -> m t) -> t -> m [t]
09:52:33 <kmc_> of the type a/
09:52:34 <kmc_> ?
09:52:36 <mr_ank> yes
09:52:38 <c_wraith> there, that's what I was looking for
09:52:42 <kmc_> yeah
09:52:45 <mr_ank> ahhh
09:52:47 <kmc_> not the terms i'd use, but yes
09:53:03 <eivuokko> mr_ank, it might be better to think in terms of constraining the type.
09:53:08 <mr_ank> oh ok
09:53:09 <kmc_> you tell it that the entire expression (read "5") should have type Int, from which it figures out what type "a" is, and can use that to invoke the correct typeclass instance
09:53:36 <mr_ank> i assuem i can do something like ::Int::Integer if it has more than 1 parametric type?
09:53:51 <eivuokko> Read a => a is any type that has Read instance, out of those types you might want to have, say Int, so you annotate with ::Int
09:54:12 <byorgey> mr_ank: no, an expression can't have two different types
09:54:44 <mr_ank> cool, thanks
09:54:52 <byorgey> mr_ank: but you can use multiple type annotations at different places inside an expression.
09:55:15 <byorgey> for example   length ([1,2,3] :: [Integer]) :: Int
09:55:25 <mr_ank> byorgey: exactly
09:55:26 * hackagebot upload: bindings-libusb 1.4 - Low level bindings to libusb. (MauricioAntunes)
09:55:28 <mr_ank> that's what i meant
09:55:32 <byorgey> mr_ank: ok, sure =)
09:55:40 <mr_ank> that i can specify "a" and "B"
09:55:42 <mr_ank> "a" and "b"
09:55:49 <byorgey> mr_ank: neither of those annotations is actually necessary in that particular example I gave, but that's the idea.
09:55:56 <mr_ank> neat thanks
09:56:16 <zygoloid> > genericLength ([1,2,3] :: [CReal]) :: Double
09:56:18 <lambdabot>   3.0
09:58:18 <kmc_> mr_ank, so the annotation is not directly filling in "a" or "b"
09:58:36 <kmc_> the type signature is attached to an expression, and specifies what the type of that expression is
09:58:38 <kmc_> it's
09:58:46 <kmc_> it's a hint which the type inference system will add to what it already knows
09:59:01 <mr_ank> hmm
09:59:14 <mr_ank> i don't understand the difference
09:59:30 <kmc_> > (repeat (read "5")) :: [Int]
09:59:31 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
09:59:32 <mr_ank> is it just constraining the types that can be inferred?
09:59:34 <kmc_> yes
09:59:53 <mr_ank> and then he compiler solves based on what you entered?
09:59:55 <kmc_> so we say that (repeat (read "5")) has type [Int], which constrains the return type of read to be Int
09:59:57 <kmc_> yes
09:59:59 <mr_ank> cool
10:00:01 <mr_ank> i get it now
10:00:02 <mr_ank> thx
10:00:06 <kmc_> which it will do anyway, if there are no signatures
10:00:19 <kmc_> but in certain cases, like read, that problem is underspecified so you have to tell it more
10:00:21 <mr_ank> oh - but it might choose something that you don't want
10:00:34 <mr_ank> like Integer instead of Int
10:00:36 <kmc_> usually if there is ambiguity you just get an error
10:00:46 <kmc_> but yeah in certain cases it picks default types for numbers
10:00:50 <mr_ank> cool
10:00:54 <kmc_> which is sort of an ugly corner of the language
10:00:59 <kmc_> > read "()"
10:01:00 <lambdabot>   ()
10:01:07 <kmc_> lambdabot defaults stuff to () sometimes
10:01:13 <HugoDaniel1> http://en.wikipedia.org/wiki/File:DiffusionOfInnovation.png in which part of the curve are we now ?
10:01:21 <HugoDaniel1> regarding haskell
10:01:30 <kmc_> early adopters
10:01:31 <koeien37> > 1 + 1 -- another exaqmple of defaulting
10:01:32 <lambdabot>   2
10:01:36 <kmc_> :t 1+1
10:01:37 <lambdabot> forall t. (Num t) => t
10:02:00 <HugoDaniel1> and lisp ?
10:02:05 <koeien37> lisp is ancient :)
10:02:07 <HugoDaniel1> which part of the curve are they now ?
10:02:17 <koeien37> but still going strong :)
10:02:23 <mr_ank> lisp doesn't have curves - only cons and cdrs.
10:02:26 <HugoDaniel1> :D
10:02:29 <HugoDaniel1> ok
10:02:31 <koeien37> car, cdr
10:02:32 <koeien37> :)
10:02:44 <HugoDaniel1> i thought that was scheme
10:02:48 <mr_ank> cadadadadadadddddr
10:03:01 <koeien37> yeah could be -- i don't know any lisp
10:03:11 <Twey> Heh
10:03:12 <mr_ank> thanks guys, back to the text
10:18:29 <Twey> mr_ank, koeien37: cons creates a cons cell, whereas car and cdr access its parts
10:18:47 <Twey> cons = (:); car = fst; cdr = snd
10:19:14 <Twey> (bearing in mind that lists in Lisps (are, (nested, (tuples, ())))
10:19:19 <ksf> arrr Issue 9. Kudos to google if they pick that one up.
10:20:34 * hackagebot upload: hpage 0.4.3 - A scrapbook for Haskell developers (FernandoBenavides)
10:20:46 <donri> Twey, lisp is such a happy language! :))))
10:20:52 <Twey> Hehe
10:20:59 <Twey> Especially if you're Russian
10:21:13 <tensorpudding> car and cdr are not fst and snd, they're head and tail
10:21:19 <Twey> tensorpudding: They're both
10:21:38 <Twey> At a fundamental level, they're fst and snd, but because lists are composed of cons cells, they're also head and tail
10:21:40 <tensorpudding> in a sense
10:21:49 <ksf> car and cdr are fst and snd. both are tuple/tree primitives, not list primitives.
10:21:56 <tensorpudding> since everything is a list
10:22:01 <ksf> lists are just a degenerate form of trees, after all.
10:22:10 <Twey> Heh.  TouchÃ©.
10:22:34 * kw317 is listenting to a tech talk about programming lanugage Go
10:22:59 <kw317> "the way type systems work today is, you can be productive, or you can be safe, but you can't have both"
10:23:11 <tensorpudding> what?
10:23:13 <ksf> kw317, it's not called go, it's called issue 9. the internet has decided.
10:23:13 <kw317> clearly that guy didn't use haskell ;-)
10:23:21 <Twey> Haha, aye.
10:23:23 <kw317> ksf: issue 9?
10:23:25 <kw317> LOL?!
10:23:27 <Twey> ksf: â€˜Issue 9â€™?
10:23:31 <kw317> that's a silly name
10:23:33 <Twey> Haha
10:23:45 <ksf> http://code.google.com/p/go/issues/detail?id=9
10:24:02 <ksf> that's issue 9. and issue 9 is quite related to plan 9, so you have it.
10:24:12 * kw317 is hoping that the speaker will elaborate on why you can't have both
10:24:14 <danderson> the peanut gallery has shweamed and shweamed and shweamed you mean :)
10:24:24 <kw317> hmm.. plan 9 is awesome
10:24:54 <ksf> what those guys really didn't seem to have noticed is that their interfaces are quite entirely equal to typeclasses.
10:24:54 <Twey> kw317: Yeah.  â˜º
10:24:58 <Twey> Haha.
10:25:10 <ksf> ...and they're calling it OO programming. "even more oop than java"
10:25:16 <chrisdone> haha
10:25:22 <chrisdone> impossible!
10:25:31 <kmc_> almost every type in go is nullable...
10:25:36 <Twey> Ych
10:25:38 <kw317> haha
10:25:46 <chrisdone> that's like saying "even more functional than Common Lisp"
10:25:56 <kmc_> haha
10:25:57 <ksf> kmc_, in haskell, _every_ type is nullable.
10:26:06 <kmc_> ksf, you mean _|_?
10:26:07 <ksf> or rather, _|_ is in every type.
10:26:09 <kmc_> hehe
10:26:17 <kmc_> that's fine though because you can't test for _|_
10:26:18 <kw317> well, it's not quite the same
10:26:21 <donri> even more assembly than C
10:27:09 <kw317> the compilation speed is quite nice though
10:27:32 <ksf> it's not only nice, it's utterly impressive.
10:27:56 <kmc_> i don't see compilation speed as a major issue
10:28:21 <kmc_> it sounds like the kind of thing you trot out when you don't have a lot of other features to stand on
10:28:24 <kmc_> do they have a REPL?
10:28:36 <ksf> kmc_, then you didn't work on big C projects, yet. even if you get make to track dependencies, you can get _huuuuge_ rebuilds.
10:28:48 <ksf> no repl as it seems.
10:29:03 <kmc_> ugh
10:29:21 <ksf> ...but repls are a dime a dozen, as long as you have shared objects and a compiler at hand.
10:29:28 <kw317> REPL?
10:29:36 <Twey> Read-Eval-Print Loop
10:29:39 <ksf> compile, link to .so, dlopen the so, call the function, there you go.
10:29:40 <kmc_> is there a good REPL for C or C++? Or Java?
10:29:40 <kw317> ah
10:29:40 <donri> hah their irc is #go-nuts
10:30:12 <kmc_> i think there's some misguided wisdom that REPLs are not useful in "compiled" or statically-typed languages
10:30:19 <Twey> Aye
10:31:07 <ksf> having a fast compiler also opens up a scripting-language like model.
10:31:21 <ksf> you can compile fast, and then maybe analyse at runtime and jit.
10:31:36 * kmc_ thinks that "scripting language" is a worse-than-useless term
10:31:41 <ksf> It's a really nice feature for system languages.
10:31:49 <ksf> haskell is a scripting language.
10:31:56 <ksf> #!/usr/bin/runhaskell works.
10:32:01 <ksf> that makes it a scripting language.
10:32:14 <kmc_> then C is a scripting language as well?
10:32:27 <Twey> Ch
10:32:40 <ksf> In principle, yes.
10:32:44 <chrisdone> I think a scripting language fundamentally supports text manipulation with the utmost convenience
10:32:52 <Maddas> kmc_: Not in the conventional sense, no.
10:32:55 <ksf> that's not true of bash.
10:33:02 <kw317> Ch allows you to use C as a scripting language
10:33:03 <kmc_> see this is why it's useless -- everyone has a different definition
10:33:07 <ksf> maybe of bash/sed
10:33:08 <kmc_> so does tcc
10:33:11 <chrisdone> ksf: but bash makes it really easy to use text manipulation programs
10:33:11 <Twey> Quite so
10:33:14 <ksf> or rather bash/ed
10:33:31 <vegai> chrisdone: a perl hacker might claim that python isn't a scripting language then...
10:33:34 <kmc_> can't you write a good text manipulation library for any language?
10:33:43 <chrisdone> vegai: seems fair to me
10:33:48 <vegai> ah :)
10:33:52 <kmc_> boost has some pretty good string manipulation for C++
10:33:53 <chrisdone> kmc_: well I said fundamentally
10:33:58 <ksf> perl is the prototypical modern scripting language, and it's been called that way because it's a bash/sed/grep/awk/whatever replacement.
10:34:17 <Maddas> The usefulness in talking about scripting languages is that it usually refers to a vague, loosely-defined group of languages. Just like when people talk about "functional" languages.
10:34:18 <ksf> conciseness also plays a great role.
10:34:18 <kmc_> "perl" and "modern" do not belong in the same sentence
10:34:26 <Maddas> kmc_: Perl 6?
10:34:28 <kmc_> haha
10:34:31 <tensorpudding> calling a language a scripting language implies that it's not good for anything besides quick hacks
10:34:45 <kmc_> Maddas, no, i'd define "functional language" by a fairly specific feature-set
10:34:50 <ksf> but it implies that simple things are simple.
10:34:52 <Maddas> kmc_: Yes, and other people would define it differently.
10:34:53 <kmc_> in particular one feature: first-class functions with closure over free variables
10:34:59 <kmc_> i think there's a lot more agreement there
10:35:08 <chrisdone> tensorpudding: I think that's probably most accurate
10:35:09 <Maddas> kmc_: The point is not whether you can think of a good definition -- many people can think of good ways to categorize 'scripting' languages, it's just that noone else agrees :-)
10:35:09 <ksf> kmc_, I think issue9 has those.
10:35:20 <kmc_> issue9 == go?
10:35:21 <ksf> at least lambdas. dunno about closures.
10:35:27 <kmc_> it has closure
10:35:33 <tensorpudding> but perl is able to be used for things besides scripts
10:35:40 <kw317> issue9 is a really silly name *sigh*
10:35:44 <kw317> go is much better imo
10:35:46 <ksf> so is brainfuck.
10:36:01 <Maddas> This discussion is pretty pointless.
10:36:06 <chrisdone> tensorpudding: did it start out that way?
10:36:07 <tensorpudding> go is a poor name for searching
10:36:35 <tromp_> now you can program go in go...
10:37:00 <donri> to me scripting perhaps wrongly is string programming. by that definition, ruby more than perl as ruby uses symbols for things like method references and whatnot.
10:37:07 <zygoloid> i... i don't believe it. 250 comments on 'go' issue 9, and not a single one suggesting renaming it to "go go gadget"
10:37:18 <chrisdone> tromp_: I herd you like board games
10:37:25 <kmc_> ugh
10:37:25 <kmc_> ugh
10:37:27 <tromp_> particularly go
10:37:37 <Maddas> zygoloid: I was leaning towards 'Go go power rangers' ^_-
10:38:21 <chrisdone> this game reminded me of Go http://www.gamedesign.jp/flash/chatnoir/chatnoir.html
10:38:42 <dolio> Wasn't TCL, like, the original scripting language? And it wasn't designed for handling text, it was for easily plugging into your program written in a heavy-weight language, as a simpler way for adding new, small routines built out of the primitives defined in the underlying language/application.
10:39:07 <ksf> oh. they should have specified a documentation format.
10:39:11 <ksf> hell even perl has one.
10:39:31 <kmc_> in go?
10:39:44 <ksf> but that's another interpretation of "scripting"
10:39:46 <ksf> kmc_, yes.
10:39:51 <kmc_> yeah, they got a lot of things wrong
10:39:57 <ksf> and lua is the best of _those_ scripting langs.
10:41:33 <tensorpudding> does anyone like tcl?
10:41:39 <tromp_> cute, chrisdone. it reminds me more of hex though
10:42:05 <dolio> No one.
10:42:16 <chrisdone> tromp_: is that a game?
10:42:29 <kmc_> "A [struct] field declared with a type but no field identifier is an anonymous field. Such a field type must be specified as a type name T or as a pointer to a type name *T, and T itself may not be a pointer type. The unqualified type name acts as the field identifier."
10:42:31 <byorgey> chrisdone: dammit, there goes my productivity.
10:42:45 <tromp_> sure is
10:42:56 <chrisdone> byorgey: :D
10:43:42 <ksf> for i, j := 0, len(a)-1; i < j; i, j = i+1, j-1 {
10:43:42 <ksf> 	a[i], a[j] = a[j], a[i]
10:43:44 <ksf> zomg
10:43:54 <ksf> that's so C it makes me whince
10:44:32 <tensorpudding> isn't go supposed to be much like C
10:45:01 <ksf> it certainly is a lot like c
10:45:16 <ksf> but a C with a gc
10:45:19 <kmc_> if i want static types with a fast complied implementation, and i'm okay with garbage collection, why would i not use haskell?
10:45:26 <ksf> and primitive managed coroutines
10:45:52 <dolio> So, something like "struct Foo { int, b : int }" is valid, and you refer to the first field like "Foo.int"?
10:46:10 <tensorpudding> because haskell is all functional and weird, i'd suppose
10:46:12 <chrisdone> byorgey: it's easy to tempt it into a corner to trap it ^_^
10:46:12 <Maddas> kmc_: There are design goals listed explicitly on the Go page.
10:46:32 <ksf> it's called issue9!
10:46:33 <byorgey> chrisdone: yes, I lost the first few games but now doing better =)
10:47:04 <Maddas> kmc_: In any case, asking in #haskell will likely yield predictable answers :-)
10:47:27 <ksf> you might shun haskell because you fear oleg.
10:47:48 <chrisdone> everyone fears Oleg
10:48:08 <ksf> It seems to me that intimidation is the last weapon we have left to avoid success.
10:51:32 <olivers> hello all. I am a c.s major, well was before I took up law .... 6 years ago. I have a month of vacation coming up. I was wondering if I could start looking at Haskell. I have never done any functional programming and most of my programming skills are lets say extinct. Assuming all this, can you suggest some books for me to start with haskell ? or better yet some videos ? or am i better off going with lisp and then heading to haskel ?
10:51:45 <tommd> ksf: That will be true until someone writes "Real World Monads, Monoids, and Functors"
10:52:32 <ksf> olivers,
10:52:33 <tommd> olivers: I know several people who learned Haskell as a first language.
10:52:34 <ksf> @where rwh
10:52:34 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
10:52:49 <ksf> yep. having forgot everything is a plus.
10:53:17 <kmc_> @where lyah
10:53:18 <lambdabot> www.learnyouahaskell.com
10:53:34 <olivers> ok this is very encouraging ...
10:53:36 <Cale> olivers: also, stick around and ask any questions you have while you're learning
10:53:43 <kmc_> and play with lambdabot
10:53:45 <kmc_> > 1 + 2
10:53:45 <lambdabot>   3
10:53:47 <tommd> olivers:  Books:
10:53:47 <tommd> "Real World Haskell"
10:53:47 <tommd> "The Craft of Functional Programming"
10:53:47 <tommd> "Haskell School Of Expression"
10:53:47 <tommd> and tutorials:
10:53:48 <tommd> "Learn you a Haskell"
10:53:50 <tommd> "Yet another Haskell Tutorial"
10:53:52 <olivers> I would like that ....
10:54:29 <kmc_> > fix (\xs -> 1 : 1 : (zipWith (+) xs $ tail xs))
10:54:30 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
10:54:34 <olivers> which one starts with an assumption that you don't know too much of anything ?
10:54:44 <byorgey> > map pred "ij!uifsf!pmjwfst"
10:54:46 <kmc_> RWH is free to read online
10:54:46 <lambdabot>   "hi there olivers"
10:54:51 <olivers> realworldhaskell ?
10:54:55 <kmc_> yes
10:55:03 <tommd> olivers: I started with Yet another Haskell Tutorial, but RWH is probably what you want these days.
10:55:10 <tommd> @where yaht
10:55:11 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
10:55:25 <byorgey> yeah, YAHT is getting to be a bit dated I think
10:55:30 <olivers> cool ... let me start with real world haskell then ...
10:55:35 <tommd> byorgey: So is H98, but it works.
10:55:43 <byorgey> tommd: touche =)
10:56:02 <olivers> and i would be using the GHC complier ? or is hugs98 a better starting point ?
10:56:08 <tommd> useghc
10:56:14 <tommd> use ghc
10:56:20 <byorgey> olivers: no, using GHC is generally better.
10:59:24 <whoppix> olivers: ghc has a usefull shell for evaluating expressions (ghci) and runghc, which is usefull if you want to do some fast "scripting". But I'm sure those basic tutorials mentioned above cover all that in greater depth.
10:59:38 <Vanadium> I have a bit of code where I parse a bunch of data and then I store it in a dozen tiny "<-" bindings until I have all of it and can call the one data constructor of my data type that has a dozen arguments. This is apparently ugly, is there are more elegant scheme to do this?
10:59:41 <chrisdone> tommd: <tommd> I know several people who learned Haskell as a first language. -- orly?
10:59:54 <Twey> Vanadium: liftM#
10:59:56 <chrisdone> tommd: did they breathe oxygen?
11:00:15 <Vanadium> I do ot think they have liftM12, and anyway, I kind of need to do other monadic actions like skipping inbetween :<
11:00:21 <olivers> cool tnx. all you have been very very helpful ... I am beginning on the rwh book :) this is exciting ....
11:00:32 <whoppix> olivers: enjoy :)
11:01:01 <byorgey> Vanadium: Constructor <$> action1 <*> action2 <*> action3 ...
11:01:08 <tommd> chrisdone: Yes.  They were mathematicians to start with.
11:01:24 <byorgey> Vanadium: import Control.Applicative, and make sure you have an Applicative instance for the monad in question
11:01:42 <Vanadium> m
11:01:43 <Vanadium> Hm
11:01:50 <Vanadium> I suppose I can store partially applied stuff too
11:01:58 <byorgey> Vanadium: ?
11:02:04 <chrisdone> tommd: interesting. what drew them to using a programming language?
11:02:31 <Vanadium> It is like getWord8; getWord8; skip98, more getWord8
11:02:34 <Vanadium> uh
11:03:10 <ddarius> There are several people who have learned/are learning Haskell as a first language for a variety of reasons.
11:04:16 <dcolish> at my school, the switched the intro data struct class from C++ to Haskell
11:04:21 <byorgey> Vanadium: that's a nice little poem you wrote there
11:04:41 <dolio> It might even be easier that way, since the student may not yet have learned to think in ways that don't work for Haskell.
11:05:03 <tensorpudding> data structures that work well in haskell don't work as well in other languages though
11:05:19 <byorgey> Vanadium: are you still confused?  I'm confused as to whether you're confused
11:05:28 <Vanadium> I guess this works
11:05:36 <dcolish> yup, but they're doing only the basics really
11:05:43 <Vanadium> Is there a way to mix something like replicateM 19 getWord8 into this whole <*> thing?
11:06:01 <byorgey> Vanadium: sure.  mix it in what way?
11:06:16 <byorgey> what should be done with the result of replicateM 19 getWord8 ?
11:06:18 <tensorpudding> though haskell makes data structures easier to reason about than C
11:06:38 <Vanadium> byorgey: Each of the 19 Word8s should be <*>'ed into the huge constructor call
11:06:55 <Vanadium> I am not sure I can fold that because the accumulator's type would change
11:07:47 <byorgey> Vanadium: oh, I see what you mean.  hmm.  yeah, there's not really a way to avoid writing 'getWord8' 19 times that I can see
11:07:57 <Vanadium> Okay
11:08:12 <byorgey> but at least you don't have to give the result of each call to getWord8 a different name.
11:08:26 <Vanadium> I suppose so
11:11:13 <ksf> Vanadium, foldr (<*>) (replicate 19 getWord8)
11:11:57 <mauke> that looks like a type error
11:12:02 <Vanadium> :t  foldr (<*>) (replicate 19 getWord8)
11:12:06 <Vanadium> err, @type?
11:12:09 <ksf> er yes, the identity element is missing.
11:12:12 <Vanadium> I swear this used to work.
11:12:18 <ksf> @bot
11:12:18 <lunabot>  :o
11:12:35 <ksf> , [$ty| foldr (<*>) (replicate 19 getWord8)]
11:12:37 <lunabot>  luna: lexical error in string/character literal at end of input
11:12:51 <ksf> well now if I knew how to speak lunabot...
11:13:49 <Vanadium> What is that?
11:16:13 <dolio> , [$ty| foldr (<*>) (replicate 19 getWord8) |]
11:16:16 <lunabot>  luna: Exception when trying to run compile-time code:
11:16:31 <ksf> err yes. that won't work.
11:17:05 <ksf> ...but that's due to getWord8 not being <*>able, not foldr not working.
11:17:21 <mauke> foldr takes three arguments
11:17:30 <ksf> yep.
11:17:45 <ksf> still, doesn't matter, getWord8 <*> getWord8 won't work.
11:18:13 <dancor> has anyone gotten wxhaskell to build on debian
11:18:15 <ksf> ...and I've got to watch stargate now.
11:18:21 <dancor> i get wxc/src/extra.cpp:1522: error: â€˜class wxStringâ€™ has no member named â€˜utf8_strâ€™
11:18:29 <dancor> this is also the build failure listed on hackage
11:20:09 <tensorpudding> hmm, are we on the boring side of the netsplit...
11:22:25 <kmc_> what does lunabot use for eval / typechecking?
11:23:11 <dolio> luna
11:23:26 <mauke> hax
11:23:36 <tensorpudding> lambdabot?
11:23:41 <fxr> I'm trying to make a cabal package which builds two hello examples each depends on a different version of happstack-server. I think there is a probem with build-depends. http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=12055#a12057
11:23:47 <tensorpudding> is gone
11:24:24 <mauke> probably lost in the netsplit
11:24:34 <tensorpudding> yes, i figure as much
11:24:54 <dcoutts> fxr: ah, the problem is that cabal expects the versions to be the same
11:26:45 <fxr> dcoutts: should I fill a bug report?
11:27:30 <dcoutts> fxr: well, it's not really a bug, it's a design feature
11:27:37 <sinelaw> conal, your paper on denotation design is citing itself.
11:27:52 <dcoutts> fxr: what is missing is a feature to explicitly allow multiple versions of a single dependency
11:28:13 <monochrom> In the same way a denotational domain is defined using itself. XD
11:28:21 <dcoutts> fxr: since in most cases you do want them to be the same version
11:28:25 <conal> sinelaw: oops!  will check it out.  thanks!
11:28:35 <dcoutts> fxr: so yes, file a feature request
11:29:06 <dcoutts> fxr: and explain your use case in the ticket, eg giving that example fragment of your .cabal file
11:29:34 <fxr> dcoutts: thanks
11:30:52 <sinelaw> conal, sure, and also page 3 first paragraph possibly missing period in "deeply Benefits"
11:31:18 <conal> sinelaw: terrific.  thx again.
11:32:21 <DrSyzygy> Hah.
11:32:26 <DrSyzygy> Lecture up for MATH198.
11:33:11 <DrSyzygy> Next week? Coalgebras and the ana/cata/hylo/zygo/para/apo/meta/prius/-morphisms family.
11:33:25 <sinelaw> prius?
11:33:34 <DrSyzygy> Just checking who's awake. :-)
11:34:00 <DrSyzygy> And I meant to write zoo, not family. Just goes to show _I_ am not yet awake.
11:35:10 <kmc_> @bot
11:35:10 <lunabot>  :o
11:35:14 <monochrom> :)
11:37:26 <sinelaw> conal, and one technical question. shouldn't [[ Map k v ]] = [[k]] -> Maybe [[v]] ? in the paper you don't use the semantic function on the rhs in this case.
11:38:35 <NEEDMOAR> DrSyzygy: what's MATH198?
11:39:20 <conal> sinelaw: i've considered that style.
11:40:09 <sinelaw> conal, for example if 'k' or 'v' are also Map types,
11:40:20 <sinelaw> it's a technicality that slightly clutters the reading
11:40:30 <DrSyzygy> NEEDMOAR: My category theory course, published lecture by lecture on the haskell wiki.
11:40:38 <DrSyzygy> http://haskell.org/haskellwiki/User:Michiexile/MATH198
11:40:46 <conal> sinelaw: they could be anything, and i need a consistent definition.
11:40:51 <NEEDMOAR> DrSyzygy: thanks.
11:42:02 <conal> sinelaw: my current leaning is to give just this one level of interpretation at a time.  i might change my mind.
11:42:34 <sinelaw> ok
11:43:17 <conal> sinelaw: maybe more experience will tell.  please keep that question in mind as you read, and let me know if you have any more insights.  i'm really not sure about my current choice.
11:44:40 <sinelaw> conal, sure. for now it just seems more correct, and it's how denotational semantics are defined (recursively over sub-structures)
11:45:37 <conal> sinelaw: yeah.  that inconsistency troubles me as well.
11:46:40 <conal> sinelaw: and right now i don't remember how i persuaded myself not to recursively interpret types.
11:47:29 <conal> sinelaw: maybe i didn't want to get stuck with having to have only a single interpretation per type.
11:49:07 <sinelaw> conal, that does make sense. You can say that the recursive invocation is there to express the fact that to really interpret the semantic meaning, you have to interpret all of it
11:49:38 <sinelaw> so maybe you can choose between different meanings, but you have to pick one.
11:51:47 <zygoloid> Vanadium: there's an evil typeclass hack you can use to get something like: "foldr (<*>) ((,,,,,) <$>) (repeat 6 foo)" working (basically the printf tric)
11:52:56 <tensorpudding> lambdabot back?
11:52:58 <kmc_> @bot
11:52:59 <lunabot>  :o
11:52:59 <lambdabot> :)
11:53:06 <conal> sinelaw: yeah.  i'm hesitant to go from talking about "a" meaning to "the" meaning.
11:53:33 <conal> sinelaw: even if i use "the" meaning informally.
11:57:33 <aleator> Jos joku viel miettii tuon `on` operaattorin saloja
11:58:22 <pumpkin> would it make sense to say algebraic datatypes form a semiring?
11:58:47 <iaefai_> @hoogle liftM
11:58:48 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
11:58:49 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:58:49 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
11:59:47 <Gracenotes> pumpkin: with sum and product?
11:59:51 <pumpkin> yeah
11:59:56 <pumpkin> pretty sure all the laws work out
12:00:09 <pumpkin> (except in haskell, since it doesn't have an empty type)
12:00:28 <Gracenotes> besides empty data decls.. which is sort of messy though
12:00:42 <pumpkin> even that isn't empty
12:00:45 <Gracenotes> and even those can be _|_
12:00:49 <pumpkin> yeah
12:00:56 <zygoloid> pumpkin: bottoms getting you down? try new bottoms-be-gone, with guaranteed totality!
12:00:59 <pumpkin> lol
12:01:31 <zygoloid> [fine print: bottoms-be-gone is not guaranteed to terminate. your codata is at risk if you do not keep up corecursion or other loops secured on it]
12:01:34 <sinelaw> am i wrong or is that a popular argument nowadays?
12:01:53 <sinelaw> (without fine print)
12:02:23 <Gracenotes> lemme see.  I suppose you could say that data MyData = Con A (Either B C) == data MyData = ConB A B | ConC A C
12:02:24 <zygoloid> if we believe hofstadter, meaning is imbued by the existence of isomorphisms to other structures
12:02:45 <Gracenotes> sum and product aren't exactly binary, though
12:02:47 <kmc_> , ppDoc [| \x -> x+1 |]
12:02:52 <Gracenotes> at least not in Haskell
12:02:56 <kmc_> @bot
12:02:56 <dolio> newtype Empty = Empty Empty is empty.
12:02:56 <lambdabot> :)
12:03:00 <monochrom> :)
12:03:05 <dolio> As empty as you get in Haskell, at least.
12:03:05 <kmc_> monochrom, you're not a bot ;P
12:03:15 <monochrom> syntax error
12:03:19 <Gracenotes> dolio: you can get a constructor out of it
12:03:28 <sinelaw> monochrom, seen monochrom?
12:03:37 <monochrom> syntax error
12:03:40 <Gracenotes> well, actually, newtypes are strict.. so you can't
12:03:55 <dolio> I can get a _ out of "data Void".
12:03:55 <Gracenotes> iirc
12:04:07 <sinelaw> preflex, seen preflex?
12:04:08 <preflex>  Sorry, I haven't seen preflex?
12:04:11 <sinelaw> preflex, seen preflex
12:04:11 <preflex>  what
12:04:35 <kmc_> are you really allowed to make recursive newtypes like that?
12:04:46 <dolio> Yes.
12:04:49 <sinelaw> why is that allowed?
12:05:03 <dolio> newtype Fix f = In (f (Fix f))
12:05:34 <Gracenotes> that has some values, right, if f isn't strict
12:05:43 <jmcejuela> I guess this is totally imperative, but how can I do something like the following?
12:05:45 <jmcejuela> bar s n | (s == n) = print "lastly"
12:05:46 <jmcejuela>         | otherwise = do (print s)
12:05:46 <jmcejuela>                          bar (s+1) n
12:06:01 <kmc_> jmcejuela, Haskell is a great imperative language :)
12:06:13 <dpratt71> does Haskell have something approximating the "Units of Measure" feature of F#? If not, how close could one get to that feature?
12:06:26 <sinelaw> dpratt71, what is that?
12:06:28 <jmcejuela> that is, how can I print the state of a variable while recursing?
12:06:33 <jmcejuela> :S
12:06:36 <Gracenotes> if f is, for example, Stream s = Stream s (Stream s)..
12:06:40 <kmc_> dpratt71, newtype USD = USD Float deriving (Eq, Ord, Num, Fractional, Floating)
12:06:49 * kmc_ doesn't know what "Units of Measure" are
12:07:00 <Gracenotes> dpratt71: there is a units library. it has some confusing typeclass hackery, though :/
12:07:20 <dpratt71> sinelaw: values can have an associated "unit" that is type checked
12:07:22 <Gracenotes> however, the code produced by it looks nice, and works nicely
12:07:30 <monochrom> jmcejuela: Control.Mond.forM_ [s..n] print >> print "lastly"
12:07:32 <Gracenotes> but nothing as built-in as F#'s
12:07:47 <Gracenotes> by merit of, uh, not being built-in :)
12:08:02 <sinelaw> Gracenotes, that doesn't sound like a bad thing
12:08:10 <Gracenotes> http://hackage.haskell.org/package/Measure-0.0.2
12:08:12 <sinelaw> for haskell imean
12:08:46 <Gracenotes> actually, I think there was another one with units of volume, mass, etc.
12:09:24 <bsod> in haskell is it possible to pass a function to itself as an argument?
12:09:44 <waern> bsod: yes
12:09:53 <Botje> if the type checker is happy with it.
12:09:57 <bsod> how can i do this
12:09:57 <sinelaw> bsod, no luck trying to get a bsod out of that
12:10:01 <Gracenotes> oh, this is the one I'm thinking about: http://hackage.haskell.org/package/dimensional-0.8 .. and numeric prelude has it too
12:10:03 <kmc_> bsod, sort of
12:10:05 <dpratt71> also, as an example, if you multiply a meters-per-second value times a seconds value, you get back a meters value
12:10:06 <waern> bsod: map (map f) xs
12:10:08 <kmc_> :t id id
12:10:09 <lambdabot> forall a. a -> a
12:10:17 <bsod> f f
12:10:17 <kmc_> waern, that's not the same function
12:10:26 <dpratt71> in F# it goes quite deep
12:10:27 <poe> > fix const
12:10:29 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> a
12:10:33 <kmc_> "f f" won't typecheck unless f is polymorphic, in which case it's being used at two different monomorphic types
12:10:37 <kmc_> like "id id" above
12:10:37 <poe> missed one argument
12:10:44 <waern> kmc_: doh, you're right
12:10:46 <pumpkin> so do algebraic datatypes form semirings with (+), (*), 0, and 1?
12:10:46 <monochrom> :id id 5
12:10:50 <monochrom> > id id 5
12:10:52 <lambdabot>   5
12:10:54 <tensorpudding> :t id id id
12:10:54 <poe> > fix (const 1)
12:10:55 <monochrom> works
12:10:55 <lambdabot> forall a. a -> a
12:10:56 <lambdabot>   1
12:11:01 <Gracenotes> whoa noise
12:11:04 <monochrom> > id id
12:11:06 <lambdabot>   {()->()}
12:11:08 <monochrom> works too :)
12:11:11 <Gracenotes> pumpkin: main problem is that + and * aren't binary
12:11:16 <pumpkin> Gracenotes: sure they are
12:11:24 <kmc_> bsod, if f has type A -> B, then it expects an argument of type A.  if you want to pass f as the argument, you get the recursive equation on types A = A -> B, which gives an "infinite type"
12:11:27 <tensorpudding> > fix id
12:11:28 <bsod> how do i declare function type?
12:11:31 <lambdabot>   mueval-core: Time limit exceeded
12:11:42 <Gracenotes> they are n-ary. unless you limit yourself to a subset of Haskell data declarations
12:11:48 <kmc_> bsod, what are you actually trying to do?
12:12:08 <pumpkin> Gracenotes: not talking about haskell :) just because I can write sum [1,2,3] doesn't mean it isn't effectively (1 + (2 + 3))
12:12:35 <kmc_> heh, if you have "newtype E = E E" you can use GeneralizedNewtypeDeriving to derive any class for E :)
12:12:42 <monochrom> haha
12:12:51 <pumpkin> kmc_: nice!
12:12:54 <Gracenotes> oh, I see. binary by definition. and you can also ensure associativity, if you have a need to transform n-ary to binary
12:12:59 <dolio> That sounds bad.
12:13:02 <pumpkin> yep
12:13:04 <kmc_> and the instances will work correctly for every value of that type!
12:13:29 <bsod> im trying to see whether in haskell you can pass a function to itself as an argument
12:13:37 <bsod> f f
12:13:38 <dolio> a + 0 /= a in Haskell.
12:13:44 <monochrom> :type id
12:13:48 <monochrom> Darn this.
12:13:52 <pumpkin> yeah, I'm ignoring bottoms/not talking about haskell
12:13:52 <monochrom> @type id
12:13:53 <lambdabot> forall a. a -> a
12:13:55 <dolio> Nor does a * 1 = 1.
12:14:04 <dolio> And a * 0 /= 0.
12:14:05 <monochrom> @src id
12:14:06 <lambdabot> id x = x
12:14:08 <pumpkin> just the idea of ADTs in general
12:14:19 <dolio> So you need to remove the bottoms for it to work.
12:14:25 <pumpkin> yep
12:14:32 <monochrom> So you write "f :: a->a" on one line, and "f x = x" on the second line. Then you can use f f.
12:14:35 <tensorpudding> :t fst fst
12:14:36 <lambdabot>     Couldn't match expected type `(a, b)'
12:14:36 <lambdabot>            against inferred type `(a1, b1) -> a1'
12:14:36 <lambdabot>     In the first argument of `fst', namely `fst'
12:14:38 <Gracenotes> bsod: only for polymorphic functions. in order words, in "f f", the first one has a slightly different type from the second. But botha re the same
12:14:50 <kmc_> :t id
12:14:51 <lambdabot> forall a. a -> a
12:15:02 <kmc_> :t let f = id; g = id in (f, g, f g)
12:15:04 <lambdabot> forall a a1 a2. (a -> a, a1 -> a1, a2 -> a2)
12:15:06 <Gracenotes> wow, lots of types. other words, both are, etc.
12:15:10 <Gracenotes> *typos >:[
12:15:21 <monochrom> types are typos
12:15:22 <tensorpudding> fst $ fst $ ((1,2),3)
12:15:27 <tensorpudding> > fst $ fst $ ((1,2),3)
12:15:28 <lambdabot>   1
12:15:38 <dolio> A * Void = A, though.
12:15:43 <dolio> In Haskell.
12:15:55 <pumpkin> A * !Void = Void
12:15:58 <dolio> Or, is isomorphic to...
12:16:33 <bsod> can someone send me an example i can try out on haskell
12:16:35 <pumpkin> actually, is that even true?
12:16:49 <monochrom> I just did. <monochrom> So you write "f :: a->a" on one line, and "f x = x" on the second line. Then you can use f f.
12:17:08 <monochrom> Why is reading so hard?
12:17:19 <bsod> sorry missed that
12:17:23 <pumpkin> let's go shopping!
12:17:44 <monochrom> I hate people who are too busy asking their questions to read answers.
12:18:02 <copumpkin> bring on the hate!
12:18:29 <bsod> easy
12:18:35 <dolio> We don't take kindly to those who don't take kindly, around here.
12:18:51 <Gracenotes> or, for example "map map" is valid. there was a discussion about that on the mailing list.. uh.. some time ago or something
12:19:53 <monochrom> > map map [id, id, id] [0, 0, 0]
12:19:55 <lambdabot>   Couldn't match expected type `[t1] -> t'
12:19:55 <lambdabot>         against inferred type `[[a...
12:20:09 <Gracenotes> > map map [length . show, (+1)] <*> [[1,10],[100,1000]]
12:20:10 <monochrom> Oh, it is harder.
12:20:11 <lambdabot>   [[1,2],[3,4],[2,11],[101,1001]]
12:21:21 <Gracenotes> map map yields a list of functions, each of which maps a list of items according to the function handed to it
12:21:54 <Gracenotes> perhaps simpler..
12:21:57 <Gracenotes> > zipWith ($) (map map [length . show, (+1)]) [[1,10],[100,1000]]
12:21:58 <lambdabot>   [[1,2],[101,1001]]
12:22:43 <Gracenotes> totally useless, of course
12:22:57 <monochrom> > map ($ 0) (map map [id,id])
12:22:58 <lambdabot>   No instance for (GHC.Num.Num [a])
12:22:59 <lambdabot>    arising from the literal `0' at <inter...
12:25:34 <Vanadium> If printf can do varargs with crazy typeclass hacks, I should be able to avoid repeating "<*> getWord8" n times instead of doing something crazy with replicateM :|
12:25:35 <sinelaw> newtypes are isomorphic to the type? I mean is newtype NewT = NewCons T isomorphic to T?
12:25:44 <sinelaw> what happens with bottom
12:26:04 <Vanadium> i cannot seem to find myself content with http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12056#a12056
12:26:06 <zygoloid> sinelaw: there is no value _|_ in the type
12:26:14 <monochrom> NewT is isomorphic to T. NewT has as many bottom as T does.
12:26:26 <noteventime> Aren't Go's interfaces basically like Haskell 98's type classes?
12:26:27 <zygoloid> sinelaw: there is a NewCons _|_ if T has a _|_
12:26:29 <Gracenotes> newtypes are strict
12:26:36 <Gracenotes> > Identity undefined `seq` ()
12:26:37 <lambdabot>   * Exception: Prelude.undefined
12:26:40 <Gracenotes> > Left undefined `seq` ()
12:26:41 <lambdabot>   ()
12:26:48 <sinelaw> ok, but on the other hand NewT can derive type classes differently
12:26:54 <zygoloid> noteventime: no, they seem to be more like c++'s abortive attempts at implicit concepts
12:26:55 <Vanadium> noteventime: They seem to be a runtime thing without explicit instance declarations?
12:26:57 <Gracenotes> yeah
12:27:11 <stroan> dancor: are you using the wxWidgets for the debian repos?
12:27:13 <Gracenotes> noteventime: people have compared them, yeah
12:27:14 <stroan> from*
12:27:18 <sinelaw> so it's not really a "typedef"
12:27:29 <noteventime> I just saw some presentation of them
12:27:34 <dolio> Every type has a value _|_. In the case of a newtype, it's the same value as 'C _|_' for the constructor C.
12:27:37 <noteventime> Haven't seen any details yet
12:27:37 <Gracenotes> noteventime: they seem to be derived automatically.. like duck typeclasses :)
12:28:07 <noteventime> Hopefully it's at least a step in the right direction
12:28:13 <Gracenotes> and of course, without any kind of parametric polymorphism
12:28:16 <PeakerWork> does Go have all pointers/references as nullable ones?
12:28:51 <zygoloid> why is go getting so much attention? just because google's behind it?
12:29:01 <zygoloid> s/go/issue 9/
12:29:06 <dolio> Do you remember when Arc was released?
12:29:06 <Gracenotes> from specification: "A pointer type denotes the set of all pointers to variables of a given type, called the base type of the pointer. A pointer value may be nil."
12:29:08 <JohnnyL> why are you even talking about go?
12:29:43 <PeakerWork> Gracenotes: :-(
12:29:46 <PeakerWork> Gracenotes: So they repeat age-old mistakes
12:30:02 <Gracenotes> "An interface value may be nil." "A map value may be nil." "A value of channel type may be nil." "A slice value may be nil." "A function value may be nil."
12:30:02 <PeakerWork> zygoloid: Yeah, Google usually creates nice things
12:30:12 <JohnnyL> Neo and Agent Smith were Isomorphic.
12:30:20 <vegai> zygoloid: and/or because Ken Thompson's and Rob Pike's names are attached to it? :)
12:30:24 <JohnnyL> ;)
12:30:25 <Gracenotes> don't you mean Mr. Anderson? :x
12:30:32 <Gracenotes> Neo and Agent Smith were duals
12:30:35 <Vanadium> Coneo
12:30:37 <Vanadium> Yeah
12:30:50 <Gracenotes> :P
12:31:02 <noteventime> Conio?
12:31:17 <Gracenotes> PeakerWork: Maybe/Nothing isn't the most efficient at times.. given that you use whole word in all cases just saying if there's a value or not
12:31:38 <PeakerWork> Gracenotes: I'd expect a compiler to optimize ptr to (Maybe a) to be a ptr to a with null option
12:31:56 <PeakerWork> Gracenotes: sort of "data structure inlining"
12:32:01 <Gracenotes> well, it is a pointer, not just a reference. The thing the designers cut out was pointer arithmetic.
12:32:09 <zygoloid> vegai: have either of them previously designed a successful language?
12:32:18 <vegai> zygoloid: are you kidding me?
12:32:33 <PeakerWork> Gracenotes: I see the main differences between ptr and reference as: Ptrs are usually not GC'd. Ptrs are themselves objects. It doesn't necessarily mean Ptrs should be nullable
12:33:07 <dolio> B?
12:33:23 <vegai> well, yeah. I guess Thompson didn't invent C really
12:33:38 <jlouis> Perhaps that Issue9/Go thing will take off. It fits almost "perfectly" into the mass-thought-process
12:34:10 <jlouis> and yes, Not Null should be the default. As should immutability
12:34:25 <Gracenotes> it's not a functional language :P
12:35:13 <Gracenotes> still..
12:35:22 <pikhq> Gracenotes: It's pretty much C without a lot of suckage.
12:35:45 <monochrom> I have found that null pointer is seldom used. It is more efficient to assume pointers are non-null. In rare cases when you need null, using Maybe is not inefficient because they are rare cases.
12:35:58 <sinelaw> if they add algebraic datatypes, that would be nice.
12:36:06 <sinelaw> but i suspect the didn't
12:36:19 <copumpkin> there are plans for it I think
12:36:35 <dolio> Cyclone isn't a functional language, but they track nullable vs. non-nullable pointers.
12:37:28 <PeakerWork> monochrom: I don't see why a compiler can't optimize ptr to Maybe to a nullable ptr
12:38:04 <PeakerWork> basically, a pointer has a bunch of special values (0 isn't the only one) and it can be used to denote a bunch of nullary constructors, if you have immutability
12:38:16 <PeakerWork> I guess if you have a mutable Maybe, you can't optimize ptr to Maybe to nullable ptr
12:38:28 <PeakerWork> mutability - the programming language destroyer
12:38:44 <Gracenotes> why two transformations? why not just Maybe -> ptr with any range of word values?
12:38:46 <sinelaw> PeakerWork, heh, it makes the language itself mutable, yes :)
12:38:51 <Twey> Nice isn't a functional language, but they track nullable vs. non-nullable pointers.
12:38:56 <monochrom> In fact you probably don't use Maybe anyway. You use Either or some error monad. The argument "Maybe is memory-inefficient" is moot because you don't actually just say Nothing, you actually have something interesting in place of Nothing and so you do use that memory for real.
12:39:29 <kmc_> "jlouis Perhaps that Issue9/Go thing will take off. It fits almost "perfectly" into the mass-thought-process" ?
12:39:37 <Twey> (Semi-)decent type systems and value-orientation tend to coÃ¯ncide, but the latter is not a prerequisite for the former.  ;)
12:39:43 <Gracenotes> monochrom: that would be nice, but (as it's been complained about) there are no union types
12:39:48 <ddarius> â€œIn a way, I've been programming Haskell for so many years, that I'd forgotten just how devastating side effects are and just how difficult they make debugging.â€ â€“ John Hughes
12:39:59 <kmc_> Gracenotes, it's a functional language by my narrow definition
12:40:02 <Gracenotes> well, true union types. maybe it's possible to get tagged union somehow
12:40:04 <monochrom> GHC uses "pointer tagging" or something to optimize Maybe's memory usage.
12:40:08 <kmc_> it has function values and closures over free variables
12:40:18 <Twey> I'm pretty sure Nice doesn't
12:40:22 <copumpkin> omg
12:40:26 <copumpkin> coÃ¯ncide
12:40:32 <kmc_> haha
12:40:37 <monochrom> (Of course it optimizes all sum types.)
12:40:40 <copumpkin> Twey: is that even correct there? :o
12:40:48 <sinelaw> copumpkin, i thought that was by purpose
12:40:55 <copumpkin> I know it is for things like coordinate
12:40:56 <Twey> copumpkin: Coincide is a substance that kills money.  ;)
12:41:02 <copumpkin> lol
12:41:03 <Gracenotes> anyhow, I shall brb
12:41:04 <Twey> copumpkin: (insert name of product here)
12:41:11 <Twey> copumpkin: Yes, it's perfectly correct.
12:41:21 <dolio> Well, there was only one Nothing in the entire program even prior to pointer tagging.
12:42:33 <pgs31> Good evening gentlefolk
12:42:43 <monochrom> hahahaha
12:42:54 <monochrom> You want to write "f f" in haskell, don't you?
12:43:07 <pgs31> I'm trying to make an interactive app which compiles haskell on the fly
12:43:18 <pgs31> Any pointers?
12:43:22 <ksf> the ghci source
12:43:27 <Vanadium> NULL
12:43:29 <pgs31> It must be possible if ghci and lambdabot do it :)
12:43:30 <copumpkin> Twey: I see, yeah
12:43:37 <ksf> there's also higher-level plugin interfaces.
12:43:47 <sinelaw> pgs31, look at how Yi does it
12:43:49 <pgs31> ksf: I've had a bit of a dig around, it seems to be very closely knit into ghc itself
12:43:49 <ksf> then there's the yi source.
12:43:49 <ddarius> system "ghc foo.hs"
12:43:58 <pgs31> ooh
12:44:05 <ksf> lambdabot doesn't compile on the fly, it loads .so's.
12:44:11 <pgs31> ahh okay
12:44:18 <ksf> ghci _should_ use libghc, which is the whole compiler as a library.
12:44:21 <sinelaw> i'm pretty sure Yi does it
12:44:28 <ksf> ...a highly volatile one, mind you.
12:44:35 <pgs31> Excellent; I don't know what Yi is but I will soon find out
12:44:43 * ddarius tests the vapor pressure of libghc.
12:44:46 <ksf> an editor, extensible in haskell.
12:44:58 <pgs31> ahh excellent
12:45:10 <pgs31> I can't see libghc on hackage
12:45:19 <ksf> ...but they also offer to compile everything and leave out run-time compiling, as libghc can be a true pita.
12:45:23 <pgs31> Is that the right place to look for docs (if there are any?)
12:45:24 <ksf> pgs31, it comes with ghc.
12:45:29 <ksf> actually, it _is_ ghc.
12:45:32 <pgs31> :)
12:45:50 <pgs31> okey dokey
12:45:55 <ksf> http://www.haskell.org/haskellwiki/GHC/As_a_library
12:46:07 <pgs31> That is exactly the sort of thing I was after
12:46:23 <pgs31> I knew it must exist - I've been digging around in the wiki for a while looking for it
12:46:28 <phaer> Hi, i'm trying to install haskell platform-2009.2.0.2 on ubuntu karmic and i get exactly the same errors as the person who posted http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=3128
12:46:34 <phaer> any suggestions?
12:46:42 <pgs31> Thanks ever so much
12:47:11 <ksf> you most likely want to look at the existing sources that use it though, as it comes with virtually no documentation.
12:48:02 --- mode: ChanServ set +o mauke
12:48:02 --- mode: mauke set +vvv lambdabot preflex hackagebot
12:49:02 --- mode: mauke set -o mauke
12:49:38 <pgs31> Roger wiko
12:49:51 <kmc_> pgs31, did you see "hint"?
12:49:58 <kmc_> hint is a nice simple wrapper to the ghc api
12:50:39 <kmc_> ksf, you're connected by IPv6??
12:51:24 <ksf> IPv6-in-IPv4.
12:52:18 <ksf> no measurable additional latency or bandwidth loss, the gateway is directy at the backbone of my isp's isp.
12:53:05 <pgs31> kmc_ hint?
12:53:06 <ksf> you can even calculate my ipv4 adress from my v6 one, the tunneled ones all start with 2002:
12:53:31 <ksf> it definitely helps to filter out dcc requests.
12:56:12 <ksf> ...all I did was add ' link_sit0="ppp0"\nconfig_sit0=( "ip6to4" )\ndepend_sit0() {\n    need net.ppp0\n} ' to /etc/conf.d/net, ln -s /etc/init.d/net.sit0 /etc/init.d/net.lo, rc-config add net.sit0 default
12:56:52 <KEBA> which editor/ide do you use under linux?
12:56:57 <ksf> vi!
12:57:12 <KEBA> s/which/which graphical/
12:57:19 <ksf> gvim.
12:57:38 <KEBA> -.-
12:58:18 <ksf> if you're looking for a full-fledged ide, have a look at leksah, an there's a plugin for eclipse, too.
12:58:27 <KEBA> ksf: thx
12:58:40 <ksf> but most hackers stick to vi or (heaven forbid) emacs in the same way ken thompson sticks to ed.
12:58:55 <monochrom> I use emacs, and heaven doesn't forbid.
12:59:15 <sinelaw> conal, in your paper section 5.1 (Monoid) you go from: "[[0]] = \k -> 0" to "[[0]] = 0", i don't understand how
12:59:16 <phaer> really vi? why not vim?
12:59:25 <monochrom> But it is unlike ken thompson sticking to ed because I use vim too.
12:59:28 <SubStack> I should learn ed
12:59:39 <sinelaw> conal, the same thing you do with [[ma <> mb]] but there it's just eta reduction
12:59:41 <ksf> well it's a ejaculatory prayer.
12:59:49 <monochrom> Later I will write a plug-in for eclipse so I can use eclipse the way I want.
12:59:52 <SubStack> then I could use the teletypes around campus to have a shell to my desktop over the phone
13:00:02 <ksf> I actually _do_ use vim.
13:00:24 <sinelaw> KEBA, emacs
13:00:31 <ksf> ...but I wouldn't be lost in a traditional vi, either, I rarely use such things as cursor keys.
13:00:36 <SubStack> should also learn yi just for kicks
13:00:58 <pgs31> Yi won't cabal-install for me..
13:00:58 <SubStack> learning new things is pretty great
13:01:00 <jasonmay> yi also does a pure haskell config?
13:01:11 <dancor> i want to use yi but i fear i will miss too many things and have to confront the fact that i'm not good enough to recreate them
13:01:13 <ksf> as soon as yi's cursor moves faster than snail-speed.
13:01:13 <sinelaw> pgs31, you need to get from darcs, that one works.
13:01:20 <pgs31> Ahh
13:01:24 <pgs31> Will do
13:01:48 <pgs31> The one from cabal is complaining about 'Category Accessor.T' being defined in multiple places
13:01:53 <ksf> open a file in yi, use the mouse wheel to move the cursor up and down, fast. you're going to see it interpret the buffer for a few seconds. try the same in vim, it's instantaneous.
13:02:00 <dancor> anyway i need to start using haskell for my shell first ;)
13:04:08 <sinelaw> ksf, what's the reason?
13:04:10 <dancor> the yi cursor seems fast enough for me
13:04:20 <ksf> I've got no idea.
13:04:20 <mmorrow> 16686 m         20   0 3568m 3.0g  10m R 97.7 78.3   1:39.26 ghc
13:04:21 <mmorrow> :o
13:04:30 <mmorrow> (3.0g)
13:04:44 <mmorrow> (resident)
13:04:48 <copumpkin> oh my
13:04:51 <ksf> dancor, as I said, use the mousewheel and you'll see a huge difference.
13:04:58 <copumpkin> mmorrow: what's it doing?
13:04:58 <dancor> ksf: i don't use the mouse
13:05:00 <ksf> keyboard repeat is usually too slow.
13:05:14 <mmorrow> it's compiling a file with a huge static map in it with -O0
13:05:20 <ksf> well I sometimes use it to scroll through large amounts of text.
13:05:20 <dancor> also i'm in a terminal and it would just scroll the terminal history
13:05:32 <copumpkin> mmorrow: ah :/ for your bytecode backend?
13:05:36 <sinelaw> mmorrow, i've tried that before and failed
13:05:44 <copumpkin> huge static data is a real pain :/
13:05:46 <mmorrow> (been using -O0 for fast recomp.., but re-added this module to the .cabal)
13:05:48 <ksf> well... konsole translates the mousewheel into cursor up/down
13:05:50 <sinelaw> mmorrow, ended up using Binary to load the map
13:06:10 <mmorrow> gah, i'm swapping so bad right now
13:06:16 <dancor> my buffer moves in jumps anyway
13:06:28 <sinelaw> mmorrow, i'm guessing we won't see any more messages from you shortly
13:06:34 <sinelaw> :P
13:06:34 <mmorrow> i forgot i even had this data in this module, it's non-essential really
13:06:46 <mmorrow>  melllllllttting
13:07:13 <ksf> eeek. introducing a data file would be evil, too.
13:07:31 <mmorrow> oh man, just killed it
13:07:38 <sinelaw> ksf, evil that works, as opposed to static data which doesn't.
13:07:39 <kmc_> pgs31, http://hackage.haskell.org/package/hint
13:07:39 <mmorrow> -O0 and lots of data don't mix
13:07:57 <pgs31> kmc_: ooh, shiny
13:07:58 <ksf> you could serialize it to a binary, convert it to a C array, link to the .o and use the ffi
13:08:15 <copumpkin> mmorrow: you should use your 3v1l s3r14l1z3r
13:08:32 <copumpkin> whoa, the bots got voice!
13:08:47 <bacelar> hi, anyone know how to get hugs compiled on mac's 10.6?
13:09:01 <copumpkin> nope, but people don't use hugs anymore
13:09:03 <ksf> it doesn't compile?
13:09:04 <pgs31> kmc_: I was just getting the fear looking at all the functions defined in GHC.*
13:09:07 <mmorrow> zmog c3r34l
13:09:10 <ksf> it even compiled out-of the box on haiku.
13:09:14 <bacelar> nope
13:09:16 <copumpkin> bacelar: what compilation issues are there?
13:09:34 <kmc_> hint is easy
13:09:42 <SubStack> copumpkin: programming languages professor here still does for some silly reason
13:09:43 <kmc_> trying to find the example i saw
13:09:50 <copumpkin> SubStack: damn
13:10:15 <kmc_> ah http://code.haskell.org/hint/devel/examples/
13:10:38 <SubStack> I remember walking through the CS building and seeing a haskell prompt through an open door
13:10:41 <SubStack> that was kind of neat
13:10:47 <kmc_> note that Prelude is not automatically imported in the interpreter scope
13:10:47 <SubStack> even if it was hugs
13:11:20 <copumpkin> gotta love some haskell documentation: http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-RWS-Lazy.html
13:11:53 <kmc_> well it should be obvious what everything does from its type :)
13:11:59 <kmc_> @unmtl RWS r w s a
13:12:00 <lambdabot> r -> s -> (a, s, w)
13:12:02 <SubStack> at least there aren't very many functions
13:12:03 <phaer> bacelar: Did you try http://trac.macports.org/browser/trunk/dports/lang/hugs98/Portfile ?
13:12:53 <copumpkin> I love that the referenced paper doesn't even contain the letters RWS
13:13:04 <copumpkin> nor does the documentation page tell you what they stand for
13:13:17 <copumpkin> for ultimate usefulness
13:13:18 <bacelar> phaer: not yetâ€¦ I'm out of macports for the time being :) but ghc wasn't available for 10.6â€¦
13:14:00 * SubStack creates the RWSHT monad. read. write. stop. hammer time.
13:14:44 <copumpkin> is that what it stands for?
13:14:52 <copumpkin> I thought it looked a bit like reader + writer + state
13:14:58 <phaer> bacelar: Did you read http://www.haskell.org/haskellwiki/Mac_OS_X#Mac_OS_X_10.6_.28Snow_Leopard.29 ?
13:15:18 <pgs31> kmc_: Hint appears to be precisely what I was after
13:15:20 <copumpkin> also, the obviously undocumented newtype RWST r w s m a	 always helps
13:15:35 <phaer> bacelar: Or the linked http://passingcuriosity.com/2009/haskell-on-snow-leopard/ ?
13:15:51 <sinelaw> is there a haskell library for symbolic math?
13:15:56 <copumpkin> yeah, I'm pretty sure it's reader + writer + state
13:16:03 <sinelaw> besides differentiation
13:16:06 <Vanadium> Is there a trivial implementation of Go's select statement in Haskell for Chans?
13:16:26 <Twey> unamb?
13:16:31 <impl> hey guys - I'm braindead/stupid, what's the function called that takes e.g. [1, 2, 3] and [A, B, C] and returns [ [1, A], [1, B], [1, C], [2, A], [2, B], ... ]
13:16:37 <impl> like a cross join in SQL
13:16:38 <sinelaw> impl, zip
13:16:49 <copumpkin> Twey: sounds more like amb
13:16:53 <copumpkin> liftM2 amb
13:16:55 <sinelaw> impl, NO.
13:16:56 <impl> sinelaw: no - that'll give me [ [1, A], [2, B] ] right?
13:16:58 <sinelaw> oops.
13:17:03 <bacelar> phaer: yep, the thing is I'm a absolute noob and I was thinking that, maybe, I didn't need the full ghc install for now on my ever shrinking hard driveâ€¦ :)
13:17:10 <sinelaw> impl, yes i was trigger happy
13:17:17 <impl> :)
13:17:26 <sinelaw> @hooge [a] -> [b] -> [(a,b)]
13:17:27 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
13:17:28 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
13:17:28 <lambdabot> Data.Graph.Inductive.Example genLNodes :: Enum a => a -> Int -> [LNode a]
13:17:29 <pgs31> Random Fact: Simon PJ's son came and did work experience at my place this sommer
13:17:33 <Twey> impl: No, it'll give you a type error.
13:17:35 <pgs31> Nice guy :)
13:17:46 <Twey> Lists are homogenous.
13:17:51 <phaer> bacelar: Then i can't help you because i'm a noob on haskell myself and i don't use os x ;)
13:17:55 <sinelaw> pgs31, cool
13:17:55 <Twey> pgs31: Where's that?
13:18:05 <pgs31> 'Cantab Capital Partners'
13:18:08 <impl> Twey: I meant generally. you can substitute [A, B, C] for [4, 5, 6] if you like
13:18:10 <pgs31> Little hedge fund in Cambridge
13:18:17 <impl> I thought the example would be easier to read with letters though.
13:18:29 <Twey> Ah, okay
13:18:30 <pgs31> We even got the man himself to come and give us a talk :)
13:18:35 <sinelaw> impl, Twey means you can't have [[1,A], [2,B]]. you probably meant [(1,A), (2,B)]
13:18:41 <sinelaw> pgs31, super cool
13:18:44 <pgs31> I was so inspired I am trying to reimplement everything we do in haskell
13:18:44 <impl> ah.
13:18:46 <Twey> sequence, I think, impl
13:18:47 <impl> yes.
13:18:49 <camio> :t amb
13:18:50 <lambdabot> Not in scope: `amb'
13:19:02 <Twey> > sequence [[1, 2, 3], [4, 5, 6]]
13:19:02 <sinelaw> @type sequence
13:19:03 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
13:19:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:19:21 <impl> Twey: perfect!
13:19:22 <impl> thanks
13:19:39 <copumpkin> or nmergeIO could help
13:20:08 <camio> Twey, nice!
13:20:43 <SubStack> @_@
13:22:26 <bacelar> phaer: cool, no problem, thanks!
13:22:49 <bacelar> copumpkin: thanks also!
13:22:59 <copumpkin> :)
13:25:33 <nimred> hello #haskell. Wich way do i uninstall a package from cabal ?
13:26:15 <copumpkin> ghc-pkg unregister <packagename>
13:26:18 <copumpkin> but it won't remove the files
13:26:33 <copumpkin> just means it won't interfere with dependency searches and the like
13:27:04 <pgs31> Okay, any hint guru's about?
13:27:20 <pgs31> I can make it evaluate expressions
13:27:30 <pgs31> runInterpreter $ do setImportsQ [("Prelude", Nothing), ("System.IO", Nothing)]; eval "\"Hello\""
13:27:38 <pgs31> Works great
13:27:46 <pgs31> But I can't get it to function inside the IO monad
13:27:55 <nimred> copumpkin I have xmonad installed via cabal. I updated all my packages installed via pkgsrc and would need to update xmonad and its dependancies... What do you recommand me to do ?
13:28:14 <pgs31> e.g. runInterpreter $ do setImportsQ [("Prelude", Nothing), ("System.IO", Nothing)]; eval "putStrLn \"Hello\""
13:28:15 <pgs31> fails
13:29:12 <copumpkin> nimred: might be best to ask in #xmonad
13:29:32 <copumpkin> nimred: you could try cabal update; cabal instal xmonad --reinstall
13:29:40 <copumpkin> but not sure if that'll do everything necessary
13:29:42 <sinelaw> so is there a haskell library for symbolic math?
13:29:55 <copumpkin> sinelaw: depends how symbolic
13:29:56 <copumpkin> > a + b
13:29:57 <lambdabot>   a + b
13:30:13 <centrinia> > a*(b+c)
13:30:15 <lambdabot>   a * (b + c)
13:30:16 <monochrom> not very sophisticated symbolic math
13:30:18 <copumpkin> > scanl1 f [1..5] :: [Expr]
13:30:19 <lambdabot>   [1,f 1 2,f (f 1 2) 3,f (f (f 1 2) 3) 4,f (f (f (f 1 2) 3) 4) 5]
13:30:22 <ksf> argh financial programming.
13:30:29 <ksf> we somehow have to get out of that niche.
13:30:33 <bsod666> in haskell can i define two functions with the same name which act differently
13:30:49 <copumpkin> bsod666: only if they're in different modules, or in a typeclass
13:30:51 <ksf> bsod666, if they're a typeclass member, yes.
13:30:52 <tromp_> not in same namespace
13:31:22 <jasonmay> > square x = x * x; square 3
13:31:23 <lambdabot>   <no location info>: parse error on input `='
13:31:26 <kmc_> impl, transpose?
13:31:31 <camio> bsod666, where is that need coming up? There may be a better way to solve the problem that prompts the question.
13:31:34 <ksf> bsod666, what's it that you're trying to do?
13:31:54 <kmc_> ksf, it's not a bad niche.  it's where the money is ;)
13:32:07 <monochrom> I think it is one of those comparative language classes.
13:32:08 <ksf> another approach is to pass a function that implements the differences.
13:32:11 <kmc_> but as is, haskell is not usable for high-frequency automated trading
13:32:23 <tromp_> or low frequency for that matter
13:32:30 <ksf> I thought that tokio-based guy did exactly that?
13:32:32 <pgs31> ksf: We like the precision of it :)
13:32:36 <kmc_> why not low frequency?
13:32:56 <pgs31> kmc_: We trade once a day on most things
13:33:07 <sinelaw> > a
13:33:08 <pgs31> kmc_: That is the sort of thing I am trying to use haskell for
13:33:08 <lambdabot>   a
13:33:09 <kmc_> the main obstacle is that garbage collection will cause an unacceptable latency spike
13:33:14 <tromp_> still too slow
13:33:14 <PeakerWork> kmc_: why isn't it good for high-freq?
13:33:15 <bsod666> i want to output a number if no number is entered in say 1
13:33:16 <sinelaw> copumpkin, how does that work?
13:33:28 <kmc_> that said, some people do use Java or C# for HF
13:33:30 <bsod666> if a number is specified i want it to use that and do a calculation
13:33:32 <ksf> well I'm coming from game programming, and am reacting kinda allergic to everything having to do with accounting or finance.
13:33:35 <copumpkin> sinelaw: a sneaky num instance along with some predefined bindings for a-z
13:33:36 <kmc_> but at the really fast end i think it's mostly C++
13:33:36 <PeakerWork> btw: High frequency/low frequency traders are just destroying the economy :-P
13:33:44 <pgs31> kmc_: You are entirely correct
13:33:47 <sinelaw> @type a
13:33:48 <PeakerWork> (auto traders which don't actually add interesting information to the market)
13:33:49 <lambdabot> Expr
13:33:50 <Vanadium> What does "low frequency" mean?
13:33:55 <kmc_> PeakerWork, there are dozens of totally different trading strategies
13:33:57 <copumpkin> sinelaw: you should check out the automatic differentiation too
13:33:57 <sinelaw> ho ho ho....Expr
13:33:57 <ksf> ...which might be because that's all that moloch that bought and ruined our studio actually consists of.
13:33:59 <PeakerWork> Vanadium: buy/sell with big gaps
13:34:02 <kmc_> Vanadium, it refers to the frequency with which one makes trades
13:34:03 <sinelaw> copumpkin, i know about that one
13:34:13 <copumpkin> ah
13:34:14 <Vanadium> I mean - big on the macroscopic scale?
13:34:16 <pgs31> Vanadium: Daily trading, or perhaps hourly or weekly. As in, not by the millisecond
13:34:17 <ksf> more accountants than people who actually get things done.
13:34:20 <Vanadium> Okay
13:34:26 <tromp_> high-freq = trade at subsecond speed
13:34:28 <PeakerWork> kmc_: most of the automated ones really don't add any useful information to the market, just exploit other software, or various locally unrandom trends
13:34:28 <Vanadium> Why is Haskell inappropriate for that, then? :<
13:34:34 <kmc_> HF algo trading is pretty harmless -- making tiny fractions of a cent from everyone, in exchange for increased liquidity
13:34:35 <Vanadium> That does not seem too time-critical
13:34:50 <pgs31> It's not
13:34:54 <kmc_> PeakerWork, at worse i think that's pretty neutral.  they're not writing exotic debt products and selling them to pension funds
13:34:56 <pgs31> Vanadium: It's perfect
13:34:58 <Vanadium> Right
13:34:58 <PeakerWork> kmc_: Basically, they're parasites who are destroying the market :-P
13:34:59 <Vanadium> Okay :]
13:35:12 <PeakerWork> kmc_: Its very harmful -- if they actually make money for no contribution
13:35:15 <SimonRC> did this discussion start from SPJ's contract combinators?
13:35:24 <kmc_> PeakerWork, elaborate?
13:35:29 <kmc_> and providing liquidity is very much a contribution
13:35:31 <monochrom> There was a bulletin board with a stock game. I used haskell to play it.
13:35:32 <pgs31> PeakerWork: Rubbish, it's a huge liquidity contribution
13:35:37 <ksf> we should really, really pressure governments to implement a transaction tax.
13:35:39 <pgs31> PeakerWork: Money for risk
13:35:43 <kmc_> liquidity-taking strategies, you have more of a point to make
13:35:44 <pgs31> ksf: They do
13:35:45 <monochrom> I mean forum.
13:35:48 <pgs31> ksf: Stamp duty
13:36:11 <kmc_> in those cases you can argue that it's a payment for computing and propogating information
13:36:19 <PeakerWork> pgs31: I am talking about auto-traders just exploit semi-non-random patterns they find (which are of other auto-traders, or other weird strategies)
13:36:23 <Vanadium> Is there a more straightforward/compact way to write this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12056 essentially a huge chain of "<*> foo"
13:36:39 <kmc_> oh jesus
13:36:45 <kmc_> Character is some huge record type?
13:36:49 <SimonRC> PeakerWork: well, they smooth everything out
13:36:49 <Vanadium> Yeah.
13:36:55 <monochrom> haha
13:36:57 <ksf> hell you can finance about everything with a 0.005% tax on every transaction.
13:36:58 <SimonRC> kmc_: no, but you can think of it that way
13:37:05 <Vanadium> It is what I would do in C, it somehow does not really translate to being elegant here.
13:37:07 <kmc_> PeakerWork, it certainly wasn't HF who destroyed the economy last year
13:37:32 <monochrom> I think it's fine.
13:37:34 <SimonRC> ksf: ah, but with that tiny tax the volume would decrease a lot
13:37:38 <kmc_> it was the very low-frequency, illiquid, poorly understood exotic derivatives that trade in back room shady deals
13:37:46 <pgs31> It's pretty hard to make good money doing HF anyway
13:37:53 <kmc_> much better to have ultra-efficient machines doing market making in the open, with tight spreads and transparency
13:38:01 <pgs31> As soon as you throw any volume at it the market moves too far away from you
13:38:09 <kmc_> pgs31, it's hard to scale up any individual strategy
13:38:13 <kmc_> to grow a HF shop you have to hire
13:38:31 <pgs31> kmc_: Out of curiosity, are you in the industry?
13:38:34 <kmc_> yeah
13:38:37 <ksf> you know, an even better strategy to increase wealth is to fund a place in your neighbourhood for the young to hang out.
13:39:03 <kmc_> Vanadium, this seems like a job for Template Haskell
13:39:27 <pgs31> ksf: Hard to make a decent return on a Billion dollars of your investors money though
13:39:34 <segoe> hi
13:39:45 <Vanadium> kmc_: All right, then I will look into template haskell later. Thank you :]
13:39:56 <ksf> ...if I had a billion dollars, I wouldn't be out looking for returns...
13:39:56 <kmc_> maybe the typeclass hacks are good enough though
13:41:13 <pgs31> kmc_: I'd be interested to learn some more if you're willing to share; I'm just mucking around with Haskell with a view to using it at our firm
13:41:39 <pgs31> ksf: It's no one person's billion dollars
13:41:52 <pgs31> ksf: It's countless hundreds of thousands of people's via pension funds etc..
13:42:21 <dpratt71> just noticed the "bots" have a different icon in my IRC client; what
13:42:27 <dpratt71> 's that about?
13:42:29 <ksf> well, it won't be my money.
13:42:41 <dpratt71> (it hasn't always been that way, right?)
13:43:04 <pgs31> ksf: If you have a pension with any of the big providers in the UK or US there's about a 1/3 chance ;)
13:43:27 <bsod666> hi, so i want to make a function which outputs 0 if there is no input but adds 1 to the input if it exists
13:43:34 <pgs31> Well, perhaps that was an exaggeration - maybe 1/20
13:43:35 <bsod666> so how could i do this
13:43:48 <bsod666> this is why i was wondering if i could define a function twice
13:43:51 <copumpkin> bsod666: no input = Nothing
13:44:01 <ksf> capital-based pension is a state crime.
13:44:08 <bsod666> sorry outputs 1
13:44:15 <bsod666> if no input
13:44:24 <copumpkin> :t fromMaybe 1 (1+)
13:44:26 <lambdabot>     Couldn't match expected type `Maybe t'
13:44:26 <lambdabot>            against inferred type `t1 -> t1'
13:44:26 <lambdabot>     In the second argument of `fromMaybe', namely `(1 +)'
13:44:29 <segoe> hi
13:44:30 <dancor> @let plusOneMaybs = fmap (+1)
13:44:32 <lambdabot>  Defined.
13:44:35 <ksf> bsod666, what's your input?
13:44:37 <copumpkin> :t maybe 1 (1+)
13:44:38 <lambdabot> forall t. (Num t) => Maybe t -> t
13:44:48 <dancor> > plusOneMaybs (Just 14)
13:44:49 <bsod666> my input could be nothing or a number
13:44:49 <pgs31> ksf: Why?
13:44:49 <lambdabot>   Just 15
13:45:09 <copumpkin> bsod666: and by nothing, you mean Nothing, right?
13:45:11 <pgs31> ksf: Surely some people would like to accept a higher risk for a better return?
13:45:18 <dancor> @forget plusOneMaybs
13:45:19 <lambdabot> Incorrect arguments to quote
13:45:24 <ksf> _some_ people, yes.
13:45:25 <dancor> @unset plusOneMaybs
13:45:25 <lambdabot> Unknown command, try @list
13:45:29 <copumpkin> @undef
13:45:30 <dancor> i've done it now
13:45:32 <bsod666> yeah
13:45:32 <dancor> @undef plusOneMaybs
13:45:41 <copumpkin> it ignores parameters
13:45:42 <pgs31> ksf: And there are plenty of funds you can invest in which will promise not to eat up your capital.
13:45:44 <copumpkin> it just clears everything
13:45:45 <ksf> but forcing people to do it because you're not providing a proper system is abysmal.
13:45:48 <dancor> oh.
13:45:58 <pgs31> ksf: You just get a rubbish return because they have to hedge out the risk
13:46:08 <pgs31> ksf: But you have to take risks to make money
13:46:26 * ksf can't find the english term on dict.leo.org
13:46:29 <pgs31> ksf: At least, that is the considered opinion
13:46:31 <ksf> "umlageverfahren".
13:46:59 <ksf> I'm directly paying the rent of my grandparents, and my kids are going to pay mine.
13:47:02 <eivuokko1> Absolute risks, yeah.  Risks relative to overall system, not so much.
13:47:25 <dancor> > let plusOneMaybs = maybe 0 (+1) in (plusOneMaybs Nothing, plusOneMaybs (Just 14))
13:47:26 <lambdabot>   (0,15)
13:47:43 <pgs31> Well people will keep living longer
13:47:48 <pgs31> it's a bit of a conundrum
13:48:05 <pgs31> We all live in the system, though, and no system we've invented yet is flawless
13:48:33 <dancor> you don't always have to take risks to make money, don't insured options (e.g. savings accounts) sometimes beat inflation (not currently)
13:48:35 <pgs31> There's no way of storing money that is risk free
13:48:48 <ksf> hell but it won't come from the free-market religion before it collapsed at least one, properly.
13:48:50 <pgs31> dancor: As long as the firm doesn't go bust
13:48:57 <ksf> *once
13:49:01 <pgs31> dancor: And as long as the currency is worth something when you get it back :)
13:49:04 <dancor> pgs31: which firm?  i'm talking about FDIC insured
13:49:04 <eivuokko1> Living is not risk-free.  Plane might drop on you.
13:49:20 <pgs31> dancor: Then as long as the FDIC doesn't go bust
13:49:30 <pgs31> dancor: It's a _low_ risk , sure
13:49:38 <mmx166mhz> Can I ask someone sth about haskell?
13:49:41 <dancor> ya, i just don't think that's necssarily more likely than like getting robbed if you don't put money into a bank
13:49:48 <pgs31> dancor: You can buy us govt. bonds, they are considered the most risk-free of assets in the world
13:49:49 <mmx166mhz> I am a beginning student who could use some assistance
13:49:51 <reltuk> mmx166mhz probably just ask
13:49:54 <monochrom> I like haskell
13:49:55 <ksf> eivuokko1, so what. a velociraptor could break into my appartment. I've got my trusty model m handy.
13:50:05 <dancor> not by me; i consider fdic savings accts same
13:50:07 <kmc_> ksf, "free-market religion"  <-- you don't think it's rational to build distributed computational systems?
13:50:15 <mmx166mhz> Ok: Suppose I have a number like 2^1000: How can I represent it as a string?
13:50:15 <eivuokko1> ksf, just making a point, some risks are not really worth mentioning.
13:50:22 <kmc_> > show (2^1000)
13:50:23 <lambdabot>   "10715086071862673209484250490600018105614048117055336074437503883703510511...
13:50:29 <monochrom> "2^1000" is a string
13:50:30 <dancor> monochrom: do something cool with it
13:50:38 <ksf> there's a difference between a free market and a unregulated market.
13:50:43 <pgs31> dancor: but they could still be worth nothing  at the end if the fed continues to print money at the rate it is doing ;)
13:50:58 <copumpkin> maybe #haskell-blah for the economics talk?
13:51:04 <pgs31> Apologies
13:51:05 <holmak> or even #econ
13:51:06 <mmx166mhz> thanks: next question: I was very impresses that with haskell u could calculate 10000! within a few seconds: What is the magic of this?
13:51:15 <kmc_> mmx166mhz, did you actually print the value?
13:51:17 <pgs31> Got a bit carried away there
13:51:19 <kmc_> because it won't calculate until you use it
13:51:23 <monochrom> It uses the gmp library
13:51:24 <ksf> mmx166mhz, fast cpu.
13:51:24 <copumpkin> :)
13:51:42 <kmc_> also, the other magic is just that GHC is a kickass sexy compiler
13:51:43 <copumpkin> mmx166mhz: definitely wouldn't be that fast on a pentium 166 mmx
13:51:50 <monochrom> Then again, that says nothing. The gmp library is just doing normal things.
13:51:57 <ksf> > product [1.10000]
13:51:58 <mmx166mhz> haha, ok lol:P Trying to solve some Project Euler things :P I know: This was my first PC.:)
13:51:58 <lambdabot>   1.1
13:52:02 <kmc_> at a time when most "high-level" or "usable" languages like Ruby and Python are implemented using slow-ass toy interpreters
13:52:03 <copumpkin> whoa
13:52:03 <ksf> > time product [1.10000]
13:52:04 <lambdabot>   Not in scope: `time'
13:52:06 <pgs31> Anyway, I must run - I'll see y'all around. Hope to make myself a regular face on here
13:52:07 <ksf> er.
13:52:13 <copumpkin> needs more dots
13:52:14 <ksf> > time product [1..10000]
13:52:15 <lambdabot>   Not in scope: `time'
13:52:19 <ksf> > product [1..10000]
13:52:20 <lambdabot>   284625968091705451890641321211986889014805140170279923079417999427441134000...
13:52:23 <kmc_> pgs31, see you around
13:52:28 * pgs31 waves
13:52:29 <copumpkin> , time (product [1..10000])
13:52:31 <yitz> @faq can haskell calculate 1000! within a few seconds?
13:52:31 <lambdabot> The answer is: Yes! Haskell can do that.
13:52:44 <copumpkin> oh, no lunabot
13:52:53 <copumpkin> mmorrow: THEY KILLED LUNA!
13:52:54 <kmc_> @faq can haskell create a burrito so big that even lambdabot could not eat it?
13:52:55 <lambdabot> The answer is: Yes! Haskell can do that.
13:53:07 <nimred> any idea about error when compiling xmonad from cabal --> http://haskell.pastebin.com/m658c4aca ?
13:53:19 <yitz> really? what happened to lunabot?
13:53:32 <Zao> Horrible kitten mauling.
13:54:54 <copumpkin> maybe it's a new moon tonight
13:54:54 <copumpkin> and luna is gone
13:54:54 <mmx166mhz> The way Ive been working with Haskell it pretty 70s( GHCi). Is there some " nicer" way , e.g.capable of showing some color...
13:54:55 <adu> hi
13:54:55 <Zao> mmx166mhz: winghci, leksah, etc.
13:54:55 <adu> I just had an epiphany
13:54:55 <ksf> nimred, what did you do to your ghc install?
13:55:03 <Botje> error: gmp.h: No such file or directory # that's probably bad. do you have the libgmp-dev package?
13:55:16 <nimred> ksf nothing special ! just compiled from pkgsrc
13:55:23 <yitz> ok, next goal for the ghc team: add colors to ghci
13:55:44 <mmx166mhz> Well; it'd sure make things sexier.
13:55:46 <nimred> ksf do i have to export some C_INCLUDE_PATH ?
13:56:02 <ksf> ghc should know where gmp.h is
13:56:11 <ksf> well not ghc, but cabal
13:56:51 <ksf> you don't need gmp installed for ghc to compile, btw, the haskell gmp package comes with the library attached.
13:57:04 <monochrom> I don't think there is anything not sexy with being 70s. Look at the plain text file you write code into. It's 50s, and you call it sexy source code.
13:57:20 <ksf> so maybe it's confused because it found -lgmp, but not gmp.h
13:57:39 <ksf> or it failed to install gmp.h as it installed integer-gmp
13:58:15 <ksf> nimred, in any case, try to compile a simple program using Integer, and look at what ghc -v tells you.
13:58:32 <Cale> nimred: Is there no binary installer/package for GHC?
13:58:36 <nimred> ksf exporting C_INCLUDE_PATH=/usr/pkg/include made it working :)
13:58:51 <ksf> that's evil.
13:58:57 <ksf> and should'nt be nescessary.
13:59:03 <mmx166mhz> Another question: SUppose I have a function with 2 parameters, and I want to make a function with 1 parameter by filling sth in for the 2nd param.. How I can do this?
13:59:14 <nimred> ksf why ?
13:59:21 <Zao> @type flip
13:59:22 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
13:59:22 <ksf> because I don't need to do it.
13:59:28 <ksf> ...and noone should.
13:59:33 <dancor> f' x = f x 4
13:59:35 <nimred> ksf wich system ?
13:59:39 <ksf> gentoo
13:59:40 <dancor> f' = f 4
13:59:50 <mmx166mhz> aha, ok thanks.
14:00:12 <mmx166mhz> question: Is there some inbuild thing representing a set( like in maths)?
14:00:17 <dons> Data.Set
14:00:22 <mmx166mhz> ok
14:00:36 <monochrom> But it can't do infinite sets.
14:00:53 <ksf> ...and the ebuild says that ghc depends on libgmp, so it's using the system version.
14:01:09 <mmx166mhz> has haskell inbuilt complex numbers?
14:01:10 <monochrom> "sets like in math" is too hard if you really mean it. But you never. You always make concessions.
14:01:19 <mauke> mmx166mhz: yes
14:01:24 <mmx166mhz> niice
14:01:38 <kmc_> mmx166mhz, look at Data.Set
14:01:42 <tommd> Are you actually working on an old Pentium 1 with MMX?
14:01:46 <kmc_> also Data.Map if you want to associate a value with every key
14:01:46 <ksf> > 1%2 + 1%3
14:01:46 <nimred> ksf http://haskell.pastebin.com/m63701e84
14:01:47 <lambdabot>   5 % 6
14:01:54 <monochrom> Data.Complex has complex numbers
14:01:55 <kmc_> > (1 :+ 1)**2
14:01:56 <lambdabot>   1.2246467991473532e-16 :+ 2.0
14:01:57 <tommd> Sorry, OT, I shouldn't ask but curiousity gets the best of me.
14:01:57 <mmorrow> copumpkin: oh noes
14:02:04 <ksf> oh that were rationals.
14:02:06 <nimred> ksf sure but you are building from portage. I am from cabal
14:02:09 <mmx166mhz> no, I have a p4 2Ghz actually:P
14:02:14 <kmc_> haha
14:02:28 <kmc_> 2 GHz P4 is roughly equivalent to 166 MHz any other chip ;P
14:02:39 <monochrom> But Data.Set would not work for Data.Complex.
14:02:45 <mmorrow> copumpkin: hmm, it looks like she split during the last netsplit
14:02:49 <m0nkfish> hi how can i enumerate the results of a foldl at every stage
14:02:56 <kmc_> m0nkfish, scanl?
14:02:57 <kmc_> :t scanl
14:02:58 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
14:03:01 <mmorrow> and never came back
14:03:02 <kmc_> > scanl (+) 0 [1..10]
14:03:04 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55]
14:03:05 <m0nkfish> i think scanl is what i needthanks
14:03:06 <m0nkfish> :)
14:03:13 <ksf> nimred, /usr/pkg/include doesn't really look right.
14:03:14 <kmc_> > scanl (+) e [f,g,h]
14:03:15 <lambdabot>   [e,e + f,e + f + g,e + f + g + h]
14:03:25 <mmorrow> dead
14:03:33 <ksf> and I've got no idea why your ghc thinks it's /usr/pkg/lib/ghc...
14:04:34 <mmx166mhz> How can I make .hs (haskell source files) using GHCi?( Until now , I made them by changing existing ones..)
14:04:35 <reltuk> ksf: that's where pkgsrc is trying to install it?
14:04:35 <mmorrow> , fix (0:)
14:04:35 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
14:04:35 <mauke> mmx166mhz: no
14:04:35 <ksf> but linux/types.h should live in /usr/include
14:04:42 <ksf> ...and that's completely missing.
14:04:56 <mmx166mhz> I cant believe the only way of making .hs files is by changing old ones..
14:05:08 <mauke> mmx166mhz: what?
14:05:23 <kmc_> mmx166mhz, in a text editor?
14:05:24 <mmx166mhz> well: I mean: How can i make .hs files.?
14:05:29 <mauke> mmx166mhz: with a text editor
14:05:36 <mmx166mhz> No, that doesn't work
14:05:39 <mauke> yes, it does
14:05:45 <kmc_> trust us
14:05:47 <mmx166mhz> hmm, with notepad too?
14:05:47 <kmc_> we've all done it
14:05:49 <kmc_> yes
14:05:57 <kmc_> notepad is terrible but yes, it will work
14:06:00 <mmx166mhz> I couldnt do it..
14:06:08 <stroan> mmx166mhz: how did you go about it?
14:06:11 <nimred> ksf i am not on linux but BSD system (NetBSD)
14:06:11 <kmc_> you will be much happier if you have an editor which at least supports auto indentation and syntax highlighting
14:06:17 <dancor> did it save your file as lol.hs.txt maybe
14:06:27 <ksf> nimred, then I don't think you'll be able to build hinotify
14:06:36 <FunctorSalad_> I really need to make myself an import list once and forall o_O
14:06:40 <ksf> inotify is a linux api
14:06:41 <shambler> scite is good for windows
14:06:42 <mmx166mhz> Yes, like that, though I could make remove the .txt part
14:06:45 <nimred> ksf i already got it compiled
14:06:50 <mmx166mhz> couldnt*
14:07:01 <mauke> mmx166mhz: why not?
14:07:10 <ksf> nimred, inotify?
14:07:17 <dancor> mmx166mhz: you should use a better editor, or rename the file from like the command prompt
14:07:24 <mmx166mhz> I save it as "sth.hs", but I couldnt get rid of .txt
14:07:29 <mauke> mmx166mhz: why not?
14:07:29 <nimred> ksf sure
14:07:31 <mmx166mhz> Ok, I do from CMD
14:07:33 <stroan> mmx166mhz: this windows?
14:07:33 <ksf> It could be that hinotify's configure can't deal with stuff being in non-linux places.
14:07:36 <ddarius> You can save files without a .txt extension with notepad.
14:07:51 <nimred> since i got xmobar compiled and xmobar depends on hinotify
14:07:52 <shambler> you can change this behavior
14:08:00 <shambler> in explorer options afair
14:08:16 <shambler> it'll show rxtensions and will allow to change them
14:08:20 <stroan> mmx166mhz: if you're going to be doing much programming, turn on show all file extensions in the windows folder options
14:08:37 <mauke> s/if.*, //
14:08:42 <ddarius> Just change the drop-down from showing .txt files to showing all files in the save dialog.
14:08:48 <mmx166mhz> ok, thanks
14:09:05 * ddarius wonders why there is a 90 message mailinglist thread on Clean.
14:09:09 <copumpkin> preflex: seen edawardk
14:09:10 <preflex>  Sorry, I haven't seen edawardk
14:09:19 <copumpkin> preflex: seen edwardk
14:09:19 <preflex>  edwardk was last seen on ##logic 9 days, 2 hours, 48 minutes and 44 seconds ago, saying:  /j #lock-free
14:09:30 <ksf> nimred, unpack the package. in ./include there's the whole inotify.h , maybe things work out if you replace it with your bsd one.
14:09:36 <copumpkin> ddarius: yeah, there have been several rather pointless threads recently
14:10:37 * dancor wonders why you would bring up a mailing list without saying which one
14:11:07 <ddarius> dancor: I don't normally specify which language I'm talking about in this channel either.
14:11:13 <ksf> mmx166mhz, more importantly, you want to use a text editor instead of notepad.
14:11:24 <mmx166mhz> which one do u reccomend?
14:11:29 <ksf> gvim.
14:11:33 <mmx166mhz> thnx
14:11:34 <segoe> well, notepad is a text editor
14:11:39 <mmx166mhz> sure it is :P
14:11:45 * segoe also recomends gvim
14:11:55 <Twey> And rotted cabbage is food
14:12:02 <dancor> http://www.haskell.org/haskellwiki/Mailing_lists
14:12:19 <Twey> Most Haskellers use emacs.  There's a good haskell-mode for emacs (maintained by Baughn) with some useful functions.
14:12:46 <ksf> Twey, unsubstituated claim.
14:12:57 <bran> I use vim =)
14:13:09 * Zao is comost
14:13:12 <FunctorSalad_> anyone need some names for alternative preludes? overture, genesis, inception
14:13:14 <ddarius> dancor: It's very clear which one is the main one.
14:13:15 <ksf> most haskellers might use vim or emacs.
14:13:16 <copumpkin> dancor: haskell-cafe
14:13:19 <ksf> but not emacs.
14:13:19 <FunctorSalad_> thesauri ftw
14:13:20 <Twey> ksf: Heh.
14:13:21 * segoe wants emacs-slime for vim
14:13:34 <theclaw> does the do-syntax have any special semantics when used with braces? (e.g. do { foo; bar; })
14:13:49 <Twey> theclaw: No, same as usual
14:13:52 <monochrom> Most haskellers argue over editors. (Substantiated claim. Just lurk in this channel for a month to see.)
14:13:55 * ksf is opting for a split prelude.
14:14:04 * hackagebot upload: hogre 0.0.1 - Haskell binding to a subset of OGRE (AnttiSalonen)
14:14:06 <theclaw> thanks
14:14:13 <Twey> The whitespace-sensitivity is just syntactic sugar for braces and semicolons.
14:14:28 <shambler> mmx166mhz, try scite
14:14:32 <ksf> monochrom, I'm going to cite you on considering citations from irc channels as proper citations.
14:14:39 <kmc_> i use vim, used to use emacs, or my own editor, tried to use yi.  i'm (gasp!) not fanatical about what editor people use
14:14:39 <ddarius> monochrom: Not really, especially compared to other programming language hang-outs.
14:14:45 <kmc_> (you think you're a radical...)
14:15:06 * hackagebot upload: simple-observer 0.0.1 - The Observer pattern (AndyGimblett)
14:15:09 * hackagebot upload: hogre-examples 0.0.1 - Examples for using Hogre. (AnttiSalonen)
14:15:16 <FunctorSalad_> Twey: yes, Baughn ftw. I'm already happy that he made a new repo instead of the old one which was 6 dirs down
14:15:23 <m0nkfish> is index a functino
14:15:30 <ddarius> @hoogle index
14:15:30 <lambdabot> Data.ByteString index :: ByteString -> Int -> Word8
14:15:30 <lambdabot> Data.Ix index :: Ix a => (a, a) -> a -> Int
14:15:30 <lambdabot> Data.Sequence index :: Seq a -> Int -> a
14:15:35 <monochrom> "private communication" is proper citation too. I don't see why irc communication is not.
14:15:36 <Twey> m0nkfish: Not in the Prelude.
14:15:46 <m0nkfish> it should be in Data.List i guess
14:15:59 <m0nkfish> @hoole findIndex
14:15:59 <lambdabot> Data.ByteString findIndex :: (Word8 -> Bool) -> ByteString -> Maybe Int
14:16:00 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
14:16:00 <lambdabot> Data.Map findIndex :: Ord k => k -> Map k a -> Int
14:16:00 <ddarius> "public communication"
14:16:18 <ksf> monochrom, do you volunteer on citing from 4chan?
14:16:29 <ddarius> m0nkfish: Are you looking for a function that does something or are you looking for a function named "index?"
14:16:42 * Warrigal ponders what type -> would have to have if it were an infix function in \x -> foo
14:16:53 * ddarius would cite from 4chan if appropriate.
14:17:43 <copumpkin> "imma chargin mah lazer" -4chan
14:17:48 <monochrom> Nothing interesting on 4chan to cite.
14:18:01 <shambler> no way
14:18:02 <copumpkin> I beg to differ
14:18:04 <Twey> Most Internet users are idiots (4chan, 2003â€“)
14:18:13 <FunctorSalad_> monochrom: err? it surely has been socially influential even if you don't like it
14:18:21 <ddarius> Twey: 4chan isn't most internet users.
14:18:37 <Twey> It's a fairly pervasive sample
14:18:45 <FunctorSalad_> so it would be interesting as an object of study at least, if not a reliable source.
14:18:46 <monochrom> influential and uninteresting
14:19:06 <ddarius> Twey: There's significant selection-bias there.
14:19:37 * Cale looks for a way to convert latex to png which doesn't fall flat on its face when faced with Tikz diagrams.
14:20:00 <ddarius> Cale: Convert to PDF and then take a screenshot.
14:20:16 <__JN> Hi, I have a patternmatch question: with something like func1 (a1:a2:a3:rest) = ...,  it's easy to manually get individual parts of a list. But what if I want to map the data at index 99 and 501 in a list? Do I have to match with (a1: ... :a99: ... :a501:rest) ot is there a better way?
14:20:17 <Twey> ddarius: That's true.
14:20:18 <Cale> ddarius: Yeah, I was hoping not to have to do that by hand.
14:20:23 <FunctorSalad_> maybe 'convert' can convert pdf to png ;)
14:20:37 <ksf> citing from boards has been proven entertaining: http://www.action-team.us/krautchan-winnenden-hoax/
14:20:44 <FunctorSalad_> Cale: pdftoppm?
14:20:59 <monochrom> mylist !! 500 gives you a501
14:21:10 <Cale> FunctorSalad_: It can, but if I use pdflatex followed by convert, I get a full page.
14:21:10 <Twey> FunctorSalad_: I think it actually can.
14:21:35 <__JN> monochrom: yes, but let's say I want 501 throuht 505 or something like that
14:21:40 <FunctorSalad_> Cale: there's probably some cropping command
14:21:44 <Cale> hmmm :)
14:22:13 <monochrom> Is writing mylist!!500, mylist!!501, mylist!!502, mylist!!503, mylist!!504 that hard?
14:22:20 <mmx166mhz> short question: Why can I calculate sqrt 2 with haskell?(it doesnt give any errors whatsoever)
14:22:50 <FunctorSalad_> __JN: fmap (mylist !!) [500..504]
14:23:02 <mauke> mmx166mhz: uh, why wouldn't you?
14:23:23 <dons> mmx166mhz: what's the type of "2" ?
14:23:24 <Yacoby> What is wrong with calculating sqrt 2>
14:23:32 <monochrom> case (a501:a502:a503:a504:a505:junk) of drop 500 mylist
14:23:39 <mmx166mhz> well; according to some text here, it should give an error as 2 isnot a floating number.. I should be writing sqrt 2.0 instead..
14:23:41 <monochrom> err
14:23:50 <mauke> mmx166mhz: is this text about OCaml?
14:24:01 <monochrom> case drop 500 mylist of (a501:a502:a503:a504:a505:junk) -> ...
14:24:01 <mauke> Yacoby: Pythagoras forbids it!
14:24:06 <__JN> monochrom: well, problem is I have textlines with columns of certain lengths where I want to pick only some columns, so I thougt pattern matching would work
14:24:07 <dons> mmx166mhz: wrong language?
14:24:13 <mmx166mhz> GHCi says it OK
14:24:25 <dons> mmx166mhz: 2 is overloaded in Haskell, and will default to the type you need
14:24:29 <dons> :t 2
14:24:30 <lambdabot> forall t. (Num t) => t
14:24:34 <dons> :t sqrt 2
14:24:36 <lambdabot> forall t. (Floating t) => t
14:24:40 <dons> :t sqrt
14:24:41 <lambdabot> forall a. (Floating a) => a -> a
14:24:44 <mmx166mhz> Hmm, Helium complains, though GHCi says it OK
14:24:50 <dons> so it just picks the right Floating type
14:24:52 <mauke> Helium isn't Haskell
14:24:54 <dons> helium doesn't do this.
14:25:12 <dolio> Helium has a simplified type architecture for teaching.
14:25:27 <mmx166mhz> ahaa, they use it at my university here..
14:25:38 <mmx166mhz> Ok, so I should just forget Helium..
14:25:57 <bsod> so its possible to use a function on another function
14:26:12 <bsod> but its not possible to use a function on itself because of infinite type
14:26:15 <Axman6> bsod: what do you mean?
14:26:25 <Warrigal> How tightly does :: bind?
14:26:28 <bsod> is that correct?Just thinking outloud
14:26:41 <Axman6> bsod: what about fix?
14:26:44 <dolio> Warrigal: As loosely as possible.
14:26:44 <mauke> Warrigal: very loosely
14:26:47 <Axman6> > fix (1:)
14:26:48 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:26:54 <Axman6> @src fix
14:26:55 <lambdabot> fix f = let x = f x in x
14:26:56 <mauke> dolio: I don't think so
14:26:58 <dolio> Warrigal: Looser than any other operator.
14:27:20 <jcapper> id is a simpler example
14:27:29 <Axman6> > id id 4
14:27:31 <lambdabot>   4
14:27:36 <jcapper> > let f a = a in f f 1
14:27:37 <lambdabot>   1
14:27:43 <Warrigal> Looser than $, then.
14:28:04 <jcapper> > let f a = a in (f f) 1
14:28:05 <lambdabot>   1
14:28:10 <bsod> hmm so my last statement was wrong
14:28:12 <Axman6> :t (\x -> x x)
14:28:13 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
14:28:13 <lambdabot>     Probable cause: `x' is applied to too many arguments
14:28:13 <lambdabot>     In the expression: x x
14:28:24 <dons> ?src iterate
14:28:25 <lambdabot> iterate f x =  x : iterate f (f x)
14:29:29 <Warrigal> Does GHC work properly when given this yet? {data Wrap a = Wrap (Wrap a -> a); self (Wrap f) = f (Wrap f)}
14:29:37 <jcapper> Warrigal: No
14:29:40 <jcapper> I tried it yesterday!
14:29:56 <jcapper> You can, however, use {-# NOINLINE self #-}
14:30:13 <bsod> what about a function on itself without specifying input can that be done?
14:31:05 <jcapper> > let f = id in f f
14:31:07 <lambdabot>   {()->()}
14:31:19 <Warrigal> > id
14:31:20 <lambdabot>   {()->()}
14:31:27 <Warrigal> lambdabot: you're weird, you know?
14:32:07 <Warrigal> So, :: binds more loosely than ->, right?
14:32:18 <mauke> no
14:32:19 <jcapper> Warrigal: Yes
14:32:24 <jcapper> No?
14:32:31 <Warrigal> @type \x -> x x :: (forall a. a -> a) -> a -> a
14:32:33 <lambdabot>     Cannot match a monotype with `t -> (forall a1. a1 -> a1) -> a -> a'
14:32:33 <lambdabot>     Probable cause: `x' is applied to too many arguments
14:32:33 <lambdabot>     In the expression: x x :: (forall a. a -> a) -> a -> a
14:32:37 <jcapper> Wait, are we talking value or type level?
14:32:44 <Warrigal> Value level.
14:32:47 <jcapper> As in lambda expressions, or the type constructor.
14:32:49 <mauke> are we talking left precedence or right precedence?
14:32:52 <jcapper> Oh, right, then probably no!
14:33:18 <Warrigal> @type (\x -> x x) :: (forall a. a -> a) -> a -> a
14:33:19 <lambdabot> forall a. (forall a1. a1 -> a1) -> a -> a
14:33:32 <Warrigal> @type ((\x -> x x) :: (forall a. a -> a) -> a -> a) id
14:33:33 <Vanadium> Man, Google should have called their language Gaskell.
14:33:33 <lambdabot> forall a. a -> a
14:33:42 <Warrigal> Vanadium: Google has a language?
14:34:08 <Axman6> it'a called Go
14:34:52 <Warrigal> How confusing.
14:35:02 <bsod666> Axman6: so is it possible to call a function on itself as an argument without any other input?
14:35:02 <Warrigal> Wait a minute, I've heard of that.
14:35:11 <Warrigal> The person it was mentioned to was confused. :-P
14:35:23 <Axman6> :t const const
14:35:25 <lambdabot> forall a b b1. b1 -> a -> b -> a
14:35:41 <Warrigal> bsod666: (id id) is a valid construction, so definitely.
14:35:41 <Axman6> > const const 1 2 3
14:35:43 <lambdabot>   2
14:36:04 <bsod666> erm but id id doesnt work
14:36:18 <jcapper> bsod666: It's a value, it just doesn't have a Show instance
14:36:24 <jcapper> As it's a function
14:36:28 <Vanadium> > id id 42
14:36:30 <lambdabot>   42
14:36:32 <dolio> Wow, you can have main with non-IO type in Helium.
14:36:39 <dons> that used to work in ghc.
14:36:41 <dons> it was cool
14:36:47 <dons> sorry, not quite. IO a
14:36:53 <dons> so you could have main :: IO Int
14:37:15 <dolio> That isn't still allowed? I thought it just did nothing beyond IO ().
14:37:23 <SimonRC> surely IO Int is nicer on many systems, to give a return code?
14:37:27 <bsod666> what i need to write for such a function?
14:37:45 <Axman6> SimonRC: i don't believe it returns the returned integer
14:37:52 <SimonRC> :-(
14:38:06 <dolio> You need to exitWith to return codes.
14:38:23 <jcapper> bsod666: People have given several examples, `id id' for example
14:38:26 <jcapper> :t id id
14:38:27 <mmx166mhz> one last question b4 I leave: How can you apply a function n times?
14:38:28 <lambdabot> forall a. a -> a
14:38:40 <kmc_> :t iterate
14:38:41 <lambdabot> forall a. (a -> a) -> a -> [a]
14:38:46 <Axman6> mmx166mhz: iterate and (!!)
14:38:54 <kmc_> > (iterate f x) !! 5
14:38:55 <lambdabot>   f (f (f (f (f x))))
14:38:59 <copumpkin> note that it's not necessarily very stack-safe
14:39:10 <mmx166mhz> ok !:)  cu all later, I love this channel! thanks all!
14:39:30 <dolio> Integer = Int is kind of a bizarre choice.
14:39:38 <dolio> For a teaching language especially, I'd think.
14:46:05 <Cale> aha, pdfcrop :)
14:50:00 <Cale> The most ridiculous thing is when someone writes what ought to be a shell script as a C program which builds up strings reprsenting commands with strcat only to call system on them.
14:50:24 <dolio> People do that?
14:50:52 <dolio> They should use Go!
14:51:04 <monochrom> hahahaha "python has an eval function like in perl"
14:51:21 <Cale> Apparently. This mathTeX server is such a program. It's 5000 lines, though that includes a fair amount of what looks to be embedded image data.
14:51:41 <Cale> (less than 1000 lines of that though, it's a lot of code)
14:51:50 <monochrom> People have to justify their time spent learning C, you know.
14:52:04 <monochrom> or s/justify/rationalize/
14:52:28 <user3> hi, im a complete noob with haskell and im trying to design a tree, it isnt a binary tree, nodes have multiple children. The problem is i dont know where to start with traversing it
14:52:33 <copumpkin> Cale: wow
14:52:48 <copumpkin> user3: so first of all, what's your data definition for your tree?
14:52:57 <dolio> Start at the root. :)
14:53:31 <Cale> It also appears to include its own implementation of md5
14:53:33 <chrisdone> is Go now a #haskell meme?
14:53:34 <nolrai_FG> That is strange. Is there any good specification of the g-machine used by GHC as of now, or do I have to just find the papers describing each change to it?
14:53:36 <copumpkin> wonderful
14:53:48 <Rotaerk> user3, data Tree e = Node [Tree e] | Leaf e
14:53:50 <nolrai_FG> What is Go?
14:53:51 <Rotaerk> maybe?
14:53:59 <user3> data PTree a = 	Empty | Element a | PhonemeSet a [PTree a] deriving (show)
14:54:12 <mauke> Show, not show
14:54:18 <user3> yup
14:54:35 <Rotaerk> oh right, forgot the e in the Node
14:54:38 <Cale> as well as a 30-lines-of-pointer-arithmetic-gibberish implementation of URL unescaping
14:54:39 <mauke> traverse x = case x of ...
14:54:56 <Rotaerk> and it doesn't need Leaf, because Nodes with empty tree lists are leafts
14:54:59 <copumpkin> user3: do you really need that many cases?
14:55:22 <copumpkin> it seems like that's equivalent to just PhonemeSet a [PTree a]
14:55:35 <copumpkin> oh, well with | Empty
14:55:36 <user3> that was supposed to be a node with more nodes
14:56:05 <nolrai_FG> Yeah but by deafalut lists arnt non-empty
14:56:19 <Rotaerk> data Tree e = Node e [Tree e]
14:56:22 <monochrom> "traverse" is vague
14:56:35 <copumpkin> Rotaerk: data NonEmptyTree
14:56:45 <copumpkin> Cofree []
14:56:54 <monochrom> But I guess a vague answer is in order. Use recursion to traverse the tree.
14:57:01 <mauke> and pattern matching!
14:57:03 <Rotaerk> depends if you allow an "empty tree" to exist
14:57:31 <monochrom> I need to practice the skill of matching vagueness in replies.
14:58:19 <mauke> nature abhors an empty tree
14:58:26 <user3> ahhh got it working!
14:58:34 <monochrom> naw. nature just abhors a naked empty tree
14:59:32 <Rotaerk> I guess it'd be:  data Tree e = Node e [Node e] | Empty
15:00:12 <kmc_> Cale, on the plus side, if you ever lock yourself out of your mathTeX server, there's probably a way to pwn the machine through the URL unescaping function
15:00:23 <Rotaerk> wait no I'm stupid again
15:00:26 <monochrom> hahahaha
15:00:27 <Rotaerk> ignore me
15:00:37 <kmc_> data Tree e = Node [Tree e]
15:00:50 <Veinor> why is there a foldl' but no foldr'?
15:01:02 <Rotaerk> kmc_, that's what I originally suggested, though you forgot to include the e itself in the node
15:01:09 <kmc_> Veinor, because the strictness of foldr is up to the consumer
15:01:13 <dolio> There is foldr' in Data.Foldable
15:01:24 <Rotaerk> but the goal would be to allow the tree to be empty without it containing nodes that are empty trees
15:01:28 <Veinor> I mean, in Data.List
15:01:29 <monochrom> Note that data Tree e = Node [Tree e]  is isomorphic to  data Tree = Node [Tree]
15:01:35 <kmc_> yeah
15:01:37 <kmc_> i messed up
15:01:40 <Veinor> :P
15:02:08 <dolio> foldr' isn't a very nice operation on lists.
15:02:27 <Veinor> ah, foldr' would still have the space leak, wouldn't it
15:02:29 <dolio> Tends to overflow stacks.
15:02:40 <kmc_> Veinor, foldr merely replaces each [] and (:) in the list with a user-defined value
15:02:50 <kmc_> so you can make a foldr strict the same way you'd make a tree strict
15:03:07 <kmc_> whereas foldl can do a lot of accumulating before you get a chance to force any part of it
15:03:11 <kmc_> that's my fuzzy understanig
15:03:24 <Cale> kmc_: ahaha
15:03:33 <Veinor> apparently foldr' can succeed where foldr fails
15:03:41 <monochrom> foldr' is unnecessary because you can already control strictness by controlling strictness of f.
15:03:59 <kmc_> Veinor, how's that?
15:04:04 <Veinor> well, I just tried it
15:04:12 <kmc_> adding strictness can only make programs more diverging
15:04:16 <kmc_> unless you have bounded resources
15:04:25 <Veinor> foldr (+) 0 [1..5000000]
15:04:28 <Veinor> whoops
15:04:28 <Veinor> > foldr (+) 0 [1..5000000]
15:04:30 <lambdabot>   * Exception: stack overflow
15:04:33 <Veinor> > foldr' (+) 0 [1..5000000]
15:04:34 <lambdabot>   Not in scope: `foldr''
15:04:37 <Veinor> bah
15:04:40 <Axman6> foldl
15:04:53 <Veinor> the point is, on my machine foldr' (+_) 0 [1..5000000] succeeds
15:04:59 <kmc_> > foldr (\!a !b -> a+b) [1..5000000]
15:05:01 <lambdabot>   <no location info>: parse error on input `->'
15:05:05 <kmc_> , foldr (\!a !b -> a+b) [1..5000000]
15:05:06 <lunabot>  luna: parse error on input `->'
15:05:11 <monochrom> No bang pattern here.
15:05:18 <Cale> I'm actually going to use this mess. I just hackily rewrote the bit which runs latex so it runs pdflatex and the bit which runs dvips so that it runs pdfcrop, and then the bit which runs convert so that it runs convert with different filenames :)
15:05:20 <MoALTz> > foldr (\x y -> x+y `seq` x+y) 0 [1..5000000]
15:05:22 <lambdabot>   * Exception: stack overflow
15:05:24 <kmc_> > foldr (\a b -> a `seq` b `seq` a+b) [1..5000000]
15:05:25 <lambdabot>   No instance for (GHC.Num.Num [t])
15:05:26 <lambdabot>    arising from a use of `GHC.Num.+' at <...
15:05:39 <kmc_> > foldr (\a b -> a `seq` (b `seq` (a+b))) [1..5000000]
15:05:40 <lambdabot>   No instance for (GHC.Num.Num [t])
15:05:41 <lambdabot>    arising from a use of `GHC.Num.+' at <...
15:05:48 <Veinor> Prelude Data.List Data.Foldable> foldr' (+) 0 [1..5000000]
15:05:49 <Veinor> 12500002500000
15:06:07 <Veinor> replacing foldr' with foldr causes the expected overflow
15:06:26 <monochrom> > foldr (flip (+)) [1..5000000]
15:06:27 <lambdabot>   No instance for (GHC.Num.Num [t])
15:06:28 <lambdabot>    arising from a use of `GHC.Num.+' at <...
15:06:35 <monochrom> > foldr (flip (+)) 0 [1..5000000]
15:06:37 <lambdabot>   * Exception: stack overflow
15:06:38 <Axman6> > foldr f 0 [1..10]
15:06:40 <lambdabot>   Ambiguous type variable `b' in the constraints:
15:06:40 <lambdabot>    `GHC.Num.Num b' arising ...
15:06:49 <Cale> and look at that, it works ;)  http://tinyurl.com/yh3kn8c
15:06:51 <nolrai_FG> Thats odd.
15:07:01 <Axman6> > foldr (f :: Expr -> Expr -> Expr) 0 [1..10]
15:07:02 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 0)))))))))
15:07:07 <Axman6> > foldr (f :: Expr -> Expr -> Expr) 0 [1..100]
15:07:09 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 (f 11 (f 12 (f 13 (f 14 (...
15:07:30 <reltuk> Cale: nice :-p
15:07:41 <monochrom> How do you write your foldr' ?
15:07:46 <Veinor> I'm using Data.Foldable
15:07:56 <dolio> > let foldr' f z0 xs = foldl f' id xs z0 where f' k x z = k $! f x z in foldr' (+) 0 [1..5000000]
15:08:01 <lambdabot>   mueval-core: Time limit exceeded
15:08:11 <dolio> That's the definition. Which is weird.
15:08:32 <Veinor> heh, it's implemented as a foldl
15:08:32 <dolio> > Data.Foldable.foldr' (f :: Expr -> Expr -> Expr) 0 [1..10]
15:08:35 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 0)))))))))
15:08:38 <reltuk>  > foldr (\a b -> a `seq` (b `seq` (a+b))) 0 [1..5000000]
15:08:39 <Cale> http://tinyurl.com/yeg7ttk -- and another :)
15:08:48 <Veinor> oh, one last question
15:09:20 <dolio> I think that might implicitly reverse the list.
15:09:33 <Veinor> if I'm going to be implementing a class for nimbers, should I define a + b for arbitrary nimbers a, b or should I use a *+ b for that
15:09:36 <Veinor> ?
15:09:47 <Cale> Now, all that's left is to replace WordPress' mathTeX URL with mine :)
15:09:51 <Veinor> (basically, nimbers are an alternate field over the non-negative integers)
15:10:09 <dolio> So it's rather like saying "foldr' f z xs = foldl' (flip f) z (reverse xs)"
15:10:39 <dolio> > foldl' (flip f :: Expr -> Expr -> Expr) 0 [10,9..1]
15:10:40 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 0)))))))))
15:10:46 <Veinor> So basically, if I have these things that are like numbers, I should obviously define a new type for them, but should I then overload + and * for them, or should I define new operators?
15:10:59 <Twey> Cale: You drew those with TikZ?
15:11:00 <monochrom> > let foldr' f z0 xs = foldl f' id xs z0 where f' k x z = k $! f x z in foldr' (+) 0 [a,b,c]
15:11:01 <lambdabot>   a + (b + (c + 0))
15:11:18 <Yacoby> I am trying to move on from only using Haskell to solve mathamatical problems and am trying to communicate with the real world. However the code I have at the moment is giving an error that I can't fix and idk why it happens. Does anyone have any ideas: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4909#a4909
15:11:22 <kmc_> Veinor, if you can give a halfway reasonable definition for the things in Num, i'd do so
15:11:34 <kmc_> it's unfortunate that the numerical classes are not more fine-grained
15:11:52 <Veinor> yeah, I can define all the stuff in num
15:11:57 <Cale> Twey: yes
15:12:08 <Veinor> negate and abs are just going to be id, heh
15:12:10 <Cale> Twey: TikZ is awesome
15:12:29 <kmc_> :t M.Map
15:12:33 <lambdabot> Couldn't find qualified module.
15:12:38 <kmc_> :t Data.Map.Map
15:12:39 <lambdabot> Not in scope: data constructor `Data.Map.Map'
15:12:45 <kmc_> :t M.lookup
15:12:46 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
15:12:50 <kmc_> Yacoby, ^^^
15:13:03 <Twey> Cale: Nice!
15:13:43 <aavogt> what does it mean that lambdabot is now +lambdabot?
15:13:44 <lambdabot> aavogt: You have 1 new message. '/msg lambdabot @messages' to read it.
15:13:58 <kmc_> Yacoby, it works here
15:14:09 <kmc_> also "print" is putStrLn . show
15:14:31 <Yacoby> kmc_: OK, thanks.
15:14:33 <kmc_> possibly you have a fancier Data.Map in which "lookup" returns in an arbitrary MonadPlus rather than in Maybe
15:14:42 <Twey> aavogt: She got voiced
15:14:42 <kmc_> in that case, add a type signature for the result of the lookup
15:14:52 <kmc_> @vixen why do you have voice
15:14:54 <lambdabot> why not?
15:15:07 <Yacoby> Cool. Will have a play, ta for your help
15:24:40 <m0nkfish> i have a list of numbers X
15:24:58 <dibblego> I bet you don't
15:24:59 <m0nkfish> whats the most efficient way of obtaining a list of all numbers Y which are sums of two members of X
15:25:26 <SimonRC> m0nkfish: repeats allowed?
15:25:34 <mauke> join (liftM2 (+))
15:25:34 <mauke> no idea if that's efficient
15:25:58 <m0nkfish> oh and X is infinite
15:26:04 <m0nkfish> no repeats ^^
15:26:20 <hjkhjh> where re from guys
15:26:22 <hjkhjh> ???
15:26:40 <Twey> map sum $ sequence [X, X]
15:27:01 <monochrom> foldr' (+) 0 [a,b] = (\y -> (\y -> id $! (a+y)) $! (b+y)) 0
15:27:43 <SimonRC> Twey: does that work for infinite lists?
15:27:43 <monochrom> It seqs b+0 before passing it to the continuation that adds (and seqs) more.
15:27:43 <copumpkin> might want to use Omega
15:27:43 <SimonRC> what's Omega?
15:27:47 <copumpkin> @hackage control-monad-omega
15:27:48 <lambdabot> http://hackage.haskell.org/package/control-monad-omega
15:27:57 <jlouis> mauke: liftM2 lifts a binary operation into the monad. What does join do here?
15:28:25 <copumpkin> it applies it to the argument twice
15:28:36 <copumpkin> it's join on the (r ->) monad
15:28:49 <kmc_> copumpkin, looks nice
15:29:01 <copumpkin> yeah
15:29:03 <jlouis> join f x = f x x ?
15:29:09 <jlouis> in this case?
15:29:15 <copumpkin> yep
15:29:16 <dibblego> @type join
15:29:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
15:29:26 <dibblego> join :: (t -> t -> a) -> t -> a
15:29:46 <SimonRC> the problem is traversing in a sensible order I think
15:30:38 <jlouis> how does one use it on a list [1,2,3] then?
15:30:53 <jlouis> there is something with types I can't get to play correctly
15:31:13 <copumpkin> > join [[1,2], [3]]
15:31:14 <lambdabot>   [1,2,3]
15:31:35 <SimonRC> now that's a misleading example!
15:31:45 <dibblego> join :: ([]  [] a) -> [] a
15:31:53 <jlouis> mm, that is the join for the list monad suddenly :)
15:32:10 <jlouis> I was thinking of join (liftM2 (+))
15:32:22 <copumpkin> > join (liftM2 (+)) [1,2,3]
15:32:24 <mauke> jlouis: liftM2 (+) is not a list
15:32:24 <lambdabot>   [2,3,4,3,4,5,4,5,6]
15:32:37 <copumpkin> :t each
15:32:39 <lambdabot> Not in scope: `each'
15:32:42 <copumpkin> aw, I want omega
15:33:04 <Veinor> are there any implementations of ordinal numbers in haskell? :D
15:33:22 <m0nkfish> what about an ordered nCr where r=2
15:33:40 <copumpkin> Veinor: the finite ones, certainly ;)
15:33:50 <Veinor> I walked right into that one, didn't I.
15:34:10 <jlouis> Heh, ghci needed :m +Control.Monad.Reader first
15:34:24 <copumpkin> or Control.Monad.Instances
15:35:07 <Veinor> Hm.
15:35:17 <Veinor> I can't think of how to do it, to be honest.
15:36:05 <nolrai_FG> I think I read about one, had Limit as a constructor I thik.
15:36:25 <Veinor> I mean, it's obvious how to do polynomials involving omega of finite degree.
15:36:26 <copumpkin> data Ordinal = Z | Omega | S Ordinal -- maybe?
15:36:31 <jlouis> mauke: Suddenly I got it and then I became enlightened
15:36:43 <nolrai_FG> So Limit [1...] = Omega.
15:36:46 <jlouis> thanks
15:36:47 <Veinor> but how do you handle omega^omega?
15:36:48 <Veinor> :P
15:36:59 <copumpkin> it just won't terminate O:-)
15:37:15 <copumpkin> actually, it will
15:37:31 <mauke> jlouis: what is fmap fix return?
15:37:34 <copumpkin> oh, maybe not :)
15:37:36 <nolrai_FG> Limit (map (Omega ^) [1..]) ?
15:37:54 <Veinor> one way would be to define them as formal expressions in omega
15:38:12 * SimonRC goes to bed
15:38:12 <copumpkin> http://en.wikipedia.org/wiki/Ordinal_arithmetic
15:38:24 <monochrom> I think it depends on how you use ordinals.
15:38:28 <Veinor> Yeah.
15:38:48 <Veinor> I usually think of them in the combinatorial game theory sense, where addition is commutative.
15:38:57 <Veinor> but the usual sense has 1+omega = omega.
15:39:00 <copumpkin> yeah, you might have to go with the expression representation if you want to be able to compare them
15:39:39 <nolrai_FG> Yeah how else would you get true for Omega == Omega?
15:40:22 <jlouis> mauke: its the id, but I do not know why
15:40:44 <jlouis> fmap fix is the functorization/monadization of fix
15:40:54 <Veinor> anyway, yeah. i think I'm going to bash together a nimber class tonight. I just have no idea how to do division in a way that isn't O(2^n) or so.
15:41:00 <jlouis> but I can't see how
15:41:04 <jlouis> :t fmap fix
15:41:06 <lambdabot> forall a (f :: * -> *). (Functor f) => f (a -> a) -> f a
15:41:10 <copumpkin> http://blog.sigfpe.com/2008/10/whats-use-of-transfinite-ordinal.html might help
15:41:12 <Veinor> where n is the bit-length.
15:41:15 <jlouis> and :t return
15:41:26 <jlouis> gets plugged together
15:41:29 <jlouis> :t return
15:41:30 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
15:41:32 <jlouis> there
15:41:33 <Veinor> I mean, I know the simple recusive definitions for + and *, but...
15:47:06 <jlouis> @src fix
15:47:07 <lambdabot> fix f = let x = f x in x
15:49:39 <jlouis> @src fmap
15:49:40 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
15:49:50 <jlouis> ah yes, of course...
15:49:58 <monochrom> fmap fix doesn't do anything special.
15:50:17 <monochrom> For example lists. fmap fix [f, g, h] = [fix f, fix g, fix h].
15:50:41 <monochrom> For example maybe. fmap fix Nothing = Nothing, fmap fix (Just f) = Just (fix f)
15:51:09 <monochrom> For example IO. fmap fix m = do { f<-m; return (fix f) }
15:51:18 <jlouis> mmm
15:51:33 <monochrom> ask the procedure m to return a function f, then return (fix f)
15:51:47 <Veinor> just fix f, heh
15:51:53 <Veinor> I don't care what it takes, just fix it!
15:52:01 <mauke> > fix error
15:52:02 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
15:52:13 <monochrom> And if there is nothing to fix, then there is nothing to fix!
15:52:20 <Veinor> exactly! :D
15:53:13 <Veinor> fix error amuses me greatly
15:53:22 <tensorpudding> @hoogle fix
15:53:23 <lambdabot> Data.Function fix :: (a -> a) -> a
15:53:23 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
15:53:23 <lambdabot> module Control.Monad.Fix
15:54:50 <Veinor> > fix fix
15:54:51 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
15:54:54 <Veinor> :(
15:55:12 <copumpkin> > fix (const fix) (1:)
15:55:13 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:55:27 <Veinor> > fix (const fix)
15:55:31 <lambdabot>   mueval-core: Time limit exceeded
15:55:32 <tensorpudding> if isBroke x then fix x else x
15:56:12 <jlouis> I can't figure out what is going on with fmap fix return
15:56:43 <copumpkin> :t fmap fix return
15:56:45 <lambdabot> forall a. a -> a
15:56:55 <copumpkin> > fmap fix return 1
15:56:57 <lambdabot>   1
15:57:09 <monochrom> The monad is forced to the (a->) monad.
15:57:09 <jlouis> Yeah, it works like the identity function
15:57:25 <copumpkin> and return for (a->) is const
15:57:26 <dmwit> > 'o' : replicate 6 'x' ++ '{' : replicate 10 ';' ++ '>' : replicate 0 '\32'
15:57:27 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
15:57:28 <lambdabot>         against inferred ty...
15:57:28 <lambdabot> dmwit: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:57:30 <jlouis> monochrom: because of fix?
15:57:31 <monochrom> So what does fmap do for the (a->) monad?
15:57:32 <copumpkin> and fix on const x is x
15:57:33 <dmwit> aww
15:57:43 <monochrom> Because of the whole expression and type inference.
15:57:49 <jlouis> okie
15:57:49 <dmwit> > ('o' : replicate 6 'x') ++ ('{' : replicate 10 ';') ++ ('>' : replicate 0 '\32')
15:57:52 <lambdabot>   "oxxxxxx{;;;;;;;;;;>"
15:57:58 <tensorpudding> > ((fmap fix return fmap) fix return 1)
15:57:59 <lambdabot>   1
15:58:02 <dmwit> AWESOME SWORD POWER
15:58:04 <copumpkin> lol
15:58:12 <jlouis> monochrom: damn, then it is obvious :)
15:58:19 <monochrom> OK, so you probably want to see why the monad is forced to (a->) first.
15:58:29 <m0nkfish> replicate 0 '\32'?
15:58:30 <Veinor> dmwit: haha
15:58:45 <dmwit> m0nkfish: symmetry
15:58:49 <Veinor> yeah, what's that last replicate for?
15:58:51 <m0nkfish> x)
15:59:24 <copumpkin> shouldn't the blade be longer?
15:59:34 <Veinor> looks like a dagger to me
15:59:40 <copumpkin> yeah
15:59:45 <copumpkin> maybe not with a fixed-width font
16:00:03 <Veinor> no, even with a fixed-width font
16:00:16 <Veinor> the blade is about as long as the... bit you grab
16:00:26 <copumpkin> hilt?
16:00:28 <tensorpudding> the hilt?
16:00:30 <Veinor> yes, thank you
16:00:39 <Veinor>  > ('0' : replicate 6 'x') ++ ('{' : replicate 20 ';') ++ ('>' : replicate 0 '\32')
16:00:47 <Veinor> > ('0' : replicate 6 'x') ++ ('{' : replicate 20 ';') ++ ('>' : replicate 0 '\32')
16:00:48 <lambdabot>   "0xxxxxx{;;;;;;;;;;;;;;;;;;;;>"
16:01:00 <copumpkin> now it just looks like a badass dagger
16:01:22 <copumpkin> > text$ ('0' : replicate 6 'x') ++ ('{' : replicate 40 ';') ++ ('>' : replicate 0 '\32')
16:01:24 <lambdabot>   0xxxxxx{;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;>
16:01:43 <lilac> why is everyone carefully putting no space next to the tip of the dagger?
16:01:46 <Veinor> maybe if you are a silly person who uses a non-fixed-width font for IRC :P
16:02:11 <Beelsebob> > text$ ('0' : replicate 6 'x') ++ ('{' : replicate mineIsBiggerThanYours ';') ++ ('>' : replicate 0 '\32')
16:02:12 <lambdabot>   0xxxxxx{;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;...
16:02:12 <copumpkin> I used fixed-width fonts when I need things to line up
16:02:18 <copumpkin> IRC isn't one of those things
16:02:40 <Veinor> I do it because I IRC in a terminal, and variable-width fonts in a terminal are absolutely horrible
16:02:46 <kmc_> > text (('8' : replicate 10 '=') ++ "D")
16:02:48 <lambdabot>   8==========D
16:02:55 <Beelsebob> thatâ€™s why I donâ€™t IRC in a terminal Veinor
16:02:55 <copumpkin>  /ban kmc_
16:02:57 <copumpkin> oh wait
16:02:57 <Veinor> kmc_: your happy face has a long nose
16:03:01 <monochrom> fmap fix :: f(a->a) -> f a.  return :: b -> m b and has to unify with f(a->a).  So f = (b->), m b = (a->a). So m=(a->), b=a.  fmap fix return :: (a->a), fmap fix return = fix . const
16:03:07 <Beelsebob> IRC and terminal are pretty incompatible things
16:03:09 <Veinor> :D
16:03:14 <kmc_> hey you guys started it
16:03:23 <Veinor> clearly you have never used irssi
16:03:30 <Beelsebob> no, Iâ€™ve used it plenty
16:03:37 <Beelsebob> itâ€™s just worse than a good GUI client
16:03:50 <Veinor> eh, I use it because it lets me attach/detach via screen
16:03:53 <blackdog> is there a standard way to do backwards search in irssi?
16:03:59 <Vanadium> Too bad there is no good gui client
16:04:01 <Veinor> backwards search?
16:04:02 <Twey> I used fixed-width fonts for everything.
16:04:05 <Beelsebob> I use bouncers for that Veinor
16:04:05 <Twey> Because I can.
16:04:15 <Veinor> Beelsebob: bouncers?
16:04:16 <Beelsebob> Vanadium: thereâ€™s plenty of good GUI clients
16:04:28 <Beelsebob> Veinor: essentially an IRC proxy in place of the screen session
16:04:29 <dancor> stroan: ty, building wxGTK-2.8.10 from source made it so that installing wx from cabal seems to be working now.
16:04:37 <dancor> blackdog: /lastlog
16:04:41 <Beelsebob> the proxy stays logged in all the time, my client connects to it
16:04:47 <jlouis> monochrom: ah yes. Thanks
16:04:53 <Veinor> ah. well my way lets me keep chatlogs, so nyeah. :P
16:05:02 <Beelsebob> Veinor: just like my way then?
16:05:25 <Veinor> ah, I must be misunderstanding you
16:05:26 <blackdog> Beelsebob: ah, thanks. that's useful. is there a similar function that will just scroll back up?
16:05:49 <Veinor> blackdog: the pgup/pgdn keys?
16:06:52 <Veinor> I still like my way, though, because I'm usually running a barnowl session under screen anyway
16:07:00 <Veinor> so I do most of my communication inside a terminal
16:07:30 <blackdog> Veinor: sometimes i'm searching for something that happened overnight, so pgdn/pgup is a bit tedious. i still want the context, though.
16:07:55 <Twey> Veinor: Barnowl?  Google is blank
16:07:55 * Beelsebob uses the neat chat log feature in his GUI IRC client for that ;)
16:08:27 <Veinor> blackdog: /lastlog -10 text
16:08:33 <Veinor> displays 10 lines before and after
16:08:41 <Veinor> Twey: terminal client for zephyr
16:08:45 <Twey> Oh, nice
16:09:00 <Veinor> zephyr is cool :D
16:09:04 <Twey> Beelsebob: I think the point was that you don't get logs of things that happened whilst you were away
16:09:16 <blackdog> Veinor: thank you, you've solved my problem admirably
16:09:16 <Beelsebob> Twey: yeh, but with a good bouncer and a good client you do
16:09:26 <blackdog> Beelsebob: i use the screen trick too.
16:09:33 <Veinor> I actually just found out about -10 via /help lastlog, heh
16:09:56 * Twey isn't quite sure why one would want a G.U.I. I.R.C. client, though.
16:09:57 * Beelsebob doesnâ€™t see the point of sacrificing having a good IRC client just because it lets me use screen, especially when using screen doesnâ€™t actually get you any benefit
16:10:01 <lilac> > let (+)=(((++).).).(.replicate).(.).(:)in('0'+6)'x'.('{'+20)';'.('>'+0)' '$[]
16:10:03 <lambdabot>   "0xxxxxx{;;;;;;;;;;;;;;;;;;;;>"
16:10:11 <Veinor> I actually like irssi as a client.
16:10:19 <Veinor> lilac: oh god
16:10:22 <Sauliusl> hey there
16:10:36 <Beelsebob> Twey: because as discussed earlier, IRC in a terminal is rubbish â€“ it ends up with conflicting things, like chat being easily readable with sans-serif fonts, and terminals wanting fixed width
16:10:37 <copumpkin> allo
16:10:38 <Twey> I can understand G.U.I. web browsers or image editors â€” they're graphical applications, and the G.U.I. is well suited to them as such
16:10:47 <Twey> But when you're just dealing with text anywayâ€¦
16:10:55 <Beelsebob> Twey: right, as is it well suited to easily readable text
16:10:57 <Veinor> chat is just as readable with serifed/fixed-width fonts for me :/
16:10:59 <Sauliusl> can anyone give a hint on haskell + openGL? particularly how to save window to a file
16:11:01 <Beelsebob> unlike a terminal
16:11:04 <kmc_> most of the IRC i do is about programming
16:11:05 <Twey> I much prefer fixed-width fonts
16:11:06 <copumpkin> proportional text helps readability
16:11:09 <kmc_> and contains lots of code
16:11:13 <kmc_> so i like fixed width
16:11:16 <kmc_> i don't find it hard to read
16:11:21 <lilac> blackdog: there's also /lastlog <foo>, /lastlog clear, /sb goto <time from lastlog>
16:11:27 <Veinor> perhaps it is all down to personal preference? :O
16:11:33 <Beelsebob> indeed
16:11:34 <m0nkfish> no shit
16:11:36 <Twey> I don't like variable-width fonts, on the whole.  I use them for printing, sometimes, but that's about it.
16:11:42 <Twey> Veinor: *gasp* :Ã¾
16:11:51 <Veinor> is that a thorn used in an emoticon
16:11:55 <Veinor> be still, my beating heart.
16:12:00 <Twey> Why yes.  Yes, it is.
16:12:04 <kmc_> Sauliusl, do you have more specific questions?
16:12:10 <kmc_> did you find code already to do it in some other language?
16:12:39 <tensorpudding> Twey: that's a nice emoticon
16:12:46 <mauke> ãƒ„
16:12:53 <Twey> Thank you.
16:12:54 <Sauliusl> kmc_ To accomplish this programmatically, you read your image     with glReadPixels(), and use the image data as input to a     routine that creates image files.
16:12:55 <Veinor> mauke: that one took me forever to get.
16:12:55 <Twey> Heh, mauke
16:13:00 <Veinor> like, the first time i saw it.
16:13:07 <Veinor> I was wondering why everybody kept saying 'tsu'
16:13:09 * jmcarthur adds Twey's emoticon as an autoreplace
16:13:09 <Sauliusl> haskell has readPixels
16:13:10 <Twey> I was just having a conversation about katakana bastardised into emoticons in another channel.
16:13:16 <Sauliusl> though I have no idea how to use it corectly
16:13:39 <copumpkin> why use tsu instead of shi, anyway?
16:14:00 <Twey> I think the winner was either ã‹› or ãƒƒâƒ
16:14:07 <Twey> It's curvier
16:14:11 <tensorpudding> i can't read those....my unicode has failed
16:14:13 <Veinor> what's the second one?
16:14:17 <Veinor> copumpkin: shi doesn't work as well
16:14:18 <Beelsebob> both are roughly the same
16:14:24 <Twey> Small tsu and combining circle
16:14:28 <Beelsebob> just variants on the same character
16:14:48 <Twey> Beelsebob: They're actually completely different sounds.
16:14:52 <tensorpudding> there are no pretty monospace fonts that have decent unicode
16:15:07 <mauke> dejavu sans mono
16:15:13 <Beelsebob> monaco tensorpudding
16:15:15 * p_l makes do with Consolas
16:15:18 <Beelsebob> or consolas
16:15:21 <boily> terminus.
16:15:22 <tensorpudding> i have consolas!
16:15:30 * mauke uses all fonts simultaneously
16:15:31 <Beelsebob> consolas is a win font
16:15:33 <tensorpudding> that's what i'm using
16:15:39 <Veinor> I have a bad case of consolas. I think it's fatal :(
16:15:41 <tensorpudding> monaco isn't very good looking
16:15:54 <copumpkin> I use consolas too
16:15:54 <Beelsebob> I love monaco
16:15:55 <copumpkin> on a mac :P
16:15:59 <Beelsebob> ditto
16:16:02 <tensorpudding> i haven't tried dejavu mono, maybe someday
16:16:09 <Beelsebob> I used to use monaco all the time, but consolas is rather nicer
16:16:12 <Twey> á»‡
16:16:14 <tensorpudding> i used monaco on mac once
16:16:19 <tensorpudding> wasn't fond of it
16:16:19 <Twey> Everson Mono isn't half bad
16:17:30 <Veinor> âˆ ã‹›/__/\
16:17:31 <Twey> Bouncer failure?  ;)
16:17:44 <JohnnyL> have any of you needed to use a DSL ala parsec?
16:18:04 <tensorpudding> my favorite font lately has been garamond
16:18:09 <Veinor> âˆ ã‹›/__âˆ§
16:18:28 <kmc_> JohnnyL, ?
16:18:46 <kmc_> i've used parsec quite a bit
16:20:47 * hackagebot upload: xmonad-extras 0.0 - Third party extensions for xmonad with wacky dependencies (DanielWagner)
16:21:10 <JohnnyL> kmc_ Ah ok. Hm, a template language would be cool/easy I suppose.
16:21:32 <copumpkin> Veinor: here's some good stuff on ordinals by the way: http://old.nabble.com/Ordinal-induction-td25995414.html
16:25:57 <stroan> dancor: np
16:28:40 <tavelram> :t a
16:28:41 <lambdabot> Expr
16:28:50 <tavelram> :t Expr
16:28:52 <lambdabot> Not in scope: data constructor `Expr'
16:30:39 <jmcarthur> @kind Expr
16:30:40 <lambdabot> *
16:32:36 <tavelram> @src a
16:32:37 <lambdabot> Source not found. Just what do you think you're doing Dave?
16:32:57 <tavelram> are they even defined in haskell? or in the parser for lambdabot, or similiar?
16:33:24 <mauke> tavelram: they're defined in one of the modules loaded by lambdabot
16:33:26 <Cale> tavelram: They're part of the simplereflect package
16:33:38 <tavelram> oh, ok
16:33:53 <tavelram> but how are they defined? since they are only placeholders sort of?
16:33:57 <tavelram> >show a
16:33:58 <mauke> http://hackage.haskell.org/packages/archive/simple-reflect/0.2/doc/html/Debug-SimpleReflect-Vars.html
16:34:08 <tavelram> > read "a"::Expr
16:34:09 <lambdabot>   No instance for (GHC.Read.Read SimpleReflect.Expr)
16:34:10 <lambdabot>    arising from a use of...
16:34:24 <mauke> http://hackage.haskell.org/packages/archive/simple-reflect/0.2/doc/html/src/Debug-SimpleReflect-Vars.html#a actually
16:34:37 <tavelram> cheers
16:36:54 * hackagebot upload: xmonad-extras 0.9 - Third party extensions for xmonad with wacky dependencies (DanielWagner)
16:37:11 <mauke> hackagebot: <3
16:38:15 <tavelram> show [a,b,c]
16:38:23 <tavelram> > show [a,b,c]
16:38:25 <lambdabot>   "[a,b,c]"
16:38:31 <tavelram> > show a
16:38:33 <lambdabot>   "a"
16:38:42 <tavelram> oh, the space
16:40:10 <chrisdone> Cale: so what did you think of the ending to Battlestar Galactica?
16:41:37 <Federalu> Join in The new chann for irc.server   #username  #username #username #username #username #username #username #username #username #username #username #username #username #username #username #username #username #username #username #username #username
16:41:48 <copumpkin> um, yeah
16:41:51 <chrisdone> worst. spam. ever
16:42:41 <mauke> ... italians
16:42:56 <copumpkin> yeah, they suck!
16:43:38 <Cale> chrisdone: I thought it was good :)
16:45:08 <chrisdone> Cale: yeah I think it definitely had to end like that at some point, and the way they did it was good
16:45:33 <chrisdone> Cale: seen Defying Gravity?
16:46:22 <Cale> nope
16:46:26 <ivanm> is it just me, or is there a spam email on haskell@haskell.org ?
16:46:43 <copumpkin> you mean the spanish thing?
16:46:53 <copumpkin> it looks like someone accidentally the wrong email address?
16:46:54 <ivanm> copumpkin: yeah
16:46:58 <ivanm> could be
16:47:10 * ivanm looks suspiciously at copumpkin...
16:47:11 <ivanm> ;-)
16:47:20 <copumpkin> I'm not spanish!
16:48:28 <ivanm> copumpkin: doesn't mean you can't write spanish-looking spam emails...
16:48:29 <ivanm> :p
16:48:34 <copumpkin> true :)
16:50:59 <danderson> So, I'm reading some Haskell in order to attempt to gain some wisdom, and I'm wondering a little something.
16:51:02 <danderson> http://hackage.haskell.org/packages/archive/HARM/0.1.4/doc/html/src/Arm-ExecutionUnit.html#singleStep
16:51:06 <chrisdone> Cale: I quickly became addicted to it. it's a bit space opera-ish but I like it
16:51:25 <ivanm> copumpkin: aha! so you admit your culpability!
16:51:28 <danderson> This code runs in the IO monad for emulating a CPU, but it seems to me that it uses the IO monad primarily as a mechanism for sequencing operations.
16:51:31 * ivanm feels vindicated!
16:51:45 <danderson> if that is the case, wouldn't it be better to use the state monad?
16:52:44 <nipuL> how do i use not on an IO Bool?
16:52:58 <monochrom> If the emulator has to display things to user every several steps, it is stuck in IO.
16:53:02 <chrisdone> :t liftM
16:53:03 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
16:53:28 <roconnor> danderson: it would be better in a state monad
16:53:30 <nipuL> i tried that, guess i'm using it wrong
16:53:38 <danderson> monochrom: presumably that could happen at a level higher up, the execution unit itself (which manipulates only memory and internal state) could live in state
16:53:38 <roconnor> danderson: however it might be more efficient in the IO monad
16:53:43 <chrisdone> nipuL: how do you want to use it?
16:53:46 <roconnor> danderson: which could be important for CPU emulation
16:53:59 <danderson> roconnor: performance would be important, yeah. Why would it be more efficient?
16:54:00 <chrisdone> :t when
16:54:01 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
16:54:07 <chrisdone> :t whenM -- hm?
16:54:09 <lambdabot> Not in scope: `whenM'
16:54:15 <chrisdone> bah
16:54:28 <roconnor> danderson: naively the statemonad copies the entire state on state update.
16:54:38 <danderson> ah. Not good.
16:54:44 <nipuL> yeah, i'm using when not
16:55:04 <danderson> liftM not?
16:55:05 <roconnor> danderson: well, there is probably a lot of sharing between the old and new states, depending on what the state is composed of exactly.
16:55:10 <roconnor> still
16:55:14 <roconnor> even this will be relatively slow
16:55:16 <monochrom> You can use ST. STRef are as efficient as IORef.
16:55:20 <nipuL> here's the line
16:55:22 <nipuL>  when $ (liftM not) (conn `hasTable` tableName)
16:55:33 <nipuL> hasTable :: Connection -> String -> IO Bool
16:55:42 <roconnor> ya, using ST would probably imporve the code.
16:55:48 <copumpkin> ivanm: damn, you trapped me!
16:55:54 <ivanm> mwahahahah!
16:56:05 <danderson> roconnor: well, the state is mostly a set of registers (16 or so), some flags, and a memory array.
16:56:15 <monochrom> If you use State, you use immutable data structures. This is fast or slow depending on which immutable data structure.
16:56:18 <danderson> maybe a couple other knobs, but it's pretty much state heaven, it's what a cpu does :)
16:56:22 <Cale> Argh, I hate regular-expression based parsers!
16:56:23 <roconnor> the memory array would be copied on every update.
16:56:35 <roconnor> in ST there is STArray
16:56:41 <danderson> right. So I need to take a look at ST. I didn't know about it.
16:56:42 <monochrom> Cale: on that tangent, I hate escaping.
16:56:47 <copumpkin> @let maybeNot Nothing = Just undefined; maybeNot (Just _) = Nothing;
16:56:49 <lambdabot>  Defined.
16:57:05 <roconnor> danderson: is it is like IO, but restricted to memory operations only
16:57:11 <chrisdone> nipuL: yeah, when is not monadic. (liftM not) (conn `hasTable` tableName) :: IO Bool, not Bool. try: doesntHave <- liftM not $ (conn `hasTable` tableName); if doesntHave then ..
16:57:15 <copumpkin> :t maybeNot
16:57:16 <roconnor> danderson: this allows a "runST" command to safely exist.
16:57:17 <lambdabot> forall t a. Maybe t -> Maybe a
16:57:20 <danderson> that sounds exactly like what the bowels of the CPU needs
16:57:32 <danderson> thanks!
16:57:35 <zygoloid> @type when $ (liftM not) (?conn `?hasTable` ?tableName
16:57:36 <lambdabot> parse error on input `?hasTable'
16:57:44 <ivanm> > fromJust . maybeNot $ Nothing
16:57:45 <lambdabot>   * Exception: Prelude.undefined
16:57:46 <chrisdone> :t when
16:57:47 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
16:58:02 <chrisdone> :t liftM not $ getLine >> return False
16:58:03 <lambdabot> IO Bool
16:58:09 <chrisdone> see, they don't fit
16:58:54 <chrisdone> if you want a function it should be :: (Monad m) => m Bool -> m a -> m a (or something)
16:59:20 <roconnor> :t  (liftM not $ getLine >> return False) >>= \b -> when b ?foo
16:59:22 <lambdabot> (?foo::IO ()) => IO ()
16:59:45 <roconnor> :t  do { b <- (liftM not $ getLine >> return False); when b ?foo }
16:59:46 <lambdabot> (?foo::IO ()) => IO ()
16:59:50 <zygoloid> @type liftM (when . not) (?hasTable ?conn ?tableName)
16:59:50 <lambdabot> forall (m :: * -> *) t t1 (m1 :: * -> *). (Monad m, ?hasTable::t -> t1 -> m1 Bool, ?conn::t, ?tableName::t1, Monad m1) => m1 (m () -> m ())
17:00:55 <chrisdone> :t let whenM pm f = pm >>= (\p -> if p then f else return ()) in whenM
17:00:56 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
17:01:31 <chrisdone> nipuL: do you get it?
17:02:53 <nipuL> nope, completely lost
17:02:56 <nipuL> :)
17:03:15 <chrisdone> what type is this?: (liftM not) (conn `hasTable` tableName)
17:04:05 <gOcOOl> why is there a strict version of foldl but not one for foldr?
17:04:30 <copumpkin> it makes sense for foldl but not for foldr
17:04:54 <monochrom> because it is an exercise left to the reader
17:05:02 <copumpkin> foldl has an "accumulator"
17:05:06 <chrisdone> nipuL: start from the first step, what type is: conn `hasTable` tableName
17:05:19 <nipuL> Connection -> String -> IO Bool
17:05:30 <gOcOOl> copumpkin: so does foldr, right?
17:05:31 <copumpkin> which will accumulate thunks if you don't ask it not to
17:05:36 <chrisdone> nipuL: and what type is: liftM not
17:05:45 <copumpkin> no, it's not accumulating anything
17:05:57 <nipuL> um, m Bool -> m Bool ?
17:06:01 <copumpkin> foldr will produce a value immediately if given a non-strict function
17:06:13 <copumpkin> it can also short-circuit
17:06:29 <chrisdone> nipuL: yes. so what type is (liftM not) (conn `hasTable` tableName)?
17:06:48 <nipuL> m Bool
17:07:01 <chrisdone> sure
17:07:53 * gOcOOl is working through the last few statements :)
17:08:11 <chrisdone> nipuL: so you what type of function do you need to test that value?
17:08:24 <copumpkin> one way to look at it is to say that foldl is tail recursive in the traditional sense
17:08:36 <copumpkin> @src foldl
17:08:37 <lambdabot> foldl f z []     = z
17:08:38 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
17:08:59 <copumpkin> it uses z as its accumulator, and charges blindly through xs without paying any attention to the function f
17:09:03 <copumpkin> @src foldr
17:09:03 <lambdabot> foldr f z []     = z
17:09:04 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:09:11 <copumpkin> foldr is more considerate, and gives immediate control to f
17:09:28 <chrisdone> nipuL: consider: Monad m => m Bool -> m () -> m (). what do you think this function might do?
17:09:36 <copumpkin> if f needs its second argument, foldr recurses, but otherwise foldr gets out of the way
17:10:25 <gOcOOl> ahhhhh ok, this has finally clicked! :)
17:10:39 <gOcOOl> I think i now understand why foldr doesn;t really accumulate anything
17:10:48 <nipuL> honestly, i have no idea
17:10:57 <copumpkin> :)
17:11:05 <nipuL> it takes bool and a monad as a function and returns a monad?
17:11:13 <gOcOOl> and also understand the tail recursiveness of foldl
17:11:47 <copumpkin> nipuL: a monad is actually something like IO or Maybe, not values of IO x or Maybe y :)
17:11:51 <chrisdone> nipuL: sure. it takes an *action* returning a Bool, an *action* returning unit, and finally returns an action returning unit
17:12:07 <zong_sharo> Loading package gd-3000.4.0 ... can't load .so/.DLL for: pthread (/usr/lib64/libpthread.so: invalid ELF header) <- Huh?
17:13:00 <heatsink> I have a style question.
17:13:08 <chrisdone> @let whenM predicateAction whenTrue = do predicate <- predicateAction; if predicateAction then whenTrue else return ()
17:13:09 <lambdabot>  <local>:3:69:
17:13:09 <lambdabot>      Couldn't match expected type `Bool' against inferred type...
17:13:24 <heatsink> Use apostrophes (not prime) in variable names?  let dontErase = True or let don'tErase = True ?
17:13:40 <mauke> let erase = False
17:14:02 <chrisdone> @let whenM predicateAction whenTrue = do predicate <- predicateAction; if predicate then whenTrue else return ()
17:14:03 <lambdabot>  Defined.
17:14:06 <chrisdone> bloody dabbrev
17:14:08 <heatsink> yes, actually this is more like let {dontErase = Just; erase = const Nothing}
17:14:30 <gOcOOl> copumpkin: so when one says, foldl' is the strict version of foldl, that means that foldl' fully evaluates (f acc x) before moving on to the next element in the list?
17:14:56 <copumpkin> well, I wouldn't say fully evaluates, but it seqs it to prevent a buildup of thunks, at least
17:15:05 <heatsink> gOcOOl, It only evaluates to weak head-normal form.  The outermost constructor is fully evaluated.
17:15:17 <chrisdone> > whenM (return True) undefined
17:15:18 <lambdabot>   No instance for (GHC.Show.Show (m ()))
17:15:18 <lambdabot>    arising from a use of `M132366257...
17:15:19 <gOcOOl> ok, got it
17:15:40 <chrisdone> ah it's late I'moff
17:16:10 <heatsink> chrisdone: o'kay good'night
17:16:56 <nipuL> thanks for you help
17:17:32 <nipuL> it must be frustrating dealing with type noobs :)
17:18:09 <MyCatVerbs> nipuL: No.
17:18:40 <MyCatVerbs> Not really. Nobody sticks around in #haskell for any length of time who doesn't like helping newbies. ^^
17:20:16 * Cale watches as all the LaTeX code on the site gets redirected through his rendering server :)
17:20:27 <copumpkin> :o
17:20:33 <Cale> CPU pegged for a few minutes :)
17:20:47 <copumpkin> mm pegging
17:21:10 <Cale> Hopefully it all *works* this time :)
17:21:56 <Cale> ah, good, finally everything is in order :)
17:24:22 <Cale> http://analogical-engine.com/wordpress/?p=12 -- and diagrams are working :)
17:25:01 <copumpkin> that link doesn't load for me :(
17:25:02 <heatsink> pretty
17:25:07 <copumpkin> private?
17:25:17 <heatsink> Remove the last part of the path
17:25:37 <copumpkin> yeah, that worked for me
17:25:47 <Cale> oh, is it unpublished?
17:25:50 <Cale> ah
17:26:05 <heatsink> Are the permutation diagrams tex also?
17:26:20 <copumpkin> ooh purty
17:26:26 <copumpkin> string diagrams
17:26:27 <Cale> heatsink: They would be now.
17:26:34 <Cale> Refreshed? :)
17:26:37 <copumpkin> yep
17:27:04 <Cale> I had made a mistake before. Wordpress makes it kind of tricky to tell what other people see so long as you're logged in.
17:27:35 <copumpkin> yeah
17:28:10 <Cale> Now, might as well put up my first one on adjunctions while I'm at it.
17:29:30 <Cale> I wish the "Choose files to upload" button in wordpress actually did anything.
17:29:45 <copumpkin> adjunctions never get tenure :/
17:32:15 <Cale> Specific examples of adjunctions get tenure ;)
17:32:45 <Cale> (particularly if they are new)
17:37:06 <heatsink> You've paid attention to accessibility as well.  With the tikz commands included in the title text, non-graphical users won't miss anything.
17:38:24 <Cale> ;)
17:39:07 <Cale> That actually caused a lot of hassle. The wordpress plugin was idiotically making replacements inside that title text and screwing the HTML up badly.
17:39:39 <ivanm> Cale: yeah, I hate it when wordpress.com won't let you replace a file with a mistake in it
17:39:46 <heatsink> huh.
17:39:51 <ivanm> instead, you can delete the old file and then upload another one with a new name :s
17:42:08 <copumpkin> wordpress is pretty shitty in general
17:43:33 <Nafai> it's PHP :)
17:43:44 <shepheb> but it renders LaTeX, so it gets a pass in my book
17:44:29 <Cale> shepheb: It doesn't do that on its own
17:44:49 <shepheb> true, I suppose.
17:45:22 <Cale> shepheb: It does it kicking and screaming after you install a plugin which talks to another server to generate the images. Even then, the plugin is so bad when you get it that it generates invalid HTML half the time and screws up your pages badly.
17:45:53 <Cale> updated. A little remark about adjunctions with more pretty diagrams :)
17:46:53 <Cale> oh, oops
17:47:10 <Cale> I seem to have messed up my diagram convention :P
17:47:52 <ivanm> Nafai: so, we need to write HackPress? :p
17:48:11 <monochrom> We need fewer blogs.
17:48:11 <Cale> For a while I couldn't decide which one I wanted to use
17:49:41 <copumpkin> monochrom: you should start a blog outlining your opinions on why there are too many blogs
17:50:57 <monochrom> That is silly.
17:51:08 <monochrom> I mean that would be silly.
17:51:13 <danderson> roconnor: just a quick followup to the ST stuff if you have a second
17:51:32 <ivanm> copumpkin: heh
17:51:45 <danderson> from what I read, if a value exits the ST monad, then an immutable copy needs to be made; is that correct?
17:51:47 <copumpkin> monochrom: fine, I'll start a blog in your honor
17:51:59 <copumpkin> danderson: not necessarily
17:52:22 <roconnor> danderson: generally
17:52:24 <ivanm> the "monochrom-didn't-want-a-blog blog" ?
17:52:26 <copumpkin> unless you're talking about a new outer constructor
17:52:37 <copumpkin> ivanm: yeah, something like that
17:54:09 <danderson> I see. So exiting ST for an emulator would be bad, resulting in a copy of core memory each time
17:54:49 <roconnor> danderson: there is unsafeFreeze
17:54:58 <roconnor> but it is potentially unsafe
17:55:45 <roconnor> presumably you don't want to copy core memory outside the ST monad very often.
17:55:53 <danderson> that sounds like a way to shoot myself in the foot with high efficiency, given my knowledge of haskell.
17:56:21 <danderson> roconnor: what I'm trying to do is keep the CPU core as pure as possible (which is in ST, not IO)
17:56:37 <danderson> but still being able to exit back out to IO from time to time to do things like display updates or sound output
17:56:45 <ivanm> @remember danderson [using unsafeFreeze for an ST action] that sounds like a way to shoot myself in the foot with high efficiency, given my knowledge of haskell.
17:56:45 <lambdabot> Done.
17:56:52 <roconnor> danderson: there is STtoIO?
17:56:57 <roconnor> @hoogle ST a -> IO a
17:56:58 <lambdabot> Did you mean: ST a a -> IO a /count=20
17:56:58 <lambdabot> Control.Exception evaluate :: a -> IO a
17:56:58 <lambdabot> Control.OldException evaluate :: a -> IO a
17:57:05 <roconnor> @hoogle ST a a -> IO a
17:57:06 <lambdabot> Control.Monad.ST stToIO :: ST RealWorld a -> IO a
17:57:06 <lambdabot> Control.Monad.ST.Lazy stToIO :: ST RealWorld a -> IO a
17:57:06 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
17:57:18 <roconnor> hmm
17:57:23 <copumpkin> ST a a would be weird
17:58:04 <roconnor> danderson: do you need to copy the entire core memory to display updates or sound output?
17:58:36 <danderson> roconnor: no. I specifically want to avoid it.
17:59:13 <danderson> one solution would be to just run everything in IO, but if possible I'd like to make the bits that don't need IO run in ST
17:59:30 <danderson> maybe that's just me being too pedantic :)
17:59:42 <roconnor> danderson: perhaps stToIO would be good for you to use.
17:59:47 <danderson> yeah, looks like
17:59:59 <danderson> the implementation surprises me a bit
18:00:05 <danderson> stToIO (ST m) = IO m
18:00:07 <roconnor> I think it might be appropriate in this situtation.
18:00:14 <mauke> @src stToIO
18:00:15 <lambdabot> stToIO (ST m) = IO m
18:00:30 <roconnor> danderson: GHC implement ST as simply IO.
18:01:00 <roconnor> in GHC the ST commands are exactly the corresponding IO commands If I understand correctly.
18:01:11 <roconnor> @src runST
18:01:12 <lambdabot> runST st = runSTRep (case st of { ST st_rep -> st_rep })
18:01:20 <roconnor> @src runSTRep
18:01:20 <lambdabot> runSTRep st_rep = case st_rep realWorld# of (# _, r #) -> r
18:01:28 <roconnor> meh
18:01:38 <roconnor> best not to look at the source of this stuff in GHC
18:01:44 <danderson> heh
18:02:24 <danderson> okay, but the bottom line is that stToIO should be perfectly zero-copy then, since the operation is no-op other than the type change
18:02:31 <danderson> which sounds good.
18:03:20 <roconnor> danderson: yes.
18:03:31 <danderson> Thanks again. It'll probably take me a while before I get anything working, but at least now I have half of an idea how to proceed.
18:04:26 * roconnor wonders what Lazy.stToIO is.
18:04:56 <roconnor> is it like unsafeinterleaveIO?
18:08:10 <danderson> actually, that prompts another question
18:08:35 <Cale> heh, I only managed to fool myself into thinking that the convention was backward ;)
18:08:43 <danderson> ST.Lazy explains that >>= and >> in that monad are non-strict, and gives as an example runST (writeSTRef _|_ v >>= readSTRef _|_ >> return 2) = 2
18:08:59 <danderson> what is _|_ here? Never seen that, and I can't get ghci to explain.
18:09:12 <Cale> danderson: anything whose evaluation never terminates
18:09:24 <danderson> aaah.
18:09:24 <Cale> danderson: so, like  undefined  or  let loop = loop in loop
18:09:39 <danderson> right, gotcha
18:09:46 <danderson> okay, so now the example suddenly makes sense.
18:09:49 <danderson> Thanks.
18:09:52 <Cale> by extension, the equation will hold for any value
18:10:54 <roconnor> oh, Lazy.stToIO is for the lasty ST monad, not for lazy IO.
18:10:57 <roconnor> lazy
18:11:37 <danderson> hmm, and so this brings another design question: by default, should I use lazy or strict ST?
18:12:05 <Cale> Chew new Lasty ST Gum! It lasts until _|_!
18:12:11 <copumpkin> lol
18:12:15 <danderson> presumably in my case, the state eventually gets used, but building a lazy cpu triggers my spidey sense. And I don't have enough experience to know if that's good or bad.
18:12:18 * roconnor has forgotten the difference.
18:12:46 <monochrom> @remember Cale Chew new Lasty ST Gum! It lasts until _|_!
18:12:47 <lambdabot> Good to know.
18:13:52 <danderson> hmm, coming from a stateful world, I guess I'll start with strict ST, which hurts my brain less.
18:14:01 <danderson> Then I'll swap it out for ST.Lazy and see what happens.
18:14:17 <danderson> what could possibly go wrong!
18:14:24 <Cale> danderson: yeah, unless you know you need the laziness, it's a little unnatural for most applications of ST.
18:14:25 <roconnor> nothing!
18:14:39 <roconnor> Cale: what's the difference?
18:14:46 <danderson> although I like the idea of a lazy CPU
18:14:54 <danderson> don't compute any state until something wants it
18:16:14 <Cale> roconnor: iirc, let vs. case in the definition of >>=
18:16:45 <roconnor> @src ST
18:16:45 <lambdabot> newtype ST s a = ST (STRep s a)
18:16:48 <roconnor> @src Lazy.ST
18:16:49 <Cale> The implementation of the lazy ST monad in GHC breaks my brain at the moment though
18:16:49 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
18:17:05 <Cale> It's lazy-unsafe-IO-a-licious.
18:17:45 <roconnor> I have this suspicion that I've used both before
18:17:54 <roconnor> so I must have understood at one point in time.
18:18:55 <danderson> @src Ix
18:18:56 <lambdabot> class (Ord a) => Ix a where
18:18:56 <lambdabot>     range           :: (a,a) -> [a]
18:18:56 <lambdabot>     index           :: (a,a) -> a -> Int
18:18:56 <lambdabot>     inRange         :: (a,a) -> a -> Bool
18:18:56 <lambdabot>     rangeSize       :: (a,a) -> Int
18:18:58 <roconnor> oh I see the example danderson mentioned.
18:19:43 <roconnor> mmm fixST
18:20:21 <roconnor> @hoolge fixST
18:20:21 <lambdabot> Control.Monad.ST fixST :: (a -> ST s a) -> ST s a
18:20:22 <lambdabot> Control.Monad.ST.Lazy fixST :: (a -> ST s a) -> ST s a
18:24:22 <Lemmih> augur: I once wrote a program named 'augur'.
18:24:57 <augur> I know you did, Lemmih.
18:25:45 <augur> I am that program, unleashed onto the infinite expanse of the internet and allowed to roam free until it achieved sentience.
18:26:21 <shapr> yay!
18:26:50 <dmwit> ?remember augur <Lemmih> augur: I once wrote a program named 'augur'. <augur> I am that program, unleashed onto the infinite expanse of the internet and allowed to roam free until it achieved sentience.
18:26:50 <lambdabot> Nice!
18:26:52 <Lemmih> Oh dear Lord, I knew it was a bad idea to let you contact Google!
18:27:24 <dmwit> Google: the new Central Intelligence Agency.
18:30:20 <ksf> so, can anybody who can use the term "existential quantifications" without blinking or getting it wrong tell me whether issue9's interfaces are really typeclasses?
18:30:29 <shapr> Is there an echo?
18:30:54 <augur> ksf: what
18:31:51 <ksf> http://golang.org/doc/go_spec.html#Interface_types
18:32:28 <danderson> not quite I think was the verdict from earlier, followed by "but why discuss it here again?"
18:33:41 <ksf> because I didn't participate in the discussion?
18:34:06 <ksf> after all, our universe has billions of centres, you know.
18:34:57 <danderson> I meant that was how the previous discussion of it ended. It finished in a sort of "who cares, it's not haskell" :)
18:36:05 <ksf> it's definitely a win for haskell if issue9 takes off, though.
18:36:09 <danderson> iirc the main difference is that in Go, objects don't need to declare their implementation of an interface
18:36:38 <danderson> if they satisfy the criteria, they implement it de facto, and the compiler can figure that out statically
18:36:40 <ksf> and we can change our tutorials from "not oop as you know it" to "oop as you know it from issue9"
18:36:52 <ksf> yep.
18:37:14 <ksf> I'm wondering what happens if you have partly-satisfied criteria.
18:37:16 <reltuk> issue9 == go?
18:37:30 <roconnor> ksf: I know what existential quantifications are.
18:37:32 <ksf> issue9 is google's new language. go is older.
18:37:39 <danderson> no, it's not :)
18:37:48 <ksf> the internets have decided.
18:37:50 <danderson> Go! is the older language, Go is google's new language until it changes
18:37:54 <ksf> it's called issue9.
18:37:58 <danderson> no they haven't, the reddit peanut gallery decided
18:38:04 <danderson> and was very retarded about it too
18:38:36 <danderson> anyway, to answer your question, if an object implements only part of an interface in go, it doesn't implement it
18:38:36 <ksf> but everybody agrees, but you!
18:38:47 <reltuk> so it must be true :-p
18:38:52 <ksf> no defaulting?
18:38:56 <danderson> which encourages the development of small, to the point interfaces
18:39:03 <danderson> I don't think so, no.
18:39:10 <danderson> mark one up for typeclasses
18:39:12 <roconnor> I think I'm missing something here
18:39:52 <ksf> I think people will soon call for interface combination (to circumvent that nasty word "inheritance")
18:40:13 <danderson> I think you can do that already somehow
18:40:17 <ksf> duh. they are, at least in haskell.
18:40:24 <ksf> that is, have a better way of doing it.
18:40:38 <danderson> although I'm unclear on the details, haven't looked deeply into it
18:41:06 <danderson> but presumably there's a way to express a type constraint across multiple interfaces
18:41:40 <reltuk> why would this language take off?
18:41:52 <ksf> because it's quite cool.
18:42:17 <ksf> less ad-hoc and well-rounded than D.
18:42:28 <ksf> er more well-rounded
18:42:52 <ksf> there's certainly some sharp corners left, but the core looks quite sane.
18:43:04 <danderson> it has some features going for it (and orthogonality of features), it's a reasonably incremental step up from other systems languages
18:43:18 <danderson> and damn, instant compilation is sexy
18:44:16 <danderson> it also has people hating on the syntax already
18:44:34 <ksf> but syntax is easy to fix.
18:44:37 <danderson> which, if python is to be believed, is a reasonable predictor of success ;)
18:44:47 <ksf> on a quick glance, it's regular enough to support layout.
18:45:13 <danderson> most of the hate isn't really grounded in reason, more along the lines of "But that's not how other languages work! Put it back! Put it back!!"
18:45:44 <danderson> except for a few where the team said "yeah, we started out like that, but in practice after writing some code, this other way is less confusing"
18:45:53 * ksf wonders how embeddable it is.
18:46:01 <ksf> ...as a haskell edsl, that is.
18:48:35 <danderson> anyway, interesting little language they came up with, it'll be interesting to see what happens once the peanut gallery goes away and they can get stuff done again
18:49:17 <ksf> the name "issue9" is going to stick, even if they don't rename it, there's going to be a gazillion people calling it that way.
18:49:47 <dmwit> You know what's easier to search for than "go"?
18:49:49 <dmwit> "issue9"
18:50:02 <dmwit> ...basically anything, really
18:50:11 <danderson> meh. I've only seen that on reddit and irc, which suggests to me that it'll go away the next time the internet mass gets distracted by something shiny
18:50:55 <ksf> no. the naming issue being number 9 and the plan9 inheritance are too much of a coincedence. it's a sign from the namespace gods.
18:51:45 <FunctorSalad_> dmwit: but google *controls* google...
18:51:58 <FunctorSalad_> they can make google find go :o
18:52:13 <danderson> we could, but it's unlikely we would
18:52:18 <FunctorSalad_> in fact, maybe that's the whole idea behind the name *conspiracy*
18:52:26 <FunctorSalad_> j/k :)
18:53:16 <danderson> what makes me sad is the string of comments on that issue in the issue tracker
18:53:30 <danderson> clearly the combined IQ of slashdot and reddit is way lower than I imagined :(
18:53:41 <FunctorSalad_> which issue?
18:53:55 <danderson> http://code.google.com/p/go/issues/detail?id=9
18:54:03 <danderson> which started this whole "issue9" crap
18:57:54 <ksf> danderson, you don't understand. it's a matter of principle. the internet can't allow google to be stronger than the internet.
18:58:28 <danderson> I do understand, but honestly, the original text of the issue drove home the point quite enough
18:58:47 <danderson> but somehow reddit figured this was just another comment thread where everybody's noise was welcome
18:59:16 <ksf> I don't think many registered at google code to post there.
18:59:23 <ksf> ...they already had accounts.
19:00:08 <danderson> having an account doesn't imply an obligation to post a comment that adds nothing to the situation
19:00:19 <ksf> well, I didn't post.
19:00:30 <danderson> comments 1 through 5 are useful data
19:00:37 <danderson> after that, it degenerates into noise
19:00:38 <Cale> Ahaha, someone suggested the name "Goat Special Edition"
19:00:42 <danderson> for 450 comments
19:00:56 <danderson> that's not expressing the voice of the internet
19:01:15 <danderson> that's just making reddit look like a pack of illiterate idiots
19:01:25 <nornagon> (accurate)
19:01:46 <danderson> (as I live in Switzerland, I exercize my right to remain neutral)
19:01:58 <ksf> well, there's those that deem themselves to be too smart to merely post issue9++
19:02:11 <ksf> ...and there isn't a poll interface.
19:02:19 <danderson> actually, the best signal is to star the issue
19:02:23 <danderson> you get pinged when there are updates
19:02:26 <copumpkin> zomg switzerland
19:02:31 <danderson> and the star count is visible in the issue tracker
19:03:08 <danderson> (and for example, the engineers working on the project hosting platform prioritize new features by star count)
19:03:22 <ksf> ...if you enable it.
19:03:37 <ksf> and it's already the most prominent, by leagues.
19:03:39 <danderson> otoh, "+1 for blah" comments add nothing, they give no easily aggregatable data
19:04:13 <danderson> ksf: my point exactly. If those 450 people had shut up and just starred the issue, the end result would be exactly the same, minus a few wasted bytes in a bigtable somewhere
19:04:51 <danderson> anyway, we'll see what happens.
19:05:01 <copumpkin> by wasting those bytes, they're sticking it to The Man
19:05:17 <ksf> oh. don't tell me google's disk space is going to run out.
19:05:22 <danderson> not really, the actual devs ignored pretty much everything but the actual issue
19:05:29 <dolio> reddit only looks like a pack of illiterate idiots? :)
19:05:31 <danderson> the only people it aggravates are those like me who see it on reddit
19:06:02 <danderson> ksf: well, we're switching to bzip2, that should buy us a little bit.
19:07:36 <copumpkin> there was a really disturbing post on reddit today, but that probably belongs in #haskell-blah
19:07:51 <Cale> "How about BING (Bing Is Not Go!)?"
19:07:54 <ksf> dolio, that's to the point. it looks like a pack, but actually is a mob.
19:08:09 <dolio> Heh.
19:09:11 <dbelange> hello friends
19:09:15 <dbelange> how do i use go in haskell
19:09:21 <Cale> 'Go' is too uncommon a word. They should call it 'an'.
19:09:37 <Cale> Or 'the'
19:09:48 <blackdog> slightly mischievous question: is there a pattern in the design patterns book that isn't trivially solved by higher-order functions?
19:09:52 <mauke> dbelange: lgo or rgo?
19:10:07 <Cale> "Have you used the the programming language?"
19:10:23 <danderson> the one suggestion that made me laugh is "The language formerly known as Go"
19:10:28 <danderson> shortened to "the language"
19:10:32 <blackdog> (i keep getting questions in interviews about things like the Factory pattern, which appears to be a way of passing in an object without knowing its concrete type)
19:10:36 <mauke> call it 'the programming programming language'
19:10:39 <muri_one> It would be awsome if you guys were talking about Go! and how it relates to haskell. rather than reddit and some naming controversy
19:10:45 <dbelange> danderson: A Programming Language?
19:10:54 <dbelange> Been done.
19:10:59 <mauke> then you can ask: have you used the the programming programming language language?
19:11:17 <danderson> and then everyone thinks you mean java.
19:11:50 <danderson> and on that note, back to more haskelly concerns, as muri_one suggests
19:11:51 <nornagon> snap
19:13:04 <twb> Haddock question: I can't currently use Unicode codepoints like â†’, but can I use HTML entities like &rarr;?
19:18:18 <ksf> hmmm issue9 uses _ with the same semantic as haskell
19:18:26 <ksf> those guys _must_ have had a look.
19:19:49 <Cale> They should just rename the language to issue9.
19:20:12 <Cale> Ah, ksf already had that idea :)
19:20:24 <dmwit> He wasn't the first, either.
19:21:47 <ksf> twb, the proof of the pudding is in the eating.
19:22:15 <mxc> ?pl (\(i,v) -> (i, f v))
19:22:16 <lambdabot> second f
19:22:52 <mxc> :info second
19:23:44 <dmwit> ?index second
19:23:45 <lambdabot> Control.Arrow
19:23:52 <Cale> It seems like a mostly pretty unambitious language as far as language features are concerned. But then, being ambitious seems like a bad thing for popularity.
19:23:54 <mxc> ty
19:24:12 <ksf> no rocket science, no.
19:24:17 <ksf> but that's also a good thing.
19:24:36 <Cale> How do you write 'map' in issue9?
19:24:55 <twb> ksf: I guess that means "TIAS"
19:24:56 <ksf> dunno, I'm still reading the spec.
19:25:04 <ksf> yep.
19:25:19 <HaudRex> Is there an extension that allows "instance Eq (forall a. (a -> a)) where"
19:25:28 <ksf> what I was looking for was a translation of "probieren geht ueber studieren", and dict.leo.org came up with the pudding.
19:25:34 <HaudRex> universal quantification in instance declarations
19:25:52 <ksf> ("trying trumps study")
19:25:59 <copumpkin> HaudRex: don't think so
19:25:59 <Cale> HaudRex: hmm. Have you tried impredicativity?
19:26:13 <copumpkin> (which is now deprecated)
19:26:31 <ksf> Cale, it's definitely possible, though. there's for loops, and lambdas.
19:26:46 <Cale> ksf: What would its type be?
19:26:50 <Cale> :t map
19:26:51 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:26:51 <ksf> how the types match up and whether you can do fmap remains to be seen...
19:27:04 <FunctorSalad_> HaudRex: you can do that if you newtype it
19:27:07 <Cale> I don't think you can even write normal map, since there are no type variables.
19:27:32 <copumpkin> I'd think that a structure would just need to implement a method called map?
19:27:51 <HaudRex> ooh, let's try newtype
19:27:55 <Cale> copumpkin: So that every single type of list would have its own implementation?
19:27:57 <FunctorSalad_> no type variables?
19:28:08 <Cale> FunctorSalad_: in issue9 (go)
19:28:09 <HaudRex> impredicativity did not work
19:28:13 <FunctorSalad_> are they seriously reviving java lists-of-objects? :(
19:28:24 <FunctorSalad_> that used to be the suck
19:28:48 <HaudRex> Java list-of-objects?
19:28:56 <HaudRex> Who needs that when you have HList?
19:28:57 <HaudRex> :)
19:29:07 <copumpkin> Cale: you might be right
19:29:16 <FunctorSalad_> before there were generics, the standard library lists held only `Object's, so you always needed to downcast
19:29:18 <FunctorSalad_> IIRC
19:29:19 <copumpkin> Cale: looking through their container hierarchy there's nothing remotely higher-order
19:29:57 <FunctorSalad_> here we higher-order for breakfast.
19:30:32 <ksf> the stdlib uses iterators
19:31:02 <FunctorSalad_> with downcasts or what?
19:31:11 <copumpkin> http://golang.org/src/pkg/container/list/list.go#L189
19:31:15 <FunctorSalad_> or is there just no one list type [constructor]
19:32:55 <FunctorSalad_> hmm it contains "Value interface{};"s
19:33:00 <ksf> ah. eg, in the sort package, there's the interface "Interface", consisting of Len, Less, and Swap.
19:34:13 <HaudRex> hmm
19:34:26 <ksf> ...so provinding a [A] -> [B] map seems to bog down to providing an interface to disect an [A] and construct a [B]
19:34:29 <HaudRex> newtyped it compiles, but doesn't actually work
19:34:47 <ksf> so the way to go would most likely be implementing cata and ana interfaces.
19:34:59 <FunctorSalad_> newtype X = X (forall a. a -> a)
19:35:00 <FunctorSalad_> ?
19:35:28 <FunctorSalad_> oO ( cathy and anna )
19:35:58 <tensorpudding> oh, it's functorsalad
19:36:03 <FunctorSalad_> and don't forget the ratamorphisms...
19:36:13 <FunctorSalad_> @quote chase the
19:36:13 <lambdabot> No quotes for this person. :(
19:36:24 <FunctorSalad_> @quote ratamorphism
19:36:25 <lambdabot> No quotes match. Wrong!  You cheating scum!
19:36:26 <tensorpudding> that guy people on freenode keeps thinking i'm related to
19:36:27 <FunctorSalad_> @quote rattamorphism
19:36:28 <lambdabot> No quotes match. The more you drive -- the dumber you get.
19:36:30 <HaudRex> No, it does!
19:36:35 <HaudRex> It does work. Stupid me.
19:36:46 <tensorpudding> because of my nick
19:37:09 <c_wraith> math structure + food is an equivalence class?
19:37:09 <copumpkin> tensorpudding: maybe you are, and just don't know it!
19:37:29 <tensorpudding> i don't think so
19:38:04 <FunctorSalad_> in the math channels "IdentityTomato" and "MorphismSteak" were also suggested to me.
19:38:07 <c_wraith> now you're in here three times!
19:39:18 <tensorpudding> yes, i hang in #math a lot of the time
19:39:24 <tensorpudding> and people there know you
19:39:29 <FunctorSalad_> :o
19:40:17 <FunctorSalad_> but you came up with that name scheme independently?
19:41:47 <tensorpudding> yes
19:41:49 <tensorpudding> i think
19:42:00 <tensorpudding> i saw you on #haskell back when i had my old nick
19:42:44 <tensorpudding> it might have been unconscious inspiration
19:49:17 <MonadRagout> you can use "type Any interface { }" to implement Dynamic in issue9 and do a map with run-time casts.
19:49:30 <MonadRagout> that's not even close to good.
19:50:33 <mmorrow> "let's call void* something a little less scary, and call it convenience!"
19:51:44 <ToposTartare> lol
19:52:30 <tensorpudding> ToposTartare?
19:52:34 <ToposTartare> what?
19:52:46 <tensorpudding> what is a tartare?
19:52:50 <ivanm> a sauce
19:52:54 <ivanm> that goes well with seafood!
19:52:57 <tensorpudding> ah
19:53:07 <ToposTartare> I was actually thinking of steak tartare
19:53:09 <tensorpudding> so it's another <math strcture> + <food item>
19:53:19 <ToposTartare> http://en.wikipedia.org/wiki/Steak_tartare
19:53:28 <ToposTartare> mmm
19:54:20 <noZone> ghc: panic! (the 'impossible' happened)   I like it when something impossible happens to me.
19:54:38 <Cale> noZone: congratulations!
19:54:48 <noZone> heh
19:54:49 <Cale> noZone: how'd it happen?
19:54:50 <ivanm> eh, I get that trying to build 6.12 RC with itself
19:55:07 <noZone> I added a LANGUAGE thingy at the top 'o the file and boom.
19:55:23 <noZone> {-# LANGUAGE -XUnicodeSyntax #-}
19:55:29 <noZone> It didn't like that.
19:55:31 <Saizan_> issue9?
19:55:35 <kmc> MonadRagout, well, they're checked casts, right?
19:55:40 <dmwit> Saizan_: Shut up shut up!
19:55:41 <gwern> mmorrow: please don't jest about void/ignore
19:55:46 <dmwit> Don't make people start talking about it again.
19:55:47 <ToposTartare> noZone: yeah, that was just fixed recently
19:55:48 <gwern> I'm still cracked up about not getting it i
19:55:57 <kmc> err @mmorrow too
19:56:05 <gwern> I would've done it if it were for you pesky dons!
19:56:18 <MonadRagout> kmc, but _runtime_ casts, nontheless.
19:56:40 <noZone> just GHC version 6.10.3
19:56:58 <zong_sharo> i need some function, like f :: RandomGen g => a -> Rand g b, but for equal arguments it must return equal values
19:57:10 <Cale> noZone: remove the -X
19:57:19 <Cale> {-# LANGUAGE UnicodeSyntax #-}
19:57:24 <kmc> sure.  but it's still safer than void*, and exactly as safe as Dynamic
19:57:35 <kmc> and a useful thing to have,
19:57:47 <dmwit> zong_sharo: Sounds like a case for fmap to me.
19:58:04 <noZone> Thanks... fixed.
19:58:08 <dmwit> zong_sharo: (i.e. your function actually has type (a -> b), but you want to lift it via fmap)
19:58:19 <zong_sharo> dmwit: actual values must vary
19:58:32 <zong_sharo> so
19:59:11 <zong_sharo> f a >>= \b -> fa >>= \c -> <- b == c, always
19:59:27 <zong_sharo> actual value of b and c must vary
19:59:43 <ivanm> gwern: why do you want to use characters you can't actually type in? :s
20:00:01 <gwern> ivanm: ? I can type ignore just fine
20:00:20 <ivanm> gwern: I thought you were complaining about unicode chars...
20:00:22 <dmwit> zong_sharo: You say, "for equal arguments it must return equal values" and "for equal arguments actual value of b and c must vary".  Which do you want?
20:00:30 <ivanm> what's ignore?
20:00:43 <gwern> ivanm: m a -> m ()
20:00:53 <gwern> const $ return ()
20:01:05 <ivanm> gwern: isn't that dont? :p
20:01:38 <dmwit> I think gwern means (>> return ()), which is more different.
20:01:57 <ivanm> yeah, that's what I thought he meant with the type sig
20:02:00 <gwern> hm. maybe, it's been a little while since I actually looked at the void/ignore definition
20:02:30 <ivanm> since const $ return () won't actually do anything...
20:02:53 <jmillikin> Is there any way to make Hackage update/rebuild existing packages? I'm running into a build issue because the "binary" and "text" libraries have been built with different versions of "bytestring"
20:03:15 <ivanm> jmillikin: rebuild them by hand
20:03:15 <MonadRagout> jmillikin, --reinstall
20:03:24 <jmillikin> Not on my local system, on Hackage
20:03:34 <ivanm> jmillikin: ahhh
20:03:45 <ivanm> yeah, they should stop core packages from being upgraded
20:03:49 <jmillikin> Normally I wouldn't care, but it's preventing the documentation for my package from being built
20:04:03 <ivanm> how does "cabal install foo" differ from "cabal install foo --reinstall" ?
20:04:22 <jmillikin> ivanm: if the package is already installed, the first does nothing
20:04:22 <Saizan_> jmillikin: no way, you can only help with the developement of the new hackage-server where this problem simply won't exist
20:04:26 <gwern> ivanm: the former won't do anything if the requested package is already installed
20:04:34 <ivanm> :o
20:04:38 <ivanm> didn't know that...
20:04:45 <gwern> ivanm: unless a newer version is available, iirc
20:04:49 <ivanm> Saizan_: because they say it won't? :p
20:05:05 <ivanm> gwern: then again, I only use cabal install for testing my own stuff
20:05:08 <gwern> (in which case cabal install foo would kick off an install of the newest version)
20:05:10 <Saizan_> ivanm: because documentation doesn't get generated on the server, but gets posted to it
20:05:27 <ivanm> Saizan_: it will have the _option_ of getting put there
20:05:40 <ivanm> but by default it will still attempt to generate it on the server
20:05:41 <ivanm> IIRC
20:05:55 <dmwit> Will it have real package ownership?
20:06:09 <ivanm> dunno
20:06:23 <Saizan_> my understanding is that there will be separate buildbots
20:06:45 * ivanm wants the dalek buildbot
20:06:46 <ivanm> ;-)
20:11:51 <gwern> would it screech, 'BROKEN BUILD! BROKEN BUILD!'?
20:12:44 <ivanm> heh
20:13:32 <MonadRagout> Cale, I think the issue9 pattern for a half-way decent map is a for loop in the forM_ sense. works over channels, too.
20:13:39 <Saizan_> and then EXTERMINATE the package
20:14:04 <Saizan_> dmwit: they are still talking about it and i don't what it is!
20:14:36 <MonadRagout> ...all in all, issue9 doesn't make fp easy, at all.
20:14:47 <zong_sharo> dmwit: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12062#a12062 <- like this
20:15:00 <MonadRagout> it might satisfy the pythonistas, but certainly not even lispers.
20:15:11 <kmc> hey guys, have any of you heard of this language called 'Go' or 'Issue9'?
20:15:15 <kmc> i hear it's pretty popular
20:15:31 * MonadRagout has just judged it as not FP enough to be usable.
20:15:39 <jmillikin> From what I've seen, it's not as functional as even Python.
20:15:40 <MonadRagout> actually, it's polymorphism that's lacking.
20:16:20 <jmillikin> I'm not sure what the target market is -- it looks like Java with alternate syntax
20:16:51 <MonadRagout> oh, it's got typeclasses instead of inheritance.
20:17:18 <zong_sharo> dmwit: um?
20:17:21 <Cale> MonadRagout: Really, map was just an example :)
20:17:25 <Saizan_> it seems statically checked duck-typing, with a lowlevel twist
20:17:31 <Cale> MonadRagout: The bigger problem is the typing issue.
20:18:00 <gwern> issue9? is that what they're actually calling it?
20:18:04 <ToposTartare> no
20:18:23 <MonadRagout> issue9 it's what it's called, though.
20:19:10 <ivanm> MonadRagout: isn't that the old language that it's based on?
20:19:19 <Cale> (The first thing I do when I see a new programming language is ask what map looks like, because if you can't write something that simple elegantly, your abstraction facilities are pitiful.)
20:19:34 <MonadRagout> no, plan9 is an os by the same guys.
20:19:34 <ivanm> with google changing the amazingly easy to search for, distinguish and completely original name of "Go" to replace it
20:19:35 <kmc> Cale, I heard maps are built in
20:19:35 <kmc> ;)
20:19:41 <ToposTartare> lol
20:19:44 <Cale> kmc: haha
20:19:50 <dmwit> zong_sharo: what?
20:19:51 <MonadRagout> issue9 in the bug tracker is a nameclash with a language called go!
20:19:52 <ivanm> Cale: it looks vaguely like C with dynamic typing, from a quick look at the examples the other day
20:19:54 <Cale> (not that kind of map, of course)
20:20:06 <kmc> it's mostly not dynamically typed
20:20:21 <ivanm> oh, I thought it was
20:20:21 <kmc> Cale, it does have lambdas with closure
20:20:34 <ivanm> people on reddit were saying how great it was because it's like python with braces :s
20:20:46 <kmc> yup, programming languages are all about syntax
20:20:46 <ToposTartare> people on reddit are fucking dumb
20:20:53 <ivanm> true
20:21:06 <kmc> the most important characteristic of a language is whether it has curly braces
20:21:33 <zong_sharo> dmwit: dunno how to explain this (my english is limited), but it must behaves in this way: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12062#a12062
20:21:44 <kmc> static typing is bad because having to write in the types decreases the ratio of curly braces to code
20:21:47 <kmc> thus making the code slower
20:22:32 <ToposTartare> lol
20:22:45 <MonadRagout> ToposTartare, true. people like me.
20:22:49 <Cale> kmc: yeah
20:22:57 <Cale> kmc: (It does have lambda)
20:22:59 <ToposTartare> MonadRagout: and me!
20:23:07 <kmc> Cale, so i don't think invoking a map is *that* bad
20:23:12 <kmc> at least the lambda is not crippled like Python's
20:23:22 <Cale> kmc: a map?
20:23:30 <Saizan_> zong_sharo: basically, you want to memoize calls to foo, not taking into account the current StdGen for the memo table
20:23:33 <kmc> an invocation of map :: (a -> b) -> [a] -> [b] i mean
20:23:48 <Cale> kmc: Yeah, I don't think you can write it.
20:23:51 <dmwit> I don't understand the problem.
20:23:57 <kmc> you can't write the HOF named map?
20:23:58 <dmwit> Just about any old "foo" should make those things be true.
20:24:01 <kmc> i don't think that's true
20:24:13 <Cale> kmc: What's its type in issue9?
20:24:16 <dmwit> Like, foo = randomR (0,10), for examplee
20:24:30 <dmwit> (or whatever the equivalent in the Rand monad is)
20:24:33 <kmc> Cale, well, it'll be monomorphic
20:24:39 <Cale> kmc: I believe you can write it for monomorphic types, sure
20:24:41 <kmc> or dynamically polymorphic
20:24:43 <kmc> ah
20:24:48 <Saizan_> dmwit: no, two calls to that would return different results, even in the same Rand block
20:25:31 <dmwit> err
20:25:49 <dmwit> sorry
20:26:00 <dmwit> Any *pure* foo should do the trick.
20:26:03 * hackagebot upload: dbus-core 0.6 - Low-level D-Bus protocol implementation (JohnMillikin)
20:26:05 <dmwit> say, fmap id
20:26:13 <Saizan_> dmwit: no, fst (bar 1) == fst (bar 2) -- False
20:26:21 <Saizan_> that wouldn't be respected
20:26:51 <dmwit> plain "get", then?
20:27:02 <dmwit> get + the argument, say
20:27:05 * hackagebot upload: dbus-client 0.2 - D-Bus client libraries (JohnMillikin)
20:27:48 <dmwit> Also, I am obviously quite tired.
20:27:56 <dmwit> I should maybe shut up.
20:28:10 <Saizan_> i think the only way is to cache the first result
20:28:20 <MonadRagout> actually, sometimes there are rare pearls to be found on proggit http://www.reddit.com/r/programming/comments/a3ggn/there_is_not_a_single_mention_of_the_word_object/c0fo94q
20:28:24 <zong_sharo> Saizan_: i need somehow make things less random
20:28:28 <kwallmark> I've just started playing with hs-dotnet.  I can run the examples that call .NET code from Haskell, but I'm struggling with calling Haskell from .NET code.  If anyone could point me toward some example code, I'd appreciate it.
20:28:40 <Saizan_> zong_sharo: do you know about monad transformers?
20:28:59 <zong_sharo> Saizan_: yep
20:29:23 <zong_sharo> actually now it's RandT StdGen (Reader Int) a
20:31:06 <Saizan_> zong_sharo: ok, you could add a StateT (Map Int Int) layer there, so that you can store the results of foo for a certain argument inside the Map and check at every call to foo if there's already a computed result and return it if so
20:31:46 <zong_sharo> Saizan_: maybe i should put StdGen in reader, instead of RandT
20:32:13 <zong_sharo> than, results will be random, but will satisfy my requirements
20:32:20 <zong_sharo> will be*
20:32:49 <c_wraith> you won't be able to use a new StdGen for each computation, then
20:32:53 <c_wraith> That might cause issues
20:33:12 <Saizan_> zong_sharo: that'll be like using a single random number over the whole Rand block, it's a bit weird
20:33:29 <Saizan_> but it would satisfy your requirements, indeed
20:33:56 <lpjhjdh> are there any good papers on using category theoretic traversal routines like catamorphisms other than the barbed wire paper and comonad reader?
20:34:11 <kmc> http://golang.org/pkg/exp/iterable/#tmp_72
20:34:17 <kmc> func Map(iter Iterable, f func(interface{}) interface{}) Iterable
20:34:28 <Saizan_> lpjhjdh: comonad reader articles often link papers
20:35:03 <lpjhjdh> Saizan_: I'll have to take a deeper look, thanks
20:35:06 <kmc> so yeah, it does the polymorphism dynamically
20:35:24 <ToposTartare> ew
20:35:43 <ToposTartare> at least it's possible, though
20:36:14 <ToposTartare> / TODO:
20:36:15 <ToposTartare> / - Zip
20:36:24 <pip> A newbie question: what does the # mean in something like case indexArray# arr# i# of (# e #) -> e
20:36:50 <Saizan_> pip: that those are GHC primitives, roughly
20:37:11 <pip> so I can just ignore them when I read the std lib src?
20:37:11 <Saizan_> (#  #) is an unboxed tuple, specifically
20:37:23 <pip> ok, thx Saizan
20:38:12 <Saizan_> they are part of the identifier they are attached to, just a name convention
20:40:48 <MonadRagout> random reddit quote: "I'm sorry, but I don't remember what we learned about subsets in 3rd grade. I'm relying on what I learned while getting my math degree from Caltech."
20:41:21 <Saizan_> aw, i just realized i should have pointed him/her to the haskell report for less cluttered definitions of the standard lib
20:41:21 <kmc> haha
20:41:22 <hiredman> lol
20:41:23 <kmc> username?
20:41:45 <hiredman> sometimes I think I should pay more attention to reddit comments
20:42:03 <ToposTartare> I hate people like that
20:42:41 <dolio> Subsets in 3rd grade?
20:42:44 <kmc> like what?
20:42:53 <dolio> Were they doing the infamous New Math?
20:42:58 <ToposTartare> like whoever said that :P
20:43:09 <Saizan_> hey, i learned venn diagrams before arithmetic!
20:43:19 <Cale> kmc: That would be a lot more acceptable as an interface if it didn't have to be implemented at every monomorphic type where you want to use it.
20:43:36 <kmc> what do you mean?
20:43:38 <Cale> (or perhaps I'm misreading this)
20:43:48 <kmc> interface{} is Top
20:43:51 <kmc> type containing every value
20:43:52 <Cale> ah
20:44:00 <ToposTartare> so you lose type safety
20:44:02 <kmc> unfortunately the downcast will be dynamically checked
20:44:11 <MonadRagout> actually, the issue9 guys are merely as incompetent as the java guys. even with java generics, they're still casting stuff to Objects and back at the bytecode level.
20:44:32 <Saizan_> the fundamental problem is that they don't have higher kinded types, apart from some builtins
20:44:39 <kmc> C++ has higher-kinded types :)
20:44:53 <dolio> Does go have closures? :)
20:44:57 <kmc> yes
20:44:59 <sg> dolio yes
20:45:01 <kmc> and lambdas / function literals
20:45:21 <MonadRagout> ...and as a consequence they have to have the map type inbuilt, which is mutable, which means that I'm supposed to trust functions that I'm passing it to not to modify it.
20:45:24 <MonadRagout> MADNESS!
20:45:39 <sg> but no generics and no OO (while i personally find the later good)
20:45:40 <kmc> what do you call a kind which has a (->) to the left of another (->) ?
20:45:42 <kmc> higher-rank?
20:45:47 <kmc> anyway C++ even has those
20:45:50 <kmc> "template templates"
20:45:54 * dolio is disappointed that he didn't set Cale off.
20:45:57 <kmc> but i assume they're basically awful
20:46:12 <MonadRagout> kmc, a -> b -> c is isomorphic to (a, b) -> c.
20:46:23 <kmc> but there's no (,) for kinds
20:46:28 <Saizan_> he means (a -> b) -> c
20:46:59 <Saizan_> higher order kinds, i'd guess :)
20:47:10 * MonadRagout wonders what question he has been answering, he doesn't find it in the scrollback.
20:47:17 <Saizan_> well, higher order types, rather
20:47:21 <Cale> dolio: I'm flipping between a bunch of things
20:47:22 <MonadRagout> mhhhh data kinds.
20:47:32 <MonadRagout> closed type funs.
20:48:44 <Saizan_> (rank is used wrt nested quantifications)
20:48:53 <emma> medfly!
20:49:05 <medfly> hi emma
20:50:35 <dbelange> lolwut
20:50:47 <reltuk> when I'm developing a cgi application is there a good way to test my methods with simulated requests within ghci or something?
20:50:50 <dbelange> Oh, thought this was #~math
20:51:35 <jmcarthur> hmm, it occurs to me that âŠ¥ possibly messes up the isomorphism between a â†’ b â†’ c and (a, b) â†’ c. in the (a, b) â†’ c case we could apply the function to âŠ¥, but i don't see an equivalent for a â†’ b â†’ c
20:52:01 <FunctorSalad_> ya it messes with everything :(
20:52:24 <FunctorSalad_> no product for you
20:52:39 <jmcarthur> and of course foo âŠ¥ âŠ¥ is not the same as uncurry foo âŠ¥
20:52:42 <MonadRagout> that's why isomorphism in Hask is isomorphism up to bottom.
20:52:45 <FunctorSalad_> (but I haven't thought about this particular case)
20:52:46 <jmcarthur> yeah
20:52:54 <pip_> Is there somewhere I can look up the details / implementation of Array#?  I don't see it in GHC-Arr src
20:53:37 * jmcarthur has a love/hate relationship with âŠ¥
20:53:39 <MonadRagout> pip_, the ghc source (wild guess)?
20:54:00 <FunctorSalad_> jmcarthur: yes. total languages have their problems too
20:54:09 <pip_> I don't see that in the GHC-Arr src (from haskell wiki)
20:54:10 <FunctorSalad_> (yes=me too)
20:54:16 <Saizan_> pip_: why are you diving in such lowlevel details as a newbie?
20:54:24 <dolio> Fast and Loose Reasoning is Morally Correct actually has a description of a category for reasoning about Haskell towards the end.
20:54:39 <pip_> Just wonder how array works in haskell
20:54:40 <FunctorSalad_> that is a title? :)
20:54:54 <dolio> Yes.
20:54:56 <FunctorSalad_> dolio: a real, honest *category*? :o
20:55:00 <dolio> Yes.
20:55:11 <FunctorSalad_> must look that up :)
20:55:16 <Saizan_> Array# is probably primitive and basically the same as a C array
20:55:44 <jmcarthur> ooh
20:55:56 <ToposTartare> I think it stores its own size though
20:56:06 <dolio> They may well throw out seq.
20:56:07 <ToposTartare> and isn't unboxed
20:56:16 <dolio> Or, maybe they don't have to, I'm not sure.
20:56:33 <dolio> seq is kind of irrelevant in the fast-and-loose fragment of Haskell.
20:56:44 * FunctorSalad_ reads
20:57:01 <Saizan_> http://www.haskell.org/haskellwiki/Modern_array_libraries <- this is a good introduction to the use of arrays in haskell
20:57:12 <Saizan_> even if there are more recent libs not covered there
20:59:01 <jmcarthur> i love how right off the bat it points out the exact example i just gave
20:59:21 <pip_> thx Saizan, that url actually has what I what.
21:03:18 <MonadRagout> "If there were a type for total, finite natural
21:03:18 <MonadRagout> numbers, and similarly for lists, then the propagation would
21:03:18 <MonadRagout> be handled by the types of reverse and map."
21:03:22 <MonadRagout> that's an excellent point.
21:03:40 <MonadRagout> someone implement a difference in types between total haskell and the rest of it.
21:04:25 <roconnor> propagation?
21:04:51 <MonadRagout> yep.
21:04:55 <MonadRagout> with some barriers.
21:05:14 <roconnor> I don't know what that means here.
21:05:19 <MonadRagout> recursive definitions infect the points they're used at.
21:05:38 <roconnor> what is propagating?
21:05:51 <MonadRagout> ah, that propagation.
21:06:29 <MonadRagout> in that context, the propagation of additional "is-not-bottom" lemmas through the proof in contrast to the same proof in a total language.
21:06:40 <MonadRagout> http://www.comlab.ox.ac.uk/people/jeremy.gibbons/publications/fast+loose.pdf
21:06:50 <MonadRagout> section 2
21:06:58 <FunctorSalad_> cata can be trusted too right?
21:07:09 <MonadRagout> by itself, yes.
21:07:22 <MonadRagout> it's structurally decreasing.
21:07:31 <MonadRagout> or at least something along those lines.
21:07:36 <MonadRagout> don't trust me on technical detail.
21:08:08 <Saizan_> you can trust if if you're recursing over a finite structure
21:08:24 * FunctorSal is back online
21:08:29 <MonadRagout> roconnor, I hereby name you LemmaBuffet
21:08:32 <FunctorSal> hmm
21:09:14 <koala_man> given any block cipher, can you exchange the encryption and decryption function and still have a working and equally secure system?
21:09:34 <roconnor> ?
21:09:52 <MonadRagout> you mean, replace your crypto algorithm with 2ROT13?
21:09:54 <MonadRagout> I doubt it.
21:10:07 <iaefai> What is the proper way in cabal to use the threaded runtime?
21:10:13 <roconnor> no, replace rot13 with rot(-13)
21:10:24 <roconnor> but rot13 is symmetric so that isn't really interesting
21:10:55 <koala_man> not replace them with something else, but encrypt with the decryption function and vice versa
21:11:07 <FunctorSal> hehe
21:11:16 <MonadRagout> I'd be surprised if that works, at all.
21:11:29 <roconnor> koala_man: interesting idea.
21:11:30 <mmorrow> the hazards of search-and-replace: "Couldn't match expected type `(->)' against inferred type `->='..."
21:11:32 <MonadRagout> I'd suspect decryption to fail on a lot of input.
21:11:48 <roconnor> MonadRagout: for a block cypher?
21:11:54 <mmorrow> that was worth a few seconds of "wtf"
21:12:16 <MonadRagout> see, as I said. don't listen to me.
21:12:18 <roconnor> MonadRagout: block cyphers should be bijective otherwise you have big problems.
21:12:21 <roconnor> :)
21:12:22 <koala_man> both encryption and decryption is bijective, and one is the reverse of the other
21:12:22 <FunctorSal> mmorrow: yeah haskell could use a real search-and-replacer
21:14:00 <Saizan_> HaRe
21:14:57 <FunctorSal> Saizan_: that is available for current ghc :(
21:15:32 <FunctorSal> a plain search&replace could work on the haskell-src-exts level I think
21:15:58 <FunctorSal> (you can even detect shadowing syntactically)
21:16:00 <c_wraith> has anyone tried to build a project-manager scale IDE for haskell?
21:16:28 <c_wraith> Something that takes over and runs your workflow, in exchange for the ability to trivially do tree-wide source manipulation?
21:16:28 <kwallmark> c_wraith: what are your views on leksah?
21:16:45 <c_wraith> I actually haven't used anything more than haskell-mode in emacs
21:16:49 <MonadRagout> c_wraith, there's hare, and there's leksah.
21:17:06 <FunctorSal> the modules could be written independently
21:17:39 <FunctorSal> then later someone can combine it in a GUI
21:17:51 <MonadRagout> if you want your workflow to be taken over: When using oleg's libraries, haskell codes you.
21:18:03 <kwallmark> It seems like Haskell would be a good choice for refactoring / static code analysis tools, given how much richness it has at compile time.
21:18:13 <FunctorSal> yeah
21:18:26 <MonadRagout> Haskell is also a bugger to parse.
21:18:26 <kmc> oh yes
21:18:32 <kmc> both for having the tools, and for implementing them
21:18:38 <MonadRagout> ...ghc-haskell even more so.
21:18:38 <kmc> MonadRagout, fortunately it's been done ;)
21:18:43 <kmc> and it's not nearly as bad as C++
21:18:49 <sproingie> or perl
21:18:54 <roconnor> :D
21:19:05 <roconnor> perl parsing being undecidable
21:19:31 * MonadRagout vaguely remembers a discussion about ghc's AST not preserving comments and how that'd be the only thing that made in unusable for refactoring.
21:19:46 <sproingie> perl cant be parsed without executing it
21:19:48 <FunctorSal> MonadRagout: src-exts has an "ExactPrinter" now
21:20:35 <iaefai> What uses base>=5?
21:20:40 <sproingie> weirdly enough even though perl6 is even more crufty looking, it supposedly can be statically parsed
21:20:43 <kmc> but guys, what about parsing Go?!?!?!?
21:20:55 <kmc> haskell is behind the times because we lack Language.Go.Parser
21:20:57 <ToposTartare> why are pullbacks/pushouts interesting?
21:21:01 <c_wraith> I thought current base was 4....  Does 6.12 go to base 5?
21:21:10 <sproingie> it's 4
21:21:11 <roconnor> Go?!?!?!? or Go!?!?!?!
21:21:12 <ToposTartare> c_wraith: nope
21:22:51 <lpjhjdh> What's with all the go hype?  Hadn't heard of it till that ltu reference.  Thoroughly unimpressed.
21:23:14 <FunctorSal> yeah it has no monomorphism restriction
21:23:14 <Axman6> seems sort of nice, for what it's aimed at
21:23:38 <ToposTartare> it seems like yet another obvious variation of the same thing
21:24:04 <sproingie> go's syntax is blah, the ideas seem pretty decent
21:24:32 <kmc> the ideas are pretty standard
21:24:36 <kmc> nothing revolutionary
21:24:36 <lpjhjdh> I twitch at the idea of yet *another* language
21:24:46 <kmc> i twitch and i salivate
21:24:48 <FunctorSal> without parametric polymorphism
21:25:30 <FunctorSal> I know almost nothing of go yet I already can't stop bitching about that ;)
21:26:02 <Saizan_> we should start a #go-bitching channel
21:26:23 <lpjhjdh> The only new language I'm excited to see progress is ats
21:26:28 <Saizan_> and then act like we don't like the board game
21:26:33 <kmc> what's ats?
21:27:11 <FunctorSal> does go have ADTs at least?
21:27:13 <Axman6> lpjhjdh: what's ATS got to offer except embedded C so you can cheaty on the shootout?
21:27:14 <lpjhjdh> http://www.ats-lang.org/
21:27:18 <FunctorSal> (with sums dammit)
21:27:39 * kmc is excited about Agda
21:27:40 <lpjhjdh> Axman6: it's just nice to see types being targeted at engineers
21:27:53 * roconnor is excited about Epigram 2
21:28:06 <kmc> does it still have the crazy syntax?
21:28:15 <FunctorSal> roconnor: is it still alive?
21:28:24 <Gracenotes> does anyone have any functional reactive code that.. uh.. does something concrete?
21:28:27 <roconnor> I don't even know if it has syntax
21:28:35 <sproingie> Gracenotes: there's frag
21:28:37 <lpjhjdh> agda is nicer than ats, but it seems like more of a pseudo-research project like haskell
21:28:42 <Gracenotes> and something that's simple, at that?
21:28:51 <sproingie> okay not frag
21:28:56 <Gracenotes> like, for example, cat implemented in FRP?
21:29:08 <kmc> Agda is nice in that i can actually understand the idea of proofs as dependently typed GADTs
21:29:09 <FunctorSal> cat :D
21:29:15 <kmc> whereas i never got the hang of "proof scripts"
21:29:17 <Gracenotes> I've looked at the paper and a bit of the source, but the idioms are not penetrable in any way. at all.
21:29:23 <sproingie> not sure how you'd do cat as reactive.  maybe minesweeper?
21:30:11 <Gracenotes> or in a GUI context: output characters as user types them
21:30:31 <sproingie> i get the idea of frp since i invented a similar idea in stackless python a while back
21:30:44 <sproingie> i dont know the implementations tho, last one i used was frantk
21:30:57 <roconnor> I've used GuiTV
21:30:59 <Gracenotes> the line between what is implemented in an API and what is meant to be implemented by the user is hopelessly confusing when all you're looking at is combinators
21:31:05 <roconnor> I don't know if that really counts as FRP
21:31:59 <Gracenotes> I doubt there will ever be a LYAH for FRP, but what exists now is... ugh...
21:32:26 <Gracenotes> what's existed for the last who-knows-how-many years
21:33:11 <dolio> ATS is less of a pseudo-research project than Haskell?
21:33:34 <lpjhjdh> dolio: if nothing else it's marketed as less so, haha
21:33:40 <lpjhjdh> dolio: fooled me at least :)
21:34:38 <lpjhjdh> I only say that about haskell because I couldn't possibly find a job around here.  Not that I could ats either
21:34:53 <dolio> There are more Haskell jobs than ATS jobs, currently.
21:36:14 <Bradly> Hello earthlings.
21:36:51 <medfly> Haskell got me a job!
21:36:58 <medfly> ... using PHP
21:37:00 <HaudRex> yay!
21:37:03 <HaudRex> boo.
21:37:04 <lpjhjdh> true, I think haskell is nicer than ats too.  Just C style languages have such a death-grip on the us.  Makes me feel like the closer you are syntactically the better chance you have :(
21:37:07 <medfly> :)))
21:37:12 <HaudRex> @pl \z h f g -> z ((h f) x) ((h g) x)
21:37:13 <lambdabot> (`ap` flip flip x) . ((flip . ((.) .)) .) . (. flip flip x) . (.)
21:37:27 <HaudRex> I'm sure there's a combinator for this kind of thing.
21:37:48 <dolio> I'm not sure how C-like ATS is, other than that you can use inline C.
21:38:00 <dolio> It grew out of Dependent ML, so it's rather like that.
21:38:15 <medfly> after trying a few other languages - are there languages besides Haskell that are NOT C-like ?
21:38:45 <c_wraith> hundreds.
21:38:54 <HaudRex> @type (***)
21:38:55 <c_wraith> moderately popular current ones include python and ruby
21:38:55 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
21:38:57 <tensorpudding> prolog is very little like haskell or C
21:38:59 <jmillikin> Any of the ML family, LISP, Erlang, APL
21:38:59 <hiredman> lisps :P
21:39:02 <dolio> Unless you think ML is C-like, in which case, case closed.
21:39:13 <lpjhjdh> I would ml is much closer to C than haskell is (syntactically).
21:39:20 <kmc> medfly, "C-like"?
21:39:25 <jmillikin> Syntax is irrelevant, though
21:39:26 <kmc> do you mean in syntax, or in more important ways
21:39:27 <medfly> python seems to use some C-like syntax.
21:39:34 <medfly> someone else said it!
21:39:38 <jmillikin> there are LISP clones with C syntax
21:39:42 <kmc> syntax is not everything
21:39:44 <tensorpudding> Smalltalk isn't very C-like.
21:39:45 <lpjhjdh> maybe f# will become popular since microsoft is pushing it in the next vs release
21:39:49 <kmc> i will never accept that Javascript is "C-like"
21:39:58 <MonadRagout> ml's syntax is sufficiently repellant to make me skip ocaml code like they were proof sections.
21:40:03 <lpjhjdh> kmc: syntactically
21:40:18 <hiredman> MonadRagout: that's how I feel about python
21:40:23 <jmillikin> Again, though, who cares about syntax?
21:40:26 <tensorpudding> F# has a very repellant syntax, if you ask me, and the fact that it ties well with other .NET languages means little to me
21:40:28 <kmc> Perl syntax is not very C-like
21:40:40 <kmc> syntax is important, but it's not as important as people make it out to be
21:40:50 <kmc> the problem is that semantics are hard, but it's easy to have an opinion about syntax
21:41:49 <dolio> Hah, if you ask Girard, semantics is easier, and overly-developed, compared to syntax.
21:41:51 <kwallmark> tensorpudding: I think .NET languages are going to get more functional goodness from the Haskell influence on C# than they will from F#, in the long run
21:41:56 <dolio> Although, he isn't talking about beauty.
21:42:01 <lpjhjdh> kmc: true, I'd be happy if everything had syntax as liberal as isabelle or agda, but it's not too important.  I feel like folks that play into hype probably overemphasize syntax.
21:42:03 <Gracenotes> JavaScript syntax is pretty much C without types.
21:42:16 <lpjhjdh> of course this is all personal conjecture
21:42:18 <medfly> javascript has no types?
21:42:20 * medfly stares
21:42:22 <Gracenotes> and with anonymous functions, regex support, and a few other things
21:42:23 <MonadRagout> agda code is verbose.
21:42:27 <Gracenotes> medfly: "syntax"
21:42:39 <Gracenotes> syntax can express types. or it can fail to.
21:42:45 <MonadRagout> ...and that's not syntax, that's semantics.
21:42:48 <Gracenotes> that doesn't necessarily correlate to semantics.
21:42:52 <kmc> imo, Go/I9 changed C's syntax enough to confuse everyone, but not enough to actually improve things
21:43:10 <medfly> everything should be like Haskell!
21:43:13 <MonadRagout> otoh, coq-style theorem provers don't have enough information.
21:43:18 <iaefai> kmc, talking about that Go thing?
21:43:29 <iaefai> Is there a way I can catch ^C so I can safely shutdown my threads?
21:43:35 <hiredman> Go/I9, cute
21:43:39 <dolio> Ice9?
21:43:45 <dolio> That'd be a good name for a language.
21:43:49 <MonadRagout> <a bunch of symbols looking like perl> ; auto ; qed.
21:43:51 <hiredman> Issue 9
21:43:52 <Gracenotes> MonadRagout: in C declarations, there is a grammar rule for a type. no such item exists in JavaScript. Its type system is divorced from its grammar entirely.
21:43:58 <c_wraith> iaefai: catch will do it.  if you use the right catch
21:44:00 <kmc> MonadRagout, haha
21:44:03 <MonadRagout> that's not exactly telling me much about how stuff works.
21:44:06 <c_wraith> @hoogle catch
21:44:06 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
21:44:07 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
21:44:07 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
21:44:14 <c_wraith> Use the one from Control.Exception
21:44:22 <iaefai> What am I catching
21:44:36 <MonadRagout> iaefai, don't listen to him.
21:44:39 <c_wraith> SomeException
21:44:40 <c_wraith> :)
21:44:44 <c_wraith> (seriously)
21:44:44 <MonadRagout> posix package, look for signals.
21:44:53 <MonadRagout> what you want to handle is SIGINT
21:45:05 <iaefai> Does this package exist and work on windows for the same purpose?
21:45:06 <lpjhjdh> MonadRagout: I have little experience with other theorem provers, but if you're not using isar, isabelle proofs aren't too informative either imo.
21:45:22 <lpjhjdh> and I'll take a hand written proof anyday
21:45:22 <MonadRagout> I didn't even ever write a proof.
21:45:36 <MonadRagout> ...only looked at a couple of tutorials and couldn't make much out of it.
21:46:12 <MonadRagout> I could parse them without much problems, but none of their didactic means ever made me able to do the stuff they're describing.
21:46:28 <MonadRagout> maybe it's just like with pointers.
21:46:55 <MonadRagout> there are people, they say, who are just physically incapable of grokking the concept of a reference to something.
21:47:30 <lpjhjdh> ha yeah, I wish there were more material targeted at mortals such as myself.  Most stuff on automated theorem provers is pretty terse.
21:47:40 <MonadRagout> that's why 90% of the people taking CS classes leave to another branch of study, claiming they do it for the lack of chicks in cs.
21:48:19 <kmc> MonadRagout, how do those people call the fire department when their house is burning?
21:48:31 <kmc> if you don't know what an address is...
21:48:47 <MonadRagout> _that_ is the question.
21:49:07 <MonadRagout> If I knew the answer, maybe I could coerce myself into grokking how to write proofs.
21:52:43 <defun> Ok. I'm running GHC Haskell under solaris. I just did some tracing of xmonad as it was running. Here is some output (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12063#a12063). Apparently, the runtime system is being traced, because it's written in C, and C generates symbols. Is there a way to make haskell code compile with symbols?
21:53:51 <defun> * more accurately C is compiled with symbols.
21:53:56 <nornagon> there's not really a direct mapping
21:54:10 <defun> bummer
21:54:27 <nornagon> there exist haskell profilers, though
21:54:40 <defun> hmm. How do they work?
21:54:52 <nornagon> Â¯\(Â°_o)/Â¯
21:55:00 <defun> I see.
21:55:44 <ivanm> defun: they're inbuilt
21:55:48 <jmcarthur> woah, we have ogre bindings now?!
21:55:53 <defun> Into the runtime?
21:55:59 <Axman6> defun: there's info in the ghc docs
21:56:00 <ivanm> defun: yes
21:56:07 <Axman6> just compile with -prof -auto-all
21:56:12 <ivanm> defun: you compile with profiling support, and then run the app with +RTS -p
21:56:18 <ivanm> hey Axman6
21:56:22 <ivanm> there's also -caf-all
21:56:27 <Axman6> and then run with +RTS -something to find the profiling info
21:56:30 <jmcarthur> oh it appears to be a fairly small binding
21:56:42 <defun> I see. Thanks.
21:56:49 <Axman6> @where profiling
21:56:50 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
21:56:54 <Axman6> hooray
21:57:12 <nornagon> jmcarthur: we do?
21:58:08 <MonadRagout> ogre?
21:58:30 <MonadRagout> there's a 3d lib implemented in pure haskell that uses ogre file formats
21:58:34 <MonadRagout> you might be looking at that
21:58:38 <jmcarthur> nornagon: http://hackage.haskell.org/package/hogre-0.0.1
21:58:43 <jmcarthur> oh?
21:58:52 <MonadRagout> ...or at the parsing functions, or something.
21:58:55 <jmcarthur> this one claims to be bindings
21:59:14 <jmcarthur> and has a bunch of rendering stuff
21:59:31 <jmcarthur> also an examples package: http://hackage.haskell.org/package/hogre-examples-0.0.1
21:59:33 <nornagon> jmcarthur: that really is a tiny subset though
21:59:41 <jmcarthur> yeah
21:59:43 <Gracenotes> meow
21:59:47 <MonadRagout> yep
21:59:50 <MonadRagout> http://github.com/anttisalonen/hogre/blob/master/src/Graphics/Ogre/Ogre.hs
22:00:18 <jmcarthur> barely counts, i guess
22:01:29 <Gracenotes> Ogre is a complicated beast. no pun intended.
22:03:54 <Gracenotes> it was explicity designed around OOP principles, as well
22:04:16 <MonadRagout> these guys are always saying that as if it were a good thing
22:04:20 <Gracenotes> and the sort of not-very-functional state-modifying that implies
22:05:14 <MonadRagout> I've yet to see purely functional objects, btw.
22:05:29 <kmc> MonadRagout, existentials?
22:05:34 <kmc> there are functional objects in TaPL
22:05:45 <MonadRagout> tapl?
22:06:01 <kmc> @where tapl
22:06:01 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
22:06:02 <MonadRagout> and no, I'm not so much referring to quantification as to the design patterns.
22:07:26 <Gracenotes> purely functional objects is an interesting term... perhaps objects used in purely functional algorithms? there *is* http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504/
22:07:42 <Gracenotes> with a focus on laziness
22:07:51 <kmc> MonadRagout, a "design pattern" is a higher-order function in a language which doesn't have higher-order functions
22:08:01 <kmc> so instead you have to write a *document* about how you would write the function
22:08:05 <kmc> it's really an awful thing once you think about it
22:08:18 <nornagon> design patterns always seemed like hacks to me
22:08:26 <lpjhjdh> what about olegs paper?
22:08:32 <MonadRagout> ...I wasn't using it in the buzzy sense.
22:08:34 <kmc> some "design patterns" are workarounds entirely for a flaw in a specific language
22:08:38 <kmc> which ones, then?
22:08:39 <MonadRagout> but a literal one.
22:10:23 <conal> i've done functional oop many times, including in some current projects.
22:12:00 <Gracenotes> the unique role of design patterns in OOP is, in my opinion, due to the fact that inheritance isn't as powerful an abstraction as people thought it would be
22:12:19 <MonadRagout> so far, the only truly oop-style idiom I've used was constructing an interface around threads.
22:12:53 <Gracenotes> in almost all OOP systems (save LISP and a few other innovative ones), what it provides is single dynamic dispatch. Which covers a lot of cases, but.. not all.
22:13:03 <MonadRagout> ...well, actually, automatons.
22:13:13 <conal> in case anyone hasn't seen it: http://www.skytopia.com/project/fractal/mandelbulb.html
22:13:42 <Gracenotes> and many exist for things which simply don't exist in the language. e.g. functions as values.
22:13:50 <conal> some trippy 3d fractal pics there
22:14:08 <kmc> woah, very nice
22:14:10 <ToposTartare> yeah, that's awesome
22:14:18 <kmc> i remember seeing 4D quaternion julia sets (in 3d slices)
22:14:22 <kmc> this looks similar but even better
22:14:23 <Gracenotes> and some are justifiable, like iterators, since they... whoa, pretty 3D pictures
22:15:04 <donri> are monads anything more than just chaining calls to functions of the same type? bind doing the chaining and return simply being a function like any else that just constructs a value of the chained type
22:15:05 <MonadRagout> iterators are a cool abstraction.
22:15:14 <MonadRagout> even more so when they're referentially transparent.
22:15:25 * medfly hands everyone some LSD
22:15:58 <Gracenotes> of course, singly linked lists, and having toList functions, takes care of much iterating business
22:16:25 * MonadRagout hands donri a plush http://www.haskell.org/sitewiki/images/1/1d/Monica_monad_falconnl.png as award
22:16:32 <donri> medfly, i should do some haskell on shrooms some time!
22:16:38 <medfly> haha
22:16:47 <donri> MonadRagout, lol, what's that?
22:16:58 <MonadRagout> that's monica monad. she's a warm, fuzzy thing.
22:17:29 <MonadRagout> one of the swawns of the haskell logo contest, and a somewhat way to cute mascot.
22:17:35 <MonadRagout> *spawns
22:17:53 <MonadRagout> oh, yes, monads.
22:18:03 <Gracenotes> and the Haskwhal, too.
22:18:06 <MonadRagout> there's a bit more to it: the monad laws.
22:18:25 <MonadRagout> but they're quite self-evident.
22:18:29 <kmc> yes you should all do haskell after taking shrooms or perhaps smoking 5-MeO-DMT
22:18:55 <MonadRagout> but it's nice to see someone coming to #haskell and _telling_ us what monads are, not _asking_
22:19:04 <Gracenotes> donri: monads could perhaps be described as chaining with extras. But this does little justice, and not so much explanation, to what is going on behind the scenes in some more, uh, interesting monads.
22:19:30 <MonadRagout> Gracenotes, don't get him down.
22:19:35 <MonadRagout> he's in abstract land.
22:20:17 <donri> I actually dreamt about haskell tonight, I made up some crazy illogical concept that I was trying to figure out in the dream, but I never succeeded because it was just something completely illogical I made up.
22:20:26 <donri> monads, OTOH, seem quite logical. :)
22:20:27 <c_wraith> anyone have experience with uu-parsinglib?
22:20:31 <Gracenotes> heh. well, learning involves both making distinctions and making groups. (somewhat like lazy evaluation)
22:21:17 <kmc> donri, "occurs check"?
22:22:09 <donri> huh
22:22:23 <bos31337> !seen dons
22:22:42 <bos31337> preflex: seen dons
22:22:42 <preflex>  dons was last seen on #haskell 7 hours, 45 minutes and 48 seconds ago, saying: so you could have main :: IO Int
22:22:44 <donri> lol, why do i see so many lojbanists in here all the time
22:22:47 <bos31337> grah
22:24:02 <kmc> who knows lojban?
22:24:36 <Gracenotes> ggj rgi regogj fgiaqe ioruw p vc xzvsd fhwf eiwf efw
22:24:51 <Gracenotes> oh.. sorry.. I have been informed this is not actual lojban.
22:24:56 <kmc> haha
22:25:41 <donri> papermachine who just joined, for one.
22:26:07 <papermachine> coi
22:26:14 <donri> coi la plemi'i
22:26:20 <donri> this is somewhat offtopic, lol
22:33:48 <c_wraith> is there any way to get uu-parsinglib to not do error correction?  I suppose I could just reject the result if there are errors, couldn't I?
22:34:33 <MonadRagout> that's what the faq says.
22:35:58 <c_wraith> bah.  There's a faq?  Why doesn't the package documentation link to it more emphatically? :)
22:36:29 * MonadRagout thinks the key to my oop-worries is providing combinators for typeclasses
22:36:32 <Gracenotes> I'd be tempted to ask lambdabot's faq utility if Haskell lets you reject the result if there are errors, but I have a feeling it would be less useful...
22:36:48 <c_wraith> It would at least be true.
22:37:09 <kmc> what kind of combinators?
22:37:09 * MonadRagout wonders why he's worried in the first place
22:37:38 <MonadRagout> something inherentance-like.
22:37:46 <MonadRagout> ...which we have, by giving contexts.
22:38:13 <kmc> yes
22:38:22 <MonadRagout> if you have a Monad, you can pass it to something that takes a Functor.
22:39:26 <kmc> yeah
22:39:35 <kmc> it's funny how typeclasses sort of let subtyping in through the back door
22:39:52 <kmc> but it a way such that it doesn't cause all of the usual problems
22:39:55 <MonadRagout> ...and, fwiw, you can also fix the record system by using typeclasses.
22:40:02 <kmc> how's that?
22:40:26 <MonadRagout> re-using names /me means.
22:40:41 <kmc> oh
22:40:43 <kmc> eh that's a hack
22:41:14 <MonadRagout> yep, but an elegant one.
22:41:14 <kmc> we use typeclasses when things are semantically similar, not just happen to use the same symbols
22:41:21 <MonadRagout> fundeps ftw.
22:41:27 <kmc> asstypes ftw
22:41:51 <MonadRagout> we also use typeclasses for all kind of type-level hackery.
22:42:01 <c_wraith> Man, when you become more comfortable with its error correction, this is rather amusing.
22:43:24 <kmc> "We use tabs for indentation and gofmt emits them by default. Use spaces only if you must. "
22:43:25 <kmc> ugggh
22:43:32 <c_wraith> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12064#a12064
22:43:58 <ToposTartare> wow, the picture here is really bad: http://en.wikipedia.org/wiki/Dagger_compact_category
22:44:06 <ToposTartare> not sure how to fix it without redoing the diagram though
22:46:20 <ToposTartare> are Set and any "ordery" categories subcategories of Rel?
22:48:25 <quicksilver> set is a subcategory of Rel, yes. Set has exactly the same objects as Rel, and a strict subset of the morphisms
22:48:36 <quicksilver> (and the same composition)
22:48:54 <ToposTartare> yeah
22:49:17 <ToposTartare> how about things like preorders?
22:49:49 <ToposTartare> I guess it must be
22:49:56 <ToposTartare> since it's still a relation
22:51:37 <ToposTartare> and subsetness/logical implication categories too
22:51:44 <Cale> ToposTartare: It's a PNG rather than generated by xypic
22:51:52 <ToposTartare> yeah
22:51:56 <Cale> (and it's been stretched)
22:52:16 <Cale> I could redo it
22:52:34 <ToposTartare> I'll do it!
22:52:37 <Cale> okay :)
22:52:46 <Cale> I'll go to sleep then :)
22:53:20 <ToposTartare> oh wait, do I need to render it outside of wikipedia and upload an svg?
22:53:25 <ToposTartare> other diagrams seem to do that
22:55:07 <Cale> hmm, maybe whatever Mediawiki is using to render LaTeX doesn't have xypic
22:55:27 <ToposTartare> ah well, I can still do it :)
22:56:33 <Cale> http://analogical-engine.com/wordpress/ <-- as you can see I've had enough diagrams for the last while :)
22:57:24 <quicksilver> not sure what you mean by "ordery" categories.
22:57:38 <Cale> ordery?
22:57:53 <quicksilver> "Ord" is normally taken to mean the objects are preordered (or ordered) sets, so that's not a subcat of Set, no
22:57:55 <Cale> Did I say that?
22:57:56 <quicksilver> the objects are different.
22:58:00 <quicksilver> ToposTartare did.
22:58:02 <Cale> oh
22:58:13 <donri> and another lojbanist, lol
22:58:24 <ToposTartare> quicksilver: I asked if it wa a subcat of Rel
22:58:28 <Cale> It's a non-full subcategory of Set
22:59:06 <quicksilver> Cale: only in a boring way by choosing an implementation of tagging a set with a preordering.
22:59:15 <quicksilver> almost everything is a subcat of Set in that kind of boring way.
23:00:22 <quicksilver> since we can implement almost everything as sets, and we can generally tweak that implementation in some kind of way to turn the morphisms into some subset of functions.
23:00:23 <ddarius> Cale: You made a blog?
23:00:33 <Cale> ddarius: With my friend Robin, yeah :)
23:00:53 <ToposTartare> hmm, how do I render .tex to svg?
23:01:03 <ToposTartare> I redrew the diagram
23:01:26 <medfly> c'mon and step right up, it's free, read Cale's blog today
23:02:00 <ray> early edition
23:04:23 <quicksilver> ToposTartare: http://en.wikipedia.org/wiki/Math_markup#Convert_to_SVG
23:05:43 <ToposTartare> thanks :)
23:06:44 <bos> ooh, where's the caleblog?
23:06:57 <quicksilver> bos: http://analogical-engine.com/wordpress/
23:07:23 <quicksilver> (people-to-lazy-to-read-back-30-lines-and-I-mean-you-bos)-- ;)
23:08:05 <bos> wow, cool, Cale should be illustrating iPhone video cames.
23:08:07 <bos> er, games.
23:08:17 <ToposTartare> bah, the pdf2svg script requires cairo
23:08:24 <bos> now the lambdas in circles shoot at the etas on the other side of the barrier!
23:09:03 <bos> join two cartesian closed categories before the clock runs out, or you will lose!
23:09:30 <medfly> I wonder if that would lead to people knowing a thing or two about mathematics
23:09:39 <quicksilver> bos: create your own natural transformation and upload it to your facebook page to challenge your friends?
23:09:42 <medfly> like games that teach little kids arithmetic
23:09:55 <Cale> The game will involve the player typing TikZ commands frantically.
23:10:17 <quicksilver> if you could somehow slip category theory into farmville you'd increase the size of mathmematical community by 3 orders of magnitude overnight.
23:10:28 <medfly> haha
23:10:31 * bos has earned a lemma in Categoryville!
23:10:40 <Cale> \filldraw[fill=white,draw=black] (-1,-2) circle (0.25) node {$\lambda$};
23:11:29 <ddarius> Natural transformations are easy to make.
23:12:04 * bos goes back to staring balefully at GHC's inliner.
23:12:54 <c_wraith> > '-' <$ [1..10]
23:12:55 <lambdabot>   "----------"
23:13:02 <c_wraith> that's a truly bizarre function
23:13:21 <ddarius> It seems useless, but turns out to be pretty handy.
23:13:35 <Cale> > '-' <$ Just 5
23:13:37 <lambdabot>   Just '-'
23:13:40 <c_wraith> I kept myself from saying useless, because I figure it has uses...  I just can't see them yet. :)
23:13:41 <ddarius> > (fmap . const) '-' [1..10]
23:13:43 <lambdabot>   "----------"
23:13:50 * copumpkin gives up
23:14:01 <ddarius> c_wraith: Write a parser using applicative notation (primarily)
23:14:06 * quicksilver notes that other languages have operators like <$ [1..10]
23:14:15 <copumpkin> Cale: I have some TeX code for that diagram if you want, but I'm not going to waste any more time trying to get it into svg :P
23:14:20 <quicksilver> in perl, "-" x 10 (IIRC)
23:14:33 <quicksilver> <$ is very handy in reactive systems too
23:14:39 <ddarius> quicksilver: But do they have operators/functions like (<$) ?
23:14:48 <quicksilver> take an event which has the *timings* of some other event, but constant value
23:14:57 <Cale> copumpkin: Wasn't it ToposTartare who was going to do it?
23:15:02 <copumpkin> Cale: that's me :P
23:15:10 <Cale> oh
23:15:15 <c_wraith> Cale wasn't around for that joke
23:15:19 <copumpkin> or if anyone else feels like having a go at it: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12066#a12066
23:15:27 <copumpkin> (for http://en.wikipedia.org/wiki/Dagger_compact_category)
23:15:40 <quicksilver> there should be a TeX 2 SVG web service
23:15:46 <copumpkin> yeah :/
23:17:19 <Cale> Were you guys here when I explained how evil the mathTeX server is?
23:17:37 <copumpkin> you mean lots of strcats and systems?
23:17:51 <Cale> yeah, and 5700 lines of poorly indented C code
23:17:56 <copumpkin> ugh
23:18:12 <Cale> with a few hundred lines of embedded image data
23:18:22 <copumpkin> wow, in the code?
23:18:26 <Cale> yes
23:18:30 <Cale> lots of sketchy looking implementations of common string routines
23:18:37 <Cale> and an implementation of MD5
23:18:44 <opqdonut> :D
23:19:00 <opqdonut> it's a shame TeX hasn't kept up with all the uses it's being put to
23:20:45 <sieni> opqdonut: wait until LaTeX 3, that'll solve all problems, like GNU Hurd and Duke Nukem Forever!
23:20:49 <Cale> oh, and every line has a comment on it
23:21:16 <copumpkin> x++; /* set x to its old value plus one */
23:21:22 <Cale> yes, like that
23:21:27 <copumpkin> wow
23:21:36 <c_wraith> I was hoping the comments would be something useful.  like hamlet.
23:21:42 <Cale>   if ( (linelen=strlen(pathline)) > 0 ) { /* ignore empty lines */
23:21:42 <Cale>     if ( linelen < pathlen ) {		/* new shortest path */
23:21:42 <Cale>       strcpy(pathbuff,pathline);	/* store shortest for caller */
23:21:42 <Cale>       pathlen = linelen; }		/* and reset new shortest length */
23:21:43 <Cale>     nlines++; } }			/* count another non-empty line */
23:22:00 <copumpkin> lol
23:22:45 <kmc> x += 3;  // add 4 to the value stored in x
23:22:48 <Cale> This is in the implementation of locatepath, which is a function that ``determines the path to program with popen("locate 'program'")''
23:23:15 <copumpkin> ugh
23:23:27 <copumpkin> write a ****ing shell script :P
23:24:46 <Cale> oh, and every function has a ~10 line header describing each of its arguments in excruciating detail. Not that this sort of information is unwelcome, but...
23:24:47 <copumpkin> does anyone know where I can find (introductory) information on the term "algebraic theory"?
23:25:03 <Cale> That term is kind of vague
23:25:14 <Cale> Do you have moar context?
23:25:39 <copumpkin> well, psykotic mentioned it in one of his reddit comments, and alluded to it being about algebraic structures with conditional laws (i.e., they aren't algebraic theories)
23:25:46 <copumpkin> so a field wouldn't be a theory, but a semiring is
23:25:49 <Cale> oh
23:26:11 <Cale> perhaps it's in the universal algebra sense
23:26:22 <copumpkin> very brief mention of it in the universal algebra wiki page, yep
23:26:40 <Cale> Or perhaps he means what can be encoded as the algebras of some monad
23:26:52 <Cale> (though I'm not certain about the status of fields there...)
23:27:07 <Cale> Actually I bet fields are the algebras of some monad.
23:27:21 <copumpkin> http://www.reddit.com/r/programming/comments/9ybto/a_formalization_of_darcs_patch_theory_using/c0f2pt6
23:28:00 <bos> i wish i could get the inliner to do my bidding.
23:28:15 <copumpkin> bos: what's it not doing?
23:28:22 <copumpkin> well, not inlining I guess :)
23:28:49 <Cale> (or inlining too much? :)
23:29:32 <bos> copumpkin: i have an inner loop in some stream fusion code where if i inline the loop body, little leaf functions don't get inlined into it, so it runs in 8 seconds. but if i don't inline it, the leaf functions do get inlined, and it runs in 0.4 seconds. but i want both the loop body *and* the leaf functions inlined!
23:29:44 <copumpkin> wow
23:29:49 <bos> and ghc is steadfastly refusing to give me my inline pony.
23:30:16 <bos> inlining is incredibly important for little leaf functions in inner loops.
23:30:28 <Veinor> suppose I have an f :: Int -> Int -> Int, and I have a set of Ints. How can I define an enlarge :: Set Int -> Set Int that enlarges its original argument by repeatedly adding f applied to all its elements, recursively?
23:30:34 <copumpkin> yeah
23:31:25 <copumpkin> bos: that seems really weird actually
23:31:38 <copumpkin> I'd think the inlining would go the other way around
23:31:46 <kmc> Veinor, look at Set.fold?
23:31:48 <kmc> :t S.fold
23:31:48 <lambdabot> forall a b. (a -> b -> b) -> b -> S.Set a -> b
23:32:02 <bos> copumpkin: if you mark a function as INLINE, ghc will not inline other functions into it.
23:32:03 <kmc> you want to enlarge to a fixed point?
23:32:11 <Veinor> yeah, enlarge it to its fixed point
23:32:25 <copumpkin> by the way Set Int is a lot more efficient as IntSet
23:32:38 <copumpkin> bos: ack :/
23:32:44 <Veinor> so if f x is 2 * x for x < 10, x otherwise, I want enlarge f [2,3,5] to be [2,3,5,4,6,10,8]
23:32:52 <Veinor> abusing notation, but you get the point!
23:33:15 <copumpkin> how do you express the constraint?
23:33:24 <Veinor> although... hm
23:33:34 <kmc> wait, how many args does f take?
23:33:38 <ddarius> copumpkin: TTT probably has some of the information you are looking for.
23:33:39 <Veinor> oh yeah, d'oh
23:33:56 <Veinor> f takes 2 args. so let f x y = min (x+y), 10
23:33:57 <Cale> x == x `S.union` S.map f x
23:34:02 <Cale> oh
23:34:09 <Veinor> bleh
23:34:15 <bos> copumpkin: yeah, this is probably where i invoke the help of the simons.
23:34:25 <Cale> Veinor: You want to apply it to all pairs?
23:34:29 <Veinor> right.
23:34:33 <copumpkin> bos: sounds like a pretty big limitation in the inliner, so probably :/
23:34:39 <Veinor> and then apply it to all pairs again, and again, and again, until I get a fixed point
23:34:59 <bos> copumpkin: it's understandable, in a way. it's intended to prevent the inliner from going into a loop.
23:35:24 <copumpkin> seems like it could do a loop detection phase first, then go and do the inlining
23:35:42 <copumpkin> ddarius: cool, I'll read more of it :)
23:35:43 <kmc> :t \f s -> let es = S.elems s in s `S.union` (S.fromList [f x y | x <- es, y <- es])
23:35:44 <lambdabot> forall a. (Ord a) => (a -> a -> a) -> S.Set a -> S.Set a
23:35:51 <ddarius> copumpkin: Good luck.
23:35:58 <copumpkin> I'll need it :)
23:36:01 <kmc> @pl \xs -> [(x,y) | x <- xs, y <- xs]
23:36:01 <lambdabot> liftM2 (:) (((x, y) | x) <-) (return . (y <-))
23:36:14 <kmc> whaaaat
23:36:16 <copumpkin> at least I have #haskell if something doesn't make sense
23:36:20 <kmc> is that a section of <- ?
23:36:26 <copumpkin> sweet
23:36:31 <Cale> kmc: @pl doesn't understand list comprehensions
23:36:33 <Veinor> o hwait, no it's not going to be pairwise. Misread the wikipedia article :/
23:36:36 <copumpkin> that's a pretty awesome @pl
23:36:40 <kmc> hehe
23:36:53 <Veinor> sectioning <-... I don't even know how that would work
23:37:06 <kmc> first class patterns and bindings
23:37:13 <kmc> what's the best pl for the cartesian product of two lists?
23:37:21 <ddarius> liftM2 (,)
23:37:32 <kmc> oh nice
23:37:36 <kmc> thanks
23:37:38 <copumpkin> or even liftA2
23:37:44 <Cale> for n lists, it would be sequence :)
23:37:46 <kmc> > liftA2 (,) [1,2,3] [4,5,6]
23:37:47 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
23:37:57 <kmc> yeah i remember that from haskell-cafe a long while ago
23:38:03 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
23:38:05 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
23:38:08 <Veinor> hm, okay. basically, I guess my question is this:
23:38:10 <kmc> people were golfing and then someone said just "sequence"
23:38:17 <copumpkin> > sequence . sequence $ [[1,2,3],[4,5],[6,7,8]]
23:38:19 <lambdabot>   [[1,1,1,1,1,1,2,2,2,2,2,2,3,3,3,3,3,3],[1,1,1,1,1,1,2,2,2,2,2,2,3,3,3,3,3,5...
23:38:33 <copumpkin> :o
23:38:37 <Veinor> I have a f that takes an a and returns an a, and I have an a0. How can I apply f to a0 until I get to a fixed point?
23:38:53 <Veinor> that's basically what it boils down to.
23:39:10 <copumpkin> :o
23:39:13 <bos> wow, holy crap. my haskell Unicode-aware "wc" code is 2x faster than GNU wc.
23:39:18 <copumpkin> nice!
23:39:21 <Veinor> haha
23:39:23 <ddarius> Veinor: It can be done pretty easily using either iterate or until.
23:39:25 <kmc> :t \f x -> takeWhile (uncurry (/=)) $ let xs = iterate f x in zip xs $ tail xs
23:39:26 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> [(a, a)]
23:39:41 <kmc> :t \f x -> fst $ last $ takeWhile (uncurry (/=)) $ let xs = iterate f x in zip xs $ tail xs
23:39:42 <ddarius> bos: Does it have all the features of GNU's?
23:39:42 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> a
23:39:59 <bos> ddarius: i'm just measuring it against "wc -m"
23:40:00 <kmc> :t until
23:40:01 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
23:40:02 <copumpkin> bos: are you somehow doing that thing that ndm mentioned in his supero presentation? encoding the in-word-ness in the program counter?
23:40:18 <kmc> > until (> 10) succ 0
23:40:19 <lambdabot>   11
23:40:27 <bos> copumpkin: i'm just doing a character count.
23:40:34 <copumpkin> oh
23:41:14 <c_wraith> but unicode-aware characters, rather than bytes?
23:41:18 <bos> yes
23:41:23 <bos> UTF-8
23:41:42 <c_wraith> you don't support every encoding ever? >_>
23:41:56 <bos> that's what i was testing here.
23:41:58 <ddarius> :t \f a0 -> fst $ until (uncurry (==)) (f . fst &&& fst) (a0, undefined)
23:42:00 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> a
23:42:10 <kmc> ooh
23:42:25 <copumpkin> doing this would be easier if you had a set monad
23:42:27 <kmc> :t \f -> f . fst &&& fst
23:42:28 <copumpkin> I think
23:42:28 <lambdabot> forall a c b. (a -> c) -> (a, b) -> (c, a)
23:42:40 <kmc> :t fst &&& fst
23:42:41 <lambdabot> forall c b. (c, b) -> (c, c)
23:43:00 <kmc> :t \f -> (f.fst) &&& fst
23:43:01 <lambdabot> forall a c b. (a -> c) -> (a, b) -> (c, a)
23:43:11 <Veinor> I'm trying to see if that does what I want, kmc
23:44:20 <ddarius> > until id (const False) True
23:44:21 <lambdabot>   True
23:44:38 <ddarius> s/(a0, undefined)/(f a0, a0)
23:44:56 <copumpkin> if you did have a Set monad, a foldM seems like it would be sufficient for this
23:45:08 <Veinor> hm.
23:45:14 <copumpkin> or maybe not, since there's nothing obvious to fold over
23:45:30 <copumpkin> an untilM would, but it isn't in Control.Monad
23:45:41 <c_wraith> well, foldM over iterateM
23:45:47 <c_wraith> But you'd need to write iterateM, too
23:45:48 <c_wraith> :)
23:45:59 <Veinor> @hoogle (a -> b) -> a -> (a,b)
23:45:59 <lambdabot> Control.Monad.Writer.Class listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
23:46:00 <lambdabot> Network.BufferType buf_span :: BufferOp a -> (Char -> Bool) -> a -> (a, a)
23:46:00 <lambdabot> Data.Graph.Inductive.Query.Monad applyWith' :: Monad m => (a -> b) -> GT m g a -> g -> m (b, g)
23:46:03 <Veinor> aw
23:46:11 <copumpkin> Veinor: id &&& f
23:46:25 <Veinor> thank you
23:46:50 <c_wraith> Honestly, there are a bunch of things that seem like they should be in Control.Monad, but aren't.  like untilM and iterateM
23:47:56 <Veinor> so I'm thinking something like (until \x -> fst x == snd x) (id &&& \(x -> f snd x))
23:48:02 <Veinor> er
23:48:08 <Veinor> so I'm thinking something like until (\x -> fst x == snd x) (id &&& \(x -> f snd x))
23:48:21 <Veinor> I'm sure I butchered that horribly
23:48:42 <copumpkin> liftA2 (==) fst snd
23:48:43 <copumpkin> :P
23:48:47 <Veinor> :P
23:48:47 <copumpkin> if you really want to be pointless
23:49:47 <c_wraith> :t join (==)
23:49:48 <lambdabot> forall a. (Eq a) => a -> Bool
23:49:56 <c_wraith> > join (==) 5
23:49:58 <lambdabot>   True
23:50:00 <copumpkin> c_wraith: almost const True ;)
23:50:04 <c_wraith> nearly!
23:50:07 <Veinor> that barfs anyway, trying to construct an infinite type
23:50:21 <copumpkin> :t liftA2 (==) fst snd
23:50:22 <lambdabot> forall b. (Eq b) => (b, b) -> Bool
23:50:25 <c_wraith> Veinor:  f $ snd x
23:50:50 <copumpkin> > join (==) (0 / 0)
23:50:51 <lambdabot>   False
23:51:08 <kmc> isn't that (uncurry (==))
23:51:10 <kmc> or am i missing something
23:51:22 <c_wraith> kmc: it's \x -> x == x
23:51:23 <copumpkin> kmc: good point :P
23:51:58 <c_wraith> > 0 / 0
23:52:00 <lambdabot>   NaN
23:52:17 <c_wraith> Ah.  and NaN == _ = False
23:58:25 <tensorpudding> > NaN + 1
23:58:25 <lambdabot>   Not in scope: data constructor `NaN'
23:58:44 <tensorpudding> can't do arithmetic with NaN
23:58:55 <tensorpudding> which is...expected
23:59:05 <bos> yes you can.
23:59:13 <bos> you just don't get useful answers.
23:59:26 <tensorpudding> :t NaN
23:59:26 <lambdabot> Not in scope: data constructor `NaN'
23:59:34 <bos> > 1/(0/0)
23:59:36 <lambdabot>   NaN
23:59:46 <bos> NaN isn't a data constructor.
