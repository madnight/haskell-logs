00:00:00 <c_wraith> I've defeated the sharks!
00:00:06 <mmorrow> , let g x = let k = foldl' (+) 0 [1..x] in \y -> let !o = k in o + y in time (g 1000000 `seq` ())
00:00:08 <lunabot>  (0.0,())
00:00:22 <mmorrow> , let g x = let !k = foldl' (+) 0 [1..x] in \y -> k + y in time (g 1000000 `seq` ())
00:00:25 <lunabot>  (0.258961,())
00:00:54 <mmorrow> one saves the work for the lambda, the other does the work up front
00:03:03 <mmorrow> , let g x = let !k = foldl' (+) 0 [1..x] in \y -> k + y in let one = g 1000000; t1 = time (one `seq` ()) in t1 `seq` (t1, time (one 42))
00:03:05 <lunabot>  ((0.254962,()),(0.0,500000500042))
00:03:24 <mmorrow> , let g x = let k = foldl' (+) 0 [1..x] in \y -> let !o = k in o + y in let one = g 1000000; t1 = time (one `seq` ()) in t1 `seq` (t1, time (one 42))
00:03:27 <lunabot>  ((0.0,()),(0.189972,500000500042))
00:03:47 <Axman6> blackdog: hmmmmmmm, EC2 looks very interesting
00:05:05 <kmc> :t time
00:05:05 <lambdabot> Not in scope: `time'
00:05:17 <kmc> , ty 'time
00:05:18 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name -> a'
00:05:19 <mmorrow> it's from timeit
00:05:23 <mmorrow> , [$ty| time |]
00:05:26 <lunabot>  forall a . a -> (Double, a)
00:05:39 <kmc> cool
00:05:41 <kmc> lunabot has IO?
00:05:50 <kmc> , putStrLn "whee"
00:05:52 <lunabot>  luna: No instance for (GHC.Show.Show (GHC.IOBase.IO ()))
00:05:59 <mmorrow> it's unsafePerformIO'ed, since no IO for the bot
00:06:05 <kmc> ah
00:06:15 <kmc> , unsafePerformIO $ putStrLn "whee"
00:06:16 <lunabot>  luna: Not in scope: `unsafePerformIO'
00:06:19 <kmc> :)
00:06:25 <mmorrow> :)
00:07:42 <mmorrow> , let f = foldr (.) id (replicate 1000000 id) in time (f `seq` ())
00:07:44 <lunabot>  (0.0,())
00:07:46 <mmorrow> , let f = foldl (.) id (replicate 1000000 id) in time (f `seq` ())
00:07:48 <lunabot>  (0.41093799999999997,())
00:08:02 <mmorrow> (notice that `f' :: a -> a)
00:09:09 <mmorrow> the fold builds 1000000 partial applications of (.) to id id in the heap
00:09:49 <mmorrow> the foldr builds one partial app of (.) to id and (thunk of rest)
00:10:07 <mmorrow> *the fold_l_ builds ...
00:10:15 <mmorrow> .. 1000000 ...
00:13:10 <mmorrow> well, the foldr eventually has to build all of those if you end up evaluating the whole pipeline
00:14:01 <mmorrow> but it does it in O(1) mem (wrt the partial applications) rather than O(n) like foldl
00:14:15 <mmorrow> exactly the opposite of the situation with e.g. (+)
00:20:19 <mmorrow> , let g x = let !k = foldl' (+) 0 [1..x] in \y -> k + y; go = g 1000000 in go `seq` time (foldl' (+) 0 (fmap go [0..100000]))
00:20:22 <lunabot>  (5.9990999999999996e-2,50000555000550000)
00:20:23 <mmorrow> , let g x = let k = foldl' (+) 0 [1..x] in \y -> k + y; go = g 1000000 in go `seq` time (foldl' (+) 0 (fmap go [0..100000]))
00:20:26 <lunabot>  (0.276958,50000555000550000)
00:20:34 <mmorrow> what a difference a ! makes!
00:20:43 <mmorrow> (in the right place)
00:21:00 <mmorrow> , let g x = let k = foldl' (+) 0 [1..x] in \y -> let !o = k in o + y; go = g 1000000 in go `seq` time (foldl' (+) 0 (fmap go [0..100000]))
00:21:03 <lunabot>  (0.275959,50000555000550000)
00:22:30 <mmorrow> hmmm
00:22:45 <mmorrow> that might be because the `k' gets inlined since it's only used once?
00:23:03 <mmorrow> , let g x = let k = foldl' (+) 0 [1..x] in \y -> k `seq` k + y; go = g 1000000 in go `seq` time (foldl' (+) 0 (fmap go [0..100000]))
00:23:15 <lunabot>  (0.26696,50000555000550000)
00:23:15 <mmorrow> , let g x = let k = foldl' (+) 0 [1..x] in \y -> k + k + y; go = g 1000000 in go `seq` time (foldl' (+) 0 (fmap go [0..100000]))
00:23:15 <lunabot>  (0.326951,100001105001050000)
00:23:17 <mmorrow> no
00:24:09 <mmorrow> oh right
00:24:14 <mmorrow> since `k' depends on `x'
00:24:30 <mmorrow> confused myself for a second there..
00:25:47 <mmorrow> actually no, whytf does the k get re-evaluated each time inside the lambda?
00:27:41 <mmorrow> oh. it doesn't, it's just that the "go `seq` ...." is cheating wrt time for the !k outside the lambda case, since it's doing the work outside of the time function
01:02:25 <ivanm> what would be the best/most efficient way (without using a regex) to see if a bytestring starts "foo-x" where foo is a known string and x is any digit?
01:02:49 <ivanm> check if it starts with foo-, drop it, then check if the first char is a digit?
01:03:11 <McManiaC> Data.ByteString isInfixOf
01:03:12 <McManiaC> ^^
01:03:27 <ivanm> yeah, for part of it
01:03:37 <ivanm> oohhh, just found breaksubstring :o
01:03:43 <Chile> that's overkill
01:03:50 <Chile> you can just check the last position
01:03:58 <ivanm> check the last position of what?
01:04:10 <Chile> oh, I see, there's more after this?
01:04:18 <ivanm> Chile: yes ;-)
01:04:29 <ivanm> I'm just interested in what it starts with
01:05:13 <Baughn> Indexing of strict bytestrings is O(1) (and cheap).. indexing of lazy ones is O(n), but that only actually matters if your "foo-" string is rather long
01:05:43 <Chile> then yeah, check if it starts with foo-, then just random access into length foo + 1
01:06:13 <Chile> at worst it'll be the same as dropping it
01:06:24 <ivanm> Baughn, Chile: *nod*
01:06:30 <Baughn> Oh, and the O(n) for lazy indexing has a very small constant factor
01:06:37 <Baughn> Since it's a chunked encoding..
01:06:56 <Baughn> It's something like 1/65000 that of indexing a list. :P
01:07:55 <ivanm> yeah, I'm using a strict bytestring
01:08:35 <Baughn> ivanm: http://www.skytopia.com/project/fractal/2mandelbulb.html <- Did you see this?
01:08:52 <ivanm> nope, I didn't
01:10:07 <ivanm> oooohhhh..... pretty...
01:10:16 <McManiaC> wicked
01:10:17 <McManiaC> :)
01:10:22 <Baughn> They're working on a GPU-accelerated renderer. This might be enough to get me to buy a GPu. :3
01:11:10 <kmc> the other page had better pictures (and less math)
01:11:16 <ivanm> Baughn: so.... you don't ahve any graphics card? :/
01:11:21 <ivanm> kmc: which other page?
01:11:30 <Baughn> ivanm: Card? No..
01:11:39 <kmc> http://www.skytopia.com/project/fractal/mandelbulb.html
01:11:45 <ivanm> so how do you view that web page? :p
01:11:46 <Baughn> ivanm: I have this nifty intel chip. Um.. yeah.
01:11:56 <ivanm> Baughn: well, so you still have a GPU...
01:12:08 <Baughn> ivanm: It's missing the P
01:12:44 <ivanm> it still does some (albeit limited) processing, does it not?
01:12:58 <ivanm> in that it has to convert it to a format your display can use, etc. ...
01:14:40 <Baughn> ivanm: That's pushing it. It ain't an nvidia card, that's for sure.
01:14:56 <Baughn> ivanm: Though I do actually have a GPU in my other computer.. it hasn't been updated for years, though
01:15:01 <ivanm> neither is an AMD one! :p
01:15:30 <Baughn> I noticed.
01:15:45 <Baughn> AMD makes truly horrid opengl drivers, and I've been writing some opengl code..
01:20:02 <ivanm> I'm hoping that noveau is in a usable state by the time I buy myself a desktop...
01:20:21 <kmc> i've never had problems with nvidia drivers for linux
01:20:53 <ivanm> Baughn: I'm really missing indent's ability to write the function name in for you if you keep tabbbing... *hint, hint*
01:20:54 <ivanm> :p
01:21:08 <ivanm> kmc: my brother has (I have an intel GPU)
01:21:35 <ivanm> he has to keep switching between noveau for stability and nvidia binary if he wants to do any 3D stuff
01:22:28 <Baughn> ivanm: haskell-mode is open-source... *hint, hint*
01:22:47 <ivanm> Baughn: my elisp-fu is weak...
01:22:53 <Baughn> ivanm: So is mine
01:23:45 <ivanm> obviously not as weak as mine...
01:24:07 <Baughn> It once was
01:26:15 <ivanm> you mean you weren't born with any innate knowledge of emacs lisp? :p
01:26:39 * ivanm wishes for a bytestring version of filepath...
01:26:40 <Baughn> I know it's hard to believe, but no!
01:26:52 <Baughn> I, too, once learned it.
01:27:25 <therp> wha'ts noveau?
01:27:39 <ivanm> therp: the new open-source driver for nvidia GPUs
01:27:50 <therp> ivanm: ah interesting
01:27:50 <ivanm> IIRC, it has 2D support and they're working on 3D support
01:28:15 <Baughn> What it does not have is power-management or vdpau, so.. non-starter for me
01:28:28 <Baughn> If not for the former, I'd at least try it. :P
01:29:20 <therp> ivanm: but frankly, I love nvidia's binary drivers. 1 1/2 years ago, I got an intel board because I wanted to use the open drivers for the intel GPUs. what followed was a year of suffering
01:32:23 <Baughn> The specs are open. Doesn't mean the drivers are /good/.
01:32:43 <Baughn> nVidia may not be able to open-source theirs, but at least they've put a lot of effort into making the drivers work well
01:35:42 <tensorpudding> nvidia drivers used to suck once
01:35:52 <tensorpudding> but they've gotten better
01:36:08 <Baughn> I remember those days. Yes, they have.
01:36:12 <Baughn> These days, they just work
01:36:20 <ivanm> 100% ?
01:36:29 <ivanm> my brother keeps complaining about stability issues...
01:36:34 <Baughn> 100% for me
01:36:52 <Baughn> ivanm: Maybe he has a very old GPU that hasn't seen updated drivers in years?
01:37:11 <Baughn> ivanm: Or maybe the stability issues have a different cause, like hardware failure
01:37:51 <therp> tensorpudding: I'm using nvidia drivers since "geforce 2". I never had stability problems with them. yes they do have some bugs, but those usuall were not of the random-crashs kind.
01:37:55 <ivanm> yeah, it's from a laptop that's around 5 years old
01:37:56 <Baughn> ivanm: I haven't had a problem with the nvidia drivers for years, much less a crash; and that's with me stress-testing them by feeding them bad opengl commands all the time
01:38:22 <Baughn> Which /will/ crash the ATI drivers
01:38:55 <ivanm> heh
01:39:29 <tensorpudding> i should have specified the linux drivers
01:39:53 <Baughn> The linux drivers used to be bad and crashy, but that was back in the geforce 1/2 days. :P
01:40:06 <tensorpudding> i had crashes much more recently than that
01:40:29 <tensorpudding> around 2005 or so
01:40:42 <Baughn> Did you report them?
01:40:58 <tensorpudding> i might have
01:41:08 <tensorpudding> they were covered in the nvidia linux driver fora
01:41:16 <tensorpudding> that was back in my gentoo days
01:41:16 <Baughn> I've found that they're very responsive to any actual problems you find
01:41:40 <tensorpudding> and i was yet inexperienced
01:42:28 <tensorpudding> but in any event, i recently installed a pci nvidia card on a build for my dad, and it gave repeated BSOD's until i managed to get the nvidia drivers installed
02:19:58 <nlogax> i see GCC has taken the #1 spot in the thread ring benchmark now
02:21:33 <Axman6> what? o.O
02:21:47 <ivanm> hey Axman6
02:21:50 <nlogax> http://shootout.alioth.debian.org/u32q/benchmark.php?test=threadring&lang=all&box=1
02:21:58 <Axman6> wtf, how did they do that
02:21:59 <nlogax> using much more memory but..
02:22:11 <Axman6> it was 20 times slower than the haskell one
02:22:44 <koeien37> they use "LWP", whatever that may be
02:23:08 <Axman6> light weight processes i'd guess
02:23:09 <c_wraith> light-weight processes.  it's a library
02:23:14 <Axman6> that's not portable though
02:23:26 <Axman6> isn't that coroutines?
02:23:40 <c_wraith> I don't know what the implementation is.
02:23:59 <c_wraith> if it's cooperative, that's an interesting approach to the problem.
02:25:13 <dolio> It looks like ordinary locking.
02:25:27 <dolio> Cooperative threading is ruled out, I think.
02:28:24 <Axman6> it even says in the damn code that it runs in a single thread of execution
02:28:47 <Axman6> but the program is required to make 503 _threads_ >_<
02:29:04 <koeien37> GHC doesn't use pthreads, right?
02:29:12 <c_wraith> why'd they pick 503?
02:29:31 <Axman6> prime number
02:29:32 <nipuL> is is possible to shorten the type class? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12189#a12189
02:31:35 <c_wraith> heh.  that really does look like cheating.
02:32:04 <dolio> Yeah, it probably isn't legal.
02:32:13 <koeien37> i disagree
02:32:24 <koeien37> define "thread"
02:32:25 <Axman6> they've nocked back haskell programs for being far closer to the rules than this
02:32:59 <dolio> It doesn't matter if you disagree.
02:33:11 <dolio> Look in the "interesting alternative programs" section.
02:33:17 <Axman6> like the one that uses binary trees, they wouldn't let us use lazy evaluation
02:33:34 <Axman6> yeah, there's Java ones what do basically the same thing i think
02:34:12 <dolio> "cooperative threads and other programs with custom schedulers will be listed as interesting alternative implementations"
02:34:15 <nlogax> would anyone care to explain the difference in noob language? i thought ghc didn't use "real" threads either
02:34:26 <Axman6> which is what that program is doing
02:34:46 <koeien37> dolio: why are Haskell programs allowed to use the GHC RTS, but C programs are not allowed to use some kind of "green threads"?
02:34:52 <kmc> nlogax, ghc maps Haskell-level threads onto OS threads, in many-one fashion
02:34:54 <Axman6> nlogax: ghc does use real threads, to run the haskell threads.
02:35:00 <kmc> but they are still real preemptively scheduled threads
02:35:05 <dolio> nlogax: It doesn't use a cooperative scheduler tailored to the fact that there's no real parallelism in the benchmark, though.
02:35:10 <Axman6> kmc: because they're  built into the ;language
02:35:13 <Axman6> uh, koeien37
02:35:44 <c_wraith> yeah, the big issue seems to be the scheduling mechanism
02:35:52 <koeien37> Axman6: ok, then if i have a programming language with a very efficient operation, "threadring503", then this would be allowed?
02:35:59 <dolio> koeien37: They're allowed to use green threads as long as the green threads use a general-purpose preemptive scheduler, instead of a cooperative scheduler tailored to the benchmark.
02:36:09 <kmc> the GHC RTS is an additional preemptive scheduler on top of the OS's preemptive scheduler
02:36:20 <koeien37> dolio: ok, i see, preemptive != cooperative is essential
02:36:21 <kmc> not a cooperative coroutines library on top of a single thread
02:36:49 <Axman6> the haskell one does actually use multiple threads
02:37:10 <koeien37> but it shouldn't be *that* hard to do the same thing in C, right? although it is some work to create such a library, I guess
02:37:37 <Maddas> koeien37: I think you're not really looking at the idea behind the shootout :-)
02:37:45 <Maddas> It is not to demonstrate that you can implement other languages in C.
02:37:47 <dolio> Well, that C program specifically says it doesn't use the lwp preemptive scheduler (I think), because it's slower.
02:37:50 <mmorrow> koeien: you'd need to implement a central scheduler that uses a generic scheduling algorithm
02:38:27 <mmorrow> koeien: rather than yield()'ing between another coroutine/or-n
02:38:33 <koeien37> dolio: yes, it says so in the "function" mutex_lock
02:39:31 <dolio> The real question is: why is cheating in Java 4x as fast as cheating in C? :)
02:40:02 <koeien37> yeah, that surprises me too
02:40:04 <ivanm> dolio: because there's so much room/scope to cheat in Java?
02:40:06 <dolio> Cheating in Lua is faster, too, apparently.
02:40:07 <ivanm> ;-)
02:40:15 <koeien37> especially since it needs to start the VM
02:40:18 <ivanm> by "cheating", we're referring to using external libraries?
02:40:26 <ivanm> koeien37: the use the server mode to get rid of that IIRC
02:40:27 <koeien37> ivanm: no, using cooperative multitasking
02:40:34 <ivanm> and average out runtimes to try and remove that value
02:40:35 <ivanm> koeien37: oh
02:41:09 <koeien37> dolio: yeah, it i sprobably against the rules, you're right
02:41:27 <c_wraith> cheating in lua means co-routines, almost certainly
02:42:00 <dolio> Yeah. Lua doesn't appear to have an accepted program.
02:42:08 <mmorrow> sw17ch has this cool C lib for coroutines/central scheduler http://swtch.com/libtask/
02:44:38 <mmorrow> it uses ucontext.h, but i was looking at the lua coroutine code "luacoco", and it optionally uses hand-coded asm, modified jmp_buf, ucontext.h in order of preference, and apparently the former two are faster
02:44:54 <mmorrow> since ucontext saves signal context too
02:45:42 <mmorrow> but anyways, you could totally adapt sw17ch's lib to implement something with the features that GHC's threads have
02:46:30 <mmorrow> sw17ch's code is super clean too, nice lib
02:57:19 <ivanm> anyone know what the shrink method in QC's Arbitrary class does (it's in QC2; not sure about 1) ?
02:57:24 <ivanm> s/does/is for/
02:57:45 <mmorrow> here's a prog that uses libtask http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4949#a4949
03:01:48 <mmorrow> ivanm: i've wondered that too
03:02:04 <mmorrow> i'm baffled as to how quickcheck2 works
03:03:03 <Heffalump> ivanm: it's for shrinking :-)
03:03:11 <Heffalump> in particular to help QC find a minimal failing case
03:03:31 <Heffalump> if it finds a test failure, then it repeatedly tries to shrink the counterexample
03:03:47 <Heffalump> so shrink x should return a list of values that are one step smaller than x in all possible ways
03:04:32 <mmorrow> ah
03:05:59 <ivanm> Heffalump: "shrinking" == ? :s
03:08:11 <Heffalump> ivanm: making things smaller, as I said
03:08:13 <Axman6> why do people alwayds choose terrible names for things in C?
03:08:36 <ivanm> Heffalump: what do mean by "making things smaller" though? ;-)
03:08:44 <ivanm> i.e. can you provide an example?
03:09:28 <Axman6> specifically, why do people choose truncated, uninformative names for things?
03:09:42 <int-e> ivanm: for a list, you could return the list with the first, second, third, and so on element removed.
03:09:46 <ivanm> Axman6: probably from when they had limited memory, etc.
03:09:46 <Heffalump> well, for an Int, you might just return [x-1] if x is positive, and [x+1] if x is negative
03:09:53 <Heffalump> for a list, what int-e says
03:09:57 <ivanm> int-e: right
03:10:00 <Heffalump> Axman6: there's a trade-off between making code big, too
03:10:21 <ivanm> Axman6: remember the bug someone found in GHC where if the full module name was > 10 chars, the code was slower? :s
03:10:26 <ivanm> (was that ever fixed by the way?)
03:10:35 <ivanm> Heffalump: _does_ QC2 do that for ints/lists?
03:10:36 <int-e> ivanm: or you could decide that you don't care how big the counterexamples are and use const [].
03:10:53 <ivanm> right
03:10:55 <Heffalump> ivanm: can't remember exactly for ints. I'm sure it does for lists.
03:10:58 <Axman6> I prefer readable code over small code
03:11:05 <Heffalump> int-e: or just leave it out, as that's the default
03:11:17 <Heffalump> but it's a huge win to have shrinking, it really makes for great test cases
03:13:26 <ivanm> Heffalump: OK, different question about QC2: any idea how I would create a non-empty list of values that matches a predicate for use with Arbitrary?
03:13:43 <ivanm> oh, right, suchThat
03:13:55 <Heffalump> either that, or use a custom generator
03:14:09 <Heffalump> depends on how likely random values are to satisfy your condition
03:14:25 <ivanm> I need to produce a string with out any '<' or '>' values
03:14:44 <Heffalump> that should be fine then
03:16:00 <c_wraith> @ty (<$)
03:16:01 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
03:16:41 <c_wraith> @hoogle  (Functor f) => f a -> b -> f b
03:16:42 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
03:16:42 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
03:16:42 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
03:17:33 <int-e> ivanm: yes, it does something like that for lists - a bit more elaborate. it also tries to shrink the list elements individually.
03:17:59 <ivanm> *nod*
03:26:44 <sinelaw> just saw the CheatSheet. nice!
03:28:21 <fluxxen> how could one iterate a custom data type? do I need to implement some kind of enumeration?
03:28:36 <Axman6> you could derive Enum...
03:29:10 <fluxxen> Axman6 ok cool thanks
03:29:46 * ivanm is confused how to use the Positive type in QC2 to generate positive numbers...
03:35:16 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
03:35:16 --- topic: set by mauke on [Mon Nov 02 11:41:43 2009]
03:35:16 --- names: list (clog_ dschoepe reubens_ fluxxen adept paulvisschers njbartlett donri Schmallon1 fasta NEEDMOAR phyrex1an RayNbow m-i-l-a-n sinelaw lorandi pietras blueflute Arnar dikini XGas socpp gdgb macron blackdog blastbeat1 jyyou triplez iblechbot sasha76 blackh mexisme ikke Athas kayess_ shrughes Stefa1 mcclurmc a-s clog perspectival Dessous mattwynne simonf benl23 Pellwurst Beelsebob int-e wunki jayne r0bby willb emma zachk1 Modius_ hp_ bens earthy)
03:35:16 --- names: list (grouzen TR2N sprang dynamix pyNem shag ketil spaceodyssey det danvet carlocci eevar2 oskimura sioraiocht shambler lazni mr_ank cdiem smelk nvoorhies hackagebot c_wraith yowgi jones- QplQyer Mowah otsdr dolio zakwilson sigh caligula__ romanandreg nwf alvarezp angelixd_ lament kadoban ski_ medfly ski gogonkt Draconx wagle iaefai Rotaerk__ ablokzijl Cale whoppix SamB_XP jsgf Sup3rkiddo twb kniu roconnor novas0x2a Raynes kolmodin BMeph otto_s_)
03:35:16 --- names: list (astrocub malie yahooooo cjs juhp Gwern-aw1y abbe cgibreak tavelram Keiya gr00vy aluink Pewpewarrows ulfdoz luite ttmrichter Mr_Awesome Polarina mreggen Cobra^^ ivanm Philonous PsiOmega nnunley alphecca- gnuvince zax andrewsw-afk M| hsaliak__ skeeterbug1 mjrosenb dons pifish_ karld stepcut aempirei McManiaC wimt LeCamarade Alpounet Dunearhp_ chrisdone nathanic1 u_quark Kim^Walkman DEVOKUN saccade_ mahogny dixiecko crem Nereid_ da-x Gracenotes)
03:35:16 --- names: list (Elench dreixel niksnut gjl voker57__ Saizan_ PeakerWork mauke kuningas ChthonLaptop felipe_ jan_____ neurocyte pikhq sereven edwtjo sbok Poeir zygoloid kw317 joed Annie|Home sior|oifig Counter-Strike tmug flux dilinger _Jordan_ idnar jml ahf Axman6 spoop dmwit smg newsham levitation_ Apocalisp dibblego snorble dejones Philippa ertai Megant EvanCarroll fnordus taruti jlouis kanalj MacCoaster byorgey Jiten kalven Exteris igorgue jlaire raim0)
03:35:16 --- names: list (andun Tobsan ath ^Einstein drspider_ tamiko pcc1 emias deiga_ arkx Raevel ibid jvoorhis wornof BONUS_ samulihs geir_ kmeyer phr FauxFaux opqdonut greap nothingmuch agemo skaar stepnem gdsx magicman srcerer jystic jre2 cathper nornagon quicksilver qebab Deewiant pragma_ Innominate dionoea ath^ koninkje_away Sisu cods wang Elly majoh Ornedan epmf Taggnostr Peaker xian Whitesquall Igloo ortmage1 amuck CalJohn rasfar joga stalker borism Bleadof)
03:35:16 --- names: list (tew88 Bassetts Cthulhon cognominal nlogax snhmib blalb dino- geoaxis_ dankna augur DrSyzygy Heffalump SimonRC canvon_ And[y] Esmil nablaa guerby tilman Badger Jaak Twey @ChanServ rey_ ac Liskni_si wolverian tkr Lemmih eelco_ JaffaCake Aikawa_ leoncamel ben0x539 dcolish ddvlad takuan reubens sieni araujo dcoutts xinming ps-auxw bind_return ToRA jelly12gen jahgru ville rgr flippo gbacon wharrgarble LeoD heaumer_ deavid wisemanby _xor rdd`)
03:35:16 --- names: list (jabagawee Tomas Guest17379 SmurfOR kpreid kynky Veinor alexsuraci thorkilnaur EvilTerran jbauman lhnz Trafalgard mm_freak Raku^ matthew-_ Jedai djinni m4thrick Eelis eyck t Chile danopia kyagrd fhs StoneToad ijnek bumblebee waern tensorpudding sohum fihi09 gbeshers jtra aiko nathanic_work nominolo_ anders^^ baaba clanehin zhijie TML linkinus thoughtpolice Neronus jix Colours burp kmc ve pixel5 jaj alexbobp peddie loupgaroublond karihre)
03:35:16 --- names: list (tessier clarkb jamwt mulletron hiredman allbery_b trez eno Optimo jkramer jontore eek MyCatVerbs glith AnMaster eagletmt onodrim Nereid ksandstr nipuL sjanssen duairc reltuk +lunabot saccade erk __marius__ teneighty tromp_ dcoutts_ davidL PHO_ inimino orbitz desp endojelly bockmabe_ beibmozoi bd_ sebas__ Laney rapacity theclaw mux mokus_ mml`_ noj +lambdabot daed brx periodic thetallguy alip Blub\0 loop AndyP ziman Botje drhodes Gabbie)
03:35:16 --- names: list (welterde Vq qwr tltstc mdordal2 mfoemmel tuukkah OnionKnight mfp regulate noddy midnite Zao dfeuer gOcOOl epokal ray liff mw493 Maddas Baughn nominolo|uni birkenfeld Valodim Warrigal Ferdirand marmolak tarbo_ laz0r dqd maskd absentia zaarg icee Twigathy thetallguy1 Gilly cjay Blaketh lefant p_l aavogt cygnus_ jasonmay mikste sevvie guerrilla osfameron ehamberg flori profmakx lsthemes arjanoosting poe thedward sunfun jims doublethink_work)
03:35:16 --- names: list (avysk companion_square authentic jql anekos therp Boney mmmdonuts malouin koala_man qed desu kar-1 mlh droidcore SubStack jfoutz netcat tumult int_e jfredett dogmaT kakeman suiside mikm Paks webframp alexander2 wagle_home da-xw mjv pantsd_pcf ggreg_ sebbe1991 GNU\colossus _plcs_ impl mornfall pettter koeien prigaux aleator mmmulani Stephan202 ahihi anji_ saiam ystael Lycurgus nasloc__ sunnavy dek5 disgrntld ido Khisanth lanaer harlekin)
03:35:16 --- names: list (wdonnelly jvogel_ poucet Aisling danderson Nanar cdfh_ fxr Milo- shepheb integral jrockway wormwood BONUS shachaf shortcircuit olsner mle mercury^ Nafai jnwhiteh equanimity erg SeaPrior _br_ bran BrianHV nimred boyscared franksh mattam dumael sproingie stroan thomastc mshaw glitch qm13_ sgf_ lavish ned mrd drbean Vulpyne electrogeek +preflex Paradox924X)
03:35:29 <Axman6> blackdog: you around?
03:35:43 <mjrosenb> Heffalump: yup
03:35:55 <Heffalump> mjrosenb: no, then. But zip first, then fold.
03:36:04 <Heffalump> zipWith is just shorthand for map after zip.
03:37:21 <mjrosenb> yup
03:37:21 <mjrosenb> \f i l1 l2 -> foldl f i (zip l1 l2) :: (a -> (a1, b) -> a) -> a -> [a1] -> [b] -> a
03:37:44 <mjrosenb> @pl \f i l1 l2 -> foldl f i (zip l1 l2)
03:37:45 <lambdabot> flip flip zip . (((.) . (.)) .) . foldl
03:37:49 <mjrosenb> eww.
03:38:18 * mjrosenb sticks with the shorter one
03:41:32 <fluxxen> Axman6 if I wasn't to derive Enum, how could one do it otherwise?
03:41:51 <mjrosenb> actually, i do not want that
03:42:03 <mjrosenb> :t \f i l1 l2 -> foldl (uncurry f) i (zip l1 l2)
03:42:05 <lambdabot> forall a b a1 b1. (a -> b -> (a1, b1) -> (a, b)) -> (a, b) -> [a1] -> [b1] -> (a, b)
03:42:17 <mjrosenb> :t \f i l1 l2 -> foldl (curry f) i (zip l1 l2)
03:42:18 <lambdabot> forall c a b. ((c, (a, b)) -> c) -> c -> [a] -> [b] -> c
03:42:35 <Axman6> fluxxen: you'd have to implement Enum yourself
03:42:42 <mjrosenb> err
03:42:53 <mjrosenb> let me actually think about what i want, then do it
03:43:51 <fluxxen> Axman6 ok then I need to do that. need to create a full deck of cards with all the suits and then I have a function that joins them together. gonna try it out then thanks
03:44:03 * mjrosenb wants to uncurry the second argument
03:44:06 <Axman6> fluxxen: uh, what?
03:44:33 <mjrosenb> @pl \f (g,h) -> q f g h
03:44:33 <lambdabot> (`ap` snd) . (. fst) . q
03:45:00 * mjrosenb would rather see that with 'curry'
03:45:18 <zygoloid> Axman6: presumably 'data Card = Card Value Suit; data Value = Two | Three | Four | ...; data Suit = Diamond | Club | ...'
03:45:31 <fluxxen> zygoloid not quite but close
03:45:47 <c_wraith> the real issue is jokers.  They don't have suits.
03:46:08 <Axman6> Card Value Suit | Joker
03:46:10 <c_wraith> if they matter for a game you're playing, they make it ugly
03:46:11 <fluxxen> Hand card otherCards that holds Card which is Card Rank Suite, where Rank for numeric is (Numeric 5) etc
03:46:12 <zygoloid> c_wraith: never seen batman?
03:46:21 <zygoloid> c_wraith: the joker has suits!
03:46:36 <mjrosenb> Heffalump: yeah, not just that simlpe
03:47:00 <fluxxen> but now I need a function that creates the whole deck. I need to create it for one color and then i have a function <+ that add it together
03:47:10 <Heffalump> @pl curry
03:47:10 <lambdabot> curry
03:47:24 <Heffalump> @pl \(g, h) -> f g h
03:47:24 <lambdabot> uncurry f
03:47:25 <Axman6> @unpl curry
03:47:25 <lambdabot> curry
03:48:01 <mjrosenb> @pl \f i l1 l2 -> foldl (\a (b,c) -> f a b c) i (zip l1 l2)
03:48:01 <lambdabot> flip flip zip . (((.) . (.)) .) . foldl . flip flip snd . (ap .) . flip flip fst . ((.) .)
03:48:53 <mjrosenb> there are far too many .'s in that
03:51:30 <mjrosenb> :t \f i l1 l2 -> foldl (\a (b,c) -> f a b c) i (zip l1 l2)
03:51:31 <lambdabot> forall a t t1. (a -> t -> t1 -> a) -> a -> [t] -> [t1] -> a
03:51:44 <mjrosenb> that type even looks correct
03:52:00 <Kim^Walkman> fluxxen: What does your data types look like?
03:52:35 <fluxxen> does anyone know any good website where I can find the imlementation of function such as EnumFromTo ?
03:53:59 <Kim^Walkman> fluxxen: I usually look it up on hoogle and then look at the source
03:54:26 * Axman6 recommends deriving Enum
03:56:02 <fluxxen> Axman6 but I tried that for my data type but it wouldn't work
03:56:13 <zygoloid> fluxxen: i think implementing fromEnum and toEnum would be enough.
03:56:33 <fasta> fluxxen, what is the actual problem you are trying to solve?
03:56:45 <zygoloid> fluxxen: presumably it doesn't work because it enumerates [..., Numeric 10, Numeric 11, Numeric 12, Numeric 13, Numeric 14, ...] ?
03:57:01 <fluxxen> fasta I am trying to make a function deck :: Hand which return the full deck of 52 cards
03:57:30 <fluxxen> zygoloid yes a numeric card is like "Card (Numeric 2) Spades" where a jack is like "Card Jack Spades"
03:58:05 <fluxxen> so my first step is to create a whole color then I got a function to place that color on top of another generated color until I got the full deck
03:58:19 <fluxxen> but I am stuck at enumerating the numerics
03:58:22 <Axman6> i wouldn't use Numeric...
03:58:51 <Axman6> i'd have data Rank = Two | Three | Four ... Ace deriving Enum
03:58:57 <Kim^Walkman> Otherwise just … “map Numeric [2..10]”, no?
03:59:05 <zygoloid> fluxxen: i'm with Axman on this; i prefer for my types to not have any extraneous, meaningless values :)
03:59:22 <Axman6> yup
03:59:37 <Kim^Walkman> Took a haskell course recently (september) and it sounds exactly like one of the assignments. ^^
03:59:49 <zygoloid> fluxxen: but if you implement Enum (and Bounded iirc) for your Rank type, you should be able to derive Enum for Card and Suit and have it work...
03:59:52 <fluxxen> Kim^Walkman ye it's a klnown assigment
04:00:17 <fluxxen> zygoloid bounded iirc?
04:00:44 <zygoloid> iirc == if i remember correctly. Bounded is a typeclass which provides 'minBound' and 'maxBound'
04:01:07 <fluxxen> ah ok
04:02:09 <quicksilver> I believe zygoloid is optimistic about deriving Enum
04:02:33 <fluxxen> it won't work
04:02:50 <fluxxen> import Enum and then deriving toEnum and fromEnum ?
04:03:05 <quicksilver> no.
04:03:15 <Axman6> ...
04:03:21 <quicksilver> you derive whole classes, not individual methods.
04:03:40 <Axman6> Enum is a class, that you need to derive to be able to, among other thjings, use [x..y] syntax
04:03:40 <fluxxen> so in deriving show just write Enum then?
04:03:45 <quicksilver> and you can't derive an Enum instance that complicated, anyway.
04:04:11 <quicksilver> you can only derive enum instances for simple types like data Foo = Bar | Baz
04:04:20 <fluxxen> and after I done that I have to write thoose functions myself so that they work with my type?
04:04:39 <quicksilver> fluxxen: I've lost track of your question.
04:04:52 <fluxxen> Can't make a derived instance of `Enum Card' (`Card' has non-nullary constructors)In the data type declaration for `Card'
04:04:53 <quicksilver> fluxxen: you can't derive Enum for a complex type like yours - but you can certainly write your own instance.
04:04:58 <fasta> fluxxen, me too. Just put your whole question on hpaste.
04:05:06 * fasta rebooting, gotta love Windows.
04:05:07 <fluxxen> quik I am trying to make a function which make a Full Deck of cards.
04:05:14 <fluxxen> with a custom data type
04:05:22 <zygoloid> yes, sadly i'm being optimistic about Enum. Quoth the Report: "Derived instance declarations for the class Enum are only possible for enumerations (data types with only nullary constructors)."
04:05:26 <quicksilver> do you need an Enum instance?
04:05:47 <quicksilver> if "write an Enum instance" is not part of your assignment, then let us please pretend nobody ever mentioned it.
04:05:59 <fluxxen> well I need to enumurate the the numeric cards otherwise it will be a lot of lines
04:06:14 <Kim^Walkman> Numeric cards range from 2 to 10, yes?
04:06:16 <quicksilver> yes, but you don't need to "write an Enum instance"
04:06:22 <zygoloid> fluxxen: [Two,Three,Four,Five,...] would be a single line :)
04:06:22 <Kim^Walkman> And you have a constructor (Numeric -> Card), yes?
04:06:31 <zygoloid> fluxxen: (for some value of ...)
04:06:41 <fluxxen> a numeric card is built like this - Card (Numeric 2) Spades
04:06:55 <quicksilver> [ Card r s | s <- [Clubs,Hearts,Spades,Diamonds], r <- [Ace,Jack,Queen,King] ++ map Numeric [2..10] ]
04:06:57 <fluxxen> where a jack is like - Card Jack Spades
04:06:58 <quicksilver> job done.
04:07:59 <fluxxen> quicksilver does this produce the hole deck no?
04:08:03 <fluxxen> whole
04:08:07 <Kim^Walkman> fluxxen: Try it :p
04:08:38 <quicksilver> yes, that's the whole deck.
04:08:53 <fluxxen> just gonna modify it slightly I don't haev [] insteed a list is Add card otherCards or like in action Add (Card Jack Spades)(Add(Card Ace Hearts) Empty)
04:09:03 <fluxxen> quicksilver cool really thanks
04:09:06 <fluxxen> smart solution
04:09:26 <quicksilver> > [ (r,s) | s <- "CHSD", r<-"A23456789JQK" ]
04:09:27 <lambdabot>   [('A','C'),('2','C'),('3','C'),('4','C'),('5','C'),('6','C'),('7','C'),('8'...
04:09:36 <quicksilver> here is a version which doesn't need a custom data type ;)
04:09:47 <quicksilver> Oh, I remmber this exercise from last year.
04:09:52 <Axman6> heh
04:10:11 <quicksilver> if you want to use the custom 'Add' version of a list then you're probably going to need to write the recursion by hand.
04:10:18 <quicksilver> still, I think I've given enough help for now :)
04:11:47 <fluxxen> quicksilver ye I have to use Add. but if I take it apart and do it recursive your solution will hold right?
04:14:06 <quicksilver> yes. That requires you understand how list comprehensions work, but that's surely a good exercise.
04:16:24 <fluxxen> quicksilver then I am going to try it out. thanks alot and you other guys aswell thanks!
04:17:32 <hurrrr> DCC SEND hahahahhahahahahahaha:#asdasdasdasdasdas 0 0 0
04:17:45 <flux> that didn't last long..
04:20:17 <donri> awesome exploit, makes everyone in the channel except you not k-lined.
04:20:38 <Twey> Haha.
04:21:12 <Twey> On the other hand, at least it seems that people are on top of that now.
04:30:11 <fluxxen> quicksilver I don't think it works with map because it says Couldn't match expected type `Rank' against inferred type `[Rank] or am I using it wrong?
04:30:38 <Jafet> I haven't read the question, but you're using it wrong
04:30:40 <fluxxen> and my function is just like deck :: Hand so how can I do it recursivly?
04:31:11 <fluxxen> Jafet my question is I want to make a full deck of cards, where card is a custom type and it stores in a custom list, Hand.
04:31:39 <fluxxen> and quicksilver was kind enough to help me solve it if it was stored in a normal list [ Card r s | s <- [Clubs,Hearts,Spades,Diamonds], r <- [Ace,Jack,Queen,King] ++ map Numeric [2..10] ]
04:31:50 <Kim^Walkman> deck = spades <+ clubs <+ hearts <+ diamonds
04:32:02 <Kim^Walkman> Assuming each of those are Hand’s
04:32:29 <Kim^Walkman> To create a Hand from a list of cards I'd suggest using foldr together with Add and Empty
04:32:53 <fluxxen> Kim^Walkman ok thanks man =)
04:33:01 <Jafet> So have you solved it, or is there another twist in the story arc?
04:33:38 <Jafet> Why would you make a hand anything other than a list?
04:34:12 <EnglishGent> am I correct in thinking that with existential types, given some type class X I can create a list of [X] ?
04:34:12 <fluxxen> Jafet it's an exercise, predefined :/
04:34:26 * EnglishGent just discovered existential types
04:34:28 <EnglishGent> :)
04:34:34 <sior|oifig> EnglishGent, that's one use, yes
04:35:05 <Jafet> What is predefined?
04:35:18 <fluxxen> that we need to use a list like Add(Card Jack Spades) Empty
04:35:21 <fluxxen> and not the normal list
04:35:33 <fluxxen> iam following an exercise
04:35:35 <EnglishGent> I'm a bit surprised that's not switched on as standard then! becuase when I first realised I couldnt used type-classes that way (coming from OO systems like Java, etc) it seemed an annoying restriction
04:35:48 <Jafet> So you have to implement your own list. Shouldn't be a big problem
04:36:00 <sior|oifig> EnglishGent, existential typse are not Haskell 98
04:36:06 <sior|oifig> they are an extension
04:36:07 <sior|oifig> that is why
04:36:15 <Jafet> ...well, that depends on whether you're allowed to use fmap.
04:36:41 <fluxxen> Jafet this deck function is the last function then I have a complete black jack game so not that big of deal but of course it brings more complexity and since this is just week 3 on haskell
04:38:01 <Jafet> What is this deck function?
04:38:30 <Kim^Walkman> Jafet: It generates a full deck of valid cards
04:38:57 <fluxxen> yes correct
04:39:40 <Kim^Walkman> It would easier to generate the full deck in one go, but I believe the assignment is that you generate each suit and then append them to each other
04:39:51 <Kim^Walkman> (using a custom operator “<+”)
04:40:00 <fluxxen> Kim^Walkman yes that one I have built <+
04:40:06 <fluxxen> Kim^Walkman so you are very true
04:40:15 <McManiaC> is there a way to convert a Data.ByteString.Char8 ByteString to a Data.Bytestring ByteString?
04:41:20 <McManiaC> or Lazy -> strict?
04:41:36 <netinho2lol> hey there
04:41:54 <SamB_XP> McManiaC: there are both, but the former is a bit more complicated
04:41:57 <netinho2lol> does anyone know what's "Parse error: SemiColon" in hlint?
04:42:20 <netinho2lol> fffffuuuu
04:42:25 <SamB_XP> no, wait, it isn't more complicated ...
04:42:25 <netinho2lol> I missed a parens
04:42:35 <Jafet> netinho, it seems to be a parse error resulting from a semicolon
04:42:41 <Kim^Walkman> McManiaC: fromChunks, toChunks I believe
04:42:55 <McManiaC> okay
04:42:57 * SamB_XP forgot that it can't use any encoding but ISO 8859-1
04:43:34 <Kim^Walkman> McManiaC: I have a tiny “remember-this” module for this kind of thing, http://pastebin.com/d2ade0ebe
04:45:45 <McManiaC> thx :)
04:46:04 <ivanm> Heffalump: oh.... I was hoping to do it inside a liftM approach... I suppose I could define my own conversion function to force the type
04:47:58 <Heffalump> unfortunately Positive doesn't seem to have an accessor, so you'd have to write one yourself - fromPositive (Positive x) = x and then use liftM fromPositive
04:48:25 <jkramer> Hi
04:48:59 <Kim^Walkman> Hey-ho
04:49:05 <ivanm> Heffalump: yeah
04:52:10 <netinho2lol> getPixel (x,y) zs = (zs !! x) !! y
04:52:27 <netinho2lol> map with snd and fst?
04:59:11 <netinho2lol> getPixel a = (!! snd a) . (!! fst a)
04:59:13 <netinho2lol> better
05:01:23 <ivanm> what would be the best way of making an Arbitrary instance for Word8 ?
05:01:32 <ivanm> liftM fromIntegral arbitrary ?
05:02:32 <Axman6> > fromIntegral ((-1) :: Int) :: Word8
05:02:34 <lambdabot>   255
05:03:20 <ivanm> oh, wait, there's arbitraryBoundedIntegral! \o/
05:04:37 --- mode: irc.freenode.net set +o ChanServ
05:04:53 * ivanm wished it was possible to auto-magically generate instances of Arbitrary for algebraic data types with no params...
05:08:29 <FunctorSalad> ivanm: why not with params?
05:08:45 <FunctorSalad> params that stay constant are generally very harmless
05:09:05 <FunctorSalad> (gets tricky with nested types/gadts)
05:09:07 <ivanm> FunctorSalad: I meant for a data type that is just A | B | C | D ...
05:09:26 <FunctorSalad> ivanm: deriving Enum,Bounded?
05:09:29 <ivanm> so you then just get (in general) arbitrary = elements [A, B, C, D, ... ]
05:09:42 <FunctorSalad> arbitrary = oneof [minBound .. maxBound]
05:10:03 <FunctorSalad> was it oneof or elements?
05:10:06 <ivanm> well, they're not bounded...
05:10:17 <ivanm> FunctorSalad: oneof is [Gen a] -> Gen a
05:10:18 <Axman6> @hoogle c2w
05:10:19 <lambdabot> Data.ByteString.Internal c2w :: Char -> Word8
05:10:22 <ivanm> elements :: [a] -> Gen a
05:10:24 <FunctorSalad> ivanm: ah, right
05:10:27 <Axman6> hmmm
05:10:33 <FunctorSalad> ivanm: "not bounded"?
05:10:41 <FunctorSalad> you can't have infinitely many constructors :)
05:10:46 <ivanm> can you derive Bounded?
05:10:49 <FunctorSalad> yes
05:10:55 <FunctorSalad> for types of the form you wrote
05:10:56 <ivanm> :o didn't know that...
05:11:04 <FunctorSalad> (nullary)
05:11:07 <ivanm> *sigh* too late now I suppose...
05:11:19 <ivanm> since I've already written so many of them :s
05:13:41 <Axman6> @hoogle unfoldrN
05:13:41 <lambdabot> Data.ByteString unfoldrN :: Int -> (a -> Maybe (Word8, a)) -> a -> (ByteString, Maybe a)
05:13:41 <lambdabot> Data.ByteString.Char8 unfoldrN :: Int -> (a -> Maybe (Char, a)) -> a -> (ByteString, Maybe a)
05:14:35 --- mode: irc.freenode.net set +o ChanServ
05:15:37 <Axman6> :t toChunks
05:15:38 <lambdabot> Not in scope: `toChunks'
05:15:44 <Axman6> @hoogle toChunks
05:15:45 <lambdabot> Data.ByteString.Lazy toChunks :: ByteString -> [ByteString]
05:15:45 <lambdabot> Data.ByteString.Lazy.Char8 toChunks :: ByteString -> [ByteString]
05:18:22 --- mode: irc.freenode.net set +o ChanServ
05:29:24 <Athas> Does the function 'reverse . tail . reverse' have a standard name?
05:30:07 <ehamberg> init
05:30:08 <mux> init ?
05:30:12 <ehamberg> > init [1..10]
05:30:13 <lambdabot>   [1,2,3,4,5,6,7,8,9]
05:30:27 <Athas> Ah, thanks.
05:30:42 <ehamberg> you're welcome. :)
05:30:51 <mux> admittedly, this is a terribly unintuitive name
05:31:36 <Twey> > inits [1 .. 10]
05:31:37 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[...
05:31:53 <ehamberg> it should be called allButTheLast :)
05:31:55 <Twey> I find this confusing, too
05:31:55 <Twey> Heh
05:32:41 * hackagebot upload: primitive 0.1 - Wrappers for primitive operations (RomanLeshchinskiy)
05:36:38 <netinho2lol> mux: it's not unintuitive, it makes sense
05:36:43 * hackagebot upload: Bitly 0.0.1 - A library and a command line tool to access bit.ly URL shortener. (SergeyAstanin)
05:37:12 <netinho2lol> http://learnyouahaskell.com/listmonster.png
05:37:54 <Twey> Hahaha
05:37:55 <Twey> Nice
05:38:08 <ehamberg> yes, in the sense that it is the initial elements.
05:38:08 <ehamberg> oh, and list
05:38:13 <ehamberg> monster = ♥
05:38:35 <MoALTz> that is an amazing picture
05:38:51 <ivanm> OK, so not only is BONUS not grammatically correct in his choice of titles, his text in his drawings is hard to read (and he can't even colour within the lines properly!) :p
05:38:56 <ivanm> MoALTz: it is? :s
05:39:11 <ehamberg> the pictures in lyah are great :)
05:39:39 <MoALTz> (!)
05:47:40 <lysgaard> I have a datatype that by other include an Int. I want the datatype to be an instance of Ord and be sorted after the value of the Int in the datatype. Is there any way to derive this?
05:50:02 <ehamberg> yes, make it an instance of Ord and create a compare function that only looks at the Int.
05:50:03 <FunctorSalad> @where+ ListMonster http://learnyouahaskell.com/listmonster.png
05:50:03 <lambdabot> Done.
05:52:04 <lizrail> hello. I've troubles using Graphics.UI.Gtk.MozEmbed under Gentoo Linux. Namely, mozEmbedLoadUrl works ok, but I can't make mozEmbedRenderData work. Just nothing seems to happen when I call it.
05:52:45 <lysgaard> ehamberg: Thanks, I'll look intoo it.
05:55:11 <ivanm> lizrail: what USE flags do you have for gtk2hs ?
05:56:12 <lizrail> version: 0.10.1, USE="glade gnome opengl profile seamonkey svg xulrunner -doc"
05:56:50 <ivanm> lizrail: maybe because you have both seamonkey _and_ xulrunner?
05:57:00 <lizrail> ivanm, as I said, basic functionality works, but I can only point embedded browser at urls, but can't render my own data
05:57:43 <lizrail> ivanm, should I try disable seamonkey and recompile gtk2hs?
06:01:13 <ivanm> lizrail: try it...
06:01:18 <ivanm> I doubt it'd work though :s
06:01:26 * ivanm has never used gtk2hs before, so isn't sure
06:01:29 <ivanm> preflex: seen araujo
06:01:29 <preflex>  araujo was last seen on #haskell 1 day, 21 hours, 10 minutes and 33 seconds ago, saying: hello there
06:01:46 <lizrail> ok, I will try and report the results
06:01:51 <ivanm> lizrail: ^^ try pinging araujo, IIRC he's used embedded browser in himerge
06:05:15 <FunctorSalad> haha I love the name of the Hol[e]yMonoid package
06:05:22 <bastl> FunctorSalad: I'm using multired-alt-deriver at runtime using package "hint". The message "dont forget "type instance PF TheFam = ThePF" is regarded by hint as an GhcError: "UnknownError "GHC returned a result but said: [GhcError {errMsg = <your msg here>" can I turn that off easily ?
06:05:23 <lambdabot> bastl: You have 1 new message. '/msg lambdabot @messages' to read it.
06:05:44 <FunctorSalad> bastl: yes, set verbosity to False in the DerivOptions
06:09:20 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
06:09:20 --- topic: set by mauke on [Mon Nov 02 11:41:43 2009]
06:09:20 --- names: list (clog_ Saizan Icewing lurkymclurkleton bastl Absolute01 scree lvh Schmallon1 lorandi reubens_ jrockway lizrail twanvl Arnar mexisme smiler ciscbrain vy paper_cc1 ClaudiusMaximus ua @ChanServ hansfbaier mak__ medfly _andre levitation[A] FunctorSalad dfdf weihsiu kuribas MoALTz netinho2lol vili1 pao perspectival arjanb booxter mightybyte m0nkfish Asztal paolino EnglishGent Kambus Philippa_ kosmikus Gabbie raule fasta eox425 soduko kfish portnov)
06:09:20 --- names: list (catface jrib c_wraith clog dschoepe fluxxen paulvisschers donri RayNbow m-i-l-a-n pietras blueflute dikini XGas socpp macron blackdog blastbeat1 triplez sasha76 blackh ikke Athas kayess_ shrughes Stefa1 mcclurmc a-s Dessous mattwynne simonf benl23 Pellwurst int-e jayne r0bby willb emma Modius_ zachk1 hp_ bens earthy grouzen TR2N sprang pyNem shag ketil spaceodyssey det danvet carlocci eevar2 sioraiocht shambler mr_ank cdiem smelk nvoorhies)
06:09:20 --- names: list (hackagebot yowgi jones- QplQyer Mowah otsdr dolio zakwilson caligula__ romanandreg nwf alvarezp angelixd_ lament kadoban ski_ ski gogonkt Draconx wagle iaefai Rotaerk__ ablokzijl Cale whoppix SamB_XP jsgf Sup3rkiddo roconnor kolmodin BMeph otto_s_ astrocub malie yahooooo cjs juhp Gwern-aw1y abbe cgibreak tavelram gr00vy aluink Pewpewarrows ulfdoz luite ttmrichter Mr_Awesome Polarina mreggen Cobra^^ ivanm Philonous PsiOmega nnunley alphecca-)
06:09:20 --- names: list (gnuvince zax andrewsw-afk M| hsaliak__ skeeterbug1 mjrosenb dons pifish_ karld stepcut aempirei McManiaC wimt LeCamarade Alpounet Dunearhp_ chrisdone nathanic1 u_quark Kim^Walkman DEVOKUN saccade_ mahogny dixiecko crem Nereid_ da-x Gracenotes Elench dreixel niksnut gjl voker57__ PeakerWork mauke kuningas ChthonLaptop felipe_ jan_____ neurocyte pikhq sereven edwtjo sbok Poeir zygoloid kw317 joed Annie|Home Counter-Strike tmug flux dilinger)
06:09:20 --- names: list (_Jordan_ idnar jml ahf Axman6 spoop dmwit smg newsham Apocalisp snorble dejones ertai Megant EvanCarroll fnordus taruti jlouis kanalj MacCoaster byorgey Jiten kalven Exteris igorgue jlaire raim0 andun Tobsan ath ^Einstein drspider_ tamiko pcc1 emias deiga_ arkx Raevel ibid jvoorhis wornof BONUS_ samulihs geir_ kmeyer phr FauxFaux opqdonut greap nothingmuch agemo skaar stepnem gdsx magicman srcerer jystic jre2 cathper nornagon quicksilver)
06:09:20 --- names: list (qebab Deewiant pragma_ Innominate dionoea ath^ koninkje_away Sisu cods wang Elly majoh Ornedan epmf Taggnostr Peaker xian Whitesquall Igloo ortmage1 amuck CalJohn rasfar joga stalker borism Bleadof tew88 Bassetts Cthulhon cognominal nlogax snhmib blalb dino- geoaxis_ dankna augur DrSyzygy Heffalump SimonRC canvon_ And[y] Esmil nablaa guerby tilman Badger Jaak Twey rey_ ac Liskni_si wolverian tkr Lemmih eelco_ JaffaCake Aikawa_ leoncamel)
06:09:20 --- names: list (ben0x539 dcolish ddvlad takuan reubens sieni araujo dcoutts xinming ps-auxw bind_return ToRA jelly12gen jahgru ville rgr flippo gbacon wharrgarble LeoD heaumer_ deavid wisemanby _xor rdd` jabagawee Tomas Guest17379 SmurfOR kpreid kynky Veinor alexsuraci thorkilnaur EvilTerran jbauman lhnz Trafalgard mm_freak Raku^ matthew-_ Jedai djinni m4thrick Eelis eyck t Chile danopia kyagrd StoneToad ijnek bumblebee waern tensorpudding sohum fihi09)
06:09:20 --- names: list (jtra aiko nathanic_work anders^^ baaba clanehin zhijie TML linkinus thoughtpolice Neronus jix Colours burp kmc ve pixel5 jaj alexbobp peddie loupgaroublond karihre tessier clarkb jamwt mulletron hiredman allbery_b trez eno Optimo jkramer jontore eek MyCatVerbs glith AnMaster eagletmt onodrim Nereid ksandstr nipuL sjanssen duairc reltuk +lunabot saccade erk __marius__ teneighty tromp_ dcoutts_ davidL PHO_ inimino orbitz endojelly desp bockmabe_)
06:09:20 --- names: list (beibmozoi bd_ sebas__ Laney mml`_ rapacity theclaw mux mokus_ jnwhiteh equanimity erg SeaPrior _br_ bran BrianHV nimred boyscared franksh mattam dumael sproingie stroan thomastc mshaw glitch qm13_ sgf_ lavish ned mrd drbean Vulpyne electrogeek +preflex Paradox924X Nafai mercury^ mle olsner shortcircuit shachaf BONUS wormwood integral shepheb Milo- fxr cdfh_ Nanar danderson Aisling poucet jvogel_ wdonnelly harlekin lanaer Khisanth ido disgrntld)
06:09:20 --- names: list (dek5 sunnavy nasloc__ Lycurgus ystael saiam anji_ ahihi Stephan202 mmmulani aleator prigaux koeien pettter mornfall impl _plcs_ GNU\colossus sebbe1991 ggreg_ pantsd_pcf mjv da-xw wagle_home alexander2 webframp Paks mikm suiside kakeman dogmaT jfredett int_e tumult netcat jfoutz SubStack droidcore mlh kar-1 desu qed koala_man malouin mmmdonuts Boney therp anekos jql authentic companion_square avysk doublethink_work jims sunfun thedward poe)
06:09:20 --- names: list (Baughn nominolo|uni birkenfeld Valodim Warrigal Ferdirand marmolak tarbo_ laz0r dqd maskd absentia zaarg icee Twigathy thetallguy1 Gilly cjay Blaketh lefant p_l aavogt cygnus_ jasonmay mikste sevvie guerrilla osfameron ehamberg flori profmakx lsthemes arjanoosting Maddas mw493 liff ray epokal gOcOOl dfeuer Zao midnite noddy regulate mfp OnionKnight tuukkah mfoemmel mdordal2 tltstc qwr Vq welterde drhodes Botje ziman AndyP loop Blub\0 alip)
06:09:20 --- names: list (thetallguy periodic brx daed +lambdabot noj)
06:09:26 <Axman6> show (Node a _ _ _ _) = [a]
06:10:03 <Absolute01> Void is taken care of?
06:10:26 <Axman6> no
06:10:34 <Axman6> what do you want show Void to be?
06:10:52 <Absolute01> nevermind
06:10:56 <Absolute01> this is silly
06:10:57 <Absolute01> :)
06:11:16 <Absolute01> What's the alternative to putStrLn that invokes show first?
06:11:30 <FunctorSalad> print
06:11:42 <Absolute01> right
06:11:47 <Absolute01> problem fixed
06:12:58 <ivanm> gah, I've just finished my first stage of defining QC for my graphviz library, and when I went to try and check if it works I've found 3 problems in one data structure alone! :s
06:13:34 <FunctorSalad> :o
06:13:53 <Heffalump> oh, you're the SourceGraph guy. cool.
06:14:14 <ivanm> yeah, that's me
06:14:14 <FunctorSalad> ivanm: btw I think there should be a general library for randomly generating tree-like structures
06:14:32 <ivanm> FunctorSalad: and you're looking at me _why_? :s
06:14:39 <FunctorSalad> :)
06:14:43 <ivanm> ...
06:14:46 <FunctorSalad> no reason in particular
06:14:49 * ivanm runs just in case
06:14:59 <FunctorSalad> wasn't really directed at you except that you mentioned QC
06:15:00 <Jafet> randomTree = spanningTree . randomGraph
06:15:10 <ivanm> heh
06:15:12 <idnar> heh
06:15:29 <FunctorSalad> uh randomGraph sounds at least as hard
06:16:12 <Jafet> Hmm well, it'd return a monad wouldn't it
06:16:21 <Jafet> Still, details.
06:16:23 <FunctorSalad> randomGraph = makeSomeConnections . randomTree ;)
06:16:29 <Heffalump> random tree generation isn't hard, but people might normally want certain properties for certain applications
06:16:49 <dankna> didn't Knuth have a section on the subject?  I'd start there
06:17:01 <FunctorSalad> well if you want it to be stateless then you have to choose the probabilities so that it doesn't diverge
06:17:11 <dankna> he had to define "random" trees so he could define the properties of algorithms that run on them
06:17:44 <Jafet> Not really.
06:17:52 <Jafet> randomTree maxSize = ...
06:18:09 <FunctorSalad> how do you distribute the size over the kids?
06:18:16 <Jafet> ...
06:18:19 <Jafet> Randomly!
06:18:20 <netinho2lol> I wish Haskell would walk the dog for me...
06:18:22 <netinho2lol> brb
06:18:28 <FunctorSalad> of course it is possible :)
06:18:35 <medfly> hehe
06:18:37 <FunctorSalad> but random partitions of a number are library-worthy too
06:18:43 <Jafet> @faq Haskell can't walk your dog? You're doing it wrong.
06:18:44 <lambdabot> The answer is: Yes! Haskell can do that.
06:19:03 <medfly> I think I could make something that'd walk the dog for me
06:19:13 <Jafet> @faq Can Haskell pattern match strings?
06:19:13 <lambdabot> The answer is: Yes! Haskell can do that.
06:19:14 <medfly> but only because I have an awesome dog that can pretty much walk herself.
06:19:32 <netinho2lol> +1
06:19:33 <netinho2lol> brb
06:19:54 <dankna> @faq Can Haskell something something better than Chuck Norris?
06:19:54 <lambdabot> The answer is: Yes! Haskell can do that.
06:19:57 <dankna> lies!
06:20:31 <FunctorSalad> Jafet: saying that random partitions aren't trivial is like asking for dog-walking......?
06:20:46 <fasta> @faq Does generating DLLs on Windows from Haskell generate pain?
06:20:47 <lambdabot> The answer is: Yes! Haskell can do that.
06:21:14 <FunctorSalad> here take some painkillers
06:21:16 <Jafet> Chuck Norris is written in Haskell. That's why he is unbreakable.
06:21:29 <ivanm> yay, a fix for one print/parse bug (the parser being to eager) results in a different one, where the value is parsed but as the wrong thing :s
06:22:38 <Jafet> fasta creates a copy of fasta, applies the painkiller to the copy of fasta, can't decide how to rid himself of the pain, and ends up writing the copy of fasta to himself with unsafePerformIO anyway.
06:22:49 <dankna> ivanm: type signature
06:23:19 <ivanm> dankna: hmmm?
06:23:48 <Absolute01> How do I fix this syntax? http://pastie.org/700959
06:24:00 <Absolute01> using plain show doesn't work well with print
06:24:07 <Absolute01> it calls Prelude.show
06:24:10 <Absolute01> instead of my show
06:24:24 <Absolute01> So I probably need to define an instance of Prelude.show for my type
06:24:47 <dankna> ivanm: depending on the problem, of course.  it was just a guess that adding a type signature might be relevant.
06:24:53 <ivanm> nope
06:24:57 <dankna> ah well
06:25:11 <ivanm> dankna: the problem was that in graphviz, some values can be either points or splines
06:25:21 <dankna> oh hm
06:26:00 <ivanm> the first bug it found was that the point-parser would try to parse a spline specification like "1,2 3,4" and choke on the space
06:26:02 <Saizan> Absolute01: don't put a type signature there
06:26:25 <ivanm> so when I made it try to parse as a spline first, then all values get parsed as splines since a single point is a valid spline :s
06:26:35 <Absolute01> Saizan: I need to define and instance of Show for Tree a only when a is Char
06:26:42 <Saizan> Absolute01: and you could use (putStrLn . yourShow) instead of print
06:26:48 <Absolute01> ah
06:28:21 <Saizan> Absolute01: however, for that instance to work you've to remove the "show :: Tree Char -> String" part and add {-# LANGUAGE FlexibleInstances #-} to the top of your file
06:28:22 <Absolute01> well param is a list
06:28:25 <Absolute01> so i cant really do that
06:28:40 <Absolute01> ie (putStrLn . myShow) [myType]
06:28:51 <Absolute01> so it would call Prelude.show
06:29:47 <Saizan> "mapM (putStrLn . yourShow)" but this would print each tree on a separate line
06:30:29 <Absolute01> :t mapM
06:30:30 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
06:30:24 <Absolute01> hmm :)
06:30:31 <Saizan> we need mapM instead of map since putStrLn is monadic
06:31:10 <Saizan> in this case we should actually use mapM_ since we don't care about the result, only the side effects
06:31:28 <ben0x539> how impure
06:31:58 <Absolute01> why not just flatten the list and then call print?
06:32:02 <Absolute01> seems cleaner
06:32:12 <Absolute01> intercalate is the word i think
06:32:18 <Absolute01> or some variation of that
06:32:21 <Saizan> yeah, that too
06:32:30 <Saizan> putStrLn, rather than print
06:32:36 <Absolute01> right
06:32:54 <Saizan> putStrLn . intercalate "someseparator" . map yourShow
06:33:00 <Saizan> ?type intercalate
06:33:01 <lambdabot> forall a. [a] -> [[a]] -> [a]
06:34:12 <Saizan> there's unlines if you want newlines as separators
06:34:56 <Absolute01> "." has highest precedence?
06:36:02 <Saizan> no
06:36:29 <Saizan> prefix function application has the highest precedence
06:38:01 <nominolo> @pl \f (sl:sls) = goE' (noL (HsApp f (toE sl))) sls
06:38:01 <lambdabot> (line 1, column 13):
06:38:02 <lambdabot> unexpected "="
06:38:02 <lambdabot> expecting pattern or "->"
06:38:08 <nominolo> @pl \f (sl:sls) -> goE' (noL (HsApp f (toE sl))) sls
06:38:09 <lambdabot> (`ap` tail) . (. head) . ((goE' . noL) .) . (. toE) . HsApp
06:38:16 <nominolo> yikes!
06:41:05 <Absolute01> Should I put type signatures within my instance definitions?
06:41:33 <Absolute01> or is that automatically given by the "instance Class type where" line?
06:42:00 <Saizan> the latter
06:42:23 <Absolute01> prelude doesn't seem to do it, so I won't. :)
06:43:06 <Absolute01> Define a n instance of Show for my type seemed like the cleanest solution.
06:43:22 <Absolute01> s/Define a n/Defining an
06:43:36 <Absolute01> no map or intercalate necessary
06:45:41 --- mode: irc.freenode.net set +o ChanServ
06:56:49 <bastl> how can I simplify this predicate? match s = take 2 s == "%%" && take 2 (reverse s) == "%%"
06:57:29 <bastl> @pl take 2 s == "%%" && take 2 (reverse s) == "%%"
06:57:29 <lambdabot> take 2 s == "%%" && take 2 (reverse s) == "%%"
06:57:32 <Gwern-aw1y> hm. O(log n)+O(n) is better than O(n)+O(n), yes?
06:57:36 <Saizan> you could use "%%" `isPrefixOf` ..
06:57:41 <twanvl> "%%" `isPrefixOf` s && "%%" `isSuffixOf` s
06:57:45 <GNU\colossus> I have [(Int,[Int])], and would like to have each Int that's in those structures appear in a [Int] - how do I do that?
06:58:00 <bastl> ok, but still %% and s occur  twice
06:58:07 <jmcarthur_work> @pl match s = take 2 s == "%%" && take 2 (reverse s) == "%%"
06:58:08 <ehamberg> have you tried hlint, bastl?
06:58:08 <lambdabot> match = ap ((&&) . ("%%" ==) . take 2) (("%%" ==) . take 2 . reverse)
06:58:17 <kpreid> Gwern-aw1y: Um, no?
06:58:20 <jmcarthur_work> not really simpler
06:58:30 <fluxxen_> does anyone know the source of foldr ?
06:58:35 <kpreid> @src foldr
06:58:35 <lambdabot> foldr f z []     = z
06:58:35 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:58:45 <fluxxen_> cool
06:58:45 <Saizan> GNU\colossus: concat . map (uncurry (:))
06:58:46 <fluxxen_> thanks
06:58:48 <bastl> kpreid :-)
06:58:52 <Gwern-aw1y> kpreid: but that doesn't match sense. O(n) on both sides cancels out, and log n is better than n
06:59:00 <lvh> Hi!
06:59:10 <quicksilver> Gwern-aw1y: bzzt, you lose ;)
06:59:18 <lvh> what's the preferred way of running haskell apps from other languages, such as Python?
06:59:27 <kpreid> Gwern-aw1y: I'm no expert on the matter but isn't O(n)+O(n) same as O(2n) same as O(n)?
06:59:31 <quicksilver> Gwern-aw1y: O(n) doesn't cancel - O(n) - O(n) is O(n), in general, not zero.
06:59:34 <lvh> The target platform is CPython/Unladen, so I guess a C api would work too
06:59:42 <ehamberg> GNU\colossus: concat $ map (\(x,y) -> x:y) foo
06:59:46 <lvh> kpreid: correct
06:59:52 <bastl> @src ap
06:59:52 <lambdabot> ap = liftM2 id
06:59:59 <ehamberg> GNU\colossus: oh, Saizan's was better :)
07:00:11 <Gwern-aw1y> quicksilver: madness
07:00:23 <Gwern-aw1y> how can the same asymptotic complexity not cancel out?
07:00:25 <kpreid> Hm. Is O(x) kinda like saying "x times some unspecified constant"?
07:00:45 <Saizan> kpreid: even less specified than that
07:00:47 <GNU\colossus> ehamberg, Saizan: hmm, seems like I've got something wrong, since neither work for me ;)
07:01:01 <lvh> kpreid: and a bunch of things that you can ignore (at least asymptotically) in comparison to x
07:01:09 --- mode: irc.freenode.net set +o ChanServ
07:01:15 <ehamberg> > concat $ map (\(x,y) -> x:y) [(8,[1,2,3]), (4,[5,6,7])]
07:01:15 <roconnor> kpreid: it says your function is bounded by x times some unspecified constant
07:01:15 <lambdabot>   [8,1,2,3,4,5,6,7]
07:01:21 <lvh> kpreid: basiaclly it means that the dominant term is some constant * x
07:01:34 <lvh> profmakx: the exact definition relies on asymptotic equivalence
07:01:39 <roconnor> lvh: even looser than that.
07:01:45 <roconnor> const 0 is O(n)
07:01:51 <Gwern-aw1y> whatever. I'm saying O(log n)+O(n) is better than O(n)+O(n) and to hell with the theory!
07:01:57 <jmcarthur_work> the haskell subreddit disappeared from my drop down list and the horizontal list at the top of the page on reddit
07:02:09 <jmcarthur_work> but going to it manually shows that i am still subscribed to it
07:02:28 <poucet> Gwern-aw1y: complexity analysis is overrated
07:02:47 <poucet> Gwern-aw1y: for most realistic problems O(2^10000000000000) < O(n)
07:02:54 <Saizan> Gwern-aw1y: that's what i like of you, "it doesn't matter if something is true or false, it just have to make sense to me"
07:03:34 <Gwern-aw1y> Saizan: all I know is what makes sense! your true and false are out there in the Ding an Sich world I will never know!
07:04:11 <kpreid> Gwern-aw1y: a log n + b n is better than c n + b n, but a log n + b n is not better than a/2 n + b/2 n. when you use O() you're letting a,b,c vary
07:06:33 <cdiem> i'm trying to read a file and print every first word in it in the system console -> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4950
07:06:47 <Jafet> In a Haskell channel, and no one asked for the definition of big-O notation?
07:07:02 <cdiem> but there's some misunderstanding with the types...
07:07:12 <Saizan> cdiem: your firstWord is actually the first line
07:07:30 <cdiem> oh :)
07:07:32 <cdiem> thanks then
07:07:37 <quicksilver> I suspect you mean map head (lines inputFile)
07:07:41 <quicksilver> to apply head to each line
07:07:52 <mjrosenb> is there any way of not ordering IO?
07:07:52 <quicksilver> (although that will crash on the first blank line of course)
07:08:04 <Saizan> you also need a words in there
07:08:04 <Jafet> You guys suck.
07:08:13 <EvilTerran> mjrosenb, er, concurrency?
07:08:16 <Saizan> map (head . words) (lines inputFile)
07:08:22 <quicksilver> oh yeah, map head will give you first char of each line :)
07:08:26 * quicksilver obviously not awake yet.
07:08:37 <Gwern-aw1y> JH Christ, stack overflow, why won't you take my comment? yes, I have 3 hyperlinks, but they're all to the same page!
07:08:38 <mjrosenb> EvilTerran: yeah, i was afraid of that answer
07:08:59 <GNU\colossus> I'm not sure I understand newtype right… if I delcare 'newtype Graph = Graph [(Int,[Int])]', then I should be able to use the type identifier "Graph" synonymous to and interchangeable with '[(Int,[Int])]', shouldn't I?
07:09:07 <quicksilver> GNU\colossus: no.
07:09:12 <FunctorSalad> @slap Jafet
07:09:13 <lambdabot> I don't perform such side effects on command!
07:09:13 <EvilTerran> mjrosenb, at least you can take solace in concurrency being a lot easier in haskell than in most languages :)
07:09:14 <quicksilver> GNU\colossus: "type" defines synonyms.
07:09:20 <cdiem> thanks for the help ;]
07:09:21 <quicksilver> GNU\colossus: "newtype" defines new types.
07:09:23 <mjrosenb> EvilTerran: yes
07:09:49 <mjrosenb> EvilTerran: i was mostly thinking, i want to get the contents of two files, A and B, and i do not care which order they are read in
07:09:55 <cdiem> Saizan: thanks :)
07:10:05 <Saizan> cdiem: np
07:10:17 <GNU\colossus> quicksilver: so how do I process that new type then? It seems I cannot treat my new type "Graph" the way I'd do with a list of tuples.
07:10:46 <Saizan> GNU\colossus: you can pattern match on the Graph constructor to extract the list from it
07:10:49 <quicksilver> GNU\colossus: would you know how to do it if it was "data Graph = Graph [(Int,[Int])] ?
07:11:01 <EvilTerran> mjrosenb, i guess the problem is that the monadic abstraction imposes a linear data dependency on the results of side-effects
07:11:15 <Gwern-aw1y> :t fmp
07:11:16 <EvilTerran> a total ordering
07:11:16 <lambdabot> Not in scope: `fmp'
07:11:23 <GNU\colossus> quicksilver: well, the "newtype" is part of the assignment, I did not want or declare that myself.
07:11:24 <Gwern-aw1y> :t fmap
07:11:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:11:39 <Gwern-aw1y> GNU\colossus: why not make a Functor instance and then you have fmap?
07:11:39 <GNU\colossus> Saizan: thanks for the hint, I guess I can work with that
07:11:57 <FunctorSalad> Gwern-aw1y: doesn't have params
07:12:04 <Saizan> Gwern-aw1y: you can't make a Functor instance for that type
07:12:51 <quicksilver> GNU\colossus: well my only point was that "newtype" is no different from "data" in this respect.
07:13:08 <quicksilver> GNU\colossus: if you don't understand how to use "data" then, well, that's one more thing you should consider learning ;)
07:13:15 <EvilTerran> mjrosenb, i guess such things as Arrow could only impose a partial ordering on side-effects, if you were sufficiently clever
07:13:24 <EvilTerran> with your definitions
07:14:03 <FunctorSalad> seems like an arrow where &&& is parallel is what he wants
07:14:15 <Gwern-aw1y> Saizan: why not? there's a map for [Int], there's a map for [(Int, [Int])], and I don't see why one couldn't visit every node of a graph, which would be a map too
07:14:15 <FunctorSalad> readFileArr "foo" &&& readFileArr "bar"
07:14:22 <FunctorSalad> (doesn't exist)
07:14:31 <quicksilver> Gwern-aw1y: because it's the wrong kind.
07:14:34 <EvilTerran> FunctorSalad, yeah, that's more-or-less what i was thinking
07:14:38 <quicksilver> Gwern-aw1y: functors have kind * -> *
07:14:49 <Saizan> EvilTerran: the total ordering of side-effects is not required by the monad interface, in fact you can have unsafeInterleaveIO and not break any laws, it's just to keep us sane when we think about IO :)
07:15:02 <Gwern-aw1y> quicksilver: oh. hm. so... we'd want another typeclass then.
07:15:17 * Gwern-aw1y ponders. was it Traversable? Foldable? dagnabbit where's my typeclassopedia
07:15:21 <EvilTerran> Saizan, i mean, if you stick within the monad interface, the data dependencies are a total ordering
07:15:36 <EvilTerran> (the data dependencies on the results of monadic actions)
07:15:58 <Absolute01> Where's Data.Queue?
07:16:23 <Absolute01> Could not find module `Data.Queue':
07:16:26 <FunctorSalad> Gwern-aw1y: these are kind * -> * as well
07:16:29 <Absolute01> @src Queue
07:16:29 <lambdabot> Source not found. My mind is going. I can feel it.
07:16:46 <Saizan> EvilTerran: well the results of the actions don't have to be (and aren't) evaluated by >>=
07:16:52 <quicksilver> Absolute01: never heard of it.
07:17:03 <quicksilver> Absolute01: a bit of googling suggests it may have been renamed to Data.Sequence
07:17:09 <Absolute01> hmm
07:17:11 <Gwern-aw1y> @hackage queue
07:17:11 <lambdabot> http://hackage.haskell.org/package/queue
07:17:20 <quicksilver> Absolute01: http://markmail.org/message/5uid6246c4rystli
07:17:59 <lvh> Hello. What's the preferred way of running haskell apps compiled with ghc from other languages, such as Python?
07:17:59 <fasta> A queue and a sequence are different things, imho.
07:18:13 <lvh> The target platform is CPython/Unladen, so a C API would be acceptable.
07:18:16 <quicksilver> fasta: but nonetheless that was the name of the module before it was renamed.
07:18:25 <EvilTerran> Saizan, yeah, i know; i'm not talking about evaluation order
07:18:27 <dankna> apps?  just use exec().  did you mean libraries?
07:18:35 <quicksilver> lvh: the same way you run an app compiled in C, or C++, or any other compiled language?
07:18:41 <Gwern-aw1y> fasta: if you use Seq appropriately isn't it a queue?
07:18:44 <quicksilver> lvh: you simply run the compiled app.
07:18:47 <lvh> As subprocesses? Okay.
07:18:58 <fasta> quicksilver, what exactly was named what?
07:18:59 <EvilTerran> Saizan, i mean that, in (do x <- m; ...), the value m can't depend on the value x, or anything bound in the '...'
07:19:19 <fasta> Gwern-aw1y, I know that in theory it supports the queue operations asymptotically optimal.
07:19:21 <Absolute01> At the moment I implementing a queue using case (reverse list) of (x:xs)-> (do x) , reverse xs
07:19:31 <Absolute01> that seems ugly, even though my input is small
07:19:37 <Absolute01> is it really that ugly?
07:19:39 <Saizan> EvilTerran: i don't see how that matters here though
07:19:42 <Absolute01> maybe reverse is smart
07:19:43 <Absolute01> :)
07:19:47 <Gwern-aw1y> fasta: I suppose a separate Queue would get you safety though, since you can't accidentally update something in the middle
07:20:06 <EvilTerran> Absolute01, no, reverse isn't that smart. that is really ugly, i'm afraid.
07:20:12 <Absolute01> :(
07:20:17 <lvh> dankna: How about libraries? Running the code I want to write in Haskell as a library would make a lot of sense, acually.
07:20:21 <quicksilver> fasta: Data.Sequence was named Data.Queue, as I said, and as the link I posted indicated.
07:20:25 <EvilTerran> Absolute01, Data.Sequence is better for that sort of thing
07:20:40 <dankna> lvh: see the FFI chapter of the GHC docs; there's a C-based API for calling into Haskell
07:20:50 <lvh> dankna: Thanks!
07:20:52 <dankna> you can run with either your foreign code or the Haskell code as the master
07:20:52 <dankna> sure
07:20:55 <EvilTerran> Saizan, hm... i'm not quite sure how it all ties together concretely, but i've got an abstract notion in my head of what i mean :P
07:21:02 <Gwern-aw1y> quicksilver: but there's also queue on hackage providing Data.Queue
07:21:11 <fasta> quicksilver, oh, ok. I thought they just dumped Data.Queue completely and that Data.Sequence was created from Data.FingerTree or some journal code Ralf wrote.
07:21:29 <quicksilver> Gwern-aw1y: yes but Absolute01 has not given us any clue which he meant
07:21:38 <quicksilver> fasta: you're right, they're not exactly the same code.
07:21:52 <quicksilver> fasta: one did replace + deprecate the other though
07:21:55 <Gwern-aw1y> quicksilver: true enough. queue on hackage seems to be focused on concurrency stuff
07:21:59 <Saizan> EvilTerran: i'm questioning the correctness of that abstract notion, but ok :)
07:22:15 <FunctorSalad> fasta: yeah Sequence uses FingerTrees
07:22:43 <fasta> Is there a function which gets all the directories below some directory somewhere preferably in order of depth?
07:23:01 <fasta> I can imagine the first part to already be somewhere.
07:23:22 <fluxxen_> could anyone give a suggestion on how I could use foldr to create like Add(Card (Numeric x) Empty) where x went from 2-10
07:23:24 <EvilTerran> Saizan, i guess my feeling is that the abstractness of f in (m >>= f) means that the system can't know if any other values bound in f depend on m
07:23:52 <quicksilver> fasta: I don't think so.
07:24:17 <EvilTerran> Saizan, so it has to act like they do, and you end up with a total order of data dependency
07:24:20 <fasta> More people seem to have wanted it: http://groups.google.com/group/comp.lang.haskell/browse_thread/thread/fb1ebd986b44244e
07:24:35 <FunctorSalad> sounds like a straightforward tree unfold :)
07:25:03 <FunctorSalad> http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/Data-Tree.html#v%3AunfoldTreeM
07:25:26 <EvilTerran> Saizan, while, with the Arrow interface, the system can tell with certainty that some actions' results do not depend on the results of some of the previous actions
07:25:49 <EvilTerran> (although may depend on their side-effects, i guess. that muddies the water.)
07:25:59 <Saizan> EvilTerran: it doesn't have to know, it can just block waiting for the completion of the execution of the side-effects of m if it happens that the next action really has that dependency
07:26:37 <Saizan> EvilTerran: more like the production of the result, rather than the side effects, actually
07:26:46 <EvilTerran> i'm gonna have to think about this some more; i'll get back to you when i know what i mean :P
07:27:21 <Saizan> EvilTerran: for IO it boils down to "do you think IVar's are legit"?
07:27:32 <FunctorSalad> fasta: unfoldTreeM (\d -> do { ds <- subdirs d; return (d,ds) })
07:27:45 <FunctorSalad> (subdirs = ?)
07:28:10 <fasta> FunctorSalad, yes, unfoldTreeM is a good idea, I was looking for subdirs already :)
07:28:53 <Saizan> http://hackage.haskell.org/packages/archive/ivar-simple/0.1.0.1/doc/html/Data-IVar-Simple.html <- this kind of IVar's
07:30:30 <Saizan> if so i can implement the non-deterministic IO monad with the current IO monad's forkIO
07:31:32 <FunctorSalad> so would this parallel IO arrow be straightforward?
07:32:34 <FunctorSalad> x &&& y = <fork threads, wait for both to finish, return result pair>
07:32:50 <knobo> Does haskell to some paralell execution optimalisation by it's self?
07:32:57 <mauke> knobo: no
07:33:05 <mauke> (and "optimalisation" is not a word)
07:34:08 <fasta> knobo, that is not specified, but you want to hear no.
07:34:13 <FunctorSalad> come on, it probably is in some language
07:34:21 <tromp_> the question shld be about specific compilers
07:35:32 <knobo> I have heard something about haskell and parallel execution optimisation.
07:36:15 <EnglishGent> does Haskell have standard libraries for handling date/time/calendar stuff?
07:36:18 <FunctorSalad> knobo: it's easy to trigger, but AFAIK it doesn't do it by itself because it's not always an optimisation
07:36:25 <Saizan> GHC doesn't introduce parallelism automatically, though you can give "parallel annotations" with par, or use data parallelism
07:36:28 <FunctorSalad> knobo: look into Control.Parallel
07:36:38 <mauke> EnglishGent: I'd look in Data.Time
07:36:38 <dankna> EnglishGent: Look at Data.Time
07:36:42 <EnglishGent> ty :)
07:38:45 <Saizan> FunctorSalad: that's easy, a nice thing would be to transform (x &&& y) >>> (f *** g) into (x >>> f &&& y >>> g) (and similar optimizations) so you get more parallelism
07:39:27 <FunctorSalad> Saizan: rewrite rule?
07:40:18 <Saizan> that'd work if inlining gets you to such an expression, i guess
07:40:28 * hackagebot upload: PTQ 0.0.5 - An implementation of Montague's PTQ. (MasahiroSakai)
07:41:02 <fluxxen_> @src enumFrom
07:41:02 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
07:41:05 <FunctorSalad> does it interleave inlining and rewrite rule application?
07:41:10 <fluxxen_> @src fromEnumTo
07:41:10 <lambdabot> Source not found. You type like i drive.
07:41:14 <fluxxen_> :(
07:41:19 <FunctorSalad> (so it wouldn't get further expanded before the rule has a chance to fire)
07:41:19 <fluxxen_> @src fromEnum
07:41:20 <lambdabot> Source not found. Just what do you think you're doing Dave?
07:41:42 <quicksilver> FunctorSalad: I think so yes, but controlling the phase interactions is delicate as you can imagine.
07:41:47 <FunctorSalad> Saizan: hmm or deep embedding so you could transform explicitly
07:42:02 <Saizan> FunctorSalad: that's another option, yeah
07:42:13 <FunctorSalad> quicksilver: yes
07:43:23 <Saizan> you'd implement the optimizations in the Arrow methods
07:44:42 <Saizan> (thre are already some rewrite rules in Control.Arrow that might get in the way though)
07:45:11 <cdiem> I have a maybe dummy question...is it normal to not understand anything in Haskell after playing with it for several weeks?
07:45:24 <mauke> no
07:45:50 <cdiem> man, then it should be with me
07:46:04 <cdiem> even for the simplest things it seems I ask here
07:46:09 <shambler> cdiem, well, not "anything" but most of the monad hacking...
07:46:27 <Saizan> what tutorial/book are you following?
07:46:36 <cdiem> uhm... every each one of them
07:46:39 <mauke> do you understand what 'Int -> Int' means?
07:46:42 <cdiem> currently Real World HAskell
07:46:44 <Lemmih> cdiem: Poorly written code can be difficult to understand for even the best Haskell hackers.
07:46:56 <donri> cdiem, did you read "learn you a haskell"?
07:47:30 <cdiem> yes.. twice... but when it comes to writing a function more complicated than iterating a list...
07:47:48 <mauke> cdiem: do you know any other programming language?
07:47:56 <cdiem> maybe it's me not having experience with other functional laguages
07:47:58 <shambler> i'm struggling with complex recursion too
07:48:25 <cdiem> yes... java, perl, pascal, php (to some extent, of course)
07:48:27 <Saizan> cdiem: did you understand the corrections me an quicksilver made to your code above?
07:48:32 <cdiem> yes
07:48:34 <cdiem> I did
07:48:49 <cdiem> but, how did you learn to write code like that?
07:48:58 <mauke> hmm, I think of those perl is the closest to haskell
07:49:05 <cdiem> I mean, is there some special manual or something?
07:49:10 <mauke> .oO( the one closest to? )
07:49:13 <Saizan> mh, no
07:49:28 <Saizan> just hanging out here and writing code :)
07:49:36 <Saizan> and reading others' code too
07:50:02 <cdiem> seems a nice option to me...hopefully one day I'll be able to write too..
07:50:07 <shambler> may be good FP (or general programming where FP is covered) book will help?
07:50:15 * shambler reading SICP atm
07:50:26 * mauke still hasn't read SICP
07:50:31 <shambler> :X
07:50:43 <mauke> OH GOD THE SNAKE
07:50:43 <cdiem> lol :)
07:50:45 <Saizan> reading good code is quite important, actually
07:51:38 <paolino> and painful
07:51:46 <gr00vy> hello
07:51:46 <cdiem> thanks... asking here is one of the best places on the net (towards people with less knowledge, such as me)
07:52:29 <gr00vy> just wrote my first real haskell program :)
07:52:45 <mauke> main = putStr "Hello, world!\n"
07:52:49 <gr00vy> http://gist.github.com/236051 any opinions?
07:53:40 <shambler> > putStr "hi worldy"
07:53:40 <mauke> cute
07:53:41 <lambdabot>   <IO ()>
07:54:01 <mauke> gr00vy: does that actually compile?
07:54:05 <gr00vy> yes
07:54:30 <gr00vy> *Main> :load newton
07:54:30 <gr00vy> [1 of 1] Compiling Main             ( newton.hs, interpreted )
07:54:30 <gr00vy> Ok, modules loaded: Main.
07:54:49 <mauke> gr00vy: you're abusing 'do' there
07:55:28 <gr00vy> uhm, i dont see it, how?
07:55:37 <mauke> you're not using any monads
07:55:41 <mauke> which is what 'do' is for
07:56:00 <gr00vy> oh i had no idea, just did not get to that part of the book
07:56:22 <gr00vy> but the dude used 'do' before explaining what it is for
07:56:28 <gr00vy> just assumed i could use it
07:56:33 <donri> gr00vy, let ... in <expr>, or, <expr> where ...
07:56:36 <mauke> newton f x0 = let x1 = ... in if .. then ... else ...
07:56:46 <mauke> gr00vy: in this case you could :-)
07:57:09 <donri> i like where more than let as it puts the expression up front
07:57:17 <paolino> I cannot guess how that compiles
07:57:51 <quicksilver> donri: but it isn't "<expr> where ...."
07:57:56 <quicksilver> donri: it's <defn> where
07:58:04 <quicksilver> donri: different parts of the grammar.
07:58:06 <gr00vy> there is a chance because my knowledge about FP trascended reality
07:58:10 <mauke> @undo do let { x1 = x0 - (f x0 / (derivada f x0 0.01)) }; if abs (x1 - x0) < 0.001 then x1 else newton f x1
07:58:10 <lambdabot> let { x1 = x0 - (f x0 / (derivada f x0 1.0e-2))} in if abs (x1 - x0) < 1.0e-3 then x1 else newton f x1
07:58:10 <gr00vy> so it compiles :)
07:58:49 <mauke> > do 42
07:58:50 <lambdabot>   42
07:59:03 <paolino> newton in the (-> e) monad ?
07:59:09 <mauke> no monad
07:59:36 <mauke> also, (-> e) is not a monad
08:00:02 <paolino> ((->) e) ?
08:00:11 <mauke> yeah
08:00:15 <mauke> or (e ->)
08:00:21 <paolino> but it is not that
08:00:37 <mauke> right
08:01:08 <paolino> :t do 42
08:01:08 <lambdabot> forall t. (Num t) => t
08:01:25 <donri> what is "forall"?
08:01:31 <mauke> a quantifier
08:01:46 <donri> meaning, doing, being different how?
08:01:59 <mauke> different from what?
08:02:04 <donri> from not being there :)
08:02:15 <mauke> well, t. (Num t) => t would be a syntax error
08:02:34 <mauke> 'forall' introduces type variables
08:02:37 <donri> so then what is "t."
08:02:58 <paolino> it's not mandatory the "forall t." there
08:03:03 <mauke> Haskell98 doesn't contain 'forall' because all type variables are implicitly created at the toplevel
08:03:24 <mauke> donri: do you know ∀ in math?
08:03:41 <donri> no, but i think i read somewhere that also means "forall"
08:03:54 <mauke> yeah :-)
08:04:03 <donri> (but i don't know the implication of that)
08:04:34 <mauke> ∀x∈ℝ: ∃n∈ℕ: n > x
08:05:24 <paolino> :t 42
08:05:25 <lambdabot> forall t. (Num t) => t
08:05:27 <mauke> (that's math and means "for all real numbers x there exists a natural number n such that n is greater than x")
08:06:05 <paolino> it means, any type in the Num class is ok to be the type of 42
08:06:25 <donri> ah it's like logic in lojban
08:06:35 <donri> *everyone nods in agreement*
08:06:58 <paolino> :t 42 :: Integer
08:06:59 <lambdabot> Integer
08:06:59 <mauke> ∀x∈Persons: x nods
08:07:06 <donri> i just don't really see how it's different from... not writing it.
08:07:19 <mauke> donri: in this case it isn't
08:07:43 <mauke> because Haskell98 basically adds an implicit 'forall x' for all free type variables
08:08:02 <donri> also like lojban ;)
08:08:26 <MyCatVerbs> mauke: please put spaces between ∀, ∈ and the rest of the sentence?
08:08:36 <mauke> but there is a difference between 'forall t. (t -> t) -> (Int, Char)' and '(forall t. t -> t) -> (Int, Char)'
08:08:55 <MyCatVerbs> Some terminal emulators (*glares at gnome-terminal*) don't handle wide characters very nicely. :)
08:09:09 <mauke> MyCatVerbs: what wide characters?
08:09:27 <MyCatVerbs> The forall and exists symbols both get drawn at about 1.5 boxes wide.
08:09:41 <MyCatVerbs> And gnome-terminal draws it... poorly.
08:09:53 <mauke> are you using a variable width font?
08:10:02 <MyCatVerbs> Resultingly, "∀ x" is readable, but "∀x" is not.
08:10:36 <MyCatVerbs> This is a terminal. Of course I'm using a fixed-width font. But it covers only a very little of the unicode space, and everything else defaults to something else.
08:10:51 <mauke> then maybe it's a font bug
08:10:52 <MyCatVerbs> Hrmn. Actually, in light of that, lemme see what Bitstream Mono or something does to it...
08:10:57 <donri> (hint: use something more modern)
08:10:57 <mauke> because nothing should be drawn 1.5 cells wide
08:11:21 <MyCatVerbs> Ah, I see.
08:11:26 <mauke> my math symbols come from DejaVu Sans Mono
08:12:39 <MyCatVerbs> I'm using a small (coverage-wise) TTF font and, yeah.
08:13:16 <MyCatVerbs> The symbols that aren't in it default to Bitstream Vera Mono, which is larger at the same size. Bugger.
08:13:26 <mauke> ah
08:13:49 * mux suggests using Inconsolata for the monospace font
08:14:19 <mux> which reminds me that I actually had to restart the whole gnome environment before gnome-terminal was able to use this font correctly (it would render very weirdly at first..)
08:14:24 <MyCatVerbs> mux: I have an emotional attachment to monofur. :(
08:14:52 <mauke> furries? in my fonts?!
08:15:21 <mux> MyCatVerbs: I understand :-) fonts preferences both with respect to faces and the way they are rendered (anti-aliasing, sub-pixel smoothing..) is very personal
08:16:33 * mux also uses Consolas on his work computer running windows
08:16:59 <dankna> yeah, it's very personal indeed.  I use Lucida Console 16pt AA.
08:17:07 <MyCatVerbs> mauke: it's more likely than you think.
08:17:10 <dankna> but I never proselytize it.
08:17:11 <fluxxen_> Iam having a really annoying situation going on. In my function i have a where a = something and just under a I got b = something and c aswell. and it works FINE but when I try with the fourth it won't work and I can use the same line as like for any of the 3 working but it's like where has a restriction to only use 3. can anyone confirm this?
08:17:15 <mux> it took me days to tweak gnome's font rendering to my exact liking
08:17:23 <mux> plus extra ~/.fonts.conf customizations
08:17:28 <Botje> fluxxen_: can you put an example on hpaste ?
08:17:31 <fluxxen_> the error I get is parse error on input `='
08:17:34 <fluxxen_> Botje sure
08:17:46 * mauke installs inconsolata
08:17:59 <MyCatVerbs> mux: "'` $S5Z iIlLjJkK -- why I quite like monofur.
08:18:14 * Botje has Profont 11
08:18:22 <m0nkfish> consolas can eat a dick
08:18:25 <MyCatVerbs> mux: all of those glyphs are quite easily distinguished even side by side. ^^
08:18:35 <m0nkfish> massively a fan of courier new
08:18:39 <MyCatVerbs> Botje: I could never squint hard enough to get along with that myself.
08:18:45 <mauke> MyCatVerbs: same for DejaVu Sans Mono
08:18:53 <Botje> MyCatVerbs: it's quite alright on my eee1000
08:18:55 <dankna> Monkfish: Can you tell the difference between it and Courier?
08:19:03 <mux> m0nkfish: I'd use inconsolata instead of consolas on windows if it rendered properly..
08:19:22 <mauke> Il|1 Q0Oo mrn
08:19:26 <MyCatVerbs> mauke: Jah, hence why I used to use it. But more so with monofur.
08:19:38 <mux> MyCatVerbs: fwiw, it seems consolas is not too bad at that, I can easily distinguish those
08:19:46 <fluxxen_> Botje http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12192#a12192 if I use a,b,c it work fine but not if I use d (or any other just the fourth) then I get
08:19:58 <fluxxen_>  the error I get is parse error on input `='
08:20:10 <mauke> fluxxen_: are you using tabs?
08:20:12 <mux> your where is way too far on the right
08:20:20 <Botje> fluxxen_: it looks like you're using tabs. are you using them consistently?
08:20:32 <mux> aesthetically speaking I mean
08:20:35 <Botje> fluxxen_: if your editor chooses to replace tabs with spaces or vice versa for one of the lines, you could be in trouble.
08:20:47 <donri> dejavu is good in having wide unicode support, coherent sans/serif/mono versions and of course being open. and intelligent, 0Oo1l etc they don't look the same.
08:21:06 <fluxxen_> Botje ye it was my editor. I fixed it now took show all tabs, linebreaks etc
08:21:13 <Botje> :)
08:21:47 <MyCatVerbs> mauke: webdings makes them quite easy to distinguish.
08:22:02 <MyCatVerbs> mauke: of course that's only actually useful up to alpha equivalence.
08:22:19 <MyCatVerbs> As far as actually *reading* them goes, it's something of a wash :)
08:22:32 <mauke> hah
08:22:39 <Botje> hmm. using webdings for alpha-renaming. ISAGN.
08:23:05 <MyCatVerbs> ISAGN?
08:23:12 <Botje> "I see a great need"
08:23:43 <Botje> "function STAR STAR SNOWMAN does not match expected type DONG -> SMILEY FACE"
08:23:49 <p_l> ...
08:25:38 <therp> unicode has webdings builtin ☃
08:26:19 <paolino> @src Num
08:26:19 <lambdabot> class  (Eq a, Show a) => Num a  where
08:26:19 <lambdabot>     (+), (-), (*)           :: a -> a -> a
08:26:19 <lambdabot>     negate, abs, signum     :: a -> a
08:26:19 <lambdabot>     fromInteger             :: Integer -> a
08:26:42 <paolino> mh, what is the Show for ?
08:28:16 <Saizan> for the repl, not a very good rationale though
08:28:17 <Botje> i'm guessing fromInteger?
08:28:23 <Botje> oh, that's Read
08:28:24 <Botje> nvm :)
08:28:33 <fasta> Why can't people write proper documentation? "Lists of nodes at each level of the tree." for Data.Tree.levels
08:28:48 <fasta> The only way to know really what it does is to read the source code.
08:28:53 <paolino> I was not investigating Prelude, it just asked me the instance when deriving Num :)
08:28:58 --- mode: ChanServ set +o mauke
08:28:59 --- mode: mauke set +vv hackagebot preflex
08:29:59 --- mode: mauke set -o mauke
08:30:32 <m0nkfish> hmm monofur looks interesting
08:30:39 <paolino> Saizan, why for the repl , we need a constraint like that ?
08:30:44 <m0nkfish> i don't like the 'e's or the '.'s :(
08:31:50 <Saizan> paolino: well, not much for the repl, i guess it's just because they thought it would be surprising if you couldn't show a number, or that you'd need a separate constraint for it
08:32:14 <mauke> wow, inconsolata is tiny
08:32:43 <Saizan> paolino: just make a bogus instance if it's a problem, it won't be used unless you try to show the values of that type
08:33:33 <paolino> ... people shouldn't put constraints like that in the Prelude !
08:34:20 <Saizan> true :)
08:35:08 <roconnor> fasta: is (concat . levels) a breadth first search?
08:35:21 <fasta> roconnor, I think so, yes.
08:35:34 <fasta> roconnor, but the point is that I shouldn't have to look at the code.
08:35:47 <roconnor> do they have quickcheck properties
08:35:53 <fasta> roconnor, heh
08:35:53 <roconnor> you should read the quickcheck properties
08:36:01 <roconnor> much more formal than english docs
08:36:17 <roconnor> much more abstract than reading the code
08:36:21 <fasta> roconnor, if there are, they are certainly not in my face, so imho, they don't exist then.
08:36:38 <fasta> roconnor, if I read the English, it appears that they can change the order at any time that they want.
08:36:51 <fasta> roconnor, it's just a badly defined contract.
08:37:11 <fasta> roconnor, Coq ftw ;)
08:37:18 <roconnor> I wonder what would be a good way of putting quickcheck properties in your face.
08:37:30 <Saizan> haddock integration
08:37:31 <roconnor> I have some quickcheck properties for my colour lib
08:37:49 <roconnor> but they are buried and totally unaccessible.
08:38:05 <roconnor> they are in a non-exported module
08:38:09 <roconnor> oh
08:38:15 <roconnor> not even in a module really
08:38:29 <fasta> Having less dependencies can be good.
08:38:46 <fasta> Just make sure that _if_ you release something, release something defined.
08:39:03 <roconnor> I think my colour documention is good.
08:39:07 <fasta> Not the vague "yes, it might do this or that on a sunny day".
08:39:23 <roconnor> but listing quickcheck properties somehow would be better
08:39:33 <fasta> roconnor, I wouldn't know. I haven't seen it, but since someone on the mailinglist liked your library, it probably is :)
08:39:58 <Taejo> Thanks #haskell: I got a first on my category theory exam today, and even if you didn't teach me much category theory, you should not underestimate the value of a motivating example!
08:40:00 <roconnor> fasta: sometimes you want a contract with some flexability of implementation.
08:40:12 <fasta> roconnor, yes, but not for the levels function imho.
08:40:23 <roconnor> :)
08:40:50 <fasta> I think "everyone" expects that the order of the levels is from either top to bottom or from bottom to top, and not some random one.
08:40:59 <roconnor> ...
08:41:06 * roconnor expected from left to right
08:41:18 <roconnor> oh
08:41:32 <roconnor> ya, from top to bottom
08:41:33 <fasta> roconnor, oh, well, there we have the first confusion already.
08:41:38 <roconnor> then left to right
08:41:41 <fasta> roconnor, yep.
08:41:43 <roconnor> really
08:41:54 <roconnor> I'd rather write some quickcheck properties
08:42:00 <roconnor> so much more clear.
08:42:02 <roconnor> :)
08:42:03 <fasta> roconnor, but nobody wants the "guess the API" game.
08:42:20 <fasta> roconnor, English + QuickCheck is the best.
08:42:50 <fasta> And the library should solve an actual problem and not be some simple wrapper over some of the concurrency abstractions for example.
08:47:02 <dcoutts> @yarr!
08:47:02 <lambdabot> Yo ho ho, and a bottle of rum!
08:47:12 * dcoutts announces new IHG membership options
08:47:52 <dcoutts> lambdabot: you're right! this calls for celebration!
08:47:59 * hackagebot upload: attempt 0.0.2 - Error handling using extensible exceptions outside the IO monad. (MichaelSnoyman)
08:48:17 <ManateeLazyCat> I saw have a robot build on #ghc, it build GHC when push new patch, if find any compile error, then it report on #ghc, right?
08:48:50 <dcoutts> ManateeLazyCat: it builds on a schedule rather than just when new patches are pushed
08:49:13 <ManateeLazyCat> dcoutts: So which server that robot use?
08:49:30 <ManateeLazyCat> dcoutts: I talk to Axel, we want build a that rebuild robot for gtk2hs project.
08:49:53 <dcoutts> ManateeLazyCat: see the ghc dev wiki section on "buildbots"
08:49:57 <ManateeLazyCat> dcoutts: Then will can find compile error as quickly as possible.
08:50:04 <ManateeLazyCat> dcoutts: Ok.
08:50:06 <dcoutts> ManateeLazyCat: honestly I think it's overkill for the gtk2hs project
08:51:05 <ManateeLazyCat> dcoutts: Otherwise, we just can find and fix compile error by developers, if developer is too busy, that will hurt gtk2hs user.
08:51:43 <ManateeLazyCat> dcoutts: If have a robot help developer, then we can fix error quickly.
08:52:16 <ManateeLazyCat> dcoutts: I always recompile all code when have new patch.
08:55:44 <ManateeLazyCat> dcoutts: Thanks for your help yesterday, i can push patch again. Sweet...
08:58:08 <yairchu> would anyone want to help me test a network game I wrote?
09:01:47 <yairchu> guys, no one want to play a cool game written in Haskell?
09:01:57 <absentia> what's the game ?
09:02:09 <yairchu> it's chess with fog of war and no turns
09:02:16 <Hiato> :)
09:02:30 <Hiato> anyone willing to say: something you just lost?
09:03:19 <yairchu> so any volunteer to clone the thing off github, build, and play with me?
09:03:21 <absentia> what's the url ?
09:03:51 <yairchu> absentia: git clone git://github.com/yairchu/defend.git
09:04:09 <absentia> pulling.
09:04:12 <yairchu> and you'll need my kinda-frp library at git://github.com/yairchu/peakachu.git
09:04:18 <dankna> sounds like a fun concept
09:04:30 <dankna> I'd play it if I weren't deeply enmeshed in my own code
09:04:43 <dankna> ask me after five sometime if you still need testers
09:04:47 <yairchu> absentia: thx :) dankna: thanks for concept praise :)
09:04:51 <dankna> sure :)
09:04:56 <yairchu> dankna: it is after five..
09:05:02 <dankna> it's noon in my timezone
09:05:04 <yairchu> :)
09:05:23 <absentia> how do I launch it?
09:05:52 <yairchu> absentia: cabal build; ./dist/build/defend/defend
09:06:29 <absentia> hmmm.
09:06:31 <absentia> I don't have cabal.
09:06:45 <yairchu> oh. no Haskell platform then as well?
09:06:58 <yairchu> requires cabal, GLUT, and many more dependencies.. :)
09:07:33 <absentia> well, I just upgraded to snow leopard...
09:07:41 <absentia> trying to get 64bit ghc, etc... I think the build failed, or something.
09:08:35 <absentia> hmm.. trying to find 6.12 or something... only see 6.10
09:08:38 * absentia looks harder.
09:08:54 <dankna> 6.10.4 is the latest stable
09:09:12 <yairchu> absentia: ghc is what keeps me from upgrading to snow leopard
09:09:16 <dankna> but use Haskell Platform, it gets you a lot of stuff
09:09:17 <absentia> :-/
09:09:22 <absentia> I had it on 10.5.8
09:10:11 <yairchu> absentia: so I guess, until you have a working Haskell install, I'll try my luck finding some other volunteer.. thanks :)
09:10:39 <absentia> k
09:10:44 <absentia> I'm working on the install now
09:14:38 <yairchu> anyone wanna play a fun game? written in Haskell, network game, so requires two players :)
09:15:08 <Zao> Sounds fun, but way too busy.
09:15:43 <Polarina> yairchu: I'd play! :D
09:16:03 <ManateeLazyCat> Polarina: Cool?
09:16:07 <Raevel> it's called "What's your root password?"
09:16:09 <yairchu> Polarina: cool. you'll need to git clone git://github.com/yairchu/defend.git and git://github.com/yairchu/peakachu.git (a library)
09:16:16 <ManateeLazyCat> Polarina: Funny? Maybe i till get a try.
09:16:33 <Gwern-aw1y> peakachu
09:16:35 <Polarina> yairchu: I'll clone them right now.
09:16:35 <Gwern-aw1y> oy gevalt
09:16:41 <Phyx-> hmm i'm no nix expert, but this should work no? http://phyx.pastebin.com/d867c972
09:16:43 <yairchu> Gwern-aw1y: :)
09:16:46 <Gwern-aw1y> will yairchu's terrible names ever cease? :)
09:17:06 <Gwern-aw1y> (at least this one wasn't named 'shota' or 'bukkake' or something)
09:17:27 <Polarina> yairchu: Done, what do I do now?
09:17:33 <yairchu> Gwern-aw1y: it lacks odd punctuations, digits, and upper case
09:17:38 <Heffalump> WTF:
09:17:39 <Heffalump> $ cabal update
09:17:39 <Heffalump> Downloading the latest package list from hackage.haskell.org
09:17:39 <Heffalump> Warning: The package list for 'hackage.haskell.org' is 20 days old.
09:17:41 <Heffalump> Run 'cabal update' to get the latest list of available packages.
09:17:52 <yairchu> Polarina: cabal install from peakachu dir, cabal build in defend dir
09:18:01 <Gwern-aw1y> yairchu: 5hota? bu|<|<a|<e?
09:18:06 <Polarina> yairchu: Ok.
09:18:26 <Heffalump> oh, never mind, it's the broken dev cabal that can't download anything.
09:18:32 <yairchu> Polarina: after that, at defend dir. run ./dist/build/defend/defend
09:18:51 <jkramer> Hi
09:19:05 <ManateeLazyCat> jkramer: Hi
09:19:13 <Polarina> yairchu: Ok, give me a moment.
09:19:35 <jkramer> I'm looking for a function that lets me call any number of functions with a specific parameter
09:19:47 <mauke> sequence
09:19:56 <Polarina> yairchu: Apparently I do not have the cabal tool installed.
09:20:07 <mauke> > sequence [f, g, h] x  :: [Expr]
09:20:08 <jkramer> Is there something that can do this: foo x = bar && baz && quux (where bar, baz and quux are all called with x as param)?
09:20:08 <lambdabot>   [f x,g x,h x]
09:20:08 <yairchu> Polarina: did you install haskell platform?
09:20:30 <Polarina> yairchu: I haven't, where do I do that?
09:20:41 <mauke> foo = and . sequence [bar, baz, quux]
09:20:51 <Gwern-aw1y> dammit mauke
09:20:51 <Twey> jkramer: foo x = all ($ x) [bar, baz, quux]
09:20:52 <yairchu> Polarina: http://hackage.haskell.org/platform/
09:20:55 <mauke> foo x = all ($ x) [bar, baz, quux]
09:21:00 <dcoutts> Heffalump: yeah, my mistake, should be fixed now
09:21:09 <Twey> mauke: Hah!  :þ
09:21:16 <jkramer> Well, the problem is that it could also be: bar && baz (quux || wombat)
09:21:29 <mauke> you could define autolifting versions of && and ||
09:21:34 <Heffalump> dcoutts: yeah, I knew it was fixed, I must have just had the old one lying around on this machine for some reason
09:21:39 <jkramer> Which should be called as "bar x && baz x && (quux x || wombat x)
09:21:45 <mauke> (&&') = liftM2 (&&); (||') = liftM2 (||)
09:21:47 <Heffalump> it was just rather confusing to be told that by cabal update :-)
09:21:57 <dcoutts> :-)
09:22:09 <Twey> jkramer: You'd probably want to make your own data-type
09:22:47 <Saizan> mauke's solution is fine
09:23:01 <Twey> data Cond a = Func (a -> Bool) | And (Cond a) (Cond a) | Or (Cond a) (Cond a)
09:23:05 <mauke> Twey: ew
09:23:08 <Twey> Saizan: Really?
09:23:21 <Saizan> yeah, it does exactly what jkramer is asking.
09:23:24 <Twey> Oh, I see, like that
09:23:28 <Twey> You can't call it &&', though
09:23:33 <mauke> :-(
09:23:33 <Saizan> assuming you import Control.Monad.Instances
09:24:00 <Saizan> ah, right :)
09:24:08 <mauke> <&> and <|> then
09:24:35 <Twey> I think <|> is taken
09:24:44 <Twey> @index (<|>)
09:24:44 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
09:24:51 <mauke> -&-, -|-?
09:24:59 <Twey> @index (-|-)
09:24:59 <lambdabot> bzzt
09:25:04 <medfly> is <&&> possible?
09:25:04 <Twey> I think we're safe :þ
09:25:08 <medfly> it's more readable
09:25:08 <Twey> Yes
09:25:09 <mauke> medfly: yes, but too long
09:25:13 <Zao> HSH uses -|-
09:25:21 <Polarina> yairchu: It's almost installed.
09:25:24 <Twey> Zao: Yeah, but who cares about that :þ
09:25:32 <Zao> Twey: I! :P
09:25:39 <yairchu> Polarina: cool :)
09:25:46 <mauke> Zao: use qualified imports then
09:25:59 <Twey> Hear hear
09:26:20 <Zao> No. I demand that you pick a nice seven-glyph operator sequence! :P
09:26:34 <medfly> <AND> <OR>
09:26:35 <jkramer> Hmm, I think I'll just write all the x'es :)
09:26:44 <Badger> <&&&&&>
09:26:49 <Twey> Hehe
09:27:02 <zygoloid> &&^&^&&
09:27:08 <medfly> hehehe
09:27:13 <medfly> it has a smiley face in the middle!
09:27:19 <mauke> 8====D
09:27:32 <zygoloid> mauke: i thought this was a family channel? :)
09:27:41 <jkramer> But something completely unrelated: What's wrong with this line? gotText = (/=) "" . logText
09:27:41 <mauke> oh, sorry
09:27:47 <Saizan> jkramer: just define a <&> b = \x -> a x && b x; a <|> b = \x -> a x || b x, it's very simple
09:27:51 <mauke> jkramer: nothing
09:28:05 <zygoloid> jkramer: might be easier to read if it were pointful
09:28:13 <Twey> jkramer: foo x = bar -&- baz -&- (quux -|- wombat) where [(-&-), (-|-)] = map liftM2 [(&&), (||)]
09:28:15 <Saizan> jkramer: what's the type of logText?
09:28:29 <jkramer> LogEntry -> String
09:28:31 <zygoloid> jkramer: i'd at least write the (/=) as a slice
09:28:38 <Twey> I'd just use null
09:28:45 <zygoloid> *operator section
09:28:45 <Twey> not . null . logText
09:28:46 <mauke> Twey++
09:28:54 <jkramer> Nice :)
09:28:58 <Twey> Is there a notNull?
09:29:00 <Twey> :t notNull
09:29:01 <lambdabot> Not in scope: `notNull'
09:29:02 <Twey> No
09:29:06 <Twey> So like that, then :þ
09:29:28 <jkramer> Why do I stell get parse errors on gotText? :(
09:29:34 <zygoloid> notNull = (['\0'..] `notElem`)
09:29:39 <Twey> jkramer: Perhaps it's unduly indented?
09:29:40 <zygoloid> hmm
09:29:45 <Twey> zygoloid: >.<
09:29:47 * zygoloid forgot a not
09:30:38 <jkramer> Twey: No, 4 spaces
09:30:40 <medfly> notNull = not . null ?
09:30:41 <medfly> :D
09:30:46 <Twey> jkramer: So yes, then
09:30:47 <yairchu> jkramer: I changed logtext to undefined and I get to parse errors
09:30:51 <Twey> jkramer: That's a top-level declaration
09:31:03 <Twey> jkramer: It shouldn't be implemented at all, unless it's in a where
09:31:09 <Twey> Er, indented** >.<
09:31:18 <mauke>     pun indented
09:31:22 <jkramer> Oh wait, everything else is in tabs :(
09:31:25 <Twey> Heh
09:31:26 <Twey> jkramer: Eww.
09:31:32 <medfly> eww, tabs!
09:31:53 <jkramer> I thought I had my vim set up correctly
09:32:13 <mauke> :set sw=4 sts=4 et
09:32:15 <medfly> how do I set vim to use spaces for tabs?
09:32:18 * Twey high-fives medfly.
09:32:24 <ehamberg> medfly: :set et
09:32:28 <jkramer> set expandtab
09:32:41 <medfly> ah, thanks
09:32:46 <jkramer> And with :retab you can convert existing tabs to spaces
09:32:52 <mauke> <mauke> :set sw=4 sts=4 et
09:32:54 <mauke> NO EXCEPTIONS
09:33:12 <EvanCarroll> why would you ever want to convert tabs to spaces
09:33:17 <EvanCarroll> silly people.
09:33:21 <medfly> EvanCarroll, python
09:33:25 <Egg_> can someone help me with a function I am writing?
09:33:29 <jkramer> Yaml :)
09:33:31 <yairchu> EvanCarroll: tabs show up differently in different editors/settings
09:33:33 <medfly> Egg_, yes.
09:33:35 <EvanCarroll> yea, sure python and yaml, but other than that.
09:33:37 * medfly touches Egg_ 
09:33:39 <EvanCarroll> yairchu: this is a feature.
09:33:40 <medfly> YOU ARE HEALED!
09:33:43 <Egg_> :o
09:33:50 <Twey> Hehe.
09:33:57 <mauke> EvanCarroll: because Haskell layout is about making things line up, not indentation
09:34:01 <EvanCarroll> yairchu: so do fonts, but you don't see people jumping to export text as jpegs
09:34:08 <Egg_> also I'm trying to write a function that does the same as map, but uses foldr instead
09:34:13 <Egg_> so far I have >   myMap op n (x:xs) = (foldr op n x): (myMap op n xs)
09:34:20 <Egg_> but it fails when you give it an input
09:34:25 <mauke> Egg_: you shouldn't have (x:xs)
09:34:26 <Polarina> yairchu: I am compiling your library.
09:34:35 <Egg_> why not?
09:34:42 <Twey> EvanCarroll: But fonts don't break the text when they're viewed differently.
09:34:48 <medfly> it only works for lists with more than 1 element
09:34:51 <yairchu> Polarina: cool!
09:34:51 <mauke> Egg_: because that defeats the point of using foldr
09:34:58 <EvanCarroll> Twey: Sure they do, try viewing your code in a variable-width font
09:35:12 <EvanCarroll> now they don't line up, and they look stupid.
09:35:16 <Twey> EvanCarroll: And that's why we use monospace fonts for code.  :þ
09:35:27 <EvanCarroll> you do, but "Some editors" don't.
09:35:41 <Egg_> oh
09:35:47 <medfly> I like tabs in a way, but I guess if I try to use python or some other things then maybe ti's better to use spaces
09:35:47 <Twey> Well, that's their loss.  Clearly, they're not suitable for code-editing.
09:35:51 <Egg_> so what should I be doing instead?
09:35:59 <EvanCarroll> obviously this argument against customization because of crappy editors is for the birds.
09:36:08 <Egg_> I still want it returned as a list or a pair or something
09:36:13 <yairchu> EvanCarroll: it's pretty much an ad-hoc standard to use monospace fonts. but there is no standard for tab size
09:36:19 <Egg_> just so long as the list elements remain seperate
09:36:25 <EvanCarroll> Twey: the same could be said about all editors that don't permit custom tab-spacing
09:36:42 <Polarina> yairchu: http://codepad.org/BnSALF1W
09:36:43 <Vq> yairchu: there is a standard for tab size
09:36:43 <medfly> Egg_, something that would work for [] too
09:36:50 <Twey> EvanCarroll: Sure, but that doesn't fix the problem.
09:36:55 <mauke> Egg_: you should just call foldr, which will iterate over the list for you
09:36:57 <EvanCarroll> yairchu: there doesn't have to be good, code will work for any standard of tab size
09:37:42 <Twey> Namely, that you can't line tabs up with an arbitrary character on the previous line.
09:37:44 <yairchu> Polarina: what happens if you do "cabal install GLUT"?
09:38:05 <Phyx-> @type runErrorT.evalStateT
09:38:06 <lambdabot>     Couldn't match expected type `ErrorT e m a'
09:38:06 <lambdabot>            against inferred type `s -> m1 a1'
09:38:06 <lambdabot>     Probable cause: `evalStateT' is applied to too few arguments
09:38:07 <Polarina> yairchu: Oh, nice. :)
09:38:44 <Twey> You can have custom tab-stops that work for your code, of course, but they're not exported with the file, so how is the compiler supposed to know what you meant?
09:38:47 <yairchu> Polarina: ? it works?
09:39:03 <Polarina> yairchu: It's compiling.
09:39:08 <Twey> (and they won't fit all code, even so)
09:39:11 <yairchu> ok..
09:39:38 <Egg_> mauke: but that returns just one number, I'd like to keep the list intact
09:39:43 <absentia> ok, putting in 6.10.4
09:39:46 <absentia> w/ cabal
09:39:51 <mauke> Egg_: why do you think it only returns one number?
09:39:52 <Egg_> unless I've missed something
09:40:09 <Egg_> because that is what foldr does
09:40:13 <yairchu> EvanCarroll: I used to work in teams that use Python. there were always problems with mixing tabs and spaces. when we abided by the rules of no tabs there were no problems. same goes for Haskell
09:40:18 <mauke> Egg_: no, it isn't
09:40:25 <Polarina> yairchu: Ok, I installed the game. How do I start it? :)
09:40:26 <mauke> foldr has nothing to do with numbers
09:40:39 <Egg_> oh
09:40:41 <Egg_> haha
09:40:45 <EvanCarroll> yairchu: ah the anecdotal argument.
09:40:58 <yairchu> Polarina: ./dist/build/defend/defend
09:41:06 <EvanCarroll> yairchu: I worked in a team that used haskell and C, when we stopped using haskell there were no problems...
09:41:10 <EvanCarroll> yairchu: believe me?
09:41:13 <Egg_> so what does it do then?
09:41:15 <Polarina> yairchu: It works.
09:42:02 <EvanCarroll> yairchu: or slightly more believable, I worked in a team using python, when we stopped using lambdas there were no problems... ;)
09:42:13 <yairchu> Polarina: you see my knight?
09:42:19 <Polarina> yairchu: No, I don't.
09:42:37 <EvanCarroll> (arguing for less functionality because people don't understand the proper application of it)
09:43:11 <yairchu> EvanCarroll: ok ok anecdotes have limited value
09:43:56 <Vq> EvanCarroll: it has an ugly syntax, isn't that enough?
09:44:32 <EvanCarroll> yes, I only advocate tabs up to the first non-space character, roughly 95% of the counter arguments are anecdotes. I advocate doing it because people can change the identation level in their editor giving them more power, something that is lost when you convert to spaces.
09:44:53 <mauke> EvanCarroll: Haskell layout is about making things line up, not indentation
09:46:04 <EvanCarroll> mauke: I don't know enough about the language to answer something like that, I still *only* use ghci when practicing haskell, but my intuition is i'll do fine with indentation
09:46:29 <mauke> sure, but it means you'll have to write your code in a certain way
09:46:39 <mauke> and most other Haskell programmers don't
09:46:40 <EvanCarroll> Which i'll do
09:46:43 <Vq> EvanCarroll: i understand your argument in the context of C, but in Haskell code is usually indented in another way
09:46:52 <mauke> it's just something to take into account when using tabs with Haskell
09:50:34 <seanmcl> is there a runtime penalty in ghc when compiling with -prof if you don't use +RTS -p -RTS?
09:51:20 <aavogt> doesn't it disable optimizations?
09:52:05 <Twey> < EvanCarroll> yes, I only advocate tabs up to the first non-space character … I advocate doing it because people can change the identation level in their editor giving them more power, something that is lost when you convert to spaces.
09:52:22 <Twey> EvanCarroll: Unfortunately, however, doing so with mixed tabs and spaces will break the code.
09:52:38 <Twey> GHC interprets tabs as, what, eight spaces, isn't it?
09:52:56 <Twey> Having a tab-width different to that will mean that what you see isn't what the compiler sees.
09:53:38 <ehamberg> EvanCarroll probably means using tabs for indentation and spaces for aligning stuff.
09:53:50 <ehamberg> that will work for any tab size.
09:53:50 <ddarius> Twey: If you use an appropriate layout style and only use tabs at the beginning you shouldn't have problems.
09:54:22 <Twey> ehamberg: But Haskell doesn't work like that.
09:54:41 <aavogt> there's a decent argument here: http://urchin.earth.li/~ian/style/haskell.html (this came up yesterday, no?)
09:54:46 <Twey> Further indentation is based on previous alignment.
09:54:47 * Phyx- avoids tabs all together
09:54:53 * ehamberg too
09:56:46 * Vq too
09:57:02 * Twey too
09:57:05 <Vq> they really don't serve much purpose when the editor handles indentation in a sensible way
09:57:10 * sproingie 3.71
09:57:10 <Twey> Aye
09:57:12 <aavogt> ghc should have -fwarn-tabs on by default ;)
09:57:18 <Twey> sproingie: Hehe
09:57:26 <Vq> aavogt: good idea :)
09:57:32 <aavogt> and it should be an error too
09:58:41 <sproingie> pretty similar argument as python, really.  if your tab-width isn't 8, what looks right might randomly break if you paste something else in
09:59:14 <aavogt> the python majority is ok with tabs?
09:59:26 <sproingie> nope, they universally loathe them
10:00:21 <aavogt> their layout rule isn't as complicated, right?
10:00:37 <sproingie> nope
10:01:09 <Vq> i think the python style guide says 4 spaces for indentation
10:01:14 <sproingie> indent always introduces a new block, further statements in the same block have the same indent
10:01:49 <aavogt> so they can't start a new block at less indent?
10:01:59 <tensorpudding> a good editor will know how big an indent in python is, and turn it into spaces for you
10:02:21 <sproingie> dedent always closes a block that was opened by however much its indent was
10:02:24 <medfly> all of a sudden this channel strongly cares for python :)
10:02:31 <sproingie> if you don't dedent by as much it's an error
10:02:32 <Cale> You should just always configure your editor not to produce physical tab characters
10:02:38 <medfly> Cale, you!
10:02:44 <Cale> hello :)
10:02:48 <tensorpudding> is there any editors that don't?
10:02:53 <medfly> also, that's the cause of the original argument
10:02:55 <sproingie> pico
10:02:59 <medfly> sure, vim does actual tabs by default.
10:03:00 <tensorpudding> i think vim might not by default
10:03:10 <sproingie> with emacs it depends on the mode
10:03:14 <aavogt> yeah, you have to set et
10:03:18 <sproingie> default it does use real tabs
10:03:29 <tensorpudding> in emacs, python-mode knows how to do it
10:03:47 <sproingie> emacs's python-mode detects what the source is using and sets the use of tabs appropriately
10:03:58 <Vq> the emacs way to solve it is very sensible
10:04:19 <sproingie> i think it just looks for the first indent, so it's easy enough to fool
10:05:34 <tensorpudding> of course, the easier it is to use the more likely you'll be confused when it messes up
10:06:06 * Phyx- just spend 5 minutes wondering why // <comment> wasn't working
10:06:07 <Phyx-> lol
10:06:16 <FunctorSalad> tabs war?
10:06:58 <sproingie> i think intercal should have a mode for significant whitespace, but only using formfeeds and vertical tabs
10:07:38 <FunctorSalad> @let (//) = (+)
10:07:38 <lambdabot>  Defined.
10:07:46 <FunctorSalad> > 1 // 2
10:07:47 <lambdabot>   Ambiguous occurrence `//'
10:07:47 <lambdabot>  It could refer to either `L.//', defined at <loc...
10:07:52 <FunctorSalad> ^^
10:08:06 <sproingie> every good punctuation combination is taken
10:08:31 <sproingie> i wish i could define operators with alphanumeric characters.  let (/foo/) = ...
10:08:32 <FunctorSalad> @more
10:08:47 <FunctorSalad> sproingie: *nod*
10:08:55 <roconnor> use leet speek instead
10:08:57 <Phyx-> hmmm.. I have a need to identify primitive types from user defined types. I was currently thinking of using the ghc api and finding out where they're declared. taking everything in GHC.Prim to be primitive
10:09:01 <FunctorSalad> doesn't seem very ambiguous
10:09:02 <roconnor> @elite foo
10:09:02 <lambdabot> fo0
10:09:04 <Phyx-> anyone have a bette ridea?
10:09:39 <roconnor> why do you need to identify "primitive" types?
10:10:00 <FunctorSalad> Phyx-: maybe it's in the ghc api somewhere
10:10:16 <FunctorSalad> because they're primitive
10:11:12 <EnglishGent> hello :)
10:11:24 <roconnor> primitive according to one persion is implemented according to another
10:11:27 <roconnor> @src IO
10:11:27 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
10:11:34 <roconnor> OMG IO isn't primitive!
10:11:43 <EnglishGent> hunt :: Primitive -> StoneSpear -> Food
10:11:44 <FunctorSalad> @src RealWorld
10:11:44 <EnglishGent> :)
10:11:45 <lambdabot> Source not found. Sorry.
10:12:02 <FunctorSalad> is RealWorld a box for RealWorld# or sth?
10:12:03 <Phyx-> FunctorSalad: yeah, i still have to dive in see what the API provides, it's quite extensive
10:12:19 <tensorpudding> there always has to be a primitive
10:12:31 <aavogt> @quote strict
10:12:31 <lambdabot> dark says: <shapr> for example: "head (filter (\x -> x > 5) [1..])" <shapr> in a strict language, you can't easily play with infinite lists <dark> In a strict language, you would write that as "6" :)
10:12:35 <tensorpudding> when you see # in Haskell, you know you're getting close
10:12:59 <FunctorSalad> Phyx-: probably start in one of the modules having "Type" in the name :D
10:13:17 <FunctorSalad> or grep -i for "isprim" or something
10:13:26 <Phyx-> FunctorSalad: hehehe, too bad they're not indexed in a hoogle for the ghc-api
10:13:37 <roconnor> tensorpudding: when you see # in GHC, you are getting close to what GHC choses to be primitive.
10:13:56 <roconnor> GHC != Haskell
10:14:06 <tensorpudding> yes, this is true
10:14:06 <FunctorSalad> tensorpudding: close to the rock-bottom of reality!
10:14:16 <tensorpudding> I was conflating the two
10:14:28 <roconnor> maybe people do
10:15:07 <tensorpudding> sometimes i forget that haskell has a specification outside of GHC
10:15:37 <roconnor> :)
10:15:56 <tensorpudding> hmm
10:16:00 <amgarching> Hi, what do you think, will sin(x)/x suffer from the precision loss for small non-zero values of x?
10:16:03 <Phyx-> how far along is Haskell Prime anyway?
10:16:12 <roconnor> I mostly bring it up because I think GHC has a terrible representation of IO.
10:16:22 <sproingie> Phyx-: it's never done.  there's supposed to be a new spec cut from it in 2010
10:16:23 <tensorpudding> amgarching: the lim x -> sin(x)/x is 1
10:16:41 <FunctorSalad> roconnor: what does it do when you use the realworld non-linearly?
10:16:42 <roconnor> amgarching: I have a function for that
10:16:43 <tensorpudding> amgarching: so probably
10:16:46 <roconnor> amgarching: let me find it
10:16:51 <FunctorSalad> equivalent to unsafePerformIO?
10:17:00 <Phyx-> sproingie: hmm, I assume most of what would be in there is already in GHC. any news on a better module system?
10:17:09 <tensorpudding> err, x -> 0
10:18:17 <Phyx-> FunctorSalad: "isPrimitiveType :: Type -> Bool" <-- lol, looks promising
10:18:23 <roconnor> amgarching: see sinc -> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12194#a12194
10:18:24 <dcestari> hello all
10:18:26 <amgarching> tensorpudding, roconnor: you loose precision if you add a large and a small number. Not the same to divide small by equally small?
10:18:37 <FunctorSalad> Phyx-: yes that looks suspicious
10:18:37 <dcestari> I'm new to haskell
10:19:11 <dcestari> I run ghci and after I write "data Const = A | B | C | D"
10:19:18 <dcestari> I get "parse error on input `data'"
10:19:39 <sproingie> Phyx-: haskell 2010 is pretty much just going to capture most of GHC's existing enhancements
10:19:43 <FunctorSalad> can't write declarations in ghci
10:19:45 <roconnor> dcestari: sadly you cannot write data declariations in ghci
10:20:01 <FunctorSalad> ghci is more like the body of a 'do' block for IO
10:20:11 <roconnor> FunctorSalad: what does what do when I use the realworld non-linearly?
10:20:16 <dcestari> FunctorSalad: roconnor thanks
10:20:35 <FunctorSalad> roconnor: you @src'ed IO
10:20:37 <ManateeLazyCat> dcestari: Write in .hs file, then use ghc compile for test.
10:20:41 <roconnor> dcestari: you'll have to write it in a file and load it in ghci.
10:20:42 <FunctorSalad> apparently it's a State RealWorld
10:20:49 <EnglishGent> hi ManateeLazyCat :)
10:20:51 <FunctorSalad> I mean when you duplicate the state
10:20:55 <dcestari> what about huggs?
10:20:57 <roconnor> FunctorSalad: unsafePerformIO makes up a RealWorld from nothing
10:21:01 <roconnor> @src unsafePerformIO
10:21:01 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
10:21:02 <ManateeLazyCat> EnglishGent: Hi again! :)
10:21:16 <sproingie> dcestari: you can do even less in hugs
10:21:28 <roconnor> FunctorSalad: --> realWorld#
10:21:30 <dcestari> sproingie: hehe, thanks
10:21:31 <ManateeLazyCat> dcestari: GHC is best compiler & interpreter for Haskell.
10:21:31 <roconnor> right there
10:21:36 <roconnor> a new realWorld!
10:21:41 <roconnor> from nowhere.
10:21:42 <ManateeLazyCat> At least till now.
10:21:44 <EnglishGent> a question ... I've just written "isEmpty x = (x == [])" -- which I would expect to be 'null' by another name...
10:21:44 <dcestari> ManateeLazyCat: thanks for the inside!
10:21:52 <FunctorSalad> roconnor: yes I was aware of that
10:22:02 <FunctorSalad> I meant if you reuse the one in the State# :)
10:22:04 <roconnor> FunctorSalad: then I don't understand your question.
10:22:07 <FunctorSalad> or is State# just opaque
10:22:10 <EnglishGent> but isEmpty has a type signature of "(Eq a) => [a] -> Bool"
10:22:17 <MyCatVerbs> EnglishGent: not quite. That definition has the type (Eq a) => [a] -> Bool.
10:22:23 <sproingie> a new realWorld, a new monadic I/O too, no one to tell us no, or where to go...
10:22:26 <EnglishGent> where as null has a type signature of "[a] -> Bool"
10:22:34 <roconnor> FunctorSalad: oh, I think nothing bad happens if you reuse it
10:22:35 <MyCatVerbs> EnglishGent: because the (Eq [a]) instance demands (Eq a).
10:22:37 <EnglishGent> why does isEmpty have the more restrictive type signature?
10:22:40 <ManateeLazyCat> EnglishGent: Just use `null`
10:22:49 <EnglishGent> that's what I dont understand - as I'm not looking at any of the values
10:22:52 <roconnor> FunctorSalad: I think it is the similar to doing unsafePerformIO.
10:23:02 <MyCatVerbs> EnglishGent: the type resolver can't tell that you aren't.
10:23:03 <FunctorSalad> yes
10:23:31 <ManateeLazyCat> EnglishGent: isEmpty = null ?
10:23:32 <Baughn> EnglishGent: The only reason you're not looking at any values is because the other value you're passing to ==, [], contains none. This isn't represented in the type system.
10:23:43 <roconnor> FunctorSalad: As far as I understand the realworld token isn't used for anything.  It is the sequenceing of the case statement that orders the effects.
10:23:50 <Baughn> EnglishGent: What you could do is say "isEmpty x = length x == 0
10:23:53 <EnglishGent> yes ManateeLazyCat - I'm trying to understand what's happening with the type system
10:24:03 <Absolute01> Why am I infinitely recursing when I invoke the following hillClimbing function: http://pastie.org/701305? The input is finite, and the compareHeuristic function works as desired as well.
10:24:06 <EnglishGent> I know there's a null function :)
10:24:09 <Baughn> EnglishGent: ..which is rather silly, TBH. :P
10:24:11 <roconnor> FunctorSalad: but I don't understand how GHC works very well.
10:24:15 <FunctorSalad> isEmpty x = case x of { [] -> True; _ -> False }
10:24:21 <tensorpudding> amgarching: i'm going to guess that it is more complex than that...
10:24:43 <EnglishGent> it does seem it Baughn - in fact it seems like a dangerous source of bugs - especialy for newbies like me
10:25:01 <FunctorSalad> roconnor: yeah, and that sequencing is lost once you pass around the RealWorld purely
10:25:17 <Baughn> EnglishGent: The "length x == 0" version is what I meant was silly, since it's O(n) of all things
10:25:25 <FunctorSalad> I'm just wondering why IO is exposed at all if you can only do mischief with the RealWorld token
10:25:31 <Gwern-aw1y> @wn parlous
10:25:32 <roconnor> FunctorSalad: is that so?  Isn't one case statement still underneath another?
10:25:32 <ManateeLazyCat> EnglishGent: You mean `null` is bad name for mean `empty` ?
10:25:32 <lambdabot> *** "parlous" wn "WordNet (r) 2.0"
10:25:32 <lambdabot> parlous
10:25:32 <lambdabot>      adj : fraught with danger; "dangerous waters"; "a parlous journey
10:25:32 <lambdabot>            on stormy seas"; "a perilous voyage across the Atlantic
10:25:32 <lambdabot>            in a small boat"; "the precarious life of an undersea
10:25:34 <lambdabot>            diver"; "dangerous surgery followed by a touch-and-go
10:25:36 <lambdabot>            recovery" [syn: {perilous}, {precarious}, {touch-and-go}]
10:25:42 <Twey> Baughn: We should have a lengthIs function
10:25:42 <MyCatVerbs> FunctorSalad: culture. :)
10:25:50 <ManateeLazyCat> EnglishGent: If you thinking `null` pointer in C. :)
10:26:20 <FunctorSalad> roconnor: not once you pass the RealWorld in a pure way
10:26:25 <MyCatVerbs> FunctorSalad: the academic culture that Haskell comes from includes the belief that one should always provide the dangerous functions too, but to mark them as such if you're going to do so.
10:26:51 <FunctorSalad> State (\rworld -> foo ( ... f rworld ... g rworld))
10:26:55 <Twey> lengthIs [] 0 = True; lengthIs [] _ = False; lengthIs _ 0 = False; lengthIs (x:xs) n = lengthIs xs (n - 1)
10:27:23 <FunctorSalad> MyCatVerbs: yes
10:27:38 <roconnor> FunctorSalad: hmm, better to ask someone else I guess.
10:27:45 <dcestari> anyone ever used Happy? I've been trying to write a simple parser but there are not many tutorials outhere
10:27:52 <sproingie> it's surprising how much dangerous stuff haskell actually lets you do
10:28:01 <EnglishGent> dcestari - I'm looking at Parsec
10:28:26 <EnglishGent> that seems fairly simple (dont know much about Happy beyond it's another parser generator though)
10:28:36 <Absolute01> Why am I infinitely recursing when I invoke the following hillClimbing function: http://pastie.org/701305? The input is finite, and the compareHeuristic function works as desired as well.
10:28:38 <roconnor> FunctorSalad: I assume IO is exposed to those people who need to make their own new IO primitives.
10:28:48 <EnglishGent> ManateeLazyCat - I'm trying _not_ to think of null pointers in C :)
10:28:51 <sproingie> contrast to, say, java, which even with sun.* APIs is still pretty well a padded room
10:29:03 <EnglishGent> but yes - I think isEmpty would be a better name
10:29:06 <dcestari> EnglishGent: I need to use happy
10:29:08 <EnglishGent> adding a synonym is trivial though
10:29:14 * hackagebot upload: hmatrix 0.6.0.0 - Linear algebra and numerical computations (AlbertoRuiz)
10:29:24 <ManateeLazyCat> EnglishGent: You just need tell me `null = isEmpty` `null = isEmpty` until you sleep..... :)
10:30:09 <roconnor> Absolute01: how do you know that prioritizedOpenList is smaller than open?
10:30:10 <EnglishGent> as I said - it's the typing I think's wierd .. I'm trying to grok the type system at a deep level - and it really surprised me that the (superficially) equivalent expression imposed an Eq restriction
10:30:40 <FunctorSalad> well, you call (==), and types never depend on values
10:30:45 <FunctorSalad> (the value being [] here)
10:31:55 <roconnor> Absolute01: in fact, to me prioritizedOpenList looks like it will always be larger than open
10:32:00 <Absolute01> roconnor: its almost always bigger actually. :)
10:32:13 <roconnor> Absolute01: well that's why you are recursing forever
10:32:17 <Absolute01> wait one sec..
10:32:33 <roconnor> Absolute01: your recurisve inputs keep getting bigger.
10:32:34 <lament> cursing forever
10:32:44 <Absolute01> roconnor: untill the leafs are reached..
10:32:48 <Absolute01> then it never expands..
10:32:56 <Absolute01> leaves.
10:33:17 <FunctorSalad> lament: "the curse is wearing off! recurse!" (sorry. really.)
10:33:21 <Absolute01> or until a goal is reached
10:33:46 <Twey> Heheh.
10:34:48 <kolmodin> anybody noticed that giving test-framework more cores doesn't actually speed it up, but slow it down?
10:34:50 <FunctorSalad> that was so horrible....
10:34:57 <roconnor> Absolute01: I don't know what you want us to say.
10:35:01 <Absolute01> roconnor: remember the open list starts with only a single element and then expands untill no more expansions are possible, at each iteration one elements from the list gets removed
10:35:19 <ManateeLazyCat> EnglishGent: I need sleep now, 02:34 now. See you! :)
10:35:19 <chrisdone> Twey: lengthIs n = (==n) . length . take (n+1)
10:35:20 <roconnor> Absolute01: here, replace generateUniqueChildren x (open ++ closed) with generateUniqueChildren x (xs ++ closed)
10:35:30 <roconnor> Absolute01: I don't know what your code does at all, but that will probably fix it.
10:35:45 <chrisdone> Twey: s/(n+1)/n
10:35:45 <Twey> chrisdone: Nice
10:35:54 <chrisdone> good olde lazy evaluation
10:35:57 <Twey> chrisdone: But what if it's longer?
10:36:02 <krainbolt> Don't put your alarm clock next to your computer speakers. Because when you're groggy and waking up it's going to freak you out that your speakers still scream at you when you turn them off.
10:36:03 <chrisdone> Twey: that's what take is for
10:36:20 <Twey> chrisdone: If you take n, the resultant list will be at most n in length
10:36:27 <Absolute01> roconnor: generateUniqueChildren generates children not int (open++closed) :)
10:36:32 <Twey> So if the original list was greater, it will give a false positive
10:36:37 <Twey> So you do want n + 1.
10:36:38 <chrisdone> Twey: then add back n+1
10:37:02 <chrisdone> Rule #2, never second guess yourself.
10:37:06 <Twey> Hehe.
10:37:07 <roconnor> Absolute01: in that case replace open with xs in your foldl.
10:37:16 <Absolute01> roconnor:  uniqueChildren = not in open or closed
10:37:30 <Absolute01> right..
10:37:41 <Absolute01> :)
10:37:54 <roconnor> 5 cents please
10:38:02 <roconnor> :)
10:38:17 <Absolute01> you take visa?
10:38:18 <Absolute01> :-P
10:38:23 <roconnor> :P
10:38:38 <roconnor> Absolute01: what is this for?
10:38:48 <Absolute01> AI class
10:38:53 <chrisdone> > foldl f [a,b,c]
10:38:54 <lambdabot>   No instance for (SimpleReflect.FromExpr [SimpleReflect.Expr])
10:38:54 <roconnor> nice
10:38:54 <lambdabot>    arising fr...
10:39:06 <Absolute01> I am not sure that was a fix anyways
10:39:08 <chrisdone> > foldl (+) [a,b,c]
10:39:09 <lambdabot>   No instance for (GHC.Num.Num [SimpleReflect.Expr])
10:39:09 <lambdabot>    arising from a use of...
10:39:10 <Absolute01> let me test it..
10:39:11 <chrisdone> bah
10:39:19 <chrisdone> > foldl (+) z [a,b,c]
10:39:20 <lambdabot>   z + a + b + c
10:39:36 <chrisdone> since when did it take out parentheses?
10:39:39 <Absolute01> woohoo hillclimbin beats dfs and bfs
10:39:40 <Absolute01> :)
10:39:46 <chrisdone> > foldl splerge z [a,b,c]
10:39:47 <lambdabot>   Not in scope: `splerge'
10:39:51 * chrisdone rage
10:40:00 <chrisdone> you know what, forget it
10:40:19 <Twey> .u'i
10:41:16 <roconnor> Absolute01: why foldl instead of foldr?
10:41:22 <FunctorSalad> > foldl (\x y -> " ("++show x++") "++show y) 3 [0..5]
10:41:23 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
10:41:23 <lambdabot>    arising from the literal ...
10:41:33 <FunctorSalad> > foldl (\x y -> " ("++show x++") "++show y) "3" [0..5]
10:41:34 <lambdabot>   " (\" (\\\" (\\\\\\\" (\\\\\\\\\\\\\\\" (\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" (...
10:41:42 <FunctorSalad> > foldl (\x y -> " ("++x++") "++show y) "3" [0..5]
10:41:43 <lambdabot>   " ( ( ( ( ( (3) 0) 1) 2) 3) 4) 5"
10:41:46 <FunctorSalad> tada
10:41:59 <chrisdone> > foldl (-) 0 [1,2]
10:41:59 <Absolute01> roconnor: i will have 2 children at most at any given time, so i dont think it matters
10:42:00 <lambdabot>   -3
10:42:08 <chrisdone> FunctorSalad: well done =)
10:42:15 <roconnor> Absolute01: okay
10:42:17 <FunctorSalad> could use an operator though :o
10:42:31 <Phyx-> FunctorSalad: lol, yes
10:42:32 <Absolute01> its a binary tree, i was just generalizing it..
10:42:44 <Absolute01> foldr simulates tail recursion?
10:43:04 <FunctorSalad> @ty parne
10:43:05 <lambdabot> Not in scope: `parne'
10:43:06 <FunctorSalad> @ty paren
10:43:07 <lambdabot> Not in scope: `paren'
10:43:10 <FunctorSalad> @ty parens
10:43:10 <lambdabot> Doc -> Doc
10:43:21 <FunctorSalad> > parens (string "test")
10:43:21 <Absolute01> > foldr (\x y -> " ("++x++") "++show y) "3" [0..5]
10:43:22 <lambdabot>   Not in scope: `string'
10:43:22 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
10:43:22 <lambdabot>    arising from the literal ...
10:43:31 <FunctorSalad> > parens (text "test")
10:43:32 <lambdabot>   (test)
10:57:22 * hackagebot upload: control-monad-failure 0.4 - A class for monads which can fail with an error. (PepeIborra)
10:58:35 <chrisdone> @pl \a n b -> n == 4 && null b || n<4 && not (null b) && a (n+1) (tail b)
10:58:36 <lambdabot> ap (ap . ((||) .) . (. null) . (&&) . (4 ==)) . ap ((.) . (&&) . (< 4)) . (ap ((&&) . not . null) .) . flip flip tail . ((.) .) . (. (1 +))
10:58:45 <chrisdone> hur
10:58:57 <Baughn> Wait, don't we already /have/ control-monad-failure?
10:58:59 <Baughn> It's called Monad
10:59:59 <chrisdone> > let lengthIs n = flip fix 0 $ \f c l -> c == n && null l || c<n && not (null l) && f (c+1) (tail l) in (lengthIs 5 [1..],lengthIs 5 [1..5]) -- Twey
11:00:00 <lambdabot>   (False,True)
11:00:20 <chrisdone> Twey: that's horrible. but defining things in terms of fix seems to be a hobby now =(
11:00:25 <Twey> Heh.
11:01:01 <chrisdone> hackagebot really needs to provide links..
11:01:20 <Baughn> Mm. Hackage is getting unwieldishly large
11:01:35 <sproingie> needs to be more wieldish
11:02:02 <Baughn> Yeah, then I'd be beamish
11:08:05 <EnglishGent> another question - I've just finished writing some simple search algorithms -- so for example I have bsearch :: a -> (a -> [a]) -> [[a]]
11:08:16 <Polarina> Is there a good FastCGI library for Haskell?
11:08:24 <chrisdone> Polarina: yeah. it's good
11:08:27 <EnglishGent> now - I want another variant for doing search where IO is involved (e.g. walking directory trees)
11:08:31 <Polarina> chrisdone: Where?
11:08:35 <chrisdone> http://hackage.haskell.org/package/fastcgi
11:08:48 <Polarina> chrisdone: Thanks.
11:08:48 <EnglishGent> I could write a variant bsearchM :: m a -> (m a -> m [a]) -> m [[a]]
11:08:57 <EnglishGent> but maintaining two copies feels wrong somehow
11:09:05 <EnglishGent> is there a more elegant way?
11:09:18 * Phyx- can't wait till there's a Haskell runtime engine.. then maybe my programs won't be 30mb+
11:09:50 * EnglishGent can actually think of a whole family of variations on a theme - where almost every variation runs into the yet-another-copy problem - but I'll start with this one, as it's the most pressing
11:09:55 <MyCatVerbs> Phyx-: GHC 6.12 is adding dynamic linking support on Linux.
11:09:55 <chrisdone> Phyx-: big executables shows character
11:10:11 <MyCatVerbs> So you should get much smaller executables soon, hopefully.
11:10:16 <chrisdone> yay
11:10:20 * chrisdone pets cat
11:10:23 <donri> http://sta.li/ ;)
11:10:34 <MyCatVerbs> Pet SPJ and friends, I'm not the one who did the work.
11:11:06 <chrisdone> MyCatVerbs: I already have a shrine of SPJ under my bed
11:12:30 <Phyx-> chrisdone: sure, but my preprocessor doesn't need to continue climbing to the size of ghc itself
11:12:44 <Phyx-> MyCatVerbs: unfortunately, I use windows predominantly
11:14:51 <chrisdone> Phyx-: yeah. I did a bit of web development where I'd upload the executable to a shared server. size was.. a pain
11:15:47 <EnglishGent> @hoogle liftM2
11:15:48 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:19:48 * EnglishGent grows at the monomorphism restriction
11:20:14 * mmmdonuts wonders how large EnglishGent will get
11:21:21 <McManiaC> why does the toChunks version of Data.ByteString.Lazy return a list of strict bytestrings?
11:22:28 <thoughtpolice> McManiaC: because that is essentially what a lazy bytestring is - it is a list of individually strict bytestrings
11:22:53 <McManiaC> with each "char" as one list element?
11:23:03 <thoughtpolice> not necessarily, no
11:23:08 <McManiaC> hmkay
11:23:08 <McManiaC> ^^
11:23:26 <thoughtpolice> that would very likely become wasteful quickly
11:23:52 <thoughtpolice> considering that the cost of creating a bytestring isn't invisible
11:23:59 <thoughtpolice> i believe 20 bytes of overhead per bytestring
11:24:27 <McManiaC> okay
11:24:41 <McManiaC> is there a general rule or is it more complicated?
11:24:46 <zong_sharo> why Foldable build arond foldr, why not foldl?
11:25:01 <jmcarthur_work> because foldr is what you usually want for lazy algorithms
11:25:43 <Absolute01> Can I list the operations of a type in ghci?
11:26:00 <jmcarthur_work> Absolute01, you could try hoogle
11:26:07 <zong_sharo> jmcarthur_work: but stack overflows
11:26:17 <jmcarthur_work> zong_sharo, depends what you are doing
11:26:25 <zong_sharo> cos of it it's fully impractical
11:26:36 <jmcarthur_work> foldr is far more useful than foldl, in my experience
11:26:50 <jmcarthur_work> there are cases where foldl is preferable
11:27:02 <jmcarthur_work> what is it that you are doing?
11:27:26 <dankna> Why would my program freeze when I try to use the value of a map?  I'm pretty sure I made sure the input to the map is finite...
11:28:01 <dankna> It doesn't pin the CPU or anything, just stops executing.  Hrm.
11:28:23 <zong_sharo> well, i will avoid stuff at all costs, if it will fail in some  uncertain and unpredictable cases, especially if scalability-related
11:28:33 <zygoloid> dankna: can you paste the code?
11:28:37 <jmcarthur_work> it's not uncertain or unpredictable
11:28:48 <dankna> well, it's a big program and it's not clear to me what portion of it is relevant
11:28:55 <jmcarthur_work> you use foldr where your algorithm calls for it, and you use foldl where your algorithm calls for it
11:28:58 <dankna> I could paste the access to the map, but that's not really helpful
11:29:05 <zong_sharo> well, it will work on list of length 100, but will fail on list of length 10^6
11:29:12 <jmcarthur_work> both can cause memory problems in different circumstances
11:29:25 <jmcarthur_work> can you please hpaste exactly what you are trying to do?
11:29:42 <zong_sharo> but foldl at least does not tears my stack away
11:29:49 <jmcarthur_work> for certain things it won't
11:31:23 <dankna> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4951#a4951
11:31:35 <zong_sharo> jmcarthur_work: i'm not trying to do something, i jusr figured about foldable and want understand why it happend
11:31:50 <dankna> zygoloid: as you see, this isn't really enough information
11:32:42 <zygoloid> dankna: it's plenty
11:32:52 <dankna> does that mean you see my mistake? :D
11:32:53 <zygoloid> subbindings = Map.union subbindings bindings -- that's your bug.
11:33:00 <dankna> erp.
11:33:02 <dankna> you're right, haha
11:33:05 <dankna> wow, how did I do that
11:33:12 <dankna> thanks!
11:33:24 <tommd> mmm, black holes.
11:33:25 <zygoloid> no problem
11:33:27 <zong_sharo> typeclass for folds is great, but foldr-basiness makes it's mostly unusefull, this discourages me
11:33:55 <jmcarthur_work> > (!! 10000) . foldr (++) "" . repeat $ "foo"
11:33:59 <lambdabot>   mueval-core: Time limit exceeded
11:34:06 <jmcarthur_work> > (!! 10000) . foldr (++) "" . repeat $ "foo"
11:34:08 <lambdabot>   'o'
11:34:14 <jmcarthur_work> > (!! 10000) . foldl (++) "" . repeat $ "foo"
11:34:20 <lambdabot>   mueval: ExitFailure 1
11:34:22 <jmcarthur_work> > (!! 10000) . foldl (++) "" . repeat $ "foo"
11:34:26 <lambdabot>   mueval-core: Time limit exceeded
11:34:41 <jmcarthur_work> i guess i'm trying too far or something in the first place
11:34:53 <jmcarthur_work> regardless, this is an example of why we often prefer foldr
11:34:55 <dankna> I'm impressed that ghc didn't pin the cpu when I did that, it just quietly decided it wasn't going to produce an answer for me today
11:35:26 <burp> > (!! 10000) . foldr (++) "" . repeat $ "foo"
11:35:28 <lambdabot>   'o'
11:35:32 <jmcarthur_work> > (!! 1000) . foldl (++) "" . repeat $ "foo"
11:35:36 <iaefai> > let n = 63 in (n % 8, n / 8)
11:35:38 <lambdabot>   mueval: ExitFailure 1
11:35:49 <lambdabot>   mueval-core: Time limit exceeded
11:36:40 <jmcarthur_work> zong_sharo, foldr is more useful than you are giving it credit for
11:39:02 <zygoloid> dankna: you're walking down a corridor. you turn left. you turn right. you turn right. black hole!
11:41:20 <byorgey> you are in a maze of twisty black holes, all *Error: loop
11:42:06 <Baughn> * Quench light
11:42:31 <dankna> zygoloid: haha, ouch
11:42:42 <monochrom> When execution falls into a black hole, we outside observers see that the execution clock stops.
11:42:59 <dankna> well, it's useful, regardless of how it's accomplished
11:44:56 <tensorpudding> so it's not an event horizon of information
11:46:21 <iaefai> If I have a function, b, that should output the same number that is given to it, how can I iterate through the range 0 to 63 to ensure that it is in fact the case? I just want to test in ghci, I support something operating like a for loop would be quite awesome.
11:46:28 <sinelaw> is RWH available at bookstores? I won't have time to order it
11:46:53 <iaefai> sinelaw: In bigger ones they should have copies
11:47:51 <sproingie> read it online while you wait for the order
11:47:55 <Botje> iaefai: map (\x -> (x, b x)) [0..63]
11:48:10 <Botje> that gives you a list of (input, output) pairs
11:48:18 <iaefai> Botje: That is awesome, thank you
11:48:19 <Botje> you could visually inspect the output
11:48:25 <Botje> or you could ask haskell to check it for you:
11:48:37 <iaefai> visual worked
11:48:38 <Botje> all (uncurry (==))
11:48:50 <sm> chrisdone: most voters seem to not want links from hackagebot
11:48:58 <sinelaw> sproingie, i'll be away with limited internet access
11:49:00 <Botje> well, all (uncurry (==)) $ map ...
11:49:11 <iaefai> sinelaw: Where do you live?
11:49:44 <sinelaw> iaefai, i'll be visiting LA for a few days
11:49:51 <sinelaw> so i was thinking to buy it there
11:49:54 <mjrosenb> byorgey: i'm sure you can think of another black hole that ghc won't be able to resolve to *Error: loop
11:51:00 <bos> dons: what do we do about the divergence between uvector and vector?
11:51:40 <iaefai> sinelaw: Found one for you: http://search.barnesandnoble.com/booksearch/store.asp?EAN=9780596514983&distance=2&zipcode=90036&x=0&y=0
11:51:43 <dons> vector's not attempting to be stable, afaik
11:51:52 <bos> dons: rl seems to be working pretty hard on vector lately, but uvector is kind of adrift.
11:51:52 <mjrosenb> bos: take a line integral?
11:51:52 <dons> so i say put all work into uvector, for a canonical flat arrays lib.
11:51:54 <sinelaw> iaefai, thanks, i just found that same page myself this very moment!
11:52:09 <dons> vector's concentrating on distributed parallel arrays though.
11:52:20 <bos> dons: fair enough. i need to start hacking on uvector a little more intensively, then, to fix stuff like O(n) indexU.
11:52:35 <dons> yeah, needs that API split done (streaming in one module, direct stuff in another)
11:52:42 <dons> and some QCs. that's the main stuff
11:52:44 <dcestari> Hello, I'm trying to implement a Show class instance
11:52:54 <dons> currently it by default exports the streaming version of everything
11:53:01 <dons> and you have to pull in the direct version from UArr
11:53:10 <dcestari> I have a type like "data Token = TokenInt Int | TokenVar String | TokenLet"
11:53:24 <bos> dons: ugh
11:53:44 <dcestari> how can I know which token value is when I'm on my show method ?
11:53:45 <dons> streaming indexU is rarely what's needed, for example
11:53:46 <bos> dons: the text package uses rewrite rules to choose between streaming and direct code
11:53:57 <dons> right, i explicitly chose not to do that after the bytestring experience
11:54:06 <dons> it becomes hard to predict when rewriting back will occur.
11:54:11 <bos> true
11:54:13 <dons> though rl seems to think it is still the best option
11:54:34 <PetRat> How do I show a number in hexadecimal format?
11:54:57 <blackh> PetRat: showHex from Numeric module in base
11:55:09 <PetRat> blackh: thanks!
11:55:34 <byorgey> dcestari: use pattern matching.
11:55:51 <byorgey> dcestari:   show (TokenInt i) = ...    show (TokenVar v) = ...
11:56:01 <dons> bos: i can open up the repo to you if you want to just hack on it.
11:56:03 <dcestari> byorgey: yes, I know It has something to do with it, but I'm SO new to haskell still
11:56:10 <bos> dons: cool.
11:56:26 <byorgey> dcestari: well, welcome =)
11:56:33 <dcestari> byorgey: thank you, I only knew how to use pattern matching on an array hehe
11:56:48 <monochrom> It is almost another PhD thesis to show that a particular set of rewrite rules terminate.
11:57:05 <byorgey> dcestari: you mean a list? ;)
11:57:53 <byorgey> dcestari: the difference is that an array lets you access any element instantly, whereas a list must be traversed from start to end.
11:57:56 <dcestari> byorgey: exactly, sorry, still shaking off the imperative stigma hehe
11:58:14 <byorgey> dcestari: Haskell lists are really lists (although Haskell does have some libraries for arrays)
11:58:18 <byorgey> dcestari: no problem =)
11:58:55 <Egg_> can someone help me with a function I'm writing again?
11:58:59 <Egg_> http://pastebin.com/m60fde5ba
11:59:16 <Egg_> It's supposed to square the numbers in a list, then add them all up
11:59:25 <Egg_> but the recursion never finishes I think
11:59:35 <Egg_> according to ghci
11:59:44 <luite> (x:xs) can never be []
11:59:48 <byorgey> Egg_: note that (x:xs) == []  will always be false.
12:00:06 <byorgey> Egg_: I think you want to write a case for   squareAdder []  first
12:00:17 <byorgey> then a case for  squareAdder (x:xs)
12:00:21 <Kim^Walkman> > sum (map (^2) [1..5])
12:00:22 <lambdabot>   55
12:00:49 <Kim^Walkman> @src sum
12:00:49 <lambdabot> sum = foldl (+) 0
12:01:09 <Egg_> oh yeah
12:01:10 <Egg_> thanks
12:01:15 <iaefai> Praise Haskell! move (Board s) src dst = Board $ S.update dst square $ S.update src EmptySquare s    where square = S.index s src   couldn't think of any other language where a move function is that easy
12:01:37 <byorgey> Kim^Walkman: now, let's not solve people's homework for them... =)
12:01:46 <Kim^Walkman> Why doesn’t sum use the strict version of foldl?
12:02:05 <iaefai> foldl is baaaad
12:02:08 <bd_> Kim^Walkman: because the haskell report defines it in terms of foldl not foldl'
12:02:10 <byorgey> Kim^Walkman: because it is silly
12:02:20 <bd_> This is arguably a bug in the report, but the GHC devs don't see it that way :)
12:02:42 * hackagebot upload: http-wget 0.2.1 - Provide a simple HTTP client interface by wrapping the wget  command line tool. (MichaelSnoyman)
12:02:43 <Kim^Walkman> foldl' would be better, but foldr would be even better, yes?
12:02:44 * hackagebot upload: authenticate 0.2.1 - Authentication methods for Haskell web applications. (MichaelSnoyman)
12:02:59 <byorgey> Kim^Walkman: no, foldl' is best for sum.
12:03:28 * Kim^Walkman has a hard time knowing when to use foldr over foldl'
12:03:38 <byorgey> Kim^Walkman: to evaluate a sum using foldr you have to get all the way to the end of the list before you can even possibly start doing any addition
12:03:46 <Kim^Walkman> Oh.
12:03:47 <byorgey> > foldr (+) 0 [a,b,c,d]
12:03:48 <lambdabot>   a + (b + (c + (d + 0)))
12:03:52 <byorgey> like that.
12:04:06 <iaefai> When haskell 98 is superceded by what is now prime, is it going to be incompatible with 98?
12:04:10 <Kim^Walkman> And that would hog some memory, wheras fold'l won't
12:04:14 <byorgey> foldr is useful when the combining function can already start producing a result before seeing the result of the recursive call.
12:04:17 <yairchu> Kim^Walkman: usually foldr would be used when you build a lazy data structure. for example map or filter would use it because they build a list based on the original list
12:04:49 <idnar> someone should just rerelease Haskell 1.4 (?) as Haskell '09
12:05:27 <tensorpudding> haskell prime is a better name
12:05:30 <fritschy> how come these functions http://pastebin.com/d75e602a9 work in ghci with let and not in a .hs file? the error i am getting is about ambigous seq... which i don't (yet) understand ;)
12:05:36 <FunctorSalad> iaefai: n+k-patterns are going out
12:05:57 <zong_sharo> tensorpudding: then 2109 revision will be named "haskell prime-prime"
12:06:00 <byorgey> fritschy: the Haskell standard libraries include a function called 'seq'
12:06:06 <tensorpudding> haskell double prime?
12:06:10 <zong_sharo> ouch
12:06:17 <byorgey> fritschy: either change the name of your function, or  import Prelude hiding (seq)
12:06:19 <zong_sharo> *2019 year revision of cource
12:06:24 <fritschy> byorgey: i tried it with sequence too... hmpf!
12:06:31 <fritschy> ok... well... :) thianks a lot :)
12:06:36 <byorgey> fritschy: hehe, there is ALSO a standard function called 'sequence' =)
12:06:56 <tensorpudding> @type sequence
12:06:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:07:02 <tensorpudding> @type seq
12:07:03 <lambdabot> forall a t. a -> t -> t
12:07:11 <FunctorSalad> and Data.Sequence, which is unrelated to both
12:07:43 <tensorpudding> will haskell prime use the quantifiers in the type signatures?
12:07:58 <fritschy> byorgey: argh :) i thought i made a mistake with that sinmple thing *g* thank you
12:08:06 <byorgey> fritschy: I might call your 'seq' function 'while'
12:08:09 <byorgey> fritschy: sure =)
12:08:53 <luite> byorgey: it looks more like 'until'
12:09:06 <byorgey> good point.
12:10:08 <monochrom> (\x -> if even x then div x 2 else 3 * x + 1) gives you the Collatz sequence, not an Ackermann thing.
12:10:35 <dankna> @src mapM
12:10:35 <lambdabot> mapM f as = sequence (map f as)
12:10:42 <dankna> hm
12:10:44 * hackagebot upload: FileManipCompat 0.15 - Expressive file and directory manipulation for Haskell. (ThomasHartman)
12:10:55 <dankna> @type sequence
12:10:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:11:04 <dankna> @src sequence
12:11:05 <lambdabot> sequence []     = return []
12:11:05 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:11:05 <lambdabot> --OR
12:11:05 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
12:11:06 <fritschy> luite: right :)
12:11:07 <dankna> hm
12:12:15 <iaefai> FunctorSalad: Why are they going out?
12:12:56 <FunctorSalad> iaefai: http://hackage.haskell.org/trac/haskell-prime/wiki/RemoveNPlusK
12:14:26 <iaefai> This is a con? "it is a concise, natural, and familiar notation for recursion over naturals"
12:14:40 <ben0x539> iaefai: a 'con' for the removal
12:14:49 <FunctorSalad> iaefai: also http://hackage.haskell.org/trac/haskell-prime/ticket/130
12:14:58 <FunctorSalad> "State: completed"
12:15:07 <iaefai> What does non-orthogonal mean?
12:15:19 <dankna> iaefai: intertwined with each other
12:15:47 <iaefai> dankna: Can you say that in a less confusing way?
12:16:14 <dankna> possibly, but I'd have to read the page you're referencing
12:16:28 <Rotaerk> non-orthogonal, lack of orthogonality
12:16:30 <iaefai> Just this: http://hackage.haskell.org/trac/haskell-prime/wiki/RemoveNPlusK
12:16:31 <Rotaerk> *cough*
12:16:44 <dankna> when two things are orthogonal they are independent - like vectors at right angles, they do not affect each other
12:17:18 <dankna> so where that page calls them "non-orthogonal" it means that they are too intertwined with the rest of the system
12:17:20 <iaefai> Would ghc be keeping it when it goes out?
12:17:29 <dankna> presumably not?
12:17:37 <ben0x539> Why are [Control.Concurrency.]Chans not called Queues, anyway
12:18:00 * edwardk_ waves hello.
12:18:10 <tensorpudding> dankna: your usage of orthogonal in the first part is valid, but i don't know in what sense vectors might affect each other that you are referring to
12:18:19 <monochrom> because we say "the communication channel is open" rather than "the communication queue is open" in Star Trek
12:18:26 <dankna> tensorpudding: well... it's just my mnemonic
12:19:01 <dankna> tensorpudding: I could explain it, but since its primary purpose is just to make sense to me, I'm not sure explaining it has much value, heh.  I probably should have left that part out.
12:19:02 <ben0x539> "hold on, data, the enterprise is not responding right away so I am blocking"
12:19:30 <Phyx-> monochrom: LOL
12:19:31 <tensorpudding> well you think of two things having an overlap, and the overlap of two vectors is their inner product, which is 0 when they are orthogonal
12:19:39 <tensorpudding> i see the line of reasoning, i'm just being nitpicky
12:19:51 <dankna> yes, that's what I was getting at
12:19:53 <dankna> okay
12:20:12 <FunctorSalad> "out of memory... pkill the firefox"
12:20:32 <tensorpudding> pkill firefox, apt-get remove firefox, apt-get install a decent web browser...
12:20:51 <FunctorSalad> (I was still going with the star trek theme)
12:20:52 <monochrom> We just analogize "orthogonal" from math to language design.
12:21:16 <tensorpudding> i actually was thinking i was in #math
12:21:36 <Jedai> iaefai: I think intertwined is not really the problem here, non-orthogonal means that this features isn't really useful because we can do the same thing with other means that aren't really harder to use or read
12:21:39 * Phyx- wonders if data used wikipedia to look for info
12:21:43 <byorgey> This use of "orthogonal" comes from the Algol 68 Report, IIRC.
12:22:05 <dankna> tensorpudding: amusement!  nope.
12:22:40 <Jedai> iaefai: and since this feature is very restricted in range (it only works with naturals or should anyway) it seems to be useless syntaxic cruft
12:23:54 <iaefai> Jedai: ok, what other means do we have without resorting to an if statement inside the function?
12:24:01 <FunctorSalad> abusing how it uses >= would make for some great obfuscated haskell
12:24:19 <Jedai> iaefai: Would GHC keep them, it would probably keep them as an "obsolete" extension for some versions and then just remove them
12:24:38 <Jedai> iaefai: you can write a view pattern
12:24:43 <generic> how can I execute a shell command in haskell?
12:24:58 <FunctorSalad> @hoogle readProcess
12:24:59 <lambdabot> No results found
12:25:03 <monochrom> System.Process.system may help
12:25:03 <ben0x539> FunctorSalad: Would it?
12:25:20 <kmc> generic, look at System.Process
12:25:22 <ben0x539> FunctorSalad: I thought it said that if the desugaring specifies functions, those always refer to the prelude and cannot be overloaded.
12:25:25 <Jedai> iaefai: use a guard or whatever, did you really use n+k pattern more than a couple of time in any of your code ?
12:25:26 <ben0x539> overriden.
12:25:35 <tensorpudding> is there a way to embed lambdabot in ghci?
12:25:47 <FunctorSalad> ben0x539: (>=) is a class method...
12:25:50 <generic> monochrom: import System.IO too?
12:25:55 <Jedai> iaefai: I don't think I ever did use them unless especially prompted to do so by a tutorial or course
12:26:23 <ben0x539> FunctorSalad: i figured the implication is that it would only work for prelude instances
12:26:37 <monochrom> Depends.
12:27:08 <FunctorSalad> ben0x539: maybe you're thinking of the comment about '+'?
12:27:25 <Jedai> generic: there's also a very nice package with an API to do easy conversation with external commands, use haskell function as part of a pseudo-pipe and so on
12:27:28 <Saizan_> tensorpudding: there's GOA (Ghci On Acid) though i'm not sure if it still works
12:27:47 <Jedai> generic: it's somewhere on Hackage, shouldn't be too hard to find
12:28:04 <generic> Jedai: im not a programmer in any lang, I just use python for math, and xmonad
12:28:08 <kmc> you can extend ghci with new commands
12:28:16 <iaefai> Jedai: I might be mistaking something when I said that last thing.
12:28:16 <iaefai> I have to write a function that determines whether or not a move can be made (chess). Looks like it will be a bitch.
12:28:24 <generic> and yes I know haskell is best for math
12:28:26 <FunctorSalad> Jedai: HSH?
12:28:48 <Jedai> FunctorSalad: Right, seems nice though I never used it myself yet
12:28:50 <iaefai> Jedai: I think I used it once
12:28:53 <generic> but Im too deep in math to learn haskel right now
12:29:00 <iaefai> But it was quite useful in that context…
12:29:04 <iaefai> I am not sure what a view pattern is
12:29:18 <tensorpudding> Saizan_: sounds a bit hardcore
12:29:38 <tensorpudding> Saizan_: all i really want is hoogle
12:29:53 <FunctorSalad> > let f (error -> 38) = 22 in f "hi"
12:29:54 <lambdabot>   Illegal view pattern:  (error -> 38)
12:29:54 <lambdabot>  Use -XViewPatterns to enable view pat...
12:29:59 <FunctorSalad> ;)
12:30:14 <Jedai> iaefai: a view pattern is somewhat a generalization of what n+k pattern are all about, basically they allow you to create user function to extend your pattern matching capacity
12:30:49 <iaefai> Jedai: I will take that and get back to work :p
12:31:10 <Saizan_> tensorpudding: cabal install hoogle and add some :def , i think there's a page about hoogle-ghci integration on the haskellwiki
12:31:19 <fffej> if I have data Color = Red | Green | Blue, is there a way to get a list of all the types (e.g [Red, Green,Blue]) without typing them in again?
12:31:26 <Jedai> iaefai: you could write a "plus" view-pattern so that (plus k -> n) would do the same thing as a n+k pattern but they're more generally useful
12:32:15 <generic> Actually would any of you gentelmen be willing to just tell me how to execute a process in linux with haskell? I assume, System.process.somthing -> String ?
12:32:28 <eivuokko> fffej, not without additional tool.
12:32:30 <Saizan_> fffej: if you add deriving (Enum, Bounded) to that declaration then you can use [minBound .. maxBound] :: [Color]
12:32:35 <generic> I just dont have time to find out I dont know any haskell really
12:32:56 <fffej> saizan_: thanks, looks like just what I need
12:33:00 <Saizan_> generic: System.Process.readProcess
12:33:20 <Jedai> :t readProcess
12:33:22 <lambdabot> Not in scope: `readProcess'
12:33:29 <kmc> generic, http://www.haskell.org/ghc/docs/latest/html/libraries/process/System-Process.html
12:33:50 <kmc> generic, in general the docs for standard modules are: http://www.haskell.org/ghc/docs/latest/html/libraries/
12:34:11 <generic> kmc: yeah i already read that
12:34:19 <generic> i dont understand any of it
12:34:24 <generic> im not a programmer >.>
12:34:32 <kmc> generic, that module basically defines a general way to spawn processes, and a bunch of special cases
12:34:42 <kmc> okay, so what do you want to do with this process?
12:34:47 <kmc> - does the shell have to expand the command line?
12:34:49 <generic> I know what it does..
12:34:51 <kmc> - do you give it input on stdin?
12:35:00 <kmc> - do you need to receive output on stdout/stderr?
12:35:00 <generic> input
12:35:06 <generic> no output
12:35:10 <FunctorSalad> generic: import System.Process; main = rawSystem "yes" []
12:35:18 <ben0x539> :D
12:35:20 <dankna> hm
12:35:23 <dankna> so I've defined mergeBy :: (a -> a -> Ordering) -> [[a]] -> [a]
12:35:25 <generic> FunctorSalad: thanks
12:35:28 <dankna> and I need a monadic version of it
12:35:35 <FunctorSalad> generic: (the list can take args)
12:35:35 <dankna> is there some easy trick, or do I need to rewrite the whole thing?
12:35:40 <dankna> I guess the type I need it to have is
12:35:52 <kmc> generic:  readProcess "myProg" ["arg1", "arg2"] "input to stdin"
12:36:03 <dankna> mergeByM :: (Monad m) => (a -> a -> m Ordering) -> [[a]] -> m [a]
12:36:16 <zygoloid> dankna: that needs a rewrite
12:36:19 <dankna> hmm okay
12:36:27 <dankna> then rewrite it I shall
12:36:29 <kmc> :t sequence
12:36:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:36:33 <kmc> dankna, ^^^ may be useful
12:36:42 <zygoloid> dankna: the original had no ordering over the, umm, orderings :)
12:36:43 <dankna> kmc: yeah I actually just discovered that a few minutes ago :)
12:37:08 <dankna> zygoloid: hmmm...  I see what you mean
12:37:32 <dankna> because the order in which the, um, orderings are evaluated isn't defined, sequence can't transform it, nor is there any other simple trick.  does that sum it up?
12:38:30 <zygoloid> dankna: right, the order in which you, umm, sequence, the calls to the ordering function is unspecified, and you'll need to specify it somehow.
12:38:50 <dankna> gotcha.
12:39:04 <dankna> no doubt the nature of that sequencing will be clear when I finish the rewrite.
12:40:26 <iaefai> I wonder if it is possible to replace ghci with something that can define functions in addition to what ghci already does.
12:40:26 <iaefai> I wonder if there is a nice way of changing this: toIndex (x, y) = (y * 8 + x)  so that x and y cannot be greater than 7 and not less than 0
12:40:45 <kmc> x `mod` 8
12:41:00 <Jedai> iaefai: ghci already allows you to define functions
12:41:10 <kmc> iaefai, you can define functions in ghci, using the do-block "let" syntax
12:41:23 <kmc> since you're already in a do block in ghci
12:41:44 <Jedai> let f 0 = 1; f 1 = 1; f n = f (n-1) + f (n-2)
12:41:52 <Jedai> > let f 0 = 1; f 1 = 1; f n = f (n-1) + f (n-2) in f 5
12:41:53 <lambdabot>   8
12:42:31 <Jedai> iaefai: you can input the let f... alone in GHCi and it will define a binding for the rest of the session
12:44:25 <cathper> Can Hugs do something similar btw.?
12:46:24 <dankna> wow...
12:46:45 <dankna> I actually understand what unification and the occurs check are, but I have never managed to trigger it in a typesystem before :D
12:47:03 <dankna> let me see if I can make sense of this error, haha; if not I'll paste it
12:48:20 <profmakx> ha
12:49:19 <monochrom> typechecking borrows much from resolution provers.
12:50:01 <Cale> cathper: hugs only accepts expressions
12:50:24 <Cale> cathper: so you don't get the let-without-in syntax
12:50:26 <fritschy> is there a way i can visualize automatically how some recursive calls are evaluated/expanded?
12:50:39 <fritschy> i can't quite get my head around something right now...
12:50:47 <Cale> fritschy: If you find one, let me know. I tend to do it by hand.
12:51:02 <Cale> fritschy: If it's small I wouldn't mind doing it for you.
12:51:06 <dankna> there we go.  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4952#a4952
12:51:09 <monochrom> ghci has a debugger side and it helps a tiny bit
12:51:37 <fritschy> Cale: nah, i can do it by my self - i am just too lazy ;) (but might just as well do it anyway)
12:52:01 <Cale> fritschy: Also, Debug.Trace is useful for printing parameters to functions, though doing that will obviously have drastic effects on evaluation order
12:52:02 <cathper> Cale: I see.
12:52:05 <dankna> the error is "Occurs check: cannot construct the infinite type: a = [a] when generalizing the type for mergeByM."  Which...  I understand why it can't construct an infinite type :) but not how what I'm doing is trying to
12:52:30 <dankna> that's line 2 of the paste that it complains about, but I suspect the problem is not really a local issue
12:52:56 <Cale> fritschy: A good trick is to stick a function definition with a guard that's always false at the top of the function decl. but stick a trace on that guard which prints parameters, or just the function name
12:53:29 <Cale> fritschy: At least, if it's so hairy that you can't figure out what parameters cause it to go wrong.
12:53:31 <monochrom> @type foldl
12:53:32 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:53:37 <ksf> what strange black magic is it that I have to do to get a rule for a pattern match to fire?
12:53:55 <monochrom> Or (x -> y -> x) -> x -> [y] -> x  if you will
12:54:03 <ksf> somehow ghc does'nt realize that it can build that thing at compile time
12:54:10 <Cale> ksf: My understanding is that RULES doesn't work very well for specific pattern matches
12:54:29 <monochrom> So let's look at foldl (mergeTwoByM function).  mergeTwoByM function :: x -> y -> x ?
12:54:45 <Cale> ksf: I remember seeing a blog post about a somewhat convoluted workaround for a similar problem not long ago. Let me search :)
12:54:47 <dankna> monochrom: hmm...  I think I might see it from what you said, but yes, please continue
12:55:26 <dankna> hmm
12:55:33 <dankna> you asked me a question, I'm trying to answer it :)
12:55:35 <monochrom> Well, mergeTwoByM function :: [a] -> [a] -> m [a].  x=[a], y=[a], x=m [a], therefore [a]=m [a]?
12:55:39 <Cale> http://unlines.wordpress.com/2009/11/05/tricking-ghc-into-evaluating-recursive-functions-at-compile-time/
12:55:44 <dankna> ah
12:55:48 <fritschy> Cale: thank you, i am reading up on debugging right now :)
12:55:51 <dankna> yes okay
12:55:54 <ksf> thx
12:56:08 <dankna> so I gave the compiler information that doesn't exactly conflict, but can only be true if the type is infinite
12:56:52 <dankna> I'm sure you can guess the followup question, but I'll ask it anyway - what do I use instead of foldl? :)
12:56:57 * hackagebot upload: GenI 0.20.2 - A natural language generator (specifically, an FB-LTAG surface realiser) (EricKow)
12:57:08 <dankna> (hey cool, re GenI)
12:57:45 <Cale> dankna: I'm betting that you really want foldM, but this is without thinking much ;)
12:57:45 <monochrom> @type foldM
12:57:46 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
12:57:53 <dankna> Cale: haha okay
12:57:57 * iaefai should have picked checkers
12:58:14 <dankna> hmmm
12:58:17 <dankna> I see, thank you
12:58:23 <monochrom> I fear that foldM is the one
12:59:47 <edwardk> @seen dons
12:59:47 <lambdabot> Unknown command, try @list
12:59:54 <edwardk> gah, i'll never get used to that =)
13:00:00 <edwardk> preflex: seen dons
13:00:00 <preflex>  dons was last seen on #ghc 1 hour and 3 minutes ago, saying: right
13:00:24 <Cale> Heh, someone should write a lambdabot @seen plugin which just asks preflex ;)
13:00:57 <ksf> oh that's a very neat trick
13:00:57 <dankna> sweet, my mergeBy now works.
13:00:58 <edwardk> haha
13:01:06 <ksf> hope it works for my case
13:01:12 <edwardk> just need to invite preflex to all the same channels ;)
13:01:33 <edwardk> not a big step from there to changing its nick from preflex to lambdabot =)
13:02:53 <Guest79539> Hello
13:03:20 <donri> hello u
13:04:19 <Guest79539> erm I have a bit of a foolish question
13:04:26 * Cale will probably never properly understand fontconfig's configuration. :P
13:04:51 <Guest79539> i mean i'd hate to make it seem as though i'm just asking "HOW DO I CODED PROGRAMZ"
13:05:08 <Cale> Guest79539: We like beginner questions here :)
13:05:12 <Guest79539> but my brain hurts as haskell's the first time I've encountered partial application & currying & such
13:05:13 <tensorpudding> how is program formed? how haskell get coded?
13:05:17 <Guest79539> yes lol
13:05:47 <Cale> @remember tensorpudding how is program formed? how haskell get coded?
13:05:48 <lambdabot> Good to know.
13:05:52 <Cale> @flush
13:05:54 <Guest79539> well if I wanted to remove all spaces from the front of a string, then break that string at the next space, one way is
13:05:56 <tensorpudding> they need to do way instain monads who confuse haskell noobies
13:06:06 <Guest79539> oh no
13:06:15 <Guest79539> its not even : ( i haven't started on monads
13:06:29 <iaefai> Is it possible to catch division by zero in a pure calculation and use it is a valid response?
13:06:32 <Guest79539> but i read a lot of abstract algebra so i think i might find it manageable
13:06:33 <Cale> @remember tensorpudding they need to do way instain monads who confuse haskell noobies
13:06:34 <lambdabot> Done.
13:06:36 <Cale> @flush
13:06:52 <roconnor> Guest79539: use Data.Split from hackage
13:07:08 <Guest79539> (break (== ' ') (dropWhile (== ' ') str))
13:07:11 <roconnor> http://hackage.haskell.org/package/split
13:07:12 <Guest79539> but that's silliness.
13:07:12 <tensorpudding> oh man, i'm being remembered for terrible meme references
13:07:25 <Cale> tensorpudding: haha
13:07:28 <roconnor> Guest79539: that isn't a terrible solution.
13:07:39 <edwardk> tensorpudding: it happens to us all
13:07:45 <Guest79539> How do i passed (== ' ') to both functions?
13:07:46 <tensorpudding> @quote tensorpudding
13:07:47 <roconnor> @hoogle isSpace
13:07:47 <lambdabot> tensorpudding says: they need to do way instain monads who confuse haskell noobies
13:07:47 <lambdabot> Data.Char isSpace :: Char -> Bool
13:07:47 <lambdabot> Data.ByteString.Internal isSpaceChar8 :: Char -> Bool
13:07:47 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
13:07:52 <iaefai> define 'instain'
13:07:53 <shapr> edwardk: dude, your monoid is showing.
13:07:53 <jlouis> tensorpudding: you are on a @remember-spree today!
13:08:02 <edwardk> ack
13:08:03 <Cale> Guest79539: If you're going to keep doing that, probably just using words is better.
13:08:05 <roconnor> Guest79539: dropWhile isSpace might be better
13:08:08 <Guest79539> oh that's neat
13:08:08 * edwardk tucks it back.
13:08:12 <fritschy> Cale: Debug.Trace did the trick :)
13:08:13 <Cale> > words "here are a bunch of words"
13:08:14 <lambdabot>   ["here","are","a","bunch","of","words"]
13:08:25 <tensorpudding> shapr: i'm pretty sure i remembered zip my monoid
13:08:35 <shapr> tensorpudding: glad to hear that.
13:08:39 <Guest79539> is that a provided function? That's cool. I'm more interested in learning how it works than just applying it however.
13:08:42 <roconnor> > words "   here   are abunch of words   "
13:08:43 <lambdabot>   ["here","are","abunch","of","words"]
13:09:04 <edwardk> shapr: started hacking on kata again today ;)
13:09:06 <Cale> words            :: String -> [String]
13:09:06 <Cale> words s          =  case dropWhile Char.isSpace s of
13:09:06 <Cale>                       "" -> []
13:09:06 <Cale>                       s' -> w : words s''
13:09:06 <Cale>                             where (w, s'') = break Char.isSpace s'
13:09:08 <shapr> edwardk: yay!
13:09:29 <ben0x539> Could really do with a wordsBy
13:09:36 <Cale> (that's the Report implementation and may or may not be what GHC actually does)
13:10:08 <Cale> If you need more complicated string splitting, check out the  split  package on hackage.
13:10:08 <shapr> Silly question, how do you get lambdabot to print utf-8?
13:10:12 <Guest79539> oh thank you
13:10:27 <Guest79539> thanks Cale. Where does s' come from though?
13:10:37 <Guest79539> I can see that s'' is coming from the "where"
13:10:51 <edwardk> Guest79539: the case's second case.
13:10:53 <Cale> Guest79539: s' is the result of dropWhile isSpace s
13:11:17 <edwardk> "the case's second case is s'" sounds like a tongue twister.
13:11:18 <Cale> Guest79539: The case is just to handle the case where it happens to be an empty string separately
13:11:19 <Guest79539> ooooooh yes yes yes
13:11:35 <Guest79539> *facepalm* pattern matching right
13:11:46 <Guest79539> s' is just a name that (dropWhile Char.isSpace s) gets bound to
13:12:00 <jlouis> Guest79539: welcome to Haskell. As soon as you get it, it is trivial :)
13:12:07 <Guest79539> That's really neat.
13:12:07 <Cale> shapr: hmm... the UTF-8 support in lambdabot is incomplete and sketchy.
13:12:24 <Guest79539> Yeah I'm a fast learner but unfortunately I store a lot of what I learn in RAM instead of writing to disk
13:12:41 <Guest79539> so for example I learned conversational german a year ago but now I can't remember my dies from my ders
13:13:02 <Guest79539> So my memory of various haskell features comes and goes
13:13:07 <Guest79539> :) thanks everypeople
13:13:13 <Cale> No problem!
13:14:57 <kosmikus> could somebody with permission please have lambdabot join #tc2009? thanks a lot.
13:14:57 <lambdabot> kosmikus: You have 1 new message. '/msg lambdabot @messages' to read it.
13:15:07 <Cale> kosmikus: sure
13:15:26 <Cale> lambdabot: @join #tc2009
13:15:26 <kosmikus> Cale: thanks
13:15:37 <Cale> kosmikus: Would you like that to be temporary or permanent?
13:15:51 <kosmikus> Cale: permanent would be cool
13:16:23 <Cale> okay, done :)
13:17:00 <kosmikus> Cale: thanks again
13:17:35 <mpwd> Is there a better way to do "liftM all $ sequence $ map (`lookup` x) ys"?
13:17:49 <burp> > sum . fmap (\x -> x^^(-2)) $ [1..10000
13:17:50 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:18:00 <burp> > sum . fmap (\x -> x^^(-2)) $ [1..10000]
13:18:01 <lambdabot>   1.6448340718480652
13:19:56 <Cale> mpwd: that... seems like a type error?
13:20:26 <mpwd> Nah... ys is a list of (p,Bool) pairs
13:21:10 <Botje> and what's x ?
13:21:11 <mpwd> So map lookup gives a list [Maybe Bool], then sequence gives "Maybe [Bool]",and liftM lifts all into the monad
13:21:39 <mpwd> Um, in this case, a propositional formula for this strange planning logic my prof came up with for his cog-sci research
13:21:53 <Botje> but all needs a predicate?
13:21:55 <Botje> did you mean and ?
13:21:56 <iaefai> Does anyone have a problem on the mac where an 'hs' file has almost any application and its brother saying it can open it?
13:21:57 <Cale> uh, but all doesn't take a Bool
13:22:07 <Cale> (or a list of Bool)
13:22:16 <mpwd> Cale:  Oh good...
13:22:20 <Cale> maybe you want 'and'
13:22:23 <mpwd> Yeah
13:22:52 <Cale> :t \x ys -> fmap and . sequence . map (`lookup` x) $ ys
13:22:53 <lambdabot> forall a. (Eq a) => [(a, Bool)] -> [a] -> Maybe Bool
13:23:00 <Cale> good, that's typechecking now :)
13:23:09 <mpwd> nice
13:23:58 <mpwd> It just occurred to me that I need to do more processing on ys than just a lookup
13:24:08 <Cale> Maybe you want a filter?
13:24:15 <iaefai> Can I have ghc tell me if I am importing something that I don't use?
13:24:26 <Cale> :t \x ys -> fmap and . sequence . map (filter (== x)) $ ys
13:24:27 <lambdabot> Bool -> [[Bool]] -> [Bool]
13:24:31 <Cale> er
13:24:38 <Cale> :t \x ys -> fmap and . sequence . map (filter ((== x) . fst)) $ ys
13:24:39 <lambdabot>     Couldn't match expected type `Bool' against inferred type `(a, b)'
13:24:40 <lambdabot>     In the second argument of `(.)', namely `fst'
13:24:40 <lambdabot>     In the first argument of `filter', namely `((== x) . fst)'
13:24:43 <Cale> hmm
13:25:16 <Cale> oh right :)
13:25:28 <Cale> :t \x ys -> fmap and . sequence . map (map snd . filter ((== x) . fst)) $ ys
13:25:29 <lambdabot> forall a. (Eq a) => a -> [[(a, Bool)]] -> [Bool]
13:25:42 <jlouis> iaefai: -fwarn-unused-imports
13:25:42 <Cale> :t \x ys -> fmap and . sequence . map snd . filter ((== x) . fst) $ ys
13:25:43 <lambdabot> forall (f :: * -> *) a. (Functor f, Monad f, Eq a) => a -> [(a, f Bool)] -> f Bool
13:25:49 <Cale> there we are :)
13:25:50 <jlouis> iaefai: see also -Wall
13:26:01 <Cale> :t \x ys -> and . sequence . map snd . filter ((== x) . fst) $ ys
13:26:02 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[a]'
13:26:02 <lambdabot>       Expected type: [Bool]
13:26:02 <lambdabot>       Inferred type: [[a]]
13:26:06 * hackagebot upload: HaskellForMaths 0.2.0 - Combinatorics, group theory, commutative algebra, non-commutative algebra (DavidAmos)
13:26:24 <Cale> :t \x ys -> and . map snd . filter ((== x) . fst) $ ys
13:26:25 <lambdabot> forall a. (Eq a) => a -> [(a, Bool)] -> Bool
13:26:39 <Cale> eliminated the Maybe
13:26:57 <iaefai> jlouis: Can I have that be done in cabal?
13:27:23 <Cale> (I like how the typechecker means that I don't have to use my brain while transforming code ;)
13:27:24 <mpwd> Cale:  Well, I know this is clumsy, but I need to handle negated propositions specially
13:27:51 <jlouis> iaefai: I do not have enough cabal-fu to answer that question, unfortunately
13:28:01 <iaefai> ok
13:28:55 <iaefai> ghc-options:  seems to be it
13:29:26 <Cale> mpwd: I'm not sure what you mean by that...
13:29:29 <osslin> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4953#a4953 I wan't to write properties to this function for quickcheck, I have one property which is: lookNothing a b = look a b = Nothing. Then I need one property for the "Just y" case, how do I do that?
13:30:13 <mpwd> Cale:  Well, so ys has type [Prop p] where data Prop p = P p | Neg (Prop p)
13:30:30 <Cale> osslin: I don't understand that property
13:30:56 <Cale> osslin: *surely* look a b is not always going to be Nothing for all values of a and b
13:31:12 <Cale> mpwd: ah
13:31:18 <osslin> Cale, okey, maybe I'm wrong but I want 2 sub properties and then one property that checks both
13:31:26 <mpwd> Cale: My list a partial truth assignment ...I want to push negations through...
13:31:41 <Cale> osslin: Perhaps you really want a property which says that  look x [] == Nothing ?
13:31:46 <mpwd> *My list is
13:32:09 <osslin> Cale: good point
13:32:15 <Cale> osslin: (though the code already says that directly, so it's a silly test to write)
13:33:26 <osslin> But how can I pair up the Nothing test with the Just test?
13:33:52 <osslin> In the exercise it says that I should write these 2 properties, then write a third that combines them
13:33:53 <Cale> osslin: I guess you could && them together, but there's no need for that.
13:33:57 <Cale> oh, okay
13:34:48 <Cale> osslin: You'll have perhaps  lookNothing :: Integer -> Bool; lookNothing x = look x [] == Nothing
13:35:28 <Cale> and then a different property (whose result is Bool) for the Just path
13:35:34 <EnglishGent> @hoogle a -> IO a
13:35:34 <lambdabot> Control.Exception evaluate :: a -> IO a
13:35:34 <lambdabot> Control.OldException evaluate :: a -> IO a
13:35:34 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
13:35:50 <Cale> osslin: You could also write something a little more comprehensive
13:36:57 <Cale> osslin: Oh, you should probably know... many of the tests in QuickCheck are Property instead of Bool
13:37:38 <Cale> osslin: Property is like Bool, but somewhat richer in that it has some capacity to explain to QuickCheck its reason for failing, in the case that there's something like ==>  for restricting testcases.
13:37:40 <osslin> yes, I discovered that a few days ago, when I added conditions to a test
13:38:01 <Cale> The equivalent of && for Property values is .&.
13:38:58 <Cale> So you could write something like  lookNothing :: Integer -> [(Integer, Integer)] -> Property; lookNothing x xs = x `notElem` map fst xs ==> look x xs == Nothing
13:41:12 <Cale> The test for lookJust will be very similar then
13:41:19 <osslin> Okey, but how do I match with Just y?
13:41:31 <Cale> Well, we could have used isNothing/isJust
13:41:34 <osslin> I mean what will I put as y?
13:41:39 <Cale> But you can also just write  /= Nothing
13:41:44 <osslin> okey
13:41:54 <kmc> @src Property
13:41:55 <lambdabot> Source not found. You type like i drive.
13:42:06 <osslin> So I rather match against /= Nothing, at least in this case since I only have 2 options?
13:42:09 <Vulpyne> I bet lambdabot is a great driver.
13:42:13 <osslin> then against Just?
13:42:19 <kmc> @vixen are you a good driver?
13:42:19 <lambdabot> thanks, i do my best to be good
13:42:38 <Cale> osslin: Yeah, I suppose.
13:42:40 <osslin> I think the problem is that I don't understand what Just means
13:42:45 <Cale> osslin: Oh!
13:42:53 <Raevel> why does (/= Nothing) have the type Eq a => Maybe a -> Bool and not Maybe a -> Bool? :-o
13:42:57 <Cale> osslin: What languages are you familiar with?
13:43:09 <monochrom> Because /= is a method of Eq
13:43:16 <Cale> Raevel: because the instance of Eq for Maybe a depends on an instance of Eq for a
13:43:23 <osslin> c,c++,c#,java
13:43:29 <tommd> @hoogle isNothing
13:43:30 <lambdabot> Data.Maybe isNothing :: Maybe a -> Bool
13:43:36 <tommd> You can use that, if you would like.
13:43:39 <Raevel> goodie
13:44:04 <tommd> But you should still work toward understanding typeclasses and get the answer to your above question.
13:44:26 <Cale> osslin: Okay, so you're familiar probably with the problem in those languages with writing a function which sometimes has no result, and sometimes has a result. When the result is supposed to be something like a positive integer, sometimes you can get away with returning -1 for failure
13:44:40 <Cale> osslin: But it's really hacky and there are a million different conventions
13:44:59 <opqdonut> and worst of all, you can accidentally pass the -1 onwards
13:45:03 <Cale> osslin: Sometimes you can get around the problem by returning a pointer which is NULL in the case that there's no result.
13:45:09 <opqdonut> to something that expects a proper value
13:45:37 <osslin> Cale: Isn't exceptions used for things like that in o-o?
13:45:59 <opqdonut> yeah, Maybe is actually somewhat like exceptions
13:46:02 <Cale> osslin: Or yes, you can throw an exception and hope that whoever calls your function is smart enough to wrap it in a try/catch
13:46:09 <opqdonut> especially the Maybe monad
13:46:19 <kmc> exceptions are not especially related to o-o
13:46:20 <Cale> osslin: So Maybe is a generic solution to this issue.
13:46:21 <tensorpudding> @src isNothing
13:46:21 <lambdabot> isNothing Nothing = True
13:46:22 <lambdabot> isNothing _       = False
13:46:26 <kmc> but yes they are often found together
13:46:41 <lament> Maybe is not a replacement for exceptions...
13:46:58 <Cale> osslin: If t is any type, then the values of type Maybe t are the value Nothing, and for each value x of type t, the value Just x
13:47:18 <Cale> osslin: So 'Just' is used to signal success, and 'Nothing' is used to signal failure.
13:47:32 <Cale> osslin: and Just is applied to whatever value the function succeeds with.
13:48:15 <Cale> osslin: When whoever calls the function and gets a result of type Maybe t, they must pattern match away the Nothing/Just in order to use the value.
13:48:22 <Cale> (or use another function which does it for them)
13:48:47 <osslin> I see
13:48:49 <Cale> So it's like exceptions for this use-case, but it makes it a little harder to forget to catch the exception.
13:49:00 <kmc> Maybe is more a replacement for Java's "null" and the like.  It avoids the disaster in Java, where anything can be "null" at any time.  You know from the type whether "Nothing" is allowed.  And you have this thing called the "Maybe monad" which propagates Nothings, so you don't have the other Java problem where every other line of code is "if (x == null) return null;"
13:50:08 <Cale> The fact that Maybe is a monad just means that there are some handy functions available for propagating failure, for the common case that you have a bunch of operations and you need them all to succeed or else the whole thing ought to fail.
13:50:15 <kmc> > do { x <- Just 3; y <- Nothing; z <- Just 4; return (x+y+z) }
13:50:16 <lambdabot>   Nothing
13:50:27 <kmc> > do { x <- Just 3; y <- Just 2; z <- Just 4; return (x+y+z) }
13:50:28 <lambdabot>   Just 9
13:50:43 <Cale> and yeah, that you can then use do-notation with it :)
13:51:09 <Baughn> > do { X <- Just 3; y <- Nothing; z <- Just 4; return (x+z) }
13:51:10 <lambdabot>   Not in scope: data constructor `X'
13:51:16 <Baughn> > do { x <- Just 3; y <- Nothing; z <- Just 4; return (x+z) }
13:51:17 <lambdabot>   Nothing
13:51:22 <Cale> It's rather handy in the case of having a chain of lookups
13:51:36 <kmc> > sequence [Just 3, Nothing, Just 5]
13:51:37 <lambdabot>   Nothing
13:51:40 <kmc> > sequence [Just 3, Just 4, Just 5]
13:51:40 <lambdabot>   Just [3,4,5]
13:51:41 <Twey> But annoying if you want to tell which one failed, afterwards.
13:51:43 <Cale> Where you look something up in one place, and then you need to look the result up in some other structure, and so on.
13:51:49 <Cale> Right.
13:52:05 * kmc <3 functors
13:52:08 * Twey wishes Data.Map were in an arbitrary monad.
13:52:11 <Guest79539> osslin: I'm reading "Learn you a haskell for great good" and it's got a very good chapter on typeclasses. I come from almost exactly the same programming background as you and I
13:52:18 <Twey> Or MonadPlus, rather.
13:52:19 <Cale> If you need the behaviour to be different for each point of failue, you might as well use case
13:52:27 <Cale> failure*
13:52:30 <Guest79539> have found it very amenable to my thought patterns
13:52:33 <kmc> :t maybe
13:52:34 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:52:44 <Twey> Cale: It's nice to be able to do a long, flat sequence of lookups, and then just case on the result
13:52:51 <kmc> :t maybe mzero return
13:52:52 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Maybe a -> m a
13:52:54 <Twey> Rather than nesting cases twenty levels deep
13:53:02 <Guest79539> Speaking of, what's the opinion of the advanced smartypantses in this room on "learn you a haskell"?
13:53:17 <osslin> Guest17379 Okey, I might get that book then :)
13:53:19 <kmc> Guest79539, the name annoys me, otherwise i think it's pretty good, but not complete yet
13:53:27 <donri> "learn you a haskell" is a great starting place.
13:53:45 <Twey> The whole thing kind of annoys me :þ
13:53:46 <Cale> Twey: You can also apply  maybe (Left "foo") Right  to each lookup :)
13:53:48 <tommd1> You learn a Haskell
13:54:02 <Twey> And it doesn't have the sort of real-world coverage that RWH has
13:54:02 <Guest79539> it made me happy :)
13:54:03 <Cale> Twey: and then use the Either monad instead :)
13:54:09 <Twey> Cale: Again, twenty levels deep :þ
13:54:13 * hackagebot upload: EventSocket 0.1 - Interfaces with FreeSwitch Event Socket. (DavidAustin)
13:54:13 <donri> that's why it's a starting place
13:54:15 <danderson> Could I have an opinion on a point of style? For practice, I came up with 3 different implementations of a function, but my untrained eyes don't know which is the most idiomatic.
13:54:18 <danderson> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4954#a4954
13:54:19 <osslin> I have also been suggested "Haskell The craft of functional programming"
13:54:20 <Twey> Yeah.  That's nice, apart from the Error constraint.
13:54:35 <Twey> osslin: That book bored the pants off of me
13:54:35 <Cale> Twey: The Error constraint is just an artefact of mtl.
13:54:46 <Twey> Cale: But mtl is everywhere.  :-\
13:54:46 <kmc> danderson, tbh i don't think it matters much
13:54:49 <kmc> they're all pretty clear
13:54:56 <kmc> but i'd go with #3
13:55:10 <kmc> in fact using <$> instead of liftM
13:55:15 <kmc> (from Control.Applicative)
13:55:22 <Cale> Twey: yeah, it's somewhat unfortunate
13:55:33 <Guest79539> It makes me a sad panda that I can't seem to find a really in-depth, FREE (as in beer) haskell book
13:55:36 <danderson> kmc: any particular reason to use <$> instead of liftM?
13:55:42 <Twey> danderson: I'd do (! n) . dataRegs <$> get
13:55:43 <Guest79539> i have no moneys :_( and no credit card or paypals
13:55:51 <kmc> danderson, just looks
13:55:53 <Vulpyne> Guest17379: You don't consider Real World Haskel one?
13:55:53 <Twey> @where rwh
13:55:53 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
13:55:57 <Guest79539> or maybe i fail at searching
13:55:59 <Twey> Like that one?
13:56:00 <Guest79539> yeah?
13:56:15 <Guest79539> realworldhaskell, hmmm... *goes to browse*
13:56:24 <kmc> danderson, if you want to manipulate record fields from within a state monad, look at three hackage packages: fclabels, lenses, data-accessor
13:56:25 <Twey> danderson: Neater, shorter, less brackets
13:56:28 <kmc> they all do about the same thing
13:56:33 <Vulpyne> It's also available in dead trees.
13:56:37 <kmc> and what they do is much nicer than the built-in record syntax, especially for updates
13:56:39 <Heffalump> Guest79539: also "learn you a haskell"
13:56:49 <Guest79539> oh neat!
13:56:49 <danderson> Twey: clearly I'm not yet sure where to put parens :) Thanks.
13:56:50 <kmc> RWH is very good
13:56:52 <Guest79539> this looks really really good
13:57:13 <Guest79539> yeah i'm working through "learn you"
13:57:15 <Guest79539> i'm almost done
13:57:23 <Guest79539> well almost done what he's written so far
13:57:41 <danderson> kmc: interesting, although combining too much goodness from different places may lead to my head exploding at this stage :)
13:57:53 <danderson> kmc: thanks for the advice!
13:57:57 <kmc> :)
13:58:21 <Guest79539> danderson: head explosion is the goal!
13:58:41 <Guest79539> you wouldn't just want to learn _yet another_ C would you?
13:59:18 <danderson> (I already have a todo to put a WriterT and maybe STM into the M68 type, but I need to get a bit of grounding in the basics before I start hitting on monad transformers
13:59:50 <EnglishGent> @hoogle (Monad m) => (a -> b -> c) -> (a -> m b -> m c)
13:59:51 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:59:51 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
13:59:51 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
14:00:41 <monochrom> head-explode is desirable
14:00:52 <danderson> Guest79539: I'd rather increase skull pressure gradually and adapt, then I can have a long happy relationship with haskell, rather than a brief fling that ends in migraine :)
14:01:05 * EnglishGent 's head is exploding - battling monads :|
14:01:53 <Twey> EnglishGent: A monad is a type that allows you a) wrap it around a value using ‘return’ and b) add functions into it using >>=.
14:02:02 * Twey commits the monad-tutorial fallacy.
14:02:11 <danderson> EnglishGent: welcome to my brain about a week ago :) (not that I claim to be fully Enlightened yet, at least I'm no longer stumbling around in the dark)
14:02:16 <Baughn> Twey: Bad twey! No cookie!
14:02:20 <EnglishGent> lol!
14:02:23 <kmc> a monad is like a giant, angry gorilla
14:02:39 <Baughn> A monad is like a fluffy, warm thing. That is a giant angry gorilla.
14:02:49 <Cale> A monad is like an algebraic theory.
14:02:52 <kmc> the (>>=) operator is like a banana, except it's filled with nails
14:02:56 <michaelcdever> That likes Ice Cream.
14:02:58 <Twey> Hahaha
14:03:00 <kmc> and the banana doesn't exist, it's only in your mind
14:03:01 <monochrom> An analogy is like using a vacuum cleaner on a monad.
14:03:01 <Baughn> Cale: Now you're just talking nonsense
14:03:08 <EnglishGent> I thought I'd figured out the basics - I'd even written some code that does useful stuff - only now I'm trying to convert some pure code I have to it's monadic equivalent ... and it's proving um - harder than I thought :|
14:03:20 <Twey> Monads are pure
14:03:31 <kmc> a monad is like a bad analogy for what monads are
14:03:37 <Baughn> Except IO, but IO is only accidentally a monad
14:03:39 <EnglishGent> ok by pure I mean 'no monadic' then :P
14:03:42 <kynky> a monad is like origami, its simple like a piece of paper, but you can do very clever and complex things with it (i thought)
14:03:48 <EnglishGent> it's IO I'm trying to do
14:03:48 <kmc> the "return" operator takes a simple concept and makes it confusing
14:03:56 <kmc> the (>>=) operator builds another layer of analogy
14:04:04 <Baughn> EnglishGent: Why convert it if the pure variant works fine?
14:04:06 * kmc should not be listened to
14:04:17 <danderson> kynky: it's also like a piece of paper in that you can make extremely painful cuts unless you're wearing gloves
14:04:21 * EnglishGent managed to write some search algorithms - now I want IO equivalents so I can do depth/breadth first searches of directory trees / chunks of the web / etc
14:04:26 <danderson> ... not sure where I'm going with that, but I'm sure it's somewhere
14:04:27 <monochrom> a monad is like a head waiting to explode
14:04:36 <kynky> danderson, :)
14:05:17 <kynky> monad only has 4 rules i thought
14:05:31 <Saizan_> 3
14:05:38 <monochrom> 1
14:05:44 <kmc> the rule of monads is that "return" and (>=>) form a monoid
14:05:46 <Saizan_> KABOOM
14:05:52 <monochrom> 0.9999
14:06:07 <dankna> kmc: highly amused at your analogy
14:06:18 <Baughn> A monad is like an applicative functor, but it can reach out and touch itself
14:06:41 <kmc> @check fix (\x -> (x / 10) + 0.9) == 1
14:06:45 <lambdabot>   mueval-core: Time limit exceeded
14:06:54 <monochrom> That is not what fix is for.
14:07:08 <kmc> fix is for fixing my code when it's broken, right?
14:07:19 <Baughn> Yes
14:07:37 <Baughn> It automatically fixes type errors.
14:07:45 <monochrom> fix is for http://www.vex.net/~trebla/haskell/fix.xhtml
14:08:07 <tensorpudding> > fix error
14:08:08 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
14:08:15 <FunctorSalad> kmc: category
14:08:20 <Guest79539> lol why is it "nub" instead of "unique"?
14:08:22 <kmc> fix is the Financial Information eXchange protocol
14:08:46 <tensorpudding> is that what xmoney uses?
14:08:51 <kmc> FunctorSalad, yeah, you're right
14:09:19 <jmcarthur_work> tensorpudding, best example of fix ever!
14:09:24 <FunctorSalad> Guest79539: means "essence" in I-forgot-what-language
14:09:40 <kmc> nubbin
14:09:46 <FunctorSalad> :o
14:09:53 <Zao> 'nub 1. The essence or core of something.'
14:09:56 <Guest79539> yeah i mean
14:09:58 <Guest79539> i know the meaning of the word
14:10:00 <Guest79539> and in that sense
14:10:04 <Guest79539> i like that its sort of intuitive
14:10:20 <Guest79539> a lot of functions in lisp, haskell etc... are cool like that because they describe things by what they do
14:10:21 <monochrom> People spend centuries arguing over names.
14:10:23 <Guest79539> "fold"
14:10:24 <Guest79539> but
14:10:27 <Guest79539> in this case
14:10:36 <Guest79539> i just think "unique" is more intuitive than "nub"
14:10:47 <Guest79539> its just funny
14:10:50 <Zao> unique sounds like a predicate, not a generator.
14:10:57 <Guest79539> oh true
14:11:02 <Guest79539> but then
14:11:04 <Guest79539> shouldn't it be
14:11:06 <Guest79539> "nubs"
14:11:07 <FunctorSalad> uniques ;)
14:11:09 <Guest79539> or couldn't i at least
14:11:09 <Guest79539> yeah
14:11:11 <Guest79539> "uniques"
14:11:14 <Twey> 22:09:24 < FunctorSalad> Guest79539: means "essence" in I-forgot-what-language
14:11:17 <Guest79539> meh
14:11:17 <Twey> English?  :þ
14:11:28 <monochrom> uniquify
14:11:29 <FunctorSalad> Twey: meh it's not my native language
14:11:30 <jmcarthur_work> uniqe
14:11:42 <Cale> If you have an adjunction whose left adjoint F takes, say, some set of values and builds a sort of "free" algebraic object from them, and whose right adjoint G forgets that algebraic structure, giving you just a set of elements, then the composite GF is a monad in Set, and the category of algebras of that monad recovers your algebraic structures.
14:12:00 <Twey> FunctorSalad: Well, the fact that all the other Prelude functions have English(-based) names should give it away.  :þ
14:12:07 <Guest79539> O_O'
14:12:10 <Guest79539> @ Cale
14:12:11 <monochrom> "uniquify" or "unique" sounds like to me this: take a list, return one single element from the list.
14:12:27 <English_Gent> beh
14:12:27 <jmcarthur_work> what about "uniqe"? ;)
14:12:32 <Guest79539> What about "uniques"?
14:12:34 <FunctorSalad> Twey: I don't see why there couldn't be one in another language
14:12:41 <FunctorSalad> "nub" just doesn't sound all that english to me
14:12:48 <Guest79539> if i can be honest
14:12:55 <Zao> Data.List.bun
14:12:59 <English_Gent> Baughn - becuase I need to be able to interleave search with IO - the pure variation works fine if you want to search e.g. game trees
14:13:06 <Guest79539> "nub" makes me think of a clitoris. It's not easy to concentrate on the problem at hand when... uh.
14:13:17 <monochrom> My point: Natural language being deliberately vague for good purposes, do not expect there exists a good name, short of writing out a full specification of five pages or something.
14:13:19 <English_Gent> but if you want to search directory trees / chunks of the web, etc it's no use at all
14:13:23 <kmc> @vixen what does "nub" make you think of?
14:13:24 <lambdabot> i dunno...
14:13:26 <Twey> FunctorSalad: Yeah, you're right.  It doesn't sound at all like a large number of English words like ‘club’ or ‘rub’ or ‘sub’ or ‘hub’ or… :þ
14:13:33 <Guest79539> "bub".
14:13:50 <Guest79539> There should be an esoteric programming language where every valid symbol rhymes with "hub"
14:13:54 <Guest79539> hub bub rub sub nub
14:13:54 <Twey> Haha
14:13:57 <FunctorSalad> Twey: I don't pronounce it like these.
14:14:04 <FunctorSalad> Twey: more like "newb"
14:14:12 <Cale> You can think of the monad GF as sort of encoding all the syntactic combinations of elements in your algebraic theory, and then the algebras of that monad as providing an interpretation which satisfies the laws of the theory.
14:14:14 <Twey> FunctorSalad: Aha — therein lies the rub.  You should.
14:14:17 <Twey> It rhymes with them.
14:14:34 <monochrom> Therein lies the rewb.
14:15:10 <English_Gent> Guest17379 - you could call in Gibberish -- make it platform-neutral - and then in the spirt of the early days of Java - you could have the campaign for 100% Gibberish
14:15:11 <English_Gent> :)
14:15:21 <Cale> I think we should call  snub = map head . group . sort
14:15:24 <dh___> good evening, I'm a newbie to haskell, can I ask a question?
14:15:30 <Cale> "sorted nub" ;)
14:15:34 <English_Gent> hi dh___ - and sure :)
14:15:34 <Guest79539> aaah!
14:15:40 <Cale> dh___: sure thing, that's what we're here for
14:15:51 <monochrom> "sorted nub" and "sort of newb"
14:16:07 <dh___> given a list [1,2,3,4,5], how do I swap elemnt at index 3 and 5 , to get 1 2 5 3 4 ?
14:16:18 <aavogt> you must make a new list
14:16:21 * ski . o O ( "snob" ? )
14:16:34 <dh___> do I need to delete first , then insert ?
14:16:39 <monochrom> "Hi, I am sort of noob. What is sorted nub?"
14:16:43 * Twey is reminded of the old ‘Bubb Rubb’ meme.
14:16:43 <Cale> dh___: There isn't an easy library function for it, because it's a bit of a sign that lists are the wrong datastructure for the job you're doing.
14:17:00 <Cale> dh___: But you can use splitAt to split the list up
14:17:16 <dh___> thanks cale, I guess you are right .
14:17:17 <Cale> dh___: and then rearrange the parts to write a swap function
14:17:22 <aavogt> @faq can haskell stop you from being horribly inefficient?
14:17:22 <lambdabot> The answer is: Yes! Haskell can do that.
14:17:32 <dino-> oh my, haddock gen for pandoc is a bear!
14:17:54 <Cale> (however, this does make the point that we *should* have a swap on Data.Sequence which we don't.
14:18:03 <Guest79539> How can i change my name...
14:18:11 <Cale> Guest79539: usually /nick foo
14:18:12 <Vulpyne> Type /nick Name_You_Want
14:18:18 <monochrom> /nick monocdrom
14:18:29 <dino-> Woo, completed without running system out of ram.
14:19:03 <tensorpudding> there is a limit to how long the names can be
14:19:24 <electrickoolaidt> i know :_(
14:19:25 <monochrom> Yeah. monocdrom is better.
14:19:32 <electrickoolaidt> my friend made me a shirt that read
14:19:32 <tensorpudding> freenode i think has 16 character limits
14:19:37 <electrickoolaidt> "The Electric Kool-Aid Turing Test"
14:19:45 <dino-> Guest17379: For a more persistent nick, freenode has docs: http://freenode.net/faq.shtml#userregistration
14:19:45 <electrickoolaidt> and had a picture of turing with rainbow eyes
14:19:50 <electrickoolaidt> and an afro
14:20:19 <FunctorSalad> Twey: why are you so vehemently arguing that I really ought to have recognized it as english? :o
14:20:35 <Twey> FunctorSalad: I'm not, it's just interesting to me that you didn't
14:20:38 <visualbasicgui> @ FunctorSalad & Twey: lol is this still going on
14:20:42 <monochrom> I guess someone should also make tshirts for "kool-aid student-t test" and other statistical tests.
14:20:50 <visualbasicgui> lololol
14:20:50 <Twey> Unload visualbasicgui
14:20:51 <Twey> :þ
14:20:51 <Vulpyne> TEKATT!
14:21:00 <visualbasicgui> Unload?
14:21:02 <English_Gent> oh - stuff before I was dc/d
14:21:13 <ghostman> fuck gentoo
14:21:15 <English_Gent> [22:05:27] <EnglishGent> I have a function:
14:21:15 <English_Gent> [22:05:51] <EnglishGent> expandwithfunction :: [a] -> (a -> [a]) -> [[a]]
14:21:15 <English_Gent> [22:06:23] <EnglishGent> expandwithfunction prefix fn = expandwithtails prefix (fn (last prefix))
14:21:15 <English_Gent> [22:06:48] <EnglishGent> where expandwithtails = map (\z -> (prefix ++ [z])) tails
14:21:15 <English_Gent> [22:07:20] <EnglishGent> I'm trying to wtite expandwithfunctionM :: m [a] -> (a -> [a]) -> m [[a]]
14:21:15 <English_Gent> [22:07:27] <EnglishGent> which should be it's counterpart
14:21:36 <Apocalisp> Is runState the catamorphism of State?
14:21:42 <ski> (visualbasicgui : when you joined, you were named `u', but you immediately changed name to `Guest79539' .. is there a reason for that ?)
14:21:51 <visualbasicgui> no i think its something that my client did
14:21:54 <poe> English_Gent hpaste it
14:21:58 <visualbasicgui> i'm using xchat
14:22:07 <Badger> because `u' is registered and protected, I'd imagine.
14:22:12 <visualbasicgui> yeah probably
14:22:12 <English_Gent> ok poe
14:22:18 <visualbasicgui> its my username on my computer because its easy to type :P
14:22:23 <visualbasicgui> and i'm the only one who uses it
14:22:26 <monochrom> hahahaha
14:22:27 <Cale> Apocalisp: State isn't a recursive type, so I guess so.
14:22:29 <English_Gent> ah - no, I cant - becuase currently my browser is dead - and refuses to restart
14:22:37 <Cale> Apocalisp: er...
14:22:42 <Badger> Twey: you nub! :)
14:22:42 <FunctorSalad> Apocalisp: well yes but trivially as Cale hinted at
14:22:43 * English_Gent sighs - software eh? it's just a source of trouble :|
14:22:46 <dh___> thanks cal. Is there a function to do a[i] = 5 ? that is : replace only 1 element?
14:22:59 <ski> English_Gent : isn't there an emacs command for hpasting ?
14:23:09 <Vulpyne> dh___: A list in Haskell is more like a linked list in C rather than an array.
14:23:10 <Cale> Apocalisp: actually, I think the catamorphism would be something which did  cata f (State g) = f g
14:23:15 <Twey> Badger: Hehe
14:23:30 <Vulpyne> dh___: To reach the last item, you need to traverse the whole list.
14:23:43 <Cale> Apocalisp: So it would have type  ((s -> (s,a)) -> b) -> State s a -> b
14:24:07 <Cale> Apocalisp: of course, that's just the CPS transform of runState
14:24:21 <FunctorSalad> oh, right
14:24:37 <Apocalisp> @type runState
14:24:38 <lambdabot> forall s a. State s a -> s -> (a, s)
14:24:54 <ghostman> fuck gentoo
14:25:35 <Chaze> suppose i have this definition:    data List a = Ø | List a (List a)
14:25:42 <Chaze> and this function:    tl  (List head tail) = tail
14:25:56 <Chaze> what's the signature of tl ?
14:26:04 <sjanssen> tl :: List a -> List a
14:26:17 <Apocalisp> @type (. runState)
14:26:18 <lambdabot> forall b s a. ((s -> (a, s)) -> b) -> State s a -> b
14:26:24 <Apocalisp> so that?
14:26:47 <Apocalisp> works for me :)
14:26:59 <Chaze> the type of Ø is (List a), as it works for any List
14:27:02 <English_Gent> ski - there might be - but if so I dont actually know that one!
14:27:02 <Vulpyne> English_Gent: Was expandwithfunction supposed to end with "tails"?
14:27:19 <Chaze> but if i do tl(2 :: Ø)  i get (List Integer)
14:27:21 <ghostman> fuck gentoo
14:27:23 <tensorpudding> what exactly is the ((->) r) anyway?
14:27:27 <Chaze> i'm wondering if that's right
14:27:28 <English_Gent> it's not desperately urgent - I can wait till I've fixed the browser
14:27:44 <Twey> tensorpudding: A function
14:27:44 <English_Gent> I'm busy writing a function to solve dh___'s problem right now anyway :)
14:27:44 <Vulpyne> English_Gent: I was trying to compile the version you pasted, and it seems to be incomplete.
14:27:48 <ghostman> fuck gentoo
14:27:49 <Twey> ((->) r) means (r ->)
14:28:07 <tensorpudding> okay
14:28:07 <Twey> So if m is (r ->), m a is (r -> a)
14:28:08 <sjanssen> Chaze: "l(2 :: Ø)" doesn't make any sense, that shouldn't compile
14:28:16 <Phyx-> ghostman: yes, we get it....
14:28:20 <ghostman> fuck gentoo
14:28:24 <tensorpudding> but what does it mean to define it as an instance of Functor?
14:28:26 <English_Gent> ah sorry - Vulpyne - [22:05:27] <EnglishGent> I have a function:
14:28:27 <English_Gent> [22:05:51] <EnglishGent> expandwithfunction :: [a] -> (a -> [a]) -> [[a]]
14:28:27 <English_Gent> [22:06:23] <EnglishGent> expandwithfunction prefix fn = expandwithtails prefix (fn (last prefix))
14:28:27 <English_Gent> [22:06:48] <EnglishGent> where expandwithtails = map (\z -> (prefix ++ [z])) tails
14:28:27 <English_Gent> [22:07:20] <EnglishGent> I'm trying to wtite expandwithfunctionM :: m [a] -> (a -> [a]) -> m [[a]]
14:28:27 <English_Gent> [22:07:27] <EnglishGent> which should be it's counterpart
14:28:28 <Twey> sjanssen: Why not?
14:28:30 <English_Gent> ah! sorry
14:28:34 <Chaze> sjanssen: well, assume i'm using :: to create a list
14:28:35 <ghostman> fuck gentoo
14:28:41 <Phyx-> ghostman: enough already
14:28:45 <ghostman> fuck gentoo
14:28:46 <Chaze> sjanssen: in fact, i've been using ：：
14:28:47 --- mode: ChanServ set +o Saizan
14:28:48 <FunctorSalad> tensorpudding: aka "hom functor"
14:28:52 --- mode: Saizan set +b *!*n=forth@*.hsi4.kabel-badenwuerttemberg.de
14:28:52 --- kick: ghostman was kicked by Saizan (Saizan)
14:28:54 <tensorpudding> hmm
14:28:57 --- mode: Saizan set -o Saizan
14:29:11 <FunctorSalad> tensorpudding: fmap f = (f.)
14:29:11 <tensorpudding> interesting
14:29:11 <Twey> sjanssen: type Ø = Int; let l = const () in l(2 :: Ø)
14:29:12 <English_Gent> Vulpyne - it should have been expandwithtails prefix tails = map (\z -> (prefix ++ [z])) tails
14:29:43 <sjanssen> Chaze: you're seeing numeric defaulting.  Haskell special cases number literals so that they default to a concrete type
14:29:51 <Vulpyne> English_Gent: Ah.
14:30:02 <ski> English_Gent : <http://haskell.org/haskellwiki/Hpaste.el>
14:30:03 <Chaze> ah alright
14:30:06 <Chaze> thanks
14:30:13 <ski> @where+ hpaste.el http://haskell.org/haskellwiki/Hpaste.el
14:30:14 <lambdabot> Done.
14:30:16 <sjanssen> Twey: your example is irrelevant if you look at the code Chaze pasted
14:30:30 <Twey> Ah, okay
14:31:02 <Twey> Yes, that doesn't make much sense.
14:31:15 <Twey> Ø isn't a type.  Ø is a value of type List a.
14:31:38 <English_Gent> ty ski :)
14:32:17 <sjanssen> Chaze: your list definition seems fairly OCaml-ish, coincedence?
14:32:20 <Vulpyne> English_Gent: expandwithfunctionM prefix fn = prefix >>= \p -> return $ expandwithtails p (fn (last p)) where expandwithtails prefix tails = map (\z -> (prefix ++ [z])) tails
14:32:48 <Vulpyne> Of course, that may not do what you want.
14:33:04 <English_Gent> thanks Vulpyne :)
14:33:19 <Vulpyne> It might be more useful if fn :: (a -> m [a])
14:33:46 <Cale> Hooray! I've triumphed over fontconfig's insane configuration... maybe!
14:33:54 <English_Gent> I'm quite open to suggestions Vulpyne :)
14:34:12 * English_Gent happy to make the code available to anyone who wants it - once it works of course! :)
14:34:15 <Vulpyne> I don't really know what you're trying to do.
14:35:18 <dh___> English_Gent is going to write a swap function. swap(a[i], a[j])
14:35:54 <ski> (sjanssen : why O'Caml-ish ?)
14:35:55 <English_Gent> it's part of the internals for pair of functions I wrote - I've got breadth-first & depth-first search functions bsearch :: a -> (a -> [a]) -> [[a]] & it's dsearch counterpart -- now I'm trying to produce versions where I can interleave search with IO - i.e. bsearchM :: a -> (a -> m [a]) -> m [[a]]
14:36:33 <English_Gent> as I'm not very experienced with monads at all yet I'm trying to convert all the bits of the inards one by one
14:36:56 <Vulpyne> Why do you want it to be monadic, out of curiosity?
14:38:02 <English_Gent> Vulpyne - becuase then you could interleave it with IO operations & use it to do (for example) searches of the web - feed it a url & have it search out from that page in depth/breadth first fashion
14:38:11 <English_Gent> or use it to search directory trees, etc :)
14:38:35 <Vulpyne> I guess that makes sense.
14:38:46 <blackdog> English_Gent: might it work just as well to have a lazily evaluated structure with an external IO function?
14:40:05 <blackdog> I can't immediately work out how to do it with the URL searching example, but my inability is not proof of impossibility:)
14:40:34 <English_Gent> well as I said I'm open to suggestions - but I confess I can see how that's possible either :)
14:41:09 <Cale> @let swap i j xs | i == j = xs  | i > j = swap j i xs  | otherwise = let (us,v:rs) = splitAt i xs; (vs,w:ws) = splitAt (j-i-1) rs in us ++ w:vs ++ v:ws
14:41:10 <lambdabot>  <local>:6:134:
14:41:10 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a...
14:41:18 <Cale> err...
14:41:31 <Cale> oh, was there already a swap?
14:41:46 <Twey> :t swap
14:41:47 <lambdabot> Not in scope: `swap'
14:41:50 <Twey> > swap
14:41:51 <lambdabot>   Not in scope: `swap'
14:41:56 * Twey shrugs.
14:41:59 <Cale> @let swap i j xs | i == j = xs  | i > j = swap j i xs  | otherwise = let (us,v:rs) = splitAt i xs; (vs,w:ws) = splitAt (j-i-1) rs in us ++ w:vs ++ v:ws
14:42:00 <lambdabot>  <local>:6:134:
14:42:00 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a...
14:42:07 <Cale> odd, that works in ghci :)
14:42:07 <dh___> hehe, thanks Cale, but it's seemed too complex as a swap
14:42:13 <Twey> Defaulting?
14:42:36 <Twey> dh___: Anyway, you should be using arrays :þ
14:42:49 <dh___> in python we can do a[i], a[j]= a[j], a[i]
14:43:01 <Cale> dh___: Lists are not meant for random access.
14:43:09 <dh___> yes, I'm reading array, is there a findIndex for Array ?
14:43:10 <Twey> dh___: That's because Python lists are a) not lists and b) mutable
14:43:13 <Vulpyne> let swaplist s e l = let { (sl,(i:restlist)) = splitAt s l; (middle,(j:endpart)) = splitAt (e - s) restlist } in sl ++ (j:middle) ++ (i:endpart)
14:43:17 <Vulpyne> > let swaplist s e l = let { (sl,(i:restlist)) = splitAt s l; (middle,(j:endpart)) = splitAt (e - s) restlist } in sl ++ (j:middle) ++ (i:endpart)
14:43:17 <Cale> dh___: Lists in Haskell are what you'd use loops for in Python.
14:43:18 <lambdabot>   not an expression: `let swaplist s e l = let { (sl,(i:restlist)) = splitAt ...
14:43:37 * Cale wonders what's going on.
14:44:39 <Cale> oh, I know!
14:44:43 <Cale> silly me
14:44:51 <Cale> I redefined (++), but forgot the infix decl
14:44:54 <Vulpyne> dh___: Anyway, that's how you could do a swap.
14:45:08 <Vulpyne> It's not too efficient with lists though.
14:45:08 <dh___> thanks Vlupyne.
14:45:30 <Cale> @let swap i j xs | i == j = xs  | i > j = swap j i xs  | otherwise = let (us,v:rs) = splitAt i xs; (vs,w:ws) = splitAt (j-i-1) rs in us ++ w:vs ++ v:ws
14:45:32 <lambdabot>  Defined.
14:45:35 <Cale> :)
14:45:42 <dh___> I would like to use Array, but there is no findIndex in Array, should I write one myself?
14:45:44 <Cale> > swap 0 3 [1..5]
14:45:45 <lambdabot>   [4,2,3,1,5]
14:45:55 <Vulpyne> Ahh, @let.
14:46:24 <English_Gent> not something I need right now - but is there a shuffle function in the standard libs?
14:46:33 * English_Gent can see it would mean monads again
14:46:44 <Vulpyne> Random numbers are IOlicious.
14:46:45 <dcolish> who do i need to speak with to get the cabal upload account access process speeded up?
14:46:59 <clarkb> dcolish: what do you need that for :)
14:47:18 <dcolish> i'd like to upload my imgur uploader
14:47:24 <Cale> dh___: anyway, that swap is less insane a definition if it's not squished onto one line :)
14:48:02 <dcoutts> dcolish: you emailed Ross, you just have to wait for him to get to it. He's generally pretty good, but he is a real human being, not a script :-)
14:48:08 <Cale> Vulpyne: Not necessarily IO, you just need to pass a PRNG state value around :)
14:48:25 <Vulpyne> Hmm, true.
14:48:26 <dh___> cale: do you mean it's bad if we can not write swap in one line? if so , I agree
14:48:36 <Vulpyne> I don't think I've ever done anything involving random numbers in my Haskell exploits so far.
14:48:53 <English_Gent> still means monads though - shuffle is clearly not deterministic!
14:48:57 <dcolish> dcoutts: I did a few weeks back, never heard and I didn't want to be rude and keep asking. i'll just wait
14:48:59 <Cale> dh___: I just mean that this definition looks better if it's *not* squished into one line.
14:49:09 <Vulpyne> English_Gent: If you know the seed, random numbers are deterministic. :)
14:49:17 <dcoutts> dcolish: oh ok, if it's been weeks then email Ross again
14:49:17 <opqdonut> well permutations is in the std list
14:49:24 <opqdonut> you can just index that with a random integer ;)
14:49:28 <Cale> dh___: But lambdabot requires that all definitions come in a single IRC message :)
14:49:46 <dcolish> dcoutts: cool thanks
14:49:54 <dh___> cale: ok, for such a simple function as swap, there should be an easy way to define it in one line. I'm an one liner
14:49:56 <English_Gent> psudo-random numbers are - random numbers arent by definition! (seriously - a decent implementation should prevent you from knowing the seed)
14:49:57 <Cale> dh___: Basically, you just split the list at two points, and concatenate the pieces back together the right way
14:50:10 <English_Gent> (except possibly for debugging purposes!)
14:50:36 <Cale> dh___: I suppose you could also write it like...
14:51:22 <dh___> Cale: it's unnatural to think swap as split .
14:51:30 <MoALTz> pseudo-random numbers flowing through your program, allowing you to get answers really do seem a kind-of magic
14:51:43 <Vulpyne> dh___: Well, if you think of lists as linked lists, it's more natural.
14:51:44 <Cale> dh___: It's unnatural to think of a list as having indices.
14:51:45 * English_Gent proposes adding 'mid from to list = take (to - from) (drop from list) to the librarys
14:51:57 * English_Gent thinking of string manipulation functions back from his 8 bit days!
14:51:58 <English_Gent> :)
14:52:09 <Cale> dh___: Anything which refers to "the nth element" of a list is probably at least a bit misguided.
14:52:28 <Vulpyne> Maybe it would help to think of lists as streams.
14:52:36 <Vulpyne> That you consume in sequence.
14:52:41 <English_Gent> Cale - why? (serious question) - Strings are lists - and at least with strings you want to do that all the time
14:53:07 <ski> English_Gent : example ?
14:53:33 <Cale> dh___: Of course, lists have that, but it's unnatural, like writing a loop which does something different just for its 6th iteration.
14:53:34 <dh___> cale: agree with your opion on list, I should use Array.
14:54:42 <Vulpyne> dh___: If it's a string, you could use ByteString.
14:55:24 <Cale> With Data.Sequence at least, splitting/replacement are inexpensive.
14:55:27 <English_Gent> ski - pulling bits out of ISO standard date-strings for example
14:55:31 <camio> This is probably a dumb question. How do I read in a file, make some computation on its contents, and write the result back to that same file?
14:55:33 <English_Gent> YYYY-MM-DD
14:55:51 <Cale> With immutable arrays, you'll be taking a copy, but otherwise it's fast to index.
14:56:36 <ski> English_Gent : i'll agree that one often want to remember certain positions in text. but i don't think *numeric* positions (that you can pull out of your hat, instead of having got a hold of them by traversing or searching) are that common
14:57:00 <Cale> :t Seq.index
14:57:01 <lambdabot> Couldn't find qualified module.
14:57:06 <English_Gent> a remarkable amount of real-world code means fiddling with strings - indeed it's the whole reason the-language-that-shall-not-be-named (Perl) became so popular :)
14:57:10 <Cale> hmm, I wonder if I have it imported...
14:57:33 <Cale> @undefine
14:57:35 * English_Gent makes the sign of the lambda to protect himself from having mentioned that -- other language
14:57:36 <Twey> English_Gent: Strings are not the optimal data type for serious string work
14:57:42 <Twey> Try Data.Text
14:57:58 <English_Gent> I shall have a look Twey :)
14:58:10 <Cale> @let swap i j s = update i (index j s) . update j (index i s) $ s
14:58:11 <lambdabot>  <local>:1:13: Not in scope: `update'
14:58:11 <lambdabot>  
14:58:11 <lambdabot>  <local>:1:36: Not in scope: `update'
14:58:23 <Cale> @let swap i j s = Seq.update i (Seq.index j s) . Seq.update j (Seq.index i s) $ s
14:58:23 <lambdabot>  <local>:1:55:
14:58:23 <lambdabot>      Couldn't match expected type `Int'
14:58:23 <lambdabot>             against in...
14:58:27 <Cale> er...
14:58:40 <Cale> oh, duh
14:58:44 <English_Gent> in all seriousness - I've already found that lazy bytestreams can give really *significant* speed increases (I gained a factor of slightely over 200 by switching some Haskell code from strings to lazy byte streams)
14:58:48 <Cale> @let swap i j s = Seq.update i (Seq.index s j) . Seq.update j (Seq.index s i) $ s
14:58:49 <lambdabot>  Defined.
14:58:54 <Cale> There we are :)
14:59:04 <English_Gent> but I'm still learning Haskell - I havent used it in anger that much yet
14:59:07 <dh___> cool, great thanks!!
14:59:12 <Vulpyne> That looks a lot nicer than the other list twiddling function.
14:59:12 <Cale> > swap 3 5 (Seq.fromList [1..10])
14:59:13 <lambdabot>   fromList [1,2,3,6,5,4,7,8,9,10]
15:00:00 <dh___> can we make the swap pointfree?
15:00:01 <ben0x539> lazy bytestrings?
15:00:03 <ben0x539> What is streams?
15:00:18 <Cale> dh___: Because you're indexing the list... it's a bit awkward.
15:00:24 <Cale> sequence rather
15:00:28 <jlouis> ben0x539: lazy bytestrings is an effective implementation of lists of bytes
15:00:38 <dh___> yes I now. I come from python, so everything is a list for me :)
15:00:42 <ben0x539> jlouis: I have heard of strings, but what is streams?
15:00:50 <English_Gent> see Data.ByteString.Lazy ben0x539 :)
15:01:13 <Cale> grr, I wish Seq.index used the opposite convention.
15:01:14 <ben0x539> right...
15:01:34 <jlouis> ben0x539: Stream is a bit ambiguous: http://www.haskell.org/hoogle/?hoogle=Stream
15:02:02 <Cale> @undefine
15:02:04 <dh___> @:i Seq
15:02:04 <lambdabot> Maybe you meant: . ? @ bf bid do ft id pl rc v wn
15:02:10 <Cale> :t let swap i j = do a <- (`Seq.index` i); b <- (`Seq.index` j); update i b . update j a in swap
15:02:11 <lambdabot> Not in scope: `update'
15:02:11 <lambdabot> Not in scope: `update'
15:02:19 <Cale> :t let swap i j = do a <- (`Seq.index` i); b <- (`Seq.index` j); Seq.update i b . Seq.update j a in swap
15:02:20 <lambdabot> forall a. Int -> Int -> Seq.Seq a -> Seq.Seq a
15:02:24 <Cale> whee
15:02:30 <Cale> @let swap i j = do a <- (`Seq.index` i); b <- (`Seq.index` j); Seq.update i b . Seq.update j a
15:02:31 <lambdabot>  Defined.
15:02:33 <dh___> :i Seq
15:02:43 <dh___> :t Seq.index
15:02:44 <lambdabot> forall a. Seq.Seq a -> Int -> a
15:03:01 <Cale> > swap 3 5 (Seq.fromList [0..10])
15:03:02 <lambdabot>   fromList [0,1,2,5,4,3,6,7,8,9,10]
15:03:04 <jlouis> ben0x539: perhaps the canonical object is the Stream class defined in http://hackage.haskell.org/packages/archive/HTTP/4000.0.7/doc/html/Network-Stream.html .. at least for HTTP
15:03:24 * Twey notices that some people hate $
15:03:38 <lament> Give me your $ if you don't like it.
15:03:45 <Twey> Haha
15:03:46 <Cale> Twey: me?
15:04:02 <Twey> Cale: That was a perfect place to use $… is there a reason you didn't?
15:04:06 <Cale> I mostly only use $ when it's awkward to write the parens I'd have to
15:04:09 <Twey> I've seen a bunch of people do that, recently
15:04:39 <Cale> dh___: In case you're wondering what I did there, the monad is the function monad
15:05:01 <Cale> dh___: it supplies a parameter (in this case, the sequence) to each of the functions
15:05:25 <dh___> thanks, I know a little bit about monad.
15:05:44 <dh___> but I think monad is ,,, imperative style, and I like point free style :)
15:05:56 <ben0x539> IO Monad is imperative style
15:06:05 <dh___> I'm trying to find a point-free style.
15:06:05 <ben0x539> Other monads are crazy magician style
15:06:34 <ski> (imo s/function monad/environment monad/)
15:06:53 <monochrom> There is a way to be monadic and pointfree at the same time.
15:09:17 <poe> :t \i j -> ap (Seq.update i . (`Seq.index` j)) ((`Seq.index` j) >>= Seq.update j)
15:09:17 <lambdabot> forall a. Int -> Int -> Seq.Seq a -> Seq.Seq a
15:10:05 <ski> (ben0x539 : what, you call my `(ReaderT Resolution . StateT SnailState . StateT [Thread] . ContT ()) IO' crazy !?)
15:13:18 <Phyx-> why are video games so addictive :(
15:13:51 <dh___> Phyx: because you win,
15:13:55 <pantsman> it's your body's way of telling you that they are more important than work, friends, and your family
15:13:59 <Phyx-> dh___: lol
15:14:01 <dh___> and wining is our basic instinct.
15:14:21 <Phyx-> hmm.. so if i started winning at life, i'd enjoy it too?
15:14:25 <dh___> to get ride of it, play it again and again , until you  really hate that game.
15:14:28 <Phyx-> but how does one win at that one...
15:14:38 <ski> (s/wining/winning/ or s/wining/whining/ ?)
15:14:39 <Phyx-> dh___: doubt i'll ever hate MW2
15:14:45 <dh___> yes, of course.
15:14:57 <pantsman> play it until you hate it like this guy: http://www.geekologie.com/2009/11/wtf_was_that_boy_loses_his_coo.php
15:15:06 <camio> The reason can't be winning alone. I can easily invent a game that I'd always win at that wouldn't be addictive.
15:15:20 <dh___> I played Soul Calibur IV for more than 10,000 matchs, so I begin to hate it :)
15:15:54 <Phyx-> lol, btw, everyone seen this? http://abstrusegoose.com/strips/computer_science_major.PNG
15:16:11 <MoALTz> good games tend to have a mix of needing insight (so there is something to improve as a skill), and having randomness (so that there is something different about each session)
15:16:27 * MoALTz plays a lot of minesweeper on expert... recklessly
15:16:29 <Phyx-> and good stories
15:16:43 <MoALTz> something like chess can give good stories i guess :P
15:17:35 <Phyx-> chess?
15:17:46 <Phyx-> ok, I enjoy a good game of chess just as the next geek
15:17:47 <Phyx-> BUT
15:17:52 <Phyx-> I fail to see how it has a story
15:18:07 <Phyx-> :t fail
15:18:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
15:18:23 <monochrom> "Once upon a time, there were two kingdoms. One day, the white pony decides to come out to explore the world..."
15:18:40 <periodic> You can get stories of amazing matches in chess.  I think that's what he's saying.
15:18:53 <periodic> Games seem to be fun when they let you learn a pattern, then apply it in new ways to get rewards.
15:19:10 <monochrom> "He meets the black unicorn and they decide to chase after each other for five turns..."
15:19:41 <periodic> And Phyx-, I've seen that, and I thought of it when I read the rage-answer on Stack Overflow about parsing HTML with regular expressions.
15:19:49 <dcestari> hello all, I need to share some things between enumerations
15:20:04 <Vulpyne> Why does white only get ponies when black has unicorns?
15:20:08 <Phyx-> periodic: lol
15:20:27 <monochrom> (2 hours later) "So finally Polly the Pawn reaches the bottomline safely and becomes the new queen, and she lives with the king happily thereafter. THE END."
15:20:49 <dcestari> I have a 'data Exp = E + E | E - E | .... | Const Int | Var String' and 'data Pattern = ( P ) | P :: P | Const Int | Var String'
15:20:49 <Vulpyne> There could be some problem if the original queen has not been killed.
15:21:02 <dcestari> but I can't have both on Exp and Pattern
15:21:04 <periodic> Phyx-: I was thinking, someone didn't learn their automata and languages.
15:21:33 <monochrom> If there are more queens, we just get Chinese fairy tales rather than European fairy tales.
15:21:34 <Phyx-> periodic: lol
15:22:09 <periodic> One of my favorite chess stories was that Bobby Fischer game where he won without moving any pieces more than halfway across the board, except once when he immediately moved it back the next turn.
15:27:53 <koeien> go > chess
15:28:09 <skorpan> go > fish
15:28:27 <ivanm> go > stop
15:28:33 <dcestari> anyone using Happy around here?
15:30:17 * Phyx- goes to play HALO3 with some friends on live
15:31:04 <periodic> dcestari: Happy is the bottom-up parser generator for Haskell, right?
15:31:30 <dcestari> periodic: Is a Compiler-Compiler for Haskell
15:32:11 <sprcow> I have a complete novice IO question... is this the right place to ask?
15:32:42 <Saizan> sprcow: yup
15:32:44 <blackdog> sprcow: sure. if it's involved, there's a beginners@haskell.org list, but no-one's gonna yell at you for asking questions here.
15:33:03 <koeien> in fact, we love questions =)
15:33:09 <MyCatVerbs> sprcow: of course! We're all inveterate sinners, murderers, liars and thieves to the last.
15:33:24 <MyCatVerbs> sprcow: #haskell is where we hang out to help random passing newbies for the sake of improving our karma.
15:33:25 <Saizan> @paste -- if you need to show code
15:33:25 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
15:33:26 <monochrom> We are eaters too.
15:33:45 <MyCatVerbs> monochrom: oh yes, mustn't forget the cannibalism.
15:33:50 <sprcow> Excellent.  You guys are great.
15:33:58 <periodic> dcestari: looks like it just generates a parser for a BNF grammar.  Looks like the syntax is a lot like YACC/bison.
15:34:39 <ivanm> koeien: we do? >_>
15:34:40 <ivanm> :p
15:34:42 <dcestari> periodic: the thing is I've never used yacc so I'm having a hard time with this
15:34:42 <sprcow> I wrote a merge and mergesort function in Haskell, and I am trying to figure out if there's any way to get them to output information as they work, to help visualize the way the sort works.
15:34:51 <periodic> haha, i love this from their documentation: "Like yacc, we include %% here, for no real reason."
15:34:53 <koeien> ivanm: as long as the questions are tasty :P
15:34:53 <dcestari> periodic: and there is not much documentation
15:35:06 <periodic> dcestari: upi
15:35:14 <periodic> dcestari: you're looking at http://www.haskell.org/happy/doc/html/sec-using.html ?
15:35:18 <ivanm> koeien: fair enough
15:35:21 <koeien> sprcow: sure. you can use Debug.Trace for this, among others
15:35:30 <dcestari> periodic: yeah
15:35:34 <periodic> dcestari: you should also probably try to get an idea of how a bottom-up parser works and how a context-free grammar is formed...
15:35:44 <periodic> dcestari: the bison documentation actually might help a lot
15:35:53 <dcestari> periodic: bison, thanks
15:36:04 <periodic> http://www.gnu.org/software/bison/manual/html_node/index.html
15:36:27 <periodic> the concepts and examples sections might explain a lot.
15:37:59 <periodic> dcestari: Yeah, happy syntax looks almost exactly like YACC/bison syntax.  There is plenty of info online on using those venerable tools.
15:38:14 <dcestari> periodic: thank you
15:38:27 <periodic> No problem.  I just learned all that stuff in a compiler class I'm taking right now. :D
15:38:57 <periodic> I would have been TOTALLY lost 4 months ago writing a parser.
15:39:29 <periodic> Now I understand the difference between Parsec and Happy and what types of languages fit them best.
15:39:41 <blackdog> dcestari: it's also quite common to use a parser combinator library like Parsec
15:40:13 <nolrai_FG> If you import a type with(..) does it import the record accessors too?
15:40:14 <dcestari> blackdog: thanks, I saw it, but I need to use Happy, is for an small academic project
15:40:27 <Saizan> nolrai_FG: yes
15:40:34 <nolrai_FG> cool
15:41:03 <periodic> blackdog: I'm split on which one is easier to use.  I like the very explicit productions of Happy, but parsec feels closer to the code so it might be more flexible/extensible.
15:41:50 <periodic> I feel like if you have an LL(1) grammar then writing the parser in Parsec is fairly straight forward.  Otherwise it can turn into a mess of trys and manys and intercalations and what not.
15:43:09 <blackdog> periodic: Parsec is sometimes easier to fit into a build process, and (although it's not always useful) you can build new parsers at runtime.
15:43:31 <nolrai_FG> Many doesnt seem hard to use to me.
15:43:35 <blackdog> Happy is a bit more traditional. Nothing wrong with that though.
15:44:12 <sprcow> Can anyone point me to a simple example of use of Debug.trace?
15:44:30 <periodic> blackdog: I never thought about using parsec to dynamically build parsers.  I'm having trouble figuring out where that would be useful.  I guess if you had a grammar specification in a file.
15:45:02 <periodic> blackdog: I feel like it's just a difference between top down and bottom up.  People have been writing recursive-descent parsers like Parsec for a long time.  Just not as dynamically.
15:45:07 <nolrai_FG> Does ! at the end of a constructor mean something?
15:45:28 <nolrai_FG> sprcow: I find debug trace to be rather difficalt to use well.
15:45:30 <periodic> the shift-reduce / bottom-up parsers are just a bit more powerful and generally more efficient on many of the grammars we usually encounter.
15:45:51 <Saizan> sprcow: let d = trace <string to print when d is first evaluated> <value to be returned as d>
15:45:56 <periodic> I shouldn't say more powerful, just more efficient/straightforward.
15:46:07 <Saizan> sprcow: trace is a bit of an hack, useful only for debugging purpouses
15:47:53 <visualbasicgui> Um... again I'm running into some trouble trying to compose functions and so forth
15:48:07 <periodic> visualbasicgui: nice name.
15:48:13 <visualbasicgui> lol thanks
15:48:19 <Axman6> visualbasicgui: got some code you're having trouble with?
15:48:21 <visualbasicgui> here's the code:
15:48:29 <visualbasicgui> wordFrequency :: String -> Map.Map String Num
15:48:30 <visualbasicgui> wordFrequency = Map.fromListWith (+) $ map (\s -> (s, 1)) . words
15:48:48 <visualbasicgui> I want to split a string into words, then try to insert it into a map from string to int
15:48:55 <visualbasicgui> the key is the word
15:49:04 <visualbasicgui> and the value is 1, and i resolve collisions with (+)
15:49:06 <Axman6> :t  map (\s -> (s, 1)) . words
15:49:07 <lambdabot> forall t. (Num t) => String -> [(String, t)]
15:49:14 <dmwit> :t M.fromListWith
15:49:15 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> M.Map k a
15:49:33 <dmwit> oh
15:49:41 <dmwit> visualbasicgui: Why the ($)? =)
15:49:50 <Axman6> visualbasicgui: the type should be: Num a => String -> Map String a
15:50:14 <dmwit> Oh, yeah, and Num isn't a type, good catch.
15:50:19 <Axman6> :t  Map.fromListWith (+) $ map (\s -> (s, 1)) . words
15:50:20 <lambdabot> Couldn't find qualified module.
15:50:28 <Axman6> :t  M.fromListWith (+) $ map (\s -> (s, 1)) . words
15:50:29 <lambdabot>     Couldn't match expected type `(k, a)'
15:50:29 <lambdabot>            against inferred type `[(a1, t)]'
15:50:29 <lambdabot>     In the first argument of `(.)', namely `map (\ s -> (s, 1))'
15:50:35 <dmwit> :t M.fromListWith (+) . map (\s -> (s, 1)) . words
15:50:35 <visualbasicgui> oh yes i forgot to say, I'm importing Data.Map as Map
15:50:36 <lambdabot> forall a. (Num a) => String -> M.Map String a
15:50:45 <visualbasicgui> what does forall mean?
15:50:45 <dmwit> Axman6: With our powers combined...!
15:50:53 <Axman6> we are...
15:50:55 <dmwit> visualbasicgui: It's noise, for now.
15:50:57 <Axman6> um
15:51:07 <dmwit> visualbasicgui: Later, it can be used for higher-rank types.
15:51:15 <Axman6> Captain Slow Haskell Help!
15:51:24 <periodic> visualbasicgui: It's basically saying "for all types a, such that a is of class Num"
15:51:27 <reltuk> I use ($) when I want (.) sometimes too...
15:51:47 <visualbasicgui> hmmm yes yes
15:51:51 <visualbasicgui> dmwit's advice was best
15:51:56 <dmwit> visualbasicgui: It is just a syntactic place to say where the type variable "a" came from.
15:52:08 <visualbasicgui> also I should have declared the type as wordFrequency :: (Num a) => String -> Map.Map String a
15:52:21 <visualbasicgui> yes I confused $ with .
15:52:28 <visualbasicgui> *shame*
15:53:07 <Axman6> ohy right, not i get why it didn't work. i missed the (+) the first time i read it
15:53:34 <visualbasicgui> :)
15:54:03 <visualbasicgui> function composition with . and partial application are beauties!
15:54:25 <dmwit> yes!
15:55:29 <heatsink> I'm writing FFI code that uses FILE *parameters.  Importing and using stdout from stdio.h crashes my code.  However, if I use fdopen to create my own FILE*, it works fine.  What gives?
15:55:35 <dmwit> Or rather, function composition and partial application are normal, and languages that don't allow them are ugly!
15:55:45 <heatsink> heh
15:56:31 <Axman6> hmm, i wonder if you could emulate currying with blocks in C on OS X
15:57:04 <Axman6> like, have functions which return blocks taking the next arg, which keep doing that until you get to your value
15:57:16 <Axman6> should make map quite easy to emulate
15:58:05 <Axman6> (and apple basically already offers a parallel map function, using grand central dispatch)
15:58:30 <dmwit> heatsink: Well, at least here, stdin and stdout are #define'd, and the FFI is known to do bad things with #defines.  Perhaps that's your problem?
15:59:44 <heatsink> Hmm.  If that's the problem, maybe using a C function to get the value will help.
16:00:23 <dmwit> That's the standard workaround, yeah.
16:00:43 <dmwit> You might also want to look at the X11 library on hackage, which imports a huge list of #define'd names, to see how they do it.
16:00:53 * hackagebot upload: HSHHelpers 0.20 - Convenience functions that use HSH, instances for HSH. (ThomasHartman)
16:01:03 <heatsink> ok
16:01:19 <dmwit> ?hackage HSH
16:01:19 <lambdabot> http://hackage.haskell.org/package/HSH
16:05:53 <heatsink> Oh, I was doing something stupid.
16:06:00 <heatsink> I can only import the address of a C global variable.
16:06:31 <Zao> FILE* p = &stdout; // suchlike fault?
16:06:43 <heatsink> yes
16:06:46 <leimy> wow... so my trying to fix a lazy leak in a Haskell program continues
16:06:58 <leimy> the source of my leaks now is some Integer inside System.Timeout
16:07:13 * leimy is tres-frustrated
16:07:14 <leimy> :-)
16:08:06 <Axman6> report a bug
16:08:12 <dmwit> "tres" doesn't look like English!
16:08:19 <leimy> it's not
16:08:27 <dmwit> Hmm... in that case, "frustrated" doesn't look like French!
16:08:31 <dmwit> ;-)
16:09:08 <leimy> looking at the source shows no Integers there.
16:09:31 <leimy> I never used Integer either though, so I'm wondering where it's coming from.
16:09:51 <Axman6> :o
16:10:16 <leimy> yeah
16:10:24 <leimy> If I grep my code for Integer, it's not there.
16:10:32 <dmwit> That means nothing.
16:10:36 <dmwit> Num a => a -- defaults to Integer
16:10:41 <Cale> Integer is the default numeric type
16:10:52 <leimy> Yeah I just realized something
16:10:58 <leimy> I wasn't explicit about my timeout variable
16:11:01 <leimy>  /constant
16:11:03 <Cale> However, it is a strict type.
16:11:03 <leimy> :-)
16:11:22 <Cale> (Int is not any stricter than it, at least)
16:11:25 <leimy> Cale: right but the evaluation of it is not strict in System.Timeout
16:11:42 <leimy> Integer is boxed.
16:11:54 <Cale> Well, like any value of kind *, yes
16:12:09 <Cale> But it's not like a lazy sequence of bits or something :)
16:12:53 <Cale> You can accumulate a large Integer expression, but the moment you evaluate it, it all gets evaluated.
16:12:54 <ben0x539> What is the kind of unboxed types?
16:13:01 <Cale> #
16:13:08 <ben0x539> ... that makes sense.
16:13:27 <dmwit> Well, they haven't got a box to cover their corners... they're sharp. ;-)
16:13:27 <jlouis> cute
16:13:54 <iaefai> Is it possible to have two patterns perform the same code without duplicating the code?
16:14:22 <Cale> iaefai: stick the code in a where and use case to pattern match
16:14:32 <iaefai> true enough
16:14:43 <Axman6> hmmmm
16:14:56 <Axman6> i wonder if (Just x)@(Just y) works
16:15:12 <dmwit> no
16:15:16 <Cale> Really?
16:15:21 <dmwit> only variable names may go to the left of @ signs
16:15:21 <Axman6> probably not if the two constructors were different an anyway
16:15:26 <nolrai_FG> Axman5: why?
16:15:26 <Cale> > let (Just x)@(Just y) = Just 6 in (x,y)
16:15:27 <lambdabot>   <no location info>: parse error on input `@'
16:15:39 <Cale> Oh, right
16:15:43 <Cale> <var>@<pat>
16:15:46 <dmwit> right
16:16:16 <Axman6> shame
16:17:11 <nolrai_FG> Anny ideas what no_CCS stands for? it seems to indecate that its a simple value, and not something computed, but the Acronym is opake to me.
16:17:30 <Cale> nolrai_FG: Context?
16:17:31 <Axman6> nolrai_FG: in what context
16:17:45 <nolrai_FG> stg code.
16:18:41 <Cale> http://hackage.haskell.org/trac/ghc/wiki/LightweightCCSCallStack -- might this be related?
16:18:55 <mauke> Card Captor Sakura
16:19:01 <Cale> haha
16:19:14 * Cale is going to reset his network, one sec.
16:19:16 <nolrai_FG> mauke: Heh
16:19:22 <iaefai> I wonder, is there anything (reasonable) that a language specifically advertising its 'OO' ability, that Haskell can't do with typeclasses and regular data types?
16:20:01 <heatsink> iaefai, dynamically checked downcasting
16:20:02 <ben0x539> Define an inheritance hierarchy without confusing the fuck out of me?
16:20:03 <mauke> @where oleg
16:20:03 <lambdabot> http://okmij.org/ftp/
16:20:13 <jlouis> mauke: :)
16:20:21 <heatsink> You can use Data.Dynamic for that, of cousre
16:20:23 <dankna> mauke: good show!
16:20:51 <Cale> So in that case, it'd stand for cost centre stack
16:21:03 <mauke> http://homepages.cwi.nl/~ralf/OOHaskell/
16:21:08 <nolrai_FG> Cale: that even almost makes sense.
16:24:53 <nolrai_FG> Cale: so if I am not woried about stack traceings I should be able to ignore it right?
16:25:40 <DrSyzygy> Is there a nice, illustrative example of using hylomorphisms that isn't fibonacci?
16:25:46 <DrSyzygy> I wanna give out fibonacci as homework...
16:26:13 <DrSyzygy> Something that builds a tree and not a list would be perfect.
16:26:27 <Cale> nolrai_FG: hopefully? :)
16:26:55 <nolrai_FG> Cale: :)
16:27:51 <periodic> You want to give out fibonacci?
16:27:59 <DrSyzygy> periodic: I was thinking about it, yeah.
16:28:19 <DrSyzygy> The programming exercises I have so far are a bit vicious, so I want there to be something easy around.
16:28:34 <nolrai_FG> That makes some sense.
16:28:34 <periodic> DrSyzygy: you were asking about non-fib exercises, so it seemed like mixed messages.
16:28:34 <DrSyzygy> And I can trust this crowd not to google the answer. (silly thing to say as a teacher, but in this case surprisingly enought rue)
16:28:50 <DrSyzygy> periodic: I want somethign to put as an example in the lecture notes text.
16:29:04 <DrSyzygy> One worked example, one homework question. And I already have fibonacci.
16:29:05 <periodic> DrSyzygy: you could always dress it up a bit so it doesn't look like fib.
16:29:29 <periodic> I loved this example when learning haskell: http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WordNumbers1/
16:29:30 <DrSyzygy> Doesn't solve that I want two easy and qualitative different examples. :-)
16:29:32 <Cale> Sum of divisors?
16:29:44 <ddarius> DrSyzygy: There are a few examples.
16:29:45 <Cale> hmm
16:29:58 <periodic> "f the integers from 1 to 999,999,999 are written as words, sorted alphabetically, and concatenated, what is the 51 billionth letter?"
16:30:02 <DrSyzygy> Cale: That's a good one if only the ana-bit gets set up right. I have one way of doing it that will overcount.
16:30:03 <periodic> :D
16:30:22 <periodic> I don't actually know what a hylomorphism is...
16:30:29 <Cale> DrSyzygy: Yeah, I just realised that might be a bit tricky :)
16:30:31 <DrSyzygy> periodic: Ah. :-)
16:30:43 <periodic> Let me remind myself.
16:30:54 <ddarius> DrSyzygy: There should be some decent examples in some of the earlier (none Squiggol) hylomorphism papers.
16:30:57 <DrSyzygy> periodic: catamorphism = fold. anamorphism = unfold. And hylomorphism = fold . unfold.
16:31:02 <periodic> oh.
16:31:08 <DrSyzygy> periodic: With more general datastructures than lists underlying it.
16:31:16 <periodic> I remember learning those terms but never learning it.
16:31:22 <periodic> er, remembering it.
16:31:29 <DrSyzygy> ddarius: I'm looking at bananas and lenses right now. Should go leaf through it for examples.
16:31:50 <Cale> heh, there's always factorial :P
16:32:00 <ddarius> DrSyzygy: That's a "squiggol" one.  Give me a sec.
16:32:07 <DrSyzygy> Cale: Oh right. Fibonacci and factorial might make for a decent pair. :-)
16:32:11 <Cale> heh
16:32:26 <lament> Haskell - the best language for all your factorial and fibonacci needs
16:32:27 <Cale> Just feels so wrong to give such a trivial example.
16:32:33 <m0nkfish> DrSyzygy, your pupils are wizards at the unseen university? :P
16:32:49 <DrSyzygy> m0nkfish: Nah. My pupils are _STUDENTS_ at UU. HUGE difference.
16:32:52 <leimy> So when using a timeout of -1, I no longer see the problem...
16:33:00 <leimy> that's because -1 means block forever.
16:33:02 <poe> drsyzygy maybe counting permutations with special properties, like derangements
16:33:10 <leimy> ... dang.
16:33:23 <Cale> leimy: What is this code that you're working on?
16:33:32 <DrSyzygy> Also, I want to be able to say, if cornered, "Yeah, here's how to do it", and I'm running low on time by now. :-)
16:34:08 <leimy> Cale: a service that polls some stuff, builds up some records, spews em on stdout like a fountain :-)
16:34:14 <leimy> it should run forever
16:34:18 <monochrom> dozents
16:34:20 <leimy> so it can't be leaky.
16:34:33 <leimy> I'm finding that Haskell was not a good choice, at least for me, to do this in. :-)
16:35:17 <Cale> When does it spew out the result for any given record?
16:36:26 <Cale> and what are you using System.Timeout to do? :)
16:37:31 <ddarius> DrSyzygy: "Sorting Morphisms" may be one of the papers I'm thinking of.
16:38:15 <Cale> leimy: I wouldn't mind taking a look to see if I can spot anything obvious.
16:39:19 <ddarius> The HYLO papers probably have tons of examples.
16:45:43 <DrSyzygy> Hmmmm.
16:45:49 <DrSyzygy> Does anyone care about metamorphisms?
16:46:07 <krainbolt> Moths are pretty cool, yeah.
16:46:15 <jasonmay> eh
16:46:16 <jasonmay> heh*
16:46:42 <DrSyzygy> krainbolt: Not metamorphosis. Metamorphisms. The ones that are the otehr way around from the hylomorphisms.
16:46:56 <DrSyzygy> It seems like cata . ana is cool, ana . cata kinda lame.
16:47:15 <krainbolt> You lost me at period.
16:47:44 <mauke> @src (.)
16:47:44 <lambdabot> (f . g) x = f (g x)
16:49:04 <leimy> Cale: I can't really share code unfortunately since it's for work... and I've been beating on this thing so much the last 2 weeks, that it's just ugly as hell.
16:49:34 <dolio> cata . ana sort of tells you something interesting about the language you're working in, where ana . cata doesn't.
16:50:26 <dolio> ana . cata :: Mu F -> Nu G
16:50:48 <dolio> Whereas cata . ana goes from A to B through Mu F = Nu F.
16:51:42 <DrSyzygy> dolio: My suspicion, pretty much.
16:51:46 <DrSyzygy> Thanks for confirming. :-)
16:51:57 <iaefai> Can one 'instance' keyword be used to define multiple functions right after the other in the typeclass?
16:52:20 <dmwit> iaefai: yes
16:52:26 <skorpan> can multiple be used?
16:52:28 <dmwit> iaefai: I didn't know it was possible to do it any other way.
16:52:49 <dmwit> In fact, I am now doubting that I understood the question properly.
16:53:38 <deech> Hi all I am having trouble calling a C function in the wireless-tools library. I have a paste of the bad code at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12204#a12204. Can anyone help?
16:54:39 <blackh> deech: The type needs to be IO CInt
16:55:01 <EvanCarroll> in haskell map is foldr, or foldl?
16:55:03 <blackh> If you want to make it pure, you need to write a wrapper that uses unsafePerformIO
16:55:23 <EvanCarroll> because the LYAH clearly implies foldr
16:55:24 <monochrom> map is foldr. in a strong sense it is so with all languages.
16:55:28 <deech> blackh: And to convert it to an IO Int I have to use fromIntegral, correct?
16:55:39 <EvanCarroll> monochrom: not with perl..
16:55:52 <leimy> deech: "return"
16:55:56 <blackh> deech: Yes, that's right
16:55:56 <EvanCarroll> at least, I don't think so.
16:56:09 <leimy> oh..
16:56:10 <leimy> yeah :-)
16:56:13 <leimy> CInt
16:56:43 <dmwit> deech: You need to list the object file with iw_get_kernel_we_version in your Haskell build line, too.
16:57:15 <EvanCarroll> monochrom: do you know this to be true? This isn't my forte but i'm interested and confused
16:57:29 <EvanCarroll> mauke: is perl's map foldr or foldl? and what is the typical?
16:57:32 <dmwit> deech: or library or whatever, of course
16:57:39 <monochrom> What does perl's "map" do? Does it lose the original list content?
16:57:39 <mauke> EvanCarroll: it's concatMap
16:57:58 <EvanCarroll> mauke: which is foldl? right?
16:58:00 <DrSyzygy> :t (***)
16:58:01 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
16:58:02 <mauke> huh?
16:58:04 <dmwit> EvanCarroll: In strict languages, foldl' is the standard.
16:58:09 <EvanCarroll> I don't know concatMap I'm just now reading about fold[lr]
16:58:18 <mauke> EvanCarroll: I don't understand the question
16:58:19 <dmwit> EvanCarroll: For example, "reduce" in Python is foldl'.
16:58:21 <deech> dmwit: i don't understand what you mean by that. so something like "ghci Haskell-Wireless.hs /usr/lib/libiw.a" ?
16:58:27 <mauke> also, it's more like concatMapM
16:58:35 <EvanCarroll> right, I thought map was always foldl, from what I'm reading
16:58:51 <mauke> what
16:58:56 <dmwit> deech: Yes, or maybe just "ghc Haskell-Wireless.hs -liw".  You should check the manual to be sure.
16:58:57 <EvanCarroll> map in perl is left-associative, and I think that is the norm for things colloqually called map
16:59:04 <mauke> how is map left associative?
16:59:13 <mauke> map doesn't associate at all
16:59:14 <EvanCarroll> perl -E'map say qw/foo bar baz/'
16:59:16 <kmc> @check \xs f -> map (f :: Int -> Int) (xs :: Int) == foldr ((:) . f) [] xs
16:59:16 <lambdabot>   Couldn't match expected type `[GHC.Types.Int]'
16:59:17 <deech> dmwit: That worked!
16:59:26 <EvanCarroll> it doesn't work the right hand side of the list provided, it works from the left.
16:59:34 <mauke> EvanCarroll: that's irrelevant
16:59:42 <deech> blackh: thanks for your help!
16:59:48 <iaefai> dmwit: What I mean is 'instance blah where   function; function; function' instead of instance blah where function; instance blah ...
16:59:48 <idnar> that doesn't really have anything to do with associativity
17:00:00 <dmwit> iaefai: Yes, that is the normal way.
17:00:07 <dmwit> i.e. the former is normal
17:00:23 <monochrom> Haskell's map works the left hand side too, and it is still foldr.
17:00:53 <EvanCarroll> so then what is the difference between foldl, and foldr?
17:01:06 <dmwit> iaefai: The latter doesn't even compile (here, at least).
17:01:13 <dolio> @src foldl
17:01:13 <lambdabot> foldl f z []     = z
17:01:14 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
17:01:15 <kmc> > foldr f z [a, b, c]
17:01:16 <lambdabot>   f a (f b (f c z))
17:01:18 <dolio> @src foldr
17:01:18 <lambdabot> foldr f z []     = z
17:01:19 <kmc> > foldl f z [a, b, c]
17:01:19 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:01:20 <lambdabot>   f (f (f z a) b) c
17:01:22 <EvanCarroll> The right fold, foldr works in a similar way to the left fold, only the accumulator eats up the values from the right.
17:01:37 <monochrom> Suppose you have an infinite list, infinite on the right hand side, finite on the left hand side. Now we do a map to it, then ask for just a few results from the left hand side. This shows that the left hand side is worked first.
17:01:43 <iaefai> dmwit: I did it not too long ago
17:01:53 <monochrom> > take 5 (map id (repeat True))
17:01:54 <lambdabot>   [True,True,True,True,True]
17:02:00 <dmwit> iaefai: I don't believe you.
17:02:04 <mauke> > foldl (\z x -> z ++ [x * 2]) [] [1 .. 4]
17:02:05 <lambdabot>   [2,4,6,8]
17:02:16 <iaefai> I can't say neigh, because it was long ago
17:02:20 <mauke> > foldr (\x z -> (x * 2) : z) [] [1 .. 4]
17:02:20 <monochrom> If haskell's map worked the right hand side first, there would be no hope this would terminate at all.
17:02:21 <lambdabot>   [2,4,6,8]
17:02:53 <dmwit> Haskell does both sides first.
17:03:13 <dmwit> > (map id [undefined, True, True, True]) !! 2
17:03:14 <lambdabot>   True
17:03:16 <idnar> qumap
17:03:20 <dmwit> see?
17:03:27 <dmwit> If Haskell did the left side first, that would be undefined.
17:03:34 <monochrom> Heh
17:03:35 <ksf> er no.
17:03:38 <dmwit> (Just trying to point out how absurd this argument is.)
17:03:52 <ksf> > id undefined
17:03:52 <dolio> Even foldr in ML does the left side first; it just also does the right side before letting you do anything else.
17:03:53 <lambdabot>   * Exception: Prelude.undefined
17:03:55 <EvanCarroll> mauke: you're just showing that you can achive the same effect with foldr/foldl, which i know.
17:03:55 <EvanCarroll> mauke: right?
17:03:59 <ksf> see? its still the same thing
17:04:07 <EvanCarroll> mauke: or are you trying to show something else with code that I don't know
17:04:24 <mauke> EvanCarroll: if you know that, how can you ask whether map is foldl or foldr?
17:04:37 <mauke> I mean, the results are the same
17:04:52 <EvanCarroll> they're only the same because the function has no side-effect though?
17:04:52 <ksf> > length [undefined, undefined]
17:04:53 <lambdabot>   2
17:04:56 <EvanCarroll> Is that what you're trying to say?
17:05:13 <idnar> how can map have side effects?
17:05:13 <ksf> it doesn't matter if length counts from left or right, it's always going to work.
17:05:15 <ben0x539> @src map
17:05:15 <lambdabot> map _ []     = []
17:05:15 <lambdabot> map f (x:xs) = f x : map f xs
17:05:17 <EvanCarroll> I mean in perl, you can easily demonstrate that map has to be foldl, which is what I thought., even if the effect can be achived both ways.
17:05:24 <ben0x539> That is clearly a right fold
17:05:31 <mauke> EvanCarroll: even if it had side effects, you could still sequence them the same
17:05:33 <dmwit> EvanCarroll: That's not map.
17:05:34 <idnar> oh, in perl
17:05:36 <dmwit> EvanCarroll: That's mapM.
17:05:49 <mauke> @src mapM
17:05:49 <lambdabot> mapM f as = sequence (map f as)
17:05:53 <dmwit> Asking whether mapM is l-to-r or r-to-l is a sensible question.
17:05:55 <mauke> ^
17:05:55 <EvanCarroll> idnar: in perl, this is legal: perl -E'map say, qw/foo bar baz/'; first foo, is put on STDOUT, then bar, then baz
17:06:05 <dmwit> Asking whether map is l-to-r or r-to-l is not a sensible question.
17:06:05 <reltuk> @type sequence
17:06:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:06:20 <mauke> @src sequence
17:06:20 <lambdabot> sequence []     = return []
17:06:20 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:06:20 <lambdabot> --OR
17:06:20 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
17:06:32 <mauke> so map is a foldr and sequence is a fodlr :-)
17:06:33 <ksf> > (map id [error "foo", error "bar", error "baz"]) !! 1
17:06:34 <lambdabot>   * Exception: bar
17:06:39 <reltuk> why does it have 2 sources?
17:06:58 <mauke> reltuk: why not?
17:07:01 <Cale> reltuk: because those are both possible implementations
17:07:01 <dmwit> The first one is for readability, the second one is for ?pl wankers.
17:07:06 <dmwit> ;-)
17:07:12 <Cale> The second is also for readability
17:07:19 <monochrom> Isn't it fun? mapM is still foldr, and its side effects are left-to-right.
17:07:20 <idnar> dmwit: pfft, since when does ?pl know foldr? :P
17:07:20 <EvanCarroll> if you had an array of database connections, and you called map to disconnect all of the connections, and return an array of the disconnection results, the ltr, or rtl would matter right?
17:07:25 <kmc> the pl version looks a lot like how you'd define map in terms of foldr
17:07:32 <EvanCarroll> or could matter
17:07:36 <kmc> :t mapM id
17:07:37 <lambdabot> forall (m :: * -> *) b. (Monad m) => [m b] -> m [b]
17:07:54 <ksf> monochrom, that's easy to explain, as no haskell function ever forces a value.
17:08:10 <ksf> it's all just abstract nonsense on top of abstract nonsense.
17:08:15 <Cale> The second version of sequence there emphasises the fact that you're replacing list structure with program structure.
17:08:26 <mauke> EvanCarroll: yes, the order of side effects matters, but you can sequence them left-to-right using foldr
17:08:40 <EvanCarroll> mauke: how?
17:08:45 <mauke> uh, see above?
17:08:51 <mauke> that's exactly what mapM does
17:09:06 <EvanCarroll> you can only sequence the output list, by switching the append to preprend or vise-versa, you can't sequence the side-effects
17:09:14 <ksf> EvanCarroll, it might be helpful to consider haskell to be a macro language that is used to generate sequential programs.
17:09:22 <dolio> In an effectful language, there are two different foldrs.
17:09:27 <m0nkfish> i don't understand sequence :[
17:09:36 <kmc> this will print "barfoo":  sequence $ reverse $ map putStr ["foo", "bar"]
17:09:36 <mauke> EvanCarroll: then how can mapM work?
17:09:43 <ksf> if you think you have an intuition about how stuff gets executed, you're wrong. there is no such intuition.
17:09:52 <kmc> :t map putStr
17:09:53 <lambdabot> [String] -> [IO ()]
17:09:53 <mmmdonuts> EvanCarroll: the point, I think, is that map only guarantees what the output will look like, not how it's achieved.  That's part of the point of purity - if you're interested in the order of side effects, then you're talking about something impure.
17:09:55 <kmc> :t mapM putStr
17:09:56 <lambdabot> [String] -> IO [()]
17:10:38 <dmwit> sequence [putStr "foo", putStrLn "bar", readLn >>= print] -- more interesting example, because it can't be obviously rewritten with mapM
17:10:55 <kmc> m0nkfish, sequence takes a list of actions and makes it an action yielding a list
17:11:13 <kmc> @src sequence
17:11:13 <EvanCarroll> can you print something to the screen from within a function in haskell?
17:11:13 <dmwit> m0nkfish: Can you articulate what you don't understand?
17:11:13 <lambdabot> sequence []     = return []
17:11:14 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:11:14 <lambdabot> --OR
17:11:14 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
17:11:27 <kmc> EvanCarroll, technically: you can make a function, which returns a "recipe" for printing to the screen
17:11:28 <EvanCarroll> like if X then print "foo" else print "bar" end
17:11:29 <dmwit> m0nkfish: Do you understand the behavior?  Do you understand the implementation?  Do you understand why we would want it?
17:11:38 <kmc> :t if True then print "foo" else print "bar"
17:11:39 <lambdabot> IO ()
17:11:45 <monochrom> ksf, dmwit: I agree with all of you. My way of saying "the question is absurd" or "the question is based on absurd premise" is by playing along with the premise and getting confusing, conflicting multiple answers. "Oh you are confused now? It is because your mental model is no good. Now you have no mental model!"
17:11:45 <kmc> EvanCarroll, that's not a function though
17:11:47 <kmc> it has no arguments
17:11:49 <kmc> it's just an IO-recipe
17:11:56 <dolio> "foldr f z (x:xs) = let g = f x in g (foldr f z xs)" is one, and the other is "foldr f z (x:xs) = let r = foldr f z xs in f x r".
17:12:08 <dolio> With identical base cases, of course.
17:12:11 <idnar> kmc: well, \x -> if x then print "foo" else print "bar" is a function
17:12:15 <m0nkfish> well i didn't understand what it did... but kmc has kind of cleared this up
17:12:18 <kmc> yes it is
17:12:23 <kmc> it's a pure function which produces an IO-recipe
17:12:32 <kmc> colloquially, an "impure function", but there's really no such thing
17:12:34 <ksf> mobit!
17:12:34 <EvanCarroll> kmc: i'm just saying if a function does that, then I'd be curious to know how mr processes a list of ["foo","bar","baz"]
17:12:43 <kmc> mr?
17:13:00 <EvanCarroll> just simply because the LYAH says map "gobbles from the right" and in perl it "gobbles from the left"
17:13:04 <ksf> :t map putStrLn ["foo","bar","baz"]
17:13:05 <lambdabot> [IO ()]
17:13:16 <kmc> EvanCarroll, that's a list of IO recipes, not an IO recipe
17:13:19 <ksf> :t sequence $ map putStrLn ["foo","bar","baz"]
17:13:20 <lambdabot> IO [()]
17:13:22 <kmc> sequence will turn it into one recipe
17:13:30 <ivanm> ksf: sequence_ would probably be better
17:13:34 <ben0x539> > sequence ["foo","bar","baz"]
17:13:34 <kmc> so it's sequence that matters for determining the side effect order
17:13:34 <ksf> yep
17:13:34 <lambdabot>   ["fbb","fba","fbz","fab","faa","faz","frb","fra","frz","obb","oba","obz","o...
17:13:35 <kmc> not map
17:13:37 <ben0x539> My mental model is no good
17:13:44 <mauke> EvanCarroll: well, perl's map is actually a C for loop, not a fold
17:13:49 <dmwit> ben0x539: different monad =)
17:13:51 <EvanCarroll> mauke: ah!
17:13:56 <EvanCarroll> mauke: that's what i'm looking for.
17:14:00 <mauke> what
17:14:02 <mauke> that's obvious
17:14:03 <ksf> ben0x539, wrong answer. you should have claimed wanting to work in Monad [a] all the time.
17:14:29 <EvanCarroll> mauke: so perl's map is misnomer
17:14:43 <ben0x539> ksf: My lack of ability to come up with an intuition for the list monad is a long-standing annoyance for me :(
17:14:47 <mauke> EvanCarroll: no
17:14:56 <EvanCarroll> mauke: how is that obvious? I've never looked at perl's map code, it accumulates variables into a list and returns them, sounds a lot like haskells map to me
17:15:01 <kmc> ben0x539, it's nondeterminism
17:15:12 <kmc> a function yields a list of "possible" results
17:15:16 <EvanCarroll> erg
17:15:18 <EvanCarroll> it doesn't accumulate
17:15:29 <monochrom> At the very beginning I already asked "what does perl's map do?" which would have settled the question but no one cared. Everybody likes to "discuss".
17:15:33 <idnar> EvanCarroll: the docs seem to say it does
17:15:36 <EvanCarroll> (doesn't make the accumulater editable from within the loop)
17:15:44 <idnar> oh
17:15:47 <idnar> well, anyway, "Evaluates the BLOCK or EXPR for each element of LIST (locally setting $_ to each element) and returns the list value composed of the results of each such evaluation."
17:15:48 <mauke> monochrom: well, I said it's like concatMapM
17:16:00 <Cale> ben0x539: are you okay with list comprehensions?
17:16:10 <monochrom> Yeah I saw that too. Other participants ignored it too.
17:16:21 <monochrom> People just so like to "discuss".
17:16:25 <ben0x539> Cale: After reading about them in a tutorial or other, I have never seen anyone use them.
17:16:29 <EvanCarroll> I'm just the clueless guy asking a question -- don't blame me ;(
17:16:31 <kmc> > [1,2,3] >>= \x -> [(4,x), (5,x)]
17:16:32 <lambdabot>   [(4,1),(5,1),(4,2),(5,2),(4,3),(5,3)]
17:16:53 <dmwit> > liftM2 (,) [1..3] [4,5]
17:16:54 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
17:16:54 <Cale> ben0x539: It's easy to forget that they exist.
17:16:55 <ben0x539> hm
17:16:57 <dmwit> whoops
17:17:05 <dmwit> > liftM2 (,) [4,5] [1..3]
17:17:06 <lambdabot>   [(4,1),(4,2),(4,3),(5,1),(5,2),(5,3)]
17:17:13 <Cale> ben0x539: But they're essentially the same thing as the list monad
17:17:16 <EvanCarroll> ok, so the answer is that perl's map is really not a haskell map which is implimented as a foldr.
17:17:20 <kmc> ben0x539, that's why (>>=) is (flip concatMap)
17:17:31 <EvanCarroll> mauke: could you describe the difference between concatMapM and map ?
17:17:55 <kmc> :t flip concatMap
17:17:56 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
17:17:59 <ben0x539> The concat part seems to keep throwing me off
17:18:23 <kmc> for each "possible" result in [a], you compute the possible values of the function for that *specific* result.  you get a list of lists, which you then combine
17:18:37 <dmwit> I've always thought (=<<) was a more natural function to look at than (>>=) anyway.
17:18:47 <dmwit> (=<<) :: (a -> m b) -> (m a -> m b)
17:18:54 <mauke> EvanCarroll: no, too obvious
17:18:54 <dmwit> It just lifts your function into a monad!
17:18:57 <dmwit> obvious as pie
17:19:00 <Cale> ben0x539: think of f =<< xs as choosing each element of xs and passing that to f to collect results, you get a list of all possibilities.
17:19:07 <kmc> > [(a,c) | a <- "ab", c <- "cd"]
17:19:08 <lambdabot>   [('a','c'),('a','d'),('b','c'),('b','d')]
17:19:13 <ben0x539> Right
17:19:16 <kmc> > do { a <- "ab"; c <- "cd"; return (a,c) }
17:19:17 <lambdabot>   [('a','c'),('a','d'),('b','c'),('b','d')]
17:19:21 <Cale> ben0x539: (and f as a function which produces a list of possibilities
17:20:01 <m0nkfish> is there a function that returns its input repeated n times in list form
17:20:07 <ben0x539> replicate
17:20:09 <dmwit> > replicate 5 'a'
17:20:10 <lambdabot>   "aaaaa"
17:20:12 <m0nkfish> ta :)
17:20:19 <kmc> > repeat 'a'
17:20:20 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
17:20:26 <dmwit> > "a" >> [1..5]
17:20:27 <lambdabot>   [1,2,3,4,5]
17:20:29 <dmwit> whoops
17:20:31 <ben0x539> > 'y' : replicate 10 'e' ++ 's'
17:20:32 <kmc> > 'w' : 'h' : repeat 'e'
17:20:32 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:20:32 <lambdabot>         against inferred ty...
17:20:32 <lambdabot>   "wheeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee...
17:20:37 <ben0x539> aw.
17:20:37 <dmwit> > [1..5] >> "a"
17:20:39 <lambdabot>   "aaaaa"
17:20:39 <tensorpudding> :t repeat
17:20:40 <lambdabot> forall a. a -> [a]
17:21:13 <kmc> > [1..5] >> "abc"
17:21:14 <lambdabot>   "abcabcabcabcabc"
17:21:20 <ben0x539> is repeat cycle . replicate or is replicate take n . repeat
17:21:34 <dmwit> no
17:21:37 <m0nkfish> @src (<-)
17:21:37 <lambdabot> Source not found. Wrong!  You cheating scum!
17:21:37 <kmc> @src repeat
17:21:37 <lambdabot> repeat x = xs where xs = x : xs
17:21:39 <m0nkfish> :(
17:21:41 <Cale> ben0x539: you mean cycle . return ?
17:21:49 <kmc> m0nkfish, heh
17:21:54 <ben0x539> I guess that works
17:22:04 <ben0x539> > [1..5] >>= const "abc"
17:22:04 <lambdabot>   "abcabcabcabcabc"
17:22:14 <kmc> > let rep a = fix (a:) in rep 'x'
17:22:15 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
17:22:16 <m0nkfish> @src const
17:22:16 <lambdabot> const x _ = x
17:22:16 <Cale> Oh, I guess return = replicate 1
17:22:17 <ben0x539> > [1..5] >>= ("abc" ++) . show
17:22:18 <lambdabot>   "abc1abc2abc3abc4abc5"
17:22:27 <m0nkfish> weird..?
17:22:34 <m0nkfish> what is const used for?
17:22:44 <Cale> m0nkfish: making constant functions
17:22:47 <ben0x539> return
17:22:52 <dmwit> const is used for ignoring things
17:23:10 <m0nkfish> could you give a simple example? :)
17:23:23 <dmwit> > const 3 "hey" -- simplest example I can think of
17:23:24 <kmc> > let len = foldr (const (+1)) 0 in len [1,2,3] -- m0nkfish
17:23:24 <lambdabot>   3
17:23:25 <lambdabot>   3
17:23:31 <kmc> 3 is the best number
17:23:35 <monochrom> The nice thing about standards is there are so many different standards to choose from. The nice thing about meaningful identifiers is that there are so many different meanings to choose from.
17:23:37 <m0nkfish> it's the magic number
17:23:43 <kmc> no that's 5
17:24:00 <kmc> :t const (+1)
17:24:01 <lambdabot> forall a b. (Num a) => b -> a -> a
17:24:10 <dmwit> 10♥ is the magic card
17:24:17 <Cale> no, that's 7
17:24:35 <ben0x539> monochrom: Which is why we *clearly* should scrap all of return, pure, const, :[], etc and just standardise on one of them
17:24:44 <kmc> class Pointed !
17:24:46 <m0nkfish> ah kmc i see what you did there :)
17:25:21 <monochrom> Yeah, call all of them "map". :)
17:25:32 <Cale> monochrom: haha
17:25:39 <dmwit> augh
17:25:50 <dmwit> That's even worse than Cale's (.) and (++). ;-)
17:25:56 <m0nkfish> @src replicate
17:25:56 <lambdabot> replicate n x = take n (repeat x)
17:26:32 <mmmdonuts> Haskell: TAMFWTDI - There's A Million Friendly Ways To Do It
17:26:47 <ben0x539> Right, if we are calling fmap (.), we are calling return const from now on >:[
17:26:47 <kmc> for certain definitions of "friendly"
17:26:54 <fbru02> i don't undersatand some people keep saying that Haskell doesn't have polymorphic types but it does as long as types happen to be of a same type class
17:27:02 <kmc> (.) isn't fmap
17:27:08 <kmc> it should be a class member of Category
17:27:18 <mmmdonuts> kmc: "friendly" was a euphemism for another word beginning with f...
17:27:22 <kmc> haha
17:27:30 <idnar> :t return (+1)
17:27:30 <dcolish> dcoutts: i just realized i only sent a message to ross 7 days ago about cabal access, but i definitely felt like 3 weeks :)
17:27:31 <lambdabot> forall a (m :: * -> *). (Num a, Monad m) => m (a -> a)
17:27:34 <ben0x539> > (+1) . read $ "2"
17:27:35 <lambdabot>   3
17:27:38 <ben0x539> > (+1) `fmap` read $ "2"
17:27:38 <lambdabot>   3
17:27:46 <ben0x539> :|
17:27:52 <idnar> how is const return?
17:27:59 <mmmdonuts> > (+1) <$> read $ "2"
17:28:00 <lambdabot>   3
17:28:17 <Saizan_> idnar: for the ((->) r) monad
17:28:28 <idnar> oh, that wasn't what I wanted
17:28:40 <monochrom> There are two meanings of "polymorphism" people use.
17:28:44 <idnar> @type return 5 :: Integer -> Integer
17:28:45 <lambdabot> Integer -> Integer
17:28:54 <idnar> > (return 5) 10
17:28:55 <lambdabot>   5
17:28:59 <idnar> right.
17:29:37 <m0nkfish> @src return
17:29:37 <lambdabot> Source not found. I've seen penguins that can type better than that.
17:29:42 <m0nkfish> oh
17:29:48 <ben0x539> It is const, we just said :)
17:29:56 <m0nkfish> its literally the same as const?
17:29:59 <kmc> return is a member of the Monad typeclass
17:30:00 <ben0x539> no
17:30:05 <kmc> m0nkfish, only for one particular monad
17:30:10 <kmc> @instances Monad
17:30:11 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
17:30:14 <kmc> the first one
17:30:14 <m0nkfish> ok gonna stop you there
17:30:15 <ben0x539> const is return for the special case of the type of return being, uh, the type of const
17:30:18 <m0nkfish> i havent 'done' monads
17:30:19 <m0nkfish> ;)
17:30:24 <kmc> m0nkfish, monads do you
17:30:35 <ben0x539> for a bunch of other types, return might be Just, or Right, or putting a thing into a list
17:30:35 <m0nkfish> ah but i live in soviet russia
17:31:04 <ivanm> ummm.... last I checked, Russia wasn't (officially) Soviet any more...
17:31:12 <kmc> that's what they want you to think!
17:31:19 <m0nkfish> we have the world fooled
17:31:24 <dmwit> m0nkfish: There's no time like the present!
17:31:26 <yitz> ivanm: it is on slashdot
17:31:32 <monochrom> const is return of (r->)
17:31:33 <dmwit> ?google you may have invented monads
17:31:34 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
17:31:34 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
17:31:38 <idnar> ivanm: nobody said Russia was still Soviet
17:31:51 <idnar> ivanm: they merely implied the use of time travel technology :P
17:32:00 <ivanm> idnar: ahhhh ;-)
17:32:02 <mmmdonuts> m0nkfish, have you looked at the source to const?
17:32:09 <mmmdonuts> @src const
17:32:09 <lambdabot> const x _ = x
17:32:12 <ivanm> so he just comes into the future to use the interwebz then?
17:32:12 <idnar> or, uhm
17:32:20 <idnar> not necessarily time "travel"
17:32:20 <ben0x539> tachyons.
17:32:26 <kmc> a soviet engineered time machine would probably work well except 2% of the time it would explode and take down the building
17:32:40 <idnar> what do you call sending information into the future?
17:32:41 <ivanm> s/building/city/
17:32:49 <mmmdonuts> kmc, sounds like the space shuttle
17:32:51 <ivanm> time communication?
17:32:53 <Saizan_> we're just so lagged that we see him chat from 20 years ago (or more?)
17:32:53 <ivanm> mmmdonuts: heh
17:32:59 <monochrom> time capsule
17:33:02 <idnar> mmmdonuts: I thought the space shuttle blew up more often than 2% of the time
17:33:24 <idnar> ivanm: IP over Tachyon
17:33:30 <m0nkfish> dmwit actually the present is 1:30am and i have a lecture in 8 hours so i'll leave it for now ;)
17:33:36 <m0nkfish> (incidentally a haskell lecture)
17:33:38 <kmc> 1.73%
17:33:40 <monochrom> Oh I have a better answer. "what do you call sending information into the future?" Blogging.
17:33:42 <Saizan_> idnar: sending informato to the future is called "being alive" :)
17:33:47 <ivanm> idnar: heh
17:33:51 <kmc> monads aren't that hard
17:33:53 <kmc> really
17:33:54 <kmc> i promise
17:34:00 <idnar> monochrom: hahaha
17:35:04 <mmmdonuts> Pop style quiz: is it better to import Applicative and use <$>, or just use fmap if you can get away with it?
17:35:17 <ben0x539> fmap
17:35:25 <kmc> i like the look of <$>
17:35:30 <ivanm> mmmdonuts: depends on how deep your fmap is
17:35:33 <kmc> :t (<$>)
17:35:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:35:39 <idnar> I prefer <$> to `fmap`
17:35:41 <ivanm> some people prefer <&> for chaining purposes, etc.
17:35:45 <kmc> :t (<&>)
17:35:46 <lambdabot> Not in scope: `<&>'
17:35:52 <ivanm> (as in they have lots of fmaps to do)
17:36:02 <idnar> <£>
17:36:05 <kmc> haha
17:36:11 <idnar> <¥>
17:36:41 <ben0x539> I still maintain (€) = flip ($) would be handy sometimes
17:36:52 <kmc> not if you have a US keyboard
17:36:57 <ivanm> <λ>
17:37:05 <ivanm> kmc: yeah
17:37:10 <ben0x539> I setxkbmap de every time I want to type one ;)
17:37:16 <monochrom> I confess a fetish with <$> too.
17:37:31 <ben0x539> Hmm, >$<?
17:37:54 <kmc> :t ($>)
17:37:55 <lambdabot> Not in scope: `$>'
17:37:57 <kmc> :t (<$)
17:37:58 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
17:38:19 <ivanm> monochrom: more information than we needed to know! keep your kinks to yourself! :p
17:38:34 <kmc> @vixen do you have a <$> fetish?
17:38:35 <lambdabot> i do occassionally, i guess
17:38:54 <mmmdonuts> I want a version of hlint that definitively answers all such style questions for me.  I'll just do what I'm told.
17:39:00 <idnar> @src (<$)
17:39:01 <lambdabot> (<$) = (<$>) . const
17:40:30 <ben0x539> That does not look right
17:41:07 <idnar> x <$ y = (const x) <$> y
17:41:18 <kmc> one problem is that Applicative imports some stuff that can conflict
17:41:23 <kmc> e.g. <|> and many with Parsec
17:41:24 <idnar> > 10 <$ [1..10]
17:41:25 <lambdabot>   [10,10,10,10,10,10,10,10,10,10]
17:41:30 <kmc> though those should go away
17:42:09 <kmc> > () <$ [1..3]
17:42:10 <lambdabot>   [(),(),()]
17:42:19 <ben0x539> ooh.
17:42:29 <kmc> :t () <$ [1..3]
17:42:30 <lambdabot> [()]
17:42:33 <kmc> :t () <$> [1..3]
17:42:34 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `()'
17:42:34 <lambdabot>     In the first argument of `(<$>)', namely `()'
17:42:34 <lambdabot>     In the expression: () <$> [1 .. 3]
17:43:07 <kmc> > (const ()) <$> [1..3]
17:43:08 <lambdabot>   [(),(),()]
17:46:09 <fbru02> what did ⊥ mean ?
17:46:32 <ivanm> fbru02: looks like a box to me...
17:46:43 <kmc> usually, it means a value which produces an error, or never terminates evaluation
17:46:48 <kmc> that's bottom, _|_ right?
17:47:04 <fbru02> _|_ yes thanks to both
17:47:11 <kmc> it's not part of Haskell syntax, but we use it to talk about the "denotations" (meanings) of haskell programs
17:48:54 <fbru02> how does one have the time/wisdom to learn haskell as a computing language and write concise Haskell/Mathematically oriented typed programs ? sometimes i think i'm not practicing my haskell-fu a lot and i should do simpler things more often
17:49:36 <ivanm> fbru02: by using it a lot? *shrug*
17:49:40 <kmc> having time is a general problem, i don't have any haskell-oriented solutions to that
17:49:45 <kmc> as for wisdom, there's plenty of it in this channel
17:49:59 <kmc> i learn something all the time
17:50:04 <kmc> even when i'm not asking questions
17:50:50 <kmc> most people here are in a position both to learn and to teach, which is wonderful
17:51:23 <monochrom> I am a very logical person. Types make a lot of sense to me. Just another logic.
17:51:34 <kmc> curry and howard would agree with you there
17:51:51 <monochrom> People who intuit too much are disadvantaged.
17:52:35 <monochrom> (where intuition takes on the did-not-use-reasoning meaning as per webster)
17:52:52 <mmmdonuts> I don't think it's intuiting so much as trying to relate it to previous experience with less rigorous systems.
17:53:06 <fbru02> sorry to vent my frustrations, but when coding haskell i try to set my mindset to basically : define my ADTs then code my functions regarding that types and then mash the funcs together in main using IO. Now i'm trying to make my code more edsl like using monads to tie the types in my functions and not rely too much in IO , is this the logicla progression of a haskell noob ?
17:53:19 <kmc> sort of
17:53:48 <kmc> it's definitely an excellent idea to design types first, then write functions from there
17:54:11 <ksf>  Couldn't match kind `#' against `*'
17:54:11 <ksf>     When matching the kinds of `GHC.Prim.Float# :: #' and `a :: *'
17:54:13 <kmc> many programs have a sort of "read, transform, write" structure
17:54:13 <monochrom> I think most haskell people do it.
17:54:27 <ksf> I'm using     ltE = varE . mkName $ "<" and fE = litE . floatPrimL . toRational $ f
17:54:31 <ksf> is that wrong?
17:55:03 <ksf> ...there don't seem to be non-prim float literals.
17:55:46 <kmc> fbru02, it's typical to have a very small "main" which calls a pure function to do most of the work
17:55:52 <kmc> but it's not always the case
17:56:28 <kmc> if your problem actually involves a lot of IO, you'll end up with lots of functions returning IO actions.  that's not a problem or anything
17:56:33 <Saizan> ?hoogle floatPrimL
17:56:34 <lambdabot> Language.Haskell.TH floatPrimL :: Rational -> Lit
17:56:34 <lambdabot> Language.Haskell.TH.Lib floatPrimL :: Rational -> Lit
17:56:34 <lambdabot> Language.Haskell.TH FloatPrimL :: Rational -> Lit
17:57:02 <ksf> I'm using ltFloat# directly now, but that's not particularily elegent
17:57:23 <ksf> well, the actual non-elegance stems from the fact that TH just plainly sucks when it comes to quasiquoting.
17:57:30 <Saizan> so your f is a Float# ?
17:57:31 <ksf> I was never once able to get it to work.
17:57:50 <ksf> oh, no. my parameter in is a Float
17:58:00 <ksf> I don't actually care, ghc is going to unbox them anyway.
17:58:12 <ksf> I've got a lot of constants, though.
17:58:28 <ksf> (I'm unrolling a binary lookup)
17:58:44 <Saizan> i wonder where Float# comes from then
17:58:51 <ksf> the literals.
17:58:57 <ksf>         \ p -> if ltFloat# p 0.5009432435035706# then
17:58:58 <ksf>                    if ltFloat# p 0.30295494198799133# then 97## else 99##
17:58:58 <ksf>                else
17:58:58 <ksf>                    if ltFloat# p 0.698490560054779# then 103## else 116##
17:59:34 <kmc> :t 97##
17:59:35 <lambdabot> GHC.Prim.Word#
17:59:53 <kmc> :t 9##
17:59:54 <lambdabot> GHC.Prim.Word#
17:59:55 <kmc> :t 9#
17:59:56 <lambdabot> GHC.Prim.Int#
18:00:06 <kmc> :t 9###
18:00:06 <lambdabot> parse error (possibly incorrect indentation)
18:00:12 <fbru02> kmc thanks somehow im my pre haskell life i use to think of the compiler as a whiny thing that wouldn't let me run my program now have to completly change my head
18:00:54 <kmc> in some sense, a haskell compiler is whinier than most
18:01:11 <ksf> heh, and I can use infixE instead of AppE . AppE
18:01:12 <kmc> because it catches errors at compile time that wouldn't be caught in other languages
18:01:35 <ksf> aaah.
18:01:50 <kmc> but we all tend to think that's a good thing :)
18:01:59 <ksf> I guess haskell is getting confused because I've got bangs in my data type
18:02:31 <ksf> nope doesn't help
18:02:53 <kmc> it can be a lot of fuss to make a C compiler happy, but once you've done so you haven't established much about the actual correctness of your program
18:03:10 <kmc> in Haskell there's more payoff for that effort.  and the effort is lessened by features like type inference
18:03:30 <m0nkfish> ksf if you're getting your hair caught in your data types, it's time for a haircut :)
18:03:56 <ksf> @hooge Float -> Float#
18:03:56 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
18:03:56 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
18:03:56 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
18:04:06 <ksf> @hooge Float# -> Float
18:04:06 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
18:04:07 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
18:04:07 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
18:04:16 <monochrom> Heh
18:04:28 <ddarius> DrSyzygy: There's quite a bit about metamorphic programming, such as the paper by that name by Martin Erwig.
18:04:58 <ksf> is unsafeCoerce actually the way to go?
18:05:16 <jmillikin> If I upload a package to Hackage which depends on 3rd-party C libraries, will it still generate the Haddock docs?
18:05:44 <dcestari> hello, anyone can point me to a Happy (compiler compiler) tutorial or example? not the User Guide
18:05:49 <monochrom> unsafeCoerce is useful when you know the exact relation between Float# and Float.
18:06:37 <kmc> dcestari, any reason you're using Happy instead of, say, Parsec or uu-parsinglib?
18:06:46 <fbru02> kmc thanks , how is the canonical way of summing a Int and Double ? somehow i never thought of that in this past year
18:06:59 <dcestari> kmc: academic requeriments
18:06:59 <kmc> parser generators have some advantages, but largely they exist to work around the weak expressive power of other languages
18:07:01 <jmillikin> fbru02: would you like the result to be an int or double?
18:07:02 <kmc> ah
18:07:29 <kmc> > (1 :: Double) + fromIntegral (2 :: Int)
18:07:29 <lambdabot>   3.0
18:07:39 <MyCatVerbs> monochrom: surely pattern matching on (F# f) is much, much safer.
18:07:48 <ksf> oh, I see
18:07:49 <kmc> > (1 :: Int) + floor (2.5 :: Double)
18:07:50 <lambdabot>   3
18:08:05 <ksf> unsafeCoerce won't work, it's data Char = C# Char#
18:08:10 <monochrom> But we know nothing about Float# now. I don't even know whether it is a type name or a data constructor name.
18:08:35 <ksf> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim/GHC-Types.html
18:08:45 <monochrom> OTOH if you know, all the better.
18:08:58 <Zariel> why cant i do, floor (n / 60)
18:09:05 <Zariel> where n is an Int ?
18:09:12 <Saizan> you can't unsafeCoerce between the two, one is a pointer to a float, the other is an actual machine float
18:09:14 <SubStack> :t (/)
18:09:15 <lambdabot> forall a. (Fractional a) => a -> a -> a
18:09:19 <fbru02> jmillikin, kmc thanks
18:09:24 <kmc> Saizan, that'd be a fun disaster
18:09:38 <kmc> they might not even be the same word size
18:09:39 <monochrom> n is an Int, / doesn't like an Int
18:09:56 <kmc> though i imagine unsafeCoerce is restricted to kind *
18:10:00 <SubStack> > (\n -> floor $ fromIntegral n / 60) (140 :: Int)
18:10:01 <lambdabot>   2
18:10:05 <monochrom> My sister hates ants and / hates ints
18:10:06 <MyCatVerbs> Zariel: you want to use a function called "div", which implements integer-division-with-truncation.
18:10:11 <Saizan> kmc: yeah
18:10:13 <mauke> > 140 `div` 60
18:10:14 <lambdabot>   2
18:10:14 <SubStack> although yeah, div does the same thing
18:10:29 <ksf>     Illegal variable name: `F#'
18:10:31 <mauke> hmm
18:10:38 <Zariel> oh thanks
18:10:42 <MyCatVerbs> ksf: turn on -XMagicHash.
18:10:49 <ksf> doesn't help
18:10:52 <mauke> there is an html pun involving div and span hidden somewhere
18:10:54 <ksf> or wait
18:11:04 <MyCatVerbs> {-# LANGUAGE MagicHash #-} otherwise.
18:11:14 <mauke> -XMagicMushrooms
18:11:15 <ksf> no, doesn't.
18:11:27 <MyCatVerbs> :set -XMagicHash -- at the GHCi prompt.
18:11:58 <kmc> -XSpecialSauce
18:12:06 <ksf> I _do_ know how to set language options
18:12:07 <MyCatVerbs> Then :t (\(F# f) -> f).
18:12:27 <ivanm> -XSpecialSauce `on` -XMagicMushrooms ?
18:12:41 <kmc> mm sounds tasty
18:12:47 <MyCatVerbs> :m GHC.Base too, in case you need to import the data constructor.
18:13:05 <ksf> I'd actually rather not go the primop way and not have TH generate primitive literals in the first place
18:13:07 <Zariel> how do i do div to get the fractional part and the int part?
18:13:12 <kmc> :t divmod
18:13:13 <lambdabot> Not in scope: `divmod'
18:13:16 <kmc> :t divMod
18:13:17 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
18:13:25 <kmc> > 29 `divMod` 4
18:13:25 <lambdabot>   (7,1)
18:13:36 <Zariel> thanks very much
18:14:09 <ksf> it's really TH that's refusing to splice the F#
18:15:09 <Saizan> FloatPrimL takes a Rational though
18:15:56 <mike8901> For anyone familiar with haskell-mode: how do I clear the buffer of the interpreter?
18:16:01 <mike8901> (in emacs, that is)
18:18:18 <ivanm> mike8901: what do you mean?
18:18:30 <ivanm> C-x h C-w ?
18:18:37 <mike8901> yep :)
18:18:37 <mike8901> thanks
18:18:48 <ksf> buggers
18:18:54 <mike8901> though that is an awfully long key binding...
18:18:54 <ivanm> ksf: what?
18:19:03 <ksf> Word doesn't export its constructor
18:19:03 <ivanm> mike8901: C-x h == select all
18:19:05 <mike8901> but I guess it's supposed to be so one doesn't accidentlaly erase the buffer
18:19:06 <ivanm> C-w == cut
18:19:09 <mike8901> ah
18:19:11 <ivanm> ksf: heh
18:19:11 <ksf> which means I can't box primwords.
18:19:30 <ivanm> mike8901: though why do you want to erase the buffer?
18:19:36 <ivanm> and that won't erase the buffer's history AFAIK...
18:19:45 <mike8901> I know - I need to copy/paste the result
18:19:54 <mike8901> and I don't want it to include stuff before a certain point
18:20:00 <ivanm> OK...
18:20:08 <ivanm> so just don't select anything before that point!
18:20:09 <Zariel> is there a better way of doing http://pastey.net/128912 ?
18:20:16 <ivanm> C-space == set mark
18:20:32 <ivanm> then go to the end point, and do C-w (or C-S-w to copy)
18:20:52 <ivanm> Zariel: pattern match on a and b?
18:21:09 <ivanm> (days, n') = n `divMod` (60 * 24)
18:21:18 <ivanm> (hours, min) = n' `divMod` 60
18:21:41 <Zariel> havnt seen, n' notation yet
18:21:58 <ivanm> Zariel: it's just another variable
18:22:17 <ivanm> having the prime (the ' character) there usually indicates an updated/revised version of that variable
18:22:32 <monochrom> we allow ' in names. for example hi'there'this'is'a'number
18:22:32 <kmc> > let (a,b) = 29 `divMod` 5 in "The values are " ++ show a ++ " and " ++ show b
18:22:34 <lambdabot>   "The values are 5 and 4"
18:23:08 <Zariel> ah I see, straight unpacking of tuples
18:23:12 <kmc> sometimes beginners think there is a special relationship betwen x and x', or x and xs
18:23:18 <kmc> but there's none; they're just names
18:23:44 <kmc> Zariel, yeah.  the tuple is an alegbraic data type constructor like any other, except with somewhat different syntax
18:23:53 <kmc> so you can pattern match on it anywhere a pattern is allowed
18:24:02 <kmc> > (\(a,b) -> a) (2,3)
18:24:03 <lambdabot>   2
18:24:21 <kmc> > case (2,3) of (1,1) -> "no"; (a,b) -> "yes"
18:24:22 <lambdabot>   "yes"
18:24:42 <monochrom> I should try to call all my variables x, x', x'', x'''... when I write code for newbies. :)
18:24:45 <kmc> @src (,)
18:24:45 <lambdabot> Source not found. That's something I cannot allow to happen.
18:24:49 <Zariel> kmc: thanks, learning is slow, but im getting there
18:25:04 <kmc> Zariel, cool.  we're always happy to help people learn
18:25:17 <Zariel> need to get a laptop to take to lectures ^^
18:25:22 <monochrom> "hi how to write a function to sum up a list?"  x (x':x'') = x' + x x''
18:25:30 <kmc> Zariel, are you learning Haskell for a class?
18:25:45 <Zariel> part of my Comp Sci first year
18:25:51 <kmc> i once spent 2 weeks trying to find a bug that turned out to be a typo of x where i meant x'
18:26:08 <kmc> after that i have become a little less enthusiastic with the apostrophes
18:26:15 <Zariel> lol
18:26:27 <tommd> kmc: I've started shying away from primes in variables due to my eyes gliding over too many such bugs.
18:26:52 <kmc> there's some rule about "the length of a variable name should be proportional to the size of its scope"
18:27:04 <kmc> and in that rule i'd say primes count as a large negative contribution to that quantity
18:27:57 * hackagebot upload: gnome-keyring 0.1 - Bindings for libgnome-keyring (JohnMillikin)
18:28:36 <monochrom> I had a more subtle mistake than yours. I had as first version this recursion "f x = ... f ...". I then renamed f to g, and wrote a slightly different function named f again. "f x = new function; g x = ... f ..." Do you see the error?
18:28:52 <kmc> it's especially dangerous because often x and x' will have the same type
18:28:57 <monochrom> (And no error message because the types match.)
18:29:07 <kmc> but anyway if you're doing lots of "updates" to primed variables, it's usually possible to rewrite as a big compositional pipeline
18:29:30 <kmc> for some reason the fake-updates are popular in ML, where also let is non-recursive so you can say "let x = f x" as an even-faker update
18:30:39 <kmc> monochrom, yeah... i've done that while memoizing especially
18:30:50 <kmc> doesn't help much if your memoized function recurses on the non-memoized one
18:33:09 <fbru02_> kmc yesterday i was reading http://blog.sigfpe.com/2009/01/haskell-monoids-and-their-uses.html , isn't it useful to have make Integer and Double instances of Monoid and then have a Summer instnace of monad that does Sum Int -> Int -> Sum Double -> Sum Double , maybe i make no sense because of the hour
18:33:49 <ivanm> fbru02_: you can't make Int and Double instances of Monoid because it's not obvious how to do os
18:33:50 <ivanm> *so
18:33:54 <ivanm> do you use + or * ?
18:34:02 <ivanm> that's why there's the Sum and Product wrapper instances
18:34:18 <iaefai> What is (%)
18:34:25 <ivanm> and "Sum Int -> Int -> Sum Double -> Sum Double" doesn't make sense
18:34:28 <kmc> basically, numbers are monoids in two different ways: addition and multiplication
18:34:31 <ivanm> iaefai: to make rational numbers
18:34:39 <kmc> and you can't have two instances for the same type
18:34:39 <iaefai> ok
18:34:42 <ivanm> > fromRational 3 % 4 :: Double
18:34:43 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
18:34:43 <lambdabot>         against inferred ty...
18:34:45 <kmc> > 2 % 4
18:34:45 <ivanm> bah
18:34:46 <lambdabot>   1 % 2
18:34:51 <ivanm> @hoogle Rational -> Double
18:34:51 <lambdabot> Numeric fromRat :: RealFloat a => Rational -> a
18:34:51 <lambdabot> Prelude fromRational :: Fractional a => Rational -> a
18:34:51 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
18:35:00 <ivanm> > fromRat 3 % 4 :: Double
18:35:01 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
18:35:01 <lambdabot>         against inferred ty...
18:35:04 <ben0x539> Maybe we should have two Monoid typeclasses
18:35:08 <ivanm> > fromRat (3 % 4) :: Double
18:35:09 <lambdabot>   0.75
18:35:10 <kmc> unfortuantely % isn't a constructor and can't be pattern matched
18:35:15 <kmc> ben0x539, why?
18:35:22 <kmc> there are many more than two ways something can be a monoid, in general
18:35:27 <ben0x539> Hmm
18:35:34 <ben0x539> Maybe we should have an infinite list of Monoid typeclasses
18:35:36 <ivanm> ben0x539: and not all monoids have more than one way of doing it
18:35:39 <ivanm> ben0x539: or not
18:35:41 <kmc> what we *really* should have is scoped typeclass instances
18:35:46 <ksf> I'm sucessfully making the code much slower by being way to smart.
18:35:46 <ivanm> you can't generalise it then
18:35:46 <kmc> by replacing typeclasses with implicit parameters
18:35:50 <ivanm> kmc: what do you mean?
18:36:15 * ivanm finds it confusing that kmc and ksf have three-letter nicks starting with k, and xchat making both those nicks the same colour... :s
18:36:33 <ksf> mine is shorter.
18:36:35 <ben0x539> Maybe we should have a Map from associative operators to Monoid instances
18:36:43 <ksf> "m" is a very lange character.
18:36:48 <ivanm> as in a Data.Map ?
18:37:03 <ivanm> ksf: not in a fixed size font it isn't...
18:37:05 <ben0x539> sure, why not
18:37:16 <ksf> why should I use fixed size for IRC?
18:37:18 <ivanm> ben0x539: then that doesn't make sense
18:37:25 <ben0x539> :I
18:37:32 <ivanm> ksf: well, even so, they're the same width here
18:37:33 <kmc> ivanm, typeclass constraints are like implict parameters of dictionary type
18:37:36 <ksf> DejaVu Serif 11
18:37:48 <kmc> and they're filled in by searching in a particular special global environment
18:37:55 <ivanm> since there's less space on either side of the m then there is of the s here...
18:38:07 <kmc> it'd be nice if instead they were regular implicit / dynamically-scoped parameters, and could be bound using "let", etc.
18:38:13 <ivanm> oh, wait, I get what ben0x539 is saying now...
18:38:23 <ivanm> ben0x539: won't work; you can't define Eq on functions let alone Ord
18:39:00 * hackagebot upload: wcwidth 0.0.0 - Native wcwidth. (JasonDusek)
18:39:05 <kmc> sure you can, with StableNames
18:39:06 * kmc ducks
18:39:41 <ivanm> kmc: hmmm?
18:39:47 <ksf> sure you can tell that two infinite loops are equal, after having run them both for infinite time.
18:39:51 <ivanm> wow, that helps... "wcwidth is a native wcwidth" :s
18:40:02 <ivanm> @slap ksf
18:40:02 <lambdabot> I don't perform such side effects on command!
18:40:41 <Zao> @unsafeSlap ksf
18:40:41 <lambdabot> Unknown command, try @list
18:40:53 <mauke>    wcwidth - determine columns needed for a wide character
18:40:54 <ivanm> even reading the full description on the hackage page doesn't make it any clearer what it's doing...
18:40:57 <ivanm> Zao: heh
18:40:59 <monochrom> @slap monocdrom
18:40:59 * lambdabot would never hurt monocdrom!
18:41:06 <ksf> @letMachinesDominateTheWorld
18:41:06 <lambdabot> Unknown command, try @list
18:41:10 <ivanm> mauke: as in `w' ?
18:41:16 * Zao monomorphizes his CD-ROM.
18:41:18 <ksf> I don't believe that.
18:41:22 <kmc> @. elite slap lambdabot
18:41:22 <lambdabot> //\/\e puLl5 14/\/\bdaBOT +hROugH t|-|e 3\/IL man9ler
18:41:26 <ksf> she's secretly plotting, behind our backs.
18:41:28 <mauke> ivanm: huh?
18:41:30 <monochrom> When has lambdabot become such a stupid pacifist?
18:41:38 <ivanm> mauke: what's a wide character?
18:41:41 <ivanm> monochrom: good question
18:41:43 <kmc> @. elite slap lambdabot
18:41:43 <lambdabot> //\/\E Pu11S 1AMBdabO+ thR0ugH T|-|e 3VIl /\/\4n9|er
18:41:48 <mauke> ｓｏｍｅｔｈｉｎｇ ｌｉｋｅ ｔｈｉｓ
18:41:55 <ivanm> but I find it interesting how elite even converts the /me into elite code...
18:42:01 <ksf> @slap monochrom
18:42:02 * lambdabot clobbers monochrom with an untyped language
18:42:04 <mauke> ivanm: a wchar_t (as opposed to a char)
18:42:05 <kmc> and not \x01ACTION
18:42:06 <ivanm> mauke: that looks like a whole bunch of boxes to me...
18:42:10 <monochrom> OK, better. :)
18:42:12 <ksf> she's no pacifist. she just likes me.
18:42:23 <monochrom> and monocdrom :)
18:42:24 <ivanm> mauke: I've barely used any C, so I still don't get that ;-)
18:42:29 <kmc> @vixen what do you think of ksf?
18:42:29 <lambdabot> let's don't talk about that
18:42:30 <mauke> ivanm: a char is a byte
18:42:35 <monochrom> hahaha
18:42:36 <ivanm> right
18:42:39 <mauke> ivanm: wchar_t is supposed to be able to represent more characters
18:43:01 <mauke> some of which may need 0, 1, 2 (or more?) columns to display
18:43:02 <ivanm> so like how to encode unicode vs ascii chars ?
18:43:23 <mauke> wchar_t is the opposite of encoding
18:43:23 <ivanm> ummm... multi-character characters?
18:44:11 <ben0x539> wchar_t is int
18:44:11 <deech> I'm trying to model a C function pointer with this code : foreign import ccall "print_info" c_wrap_print_info :: (CInt -> CString -> (Ptr CString)-> CInt ) -> IO (FunPtr ( CInt -> CString -> (Ptr CString) -> CInt)), and I get an "unacceptable argument type in foreign declaration" error. What does this mean?
18:44:11 <ben0x539> hth
18:44:24 <ivanm> mauke: I meant how to represent it in memory, etc.
18:44:45 <jmillikin> char : Word8 :: wchar_t : Char
18:44:48 <mauke> that's kind of orthogonal to wcwidth
18:44:49 <kmc> wait what
18:44:56 <mauke> I'd expect a Haskell version to have the type Char -> Int
18:45:02 <kmc> the "wide" in wchar_t has nothing to do with the display size
18:45:12 <kmc> it means that its unicode value may be greater than 255
18:45:20 <jmillikin> he was joking, I think
18:45:54 <kmc> if you want to (portably) treat it as a sequence of bytes, you'll have to pick an encoding, like utf-8, utf-16, etc
18:46:02 * hackagebot upload: wcwidth 0.0.1 - Native wcwidth. (JasonDusek)
18:47:27 <ben0x539> deech: Are you trying to pass a haskell function to C code? idgi
18:48:55 <jmillikin> deech: if you're trying to convert a Haskell function into a C function pointer, you need to use <<foreign import ccall "wrapper">>. See http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Ptr.html
18:49:01 <deech> ben0x539: yes, I need to pass something to a C-function that takes a function pointer.
18:49:31 <ben0x539> but that is what funptr does
18:49:45 <ben0x539> isn't it
18:50:37 <deech> jmillikin: I read the doc, does it have to be called "wrapper"?
18:50:42 <jmillikin> funptr does two things, c -> c and haskell -> c
18:51:03 <jmillikin> No, the "wrapper" is saying which kind of foreign import it is
18:51:12 <jmillikin> the name of the function generated is on the second line
18:51:50 <deech> jmillikin: Oh I didn't think the string "wrapper" meant something. Thanks!
18:52:19 <jmillikin> http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=4957#a4957
18:53:24 <ksf> @src (&&)
18:53:25 <lambdabot> True  && x = x
18:53:25 <lambdabot> False && _ = False
18:53:46 <deech> jmillikin: Awesome! Thank you.
18:56:37 <iaefai> Is there another way of doing this:  foldr1 (==) [1,0] where I don't need a function that is (a -> b -> b)?
18:56:45 <ben0x539> ... how do I use the FFI to call a function named "wrapper" then?
18:57:11 <gjl> What would I need to do to have a simple list comprehension like [ x ^ 2 | x <- [1.000001,1.000002..100]] computed using multiple threads?
18:57:43 <jmillikin> ben0x539: it's a different "foreign ..." syntax
18:59:20 <ben0x539> jmillikin: How so?
18:59:32 * ksf wonders if there's any imaginable way in which x could be forced when the lhs of && is False
18:59:51 <jmillikin> it would be something like <<foreign import ccall unsafe "header.h wrapper"
18:59:58 <ksf> gjl, data parallel haskell?
19:00:06 <ben0x539> I thought the header.h part was option :<
19:00:11 <gjl> thanks. I'll look into that
19:01:35 <Zariel> whats a better way of doing this http://pastey.net/128913 all I could come up with was create a list of all numbers which arnt divisable
19:02:57 <poe> Zariel you can check only up to square root of x
19:03:15 <ivanm> s/can check only/only need to check/
19:03:54 <Zariel> yeah that makes sense, doh (3am is a bad times)
19:04:31 <poe> Zariel and also only 2 : [3,5..] (2 and odd numbers)
19:05:59 <poe> and also (== []) is better written as null
19:08:19 <poe> and you can short cut at the first divisor isPrime n = any (\d -> mod n d == 0) (2 : [3,5..s]) where s = ceiling (sqrt n)
19:08:20 <Zariel> why wont it let me do, isItPrime x = prime x 2 : [ 3, 5 .. floor (sqrt x) ]
19:08:31 <iaefai> I get an error in pattern with this: eq n1:n2:[] = if (n1 == n2)    I am not sure why
19:08:34 <ivanm> Zariel: because sqrt doesn't work on integrals
19:08:40 <ivanm> Zariel: sqrt $ fromIntegral x
19:08:42 <poe> Zariel that needs parens
19:08:47 <ivanm> (that's my random guess anyway)
19:09:00 <ivanm> iaefai: eq (n1:n2:[])
19:09:03 <ivanm> or just eq [n1,n2]
19:09:09 <ivanm> poe: was that for iaefai?
19:09:15 <poe> no
19:09:21 <iaefai> ok
19:09:26 <poe> but it also applies :)
19:10:04 <Zariel> thanks very much, what does this mean: (\d -> ...
19:10:10 <mike8901> list comprehensions are guaranteed to be in-order, right?
19:10:20 <poe> Zariel anonymous function (lambda abstraction)
19:10:24 <iaefai> What is this mean? Occurs check: cannot construct the infinite type: t = [t]   on the line eq [n1:n2] = if (n1 == n2) \n then 1 \n else 0
19:10:44 <mike8901> > [x | x<-[1..100]]
19:10:45 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:10:49 <Zariel> poe: oh right, lambda d = ..
19:10:57 <ben0x539> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12206#a12206 this ffi thing is kind of fun
19:10:59 <poe> Zariel f x = foo is the same as f = \x -> foo
19:11:01 <mike8901> [x | x<-reverse[1.100]]
19:11:08 <monochrom> (\d -> mod n d == 0) means lambda d: mod(n,d)==0
19:11:12 <mike8901> > [x | x<-reverse [1.100]]
19:11:13 <lambdabot>   [1.1]
19:11:26 <mike8901> [x | x<-reverse[1..100]]
19:11:38 <mike8901> > [x | x<-reverse[1..100]]
19:11:39 <lambdabot>   [100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,7...
19:12:05 <poe> iaefai mixing syntax, (a:b:[]) is [a,b]
19:12:18 <iaefai> oh missed that part
19:12:28 <ivanm> mike8901: [x | x <- xs] == xs ...
19:12:34 <poe> iaefai a:b means whatever type is a, b must be a list of things of that type.
19:12:48 <mike8901> okay, good :)
19:12:49 <iaefai> yes
19:12:49 <ivanm> @check \xs -> [x | x <- xs] == xs
19:12:50 <lambdabot>   "OK, passed 500 tests."
19:13:01 <poe> iaefai but that bugs the compiler, because for some other reason a and b have the same type
19:13:02 <ivanm> @check \(xs :: [Int]) -> [x | x <- xs] == xs
19:13:02 <lambdabot>   Parse error in pattern at "->" (column 16)
19:13:06 <ivanm> bah
19:15:16 <sohum> ivanm: is that a compiler-specific result? I thought the list monad didn't guarantee order?
19:15:48 <jmillikin> What would be the point of an unordered list?
19:16:03 <Zao> A collection of stuff?
19:16:19 <jmillikin> Data.Set's better for that
19:16:22 <Zao> If order doesn't matter, it'd be silly to have to maintain it.
19:16:24 <bd_> jmillikin: You want to know if an item is in the list, but you don't really care about any other attribute of the list. And you want it to be fast.
19:16:50 <jmillikin> Yes, but the whole point of a list is that it's sequential.
19:17:01 <ivanm> sohum: I think it does
19:17:10 <ivanm> jmillikin: exactly
19:17:19 <Zao> Evaluation order, no. Sequence order, yes.
19:17:25 <Zao> If I understand the context right.
19:17:26 <ivanm> @src [] (>>=)
19:17:26 <lambdabot> xs >>= f     = concatMap f xs
19:17:30 <ivanm> sohum: ^^
19:17:37 <ivanm> so it's guaranteed
19:17:38 * sohum nod
19:17:39 <sohum> right
19:17:40 <ivanm> @src [] return
19:17:41 <lambdabot> return x    = [x]
19:18:49 <tensorpudding> @src [] (>>=)
19:18:49 <lambdabot> xs >>= f     = concatMap f xs
19:19:05 <tensorpudding> :t concatMap
19:19:06 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
19:20:02 <tensorpudding> > concatMap return [1..3]
19:20:03 <lambdabot>   [1,2,3]
19:20:23 <dino-> I was just poking at gitit thinking of maybe using it as some kind of personal storage of ramblings on my system..
19:20:42 <dino-> Wonder if I can rig it so I don't have to login. Or maybe that's a bad idea. Not sure.
19:22:21 <ivanm> dino-: if it's going to be publically accessible, then you probably want a login
19:23:35 <dino-> ivanm: No, never. Well, I hope never. :/
19:24:19 <mmmdonuts> dino: that should be easy enough to do. See the custom auth example in the comments in Gitit.hs.
19:25:05 <dino-> mmmdonuts: Ok, thank you
19:26:56 <mmmdonuts> dino: you could probably hardcode the withUser function like this:
19:27:10 <mmmdonuts> withUser = localRq (setHeader "REMOTE_USER" "dino")
19:27:33 <mmmdonuts> Then you'd always be logged in as "dino"
19:27:43 <dino-> Ah, I read that in the config with the auth type 'generic'
19:27:48 <dino-> Looks for REMOTE_USER
19:28:55 <mmmdonuts> I'm just basing that on the "more complex example" in the Gitit.hs comments. it's possible there's a simpler way...
19:35:39 <visualbasicgui> Has anybody within earshot here been doing project euler problems in haskell?
19:35:46 <visualbasicgui> if so, how have you found the time constraints?
19:37:00 <shepheb> generally for PE, the efficient algorithm will finish in 10-20 seconds at most.
19:37:08 <visualbasicgui> aaaaaaaaah
19:37:17 <visualbasicgui> well that's okay i suppose
19:37:24 <shepheb> I've never had classical optimization, trying to squeeze a few percent out, matter in any language for PE
19:37:45 <visualbasicgui> i'm just generally wondering if haskell would be suitable for a game
19:37:48 <visualbasicgui> not
19:37:56 <visualbasicgui> you know, like some next 3D halo killer :P
19:37:59 <visualbasicgui> that's dumb anyways
19:38:02 <visualbasicgui> but like
19:38:07 <shepheb> once you move beyond the first few dozen problems, a too-naive algorithm will take many minutes or hours anyway
19:38:08 <visualbasicgui> maybe a tetris with psychedelic patterns
19:38:13 <tommd> visualbasicgui: There are several games in Haskell you could look at as examples.
19:38:23 <visualbasicgui> I've played Raincat and found it adorable
19:38:25 <visualbasicgui> my girlfriend lost it
19:38:33 <shepheb> Raincat is awesome
19:38:37 <tommd> visualbasicgui: Frag is the most well known one, but hard to get running as it is almost unmaintained these days.
19:38:39 <visualbasicgui> she was screaming and squirming and almost threw my computer across the room
19:38:43 <gjl> how does one compile using a Makefile?
19:39:10 <tommd> gjl: Makefiles are akin to scripts, so the same way you compile from the command line.
19:39:22 <tommd> What's the issue?
19:39:33 <visualbasicgui> ./configure && make && make install?
19:39:43 <visualbasicgui> that's probably not what you meant
19:40:02 <tommd> Oh, or that - I figured he was talking about how to use make and ghc
19:40:07 <gjl> I have mirrored http://darcs.haskell.org/ghc-6.10/packages/dph/examples/
19:40:08 <visualbasicgui> he probably was
19:40:09 <visualbasicgui> who knows
19:40:12 <gjl> on my drive
19:40:15 <gjl> there is a Makefile there
19:40:23 <tommd> and 'make' doesn't do it for you?
19:40:30 <gjl> nope
19:40:42 <gjl> Makefile:2: ../../mk/config.mk: No such file or directory
19:40:49 <gjl> make: *** No rule to make target `../../mk/config.mk'.  Stop.
19:42:11 <tommd> gjl The dph packages are not for the faint of heart.  If you are serious then you might need to do some digging and e-mail in the ML.
19:42:21 <iaefai> When I load up this module: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12207#a12207  anything in the typeclass instance is not in scope, any ideas why?
19:43:22 <kmc> iaefai, are you importing the Board class?
19:43:36 <gjl> tommd: would this be the best one: haskell-cafe@haskell.org?
19:43:37 <iaefai> yes
19:43:49 <iaefai> No errors show when loading this module
19:43:55 <tommd> djl: I would guess that, yes.
19:43:59 <tommd> gjl: ^^
19:44:06 <iaefai> Board module: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12207#a12208
19:44:13 <tommd> iaefai: But do you load the Board module in ghci too
19:44:21 <gjl> thanks
19:44:29 <tommd> :m +Board Checkers
19:44:46 <iaefai> ok, that seems to help
19:46:23 <EvanCarroll> is there another way to write this let f =  ( 102 `mod` )
19:46:24 <tommd> iaefai: Just because you imported a module that has an instance of a typeclass does not give you access to the methods of the class.  You must import the module that declared the type class.  You probably already figured out, but I'm just making sure.
19:46:44 <tommd> EvanCarroll: let f = flip mod 102
19:46:50 <tommd> err, not that
19:46:56 <tommd> let f = mod 102
19:47:06 <iaefai> tommd: I have imported other modules through the source file I loaded, while accessing modules that source file imported.
19:48:00 <tommd> iaefai: You seem to be arbitrarily generalizing my statement.  Not a good thing to do when discussing a language. :-)
19:48:33 <EvanCarroll> mod 102 == (102 `mod`) ?
19:48:41 <dmwit> iaefai: Also, keep in mind that ghci behaves differently if there is a compiled version of a file laying around than it does if it has to interpret the file.
19:48:46 <tommd> EvanCarroll:  f a b == a `f` b
19:48:57 <dmwit> ?check \x -> mod 102 x == (102 `mod`) x
19:48:57 <lambdabot>   "* Exception: divide by zero
19:49:01 <dmwit> bleh
19:49:08 <dmwit> ?check \x -> x /= 0 ==> mod 102 x == (102 `mod`) x
19:49:08 <lambdabot>   No instance for (Test.QuickCheck.Testable
19:49:09 <lambdabot>                     (Test.QuickCh...
19:49:14 <dmwit> Oh, COME ON.
19:49:26 <dmwit> ?check \x -> (x /= 0) ==> (mod 102 x == (102 `mod`) x)
19:49:26 <lambdabot>   No instance for (Test.QuickCheck.Testable
19:49:27 <lambdabot>                     (Test.QuickCh...
19:49:41 <dmwit> :t x /= 0 ==> mod 102 x == (102 `mod`) x
19:49:41 <lambdabot> Property
19:49:55 <dmwit> :t \x -> x /= 0 ==> mod 102 x == (102 `mod`) x
19:49:56 * Zao ponders whether to quickcheck for dmwit's wit.
19:49:56 <lambdabot> forall a. (Integral a) => a -> Property
19:51:05 <iaefai> tommd: I will keep your specific instance in mind.
19:51:15 <tommd> ?check (\x -> x /= 0 ==> mod 102 x == (102 `mod`) (x :: Int))
19:51:15 <lambdabot>   No instance for (Test.QuickCheck.Testable
19:51:16 <lambdabot>                     (Test.QuickCh...
19:51:17 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12209#a12209
19:51:23 <tommd> Humm, works outside lambdabot
19:51:30 <ksf> how do I get ghc to generate sane code for such a thing?
19:51:31 <dmwit> Yeah, I really don't get it.
19:51:51 <ksf> the pasted version is waaaaay slower than traversing a tree
19:52:39 <tommd> ksf: I would try guards.  It is probably making new thunks for every 'if' level.
19:53:11 <ksf> but I don't want to chain &&...
19:53:16 <ivanm> tommd: I think it's the (x :: Int) bit that lambdabot doesn't like...
19:53:21 <dmwit> :t \f -> lookup id . map (\x -> p < f x)
19:53:22 <lambdabot>     Couldn't match expected type `(a -> a, b)'
19:53:22 <lambdabot>            against inferred type `Bool'
19:53:22 <lambdabot>     In the expression: p < f x
19:53:35 <tommd> ivanm: No, dmwit tried it without the signature earlier.
19:53:42 <ksf> so I'd need case () of _ | p < 2323 ->   and so on
19:53:44 <dmwit> :t \f -> lookup id . map (\(x, v) -> (p < f x, v))
19:53:45 <lambdabot>     Couldn't match expected type `a -> a' against inferred type `Bool'
19:53:45 <lambdabot>     In the expression: p < f x
19:53:45 <lambdabot>     In the expression: (p < f x, v)
19:53:46 <ivanm> dmwit: need to tell lambdabot what p is...
19:53:54 <ivanm> tommd: oh...
19:53:57 <dmwit> ah yes
19:54:05 <dmwit> Looks like I'm striking out tonight.
19:55:02 <tommd> ksf: You might want a named function to make syntax nicer, thus avoiding the case statement.
19:55:04 <dmwit> :t \f p -> head . filter ((p<) . f)
19:55:05 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> a1 -> [a] -> a
19:55:13 <dmwit> that's better
19:55:16 <dmwit> ksf: What about that?
19:55:25 <ksf> that's the output of -ddump-splices
19:55:35 <dmwit> err... something like that, I guess
19:55:37 <ksf> I don't really care for it to be beautiful
19:56:14 <ksf> dmwit, because a linear lookup is slower than a binary one
19:56:19 <dmwit> right
19:56:27 <ksf> ...well, for n = 4 it's the same.
19:56:41 <ksf> n <= 4
19:57:28 <dmwit> So I take it f' is monotonic.
19:57:45 <ksf> f' is F#
19:58:00 <ksf> that's a hack because TH converts my constants into primconstants
19:58:21 <dmwit> well... if we're going for speed here, why not unpack and use <# then?
19:58:32 <ksf> I think it does that.
19:58:39 <dmwit> err
19:58:44 <dmwit> That doesn't seem to.
19:58:54 <dmwit> I mean, each (<) unpacks it its own self.
19:59:32 <dmwit> Actually, just ignore me.  I'm deep into territory I don't understand correctly.
19:59:46 <ksf> but generally ghc is quite good at unpacking stuff
19:59:59 <ksf> ...that's just anecdotal evidence. my core is usually full of #'s.
20:04:50 <ksf> are profiling builds for TH-enabled stuff broken with 6.10.4?
20:05:23 <ksf> it's telling me to recompile with -osuf but that fails with ghc: ./Data.o: unknown symbol `era'
20:05:55 <ksf> oh, nevermind, -fforce-recomp was the culprit
20:07:01 <ksf> zomg I can't believe that profile.
20:07:05 <ksf> It can't possibly be true.
20:09:13 <dmwit> Well, don't keep us in suspense... what did it say?
20:09:31 <ivanm> dmwit: the world is ending in 2013, not 2012 like the mayans said
20:09:39 <dmwit> Makes sense.
20:09:45 <dmwit> We lost a year between -1 and +1, remember?
20:10:12 <ksf> it did say, and still says, that the lookup functions are bleeding fast, but at the same time a hell a lot of time is spend unrolling stuff.
20:10:25 <ivanm> dmwit: we lost about 6 years when they started the gregorian calendar IIRC
20:10:39 <ivanm> since they guesstimated when year 1 was
20:10:40 <dmwit> 2019, then?
20:10:55 <ivanm> the other way round...
20:10:59 <ivanm> 2007!
20:11:09 <dmwit> Don't be ridiculous.
20:11:11 <ivanm> lost/gained, whatever the correct term is
20:11:33 <dmwit> Wake up and smell... the ashes, Mr. Freeman.
20:11:47 <ivanm> is that a half-life quote? if so, I've never played it...
20:12:50 <dmwit> ivanm: Creepiest game character ever invented: http://www.youtube.com/watch?v=qhbhQioqLK8
20:13:33 <dmwit> The first minute or two there is the beginning of the game.
20:13:42 <dmwit> I was as confused as I'm sure you are.
20:14:07 <ksf> well that assembly there can't possibly be slow.
20:14:16 <ivanm> yes, I am
20:14:30 * ivanm goes to check what that most authorative of sources - wikipedia - has to say
20:14:36 <MichaelGG> Does Haskell have any nice libraries or examples of formatting length prefixed byte encoded messages?
20:15:17 <dmwit> MichaelGG: Check out the Get and Put monads in the um...
20:15:20 <dmwit> what is it called...
20:15:42 <dmwit> Data.Binary
20:15:55 <dmwit> ?hackage binary
20:15:55 <lambdabot> http://hackage.haskell.org/package/binary
20:16:17 <MichaelGG> Like in F# I can use metadata attributes so i could make up a data type and tag things and then just implement a single formatter
20:18:37 <dmwit> MichaelGG: It's not hard to write Binary instnances, there are instances for tuples and sums so there's not much needed after that.
20:18:47 <dmwit> If you just need serialization.
20:18:55 <MichaelGG> no its to implement a specifc format
20:18:59 <dmwit> If you need a specific format, then like I said check out the Get and Put monads and write it yourself.
20:19:11 <dmwit> Again, it's more approachable than it seems. =)
20:19:31 <MichaelGG> thats just pretty straightforward writing binary eh
20:19:34 <dmwit> (Remember: you've got the full power of Haskell as your macro language. =)
20:20:13 <MichaelGG> Last night i came across Parsec and the monadic parser combinator paper and had a fit of how awesome that was
20:20:41 <MichaelGG> so iw as thinking that maybe there was some really awesome way to get arbitrary data types into neat little formats without doing it by hadn
20:24:12 <dmwit> Well, uh, it's about as much "by hand" as Parsec is.
20:25:39 <MichaelGG> i didnt mean to compare directly
20:25:48 <MichaelGG> just how theres so much cool stuff over in haskell land.
20:27:27 <c_wraith> ok, typical problem...  I have keys (del, in particular) not working in ghci after installing on ubuntu 9.10.  someone have a page describing this yet?
20:29:54 <Cale> c_wraith: which ghc version is it?
20:30:52 <c_wraith> 6.10.4, from apt
20:30:58 <Cale> hmm
20:31:11 <c_wraith> I've seen a lot of people describe this problem
20:31:18 <c_wraith> something about haskeline being misconfigured
20:31:58 <Cale> That might be the case. I'm running the generic linux binary with no problems.
20:36:12 <c_wraith> hmm.  I have about 10 lines in a row that end with <* skipSpaces
20:36:25 <c_wraith> Does this tell me I should be tokenizing ahead of time?
20:39:34 <ddarius> That or you should be using normal abstracting techniques...
20:39:43 <ddarius> ho shapr
20:40:05 <c_wraith> ddarius:  they all have different types.  there is no abstraction that applies, that I'm aware of
20:41:49 <dmwit> Are you insulting my polymorphism?
20:43:13 <ivanm> c_wraith: no problems here with 6.10.4 using a ghc I've built myself on gentoo...
20:43:28 <ivanm> c_wraith: I wonder if it makes a difference if you use 6.10.4 to build 6.10.4 ...
20:43:33 <c_wraith> ivanm: this is an ubuntu packaged version issue, possibly only with laptop keyboards
20:43:44 <ivanm> only with laptop keyboards? wtf?
20:43:59 <c_wraith> ivanm: I know I've seen someone mention fixing it with editing a configuration file for haskeline
20:44:00 <ivanm> how does that make a difference?
20:50:30 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
20:50:30 --- topic: set by mauke on [Mon Nov 02 11:41:43 2009]
20:50:30 --- names: list (clog_ Colours_ shellsage Pewpewarrows shapr Uawdal BgPerl-VB03 SmurfOR mmaruseacph2 Stefa2 otto_s roconnor blueflute JabDesign SamB_XP leoncamel fracture musically_ut bos jyyou deech malie Raynes mike8901 aluink solidsnack Heavensrevenge aiko_ Polarina shrughes Gwern-away c_wraith augur kyagrd saccade_ lispy|web caligula_ fbru02 garslo tommd conal horms jsgf gbeshers weihsiu oskimura mm_freak seancorfield krainbolt trvbldn jmillikin leandrom_)
20:50:30 --- names: list (Modius Peaker triplez Saizan hansfbaier Apocalisp dobs SirNick kfish QinGW Adamant ulfdoz sunfun ganbold jleedev Pthing Rotaerk borism_ cloudhead kmc Zeiris ChilliX LitesterB Vq_ dolio Kapowski jmcarthur redline6561 levitation_ Cale lispy sioraiocht kpreid leimy Cobra| arvidj_ awarring ivanm Gracenotes ttmrichter aburrido stoop Garfinkle Philonous dcolish dancor ski_ EnglishGent^afk Alpounet sigh ezrakilty kynky m3ga Spockz Kim^Walkman visualbasicgui)
20:50:30 --- names: list (dibblego ksf sdelic mattrepl alvarezp edwardk mahogny ville ystael ketil ua jan_ guerby fhs Cthulhon| monochrom gjl fritschy camillo astrolabe Igloo hgolden trofi shambler amgarching Nereid_ hellige flazz nathanic ddarius Megant_ DekuNut Aikawa sm kniu Phyx- Spaghettini rdd LeCamarade +preflex mauke jonafan cognominal Mortomes zhijie1 C-Keen arsenm @ChanServ thingwath knobo profmakx Hunner CalJohn clog scree jrockway Arnar mexisme smiler)
20:50:30 --- names: list (ClaudiusMaximus paolino Kambus Philippa_ kosmikus Gabbie soduko donri m-i-l-a-n socpp blackdog blackh kayess_ mcclurmc a-s jayne r0bby willb emma earthy TR2N sprang det mr_ank smelk +hackagebot jones- angelixd_ lament kadoban ski gogonkt Draconx wagle iaefai whoppix kolmodin BMeph astrocub yahooooo cjs juhp cgibreak tavelram gr00vy luite Mr_Awesome mreggen PsiOmega nnunley alphecca- gnuvince zax andrewsw M| hsaliak__ mjrosenb dons pifish_)
20:50:30 --- names: list (karld stepcut aempirei McManiaC wimt chrisdone DEVOKUN dixiecko crem da-x Elench dreixel niksnut voker57__ PeakerWork kuningas felipe_ neurocyte pikhq sereven edwtjo sbok Poeir zygoloid kw317 joed Annie|Home Counter-Strike tmug flux dilinger _Jordan_ idnar jml ahf Axman6 spoop dmwit smg newsham snorble dejones ertai EvanCarroll fnordus taruti jlouis kanalj MacCoaster byorgey Jiten kalven Exteris igorgue jlaire raim0 andun Tobsan ath ^Einstein)
20:50:30 --- names: list (drspider_ tamiko pcc1 emias deiga_ arkx Raevel ibid jvoorhis wornof BONUS_ samulihs geir_ kmeyer FauxFaux opqdonut greap nothingmuch agemo skaar stepnem gdsx magicman srcerer jystic jre2 cathper nornagon quicksilver qebab Deewiant pragma_ Innominate dionoea ath^ koninkje_away Sisu cods wang Elly majoh Ornedan epmf Taggnostr xian Whitesquall rasfar joga stalker borism Bleadof tew88 Bassetts nlogax snhmib blalb dino- geoaxis_ dankna DrSyzygy)
20:50:30 --- names: list (Heffalump SimonRC canvon_ And[y] Esmil nablaa tilman Badger Jaak Twey rey_ ac Liskni_si wolverian tkr Lemmih eelco_ JaffaCake ben0x539 sieni araujo dcoutts xinming ps-auxw bind_return ToRA jelly12gen flippo wharrgarble LeoD heaumer_ deavid wisemanby _xor jabagawee Tomas Veinor alexsuraci thorkilnaur EvilTerran jbauman lhnz Trafalgard Raku^ matthew-_ Jedai djinni m4thrick Eelis eyck t Chile danopia StoneToad ijnek bumblebee waern tensorpudding)
20:50:30 --- names: list (sohum fihi09 jtra nathanic_work anders^^ baaba clanehin zhijie TML linkinus thoughtpolice Neronus jix Colours burp ve pixel5 jaj alexbobp peddie loupgaroublond karihre tessier clarkb jamwt mulletron hiredman allbery_b trez eno Optimo jkramer jontore eek MyCatVerbs glith AnMaster Nereid ksandstr nipuL sjanssen duairc reltuk +lunabot saccade __marius__ tromp_ dcoutts_ davidL PHO_ inimino orbitz endojelly desp bockmabe_ beibmozoi bd_ Laney)
20:50:30 --- names: list (mml`_ sebas__ theclaw mux mokus_ rapacity noj +lambdabot daed brx periodic thetallguy alip Blub\0 loop AndyP ziman Botje drhodes welterde qwr tltstc mdordal2 mfoemmel tuukkah mfp regulate noddy midnite Zao dfeuer gOcOOl epokal ray liff mw493 Maddas Baughn nominolo|uni birkenfeld Valodim Warrigal Ferdirand marmolak tarbo_ laz0r dqd maskd absentia zaarg icee Twigathy thetallguy1 Gilly cjay Blaketh lefant p_l aavogt cygnus_ jasonmay mikste)
20:50:30 --- names: list (sevvie guerrilla osfameron ehamberg flori lsthemes arjanoosting poe thedward jims doublethink_work avysk companion_square authentic jql anekos therp Boney mmmdonuts malouin koala_man qed desu kar-1 mlh droidcore SubStack jfoutz netcat tumult int-e jfredett dogmaT kakeman suiside mikm Paks webframp alexander2 wagle_home da-xw mjv ggreg_ sebbe1991 GNU\colossus _plcs_ impl mornfall pettter koeien prigaux aleator mmmulani Stephan202 ahihi anji_)
20:50:30 --- names: list (saiam Lycurgus nasloc__ sunnavy dek5 ido Khisanth lanaer harlekin wdonnelly jvogel_ poucet Aisling danderson Nanar cdfh_ fxr Milo- shepheb integral wormwood BONUS shachaf shortcircuit olsner mle mercury^ Nafai Paradox924X electrogeek Vulpyne drbean mrd ned lavish sgf_ qm13_ glitch mshaw thomastc stroan sproingie dumael mattam franksh boyscared nimred BrianHV bran _br_ SeaPrior erg equanimity jnwhiteh)
20:50:48 <ivanm> heh
20:52:49 <c_wraith> interested in seeing xev output from press / release of the del button?
20:54:09 <c_wraith> http://pastebin.com/m2de6c808
20:54:23 <c_wraith> the characters it's failing to render are 0x7f, which I believe are the ascii control code for DEL
20:59:00 <scutigera> any debian users ?
20:59:42 <ivanm> scutigera: no, this has been declared a debian-free zone :p
20:59:50 <ivanm> (j/k, in case you couldn't tell)
20:59:55 <Cale> c_wraith: I'm seeing something essentially the same from my delete key
20:59:58 <ivanm> not that I know if any debian users are online atm...
21:00:07 <ksf> would I be right if I suspect that mmapped IO would be even faster than hPut?
21:00:13 <Cale> c_wraith: (but it works here)
21:00:26 <ksf> er hPutBuf
21:00:31 <scutigera> I have this problem: ghc-6.8.2: not built for interactive use
21:00:45 <bos> ksf: it depends.
21:00:49 <Cale> scutigera: There is a generic linux binary on the GHC website
21:00:50 <ksf> scutigera, well, then build it for interactive use
21:00:59 <ksf> bos, outputting the sequences in the fasta benchmark
21:01:14 <Cale> scutigera: It works well, is not out-of-date, and I recommend its use :)
21:01:16 <ksf> something's fishy with the bytestring solution, at least in the way I currently use it.
21:01:26 <ivanm> c_wraith: mine looks the same pretty much; do root and state mean anything (because mine are different) ?
21:01:36 <ivanm> c_wraith: what keymap are you using? US?
21:01:42 <bos> ksf: you'd be unlikely to notice the difference there, and the hassle would be more trouble than it would earn you in by-no-means-sure performance.
21:01:50 <Cale> (compiling GHC yourself is a waste of time unless you are hacking on it)
21:02:00 <scutigera> looks like 6.10 is in testing/unstable, so is it better to run testing/unstable or fetch 6.10 frm ghc ?
21:02:09 <ivanm> scutigera: probably the former
21:02:17 <ivanm> since they have the whole haskell platform there IIRC
21:02:36 <ksf> well managing a continuous region of memory isn't really more complex than managing an alloca'd 61-byte buffer
21:02:46 <c_wraith> ivanm: Yes, I'm using th US keymap
21:02:47 <ksf> ...but I'd have to resize the region manually.
21:02:50 <scutigera> ivanm: yes the cabal/debian interaction is confusing.  are all the cabal packages also deb packages ??
21:03:00 <Cale> scutigera: no, they're separate
21:03:08 <ivanm> scutigera: I highly doubt it, seeing as how there are so many cabal packages on hackage ;-)
21:03:19 <ivanm> unless I'm completely misunderstanding what scutigera is talking about...
21:03:38 <mtnviewmark> question about cabal: If I installed a whole bunch of packages but didn't have documentation: True in config --- how can I get cabal to build the docs for the already installed packages?
21:03:56 <ivanm> don't know if there's an easy way to rebuild anything...
21:04:00 <ivanm> *everything
21:04:00 <Cale> ivanm: It would be interesting if when cabal-install installed a package, it first made a .deb of it and installed that
21:04:02 <ksf> it was surely a brilliant idea of the debian packagers not to provide an interactive version.
21:04:16 <ivanm> Cale: I think that's an awful idea
21:04:20 <ksf> another proof of just how great a distro debian is.
21:04:29 <bos> mtnviewmark: cabal install --reinstall
21:04:32 <scutigera> parsec, pretty, random, network - some are in cabal and some look to be ghc extras (?)
21:04:35 <ivanm> Cale: maybe it'd work in binary distros like debian, but what would you do with cabal flags?
21:04:40 <ivanm> bos: does that do all of them?
21:04:45 <mtnviewmark> oh really --- well - that should be fun!
21:04:56 <ivanm> bos: it sounds like mtnviewmark wants them all rebuilt
21:05:08 <bos> ivanm: yes
21:05:09 <ksf> If it were two hours later, I could go to the supermarket and buy some coffee.
21:05:11 <ivanm> scutigera: ghc-extras is no more; it's the haskell platform now
21:05:16 <Cale> ivanm: huh?
21:05:16 <ivanm> @time ksf
21:05:18 <lambdabot> Local time for ksf is Tue Nov 17 06:04:58
21:05:42 <tensorpudding> does Category represent categories?
21:05:43 <Cale> ivanm: All it would do is package the thing as a .deb so that, for instance, you could uninstall it later.
21:05:53 <Cale> tensorpudding: *sort of*
21:05:53 <mtnviewmark> I suppose I'm going to have to name 'em
21:05:55 <ivanm> Cale: how would cabal-install deal with making the .deb for something like xmonad-contrib and choosing whether to use xft support or not?
21:05:56 <scutigera> Cale: I like the idea.
21:06:08 <ksf> the baker has open already, but they're cutthroats when it comes to anything else but bread+buns
21:06:24 <Cale> tensorpudding: It represents a very special kind of category built on the types in Hask, whose composition maps are all natural transformations
21:06:48 <ivanm> Cale: well, the debian app/lib on hackage could do presumably do that if/when dcoutts makes cabal-install a library as well as an app
21:06:53 <tensorpudding> okay..
21:07:07 <ivanm> Cale: I know that kolmodin has embedded a version of cabal-install inside hackport to duplicate some of its features...
21:07:14 <ivanm> (since there's no library version of it yet)
21:07:34 <Cale> ivanm: I'm not saying that anyone would distribute these .debs
21:07:46 <Cale> ivanm: They would just get installed where they were built.
21:07:54 <ivanm> Cale: OK; then why not just get uninstall support into cabal-install?
21:08:02 <ivanm> rather than a per-distro thing like that?
21:08:23 <Cale> I also wasn't suggesting this was a particularly sane thing to do ;)
21:08:28 <ivanm> heh
21:08:31 <Cale> (I'm running the binary GHC myself)
21:08:44 * ivanm generally makes his own ebuild whenever he wants/needs a new package from hackage
21:09:03 <Cale> (i.e. http://haskell.org/ghc/dist/6.10.4/ghc-6.10.4-i386-unknown-linux-n.tar.bz2 )
21:09:05 <ivanm> and then I push it into the gentoo-haskell overlay, so that everyone else can enjoy the fruits of my labour...
21:09:05 <ivanm> ;-)
21:09:18 <ivanm> Cale: you're using debian I take it?
21:09:23 <Cale> No, Ubuntu
21:09:39 <Cale> Though, I've been thinking about switching back to Debian unstable.
21:09:53 <Cale> Ubuntu has been only getting worse for the last 3 or 4 versions
21:10:13 <tensorpudding> ubuntu, or gnome, or both?
21:10:16 <scutigera> Cale: I didn't have very good luck with Ubuntu, that's why I'm back on Deb.
21:10:45 <Cale> tensorpudding: Well, maybe it's Gnome's fault too, but it's Ubuntu's fault for not doing the bare minimum to fix things before passing the work on to me.
21:10:59 <shapr> ho ddarius
21:11:12 <Cale> I spent a day and a half fixing my audio after "upgrading" to Karmic.
21:11:26 <tensorpudding> heh
21:11:28 <Cale> By downloading source packages and recompiling them properly.
21:11:39 <ivanm> Cale: I thought ubuntu already did too many of its own "tweaks" to gnome, etc. ...
21:11:46 <ivanm> shapr!!!!!!!!!!!!!!
21:11:49 <ivanm> ;-)
21:11:49 <Cale> (and uninstalling pulseaudio)
21:11:55 <tensorpudding> i like debian stable because it almost never changes
21:12:09 * ivanm updates his unstable gentoo system every day
21:12:09 <ivanm> :p
21:12:11 <blackh> Is it possible to alias the module you're in like you can with import ... as X for imported modules?
21:12:29 <Cale> I like having new versions of things, but there at least should be some expectation that they work.
21:12:30 <tensorpudding> ivanm: i'm sure you're computer gets a nice workout with all the compiling
21:12:36 <ivanm> yup
21:12:48 <mtnviewmark> wheee:    cabal install --reinstall  `ghc-pkg list --user --simple-output`
21:12:49 <ivanm> tensorpudding: well, there usually isn't more than an hour of stuff to do each day
21:12:50 <ivanm> if that
21:12:52 <tensorpudding> you don't need new versions of everything...
21:13:00 <Cale> I hate having to compile anything.
21:13:12 <ivanm> Cale: so you never get random new packages off hackage? :p
21:13:17 <tensorpudding> ivanm: i'm being somewhat facetious, i ran gentoo for a year back when installing it involved chrooting
21:13:31 <shapr> ivanm!!!
21:13:38 <Cale> ivanm: Well, there's that, but if I could get binaries, I would take them.
21:13:38 <scutigera> Cale: then don't used fink...
21:13:43 <mtnviewmark> it's rather heavy handed just to get the documentation generated....
21:13:49 <tensorpudding> but i ran ~x86 and it was in a constant state of nearly broken
21:13:53 <scutigera> Cale: it compiles gcc4 (for 8 hours)
21:14:09 <Cale> scutigera: yeah, that's just a complete waste of time
21:14:12 <ivanm> tensorpudding: installing it still involves chrooting, and I'm using ~x86
21:14:44 <tensorpudding> i thought there was an installer
21:14:45 <mtnviewmark> ah, fie --- that doesn't really work, as the various package documentations sets are not cross-linked
21:14:53 <tensorpudding> there was one back in 2006 when i stopped using it
21:14:53 <mtnviewmark> haddock is doing them independently of each other
21:15:04 <scutigera> Cale: and confusing. I forgot about fix points on compilers and killed it twice thinking the build was busted. doh !
21:15:12 <Cale> ivanm: I also compiled the gnome-media and gnome-applets packages by hand, but I had a headache the entire time.
21:15:26 <bos> mtnviewmark: they're cross linkable
21:15:39 <bos> but fiddly
21:15:50 <mtnviewmark> right - but clearly not by cabal during it's install (or reinstall) processing
21:15:59 <ivanm> tensorpudding: there's a GUI, I still don't think it's worth using
21:16:18 <ivanm> tensorpudding: I do my installs via a live CD from another distro ;-)
21:16:28 <mtnviewmark> so, what I want is a command that says - hey - build and lovely single, cross-linked, documentation set from my system installed packages and doc (via Haskell Platform) and the current set of user installed packages
21:16:51 <ivanm> Cale: next time, take the headache tables _before_ you start it compiling! ;-)
21:16:51 <tensorpudding> i still remember the install process
21:17:05 <ivanm> Cale: I suppose the thing is on gentoo is that whilst it is compiling packages for you, it's all automatic
21:17:17 <ivanm> just like doing cabal install to fetch all the deps you need, etc.
21:17:20 <tensorpudding> vaguely
21:17:29 <Cale> ivanm: but it still puts you into "computer maintenance" mode for hours
21:17:32 <bos> mtnviewmark: there's a script in the ghc tree that does that, which i believe you'll have to run by hand.
21:17:45 <bos> mtnviewmark: it invokes haddock in a mode that generates cross-module links
21:17:55 <ivanm> Cale: the computer is usually on anyway... ;-)
21:17:57 <Cale> Actually, you know what would be awesome? If cabal-installing something could effectively be wget + cp.
21:17:58 <bos> mtnviewmark: libraries/gen_contents_index, i believe
21:18:15 <ivanm> Cale: wouldn't work due to too many possible deps, etc. IMHO
21:18:17 <mtnviewmark> of course, that means more yak-shaving -- I don't have the ghc tree given that I installed via Haskell Platform!  :-)
21:18:29 <bos> argh, can't build GHC HEAD for random incomprehensible reasons.
21:18:31 <ivanm> (if for some reason you're not letting it upgrade a particular version of a dep package or something)
21:18:31 <Cale> Well, yeah, + dependency tracking
21:18:40 <bos> mtnviewmark: you don't need the tree, just the script
21:18:45 <ivanm> bos: as in the RC or straight-from-version-control?
21:18:52 <mtnviewmark> bos - are you running SnowLeopard?
21:18:55 <bos> mtnviewmark: http://darcs.haskell.org/ghc/libraries/gen_contents_index
21:19:00 <mtnviewmark> thanks, bos
21:19:09 * bos typed that URL in from memory.
21:19:11 <bos> scary.
21:19:33 <bos> ivanm: can't build HEAD, not the 6.12 branch.
21:19:37 <ivanm> heh
21:19:43 <bos> ivanm: i built it the other day, and now it's failing.
21:19:43 <ivanm> bos: oh, 6.13?
21:19:50 * ivanm can't even build the 6.12 RC using itself...
21:21:01 <tensorpudding> @type arr
21:21:02 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
21:25:02 <tensorpudding> @src arr (->)
21:25:03 <lambdabot> Source not found. You type like i drive.
21:25:13 <tensorpudding> @src (->) arr
21:25:14 <lambdabot> arr f = f
21:25:24 <mtnviewmark> bleh!  What do you do when the same module (Data.UUID) is found in two packages (uuid and system-uuid)????
21:25:55 <jmillikin> Only link to one of them, I guess
21:26:03 <tensorpudding> hope that you don't have to have both on your system at once
21:26:16 <jmillikin> You can install both safely on the same system
21:26:44 <jmillikin> Assuming you're using cabal, it should namespace the modules according to package name and version.
21:27:01 <mtnviewmark> right - but I can't use both in a single program at once, can I?
21:27:15 <ivanm> mtnviewmark: are you using cabal, or hacking yourself in ghci?
21:27:21 <jmillikin> No, you can't -- but why would you want to?
21:27:22 <ivanm> you just have to hide the one you're not using
21:27:25 <mtnviewmark> both - but assume cabal
21:27:42 <ivanm> mtnviewmark: when you use cabal, you specify which packages you're using
21:27:43 <mtnviewmark> why would I? because they have mutually exclusive functionality
21:27:46 <ivanm> and cabal will hide the rest
21:27:58 <mtnviewmark> right - but if I need both, I'm, er screwed
21:28:36 <ivanm> mtnviewmark: only if the stuff they contain clashes
21:28:36 <mtnviewmark> I suppose I can make due with Read and Show functionliaty in system-uuid's Data.UUID, but the more explicit fromString, toString in uuid's Data.UUID is nicer....
21:28:41 <ivanm> otherwise, it _might_ be OK
21:28:52 <ddarius> ivanm: What module would import Data.UUID import?
21:28:57 <mtnviewmark> It does - they both define Module Data.UUID, with a type UUID
21:29:03 <ivanm> mtnviewmark: Read and Show should only be used to print/read code for debugging purposes, etc.
21:29:18 <mtnviewmark> right - that's why I wanted fromString / toString
21:29:19 <ivanm> ddarius: oh, right, I was confused by something else
21:29:23 <mtnviewmark> but that is in uuid's Data.UUID,
21:29:35 <ivanm> otherwise, you can hide packages on a per-module basis IIRC
21:29:37 <jmillikin> mtnviewmark: What advantages does system-uuid have over uuid? Looking at them, system-uuid appears to have very little functionality
21:29:37 <mtnviewmark> whereas, generating random UUIDs (something I also need) is only in system-uuid's package
21:29:46 <ivanm> someone was asking about this on cafe for mtl and one of the newer pacakges...
21:29:48 <mtnviewmark> V5 (random) UUIDs
21:30:12 <mtnviewmark> er, V4 (random)
21:30:38 <mtnviewmark> uuid supprots V1 and V5, whereas system-uuid does V1 and V4
21:31:22 <jmillikin> How annoying...I wonder how difficult adding support for v4 to uuid would be
21:31:54 <lispy|web> is happy deprectated?
21:31:55 <lambdabot> lispy|web: You have 1 new message. '/msg lambdabot @messages' to read it.
21:31:57 <mtnviewmark> probably not hard --- and then wouldn't rely on local OS uuid functions (which system-uuid does)
21:32:16 <lispy|web> Copyright © 1997-2001 Simon Marlow <-- taht appears in the happy manual
21:32:19 <mtnviewmark> but - more yak shaving....
21:33:43 <lispy|web> the happy docs also mention making sure that your ghc is newer than 4.something-old.
21:34:16 <lispy|web> I was going to write a parser for something and I thought maybe it would be better to use happy, but I know parsec3 is recent :)
21:34:16 <Cale> lispy|web: That's still true ;)
21:34:42 <ksf> @pl f >>= \a -> g >> h a
21:34:43 <lambdabot> (g >>) . h =<< f
21:34:50 <Cale> lispy|web: The latest happy came out on April 23 of this year
21:35:17 <ksf> well f >>= (g >>) . h is almost readable.
21:35:22 <lispy|web> I guess use it if I want to
21:35:31 <lispy|web> It's just weird using something with such old docs
21:36:00 * lispy|web installs the latest happy and alex
21:36:42 * ksf wants supercompilation
21:37:02 <ksf> and no don't mention supero, while I got it to compile, I didn't get yhc to compile.
21:37:36 <mtnviewmark> AHA - uuid DOES have V4 random UUIDs -- by providing an instance of Random UUID!
21:37:58 <mtnviewmark> I have to say, one of the failings of haddock, is that instances dont' really get the opportunity to have extensive doc.
21:38:12 * ksf thinks people who upload defunct code into a repository are the same type of people who drive 200km/h right next to a kindergarten.
21:38:48 <jmillikin> mtnviewmark: according to the docs, those are for version 3 UUIDs
21:39:22 <Cale> mtnviewmark: I agree. Sometimes the instances are the main point of a module, and you can't even see them unless the types which they are instances of are also defined there.
21:39:24 <erikc> ksf: how bout ppl who keep commented out and #if 0'd code, 'in case they need it', despite it being under source control
21:39:43 <mtnviewmark> I think that might be a mistake -- V4 UUIDs are the random ones
21:39:46 <Cale> Er, I mean, the classes
21:40:00 <ksf> that's fine if it's _new_ code.
21:40:29 <ksf> ...though that'd be #if NEW_FEATURE_FOO_DONT_ENABLE_YET
21:40:37 <erikc> hehe
21:40:45 <jmillikin> ksf: that's what branches are for
21:41:32 <ksf> maybe branching would be pain because the code is closely intertwined with something else
21:42:14 <ksf> I'm not advocating it, just saying that it's not a no-go.
21:42:23 * bos figures out why ghc wasn't building
21:42:57 <bos> mtnviewmark: file a bug, perhaps?
21:43:36 <mtnviewmark> yes, I just verified, it does indeed produce V4 UUIDs --- so just a documentation bug
21:43:43 * ksf shudders at the thought that he's going to compile his code, and ghc can't tell whether his pointer arithmetic is correct
21:44:22 <lispy|web> mtnviewmark: I find that one of the sad realities of haddocks is that I almost always have to click the "source" link.  Thank god hackage makes this easy.
21:45:19 * lispy|web could thank all the people who worked hard to make hackage what it is, but thanking an imaginary friend seems so much better
21:46:16 <bos> hackage is a source of great pleasure to me.
21:46:30 <SmurfOR> Does anyone know if regex-posix 0.94.1 is broken on ghc-6.10.3?  I can't get it to work to return types like [String] and [ByteString] oddly enough [[String]] and [[ByteString]] work (albeit incorrectly returning duplicate results).
21:46:38 <bos> it knocks every other language's package management and publication into a cocked har.
21:46:40 <bos> hat.
21:47:51 <lispy|web> Er, well it's still missing some relevant features.  I heard a rumor those features exist in some sort of happs version of hackage that is rumored to exist
21:48:03 <lispy|web> Commenting/voting on packages would be very nice
21:48:16 <lispy|web> And more packages need to give their release notes :)
21:48:21 <ddarius> Yeah, there's quite a few thing yet to do with Hackage and Cabal and the structure of the libraries.
21:48:24 <bos> oh sure, it lacks some stuff. but it's still really good.
21:48:48 <ddarius> The Haskell community isn't one to go off half cocked.
21:49:48 <lispy|web> I do like, it or else I wouldn't have written that horrible parody song for it
21:50:05 <lispy|web> http://www.haskell.org/haskellwiki/Humor/Hackage_Theme_Song
22:03:58 <Adamant> lispy|web: to avoid a Free Software Song style scenario, please ensure nobody ever tries to sing that out loud except in the privacy of their own home :P
22:04:21 * Adamant jokes
22:05:08 <lispy|web> Adamant: yeah, I didn't actually get the syllables right to be able to sing it to the tune it was intended for
22:05:52 <Adamant> lispy|web: I'm just afraid Richard Stallman will somehow discover Haskell and get it in his head to sing that at some point
22:06:07 <lispy|web> hah
22:06:25 <ivanm> preflex: seen lispy
22:06:25 <preflex>  lispy was last seen on #haskell 2 days, 13 hours, 15 minutes and 43 seconds ago, saying: ?tell tommd The # is posted on the door, and I tried to email it to you yesterday.  Sorry if you didn't get it.  But, yeah it's on the door :)
22:06:37 <ivanm> lispy|web: so how do you choose which nick to use? :p
22:06:42 <ivanm> you obviously use both...
22:06:45 <ivanm> ;-)
22:07:23 <lispy|web> ivanm: I used lispy|web when I'm using the freenode web client
22:07:29 <ivanm> ahhhh
22:07:49 <lispy|web> I couldn't tell you why I do thta
22:08:04 <ivanm> heh
22:08:09 <BMeph> Dr. Haskell's Sing-Along Wiki, huh? Sounds...derivative. ;)
22:08:11 <lispy|web> lispy: oh, looks like you're logged in twice
22:08:20 <ivanm> because you never log out of your main one?
22:08:33 <lispy|web> ivanm: never is a very long time
22:08:45 <lispy|web> er, in that sentence I mean
22:08:49 <lispy|web> forever is a long time?
22:09:13 <ivanm> heh
22:10:29 <iaefai> good night, and thank you everyone
22:11:49 <SmurfOR> How do I use an older version of a package from hackage in ghci?  I installed it via cabal but when I load it in ghci it uses the newest version.
22:11:51 <ivanm> andyjgill: at least I now know at least one person reads my blog :p
22:12:04 <ivanm> SmurfOR: did you install the new version or the old version?
22:12:06 <andyjgill> ivanm: :-)
22:12:13 <ivanm> what does "ghc-pkg list" say?
22:12:20 <aavogt> @ask nomeata where did the search submitting mail go in darcswatch? (Can we have them back?)
22:12:20 <lambdabot> Consider it noted.
22:12:21 <Heffalump> it's on Planet Haskell, so lots of people must be reading it
22:12:45 <ivanm> andyjgill: are you "andygillku" who wrote Chalkboard?
22:12:48 <andyjgill> The dependence on QC, QC2, HUnit and others is a pet peeve of mine.
22:12:57 <SmurfOR> ivanm, it shows the older package but when i load it in ghci it says that it's loading the newer version
22:13:04 <ivanm> Heffalump: yes, but that doesn't mean people read it ;-)
22:13:06 <aavogt> ivanm: link?
22:13:08 <ivanm> Heffalump: and he commented
22:13:11 <andyjgill> Yes. We actually, the new version was written by Kevin Matlage at KU.
22:13:24 <andyjgill> We=>Well
22:13:26 <ivanm> aavogt: http://ivanmiljenovic.wordpress.com/2009/11/17/waddaya-know-testing-works/ , also on planet
22:13:29 <ivanm> andyjgill: heh
22:13:44 <ivanm> SmurfOR: does ghc-pkg list show both versions?
22:13:56 <SmurfOR> ivanm, could it be because the ~/.ghc/i386-linux-6.10.3/package.conf is different?
22:14:00 <andyjgill> We are working on release, before new functionality goes in.
22:14:03 <ivanm> maybe use "ghc-pkg hide <newer version>" to hide the newer one?
22:14:22 <ivanm> andyjgill: your website says 0.02 is the newest release; hackage has 0.2
22:15:05 <andyjgill> Oh. Thats a problem. It will get fixed when we update. We've also got a new website, with examples and a tutorial.
22:15:14 <ivanm> right
22:15:22 <SmurfOR> ivanm, thanks :)
22:15:31 <ivanm> SmurfOR: no worries
22:15:47 <ivanm> SmurfOR: use ghc-pkg expose to un-hide it
22:16:30 <bos> things'll be much better when cabal natively groks tests
22:17:06 <aavogt> ivanm: I guess shipping the tests with the code is done for the same reason that people leave warnings enabled when compiling for users
22:17:26 <ivanm> bos: by having a distinct test setup in cabal?
22:17:36 <ivanm> aavogt: rather than, you know, _fixing_ them?
22:17:53 <ivanm> I leave warnings enabled, but fix them before I release (except for a few orphan instances)
22:17:54 <bos> ivanm: right
22:18:20 <aavogt> well warnings vary from compiler to compiler
22:18:31 <ddarius> Pranav Mistry is a garage genius.
22:19:20 <aavogt> but agreed, people should correct warnings.
22:19:21 <ivanm> who?
22:19:38 <Heffalump> ivanm: I think distributing tests as standard would be a good thing, if it didn't cause the dependency problems you mention. Consider for example the GHC team wanting to test the whole of hackage with a new compiler.
22:19:45 <ivanm> aavogt: warnings mean more build output; making tests default means more useless deps
22:19:52 <ivanm> Heffalump: agreed
22:19:58 <ivanm> Heffalump: but as it stands, it's bad
22:20:10 <ivanm> see the troubles dcoutts is having on hackage
22:20:19 * mtnviewmark filed doc bug for uuid package
22:20:47 <ivanm> Heffalump: the main point of that rant was because of packages like hmatrix
22:21:04 <aavogt> ivanm: you're supposed to cover the possible alternatives in some kind of followup post now
22:21:11 <ivanm> there was another one (which I can't recall) that until recently had compulsory deps, but after people complained on the mailing lists he removed the test executable IIRC
22:21:17 <ivanm> aavogt: heh
22:21:18 <sjanssen> I dislike enabling tests in the default build of released packages
22:21:21 <andyjgill> Heffalump: I agree about shipping with tests, and fixing the dependency problems. Turning tests off by default makes sense to me, even if they are shipped.
22:21:23 * ddarius didn't know there were rules to blogging.
22:21:34 <ivanm> ddarius: neither did I
22:21:40 <sjanssen> IMO, the way xmonad does it is pretty good until Cabal has real testing support
22:21:46 <ivanm> ddarius: and who is Pranav Mistry?
22:21:53 <Heffalump> what does xmonad do?
22:21:55 <ddarius> @google pranav mistry
22:21:57 <lambdabot> http://www.pranavmistry.com/
22:21:57 <lambdabot> Title: Pranav Mistry
22:21:57 <ivanm> sjanssen: put it part of the darcs record hook?
22:22:33 <sjanssen> Heffalump: we've got "flag testing\n default: False" which conditionally depends on quickcheck and enables the tests via CPP
22:22:49 <Heffalump> ah, yes, same as darcs
22:23:24 <ddarius> ivanm: The most recently posted TED talk is by him.  A lot of what he talks about was covered in an earlier TED talk by a colleague, but still there is a lot of ingenuity this guy shows using simple materials.
22:23:46 <ivanm> TED?
22:23:53 <ddarius> www.ted.com
22:24:09 <andyjgill> sjanssen: thats what we do in ChalkBoard (I think Heffalump suggested this to me at the HIW'09)
22:24:53 <ivanm> sjanssen: IIRC, that still (with Cabal < 1.8.0.1) still requires quickcheck to be installed...
22:25:03 <sjanssen> Heffalump, andyjgill: no surprise that multiple projects have picked up on this solution of least resistance
22:25:06 * ivanm checks by uninstalling quickcheck and trying to build xmonad from darcs
22:25:21 <ivanm> which I alluded to in my blog post
22:25:22 <sjanssen> ivanm: no, the default: False means that quickcheck is not required by default
22:25:37 <ivanm> sjanssen: I've had problems with some packages that try to do that and still fail...
22:25:41 <Heffalump> it's if you have different executables with different requirements that they all find themselves needing the same deps
22:25:49 <ivanm> maybe because they don't explicitly state that the flag is false as well...
22:25:56 <ivanm> OK, it's working... *shrug*
22:26:01 <sjanssen> ivanm: they're doing it wrong?  I know that xmonad's setup works
22:26:43 <ivanm> sjanssen: yeah; maybe because it's completely separate from the main library/executable?
22:27:20 <sjanssen> ivanm: a missing "default: False" seems to be the most likely issue
22:28:00 <ivanm> yeah, that'd be my guess
22:28:04 <sjanssen> and if it's a separate executable, they probably need to have buildable: False when testing is off
22:28:24 <ivanm> dcoutts has partially fixed this for cabal 1.8.0.1
22:29:13 <Heffalump> what's partial about it?
22:30:29 <ivanm> Heffalump: it doesn't work with constraints
22:30:49 <ivanm> unneeded deps aren't brought in, but if you specify --constraing=QuickCheck<2 and it uses QC-2, then it will fail
22:31:03 <ivanm> (as in it uses QC-2 in a non-buildable section)
22:32:08 <ddarius> Does QuickCheck have QuickCheck properties?
22:32:20 <ivanm> heh
22:32:27 <ivanm> a bootstrapping validator?
22:33:03 <sjanssen> ivanm: just read your blog post.  I think it's good to ship all the code related to a project, including the tests, in the tarball
22:33:05 <mtnviewmark> why wouldn't it?
22:34:04 <sjanssen> ivanm: the important thing is that tests and testing libraries aren't on by default in the build process
22:35:26 <ivanm> sjanssen: right, I didn't realise that that technique could work, because the only time I've been aware of it is when it _doesn't_
22:35:36 <ivanm> and I have to add QC/HUnit to the dependencies in the ebuild
22:37:26 <ksf> -fviaC, TH and profiling combined don't seem to work out
22:38:07 <sjanssen> ivanm: I mean that with your approach, even though you don't build the external test module, it would be good to package that module in releases of your library
22:38:17 <sjanssen> just good release practice, in my opinion
22:38:39 <ivanm> sjanssen: right, there's just no real way of doing it unless I have it as a extra-source-file
22:39:09 <sjanssen> ivanm: extra-source-file is exactly what I'd do
22:39:23 <ivanm> sjanssen: even though there's the darcs repo available if people actually want it/care?
22:43:10 <Axman6> ksf: why are you using -fviaC for the fasta thing btw?
22:43:11 <ksf> YAY extrapolating to the shootout's box, my code should run in 5.975s, which'd be place 3
22:43:16 <ksf> yep
22:43:22 <Axman6> why?
22:43:26 <ksf> because it's faster.
22:43:39 <Axman6> using C is often slower than the NCG these days
22:43:39 <ksf> ghc doesnt' seem to generate good code for the randgen
22:43:46 <Axman6> fair enough
22:44:06 <ivanm> Axman6: except for doubles
22:44:19 <ivanm> anything numeric normally ends up being faster with -fviac IIRC
22:44:21 <ksf> there's always the option of splitting the sources, though, and compiling with different options.
22:44:33 <ksf> I've got two source files anyway, due to TH
22:45:14 <ivanm> sjanssen: I'm already using a non-included file to help generate some of the code (manual generation from running it as a script)
22:51:05 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
22:51:05 --- topic: set by mauke on [Mon Nov 02 11:41:43 2009]
22:51:05 --- names: list (clog Dunearhp_ hansfbaier Asztal onodrim solidsnack alvarezp TacticalGrace medfly CodeBlock metageorge rgr bastl cdiem bwwww Whitesquall1 Pthing deech novas0x2a Guest81877 ablokzijl nwf nathanic_work1 shintah omg911 shellsage erikc Sup3rkiddo mwc mxc mtnviewmark Exteris Colours_ Pewpewarrows shapr Uawdal BgPerl-VB03 SmurfOR Stefa2 otto_s blueflute SamB_XP leoncamel fracture musically_ut bos jyyou malie Raynes mike8901 aluink Heavensrevenge)
22:51:05 --- names: list (aiko_ Polarina shrughes Gwern-away c_wraith augur saccade_ lispy|web caligula_ fbru02 tommd conal horms jsgf gbeshers oskimura mm_freak seancorfield trvbldn Modius Peaker Saizan Apocalisp kfish QinGW Adamant ulfdoz sunfun ganbold jleedev Rotaerk borism_ Zeiris LitesterB Vq_ dolio Kapowski jmcarthur redline6561 levitation_ Cale lispy sioraiocht kpreid leimy Cobra| arvidj_ awarring ivanm Gracenotes ttmrichter aburrido stoop Garfinkle Philonous)
22:51:05 --- names: list (dcolish dancor ski_ EnglishGent^afk Alpounet ezrakilty kynky Spockz Kim^Walkman dibblego ksf mattrepl edwardk mahogny ville ystael ketil ua jan_ guerby fhs Cthulhon| gjl fritschy camillo astrolabe Igloo hgolden shambler amgarching hellige flazz nathanic ddarius Megant_ DekuNut Aikawa sm kniu Phyx- Spaghettini rdd LeCamarade +preflex mauke jonafan cognominal Mortomes zhijie1 C-Keen arsenm @ChanServ thingwath knobo profmakx Hunner CalJohn)
22:51:05 --- names: list (scree jrockway Arnar mexisme smiler ClaudiusMaximus paolino Kambus Philippa_ kosmikus Gabbie soduko donri m-i-l-a-n socpp blackdog blackh kayess_ mcclurmc a-s jayne r0bby willb emma earthy TR2N sprang det mr_ank smelk +hackagebot jones- angelixd_ lament kadoban ski gogonkt Draconx wagle whoppix kolmodin BMeph astrocub yahooooo cjs juhp cgibreak tavelram gr00vy luite Mr_Awesome mreggen PsiOmega nnunley alphecca- gnuvince zax andrewsw M|)
22:51:05 --- names: list (hsaliak__ mjrosenb dons pifish_ karld stepcut aempirei McManiaC wimt chrisdone DEVOKUN dixiecko crem da-x Elench dreixel niksnut voker57__ PeakerWork kuningas felipe_ neurocyte pikhq sereven edwtjo sbok Poeir zygoloid kw317 joed Annie|Home Counter-Strike tmug flux dilinger _Jordan_ idnar jml ahf Axman6 spoop dmwit smg newsham snorble dejones ertai EvanCarroll fnordus taruti jlouis kanalj MacCoaster byorgey Jiten kalven igorgue jlaire raim0)
22:51:05 --- names: list (andun Tobsan ath ^Einstein drspider_ tamiko pcc1 emias deiga_ arkx Raevel ibid jvoorhis wornof BONUS_ samulihs geir_ kmeyer FauxFaux opqdonut greap nothingmuch agemo skaar stepnem gdsx magicman srcerer jystic jre2 cathper nornagon quicksilver qebab Deewiant pragma_ Innominate dionoea ath^ koninkje_away Sisu cods wang Elly majoh Ornedan epmf Taggnostr xian rasfar joga stalker borism Bleadof tew88 Bassetts nlogax snhmib blalb dino- geoaxis_)
22:51:05 --- names: list (dankna DrSyzygy Heffalump SimonRC canvon_ And[y] Esmil nablaa tilman Badger Jaak Twey rey_ ac Liskni_si wolverian tkr Lemmih eelco_ JaffaCake ben0x539 sieni araujo dcoutts xinming ps-auxw bind_return ToRA jelly12gen flippo wharrgarble LeoD heaumer_ deavid wisemanby _xor jabagawee Tomas Veinor alexsuraci thorkilnaur EvilTerran jbauman lhnz Trafalgard Raku^ matthew-_ Jedai djinni m4thrick Eelis eyck t Chile danopia StoneToad ijnek bumblebee)
22:51:05 --- names: list (waern tensorpudding sohum fihi09 jtra anders^^ baaba clanehin zhijie TML linkinus thoughtpolice Neronus jix burp ve pixel5 jaj alexbobp peddie loupgaroublond karihre tessier clarkb jamwt mulletron hiredman allbery_b trez eno Optimo jkramer jontore eek MyCatVerbs glith AnMaster Nereid ksandstr nipuL sjanssen duairc reltuk +lunabot saccade __marius__ tromp_ dcoutts_ davidL PHO_ inimino orbitz desp endojelly bockmabe_ beibmozoi bd_ sebas__)
22:51:05 --- names: list (Laney rapacity theclaw mux mokus_ mml`_ noj +lambdabot daed brx periodic thetallguy alip Blub\0 loop AndyP ziman Botje drhodes welterde qwr tltstc mdordal2 mfoemmel tuukkah mfp regulate noddy midnite Zao dfeuer gOcOOl epokal ray liff mw493 Maddas Baughn nominolo|uni birkenfeld Valodim Warrigal Ferdirand marmolak tarbo_ laz0r dqd maskd absentia zaarg icee Twigathy thetallguy1 Gilly cjay Blaketh lefant p_l aavogt cygnus_ jasonmay mikste)
22:51:05 --- names: list (sevvie guerrilla osfameron ehamberg flori lsthemes arjanoosting poe thedward jims doublethink_work avysk companion_square authentic jql anekos therp Boney mmmdonuts malouin koala_man qed desu kar-1 mlh droidcore SubStack jfoutz netcat tumult int-e jfredett dogmaT kakeman suiside mikm Paks webframp alexander2 wagle_home da-xw mjv ggreg_ sebbe1991 GNU\colossus _plcs_ impl mornfall pettter koeien prigaux aleator mmmulani Stephan202 ahihi)
22:51:05 --- names: list (anji_ saiam Lycurgus nasloc__ sunnavy dek5 ido Khisanth lanaer harlekin wdonnelly jvogel_ poucet Aisling danderson Nanar cdfh_ fxr Milo- shepheb integral wormwood BONUS shachaf shortcircuit olsner mle mercury^ Nafai jnwhiteh equanimity erg SeaPrior _br_ bran BrianHV nimred boyscared franksh mattam dumael sproingie stroan thomastc mshaw glitch qm13_ sgf_ lavish ned mrd drbean Vulpyne electrogeek Paradox924X)
22:51:39 <ivanm> sjanssen: I'm looking that the tarball from the perspective of users wanting to build it to get the library/executable, not for someone interested in looking/hacking at the source
22:52:43 <sjanssen> ivanm: those files won't hurt anyone that just wants to build your package, and will only help those odd people that want to do more
22:52:57 <ivanm> right
23:00:07 <kolmodin> ivanm: right, that's true
23:00:30 <ksf> Is there any way to tell ghc to inline a function into a function into which I pass it?
23:00:50 <ksf> i.e. doublicate the function it's passed into?
23:01:25 <ksf> aka known as -fexplode-codesize
23:02:01 <ivanm> kolmodin: which is why I mentioned hackport in here a while back
23:02:13 <Cale> ksf: well... at the very least you might be able to make that happen by hand (in a library setting)
23:02:30 <ksf> well, it's a shootout entry.
23:02:36 <Cale> ah
23:02:37 <ksf> I could do even more TH than now.
23:02:41 <Cale> well, that's not useful there :)
23:02:52 <ksf> they disallow TH?
23:02:58 <Cale> But you could, say, define a RULES pragma for the particular combination, and a specialised version by hand.
23:03:06 <kolmodin> ivanm: yeah
23:03:12 <Cale> Oh, I wasn't talking about TH
23:03:15 <ivanm> ksf: use ZeroTH before you submit it?
23:03:17 <ksf> phew
23:03:20 <Cale> I was talking about my idea of what to do :)
23:03:34 <ksf> ivanm, you mean splicing manually?
23:03:56 <ksf> the point in using TH is actually to use the same data that the others use, but reify it as code.
23:04:05 <ivanm> ksf: well, if they were disabling TH, then you could use TH to write it and then use ZeroTH as a pre-processor before submitting it
23:04:31 <ksf> as manually writing out that binary search looks kinda suspicious.
23:05:09 <ksf> but as it's a shootout designed to compare languages, and TH is an essential Haskell feature, I don't think we should leave it out.
23:06:33 <ksf> higher-order functions don't really help if you want to optimize a tightloop ;)
23:06:47 <Zao> I'm sure that C++ caressers use lots of templates.
23:07:19 <ksf> I'm sure they would, if they could encode their data as templates and ints...
23:09:13 <lispy|web> does cabal have support for happy?
23:09:27 <lispy|web> Specifically, can it just see the happy file and go to town on it?
23:09:38 <ivanm> I think so...
23:09:42 <ivanm> don't ask me how though ;-)
23:09:45 <lispy|web> If not, how would I get cabal to do TheRightThing
23:10:28 <ivanm> lispy|web: I believe magic can help you there ;-)
23:11:07 <lispy|web> ivanm: as a smartass I typed, cabal instal magic
23:11:16 <lispy|web> ivanm: It started to install something
23:11:19 <ivanm> heh
23:11:30 <lispy|web> * Missing C library: magic
23:11:40 <ivanm> "Interface to C file/magic library"
23:11:50 <lispy|web> Yea, that's descriptive...
23:12:08 <cjs> So, given a ByteString, I just want to see if it matches /^[-][0-9]+(\.[0-9]*)?$/, i.e., can be read as a float, and return Just that string or Nothing. Isn't there some clever monadic way to do this without going so far as to resort to using Parsec or whatever?
23:12:11 <ivanm> look at the file to determine its type rather than the extension AFAICT
23:12:12 <lispy|web> ?go What is magic?
23:12:13 <lambdabot> Maybe you meant: google googleit do
23:12:18 <lispy|web> ?google What is magic?
23:12:20 <lambdabot> http://en.wikipedia.org/wiki/Magic_(paranormal)
23:12:20 <lambdabot> Title: Magic (paranormal) - Wikipedia, the free encyclopedia
23:12:20 <ivanm> http://hackage.haskell.org/package/magic
23:12:25 <ivanm> lispy|web: ^^
23:12:31 <ksf> cjs, indeed, that grammar is context-free
23:12:36 <ivanm> cjs: regex?
23:12:41 <ksf> so you can use the applicative interface and don't go monadic
23:12:44 <cjs> Or going so far as to use a regex.
23:12:44 <ivanm> the various regex-* libraries work on bytestrings...
23:12:45 <ksf> regexen are evil.
23:12:56 <cjs> Hm. Tiime to learn about applicitive?
23:12:59 <ivanm> cjs: dammit, _now_ you say that!
23:13:31 <cjs> Well, it just seems to me that there's some quite simple and clever way of doing this with just standard library stuff that I just don't happen to know.
23:13:35 <ivanm> cjs: that sounds exactly the type of values you're _not_ meant to use bytestrings for ;-)
23:13:45 <ivanm> cjs: check out the .Char bytestring modules
23:13:47 <lispy|web> One clever way is to read :: Float and catch the exception
23:13:51 <ivanm> you've got split, all, etc. IIRC
23:13:53 <cjs> I'm converting from a ByteString to this; the ByteString was read from the network.
23:13:58 <ksf> ...or use the version that returns a maybe.
23:13:58 <ivanm> lispy|web: hmmm...
23:14:00 <lispy|web> > read "foo" :: Float
23:14:01 <lambdabot>   * Exception: Prelude.read: no parse
23:14:08 <ivanm> ksf: you mean reads?
23:14:10 <ksf> but read sounds like a good idea
23:14:12 <cjs> It's not quite Float; e.g., 1.3E-4 is not valid.
23:14:13 <ksf> :t reads
23:14:15 <lambdabot> forall a. (Read a) => String -> [(a, String)]
23:14:17 <lispy|web> > read "foo" :: Float `catch` (\c -> "yay")
23:14:18 <lambdabot>   <no location info>: parse error on input `\'
23:14:20 <ksf> yes.
23:14:26 <ivanm> cjs: I used a parsing library to do that kind of stuff
23:14:28 <ksf> don't we have a -> Maybe a version?
23:14:53 <lispy|web> > (read "foo" :: Float) `catch` (\c -> "yay")
23:14:54 <lambdabot>   Couldn't match expected type `GHC.IOBase.IO a'
23:14:54 <lambdabot>         against inferred typ...
23:14:57 <ivanm> ksf: reads
23:15:01 <ivanm> @type reads
23:15:02 <lambdabot> forall a. (Read a) => String -> [(a, String)]
23:15:02 <lispy|web> ?hoogle reads
23:15:03 <lambdabot> Prelude reads :: Read a => ReadS a
23:15:03 <lambdabot> Text.Read reads :: Read a => ReadS a
23:15:03 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
23:15:12 <ivanm> ksf: then you can use a case to convert it to a maybe
23:15:17 <cjs> Basically, I'm thinking I just want to write more or less the code a regex matching engine generator would produce, right?
23:15:20 <ivanm> @hoogle (Read a) => String -> Maybe a
23:15:20 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
23:15:21 <lambdabot> Network.CGI readCookie :: (Read a, MonadCGI m) => String -> m (Maybe a)
23:15:21 <lambdabot> Network.CGI readInput :: (Read a, MonadCGI m) => String -> m (Maybe a)
23:15:29 <ivanm> cjs: probably
23:15:31 <ksf> :t listToMaybe . map fst . reads
23:15:32 <lambdabot> forall a. (Read a) => String -> Maybe a
23:15:36 <ksf> that one.
23:15:38 <ivanm> cjs: but writing the regex would probably be easier
23:15:44 <ivanm> ksf: that "one"? :p
23:16:02 <lispy|web> > listToMaybe . map fst . reads "foo" :: Maybe Float
23:16:03 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
23:16:03 <lambdabot>         against inferred typ...
23:16:15 <ivanm> lispy|web: needs a $
23:16:17 <cjs> ivanm: Probably easier, yes, but less educational. This way is only hard because I don't know how to do it, not because it's inherently difficult to do, I'm guessing.
23:16:28 <lispy|web> oh yeah, /me is tired
23:16:28 <mtnviewmark> is there a new package for locale info?  defaultTimeLocale (needed for parseTime) is in the package old-locale
23:16:34 <ivanm> @time lispy|web
23:16:34 <ksf> > listToMaybe . map fst . reads $ "foo" :: Maybe Float
23:16:36 <lambdabot>   Nothing
23:16:36 <lispy|web> > listToMaybe . map fst . reads $ "foo" :: Maybe Float
23:16:37 <lambdabot> Local time for lispy|web is Mon Nov 16 23:16:36 2009
23:16:37 <lambdabot>   Nothing
23:16:42 * ivanm wonders if that works via web interface
23:16:47 <lispy|web> > listToMaybe . map fst . reads $ "111" :: Maybe Float
23:16:48 <lambdabot>   Just 111.0
23:16:52 <ivanm> lispy|web: is that your correct time?
23:17:07 <ivanm> mtnviewmark: there's a newish locale-related package on hackage IIRC
23:17:12 <lispy|web> ivanm: that's correct
23:17:13 <cjs> ksf: Not that I cannot use read on float, because that will accept invalid numbers for this particular protocol, e.g., "1.2E-3".
23:17:23 <cjs> s/Not/Note/
23:17:24 <ivanm> lispy|web: OK, so it still works via web interface
23:17:28 <mtnviewmark> hmmmm.... but old-locale comes with Haskell Platform?
23:17:32 <mtnviewmark> I suppose I'll stick with that
23:17:54 <ksf> well, my take at it would be to use reads and annotate it with FIXME
23:18:12 <ivanm> heh
21:21:11 --- topic: '["The Monad.Reader issue #14 out now: http://themonadreader.wordpress.com/", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
21:21:11 --- topic: set by mauke on [Mon Nov 02 11:41:43 2009]
21:21:11 --- names: list (clog_ solidsnack triplez Snark DrSyzygy m-i-l-a-1 m3ga unknownmat clog Dunearhp_ hansfbaier Asztal onodrim alvarezp TacticalGrace medfly CodeBlock rgr cdiem bwwww Whitesquall1 Pthing deech novas0x2a Guest81877 ablokzijl nwf nathanic_work1 shintah omg911 shellsage Sup3rkiddo mwc mxc mtnviewmark Exteris Colours_ Pewpewarrows shapr BgPerl-VB03 SmurfOR Stefa2 otto_s blueflute SamB_XP leoncamel fracture musically_ut bos jyyou malie Raynes mike8901)
21:21:11 --- names: list (aluink Heavensrevenge aiko_ Polarina shrughes Gwern-away c_wraith augur saccade_ lispy|web caligula_ fbru02 tommd conal horms jsgf gbeshers oskimura mm_freak seancorfield trvbldn Modius Peaker Saizan Apocalisp kfish QinGW Adamant sunfun ganbold jleedev borism_ LitesterB Vq_ dolio Kapowski jmcarthur redline6561 levitation_ Cale lispy sioraiocht kpreid leimy Cobra| arvidj_ awarring ivanm Gracenotes ttmrichter aburrido stoop Philonous dcolish)
21:21:11 --- names: list (dancor ski_ EnglishGent^afk Alpounet ezrakilty kynky Spockz Kim^Walkman dibblego ksf edwardk mahogny ville ystael ketil ua jan_ guerby fhs Cthulhon| gjl fritschy camillo astrolabe Igloo shambler amgarching hellige flazz nathanic Megant_ DekuNut Aikawa sm kniu Phyx- Spaghettini rdd LeCamarade +preflex mauke jonafan cognominal Mortomes zhijie1 C-Keen arsenm @ChanServ thingwath knobo profmakx Hunner CalJohn scree jrockway Arnar mexisme smiler)
21:21:11 --- names: list (ClaudiusMaximus paolino Kambus Philippa_ kosmikus Gabbie soduko donri socpp blackdog blackh kayess_ mcclurmc a-s jayne r0bby willb emma earthy TR2N sprang det mr_ank smelk +hackagebot jones- angelixd_ lament kadoban ski gogonkt Draconx wagle whoppix kolmodin BMeph astrocub yahooooo cjs juhp cgibreak tavelram gr00vy luite Mr_Awesome mreggen PsiOmega nnunley alphecca- gnuvince zax andrewsw M| hsaliak__ mjrosenb dons pifish_ karld stepcut aempirei)
21:21:11 --- names: list (McManiaC wimt chrisdone DEVOKUN dixiecko crem da-x Elench dreixel niksnut voker57__ PeakerWork kuningas felipe_ neurocyte pikhq sereven edwtjo sbok Poeir zygoloid kw317 joed Annie|Home Counter-Strike tmug flux dilinger _Jordan_ idnar jml ahf Axman6 spoop dmwit smg newsham snorble dejones ertai EvanCarroll fnordus taruti jlouis kanalj MacCoaster byorgey Jiten kalven igorgue jlaire raim0 andun Tobsan ath ^Einstein drspider_ tamiko pcc1 emias)
21:21:11 --- names: list (deiga_ arkx Raevel ibid jvoorhis wornof BONUS_ samulihs geir_ kmeyer FauxFaux opqdonut greap nothingmuch agemo skaar stepnem gdsx magicman srcerer jystic jre2 cathper nornagon quicksilver qebab Deewiant pragma_ Innominate dionoea ath^ koninkje_away Sisu cods wang Elly majoh Ornedan epmf Taggnostr xian rasfar joga stalker borism Bleadof tew88 Bassetts nlogax snhmib blalb dino- geoaxis_ dankna Heffalump SimonRC canvon_ And[y] Esmil nablaa tilman)
21:21:11 --- names: list (Badger Jaak Twey rey_ ac Liskni_si wolverian tkr Lemmih eelco_ JaffaCake ben0x539 sieni araujo dcoutts xinming ps-auxw bind_return ToRA jelly12gen flippo wharrgarble LeoD heaumer_ deavid wisemanby _xor jabagawee Tomas Veinor alexsuraci thorkilnaur EvilTerran jbauman lhnz Trafalgard Raku^ matthew-_ Jedai djinni m4thrick Eelis eyck t Chile danopia StoneToad ijnek bumblebee waern tensorpudding sohum fihi09 jtra anders^^ baaba clanehin zhijie)
21:21:11 --- names: list (TML linkinus thoughtpolice Neronus jix burp ve pixel5 jaj alexbobp peddie loupgaroublond karihre tessier clarkb jamwt mulletron hiredman allbery_b trez eno Optimo jkramer jontore eek MyCatVerbs glith AnMaster Nereid ksandstr nipuL sjanssen duairc reltuk +lunabot saccade __marius__ tromp_ dcoutts_ davidL PHO_ inimino orbitz endojelly desp bockmabe_ beibmozoi bd_ sebas__ Laney mml`_ rapacity theclaw mux mokus_ noj +lambdabot daed brx periodic)
21:21:11 --- names: list (thetallguy alip Blub\0 loop AndyP ziman Botje drhodes welterde qwr tltstc mdordal2 mfoemmel tuukkah mfp regulate noddy midnite Zao dfeuer gOcOOl epokal ray liff mw493 Maddas Baughn nominolo|uni birkenfeld Valodim Warrigal Ferdirand marmolak tarbo_ laz0r dqd maskd absentia zaarg icee Twigathy thetallguy1 Gilly cjay Blaketh lefant p_l aavogt cygnus_ jasonmay mikste sevvie guerrilla osfameron ehamberg flori lsthemes arjanoosting poe thedward)
21:21:11 --- names: list (jims doublethink_work avysk companion_square authentic jnwhiteh equanimity erg SeaPrior _br_ bran BrianHV nimred boyscared franksh mattam dumael sproingie stroan thomastc mshaw glitch qm13_ sgf_ lavish ned mrd drbean Vulpyne electrogeek Paradox924X Nafai mercury^ mle olsner shortcircuit shachaf BONUS wormwood integral shepheb Milo- fxr cdfh_ Nanar danderson Aisling poucet jvogel_ wdonnelly harlekin lanaer Khisanth ido dek5 sunnavy nasloc__)
21:21:11 --- names: list (Lycurgus saiam anji_ ahihi Stephan202 mmmulani aleator prigaux koeien pettter mornfall impl _plcs_ GNU\colossus sebbe1991 ggreg_ mjv da-xw wagle_home alexander2 webframp Paks mikm suiside kakeman dogmaT jfredett int-e tumult netcat jfoutz SubStack droidcore mlh kar-1 desu qed koala_man malouin mmmdonuts Boney therp anekos jql)
23:28:47 * Axman6 *rages*
23:29:02 <Axman6> are there any good browsers for linux? firefox is pathetic and slow
23:29:35 <ksf> links
23:29:38 <ksf> or uzbl
23:29:39 <ivanm> Axman6: works for me...
23:29:52 <ivanm> it's slow to load, but that's only because of the number of tabs I have open...
23:29:52 <Axman6> i thought there was chrome for linux, and was extremely disappointed to find out there isn't
23:29:55 <ksf> but then, you could just write one in haskell.
23:29:59 <ivanm> Axman6: there's chromium
23:30:12 <ivanm> which is chrome - advertising AFAICT
23:30:23 <ivanm> Axman6: then there's the webkit-based browsers
23:30:32 <ivanm> Axman6: but most people use firefox still due to the customisability
23:30:36 <ivanm> extensions ftw! ;-)
23:31:07 <Axman6> fuck extensions
23:31:17 <cjs> Well, there's the state machine I was looking for. But it looks more like Scheme than Haskell....   http://hpaste.org/fastcgi/hpaste.fcgi/view?id=12217#a12217
23:31:25 <ksf> you could start by converting yi into a text browser for compliant xhtml
23:32:13 <ivanm> Axman6: *shrug* they're the main reason I stick with ff
23:32:15 <ksf> cjs, if you want to get into parsing, I'd recommend this: http://www.cs.uu.nl/research/techreps/repo/CS-2008/2008-044.pdf
23:33:13 <cjs> Well, I already know how to write Monadic parsers. I just want to avoid doing a full-blown one for something as simple as this.
23:34:58 <ksf> being monadic doesnt' make them complex
23:35:14 <ksf> they're going to be faster and have a smaller assembly codeprint than a regex machine
23:35:49 <cjs> So you can do it in fewer lines than I've got up on hpaste?
23:36:02 <cjs> That's exactly what I'm asking for.
23:36:04 <ksf> if you want something tiny, you can use polyparse or such
23:36:14 <cjs> It's no longer tiny if I have to pull in a library.
23:36:37 <ksf> erm it's going to be more readable.
23:37:32 <cjs> Really?
23:54:16 <yitz> cjs: it's not too hard to be more readable than a regex.
23:57:14 <yitz> ksf: oh dear, that link is a paper about building a parser library from scratch. that's certainly not ksf needs.
23:57:26 <ivanm> heh
23:57:31 <ivanm> what does ksf want?
23:57:32 <chrisdone> Axman6: I've been using chromium on ubuntu. won't be long before it picks up extension support (like Chrome). it's also fast. but then so is opera
23:57:49 <ivanm> chrisdone: though at least chromium pretends to be open-source...
23:58:00 <chrisdone> ivanm: "pretends"?
23:58:24 <yitz> ksf: i one of those people who just uses parsec out of ignorance. is there a link that summarize the libraries available, and their relative strengths and weaknesses?
23:58:26 <dolio> dolio knows what dolio wants.
23:58:33 <ivanm> chrisdone: well, how much of it is a community thing, etc. and how much is google, etc.?
23:58:39 <ivanm> dolio: that's nice...
23:58:51 <ivanm> yitz: parsing libraries?
23:59:25 <lispy|web> ivanm: for the record, cabal recognizes .y files and runs happy on them
23:59:26 <yitz> s/ksf/cjs/
23:59:31 <ivanm> lispy|web: \o/
23:59:33 <lispy|web> ivanm: so it "just works"
23:59:42 <ivanm> yitz: heh, I was wondering why you were suddenly pinging ksf...
23:59:44 <lispy|web> had to read the cabal manual to figure this out, but it's nice
