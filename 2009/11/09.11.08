00:00:46 <copumpkin> yeah, the whole statement was false
00:02:46 <copumpkin> fixed!
00:08:47 <copumpkin> got sidetracked a moment to prove that forall a. Vec a 0 is finite :)
00:13:48 <ddarius> Vec a n ~ n -> a = a^n
00:17:19 <copumpkin> yep!
00:40:58 <copumpkin> Cale: yay, success!
01:08:05 <aeron> are there any good builtins to grab n lines of input?
01:09:16 <Jedai> aeron: replicateM n getLine
01:09:38 <aeron> thank you jedai
01:11:22 <Jedai> aeron: You're welcome, that's not really a builtin but it's easy enough to use :) (and the channel is very split right now, so you might not get another answer as fast as usual)
01:12:37 <aeron> Jedai: no, it actually helps me quite a bit. I'm trying to wrap my head around all of these monad operations, so it's especially useful
01:15:38 <aeron> Jedai: So, if I want to read in a bunch of lines and read them in as Ints (and I can assume input will be well-formed), would I just read in that way and then use something like
01:15:56 <aeron> lineNums <- mapM (\x -> read x :: Int) lines
01:16:15 <aeron> assuming lines was the result of: lines <- replicateM 5 getLines
01:19:25 <Jedai> aeron: If you just want to do that, using "replicateM n readLn" directly might be even better
01:20:10 <Jedai> aeron: besides your code wouldn't work : read is not monadic so your use of a do-binding and of mapM is an error
01:20:39 <Jedai> you would use a normal "let nums :: [Int] = map read lines" instead
01:21:57 <aeron> Jedai: thanks, I wasn't sure how that type hinting would work for something like that; also, didn't know about readLn :)
01:23:02 <Jedai> Well to be honest this particular type hint would require an extension since type hint in a pattern (which nums is) is not Haskell98
01:23:29 <Jedai> If you wanted to be Haskell98 compatible you could do :
01:24:02 <Jedai> let nums = map read lines :: [Int]
01:24:33 <Jedai> aeron: or put a separate signature line : let nums :: [Int]; nums = map read lines
01:24:57 <aeron> Jedai: alright makes sense
01:27:16 <Jedai> aeron: the extension is ScopedTypeVariables (it covers a bit more ground than just type hinting in pattern in fact) and it's really nice for some usages, in particular in a do-binding where putting the signature on the other part would means having to explicit the monad too
01:27:43 <Jedai> with it you can do "lineNums :: [Int] <- replicateM 5 readLn"
01:29:44 <Jedai> It's probably one of those extension that will make it into Haskell' without much of a problem
01:30:27 <aeron> Jedai: then in a do statement, how would I do it directly (e.g., lines <- replicateM 5 readLn :: [Int]) or something without needing the extension?
01:31:21 <Jedai> aeron: you would have to do "lines <- replicateM 5 readLn :: IO [Int]"
01:32:18 <Jedai> or more complicated (and sometimes impossible to express) in more complicated setups/monads
01:32:33 <aeron> and then to use it I'd have to use mapM against the list
01:32:37 <aeron> perfect, thanks :)
01:33:29 <Jedai> It is also often the case that you don't need to put those constraints explicitly because an operation you do on lines further on constraint its type sufficiently
01:34:08 <Jedai> aeron: No, the type of the list would be the same, and mapM don't operate on monadic lists anyway
01:34:20 <Jedai> @type mapM
01:34:25 <Jedai> :t mapM
01:34:46 <Jedai> Oops... We're splitted from lambdabot :(
01:34:55 <aeron> Jedai: wait, but wouldn't the list be IO [Int] so I'd have to use a monadic map?
01:35:03 <aeron> I'm confused why it's different here :0
01:35:22 --- mode: irc.freenode.net set +o ChanServ
01:35:31 <Jedai> mapM :: (Monad m) => (a -> m b) -> [a] -> m [b]
01:35:45 <Jedai> aeron: this is the type of mapM
01:35:52 <aeron> oh, okay now it does make sense :)
01:36:03 <aeron> I was confused because the function I'm mapping is an IO action
01:36:46 <mmorrow> @pl (\o->o o)(\o->o o)
01:36:47 <lambdabot> ap id id (ap id id)
01:36:47 <lambdabot> optimization suspended, use @pl-resume to continue.
01:36:47 <Phyx-> medfly: http://www.haskell.org/haskellwiki/Pointfree has more details
01:36:47 <mmorrow> @. unpl pl (\o->o o)(\o->o o)
01:36:49 <Jedai> aeron: Right you use mapM to map a monadic action on a normal list and you get a list of results in the monad
01:36:51 <lambdabot>  Parse error at end of input
01:36:59 <aeron> yeah makes sense now
01:37:02 <mmorrow> @unpl ap id id (ap id id)
01:37:03 <lambdabot> (\ g h i -> h >>= \ g -> i >>= \ e -> return (g g e)) (\ j -> j) (\ a -> a) (\ b -> b) ((\ c -> c) >>= \ l -> (\ d -> d) >>= \ k -> return (l k))
01:37:03 <Phyx-> eek, we're being invaded by joins :P
01:37:15 <mmorrow> @. pl unpl ap id id (ap id id)
01:37:15 <lambdabot> join (join id) ((id >>=) . (return .) =<< id)
01:37:21 <mmorrow> @. unpl pl unpl ap id id (ap id id)
01:37:21 <lambdabot> unpl (\ g h -> g >>= \ e -> h >>= \ d -> return (e d)) (\ a -> a) (\ b -> b) ((\ c -> c) >>= \ j -> j)
01:37:28 <Phyx-> what's with the @. ?
01:37:28 <mmorrow> @ unpl p. l unpl ap id id (ap id id)
01:37:32 <copumpkin> mmorrow wants to kill lambdabot again
01:37:33 <mmorrow> @. unpl p . l unpl ap id id (ap id id)
01:37:33 <lambdabot> Plugin `compose' failed with: Unknown command: "p"
01:37:35 <copumpkin> for another 2 days :P
01:37:41 <mmorrow> @. unpl . pl unpl ap id id (ap id id)
01:37:41 <lambdabot> (((\ a -> a) >>= \ h -> h) >>= \ f -> f) (\ l -> (\ b -> b) >>= (((\ e -> e) >>= \ d r -> return (d r)) l))
01:37:51 <copumpkin> mmorrow: (it still hasn't been fixed as far as I know)
01:37:51 <mmorrow> i wonder what this stabilizes to
01:37:57 <mmorrow> copumpkin: heh
01:38:15 <Phyx-> awww i have to re-identify with nickserv
01:38:16 <Phyx-> booooo
01:38:17 <aefjt> Haskell translation party?
01:38:25 <mmorrow> @. pl . unpl . pl unpl ap id id (ap id id)
01:38:25 <lambdabot> join (join id) ((id >>=) . ((return .) =<< id))
01:38:33 <mmorrow> @. unpl . pl . unpl . pl unpl ap id id (ap id id)
01:38:33 <lambdabot> (((\ a -> a) >>= \ h -> h) >>= \ f -> f) (\ l -> (\ b -> b) >>= (((\ e -> e) >>= \ d r -> return (d r)) l))
01:38:43 <Phyx-> > map (+)
01:38:45 <lambdabot>   []->
01:38:45 <lambdabot>    []
01:38:45 <lambdabot>  [-2]->
01:38:45 <lambdabot>    [{-3->-5;-2->-4;-1->-3;0->-2;1->-1;2->0;3->1}]
01:38:45 <lambdabot>  [-2,-...
01:38:46 <mmorrow> aw, it's done
01:38:56 <mmorrow> @unpl ap id id (ap id id)
01:38:56 <lambdabot> (\ g h i -> h >>= \ g -> i >>= \ e -> return (g g e)) (\ j -> j) (\ a -> a) (\ b -> b) ((\ c -> c) >>= \ l -> (\ d -> d) >>= \ k -> return (l k))
01:38:57 <mmorrow> one
01:39:08 <mmorrow> @. pl unpl ap id id (ap id id)
01:39:08 <lambdabot> join (join id) ((id >>=) . (return .) =<< id)
01:39:09 <nolrai_FG> OW
01:39:14 <mmorrow> @. unpl . pl unpl ap id id (ap id id)
01:39:14 <lambdabot> (((\ a -> a) >>= \ h -> h) >>= \ f -> f) (\ l -> (\ b -> b) >>= (((\ e -> e) >>= \ d r -> return (d r)) l))
01:39:17 <nolrai_FG> > map (id)
01:39:18 <lambdabot>   {[]->[];[()]->[()];[(),()]->[(),()];[(),(),()]->[(),(),()]}
01:39:18 <mmorrow> @. pl . unpl . pl unpl ap id id (ap id id)
01:39:19 <lambdabot> join (join id) ((id >>=) . ((return .) =<< id))
01:39:22 <mmorrow> done
01:39:45 <mmorrow> @type join (join id) ((id >>=) . ((return .) =<< id))
01:39:45 <lambdabot>     Occurs check: cannot construct the infinite type:
01:39:46 <lambdabot>       m = (->) (m (m a))
01:39:46 <lambdabot>     Probable cause: `id' is applied to too few arguments
01:39:54 <Phyx-> lol
01:40:05 <Phyx-> fail
01:40:15 <nolrai_FG> > map (+1)
01:40:16 <lambdabot>   []->
01:40:16 <lambdabot>    []
01:40:16 <lambdabot>  [-2]->
01:40:16 <lambdabot>    [-1]
01:40:16 <lambdabot>  [-2,-1]->
01:40:18 <lambdabot> [4 @more lines]
01:40:24 <mmorrow> from (a = a -> r) to (m = (->) (m (m a)))
01:40:45 <nolrai_FG> Is that what it is doing?
01:40:46 <Jedai> Phyx-: What does it use to do this ? Quickcheck ?
01:40:49 <mmorrow> @type (((\ a -> a) >>= \ h -> h) >>= \ f -> f) (\ l -> (\ b -> b) >>= (((\ e -> e) >>= \ d r -> return (d r)) l))
01:40:50 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
01:40:50 <lambdabot>     Probable cause: `h' is applied to too many arguments
01:40:50 <lambdabot>     In the expression: h
01:41:09 <mmorrow> it's an infinite type that haskell would reject to begin with, then @pl and @unpl have their way with it
01:41:20 <Vq> > show id
01:41:21 <lambdabot>   "{()->()}"
01:41:30 <Phyx-> Jedai: i have no idea, I found out about it yesterday myself, But yeah, it might be quickcheck
01:41:43 <mmorrow> nolrai_FG: oh. :)
01:42:07 <nolrai_FG> Wait a show on functions? how?
01:42:08 <mmorrow> what lib is this show instance from?
01:42:14 <Phyx-> it used to jus return <<Function>> or something
01:42:25 <mmorrow> > not
01:42:25 <lambdabot>   {True->False;False->True}
01:42:31 <Phyx-> > return :: a -> IO a
01:42:33 <lambdabot>   {()-><IO ()>}
01:42:50 <mmorrow> > either (either Right Left) (either Right Left)
01:42:51 <Vq> it's nicely done
01:42:51 <lambdabot>   Left (Left ())->
01:42:51 <lambdabot>    Right ()
01:42:51 <lambdabot>  Left (Right ())->
01:42:51 <lambdabot>    Left ()
01:42:51 <lambdabot>  Right (Left ())...
01:42:58 <mmorrow> > either Right Left
01:42:59 <lambdabot>   {Left ()->Right ();Right ()->Left ()}
01:43:01 <mmorrow> hehe
01:43:05 <mmorrow> sweet
01:43:10 <Jedai> nolrai_FG: Very clearly its using something like Quickcheck to generate possible arguments and show all of them under a certain size
01:43:19 <nolrai_FG> > reverse
01:43:20 <lambdabot>   {[]->[];[()]->[()];[(),()]->[(),()];[(),(),()]->[(),(),()]}
01:43:44 <Vq> > reverse :: [Int] -> [Int]
01:43:45 <lambdabot>   []->
01:43:45 <lambdabot>    []
01:43:45 <lambdabot>  [-2]->
01:43:45 <lambdabot>    [-2]
01:43:45 <lambdabot>  [-2,-1]->
01:43:47 <lambdabot> [4 @more lines]
01:43:54 <Vq> @more
01:43:54 <lambdabot>    [-1,-2]
01:43:54 <lambdabot>  [-2,-1,0]->
01:43:54 <lambdabot>    [0,-1,-2]
01:43:55 <Phyx-> ack, that's not really readable :(
01:43:55 <lambdabot> ...
01:43:55 <aefjt> @src id
01:43:56 <lambdabot> id x = x
01:44:04 <Phyx-> > liftM (+)
01:44:06 <lambdabot>   No instances for (Test.SmallCheck.Serial (m a1),
01:44:06 <Jedai> nolrai_FG: it's typeclass magic, not even really complicated, look at how Quickcheck work (the instances) and you should get it fast
01:44:06 <lambdabot>                    GHC.Sho...
01:44:09 <Phyx-> hehehe
01:44:19 <Phyx-> smallcheck!
01:44:39 <Phyx-> guess that solves it, lol
01:44:45 <mmorrow> > (\t -> fix (\me -> me {subForest = [t,me,t]}))
01:44:46 <lambdabot>   No instance for (Test.SmallCheck.Serial (Data.Tree.Tree a))
01:44:46 <lambdabot>    arising from...
01:44:54 <nolrai_FG> > (+1)
01:44:55 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
01:44:55 <mmorrow> aha
01:45:14 <Phyx-> > undefined
01:45:16 <lambdabot>   * Exception: Prelude.undefined
01:45:17 <Jedai> Phyx-: Right, it seems too systematic for QuickCheck
01:45:24 <nolrai_FG> That is really cool. Not perfect but cool.
01:45:30 <mmorrow> > fix . (:)
01:45:35 <lambdabot>   mueval-core: Time limit exceeded
01:45:45 <Phyx-> mmorrow: lol, really now. :P
01:45:55 <mmorrow> :)
01:46:29 <mmorrow> > \f -> fix (fix f:)
01:46:31 <nolrai_FG> :t fix . (:)
01:46:34 <lambdabot>   mueval-core: Time limit exceeded
01:46:35 <lambdabot> forall a. a -> [a]
01:47:03 <nolrai_FG> > fix . (:) $ 1
01:47:05 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
01:47:15 <nolrai_FG> > fix . (:) $ ()
01:47:15 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
01:47:27 <nolrai_FG> So why doesnt it show that?
01:48:01 <Jedai> nolrai_FG: it's repeat
01:48:03 <Phyx-> 5*C hrm.. starting to get cold...
01:48:05 <Jedai> > repeat
01:48:08 <mmorrow> @djinn a -> Not(Not(Not(a)))
01:48:09 <lambdabot> -- f cannot be realized.
01:48:10 <lambdabot>   mueval-core: Time limit exceeded
01:48:15 <mmorrow> @djinn Not a -> Not(Not(Not(a)))
01:48:15 <lambdabot> f a b = void (b a)
01:48:19 <mmorrow> gah
01:48:50 <sticazzi> Hello! Is there some module that defines a composition operator which is the flip of (.) ?   I've defined mine.. f1 ==> f2 = f2 . f1 but if there's someone who wrote the same I'd rather reuse it
01:48:56 <Jedai> > repeat :: [()]
01:48:58 <Phyx-> nolrai_FG: because it keeps applying (: ()) over and over again
01:48:58 <lambdabot>   Couldn't match expected type `[()]'
01:48:59 <lambdabot>         against inferred type `a -> [a]'
01:49:19 <nolrai_FG> what is "Not"?
01:49:34 <Jedai> > repeat :: () -> [()]
01:49:42 <lambdabot>   mueval: ExitFailure 1
01:49:51 <Phyx-> sticazzi: just define (,) = flip (.) or the like
01:50:01 <Phyx-> err (,) is taken though :P tupples
01:50:23 <nolrai_FG> he did (==>)
01:50:46 <nolrai_FG> (althoug that is used for other things in ?Arrow? somthing)
01:51:12 <Phyx-> > dataTypeOf (Not undefined)
01:51:14 <lambdabot>   Not in scope: data constructor `Not'
01:51:16 <nolrai_FG> > show
01:51:18 <lambdabot>   {()->"()"}
01:51:25 <Phyx-> guess Not is nothing nolrai_FG
01:51:55 <nolrai_FG> > fix
01:51:59 <lambdabot>   mueval-core: Time limit exceeded
01:52:10 <nolrai_FG> > (.)
01:52:11 <lambdabot>   No instances for (Test.SmallCheck.Serial (f a),
01:52:11 <lambdabot>                    GHC.Show...
01:52:21 <Jedai> nolrai_FG: Not is the not of logic, (not A == A -> False)
01:52:49 <nolrai_FG> > (.) :: (a->b) -> (b-> c) -> a -> c
01:52:50 <lambdabot>   Couldn't match expected type `b' against inferred type `a'
01:52:51 <lambdabot>    `b' is a rigi...
01:52:51 <sticazzi> (.) is not very easy when composing a very long transformation pipeline
01:53:02 <Jedai> :t void
01:53:03 <lambdabot> Not in scope: `void'
01:53:05 <mmorrow> > fix (\k a -> fmap ($ k a) a)
01:53:06 <lambdabot>   No instances for (Test.SmallCheck.Serial (f (f b -> b)),
01:53:06 <lambdabot>                   ...
01:53:07 <sticazzi> s/not very easy/not very easy to read/
01:53:10 <mmorrow> awww
01:53:16 <mmorrow> @let loeb fix (\k a -> fmap ($ k a) a)
01:53:16 <lambdabot>   Parse error: SemiColon
01:53:18 <mmorrow> @let loeb = fix (\k a -> fmap ($ k a) a)
01:53:19 <lambdabot>  Defined.
01:53:46 <nolrai_FG> > (.) :: (b->c) -> (a->b) -> a -> c
01:53:48 <lambdabot>   {{()->()}->{{()->()}->{()->()}}}
01:54:00 <Jedai> sticazzi: habits probably but I find it pretty readable, what's your problem with it ? Would you prefer to write your pipeline in the other direction ?
01:54:09 <mmorrow> > loeb [\x->(x!!1)*x(!!3),const 4,sum.take(2),const 9]
01:54:10 <lambdabot>   Couldn't match expected type `([a] -> a) -> b'
01:54:10 <lambdabot>         against inferred typ...
01:54:46 <Jedai> sticazzi: You could use (>>>) in this case
01:54:51 <nolrai_FG> Jedai: thanks.
01:54:54 <mmorrow> > loeb [\x->(x!!1)*x(!!3),const 4,(!!3),const 9]
01:54:55 <lambdabot>   Couldn't match expected type `([a] -> a) -> b'
01:54:55 <lambdabot>         against inferred typ...
01:54:56 <nolrai_FG> :t >>>
01:54:57 <lambdabot> parse error on input `>>>'
01:54:57 <mmorrow> gah
01:55:03 <nolrai_FG> :t (>>>)
01:55:04 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
01:55:12 <mmorrow> > loeb [(!!1),const 8]
01:55:13 <lambdabot>   [8,8]
01:55:16 <jlaire> > loeb [\x->(x!!1)*(x!!3),const 4,(!!3),const 9]
01:55:18 <lambdabot>   [36,4,9,9]
01:55:19 <mmorrow> arg
01:55:22 <sticazzi> Jedai, yeah.. that's correct
01:55:25 <mmorrow> > loeb [\x->(x!!1)*(x!!3),const 4,sum.take(2),const 9]
01:55:26 <lambdabot>   [36,4,40,9]
01:55:29 <Phyx-> sticazzi: that depends on how you write it
01:55:38 <nolrai_FG> haskel has a catagory type class?
01:55:51 <Phyx-> sticazzi: putting each composition on a new lines makes it alot more readble
01:56:03 <Jedai> nolrai_FG: Now it has one (since the 6.10 it is in the platform at least)
01:56:15 <Phyx-> nolrai_FG: Control.Category?
01:56:36 <mmorrow> > loeb :: [[a] -> a] -> [a]
01:56:38 <lambdabot>   * Exception: stack overflow
01:56:42 <aefjt> Are (first year) courses with Haskell any good?
01:56:44 <Phyx-> @type loeb
01:56:46 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
01:56:54 <Phyx-> hm
01:57:00 <mmorrow> > loeb :: [[Int] -> Int] -> [Int]
01:57:02 <lambdabot>   * Exception: stack overflow
01:57:03 <Phyx-> @hoogle loeb --info
01:57:04 <lambdabot> No results found
01:57:10 <jlaire> @src loeb
01:57:11 <lambdabot> Source not found. That's something I cannot allow to happen.
01:57:12 <mmorrow>  @let loeb = fix (\k a -> fmap ($ k a) a)
01:57:12 <Phyx-> must be locally defined
01:57:18 <Jedai> aefjt: Well it really depends more on the course and the professor
01:57:22 <mmorrow>  loeb a = fmap ($ loeb a) a
01:57:40 <mmorrow> > loeb [(!!1),const 8]
01:57:41 <lambdabot>   [8,8]
01:57:44 <mmorrow> > loeb [(!!0),const 8]
01:57:49 <lambdabot>   mueval: ExitFailure 1
01:58:03 <nolrai_FG> whats the differnce between Catagory, and Monoid?
01:58:16 <opqdonut> Monoid is over one type, category over multiple
01:58:22 <opqdonut> :t mconcat
01:58:23 <lambdabot> forall a. (Monoid a) => [a] -> a
01:58:23 <Jedai> aefjt: I think Haskell is a pretty good language to introduce serious beginners to programming but you need a good teacher
01:58:30 <opqdonut> :t mappend
01:58:30 <lambdabot> forall a. (Monoid a) => a -> a -> a
01:58:33 <sticazzi> Jedai, that looks interesting but maybe in a bit.. I'm still learning the language to understand that signature (specifically I'm confused by the * in there)
01:58:35 <opqdonut> ^ that's the monoid operation
01:58:37 <nolrai_FG> Right.
01:58:39 <opqdonut> :t (>>>)
01:58:40 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
01:58:44 <mmorrow> @type [(.),mappend]
01:58:45 <lambdabot> forall b. (Monoid b) => [(b -> b) -> (b -> b) -> b -> b]
01:58:48 <opqdonut> that's the arrow operation
01:58:52 <opqdonut> *category
01:59:30 <nolrai_FG> Okay.
01:59:33 <mmorrow> @type ((.),[(.),mappend])
01:59:34 <lambdabot> forall a b (f :: * -> *) b1. (Functor f, Monoid b1) => ((a -> b) -> f a -> f b, [(b1 -> b1) -> (b1 -> b1) -> b1 -> b1])
01:59:34 <opqdonut> sticazzi: you can just ignore the "forall (f :: * -> *) b." part really
01:59:41 <mmorrow> wut
01:59:52 <copumpkin> sticazzi: interesting nick
02:00:04 <Jedai> sticazzi: Don't worry about that, Just remember that (a -> b) is an instance of category, so (>>>) type for this instance becomes "(a -> b) -> (b -> c) -> (a -> c)"
02:00:06 <mmorrow> (.) is re-Caleskellated
02:00:25 <mmorrow> @type (.)
02:00:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:00:45 <Jedai> sticazzi: In other words, it's just (.) reversed (for the case that concerns you)
02:01:06 <Jedai> > (+5) >>> (*2) $ 10
02:01:08 <lambdabot>   30
02:01:08 <sticazzi> Jedai: nice! I take it this works for more than just functions then..
02:01:12 <Jafet> Jedai: sure
02:01:40 <Jedai> sticazzi: Right, but you probably don't need to worry about that before you learn about arrows anyway
02:02:05 <sticazzi> what's the module I need to import?
02:02:16 <Jedai> sticazzi: Control.Category
02:02:51 <Jedai> sticazzi: Or you could import Control.Arrow directly, even if you don't use Arrow it has some nice goodies like (&&&) and (***)
02:03:06 * Phyx- loves his (***)
02:03:25 <Jedai> > (+5) &&& (*2) $ 10
02:03:27 <lambdabot>   (15,20)
02:04:34 * sticazzi will look into arrows.. sounds interesting stuff
02:04:58 <Phyx-> > id *** (+1) $ (0,0)
02:04:59 <lambdabot>   (0,1)
02:05:21 <Jedai> > second (+1) $ (0,0)
02:05:22 <lambdabot>   (0,1)
02:10:43 <sticazzi> second :: (Arrow a) => a b c -> a (d, b) (d, c)      -- what's a good source of documentation to understand what 'a b c' means.. I haven't seen multiple types thrown around like this before... I guess in this case 'a' is a type constructor?
02:11:26 <Jedai> sticazzi: Right, this is parametric polymorphism with type constructor
02:11:39 <Jedai> sticazzi: like the monad functions
02:11:47 <Jedai> :t (>>=)
02:11:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:12:06 <PeakerWork> sticazzi: "a" is an arrow class instance.  b and c are the type arguments. in the case of arrows, the first one means "input type" and the latter means "output type", pretty much
02:12:07 <Jedai> sticazzi: Here m is a type constructor, instance of Monad
02:12:38 <jlaire> if a = (->), then a b c = b -> c
02:13:00 <PeakerWork> sticazzi: so "a b c" kinda means "an arrow a from type b to type c".  Sometimes, instead of the type variable "a", the type variable (~>) is used, and then you can replace: Arrow a => a b c   with:   Arrow (~>) => b ~> c
02:13:05 <EnglishGent^afk> morning all :)
02:13:16 <Jedai> sticazzi: You note that a monad is of kind (* -> *) which means it takes only one type parameter whereas an arrow takes two (it's kind is (* -> * -> *))
02:13:57 <PeakerWork> Arrow is like a Monad that is also parametrized on the input type (and cannot join).  More like Applicative that's also parametrized on the input type, then, I guess
02:14:35 <sticazzi> makes sense, sort of.. I think I have a fair amount of reading up to do :D
02:16:57 <sticazzi> I'm getting hungry and I'll go get some breakfast.. thanks for all your help!
02:17:40 <Axman6> sticazzi: heh, you sound a lot like me :)
02:26:53 <pao> Hi all :-)
02:27:42 <Axman6> o/ pao
02:28:36 <pao> I was reading the implementation for foldl' ... I see there's a ifdef for GHC ... is that for performance reasons? I cannot really grasp the need for a slightlty different version...
02:28:59 <Pellwurst> i am trying to install ghc 6.10.4 on an ubuntu 9.04, but i always get "libgmp.so.3: cannot open shared object file: No such file or directory"
02:29:05 <pao> @hpaste
02:29:06 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
02:29:07 <Pellwurst> how can i solve this problem?
02:29:43 <pao> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4857#a4857
02:29:49 <pao> that's the relevant paste
02:30:02 <Axman6> pao: do you have gmp installed?
02:30:09 <Axman6> uh, Pellwurst, not pao
02:31:00 <Pellwurst> Axman6: yes, i have
02:31:10 <Axman6> how odd
02:31:38 <Jedai> Axman6: Maybe a version problem ?
02:31:51 <Axman6> could be
02:32:02 <Axman6> i stay away from linux whereever possible
02:32:05 <pao> Pellwurst: how did you installed ghc?
02:32:08 <medfly> Axman6, bah!
02:32:15 <pao> Axman6: shame on you :-)
02:32:17 <medfly> Axman6, what do you use?
02:32:20 <medfly> shame on you, yes!
02:32:24 <Axman6> i don't like pain, and i like productivity
02:32:28 <Axman6> so, i use OS X :)
02:32:33 <Axman6> (and the BSD's)
02:32:39 <medfly> on a desktop!
02:32:49 <Axman6> not on desktops
02:32:50 <Pellwurst> pao: well i've got the ghc 6.8 at the moment and installed that via apt
02:32:50 <Jedai> Axman6: Linux is fine :)
02:33:05 <Pellwurst> and i'd like to update that to 6.10.4
02:33:14 <Axman6> but i feel that FreeBSD makes a far better server than linux does, and that OS X puts linux to shame on the desktop
02:33:16 <medfly> Pellwurst, I see a libgmp on the package system (though I use a different version of ubuntu)
02:33:35 <Jedai> Pellwurst: You could upgrade to Ubuntu 9.10... (a little bit too much though...)
02:33:38 <medfly> Axman6, yes, especially the incredibly high cost and the need for a special computer
02:33:44 <medfly> Axman6, just, shame!
02:34:08 <inad922> hello
02:34:09 <Pellwurst> is it possible to simply install 6.10 via apt as well?
02:34:13 <Jedai> Axman6: Well I like my XMonad/KDE desktop
02:34:15 <Axman6> if the linux world could get its act together, i might like it
02:34:29 <Axman6> Jedai: so does FreeBSD
02:34:31 <medfly> Pellwurst, you can try, but they usually have old versions.
02:34:41 <Axman6> anyway, we're getting off topic
02:34:44 <inad922> Could someone tell me whats the type of (<-) that 1 uses for example at "x <- getLine"?
02:34:57 <medfly> @type (<-)
02:34:58 <lambdabot> parse error on input `<-'
02:35:00 <medfly> :(
02:35:16 <inad922> yeah ghci couldn`t tell me either
02:35:31 <Axman6> inad922: it doesn't have a type. but it translates into something else: do {x <- getLine; print x} --> getLine >>= \x -> print x
02:35:36 <Jedai> medfly: 6.10 is on Ubuntu 9.10, just in time for ghc6.12 to be released !!
02:35:47 <Axman6> heh
02:35:50 <medfly> woo!!!!
02:35:53 <inad922> ow
02:35:56 <inad922> thanks Axman6
02:36:06 <Axman6> inad922:  do you know about monads?
02:36:10 <rasfar> it's really just an HCI issue.  bsd, linux, ... if you get the right frontend, there's plenty of power and flexibility in the OS proper.
02:36:21 <Jedai> Pellwurst: How are you trying to install GHC ? The binary package ?
02:36:26 <inad922> yes I know what >>=(bind) is
02:36:53 <Jafet> <- isn't an operator, it's syntax
02:37:14 <Pellwurst> Jedai: yes
02:37:53 <Jedai> inad922: do-notation is purely syntax sugar, if you're curious, the Haskell report contains a complete description of how it is translated to real Haskell code (with >>= and >>)
02:37:58 <inad922> Axman6: but the second 1 is still a IO () -> IO () function or I am missing something?
02:38:06 <Axman6> inad922: well, do notation is sugar for >>= and >>
02:38:19 <Axman6> inad922: what do you mean?
02:38:19 <inad922> whats >> btw?
02:38:22 <Axman6> second what?
02:38:28 <Axman6> @src (>>)
02:38:29 <lambdabot> m >> k      = m >>= \_ -> k
02:38:41 <Axman6> just runs the first argument, and returns the second
02:38:43 <Jedai> inad922: getLine is a IO action, its type is not "IO () -> IO ()" but just "IO String"
02:38:46 <inad922> getLine >>= \x -> print x
02:38:48 <Axman6> > Just 4 >> Just 5
02:38:48 <lambdabot>   Just 5
02:38:53 <Axman6> > Nothing >> Just 5
02:38:54 <lambdabot>   Nothing
02:40:14 <inad922> but print has type a -> IO () and getLine IO String so with >>= isnt it combined into an IO String -> IO String?
02:40:26 <Jedai> inad922: No
02:40:30 <Jedai> :t (>>=)
02:40:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:41:10 <Pellwurst> Jedai: that's what it says: http://pastebin.com/m52867806
02:41:10 <Jedai> inad922: Replace m by IO, a by String and b by () and you'll see that the result is an "IO ()" action
02:41:39 <inad922> I dont know this forall syntax there
02:42:16 <Axman6> inad922: forget everything up to the .
02:42:27 <Jedai> inad922: Forget the forall and upt to the dot
02:42:47 <inad922> ok
02:42:54 <Jedai> (>>=) :: (Monad m) => m a -> (a -> m b) -> m b
02:43:00 <inad922> so basically its a return value of type IO ()
02:43:36 <Jedai> inad922: Yes, when you combine getLine and print with (>>=), you get a value of type "IO ()"
02:44:02 <Jedai> :t (getLine >>= print)
02:44:04 <lambdabot> IO ()
02:45:06 <Jedai> inad922: From two IO action, (>>=) has created one which will do its two component sequentially, transmitting information from the first to the second
02:45:33 <inad922> umm ok I seem to understand this but I still dont know what (<-) does at "x <- getLine"
02:46:08 <Jedai> inad922: It allows you to name the results of running getLine for the rest of the do-block
02:46:19 <inad922> It seems like an IO String -> String function
02:46:30 <Jedai> inad922: it's just syntactic sugar, it has no type !!!!!!!!!!
02:46:37 <inad922> umm
02:46:38 <inad922> ok
02:46:52 <inad922> but why not ? :)
02:48:08 <Jedai> inad922: because it isn't... because do-notation is just a convenient way to note monadic code, (<-) has no more type than (=) has a type or let, or data...
02:48:14 <maltem> inad922, it binds the variable on its left, i.e. it is not a function
02:48:28 <maltem> inad922, just like \ (lambda) is not
02:49:35 <Axman6> inad922: can you tell me what the type of = is?
02:53:54 <inad922> hmm no I dont. But in other languages IO doesnt appear as somekind of magic, thats why I try to understand this stuff
02:54:18 <Jafet> Actually, IO is magic in other languages more than in Haskell, where it is only advanced technology.
02:55:08 <medfly> lol...
02:55:20 <medfly> Haskell is less superstitious
02:56:01 <Jafet> Until you zap the unsafe wand
02:56:43 <Axman6> inad922: http://random.axman6.com/blog/?page_id=70
02:57:12 <Jafet> Heresy! Procure the stakes
02:58:14 <ehamberg> Axman6: your website is beautiful! ^__^
02:58:26 <Axman6> heh, thanks. i didn't design it however :)
03:00:59 <medfly> Axman6, heretic, your 7th example of code on that webpage has a typo
03:01:11 <Axman6> what is it?
03:01:18 <medfly> you use "str" instead of say, str1.
03:01:24 <Axman6> thanks
03:01:33 <medfly> thanks for the post
03:01:34 <Jafet> I'm sure he's proven it correct, anyhow
03:02:18 <Jafet> What's with the spurious newlines in the code examples?
03:03:22 <ehamberg> Axman6: "So what is we want to get something back from out function" – i guess that should be "what if" and "our function"?
03:03:36 <Axman6> indeed
03:03:49 <Axman6> see, i've had this thing up for like 6 months, and no one gave me any feedback
03:03:50 <Axman6> jerks
03:03:59 <ehamberg> and in the code below you use "str" instead of "str1" :)
03:04:15 <ehamberg> feedback galore!
03:04:36 <medfly> I don't normally google for tutorials
03:04:38 <Axman6> ok, fixed both of them i think
03:05:01 <Jafet> Also, your program session does not match the output that the code would produce
03:05:08 <Axman6> Jafet: that's how i write code, it's easier to see what's happening
03:05:11 <ehamberg> Axman6: yes. that was fast. :)
03:05:37 <Axman6> Jafet: how so?
03:06:24 <Jafet> ...er, just read it
03:06:32 <ehamberg> s/do stuff with these function right?/do stuff with these functions, right?/
03:07:16 <Jafet> "Good morning, heretic Axman6. May we, representing #haskell, interest you in a copy-editor?"
03:07:47 <inad922> Axman6: after reading that stuff I am thinking about (<-) as the universal unwrapper for the IO type? Is that close to the truth?
03:08:15 <Axman6> it's nothing to do with IO specifically
03:08:36 <Axman6> it's monadic do notation, special syntax for using monads, that makes it looks very procedural
03:08:38 <Jedai> inad922: Don't think about (<-) when trying to understand IO, only think about the monadic code written without do-notation
03:09:25 <Axman6> @undo do {x <- foo; y <- bar; z <- baz; return (x+y,z)}
03:09:26 <lambdabot> foo >>= \ x -> bar >>= \ y -> baz >>= \ z -> return (x + y, z)
03:09:32 <Axman6> inad922: ^^^^^^^^^^^^^^^^^^^^^
03:09:52 <Jedai> inad922: The do-notation is just a convenient syntactic sugar but it won't help you understand how monads work, it will only impede your progress if you try to consider it by itself rather than its translation
03:09:56 <Axman6> those pieces of code are _exactly_ equivalent
03:12:11 <Jedai> inad922: try to write most of your IO (and other monadic) code without the do-notation at first, only use it when you master the use of (>>=) and (>>). If you want to understand how it works that is, if you only want to use it, do-notation is perfectly adequate
03:12:41 <Jedai> s/when you master/once you have mastered
03:15:17 <inad922> after staring on the "@undo..." translation for some time I just realized that it actually answered my initial question. So basically (<-) makes sense in do notation and x <- y means something like y >>= id
03:16:09 <Axman6> well, no
03:16:27 <Axman6> x <- y doesn't make any sense unless you use x
03:16:37 <Axman6> @undo do {x <- y}
03:16:37 <lambdabot>  Parse error at "}" (column 11)
03:16:42 <Axman6> @undo do {x <- y; foo}
03:16:42 <lambdabot> y >>= \ x -> foo
03:16:44 <ski> `do x <- y; ...' means `y >>= \x -> ...'
03:16:49 <mux> it's rather, "x <- y; f x" == "y >>= f"
03:16:52 <Jafet> inad, what is the type of =?
03:16:59 <Jafet> What is the type of \?
03:17:03 <Jafet> How about ()?
03:17:13 <medfly> () is a tuple, no?
03:17:23 <mux> () is unit
03:17:24 <Jedai> Jafet: Well () : ()
03:17:30 <Jafet> Oh, duh
03:17:31 <ski> @type (
03:17:32 <lambdabot> parse error (possibly incorrect indentation)
03:17:33 <Jedai> () :: ()
03:17:36 <Jafet> ( )
03:17:51 <medfly> @type ()
03:17:52 <lambdabot> ()
03:17:55 <Axman6> :t (()())
03:17:56 <lambdabot>     Couldn't match expected type `() -> t' against inferred type `()'
03:17:56 <lambdabot>     In the expression: (() ())
03:17:58 <Axman6> >_>
03:18:00 <Jafet> (.)(.)
03:18:04 <Jedai> medfly: it's unit, you can consider it as a 0-tuple
03:18:09 <Axman6> :t ((.)(.))
03:18:10 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
03:18:28 <Axman6> oh, Cale's made (.) = fmap again -_-
03:18:38 <Axman6> > (+1) . [1..10]
03:18:38 <mux> heheh
03:18:38 <Jedai> Cool
03:18:39 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
03:18:51 <Axman6> > show . (+1) . [1..10]
03:18:53 <lambdabot>   ["2","3","4","5","6","7","8","9","10","11"]
03:18:57 <Jedai> :t (++)
03:18:59 <lambdabot> forall m. (Monoid m) => m -> m -> m
03:18:59 <mux> lambdabit is hascale again
03:19:11 <Jedai> And (++) is mappend again !
03:19:37 * Axman6 rages at Cale again for plating potential noob bombs again
03:20:07 <mux> Hascale: and you thought Haskell was hard?
03:20:16 <medfly> hehehe
03:20:21 <Jafet> @let (.) f g = \x -> f (g x)
03:20:22 <lambdabot>  <local>:2:0:
03:20:23 <lambdabot>      Multiple declarations of `L..'
03:20:23 <lambdabot>      Declared at: .L.hs:79:...
03:20:32 <Jafet> Hm
03:20:53 <medfly> (++) as mappend doesn't seem to bad
03:21:11 <Jedai> mux: Well it's not really harder, more like disappointing once the beginner try it on its own...
03:21:13 <mux> yeah, things were actually like this in previous versions of haskell
03:21:21 <mux> (.) as fmap is more confusing
03:21:23 <Jedai> medfly: It's really nice yeah !!
03:21:30 <mux> Jedai: yes, my point exactly
03:22:00 <medfly> what is (.) otherwise?
03:22:14 <mux> function composition
03:22:16 <medfly> like f . g?
03:22:18 <medfly> ah, okay.
03:22:27 <Jedai> medfly: (.) is just the composition of function in Haskell98
03:22:40 <medfly> thanks
03:22:42 <Jedai> > (*2) . [1..10]
03:22:44 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
03:22:54 <Jedai> medfly: this don't work normally...
03:22:55 <Axman6> @src (->) fmap
03:22:55 <lambdabot> fmap = (.)
03:23:34 <medfly> fmap doesn't seem to be so different from map, what's the difference? I see the type is a bit different
03:23:51 <Jedai> mux: and (.) == fmap is less useful than it was before Applicative became so prevalend, <$> is a little bit longer but pretty nice too
03:24:08 <Jedai> medfly: map only works on lists, fmap works on any functor
03:24:16 <medfly> oh, okay. thanks
03:24:28 <Jedai> > fmap (+2) (Just 5)
03:24:30 <lambdabot>   Just 7
03:25:47 <Phyx-> wtf
03:26:08 <Phyx-> @src fmap
03:26:09 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
03:26:36 <medfly> @src (.)
03:26:36 <lambdabot> (f . g) x = f (g x)
03:26:42 <medfly> haha
03:26:44 <skorpan> > let (.) = fmap in (+2) . (Just 5)
03:26:46 <lambdabot>   Just 7
03:26:48 <Phyx-> right, (->) was part of the instance
03:26:50 <skorpan> this is madness
03:27:20 <ski> @src [] fmap
03:27:21 <lambdabot> fmap = map
03:27:37 <Jedai> @src Maybe fmap
03:27:38 <lambdabot> fmap _ Nothing       = Nothing
03:27:39 <lambdabot> fmap f (Just a)      = Just (f a)
03:27:53 <ski> @src IO fmap
03:27:54 <lambdabot> fmap f x = x >>= (return . f)
03:28:22 <Jedai> @src lifM
03:28:24 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
03:28:27 <Jedai> @src liftM
03:28:28 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
03:28:58 <ski> @src liftA
03:28:59 <lambdabot> liftA f a = pure f <*> a
03:29:15 <Phyx-> @src (-.)
03:29:16 <lambdabot> Source not found. Sorry.
03:29:18 <Phyx-> @src (->)
03:29:19 <lambdabot> Source not found.
03:29:30 <Phyx-> @type (->)
03:29:31 <lambdabot> parse error on input `->'
03:29:31 <Jedai> ski: liftA == (<$>)
03:29:51 <Phyx-> how can (->) be an instance of anything if it's not defined as a type?
03:29:51 <ski> i'm aware
03:30:06 <Jedai> Phyx-: it's a type constructor
03:30:13 <ski> it's still a type, even if it hasn't a Haskell definition
03:30:19 <ski> (it's abstract)
03:30:30 <skorpan> it's "(->) a" that's the instance though, i think
03:30:33 <Phyx-> ah ok
03:30:55 <Jedai> skorpan: In functor case though, in arrow case, (->) is the instance
03:31:05 <skorpan> i see
03:31:17 <Phyx-> skorpan: that's for monads right? because those need a kind * -> * no?
03:31:42 <Jedai> Phyx-: Functor and Applicative and Monad yes
03:32:34 <Phyx-> yeah, ok, makes sense now, i always found those instances fishy
03:34:11 <Jedai> Phyx-: The ((->) env) monad is just Reader though
03:34:22 <Jedai> if you look at it just right
03:35:10 <ski> @unmtl Reader env a
03:35:11 <lambdabot> env -> a
03:35:56 <Jedai> ski: unmtl ?
03:35:59 <Phyx-> Jedai: yeah I know, my problem with them were that i though (->) only existed in concrete syntax, not that it was actually <part> of the language
03:36:57 <Jedai> Phyx-: Funny how your problem mirrored inad's one but in reverse and at the type level... ^^
03:37:03 <ski> @help unmtl
03:37:04 <lambdabot> unroll mtl monads
03:37:24 <Jedai> ski: Pretty cool, it it recent ?
03:37:30 <ski> (`mtl' standing for "monad transformer library", iirc)
03:37:40 <ski> not that a recent plugin, i think
03:38:23 <ski> @unmtl StateT s (ContT o (ReaderT r IO)) a
03:38:24 <lambdabot> s -> (a -> s -> r -> IO o) -> r -> IO o
03:38:24 <Jedai> @unmtl StateT nb (Reader env a)
03:38:25 <lambdabot> err: `StateT nb (env -> a)' is not applied to enough arguments.
03:39:06 <ski> @unmtl StateT nb (Reader env) a
03:39:06 <lambdabot> nb -> env -> (a, nb)
03:39:35 <Jedai> ski: definitely nice :)
03:41:18 <tristes_tigres> HDBC-sqlite, haskelldb-hsql-sqlite or sqlite ?
03:42:42 <tristes_tigres> what's the best binding for sqlite
03:46:00 <Phyx-> hmm CoD:MW2 in 2 days.... time to go reply MW1
03:46:02 <Phyx-> replay*
03:46:04 <Phyx-> bbl
03:52:25 <pao> tristes_tigres: I'll try out with HDBC-sqlite first
03:52:44 <tristes_tigres> pao : why ?
03:53:39 <pao> haskelldb has got a nice type safe monadic interface but it's quite steep learning curve
03:54:13 <pao> if you use HDBC-sqlite you can easily port your app to different DB backend (at least in theory)
03:54:21 <pao> that's it
03:56:24 <tristes_tigres> pao: thanks
03:57:25 <pao> tristes_tigres: you're welcome
03:58:00 <mmorrow_> also haskelldb doesn't do joins and complex queries, which is a problem in some situations
04:38:35 <burp> I recommend takusen
04:38:53 <RayNbow> Cale, are you going to compare your upcoming vector/monad blog posts ( http://analogical-engine.com/wordpress/?p=7 ) with sigfpe's posts on vectors/monad ( http://blog.sigfpe.com/2009/05/trace-diagrams-with-monads.html + http://blog.sigfpe.com/2008/08/hopf-algebra-group-monad.html )?
04:39:32 <burp> um, he's gone
05:16:47 * Phyx- wonders what the ratio of windows/unix-like os users is in #haskell
05:17:11 <burp> ctcp version #haskell ;)
05:19:10 <Phyx-> burp: i don't think i'd make it out alive
05:19:38 <burp> yup :D
05:20:42 <Phyx-> but i think, it would be skewed a bit to the latter
05:25:31 <skorpan> wow, that was a nice way to trigger a DDOS on myself
05:25:37 <burp> post it somewhere ;)
05:25:53 <marcot> Good morning.  Is there a way to configure cabal to build and install only the libraries in a package with libraries and executables?
05:29:18 <skorpan> results: http://pastebin.com/d60aa0d28
05:30:23 <burp> wow, almost just irssi
05:30:32 <Phyx-> skorpan: LOL
05:30:34 * mauke is on line 363
05:30:43 <Phyx-> i never got the version
05:31:29 <skorpan> just five erc users... that's odd
05:31:39 <Phyx-> to whom ever has the "irssi v0.8.13 - running on CYGWIN_NT-6.0-WOW64 i686"
05:31:47 <Phyx-> where'd you get the 8.13?
05:31:55 <Phyx-> iz has 8.12
05:31:57 <skorpan> lol
05:33:20 <Twey> 14:24 *** ANON CTCP VERSION irssi v0.8.12 - running on SunOS i86pc — woah
05:33:50 <shambler> hehehe
05:33:59 <shambler> any plan9 users?
05:34:29 <Phyx-> i think it's safe to say, irssi is the most used client here
05:34:52 <Phyx-> wth is "Purple IRC" sounds like a dissease
05:35:16 <burp> sounds like pidgin to me
05:35:26 <burp> purple is multi messenger library
05:35:30 <Phyx-> hmm
05:35:38 <Phyx-> and "WeeChat" ?>
05:35:39 <Phyx-> lol
05:35:42 <burp> is like irssi
05:35:44 <Phyx-> WiiChat? :P
05:36:21 <Phyx-> lol, so to answer my original question
05:36:35 <Phyx-> we windows user seem to be lower than 5%
05:37:01 <luite> I use windows, but my irc client runs on a linux server
05:37:08 <luite> (irssi)
05:37:10 <skorpan> more legible and sorted: http://pastebin.com/m2f21375d
05:37:23 <luite> there may be more people with a similar setup
05:37:34 <skorpan> we aren't many rcirc users -_-
05:37:54 <shambler> roflcopter 0.8.13-svn
05:37:58 <shambler> :S
05:38:01 <medfly> heh, I can't wait for teh day that what Phyx- said will be true in a few more places ;)
05:38:28 <burp> lol
05:38:44 <Phyx-> medfly: plasphamy
05:38:49 <Phyx-> errr
05:39:04 <Phyx-> medfly: blasphemy!
05:39:04 <Jedai> I think I'm the only one using KvIRC
05:39:05 <Phyx-> lol
05:39:14 <shambler> same here
05:39:24 <Phyx-> then you can't be the only one anymore
05:39:25 <Phyx-> lol
05:39:31 <shambler> but for nonamescript + mirc ;<
05:39:43 <Jedai> Very nice graphic irc client (much nicer than XChat IMNSHO)
05:39:56 <medfly> I like xchat.
05:40:02 * Phyx- stopped using xchat when they started charging for the windows builds
05:40:10 <Phyx-> left them and went to irssi and never looked back!
05:41:17 <medfly> why is it blasphemy?
05:45:19 <shambler> "only fools read this"
05:45:22 <shambler> :(
05:46:23 * Phyx- really doesn't want to make this specification
05:47:09 <danderson> Hi. I have a rather strange question for you folks. I'm currently sick and learning haskell, and I'm not sure if a library/framework actually exists, or if I just made it up in a fever dream (just got up).
05:47:18 <danderson> It's rather annoying, and I'd like to settle it :)
05:47:38 <shambler> erm
05:47:39 <medfly> you're hallucinating that Haskell exists!
05:47:55 <shambler> @faq
05:47:56 <lambdabot> The answer is: Yes! Haskell can do that.
05:48:17 <danderson> iirc, it was an event-driven network framework, which used laziness to disguise the event-driven nature of stuff
05:48:40 <danderson> the details are a bit fuzzy, which probably means I made it up in my sleep, but I have a niggling doubt.
05:48:53 <shambler> flu?
05:48:57 <danderson> yeah
05:49:01 * shambler panics
05:49:05 <danderson> medfly: that would also explain a lot
05:49:11 * danderson coughs over everyone
05:49:11 <Phyx-> hehe
05:49:22 <danderson> probably not the dreaded Zombie Flu of the 21st century though
05:49:30 <danderson> just plain old feeling like crap for a couple of days
05:49:40 <medfly> aww, I hope you feel better soon.
05:50:07 <Jedai> danderson: Are you speaking about Reactive or some other FRP framework around ?
05:50:36 <Phyx-> Jedai: yeah, my thought were off Reactive too, but wasn't too sure he meant that
05:50:41 <Jedai> If I remember correctly buster had something about the network
05:51:19 <Phyx-> of*
05:51:22 <danderson> hmm.
05:51:50 <Jedai> danderson: Was it FRP or pseudo-FRP ?
05:51:58 <danderson> neither of those match what I was thinking of, but if they're the foremost haskell libs in that area, it's unlikely I happened across another
05:52:57 <Jedai> danderson: foremost I wouldn't say, Reactive is extremely experimental and buster is pseudo-FRP IIRC there was also elerea I think
05:53:31 <danderson> the event stream was hidden by the use of lazy containers
05:53:56 <Jedai> There are some like that but mainly they're framework without the flesh around that would make them good network framework (they have the potential to be though)
05:54:00 <danderson> eg. if you fetched an URL over HTTP, you'd get back a ByteString that would block until data was available
05:54:16 <danderson> (block if evaluated when no data is available that is)
05:54:22 <Jedai> danderson: Curl in Haskell ?
05:54:55 <Jedai> danderson: what you describe is more or less how the classic network libraries work in Haskell anyway
05:55:19 <danderson> okay, then I must have mushed together and extrapolated what little I know of networking in Haskell
05:55:27 <danderson> thanks for helping me clear my mind :)
06:14:05 <Phyx-> aaand my tex editor bites the dust
06:15:28 <Phyx-> oh for crying out loud...
06:26:05 <sioraioc_> Hrm, in lhs2TeX I am trying to get greek letters for the type variables, I tried adding %include greek.fmt, but it doesn't change anything
06:42:19 <kw317> are there more monads than arrows?
06:43:54 <kw317> I'm wondering about the relation of arrows, monads and applicative functors
06:48:14 <Saizan_> kw317: there's a paper by wadler
06:49:13 <Saizan_> kw317: http://homepages.inf.ed.ac.uk/wadler/topics/links.html#arrows-and-idioms
06:50:18 <kw317> Saizan_: thanks
06:50:56 <byorgey> kw317: they aren't directly comparable. But every monad can be made into a special kind of arrow, so in that sense I'd say there are more arrows than monads.
06:55:10 <Saizan_> there's a path from monad to arrow to applicative functor, which gets you an app. functor isomorphich to return/ap
06:56:29 <Luke> whats up byorgey?
06:56:51 * Luke is from HacPhi
06:58:37 <Guest96712> hi pls checkt out
06:58:37 <Guest96712> so f**** hot
06:58:37 <Guest96712> http://beim-selbermachen-erwischt.net/?id=3185807
06:59:35 <Guest96712> hi pls checkt out
06:59:40 <tavelram_> ok, everybody goto that url, but remove the ref-id at the end :p
07:07:14 <BONUS> hmm
07:07:27 <BONUS> yoneda :: (forall b. (a -> b) -> f b) -> f a
07:07:29 <BONUS> yoneda t = t id
07:08:00 <BONUS> how come this gets type checked
07:08:11 <Phyx-> because
07:08:15 <Phyx-> id is a -> a
07:08:21 <BONUS> i mean, a is instantiated outside, and if we pass a -> a
07:09:00 <BONUS> the b that's foralled inside gets instantiated by the outside, no?
07:09:10 <Phyx-> when unifying and getting the type for t id, b becomes a
07:09:46 <mauke> t's type says "I work for all b"
07:09:49 <mauke> that includes a
07:09:57 <BONUS> ah, yes, of course
07:10:30 * Phyx- sucks at explaining stuff
07:10:47 <BONUS> no no i grokked it from both of you :D
07:10:54 <BONUS> just had to make the intuitive leap
07:11:14 <BONUS> existentials that aren't just inside types sometimes confuse me
07:12:24 <Luke> I'm unable to get Network.Pcap package working. It cant seem to work correctly with the pcap.h with FFI: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11956
07:13:57 <Luke> anyone have any experience getting this stuff working? I've looked at the source and nothing stands out
07:26:05 <Botje> Luke: are you sure that symbol is also in the library you're trying to load?
07:26:41 <Luke> i cant be 100% sure because it's binary. i'm assuming the headers are correct. this is a very widely used library (libpcap)
07:26:58 <Botje> does "nm ~/.cabal/lib/pcap-0.4.4/ghc-6.10.4/HSpcap-0.4.4.o" mention that function
07:27:41 <Luke> U pcap_is_swapped
07:27:42 <Luke> =/
07:28:24 <Luke> its at least defined in the c header
07:28:56 <jmcarthur> yoneda ∷ (∀ β . (α → β) → f β) → f α   -- testing out my auto text replacement settings in xchat
07:29:21 <jmcarthur> would suck if too many people can't see unicode in their clients though
07:29:35 <koeien> i only see ?
07:29:39 <jmcarthur> dang
07:29:47 <dschoepe> works fine here
07:29:48 <BONUS> i see little squares (running irssi through putty)
07:29:51 <Luke> i saw the greek letters
07:29:56 <Botje> Luke: the C header isn't good enough :)
07:29:57 <Luke> whats between alpha and beta?
07:30:00 <Botje> jmcarthur: works for me
07:30:04 <drhodes> Luke: I just tried to $ cabal install pcap; on x86-linux and got: compiling dist/build/Network/Pcap/Base_hsc_make.c failed,  I then $ apt-get install libpcap0.8-dev, and the module imported ok. fwiw.
07:30:05 <Luke> Botje: haha yeah =) clearly
07:30:06 <jmcarthur> Luke: →
07:30:08 <jmcarthur> dang
07:30:10 <Luke> i saw that
07:30:12 <jmcarthur> - >
07:30:15 <jmcarthur> without the space
07:30:19 <byorgey> looks like an underscore to me
07:30:22 <Luke> i could see the arrow fine when you pasted it
07:30:22 <Botje> Luke: so apparently you have a newer / older version of libpcap that doesn't include this symbol
07:30:41 <Luke> Botje: i've figured as much. I'm on a crusade to fix it or find what version I need
07:30:49 <Luke> I've messaged bos about it
07:31:00 <byorgey> jmcarthur: I think you will find that clients (and fonts) vary extremely widely in their ability to render such things.
07:31:21 <jmcarthur> byorgey: yeah. that sucks
07:31:26 <Luke> jmcarthur: i saw all the arrows except here: (α ��� β)
07:31:29 <jmcarthur> i think i will have to drop it
07:31:44 <jmcarthur> Luke: i find that very weird
07:31:47 <Luke> same
07:31:57 <koeien37> pidgin gives diamonds in the middle, but an alpha & a beta at the begin and end
07:31:58 <Luke> i use dejavu which should support all unicode chars
07:32:06 <Botje> Luke: FWIW, my version of libpcap seems to have it.
07:32:18 <Luke> what version/distro?
07:32:28 <Botje> i'm on ubuntu 9.10
07:32:32 <Luke> same!
07:32:33 <Luke> damnit
07:32:33 <Luke> haha
07:32:36 <Botje> and i have version 1.0.0-2ubuntu1
07:32:39 <Luke> yup
07:32:58 <Botje> does nm -D /usr/lib/libpcap.so.1.0.0 | grep swap
07:33:01 <Botje> produce a result for you?
07:33:14 <Luke> 000000000000b110 T pcap_is_swapped
07:33:17 <Luke> yup
07:33:33 <Botje> then you should run ldd on that .so file inside your .cabal and ensure it links against libpcap
07:33:38 <Luke> good thing I didn't try to use this at work =) I've spent 2 days on this already =D
07:33:50 <Luke> Botje: oh how do I do that?
07:33:55 <Luke> 'inside the .cabal'
07:34:00 <Botje> that path you pasted
07:34:08 <Luke> yeah
07:34:15 <Botje> ldd ~/.cabal/lib/pcap-0.4.4/ghc-6.10.4/HSpcap-0.4.4.o
07:34:20 <Botje> and see which pcap it links to
07:34:39 <Luke> 'not a dynamic executable'
07:34:45 <Botje> uh, duh :(
07:34:48 <Luke> hah
07:35:46 <Botje> let me try cabal installing it
07:36:19 <Luke> i've basically started fresh on 2 9.10 boxes, installed platform, and then tried Pcap with this same probelm
07:38:27 <Botje> okay, got it compiled
07:38:32 * Botje hunts for a quick testing app
07:39:02 <Botje> ah.
07:39:12 <Botje> running "lookupDev" gives me a load error for that file as well.
07:39:31 <Botje> drhodes: after importing, can you type "lookupDev" into ghci? that actually loads the package.
07:41:12 <mmmulani> why does groupBy (<) [1,2,3,4,5,4,3,2,1] not yield [[1,2,3,4,5],[4],[3],[2],[1]] ?
07:41:27 <mmmulani> > groupBy (<) [1,2,3,4,5,4,3,2,1]
07:41:28 <lambdabot>   [[1,2,3,4,5,4,3,2],[1]]
07:41:29 <Botje> mmmulani: it only looks at consecutive items
07:41:49 <mmmulani> Botje: but then (<) should return false for (5,4)
07:42:10 <koeien37> it is strange to use groupBy with a non-equivalence relation?
07:42:13 <byorgey> I think it starts by looking at  (1,2), then (1,3), then (1,4), ...
07:42:21 <koeien37> @src groupBy
07:42:22 <mmmulani> oh :/
07:42:22 <lambdabot> groupBy _  []       =  []
07:42:22 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
07:42:22 <lambdabot>     where (ys,zs) = span (eq x) xs
07:42:23 <Botje> mmmulani: oh, right. it only looks at the first element of the series, sorry.
07:42:24 <byorgey> so (<) doesn't return false until it looks at (1,1)
07:42:28 <mmmulani> ahhhhh
07:42:38 <drhodes> Botje: nope ghc: unable to load package `pcap-0.4.4'
07:43:02 <Botje> drhodes: yeah. so that's a problem :)
07:43:02 <byorgey> it's assuming that the thing you give it is an equivalence, in which case it wouldn't make a difference whether it compares the first thing to successive things, or compares adjacent pairs.
07:43:39 <mmmulani> ahhhhh
07:43:41 <byorgey> the behavior of passing (<) to groupBy should not be relied upon =)
07:44:15 <Luke> Botje: yeah that's when I got the error. when I tried loading the package after calling a function
07:44:42 <Botje> Luke: that package looks weird
07:45:35 <Luke> not linking correctly or something?
07:45:49 <Botje> Luke: aha.
07:46:35 <Botje> Luke: cabal unpack pcap; cd pcap-0.4.4; chmod +x configure; ./configure
07:46:45 <Botje> that will generate a file pcap.buildinfo
07:47:04 <Botje> you need to put the contents of that file at the end of pcap.cabal (respect the indentation)
07:47:21 <Botje> and then you can runhaskell Setup.lhs configure --user; runhaskell Setup.lhs build; runhaskell Setup.lhs install
07:47:37 <Botje> apparently cabal doesn't know it's supposed to run the configure script
07:47:57 <Luke> damn this isn't portable enough
07:48:04 <Luke> i'm trying to use this for work
07:48:07 <gressvol-> I'm modifing a parser to be able to handle expressions greater than 2 operators e.g. 2+2+2. code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4858#a4858 my idea for that is to make a expressionlist like dnf: <expressionlist> ::= >expression | expression
07:48:10 <Luke> this wont fly =)
07:48:36 <gressvol-> dnf: <expressionlist> ::= <expression> | <expression> <expressionlist> *
07:49:12 <gressvol-> cant get the expressionlist to work..
07:50:55 <Codex_> gressvol: remove the loop.
07:51:15 <Luke> Botje: it worked! Thanks
07:51:23 <Codex_> gressvol: I mean from expressionlist to expressionlist, it might cause problems.
07:51:35 <Luke> Botje: should I file a bug report this somewhere? does cabal have that?
07:52:15 <gressvol-> Codex_: okey, will try
07:52:54 <Botje> Luke: you could poke bos, for a start
07:52:57 <Botje> and see where that leads :)
07:53:07 <Luke> already have. if he follows up i'll let him know
07:53:09 <Luke> thanks for your help
07:53:28 <gressvol-> nope, it doesnt work.
07:53:30 <Luke> good sluthing
07:53:51 * Twey read ‘sloughing’
07:54:20 <Botje> Luke: heh, i just found a _WAY_ easier solution :)
07:54:25 <Luke> yeah?
07:54:34 <Botje> change line 3 of Setup.lhs to read "> main = defaultMainWithHooks autoconfUserHooks"
07:54:38 <Botje> instead of simpleUserHooks
07:55:12 <Luke> nice
07:57:04 <Luke> Botje: thanks so much
07:59:54 <Botje> no problem; have fun :)
08:06:12 <jystic> I'm mapping a function over a list of records, storing the "result" in a TVar and repeating this process over and over again. It causes a space leak, which makes sense to me, but i'm not really sure how to fix it, where to introduce strictness, etc. Can anyone help?
08:06:42 <koeien37> probably add strictness at the point where you write to the TVar
08:07:07 <pao> I'd really like to have strict versions for mapM and foldM.... is that a "smell"?
08:07:25 <jystic> i tried that, but actually the list is inside another record, so it doesn't really work
08:08:07 <jystic> it's line 30 of this http://github.com/jystic/lambdasim/blob/master/Simulation.hs that's causing the problem
08:09:15 <jystic> changing it to: simVessels = map id (simVessels s) still causes the leak, so i'm pretty sure the problem is the map
08:27:29 <gwern> @quote austere
08:27:30 <lambdabot> Veinor says: I write austere haskell. all of my variables are named a, a', a'', a''', etc.
08:27:39 <gwern> @quote 127.0.0.1
08:27:40 <lambdabot> ddarius says: releases network version 127.0.0.1
08:27:45 <gwern> @quote Bobby
08:27:46 <lambdabot> Berengal says: 'Bobby Boolean felt horrible. What did he ever do to the other values? He was just a simple bit, a simple answer to a simple question! Suddenly he felt his insides churn; he felt an
08:27:46 <lambdabot> exception coming on! Oh no! What should he do, now that he was outside of IO?'
08:27:54 <gwern> @quote chanting
08:27:55 <lambdabot> Berengal says: '"Go away! You're not like us!" the other values yelled. "You're impure! Impure! Impure! Impure!" they started chanting.'
08:28:04 <gwern> @quote failed
08:28:05 <lambdabot> dpratt71 says: <dpratt71> so I read somewhere that the unofficial motto of Haskell was "avoid success at all costs"... <Baughn> dpratt71: Yeah. We failed.
08:28:12 <gwern> @quote maximum
08:28:13 <lambdabot> Warrigal says: Note to self: don't do maximum [1..].
08:28:31 <gwern> @quote foremost
08:28:31 <lambdabot> mauke says: the first and foremost task of a haskell compiler is to break haskell programs
08:28:41 <gwern> @quote generalisation
08:28:42 <lambdabot> ksf says: ...premature generalisation is the root of all procrastination.
08:28:53 <gwern> @quote feels.*so
08:28:54 <lambdabot> jimi_hendrix says: that took longer than it should have, but it feels so pure
08:29:00 <gwern> @quote Prolog
08:29:01 <lambdabot> ddarius says: Unfortunately, the logic programming community has this unhealthy death grip on Prolog.
08:29:17 * gwern feels vaguely disappointed
08:29:19 <gwern> @flush
08:29:23 <Warrigal> I think maximum [1..] is how I got GHC to crash.
08:30:03 <mauke> preflex: quote
08:30:06 <preflex>  <kakazza> yeah, my colon is just not made for white dicks
08:30:10 <mauke> argh
08:30:18 <mauke> preflex: NOT APPROPRIATE
08:30:48 <gwern> mauke: your fault for installing the nsfw fortunes
08:31:09 <mauke> I'm scared to try again :-(
08:34:42 <gwern> preflex: quote
08:34:45 <preflex>  <c_okie> Just saying, don't say stupid shit to me
08:34:51 * gwern is seeing a theme
08:34:59 <mauke> preflex: quote
08:35:02 <preflex>  <kakazza> yeah, my colon is just not made for white dicks
08:35:09 <mauke> sigh. the rng hates me.
08:35:20 <idnar> heh
08:35:23 <mauke> everywhere else it likes to spit out haskell quotes, just not here
08:35:35 <narens> could some explain why this function doesn't evaluate one file at a time? foldFiles f accum files = foldM (workOnFile) accum files
08:35:35 <narens>   where workOnFile ac file = do
08:35:35 <narens>           putStrLn $ "working on " ++ (show file)
08:35:35 <narens>           res <- fmap (f ac) (readFile file)
08:35:38 <narens>           evaluate res
08:36:03 <koeien37> readFile is lazy
08:36:11 <narens> even though evaluate is used?
08:36:19 <koeien37> depends on your definition of evaluate
08:36:40 <mauke> @src evaluate
08:36:41 <lambdabot> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
08:36:58 <mauke> depends on res
08:36:58 <koeien37> i guess this only evaluates the first : ?
08:37:04 <koeien37> yeah
08:37:47 <gwern> if the rng hates you, best not play nethack
08:37:49 <narens> lambdabot: Sorry, don't understand that that line is
08:45:20 <Phyx-> "Gadget Helpline, a UK tech support service, found that well over half of their male customers (64%) didn't even bother to read the manual before calling tech support"<-- lol
08:45:34 <benmachine> only 64%?
08:45:47 <Phyx-> hehehe
08:46:15 <koeien37> i would try to read the manual, just because it might save me some time on the phone
08:46:24 <koeien37> but if you even have to read the manual, it's a lost cause
08:46:34 <jcapper> Hmm, should it be possibly to crash the ghc type checker without any extensions turned on?
08:46:35 <Phyx-> yup
08:46:38 <idnar> I don't usually read the manual because it's usually wrong
08:46:41 <idnar> I just read the source code ;)
08:46:52 <Phyx-> I just try till i succeed
08:46:54 <koeien37> jcapper: no, not without things like UndecidableInstances
08:46:56 <Phyx-> trial and error ftw!
08:47:12 <tavelram_> @pl \a b c -> if a then b else c
08:47:13 <lambdabot> if'
08:47:18 <tavelram_> > if' a b c
08:47:20 <lambdabot>   Not in scope: `if''
08:47:25 <jcapper> koeien37: Hmm, maybe what I've found is a bug then.
08:48:12 <jcapper> I tried encoding currys paradox.
08:48:21 <jcapper> Just to "see what would happen"
08:48:26 <jcapper> And the checker doesn't appear to terminate
08:48:46 <jcapper> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11960#a11960
08:49:36 <koeien37> i get a stack overflow
08:50:00 <jcapper> Hmm, maybe I'm just not waiting long enough then
08:50:27 <jcapper> So a stack overflow is the intended behaviour of checking that program?
08:50:56 <koeien37> i doubt it
08:51:30 <Phyx-> i get a stack overflow too
08:51:35 <Phyx-> after approx 30secs
08:51:42 * benmachine notes ghc curry.hs is taking a lot longer to break than ghci
08:51:49 <koeien37> yeah
08:51:56 * benmachine also notes all his memeory appears to be escaping
08:51:57 <koeien37> ghc-6.8.2 borks too
08:52:04 <jcapper> Yeah, ghc was my original test
08:52:11 <jcapper> It took a very long time to eat all of my RAM
08:52:20 <benmachine> aaa
08:52:26 <benmachine> mouse lag :(
08:52:28 <koeien37> woops, just in time to kill the process
08:53:11 * benmachine kill %%
08:53:37 <jcapper> It seems like an obvious problem tho' (a non-strictly positive type)
09:04:38 <jfhall> does anyone know what the name of the function operator (->) is? I'm trying to look it up on google, but I can't find anything
09:07:17 <Gracenotes> it's the function application type constructor. I think people might use "to" if they were reading code aloud..
09:07:32 <FunctorSalad> ArrowT
09:07:38 <FunctorSalad> going by TH
09:08:08 <FunctorSalad> , [t| (->) () () |]
09:08:11 <lunabot>  AppT (AppT (ConT (->)) (ConT ())) (ConT ())
09:08:19 <Gracenotes> sounds LamE, FunctorSalad! *ducks*
09:08:20 <FunctorSalad> ahem
09:10:01 <Saizan_> jfhall: what are you trying to find, specifically?
09:10:35 <Botje> jfhall: it's a type constructor :
09:19:50 <Philonous> @hoogle m Bool -> m a -> m a -> m a
09:19:50 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
09:19:51 <lambdabot> Control.OldException bracket_ :: IO a -> IO b -> IO c -> IO c
09:19:51 <lambdabot> Control.Exception.Base bracket_ :: IO a -> IO b -> IO c -> IO c
09:23:13 <Philonous> @type let ifM p a b = p >>= \p -> if p then a else b in ifM
09:23:16 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> m b -> m b -> m b
09:23:56 <Philonous> I wonder why this isn't in the standard library. Isn't this a pretty common pattern?
09:24:14 <nolrai_FG> Does (kleisli arrows of a type m are a Catagory) imply m is a monad?
09:25:47 <Philonous> If they form a monoid then m is a monad. What exactly do you mean by category?
09:29:13 <Philonous> Well, actually I think Kleisli arrow implies that m is a monad in the first place
09:30:39 <lvh> hello
09:30:53 <koeien37> hi
09:35:33 <nolrai_FG> Philonous:that and i think your right, they added a Catagory type class, and am trying to figure out if being a monad means more then the a --> m a being a Catagory. But you cant make instances of types, only datas or newtypes right?
09:36:33 <deech`> Is it possible to use lhs2tex-style and haddock-style commenting in the same file?
09:37:27 <Philonous> With -XTypeSynonymInstances you can declare type synonyms to be instances,
09:38:22 <olsner> hmm, I'd like to have some generic way of describing transformations like (a,b) <-> (Maybe a, Maybe b) <-> Maybe (a,b), or more generically C a b <-> C (f a) (f b) <-> f (C a b) for some functor (or applicative, if that turns out to be necessary)
09:42:50 <nolrai_FG> Hmm, then you should be able to do do notation on Catagorys and have it implement monad do notation as a side affect. Just idle thoughts here though.
09:45:27 <Philonous> nolrai_FG: no. What is "foo <- bar" supposed to mean in any category? you can't translate it to (\foo  -> ...) . bar because it relies on the fact that Kleisli arrows are functions
09:47:00 <Philonous> There is, however, a do notation for Arrows. But it exploits the fact that arrows allow you to bypass values via first
09:48:56 <Philonous> (So it doesn't work for Categories in general, either )
09:50:18 <PeakerWork> nolrai_FG: Categories only have (.) and id.. can't do that much with that :)
09:50:23 <PeakerWork> (Without adding more)
09:56:29 <RayNbow> hmm, hpaste died?
10:05:49 <nolrai_FG> Ah, so there is more structure to monads. hmm
10:06:53 <jelly12gen> there are much monads
10:07:04 * jelly12gen still doesnt understand monads :(
10:09:19 <burp> you started with IO?
10:09:44 <nolrai_FG> Monads arnt so bad once you use them a lot.
10:09:53 <burp> if yes, restart again without IO, and read 3 more tutorials
10:10:02 <nolrai_FG> IO isnt a great start unfortunately.
10:10:13 <benmachine> yeah I think I learnt monads by using them and then working out how they worked afterwards
10:10:16 <benmachine> well
10:10:25 <mauke> understanding monads is overrated
10:10:28 <mauke> just use them
10:10:28 <nolrai_FG> You cant see whats going on because you cant inspect IO values.
10:10:31 <benmachine> it is useful to construct the implementation of one or two
10:10:40 <nolrai_FG> ^^^
10:10:59 <mauke> you can construct, say, Reader or State without understanding monads
10:11:10 <benmachine> the exercises on that blog post somewhere which get you to implement monad maybe and list and some other ones
10:11:13 <benmachine> were really useful
10:11:23 <benmachine> (and also, mapM and so forth)
10:11:34 <olsner> it seems that understanding monads isn't necessarily useful for using monads, and vice verse
10:11:43 <benmachine> olsner: I'd say it's definitely useful
10:11:48 <benmachine> but perhaps not essential
10:11:53 <nolrai_FG> There should be a type class for "you can introduce names with me".
10:12:05 <nolrai_FG> maybe?
10:12:10 <nolrai_FG> hmm
10:12:48 <nolrai_FG> olsner: you mean understanding the math, or understanding them in haskell. cause those are different.
10:14:08 <c_wraith> you can use the IO monad very successfully without ever understanding how it works.
10:14:29 <RayNbow> jelly12gen, have you read Typeclassopedia?
10:14:34 <Phyx-> IO monad has math? :O
10:14:39 <jelly12gen> RayNbow: nope
10:14:45 <RayNbow> @where typeclassopedia
10:14:46 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
10:15:00 <olsner> nolrai_FG: I meant understanding them in haskell
10:15:15 <RayNbow> jelly12gen: you should read it... it's an excellent article written by byorgey
10:15:26 <olsner> of course "understanding" is quite loosely defined, so I guess I could be saying anything :)
10:15:37 <jelly12gen> RayNbow: this is weekly?
10:15:42 <jelly12gen> RayNbow: ok
10:15:52 <RayNbow> jelly12gen: no, The Monad Reader is not weekly :p
10:16:07 * jelly12gen should start writing a bot in haskell
10:16:19 <desp> Is it possible to automatically derive an Enum instance based on the Bounded instance bounds?
10:16:34 * benmachine should continue writing a bot in haskell
10:16:59 <benmachine> desp: no
10:17:12 <desp> Aw.
10:17:13 <byorgey> desp: I don't think so; just knowing some bounds doesn't tell you how to get from one element to the next in the ordering.
10:17:21 <benmachine> I think all you need is succ and pred
10:17:23 <jelly12gen> RayNbow:let me read it :)
10:17:31 <benmachine> but if you don't have those you are a bit stuck
10:17:36 <desp> benmachine: well, it beats defaulting to 0 and n-1
10:17:44 <desp> s/benmachine/byorgey/
10:18:08 <desp> benmachine: I just have a well-defined sequence of C constants that starts at -10000 ;)
10:19:02 <benmachine> hmm
10:19:14 <benmachine> enumFrom/enumTo would probably do the trick as well, if you had those
10:19:23 <benmachine> er
10:19:26 <benmachine> enumTo doesn't exist
10:19:30 <benmachine> fromEnum
10:19:32 <benmachine> that is the one
10:19:41 <benmachine> and
10:19:42 <benmachine> toEnum
10:19:45 <benmachine> that is what I meant
10:19:57 <Phyx-> > ['0'..'z']
10:19:58 <benmachine> enumFrom does exist but it is something else
10:19:58 <lambdabot>   "0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwx...
10:20:04 <Phyx-> lol!
10:20:13 <desp> benmachine: I know, but I have to define toEnum/fromEnum myself, for each constant.
10:20:33 <desp> Hence, my question about deriving.
10:20:40 <benmachine> erm
10:20:50 <desp> Because the current deriving behavior is fine, it just needs a shift.
10:20:58 <benmachine> ah
10:21:02 <Philonous> enumTo = reverse . enumFrom
10:21:03 <desp> And said shift could theoretically be based on the bounds.
10:21:05 <benmachine> I see what you mean now
10:21:15 <benmachine> Philonous: hah
10:21:21 <Philonous> ;)
10:21:29 <Phyx-> @src enumTO
10:21:30 <lambdabot> Source not found. Just what do you think you're doing Dave?
10:21:31 <Phyx-> @src enumTo
10:21:32 <lambdabot> Source not found. Just what do you think you're doing Dave?
10:21:34 <Phyx-> :O
10:21:43 <Phyx-> you dare defy me you bot!
10:21:51 <burp> [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]] <- how can I create this?
10:21:52 <Gracenotes> it is defined for specific instances
10:22:02 <benmachine> burp: like that? :P
10:22:15 <burp> benmachine: you know how I meant this :P
10:22:24 <burp> it's just an example I need to generalize ;)
10:22:27 <Gracenotes> for an arbitrary row/column size, right?
10:22:36 <benmachine> burp: well I guess it depends how general you need
10:22:41 <Gracenotes> well, with # rows = # columns. identity matrix, basically
10:22:48 <benmachine> oh
10:22:49 <benmachine> hmm
10:23:01 <burp> yeah kind of identity matrix
10:23:10 <burp> but elements mustn't be numbers
10:23:11 <benmachine> it sounds like something that would be easy but I can't think of a simple way
10:23:48 <burp> same =)
10:23:51 <mjonsson> tabulate n (\i -> tabulate n j (\j -> if i == j then 1 else 0)) for a suitable definition of tabulate
10:23:58 <desp> @src boundedEnumFrom
10:23:58 <lambdabot> Source not found. That's something I cannot allow to happen.
10:24:25 <Gracenotes> > let n = 6 in map (take n) $ take n $ iterate (0:) (1:repeat 0)
10:24:26 <lambdabot>   [[1,0,0,0,0,0],[0,1,0,0,0,0],[0,0,1,0,0,0],[0,0,0,1,0,0],[0,0,0,0,1,0],[0,0...
10:24:55 <Gracenotes> > let n = 2 in map (take n) $ take n $ iterate (0:) (1:repeat 0)
10:24:55 <benmachine> not bad
10:24:56 <lambdabot>   [[1,0],[0,1]]
10:25:04 <burp> > let n = 6 in map (take n) $ take n $ iterate (x:) (y:repeat x)
10:25:05 <lambdabot>   [[y,x,x,x,x,x],[x,y,x,x,x,x],[x,x,y,x,x,x],[x,x,x,y,x,x],[x,x,x,x,y,x],[x,x...
10:25:09 <burp> hm yup thats good :)
10:25:22 * benmachine thinks the first $ should be a .
10:26:00 <burp> in my case I need to construct a bigger matrix out of single block matrixes on the diagonale
10:26:04 <mjonsson> i think my code is clearer even if it's longer
10:26:07 <Gracenotes> eh, it's all right-associative. There might be some function call overhead calculating everything to begin with, but it is pretty direct for the laziness it uses
10:26:14 <burp> with hmatrix fromBlocks :: Element t => [[Matrix t]] -> Matrix t "Creates a matrix from blocks given as a list of lists of matrices:"
10:26:36 <burp> the 0's are null matrixes and the 1 are other block matrixes
10:26:38 <Gracenotes> burp: the list of blocks should be some power of 2 large, right?
10:26:43 <Philonous> > let kronecker i j = if i == j then 1 else 0 in (\n -> [[kronecker i j | i <- [1..n]] | j <- [1..n]] ) 3
10:26:44 <lambdabot>   [[1,0,0],[0,1,0],[0,0,1]]
10:26:47 <benmachine> Gracenotes: yeah there's no *actual* difference except in that with a . you can more easily strip off the parameters or whatever
10:26:58 <burp> hm, not necessarily I think
10:27:02 <benmachine> it is more function-y :P
10:27:12 <jfhall> gracenotes,saizan,botje: sorry I missed your replies, I got a little distracted. I'm interested in the operator because I've been getting a "No instance for (Monad ((->) FilePath))" and I want to understand what is going on. Knowing that it's a type constructor should help my search thanks
10:27:33 <burp> it's for a small finite element method calculation
10:27:42 <Gracenotes> jfhall: ah.. it is a confusing type error that probably means something much simpler
10:27:47 <benmachine> jfhall: depends where you are getting an error
10:28:06 <benmachine> I mean, there is an instance for Monad ((->) t) in Control.Monad.Instances ()
10:28:13 <Gracenotes> hm.. mind pastebin-ing around where you found it?
10:28:19 <benmachine> but if you don't know that then likely you are trying to use a function as a monad inapprorpriately
10:28:29 <benmachine> inappropriately, even
10:28:34 <dcolish> when would one use the file suffix .lhs rather than .hs?
10:28:42 <benmachine> dcolish: literate haskell
10:28:59 <benmachine> which means
10:29:10 <dcolish> oh i see
10:29:16 <benmachine> either a TeX-ish file with code in \begin{code} \end{code}
10:29:20 <dcolish> its mostly comments excent for the code
10:29:29 <dcolish> not the other way around
10:29:31 <benmachine> or a file where haskell code is preceded by >s
10:29:36 <benmachine> well yeah
10:29:42 <benmachine> that's not necessarily the case
10:29:46 <dcolish> thats interesting
10:29:52 <benmachine> but in general it's a way of writing haskell that makes comments the norm
10:30:23 <benmachine> e.g. sometimes you can write a mailing list post which compiles if you save it as a .lhs file
10:30:47 <Gracenotes> dcolish: normal Haskell programs have one output: the compiled version (and interface, and whatnot). Literate Haskell programs are LaTeX, so they can also output to PDF or PS or other documents
10:31:21 <Gracenotes> well, they don't *have* to be LaTeX, but in a source code tree for a project, that would make sense for prettiness
10:31:38 <dcolish> no i can see that advantage
10:31:43 <dcolish> is it very common to use lhs?
10:31:47 <koeien37> lhs2TeX exists
10:31:57 <koeien37> prettifier for literate Haskell
10:32:07 <koeien37> (nice arrows/lambda's in the TeX and so on)
10:32:39 <ubuntu-nathan> Hello for all!
10:32:44 <jfhall> gracenotes: this is how I produced the error: return =<< getDirectoryContents
10:32:44 * ubuntu-nathan is very happy!
10:32:45 <koeien37> hi
10:32:46 <Gracenotes> it is used in the GHC source tree. I don't recall too many uses elsewhere..
10:33:04 <ubuntu-nathan> It's possible to compile Haskell to Windows Mobile?
10:33:09 <dcolish> looks like it'd be great for papers or classwork
10:33:14 <Philonous> sigfpe uses it in it's blog posts and there are academic papers that make use of it
10:33:16 <koeien37> dcolish: yeah, i've used it for that
10:33:25 <ubuntu-nathan> build applications for Windows Mobile using Haskell?
10:33:27 <byorgey> dcolish: it's most common to use .lhs for writing (a) blog/mailing list posts and (b) papers about Haskell (using the wonderful lhs2TeX preprocessor)
10:33:47 <byorgey> dcolish: yes, it's great for writing papers that need to talk about Haskell code
10:33:48 <p_l> ubuntu-nathan: if you can compile for ARM, I guess so
10:33:49 <Gracenotes> jfhall: "return" is a way to wrap pure (non-IO) values, and "turn" them into IO values. excuse the inexactness..
10:33:57 <ubuntu-nathan> huh
10:34:04 <ubuntu-nathan> that's wonderfull!
10:34:04 <koeien37> jfhall: m >>= return === m in monads
10:34:19 <dcolish> right on, i've begun to use LaTeX for all my class work, keeps it much nicer looking
10:34:52 <Gracenotes> I'm a bit curious how it would cause a type error, though. jfhall: if getDirectoryContents takes any parameters, make sure to fill them in
10:35:05 <Gracenotes> I'm guessing it takes a FilePath?
10:35:08 <koeien37> :t getDirectoryContents
10:35:10 <lambdabot> Not in scope: `getDirectoryContents'
10:35:25 <jfhall> gracenotes: thats what I was wondering about, why can't i let getDirectoryContents use partial application?
10:35:40 <koeien37> jfhall: you can
10:35:40 <Phyx-> @hoogle directory contenst
10:35:41 <lambdabot> No results found
10:35:45 <Phyx-> @hoogle directory content
10:35:46 <lambdabot> System.Directory getDirectoryContents :: FilePath -> IO [FilePath]
10:36:27 <Phyx-> :t System.Directory.getDirectoryContents
10:36:29 <lambdabot> FilePath -> IO [FilePath]
10:36:30 <jfhall> koeien37: but it gives me type errors if I don't explicitly provide the argument to getDirectoryContents
10:36:49 <koeien37> jfhall: you can use getDirectoryContents partially applied
10:36:56 <koeien37> mapM getDirectoryContents [".", ".."]
10:37:01 <koeien37> -- an example
10:37:02 <Phyx-> how do you partially apply that.. it only has 1 argument
10:37:03 <Gracenotes> jfhall: >>= is: m a -> (a -> m b) -> m b. (and =<< is opposite). You are saying, when you do getDirectoryContents >>= return, that "getDirectoryContents" is of type m a. It happens to be of type FilePath -> IO [FilePath], which can also be written (->) (FilePath) (IO [FilePath]).
10:37:52 <Gracenotes> since monads are parameterized over the last type variable: e.g., Either a b would have a monad declared for Either a (with b as that type variable), you are really claiming that ((->) FilePath) is a Monad
10:38:03 <jfhall> Gracenotes: that explains the error, I still have to wrap my head around some things i guess
10:38:22 <jfhall> ok I see that
10:38:43 <Gracenotes> and it *can* be a monad, but it probably won't do what you want it to do ;)
10:38:56 <Phyx-> Gracenotes: since FilePath is typedef'd to String, isn't it one? part of the list monad?
10:39:32 <koeien37> the list monad is not ((->) [Char])
10:39:52 <jfhall> Thanks for all the help, you guys have cleared up some things for me
10:39:57 <Phyx-> sure, it's ((->) [a]) no?
10:40:08 <Gracenotes> jfhall: if it helps, you can do something like getDirectoryContents <$> otherMonadicFunction
10:40:15 <koeien37> just [] a
10:40:25 <FunctorSalad> wasn't there a library for Map-List-hybrids? (maps which also remember an order of keys)
10:40:28 <koeien37> ((->) x) is like the Reader monad
10:40:44 <Phyx-> yes, that i know
10:40:45 <jfhall> gracenotes: ohhh, I will have to lookup <$>, thanks again
10:40:56 <c_wraith> jfhall: <$> is fmap
10:41:07 <jfhall> oh thanks
10:41:10 <FunctorSalad> it's just data MapList a k = MapList [a] (Map a k), but I mean a library that defines all the operations on it...
10:41:25 <Gracenotes> actually, no.. never mind.. <$> is more for pure functions
10:41:43 <Gracenotes> (getDirectoryContents =<< getCurrentDirectory) is of type (IO [FilePath])
10:43:03 <Phyx-> koeien37: right, only []. sorry, brainfart...
10:43:23 <Gracenotes> partial application for monads is not as easy, mostly because you can't have functions yield partially applied functions. only partially applied functions wrapped in that particular monad (IO (a -> b)). That is where Applicative comes in handy, though.. but I'm just rambling now, heh
10:44:59 <a_guest> I have a module file, where I define and export a datatype. I also define it as member of a typeclass. Do I have to export the membership?
10:45:12 <jfhall> gracenotes: that makes sense, and that's is what I was overlooking... I have heard of Applicative, but don't much about that, I'll have to check that out, thanks again for the info
10:45:31 <koeien37> a_guest: no. in fact there is no way to avoid exporting it
10:46:24 <a_guest> koeien37: ok
10:46:51 <kmc> @djinn (Maybe a) -> (a -> Maybe b) -> Maybe b
10:46:52 <lambdabot> f a b =
10:46:52 <lambdabot>     case a of
10:46:52 <lambdabot>     Nothing -> Nothing
10:46:52 <lambdabot>     Just c -> b c
10:46:55 <Gracenotes> Applicatives are pretty neat
10:53:30 <dcolish> so i just read a paper about using llvm for ghc on reddit, but there was no code with that paper. is that code or similar available?
10:55:57 <kmc> @quote kleisli
10:55:57 <lambdabot> lilac says: class Monad m where / return and Kleisli compose / must form a monoid
10:56:11 <jfhall> dcolish: I think dons mentioned it hasn't been released yet in the comments on reddit
10:56:53 <red-agent> Hi. Is there a de-facto standard tools for doing haskell in VIM?
10:57:16 <dcolish> jfhall: ah yes, the comments... i should read those first next time
10:57:29 <kmc> :t (>=>)
10:57:30 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
10:58:34 <eu-prleu-peupeu1> hi
10:58:44 <eu-prleu-peupeu1> i have this hypothetical data type in haskell
10:58:46 <eu-prleu-peupeu1> http://pastebin.com/d14989af6
10:59:00 <eu-prleu-peupeu1> but it does not scale well if i add new fields on it
10:59:07 <eu-prleu-peupeu1> because if i do it, then i have to change all the functions :/
10:59:20 <eu-prleu-peupeu1> how do i make this kind of code "maintainable" ?
10:59:22 <koeien37> you can turn the function into    createMyData { dataId = 0 }
10:59:40 <jfredett> yah- then you'll get all the other fields set to "undefined"
10:59:56 <jfredett> (so don't try to access them)
11:00:01 <jfredett> but that will work.
11:00:12 <eu-prleu-peupeu1> oh
11:00:28 <kmc> eu-prleu-peupeu1, is the idea of "createMyData" that it's just a Mydata with some "default" values?
11:00:53 <kmc> also, createMyData is not a function, and it's not very reasonable to give it a verb-name like "create"
11:01:05 <kmc> it's just the name of a particular Mydata value
11:01:15 <Gracenotes> well, you do need a value to run record modification on
11:01:17 <eu-prleu-peupeu1> kmc, createMyData is a "constructor"
11:01:22 <eu-prleu-peupeu1> i only export it
11:01:23 <Gracenotes> although.. hmm..
11:01:30 <nolrai_FG> Hey it seems like hpaste is down, anything else I can use instead?
11:01:33 <kmc> eu-prleu-peupeu1, what's its type?
11:01:43 <koeien37> nolrai_FG: pastebin.com
11:01:54 <eu-prleu-peupeu1> f :: MyData
11:01:55 <eu-prleu-peupeu1> :P
11:02:00 <kmc> right, so it's not a function
11:02:05 <kmc> it hasn't got a (->) in the type
11:02:11 <kmc> and it doesn't "do" anything
11:02:15 <jfredett> eu-prleu-peupeu1: typically (since you're not creating a function to create MyDatas, but rather a single MyData instance) we call those things "defaultData" or similar
11:02:21 <kmc> it's just a particular value of type MyData, which you export
11:02:26 <Gracenotes> eu-prleu-peupeu1: a constructor is that actual glue that binds values of a datatype together. It's not a procedure.. it's a data structure. Similarly, when you create an object from that constructor, it's just a value.. not a function or anything
11:02:43 <eu-prleu-peupeu1> yes
11:02:54 <kmc> and yeah, this is a common pattern to define a record type, and a "default" record.  i usually put them next to each other, and maintainability is not that bad
11:02:56 <eu-prleu-peupeu1> i know
11:03:14 <eu-prleu-peupeu1> so how do i do it if i dont want to export the data type i just created ?
11:03:15 <Gracenotes> personally, I tend to like calling default values of MyData something like mkMyData. Which *is* a verb, but, eh :P
11:03:32 <kmc> eu-prleu-peupeu1, you will have to export the type, but you don't have to export the type's data constructors
11:03:41 <Gracenotes> eu-prleu-peupeu1: oh. for that, make the constructor name different from the type name
11:03:55 <Gracenotes> some Haskell modules do data MyData = MkMyData Int String Whatever
11:04:01 <kmc> they can be the same name even
11:04:01 <eu-prleu-peupeu1> ah okey
11:04:13 <Gracenotes> kmc: oh, that's true.. you just have to be picky at export syntax
11:04:17 <kmc> module Foo(Bar) versus module Foo(Bar(Bar))
11:04:40 <Gracenotes> doesn't the latter automatically export all constructor fields?
11:04:44 <Gracenotes> I mean, former
11:04:47 <nolrai_FG> Can some one look at http://pastebin.com/m46f534f5 and see if there is a way to clean up the code. It works but is kind of ugly.
11:04:51 <kmc> wouldn't that be Bar(..)?
11:05:38 <Gracenotes> er. if I ever in my life make a Haskell module, I'll tell you. >_>
11:05:49 <nolrai_FG> yes
11:05:51 <koeien37> yeah Bar(..)
11:05:57 <Gracenotes> I do happen to like the MkBlah trick though
11:06:27 <Gracenotes> > let tree = tree { rootLabel = 4 } in rootLabel tree
11:06:31 <lambdabot>   mueval-core: Time limit exceeded
11:06:34 <Gracenotes> aww.
11:10:09 <eu-prleu-peupeu1> it should be possible to add default values directly to the fields of the data type
11:10:29 <eu-prleu-peupeu1> MyData { myDataId :: Int = 0} or whatever
11:11:00 <nolrai_FG> haskell record syntax needs a lot of upgrades.
11:11:32 <copumpkin> eu-prleu-peupeu1: check out Data.Default
11:11:37 <copumpkin> @hackage default
11:11:38 <lambdabot> http://hackage.haskell.org/package/default
11:11:49 <mtnviewmark> Looking for opinions: I have a data type that can be treated at times like map and at others like an array --- I've modeled the map-like functions  on Data.Map, assuming that will be most familiar to Haskell programmers -- Should I model the array-like functions on Data.Array? on Data.List[]? or perhaps on Data.Map with Int keys?
11:11:53 <copumpkin> http://hackage.haskell.org/package/data-default
11:12:38 <Cale> mtnviewmark: All of those seem like good options...
11:12:39 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
11:12:45 <nolrai_FG> Like it would be nice if record names were a type so you could do stuff like "modAttrubute attr r v = r {attr = v $ attr r}"
11:13:08 <mtnviewmark> Cole: hence why it wasn't clear to me!  :-)
11:13:56 <eu-prleu-peupeu1> thanks copumpking
11:14:08 <mtnviewmark> noirai_FG: as in like Data.Accessor ?
11:14:49 <Gracenotes> the king of co-puns
11:14:58 <Cale> RayNbow: We're essentially talking about the same stuff. I'm going to have stuff on string diagrams soon enough too :)
11:16:44 <nolrai_FG> mtnviewmark: Yeah, it would be nice if there was some sugar that did that for you.
11:17:06 <Cale> RayNbow: Did you want to know something specific about how it connects up?
11:18:26 <kmc> nolrai_FG, Data.Accessor can derive first-class labels using TH
11:18:39 <kmc> sorry Data.Record.Label in fclabels package
11:19:00 <nolrai_FG> coolness any examples?
11:19:16 <kmc> Data.Lenses in lenses also has TH
11:19:25 <kmc> it'd be great if someone familiar with these three packages could do a comparison
11:21:10 <nolrai_FG> fclabels is sweet.
11:24:10 <Cale> This is a pretty esoteric question, but does anyone happen to know if there's a mathTeX server which supports TikZ?
11:26:25 <luite> hehe I had the same question a while ago, ended up installing latex+tikz locally
11:26:58 <luite> and found out that ultimate latex is not very ultimate after all...
11:27:02 <Cale> Yeah, I was thinking of just running a mathTeX server on my own machine, and letting the blog (which is hosted) cache the images.
11:27:41 <Cale> The code is very very ugly. I've cleaned it up a bit, but still have some work to do in removing the repetition.
11:27:53 <Cale> (For Ultimate LaTeX)
11:28:08 <luite> if I remember correctly, it basically contains the same (huge and ugly) function twice
11:28:12 <Cale> yes
11:28:44 <Cale> and it's all indented incorrectly, and it forgets to escape strings before inserting them into HTML attributes.
11:29:45 <Cale> (so if there's a quote character in your LaTeX code, you end up with malformed HTML)
11:30:27 <luite> ah I'm not sure if I fixed that, I should probably check
11:30:30 <Cale> (I ran into that while testing xypic diagrams)
11:30:42 <nolrai_FG> @hoogle Either e a -> (e -> a) -> a
11:30:43 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
11:30:43 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
11:31:01 <tristes_tigres> anyone installed hdbc-sqlite3 under windows ? http://software.complete.org/software/wiki/13/FrequentlyAskedQuestions doesn't seem to work, claims sqlite3 can not be found, even though it's in %windir%\system32 and ghc  --print-libdir
11:31:07 <kmc> :t either id
11:31:08 <lambdabot> forall a b. (b -> a) -> Either a b -> a
11:31:27 <koeien37> :t flip either id
11:31:28 <lambdabot> forall a b. (a -> b) -> Either a b -> b
11:31:45 <mtnviewmark> oy, why doesn't the doc for Data.Array.IArray actually list all the class methods?
11:31:49 <aavogt> :t flip $ flip either id
11:31:50 <lambdabot> forall a b. Either a b -> (a -> b) -> b
11:32:09 <kmc> :t flip flip
11:32:10 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
11:32:11 <Cale> mtnviewmark: Doesn't it?
11:32:45 <RayNbow> Cale: to be honest, I haven't read your blog posts in detail yet... I've just skimmed over it
11:32:48 <Cale> mtnviewmark: Oh, are there low-level things which are not part of the interface that it obscures?
11:32:49 <nolrai_FG> would of thought it would have been some where. For handleing errors.
11:32:49 <kmc> @djinn (a -> b -> c) -> (b -> a -> c)
11:32:49 <lambdabot> f a b c = a c b
11:32:54 <mtnviewmark> nope - my install (Haskell Platform), has only one method listed in Data-Darray-IArray.html
11:33:22 <mtnviewmark> well, perhaps - but if you wanted to create an instance of IArray, you'd need to know them
11:33:30 <kmc> :t catchError
11:33:32 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
11:34:54 <mtnviewmark> perhaps one isn't meant to write instances of IArray
11:34:54 <nolrai_FG> kmc: but I am at the top, I dont want to produce a "m a" I just want an a.
11:36:02 <Cale> mtnviewmark: Oh, right, the real things in IArray are mostly named unsafe*
11:36:49 <jkff> Hi. I wonder whether there is a use for foldl at all?
11:36:51 <Cale> mtnviewmark: Perhaps if you import Data.Array.Base?
11:36:57 <Cale> jkff: reverse
11:37:05 <Cale> (and things like it)
11:37:15 <jkff> But reverse can be done with foldl'
11:37:30 <Cale> It can, but it's slightly less desirable to do that.
11:37:39 <jkff> Why? It has the same strictness properties
11:38:01 <Cale> Perhaps after optimisation it will be the same...
11:38:05 <tristes_tigres> cabal claims
11:38:05 <tristes_tigres> Configuring HDBC-sqlite3-2.2.0.0...
11:38:05 <tristes_tigres> cabal: Missing dependency on a foreign library:
11:38:05 <tristes_tigres> * Missing C library: sqlite3
11:38:06 <nolrai_FG> kmc: right now I do case do {lots of things} of {Left err -> print err; Right action -> action} is that as clean as it gets?
11:38:32 <Cale> However, with foldl, you don't necessarily evaluate more flips than you have to
11:38:45 <jkff> What flips?
11:38:53 <Cale> reverse = foldl (flip (:)) []
11:39:40 <jkff> Hm. Well, if we take into account only the semantics and asymptotic performance, it still seems to me that foldl is not needed at all
11:39:43 <Philonous> jkff: foldl' (**) /= foldl (**) /= foldr (**)
11:40:03 <Cale> whoa, what killed hpaste?
11:40:06 <Cale> @hpaste
11:40:07 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
11:40:19 <Cale> the moonpatio one is up :)
11:40:27 <jkff> Philonous: You mean, for a sufficiently lazy instance of Real?
11:40:30 <jkff> :t (**)
11:40:31 <lambdabot> forall a. (Floating a) => a -> a -> a
11:40:35 <jkff> OK, of Floating
11:41:29 <Cale> jkff: Oh, there are cases where it matters semantically too. They are pretty rare.
11:41:34 <Cale> (and for performance)
11:41:40 <Cale> reverse is actually kind of a poor example
11:41:50 <jkff> Those are cases where we care lazily about the very last element of the list
11:41:59 <Cale> The best examples have expensive combining functions, but which need to be left-associated
11:42:19 <Cale> and where the list isn't necessarily expected to be very long
11:42:47 <eu-prleu-peupeu1> how do i solve this: http://pastebin.com/m6a58a956 ?
11:42:49 <jkff> Well, I'm not saying that foldl is equivalent either to foldr or to foldl' in every situation, but that it seems to me that there does not exist a non-contrived example of its usefulness.
11:42:49 <Cale> I should say, expensive, but doesn't necessarily require its first argument
11:43:00 <jkff> Yes, basically we're saying the same things
11:43:18 <Cale> jkff: The only examples I can imagine of where foldl is better than foldl' or foldr are large-ish.
11:43:30 <jkff> eu-prleu-peupeu1: Your nick is a good exercise in touch typing
11:43:33 <Cale> There are almost no short one-liners where it's the case.
11:43:51 <nolrai_FG> is there a way to cleanup http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4859#a4859?
11:43:52 <Cale> The combining function is generally going to be something complicated to define.
11:43:52 <jkff> eu-prleu-peupeu1: Well, you have to do ghci -hide-package monads-fd
11:44:05 <jkff> Cale: Thanks, that's what I thought
11:44:14 <mtnviewmark> I'm just not clear that IArray was designed to be instanced by packages outside of GHC's array implementation
11:44:19 <Cale> eu-prleu-peupeu1: iirc, it's something like  ghc-pkg hide monads-fd-0.0.0.1
11:44:49 <Cale> mtnviewmark: That is true.
11:45:15 <mtnviewmark> okay, then the way to provide an array like interface to my type isn't to instance IArray ----
11:45:22 <mtnviewmark> good to know :-)
11:45:33 <Cale> mtnviewmark: When you said "make the interface similar to Array's", I thought you meant borrowing the type signatures and/or names ;)
11:45:39 <mtnviewmark> I did
11:46:08 <Cale> But yeah, instancing IArray is not easy, because they've gone to a lot of trouble to squeeze a bit of extra performance out of it.
11:46:22 <mtnviewmark> but if instancing an existing Type class would have gotten me the interface, that would, of course, be better - since I wouldn't be expanding the namespace (or building a parallel one to be imported qualified)
11:47:20 <Cale> right
11:47:23 <Cale> It would be nice...
11:47:45 <Cale> GHC's arrays still aren't as fast as the array's in older implementations of Haskell somehow.
11:47:51 <Cale> arrays*
11:48:38 <Vanadium> @pl \(a, b) -> (f a, b)
11:48:39 <lambdabot> first f
11:48:42 <Vanadium> aaa
11:48:48 <mtnviewmark> makes me wonder why more of the Prelude isn't factored into typeclasses
11:49:04 <nolrai_FG> where is the docs for the td version of the mtl?
11:49:16 <Heffalump> tf version, you mean?
11:49:24 <nolrai_FG> yes
11:49:36 <mtnviewmark> like I'd have expected Foldable and Traversable to be in the Prelude, with [] being an instance of them -- and the non-qualified Prelude functions to have been members of those typeclasses
11:49:41 <tristes_tigres> anyone is using sqlit3 with ghc ?
11:49:44 <Cale> mtnviewmark: There is a *lot* of inertia to changing the Prelude somehow. Almost everyone would like to see the Prelude evolve, but actually making that happen is awfully hard.
11:49:53 <mtnviewmark> Understood
11:50:12 <Cale> mtnviewmark: If you're interested in it, there are a bunch of us hanging out in #alt-stdlib
11:50:18 <mtnviewmark> oooo
11:50:26 <mtnviewmark> that looks like me in spades!
11:50:27 <Cale> (though there hasn't been much discussion there lately)
11:50:52 <mwc> Cale: how big is the contingent lobbying to have Num superclassed as Group and Ring and all that?
11:50:53 <mtnviewmark> (funny name for a Haskell channel - the word haskell doesn't appear in it!)
11:51:16 <Heffalump> nolrai_FG: aren't they with the package?
11:51:17 <mtnviewmark> heh - I'd be in the anti-group for that
11:52:11 <Cale> mwc: Personally, I think a class named "Ring" is a bad idea, since it couldn't accomodate Float
11:52:32 <koeien37> why not?
11:52:40 <Cale> Because Float isn't a ring.
11:52:50 <mtnviewmark> I'd be more interested in making the stdlib more clear, obvious and utilitarian for programmers - and would be willing to give up some mathematical nomenclature and machinery to achieve it
11:52:51 <mwc> heh, I'd agree, there's no need to rebuild MAGMA in the Prelude
11:53:02 <koeien37> Cale: why not?
11:53:10 <Cale> koeien37: Because it's not associative.
11:53:16 <Cale> (in either of the operations)
11:53:21 <mwc> koeien37: Floating Point arithmec isn'tthe same thing as Real arithmetic
11:53:34 <koeien37> yeah okay, but why can't we ignore this?
11:54:07 <Cale> I just prefer the name "Num" because it doesn't imply anything about laws. :)
11:54:07 <mwc> koeien37: if you care about getting accurate FP results, you need to be aware that it's not safe to assume they model the reals
11:54:46 <Cale> I'd go for Additive and Multiplicative for the superclasses of Num if we were going to split it up.
11:54:49 <koeien37> yeah sure
11:55:19 <mwc> koeien37: for instance, if you have abc where a is very small and b,c very large, then a(bc) loses more precision than (ab)c
11:55:24 <koeien37> yeah i know
11:55:44 <mwc> so in general, a(bc) /= (ab)c and associativity is out the window
11:56:00 <mwc> and in mathematics, there's no such things as close
11:56:07 <Vanadium> > let numInt f a b n = let dx = (b - a) / fromIntegral n in  sum $ map ((* dx) . f) [a, a + dx .. b] in numInt (\x -> cos (2*pi*x)) 0 100 1000000
11:56:10 <lambdabot>   * Exception: stack overflow
11:56:17 <Vanadium> Why can this not somehow run in constant space? :<
11:56:21 <mwc> FP arithmetic being almost associative and a dollar will get you a cup of coffee
11:56:33 <jkff> Vanadium: Because 'sum' is lazy
11:56:53 <jkff> > let numInt f a b n = let dx = (b - a) / fromIntegral n in  foldl' (+) 0 $ map ((* dx) . f) [a, a + dx .. b] in numInt (\x -> cos (2*pi*x)) 0 100 1000000
11:56:56 <lambdabot>   1.0000276453532166e-4
11:56:58 <BONUS> just foldl1' (+) it
11:57:10 <BONUS> ya
11:57:27 <Vanadium> Right, thanks :<
11:57:45 <jkff> :t foldl1'
11:57:46 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
11:57:56 <jkff> Heh. For some reason, I thought it didn't exist
11:58:25 <jkff> Anyway, in this algorithm you need foldl', not foldl1'.
11:58:51 <tristes_tigres> ghc is not seeing sqlite3.dll, even though it's in %windiwr%\system32 and ghc  --print-libdir
12:01:08 <nolrai_FG> Heffalump: yeah, but if you search for td you dont find them.
12:02:46 <nolrai_FG> does implementing Prompt in the style the tf mtl uses make sense?
12:05:28 <hresu> How easy/difficult is it to deploy a haskell gui app as binaries for mac os, windows, and linux these days?
12:09:45 <nolrai_FG> I.e. implement Prompt by PromptT p Id?
12:10:15 <Cale> hresu: Well, they tend to be statically linked against the libraries they use. I'm not sure how the bindings with Gtk2 work with regard to linking though.
12:10:34 <ppavelV6> hi everybody
12:10:43 <koeien37> hello
12:10:47 <Cale> hresu: I suppose on windows/mac you might have to get people to install GTK 2
12:11:11 <Vanadium> Good luck with that
12:11:12 <sinelaw> conal, if you're there, i have a question about FRP and denotational design
12:11:20 <hresu> Cale: but if I were to develop a working app under Linux, how painful do you think it'd be to get binaries for the other platforms?
12:11:48 <Cale> hresu: Theoretically, not so painful. You should hardly have to modify the code itself at all.
12:11:51 <mercury^> Ever since I used lhs2TeX, I long for a similarly easy way to specify multiple left aligned columns with correct spacing in latex.
12:12:09 <conal> sinelaw: i'm here.
12:12:29 <hresu> Cale: I've searched, but not found documentation on this; can you point me to some?
12:12:33 <ppavelV6> I'm thinking about the concept that i only can describe like "Monad without return". You have binding (associative) but don't mess putting things into it (nor can you get anything out). The application for this will be composing paths in graphics packages like Cairo or CoreGraphics. Does anyone aware of such a beast?
12:13:02 <Cale> hresu: You should just be able to build the same code on a windows machine with GHC installed on it.
12:13:12 <Cale> hresu: etc.
12:13:36 <hresu> Cale: hmm, ok; thanks
12:13:37 <nolrai_FG> ppavel:: a monoid? hmm
12:13:45 <Cale> hresu: GHC doesn't cross compile (yet?), but the libraries are mostly the same on all platforms.
12:13:59 <Cale> hresu: Unless you go using the bindings to Posix or Windows API's of course.
12:14:16 <nolrai_FG> ppavel: what kind we talking about * or * -> *?
12:14:21 <sinelaw> conal, great. i'm trying to define clearly what FRP is, and what is it that makes it better than other approaches. So far (with Peaker's help) i've concluded that FRP is about doing denotational design for reactive systems, which brings up the question whether denotational design neccesarily means _functional_.
12:14:25 <ppavelV6> holrai_FG: *->*
12:14:25 <hresu> Sure, I don't plan to hardcode a bunch of paths in /usr either :-)
12:14:42 <kmc> ppavelV6, i've often wanted "arrow without pure"; this seems similar
12:15:05 <ppavelV6> kmc: probably but somehow weaker
12:15:16 <ppavelV6> does this make any sense?
12:15:31 <kmc> so you do have join :: m (m a) -> m a ?
12:15:52 <ppavelV6> kmc: good question :))) let me think a bit
12:15:59 <conal> sinelaw: in a sense denotational design is inherently functional: in as much as denotational semantics is about mapping languages into the lambda calculus.
12:16:29 <PeakerWork> kmc: have you looked at DeepArrow?
12:16:39 <Cale> hmmm... and the lambda calculus is the language of Cartesian closed categories...
12:16:52 <tristes_tigres> OK, I solved the problem. Even though sqlite3.dll is in directory shown by "ghc  --print-libdir", you still have to tell this directory to Cabal explicitely in the flag  "--extra-lib-dirs"/ Looks like a bug to me
12:17:06 <jkff> Is there a package on Hackage abstracting the things from "Bananas, lenses etc."? I mean folds for fixpoints of functors. I kind of expected that from Data.Foldable, but alas.
12:17:08 <ppavelV6> kmc: sure it will have. No I don't know about DeepArrow
12:17:32 <conal> sinelaw: but you could say "math" instead of "functional"
12:17:50 <conal> sinelaw: since the functional part (target of the semantics) doesn't have to execute
12:18:17 <ppavelV6> kmc: class My t where (>>>=):: t a->(a->t b) so join' tta = tta >>>= id
12:18:27 <jkff> Oh, I found http://hackage.haskell.org/package/th-fold and http://hackage.haskell.org/package/fixpoint
12:18:59 <jkff> 'fixpoint' is exactly what I've been seeking for, thanks jkff :)
12:19:04 <sinelaw> conal, so when talking about FRP we really  should mean "design you program with precise mathematical descriptions to parts of your design"
12:19:20 <sinelaw> the "R" of FRP just means we're using this for reactive systems, no more
12:19:50 <conal> sinelaw: and, as i said in my "push-pull frp" talk, i regret the name "frp".
12:20:13 <sinelaw> ah. and, for the layman, all this really means he's out of a job
12:20:13 <conal> sinelaw: for me, (continuous) time is more central than reactivity
12:20:20 <conal> "functional temporal programming"
12:21:07 <conal> "dynamic values without mutability"
12:21:11 <conal> something like that
12:21:16 <PeakerWork> conal: It might be a good way to distinguish your work/libraries from other FRP attempts which don't model continuous time
12:21:35 <ppavelV6> kmc: the reason for the construct is that there's a large difference between having some path and having no path at all. Paths are composable but i'm not willing to let (myself) to cheat with creating 'fake' paths with return something. Only real path operation are allowed to return the value in this type. Some functions (like getting the current point or stroking) work on the values of the type. The type is itself abstract and path composition is achi
12:21:35 <ppavelV6> via 'bind' operation
12:21:37 <PeakerWork> conal: (calling your newer works FTP might be a bad idea though :)
12:21:44 <sinelaw> FRP :)
12:21:51 <sinelaw> s/FRP/FTP
12:21:52 <conal> sinelaw: yeah.  for me the central aspects always were (a) precise & simple denotation and (b) continuous time.
12:22:20 <conal> sinelaw: both of those aspects get lost in some systems
12:22:48 <sinelaw> why is it that continuous time is so important?
12:22:48 <conal> sinelaw: i'm having trouble parsing your "design you program with ...".  especially the "to".
12:23:13 <sinelaw> conal, sorry - i meant 'for'
12:23:23 <conal> sinelaw: and i'm guessing you're talking about DD rather than specifically FRP there.
12:23:42 <conal> sinelaw: ah, thanks.  yes, though replace "parts of" with "all of"
12:24:59 <conal> sinelaw: iow: don't just *say* things precisely (syntax & types), *mean* things precisely (semantics).
12:26:04 <conal> sinelaw: i think of syntax & types as form and semantics as substance.  so i spend more time on the latter than the former.
12:26:37 <Gracenotes> hm, does it make sense to call something a "unit subtype"? i.e., B is a subtype of A, and B only has one possible value (and bottom)
12:29:00 <conal> Gracenotes: makes sense to me.  also "singleton"
12:32:04 <dpratt71> I came across a "kind" sigature the other day when reading about type families; I thought I understood what was being expressed, but now I'm not as sure
12:32:47 <dpratt71> class GMapKey k where
12:32:48 <dpratt71>     data GMap k :: * -> *
12:32:48 <dpratt71>     ...
12:33:02 <conal> sinelaw: good point about "FTP".  i'll keep thinking.  suggestions welcome.
12:33:15 <kmc> this means that "GMap k v" is a type
12:33:23 <kmc> that is, "GMap k" expects one more type argument
12:33:40 <kmc> hence it has kind * -> *: a type-level "function" from a type (kind *) to a type (kind *)
12:33:44 <amaron> what do I use instead of list in foreign exported haskell function?
12:33:52 <amaron> Ptr?
12:34:25 <dpratt71> kmc: ok, it might help me to try to understand why the declaration wasn't simply "data GMap k v"
12:35:15 <kmc> because v isn't in scope
12:35:33 * RayNbow just spent a lot of brain cycles to understand yoneda :: (forall b . (a -> b) -> f b) -> f a in sigfpe's latest blogpost... (took me a while :p)
12:36:38 <kmc> a class-associated type can only use the class's type variables as parameters
12:37:20 <dpratt71> kmc: ok, what would be the effect of including "v" in the class type's variables?
12:37:30 <amaron> I'm trying something like this: foreign export stdcall shortestPath :: Int -> (Ptr (Ptr Int)) -> IO () and I've got "Invalid type signature" for that line.
12:37:57 <kmc> dpratt71, you then need a way to tell the compiler that for any particular "k" there is only one "v" such that the instance (GMapKey k v) exists
12:38:05 <kmc> otherwise it will get confused when working with the instances
12:38:20 <kmc> that way is called a "functional dependency", and in many cases it's a more roundabout way of achieving associated types
12:38:48 <zygoloid> RayNbow: i've not seen the post but presumably type forall b. (a -> b) -> f b is isomorphic to type f a by parametricity?
12:38:48 <dpratt71> kmc: ok, still not 100% clear, but getting there, thanks
12:39:19 <zygoloid> RayNbow: then yoneda f = f id, and yoneda_inverse x = flip fmap x?
12:39:31 * zygoloid pulls up planet haskell
12:41:54 <tomsw> newbie question, is there an better way to do this:  subSort = sortBy (\j k -> compare (length j) (length k))? In Lisp, length would be the key argument
12:41:56 <dpratt71> previously, I have only encountered type signatures in declarations that did not include named variables; are there other scenarios where they might be combined such as this?
12:42:01 <Cale> amaron: You have to write a wrapper which allocates memory, etc.
12:42:16 <Cale> amaron: You can't just foreign export a function which uses lists directly.
12:42:36 <luite> amaron: you sould probably use CInt instead of Int
12:42:42 <Cale> amaron: Well, in your case, it's taking the list as a parameter, so it won't allocate...
12:43:03 <Vanadium> Aww, why is System.Random so slow
12:43:07 <Cale> amaron: But if you want to interface with something that uses a list, you'll have to read the elements from memory at that pointer.
12:44:06 <luite> amaron: if you have a list and want to make a Ptr CInt, you do something like withArray (map fromIntegral xs) $ \ptr ->
12:45:12 <kmc> tomsw:
12:45:16 <kmc> :t compare `on` length
12:45:18 <lambdabot> forall a. [a] -> [a] -> Ordering
12:45:28 <RayNbow> zygoloid: yes it is
12:45:32 <kmc> "on" lives in Data.Function
12:45:45 <Axman6> dpratt71: what's the problem?
12:45:54 <tomsw> kmc: thanks
12:46:32 <Axman6> tomsw: using 'comparing length' is even nicer
12:46:49 <dpratt71> Axman6: are you referring to my last comment?
12:46:56 <Axman6> yes
12:47:06 <PeakerWork> @src comparing
12:47:07 <lambdabot> Source not found. It can only be attributed to human error.
12:47:15 <RayNbow> :t comparing
12:47:17 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
12:47:18 <PeakerWork> @type (comparing, (compare `on`))
12:47:18 <luite> amaron: oh sorry didn't see that it was export, not import
12:47:20 <lambdabot> forall b a b1 a1. (Ord a, Ord b1) => ((b -> a) -> b -> b -> Ordering, (a1 -> b1) -> a1 -> a1 -> Ordering)
12:47:22 <Axman6> comparing = compare `on`
12:47:31 <Axman6> comparing f = compare `on` f
12:47:40 <PeakerWork> comparing = (compare `on`) yeah
12:47:53 <amaron> luite, Cale: I've allready did that code, also tried with Ptr CInt, but compiler again complains with "Invalid type signature"
12:48:21 <amaron> I later use peekArray to convert it
12:48:32 <amaron> but I cannot pass foreign line
12:48:52 <dcolish> why does it appear that i need a point when using concatMap?
12:49:09 <dcolish> for ex:  result r = head $ H.xread $ concatMap (unwords.tail.lines) r
12:49:11 <luite> amaron: have you set {-#LANGUAGE ForeignFunctionInterface #-} in your source file?
12:49:33 <dpratt71> Axman6: probably because I am a Haskell newbie, I had not prior encountered Haskell declarations that use a combination of named parameters and type signatures in a single declaration
12:49:42 <amaron> luite: ah, no, let me try
12:49:43 <dpratt71> it always seemed to be one or the other
12:49:48 <koeien37> dcolish: you can remove the r , but change the $ into .
12:50:01 <Axman6> dpratt71: i try and always use both
12:50:18 <Twey> Named parameters?
12:50:23 <dpratt71> Axman6: in one declaration?
12:51:07 <dcolish> koeien37: ah!
12:51:21 <kmc> dpratt71, can you give an example of this sort of declaration?
12:51:22 <dpratt71> normally, I see something like:
12:51:22 <dpratt71> f :: Int -> Int
12:51:22 <dpratt71> f x = x * x
12:51:30 <dpratt71> two lines
12:51:31 <amaron> luite: that fixed the problem, thanks
12:51:46 <dpratt71> (not sure if that's even right)
12:51:49 <luite> ok, great :)
12:52:29 <dpratt71> anyways, the "x" parameter is expressed in the type signature
12:54:08 <dpratt71> in the case of "data GMap k :: * -> * ", (I think) k is not represented in the kind signature, but rather is in addition to it, if that makes any sense
12:54:10 <dcolish> whats a good library for config parsing?
12:54:28 <Twey> HsLua
12:54:32 <Twey> Dyre
12:55:27 <kmc> yes
12:55:37 <kmc> because it's "GMap k :: * -> *", not "GMap :: * -> *"
12:55:49 <kmc> likewise, with your f above you could say "f 3 :: Int"
12:56:19 <kmc> > let f = (subtract 2 :: Int -> Int) in f 5
12:56:20 <lambdabot>   3
12:57:44 * dpratt71 is thinking about kmc's remarks
12:58:01 <lispy|web> :t f
12:58:03 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
12:58:08 <dcolish> hmm Dyre looks nice
13:00:00 <dons> haskell @ fosdem. let's do this http://www.haskell.org/pipermail/haskell-cafe/2009-November/068848.html
13:00:09 <Heffalump> wow, quick off the mark there!
13:00:18 <Heffalump> you going to come, then?
13:00:21 <dons> Heffalump: i think i could make it...
13:00:43 <Heffalump> you have a remarkable willingness to make transatlantic flights
13:00:52 <dons> :) and a lot of FF points
13:01:05 <Heffalump> are you coming to Zurihac too?
13:01:09 <dons> yeah
13:02:06 <dons> ok. yeah. let's build a strong program. put me down for work.
13:02:28 <Heffalump> xmonad FTW :-)
13:02:37 <dons> right!
13:03:11 <copumpkin> :O
13:03:43 <dons> how do they decide to accept a proposal?
13:03:48 <dons> what are the main critiera?
13:05:14 <Heffalump> not really advertised, I don't think
13:06:02 <dpratt71> kmc: ok, I can sorta make sense of this in at least three different ways; I'm wondering which way (if any) is the most correct...
13:06:04 <dons> so we assume it is the strenght of the program, the reputation of the community, likely interest to attendees...
13:06:20 <dons> (e.g. we could cite the OSCON/InfoQ success?)
13:06:26 <Heffalump> expect so
13:06:31 <Heffalump> is InfoQ open-source?
13:07:15 <dpratt71> so, one thought is that the kind signature is actually bound to "k", so that's how the overall kind of GMap is * -> * -> *
13:07:17 <dons> don't think so. but they definitely have been getting a bump from haskell stuff
13:07:32 <dons> OSCON however - we have stats on SPJs talks. and bos' has been involved
13:07:40 <Heffalump> not sure that citing non-OS stuff is too relevant. But yeah, definitely OSCON.
13:07:50 <kmc> dpratt71, it is also a correct statement to say that "GMap :: * -> * -> *".  but it's not sufficient to *define* the class-associated type, because an instance of the data-family GMap lives in an instance of the class GMapKey, and we want a certain relationship between those instances
13:08:02 <dpratt71> another thought is that Gmap applied to some "k" has a resulting signature of * -> *
13:08:15 <kmc> yes, the second thing you said is correct and not the first
13:08:32 <kmc> the signature attaches to "GMap k"
13:08:33 <dpratt71> kmc: ah, that helps a lot
13:09:26 <dpratt71> kmc: ok, I think I pretty much "get it" now, thanks for your help
13:09:31 <kmc> cool :)
13:09:47 <kmc> in particular we assume that k :: *
13:09:55 <kmc> if not, we'd have to say so in the class head, i think
13:09:59 <dpratt71> ok
13:11:02 <bob0> What's wrong with the indentation here? http://pastebin.com/f3ba36a07
13:11:12 <dpratt71> (now I just need to figure out why we're doing this in the first place :) )
13:12:13 <Twey> bob0: Your ‘where’ is inside your ‘do’
13:13:18 <dcolish> well, while Dyre is awesome its a bit more complex than i need
13:13:48 <Twey> HsLua it is then
13:13:58 <dcolish> that didnt look simple either
13:14:07 <dcolish> i really like the python style config
13:14:09 <Twey> http://www.haskell.org/haskellwiki/HsLua
13:14:12 <Twey> Exceedingly simple
13:14:20 <Twey> And also very powerful
13:14:34 <dcolish> didnt see the wiki page, i was judging from hackage pages
13:15:19 <bob0> Twey: I took it out: http://pastebin.com/f8ef04a7
13:15:44 <Twey> bob0: Your ‘where’ is ‘inside’ your ‘forM_’
13:15:56 <Twey> ‘where’ clauses can only be attached to function equations
13:16:25 <bob0> Twey: oh
13:16:59 <Twey> And they must appear at the bottom of them
13:17:50 <dpratt71> bob0's question reminded me of a question I had recently...
13:18:31 <dpratt71> I was reading about "do" notation (in the doc wiki?) and it was describing the advantages thereof...
13:20:32 <kmc> Dyre looks not too bad either
13:20:47 * dpratt71 is finding it hard to explain the question 
13:20:52 <dpratt71> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4861#a4861
13:21:43 <Twey> dpratt71: The answer is the same.  You can't attach a ‘where’ to an arbitrary ‘do’ block.
13:21:53 <Twey> It has to go with a function equation.
13:22:31 <kmc> dpratt71, what's your question?
13:22:40 <dpratt71> Twey: ok, my version is "name2", btw...no "do" block there
13:22:53 <kmc> name2 is the typical de-sugaring of nameDo
13:23:18 <binrapt> Is Haskell a good choice if I have to write a memory sensitive service? (as in, the system it runs is rather weak, little physical memory is available) Does Haskell generally use considerably more memory to solve a problem in comparison to, say, a C++ application which implements essentially the same algorithm?
13:23:32 <dons> how little physical memory do you have?
13:23:34 <kmc> (except you got rid of the "let full" binding)
13:23:45 <kmc> binrapt, in general it is difficult to write Haskell programs which are conservative with memory usage
13:23:46 <dpratt71> kmc: I tried to leave first++" "++last in a "where", but it didn't work
13:23:51 <dons> binrapt: at a minimum, a ghc haskell program will have approx. a 1M memory footprint.
13:24:03 <dpratt71> "first" not in scope...
13:24:05 <dons> ghc haskell however, is typically a lot more efficient than java, say. but less than C++
13:24:17 <dons> xmonad, for example, runs in about a constant 2-3M heap.
13:24:18 <dpratt71> did I just bork the indentation?
13:24:22 <binrapt> Overall 1 gigabyte, dons, but a lot of that is already reserved by other programs, the other services are somewhat flexible about it though, I can never quite tell for sure how much is available really
13:24:26 <kmc> dpratt71, right, because the "where" lives on the "outside" of the function body, but first is bound by an inner lambda
13:24:29 <dons> oh. 1G?
13:24:35 <kmc> however you can use "let" outside the "do" notation
13:24:38 <dons> well, that's not really too constrained, is it?
13:25:00 <kmc> "let" is an expression built from smaller expressions, whereas "where" attaches to an entire function equation and is not an expression
13:25:13 <dons> binrapt: imagine, say, 2M heap + dataset size
13:25:18 <binrapt> dons well, I considered using Haskell to write a HTTP service and I am a total newbie at Haskell
13:25:19 <Twey> binrapt: Well-constructed Haskell should be fine on that
13:25:24 <dpratt71> kmc: interesting; I wasn't aware of that distinction
13:25:35 <Twey> Like any language, you have to understand what's going on to optimise it well
13:25:38 <dons> http is no problem we write servers all the time, that run on typical systems. p.s. use lots of threads.
13:25:38 <binrapt> The user load is usually rather low, rarely more than 50 requests per minute
13:25:46 <kmc> > let x = (let y = 4 in y + 2) in x + 3
13:25:47 <lambdabot>   9
13:25:50 <kmc> (pathological example)
13:25:57 <luite> binrapt: if you have a really allocation heavy program you may need to increase heap size and allocation area to get good performance, in such cases manually managed memory might be better
13:25:59 <dons> there's a sammple simple haskell server on a blog somewhere that does 14.4k /sec, if you want to start there.
13:26:15 <luite> but it really depends on what you do
13:26:35 <dons> so, i would say: don't worry about memory, you'll be fine.
13:27:02 <kmc> dpratt71, the do-notation's "let" is a special case which lacks the "in" part
13:27:29 <kmc> do { a; let x = b; c }   ==>  do { a; let x = b in do { c } }
13:27:50 <theclaw> beginners questions: when executing "let a = (getChar >>= (\a -> getChar >>= (\b -> putStrLn (a:b:[]))))" in ghci (interactive mode), no input is read, it is read when trying to evaluate "a"; why?
13:27:58 <theclaw> *question
13:28:02 <kmc> a "do" block itself is an expression, and many powerful things can be done by nesting "do" blocks with various combinators between
13:28:28 <kmc> theclaw, you just defined an IO action named "a"
13:28:33 <kmc> you didn't do anything with that IO action
13:28:39 <dpratt71> kmc: I take it you're not in the "do notation considered harmful" camp? :)
13:28:44 <kmc> nope
13:28:54 <kmc> though it's not always the right tool
13:29:35 <kmc> theclaw, technically the IO happens not when "a" is evaluated, but when it's sequenced into the overall IO action
13:29:42 <kmc> in a standalone program that would be "main"
13:30:08 <kmc> in GHCi, the interactive loop itself is in the IO monad, and *after* evaluating anything of type (IO a) it will sequence it in and print the result
13:30:32 <Twey> In the IO monad, with magic ‘print’s
13:30:36 <binrapt> I am really insecure about web development with Haskell anyways. You would have to shut down and restart the central dynamic content provider service all the time to make new modifications in the code work, right? The next possibility would be having ghc produce some library so you can reload it in the service without having to shut it down? Hm
13:30:48 <Twey> binrapt: Like Dyre?
13:30:51 <binrapt> But that would require quite some foreign language interfacing and such I guess :(
13:31:00 <Twey> Or Dyre.
13:31:24 <kmc> the idea in Haskell is that evaluation and application of functions never performs side effects, but only produces "recipes" for how the side effects would be performed
13:31:25 <theclaw> kmc: hmm. I don't know enough about monads yet to fully understand that I guess
13:31:33 <kmc> theclaw, don't try to understand monads by understanding IO
13:31:37 <kmc> IO is a weird atypical monad
13:32:11 <theclaw> kmc: hmm. I thought "IO ()" just refers to the IO state?
13:32:20 <kmc> what would that mean?
13:32:21 <Botje> theclaw: you understand monads by using them.
13:32:27 <dcolish> how do I convert a () to a String?
13:32:35 <kmc> a value of type "IO ()" is a recipe for performing IO
13:32:45 <Botje> theclaw: all the theory is nice to know once you can write State code without getting a type error
13:32:51 <Botje> dcolish: show ()
13:32:52 <kmc> or an "action" or a "computation"
13:32:59 <kmc> > show ()
13:33:00 <lambdabot>   "()"
13:33:01 <Botje> dcolish: it won't be real useful though.
13:33:27 <dcolish> ok so lets say i'm reading someting in that returns a IO (), but i need that value to be a string
13:33:33 <kmc> () is not IO ()
13:33:41 <nolrai_FG> show = const "()" --for ()
13:33:54 <Botje> dcolish: why?
13:33:57 <kmc> dcolish, returning "IO ()" means that you're doing IO but not producing a value
13:34:02 <kmc> so what value would there be to string-ify?
13:34:14 <kmc> (technically, you produce the useless value (), whose type is also written ())
13:34:22 <Kim^Walkman> theclaw: A way that made me understand how it works is think of the code as instructions to follow (as opposed to an actual value)
13:34:23 <nolrai_FG> dcolish: what exactly are you talking about?
13:34:47 <dcolish> reading in a Lua config value and returning that to my main
13:34:48 <nolrai_FG> Kim^Walkman: that's how I think of it.
13:34:49 <tensorpudding> returning IO () means that you're doing a computation that doestn't return a value in a sense, it might just do some side-effect
13:34:56 <Kim^Walkman> theclaw: If I write you a note that says “1. Go to ATM. 2) Get me cash” it has no actual value
13:35:09 <Kim^Walkman> theclaw: However, if you follow the instructions (ie. execute it) it suddenly becomes cash
13:35:46 <nolrai_FG> and “1. Go to ATM. 2) Get me cash 3) count the cash” does have a value.
13:36:35 <nolrai_FG> What is the haskell way to store your position in tree like data type?
13:36:41 <_nickel> https://gist.github.com/42604fa3ad536d56c613 anyone know how I can get highlighting like in that gist for vim. Not the colors but rather the elements highlighted separately in a similar fashion
13:36:45 <theclaw> Kim^Walkman: hmm, I think that's not my problem honestly
13:36:45 <Kim^Walkman> nolrai_FG: True, I was speaking in terms of a result however. The note cannot turn into cash unless I follow the instructions (:
13:36:47 <kmc> nolrai_FG, a zipper
13:37:05 <tensorpudding> @type return ()
13:37:06 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
13:37:15 <Kim^Walkman> And I don't get the value, but the result of following the instructions as a separate entity
13:37:34 <Kim^Walkman> … typing without commas late in the evening is bad for readability
13:37:40 <theclaw> kmc: so, e.g. when typing "let ..." in ghci and pressing "enter", what the actual functions - getChar, putStrLn - get executed immediately?
13:38:11 <nolrai_FG> kmc: hmm, I have seen zipers for lists. But dont really get them for trees, what would it look like?
13:38:20 <Kim^Walkman> getChar contains instructions for the operating system that says “get me a character” (kind of)
13:38:29 <nolrai_FG> theclaw: nothing.
13:38:36 <kmc> nolrai_FG, you can make a zipper for any algebraic type by taking its "derivative".  can't explain here but there's stuff on the wiki
13:38:53 <nolrai_FG> `k thanks.
13:39:19 <kmc> theclaw, if you've learned other languages you've probably muddled together two very different concepts: "apply a function to get a result" and "execute some side effects"
13:39:24 <kmc> in haskell we separate these
13:39:30 <kmc> for starters, getChar is not even a function
13:39:31 <kmc> :t getChar
13:39:32 <lambdabot> IO Char
13:39:40 <kmc> note the absence of "->" in its type
13:39:57 <kmc> it doesn't take arguments.  it's just a recipe for doing some IO, with the result being a Char
13:40:00 <theclaw> kmc: I thought it's a function with no arguments
13:40:03 <kmc> no
13:40:14 <kmc> there's no such thing in Haskell.  every function has exactly one argument
13:40:29 <Kim^Walkman> yay currying
13:40:44 <theclaw> okay, makes sense
13:41:03 <kmc> you can make a function whose argument is (), the useless type, but there's almost no reason to do so
13:41:14 <tensorpudding> > id ()
13:41:15 <lambdabot>   ()
13:41:39 <Gracenotes> in GHC, IO Char is a sort-of-function: given the current state of things, return a new state of things where a character has been read, with the character that's been read as the result. But that's just one way of looking at it.
13:42:01 <Gracenotes> er. I don't want to confuse anyone :/
13:42:19 <kmc> that's an implementation detail
13:42:27 <kmc> a newtype of a function is not a function
13:42:32 <tensorpudding> it may have many functions in its implementation
13:42:33 <kmc> especially when you hide the data constructor
13:43:10 <kmc> theclaw, so we have functions, which compute outputs from inputs.  they have nothing to do with side effects; they're like functions in math
13:43:34 <kmc> in math you can say "f(x) = 2*x + 3" but it's nonsense to say "f(x) = write x two inches to the left on the paper"
13:43:35 <tensorpudding> they have a "domain" and a "range"
13:43:50 <theclaw> kmc: yes, I got that
13:43:51 <Gracenotes> kmc: it is a sort-of-function :)
13:44:05 <kmc> cool
13:44:14 <tensorpudding> although in maths, a function on multiple variables is usually not curried
13:44:28 <tensorpudding> but expressed as acting on a cartesian product
13:45:02 <tensorpudding> but in haskell, you can change functions of type a -> a -> a to (a,a) -> a
13:45:10 <tensorpudding> @type uncurry
13:45:11 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
13:50:22 <Guest40776> is there a function in haskell which return the current position of an element in a list
13:51:04 <Kim^Walkman> Guest40776: Look in Data.List
13:51:17 <Vanadium> Is there a function that is \f a n -> iterate f a !! n, except strict?
13:51:33 <binrapt> So what exactly can I do with Dyre? Sounds complicated. My scenario was this: A persistent Haskell HTTP service, perhaps run in combination with nginx - you keep on modifying files to fix some things on the site and you obviously don’t want to have to relaunch the service all the time.
13:51:41 <Kim^Walkman> LordDoskias: Namely elemIndex (for example)
13:52:00 <tensorpudding> @src elemIndex
13:52:01 <lambdabot> elemIndex x     = findIndex (x==)
13:52:09 <tensorpudding> that's not helpful so much
13:52:11 <kmc> LordDoskias, if you need that a lot, then a list is probably not a good datastructure
13:52:31 <theclaw> kmc: I don't get it. Could you please explain what happens when this "let a = " statement is executed?
13:52:42 <kmc> > let a = 3 in a + 1
13:52:43 <lambdabot>   4
13:52:59 <kmc> "let" just gives names to some expressions
13:53:48 <theclaw> kmc: yes, but what happens with "getChar >>= (\a -> getChar >>= (\b -> putStrLn (a:b:[])))"?
13:53:53 <kmc> same thing
13:53:59 <kmc> :t getChar >>= (\a -> getChar >>= (\b -> putStrLn (a:b:[])))
13:54:00 <lambdabot> IO ()
13:54:03 <kmc> that's an expression
13:54:05 <kmc> you give it a name
13:54:06 <theclaw> kmc: no chararcters are actually read, right?
13:54:10 <kmc> correct
13:54:25 <theclaw> kmc: but the two lambda functions are applied?
13:54:34 <JohnnyL> have any of you created AJAX/J apps with Haskell
13:54:34 <kmc> no, they have no arguments
13:54:41 <JohnnyL> ?
13:54:45 <theclaw> kmc: what's with a,b?
13:54:51 <kmc> ?
13:55:04 <kmc> an application looks like this:
13:55:06 <theclaw> kmc: why do they have no arguments?
13:55:08 <kmc> > (\a -> a + 2) 3
13:55:09 <lambdabot>   5
13:55:10 <m0nkfish> is there a difference between "let" and "where"
13:55:12 <m0nkfish> (beyond syntax)
13:55:19 <kmc> you need something to substitute in for a and b
13:55:36 <theclaw> kmc: I thought that's what ">>=" does?
13:55:45 <kmc> only once the IO happens
13:55:51 <kmc> you don't have the value until then
13:56:05 <tensorpudding> the >>= unwraps getChar and puts the character into the lambda, when getChar is actually executed
13:56:28 <kmc> but it's messy to think of what happens when;  much better imo to think of building instructions for how to do some IO
13:57:01 <kmc> and a "let" within a do block (which the GHCi prompt is) never does any IO
13:57:11 <theclaw> kmc: hmm,
13:57:19 <kmc> it gives names to some expressions, which you can use later in that "do" block, to do IO or for any other purpose
13:57:36 <kmc> so after this you can type "a" at the GHCi prompt and it will do the IO
13:57:46 <sjanssen> what's currently the fastest structure for storing a set of strings?
13:57:47 <LordDoskias> basically i have to write as function doing the same as elemAt
13:57:48 <theclaw> kmc: that made the whole thing much more clearer - thanks a lot
13:57:49 <Kim^Walkman> m0nkfish: let […] in […] is an expression, but […] where […] is not
13:57:50 <LordDoskias> but with recursion
13:57:56 <kmc> :)
13:57:56 <sjanssen> by currently I mean implemented and in hackage
13:58:06 <theclaw> very helpful channel :)
13:58:08 <Gracenotes> tensorpudding: well.. operationally speaking.. isn't evaluation of getChar forced by the time it's put in a Char constructor?
13:58:38 <Gracenotes> in fact, even before that, isn't it forced just by the >>=? >=>
13:58:39 <tensorpudding> i wouldn't know...i'm still pretty dim when it comes to this stuff
13:58:49 <kmc> strictly speaking, evaluating getChar doesn't do the IO either
13:58:50 <Gracenotes> <.<
13:58:52 <tensorpudding> i don't know how exactly the IO monad handles things
13:58:54 <Kim^Walkman> sjanssen: I guess it'd depend on what operations you need on them
13:59:15 <kmc> i'd expect that getChar being a CAF is already at WHNF
13:59:26 <Gracenotes> of course, you could do getChar `seq` 4, and it wouldn't do a thing
13:59:31 <tensorpudding> CAF?
13:59:35 <kmc> constant applicative form
13:59:46 <sjanssen> Kim^Walkman: I need a set structure of strings, insertion and lookup are the operations I need
13:59:48 <tensorpudding> man, i don't know anything
13:59:49 <Gracenotes> there is magic in >>=. aka bindIO
14:00:26 <Gracenotes> in fact, there's magic everywhere. the whole thing is magical.
14:00:32 <kmc> Gracenotes, not that much magic (in GHC).  just the careful use of "case" to force things at the right times
14:00:41 <kmc> to my limited understanding, at least
14:00:48 <Kim^Walkman> sjanssen: You mean like Map? (dictionary of key -> values)
14:01:12 <sjanssen> Kim^Walkman: I mean like Data.Set, but for strings and really fast
14:01:14 <kmc> sjanssen, if you don't mind using the IO monad, Judy arrays are supposed to be really fast
14:01:43 <Gracenotes> ah. so you might pinpoint the magic in the primitive nature of State# ;)
14:01:58 <kmc> you mean RealWorld#? or something else?
14:02:05 <Kim^Walkman> sjanssen: Oh, no idea then (:
14:02:38 <sjanssen> dons: the ByteString instance in judy seems not useful/dangerous
14:03:10 <Vanadium> Is ByteString what I am supposed to use for binary IO?
14:03:14 <kmc> oh right, it's State# RealWorld
14:04:16 <sjanssen> Vanadium: yes
14:04:19 <Gracenotes> I need to look into the RTS and figure it out once and for all..
14:07:03 <binrapt> Was using \t instead of spaces problematic in Haskell? I recall having had a problem with this in the past
14:07:21 <kmc> in source code?
14:07:30 <binrapt> Yers
14:07:31 <binrapt> *Yes
14:07:35 <kmc> iirc \t is treated as some fixed number of spaces, maybe 8
14:07:36 <sjanssen> binrapt: it is a problem if your editor shows tabs as not 8 spaces, or if you mix tabs and spaces
14:07:46 <kmc> anyway \t is evil
14:07:48 <sjanssen> binrapt: using spaces only is highly recommended
14:08:08 <binrapt> I use \t only really, I hate spaces with a passion
14:08:13 <binrapt> Visually represented as 4
14:08:24 <nolrai_FG> :t liftM
14:08:26 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:08:34 <sjanssen> binrapt: yep, that will give you headaches with Haskell
14:08:37 <kmc> :t fmap
14:08:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:08:42 <kmc> :t (<*>)
14:08:43 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:08:46 <kmc> :t (<$>)
14:08:46 <Kim^Walkman> binrapt: I used to be like you until I started learning python and haskell
14:08:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:08:48 <sjanssen> there's code that can change meaning depending on how wide tabs are
14:08:56 <Sadache> anyone know a pointer that explains how lift2 id produces ap? this thing drives me crazy? I guess it shows the power of type guessing the checker does.
14:09:07 <binrapt> Kim^Walkman Python made me love \t over spaces even more
14:09:19 <kmc> unlike Python, you can write Haskell without any whitespace-dependence
14:09:55 <sjanssen> Sadache: start by understanding this definition: "($) :: (a -> b) -> a -> b; ($) = id"
14:10:05 <LordDoskias> http://pastebin.com/m79340940
14:10:08 <binrapt> kmc I am puzzled, sjanssen just told me that that is not the case?
14:10:10 <LordDoskias> where is the problem in that code
14:10:18 <BONUS> @src liftM2
14:10:19 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:10:40 <kmc> binrapt, the whitespace dependence is specified as a self-contained function which inserts "invisible" { } and ;
14:10:50 <nolrai_FG> > split 2 "abcd"
14:10:51 <kmc> you can write those in yourself and it will do nothing
14:10:53 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
14:10:53 <lambdabot>         against inferr...
14:10:57 <kmc> you can also mix the styles as desired
14:11:02 <kmc> > let { a = 3; b = 4 } in a + b
14:11:03 <lambdabot>   7
14:11:07 <nolrai_FG> > :t split
14:11:09 <lambdabot>   <no location info>: parse error on input `:'
14:11:13 <BONUS> now what happens if f is id? it's do { x1 <- m1; x2 <- m2; return (id x1 x2)}. and id x1 x2 is just x1 x2. so it returns the function it gets from the first applicative applied with the value from the second
14:11:18 <nolrai_FG> :t split
14:11:19 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
14:11:42 <sjanssen> nolrai_FG: you want splitAt
14:11:51 <dpratt71> Sadache: funny, the same thing was bothering me the other day; I finally figured it out, but I'm almost afraid to revisit it in case I forgot :)
14:12:10 <kmc> binrapt, so unlike python there is a non-whitespace-dependent way to write any syntactic element
14:12:16 <nolrai_FG> > splitAt 2 "abcd"
14:12:17 <lambdabot>   ("ab","cd")
14:12:19 <dpratt71> I should say "I figured it out with a lot of help from #haskell"
14:12:25 <kmc> (a much better design imo)
14:12:43 <binrapt> kmc so you have to resort to awkward non-standard notation at times if you want to use \t only?
14:12:47 <tensorpudding> though does anyone really use the braces?
14:12:49 <LordDoskias> any1 got ideas ?
14:13:03 <kmc> it's in the standard.  and i don't think it's that awkward
14:13:05 <kmc> but essentially yes
14:13:15 <binrapt> :((
14:13:17 <kmc> if your \t are not 8 characters
14:13:22 <dcolish> fg
14:13:26 <dcolish> shoot!
14:13:33 <kmc> fg: current: no such job
14:13:44 <Kim^Walkman> LordDoskias: Same question back at you
14:13:46 <sjanssen> binrapt: you can use \t only, you just need to reconfigure your editor to use the standard definition of \t
14:13:47 <sohum> also, the braces are really good for code generation
14:14:01 <tensorpudding> There are good reasons to have it for code generation but it's less readable
14:14:07 <kmc> if python did whitespace this way, it might have a real lambda expression
14:14:09 <Kim^Walkman> LordDoskias: Or, well, *what* is the problem?
14:14:13 <dcolish> kmc: :)
14:14:28 <LordDoskias>  http://pastebin.com/m79340940\
14:14:28 <shambler> sjanssen, what is standard definition of \t?
14:14:29 <Sadache> BONUS: I need to stair at the code for while. My lift2 is let lift2 h f1 f2 a = h (f1 a) (f2 a)
14:14:29 <LordDoskias>  http://pastebin.com/m79340940
14:14:32 <LordDoskias> this is the problem
14:14:35 <LordDoskias> the code doesn't work
14:14:39 <kmc> if you really really absolutely positively need your 4-character tabs, you can use a tiny preprocessor
14:14:43 <sjanssen> shambler: align to the next 8 space boundary
14:15:10 <Sadache> dpratt71: I hope I'll do too :)
14:15:26 <BONUS> ah, that's lifting for (->) r only. liftA2/liftM2 is more general
14:15:30 <Kim^Walkman> LordDoskias: It compiles and runs; probably not like you want it but I can't read your mind
14:15:41 <dpratt71> Sadache: you will, but don't get frustrated if it takes a while
14:15:59 <jlouis> shapr: the unicycler of doom enters the Arena!
14:16:04 <LordDoskias> Kim^Walkman: should be a replace for intersperse
14:16:06 <shapr> jlouis: yay!
14:16:12 <LordDoskias> but it doesn't run for me o_O
14:16:14 <shapr> jlouis: I met a unicyclist in Huntsville yesterday!
14:16:17 <Sadache> BONUS: I know, actually my code is in F# where I need to redifine these and there I dont have type classes
14:16:29 <BONUS> ah
14:16:33 <jlouis> shapr: The unicycling hunter of doom?
14:16:41 <LordDoskias> Kim^Walkman:  the idea is to add separator character between each elemnt of the list
14:16:59 <jlouis> I dropped the unicycle again and went back to swimming
14:17:21 <shapr> jlouis: Nah, cute little asian artist woman.
14:17:44 <jlouis> shapr: so you did fall in love?
14:17:49 <jlouis> :P
14:17:59 <shapr> Nah, doing that elsewhere.. different nationality.. one I haven't tried before!
14:18:15 <Kim^Walkman> LordDoskias: That's exactly what it does for me;
14:18:29 <Kim^Walkman> LordDoskias: “between '.' "abcd"” => "a.b.c.d."
14:18:31 <LordDoskias> but if i got '_' as a separator and then 1,2,3,4
14:19:18 <Kim^Walkman> LordDoskias: It's a type error to mix characters with numbers; a list can contain only one type
14:19:46 <Kim^Walkman> LordDoskias: You want it to print "1_2_3_4" when given “between '_' [1,2,3,4]”?
14:19:48 <LordDoskias> hmz
14:19:54 <LordDoskias> let me try something
14:20:23 <LordDoskias> between :: a -> [a] -> [a]
14:20:31 <LordDoskias> i thought this means it doesn't care what i pass for a
14:20:38 <Kim^Walkman> It means all a’s must be of same type
14:20:45 <LordDoskias> or yo mean whatever i pass as a separator the same i should to the second
14:21:14 <Sadache> BONUS: thank you for your help.
14:21:17 <Kim^Walkman> LordDoskias: It can be “between :: String -> [String] -> [String]” or “between :: Int -> [Int] -> [Int]” but *not* “between :: Int -> [Integer] -> [Integer]”
14:21:23 <BONUS> no problem :D
14:21:30 <LordDoskias> i see, thansk
14:21:44 <LordDoskias> i did 3/6 of the recursions
14:21:45 <Kim^Walkman> LordDoskias: You could convert your input list to a string, for example
14:21:48 <BONUS> this trick with id being used as a binary function is used elsewhere too
14:22:04 <BONUS> :t id :: a -> (a -> b) -> b
14:22:05 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a -> b) -> b
14:22:06 <lambdabot>     In the expression: id :: a -> (a -> b) -> b
14:22:18 <BONUS> :t id :: (a -> b) -> a -> b
14:22:19 <lambdabot> forall a b. (a -> b) -> a -> b
14:22:23 <Kim^Walkman> LordDoskias: between '_' (concatMap show [1..5])
14:22:40 <BONUS> > zipWith id [(+2),(+3),(+4)] [1,2,3]
14:22:41 <lambdabot>   [3,5,7]
14:23:28 <tensorpudding> how did you change id's type there
14:23:37 <jlouis> shapr: heh, cool!
14:23:39 <LordDoskias> Kim^Walkman: another question if x == [] - is this the way to check whether an element of a list is a cons cell
14:23:54 <Sadache> BONUS: do you have a pointer to examples of this trick?
14:24:30 <Kim^Walkman> LordDoskias: It requires “x” to be an instance of Eq (because of the ==), you could use “null”-function to test if x is an empty list
14:24:39 <Kim^Walkman> LordDoskias: But I'm not sure I understand you correctly :)
14:24:42 <LordDoskias> not en empty list
14:24:45 <copumpkin> @tell mmorrow hpaste.org db is locked :(
14:24:46 <lambdabot> Consider it noted.
14:24:57 <LordDoskias> every list in haskell is made up of differenct concs cells, each pointing to the next, right?
14:24:57 <nolrai_FG> :t Data.Map.keys
14:24:58 <lambdabot> forall k a. M.Map k a -> [k]
14:25:06 <LordDoskias> and each list ends with an empty cons cell
14:25:20 <Kim^Walkman> LordDoskias: 1 : 2 : 3 : [] is the same as [1,2,3]
14:25:22 <mauke> each list consists of (:) cells, ending with []
14:25:37 <LordDoskias> indeed
14:25:54 <Kim^Walkman> You can pattern match on a list with one element
14:25:58 <LordDoskias> if i have (x:y:xs) i want to check whether y is []
14:26:13 <mauke> so this is a list of lists?
14:26:30 <LordDoskias> i watn to check whether an element is []
14:26:44 <LordDoskias> i will wirte a function that takes a list and return everything apart from the last element and the []
14:26:53 <mauke> huh?
14:27:08 <Kim^Walkman> LordDoskias: I believe it's easier to do in another way
14:27:14 <kmc> how can you have a (finite) list without a []?
14:27:18 <LordDoskias> i have to do it with recursion
14:27:32 <tensorpudding> > last [1..10]
14:27:34 <lambdabot>   10
14:27:51 <tensorpudding> like that, but as a list?
14:27:56 <LordDoskias> as an excersise
14:28:03 <LordDoskias> nope
14:28:09 <Kim^Walkman> http://pastebin.com/d5799adcb
14:28:15 <LordDoskias> myfunc [1..10] should return [1,2,3,4... 9]
14:28:24 <mauke> LordDoskias: that's not a list of lists
14:28:30 <mauke> so y can't be [], because [] is a list
14:28:44 <Kim^Walkman> mauke: I believe he wants to match on like…
14:28:50 <tensorpudding> you can do a pattern match on x:xs, if xs = [] then return (x : xs), otherwise just recurse on xs
14:28:55 <Kim^Walkman> mauke: Uh… like lists are 1 : 2 : 3 : [] : [] : [] …
14:29:08 <copumpkin> you can't have multiple [] in there
14:29:09 <tensorpudding> err, return [x]
14:29:09 <Kim^Walkman> mauke: (I believe that's what he belives, or something in that sense)
14:29:26 <skorpan> hypothetically, if i were to use unsafePerformIO throughout my haskell program, would it be any more "unsafe" than e.g. python?
14:29:36 <mauke> skorpan: yes
14:29:50 <luite> skorpan: lazyness may bite you
14:29:52 <mauke> skorpan: you can defeat the type system with unsafePerformIO
14:30:00 <mauke> also, segfaults
14:30:05 <tensorpudding> of course, last will fail on infinite lists
14:30:09 <Kim^Walkman> copumpkin: I know, but I believe he wanted to pattern match in such a way that the pattern “(x:y:xs)” matches “[x]” (which it doesn't)
14:30:15 <copumpkin> also, things not getting evaluated multiple times when you intend them to
14:30:24 <skorpan> mauke: but seeing as python is (in some sense) all about defeating the type system, why is unsafePerformIO more unsafe?
14:30:28 <kmc> skorpan, no
14:30:33 <LordDoskias> Kim^Walkman: the magic of pattern matching
14:30:35 <kmc> python is dynamically typed but strongly typed
14:30:41 <LordDoskias> my idea was a little bit more complicated
14:30:42 <mauke> skorpan: no, python doesn't let you sidestep the type system
14:30:46 <kmc> it is important to keep these concepts separate
14:30:49 <Kim^Walkman> LordDoskias: Haskell is lovely :)
14:30:56 <kmc> python will check every operation, at runtime instead of compile time
14:30:58 <LordDoskias> well i hate it
14:31:06 <kmc> unsafePerformIO lets you perform operations that are not checked *at all*
14:31:07 <LordDoskias> but it's in my course so i'd rather learn the basics
14:31:08 <LordDoskias> ...
14:31:11 <skorpan> oh, i see
14:31:20 <skorpan> i thought they were somehow checked at runtime...  don't ask.
14:31:37 <coprogrammer> :O
14:31:38 <kmc> well, the type-unsafety of it is sort of a side effect of its actual purpose
14:31:45 <Kim^Walkman> LordDoskias: Hehe, it takes a while to get used to; especially when most of the documentation seems like it's written for anybody else apart from the “average programmer” (or maybe I'm just a little behind)
14:32:02 <BONUS> Sadache: i don't think they're collected anywhere
14:32:05 <nolrai_FG> LordDoskias: to see if an element is the last just pattern matach on [x].
14:32:16 <BONUS> it's just that id can be viewed as (a -> b) -> a -> b
14:32:28 <BONUS> > (+3) `id` 4
14:32:29 <tensorpudding> how exactly is that?
14:32:29 <lambdabot>   7
14:32:30 <luite> Kim^Walkman: I guess that's true, many packages really could use some proper documentation, with good examples
14:32:36 <skorpan> is the ST monad "the haskell version" of clean's type uniqueness?
14:32:52 <LordDoskias> Kim^Walkman:  your version doesn't work if i change the name of the func to init2
14:33:00 <fryguy> Is there ever a situation when using foldl is correct over foldl'?  And is there ever a sitation when it makes sense to use either when foldr and foldr' are available?  Intuitively it seems like there should be a case for foldl', but I can't think of a concrete example.
14:33:07 <LordDoskias> nolrai_FG:  ok , gonna try someting now
14:33:23 <Kim^Walkman> LordDoskias: Please show your modifications, easier to help if you do :)
14:33:33 <sohum> BONUS: well, yes. :t id is  a -> a, and there's no reason that should be invalid when a = b -> c
14:33:38 <kmc> @src foldl'
14:33:39 <lambdabot> foldl' f a []     = a
14:33:39 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
14:33:41 <Kim^Walkman> LordDoskias: (do note the function is recursive if you change its' name)
14:33:52 <BONUS> sohum: yup
14:34:09 <BONUS> > id (+) 3 2
14:34:10 <lambdabot>   5
14:34:28 <Kim^Walkman> LordDoskias: … oh, doh. I forgot a case in the pattern matching ;)
14:35:11 <LordDoskias> [1,2,3,4,5,6,7,8,9,10*** Exception: Worksheet1.hs:(161,0)-(162,40): Non-exhaustive patterns in function beginning
14:35:55 <sohum> :t ap
14:35:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:35:57 <Kim^Walkman> LordDoskias: It would be a good exercise to figure out why it blows up
14:36:02 <sohum> :t ap (+3)
14:36:03 <lambdabot> forall a b. (Num (a -> b)) => ((a -> b) -> a) -> (a -> b) -> b
14:36:07 <LordDoskias> looking at it now
14:36:15 <BONUS> another cool trick with that -- ziplists with id!
14:36:25 <Kim^Walkman> LordDoskias: http://pastebin.com/d393d48da — if you want to cheat a bit
14:36:49 <sshc> if I have a UR uery string, such as "foo=3&bar=quux", how do I change the string into a map (Map String String)?
14:36:54 <sohum> :t ($) (+3)
14:36:55 <lambdabot> forall a. (Num a) => a -> a
14:37:01 <sohum> > ($) (+3) 4
14:37:02 <lambdabot>   7
14:37:06 <sshc> is there a standard function I can use to do this, or do I need to write it manually?
14:37:10 <LordDoskias> beginning [x] = [] ! = beginning (x:[]) ?
14:37:10 <BONUS> > let (+) = zipWith id in map (*) + [1,2,3] + [1,2,3]
14:37:12 <lambdabot>   Couldn't match expected type `[b1 -> b -> c]'
14:37:12 <lambdabot>         against inferred type...
14:37:12 <LordDoskias> is that right
14:37:15 <BONUS> ugh
14:37:32 <LordDoskias> Kim^Walkman: i already added the empty list case
14:37:36 <sohum> > zipWith ($) [(+3),(+2),(*4)] [4,3,2]
14:37:37 <lambdabot>   [7,5,8]
14:37:53 <BONUS> > let (+) = zipWith id in map (*) [1,2,3] + [1,2,3]
14:37:54 <lambdabot>   [1,4,9]
14:37:58 <sohum> > zipWith (.) [(+3),(+2),(*4)] [4,3,2]
14:37:59 <lambdabot>   No instance for (GHC.Num.Num (f a))
14:37:59 <lambdabot>    arising from the literal `4' at <int...
14:38:02 * sohum nod
14:38:06 <Kim^Walkman> LordDoskias: (x:[]) and [x] matches a list with ONE element
14:38:15 <sohum> > zipWith (.) [4,3,2] [(+3),(+2),(*4)]
14:38:16 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
14:38:16 <lambdabot>    arising from the literal `4' at <...
14:38:21 <sohum> oh, right, doy
14:38:24 <LordDoskias> yeah but thats not the problem
14:38:28 <LordDoskias> it return every element
14:38:52 <LordDoskias> even the last one
14:39:10 <Sadache> BONUS: and does it only works with id? I guess other than Id would be too complex to predict, right?
14:39:18 <EvanCarroll> is he oreilly book the best book for learning haskell?
14:39:20 <Kim^Walkman> LordDoskias: Peculiar; “ghci> init' [1..11]
14:39:20 <Kim^Walkman> [1,2,3,4,5,6,7,8,9,10]”
14:39:32 <tensorpudding> so is id and ($) equivalent then?
14:39:38 <mauke> tensorpudding: yes
14:39:48 <mauke> tensorpudding: ($) is a specialization of id
14:39:52 <LordDoskias> try it with 1..10
14:39:54 <tensorpudding> that really breaks my brain, but the type signatures don't lie
14:39:55 <dons> sjanssen: re. judy, yep. experiment. don't use it.
14:40:03 <BONUS> it's a property of id yeah
14:40:11 <BONUS> there's also some cool stuff you can do with const
14:40:13 <mauke> tensorpudding: ($) :: (a -> b) -> a -> b; ($) = id
14:40:24 <tensorpudding> @src ($)
14:40:25 <lambdabot> f $ x = f x
14:40:27 <BONUS> :t (const id, flip const)
14:40:28 <lambdabot> forall a b a1 b1. (b -> a -> a, b1 -> a1 -> a1)
14:40:29 <LordDoskias> or 1002
14:40:33 <LordDoskias> or 102
14:40:38 <tensorpudding> ah, pointy
14:40:51 <tensorpudding> @pl f $ x
14:40:52 <lambdabot> f x
14:41:15 <tensorpudding> err that's not what i want
14:41:22 <mauke> > let foo [] = []; foo [x] = []; foo (x : xs) = x : foo xs in foo [1 .. 10]
14:41:24 <lambdabot>   [1,2,3,4,5,6,7,8,9]
14:42:09 <Kim^Walkman> LordDoskias: Oh, I see what you mean
14:42:42 <Sadache> BONUS: and does this trick have a name?
14:42:44 <kmc> EvanCarroll, which one? RWH?
14:42:44 <sohum> tensorpudding: well, typewise ($) is a specialisation of id. the reason it's used differently is because it'd defined to have a much lower precedence
14:43:18 <BONUS> hmm, not that i'd now of
14:43:20 <Sadache> BONUS: do you have a twitter or a website that I link to you if I blog about this?
14:43:25 <Kim^Walkman> LordDoskias: You need to add another pattern match for when the list only has two items in it; the almost last one and the last one
14:43:51 <BONUS> Sadache: uh yeah i have both :D i mean you don't have to link or anything. but if you want it's learnyouahaskell.com
14:44:07 <BONUS> there's no attribution required for knowledge haha
14:44:10 <sohum> @info ($)
14:44:11 <lambdabot> ($)
14:44:11 <Kim^Walkman> LordDoskias: But it's becoming silly; so:
14:44:15 <sohum> blergh
14:44:15 <LordDoskias> Kim^Walkman: this was my initial idea
14:44:28 <sohum> where's the thingy that'll show you precedences
14:44:41 <LordDoskias> get 2 itesm each time and check whether the second one i an empty list, which means the penultimate iteam is the last and hsould not be added to the final list
14:44:52 <EvanCarroll> kmc: yea
14:44:55 <Kim^Walkman> LordDoskias: http://pastebin.com/d1ed60537
14:44:58 <Sadache> BONUS: and your twitter id?
14:45:04 <BONUS> bonus500
14:45:06 <BONUS> :)
14:45:12 <kmc> i don't know if there's a definitive "best book" but a lot of people like RWH
14:45:33 <coprogrammer> the best book is the one I haven't started writing yet
14:45:46 <BONUS> RWH is awesome
14:46:04 <LordDoskias> it's working now, thansk
14:46:17 <tensorpudding> RWH is awesome, so is LYAH
14:46:24 <BONUS> :)
14:46:32 <Kim^Walkman> LordDoskias: Sorry about the misdirection, happens when you code at midnight some times
14:46:44 <BONUS> cool thing about id is that it really showcases, like, ultimate polymorphism
14:47:22 <kmeyer> Hi, I'm curious as to how I can go about reading bytes from a file
14:47:23 <LordDoskias> Kim^Walkman: it's understanable
14:47:52 <Kim^Walkman> kmeyer: Look at the ByteString package
14:47:55 <sohum> yea, ($) has precedence 0
14:47:55 <Twey> kmeyer: ByteStrings are probably the best way
14:47:59 <BONUS> the a's in a -> a can really be ANYTHING, and the type system is smart enough so it can figure out how to adapt that to be as general as possible
14:48:03 <BONUS> like
14:48:05 <BONUS> :t flip id
14:48:07 <lambdabot> forall b c. b -> (b -> c) -> c
14:48:12 <kmeyer> thanks Twey, Kim^Walkman
14:48:20 <sinelaw> conal, if you're here: thinking about what you said, i come from an electrical engineering background and they have precise math. definitions and a theory (Control Theory) to deal exactly with time-varying values, albeit it's limited to numbers or vectors
14:48:37 <sohum> ($), ($!), and `seq` apparently all hae precedence 0
14:48:46 <sinelaw> conal, i mean to deal with systems that react to temporal input
14:48:58 <sohum> :t (.)
14:49:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:49:33 <BONUS> because flip is (a -> b -> c) -> b -> a -> c, it sees that if it wants to flip the id function, id has to be at least (a -> b) -> a -> b
14:49:41 <BONUS> because in that form it "takes two parameters"
14:50:00 <sohum> :t (.) (+)
14:50:01 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f (a -> a)
14:50:28 <sohum> :t (.) id
14:50:29 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
14:51:18 <sohum> > head $ [1..]
14:51:19 <lambdabot>   1
14:51:22 <sohum> > head $! [1..]
14:51:24 <lambdabot>   1
14:51:32 <sohum> ...huh?
14:51:36 <sinelaw> conal, PeakerWork so "FTP" is in a way, thinking of systems in a way that's an extension of control theory to arbitrary value types rather than just numbers and vectors
14:51:40 <Twey> sohum: $! is strict
14:51:46 <Twey> @src ($!)
14:51:47 <lambdabot> f $! x = x `seq` f x
14:52:08 <Twey> f $! x means evaluate x first, then apply f to it
14:52:09 <sohum> Twey: right, so I'd expect it to strictly evaluate [1..] and throw me a mueval error
14:52:16 <Twey> Only WHNF
14:52:24 <sohum> aaah
14:52:33 <sohum> danke
14:52:38 <Twey> Bitte schön
14:53:16 <Sadache> BONUS: I like this trick! It generates no entropy :)
14:54:18 <BONUS> hmm, no entropy? in what sense
14:54:21 <tommd> @seen dons
14:54:22 <lambdabot> Unknown command, try @list
14:54:29 <tommd> preflex: seen dons
14:54:29 <Sadache> if everyone uses this kind of reasonig we won't have any ecology problem...
14:54:29 <preflex>  dons was last seen on #xmonad 11 minutes and 2 seconds ago, saying: p2p archive?
14:55:33 <conal> sinelaw: nice.  i like that perspective.
14:55:59 <sinelaw> conal, but is it really more than that?
14:56:01 <conal> sinelaw: i'll check out control theory.  have heard of it but never studied.
14:56:09 <conal> sinelaw: don't know
14:56:20 <tommd> Prelude Data.Array.Vector> let b = sliceU a 2 4
14:56:20 <tommd> Prelude Data.Array.Vector> a
14:56:20 <tommd> toU [1,2,3,4,5,6]
14:56:20 <tommd> Prelude Data.Array.Vector> b
14:56:20 <tommd> toU [3,4,5,6]
14:56:21 <tommd> dons: see above.  Should 'uvector' do this?  'lengthU $ sliceU arr min max' should equal 'max - min' and this is a bug, right?
14:56:41 <coprogrammer> lol, gotta love people saying "I understand that I'm in a grocery store, but can anyone tell me where I can find books on zygohistomorphic prepromorphisms"
14:56:54 <Twey> Hahaha
14:56:56 <BONUS> lol
14:58:14 <Twey> Heh, apparently Kmett developed the ‘zygohistomorphic prepromorphism’ page
14:58:20 <sinelaw> conal, ok. the stuff i've studied is basically linear control theory, which deals with time-dependent functions passing through linear systems which are represented as functions in the Laplace plane (frequency-domain functions), and includes treatment of stability, feedback, tracking, etc...
14:58:24 <BONUS> edwardk owns
14:58:42 <BMeph> tommd: Looking at that example, I'd guess that 'lengthU $ sliceU arr min max' would give you 'max'... :)
14:58:54 <Twey> « One might argue that for consistency the name should be a
14:58:56 <Twey> zygohistoprepromorphism, but that starts to become unwieldy. »
14:59:00 <Twey> Hahaha.
14:59:27 <coprogrammer> in case anyone missed, I'm referring to a recent email in haskell-cafe :)
14:59:37 <tensorpudding> at that point you start using acronyms
14:59:41 <Twey> Got a nice convenient link?
14:59:45 <conal> sinelaw: sounds like neat stuff.
14:59:54 <Twey> tensorpudding: ZHPPMs :þ
15:00:01 <BONUS> one of these days i really gotta learn what these zygohistomorphic prepromorphisms that i mention so much actually are
15:00:17 <Twey> BONUS: http://www.opensubscriber.com/message/haskell-cafe@haskell.org/13009107.html
15:00:27 <kmeyer> hrm
15:00:33 <nolrai_FG> :t putStrLn
15:00:34 <lambdabot> String -> IO ()
15:00:42 <tommd> BMeph: Doh!! You are right - I completely misinterpreted the args.  Thanks
15:00:43 <sinelaw> i'll need to think about how that can (or should) be extended to other types.
15:00:44 <kmeyer> maybe I'm just dumb today, but how do I get ghc to find ByteString? ghc-pkg list shows bytestring installed
15:01:09 <tommd> dons: Summarizing the above: at the least the docs for uvector should be clearer, perhaps I'll send a patch your way.
15:01:35 <mauke> kmeyer: what's the error message?
15:01:42 <sinelaw> kmeyer, import Data.ByteString?
15:02:06 <kmeyer> sinelaw: ahhhh
15:02:06 <Twey> Haha, ad on the opensubscriber page: ‘C++ Homework?  Impossible.  Pointers suck.  We know.  We can help.  Post a question, get answers fast!’
15:02:11 <coprogrammer> Twey: http://www.haskell.org/pipermail/haskell-cafe/2009-November/068858.html
15:02:24 <Twey> coprogrammer: Argh.
15:02:27 <kmeyer> mauke: Could not find module `ByteString'
15:02:35 <Twey> coprogrammer: Undertsand** :þ
15:02:44 <coprogrammer> lol
15:02:49 <mauke> kmeyer: it's Data.ByteString
15:02:58 <Twey> Heh, sent from a HoTMaiL address
15:03:04 <kmeyer> yeah, I didn't know
15:03:19 <BONUS> haha
15:03:22 <sinelaw> kmeyer, when in that kind of trouble, i lookup the package in Hackage - it shows you which modules it makes available
15:03:29 <BONUS> edward is my idol
15:03:40 <coprogrammer> only the really cool people have hotmail addresses
15:03:42 <kmeyer> sinelaw: I was actually looking at the hackage page, just didn't notice Data
15:03:45 <sinelaw> kmeyer, also, cabal info bytestring would show you that
15:03:53 <kmeyer> thanks
15:04:00 <sinelaw> cabal says "Modules: Data.ByteString ...."
15:04:18 <sinelaw> my pleasure, first time i've ever helped anyone with haskell :)
15:04:30 <kmeyer> heh
15:04:31 <sinelaw> sinelaw++
15:04:44 <kmeyer> indeed
15:04:44 <mauke> preflex: karma sinelaw
15:04:44 <preflex>  sinelaw: 1
15:04:54 <sohum> karma?
15:05:05 <sinelaw> self-inflicted karma, is that legal?
15:05:06 <sohum> cool
15:05:11 <kmc> level up!
15:05:13 <sohum> preflex: karma sohum
15:05:14 <preflex>  sohum has no karma
15:05:16 <sohum> sohum++
15:05:19 <sohum> preflex: karma sohum
15:05:19 <preflex>  sohum: 1
15:05:21 <sinelaw> heh
15:05:24 <sohum> apparently so
15:05:27 <mauke> not quite
15:05:31 <sinelaw> sohum+=5
15:05:35 <kmc> preflex: karma c
15:05:36 <preflex>  c: 46795
15:05:41 <sohum> ahhahaha
15:05:43 <sinelaw> hahaha
15:06:03 <sinelaw> that tells you precisely how many times c++ was mentioned (one-up again!)
15:06:21 <sohum> surprisingly high, actually.
15:06:27 <kmc> preflex: karma c
15:06:27 <preflex>  c: 46796
15:06:44 <mauke> getting your karma over 10 by ++'ing yourself might be harder than you think :-)
15:06:45 <kmc> c--
15:06:46 <kmc> preflex: karma c
15:06:47 <preflex>  c: 46795
15:06:55 <sinelaw> oh
15:06:55 <sohum> oh, right
15:07:08 <sohum> so it's the number of times c++ was mentioned /over/ c--
15:07:11 <kmc> > text "kmc++"
15:07:12 <lambdabot>   kmc++
15:07:14 <sinelaw> sohum, yes :)
15:07:20 <kmc> preflex: karma kmc
15:07:21 <preflex>  kmc: 1
15:07:22 <sohum> then it's /really/ high
15:07:28 <sohum> sohum--
15:07:29 <sohum> sohum--
15:07:35 <sinelaw> > repeat . text $ "kmc++"
15:07:36 <sohum> preflex: karma sohum
15:07:36 <preflex>  sohum: 3
15:07:37 <lambdabot>   [kmc++,kmc++,kmc++,kmc++,kmc++,kmc++,kmc++,kmc++,kmc++,kmc++,kmc++,kmc++,km...
15:07:41 <sohum> ...what
15:07:42 <kmc> preflex: karma c
15:07:43 <preflex>  c: 46795
15:07:44 <BONUS> it's interesting because c-- is actually more relevant to Haskell, seeing how it's used in GHC (isn't it?)
15:07:44 <kmc> preflex: karma kmc
15:07:44 <preflex>  kmc: 1
15:07:46 <kmc> damn
15:07:50 <sinelaw> didn't work
15:07:56 <sinelaw> > repeat . text $ "kmc++ "
15:07:58 <lambdabot>   [kmc++ ,kmc++ ,kmc++ ,kmc++ ,kmc++ ,kmc++ ,kmc++ ,kmc++ ,kmc++ ,kmc++ ,kmc+...
15:07:59 <sinelaw> > repeat . text $ " kmc++ "
15:08:01 <sohum> I'd have it ignore lambdabot, yeah
15:08:01 <lambdabot>   [ kmc++ , kmc++ , kmc++ , kmc++ , kmc++ , kmc++ , kmc++ , kmc++ , kmc++ , k...
15:08:09 <kmc> BONUS, unfortunately i spend more time complaining about my job than i do talking about GHC's backend
15:08:10 <sohum> preflex: karma sohum
15:08:10 <preflex>  sohum: 3
15:08:11 <mauke> sohum: if you try to karma yourself, it actually uses a RNG
15:08:14 <skorpan> this discussion is very relevant to my interests.
15:08:16 <Twey> > text "foo\nbar"
15:08:18 <sohum> mauke: aaaah
15:08:18 <lambdabot>   foo
15:08:18 <lambdabot>  bar
15:08:19 <sinelaw> preflex: karma kmc
15:08:20 <preflex>  kmc: 11
15:08:21 <sjanssen> new Haskell goal: for every "ask proggit", we post the solution in Haskell source code before any other language: http://www.reddit.com/r/programming/comments/a25h2/ask_proggit_how_to_find_the_minimal_chain_of/c0fikib :)
15:08:21 <sinelaw> hah
15:08:25 <sohum> mauke: right, that makes sense
15:08:26 <sinelaw> there you go
15:08:35 <mauke> kmc-- kmc-- kmc-- kmc-- kmc-- kmc-- kmc-- kmc-- kmc-- kmc-- kmc--
15:08:35 <BONUS> kmc: hahaha
15:08:58 <sohum> it /doesn't/ ignore lambdabot?
15:08:59 <lhoersten> I'm trying to use ByteString.split which the docs say should be able to take a char as a word8: http://bit.ly/4CddWF ... unfortunately it's being rejected because it's a Char type. how can I use split then?
15:09:00 <Twey> text . unlines $ repeat "kmc++"
15:09:02 <sohum> preflex: karma kmc
15:09:03 <preflex>  kmc has no karma
15:09:03 <Twey> … I guess
15:09:06 <sohum> kmc--
15:09:07 <kmc> frex yesterday i was complaining after discovering that C++ has a "design pattern" for "filter" and it's about 20 lines of code
15:09:08 <sohum> preflex: karma kmc
15:09:08 <preflex>  kmc: -1
15:09:08 <Twey> Heh
15:09:13 <kmc> ugh
15:09:14 <sohum> so it does go negative
15:09:17 <sohum> thanks, kmc
15:09:19 <sohum> kmc++
15:09:20 <sohum> kmc++
15:09:21 <pcc1> I am receiving the following error from "ghc --make": "module `main:M' is defined in multiple files: M.hs-boot M.hs" well of course it is!
15:09:30 <sinelaw> preflex, karma make
15:09:30 <preflex>  make: 1
15:09:34 <sjanssen> lhoersten: the docs are bad, use Data.ByteString.Char8 instead
15:09:37 <kmc> thanks, sohum
15:09:38 <kmc> thohum
15:09:56 <mauke> preflex: karmatop
15:10:01 <preflex>  c: 46795; g: 2602; ##c: 2230; c/c: 1161; vc: 981; bacek: 947; #c: 785; notepad: 759; pmichaud: 755; coke: 700
15:10:10 <kmc> preflex: karma police
15:10:10 <preflex>  police: -9
15:10:10 <sohum> hahaha, ##c++
15:10:24 <sohum> and c/c++
15:10:26 <sohum> hahaha
15:10:30 <lhoersten> sjanssen: ah thanks
15:10:44 <kmc> sohum, discussion of ##c++ is not STRICT ISO C++ and will NOT BE TOLERATED!
15:10:51 <kmc> :)
15:10:54 <Vanadium> ##iso-c+=
15:10:54 * sohum snerk
15:10:56 <Vanadium> +, even
15:11:01 <BMeph> preflex: karma chameleon
15:11:01 <preflex>  chameleon has no karma
15:11:09 <sohum> boooo
15:11:11 <benmachine> chameleon++
15:11:13 <sohum> chameloon++
15:11:14 <kmc> they actually have a bot just to snark people for that
15:11:18 <sohum> ..if I can spell
15:11:19 <kmc> it's really annoying
15:11:25 <sohum> chameleon++
15:11:30 <sohum> chameloon--
15:11:37 <mauke> !fun
15:11:43 <dcolish> Twey: have you worked ithe HsLua libs recently? the wiki is outdated and i'm having issues
15:11:43 <shambler> :S
15:11:51 <Vanadium> Come on, they kind of have a point when there are a bunch of people in ##c++ who are really good at iso c++ and then a jerk joins and asks questions about some obscure library and gets all indignant when no one can help him :<
15:11:53 <BMeph> I'd say "It comes and goes," but I think that's just too much fun... ;p
15:12:15 <kmc> people here ask questions that aren't about Haskell 98 all the time
15:12:17 <sohum> > launchTheMissiles
15:12:18 <lambdabot>   Not in scope: `launchTheMissiles'
15:12:21 <sohum> > launchZeMissiles
15:12:23 <lambdabot>   Not in scope: `launchZeMissiles'
15:12:34 <shambler> there is no such thing as "too much fun"
15:12:47 <sohum> > launchZeMissiles
15:12:48 <lambdabot>   <IO ()>
15:12:51 <sohum> hehehe
15:12:53 <Vanadium> kmc: Yeah, but the C++ ecosystem is arguably a bit more diverse
15:12:59 <sohum> scary looking IO action.
15:13:01 <sohum> check!
15:13:02 <kmc> and it's not about people getting indignant, they refuse to even consider a question
15:13:11 <sinelaw> Vanadium, last time I tried #c++ they were pretty rude
15:13:14 <kmc> even if the channel is otherwise dead and someone can help
15:13:19 <Sadache> this code is in F# but is very similar to haskell code and uses its idioms. Does anyone suggest any improvement for cleaning it up? http://snipt.org/pgoo
15:13:22 <kmc> i mean saying "we don't know" is okay
15:13:27 <sohum> last time I tried #c they were very rude
15:13:42 <mauke> ##c++ is actually a pretty fun channel
15:13:47 <Vanadium> I have not been there in a while, but I did not think it was that bad
15:13:49 <sohum> rather, I shouldn't say "they"
15:13:53 <sinelaw> #math in it's bad days topped them all
15:13:57 <sinelaw> *its
15:13:59 <sohum> there's this one guy who kinda soured me
15:14:06 <mauke> Zhivago!
15:14:10 <sinelaw> but that was a long time ago, when i was trying #math
15:14:47 <Vanadium> I went to ##c once and was laughed out of the channel for asking a question in such a way that it implies the presence of a stack :<
15:14:58 <BMeph> sinelaw: Was it 'antonfire'? :)
15:15:10 <mauke> Vanadium: yeah, C has no stack
15:15:22 <shambler> the cake is a lie
15:15:31 <Vanadium> It was you, wasn't it
15:15:49 <mauke> maybe, but probably not
15:16:37 <sinelaw> BMeph, don't remember, but it was like, upper-case of "if you can't define everything you use properly down to ZF Set theory then your question is completely stupid and ignorant, and you are a moron, so go away and now /ignore"
15:17:00 <nolrai_FG> :t fromMaybe
15:17:02 <lambdabot> forall a. a -> Maybe a -> a
15:17:08 <lhoersten> sjanssen: still cant seem to get it working
15:17:18 <BMeph> sinelaw: That sounds like him. :\
15:17:22 <lhoersten> sjanssen: says the char8 constructor isn't in scope
15:17:34 <mauke> the what?
15:17:57 <sjanssen> lhoersten: import Data.ByteString.Char8 is the only change you should have made
15:18:13 <Sadache> actually it is for defining a safe version of splitAt in f# using lift functions and ap
15:18:22 <lhoersten> sjanssen: yeah that didn't work
15:18:57 <lhoersten> sjanssen: is the constructor visible?
15:19:07 <mauke> what constructor?
15:19:11 <lhoersten> they may not have exported it right
15:19:17 <lhoersten> mauke: the Char8 constructor
15:19:19 <reltuk>  is there a way for a module to use functions from another modules which wreen't exported?
15:19:23 <mauke> lhoersten: what is Char8?
15:19:27 <reltuk> I'm thinking of testing in particular...
15:19:30 <lhoersten> Data.ByteString.Char8
15:19:34 <mauke> lhoersten: yes?
15:19:38 <mauke> that's a module, not a type
15:19:44 <lhoersten> ah
15:20:03 <lhoersten> all I want to do is use Data.ByteString.split
15:20:04 <binrapt> Leaking memory in Haskell is usually a non-issue in comparison to programming in C or C++, right? The only ways in which you could achieve it is by misusing a foreign language interface or using a foreign language interface which uses a broken/leaking implementation or by somehow engaging in an ever increasing level of recursion - right?
15:20:10 <lhoersten> and I cant figure out how
15:20:17 <mauke> lhoersten: use Data.ByteString.Char8.split
15:20:40 <reltuk> binrapt: is that a joke?  :-p
15:20:48 <binrapt> reltuk nope
15:20:59 <mauke> binrapt: memory leaks, yes; but we have something called space leaks
15:21:01 <lhoersten> mauke: what is Data.ByteString.split for then? the examples seem pretty clear though they don't actually work
15:21:12 <sinelaw> binrapt, haskell has different problems
15:21:19 <mauke> lhoersten: Data.ByteString.split works on Word8, not Char
15:21:34 <sjanssen> lhoersten: Data.ByteString does everything in terms of bytes, Data.ByteString.Char8 does everything in terms of characters
15:21:40 <reltuk> a space leak might as well be a memory leak...
15:21:42 <lhoersten> mauke: look at the docs though... they show it takin characters
15:21:46 <sinelaw> binrapt, you can't accidentally forget to free something that you've stopped referencing, but you can accidentally forget to stop referencing something
15:22:12 <sinelaw> anyone correct me if i'm wrong :)
15:22:14 <kmc> and you can forget to turn big unevaluated thunks into small values early on
15:22:20 <lhoersten> sjanssen: anyway I think I still want to do it in terms of bytes. Should I have to use a constructor for Word8 then? (Word8 '1') or something?
15:22:23 <binrapt> mauke hmm what’s a space leak?
15:22:28 <binrapt> Should I google that?
15:22:32 <kmc> reltuk, i don't agree, because the solutions are very different
15:22:38 <kmc> but yes they're both serious
15:22:44 <mauke> <sjanssen> lhoersten: the docs are bad, use Data.ByteString.Char8 instead
15:22:45 <sinelaw> binrapt, if you're interested in Haskell you might as well start learning it
15:22:50 <sinelaw> @where rwh
15:22:51 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:22:53 <sinelaw> @where yaht
15:22:55 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
15:23:03 <sinelaw> binrapt, you can try one of those links
15:23:07 <tensorpudding> @where lyah
15:23:07 <lambdabot> www.learnyouahaskell.com
15:23:08 <sinelaw> (esp. the first)
15:23:10 <lhoersten> mauke: that's if I want to use a char... I actually just want to pass a Word8
15:23:19 <mauke> lhoersten: no, you don't
15:23:22 <mauke> lhoersten: '1' is a Char
15:23:30 <lhoersten> ah good point. the '' make it a char then?
15:23:33 <mauke> yes
15:23:34 <sinelaw> yeah, ignore yaht, it's not as good as the others
15:23:41 <lhoersten> if I pass a number it will make it a Word8?
15:23:42 <mauke> a Word8 would look like 49
15:23:45 <mauke> yes
15:23:47 <lhoersten> awesome
15:23:47 <lhoersten> thanks
15:23:57 <mauke> well, you could write (fromIntegral (ord '1'))
15:24:01 <lhoersten> right
15:24:10 <lhoersten> i dont want the char 1, i actually want 01
15:24:13 <lhoersten> the value
15:24:20 <mauke> ok, then just use 1 :-)
15:24:24 <binrapt> Is it common for newbies to leak memory in Haskell? I thought it was not really possible in predominantly functional programming languages
15:24:27 <Vanadium> '\x01' :]
15:24:33 <mauke> Vanadium: '\1'
15:24:39 <mauke> but that's a Char again
15:24:43 <Vanadium> octal numbers are the devil's
15:24:44 <kmc> binrapt, "functional" and "garbage collected" are totally different concepts
15:24:52 <mauke> Vanadium: that's not octal
15:24:53 <kmc> and again, you won't leak memory in  the sense of never freeing
15:25:11 <kmc> but you may create very large unevaluated thunks when you'd rather have the result earlier and use less memory
15:25:13 <Vanadium> Oh. :<
15:25:29 <Vanadium> Not reading the documentation is the devil's :<
15:25:54 <kmc> > let x :: Int; x = read $ return '1' in x
15:25:55 <lambdabot>   1
15:26:00 <lhoersten> Vanadium: what is '\x01'?
15:26:05 <lhoersten> making an unprintable character?
15:26:07 <mauke> > '\x01'
15:26:09 <lambdabot>   '\SOH'
15:26:12 <mauke> yes
15:26:15 <lhoersten> ah
15:26:19 <Vanadium> > '\x01' == '\1'
15:26:20 <mauke> it's (chr 0x01)
15:26:20 <lambdabot>   True
15:26:29 <lhoersten> > '\01'
15:26:30 <lambdabot>   '\SOH'
15:26:33 <lhoersten> ah ok thanks
15:26:36 <kmc> > '\x08'
15:26:37 <lambdabot>   '\b'
15:26:58 <nolrai_FG> Can I use mapM to write "goTo ((a, b):xs) c = goTo xs =<< lookIn a b c"? or maybe foldM?
15:27:04 <Vanadium> > '\u0539'
15:27:05 <lambdabot>   <no location info>:
15:27:06 <lambdabot>      lexical error in string/character literal at chara...
15:27:09 <Vanadium> aw.
15:27:21 <mauke> > '\x539'
15:27:23 <lambdabot>   '\1337'
15:27:29 <skorpan> nolrai_FG: looks more like a fold
15:27:45 <lhoersten> haha thanks for all your help
15:27:55 <lhoersten> the docs were really throwing me off...
15:28:15 <nolrai_FG> :t foldM
15:28:16 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
15:28:41 <skorpan> @pl \((a, b):xs) c -> goTo xs =<< lookIn a b c
15:28:42 <lambdabot> ap (uncurry ((flip ((.) . (=<<) . goTo) .) . lookIn) . head) tail
15:28:43 <Vanadium> Today I wrote iterate f a !! n, and then I got a stackoverflow and had to write it out and make it strict. Is there a more concise way to do that?
15:29:43 <MacCoaster> what's a good way to replace an element in a list? like if i already have a list [1,2,3,4,5] and i want to create a new list replacing 4 with 10?
15:30:10 <mathijs> Hi all, is there a reason why the 'Sum a' Monoid doesn't enforce a to be Num?
15:30:18 <BMeph> Vanadium: 'head . drop n . iterate f $ a', perhaps? :)
15:31:02 <BMeph> MacCoaster: Looks like you'd rather use an array than a list. :)
15:31:20 <MacCoaster> BMeph: yeah, but no choice :\
15:31:49 <tensorpudding> there's probably a function in Data.List that could do something like that
15:31:59 <MacCoaster> i only can think of splitAt then somehow get the "cdr" of the 2nd part, BMeph
15:32:07 <RayNbow> http://lambda.bugyo.tk/cdr/mwl13/mwl13.html <-- hmm, a manga about Lisp... there isn't a manga about Haskell yet, is there?
15:32:09 <BMeph> MacCoaster: Why's that? Instructions not to use Arrays, on enalty of death (or no credit)? :)
15:32:28 <MacCoaster> BMeph: hehe design of the program, already operates on list
15:32:41 <Vanadium> BMeph: Great, that seems to work but I have no idea why.
15:33:35 <BMeph> MacCoaster: That's the beauty of modularity; you can swap into a different structure, do the easier processing there, and swap back once the process is done. :)
15:34:49 <reltuk> is there a better way to shuffle a list in haskell than random-shuffle on hackage?
15:35:05 <Twey> Isn't random-shuffle Oleg's one?
15:35:09 <Twey> I doubt it…
15:35:11 <BMeph> Vanadium: Because 'drop n list' tells the machine not to keep track of that part of the list, thus it can work in constant space. -- cribbed from prior #haskell conversations; may need various 'modulo' declarations to be valid. ;)
15:35:29 <EvanCarroll> how do you use guards in ghci let x a = a = 1 | a < 5 = "wtf"
15:35:50 <BMeph> reltuk: Depends on what you mean by 'better', though. :)
15:36:20 <mauke> EvanCarroll: how do you use guards in non-ghci?
15:36:29 <EvanCarroll> http://learnyouahaskell.com/syntax-in-functions
15:36:32 <EvanCarroll> like that.
15:36:42 <BMeph> EvanCarroll: Sorry for trolling, but...was there a question there? ;)
15:36:58 <EvanCarroll> BMeph: yes, reread it.
15:37:01 <mauke> EvanCarroll: yeah, I don't see how your x fits that pattern
15:37:15 <EvanCarroll> do guards attach to functions or invocations?
15:37:24 <mauke> what's an invocation?
15:37:27 <Vanadium> BMeph: But why does it hold on to the list if I use (!!)?
15:37:43 <Twey> let x a | x < 5 = "wtf" | otherwise = "1"
15:37:45 <reltuk> twey well, shuffle :: [a] -> Int -> gen   doesn't return the new generator
15:37:56 <EvanCarroll> mauke: stop answering my questions, i find your input especially useless in all cases of you providing assistance.
15:38:03 <mauke> lol k
15:38:21 <reltuk> and it's using 30% of my programs runtime =/
15:39:10 <c_wraith> it is astounding that it doesn't return the new generator.
15:39:24 <c_wraith> But...  30% of your program's time?  How big of lists are you using?
15:39:25 <kmc> oh snap
15:39:27 <Twey> Hm
15:40:25 <reltuk> between 10 and 30 elems?
15:40:42 <kmc> > let x a | (a < 5) = 1 in x 2
15:40:44 <lambdabot>   1
15:40:47 <kmc> > let x a | (a < 5) = 1 in x 8
15:40:48 <lambdabot>   * Exception: <interactive>:1:149-165: Non-exhaustive patterns in function x
15:41:03 <reltuk> it's also a pretty big allocator, despite the fact that I replace a lot elems in the middle of lists elsewhere in the program, etc.
15:42:22 <c_wraith> well..  what Gen are you using?
15:42:52 <kmc> EvanCarroll, i don't know what you mean by "invocation"
15:43:03 <BMeph> Vanadium: Why wouldn't it? 'list !! n' says, "Take this list, go through it to element 'n', and give me that one." You can't go through a list without having a list to go through, so it has to hold on to it. 'drop n list' says, "Take this list, and throw away the first 'n' elements, and give me the rest of the list." You specifically tell the computer not to keep that part of the list around. It's a Lazy thing, you understand. ;)
15:43:14 <kmc> guards attach to the "outer-level pattern" (sorry, don't know the correct term) in a function equation or a case arm
15:43:55 <BMeph> EvanCarroll: When you say, "invocation," do you mean a function call, or a function declaration? Most folks I know associate invocation with running a program. :)
15:43:57 <Vanadium> BMeph: It thought it said "take this list, then throw the first element away, then repeat this n-1 times, then give me the first element"
15:44:18 <orbisvicis> is there a tool to do something like "map (<- function) list" in a do block ?
15:44:20 <idnar> BMeph: I don't understand why list !! n would hold onto more data than drop n list
15:44:29 <kmc> orbisvicis, mapM?
15:44:37 <jlouis> :t mapM
15:44:39 <idnar> you're extracting a single element from the list, throwing the rest away
15:44:39 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:45:09 <jlouis> orbisvicis: you might be interested in its cousin,
15:45:12 <jlouis> :t mapM_
15:45:14 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
15:45:19 <reltuk> c_wraith System.Random.StdGen
15:45:19 <kmc> i think it's easy enough to ignore people who aren't helping, and you might learn something anyway
15:45:39 <reltuk> it might be the generator...I need more data :-)
15:45:54 <idnar> or to put it another way, I would expect "list !! n" to be equivalent to "head . drop n $ list"
15:46:11 <kmc> > mapM (liftM succ) [Just 1, Just 2, Just 3]
15:46:12 <lambdabot>   Just [2,3,4]
15:46:12 <EvanCarroll> BMeph: I thought it was obvious, but aparently not, I was aiming for "function call"
15:46:40 <idnar> @src (!!)
15:46:41 <lambdabot> xs     !! n | n < 0 = undefined
15:46:41 <lambdabot> []     !! _         = undefined
15:46:41 <lambdabot> (x:_)  !! 0         = x
15:46:41 <lambdabot> (_:xs) !! n         = xs !! (n-1)
15:46:43 <EvanCarroll> it seems as if they are attached to the definitions
15:47:30 <orbisvicis> jlouis: kmc: thanks that would work
15:48:19 <EvanCarroll> BMeph: it actually has it in the tutorial inline guards
15:48:20 <EvanCarroll> # max' a b | a > b = a | otherwise = b
15:48:26 <EvanCarroll> muahah, nice
15:49:10 <kmc> personally i think that syntax isn't so readable, and would put each guard on its own line
15:49:45 <EvanCarroll> I'm not sure if I like guards
15:50:00 <Twey> Most definitely
15:50:19 <Twey> Guard syntax was definitely meant to be multi-line.
15:50:21 <EvanCarroll> it is kind of a neat idea, I'd liken them more towards teranary operaters, where ? also functions as if-else
15:50:31 <mwc> Every few weeks I take my PC outside to clean it out with the air compressor. I vacumn pretty often, so my only conclusion is that this dust is ground up lambdas
15:50:39 <mwc> should I worry about lubricating GHC?
15:50:55 <EvanCarroll> (for the purpose of teaching them in a tutorial)
15:50:57 <Twey> Hahaha
15:51:22 <jlouis> mwc: only if you use floating point numbers a lot
15:51:24 <kmc> EvanCarroll, haskell's if .. then .. else is like C's ternary operator
15:51:29 <kmc> what would you use (?) for?
15:51:32 <Cale> http://cale.yi.org/share/Strings.pdf -- sneak preview of my next post :)
15:51:57 <EvanCarroll> kmc: I would use it in an imperative language to impliment guards.
15:52:18 <kmc> one neat trick for many-way conditionals is "case () of _ | foo -> ... _ | bar -> ..."
15:52:20 <EvanCarroll> but guards have the added functionality of permiting multiple conditionals
15:52:32 <Eduard_Munteanu> Hi.
15:52:35 <kmc> i don't see why an imperative language couldn't have guards, or pattern-matching for that matter
15:52:38 <kmc> in fact haskell is such a language
15:52:40 <EvanCarroll> kmc: Yea, I'm sure there are many nice tricks, but I'm only the third chapter of this tutorial
15:52:40 <kmc> hi Eduard_Munteanu
15:53:13 <EvanCarroll> kmc: but guards are just conditional syntax specific to the return value right?
15:53:14 <jlouis> Cale: a 2-arrow in general is an "arrow the next level up" so in Cat it yields Nat. Transforms?
15:53:24 <Eduard_Munteanu> kmc, yes, Haskell is well-founded imperative.
15:53:27 <kmc> EvanCarroll, not sure what you mean
15:53:54 <Cale> jlouis: yeah
15:53:59 <kmc> you can write an imperative program in haskell using pattern matching, guards, and the do notation
15:54:07 <kmc> i think that's a reasonable way to write imperative programs in general
15:54:15 <mwc> kmc: arguably a language like ocaml is very imperative and has both those features
15:54:37 <EvanCarroll> kmc: I mean, a perl user could impliment (max' a b | a > b = a | otherwise = b ) as `sub foo { my ($a,$b)=@_; return $a>$b ? $a : $b }`
15:54:44 <kmc> i think haskell is "very imperative", if that means great support for imperative programming
15:55:02 <EvanCarroll> the only difference is guards support more conditions
15:55:21 <mauke> so does ?:
15:55:32 <EvanCarroll> without nesting.
15:55:33 <mwc> kmc: from a theoretical standpoint, Haskell has some very nice foundational properties that imperative languages lack.
15:55:44 <mauke> $cond1 ? $ret1 : $cond2 ? $ret2 : $otherwise
15:55:53 <EvanCarroll> thats nesting.
15:55:54 <EvanCarroll> goodjob.
15:56:00 <idnar> how is that different to guards?
15:56:07 <BMeph> EvanCarroll: True. BTW, you could also write it (max') in Haskell that way:
15:56:10 <mwc> so I think there's room to distinguish merely imperative languages as a subclass of more general languages that also support imperative styles
15:56:22 <jlouis> Cale: sadly I stopped my Cat-theory endeavour somewhere after adjoint, so I hope you'll clean something up with those posts :)
15:56:23 <kmc> the idea that haskell is bad for imperative programming stems from the fact that there's a steep learning curve, especially for the imperative features, but it's a more general problem than that
15:56:30 <BMeph> "max' a b = if a > b then a else b"
15:56:33 <dpratt71> Cale: this is fantastic; I was just sitting here wondering just how adjunctions and monads fit together
15:56:34 <idnar> cond1 = ret1 | cond2 = ret2 | otherwise = ret3
15:56:35 <jlouis> after adjoint, before Kan extension, that is
15:56:46 <kmc> mwc, it sounds then like you're defining "imperative language" as the *absence* of certain features
15:56:49 <idnar> you're just replacing ? with = and | with :
15:56:51 <kmc> i don't find that a very useful definition
15:57:00 <kmc> i'd rather call it what it is: a design flaw in those languages
15:57:03 <mwc> heh
15:57:26 <kmc> it's not some ideological point that C++ doesn't have first-class functions.  they just didn't think it was worth the effort to implement them.
15:57:42 <kmc> now people go to ridiculous extremes just to get something halfway equivalent
15:58:03 <mwc> I think there's a point of view from which C++'s design goals are incompatible with something like first class functions
15:58:13 <kmc> which goal?
15:58:27 <orbisvicis> design flaw ?
15:58:32 <Eduard_Munteanu> Why? Function pointers implement some sort of higher-order functions.
15:58:36 <kmc> nope
15:58:39 <kmc> they don't have closure
15:58:55 <mwc> C++ is "meant" to be implemented a certain way, in so far as the features added to the language were designed to be very cheap on the hardware the designers have in mind
15:59:14 <sinelaw> C++ doesn't really encourage abstraction
15:59:19 <sinelaw> modularity
15:59:20 <kmc> people end up writing classes to simulate closures, and overriding the function-call operator
15:59:21 <sinelaw> tractability
15:59:21 <mwc> closures mean you abandon the stack and really beg for GC
15:59:28 <kmc> and this can be done in an entirely mechancial way from a lambda expression
15:59:33 <kmc> and indeed that's what they're doing in C++1x
15:59:43 <mwc> *abandon stack local storage
15:59:45 <kmc> but for now it's an extra 10 lines you have to write, that can't be nested in another function
15:59:53 <Vanadium> boost's phoenix is pretty scary for a c++ library
16:00:01 <kmc> mwc, i think you can make closures work in a context of explicit memory management
16:00:06 <kmc> obviously it will be harder to get right
16:00:10 <mwc> indeed, they did it in the standard
16:00:14 <kmc> but i'm okay with that, because it does correspond to design goals
16:00:32 <kmc> you do have concepts like close-by-value/-pointer/-reference
16:00:37 <kmc> i think they will be most useful with smart pointers
16:00:41 <mwc> yp
16:00:42 <kmc> anyway, enough C++, must eat, back later
16:00:58 <mwc> well, smart pointers are really meant for close-by-value (copy)
16:01:13 <mwc> close by copy is the only sane way to do it anyways
16:01:45 <mwc> close by reference is pretty scary, but I suppose it's not too bad in the concept of something like accumulate<>
16:01:54 <Vanadium> close-by-reference makes perfect sense when you can make some assumptions about lifetimes :\
16:02:11 <Vanadium> A lot of time, you have a local variable and then pass a closure on to something that will destroy it before it returns to you
16:02:13 <Thyssen> neat
16:02:21 <mwc> Vanadium: that's what I meant
16:02:28 <Vanadium> Right
16:02:30 <mwc> accumulate is basically STL for fold
16:02:52 <Vanadium> Or you have a reference to a thing that has ownership of the closure, and destroys it before destroying itself, like in some gui callbacks or something
16:04:00 <mwc> One of the Caml developers described their object implementation as closures with multiple entry points
16:04:02 <jlouis> I've never really done C++. It scared me too much.
16:04:15 <mwc> it's somewhat amusing to me that C++ closures are objects with a single entry point
16:04:53 <sinelaw> preflex, karma c++
16:04:53 <preflex>  c++: -14
16:05:04 <sinelaw> preflex, karma C++
16:05:05 <preflex>  C++: -14
16:05:14 <Zao> preflex, karma C
16:05:15 <preflex>  C: 46814
16:05:41 <sinelaw> Zao, Ah. So I was asking it about c++++ :)
16:05:44 <Zao> C++ is a lovely language, full of traps and grues.
16:05:50 <Badger> that's a lot of c plus plus references
16:06:02 <Badger> @karma perl
16:06:02 <Vanadium> mwc: I think it is pretty cool how C++ is just barely powerful enough that you can pretend to have a lot of concepts, just by mapping them to classes of some perverse manner
16:06:03 <lambdabot> perl has a karma of 1
16:06:07 <Badger> :o
16:06:20 <mauke> preflex: karma perl
16:06:21 <preflex>  perl: 49
16:06:49 <Zao> When I code in C++ and come up with a legal but disgusting solution, I bounce in my chair and laugh maniacally.
16:06:54 <Zao> Haskell rarely does that to me.
16:06:55 <idnar> Badger: it's even more c plus plus references if you consider C--
16:06:55 <Thyssen> preflex: karma karma
16:06:55 <Vanadium> :D
16:06:56 <preflex>  karma: 10
16:07:01 <Thyssen> preflex: karma karma
16:07:01 <preflex>  karma: 10
16:07:14 <sinelaw> Zao, and then fall on your head, when you run it and *kaboom*
16:07:27 <Thyssen> preflex: karma preflex
16:07:27 <preflex>  preflex: 7
16:07:27 <sinelaw> preflex, karma preflex
16:07:28 <preflex>  preflex: 7
16:07:30 <sinelaw> he
16:07:31 <sinelaw> h
16:07:33 <Badger> @karma chameleon
16:07:34 <lambdabot> chameleon has a karma of 3
16:07:36 <Thyssen> hehe
16:07:38 <Zao> sinelaw: Never. My code is always correct <_<
16:07:59 <sinelaw> Zao, C++ doesn't let correct code hinder the bugs
16:08:18 <Vanadium> Does too :|
16:08:18 <sinelaw> in fact that just raises the chances of a problem
16:08:34 <sinelaw> you might anger the gods
16:08:52 <Thyssen> preflex:  karma(karma(karma(karma(karma(karma(karma(karma(karma(karma(karma))))))))))
16:09:26 <erikc> like C, C++ is good for a few things: writing your kernel loops and building a runtime for a higher level language so you can get out of the tarpit
16:10:03 <Thyssen> well you can write a higher level language in haskell pretty well too
16:10:23 <Thyssen> pugs came before rakudo for example
16:11:07 <erikc> Thyssen: totally, but you can build lots of useful programs in Haskell too :), C++ is only good for getting out of it
16:11:22 <Eduard_Munteanu> @karma Eduard_Munteanu
16:11:23 <lambdabot> You have a karma of 0
16:11:24 <gisel> Enter text here...helooe
16:11:27 <gisel> helo
16:11:34 <Eduard_Munteanu> WTF? Ungrateful bastard ^^.
16:11:41 <gisel> ???
16:11:57 <Vanadium> C++ is also good because it is slightly saner than C, yet it can go and co-opt all those neat C libraries with less effort than our ffi
16:12:07 <mauke> Vanadium: NAK NAK NAK
16:12:19 <mauke> IMO C is a lot saner than C++
16:12:22 <BONUS> C++ is saner than sometihng?
16:12:24 <Eduard_Munteanu> Vanadium, that's simply a library problem.
16:12:41 <sinelaw> mauke, agreed
16:12:44 <Vanadium> C++ lets me hide a lot more stuff behind RAII than C has abstractions for
16:12:53 <Thyssen> c reminds me of an ADD child that you have to hold its hand and show it how to do everything, then 10 seconds later it forgets
16:13:01 <BONUS> imo C++ is like the guy that goes around shouting "I am napoleon!!!"
16:13:22 <mauke> Vanadium: you can't build complete and powerful abstractions in C++
16:13:37 <Vanadium> :|
16:14:00 <mauke> it's tempting to try, but it will always be incomplete and/or broken
16:14:52 <mwc> ain't that the truth
16:15:26 <Cale> @remember <BONUS> C++ is saner than something? imo C++ is like the guy that goes around shouting "I am napoleon!!!"
16:15:27 <lambdabot> It is forever etched in my memory.
16:15:35 <mauke> @flush
16:15:37 <Vanadium> I kind of liked gtkmm :(
16:15:39 <dcolish> geez HsLua dropping dofile drives me nuts
16:16:12 <Thyssen> vanadium try gtkhs
16:16:12 <Cale> @remember <Thyssen> c reminds me of an ADD child that you have to hold its hand and show it how to do everything, then 10 seconds later it forgets
16:16:12 <lambdabot> Good to know.
16:16:16 <Cale> @flush
16:16:19 <Vanadium> gtkhs is scary
16:16:38 <Vanadium> @help flush
16:16:39 <lambdabot> flush. flush state to disk
16:16:40 <Thyssen> cale?
16:17:18 <Cale> Thyssen: just telling the bot to remember your analogy :)
16:17:33 <dons> tommd: could be a bug. i'm not sure what the semantics of sliceU are supposed to be.
16:17:33 <Vanadium> Also gtk2hs seems to miss a bunch of gtk and dropping to C to use that is still easier in C++ :/
16:17:34 <Thyssen> ah neat
16:17:42 <dons> tommd: uvector needs quickchecking
16:17:44 <Vanadium> And frankly the documentation seems to be better, but that is neither here nor there :C
16:18:15 <dons> i thought it was supposed to provide a lot of gtk
16:18:23 <luite> uvector needs a working Bool instance :p
16:18:32 <dons> luite: did you work out what was wrong?
16:19:06 <dons> the instance code is straight from the array package, but UA Bool has only been lightly tested -- not quickchecked. i'd like help checking that sutff
16:19:07 <luite> dons: I guess UA Bool needs its own specialized memcpy/memmove functions
16:19:08 <jlouis> Can one slice a ByteString by a triple (bs, offset, length) and then work on the slice?
16:19:17 <jlouis> like in SML?
16:19:26 <luite> dons: that seems to be the only place where it actually goes wrong
16:19:28 <dons> luite: we'd need to do that at every type though
16:19:34 <jlouis> In other words, is there a library for that?
16:19:46 <Vanadium> Also I am not aware of a single gtk2hs application that I managed to run out of the box :C
16:20:21 <dons> luite: so maybe via the copy function in the UA type class (sounds like it needs to be a typeclass method, if you need it)
16:20:38 <luite> dons: I'm not quite sure why a machine sized word needs to be allocated for a bool array, perhaps they do some masking with a larger value than a byte
16:21:15 <dons> words are a convenient structure to work on. less memory transfers than bytes for sequential access?
16:21:21 <luite> dons: the UA type class already has these functions I think? I'd have to check though
16:22:08 <dons> its a user error, i think, to use bytewise copying functions on packed structures. at least, it is asking for trouble. you'll need to do low level stuff to compute the actual size (via the underlying type class instances)
16:22:59 <luite> dons: the offsets of the memcpy functions are in elements, not bytes, so I don't really think it's a user error
16:23:23 <dons> ok. so that does sound like a bug then. can you debug the Bool instance to see why that is?
16:23:48 <dons> if not, just send me the testcase.
16:23:57 <luite> dons: and it could be useful too, to move/copy large amounts of packed data, it could be shifted in 32 or 64 bit words by the implementation, much faster than manually copying all individual bools
16:24:00 <dons> (/me is sure lots of things will turn up once the quickchecks are in place)
16:24:16 <dons> certainly. we should be able to do clever things like that.
16:24:36 <kw317> I've got a question about lambda calculus and haskell - why is that in System F we can't write a fixed point combinator and we can in Haskell?
16:24:53 <mauke> because it's built into Haskell
16:25:08 <dons> we add Y as a primitive, basically
16:25:24 <kw317> ah, I see
16:25:31 <mwc> do we? isn't it fix f = let x = f x in x
16:25:50 <Vanadium> @src fix
16:25:51 <lambdabot> fix f = let x = f x in x
16:25:58 <dons> via the magic letrec-ish let
16:26:01 <kw317> mwc: yeah, but then you have recursive let
16:26:09 <kw317> which itself needs fix
16:26:17 <mwc> Ahhh
16:26:18 <luite> dons: I'll look at it later, probably next weekend, but I'm not sure if I can make a complete fix, it looks like it'd require some effort, and possibly more C functions (combination of memcpy and shifts)
16:26:30 <dons> hmm.
16:27:02 <luite> although some of it could be done in haskell, I don't know how fast those unchecked shifts are
16:27:04 <Vanadium> I do not understand the difference to fix f = f (fix f)
16:27:43 <Saizan_> Vanadium: the let version guarantees sharing
16:27:46 <dons> fast.
16:28:17 <Saizan_> but beyond that, they are the same
16:38:39 <gmaslov> @. hoogle type flip ($)
16:38:40 <lambdabot> Parse error:
16:38:40 <lambdabot>   --count=20 "forall b b1. b -> (b -> b1) -> b1
16:38:40 <lambdabot> "
16:40:16 <luite> dons: oh by the way, if you want a test case, just do any memcpyOffMU or memmoveOffMU on a UArr Bool, for example: a1 = toU [True,False,True,False]  test1 = let la1 = lengtU a1 in newU (2*la1) (\a -> do copyMU a 0 a1; memcpyOffMU a1 a 0 la1 la1)
16:40:47 <luite> I hope that's somewhat correct :p
16:41:29 <luite> I guess I forgot some { }
16:44:34 <dons> putting that in the testsiute. thanks
16:44:42 <dons> hopefully i get time to write some QCs on my next flight.
16:45:08 <dons> there are some properties, but they tend to test only the fused code
16:47:13 <luite> the results are unpredictable in the currenct version, the first cpy seems to work, but the memcpyOffMU seems to copy from an to a location beyond the bounds of the arrays, so the last 4 Bools are never initialized
16:48:58 <reltuk> anyone point to an example of a server that accepts persistent connections and reads and writes messages to clients?
16:49:14 <reltuk> something like an irc or game server
16:49:29 <dons> there's an irc client tutorial on the haskellwiki
16:58:51 * hackagebot upload: hoauth 0.1.8 - A Haskell implementation of OAuth 1.0a protocol. (DiegoSouza)
17:41:06 <roconnor> This puts LYAH to shame : http://lambda.bugyo.tk/cdr/mwl/
17:41:11 <roconnor> at least I think it does
17:44:13 <medfly> haha, in terms of drawings?
17:45:52 <copumpkin> roconnor: 日本語で書いたから、分かりにくいと思う
17:45:57 <copumpkin> or something like that
18:20:09 <kmc> @bot
18:20:10 <lambdabot> :)
18:20:10 <lunabot>  :o
18:20:32 <Zao> (:[])
18:22:25 <tensorpudding> this channel has a lot of bots
18:22:45 <medfly> 1 per 200 people
18:22:49 <medfly> :))
18:22:53 <hiredman> nice
18:22:59 <kmc> this channel has a lot of people
18:23:12 <tensorpudding> i know about lambdabot but not the others
18:23:35 <monochrom> No people here. Everyone is a surrogate.
18:23:55 <reltuk> is the right pattern for accepting connections: forever $ do { listenOn; accept; forkIO; sClose } ?
18:24:08 <mauke> that looks wrong
18:24:36 <mauke> I think listen should only be called once
18:24:56 <mauke> sClose should probably be done in the new thread
18:24:56 <reltuk> and so no need for sClose after that, huh?
18:25:08 <mauke> er, accept gives you a new fd
18:25:20 <reltuk> yeah, hClose in the new thread
18:25:34 <mauke> forkIO $ foo `finally` sClose fd
18:26:12 <ivanm> preflex: seen Axman6
18:26:12 <preflex>  Axman6 was last seen on #haskell 5 hours, 36 minutes and 12 seconds ago, saying: dpratt71: i try and always use both
18:26:38 <ivanm> @ask Axman6 you actually liked the FatELF proposal!?!?!?! go back into your hole you filthy little mac fanboi! :p
18:26:38 <lambdabot> Consider it noted.
18:26:48 <medfly> lol
18:27:06 <chrisf> hi #haskell
18:27:09 <Vanadium> Everywhere else, they seem to multiplex on connections in a single thread :<
18:27:13 <kmc> hi chrisf
18:27:22 * ivanm doesn't get why some projects create their own .deb, .rpm, etc. files... isn't that up to the distro to make?
18:27:32 <chrisf> multiplexing on connections on a single thread sounds good.
18:27:34 * ivanm vaguely waves in chrisf's general direction
18:27:37 <chrisf> can has context?
18:27:49 <kmc> Vanadium, threads are a pain in most languages
18:27:49 <dmwit> ivanm: But, but, what if the project isn't notable enough to be put in the distro!
18:28:09 <Vanadium> kmc: But surely this way this just means you somehow have to multiplex on the changes that all your clients do to shared state
18:28:12 <ivanm> dmwit: then switch to a better distro!
18:28:20 <ivanm> or get it into a community repository for that distro
18:28:25 <chrisf> Vanadium: what are you doing with shared state?
18:28:36 <dmwit> ivanm: So, what you're saying is, build a .deb...?
18:28:38 <ivanm> dmwit: my main beef is with (usually commercial) packages that have a .rpm and that's it...
18:28:40 <Vanadium> Having my clients interact, presumably
18:28:45 <kmc> ivanm, tried alien?
18:28:56 <ivanm> dmwit: IIRC, .rpms aren't that cross-distro
18:29:12 <ivanm> kmc: do a /whois on me and try and guess why that is an absolutely useless thing to try ;-)
18:29:19 <dmwit> Right, I know, just playing devil's advocate.
18:29:23 <chrisf> surely *if there is no other package*, then building a package as part of your build is not a bad move.
18:29:37 <kmc> heh
18:30:05 <chrisf> but getting a package included in contrib for the various distros is better.
18:30:06 <ivanm> dmwit: or stupid upstreams that think everyone uses ubuntu (or whatever their distro of choice is)
18:30:23 <Axman6> ivanm: o/
18:30:24 <lambdabot> Axman6: You have 2 new messages. '/msg lambdabot @messages' to read them.
18:30:32 <ivanm> hey Axman6
18:31:01 <chrisf> lambdabot provides message storage now too? :D
18:31:03 <Axman6> you don't think FatELF is a good idea? wtf is wrong with you?
18:31:08 <Axman6> chrisf: it always has
18:31:12 <ivanm> chrisf: "now"? always has AFAIK...
18:31:23 <ivanm> Axman6: because I don't think binary packages are a good idea ;-)
18:31:29 <chrisf> every cool feature of lambdabot is "new" to me.
18:31:38 <ivanm> have you seen flameeye's blog post about FatELF?
18:31:42 <Vanadium> Siding with ivanm out of gentoo solidarity here
18:31:43 <medfly> it has really cool things.
18:31:45 <medfly> @keal
18:31:45 <lambdabot> can haskell pipe the raw irrational megaequation into an analog device
18:31:49 <chrisf> FatELF sounds like an incredibly stupid idea.
18:31:51 <ivanm> Vanadium: \o/
18:31:56 <Axman6> ivanm: and you're the kind of person who is keeping linux from being a decent desktop OS
18:31:58 <medfly> fat elf
18:31:58 <Thyssen> lambdabot kick lambdabot
18:32:11 <medfly> Axman6, it's all your fault!
18:32:14 <dcolish> whats wrong with linux's desktop?
18:32:17 <Axman6> chrisf: why? it makes life for users about 1000 times easier
18:32:25 <dcolish> or any unix desktop?
18:32:38 <ivanm> dcolish: agreed
18:32:41 <ivanm> Axman6: how?
18:32:43 <Axman6> dcolish: not any unix desktop, OS X does a fantastic job
18:32:46 <kmc> @nixon
18:32:46 <lambdabot> Americans admire a people who can scratch a desert and produce a garden. The Israelis have shown qualities that Americans identify with: guts, patriotism, idealism, a passion for freedom. I have
18:32:46 <lambdabot> seen it. I know. I believe that.
18:32:50 <Vanadium> I am inherently suspicious of any rationale that starts with "Given enough disc space,"
18:32:52 <chrisf> that's hardly a unix.
18:32:53 <Thyssen> because x is crufty and performance is crummy
18:32:57 <ivanm> how do package managers _not_ solve the problem?
18:33:00 <dcolish> os x isn not unix
18:33:01 <ivanm> Thyssen: ssshhhh!
18:33:01 <Vanadium> as someone who uses a notebook pretty much exclusively and has netbook-using friends, and
18:33:01 <ivanm> ;-)
18:33:13 <Axman6> ivanm: because users don't have to worry about which architecture their OS is running on when they want to download something not in their package manager
18:33:14 <ivanm> dcolish: was that "isn't not unix" or "is not unix" ?
18:33:17 <medfly> is @nixon a thing that shows nixon quotes?
18:33:21 <kmc> yes
18:33:21 <Thyssen> dcolish: it has the sco certification
18:33:22 <kmc> @nixon
18:33:22 <medfly> like, the president?
18:33:22 <lambdabot> Once you get into this great stream of history, you can't get out.
18:33:23 <Axman6> dcolish: um, what?
18:33:23 <medfly> cool.
18:33:25 <mmorrow> all osx's "universal" binary fmt (or whatever the name is) is an ar archive of one mach-o file for each possible platform iirc
18:33:25 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
18:33:27 <dcolish> ivanm: is not unix
18:33:32 <dcolish> lag sucks
18:33:33 <ivanm> Axman6: as I argued earlier, that's a stupid thing to do
18:33:34 <tensorpudding> OSX is UNIX, it fits the specification
18:33:42 <kmc> richard milhous nixon yes
18:33:45 <Axman6> ivanm: what is?
18:33:58 <kmc> @help nixon
18:33:58 <lambdabot> Richad Nixon's finest.
18:34:02 <chrisf> tensorpudding: it might once have been a UNIX, but it's got so much nextstep-style crap bolted on...
18:34:08 <ivanm> Axman6: having binary packages (well, I was talking specifically about pre-build .debs, etc.)
18:34:08 <tensorpudding> in any meaningful sense of the word UNIX
18:34:11 <Axman6> dcolish: it is unix
18:34:15 <dcolish> nope
18:34:20 <Axman6> like, officially, it _is_ unix
18:34:22 <ivanm> Axman6: if you're using a non-x86-based arch, then you must surely know enough to make sure you get the correct arch binary
18:34:25 <kmc> if they spell it "creat" instead of "create" then it's unix
18:34:27 <hiredman> UNIX
18:34:31 <Axman6> ivanm: what about PPC?
18:34:33 <dcolish> it utilizes unix, but its something else
18:34:34 <kmc> @quote unix
18:34:34 <lambdabot> Cale says: interact is the one true way to write unix programs in Haskell :)
18:34:36 <hiredman> sco's trademark is UNIX
18:34:37 <Vanadium> Having binary packages is a pretty good plan if you are targetting mobile devices :(
18:34:39 <chessguy> 'ello
18:34:43 <kmc> @quote unix
18:34:44 <lambdabot> Cale says: interact is the one true way to write unix programs in Haskell :)
18:34:48 <Axman6> dcolish: ... you are kidding right?
18:34:53 <dcolish> nope
18:35:00 <chrisf> @quote unix
18:35:00 <lambdabot> Cale says: interact is the one true way to write unix programs in Haskell :)
18:35:06 <Axman6> http://arstechnica.com/apple/news/2007/08/mac-os-x-leopard-receives-unix-03-certification.ars
18:35:08 <ivanm> Axman6: thy surely know enough that they're using a non-Intel platform
18:35:11 <Thyssen> ok lambdabot we get it
18:35:13 <hiredman> @nixon
18:35:14 <lambdabot> In a flat choice between smoke and jobs, we're for jobs...But just keep me out of trouble on environmental issues.
18:35:16 <kmc> welp this argument sure is going places
18:35:19 <ivanm> certification /= unix :p
18:35:20 <Axman6> ivanm: so my dad should know that?
18:35:24 <dcolish> arstechnica, all that is true is world... i forgot
18:35:27 <tensorpudding> what is unix then?
18:35:33 <mmorrow> Axman6: it's a bsd with a bunch of proprietary lockdown :)
18:35:35 <kmc> @vixen what is unix?
18:35:36 <lambdabot> let's don't talk about that
18:35:36 <hiredman> ivanm: but certification == UNIX
18:35:40 <Vanadium> kmc: Maybe we can talk about C++ again instead :)
18:35:42 <ivanm> Axman6: how often does your dad install random packages off websites?
18:35:46 <kmc> @quote c++
18:35:46 <lambdabot> quicksilver says: No. I don't think that [omitted] is hackish. It's a common and useful idiom in C, Perl, and Shell.
18:35:49 <Axman6> often enough
18:35:49 <dmead> hello channel
18:35:51 <dmead> > 0^0
18:35:52 <lambdabot>   1
18:35:55 <dmead> hmmm!
18:36:02 <ivanm> (and the fact that you have a PM that prevents you from doing that is one of the greatest benefits of linux over windows IMHO)
18:36:03 <Axman6> ivanm: and no matter which maching he's on, it's the same download
18:36:14 <MacCoaster> how do i load a second module in ghci so that i still have the first Module loaded in context.. ive tried to do stuff like :m + SecondModule but it keeps saying SecondModule is not loaded
18:36:15 <Axman6> PM?
18:36:18 <chrisf> c++ is the one language that surpasses haskell in weirdness.
18:36:25 <monochrom> > product []  {- this is why -}
18:36:26 <lambdabot>   1
18:36:27 <dcolish> lol
18:36:30 <kmc> MacCoaster, you have to give the file on the command line too
18:36:40 <monochrom> > 0**0
18:36:41 <lambdabot>   1.0
18:36:41 <ivanm> Axman6: package manager
18:36:48 <kmc> or use :load
18:36:48 <monochrom> That one is new to me
18:37:02 <MacCoaster> kmc:  bingo, thanks!
18:37:08 <kmc> chrisf, not the good kind of weirdness though :/
18:37:19 <Axman6> ivanm: package managers are flawed, and are just there because linux systems have an inadequate way of manageing software installs and libraries
18:37:19 <ivanm> monochrom: what, 0 ** 0 = 1?
18:37:21 <tensorpudding> > 0/0
18:37:22 <lambdabot>   NaN
18:37:27 <chrisf> agreed; haskell's weirdness rocks. c++'s weirdness is just... weird.
18:37:28 <ivanm> probably a definitional thing somewhere to make other stuff work well
18:37:33 <ivanm> because x ^ 0 == 1
18:37:39 <ivanm> Axman6: nope
18:37:41 <monochrom> I don't mind it.
18:37:43 <ivanm> I disagree
18:37:50 <ivanm> Axman6: so you don't use cabal-install?
18:37:52 <dcolish> pacman ftw!
18:37:54 <ivanm> you do it all by hand?
18:37:54 <Axman6> i do
18:38:04 <ivanm> well, cabal-install is a poor-man's PM
18:38:10 <Axman6> it is for different things. package managers are find for programmers
18:38:11 <kmc> > undefined ^ 0
18:38:12 <lambdabot>   1
18:38:15 <monochrom> I know people argue over what 0^0 or 0^^0 or 0**0 means. It's not better than arguing what qualifies as unix.
18:38:17 <tensorpudding> PM is a package manager
18:38:19 <Thyssen> ivanm:: PM?
18:38:19 <Axman6> fine*
18:38:19 <mauke> so ... can we move this talk about binaries, unix, and package managers to #haskell-blah?
18:38:26 <ivanm> Axman6: and with dynamic libraries, you need something to do all the deps and everything for you
18:38:26 <tensorpudding> err, cabal-install
18:38:30 <ivanm> Thyssen: package manager
18:38:34 <Axman6> #haskell-blah gogogo
18:38:38 <kmc> > undefined ** 0
18:38:39 <lambdabot>   * Exception: Prelude.undefined
18:38:46 <tensorpudding> it is just a very lacking one
18:38:50 <ivanm> Axman6: a lot of people agree that package managers are one of the nicer aspects of distros
18:38:53 <ivanm> including newbies
18:38:55 <Axman6> ivanm: #haskell-blah
18:39:04 <Axman6> ivanm: i c ertainly do not
18:39:06 <mmorrow> i don't think sticking every possible binary in an ar archive is very universal, or scalable
18:39:10 <kmc> @src (^)
18:39:10 <lambdabot> x ^ 0            =  1
18:39:11 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
18:39:11 <lambdabot>   where f _ 0 y = y
18:39:11 <lambdabot>         f x n y = g x n
18:39:11 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
18:39:12 <lambdabot>                       | otherwise = f x (n-1) (x*y)
18:39:13 <ivanm> mmorrow: agreed
18:39:14 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
18:39:25 <mmorrow> let alone efficient wrt disk space
18:39:36 <Axman6> mmorrow: that's also not what's proposed or what is done
18:39:41 <ivanm> Axman6: http://blog.flameeyes.eu/2009/11/04/elf-should-rather-be-on-a-diet
18:39:46 <mmorrow> Axman6: that's what apple does
18:39:51 <Tordek> @src iterate
18:39:51 <lambdabot> iterate f x =  x : iterate f (f x)
18:39:56 <Axman6> not every possible architecture
18:40:02 <Axman6> the 4 architectures they support
18:40:08 <chrisf> what's the impact of fatelf on vm usage? can we cleanly mmap just the image for our current arch?
18:40:11 <Axman6> which does not make programs large
18:40:17 <mauke> HELLO MORE HASKELL PLZ
18:40:18 <ivanm> Axman6: right, but gentoo supports a heap of arches
18:40:22 <Axman6> their resources take up significantly more space
18:40:22 <ivanm> so does debian IIRC
18:40:24 <ivanm> not just 3
18:40:27 <kmc> @nixon
18:40:27 <lambdabot> Your boys will be home for Christmas.
18:40:33 <Axman6> urgh
18:40:33 <ivanm> mauke: heh
18:40:40 <chrisf> ivanm: gentoo does not (even superficially!) support newbies, though.
18:40:40 <tensorpudding> the fact that linux supports more distros than apple is irrelevant
18:40:43 <kmc> @vixen what do you think of FatELF?
18:40:44 <lambdabot> let's don't talk about that
18:40:45 <ivanm> chrisf: true
18:40:53 <tensorpudding> since you are technically not supposed to run OSX on non-apple hardware
18:40:55 <ivanm> chrisf: I did mention debian as well though ;-)
18:40:55 <kmc> hey guys listen to lambdabot
18:41:06 <ivanm> kmc: heh
18:41:09 <Thyssen> chrisf: sure it does, it has some of the best documentation of the linuxen
18:41:22 <monochrom> haha
18:41:33 <ivanm> Thyssen: yes, and then you get random people ranting at design choices, etc.
18:41:38 <Thyssen> what gentoo handbook is excellent
18:41:41 <tensorpudding> gentoo makes you do a lot of work yourself, which is more involved and not suitable for everyone
18:41:43 <ivanm> see the recent argument about nano as the default editor
18:41:51 <dcolish> so i'm trying to use arrows for the first time like: printFile = readFile >>> print
18:41:54 <chrisf> Thyssen: my grandma doesn't stand a chance against broken USE/CFLAGS/etc.
18:41:57 <dcolish> but i think somethings wrong
18:42:07 <Thyssen> hhehe so buy her windows 7
18:42:07 <mauke> :t (>>>)
18:42:09 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
18:42:15 <tensorpudding> wow
18:42:20 * thoughtpolice is happily running debian at work
18:42:25 <tensorpudding> Category.Category
18:42:41 * chrisf whispers that 7 actually rocks, and he uses it in favor of linux.
18:42:54 * monochrom uses 9
18:42:55 <thoughtpolice> i don't feel the need to fuck around with gentoo. :/ I want something I can put into my CD drive, answer a few questions and have it boot to a login screen (be it X or not)
18:42:59 <mauke> :t readFile >=> putStr
18:43:01 * Axman6 uses 10
18:43:01 <lambdabot> FilePath -> IO ()
18:43:09 <chrisf> damn linux's broken ACPI.
18:43:10 * tensorpudding goes up to 11
18:43:17 <dcolish> why do you need th >=> instead of >>>?
18:43:20 <Axman6> what's an ACPI?
18:43:20 <chrisf> i see what you did there :D
18:43:26 <mauke> :t (>=>)
18:43:28 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
18:43:31 <monochrom> actually 6.8.2 works fine for me, I don't need 7 yet.
18:43:33 <dcolish> ah
18:43:44 <thoughtpolice> advanced configuration and power management
18:43:49 * Axman6 doesn;t actually care, and is just making yet another point about how inadequate linux is
18:44:01 <kmc> dcolish, because you can't declare a Category instance for /\a. /\b. a -> m b
18:44:02 <ivanm> chrisf: it isn't linux that has the broken ACPI
18:44:06 <kmc> :t (>>>)
18:44:07 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
18:44:16 <tensorpudding> OS flamewars go elsewhere ---->
18:44:17 <Axman6> ivanm: well, yeah, it is
18:44:20 <monochrom> automatic continuation passing interaction
18:44:25 <chessguy> hey guys...i hate haskell package dependencies. trying to install http://www.haskell.org/haskellwiki/GeBoP . when i "cabal install GeBoP" it tells me "ghc-pkg: dependency bytestring-0.9.1.5 doesn't exist (use --force to override)". when i try to "caball install bytestring", it tells me "All the requested packages are already installed." Suggestions?
18:44:28 <ivanm> it's the HW manufacturers that deliberately cripple their ACPI, either by having if-checks for linux (I've seen this) or using deliberate proprietary windows extensions
18:44:30 --- mode: ChanServ set +o mauke
18:44:41 <tensorpudding> chessguy: did you do cabal update?
18:44:42 <ivanm> chessguy: :o
18:44:46 <Thyssen> so far this language pwns
18:44:47 <chrisf> ivanm: you're correct, of course. however, when windows can do S3/S4 on my laptop and linux can't, linux loses.
18:44:50 <mauke> please, no more linux, packages, etc :-(
18:44:58 <kmc> buy a thinkpad
18:45:05 <thoughtpolice> Axman6: I have some qualms with package managers (although apt is quite excellent after having used debian for a few months, I must say,) but I do not think linux is 'inadequate' unless you would like to specifically say what it's inadequate at
18:45:05 <tensorpudding> buy me a macbook pro
18:45:25 <chessguy> tensorpudding:  yup, that was the first thing i did before i started
18:45:29 <dcolish> mauke: what scope is (>=>) in?
18:45:30 --- mode: mauke set -o mauke
18:45:40 <mauke> @hoogle (>=>)
18:45:40 <kmc> @hoogle (>=>)
18:45:40 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
18:45:41 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
18:45:43 <copumpkin> oh wow, I assumed tensorpudding was FunctorSalad, but he doesn't appear to be
18:45:47 <tensorpudding> chessguy: what version of ghc is it...
18:45:59 <chessguy> 6.8.2
18:46:02 <ivanm> chessguy: I've built 0.9.1.5 here with 6.10.4 ...
18:46:21 <tensorpudding> on hackage, 0.9.1.5 is clearly available...
18:46:36 <tensorpudding> what version of base does 0.9.1.5 require i wonder
18:46:47 <chessguy> what is 0.9.1.5? bytestring?
18:46:49 <ivanm> but I'm surprised that it specifically requests it; by the PVP its API should be identical to all other 0.9.1.* (unless it specifically uses the thing that .5 had the bug fix for)
18:46:52 <ivanm> chessguy: yes
18:47:10 <kmc> dcolish, functions of the form (a -> m b) form a monoid with return and (>=>)
18:47:18 <ivanm> chessguy: maybe paste up the entire build output to see if we can glean any more hints from it?
18:47:20 <tensorpudding> chessguy: bytestring, i mean, yes
18:47:21 <kmc> learned that today, it's a nice way to state the monad laws
18:47:26 <dcolish> a monoid?
18:47:33 <dcolish> geez
18:47:49 <dcolish> i love the names used for things in haskell
18:47:52 <chessguy> ivanm:  from the GeBoP install?
18:47:58 <ivanm> chessguy: yeah
18:48:03 <kmc> they're mostly from math
18:48:05 <ivanm> dcolish: well, it is a monoid
18:48:10 <chessguy> k
18:48:12 <ivanm> so what's wrong with that name? ;-)
18:48:19 <dcolish> nothing, i like it
18:48:26 <dcolish> just dont know what it means one bit
18:48:43 <tensorpudding> on my system, i can get 0.9.1.5 of bytestring fine, though i'm using 6.10.1
18:48:46 <mauke> dcolish: it means it has a neutral element and an associative operation
18:48:51 <kmc> if you know group theory, a monoid is a group which doesn't necessarily have inverses
18:49:01 <kmc> @src Monoid
18:49:01 <lambdabot> class Monoid a where
18:49:01 <lambdabot>     mempty  :: a
18:49:01 <lambdabot>     mappend :: a -> a -> a
18:49:01 <lambdabot>     mconcat :: [a] -> a
18:49:07 <dcolish> i dont know group theory
18:49:19 <tensorpudding> or it's a category with some nice properties
18:49:23 <Axman6> thoughtpolice: if you missed it, i replied in #haskell-blah
18:49:25 <chessguy> tensorpudding:  maybe i'm due for a ghc upgrade?
18:49:38 <mauke> law: mappend a (mappend b c) == mappend (mappend a b) c
18:49:42 <ivanm> chessguy: why, what are you using?
18:49:50 <ivanm> oh, right 6.8.2
18:49:50 <mauke> law: mappend mempty x == x
18:49:51 <chessguy> 6.8.2
18:49:59 <ivanm> WHAT ARE YOU DOING WITH SUCH AN OLD VERSION OF GHC?!?!?!?!? :o
18:49:59 <kmc> i.e. ((a ++ b) ++ c) == (a ++ (b ++ c))
18:50:03 <chessguy> haha
18:50:10 <tensorpudding> chessguy: i don't think so, there is no requirements on bytestring for 6.10
18:50:15 <chessguy> ok
18:50:18 <monochrom> 6.8.2 is not that old.
18:50:20 <dcolish> ah i see
18:50:34 <tensorpudding> also 6.8.x is what's in a good number of linux package managers
18:50:38 <Axman6> monochrom: sure it is
18:50:38 <mauke> dcolish: instance Monoid [a] where mempty = []; mappend = (++)
18:50:46 <tensorpudding> so it's the standard issue there.
18:50:47 <monochrom> fine
18:50:52 <tensorpudding> I'm not sure what version is in macports
18:50:53 <Saizan_> chessguy: it's weird, none of of the deps of GeBoP seem to require that specific version of byetstring
18:51:00 <Axman6> tensorpudding: ... yeah i'll keep quiet about package managers :P
18:51:13 <ivanm> Axman6: heh
18:51:38 <mmorrow> (+,0),(*,1),(++,[]),((.),id),(and,True),(or,False),(union,empty),(intersection,all),..
18:51:50 <mmorrow> (mappend,mempty)
18:51:59 <chessguy> @paste
18:51:59 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
18:53:42 <chessguy> wait for it....
18:53:53 <Axman6> tensorpudding: macports has always had the latest release less than a month after release
18:53:57 <ivanm> chessguy: if you're hoping for the paste announce...
18:54:02 <ivanm> it hasn't been here for quite a while :(
18:54:19 <chessguy> no, i'm waiting for the build attempt to finish so i can copy/paste the output
18:54:26 <ivanm> ahhh
18:54:34 <Saizan_> chessguy: ghc-pkg list might also be relevant
18:54:43 <ivanm> and check
18:55:20 <Axman6> tensorpudding: though, it is currently broken at the moment on snow leopard (GHC problem, not taking account of the 64 bit changes)
18:55:32 <chessguy> here's the ghc-pkg list: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4865#a4865
18:55:36 <tensorpudding> Axman6: not surprising
18:55:56 <tensorpudding> Axman6: though macports are source packages, so you have to compile them
18:55:56 <ivanm> Axman6: I thought ChilliX fixed it...
18:56:03 <kmc> is there any relationship between haskell-src-exts and GHC's parser?
18:56:11 <ivanm> chessguy: well, you have 0.9.1.5
18:56:18 <ivanm> chessguy: what does "ghc-pkg check" say?
18:56:19 <Axman6> ivanm: he probably has, but i don't know if it's in the actual GHC source or not
18:56:29 <chessguy> strange. why does it look like i have both 0.9.1.4 and .5?
18:56:32 <Axman6> ChilliX: you around?
18:56:40 <ivanm> Axman6: IIRC, he was going to put it in (this is the ghci problems for 6.12)
18:56:45 <ivanm> chessguy: because you do
18:56:47 <Saizan_> chessguy: there's usually no problem in having multiple versions
18:56:49 <tensorpudding> chessguy: maybe installation of 0.9.1.5 failed but it was marked as installed
18:56:52 <ivanm> chessguy: cabal-install doesn't remove old versions
18:56:57 <JohnnyL> are there any web providers that host haskell (as cheap as they get)?
18:56:59 <chessguy> "ghc-pkg check" doesn't output anything
18:57:06 <tensorpudding> you might try reinstalling it with install --reinstall
18:57:12 <Saizan_> chessguy: though i think  you're getting problems with wx/wxcore
18:57:29 <ivanm> JohnnyL: as in hosting haskell-based web frameworks (happstack, etc.)?
18:57:33 <ivanm> or haskell code?
18:57:37 <dcolish> i often feel like i dont have enough math under my belt to really get into the fun hasekll stuff
18:57:45 <kmc> dcolish, which stuff?
18:58:02 <Axman6> dcolish: you don't need it
18:58:03 <kmc> and which math
18:58:04 <dcolish> arrows, monoids etc
18:58:06 <ivanm> dcolish: I often feel I have the wrong math under my belt to really get into the fun haskell stuff... ;-)
18:58:10 <kmc> category theory helps a bit with intuition but it's not necessary for the programing itself
18:58:10 <Axman6> learning lambda calculus is somewhat helpful
18:58:11 <ivanm> Axman6: to keep up with Cale you do! :p
18:58:14 <monochrom> I don't either. Don't worry. Learn as needed. Don't generalize prematurely.
18:58:15 <JohnnyL> ivanm like ghc and a way to get data out via port 80.
18:58:30 <ivanm> JohnnyL: ummm... a remote build site?
18:58:38 <JohnnyL> ivanm yah
18:58:40 <monochrom> (I still don't know 2-categories!)
18:58:43 <ivanm> look for one with ssh access or something?
18:58:51 <tensorpudding> to keep up with sigpfe and comonad.reader you need crazy knowledge
18:58:57 <Saizan_> chessguy: http://www.haskell.org/haskellwiki/WxHaskell/Building#building_by_cabal_command
18:58:57 <ivanm> monochrom: wait, I didn't even know there was such a thing as 2-categories!
18:59:01 <JohnnyL> ivanm thanks anyway.
18:59:14 <Thyssen> (length [1..])
18:59:17 <ivanm> JohnnyL: maybe look for one with ssh access or something?
18:59:29 <ivanm> Thyssen: were you expecting that to run?
18:59:37 <chessguy> Saizan_:  you might be right, check this out: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4865#a4866
18:59:38 <ivanm> Haskell /= lisp :p
18:59:40 <dcolish> model theory stuff mostly
18:59:45 <Thyssen> ivanm: yes
18:59:48 <tensorpudding> n-category cafe is pretty hardcore also
18:59:56 <Axman6> model theory?
18:59:59 <monochrom> w00t model theory! So you know how to prove CH is independent of ZFC?
19:00:01 <ivanm> > length ([1..] :: [Int])
19:00:05 <lambdabot>   mueval-core: Time limit exceeded
19:00:05 <ChilliX> Axman6: yep
19:00:07 <tensorpudding> though that's not haskell, but math/physics
19:00:17 <Cale> Forcing FTW!
19:00:18 <ivanm> Thyssen: use > to preface code to run
19:00:22 <copumpkin> > genericLength [1..] > (3 :: Natural)
19:00:22 <Thyssen> ah neat
19:00:23 <lambdabot>   True
19:00:28 <Saizan_> chessguy: heh, yeah, it seems wxcore picked the user-installed deps but it's trying to register itself in the global package db
19:00:31 <Axman6> ChilliX: i saw the thesis' your students wrote, looking forward to reading them :)
19:00:32 <chessguy> Saizan_:  ok, let me give those options a shot
19:00:32 <Cale> (I don't really understand forcing)
19:00:34 <Thyssen> > False
19:00:35 <lambdabot>   False
19:00:36 <ivanm> Cale: forcing what? esoteric math down people's throats? :p
19:00:50 <monochrom> I understand forcing a thunk. <duck>
19:00:53 <Cale> ivanm: It's the technique used to prove various things are independent of ZFC.
19:00:58 <ivanm> ahhhh
19:01:08 <Axman6> i understand forcing a thug isn't a great idea
19:01:14 <monochrom> haha
19:01:35 <dcolish> thugs can be nasty
19:01:43 <ivanm> Axman6: well, if you're a bigger thug it isn't that big a deal...
19:01:54 <Axman6> only if you're up for a fight
19:01:59 <tensorpudding> i don't understand inaccesible cardinals
19:02:15 <copumpkin> are they like inaccessible island in the south atlantic?
19:02:17 <Axman6> tensorpudding: the ones locked up in the vatican?
19:02:21 <tensorpudding> lol
19:02:24 <monochrom> hahaha
19:02:26 <copumpkin> lol
19:02:32 <tensorpudding> it's a birdcage with a rusty hinge
19:04:16 <ivanm> hmmm.... apparently sigfpe's latest blog post only needs high school algebra...
19:04:26 <tensorpudding> yeah...
19:04:39 <tensorpudding> i've never seen type theory in high school algebra
19:04:46 <ivanm> this, of course, depends on your definition of "high school algebra"...
19:04:54 <ivanm> (which depends on where you went to high school)
19:04:56 <monochrom> and quantifiers
19:04:56 <nolrai_FG> Is there a function to cleare the console in haskell. So that you could write something like less or a rouge like or something?
19:05:03 <mmorrow> JohnnyL: if you have linux and ssh access to your hosted box, then you can get ghc setup on it one way or another
19:05:17 <ivanm> oh, these axioms: http://en.wikipedia.org/wiki/Tarski%27s_high_school_algebra_problem
19:05:33 <monochrom> (It saddens me that quantifiers are not quite done properly in highschool. Makes things like induction and limits more confusing.)
19:05:45 <mmorrow> JohnnyL: i've got two separate hosted servers that i've got setup with ghc
19:05:59 <nolrai_FG> monochrome: ??
19:06:02 <ivanm> monochrom: here, stuff like induction is only taught in extension mathematics at high school...
19:06:03 <tensorpudding> i saw quantifiers near the end of high school
19:06:15 <ivanm> quantifiers == forall, there exists, etc.?
19:06:17 <tensorpudding> and i remember we talked about sets for a brief time
19:06:22 <tensorpudding> yes
19:06:34 <dibblego> forall == universal quantifier, exists == existential quantifier
19:06:36 <ivanm> yeah, did that in extension math as well
19:06:47 <nolrai_FG> my formal math training started at precalc so my view of the whole thing is rather distorted.
19:06:57 <tensorpudding> the standard heirarchy of N < Z < Q < R < C
19:07:13 <ivanm> < == subset ?
19:07:16 <tensorpudding> but we focused entirely on R
19:07:20 <tensorpudding> yeah, lazy notation
19:07:23 <ivanm> heh
19:07:36 <ivanm> is 0 \in N ? :p
19:07:41 <nolrai_FG> I dont really like R.
19:07:47 <mmorrow> N doesn't really belong there unless we're just talking about them as sets
19:07:57 <kmc> real numbers are bogus
19:08:03 <tensorpudding> we were talking about sets
19:08:05 <Saizan_> poor N
19:08:10 <ivanm> Saizan_: heh
19:08:10 <kmc> almost every real number contains an infinite amount of information
19:08:15 <tensorpudding> in high school we didn't have any notion of structured sets
19:08:23 <ivanm> kmc: so how are they not real?
19:08:24 <tensorpudding> in formal terms
19:08:35 <kmc> what do you mean?
19:09:02 <Cale> ivanm: 0 is usually in N these days ;)
19:09:03 <kmc> structured sets = categories?
19:09:22 <ivanm> Cale: depends if you talk to a mathematician or a computer scientist sometimes...
19:09:35 <dcolish> Cale: it was explained to me that 0 is in N when its convenient
19:09:40 <tensorpudding> kmc: i meant generally groups, rings, fields, lattices, monoids, algebras, etc.
19:09:42 <kmc> N = \mu X. 1 + X
19:09:45 <ivanm> IIRC, when I did first year discrete math we had 0 \in N only because the subject was mainly for IT students
19:09:46 <kmc> yeah, categories
19:09:48 <ivanm> dcolish: heh
19:09:57 <tensorpudding> you can think of them as all categories
19:10:35 <Cale> dcolish: yeah, basically
19:10:59 <Cale> dcolish: I tend to use N when talking about {0,1,2,...} and Z+ for {1,2,3...}
19:11:29 <ivanm> in high school, we used "whole numbers" as the term for Z+ (since this conversation started with what "high school maths" meant)
19:11:45 <ivanm> Cale: but agreed, Z+ is what I use[d] when talking about {1,..}
19:11:55 <tensorpudding> almost all real numbers have a geometric mean equal to khinchin's constant but we have not conclusively found one that does
19:12:01 * kmc is lately worrying about http://hackage.haskell.org/trac/ghc/ticket/1496
19:12:16 <tensorpudding> err, the geometric mean of their continued fraction expansion
19:12:19 <Cale> yeah
19:12:38 <Cale> There are surprisingly few almost all real numbers.
19:12:54 <Cale> ;)
19:12:54 <kmc> that's because almost all real numbers aren't computable
19:12:58 <kmc> so how would we find one?
19:13:01 <tensorpudding> though i still need to get over chaitin's constant
19:13:09 <dcolish> the more math i study, the me i think understanding is a lot of notation over concepts
19:13:14 <dcolish> s/me/more/
19:13:35 <Cale> dcolish: Having the right notation certainly makes understanding a heck of a lot smoother.
19:13:54 <Cale> Just having the right definitions is often hard to achieve :)
19:14:00 <tensorpudding> i've been reading awodey, i've noticed he has a tendancy to mention things "in quotes"
19:14:20 <dcolish> Cale: i can imagine
19:15:50 <Cale> dcolish: This is something I really like about category theory. It gives you a lot of tools for finding what are probably the right definitions.
19:16:39 <monochrom> category theory is a better design pattern than design pattern
19:16:59 <tensorpudding> category theory is the lowest common denominator of math, there's enough abstraction to do all sorts of things
19:17:05 <dcolish> heh, they mention arrows in the wikipedia def
19:17:20 <kmc> of category theory?
19:17:30 <dcolish> yes: http://en.wikipedia.org/wiki/Category_theory
19:17:45 <kmc> there's sort of an unfortunate clash between what Haskell calls "Arrows" and what category theory does
19:18:05 <kmc> Haskell's Arrow class is more like "category with cartesian products"
19:18:22 <Cale> mm... and perhaps some other stuff
19:18:31 <kmc> certainly other stuff, someone else can explain better
19:18:36 <hansfbaier> anyone knows a decent, more practically oriented introduction into category theory?
19:18:51 <kmc> dcolish, this took me forever to understand: the objects of the category Hask are the types in Haskell, and the morphisms ("arrows") are functions
19:18:58 <hansfbaier> many books on category theory are not very much fun to read.
19:18:59 <kmc> *not* the function types
19:19:18 <Cale> Arrows actually happen to be monoid objects in a particular category of bifunctors, but iirc, it's not quite as simple as that even.
19:19:34 <dcolish> i thought all functions were arrows?
19:19:38 <kmc> this matches the idea that a category is a "typed monoid"
19:19:39 <Cale> hansfbaier: Have you tried Awodey's book?
19:20:03 <kmc> (->), that is the type constructor of Haskell functions, is an instance of Arrow
19:20:26 <Cale> yeah...
19:20:30 <kmc> and more importantly of Category
19:20:34 * hansfbaier googles
19:20:39 <tensorpudding> i know what bifunctors are
19:20:52 <Cale> Though the "Category" class is something which I haven't been able to completely classify either.
19:20:52 <tensorpudding> thanks to mac lane/awodey
19:20:56 <kmc> meaning that a value of type "a -> b" is a morphism in the category Hask
19:21:01 <tensorpudding> that's the thing that confused me
19:21:21 <tensorpudding> so an instance of Functor is a functor right?
19:21:34 <Cale> tensorpudding: It's an endofunctor Hask -> Hask
19:21:39 <tensorpudding> ah
19:21:39 <kmc> an instance of Functor is an endofun... what Cale said ;)
19:21:50 <tensorpudding> so a monad is a special kind of endofunctor?
19:21:55 <kmc> you can define a more general Functor class which takes two Categories as well
19:22:03 <tensorpudding> or does an instance of Monad not correspond to a monad?
19:22:24 <tensorpudding> ah, so endofunctors on Cat?
19:23:26 <Cale> Yeah, a monad is an endofunctor T: C -> C together with natural transformations eta: 1 -> T and mu: T^2 -> T satisfying a couple of laws
19:23:48 <Cale> (which are analogous to the monoid laws)
19:23:48 <tensorpudding> ah
19:24:16 <dcolish> i need a monoid laws tshirt
19:24:18 <tensorpudding> so a monad is a monoid over endofunctors, crazy
19:24:25 <dcolish> maybe i'll remember them then
19:24:33 <ivanm> heh
19:24:36 <tensorpudding> I have too much category theory to learn
19:24:50 <Cale> So, if you start with T^3 and you use mu T to get to T^2 and then mu to get to T, it's the same as starting from T^3, using T mu to get to T^2, and then mu to get to T
19:24:52 <kmc> the first law of monoids is: you do not talk about monoids
19:24:53 <Cale> (that's associativity)
19:25:01 <tensorpudding> someday i'll finish mac lane and learn what a Kan extension is
19:25:09 <dcolish> kmc: no thats the first rule of thermodynamics!
19:25:26 <kmc> the second law of thermodynamics is "shit happens"
19:25:29 <dcolish> lol
19:25:33 <Eduard_Munteanu> kmc, :))
19:25:46 <Cale> and there's a couple unit laws which say that if you start from T, use eta T or T eta to get to T^2, and then mu to get back to T, that's the identity
19:25:59 <tensorpudding> i am joe's irreversible processes
19:26:29 <Cale> There's a lovely way to diagram this
19:26:44 <Cale> (Wait for my blog post! :)
19:26:57 <tensorpudding> damn, more blogs to follow that I can't follow
19:26:59 <Cale> Or watch the Catsters' videos on YouTube
19:28:54 <dcolish> is there a point free way to say this: keyVal res str = (xpathQN str res) ++ " = " ++ (xpathTxt str res)
19:29:08 <kmc> @pl \res str -> (xpathQN str res) ++ " = " ++ (xpathTxt str res)
19:29:08 <lambdabot> ap (ap . ((++) .) . flip xpathQN) (((" = " ++) .) . flip xpathTxt)
19:29:21 <kmc> there isn't that nice and readable
19:29:26 <dcolish> lol
19:29:45 <dcolish> ok i'm sticking with what i got
19:29:48 <Eduard_Munteanu> Cale, there's one on Wikipedia.
19:29:53 <chessguy> Saizan_:  still waiting for wx to install
19:29:55 <chessguy> ......
19:29:58 <dcolish> i was wondering if (***) could help me
19:30:00 <Cale> Eduard_Munteanu: one what?
19:30:05 <kmc> keyVal res str = concat [xpathQN str res, " = ", xpathTxt str res]
19:30:10 <kmc> not pointfree but i think it looks a bit nicer
19:30:18 <dcolish> yes
19:30:20 <aavogt> or unwords
19:30:30 <orbisvicis> if i have "f:: a -> b -> c -> .." can i pattern match when calling it, so "f (a,b) c .." ?
19:30:32 <Eduard_Munteanu> Cale, http://en.wikipedia.org/wiki/Strong_monad
19:30:36 <aavogt> then you don't need the spaces around the =
19:30:36 <nolrai_FG> If you wanted to use termcap from haskell could you?
19:30:37 <Eduard_Munteanu> Cale, diagram regarding monads.
19:30:48 <Eduard_Munteanu> I heard Haskell's monads are in fact strong monads.
19:30:51 <kmc> orbisvicis, i don't understand the question?
19:31:02 <Cale> Oh, the diagrams I'm talking about are actually a little different.
19:31:24 <Cale> There are these nice "string diagrams" you can use to represent what's going on with a monad
19:31:50 <kmc> nolrai_FG, you can access any C library via FFI
19:31:52 <dcolish> aavogt: good call
19:32:03 <Eduard_Munteanu> Cale, what I'd like to see is some really fine explanation of hylomorphisms et al. in Haskell :)
19:32:28 <Cale> Wasn't there one of those by edwardk?
19:32:39 <aavogt> @type fmap (intercalate " = ") . sequence [?f,?g]
19:32:40 <lambdabot> forall (f :: * -> *). (?f::f [[Char]], ?g::f [[Char]], Monad f, Functor f) => f [[Char]]
19:32:44 <Eduard_Munteanu> Cale, I found one explanation on a blog, but it wasn't too descriptive.
19:33:02 <aavogt> @type sequence [(+),subtract]
19:33:03 <lambdabot> forall a. (Num a) => a -> [a -> a]
19:33:24 <aavogt> @type (intercalate " = " .) . sequence . sequence [?f,?g]
19:33:25 <lambdabot> forall (f :: * -> *) (f1 :: * -> *). (Functor f, Monad f, ?f::f1 (f [Char]), ?g::f1 (f [Char]), Monad f1, Functor f1) => f1 (f [Char])
19:33:42 <kmc> @type ?x
19:33:42 <lambdabot> forall t. (?x::t) => t
19:33:46 <orbisvicis> kmc: if (a,b) are in a tuple, I can call "let t = (a,b) in f (fst t) (snd t) c .." or can I pattern match when calling f ?
19:33:58 <chessguy> ok so now wxcore has failed to install
19:33:59 <chessguy> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4865#a4867
19:34:03 <Cale> Well, I can tell you what a hylomorphism is if you know what a catamorphism and anamorphism are.
19:34:08 <aavogt> @type (intercalate " = " .) . sequence . sequence [++,\x y -> x ++ "hai" ++ y]
19:34:09 <lambdabot> parse error on input `,'
19:34:26 <aavogt> @type (intercalate " = " .) . sequence . sequence [(++), \x y -> x ++ "hai" ++ y]
19:34:27 <lambdabot> [Char] -> [Char] -> [Char]
19:34:32 <kmc> orbisvicis, why would you write that over (f a b c)
19:34:36 <dcolish> damn transformers conflicts with mtl
19:34:48 <aavogt> > ((intercalate " = " .) . sequence . sequence [(++), \x y -> x ++ "hai" ++ y]) "one" "two"
19:34:49 <lambdabot>   "onetwo = onehaitwo"
19:34:52 <kmc> unless t is really already a tuple from far away
19:35:06 <aavogt> dcolish: ^^
19:35:12 * ivanm thinks we need a "Cale -> English" translator...
19:35:12 <ivanm> ;-)
19:35:21 <Cale> ivanm: sorry about that ;)
19:35:22 <kmc> if t is already a tuple, you can do the other way:
19:35:26 <kmc> let (a,b) = t in f a b c ...
19:35:30 <orbisvicis> kmc: just an example, but maybe more more approrpiately i should define "two :: (a,b) -> a -> b and compose them ?
19:35:36 <kmc> :t uncurry
19:35:37 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
19:35:38 <orbisvicis> f .two
19:35:39 <kmc> :t curry
19:35:40 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
19:35:49 <kmc> ^^^ those are good to know
19:35:51 <ivanm> Cale: well, maybe a "simple Cale" mode similar to the simple english wikipedia :p
19:36:01 <dcolish> aavogt: nice
19:36:02 <aavogt> haha
19:36:18 <kmc> i don't think that your "two" is going to do what you want
19:36:21 <chessguy> Saizan_: ?
19:36:23 <dcolish> is point free always preferable ?
19:36:26 <kmc> it returns a b; it doesn't provide it as an argument
19:36:34 <kmc> dcolish, no, it's often less readable
19:36:43 <aavogt> in #haskell, or in the real world?
19:36:47 <dcolish> real world
19:36:56 <dcolish> i'm going to share this code
19:37:07 <kmc> basically it is clearer to say "filter (<0)" than "filterThingsLessThanZero"... the point-free version is better than any name
19:37:09 <aavogt> well the sequence uses the (r ->) monad
19:37:12 <reltuk> why is Network.listen binding ipv6 localhost and not ipv4 addresses on my vista machine?
19:37:12 <kmc> but in more complicated cases, you want a name
19:37:31 <chessguy> any ideas on my wxcore install issue? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4865#a4867
19:38:12 <aavogt> conceptually it is nice because you're applying an arbitrary number of functions to two arguments, and separating the results with " = ", but on second thought that's probably not a common kind of output
19:38:21 <chessguy> what is this stuff about profiling packages for ByteString?
19:38:23 <Cale> ivanm: Is there anything in particular you'd like explained?
19:38:30 <aavogt> ie. x = y = z isn't something people do often
19:38:35 <aavogt> except in math sometimes
19:38:38 <dcolish> right
19:38:48 <Eduard_Munteanu> Cale, yeah, I meant a better material on anamorphisms, catamorphisms etc.. I wanted to know what those intermediate transformations mean.
19:40:29 <Cale> Eduard_Munteanu: hmm, yeah, it would be nice if there were more. Usually for those two, you end up learning from someone else randomly :)
19:40:31 <aavogt> dcolish: if you leave arguments out, it's probably a good idea to include a type signature so people can figure out how to use the functions ;)
19:41:01 <dcolish> i've been getting in the habit of writing type signatures
19:41:13 <dcolish> its really helpful when i pick up the code again
19:41:41 <Cale> Eduard_Munteanu: roughly, an anamorphism is something which starts from some "seed" value and builds up a datastructure by applying a function recursively that selects which constructor to use, along with providing seeds for the places in which the type is recursive
19:41:43 <ivanm> Cale: nah, I was referring to in general ;-)
19:42:24 <Cale> Eduard_Munteanu: and a catamorphism is a function which replaces each constructor throughout a datastructure with another function or value of an appropriate type
19:42:34 <Cale> So, unfold and fold, basically :)
19:42:58 <Cale> A hylomorphism is what you get when you use an anamorphism and immediately follow it with a catamorphism.
19:43:40 <Eduard_Munteanu> Cale, yeah, what I had trouble with is that representation ana = f . g . h, I wanted to know what they meant.
19:43:41 <aavogt> para- poly- ?
19:43:52 <aavogt> ;)
19:44:05 <kmc> dcolish, yup, type signatures are machine-checkable documentation
19:44:14 <kmc> they're like comments that can't be incorrect
19:45:03 <Cale> aavogt: polymorphism is something completely different
19:45:04 <dcolish> too bad it spoils me when i have to write C and python
19:45:25 <Cale> a paramorphism is a variation of a catamorphism, and I don't remember the details
19:45:27 <aavogt> Cale: I guess they ran out of suffixes
19:46:16 <Eduard_Munteanu> Cale, that was what I read... http://ulissesaraujo.wordpress.com/2009/04/08/anamorphisms-in-haskell/
19:46:18 <chessguy> is there a better place to ask about my wxcore install issues?
19:46:42 <dcolish> am i daft or is there no cabal uninstall comand?
19:47:03 <sohum> I've gotten into the habit of adding type signatures in comments in other languages, actually. they're /really/ useful.
19:47:23 <sohum> dcolish: I believe the closest you'll get is ghc-pkg unregister
19:47:35 <copumpkin> but that doesn't remove the files
19:47:36 <Eduard_Munteanu> chessguy, wxWidgets?
19:47:41 <sohum> no, it doesn't.
19:47:43 <aavogt> well types can be wrong if you use 'type' to specify that say type X = Double, type Y = Double, type Point = (X,Y), when you algorithm/output actually assumes that you have  Point = (Y,X)
19:47:58 <chessguy> Eduard_Munteanu:  wxhaskell
19:48:02 <sohum> aavogt: not if you newtype!
19:48:07 <sohum> :P
19:48:18 <dcolish> well i really just want to unregister i guess
19:48:29 <aavogt> sohum: I suppose you could still use the X and Y newtypes wrongly
19:48:42 <chessguy> Eduard_Munteanu:  check out the error: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=4865#a4867
19:48:45 <dcolish> somehow i installed transformer-0.1.4.0 on my box
19:49:19 <sohum> aavogt: I suppos.e
19:49:25 <jmcarthur> dcolish: ghc-pkg unregister transformer
19:49:28 <dcolish> but that severly conflicts with mtl-1.1.0.2
19:49:39 <dcolish> i just hope that doesnt break something else
19:50:10 <aavogt> ghc-pkg hide transformer is probably better
19:50:16 <dcolish> ok cool
19:50:22 <aavogt> but isn't it called transformers?
19:50:34 <dcolish> yes
19:50:37 <aavogt> .oO(or has that name not been taken yet?)
19:50:38 <jmcarthur> i think dcolish typoed
19:50:56 <Eduard_Munteanu> chessguy, dunno, I haven't tried installing it yet.
19:51:14 <jmcarthur> · ∘ O
19:53:31 <Saizan_> chessguy: the last one can be fixed with cabal install bytestring --reinstall -p
19:53:50 <chessguy> Saizan_:  oh really? why's that?
19:54:09 <Saizan_> chessguy: cabal doesn't install the profiling version by default
19:54:35 <chessguy> why would other packages require it then?
19:54:53 <jmcarthur> ghc flags set in the cabal file?
19:55:08 <sohum> aavogt: but yeah, in general, the more dynamism you put in your types the more likely the type won't be an automatic correctness implier
19:55:09 <Saizan_> wxcore has a custom build script, it probably always tries to install its profiling version
19:58:06 <chessguy> sheesh
20:05:20 <dcolish> what is a simple example of using (***) ?
20:05:58 <roconnor> > (length, succ) (***) ("dcolish", 7)
20:06:00 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t'
20:06:00 <lambdabot>         against inferred type ...
20:06:04 <roconnor> @type (***)
20:06:05 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
20:06:27 <roconnor> > (length *** succ) ("dcolish", 7)
20:06:28 <lambdabot>   (7,8)
20:07:01 <roconnor> > (length *** succ) ("dcolish", 12)
20:07:02 <lambdabot>   (7,13)
20:07:26 <dcolish> hmm ok that is cool
20:10:22 <disgrntld> Err, does anyone know why I can't import Data.List? I put, "import Data.List" in a file, test.hs, which I load in hugs with ":l test.hs". It tells me: ERROR "Data.List" - Unable to open file "Data.List".. Gotta be something stupid I'm doing
20:10:37 <ivanm> does hugs come with Data.List?
20:10:41 <ivanm> disgrntld: try just List
20:10:59 <disgrntld> *blush*
20:11:04 <disgrntld> ok, that worked.. thanks ivanm
20:11:23 <ivanm> disgrntld: if you can, dump hugs and use ghci
20:11:31 <ivanm> (which comes with ghc)
20:11:51 <aavogt> perhaps it does have Data.List if you disable it being haskell-98 compatible?
20:12:03 <ivanm> aavogt: *shrug* never used hugs
20:12:03 <aavogt> the flag being -98 or something
20:12:06 <dmead> :t (***)
20:12:07 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
20:12:10 <disgrntld> kk, I have ghci, I'll give it a do
20:12:16 <disgrntld> go*
20:12:25 <disgrntld> hmm, lemme try that aavogt
20:13:52 <aavogt> ivanm: yeah it's funny how there are still echoes from the time that hugs had better error messages than ghc (I think this can be found in YAHT), when this is no longer the case (or I'm just used to ghc's messages)
20:14:08 <disgrntld> Data.List still didn't work with "hugs -98", though I didn't see a "-98" flag in the man page
20:14:17 <ivanm> aavogt: heh
20:14:34 <ivanm> I seem to recall seeing things about hugs having awful incomprehensible error messages...
20:17:43 <aavogt> disgrntld: I've just tried it, and hugs likes if you write import Data.List in a file and load that one up, but  :module Data.List, or even :module List isn't accepted
20:17:53 <dibblego> liftM is not in Prelude?
20:18:04 <aavogt> dibblego: use fmap
20:18:12 <aavogt> which is
20:18:13 <dibblego> I want liftM2 without the import, for a code sample
20:18:56 <aavogt> then you'll have to include the definition of liftM2 in your code sample
20:19:06 <dibblego> I'll undo it I think, ta
20:19:47 <ivanm> @. undo src liftM2
20:19:48 <lambdabot> ()
20:19:54 <ivanm> :o
20:19:58 <ivanm> @src liftM2
20:19:58 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
20:20:21 <ivanm> @undo  do { x1 <- m1; x2 <- m2; return (f x1 x2) }
20:20:21 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
20:20:35 <reltuk> how does one use Network.Socket socket/bindSocket/listen?
20:20:44 <ivanm> @hoogle socket
20:20:45 <reltuk> I'm confused by the fact that bindSocket doesn't return IO Socket
20:20:45 <lambdabot> Network.Socket socket :: Family -> SocketType -> ProtocolNumber -> IO Socket
20:20:45 <lambdabot> module Network.Socket
20:20:45 <lambdabot> Network data Socket
20:20:46 <disgrntld> aavogt: that's weird, I had exactly that (import Data.List) and hugs gave the error, version is November 2002 (lol, I'm ssh'ed into my universities machine)
20:21:29 <aavogt> I have the newest hugs: September 2006
20:21:50 <disgrntld> well I guess I can't complain, heh
20:21:52 <ivanm> isn't it that sad that the "newest" hugs is that old? :(
20:22:10 <ivanm> (for something that is still relatively well used)
20:22:49 <aavogt> you'd think that somebody at one of the schools who teach haskell would pick up hugs development
20:22:56 <aavogt> but I guess it isn't an easy thing to do
20:23:54 <leimy> What's a good way to say "potentially many lines of text that don't begin with Y" in parsec?
20:24:03 <leimy> I'm trying to ignore a bunch of lines between meaningful ones.
20:24:11 <leimy> and for some reason, I can't seem to get it right
20:24:12 <ivanm> is the file size the only real reason not to use ghc[i]?
20:24:20 <leimy> also... "many anyChar" is a bad idea :-)
20:24:40 <aavogt> leimy: you can first separate your tokens into lines?
20:25:08 <leimy> aavogt: I've got my tokens in blocks :-)
20:25:26 <leimy> I guess I could do "lines"
20:25:29 <aavogt> then say  many (satisfy ((/=Just "Y") . listToMaybe))
20:26:01 <aavogt> of course the other step is to define exactly what a line is
20:26:06 <leimy> but the context of a block is one line in the block, and the value comes a variable number of lines later... so the whole block should be consumed as a whole really.. or it's most convenient :-)
20:30:02 <leimy> looks like i could use "manyTill (many alphaNum >> eol) (string "the string I want to stop skipping at")
20:31:56 <leimy> I'm aching for a pre-made character class that's all the printable ASCII characters
20:32:00 <leimy> I guess I can make one :-)
20:33:49 * copumpkin 's agda adventures go on!
20:34:17 <copumpkin> I should really work on things that I need to do rather than this videogame-like endeavor
20:34:43 <mmorrow> Copumpkin Jones and the Dependently-Typed Vectors of Dooom!
20:34:48 <copumpkin> lol
20:35:02 <copumpkin> no vectors right now
20:35:08 <copumpkin> working on regular languages in agda
20:35:17 <mmorrow> watch out for that one guy that tries to rip your heart out with his bare hand
20:35:31 <copumpkin> :O
20:35:32 <copumpkin> oh no
20:36:15 <mmorrow> copumpkin: are you using the emacs interface?
20:36:19 <copumpkin> yeah
20:36:25 <copumpkin> only thing I use emacs for :)
20:36:45 <mmorrow> heh, yeah. is the repl bitrotted?
20:36:51 <copumpkin> yeah
20:36:59 <copumpkin> besides, having a GUI is nice
20:36:59 <mmorrow> i've only used the repl
20:37:15 <mmorrow> well, and compiled code too
20:37:16 <copumpkin> having holes and being able to click on them and ask it what the goal is and context is
20:37:27 <copumpkin> ah, I rarely actually run this stuff
20:38:04 <mmorrow> here's my agda ByteString module! http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=584
20:38:05 <dcolish> has anyone else noticed the haskell-vim interface crashing often?
20:38:13 <dcolish> its only very recently
20:38:33 <copumpkin> mmorrow: oh nice :P what'd you use it for?
20:38:45 <kmc> copumpkin, the solution is an MMORPG
20:38:47 <kmc> World of Agda
20:38:48 <roconnor> copumpkin: once the code type checks there is no need to run it
20:38:56 <copumpkin> roconnor: exactly! :P
20:38:56 <mmorrow> copumpkin: printing "asdf" !
20:38:57 <roconnor> you already know what it will do
20:39:34 <copumpkin> mmorrow: did you prove anything interesting with agda when you were playing with it?
20:39:53 <copumpkin> I'm always looking for good things to prove that aren't too involved
20:39:57 <mmorrow> copumpkin: the real reason i did that was to explore how useful it would be as an actual programming language, e.g. to write an echo server
20:40:01 <kmc> pumping lemma?
20:40:09 <copumpkin> kmc: that's what I'm working towards right now
20:40:12 <mmorrow> copumpkin: i never took it beyond getting printing abilities
20:40:17 <copumpkin> mmorrow: ah
20:40:32 <copumpkin> it's seriously addictive
20:40:38 <kmc> it would be badass to teach an into Theory of Computation course where students submit proofs in Agda
20:40:40 <copumpkin> like a big puzzle
20:40:47 <mmorrow> copumpkin: not really, although i read over most of the source code
20:40:57 <copumpkin> kmc: yeah :) that would be awesome
20:41:10 <mmorrow> copumpkin: (@prove anything interesting?)
20:41:15 <kmc> when you prove that 3-coloring a graph is NP-complete i definitely want to see that :)
20:41:26 <mmorrow> copumpkin: which was interesting
20:41:28 <copumpkin> looking back at when I took ToC, a lot of the proofs I wrote were constructive
20:41:45 <copumpkin> hah, no np-completeness proofs yet ;)
20:41:56 <copumpkin> although reductions seem very constructive
20:42:00 <kmc> yeah
20:42:12 <copumpkin> mmorrow: for the standard library?
20:42:22 <copumpkin> mmorrow: or the typechecker etc.?
20:42:26 <mmorrow> copumpkin: for the compiler/etc
20:42:27 <mmorrow> yeah
20:42:28 <copumpkin> ah
20:42:40 <mmorrow> well, the (agda) libs too
20:42:52 <mmorrow> but very quick gloss-over
20:42:53 <copumpkin> I want an agdabot! :P
20:43:02 <mmorrow> heh, it'd be doable for sure
20:43:05 <copumpkin> :)
20:43:08 <mmorrow> hmm
20:43:20 <copumpkin> some of it is pretty resource-intensive though
20:43:40 <aavogt> but isn't agda not-turing complete in some mode?
20:43:45 <copumpkin> yep
20:43:49 <aavogt> ie. it finishes in a finite time?
20:43:53 <copumpkin> turing completeness is overrated ;)
20:44:06 <mmorrow> aavogt: you don't have to enable the termination checker if you don't want
20:44:17 <copumpkin> it just marks code it can't prove terminates in pink
20:44:17 <mmorrow> aavogt: it's separate from the type system
20:44:18 <aavogt> I mean for an irc bot
20:44:22 <aavogt> ah
20:44:26 <copumpkin> aavogt: oh, the bot would be in haskell
20:44:29 <copumpkin> since agda is just a library
20:44:49 <aavogt> I doubt many people know agda
20:45:01 <copumpkin> I'd be inclined to agree with you :)
20:45:09 <kmc> i don't think you can do much in single expressions like we do with lambdabot
20:45:22 <copumpkin> kmc: yeah, it would need state
20:45:24 <aavogt> the whole emacs thing kind of put me off, and then they go and explain how complicated it is to write function composition...
20:45:51 <copumpkin> aavogt: the emacs isn't that bad... I'm not usually a fan but it's pretty good for this. Function composition isn't that hard, really
20:46:05 <aavogt> @src (.)
20:46:05 <lambdabot> (f . g) x = f (g x)
20:46:09 <kmc> is anyone here a grad student at chalmers?
20:46:21 <copumpkin> aavogt: it's the same in agda :) just the type is a bit more involved if you want full generality
20:46:23 <mmorrow> wut do you mean function composition is hard?
20:46:26 <mmorrow> main = (putStrLn ∘ pack ∘ C.fromList ∘ map c2w ∘ toList) "asdf"
20:46:29 <mmorrow> ?
20:46:30 <aavogt> copumpkin: the type though
20:46:32 <aavogt> yeah
20:47:06 <copumpkin> well, it's more powerful than haskell composition
20:47:21 <copumpkin> you can write haskell-like composition just as easily
20:47:32 <copumpkin> but you probably want the more general form
20:48:11 <mmorrow> well, you get to use the functions to compute the type of the result as well, which is neat
20:48:21 <copumpkin> yeah, exactly
20:49:34 <copumpkin> aavogt:
20:49:35 <copumpkin> _∙_ : ∀ {a b c : Set} → (b → c) → (a → b) → (a → c) (f ∙ g) x = f (g x)
20:49:41 <copumpkin> whoops, there was a newline in there
20:49:45 <copumpkin> that typechecks just fine
20:50:17 <aavogt> but at that point you might as well be writing haskell for all the dependent type benefits you get?
20:50:25 <aavogt> rather, lack thereof
20:50:41 <copumpkin> for that particular function, yeah
20:51:06 <mmorrow> aavogt: well, any function where you don't make use of the dependent-types just degenerates to the haskell-equiv basically
20:51:15 <copumpkin> or less, even
20:51:23 <mmorrow> module polymorphism
20:51:26 <mmorrow> *modulo
20:51:36 <copumpkin> yep, no typeclasses
20:51:44 <copumpkin> parametrized modules are nice though :)
20:51:44 <mmorrow> ah right, that too
20:52:09 <mmorrow> a cayenne evalbot would cool too
20:52:31 <copumpkin> I'm having trouble writing an enumerator for kleene star
20:57:04 <reltuk> anyone want to take a look at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11964 and tell me why it's not listening and not bound on the port I think it should be =/
20:58:15 <kmc> reltuk, did you strace the binary?
20:59:09 <reltuk> no...this is on a windows boxand I don't have many dev tools...
20:59:15 <kmc> ouch
20:59:51 <kmc> iirc windows has some magic "make sockets work" function you have to call before sockets will work
21:00:32 <reltuk> yeah, I thiknk I did that...
21:00:52 <reltuk> withSocketsDo or some such...I'll try it on one of my bsd boxes and see what happens
21:00:53 <dnm_> Re: "I don't have many dev tools...": is this because you can't install them, or just don't have them handy or know what would be best to help inspect the system? If it's the latter, I may be able to help.
21:00:59 <dcolish> is there a quick list of the cabal Licenses recognized?
21:01:39 <dcolish> oh i found it
21:02:26 <binrapt> Is there a syntax highlighting library for Haskell which supports tons of different programming languages?
21:02:56 <binrapt> I intend to write some kind of fast CGI pastebin with syntax highlighting as my hello world in Haskell :(
21:03:11 <binrapt> I saw this kate one on Google
21:03:47 <mmorrow_> reltuk: also, you know that "putStrLn $ "Accepting connection from " ++ (show socket) ++ " on port " ++ (show sn);" will always print the same thing, right?
21:04:10 <mmorrow_> reltuk: did you mean to be doing that on `newS' rather than `socket' ?
21:05:11 <mmorrow_> binrapt: you might find the code the hpaste2 interesting
21:05:36 <mmorrow_> binrapt: it uses fastcgi and an sqlite db (happens to use takusen as its db library)
21:05:45 <binrapt> :O
21:06:26 <reltuk> mmorrow_: yeah, it was debugging for accepting the connection...which doesn't appear to work =/
21:06:44 <binrapt> Does it use highlighting-kate?
21:07:33 <mmorrow> reltuk: was just making sure you weren't basing that it isn't working on the output of that line
21:08:09 <mmorrow> reltuk: since that would tell you what addr/port you're /listening/ on i believe
21:08:55 <mmorrow> binrapt: it uses the python lib <i don't recall the name> via an FFI binding
21:09:00 <mmorrow> binrapt: it's quite good
21:09:03 <mmorrow> oh, pygments
21:09:29 <binrapt> Ouch, FFI is pretty brutal for a newbie I think
21:09:51 <mmorrow> if code.haskell.org wasn't down i'd give you the link to the git repo
21:10:05 <mmorrow> aha, it's up
21:10:06 <ivanm> bos31337: so you're now showing off your 1337-ness to the world? :p
21:10:15 <dcolish> grr cabal
21:10:17 <mmorrow> http://code.haskell.org/hpaste.git/
21:10:29 <Cale> binrapt: But... you don't have to understand how highlighting-kate works to use it
21:10:33 <mmorrow> binrapt: i just mean you might find the code interesting to read
21:10:49 <bos31337> ivanm: i've been 31337 since before you ate solid food, kid.
21:10:52 <mmorrow> binrapt: since hpaste2 is a (fast)cgi online pastebin too
21:10:58 <ivanm> heh
21:11:04 <Cale> three-leetness
21:11:20 <bos31337> Cale: it generalises to N-leetness.
21:11:22 <mmorrow> thr33l33t
21:11:26 <ivanm> I know enough to know that anything using highlighting-kate doesn't work on gentoo because of the stupid linking scripts :@
21:11:41 <copumpkin> :O
21:11:45 <Cale> bos31337: ahaha
21:12:04 <mmorrow> ivanm: you mean in ghci? you can just make a symlink (yes, this solution is bootleg)
21:12:24 <ivanm> mmorrow: well, not just... using pandoc with highlighting-kate support fails
21:12:33 <ivanm> though I think that's because of TH, which is ghci
21:12:36 <mmorrow> ivanm: in compiled code?
21:12:43 * bos31337 ponders the final coalgebra of N-leet arrows
21:12:52 <ivanm> mmorrow: yup
21:12:54 <ivanm> it won't compile
21:12:56 <mmorrow> ivanm: just make a symlink to any libs ghci might need to load
21:12:57 <ivanm> because of libpcre
21:12:59 <dolio> (∞,1)-leetness
21:13:04 <Gracenotes> hm. if GHC uses eval/apply instead of enter/push, to what extent is its STG really spineless? -.-
21:13:13 <ivanm> mmorrow: yeah, we can do that... but it's not possible to do it in a pkg-management side of things :s
21:13:15 <binrapt> mmorrow no worries, I already cloned it, looking at the code right now
21:13:38 <binrapt> Cale oh does highlighting-kate use an FFI too?
21:13:44 <mmorrow> ivanm: right, but *you* can do that and get pandoc+highlighting-kate built
21:13:49 <Gracenotes> dolio: your leetness is an empty interval?
21:13:59 <ivanm> mmorrow: yes, but I also help with pkg management ;-)
21:14:08 <mmorrow> binrapt: apparently someone is using libpcre along the line somewhere
21:14:18 <Cale> binrapt: yeah, it's a binding to the library which does highlighting for the kate text editor
21:14:30 <dolio> Gracenotes: http://golem.ph.utexas.edu/category/2009/10/associativity_data_in_an_1cate.html
21:14:36 <binrapt> Cale ah ok
21:14:47 <ivanm> mmorrow: highlighting-kate uses pcre-light IIRC
21:14:48 <Cale> It uses FFI internally, but you don't have to care about that :)
21:15:01 <Gracenotes> oh. darn parentheses and their ad-hoc polymorphism
21:15:06 <binrapt> FFI is impure, right? Requires complicated monads and all?
21:15:12 <mmorrow> ivanm: Shouldn't be that Hard(tm) to add http://darcs.haskell.org/ghc/rts/Linker.c
21:15:14 <ivanm> Gracenotes: ?
21:15:16 <Cale> binrapt: just IO
21:15:36 <Cale> binrapt: You don't need to know anything about monads if you're only using one monad :)
21:15:51 <EvanCarroll> how come something like "let x x | x > 5 = "foo" | x < 5 = "bar" | otherwise = "baz" where a = (x 10)" won't compile?
21:15:57 <dolio> Yeah. We should write mathematics in s-expressions, like Sussman suggested.
21:16:03 <Gracenotes> ivanm: ambiguous
21:16:14 <Cale> EvanCarroll: because you gave both the function parameters the same name
21:16:25 <ivanm> how do parentheses provide ad-hoc polymorphism that is ambiguous?
21:16:36 <EvanCarroll> yes
21:16:42 <ivanm> (how do they provide ad-hoc polymorphism to start with?)
21:16:42 <EvanCarroll> that should have been obvious
21:17:16 <EvanCarroll> =( I'm trying to recite everything i saw today i thought was interesting
21:17:19 <dcolish> is there a shortcut to give me alist of dependencies for writing a .cabal?
21:17:20 <Cale> Er, oh
21:17:26 <dolio> ivanm: They might denote an ordered pair or an open interval.
21:17:31 <dolio> Or something else.
21:17:35 <Cale> No, it's worse than that, you gave the function the same name as its parameter
21:17:41 <Gracenotes> it is polymorphic by merit of being polysemic: many meanings. these meanings are ad-hoc: mathematicians add them as they see fit, but there is a finite set of them out there, somewhere :)
21:17:41 <ivanm> dcolish: try to do "cabal install", and see what it complains about ;-)
21:17:53 <mmorrow> let x x x x x = x x (x x x) in x
21:17:56 <dcolish> well this isnt in cabal yet
21:17:57 <ivanm> dolio: in what context?
21:18:03 <dolio> Mathematics.
21:18:05 <dcolish> its on my system only
21:18:19 <ivanm> dcolish: Write the cabal file with no build-depends
21:18:26 <ivanm> then try doing "cabal install" to it
21:18:30 <ivanm> it wil complain about a package
21:18:31 <ivanm> add it
21:18:40 <ivanm> repeat until it stops complaining
21:18:48 <ivanm> dolio: oh, I thought Gracenotes was talking about haskell :s
21:19:06 <dcolish> ivanm: heh ok
21:20:25 <Gracenotes> ooooh... the G in G-machine stands for 'graph'. did not know that.
21:21:17 <dolio> Doesn't it always?
21:21:22 <dolio> Graph machine. Graph string.
21:21:25 <dolio> Graph spot.
21:21:29 <ivanm> mmorrow: what did you mean for me to add that Linker.c file?
21:21:34 <copumpkin> lol
21:21:35 <ivanm> heh
21:21:55 <copumpkin> Gräfenberg?
21:23:12 <mmorrow> ivanm: the problem here is that Linker.c doesn't have code to recognize and parse the most basic two or three linker script commands
21:23:23 <Gracenotes> @vixen Have you parsed any interesting graph strings lately?
21:23:24 <lambdabot> let's don't talk about that
21:23:32 <mmorrow> so it tries to load e.g.
21:23:40 <dcolish> why would a file segfault when build using ghc --make, but not when run with runghc?
21:23:47 <dcolish> s/file/program/
21:23:52 <mmorrow> OUTPUT_FORMAT(elf64-x86-64)
21:23:52 <mmorrow> GROUP ( /lib64/libpthread.so.0 /usr/lib64/libpthread_nonshared.a )
21:23:55 <mmorrow> as a .so
21:24:26 <mmorrow> while it needs to go "oh, this clearly isn't an elf file, aha i should look for /lib64/libpthread.so.0"
21:24:32 <roconnor> dcolish: optimization
21:24:48 <dcolish> hmm, ok how do i prevent that then?
21:24:55 <roconnor> ghc --make -o0
21:25:29 <mmorrow> ivanm: so it actually would be super easy to add to Linker.c, it's just that no one has stepped up and done it
21:25:36 <ivanm> heh
21:25:43 <dcolish> roconnor: that didnt help
21:25:57 <roconnor> hmm
21:26:11 <roconnor> perhaps you are not running the same thing you are compiling
21:26:17 <ivanm> mmorrow: thing is, according to the dlopen page, you're meant to be able to call it on the foo.so; if you try it with things like libpcre that have linking scripts here on gentoo that fails
21:26:20 <roconnor> though that seems difficult to believe
21:26:44 <ivanm> but apparently that's the correct behaviour because you're assuming a given ABI :@
21:26:51 <dcolish> i'm pretty sure its the right program
21:27:12 <roconnor> dcolish: strange
21:27:33 <roconnor> dcolish: that's the only idea I had.  I had this problem once, but I was using a lot of unsafeCoerce.
21:27:59 <dcolish> i am using HsLua which does a lot of FFI stuff
21:28:27 <roconnor> perhaps someone more familiar with HsLua will know
21:29:03 <dcolish> how can i compile with debugging symbols?
21:29:26 <ivanm> mmorrow: I might have considered trying to hack a solution into Linker.c, but I have just enough C knowledge to be able to get myself into trouble :s
21:32:09 <mmorrow> ivanm: i'm trying to find where in Linker.c it'd need to identify a linker script..
21:36:03 <mmorrow> ivanm: so there's an `addDLL' function for .so's, but i guess what must be happening is that you always go through
21:36:07 <mmorrow> HsInt loadObj( char *path )
21:36:28 <mmorrow> as the pain entrypoint, which will read the file, and try to verify it as an ELF
21:36:37 <mmorrow> (or mach-o or PE, depending on your platform)
21:37:00 <mmorrow> and it's here where it barfs trying to verify that the txt linker script is an elf
21:37:36 <mmorrow> so it doesn't base the dlopen()-ness on the extension i guess
21:38:38 <mmorrow> if it's not that, then it's probably something similar
21:38:59 <mmorrow> since Linker.c is clearly trying to treat the *.so as an elf file before it calls dlopen() on it
21:39:32 <mmorrow> s/elf/mach-o/ is you're on osx
21:39:35 <mmorrow> s/is/if/
21:42:30 <mmorrow> i can't remember the error message this causes to search for it though
21:42:32 <mmorrow> something like
21:42:46 <mmorrow> "... is too short ..."
21:43:00 <dcolish> i cant figure this out for the life of me
21:44:46 <reltuk> the docs to STM TVars mention newTVarIO being able to be used in top level values created with unsfaePerformIO...is this a recommended pattern?
21:45:17 <copumpkin> well, you generally want to avoid globals in general
21:45:27 <copumpkin> generally + in general
21:45:30 <copumpkin> I'm eloquent tonight
21:45:39 <mmorrow> reltuk: that's why newTVarIO exists, but whether it's the recommended pattern is another matter
21:45:55 <aavogt> elucidate the source of copumpkin's eloquence
21:46:49 <mmorrow> reltuk: if it's possible-without-extreme-amount-of-effort to avoid the global, that's recommended, but otherwise do it
21:48:54 <reltuk> and to avoid globals you just thread it through/put everything into some monadic context where it's available?
21:49:27 <roconnor> readerT <envContaintingYourTVar> IO is potentially good for this
21:49:28 <dcolish> well its definitely HsLua
21:50:02 <mmorrow> reltuk: right
21:50:45 <mmorrow> reltuk: or to not use a monad and pass everything explicitly
21:51:02 <mmorrow> well, you're already in IO, but i mean as opposed to (ReaderT IO)
21:51:08 <mmorrow> well, you're already in IO, but i mean as opposed to (ReaderT env IO)
21:51:09 <roconnor> in GHC there is also the implicit argument possiblity ....
21:51:19 <copumpkin> eugh
21:51:29 <roconnor> I feel dirty for even bringing it up
21:51:30 <reltuk> what's implicit argument?
21:51:41 <reltuk> lol, maybe I don't want to know :^p
21:51:52 <Axman6> sounds likely
21:51:55 <mmorrow> , (\x -> (?f x, x))
21:51:56 <lunabot>  luna: Unbound implicit parameter (?f::t1 -> t)
21:52:02 <mmorrow> , (\x -> (?f x, x)) 42
21:52:03 <lunabot>  luna: Unbound implicit parameter (?f::t1 -> t)
21:52:11 <mmorrow> , let ?f = (*2) in  (\x -> (?f x, x)) 42
21:52:13 <lunabot>  (84,42)
21:52:48 <mmorrow> main = do tvar <- newTVarIO 42; let ?theTVar = tvar; theRestOfMyProgram
21:52:48 <roconnor> mmorrow: I don't think that example quite illustrates implicit arguments
21:53:02 <mmorrow> that however does
21:53:33 <reltuk> lol
21:54:06 <mmorrow> reltuk: so then, in anything reachable from the "theRestOfMyProgram" function, you can use ?theTVar to refer to that TVar
21:54:06 <reltuk> is it dynamically scoped?
21:54:10 <mmorrow> kind of
21:54:12 <roconnor> , let g x = (?f x,x) in let ?f = (*2) in g 42
21:54:14 <lunabot>  (84,42)
21:54:22 <roconnor> that illustrates it
21:54:38 <reltuk> that's definitely not better than a global ;-)
21:54:53 <roconnor> well, half better
21:55:00 <aavogt> , let ?f = 1 in let ?f = ?f + 1 in ?f
21:55:01 <lunabot>  2
21:55:03 <mmorrow> reltuk: the difference is that all implicit params are tracked in the type, just like type class contexts
21:55:14 <mmorrow> @type (\x -> (?f x, x)
21:55:15 <lambdabot> parse error (possibly incorrect indentation)
21:55:15 <mmorrow> @type (\x -> (?f x, x))
21:55:16 <roconnor> I don't know how variable name shadowing works with implicit arguments
21:55:17 <lambdabot> forall t t1. (?f::t1 -> t) => t1 -> (t, t1)
21:55:32 <aavogt> , let ?f = 1 in let ?f = ?f + 1 in let ?f = "hai" in ?f
21:55:33 <lunabot>  "hai"
21:55:34 <roconnor> it seems likely to be unhygenic
21:55:45 <mmorrow> i've got a paste somewhere that iirc completely classifies the behavior of implicit params in four examples
21:55:47 <reltuk> oh, interesting
21:55:49 * mmorrow tries to find it
21:55:50 <aavogt> , let ?f = 1 in let ?f = ?f + 1 in (let ?f = "hai" in ?f, ?f)
21:55:51 <lunabot>  ("hai",2)
21:56:28 <aavogt> there's some nasty example of implicit params being weird in the ghc manual
21:56:37 <roconnor> reltuk: just include a GUID in your implicit variable name
21:59:17 <mmorrow> gah, i can't find it
21:59:35 <mmorrow> this shows how they use essentially the same mechanism as typeclasses though http://hpaste.org/fastcgi/hpaste.fcgi/view?id=7512
21:59:56 <roconnor> , let ?f = (*3) in let g x = (?f x,x) in let ?f = (*2) in g 42
21:59:57 <lunabot>  (84,42)
22:00:06 <mmorrow> you can also capture then in an existential box like you can with typeclasses
22:00:48 <aavogt> and they let you define an irregularEq
22:00:58 <mmorrow> , let go x = ?f x : let ?f = ?f . ?f in go x in let ?f = (*2) in go 2
22:00:59 <lunabot>  [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
22:01:52 <mmorrow> so `go' can't override ?f within itself for a recursive call
22:02:14 <aavogt> > iterate (*2) 2
22:02:14 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
22:02:19 <mmorrow> , let go x = ?f x : let ?f = (*4) in go x in let ?f = (*2) in go 2
22:02:20 <lunabot>  [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
22:02:34 <roconnor> thankfully reltuk is unlikely to want to do any of this crazy stuff
22:03:20 <roconnor> It should be a compile error to define ?f in more than one spotin in the entire program
22:03:23 <roconnor> :)
22:04:33 <ivanm> mmorrow: *nod*
22:04:35 <aavogt> , let f = let ?x = ?x + 1 in ?x : g; g = let ?x = ?x + 2 in ?x : f in f
22:04:37 <lunabot>  luna: Unbound implicit parameter (?x::a)
22:04:44 <mmorrow> well, you might have different ?f's for different sub-parts of the program
22:04:45 <aavogt> , let f = let ?x = ?x + 1 in ?x : g; g = let ?x = ?x + 2 in ?x : f in let ?x = 1 in f
22:04:46 <lunabot>  luna: Unbound implicit parameter (?x::a)
22:04:57 <roconnor> mmorrow: no no
22:05:05 <mmorrow> aavogt: let ?x isn't recursive
22:05:27 <mmorrow> roconnor: that's part of the purpose of them..
22:05:33 <roconnor> nah
22:05:39 <mmorrow> yuhuh
22:05:40 <aavogt> well you can do the same for Reader
22:05:41 <roconnor> the purpose is to avoid the global state hack
22:05:44 <roconnor> :)
22:06:06 <mmorrow> roconnor: by introducing a mechanism with even more complicated semantics, yay!
22:06:13 <roconnor> :D
22:06:13 <mmorrow> :)
22:06:21 <aavogt> , let ?x = 1 in let f = let ?x = ?x + 1 in ?x : g; g = let ?x = ?x + 2 in ?x : f in f
22:06:22 <lunabot>  [2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,...
22:06:55 <aavogt> so let ?x = blah is the same as local
22:06:57 <aavogt> @type local
22:06:58 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
22:08:00 <mmorrow> , let go x = let ?f = (*2) in ?f x; let y = let ?f = (*1000) in go 2 in let ?f = negate in y
22:08:01 <lunabot>  luna: parse error on input `)'
22:08:32 <mmorrow> , let go x = let ?f = (*2) in ?f x; y = let ?f = (*1000) in go 2 in let ?f = negate in y
22:08:33 <lunabot>  4
22:08:41 <copumpkin> preflex: seen edwardk
22:08:42 <preflex>  edwardk was last seen on ##logic 6 days, 10 hours, 48 minutes and 7 seconds ago, saying:  /j #lock-free
22:08:43 <mmorrow> , let go x = ?f x; y = let ?f = (*1000) in go 2 in let ?f = negate in y
22:08:44 <lunabot>  2000
22:09:14 <mmorrow> , let go x = ?f x; ?f = (*1000); let y = go 2 in let ?f = negate in y
22:09:15 <lunabot>  luna: Parse error in pattern
22:09:22 <mmorrow> , let go x = ?f x; ?f = (*1000); y = go 2 in let ?f = negate in y
22:09:23 <lunabot>  luna: Parse error in pattern
22:09:26 <mmorrow> gah
22:09:51 <mmorrow> oh right, you let for implicit params is separate from regular let
22:10:01 <ski> (mmorrow : yes, generally side-effectful mechanisms are more complicated than pure ones)
22:10:10 <aavogt> I think that's for the sanity of ordering
22:10:17 <mmorrow> , let go x = ?f x; y = go 2; x = let ?f = (*1000) in y in let ?f = negate in (y,x)
22:10:18 <lunabot>  luna: Unbound implicit parameter (?f::t -> t1)
22:10:38 <aavogt> otherwise which ?x do you refer to in the other let-bound variables?
22:10:40 <mmorrow> , let go x = ?f x; y = go 2; z = let ?f = (*1000) in y in let ?f = negate in (y,z)
22:10:41 <lunabot>  luna: Unbound implicit parameter (?f::t -> t1)
22:11:06 <ski> @type \x -> \y -> ?f x + ?g y
22:11:07 <lambdabot> forall t a t1. (?f::t -> a, ?g::t1 -> a, Num a) => t -> t1 -> a
22:11:16 <mmorrow> aavogt: it's since let+? is a completely different thing i believe
22:11:20 <mmorrow> (than let)
22:11:38 <mmorrow> it has a separate rep in the AST, etc
22:11:39 <aavogt> I guess out of convenience it could be modified to accept those where order doesn't matter
22:11:55 <mmorrow> yeah, if you could deduce it i can see that
22:12:18 <ski> @type \x -> (\ ?g y -> ?f x + ?g y) ?g
22:12:19 <lambdabot> Parse error in pattern
22:12:30 <ski> @type \x -> (\g y -> let g = ?g in ?f x + ?g y) ?g
22:12:32 <lambdabot> forall t a t1. (?g::t1 -> a, Num a, ?f::t -> a) => t -> t1 -> a
22:12:34 <ski> er
22:12:39 <ski> @type \x -> (\g y -> let ?g = g in ?f x + ?g y)
22:12:40 <lambdabot> forall t a t1. (Num a, ?f::t -> a) => t -> (t1 -> a) -> t1 -> a
22:12:44 <ski> @type \x -> (\g y -> let ?g = g in ?f x + ?g y) ?g
22:12:46 <lambdabot> forall t a t1. (Num a, ?f::t -> a, ?g::t1 -> a) => t -> t1 -> a
22:13:34 * ski tries to get `(Num c,?f :: a -> c) => a -> (?g :: b -> c) => b -> c'
22:13:53 <ddarius> ski: It ain't gonna happen.
22:14:08 <kmc> madness
22:14:53 <mmorrow> @type undefined :: a -> (forall b. ?foo :: Num b => b -> b => Int -> Int) -> Int
22:14:54 <lambdabot> parse error on input `=>'
22:15:03 <mmorrow> @type undefined :: a -> (?foo :: forall b. Num b => b -> b => Int -> Int) -> Int
22:15:05 <lambdabot> parse error on input `forall'
22:15:09 <ski> the implicit parameter constraints are always floated to the outermost level of the type ?
22:15:16 <mmorrow> @type undefined :: a -> ((?foo :: forall b. Num b => b -> b) => Int -> Int) -> Int
22:15:17 <lambdabot> parse error on input `forall'
22:15:18 <kmc> are implicit params used in any major haskell programs?
22:15:27 <ddarius> ski: Just like class constraints.
22:15:48 <mmorrow> @type undefined :: a -> (forall b. Num b => b -> b) -> Int
22:15:49 <lambdabot> forall a. a -> (forall b. (Num b) => b -> b) -> Int
22:16:11 <ski> ddarius : yes, but for class constraints there is only supposed to be at most one dictionary for any instance
22:16:18 <mmorrow> i wonder if the parser is the only thing preventing this from working here
22:16:21 <mmorrow> @type undefined :: a -> (?foo :: forall b. Num b => b -> b => Int -> Int) -> Int
22:16:23 <lambdabot> parse error on input `forall'
22:17:02 <mmorrow> oh
22:17:12 <mmorrow> @type undefined :: a -> (forall b. (?foo :: Num b => b -> b) => Int -> Int) -> Int
22:17:13 <lambdabot> parse error on input `=>'
22:17:15 <ddarius> :t \a -> let ?b = a in ?b
22:17:15 <mmorrow> grr
22:17:16 <lambdabot> forall t. t -> t
22:18:21 <roconnor> mmorrow: wrong bot
22:18:42 <mmorrow> haha
22:18:43 <roconnor> oh wait
22:18:46 <roconnor> ski was uing lambdabot
22:18:46 <mmorrow> err
22:18:53 <mmorrow> ah
22:18:58 <roconnor> hmm
22:19:06 <roconnor> > let ?f = (*3) in let g x = (?f x,x) in let ?f = (*2) in g 42
22:19:06 <mmorrow> @type ?f
22:19:07 <lambdabot>   (84,42)
22:19:07 <lambdabot> forall t. (?f::t) => t
22:21:50 <ivanm> has anyone managed to build the documentation for the 6.12 RC?
22:23:29 <b7j0c> a question: how would one apply a function like 'head' to a function in IO like getArgs which is of type IO [String]. i.e. get the first arg. doing getArgs >>= head is not right, nor is getArgs . head
22:24:25 <dibblego> @type liftM head
22:24:27 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> m a
22:24:38 <b7j0c> cool! thanks dibblego
22:24:50 <dibblego> getArgs <$> head -- you will need import Control.Applicative
22:25:02 <b7j0c> got it! thanks
22:25:34 <copumpkin> head <$> getArgs
22:25:37 <Axman6> b7j0c: or fmap head getArgs
22:25:43 <dibblego> er yeah, other way around
22:26:07 <b7j0c> thanks Axman6!
22:26:08 <dibblego> getArgs >>> head
22:26:08 <ski>   do arg:args <- getArgs
22:26:11 <ski>      ...
22:26:22 <kmeyer> :t getArgs >>= \x -> return (head x)
22:26:24 <lambdabot> Not in scope: `getArgs'
22:26:28 <Axman6> the possibilities are endless!
22:26:38 <ski> @index getArgs
22:26:39 <lambdabot> System.Environment
22:26:48 <b7j0c> indeed. you guys are quite helpful, i appreciate it
22:26:56 <ski>   arg <- head `liftM` getArgs
22:28:12 <ski> dibblego : ?
22:28:20 <ski> @type (>>>)
22:28:22 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
22:28:31 <dibblego> oh nothing
22:28:41 <b7j0c> thanks again and goodnight!
22:28:42 <ski> (`(>>>)' is not `flip fmap', even in Caleskell)
22:28:49 <copumpkin> :t Kleisli getArgs >>> arr head
22:28:50 <lambdabot> Not in scope: `getArgs'
22:28:53 <dibblego> yeah I was writing Java at the time, sincere apologies
22:29:09 <ivanm> bah, the GHC README lies about how to build and isntall documentation... :@
22:29:13 <ski> @type Kleisli getArgs System.Environment.>>> arr head
22:29:14 <lambdabot> Not in scope: `getArgs'
22:29:15 <lambdabot> Not in scope: `System.Environment.>>>'
22:29:22 <copumpkin> whoa
22:29:24 <copumpkin> how did that happen :P
22:29:26 <ski> @type Kleisli System.Environment.getArgs >>> arr head
22:29:27 <lambdabot>     Couldn't match expected type `a -> m b'
22:29:28 <lambdabot>            against inferred type `IO [String]'
22:29:28 <lambdabot>     In the first argument of `Kleisli', namely
22:29:44 <copumpkin> @type Kleisli (const getArgs) System.Environment.>>> arr head
22:29:45 <ski> copumpkin : qualified wrong name :)
22:29:46 <lambdabot> Not in scope: `getArgs'
22:29:46 <lambdabot> Not in scope: `System.Environment.>>>'
22:29:53 <copumpkin> @type Kleisli (const System.EnvironmentgetArgs) System.Environment.>>> arr head
22:29:55 <lambdabot>     Not in scope: data constructor `System.EnvironmentgetArgs'
22:29:55 <lambdabot> Not in scope: `System.Environment.>>>'
22:29:55 <copumpkin> BAH
22:29:58 <copumpkin> @type Kleisli (const System.Environment.getArgs) System.Environment.>>> arr head
22:30:00 <lambdabot> Not in scope: `System.Environment.>>>'
22:30:04 <ski> @index (>>>)
22:30:04 * copumpkin goes to sleep
22:30:04 <lambdabot> Control.Arrow
22:30:06 <copumpkin> lol
22:30:09 * ski whistles
22:30:10 <copumpkin> yeah, I just copied and pasted
22:30:15 <copumpkin> @type Kleisli (const System.Environment.getArgs) >>> arr head
22:30:16 <lambdabot> forall a. Kleisli IO a String
22:30:24 <copumpkin> @type runKleisli $ Kleisli (const System.Environment.getArgs) >>> arr head
22:30:25 <lambdabot> forall a. a -> IO String
22:30:27 <copumpkin> tada
22:30:56 <ski> @hoogle (() -> a) -> a
22:30:56 <lambdabot> Data.Function fix :: (a -> a) -> a
22:30:57 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
22:30:57 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
22:30:59 <kmc> @tell kmc_ http://www.linux-kongress.org/2009/slides/compiler_survey_felix_von_leitner.pdf
22:30:59 <lambdabot> Consider it noted.
22:31:03 <ski> @hoogle a -> (() -> a)
22:31:03 <lambdabot> Control.Parallel.Strategies demanding :: a -> Done -> a
22:31:03 <lambdabot> Control.Parallel.Strategies sparking :: a -> Done -> a
22:31:03 <lambdabot> Prelude asTypeOf :: a -> a -> a
22:31:18 <copumpkin> @type (runKleisli $ Kleisli (const System.Environment.getArgs) >>> arr head) ()
22:31:19 <lambdabot> IO String
22:31:49 <ski> kmc : you're aware of `/msg MemoServ send kmc_ ...', yes ?
22:33:33 <kmc> no, good to know :)
22:39:48 <ski> (send `help' for more info)
22:40:49 <Gracenotes> in STG pretty-printing, what is code like "GHC.Num.:DNum tpl1_sue tpl2_stf tpl3_suf tpl4_sug tpl5_suh tpl6_sui tpl7_suj tpl8_suk tpl9_sul"? something to do with typeclasses, I'm guessing? 7 functions from Num, and a reference to Eq and Show instances each?
22:41:24 <copumpkin> might get more of an answer from #ghc
22:41:38 <ski> presumably that is a `Num' dictionary, yes
22:42:01 <gio123> ski:hi
22:42:04 <gio123> ski: hi
22:42:40 <Gracenotes> I'm not sure how to make sense out of the number "9" otherwise :P lemme try playing around with it, though
22:44:16 <Gracenotes> mm. when I use an Eq function, it further does a case statement on that
22:44:59 <ski> to extract the members of the `Eq' dictionary
22:45:05 <Gracenotes> yep
22:45:59 <Gracenotes> I suppose if you have a typeclass called D, you can make it print :DD
22:46:09 <mmorrow> Gracenotes: that's the datatype GHC creates to hold Num instance dictionaries
22:46:36 <mmorrow> the identifiers have names with : so they're illegal haskell source-level idents
22:46:51 <mmorrow> (on purpose)
22:47:54 <mmorrow> then each instance corresponds to a top-level declaration that takes as params a dict for every class the corresponding instance def has in its context
22:48:02 <mmorrow> e.g.
22:48:10 <mmorrow> err, hmm what's a good one
22:48:29 <ski>   instance Eq a => Eq [a]
22:48:35 <mmorrow> fooOrd (DEq{...}) = DOrd {....}
22:48:39 <iaefai> Luke, Obiwan never told you the true nature of the monad!
22:48:52 <mmorrow> fooOrd :: DOrd Foo
22:48:59 <mmorrow> no
22:49:06 <mmorrow> fooOrd :: DEq Foo -> DOrd Foo
22:49:31 <mmorrow> *then* there's another top-level def that corresponds to the *actual* instance
22:49:41 <mmorrow> gah
22:49:47 <mmorrow> yeha
22:50:02 <Gracenotes> looks like Show does not have this sort of pattern matching.. that I can see
22:50:03 <mmorrow> fooOrdInstance = fooOrd fooEq
22:50:35 <Gracenotes> never mind, found it
22:51:47 <Gracenotes> so are huge typeclasses slow after all? :)
22:51:52 <mmorrow> Gracenotes: this makes it clear what GHC does http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3326
22:52:18 <Gracenotes> they are program-wide tables, so I'd imagine there is jump-table-esque access..
22:52:29 <binrapt> What's the standard function to retrieve the n'th element of a list?
22:52:32 <mmorrow> Gracenotes: heh, after seeing the generated code you get super hesitant about using un-resolved typeclasses
22:52:33 <mauke> !!
22:52:48 <copumpkin> > [1..5] !! 3
22:52:49 <lambdabot>   4
22:53:02 <Gracenotes> omg, everything I learned about math is wrong
22:53:34 <mauke> preflex: calc 1 2 + 3 *
22:53:35 <preflex>  7
22:53:50 <ski> mmorrow : which source would `fooOrd :: DEq Foo -> DOrd Foo; fooOrd (DEq{...}) = DOrd {....}' correspond to ?
22:53:53 <Gracenotes> mmorrow: I tend to like explicit type declarations as well
22:53:55 <ski> an instance declaration ?
22:54:13 <mmorrow> ski: i'm trying to recall, i just confused myself
22:55:05 <mmorrow> ski: did you see this? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=3326
22:55:16 * ski looks now
22:55:32 <mmorrow> ski: (that's generated from ghc ext-core, which comes directly from core)
22:55:49 <mmorrow> but the syntax and prettyprinter is my own, after some processing and misc
22:56:13 <copumpkin> thar be spines and tags
22:56:19 <mmorrow> so $f1 is the instance
22:56:22 * ski idly wonders why `(Ord k) => ' rather than `Ord k => ' ..
22:56:26 <Gracenotes> okay, typeclass directionarification happens at Core.
22:56:31 <copumpkin> ski: consistencY?
22:56:37 <copumpkin> (unlike my capitalization)
22:56:39 <mmorrow> and takes a $dOrdaMn
22:57:07 <mmorrow> Gracenotes: right, once you get to core, type classes have become explicit dictionaries
22:57:26 <mmorrow> and are explicitly created and passed
22:58:00 <mtnviewmark> is it considered bad form to define functions where the return type is just a constrained type variable?
22:58:25 <mtnviewmark> as in   foo :: (SomeClass a) => String -> Gizmoe -> a
22:58:31 <copumpkin> nope
22:58:47 <copumpkin> :t read
22:58:49 <lambdabot> forall a. (Read a) => String -> a
22:58:53 <copumpkin> :t printf
22:58:54 <lambdabot> forall r. (PrintfType r) => String -> r
22:58:59 <kmc> you do sometimes need an explicit type annotation to call them
22:58:59 <copumpkin> granted, printf is a bit of a hack
22:59:04 <ski> (if `(Foo,Bar,Baz)' is a conjunction (with a triple as proof), then `(Foo)' is a unary conjunction (with "unituple" as proof) .. but unituples doesn't exist in haskell, so i prefer to write the unary conjunction of a constraint as simply that constraint itself)
22:59:24 <kmc> the caller can pick any type "a" which satisfies
22:59:32 <mtnviewmark> okay, so the sometimes "extra typing" required by the users of these functions is considered "par for the course"
22:59:42 <mauke> :t return
22:59:44 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
22:59:45 <mmorrow> ski: yeah, i like the consistency of always using (...)
22:59:48 <kmc> if you instead want the function being called to pick which type, and the caller doesn't get a say, you'd wrap it in an existential
23:00:07 <mmorrow> ski: although i've recently started not always doing this for function type sig constraints
23:00:56 <ski> mmorrow : well, if we every get other non-atomic constraints than conjunction (such as implication and universal quantification), i think it's nicer to not default now already to "every constraint is a conjunction of atomic constraints" :)
23:01:00 <ski> (ymmv)
23:01:51 * ski str `@tell'ing mtnviewmark something, but don't recall what it was
23:02:19 <ski> (s/every/ever/)
23:02:20 <mtnviewmark> I like the (...) usage, even for single constraints because I read the (...) /sotto voce/
23:02:30 <olsner> hmm, has the liftIO/printf/undefined thing been fixed now?
23:03:09 * mtnviewmark is off to sleep
23:07:18 <Gracenotes_> > let x :: () => Int; x = 2+3 in x  -- ski, mmorrow
23:07:19 <lambdabot>   5
23:07:53 <kmc> is the empty constraint list a constraint list?
23:07:54 * kmc ducks
23:07:54 <Gracenotes_> along the same lines as "let in 3+4"
23:08:21 <mmorrow> , let in ()
23:08:22 <lunabot>  ()
23:08:31 <ski> kmc : obviously, yes :)
23:08:31 <kmc> > do {}
23:08:33 <lambdabot>   <no location info>: Empty 'do' construct
23:08:35 <copumpkin> > let in the cat
23:08:37 <lambdabot>   Ambiguous occurrence `cat'
23:08:37 <lambdabot>  It could refer to either `L.cat', defined at <l...
23:08:42 <kmc> :t the
23:08:43 <lambdabot> String -> Doc
23:08:45 <copumpkin> > let in the L.cat
23:08:46 <lambdabot>   meow
23:09:01 <ski> > [() |]
23:09:03 <lambdabot>   <no location info>: parse error on input `]'
23:11:20 <kmc> :t L.cat
23:11:21 <lambdabot> [Char]
23:17:25 <nolrai_FG> > let in the L.cat
23:17:26 <lambdabot>   meow
23:17:33 <nolrai_FG> :t L.cat
23:17:35 <lambdabot> [Char]
23:17:57 <nolrai_FG> What is L?
23:18:18 <kmeyer> :t the
23:18:20 <lambdabot> Not in scope: `the'
23:18:26 <mauke> > let in the cat
23:18:28 <lambdabot>   meow
23:18:47 <nolrai_FG> > let in the dog
23:18:48 <lambdabot>   Not in scope: `dog'
23:18:49 <kmc> > hcat $ map text $ replicate L.cat
23:18:50 <lambdabot>   Not in scope: `L.cat'
23:19:01 <kmc> > hcat $ map text $ repeat L.cat
23:19:01 <lambdabot>   Not in scope: `L.cat'
23:19:25 <nolrai_FG> why are things sometimes in scope and sometimes not?
23:19:35 <mauke> because people undefine them
23:19:58 <nolrai_FG> :t cat
23:19:59 <lambdabot> [Doc] -> Doc
23:20:10 <nolrai_FG> > let in the cat
23:20:12 <lambdabot>   meow
23:20:12 <kmc> > hcat $ map text $ repeat "meow"
23:20:14 <lambdabot>   * Exception: stack overflow
23:20:22 <nolrai_FG> :t the
23:20:23 <lambdabot> forall t. t -> Doc
23:20:43 * kmc is suspicious of that function
23:20:46 <nolrai_FG> > let in the ()
23:20:48 <lambdabot>   meow
23:20:50 <kmc> > the id
23:20:51 <lambdabot>   meow
23:20:57 <kmc> > the undefined
23:20:58 <lambdabot>   meow
23:20:59 <nolrai_FG> tricky
23:21:03 <kmc> @src the
23:21:04 <lambdabot> Source not found. I've seen penguins that can type better than that.
23:21:05 <iaefai> :t <$>
23:21:06 <lambdabot> parse error on input `<$>'
23:21:15 <MoALTz> :t the
23:21:17 <lambdabot> forall t. t -> Doc
23:21:18 <kmc> :t (<$>)
23:21:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:21:24 <nolrai_FG> the cat isnt meowing the the the is.
23:21:32 <kmc> woah, that's deep
23:21:32 <iaefai> @src (<$>)
23:21:32 <lambdabot> f <$> a = fmap f a
23:21:50 <iaefai> @src fmap
23:21:50 <lambdabot> Source not found. Maybe if you used more than just two fingers...
23:21:59 <kmc> fmap lives in the typeclass Functor
23:23:35 <mauke> @src Maybe fmap
23:23:36 <lambdabot> fmap _ Nothing       = Nothing
23:23:36 <lambdabot> fmap f (Just a)      = Just (f a)
23:30:41 <iaefai> In the second function (starting at 10), is there an easy way (using the Either monad?) to return the Config I want to return?   ( data Config = Config { documentRoot :: String } deriving (Read, Show) )
23:31:12 <kmc> iaefai, i don't see your paste
23:31:17 <iaefai> oops
23:31:22 <iaefai> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=11942
23:31:32 <iaefai> It seems that sometimes copy and paste doesn't work
23:32:37 <iaefai> I think I should be able to take advantage of the Either monad here, but i am not sure how to go about that
23:32:48 <iaefai> Because I have the Either and IO together in a manner of speaking.
23:32:50 <kmc> so IO (Either a b) is not a monad
23:32:59 <kmc> you already un-monaded it with runErrorT in getConf
23:33:28 <iaefai> second function is the one I am writing now, to replace the ConfigFile implementation of the first one
23:34:14 <kmc> ah
23:34:17 <kmc> using parsec?
23:34:23 <iaefai> It does use parsec yes
23:34:55 <iaefai> I can paste the parser if you like
23:35:24 <kmc> :t parseFromFile
23:35:25 <lambdabot> Not in scope: `parseFromFile'
23:35:31 <kmc> parseFromFile :: Parser a -> SourceName -> IO (Either ParseError a)
23:35:44 <iaefai> That sounds like the one
23:36:16 <kmc> the Either monad is only useful if you want to chain several computations that use Either to represent error
23:37:13 <kmc> :t either (error.show) return
23:37:14 <lambdabot> forall a b (m :: * -> *). (Show a, Monad m) => Either a b -> m b
23:38:21 <iaefai> kmc, what would your recommendation be here? Is there a way to write this so I can easily add settings later without having to worry about dealing with the Left side that I would just want passed on?
23:38:36 <kmc> passed on to where?
23:38:45 <kmc> adding settings would be a change to the parser and the Config datatype, right?
23:39:02 <kmc> what do you want to do if there's a parse error?
23:39:09 <ski> @type (either Left Right) . sequence
23:39:11 <lambdabot> forall a a1. (Error a) => [Either a a1] -> Either a [a1]
23:39:35 <binrapt> http://haskell.pastebin.com/d5db02661 <- why is the parenthesis pattern at the bottom not permitted? I thought Haskell wasn't white space sensitive :(
23:39:38 <iaefai> kmc, I want any errors to be handled outside this function, and adding settings would not change the paser, only the config data type and adding the code to find it in the map
23:39:40 * ski sometimes want to do that, without needing the `Error a' constraint
23:39:49 <binrapt> It works when I pull up the if and the last ) for example
23:41:14 <kmc> iaefai, the simple thing is, since you're already in IO, use the IO exceptions
23:42:36 <kmc> something like: either throw return <$> parseFromFile parser "filename"
23:43:10 <kmc> assuming ParseError is an instance of Exception or can be made so
23:45:06 <iaefai> I am kind of confused as to how this would assist me.
23:46:03 <GNU\colossus> hi there. I've got a list of lists of Int [[Int]], and would like to ensure there are only zeroes and ones in the whole structure . but I fail to grasp how to do that in Haskell. could anyone please hint me at which functions I should be looking at to find a solution to the problem?
23:46:28 <kmc> :t all -- GNU\colossus
23:46:29 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
23:46:30 <iaefai> You are talking about me changing the way my configuration module works, which is generalized away from specific config types
23:46:44 <ivanm> GNU\colossus: [[Int]] ?
23:46:53 <GNU\colossus> ivanm: yes.
23:46:56 <ivanm> all (all (`elem` [0,1]))
23:47:11 <ivanm> that's to test if they all are 0s and 1s
23:47:14 <kmc> :t all (all (`elem` [0,1]))
23:47:15 <lambdabot> forall a. (Num a) => [[a]] -> Bool
23:47:24 <GNU\colossus> ha! I tried nesting all ind another all before, but my brain assploded, and I couldn't make it work.
23:47:26 <ivanm> if you want to ensure on the type-level... you'll have to use something like Bool or create your own custom type :s
23:47:28 <GNU\colossus> thanks a bunch!
23:47:31 <ivanm> actually, is there a Bits type?
23:47:50 <ivanm> @instances-importing Data.Bit Integral
23:47:51 <lambdabot> Int, Integer
23:47:53 <ivanm> GNU\colossus: no worries!
23:48:28 <kmc> binrapt, haskell has optional whitespace sensitivity
23:48:36 <kmc> you can always get rid of it by adding explicit { } ;
23:48:51 <iaefai> 'default whitespace sensitivity' :p
23:48:58 <Cale> binrapt: Haskell *is* whitespace sensitive by default, yeah.
23:49:03 <ivanm> kmc: which is usually not recommended...
23:49:21 <kmc> it's not default if you think of "programming" as an act primarily involving curly braces
23:49:34 <iaefai> It is socially unacceptable to bring it closer to the look of C/C++
23:50:33 <kmc> binrapt, why not put your conditional inside the "let" you already have?
23:50:40 <kmc> also, a few more things to note:
23:50:43 <ski> mmorrow : is `Identity' in lunabot ?
23:51:01 <kmc> - there's a special form of "let" that you can use inside "do"  (you can use the regular one there as well)
23:51:03 <iaefai> Is hackage up to you guys?
23:51:15 <ivanm> iaefai: agreed!
23:51:25 <kmc> - it's bad form to use if isJust ... then ... fromJust ....   pattern-match using "case" instead
23:51:27 <ivanm> iaefai: yup
23:51:48 <iaefai> ok, I REALLY want to be able to make some master documentation for all of my installed modules
23:52:20 <mmorrow> , ''Identity
23:52:21 <lunabot>  luna: Not in scope: type constructor or class `Identity'
23:52:30 <mmorrow> ski: lunabot has monadLib instead of mtl
23:52:31 <kmc> result_str = case result of { Nothing -> "Invalid index specified"; Just v -> show v } -- binrapt
23:52:35 <kmc> or better:
23:52:36 <kmc> :t maybe
23:52:37 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
23:52:39 <mmorrow> hmm
23:52:41 <mmorrow> , ''Id
23:52:42 <lunabot>  MonadLib.Id
23:52:45 <kmc> :t maybe "Invalid index specified" show
23:52:46 <lambdabot> forall a. (Show a) => Maybe a -> [Char]
23:52:47 <mmorrow> , src ''Id
23:52:50 <lunabot>  newtype Id a = I a
23:52:57 <mmorrow> , runId (return 42)
23:52:58 <lunabot>  42
23:53:08 <ski> , [$ty| I |]
23:53:11 <lunabot>  SKI
23:53:14 <mmorrow> heh
23:53:23 <ski> O.o
23:53:32 <mmorrow> , [$ski|S[(,)][show][42]|]
23:53:34 <lunabot>  (42,"42")
23:53:36 <kmc> binrapt, same goes for "element".  it'd be much better to rewrite it using two equations, pattern matching on the list
23:53:47 <mmorrow> , [$ski|SKISKISKISKIKSIIIISKSK|]
23:53:49 <lunabot>  K
23:53:57 <mmorrow> , [$ski|SKISKI(SKISKIKS)IIIISKSK|]
23:54:00 <lunabot>  K
23:54:05 <mmorrow> err
23:54:19 <mmorrow> , [$ski|KSKKISKSIKIKS|]
23:54:21 <lunabot>  S
23:54:38 <mmorrow> , [$ski|KKIS|]
23:54:38 <kmc> (if you want to write it recursively instead of calling "drop", that is)
23:54:40 <lunabot>  K :$ S
23:54:52 <kmc> "head" is an unsafe function, in that it will cause a runtime error if the argument list is empty
23:55:05 <mmorrow> , src ''SKI
23:55:08 <lunabot>  data SKI = S | K | I | E Exp | SKI `(:$)` SKI
23:55:09 <kmc> also, "length" will traverse the entire list to find its length, even if index is 0
23:55:27 <kmc> in fact, this version won't index infinite lists properly
23:55:44 * iaefai defines a function set car, and cdr…
23:56:34 <iaefai> :t runErrorT
23:56:35 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
23:56:49 <kmc> mmorrow, that's an awesome quasiquoter :D
23:57:10 <iaefai> What exactly is 'runErrorT' and what does it do?
23:57:18 <kmc> iaefai, do you know what ErrorT is?
23:57:43 * hackagebot upload: serialport 0.3.0 - Cross platform serial port library. (JorisPutcuyps)
23:58:05 <iaefai> sweet a new serialport!
23:58:06 <ski> @type let each = Cont . flip all in \xss -> (each >=> each) xss `runCont` (`elem` [0,1])  -- GNU\colossus,ivanm,kmc
23:58:07 <lambdabot> forall a. (Num a) => [[a]] -> Bool
23:58:24 <kmc> what
23:58:45 <ivanm> ski: wtf does that do?
23:59:08 <kmc> :t Cont . flip all
23:59:10 <lambdabot> forall a. [a] -> Cont Bool a
23:59:14 <ski> the same as  all (all (`elem` [0,1]))
