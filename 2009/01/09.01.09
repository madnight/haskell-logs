00:00:27 <vegai> ohh
00:00:40 <vegai> after importing Data.Time.Format, UTCTime suddendly has a Show instance :)
00:00:47 * vegai feels silly now.
00:00:50 <chrisdone> oh, sweet
00:01:05 <chrisdone> I'd wondered where it was defined, because the Show instance appears elsewhere in the Haddock documentation
00:22:11 <Axman6> al-maisan: woah, scared me a little there, your nick is very similar to to me name :o
00:22:38 <al-maisan> Axman6: :)
00:22:48 <Axman6> s/me/my
00:23:05 <al-maisan> no worries :)
00:23:27 * Axman6 is Alex Mason, for the record
00:23:47 * al-maisan is Muharem Hrnjadovic
00:23:54 <Axman6> heh
00:23:56 <al-maisan> not very similar, really :)
00:24:04 <Axman6> indeed
00:24:48 <al-maisan> Axman6: http://en.wikipedia.org/wiki/Meissa
00:25:13 <mmorrow> chrisdone: hmm, i guess i don't. but this might be useful http://tools.ietf.org/html/rfc5322
00:25:18 <al-maisan> I liked the name and adopted is my IRC nick
00:25:39 <al-maisan> s/is my/it as my/
00:25:49 <ksf> http://haskell.org/haskellwiki/Reactive/Tutorial/A_FPS_display
00:26:22 <mmorrow> chrisdone: this dood claims the regex on this page matches 99% of email addrs http://www.regular-expressions.info/email.html
00:27:16 <mmorrow> ^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$
00:27:41 * mmorrow adds it to the #haskell logs
00:28:16 <mmorrow> wtf, what about lowercase??
00:28:51 <chrisdone> mmorrow: haha, I saw that one/currently using.. I added lowercase..
00:28:54 <mmorrow> oh, he assumes case insensitive matching
00:29:02 <chrisdone> I'm using
00:29:03 <chrisdone>     valid = (=~ "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,4}\
00:29:03 <chrisdone>                 \\\.{0,1}[a-zA-Z]{0,4}")
00:29:03 <chrisdone>  
00:29:03 <Axman6> al-maisan: very nice :)
00:29:05 <chrisdone> at the merment
00:29:08 <mmorrow> chrisdone: nice
00:29:18 <chrisdone> mmorrow: I dunno if it's a good checker or not. it's hard
00:29:19 <Axman6> al-maisan: mine;s just AleX MAsoN 6 :P
00:29:37 <al-maisan> Axman6: why the "6"?
00:29:58 <chrisdone> emailInput :: Form Html Store String
00:29:58 <chrisdone> emailInput = F.input Nothing `F.check` F.ensure valid error where
00:29:58 <chrisdone>     error = "Invalid email address!"
00:29:58 <chrisdone>     valid = (=~ "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,4}\
00:30:02 <chrisdone>                 \\\.{0,1}[a-zA-Z]{0,4}")
00:30:03 <Ralith> al-maisan: presumably, 0-5 were taken.
00:30:05 <chrisdone> :D
00:30:17 <al-maisan> Ralith: ah, OK.
00:30:22 <mmorrow> chrisdone: if you're feeling hardcore, you can write a parser as per the def in that rfc
00:30:26 <Ralith> al-maisan: (that was a joke)
00:30:35 <al-maisan> :)
00:30:46 <Ralith> chrisdone: if that's a regexp, someone wrote the Perfect Email Regexp on a perl mailing list a while back
00:30:49 <Ralith> chrisdone: it was about a page long.
00:31:01 <chrisdone> Ralith: too slow>:|
00:31:15 <Ralith> but it accepted every single valid email conceivable!
00:31:21 <Saizan> RFCs are not always that good to follow, i.e. not even google respects the cookie one
00:31:51 <Ralith> Saizan: what's the cookie one say?
00:31:54 <mmorrow> chrisdone: here's part of the address syntax spec http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=748#a748
00:32:29 <mmorrow> i bet a ReadP parser for the spec would use less chars than that perl regex, and be just as correct :)
00:32:51 <Saizan> Ralith: some special characters are not allowed in the value of the cookie
00:32:52 <mmorrow> Saizan: ugh
00:32:57 <chrisdone> mmorrow: that's actually not too bad
00:32:59 <Ralith> Saizan: why?
00:33:07 <mmorrow> chrisdone: totally
00:33:24 <chrisdone> worth making a library for hackage, maaaaybe
00:34:04 <mmorrow> chrisdone: use ReadP or burn in hell!
00:34:14 <mmorrow> :)
00:34:24 <Saizan> Ralith: to ease parsing i guess? i'm not sure if without that restriction it becomes non-deterministic
00:34:35 <chrisdone> ReadP? never heard of it
00:35:24 <chrisdone> oh, parsec
00:35:58 <chrisdone> no, not parsec
00:36:00 <chrisdone> lulz
00:36:04 <chrisdone> why ReadP?
00:36:19 <mmorrow> oh, i thought you were kidding :)
00:36:22 <mmorrow> , readP_to_S (choice . fmap string $ ["asdf","jkl;","jkl","qwerty"]) "jkl"
00:36:24 <lunabot>  [("jkl","")]
00:36:27 <mmorrow> (+++) is commutative
00:36:37 <mmorrow> none of this "try" nonsense
00:36:49 <mmorrow> it does breadth-first search
00:36:58 <chrisdone> oooo
00:37:00 <mmorrow> and it's efficient to boot
00:37:09 <vegai> chrisdone: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsemail ?
00:37:19 <chrisdone> hell yeah!
00:37:19 <mmorrow> (choice = foldr (+++) pfail)
00:37:39 <mmorrow> oh nice
00:37:47 <mmorrow> oh. parsec.
00:37:50 * mmorrow weeps
00:38:10 <vegai> aww, why the hate
00:38:11 <chrisdone> mmorrow: I think I'll play with this ReadP
00:38:19 <mmorrow> vegai: :)
00:38:23 <chrisdone> mmorrow: have you tried Frisby? thoughts?
00:38:25 <mmorrow> chrisdone: do eet!
00:38:37 <vegai> does parsec's performance penalty really hurt with small stuff like email addresses?
00:38:46 <mmorrow> chrisdone: no, but that's the one where you had the massive mdo producing the 74 tuples, right?
00:39:25 <mmorrow> vegai: "just a little crack", "just one hit", "i'll only be gone for a second"....
00:39:31 <chrisdone> http://hackage.haskell.org/packages/archive/hsemail/1.3/doc/html/Text-ParserCombinators-Parsec-Rfc2822.html#v%3Aaddr_spec
00:39:49 <vegai> heh
00:39:55 <chrisdone> mmorrow: yeah, it was :(
00:40:24 <Axman6> al-maisan: no reason really, it was my 'favourite number' at the time :P
00:40:38 <al-maisan> fair enough :)
00:40:39 <mmorrow> chrisdone: where'd you get that from again? i tried to find it actually maybe a month ago and couldn't
00:40:58 <al-maisan> Axman6: BTW, do you get to do a lot of haskell programming?
00:40:59 <chrisdone> mmorrow: http://repetae.net/computer/frisby/
00:41:08 <chrisdone> http://www.mail-archive.com/haskell@haskell.org/msg19128.html
00:41:20 <mmorrow> nice
00:42:36 * chrisdone might try ReadP for a lojban parser ~_ ~
00:42:47 <chrisdone> it really needs excessive use of 'try' in parsec, which makes it slow as shit
00:42:59 <chrisdone> and Frisby can't do it because there's too many rules to fit in an mdo
00:43:02 <lepassive> > print "I finally got Monads"
00:43:04 <lambdabot>   * Exception: "<IO ()>"
00:43:05 <chrisdone> so maybe ReadP will be better
00:43:09 <chrisdone> lepassive: heh
00:43:11 <lepassive> > "I finally got Monads"
00:43:13 <lambdabot>   "I finally got Monads"
00:43:20 <lepassive> now it works :)
00:43:52 <Saizan> > say "I finally got Monads"
00:43:53 <lambdabot>   Not in scope: `say'
00:44:27 <lepassive> correct me if I'm wrong a Monad encapsulates the outside world (that may vary) and gives me a new cute Monad
00:45:27 <chrisdone> > "I " ++ ([1..5] >>= const "finally") ++ " got monads"
00:45:28 <lambdabot>   "I finallyfinallyfinallyfinallyfinally got monads"
00:46:03 <vixey> lol
00:46:16 <lepassive> > "Sounds he got them more than I do :("
00:46:18 <lambdabot>   "Sounds he got them more than I do :("
00:46:27 <ksf> > [1..] >>= show
00:46:29 <lambdabot>   "12345678910111213141516171819202122232425262728293031323334353637383940414...
00:46:39 <earthy> > let say = id in say ['I',' ', 'f','i','n','a','l','l','y',' ','g','o','t',' ','m','o','n','a','d','s']
00:46:41 <lambdabot>   "I finally got monads"
00:47:09 <vixey> :t intercalate "','"
00:47:10 <lambdabot> [[Char]] -> [Char]
00:47:38 <earthy> :t join
00:47:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
00:47:46 <vixey> :t (("[" ++) . (++ "]") . intercalate "','" . map return)
00:47:47 <lambdabot> [Char] -> [Char]
00:49:53 <mmorrow> , readP_to_S (let go n = between (char '(') (char ')') (go (n+1)) +++ return n in go 0) "(((())))"
00:49:55 <lunabot>  [(0,"(((())))"),(4,"")]
00:50:28 <mmorrow> that seems like it's "buggish" for that to return that result and not
00:50:42 <mmorrow> [(0,"(((())))"),.. 1 ... 2 ... 3 .. , (4,"")]
00:51:19 <mmorrow> i would've thought that'd have been the behavior
00:51:25 <mmorrow> , readP_to_S (let go n = between (char '(') (char ')') (go (n+1)) +++ return n in go 0) "(((())))"
00:51:27 <lunabot>  [(0,"(((())))"),(4,"")]
00:51:28 <mmorrow> , readP_to_S (let go n = between (char '(') (char ')') (go (n+1)) <++ return n in go 0) "(((())))"
00:51:31 <lunabot>  [(4,"")]
00:53:06 <mmorrow> , readP_to_S (let go 0 = 0; go n = (go (n+1) +++ return (n+1)) +++ return n in go 0) "(((())))"
00:53:07 <lunabot>  luna: No instance for (GHC.Num.Num
00:53:16 <Saizan> lepassive: it doesn't necessarily encapsulate the outside world, that's specific to the IO monad, if anything
00:53:18 <mmorrow> , readP_to_S (let go 0 = 0; go n = (go (n+1) +++ return (n+1)) +++ return n in go 4) "(((())))"
00:53:19 <lunabot>  luna: No instance for (GHC.Num.Num
00:53:43 <mmorrow> , readP_to_S (let go 0 = return 0; go n = (go (n-1) +++ return (n-1)) +++ return n in go 4) "(((())))"
00:53:45 <lunabot>  [(0,"(((())))"),(0,"(((())))"),(1,"(((())))"),(1,"(((())))"),(2,"(((())))...
00:53:59 <mmorrow> , readP_to_S (let go 0 = return 0; go n = go (n-1) +++ return n in go 4) "(((())))"
00:54:01 <lunabot>  [(0,"(((())))"),(1,"(((())))"),(2,"(((())))"),(3,"(((())))"),(4,"(((())))")]
00:54:07 <Saizan> lepassive: but yeah, a monad adds some "effects" to your language, by representing them in the monadic type
00:54:40 <Saizan> lepassive: another example is the list monads, where the effect is non-determinism
00:54:44 <vixey> :t msum
00:54:45 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
00:54:51 <mmorrow> , readP_to_S (let go n = (char '(' >> go (n+1) >> char ')') +++ return n in go 4) "(((())))"
00:54:52 <lunabot>  luna: No instance for (GHC.Num.Num GHC.Types.Char)
00:54:58 <vixey> , readP_to_S ((msum . map return . iterate (+1)) 0) "fooooooo"
00:55:00 <lunabot>  [(0,"fooooooo"),(1,"fooooooo"),(2,"fooooooo"),(3,"fooooooo"),(4,"fooooooo...
00:55:11 <lepassive> Saizan, well then how soon should I be writing my own Monads ?
00:55:11 <mmorrow> , readP_to_S (let go n = (char '(' >> go (n+1) >>= \m -> char ')' >> return m) +++ return n in go 4) "(((())))"
00:55:13 <lunabot>  [(4,"(((())))"),(8,"")]
00:55:39 <vixey> , readP_to_S ((msum . map (return <=< get) . iterate (+1)) 0) "fooooooo"
00:55:41 <lunabot>  luna: Ambiguous occurrence `get'
00:55:45 <vixey> , readP_to_S ((msum . map (return <=< ReadP.get) . iterate (+1)) 0) "fooooooo"
00:55:47 <lunabot>  luna: Not in scope: `ReadP.get'
00:56:04 <mmorrow> , Text.ParserCombinators.ReadP.get
00:56:06 <lunabot>  luna: No instance for (GHC.Show.Show
00:56:20 <vixey> , readP_to_S ((msum . map (return <=< Text.ParserCombinators.ReadP.get) . iterate (+1)) 0) "fooooooo"
00:56:22 <lunabot>  luna: Couldn't match expected type `a -> m b'
00:56:33 <vixey> , readP_to_S ((msum . map (return =<< Text.ParserCombinators.ReadP.get) . iterate (+1)) 0) "fooooooo"
00:56:35 <lunabot>  luna: Couldn't match expected type `a1 -> a'
00:56:52 <Saizan> lepassive: see the implementation of some of the monads here (apart IO) first http://www.haskell.org/all_about_monads/html/introII.html
00:56:56 <vixey> oh
00:57:10 <vixey> , readP_to_S ((msum . map (\x -> do Text.ParserCombinators.ReadP.get ; return x) . iterate (+1)) 0) "fooooooo"
00:57:14 <lunabot>  Stack space overflow: current size 8388608 bytes.
00:57:14 <lunabot>  Use `+RTS -Ksize' to increase it.
00:57:40 <vixey> I didn't expect it to crash though
00:57:47 <lepassive> Saizan, thanks I wondered where do they get the examples :)
00:58:15 <mmorrow> , let go n p = return n +++ (char '(' >> (go (n+1) (p >> char ')') <++ p)) in readP_toS (go 0) "(((())))"
00:58:17 <lunabot>  luna: Not in scope: `readP_toS'
00:58:21 <mmorrow> , let go n p = return n +++ (char '(' >> (go (n+1) (p >> char ')') <++ p)) in readP_to_S (go 0) "(((())))"
00:58:23 <lunabot>  luna: Couldn't match expected type `Text.ParserCombinators.ReadP.ReadP a'
00:58:40 <mmorrow> , let go n p = return n +++ (char '(' >> (go (n+1) (p >> char ')') <++ p)) in readP_to_S (go 0 (return())) "(((())))"
00:58:41 <lunabot>  luna: Couldn't match expected type `GHC.Types.Char'
00:59:59 <lepassive> lunabot like a female lambdabot ?
00:59:59 * vixey <3 (+++)
01:00:23 <mmorrow> , let go n p = return n +++ (char '(' >> (go (n+1) (p >> char ')' >> return ()) <++ (p>>return (n+1)))) in readP_to_S (go 0 (return())) "(((())))"
01:00:24 <fasta> Haskell has more logos than libraries ;) http://haskell.org/haskellwiki/Haskell_logos/New_logo_ideas Seriously, I was sort of impressed with the amount of logos.
01:00:25 <lunabot>  [(0,"(((())))"),(1,"((())))"),(2,"(())))"),(3,"())))"),(4,"))))")]
01:00:31 <vixey> fasta, LOL
01:00:31 <mmorrow> whoa
01:01:01 <Ralith> fasta: very enthusiastic community.
01:01:43 <igowen> there are some terrible logos on there
01:02:09 <mmorrow> i love the that's a >>= but with s/>/lambda/ for the second '>'
01:02:16 <mmorrow> *the one that's ...
01:02:19 <igowen> they should just use this one http://haskell.org/sitewiki/images/7/75/Pure_Devil_Haskell.png
01:02:31 <vixey> my favorite idea is the sloth
01:02:33 <vixey> for haskell
01:02:53 <mmorrow> haha, that devil one + the haskell-cafe msg are hillarious
01:03:52 <lepassive> @hoogle Maybe
01:03:52 <lambdabot> module Data.Maybe
01:03:52 <lambdabot> Prelude data Maybe a
01:03:52 <lambdabot> Data.Maybe data Maybe a
01:03:55 <igowen> this one, mmorrow? http://media.nokrev.com/junk/haskell-logos/logo7.png
01:03:59 <igowen> that one is pretty slick
01:04:23 <mmorrow> exactly, i think that's a great idea
01:04:56 <mmorrow> nice and simple + merges two possible logos into a single clever one
01:05:01 <igowen> half-life much? http://haskell.org/sitewiki/images/4/49/Tshirt-logo-mod-inv.png
01:05:23 <mmorrow> that one's way too noisy
01:06:04 <igowen> I kind of like that little square one with the favicon example
01:06:57 <chrisdone> http://haskell.org/haskellwiki/Image:Hazard_lambda_cracked_2.png
01:07:00 <chrisdone> I unsafePerform'd
01:07:16 <mmorrow> i like the rounded one myself http://media.nokrev.com/junk/haskell-logos/logo8.png
01:07:36 * vixey .. what's so good about lambda anyway
01:07:49 <mmorrow> heh, that one would be a lot sweeter if the skull was more "badass"
01:08:22 <igowen> I think I prefer the square corners
01:08:27 <mmorrow> because it doesn't instill much fear and pirate nightmares
01:08:31 <chrisdone> http://haskell.org/sitewiki/images/4/44/Haskell2.png <-- quite nice, simple
01:08:41 <chrisdone> mmorrow: yeah, me too
01:09:08 <igowen> that looks very little like a lambda. or an h.
01:09:14 <mmorrow> ooh, i kinda like that one.
01:09:28 <mmorrow> yeah, but i think it'd be better with just a single orange h
01:09:31 <mmorrow> slash lambda
01:09:42 <chrisdone> I like what s/he's done with it
01:10:08 <mmorrow> yeah. i think the lambdabind is still my fav though
01:11:44 <vixey> why the haskell logol are all lambda and not -> or something
01:13:03 <Ralith> wow
01:13:12 <chrisdone> mmorrow: http://pix.nofrag.com/4/0/8/6f4b9779ee96d414ac1f557ec6f54.jpg needs more nomads
01:13:12 <Ralith> there are a lot of really good graphical designers
01:13:37 <Ralith> fav: http://haskell.org/haskellwiki/Image:Testhask.png
01:14:17 <Saizan> the lambda is too hidden there
01:14:24 <Ralith> why does it need to be obvious?
01:14:43 <Saizan> what haskell have to do with mountains?
01:14:45 <igowen> also the mountain doesn't really represent anything
01:14:54 <Ralith> it's beautiful, simple, can be tweaked to beauty at any scale from favicon to poster
01:14:57 <chrisdone> it's like a vacation advertisement
01:15:02 <chrisdone> Evaluate Your Life: Visit Haskell
01:15:06 <Ralith> Saizan: connection between high theory and well-grounded reality?
01:15:12 <Ralith> peak of its field?
01:15:13 <Ralith> etc
01:15:17 <Ralith> it's not hard to come up with symbolism.
01:15:30 <igowen> you mean it's not hard to make up symbolism that isn't there
01:15:33 <vixey> Ralith, that "connection between high theory and well-grounded reality" sounds perfect
01:15:44 <Ralith> igowen: it's there as much as anywhere else.
01:15:48 <ksf> symbolism is always made up, that's its nature.
01:15:53 <Ralith> exactly, ksf
01:15:59 <vixey> Ralith, because that is something which Cale (ho made the logo) said is one main reason they used Haskell..
01:16:17 <Ralith> heh
01:16:31 <vixey> I bet that is what it means
01:16:37 <Ralith> quite probably
01:16:53 <vixey> very mabye!
01:17:07 <igowen> the pure devil one is clearly the best, though
01:17:07 <Saizan> ksf: others need to have a vague idea of what the symbol means though
01:17:11 <Ralith> I love the gentle gradiants/high contrast.
01:17:18 <Ralith> Saizan: why?
01:17:18 <ksf> not at all.
01:17:19 <Cale> :)
01:17:22 <Ralith> I have no idea what most logos mean
01:17:26 <Ralith> plenty of them are still good
01:17:34 <Ralith> it needs to be unique and memorable; the rest is ancillary.
01:17:58 <mmorrow> chrisdone: hahaha, that one's hillarious
01:18:00 <Saizan> well if you're using symbolims and very few understand what you're trying to communicate with it you're failing
01:18:12 <Saizan> or you've done a work of art, your choice :)
01:18:18 <mmorrow> vixey: yeah, i like (->) more than lambda too
01:18:26 <Ralith> Saizan: symbolism doesn't exist to be obvious to all.
01:18:31 <Ralith> and it's also not the point of the logo
01:18:38 <Ralith> the point of the logo is to look nice and stick in the mind
01:18:39 <vixey> then again, I don't really use types in haskell much
01:18:50 <ksf> so then, what does tux denote?
01:18:56 <Ralith> hehe
01:18:58 <Ralith> exactly.
01:19:06 <Ralith> adding symbolism in is just for fun, imo
01:19:14 <Ralith> something for an interesting paragraph on an "About" page.
01:19:24 <Ralith> makes haskellers seem deep :D
01:19:34 <vegai> does import Foo.Bar () do what it looks like? I.e. import nothing?
01:19:35 <ksf> we need to figure out a recursive recronym, too.
01:19:38 <vegai> hmm, or does it import all
01:19:47 <mmorrow> , fmap ppDoc . repeat $ (ConT ''(->))
01:19:50 <lunabot>  [(->),(->),(->),(->),(->),(->),(->),(->),(->),(->),(->),(->),(->),(->),(-...
01:20:10 <chrisdone> linus torvalds is from finland; most americans think there are pengiuns in finland
01:20:18 <Saizan> vegai: nothing
01:20:18 <mmorrow> aren't there?
01:20:39 <chrisdone> mmorrow: I'm waiting for a pengiun expert to tell me :P
01:20:45 <cads> that's a lot of arrows, mmorrow
01:20:47 <ksf> they were expelled for harassing elks.
01:20:49 <profmakx> there are. in zoos.
01:20:53 <chrisdone> anyone finnish, btw? http://wiki.helsinki.fi/pages/viewpage.action?pageId=33892989
01:21:08 <vegai> Saizan: funny though that for instance importing Data.Time.Format () gives me an instance Show UTCTime :)
01:21:33 <vixey> ksf, Haskell -- A Seriously Kool Especially Lazy Language
01:21:34 <chrisdone> IRRC you can't import specific instances or decide not to?
01:21:40 <Saizan> vegai: yeah, instances can't be hidden
01:22:08 <vegai> can their importing be made implicit?
01:22:17 <Saizan> no
01:22:27 <ksf> that ought to be fixed
01:22:42 <Saizan> the module language only deals with symbols
01:23:18 <Saizan> ksf: it's a design decision to ensure consistency, i.e. there should be only one instance for each type
01:24:24 <vegai> I wonder if I asked this already... but is there way to see if a thread is alive?
01:24:45 <vegai> a simple way, I mean. Without needing to implement it myself
01:25:02 <Claudius1aximus> @hoogle ThreadId -> a
01:25:02 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
01:25:02 <lambdabot> Prelude id :: a -> a
01:25:02 <lambdabot> Data.Function id :: a -> a
01:26:23 <Claudius1aximus> don't think there is, actually - i had problems when my program exited instead of waiting for all threads to finish
01:26:29 <Claudius1aximus> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#11
01:26:49 <mmorrow> vegai: you could write `myFork' which wraps forkIO and keeps a (MVar [ThreadId]) of live threads (and inserts an IO action at the end of each thread that'll remove their threadid from the MVar
01:26:56 <vegai> Claudius1aximus: compiled with -threaded?
01:28:00 <Saizan> vegai: that won't change anything, when the main threads terminates the process exits
01:28:04 <vegai> hmm, also, GHC.Conc might have something
01:28:09 <Saizan> s/treads/thread/
01:28:30 <chylli> where can I get the doc of funDeps ? I googled it but got lots of things from haskell-cafe
01:29:13 <vegai> GHC.Conc.threadStatus :: ThreadId -> IO ThreadStatus
01:29:22 <vegai> one of whose constructors is ThreadDied
01:29:39 <vegai> I bet it's a good idea to use anything from the GHC hierarchy, right? :)
01:30:01 <mmorrow> nice, but you'd still have to keep a list in that case of all ThreadIds ever forked
01:30:23 <vegai> yeah, that's not a problem
01:30:49 <vegai> I just want a simple supervisor process that is able to relaunch threads in case they die
01:31:50 <vegai> I suppose it would almost always be a case of an error in my program if such a thing happens
01:32:03 <vegai> still, might be a bit nicer to not completely die in that case
01:32:25 <vegai> or even worse, partially die (one thread dead, others active)
01:34:42 <chrisdone> mmorrow: I like this, validating the formlet values but also passing back values (here the user's id to be saved in a session variable): http://hpaste.org/13775
01:39:46 <lepassive> can't I declare data in GHCI ??
01:40:18 <vixey> no
01:40:33 <lepassive> vixey, why not ?
01:41:23 <Cale> GHC only evaluates expressions (executing IO actions if that's what you give it), and doesn't accept declarations.
01:41:27 <Cale> GHCi*
01:41:44 <Cale> If you want to make declarations, you put them in a file, and load it
01:42:04 <lepassive> Cale, Okay thanks.
01:42:14 <Cale> Use :r to reload the file when you update it
01:43:50 <lepassive> Cale, like reload in python
01:44:09 <lepassive> Haskell and Python have alot in common they should get married :)
01:45:01 <Saizan> except that it's a bit more messy to call reload from haskell programs :)
01:45:12 <halberd> Suppose we define a height function h on a directed graph, such that h(x) = the maximum length of any path from x to a leaf of the graph, or infinity if no such path exists
01:45:19 <halberd> is computing h(x) np-complete?
01:45:52 <halberd> oh, wait a minute, the path also can't repeat nodes
01:46:09 <halberd> h(x) = the maximum length of any path from x to a leaf of the graph, where no node appears twice in this path
01:46:18 <Lamperi> a
01:47:40 <halberd> it is related to the longest path probem so i think it probably is np-complete
01:48:31 <Stephan202> I believe I read good things about "Real World Haskell" here.
01:48:59 <Stephan202> The single review at Amazon.co.uk is negative, but I doubt its complaints are fair
01:49:05 <Stephan202> buy or no buy?
01:49:08 <igowen> buy
01:49:27 <igowen> read the reviews on amazon.com if you're unconvinced
01:49:36 <igowen> or read the book itself online
01:49:36 <Stephan202> Will do now!
01:49:47 <Raynes> I love eBooks.
01:51:26 <lepassive> RWH is pretty rough, but that's what RW is all about
01:51:52 <Raynes> Nothing rough about it. Easy read.
01:52:25 * Ralith agrees, based on the relatively small amount he's gotten through
01:52:34 <Stephan202> .com the reviews are unanimously positive. Ok. Buy.
01:53:33 <doublec> awall, pegs first usage will be slow as they are lazily compiled
01:53:35 <doublec> so when you first use a peg it invokes factor's compiler
01:53:37 <doublec> which is quite slow
01:54:30 <vegai> doublec: #haskell?
01:54:38 <doublec> oops :-)
01:55:55 <lepassive> Raynes, Maybe for some one used to code haskell for more than 1 week :)
02:00:25 <Jamshid> hellooooooooooo
02:00:41 <chrisdone> hai
02:00:53 <jml> the haskell stdlib has a dichotomy function, right?
02:01:11 <jml> something that splits a list into two distinct lists based on a predicate?
02:01:45 <sjanssen> jml: Data.List.partition
02:01:51 <jml> sjanssen: thank you.
02:04:04 <Peaker> jml: you could use hoogle:
02:04:05 <Peaker> @hoogle (a -> Bool) -> [a] -> ([a], [a])
02:04:06 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
02:04:06 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
02:04:06 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
02:04:15 <Peaker> doh, its like the 5th result :)
02:04:31 <jml> Peaker: still, it's useful to know of the tool :)
02:04:39 <jml> is hoogle purely IRC based?
02:04:49 <chrisdone> @go hoogle
02:04:52 <lambdabot> http://www.haskell.org/hoogle/
02:04:52 <lambdabot> Title: Hoogle
02:04:53 <Peaker> jml: http://www.haskell.org/hoogle/
02:04:55 <Peaker> oops
02:04:56 <jml> I guess not :)
02:04:58 <Peaker> too late :)
02:05:02 <chrisdone> jml: also useful is Data.List.Split on Hackage
02:05:10 <Peaker> jml: you can also cabal install hoogle and have it available from the command line
02:05:29 <Peaker> jml: you can also use haddock to generate hoogle databases for 3rd party packages (normally hoogle only works on the Prelude and some stdlibs)
02:06:01 <chrisdone> e.g. run hoogle on your current project and hoogle your project with GHCi on Acid or something awesome like that
02:06:06 <Peaker> jml: and lastly, this ~/.ghci is useful: :def hoogle \x -> return $ ":!hoogle " ++ x
02:06:14 <Peaker> jml: so you can :hoogle from the ghci shell :)
02:06:26 <chrisdone> or that :D
02:06:35 <jml> gosh, I don't even *have* a ghci
02:06:38 * chrisdone adds that line
02:06:43 <jml> a ~/.ghci, I mean
02:06:44 <Peaker> jml: why not?
02:06:45 <Peaker> oh
02:06:50 <Peaker> jml: I only have that in my ~/.ghci
02:07:33 <jml> chrisdone: Is Acid a technical term? I'd google 'haskell acid', but I fear for my eyes.
02:07:53 <chrisdone> jml: it's just a setup for using lambdabot within GHCi
02:08:04 <Peaker> jml: haddock --hoogle on a package will generate a .txt file that you can then use: hoogle --convert on, to create a binary index. Then you can hoogle --combine all the binary indexes you built, and use "hoogle --d=your_combined_database" to look in all of them
02:10:39 <vixey> I do not understand how for: reify :: A -> [[A]] -> /\nf_A  this rule  reify () e = e  can typecheck
02:10:46 <vixey> [[A]] isn't /\nf_A.....
02:13:43 <Boney> that's awesome.  I want a hoogle for all my programming languages now.
02:14:56 <chrisdone> :D
02:15:07 * jml stops doing brain stuff for the day
02:18:43 <boegel> I must say, since I've started reading RWH, I'm falling in love with Haskell again... I forgot how beautiful it was, and how easy to write bug-free code
02:19:00 <vixey> How have you written bug-free code?
02:19:22 <vixey> I find bugs in haskell code I wrote all the time..
02:19:50 <jml> A wise man once said, "the program isn't debugged until the last user is dead".
02:20:10 <Saizan> @remember jml A wise man once said, "the program isn't debugged until the last user is dead".
02:20:11 <lambdabot> It is stored.
02:20:30 <jml> :D
02:20:47 <Saizan> vixey: then you don't have sufficiently expressive types! j/k
02:21:07 <jml> it's actually from the Twisted.Quotes file, but I'm happy to have my name attached to it.
02:21:24 <boegel> vixey: because I start out with easy, small functions
02:21:45 <chrisdone> hrmage
02:21:47 * jml is gone to eat yoghurt and engage in multimedia entertainment.
02:21:57 <boegel> vixey: and I usually code stuff in C, which is a lot harder to get right from the first time
02:22:20 <vixey> every very small simple things hide demons
02:24:33 <vixey> I am bugged also
02:24:49 <vixey> because this NbE code everyone writes about does not typecheck
02:30:06 <fasta> Is anyone using a library to generate fold implementations with e.g. TH?
02:30:19 <vixey> ?where moonpaste
02:30:19 <lambdabot> I know nothing about moonpaste.
02:30:23 <vixey> oh my god
02:30:32 <vixey> lambdabot--
02:32:18 <vixey> fasta, this is one sort of thing http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=319
02:53:21 <fschwidom> how can i define a function which returns a value uses IO?
02:53:38 <vixey> what
02:53:41 <vixey> ?
02:54:10 <fschwidom> like this: test :: Bool -> TE -> IO (), (Maybe TE)
02:54:18 <vixey> test _ _ = return ()
02:54:35 <vixey> I just ignored ", (Maybe TE)"
02:55:07 <vixey> or oshould the actualy type be: Bool -> TE -> IO (Maybe TE)
02:55:15 <vixey> or
02:55:23 <vixey> Bool -> TE -> (IO (), Maybe TE)
02:57:01 <fschwidom> it seems not to be possible to print to console and habe a 'second' return value
02:57:33 <vixey> it is
02:57:51 <EvilTerran> fschwidom, ah, i guess the type you want is ... -> IO (Maybe TE)
02:57:57 <fschwidom> ok, i understand - so i have to use a tuple
02:58:05 <EvilTerran> ... that's not a tuple
02:59:19 <EvilTerran> ?type do putStrLn "foo!"; return "bar!" -- both prints something and returns something
02:59:20 <lambdabot> IO [Char]
02:59:48 <fschwidom> i will use test :: Bool -> TE -> (Maybe (IO (), TE))
02:59:52 <fschwidom> thanks for help
03:00:01 <EvilTerran> um, okay
03:01:12 <Holle_> does anybody know graphics.soe?
03:04:17 <earthy> holle: that's been in-maintenance out-of-maintenance in-maintenance and out-of-maintenance for too many times
03:04:34 <Holle_> what do you mean?
03:04:35 <earthy> holle: I don't know it's current status.
03:04:40 <earthy> it might work, it might not
03:04:46 <earthy> if it does, it's nice
03:05:00 <Holle_> i'm using it and it works
03:05:11 <blackdog> this sounds like a dumb question, but how do i make a haskell program dump core?
03:05:21 <earthy> blackdog: why do you want to?!
03:05:22 <blackdog> i tried dividing by zero and got infinity
03:05:28 <Holle_> my problem: i want to use more than 8 predefined colours.
03:05:49 <blackdog> earthy: i want to pull the trick of doing a bunch of computation, dumping core, then editing the binary
03:05:55 <earthy> blackdog: haskell programs Do Not Dump Core
03:06:07 <blackdog> i think emacs used to do it - it's a cheap way of saving state
03:06:20 <vixey> earth how about if you deref a null pointer?
03:06:38 <earthy> vixey: hey, now you're talking unsafe shite in the IO monad.
03:07:17 <earthy> blackdog: why do you want to dump core?
03:07:47 <blackdog> i have a program that spends a lot of time reading in and building up a set of data structures. once it's read them in, it's fast as hell.
03:08:07 <blackdog> my reasoning is that i'd like to be able to save the in-memory image at that point, so i don't get the startup delay
03:08:20 <vixey> blackdog, maybe you can produced a compiled representation that is quicker to load/save
03:08:27 <blackdog> (totally non-portable, probably, blah blah blah)
03:08:28 <earthy> then write the datastructures out using Data.Binary...
03:08:38 <blackdog> vixey: yeah, that's the approach i was taking before
03:09:06 <blackdog> but it's more code, and probably still slower - ideally, i'd like to just blat the whole memory image in. can't get much faster than that.
03:09:17 <jonaskoelker> blackdog: google for unsafeIO at haskell.org; it says in its documentation that combining unsafeio with newioref and stuff can make you write a program that dumps core
03:09:18 <earthy> just write your instances of Binary for the datastructures you've built
03:09:20 <EvilTerran> blackdog, generate haskell code of a module exporting your data as a constant, then compile it? that might be similarly fast
03:09:24 <jonaskoelker> blackdog: but don't do it :P
03:09:24 <fasta> vixey:  maybe undefined pp =<< runQ (deriveFold (mkName "FoldList") $(lift =<< reify ''[])) gives me    Couldn't match expected type `Q Exp' against inferred type `t m a'
03:09:24 <fasta>     In the first argument of `(=<<)', namely `lift'
03:09:24 <fasta>     In the expression: lift =<< reify '[]
03:09:24 <fasta>     In the second argument of `deriveFold', namely
03:09:24 <fasta>         `$(lift =<< reify '[])'
03:09:52 <Sleeploud> Morning.
03:10:25 <blackdog> EvilTerran: well, it needs to read a bunch of stuff in from the filesystem in order to build the constant
03:10:56 <EvilTerran> ... so?
03:11:09 <earthy> blackdog: what you *want* is a memory-mapped representation of your data so that you can directly blocktransfer it to disk
03:11:13 <earthy> right?
03:11:44 <earthy> then why not write your data accessors on top of an array of bytes?
03:11:57 <earthy> you do have code already that uses those data accessors.
03:12:03 <Holle_> is it possible to define own colours in graphics.soe?
03:12:22 <blackdog> earthy: then i have to change my data representations to use an array of bytes
03:12:27 <blackdog> that's hardly non-invasive
03:12:45 <blackdog> i was actually thinking of writing a hackage package with one function
03:12:46 <Workybob> blackdog: so what you want... is to have an array of bytes representation for your data...
03:12:49 <Workybob> but not have to make it?
03:13:16 <blackdog> staged :: IO a -> (a -> IO b)
03:13:27 <blackdog> Workybob: pretty much.
03:13:32 <EvilTerran> Holle_, don't think so, no
03:13:48 <EvilTerran> Holle_, graphics.soe is an educational tool, not a complete graphics library
03:13:48 <Holle_> so i can only use 8 colours?
03:14:03 <Saizan> @ask dcoutts_ does this looks right to you? http://hpaste.org/13776
03:14:03 <lambdabot> Consider it noted.
03:14:12 <earthy> HOlle: looks like it
03:14:28 <EvilTerran> blackdog, here's another idea; could you store the data in a database?
03:14:29 <Saizan> good, grammar errors in a persistent message
03:15:04 <EvilTerran> blackdog, seeing as they're designed to be fast at manipulating large amounts of data
03:15:05 <blackdog> EvilTerran: I could. but it'd be a biggish change.
03:15:13 <Holle_> is there anothe library to print simple 2d graphics (polygones, lines)?
03:15:41 <blackdog> EvilTerran: but i'd stil need to pull them in to haskell datatypes at runtime anyway.
03:16:10 <earthy> gtk2hs has a cairo binding
03:16:25 <blackdog> EvilTerran: I know what i'm trying for is not terribly portable, but it's kind of a fun hack
03:16:26 <EvilTerran> blackdog, ah, well, i don't think the dumping core idea will work even if you could dump core somehow, so you're going to have to do *something* vaguely invasive
03:16:27 <earthy> see http://www.haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Cairo.html
03:16:34 <vixey> @hackage diagrams
03:16:35 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/diagrams
03:16:52 <blackdog> EvilTerran: I'm pretty sure emacs used to do something similar
03:16:56 <EvilTerran> you said
03:17:05 <blackdog> EvilTerran: whoops, so i did. sorry, getting senile
03:17:19 <earthy> and http://www.haskell.org/gtk2hs/docs/current/Graphics-Rendering-Cairo.html
03:18:01 <EvilTerran> i know you can do that sort of thing in some languages, but i don't know how fragile it is
03:18:25 <EvilTerran> or how it'd react to, say, compiled haskell not using the normal stack
03:18:25 <vixey> I thought it was a summer of code project
03:18:31 <vixey> loadable coredumps
03:19:08 * EvilTerran would rather have serializable continuations, but i imagine that's harder =/
03:19:10 <blackdog> EvilTerran: I don't think it's really a language dependent thing - maybe architecture dependent, but even just ELF would be useful
03:19:33 <Holle_> lambdabot: how do i install diagrams?
03:19:43 <earthy> cabal-install diagrams ?
03:19:43 <vixey> Holle_, do you have cabal?
03:19:48 <EvilTerran> Holle_, lambdabot is a bot
03:19:50 <EvilTerran> ?bot
03:19:50 <lambdabot> :)
03:19:55 <chrisdone> how is diagrams formed?
03:20:05 <vixey> Holle_, maybe easiest to just download the source code and: runhaskell Setup configure
03:20:20 <Holle_> what ist cabal?
03:20:27 <EvilTerran> ?where cable
03:20:28 <lambdabot> I know nothing about cable.
03:20:30 <EvilTerran> ?where cabal
03:20:31 <lambdabot> http://www.haskell.org/cabal
03:20:32 <lilac> blackdog: there's a google coredump library which i think does what you want; you could FFI to that
03:20:40 <EvilTerran> ... strange typo, that one
03:21:11 <lilac> blackdog: http://code.google.com/p/google-coredumper/
03:21:13 <blackdog> lilac: that looks promising, thanks
03:21:19 <blackdog> yep, looking at it now :)
03:21:36 <lilac> blackdog: there's another program somewhere which'll turn an elf coredump into an elf binary
03:21:49 <blackdog> lilac:  god bless the internet
03:21:55 <Saizan> ?hackage cabal-install
03:21:56 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
03:22:22 <Saizan> Holle_: download the tarball from there, you can use the bootstrap.sh script for its dependencies if you're on unix
03:22:38 <Holle_> i am using xp
03:23:41 <Holle_> so i have to run setup.hs?
03:23:49 <Saizan> Holle_: then execute runghc Setup configure from inside the directory where you've unpackeed the tarball
03:24:14 <Saizan> Holle_: it'll tell you some dependencies are missing (only 4) and you've to install those similarly
03:25:02 <Saizan> ah, to complete the installarion you've to also run "runghc Setup build" and "runghc Setup install"
03:25:13 <Holle_> saizan: sorry i don't undestand what you mean. i am using win xp und unpacked cabal
03:25:19 <jpcooper> that sounds like a transformer
03:26:09 <Saizan> Holle_: you've to type those commands in a cmd.exe prompt
03:26:30 <Saizan> Holle_: from the directory where the sources of cabal-install are
03:26:51 <fasta> vixey: ok, I used the wrong lift, but then it still needs a Lift Info instance, which doesn't seem to exist.
03:27:11 <vixey> maybe needs a newer TH or soething.. I don't know much about it
03:27:52 <Holle_> "runghc Setup" throws "no command given"
03:29:21 <Holle_> "runghc Setup build/install" throws both "Setup: Run the configure command first"
03:30:29 <bohdan> can I create hierarchical types in haskell? e.g. data X = A | B@(B1 | B2) , and then write 'foo B1 = 3; foo B2 = 4; bar B = 5'
03:30:31 <Saizan> Holle_: sorry, i didn't use quotes the first time, the command is "runghc Setup configure"
03:30:47 <Lemmih> Holle_: Try running the configure command first.
03:30:58 <Holle_> it tried "runghc Setup configure" and it says "... missing: HTTP >= 3000 <3002, zlib >=0.4 && <0.6
03:32:32 <Saizan> Holle_: ok, so you need to install those too, once you've cabal-install working this part is handled automatically
03:32:51 <Holle_> where do i get it?
03:33:03 <Saizan> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HTTP-3001.1.5
03:33:21 <Saizan> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib
03:33:28 <Lemmih> bohdan: data X = A | B; data B = B1 | B2; foo (B B1) = 3; foo (B B2) = 4; foo (B _) = 5
03:33:47 <Lemmih> bohdan: Er, data X = A | B B
03:34:19 <lilac> foo (B B1) = 3; foo (B B2) = 4; foo A = 5
03:34:52 <bohdan> nice, thanks
03:35:14 <Holle_> "runghc Setup install" -> permission denied (using vista=
03:36:00 <dnul> I'm looking for a function that given another function f an integer I, and some parameter x,  apply I times f
03:36:03 <Saizan> Holle_: ah, then you want "runghc Setup configure --user" and then build and install again
03:36:19 <dnul> like f (  f ( f ( x) ) )  for f 3 x
03:36:33 <Saizan> Holle_: --user makes it install in user-specific directories, so you shouldn't need privileges
03:36:44 <lilac> dnul: foldr (.) id (replicate n f)
03:36:55 <dnul> lilac: thanks
03:37:13 <lilac> > foldr (.) id (replicate 5 f) x :: Expr
03:37:15 <lambdabot>   f (f (f (f (f x))))
03:37:21 <Holle_> Setup: Error: Could not find module: Network.Stream with any suffix: ["hi"]
03:37:49 <Saizan> > iterate f x !! 5
03:37:50 <lambdabot>   f (f (f (f (f x))))
03:37:56 <lilac> @src Endo
03:37:57 <lambdabot> Source not found. Sorry.
03:38:09 <Saizan> Holle_: then there's something wrong in your ghc installation
03:38:14 <lilac> @hoogle Monoid m => Int -> m -> m
03:38:15 <lambdabot> Prelude scaleFloat :: RealFloat a => Int -> a -> a
03:38:15 <lambdabot> Prelude replicate :: Int -> a -> [a]
03:38:15 <lambdabot> Data.List replicate :: Int -> a -> [a]
03:38:35 <lilac> > mconcat (replicate 5 (Endo f))
03:38:36 <lambdabot>       No instance for (Show (Endo a))
03:38:36 <lambdabot>        arising from a use of `show' at ...
03:38:36 <dcoutts> @Arr!
03:38:37 <lambdabot> Aye Aye Cap'n
03:38:45 <lilac> > unEndo $ mconcat (replicate 5 (Endo f))
03:38:46 * dcoutts reads Saizan's hpaste
03:38:46 <lambdabot>   Not in scope: `unEndo'
03:38:55 <Holle_> ok. i try to reinstall ghc
03:39:22 <lilac> > mconcat (replicate 5 (Endo f)) `appEndo` x
03:39:24 <lambdabot>   f (f (f (f (f x))))
03:39:35 <Saizan> @yow
03:39:35 <lambdabot> Yow!  I want to mail a bronzed artichoke to Nicaragua!
03:39:51 <Gracenotes> I just realized that the term "bag of tricks" is a misnomer. It's more like a set of tricks, since it shouldn't have any duplicate elements. As a free monoid, that is, it's idempotent.
03:39:59 <Gracenotes> yay Haskell for expanding my mind
03:40:31 <Gracenotes> >.>
03:40:35 <fasta> How do I show a (Quasi m) => m (Maybe [Dec])?
03:40:36 <Cale> s/free//
03:40:39 <Saizan> mmh, a free monoid has duplicates, no?
03:41:13 <Gracenotes> Cale: that too
03:41:23 <Saizan> :t unQ
03:41:24 <lambdabot> Not in scope: `unQ'
03:41:31 <Saizan> > src ''unQ
03:41:33 <lambdabot>   <no location info>:
03:41:33 <lambdabot>      lexical error in string/character literal at chara...
03:41:34 <Saizan> , src ''unQ
03:41:42 <lunabot>  luna: Not in scope: type variable `unQ'
03:42:21 <Saizan> fasta: i usually use something like $(val >>= lift . show)
03:42:49 <vixey> Gracenotes, ... lol (about "bag" of tricks)
03:44:34 <Gracenotes> vixey: apparently now I can say "commutative idempotent free monoid of tricks"
03:44:44 <Gracenotes> although I'm not sure of the degree to which it
03:44:47 <Gracenotes> er, it's free
03:45:02 <Gracenotes> what would a non-free monoid look like?
03:45:17 <vixey> isn't String a non free monoid?
03:45:18 <fasta> Saizan: what's val? I tried substituting val for the value of the type above, but that certainly doesn't work.
03:45:47 <fasta> Saizan: never mind
03:45:57 <fasta> Saizan: Control.Monad.Trans was in the way again :(
03:46:32 <Gracenotes> vixey: hm... so a list of strings would be free, then.
03:46:33 <dcoutts> Saizan: looks ok
03:46:40 <cads> I'd like to come up with a scheme for representing a tree structures which would be unique for trees of unique topology, regardless of the ordering that the trees might have in their native representations.
03:46:52 <Holle_> after reinstalling ghci the same problem: Setup: Error: Could not find module: Network.Stream with any suffix: ["hi"]
03:47:02 <Gracenotes> I'm not sure if a skill would be a free or nonfree monoid. On one hand, a skill is made up of a sequence of sub-skills
03:47:02 <Saizan> dcoutts: thanks :)
03:47:20 <Gracenotes> on the other hand the effect of the skill is unique
03:47:34 <vixey> cads, I bet it's not possible using haskells 'data'
03:47:48 <cads> In the case that I'm thinking of, the trees are directory trees which have been stripped of directory names and contents, but might still be ordered according to the alphabetical ordering of the directories
03:47:57 <Saizan> ?hoogle stringL
03:47:58 <lambdabot> Language.Haskell.TH stringL :: String -> Lit
03:47:58 <lambdabot> Language.Haskell.TH.Lib stringL :: String -> Lit
03:47:58 <lambdabot> Language.Haskell.TH StringL :: String -> Lit
03:48:35 <Gracenotes> eh, it's all abstract nonsense anyway ;)
03:48:47 <Saizan> fasta: in that case it's the same as "return . LitE . StringL", btw
03:48:49 <cads> sorry, this isn't about how I'd do something like this is haskell, but more along the lines of how would something like this be formulated in general
03:49:28 <dcoutts> Saizan: I recently changed the solver interface a bit, to pass constraints separately from targets, which lets us have constraints on packages which are not direct targets
03:49:29 <fasta> Saizan: I got it working already without that. I even got it to pretty print it, so I can actually see what it is generating :)
03:49:36 <fasta> Saizan: thanks
03:49:51 <dcoutts> Saizan: and I generalised constraints to include flags and installed status
03:50:24 <dcoutts> Saizan: since internally the solver has to be able to cope with requiring an installed version, if it's a dependency of an installed package we're picking
03:51:10 <lilac> vixey: [] is the free monoid over a type, so String is the free monoid over Char.
03:51:22 <dnul> lilac: Regarding  foldr (.) id (replicate n f)  , it is possible that f receives more than 1 parameter?
03:51:32 <vixey> ok
03:51:34 <dcoutts> Saizan: see type DependencyResolver in Distribution/Client/Dependency/Types.hs
03:51:39 <vixey> I have to look up the definition because I'm confused
03:51:52 <Gracenotes> lilac: hm. so what would be a non-free monoid in Haskell (if any)?
03:51:54 <cads> I can't think of an ordering scheme that isn't ambiguous for certain pathological cases
03:52:10 <lilac> Gracenotes: Maybe
03:52:15 <cads> anyways, I apologize if the question was too off topic, vixey, all
03:52:26 <vixey> cads, I don't think so
03:52:32 <vixey> cads, but I do think it's impossible
03:52:35 <Saizan> dcoutts: ah, right, but i think those can be subsumed by either restricting the initial AvailablePackages or having a sufficiently rich Preferences
03:52:41 <baaba> dnul, if f :: a -> a -> a then what does the second iteration get as its parameters?
03:52:50 <lilac> Gracenotes: indeed, any monoid other than [] is probably non-free
03:53:02 <dnul> lilac: ahaha , true , thx
03:53:07 <dcoutts> Saizan: not in preferences, these are actual constraints
03:53:12 <dnul> lilac: rookie mistake
03:53:30 <dcoutts> Saizan: but yes, many constraints can be pre-applied to the available and installed packages
03:53:38 <Gracenotes> lilac: couldn't Maybe be considered similar to a list with zero or one elements? Isn't that free?
03:53:46 <dcoutts> Saizan: however I'm not doing it that way because I want to generate decent error messages
03:54:21 <lilac> Gracenotes: the "zero or one elements" makes it not be free.
03:54:28 <dcoutts> Saizan: and making the constraints explicit to the solver allows it to explain why it did or did not do something and relate it back to the reasons for the given constraints
03:55:26 <polveroj> Gracenotes: it's not free because some terms are identified with others (Nothing `mappend` Nothing == Nothing).  The only equalities in a free monoid are the ones entailed by the monoid laws
03:56:05 <Gracenotes> but also [] ++ [] == []...?
03:56:16 <Gracenotes> hm, I must be missing something from the definition
03:56:19 <polveroj> Gracenotes: oops, I mean (Just 1 `mappend` Just 2 == Just 1)
03:56:24 <dcoutts> Saizan: for example, instead of removing broken packages from the installed package set, we could instead add a constraint not to pick that version and attach a reason to the constraint. Then if the solver finds a conflict it can explain why it did not pick the broken package, or why it had to re-install it or whatever.
03:56:29 <bohdan> what is a good way to test this function? http://hpaste.org/13777
03:56:33 <polveroj> Gracenotes: the identity is allowed to be an identity =/
03:56:40 <bohdan> quickcheck doesn't look appropriate here
03:56:50 <Saizan> dcoutts: right, mine was mostly an outline of the problem to see what are the main requirements for the solver engine
03:56:51 <vixey> bohdan, testing it for what?
03:56:54 <fasta> I get TH: Illegal variable name: `A'  for http://paste.debian.net/25594/. I don't see why A would be illegal, other than that A is a upper case letter, but assuming the Fold library works, it shouldn't generate it.
03:56:57 <bohdan> vixey, unit testing
03:57:05 <vixey> bohdan, for?
03:57:22 <Gracenotes> polveroj: ah, so in a free monoid, x*y=x can only work if y is the identity?
03:57:26 * vixey suggests renaming abs into clamp
03:57:43 <Gracenotes> * meaning mappend
03:58:25 <bohdan> vixey, I don't understand your question
03:58:35 <lilac> vixey: i'd expect "Ord a => clamp :: a -> (a, a) -> a; clamp x (l,u) = min u (max x l)"
03:58:38 <bohdan> testing that damage X Y Z = a
03:58:53 <vixey> bohdan, are you unit testing because it's the right thing to do, or because you want to get some information from doing this operation?
03:59:27 <vixey> lilac, that's a decent function but not applicable here
03:59:30 <Saizan> dcoutts: btw, do we still recompile the same version of an installed package if needed? that's not entirely safe
03:59:54 <cads> vixey, I think the problem is equivalent to enumerating the possible topologies of trees, and that should be tractable.. should be fun :D
04:00:10 <vixey> cads, ok true.
04:00:35 <vixey> cads, data TopologicallyCanonicalTrees = Zero | Succ TopologicallyCanonicalTrees
04:00:56 <cads> haha
04:00:59 <vixey> cads, but I think it's impossible to have canonical representations which hold actual structure.. I guess that cannot be made formal though
04:01:35 <cads> I'm not entirely sure how you mean that
04:01:36 <bohdan> vixey, testing as in "testng to make sure the implementation works for the few sample cases I come up with"
04:01:38 <lilac> vixey: my point is, renaming abs to clamp might cause confusion
04:01:52 <ksf> I just managed to mess up my X font rendering using haskell.
04:01:53 <bohdan> vixey, something one would do with ghci, but make it automated
04:02:00 <jonaskoelker> :t mappend
04:02:01 <lambdabot> forall a. (Monoid a) => a -> a -> a
04:02:14 <vixey> bohdan: ok if you have a bunch of input/output specifications then yeah just use quickcheck
04:02:18 <vixey> @check  3 == 2 + 1
04:02:19 <lambdabot>   "OK, passed 500 tests."
04:02:21 <jonaskoelker> is mappend similar to mplus?
04:02:22 <ksf> If I still had xcompmgr running, I'd see a black screen and a cursor.
04:02:46 <vixey> lilac, but calling it abs in the first place is confusion
04:03:08 <Saizan> jonaskoelker: in spirit, but they might do different things for the same type
04:03:11 <bohdan> vixey, if you look at the function, it's pretty hard to determine what would the output be without pretty much repeating the function
04:03:17 <bohdan> vixey, or maybe I don't get it
04:03:27 <jonaskoelker> Saizan: do you have an example where they do do different things?
04:03:32 <vixey> bohdan, OK you lost me
04:03:42 <Saizan> > Just "a" `mappend` Just "b"
04:03:44 <lambdabot>   Just "ab"
04:03:47 <vixey> bohdan, You don't have several examples of input/output as a specification?
04:03:52 <Saizan> > Just "a" `mplus` Just "b"
04:03:54 <lambdabot>   Just "a"
04:04:16 <vixey> bohdan, why can't you take the definition as *the* definition -- it is correct, don't bother testing it
04:04:33 <bohdan> vixey, from what I understand about quickcheck, it makes sense to check if you know an invariant about the output
04:04:56 <vixey> bohdan: I think when you said:  <bohdan> vixey, testing as in "testng to make sure the implementation works for the few sample cases I come up with"
04:04:57 <bohdan> @check \a -> (a * 3) `mod` 3 == 0
04:04:59 <lambdabot>   "OK, passed 500 tests."
04:05:01 <vixey> bohdan, that I misunderstood you a bit
04:05:12 <vixey> bohdan, is the bit in quotes what _quickcheck_ does?
04:05:21 <bohdan> vixey, not quite
04:05:30 <Saizan> there's HUnit for unit testing
04:05:38 <Gracenotes> :t (Just "a" `mappend`)
04:05:39 <lambdabot> Maybe [Char] -> Maybe [Char]
04:05:48 <jonaskoelker> Saizan: cool, thanks
04:05:49 <bohdan> vixey, the example you gave is a bit pointless, why do you need to test 3 == 2 + 1 500 times? 1 would be enough
04:05:59 <Gracenotes> :t (Just 'a' `mappend`)
04:06:01 <lambdabot>     No instance for (Monoid Char)
04:06:01 <lambdabot>       arising from a use of `mappend' at <interactive>:1:0-19
04:06:01 <lambdabot>     Possible fix: add an instance declaration for (Monoid Char)
04:06:08 <vixey> bohdan, yeah I agree that useing quickcheck is pointless
04:06:50 <bohdan> @bots
04:06:50 <lunabot>  :)
04:06:50 <lambdabot> :)
04:07:00 <bohdan> ok, just checking you, vixey :)
04:07:01 <icqnumber> :)
04:07:31 <vixey> funny
04:08:12 <jonaskoelker> using quickcheck is pointless?
04:08:18 <vixey> I stil think you are just testing because you got told it's the right thing to do, because you seem to have no idea what you're doing it /for/
04:09:00 <Saizan> vixey: he's testing it because he doesn't have a formal specification that's simpler than the implementation
04:09:02 <bohdan> vixey, duh
04:09:14 <bohdan> Saizan, exactly
04:09:17 <vixey> Saizan, that doesn't make sense
04:09:23 <Saizan> vixey: it happens.
04:09:23 <bohdan> Saizan, but hUnit is a bit verbose
04:09:25 <polveroj> Gracenotes: ok, so the Monoid instance on Maybe isn't what I thought it was.
04:09:37 <vixey> Saizan, you can't test a definition, you can prove expected properties about it.
04:09:38 <Gracenotes> hm, not quite what I thought either
04:09:44 <bohdan> vixey, look at the code, http://hpaste.org/13777
04:10:13 <Saizan> vixey: he's testing its code, which is not the same thing as the definition
04:10:48 <vixey> for example if f I defined 0 + n = n; (S m) + n = S (m + n), there's no test data, but I can prove things like x + y = y + x to be sure this is really an addition
04:11:04 <dcoutts> Saizan: right, it's a fine outline and yes we do still rebuild the same version of an installed package against different deps, it's not safe.
04:11:45 <bohdan> vixey, imagine you wrote a square root implementation for megacomplex numbers
04:11:48 <Saizan> vixey: that works because you can tell that your (+) is the right one
04:12:18 <bohdan> ok maybe that was a bad example
04:12:31 <bohdan> imagine you wrote md5 hash function
04:12:45 <bohdan> how do you check that it's indeed md5 and not, say, sha1?
04:12:46 <Saizan> he could still prove properties about its code..
04:13:24 <vixey> I don't know. I can't be bothered talking to bohdan anymore because they called me a robot though
04:13:30 <jonaskoelker> is there a piece of software which will try to prove theorems about my code?
04:14:11 <jonaskoelker> I'd like a _proof_ that my interpreter's optimization phase is sound ...
04:14:12 <vixey> which I'm probably supposed to just ignore but I found it kind of offensive
04:14:23 <ksf> jonaskoelker, learn agda.
04:14:49 <fasta> jonaskoelker: what kind of proof? One that can be machine checked?
04:14:55 <vixey> jonaskoelker: in something like Coq you could give an interpretation and show that  interpret program = interpret (optimize program)
04:14:55 <bohdan> wtf was that then, <vixey> bohdan, yeah I agree that useing quickcheck is pointless
04:15:38 <jonaskoelker> fasta: one that is machine-generated
04:15:59 <bohdan> vixey, hey sorry if it got you offended, you were just trying to help
04:16:05 <jonaskoelker> fasta: even if the program is main = putStrLn "your program is correct", I'd trust it :D
04:16:06 <vixey> jonaskoelker, (of course you could do it by hand as well, but with a computer you can automate the proof search to some extent)
04:16:13 * bohdan is not funny today
04:16:23 <halberd> jonaskoelker: you can do an informal proof for the tricky bits
04:16:46 <fasta> jonaskoelker: computers are not fast enough to do this for non-trivial things and in general it is probably not possible.
04:16:50 <vixey> jonaskoelker, (I suppose I am not visible to you ?)
04:16:57 <jonaskoelker> you are
04:17:04 <jonaskoelker> I was reading about Coq
04:17:14 <halberd> jonaskoelker: just put invariants in your code (in comments) stating what must be true of various variables at certain points
04:17:22 <halberd> and prove that your invariants are correct
04:17:23 <jonaskoelker> my leaky bucket filter of information consumption got filled
04:17:31 <fasta> jonaskoelker: if you have a Deep Thought machine at your disposal it will work, though.
04:17:39 <vixey> halberd, hoare logic for pure functional programming? :p
04:17:49 <vixey> halberd, I don't think that is a common approach..
04:18:05 <jonaskoelker> fasta: doesn't Gödel's incompleteness theorems show that indeed it isn't possible?
04:18:20 <halberd> well vixey you can put invariants in functional code too... they would be about the values of arguments to the function
04:18:35 <halberd> I have a habit of writing invariants if code is particularly tricky vixey
04:18:37 <vixey> halberd, oh! like  Just Bool  and stuff, I get you
04:18:48 <vixey> oopn
04:18:51 <vixey> Maybe Bool*
04:19:17 <halberd> well you might have a loop invariant stating that "at the beginning of the loop, y = x * z"
04:19:24 <halberd> in an imperative language
04:19:28 <vixey> if you used a while loop yeah
04:19:36 <halberd> so you can just do the same thing in a functional language, only x, y, and z are arguments to the function
04:19:41 <halberd> and you state that you assume y = x * z
04:19:44 <jonaskoelker> vixey: dvorak for the win? :)
04:19:45 <vixey> but in pure fp why you would bother? I don't understand
04:20:05 <vixey> because doesn't it pop out automatically from the induction step?
04:20:06 <halberd> well the code might be tricky enough that it's hard to understand without them
04:20:21 <vixey> jonaskoelker, I still suck at typing though :p,, but I am improving slowly
04:20:41 <halberd> what induction step?
04:20:42 <jonaskoelker> vixey: cool.  Hang around in #dvorak and stay silent like the rest of us :)
04:20:55 <jonaskoelker> halberd: the reiteration/recursion
04:21:16 <halberd> no I'm wondering what vixey meant
04:21:58 <vixey> halberd, just thinking ilke, if you wanted to prove  P(x) holds after the loop   while(...){...}  then you would use invariants, but if you wanted to prove  P(f(y))  the for all your induction steps, you'd have the 'invaniant' as a hypothesis no?
04:22:32 <vixey> (assuming f is some recursive function)
04:22:56 <halberd> I don't know what you mean by P(f(y))
04:23:08 <vixey> halberd, P is some property
04:23:12 <halberd> listen it's the same thing, you can translate a while loop directly into a tail recursive function
04:23:16 <eu-prleu-peupeu> hello Haskl3z0rs
04:23:28 <halberd> the invariants are exactly the same
04:23:30 <vixey> halberd, if you say so..... seems different to me
04:23:38 <jonaskoelker> eu-prleu-peupeu: h3ll0
04:23:53 <halberd> the only difference between a tail recursive function, and a while loop, is notation
04:24:13 <vixey> halberd, I don't see why that is relevant, f doesn't have to be tail recursive
04:24:40 <eu-prleu-peupeu> hey jonaskoelker, you could change your nick to be "jonasskywalker"
04:24:45 <vixey> halberd, of course everything can be made tail recursive and turned into while loops, but I think when you do that transformation you mutilate the program and the proof is necessarily going to be _differen_
04:25:07 <halberd> if f happens to be tail recursive, then if you write it as a while loop you can write invariants about the loop... those same invariants apply to the tail recursive form
04:25:09 <jonaskoelker> while condition do body end --> f stateofworld = if condition then f(body(stateofworld)) else stateofworld
04:25:20 <jonaskoelker> eu-prleu-peupeu: or I could not :)
04:25:29 <halberd> if f isn't tail recursive then you write other things that "should be true" for certain values of the arguments, then try to prove them
04:25:36 <vixey> halberd, seems like a reasonable conjecture
04:25:48 <ksf> I get a 10 fps difference with a simple fps display between glut and freeglut.
04:25:48 <vixey> halberd, I wouldn't believe it without proof though
04:26:04 <jonaskoelker> ksf: who's winning?
04:26:06 <halberd> what wouldn't you believe without proof?
04:26:21 <ksf> freeglut.
04:26:25 <chessguy_work> 'morning
04:26:32 <vixey> halberd, that the proofs about recursive and while loop based programs use the same invariants
04:27:12 <vixey> halberd, I'm sure it would work for certain recursion patterns but I suspect it's not true in general
04:27:17 <ksf> still, 100fps isn't much considering that glxgears gives 264.
04:27:25 <vixey> halberd, it's an interesting connection though
04:27:26 <halberd> for tail recursion the loop is just the same as the function
04:27:41 <halberd> for other kinds of recursion there isn't a direct correspondence
04:28:47 <halberd> a while loop written in an imperative language has several variables which are updated during the body of the loop, and you can apply an invariant to the beginning of the loop
04:29:12 <halberd> the corresponding tail recursive function has several arguments (instead of mutable variables) which are updated to different values with each recursive call of the function
04:30:15 <halberd> if the tail recursive function does the same thing as the while loop, the values of the variables on a given iteration of the while loop are the same as the values of the arguments at the corresponding stack frame for the function
04:31:01 <halberd> so anything you say in an invariant about the variables in the while loop is also going to apply to the values of the arguments in the recursive function
04:31:08 <halberd> because their values are the same
04:32:04 <vixey> halberd, if you have P(f(x)) and you know g = f, then you have P(g(x)), say g is the while loop version, then they have the same proof (except for one equational rewrite)
04:32:37 <vixey> halberd, but when you try to erase that rewrite rule, (like what we're talking about), you come into all these technicalities
04:32:42 <ksf> dammit I don't get heap profiles.
04:33:10 <halberd> anyway I'm not an expert on informal verification, it's just something I do to make sure I understand how a given function works and make sure that it's correct
04:33:34 <vixey> halberd, hehe me neither this is just an interesting thing to wonder about
04:34:30 <ksf> ...and I'm slowly, but steadily leaking memory.
04:35:18 <halberd> I don't see where your doubt is coming from
04:36:01 <halberd> what technicalities?
04:36:17 <halberd> what could go wrong? (famous last words)
04:39:12 <FunctorSalad_> is there a way to set custom defaulting rules in ghc?
04:39:22 <FunctorSalad_> (for one's own typeclasses)
04:40:04 <augustss> @pl f y z = x >>= \ x' -> foo2 (f x') y z
04:40:04 <lambdabot> f = fix (((((x >>=) .) . flip) .) . flip . (foo2 .))
04:40:31 <augustss> @pl foo3 f x y z = x >>= \ x' -> foo2 (f x') y z
04:40:31 <lambdabot> foo3 = flip ((.) . (.) . (>>=)) . (flip .) . flip . (foo2 .)
04:40:33 <FunctorSalad_> say, f :: (Thing a) => Int -> a, g :: (Thing a) => a -> String... I'd like to be able to write g . f without annotations
04:44:46 <FunctorSalad_> > (1/0) :: Double
04:44:48 <lambdabot>   Infinity
04:44:52 <FunctorSalad_> > Infinity
04:44:53 <lambdabot>   Not in scope: data constructor `Infinity'
04:44:56 <FunctorSalad_> :)
04:45:22 <FunctorSalad_> > (read "Infinity") :: Double
04:45:24 <lambdabot>   Infinity
04:46:08 <vixey> weird
04:46:19 <vixey> I hate read now
04:46:38 <vixey> what on earth is read for ?
04:46:39 <FunctorSalad_> why vixey?
04:46:51 <FunctorSalad_> e.g. for parsing numbers
04:46:56 <chessguy_work> > read "3" :: Int
04:46:57 <lambdabot>   3
04:47:00 <vixey> I don't use it for that!
04:47:07 <chessguy_work> @hoogle Infinity
04:47:08 <lambdabot> package infinity
04:47:32 <FunctorSalad_> what do you use then, vixey?
04:47:47 <chessguy_work> @src Read
04:47:48 <lambdabot> class Read a where
04:47:48 <lambdabot>   readsPrec    :: Int -> ReadS a
04:47:48 <lambdabot>   readList     :: ReadS [a]
04:47:48 <lambdabot>   readPrec     :: ReadPrec a
04:47:48 <lambdabot>   readListPrec :: ReadPrec [a]
04:47:49 <vixey> whatever parser library I have imported
04:48:12 <chessguy_work> so hide it. problem solved
04:48:22 <bohdan> @check \a -> read (show a) == a
04:48:23 <lambdabot>   "OK, passed 500 tests."
04:48:54 <FunctorSalad_> btw is there any safe read in the stdlib?
04:49:04 <FunctorSalad_> (there are some in the "safe"package)
04:49:11 <chessguy_work> safe how?
04:49:18 <FunctorSalad_> pure error handling
04:49:19 <chessguy_work> complete you mean?
04:49:21 <vixey> @let flip = (==0) . (`mod`1000)
04:49:22 <lambdabot>  Defined.
04:49:24 <vixey> @check flip
04:49:26 <lambdabot>       Overlapping instances for Show (a -> b -> c)
04:49:26 <lambdabot>        arising from a use ...
04:49:43 <vixey> @undef
04:49:48 <vixey> @let flipACoin = (==0) . (`mod`1000)
04:49:49 <lambdabot>  Defined.
04:49:58 <vixey> @check flipACoin
04:49:58 <lambdabot>   Not in scope: `flipACoin'
04:50:03 <vixey> brrrrr.....
04:50:07 <FunctorSalad_> readSafe :: (MonadError e m, Error e) => String -> m a      -- appropriate signature imho
04:50:09 <chessguy_work> @check L.flipACoin
04:50:10 <lambdabot>       Failed to load interface for `L':
04:50:10 <lambdabot>        Use -v to see a list of the fi...
04:50:23 <vixey> @check let flip = (==0) . (`mod`1000) in flip
04:50:24 <lambdabot>   "Falsifiable, after 0 tests:\n-3\n"
04:50:37 <vixey> > (`mod` 1000) (-3)
04:50:38 <lambdabot>   997
04:50:39 <chessguy_work> strange
04:50:42 <FunctorSalad_> @src MonadError
04:50:43 <lambdabot> class (Monad m) => MonadError e m | m -> e where
04:50:43 <lambdabot>     throwError :: e -> m a
04:50:43 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
04:50:45 <vixey> @check let flip = (/=0) . (`mod`1000) in flip
04:50:46 <lambdabot>   "Falsifiable, after 1 tests:\n0\n"
04:50:48 <vixey> @check let flip = (/=0) . (`mod`1000) in flip
04:50:49 <lambdabot>   "Falsifiable, after 1 tests:\n0\n"
04:50:51 <vixey> awww
04:51:01 <vixey> it's not 50:50 chance
04:51:12 <vixey> is there anything which is 50:50?
04:51:31 <chessguy_work> change the 1000 to a 0?
04:51:34 <chessguy_work> err, to a 2
04:52:29 <vixey> @check let flip = (/=0) . (`mod`2) . (+2) . abs in flip
04:52:30 <lambdabot>   "Falsifiable, after 0 tests:\n-2\n"
04:52:38 <bohdan> > randomRIO (0, 1)
04:52:40 <lambdabot>   * Exception: "<IO Integer>"
04:52:51 <vixey> @check let flip = (/=0) . (`mod`1000) . (+1000) . abs in flip
04:52:52 <lambdabot>   "Falsifiable, after 1 tests:\n0\n"
04:57:20 <jonaskoelker> @check let flip = (==0) . (`mod` 17) . (+17) . abs in flip
04:57:21 <lambdabot>   "Falsifiable, after 0 tests:\n1\n"
04:57:34 <jonaskoelker> @check let flip = (/=0) . (`mod` 17) . (+17) . abs in flip
04:57:35 <lambdabot>   "Falsifiable, after 2 tests:\n0\n"
04:57:57 <jonaskoelker> yay, fun with the lambdabot
04:58:51 <boegel> I haven't been following the Haskell mailing list lately... whatever happened to the Haskell benchmark suite, hbench? did they finish up on it?
04:59:10 <chessguy_work> boegel, haven't seen anything about it lately
04:59:50 <augustss> @pl \ y -> x >>= \ x' -> foo1 (f x') y
04:59:50 <lambdabot> (x >>=) . flip (foo1 . f)
05:01:04 <augustss> @pl \ y z -> x >>= \ x' -> foo2 (f x') y z
05:01:04 <lambdabot> ((x >>=) .) . flip . flip (foo2 . f)
05:03:36 <fasta> jonaskoelker: I already said "and in general it is probably not possible". The probably refers to whether or not hyper-computation is possible and whether or not the universe has been seeded with a non-computable string.
05:04:58 <chessguy_work> wow, sounds like i missed an...interesting conversation
05:07:58 <fasta> chessguy_work: reading a book on advanced vector calculus is probably interesting; that way you can actually understand what people are trying to do :)
05:08:19 <fasta> more*
05:08:50 <vixey> vector calculus ?
05:08:59 <vixey> that's something I never hear people talk about
05:08:59 <centrinia> more advanced vector calculus
05:10:00 <FunctorSalad_> why does quickCheck check an argument-less property 100 times?
05:10:15 <FunctorSalad_> (or how to avoid it?)
05:13:01 <vixey> why is it bad to check it 100 times?
05:13:17 <FunctorSalad_> efficiency
05:13:28 <vixey> it only does the actual computation once
05:13:55 <centrinia> That's lazy. :)
05:14:12 <fasta> It will probably do the computation once, but does evaluate something 100 times.
05:14:19 <mercury^> Needy.
05:14:34 <fasta> So, if you increase the number to 1 billion, you will notice it.
05:14:38 <FunctorSalad_> vixey: even when using the quickCheck script? I can see the counter counting up to 100 ;)
05:15:27 <FunctorSalad_> nevermind, the output slowness is emacs-induced
05:16:11 <FunctorSalad_> mercury^: needy? what?
05:17:46 <mercury^> FunctorSalad_: centrinia said "that's lazy", but it is the behaviour of call by need, whereas lazy evaluation can also be implemented with call by name.
05:18:39 * EvilTerran thought "lazy evaluation" was another name for call-by-need, and that they were both implementation approaches for non-strict semantics
05:18:53 <FunctorSalad_> mercury^: I don't know the difference between c-b-need and c-b-name :(
05:19:10 <EvilTerran> ("they both" being lazy evaluation and c-b-name)
05:19:36 <FunctorSalad_> I thought the name was only evaluated once needed :)
05:20:02 <lilac> EvilTerran: i thought lazy evaluation, call-by-name and call-by-need were all semantically equivalent
05:20:23 <mercury^> EvilTerran: hmm, I thought lazy evalution was another name for non-strict.
05:20:29 <vixey> lilac, what's call by name vs call by need?
05:20:40 <vixey> lilac,isn't one of those = lazy?
05:20:42 <EvilTerran> lilac, indeed, that's what i thought (in a side-effect-free setting), but i thought lazy evaluation and call-by-need were synonymous
05:21:11 <EvilTerran> call-by-name: (\x -> x + x) (1+1) = (1+1) + (1+1) = 2 + (1+1) = 2 + 2 = 4
05:21:13 <mercury^> EvilTerran: nah, call by need means the specific sharing strategy.
05:21:25 <kaol> @src foldr1
05:21:26 <lambdabot> foldr1 _ [x]    = x
05:21:26 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
05:21:26 <lambdabot> foldr1 _ []     = undefined
05:21:29 <vixey> mercury^, and lazy means?
05:21:34 <vixey> vs non-strict
05:21:41 <mercury^> They are the same I think.
05:21:44 <EvilTerran> call-by-need: (\x -> x + x) (1+1) = (let x = 1+1 in x + x) = (let x = 2 in x + x) = 2 + 2 = 4
05:22:48 <EvilTerran> the exact meanings of jargon will change from paper to paper and book to book, anyway
05:22:58 <EvilTerran> just define your terms before you start using them :P
05:23:22 <lilac> EvilTerran: i thought call-by-name and call-by-need are both implementation strategies for non-strict evaluation
05:23:34 <lilac> the former being uncached and the latter being cached
05:23:36 <EvilTerran> lilac, i said that a minute ago
05:23:41 <mercury^> Or don't use "lazy evalution" and stick to strict/non-strict and call-by-*
05:23:42 <EvilTerran> apart from the caching bit
05:23:49 <vixey> EvilTerran, it's really not widely agreed on?
05:24:05 <EvilTerran> * EvilTerran thought "lazy evaluation" was another name for call-by-need, and that [lazy evaluation and c-b-name] were both implementation approaches for non-strict semantics
05:24:07 <lilac> whether lazy == non-strict or lazy == call-by-need is i think not universally agreed
05:24:29 <vixey> that's a shame
05:24:31 <EvilTerran> vixey, it may be agreed on on paper, but judging by our present confusion, it's not agreed on in practice :P
05:25:01 * mercury^ thought "lazy evaluation" was another name for non-strict semantics and that [c-b-need and c-b-name] were both implementation approaches for those.
05:25:03 <lilac> obviously we should just each edit wikipedia to show our preferred definitions before we start talking
05:25:29 <EvilTerran> WikiReality :P
05:26:21 <lilac> it turns out that wikipedia doesn't know the answer
05:26:24 <vixey> mercury^, I thought non-strict was the blanket term, and lazy meant with sharing
05:26:43 <vixey> kind of like non-negative means 0, 1, ...
05:27:04 <centrinia> Are non-strict evaluation strategies disjoint from the strict evaluation strategies?
05:27:27 <mercury^> centrinia: yes. They give different results for terms that are not total.
05:27:29 <vixey> disjoint in what repspects?
05:27:43 <oklopol> non-strict is when you're not strict when that would result in chaos
05:27:54 <vixey> mercury^, well not really
05:27:55 <oklopol> but makes no other guarantee
05:27:55 <centrinia> vixey, there isn't an evaluation strategy that is both strict and non-strict.
05:28:11 <vixey> mercury^, it's not so much different results as, whether it gives a result at all
05:28:18 <lilac> centrinia: different evaluation strategies give results which differ only in bottoms
05:28:22 <mercury^> vixey: that is a different result.
05:28:38 <vixey> mercury^, I don't consider non-termination giving a result
05:28:42 <centrinia> Having no result is not a result. :(
05:28:44 <mercury^> And bottom is not only represeted by non-termination in haskell.
05:28:46 <lilac> centrinia: strict strategies give bottoms whenever they can, lazy strategies avoid bottom whenever they can
05:29:04 <oklopol> mercury^: yes but it's better not to think about it like that, it's more about finding a normal form, some find it, some don't, but it's the same normal form
05:29:34 <oklopol> non-strict finds it when lazy would, but otherwise can be as strict as it wants afaiu
05:32:41 <kaol> anyone happen to have a ready TH function that would do \(a,b,c) -> do x <- a; y <- b; z <- c; return (x,y,z) for n-tuples?
05:33:11 <vixey> kaol, I wouldn't use TH for that
05:33:31 <vixey> kaol, I write  KEEP a! KEEP b! KEEP c! STORE==> (,,)
05:33:38 <kaol> how can I do that to arbitrarily sized tuples then?
05:33:49 <vixey> kaol, how do you mean?
05:34:07 <lilac> kaol: define an Applicative instance for your monad and then do "return . (,,) <$> a <*> b <*> c"
05:34:23 <kaol> n-sized as in (,), (,,), (,,,) etc
05:34:40 <lilac> @type \(a,b,c) -> pure . (,,) <$> a <*> b <*> c
05:34:42 <lambdabot> forall a b c a1 (f :: * -> *). (Applicative f) => (f a, f a1, f b) -> f (c -> (a, b, c))
05:35:18 <kaol> I just used (,,) as an example, I want to generate code for the rest, too
05:35:30 <vixey> kaol, so you just want to write a function like  h :: (m a, m b, ..., m z) -> m (a, b, ..., z)?
05:35:36 <lilac> @type \(a,b,c) -> (,,) <$> a <*> b <*> c
05:35:38 <lambdabot> forall a a1 a2 (f :: * -> *). (Applicative f) => (f a, f a1, f a2) -> f (a, a1, a2)
05:35:41 <lilac> that's it
05:35:59 <EvilTerran> ?type liftA3 (,,)
05:36:00 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => f a -> f b -> f c -> f (a, b, c)
05:36:19 <EvilTerran> hm, not quite
05:36:28 <lilac> @hoogle uncurry3
05:36:29 <lambdabot> No results found
05:36:41 <lilac> @let uncurry3 f (a,b,c) = f a b c
05:36:43 <lambdabot>  Defined.
05:36:50 <vixey> kaol, ?
05:37:04 <lilac> @type uncurry3 $ liftA3 (,,)
05:37:05 <kaol> oh, I can roll my own with foldr1 (\a b -> AppE '(>>=) (VarE a) (LamE (VarP something))
05:37:05 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (f a, f b, f c) -> f (a, b, c)
05:37:21 <kaol> or something like that. I'll figure it out yet
05:37:26 <vixey> kaol, if you nest the tuples like (a, (b, (c, ()))) instead of (a,b,c) then I think you can implement it without TH (just using typeclasses)
05:37:43 <lilac> kaol: seriously, you should consider using Applicative for this sort of thing
05:39:02 <polveroj> do scoped type variables work in where clauses?
05:39:26 <vixey> I think they don't... but it could just be me not understanding type errors
05:44:16 <Workybob> kaol: infix applicative to the rescue!
05:44:28 <Workybob> a <^(,,)^> b <*> c
05:45:35 <Workybob> shame it's not a pair chain though – a <^(,)^> b <^(,)^> c is much nicer
05:45:56 <hydrapheetz> That looks like an emoticon if you look at it funny.
05:46:00 <vixey> a <^(,)^> b <^(,)^> c <^(,)^> return ()
05:46:22 <Workybob> vixey: I prefer pairs to be defined as always containing 2 things for some reason
05:46:28 <vixey> () is a thing
05:46:29 <Workybob> also, pure ;)
05:46:41 <Workybob> vixey: yeh – I mean two things that don't have to be tuples
05:46:50 <vixey> there is a monad instance for applicative btw
05:47:01 <vixey> () isn't a tuple
05:47:11 <Workybob> sure it is -- it's a zero-tuple
05:47:24 <vixey> in that case a is a one tuple
05:47:34 <Workybob> yeh, exactly
05:47:46 <Workybob> that's what doesn't make sense to me about terminating it with pure ()
05:48:21 <vixey> why?
05:48:34 <Workybob> why not just use data a × b = a , b -- and the value 1 , 2 , 3 -- why use 1 , 2 , 3 , ()
05:48:54 <Workybob> (playing with syntax a little here)
05:48:55 <lilac> Workybob: wrong number of _|_s
05:49:06 <lilac> apart from that, it's feasible
05:49:07 <Workybob> data a ×! = a ,! b
05:49:16 <vixey> (a,(b,(c,d))) makes little sense, why not ((a,b),(c,d))
05:49:19 <lilac> still wrong number of bottoms
05:49:24 <Workybob> really lilac?
05:49:31 <vixey> with (a,(b,(c,(d,())))) it has got inductive structure
05:49:32 <lilac> there's no 1,2,3,_|_
05:49:51 <Workybob> lilac: oh, so there isn't
05:49:52 <Workybob> damn
05:49:58 <lilac> :) you need the () terminator
05:50:00 <Workybob> vixey: that's true
05:50:05 <Workybob> lilac: yeh, that makes sense now
05:50:09 <vixey> also the bent one  (a,(b,(c,d)))  doesn't have a [] or [a]
05:50:35 <vixey> (because () and x, don't fit into the schema unless you add them as special cases)
05:50:51 <Workybob> vixey: [] or [a]? -- I don't follow you
05:50:57 <vixey> (but it means x cannot be a tuple as well, which is a hassle)
05:51:12 <vixey> compare [], [a], [a,b], ... with () (a,()) (a,(b,()))
05:51:31 <Workybob> sure – I just didn't see the need of that
05:51:36 <Workybob> until lilac pointed out the bottoms thing
05:52:09 <lilac> FWIW, i think 'data a :, b = !a :, !b' isn't too bad
05:52:14 <vixey> you can write functions by induction on the type, but that becomes awkward with the (a,(b,c)) style because of the special cases
05:52:26 <Workybob> lilac: I'd rather have an explicitly strict one in all honesty
05:52:34 <Workybob> the rest of Haskell is lazy unless otherwise told to be strict
05:52:41 <Workybob> I don't see why pairs should be different
05:52:50 * vixey uses :*:
05:52:51 <Workybob> also, the !a seems rather too much to me
05:53:01 <polveroj> how about all products end in () and are right-strict?
05:53:19 <vixey> polveroj, () or another product ?
05:53:24 <Workybob> polveroj: that's what I suggested earlier, mostly, and lilac corrected to include the ()
05:53:46 <fasta> Saizan: when I pretty print the code and then copy it in the code, it does work.
05:54:06 <polveroj> vixey: end eventually in () I meant--in the middle it might be another product
05:54:08 <Workybob> I'd love to see two types added – data a × b = a , b | () -- and data a ×! b = a × !b | ()
05:54:30 <polveroj> then the whole thing could be bottom, any of the elements could be bottom, but no partial segments could be bottom
05:54:44 <Saizan> fasta: ah, i see
05:54:54 <Workybob> oops, last × should be a ,
06:03:00 <JaffaCake> http://www.reddit.com/r/programming/comments/7oizh/ghc_benchmarking_recent_improvements_in/
06:05:31 <lilac> Workybob: then Int ?W! (Int ?W! Int) would contain values "()", "42 , ()", "42, 76, 39" and not "42, 76, _|_". is that what you want?
06:13:02 <Workybob> lilac: it is slightly strange, true
06:13:23 * Workybob ponders if it needs type families to sort out
06:13:39 <Workybob> (to specify that the b must be another pair)
06:15:27 <vixey> no just use a GADT
06:15:53 <vixey> type families let you write functions like append :: Tuple a -> Tuple b -> Tuple (Append a b)
06:16:10 <vixey> (although I think that's probably about /all/ they let you write)
06:20:08 <lilac> vixey: you seem to love GADTs an unhealthy amount ;-)
06:20:27 <vixey> hehe
06:20:46 <vixey> I've only just discovered how expressive they are, quite amazing
06:21:12 <lilac> indeed, they're pretty neat
06:21:17 <yottis> i've only discovered i need to learn more or start using lsd to understand them
06:21:39 <vixey> (you could probably write  append :: Tuple a b -> Tuple b z -> Tuple a z   with them, btw, to do the equiv. thing without type families)
06:21:47 <lilac> i've found them to be one of the most intuitive haskell extensions :)
06:22:07 <vixey> they are terribly simple but (like lambda calculus) have tremendous implications
06:22:47 <yottis> i'm in the middle of rewiring my imperative mind into a functional one so i have to be excused
06:24:57 <Workybob> vixey: TypeFamilies interact with the rest of Haskell rather nicer than GADTs
06:25:18 <vixey> I don't know what you mean by that
06:25:21 <Workybob> (at least that's the impression I get)
06:25:30 * EvilTerran found the converse to be the case
06:25:49 <EvilTerran> that might just be that type families interact badly with my mind, tho
06:25:56 <Workybob> from my experience and what I've seen of other people playing with GADTs, every time I've tried to build something, I've ended up tripping over GADTs and classes interacting badly with each other
06:26:11 <Workybob> TypeFamilies though I've seen successfully used in at least one case
06:26:23 <vixey> I find typeclasses awkward anyway, don't think GADTs make things much worse
06:26:27 <lilac> i've generally found that GADTs just do what i want them to, but i've not tried type families
06:26:42 <lilac> typeclasses don't do what i want by themselves
06:28:13 <mib_512r82cj> hi all..... I´m trying to install sdf2haskell. however, I get *unknown package: data* error
06:28:26 <mib_512r82cj> where can I find this package?
06:35:34 <lilac> mib_512r82cj: this page has a link, looks like: http://www.cs.vu.nl/Strafunski/
06:35:53 <lilac> http://wiki.di.uminho.pt/wiki/pub/Joost/Sdf2HaskellDownloads/Sdf2Haskell-2.3.tar.gz
06:36:56 <lilac> mib_512r82cj: i think i misparsed your question, sorry ;-)
06:41:36 <LoneTech> speaking of links, why do the RWH comment rss links point to non-existent addresses?
06:42:02 <SamB_XP> dons: ?
06:46:53 <LoneTech> I get links like http://book.realworldhaskell.org/read/deftypes.html?comment=9049&uuid=4e417c272edb6a4b1b46#add.hs:sumList from the rss, which ought to be somewhere around http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#add.hs:sumList
06:57:19 <sw17ch> am i correct in thinking that the GC in haskell doesn't ever have to deal with cycles?
06:57:29 <sw17ch> or rarely has to?
06:57:51 <sw17ch> and just as i say that, i think of an example
06:58:03 <Saizan> ?src repeat
06:58:03 <lambdabot> repeat x = xs where xs = x : xs
06:58:09 <Saizan> that's a cycle :)
06:58:12 <sw17ch> :)
06:58:14 <sw17ch> yep...
06:58:26 <augustss> sw17ch: there can be plenty of cycles
06:58:29 <sw17ch> so the GC does have to use a mark-sweep algorithm
06:58:38 <sw17ch> or something similar
06:58:47 <augustss> sw17ch: no, there are many algorithms that can handle cycles
06:59:03 <augustss> sw17ch: ghc uses a generational copying collector
06:59:09 <sw17ch> do those fall in the "something similar" category?
06:59:42 <augustss> I'd not say that it's similar to mark sweep.  there's no sweep :)
07:00:05 <augustss> sw17ch: basically, you copy all live data in the heap to a new place.
07:00:44 <sw17ch> augustss: and then free the rest?
07:00:53 <sw17ch> "free"?
07:01:00 <magthe> http://hpaste.org/13781 - I'm somewhat surprised the difference between these answers is so big... are there any rules to follow to make sure things like these are easily avoided?
07:01:38 <augustss> the simplest copying collector uses two heap halves.  once you've copied all the live data to the new half, all of the old half is empty (and could be freed).
07:01:43 <vixey> magthe, you could use CReal
07:01:52 <vixey> it's infinite precision
07:02:30 <augustss> magthe: take a course in numerical analysis :)
07:02:57 <magthe> vixey: I assume that comes at a price though... so when I _know_ that the input data is specified down to two decimals only it seems like overkill
07:03:05 <augustss> magthe: there are many things to look out for when using FP
07:03:28 <magthe> augustss: I've worked hard to purge the knowledge I picked up in numerical analysis :)
07:03:34 <sw17ch> > product [0.001,0.002,0.003,10.4]
07:03:36 <lambdabot>   6.24e-8
07:03:42 <sw17ch> > product (reverse [0.001,0.002,0.003,10.4])
07:03:44 <lambdabot>   6.24e-8
07:03:53 <sw17ch> > product (reverse [0.01,0.02,0.03,10.4])
07:03:53 <magthe> yes, I know there are, this time I got bitten by it in a really irritating way though
07:03:54 <vixey> magthe, or not then...
07:03:54 <lambdabot>   6.24e-5
07:04:12 <xenoblitz> Guys I have a question...and I apologize in advance if what I'm about to say makes no sense... I am trying to write a small language using Haskell's data structures... for a sequence of instructions I have added the constructor :>: such that I can do Inst :> Inst... now the question is: why is it that when I do things like Inst :> Inst :> Inst it is translated as (at least apparently) to  (:>: (:>: Inst Inst) Inst) instead of :>: Inst (:>: Inst Inst)
07:04:13 <sw17ch> > 10000000 * (product (reverse [0.001,0.002,0.003,10.4]))
07:04:14 <lambdabot>   0.624
07:04:27 <sw17ch> > 10000000 * (product (reverse [0.00000001,0.002,0.003,10.4]))
07:04:28 <lambdabot>   6.2399999999999995e-6
07:04:33 <vixey> I never understood how a simple solution to a problem can be overkill
07:04:36 <sw17ch> > 10000000 * (product ( [0.00000001,0.002,0.003,10.4]))
07:04:37 <lambdabot>   6.240000000000002e-6
07:04:58 <halberd> xenoblitz: you need to make it right associative
07:05:04 <vixey> xenoblitz,  x :> y  = (:>) x y
07:05:08 <augustss> xenoblitz: make :> infixr
07:05:21 <magthe> vixey: I have constraints on time and space, and know that there are two decimals, so infinite precision seems overkill ;)
07:05:31 <fasta> How can I splice in a Q [Dec]?
07:05:34 <augustss> magthe: use Double
07:05:50 <vixey> magthe, whatever
07:06:06 <magthe> augustss: pointer to difference between Float and Double?
07:06:13 <sw17ch> magthe: (some one correct me if i'm wrong.) in general, multiplying floats from lowest value to highest value produces the most accurate result
07:06:33 <sw17ch> > sizeof (undefined :: Float)
07:06:34 <lambdabot>   Not in scope: `sizeof'
07:06:37 <augustss> magthe: Float has 6-7 digits, Double has about 15.
07:06:38 <sw17ch> > sizeOf (undefined :: Float)
07:06:40 <lambdabot>   Not in scope: `sizeOf'
07:06:51 <augustss> Float takes 4 bytes, Double 8 bytes
07:06:51 <xenoblitz> halberd, vixey, augustss: is it because haskell assumes what, left associative, due to laziness perhaps?... and where can I read about making constructors infixr or that stuff?
07:06:55 <sw17ch> > Data.Storable.sizeOf (undefined :: Float)
07:06:56 <lambdabot>       Failed to load interface for `Data.Storable':
07:06:56 <lambdabot>        Use -v to see a li...
07:07:01 <xenoblitz> what i mean to say is what do i google for? :P
07:07:14 <augustss> xenoblitz: Haskell use assumes left assoc.  No particular reason.
07:07:35 <augustss> xenoblitz: How about reading the report?
07:07:56 <augustss> xenoblitz: Just say 'infixr :>' somewhere in your module
07:08:00 <xenoblitz> augustss: lol ok ok I tend NOT to try read the report sometimes cause it usually gives me a headache
07:08:01 <LoneTech> the report does seem rather helpful, and I'm quite the newbie
07:08:29 <xenoblitz> augustss: I'll look it up thanks
07:09:22 <Saizan_> infix[r|l] <symbol> <precedence>
07:09:50 <idnar> I don't understand mdo :/
07:10:06 <EvilTerran> Saizan_, isn't it infix[r|l|] <precedence> <symbol> (, <symbol>)* ?
07:11:16 <augustss> it is
07:11:22 <Saizan_> it is
07:11:31 <EvilTerran> ?type let infixr 2 `x`, `y`; (x,y) = undefined in ()
07:11:32 <lambdabot> ()
07:11:52 * EvilTerran still finds those commas to be a bit of an oddity
07:11:56 <xenoblitz> thanks for the help
07:12:07 <vixey> and in LANGUAGE it requires commass
07:12:09 <vixey> really bizarre..
07:12:59 <EvilTerran> vixey, these commas particularly bug me because, without them, (,) being a valid operator name character wouldn't introduce ambiguity
07:13:20 <vixey> I just don't like typing commas :p
07:13:23 <EvilTerran> and i want to be able to define (<,>) = liftA2 (,) :P
07:18:18 <SamB_XP> EvilTerran: what about in list comprehensions ?
07:18:40 <SamB_XP> oh, but that wouldn't be an ambiguity
07:19:34 <SamB_XP> EvilTerran: you could petition to have them deprecated
07:22:19 <vixey> cs.ioc.ee/~tarmo/tsem08/chapman-slides.pdf cool
07:28:21 <schme> Hey cats and dolls. I was wondering, is there some way to get into the opencl usage with ghc?
07:49:08 <lilac> i assume infixl is the default since function application is left-associative
07:49:58 <dolio> infixl 9, I think?
07:50:09 <lilac> infixl 10 presumably
07:50:19 <lilac> or at least, more than any operator
07:50:36 <dolio> Function application is a special case. It binds tighter than any operator.
07:51:26 <lilac> if you imagine there to be a secret >$< in the place of function application, it's effectively infixl 10
07:51:36 <jonaskoelker> how much are ML signatures/modules like haskell classes/instances?
07:51:42 <vixey> in my parser I used infixl 100000
07:51:51 <jonaskoelker> in my mind, they live in the same space, but exactly how close are they?
07:51:52 <dolio> Yeah, but you can't declare any other operators that have the precedence of function application.
07:52:07 <vixey> you can't define anything at infix 10 in haskell
07:52:11 <vixey> or higher
07:52:35 <dolio> Yes, default is infixl 9.
07:52:41 <dolio> And if you omit the digit, 9 is assumed.
07:52:56 <dolio> So "infixr :' is the same as "infixr : 9".
07:53:08 <lilac> infixr 9 :
07:53:13 <dolio> Yeah.
07:53:28 <dolio> I always get them switched.
07:53:45 <lilac> it's the 'right' way around (list last), like map
07:53:58 <lilac> at least, iirc
07:54:16 <schme> jonaskoelker: I
07:54:16 <Saizan_> jonaskoelker: the main difference is that typeclass instances are indexed by types, while for ML functors you explicitly declare which one you're using so you've more freedom in composing them, afaiu
07:54:28 <schme> jonaskoelker: damn. enter typo.   I'd love to know the answer to that myself.
07:54:48 <lilac> > let a * b = a - b; infixl 5 * in 2*3*7
07:54:50 <lambdabot>   -8
07:55:17 <jonaskoelker> Saizan_: and in return for more freedom in ML, you also have to type more?
07:55:32 <Saizan_> jonaskoelker: yeah
07:55:51 <lilac> well, you need to type more in haskell if you want the same functionality (newtypes etc) presumably?
07:55:51 <Saizan_> in haskell the type system decides which code to use for you
07:56:26 <Saizan_> i'm talking about implementing something like Ord
07:56:54 <Saizan_> typeclasses are not suitable for too advanced module-like functionality, imho
07:59:26 <jonaskoelker> Saizan_: such as...?
07:59:30 <Saizan_> ostly because you can't say something like "use the same instance of this class for all the occurrences in scope"
07:59:58 <Saizan_> like you do when you parametrize your module over a signature in ML
08:00:31 <jonaskoelker> most of the module/signature/functor parts of ML is in the land of mostly forgotten
08:00:47 <BMeph> > let a * b = a - b; infixr 5 * in 2*3*7
08:00:48 <lambdabot>   6
08:00:53 <Saizan_> really?
08:00:57 <jonaskoelker> "I took this one functional programming class in college" <-- you know the story
08:00:58 <BMeph> Sweeet, it actually Works! :)
08:01:15 <dolio> There's probably always ways to encode what you're doing in ML by stuff in Haskell. The question is how bad it will look.
08:01:15 <Saizan_> ah i see
08:01:28 <Saizan_> dolio: yeah, that's the main point
08:01:37 <dolio> Stuff with (sufficiently advanced) type classes, that is.
08:01:57 <jonaskoelker> just a few years ago, but it's not before learning haskell on my own that I thought "hey, this shit ain't not so bad" and started listening to what my teacher said back then... :)
08:02:04 <Saizan_> modules are meant to make code organization easier, not more complex
08:02:09 <dolio> Like, Oleg's encoding of translucent functors (which I haven't really bothered to understand) into multiparameter type classes and such.
08:03:42 <redditbot> GHC: Benchmarking recent improvements in parallelism
08:03:44 <Saizan_> maybe some TH over that could make it usable :)
08:04:27 <dolio> Well, I forget what use translucent functors are, so I don't know if it's worth the time fixing it up.
08:05:53 <dolio> Of course, Haskell misses a lot in that area, I suppose.
08:06:16 <dolio> Only having existential types to mimic that sort of thing.
08:12:30 <BMeph> That's an idea: augustss was having a tough time getting a useable form of basically a parametric record type, but it was both ugly and clunky. Maybe oleg could figure out a sleeker way. Of course, there's always the problem that he'd just say to use ML. ;)
08:14:54 <vixey> :t \a b c -> ((a (\d -> b d)) c)
08:14:56 <lambdabot> forall t t1 t2 t3. ((t -> t1) -> t2 -> t3) -> (t -> t1) -> t2 -> t3
08:16:38 <Saizan> BMeph: except that Oleg's solutions rarely look clean to me :)
08:16:58 <dolio> Yeah. Sleekness is typically left as an exercise for the reader. :)
08:18:44 <ehird> @hoogle iterateUntil
08:18:45 <lambdabot> No results found
08:18:47 <ehird> @hoogle iterateWhiel
08:18:48 <lambdabot> No results found
08:18:49 <ehird> @hoogle iterateWhile
08:18:49 <lambdabot> No results found
08:19:11 <dolio> @type until
08:19:12 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
08:19:23 <mmorrow> , let bin = Node () [bin,bin] in bin
08:19:27 <lunabot>  Node {rootLabel = (), subForest = [Node {rootLabel = (), subForest = [Nod...
08:20:14 <IsoPallo> Wow. Temmi is on top three!
08:20:26 <IsoPallo> Sorry, wrong channel
08:20:34 <ehird> dolio: that doesn't return a bag of results, though
08:20:50 <vixey> huh I wonder what clean means wrt. source code
08:21:09 <dolio> What's the type you actually want?
08:22:48 <mmorrow> , let apart (x:y:zs) = (x,y) : apart zs; bin (x:xs) = let (ys,zs) = unzip (apart xs) in Node x [bin ys, bin zs] in bin [0..]
08:22:55 <lunabot>  Killed.
08:24:40 <ehird> dolio: (a -> Bool) -> (a -> a) -> a -> [a]
08:24:45 <mmorrow> , levels (let apart (x:y:zs) = (x,y) : apart zs; bin (x:xs) = let (ys,zs) = unzip (apart xs) in Node x [bin ys, bin zs] in bin [0..])
08:24:47 <lunabot>  [[0],[1,2],[3,5,4,6],[7,11,9,13,8,12,10,14],[15,23,19,27,17,25,21,29,16,2...
08:24:56 <ehird> (return is finite list up to the point where the first arg gives True)
08:25:02 <mmorrow> , flatten (let apart (x:y:zs) = (x,y) : apart zs; bin (x:xs) = let (ys,zs) = unzip (apart xs) in Node x [bin ys, bin zs] in bin [0..])
08:25:05 <dolio> ehird: That's essentially unfoldr.
08:25:09 <lunabot>  Killed.
08:25:18 <ehird> :t unfoldr
08:25:19 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
08:25:24 <ehird> Maybe.
08:25:24 <dolio> Although you need some combinators to make it 'nice'.
08:25:26 <ehird> It's really just
08:25:28 <ehird> :t iterate
08:25:29 <lambdabot> forall a. (a -> a) -> a -> [a]
08:25:32 <ehird> with a termination case
08:25:36 <dolio> Well, yeah, you can iterate and take, too.
08:25:39 <idnar> :t takeWhile
08:25:40 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
08:25:46 <dolio> That always makes my blood boil, though. :)
08:26:03 <Saya> hey i want a to build a register type class that has 2 functions :  write :: (reg a) -> a -> IO () and read :: (reg a) -> IO () , is there anyway to specify in my type class that i want my type to be an instance of a kind so that reg is * -> * and a is its parameter? :s
08:26:17 <idnar> @pl \c f z -> takeWhile c (iterate f z)
08:26:17 <lambdabot> (. iterate) . (.) . takeWhile
08:26:21 <idnar> @type \c f z -> takeWhile c (iterate f z)
08:26:22 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> [a]
08:26:22 <mm_freak_> currently i have a [(i,e)] list, which is usually used exhaustively element by element, but sometimes i have lookups, which are currently heavy
08:26:44 <mm_freak_> will turning it into a Map i e make exhaustive use slower?
08:26:48 <Saya> read :: (reg a) -> IO a  actually but my question stand ^
08:27:03 <mm_freak_> (exhaustive in that i use 'assocs')
08:27:04 <dolio> @type let stopAt p f x = if p x then Nothing else Just (f x) ; dup x = (x,x) in \p f -> unfoldr (stopAt p $ dup . f)
08:27:05 <lambdabot> forall b. (b -> Bool) -> (b -> b) -> b -> [b]
08:27:23 <lilac> @type unfoldr . ((Just . join (,)) .)
08:27:25 <lambdabot> forall b. (b -> b) -> b -> [b]
08:27:48 <lilac> @check unfoldr . ((Just . join (,)) .) == iterate
08:27:50 <lambdabot>       No instance for (Eq ((b -> b) -> b -> [b]))
08:27:50 <lambdabot>        arising from a use o...
08:27:51 <Saizan> Saya: class Register reg where write :: reg a -> a -> IO () should work
08:28:05 <mmorrow> @pl iterate
08:28:06 <lambdabot> iterate
08:28:12 <Saizan> Saya: or do you also want to make 'a' a parameter of the class?
08:28:39 <mmorrow> @pl fix (\k f x -> x : k f (f x))
08:28:40 <lambdabot> fix ((ap (:) .) . ((.) =<<))
08:28:44 <lilac> @check \f x -> (unfoldr . ((Just . join (,)) .)) f x == iterate f x
08:28:45 <lambdabot>       Overlapping instances for Show (b -> b)
08:28:46 <lambdabot>        arising from a use of `m...
08:28:46 <mmorrow> @type fix (\k f x -> x : k f (f x))
08:28:47 <lambdabot> forall a. (a -> a) -> a -> [a]
08:29:25 <Saya> Saizan: nope that should be good i just didnt think hard enough >.<
08:29:50 <mmorrow> , fix (\me -> Node () [me,me])
08:29:52 <lunabot>  Node {rootLabel = (), subForest = [Node {rootLabel = (), subForest = [Nod...
08:30:46 <lilac> @type \f g -> unfoldr (\x -> f x <?> join (,) (g x))
08:30:48 <lambdabot> forall b. (b -> Bool) -> (b -> b) -> b -> [b]
08:31:00 <vixey> , Node
08:31:01 <lunabot>  luna: No instance for (GHC.Show.Show
08:31:04 <vixey> , ''Node
08:31:06 <lunabot>  luna: Not in scope: type constructor or class `Node'
08:31:07 <dolio> @type (<?>)
08:31:08 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => Bool -> a -> m a
08:31:08 <vixey> , 'Node
08:31:11 <lunabot>  Data.Tree.Node
08:31:18 <vixey> @hoogle Data.Tree.Node
08:31:19 <lambdabot> Data.Tree Node :: a -> Forest a -> Tree a
08:31:21 <mmorrow> , levels (fix (\me -> Node () [me,me]))
08:31:24 <lunabot>  [[()],[(),()],[(),(),(),()],[(),(),(),(),(),(),(),()],[(),(),(),(),(),(),...
08:31:34 <mmorrow> , src ''Tree
08:31:44 <mmorrow> Tree a = Node a [Tree a]
08:31:44 <lunabot>  data Tree a = Node {rootLabel :: a, subForest :: (Forest a)}
08:32:10 <mmorrow> , levels (fix (\me -> Node () [me,me,me]))
08:32:12 <lunabot>  [[()],[(),(),()],[(),(),(),(),(),(),(),(),()],[(),(),(),(),(),(),(),(),()...
08:32:23 <dolio> lilac: What package is that from?
08:33:19 <lilac> dolio: it's a local @let
08:33:25 <dolio> Ahh.
08:33:26 <lilac> i'm gonna package it up Real Soon Now ;-)
08:33:33 <lilac> see also <:>
08:33:45 <dolio> @type (<:>)
08:33:46 <lambdabot> Not in scope: `<:>'
08:34:08 <lilac> @type (<:>)
08:34:10 <lambdabot> forall t. Maybe t -> t -> t
08:34:18 <mmorrow> @type bool
08:34:19 <lambdabot> Not in scope: `bool'
08:34:31 <mmorrow> @let bool f _ False = f; bool _ t True = t
08:34:32 <lambdabot>  Defined.
08:34:38 <vixey> (unfoldr (\x -> f x <?> join (,) (g x))) = takeWhile f . iterate g x  ?
08:34:49 <vixey> (takeWhile f . iterate g) x
08:35:16 <mmorrow> @type fix (\k p f x -> bool [] (x : k p f (f x)) (p x))
08:35:17 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> [a]
08:35:49 <dolio> @type \p f -> unfoldr (\x -> p x <?> f x)
08:35:51 <lambdabot> forall b a. (b -> Bool) -> (b -> (a, b)) -> b -> [a]
08:36:28 <mmorrow> @let pair (<>) f g = (\x -> f x <> g x)
08:36:29 <lambdabot>  Defined.
08:36:39 <lilac> > takeWhile (<3) . iterate (+1) $ 0
08:36:40 <lambdabot>   [0,1,2]
08:36:41 <lilac> > (\f g -> unfoldr (\x -> f x <?> join (,) (g x))) (<3) (+1) 0
08:36:43 <lambdabot>   [1,2,3]
08:36:59 <mmorrow> @type (unfoldr .) . pair (<?>)
08:37:00 <lambdabot> forall a t. (t -> Bool) -> (t -> (a, t)) -> t -> [a]
08:37:05 <lilac> @type pair
08:37:07 <lambdabot> forall t1 t2 t3 t. (t1 -> t2 -> t3) -> (t -> t1) -> (t -> t2) -> t -> t3
08:37:15 <mmorrow> @let pair (<>) f g = (\x -> f x <> g x)
08:37:15 <lambdabot>  <local>:3:0:
08:37:16 <lambdabot>      Warning: Pattern match(es) are overlapped
08:37:16 <lambdabot>               In...
08:37:18 <dolio> > let swap (a,b) = (b,a) in unfoldr (\x -> x == 0 <?> swap (divMod 10 x)) 123456
08:37:19 <mmorrow> crap
08:37:19 <lambdabot>       Occurs check: cannot construct the infinite type: b = m (b, b)
08:37:19 <lambdabot>        E...
08:37:32 <dolio> > let swap (a,b) = (b,a) in unfoldr (\x -> x == 0 <?> swap (divMod x 10)) 123456
08:37:33 <lilac> @@ @type join :: @type pair
08:37:33 <lambdabot>       Occurs check: cannot construct the infinite type: b = m (b, b)
08:37:33 <lambdabot>        E...
08:37:35 <lambdabot>     Occurs check: cannot construct the infinite type: t1 = t -> t1
08:37:35 <mmorrow> didn't mean to redefine it
08:37:39 <mmorrow> @type pair
08:37:40 <lambdabot> forall t1 t2 t3 t. (t1 -> t2 -> t3) -> (t -> t1) -> (t -> t2) -> t -> t3
08:37:42 <mmorrow> oh good
08:37:51 <dolio> > let swap (a,b) = (b,a) in unfoldr (\x -> (x == 0) <?> swap (divMod x 10)) 123456
08:37:52 <mmorrow> @type on
08:37:53 <lambdabot>   []
08:37:53 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
08:38:07 <dolio> > let swap (a,b) = (b,a) in unfoldr (\x -> (x /= 0) <?> swap (divMod x 10)) 123456
08:38:09 <lambdabot>   [6,5,4,3,2,1]
08:38:25 <mmorrow> nice
08:39:29 <mmorrow> > unfoldr (pair (<?>) (/= 0) (uncurry (flip(,)) . flip divMod 10)) 123456
08:39:31 <lambdabot>   [6,5,4,3,2,1]
08:40:02 <mmorrow> @pl unfoldr (pair (<?>) (/= 0) (uncurry (flip(,)) . flip divMod 10))
08:40:03 <lambdabot> unfoldr (pair (<?>) (0 /=) (uncurry (flip (,)) . flip divMod 10))
08:40:07 <mmorrow> hehe
08:40:33 <ski_> (BMeph : parametric record type ?)
08:42:45 <dolio> ski_: http://augustss.blogspot.com/2008/12/somewhat-failed-adventure-in-haskell.html
08:42:49 <dolio> And subsequent posts.
08:42:51 <SamB> man, it's a good thing I touch type, or I'd need a new keyboard ...
08:42:58 <mmorrow> > snd . foldl' (\(!m,!n) x -> (m+x*10^n,n+1)) (0,0) . unfoldr (pair (<?>) (/= 0) (uncurry (flip(,)) . flip divMod 10)) $ 123456
08:42:59 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
08:43:06 <mmorrow> > snd . foldl' (\(m,n) x -> (m+x*10^n,n+1)) (0,0) . unfoldr (pair (<?>) (/= 0) (uncurry (flip(,)) . flip divMod 10)) $ 123456
08:43:07 <lambdabot>   6
08:43:17 <mmorrow> dangit
08:44:58 <mmorrow> oh, heh
08:45:04 <mmorrow> > fst . foldl' (\(m,n) x -> (m+x*10^n,n+1)) (0,0) . unfoldr (pair (<?>) (/= 0) (uncurry (flip(,)) . flip divMod 10)) $ 123456
08:45:06 <lambdabot>   123456
08:45:22 <mmorrow> @pl fst . foldl' (\(m,n) x -> (m+x*10^n,n+1)) (0,0)
08:45:22 <lambdabot> fst . foldl' (uncurry ((`ap` (1 +)) . ((flip . ((,) .)) .) . (. ((*) . (10 ^))) . (.) . (+))) (0, 0)
08:46:07 <mmorrow> @let id' = fst . foldl' (\(m,n) x -> (m+x*10^n,n+1)) (0,0) . unfoldr (pair (<?>) (/= 0) (uncurry (flip(,)) . flip divMod 10))
08:46:08 <lambdabot>  Defined.
08:46:47 <mmorrow> > iterate id' 100^40
08:46:49 <lambdabot>       No instance for (Num [a])
08:46:49 <lambdabot>        arising from a use of `^' at <interact...
08:46:54 <mmorrow> @type id'
08:46:55 <lambdabot> forall a. (Integral a) => a -> a
08:47:00 <mmorrow> > iterate id' (100^40)
08:47:02 <lambdabot>   [10000000000000000000000000000000000000000000000000000000000000000000000000...
08:47:07 <mmorrow> > iterate id' (100^100)
08:47:08 <lambdabot>   [10000000000000000000000000000000000000000000000000000000000000000000000000...
08:47:20 <mmorrow> gmp is friggin fast
08:47:39 <dolio> ski_: He wants signature parameterize modules. Which, who doesn't? :)
08:47:47 <mmorrow> err, i wonder if the entire number needs to be computed before you can get any digits of it
08:47:50 <mmorrow> probably not..
08:48:30 <mmorrow> > 100^300
08:48:31 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
08:48:37 <mmorrow> > 100^1000
08:48:37 <lilac> > 10^3000
08:48:38 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
08:48:39 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
08:48:44 <mmorrow> > 100^100000
08:48:45 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
08:48:47 <vixey> > 1000^1000^100
08:48:51 <mmorrow> heh
08:49:00 <lilac> > 2^2^2^2^2
08:49:00 <vixey> > 10^10^10
08:49:02 <lambdabot>   thread killed
08:49:04 <lambdabot>   200352993040684646497907235156025575044782547556975141926501697371089405955...
08:49:13 <lambdabot>   mueval: Prelude.read: no parse
08:49:13 <lambdabot>  mueval: out of memory (requested 38797312 b...
08:49:17 <vixey> , 10^10^10
08:49:23 <lunabot>  luna: out of memory (requested 7340032 bytes)
08:49:32 <mmorrow> , 100^10000
08:49:34 <lunabot>  1000000000000000000000000000000000000000000000000000000000000000000000000...
08:49:37 <mmorrow> , 100^100000000
08:49:43 <lunabot>  luna: out of memory (requested 7340032 bytes)
08:49:53 <Martijn> Who is lunabot?
08:49:53 <vixey> > (10^10)^10
08:49:57 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
08:49:57 <vixey> > 10^(10^10)
08:50:01 <mmorrow> , length . show $ 100^10000
08:50:05 <lunabot>  20001
08:50:13 <lambdabot>   thread killed
08:51:04 <Martijn> > take 1 . show $ 10^(10^10)
08:51:16 <mmorrow> Martijn: i have a darcs repo (not for the bot code though, but it's pretty trivial a shell) if you're interested: http://moonpatio.com/repos/luna/
08:51:19 <lambdabot>   thread killed
08:51:30 <mmorrow> it'll only work on ghc-6.10.1
08:52:05 <Martijn> mmorrow: That doesn't really answer my question. :-)
08:52:14 <lilac> > let a 0 m n = m + n; a (k+1) m n = let j = a k m n in a k (j+m) (j+n) in a 10 2 3
08:52:16 <lambdabot>   187586583477321577866054587091073254346181035018433090794171097942093559559...
08:52:51 <mmorrow> Martijn: um, it has some stuff that lambdabot doesn't, namely TH and other misc
08:53:11 <mmorrow> , eval "eval \"eval \\\"42\\\"\""
08:53:16 <lunabot>  <<Dynamic>>
08:53:28 <Martijn> mmorrow: Ah, okay
08:53:43 <Martijn> , eval "42" :: Int
08:53:45 <lunabot>  luna: Couldn't match expected type `GHC.Types.Int'
08:53:55 <Martijn> , :t eval
08:53:55 <mmorrow> , (fromJust . fromDynamic . fromJust . fromDynamic . fromJust . fromDynamic) (eval "eval \"eval \\\"42\\\"\"") :: Integer
08:53:56 <lunabot>  luna: Couldn't match expected type `(GHC.Base.String
08:54:01 <lunabot>  42
08:54:03 <rwbarton> , src 'eval
08:54:06 <mmorrow> , [$ty| eval |]
08:54:09 <lunabot>  eval :: String -> Dynamic
08:54:13 <mmorrow> , [$tyQ| eval |]
08:54:14 <lunabot>  String -> Dynamic
08:54:19 <lunabot>  AppT (AppT ArrowT (ConT String)) (ConT Dynamic)
08:54:33 <ski_> dolio : aye !
08:55:09 <ski_> @kind ContT Dynamic
08:55:09 <mmorrow> , fromDynamic (eval "[0..]") :: [Integer]
08:55:11 <lunabot>  luna: Couldn't match expected type `[GHC.Integer.Internals.Integer]'
08:55:11 <lambdabot> (* -> *) -> * -> *
08:55:13 <mmorrow> , fromDynamic (eval "[0..]") :: Maybe [Integer]
08:55:19 <lunabot>  Just [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25...
08:56:28 <mmorrow> lunabot does
08:56:56 <mmorrow> ":info" with ", src '<not a type name>" or ", src ''<a type name>"
08:57:02 <mmorrow> , src 'fmap
08:57:06 <mmorrow> , src ''Maybe
08:57:07 <lunabot>  Class op from Functor: fmap :: forall f . Functor f => forall a b . (a ->
08:57:07 <lunabot>                                                                       b) ->
08:57:07 <lunabot>                                                                      (f a)...
08:57:09 <mmorrow> ugh
08:57:11 <lunabot>  data Maybe a = Nothing | Just a
08:57:12 <ski_> dolio : btw, Reiner Pope's comment seems like it might possibly be related to normalization in the relational database model ..
08:57:16 <mmorrow> and :t with
08:57:32 <mmorrow> , [$ty| let fix f = let x = f x in x in fix |]
08:57:37 <lunabot>  forall a . (a -> a) -> a
08:57:54 <mmorrow> and that's all other than eval (including though the nested eval)
08:59:00 <mmorrow> and has category-extras, CC-delcont, logict, some others i can't think of...
08:59:33 <mmorrow> , foldr interleave [] (fmap (\n->[n..]) [0..])
08:59:35 <lunabot>  [0,1,1,2,2,2,3,3,4,3,5,3,6,4,7,4,8,5,9,4,10,6,11,4,12,7,13,5,14,8,15,5,16...
09:00:05 <elbar> @hoogle interleave
09:00:06 <lambdabot> System.IO.Unsafe unsafeInterleaveIO :: IO a -> IO a
09:00:06 <lambdabot> Control.Monad.ST unsafeInterleaveST :: ST s a -> ST s a
09:00:06 <lambdabot> Control.Monad.ST.Lazy unsafeInterleaveST :: ST s a -> ST s a
09:00:16 <mmorrow> , src 'interleave
09:00:22 <lunabot>  Class op from MonadLogic: interleave :: forall m . MonadLogic m => forall...
09:00:22 <lunabot>                                                                           ...
09:00:31 <mmorrow> gah, that needs fixing
09:00:32 <vixey> ah MonadLogic
09:00:39 <mmorrow> , src ''MonadLogic
09:00:44 <lunabot>  class (MonadPlus m) => MonadLogic m where
09:00:44 <lunabot>          msplit :: forall a . m a -> m (Maybe (a, m a))
09:00:44 <lunabot>          interleave :: forall a . m a -> m a -> m a
09:01:06 <mmorrow> and lunabot does up to 32 lines in a /msg, and 3 max in-channel
09:02:24 <vixey> <lunabot>          (>>-) :: forall b a . m a -> (a -> m b) -> m b
09:02:24 <vixey> <lunabot>          ifte :: forall b a . m a -> (a -> m b) -> m b -> m b
09:02:24 <vixey> <lunabot>          once :: forall a . m a -> m a
09:02:56 <vixey> (that's the rest of MonadLogic)
09:03:01 <rwbarton> , $( lift . pprint . cleanNames . fst =<< oldtype =<< [t| WriterT Int [] String |] )
09:03:06 <lunabot>  "[] ((,) ([] Char) Int)"
09:03:11 <mmorrow> heh, nice
09:03:19 <vixey> , src 'oldtype
09:03:24 <lunabot>  oldtype :: Type -> Q ((Type, [Dec]))
09:03:26 <rwbarton> some day I need to rewrite oldtype with an algorithm that's actually correct
09:03:43 <redditbot> A transactional data cache with configurable persistence
09:03:43 <redditbot> Indexing a coinductive type on a trace
09:03:45 <mmorrow> i love the name
09:03:50 <vixey> rwbarton, what do you mean rewrite?
09:04:02 <vixey> redditbot: link?
09:04:19 <dolio> ski_: Hmm, could be.
09:04:22 <vixey> @go Indexing a coinductive type on a trace
09:04:25 <vixey> redditbot--
09:04:28 <lambdabot> http://www.comp.nus.edu.sg/~joxan/papers/model.pdf
09:04:28 <lambdabot> Title: Modeling Systems in CLP with Coinductive Tabling
09:06:14 <rwbarton> vixey: Well I wrote it originally
09:06:25 <mmorrow> , ppDoc $( lift . fst =<< oldtype =<< [t| ReaderT Bool (WriterT Int (State ()) String |] )
09:06:27 <lunabot>  luna: parse error on input `|]'
09:06:28 <vixey> and it got put into the standard libraries?
09:06:37 <rwbarton> vixey: no, just into lunabot
09:06:39 <mmorrow> , ppDoc $( lift . fst =<< oldtype =<< [t| ReaderT Bool (WriterT Int (State ())) String |] )
09:06:44 <lunabot>  Bool -> () -> (,) ((,) ([] Char) Int) ()
09:06:48 <mmorrow> sweet.
09:07:07 <rwbarton> , src ''Mu
09:07:09 <mmorrow> that makes the monad unraveler almost finished
09:07:12 <lunabot>  newtype Mu f = Mu (f (Mu f))
09:07:22 <rwbarton> , $( lift . pprint . cleanNames . fst =<< oldtype =<< [t| Mu Maybe |] )
09:07:26 <lunabot>  "X_0"
09:07:29 <rwbarton> where...
09:07:31 <mmorrow> heh
09:07:34 <rwbarton> , $( lift . map (pprint . cleanNames) . snd =<< oldtype =<< [t| Mu Maybe |] )
09:07:38 <lunabot>  ["newtype X_0 = X_0 (Maybe X_0)"]
09:07:51 <mmorrow> oh
09:08:05 <vixey> coooool
09:08:12 <vixey> , $( lift . map (pprint) . snd =<< oldtype =<< [t| Mu Maybe |] )
09:08:16 <lunabot>  ["newtype X_0 = X_0 (Data.Maybe.Maybe X_0)"]
09:08:25 <rwbarton> that's the part that's broken in more complicated cases
09:08:26 <mmorrow> vixey: there's also a tysyn expander
09:08:43 <vixey> , $( lift . map (pprint . cleanNames) . snd =<< oldtype =<< [t| (Mu Maybe,Either () ()) |] )
09:08:47 <lunabot>  ["newtype X_0 = X_0 (Maybe X_0)"]
09:09:02 <vixey> oh it didn't work that time
09:09:38 <rwbarton> I think that's right... just the way it uses X_0 is different
09:09:51 <rwbarton> , $( lift . map (pprint . cleanNames) . fst =<< oldtype =<< [t| (Mu Maybe,Either () ()) |] )
09:09:53 <lunabot>  luna: Couldn't match expected type `[a]'
09:09:57 <rwbarton> , $( lift .  (pprint . cleanNames) . fst =<< oldtype =<< [t| (Mu Maybe,Either () ()) |] )
09:10:01 <lunabot>  "(X_0, Either () ())"
09:10:07 <vixey> oh
09:10:22 <vixey> , $( lift . map (pprint . cleanNames) . snd =<< oldtype =<< [t| (Mu Maybe,(Mu,Maybe, Either () ())) |] )
09:10:24 <lunabot>  luna: `Luna.Mu.Mu' is not applied to enough type arguments
09:10:30 <vixey> , $( lift . map (pprint . cleanNames) . snd =<< oldtype =<< [t| (Mu Maybe,(Mu Maybe, Either () ())) |] )
09:10:34 <lunabot>  ["newtype X_0 = X_0 (Maybe X_0)","newtype X_0 = X_0 (Maybe X_0)"]
09:10:59 <rwbarton> those really have different labels, it's just cleanNames doesn't know it can't reuse the number
09:11:17 <rwbarton> , $( lift . map (pprint . cleanNames) . snd =<< oldtype =<< [t| Mu ((,) (Mu Maybe)) |] )
09:11:21 <lunabot>  ["newtype X_0 = X_0 ((,) X_1 X_0)","newtype X_0 = X_0 (Maybe X_0)","newty...
09:11:31 <rwbarton> , $( lift . map (pprint) . snd =<< oldtype =<< [t| Mu ((,) (Mu Maybe)) |] )
09:11:36 <lunabot>  ["newtype X_0 = X_0 (GHC.Tuple.(,) X_1 X_0)","newtype X_0 = X_0 (Data.May...
09:11:40 <rwbarton> actually it's pprint that does the renumbering
09:13:21 <mmorrow> rwbarton, vixey: i just pasted the version of both that're in lunabot: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=749
09:13:46 <vixey>  `runReaderT` []) `runContT` return) `runStateT` []
09:13:48 <vixey> nice
09:15:32 <dons> ?users
09:15:32 <lambdabot> Maximum users seen in #haskell: 668, currently: 627 (93.9%), active: 17 (2.7%)
09:15:37 <dcoutts_> @arr!
09:15:38 <lambdabot> Yo ho ho, and a bottle of rum!
09:15:56 <mmorrow> @yow
09:15:57 <lambdabot> OMNIVERSAL AWARENESS??  Oh, YEH!!  First you need four GALLONS of JELL-O
09:15:57 <lambdabot> and a BIG WRENCH!! ... I think you drop th'WRENCH in the JELL-O as if
09:15:57 <lambdabot> it was a FLAVOR, or an INGREDIENT ... ... or ... I ... um ... WHERE'S
09:15:57 <lambdabot> the WASHING MACHINES?
09:16:06 <mm_freak_> i have:  data Neuron = Input { … } | Hidden { … }
09:16:26 <mm_freak_> currently i'm doing:  case n of Input _ _ -> … someField n …
09:16:33 <mm_freak_> any way to do this more elegantly?
09:16:50 <mm_freak_> i.e. without mentioning the "_ _"
09:16:52 <mmorrow> case n of Input{} -> ... ...
09:16:59 <mmorrow> best thing evar
09:17:04 <mm_freak_> ah, great =)
09:17:12 <rwbarton> Amazingly, you can do that even if Input wasn't defined with record syntax
09:17:22 <Saizan> or case n of Input{...} -> someField
09:17:33 <Saizan> with an extension
09:17:43 <rwbarton> is that a literal ...?
09:17:59 <mmorrow> , let Node {...} = undefined in undefined
09:18:02 <lunabot>  luna: parse error on input `...'
09:18:06 <Saizan> rwbarton: yes
09:18:13 <mmorrow> what extension?
09:18:18 <Saizan> it's called RecordPuns, iirc
09:18:24 <mmorrow> ah, nice
09:18:45 <Saizan> it works both in patterns and in expressions
09:19:03 <rwbarton> actually it's just ..
09:19:12 <rwbarton> , let Node {..} = undefined in undefined
09:19:14 <lunabot>  luna: Illegal `..' in record pattern
09:19:17 <vixey> why not just {} ?
09:19:23 <vixey> , let Node {} = undefined in 34
09:19:25 <lunabot>  34
09:19:27 <vixey> record sytax
09:19:29 <rwbarton> I think {..} brings the fields into scope?
09:19:37 <Saizan> rwbarton: yeah
09:19:41 <vixey> without naming them!?
09:20:27 <mmorrow> ohhhh, nice
09:20:32 <rwbarton> mm_freak_: yet another option is the haskell98 case n of Input { someField = foo } -> ... foo ...
09:20:43 <rwbarton> mm_freak_: or the extension  case n of Input { someField } -> ... someField ...
09:21:19 <Saya> Is there a standard haskell message passing library?
09:21:29 <mmorrow> , let Node {subForest} = Node 42 [Node 42 []] in subForest
09:21:31 <lunabot>  luna: Illegal use of punning for field `subForest'
09:21:39 * vixey wonders what is "message passing"?
09:21:40 <dons> Saya: for local or remote threads?
09:22:15 <dons> Saya: there's a suite of standard concurrency abstractions, including channels and async messages, transactional variables, and other things
09:22:18 <dons> it depends on what you're doing
09:22:47 <rwbarton> , let Node { subForest = sf } = Node 42 [Node 42 []] in sf
09:22:49 <lunabot>  [Node {rootLabel = 42, subForest = []}]
09:22:59 <mm_freak_> rwbarton: thanks
09:23:04 <sw17ch> is it possible to give an upper bound on the amoutn of time it will take to run the GC at any given point in a program?
09:23:11 <mm_freak_> the standard version suffices for me =)
09:23:26 <ski_> why didn't `Node {subForest} = blah' work ?
09:23:28 <mmorrow> i don't think so
09:23:33 <dons> sw17ch: nope.
09:23:45 <mmorrow> sw17ch: timber looks really cool though
09:23:48 <dons> try to minimise GC to < 10% of the program's runtime
09:24:56 <Saya> remote
09:25:13 <dons> to other haskell nodes on other machines?
09:25:27 <Saya> yeah
09:25:31 <dons> there's a couple, i've not used them. a new one is the erlang wire protocol.
09:25:45 <dons> the 'ports' library is another one.
09:25:48 <dons> all on hackage.haskell.org
09:25:50 <mmorrow> oh interesting
09:26:22 <Saya> thx ill check them out, im playing around with erlang (trying to) like abstractions in haskell actually
09:27:38 <gchrupala> why is it that in  "f x y = let x' = g x in h x' y"   does not behave the same as "f x = let x' = g x in \y -> h x' y"?
09:29:28 <vixey> gchrupala, you really mean behave? and not wondering about types?
09:29:57 <dons> Saya: you programming  a cluster?
09:30:40 <vixey> gchrupala, g x can be calculated and stored as soon as you apply x in the second case.. but that cannot happen with the first
09:30:57 <gchrupala> vixey: why not?
09:31:07 <jonaskoelker> is there a way to make hpc only color the expressions that were evaluated (not declarations, pattern matches or guards)?
09:31:29 <vixey> gchrupala, because it's underneath a binder
09:31:43 <gchrupala> vixey: y is not used in the let expression
09:31:54 <vixey> yeah I noticed
09:32:05 <vixey> that doesn't matter though
09:32:18 <gchrupala> ah
09:35:20 <polveroj> So, I have a type "Pattern s a b" of pattern matches on "a" producing "b", where "s" is an uninhabited type used for exhaustiveness checking. Is there a way to wrap this so I can declare Functor/Applicative/Alternative instances, but still have matching an inexhaustive pattern be a type error?
09:36:30 <vixey> what's s?
09:36:49 <vixey> why 's' instead of 'Void'?
09:36:55 <lilac> polveroj: do you not just want a Functor (etc) instance for forall s a. Pattern s a?
09:37:28 <polveroj> s is a representation of which cases are handled, which has a typeclass Exhaustive if those cases are exhaustive
09:37:40 <augustss> Am I the only one that daily wishes you could write 'do foo :: T; foo <- ...'?
09:37:41 <Saya> dons: well i did it in c++ and it gave me headaches :p but this is just a freetime thing to see how it could maybe work
09:37:47 <vixey> so s is computed from a?
09:38:15 <vixey> (I should maybe say, the type s computed from the type a?)
09:38:22 <polveroj> lilac: that's fine until you try to match using it, but I don't know how to recover whether s has a particular typeclass
09:38:44 <lilac> augustss: PatternSignatures permits 'do foo :: T <- ...'
09:39:07 <lilac> polveroj: what's the problem?
09:39:16 <augustss> lilac: I know, but I like the signature on its own line
09:39:17 <vixey> in void foo() { T foo; f = ... }
09:39:41 <lilac> polveroj: oh, i see :)
09:40:28 <lilac> polveroj: you have "fmap :: (b -> c) -> Pattern s a b -> Pattern s a c". If the compiler knows that s is an instance of Exhaustive before, it should still know that after...
09:40:45 <polveroj> lilac: yeah, fmap is fine
09:41:05 <vixey> polveroj, the type s is computed from the type a?
09:41:09 <polveroj> lilac: but <|> isn't--neither branch needs to be exhaustive beforehand, but the combination might be exhaustive
09:41:17 <lilac> polveroj: then that's not <|>
09:41:21 <polveroj> vixey: it's computed (using fundeps) from the "s" types of the components when you build the patterns
09:41:36 <vixey> polveroj, do you have any code online ?
09:41:38 <vixey> of this..
09:42:03 <polveroj> vixey: um, I can clean it up briefly and then hpaste it
09:42:18 <vixey> ok but you don't have to clean itup
09:42:26 <vixey> I'm just wondering what this looks like
09:42:32 <lilac> polveroj: <|> has the wrong type for your needs. how about (>|< :: Pattern s a b -> Pattern t a b -> Pattern (Merge s t) a b)
09:46:40 <polveroj> um, it's too long for hpaste by a tad -- is there another place?
09:47:14 <vixey> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/
09:49:21 <polveroj> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=751
09:50:30 <polveroj> lilac: yeah, that's why I was thinking along the lines of wrapping it
09:50:45 <vixey> polveroj, annotated with something
09:50:56 <augustss> @seen bos
09:50:56 <lambdabot> bos is in #ghc and #haskell. I last heard bos speak 1s ago.
09:51:18 <polveroj> lilac: without the exhaustiveness checking patterns are isomorphic to "a -> Maybe b", which has tons of reasonable instances for free
09:52:45 <polveroj> lilac: the extra type is just a proof that sometimes the Mabye is guaranteed to be Just something, and I'm annoyed that having an extra proof in the type makes me lose all those instances
09:55:14 <vixey> polveroj, so it's just this: http://www.itu.dk/people/mir/typesafepatterns.hs , except you want to make exaustiveness checked at compiletime?
09:55:55 <polveroj> vixey: yeah, with the secondary goal of having human-readable type signatures
09:55:57 <rwbarton> polveroj: I like how you have nine lines of language extensions and *also* -fglasgow-exts :)
09:56:12 <polveroj> rwbarton: yeah eventually I gave up
09:56:15 <vixey> polverjo, type signatures of what?
09:56:22 <erikc> oooooooooooh....the evil mangler is the reason i couldnt match up InfoTypes.h structures with .hc output
09:56:36 <polveroj> vixey: of patterns
09:56:37 <vixey> how evil!
10:02:13 <vixey> wow thats really neat
10:02:19 <vixey> v2     = uncurry three flip ((-), (3, (7, ())))
10:03:44 <redditbot> Haskell XCB bindings now here
10:04:04 <vixey> redditbot-- # irritating and doesn't give hyperlinks
10:04:08 <pumpkin> *yawn*
10:04:16 <pumpkin> @seen dons
10:04:17 <lambdabot> dons is in #novalang, #haskell, #ghc, #concatenative, #darcs, #xmonad and #arch-haskell. I last heard dons speak 34m 19s ago.
10:04:29 <harblcat> is Data.Array what I need to use to have a multi-dimension array?
10:05:00 <ddarius> @tell dons Have reddit bot give links.
10:05:00 <lambdabot> Consider it noted.
10:05:07 <rwbarton> harblcat: Yes, Data.Array does multidimensional arrays, just use a pair as the index type
10:05:41 <vixey> polveroj,  is even ->> ... || is odd ->> ...  is exaustive? :p
10:05:45 <harblcat> rwbarton: how would I just update one index in it, after the array has been created?
10:06:20 <vixey> polveroj, did you see my annotation?
10:06:20 <rwbarton> harblcat: Well, you'd probably want to use one of the mutable array interfaces, like STArray
10:06:31 <rwbarton> harblcat: but there's also the // operator, if you don't mind copying the whole array
10:06:42 <polveroj> vixey: no, it's conservative about functions.  You have to maybeMatch or forceMatch if it can't prove it's safe to force the maybe
10:07:08 <harblcat> mmm.. STArray will let me have a mutable array, but isn't that kind of dangerous?
10:07:21 <polveroj> vixey: yeah, that looks cool.  I'm not sure how it fits with my uncurrying implementation though
10:07:33 <rwbarton> harblcat: No
10:07:36 <vixey> probably doesn't atm
10:08:07 <polveroj> vixey: my version of the example from the paper would be "deepUncurry flip ((-), (3, (7, ())))"
10:08:23 <Badger> @index deepUncurry
10:08:24 <lambdabot> bzzt
10:08:25 <polveroj> vixey: with the currying combinator inferred by the typeclass
10:08:39 <rwbarton> harblcat: the STArray operations run in ST
10:08:56 <sw17ch> mmorrow: timber?
10:09:02 <harblcat> ST being a monad?
10:10:29 <thoughtpolice> harblcat: yes.
10:11:20 <harblcat> and ST stands for state thread, right?
10:11:34 <pejo> sw17ch, http://timber-lang.org
10:11:43 <thoughtpolice> can't verify that for you, but sure :)
10:11:55 <sw17ch> does it do something special with GC?
10:11:58 <sw17ch> (timber that is)
10:13:14 <pejo> sw17ch, the gc is incremental, and each operation is simple
10:14:02 <dons> ?yow
10:14:02 <lambdabot> I'll show you MY telex number if you show me YOURS ...
10:14:21 * thoughtpolice wonders where some of these lambdabot commands originated...
10:14:34 <pumpkin> hey dons, did you get my @tell?
10:14:38 <dons> nope?
10:14:38 <lambdabot> dons: You have 16 new messages. '/msg lambdabot @messages' to read them.
10:14:41 <dons> ah
10:14:41 <rwbarton> dons:
10:14:42 <rwbarton> -                Just t  -> privmsgH h c $ prefix ++ t
10:14:42 <rwbarton> +                Just t  -> privmsgH h c $ prefix ++ t ++ maybe "" ("  " ++) (rssItemLink item)
10:14:43 <pumpkin> lol
10:14:46 <rwbarton> :)
10:14:47 <pumpkin> everyone wants to talk to dons
10:14:52 <sw17ch> dons: you're not popular or anything, are you?
10:15:18 * Botje starts telling tickets for audiences with dons
10:15:35 <dons> ok. i didn't get the msg
10:15:41 <Botje> 10 audiences and the eleventh is free!
10:15:49 * sw17ch offers Botje two internets for a ticket
10:16:08 * Botje pokes one
10:16:16 <Botje> it doesn't seem very fresh
10:16:20 <Botje> it's full of spam!
10:16:49 <pumpkin> dons: I have a UArr variance and stddev function that's pretty fast... it's hard to test against the Math.Statistics one as the Math.Statistics one runs out of stack space for me on large inputs, but on smaller inputs, it was around 9 times better for me
10:16:49 <Botje> the other one's good though. I'll give you a ticket but i'm cutting me own throat!
10:16:52 * sw17ch offers Botje an Internet2.0
10:17:01 <thoughtpolice> Botje: i will gladly pay you tuesday for an ticket today
10:17:18 <BMeph> sw17ch: It (http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-gc) looks like the closest GHC gets is the -I option which sets the idle time needed for the GC to start. :)
10:17:19 <Botje> :)
10:17:22 <Badger> Botje: got any sausages?
10:17:25 <pumpkin> dons: http://hpaste.org/13786 is it :)
10:17:33 <pumpkin> or should I email it to you?
10:17:36 <Botje> Badger: so fresh the pig doesn't know what's missing :)
10:17:44 <Badger> :D
10:17:44 <sw17ch> BMeph: i'm more looking to tell it how long it's allowed to run
10:17:48 <dons> pumpkin: can you mail me a patch against the darcs repo?
10:17:55 <sw17ch> or at least determine the upper bound on how long it will take to run
10:18:12 <pumpkin> sure, but it'll take me a few minutes to figure out how darcs works :P
10:18:12 <harblcat> can I have an example of using ST?
10:18:33 <pejo> sw17ch, determine the upper bound statically?
10:19:22 <sw17ch> pejo: mostly at any given time
10:19:28 <sw17ch> i'm thinking real time or partitioned operating systems
10:19:56 <dons> harblcat: main = print (runST ...)
10:20:15 <elbar> @ runST (unsafeIOToST $ print "Hello, ST")
10:20:22 <elbar> > runST (unsafeIOToST $ print "Hello, ST")
10:20:24 <lambdabot>   Not in scope: `unsafeIOToST'
10:20:30 <elbar> grr
10:20:43 <sw17ch> pejo: basically, when it comes to proving how long something will take in wall-clock time
10:20:44 <pumpkin> dons: http://code.haskell.org/~dons/code/statistics-fusion/ doesn't seem to contain anything when I get it
10:21:47 <dons> oh. checking..
10:22:44 <sw17ch> ideally, it'd be nice to get a general concept of the heap's complexity to approximate an upper bound on collection time
10:23:09 <dons> pumpkin: try agian
10:23:24 <pumpkin> aha, thanks :)
10:26:36 <pejo> sw17ch, that's a really hard problem in the general case, and Timber won't solve that even partially right now.
10:27:07 <sw17ch> pejo: oh, i'm aware :)
10:27:44 <dons> use haskell as a DSL to generate code for a real time environment, perhaps
10:27:50 <dons> a la Eaton's hydraulic control code
10:29:25 <matthewp> dons: I take it you might get a podcasting visitor soon?
10:30:17 <erikc> is there a forum for proposing new functions in the standard lib? (specifically, (get|put)Bitfield(Word8|Word16|Word32|Word64)(be|le) family of functions that take [(Int, Int)] bit offset/size pairs and return the contents of bitfields
10:31:45 <RayNbow> hmm, is GHCi supposed to exit when you try to evaluate...
10:31:49 <RayNbow> > let x = x in x
10:32:05 <lambdabot>   thread killed
10:32:41 * RayNbow uses GHC 6.10.1 (Win32)
10:33:33 <rwbarton> It's probably running out of memory
10:33:41 <int80_h> @seen dons
10:33:41 <lambdabot> dons is in #novalang, #haskell, #ghc, #concatenative, #darcs, #xmonad and #arch-haskell. I last heard dons speak 5m 51s ago.
10:33:52 * vixey is still wishing for _ in type annotations
10:33:52 <athos> @index (%)
10:33:53 <lambdabot> Data.Ratio
10:34:24 <int80_h> @src sortBy
10:34:24 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
10:34:30 <harblcat> I don't really grok monads yet...
10:34:46 <arjanb> RayNbow: i noticed such problems as well while doing some buggy knot tying
10:35:26 <arjanb> RayNbow: it seem that ghci does crash with a C stack overflow
10:35:59 <vixey> huh?? x /\ 1 = 1?
10:36:06 <pumpkin> dons: I sent it, but it's my first time using darcs so I'm not sure if I did everything right
10:36:14 <vixey> I thought /\ is like &&  and x && True = x
10:36:14 <dons> pumpkin: got the patch, thanks
10:36:14 <Saya> can i define a type class only in terms of other type classes like  class (A a, B a) => C a and no further requirements?
10:36:33 <vixey> Saya, isn't that the exact syntax for it
10:36:34 <vixey> ?
10:36:38 <Saya> oh :p
10:36:46 <dons> pumpkin: oh, but the patch isn't attched.
10:36:48 <pumpkin> dons: oh whoops, I'm dumb
10:36:49 <pumpkin> yeah :P
10:36:50 <dons> did you do 'darcs send'?
10:36:53 <vixey> Saya, great guess!
10:36:58 <Saya> Malformed head of type or class declaration
10:36:58 <rwbarton> Saya: I include a 'where' at the end, but I don't know if it's required
10:37:09 <vixey> Saya, oh but it only works on instances
10:37:24 <Saya> oh forgot something when i wrote it in my program :p
10:37:33 <pumpkin> dons: yeah, but with -o because I wasn't sure how to use my gmail address
10:37:36 <Saya> or no
10:37:38 <lilac> vixey: it's harder than you might think to add _ in type annotations. or at least, it was too hard for me (a ghc newbie)
10:37:55 <vixey> lilac, how hard do I think it is?
10:38:06 <vixey> lilac, I haven't really thought about it but I know I'm not going to implement it
10:38:09 <lilac> well, you might think it would be extremely easy ;-)
10:38:24 <RayNbow> arjanb: does it exit with an error message on your machine? Because here it doesn't and just silently returns to the shell prompt.
10:38:34 <tromp__> > 1280 :% 720
10:38:35 <lambdabot>   Not in scope: data constructor `:%'
10:38:38 <vixey> lilac, I think it's extremely hard for one reason, It would involve editing GHCs code.. other than that haven't really thought about it
10:39:01 <dons> win 44
10:39:03 <lilac> since it should be equivalent to synthesizing an ungeneralized type variable or similar
10:39:09 <rwbarton> vixey: I think it would have complicated interactions with places where type signatures are required, like polymorphic recursion or GADT matching
10:39:25 <Saya> ok now it works without the where :)
10:39:28 <rwbarton> vixey: but maybe I'm wrong
10:39:35 <lilac> > replicate 44 "dons++"
10:39:37 <lambdabot>   ["dons++","dons++","dons++","dons++","dons++","dons++","dons++","dons++","d...
10:39:42 <tromp__> > 1280 Data.Ratio.:% 720
10:39:43 <lambdabot>   Not in scope: data constructor `Data.Ratio.:%'
10:39:49 <lilac> dons: there you go
10:39:50 <pumpkin> tromp__: %?
10:39:54 <pumpkin> > 5 % 6
10:39:55 <lambdabot>   5%6
10:40:02 <arjanb> RayNbow: no it just crashes, but compiled it gives a C stack overflow and it seems to be a regression in 6.10
10:40:03 <baaba> what
10:40:05 <tromp__> oh, right:)
10:40:06 <baaba> :t (%)
10:40:07 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
10:40:11 <baaba> oh
10:40:16 <tromp__> > 1280 % 720
10:40:18 <lambdabot>   16%9
10:40:22 <RayNbow> arjanb: ah, ok
10:40:31 <tromp__> reading about the new Dell Mini 10 :)
10:40:46 <tromp__> looks like a winner
10:43:51 <arjanb> RayNbow: http://hackage.haskell.org/trac/ghc/ticket/2786
10:48:21 <pumpkin> erikc: you could try putting your suggestions on haskell_proposals on reddit, but not many people really follow it :/
10:50:14 <cknapp> Hello, everybody.
10:50:23 <kaol> my n-tuple TH bind wasn't that hard to make
10:57:45 <adrian_> how do I tell quickCheck to generate lists that are longer than 100 items?
10:58:09 <adrian_> forAll (sized $ \n -> resize (n*n) arbitrary) does not work
10:59:32 <cknapp> What does '!' do?
10:59:47 <sw17ch> :t (!)
10:59:49 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
11:00:08 <cknapp> Cool. Thanks...
11:00:11 * cknapp feels stupid
11:00:30 <adrian_> ah check (defaultConfig {configMaxTest=10000})
11:00:33 <vixey> do you know what it does now?
11:00:48 <cknapp> Gives the element at an index.
11:00:57 <cknapp> ?
11:01:47 <sw17ch> yes :)
11:01:52 <vixey> what does Conflicting family instance declarations mean?
11:01:58 <sw17ch> :t Array
11:01:59 <lambdabot> Not in scope: data constructor `Array'
11:02:19 <sw17ch> cknapp: sorry, i didn't mean to make that answer as cold as i did
11:02:21 <sw17ch> :P
11:02:43 <cknapp> Oh, no; It worked perfectly... Everyone needs to feel stupid at times...
11:02:53 <Raevel> except me
11:02:55 <cknapp> Especially when asking an easily answered question.
11:03:10 <thoughtpolice> when in doubt: lambdabot saves!
11:03:37 <thoughtpolice> (and takes half damage)
11:04:12 <pumpkin> dons: why does statistics-fusion's cabal use via-C?
11:05:13 <dons> better code
11:05:27 <dons> some indirect jumps get resolved
11:05:35 <pumpkin> ah, interesting
11:08:53 <vixey> polveroj, are you here still?
11:12:18 <r2q2> Hi
11:12:35 <r2q2> What is a good introduction to haskells data types?
11:14:32 <cknapp> A Gentle Introduction to Haskell, Yet Another Haskell Tutorial, Real World Haskell...
11:14:32 <vixey> type instance does not do what I wanted it to :/
11:15:27 <vixey> with  data Y ; data N   should it be possible to write  type family Join c1 c2,  which task the meet?
11:15:43 <cknapp> r2q2: I would start at the end of the list; I think RWH is the most accessible, and A Gentle Introduction the least.
11:15:53 <vixey> so for Join Y N = Y, and Join N N = N, .. but also for Join (a,b) (u,v) = (Join a u, Join b v)
11:16:09 <mm_freak_> is a Seq more compact in memory than a list?
11:16:20 <vixey> mm_freak, no it won't be
11:16:29 <vixey> mm_freak, more structure internally isn't there?
11:16:30 <bos> mm_freak_: probably less compact
11:16:55 <bos> a Seq is a tree, so it has more bookkeeping overhead
11:18:02 <dolio> Yeah, but the ends can look like: "Four x y z w" instead of "x : y : z : w : []".
11:18:10 <dolio> And the former has fewer tags and such.
11:19:40 <dolio> Although that probably doesn't make it beat lists in general.
11:20:19 <rwbarton> vixey: works for me... http://hpaste.org/13788
11:21:39 <vixey> It's just that I need  (undefined :: Join (Y,Y) (Y,Y)) :: Y  to work as well
11:21:55 <vixey> (infact  Join (Y,N) (N,Y) = Y  as well)
11:22:05 <rwbarton> why wouldn't it be Join (Y, N) (N, Y) = (Y, Y)?
11:22:17 <vixey> well yes
11:22:24 <rwbarton> oh is this for the exhaustivity checking
11:22:36 <vixey> but at the very end of all the joining, I want to check if it's Y everywhere
11:23:28 <mm_freak_> ok, thanks
11:25:07 <vixey> I tried to define a normalizer but stuff like
11:25:12 <vixey> type instance Red (Y,Y) = Y
11:25:13 <vixey> type instance Red (u,v) = (u,v)
11:25:18 <vixey> is disallowed
11:26:08 <vixey> although it seems to like type instance Red ((x,y),v) = ((x,y),v)
11:26:40 <rwbarton> Right, you can only have overlapping instances if the right hand sides agree
11:26:51 <vixey> :(
11:27:00 <vixey> why isn't this type family language easier to program in
11:27:10 <dons> umm
11:27:22 <vixey> yay,   safeMatch (NIL :|: CONS (LEFT VAR) VAR :|: CONS (RIGHT VAR) VAR)  typechecks
11:27:22 <dons> formal systems are hard?
11:27:24 <EvilTerran> because it's a type system, and so not intended to be a full language in its own right?
11:27:45 <augustss> vixey: can't you expand the (u,v) to the other 3 cases?
11:28:05 <vixey> augustss, I went and did that everywhere and I'm hoping that it's worked (at least my test got through)
11:28:11 <polveroj> vixey: oh cool, what are you up to?
11:28:13 <vixey> I don't really undestand why type family does.. though
11:28:33 <augustss> vixey: type families are a mystery
11:28:39 <vixey> yes :)
11:28:51 * vixey is too impatient to wait for docs though
11:28:56 <augustss> a new more cumbersome way of defining functions :)
11:29:09 <pumpkin> dons: I might go and add kurtosis and a couple of others if there's nothing horrendously wrong with what I sent you earlier (seems to be working for me, but I can't say I've tested it exhaustively)
11:29:14 <vixey> polveroj, this http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=751#a753
11:29:16 <polveroj> yeah, just give us type lambdas already and be over with it :)
11:29:29 <vixey> if you ignore the horrible type instance stuff, the rest is vaugely readable
11:29:37 <vixey> anyway, I rewrite this patterns stuff using a GADT
11:29:45 <vixey> (recently I seem to write everything in a GADT...)
11:30:01 <pumpkin> oh no! GADT addiction is very bad
11:30:07 <vixey> so incomplete pattern matches like:  safeMatch (CONS (LEFT VAR) VAR :|: CONS (RIGHT VAR) VAR)
11:30:09 <vixey> give a type error
11:30:13 <pumpkin> detox needed
11:30:59 <vixey> (it says  Couldn't match expected type `Y' against inferred type `Join (N, (Y, N), Y) (N, (N, Y), Y)', ...   perhaps with some more hacking you could write a type family that says what the missing patterns are?)
11:31:55 <vixey> dons, but why not just use something like simply typed lambda calculus?
11:32:29 <dons> as your proof system?
11:32:56 <vixey> instead of this quite odd, awkward rewrite language
11:32:57 <vixey> yes instead of type families
11:32:57 <rwbarton> vixey: I wonder why it didn't try to reduce that Join expression, then you would have gotten a reasonable error message
11:33:06 <EvilTerran> rwbarton, i've noticed it tends to not reduce type families in type errors
11:33:10 <vixey> rwbarton, I think it's an assumption that non-normalized terms are more readible.. can't remember where I read it
11:33:23 <dons> vixey: decidability?
11:33:37 <EvilTerran> dons, vixey did state "simply typed"...
11:33:43 <rwbarton> vixey: I guess that could certainly be the case in many situations
11:33:48 <vixey> dons, equality for simply typed lambda calculus (with lexicographic structural recursive functions) are still decidable
11:34:00 <dons> as the type system. so i imagine he means something like a pure type system
11:34:08 <vixey> seems a hell of a lot more sensible than what we have currently
11:34:27 <EvilTerran> "simply-kinded type-lambda calculus"?
11:34:28 <dons> do you want that as your value  level, or your type level?
11:34:45 <vixey> type level, to replace the mechanics of whatever-the-hell drives this kid of stuff:
11:34:46 <vixey> a
11:34:51 <vixey> type family Red c
11:34:51 <vixey> type instance Red Y = Y
11:34:51 <vixey> type instance Red N = N
11:34:56 * BMeph goes to make a sign saying, "Free the Type Lambda Twenty!" ;p
11:35:16 <dons> you might want to think about what your type system would be actually doing then.
11:35:54 <vixey> dons, I think type inference would not have to take it into account,  but typechecking would need to check that simple typed lambda expressions are equal -- which is easy
11:36:02 <dons> this is whatever-the-hell is driving your current stuff, http://galois.com/~dons/images/fc-tr.png
11:36:13 <vixey> ah cool!
11:36:30 * rwbarton expected to see a picture of Oleg
11:36:36 <vixey> got to read this paper
11:37:40 * Trafalgard can't seem to find any information about what the heck showPackageId was supposed to do
11:38:14 <Trafalgard> VS Haskell's haskell project component's setup script calls it, and it won't compile because that function no longer exists
11:38:33 <Trafalgard> something says "use the Text class instead" but that's helpfully vague
11:38:52 * vixey wonders if there is any lambda calculus which is its own type system?
11:39:46 <EvilTerran> vixey, i think that'd suffer from incompleteness
11:40:00 <vixey> incompleteness? no problem.
11:40:02 <dolio> Calculus of constructions?
11:40:09 <vixey> not CoC
11:40:49 <vixey> I meant literally like, turtles all the way up.. without degenerating into Type[10] : Type[11] : ...
11:41:23 <vixey> It's probably stupid enough that nobody bothered to study it I gues.. :p
11:41:58 <dolio> Well there are plenty of Type : Type papers out there, but that leads to undecidability and stuff.
11:43:18 <vixey> oh of course
11:43:46 <vixey> it's a bit strange to think people would not have suspected that Type : Type is inconsistent..a
11:45:05 <dolio> They know it's inconsistent. It's a question of whether you care.
11:46:22 <BMeph> How about programming by shape? :)
11:46:47 <kaol> by shapr
11:50:01 <augustss> Type : Type doesn't have to lead to undecidability.
11:50:32 <augustss> Nor inconsistency.
11:50:40 <augustss> It all depends on what else you have.
11:57:52 <vixey> this paper about Fc says that Fomega has got type level lambda
11:59:06 <vixey> I thought it didn't... and there is not any mention of that on wikipedia
11:59:45 <vixey> oh no. I just misread the page.. sorry
12:03:22 <augustss> vixey: yes , Fw has type level lambdas
12:03:51 <vixey> I was sure it didn't :S .. I don't know where I got that idea from
12:03:58 <vixey> thanks though
12:04:21 <byorgey> in fact, that is exactly what Fw has that system F doesn't
12:04:51 <sw17ch> does any one else ever get the urge to fake newtype'ing in C? --> http://hpaste.org/13791
12:05:36 * vixey will remember it now :p
12:07:24 <dolio> F2 doesn't, but F3 and above do, no?
12:09:12 <dolio> Of course, F3 and above are lame; might as well go all the way to Fw.
12:09:38 <vixey> :o
12:09:45 <vixey> in System Fc paper it's got this example:
12:09:58 <vixey> kind Nat = Z | S Nat
12:10:06 <vixey> type Plus :: Nat -> Nat -> Nat
12:10:21 <vixey>      Plus Z b = b ; Plus (S a) b = S (Plus a b)
12:10:32 <vixey> and it says they didn't implement it but it might be useful
12:11:52 <dolio> Yeah. Datakinds would be handy.
12:11:56 <dolio> See Omega.
12:12:08 <dolio> And, uh, Agda and Coq.
12:12:13 <vixey> Omega makes me fell ill
12:12:36 <vixey> I don't have an intuitive understanding of narrowing, so I can't deal with the error messages I get
12:12:48 <vixey> like I have no clue if it's my fault or that narrowing didn't do enough
12:14:19 <dolio> Datakinds are probably the more appropriate way to do stuff like type level arithmetic.
12:14:33 <dolio> Even if they implement their closed type families...
12:16:30 <dolio> Since you really only want to define Plus and Times and such over the types that denote naturals.
12:16:57 <dolio> And datakinds do that without having to add in void cases and stuff.
12:17:12 <polveroj> dolio: yeah, I frequently wish I had a type system in my type system so I could typecheck my type-level code.
12:17:26 <cknapp> :t ($=)
12:17:27 <lambdabot> Not in scope: `$='
12:18:16 <vixey> polveroj, hehehe
12:18:29 <vixey> I think the best way to do type level arithmetic is not
12:18:48 <vixey> instead, just take the (+) :: Integer -> Integer -> Integer you already wrote
12:19:45 <vixey> polveroj, I am wondering if I can maybe simplify the horrid use of type families I did..
12:23:47 <polveroj> vixey: hmm, maybe.  Making "append" be (,) seems to complicate things--I kept all my tuples in normal form
12:24:16 <vixey> polveroj, referring to your append or one of mine?
12:24:58 <vixey> polveroj, oh by horrid use of type families, I meant the Join/Normalize/Red stuff
12:27:54 <polveroj> vixey: well, I wrote out GLB (which is your Join) for each pair of {always, never, (a,b), ()}
12:28:20 <vixey> there might be a better way but I don't know this Fc stuff well
12:28:40 <polveroj> vixey: but all my tuples are ()-terminated lists, so I don't have to do as much tuple juggling to recurse
12:28:50 <vixey> polveroj, does it still work though?
12:29:18 <vixey> polveroj, I thought about using () terminated tuplists, but then I got worried about it not being correct
12:31:00 <vixey> (it might give false positives on cases where the things have different structure.. but that would never be checked in the first place. so it's hard to tell)
12:31:16 <polveroj> vixey: yeah, that's what I was thinking.
12:35:11 <polveroj> vixey: I don't see a way to make it extensible to arbitrarily many constructors without tuplists, though
12:35:29 <polveroj> vixey: I was considering writing some TH to generate selectors
12:35:51 <polveroj> vixey: (which is one of the reasons I didn't use GADTs, actually)
12:42:43 <jonaskoelker> how do you guys pefer to generate a random permutation of a list?  I sort by an infinite list of random numbers, and I'm a bit unhappy about it taking O(n log n) time
12:42:58 <jonaskoelker> (I'm not much experienced in functional algorithmics...)
12:44:09 <dons> jonaskoelker: is performance a concern?
12:44:30 <dons> n log n seems ok, imo.
12:44:30 <jonaskoelker> it's always a concern :)
12:44:42 <dons> try using an array perhas
12:45:03 <dons> just fill it directly by zipping with the infinite randoms
12:45:03 <pumpkin> you could do it easily in O(n) on an array
12:45:07 <jonaskoelker> yeah
12:45:21 <jonaskoelker> that one I know well back from my imperative days ;)
12:45:32 <dons> well, you can do it here too.
12:45:50 <polveroj> does Array have a function for performing a list of swaps?
12:46:02 <Saizan> that doesn't give you an uniform distribution though, right?
12:46:17 <jonaskoelker> Saizan: sorting by random?  Why wouldn't it?
12:46:28 <sw17ch> polveroj: what does "list of swaps" mean?
12:47:02 <pumpkin> polveroj: I think the typical thing to do is to zip with the new order, and sort on the zipped field
12:47:55 <polveroj> you can do it in O(n) by swapping the first element with a random element, the second with a random element other than the first, the third with a random element other then the first two etc
12:48:45 <polveroj> (this gives you n! possibilities; not excluding the already-swapped elements gives you n^n instead and is wrong)
12:49:39 <Saizan> http://okmij.org/ftp/Haskell/perfect-shuffle.txt
12:51:04 <hugo___> hi
12:52:15 <Jedai> But seriously, using an array isn't such a bad deal I suspect. I would be you I would benchmark Oleg solution and an array based classic shuffle.
12:52:42 <n0nsense> hi
12:52:55 <n0nsense> can anyone help me with gtk2 on archlinux?
12:53:06 <n0nsense> (the gtk-haskell-bindings)
12:53:19 <Saizan> Jedai: you can implement oleg's solution with an array in O(n), it's just the algorithm polveroj described
12:53:51 <Saizan> Jedai: but zipping with a list of random numbers and sorting on them doesn't give you a perfect distribution
12:54:12 <Elly> knuth shuffle!
12:54:13 <Jedai> Saizan: Ah yes, but if I remember correctly Oleg's solution provides a perfect shuffle on a list in O(n log n)
12:54:14 <jonaskoelker> Saizan: it does if you zip by a list of infinite lists of random numbers, right?
12:54:17 <n0nsense> i can't find them
12:54:33 <Jedai> jonaskoelker: I don't think so
12:54:43 <jonaskoelker> Jedai: hm.  Why not?
12:54:51 <Saizan> jonaskoelker: no, why? you're going to use a finite number of them
12:55:00 <Saizan> jonaskoelker: there's an explanation in the link above
12:55:02 <int-e> jonaskoelker: you need an infinite range of random numbers - duplicates skew the distribution
12:55:23 <Jedai> Jedai: I was just wondering if using an intermediate array might not be faster than using Oleg's solution directly on a list
12:55:41 <Jedai> s/Jedai/Saizan
12:56:51 <n0nsense> -.-
12:56:56 <Jedai> Saizan: the complexity of the array based solution is O(n) though with a big constant while the list based solution is O(n log n), even if the memory used might be less
12:57:30 <kmeyer> is (!) the array access operator?
12:57:43 <Saizan> kmeyer: yes
12:57:46 <kmeyer> k
12:57:50 <kmeyer> looked that way from the docs
12:57:54 <Saizan> n0nsense: what's your problem with gtk2hs?
12:58:34 <Saizan> Jedai: i think we'd have to benchmark that
12:58:38 <jonaskoelker> okay; here's my thinking: sort the list of lists of random numbers.  Replace each list with its index.  You now have [(e1, r1), ..., (en, rn)], with ri != rj for i != j.  Sorting on unique random keys gives a uniform choice.
12:58:42 <jonaskoelker> where am I wrong?
13:01:07 <Saizan> the _unique_ part is not usually included, since you've to generate an arbitrary number of random numbers to get an unique prefix of length n
13:01:14 <Jedai> jonaskoelker: Firstly I guess you have a problem with the uniqueness of your random keys
13:01:30 <n0nsense> Saizan: ah, finally found it. thanks
13:01:32 <gnuvince_> Is infix[rl] a function or a special form?
13:01:42 <Jedai> gnuvince_: it's a keyword
13:01:44 <ziman> it's builtin
13:01:47 <gnuvince_> Jedai: merci
13:03:55 <Jedai> jonaskoelker: If your random number really are unique and uniformly distributed, then you really have a perfect shuffle but with the random generator around it's two big "if"
13:04:30 <jonaskoelker> So either I hang or the random generator is crappy or I have the perfect random shuffle?
13:05:06 <jonaskoelker> I know that number two is true (unfortunately), but if I had a better one I'd either loop or generate a perfect shuffle... yes?
13:05:26 <Jedai> jonaskoelker: Even the good random generators don't guarantee uniqueness usually
13:05:33 <Holle_> exists a function which executes a function on every element of a list?
13:05:45 <polveroj> Jedai: infinite streams can never compare as equal though
13:05:54 <Saizan> Holle_: map or mapM
13:06:21 <Saizan> if you guarantee uniqueness than your distribution is not uniform
13:06:34 <Holle_> i mean something like "map (\x -> (putStrLn.show) x) list"
13:06:49 <jonaskoelker> Holle_: mapM_ (putStrLn . show) list
13:07:19 <Holle_> great! thanx!
13:09:27 <vixey> polveroj: TH has problems with GADTs?
13:09:42 <polveroj> vixey: no, but GADTs are closed
13:10:16 <polveroj> vixey: so you can't build new patterns except by composing existing ones
13:10:28 <vixey> oh right, or adding a new one to the GADT
13:13:31 <Holle_> trying it i get this error: *** Type           : Window -> IO [()] *** Does not match : Window -> IO ()
13:17:47 <Jedai> Personally I don't find a solution that hangs from time to time better than a solution that gives imperfect results (but generally usable), especially when you have a better solution that never hangs, give perfect shuffle and has even a lower complexity...
13:18:28 <jonaskoelker> true
13:18:38 <jonaskoelker> I'll change my code :)
13:18:42 <harblcat> the easiest way to program in haskell is...?
13:18:51 <ziman> Holle_, putStrLn.show is also known as print
13:19:02 <enticingjelly> :t print
13:19:04 <lambdabot> forall a. (Show a) => a -> IO ()
13:19:04 <vixey> harblcat, with a typechecker around
13:19:07 <Jedai> polveroj: Sure they can't, (==) is a partial function on them... Though in this case, the equality could be decided since they're completely dependant on the seed of the rg used to create them
13:19:09 <jonaskoelker> harblcat: find a problem you want to solve, and work at it :)
13:19:12 <enticingjelly> holy shit.
13:19:43 <ziman> enticingjelly, have you been writing putStrLn.show all the time? :)
13:19:56 <polveroj> Jedai: (==) is a partial function on them that, when it halts, is always False
13:19:57 <Holle_> putStrLn was just an example. i am using "drawInWindow w (withColor Red (polygon x))" of graphics.soe
13:20:09 <enticingjelly> ziman, *all* the time, or often defining p = putStrLn . show somewhere...
13:20:31 <harblcat> well, what if I want to make mostly interactive programs?
13:20:59 <jonaskoelker> harblcat: depends on what you mean by interactive...
13:21:13 <harblcat> er... nethack?
13:21:17 <enticingjelly> ziman, I just never cared to look if it's already there (even though I do it all the time, for other functions)
13:21:24 <polveroj> Jedai: and `compare` will give LT or GT in a small, finite expected time
13:21:41 <harblcat> basically, get a key, do something, get a key, etc...
13:21:50 <jonaskoelker> harblcat: go look for a curses library and get hacking :)
13:21:56 <ziman> enticingjelly, yeah, sometimes it's easier to just write the definition :)
13:22:09 * pumpkin is amazed at how lengthU = foldlU (const . (+1)) 0 is O(1)
13:22:12 <jonaskoelker> not sure which library though...
13:22:15 <Jedai> polveroj: Right, your point being ?
13:22:16 <harblcat> are there any curses libraries that are cross platform, though?
13:22:42 <jonaskoelker> pumpkin: (foo)U?
13:22:48 <enticingjelly> ziman, yup %)
13:22:57 <harblcat> I remember trying to find a cross platfrom ansi library; that was not so fruitful
13:22:58 <enticingjelly> by the way
13:23:18 <pumpkin> jonaskoelker ?
13:23:18 <ziman> pumpkin, is it a rewrite rule?
13:23:30 <jonaskoelker> pumpkin: lengthU, foldlU, what's the U?
13:23:34 <pumpkin> ziman: not sure how the magic works, but a comment above it says O(1)
13:23:40 <pumpkin> jonaskoelker: for the UArr in uvector
13:23:41 <vixey> :t const . (+1)
13:23:42 <lambdabot> forall b a. (Num a) => a -> b -> a
13:23:43 <Jedai> pumpkin: That's a pretty amazing optimization...
13:23:43 <ziman> neat ;)
13:23:48 <vixey> :t const (+1)
13:23:49 <lambdabot> forall a b. (Num a) => b -> a -> a
13:23:53 <pumpkin> Jedai: UArr is pretty amazing :P
13:24:14 <int-e> pumpkin: hmm, does that work with +2, too?
13:24:20 <polveroj> Jedai: jonaskoelker was sorting N streams of random numbers to get a random permutation of 1...N, which I think should work because you never have collision problems with streams
13:24:29 <vixey> why is it O(1)?
13:24:33 <pumpkin> int-e: not a clue :) the comment might be lying/out of sync with the code, but if it's true, I'm pretty amazed :P
13:24:39 <pumpkin> from http://hackage.haskell.org/packages/archive/uvector/0.1.0.3/doc/html/src/Data-Array-Vector-Strict-Basics.html#mapU
13:25:02 <pumpkin> maybe it's the commented-out version that's O(1)
13:25:04 <pumpkin> Prim.lengthU
13:25:36 <Jedai> polveroj: Right, if you define "work" as "sometimes hang indefinitely while there's a perfectly good solution that don't and that even perform faster in all conditions"
13:26:06 <enticingjelly> :t \f a b -> unzip `fmap` zipWithM f a b
13:26:07 <lambdabot> forall a b a1 b1 (f :: * -> *). (Functor f, Monad f) => (a1 -> b1 -> f (a, b)) -> [a1] -> [b1] -> f ([a], [b])
13:27:28 <enticingjelly> :t \f a b -> mapAndUnzipM (curry f) (zip a b)
13:27:30 <lambdabot> forall b b1 c a b2. (((a, b2), b) -> (b1, c)) -> [a] -> [b2] -> b -> ([b1], [c])
13:27:51 <sw17ch> i like asking for types that don't make sense...
13:27:54 <polveroj> Jedai: oh, I agree it's a silly algorithm to actually use
13:27:56 <sw17ch> :t (+) (+) (+) (+)
13:27:58 <lambdabot> forall a. (Num ((a -> a -> a) -> (a -> a -> a) -> a -> a -> a), Num a, Num (a -> a -> a)) => (a -> a -> a) -> a -> a -> a
13:28:13 <sw17ch> :t (+) . (+) . (+) . (+)
13:28:15 <lambdabot> forall a. (Num a, Num (a -> a), Num ((a -> a) -> a -> a), Num (((a -> a) -> a -> a) -> (a -> a) -> a -> a)) => a -> (((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) ->
13:28:15 <lambdabot>  a -> a
13:28:24 <enticingjelly> :t \f a b -> mapAndUnzipM (uncurry f) (zip a b)
13:28:25 <lambdabot> forall a b (m :: * -> *) b1 c. (Monad m) => (a -> b -> m (b1, c)) -> [a] -> [b] -> m ([b1], [c])
13:28:44 <jonaskoelker> @pl \a b c d -> a + b + c + d
13:28:44 <lambdabot> ((((+) .) . (+)) .) . (+)
13:29:10 <enticingjelly> @pl \f a b -> unzip `fmap` zipWithM f a b
13:29:11 <lambdabot> (((unzip `fmap`) .) .) . zipWithM
13:29:18 <enticingjelly> @pl \f a b -> mapAndUnzipM (uncurry f) (zip a b)
13:29:19 <lambdabot> (. zip) . (.) . mapAndUnzipM . uncurry
13:29:48 <enticingjelly> yup, really pointless.
13:30:07 <enticingjelly> but seriously now, one of the two aforementioned functions would be nice in the standard library
13:30:10 <Peaker> enticingjelly: note that @pl just proves its possible but very often finds an ugly PL where nice PL's also exist
13:30:13 <enticingjelly> called map2M or something
13:30:13 <harblcat> it seems that there aren't any cross platform curses libraries for haskell...
13:30:22 <Peaker> @type unzip
13:30:24 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
13:30:27 <harblcat> anyone have experience in wxHaskell?
13:31:32 <pumpkin> Peaker: we need an objective function for elegance!
13:31:45 <pumpkin> maybe negate the number of flips
13:31:56 <pumpkin> and then search over all possible transformations
13:32:05 <pumpkin> :P
13:32:34 <Holle_> what can i do to get IO () instead of [()]
13:32:50 <pumpkin> Holle_: you could do sequence_
13:33:05 <pumpkin> or the underscore version of whatever you used to make the [()]
13:33:25 <Holle_> what means "underscore"?
13:33:34 <pumpkin> many functions have underscore versions
13:33:35 <C-Keen> Holle_: "_"
13:33:38 <pumpkin> mapM, mapM_
13:33:40 <pumpkin> :t mapM
13:33:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
13:33:43 <pumpkin> :t mapM_
13:33:45 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
13:34:01 <polveroj> Holle_: underscore usually means "throwing away the result and returning ()"
13:36:38 <ziman> Holle_, "your_function >> return ()" will always work (although using an M_ function would be better, if one is available)
13:37:27 <Holle_> nice it works :)
13:43:07 <vixey> > 'ν'
13:43:08 <lambdabot>   '\957'
13:48:41 <chrisdone> screw backwards compatibility
13:48:49 <chrisdone> write new code
13:48:57 <chrisdone> it needs rewriting anyway
13:49:21 <chrisdone> you're just hindering innovation
13:51:08 <sjanssen> chrisdone: but it doesn't need rewriting!
13:58:44 <vixey> I can't see what is the difference between reify and reflect..
13:59:06 <vixey> it seems like an artificial separation
13:59:26 <ddarius> vixey: They should be conceptual inverses...
13:59:42 <vixey> I write NbE where reify = reflect
14:00:00 <Riastradh> ?
14:01:24 <vixey> I don't get it :/a
14:01:41 <Riastradh> I don't get `I write NbE where reify = reflect' either.
14:01:57 <vixey> have you seen the algorithm Riastradh?
14:02:00 <ddarius> vixey: reify should be Semantics -> Syntax and reflect Syntax -> Semantics (and more precisely it would be an embed-project pair, reflect . reify /= id in general)
14:02:12 <vixey> ddarius, but Syntax = Semantics
14:02:19 <ddarius> vixey: Possibly.
14:02:37 <vixey> I have to write  quote . reify . eval
14:03:42 <adrian_> I thought ByteStrings were always faster than Strings
14:03:54 <ddarius> adrian_: No.
14:04:04 <ddarius> X is always faster than Y is almost never true.
14:04:05 <Riastradh> I can easily write a program using ByteStrings that runs much slower than, but computes the same answer as, a program that uses Strings!
14:04:28 <adrian_> my Knuth-Morris-Pratt implementation needs twice as much time with ByteStrings
14:04:38 <vixey> there was one example where reflect uses delimited continuations but reify didn't
14:04:52 <adrian_> I'm quite dissappointed
14:04:59 <vixey> other than that, they usually are the same except for swapping up and down arrows
14:05:04 <chrisdone> adrian_: profile!
14:05:05 <ddarius> adrian_: ByteStrings are good for small strings.
14:05:19 <ddarius> s/are/aren't.
14:05:29 <adrian_> hm
14:05:43 <adrian_> the text I search I quite large
14:05:50 <Jedai> adrian_: On the other hands that might be just due to you not really understanding the cost of various function over ByteStrings
14:06:02 <adrian_> but during the algorithm I fiddle around witch much shorter prefixes
14:06:07 <adrian_> jedai: possibly
14:06:33 <Jedai> adrian_: There is a bytestring-search package (or something like that) on hackage with a KMP, you should try that too and compare
14:07:31 <Jedai> adrian_: A lot of function have different complexities on String and ByteString since the data structures are quite different after all
14:07:54 <adrian_> according to the profiling information, the most expensive function is this one http://hpaste.org/13794
14:08:07 <adrian_> the documentation says uncons is O(1)
14:09:34 <sjanssen> adrian_: uncons on ByteString is probably just a bit slower than case/head/tail on lists
14:09:57 <adrian_> probably
14:09:58 <ddarius> That function is not tail recursive.
14:10:11 <adrian_> is it not?
14:10:52 <Deewiant> adrian_: the last function to be called there is (+), not eqs
14:10:57 <Deewiant> Hence, it's not.
14:11:12 <adrian_> I see
14:11:12 <Jedai> adrian_: Well no, in (1 + eqs () ())  eqs is not in tail position
14:11:18 <bos> it's a pretty bad way to write the function, anyway. you're inspecting the list to see if it's empty twice.
14:11:32 <bos> null does it once, then uncons does it
14:11:48 <adrian_> I had a head/tail there first
14:11:52 <adrian_> but you're right
14:12:20 <Jedai> adrian_: You could just make a case of on the result of uncons, there's a reason it returns a Maybe
14:14:37 <Jedai> eqs !n a b = case (uncons a, uncons b) of
14:14:38 <Jedai> 		(Just (ha, ta), Just (hb, tb) | ha == hb -> eqs (n+1) ta tb
14:14:38 <Jedai> 		_                                                               -> n
14:15:16 <Jedai> something like that
14:15:27 <vixey>  eqs $! (n+1) ta tb  works too
14:15:36 <dolio> Nope.
14:15:40 <vixey> really??
14:15:46 <Jedai> vixey: and without an extension right
14:15:51 <dolio> (eqs $! n+1) ta tb
14:15:54 <ddarius> vixey: That parses as eqs $! ((n+1) ta tb)
14:15:57 <vixey> oh..
14:17:01 <Jedai> anyway the function can be vastly improved though it might not be the main problem
14:18:27 <JoshTriplett> @pl \x -> fromMaybe [] x
14:18:28 <lambdabot> fromMaybe []
14:18:47 * JoshTriplett hoped that would tell me if a function exists that does fromMaybe [].
14:19:03 <dolio> There isn't.
14:19:03 <JoshTriplett> @hoogle Maybe [a] -> [a]
14:19:04 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
14:19:04 <lambdabot> Prelude cycle :: [a] -> [a]
14:19:04 <lambdabot> Prelude init :: [a] -> [a]
14:19:29 <beelsebob> JoshTriplett: maybe
14:19:29 <dolio> Oh, well, yes, that foldable probably works.
14:19:43 <beelsebob> > maybe [] id (Just [5])
14:19:44 <lambdabot>   [5]
14:19:48 <beelsebob> > maybe [] id Nothing
14:19:49 <lambdabot>   []
14:19:55 <JoshTriplett> beelsebob: fromMaybe [] == maybe [] id
14:20:08 <JoshTriplett> > concat $ Just [1, 2, 3]
14:20:10 <lambdabot>   Couldn't match expected type `[[a]]'
14:20:14 <beelsebob> oh, sorry, I'm being a fail at reading
14:20:22 <JoshTriplett> beelsebob: Happens to all of us. :)
14:20:30 <JoshTriplett> > Data.Foldable.concat $ Just [1, 2, 3]
14:20:31 <lambdabot>   [1,2,3]
14:20:37 <JoshTriplett> > Data.Foldable.concat $ Nothing
14:20:39 <lambdabot>   []
14:20:48 <JoshTriplett> OK, that works nicely, but seems just a tad too magic.
14:21:00 <dolio> Why does that exist, though? Is fold not good enough?
14:21:16 <dolio> We have to monomorphize in our generalization libraries, too? :)
14:21:19 <dons> ?bug
14:21:19 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
14:25:03 <matthewp> dons: had a quick question about monad isolation using typeclasses.  This solution is adequate if you're doing one type of IO with one handle.
14:25:03 <koeien> (speaking as a vim user) is "haskell-mode" the best haskell-library for emacs as of today?
14:25:07 <JoshTriplett> @pl let f p c = do guard (p job); [c] in f
14:25:08 <lambdabot> (line 1, column 31):
14:25:08 <lambdabot> unexpected "["
14:25:08 <lambdabot> expecting "()", natural or identifier
14:25:15 <matthewp> I guess design would say that you only deal with one handle type at a time
14:26:03 <matthewp> meaning another function would handle the writing some results to a file, where another function retrieved the results from the DB
14:31:52 <EvilTerran> @undo \p c -> do guard (p job); [c]
14:31:52 <lambdabot> \ p c -> guard (p job) >> [c]
14:31:57 <EvilTerran> @pl \ p c -> guard (p job) >> [c]
14:31:57 <lambdabot> (. return) . (>>) . guard . ($ job)
14:34:15 <JoshTriplett> EvilTerran: Actually, I wanted to pl a much more complicated expression, but I first wanted to test if let would work.
14:34:25 <JoshTriplett> EvilTerran: I don't really want to inline that function everywhere I call it. :)
14:38:22 <polveroj> what's the precedence of -> in lambda expressions?
14:38:40 <BONUS> rly low
14:39:06 <BONUS> basically a lambda eats up everything to its right unless surrounded by parens
14:39:11 <BONUS> someone correct me if im wrong
14:39:37 <dolio> Yes.
14:39:42 <polveroj> is it so low you can't define operators with lower precedence?
14:39:56 <dolio> It's syntax.
14:39:57 <BONUS> the -> in lambda is not an operator really
14:39:58 <BONUS> yeah
14:40:15 <dolio> \ps -> e is the syntax for lambda expressions.
14:40:20 <polveroj> yeah
14:40:27 <jonaskoelker> I need "monad stacks 101".  I have a function roll that should return Either String [Integer], and roll' wants to do the work and drag around a Reader and a MonadRandom.  What's going to be the type of roll'?
14:40:56 <vixey> @fo monad transformers step by step
14:40:57 <lambdabot> Maybe you meant: foldoc forget fortune ft
14:41:00 <vixey> @go monad transformers step by step
14:41:07 <lambdabot> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
14:41:07 <lambdabot> Title: Monad Transformers Step by Step
14:45:54 <Holle_> how do i return a value using "do"?    function :: Int -> Bool    function x = do ... ; True
14:46:12 <vixey> Holle_, you cannot do that
14:46:14 <BONUS> why are you using "do" if you have an Int -> Bool function
14:46:15 <Heffalump> if the body of the function is a do, then the function must have a monadic return type
14:46:26 <vixey> it's got to be [Boo] or Maybe Bool or whatever
14:46:27 <Peaker> @type do 5
14:46:28 <lambdabot> forall (t :: * -> *) t1. (Num (t t1)) => t t1
14:46:54 <Peaker> @undo do 5
14:46:54 <lambdabot> 5
14:46:58 <Peaker> @type 5
14:46:59 <lambdabot> forall t. (Num t) => t
14:47:03 <Peaker> "undo" lies :)
14:47:19 <vixey> @undo fix (\u -> do u <- u u)
14:47:19 <lambdabot>  Parse error at ")" (column 23)
14:47:26 <vixey> @undo fix $ \u -> do u <- u u
14:47:26 <lambdabot>  Parse error at end of input
14:47:31 <vixey> boo
14:47:32 <Holle_> ok
14:47:37 <vixey> @undo do u <- u u
14:47:38 <lambdabot>  Parse error at end of input
14:47:39 <dolio> Do's just following the Haskell 98 rules.
14:47:42 <vixey> @undo do u <- u u ; return u
14:47:43 <lambdabot> u u >>= \ u -> return u
14:47:43 <dolio> Undo, even.
14:48:13 <polveroj> so you can use do with non-monadic types if you don't have any newlines/semicolons?
14:49:07 <BMeph> polveroy: See Heffalump's last comment. ;)
14:49:29 <polveroj> BMeph: that's not what lambdabot seemed to say, though
14:49:35 <BMeph> Haskell: Learn It, Love It, Live It! :)
14:49:45 <vixey> Drink Haskelcola
14:49:53 <polveroj> BMeph: there wasn't any (Monad t) constraint
14:50:04 <JoshTriplett> Holle_: Perhaps you could clarify what you want to do?
14:50:14 <JoshTriplett> Holle_: Or rather, what you want to "do". :)
14:51:00 <Holle_> ^^ thanks i am now using "let ... in ..." instead of "do ..."
14:51:09 <BONUS> let bindings own
14:51:10 <JoshTriplett> Holle_: Ah. :)
14:51:40 <BONUS> let x = x in x
14:51:41 <BONUS> hehe
14:51:58 * ddarius almost never uses let bindings.
14:52:14 * JoshTriplett tends to use "where" more often, but still uses let sometimes.
14:52:43 <JoshTriplett> I almost always use "where" for helper functions, but occasionally I use let for *variables* that simplify a later expression.
14:52:46 <JoshTriplett> Particularly in a do.
14:53:05 <BONUS> i use where for helper functions and let for local variables
14:53:06 <JoshTriplett> I often find myself writing a do with 3 monadic operations and 10 lets. :)
14:53:11 <JoshTriplett> BONUS: Yeah.
14:58:27 <BONUS> hmm. lets see if im getting this straight
14:58:49 <pumpkin> homophobe
14:59:01 <BONUS> in comonads, extract, duplicate and =>> are analogous to return, join and >>=
14:59:02 <BONUS> haha
14:59:05 <BONUS> :]
14:59:19 <vixey> s/analogous/dual/
14:59:19 <amaron_> thats kinky
14:59:39 <BONUS> aha. dual as in category theory dual?
14:59:46 <ddarius> BONUS: As in one of them.
14:59:55 <ddarius> (The one usually labelled "co")
15:00:00 <ddarius> (as opposed to "op")
15:00:07 <BONUS> aha i see
15:00:45 <amaron_> what do you use them for?
15:01:06 <BONUS> i dont use them for anything personally, just reading about them
15:01:17 <BONUS> sigfpe used them for stream functions
15:01:29 <BONUS> http://sigfpe.blogspot.com/2006/06/monads-kleisli-arrows-comonads-and.html
15:01:42 <ddarius> Streams being the cofree comonad on the identity functor.
15:01:43 <amaron_> arrows, huh
15:01:57 <amaron_> i'm still digesting monads
15:02:11 <Riastradh> sigfpe makes it hard to Google for information about handling floating-point traps on Unix.
15:02:26 <ddarius> @google sigfpe
15:02:29 <lambdabot> http://en.wikipedia.org/wiki/SIGFPE
15:02:29 <lambdabot> Title: SIGFPE - Wikipedia, the free encyclopedia
15:02:38 <BONUS> haha
15:03:49 <redditbot> well-foundedness, part 1 of 2: who cares?
15:04:30 <dolio> Seriously.
15:04:41 <pumpkin> oh sweet, my lib has that category theory book that Cale has in PDF :)
15:04:42 <dons> yeah, totally.
15:04:47 <vixey> redditbot, link?
15:04:54 <dons> reddit/haskell.
15:04:55 <BONUS> pumpkin: which book is that
15:05:07 <vixey> it'd be good if the bot did it automatically
15:05:10 <dons> yep
15:05:14 <vixey> curretly it's just annoying
15:05:16 <pumpkin> BONUS: the awodey one
15:05:20 <BONUS> i wonder, do i need to be subscribed to both planet haskell and reddit haskell
15:05:20 <ddarius> BONUS: "Category Theory" by Steven Awodey
15:05:24 <dons> patches welcome. http://hackage.haskell.org/cgi-bin/hackage-scripts/package/rss2irc
15:05:32 <vixey> you already got given a patch didn't you
15:05:37 <pumpkin> it looks pretty good, but I'm not a fan of reading the huge book in a pdf
15:05:38 <dons> nope.
15:05:45 <vixey> pasted to this channel
15:05:49 <ddarius> pumpkin: It is pretty good.
15:05:52 <dons> nope
15:05:57 <dons> vixey: send one.
15:06:07 <dons> http://code.haskell.org/~dons/code/rss2irc/ darcs patch here
15:06:22 <pumpkin> ddarius: yeah, I really like what I've read of it so far :) it's just a bit of an eyestrain
15:06:26 <pumpkin> and it's very expensive to buy
15:06:30 <vixey> 10:14:42 <rwbarton> -                Just t  -> privmsgH h c $ prefix ++ t
15:06:31 <vixey> 10:14:42 <rwbarton> +                Just t  -> privmsgH h c $ prefix ++ t ++ maybe "" ("  " ++) (rssItemLink item)
15:06:31 <BONUS> the book costs $124
15:06:31 <BONUS> omg
15:06:40 <pumpkin> BONUS: yeah, that's why I was happy my lib had it :P
15:06:43 <dons> hey, awesome. 1700 subscribers to haskell reddit. that's pretty close to -cafe@
15:06:47 <dons> i bet it overtakes -cafe soon
15:07:02 <pumpkin> ooh my lib has TAPL too
15:07:05 <pumpkin> yay for saving money
15:07:12 <vixey> dons that should do it
15:07:17 <ehird> dons: how many % of those just want to be in with the cool reddit crowd? :P
15:07:20 <BONUS> while we're on that topic, i got RWH for a really low price of like 22 euros because 22 GBP = 22 euros. love that weak UK pound.
15:07:22 <EvilTerran> i'd almost say TaPL's worth paying for
15:07:30 <dolio> Really? Only 1700 on haskell-cafe?
15:07:33 <EvilTerran> if you can find a used copy, anyway
15:07:42 <dons> dolio: no, 2.5k or so last i checked
15:07:46 <pumpkin> EvilTerran: yeah, probably... but for now I can just check it out for several months :P
15:07:53 <dolio> Ah. Well, nevertheless.
15:07:55 <dons> just goes to show the web is more important
15:08:00 <dolio> We have 1/4 of that in this channel right now.
15:08:01 <BONUS> im not subscribed to haskell-cafe because i still don't get mailing lists
15:08:05 <dons> -cafe's reached a limit due to traffic size
15:08:30 <pumpkin> I just stuck a label on it in gmail, and it looks like a forum now, with all the threaded discussions
15:09:04 <ehird> <BONUS> im not subscribed to haskell-cafe because i still don't get mailing lists <- what's to get?
15:09:18 <BONUS> dunno, they always seemed kind of strange to me :]
15:09:26 <dons> like the web in slow motion
15:09:29 <BONUS> getting all those mails in my inbox, seems scary
15:09:39 <ehird> BONUS: folders you silly.
15:09:45 <Adamant> BONUS: I had family over in Britain during the height of the pound and euro's strength vs. the dollar. no whining ;)
15:09:48 <BONUS> yeah but still just the thought
15:09:57 <EvilTerran> "skip inbox" filters
15:09:58 <BONUS> haha
15:10:03 <pumpkin> EvilTerran: yeah
15:10:42 * pumpkin tries to decide if it's worth the 10-minute walk to the library in the below-freezing weather to get the books now
15:10:50 <ddarius> pumpkin: Yes.
15:10:57 <BONUS> we should have an 8-ball in here
15:11:08 <ddarius> @dice 1d2
15:11:08 <lambdabot> 1d2 => 1
15:11:15 <pumpkin> ddarius: maybe the books will warm up my soul on the way back
15:11:18 <pumpkin> lol
15:11:27 <pumpkin> I guess that's a yes
15:11:29 <BONUS> books = good
15:11:36 <ddarius> pumpkin: It will give you something to do the rest of the time you're not going out due to the below-freezing weather.
15:11:41 <vixey> books = books
15:11:46 <pumpkin> true :)
15:13:33 <hugo___1> is there a way to install ghc 6.10.1 without destroying my current 6.8.2 config ?
15:13:38 <hugo___1> in linux
15:13:51 <Heffalump> install the binary tarball in a separate directory
15:14:06 <Heffalump> the configs live inside the ghc tree, so will be indepdendent
15:14:35 <hugo___> Heffalump: yes, but when i do a runhaskell Setup.lhs configure, how will it know which ghc dir to install into ?
15:14:40 <hugo___> can i specify it ?
15:14:47 <Heffalump> change your PATH first
15:15:01 <Heffalump> there are flags you can pass instead but changing your path is much less hassle IME
15:15:08 <hugo___> okey
15:15:18 <hugo___> ill do a simple script so i can easily shift configs
15:15:24 <hugo___> thanks
15:15:30 <hugo___> nice thing ghc does it
15:15:40 <EvilTerran> @@ @run words "sleep eat haskell idle" !! (pred.read.last.words$(@show @dice 1d4))
15:15:41 <lambdabot>   "haskell"
15:16:03 <EvilTerran> BONUS, lambdabot can make decisions for you that way :)
15:16:18 <BONUS> hahaha nice
15:17:07 <ehird> @@ @run words "sleep eat haskell idle" !! (pred.read.last.words$(@show @dice 1d4))
15:17:09 <lambdabot>   "eat"
15:17:10 <vixey> @w80 polarize
15:17:21 <lambdabot> *** "polarize" wn "WordNet (r) 2.0"
15:17:21 <lambdabot> polarize
15:17:21 <lambdabot>      v 1: cause to vibrate in a definite pattern; "polarize light
15:17:21 <lambdabot>           waves" [syn: {polarise}]
15:17:21 <lambdabot>      2: cause to concentrate about two conflicting or contrasting
15:17:23 <lambdabot> [3 @more lines]
15:17:36 <EvilTerran> @@ (@show @dice 1d4); (@show @dice 1d4); (@show @dice 1d4); (@show @dice 1d4)
15:17:36 <lambdabot>  "1d4 => 4"; "1d4 => 4"; "1d4 => 1"; "1d4 => 2"
15:20:52 <amaron_> BONUS: thanks for the link, it's very interesting
15:21:10 <BONUS> :]
15:22:56 <idnar> @dice 3d8
15:22:57 <lambdabot> 3d8 => 12
15:24:23 <Holle_> my function: "changeColor :: (Int,Int) -> [[Point]] -> Window -> IO ()" what should i write, if i want to do nothing in else case?
15:24:46 <mux> use the when function
15:24:48 <mux> :t when
15:24:49 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
15:25:12 <ddarius> @src when
15:25:12 <lambdabot> when p s = if p then s else return ()
15:26:08 <Holle_> isn't "return ()" engough?
15:27:16 <sjanssen> Holle_: yes, you could leave return () in an else or case clause
15:27:36 <sjanssen> Holle_: 'when' is just a function that abstracts that pattern
15:28:02 <chessguy> @src State
15:28:03 <lambdabot> Source not found.
15:28:06 <sjanssen> 'if p then doStuff else return ()' can instead be written 'when p doStuff'
15:28:14 <sjanssen> @unmtl State s a
15:28:14 <lambdabot> s -> (a, s)
15:28:22 <chessguy> i'm trying to remember, where can i find the source for the State instance of monad?
15:28:37 <sjanssen> @source Control.Monad.State
15:28:37 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
15:28:52 <pumpkin> oh that's handy
15:28:56 <pumpkin> I didn't know about @source
15:29:01 <chessguy> that doesn't have it though
15:29:12 <sjanssen> chessguy: it is in one of the imported modules
15:29:17 <sjanssen> Control.Monad.State.Lazy, probably
15:29:19 <pumpkin> @source Control.Monad.State.Lazy
15:29:19 <lambdabot> Control.Monad.State.Lazy not available
15:29:34 <sjanssen>  @source is not very smart
15:29:36 <pumpkin> http://darcs.haskell.org/packages/mtl/Control/Monad/State/Lazy.hs
15:29:51 <chessguy> oh there we go
15:30:06 <chessguy> thanks
15:31:01 <EvilTerran> @@ @@ (@where decide) words "sleep eat haskell idle"
15:31:02 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
15:31:04 <EvilTerran> hm
15:31:11 <EvilTerran> it works in pm =/
15:31:21 <EvilTerran> darn truncation
15:31:30 <EvilTerran> @where decide
15:31:31 <lambdabot>  @run {- usage: "@@ @@ (@where decide) <list>" -} @@ @read @run show opts ++ " !! (pred.read.last.words) (@show @dice 1d" ++ show (length opts) ++ ")" where opts =
15:31:33 <oklopol> read that as "sleep eat haskell die"
15:31:41 <oklopol> i was like "wow, what a gambler!"
15:32:21 <EvilTerran> yay for weird hacks :D
15:33:59 <matthewp> Had a question on an exercise in Real World Haskell Chapter 15 in regards to writing a QuickCheck for SafeHello
15:34:01 <matthewp> anyone do that one?
15:34:16 <vixey> SafeHello LOL
15:34:30 <ddarius> unsafeHelloWorld
15:34:34 <matthewp> yeah, pretty funny name
15:37:12 <Saya> how would you make an unsafe hello? :o
15:37:27 <matthewp> unsafePerformIO?
15:37:40 <matthewp> unsafePerformHelloWorld
15:37:49 <pumpkin> lol
15:37:49 <chessguy> @source Data.List
15:37:50 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
15:38:03 <polveroj> unsafeViolatePrimeDirective -- unsafe hello
15:38:04 <EvilTerran> unsafeHelloProfessorFaulknerWouldYouLikeToPlayAGame
15:39:25 <EvilTerran> *Falken
15:39:30 <chessguy> @source Control.Monad.List
15:39:31 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/List.hs
15:41:34 <matthewp> I was looking at these in particular: http://book.realworldhaskell.org/read/programming-with-monads.html#id649843
15:42:11 <rwbarton> Saya: this seems like a pretty unsafe way to do it: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=712
15:44:07 <EvilTerran> rwbarton, :O
15:46:39 <Saya> indeed :)
15:46:40 <dublpaws> I'm considering apt-get purging all of ghc stuff and installing 6.10 from the .bz - but I'm afraid that doing so will stomp the life out of all that is good.
15:47:26 <Saya> is that list machine code? :p
15:47:32 <kmeyer> Saya: yes
15:47:47 <ddarius> dublpaws: You can have multiple GHC installs side-by-side with no problem.
15:48:00 <dolio> I tried that a while back, and it left my system in a state where apt could no longer do anything.
15:48:01 * dublpaws squints in disbelief
15:48:07 <Saya> might aswell use brainfuck
15:48:14 <kmeyer> dublpaws: does sid have a newer ghc?
15:48:22 <dolio> Because one of the haskell packages depending on something that could no longer be installed, and couldn't be removed either.
15:48:31 <dolio> But, hey, things might go better for you. :)
15:48:41 <dublpaws> I'm using ubuntu, not sure about the debian side of life.
15:49:33 <dolio> Just installing the .bz into /usr/local should work, without uninstalling the version from apt.
15:50:04 <dolio> If you want to be safe.
15:50:25 <dublpaws> ok, I'll give it a whirl, thanks :)
15:51:38 <Peaker> conal: ping
15:54:44 <conal> Peaker: hi
15:55:11 <Peaker> conal: hey.. I was wondering if exposing Reactive separately to Behavior after all was worth it for a Monad instance.. Reactive does have one, right?
15:56:14 <Peaker> conal: I thought about (compiler <*> sourceCode) and the realization that "everything" is a changing value, and I think a necessary by-product of that is that things are going to need monadic combinations, rather than just applicative ones
15:56:15 <conal> Peaker: yes, i think it does.  checking
15:56:50 <conal> Peaker: maybe so.  any monadic, non-applicative examples in mind?
15:57:54 <conal> Peaker: maybe the answer is: wherever Monad is useful.
15:59:24 <Peaker> conal: well, perhaps I want to compile and evaluate an expression which will result in a Behavior.  If the source of this compilation is itself a Behavior, fmap will get me B (B a)
16:00:04 <Peaker> conal: basically where ever I have a computation which results in behaviors/events, rather than simple/pure values
16:00:18 <conal> Peaker: yeah.
16:01:52 <Peaker> if someone does want to join Behaviors, he can first sample/crop them into a Reactive
16:03:08 <rictic> I'm seeing an unexpected Stack Space Overflow on a program that, to my intuition, should take constant space
16:03:51 <rictic> The program is similar to this one: main = print $ (iterate (+1) 1) !! 1000000 -- only there's a more complicated function substituted for (+1), but that seems to be unrelated
16:04:33 <Lemmih> rictic: iterate is quite lazy.
16:04:37 <dolio> iterate (+1) builds a bunch of thunks.
16:04:49 <Lemmih> rictic: You end up with (1+1+1+1+...).
16:05:05 <rictic> But aren't they quickly garbage collected?
16:05:11 <thoughtpolice> no
16:05:16 <thoughtpolice> every value depends on its previous value
16:05:18 <dolio> So when you get the 1,000,000th one, you have one million nested unevaluated functions to reduce.
16:05:24 <thoughtpolice> so the GC can't collect them all as it goes by
16:05:29 <dolio> And with + you need to get all the way to the bottom.
16:05:53 <rictic> Ah, I think I see.  So I need a strictness annotation somewhere
16:07:40 <dolio> Yes, but it needs to be in iterate or (!!).
16:08:40 <sjanssen> rictic: I'd use strictify in this case:
16:08:53 <sjanssen> strictify = foldr (\x xs -> x `seq` (x:xs)) []
16:09:38 <sjanssen> main = print $ (strictify $ iterate (+1) 1) !! 1000000
16:09:53 <rictic> sjanssen: Neat, that worked
16:10:11 <rictic> Thanks for the help everyone, much appreciated
16:11:03 * blackdog gets a perverse enjoyment from "> main =  peek (nullPtr :: Ptr Int)
16:11:05 <blackdog> "
16:11:50 <harovali> hi, i don't quite "get it" about functional dependencies
16:12:19 <dolio> > foldl' (flip id) 1 $ replicate 1000000 (+1)
16:12:21 <lambdabot>   1000001
16:23:12 <Botje> harovali: do you know something about databases?
16:26:29 <Botje> uh oh
16:26:32 <Botje> di I scare him?
16:27:00 <dolio> What?
16:27:08 <lispy> > peek (nullPtr :: Ptr Int)
16:27:09 <lambdabot>   Not in scope: `peek'Not in scope: `nullPtr'Not in scope: type constructor o...
16:29:50 <lispy> ?tell gwern Dear Gwern, the one line error messages are a bit better, but why do they run together?  Shouldn't there be a space where the newline once was?  Something like (intercalate " " . lines) instead of (filter (not . isSpace)).  Sincerely, lispy.
16:29:51 <lambdabot> Consider it noted.
16:32:19 <harovali> Botje: yes, in the db context i get it
16:32:32 <sjanssen> lispy: unwords . lines
16:33:05 <ddarius> harovali: They are the same thing.
16:34:01 <Peaker> if you've got a thing that is only referred to by another thing, then that other thing can be accounted as "containing" that thing. If something contains a lot of things (like a recursive thunk), it can be forced as a GC strategy to free it?
16:34:47 <ddarius> Peaker: I'm not quite sure what your question is.  If you are asking if forcing something can lead to freeing resources, then yes.
16:35:26 <ddarius> If you are asking if the GC could force things as it marks them, then ideas like that have been brought up a few times before.
16:35:27 <Peaker> ddarius: I'm asking if it could possibly be implemented in the GC -- A) identify which thunks are space eaters  B) force them to make them eat less space
16:35:47 <sjanssen> additionally, forcing a thunk can actually cause more resources to be required
16:35:55 <ddarius> Peaker: It's not always clear that that will -reduce- space.
16:35:59 <Peaker> sjanssen: if that's the case, then "undo" the forcing :-)
16:36:13 <Peaker> ddarius: if the post-force is bigger, just unforce it
16:36:40 <lispy> sjanssen: oh, neat, I didn't think of that
16:36:42 <ddarius> Peaker: That could lead to asymptotic changes in time usage (and of course higher peak memory usage)
16:36:42 <Peaker> if it takes too long and it might be bottom, also cancel
16:36:43 <sjanssen> Peaker: but what if you'll only get a net space reduction if you force the newly created thunks?
16:37:23 <Peaker> sjanssen: that kind of cleverness would only work if there's some kind of runtime profiling or programmer annotations
16:37:31 <lispy> ?tell gwern P.S. <sjanssen> lispy: unwords . lines
16:37:32 <lambdabot> Consider it noted.
16:37:38 <Peaker> sjanssen: I think a first-order try-thunks-and-fail might be an improvement
16:37:44 <lispy> ?tell gwern P.S. <sjanssen> lispy: unwords . lines
16:37:44 <lambdabot> Consider it noted.
16:37:51 <lispy> oops
16:37:59 <sjanssen> Peaker: I bet in most cases it will just eat much more CPU
16:38:01 <ddarius> You're going to piss gwern off
16:38:03 <Peaker> sjanssen: of course arbitrary thresholds can be defined - for how deep to try to force thunks before giving up
16:38:55 <Peaker> sjanssen: well, it might eat more CPU to release memory.. I think I wait for swap ins much more frequently than I wait for my CPU :)
16:39:01 <roconnor> What's the diff between syncronous vs asyncronous exceptions in GHC?
16:39:16 <sjanssen> Peaker: I mean eat CPU without significant reductions in memory use
16:39:52 <ddarius> If it doesn't actually commit to the change, it will eat CPU -with- significant -increases- in memory use.
16:39:59 <sjanssen> roconnor: synchronous exceptions are raised by operations called in the thread, asynchronous operations may come at any time
16:40:04 <Peaker> sjanssen: it might make it possible to be less knowledgeable about strictness and still write valid programs.. In those cases, (e.g big lazy fold, or iterate as above) it would "Just work"
16:40:27 <ddarius> Peaker: Writing code that relies on magic is a bad idea.
16:40:29 <Peaker> ddarius: it can only temporarily increase memory use, it can always just dump its attempts and release the memory
16:40:37 <roconnor> sjanssen: I guess that makes sense
16:40:56 <roconnor> sjanssen: what would be a typical example of an asynchronous exception?
16:41:04 <ddarius> Peaker: Temporary memory use is still a problem.
16:41:10 <Peaker> ddarius: unless the magic is well understood and commonly implemented (e.g naming implying sharing)
16:41:30 <sjanssen> roconnor: killThread raises any async exception in the killed thread
16:41:34 <sjanssen> s/any/an
16:41:40 <ddarius> Peaker: This is something that is inherently ad-hoc.
16:41:43 <roconnor> right
16:42:00 <sjanssen> roconnor: that's the only async exception that I have experience with
16:42:03 <ddarius> Peaker: And likely highly fragile.
16:42:21 <Peaker> ddarius: if heuristics don't solve the problem, throw more heuristics at it :-)
16:42:45 <ddarius> Peaker: "If it's hard to understand what it will do, let's make it harder to understand and more ad-hoc."
16:43:06 <mmorrow> data AsyncException
16:43:06 <mmorrow>   = StackOverflow | HeapOverflow | ThreadKilled | UserInterrupt
16:43:17 <Peaker> I believe (and hope) that we can replace the programmer's ad-hoc/heuristic strictness annotations/use of strict functions with a smarter RTS that does more heuristics
16:43:36 <jonaskoelker> "monad stack 101" still needed :( -- please see http://hpaste.org/13796 -- Which type can I give the function i?
16:43:54 <Toxaris_> Peaker: why do the heuristics in the RTS and not as static analyses / optimizations?
16:43:56 <ddarius> Peaker: You can't.  Programmers aren't bound to maintain semantics.  Also, programmers know what they intend (at least better than compilers/RTSes know)
16:43:57 <mmorrow> i'd rather have an rts with no heuristics myself :)
16:44:00 <sjanssen> mmorrow: but any sort of exception can be thrown with throwTo
16:44:10 <jonaskoelker> see also http://hpaste.org/13797 for an error message
16:44:22 <sjanssen> mmorrow: yeah, dynamic (RTS) magic seems more scary than static (compiler) magic
16:44:32 <Peaker> Toxaris_: I think not all of the useful strictness analysis can be done based on just compile-time data
16:44:41 <roconnor> jonaskoelker: better to annotate the paste than make a new one.
16:44:50 <roconnor> jonaskoelker: next time
16:44:52 <roconnor> :)
16:44:54 * ddarius doesn't recommend relying on strictness analysis either for anything other than constant factor differences.
16:44:56 <jonaskoelker> roconnor: I'll keep that in mind
16:44:59 <jonaskoelker> yeah, next time :)
16:45:00 <mmorrow> sjanssen: totally
16:45:05 <Peaker> ddarius: I agree with the former, but not the latter.. If the latter is true, then fix the DSL/library so that the code does match intention
16:46:26 <ddarius> Peaker: There can be no situation where the compiler knows what you intend better than you do.
16:46:28 <Peaker> ddarius: I agree that its not a good idea to rely on experimental optimizations for your code to run at all.  I am hoping it is possible for a set of optimizations be "standardized" so that everyone can rely on them, and for typical newbie lazy programs will work
16:46:48 <Ralith> My just-built ghci isn't correctly handling input like arrow keys, EOF, backspace, etc.  Any tips?
16:47:06 <Peaker> ddarius: and perhaps, a good set of heuristics can solve the problem well enough (with some constant factor hit, surely) that we never have to think about it again..
16:47:17 <jonaskoelker> no help with my monad stack? :|
16:47:37 <Peaker> @hoogle getRandomR
16:47:37 <lambdabot> No results found
16:47:45 <Peaker> jonaskoelker: what's getRandomR?
16:48:02 <jonaskoelker> Peaker: randomR, but in the Random monad
16:48:09 <ddarius> Peaker: I don't see any point in that.  Strictness analysis is fragile.  It would be much harder to rely on an intricate interplay of various optimization rather than just stating my intent that I want a certain argument strictly evaluated.
16:48:40 <Peaker> ddarius: is it always clear what should be strictly evaluated?
16:49:03 <Ralith> in fact, ghci's refusal to properly process backspace is really, really annoying :/
16:49:11 <jonaskoelker> Peaker: http://www.haskell.org/haskellwiki/New_monads/MonadRandom
16:49:19 <Peaker> ddarius: worse yet, do you duplicate each piece of code for strictness on each possible argument, or worse, for each strictness variant of its called functions?
16:49:29 <ddarius> Peaker: No, but having random "standardized" "optimizations" would not help that any.
16:49:42 <Peaker> jonaskoelker: why is your commented type bad?
16:49:59 <jonaskoelker> Peaker: see hpaste 13797
16:50:13 <Peaker> jonaskoelker: yeah, you just need some lifting to do
16:50:37 <Toxaris_> jonaskoelker: you need instance (MonadRandom m, Error e) => MonadRandom (ErrorT e m) where ...
16:50:41 <ddarius> Peaker: In my experience, I've never needed a function with different strictnesses at different times.
16:50:45 <Peaker> jonaskoelker: lift once to access ReaderT, lift twice to access RandT
16:50:55 <Toxaris_> jonaskoelker: similar to the instances on the wiki page you pointed to
16:51:01 <Peaker> ddarius: surely you've needed both foldl' and foldl/foldr?
16:51:12 <sjanssen> Peaker: foldl is never needed
16:51:23 <ddarius> foldl' and foldr are totally different functions, not variants with different strictness.
16:51:39 <sjanssen> Peaker: and the difference between foldr and foldl is not at all strictness
16:51:40 <ddarius> Peaker: They also illustrate the fact that different strictnesses usually imply a totally different approach.
16:51:46 <ddarius> And no, I don't need foldl.
16:51:47 <Peaker> Toxaris_: I really hate these instances :-(  I think its better to just newtype your monad transformer combination, and define lifters for each layer
16:52:10 <Peaker> sjanssen: I know, I said foldl/foldr because foldl is kind of useless, so foldl' vs. foldr :-)
16:52:50 <sjanssen> Peaker: and you never need a strict foldr, it just doesn't make sense
16:53:01 <Toxaris_> Peaker: I don't understand. With the additional instance, jonaskoelker could write newtype MyMonad a = MyMonad (StateT ...) deriving (MonadRand, MonadError e, ...)
16:53:16 <Peaker> sjanssen: you need a strict fold, though
16:53:35 <sjanssen> Peaker: correction, you need a tail recursive fold
16:53:43 <Peaker> Toxaris_: yeah, but you need O(N*N) instances, where N=number of monad types, and then someone ought to know all possible pairs too
16:54:08 <sjanssen> (it only so happens that strictness is necessary tail recursion and an accumulator)
16:54:38 <Peaker> Toxaris_: I prefer just using:  env <- liftEnv ask    over jumping through all these hoops just so it is: env <- ask.  This also allows me to mix in a bunch of ReaderT's
16:55:06 <Peaker> Toxaris_: instance MonadRandom will catch the first one, which is kind of ad-hoc/arbitrary. It makes sense for IO (of which there can only be one), though
16:55:48 <Ralith> It looks like ghci is taking all characters as as text input for some reason
16:56:04 <Toxaris_> Peaker: but then you loose polymorphism, since your functions have to use concrete monad types, i.e. you cannot later change your monad transformer stack
16:56:25 <Peaker> Toxaris_: you can, because you defined lifters to abstract away the stack's form
16:57:19 <Toxaris_> Peaker: "abstract away" as in "only one place in the code", but not as in "polymorphism"
16:57:45 <Peaker> for example:   newtype MyStackT m a = ReaderT (RandomT (ReaderT (m a))) ; liftGUIState = id ; liftMainRandomGen = lift ; liftModelState = lift . lift ; instance MonadTrans MyStackT where lift = lift . lift . lift
16:58:11 <Ralith> ah, I see, I need to rebuild with libedit
16:58:17 <Peaker> Toxaris_: I don't think that code that uses primitives from a bunch of different monad types can benefit from being generic to any monad stack
16:58:43 <Peaker> Toxaris_: Especially as I don't think "ask", for example, is a very meaningful operation without a particular monad stack in mind
16:58:54 <Peaker> Toxaris_: And then (liftToSpecificEnvYouWant ask) makes more sense
16:59:18 <Toxaris_> Peaker: yeah for multiple instances of the same transformer, that makes a lot of sense
17:00:11 <jonaskoelker> Peaker, Toxaris_: yay, it w0rx.  Thanks for your time & attn. :)
17:00:31 <rwbarton> Wouldn't a MonadReader class without a functional dependency work well in that situation?  (multiple ReaderTs)
17:00:43 <Peaker> jonaskoelker: did you use the extra instances, or lifts?
17:00:48 <Toxaris_> Peaker: I misunderstood your approach at first. newtyping the monad *transformer* is clever (not the monad) sounds clever.
17:00:54 <jonaskoelker> Peaker: just a single lift, on getRandomR
17:01:02 <mmorrow> @djinn-env
17:01:02 <lambdabot> data () = ()
17:01:03 <lambdabot> data Either a b = Left a | Right b
17:01:04 <lambdabot> data Maybe a = Nothing | Just a
17:01:06 <lambdabot> data Bool = False | True
17:01:10 <lambdabot> data Void
17:01:14 <lambdabot> type Not x = x -> Void
17:01:18 <lambdabot> Plugin `djinn' failed with: thread killed
17:01:20 <Peaker> Toxaris_: I think EvilTerran pointed that approach out to me long ago
17:01:32 <mmorrow> @djinn-add data Cont r a = Cont ((a -> r) -> r)
17:01:33 <jonaskoelker> -- and I'll probably wrap that in a function for the `real deal', since I always want 1..n
17:01:42 <Peaker> Toxaris_: All the newtype unpacking to get those above lifts going is a bit annoying, but it concentrates all of the annoyance to one place: The definition of the stack
17:01:48 <Toxaris_> rwbarton: I don't think you could write the generic MonadReader instance then. Or can you select instances depending on type equality nowadays?
17:01:57 <baaba> what does the Not type do exactly?
17:02:00 <baaba> i don't get it
17:02:08 <mmorrow> @djinn Cont r a -> (a -> Cont r b) -> Cont r b
17:02:08 <lambdabot> f a b =
17:02:08 <lambdabot>     case a of
17:02:08 <lambdabot>     Cont c -> Cont (\ d ->
17:02:08 <lambdabot>                     c (\ e ->
17:02:08 <lambdabot>                        case b e of
17:02:10 <lambdabot>                        Cont f -> f d))
17:02:34 <mmorrow> djinn can derive a bunch of (>>=) defs automatically
17:03:01 <rwbarton> Of course, you generally have no assurance that it's chosen a reasonable one
17:03:27 <mmorrow> rwbarton: yeah, i wonder what guarantees/assumptions one could make
17:03:51 <redditbot> Liskell standalone
17:03:58 <rwbarton> Toxaris_: What's wrong with just removing the functional dependency and adding type annotations at the call point?  (I haven't tried this, maybe it really doesn't work how I imagine)
17:04:12 <baaba> optionally disable things like const, join?
17:04:26 <baaba> i have no idea how @djinn works, does it come up with a set of potential answers?
17:04:55 <rwbarton> baaba: I looked into it briefly and determined that it was Complicated. :)
17:04:59 <baaba> heh
17:05:30 <mmorrow> i've been thinking about this in terms of "oldtype/@unmtl + djinn-logic/TH-code" to flatten a monad stack type, then derive instance Functor + Monad + any (appropriate) helper functions (e.g. ask, get, callCC, ..) you request
17:05:38 <dons> $wfold :: Int# -> Double# -> Double# -> Int# -> (# Int#, Double#, Double# #)
17:05:40 <dons> pumpkin: :)
17:05:42 <mmorrow> djinn gets callCC for Cont correct
17:05:58 <dons> i love stream fusion
17:06:00 <mmorrow> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
17:06:00 <lambdabot> f a =
17:06:00 <lambdabot>     Cont (\ b ->
17:06:00 <lambdabot>           case a (\ c -> Cont (\ _ -> b c)) of
17:06:00 <lambdabot>           Cont d -> d b)
17:06:23 <baaba> @djinn a -> (a -> a) -> a
17:06:23 <lambdabot> f a b = b a
17:06:38 <baaba> interesting, i expected f a _ = a
17:06:44 <rwbarton> baaba: yeah, that's an interesting example
17:06:48 <mmorrow> hmm
17:07:00 <Toxaris_> rwbarton: so you have (1) instance MonadReader r (ReaderT r m) where ...; (2) instance MonadReader r m => MonadReader r (ReaderT s m) where ...; Now which instance should be chosen for ask :: ReaderT Int (ReaderT Int Identity) Int?
17:07:02 <rwbarton> baaba: I believe Djinn has some heuristic that makes it try to use all its arguments
17:07:11 <baaba> ah
17:07:36 <rwbarton> Toxaris_: Oh, it won't work with two ReaderTs of the same type, no
17:07:56 <rwbarton> Toxaris_: Hmm, are you saying that that means it actually will never work, because of the way instance selection happens...
17:08:05 <mmorrow> $(flattenM [t| forall r w s a. ReaderT r (WriterT w (State s)) a|])
17:08:12 <Toxaris_> rwbarton: yes I am. of course, I may be wrong.
17:08:17 <rwbarton> Toxaris_: OK, thanks :)  I believe it.
17:08:22 * EvilTerran thinks Toxaris_ is right
17:08:29 * rwbarton too
17:08:34 <pumpkin> dons: :o
17:08:42 <EvilTerran> you could use a ReaderT (Int,Int), though
17:08:42 <pumpkin> dons: you made it better?
17:08:49 <dons> nah, it was already fine.
17:08:51 <pumpkin> ooh
17:08:57 <dons> just checking the assembly it produced.
17:08:58 <Toxaris_> I think a possible solution would be to label the readers at the type level
17:08:59 <pumpkin> I tried to model it as much as possible on your other functions :)
17:09:01 <dons> yeah.
17:09:03 <dons> looks good.
17:09:09 <pumpkin> yay
17:09:14 <dons> pushed and uploaded.
17:09:17 <EvilTerran> Toxaris_, yeah, that'd work too. tupling the readers is the quick-n-dirty solution.
17:09:20 <mmorrow> , ppDoc' $(lift . fst =<< oldtype =<< [t|forall r w s a. ReaderT r (WriterT w (State s)) a|])
17:09:24 <lunabot>  forall r w s a . r -> s -> (,) ((,) a w) s
17:10:12 <pumpkin> dons: thanks a lot :) exciting!
17:11:21 <pumpkin> so my library had TAPL but their copy of awodey's category theory was gone! it was supposed to be in, but it wasn't on the shelf :(
17:13:42 <mmorrow> , let ForallT ns _ t = $(lift . fst =<< oldtype =<< [t|forall r w s a. ReaderT r (WriterT w (State s)) a|]) in NewtypeD [] (mkName "RWS") ns (NormalC (mkName "RWS") [(NotStrict, t)]) []
17:13:46 <lunabot>  NewtypeD [] RWS [r_1627418523,w_1627418524,s_1627418525,a_1627418526] (No...
17:13:52 <mmorrow> , ppDoc (let ForallT ns _ t = $(lift . fst =<< oldtype =<< [t|forall r w s a. ReaderT r (WriterT w (State s)) a|]) in NewtypeD [] (mkName "RWS") ns (NormalC (mkName "RWS") [(NotStrict, t)]) [])
17:13:56 <Toxaris_> EvilTerran: maybe using MonadReader with r an HList which contains the needed fields
17:13:56 <lunabot>  newtype RWS r_0 w_1 s_2 a_3 = RWS (r_0 ->
17:13:56 <lunabot>                                     s_2 -> (,) ((,) a_3 w_1) s_2)
17:14:16 <mmorrow> , ppDoc' (let ForallT ns _ t = $(lift . fst =<< oldtype =<< [t|forall r w s a. ReaderT r (WriterT w (State s)) a|]) in NewtypeD [] (mkName "RWS") ns (NormalC (mkName "RWS") [(NotStrict, t)]) [])
17:14:20 <lunabot>  newtype RWS r w s a = RWS (r -> s -> (,) ((,) a w) s)
17:14:37 <Toxaris_> EvilTerran: as a combination of the two approaches
17:20:33 <mmorrow> heh, oops
17:21:18 <Guenni> hi mmorrow
17:21:33 <mmorrow> Guenni: hi
17:21:49 <Guenni> mmorrow: can you tell me what this means: http://hpaste.org/13798?lines=true?
17:21:54 <mmorrow> , let mkVec n = let name = mkName ("Vec"++show n) in ppDoc' (DataD [] name [] [NormalC name (zip (repeat IsStrict) (replicate n (unQ[t|Int|])))] []) in vcat . fmap mkVec $ [2..4]
17:21:57 <lunabot>  data Vec2 = Vec2 !Int !Int
17:21:57 <lunabot>  data Vec3 = Vec3 !Int !Int !Int
17:21:57 <lunabot>  data Vec4 = Vec4 !Int !Int !Int !Int
17:22:03 * mmorrow looks
17:22:21 <pumpkin> Guenni: "what it means"?
17:22:40 <pumpkin> it means you have a type with a strict pointer to a regex and a pointer to a bytestring :P
17:22:42 <Guenni> yes, I don't know the notation, the exclamation marks confuse me
17:22:43 <mmorrow> ah, the "!"s are to make those values strict
17:23:04 <mmorrow> so they'll always only be one level deep thunkwise
17:24:23 <mmorrow> , let mkVec n = let name = mkName ("Vec"++show n) in ppDoc' (DataD [] name [] [NormalC name (zip (repeat IsStrict) (replicate n (unQ[t|Int|])))] []) in mkVec 128
17:24:23 <Guenni> mmorrow: do you know where I could get more information on that, cause it's still chinese to me
17:24:40 <mmorrow> Guenni: the ghc manual is probably your best bet
17:24:52 <Guenni> this is ghc specific?
17:24:55 <pumpkin> Guenni: basically, it hinders laziness
17:25:01 * mmorrow made the mistake of printing mkVec 128 out in a /msg..
17:25:06 <lunabot>  data Vec128 = Vec128 !Int
17:25:08 <lunabot>                       !Int
17:25:10 <lunabot>                       !Int
17:25:19 <Guenni> pumpkin: thx
17:25:24 <pumpkin> mmorrow: will that be 128 !Ints ?
17:25:30 <mmorrow> oh yesh
17:25:33 <pumpkin> or 32/16 of them?
17:25:50 <mmorrow> 128 ints
17:25:55 <pumpkin> ah
17:26:08 <byorgey_> !Int
17:26:12 <Guenni> this examples pops up in rwh in the ffi part
17:26:12 * byorgey_ decides to help out
17:26:52 <mmorrow> Guenni: i don't think ghc is the only compiler to support that, but i'm not sure if it's haskell98 or not
17:27:38 <Guenni> the "!" is only valid for data declarations or used in General to force strictness?
17:27:49 <mmorrow> you can also attach "deriving .." to data/newtype decls
17:27:50 <mmorrow> , let mkVec n = let name = mkName ("Vec"++show n) in ppDoc' (DataD [] name [] [NormalC name (zip (repeat IsStrict) (replicate n (unQ[t|Int|])))] [''Eq,''Ord,''Read,''Show]) in mkVec 4
17:27:53 <lunabot>  data Vec4 = Vec4 !Int !Int !Int !Int
17:27:53 <lunabot>      deriving (Eq, Ord, Read, Show)
17:28:34 <mmorrow> Guenni: it's a case of the same symbol being used in two separate contexts for essentially the same purpose
17:28:35 <Guenni> mmorrow: thx
17:30:00 <Guenni> mmorrow: is your target plattform for your haskell apps unix or windows?
17:30:14 <mmorrow> unix
17:30:44 <Guenni> mmorrow: I guess that's true for most people here ...
17:30:49 <Guenni> damn
17:30:53 <mmorrow> linux in particular, but the only linux-specific code i use regularly that i can think of is inotify
17:31:52 <Guenni> I'll have to "fix" some of the HDBC-ODBC stuff myself to get it working with MS-Access, me!
17:32:05 <pumpkin> > fix sql
17:32:06 <mmorrow> heh
17:32:06 <lambdabot>   Not in scope: `sql'
17:33:19 <Guenni> I contacted the HDBC developer if he can help me why hdbc blows up when I use it with Access, but he's never used it on Win32 :(
17:33:44 <mmorrow> yeah, i have exactly zero experience running haskell code on windows
17:34:24 <Guenni> mmorrow: wish me luck
17:35:06 <mmorrow> good luck!
17:40:37 <kmeyer> where is Ix defined?
17:41:10 <Peaker> @index Ix
17:41:10 <lambdabot> Data.Ix, Data.Array, Data.Array.IArray, Data.Array.Unboxed, Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable, Data.Array.Diff
17:41:15 <Peaker> @hoogle Ix
17:41:15 <lambdabot> module Data.Ix
17:41:15 <lambdabot> Data.Ix class Ord a => Ix a
17:41:15 <lambdabot> Data.Array.Base ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
17:48:13 <jberryman> what would be an application for a tree that looked like: Tree a = Leaf a | Branch (Tree a) (Tree a)   ?
17:48:14 <harovali> how do I have to read the where part in a type class definition?
17:50:54 <SamB> jberryman: you know, I think it's more usual to start with the application and then figure out the tree for it ...
17:50:55 <roconnor> jberryman: an intermediate data structure for merge-sort
17:51:19 <harovali> > class And b1 b2 b | b1 b2 -> b where >   and :: b1 -> b2 -> b
17:51:20 <lambdabot>   <no location info>: parse error on input `class'
17:51:54 <Saizan_> harovali: where introduces the block where the methods of the class are defined
17:51:57 <harovali> up to the "where" I seem to be able to read it, but then, I don't know what the chain of ->'s means
17:52:09 <harovali> Saizan_: aha!
17:52:11 <ski_> (SamB : well, i was thinking that looked like a good type for a tree monad ..)
17:52:20 <rwbarton> jberryman: Huffman decoding
17:52:50 <harovali> Saizan_: how does      and :: b1 -> b2 -> b      read like ?
17:53:11 <Saizan_> harovali: and is a function that takes a b1 and a b2 and returns a b
17:53:12 <harovali> and is suposed to take 2 args, right?
17:53:19 <rwbarton> ski_: Yeah, also a kind of "list" with constant-time concatenation
17:53:24 <ski_> `and' takes a parameter of type `b1', a paramater of type `b2', and yields a result of type `b'
17:54:05 <harovali> ski_: what I still don't get is the -> chain , because it doesn't seem to "group" b1 b2
17:54:33 <ski_> (rwbarton : yeah .. if `Branch' were associative)
17:55:06 <jberryman> harovali: that's because what it's actually saying is: 'and is a function which takes a b1 and returns a function that takes a b2 and returns a type of b
17:55:33 <Saizan_> harovali: n-ary functions are actually 1-ary functions that returns (n-1)-ary ones
17:55:35 <rwbarton> ski_: (Well, I imagine it as a solution to the same problem that DList solves, namely building up a list by concatenating pieces)
17:55:40 <ski_>   and :: b1 -> (b2 -> b)
17:56:07 <harovali> like in currying ?
17:56:12 <jberryman> harovali: http://www.haskell.org/haskellwiki/Currying
17:56:17 <harovali> aha
17:56:20 <SamB> harovali: that IS currying
17:56:21 <Saizan_> yeah, that's it
17:56:52 <SamB> harovali: there IS a reason they named this language after Haskell Curry, you know
17:57:06 <harovali> SamB of course :)
17:57:13 <Saizan> really?
17:57:24 <SamB> Saizan: yeah. not sure what it is though.
17:58:04 <SamB> it's got to be a better reason than the reason for the Monomorphism Restriction ;-P
17:58:05 <ski_> SamB : istr it was the name suggestion that was left, after others had been removed
17:58:13 <ski_> (fsvo "istr")
17:58:28 <SamB> ski_: ah. so the name was finished.
17:59:05 <SamB> (I was joking that they named the language after him only to link it with currying ;-)
17:59:05 <ski_> (augustss probably know)
17:59:16 <ski_> (i know :)
17:59:31 <SamB> which would NOT be a bad reason
18:00:29 <harovali> what is Prelude?
18:00:45 <SamB> harovali: the music you hear when you start GHCi
18:01:05 <harovali> SamB ah
18:01:10 * SamB kids
18:01:22 <Saizan> the standard module that's automatically in scope
18:01:26 <SamB> actually, it's the library module that is implicitly imported
18:01:32 <ski_> a collection of generally useful operations and types that are per default loaded (unless you object)
18:01:40 <harovali> i see, thanks
18:01:58 <Saizan> though skimming a tutorial might be faster :)
18:02:06 <SamB> which is for some reason given a musical name
18:02:27 <SamB> also, you're doomed to spend a lot of time reimplementing things that are already in Prelude
18:02:46 <SamB> or in Data.List ...
18:03:26 <rwbarton> @wn prelude
18:03:32 <lambdabot> *** "prelude" wn "WordNet (r) 2.0"
18:03:32 <lambdabot> prelude
18:03:32 <lambdabot>      n 1: something that serves as a preceding event or introduces
18:03:32 <lambdabot>           what follows; "training is a necessary preliminary to
18:03:32 <lambdabot>           employment"; "drinks were the overture to dinner" [syn:
18:03:34 <lambdabot> [4 @more lines]
18:03:49 <SamB> @devil Prelude
18:03:49 <lambdabot> No match for "Prelude".
18:04:02 <ski_> @devil angel
18:04:03 <lambdabot> No match for "angel".
18:04:07 <ski_> @devil milestone
18:04:08 <lambdabot> No match for "milestone".
18:04:09 <SamB> @devil money
18:04:10 <lambdabot> *** "MONEY" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
18:04:10 <lambdabot> MONEY, n.  A blessing that is of no advantage to us excepting when we
18:04:10 <lambdabot> part with it.  An evidence of culture and a passport to polite
18:04:10 <lambdabot> society.  Supportable property.
18:04:10 <lambdabot>  
18:07:04 <Ralith> I'm having problems building ghc
18:07:04 <Ralith> /usr/home/ralith/src/ghc-6.10.1/ghc/stage2-inplace/ghc could not be
18:07:06 <Ralith> determined.
18:07:23 <Ralith> % ghc/stage2-inplace/ghc
18:07:23 <Ralith> /libexec/ld-elf.so.1: Undefined symbol "rl_line_buffer" referenced from COPY relocation in /usr/home/ralith/src/ghc-6.10.1/ghc/stage2-inplace/libexec/ghc
18:07:35 <Ralith> I've tried rebuilding from a clean extract of the tarball
18:07:37 <Ralith> how do I fix this?
18:09:46 <rwbarton> Looks editline-related..
18:10:10 <rwbarton> What OS?
18:11:01 <Ralith> FreeBSD
18:11:13 <Ralith> I just built editline, and it worked beforehand, so that's likely
18:11:25 <Ralith> that said, working ghci without editline sucks horribly.
18:12:04 <Ralith> does ghc need a particular version of libedit?
18:12:16 <Ralith> I've got 2.6.10
18:12:48 <rwbarton> I'm not sure.  I built mine against readline
18:12:57 <Ralith> you can do that on 6.10.1?
18:13:05 <rwbarton> Well, it's not officially supported
18:13:14 <Ralith> :/
18:13:20 <rwbarton> http://www.haskell.org/pipermail/glasgow-haskell-users/2009-January/016443.html
18:14:34 <rwbarton> I guess you could check whether your editline shared library provides a symbol 'rl_line_buffer'
18:14:49 <rwbarton> the editline haskell package certainly expects it to
18:15:49 <Ralith> been a while since I've had to do anything like that; how do I go about it?
18:16:52 <rwbarton> probably something like   nm -D /usr/lib/libeditline.so | grep rl_line_buffer
18:18:01 <Peaker> @djinn a -> a
18:18:02 <lambdabot> f a = a
18:18:16 <Peaker> @djinn Maybe a -> (a -> b) -> b
18:18:16 <lambdabot> -- f cannot be realized.
18:18:25 <Peaker> hmm.. djinn sucks :)
18:18:25 <Ralith> ahh, nm
18:18:45 <Ralith> rwbarton: wait a moment-- would it be trying to link to libeditline.so?
18:18:49 <Ralith> 'cuz it's libedit.so here
18:19:01 <Peaker> oh wait, I suck
18:19:01 <Ralith> also:
18:19:02 <Ralith> 0001a110 B rl_line_buffer
18:19:02 <Peaker> djinn was right
18:19:03 <rwbarton> libeditline.so was just a guess
18:19:05 <Peaker> @djinn Maybe a -> (a -> b) -> Maybe b
18:19:05 <lambdabot> f a b =
18:19:05 <lambdabot>     case a of
18:19:05 <lambdabot>     Nothing -> Nothing
18:19:05 <lambdabot>     Just c -> Just (b c)
18:19:11 <Ralith> symbol looks like it's there.
18:19:14 <rwbarton> Ralith: Yeah, it seems the symbol is there
18:21:05 <Ralith> no ideas, then?
18:22:13 <rwbarton> Ralith: Yeah... I mean you could try running ldd (if that exists on FreeBSD) on the ghc/stage2-inplace/ghc executable to see if something looks obviously wrong
18:22:33 <rwbarton> Ralith: but this could also be just leading down a rabbit hole...
18:22:38 <Ralith> bit late; already started rebuilding w/ readline
18:22:47 <rwbarton> Ah, that's probably the way to go anyways :)
18:22:52 <Peaker> @djinn Maybe a -> Maybe (a->b) -> Maybe b
18:22:52 <lambdabot> f a b =
18:22:52 <lambdabot>     case a of
18:22:52 <lambdabot>     Nothing -> Nothing
18:22:52 <lambdabot>     Just c -> case b of
18:22:52 <lambdabot>               Nothing -> Nothing
18:22:55 <lambdabot>               Just d -> Just (d c)
18:23:03 <rwbarton>  f a b = Nothing
18:23:07 <Peaker> ok, djinn is awesome :)
18:23:14 <Ralith> ldd: ghc/stage2-inplace/ghc: not a dynamic executable
18:23:19 <pumpkin> doesn't djinn know about >>=?
18:23:28 <rwbarton> ah, sorry, the /usr/home/ralith/src/ghc-6.10.1/ghc/stage2-inplace/libexec/ghc probably
18:23:29 <Peaker> pumpkin: djinn reinvents >>= at need :)
18:23:36 <pumpkin> :)
18:23:48 <rwbarton> @. pl djinn Maybe a -> Maybe (a->b) -> Maybe b
18:23:48 <lambdabot> (line 3, column 13):
18:23:48 <lambdabot> unexpected ">" or "-"
18:23:48 <lambdabot> expecting variable, "(", operator or end of input
18:24:00 <rwbarton> @pl f a b = Nothing
18:24:01 <lambdabot> f = const (const Nothing)
18:24:05 <pumpkin> @. pl djinn Maybe a -> Maybe (a->b) -> Maybe b
18:24:05 <lambdabot> (line 3, column 13):
18:24:05 <lambdabot> unexpected ">" or "-"
18:24:05 <lambdabot> expecting variable, "(", operator or end of input
18:24:09 <pumpkin> boo :(
18:24:18 <rwbarton> I guess it doesn't like case
18:24:20 <Ralith> rwbarton: discovery!
18:24:31 <pumpkin> rwbarton: or maybe the multiline output?
18:24:36 <rwbarton> @pl \a -> case a of Nothing -> Nothing ; Just x -> Just x
18:24:36 <lambdabot> (line 1, column 25):
18:24:36 <lambdabot> unexpected ">" or "-"
18:24:36 <lambdabot> expecting variable, "(", operator or end of input
18:24:41 <rwbarton> pumpkin: yes, possibly
18:24:44 <Ralith> rwbarton: it's linking to /lib/libedit.so.6 instead of /usr/local/lib/libedit.so
18:24:47 <rwbarton> pumpkin: the layout probably gets destroyed
18:24:50 <Peaker> well, how can it PL cases arbitrarily?
18:24:51 <rwbarton> Ralith: ah, that seems bad
18:25:08 <rwbarton> Peaker: It can't, but it could detect that the case are Nothing and Just _, I guess, and use maybe
18:25:09 <Ralith> rwbarton: indeed; they appear to be different libraries.
18:25:19 <Ralith> how would I tell it to use the /usr/local one?
18:25:35 <rwbarton> Ralith: Hmm... you could set LD_LIBRARY_PATH=/usr/local/lib
18:25:38 <Peaker> rwbarton: yeah, maybe @fold should do that though
18:25:43 <rwbarton> Ralith: That's probably not the "right" solution
18:25:45 <Peaker> rwbarton: so @. pl fold ...
18:25:59 <Ralith> rwbarton: nope :P
18:26:07 <rwbarton> Peaker: @fold would be like un-layout?
18:26:42 <Peaker> rwbarton: I mean @fold like @catamorphism -- convert cases to the appropriate fold calls, when folders are known
18:26:56 <Peaker> rwbarton: maybe: (TypeName.cata)  when the folder is not known
18:27:04 <rwbarton> Peaker: Oh, I see
18:27:13 <rwbarton> , src 'gcata
18:27:15 <lunabot>  luna: Not in scope: `gcata'
18:27:16 <Peaker> rwbarton: doesn't have to be part of the PL thing
18:27:25 <rwbarton> Peaker: right
18:27:26 <Peaker> cause it is possible as strictly a preprocessing
18:28:06 <Peaker> @djinn a -> Maybe (a, Maybe a)
18:28:06 <lambdabot> f a = Just (a, Nothing)
18:28:16 <Peaker> why does it choose Nothing for the (Maybe a)?
18:28:18 <rwbarton> @pl \a b -> maybe Nothing (\x -> maybe Nothing (Just . ($ x)) b) a
18:28:18 <lambdabot> flip (maybe Nothing . flip (maybe Nothing . (Just .) . flip id))
18:28:24 <rwbarton> :t \a b -> maybe Nothing (\x -> maybe Nothing (Just . ($ x)) b) a
18:28:25 <lambdabot> forall a b. Maybe a -> Maybe (a -> b) -> Maybe b
18:28:41 <rwbarton> Peaker: Why not? :)
18:28:54 <Peaker> rwbarton: then why not choose Nothing for all Maybes and get things over with? :)
18:29:07 <rwbarton> Ralith: Is there a .so called libedit2.so somewhere?
18:29:12 <rwbarton> Peaker: Indeed
18:29:46 <Peaker> rwbarton: I suspect some heuristic that tries to alternate between Just and Nothing or such
18:29:47 <rwbarton> Peaker: By the same logic, a Maybe a argument is useless, since it might be Nothing
18:29:51 <Ralith> rwbarton: nope. Looking into setting LDFLAGS="-R /usr/local/lib/libedit.so.6"
18:29:53 <Saizan_> Peaker: it tries to give useful proofs but not too hard, also it doesn't do recursion
18:30:25 <Peaker> @djinn Monad m => (a -> b) -> m a -> m b
18:30:26 <lambdabot> Error: Class not found: Monad
18:30:42 <Peaker> Saizan_: I am tired enough that I read "do recursion" and wondered if it did monads :)
18:30:52 <Ralith> rwbarton: readline built worked, anyway, so this'll do for now.
18:30:56 <Ralith> thanks for the help.
18:33:58 <ski_> @djinn Monad m => (a -> m b) -> (m a -> m b)
18:33:58 <lambdabot> f a b = b >>= a
18:34:06 <ski_> @djinn Monad m => (a -> b) -> (m a -> m b)
18:34:07 <lambdabot> -- f cannot be realized.
18:34:11 <ski_> hmm
18:34:16 <Peaker> djinn likes you more? :(
18:34:37 <ski_> Peaker : i just `@djinn-add'ed `Monad' ..
18:35:01 <Peaker> I figured :-)
18:35:02 <Saizan_> augustss said it doesn't handle higher-kinded classes well
18:35:10 <rwbarton> for example,
18:35:16 <Peaker> how do you add a class?
18:35:23 <rwbarton> @djinn Monad m => (a -> m b') -> (m a -> m b')
18:35:23 <lambdabot> -- f cannot be realized.
18:35:30 <ski_> Saizan_ : .. as evidenced by it refusing to infer `fmap' above
18:35:46 <ski_> Peaker : just like adding anything else
18:36:04 <Peaker> ski_: how do you add everything else?
18:36:53 <ski_> @djinn-add class Eq a => Ord a where (<=) :: a -> a -> Bool
18:36:53 <lambdabot> Cannot parse command
18:37:06 <ski_> hm, possibly it doesn't understand superclasses ..
18:37:22 <ski_> @djinn Eq a => a -> Bool
18:37:23 <lambdabot> f a = a == a
18:37:42 <ski_> @help djinn-add
18:37:42 <lambdabot> djinn-add <expr>.
18:37:42 <lambdabot> Define a new function type or type synonym
18:37:50 <ski_> (or class)
18:38:06 <Peaker> that's pretty cool.. how much effort has gone into djinn?
18:38:21 <ski_> augustss
18:41:11 <machack666> seems like there should be a quick way to do this, but how to generate a list of all permutations of length <= n from an input list?  I can think of a clunky way to do it, but seems like there should be something elegant
18:42:24 <ski_> @djinn ((a -> b) -> (p -> p) -> o) -> ((a -> b) -> o)
18:42:24 <lambdabot> f a b = a b (\ c -> c)
18:42:52 <ski_> @djinn ((a -> b) -> (b -> b) -> o) -> ((a -> b) -> o)
18:42:53 <lambdabot> f a b = a b (\ c -> c)
18:43:25 <rwbarton> machack666: maybe something like...
18:43:31 <sclv__> @hoogle permutation
18:43:31 <lambdabot> package permutation
18:44:01 <rwbarton> > let permsOfLength 0 _ = [[]]; permsOfLength n xs = [ x : y | x <- xs, y <- permsOfLength (n-1) (xs \\ [x]) ] in permsOfLength 3 "abcde"
18:44:03 <lambdabot>   ["abc","abd","abe","acb","acd","ace","adb","adc","ade","aeb","aec","aed","b...
18:44:37 <ski_> what is a "permutation of length <= n" ?
18:45:04 <rwbarton> I'm guessing it means a sequence of <= n distinct elements drawn from the input list (which I assume has no duplicates)
18:45:11 <ski_> is the length measured in the minimal number of swaps needed to compose it ?
18:47:14 <ddarius> The translation of constructor classes into System F involves higher-rank types.
18:47:14 * ski_ thinks one should be able to do something with `replicateM' ..
18:47:27 <machack666> sorry, permutation was the wrong word; I meant combinations drawn from a source list
18:47:53 <sclv__> one can just use the subsequences function and filter it, no?
18:48:00 <sclv__> of course there are more efficient ways.
18:48:12 <rwbarton> You can modify what I wrote slightly using the 'tails' function
18:48:18 <rwbarton> rather than \\
18:48:26 <Peaker> @djinn (a -> b) -> [a] -> [b]
18:48:26 <lambdabot> Error: Undefined type []
18:48:37 <rwbarton>  f _ _ = [] -- :P
18:48:43 <ski_> or write a `select :: [a] -> [] (a,[a])' ..
18:48:57 <Peaker> @djinn add data List a = Cons a (List a) | Empty
18:48:58 <lambdabot> Cannot parse command
18:49:00 <Peaker> @djinn-add data List a = Cons a (List a) | Empty
18:49:00 <lambdabot> Error: Recursive types are not allowed: List
18:49:07 <machack666> so for input list [1..9], you could have [[1],[2],..,[9],[1,1],[1,2],[1,3],..,[1,1,1],..]
18:49:18 <ozy`> there should be a /. operator that uploads a string to a well-known website
18:49:30 <machack666> basically all phrases of length <= n for a defined alphabet
18:49:45 <sclv__> machack666: is duplication allowed?
18:49:47 <rwbarton> Wait, that's something different again.
18:49:55 <rwbarton> Assuming order matters
18:50:04 <sclv__> ski: better yet a "picks" that gives you [a] ->[(a,[a])]
18:50:23 <rwbarton> sclv__: that is the same type that ski wrote :)
18:50:42 <machack666> sclv__: hypothetically, no, as you could just filter out, but it feels like there should be something elegant which produces all without needing to filter
18:50:52 <sclv__> oh... oops :-) the prefix list type send me for a loop
18:51:13 <machack666> rwbarton: order is insignificant, if you're talking to me
18:51:17 <rwbarton> machack666: is [2,1] in one of those .. somewhere?
18:51:19 <rwbarton> machack666: so no
18:51:20 <sclv__> machack666: in that case, ski's selection is correct
18:51:42 <machack666> sorry, misunderstood the ordering significance
18:51:47 <machack666> yes, [1,2] and [2,1] are distinct
18:51:58 <sclv__> .. or not.
18:52:26 <rwbarton> Can you please give the complete output for  function 2 [1,2,3]  :)
18:53:02 <ski_> sclv__ :)
18:53:20 <machack666> [[1],[2],[3],[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3],[1,1,1],[1,1,2],...,[3,3,2],[3,3,3]]
18:53:29 <machack666> truncated for brevity :)
18:53:35 <rwbarton> ah, so:
18:53:39 <rwbarton> > replicateM 2 [1,2,3]
18:53:40 <lambdabot>   [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
18:54:54 <pumpkin> > replicateM 3 [1,2,3]
18:54:56 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,2,1],[1,2,2],[1,2,3],[1,3,1],[1,3,2],[1,3,3],[2...
18:57:14 <ski_> (rwbarton : i was thinking of using `replicateM n' on `select' .. possibly in a nondeterministic state monad)
18:57:34 <machack666> seems like that's almost a foldM combined with replicateM, no?
18:58:24 <sclv__> ?src replicateM
18:58:25 <lambdabot> replicateM n x = sequence (replicate n x)
19:00:51 <machack666> the output for function 3 [1,2,3] = replicateM 1 [1,2,3] `mplus` replicateM 2 [1,2,3] `mplus` replicateM 3 [1,2,3]
19:01:03 <hoelzro> does anyone here use Vim to edit literate Haskell?  my current syntax highlighting is terrible
19:01:28 <ski_> > replicateM 3 (StateT select) `evalStateT` "abcd" :: [String]
19:01:30 <lambdabot>   ["abc","abd","acb","acd","adb","adc","bac","bad","bca","bcd","bda","bdc","c...
19:01:47 <ski_> (that's what i had in mind)
19:02:14 <machack666> the trick is now generalizing the addition of the lower-n'ed combinations
19:03:03 <rwbarton> > let xs = "abc" in do n <- [1,2]; replicateM n xs
19:03:04 <lambdabot>   ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc"]
19:04:13 <rwbarton> "Pick a length n, and then pick that many letters"
19:05:00 <ski_> "Decide to stop, or to have one more letter, if allowed", then ?
19:05:04 <machack666> > let function len xs = do n <- [1..len]; replicateM n xs in function 3 [1,2,3]
19:05:05 <lambdabot>   [[1],[2],[3],[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3],[1,1,1],...
19:05:38 <machack666> I think that does what I need
19:05:52 <machack666> good old ListMonad
19:06:05 <ski_> @hoogle f (a -> b) -> (a -> f b)
19:06:06 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
19:06:06 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
19:06:06 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
19:18:14 <dolio> @type (*>)
19:18:16 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
19:18:42 <dolio> @type \f -> (<*>) f . pure
19:18:43 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> a -> f b
19:27:16 * canadaduane pasted http://pastie.textmate.org/private/jmbckzl8gklvwep7cfqhzg
19:27:29 <canadaduane> Why does that give "invalid type signature"?
19:28:46 <canadaduane> ahh... is it the Float ?
19:28:47 <pumpkin> Array?
19:28:53 <rwbarton> MkHotplate starts with a capital letter so haskell thinks it's a data constructor
19:29:07 <rwbarton> values have to start with lowercase letters
19:29:14 <rwbarton> *variables
19:29:22 <canadaduane> ohh
19:29:40 <canadaduane> thank you, that was it
19:30:10 <canadaduane> Haskell has been one heck of a language to learn
19:30:22 <canadaduane> I'm expecting some kind of payoff after 3 months... lol
19:30:38 * pumpkin hands canadaduane $100
19:30:42 <canadaduane> ha
19:31:13 <rwbarton> @type range
19:31:14 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
19:31:32 <roconnor> haskell should have a different convention, like constructors are green and variables are blue.
19:31:43 <rwbarton> constructors are green on my screen... :)
19:31:53 <roconnor> rwbarton: you are half way there
19:32:30 <canadaduane> brb
19:33:05 * rwbarton wishes he could use arbitrary unicode characters in identifier names
19:33:23 <canadaduane> rwbarton: try Fortress :P
19:33:54 <rwbarton> canadaduane: Oh yeah, isn't that going to be released in just a few years now? :)
19:34:07 <pumpkin> you can almost use arbitrary unicode characters in most places!
19:34:13 <pumpkin> they just have to be of specific classes
19:34:24 <canadaduane> There are over 200 people on the mailing list... probably all waiting for that event
19:34:41 <canadaduane> (the Fortress mailing list)
19:34:50 <rwbarton> (I actually have no idea what the status of Fortress is)
19:35:22 <canadaduane> It hit 1.0 last year, that was neat.  But if I thought Haskell was hard to learn... goodness sakes
19:35:44 <roconnor> pdftk++
19:36:36 <rwbarton> pumpkin: I discovered this great character: 2061 FUNCTION APPLICATION · contiguity operator indicating application of a function
19:37:25 <rwbarton> pumpkin: which could be overloaded for different kinds of function application!
19:37:29 <rwbarton> pumpkin: except it's not valid
19:38:15 <pumpkin> I wonder why not hmm
19:39:26 <pumpkin> oh it's listed under other, format
19:40:25 <rwbarton> You also can't use curly quotes
19:51:46 <chessguy> i'm impressed by the number of companies on http://www.haskell.org/haskellwiki/Haskell_in_industry
20:16:49 <CakeProphet> so ap is like...
20:17:09 <CakeProphet> ($) mixed with liftM?
20:17:34 <rwbarton> @src ap
20:17:34 <lambdabot> ap = liftM2 id
20:17:52 <rwbarton> and ($) = id (more or less)
20:19:29 <CakeProphet> rwbarton:  in the case of functions, right?
20:19:33 <CakeProphet> :t id
20:19:35 <lambdabot> forall a. a -> a
20:19:39 <CakeProphet> :t ($)
20:19:41 <lambdabot> forall a b. (a -> b) -> a -> b
20:22:28 <CakeProphet> hmmm... yeah
20:22:38 <CakeProphet> ($) f === id f
20:22:51 <roconnor> ($) === id
20:22:57 <roconnor> @pl ($)
20:22:58 <lambdabot> id
20:23:35 <CakeProphet> that's only true when a is (x->y) though.
20:23:58 <CakeProphet> @pl id
20:23:59 <lambdabot> id
20:24:49 <roconnor> CakeProphet: fair point
20:24:55 <dolio>  @pl isn't afraid of generalizing types.
20:25:29 <CakeProphet> well yeah... when you do @pl ($) it can safely assume you're dealing with (a->b)... since that's what ($) accepts.
20:25:47 <CakeProphet> and for (a->b) ($) === id
20:26:52 <rwbarton>  @pl actually doesn't care about types in the slightest
20:27:01 <rwbarton> @pl \x -> x x
20:27:01 <lambdabot> join id
20:27:11 <pumpkin> lol
20:27:39 <roconnor> @pl \f -> (\x -> f x x) (\x -> f x x)
20:27:39 <lambdabot> ap join join
20:28:04 <roconnor> SWW ?
20:28:28 <roconnor> Y = SWW ?
20:29:30 <CakeProphet> I'm glad Haskell has id.
20:29:42 <CakeProphet> I once petitioned to the Python devs to include id somewhere in the standard library
20:29:45 <CakeProphet> didn't go over too well
20:30:26 <rwbarton> That sounds like it could be amusing.
20:30:48 <CakeProphet> they thought I was a troll
20:31:34 <Adamant> funny, I always though Python was a troll
20:31:43 <pumpkin> python's a snake
20:31:51 <Adamant> no, I mean
20:32:16 <roconnor> I think I've used id before
20:32:38 <Adamant> the whole language
20:33:00 <CakeProphet> roconnor:  in Haskell or Python?
20:33:14 <roconnor> Haskell
20:33:26 * CakeProphet has been in a situation in Python where he had to do lambda x: x
20:33:36 <CakeProphet> that's why I thought id in standard library would have been nice
20:33:55 <roconnor> oh wow
20:33:58 <roconnor> I use it a lot
20:34:01 <roconnor> negateCts = UniformCts id negate
20:34:14 <roconnor> sinCts = UniformCts id (approx . rationalSin radius)
20:34:41 <roconnor> Picard.hs:  Build_UniformCts (\x -> forgetUniformCts id x) (\a eps -> a)
20:35:00 <roconnor> Era.hs:sin_dr x = x*power_series (acc_seq (\a n -> -a*(1%(2*n*(2*n+1))))) id (x*x)
20:35:06 <rwbarton> I've used it 3 times in this currently 314-line program I'm writing
20:35:36 <rwbarton> although two of those uses are in placeholders fromList/toList for when I switch to difference lists
20:35:42 <roconnor> UniversalGeometry/Figure.hs:                      (foldr (.) id $ map shows b) .
20:35:44 <roconnor> oh
20:35:53 <roconnor> but I've stopped using foldr (.) id
20:35:57 <pumpkin> UniversalGeometry :o
20:36:09 <rwbarton> Oh?  What else then?
20:36:28 <rwbarton> mconcat . map Endo? :)
20:36:34 <roconnor> rwbarton: ummm
20:36:43 <roconnor> foldr id x -- IIRC
20:36:48 <roconnor> so I guess that still counts
20:36:59 <roconnor> or foldr ($) x -- probaby clearer
20:37:15 <rwbarton> @type foldr id
20:37:16 <lambdabot> forall b. b -> [b -> b] -> b
20:37:41 <roconnor> Graphics/Rendering/Chart/Axis.hs: relativeExtend = defaultRelativeExtend id id
20:38:00 <roconnor> Data/Colour/RGBSpace.hs:linearTransferFunction = TransferFunction id id 1
20:38:02 <roconnor> wow
20:38:09 <roconnor> id is even more popular than I had realized
20:38:34 <roconnor> rwbarton: prehaps flip (foldr id)
20:38:40 <roconnor> is more clear
20:38:57 <BMeph> @ty foldr (flip id)
20:38:58 <lambdabot>     Occurs check: cannot construct the infinite type: c = a -> c
20:38:58 <lambdabot>     Probable cause: `flip' is applied to too many arguments
20:38:58 <lambdabot>     In the first argument of `foldr', namely `(flip id)'
20:39:07 <BMeph> Heh-heh. ;p
20:40:04 <roconnor> Arbitrage2.hs:  maybe (fail "no session id found") return
20:40:08 <roconnor> I guess that one doesn't count
20:40:36 <roconnor> either (error . show) id
20:40:45 <roconnor> boy
20:40:52 <roconnor> how does python manage without id
20:41:10 <Ralith> by being imperative
20:41:35 <Saizan> HOFs are probably rare?
20:43:35 <roconnor> Is there a nicer way to do (either (error . show) id), prehaps using an arrow function?
20:44:01 <dolio> @type (+++)
20:44:02 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
20:44:09 <dolio> @type (|||)
20:44:10 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
20:44:16 <Saizan> ?type error . show ||| id
20:44:17 <lambdabot> forall a c. (Show a) => Either a c -> c
20:44:48 <Riastradh> That's not terse enough for you already, roconnor?
20:44:50 <roconnor> @src (->) (|||)
20:44:51 <lambdabot> Source not found. That's something I cannot allow to happen.
20:44:59 <nolrai_East> So what are the common Haskell idioms for implementing a back-end, that can have multiple possible front-ends? I'm trying to write a simple game and I want to be able to test the engine with a command line interface, and then replace that with a graphical interface latter.
20:45:01 <roconnor> Riastradh: nope
20:45:10 <roconnor> @src (|||) (->)
20:45:11 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
20:45:38 <nolrai_East> in what file is ||| defined?
20:45:39 <sjanssen> roconnor: it seems clear from the type that (|||) = either
20:45:46 <roconnor> yes
20:46:03 <roconnor> sjanssen: although it could be (|||) = undefined
20:46:13 <ClaudiusMaximus> nolrai_East: the Prompt monad might work for that (at least the examples had "interactive input" vs "algorithmic input" iirc)
20:46:24 <roconnor> you never can tell with Haskell
20:46:24 <BMeph> @ty ap zip . map (error . show)
20:46:25 <lambdabot>     Couldn't match expected type `[a] -> [b]'
20:46:25 <lambdabot>            against inferred type `[c]'
20:46:25 <lambdabot>     Probable cause: `map' is applied to too many arguments
20:46:43 <BMeph> @ty ap zip . error . show
20:46:45 <lambdabot> forall a b a1. (Show a1) => a1 -> [a] -> [(a, b)]
20:46:51 <nolrai_East> ClaudiusMaximus: Thanks!
20:46:58 <nolrai_East> ClaudiusMaximus++
20:47:30 <ClaudiusMaximus> nolrai_East: if you haven't found it already http://www.mail-archive.com/haskell-cafe@haskell.org/msg33040.html
20:47:55 <BMeph> nolrai_East: (|||) is in Control.Arrow :)
20:48:07 <rwbarton> It's on hackage too, MonadPrompt
20:48:46 <Saizan> ?hackage MonadPrompt
20:48:46 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MonadPrompt
20:48:54 * ClaudiusMaximus should have guessed that, everything seems to be :)
20:48:57 <BMeph> nolrai_East: But yeah, try a Prompt Monad - one of the most fun things about Haskell... ;p
20:49:24 <roconnor> this monad prompt looks pretty cool
20:49:28 <BMeph> Haskell: If you don't like lazy monads, we have Prompt ones, too! ;)
20:49:56 <pumpkin> y'all should use statistics-fusion! there's some code of mine in there!
20:50:01 * pumpkin is very proud
20:53:26 <roconnor> I wonder if there is a Haskell 98 way of doing the Prompt Monad
20:54:34 <nolrai_East> I don't have to understand GADT to use the Prompt Monad, do I?
20:55:05 <roconnor> hmm
20:55:28 <roconnor> nolrai_East: after reading the post, I imagine that you do.  But I'm not certain.
20:55:48 <byorgey> that's OK, GADTs aren't that hard
20:56:03 <byorgey> it just lets you be a bit more flexible with the types of your data constructors.
20:56:08 <roconnor> ya, typical uses of GADTs aren't that hard
20:56:21 <CakeProphet> > let mapD 0 _ = const []; mapD 1 f = map f; mapD n f = map (mapD (n-1) f) in mapD 2 (+3) [[1,2,3], [1,2,3], [1,2,3]]
20:56:22 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
20:56:22 <lambdabot>        Expect...
20:56:39 <nolrai_East> mmm. OK then. any good places to read up on GADTs?
20:56:41 <CakeProphet> ugh
20:56:53 <rwbarton> Heh, nice try :)
20:57:52 * roconnor doesn't have any GADT references himself
20:58:10 <Saizan> mmh
20:58:18 <Saizan> ?google wikibook GADTs
20:58:21 <lambdabot> http://en.wikibooks.org/wiki/Haskell/GADT
20:58:27 <byorgey> CakeProphet: use something like  data Bush a = Trunk (Bush [a]) | Leaves [a]
20:58:33 <byorgey> and make it an instance of Functor
20:59:03 <rwbarton> You can also write a deepFmap using some type class magic
21:00:13 <CakeProphet> -shrug- I just wanted to see if I could make a multi-dimensional map.
21:00:43 <rwbarton> CakeProphet: Its type would have to depend on the integer you passed it
21:01:14 <CakeProphet> no
21:01:18 <CakeProphet> not really.
21:01:19 <roconnor> instance (Functor f, Functor g) => Functor (f :O g)
21:01:31 <CakeProphet> [a] and [[]] are the same right?
21:01:45 <Saizan> you could make one with data Nat n where Zero :: Nat Zero; Succ :: Nat (Succ Zero), probably
21:01:47 <CakeProphet> or... rather
21:02:05 <byorgey> CakeProphet: yes, really.  the type of the second parameter to mapD would have to be  [[...[[a]]...]]  where the number of ... is n
21:02:08 <CakeProphet> [a] and [[a]]. or do type variable not represent parametrical types.
21:02:19 <CakeProphet> +s
21:02:51 <byorgey> CakeProphet: no, if you try to unify  [a] and [[a]] you get the recursive type  a = [a] which is not allowed.
21:03:08 <CakeProphet> ...why.
21:03:19 <Saizan> CakeProphet: in forall a. Int -> (a -> b) -> [a] -> [b], you can't assume anything about 'a' and 'b'
21:03:34 <roconnor> CakeProphet: no particular reason other than it usually stops errors
21:03:43 <dolio> If a = [a], then a = [[[[[[[[...]]]]]]]]
21:03:43 <Saizan> CakeProphet: while you're trying to assume some type for 'a' depending on the value of the Int
21:04:10 <roconnor> you can make data BigList a = [BigList a] if you want.
21:04:11 <pumpkin> it's fine with infinite custom types isn't it?
21:05:12 <byorgey> pumpkin: as long as there is a constructor 'in between' the recursion.
21:05:24 <pumpkin> yeah
21:05:43 <byorgey> Haskell has 'iso-recursive' types, but disallows 'equi-recursive' types
21:07:03 <roconnor> byorgey: that's a good way of putting it
21:07:15 <roconnor> although I think some people on cafe would disagree
21:07:17 <CakeProphet> sure, if you know what that means.
21:07:25 <rwbarton> But more to the point, you probably don't have a value of [[[[[[[[[[[...]]]]]]]]]]]
21:07:38 <roconnor> prefering 'grape-recursive' and 'blueberry-recursive'
21:07:44 <byorgey> hehe
21:07:45 <roconnor> cause that is more friendly
21:07:47 <dolio> Well, there are plenty, but they aren't very interesting.
21:07:56 <byorgey> [], [[]], [[[]]], ...
21:08:11 <roconnor> [[],[[]]]
21:08:22 <byorgey> oh yeah, those too =)
21:08:25 <dolio> Yeah. And fix (:[]).
21:08:30 <roconnor> they aren't very intresting, if you think set theory isn't very intresting
21:09:05 <byorgey> let's Godel-encode everything, and then express them using values of type [[[[[[[...]]]]]]]]! =D
21:09:12 <roconnor> \o/
21:10:37 <CakeProphet> ...I don't want a type of [[[...]]], I want a type of [a] where a can equal [b] or [[b]] or [[[b]]]
21:10:48 <CakeProphet> just like a can be Int, Char, etc
21:11:20 <dolio> It can.
21:11:31 <dolio> As much as it can be any of those, anyhow.
21:11:43 <CakeProphet> and Haskell's type system limiting this when it's supposed to be polymorphic is silly.
21:11:48 <rwbarton> No it's not
21:11:48 <Saizan> yeah, but your function can't be defined per cases on the type that 'a' will be instanced to
21:11:55 <rwbarton> Look: mapD 1 is map, right?
21:11:55 <Saizan> you need typeclasses for that
21:12:02 <byorgey> CakeProphet: the problem is that if you have a function that takes an [a], it must work *no matter* what a is.
21:12:10 <byorgey> even if a is Int.
21:12:29 <byorgey> but your function would need to test a to see whether it is a list or not, and act differently in either case.
21:12:39 <byorgey> Haskell can't do that.
21:12:48 <Cale> Typeclasses.
21:13:01 <rwbarton> Actually, CakeProphet wants to use the integer argument to distinguish the cases, which also doesn't work, but...
21:13:47 <roconnor> mapD is a dependent type
21:13:53 <dolio> You could do it with some fancy type stuff.
21:13:57 <rwbarton> CakeProphet: You want mapD 1 :: (a -> b) -> [a] -> [b] and mapD 2 :: (a -> b) -> [[a]] -> [[b]], which is impossible
21:14:04 <dolio> Families and GADTs for some pseudo dependent typing.
21:14:05 <roconnor> you need a fancier type system to do dependent types
21:14:16 <pumpkin> I want dependent haskell
21:14:22 <roconnor> epigram!
21:14:26 <Saizan> or you can use macros.
21:14:31 <byorgey> agda!
21:14:39 <roconnor> agda!
21:14:41 <dolio> Of course, then you won't be writing "1".
21:14:43 <pumpkin> agda!
21:14:54 <roconnor> agda 2!
21:15:06 <pumpkin> 2! is just 2, silly
21:15:15 <rwbarton> With the type class solution you don't need the integer argument at all
21:15:37 <CakeProphet> rwbarton:  what is the typeclass solution?
21:16:03 <CakeProphet> and yes you do... if you want to map a function over nested rows
21:16:25 <rwbarton> http://okmij.org/ftp/Haskell/typecast.html#deepest-functor
21:16:58 <pumpkin> I wish oleg would stop his underscore abuse :P
21:17:03 <pumpkin> as much as I love the things he does
21:17:07 <rwbarton> hmm, I'm not sure whether that's the good version
21:17:08 <Saizan> CakeProphet: the type system can figure out how you deep you want to go for you
21:17:13 <byorgey> CakeProphet: warning, that way lies madness ;)
21:17:40 <roconnor> If you don't have an interger argument then it seems to me that polymorphic functions would behave in potentially unexpected ways
21:18:10 <roconnor> I'd use an integer argument.  that's what was done for my derivatives of multivariable polynomials
21:18:14 <rwbarton> roconnor: that's the difference between the "good version" and the "bad version"
21:18:27 <roconnor> well not really an integer argument
21:18:36 <roconnor> but taht Zero, Succ Zero type stuff
21:19:01 <Cale> > everywhere (mkT (+1)) [1,2,3,4,5]
21:19:03 <lambdabot>   /tmp/6703922704986936543:70:56: Not in scope: `everywhere'/tmp/670392270498...
21:19:08 <Cale> aww
21:20:02 <rwbarton> , everywhere (mkT (+1)) [1,2,3,4,5]
21:20:10 <lunabot>  [2,3,4,5,6]
21:20:45 <Cale> , everywhere (mkT (+1)) [[1,2,3,4,5],[6,7,8]]
21:20:47 <lunabot>  [[2,3,4,5,6],[7,8,9]]
21:21:07 <Cale> , everywhere (mkT (+1)) [[[1,2,3,4,5],[6,7,8]],[[9,10,11],[12,13]]]
21:21:09 <lunabot>  [[[2,3,4,5,6],[7,8,9]],[[10,11,12],[13,14]]]
21:21:46 <roconnor> , everywhere (mkT (:[])) [[1,2,3,4,5],[6,7,8]]
21:21:48 <lunabot>  luna: Occurs check: cannot construct the infinite type: b = [b]
21:21:55 <CakeProphet> class IsCollection  t coll | t -> coll   I've never seen this syntax
21:22:05 <byorgey> that's a functional dependency
21:22:20 <Cale> It means that the type t determines the type coll uniquely.
21:22:22 <rwbarton> I think this might the nice version, from EvilTerran: class FunctorOf a fa b fb | fa -> a, fb -> b where fomap :: (a -> b) -> fa -> fb; instance FunctorOf a a b b where fomap = id; instance (FunctorOf a fa b fb, Functor g) => FunctorOf a (g fa) b (g fb) where fomap = fmap . fomap
21:22:43 <roconnor> | t -> coll  is only for helping the type inference system.  It doesn't really affect the semantics
21:22:47 <byorgey> that is, for each given type t, there can only be one instance of IsCollection.
21:23:01 <roconnor> one instance of coll
21:23:20 <Cale> IsCollection is the class here :P
21:24:31 <Cale> Ah, I see the point roconnor is making :)
21:24:39 <Saizan> we usually say that for each 't' there can be only one 'coll', but with that fundep 't' is the key of the relation, so it's also true that for each 't' there can be only one instance
21:25:11 <CakeProphet> this is ridiculously complicated.
21:25:31 <Cale> CakeProphet: What is?
21:25:43 <CakeProphet> http://okmij.org/ftp/Haskell/deepest-functor.lhs
21:25:53 <roconnor> CakeProphet: use agda 2
21:26:07 <CakeProphet> what?
21:26:15 <roconnor> it does exactly what you want
21:27:04 <Cale> CakeProphet: That code was written by Oleg. He has a tendency to push at the boundaries of what's expressible.
21:27:50 <lament> from the other side
21:27:53 <roconnor> http://appserv.cs.chalmers.se/users/ulfn/wiki/agda.php?n=Main.HomePage
21:27:56 <Cale> lament: hehe
21:28:23 <lament> imagine having oleg as your prof
21:29:23 <Saizan> roconnor: have you tried writing something like that?
21:29:39 <roconnor> Saizan: mapD?
21:29:50 <Saizan> yes, in agda2
21:29:55 <roconnor> not in agda2
21:29:58 <Cale> CakeProphet: It's important to note that types in Haskell are entirely a compile-time construct.
21:30:01 <roconnor> in Haskell
21:30:09 <roconnor> and I could do it in Coq
21:30:17 <roconnor> but I've never used agda2
21:30:25 <Cale> CakeProphet: So the value of a parameter to a function alone can't determine the type of its result. The *type* of that parameter can.
21:30:58 <roconnor> Cale: btw, your two statements are independent.
21:32:16 <Cale> roconnor: Which two?
21:33:08 <roconnor> types being a compile time construct and values not being able to determine the type of the result
21:33:25 <Saizan> you've type-erasure in dependently typed languages too
21:33:25 * CakeProphet is trying to understand how this deep fmap works.
21:33:26 <roconnor> for example Coq has the latter, but can be extracted to scheme, which is typeless
21:33:35 <Cale> If you allow the value of a parameter to determine the type of the result of a function, then in order to typecheck the code, you need to evaluate the value.
21:33:44 <rwbarton> CakeProphet: Better to try something like http://hpaste.org/2938
21:34:09 <roconnor> Cale: so you sould instead say that values are an entirely run-tme construct
21:34:22 <Cale> Well, that's true as well.
21:34:49 * roconnor gives up
21:34:53 <Saizan> Cale: you can prove that for each value you get a welltyped function
21:35:08 <Saizan> for each value that parameter can take
21:35:15 <Saizan> i meant
21:35:32 <CakeProphet> rwbarton:  so you can use multi-parameter type classes to describe different behavior for different combinations of types?
21:35:40 <CakeProphet> like type pattern matching?
21:36:11 <rwbarton> Saizan: But in this case, you'd also have to check the application of the function
21:36:49 <rwbarton> CakeProphet: Yeah, to the extent that ordinary type classes are like type pattern matching on a single type
21:37:55 <CakeProphet> rwbarton:  but then how do Functors become instances of FunctorOf?
21:38:18 <CakeProphet> is it because not all of the parameters are explicit... so you can make /every/ instance of Functor an instance of FunctorOf?
21:38:31 <CakeProphet> through type constraints.
21:38:43 <Cale> You can think of a typeclass as a predicate on types, which, when true, provides some functionality involving the type it holds for. Multiparameter typeclasses extend that in a natural way -- they're relations or n-ary predicates on types, which when true, provide some interface relating those types.
21:40:07 <Cale> Functional dependencies allow you to express constraints on how that relation looks -- that certain combinations of the types being related uniquely determine certain other combinations (the same way that the parameters to a function uniquely determine its result)
21:40:36 <CakeProphet> ...I'll grok that later.
21:41:05 <CakeProphet> I've just always seen instance SomeTypeClass SomeSpecificType
21:41:09 <Cale> So, for a single-parameter typeclass example, you can think of the Ord class as being a predicate which tells you if a type is ordered.
21:41:22 <CakeProphet> so I didn't know you could instance SomeTypeClass a
21:41:35 <CakeProphet> or with multi-parameters, SomeTypeClass a b c
21:42:00 <Cale> Ah, that does require further extensions, if you don't have at least a little structure in each of the type parameters.
21:42:19 <gio123> Cale: hi
21:42:23 <Cale> hi
21:42:37 <Cale> Even in Haskell 98, you're allowed to have  instance Ord a => Ord [a] where ...
21:43:29 <nolrai_East> :t concatMap
21:43:30 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
21:44:28 <gio123> Cale: could you please see pm
21:44:38 <newsham> > concatMap (('(':).(++")")) "hello"
21:44:40 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
21:45:19 <newsham> > concatMap (\c -> "("++[c]++")") "hello"
21:45:20 <lambdabot>   "(h)(e)(l)(l)(o)"
21:45:51 <pumpkin> newsham: I love using ("(" ++) . (++ ")") for stuff like that, and it isn't particularly unclear either
21:46:02 <pumpkin> oh wait, that doesn't work for this :)
21:46:04 <pumpkin> sorry
21:46:08 <pumpkin> you could add a return, I guess
21:46:18 <pumpkin> but that makes it less purty
21:46:59 <pumpkin> '(':x:")" maybe
21:47:09 <pumpkin> @pl \x -> '(':x:")"
21:47:09 <lambdabot> ('(' :) . (: ")")
21:47:14 <pumpkin> woohoo
21:47:34 <pumpkin> > concatMap (('(' :) . (: ")")) "hello"
21:47:35 <lambdabot>   "(h)(e)(l)(l)(o)"
21:47:44 <nolrai_East> > replicate (-1) 'a'
21:47:45 <lambdabot>   ""
21:49:31 <CakeProphet> > "(" ++ (intersperse ")(" "hello") ++")"
21:49:32 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
21:49:51 <CakeProphet> ah.
21:52:21 <CakeProphet> > "(" ++ (intercalate ")(" (map (:[]) "hello")) ++")"
21:52:23 <lambdabot>   "(h)(e)(l)(l)(o)"
21:52:34 <CakeProphet> not very pretty now.
21:52:45 <pumpkin> map return
21:53:19 <CakeProphet> I guess that would get rid of some of the Perlocity.
21:53:19 <pumpkin> oh, even prettier is
21:53:27 <pumpkin> "hello" >>= ('(' :) . (: ")")
21:53:34 <pumpkin> > "hello" >>= ('(' :) . (: ")")
21:53:35 <lambdabot>   "(h)(e)(l)(l)(o)"
21:54:23 <nornagon> @pl (\a -> "("++a++")")
21:54:24 <lambdabot> ('(' :) . (++ ")")
21:54:26 <mmorrow> > foldl (\doc  c -> doc <> parens (char c)) (text "") "hello"
21:54:28 <lambdabot>   (h)(e)(l)(l)(o)
21:54:37 <nornagon> @pl (\a -> "((("++a++")")
21:54:38 <lambdabot> ("(((" ++) . (++ ")")
21:54:55 <CakeProphet> I always have a hard time wrapping my head around function compositions of compositions.
21:54:57 <nornagon> bad lambdabot, changing my "" to ''.
21:55:13 <pumpkin> why?
21:55:35 <nornagon> > concatMap (("("++).(++")")) "hello"
21:55:37 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
21:56:03 <pumpkin> > concatMap (("("++).(++")") . return) "hello"
21:56:04 <lambdabot>   "(h)(e)(l)(l)(o)"
21:56:06 <nornagon> oh, right
21:56:21 <mmorrow> > let r n = foldr (.) id . replicate n; f = r 3 braces . r 3 brackets . r 3 parens in f (int 42)
21:56:22 <lambdabot>   {{{[[[(((42)))]]]}}}
21:56:38 <pumpkin> lol
21:56:59 <rwbarton> @type parens
21:57:00 <lambdabot> Doc -> Doc
21:59:01 <CakeProphet> I've always wanted a And and Or type.
21:59:08 <pumpkin> what fo'?
22:00:07 <CakeProphet> data Or a b = (:|:) a b
22:00:23 <pumpkin> what does it do?
22:00:44 <CakeProphet> well... I don't really think it's possible because of typing
22:00:45 <CakeProphet> but
22:00:55 <CakeProphet> it would derive Eq
22:01:10 <CakeProphet> so that (3 :|: 4) == 3
22:01:12 <CakeProphet> would yield True
22:01:24 <pumpkin> :o
22:01:37 <pumpkin> Eq wants both sides to be of same type :(
22:01:38 <mmorrow> > let (<+>) = (Text.PrettyPrint.HughesPJ.<+>); fun f args bdy = text "function" <+> text f <> parens (hcat . punctuate comma . fmap text $ args) <+> char '{' $+$ nest 2 (vcat . fmap ((<>semi) . text) $ bdy) $+$ char '}' in fun "id" ["x"] ["return(x)"]
22:01:39 <lambdabot>   function id(x) {
22:01:39 <lambdabot>    return(x);
22:01:39 <lambdabot>  }
22:01:41 <CakeProphet> right
22:01:43 <newsham> > (map chr.concatMap (\x->[40,x,41]).scanl (+) 104) [-3,0,7,3]
22:01:44 <rwbarton> Isn't it also impossible because its semantics don't make any sense? :)
22:01:45 <lambdabot>   "(h)(e)(e)(l)(o)"
22:02:07 <newsham> > (map chr.concatMap (\x->[40,x,41]).scanl (+) 104) [-3,7,0,3]
22:02:08 <lambdabot>   "(h)(e)(l)(l)(o)"
22:02:15 <mmorrow> (lb insert an extra space on the first line)
22:02:34 <pumpkin> lol
22:02:36 <mmorrow> > text "showMeWithNoParens"
22:02:37 <lambdabot>   showMeWithNoParens
22:02:39 <pumpkin> that's pretty cute :)
22:02:45 <mmorrow> oops s/parens/quotes/
22:03:24 <CakeProphet> rwbarton:  it makes perfect sense. (3 :|: 4) is a value that equals 3 or 4. It's just not possible because of the typing of (==)
22:03:33 <newsham> CakeProphet: there are And and Or types already
22:03:37 <rwbarton> CakeProphet: Does 3 :|: 4 == 4 :|: 5?
22:03:39 <newsham> they're called (,) and Either
22:03:55 <CakeProphet> rwbarton:  yes.
22:03:57 <rwbarton> CakeProphet: Or, 3 == 3 :|: 4 == 4 ??
22:04:21 <pumpkin> CakeProphet: sounds like you could almost monadize it
22:04:32 <CakeProphet> and I suppose
22:04:33 <pumpkin> but not really
22:04:35 <newsham> Either (S (S (S Z))) (S (S (S (S Z))))
22:04:54 <CakeProphet> (3:|:4) + 2 would yield (5:|:6)
22:05:02 <CakeProphet> :D
22:05:05 <pumpkin> lol
22:05:05 <newsham> ?type (+)
22:05:07 <lambdabot> forall a. (Num a) => a -> a -> a
22:05:19 <CakeProphet> right.
22:05:22 <rwbarton> :t (<^)
22:05:23 <lambdabot> Not in scope: `<^'
22:05:40 <newsham> > liftM (+2) [3,4]
22:05:41 <lambdabot>   [5,6]
22:06:10 <rwbarton> @let infixl 3 <^; (<^) = flip (<$>)
22:06:11 <lambdabot>  Defined.
22:06:22 <rwbarton> @let infixl 3 ^>; (^>) = (<*>)
22:06:23 <lambdabot>  Defined.
22:06:27 <pumpkin> oh no, here come the bats
22:06:36 <rwbarton> > [3,4] <^(+)^> pure 2
22:06:37 <lambdabot>       Ambiguous occurrence `pure'
22:06:37 <lambdabot>      It could refer to either `Control.Appl...
22:06:46 <rwbarton> > [3,4] <^(+)^> Control.Applicative.pure 2
22:06:47 <lambdabot>   [5,6]
22:06:52 <mmorrow> we can't stop HERE! it's BAT COUNTRY!!
22:07:08 <newsham> > [3,4] <^(+)^> [2]
22:07:09 <lambdabot>   [5,6]
22:07:21 <CakeProphet> oh lawd.
22:07:29 <pumpkin> it's the bat operator from hell
22:07:40 <newsham> > or (liftM2 (==) [3,4] [4,5])
22:07:42 <lambdabot>   True
22:07:45 <CakeProphet> :t <$>
22:07:47 <lambdabot> parse error on input `<$>'
22:07:53 <CakeProphet> :t (<$>)
22:07:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:08:12 <newsham> > ([3,4] <^(==)^> [4,5])
22:08:14 <lambdabot>   [False,False,True,False]
22:08:24 <CakeProphet> gosh golly... that type signature looks awfully familiar.
22:08:36 <newsham> ?src (<$>)
22:08:37 <lambdabot> f <$> a = fmap f a
22:09:01 <mmorrow> > [(^3),(+4)] <^(.)^> [(*2)] <^id^> [42]
22:09:03 <lambdabot>   [592704,88]
22:09:13 <pumpkin> lol
22:09:24 <CakeProphet> rwbarton: oh that's cool.
22:09:26 <mmorrow> heh, these bat operators are sweet
22:10:00 <CakeProphet> <^ and ^> are like some weird liftM2
22:11:04 <newsham> %format <^(+)^> "\overline{$+$}"
22:11:15 <newsham> infix liftM2 op
22:11:26 <Saizan> liftM2 f x y = fmap f x `ap` y
22:11:53 <newsham> f `fmap` x `ap` y
22:12:00 <newsham> return f `ap` x `ap` y
22:15:03 <mmorrow> @yow
22:15:03 <lambdabot> An INK-LING?  Sure -- TAKE one!!  Did you BUY any COMMUNIST UNIFORMS??
22:15:07 <mmorrow> @nixon
22:15:07 <lambdabot> Don't get the impression that you arouse my anger. You see, one can only be angry with those he respects.
22:15:26 <newsham> ?Farber
22:15:27 <lambdabot> I'm standing over your shoulder.
22:15:44 <mmorrow> @. vixen nixon
22:15:45 <lambdabot> Whatever
22:15:51 <rwbarton> @ghc
22:15:52 <lambdabot> ghc says: panic! (the `impossible' happened, GHC version 6.4)
22:16:25 <Saizan> @protontorpedo
22:16:26 <lambdabot> hu me/
22:19:40 -i8801(n=g9481@189.10.109.162)- Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel s
22:19:40 -o2966(n=v1687@189.10.109.162)- Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel s
22:19:40 -y4373(n=q2322@200.78.218.2)- Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel so
22:19:42 -y6926(n=c2104@201-67-5-155.cbace700.dsl.brasiltelecom.net.br)- Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The Uni
22:19:44 -y4373(n=q2322@200.78.218.2)- Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel so
22:19:44 -i8801(n=g9481@189.10.109.162)- Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel s
22:19:45 -o2966(n=v1687@189.10.109.162)- Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel s
22:19:48 -y6926(n=c2104@201-67-5-155.cbace700.dsl.brasiltelecom.net.br)- Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The Uni
22:19:49 -i8801(n=g9481@189.10.109.162)- Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel s
22:19:49 -o2966(n=v1687@189.10.109.162)- Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel s
22:19:49 -y6926(n=c2104@201-67-5-155.cbace700.dsl.brasiltelecom.net.br)- Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The Uni
22:19:58 -y6926(n=c2104@201-67-5-155.cbace700.dsl.brasiltelecom.net.br)- Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The Uni
22:19:59 -i8801(n=g9481@189.10.109.162)- Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel s
22:19:59 -o2966(n=v1687@189.10.109.162)- Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel s
22:20:02 -y6926(n=c2104@201-67-5-155.cbace700.dsl.brasiltelecom.net.br)- Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The Uni
22:20:02 -o2966(n=v1687@189.10.109.162)- Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel s
22:20:02 -i8801(n=g9481@189.10.109.162)- Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel s
22:20:10 -b9073(n=x3945@wc-02.sps.net.sa)- Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel
22:20:10 -b9073(n=x3945@wc-02.sps.net.sa)- Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel
22:20:12 -b9073(n=x3945@wc-02.sps.net.sa)- Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel
22:20:15 -y6926(n=c2104@201-67-5-155.cbace700.dsl.brasiltelecom.net.br)- Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The UniBG irc.techno-link.com channel sofia Welcome The Uni
22:20:24 <moofbong> wtf
22:20:33 <newsham> houston we have a problem
22:20:41 <QtPlatyp1s> Weard ass spam.
22:20:53 <RichiH> i am dealing with it
22:21:14 <mmorrow> * b9073 (n=x3945@wc-02.sps.net.sa) has joined #haskell
22:21:14 <mmorrow> * y4373 (n=q2322@200.78.218.2) has joined #haskell
22:21:14 <mmorrow> * o2966 (n=v1687@189.10.109.162) has joined #haskell
22:21:14 <mmorrow> * i8801 (n=g9481@189.10.109.162) has joined #haskell
22:21:38 <RichiH> yes, i nuked them
22:21:49 <mmorrow> :)
22:22:29 <moofbong> seems like an odd thing to bomb an irc room with...
22:22:31 <newsham> .mx,.br,.sa
22:23:03 <jHoNDoE> nuked?
22:23:54 <rwbarton> @users
22:23:57 <lambdabot> Maximum users seen in #haskell: 668, currently: 564 (84.4%), active: 13 (2.3%)
22:24:41 <RichiH> jHoNDoE: the bots will not be able to reconnect to freenode
22:25:38 <rwbarton> I realize this is a stupidly phrased question, but: what does it mean that the bots' names are purple on my screen? :)
22:25:55 <jHoNDoE> k
22:26:16 <SamB_XP> rwbarton: probably the fact that they're using NOTICE
22:26:20 <SamB_XP> rather that PRIVMSG
22:26:22 <CakeProphet> rwbarton:  that your IRC client has terrible fashion sense.
22:26:25 <geezusfreeek> does anybody know of any research, papers, or articles on reasoning about sharing? it appears to be a somewhat neglected topic to me
22:26:44 <CakeProphet> sharing what?
22:26:44 <geezusfreeek> i've seen a lot of stuff about knot tying lately, is about it
22:26:51 -newsham(n=chat@thenewsh.com)- hi rwbarton
22:26:52 <rwbarton> SamB_XP: I see, thanks
22:27:25 <geezusfreeek> @src repeat
22:27:26 <lambdabot> repeat x = xs where xs = x : xs
22:27:37 <geezusfreeek> CakeProphet, that, for example
22:27:51 <sclv__> geezusfreeek: i know of papers about compiler optimizations -- let-floating in ghc, etc.
22:28:18 <Ralith> RichiH: 22:19:53 -!- ydo [i=tbe@debian.as] has quit [K-lined]
22:28:21 <Ralith> was that intended?
22:28:31 <mmorrow> , let repeat x = fix (\me -> x : me) in repeat 0
22:28:33 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
22:28:40 <CakeProphet> geezusfreeek:  why not repeat x = x:repeat x
22:28:48 <geezusfreeek> sclv__, i'm looking for something that treats it on a somewhat more semantic level, if that is a reasonable way to word it
22:29:08 <rwbarton> geezusfreeek: maybe you want to look at papers on graph reduction?
22:29:13 <sclv__> the transformations they provide and arguments about them seem useful for reasoning about code more generally -- i.e. times when floating things either in or out is an absolute win.
22:29:47 <geezusfreeek> sclv__, hmm, yes, that may be close to what i'm looking for
22:29:47 <mmorrow> , levels (fix (\me -> Node () [me,me]))
22:29:49 <lunabot>  [[()],[(),()],[(),(),(),()],[(),(),(),(),(),(),(),()],[(),(),(),(),(),(),...
22:30:18 <RichiH> Ralith: no. i unklined the shell, already
22:30:18 <sclv__> is sharing part of the haskell standard? i forget, although it seems somewhat implied by the monomorphism restriction
22:31:00 <sclv__> i.e. if repeat compiled to something unshared, would that be a broken haskell implementation, or just a poor one?
22:31:07 <geezusfreeek> i don't believe it is defined as a part of haskell's semantics
22:31:17 <geezusfreeek> but i haven't checked specifically
22:31:31 <SamB_XP> sclv__: well, if it violated the laws of physics it could even be a decent one
22:31:42 <mmorrow> sclv__: i think it would just be non-efficient and memory intensive
22:31:54 <mmorrow> *more more intensive ;)
22:32:03 <mmorrow> s/more more/more/
22:32:08 <mmorrow> smores!
22:32:15 * mmorrow slowly backs away
22:32:53 <CakeProphet> > fix id
22:32:54 <lambdabot>   * Exception: stack overflow
22:32:56 * SamB_XP trips mmorrow on the way back
22:33:02 <CakeProphet> :3
22:33:58 <rwbarton> > let x = x in x
22:33:59 <CakeProphet> unfortunately Haskell has no way to recognize that id called infinitely on itself is just id
22:34:12 <lambdabot>   thread killed
22:34:13 <rwbarton> did I break it?
22:34:26 <sclv__> CakeProphet: is it really?
22:34:32 <pumpkin> haven't seen centrinia around for a while, I wonder where he went
22:34:32 <geezusfreeek> CakeProphet, the actual definition creates a Cons that points to itself in memory. yours creates an infinite list
22:34:50 <geezusfreeek> (once fully evaluated)
22:35:06 <SamB_XP> geezusfreeek: when does THAT happen ?
22:35:11 * mmorrow throws a seagull at SamB_XP
22:35:34 <CakeProphet> ?src fix
22:35:34 * SamB_XP tosses it on the rocks
22:35:34 <lambdabot> fix f = let x = f x in x
22:35:54 * mmorrow prefers neat
22:36:21 <CakeProphet> geezusfreeek:  wat?
22:36:27 <CakeProphet> there's cons anywhere
22:36:29 <mmorrow> fix f = f (fix f)
22:36:30 <CakeProphet> in that definition
22:36:33 <mmorrow> (alternately)
22:36:42 <CakeProphet> *no cons
22:36:46 <geezusfreeek> CakeProphet, (:) is cons
22:36:48 <sclv__> with a kestrel chaser, maybe?
22:36:52 <mmorrow> , fix . (:) $ 0
22:36:54 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
22:37:01 <mmorrow> ==> fix (0:)
22:37:12 <mmorrow> ==> fix (\me -> 0 : me)
22:37:14 <CakeProphet> geezusfreeek:  (:) is nowhere in fix
22:37:30 <geezusfreeek> CakeProphet, i thought we were talking about the definition of repeat
22:37:31 <CakeProphet> ...oh
22:37:34 <CakeProphet> you're talking about earlier.
22:37:36 <mmorrow> ==> xs = 0 : xs in xs
22:37:57 * jeffwheeler doesn't understand fix at all.
22:38:03 <geezusfreeek> @src fix
22:38:04 <lambdabot> fix f = let x = f x in x
22:38:11 <mmorrow> ==> ... = 0 : (0 : (0 : ... ))
22:38:23 <bmh> can someone recommend a Fractional type for rational numbers?
22:38:24 <jeffwheeler> I see that . . . I don't when one would ever (sensibly) use that.
22:38:25 <CakeProphet> geezusfreeek:   is there any semantc difference in a self-referencing cons and the infinite list version?
22:38:26 * pumpkin is trying to make an awesomely fast UArr sliding entropy now
22:38:30 <jeffwheeler> bmh: Rational?
22:38:39 <mmorrow> jeffwheeler: using it with two args is what turned the light on for me
22:38:45 <bmh> jeffwheeler: n = a/b
22:38:54 <sclv__> one way to think of fix:
22:38:56 <sclv__> ?ty fix (undefined :: (a->b) -> (a->b))
22:38:57 <lambdabot> forall a b. a -> b
22:39:00 <jeffwheeler> ?hoogle Rational
22:39:01 <lambdabot> Prelude type Rational = Ratio Integer
22:39:01 <lambdabot> Data.Ratio type Rational = Ratio Integer
22:39:01 <lambdabot> Text.PrettyPrint.HughesPJ rational :: Rational -> Doc
22:39:06 <rwbarton> > 7686 % 364
22:39:08 <lambdabot>   549%26
22:39:14 <sjanssen> CakeProphet: the difference is undetectable in Haskell '98
22:39:16 <rwbarton> :t 7686 % 364
22:39:17 <CakeProphet> sclv__:  I would say id
22:39:18 <lambdabot> forall t. (Integral t) => Ratio t
22:39:19 <CakeProphet> er.
22:39:20 <bmh> awesome.
22:39:23 <geezusfreeek> CakeProphet, provided that you never update it, the self-referencing cons will only ever take constant memory
22:39:31 <CakeProphet> sclv__:  I would say id (id (id ...))  is id.
22:39:47 <CakeProphet> geezusfreeek:  -nod- and Haskell doesn't let you update it.
22:39:54 <CakeProphet> so yeah.
22:40:03 <mmorrow> jeffwheeler: run this in ghci:
22:40:04 <mmorrow> fix (\go hist -> do {l <- getLine; case l of ":q" -> return (reverse (":q":hist)); _ -> print l >> go (l:hist)}) []
22:40:08 <geezusfreeek> CakeProphet, by "update" i mean in the sense that you make a new list out of pieces of the old
22:40:09 <mmorrow> a repl
22:40:32 <mmorrow> that exact example was the "oh, that's easy" moment for me
22:40:38 <rwbarton> I wonder whether fix or id is more common in actual Haskell code
22:40:42 <CakeProphet> geezusfreeek:  oh... like take 5 (repeat 0)
22:40:44 <geezusfreeek> for example, say you "update" the 100th element of the list. it will have to construct the 99 cons cells preceding the updated one
22:40:52 <sclv__> rwbarton: id for sure!
22:40:59 <geezusfreeek> or that, yes
22:41:02 <CakeProphet> rwbarton:  I didn't know fix has a practical use.
22:41:06 <pumpkin> I can't say I've ever used fix in anything beyond playing with lambdabot
22:41:13 <SamB_XP> I think fix has uses
22:41:22 <rwbarton> OK, fair enough, has anyone besides mmorrow used fix in a real program? :)
22:41:25 <geezusfreeek> i have used fix in actual code, but i use id much more often
22:41:26 <mmorrow> heh
22:41:28 <jeffwheeler> The entire Haskell community has yet to find the use, though. :)
22:41:29 <SamB_XP> but not nearly as many as id
22:41:31 <sclv__> generally I think people go for writing the recursion directly unless they're making a point or being very clever.
22:41:32 <pumpkin> rwbarton: I've seen centrinia do it
22:42:56 <sjanssen> rwbarton: I have used fix in xmonad
22:43:01 <jeffwheeler> So, fix seems to be a way to implement recursion, passing the result to the next time through.
22:43:07 <CakeProphet> const is far more useful than I would have ever imagined when I first saw its definition.
22:43:16 <sclv__> fix should be in the prelude anyway though -- hiding away in Data.Function its no fun
22:43:29 <jeffwheeler> Is my conclusion correct?
22:43:35 <SamB_XP> jeffwheeler: no!
22:43:40 <jeffwheeler> Oh. :(
22:43:48 <SamB_XP> there is no "next time"
22:43:53 <SamB_XP> just ONE time
22:44:06 <SamB_XP> it passes the result to the function
22:44:12 <sjanssen> jeffwheeler: yes, fix can be used for recursion
22:44:22 <geezusfreeek> fix is _the_ way to implement recursion
22:44:28 <pumpkin> you have to be sneaky about it though
22:44:36 <pumpkin> or it'll never return
22:44:36 <jeffwheeler> SamB_XP: wait, what? The result of what, to the function passed to fix?
22:44:54 <SamB_XP> it passes the functions result to the function
22:44:59 <SamB_XP> then returns it
22:44:59 <mmorrow> fix eliminates verbosity in "where go" functions that don't need to pattern match (although if your "where go" function has to pattern match on it's arg, might as well do "where go" since you'll need a case in the fix anyway in that case)
22:45:35 <mmorrow> , fix (\k !m !n -> m : k n (m+n)) 0 1
22:45:35 <ddarius> const is useful practically, fix is not particularly
22:45:37 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
22:45:40 <sclv__> I think "where go" is v. simple and expressive. + it uses less parens, which is itself a win
22:46:00 <mmorrow> , let go !m !n = m go n (m+n) in go 0 1
22:46:01 <lunabot>  luna: Occurs check: cannot construct the infinite type:
22:46:07 <mmorrow> , let go !m !n = m : go n (m+n) in go 0 1
22:46:09 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
22:46:12 <sclv__> if you write with all parens and lambdas it starts to feel very @pl or lispish
22:46:23 <SamB_XP> um
22:46:29 <mmorrow> heh, i've actually grown to like that look
22:46:32 <SamB_XP> @pl doesn't use any lambdas
22:46:32 <lambdabot> doesn't use any lambdas
22:46:33 <mmorrow> although i hated it at first
22:46:35 <geezusfreeek> without a special type rule for fix the type system would be too restrictive to write general recursive functions
22:46:39 <SamB_XP> hehe
22:46:53 <mmorrow> fix == recursive let
22:47:06 <sclv__> SamB_XP: heh i'll grant that.
22:47:07 <CakeProphet> :t fix
22:47:09 <lambdabot> forall a. (a -> a) -> a
22:47:12 <sclv__> by definition even
22:47:31 <mmorrow> @pl \f -> let x = f x in x
22:47:32 <lambdabot> fix
22:47:53 <ddarius> @free fix
22:47:54 <lambdabot> f . g = h . f => f (fix g) = fix h
22:48:13 <SamB_XP> sclv__: yeah.
22:48:17 <rwbarton> @pl fix $ \again -> checkMaskEvent d mask p >>= \more -> when more again
22:48:17 <lambdabot> fix ((checkMaskEvent d mask p >>=) . flip when)
22:48:22 <SamB_XP> I was going to say "that's the point"
22:48:24 <CakeProphet> iterate is more fun than fix.
22:48:31 <bmh> jeffwheeler: Thanks for the Ratio protip. Converting my code is trivial! =D
22:48:39 <SamB_XP> but then I was thinking it might make more sense to say "that's the pointless"
22:48:40 <jeffwheeler> bmh: it's a great one; no problem.
22:48:40 <geezusfreeek> SamB_XP, ridiculous. @pl is free of points
22:48:48 <SamB_XP> but that doesn't really sound right either
22:48:59 <newsham> to iterate is illiterate
22:49:00 <CakeProphet> > fix fix
22:49:01 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a
22:49:01 <lambdabot>      Proba...
22:49:03 <hydo> Does the traditional haskell community wisdom prefer one over the other between hsql and hdbc?
22:49:04 <newsham> to recurse is worse
22:49:20 <sclv__> hydo: hdbc is more actively used and supported
22:49:30 <hydo> sclv__: thanks!
22:49:36 <bmh> I hear couchdb is really great too ;-)
22:49:48 <ddarius> :t \f z -> fix ((z:) . map f)
22:49:49 <lambdabot> forall b. (b -> b) -> b -> [b]
22:49:54 <mmorrow> @type flip fix
22:49:56 <lambdabot> forall b c. b -> ((b -> c) -> b -> c) -> c
22:50:00 <mmorrow> @type (flip . flip) fix
22:50:01 <lambdabot> forall b c. ((b -> c) -> b -> c) -> b -> c
22:50:31 <mmorrow> @type fix :: forall b c. ((b -> c) -> b -> c) -> b -> c
22:50:32 <lambdabot> forall b c. ((b -> c) -> b -> c) -> b -> c
22:50:50 <mmorrow> that's the usage that makes more sense at first i think (to me at least)
22:51:07 <sclv__> @ty fmap fix return
22:51:08 <lambdabot> forall a. a -> a
22:51:12 <pumpkin> mmorrow: that makes a lot more sense
22:51:14 <ddarius> mmorrow: That's because your mind has been corrupted by eager languages.
22:51:20 <mmorrow> , fix (\cont x -> x) 0
22:51:22 <pumpkin> oh no
22:51:22 <lunabot>  0
22:51:25 <geezusfreeek> @pl repeat x = let xs = x : xs in xs
22:51:25 <lambdabot> repeat = fix . (:)
22:51:37 <mmorrow> ddarius: heh, but now i am free!
22:51:46 <ddarius> @free mmorrow
22:51:48 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `mmorrow'\n\n"
22:51:52 <geezusfreeek> heh
22:51:56 <mmorrow> , levels (fix (\me -> Node () [me,me]))
22:51:58 <lunabot>  [[()],[(),()],[(),(),(),()],[(),(),(),(),(),(),(),()],[(),(),(),(),(),(),...
22:52:01 <mmorrow> , levels (fix (\me -> Node () [me,me,me]))
22:52:02 <SamB_XP> @devils free
22:52:03 <lambdabot> No match for "free".
22:52:05 <lunabot>  [[()],[(),(),()],[(),(),(),(),(),(),(),(),()],[(),(),(),(),(),(),(),(),()...
22:52:12 <mmorrow> , flatten (fix (\me -> Node () [me,me]))
22:52:14 <SamB_XP> @devils liberty
22:52:14 <lunabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
22:52:15 <lambdabot> *** "LIBERTY" devils "THE DEVIL'S DICTIONARY ((C)1911 Released April 15 1993)"
22:52:15 <lambdabot> LIBERTY, n.  One of Imagination's most precious possessions.
22:52:15 <lambdabot>  
22:52:15 <lambdabot>     The rising People, hot and out of breath,
22:52:15 <lambdabot>     Roared around the palace:  "Liberty or death!"
22:52:16 <jeffwheeler> That repeat definition is awesome.
22:52:16 <lambdabot> [4 @more lines]
22:52:20 <SamB_XP> @more
22:52:20 <lambdabot>     "If death will do," the King said, "let me reign;
22:52:21 <lambdabot>     You'll have, I'm sure, no reason to complain."
22:52:23 <lambdabot>                                                       Martha Braymance
22:52:25 <lambdabot>  
22:52:26 <sclv__> @free mmorrow :: (a -> a) -> a
22:52:27 <lambdabot> f . g = h . f => f (mmorrow g) = mmorrow h
22:52:32 <jeffwheeler> @src repeat
22:52:33 <lambdabot> repeat x = xs where xs = x : xs
22:52:34 <pumpkin> lol
22:52:38 <mmorrow> nice, lunabot's machine is less sluggish today
22:52:50 <mmorrow> sclv__: heh
22:53:12 <sclv__> ^^ fixed it
22:53:17 <sclv__> :-P
22:53:33 <geezusfreeek> > fix (1:)
22:53:34 <ddarius> The free theorem for that type actually uniquely defines the function.
22:53:35 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
22:54:50 <sclv__> @djinn (a -> a) -> a
22:54:50 <lambdabot> -- f cannot be realized.
22:54:57 <jeffwheeler> let p v = print $ take 100 $ show $ v -- super handy in GHCi
22:55:01 <sclv__> bah
22:55:05 <jeffwheeler> Except no v is necessary, obviously.
22:55:39 <geezusfreeek> why the p?
22:55:42 <sclv__> jeffwheeler: I prefer the just smack ctrl-c really quickly method of printing initial segments of infinite structures..
22:56:02 <sjanssen> sclv__: usually it takes ghci a while to respond to ctrl-c
22:56:04 <jeffwheeler> geezusfreeek: abbreviation of 'print' :)
22:56:16 <sclv__> its like terminal history roulette :-)
22:56:27 * geezusfreeek sides with sclv__'s way
22:56:27 <scook0> it usually clobbers your scrollback too
22:56:29 <bmh> Data.Ratio wins: 1.9359513991901167e-14 has become 0%1. Hurrah!
22:57:02 <geezusfreeek> > 1.9359513991901167e-14 :: Rational
22:57:03 <lambdabot>   19359513991901167%1000000000000000000000000000000
22:57:32 <bmh> I was having precision problems that Ratio cured.
22:57:53 <geezusfreeek> oh, you _wanted_ 0%1, i get it now
22:58:43 <Olathe> > fix fix
22:58:44 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a
22:58:44 <lambdabot>      Proba...
22:58:52 <bmh> > :t fix
22:58:53 <lambdabot>   <no location info>: parse error on input `:'
22:58:54 <Olathe> > fix (fix (1:))
22:58:55 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `[t]'
22:58:59 <CakeProphet> @let (*$) _ 0 = id; ($*) f n = f . (f *$ (n-1))
22:59:01 <lambdabot>  Defined.
22:59:10 <Olathe> > fix ((fix (1:)):)
22:59:12 <lambdabot>   [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
22:59:45 <bmh> fix (+ 1)
22:59:50 <bmh> > fix (+ 1)
22:59:51 <newsham> heh, neat, sigfpe embedded expressions in monads.
23:00:06 <lambdabot>   thread killed
23:00:18 <geezusfreeek> :t (*$)
23:00:20 <lambdabot> forall t t1 a. (Num t1) => t -> t1 -> a -> a
23:00:31 <pumpkin> "The goal today is to implement an impossible Haskell function."
23:00:33 <geezusfreeek> wha-?
23:00:48 <bmh> 'on', there's one I haven't used before
23:01:01 <newsham> ?type \broken x -> if ?broken ?x then fix ?x else ?x
23:01:02 <lambdabot> Top level:
23:01:02 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
23:01:02 <lambdabot>       Expected type: a -> a
23:01:08 <mmorrow> > fix (\again f x-> x : again (f x)) (+1) 0
23:01:09 <lambdabot>       Occurs check: cannot construct the infinite type: t = a -> t
23:01:09 <lambdabot>      Proba...
23:01:16 <mmorrow> > fix (\again f x-> x : again f (f x)) (+1) 0
23:01:18 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
23:01:45 <newsham> ?type on (+)
23:01:47 <Olathe> > let f f' = fix (f':) in f (fix (1:))
23:01:47 <lambdabot> forall b a. (Num b) => (a -> b) -> a -> a -> b
23:01:47 <mmorrow> > fix (\again f x-> if 10 < x then [] else x : again f (f x)) (+1) 0
23:01:48 <lambdabot>   [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:01:49 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10]
23:01:54 <CakeProphet> (+3) *$ 10 5
23:02:00 <CakeProphet> > (+3) *$ 10 5
23:02:00 <Olathe> > let f f' = fix (f':) in fix f
23:02:02 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
23:02:02 <lambdabot>        Expect...
23:02:02 <lambdabot>       Overlapping instances for Show (a -> a)
23:02:02 <lambdabot>        arising from a use of `s...
23:02:30 <ozy`> :t (*$)
23:02:31 <lambdabot> forall t t1 a. (Num t1) => t -> t1 -> a -> a
23:02:32 <CakeProphet> oh...
23:02:38 <CakeProphet> lolwhoops
23:02:43 <newsham> > ((+) `on` snd) ('c',5) ('d',1)
23:02:45 <lambdabot>   6
23:02:50 <CakeProphet> @let ()
23:02:50 <Olathe> > let f f' = f $ fix (f':) in f 1
23:02:50 <lambdabot>   Parse error
23:02:51 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
23:02:52 <lambdabot>        Expect...
23:02:53 <CakeProphet> ..
23:04:39 <CakeProphet> @let ($*) _ 0 = id; ($*) f 1 =f;  ($*) f n = f $ f $* pred n
23:04:40 <lambdabot>  <local>:10:44:
23:04:40 <lambdabot>      Occurs check: cannot construct the infinite type: a = a ...
23:07:17 <CakeProphet> > (+3) *$ 10 5
23:07:18 <lambdabot>       Overlapping instances for Show (a -> a)
23:07:18 <lambdabot>        arising from a use of `s...
23:08:14 <CakeProphet> @let ($*) _ 0 = id; ($*) f 1 =f;  ($*) f n = f . (f $* (pred n))
23:08:16 <lambdabot>  <local>:9:15:
23:08:16 <lambdabot>      Warning: Pattern match(es) are overlapped
23:08:16 <lambdabot>               I...
23:09:40 <CakeProphet> > (+3) $* 10 0
23:09:42 <lambdabot>       Overlapping instances for Show (a1 -> a1)
23:09:42 <lambdabot>        arising from a use of ...
23:10:16 <CakeProphet> > ((+3) $* 10) 0
23:10:18 <lambdabot>   * Exception: <local>:9:0-12: Non-exhaustive patterns in function *$
23:10:51 <rwbarton> Yeah, 12 minutes ago you made some $* vs. *$ typos
23:11:07 <CakeProphet> ...oh
23:11:24 <CakeProphet> oh well
23:11:26 <rwbarton> You probably want...
23:11:30 <rwbarton> @undefine ($*)
23:11:32 <rwbarton> @undefine (*$)
23:11:51 <rwbarton> @let ($*) _ 0 = id; ($*) f 1 =f;  ($*) f n = f . (f $* (pred n))
23:11:52 <lambdabot>  Defined.
23:11:52 <sclv__> undef is still global i thought?
23:11:57 <CakeProphet> I thought lambdabot had to get rid of everything?
23:12:00 <rwbarton> is it?
23:12:01 <rwbarton> Could be
23:12:15 <rwbarton> :t (<^)
23:12:16 <lambdabot> Not in scope: `<^'
23:12:18 <rwbarton> :(
23:12:26 <CakeProphet> > ((+3) $* 10) 0
23:12:27 <lambdabot>   30
23:12:30 <sclv__> oh no, not the batsignals!
23:12:31 <CakeProphet> yay!
23:13:02 <mae> hola HASKELLITES
23:13:21 <CakeProphet> I'm going to implement a web browser in Haskell... in which /every/ function is an operator
23:13:39 <CakeProphet> Perl hackers will be jealous of my might.
23:17:07 <CakeProphet> > map (join map) [x,y,z]
23:17:09 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a]'
23:17:22 <CakeProphet> :t join map
23:17:23 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a]'
23:17:23 <lambdabot>       Expected type: (a -> b) -> (a -> b) -> a1
23:17:23 <lambdabot>       Inferred type: (a -> b) -> [a] -> [b]
23:17:49 <newsham> sigfpe's blog is on a roll
23:18:35 <mmorrow> @go sigfpe
23:18:56 <lambdabot> http://en.wikipedia.org/wiki/SIGFPE
23:18:56 <lambdabot> Title: SIGFPE - Wikipedia, the free encyclopedia
23:18:56 <mmorrow> > 42
23:18:56 <lambdabot>   42
23:19:05 <mmorrow> heh, i shoulda know
23:19:06 <mmorrow> n
23:19:33 * CakeProphet wishes lambdabot allowed datatypes
23:20:09 <CakeProphet> and classes and typeclasses.
23:20:14 <CakeProphet> er.
23:20:16 <CakeProphet> instances
23:20:18 <CakeProphet> and typeclasses.
23:21:47 <mmorrow> CakeProphet: me too. i tried to see how hard this would be to add to ghci, but the ghc datatypes are like you pull this tiny string and it keeps unravelling and unravelling and you eventually find that it's connected to everything, including your finger from the opposite way you'd think
23:22:07 <mmorrow> so i've "put that on hold" until the horror wears off
23:22:33 <newsham> ?let data TestThis = Test1 | Test2 deriving Show; f Test1 = 1; f Test2 = 2
23:22:34 <lambdabot>  Invalid declaration
23:23:12 <mmorrow> and ghci is hardwired (the byecode compiler in some way i can't friggin figure out) to compile:
23:23:21 <mmorrow> literal ==> print literal
23:23:40 <mmorrow> exp :: IO a ==> exp :: IO a     (no change)
23:23:50 <mmorrow> and about 4 other rules
23:24:13 <jeffwheeler> The fix definition provided here makes much more sense to me: http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion
23:24:55 <mmorrow> and the function to compile to byecode only exist for "statements" and "expression", neither of which include datas or classes. so there isn't even a direct path (other than loading an entire module) to add datas and/or classes like you would expressions
23:25:27 <mmorrow> so in a nutshell, you'd have to touch pretty much every single part of the compiler
23:25:36 <mmorrow> !
23:25:56 <rwbarton> But what about some hack, like  @let data Foo = Foo
23:26:05 <mmorrow> exactly :(
23:26:20 <mmorrow> the easiest ways i see to do it are:
23:26:28 <mmorrow> (all of which are "hacks")
23:27:59 <newsham> "you can view the codensity monad as the right Kan extension of a functor along itself."
23:28:06 <mmorrow> (1) keep a "current module" of the abstract syntax (HsSyn, ie one-level from txt code), and when you add a data, add its AST to the current module's AST, then pretty print that to a temp file, and transparently reload the "current module", which would simulate just defining that data and preserving all other bindings
23:28:21 <newsham> just when you think sigfpe's blog is mind bending, someone comes along and ups the ante
23:29:15 <mmorrow> (2) pending finding some way to construct a "TyCon", you can extend the "ITableEnv" of the byecode linker to just magically have that new datatype be in scope (no typechecking happens this way....)
23:29:59 <mmorrow> and anything other way i don't know enough about all the moving parts to even know how it would be done
23:30:02 <Saizan_> mmorrow: there's no way to let it interpret the AST directly?
23:30:16 <mmorrow> it compiles the AST:
23:31:42 <mmorrow> .hs -> HsSyn RdrName -> HsSyn Name -> Core -> Core -> CompiledByteCode -> UnlinkedByteCode -> LinkedByteCode -> IO (side-effect the heap)
23:31:49 <mmorrow> or something along those lines
23:31:51 <mmorrow> it's epic
23:32:00 <Ralith> mmorrow: what's he doing?
23:32:22 <mmorrow> Ralith: me or Saizan?
23:32:38 <mmorrow> Saizan_: so to actually answer your question, i don't know :)
23:32:53 <mmorrow> but not interpreting byecode would be super slow
23:32:57 <mmorrow> *bytecode
23:33:05 <mmorrow> and you'd lose all sharing, etc..
23:33:10 <Ralith> mmorrow: the stuff you just described -- bear in mind I'm new to haskell, so you'll have to put it simply.
23:33:33 <Ralith> an interpreter?
23:34:12 <mmorrow> Ralith: i was trying to learn enough about the src -> byecode pipeline in ghc to be able to add the ability to create new data/class/etc declarations at the ghci prompt just like you do for expressions
23:34:27 <mmorrow> and i was not victorious :)
23:34:27 <Ralith> ah, cool!
23:34:30 <Ralith> aw.
23:34:40 <Saizan_> mmorrow: no, i meant without going via the prettyprinted temp file, but rather make it load the HsSyn or whatever you've
23:34:54 <mmorrow> i learned 100x more than a lot in the process though (and wrote lunabot) :)
23:34:54 <Ralith> don't give up; that sounds like lots of fun to have.
23:34:58 <Ralith> heh
23:35:13 <jeffwheeler> @src fix
23:35:14 <lambdabot> fix f = let x = f x in x
23:35:39 <mmorrow> Ralith: totally. i'm not quitting, just re-assessing the route to a solution :)
23:36:03 <Ralith> yay!
23:36:19 <mmorrow> Saizan_: oh yeah, totally. you could do that too i'm sure without too much extra trouble (i just mentioned via-a-tmp-file as the path of least resistance)
23:37:10 <mmorrow> Saizan_: i think (1) is actually feasible and wouldn't be super hard. also, it ensures everything is typechecked/consistent/etc at all times
23:37:59 <mmorrow> and you could even write the "current module" to disk and get something like .ghci_history, but instead of lines of txt it'd be the AST of what you just did
23:38:47 <Saizan_> the problem is that you'd lose the currently defined bindings, right? like :load in ghci
23:39:12 <mmorrow> but the beatiful part of this is that you're maintaining those at all times in the "current-module"
23:39:44 <Saizan_> yeah, you can put everything there and not just instances/types
23:39:47 <mmorrow> so the analogy would be:  StateT HsModule IO a
23:39:52 <mmorrow> exactly
23:40:38 <mmorrow> and :m + Foo  would add an import line, etc..
23:40:48 <Saizan_> it's a bit problematic to handle shadowing
23:41:10 <mmorrow> yeah, there ae definitely a few things that'd need to be worked out
23:41:14 <rwbarton> shadowing of types, you mean?
23:41:21 <Saizan_> even values
23:41:22 <mmorrow> both
23:41:55 <mmorrow> you'd have to have a non-naive method of merging a new decl/exp/whatever into the current module
23:42:17 <Saizan_> in ghci: let x = foo; let y = x; let x = bar -> now y == foo, x == bar
23:42:27 <mmorrow> you'd probably need to also maintain a dep graph of each decl, etc ..
23:42:42 <mmorrow> since if you have
23:42:47 <mmorrow> f = foo y
23:42:52 <mmorrow> and you re-define y
23:43:07 <mmorrow> then f sees the /new/ y, since we're constantly reloading this module
23:43:30 <mmorrow> so that's where how this would behave would be radically different
23:43:55 <rwbarton> Hmm, I guess I was imagining you'd simulate the current behavior somehow, but I don't know how exactly
23:44:23 <Saizan> refreshing values with new definitions of free variables can be a nice feature
23:44:24 <mmorrow> yeah, me neither. but i agree, there should be some way to do this.
23:44:37 <rwbarton> module M12375 where  import M12374 hiding (y); y = 42   -- :)
23:44:56 <mmorrow> Saizan: but what if (f = foo y), the new `y' is of a completely diff type?
23:45:05 <mmorrow> and f doesn't typecheck anymore
23:45:06 <nolrai_East> @pl \(x1,y1) (x2, y2) -> abs (x1 - x2) + abs (y1 - y2)
23:45:07 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. ((abs .) . (-))) . flip . (((.) . (+) . abs) .) . (-))
23:45:24 <nolrai_East> hmm
23:45:26 <Saizan> mmorrow: yeah, it should be an explicit choice from the user
23:46:01 <mmorrow> Saizan: that's a good idea. behavior is controllable with a :set or something
23:46:10 <rwbarton> mmorrow: you can simulate the current behavior by putting each definition in its own module like I wrote above
23:46:25 <mmorrow> oh, nice i missed that
23:46:34 <mmorrow> yeah, that would actually do it i think
23:46:49 <mmorrow> heh, ok so you'd need to have something like
23:47:12 <rwbarton> M12375 is supposed to reexport M12374, I don't remember whether that happens by default
23:47:14 <mmorrow> StateT (Graph (Module, Graph Decl)) IO a
23:48:00 <mmorrow> (or something equivalent to this i think)
23:48:15 <Saizan> then :info y gives me -- defined in M12374 ? :)
23:48:35 <rwbarton> Yeah, well :)
23:48:44 <rwbarton> I bet you could implement this as a purely textual wrapper around ghci
23:48:52 <mmorrow> yeah, :m, :info, :load, :r would all need to be redefined
23:49:05 <rwbarton> I don't know how it would interact with those commands
23:49:24 <rwbarton> Saizan: and if you want to change your mind about y, you can edit M12374.hs
23:49:28 <rwbarton> (maybe)
23:50:03 <mmorrow> hmm, i think a textual wrapper would be tough, since you can't control ghc
23:50:35 <rwbarton> you can implement this with ghci, by writing files and loading them
23:50:41 <mmorrow> i dunno though, yeah
23:51:12 <mmorrow> i think you may be able to. the only thing though is that you'd need to parse the .hs files still, and be able to ..
23:51:14 <mmorrow> oh wait
23:51:33 <mmorrow> your idea is that /every/ new exp/decl/etc foes into its /own/ module?
23:51:38 <mmorrow> *goes
23:51:42 <rwbarton> yes
23:52:00 <mmorrow> ahhh, ok. yeah that sounds like it'd work i think
23:52:25 <rwbarton> That's why the number was so big :)
23:52:29 <mmorrow> (suboptimal, but more than nothing indeed)
23:52:37 <mmorrow> heh, i was wondering about those numbers
23:52:59 <rwbarton> Well, expressions you can just evaluate and print
23:53:32 <mmorrow> you'd still need to retain them in a module though, since you'll need to do a :reload for every data/class decl
23:53:59 <rwbarton> I need to retain definitions of top-level values
23:54:20 <mmorrow> so you're not counting "let x = 42" as toplevel?
23:54:29 <rwbarton> that I am, but not just "42"
23:54:32 <CakeProphet> what would be the problem with appending them to a file?
23:54:33 <mmorrow> ohh
23:54:38 <mmorrow> totally
23:54:42 <rwbarton> Well, I think the syntax would become just "x = 42"
23:54:49 <rwbarton> not sure
23:55:03 <mmorrow> any names that are bound would be a way to say it i guess
23:55:23 <rwbarton> Anyways, maybe I will have a go at it tomorrow
23:56:00 <CakeProphet> wait, are you talking about implement data, class, and instance for lambdabot?
23:56:06 <CakeProphet> +ing
23:56:16 <Saizan> the upside is that loading new modules doesn't reset the bound values in the session
23:56:30 <mmorrow> yeah, that's be a huge plus
23:56:47 <mmorrow> CakeProphet: for ghci
23:56:57 <araujo> hello
23:57:14 <mmorrow> but i think i'd still wanna go the via-ghc-api/ghci-internals route
23:57:30 <mmorrow> that way lunabot/lambdabot etc could do it too
23:57:33 <vixey> hi
23:57:37 <mmorrow> hi
23:58:12 <mmorrow> rwbarton: awesome! go for it. i'd love to help.
23:58:18 <CakeProphet> if each @let in lambdabot made a seperate module it would be simple to make @undefine work on names.
23:58:53 <vixey> anyone did a stress test with hundreds of modules?
23:59:07 <mmorrow> vixey: the time is ripe ;)
23:59:52 <Saizan> hundreds of temp files..
