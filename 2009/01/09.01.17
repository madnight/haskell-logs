00:00:07 <Cale> I suppose -- the representation as functions is not strictly necessary though.
00:00:12 <ivanm> *nod*
00:00:18 <Cale> You could, instead, choose to write something like:
00:00:25 <Cale> data State s a where
00:00:40 <Cale>   ReturnS :: a -> State s a
00:00:56 <Cale>   BindS :: (State s a) -> (a -> State s b) -> State s b
00:01:03 <Cale>   GetS :: State s s
00:01:05 <ivanm> Cale: is that valid? since when can you have a where statement in a data definition?
00:01:10 <Cale>   PutS :: s -> State s ()
00:01:15 <dolio> Since GADTs.
00:01:16 <Cale> ivanm: This is a GADT.
00:01:20 <ivanm> ahhhhh
00:01:34 * ivanm doesn't think he's seen them before, hence the confusion
00:01:35 <PumpkinM> I prefer to see myself as a container than a computation: return candle :: PumpkinM Candle
00:02:02 <Cale> ivanm: It just lets you write the types of the data constructors explicitly, basically.
00:02:24 <ivanm> as opposed to: data State s a = ReturnS (a -> State s a) | ... ?
00:02:37 <dmwit> Well... the interesting bit is that the final (return) type need not be quite so polymorphic as the data declaration, right?
00:02:53 <ivanm> dmwit: hmmm?
00:02:59 <dmwit> ivanm: No, as opposed to data State s a = ReturnS a | ...
00:03:01 <Cale> Well, I need the little bit of extra freedom this gives, but it would be  ReturnS a  for the first constructor
00:03:10 <ivanm> dmwit: ahhh
00:03:14 <ivanm> *nod*
00:03:17 <Cale> BindS simply can't be written in the old notation
00:03:18 <ivanm> I get you now
00:03:26 <ivanm> *nod*
00:03:39 <ivanm> is this official haskell, or a ghc extension?
00:03:46 <dmwit> It's an extension.
00:03:51 <dolio> BindS is just existential.
00:04:00 <dolio> GetS and PutS are the GADT ones.
00:04:19 <Cale> So instead of  runState (State s) x = s x, we'll now have something which interprets this abstract syntax for our State language.
00:04:30 <ivanm> *nod*
00:05:52 <Cale> runState (ReturnS v) s = (s,v); runState (BindS x f) s = let (s',v) = runState x s in runState (f v) s'
00:05:56 <dmwit> I've just been learning about phantom types... which are also kind of neat, and fall just a bit short of GADTs.
00:06:07 <Cale> runState GetS s = (s,s)
00:06:22 <Cale> runState (PutS s') s = (s',())
00:06:33 <dmwit> You can end up writing a function which pattern matches on constructors from different types... weird.
00:07:06 <ivanm> dmwit: :o
00:08:09 <ivanm> dmwit: almost like pattern matching on the class level kind of thing? (if it's this instance, do that, etc.)
00:08:44 <dmwit> Kind of, yeah!
00:09:07 <dmwit> In fact, in the paper I was reading, Hinze was using phantom types as an alternative to classes.
00:09:13 <ivanm> *nod*
00:09:21 <dmwit> A pretty bad alternative, really, but an interesting idea nonetheless. =)
00:09:52 <ivanm> though off the top of my head, I'd think that'd make it harder to have "instances".... can you extend the definition of such a function in your own code?
00:10:15 <ivanm> dmwit: so how do the type sigs for such functions look?
00:10:27 <ivanm> you'd have to constrain which types you actually have matches for _somehow_, wouldn't you?
00:11:07 <sleven> if i need to nest 3 for loops, using forM and return works right?
00:11:21 <ivanm> sleven: ummmm..... what?
00:11:56 <sleven> and quicksilver: is this: get (Matrix2 m) = m , necessary to patternmatch out the 2darray from the Matrix?
00:12:06 <sjanssen> sleven: usually nested for loops mean you're going about it wrong, but not necessarily
00:12:06 <dmwit> sleven: I guess.  You should really re-examine what you're doing, though, if you need that.
00:12:13 <dmwit> sleven: It's really uncommon.
00:12:18 <dmwit> ivanm: Yes, instances are harder.
00:12:26 <sleven> i multiply 2 matrices
00:12:31 <sleven> really simple in java
00:12:33 <sleven> i post
00:12:35 <PumpkinM> sleven: strassen!
00:12:36 <PumpkinM> ;)
00:12:46 <PumpkinM> ~2.7 is better than 3 :P
00:13:06 <sleven> http://hpaste.org/14008
00:13:13 <PumpkinM> but apparently there's a better one too :)
00:13:14 <dmwit> ivanm: The way Hinze went about it, you have a data type that represents types (with a constructor for each "interesting" type); introducing a new "instance" involves adding a constructor.
00:13:20 <sjanssen> a litte bit better than forM xs $ \x -> forM ys $ \y -> forM zs $ \z -> ... is forM (liftM3 (,,) xs ys zs) $ \(x, y, z) -> ...
00:13:23 <ivanm> dmwit: ahhhhh
00:13:24 <sleven> there is some java code there thta shows whta i want to do
00:13:48 <ivanm> sleven: what datatype are you using for your matrices?
00:13:53 <PumpkinM> sleven: isn't it easier to break it down into maps of dot products over columns and rows?
00:14:06 <ivanm> I would question why you're doing it in a monadic form...
00:14:10 <ivanm> zip ftw! ;-)
00:14:12 <dmwit> ivanm: So you get something like (eq :: Type t -> t -> t -> Bool) or so.
00:14:19 <sjanssen> sleven: are you actually working with a mutable type here?
00:14:21 <ivanm> dmwit: *nod*
00:15:10 <PumpkinM> http://en.wikipedia.org/wiki/Coppersmith–Winograd_algorithm
00:15:19 <sleven> ivanm: listArray
00:15:39 <sleven> (2darrays or cleverly indiced 1darrays as quicksilver put it)
00:15:41 <sjanssen> sleven: ah, listArray
00:15:49 <sjanssen> sleven: you don't want for loops at all here
00:16:07 <dmwit> Yeah, definitely not.
00:16:15 <dmwit> I like the list comprehension thing you're trying.
00:16:47 <sjanssen> sleven: the tricky bit is that you need a nested list comprehension, with a 'sum' applied to the inner one
00:17:51 <sjanssen> [ ... | i <- [0 .. rows - 1], j <- [0 .. cols - 1]] -- solve for ... :)
00:19:03 <sleven> well i did setAt i j before
00:19:14 <sleven> but that created loads of matrices instead of one(naturally)
00:19:51 <dmwit> Yeah, you don't want to try to do this by updating each element.
00:21:24 <sjanssen> sleven: does it help if I tell you that '...' starts out '((i, j), sum ..)'?
00:25:39 <sleven> sjanssen: a little im tyring
00:35:16 <sleven> sjanssen: no i dont see it, reall ((i,j), sum?
00:36:30 <PumpkinM> what does     Kind error: `m' is applied to too many type arguments mean?
00:36:46 <PumpkinM> I don't have any constraints on m, so I'm not sure how it decides how many arguments is too many on its kind
00:37:25 <dmwit> Do you use it twice in the type signature?
00:37:57 <PumpkinM> oh, maybe, hmm
00:41:03 <sjanssen> sleven: yep
00:42:16 <sjanssen> sleven: notice that in the Java version, you've got "arr[i][j] += ...", ie. the innermost loop is only working on on cell at a time
00:43:46 <sleven> yes and thats what I cant replicate in haskell.
00:43:56 <sleven>  [((i,j), sum ((getAt m1 i k) * (getAt m2 k j)))  is not at all correct
00:45:03 <sleven> i need a list to sum over.
00:45:22 * dmwit notes that there are two lists in scope at that point
00:45:40 <dmwit> We also have many functions for combining lists...
00:45:45 <dmwit> ?hoogle [a] -> [a] -> [a]
00:45:46 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
00:45:46 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
00:45:46 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
00:46:06 <dmwit> :t (zip, zipWith)
00:46:07 <lambdabot> forall a b a1 b1 c. ([a] -> [b] -> [(a, b)], (a1 -> b1 -> c) -> [a1] -> [b1] -> [c])
00:51:17 <sjanssen> sleven: you need another list to pass to sum
00:51:32 <sjanssen> sleven: a list comprehension within a list comprehension is allowed
00:52:49 <sleven> hmm I could filter by coordinates o perhaps
00:53:22 <sjanssen> no need to filter
00:54:35 <Taejo> "Although i have this minor objection with lispers using the lambda symbol, but overall i think the lispers and i share a more important common goal. That is, to kill all imperative programing ignoramuses of the world. Once the unix and C and Perl and otherwise idiots are all dead, then i'll formally raise my objection about Lisper's unfit borrowing of the lambda symbol."
00:55:13 <sleven> lol
00:55:17 <sleven> who said that?
00:55:30 <Taejo> Xah Lee (http://xahlee.org/)
00:57:37 <sleven> sjanssen: but is the first three listcomprehensiosn correct? i need to do away with those no and nest them instead?
00:57:56 <PumpkinM> whee
00:58:04 <PumpkinM> I have succeeded a tiny bit
01:01:37 <grom358> > reverse "olleh"
01:01:38 <lambdabot>   "hello"
01:01:54 <dolio> @quote xahlee
01:01:54 <lambdabot> xahlee says: note to readers: i'm not just interested in functional programing, i'm the world's top expert
01:01:59 <pumpkin> I can sort of call Data.Maps as functions now
01:02:16 <pumpkin> :P
01:02:31 <pumpkin> my life is now complete
01:02:55 <dmwit> dolio: I consider myself warned fair and square.
01:04:52 <pumpkin> what's a good typeclass name for something that's can be thought of as a function
01:04:53 <pumpkin> ?
01:05:55 <sleven> is xahlee just a troll or he is skilled too?
01:05:57 <pumpkin> (and separately, a good typeclass name for something that can be thought of as a function, for which there also exists an identity under function composition?)
01:06:16 <pumpkin> I feel like I'm reinventing arrows somehow
01:06:19 <grom358> @pumpkin, Functor? i got no idea
01:06:19 <lambdabot> Unknown command, try @list
01:06:37 <jkff> pumpkin: Morphism?
01:06:39 <grom358> naming is hard
01:06:55 <pumpkin> I guess I could take advantage that they chose to call Arrows Arrows and use Morphism :P
01:07:05 <jkff> However then you're going to reinvent categories
01:07:09 <pumpkin> yeah
01:07:36 <pumpkin> but I don't want to necessarily require an identity morphism
01:07:45 <sleven> sjanssen: i can do (i,j,k) and get al the indices then do if i == j the whole i,j += i,k * k,j thing. but i dont see a simple elegant way of doing it
01:07:48 <pumpkin> (or that would prevent my Map instance)
01:08:22 <sjanssen> sleven: there is no += in Haskell
01:08:22 <jkff> pumpkin: Why?
01:08:38 <pumpkin> jkff: because it'd be hard to make an identity Map
01:08:52 <pumpkin> because it would have to contain all elements in its domain
01:08:58 <pumpkin> in its domain type, that is
01:09:25 <pumpkin> I could make one for enumerable domains, but it would still be monstrously inefficient
01:09:41 <pumpkin> I plan to make a WrappedMap or something similar to allow for more flexibility there :P
01:09:51 <jkff> Yes, that's what I was going to suggest :)
01:09:58 <pumpkin> but still
01:10:38 <pumpkin> you think this need for a category minus the identity moprhism is pretty Map-specific? I can't really think of somewhere else I'd need it, but I don't want to impose restrictions!
01:10:51 <sleven> sjanssen: no but i could do something equivalent
01:11:00 <sjanssen> sleven: think about how you would perform the multiplication if you were using pen and paper
01:11:03 <pumpkin> I mean, Map and IntMap!
01:11:08 <pumpkin> that's two possible cases!!
01:11:13 <pumpkin> ;)
01:11:17 <sleven> but what do i need to do, nest 3 listcomprehernsiosn and then a way to do ((i,j) sum ...) over that?
01:11:33 <sjanssen> sleven: nest two comprehensions
01:11:38 <jkff> Hm. I need to think about that, it looks like an instance for Map is hiding somewhere around
01:11:56 <sjanssen> sleven: you'll have one outside sum, and one inside sum
01:12:03 <jkff> (However one of my thoughts has been rejected by the Yoneda Lemma)
01:12:22 <pumpkin> jkff: well, I made an Enumerable typeclass that actually does Enum right... so I could impose an Enumerable constraint on the domain of the Map
01:12:24 <jkff> (I was going to consider maps as operators on maps)
01:12:31 <Saizan_> pumpkin: why did you thought of using a typeclass? (just curiosity)
01:12:44 <pumpkin> Saizan_: for what?
01:12:56 <jkff> I don't think Enum is the way to go here.. It contradicts the underlying math
01:13:12 <pumpkin> jkff: yeah, it's more of a practical thing :)
01:13:14 <Saizan_> pumpkin: for Maps as "Morphisms"
01:13:37 * jkff leaves for a while
01:13:46 <Cale> jkff: What was rejected by the Yoneda lemma?
01:13:52 <Cale> oh
01:13:59 <moozilla> so, I finally understand monads, what's next?
01:14:02 <pumpkin> Saizan_: mostly just for the fun of it... I just wanted to see if I could treat Maps like functions
01:14:16 <pumpkin> Saizan_: and what else I could treat as a function
01:14:25 <pumpkin> so I made a typeclass out of it
01:14:44 <Saizan> ah, i see :)
01:14:45 <pumpkin> I can trivially do it with maps just by doing (mapInstance!) and using that as a function
01:14:47 <pumpkin> but I wanted it more general
01:14:51 <pumpkin> so I used ? instead :P
01:15:07 <pumpkin> and took the RMonad principle and made my own typeclass with the ? method
01:15:35 <pumpkin> I get the feeling this will all be completely useless, but it's fun to play around with
01:16:22 <Saizan> yeah, i've found that it is :)
01:16:57 <pumpkin> so yeah, I'm reinventing the wheel here, I guess
01:17:05 <pumpkin> but arrow didn't allow restricted arrows
01:17:09 <Saizan> (i asked because lately i'm interested in module systems/abstraction mechanisms)
01:18:56 <sleven> sjanssen: the whole list comprehension thing is so backwards,i cant thnk this way
01:19:35 <sjanssen> sleven: it's just like a for loop
01:20:40 <pumpkin> there, I defined >>>> and <<<< on my pseudocategories
01:20:42 <pumpkin> lol
01:22:49 <pumpkin> now I can "compose" maps easily
01:23:06 <pumpkin> of course, the composition is no longer a map, which is kinda ugly
01:25:01 <sleven> sjanssen: mul m1 m2 = [(i,j) | i <- [0..rows m1-1], j <- [0..cols m2-1]] , that results ina ll the indices for the new matrix, the product of m1 and m2
01:25:03 <pumpkin> I wish it were possible for Data.Map to be lazy :P
01:25:06 <pumpkin> that would solve all my problems
01:31:23 <sleven> sjanssen: hmm i think i have it
01:31:33 <sleven> i have the indices and their correct values
01:32:58 <sleven> are bytestrings in ghc 6.10.1 by default?
01:33:16 <sjanssen> yes
01:39:14 <dolio> pumpkin: The problem is, you want memoized functions, and you're trying to use a finite map data structure instead of a library for memoized functions.
01:39:23 <pumpkin> nope
01:39:48 <pumpkin> I'm really just playing around with the idea of using different things as functions
01:40:36 <pumpkin> so I've wanted in the past a way of marking the inverse of a function
01:40:57 <pumpkin> I can sort of do that somewhat elegantly here
01:41:12 <pumpkin> well, not exactly elegantly yet
01:41:16 <mmorrow> if you want to treat Map as functions, you need to do something like this:
01:41:40 <mmorrow> data a:->b where M :: (Ord a, Ord b) => Map a b -> (a :-> b)
01:42:08 <Raevel> pumpkin: http://code.haskell.org/shsh/ <-- did you see this? you were the one talking about something like it, right?
01:42:10 <mmorrow> then you can compose them on account of requiring both `a' /and/ `b' to be ORd
01:42:10 <pumpkin> am I allowed to do a data definition like that? :o
01:42:19 <pumpkin> Raevel: yeah :) looks neat
01:42:25 <mmorrow> also, you don't have to write Ord in any functions anymore~
01:42:30 <mmorrow> s/~/!/
01:42:55 <pumpkin> mmorrow: but I wanted it more general than Map
01:43:02 <mmorrow> i did this the other day and was like yessss!!
01:43:08 <pumpkin> I have an RMonad-like approach right now
01:43:19 <mmorrow> pumpkin: hmm, i don't know RMonad
01:43:31 <pumpkin> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/rmonad
01:43:36 <mmorrow> if you use a Map, there's no way around Ord
01:43:43 <pumpkin> I know :)
01:43:58 <pumpkin> that's why I used the RMonad technique to make my typeclass not afraid of constraints
01:44:14 <mmorrow> oh, it makes a new class ...
01:44:37 <pumpkin> yeah, and it allows you to make a Set monad quite nicely
01:44:55 <pumpkin> Heffalump made it
01:45:01 <pumpkin> with someone else
01:45:17 <mmorrow> for a second there i thought it did the impossible :)
01:46:11 <Raevel> hmm, do i need to/can i update cabal install's package cache somehow?
01:46:24 <pumpkin> mmorrow: it's magic!!1!1!
01:46:56 * mmorrow cues the snakecharming music
01:49:23 <pumpkin> http://hpaste.org/14009
01:52:38 <sleven> sjanssen: thanks for your help I got it working
01:52:52 <sleven> http://hpaste.org/14010 , can it be improved (mul is at the bottom)
01:53:08 <Saizan> Raevel: "cabal update"?
01:54:14 <beelsebob> your naming for addOrSub is rather odd
01:54:20 <beelsebob> I'd call that one zipWith
01:54:31 <beelsebob> and push the function argument to the front
01:54:34 <Raevel> i forgot to write cabal --help, :-D
01:54:46 <Raevel> i blame the morning hour
01:55:02 <sleven> http://hpaste.org/14010#a1
01:56:02 <sleven> i missed if u said something
01:56:25 <beelsebob> your naming for addOrSub is rather odd
01:56:33 <beelsebob> I'd call that one zipWith and push the function argument to the front
01:56:57 <povman> what's that website with hundreds of programming problems?
01:59:12 <Raevel> povman: projecteuler.net
01:59:31 <povman> Raevel:
01:59:34 <povman> Raevel: thanks
02:04:53 <sleven> beelsebob: but there already is zipWith as  a name for a function i the prelude
02:05:03 <beelsebob>  so mport it qualified
02:05:21 <sleven> cant emacs  mode insert types for me for my functions?
02:07:16 <Saizan> sleven: put the cursor over the definition and C-u C-c C-t
02:08:44 <mmorrow> wow, i just read that clojure doesn't do TCO
02:09:04 <dolio> That's a JVM issue, I think.
02:09:07 <mmorrow> though i never thought about it, i guess it's obvious that it doesn't due to
02:09:08 <mmorrow> yeah
02:09:53 <pumpkin> wow, that seems like a pretty big issue
02:10:05 <dolio> TCO interferes with the security model, I think.
02:10:07 <mmorrow> the JVM blows for functional langs...
02:10:07 <sleven> beelsebob: from where
02:10:22 <beelsebob> sleven: import qualified Prelude as P
02:10:24 <sleven> mmorrow: it has loop-recur so it desont matter
02:10:33 <beelsebob> or more to the point
02:10:39 <beelsebob> import Prelude hiding (zipWith)
02:10:47 <sleven> beelsebob: dont I have to P. pretty much everything then?
02:10:47 <pumpkin> sleven: what if you want to write your own recursive functions?
02:11:06 <beelsebob> sleven: not if you also use the import Prelude hiding line
02:11:07 <sleven> pumpkin: in clojure? you use loop-recur...
02:11:21 <sleven> and it is lazy so you can use lazy-cons for a lot
02:12:14 <pumpkin> oh no, the time is 2^9
02:12:22 <pumpkin> that probably means I should go to sleep
02:12:47 <mmorrow> see the "things that suck" section here http://wiki.brianweb.net/LambdaVM/Implementation
02:13:04 <mmorrow> sleven: it doesn't have "jmp"
02:13:10 <mmorrow> (the jvm)
02:13:36 <pumpkin> Arguments have to be passed in global variables. Accessing global variables requires memory access. I don't think there is a JIT on the planet that is smart enough to figure out that it would be smart to tie a global variable to a register.
02:13:37 <pumpkin> :o
02:13:43 <mmorrow> clojure apparently has to use a trampoline for mutual recursion, which is horrificly inefficient
02:14:53 * pumpkin adds contributing to the GHC on JVM project to his list of things to never try
02:15:12 <ivanm> heh
02:15:17 <mmorrow> from that "things that suck":
02:15:20 <mmorrow> "We can't make direct branches. What should be a single direct jump instruction turns into an indirect jump back to the caller (who in running the interpreter loop), a conditional branch (while (c != null), followed by a virtual method call (memory read, and another indirect jump). And this is the best case scenario (there might be other stuff going on in the jvm under the hood). This is a lot of overhead."
02:15:38 <ivanm> mmorrow: isn'there a similar reason why Lemmih said he didn't want to target JVM for LHC?
02:15:49 <pumpkin> it could be fun to try to give an OISC backend to GHC
02:16:01 <mmorrow> ivanm: i don't know, but probably
02:17:11 <sleven> i asked for ghc on jvm a while ago because i liked clojrue so much. but im starting to think it is so frigggin easy to write software fast in functional langauges i can write most libs myself in notime anyway
02:17:23 <mmorrow> sleven: exactly
02:17:55 <pumpkin> sleven: there's also a surprisingly large selection on hackage, for common things
02:18:22 <FunctorSalad> cabal newbie problem :( I'm trying to generate an executable, and - "Warning: output was redirected with -o, but no output will be generated because there is no Main module."
02:18:23 <dolio> Often multiple packages per common thing.
02:18:48 <FunctorSalad> (I do have a "main-is" field in my "executable" section in the .cabal)
02:19:41 <mmorrow> which i think speaks to sleven's point.. most pkgs on hackage are less than a year old (or at least a lot)
02:19:59 <sleven> why is ghc so picky about intendation?
02:20:13 <mmorrow> sleven: layout rule
02:20:28 <mmorrow> it's why you don't need semicolons and braces all over
02:20:30 <sleven> i cant do instance show blah blah blah =  and then on a new row if then prettyprint m else blahaba
02:20:32 <FunctorSalad> sleven: so you don't need to write so many { ; } :)
02:21:02 <pumpkin> sleven: from what I understand, it's sort of treating your code like a spreadsheet, with column-like things
02:21:25 <Saizan> sleven: you can, you just have to indent the if more than show
02:21:58 <Saizan> FunctorSalad: tried seeing what's going on with -v? or -v2
02:25:16 <sleven> Saizan: cool. can I ask emacs do it for the whole file without asking for permission  ?
02:25:34 <sleven> and can it add the function declaration on top of the function rather than below?
02:25:44 <sleven> jmp=?
02:27:40 <FunctorSalad> Saizan: cabal's call to ghc doesn't include -main-is, that seems suspicious
02:28:30 <FunctorSalad> I also don't get the "other-modules" field... --make ensures that all the necessary modules are compiled as well as the executable, no?
02:28:44 <Saizan> FunctorSalad: it's needed for sdist
02:29:02 <Saizan> and to tell cabal in general that there are other modules
02:29:14 <sjanssen> FunctorSalad: is your main module actually named Main, or is it something else?
02:29:25 <FunctorSalad> sjanssen: something else :)
02:30:11 <FunctorSalad> I thought that's what the "main-is" field is for ;)
02:30:24 <sjanssen> FunctorSalad: main-is tells Cabal which file Main is in
02:30:52 <sjanssen> specifying that GHC should look for the 'main' function in a module other than Main is another matter
02:30:54 <Saizan> yeah, it doesn't support ghc's -main-is flag, it seems
02:31:22 <FunctorSalad> :) I thought it is just like -main-is....
02:31:31 <sjanssen> it isn't.
02:32:04 <sjanssen> you could probably use ghc-options: -main-is, though
02:33:11 <FunctorSalad> hmm, ghc --make will complain if the module name doesn't match the filename...
02:33:40 <FunctorSalad> so it seems odd to support putting modul Main into a different file
02:33:44 <FunctorSalad> *module
02:35:38 <FunctorSalad> ok, calling the module "Main"  (without mv'ing the file) worked... thx Saizan sjanssen
02:36:59 * mmorrow is paging through ltu
02:37:19 <mmorrow> wow, they're not going to require proper TCO for new javascript
02:37:25 <Raevel> TCO?
02:37:27 <mmorrow> that's such a shame
02:37:33 <Raevel> OH n/m
02:37:34 <vixey> homework the ultimate
02:37:50 <Raevel> yes, shame :-(
02:38:16 <mmorrow> mutual f g a = f a (\b -> g b (\a -> mutual f g a))
02:38:17 <Raevel> they probably want to keep us out of there
02:38:19 <FunctorSalad> :) http://www.acronymfinder.com/TCO.html
02:38:30 <FunctorSalad> thermal cut-off?
02:38:32 <sleven> isnt this wrong btw: instance Show (Matrix matrix) where show m = // shouldnt it be show matrix ?
02:38:47 <mmorrow> sleven: the `m' is just a pattern
02:38:54 <mmorrow> (a trivial pattern in this case)
02:39:03 <mmorrow> so it could be any var name
02:39:38 <mmorrow> , let foo (Just x) = show x; foo Nothing = ""; in foo (Just 4)
02:39:39 <lunabot>  "4"
02:39:44 <FunctorSalad> sleven: matrix is a type variable and m is just a variable for a value... they don't have anything to do with each other directly
02:39:46 <sleven> http://hpaste.org/14011 how can I better that becuase whats shown doesnt work
02:40:34 <mmorrow> sleven: ah, the indent of "then" and "else" have to be greater than the indent of "if"
02:40:44 <mmorrow> (and you can ditch the braces too)
02:40:55 <Saizan> sleven: btw http://hpaste.org/14011#a1
02:41:09 <Saizan> actually it can be the same, outisde a do-block
02:42:03 <mmorrow> sleven: or http://hpaste.org/14011#a2
02:42:30 <sleven> no not Matrix, matrix
02:42:39 * Saizan loves :! hoogle --info foo
02:42:50 <sleven> bu the then refueses to indent
02:43:09 <Saizan> sleven: "matrix" is a type variable, Matrix is a type constructor
02:43:16 <sleven> i stillget parse error on inendation
02:43:30 <mmorrow> Saizan: yeah, you're right. "let", "where", "do", "of" are layout triggers
02:43:48 <Saizan> sleven: maybe the error is somewhere around that snippet?
02:43:57 <Saizan> sleven: can you paste the error message?
02:44:42 <mmorrow> the indent of the first token after any of those triggers _determines_ the minimal indent for any token in that block
02:46:47 <mmorrow> so if/then/else having the same indent in a do block should be OK as long as then "if" isn't matched up with the minimal indent of the do block itself
02:47:02 <mmorrow> (which would mean that then/else are as well)
02:47:28 <sleven> it works i changed to | layout
02:48:02 <mmorrow> nice
02:50:34 <sleven> obv importing qualified Prelude is retarded then I have to Prelud. everyhting
02:51:04 <sleven> but if i use hiding, how do Ir refer to those hdiden fucntions?
02:51:11 <sleven> Prelude.transpose doesnt work
02:51:30 <mauke> import qualified Prelude as P
02:51:35 <mauke> import Prelude hiding (transpose)
02:51:39 <mauke> P.transpose
02:51:42 <Saizan> sleven: you can import a module multiple times
02:51:55 <Saizan> once qualified and once using hiding, like mauke just showed
02:52:44 <sleven> but if it is qaulified then i need to P.*
02:53:11 <Saizan> no
02:53:37 <sleven> ah i see
02:53:48 <mmorrow> (transpose is in Data.List also)
02:53:59 <sleven> but is that good? it seems like an awkward wya of doing thins
02:54:03 <sleven> yes i noticed
02:54:14 <mmorrow> it's the only way for better or for worse
02:54:21 <Saizan> it's common practice
02:55:03 * Saizan wonders if a dependecy on binary is appropriate in an irc-parsing library
02:55:08 <sleven> ok
02:57:09 <sleven> again, if I want to make a dsl that allows things like: (m + n) * k' , where m n and k are matrices and k' mean k transpose, so i want my own dsl. should I use template haskell?
02:57:51 <vixey> sleven, I think that using TH for it would be pretty painful
02:58:25 <vixey> you could do:  (m + n) * transpose k  without any extensions btw.
02:58:27 <Saizan> sleven: you can just redefine those operators to match your use
02:58:39 <Saizan> ah, yeah, apart from '
02:58:56 <FunctorSalad> ghc 6.10.1 has postfix operators, but ' might be illegal
02:59:18 <mmorrow> couldn't you make Matrix an instance of Num?
02:59:19 <Saizan> ' is not an operator symbol
02:59:38 <vixey> but of course you can write
02:59:45 <vixey> (m + n) * k'
02:59:49 <vixey>  where k' = transpose k
02:59:58 <FunctorSalad> you could use the actual transpose symbol ;) ⊤
03:00:21 <mmorrow> you couldn't even do that with TH alone, you'd need to use a QuasiQuoter where you've supplied your own parser
03:01:39 <sleven> what is the easiest way to get a random double between 0 and 1?
03:01:48 <mmorrow> [$mat| m + n) * k' |] ===> (m `matSum` n) `matProd` transpose k
03:02:01 <mmorrow> s/m/(m/
03:02:19 <sleven> so I can define * for my own datas?
03:02:20 <mmorrow> , randomR (0,1::Double) (mkStdGen 7436876298)
03:02:23 <lunabot>  (0.8713053677629925,32475254 1655838864)
03:02:51 <mmorrow> sleven: if you make your datatype and instance of Num, then you can use (+), (*), ...
03:02:52 <Saizan> sleven: yes, make your type an instance of Num
03:02:57 <mmorrow> @src Num
03:02:57 <lambdabot> class  (Eq a, Show a) => Num a  where
03:02:57 <lambdabot>     (+), (-), (*)           :: a -> a -> a
03:02:57 <lambdabot>     negate, abs, signum     :: a -> a
03:02:57 <lambdabot>     fromInteger             :: Integer -> a
03:03:29 <FunctorSalad> or you can avoid importing Prelude if you need a more general sig for (*)
03:03:33 <mmorrow> if some of the functions in Num don't make sense for your type, you can just define them as "error \"this doesn't make sense\""
03:04:01 <FunctorSalad> (unless * is magic?)
03:04:07 <mmorrow> it's not
03:04:35 <FunctorSalad> is +? for n+k patterns
03:04:57 <mmorrow> "+?" ?
03:05:00 <Saizan> it's magical only in patterns
03:05:09 <mmorrow> ohh, just parsed that
03:05:26 <FunctorSalad> (let's have p*q-patterns... let (p*q) = secretKey in .....) :D
03:05:59 <Saizan> @faq can haskell break RSA?
03:05:59 <lambdabot> The answer is: Yes! Haskell can do that.
03:06:01 <mmorrow> we could craxxor all the codez!
03:06:14 <mmorrow> you'd need "-" patterns too though
03:06:21 <Saizan> @faq in the type system?
03:06:21 <lambdabot> The answer is: Yes! Haskell can do that.
03:06:30 <mmorrow> let (p-1)*(q-1) = secretKey in ...
03:07:22 <FunctorSalad> (err and actually it's the publicKey, but anyway)
03:07:32 <mmorrow> heh, right
03:09:43 <sleven> well I need to define my own * , like  have with mul because i suspect ghc isnt smart enough to figure out how to do proper matrix mult
03:10:32 <vixey> sleven, instance Num Matrix where ... m * n = ... ; ...
03:11:18 <mmorrow> sleven: yes, you define (*) for your type in instance Num MyType where (*) = ....
03:11:30 <mmorrow> (+) = .... , etc
03:11:53 <mmorrow> (you can say      m * n = .....    too)
03:13:37 <sleven> do I derive Num?
03:14:19 <mmorrow> you can't unfortunately
03:14:51 <mmorrow> (if you derive (Foo) for a type, that mean that the compiler generates the code "instance Foo where ...." for your type)
03:15:22 <mmorrow> so derive(Foo) means the same thing as writing out instance Foo MyType where ...
03:15:29 <sleven> instance Num (Matrix matrix) where
03:15:32 <sleven> ?
03:15:36 <vixey> sleven, instance Num Matrix where ... m * n = ... ; ...
03:15:38 <vixey> oh
03:15:43 <vixey> what's 'matrix'?
03:15:43 <mmorrow> yes
03:15:50 <vixey> is that dimensions?
03:15:52 <mmorrow> it's just a tyvar, right?
03:16:21 <mmorrow> instance Num (Matrix a) where ...  would mean the same thing
03:16:30 <sleven> yes
03:17:20 <sleven> instance Num (Matrix m) where m * n = mul m n
03:17:33 <sleven> Warning: No explicit method nor default method for `abs'
03:17:35 <sleven> i have to def them all?
03:17:50 <vixey> no
03:18:15 <Saizan> you should if your type supports them
03:18:16 <sleven> so how do I do else error?
03:18:21 <sleven> signum =?
03:18:43 <FunctorSalad> abs m n = error "not supported"
03:19:03 <mmorrow> or just abs = error ...
03:19:59 <FunctorSalad> isn't that stricter? ;)
03:20:10 <mmorrow> @type error "zomg" :: Tree (Maybe (Either [Int] (Double, String))) -> ([Integer], [IO ()])
03:20:11 <lambdabot> Tree (Maybe (Either [Int] (Double, String))) -> ([Integer], [IO ()])
03:20:23 <mmorrow> @type error "zomg"
03:20:24 <lambdabot> forall a. a
03:21:07 <mmorrow> FunctorSalad: i guess so yeah, but i'd think you'd want to be
03:21:21 <mmorrow> (although i didn't have that in mind when i wrote that)
03:21:54 <FunctorSalad> I was just being silly, I can't think of any case where it matters
03:23:11 <mmorrow> i think that's a good point though. if you did "abs m n = error .. ", then   abs m `seq` ..  (or equivalent in some shape or form) wouldn't error out
03:23:32 <mmorrow> i'm not sure if that would ever happen though
03:24:06 <FunctorSalad> or how about "abs m = positiveMatrixSqrt (m * transpose m)"... :)
03:24:06 <sleven> so Num has some basic defaults thta must be implemented then I can add too if i want, like -
03:24:06 <sleven> ?
03:24:06 <sleven> what is signum?
03:24:06 <sleven> and fromInteger
03:24:07 <mmorrow> , let foo = error "asdf" in foo 42 `seq` 9999
03:24:10 <lunabot>  luna: asdf
03:24:15 <sereven> > map signum [4,0,-4]
03:24:16 <mmorrow> , let foo x y = error "asdf" in foo 42 `seq` 9999
03:24:17 <lambdabot>   [1,0,-1]
03:24:18 <lunabot>  9999
03:24:23 <twb> I have a list of predicates [p,q,r] :: [a->Bool] and I want to create a "combined" predicate p || q || r.  How can I do this?  I'm trying to foldl (||) without much success.
03:24:24 <lambdabot> twb: You have 1 new message. '/msg lambdabot @messages' to read it.
03:24:42 <Raevel> @src or
03:24:43 <lambdabot> or    =  foldr (||) False
03:24:59 <twb> Raevel: thanks!
03:25:11 <Raevel> oh wait. i didn't read what you wrote properly i think
03:25:12 <twb> I bet I had the foldl argument order wrong or somethign stupid like that
03:25:27 <mmorrow> yeah, you need foldr to short-circuit there
03:25:35 <mauke> :t any
03:25:36 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
03:25:46 <FunctorSalad> abs m = u*d1*v where (u,d,v) = svd m;  d1 = fmap sqrt d
03:25:46 <Raevel> or . map predicates
03:25:52 <twb> mauke: any takes a single test and a list or arguments.
03:25:52 <Saizan> sleven: you should learn about typeclasses
03:25:54 <mauke> :t any ($ ?v)
03:25:55 <lambdabot> forall a. (?v::a) => [a -> Bool] -> Bool
03:25:59 <twb> mauke: I have a *list* of tests.
03:26:11 <twb> Hmm.
03:26:13 <mauke> twb: \v -> any ($ v) tests
03:26:34 <twb> Wow, let me start at that for a while
03:26:41 <FunctorSalad> eh nvm that last one is off
03:26:47 <mauke> @unpl ($ v)
03:26:47 <lambdabot> (\ a -> a v)
03:29:46 * twb tries to compile it
03:30:01 <sleven> hmm i guess I could implement abs for a matrix but that isnt a "real" linear algebra function is it? does it ever make sense?
03:30:34 <mauke> :t signum
03:30:35 <lambdabot> forall a. (Num a) => a -> a
03:30:56 <mauke> signum * abs == id
03:31:10 <FunctorSalad> sleven: componentwise abs doesn't make much sense imho
03:32:02 <FunctorSalad> the (a * transpose a) is vaguely analogous to (abs x)^2 for x real or complex
03:32:25 <FunctorSalad> (transpose being analogous with the complex conjugate)
03:34:19 <FunctorSalad> if you encode complex numbers as 2-dimensional rotation matrices, the transpose is actually the complex conjugate :)
03:39:16 <thoughtpolice> @seen mmorrow
03:39:17 <lambdabot> mmorrow is in #haskell and #ghc. I last heard mmorrow speak 13m 49s ago.
03:39:22 <mmorrow> heya
03:40:53 <twb> How can I simplify this expression?
03:40:54 <twb> map (\regexp file -> isJust $ matchRegex regexp file) regexps
03:41:17 <twb> map (isJust . matchRegex) regexps doesn't DWIM
03:41:24 <vixey> @pl (\regexp file -> isJust $ matchRegex regexp file)
03:41:24 <lambdabot> (isJust .) . matchRegex
03:41:32 <vixey> map ((isJust .) . matchRegex) regexps
03:41:54 <mmorrow> @pl \a b -> g (f a b)
03:41:54 <lambdabot> (g .) . f
03:41:56 <joma> hmm if i want a function like: info :: Matrix m -> [(String, val)] , where valculd be sometimes bool, sometimes Int, is that possible? do I need to use tuples?
03:41:58 <mmorrow> @pl \a b c -> g (f a b c)
03:41:58 <lambdabot> ((g .) .) . f
03:41:59 <twb> I wish I could just work that out.
03:42:02 <mmorrow> @pl \a b c d -> g (f a b c d)
03:42:02 <lambdabot> (((g .) .) .) . f
03:42:04 <mmorrow> ...
03:42:16 <mauke> joma: you could use Either
03:42:47 <thoughtpolice> mmorrow: can i use your th-utils to derive stuff for a quasiquoter, e.g. xml parsing?
03:42:57 <joma> mauke: how?
03:43:09 <mauke> in the obvious way
03:43:14 <mmorrow> thoughtpolice: hmm, which th-utils is this?
03:43:25 <mauke> @src Either
03:43:25 <lambdabot> Source not found. The more you drive -- the dumber you get.
03:43:29 <mauke> :-(
03:43:54 <mauke> data Either a b = Left a | Right b
03:44:12 <mmorrow> thoughtpolice: ah, this one http://moonpatio.com/repos/th-utils ?
03:44:18 <FunctorSalad> joma: or you could just make your own type "data Thing = Foo Int | Bar String"
03:44:19 <thoughtpolice> mmorrow: http://code.haskell.org/~morrow/code/haskell/th-utils/
03:44:37 <FunctorSalad> I mean Bool not String
03:45:07 <mmorrow> yes, you should be able to. one thing to note though is that that pkg requires haskell-src-exts <= 0.3.8
03:45:22 <mauke> haha, just use Matrix m -> [(String, String)]
03:45:23 <thoughtpolice> mmorrow: yeah, wondering if that could be updated :)
03:45:32 <mmorrow> i haven't yet fixed by src-exts -> TH code yet :(
03:45:33 <mauke> (warning: not a real solution)
03:45:37 <thoughtpolice> mmorrow: would be nice to have on hackage
03:45:43 <mmorrow> thoughtpolice: it's going to be nontrivial
03:46:05 <mmorrow> thoughtpolice: that has been on my todo-list though for a while. i need to suck it up and be done with it.
03:46:38 <mmorrow> thoughtpolice: request noted though. i'll see what i can do :)
03:57:01 <jeffz`> http://www.reddit.com/r/programming/comments/7qf6f/i_am_18_years_old_i_want_to_be_a_programmer_and_i/ - someone downmodded learnyouahaskell :(
03:58:01 <blackdog> jeffz`: someone is wrong on the internet, you say?!?
03:58:05 <BONUS> no worries, i cancelled their downmoddation!!
03:58:17 <jeffz`> blackdog: hehe
03:58:27 <sleven> how do I import either?
03:58:34 <BONUS> although idk if you can follow LYAH if you've never programmed before
03:58:48 <blackdog> BONUS: http://www.theonion.com/content/opinion/yee_haw_my_vote_cancels_out
03:59:03 <BONUS> sleven: import Data.Either(either)
03:59:12 <BONUS> haha
03:59:23 <jeffz`> BONUS: better to steer someone in the direction of Haskell in any case I think
04:00:00 <BONUS> that's true. i wonder if now that FP getting more and more established, you'll get more people who learn a functional language first
04:01:11 <jeffz`> the op says they are working through K&R, so lyah can't really hurt
04:01:12 <jethr0> in Karlsruhe in Germany the introductory CS course was actually taught in haskell for several years
04:01:32 <jethr0> much to the discontent of the freshmen who wanted to program in cool languages like C++ ;)
04:01:36 <vixey> K&R... for a beginner ?
04:01:39 <vixey> weird
04:03:42 <jethr0> vixey: probably still a better introduction than Stroustrup ;)
04:04:10 <jethr0> that book (as an introduction) will keep you away from programming for life...
04:05:20 <maltem> jethr0: I'm currently suffering from C++ in a freshmen engineering course at Aachen :)
04:07:04 <jethr0> maltem: there's no easy way to put it. if you stick to really simple code, C++ is bearable. but with exception-safe code you have to juggle so much stuff in your head that it becomes a logistic nightmare to implement anything even remotely complex.
04:07:56 <jethr0> i've just had another look at java and after programming solely haskell for some years now, I saw some serious shortcomings
04:08:27 <jethr0> for example the standard by-reference parameter passing and no mechanism to declare parameters const (as far as I could find)
04:08:51 <jethr0> also, no good tutorial, code examples or similar. finding out how to sort a collection took me 5 times as long as it should have
04:08:56 <povman> jethr0: you can declare parameters const
04:08:58 <Raevel> jethr0: foo(final X bar) (?)
04:09:06 <jethr0> ah, cool
04:09:29 <maltem> jethr0: At least Java looks like it has been designed, opposed to C++. Actually I'd rather do number-crunching and the like in C
04:09:31 <povman> is this c++? that would be foo(const X& bar)
04:09:31 <Raevel> of course, that means only that you cannot change the value of the variable, you can still modify the objects if they allow it
04:09:32 <jethr0> i found a page somewhere on the net that said java had nothing similar to "const". good to know
04:10:03 <maltem> jethr0: "final" doesn't share any letter with "const"!
04:10:08 <Raevel> (imo, final should be the default for all args)
04:10:11 <jethr0> Raevel: exactly, so final doesn't really help me. there's no guarantee a method is not gonna mutate the object passed to it
04:10:19 <maltem> jethr0: so clearly they are not similar :)
04:10:20 <jethr0> hehe
04:10:29 <sleven> hmm if i have 2 lists and i want to print the corresponding items from eahc list
04:10:52 <jethr0> sleven: could you give a short example?
04:11:02 <Stinger> c++ was over designed :P
04:11:22 <jethr0> oh noes, not the C++ debate again
04:11:27 <Raevel> jethr0: not sure i can see how one could work around this, assuming someone getting the reference later on does want to modify it (otherwise you can just pass a dummy object containing the same values)
04:11:39 <jethr0> let's just all agree that we like haskell better than C++ and cut it short
04:11:45 <Stinger> which c++ debate was this? :)
04:11:59 <jethr0> the "C++ is a pile of crap" debate
04:12:09 <mmorrow> sleven: zip
04:12:11 <twb> jethr0: that's not a debate, that's a tautology
04:12:11 <maltem> jethr0: Guess who started the current debate :)
04:12:18 <jethr0> sorry
04:12:29 <jethr0> oh wait, one could argue it was you
04:12:37 <maltem> (actually, yes, we're not debating, we're just agreeing)
04:13:27 <jethr0> maltem: so, how are your colleagues taking C++ as an introductory language?
04:13:27 <sleven> ["Rows: ","Columns: ","Symmetric: ", "Square: "]
04:13:27 <sleven>              [P.Left (rows m), P.Left (cols m),
04:13:27 <sleven>               P.Right (symmetric m), P.Right (square m)]
04:13:33 <sleven> well basically Iw ant :
04:13:38 <sleven> Rows: 10
04:13:41 <maltem> jethr0: we could now start a meta-meta discussion on who should be blamed for the blaming discussion :)
04:13:42 <sleven> Square: True
04:13:46 <sleven> etc
04:14:12 <maltem> jethr0: the introductory language was Java, C++ is more like the legacy engineering language
04:14:43 <twb> @google "The Perils of Java Schools"
04:14:50 <lambdabot> http://www.joelonsoftware.com/articles/ThePerilsofJavaSchools.html
04:14:50 <lambdabot> Title: The Perils of JavaSchools - Joel on Software
04:14:51 <jethr0> ah, ok. at least with java shooting yourself in the foot is nigh-impossible
04:15:05 <mmorrow> , zipWith (++) ["One: ", "Hello :"] [show 99, show [Left 3, Nothing]]
04:15:18 <lunabot>  luna: Couldn't match expected type `Data.Either.Either t b'
04:15:31 <mmorrow> , zipWith (++) ["One: ", "Hello :"] [show 99, show [Just "asdf", Nothing]]
04:15:36 <lunabot>  ["One: 99","Hello :[Just \"asdf\",Nothing]"]
04:15:38 <povman> jethr0: actually in java1.4 and before, most of the code was casts.
04:15:40 <maltem> jethr0: Yeah in Java I mainly miss a Maybe type
04:15:49 <mmorrow> zipWith is super useful
04:15:49 <Raevel> maltem: yes!!!
04:16:05 <Raevel> null is the thing i hate most about java
04:16:17 <maltem> same here
04:16:50 <maltem> and of course, the downcasts
04:16:53 <Raevel> mind boggling how that got in there
04:17:01 <sleven> yes zipWith is goot
04:17:07 <mmorrow> after haskell, it physically pains me to prog in languages without (1) pattern matching, and (2) first-class functions and the ability to dynamicaly create them (lambdas)
04:17:20 <sleven> haskell wins
04:17:23 <twb> mmorrow: even in CL pattern matching is just ugly
04:17:38 <sleven> you even mention Javs shortcomings in #Java you get plastered
04:17:40 <Raevel> mmorrow: http://se2.php.net/array_walk :-D
04:17:42 * vixey after using hakell I lost the use of my legs
04:17:48 <jethr0> coming from haskell, i missed laziness, simple to declare data types, type synonyms, type inferences, etc.
04:17:54 <twb> sleven: that's because it's full of people who only know one paradigm
04:18:07 <twb> jethr0: I like type classes most of all of Haskell's features.
04:18:09 <jethr0> also, i had totally forgotten how to deal with state. state seemed so baroque to carry around with me all the time ^_^
04:18:15 <vixey> I heard people saying,  Once I learned Lisp I got better at every programming language
04:18:18 <mauke> "A PHP function is passed by its name as a string."
04:18:23 <jethr0> anyone know whether java supports type synonyms?
04:18:25 <vixey> and with haskell they say,   I got bored of every programming language
04:18:31 <Raevel> vixey: that's true for most programming languages i'd say
04:18:49 <jethr0> repetitively typing "Vector<Vec2D>" gets old after a while
04:19:00 <twb> jethr0: use a CPP macro!
04:19:03 <mmorrow> mauke, Raevel: looks fabulous :)
04:19:05 <twb> >duck<
04:19:27 <mauke> mmorrow: http://www.php.net/manual/en/function.create-function.php
04:19:37 <jethr0> having learned haskell in a very incremental way, I had simply not realized how cool type classes and a fully extensible language are until I sorely missed these features in java
04:19:45 <mauke> challenge: read that page without RAGE
04:20:01 <mmorrow> hehe
04:20:16 <twb> The thing I miss most in Haskell is DEFINE-SYNTAX
04:20:27 <sleven> how do I uneither a list?
04:20:38 <twb> TH just looks so unweildy in comparison
04:20:44 <Raevel> mauke: no rage here, i'm pretty much crying though, since i used to do a lot of php
04:20:47 <dolio> What does "uneither" mean?
04:20:53 <sleven> twb: I miss macro-like evaluation-control. now I have to write something that works instead of a ahck :)
04:20:58 <sleven> fromEither
04:20:59 * blackdog is learning that linking a tiny bit of C with a lot of haskell is like a big barrel of delicious fudge with only a tiny little bit of poo in it
04:21:00 <jethr0> mauke: just as nice as using the content of a variable as the variable name of another one in PHP. *argh*
04:21:14 <sleven> [P.Left (rows m), P.Left (cols m),
04:21:14 <sleven>                         P.Right (symmetric m), P.Right (square m)])
04:21:14 <vixey> twb, what sort of things would you use it for in haskell?  personally I didn't come across a time where I would use macros yet
04:21:20 <sleven> i dont want the lefts and right in there
04:21:26 <sleven> hmm maybe i dont neeed lol
04:21:30 <vixey> sleven, the entire execution of haskell is macro like
04:21:39 <dolio> What type signature do you want?
04:21:52 <vixey> sleven, (Oleg showed how to rewrite  zipWith (+) fibs (tail fibs)  in lisp macros)
04:21:52 <jethr0> I forgot the syntax, but it went something like '$var1 = "hello"; $var2 = "var1"; print $$var2' => "hello"
04:21:53 <dolio> Anyhow, I don't think there's any such function in the libraries, although they've been proposed.
04:21:57 <twb> vixey: usually when something is really repetetive and can't be abstracted with HOFs.
04:22:03 <Raevel> jethr0: yep that's it
04:22:15 <mauke> mmorrow: http://home.cs.tum.edu/~mai/cgi-bin/foo
04:22:23 <jethr0> blackdog: and all together is that little bit of poo spoiling the fun??
04:22:26 <Raevel> $$foo is not used often though
04:22:29 <twb> vixey: admittedly they aren't as necessary as in Scheme, because of the laziness and such
04:22:29 <lunabot>  luna: Not in scope: `foo'
04:22:45 <Raevel> (the reason for it not being used: dumb luck)
04:23:02 <jethr0> whether used or not, it's a horrible feature to come up with. certainly very flexible, but with a high foot-shoot-index.
04:23:06 <blackdog> jethr0: yeah, a little :)
04:23:18 <mmorrow> mauke: haha :)
04:23:22 <dolio> @type partitionEithers -- apparently this *is* in now
04:23:23 <lambdabot> Not in scope: `partitionEithers'
04:23:31 <dolio> @hoogle partitionEithers
04:23:31 <lambdabot> No results found
04:23:36 <mmorrow> , [$ty| partitionEithers |]
04:23:37 <dolio> Well, bah.
04:23:41 <Raevel> mirc script (:-D) uses the $$foo a lot, except you have to write % [ $+ [ %foo ] ] instead
04:23:55 <lunabot>  Killed.
04:23:56 <Raevel> another fine language everyone should learn
04:23:58 <mmorrow> gah
04:23:59 <mmorrow> , [$ty| partitionEithers |]
04:24:06 <lunabot>  Killed.
04:24:07 <mmorrow> , 42
04:24:08 <mmorrow> , 42
04:24:10 <lunabot>  42
04:24:11 <lunabot>  42
04:24:16 <twb> vixey: just to be clear, I quite like R5RS-style "clean" macros, as opposed to the more powerful but more brain-hurty CL macros.
04:24:16 <mmorrow> , [$ty| 42 |]
04:24:22 <lunabot>  Killed.
04:24:24 <vixey> twb, likewise :)
04:24:29 * mmorrow rages
04:24:35 <twb> Though of course variable capture has its place ;-)
04:24:40 <dolio> Anyhow. partitionEithers :: [Either a b] -> ([a],[b])
04:24:49 * twb waves vaguely at _On Lisp_ and giggles
04:24:52 <jethr0> similarly, i remember writing some perl golf code and coming up with "$_[$_]" for the element of the current array at the current scalar. whoever comes up with these features *tststs*
04:24:53 <dolio> lefts :: [Either a b] -> [a], rights :: [Either a b] -> [b]
04:25:04 <sleven> I want info: info :: Matrix repr -> IO ()
04:25:25 <twb> jethr0: you can even do that in bash: x=y; y=2; ${!x}
04:25:57 <dolio> @type map (id ||| id)
04:25:58 <sleven> http://hpaste.org/14014
04:25:58 <lambdabot> forall c. [Either c c] -> [c]
04:26:18 * jethr0 considers "On Lisp" on of the great books on programming. arcane yes, baroque sure, a maintenance nigtmare maybe, but so damn powerful and versatile
04:26:22 <mmorrow> , [$ty| 42 |]
04:26:27 <blackdog> jethr0: ah, man, i think i've been institutionalised - it took me a second to work out why anyone would think that syntax is weird
04:26:27 <mauke> jethr0: except @_ is function args, not the "current array" :-)
04:26:28 <lunabot>  Killed.
04:26:42 <dolio> Oh.
04:26:57 <hugo___> hi
04:26:57 <twb> OL is a perfect demonstration of writing code so clever that you can't debug it
04:27:01 <jethr0> of course with typing added to the power of even better
04:27:03 <dolio> sleven: Why don't you just put "show" in for P.Left/Right? It's shorter. :)
04:27:16 <vixey> on lisp is stupid.. (DEFMACRO AVERAGE ...
04:27:21 <mmorrow> , [$ty| partitionEithers |]
04:27:23 <mauke> bonus question: which function writes into @_, clobbering your arguments?
04:27:26 <lunabot>  forall a b . ([] (Either b a)) -> ([] b, [] a)
04:27:29 <mmorrow> yay
04:27:44 <jethr0> mauke: no, i really meant "$_[$_]". perl infers that the outer variable must be an array from the brackets and keeps current array and current scalar separately (as far as i remember)
04:28:13 <mauke> again, @_ is function arguments. there is no "current array".
04:28:19 <mmorrow> , [$ty| let fix f = let x = f x in x in fix |]
04:28:24 <lunabot>  forall a . (a -> a) -> a
04:28:46 <mauke> unlike $_, which is bound by things like for/map/grep/etc
04:29:11 <twb> The good news is that Python keeps up the grand old tradition of spelling "it" as "_"
04:29:21 <sleven> and can I force a computation to finish calculating before it starts printing?
04:29:36 <mmorrow> , [$ty| fromDynamic (eval "42") |]
04:29:40 <twb> sleven: you mean eager evaluation?
04:29:43 <lunabot>  forall a . Typeable a => Maybe a
04:30:28 <mmorrow> sleven: why?
04:30:36 <mmorrow> printing forces evaluation
04:31:10 <Saizan_> someone knows how to produce an hoogle index with links to the haddock documentation?
04:31:57 <sleven> dolio: *duh* yeha i made a problem of something that wasnt
04:32:19 <dolio> Eh.
04:32:23 <blackh> Saizan_: If I recall correctly, this is documented in the documentation for HsColour
04:32:50 <Saizan_> blackh: really? weird place to put that
04:33:08 <blackh> Saizan_: Please ignore me! I am answering the wrong question.
04:33:18 <blackh> Saizan_: Too many late nights
04:33:28 <dolio> I was going to go into how you want a list with type [exists a. Show a => a], which isn't possible in GHC, but then I realized just writing "show" wouldn't be much more work than getting that to work out, even if the language supported it.
04:34:23 <jamii> damn - wheres liftM6 when you need it?
04:34:37 <sleven> most fo all, lately I have really come to appreciate the style of "a lof of functions operating on a small set of types" rather than OO approach of a small number of functions/methods operating ona  huge number of types/objects. i just think the whole OO-programming model is fundamentally wrong/flawed. It is not how the world works,saying "everything is an object" means nothing. it is just how we think in everyday life, a bunch of stuff v
04:34:43 <vixey> liftM 6
04:34:56 <mauke> jamii: return f `ap` x1 `ap` x2 `ap` x3 `ap` x4 `ap` x5 `ap` x6
04:35:11 <sleven> mmorrow: well i do: info m and the it prints Symmetric and it waits for the calucaltion before printing True/False...
04:35:36 <blackh> sleven: That's a great insight! Mostly I find FP works amazingly and don't know why! But I have realized one thing:
04:36:34 <blackh> sleven: Objects exist to make mutable state manageable. Eliminate the mutable state, and the need for objects disappears too.
04:36:45 <jamii> mauke: liftM6 f <$> x1 <*> x2 <*> ...
04:37:35 <jamii> mauke: Theres only so much punctuation I'm willing to type. Maybe missingh has liftM6. Cant bring myself to redefine it
04:38:33 <hugo___> [liftM1 .. liftM100] doesn't work ? :P
04:38:38 <jethr0> isn't it possible to define liftM6 in terms of liftM5?
04:39:06 <Saizan_> yes
04:39:15 <jethr0> like "liftM6 = ap liftM5" or similar?
04:39:16 <mmorrow> dolio: a GADT to "hide" the existential: http://hpaste.org/14015
04:39:43 <mauke> liftM6 f u v w x y z = liftM5 f u v w x y `ap` z
04:39:43 <jamii> jethr0: I like that. Thanks. At least this way its a pretty redefinition
04:39:59 <jethr0> :t ap liftM5
04:40:00 <lambdabot> forall a1 a2 a3 a4 a5 r (m :: * -> *). (Monad m) => ((a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1) -> (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a2 -> m a3 -> m a4 -> m a5 -> m r
04:40:06 <mmorrow> sleven: if you made it force it first, it would just print nothing, then pause, then print "Symmetric ....."
04:40:10 <jethr0> i hope it's correct...
04:40:13 <mm_freak> i've got a database with dated datasets, what's the preferred date type?  ZonedTime?
04:40:24 <mmorrow> sleven: so i don't see what you'd gain
04:40:29 <mm_freak> it should be precise all around the world
04:40:32 <jethr0> @let lM2 = ap liftM1
04:40:33 <lambdabot>  <local>:1:9: Not in scope: `liftM1'
04:40:38 <jethr0> @let lM2 = ap liftM
04:40:38 <lambdabot>  Defined.
04:41:05 <baaba> :t lM2
04:41:06 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => ((a1 -> r) -> m a1) -> (a1 -> r) -> m r
04:41:15 <baaba> that's not quite right
04:41:23 <jethr0> > lM2 (+) [3] [4]
04:41:24 <lambdabot>       Occurs check: cannot construct the infinite type: a1 = a1 -> r
04:41:24 <lambdabot>      Pro...
04:41:52 <jethr0> argh, my type skillz are just sub-par
04:42:00 <Axman6> :t lM2
04:42:01 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => ((a1 -> r) -> m a1) -> (a1 -> r) -> m r
04:42:34 <mmorrow> dolio: oh. the GADT isn't necessary..
04:42:41 <Axman6> > liftM2 (+) [1..3] [10..13]
04:42:42 <lambdabot>   [11,12,13,14,12,13,14,15,13,14,15,16]
04:43:17 <baaba> > let liftM2 f x y = liftM f x `ap` y in liftM2 (+) [1..3] [10..13]
04:43:19 <lambdabot>   [11,12,13,14,12,13,14,15,13,14,15,16]
04:43:33 <roderyk> using hxt-8.1.0, I'm getting: No instance for (XmlPickler Double), using import Text.XML.HXT.Arrow.Pickle. Is this really true, or is there something off with my code?
04:43:36 <baaba> @pl \f x y -> liftM f x `ap` y
04:43:36 <lambdabot> liftM2
04:43:39 <baaba> haha
04:43:41 <Axman6> heh
04:43:56 <baaba> @unpl liftM2
04:43:56 <lambdabot> (\ c d e -> d >>= \ b -> e >>= \ a -> return (c b a))
04:45:12 <jethr0> it's amazing how @unpl can generate so much verbosity from so little
04:45:16 <baaba> @pl \f x y -> liftM f x `g` y
04:45:16 <lambdabot> (g .) . fmap
04:45:24 <baaba> :t (ap .) . fmap
04:45:25 <lambdabot> forall a b a1 (f :: * -> *). (Functor f, Monad f) => (a1 -> a -> b) -> f a1 -> f a -> f b
04:45:27 <Axman6> jethr0: @pl can be far worse
04:45:44 <baaba> @pl \f x y z -> liftM f x y `g` z
04:45:44 <lambdabot> ((g .) .) . fmap
04:45:45 <Saizan> roderyk: the instance might be defined in a module you aren't importing
04:45:46 <baaba> erm
04:45:49 <baaba> @pl \f x y z -> liftM2 f x y `g` z
04:45:49 <jethr0> my personal favorite is still its use of "(f .) .) .)" etc.
04:45:49 <lambdabot> ((g .) .) . liftM2
04:45:50 <Axman6> @pl \q w e r t y u i o p -> t y p e w r i t e r
04:45:53 <lambdabot> const ((((((const . (const .)) .) .) .) .) . flip flip id . ((ap . (flip .) . ((flip .) .)) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . join . (flip .) . ((flip .) .) . (((flip .) .) .) .
04:45:53 <lambdabot> ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip flip id . (flip .) . ((ap .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((flip .) .) .) .) . (flip .) . ((flip
04:45:53 <lambdabot> .) .) . (((flip .) .) .) . flip (flip . (flip .) . ((flip .) .) . flip (flip . (flip .))))
04:45:53 <lambdabot> optimization suspended, use @pl-resume to continue.
04:45:54 * Axman6 ducks
04:46:35 <sleven> mmorrow: I do the computation ina let, then mapM_ print tags. ouclnt i strictness annotate the let then it would print automatically?
04:47:17 <Axman6> anyone see this? http://eigenclass.org/R2/writings/extprot-extensible-protocols-intro
04:47:42 <sleven> how do I strictness annotate agaiN?
04:48:19 <mmorrow> you can use a "!", but that'll only force one-level
04:48:26 <mmorrow> , let !x = 1 + 1 in x
04:48:28 <lunabot>  2
04:48:49 <mmorrow> you can use "rnf" if you want, but 99% of the time this isn't what one would want
04:49:00 <mmorrow> Control.Parallel.Strategies.rnf
04:49:23 <mmorrow> , let x = 1 + 1 in rnf x `seq` x
04:49:25 <lunabot>  2
04:49:37 <mmorrow> , let x = [0..100000] in rnf x `seq` x
04:49:40 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
04:49:46 <mmorrow> , let x = [0..1000000000000] in rnf x `seq` x
04:49:49 <lunabot>  luna: out of memory (requested 1048576 bytes)
04:49:53 <mmorrow> , let x = [0..1000000000000] in x
04:49:55 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
04:50:03 <Axman6> sleven: there's also seq
04:50:33 <mauke> > let x = [undef] in rnf x `seq` 42
04:50:34 <lambdabot>   Not in scope: `undef'
04:50:40 <mauke> > let x = [undefined] in rnf x `seq` 42
04:50:40 <lambdabot>   Add a type signature
04:50:53 <mauke> oh, you silly bot
04:51:09 * Counter-Strike slaps lambdabot
04:51:11 <Counter-Strike> :P
04:51:12 <mauke> > let x = [(),undefined] in rnf x `seq` 42
04:51:13 <lambdabot>   * Exception: Prelude.undefined
04:51:16 <mmorrow> @slap lambdabot
04:51:16 * lambdabot would never hurt lambdabot!
04:51:19 <mmorrow> haha
04:51:21 <mmorrow> @slap lambdabot
04:51:21 * lambdabot pulls lambdabot through the Evil Mangler
04:51:35 <mauke> @shapr mmorrow
04:51:36 * lambdabot moulds mmorrow into a delicous cookie, and places it in her oven
04:51:43 <mmorrow> heh
04:51:57 <mauke> ... so I hear you're "baked"
04:52:06 <mmorrow> oh yesh
04:52:34 <roderyk> Saizan: I couldn't find any sub-module that pickles double. I made an instance with the same primitive used for integers (using read/show), but I wonder if there was a good reason why they avoided pickling it...
04:54:33 <mm_freak> i'd like to output colored text, what's the preferred method?
04:55:28 <mauke> http://hackage.haskell.org/packages/archive/ansi-terminal/0.5.0/doc/html/System-Console-ANSI.html looks relevant
04:55:36 <twb> mm_freak: the vty package, maybe?
04:55:53 <twb> vty does more than just colours, though...
04:56:27 <twb> In general I have been pretty disappointed with the Haskell libraries for tty users; everyone seems to want GUIs these days :-(
04:56:36 <mm_freak> mauke: exactly what i was looking for, thanks
04:56:41 <mm_freak> twb: vty does too much
04:56:48 <twb> mm_freak: okie dokey
04:57:41 <sleven> http://hpaste.org/14016 , how would I enforce strictness on that?
04:57:56 <sleven> http://haskell.org/ghc/docs/latest/html/libraries/base/GHC-Arr.html#v:listArray, I want a function sbumatrix: submatrix Matrix indices -> Matrix. where indices is given like ((0,0),(0,1)) for elem 1 and 2 on the first row. i cant find a function that does that? is there or i have to write my own?
04:59:58 <Axman6> > 2^128
04:59:59 <lambdabot>   340282366920938463463374607431768211456
05:03:23 <luqui> > fix . foldr (.) id . map (:) $ [1,2,3,4,5]
05:03:24 <lambdabot>   [1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,...
05:05:56 <hugo___> is there anything similar to C's printf in haskell ?
05:06:17 <lucca> which aspect of printf?
05:06:19 <mauke> > ""++ printf "Hello, %d %s" 42 "world"
05:06:20 <lambdabot>   "Hello, 42 world"
05:06:29 <hugo___> yes, that
05:06:33 <hugo___> good :D
05:06:36 <lucca> heh
05:07:32 <hugo___> it must really wicked haskell code
05:07:40 <hugo___> *be*
05:07:41 <qwr> > ""++ printf "Hello, %s %d" 42 "world"
05:07:43 <lambdabot>   "Hello, * Exception: Printf.printf: bad argument
05:08:20 <hugo___> :D
05:08:23 <hugo___> this is not C
05:08:23 <hugo___> :D
05:08:25 <mmorrow> , $(printf "%s: %d") "val" 42
05:08:29 <lunabot>  "val: 42"
05:08:39 <mmorrow> , $(printf "%s: %d") 42 "val"
05:08:43 <lunabot>  luna: No instance for (GHC.Real.Integral [GHC.Types.Char])
05:08:55 <mornfall> @src printf
05:08:55 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
05:08:56 <mmorrow> the TH printf is nice too
05:08:58 <mornfall> Pff. :)
05:09:10 <mmorrow> heh, it's more that a few lines
05:09:35 <mmorrow> , [$ty| $(printf "%s: %d") |]
05:09:40 <lunabot>  Killed.
05:09:42 <mmorrow> , [$ty| $(printf "%s: %d") |]
05:09:48 <lunabot>  Killed.
05:09:51 <mmorrow> sigh
05:10:11 <Badger> @src Text.printf
05:10:12 <lambdabot> Source not found. You speak an infinite deal of nothing
05:10:15 <Badger> huh
05:10:27 * mmorrow ups lunabot's time rlimit
05:10:31 <mornfall> Looks like clever typeclass hackery. :)
05:10:53 <mmorrow> http://darcs.haskell.org/libraries/base/Text/Printf.hs
05:11:02 <mmorrow> it is exactly that
05:11:06 <Badger> :t printf "%s: %d"
05:11:08 <lambdabot> forall r. (PrintfType r) => r
05:11:20 <mmorrow> the TH one though can statically determine types though
05:11:30 <Badger> also: if I don't typesig, apparently it's a data constructor?
05:11:32 <mmorrow> because it computes the type from the string
05:11:44 <mornfall> Yes, but TH is still a little icky.
05:11:56 <mmorrow> mornfall: how so?
05:12:01 <mmorrow> (and the TH one doesn't need a sig)
05:12:02 <sleven> how do I read an IO Handle to a ByteString?
05:12:08 <sleven> how do I read an IO Handle to a ByteString?
05:12:15 * mauke recommends http://hackage.haskell.org/cgi-bin/hackage-scripts/package/printf-mauke
05:12:29 <Badger> > printf "mauke"
05:12:30 <lambdabot>   Add a type signature
05:12:53 <Axman6> > (fromIntegral $ 2^128) :: Double
05:12:54 <lambdabot>   3.402823669209385e38
05:13:00 <hugo___> amazing :)
05:13:00 <mmorrow> , $(printf "mauke")
05:13:05 <lunabot>  "mauke"
05:14:15 <mmorrow> sleven: looks at the ByteString haddocks
05:14:29 <mmorrow> http://www.haskell.org/ghc/dist/current/docs/libraries/
05:14:32 <Axman6> > (fromIntegral $ 2^128) :: CReal
05:14:33 <lambdabot>   340282366920938463463374607431768211456.0
05:15:28 <mornfall> mmorrow: It seems to me that it doesn't work as part of ghc --make, for some reason.
05:15:47 <mmorrow> mornfall: what doesn't? TH?
05:15:49 <mornfall> mmorrow: Yes, TH.
05:15:59 <mmorrow> i don't know what you're talking about :)
05:16:08 <tjb> With lamba function how do I put a type constraint on:
05:16:13 <tjb> let shex = (\x -> showHex (toInteger(x)) "" )
05:16:31 <tjb> where I want "x" to be a Word64
05:16:48 <maltem> tjb: let shex :: Word64 -> ...; shex = ...
05:16:48 <mmorrow> mornfall: that shouldn't be the case. maybe something else is going wrong?
05:16:55 <mauke> :t showHex
05:16:56 <lambdabot> forall a. (Integral a) => a -> String -> String
05:17:02 <mauke> let shex x = showHex (x :: Word64) ""
05:17:05 <Axman6> > 2.7e39/6e23 * 28
05:17:06 <lambdabot>   1.26e17
05:17:06 <mornfall> mmorrow: http://hpaste.org/14017 seems to be needed to compile with TH... I haven't written that invocation, though..
05:17:09 <Axman6> oi!
05:17:14 * mmorrow looks
05:17:23 <tjb> mauke, maltem: ah, thanks
05:17:56 <mornfall> mmorrow: We used to use DrIFT and it looked considerably simpler to me. (Switched to Data.Derive...)
05:17:59 <mmorrow> mornfall: what was the error it gave you with make?
05:18:06 <Axman6> does lambdabot still announce URL's?
05:18:08 <mornfall> Good question.
05:18:18 <vixey> www.goooooooooooogle.com
05:18:19 <mmorrow> perhaps you didn't give ghc -XTemplateHaskell
05:18:31 <mmorrow> (either at the cmd line, or in a LANGUAGE pragma)
05:18:33 <mornfall> mmorrow: I have {-# LANGUAGE TemplateHaskell #-} in there...
05:18:34 <vixey> http://www.cs.swan.ac.uk/~csetzer/research/researchprofile.html
05:18:53 <vixey> seems not to..
05:18:57 <Axman6> nope, ta vixey
05:19:00 <mmorrow> mornfall: without the error msg from --make, i'm not sure. but if this really is the case, then it's a bug.
05:19:02 <vixey> OH if you meant Hpastes... then no
05:19:12 <vixey> but it was a differetn bot that does hpastes I thought
05:19:33 <mornfall> mmorrow: I'm running the compile, I'll try to give you the error, although last time I couldn't compile the code for some other reason. :\
05:19:59 <mmorrow> mornfall: cool :)
05:20:49 <mornfall> Ok, the last time it was due to old version of Data.Derive. So let's see.
05:21:11 <hugo___> :)
05:22:18 <mornfall> Hm. With second line alone, I get ghc-6.8.2: /home/mornfall/dev/divine/branch-2.0-lis/examples/Divine/module_init.o: unknown symbol `__stginit_BenchmarkHs'
05:23:35 <Axman6> vixey: nah i meant URL titles. though i do wish hpaste was still working :(
05:23:36 <mmorrow> hmm
05:24:12 <mmorrow> mornfall: i'm confused, do you suspect TH to be somehow indeirectly the cause of this?\
05:24:21 <mmorrow> *indirectly
05:25:06 <mornfall> mmorrow: It worked fine with one --make invocation before we started using TH.
05:25:19 <sleven> Lennart Augustsson: you think I should study CS civil engineer or tehcnical mathematics civ eng in Lund if im interested in: datamining/machine learning/formal verification of programs/computer games ?
05:25:55 <mornfall> Let me try with ghc 6.10...
05:26:21 <mmorrow> ah, i see. it looks like a linker issue.. maybe derive has something to do with it
05:26:46 <mmorrow> i'm not really sure though
05:29:21 <mornfall> Anyhow, talking of this project... There's this TODO in RtsAPI.c, in rts_lock, where it grabs a global mutex... Anyone with an idea when is that going to see some improvement? : - )
05:29:41 <mornfall> (sched_mutex to be exact)
05:29:53 <mm_freak> can i trust (read . show) for ZonedTime to be (at least almost) id?
05:34:11 <mornfall> mmorrow: (Hm, same error with 6.10...)
05:34:58 <Yoric[DT]> Out of curiosity, is there anyone from Glasgow around here (besides the compiler :))?
05:36:17 <mmorrow> mornfall: (still confused) do you suspect this error to be TH/derive-related?
05:37:23 <mornfall> mmorrow: Well, I don't see any other possibility, since it works when no TH is involved.
05:37:43 <mmorrow> ok, i wonder where that sym is located
05:37:50 * mmorrow is looking
05:38:06 <sleven> how do I break a string to the next row?
05:38:41 <Ferdirand> ~.
05:39:16 <mauke> "a" ++ "b", "a\   \b"
05:39:45 <mlesniak> Is there a function (which I've obviously not found) to get the longest element from a list? Hoggle did not found anything good on [[a]] -> [a].
05:39:56 <mornfall> mmorrow: It should come from the BenchmarkHs module, and is used by module_init.c.
05:40:00 <mauke> :t maximumBy (comparing length)
05:40:01 <lambdabot> forall a. [[a]] -> [a]
05:40:15 <vixey> > maximumBy (comparing length) ""
05:40:16 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
05:40:16 <mlesniak> mauke: Ah, thanks
05:40:22 <mornfall> mmorrow: I guess ghc tries to link things in wrong order when TH is involved.
05:40:26 <vixey> > maximumBy (comparing length) []
05:40:27 <lambdabot>   * Exception: List.maximumBy: empty list
05:40:52 <mlesniak> vixey: thanks, too!
05:41:00 <mmorrow> mornfall: interesting. this is definitely bug-report material.
05:41:47 <mmorrow> possibly ghc computes dependencies before it runs the splices, and the splices are introducing a new dep (or something)
05:43:41 <mmorrow> but i guess that could only happen if the splice is spitting out a foreign import decl or something, and that foreign function itself depends on an additional haskell module (guessing)
05:43:43 <mornfall> Liskni_si: ping... Do you know something more about that link failure?
05:44:08 <mmorrow> (since TH can't add imports)
05:44:39 <mmorrow> but i don't think ghc can determine if an imported C function has /haskell/ deps anyhow
05:45:00 <mmorrow> (i'm not sure if this is even what's happening in this case)
05:45:16 <jamii> I think liftM13 is a sign a should refactor...
05:45:23 <vixey> Proof. Easy. [] heh
05:45:23 <jamii> *i should
05:45:47 <mornfall> mmorrow: http://divine.fi.muni.cz/trac/browser/examples has the code...
05:46:59 <vixey> hi mmorrow
05:47:19 <mornfall> (Another pet peeve of mine is that we have no clue how to emit INLINE pragmas from TH...)
05:48:51 <mmorrow> mornfall: yeah, it's a pain that TH doesn't do pragmas (although INLINE usually mean something naughty is being done ;), nor can it do GADTs, type/data families, or imports
05:49:02 <vixey> are you going to add outfix to your parser? to allow stuff like: [[ App m n ]] delta = [[ m ]] delta ([[ n ]] delta)
05:49:28 <mornfall> mmorrow: Well, naughty. I just need all the performance I can get. :)
05:49:40 <mornfall> And INLINE helps an awful lot.
05:49:43 <Heffalump> jamii: you can use return foo `ap` bar `ap` baz `ap` ... inplace of liftM<n> foo bar baz ...
05:50:15 <Axman6> hmm
05:50:34 <blackdog> if i set the -A1G in the RTS options to prevent a garbage collection happening, my linked C code works. If i don't, i get memory corruption. The C code doesn't call back to haskell: it may or may not be reentrant, i haven't exhaustively checked. Any ideas on what i should be looking for first?
05:50:35 <mmorrow> mornfall: heh, i just saw where you're using it, i was thinking about when one would use it for an unsafePerformIO'ed CAF
05:50:56 * Axman6 considers making a new linux distro which is purely aimed at haskell. latest GHC, Xmonad, all the useful haskell tools
05:51:18 <Heffalump> blackdog: reentrant in what sense?
05:51:19 <mmorrow> mornfall: maybe it'd work if you included BenchmarkHs.o in with module_init.c when you link it
05:51:22 <mornfall> Axman6: Like Arch? :)
05:51:40 <Axman6> mornfall: it's not as haskell centric as i'd be making :P
05:51:54 <blackdog> Heffalump: there may be static variables in the functions i'm calling in C land
05:52:16 <Heffalump> no, I mean how could the C functions be getting reentered? Threading? Interrupts?
05:52:22 <mmorrow> oh, i just realized what the build command was..
05:52:40 <blackdog> Heffalump: probably can't be, but i'm not conversant with the GHC runtime system
05:53:03 <Heffalump> ah, right. I don't see how it could be if there's no threading/par+unsafePerformIO.
05:53:26 <Heffalump> does the C side stash pointers given to it by the Haskell side?
05:53:31 <mmorrow> mornfall: i'm not sure exactly the dynamics of what's happening, but you may want to file a bug report if you can extract a good example of how ghc is failing
05:53:35 <blackdog> Heffalump: no
05:53:51 <blackdog> oh, hm. no, i don't think so.
05:54:11 <Heffalump> if it does you have to pin them on the Haskell side (ForeignPtr I think)
05:54:28 <Heffalump> otherwise, all I can think of is using a debugger and memory breakpoints to watch for the corruption
05:55:04 <blackdog> ah, that's an idea - so maybe when i pass the strings in, it's just stashing the pointers rather than copying them
05:55:47 <Heffalump> sorry, I mean StablePtr, not ForeignPtr
05:55:56 <blackdog> thanks, Heffalump - but that sounds like something to be tackled after 8 hours sleep
05:56:03 <mmorrow> or just mallocBytes and get a Ptr from the C heap..
05:57:54 <mornfall> mmorrow: Will try.
06:03:57 <sleven> Axman6: write the whole thing in assembler and Haskell
06:04:26 <Axman6> meh, too much effort
06:04:31 <sleven> how serious are the Haskell OSes? just proofs of concept?
06:04:54 <sleven> could a real OS be written in Haskell or there be too much overhead and unpredictable memory use?
06:05:12 <vixey> sleven, what would a proof of concept tell you?
06:13:04 <joma> so how do I get a new seed?
06:13:05 <joma> randElem = R.randomR (0,1::Double) (R.mkStdGen 7436876298)
06:13:15 <FunctorSalad> "case" is not treated specially as a do-statement, is it? (in a proc statement it is)
06:13:39 <joma> can I take the os time ore something?
06:13:55 <FunctorSalad> @undo do { x <- y; case x of { True -> return False; False -> return True } }
06:13:56 <lambdabot> y >>= \ x -> case x of { True -> return False; False -> return True}
06:14:31 <luqui> FunctorSalad, in proc case desugars to ArrowChoice
06:14:36 <FunctorSalad> proc hasn't become very popular yet, has it? ;)
06:14:40 <luqui> introducing new proc blocks wouldn't make sense
06:14:40 <FunctorSalad> (it is kinda confusing)
06:15:17 <luqui> well (1) arrows aren't that common, and (2) proc notation's desugaring is much more complex than do's
06:17:17 <FunctorSalad> proc x -> case x of { True -> a1 -< foo ; False -> a2 -< bar }    should desugar to arr (\x -> case x of { True -> Left foo; False -> Right bar }) >>> (a1 ||| a2) right?
06:17:30 <roderyk> http://hpaste.org/14021  Could someone take a look at this? I'm still struggling at groking arrows and I'm fighting with the type checker
06:17:56 <roderyk> I'd like to do some IO () with an unpickled value, w/o changing the actual XmlTree
06:18:14 <luqui> FunctorSalad, that or something equivalent by the laws.  ianm.
06:18:19 <FunctorSalad> roderyk: perform $ arrIO myIOAction ?
06:19:05 <roderyk> FunctorSalad: ah, didn't know about perform. thanks :)
06:19:49 <FunctorSalad> roderyk: it should amount to something like "perform f = ( f &&& arr id ) >>> arr snd"
06:20:19 <FunctorSalad> it runs the argument arrow (f) but discards the result and passes through the original result
06:21:03 <FunctorSalad> it is a bit confusing because lazyness would seem to indicate that f is never evaluated on the RHS... but it is in the &&& instance of arrows with side-effects I think
06:21:26 <roderyk> FunctorSalad: actually, I'm still a little lost. Converting it to perform still gives me the same typecheck problem..
06:22:02 <FunctorSalad> runKleisli (Kleisli putStrLn &&& Kleisli (return 0)) should be (\x -> putStrLn x >> return 0) or so
06:22:51 <FunctorSalad> roderyk: did you ensure the think passed to peform is an *arrow*?
06:23:21 <FunctorSalad> you can convert an IO value into an arrow by "arrIO (\_ -> myIOValue)"
06:23:48 <FunctorSalad> (or replace the _ by a variable if you want to use the output of the previous arrow)
06:24:31 <joma> *Matrix> R.newStdGen
06:24:31 <joma> 1826349268 1655838863 , so how do I get the value from that since fst and snd doesnt work?
06:24:31 <joma> i just want a function that returns a new random number each time
06:24:31 <joma> must pe possible to construct right?
06:24:32 <joma> what is Ord ?
06:25:13 <Axman6> @src Ord
06:25:13 <lambdabot> class  (Eq a) => Ord a  where
06:25:13 <lambdabot>     compare      :: a -> a -> Ordering
06:25:13 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
06:25:13 <lambdabot>     max, min         :: a -> a -> a
06:26:40 <mauke> :t randomIO
06:26:41 <lambdabot> forall a. (Random a) => IO a
06:26:44 <joma> what is Ord ? it is for < and > comparisment only?
06:26:47 <mauke> there's your "function"
06:27:38 <Axman6> joma: it's a class which has instances for types which you can compare their ordering
06:27:48 <Axman6> like numbers, characters etc
06:27:57 <Axman6> @instances Ord
06:27:58 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
06:28:18 <Axman6> @src Maybe Ord
06:28:18 <lambdabot> Source not found. :(
06:28:22 <Axman6> :(
06:28:33 <mauke> @src Maybe compare
06:28:34 <lambdabot> Source not found. :(
06:29:20 <Axman6> > compare Nothing Nothing
06:29:21 <lambdabot>   EQ
06:29:29 <Axman6> > compare Nothing (Just 3)
06:29:30 <lambdabot>   LT
06:30:11 <Axman6> > compare (Just 4) (Just 3)
06:30:11 <Axman6> GT...
06:30:12 <lambdabot>   GT
06:32:06 <roderyk> FunctorSalad: nope, still not getting it. If perform drops everything, I'm still going to need to return the original input somehow (because processRoot expects an XmlTree). Could you possibly try to explain it using http://hpaste.org/14021#a1 example?
06:33:09 <olsner> how surprising: "Function composition is ugly in PHP" :P
06:33:17 <mauke> haha
06:33:30 <mauke> ITYM impossible
06:33:49 <FunctorSalad> roderyk: processRoot is not a function, you can't apply it to something
06:34:29 <olsner> said by someone who went from haskell to php: http://www.reddit.com/r/programming/comments/7qcza/so_my_boss_saysive_noticed_you_guys_have_been/c073iy2
06:37:36 <FunctorSalad> roderyk: arrows aren't directly applied to arguments; they're composed using >>>. I'm not sure whether you really want processRoot to be recursive?
06:39:18 * bremner feels guilty for pointing roderyk to hxt. I basically use cookbook examples and don't really understand arrows
06:39:43 <joma> hmm does ord make sense to define for a Matrix? deriving seems risky
06:39:45 <roderyk> FunctorSalad: oh, jeez... that was some kind of brain fart. The function I was thinking of is 'processTopDown'
06:39:56 <roderyk> FunctorSalad: sorry for the confusion :)
06:40:15 <roderyk> bremner: it's ok, I'm banging my head but hopefully some good will come of this :)
06:40:28 <roderyk> (as long as admins don't kick me off #haskell for asking stupid questions)
06:40:35 <FunctorSalad> *nod*, hxt is weird in the beginning but not bad once you've used it a bit
06:40:37 <bremner> roderyk: ok, let me know if you want to look at the code of another confused person
06:41:30 <FunctorSalad> maybe it helps to think of "A b c" for some Arrow A as "b -> M c" for some Monad M
06:41:50 <FunctorSalad> (in fact, if the Arrow is an ArrowApply, it is always of that form)
06:42:07 <luqui> FunctorSalad, lies!
06:42:27 <SamB_XP_> luqui: what lies ?
06:42:49 <FunctorSalad> luqui: isomorphic?
06:42:54 <acidjnk> hello
06:42:56 <luqui> yeah.
06:42:59 <luqui> I was just being pedantic.
06:43:04 <SamB_XP_> ArrowMonad
06:43:21 <SamB_XP_> Kleisli
06:43:29 <olsner> maybe that's what Kleisli should be called though :)
06:43:31 <luqui> just because something has an ArrowApply doesn't mean it *is* a kleisli arrow, just that it is isomorphic to one
06:43:33 <acidjnk> I get a parse error here: let curry2 = \((\((a,b)->c))->a->b->c) why is that?
06:43:41 <vixey> :t \((\((a,b)->c))->a->b->c)
06:43:42 <lambdabot> parse error on input `->'
06:43:47 <luqui> O
06:43:47 <vixey> :t \((\((a,b)->c))->a b c)
06:43:48 <lambdabot> parse error on input `->'
06:43:55 <vixey> :t \(\((a,b)->c))->a b c
06:43:56 <lambdabot> parse error on input `->'
06:44:09 <SamB_XP_> olsner: what ?
06:44:09 <vixey> I suppose  (\((a,b)->c))  isn't a variable name
06:44:17 <SamB_XP_> ArrowMonad goes the other way
06:44:28 <joma> where is join?
06:44:32 <olsner> SamB_XP_: so, MonadArrow then?
06:44:36 <luqui> joma, Control.Monad?
06:44:53 <Axman6> @hoogle join
06:44:53 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
06:44:53 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
06:44:53 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
06:45:09 <acidjnk> so in this lambda notation there are rules which I violated?
06:45:25 <vixey> ye
06:45:32 <acidjnk> thanks
06:46:03 <joma> anyone can explain how to: randElem seed = R.newStdGen (0,1::Double) or something so I can call a functiona nd get a new value each time?
06:46:14 <joma> how can I get the values from newStdGen?
06:46:27 <luqui> joed, using a function like randoms
06:46:29 <luqui> or randomR
06:47:12 <chessguy_> joma:  haskell doesn't allow you to pass the same thing to a function and get a different value back
06:47:44 <luqui> randElem = randomRIO (0,1)
06:47:55 <SamB_XP_> luqui: please, no!
06:47:57 <joma> not even in a do?
06:47:57 <joma> isnt that what monads are for?
06:48:18 <chessguy_> not quite
06:48:19 <luqui> SamB_XP_, I don't know why everybody hates randomRIO so much.  he's already in IO.
06:48:32 <SamB_XP_> luqui: the global state ...
06:48:53 <chessguy_> joma:  check out http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Randoms
06:48:56 <maltem> joma: monads aren't "for something" really, they're just a certain (very useful) kind of structure
06:49:03 <luqui> SamB_XP_, frankly I find working purely with random numbers really annoying, without a module like MonadRandom
06:49:10 <maltem> joma: but really, for side effects, there is the IO monaddddd
06:49:13 <maltem> oops
06:49:31 <SamB_XP_> it's spelled monaaaaad
06:49:45 <maltem> (stupid wireless keyboards ;-)
06:49:49 <luqui> (I like MonadRandom though, because the monad has a nice semantics :-)
06:50:04 <joma> and i want a double
06:50:04 <joma> and SamB_XP_: why not?
06:50:47 <SamB_XP_> joma: I said already! the global state...
06:50:53 <luqui> joma, randoms can be done purely, and we like to keep it pure when we can.
06:51:17 <luqui> I suggest http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MonadRandom
06:51:55 <luqui> assuming you're using randoms in a nontrivial way
06:53:04 <chessguy_> luqui:  err, that looks like it still requires IO
06:53:14 <luqui> chessguy, what do you mean requires?
06:53:18 <chessguy_> or am i missing something
06:53:18 <luqui> it can use IO
06:53:28 <chessguy_> "To extract a value from the Rand monad, we can can use evalRandIO."
06:53:34 <luqui> evalRand
06:53:41 <luqui> takes a gen
06:53:46 <joma> and why does it work in prelude but not in file?
06:54:05 <roconnor> Why does Traversable have to be Foldable?
06:54:11 <luqui> joma, ghci automatically executes IO actions
06:54:13 <maltem> luqui: so wow, but where do you get a random generator?
06:54:26 <chessguy_> oh i see
06:54:30 <luqui> maltem, mkStdRandom?
06:54:59 <Liskni_si> mornfall: cc complaining about __stginit_<MODULE> being undefined, if that's what you were talking about
06:55:09 <maltem> luqui: you mean mkStdGen? That's not a *random* generator
06:55:59 <luqui> maltem, so, sire advocate, where do *you* get a random number when you want one?
06:56:31 <roconnor> @hoogle foldr
06:56:31 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
06:56:31 <lambdabot> Data.ByteString foldr :: (Word8 -> a -> a) -> a -> ByteString -> a
06:56:31 <lambdabot> Data.Foldable foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
06:56:36 <SamB_XP_> luqui: random.org
06:56:58 <ivanm> > random (mkStdGen 1)
06:56:59 <lambdabot>   (7917908265643496962,545291967 2103410263)
06:57:03 <ivanm> luqui: ^^
06:57:07 <joma> so basically a pure random fucntion always need  parameter and a randomfunction without parameter thus a monad
06:57:09 <maltem> luqui: not differently from anyone else. but the point is that MonadRandom is just a handy wrapper
06:57:15 <luqui> ivanm, I know.  we're having some kind of silly philosophical argument.
06:57:25 <luqui> maltem, yeah, but it has a nice semantics, independent of generators
06:57:30 <ivanm> luqui: oh ;-)
06:57:41 <maltem> luqui: ok, point taken.
06:57:52 <luqui> unfortunately the docs make no mention of said semantics
06:57:58 <luqui> they might not even know they have them :-)
06:57:59 <joma> http://hpaste.org/14023
06:58:21 <mm_freak> > drop 64 . map (.&. 1) . iterate ((`mod` 11073215066555121313) . (^2)) $ 2
06:58:22 <lambdabot>       Ambiguous occurrence `.&.'
06:58:22 <lambdabot>      It could refer to either `Data.Bits..&....
06:58:30 <mm_freak> > drop 64 . map (`mod` 2) . iterate ((`mod` 11073215066555121313) . (^2)) $ 2
06:58:32 <lambdabot>   [1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,1,...
06:58:34 <roconnor> @src reverse
06:58:35 <lambdabot> reverse = foldl (flip (:)) []
06:58:51 <mm_freak> > drop 64 . map (`mod` 2) . iterate ((`mod` 158898678512166998515090523653746626561) . (^2)) $ 2
06:58:52 <lambdabot>   [1,0,0,0,1,1,0,1,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,0,1,0,0,0,1,...
06:59:08 <joma> i want a function: randDouble :: Double
06:59:10 <chessguy> joma:  what is the type of randDouble ?
06:59:20 <chessguy> (it's not Double)
06:59:32 <roconnor> > (\l a r -> foldl (flip (:)) (a:r) l) [3,2,1] 4 [5,6,7]
06:59:33 <lambdabot>   [1,2,3,4,5,6,7]
06:59:38 <luqui> joma, if randDouble :: Double, then randDouble is some number
06:59:46 <luqui> it can't be different from itself
07:00:17 <luqui> it might be random in the xkcd sense :-)
07:00:22 <joma> or randDouble :: seed -> Double
07:00:22 <joma> IO Double
07:00:22 <joma> i know why the error is
07:00:22 <joma> just how do i get a new seed each time
07:00:22 <joma> ?
07:00:23 <joma> im trying to get one out of newStdGen but i dont get how
07:00:30 <roconnor> @seen jeffwheeler
07:00:31 <lambdabot> I saw jeffwheeler leaving #haskell 6h 48m ago, and .
07:00:39 <luqui> http://xkcd.com/221/
07:00:41 <roconnor> @tell jeffwheeler http://hpaste.org/14006#a1
07:00:42 <lambdabot> Consider it noted.
07:01:01 <chessguy> xkcd++
07:01:17 <maltem> joma: seed is called generator in the System.Random library, and you can get an initial one from e.g. newStdGen
07:02:05 <Axman6> @karma xkcd
07:02:05 <lambdabot> xkcd has a karma of 1
07:02:31 <maltem> joma: also, you always get a new seed when you ask for a number with 'random'
07:02:51 <luqui>  do { g <- newStdGen; return (randomR (0,1::Double) g) }
07:03:07 <luqui> or if you don't want the generator tagging along:
07:03:25 <luqui> do { g <- newStdGen; return (fst (randomR (0,1::Double) g)) }
07:03:37 <mm_freak> @let randomNumber = 4
07:03:38 <lambdabot>  Defined.
07:03:58 <luqui> oh good, then I can generate truly random values
07:04:00 <joma> but how do I keep it pure?
07:04:00 <joma> does a do always cause IO?
07:04:07 <chessguy> aka neStdGen >>= fst . randomR (0,1::Double)
07:04:18 <luqui> > randomR (0,1::Double) (mkStdGen randomNumber )
07:04:20 <lambdabot>   (0.47519259899277067,1563150291 1655838864)
07:04:22 <maltem> joma: no, but newStdGen needs IO
07:04:43 <luqui> joed, to keep it pure you need to pass a generator around
07:04:44 <mm_freak> > repeat randomNumber
07:04:45 <lambdabot>   [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
07:04:53 <luqui> er
07:04:56 <luqui> joma, ^^
07:05:04 <joma> @randomNumber
07:05:04 <lambdabot> Unknown command, try @list
07:05:31 <maltem> joma: there's no way to keep it even purer, you need to use something like newStdGen once
07:05:31 <luqui> joma, which, again, I suggest you do using MonadRandom :-)
07:05:47 <blackh> joma: Or use randoms
07:05:55 <luqui> yeah randoms is nice for simple cases
07:07:08 <maltem> (The System.Random API documentation should really have some examples in it.)
07:07:18 <joma> luqui: ok thats what i mean , so how?
07:07:18 <joma> it makes ismple functions so complex
07:07:18 <joma> matrix01 r c = let m = matrix r c 0 in foreach randDouble m
07:07:34 <joma> yeah overall I think Haskell docs lack examples
07:07:52 <mm_freak> joma: the 'do' keyword is slightly misleading…  it's just syntactic sugar for monadic combinators
07:07:53 <luqui> definitely.  big haskell-cafe thread going on calling for better docs
07:08:27 <mm_freak> > do x <- [1,2,3]; y <- [4,5,6]; return (x^2 + y^2)
07:08:28 <lambdabot>   [17,26,37,20,29,40,25,34,45]
07:08:48 <luqui> joma, when you want a random number, use eg.: do { r <- getRandomR (0,1); return ( ... r ... ) }
07:08:51 <mm_freak> > [1,2,3] >>= \x -> [4,5,6] >>= \y -> return (x^2 + y^2)
07:08:52 <joma> good docs but no examples
07:08:53 <lambdabot>   [17,26,37,20,29,40,25,34,45]
07:09:07 <luqui> to me examples are part of good docs
07:09:29 <luqui> I was always impressed by many perl modules' documentation; the intro section usually included a mini-tutorial
07:11:05 <luqui> joma, you probably want the plain-vanilla Rand monad, if you're being pure about it
07:11:27 <SamB_XP_> luqui: file a haddock bug about how that isn't easy to do ?
07:11:30 <mm_freak> > runCont (callCC $ \k -> k 5) id
07:11:31 <lambdabot>   5
07:11:58 <luqui> SamB_XP_, hmm?
07:12:01 <mm_freak> :t runCont (callCC $ \k -> k k)
07:12:02 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> m b
07:12:02 <lambdabot>     Probable cause: `k' is applied to too few arguments
07:12:02 <lambdabot>     In the first argument of `k', namely `k'
07:12:14 <SamB_XP_> luqui: well, how would YOU do it ?
07:12:20 <luqui> SamB_XP_, do what?
07:12:36 <SamB_XP_> write such a mini-tutorial in your library documentation ?
07:13:01 <luqui> SamB_XP_, well, I actually tried to a little, when I first came here from perl.  then I fell into the culture, unfortunately.
07:13:09 <joma> but how can I map over a structure and for each get a new random number?
07:13:14 <luqui> SamB_XP_, i'd just put it at the head of the docs for the module
07:13:24 <luqui> you know, in haddock before the module keyword
07:13:35 <ivanm> joma: mapAccumL ?
07:13:37 <mm_freak> i'd put it at the end for the sake of programmer's convenience
07:13:47 <luqui> scrolling is not that hard
07:13:47 <mm_freak> -- $tutorial
07:13:49 * ivanm is coming in halfway a conversation again, and thus his suggestion mightn't be relevant
07:14:02 <luqui> mm_freak, oh, that's interesting.  I am not haddock-leet
07:14:28 <mm_freak> luqui: programmers working on the code don't need that tutorial, that's why i think it's better at the end
07:14:38 <luqui> joma, forM xs (\x -> do { r <- getRandomR (0,1); ... })
07:15:25 <luqui> mm_freak, sure, ok.  I don't really care, as long as its easy to make and to read.  what's this -- $  notation?
07:16:16 <mm_freak> it's placeholder syntax, which you can use in the module documentation part
07:16:23 <luqui> joma, it's a bit imperative feeling.  You could also get an infinite list of random numbers beforehand with getRandomRs
07:16:28 <luqui> and then zip with it
07:16:50 <mm_freak> just write '$tutorial' there, then you can write '$tutorial' somewhere else, where you want to place the actual documentation
07:17:18 <luqui> oh ok
07:17:25 <mm_freak> luqui: http://haskell.org/haddock/doc/html/ch03s05.html
07:21:15 <int80_h> good morning haskell
07:21:19 <int80_h> @haskell
07:21:19 <lambdabot> Unknown command, try @list
07:21:23 <int80_h> #haskell!
07:21:26 <int80_h> ugh
07:23:56 <hugo___> where can i learn about monoids and their uses ?
07:24:19 <BONUS> just take a look at the documentation for Data.Monoid
07:26:13 <roconnor> read the paper on finger trees?
07:26:14 <luqui> hugo___, the most potent example of a monoid, is the Writer monad.  I.e., (w,a) is a monad on a whenever w is a monoid
07:26:57 <joma> is there a builtin for positive nbr?
07:27:08 <luqui> > (> 0)  42
07:27:09 <lambdabot>   True
07:27:29 <roconnor> luqui: (0<) is better
07:27:39 <luqui> roconnor, not for my brain
07:27:55 <hydo> Can anyone clue me in to the supposed interpretive dance required to get HXT to support unicode?  I can't seem to get the practical examples from the haskell wiki to run.
07:28:01 <roconnor> luqui: but yours is backwards.
07:28:21 <mauke> ((<) 0)
07:28:34 <luqui> roconnor, true, I suppose.  I have a connection between positive and greater in my head though
07:28:45 <roconnor> luqui: oh, interesting
07:28:48 <joma> ie pos x = x >= 0
07:28:50 <luqui> or maybe my brain is the thing that is backwards
07:29:12 <luqui> joma, right.  just use a section:  (>= 0)
07:29:20 <luqui> :t (>= 0)
07:29:21 <lambdabot> forall a. (Ord a, Num a) => a -> Bool
07:29:34 <SamB_XP_> but 0 is NOT positive
07:29:37 <roconnor> joma: that is non-negative
07:29:55 <unigee> hi, could some one please explain how to print a number to two decimal places? i.e sqrt 2 should end up as 1.41 ?
07:29:56 <luqui> sigh: mathematicians.  can't live with 'em, can't prove 'em wrong.
07:30:02 <vixey> lol
07:30:08 <vixey> @remember <luqui> sigh: mathematicians.  can't live with 'em, can't prove 'em wrong.
07:30:08 <lambdabot> I will never forget.
07:30:18 <mauke> @quote <luqui>
07:30:18 <lambdabot> <luqui> says: sigh: mathematicians.  can't live with 'em, can't prove 'em wrong.
07:30:21 <mauke> :-|
07:30:37 <mauke> > ""++ printf "%.2f" (sqrt 2)
07:30:38 <lambdabot>   "1.41"
07:30:49 <roconnor> @quote
07:30:49 <lambdabot> wilx says: I mean, besides the murders, it all looks so nice.
07:30:52 <unigee> thanks
07:30:59 <iago_> someone knows why Haskell lacks of a "standard" collection type-class hierarchy? ;P
07:31:12 <mauke> @where edison
07:31:12 <lambdabot> http://www.cs.princeton.edu/~rdockins/edison/home/
07:31:19 <luqui> hmm.  Are there nicer numeric formatters than printf?
07:31:27 <roconnor> hierarchy?
07:31:39 <roconnor> do collections for a hierarchy?
07:31:42 <roconnor> form
07:31:50 <iago_> mauke, edison is not "standard"
07:32:19 <luqui> iago_, well, "standard" is a stupid thing to talk about.  it only causes flame wars and hurt feelings.
07:32:20 <iago_> roconnor, a hierarchy of type-classes defining interfaces for different type of collections
07:32:47 <luqui> iago_, what might it look like?
07:33:04 <luqui> if you start designing it, you might understand :-)
07:33:22 <iago_> I start, very few time in it ;P
07:33:42 <bremner> edison is in debian. Therefore standard... :-)
07:33:47 <iago_> anyway should be simple enough, you want to take care of all special cases
07:33:50 <luqui> basically there's not all that much you can abstract from collections.
07:33:56 <iago_> you don't want*
07:34:18 <roconnor> being immutable might remove some of the normal imperitive classes
07:34:26 <roconnor> classes of collections
07:34:55 <SamB_XP_> I tried once
07:35:07 <iago_> luqui, standard is not stupid
07:35:19 <roconnor> wow Edison look neat
07:35:34 <SamB_XP_> I couldn't get map to constrain the input and output to be of the same sort of collection, though :-(
07:35:38 <luqui> iago_, my argument for why it is is that it stifles healthy competition
07:36:03 <luqui> iago_, once something is standard, everybody wants to use it and alternatives are no longer considered
07:36:18 <luqui> case in point: mtl sucks.
07:36:18 <iago_> luqui, and when something is not standard you live in a hell
07:36:39 <luqui> iago_, that is a very cohesive argument that I will have to think a long time about
07:36:40 <roconnor> CollX is the root class of the collection hierarchy.
07:36:48 <roconnor> I guess there is a hierarchy after all
07:37:03 <vixey> iago_, you have to learn 3 different ways to import a SRFI :p
07:37:07 <pejo> iago, edison is on hackage, it's easy to use, depend on and link against.
07:37:13 <vixey> iago_, wouldn't really call that hell myself...
07:37:13 <iago_> luqui, I don't want to have to adapt the API of a library because it uses another collecion-classes
07:37:39 <luqui> iago_, first you find a library that uses collections at all :-)
07:37:43 <|roderyk|> this is probably a silly question (and I probably should just sit down and read all I can on arrows), but I have the following scenario and would love some input on what concepts best describe it: OrigTree >>> (applyFilter -> [Elem] -> ([Elem] -> [b]) -> ([b] -> IO ())) >>> OrigTree
07:37:52 <luqui> most of our library interfaces are more abstract than that :-)
07:38:02 <iago_> luqui, the lack of a std is sure the first reason why nobody uses it
07:38:03 <|roderyk|> so I guess 'perform' to drop computations and keep originally input
07:38:17 <luqui> iago_, well there are certainly Data.Map and Data.Set as standard
07:38:20 <|roderyk|> but I need something like processTopDown that accumulates a set of values; should this be arrow + state ?
07:38:38 <iago_> luqui, standard implementations, I prefer work with interfaces
07:38:54 <luqui> iago_, what interface would you like to work with?
07:39:24 <iago_> well, there are not strictly interfaces, although you can argue that all implementations uses the same structure
07:39:24 <luqui> iago_, you are free to create one and publish it on hackage to encourage use.
07:39:50 <iago_> luqui, this is not the question :P I ask because perhaps there is a good reason to don't do it
07:40:08 <luqui> iago_, there is a reasonably good reason.
07:40:16 <luqui> but it only becomes clear once you think harder.
07:40:24 <luqui> _what do you put in this hierarchy_?
07:40:36 <luqui> and then you realize that that question has no good answer
07:40:39 <roconnor> luqui: have you looked at Edison?
07:40:44 <luqui> er, maybe it does
07:40:46 <iago_> luqui, this happens with all interfaces. With this idea we must avoid any std interface
07:40:55 <luqui> I have not, I am blowing hot air :-)
07:41:10 <roconnor> I've only looked at it for the last 5 min
07:41:18 <roconnor> but it seems like something
07:41:33 <roconnor> has both collections and a hierarchy
07:41:40 <chessguy> edison ought to be on hackage
07:41:46 <Saizan> it is
07:41:49 <luqui> yeah, looks nice
07:41:54 <iago_> luqui, I know that there isn't a perfect solution, but this isn't a good reason
07:41:54 <Saizan> ?hackage edison
07:41:54 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/edison
07:42:08 <luqui> iago_, oh, also, I forgot to mention; there is already something like that
07:42:11 <chessguy> oh, it is
07:42:16 <roconnor> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/EdisonAPI-1.2.1
07:42:17 <Saizan> ok, the name is different :)
07:42:21 <luqui> iago_, Functor, Foldable, Traversable form a sort of collections hierarchy
07:42:32 <chessguy> yeah Saizan  :)
07:42:37 <roconnor> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/EdisonCore
07:42:42 <iago_> luqui, sure, but needs more :P
07:42:47 <luqui> iago_, what do you need?
07:43:02 <roconnor> Data.Edison.Coll.SplayHeap
07:43:08 <mauke> ENTERPRISE INTERFACE HIERARCHY
07:43:12 <roconnor> Data.Edison.Seq.MyersStack
07:43:12 <iago_> that my code doesn't depends on concrete types unnecessary
07:43:24 <luqui> iago_, I mean concretely.  what do you need that you are missing?
07:43:47 <roconnor> If Edison is the the only collections interface, does that mean it is the standard one?
07:43:56 <iago_> for example, something like Data.ListLike is frequently needed
07:44:13 <mauke> what operations?
07:44:14 <iago_> but again, I don't see it "standarized" (at least de-facto)
07:44:14 <roconnor> Data.Edison.Seq.ListSeq
07:44:30 <roconnor> operations: http://hackage.haskell.org/packages/archive/EdisonAPI/1.2.1/doc/html/Data-Edison-Seq-ListSeq.html
07:44:30 <chessguy> roconnor:  i wouldn't call anything "standard" unless it's in the standard library
07:44:35 <chessguy> personally
07:44:56 <roconnor> chessguy: the standard library hasn't changed in 10 years  assuming you mean the Prelude
07:45:03 <chessguy> i don't
07:45:06 <roconnor> ok
07:45:11 <chessguy> i mean http://haskell.org/ghc/docs/latest/html/libraries/index.html
07:45:18 <luqui> iago_, really?  List is initial for ListLike, why not use List?
07:45:24 <luqui> what does ListLike buy you?
07:45:38 <mauke> ListLike *is* List
07:45:39 <iago_> List?
07:45:46 <luqui> []
07:45:49 <roconnor> luqui: allows you to use Data.Seq?
07:45:53 <luqui> I spell it List, as it should be spelled?
07:45:54 <roconnor> for fast concat
07:45:59 <iago_> [a] is a concrete type
07:46:00 <luqui> roconnor, you and your arguments!
07:46:02 <luqui> touche :-)
07:46:18 <luqui> iago_, maybe you need to change your thinking to be okay with concrete types when they are okay
07:46:26 <luqui> although roconnor has a good point with Seq
07:46:50 <luqui> eg. I once wanted a Takeable typeclass, with a method:  take ;: t -> Maybe (a, t)
07:46:55 <luqui> but then I realized that Takeable is just []
07:46:56 <iago_> luqui, concrete types are usually not good
07:47:05 <mauke> iago_: I disagree
07:47:16 <roconnor> I agree with iago_
07:47:21 <luqui> I agree with God
07:47:39 <vixey> luqui, what's God's opinion on abstraction?
07:47:45 <vixey> :p
07:47:49 <luqui> it's the same as mine, obviously
07:47:54 <mauke> luqui: uncons :: t a -> b -> (a -> t a -> b) -> b
07:47:56 <mauke> :-)
07:48:33 <iago_> mauke, hard to understand your idea
07:48:41 <luqui> mauke, I am also lost :-)
07:49:00 <mauke> what, it's the same as yours except for the intermediate data structure
07:49:02 <iago_> I refer to why he disagrees
07:49:08 <luqui> mauke, oh right
07:49:18 <luqui> mauke, well, and parameterization of t
07:49:42 <luqui> mauke, you prefer the cps style?
07:49:59 <mauke> yeah
07:50:07 <luqui> I want to use the Maybe style and have my compiler change it to the more efficient one
07:50:13 <luqui> whichever it is
07:50:25 <luqui> or is it not for efficiency that you prefer this style?
07:50:37 <mauke> meh, I mean I'm going to case match on that Maybe anyway, so I might just pass the branches in the first place
07:51:09 <luqui> mauke, I can more obviously see what take is doing from its type in the Maybe case.
07:51:25 <luqui> but you have a point, I'm just going to pass it to maybe.
07:51:40 <luqui> oh, I guess you could pass it to unfoldr too, though
07:51:51 <mauke> I'm thinking of this style as "pattern matching in a box"
07:52:01 <roconnor> iago_: I think the answer to your original question might be, "No collections package is yet mature enough to be standard"
07:52:09 <mauke> there are no first class patterns, but this is the closest you get
07:52:45 <SamB_XP_> mauke: what was the ASIN for that ?
07:53:07 <mauke> arc sine?
07:53:20 <SamB_XP_> no, that amazon number
07:53:38 <mauke> huh?
07:53:44 <SamB_XP_> for the box
07:53:51 <iago_> roconnor, ok, it sounds more reasonable, although one should expect some effort to solve it
07:54:04 <roconnor> iago_: hence Edison
07:55:04 <iago_> perhaps I'm confused, but I see Edison to be more complex than needed
07:55:12 <SamB_XP_> iago_: I tried once!
07:55:13 <roconnor> oh?
07:55:18 <SamB_XP_> now it's your turnk
07:55:23 <luqui> oh my god so many methods!
07:55:31 <luqui> (in Sequence)
07:55:50 <roconnor> iago_: it looked to me like exactly what you were talking about
07:55:56 <roconnor> it has a heirchy
07:56:04 <roconnor> lots of interfaces
07:56:10 <roconnor> and many supporting implemenations
07:56:25 <SamB_XP_> s/turnk/turn!/
07:56:37 <iago_> roconnor, yep, it's the same idea
07:57:13 <roconnor> It's probably less complex that you think
07:57:16 <SamB_XP_> iago_: so ... if you have issues with it, you can design your own
07:57:19 <pejo> mauke, have you seen the first class patterns article linked from Wadler's blog?
07:57:39 <iago_> SamB_XP_, I know, but I will have the same problem
07:57:45 <mauke> pejo: yes :-)
07:58:18 <SamB_XP_> iago_: which same problem ?
07:58:49 <iago_> I expect one idea, perhaps not the best, but one, standarized (at least in practice)
07:58:59 <luqui> iago_, pretend it is edison
07:59:04 <luqui> there don't seem to be too many contenders
07:59:19 <SamB_XP_> that's because most of them are stillborn
07:59:28 <luqui> standardization starts with the community.
07:59:42 <SamB_XP_> but we aren't quite satisfied with edison
07:59:44 <iago_> first, I think now it's better to use foldable, functor etc
07:59:53 <iago_> instead of forget it
07:59:55 <luqui> it is silly to standardize something which is not widely used.
08:00:35 <roconnor> iago_: you certainly want to use those classes where appropriate
08:01:01 <iago_> roconnor, yep, but for example Edison defines its own fold*
08:01:04 <joma> anyone good with arrays? I still don't get if I can slice a listArrays? like : slice  ((0,0),(1,1)) array ; to get 4 elems from array
08:01:33 <roconnor> iago_: but the implemenations in Edison could still define Foldable instances
08:01:40 <iago_> in fact, I think that the list notation should be valid for any List-like type, more powerful
08:01:44 <roconnor> in fact, you could define the instances too
08:02:18 <roconnor> use fromList [foo], and the the optimizer work it's magic
08:02:22 <luqui> iago_, nah, why?  you can just use X.fromList [1,2,3,4] for whichever X you mean
08:02:25 <roconnor> its
08:02:46 <iago_> luqui, it's not the same :|
08:02:55 <luqui> iago_, why?  aesthetic concerns?
08:02:56 <roconnor> why not?
08:03:20 <iago_> fromList foo does the work with list, then converts it to some other collection
08:03:32 <roconnor> not necessarily
08:03:32 <luqui> iago_, have trust in haskell optimization
08:03:37 <iago_> is it the same that works with the collection itself?
08:04:04 <roconnor> iago_: the intermediate list is resonably likely to be deforrested
08:04:16 <luqui> iago_, I don't know what kind of function you would write that would allow a literal list to be immedately converted without traversal
08:04:18 <iago_> luqui, so I haven't got to use [:a:] for parallelization, I just work with [], and when I finish, I just do a fromList
08:04:20 <luqui> got to get there from somewhere
08:04:23 <iago_> and the compiler do the magic?
08:04:23 <iago_> :P
08:04:56 <luqui> from what I understand, [::] has pretty different constraints than []. but I'm not really familiar with the PArr stuff.
08:05:08 <luqui> and maybe they will, once PArr is anywhere near stable
08:05:49 <luqui> iago_, what you propose is dangerous because of, eg.:  head . filter (> 100) $ [ x | x <- [1..] ]
08:06:00 <luqui> changing those to [::] would cause a change in semantics
08:06:29 <luqui> maybe it would help if you realized the truth: there are no lists  (only loops)
08:07:12 <iago_> well, in this case not, ok
08:08:04 <nikki93> Hey guys!
08:08:05 <luqui> I'm just wondering what intermediate representation you would use to build a Seq, if not list.
08:08:09 <nikki93> Anyone here used 'FORTH'?
08:09:40 <iago_> luqui, I'm talking about work with any list-like structure like you work with lists
08:09:47 <joma> anyone good with arrays? I still don't get if I can slice a listArrays? like : slice  ((0,0),(1,1)) array ; to get 4 elems from array
08:09:47 <NorthStar> nikki93: there is a Forth dedicated channel
08:09:52 <iago_> equals that some people proposed to do the same with strings
08:09:55 <vixey> iago_, why are you only thinking abotu 'list like'
08:10:13 <iago_> vixey, it's the common example, there is no a concrete reason
08:10:19 <vixey> iago_, don't you want to write programs that work for classes of data types?
08:10:42 <iago_> is what I'm asking for
08:11:10 <iago_> but the solution seems to be edison
08:11:26 <iago_> but like I said, edison takes care of lot of details I think a general interface shouldn't
08:11:42 <luqui> iago_, what *should* a general interface take care of?
08:11:48 <iago_> I don't expect things like unsafeInsertMin, etc in a general soluttion
08:12:07 <iago_> luqui, of common cases, it is *general*
08:12:13 <luqui> so don't use it?
08:12:22 <luqui> iago_, how general?
08:12:28 <luqui> general enough to support infinite lists?
08:12:43 <luqui> I use those all the time, btw
08:12:48 <iago_> in Haskell should of course ;P
08:13:18 <luqui> iago_, oh good!  because [] is about the only one you'll find that does that! :-)
08:13:40 <luqui> so we already have one! :-)
08:14:30 <iago_> I don't see the problem
08:14:52 <luqui> iago_, most sequence implementations only support finite sequences.
08:15:01 <iago_> ok, and?
08:15:13 <luqui> iago_, so you said the general list interface should support infinite lists.
08:15:24 <iago_> am I saying that all implementations have to support infiniteness?
08:15:32 <luqui> that's what I thought you were saying
08:15:46 <luqui> I like laws to go along with my interfaces, otherwise I have no idea what i'm programming!
08:15:59 <iago_> ok, you understand bad, or I say it bad
08:16:01 <luqui> it's all code, and sure it executes, but without semantics it has no meaning
08:16:30 <iago_> luqui, monad interfaces supports stateful monads
08:16:38 <iago_> but not all monads add support for state
08:16:46 <luqui> iago_, fair.
08:16:50 <iago_> there is an interface for that
08:17:25 <iago_> luqui, so I don't the problem with support infinite structures
08:17:36 <luqui> so the semantics of a general list typeclass does not decide its strictness
08:17:56 <luqui> hmm, that rules out my use of it in most cases.  anyhow, I'll play along.
08:18:01 <luqui> what operations do you want in listlike?
08:18:40 <luqui> (:) obviously, the most-used one
08:18:48 <iago_> yep
08:19:02 <luqui> yeah probably the standard stuff.  cons, uncons, fold (from Foldable probably), unfold...
08:19:08 <iago_> well, is not obvious the complete set of methods, of course
08:19:27 <luqui> alright.
08:19:38 <iago_> you need more than a day to think in it
08:19:48 <iago_> anyway finally you will get something good
08:19:57 <iago_> not perfect, but enough for 95% of cases
08:20:09 <luqui> well, IMO, [] is enough for 95% of cases
08:20:15 <iago_> no
08:20:16 <luqui> [] = Iterator in OO languages
08:20:34 <luqui> iago_, what's your case for which it isn't?
08:20:43 <iago_> when I write my code I want can change the collection type
08:20:48 <iago_> easily
08:20:49 <luqui> surely you must have at least one concrete counterexample?
08:21:05 <luqui> iago_, sure.
08:21:09 <luqui> import qualified Data.List as L
08:21:21 <luqui> change to import qualified Data.Seq as L.  not perfect, but works a lot of the time :-)
08:21:21 <iago_> luqui, the case is that I don't want to get married with any type unnecessary
08:21:41 <luqui> iago_, okay, what's a case where you benefit from this abstraction?
08:21:52 <luqui> and also still have well-defined semantics for your program?
08:22:19 <Saizan> [] vs ByteString vs ByteString.Lazy is quite common
08:22:32 <vixey> iago_, can't figure out what you are trying to do exactly
08:22:34 <Saizan> wanting to migrate from one to the other, i mean
08:22:35 <pejo> iago, have you looked at generic programming? You probably want one of the more advanced gp-libraries.
08:23:00 <luqui> Saizan, yeah, classes aren't necessary for that. we just use qualified imports.  but it is indeed suboptimal.
08:23:07 <luqui> mlfunctors would be great for this
08:23:24 <vixey> but you can write polytypic size, map, inhabitants.. stuff like this
08:23:35 <vixey> (with just a GADT)
08:23:38 <Saizan> luqui: you end up editing the code, because the "methods" aren't named consistently enough
08:23:55 <luqui> Saizan, well BS.Lazy and BS they are, but yeah in general not.
08:24:05 <iago_> vixey, it is a good thing in general
08:24:19 <luqui> that's kind of a failure on H98's part, with type String = [Char]
08:24:25 <iago_> pejo, I take a look,  but few time
08:24:26 <Saizan> but generalizing for the sake of it seems not worth it
08:24:48 <iago_> luqui, qualified imports?
08:24:49 <iago_> lol
08:24:57 <iago_> I see some libraries to use toList
08:25:01 <iago_> others uses elems
08:25:03 <iago_> others ...
08:25:06 <luqui> generalizing is great.  but you have to have something *real* to generalize
08:25:09 <luqui> with structure and laws
08:25:13 <luqui> not just some names and types with no meaning
08:25:43 <vixey> generic programming is good in general ? lol
08:25:46 <luqui> iago_, I said it was suboptimal.  mlfunctors are really the niche for implementation invariance.  typeclasses don't quite fit the bill.
08:26:00 <sleven> Control.Monad.liftM :: (Monad m) => (a1 -> r) -> m a1 -> m r
08:26:03 <vixey> iago_, I must disagree, .. there will always be something you can't abstract over
08:26:05 <sleven> what does it do?
08:26:22 <luqui> sleven, same as fmap.  it applies a function to the value 'inside' a monad.
08:26:27 <iago_> vixey, you can't abstract all of course
08:26:28 <sleven> vixey: can you post the question/statement you just answered/responded to?
08:26:33 <iago_> well, "of course"
08:26:39 <luqui> > liftM show [1,2,3,4,5]
08:26:40 <vixey> sleven, everything should be in the channel logs
08:26:41 <lambdabot>   ["1","2","3","4","5"]
08:26:50 <vixey> sleven, the last file in http://tunes.org/~nef/logs/haskell/"
08:27:08 <Saizan> luqui: for collections i don't see the difference, everything revolves around the type of it
08:27:13 <pejo> vixey, I'm struggling to understand what iago is trying to achieve. I'm not making a stance for/against gp.
08:27:22 <sleven> does Functor have the same meaning in math as in haskell?
08:27:29 <luqui> Saizan, my arguments earlier re: strictness, for one
08:27:42 <sleven> vixey: address wrong
08:27:51 <sleven> gp as in ? genetic programming?
08:27:54 <Saizan> luqui: those apply to mlfunctors too, you've to declare a signature and have modules that implement it
08:28:03 <chessguy_> sleven:  generic programming
08:28:07 <sleven> ah
08:28:16 <luqui> Saizan, oh sry, I thought you were responding to a different point
08:28:38 <pejo> sleven, you asked earlier about prototype operating systems: the house papers mention pretty explicitly that they haven't tried to optimize it for performance (yet).
08:29:16 <lucca> > [1..5] >>= show
08:29:17 <lambdabot>   "12345"
08:29:23 <sleven> is there no "cheat" to "lift" a value from a monad? like: unsafeStealFromMonad :: (m v) -> v ?
08:29:37 <luqui> Saizan, yeah, maybe I'm lying there.  It could be my recent vendetta against typeclasses talking.
08:29:47 <mauke> sleven: that depends entirely on the monad
08:29:57 <lucca> sleven: return?
08:29:58 <luqui> I'm tired and flamey :-)
08:30:20 <lucca> oh, nevermind
08:30:21 <vixey> sleven, usually >>= does the trick
08:30:42 <luqui> sleven, well especially not from the Maybe monad
08:30:51 <luqui> unsafeStealFromMonad Nothing = ???
08:31:07 <vixey> just use >>= :)
08:31:15 <vixey> > Nothing >>= (return . (+1))
08:31:16 <lambdabot>   Nothing
08:31:17 <luqui> (vixey is correct)
08:31:21 <vixey> > Just 64 >>= (return . (+1))
08:31:22 <lambdabot>   Just 65
08:31:25 <mauke> sleven: nothing says that a value of type (m v) has to contain a v
08:31:38 <chessguy_> @src fromJust
08:31:39 <lambdabot> fromJust Nothing  = undefined
08:31:39 <lambdabot> fromJust (Just x) = x
08:32:06 <chessguy_> sleven:  there's not a general way to "steal" a value from an arbitrary monad, but some monads do supply it
08:32:07 <luqui> sleven, one of my favorite monads is the Future monad.  Future a is a value of type a which will be available sometime in the future.
08:32:08 <iago_> luqui, anyway, mlfunctor are a good idea too
08:32:19 <iago_> but could be complementary
08:32:22 <chessguy_> @hoogle Future
08:32:23 <lambdabot> No results found
08:32:23 <Saizan> the main problem with collections interfaces is that they end up being huge and look ugly :)
08:32:26 <sleven> lucca: i mean if i have IO Double as value, and I want to just get the value even though it is impure
08:32:26 <vixey> how does mlfunctor related to generic programming?
08:32:26 <iago_> with type-classess
08:32:29 <luqui> they are what we should be using instead of what we are using qualified imports for
08:32:41 <mauke> sleven: there is no value to get
08:32:45 <iago_> Saizan, uhm no, the problem is when you do it in this way
08:32:46 <lucca> IO Double is an action...
08:32:50 <luqui> where by qualified imports I'm referring to ByteString.Lazy, State.Lazy, etc.
08:33:21 <kerlo> luqui: sounds like the (->) e monad.
08:33:39 <kerlo> Where e is the type of the future!
08:33:40 <luqui> kerlo, semantically it's a Writer actually :-)
08:33:58 <Saizan> iago_: you can't have too little methods, otherwise they end up with poor efficiency for most structures
08:34:01 <sleven> well you know what im trying to achieve...
08:34:15 <luqui> kerlo, it's only one value, so a function doesn't seem appropriate
08:34:23 <luqui> kerlo, oh! lol
08:34:30 <Saizan> re mlfunctors: "Named Instances for Haskell Type Classes" http://www.informatik.uni-bonn.de/~ralf/hw2001/4.html
08:34:31 <luqui> type of the future is Sigma, I think :-)
08:34:42 <luqui> (Sigma = sierpinski space)
08:35:11 <iago_> Saizan, you can consider some of that, but not very specific methods
08:35:14 <sleven> randd :: IO Double ;; randd = do   gen <- R.newStdGen   return $ fst $ R.randomR (0,1::Double) gen //// should just be randd :: Double. basically there is no way to just say f u ghc just give ignore all kinds of tape safety?
08:35:53 <luqui> Saizan, looks cool
08:35:53 <iago_> of course you should keep the mandatory definitions as few as possible
08:36:01 <roconnor> ah augustss found a good example of a functor that is not a collecton, the continuation monad
08:36:15 <kerlo> Heat death means the future is 1 :: Sigma, Big Crunch means the future is 0 :: Sigma?
08:36:20 <roconnor> I thought the reader monad was a bad example, because the reader is probably a collection
08:36:26 <iago_> for something list-like I will only consider (:), head, tail, and []
08:36:35 <iago_> the rest could be defined in base of them
08:36:38 <mauke> sleven: type Double means it's a constant
08:36:39 <iago_> if you want, rewrite them
08:36:45 <vixey> kerlo, huh?
08:36:57 <luqui> roconnor, definitely.  it has one element for each value of r
08:37:38 <roconnor> right
08:37:59 <roconnor> I need to find a ground for this place
08:38:02 <kerlo> vixey: In the Sierpinski space, {1} is open and {0} is closed.
08:38:04 <roconnor> I keep shocking my laptop
08:38:07 <kerlo> At least, that's what Wikipedia says.
08:38:29 * roconnor looks around and only sees ikea furnature
08:38:48 <luqui> kerlo, lol nice :-)
08:38:55 <roconnor> maybe I should run a wire from the electrical socket
08:39:03 <sleven> R.newStdGen :: IO R.StdGen has IO too, cant i get out of the friggin IO?
08:39:09 <luqui> I was thinking 0 = not yet, 1 = already
08:39:10 <SamB_XP_> roconnor: hmm, I once heard ikea likened to a dungeon crawl
08:39:18 <mauke> sleven: you seem to think IO is just a wrapper around values
08:39:36 <paolino> sleven, why you want that ?
08:39:50 <luqui> sleven, you cannot!  that is the wonderful thing about it
08:40:09 <sleven> and
08:40:14 <sleven> *Matrix Control.Monad> R.newStdGen 1042089258 2103410262
08:40:18 <roconnor> sleven: write function of type a -> IO b
08:40:21 <sleven> howcan i actually get those values?
08:40:22 <luqui> sleven, (as vixey said, you use >>= to get out of it)
08:40:26 <roconnor> and then use bind or do notation to use IO
08:40:55 <mauke> sleven: by executing the newStdGen action
08:40:55 <vixey> it's ok to take something out a monad as long as you put it back in :p
08:41:01 * luqui thinks we should just point to unsafePerformIO every time this question is asked
08:41:07 <roconnor> do {a <- randomSomething; b <- myFunction a; let c = MyOtherFunctionWithoutIO b; ...}
08:41:17 <SamB_XP_> luqui: you cruel man!
08:41:32 <kerlo> sleven: you get the value out of an IO a by running it. You run it by either setting main to it or passing it to >>= and then running that.
08:41:39 <SamB_XP_> they can't handle the TRUTH!
08:41:40 <Saizan> ?wiki Monads as computation
08:41:40 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_computation
08:41:52 <sleven> i need to generate a list of random values and on each call it should be a different lists and also on eahc run of the program it should be a different list
08:41:58 <Saizan> sleven: ^^^^
08:42:15 <luqui> sleven, randoms =<< newStdGen
08:42:19 <luqui> er
08:42:24 <luqui> fmap randoms newStdGen
08:42:25 <mauke> sleven: maybe you should start using IO instead of fighting it
08:46:49 <sleven> is there no way to kill a function in ghci without killing ghci?
08:46:58 <mauke> ^C
08:47:21 <iago_> ^C frequently doesn't works
08:47:23 <iago_> ;P
08:47:51 <luqui> yeah, sucks when that happens
08:48:13 <luqui> it's just because ghci is working so hard! =P
08:48:37 <Heffalump> ^C works reliably for me on Linux
08:48:39 <luqui> (or maybe it's inverse lazy evaluation:  I'll interrupt it when I feel like it)
08:51:20 <chessguy> what is the point of the third monad law? why do we need monads to be...err..commutative? i never remember the right term
08:51:52 <Heffalump> associative
08:51:56 <chessguy> (x >>= f) >>= g == x >>= (\v -> f v >>= g)
08:52:02 <Heffalump> one important reason is so that do notation works sanely
08:52:02 <chessguy> Heffalump:  thanks
08:52:52 <chessguy> Heffalump:  to make it so that parens aren't required in do-notation?
08:52:56 <Heffalump> chessguy: right
08:53:14 <Heffalump> and so that you can arbitrarily change the nesting of chunks of it without changing the meaning
08:53:18 <sleven> hmm in DOS control-C works, it breaks back to the prelude without killing it.
08:53:38 <pejo> sleven, what do you want to do with the list of random numbers, once you have it?
08:53:39 <mauke> that's not DOS, and that's not the prelude
08:53:46 <sleven> and ^C , i have to do shift-^-shift-c correct?
08:53:54 <Heffalump> nono
08:53:56 <Heffalump> ctrl-c
08:53:59 <SamB_XP_> hahahaha
08:54:21 <sleven> ah wait control-c works in ghci too! how awesome!
08:54:36 <chessguy> i guess i could see needing parens in do-notation becoming messy. seems like a small reason for such a requirement though
08:55:11 <Heffalump> I'd say it's pretty crucial
08:55:17 <sleven> pejo: put it in my matrix. i jsut want to be able to generate a random matrix for testing purposes. a matrix is a listArray behind the secens and listArray can be constructed with a list
08:55:24 <Heffalump> I would find it very hard to understand what code meant if that law didn't apply.
08:55:41 <chessguy> Heffalump:  why?
08:56:01 <chessguy> Heffalump:  (i'm sure you're right, i'm just not getting it)
08:56:02 <Heffalump> because you'd have to think about the order in which the binds happened
08:56:27 <Heffalump> imagine what would happen in C if ; wasn't associative
08:56:40 <pejo> sleven, and why can't you do that in IO?
08:57:02 <chessguy> pejo:  are you encouraging him to do everything in IO?
08:57:04 <luqui> chessguy, we want a -> m b to behave like functions in some respect
08:57:16 <luqui> function composition is associative, so kleisli composition (>=>) should also be
08:57:27 <luqui> which boils down to the associativity law
08:57:42 <sleven> well whatever i do i get this annoying io type with me
08:58:13 <luqui> sleven, you will need IO *somewhere* in your program
08:58:15 <chessguy> sleven: can you @paste your code?
08:58:17 <sleven> and why cant i take 5 from fmap R.randoms R.newStdGen?
08:58:17 <luqui> but it can be very small
08:58:31 <luqui> slarba, fmap (take 5 . R.randoms) R.newStdGen
08:58:36 <luqui> damnit
08:58:38 <luqui> sleven, ^^^
08:58:54 <mauke> sleven: because it's not a list
08:58:57 <pejo> chessguy, I'd rather view it as discouraging the use of unsafe*
08:59:04 <sleven> http://hpaste.org/14027
08:59:12 <chessguy> @type fmap (take 5 . System.Random.Randoms) System.Random.newStdGen
08:59:13 <lambdabot>     Not in scope: data constructor `System.Random.Randoms'
08:59:17 <sleven> u call me slarba?
08:59:19 <chessguy> pejo:  neither is necessary
08:59:33 <luqui> sleven, IRC autocomplete bites again
08:59:56 <sleven> Ambiguous type variable `a' in the constraint:      `R.Random a'        arising from a use of `R.randoms'
09:00:25 <luqui> sleven, yeah, but in a larger context inference will know which type you meant
09:00:36 <luqui> or you could add a type signature and tell it
09:00:45 <luqui> what kinds of random thingies are you generating?
09:01:06 <chessguy> type fmap (take 5 . System.Random.5andoms) System.Random.newStdGen
09:01:08 <chessguy> @type fmap (take 5 . System.Random.randoms) System.Random.newStdGen
09:01:09 <lambdabot> forall a. (Random a) => IO [a]
09:01:57 <chessguy> sleven:  your best bet is probably to have a main, which uses "randoms" and "newStdGen" to generate an infinite list of random numbers, and then to pass those around as needed
09:01:59 <sleven> but then i ahve IO [a] again. i just want [a]
09:02:17 <sleven> chessguy: no that would be horrible. it is a library
09:02:18 <luqui> sleven, you need to bind the IO [a] to something then
09:02:20 <sleven> not a program
09:02:39 <luqui> oh for a library, it should probably take a generator then
09:02:57 <chessguy> sleven:  your library should be written in terms of the infinite list. or, as luqui  says, in terms of a generator
09:03:27 <chessguy> then use your main to exercise the library
09:03:52 <roconnor> Maybe I should call my function hslView or viewHSL
09:03:57 <roconnor> @hoogle viewRight
09:03:58 <lambdabot> No results found
09:04:02 <roconnor> @hoogle rightView
09:04:03 <lambdabot> No results found
09:04:43 <roconnor> @hoogle viewR
09:04:44 <lambdabot> Data.Sequence data ViewR a
09:04:44 <lambdabot> Data.Sequence viewr :: Seq a -> ViewR a
09:04:45 <sleven> but i dont see how to fix the type variable
09:04:59 <sleven> or hwo to bind it
09:06:02 <chessguy> sleven:  start by writing your library functions in terms of generators
09:06:08 <roconnor> hayoo++
09:07:18 <sleven> generators?
09:07:40 <luqui> (RandomGen g) => g -> ([Double], g), for example
09:07:45 <luqui> or MonadRandom if you like =P
09:08:00 <sleven> you mean random generators?
09:08:05 <luqui> yes
09:08:06 <sleven> i dont need the random stuff really
09:08:16 <sleven> it is just for one silly function that isnt necessary
09:08:26 <chessguy> @hoogle ...
09:08:27 <lambdabot> No results found
09:08:33 <sleven> seems ridiculous i have to rearrange my whole program for this one function
09:08:33 <chessguy> oops
09:08:54 <luqui> sleven, it takes quite a lot of brain rewiring to learn good architecture in haskell
09:08:58 <luqui> because haskell is so strict about it
09:09:06 <chessguy> sleven:  is the function supposed to be in the library?
09:09:09 <luqui> compare it to the first time you learned not to use global variables
09:09:47 <sleven> chessguy: yes
09:10:13 <chessguy> sleven:  what's the type signature of the function?
09:10:27 <sleven> i cant figure it out
09:10:41 <luqui> what should it be
09:10:44 <sleven> randd :: (R.Random a) => Int -> IO (IO [a])
09:10:45 <luqui> is what he's asking
09:10:47 <sleven> i mean there it is
09:10:59 <sleven> but i just want [Double]
09:11:02 <sleven> somehow
09:11:06 <chessguy> sleven:  what's it supposed to do?
09:11:08 <chessguy> "do"
09:11:14 <sleven> generate a list of random numbers
09:11:21 <sleven> given a range
09:11:22 <chessguy> sleven:  that's not a function
09:12:05 <luqui> so then the question is, what can the type signature be so that you can still achieve the effect you want, but that it is actually a function
09:12:07 <chessguy> sleven:  it should take a random generator too
09:12:14 <sleven> i have asked several times how to get the values from Matrix> R.newStdGen
09:12:14 <sleven> 1363388010 2147483398, os that possible?
09:12:19 <sleven> i mean separating them?
09:12:25 <luqui> sleven, we have told you more than several times
09:12:44 <sleven> then i dont get your explanations
09:12:45 <chessguy> sleven:  ok, here's the type signature for what you want
09:12:47 <chessguy> are you ready?
09:13:13 <sleven> wait wait
09:13:19 <sleven> im breathing
09:13:20 <sleven> ok
09:13:22 <sleven> shoot
09:13:25 <chessguy> randd :: RandomGen g => g -> ([Double], g)
09:13:26 <luqui> lol :-)
09:13:36 <chessguy> trust us, taht's what you want
09:14:00 <luqui> (I want randd :: Rand [Double])
09:14:06 <chessguy> no you don't
09:14:11 <chessguy> err
09:14:12 <luqui> yes I do!
09:14:15 <chessguy> sorry
09:14:28 <luqui> MonadRandom kicks the pants off of explicit generator passing
09:14:49 <chessguy> luqui:  sorry, i thought that was from sleven  and automatically shot it down
09:14:53 <luqui> yeah I know
09:14:55 <luqui> it was funny
09:16:17 * chessguy thinks his head exploded
09:17:00 <sleven> yes so i should do newStdgen then take one value of it and give to the matrix and the other i pass to gen a new value
09:17:36 <sleven> but how do I get the value from newStdGen?
09:17:49 <sleven> it is not patternmatchable and i cant do fst snd
09:18:18 <luqui> sleven, do not use newStdGen
09:18:35 <luqui> you are *given* a random generator, use it
09:23:16 <sleven> well i dont know which one im given soi dont know how to use it
09:24:01 <sleven>  Not in scope: data constructor `R.RandomGen'
09:24:55 <MyCatVerbs> That's because RandomGen is a typeclass, not a value.
09:25:42 <Saizan> sleven: your functions should take one as a parameter
09:26:16 <int80_h> I have a question about the graham scan algorithm, problem 13 chapter 3 of RWH
09:26:25 <Saizan> sleven: then you write a little wrapper in IO that does something like do gen <- newStdGen; print (yourfunction gen)
09:26:57 <MyCatVerbs> Where yourfunction :: (RandomGen gen) => gen -> Whatever.
09:27:02 <chessguy> Saizan:  lets get his function written first :)
09:27:18 <Saizan> chessguy: just to give the general idea
09:27:20 <int80_h> So, I have to find the tangent of the angle that point P, and some other point (call it point A), makes with the X axis
09:27:25 <sm> morning all
09:27:31 <chessguy> Saizan:  his function generates an infinite list anyway
09:27:40 <roconnor> the most important thing about IO that doesn't get enough play is that you need to write functions of type a -> b -> IO c, and then you combine these function in little do "scripts"
09:27:43 <sm> can't I put a # comment within a field in a .cabal file ? eg at the end of a line
09:27:57 <int80_h> so, I draw a line down to the X axis, through P and A, making an angle
09:28:09 <int80_h> but to get the tangent, I need the opposite length
09:28:20 <chessguy> roconnor:  more or less true for any monad
09:28:23 <Saizan> sm: like in haskell, you can use -- for comments
09:28:28 <dcoutts> sm: use -- on a line on it's own
09:28:29 <roconnor> chessguy: yes
09:28:43 <sm> ah, thanks Saizan, dcoutts
09:28:45 <dcoutts> sm: unfortunately it cannot be at the end of a line with other stuff on it
09:28:58 <int80_h> do I just draw a stright line from point P down to the X axis to make the opposite side?
09:29:07 * sm has been away a while
09:29:23 <chessguy> sleven:  i hope you know this by now, but you should be looking at http://haskell.org/ghc/docs/latest/html/libraries/random/System-Random.html
09:30:29 <Saizan> int80_h: you've the coordinates of the points?
09:30:46 <int80_h> Saiza: yes
09:30:50 <int80_h> Saizan: yes
09:30:51 <roconnor> @type until
09:30:52 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
09:32:02 <int80_h> Saizan: The point of finding the tangent is I will be sorting a set of points based on what the tangent is
09:32:52 <roconnor> @type iterate
09:32:53 <lambdabot> forall a. (a -> a) -> a -> [a]
09:33:05 <roconnor> I guess there is not iterateUntil
09:33:16 <roconnor> @hoogle (a -> Bool) -> (a -> a) -> a -> [a]
09:33:17 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
09:33:17 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
09:33:17 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
09:33:34 <roconnor> I guess I use iterate and takeUntil
09:34:08 <Saizan> int80_h: there's a simple equation to find the rect that goes through two points, in the form y = m*x + q, then 'm' is the tangent
09:34:18 <Saizan> int80_h: if i've understood your problem
09:34:49 <chessguy> roconnor:  that seems more idiomatic anyway
09:35:00 <roconnor> @hoogle takeUntil
09:35:00 <lambdabot> No results found
09:35:09 <chessguy> @hoogle takeWhile
09:35:09 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
09:35:10 <lambdabot> Data.ByteString takeWhile :: (Word8 -> Bool) -> ByteString -> ByteString
09:35:10 <lambdabot> Data.List takeWhile :: (a -> Bool) -> [a] -> [a]
09:35:16 <roconnor> hmm
09:35:16 <Saizan> s/rect/line/
09:35:31 <roconnor> I need to takewhile and including the first failure
09:35:49 * roconnor ponders this inelegance
09:35:58 <chessguy> takeUntil = takeWhile . not // yes?
09:36:15 <int80_h> Saizan: No, I'm not looking for the rectangle that goes through two points
09:36:44 <int80_h> Saizan: I've solved the problem I had. Now I have another
09:37:00 <sleven> Possible cause: the monomorphism restriction applied to the following:
09:37:00 <sleven>       rollDice :: IO t
09:37:06 <int80_h> Saizan: I realized I needed to make a 90 degree angle, so I know what to do
09:37:12 <sleven> Probable fix: give these definition(s) an explicit type signature
09:37:17 <sleven> which one?
09:37:29 <chessguy> sleven:  what code?
09:37:41 <int80_h> Saizan: Now I need to find out where the line that passes through point P and A passes through the X- axis
09:37:56 <sleven> rollDice = R.getStdRandom (R.randomR (1,6))
09:38:18 <roconnor> chessguy: in Pascal, a while loop may execute 0 times, but repeat-until always goes at least once
09:38:37 <chessguy> roconnor:  um...ok
09:39:31 <roconnor> anyhow, I think the fact that I want this strange function means I'm doing something wrong
09:39:32 <chessguy> so takeUntil p xs = head xs : takeWhile (not p) (tail xs)
09:39:51 <roconnor> not quite
09:39:56 <chessguy> roconnor:  i'd say the fact that you're trying to replicate Pascal means you're doing something wrong :)
09:40:05 <sleven> changing to:rand_range from to = R.getStdRandom (R.randomR (from,to))  make sit magically work, why is that?
09:40:24 <roconnor> I'm just using pascal as an example to illustrate how I mean the word Until
09:41:26 <sleven> rand_range from to = R.getStdRandom (R.randomR (from,to))
09:41:36 <sleven> rand_range :: (R.Random a) => a -> a -> IO a
09:41:38 <Saizan> int80_h: i'd still find the equation of the line that goes through those points, and then solve it for y = 0
09:41:46 <sleven> and i can lift that value out?
09:42:22 <roconnor> @typ iterate
09:42:23 <lambdabot> forall a. (a -> a) -> a -> [a]
09:42:35 <Saizan> int80_h: http://en.wikipedia.org/wiki/Linear_equation#Two-point_form
09:43:12 <roconnor> actually maybe takeWhile is correct
09:44:57 <chessguy> sleven:  did you write your randd function yet?
09:45:03 <int80_h> Saizan: Heh, thanks. I was on a more complicated track. Seems I have forgotten some of the basics
09:45:39 <chessguy> @hoogle Result
09:45:39 <lambdabot> Test.QuickCheck data Result
09:45:39 <lambdabot> Test.QuickCheck Result :: Maybe Bool -> [String] -> [String] -> Result
09:45:39 <lambdabot> Data.Typeable funResultTy :: TypeRep -> TypeRep -> Maybe TypeRep
09:45:53 <int80_h> I was trying to form a right triangle to find the tangent, forgetting that the slope is the tangent. duh.
09:46:07 <Saizan> yeah :)
09:46:43 <int80_h> well that's going to make the code much simpler than I had at first imagined
09:46:45 * Saizan has just learned how these things are called in english :)
09:47:28 * jeffwheeler wonders whether they are any fun symbolic math things in Haskell like Python's SymPy
09:47:28 <lambdabot> jeffwheeler: You have 1 new message. '/msg lambdabot @messages' to read it.
09:47:33 <jeffwheeler> @messages
09:47:33 <lambdabot> roconnor said 2h 46m 51s ago: http://hpaste.org/14006#a1
09:48:33 <jeffwheeler> roconnor: I considered that for foldr, but for some reason I thought it would be less efficient. I'm not sure, though . . .
09:48:44 <roconnor> what is a better name for cojoin for ListZipper: http://hpaste.org/14006#a3 ?
09:49:03 <roconnor> jeffwheeler: ah, there you are
09:49:17 <Saizan> roconnor: duplicate?
09:49:29 <Saizan> i've seen that used here and there
09:49:35 <roconnor> Saizan: better, but not good enough
09:50:24 <roconnor> something more specific to Zippers or ListZipper, like how focus is better than coreturn or counit
09:51:29 <roconnor> jeffwheeler: in any case, you need to have a toList function of some kind :)
09:51:34 <Saizan> mmh, something like "worlds" or "places"
09:51:35 <jeffwheeler> I rather liked the toList being automatically created :-/
09:51:47 <roconnor> oh
09:51:48 <jeffwheeler> roconnor: Foldable (or Traversable?) made it available automatically.
09:51:54 <roconnor> I didn't realize that
09:52:09 <roconnor> good then
09:53:02 <roconnor> jeffwheeler: but your foldr is wrong
09:53:12 <jeffwheeler> I'll s/add/insert/g for you, though
09:53:22 <roconnor> it doesn't traverse the ls in reverse order like it ought to
09:53:22 <jeffwheeler> roconnor: how so?
09:53:33 <jeffwheeler> roconnor: oh, you're right
09:54:12 <alsonk> anyone on the cabal-install team around?
09:54:19 <sclv> extend always made sense to me.
09:54:22 <roconnor> foldr f z (Zipper ls x rs) = foldl (flip f) (foldr f z (x:rs) ls  might work
09:54:42 <luqui> roconnor, positions?
09:54:43 <sclv> unless that's cobind...
09:54:57 <chessguy> @type liftM2
09:54:59 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:55:00 <luqui> roconnor, the plural of whatever ListZipper is supposed to mean.
09:55:13 <luqui> I think of a zipper as recording a position
09:55:17 <roconnor> luqui: positions seems reasonable
09:55:41 <roconnor> I hope we can do better, but I'd be satified with positions
09:56:13 <vixey> what class of data types can yo uwrite zippers for?
09:56:56 <jeffwheeler> vixey: I don't think there are any restrictions, just like list
09:56:57 <roconnor> vixey: any type of the form mu F, where F is made out of algebraic operations mu and I think nu can be thrown in as well, but I'm not sure.
09:56:58 <vixey> it's got to be more than just   F r1 r2 ... = C1 p1 p2 .. | C2 ..,  with pi = rj, or (F ...)
09:57:19 <vixey> ah I didn't capture nested recursion
09:57:46 <vixey> ok  mu, +, *, 0 1, X   I guess that is the more natural way to present it
09:57:54 <vixey> and is that it?
09:57:56 <roconnor> I guess F is any differentiable functor
09:58:14 <sleven> can I propagate an error to a higher level?
09:58:22 <vixey> thisg like (a -> b) are really awkward
09:58:31 <roconnor> because, if you don't mind the abuse of notaiton, zipper (mu F) = (mu F, mu dF)
09:58:32 <sleven> or the idiomatic way is to handle all error locally?
09:58:44 <roconnor> or something like that
09:58:50 <jeffwheeler> roconnor:  foldr f z (Zipper ls x rs) = foldl (flip f) (foldr f z (x:rs)) ls worked (yours, with an extra closing parentheses)
09:59:19 <luqui> vixey, what is nu?
09:59:26 <roconnor> jeffwheeler: Do you understand why it works?
09:59:29 <roconnor> @src reverse
09:59:31 <lambdabot> reverse = foldl (flip (:)) []
09:59:37 <vixey> for mu least, and nu greatest fixed point
09:59:41 <roconnor> It is basically an optimization of the source of reverse
09:59:43 <luqui> oh ok
09:59:44 <jeffwheeler> roconnor: not really :-/
09:59:48 <vixey> mu = nu in haskell land
09:59:55 <luqui> right
09:59:59 <vixey> (or maybe everything is nu, I'm not sure)
10:00:26 <luqui> data List a = List a (List a) -- mu
10:00:29 <luqui> er
10:00:31 <luqui> data List a = List a (List a) -- nu
10:00:35 <luqui> data List a = List a !(List a) -- mu
10:00:37 <roconnor> jeffwheeler: actualy, let me walk you through it this way
10:00:46 <roconnor> jeffwheeler: to convert a zipper to a list we want
10:01:05 <roconnor> toList (Zipper ls x rs) = reverse ls++(x:rs)
10:01:07 <luqui> data Tree a = Branch a (Tree a) !(Tree a) -- ???
10:01:16 <roconnor> and reverse ls is defined as
10:01:41 <roconnor> toList (Zipper ls x rs) = (foldl (flip (:)) [] ls)++(x:rs)
10:01:58 <jeffwheeler> roconnor: that makes sense
10:02:22 <roconnor> now (++foo) simply takes a list and replaces the null with foo
10:02:28 <roconnor> so we can do that ourselvs
10:02:41 <roconnor> toList (Zipper ls x rs) = (foldl (flip (:)) (x:rs) ls)  -- this is a real optimization
10:02:48 <vixey> (->) seems to cause problems for zipping
10:03:11 <roconnor> now finally, a foldr over a list simply replaces (:)'s with f's and []'s with zs
10:03:32 <jeffwheeler> roconnor: crazy, thanks.
10:03:41 <roconnor> foldr (Zipper ls x rs) = foldr (foldl (flip (:)) (x:rs) ls)  -- step1
10:03:45 <roconnor> er
10:03:55 <roconnor> foldr f z (Zipper ls x rs) = foldr f z (foldl (flip (:)) (x:rs) ls)  -- step1
10:04:20 <roconnor> foldr f z (Zipper ls x rs) = foldl (flip f) (foldr f z (x:rs)) ls  -- step2 replace the :
10:04:49 <roconnor> jeffwheeler: it is just like high school algebra, but the rules are all unfamiliear
10:05:05 <jeffwheeler> roconnor: yep.
10:05:28 <chessguy> what am i missing here?
10:05:29 <chessguy> http://hpaste.org/14029
10:06:07 <sleven> hmm is there some way I could help haskell with laziness? or wait I njust have to write my function differently.
10:06:16 <chessguy> @type liftM2
10:06:18 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:06:24 <vixey> sleven, huh?
10:06:51 <roconnor> jeffwheeler: so far "positions" the the best name suggested here for cojoin
10:07:18 <jeffwheeler> roconnor: yep, was just adding it; I have no idea what it does yet, but was just about to play with it
10:08:10 <roconnor> jeffwheeler: It seems obsurce, but people will probably find it quite useful, in the same way monads are useful
10:08:35 <sleven> can I map over tuples somehow?
10:08:49 <roconnor> jeffwheeler: cobind :: (Zipper a -> a) -> Zipper a -> Zipper a
10:09:09 <roconnor> cobind f z = fmap f (cojoin z)
10:09:29 <roconnor> that is also useful and should be defined
10:09:37 <jeffwheeler> roconnor: oh, it just selects each item in the zipper, and then returns them in another zipper
10:09:53 <roconnor> jeffwheeler: ya, it makes a zipper of all the zippers available
10:09:59 <luqui> sleven, Control.Arrow has some nice functions for mapping over pairs
10:10:09 <luqui> triples and more have basically no library support, so nobody uses them
10:10:24 <roconnor> jeffwheeler: cojoin is used to define cobind
10:10:40 <jeffwheeler> roconnor: but presumably I'll change it to positions, still
10:10:51 <luqui> > (left show (1,2), right show (1,2), (show *** succ) (1,2))
10:10:52 <lambdabot>   Couldn't match expected type `(t, t1)'
10:11:03 <roconnor> jeffwheeler: and cobind is used when you want to apply a function everywhere in the zipper, but f wants to know the surrounding "context" at each point
10:11:06 <luqui> > (first show (1,2), second show (1,2), (show *** succ) (1,2))
10:11:07 <lambdabot>   (("1",2),(1,"2"),("1",3))
10:11:30 <roconnor> luqui:  have a better name for cobind in ListZipper?
10:11:33 <Taejo> :t f *** f
10:11:34 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a, SimpleReflect.FromExpr (a b' c'), SimpleReflect.FromExpr (a b c)) => a (b, b') (c, c')
10:11:40 <luqui> roconnor, sounds like extend ;-)
10:11:49 <luqui> roconnor, oh.
10:11:58 <roconnor> luqui: better, but still kinda generic
10:12:02 <luqui> roconnor, right, mixing up cojoin and cobind.  you were describing it :-)
10:12:03 <Taejo> :t (***)
10:12:04 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
10:12:16 <luqui> roconnor, inContext?
10:12:22 <idnar> once you start going beyond tuples of length 2 or so, records start looking like a *much* nicer option
10:12:22 <roconnor> luqui: I'm thinking contextMap
10:12:24 <Taejo> sleven: (f *** f) (a, b) == (f a, f b)
10:12:29 <luqui> that's not bad
10:12:33 <roconnor> mapWithContext
10:12:38 <idnar> although the namespace issues are unfortunate
10:12:41 <roconnor> maybe contextMap is better than that
10:12:58 <jeffwheeler> I like contextMap.
10:13:00 <Taejo> sleven: but if you want to map over arbitrary tuples, you're probably doing it wrong
10:13:15 <roconnor> contextMap f z = fmap f (positions z)
10:13:23 <roconnor> that even reads fairly nicely
10:13:24 <luqui> you are using the flipped version, right?  (w a -> b) -> (w a -> w b)
10:13:33 <roconnor> luqui: right
10:13:33 <luqui> ok good
10:14:22 <roconnor> The nice thing about abstract math is that is points out functions like positions and contextMap, that I beleive are genuinely useful, and not at all obvious
10:14:55 <luqui> yep.  the standard typeclasses have actually been a lot of guidance to frp research
10:15:10 <roconnor> jeffwheeler: these functions satify the comonad laws, such as, fmap focus (positions z) = z
10:15:14 <sleven> i have two inputs (as tuples) that iw ant to validate
10:15:34 <jeffwheeler> roconnor: couldn't contextMap be :: (Zipper a →  b) →  Zipper a →  Zipper b?
10:15:50 <roconnor> jeffwheeler: yes, of course
10:15:56 <roconnor> my mistake
10:16:03 <jeffwheeler> no problem
10:16:05 <sleven> (0,0) and (2,2) for example
10:16:19 <sleven> i want to chck bigger than 0 and smallr than rows/cols
10:16:37 <jeffwheeler> atEnd $ next $ fromList [1..5] -- neat
10:16:37 <luqui> I'd just write a function inRange
10:16:47 <nikki93> Hey guys! Is haskell a good 'scripting language'? For embeddig within c++? You know, many games use scripting languages such as lua for, well, scripting. I was wondering whether haskell is good for that.
10:16:48 <sleven> ahi see how
10:17:02 <pizza_> nikki93: no
10:17:03 <sleven> nikki93: write the whole game in haskell
10:17:04 <gio123> does somebody has
10:17:06 <gio123> http://www.cis.upenn.edu/~bcpierce/tapl/
10:17:06 <gio123> ?
10:17:35 <luqui> nikki93, embedding haskell is currently rather a PITA from what I've heard.   But I am not experienced.
10:17:59 <luqui> nikki93, however I would be inclined to say not in particular, because it thinks so differently from C++
10:18:04 <vixey> I tought it was meant to be really easy
10:18:07 <Taejo> and your players would probably not thank you
10:18:09 <intoverflow> gio123: I has it
10:18:32 <luqui> Taejo, well, they would in years when they achieve enlightenment :-)
10:18:43 <gio123> intoverflow>: electronic version
10:18:43 <nikki93> Oh ok, I was just asking out of curiosity (I use squirrel for scripting otherwise).
10:18:44 <gio123> ?
10:18:53 <intoverflow> gio123: no, a legit paper version
10:19:01 <nikki93> I must say, I was introduced to haskell by xmonad, and I was reading the 'real world haskell book' past few days, and its pretty cool.
10:19:21 <luqui> nikki93, haskell is teh roxor
10:19:23 <nikki93> But really, all algorithms/problems/whatever I think of I know I can only translate into imperative paradigm.
10:19:32 <roconnor> oh right, and focus (positions z) = z
10:19:33 <nikki93> How do you guys do it in functional?
10:19:39 <luqui> nikanj, a lot of practice?
10:19:47 <luqui> grr, nikki93 ^^
10:19:50 <nikki93> Are you able to easily implement whatever you think of?
10:19:50 <SamB> gio123: sadly, only the sequel appears to be easily availalable in pirated form!
10:20:37 <luqui> nikki93, yeah pretty much.  FP tends to be harder on your brain and easier on your fingers, but programming is just as easy as it was when I was a proficient C++er
10:20:40 <nikki93> Also, I'm very spoilt by Object-Orientedness and all its relatives (I'm a heavy C++ user). Haskell, AFAIK, ain't OOP. But it does have something like structs right? Or am I mistaken, and you guys usually work in a different way?
10:20:42 <luqui> (easier, actually)
10:20:49 * SamB wonders if he's going to be quoted in HWN saying that
10:20:49 <bremner> nikki93: scheme or guile are probably better choices for scripting languages IMHO
10:20:59 <jeffwheeler> @faq Can Haskell let me implement whatever odd algorithm I come up with, easily?
10:20:59 <lambdabot> The answer is: Yes! Haskell can do that.
10:21:07 <nikki93> One thing I love about haskell is that you have to be a genius (or at least, pretty clever) to program in it.
10:21:17 <luqui> nikki93, yeah, OOP is generally irrelevant to haskell.  different design patterns emerge.
10:21:20 <nikki93> You won't find some idiots just getting a certificate and sitting at a job just cuz of the money.
10:21:25 <bremner> nikki93: typeclasses are like interfaces (or abstract base classes)
10:21:56 <jeffwheeler> nikki93: I think that appeals to many of the Haskell people. I certainly love that.
10:21:58 <nikki93> data Point = { x :: Double, y :: Double } or something like that.
10:22:02 <luqui> nikki93, well.  I don't think that's true.  You have to work at learning it, esp. if you are from an imperative background.  I think wadler has some research showing it is a very nice first language though.
10:22:03 <Taejo> @faq Can Haskell bring me infinite wealth?
10:22:04 <lambdabot> The answer is: Yes! Haskell can do that.
10:22:17 <Heffalump> > repeat '$'
10:22:17 <Taejo> > let wealth = wealth + 1 in wealth
10:22:19 <lambdabot>   "$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$...
10:22:32 <lambdabot>   thread killed
10:22:35 <SamB> nikki93: hmm, I like the fact that it isn't dull to program in ;-)
10:22:42 <nikki93> Hey, lambdabot is an interpreter right?
10:22:43 <pizza_> @faq Can Haskell interpreters be less than 10MB?
10:22:43 <lambdabot> The answer is: Yes! Haskell can do that.
10:22:46 <luqui> but having a background in imperative programming *hurts* you when you try to learn haskell.  you'd be better off with no knowledge of programming at all :-)
10:22:53 <nikki93> But, there's lots to learn. And the real world haskell book is too long. I'm impatient. :P
10:22:55 <jeffwheeler> nikki93: among other things, it can interpreter code
10:22:59 <jeffwheeler> err, interpret
10:23:15 <roconnor> jeffwheeler: I'd make addLeft and deleteLeft defaults, because that is how a text editor works, but I don't feel strongly about it
10:23:17 <nikki93> You guys treat lambdabot like a dog lol.
10:23:33 <SamB> luqui: I don't think it's *that* bad -- as long as you don't try to apply said knowledge except in thinking about the operational semantics ;-P
10:23:37 <jeffwheeler> roconnor: hmm, I'm not sure; that's a good point, though
10:23:45 <roconnor> ya
10:23:45 <SamB> (or the FFI)
10:23:50 <roconnor> I'm not sure either
10:23:56 <jeffwheeler> roconnor: I wonder how list works
10:23:59 <nikki93> Other than RWH (I'll let you figure that one out), what are the other good haskell first-time-or-whatever-resources to learn from?
10:24:11 <roconnor> of course (a:) adds to the right
10:24:20 <roconnor> so there is some justification for your choice too
10:24:35 <roconnor> like I said, I don't feel strongly
10:24:36 <luqui> SamB, yeah, that might have been too strong.  still, it's weird coming into a language that people cherish for what it does *not* let you do.
10:24:40 <luqui> from eg. Perl
10:24:55 <SamB> luqui: well
10:24:59 <jeffwheeler> I got no responses from libraries@; I think I'll post to haskell@
10:25:01 <luqui> even though math is all about what you can't do :-)
10:25:02 <SamB> I guess so
10:25:15 <SamB> but I like how that makes it easier for the compiler to figure out what you DO want to do
10:25:28 <int80_h> nikki93:YAHT
10:25:31 <nikki93> Because of my imperative-spoiltedness, whenever I think of a looping function I'm screwed. :P
10:25:32 <luqui> oh sure.  haskell vets understand all the copious advantages thereof
10:25:33 <SamB> e.g. typeclass dispatch wouldn't work with dynamic types ;-P
10:25:37 <nikki93> int80_h: And whats that?
10:25:51 <int80_h> nikki93: Yet Another Haskell Tutorial
10:26:12 <int80_h> nikki: I also plan on going through project euler once I have enough haskell to work with
10:26:18 <luqui> recently though I love haskell for its semantics.  It is the only real-world language I can do math on.
10:26:29 <luqui> i.e. the programs have more meaning than what you do when you run them
10:26:34 <luqui> *what they do
10:26:36 <jeffwheeler> If only Euler wasn't so math oriented . . .
10:26:40 <vixey> mumble
10:26:42 <jeffwheeler> there should be one that's more focused on other stuff
10:26:57 <luqui> jeffwheeler, we should make one!
10:27:03 <vixey> @dict real-world
10:27:03 <lambdabot> Supported dictionary-lookup commands:
10:27:03 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
10:27:03 <lambdabot> Use "dict-help [cmd...]" for more.
10:27:12 <jeffwheeler> luqui: definitely.
10:27:16 <BONUS> euler is good for like 100 problems or so, after that it's not about programming so much as it is about knowing the maths behind the problems
10:27:22 <int80_h> jeffwheeler: I would love to see the equivilent of the Standford C library linked list text
10:27:25 <nikki93> How do I use lambdabot for interprettation?
10:27:32 <FunctorSalad> > "woof"
10:27:34 <lambdabot>   "woof"
10:27:43 <roconnor> > reverse "woof"
10:27:44 <lambdabot>   "foow"
10:27:52 <int80_h> jeffwheeler: Like progressively difficult data structure implementation challenges
10:27:57 <jeffwheeler> luqui: I use various computer programming contest problems, now. TCEA, Trinity high-school programming contest, etc.
10:27:58 <nikki93> > let abc = "abc"
10:27:59 <lambdabot>   <no location info>: parse error on input `;'
10:28:04 <nikki93> > abc
10:28:05 <lambdabot>   Not in scope: `abc'
10:28:15 <roconnor> > nubBy(((>1) .) . gcd) [2..]
10:28:15 <ski_> > let abc = "bad" in abc
10:28:16 <jeffwheeler> @let abc = "abc"
10:28:17 <lambdabot>  Defined.
10:28:18 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
10:28:18 <lambdabot>   "bad"
10:28:19 <luqui> > [2,7] ++ (fix . foldr (.) id . map (:) $ [1,8,2,8])
10:28:20 <lambdabot>   [2,7,1,8,2,8,1,8,2,8,1,8,2,8,1,8,2,8,1,8,2,8,1,8,2,8,1,8,2,8,1,8,2,8,1,8,2,...
10:28:21 <jeffwheeler> > abc
10:28:22 <lambdabot>   "abc"
10:28:24 <intoverflow> > http://ipsc.ksp.sk/
10:28:24 <lambdabot>   <no location info>: parse error on input `;'
10:28:24 <nikki93> > printStrLn
10:28:25 <lambdabot>   Not in scope: `printStrLn'
10:28:30 <intoverflow> err
10:28:32 <nikki93> I suck. :(
10:28:36 <luqui> ^^ e for the overzealous pattern matcher
10:28:40 <intoverflow> jeffwheeler: http://ipsc.ksp.sk/
10:28:47 <vixey> nikki93, nobody gets to use any IO :p
10:28:54 <vixey> nikki93, (not on lambdabot,..)
10:29:00 <luqui> not EVER!
10:29:03 <int80_h> jeffwheeler: If you came up with an intriguing project, and got it going, I'll bet you could attract the geniuses to give us nice puzzles to solve
10:29:04 <nikki93> Ahh, no monadness.
10:29:09 <luqui> what channel do you think you're in!?
10:29:16 <luqui> nikki93, monads are fine.  just not *that* monad
10:29:22 <ski_> @quote IO
10:29:22 <lambdabot> lennart says: Should Haskell also provide unrestricted side effects, setjmp/longjmp, missile launching functions, etc?  After all, people who don't want to use them can just avoid them. :)
10:29:25 <roconnor> nikki93: you can use other monads
10:29:29 <luqui> > do { x <- [1,2,3]; y <- [4,5,6]; return (x,y) }
10:29:30 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
10:29:36 <jeffwheeler> intoverflow: that one looks fun; I'll have to teach a few friends Haskell :D
10:29:39 <nikki93> roconnor: I don't know what a monad is, so its fine
10:29:41 <FunctorSalad> fast-scrolling channel is ...
10:29:43 <roconnor> :P
10:29:44 <nikki93> I'm still noob. :P
10:30:00 <nikki93> Gimme a haskell assignment.
10:30:01 <nikki93> Simple one.
10:30:10 <int80_h> nikki93: read RWH. It will make monads friendly and familiar to you.
10:30:11 <C-Keen> find a palindrome
10:30:12 <roconnor> nikki93: With our help, pretty soon you will be writting your own monad tutorial
10:30:24 <jeffwheeler> nikki93: submit a patch to Yi! (It's easier than you think.)
10:30:38 <nikki93> int80_h: I was readig that, but I got bored somewhere in between.
10:30:43 <int80_h> better. Nikki93 can write a monad that generates monad writing tutorials
10:31:16 <luqui> instance Monad Tutorial where return x = "A monad is just like " ++ x
10:31:57 <luqui> nikki93, generate an infinite list of the primes.
10:32:09 <luqui> nikki93, it's good practice.  the first time I tried it took me 20 lines :-)
10:32:49 <luqui> or if you like real world things, write a program which prints "LOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOL..." to the screen
10:32:53 <luqui> (okay that might be too easy)
10:33:51 <nikki93> let a x = if (x > 0) then "LO" + a (x - 1) else "L"
10:33:57 <nikki93> putStrLn a 200
10:33:58 <nikki93> :)
10:34:05 <nikki93> putStrLn (a 200)
10:34:15 <nikki93> How's that, luqui?
10:34:20 <roconnor> nikki93: not a bad start
10:34:45 <nikki93> s/+/++/g
10:34:51 <roconnor> someone teach nikki93 library functions to make that code more haskelly
10:34:56 <FunctorSalad> I recently wrote a program that mapped an integer n to the number of google hits for l(ol)^n...
10:35:11 * roconnor would but is a bit busy at the moment
10:35:18 <mux> > reoeat 200 "LO" ++ "L"
10:35:19 <lambdabot>   Not in scope: `reoeat'
10:35:24 <FunctorSalad> (there were hits for everything up to 50 at least)
10:35:26 <mux> > repeat 200 "LO" ++ "L"
10:35:26 <lambdabot>   Couldn't match expected type `[Char] -> [a]'
10:35:35 <luqui> > concat (replicate 200 "LO") ++ "L!!!11"
10:35:36 <lambdabot>   "LOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLO...
10:35:38 <mux> > replicate 200 "LO" ++ "L"
10:35:39 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
10:35:44 <mux> pft.
10:35:53 <FunctorSalad> > "L" ++ fix ("LO"++)
10:35:55 <lambdabot>   "LLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOL...
10:36:04 <ski_> nikki93 : a variant would be `a x = "L" ++ if x > 0 then "O" ++ a (x - 1) else ""'
10:36:05 <luqui> > take 200 (cycle "LO") ++ "L"
10:36:07 <lambdabot>   "LOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLO...
10:36:23 <idnar> > cycle "LO"
10:36:24 <lambdabot>   "LOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLO...
10:36:38 <luqui> these all look the same!!!   LOLOLLOLOL
10:37:05 <FunctorSalad> > let l = "l" o; o = "o" l in l
10:37:06 <jeffwheeler> > 'L' : concat (replicate 200 "OL")
10:37:06 <lambdabot>   Couldn't match expected type `t1 -> t'
10:37:07 <lambdabot>   "LOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLO...
10:37:16 <jeffwheeler> mine will always end on "L" ;)
10:37:24 <centrinia> > take 100 $ intersperse 'O' . repeat $ 'L'
10:37:25 <lambdabot>   "LOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLO...
10:37:32 <FunctorSalad> lol
10:37:40 <luqui> > cycle "LO" ++ "L"  -- mine too
10:37:41 <jeffwheeler> That one's clever.
10:37:42 <lambdabot>   "LOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLO...
10:38:03 <jeffwheeler> luqui: :P
10:38:04 <centrinia> luqui: That append doesn't make sense.
10:38:11 <luqui> centrinia, that was the joke :-)
10:38:16 <centrinia> I know. :)
10:38:22 <luqui> centrinia, I know you know
10:38:22 <nikki93> But mine's the best. :P
10:38:26 <ski_> > iterate ("LO" ++) "L" !! 10
10:38:27 <lambdabot>   "LOLOLOLOLOLOLOLOLOLOL"
10:38:35 <nikki93> lols x = if (x > 0) then "LO" ++ lols (x - 1) else "L!"
10:38:41 <luqui> wait, who is nikki93?  :-)
10:38:44 <nikki93> Haskell is fun stuff.
10:38:45 <nikki93> I'm me.
10:38:52 <nikki93> Newboytohaskell.
10:39:11 <jeffwheeler> > let lols x = if (x > 0) then "LO" ++ lols (x - 1) else "L!" in lols 5
10:39:12 <nikki93> The Haskell quicksort is awesome.
10:39:12 <lambdabot>   "LOLOLOLOLOL!"
10:39:22 <ski_> nikki93 :  a x = "H" ++ if x > 0 then "I" ++ a (x - 1) else "!"
10:39:23 <luqui> > roflmao = "LO" : roflmao
10:39:24 <lambdabot>   <no location info>: parse error on input `='
10:39:41 <nikki93> I mean, EVERY piece of haskell I've seen is, you know 'clever', 'beautiful' code.
10:39:45 <roconnor> nikki93: haskell's quicksort is really a deforested tree sort, but never mind about that.
10:39:50 <roconnor> :P
10:39:52 <baaba> > let lol = "LO" ++ lol in lol
10:39:53 <lambdabot>   "LOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLO...
10:40:05 <luqui> nikki93, I should show you some of my FRP bootstraps
10:40:05 <nikki93> roconnor: Yeah, it goes in to a tree and sorts until nulls.
10:40:07 <jeffwheeler> roconnor: still a great boasting tool
10:40:11 <int-e> > showIntAtBase 2 ("OL"!!) 366503875925 ""
10:40:12 <luqui> nikki93, I will change your mind promptly
10:40:12 <lambdabot>   "LOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOL"
10:40:32 <chessguy> ok, what silly little thing am i missing here? http://hpaste.org/14029
10:40:34 <luqui> nikki93, once you see three unsafePerformIOs in the scope of one function, you want to cut your eyes out
10:40:35 <roconnor> treeSort++
10:40:53 <FunctorSalad> do rewrite rules get exported? say I define Foo :: * -> * in one module and specialize it to Foo Double in another with a rewrite rule
10:40:58 <nikki93> Anyone here on windows?
10:41:09 <nikki93> Try my computer game I made in C++, at www.grall.uni.cc.
10:41:10 <roconnor> FunctorSalad: rules in GHC are exported like instances
10:41:14 <nikki93> I'm on Linux, it runs fine under Wine
10:41:24 <FunctorSalad> (currently I need to have the specialize pragma in the same module as the general definition :()
10:41:30 <nikki93> When I made it, I was still a Windoze person.
10:41:38 <FunctorSalad> roconnor: ah, nice
10:41:42 <luqui> chessguy, good question!
10:41:46 <nikki93> BTW, someone was saying that learning haskell can make you programm better in C++. is hat true?
10:41:48 <luqui> looks okay to me
10:41:57 <jeffwheeler> Cabal 2? Woo, I'm excited.
10:41:59 <roconnor> I think you should be able to specialize a function anywhere ... but I've not tried
10:42:08 <FunctorSalad> nikki93: more like "more frustrated to program in <other language>"...
10:42:11 <jeffwheeler> I could never appreciate Cabal until I'd use the mess of Python stuff.
10:42:13 <luqui> chessguy, oh no there it is
10:42:24 <luqui> chessguy, liftM2 take a pure function, whereas your f returns a Maybe
10:42:33 <dcoutts> jeffersonheard: oh yes? what in particular do you find is better / worse?
10:42:42 <luqui> chessguy, throw a join on the front of that liftM2 would do the trick
10:42:47 <vixey> nikki93, I don't share it but the concensus seems to be programming in haskell makes you hate everything that isn't haskell....
10:43:03 <jeffwheeler> vixey: it's true!
10:43:17 <vixey> I don't feel that way, maybe I haven't learned haskell yet though :)
10:43:25 <ski_> @hoogle (a -> b -> m c) -> (m a -> m b -> m c)
10:43:25 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
10:43:25 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
10:43:25 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
10:43:26 <FunctorSalad> purity / explicit state is a big one I'd say
10:43:30 <dcoutts> jeffersonheard: oops, sorry, I meant to direct that Q to jeffwheeler
10:43:34 <chessguy> luqui:  ah, thanks
10:44:02 <ski_> there should be `extendM2'
10:44:04 <FunctorSalad> I dread having to deal with destructive updates when I need to code in another lang soon :(
10:44:05 <vixey> :t \f -> f`on`return
10:44:06 <lambdabot> forall c a (m :: * -> *). (Monad m) => (m a -> m a -> c) -> a -> a -> c
10:44:08 <dcoutts> jeffwheeler: what in particular do you find is better / worse compared to the python packaging stuff?
10:44:12 <jeffwheeler> dcoutts: from Python? There's a nice, standard place where all the packages are (Hackage) and everything works properly. I know where stuff installs, too.
10:44:19 <luqui> ski_, are there any `ap` like patterns for extend?
10:44:22 <FunctorSalad> and spooky action at a distance ;)
10:44:31 <vixey> :t (>>=)
10:44:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:44:33 <jeffwheeler> dcoutts: in setuptools, everything is gross and setup.py is as fugly as can be
10:44:42 <vixey> ski_, or maybe bind2?
10:44:47 <ski_> (`extendM' would just be `(=<<)')
10:44:52 <jeffwheeler> dcoutts: 'cabal install' doesn't randomly do weird things
10:44:56 <dcoutts> jeffwheeler: you mean the setup.py that every package has?
10:45:15 <jeffwheeler> dcoutts: yeah; it frequently includes Very Strange things
10:45:22 <dcoutts> jeffwheeler: as in each package developer puts random crap code into their setup.py
10:45:23 <jeffwheeler> dcoutts: oh, and I can browse the docs on Hackage, which is awesome :)
10:45:24 <FunctorSalad> jeffwheeler: the version mess isn't "weird"? ;)
10:45:27 <ski_> luqui : for `(=<<)' ?
10:45:31 <luqui> ski_, yeah
10:45:38 <jeffwheeler> dcoutts: exactly.
10:45:45 <FunctorSalad> I can't do cabal upgrade because it will install process-1.0.1.1 which then proceeds to screw everything up...
10:45:54 <dcoutts> jeffwheeler: we have the same issue with Setup.hs, but fortunately most packages can do without one
10:45:58 <FunctorSalad> (conflicts with process-1.0.1.0)
10:46:03 <ski_> @type \f x -> join (return f `ap` x)
10:46:04 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a -> m a1) -> m a -> m a1
10:46:07 <nikki93> I'm reading 'Why HAskell' on the wiki
10:46:14 <jeffwheeler> dcoutts: we have a Setup.hs file, but it's not awful. :)
10:46:25 <nikki93> It says Haskell focuses on 'what' rather than 'how'.
10:46:26 <luqui> ski_, yeah I guess you can just join it at the end
10:46:30 <Taejo> dcoutts: isn't there a Cabal option that says, "my Setup.hs is the normal one"
10:46:48 <dcoutts> FunctorSalad: I wonder if this would help or not: http://hackage.haskell.org/trac/hackage/ticket/420
10:46:52 <baaba> @pl \f x -> join (return f `ap` x)
10:46:52 <lambdabot> (=<<)
10:46:52 <jeffwheeler> Taejo: build-type: Simple?
10:47:02 <dcoutts> Taejo: yes exactly, build-type: Simple
10:47:11 <ski_> f :: a -> b -> m c; x :; m a; y :: m b
10:47:19 <Taejo> yes. what proportion of packages have that?
10:47:35 <dcoutts> Taejo: most, I'd have to check though
10:47:35 <ski_> return f :: m (a -> b -> m c)
10:47:43 <ski_> return f `ap` x :: m (b -> m c)
10:47:52 <ski_> return f `ap` x `ap` y :: m (m c)
10:47:59 <ski_> join (return f `ap` x `ap` y) :: m c
10:48:17 <dcoutts> Taejo: I occasionally test that all the Setup.hs scripts compile with a new Cabal lib, and the number of ones over a few lines long is pretty low as a proportion, perhaps ~10%
10:48:25 <ski_> so, maybe it would be nicer if we had an operator `joinAp' to apply last
10:48:32 <FunctorSalad> dcoutts: I think that's a different issue... I think in my case the issue is that most of my packs are linked with process-1.0.1.0, then when you code something it will select process-1.0.1.1 by default and crash
10:48:44 <FunctorSalad> dcoutts: so I must avoid installing process-1.0.1.1
10:48:47 <ski_> joinAp :: Monad m => m (a -> m b) -> m a -> m b
10:48:53 <jeffwheeler> dcoutts: this is the setup.py stuff I'm referring to: https://svn.enthought.com/enthought/browser/Mayavi/trunk/setup.py
10:48:53 <FunctorSalad> (just an example, it also happens with other packs)
10:48:56 <ski_> return f `ap` x `joinAp` y :: m c
10:49:41 <dcoutts> FunctorSalad: you mean ghci will select process-1.0.1.1? or do you mean cabal configure will do
10:49:56 <Saizan> FunctorSalad: do you use "ghc"? if not you should be able to rebuild the other packages against the new process
10:49:57 <ski_> extendM4 f ma mb mc md = f `liftM` ma `ap` mb `ap` mc `joinAp` md
10:50:10 <jeffwheeler> dcoutts: that's what I love cabal for _not_ having
10:50:11 <FunctorSalad> dcoutts: ghci usually
10:50:21 <dcoutts> jeffwheeler: right
10:50:23 <FunctorSalad> Saizan: IIRC some depend on 1.0.1.0
10:50:29 <nikki93> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
10:50:30 <FunctorSalad> (but it's been some time)
10:50:34 <nikki93> How's that?
10:51:01 <FunctorSalad> Saizan: dcoutts: anyway, one fix is to put constraint==1.0.1.0 in your .cabal and never do cabal upgrade ;)
10:51:02 <luqui> I think I prefer extendM4 f ma mb mc md = join (f `liftM` ma `ap` mb `ap` mc `ap` md)
10:51:12 <FunctorSalad> constraint: process==1.0.1.0
10:51:16 * Saizan never does cabal upgrade
10:51:17 <ski_> (nikki93 : i think it's been said that that's not really a Scheme .. but it might be nice as a haskell tutorial .. i'm not sure)
10:51:27 <dcoutts> FunctorSalad: right, you'd have to hide the new one. Perhaps what you/we want to do in this situation is list some packages that you do not want to upgrade, or equivalently that you want to pick the installed version of certain packages
10:52:00 <dcoutts> FunctorSalad: I mean list them in the ~/.cabal/config
10:52:19 <dcoutts> FunctorSalad: as global constraints, "always pick an installed version of foo"
10:52:25 <ski_> luqui : not `.. = join (return f `ap` ma `ap` ..)', then ?
10:52:25 <FunctorSalad> ah yes I meant that one, not ".cabal"
10:53:28 <FunctorSalad> dcoutts: another solution would be if you could link ghc against the new version (then you could recompile everything with the newest process)
10:53:54 <FunctorSalad> maybe that doesn't make sense, I don't really know
10:54:01 <dcoutts> FunctorSalad: or equivalently if the upgrade planner considered the ghc package, rather than only the ones that can be upgraded
10:54:04 <nikki93> So what is a monad anyway?
10:54:23 <dcoutts> FunctorSalad: if we required global consistency then you would not get the problem, on the other hand global consistency is hard
10:54:38 <chessguy> @src Monad
10:54:38 <lambdabot> class  Monad m  where
10:54:38 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
10:54:38 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
10:54:38 <lambdabot>     return      :: a -> m a
10:54:38 <lambdabot>     fail        :: String -> m a
10:54:41 <chessguy> 'nuff said
10:54:46 <dcoutts> FunctorSalad: your existing set of installed packages is unlikely to be globally consistent
10:55:07 <ski_> nikki93 : a type constructor `m' which has `return' and `(>>=)' satisfying a few simple laws
10:55:17 <FunctorSalad> dcoutts: I tried ;)
10:55:42 <dcoutts> FunctorSalad: sorry, tried what?
10:55:59 <FunctorSalad> dcoutts: to keep it globally consistent, in case I need to use the packages together in one program
10:56:15 <ski_> nikki93 : however, i think usually it is best to look at various different examples of monads, first
10:56:20 <dcoutts> FunctorSalad: I see, right
10:56:21 <FunctorSalad> though conflicting quickCheck dependencies somehow didn't break it...
10:56:27 <Saizan> though, does ghc exposes anything from process?
10:56:49 <dcoutts> Saizan: I expect it's a purely private dependency
10:57:22 <dcoutts> FunctorSalad: perhaps we should default to trying for global consistency with upgrade and let the user supply an extra flag for semi-consistency
10:57:55 <ski_> nikki93 : i like "What the hell are Monads?" at <http://www-users.mat.uni.torun.pl/~fly/materialy/fp/haskell-doc/Monads.html> by Noel Winstanley
10:58:13 <FunctorSalad> nikki93: it's a way to "upgrade" types such that everything from the old type can be considered as something from the new type, and so that upgrading a type twice is as good as upgrading it once
10:58:49 <FunctorSalad> for example, you can turn a type "a" into "list of a", and consider every value x :: a as the one-element list [x]
10:59:08 <FunctorSalad> and two layers of list can be flattened into one
10:59:13 <vixey> that doesn't make sense
10:59:49 <FunctorSalad> vixey: why?
11:00:02 <vixey> it just doesn't
11:00:53 <sm> well this is silly.. but is there a way to seek to the beginning of stdin, to read it twice ?
11:01:01 <FunctorSalad> vixey: ah of course
11:01:04 <FunctorSalad> :p
11:01:35 <sm> I have parsec + error monad thingy reading the input, but I also need to get a raw copy of the whole thing
11:02:04 <vixey> sm, why don't you write a parser combinator for it instead
11:02:12 <FunctorSalad> vixey: obviously I should have told him that it's a monoid in a category of endofunctors and natural transformations between them
11:02:15 <sm> that is beyond me :/
11:02:21 <vixey> sm, it's easy
11:02:27 <vixey> you will do fine
11:02:34 <sm> I tried :)
11:02:44 <vixey> did something go wrong?
11:03:12 <nikki93> Really, most programs I think of writing (mostly games) have to 'do' something.
11:03:23 <sm> yes of course, I could not get it working in an affordable amount of time.. I was working with #haskell too
11:03:26 <nikki93> How does that translate into a functional paradigm where you just want to evaluate an expression?
11:03:33 <sm> but I hear you
11:04:09 <vixey> sm, did you figure out exactly what the combinator should do, and what type it has?
11:04:12 <mjrosenb> nikki93: in haskell, with monads
11:04:16 <vixey> regardless of being able to write it or not
11:04:28 <sm> I don't think so
11:04:39 <vixey> this is a reasonable  step 1, to try
11:04:39 <sleven> does real world haskell exist as pdf for free?
11:04:51 <jeffwheeler> sleven: I don't think as a PDF, but on the RWH website
11:04:58 <mjrosenb> nikki93: in other functional languages, they specify the order of execution exactly, and in such a way that you're guaraneed that side effects will occur
11:05:20 <sm> thanks vixey.. the problem is that is beyond me right now. truly. :)
11:05:48 <sm> I'll work on another bit and hope a contributor shows the way
11:05:51 <mjrosenb> jeffwheeler: wow, that just confused me to no end
11:06:07 <vixey> sm, why do you think that..?
11:06:11 <jeffwheeler> mjrosenb: sorry; I mean they have it available in HTML on the RWH website
11:06:15 <Gracenotes> @index first
11:06:15 <lambdabot> Control.Arrow
11:06:41 <dons> cosmicray (john goerzon) on why you should learn haskell, interviewed for oreilly, http://www.reddit.com/r/programming/comments/7qes2/john_goerzen_on_why_you_should_learn_haskell/
11:06:42 <mjrosenb> jeffwheeler: i'm used to rwh being  for bob harper, who wrote the sml spec
11:07:00 <dons> mjrosenb: "rwh being  for bob harper" ?
11:07:06 <jeffwheeler> mjrosenb: ;) Real World Haskell
11:07:06 <roconnor> jeffwheeler: I think your traverse is broken in the same way that Foldable was
11:07:20 * jeffwheeler investigates
11:07:20 <int80_h> r for robert
11:07:22 <dons> isn't bob's book PTS or something?
11:07:24 <pk> What's the syntax for declaring associated types ?
11:07:28 <dons> oh, of course :)
11:07:32 <roconnor> The simplest fix is traverse f (reverse ls)
11:07:32 <dons> *that* RWH.
11:07:52 <dons> i'd forgotten that encoding.
11:08:15 <mjrosenb> dons: yeah
11:08:17 <jeffwheeler> roconnor: I stole the version of traverse from Yi's WindowSet, but I'll try that
11:08:22 <mjrosenb> http://www.cs.cmu.edu/~rwh/
11:08:27 <chessguy> hey, do ya'all think Map a (Map b c) is the right representation in http://code.haskell.org/pci/examples/ch2/ ?
11:08:28 <roconnor> jeffwheeler: that is frightening
11:08:46 <BONUS_> gah ... how come you can't browse source from the new haddock :[
11:09:16 <int80_h> @seen lemmih
11:09:16 <lambdabot> lemmih is in #haskell and #lhc-compiler. I last heard lemmih speak 1m 16s ago.
11:09:20 <Lemmih> dons: People seem to be fond of LLVM. 80% of the traffic to the lhc blog goes to the article about llvm.
11:09:24 <int80_h> lemmih, you there?
11:09:30 <dons> Lemmih: similarly on arch linux' blog
11:09:36 <dons> the llvm article gets lots of hits.
11:09:37 <chessguy> BONUS: you can in hackage
11:09:43 <jeffwheeler> roconnor: on second look, apparently I forgot the 'reverse' from their version ;)
11:09:47 <sleven> *Matrix> (2,0) >= (0,1)
11:09:47 <sleven> True
11:09:51 <dons> Lemmih: use the haskell llvm bindings to do a quicky backend , and win lots of fans :)
11:09:51 <sleven> is not what i want
11:09:59 <BONUS> hmmm... can you browse the standard libs in hackage?
11:10:04 <int80_h> lemmih: I tried to send a private message, did you get it?
11:10:11 <dons> BONUS: i don't think so. only the standard ones that have packages on hackage.
11:10:21 <dons> but i have seen grand-unified haddocks for everything once or ttwice
11:10:21 <BONUS> ah
11:10:24 <sleven> i want to check that a uple is: (0,0) <= (a,b) <= (r,c)
11:10:32 <dons> presenting the giant tree of all modules would be very cool
11:10:38 <chessguy> sleven:  define <=
11:10:39 <BONUS> yeah i still keep viewing 6.8.3 documentation because it lets you view source
11:10:48 <dons> anyone want   to grab the hackage and stdlib tarball and graph the module hierarchy?
11:10:55 <sleven> llvm =?
11:11:03 <ski_> nikki93 : often, large amounts of a program can be written in a non-stateful way
11:11:06 <chessguy> > (1,2) <= (2,3)
11:11:07 <lambdabot>   True
11:11:11 <Lemmih> dons: LLVM is unfortunately quite badly suited for lazy, functional languages.
11:11:16 <jeffwheeler> roconnor: they use: WindowSet <$> (reverse <$> traverse f (reverse b)) <*> f c <*> traverse f a
11:11:54 <ski_> > (2,100000) <= (3,1)
11:11:56 <lambdabot>   True
11:12:00 <sleven> chessguy: (0,0) <= (a,b) -> 0 <= a and 0 <= b
11:12:16 <sleven> what is llvm?
11:12:16 <olsner> people expect LLVM to be the code generation silver bullet :)
11:12:18 <roconnor> jeffwheeler: hmm
11:12:22 <dcoutts> Lemmih: I don't understand the details of why that is. They have some API for accurate garbage collection. Does that not work?
11:12:24 <ski_> > (0,0) <= (1,-100000000)
11:12:26 <lambdabot>   True
11:12:29 <roconnor> jeffwheeler: that is right, but I think we can do something nicer
11:12:33 <thetallguy> Anyone know who wrote System.Console.Readline?
11:12:35 <chessguy> sleven:  oh, i think you just need a new instance of Ord
11:12:47 <Lemmih> dcoutts: Sure, but it is as efficient as accurate garbage collection in C.
11:12:54 <vixey> x1 < y1 \/ (x1 = y1 /\ x2 < y2) \/ ...
11:12:57 <dcoutts> Lemmih: http://llvm.org/docs/GarbageCollection.html
11:13:37 <ski_> (vixey : i wonder if there's a nicer way to state that ..)
11:13:49 <Lemmih> dcoutts: It requires you to put each GC root on the stack. This is ok for, say, Java but socks when you do 10+ million allocations per second.
11:13:50 <dcoutts> Lemmih: it's not clear to me why that is. If they provided nothing then you'd have to use the C trick.
11:13:55 <roconnor> @hoogle Applicative
11:13:56 <lambdabot> module Control.Applicative
11:13:56 <lambdabot> Control.Applicative class Functor f => Applicative f
11:13:56 <lambdabot> package applicative-extras
11:14:07 * Grizzly` bows to the room
11:14:10 <nikki93> Anyone used 'Clean'?
11:14:17 <int80_h> In a list of 2D points, I want to find the point with the lowest y value. Right now my algorithm sorts the list by y values and then will return the first point in the list. Is there a better way?
11:14:28 <roconnor> jeffwheeler: I want to use the Dual Applicative functor, if I can find it
11:14:29 <chessguy> ski_:  is it different from "x1 <= y1 /\ x2 <= y2" ?
11:14:31 <int80_h> I mean, do I need to sort.
11:14:44 <ski_> chessguy : yes
11:14:45 <Lemmih> dcoutts: It also means you can't have heap pointers in registers which again is ok for "normal" languages but very bad for Haskell.
11:14:47 <dcoutts> Lemmih: it claims on that page that for ocaml they have something: "It supports the Objective Caml language runtime by emitting a type-accurate stack map in the form of an ocaml 3.10.0-compatible frametable. The linkage requirements are satisfied automatically by the ocamlopt compiler when linking an executable."
11:14:50 <ski_> lexicographic ordering
11:15:06 <ski_> (chessguy : see my two examples above)
11:15:14 <Lemmih> dcoutts: I will explain all of it on the blog (:
11:15:14 <chessguy> int80_h:  i think a fold should be fine
11:15:20 <dcoutts> Lemmih: ok
11:15:34 <sleven> chessguy: but how? http://hpaste.org/14031 then? how would I declare that for all cases?
11:15:42 <int80_h> chessguy: oh, I can't use fold yet. This is from Chapter 3 of RWH
11:16:06 <int80_h> I think perhaps, given my constraints, I will need to sort.
11:16:06 <roconnor> crap
11:16:06 <roconnor> there seems to be no dual applicative functor :(
11:16:07 <Taejo> :t minBy
11:16:08 <lambdabot> Not in scope: `minBy'
11:16:13 <Taejo> :t minimumBy
11:16:14 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
11:16:20 <nikki93> int80_h: Have a variable called lowestY. Then iterate and make it min(lowestY, currY) each time.
11:16:25 <chessguy> int80_h:  so do the idea of fold, but without actually using fold
11:16:29 <nikki93> Damn I'm still imperative.
11:16:40 <ski_> sleven : how is `Tuple' defined ?
11:16:42 <int80_h> chessguy: nice!
11:16:48 <vixey> nikki93, lol
11:16:57 <Taejo> int80_h: the function you need is minimumBy
11:17:00 <Grizzly`> Does anybody know what Module ShowPackageId is in in cabal 1.6? doesn't seem to be Distribution.Package (like in older Cabal Versions) nor Distribution.Text (like a discussion in an older log of this channel supposes)
11:17:04 <dons> how's this for a nice comment, http://twitter.com/kapilash/status/1125895562 :)
11:17:10 <Grizzly`> at least I still get not in scope...
11:17:11 <int80_h> @foldr
11:17:15 <int80_h> @src foldr
11:17:15 <lambdabot> foldr f z []     = z
11:17:15 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:17:28 <ski_> nikki93 : <http://arcanux.org/lambdacats/varbl.jpg>
11:17:58 <sleven> ski_ im just sketching, i dont really know how to start
11:18:18 <chessguy> dons:  i don't get it. how does flashing RWH get anything done?
11:18:23 <ski_> sleven : what do you want to do ?
11:18:25 <int-e> chessguy: Map a (Map b c) is good if most values 'a' occur more than once. Otherwise, Map (a, b) c seems better.
11:18:30 <Saizan_> Grizzly`: i think you should use Distribution.Text.display
11:18:31 <twanvl> roconnor: you mean like "t a * t b -> t (a * b)" is dual to "t (a+b) -> t a + t b"?
11:18:40 <Grizzly`> i'll try :)
11:18:54 <nikki93> lol
11:19:12 <nikki93> Has anyone used the programming language known as 'Clean'?
11:19:35 <sleven> ski_ (0,1) <= (1,0) -> False , byd efault it is True
11:19:41 <int-e> chessguy: if Map had a special, compact representation for singleton maps (it doesn't), Map a (Map b c) would never be worse thant Map (a,b) c, I think.
11:19:52 <dcoutts> Grizzly`: there is no module ShowPackageId in Cabal-1.6, did you mean a function or something?
11:20:02 <chessguy> int-e:  thanks for the comments. i'm not sure what you mean by "values 'a'"
11:20:17 <roconnor> twanvl: I want the f <*> x = x <**> f applicative functor
11:20:29 <ski_> > (0,1) <= (1,0)     where   (0,1) <= (1,0) = False
11:20:31 <lambdabot>   False
11:20:42 <chessguy> Map a (Map b c) can only store one Map for any value of type 'a', yes?
11:20:59 <Grizzly`> dcoutts, I think the Setup.lhs I got is not supposed to be compatible with Cabal 1.6, but with the cabal version that was supposed to come with ghc 6.8... I'm just trying to get around what causes the problem...
11:21:02 <Grizzly`> naively :)
11:21:13 <int-e> chessguy: I mean the values of type a. (which is one of the key types)
11:21:17 <ski_> sleven :maybe you could explain more carefully exactly when `(a0,b0) <= (a1,b1)' should be `True' ?
11:21:30 <roconnor> jeffwheeler: bah.  I guess start with the reverse-traverse-reverse thing, and we can see about doing better later
11:21:32 <twanvl> roconnor: so with reversed order of effects, you can of course use a newtype for that
11:21:36 <dcoutts> Grizzly`: ah, you mean the old Distribution.Package.showPackageId, yes that's now Distribution.Text.display (it's a type class)
11:21:44 <jeffwheeler> roconnor: yep, posted it here: http://hpaste.org/14030#a2
11:21:45 <sleven> ski_ yes but for all variations of (a,b) <= (c,d)
11:21:55 <roconnor> twanvl: yes yes, but I thought it would be part of Control.Applicative
11:22:09 <Grizzly`> dcoutts, I have a line that says ">          shownPackageId = showPackageId (package description)
11:22:09 <Grizzly`> "...
11:22:20 <ski_> sleven : but unless you tell when that should be `True' and when that should be `False', i have no idea what your `(<=)' is supposed to do
11:22:25 <int-e> chessguy: yes. so? You get Map a (Map b c) by currying Map (a, b) c, once you realize that a Map is really a function with a finite domain.
11:22:37 <sleven> <= means bigger than or equal to
11:22:44 <sleven> right?
11:22:50 <ski_> yes
11:22:51 <dcoutts> Grizzly`: use: display (packageId pkg)
11:22:55 <sleven> but whatever i can wrie a special one
11:22:57 <nikki93> Which is more efficient? "factorial n = if (n > 1) then n * factorial (n - 1) else 1", or omiting the if/then/else and using "factorial 0 = 1" and "factorial 1 = 1" before "factorial n = n * factorial (n - 1)"?
11:23:12 <dcoutts> Grizzly`: display is from Distribution.Text, packageId is from Distribution.Package
11:23:19 <int-e> chessguy: Note that I don't know what exactly the problem that is being solved is.
11:23:20 <Grizzly`> like in "> shownPackageId = display (packageId pkg)" ?
11:23:27 <ski_> sleven : presumable you have some specific meaning of `(<=)' on pairs in mind .. since you want to write this ?
11:23:31 <dcoutts> Grizzly`: yep
11:23:32 <vixey> ski_,(large \/ and large/\)   \/[i=1..n] ((/\[j=1..i-1] xi = yi) /\ xi < yi)
11:24:00 <roconnor> @type traverse
11:24:01 <lambdabot> Not in scope: `traverse'
11:24:03 <vixey> nikki93, the pattern matching one is more readable
11:24:04 <ski_> vixey : whence `large' ?
11:24:09 <roconnor> @hoogle traverse
11:24:10 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
11:24:10 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
11:24:15 <vixey> ski_, like capitol sigma for summation
11:24:16 <nikki93> vixey: Ok, but I'm talking about efficiencyness.
11:24:26 <vixey> nikki93, no clue
11:24:35 <chessguy> int-e:  it's for weighted associations. e.g. DataSet Person Item EnjoymentOnAScaleFrom1To5
11:24:42 <ski_> (.. oh, i thought it was a variable)
11:24:56 <vixey> nikki93, I can't see any algorithmic difference so I would say they are equally efficient
11:25:00 <sleven> ski: eqa x y = fst x <= fst y && snd x <= snd y ;; does the job, was jsut wondering if there was a builtin one
11:25:16 <chessguy> (i think EnjoymentOnAScaleFrom1To5 is an awesome type and should be in the standard library)
11:25:31 <ski_> sleven : how are you going to implement `compare' for that ?
11:25:33 <vixey> sleven yuck
11:25:47 <olsner> @ty mappend (comparing fst) (comparing snd)
11:25:48 <lambdabot> forall a b. (Ord b, Ord a) => (a, b) -> (a, b) -> Ordering
11:25:50 <vixey> sleven, eqa x y && eqa y x does -not- mean x = y
11:26:06 <ski_> sleven : which is largest of `(5,3)',`(4,6)' ?
11:26:42 <ski_> olsner : i think we've concluded that sleven isn't after the lexicographic ordering ..
11:27:03 <olsner> bah! and here I thought I was being clever
11:28:12 <ski_> @src (->) Ord
11:28:12 <lambdabot> Source not found.
11:28:21 <ski_> er
11:28:25 <ski_> @src (->) compare
11:28:25 <lambdabot> Source not found. Just what do you think you're doing Dave?
11:28:32 <roconnor> jeffwheeler: Idealy I'd like sequenceA (Zipper ls x rs) = Zipper <$> unDualA (sequenceA (map DualA ls))  <*> x <*> sequenceA rs
11:28:44 <roconnor> but DualA and unDualA don't seem to exist at the moment
11:30:37 <ski_> (roconnor : `OppositeA' wouldn't be a better name ?)
11:30:42 <roconnor> sure
11:31:06 <ski_> @hoogle Dual
11:31:06 <lambdabot> Data.Monoid newtype Dual a
11:31:06 <lambdabot> Data.Monoid Dual :: a -> Dual a
11:31:06 <lambdabot> Data.Monoid getDual :: Dual a -> a
11:31:14 <int-e> chessguy: Ok. I like  Map a (Map b c)  then.
11:31:32 <roconnor> ski_: isn't <*> a monoid?
11:31:42 <chessguy> int-e:  thanks
11:31:44 <ski_> @type (<*>)
11:31:45 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
11:31:51 <roconnor> sorry
11:31:53 <roconnor> my dum
11:32:03 <roconnor> stupid symetric symbol
11:32:08 <ski_> exactly
11:32:15 <roconnor> When I'm king of the world it will be called <@>
11:32:38 * chessguy plots against the future king
11:32:49 <ski_> it might be called `($<)' or something of the like
11:32:52 <roconnor> @kill chessguy
11:32:52 <lambdabot> Maybe you meant: keal kind tell
11:33:02 <roconnor> @keal chessguy
11:33:02 <lambdabot> nsa prevent me from returning to math on efnet
11:33:05 <ski_> @type (<**>)
11:33:06 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
11:33:20 <ski_> might then be `(>$)'
11:33:49 <roconnor> ski_ ?
11:34:13 <chessguy> roconnor:  lol
11:34:22 <ski_> any assymetric operator name would be better than the current one(s)
11:34:28 <chessguy> @keal
11:34:29 <lambdabot> i need math friendly compiler to compile for jvm or flash
11:35:35 <ski_> (roconnor : all clear ?)
11:36:18 <nikki93> Clean has a concept of 'function guards', along with the usual pattern matching for similar ideas.
11:36:23 <nikki93> DOes haskell have something like that?
11:36:26 <nikki93> (not comparing, asking)
11:36:37 <roconnor> yep
11:37:09 <ski_> @src take
11:37:09 <lambdabot> take n _      | n <= 0 =  []
11:37:09 <lambdabot> take _ []              =  []
11:37:09 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
11:37:31 <dons> nikki93: guards? sure.
11:37:34 <dons> f x | x > 2 = 7
11:37:37 <dons> that kind of thing?
11:37:54 <dons> pretty much the same as in clean, but we use | otherwise = 7 instead of the default case in clean
11:38:15 <gwern> hm, hlint doesn't warn about using [Char]
11:38:31 <dons> good response on reddit. http://www.reddit.com/r/programming/comments/7qhdv/darcs_22_released_performance_libdarcs_general/
11:38:38 <dons> gotta work at getting darcs releases publicised, guys.
11:38:48 <dons> the blog is a great step
11:38:51 <Taejo> > otherwise
11:38:52 <lambdabot>   True
11:40:08 <nikki93> > "25"
11:40:09 <lambdabot>   "25"
11:40:23 <vixey> > show "25"
11:40:24 <lambdabot>   "\"25\""
11:40:45 <nikki93> > let fac x = if (x > 1) then x * fac (x - 1) else 1
11:40:46 <lambdabot>   <no location info>: parse error on input `;'
11:40:52 <nikki93> ??
11:41:02 <nikki93> > fac x = if (x > 1) then x * fac (x - 1) else 1
11:41:02 <vixey> @let fac x = if (x > 1) then x * fac (x - 1) else 1
11:41:03 <lambdabot>   <no location info>: parse error on input `='
11:41:04 <lambdabot>  Defined.
11:41:10 <vixey> > fac 13
11:41:10 <nikki93> > fac 3
11:41:12 <lambdabot>   6227020800
11:41:12 <lambdabot>   6
11:41:15 <nikki93> LAG!
11:41:16 <nikki93> :P
11:41:27 <nicou> > fac 3
11:41:29 <lambdabot>   6
11:41:30 <nikki93> Lets make a game on lambdabot and play it here.
11:41:35 <nikki93> Hmm...
11:41:49 <vixey> hehe
11:42:54 <nikki93> @ let lols x = if (x > 0) then "LO" ++ lols (x - 1) else "L!"
11:43:05 <nikki93> @let lols x = if (x > 0) then "LO" ++ lols (x - 1) else "L!"
11:43:06 <lambdabot>  Defined.
11:43:11 <nikki93> > lols 10
11:43:13 <lambdabot>   "LOLOLOLOLOLOLOLOLOLOL!"
11:43:16 <nikki93> :)
11:43:37 <nikki93> > lols (fac 4)
11:43:38 <lambdabot>   Not in scope: `fac'
11:43:47 <nikki93> It 'forgot' fac?
11:44:01 <nicou> probably the environment gets resetted or something?
11:44:14 <nicou> reset*
11:44:26 <nicou> > fac 3
11:44:28 <lambdabot>   6
11:44:30 <chessguy> you could just write "lols 24" :)
11:44:42 <nicou> it works
11:44:55 <nicou> (fac 3) + 2
11:45:01 <nicou> > (fac 3) + 2
11:45:03 <lambdabot>   8
11:45:15 <nicou> > lols (fac 3)
11:45:16 <lambdabot>   "HIHIHIHIHIHIH!"
11:45:19 <vixey> > lols (fac 4)
11:45:20 <lambdabot>   "HIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIH!"
11:45:24 <vixey> > lols (fac 5)
11:45:25 <lambdabot>   "HIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHI...
11:45:48 <mstr> > map lols [1..3]
11:45:49 <lambdabot>   ["HIH!","HIHIH!","HIHIHIH!"]
11:46:05 <nicou> > map lols (map fac [1..])
11:46:07 <lambdabot>   ["HIH!","HIHIH!","HIHIHIHIHIHIH!","HIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHIHI...
11:46:18 <nikki93> curryation!
11:46:32 <nicou> I'm a schemer newbie
11:46:42 <nikki93> I'm new to Haskell.
11:46:47 <nikki93> But I'll use this channel for spam.
11:46:50 <Taejo> nicou: map f . map g == map (f . g)
11:46:51 <nicou> I'm newer to Haskell
11:46:52 <nikki93> Check out www.grall.uni.cc.
11:46:56 <nicou> thanks
11:47:02 <nikki93> nicou: No, I'm newer.
11:47:06 <dons> ok. my day has been made. jeff heard has a haskell visualisation blog.
11:47:08 <dons>  http://www.reddit.com/r/programming/comments/7qhlj/visualising_10_terabytes_of_web_traffic_with/
11:47:09 <pumpkin> ...
11:47:11 <nicou> I didn't even think of the composition operator
11:47:11 <dons> check it out.
11:47:40 <gwern> there's something very satisfying about refactoring to move IO up the call stack
11:48:20 <nicou> I wish it could be bigger
11:48:24 <dons> wow, the animation is awesome.
11:48:28 <dons> http://vizserv5.renci.unc.edu/projects/jun04_2008/europa/ibiblio/
11:48:33 <gwern> nicou: the composition operator?
11:49:05 <nicou> gwern: Isn't . the composition operator?
11:49:16 <gwern> you could do what the cool kids do and use unicode I suppose for a bigger dot...  · etc
11:49:17 <nikki93> gwern: Are you the guy who made a lot of suggestions to RWH?
11:49:38 <gwern> nikki93: I made a number of them but not enough to make it to the credits, so no :)
11:49:58 <nikki93> How about this factorial function?
11:50:11 <nicou> gwern: well it's isn't a s,mcircle anyway
11:50:16 <nikki93> @let fac n = product [1..n]
11:50:17 <lambdabot>  <local>:2:0:
11:50:17 <lambdabot>      Warning: Pattern match(es) are overlapped
11:50:17 <lambdabot>               In...
11:50:19 <nicou> gwern: well it's isn't a small circle anyway
11:50:24 <nikki93> > fac 2
11:50:25 <lambdabot>   2
11:50:28 <sleven> data Matrix m = Matrix (m :: (DA.Array (Integer,Integer) Double))
11:50:32 * gwern has no idea what nicou means
11:50:34 <nikki93> @let FACCCC n = product [1..n]
11:50:35 <lambdabot>  <local>:3:0: Not in scope: data constructor `FACCCC'
11:50:35 <lambdabot>  
11:50:35 <lambdabot>  <local>:3:23:
11:50:35 <lambdabot>      A...
11:50:39 <sleven> how do i declare it?
11:50:39 <sleven> data Matrix = Matrix DA.Array (Integer,Integer) Double
11:50:44 <nikki93> @let faccc n = product [1..n]
11:50:45 <lambdabot>  Defined.
11:50:51 <nikki93> > faccc 5
11:50:52 <lambdabot>   120
11:50:55 <nikki93> YEAH!
11:50:58 <gwern> nikki93: a leading capital means a type, not a functon
11:50:58 <nikki93> I rock!
11:50:59 <nikki93> :P
11:51:03 <nikki93> gwern: Figured. :)
11:51:16 <ski_> sleven : `m' is not used in the type
11:51:18 <nicou> gwern: I'm sorry, I'm so new to Haskell, but Taejo said:
11:51:18 <nicou> Taejo: nicou: map f . map g == map (f . g)
11:51:21 <nikki93> gwern: I'm not THAT bad, ok? :P
11:51:26 <sleven> i want Matrix to be of type DA.Array
11:51:38 <nicou> gwern: that dot composes functions, right?
11:51:47 <ski_> sleven : i don't belive you
11:51:57 <nikki93> I'm  still a little scared about performance issues about recursion vs loops
11:52:12 <vixey> nikki93, specifically?
11:52:16 <ski_> sleven : i think you want `Matrix' to be of type `DA.Array (Integer,Integer) Double -> Matrix'
11:52:20 <Taejo> nikki93: we don't call our compiler Glorious for nothing
11:52:30 <gwern> nicou: well if you use a cool editor like emacs or yi or leksah, they'll include in the syntax highlighting a 'ordinary -> Unicode' step, so your dull ASCII haskell looks more interesting
11:52:36 <int80_h> nikki93: not a worry. any modern compiler will translate recursion to iteration.
11:52:37 <Taejo> nicou: yes, (.) is composition
11:52:42 <gwern> eg 'setTopLevelModules [(takeWhile (≠ '.') lfl')]'
11:53:08 <vixey> the translatable form of recursion *is* iteration
11:53:13 <nicou> gwern: Oh, okay. I'm also new to Linux, vi, and Unicode, so... :P
11:53:16 <nicou> gottago
11:53:23 <ski_> sleven : tried something like `data Matrix = MakeMatrix {getMatrix :: DA.Array (Integer,Integer) Double}' ?
11:53:30 <gwern> or cool lambdas like ' E.evaluate (uncons str) `E.catch` λe →  return $ Exception $ toStream (show e)'
11:53:35 <sleven> yes so how do I declare that?
11:53:55 <ski_> sleven : that was a type declaration
11:53:56 <nikki93> Are there any 3d games around written in haskell?
11:54:00 <gwern> yes
11:54:04 <ski_> @where frag
11:54:04 <lambdabot> http://www.haskell.org/haskellwiki/Frag
11:54:08 <gwern> did you look in the games section of hackage?
11:54:09 <sleven> yes that works but i dont want it, it is basically what i ahd before
11:54:09 <int80_h> yay frag
11:54:09 <Heffalump> yes, Matthew Sackman and Tristan Allwood have one
11:54:19 <luite_> I've written a program that spends most of its time in a foreign function. When I compile the program with -threaded, it runs about 25% faster, without specifying +RTS -N2? using the -N2 option doesn't make any difference at all (makes it slower, if anything). is parallellism handled in some special way for foreign functions?
11:54:23 <gwern> Heffalump: they do? is it on hackage?
11:54:28 <Heffalump> not sure
11:54:35 <gwern> Heffalump: ln pls kthnxbai
11:54:39 <nikki93> I found this: http://www.haskell.org/haskellwiki/Frag
11:54:46 <Heffalump> just looking - all I know about it is from their London HUG talk
11:54:47 <sleven> data Hey x = Hey x | Yey x
11:54:49 <nikki93> ski_: Oh lol, I found it myself. :)
11:55:12 <ski_> sleven : .. yes ?
11:55:20 * gwern calls on the dark powers of ft'hagn'Googul to deliver me sackman's game
11:55:30 <dons> luite_: foreign threads are handled differently
11:55:37 <dons> also the threaded runtime is just a different runtime
11:56:22 <dons> dcoutts: you should mention this on the gtk blog (i think he's using the gtk2hs cairo bindings) http://vis.renci.org/jeff/?p=33
11:56:30 <gwern> 154mb? how long is this video? :(
11:56:32 <Heffalump> http://www.zonetora.co.uk/2007/09/24#LondonHug1 has their talk, but I can't find the game anywhere, sorry..
11:56:35 <pumpkin> Heffalump: I used something like your RMonad idea of Suitable typeclasses to get a workable "callable/applicable/morphism/arrow-wheel-reinvention" implementation :D
11:56:46 <Heffalump> oh yes?
11:56:59 <Heffalump> (btw the Suitable idea came from someone on haskell-cafe, not me)
11:57:06 <pumpkin> it's pretty ugly, but it sort of does what I want it to
11:57:10 <pumpkin> ah, cool :)
11:57:26 <dcoutts> dons: yes, that's pretty cool
11:57:46 <luite_> dons: ah ok. does ffi parallellism work for unsafe functions?
11:58:46 <ski_> (gwern : maybe you mean <http://cthuugle.com/en/> ?)
11:59:14 <pejo> Anyone here in Savannah and up for dinner today/tomorrow?
12:00:19 <Heffalump> pumpkin: got some code to show?
12:01:22 <gwern> ski_: you pray to your gods, I'll pray to mine
12:01:43 <pumpkin> Heffalump: it's a little embarrassing, but sure :P http://hpaste.org/14032 (you make something "applicable" by using the ? postfix operator, then you can call it like a function)
12:02:09 <ski_> (gwern : ah, but which are which ? :)
12:02:23 <gwern> ski_: we'll know based on who gets eaten last
12:02:42 <roconnor> hmmm, hard to download network drivers without the network
12:04:05 <Heffalump> pumpkin: ah, one of the key bits of rmonad for me is the embedding into real monads. Thinking about it, I think that's the bit where I had trouble with first.
12:04:10 <dons> vixey: did you see that with the qt license change, qthaskell is now packaged up natively, http://aur.archlinux.org/packages.php?ID=23168
12:04:34 <vixey> no I didn't know about that
12:04:48 <Heffalump> anyway, restricted-foo all good :-)
12:05:22 <gwern> I thought qt was gpl, why would a switch to lgpl lead to it being packaed?
12:05:30 <dons> so that's kind of exciting. it means we now have 3 active gui projects
12:05:32 <pumpkin> Heffalump: yeah, my main motivating idea was being able to "call" Data.Maps like functions, compose them, etc. Then I was thinking of other types that felt like they could be "callable", like matrices, and an isomorphism wrapper datatype. Not particularly interesting or well grounded in theory, but it helps me grasp more :)
12:05:37 <nikki93> Who here uses xmonad?
12:05:37 <gwern> (also, does anyone even use qthaskell?)
12:05:38 <dons> gtk2hs, wxhaskell and qthaskell
12:05:41 <dons> besides the pure haskell ones.
12:05:48 <asgaroth_> nikki93: me
12:05:50 <dons> gwern: i think there's more of a chance now.
12:05:55 <dons> nikki93: ask in #xmonad :)
12:06:24 <nikki93> dons: :)
12:06:36 <gwern> dons: well, I guess if it's packaged in any form that's better than before
12:06:38 <nikki93> dons: I know about #xmonad, I frequent there. I was bored and though I'd spam.
12:07:06 <dons> gwern: it had some weird non-distribution thing going on.
12:07:25 <int80_h> @tan (5,3) (5,6)
12:07:26 <lambdabot> Maybe you meant: faq map run thx wn
12:07:26 <dons> i don't recall the details, but we had several emails about it
12:07:33 <int80_h> @src tan (5,3) (5,6)
12:07:33 <lambdabot> Source not found. :(
12:07:45 <int80_h> @src tan
12:07:45 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
12:08:02 <C-Keen> @hoogle tan
12:08:02 <lambdabot> Prelude tan :: Floating a => a -> a
12:08:02 <lambdabot> Prelude tanh :: Floating a => a -> a
12:08:02 <lambdabot> Prelude atan :: Floating a => a -> a
12:08:16 <sleven> let cw c a b = a c b
12:08:23 <sleven> Matrix> cw (<) 10 20
12:08:23 <sleven> <interactive>:1:7:
12:08:23 <sleven>     No instance for (Num ((a -> a -> Bool) -> t1 -> t2))
12:08:25 <sleven> why not?
12:10:08 <pejo> sleven, `c`, not c
12:13:01 <Liskni_si> > let cw (~) a b = a ~ b in cw (<) 10 20
12:13:01 <lambdabot>   <no location info>: parse error on input `)'
12:13:17 <Liskni_si> > let cw (%) a b = a % b in cw (<) 10 20
12:13:18 <lambdabot>   True
12:13:37 <Cale> ah, hehe, lazy patterns :)
12:18:10 <gwern> dons: binding to c++ from haskell is hard; qthaskell was using some strange script to generate C files which haskell could then bind to
12:19:58 <dons> yup
12:20:44 <int80_h> as soon as I get through the FFI chapter of RWH, I want to try and create haskell bindings for libnova
12:21:38 <dons> cool. someone has decided to downmod all submissoins to the haskell reddit. that's pointless. http://www.reddit.com/r/haskell/new/
12:21:41 <dons> int80_h: yay!
12:22:32 <pumpkin> people are ridiculou
12:22:40 * jeffwheeler definitely thought they meant 'demonic', not 'daemonic'
12:23:14 <int80_h> dons: well my Grand Evil Scheme (tm) is to write a web app that allows you to find planet location on the celestial sphere, given date and long/lat. I figure writing haskell bindings to libnova is a good first tangible step.
12:23:20 <dons> mm
12:23:27 <sleven> well not that i have discovered what a secret weapon haskell is i think the development on it shouldt stop and you should all go back to C++/Java
12:24:05 <sleven> but i still havent managed to created a randommatrix function for my matrix lib so maybe I should instead...
12:24:23 * int80_h is in Java Rehab.
12:24:32 <pumpkin> sleven: wli is also working on a matrix lib!
12:24:40 <pumpkin> I can't wait
12:24:44 <int80_h> not really. never learned Java. I suppose I should.
12:25:37 <jeffwheeler> int80_h: It's funny. I love Haskell for its ability to abstract everything. I hate Java for abstracting everything, though. :P
12:26:08 <jeffwheeler> I guess there are different kinds of abstractions. Haskell's kind, like monads, and Java's kind, with 19 URI* classes
12:26:29 <int80_h> jeffwheeler: yeah, I never saw the point in schools teaching data structures in something like Java. I worked with a guy who was useless because he never learned how to do a linked list in C.
12:27:12 <int80_h> I mean, I can see doing it in Java for convenience, *once* you've learned a lower level abstraction such as whaty C presents.
12:27:14 <jeffwheeler> int80_h: mmhmm; I was taught linked lists in Java, initially, though
12:28:23 <sleven> is the sequence Monad what makes it possible to do IO in order?
12:28:41 <dmwit> sequence is not a monad.
12:29:03 <dmwit> sequence is a function that acts on lists of monadic actions to turn them into a single monadic action with a list as its computation type.
12:29:22 <dmwit> ...which is just a wordy way to say its type:
12:29:23 <dmwit> :t sequence
12:29:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:31:16 <pejo> sleven, are you doing your matrix lib for fun, or need it for something else?
12:31:17 <sleven> if i read in a bitmap or jpg file, what do I get?
12:31:32 <sleven>  basically want the bytes, or the pixels
12:32:18 <blackh> sleven: What exactly do you want to do?
12:32:34 <chessguy> can someone familiar with propositional logic spot-check my sanity please? http://hpaste.org/14033
12:32:51 <sleven> blackh: image analysis
12:32:51 <dmwit> sleven: I recommend using an image library, which will hold an abstract representation of the image somewhere.  Gtk2Hs can do it; there's also several image-only libraries on Hackage.
12:33:04 <sleven> i want to write my own image-library
12:33:06 <pumpkin> sleven: if you use a package that knows images to read it, you get image data :P if you use readFile or similar, you get the bytes in the file
12:33:32 <pumpkin> sleven: check the codec section on hackage
12:33:37 <blackh> sleven: A binding to a C library, or from scratch?
12:33:38 <chessguy> sleven:  that's a bit like learning about archtiecture by building a skyscraper :)
12:33:56 <chessguy> or learning spelling by reading my typing...
12:34:03 <gwern> cool, now orchid is using filestore
12:34:10 <pumpkin> orchid?
12:34:16 <pumpkin> balls?
12:34:28 <gwern> orchid, the wiki
12:34:32 <skorpan> what are the X and Y parameters for in the hpaste.org POST request?
12:35:14 <sleven> chessguy: from scratch, just want to be able to put the pixels in a matrix
12:36:29 <Gracenotes> skorpan: hm? the target is http://hpaste.org/new, the text has the name "content"; name is "nick", title is "title"
12:37:07 <blackh> sleven: Try hsmagick.
12:37:09 <Gracenotes> looks like it's application/x-www-form-urlencoded, as usual
12:44:41 * roconnor uses GuiTV
12:44:48 <roconnor> oops
12:44:56 * roconnor is running behind
12:46:01 <skorpan> Gracenotes: but in the actual POST for some reason "x" and "y" appear
12:47:03 <Gracenotes> what do you mean?
12:47:19 <Gracenotes> your browser added the two parameters when it did a POST?
12:47:35 <skorpan> yes
12:48:01 <Gracenotes> ....odd-ish.
12:48:36 <skorpan> announce=XXX&content=XXX&nick=XXX&remember=XXX&title=XXX&x=30&y=8
12:49:08 <sleven> what do I dow ith a handle? how do irea din the bytes?
12:49:09 <skorpan> the values of x and y change every time
12:49:28 <pumpkin> sleven: hGetContents?
12:49:39 <kerlo> sleven: hGetChar, hGetLine, hGetContents, etc.
12:49:52 <blackh> skorpan: Are you using an HTML image map?
12:50:04 <dmwit> Using hGetContents or readFile to read a binary file is really bad advice.
12:50:06 <skorpan> blackh: not that i'm aware of?
12:50:20 <dmwit> If you want bytes, read in a ByteString.  That's what it's for.
12:50:33 <blackh> skorpan: If you are, that would explain it. The browser adds the position where you clicked.
12:50:52 <kerlo> Is String defined as a string of Unicode characters, which may or may not be byte-encoded in the way you want?
12:50:57 <dmwit> Otherwise, you're likely to be bitten on any implementation that actually correctly implements hGetContents or readFile.  (...not that any do right now)
12:51:10 <skorpan> blackh: oh, yes, it's an input type="image"
12:51:14 <dmwit> kerlo: String is defined as a list of Unicode characters, which are not encoded.
12:51:25 * kerlo nods
12:52:18 <dmwit> If you're actually reading in a non-trivial file format, you probably want to combine your ByteString with some Get/Put monads.
12:52:59 <Gracenotes> oh, I think I figured out how to detect primality in the lambda calculus! Thanks, Wilson's theorem
12:54:49 <dmwit> I'm still proud of this little hack: http://www.reddit.com/r/programming/comments/7q8pg/i_was_hired_to_write_a_device_driver_for_an_old/c073go1?context=1
12:55:01 <dmwit> I boasted about it last night, too. =)
12:58:18 <pumpkin> dmwit: I'd try it but I don't have aplay :/
12:58:39 <dmwit> Well, your favorite wav-player, then.
12:58:52 <dmwit> You could do "./tempo >/dev/dsp" on many systems.
12:59:05 <dmwit> ...or are you on Windows...
12:59:17 <pumpkin> mac os :)
12:59:19 <pumpkin> no /dev/dsp
12:59:34 <pumpkin> but I'll do it in two steps!
13:03:25 <sleven> getContents :: IO ByteString
13:03:29 <sleven> so what do i pass it?
13:03:38 <sleven> just the string-path didnt work
13:03:45 <dmwit> That one reads stdin, so you don't pass it anything.
13:03:56 <sleven> ah readFile
13:04:06 <dmwit> That's probably better.
13:04:38 <asgaroth> There's also hGetContents if you need more fine-grained access about opening/closing the file
13:05:11 <pumpkin> as dmwit says, the ByteString ones are probably best
13:05:15 <sleven> readFile :: FilePath -> IO ByteString
13:05:33 <sleven> so why cant i getContents on that?
13:05:39 <sleven>  Couldn't match expected type `ByteString -> t'
13:05:40 <sleven>            against inferred type `IO ByteString'
13:05:47 <skorpan> as dmwit said, getContents reads stdin...
13:05:55 <pumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString.html#v%3AreadFile
13:06:16 <pumpkin> sleven: you need to import (qualified) Data.ByteString (as B)
13:06:24 <pumpkin> and use ByteString's readFile
13:06:55 <dmwit> sleven: Why would you use both getContents and readFile?
13:07:04 <dmwit> sleven: readFile already returns the whole contents of the file.
13:07:23 <sleven> i have done that
13:07:47 <sleven> Chunk "\255\216\255\224\NUL\DLEJFIF\NUL\SOH\STX\NUL\NULd\NULd
13:07:50 <sleven> so what is that?
13:08:25 <dmwit> sleven: It's the bytes 255, 216, 255, 224, 0, etc.
13:08:26 <asgaroth> sleven: The contents of your file probably
13:09:00 <dmwit> Looks like a jpeg file to me.
13:09:10 <dmwit> > map ord "\DLEJFIF"
13:09:11 <sleven> yes sure
13:09:11 <lambdabot>   [16,74,70,73,70]
13:09:19 <sleven> but DLEJFIF etc
13:09:23 <sleven> how do i decode it
13:09:31 <dmwit> It's already decoded!
13:09:36 <sleven> or how do I turn it all into number si mean
13:09:42 <dmwit> It *is* all numbers.
13:09:43 <sleven> SOH it is not hexadeciaml obv
13:09:52 <dmwit> Just because it prints that way doesn't mean anything...
13:10:17 <dmwit> Maybe you should read the ByteString docs to see how to munge ByteStrings. ;-)
13:10:41 <sleven> and Chunk and Empty in the beginning what does that mean?
13:10:51 <pumpkin> that's just how the bytestring is represented
13:11:09 <pumpkin> but the chunks are relatively transparent
13:11:44 <blackh> sleven: If you want to decode it, use hsmagick!
13:11:55 * dmwit continues to agree with blackh
13:12:19 <dmwit> This is why God created libraries.  So that we don't all have to write this kind of boring code.
13:12:30 <sleven> Couldn't match expected type `ByteString'
13:12:30 <sleven>            against inferred type `IO ByteString'
13:12:37 <sleven> how do I get away from IO again?
13:12:50 <sleven> well i want to learn that its fine
13:13:10 <pumpkin> <-
13:13:16 <pumpkin> or fmap, or >>=
13:13:17 <asgaroth> sleven: >>= or do notation and <-
13:13:26 <pumpkin> depends what you want to do, really
13:13:32 <pumpkin> you can never truly escape IO*
13:13:52 <asgaroth> except for unsafePerformIO but that's evil and should not be used _ever_
13:14:05 <asgaroth> except maybe in some very very rare cases
13:14:13 <pumpkin> well, for FFI stuff
13:14:19 <pumpkin> I think is all it's really designed for
13:14:23 <hugo___1> asgaroth: like what ?
13:14:26 <dmwit> You don't leave IO; you bring everything else *into* IO.
13:14:49 <pumpkin> hugo___1: say you have an FFI interface to a c function you know is pure
13:14:54 <dmwit> hugo___1: Like for calling functions like "sin" that are morally pure, bet technically impure.
13:15:20 <pumpkin> but I think there's a way of telling the FFI that it's pure without having to ever write unsafePerformIO isn't there, too?
13:15:20 <dmwit> hugo___1: Also, what's up with the "___1" bit? =P
13:15:24 <dmwit> no
13:15:32 <sleven> B.split (B.pack "\\") im
13:15:41 <ski_> pumpkin : yes
13:15:44 <dmwit> There's safe/unsafe annotations, but that has to do with GC, not purity.
13:15:46 <hugo___> sorry :P
13:15:50 <dmwit> Wait, yes?
13:16:09 <sleven> but thats just bull if it forces me to fuck around with a bunch of ridic restrictions
13:16:45 <pumpkin> > onoesNetsplit
13:16:46 <lambdabot>   onoes, netsplit!
13:17:36 <ski_> 3.3 Foreign Declarations - Import Declarations <http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise3.html#x6-130003.3>
13:17:46 <ski_>   foreign import ccall "math.h sin" sin :: CDouble -> CDouble
13:18:11 <roconnor> wow.  I think I disagree with almost everying in Brian's post: http://enfranchisedmind.com/blog/2009/01/16/on-monoids-and-metaphor-shear/
13:18:38 <dmwit> Oh, huh, ski_ is right.
13:18:42 <dmwit> I totally misremembered the spec.
13:18:51 <dmwit> Oh, and he posted the link here, too, great. =)
13:18:54 <dmwit> ski_++
13:19:20 <ski_> @karma- ski_
13:19:20 <lambdabot> You can't change your own karma, silly.
13:19:22 <sleven> how do I make a bytestring froma string?
13:19:28 <ski_> (@karma+ ski)
13:19:29 <sleven> ski__ ++
13:19:36 <asgaroth> sleven: pack
13:19:43 <sleven> karma ski
13:19:45 <sleven> @karma ski
13:19:46 <lambdabot> ski has a karma of 0
13:19:53 <sleven> karma ski ++
13:19:58 <sleven> @karma
13:19:58 <lambdabot> You have a karma of 0
13:20:08 <sleven> sleven ++
13:20:11 <sleven> > sleven ++
13:20:12 <lambdabot>   <no location info>: parse error on input `;'
13:20:29 <sleven> > let f x = f f x in f x
13:20:30 <lambdabot>       Occurs check: cannot construct the infinite type: t = t -> t1
13:20:30 <lambdabot>      Prob...
13:20:40 <dmwit> What?  He's claiming that groups and monoids are basically the same??
13:21:07 <dmwit> ski_--
13:21:09 <dmwit> ski++
13:21:09 <int-e> dmwit: hmm. ask him to solve "a" ++ x == ""
13:21:11 <pumpkin> inverses--
13:21:25 * dmwit nods at int-e
13:21:59 <roconnor> dmwit: I can't tell if he is claiming that or not
13:22:02 <sleven> come on someone, how do I splt the bytestring
13:22:11 <ski_> (dmwit : ty)
13:22:12 <roconnor> I'm being generous and I assume he isn't
13:22:22 <roconnor> but secretly I fear he is
13:22:24 <sleven> B.split '\\' "224\244" etc
13:23:13 <pumpkin> "The point here is not that “monoid” should have been called “group” (it shouldn’t have been), the point here is that the term monoid didn’t come from abstract algebra."
13:23:15 <pumpkin> ?
13:23:16 <dmwit> sleven: Somewhere along the line, you became very confused.
13:23:28 <int-e> where else did it come from?
13:23:30 * int-e is a bit disappointed that nobody replied to http://www.haskell.org/pipermail/haskell-cafe/2009-January/053689.html
13:23:34 <dmwit> sleven: "\224\224" is a way of printing the two bytes [244, 244].
13:23:55 <sleven> but is is in astring
13:24:02 <sleven> i want to split the damn thing
13:24:06 <roconnor> int-e: is there a reply needed?  It is the perfect comment
13:24:07 <pumpkin> int-e: beats me
13:24:07 <dmwit> sleven: It is not stored as a string, ['\\', '2', '4', '4', '\\', '2', '4', '4'].
13:24:13 <sleven> anyhw, how do I split anyway?
13:24:19 <pumpkin> int-e: not in his book => not abstract algebra
13:24:32 <dmwit> sleven: So I'm *pretty* sure you don't want to split it, if what you're asking for is just the bytes contained in the ByteString.
13:24:53 <dmwit> sleven: There *is* a way to split on a particular byte, if that's really what you want, and it's even called "split".
13:25:11 <dons> oops, i can't believe i used monoids as the example :) http://ian.gowen.cc/post/69448677/haskell-is-a-high-level-language-a-really-high
13:25:17 <dmwit> sleven: But it *sounds* like you just want to be able to access the byte at a particular position...
13:25:18 <int-e> roconnor: not really, I guess, except to caress my ego.
13:25:27 <igowen> dons: haha, that was me
13:25:30 <dons> :)
13:25:32 <ski_> "The abstract algebra name for a thing with an operator and an identity element is group, not monoid (although, to be fair, group also implies that the operator is associative and that every element has an inverse."
13:25:34 <roconnor> int-e: you are Bertram?
13:25:36 <ski_> wtf ?
13:25:38 <int-e> roconnor: yes
13:25:43 <dons> funny, considering the discussion about the monoid name choice this week
13:25:51 <roconnor> int-e: I thought it was a perfect comment
13:25:55 <roconnor> I had nothing to add
13:25:56 <kerlo> @type readsPrec
13:25:57 <lambdabot> forall a. (Read a) => Int -> String -> [(a, String)]
13:26:11 <int-e> roconnor: ok, thanks. feeling better now :)
13:26:16 <dmwit> sleven: In which case "index" is the function you want.
13:26:42 <Heffalump> Monoid is clearly the right name. The question is whether it's worth the cost of being right.
13:26:44 <roconnor> int-e: there was no button to vote it up
13:26:44 <pumpkin> I'm not sure how addable is any better than appendable for monoids
13:26:50 <dmwit> sleven: But even more likely is that Get/Put is what you really want.
13:26:52 <pumpkin> "associativeoperationable"
13:26:54 <kerlo> I don't need to pay attention to the Int if I don't have any infix operators, right?
13:26:57 <roconnor> Heffalump: it is
13:27:12 <Heffalump> and anyway unless you propose to change mappend's name, you can hardly claim the linguistic high ground
13:27:13 * roconnor hopes he doesn't have to justify that remark
13:27:18 <pumpkin> Heffalump: only issue seems to be the mappend naming, which doesn't seem as right as the name of the type
13:27:20 <pumpkin> yeah
13:27:30 <roconnor> Heffalump: mappend is a fairly terrible name
13:27:47 <roconnor> although not quite really terrible
13:28:13 <pumpkin> it gave rise to this whole noise about "Appendable" probably
13:28:22 <roconnor> Heffalump: I'd call it (·)
13:28:23 <Heffalump> when I gave a course on Haskell at work, someone (who is admittedly somewhat hostile to FP) made the point that while most other languages use colloquial English for their concepts, Haskell has a whole set of new terms to understand.
13:28:24 <pumpkin> I wonder if that would've been proposed had the operation not been called mappend
13:28:31 <roconnor> so it is best I don't go around naming stuff
13:28:58 <igowen> if you going to call it that, I don't think mappend is any better or worse
13:29:07 <roconnor> Heffalump: other langauges have Hash, Integer, and Vector
13:29:10 <pumpkin> Heffalump: class/boolean/constructor/encapsulation?
13:29:10 <igowen> since (·) looks like multiplication
13:29:15 <roconnor> Boolean
13:29:26 <pumpkin> I can't say I've heard those used much in common english
13:29:37 <roconnor> igowen: multiplication is a monoid :)
13:29:37 <pumpkin> igowen: it's quite common to do that though
13:29:42 <Heffalump> you've never heard "construct" in English?
13:29:45 <pumpkin> I mean, we can call the two operations in a field + and *
13:29:51 <pumpkin> Heffalump: constructor :P
13:29:53 <igowen> roconnor: so is append.
13:29:54 <byorgey_> Every language has a whole set of new terms to understand.
13:30:00 <Heffalump> that's an obvious derivation..
13:30:05 <Heffalump> "thing that constructs"
13:30:07 <pumpkin> fair enough
13:30:17 <pumpkin> the others though are fairly foreign-sounding
13:30:19 <Heffalump> I'd say the same applies to encapsulation.
13:30:24 <Heffalump> I agree about class and boolean.
13:30:39 <roconnor> igowen: True.  I guess I have to resort to (·) being a common mathematical notation for monoid (and group) operations.
13:30:51 <Heffalump> but Haskell has those *too*
13:31:14 * roconnor is tempted to document Booleans as the coproduct of the final object with itself.
13:31:19 <pumpkin> lol
13:31:21 <igowen> roconnor: indeed, which is a pretty strong case for it since we *are* calling it by its mathematical name
13:31:35 <pumpkin> let's introduce unicode operators into the standard library
13:31:36 <dmwit> I like that Brian claims Haskell can have only one instance of Monoid for Integer, when in fact it actually has either none or two, depending on whether you count newtypes.
13:31:37 <pumpkin> we can be like APL
13:31:42 <igowen> but in reality, it's just a binary operation. you can call it whatever you want, it doesn't change its properties
13:32:42 <pumpkin> couldn't you create a "useless type" do provide both monoids, if you parametrized monoid on an extra type?
13:32:53 <pejo> I read "Made to stick" yesterday. I think Heffalump is on to exactly the same thing that large parts of that book stresses.
13:32:55 <roconnor> @instances Monoid
13:32:55 <pumpkin> or as many monoids as you wanted, for as many operations as you wanted
13:32:56 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
13:33:17 <dmwit> ?src Dual
13:33:17 <lambdabot> Source not found. My pet ferret can type better than you!
13:33:33 <roconnor> pejo: oh?
13:33:49 <dmwit> > Dual [3..5] `mappend` Dual [7..9]
13:33:50 <lambdabot>   Dual {getDual = [7,8,9,3,4,5]}
13:33:52 <dmwit> oh
13:33:54 <dmwit> lame
13:34:11 <dmwit> > Dual (First 3) `mappend` Dual (First 5) -- Last! =)
13:34:12 <lambdabot>       No instance for (Num (Maybe a))
13:34:12 <lambdabot>        arising from the literal `3' at ...
13:34:16 <dmwit> oy
13:34:23 <roconnor> First Just
13:34:31 <sleven> Couldn't match expected type `ByteString'
13:34:31 <sleven>            against inferred type `IO ByteString'
13:34:32 <dmwit> > Dual (First (Just 3)) `mappend` Dual (First (Just 5)) -- Last! =)
13:34:33 <lambdabot>   Dual {getDual = First {getFirst = Just 5}}
13:34:38 <sleven> *Ia> B.index hl 0
13:34:39 <pumpkin> sleven: pull it out
13:34:54 <sleven> im starting to remember why i switched to clojure from haskell a few months ago
13:34:57 <dmwit> sleven: put it in
13:34:58 <pumpkin> lol
13:34:58 <mstr> > read "5"
13:35:00 <lambdabot>   * Exception: Prelude.read: no parse
13:35:03 <pumpkin> sleven: fmap it
13:35:05 <mstr> > read "5" :: Int
13:35:06 <lambdabot>   5
13:35:11 <dmwit> sleven: "return" converts a ByteString to an IO ByteString.
13:35:13 <mstr> > read "lol" :: Int
13:35:14 <lambdabot>   * Exception: Prelude.read: no parse
13:35:16 <kerlo> I wonder what it tries to read "5" as when you do that.
13:35:27 <dmwit> ()
13:35:28 <kerlo> > read "(1,5)" :: (Int,Integer)
13:35:29 <lambdabot>   (1,5)
13:35:32 <dmwit> > read "()"
13:35:33 <lambdabot>   ()
13:35:44 <FunctorSalad> · would be a lot prettier than "mappend" o_O
13:35:47 <roconnor> extended defauling
13:35:52 <roconnor> @check (==)
13:35:53 <lambdabot>   "OK, passed 500 tests."
13:36:00 <dmwit> FunctorSalad: ++ would be easier to type *and* prettier
13:36:10 <FunctorSalad> any haskell-mode hacker here? :)
13:36:22 <pumpkin> @check (==) :: Int -> Int -> Bool
13:36:22 <lambdabot>   Couldn't match expected type `Int -> Int -> Bool'
13:36:23 <Heffalump> dmwit: and it suffers exactly the same problem as mappend
13:36:24 <FunctorSalad> I guess you could get haskell-mode to display mappend as (whatever)
13:36:28 <roconnor> I don't like (++) all that much, but it is a vast improvement
13:36:35 <Heffalump> unless you can propose a different pronounciation for it to 'cat'
13:36:37 <roconnor> and I don't really have anything better
13:36:39 <dmwit> Heffalump: Well, at least it's infix. =)
13:36:42 <Heffalump> and make that pronounciation stick
13:36:46 <Heffalump> so is `mappend` :-p
13:36:50 <pumpkin> I think it should be *
13:36:52 <dmwit> tooooo loooooong
13:36:55 <pumpkin> and then we pull the * out of num
13:37:00 <roconnor> :)
13:37:11 <FunctorSalad> "mappend" is not just long and non-mathematical... the word just looks ugly
13:37:15 <dmwit> pumpkin: You might like the alternative Prelude for mathematicians that's on Hackage...
13:37:17 <Heffalump> but (*) is commutative
13:37:28 <pumpkin> dmwit: yeah, I saw it, it makes me feel warm and fuzzy but I still don't use it :/
13:37:33 <FunctorSalad> Heffalump: how? rewrite rule?
13:38:02 <Heffalump> FunctorSalad: I mean cognitively.
13:38:06 <FunctorSalad> things called "multiplication" are not commutative in many cases
13:38:16 <FunctorSalad> (matrices and so on)
13:38:22 <Heffalump> true
13:38:39 <pumpkin> I say we make the mathematical prelude the standard one
13:38:47 <pumpkin> !
13:38:47 <pumpkin> :D
13:38:56 <pumpkin> that'll make all the people in this thread happy
13:39:03 <pumpkin> (the ones complaining about monoid)
13:39:04 <roconnor> horray
13:39:10 <FunctorSalad> Appendoid
13:39:14 <igowen> eww
13:39:15 <FunctorSalad> :D
13:39:19 <pumpkin> lol
13:39:20 <dmwit> Appendix
13:39:22 <idnar> haha
13:39:43 <roconnor> FunctorSalad: an Appendoid would be a groupoid without an inverse
13:39:54 <roconnor> what do they call that?
13:39:58 <roconnor> a Monoidoid?
13:40:04 <roconnor> or is that a category?
13:40:07 <FunctorSalad> roconnor: a monoidoid is a category :)
13:40:15 <pumpkin> mathturbation galore
13:40:38 <FunctorSalad> pumpkin: it's better than war or something
13:40:47 <pumpkin> yeah :)
13:40:52 <FunctorSalad> ;)
13:41:05 <blackh> A profiling question: Can someone tell me what the cost centre called SYSTEM refers to?
13:41:23 <blackh> I have vast quantities of memory leaking there.
13:41:36 <pumpkin> is there a name for category minus identity morphisms?
13:41:56 <Heffalump> "useless"?
13:42:01 <pumpkin> :P
13:42:02 <FunctorSalad> "semigroupoid" would be consistent but I've never heard it
13:42:19 <pumpkin> I prefer Heffalump's one
13:43:06 * kerlo decides his readsPrec parser is ugly and starts over using Parsec
13:43:29 <pumpkin> kerlo: attoparsec!
13:46:01 * roconnor wonders if foldr (:) [] is optimized to id
13:46:21 <sleven> gnight
13:46:26 <FunctorSalad> roconnor: check? (how would one do that?)
13:46:27 <Heffalump> well, it will be if you consume a build with it
13:46:31 <FunctorSalad> good night sleven
13:46:33 <blackh> sleven: See ya!
13:46:42 * kerlo decides Parsec is unnecessary and uses a more readsPrec-style thing instead
13:46:54 <roconnor> FunctorSalad: either search the std. lib for a rule, or run with -O and check the core
13:47:02 * int-e would love to have  map Foo  optimized to  unsafeCoerce  if  Foo  is a newtype constructor.
13:47:03 <pumpkin> how does compilation time get affected by number of rewrite rules it's checking against? is it just linear in the number of rules?
13:47:19 <FunctorSalad> roconnor: yeah, I mean which of the "ddump" options is the appropriate one
13:47:39 <FunctorSalad> pumpkin: rewriting can do anything, even loop
13:47:43 <roconnor> -ddump-rules
13:47:49 <roconnor> if you know or recoginize the name
13:47:52 <FunctorSalad> (in principle, maybe ghc limits it)
13:48:04 <roconnor> could be foldr/single
13:48:15 <roconnor> hmm
13:48:17 <roconnor> probably not
13:48:20 <roconnor> "foldr/single"
13:48:24 <roconnor> @go "foldr/single"
13:48:32 <lambdabot> http://hackage.haskell.org/packages/archive/base/4.0.0.0/doc/html/src/GHC-Base.html
13:48:32 <lambdabot> Title: Haskell Code by HsColour
13:48:38 <kerlo> int-e: aren't newtype constructors optimized to id?
13:48:59 <roconnor> int-e: and then map id optimized to id?
13:49:19 <Heffalump> the optimisation of newtype constructors is too late for any map id like rules to fire
13:49:32 <roconnor> ah
13:49:35 <roconnor> "foldr/id"                        foldr (:) [] = \x  -> x
13:49:37 <roconnor> horray
13:49:38 <Heffalump> someone was asking SimonPJ about this at ICFP and he said it's hard
13:49:42 <int-e> kerlo: I think not. They disappear at runtime, but the type checker needs to keep them around, and rules need type checking to work
13:49:44 <FunctorSalad> int-e: I thought newtypes get removed completely?
13:49:53 <FunctorSalad> or do you mean a "map id" remains
13:50:05 <Heffalump> FunctorSalad: a "map id" remains
13:50:35 <roconnor> huh?
13:50:47 <roconnor> it can go as far as map id, but not further?
13:51:11 <roconnor> I thought eliminating map id would be the easy part
13:51:24 <int-e> roconnor: it's never  map id
13:51:40 <roconnor> <Heffalump> FunctorSalad: a "map id" remains
13:51:41 <int-e> roconnor: it's  map <newtype constructor>, and later  map coerce
13:51:53 <int-e> roconnor: and the coerce becomes a noop, essentially an id
13:51:54 <kerlo> Why do the rules need type checking to work?
13:51:57 <roconnor> maybe I don't know what remains mean
13:51:59 <Heffalump> sorry, I was unclear
13:52:07 <Heffalump> I meant what int-e said.
13:52:11 <roconnor> ah
13:52:12 <roconnor> okay
13:52:22 <roconnor> stupid typed core language
13:52:31 <Heffalump> kerlo: to stop the user making wrong ones, and to make the core language checkable.
13:52:43 <FunctorSalad> kerlo: I think because of things like the "genericLookup = intLookup" example in the user's guide
13:52:50 <pejo> int-e/Heffalump, is this in System F_c?
13:53:03 <kerlo> Mm.
13:53:34 <FunctorSalad> the last paragraph in the "specialize" section here http://haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#specialize-pragma
13:53:50 <roconnor> could map coerce be rewriten to coerce?
13:53:54 <FunctorSalad> (hammered lookup is HAMMERED)
13:54:15 <Heffalump> pejo: yes
13:54:43 <Heffalump> roconnor: how would you write the rewrite rule in the front-end?
13:59:22 <roconnor> Heffalump: I wouldn't
13:59:57 <pumpkin> aha, sigfpe jumped in
14:00:01 <cantropy> hi, how are monads implemented within the compiler?
14:00:07 <pumpkin> "Although monoids come from mathematics (algebra in particular) they are found everywhere in computing."
14:00:08 <int80_h> offtopic question. how can I see the output from multiple channels?
14:00:14 <Cale> cantropy: They're not?
14:00:26 <pumpkin> cantropy: what part of them? the only compiler support for them is the do notation
14:00:37 <pumpkin> and that's just syntactic sugar
14:00:37 <Cale> cantropy: Monads are type constructors which happen to be instances of a particular typeclass (the Monad typeclass)
14:00:41 <Gracenotes> monads are just regular typeclasses. Typeclasses are implemented in the compiler in an interesting way, though
14:00:49 <cantropy> what I meant to ask is how are side effects supported in Haskell.
14:00:58 <Cale> cantropy: Oh, that's a very different question.
14:01:02 <pumpkin> @src IO
14:01:03 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
14:01:03 <pejo> Heffalump, one could imagine a second set of rewrite rules. Is there other overhead with traversals from coercions as well?
14:01:21 <Cale> cantropy: There's one particular monad, the IO monad, which handles describing real-world effects.
14:01:27 <pumpkin> cantropy: by threading the state of the universe through our computations!
14:01:28 <pumpkin> ;)
14:01:40 <int80_h> state of the universe...woah man. woah.
14:01:59 <cantropy> pumpkin: can you elaborate on "threading the state"
14:02:05 <pumpkin> int80_h: one of these days I'll find a way to pull that RealWorld out of the IO, and then I'll rule the world!
14:02:11 <Cale> Actually, I prefer to give a different explanation. The implementation of the IO monad in GHC is cheesy, even if it happens to be the simplest thing to optimise.
14:02:13 <ddarius> pumpkin: That's a hack.
14:02:13 <pumpkin> cantropy: I'm sure Cale can do this a lot better than I can :)
14:02:20 <pumpkin> ddarius: I know :)
14:02:29 <roconnor> @wiki IO_Semantics
14:02:30 <lambdabot> http://www.haskell.org/haskellwiki/IO_Semantics
14:02:50 <FunctorSalad> so IO is actually a data constructor too? :O
14:02:57 <int80_h> pumpkin: If you need someone to start an Inqusition against C#, Java and Visual Basic, I'm your man.
14:03:13 <pumpkin> thanks :)
14:03:13 <ddarius> Cale: I don't even think it is the simplest thing to optimize, it's just the way it is now due to history and a "if it ain't broke, don't fix it" mentality.
14:03:16 <Cale> In GHC, the IO monad is implemented internally using impure functions which pass around a token (of type RealWorld), which serves to keep the order of evaluation straight, and hence the order in which the effects occur is determined.
14:03:17 <ski_> FunctorSalad : in ghc
14:03:17 <int80_h> I'll be persecuting left and right
14:03:43 <Cale> But I prefer to describe the IO monad in another way.
14:03:50 <Gracenotes> int80_h: I'll be persecuting either
14:04:08 <ddarius> pumpkin: But yes, Dan is right, monoids are freakin' ubiquitous in computing.
14:04:09 <int80_h> I knew somone was going to go there. I just didn't know who
14:04:29 <kerlo> Cale: what's actually in a RealWorld value?
14:04:33 <Cale> kerlo: nothing.
14:04:44 <Cale> kerlo: It just serves to keep the data dependencies straight.
14:04:47 <Gracenotes> Cale: well, maybe
14:04:53 <pumpkin> ddarius: I only brought it up in resposne to the blog post saying that monoids weren't from algebra because he couldn't find them in his book
14:04:54 <FunctorSalad> @remember <kerlo> Cale: what's actually in a RealWorld value? <Cale> kerlo: nothing.
14:04:55 <lambdabot> It is stored.
14:04:55 <Gracenotes> okay, that's enough :/
14:05:30 <int80_h> pumpkin: I read that too. I was tempted to look in *my* book. But then I remembered I had an exercise to finish
14:05:36 <roconnor> hah
14:05:36 <Cale> kerlo: All the actual effects are in the function structure, put there by cheating.
14:05:39 <roconnor> @quote spoon
14:05:40 <lambdabot> roconnor says: error "there is no spoon" :: not Spoon
14:05:45 <roconnor> oh
14:05:54 <roconnor> hmm
14:06:11 <FunctorSalad> nihilism \o/
14:06:16 <chessguy> can someone help me figure out what's wrong with my function for distributivity of /\ over \/ and of \/ over /\ ?
14:06:16 <Cale> I prefer to maintain the purity of functions when describing the IO monad, and this is entirely possible.
14:06:18 <chessguy> http://hpaste.org/14039
14:06:22 <ski_> (int-e : would the `coerce' unwrap the newtype ?)
14:06:39 <Cale> You can think of the IO datatype as being something like this (in GADT syntax):
14:06:42 <cantropy> @quote love
14:06:43 <Cale> data IO t where
14:06:43 <lambdabot> kealyow says: can you make a macro that builds the expression accoridng to those MODULAR LOVE UNITS??
14:06:53 * int80_h maintains the Purity of Essence.
14:06:56 <Cale>   ReturnIO :: t -> IO t
14:07:08 <chessguy> (it doesn't appear to have a fixpoint, as defined)
14:07:08 <Cale>   BindIO :: IO a -> (a -> IO b) -> IO b
14:07:22 <ski_> (Cale : i don't really see how `State# RealWorld -> (# State# RealWorld, a #)' is impure, but ymmv ..)
14:07:24 <Cale>   PutChar :: Char -> IO ()
14:07:31 * roconnor strongly recommends the continutaion style of IO over the GADT style
14:07:32 <Cale> ski_: The -> in that is impure.
14:07:36 <jeffwheeler> Is there an idiom for something like Int -> [a] -> [[a]], such that f 3 "abcdefghij" = ["abc", "def", "ghi", "j"]?
14:07:41 <Cale>   ... other IO primitives here ...
14:07:43 <ski_> Cale : why ?
14:07:53 <Olathe> jeffwheeler: Sure.
14:08:02 <Cale> ski_: Because it is.
14:08:11 <ski_> Cale : how come it's not in Clean ?
14:08:19 * jeffwheeler is surprised by the fact that I have the alphabet memorized faster backwards.
14:08:20 <roconnor> Olathe: oh, I hope that function was added to the std. libs
14:08:31 <int-e> ski_: yes. the representations of the newtype and the underlying type are the same.
14:08:35 <jeffwheeler> Olathe: what is it?
14:08:35 <Olathe> > let splits _ [] = []; splits n xs = take n xs:splits n (drop n xs) in splits 3 "abcdefghij"
14:08:36 <Cale> ski_: The State# RealWorld type doesn't have any structure to it.
14:08:36 <lambdabot>   ["abc","def","ghi","j"]
14:08:44 <roconnor> gah
14:08:45 <jeffwheeler> Olathe: wonderful, thanks.
14:08:49 <Cale> ski_: In fact, it has no values at all, iirc.
14:08:54 <Olathe> You're welcome.
14:08:56 <ski_> Cale : the structure is just abstract, imo
14:09:03 <Cale> ski_: It's only there to keep data dependencies straight.
14:09:18 <ski_> which is only one way to look at it
14:09:20 <int-e> ski_: the absence or presence of the newtype constructor only affects the type. once types are erased, they become irrelevant.
14:09:20 <Cale> ski_: So that the effects, which are part of the function structure, happen in the right order.
14:09:35 <roconnor> Cale: your GADT IO doesn't really capture the equivalence relation on the type as well as the continuation passing style does.
14:09:53 <ski_> Cale : to me that sounds like pure .. there's no *side*-effects
14:10:00 <Cale> roconnor: that's true.
14:10:14 <Cale> ski_: The functions themselves are impure.
14:10:24 <Cale> ski_: Because they produce different results for the same input.
14:10:26 <roconnor> Cale: why do you (and vixey) keep using the GADT style?
14:10:45 <ski_> Cale : no. because you can never pass them the same input (the world can't be copied)
14:10:50 <cantropy> @quote GADT
14:10:51 <lambdabot> ihope says: Oops, I forgot that Djinn doesn't do GADT's.
14:11:10 <Cale> ski_: There's only one value of type State# RealWorld
14:11:35 <ski_> Cale : i don't believe that :)
14:11:42 <Cale> ski_: I'm talking specifically about GHC's implementation.
14:12:05 * ski_ is talking specifically about representing `IO a' as `State# RealWorld -> (# State# RealWorld, a #)'
14:12:13 <Cale> I'm entirely aware that you could give the RealWorld value some structure, and at least for single-threaded programs, make something work properly.
14:12:29 <Cale> But that's not how GHC does it.
14:12:38 <int80_h> can I have multiple where statements in a function?
14:12:53 <ski_> int80_h : nested, yes
14:12:54 <Cale> GHC uses the State# RealWorld value *just* to keep the data dependencies in order, and it uses impure functions.
14:13:14 <int80_h> ski_ : ah my indentation is faulty. okay
14:13:14 <Olathe> int80_h: You can also do where a = 5; b = 6; ...
14:13:23 <ski_> Cale : an impure function, viewed from the right angle, is a pure function
14:13:39 <Cale> huh?
14:13:53 <Cale> State# RealWorld has exactly one value.
14:13:55 <Cale> (bottom)
14:14:05 <pumpkin> :( so my plan to rule the world would fial?
14:14:08 <pumpkin> *fail
14:14:30 <chessguy> no propositional logic love?
14:14:33 <ski_> (i've already said i don't believe in a single world)
14:14:34 <roconnor> @kind State#
14:14:35 <lambdabot> Not in scope: type constructor or class `State#'
14:14:38 <chessguy> :(
14:14:40 <Cale> and so the functions of type  State# RealWorld -> (#State# RealWorld, a#), if they were proper functions, would have to produce the same value every time
14:14:48 <Cale> But they are not.
14:14:50 <pumpkin> chessguy: what's your issue?
14:15:07 <chessguy> pumpkin:  trying to fix http://hpaste.org/14039 -- it doesn't appear to have a fixed point
14:15:29 <pumpkin> ah
14:15:43 <Cale> ski_: Let's put it this way: GHC doesn't *actually* work by passing the state of the real world around as some data structure.
14:16:04 <ski_> Cale : if you take a machine language operation, you could consider that as taking the whole state of the RAM as an implicit operand
14:16:19 <Cale> ski_: It couldn't. There's a lot of that real world which it doesn't have direct access to, like the state of my brain, and other computers over the network.
14:16:26 <Olathe> chessguy: What is Sentence's definition ?
14:16:32 <dons> woo. http://www.reddit.com/r/programming/comments/7qidc/haskell_monoids_and_their_uses_a_neighborhood_of/
14:16:35 <dons> and so it rolls on
14:16:55 <ski_> Cale : in a similar sense, i claim that the `State# RealWorld' value represents the whole world
14:16:58 <Cale> Also, time plays an interesting role in this.
14:17:01 <chessguy> Olathe:  i annotated it
14:17:18 <ski_> Cale : what is "direct access" ?
14:17:22 <Cale> ski_: Except that the *implementation* doesn't do it that way.
14:17:25 <roconnor> d (A*X + 1) / dX = dA/dX + 0 = dA/dX
14:17:27 <chessguy> Cale:  are you _sure_ ghci doesn't have access to the state of your brain? :)
14:18:02 <int80_h> oi
14:18:08 <Olathe> chessguy: Anything fully distributed should be a fix point.
14:18:33 * roconnor wonders if he is wrong about zippers
14:18:48 <chessguy> Olathe:  that's what i would expect too
14:19:17 <ski_> (Cale : how can you tell whether it does it that way or not ? it's a matter of POV)
14:19:18 <pumpkin> lol dons: we both posted that :)
14:19:29 <pumpkin> dons: but I did it in the haskell reddit :D
14:19:52 <Cale> ski_: Because I can look at the GHC source code.
14:19:53 <Olathe> chessguy: let fullyDistribute s = fst.head.dropWhile (not.snd).zip is $ zipWith (==) is (tail is) where is = iterate distribute s
14:19:55 <pumpkin> not sure why I didn't use his original title, at this point
14:20:05 <dons> pumpkin: yay good
14:20:21 <Cale> ski_: There's no implementation of L^2(R) and quantum mechanics inside GHC.
14:20:51 <kerlo> It's planned for GHC 6.12.0, though.
14:21:21 <ski_> because ghc doesn't contain the world .. but programs that are run will be passed the real world
14:21:48 <Olathe> chessguy: Or, more directly: let fullyDistribute s = if (s == d) then s else fullyDistribute d where d = distribute s
14:22:07 * ski_ thinks we're possibly going in circles here
14:22:10 <Cale> ski_: Except that they won't, because that's not actually how the compiler works.
14:22:29 <Cale> ski_: The impure functions will be compiled into machine instructions which will be carried out by the processor.
14:22:32 <roconnor> @tell jeffwheeler I think I might have been as wrong about Zipper of Lists being non empty as I was passionate about being right.
14:22:32 <lambdabot> Consider it noted.
14:22:33 <pumpkin> Olathe: the instance for Eq might be hard
14:22:34 <ski_> yes
14:22:44 <ski_> the processor executes on the real world
14:23:04 <Olathe> pumpkin: Hmm, by == there I mean identical form.
14:23:08 <pumpkin> ah
14:23:26 <Cale> You can lie to yourself about what the types mean, but it's silly, there's no need to do so.
14:23:30 <Olathe> I wish there were some standard way to distinguish the two.
14:23:36 <chessguy> Olathe:  infinite loop
14:23:43 <Olathe> chessguy: For what input ?
14:23:44 <roconnor> @tell jeffwheeler Sorry
14:23:44 <lambdabot> Consider it noted.
14:23:51 <pumpkin> aw
14:24:05 <chessguy> (Not (Symbol "a") :\/: (Symbol "b" :\/: Symbol "c")) :/\: ((Not (Symbol "b") :/\: Not (Symbol "c")) :\/: Symbol "a")
14:24:30 <Olathe> chessguy: Hmm. What about distribute (Symbol "a") ?
14:24:35 <chessguy> that's fine
14:24:48 <Olathe> Ahh, so something in that one is messing up.
14:25:13 <ski_> (Cale : i just still haven't seen anything to distinguish (in results) the two points-of-view .. but we can drop this conversation now, if you like)
14:25:20 <Olathe> What does iterate distribute (allThat) seem to do ?
14:25:35 <Olathe> Is there some sort of cycle it gets stuck in ?
14:25:52 <Cale> ski_: Well, it seems to me that forkIO is hard to explain in terms of the RealWorld model.
14:26:17 <benmachine> there's a comma missing from the topic :o
14:26:20 <benmachine> also, hi
14:27:16 <chessguy> Olathe:  hard to tell
14:27:23 <dmwit> benmachine: Hiya!
14:27:51 <pumpkin> chessguy: maybe Debug.Trace could help
14:28:00 <Cale> ski_: One trouble that I have with it as a mathematical model is that the result of an IO action depends on things which basically any specific RealWorld type we could try to invent would almost certainly fail to represent.
14:28:36 <Heffalump> like what?
14:28:51 <chessguy> pumpkin:  well, looking at it logically, it doesn't seem like "iterate distribute" _should_ have a fixpoint
14:28:57 <chessguy> even though i know it should
14:30:14 <chessguy> Olathe, pumpkin  i mean, if it fits the (a \/ (b /\c)) rule, it puts it in the form that matches the (a /\ (b \/ c)) rule, and vice versa
14:30:32 <Cale> Heffalump: Well, no matter how much data we try to pack in, we're likely to miss things. I really don't want to have to try to express the way in which termperature or vibration in my room affects my disk performance and changes the timing of an operation slightly, producing a different result.
14:31:03 <dons> this is a most interesting commit:
14:31:04 <dons>  http://www.haskell.org/pipermail/cvs-other/2009-January/000734.html
14:31:08 <Heffalump> you don't have to, it's just the fact that you could that's important
14:31:09 <chessguy> Cale:  isn't there a library for that in hackage yet?
14:31:12 <Cale> Heffalump: It's better to just think of IO values as descriptions of actions to be carried out.
14:31:36 <Cale> Heffalump: Rather than trying to encode them as functions from one state to "the next", whatever that is.
14:31:39 <Heffalump> we've had this argument before - it's not that simple because of the callback into the Haskell world produced by >>=
14:31:43 <Olathe> chessguy: A more minimal explosion: take 10.map (length.show).iterate distribute $ (Symbol "a") :/\: (Symbol "a" :\/: Symbol "a")
14:32:02 <Heffalump> dons: indeed
14:32:10 <Cale> Heffalump: So the descriptions can involve Haskell functions?
14:32:22 <chessguy> Olathe:  [44,62,98,152,242,386,620,998,1610,2600]
14:32:34 <Cale> Heffalump: I prefer that to some nebulous conglomeration of real world information.
14:33:05 <Olathe> chessguy: Yep, but what does it do with a ^ (a v a) ?
14:33:13 <Cale> It's not clear how much information about the real world is enough to serve as an accurate model, so it's not really worth trying, in my opinion.
14:33:20 <Heffalump> everything.
14:33:35 <Heffalump> including an interactive model of my mind
14:33:43 <chessguy> Olathe:  hm?
14:33:48 <pumpkin> chessguy: one ugly way to get around it could be to wrap something that's already been distributed in a Distributed constructor, and avoid that in future
14:33:48 <Heffalump> but not yours, we wouldn't want to pollute it :-)
14:33:53 <Cale> Even "everything" might not be enough.
14:34:15 <Olathe> chessguy: It goes to (a ^ a) v (a ^ a), I think.
14:34:22 <Heffalump> I guess I'm making some assumptions about physics here
14:35:04 <chessguy> *TestKB> let a = Symbol "a"
14:35:05 <chessguy> *TestKB> distribute (a :/\: (a :\/: a))
14:35:05 <chessguy> (Symbol "a" :/\: Symbol "a") :\/: (Symbol "a" :/\: Symbol "a")
14:35:10 <chessguy> Olathe:  is that what you mean?
14:35:12 <Olathe> Yep.
14:35:15 <Cale> Well, assuming that the world is quantum-mechanical, you'll end up with some formal sum of states, and the result of an IO action will be entangled with all sorts of other things.
14:35:22 <chessguy> Olathe:  is that wrong?
14:35:27 <Olathe> Then it uses the a v (b ^ c) rule to expand it more.
14:35:37 <pumpkin> chessguy: won't something like distribute (a :/\: b) = (distribute a) :/\: (distribute b) keep matching too?
14:35:55 <Heffalump> except that on the scale of the external behaviour of computers there's no superposition, as I understand the current knowledge
14:35:58 <pumpkin> I guess it will, but will hit a fixpoint
14:36:19 <Olathe> chessguy: Hmm...
14:36:23 <Cale> Heffalump: I could hook my computer up to a device which measures the spin of an electron.
14:36:28 <Olathe> chessguy: How do you know when you're done expanding ?
14:36:39 <chessguy> Olathe:  that's what i'm trying to figure out
14:36:49 <Cale> Heffalump: and the state of my program would become entangled with that electron's spin.
14:37:06 <Heffalump> well, even if you did, it's still modellable
14:37:41 <Cale> Heffalump: mm... but not quite as a function RealWorld -> (RealWorld, a)
14:37:50 <chessguy> pumpkin:  well, at least that case is breaking the expression down into smaller pieces
14:37:57 <pumpkin> yeah
14:38:07 <Cale> Heffalump: Because I'll get more than one value of type a
14:38:22 <Cale> Heffalump: in different parts of that formal sum of worlds
14:38:49 <pumpkin> chessguy: maybe just a guard?
14:39:16 <Heffalump> Cale: not from the point of view of a single execution
14:39:29 <pumpkin> although it would be a rather large guard
14:39:40 <Cale> Heffalump: A single execution of the program will occur across many quantum worlds here.
14:39:51 <Heffalump> even if true, we don't need to model that
14:40:41 <Cale> Heffalump: You could say that the program is an "observer" and collapse the state randomly according to the magnitude of each of the possible states.
14:40:56 <Heffalump> and I don't think it is true with current architecture, your device to measure the spin of an electron can't communicate with the computer without causing a collapse long before Haskell sees it
14:41:15 <Cale> Collapses are part of our mental model, they're not "real".
14:42:24 <Cale> Quantum systems just get entangled with one another -- as long as you have some external possible system you're concerned with, you can't decide to collapse the state.
14:43:11 <Cale> If you don't care about interaction with external observers anymore, you can collapse the quantum state to a definite value.
14:43:20 <Cale> (as a kind of simplification)
14:43:59 <Heffalump> ok, so the very pedantic view of IO could be as some quantum monad, with State RealWorld being a useful simplification for most purposes.
14:44:35 <Heffalump> I'm still not convinced a quantum monad is even strictly necessary, but I don't know enough quantum mechanics to argue.
14:44:53 <roconnor> @tell jeffwheeler ya, I checked the calculation, and the zipper of a list indeed can be empty.  What I helped you write is simply the non-empty list comonad, which is usefull in of itself, but probably already in hackage somewhere.
14:44:53 <lambdabot> Consider it noted.
14:45:17 * roconnor is ashamed
14:45:29 <kerlo> @hoogle guard
14:45:29 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
14:45:29 <lambdabot> Language.Haskell.TH data Guard
14:45:29 <lambdabot> Language.Haskell.TH.Syntax data Guard
14:45:36 <{g}> Hey People! In haskell, how do you check if $string1 begins with $string2?
14:45:48 <int-e> @type isPrefixOf
14:45:49 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
14:45:50 <asgaroth> {g}: isPrefixOf
14:46:05 <jeffwheeler> roconnor: Playing with an IRC client on the iPhone, which is why I keep logging on and off
14:46:05 <lambdabot> jeffwheeler: You have 3 new messages. '/msg lambdabot @messages' to read them.
14:46:19 <pumpkin> jeffwheeler: the colloquy one?
14:46:35 <jeffwheeler> pumpkin: Exactly. It's awesome.
14:46:42 <pumpkin> cool :)
14:46:48 <benmachine> I used colloquy on OSX
14:46:51 <benmachine> I didn't like it
14:46:55 <roconnor> jeffwheeler: I was totally wrong about what a ZipperList is.  I feel really bad.
14:47:18 <roconnor> jeffwheeler: I was totally wrong about what a ZipperList is.  I feel really bad.
14:47:36 <jeffwheeler> roconnor: Huh?
14:47:46 <{g}> asgaroth: how does the whole command look like? i dont know haskell. im just interested in languages.
14:47:47 <Lemmih> Ack, the LLVM mailing list isn't as friendly as haskell-cafe.
14:47:54 <Cale> Heffalump: yeah, I just think that since we basically never actually supply a value of type RealWorld on paper for the purposes of modelling (or at least, I've never chosen to do so), it seems like an awkward way to express the thing.
14:48:06 <asgaroth> {g}: "foo" `isPrefixOf` "foobar" would be very readable
14:48:09 <roconnor> jeffwheeler: a ZipperList can be empty.
14:48:20 <asgaroth> {g}: or isPrefix "foo" "foobar" in prefix notation
14:48:27 <asgaroth> *isPrefixOf
14:48:30 <roconnor> jeffwheelet: and isn't the same thing as the non-empty list comonad
14:48:34 <ddarius> Lemmih: Hah
14:48:46 <jeffwheeler> roconnor: apologies, I lost the message before that last one.
14:48:55 <ddarius> "Haskell: It's not just the language that spoils you"
14:48:58 <jeffwheeler> But now I'm on my primary machine, so it should be good.
14:49:11 <dibblego> @users
14:49:11 <lambdabot> Maximum users seen in #haskell: 664, currently: 623 (93.8%), active: 26 (4.2%)
14:49:33 <roconnor> jeffwheeler: a ZipperList can be empty.
14:49:40 <Cale> Heffalump: I prefer to think of IO actions as something more concrete, and just treat them directly as the basic explanation of my program's meaning.
14:49:55 <Cale> (rather than relying on some description of the real world)
14:49:56 <Heffalump> Cale: you still haven't satisfactorily explained the callback bit.
14:50:00 <roconnor> apperently the "focus" of a ZipperList isn't on an individual element like I thought, but on the entire rest of the list
14:50:01 <{g}> asgaroth: say you want to write "yes" on screen if string1 begins with string2. how would the whole line look like? i mean something like "if($string1->beginsWith($string2)) echo 'yes';else echo 'no';"
14:50:02 <jeffwheeler> roconnor: hmm, I rather liked the latest solution posted on the mailing list
14:50:14 <jeffwheeler> roconnor: oh, I suppose that makes sense too
14:50:22 <chessguy> hmm, i'm stumped
14:50:24 <Cale> Heffalump: What's to explain? There's some actual function there which takes a value and produces an action.
14:50:30 <jeffwheeler> roconnor: on the other hand, the current version is way more useful for what I'm trying to do. I wonder if there's something else I can call it.
14:50:34 <roconnor> jeffwheeler: ya, the non-empty list comonad is really useful
14:50:37 <Cale> (which is another description of stuff to be done)
14:50:49 <chessguy> jeffwheeler:  what is it you're tring to do?
14:50:54 <roconnor> jeffwheeler: it just isn't a ZipperList
14:51:05 <Heffalump> ok, but that's substantially more complicated than the entire Haskell program producing one set of IO actions
14:51:06 <jeffwheeler> chessguy: represent a selected element in a list for a UI
14:51:21 <Cale> Heffalump: hm?
14:51:22 <asgaroth> {g}: print (if "foo" `isPrefixOf` "foobar" then "yes" else "no") would be one way. (Of course you could put the print inside of the then and elses
14:51:26 <Gracenotes> ugh, I haven't done graphical programming in forever. Time to bite the bullet...
14:51:46 <roconnor> jeffwheeler: You could rename it to FocusList, or some such thing
14:51:52 <cknapp> Question: If I wanted to see what new work has been done since Erwig's FGL paper, where would I go (papers and code)
14:52:01 <{g}> asgaroth: thanks.
14:52:08 <jeffwheeler> roconnor: good suggestion, and I'll make the change, then post it to the mailing list.
14:52:27 <roconnor> jeffwheeler: appollogies again.
14:52:42 <jeffwheeler> roconnor: oh, I don't mind at all. Renaming a few things is easy. ;)
14:52:49 <roconnor> jeffwheeler: ah, PointedList might be better
14:53:02 <roconnor> depending if you prefer mathy names or "intuative" names :D
14:53:12 <cknapp> ...
14:53:31 <jeffwheeler> roconnor: PointedList is good. :P
14:53:32 * cknapp marvels at the length of that Haskell-Cafe discussion
14:53:36 <Cale> Heffalump: I tend to think of the running of a Haskell program as consisting of two interleaved processes: evaluation and execution. The main value is executed, which immediately demands to know which sort of action it is, and forces its evaluation. Once this is determined, if it's an IO primitive, the executor carries that action out. If it's a bind of the form x >>= f the executor executes x, and captures the result
14:53:36 <Cale>  v, then continues by executing f v.
14:53:56 <jeffwheeler> cknapp: didn't we have an almost identical discussion about a month ago?
14:54:05 <Cale> (which will immediately involve evaluating f v)
14:54:08 <chessguy> pumpkin, Olathe  (if you're till interested), check out the code at http://www.cs.yale.edu/homes/cc392/report.html -- he appears to do pretty much the same thing
14:54:11 <cknapp> On the list? Or the question I just asked?
14:54:32 <Cale> (since f v is clearly not in whnf already)
14:54:50 <roconnor> jeffwheeler: I don't see PointedLists in category-extras
14:55:04 <jeffwheeler> cknapp: on the list
14:55:07 <roconnor> so it isn't duplicating anything there
14:55:15 <cknapp> I just subscribed a few days ago...
14:55:16 <jeffwheeler> roconnor: sweet :)
14:55:17 <Heffalump> Cale: that's a reasonable model, but it's very complicated for teaching, IMO
14:55:21 <cknapp> So I don't know. :)
14:55:32 <Cale> I don't know. I think it's simple enough.
14:55:37 <jeffwheeler> cknapp: ah; I think it's funny that conversations keep going to that
14:55:51 <Cale> What's complicated about it?
14:55:56 <cknapp> It is funny... it's also obnoxious
14:56:06 <cknapp> Cale: I think it's fine... if that counts for anything. :)
14:56:18 <Heffalump> it requires a good understanding of laziness, for one thing
14:56:22 * cknapp has used his smiley quota for the night.
14:56:31 <ddarius> Heffalump: No it doesn't.
14:56:42 <cknapp> Heffalump: to come up with, yes, to understand, no.
14:56:43 <ddarius> It'd be just the same without laziness.
14:56:44 * jeffwheeler can't figure out how to disable Colloquy from displaying smileys
14:57:11 <Cale> Without laziness, the IO action would already be in normal form.
14:57:20 <ddarius> However, it does allow for accounting for how laziness affects IO action (which is not at all) in a pleasant manner.
14:58:17 <ddarius> It's also a reasonably accurate description of what is actually going on, particularly for actions that require system calls.
14:58:39 <Cale> (when you had the recursive call   execute (f v),  the f v would be evaluated first, then execute would be called on it.
14:58:54 <Cale> Which is basically the same thing, because execute is going to pattern match anyway)
14:59:22 <Heffalump> it's no more accurate than the RealWorld description where the runtime representation of RealWorld is void.
14:59:51 <Cale> Sure, I'll agree with that. It just avoids naming the real world as a type altogether.
14:59:52 <Heffalump> I agree about laziness.
15:00:09 <Heffalump> yes, and instead it names "things you can do in IO" as a type.
15:00:13 <Cale> right.
15:00:13 <ddarius> Heffalump: When you call write(1) you do pass the information in and a "continuation".  Control transfers to the kernel which performs the actual actions for you and then returns to you (calls the continuation) with results.  This is how it works in any language.
15:00:25 <ddarius> For things like IORefs, I agree that it is inaccurate.
15:00:27 <Cale> Which I prefer, because that's more discrete and exact.
15:00:28 <Heffalump> ddarius: only in as much as any function call works that way.
15:01:17 <Heffalump> anyway, I'm not disputing the accuracy of the model, just its value as a first explanation of IO to beginners.
15:01:40 <Cale> RealWorld is something which we're always forced to be hazy about. Here, we can at least have some hope of enumerating the possible IO primitives, though the explanation of what they do is left informal.
15:01:52 <ddarius> As far as I'm concerned the State RealWorld is a non-explanation.
15:01:55 <Heffalump> you can't enumerate them, because the user can always write more!
15:01:58 <ddarius> You can't do anything with that model.
15:02:04 <Cale> Heffalump: Well, in terms of Bind.
15:02:07 * chessguy didn't think it would take me all day to write a Sentence -> CNF converter :(
15:02:12 <Cale> Heffalump: Or, I suppose the FFI.
15:02:24 <Olathe> chessguy: http://hpaste.org/14039#a2
15:02:32 <Heffalump> Cale: the FFI was what I had in mind.
15:02:37 <Olathe> chessguy: I wouldn't recommend distribute for CNF.
15:02:46 <Heffalump> I guess you could make an ADT that encapsulates everything you can write in FFI.
15:02:55 <Gracenotes> all right, time to implement Tetris in Haskell. (though it's implemented already)
15:03:00 <Heffalump> but it's no more appealing than being explicit about what RealWorld is.
15:03:01 <Cale> Sort of... I've thought about that, but it's tricky.
15:03:07 <ddarius> Heffalump: Or you could just pass "names" of FFI functions to the "system"
15:03:07 <Cale> You really want an open GADT.
15:03:09 <Olathe> chessguy: I'd just convert it to [[Symbol|T|F]]
15:03:17 <ddarius> Which is kind of what is actually happening anyway.
15:03:19 <Cale> (or an open ADT of some sort, anyway)
15:03:29 <chessguy> Olathe:  err, i thought you needed distribution to be able to do that
15:03:32 <Cale> The fiddly bit is just that FFI calls have types too.
15:03:38 <Olathe> chessguy: Oh, no, it's easier than that.
15:03:55 <chessguy> oh?
15:03:57 <Olathe> chessguy: Does CNF require all available symbols in each term ?
15:04:04 <Olathe> chessguy: Or just the necessary ones ?
15:04:06 <Heffalump> but as both of these are just mental models, there's no need to actually bother
15:04:22 <Cale> I'd actually like to see my way done in an implementation.
15:04:25 <Heffalump> if you actually want to model IO for other purposes like reasoning or testing, then the explicit IO actions datatype is superior
15:04:38 <ddarius> Heffalump: You could -actually- implement IO as Cale describes.  You can't actually implement IO with the State RealWorld approach without having magical impure functions.
15:04:49 <Olathe> chessguy: Like does it need A + B to A !B + A B + !A B ?
15:05:00 <Olathe> chessguy: Or is A + B sufficient ?
15:05:01 <Heffalump> ddarius: only once you solve the open datatype problem
15:05:02 <ddarius> Cale's approach explicitly acknowledges an RTS-like entity that performs the actions on behalf of the Haskell program.
15:05:06 <chessguy> Olathe:  just the necessary ones, if i'm understanding
15:05:09 <ddarius> Heffalump: That's easy enough to do.
15:05:24 <Cale> We should have open ADTs anyway.
15:05:25 <Olathe> chessguy: Ahh.
15:05:31 <Heffalump> but anyway, I don't care. I'm only arguing for State RealWorld as a good explanation for beginners.
15:05:37 <Olathe> chessguy: Well, first I'd convert everything to ands and ors.
15:05:54 <Olathe> chessguy: I'd move all the nots to be Not (Symbol) only.
15:05:55 <ddarius> Heffalump: I say it's a good non-explanation for beginners to get them off your back.
15:06:06 <Cale> I suppose I'm biased by the fact that I found the State RealWorld explanation incredibly confusing when I was a beginner.
15:06:07 <Olathe> Using DeMorgan's or whatever.
15:06:11 <Heffalump> It explains serialisation perfectly.
15:06:13 <chessguy> Olathe:  the book i'm trying to work through describes toCNF = distribute . moveNotsToLiterals . removeImplication . removeBinConditionals
15:06:17 <Heffalump> Which is the obvious difficulty of IO.
15:06:31 <Olathe> chessguy: Ahh.
15:06:40 <Olathe> chessguy: It's a good strategy.
15:06:53 <ddarius> Heffalump: Until the beginner asks what happens if you drop the RealWorld or duplicate it.  Then you reply "You just Don't Do That."
15:07:04 <Cale> I eventually found out that it's actually best not to worry about the representation of IO values, and just look at them as directly being the expressions which define them.
15:07:12 <ddarius> Cale's approach (or the continuation approach) also explains serialization perfectly.
15:07:17 <Heffalump> ddarius: no, I reply "the implementation doesn't let you"
15:07:31 <Heffalump> ddarius: yes, but it's much more complicated!
15:07:39 <ddarius> Heffalump: As I said, a way to get beginners off your back without actually explaining anything.
15:07:40 <Heffalump> State RealWorld is really simple.
15:07:52 <chessguy> Olathe:  but unnecessary?
15:07:56 <Heffalump> It's entirely true that the implementation doesn't let you duplicate RealWorld
15:08:01 <Olathe> chessguy: I'd recommend not expanding things that are already (a) AND (b).
15:08:12 <Heffalump> And GHC's implementation does actually have that token.
15:08:18 <Olathe> chessguy: No, that was basically what I was going on about.
15:08:28 <ddarius> Heffalump: Implemented via hacks and magic.
15:08:38 <Olathe> chessguy: Convert the conditionals, move the nots to literals, etc.
15:08:48 <Heffalump> no more so than laziness..
15:09:08 <Olathe> chessguy: The only thing you don't need, really, is (a + b)(c + d) -> whatever.
15:09:17 <Olathe> chessguy: It's already in CNF, so no distribution is useful.
15:09:26 <Heffalump> and "the implementation doesn't let you duplicate the token" is exactly equivalent to "the implementation doesn't let you provide two continuations that will both be called"
15:09:33 <Heffalump> in both cases, the interface doesn't let you do it
15:09:40 <Olathe> chessguy: That should, also, fix your infinite loop problem.
15:09:51 <chessguy> Olathe:  so there's no recursive case in distribute?
15:10:16 <ddarius> Heffalump: But you could do that.  Doing that, for example, would be one way to start describing concurrency.
15:10:22 <Olathe> chessguy: Oh, it's recursive for ab + cd for example.
15:10:26 <Olathe> Or ab + c
15:10:28 <Olathe> Or whatever.
15:10:34 <chessguy> ...
15:10:50 <Heffalump> you could also describe concurrency by partitioning up the mythical RealWorld
15:10:53 <ddarius> Heffalump: There's no requirement that only one continuation be provided/called for the model to make sense.
15:11:10 <chessguy> sorry, i'm not getting what you're saying i should do
15:11:25 <ddarius> Heffalump: Into what partitions?
15:11:32 <Olathe> chessguy: Oh, you have something like distribute a AND (b OR c) = whatever.
15:11:42 <Olathe> chessguy: Since that's already in CNF, you don't need that, I think.
15:11:52 <Heffalump> hmm, maybe not, sorry
15:11:54 <Olathe> chessguy: I could be wrong, though.
15:12:12 <chessguy> oh, so i should only distribute the a OR (b AND c) ?
15:12:24 <Heffalump> but anyway, I don't care, because if I'm getting that deep then they already get the basics of IO.
15:12:31 <Olathe> chessguy: Yeah.
15:12:42 <chessguy> ah
15:12:51 <Olathe> chessguy: Get the AND as the main operator and the ORs as secondary.
15:13:06 <kerlo> @type takeWhile
15:13:08 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
15:13:17 <kerlo> @hoogle (a -> Bool) -> [a] -> ([a],[a])
15:13:17 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
15:13:17 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
15:13:17 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
15:13:36 <kerlo> > break isSpace "one two three"
15:13:37 <lambdabot>   ("one"," two three")
15:14:03 <chessguy> Olathe:  like this? http://hpaste.org/14039#a3
15:15:27 <Olathe> chessguy: Yeah, I think so.
15:17:12 <Olathe> chessguy: I'd add one for the mirror, too.
15:17:20 <chessguy> mirror?
15:17:21 <kerlo> @index isSpace
15:17:22 <lambdabot> Data.Char
15:17:35 <Olathe> distribute (a :\/: (b :/\: c)) and distribute ((b :/\: c) :\/: a)
15:17:58 <chessguy> ah
15:18:32 <Olathe> And, for good measure (a OR b) AND (c OR d)
15:21:19 <chessguy> err, that should be caught already
15:21:23 * kerlo is disappointed by an infinite loop
15:21:53 <roconnor> I fear that this RealWorld implemenation of IO idea may be the source of the incorrect notions about how strict monad evaluation is.
15:22:39 <roconnor> and thus is very bad to teach to beginners, or anyone else for that matter.
15:22:59 <roconnor> Cale: what are the odds of disabling @src IO ?  :)
15:23:04 <Olathe> chessguy: You're probably right.
15:23:18 <kerlo> Should I be doing @src IO right now?
15:23:24 <roconnor> no
15:23:30 <Heffalump> the RealWorld model doesn't cause any strictness problems, does it?
15:23:32 <Heffalump> @src IO
15:23:32 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
15:24:13 <kerlo> The error message should be "Learn to respect the unknown unknowns."
15:24:37 <chessguy> Olathe:  hmm. it still gets the example in the book wrong
15:25:10 <Olathe> Ahh, I'm not sure where to go, then.
15:25:17 <kerlo> Does GHCi have a convenient way to trace evaluation?
15:25:24 <Cale> kerlo: Sort of.
15:25:53 <Cale> kerlo: Make sure that the file you want to trace through is in interpreted mode, then use :trace <expr>
15:26:06 <Cale> Well, you'll need to set some breakpoints first.
15:26:19 <Cale> and/or  :set -fbreak-on-exception
15:27:10 <Cale> With the latter, you can press Ctrl-C at some point, and if all goes well, the evaluation will stop and allow you to observe the variables in scope
15:27:45 <Heffalump> Cale: can't you also :step from the beginning without setting any breakpoints?
15:27:59 <Cale> Heffalump: oh, possibly, I've never tried that actually.
15:28:06 <Heffalump> neither have I :-)
15:28:13 <Heffalump> I just had the impression it was possible.
15:28:32 <Cale> ah, you can, yes
15:31:48 * kerlo gets tired of stepping through and traces it manually
15:32:08 * Cale steps through the evaluation of a fractran prime number generator :)
15:32:13 <Heffalump> I think IDE integration might make the debugger rather more usable.
15:32:21 <Cale> It would, yeah.
15:32:22 <Heffalump> Right now I only very rarely find it any use at all.
15:32:37 <Cale> It's currently mostly useful for locating the source of exceptions, if that.
15:33:16 <Heffalump> yeah
15:33:18 <Heffalump> or finding loops
15:33:22 <Cale> I actually find Debug.Trace.trace more useful if I'm really stuck.
15:33:24 <Heffalump> if you're lucky
15:33:31 <Heffalump> yeah
15:33:38 * kerlo notices something
15:33:39 * roconnor is going to use Writer (Sum Integer) over state more often now
15:33:54 <Heffalump> I use Writer (Any Bool) sometimes
15:34:00 <kerlo> In a Lispoid, we generally don't want tokens to be able to contain parentheses.
15:34:11 <Cale> I love WriterT (Product Rational) []
15:34:12 <roconnor> Heffalump: nice
15:34:24 <Heffalump> well, I've used it once, and I might use it again :-)
15:34:42 <pumpkin> Cale: what for?
15:34:55 <Cale> pumpkin: Determining distributions of probabilities.
15:35:06 <pumpkin> ooh
15:35:26 <Cale> It's wonderful for simulating fairly complicated game situations which involve randomness.
15:36:07 <pumpkin> mmm
15:36:28 <cads> hey, you guys know any good exit nodes for getting free access to the ACM?
15:36:35 <cads> with tor, that is
15:36:45 <roconnor> cads: did you try all the .edu exit nodes?
15:37:03 <cads> tried a few so far
15:37:08 <cads> you think mit has it?
15:37:12 <Cale> I had someone from #math who wanted to simulate a bunch of situations in a game of Risk, and I wrote a simulator in about 30 lines of Haskell code which determined the probabilities of all the possible outcomes.
15:37:17 <roconnor> cads: likely
15:37:21 <Heffalump> on that note, any ACM members know how to get hold of their annual accounts?
15:37:45 <Heffalump> I can't spot them anywhere on their website.
15:37:46 <pumpkin> cads: have you tried looking at authors' personal sites as I said? :P
15:38:51 <pumpkin> whenever I see hledger on hackage
15:38:59 <Cale> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=705 -- okay, so maybe 40-50 or so, really ;)
15:39:02 <pumpkin> I think heath ledger
15:39:22 <mapreduce> @hoogle [a] -> (a -> b) -> Maybe a
15:39:22 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
15:39:22 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
15:39:22 <lambdabot> Data.List findIndex :: (a -> Bool) -> [a] -> Maybe Int
15:39:24 <Cale> I also managed to explain the code to him step by step :)
15:39:37 <pumpkin> cool :)
15:39:37 <Cale> (even though he was not a Haskell user)
15:40:02 <mapreduce> Is there a function that will map a function over the first element of a list, returning a Maybe with the result?
15:40:32 <Cale> fmap f . listToMaybe
15:40:33 <mapreduce> Like.. let headMap list f = f . head $ list, but total.
15:40:54 <ddarius> fmap f . listToMaybe
15:41:00 <pumpkin> Heffalump: I don't think there's a way to
15:41:08 <pumpkin> well, I use a site license and can't see anything
15:41:15 * chessguy resorts to a truth table to prove his theorem prover wrong
15:41:21 <Heffalump> pumpkin: I'm sure they have to publish them to members
15:41:38 <mapreduce> @src listToMaybe
15:41:38 <lambdabot> listToMaybe []        =  Nothing
15:41:38 <lambdabot> listToMaybe (a:_)     =  Just a
15:41:56 <roconnor> listToMaybe++
15:42:31 <mapreduce> What lib is that in?
15:42:36 <mapreduce> @hoogle listToMaybe
15:42:36 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
15:42:37 * ddarius hasn't decided if the "fused" or "unfused" route is the way to go.
15:42:59 <ddarius> Conal seems to prefer an "unfused" approach whereas I often think of a "fused" approach first.
15:43:52 <pumpkin> ddarius: fused? in the stream fusion sense?
15:44:55 <ddarius> pumpkin: Very roughly in the same sense, but not really and not for the same reasons.
15:45:01 <pumpkin> ah
15:46:01 <ddarius> As an example, let's say you want to write a multiplex function, it takes two lists and combines them into one.
15:47:03 <ddarius> Actually give me a minute.
15:47:12 <sm>   hledger 0.3 released
15:47:50 <pumpkin> sm: was just commenting on how it reminded me of the author :P
15:47:52 <pumpkin> *actor
15:47:56 <pumpkin> bah, my mind is fried
15:48:22 <sm> I wonder why only some modules are listed at http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hledger .. looks like just the exposed-modules from http://joyful.com/darcsweb/darcsweb.cgi?r=hledger;a=headblob;f=/hledger.cabal .. also how to get those linking to haddocks..
15:49:17 <sm> pumpkin: ha! rip heath
15:50:26 <ddarius> Actually, that can lead to a simple example.  To combine two lists into one you could use zipWith or you could use the simpler function zip and then map over the results.
15:51:14 <opqdonut> zipWith f = (map (uncurry f) .) . zip
15:51:24 <ddarius> opqdonut: And zip = zipWith (,)
15:51:29 <opqdonut> indeed
15:52:00 <Elly> I think using both of those definitions at the same time might be considered rude
15:52:25 <opqdonut> ddarius: and the dividing question is which one to define in terms of the other right?
15:52:40 <ddarius> opqdonut: Essentially, yes.
15:52:49 <ddarius> I.e. which should be considered more "primitive"
15:52:54 <opqdonut> yeh
15:53:01 <opqdonut> I'd probably go with zip
15:53:04 <ddarius> or "basic"/"fundamental" to choose less loaded terms
15:53:21 <opqdonut> using zipWith as the primitive leads to a certain kind of overabstraction
15:54:01 <opqdonut> abstract much and then come halfway back, when you could've first gone halfway and named the result
15:54:09 <opqdonut> if you see what i mean
15:54:13 <pumpkin> yeah
15:54:23 <pumpkin> but I would prefer zipWith to come first, despite that :P
15:54:24 <opqdonut> sleep beckons ->
15:54:47 <ddarius> opqdonut: Yes, but is the more abstract version more or less basic?
15:54:55 <ddarius> or fundamental?
15:55:18 <ddarius> pumpkin: In this case there are performance reasons to prefer zipWith and zipWith is often what you want.
15:55:32 <pumpkin> yeah
15:55:42 <ddarius> pumpkin: listToMaybe is an example that goes the other way.  You could have a mapHead functions with listToMaybe = mapHead Nothing Just
15:55:47 <pumpkin> is there a rewrite rule for map . zip?
15:56:03 <ddarius> pumpkin: I don't think so, but maybe.
15:56:32 <pumpkin> that would actually be a handy lambdabot tool, to look up rewrite rules somehow, and ask it to apply them to code you pass in
15:56:49 <ddarius> The idea underlying the foldr/build fusion system doesn't do zips, but it would be no problem to add other reasonable rules.
15:57:42 <Heffalump> much better to finish off stream fusion
15:58:08 <pumpkin> what's missing?
15:58:32 <dons> probably works now for those nested concatMaps :)
15:58:35 <Heffalump> some issues with deeply nested list comprehensions still being slower than foldr/build, I thought
15:58:40 <Heffalump> dons: oh, really?
15:59:00 <dons> well, the static arg transform made it in, and other   things have improved.
15:59:16 <dons> at least we'd have to check. i wouldn't be surprised if things were much better
15:59:22 <Heffalump> so then you guys just need to find time to polish it up to go in?
15:59:26 <Heffalump> that'd be really cool.
16:00:21 <dons> yeah. at least, we'd need to walk over Data.List.Stream again, then redo the benchmarks
16:00:38 <dons> it has consistently been yielding better code that build/foldr for a long time though
16:00:46 <dons> with the caveates for nested concatmaps/list comprehensions
16:00:55 <Heffalump> right
16:04:29 <blackh> Anyone know what the cost centre called SYSTEM is? (I'm memory profiling with ghc).
16:05:10 <ehird> since Deewiant's just gone to sleep... he just told me he released his haskell-based generic build tool (it has build files in haskell) :-)
16:05:11 <ehird> http://users.tkk.fi/~mniemenm/coadjute/
16:05:37 <ehird> whoa, ipv6 flood
16:06:51 <xpika> my forkIO's are running backwards.
16:07:52 <Igloo> blackh: Things like the stack
16:08:00 <pumpkin> sdrawkcab?
16:08:32 <blackh> Igloo: Thanks - that could be a clue!
16:08:38 <cads> pumpkin, it's hard to find the papers sometimes
16:08:40 <blackdog> what are the semantics of C calls through the FFI? Can I be sure that while the C call is running, there'll be no action (garbage collection in particular) in Haskell-land?
16:08:46 <pumpkin> cads: that's true
16:09:10 <pumpkin> cads: but if you have any specific requests I can fetch them for you
16:09:30 <cads> hey alright :D
16:10:09 <blackdog> (context: passing pointers to strings into a c function, crashes hard with normal RTS options, works fine if i pass -A1G to stop GC happening, doesn't work even when the first thing i do with the passed-in array of CStrings is copy it completely)
16:10:14 <xpika> ive got do{ forkIO (putStrLn "hi" >> putStrLn "yo") } printing yo  hi
16:10:28 <blackh> Igloo: SYSTEM is leaking huge amount of memory for me, and it can't be the stack because it's increasing beyond returns to the program's main loop
16:11:56 <Heffalump> blackh: I think the stack could still be used to evaluate closures at that point
16:11:58 <Cale> xpika: That doesn't seem possible.
16:12:26 <Cale> xpika: However,  forkIO (putStrLn "hi") >> putStrLn "yo"  will print them in a nondeterministic order.
16:13:03 <pumpkin> xpika: I always get them in the right order
16:13:18 <pumpkin> but ghci's prompt printing sometimes gets in the way
16:13:22 <pumpkin> if that's what you're using
16:13:29 <pumpkin> since it's happening in a different thread
16:13:32 <Guenni> what functions can I use to get the time difference in day fractions between 2 dateTimes?
16:14:29 <roconnor> @hoogle diffTime
16:14:30 <lambdabot> Data.Time.Clock data DiffTime
16:14:30 <lambdabot> Data.Time.Clock data NominalDiffTime
16:14:30 <lambdabot> Data.Time.Clock picosecondsToDiffTime :: Integer -> DiffTime
16:14:53 <Lemmih> dons: New blog post. I think the LLVM crowd are one step away from skinning me alive.
16:15:03 <roconnor> @hoogle UTCTime -> UTCTime -> NominalDiffTime
16:15:04 <lambdabot> Data.Time.Clock diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime
16:15:04 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
16:15:04 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
16:15:10 <mmorrow> Lemmih: i think your last two blog posts are well-put.
16:15:24 <pumpkin> Lemmih: yeah, it looks good to me
16:15:26 <roconnor> Guenni: there are a couple of options depending on exactly what you want.
16:15:46 <ddarius> blackdog: Read the FFI spec, there are "safe" and "unsafe" attributes that can be applied to FFI calls that give different guarantees.
16:15:48 <ddarius> @where ffi
16:15:48 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
16:16:05 <Gracenotes> any simple ways to do 2D graphics in Haskell anyone might suggest?
16:16:19 <roconnor> do you have local time or utc time or universal time
16:16:24 <Gracenotes> I'm trying to do a small game
16:16:32 <ddarius> Gracenotes: Cairo seems popular for vector graphics.
16:16:35 <roconnor> Gracenotes: Cairo?
16:16:45 <mmorrow> OpenGL?
16:16:52 <ddarius> Gracenotes: You can use OpenGL or SDL for pixel based graphics just like in any other language.
16:16:59 <Guenni> roconnor: I got 2 data = MyTime Year Month Day Hour Min types and want the difference in days
16:17:20 <blackdog> ddarius: sure, but safe is the default, right? and AFAICT, even unsafe just guarantees that the C code won't call back into the haskell runtime
16:17:25 <Gracenotes> ddarius: yeah, I've taken a look at those packages, but I have no prior experience in either OpenGL or SDL
16:17:25 <Guenni> roconnor: the data type is my own creation the values are Int
16:17:44 <roconnor> Guenni: any reason to not use the exsiting data types?
16:17:58 <Gracenotes> or Cairo for that matter
16:18:21 <Guenni> roconnor: yes, I did want to use LocalTime but couldn't derive Data, Typeable
16:18:22 <Gracenotes> need to start somewhere, though. I'll try cairo out
16:18:35 <Guenni> roconnor: and had to, so this was a work around
16:18:41 <roconnor> Guenni: you have the time to within minutes and you want the difference in days,  you want the diference to be fractional?
16:18:57 <ddarius> Gracenotes: Do you know if you'll need pixel-level graphics or not?
16:18:59 <Guenni> roconnor: yes
16:19:06 <ddarius> Gracenotes: If you do, Cairo will be useless for you.
16:19:09 <blackdog> ddarius: yeah, same behaviour with safe :/
16:19:33 <ddarius> blackdog: The GHC User Guide (or the developer's wiki) should give you more specific guarantees.
16:19:34 <Gracenotes> ddarius: what can Cairo do?
16:19:50 <Guenni> roconnor: I was gonna convert and the let the standard libs do their work
16:19:51 <mmorrow> blackdog: have you tried using mallocBytes, then copying in your data, then passing that Ptr to C?
16:20:02 <ddarius> Gracenotes: It's a vector-graphics library, like SVG.
16:20:05 <Guenni> roconnor: not sure about which types to convert to though
16:20:11 <Gracenotes> ah, I see
16:20:17 <blackdog> mmorrow: nah, i tried to cheat by copying it in C-land. no joy though, so i'll try that one now
16:20:18 <mmorrow> blackdog: that way the data lives in the C heap from the start.
16:20:50 <Gracenotes> ddarius: I'm trying to start out with a tetris clone. Vector graphics will probably do well there.
16:20:57 <roconnor> Guenni: hmm,  My first inclinaton to to convert them to UTCTimes and then use diffUTCTime
16:21:01 <ddarius> Gracenotes: Yeah, Cairo should be fine for that.
16:21:56 <dcoutts> sm: the hackage page only lists the exposed-modules because those are the only ones that form the API
16:22:02 <mmorrow> blackdog: you should even be able to free that Ptr on the C side
16:22:07 <mmorrow> (if desired)
16:22:30 <sm> I see, thanks
16:22:50 <mmorrow> i know GHC foreign imports "malloc" internally for mallocBytes
16:22:51 <jeffwheeler> > let s ' ' = 32; s = ord in s 'a'
16:22:52 <lambdabot>       Equations for `s' have different numbers of arguments
16:22:52 <lambdabot>        <interacti...
16:22:58 <jeffwheeler> Why is that invalid?
16:23:23 <mmorrow> alternatively you could just foreign import "malloc" yourself to excessively paranoid
16:23:27 <trygvis> anyone know if there are work going on to run haskell on a JVM?
16:23:51 <roconnor> jeffwheeler all equations have to have the same number of arguments, otherwise pattern matching becomes difficult to understand ... maybe.
16:23:52 <jeffwheeler> Obviously, not using pl-form makes the above code work, . . . but that seems very unnecessary.
16:23:57 <wabash> anybody ever call Haskell methods from another language?
16:24:09 <Guenni> roconnor: Thx, will do
16:24:15 <Heffalump> jeffwheeler: because the language would have to immediately expand it anyway, which would potentially lead to different recalculation behaviour than you were expecting
16:24:16 <jeffwheeler> roconnor: :-/
16:24:41 <ddarius> wabash: Sure.
16:24:42 <roconnor> Guenni: toRational will convert a NominalDiffTime to seconds
16:24:47 <Heffalump> in particular if ord was something expensive to compute, you'd be upset if it was calculated repeatedly, as it is in the expanded version
16:24:50 <ddarius> Even dynamically generated ones.
16:24:51 <mmorrow> trygvis: there have been a few projects aiming for that, but there're some things about the JVM that make it hard to do efficiently
16:25:00 <Heffalump> I guess in principle it could be lifted, but it's not.
16:25:15 <trygvis> mmorrow: yeah, I can imagine. know of any blogs or postings summarizing the issues?
16:25:25 * mmorrow is finding a link ...
16:25:25 <wabash> ddarius: What language?
16:25:30 <ddarius> wabash: C.
16:25:44 <wabash> ddarius: Oh, I see. How about Ruby? Do you think that's even possible?
16:26:03 <mmorrow> trygvis: http://wiki.brianweb.net/LambdaVM/LambdaVM
16:26:11 <trygvis> thanks!
16:26:13 <wabash> And BTW, how do we get the little *** comment thing, like ***wabash wonders how to do triple asterisks....
16:26:16 <ddarius> wabash: Of course it is.  You just expose the functions as C functions and use whatever Ruby has in the way of FFI to use them as C functions.
16:26:21 <Heffalump> wabash: /me foo
16:26:25 * wabash test
16:26:31 * wabash tests new toy out
16:26:32 <mmorrow> trygvis: to see some of the difficulties, see "things that suck" in http://wiki.brianweb.net/LambdaVM/Implementation
16:26:36 <Heffalump> (it renders differently in different clients, FWIW, *** is specific to your client)
16:26:38 <wabash> Heffalump: Thanks, Hef.
16:26:53 <wabash> ddarius: Interesting. Great to know. How do we handle types then?
16:27:02 <ddarius> wabash: What do you mean?
16:27:21 <wabash> I mean, in Ruby, have BigNum or Fixnum. When I call Haskell function, am I only allowed C primatives?
16:27:43 <ddarius> wabash: I have no idea.  I have no idea how ruby's FFI works.
16:28:10 <wabash> Ok, then in the C case; is it basically that you have to make Haskell exposure conform to C native types?
16:28:13 <ddarius> wabash: Most likely you will have to marshall through an intermediate.
16:28:24 <wabash> Or can you synthesize a Haskell time from a C struct or something?
16:28:33 <ddarius> wabash: Yes and no.  You can pass things to C as opaque pointers and functions to manipulate them.
16:29:01 <roconnor> Guenni: be aware the nomialDiffTime ignores leap seconds
16:29:10 <mmorrow> wabash: Haskell <--ffi--> C <--ffi--> SomeLang
16:29:13 <wabash> Ok, the other way around, though. If I have a C program call Haskell function.
16:29:22 <wabash> mmorrow: ok, thanks.
16:29:54 <wabash> mmorrow: Unfamiliar with FFI in general, except Ruby to C. Wondering conceptually how, in FFI, we bridge datatypes between languages.
16:31:03 <ddarius> wabash: You write marshalling functions that convert from one to the other or to/from an intermediate format, or you just allow one to tell the other how to manipulate whatever itself.
16:31:22 <Guenni> roconnor: thx, that won't be a problem
16:31:40 <wabash> ddarius: I see. So in the case of a Bignum (arbitrary size int), would I have a marshall function that understands both languages?
16:31:57 <ddarius> wabash: That's one possibilty, yes.
16:32:10 <wabash> ok, great. Thanks.
16:32:20 <wabash> I am starting to get a picture of this now.
16:32:27 <mmorrow> wabash: there's no one "right way", just a bunch of "that'll work"s
16:33:11 <wabash> mmorrow: Yes. I'm glad to hear that. Spent a few years in te rails channel getting berated for asking questions about stuff.
16:33:24 <mmorrow> sucky :)
16:33:32 <wabash> Turns out that the rails community is pretty particular about the way that they do things, good or bad.
16:33:57 <pumpkin> they call it an opinionated framework for a reason :P
16:34:22 <blackdog> they just want to distinguish themserves from perl...
16:34:28 <jeffwheeler> Django, on the other hand, is for perfectionists who want things done right. ;)
16:34:34 <wabash> ddarius: mmorrow: and I appreciate the time spent answering abstract, high-level questions here; I do a lot better if I have some rough concept, even if slightly generic and imprecise, about how things work.
16:34:46 <wabash> jeffwheeler: I think you meant:
16:35:05 <pumpkin> what turned me off most in ruby was me pointing out a bug in MRI and being called a retard and /ignored by a prominent rubyist for saying it should probably issue a warning if the bug-like condition was encountered
16:35:10 <wabash> Django,
16:35:11 <wabash>     on the other hand,
16:35:11 <wabash>         is for perfectionists....
16:35:22 <wabash> pumpkin: Exactly!
16:35:30 <dons> language professionals :)
16:35:42 <pumpkin> I mean, if you create more than a certain number of symbols in ruby
16:35:44 <pumpkin> they start to collide
16:35:57 <wabash> pumpkin: These are my experiences. Abusiveness is wrong, etc, but *unfounded* abusiveness is just ..... WTF?
16:35:57 <repnop> ruby on the jvm :)
16:36:03 <wabash> know what I mean?
16:36:05 <pumpkin> it's fairly easy to detect this, so why not just say "warning, lots of symbols created, might start having issues with correctness of equality"
16:36:05 <jeffwheeler> wabash: can we really make fun of that in #haskell? ;)
16:36:38 <wabash> jeffwheeler: As long as I am able to make fun of myself and the language that I use, I feel pretty comfortable making fun of other langs! ;
16:36:40 <wabash> ;)
16:36:58 <wabash> Family gatherings, I usually tell a few jokes about computer programmers....
16:36:58 <jeffwheeler> wabash: fair enough. I love the whitespace sensitivity in both Python and Haskell.
16:37:34 <wabash> Most of the time, I'm less making fun of something and more epitomizing it for fun.
16:37:47 <jeffwheeler> hehe
16:37:49 <wabash> Except for Java.
16:38:11 <chessguy> @type \xs -> do { x1 <- xs; x2 <- xs; guard (x1 == x2); return [x1,x2]; }
16:38:12 <lambdabot> forall (t :: * -> *) t1. (Eq t1, MonadPlus t) => t t1 -> t [t1]
16:38:20 <wabash> Then I say "AbstractHighLevelStringBuilderFactoryParserGenerator.new" when I want a frickin string.
16:38:52 <pumpkin> people were doing the same thing about haskell the other day :P
16:38:54 <Axman6> dons: have you had a chance to play with that n-bodies thing at all yet?
16:38:57 <jeffwheeler> wabash: and have you tried downloading something off the 'net? 19 URI* classes!
16:39:11 <wabash> Yeah, that's funny too.
16:39:29 <blackdog> wabash:
16:39:30 <jeffwheeler> wabash: . . . except for when you actually have to use them.
16:39:31 <wabash> I sorta like having URLs as strings.
16:39:32 <pumpkin> "no, you don't need to understand what a monoid is to append two strings"
16:39:44 <blackdog> I think i saw a RequestFactoryFactory the other day...
16:39:48 <Cale> I invented a musical instrument. I call it the cacophone. It's a combination of an accordion, a saxophone, and a German World War II Enigma machine. The keys on the accordion, when pressed, are fed into the Enigma machine, which instead of producing an encoded message, is used to determine which pads on the saxophone are pressed. Then the wind from the accordion is fed into the saxophone chamber.
16:39:54 <wabash> blackdog: Awesome!!!!
16:40:12 <dons> Axman6: nope. thanks for reminding me.
16:40:24 <wabash> Cale: no dumber than atonal composition.
16:40:41 <pumpkin> lol Cale
16:40:56 <Axman6> dons: i'm hoping you run into the bug i'm getting that causes a segfault :\
16:41:38 <dons> compiling via C?
16:41:39 <wabash> ladies and gents, it's always my favorite channel. In a couple of months study, I'm hoping to answer ppl's questions too.... Time for dinner!
16:41:40 <chessguy> Cale:  i'll have a little bit of that
16:41:49 <dons> gcc has bugs that have manifested as segfaults in nbody before
16:41:54 <dons> try removing -optc-O2 et al
16:41:56 <Axman6> i haven't tried that
16:41:58 <dons> or sitching to -fasm
16:42:19 <chessguy> @hoogle guard
16:42:20 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
16:42:20 <lambdabot> Language.Haskell.TH data Guard
16:42:20 <lambdabot> Language.Haskell.TH.Syntax data Guard
16:42:43 <Axman6> from what i can remember, i've just been using ghc --make -O2 n-bodies-
16:42:56 <pumpkin> Axman6: I'll be curious to see if that helps you
16:44:57 <chessguy> @pl \x y -> s x y && o x y
16:44:57 <lambdabot> ap (ap . ((&&) .) . s) o
16:45:23 <roconnor> > 200/31
16:45:25 <lambdabot>   6.451612903225806
16:45:55 <chessguy> @src delete
16:45:56 <lambdabot> delete = deleteBy (==)
16:46:04 <chessguy> @src deleteBy
16:46:04 <lambdabot> deleteBy eq x []        = []
16:46:04 <lambdabot> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
16:46:22 <Axman6> n-bodies-ST.hs*
16:46:22 <Axman6> dons: my most upsetting bug is that somehow i must have changed the program, and now instead of taking 2m30, it takes almost 15 mins, and i have no idea why :(
16:46:38 <pumpkin> Axman6: have you tried profiling?
16:47:17 <dons> inlining :)
16:47:26 <dons> you gotta profile and read core when it comes down to cache misses
16:48:33 <blackh> 8-)
16:57:04 <chessguy> > filter even [1..5]
16:57:06 <lambdabot>   [2,4]
17:01:21 <kerlo> I wonder what the longest English phrase that's also a valid Haskell expression is. :-P
17:02:02 <Gracenotes> @hackage gtk2hs
17:02:02 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gtk2hs
17:02:05 <kerlo> @hoogle [a]
17:02:05 <lambdabot> Prelude repeat :: a -> [a]
17:02:05 <lambdabot> Data.List repeat :: a -> [a]
17:02:05 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
17:02:09 <Gracenotes> @hackage gtk
17:02:09 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gtk
17:02:13 <Gracenotes> hrm.
17:02:26 <dcoutts> @where gtk2hs
17:02:26 <lambdabot> http://haskell.org/gtk2hs/
17:02:35 <Gracenotes> I need pretty documentation :3
17:02:48 <dcoutts> Gracenotes: it's there, including hoogle
17:02:53 <Gracenotes> phew
17:03:01 <dcoutts> Gracenotes: @hackage does not know what is available
17:03:12 <Gracenotes> yeah, just a link generator
17:03:15 <dcoutts> yep
17:03:18 <Gracenotes> unfortunately, I can't find any Cairo docs :/
17:03:19 * kerlo decides to call his home-brewed Lispy thing "Silly Lisp"
17:03:27 <Gracenotes> besides the C version
17:03:32 <Gracenotes> which I suppose it good enough
17:03:35 <Gracenotes> *is
17:03:36 <pumpkin> kerlo: be careful, lispy is in here!
17:03:41 <dcoutts> Gracenotes: the Haskell cairo docs are there too
17:03:57 <Gracenotes> oh, now I see it.
17:04:00 <Gracenotes> second phew
17:05:07 <jeffwheeler> Is it still difficult/impossible to install GtkHs on 6.10?
17:05:12 <pumpkin> Axman6: did the different code generator help?
17:06:02 <kerlo> *Lisp> evaluate (read "(Hello, world!)")
17:06:03 <kerlo> (Hello, world!)
17:06:11 <dcoutts> jeffwheeler: you need the darcs version or to wait a few days for the tarball release
17:06:12 <kerlo> Now all I have to do is make some functions actually do something.
17:06:32 <jeffwheeler> dcoutts: darcs works? Cool, I'll do that. Thanks. :)
17:07:14 <chessguy> is there some better way to write this? \xs ys -> do { x <- xs; y <- ys; guard (p x y); return c x y }
17:07:35 <chessguy> err, sorry, that's "return (c x y)"
17:08:23 <dmwit> xs, ys lists?
17:08:27 <chessguy> yes
17:08:39 <Gracenotes> list comprehensions?
17:08:45 <dmwit> Yeah.
17:08:48 <chessguy> oh, duh
17:08:57 * chessguy hugs Gracenotes 
17:09:05 <dmwit> For non-lists, you could use
17:09:06 <Gracenotes> :)
17:09:22 <dmwit> ensure p x = guard (p x) >> return x
17:09:50 <dmwit> liftM (uncurry c) (liftM2 (ensure (uncurry p)) xs ys)
17:10:08 <dmwit> ...but that's really gross, so don't do that.
17:10:11 <chessguy> @pl ensure p x = guard (p x) >> return x
17:10:12 <lambdabot> ensure = (`ap` return) . (((>>) . guard) .)
17:10:17 <chessguy> as is that
17:10:38 <dmwit> That's why you don't write ensure point-free. =)
17:10:51 * dmwit didn't think point-free was a requirement of the question
17:10:58 <chessguy> it wasn't
17:11:13 <chessguy> it's just a reflex to check :)
17:11:32 <dmwit> =)
17:11:38 <int80_h> thank you haskell, for letting me divide by zero
17:12:08 <ray> @faq Can you divide by zero in Haskell?
17:12:08 <lambdabot> The answer is: Yes! Haskell can do that.
17:12:25 <pumpkin> > 1 / 0
17:12:26 <lambdabot>   Infinity
17:12:37 <pumpkin> > 1 / 0 * 0
17:12:38 <lambdabot>   NaN
17:12:42 <pumpkin> :(
17:12:49 <pumpkin> can't I just cancel out the 0s? :(
17:12:52 <Ikkebr> 0*0
17:12:53 <pumpkin> ;)
17:12:58 <Ikkebr> > 0 * 0
17:12:58 <Gracenotes> > (1/0) * (1/0)
17:12:59 <lambdabot>   0
17:13:00 <lambdabot>   Infinity
17:13:09 <Ikkebr> > Infinity - Infinity
17:13:10 <lambdabot>   Not in scope: data constructor `Infinity'Not in scope: data constructor `In...
17:13:20 <_roconnor> > (1/0) - (1/0)
17:13:22 <lambdabot>   NaN
17:13:35 <int80_h> You can't use arithmetic operators on infinities
17:13:36 <kerlo> @faq Can you cast kerlo into a nonce in Haskell?
17:13:36 <lambdabot> The answer is: Yes! Haskell can do that.
17:13:38 <Gracenotes> pumpkin: (x^2) * (1/x) doesn't equal 1
17:13:49 <_roconnor> math is hard
17:13:52 <_roconnor> let's go IEEE
17:13:53 <Gracenotes> even though one approaches infinity and the other one approaches zero
17:14:04 <kerlo> @faq If you can understand me, touch your nose.
17:14:04 <lambdabot> The answer is: Yes! Haskell can do that.
17:14:04 <chessguy> @slap
17:14:04 <pumpkin> Gracenotes: :'(
17:14:04 * lambdabot hits  with a hammer, so they breaks into a thousand pieces
17:14:07 <kerlo> Great.
17:14:07 <dolio> You can. But "Infinity" is not a numeric literal.
17:14:33 <pumpkin> @let infinity = 1/0 :: Double
17:14:34 <lambdabot>  Defined.
17:14:46 <pumpkin> @let nan = 0/0
17:14:47 <jeffwheeler> Is there any symbolic math library like Python's SymPy in Haskell?
17:14:47 <lambdabot>  Defined.
17:14:47 <_roconnor> > -infinity
17:14:49 <lambdabot>       Ambiguous occurrence `infinity'
17:14:49 <lambdabot>      It could refer to either `L.infini...
17:14:53 <pumpkin> :(
17:15:05 <pumpkin> > L.infinity
17:15:05 <Gracenotes> > (-1)/0
17:15:07 <lambdabot>   -Infinity
17:15:07 <lambdabot>   Infinity
17:15:10 <int80_h> did lambdabot make a joke?
17:15:45 <Gracenotes> oh, wait...
17:15:53 <_roconnor> jeffwheeler: http://hackage.haskell.org/packages/archive/numbers/2008.4.20.1/doc/html/Data-Number-Symbolic.html ?
17:16:54 <jeffwheeler> roconnor: it doesn't have any idea of algebras (like, say, simplifying or factoring) but it's the right idea
17:17:32 <chessguy> > nub [2]
17:17:33 <lambdabot>   [2]
17:17:39 <jeffwheeler> _roconnor: SymPy is a neat Python library that can handle all sorts of symbolic math/algebra things, and some calculus
17:17:49 <_roconnor> nice
17:18:07 <Axman6> Cale: you around? we'd like to welcome lambdabot back into #macosx if that's ok :)
17:18:14 <jeffwheeler> _roconnor: and just the type of thing I'd expect from Haskell people, from how math-oriented they usually are ;)
17:18:17 * kerlo decides it's too difficult to implement lambda for his little lispy thing
17:18:22 <jeffwheeler> @invite #macosx
17:18:23 <lambdabot> Unknown command, try @list
17:18:30 <jeffwheeler> Hmm . . . there's something like that.
17:18:40 <_roconnor> jeffwheeler: we are more semantics rather than syntax I'm afraid
17:18:41 <Cale> lambdabot: @join #macosx
17:18:48 <_roconnor> not all of use
17:18:49 <_roconnor> us
17:18:59 <Axman6> thanks Cale :) will that be permanent?
17:19:06 <_roconnor> but i'd say generally
17:19:08 <Cale> If you'd like
17:19:40 <jeffwheeler> _roconnor: it would seem so. Oh well . . .
17:19:51 <Axman6> Cale: yes please :)
17:20:02 <_roconnor> jeffwheeler: so we have automatic differentiation
17:20:12 <jeffwheeler> _roconnor: err, what?
17:20:44 <_roconnor> jeffwheeler: http://augustss.blogspot.com/2007/04/overloading-haskell-numbers-part-2.html
17:21:09 <jeffwheeler> _roconnor: oh, yes; like is done in RWH
17:21:15 <_roconnor> > deriv (\x -> x^2) 5
17:21:16 <lambdabot>   10
17:21:32 <jeffwheeler> Err . . . wow.
17:21:38 * jeffwheeler reads the article in more depth.
17:21:41 <centrinia> Is there a Scrap Your Zippers module?
17:21:48 <_roconnor> > deriv (\x -> sin x) pi
17:21:50 <lambdabot>   -1.0
17:22:04 <centrinia> > deriv abs 0
17:22:06 <lambdabot>   0
17:22:16 <_roconnor> @check \x -> deriv exp x == exp x
17:22:18 <lambdabot>   "OK, passed 500 tests."
17:22:26 <centrinia> > deriv abs 1
17:22:27 <_roconnor> @check \x -> deriv sin x == cos x
17:22:28 <lambdabot>   1
17:22:28 <lambdabot>   "OK, passed 500 tests."
17:22:34 <centrinia> >deriv abs (-1)
17:22:38 <_roconnor> @check \x -> deriv sin x == sin x
17:22:40 <lambdabot>   "Falsifiable, after 0 tests:\n2.0\n"
17:22:44 <centrinia> > deriv abs (-1)
17:22:45 <lambdabot>   -1
17:22:49 <centrinia> Weird.
17:22:58 <centrinia> Why is the derivative of |x| at 0 defined?
17:23:05 <mmorrow> > deriv (\x -> (2*x^3 - x^2 - 1) * (x + x^2 + 100 * x)) x
17:23:07 <lambdabot>   (2 * ((1 * x + x * 1) * x + x * x * 1) - (1 * x + x * 1)) * (x + x * x + 10...
17:23:14 <kerlo> centrinia: because deriv is stupid.
17:23:18 <pumpkin> centrinia: you would like NaN?
17:23:23 <_roconnor> mmorrow: good example
17:23:25 <mmorrow> > deriv (\x -> (2*x^3 - x^2 - 1) / sin (cos (sin x ^ 30) - 1)) x
17:23:27 <lambdabot>   (2 * ((1 * x + x * 1) * x + x * x * 1) - (1 * x + x * 1)) * recip (sin (cos...
17:23:36 <kerlo> > deriv abs x
17:23:37 <lambdabot>   signum x * 1
17:23:40 <kerlo> Wow.
17:23:53 <Axman6> deriv needs some identity checking...
17:23:54 <kerlo> That's actually not stupid at all. :-P
17:23:57 <centrinia> Is there an integrate function?
17:24:01 <mmorrow> this is the combination of AutomaticDifferentiation and SimpleReflect
17:24:04 <pumpkin> granted,     abs p@(D x x')           =  D (abs x) (signum p * x')
17:24:14 <mmorrow> > foldr f z [0..9] :: Expr
17:24:15 <lambdabot>   f 0 (f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 z)))))))))
17:24:16 <kerlo> Symbolic derivative...
17:24:25 <kerlo> > deriv signum x
17:24:27 <lambdabot>   0
17:24:35 <mmorrow> > deriv cos x
17:24:36 <lambdabot>   1 * negate (sin x)
17:24:40 <kerlo> Darn, it left out the Dirac delta.
17:24:40 <mmorrow> > deriv sin x
17:24:41 <lambdabot>   1 * cos x
17:24:43 <_roconnor> jeffwheeler: don't miss mmorrow's examples
17:24:47 <centrinia> > take 8 $ iterate deriv cos
17:24:49 <lambdabot>       Occurs check: cannot construct the infinite type: a = Dif a
17:24:49 <lambdabot>        Expe...
17:24:52 <kerlo> @doc deriv
17:24:53 <lambdabot> deriv not available
17:25:00 <jeffwheeler> _roconnor: yeah, and I'm going through the article too
17:25:00 <kerlo> @index deriv
17:25:00 <lambdabot> bzzt
17:25:04 * kerlo frowns
17:25:07 <mmorrow> kerlo: cheack out augustss' blog post
17:25:07 <centrinia> > take 8 $ iterate deriv (\x -> cos x)
17:25:09 <lambdabot>       Occurs check: cannot construct the infinite type: a = Dif a
17:25:09 <lambdabot>        Expe...
17:25:27 <kerlo> Is lambdabot ever going to stop being so nifty? :-P
17:25:27 <mmorrow> > iterate (deriv (\x -> cos x)) x
17:25:28 <lambdabot>   [x,1 * negate (sin x),1 * negate (sin (1 * negate (sin x))),1 * negate (sin...
17:25:32 <mmorrow> @type deriv
17:25:33 <lambdabot> forall a b. (Num b, Num a) => (Dif a -> Dif b) -> a -> b
17:25:43 <mmorrow> , src ''Dif
17:25:48 <lunabot>  data Dif a = D a (Dif a)
17:26:07 <Axman6> infinite list?
17:26:08 <mmorrow> it's just an incredibly clever trick
17:26:15 <centrinia> > deriv log 4
17:26:17 <lambdabot>   0.25
17:26:20 <centrinia> Wow.
17:26:28 <jeffwheeler> > :t x
17:26:29 <lambdabot>   <no location info>: parse error on input `:'
17:26:51 <mmorrow> Axman6: yes, and infinite list of _all_ derivatives
17:26:54 <pumpkin> > deriv sinh x
17:26:55 <lambdabot>   (1 * exp x - negate 1 * exp (negate x)) * recip 2
17:26:56 <roconnor> @type x
17:26:58 <lambdabot> Expr
17:27:03 <Axman6> mmorrow: ... o.O
17:27:07 <mmorrow> , src ''Expr
17:27:12 <lunabot>  data Expr = Expr {showExpr :: (Int -> ShowS),
17:27:12 <lunabot>                    intExpr :: (Maybe Integer),
17:27:12 <lunabot>                    doubleExpr :: (Maybe Double),
17:27:30 <centrinia> > deriv (\x -> (f x) *  (g x))
17:27:31 * kerlo decides to give his Lispoid behavior he doesn't really understand, thereby following in the Lisp tradition
17:27:32 <lambdabot>       Overlapping instances for Show (a -> b)
17:27:32 <lambdabot>        arising from a use of `s...
17:27:34 <mmorrow> <lunabot>  data Expr = Expr {showExpr :: (Int -> ShowS),
17:27:34 <mmorrow> <lunabot>                    intExpr :: (Maybe Integer),
17:27:34 <mmorrow> <lunabot>                    doubleExpr :: (Maybe Double),
17:27:34 <mmorrow> <lunabot>                    reduced :: (Maybe Expr)}
17:27:54 <mmorrow> > deriv (\x -> (f x) *  (g x)) x
17:27:55 <lambdabot>       No instance for (SimpleReflect.FromExpr (Dif b))
17:27:55 <lambdabot>        arising from a ...
17:28:27 <mmorrow> > deriv (\x -> ((\x -> f x) x) *  ((\x -> g x) x)) x
17:28:28 <lambdabot>       No instance for (SimpleReflect.FromExpr (Dif b))
17:28:28 <lambdabot>        arising from a ...
17:28:31 <mmorrow> aww
17:28:34 <chessguy> @hoogle trace
17:28:34 <lambdabot> Debug.Trace trace :: String -> a -> a
17:28:35 <lambdabot> module Debug.Trace
17:28:35 <lambdabot> package traced
17:28:49 <roconnor> > val (dif ((\x -> x^2) 5))
17:28:51 <lambdabot>   Not in scope: `dif'
17:28:56 <roconnor> > val (df ((\x -> x^2) 5))
17:28:58 <lambdabot>   0
17:28:59 <kerlo> > (\("foo"++x) -> x) "foobar"
17:29:00 <lambdabot>   <no location info>: Parse error in pattern
17:29:11 <kerlo> We still don't have k++ and ++k patterns, I see.
17:29:14 <mmorrow> heh
17:29:16 <gwern> mmorrow: incidentally, do you still remember why you couldn't use mueval as a library for lunabot's eval functionality?
17:29:27 <centrinia> @let newton f x = x - (deriv f x) / (f x)
17:29:28 <lambdabot>  <local>:8:32:
17:29:28 <lambdabot>      Occurs check: cannot construct the infinite type: a = Dif...
17:29:41 <roconnor> oh right
17:29:43 <Axman6> kerlo: well.. yeah
17:29:48 <roconnor> deriv f = val . df . f . dVar
17:29:58 <mmorrow> gwern: because i want to have full control over the ghc-api, compilation, the HscEnv, etc.
17:30:04 <mmorrow> linking, ...
17:30:15 * jeffwheeler feels silly: ". . . using high school calculus" --- that's the highest math I've had!
17:30:16 <roconnor> > val . df . x^5 . dVar 2
17:30:16 <gwern> ah. I suppose I should look at the lunabot src
17:30:17 <lambdabot>   Couldn't match expected type `a -> Dif a1'
17:30:22 <roconnor> > val . df . (^5) . dVar 2
17:30:23 <Axman6> > (\'f':'o':'o':xs -> xs) "foobar"
17:30:24 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Dif t'
17:30:24 <lambdabot>   <no location info>: parse error on input `:'
17:30:29 <gwern> ,version
17:30:30 <lunabot>  luna: Not in scope: `version'
17:30:30 <mmorrow> , [$tyQ| let fix f = let x = f x in x in fix |]
17:30:34 <roconnor> > val . df . (^5) . dVar $ 2
17:30:34 <Axman6> > (\('f':'o':'o':xs) -> xs) "foobar"
17:30:35 <lunabot>  ForallT [a] [] (AppT (AppT ArrowT (AppT (AppT ArrowT (VarT a)) (VarT a)))...
17:30:35 <gwern> bah!
17:30:35 <lambdabot>   80
17:30:36 <lambdabot>   "bar"
17:30:50 <mmorrow> , eval "eval \"42\""
17:30:53 <roconnor> > df . (^5) . dVar $ 2
17:30:55 <lambdabot>   80~~
17:30:56 <lunabot>  <<Dynamic>>
17:30:59 <gwern> lunabot: version
17:31:08 <roconnor> > iterate (df . (^5) . dVar) 2
17:31:09 <lambdabot>       Occurs check: cannot construct the infinite type: a = Dif a
17:31:09 <lambdabot>        Expe...
17:31:09 <mmorrow> , fromDynamic (eval "eval \"42\"")
17:31:14 <gwern> lunabot: @version
17:31:14 <lunabot>  Nothing
17:31:15 <mmorrow> , fromDynamic (eval "eval \"42\"") :: Maybe Dynamic
17:31:20 <lunabot>  Just <<Integer>>
17:31:31 <roconnor> > iterate df  ((^5) $ dVar 2)
17:31:32 <lambdabot>   [32~~,80~~,160~~,240~~,240~~,120~~,0~~,0~~,0~~,0~~,0~~,0~~,0~~,0~~,0~~,0~~,...
17:31:35 <mmorrow> , (fromJust . fromDynamic . fromJust . fromDynamic) (eval "eval \"42\"") :: Integer
17:31:40 <lunabot>  42
17:31:53 <mmorrow> gwern: i have an infinitely nested `eval'
17:31:59 <gwern> mmorrow: where's the repo?
17:32:00 <mmorrow> which the bot is also using
17:32:01 <roconnor> > map val $ iterate df  ((^5) $ dVar 2)
17:32:03 <lambdabot>   [32,80,160,240,240,120,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
17:32:18 <mmorrow> gwern: http://moonpatio.com/repos/luna/
17:32:19 <roconnor> > map val $ iterate df  (sin $ dVar 0)
17:32:20 <lambdabot>   [0.0,1.0,-0.0,-1.0,0.0,1.0,-0.0,-1.0,0.0,1.0,-0.0,-1.0,0.0,1.0,-0.0,-1.0,0....
17:32:22 <pumpkin> > map val $ iterate df  (sin $ dVar x)
17:32:23 <lambdabot>   [sin x,1 * cos x,1 * (1 * negate (sin x)),1 * (1 * (1 * negate (cos x))),1 ...
17:32:29 <gwern> thnx
17:32:29 <pumpkin> nice
17:32:33 <roconnor> :D
17:32:38 <Olathe> @type df
17:32:39 <lambdabot> forall a. (Num a) => Dif a -> Dif a
17:32:45 <Axman6> @hoogle deriv
17:32:45 <lambdabot> package derive
17:32:45 <lambdabot> Distribution.Extension DeriveDataTypeable :: Extension
17:32:45 <lambdabot> Language.Haskell.Extension DeriveDataTypeable :: Extension
17:32:46 <pumpkin> although it should simplify them!
17:32:51 <pumpkin> > map val $ iterate df  (sinh $ dVar x)
17:32:52 <lambdabot>   [(exp x - exp (negate x)) * recip 2,(1 * exp x - negate 1 * exp (negate x))...
17:32:53 <roconnor> Data.Number.Symbolic really needs a simplification pass
17:32:54 <mmorrow> gwern: i pulled a ton of code out of ghc and did various minor things to it, but in principle one could do the same thing without pulling out that ghc code
17:33:05 <Axman6> :t deriv
17:33:06 <lambdabot> forall a b. (Num b, Num a) => (Dif a -> Dif b) -> a -> b
17:33:31 <Olathe> O-o
17:33:37 <gwern> mmorrow: but too lazy to rewrite it better?
17:33:41 <Axman6> > deriv (cos.sin)
17:33:42 <lambdabot>       Overlapping instances for Show (a -> a)
17:33:42 <lambdabot>        arising from a use of `s...
17:33:47 <Axman6> > deriv (cos.sin) x
17:33:48 <lambdabot>   1 * cos x * negate (sin (sin x))
17:34:01 <Olathe> > deriv pi
17:34:02 <lambdabot>       Overlapping instances for Show (a -> b)
17:34:02 <lambdabot>        arising from a use of `s...
17:34:05 <mmorrow> gwern: heh, i have like 10 projects going in parallel. i need 4 of me.
17:34:11 <roconnor> > deriv pi x
17:34:12 <lambdabot>       No instance for (Floating (Dif Expr -> Dif b))
17:34:12 <lambdabot>        arising from a us...
17:34:15 <mmorrow> 10 would be nice too
17:34:19 <jeffwheeler> > deriv (const pi) x
17:34:19 <roconnor> ah
17:34:20 <lambdabot>   0.0
17:34:21 <Olathe> @type deriv pi
17:34:21 <pumpkin> how do you apply pi?
17:34:22 <lambdabot> forall a b. (Num b, Num a, Floating (Dif a -> Dif b)) => a -> b
17:34:33 <Olathe> @type deriv pi 5
17:34:34 <lambdabot> forall a b. (Num b, Num a, Floating (Dif a -> Dif b)) => b
17:34:36 <gwern> pumpkin: with a fork
17:34:38 <Olathe> > deriv pi 5
17:34:39 <lambdabot>       No instance for (Floating (Dif a -> Dif b))
17:34:39 <lambdabot>        arising from a use o...
17:34:41 <pumpkin> hah
17:34:45 <jeffwheeler> > deriv (const pi) 5
17:34:47 <lambdabot>   0.0
17:34:56 <roconnor> > deriv (const x) x
17:34:58 <lambdabot>   Couldn't match expected type `Dif b' against inferred type `Expr'
17:35:13 <jeffwheeler> > deriv x x
17:35:14 <lambdabot>   Couldn't match expected type `Dif a -> Dif b'
17:35:19 <mmorrow> const x
17:35:20 <roconnor> > deriv (const (var x)) x
17:35:21 <lambdabot>       Ambiguous occurrence `var'
17:35:21 <lambdabot>      It could refer to either `Data.Number.S...
17:35:22 <jeffwheeler> >deriv (\x -> x) x
17:35:23 <Olathe> > deriv x 1
17:35:24 <lambdabot>   Couldn't match expected type `Dif a -> Dif b'
17:35:37 <mmorrow> > deriv (const x) x
17:35:38 <lambdabot>   Couldn't match expected type `Dif b' against inferred type `Expr'
17:35:42 <mmorrow> :(
17:35:43 <jeffwheeler> > deriv (\x -> x) x
17:35:45 <lambdabot>   1
17:35:48 <mmorrow> yay
17:35:48 <roconnor> > deriv (const (dVar x)) x
17:35:50 <lambdabot>   1
17:35:57 <mmorrow> ahh, right
17:36:06 <roconnor> > deriv (const (dVar y)) x
17:36:08 <lambdabot>   1
17:36:14 <roconnor> :D
17:36:18 <jeffwheeler> :(
17:36:23 <roconnor> > deriv (const (dVar pi)) x
17:36:24 <lambdabot>   1.0
17:36:28 <Olathe> > deriv (dVar x) 1
17:36:29 <lambdabot>   Couldn't match expected type `Dif a -> Dif b'
17:36:35 * kerlo frowns not being able to put 'where' around a whole big set of declarations
17:36:38 <Olathe> > deriv (\x -> dVar x) 1
17:36:39 <lambdabot>   1~~
17:36:46 <Olathe> ~~ ?
17:36:48 <Olathe> > 1~~
17:36:49 <lambdabot>   <no location info>: parse error on input `;'
17:36:56 <roconnor> @type deriv (\x -> dVar x) 1
17:36:58 <lambdabot> forall a. (Num a) => Dif a
17:37:08 <roconnor> 1~~ means 1 plus or minus epsilon
17:37:13 <Olathe> > deriv (\x -> dVar x) 1 1
17:37:14 <lambdabot>   Couldn't match expected type `t1 -> t'
17:37:20 <jeffwheeler> Epsilon?
17:37:46 <roconnor> epsilon is an infinitesimal
17:38:09 <Olathe> > sing "What's epsilon got to do...got to do with it ?"
17:38:10 <lambdabot>   ♪ What's epsilon got to do...got to do with it ? ♪
17:38:33 <Olathe> > deriv dVar 1
17:38:35 <lambdabot>   1~~
17:38:37 <roconnor> sin (x+epsilon) = sin x + epsilon*cos(x)
17:38:38 <Olathe> > deriv dVar 50
17:38:39 <lambdabot>   1~~
17:38:46 <Olathe> @type dVar
17:38:47 <lambdabot> forall a. (Num a) => a -> Dif a
17:38:56 <Olathe> > dVar 50
17:38:58 <lambdabot>   50~~
17:39:07 <roconnor> dVar c is c + epsilon
17:39:54 <chessguy> @hoogly any
17:39:54 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
17:39:54 <lambdabot> Data.ByteString any :: (Word8 -> Bool) -> ByteString -> Bool
17:39:54 <lambdabot> Data.Foldable any :: Foldable t => (a -> Bool) -> t a -> Bool
17:40:00 <Olathe> > deriv (sin.dVar) x
17:40:01 <lambdabot>   1 * cos x~~
17:40:07 <Olathe> How does it do that ?
17:40:28 <roconnor> @type deriv (sin.dVar)
17:40:30 <lambdabot> forall a. (Floating a) => a -> Dif a
17:40:44 <augustss> roconnor: Data.Numbers.Symbolic has some simplification, SimpleReflect doesn't
17:41:01 <roconnor> sin.dVar is of type Dif Expr -> Dif (Dif Expr)
17:41:05 <augustss> > var "x"
17:41:06 <lambdabot>       Ambiguous occurrence `var'
17:41:06 <lambdabot>      It could refer to either `Data.Number.S...
17:41:07 <Olathe> > let f = sin.cos in deriv (f.dVar) x
17:41:08 <roconnor> augustss: ah right
17:41:08 <lambdabot>   1 * negate (sin x) * cos (cos x)~~
17:41:19 <Olathe> How does it know what functions it's getting ?
17:41:42 <Olathe> From what I understand, show can't work on functions because it can't see their definitions or something.
17:41:43 <roconnor> Olathe: from the Floating instance of Dif a
17:41:47 <Olathe> Ahh.
17:41:57 <augustss> > Data.Number.Symbolic.var "x"
17:41:59 <lambdabot>   x
17:42:33 <augustss> > deriv (sin.cos) $ Data.Number.Symbolic.var "x"
17:42:34 <lambdabot>   (-sin x)*cos (cos x)
17:42:46 <mjonsson> can it do integrals?
17:42:51 <augustss> No
17:43:00 <Axman6> i'd be using Mathematica for that
17:43:12 * Axman6 <3 his university for giving him a free copy
17:43:13 <jeffwheeler> SymPy can do integrals. ;)
17:43:16 <Olathe> > sin.dVar
17:43:17 <roconnor> We could do integrals if we used that power series library
17:43:17 <lambdabot>       Overlapping instances for Show (a -> Dif a)
17:43:17 <lambdabot>        arising from a use o...
17:43:23 <Olathe> > sin.dVar $ x
17:43:24 <augustss> Integral are very difficult compared to derivation
17:43:24 <lambdabot>   sin x~~
17:43:27 <roconnor> maybe that should be added to lambdabot
17:43:30 <mjonsson> augustss, yeah
17:44:07 <augustss> > deriv (^2) x
17:44:08 <lambdabot>   1 * x + x * 1
17:44:12 <roconnor> augustss: what about using http://www.cs.dartmouth.edu/~doug/powser.html
17:44:25 <Olathe> > deriv sin x
17:44:26 <kmeyer> is DiffArray part of core ghc libraries?
17:44:26 <lambdabot>   1 * cos x
17:44:34 <Olathe> > deriv (sin.dVar) x
17:44:35 <lambdabot>   1 * cos x~~
17:44:37 <roconnor> augustss: oh, maybe that is hard to evaluate
17:44:43 <jeffwheeler> @hoogle DiffArray
17:44:44 <lambdabot> Data.Array.Diff type DiffArray = IOToDiffArray IOArray
17:44:44 <lambdabot> Data.Array.Diff data IOToDiffArray a i e
17:44:44 <lambdabot> Data.Array.Diff newDiffArray :: (MArray a e IO, Ix i) => (i, i) -> [(Int, e)] -> IO (IOToDiffArray a i e)
17:44:54 <augustss> roconnor: Might be okay for numeric stuff, but not symbolic.
17:45:00 <Olathe> Is dVar only needed for multivariable stuff ?
17:45:15 <kmeyer> jeffwheeler: what's that mean?
17:45:24 <jeffwheeler> kmeyer: less than I thought it would. :-/
17:45:27 <kmeyer> :D
17:45:33 <roconnor> mjonsson: oh, did you want symbolic integration? or just access to the integral as a function?
17:45:43 <ddarius> Numeric integration = easy, numeric differentiation = hard; symbolic integration = hard, symbolic differentiation = easy
17:45:47 <kmeyer> newDiffArray (start, end) [(coord, pairs), ...]
17:45:48 <kmeyer> I guess.
17:45:59 <jeffwheeler> kmeyer: looks like it's in the arrays package, which may or may not be included with GHC.
17:46:05 <jeffwheeler> ghc-pkg list to see
17:46:17 <chessguy> ok, one more algorithm and i can call this a successful day
17:46:23 <kmeyer> array-0.2.0.0
17:46:27 <kmeyer> so I should have it, I think
17:46:32 <jeffwheeler> kmeyer: yep.
17:46:40 <kmeyer> cool.
17:49:24 <mjonsson> roconnor, I was just curious, but I meant symbolic integration
17:49:59 <roconnor> mjonsson: ah.  that is fairly difficult.
17:50:30 <roconnor> jeffwheeler: your new positions implemenation forces more normalization that it used to.
17:51:00 <roconnor> jeffwheeler: we probably want to use some sort of unfoldr here
17:51:06 <roconnor> @type unfoldr
17:51:08 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
17:51:44 <jeffwheeler> roconnor: hmm; I didn't consider that -- I just played with it until it functioned correctly ;)
17:52:00 <roconnor> jeffwheeler: length always raise a red flag for me
17:52:04 <roconnor> well, maybe an orange flag
17:52:58 <roconnor> jeffwheeler: unfoldr (\p -> fmap (\x->(x,x)) previous) p
17:53:06 <roconnor> does approximately what you want
17:53:11 <roconnor> may need some tweeking
17:53:27 <roconnor> @pl (\x->(x,x))
17:53:27 <lambdabot> join (,)
17:53:32 <roconnor> ah right
17:53:32 * kerlo adds type signatures to his program, thereby making the type error a lot shorter
17:53:33 <roconnor> bah
17:53:39 <jeffwheeler> roconnor: that looks considerably better than what I just tried ;) : left  = takeWhile (not · atStart)  $ iterate (fromJust · previous) (fromJust $ previous $ p)
17:53:40 <roconnor> kerlo: good idea
17:54:05 <jeffwheeler> roconnor: and probably works, too
17:54:08 <roconnor> jeffwheeler, well I haven't tested mine
17:54:19 <roconnor> I'm expecting you will need to throw in a tail at the end.
17:54:30 <roconnor> (or beginning depending on how you count things)
17:54:36 <kerlo> Simple enough to do: comment out the dubious code, ask GHCi for the type signatures, copy them.
17:54:41 <roconnor> :D
17:55:36 <kerlo> And maybe change them. I don't want my readsPrec functions taking complex numbers.
17:55:37 <roconnor> jeffwheeler: I was a little worried about using maybe with next and previous, but I think this unfoldr shows that it is "the right thing"
17:56:05 <roconnor> @type unfoldr
17:56:07 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
17:56:10 <roconnor> heh
17:56:15 <roconnor> maybe you won't need the tail
17:56:27 <Axman6> > read "1.0 :+ 2.0" :: Complex Double
17:56:28 <lambdabot>   1.0 :+ 2.0
17:56:56 <jeffwheeler> roconnor: I'm slow at all this. I'm just now finishing fixing the imports.
17:56:58 <kerlo> (And I'd rather say String than [Char].)
17:57:07 <roconnor> jeffwheeler: take your time
17:57:40 <Gracenotes> http://www.haskell.org/gtk2hs/docs/current/System-Glib-MainLoop.html#v%3AtimeoutAdd says that one can "set a function" to be called at regular intervals... so why isn't there a function as an argument?
17:58:27 <mmorrow> i think i read somewhere that mathematica's code for symbolic integration is over 1 million lines
17:58:30 <Gracenotes> it's timeoutAdd :: IO Bool -> Int -> IO HandlerId
17:58:41 <dcoutts> Gracenotes: the IO Bool is the function
17:58:51 <dcoutts> though you might prefer to call it an action
17:58:59 <Gracenotes> ...ah
17:59:04 <mmorrow> (ghc is around 150,000 loc)
17:59:12 <Gracenotes> thanks :)
17:59:19 <roconnor> mmorrow: there is an algorithm to find an elementary anti-deriviative if it exists and terminates if it doesn't exists, but no one has ever implemented it.
17:59:21 <Gracenotes> yes, functionless arguments. Always surprising
17:59:33 <roconnor> in its entirety
17:59:36 <Gracenotes> or is that argumentless functions?
17:59:38 <Axman6> mmorrow: mathematica is pretty impressive really, though it's syntax is horrid
17:59:48 * Gracenotes goes back to work
17:59:58 <dcoutts> Gracenotes: well because it's a monad it really has hidden arguments
18:00:14 <mmorrow> roconnor: i have a book on symbolic integration that i got for amusement. i'd be surprised if the algo you're refering to works in the general case.
18:00:19 <Gracenotes> RealWorld?
18:00:35 <roconnor> mmorrow: it does.
18:00:41 <mmorrow> Axman6: 1 million loc in C
18:00:43 <roconnor> I was so pissed of when I read about it
18:00:46 <mmorrow> roconnor: link?
18:00:57 <roconnor> all that time as an undergrad fiddling to find antideriviates
18:01:03 <roconnor> and there was an algorithm all this time!
18:01:07 <mmorrow> why would mathematica have 1 million LOC dedicated to symbolic integration then?
18:01:32 <Axman6> it's a big algorithm
18:01:35 <Axman6> :P
18:01:57 <mmorrow> apparently :)
18:02:00 <dcoutts> Gracenotes: well in the case of IO it's more helpful to think of it as abstract, but if that were some state or reader monad value, M Bool, it's still an action with some internal plumbing so it's not really a value
18:02:21 <roconnor> bah
18:02:24 <roconnor> can't find the paper
18:02:29 <roconnor> I'll have to use wikipedia
18:02:30 <ddarius> @google Risch algorithm
18:02:32 <lambdabot> http://en.wikipedia.org/wiki/Risch_algorithm
18:02:46 <dcoutts> Gracenotes: you just have to read  M Foo as  the 'M' representing all that hidden plumbing, extra arguments and results or whatever it does internally
18:02:54 <roconnor> ya
18:02:57 <roconnor> there you go
18:03:37 <roconnor> ``No software (as of March 2008[update]) is known to implement the full Risch algorithm, although several computer algebra systems have partial implementations.
18:03:38 <dcoutts> Gracenotes: but yes, one implementation of IO is to pass a real world token value
18:03:47 <mmorrow> "Note that a lot of programs (including Maple and Mathematica) can find the antiderivative for the above function using non-elementary functions (which is not the topic for Risch algorithm)."
18:04:14 <mmorrow> "The Risch algorithm is used to integrate elementary functions."
18:04:46 <dons> dcoutts: 28 day sliding average graph of hackage uploads per day, http://galois.com/~dons/images/hackage-daily-graph.png
18:04:57 * gwern sighs. I wish John hadn't left for the day while leaving gitit in a non-compiling state vis-a-vis filestore
18:04:57 <roconnor> dons: I uploaded today!
18:05:09 <gwern> I uploaded yesterday!
18:05:20 <roconnor> oh, but not uniquely
18:05:22 <roconnor> sorry
18:05:34 <dcoutts> dons: it would be great to annotate it with ghc releases, I expect they align with the two biggest peaks
18:05:48 <roconnor> well, maybe I don't know what unique mean
18:05:52 <roconnor> does it mean new package
18:06:10 <roconnor> or combining multiple uploads of one package on one day?
18:07:00 * chessguy 's head hurts from turning thus imperative crap into decent code
18:07:29 <dcoutts> augustss_: the LLVM / FP discussion does not seem too healthy. There is not enough discussion of specific details, eg what in C-- is not in LLVM. Eg they cite EHC, but if you read the talk, they don't do GC at all. So not a useful data point.
18:07:44 <Gracenotes> chessguy: translating?
18:07:53 <Gracenotes> between languages
18:08:05 <chessguy> yeah, from pseudo-pseudo-cde
18:09:36 <mmorrow> dcoutts: yeah, it doesn't look like any of the people claiming LLVM can solve these problems has read the C-- spiel, let alone the C-- spec
18:09:39 <augustss_> dcoutts: it seems rather vague, yes. But I know some fp people that dislike the llvm.
18:10:22 <dcoutts> augustss_: sure, but they have reasons beyond NIH and LLVM being C++, we need to articulate exactly what the problems are
18:10:39 <dcoutts> mmorrow: yes, exactly
18:10:56 <augustss_> If there are problems. I'm not convinced.
18:10:59 <pejo> dcoutts, is it likely that articulating it will make them fix llvm, or go away?
18:11:02 <adimit> a quick question: in order to store various dates (I got full dates, i.e. h:m m/d/y +TZ, as well as just h:m) reliably and in a 'standard' manner, I use Dat.Time.Format, or wouldn't I?
18:11:27 <dcoutts> mmorrow: but it also may not be clear to LLVM hackers used to C etc what it is in C-- that is really essential for FP languages.
18:11:41 <dcoutts> mmorrow: it might just look like a random different feature set
18:12:00 <Axman6> > read "NaN" :: Double
18:12:01 <lambdabot>   NaN
18:12:05 <Axman6> nice
18:12:19 <dcoutts> pejo: I think if it's done in the right way then we can get advice from the LLVM people on how to extend it to support the stuff we need.
18:12:34 <augustss_> I'm sure the llvm needs some changes for fp, but I don't know how big.
18:12:40 <dcoutts> pejo: the intention is not to put down LLVM
18:13:00 <dcoutts> if we don't have to support native code gen for lots arches that's a great thing
18:13:30 <mmorrow> dcoutts: yeah, i think that's part of it too. (from what i understand, etc) it's not a simple matter of just "hacking support for keeping the heap pointer in a reg" in. it would require an entirely different fundamental way of doing things.
18:14:02 <dcoutts> augustss_: right, the LLVM hackers are in the best place to say, but they don't know what we need.
18:14:07 <mmorrow> (i'm no expert on this topic, and i've certainly never written a code gen, etc..)
18:14:26 <pejo> dcoutts, most definitely. It makes it harder to research backend specific optimisations though.
18:14:45 <dcoutts> mmorrow: really? how so?
18:14:53 <augustss_> The heap pointer shouldn't be in a reg. It should allocated like any variable.
18:15:26 <dcoutts> mmorrow: C-- does not look that different from LLVM. It's got some extra features but it doesn't look fundamentally different.
18:15:43 <mmorrow> perhaps "fundamentally" was too strong a word choice
18:16:01 <mmorrow> augustss_: oh?
18:16:09 <Lemmih> augustss_: Is it is now, heap pointers are always put on the stack.
18:16:09 <dcoutts> augustss_: indeed, I think the ghc backend will not require that once the high performance -fvia-C backend goes away
18:16:50 <augustss_> mmorrow: why tie up a register when you are not allocating?
18:16:56 <dcoutts> Lemmih: they say they can allow them to go in a reg, what else would be needed?
18:17:36 <Lemmih> dcoutts: A way of determining which registers contain heap pointers.
18:17:51 <dcoutts> Lemmih: presumably you have to make sure that is at least static.
18:17:52 <mmorrow> augustss: i guess that makes sense. i thought for some reason that being able to reserve regs for certain purposes globally was desireable.
18:17:55 <Lemmih> dcoutts: It is not known statically.
18:18:03 <dcoutts> Lemmih: in ghc it is
18:18:15 <Lemmih> dcoutts: Sure, but in LHC it is not.
18:18:58 <dcoutts> Lemmih: perhaps it prevents some optimisations, you cannot alias the two kinds, but surely it is possible
18:19:14 <dcoutts> Lemmih: otherwise you need data tagging to work it out right?
18:19:33 <gwern> hm. looking through the downloaded tarballs from hackage is not working
18:19:39 <Lemmih> dcoutts: Right, and are /are/ using data tagging.
18:19:45 <Lemmih> *and we are
18:19:49 <gwern> dcoutts: is there any master list of who uploaded what? I can't remember half the packages I need to check with 6.10
18:20:06 <dcoutts> gwern: yes, the log, see the intro page for the link
18:20:32 <gwern> the intro page? man, I haven't been there since last year
18:20:56 <gwern> ah, excellent. exactly what I needed
18:20:58 <Lemmih> dcoutts: It definitely is possible. You just can't do it with LLVM.
18:21:18 <dcoutts> Lemmih: so for example you could not compile for a platform that used a different set of registers for addresses vs data values
18:21:31 <chessguy> @type uncurry
18:21:33 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
18:21:49 <gwern> I've uploaded only 191 tarballs? that seems a little low
18:21:53 <gwern> I need to get cracking
18:21:55 <dcoutts> hah hah
18:21:56 <Killb0t> what's haskell?
18:22:14 <mauke> a programming language
18:22:15 <Lemmih> dcoutts: I wasn't aware such platforms existed.
18:22:17 <Axman6> a functional programming language
18:22:19 <dcoutts> Killb0t: http://haskell.org/
18:22:24 <augustss_> Lemmih: so you should figure out how to improve the llvm
18:22:39 <dcoutts> Lemmih: they are only of historical interest now
18:22:56 <Lemmih> augustss_: The C-- guys have been studying how to do it in 10 years and they're still not done.
18:23:21 <dcoutts> Lemmih: I don't understand what you mean by that exactly
18:23:33 <augustss_> Lemmih: maintaining 5-10 native code generators isn't that much fun. I promise.
18:23:34 <Lemmih> augustss_: It's a research problem, not an engineering problem.
18:23:36 <dcoutts> Lemmih: there is a C-- compiler, qc-- and ghc's backend is a simplified C-- compiler
18:23:37 <pejo> dcoutts, microcontrollers, DSP's, etc.
18:23:50 <dcoutts> pejo: oh, ok, still alive
18:24:06 <Lemmih> dcoutts: I'm well aware of that.
18:24:30 <dcoutts> Lemmih: so clearly I don't know what this research problem is
18:24:39 <pejo> dcoutts, perhaps not a target market for Haskell, but the hardware guys have a way of making sure that it's hard to write compilers for stuff they make.
18:24:44 <Lemmih> augustss_: Right, and that's why people have been working on C-- for so long.
18:25:00 <dcoutts> pejo: :-)
18:25:15 <moozilla> can someone tell me what the preferred way of writing networking code?
18:26:35 <augustss_> @faq networking?
18:26:35 <lambdabot> The answer is: Yes! Haskell can do that.
18:26:48 <moozilla> lol
18:27:10 <moozilla> I wrote an IRC bot, but I just copy/pasted the networking code
18:27:14 <moozilla> I want to understand it
18:28:11 <dcoutts> moozilla: the sockets lib is basically the same api as you get in other languages, so a generic sockets networking might help if you can't find enough haskell-specific tutorials
18:28:13 <Lemmih> dcoutts: We don't know how to create a good target language. C-- is a stab in that direction but it is far from done.
18:29:01 <mmorrow> my understanding is that C-- allows you to create arbitrarily many stacks, and arbitrarily transfer control between them.
18:29:10 <mmorrow> can this be done with LLVM?
18:29:13 <dcoutts> Lemmih: fair enough, I'm sure C-- is not the final word in target languages for FP compilers
18:29:20 <moozilla> dcoutts so it would be done with Network.Socket?
18:29:28 <dcoutts> moozilla: yes
18:29:37 <dcoutts> mmorrow: get on the LLVM list and talk about it
18:29:50 <mmorrow> :)
18:29:56 <moozilla> dcoutts why does the library page say this: "The Network interface is a "higher-level" interface to networking facilities, and it is recommended unless you need the lower-level interface in Network.Socket. "?
18:30:56 <gwern> dcoutts: I know I've asked this before, but what earthly use does cabal supporting greencard serve?
18:31:13 <dcoutts> moozilla: it's a simplified api compared to the sockets api
18:31:34 <moozilla> dcoutts: so most apps use Network.Socket?
18:31:57 <dcoutts> moozilla: I expect many can use the simplified Network api
18:32:04 <dcoutts> gwern: what support for green card? :-)
18:32:51 <gwern> dcoutts: in Setup configure, iirc
18:32:51 <dcoutts> gwern: oh, sorry, I'd forgotten, I didn't remove all of it
18:33:09 <mauke> :t [mempty, (mempty,mempty), (mempty,(mempty,mempty))]
18:33:10 <lambdabot> forall a a1 a2. (Monoid a2, Monoid a1, Monoid a) => [(a, (a1, a2))]
18:33:28 <gwern> specifically, in Distribution/Simple/PreProcess.hs and Distribution/Simple/Program.hs
18:33:42 <gwern> although I'd prefer doc/Cabal.xml didn't link to greencard too
18:33:59 <gwern> ie - Distribution/Simple/PreProcess.hs:  [ ("gc",     ppGreenCard)
18:34:18 <dcoutts> gwern: I was getting confused with the support for progrimatica, which got removed
18:34:43 <dcoutts> gwern: greencard is perfectly reasonable as a pre-processor, though I don't know of any packages now that use it apart from nhc
18:34:58 <dcoutts> gwern: supporting it is pretty cheap
18:35:27 <gwern> nhc still uses it? they must be using a private branch, because I know I didn't support nhc when I cabalized greencard...
18:35:44 <dcoutts> must be
18:35:59 <gwern> dcoutts: it's historical and unmaintained and I used some rather gruesome hacks to make it work and I'm afraid someone will actually try to use it
18:36:47 <dcoutts> gwern: heh heh
18:37:05 <chessguy> @hoogle [a] -> [a] -> Bool
18:37:05 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
18:37:05 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
18:37:05 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
18:37:15 <gwern> I have no trouble with it being on hackage as being of historical interest, but if someone tries to use it...
18:37:24 <chessguy> is there no standard subset function ?
18:37:26 <chessguy> @hoogle+
18:37:26 <lambdabot> Distribution.Simple.Utils isInfixOf :: String -> String -> Bool
18:37:26 <lambdabot> System.FilePath.Posix equalFilePath :: FilePath -> FilePath -> Bool
18:37:26 <lambdabot> System.FilePath.Windows equalFilePath :: FilePath -> FilePath -> Bool
18:38:52 <Axman6> i didn't know about @hoogle+, nice :)
18:39:13 <chessguy> > [1,2,3] \\ [4]
18:39:15 <lambdabot>   [1,2,3]
18:39:33 <kerlo> > "hello, world" \\ "l"
18:39:35 <lambdabot>   "helo, world"
18:39:44 <kerlo> > "hello, world" \\ "over the lazy dog"
18:39:46 <lambdabot>   "l,wl"
18:40:17 <mauke> :t (null .) . (\\)
18:40:18 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
18:41:33 <chessguy> mauke:  yeah, that's what i came up with myself
18:41:47 <chessguy> @unpl (null .) . (\\)
18:41:47 <lambdabot> (\ d g -> null (d \\ g))
18:42:26 <chessguy> @pl isSubsetOf xs ys = null (ys \\ xs)
18:42:27 <lambdabot> (line 1, column 18):
18:42:27 <lambdabot> unexpected "="
18:42:27 <lambdabot> expecting variable, "(", operator or end of input
18:42:48 <chessguy> @pl \xs ys -> null (ys \\ xs)
18:42:48 <lambdabot> (line 1, column 20):
18:42:48 <lambdabot> unexpected "\\"
18:42:48 <lambdabot> expecting variable, "(", operator or ")"
18:42:52 <chessguy> sigh
18:42:58 <blackh> I have just found the cause of a bizarre bug.  I just need to ask whether the fault lies in my code, in ghc, or in my mental health...
18:43:23 <dons> graphic hackage: http://www.reddit.com/r/haskell/comments/7qjie/open_source_haskell_releases_and_growth/
18:44:15 <gwern> the fault, dear blackh, lies not the codes, but ourselves
18:44:51 <dons> http://galois.com/~dons/images/chart-hackage.png
18:44:57 <dons> breakdown of hackage by category
18:45:02 <blackh> The code uses an IORef inside unsafePerformIO.  I'm putting a huge string into this IORef (inside a tree structure).  If I leave the value in the IORef, it leaks memory.  If I write over the contents of the IORef with an empty data structure, it doesn't leak!
18:45:44 <blackh> I would think that an IORef used inside unsafePerformIO should be cleaned up when unsafePerformIO exits (and the IORef is no longer referenced by anything).  Doesn't that seem sensible?
18:45:53 <Axman6> dons: i did some more testing, and found i get segaults with -fvia-C as well as without it. i get slightly different (incorrect) numerical results with though
18:46:35 <blackh> Ah. I know what it is. A closure is registered with C code, and the closure references the IORef.
18:46:43 <blackh> Thank you! You have been most helpful! :)
18:47:01 <mauke> my work here is done.
18:47:18 <gwern> just like mauke to hog the credit
18:47:22 <gwern> I too did nothing
18:47:39 <moozilla> as did I
18:48:41 <gwern> dons: I think we may need to start splitting the Other category
18:49:54 <kerlo> @type when
18:49:55 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
18:50:18 <dons> gwern: well, that's the combination of the other 30 odd categories
18:50:22 <dons> all < 20 packages each
18:50:32 <chessguy> the sickness! http://hpaste.org/14042 oh, it hurts!! :)
18:51:01 <dolio> That's some sleek code.
18:51:13 <chessguy> haha
18:51:32 <chessguy> it type-checks :)
18:51:40 <Nafai> Dang it you guys
18:51:52 <Nafai> Even though I haven't done a ton of Haskell programming
18:52:02 <Nafai> I think you've ruined me for most dynamic programming
18:53:02 <mauke> Nafai: http://en.wikipedia.org/wiki/Dynamic_programming
18:53:12 <mauke> huhu
18:53:14 <Nafai> Er
18:53:16 <Valodim> no we improved you. but you will never feel the happiness of blissfull ignorance again :)
18:53:20 <Nafai> You know what I meant:)
18:53:58 <Nafai> dynamic typing
18:54:23 <dons> sleek the elite code chessguy
18:54:49 <blackh> Nafai: I sometimes wish it were possible to become ignorant again. :)
18:54:57 <Nafai> blackh: Heh :)
18:54:59 <chessguy> dons:  it's goin' up on hackage, baby!
18:55:01 <Axman6> dons: had a chance to play with that nbodies thing?
18:55:09 <mauke> meh, I don't see the problem
18:55:12 <mauke> I still like Perl
18:55:23 <blackh> Nafai: I look enviously out the window at my sheep. :)
18:55:40 <Valodim> blackh: well I for one like apples. especially provided by snakes
18:56:00 <kerlo> Now, surely there's a simple way to write "all but the last two elements of xs".
18:56:08 <Nafai> My problem is I'm too much of an idealist
18:56:15 <mauke> :t join (.) init
18:56:16 <lambdabot> forall a. [a] -> [a]
18:56:43 <chessguy> > join (.) init $ [1,2,3,4,5]
18:56:45 <lambdabot>   [1,2,3]
18:56:52 <Axman6> > init []
18:56:52 <kerlo> I guess that'll work.
18:56:53 <lambdabot>   * Exception: Prelude.init: empty list
18:56:53 <chessguy> that's sick
18:57:01 <mauke> :t join fmap init
18:57:03 <lambdabot> forall a. [a] -> [a]
18:57:03 <chessguy> mauke++
18:57:30 <Valodim> :t join
18:57:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
18:57:32 <dolio> dcoutts: I need some cabal advice.
18:57:39 <Valodim> ..huh
18:57:43 <dcoutts> @yarr!
18:57:43 <lambdabot> Where d' all t' pirates come from?
18:57:43 <lambdabot> Great Yarrmouth!
18:57:46 <dcoutts> dolio: ok
18:58:08 <dolio> dcoutts: I want to add tests to uvector-algorithms, but obviously if I want benchmarks, 'test = system "runhaskell foo.hs"' isn't going to be good enough.
18:58:12 <mauke> Valodim: set m = (e ->) and rethink
18:58:43 <dolio> So, should I make a separate benchmarking package, or is there some way to compile a test app with optimizations from within the package?
18:58:47 <kerlo> @index hSetBuffering
18:58:47 <lambdabot> System.IO
18:58:51 <Valodim> "apply twice"?
18:58:58 <Valodim> + by
18:58:59 <gwern> dons: oh. I thought we had a real Other category that that was counting, not 'all the small categories'
18:59:03 <dcoutts> dolio: ah, it's for benchmarking rather than correctness
18:59:09 <chessguy> if an inference engine thinks that "(a /\ b) /\ (not a)" doesn't entail b, is that a bad thing?
18:59:10 <kerlo> @index isPrefixOf
18:59:11 <lambdabot> Data.List
18:59:19 <chessguy> err, a\/b
18:59:30 <cknapp> chessguy: I would assume that's a problem
18:59:35 <chessguy> never mind, i think my brain has slipped a gasket
18:59:36 <dolio> Well, I want correctness tests, too, but those don't depend on performance, so I can use the typical tricks.
18:59:37 <chessguy> or 2
19:00:08 <dcoutts> dolio: until we have better support for tests it might just be simpler to bung the test app into a sub directory with it's own .cabal file and distribute the thing in the tarball
19:00:20 <cknapp> Oh... you put the formula wrong in the inference engine? Yeah, not a problem. :)
19:00:21 <dcoutts> dolio: you don't expect all users to build it right?
19:00:31 <dolio> Right.
19:00:40 <dolio> That's actually a good idea. I think I'll try that.
19:00:50 <dolio> Keep it all under the same repository.
19:00:54 <dcoutts> dolio: or you can include it in the same .cabal file as an executable but with buildable: False
19:01:29 <dcoutts> dolio: that's another common trick. We're going to be adding proper test sections some time, like lib or exe but specifically for tests.
19:01:49 <dolio> Okay.
19:01:57 <dons> gwern: http://hpaste.org/14043
19:02:16 <dons> top 30 categories. 72 in total
19:03:07 <mauke> my regex-based expression simplifier thinks it's equivalent to not (not b \/ a)
19:03:14 * gwern is pleased by the high game ranking
19:03:35 <dcoutts> dons: nice post about hackage 1k
19:04:22 <dons> the sliding average growth curve is cool
19:04:41 <dcoutts> yes
19:04:48 <roconnor> dons: that is a nice spread in category
19:04:50 <dons> i need an up to date irc channel one though. then overlay that on hackage.
19:06:22 * roconnor will try to convince dons to use Haskell Charts
19:06:24 <roconnor> :P
19:07:26 <dcoutts> yes, it's pretty
19:07:54 <dcoutts> and you can use cairo to draw extra stuff on top I presume
19:08:32 * dcoutts stops hacking on the new "cabal info" command and goes to bed
19:08:45 <roconnor> damn
19:08:50 <blackh> Is it possible to add a finalizer to any old data structure? I am trying to figure out some way to make sure freeHaskellFunPtr gets called on a list of FunPtrs that I'm keeping in this data structure.
19:08:59 <kmeyer> @hoogle IO Char
19:08:59 <lambdabot> Did you mean: :: IO Char /count=20
19:08:59 <lambdabot> No results found
19:09:02 * roconnor slips dcoutts some caffine pills
19:09:11 <dcoutts> roconnor: it's 3am already! :-)
19:09:14 <mauke> :t getChar
19:09:16 <lambdabot> IO Char
19:09:18 <kmeyer> hrm...
19:09:22 <kmeyer> thanks mauke
19:09:36 <roconnor> dcoutts: thats okay ... I guess  :P
19:09:57 <dcoutts> roconnor: it's like "cabal list" but not for searching, it takes specific package names and displays much more detailed info, a merge of the info you see on the hackage page with what you get from ghc-pkg describe
19:10:03 * kmeyer is writing an as-pure-as-possible brainfuck interpreter
19:10:16 <kmeyer> as a learning exercise
19:10:25 <chessguy> haha, no more runtime error
19:10:35 <chessguy> an infinite loop, yes, but not a runtime error
19:11:10 <roconnor> chessguy: that doesn't sound better
19:11:23 <chessguy> don't be such a pessimist
19:11:24 <kmeyer> :t putChar
19:11:25 <lambdabot> Char -> IO ()
19:12:10 <chessguy> it's clearly better, because the runtime error was hiding the infinite loop, so there were (at least) two bugs, and now there's "only" at least 1 bug.......
19:12:38 <chessguy> bow to my superior logic
19:13:23 <roconnor> chessguy: you used recursion or recursive let didn't you?
19:13:29 <roconnor> tsk tsk
19:13:38 <chessguy> heh
19:13:46 <roconnor> fold!
19:13:50 <roconnor> fold!!
19:13:50 <chessguy> i forgot recursion is frowned upon in haskell
19:13:54 <kmeyer> :D
19:14:09 <kerlo> Is GHC.Exception.SomeException an instance of GHC.Exception.Exception?
19:14:31 <roconnor> recursion leads to bugs :P
19:14:58 <Japsu> programming leads to bugs
19:15:13 <chessguy> @ghc
19:15:13 <lambdabot> ghc says: Bad eta expand
19:15:16 <roconnor> that too
19:15:16 <chessguy> @ghc
19:15:17 <lambdabot> ghc says: Cannot unify a type variable with a type scheme
19:15:26 <chessguy> @.elite ghc
19:15:27 <lambdabot> Ghc
19:15:32 <roconnor> @quote impossible
19:15:33 <lambdabot> qwe1234 says: the lisp folks have purposefully made lisp so that static analysis is impossible.
19:15:36 <kerlo> @. elite ghc
19:15:36 <lambdabot> Ghc 5AYS: cY(|E in 7ype zYNONym DEclARa7I0n$
19:15:43 <blackh> Does anyone know how to get hold of Evan Martin, the author of hexpat? He is not replying to my emails.
19:15:44 <chessguy> @slap ghc
19:15:45 * lambdabot locks up ghc in a Monad
19:15:53 <chessguy> haha
19:15:59 <kerlo> @ghc
19:15:59 <lambdabot> ghc says: Occurs check: cannot construct the infinite kind
19:16:01 <chessguy> just try to get out of that, ghc
19:16:08 <dolio> @keal
19:16:08 <lambdabot> there is no way to prove the failsafe exists
19:16:10 <kerlo> GHC is fun.
19:16:18 <kerlo> These are all real errors, I take it.
19:16:46 <kmeyer> what is the behaviour of getChar if EOF is encountered?
19:17:08 <chessguy> > getChar "EOF"
19:17:09 <lambdabot>   Couldn't match expected type `[Char] -> t'
19:17:13 <chessguy> kmeyer:  there ya go
19:17:22 <kmeyer> ?
19:17:35 <kmeyer> :t getChar
19:17:36 <lambdabot> IO Char
19:17:37 <kmeyer> you're using it wrong
19:17:40 <chessguy> ok, i'll stop being (quite so) silly
19:18:11 <chessguy> kmeyer:  don't mind me
19:18:14 <scsibug> kmeyer: it throws an exception
19:18:20 <kmeyer> scsibug: ew :(
19:18:30 <roconnor> @hoogle eof
19:18:31 <lambdabot> Text.Parsec.Combinator eof :: (Stream s m t, Show t) => ParsecT s u m ()
19:18:31 <lambdabot> Text.ParserCombinators.Parsec.Combinator eof :: (Stream s m t, Show t) => ParsecT s u m ()
19:18:31 <lambdabot> Text.Read EOF :: Lexeme
19:18:39 <roconnor> @more
19:18:48 <roconnor> @more-hoogle
19:18:49 <lambdabot> Unknown command, try @list
19:18:54 <chessguy> @hoogle+
19:18:54 <lambdabot> Language.Haskell.Lexer EOF :: Token
19:18:54 <lambdabot> Text.Read.Lex EOF :: Lexeme
19:18:54 <lambdabot> System.IO.Error eofErrorType :: IOErrorType
19:18:55 <scsibug> kmeyerwhat would y
19:18:58 <cknapp> On page 6 of the FGL paper, it says "The graph type itself is implemented for efficiency reasons as an abstract type." That seems irrelevant unless I'm misunderstand "abstract data type". Can anyone here help clarify?
19:19:04 <scsibug> kmeyer: what would you prefer it do?
19:19:21 <kmeyer> return a char with EOF value
19:19:23 <roconnor> bah
19:19:25 <roconnor> @type isEOF
19:19:27 <lambdabot> Not in scope: `isEOF'
19:19:34 <roconnor> @type System.IO.isEOF
19:19:36 <lambdabot> IO Bool
19:19:46 <dpratt71> @src reverse
19:19:46 <lambdabot> reverse = foldl (flip (:)) []
19:19:47 <kmeyer> ah.
19:19:49 <kmeyer> thanks, roconnor
19:19:52 <roconnor> np
19:19:53 <kerlo> @src read
19:19:54 <lambdabot> read s = either error id (readEither s)
19:20:10 <kerlo> @src readEither
19:20:10 <lambdabot> Source not found. You type like i drive.
19:20:20 <kerlo> Meh.
19:20:37 <roconnor> kmeyer: you can write roconnor++ if you like.
19:20:47 <kmeyer> roconnor++
19:20:48 <roconnor> @karma
19:20:49 <lambdabot> You have a karma of 3
19:20:51 <kmeyer> that's not very pure
19:20:52 <roconnor> :)
19:21:05 <roconnor> succ roconnor
19:21:12 <cknapp> Haha
19:21:17 <roconnor> modify (+1) roconnor
19:21:25 <dpratt71> @src foldl
19:21:25 <lambdabot> foldl f z []     = z
19:21:25 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
19:21:51 <roconnor> dpratt71 is learning the secret art of O(n) reverse
19:22:07 <dpratt71> :)
19:22:37 <cknapp> Is it really a deep secret?
19:22:41 <roconnor> @foldl f z [a,b,c]
19:22:43 <lambdabot> No match for "f".
19:22:43 <lambdabot>  
19:22:43 <lambdabot> *** "z" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
19:22:43 <lambdabot> Z++
19:22:43 <lambdabot>  
19:22:44 <roconnor> > foldl f z [a,b,c]
19:22:45 <lambdabot> [94 @more lines]
19:22:47 <lambdabot>   f (f (f z a) b) c
19:22:57 <roconnor> > foldl f z [a,b,c]
19:22:59 <lambdabot>   f (f (f z a) b) c
19:23:29 <dpratt71> I know lambdabot is wondrous, but is there a way to get GHCi to part with this basic information?
19:23:43 <roconnor> cknapp: I don't know, I only learned it this year actually
19:24:01 <Gracenotes> using IO is like selling your soul to the devil... lots of things are easier with io refs :<
19:24:02 <roconnor> cknapp: that foldl is all about accumulating
19:24:02 <Cale> dpratt71: what information?
19:24:05 <Axman6> > foldl (:) [] [a,b,c]
19:24:06 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
19:24:06 <lambdabot>        Expect...
19:24:09 <cknapp> Oh.
19:24:10 <Cale> Gracenotes: oh?
19:24:14 <Axman6> > foldl (flip (:)) [] [a,b,c]
19:24:16 <lambdabot>   [c,b,a]
19:24:17 <dpratt71> the definition of stuff like 'foldl'
19:24:37 <roconnor> cknapp: and it implement exactly the HelperReverse technique from school without the explicit helper function.
19:24:42 <mmorrow> kmeyer: check out this brainfuck compiler of rwbarton's (goes to asm (via harpy) -> ELF .o (via hax))  http://moonpatio.com/repos/brain/
19:24:44 <cknapp> I learned fold from Scheme, and then got to the Republic of Haskell and learned I hadn't been told the whole truth
19:24:45 <Axman6> dpratt71: i think goa might do that (ghc on acid)
19:24:49 <Gracenotes> Cale: it's tempting to use an IOArray and just throw everything into an IO monad, rather than using a better-designed system with something like STArray
19:24:59 <Cale> dpratt71: Oh, no. To see the definition you'd have to look at the (GHC) source code.
19:25:06 <mmorrow> (* kmeyer is writing an as-pure-as-possible brainfuck interpreter) not sure if you're still doing this
19:25:23 <Cale> dpratt71: The Haskell Report gives example implementations for many of the Prelude functions.
19:25:31 <dpratt71> Cale: ah...so lambdabot is my friend
19:25:35 <ddarius> chessguy: Holy unnecessary parens, Batman!
19:25:38 <kmeyer> mmorrow: yes, still am
19:25:42 <Axman6> Cale: pretty sure GoA lets you do that, since it uses lambdabot
19:25:44 * kmeyer isn't on i386 though
19:25:46 <chessguy> who what where???
19:26:00 <mmorrow> kmeyer: ah too bad
19:26:03 <cknapp> Ah! "Abstract type" means type class!
19:26:08 <Cale> Axman6: oh, yeah, you could use GHCi on Acid.
19:26:10 * cknapp learns the beauty of looking at the source
19:26:11 <chessguy> oh yes
19:26:15 <dpratt71> Axman6: if I said I was using Windows...
19:26:15 <Cale> I've never tried that.
19:26:31 <int80_h> I used ghci on acid once. It wasn't plesant. ;)
19:26:33 <Axman6> dpratt71: you have ghc installed? (and cabal-install?)
19:26:50 <dpratt71> I've heard of cabal...
19:26:54 <int80_h> as I recall, I implemented visual basic. I was traumatized for days.
19:27:01 <dpratt71> they make it so easy for us Windows guys
19:27:33 <cknapp> int80_h: but notice, you were able to implement VB in the time it took for the acid to wear off! Haskell elegance strikes again!
19:27:40 <ddarius> chessguy: http://hpaste.org/14042#a1
19:27:41 <int80_h> hee hee
19:27:49 <jeffz`> dpratt71: if you get cabal-install from hackage, you get a commandline util for automatically installing stuff from hackage
19:27:59 <kmeyer> mmorrow: /me is a newbie, just trying to familiarize myself :D
19:28:00 <mmorrow> if you were able to implement vb /while/ on acid, haskell awesomeness strikes again!
19:28:33 <cknapp> kmeyer: welcome! We promise not to hurt your brain (any more than we want to hurt it, at least)
19:28:42 <chessguy> ddarius:  haha, i posted the same thing 6 seconds after you :)
19:28:51 <dpratt71> jeffz`: I'll have to investigate...I installed GHC via an .msi
19:29:04 <chessguy> or close anyway
19:29:42 <cknapp> what does a line like "Class Graph gr => DynGraph gr" mean? Is it declaring DynGraph as a subclass of Graph?
19:29:53 <gwern> shapr == shae ericsson right
19:30:39 <ddarius> chessguy: You missed one set of parens, I decided on one use of ($), you converted to concatMap which I didn't.
19:30:43 <ddarius> gwern: Yes.
19:30:45 <ddarius> erisson
19:31:14 <chessguy> cknapp:  "gr must be a member of Graph before it can be a member of DynGraph"
19:31:20 <gwern> hm. the bastard set up a new fermat's last margin repo on me >.<
19:31:21 <cknapp> Ok. Thanks
19:31:59 <gwern> @seen shae
19:31:59 <lambdabot> I haven't seen shae.
19:32:05 <gwern> @seen shapr
19:32:06 <lambdabot> shapr is in #haskell and #haskell-blah. I last heard shapr speak 1d 23h 44m 3s ago.
19:32:11 <chessguy> ddarius:  you say tomato, i use concatmap
19:32:18 <cknapp> haha
19:32:20 <Cale> Or s/before it can be/if it is to be/
19:32:43 <cknapp> Cale: you say tomato, I read source.
19:32:53 <gwern> @ask shapr what's the status of fermat'slastmargin? I have the tarball on hackage, but it's out of date and doesn't build with 6.10 while your darcs flm does. can I upload it?
19:32:53 <lambdabot> Consider it noted.
19:32:54 <Cale> If it made you happy to do so, you could write the instance of DynGraph, and then base the instance of Graph on it.
19:32:55 <ddarius> chessguy: I would've used concatMap too if I had actually looked at the code
19:32:58 * chessguy high-fives cknapp  
19:33:06 * cknapp high-fives back
19:33:22 <dpratt71> easy question: what's an example of a relatively simple function that does something useful, but doesn't specify a particular type...like "f a = [a]", but at least somewhat useful
19:33:23 <cknapp> Cale: that's useful to know.
19:33:39 <Cale> dpratt71: length?
19:33:42 <chessguy> map?
19:33:43 <gwern> dpratt71: fst?
19:33:43 <Cale> dpratt71: Or map
19:33:47 <kmeyer> :t unGetChar
19:33:48 <lambdabot> Not in scope: `unGetChar'
19:33:50 <gwern> foldr?
19:33:50 <kmeyer> :t ungetChar
19:33:52 <lambdabot> Not in scope: `ungetChar'
19:33:53 <kmeyer> boo
19:33:59 <chessguy> kmeyer:  what the heck would ungetChar do?
19:34:02 <cknapp> I love comments "quasi-unlabelled Node"
19:34:06 <kmeyer> chessguy: same thing as in C?
19:34:07 <roconnor> @hoogle peek
19:34:08 <lambdabot> Foreign.Storable peek :: Storable a => Ptr a -> IO a
19:34:08 <lambdabot> Foreign.Marshal.Array peekArray :: Storable a => Int -> Ptr a -> IO [a]
19:34:08 <lambdabot> Foreign.Marshal.Array peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
19:34:13 <kmeyer> :t peek
19:34:15 <lambdabot> Not in scope: `peek'
19:34:17 <chessguy> kmeyer:  what does it do in C?
19:34:25 <kmeyer> chessguy: puts one character back on stdin
19:34:27 <dpratt71> length and fst are very good suggestions
19:34:31 <chessguy> @google ungetchar c
19:34:33 <lambdabot> No Result Found.
19:34:42 <chessguy> kmeyer:  how ridiculous
19:34:43 <roconnor> kmeyer: prehaps you'd be happer using getContents, and just grab everything at once?
19:34:49 <kmeyer> chessguy: it's ungetc in C land
19:34:51 <dpratt71> @src length
19:34:51 <lambdabot> Source not found.
19:34:59 <chessguy> @google ungetc c
19:35:01 <lambdabot> No Result Found.
19:35:08 <chessguy> @slap herself
19:35:08 <dpratt71> @src fst
19:35:09 * lambdabot throws some pointy lambdas at herself
19:35:09 <lambdabot> fst (x,_) =  x
19:35:13 <kmeyer> roconnor: nah
19:35:26 <moozilla> what's the effecient string class again?
19:35:29 <kmeyer> it's a brainfuck interpreter, the input may not all come at once
19:35:31 <chessguy> ByteString
19:35:37 <chessguy> @hoogle ByteString
19:35:37 <lambdabot> module Data.ByteString
19:35:37 <lambdabot> module Text.Parsec.ByteString
19:35:37 <lambdabot> Data.ByteString data ByteString
19:35:39 <dpratt71> hmm...it'd probably be better in my case if it involved a list...
19:35:53 <dpratt71> ...how do I find the definition of length?
19:35:56 <moozilla> chessguy I was thinking of ShowS or StringS or something
19:36:00 <chessguy> @src length
19:36:00 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
19:36:09 <chessguy> @quote shock
19:36:10 <lambdabot> No quotes match. Just try something else.
19:36:16 <cknapp> ?
19:36:18 <chessguy> @quote something
19:36:19 <lambdabot> qwe1234 says: if programming languages were gods, something like smalltalk would be Cloacina, the goddess of the sewers
19:36:32 <cknapp> @src Data.List.length
19:36:32 <lambdabot> Source not found.
19:36:46 <roconnor> kmeyer: hLookAhead stdin ?
19:36:50 <cknapp> @where did your source go?
19:36:50 <lambdabot> I know nothing about did.
19:36:54 <chessguy> cknapp:  not all functions have @src'able definitions in lambdabot
19:36:59 <cknapp> :(
19:37:16 <dpratt71> cknapp: thanks for tryin'
19:37:20 <roconnor> kmeyer: getContents is lazy, and won't actually get it all at once
19:37:38 <kmeyer> hm
19:37:39 <roconnor> or as I perfer to think of it, getContents is concurrent
19:37:47 <dpratt71> maybe I'll go with foldr...the more complicated, the better...up to a point
19:37:48 <roconnor> lazy and concurrent?
19:38:03 <cknapp> dpratt71? What is this?
19:38:15 <chessguy> dpratt71:  arrows ftw!
19:38:30 <dpratt71> I'm writing a blog post comparing an imperative language like C# to a functional language like Haskell
19:38:33 <chessguy> ooh, or continuations!
19:38:45 <ddarius> dpratt71: C# takes a lot from Haskell.
19:38:52 <chessguy> mm, i wouldn't say a lot
19:39:04 <chessguy> what it does take was mostly bolted on after the fact
19:39:06 <dpratt71> you mean C# 3.5 + ?
19:39:10 <Cale> dpratt71: Write the equivalent of foldr in both, and then map f = foldr ((:) . f) []  in both :)
19:39:31 <roconnor> kmeyer: you may also be intrested in "interact" which is also equally as lazy
19:39:35 <roconnor> @type interact
19:39:36 <lambdabot> (String -> String) -> IO ()
19:39:52 <roconnor> main = interact brainfuck
19:40:00 <dpratt71> Cale: I'm not sure I want to take the time to write all that in C# ;)
19:40:03 <Ralith> @src id
19:40:03 <lambdabot> id x = x
19:40:26 <dpratt71> thanks for the help folks, lambdabot
19:40:43 <defun> Hi. I just solved problem 2 on project euler. Here is my correct solution: (http://hpaste.org/14044)   Here is my initial, but wrong solution: (http://hpaste.org/14045). I would like to know why that one is wrong. Thanks.
19:40:47 <gwern> @seen dcoutts
19:40:48 <lambdabot> dcoutts is in #haskell, #haskell-soc, #gentoo-haskell, #darcs, #ghc and #haskell-overflow. I last heard dcoutts speak 30m 51s ago.
19:41:10 <mauke> defun: "maximun" undeclared
19:41:18 <defun> ?
19:41:25 <ddarius> Look closer
19:41:26 <gwern> @ask dcoutts what happened to GPLib on hackage? I know I uploaded it, it's in the log (Thu Feb  8 03:59:01 UTC 2008 GwernBranwen GPLib 0.0), but it doesn't show in cabal list or the pkg list page
19:41:26 <lambdabot> Consider it noted.
19:41:51 <roconnor> oh, there is a Hayoo! link in hackage
19:41:53 <defun> mauke: what do you mean maximum undeclared?
19:41:54 <roconnor> that is great
19:41:59 <roconnor> Hayoo is so hard to find
19:42:01 <mauke> defun: that's not what I said
19:42:10 <moozilla> which is more effecient using bytestrings or normal strings with printf?
19:42:21 <roconnor> don't use printf :)
19:42:39 <moozilla> why does the tutorial bot use printf :P
19:42:47 <roconnor> where?
19:42:52 <defun> oh!
19:42:59 <mauke> preflex uses (something like) printf
19:43:01 <chessguy> @hoogle delete
19:43:01 <lambdabot> Data.HashTable delete :: HashTable key val -> key -> IO ()
19:43:01 <lambdabot> Data.IntMap delete :: Key -> IntMap a -> IntMap a
19:43:01 <lambdabot> Data.IntSet delete :: Int -> IntSet -> IntSet
19:43:10 <defun> thanks.
19:43:14 <chessguy> @hoogle a -> [a] -> [a]
19:43:15 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
19:43:15 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
19:43:15 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
19:43:31 <moozilla> write :: Handle -> String -> String -> IO ()
19:43:32 <moozilla> write h s t = do
19:43:32 <moozilla> hPrintf h "%s %s\r\n" s t
19:43:32 <moozilla> printf "> %s %s\n" s t
19:43:45 <gwern> @ask kowey btw, hackage libGenI fails with 6.10, but darcs libGenI is fine. time for another hackage upload?
19:43:45 <lambdabot> Consider it noted.
19:43:45 <moozilla> roconnor ^
19:44:05 <cknapp> What a wonderful line of code: (.:) = (.) . (.)
19:45:09 <roconnor> moozilla: lemme remove that :P
19:45:19 <defun> I've changed it to the correct spelling, but now I get a compile error: (http://hpaste.org/14046)
19:45:29 <moozilla> roconnor i would love to see the version that doesn't use it
19:45:41 <moozilla> i'm trying to learn how to properly code an irc bot in haskell :P
19:45:55 <mauke> defun: maximum takes a list. x is an Integer
19:45:57 <roconnor> damn it dons and his printfing
19:46:28 <ddarius> moozilla: Learn the banjo instead.
19:46:34 <moozilla> :P
19:46:37 <roconnor> printf    "> %s %s\n" s t  becomes  putStrLn ("> "++s++" "++t)
19:46:41 <defun> oh, I see.
19:46:49 <defun> ok, never mind then.
19:46:51 <defun> thanks.
19:46:55 <moozilla> i love haskell and so far an irc bot is the only project i can constantly work on
19:46:57 <ddarius> moozilla: It's probably more gratifying and fun.
19:46:59 <moozilla> at the level i'm at
19:47:16 <roconnor> and hPrintf h "%s %s\r\n" s t  becomes hPutStr (s++" "++t++"\r\n") -- here I'm assuming it is important to get the \r\n stuff right
19:47:34 <mauke> \r\n is never right
19:47:41 <cknapp> :)
19:47:56 <roconnor> mauke: okay, well someone who understand IRC protocol will have to comment on the \r\n
19:48:02 <roconnor> cause I don't know
19:48:04 <mauke> it's \013\010
19:48:07 <moozilla> i need to re-read the RFC
19:48:24 <roconnor> mauke: that sounds more plausible
19:51:08 <cknapp> What would people say the current state of the fgl is?
19:58:02 <gwern> @hoogle currentModule
19:58:03 <lambdabot> Language.Haskell.TH currentModule :: Q String
19:58:03 <lambdabot> Language.Haskell.TH.Syntax currentModule :: Q String
19:58:03 <lambdabot> Language.Haskell.TH.Syntax qCurrentModule :: Quasi m => m String
19:58:08 <chessguy> err, what was the cute one-liner for getting all the pairs of a list, where (x,y) and (y,x) are the same?
19:58:33 <roconnor> filter (join (==)) ?
19:58:45 <roconnor> er
19:58:51 <chessguy> i don't think so
19:59:00 <roconnor> filter (uncurry (join (==))) ?
19:59:17 <roconnor> no wait
19:59:21 <chessguy> > filter (join (==)) [1,2,3]
19:59:22 <lambdabot>   [1,2,3]
19:59:25 <roconnor> filter (uncurry . (==)) ?
19:59:39 <roconnor> filter (uncurry (==)) ?
19:59:39 <chessguy> > filter (uncurry . (==)) [1,2,3]
19:59:41 <lambdabot>   Couldn't match expected type `b -> c' against inferred type `Bool'
19:59:43 <roconnor> I should stop guessing
19:59:55 <roconnor> [1,2,3] isn't a list of pairs
20:00:09 <chessguy> roconnor:  right, i want to get all the pairs from a list
20:00:16 <roconnor> ah
20:00:20 <roconnor> @quote aztec
20:00:20 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
20:00:33 <chessguy> @type zip`ap`tail
20:00:34 <lambdabot> forall b. [b] -> [(b, b)]
20:00:45 <chessguy> are you serious
20:00:48 <cknapp> Hahah
20:00:54 <Axman6> zipWith f `ap` tail is quite nice
20:00:55 <chessguy> > zip`ap`tail [1..3]
20:00:56 <roconnor> zip`ap`tail $ [1,2,3]
20:00:57 <lambdabot>   Couldn't match expected type `[a] -> [b]'
20:01:03 <roconnor> > zip`ap`tail $ [1,2,3]
20:01:05 <lambdabot>   [(1,2),(2,3)]
20:01:10 <roconnor> > (zip`ap`tail) [1,2,3]
20:01:12 <lambdabot>   [(1,2),(2,3)]
20:01:15 <Axman6> > zipWith (<=) `ap` tail [1..]
20:01:16 <lambdabot>   Couldn't match expected type `[a] -> [a]'
20:01:22 <chessguy> what happened to (1,3)
20:01:25 <Axman6> > (zipWith (<=)) `ap` tail [1..]
20:01:26 <lambdabot>   Couldn't match expected type `[a] -> [a]'
20:01:27 <Gracenotes> @hoogle a -> [(a, b)] -> [b]
20:01:27 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
20:01:27 <lambdabot> Data.Array.Base (!) :: (IArray a e, Ix i) => a i e -> i -> e
20:01:27 <lambdabot> Data.Array.IArray (!) :: (IArray a e, Ix i) => a i e -> i -> e
20:01:28 <CakeProphet> mconcat [Any True, Any False]
20:01:29 <Axman6> bah
20:01:31 <CakeProphet> > mconcat [Any True, Any False]
20:01:32 <lambdabot>   Any {getAny = True}
20:01:37 <Axman6> :t (zipWith (<=)) `ap` tail
20:01:38 <lambdabot> forall a. (Ord a) => [a] -> [Bool]
20:01:41 <roconnor> chessguy: oh, I only gave you consecuative pairs
20:01:45 <CakeProphet> > mconcat [All True, All False]
20:01:46 <Axman6> > (zipWith (<=)) `ap` tail $ [1..]
20:01:46 <lambdabot>   All {getAll = False}
20:01:47 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
20:01:58 <CakeProphet> hmmm... what's the purpose of Any and All?
20:02:03 <chessguy> @src Any
20:02:04 <lambdabot> Source not found. Wrong!  You cheating scum!
20:02:08 * chessguy hangs his head
20:02:14 <CakeProphet> > pure (Any True)
20:02:15 <lambdabot>       Ambiguous occurrence `pure'
20:02:15 <lambdabot>      It could refer to either `Control.Appl...
20:02:18 <roconnor> chessguy: i think I understand your question now
20:02:19 <Gracenotes> to prove that booleans can be monoids too?
20:02:25 <Gracenotes> re. purpose of Any/All
20:02:26 <CakeProphet> > Control.Applicative.pure (Any True)
20:02:27 <lambdabot>       No instance for (Show (f Any))
20:02:27 <lambdabot>        arising from a use of `show' at <...
20:02:35 <chessguy> Gracenotes:  we <3 monoids
20:02:53 <CakeProphet> are they used anywhere?
20:02:55 <Gracenotes> same with Product and Sum
20:03:01 <Gracenotes> you could possibly use them with a Writer
20:03:24 <ddarius> > zipWith drop [0..] . join (liftM2 (,)) $ [1,2,3]
20:03:25 <lambdabot>   Couldn't match expected type `[a]' against inferred type `(a2, a2)'
20:03:31 <chessguy> @hoogle [a] -> (a, a)
20:03:32 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
20:03:32 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
20:03:32 <lambdabot> Prelude divMod :: Integral a => a -> a -> (a, a)
20:03:43 <chessguy> @hoogle [a] -> [(a,a)]
20:03:43 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
20:03:43 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
20:03:43 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
20:03:46 <Gracenotes> CakeProphet: if you want to keep track of, say, whether an invariant was kept for any/all sub-operations of a larger operations
20:04:12 <Gracenotes> just tell (Any bool)
20:04:25 <CakeProphet> I've never used writer
20:04:28 <Gracenotes> *-s
20:04:30 <gnuvince_> @src forM
20:04:30 <lambdabot> forM = flip mapM
20:04:35 <ddarius> > concat . zipWith drop [0..] . (\xs -> [[(x,y) | x <- xs] | y <- xs]) $ [1,2,3]
20:04:37 <gnuvince_> @src mapM
20:04:37 <lambdabot>   [(1,1),(2,1),(3,1),(2,2),(3,2),(3,3)]
20:04:37 <lambdabot> mapM f as = sequence (map f as)
20:04:38 <CakeProphet> > Control.Applicative.pure id
20:04:39 <lambdabot>       No instance for (Show (f (a -> a)))
20:04:39 <lambdabot>        arising from a use of `show'...
20:04:44 <roconnor> (\l -> concat (zipWith (\x y -> map (x,) y) l (tails l))) [1,2,3]
20:04:47 <roconnor> > (\l -> concat (zipWith (\x y -> map (x,) y) l (tails l))) [1,2,3]
20:04:49 <lambdabot>   <no location info>: parse error on input `)'
20:04:55 <roconnor> > (\l -> concat (zipWith (\x y -> map (x,) y) l (tails l)) [1,2,3]
20:04:56 <lambdabot>   <no location info>: parse error on input `)'
20:05:03 <gnuvince_> @src sequence
20:05:03 <lambdabot> sequence []     = return []
20:05:03 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
20:05:03 <lambdabot> --OR
20:05:03 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
20:05:13 <Gracenotes> CakeProphet: a writer is kind of like a logger
20:05:24 <ddarius> roconnor: (x,) isn't legal syntax
20:05:34 <roconnor> > (\l -> concat (zipWith (\x y -> map ((,)x) y) l (tails l))) [1,2,3]
20:05:36 <lambdabot>   [(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
20:05:36 <roconnor> damn it
20:05:49 <Gracenotes> CakeProphet: running a writer yields two results, the actual result, and the stuff you logged
20:05:57 <CakeProphet> ah okay
20:06:01 <Gracenotes> the log has to be a monoid, so you can keep on adding stuff onto it
20:06:03 <ddarius> > concat (zipWith (map . (,)) `ap` tails $ [1,2,3]
20:06:04 <lambdabot>   <no location info>: parse error on input `;'
20:06:12 <ddarius> > concat (zipWith (map . (,))) `ap` tails $ [1,2,3]
20:06:14 <lambdabot>   Couldn't match expected type `[[a]]'
20:06:22 <Gracenotes> so, you can keep on adding an Any Bool and seeing if the end result is True or False
20:06:31 <roconnor> @pl (\l -> concat (zipWith (\x y -> map ((,)x) y) l (tails l)))
20:06:32 <lambdabot> join . ap (zipWith (map . (,))) tails
20:06:40 <Gracenotes> if it's True, that means it logged True at one point
20:06:53 <CakeProphet> > mappend (Any True) (Any False)
20:06:55 <lambdabot>   Any {getAny = True}
20:06:55 <Gracenotes> and for All Bool, True means that it logged True at all points
20:06:56 <roconnor> > concat . zipWith (map . (,))`ap`tails $ [1,2,3]
20:06:57 <lambdabot>       precedence parsing error
20:06:57 <lambdabot>          cannot mix `(.)' [infixr 9] and `ap' ...
20:06:59 <CakeProphet> ah okay
20:07:24 <CakeProphet> > mempty :: Any a
20:07:25 <lambdabot>       Kind error: `Any' is applied to too many type arguments
20:07:25 <lambdabot>      In the typ...
20:07:29 <roconnor> hey, lambdabot, I'm not mixing
20:07:31 <CakeProphet> > mempty :: Any
20:07:32 <ddarius> > (concat . zipWith (map . (,)))) `ap` tails $ [1,2,3]
20:07:32 <lambdabot>   Any {getAny = False}
20:07:33 <lambdabot>   <no location info>: parse error on input `)'
20:07:36 <roconnor> oh
20:07:39 <roconnor> that other .
20:07:41 <ddarius> > (concat . zipWith (map . (,))) `ap` tails $ [1,2,3]
20:07:42 <lambdabot>   Couldn't match expected type `[[a]]'
20:07:48 <roconnor> > concat . (zipWith (map . (,)))`ap`tails $ [1,2,3]
20:07:50 <lambdabot>       precedence parsing error
20:07:50 <lambdabot>          cannot mix `(.)' [infixr 9] and `ap' ...
20:07:55 <roconnor> > concat . (zipWith (map . (,))`ap`tails) $ [1,2,3]
20:07:56 <ddarius> Whatever, @pl had a nice one.
20:07:57 <lambdabot>   [(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
20:08:19 <CakeProphet> hmmm
20:08:36 <CakeProphet> > mempty :: (,)
20:08:38 <lambdabot>       `(,)' is not applied to enough type arguments
20:08:38 <lambdabot>      Expected kind `?', b...
20:08:43 <CakeProphet> > mempty :: (a,b)
20:08:44 <lambdabot>       Could not deduce (Monoid b, Monoid a) from the context ()
20:08:44 <lambdabot>        arisin...
20:08:48 <kmeyer> @hoogle Char -> Int
20:08:48 <lambdabot> Data.Char digitToInt :: Char -> Int
20:08:48 <lambdabot> Data.Char ord :: Char -> Int
20:08:48 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
20:08:52 <CakeProphet> > mempty :: (Bool,Bool)
20:08:53 <lambdabot>       No instance for (Monoid Bool)
20:08:54 <lambdabot>        arising from a use of `mempty' at ...
20:08:57 <kmeyer> > ord '5'
20:08:59 <lambdabot>   53
20:09:01 <roconnor> > mempty :: ((),())
20:09:01 <kmeyer> cool.
20:09:02 <Gracenotes> @src lookup
20:09:02 <lambdabot> lookup _key []          =  Nothing
20:09:02 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
20:09:02 <lambdabot>                         | otherwise = lookup key xys
20:09:03 <lambdabot>   ((),())
20:09:15 <CakeProphet> > mempty :: (Anyl,All)
20:09:16 <lambdabot>   Not in scope: type constructor or class `Anyl'
20:09:20 <CakeProphet> > mempty :: (Any,All)
20:09:22 <lambdabot>   (Any {getAny = False},All {getAll = True})
20:09:27 <CakeProphet> hmm... neat.
20:09:34 <chessguy> @type join . ap (zipWith (map . (,))) tails
20:09:35 <lambdabot> forall a. [a] -> [(a, a)]
20:09:56 <CakeProphet> > mappend (mempty :: (Any,All)) (Any True, All False)
20:09:58 <lambdabot>   (Any {getAny = True},All {getAll = False})
20:09:58 <Gracenotes> @instances Monoid
20:09:59 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
20:10:14 <CakeProphet> that's kind of useful.
20:10:16 <CakeProphet> I guess.
20:10:17 <roconnor> > mempty :: (Any,All,Ord)
20:10:18 <lambdabot>       Class `Ord' used as a type
20:10:18 <lambdabot>      In the type `Ord'
20:10:18 <lambdabot>      In the type `(An...
20:10:24 <roconnor> > mempty :: (Any,All,Ordering)
20:10:26 <lambdabot>   (Any {getAny = False},All {getAll = True},EQ)
20:10:34 <CakeProphet> > mappend EQ GT
20:10:36 <lambdabot>   GT
20:10:41 <CakeProphet> > mappend LT GT
20:10:42 <lambdabot>   LT
20:10:48 <CakeProphet> > mappend GT LT
20:10:49 <lambdabot>   GT
20:10:54 <CakeProphet> ...weird.
20:11:08 <Gracenotes> the Ordering monoid is a bit weird
20:11:13 <roconnor> CakeProphet: returns the leftmost unless it is EQ, then moves down a notch
20:11:14 <Gracenotes> > mconcat $ map Sum [1..5]
20:11:15 <chessguy> @type join . ap (zipWith (map . (,))) tails
20:11:15 <lambdabot>   Sum {getSum = 15}
20:11:16 <lambdabot> forall a. [a] -> [(a, a)]
20:11:20 <chessguy> strange, that doesn't typecheck in my code
20:11:21 <roconnor> CakeProphet: is is really really useful
20:11:30 <roconnor> CakeProphet: imagine comparing version numbers
20:11:36 <roconnor> separated by dots
20:11:37 <Gracenotes> CakeProphet: Cale also explains the ordering monoid here: http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx
20:11:50 <ddarius> It's just lexicographical ordering.
20:12:11 <kmeyer> @hoogle isEOF
20:12:11 <lambdabot> System.IO isEOF :: IO Bool
20:12:12 <lambdabot> System.IO.Error isEOFError :: IOError -> Bool
20:12:12 <lambdabot> System.IO.Error isEOFErrorType :: IOErrorType -> Bool
20:12:40 <CakeProphet> mappend (Dual 1) (Dual 2)
20:12:43 <CakeProphet> > mappend (Dual 1) (Dual 2)
20:12:44 <lambdabot>   Add a type signature
20:12:45 <ddarius> roconnor: Or just the digits of a number, or just letters of a word...
20:12:52 <CakeProphet> > mappend (Dual 1) (Dual 2) :: Dual Int
20:12:53 <lambdabot>       No instance for (Monoid Int)
20:12:53 <lambdabot>        arising from a use of `mappend' at ...
20:13:08 <CakeProphet> Dual a where a is a Monoid then?
20:13:13 <ddarius> Yes.
20:13:26 <roconnor> > mconcat (zipWith compare "Alice" "Ant")
20:13:28 <lambdabot>   LT
20:13:34 <CakeProphet> > mappend (Dual (Any True)) (Dual (Any False)) :: Dual Any
20:13:35 <lambdabot>   Dual {getDual = Any {getAny = True}}
20:13:41 <ddarius> chessguy: Are you sure it doesn't type check as oppose to complaining about a missing instance?
20:13:41 <chessguy> @pl pairs xs = concat (zipWith (\x y -> map ((,)x) y) xs (tails xs))
20:13:42 <lambdabot> pairs = join . ap (zipWith (map . (,))) tails
20:13:49 <CakeProphet> ...so what is Dual doing?
20:14:04 <ddarius> Dual a `mappend` Dual b = Dual (b `mappend` a0
20:14:14 <roconnor> @check (\x y -> mconcat (zipWith compare x y) == compare x (y::String))
20:14:15 <lambdabot>   "Falsifiable, after 0 tests:\n\"\"\n\"\\116270\\21236\\429743\"\n"
20:14:44 <CakeProphet> ddarius:  what's the benefit then
20:14:51 <chessguy> ddarius:  Could not deduce (Monad ((->) [a])) from the context ()
20:14:57 <ddarius> CakeProphet: What do you mean?
20:15:08 <ddarius> chessguy: You need to import Control.Monad.Instances.
20:15:09 <kmeyer> @hoogle Int -> Char
20:15:09 <lambdabot> Data.Char chr :: Int -> Char
20:15:09 <lambdabot> Data.Char intToDigit :: Int -> Char
20:15:09 <lambdabot> Data.ByteString.Char8 index :: ByteString -> Int -> Char
20:15:24 <CakeProphet> ddarius:  I'm not sure why Dual exists, basically.
20:15:40 <roconnor> > intToDigit 10
20:15:40 <chessguy> aha
20:15:42 <lambdabot>   'a'
20:15:55 <roconnor> > intToDigit 15
20:15:57 <lambdabot>   'f'
20:16:20 <CakeProphet> > (mappend (+3) (*5)) 5
20:16:21 <lambdabot>   Add a type signature
20:16:44 <ddarius> CakeProphet: It flips a monoid around.  For commutative monoids like Sum, Any, All, Product it makes no difference.  For non-commutative monoids like [a], Endo, Ordering, First, Last, Maybe it leads to different behavior that is often useful.
20:16:52 <ddarius> E.g. First = Dual Last (or vice versa)
20:17:12 <CakeProphet> > (mappend (+3) (*5) :: (Int->Int)) 5
20:17:13 <lambdabot>       No instance for (Monoid Int)
20:17:13 <lambdabot>        arising from a use of `mappend' at ...
20:17:18 <CakeProphet> ddarius:  ah okay.
20:17:27 <CakeProphet> hmmm
20:17:56 <CakeProphet> > (mappend Any All)
20:17:57 <lambdabot>   Couldn't match expected type `Any' against inferred type `All'
20:18:04 <CakeProphet> oh, right.
20:18:27 <CakeProphet> > (mappend Any mempty)
20:18:28 <lambdabot>       Overlapping instances for Show (Bool -> Any)
20:18:28 <lambdabot>        arising from a use ...
20:18:36 <CakeProphet> > (mappend Any mempty) False
20:18:37 <lambdabot>   Any {getAny = False}
20:18:42 <CakeProphet> > (mappend Any mempty) True
20:18:43 <lambdabot>   Any {getAny = True}
20:18:48 <CakeProphet> composition basically?
20:19:00 <CakeProphet> hmmm
20:19:04 <CakeProphet> no.
20:19:14 <CakeProphet> couldn't be
20:19:29 <ddarius> CakeProphet: That's the monoid instance for Monoid b => Monoid (a -> b) whose definition you should be able to figure out from the type.
20:19:29 <kmeyer> zipWith is basically a map2, right?
20:19:36 <ddarius> kmeyer: Yes.
20:19:46 <ddarius> kmeyer: Now what is map0?
20:19:58 <CakeProphet> ddarius:  no. Definitions are never obvious to me based on type alone. too many things it could possibly do.
20:20:14 <int80_h> http://hpaste.org/14047
20:20:30 <ddarius> CakeProphet: There are only two natural definitions in this case and out of those two one is more natural than the other.
20:20:32 <int80_h> having a little trouble with implementing the graham scan algorithm problem from RWH, chapter 3
20:20:56 <CakeProphet> ddarius:  ...no.
20:21:29 <CakeProphet> basically all it says to me is that constructors for Monoids are also monoids.
20:21:49 <int80_h> could someone check out my code? http://hpaste.org/14047
20:21:54 <ddarius> That's not what it says at all.  It says that functions into a monoid are monoids.
20:22:03 <cknapp> int80_h: I'm looking.
20:22:11 <cknapp> I don't know how much help I'll be.
20:22:14 <CakeProphet> ddarius:  that's the same thing.
20:22:19 <kmeyer> ddarius: um... id?
20:22:29 <ddarius> kmeyer: No.
20:22:39 <CakeProphet> :t Any
20:22:39 <kmeyer> empty list?
20:22:40 <lambdabot> Bool -> Any
20:22:57 <int80_h> cknapp: thanks for looking :)
20:23:01 <kmeyer> :t map
20:23:02 <ddarius> kmeyer: If map :: (a -> b) -> [a] -> [b] and zipWith :: (a -> b -> c) -> [a] -> [b] -> [c] what type should map0 have?
20:23:02 <Axman6> @src (a -> b) mappend
20:23:02 <lambdabot> Source not found. I've seen penguins that can type better than that.
20:23:02 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:23:31 <kmeyer> map0 :: a -> [a]?
20:23:35 <ddarius> CakeProphet: a -> b is -any- function.
20:23:39 <ddarius> kmeyer: Correct.
20:23:45 <kmeyer> what would that even do?
20:23:48 <CakeProphet> ddarius:  correct. except it's not because of the class constraint.
20:24:02 <mmorrow> (m -> m -> m) -> ((a->m) -> (a->m) -> (a -> m))
20:24:04 <ddarius> kmeyer: There are only a few natural definitions for that function.
20:24:12 <CakeProphet> we're basically saying the same thing, I've just broadened my definition of "constructor" to be any function that returns a Monoid.
20:24:25 <cknapp> int80_h: can you provide all the relevant code?
20:24:32 <kmeyer> > let map0 a = a : map0 a in map0 5
20:24:34 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
20:24:35 <mmorrow> \(<>) f g -> (\a -> f a <> g a)
20:24:35 <ddarius> Only one of them makes sense in the series zipWith0, zipWith1=map, zipWith2 = zipWith, zipWith3, ...
20:24:40 <ddarius> kmeyer: Correct.
20:24:49 <ddarius> kmeyer: Or using library functions, map0 = repeat.
20:24:50 <CakeProphet> ddarius:  but can you just tell me what mappend with (a->b) does? No, it's not obvious.
20:24:56 <int80_h> cknapp: figured I did, but I'll paste in the entire file
20:25:02 <mmorrow> CakeProphet: \(<>) f g -> (\a -> f a <> g a)
20:25:08 <kmeyer> ddarius: ah.
20:25:11 <ddarius> (f `mappend g) x = f x `mappend` g x
20:25:13 <cknapp> thanks: It's nice to have a context to work with
20:25:14 <Gracenotes> @hoogle Num a => (a, a) -> [a]
20:25:14 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
20:25:14 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
20:25:14 <lambdabot> Prelude snd :: (a, b) -> b
20:25:16 * kmeyer isn't intimately familiar with the library yet
20:25:52 * kmeyer believes he has managed to grasp the difference between IO actions and functions, but general monads elude him
20:25:59 <CakeProphet> > mempty :: (Bool->Any)
20:26:00 <lambdabot>       Overlapping instances for Show (Bool -> Any)
20:26:00 <lambdabot>        arising from a use ...
20:26:06 <CakeProphet> mempty = id?
20:26:13 <int80_h> cknapp: I made some changes to the input, but here's the whole file plus new input
20:26:13 <ddarius> mempty = const mempty
20:26:14 <CakeProphet> er...
20:26:16 <mmorrow> Cake: it just feeds the arg to each function, then uses the mappend for he result type to turn those two results into a single result
20:26:20 <ddarius> id wouldn't type check
20:26:29 <CakeProphet> right.
20:26:49 <CakeProphet> > (mempty :: (Bool->Any)) False
20:26:51 <lambdabot>   Any {getAny = False}
20:27:30 <CakeProphet> > (mempty :: (Int->Any)) 4
20:27:31 <lambdabot>   Any {getAny = False}
20:27:32 <cknapp> int80_h: where?
20:27:35 <CakeProphet> ...wat
20:27:39 <CakeProphet> how does it determine that.
20:27:42 <CakeProphet> > (mempty :: (Int->Any)) 10
20:27:43 <lambdabot>   Any {getAny = False}
20:27:44 <CakeProphet> > (mempty :: (Int->Any)) 10
20:27:46 <lambdabot>   Any {getAny = False}
20:27:49 <CakeProphet> > (mempty :: (Int->Any)) 0
20:27:51 <lambdabot>   Any {getAny = False}
20:27:52 <mmorrow> > return 42 :: IO Double
20:27:53 <lambdabot>   * Exception: "<IO Double>"
20:27:57 <mmorrow> > return 42 :: [Int]
20:27:58 <lambdabot>   [42]
20:28:01 <mmorrow> > return 42 :: Just Float
20:28:02 <lambdabot>   Not in scope: type constructor or class `Just'
20:28:07 <mmorrow> > return 42 :: Maybe Float
20:28:08 <mmorrow> heh
20:28:09 <lambdabot>   Just 42.0
20:28:35 <cknapp> ?
20:28:37 <CakeProphet> I'm guessing mempty :: (a->b) = mempty :: b
20:28:40 <cknapp> mmorrow: why?
20:28:48 <int80_h> cknapp: http://hpaste.org/14047#a1
20:28:49 <mmorrow> cknapp: why what?
20:28:59 <CakeProphet> er...
20:29:00 <CakeProphet> oh okay
20:29:04 <cknapp> the typing
20:29:11 <Ralith> @src foldl`
20:29:11 <lambdabot> Source not found. Do you think like you type?
20:29:13 <Ralith> @src foldl'
20:29:13 <lambdabot> foldl' f a []     = a
20:29:13 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
20:29:15 <CakeProphet> mempty :: (a->b) = const (mempty :: b)
20:29:16 <ddarius> CakeProphet: Since mempty is simpler and it's definition is -uniquely- determined by the type and monoid laws, let's look at it.  mempty :: Monoid b => a -> b in this instance.  The (->) means mempty must be of the form mempty = \x -> ..., the fact that the type variable 'a' is not used anywhere else means we can't use 'x' for anything so mempty = \_ -> ..., the ... has type Monoid b => b, there's only one way to get a va
20:29:16 <ddarius> lue of that type namely mempty for it, so mempty = \_ -> mempty.
20:29:40 <mmorrow> cknapp: the compiler selects which "return" to use based on the type for that "return"
20:29:52 <mmorrow> this is the whole idea behind type classes
20:29:58 <cknapp> Ah.
20:30:02 <ddarius> (Actually, the definition is uniquely determined by the types in this case even ignoring the laws (modulo undefined))
20:30:25 <int80_h> cknapp: did you get the url?
20:30:34 <CakeProphet> ddarius:  -shrug- it's just never obvious to me what a function does based on type.
20:30:39 <cknapp> Yeah. Sorry, I'm tired and being distracted by like 4 things...
20:30:45 <cknapp> It'll be a minute. :)
20:30:57 <mmorrow> cknapp: usually you don't need to give an explicit type sig because the type is determined by the surrounding context
20:31:16 <int80_h> cknapp: no worries.
20:31:17 <ddarius> CakeProphet: It's a skill you should develop.  Types can say a lot about a value and you can read guarantees off just from the type.
20:31:45 <cknapp> CakeProphet: it is indeed a useful skill
20:31:46 <ddarius> In some cases, such as mempty, you can read the entire definition off from the type.  This means that if you were implementing it, you wouldn't even need to think.
20:32:22 <ddarius> @djinn-add class Monoid m where mempty :: m; mappend :: m -> m -> m
20:32:45 <ddarius> @djinn Monoid b => a -> b
20:32:45 <lambdabot> f _ = mappend mempty mempty
20:32:56 <ddarius> Which from the monoid laws is f _ = mempty
20:33:11 <ddarius> (so I guess you do need the monoid laws)
20:33:23 <CakeProphet> > mappend (Endo (+4)) (Endo (+5))
20:33:24 <lambdabot>       No instance for (Show (Endo a))
20:33:24 <lambdabot>        arising from a use of `show' at ...
20:33:45 <CakeProphet> > appEndp (mappend (Endo (+4)) (Endo (+5))) 5
20:33:46 <lambdabot>   Not in scope: `appEndp'
20:33:49 <CakeProphet> > appEndo (mappend (Endo (+4)) (Endo (+5))) 5
20:33:50 <Axman6> @src Endo
20:33:51 <lambdabot> Source not found. You speak an infinite deal of nothing
20:33:51 <lambdabot>   14
20:33:57 <ddarius> @djinn (Monoid a, Monoid b) => (a,b)
20:33:57 <lambdabot> f = (mappend mempty mempty, mappend mempty mempty)
20:33:57 <dolio> The monoid laws at least tell you that all the crap you can do like that ammounts to the same function.
20:34:02 <CakeProphet> composition?
20:34:03 <gio123> what the word inlining, means?
20:34:31 <mmorrow> (mempty,mappend,Type) ==> (0,(+),Num), (1,*,Num), ([],(++),[a]), (id,(.),(a->a)), ...
20:34:44 <andyjgill> Does anyone have a hackage recommendation for reading and writing images?
20:34:56 <dolio> For mappend you can get different functions, but one is 'obviously correct'.
20:34:58 <CakeProphet> > appEndo (mappend (Endo (+a)) (Endo (+b))) c
20:34:59 <lambdabot>   c + b + a
20:35:02 <mmorrow> andyjgill: there's an imagemagick binding that looks nie
20:35:05 <mmorrow> *nice
20:35:06 <Axman6> gio123: i think it means that if you've inlined f, then all occurances of f will be replaced with the definition of f
20:35:13 <CakeProphet> > appEndo (mappend (Endo (f a)) (Endo (f b))) c
20:35:15 <lambdabot>   f a (f b c)
20:35:18 <CakeProphet> ...sweet.
20:35:21 <mmorrow> i haven't used it though, although i've used imagemagick a bunch and it's great
20:35:50 <mmorrow> (but just for reading/writing images it might not be what you're looking for)
20:36:07 <andyjgill> mmorrow: the hsmagick package?
20:36:09 <CakeProphet> no clue why you would ever need Endo, but it's neat nontheless.
20:36:19 <mmorrow> andyjgill: yes
20:36:27 <andyjgill> thanks for the pointer.
20:36:31 <mmorrow> np
20:36:47 <CakeProphet> it would make more sense to define Monoid (a->a)  instead of Monoid (Endo (a->a)) I think
20:36:55 <CakeProphet> I could be missing something though
20:37:28 <dolio> Not Endo (a -> a), Endo a.
20:37:33 <dolio> Endo a = a -> a
20:37:56 <CakeProphet> ambiguous with (Monoid b) => Monoid (a->b) maybe?
20:38:11 <CakeProphet> if a = b
20:38:15 <chessguy> hey, i look like i'm programming in a functional language again: http://hpaste.org/14042#a3
20:38:54 <CakeProphet> :t Id
20:38:55 <lambdabot> Not in scope: data constructor `Id'
20:39:49 <dolio> "instance Monoid (a -> a) ..." isn't actually allowed by Haskell 98.
20:39:54 <dolio> It requires FlexibleInstances.
20:39:57 <CakeProphet> What's an Applicative that's also not a Monad?
20:40:11 <Axman6> @instances Applicative
20:40:12 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
20:40:16 <dolio> ZipList.
20:40:33 <gwern> @tell dcoutts likewise, 'blockio' seems to be missing from hackage
20:40:33 <lambdabot> Consider it noted.
20:40:35 <CakeProphet> :t ZipList
20:40:37 <lambdabot> forall a. [a] -> ZipList a
20:40:44 <Axman6> chessguy: what is that anyway?
20:40:54 <Axman6> @src ZipList
20:40:54 <lambdabot> Source not found. Maybe you made a typo?
20:40:59 <chessguy> Axman6:  guts of an inference engine
20:41:07 <Axman6> @hoogle ZipList
20:41:07 <lambdabot> Control.Applicative newtype ZipList a
20:41:07 <lambdabot> Control.Applicative ZipList :: [a] -> ZipList a
20:41:07 <lambdabot> Control.Applicative getZipList :: ZipList a -> [a]
20:41:15 <CakeProphet> > pure 5 :: ZipList Int
20:41:16 <lambdabot>       Ambiguous occurrence `pure'
20:41:16 <lambdabot>      It could refer to either `Control.Appl...
20:41:22 <dolio> pure = repeat, fs <*> xs = zipWith ($) fs xs
20:41:23 <gwern> @tell dcoutts ...and 'child'
20:41:23 <lambdabot> Consider it noted.
20:41:25 <CakeProphet> > Control.Applicative.pure 5 :: ZipList Int
20:41:26 <lambdabot>       No instance for (Show (ZipList Int))
20:41:26 <lambdabot>        arising from a use of `show...
20:41:39 <CakeProphet> ah okay.
20:42:13 <dolio> Anyhow, you can write a monad instance such that it gives you the correct ap.
20:42:26 <dolio> But I think it violates the monad laws.
20:43:02 <int80_h> hey, could someone take a peek at my partial attempt at the graham scan algorithm exercise from RWH? http://hpaste.org/14047#a1
20:43:02 <CakeProphet> > (ZipList [(+3),(+4),(+5)]) <*> (Ziplist [7,6,5])
20:43:03 <lambdabot>   Not in scope: data constructor `Ziplist'
20:43:10 <CakeProphet> > (ZipList [(+3),(+4),(+5)]) <*> (ZipList [7,6,5])
20:43:11 <lambdabot>       No instance for (Show (ZipList a))
20:43:11 <lambdabot>        arising from a use of `show' ...
20:43:18 <dolio> It only works if things are set up so that, from a join perspective, all your ZipList (ZipList a) are square.
20:43:39 <Axman6> @instances Show
20:43:39 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
20:43:41 <CakeProphet> > getZipList ((ZipList [(+3),(+4),(+5)]) <*> (ZipList [7,6,5]))
20:43:42 <lambdabot>   [10,10,10]
20:44:04 <chessguy> Axman6:  the idea is that you can feed it logical statements, and ask it to deduce new ones
20:44:16 <Axman6> ah fair enough.
20:44:47 <cknapp> int80_h, I'm not quite sure what the problem is... The problem is the patter matching for 'insert'... so maybe Haskell doesn't allow patterns after a where? That doesn't sound right.
20:45:01 <cknapp> Anyway, there's an easier way to sort... check Data.List.sortBy
20:45:35 <Olathe> @type sortBy
20:45:36 <int80_h> chnapp: this is an exercise out of a book. I have to pick "lesson in haskell patterns" over "easier way to do it".
20:45:36 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
20:45:59 <Olathe> int80_h: Why not sortBy (comparing snd) ?
20:46:02 <int80_h> chknapp: if I did it the easy way, I'd be missing the point of the exercise.
20:46:07 <Olathe> @type comparing snd
20:46:08 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Ordering
20:46:23 <int80_h> olathe: haven't covered sortBy yet.
20:46:31 <Olathe> Ahh.
20:46:54 <CakeProphet> > 5 (<5) [1..10]
20:46:55 <lambdabot>       No instance for (Num ((a -> Bool) -> [t] -> a1))
20:46:55 <lambdabot>        arising from th...
20:47:02 <CakeProphet> > 5 (<$) [1..10]
20:47:03 <lambdabot>       No instance for (Num ((a -> f b -> f a) -> [t] -> a1))
20:47:03 <lambdabot>        arising f...
20:47:05 <CakeProphet> weird typo
20:47:10 <cknapp> int80_h: not necessarily; the easier way is a better way. But, figuring out what's going on, and then rewriting the better way is the more effective way, overall: you learn what was wrong, and you learn better Haskell style.
20:47:18 <CakeProphet> > 5 <$ [1..10]
20:47:19 <lambdabot>   [5,5,5,5,5,5,5,5,5,5]
20:47:22 <int80_h> cknapp: patterns are allowed after a where statement. In a pervious attempt, it took my input, but gave me the wrong output
20:47:37 <cknapp> int80_h: yeah; it didn't seem right...
20:47:50 <cknapp> But I have no idea... wait..
20:47:57 <cknapp> let me think for a second, I may have found it.
20:48:28 <int80_h> cknapp: cool. Let me know your thought process. I'm trying to figure out how to troubleshoot haskell code more than solving this particular problem.
20:48:39 <CakeProphet> :t [::]
20:48:40 <lambdabot> parse error on input `::'
20:48:49 <ddarius> CakeProphet: Yes the Endo instance very much overlaps with the function instance.  It used to be, though, that the function instance was the (a -> a) one, but they changed that a bit back.
20:48:54 <cknapp> The problem is with the pattern match on "insert"
20:48:59 <cknapp> I assume, it's with some wild base case.
20:49:16 <ddarius> Also, Endo is rather handy, albeit less so with the newtype wrapper required now.
20:49:20 <Olathe> > let sort' [] = []; sort' [a] = [a]; sort' (a:as) = insert (sort' as) where insert [] = [a]; insert (b:bs) = if snd a <= snd b then a:b:bs else b:insert bs in sort' $ zip [1..5] [11..15]
20:49:22 <lambdabot>   [(1,11),(2,12),(3,13),(4,14),(5,15)]
20:49:32 <int80_h> cknapp: where insert [] = [a] is the problem?
20:49:35 <ddarius> CakeProphet: One example, DList could be defined simply as type DList a = Endo [a]
20:49:37 <CakeProphet> there's a Functor [::] instance...
20:49:39 <Olathe> > let sort' [] = []; sort' [a] = [a]; sort' (a:as) = insert (sort' as) where insert [] = [a]; insert (b:bs) = if snd a <= snd b then a:b:bs else b:insert bs in sort' $ zip [1..5] [11,15,13,12,14]
20:49:41 <lambdabot>   [(1,11),(4,12),(3,13),(5,14),(2,15)]
20:50:00 <CakeProphet> ddarius:  never used Dlist
20:50:03 <Olathe> > let sort' [] = []; sort' [a] = [a]; sort' (a:as) = insert (sort' as) where insert [] = [a]; insert (b:bs) = if snd a <= snd b then a:b:bs else b:insert bs in sort' [(1,2),(2,3),(4,1),(5,9)]
20:50:05 <lambdabot>   [(4,1),(1,2),(2,3),(5,9)]
20:50:24 <ddarius> CakeProphet: You may well have used the trick it captures.
20:50:24 <CakeProphet> what is [::]...
20:50:24 <dolio> sort = foldr insert []
20:50:25 <Olathe> Ahh, I see.
20:50:28 <ddarius> CakeProphet: Also see ShowS
20:50:33 <cknapp> int80_h: maybe... that doesn't seem wrong; but the recursive call might not drop it's way down to that case properly...
20:50:41 <Olathe> int80_h: Your sort by tangents insert thing is flawed.
20:50:58 <Olathe> int80_h: What if it gets [a] ?
20:51:05 <int80_h> Olathe: yeah I got that far. ;)
20:51:11 <Axman6> CakeProphet: parallel arrays?
20:51:14 <int80_h> ooh...hmm
20:51:33 <Olathe> int80_h: It can handle empty lists and lists with more than one element, I think.
20:51:38 <chessguy> haha, apparently the 'pairs' function he hacked up has unintended side effects on lists of lists :)
20:51:47 <cknapp> There it is.
20:51:52 <cknapp> Wow... I'm blind.
20:51:53 <chessguy> @let pairs = join . ap (zipWith (map . (,))) tails
20:51:54 <gwern> @seen Cale
20:51:54 <int80_h> cknapp: what?
20:51:55 <CakeProphet> Axman6:  how do you construct them.
20:51:56 <lambdabot>  Defined.
20:51:56 <lambdabot> Cale is in #haskell, #ghc and #haskell-overflow. I last heard Cale speak 1h 12m 46s ago.
20:52:04 <cknapp> what Olathe said
20:52:05 <chessguy> > pairs [1,2,3]
20:52:07 <lambdabot>   [(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
20:52:15 <sclv> ?ty pairs
20:52:16 <cknapp> You have no case for insert [a]
20:52:16 <lambdabot> forall a. [a] -> [(a, a)]
20:52:22 <gwern> @tell Cale I'm doing a minor release of lambdabot so as to get a version with the proper haskell-src-exts dep onto hackage
20:52:22 <lambdabot> Consider it noted.
20:52:26 <gwern> @flush
20:52:27 <chessguy> > pairs [[1,2],[3]]
20:52:29 <lambdabot>   [([1,2],[1,2]),([1,2],[3]),([3],[3])]
20:52:34 <chessguy> !!
20:52:51 <Olathe> @type (!!!)
20:52:53 <lambdabot> Not in scope: `!!!'
20:52:57 <ddarius> chessguy: ?
20:52:59 <sclv> chessguy: huh?
20:53:05 <Axman6> CakeProphet: [:a,b,c:]? they also have a cons thing, but i forget what it is...
20:53:15 <int80_h> okay, trying code with the additional case
20:53:20 <chessguy> oh wait
20:53:23 <chessguy> that IS right
20:53:26 <CakeProphet> Axman6:  hmmm... I've never seen that before.
20:53:40 <int80_h> this is the new case I added
20:53:42 <ddarius> chessguy: It's parametric, it can't be wrong unless GHC is producing bad code.
20:53:44 <Axman6> CakeProphet: you can use [:x:] +:+ xs
20:53:49 <sclv> according to the type signature, it has to be. :-)
20:53:54 <int80_h>  insert [a] = [a]
20:54:00 <gwern> @seen byorgey
20:54:00 <lambdabot> byorgey is in #haskell-blah, #xmonad and #haskell. I last heard byorgey speak 7h 24m 6s ago.
20:54:02 <int80_h> but I still get the same error
20:54:07 <CakeProphet> > [:1:]
20:54:08 <lambdabot>   <no location info>: parse error on input `]'
20:54:42 <CakeProphet> > [:1,2,3:]
20:54:44 <lambdabot>   <no location info>: parse error on input `]'
20:54:51 <Gracenotes> I'm trying to implement the four cardinal directions using an Enum and succ/pred for rotation, with a special case for wrapping around from maxBound to minBound. Is there a better way to implement this...?
20:54:51 <chessguy> i didn't say it was producing the wrong type
20:55:03 <sclv> , > [: 1,2,3 :]
20:55:05 <lunabot>  luna: No instance for (GHC.Show.Show ([:t:] -> GHC.Bool.Bool))
20:55:10 <sclv> , [: 1,2,3 :]
20:55:11 <lunabot>  [:1,2,3:]
20:55:22 <sclv> lunabot >>> lambdabot
20:55:23 <ddarius> chessguy: I'm saying if it behaved correctly on Int, it must behave correctly on all types, not that it was producing the wrong type.
20:55:29 <bos> @seen dons
20:55:30 <lambdabot> dons is in #concatenative, #arch-haskell, #ghc, #xmonad, #darcs and #haskell. I last heard dons speak 1h 50m 39s ago.
20:55:31 <CakeProphet> what's the difference between [::] and []?
20:55:32 <Gracenotes> I suppose not.
20:55:44 <int80_h> cknapp: added new case "insert [a] = [a]but I still get the same error
20:55:53 <CakeProphet> Gracenotes:  sort of breaks the rules of succ//pred, but it shouldn't matter.
20:56:21 <gwern> @ask byorgey Math.OEIS seems to fail on 6.10 because of a bad type sig (cm out, and the inferred type compiles). can you fix this with a hackage release?
20:56:21 <lambdabot> Consider it noted.
20:56:25 <chessguy> ddarius:  yeah, i thought it was performing differently because join or ap were seeing a different context
20:56:36 <Gracenotes> CakeProphet: I'm not redefining succ/pred. Just making rotate West -> North, and rotate d -> succ d
20:56:49 <cknapp> int80_h: try replacing [a] with [b]... you're shadowing an earlier definition, and possibly confusing it (at the very least, you'll confuse someone trying to read the code)
20:56:56 <ddarius> chessguy: pairs would have to have a context constraint in it's type for that to happen
20:56:57 <CakeProphet> Gracenotes:  you could make it a typeclass like Enum.
20:57:26 <sclv> [::] is a special type for arrays suitable for parallelized operation. new, experimental stuff. good to play with, not so good for production.
20:57:45 <Gracenotes> CakeProphet: the idea is to avoid writing out cases for North, East, South, and West
20:57:58 <Gracenotes> defining a special succ and pred would require 8 total cases
20:58:18 <chessguy> ddarius:  i'll take your word for it
20:58:20 <Gracenotes> and you know what they say about Haskell and laziness :)
20:58:28 <int80_h> cknapp: I replaced [a] with [b]. Still the same error.
20:58:29 <chessguy> @quote lazy
20:58:30 <lambdabot> malig says: quantum mechanics actually strikes me as less wierd than lazy evaluation sometimes. at least it disallows time travel
20:58:36 <cknapp> I figured...
20:58:47 <intoverflow> great quote
20:59:11 <gwern> hm, can't compile lb
20:59:25 <CakeProphet> , map (const mkStdGen) [:1,2,3:]
20:59:26 <gwern> ah who am I kidding. I'm going to upload anyway
20:59:27 <lunabot>  luna: Couldn't match expected type `[a]' against inferred type `[:a1:]'
20:59:34 <CakeProphet> , map (const newStdGen) [:1,2,3:]
20:59:35 <cknapp> int80_h: I hate to ask the obvious, but have you saved and reloaded? ;)
20:59:35 <lunabot>  luna: Couldn't match expected type `[a]' against inferred type `[:a1:]'
20:59:42 <int80_h> chnapp: specifically it looks like this insert [b] = [b]
20:59:57 <int80_h> cknapp: I've been caught that way before, but not this time.
21:00:02 <cknapp> :)
21:00:25 <sclv> CakeProphet: you can't use standard list operations on [::] -- its sugar for a special array structure.
21:00:30 <int80_h> that insert is right after the base case
21:00:55 <CakeProphet> sclv, I'm trying to find some case where parallel arrays would do something unexpected, but that requires state.
21:01:00 <cknapp> Actually... You don't need that singleton case: x:[] = [x]
21:01:15 <sclv> they don't do anything unexpected. by definition.
21:01:19 <gwern> @tell Cale also, it'd be good if you could push updated state/
21:01:19 <lambdabot> Consider it noted.
21:01:40 <CakeProphet> sclv:  well... a case where they would return a different value than their [] counterpart.
21:01:49 <sclv> they don't. by definition.
21:02:14 <CakeProphet> ...wat.
21:03:25 <sclv> the types of operations you can do with them are restricted such that operations with them may be parallelized arbitrarily and transparently.
21:03:40 <sclv> if you find an operation where this is not the case, then you have found a bug.
21:05:12 <int80_h> non-exhaustive patterns in function insert, but noone (including me) can spot it. I think I'll repost my albeit minor change
21:05:30 <cknapp> int80_h: I just realized this won't sort the whole list anyway... suppose you have [(1,1),(2,4),(2,3)] even if we find the bug, it won't sort that list.
21:05:41 <cknapp> It stops once it inserts 'a'
21:07:13 <int80_h> cknapp: I had that problem before. It wouldn't sort the list
21:07:29 <cknapp> Maybe the Haskell compiler is smart enough that it's giving you fake parse errors to trick you into fixing your code. :)
21:07:41 <int80_h> cknapp: would it help to post my previous verion that at least gave output, veven if it was wrong output
21:07:50 <cknapp> It may
21:08:35 <gwern> hm, mage isn't building. I wonder if cabal changed how it handled c wrappers
21:08:40 <int80_h> cknapp: oh crap!
21:08:48 <cknapp> ?
21:08:49 <int80_h> chnapp: I see what I was doing wrong
21:09:03 <int80_h> chnapp: I was saving one file and loading an older file
21:09:07 <cknapp> Ah.
21:09:17 <cknapp> Well, that would be the problem...
21:09:35 <int80_h> cknapp: okay let me start this over again
21:09:47 <cknapp> Human-computer relations are always interesting. :)
21:10:08 <roconnor> @vixen Human-computer relations are always interesting.
21:10:08 <lambdabot> how frequent is always?
21:10:22 <intoverflow> Suppose I define a function f x = x + 1.  Later, I evaluate (f 1) in several distinct places in my program (and I force the evaluation; say, print $ f 1).  Does Haskell memoize the result?  if not, is there a common trick to get it to?
21:10:42 <int80_h> chnapp: okay now we're back to the problem where it doesn't sort the whole list
21:10:50 <cknapp> what does @vixen do?
21:11:02 <roconnor> intoverflow: GHC doesn't typically memoize functions
21:11:04 <int80_h> cknapp: I'm going to look it over a minute, and if I can't figure it out I'll post my code
21:11:17 <jeffwheeler_> intoverflow: I want to say 'where' clauses do
21:11:24 <cknapp> Think about what happens when you put a back into the list.
21:11:31 <roconnor> intoverflow: we introduce sharing with let expressions
21:11:44 <roconnor> (or where clauses)
21:11:47 <cknapp> I can give you more if you'd like, or I can leave it at that.
21:11:47 <intoverflow> roconnor: sure, although this is a local thing
21:11:50 <mpeter> the mack is back
21:11:51 <roconnor> as jeff says
21:11:52 <wli> There should be easy ways to cache results. For instance, a hashtable with bounded collision chains whose overflow policy for the collision chains is to carry out LRU ejection.
21:11:52 <mpeter> doin good and lookin fly
21:12:06 <mpeter> how bout me and you and black
21:12:08 <mpeter> lemme take you from the back
21:12:11 <wli> However, you may need a monad to carry it out.
21:12:12 <mpeter> girl let me touch you theerree
21:12:13 <roconnor> intoverflow: you will often see global lists used to memoize
21:12:39 <jeffwheeler_> mpeter: ...?
21:12:51 <int80_h> troll, pay no nevermind
21:13:06 <roconnor> mpeter: you have to put @vixen before what you say
21:13:06 <mpeter> don't get me started int80_h
21:13:16 <int80_h> ooooh
21:13:36 <int80_h> @vixen the mack is back
21:13:36 <lambdabot> you are soooo interesting
21:13:44 <int80_h> hee hee
21:13:59 <int80_h> @vixen doin good and lookin fly
21:13:59 <lambdabot> good good
21:14:11 <cknapp> @vixen lazy evaluation
21:14:11 <lambdabot> Whatever
21:14:27 <int80_h> oooh cknapp strikes out with a vixenbot
21:14:40 <int80_h> that's going to be years of therapy right there ;)
21:15:13 <cknapp> I figured since it's in #haskell, it would give something witty there...
21:15:31 <jeffwheeler_> @vixen shouldn't everybody use a language with lazy evaluation?
21:15:32 <lambdabot> i'm 19
21:15:40 <intoverflow> heh
21:15:43 <mpeter> hear that fellas
21:15:47 <mpeter> she's fair game
21:15:49 <roconnor> @quote functional programmers
21:15:50 <lambdabot> No quotes for this person. Have you considered trying to match wits with a rutabaga?
21:15:52 * jeffwheeler_ wins
21:15:58 <roconnor> @quote functional
21:15:59 <lambdabot> ghc says: The instance types do not agree with the functional dependencies of the class
21:16:02 <roconnor> @quote functional
21:16:03 <lambdabot> qwe1234 says: oh come on, what do 'functional languages' have to do with lambda calculus?
21:16:12 <roconnor> @quote programmers
21:16:12 <lambdabot> monochrom says: The problem is that bad programmers will assess tutorials for good programmers as "ivory tower", and moreover bad programmers are the vocal majority.  It gets you bad press.
21:16:20 <roconnor> @quote "functional programmers"
21:16:21 <lambdabot> No quotes for this person. Do you think like you type?
21:16:26 <roconnor> :(
21:16:27 <Elly> lambda calculus is awesome :)
21:16:31 <roconnor> @quote lambdabot
21:16:32 <lambdabot> lambdabot says: Plugin `quote' failed
21:16:42 <roconnor> *L*
21:16:45 <Elly> haha :)
21:16:49 <mpeter> that's not a very good quote
21:16:50 <cknapp> Elly: that's like saying "God is awesome in a Church"
21:17:01 <cknapp> move the end quote over 3 words, please...
21:17:03 <Elly> cknapp: I think your closing quote is misplaced
21:17:04 <Elly> yeah
21:17:16 <mpeter> @quote ushdf
21:17:16 <lambdabot> No quotes match. stty: unknown mode: doofus
21:17:20 <mpeter> @quote mpeter
21:17:20 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
21:17:33 <mpeter> anyway
21:17:35 <mpeter> what's new in haskell
21:17:40 <Elly> monads
21:17:44 <cknapp> Monoids
21:17:51 <cknapp> And monoid documentation...
21:17:54 <jeffwheeler_> Gtk2Hs! Woo.
21:17:59 <roconnor> http://hackage.haskell.org/packages/archive/recent.html
21:18:10 <roconnor> lambdabot-4.2.2.1
21:18:17 <int80_h> and monoids generating monoid documentation
21:18:31 * int80_h had to go there
21:18:35 * wli tries to think of how to monadically memoize.
21:18:37 <pejo> jeffwheeler_, I find lazy evaluation really hard myself.
21:18:42 <intoverflow> monoids are like burritos
21:18:52 <cknapp> Obviously!
21:18:57 <int80_h> tasty with chile verde?
21:19:02 <mpeter> monoids are like salmon steaks
21:19:03 * cknapp suddenly gets monoids
21:19:12 <roconnor> pejo: you can always understand lazy evaluation later
21:19:14 <mpeter> share it with the rest of us
21:19:18 * cknapp will write a new tutorial "Monoids explained (finally)"
21:19:32 <pejo> roconnor, I intend to.
21:19:35 <sclv> i got monoids once in high school. it was awful. i missed a weak of class.
21:19:41 <sclv> erm, week.
21:19:41 <jeffwheeler_> I think "multiplicative monoid" is one of my favorite phrases.
21:19:42 <roconnor> when you need it
21:19:56 <sclv> correcting spelling in jokes is terrible.
21:19:59 <int80_h> as opposed to additive?
21:20:14 <Saizan__> @seen gwern
21:20:14 <lambdabot> gwern is in #perl6, #haskell, #darcs and #xmonad. I last heard gwern speak 11m 38s ago.
21:20:24 <int80_h> or add-versial
21:20:27 <cknapp> I'm all about divisive monoids...
21:20:29 <int80_h> oh someone stop me!
21:20:31 <jeffwheeler_> int80_h: Yes, or any other less awesome-sounding phrase.
21:20:34 <roconnor> a monoid is a catagory with one object.  What's so hard about that :P
21:20:50 * mpeter Playing MPEG stream 1 of 4: Assholeparade - Hash Thrash.mp3
21:21:27 <sclv> can somebody kick mpeter?
21:21:32 <mpeter> don't kick me
21:21:36 <mpeter> i'm a victim of society
21:21:38 <Saizan__> @tell gwern if you put State/tell in lambdabot's tarball on hackage, then the same messages are going to be received several times
21:21:38 <lambdabot> Consider it noted.
21:21:42 <int80_h> how about a wet trout?
21:21:53 <intoverflow> absolutely nothing about monoids is hard to understand.  which is why people think they are confusing.  After all, if it has a name it *must* be technical!
21:21:55 <roconnor> what happens when you take voice from someone?
21:22:02 <mpeter> they get angry at you
21:22:22 <roconnor> mpeter: but they can still read, right?
21:22:30 <mpeter> that's not as useful as it sounds
21:22:47 <intoverflow> mpeter is failing the turing test before our very eyes
21:22:47 <int80_h> I think he meant read/write
21:22:51 <Taejo> roconnor: nothing, in an unmoderated channel
21:22:53 <cknapp> intoverflow: but, what's a "set" and what's an "operation"?
21:23:07 <Axman6> roconnor: you mean +q on someone?
21:23:17 <intoverflow> cknapp: a set is something satisfying ZF, and an operation is a subset of the cartesian cube of a set
21:23:37 <mpeter> no choice, intoverflow
21:23:38 * intoverflow pauses and realizes cknapp's comment may have been rhetorical
21:23:53 <roconnor> Taejo: Ah.  I totally don't know what voice means then.  I was just guessing
21:23:53 * mpeter laughs quietly to himself
21:24:00 * wli suspects memoization is little more than a state monad.
21:24:34 <intoverflow> wli: it could definitely be implemented that way; I just thought I'd toss the question out to see if there was a clever alternative
21:24:35 <cknapp> Wait, subset of the cube? I guess that works... but *:XX->X is nicer than * c XXX....
21:24:56 * wli is trying to remember how to write the monad transformer nonsense.
21:24:57 <cknapp> c = subset...
21:25:04 <Taejo> roconnor: nobody has voice in this channel. In my hang-out channel, we having voice means you're an oldtimer but can't be trusted with ops.
21:25:13 <cknapp> (it doesn't look quite as pretty as I thought it would)
21:25:14 <intoverflow> cknapp: yeah, but that's just notation.  I mean, an operation is a function from X^2 -> X, and a function is just a subset of the product of the domain and range
21:25:26 <roconnor> Taejo: heh, it must have some operational semantics
21:25:57 <Taejo> roconnor: well, you can make the channel moderated
21:26:01 <cknapp> intoverflow: satisfying certain restrictions...
21:26:28 <cknapp> Also, there's abstraction for a reason... :)
21:26:34 <cknapp> (aimed at me, too)
21:26:59 <Saizan> intoverflow: also, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MemoTrie
21:27:03 <intoverflow> cknapp: two restrictions.  f : D -> R is a set of pairs f = {(d,r)} such that forall d \in D there exists a unique r \in R with (d,r) \in f
21:27:38 <intoverflow> cknapp: well, I put the restrictions into one sentence, I guess.  the translation is that, for all d in D, f(d) must be defined; the second restriction is it must be unique.
21:27:58 <intoverflow> Saizan: thanks, will check it out
21:28:18 <ddarius> cknapp: A set is a discrete category.
21:28:23 * intoverflow pauses to reflect on how much of Conal's code he has used
21:28:38 <cknapp> Yeah; I got it. I was being pedantic... I'm aware of the definition... I just don't like cartesian products...
21:28:42 <cknapp> :)
21:29:05 <intoverflow> cknapp: heh, sorry to be so verbose then; I didn't want ot risk mocking a sincere question :)
21:29:38 <cknapp> No, not at all. I think anyone who is programming should have at least a very strong intuition of a set and a function...
21:29:49 * intoverflow teaches the "math for people who fear math" class at Utah
21:29:51 <cknapp> and if it were serious, do you think that answer would satisfy me?
21:30:02 <cknapp> It's a bit higher level, no?
21:30:02 * mpeter shrugs
21:30:11 <ddarius> intoverflow: Do you just summarily beat them over the head as they enter and call it a day?
21:30:14 <intoverflow> it depends; are you someone who knew the defintion at one time and has forgot?  or are you someone who has never thought about it?
21:30:26 <cknapp> Fair enough.
21:30:51 <Taejo> intoverflow: "math for people who fear math but have to do it anyway", or "math for people who fear math but want to get over the fear"?
21:31:03 <intoverflow> Taejo: mostly the former
21:31:05 <mpeter> people fear math because they're fools
21:31:14 <intoverflow> mpeter: I wish it was that easy
21:31:17 <mpeter> teach them that knowledge is a weapon for them to wield
21:31:20 <mpeter> and the math will follow
21:31:24 <ddarius> Fearing math is silly, not liking math is fine.
21:31:27 <Taejo> intoverflow: :) -- I could enjoy the latter, but would struggle with the former
21:32:13 <intoverflow> Taejo: I find that when I'm able to connect with a student, their resentment starts to vanish.  So the trick is to do that 40 times per semester
21:32:54 <cknapp> intoverflow: Indeed... that's a lot of work, though
21:33:40 <intoverflow> cknapp: it is, but it's what the tax payers pay me to do.  Sure, in principle they also pay me to do my own math, but they wouldn't pay me for the latter unless I also did the former (or unless I was really badass at the latter)
21:33:42 <cknapp> People fear math because they don't realize that you *have* to bend your mind to understand it.
21:34:02 <cknapp> intoverflow: indeed... I'll be there at some point (or such is the goal)
21:34:47 <intoverflow> For most people it's a learned mental barrier.  Early in life they hit a bump with math, and someone made them feel bad about it, and that feeling stuck with them.  They'd prefer to be good at math, but they've erected a defense mechanism built out of "I hate math, which is an excuse to be bad at it."
21:35:22 <intoverflow> So the first day is a lot of "the sooner you learn to quit hating useful things, the better off you'll be"
21:35:40 <cknapp> Indeed. I've also noticed that most people are extremely surprised at how much work I put into math for someone who is "really smart"
21:36:09 <cknapp> I.e. the high work/result ratio
21:36:10 <intoverflow> yeah, although I speculate that "you're good at math, so you must be really smart" is a part of that emotional defense
21:36:12 <mpeter> way to brag
21:36:25 <cknapp> yeah... I'm not that smart...
21:36:36 <cknapp> but "You're good at math and computers! You must be a genius"
21:36:48 <cknapp> It's rather obnoxious,a ctually...
21:37:19 <wli> That would work out okay if most people had any idea what math is. If they saw math happening, they'd mistake it for some kind of vague philosophizing vs. anything they recognize as math.
21:37:58 <mpeter> learning happens through utility
21:38:01 <intoverflow> wli: I agree completely.  Here in the States, k-12 math is very utility-focused, and consequently misses out on what mathematicians think math is actually about.
21:38:02 <cknapp> wli: yeah, I try to impress that on people as much as I can... I very much appreciate art for it's artistic, rather than utlitiarian or scientific appeal.
21:38:04 <mpeter> the childen learns to walk in leading strings
21:38:09 <mpeter> later, moves in all directions
21:38:39 <mpeter> you will find that art with a utilitarian or scientific appeal is scarcely art, but craft
21:38:55 <cknapp> art was supposed to be math...
21:38:56 * wli doesn't see ghc-6.10.x in portage.
21:39:08 <cknapp> math for it's artistic...
21:39:17 <afabian> The key thing about math for me is just to accept it... I mean, it doesn't always make intuitive sense, like quatum physics doesn't.  Like, you know, various cardinalities of infinity... so, my general rule is to just accept any provable relationship between quantities whether it makes any sense or not.  Much easier that way.
21:39:37 <intoverflow> I was lucky enough to meet a US congressman at a mathematical function (his name escapes me; it was a brief meeting).  He pointed out that everyone (incl in Congress) gets that math is useful, but very few people realize that math is still going on.  He pointed out that if we don't take the time when teaching non-mathematicians to point out contemporary mathematics, then the lay person won't even know it exists.
21:39:41 <Cale> afabian: Of course, you can choose to disagree with one of the axioms instead.
21:39:41 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
21:39:53 <Taejo> afabian: one doesn't understand mathematics, one just grows used to it
21:39:56 <sereven> wli: still in haskell overlay, can also ask in #gentoo-haskell
21:40:10 <wli> sereven: AIUI I have the overlay.
21:40:13 <CakeProphet> intoverflow:  rofl. "mathematical function"
21:40:13 <Cale> I don't know. Isn't getting used to it the same as understanding it?
21:40:21 <mpeter> yes
21:40:37 <mpeter> that is what "word problems" are an attempt to rectify
21:40:52 <Cale> mpeter: what?
21:40:56 <cknapp> In general a poor attempt...
21:41:14 <intoverflow> At some point, beign good at math requires you to accept math as being free of semantics; but I think a lot of talented mathematicians would tell you that putting on some semantics from time to time really helps with being able to take stabs at developing new math
21:41:17 <mpeter> cale: bridging the gap between abstract dialogue and applicable use
21:41:47 <Cale> mpeter: ah, except they tend to fail miserably at satisfying either side of that gap.
21:42:19 <cknapp> And fall into the chasm below...
21:42:28 <mpeter> "A lamppost stands at a 25 degree angle with respect to the vertical.  What's the derivative of f(x)=x^2+9x-20x from x=2 to x=50?"
21:42:28 <wli> Is there any compelling reason to get ghc-6.10.x?
21:42:31 <Cale> I have nothing against mathematical modelling. It's a very meaningful and difficult discipline, and I think it should be taught, but I would prefer that it be taught in a separate course from mathematics.
21:42:38 <cknapp> mpeter: haha
21:42:50 <mpeter> turns out the butler did it
21:42:51 <CakeProphet> hmmm... so how does STM work?
21:42:53 <wli> mpeter: Rephrase in such a manner as to make some sort of sense.
21:42:56 <Cale> Where it can be treated properly.
21:42:57 <Axman6> > deriv (\x -> x^2+9x-20x) x
21:42:58 <lambdabot>       No instance for (Num (Dif Expr -> Dif Expr))
21:42:58 <lambdabot>        arising from the li...
21:43:05 <Axman6> > deriv (\x -> x^2+9*x-20*x) x
21:43:05 <intoverflow> example of trying to put intuition in: http://terrytao.wordpress.com/2007/11/20/pcm-article-compactness-and-compactification/
21:43:06 <lambdabot>   1 * x + x * 1 + 9 * 1 - 20 * 1
21:43:13 <mpeter> i can't believe that's a function
21:43:19 <Taejo> CakeProphet: do you have a specific question?
21:43:21 <pejo> wli, there are some new features in it, but if you don't need them you'll be fine anyways.
21:43:29 <CakeProphet> Taejo:  well, what are "atomic memory transactions".
21:44:07 <intoverflow> CakeProphet: often when we are working with a shared variable, we have a process like this: read variable, compute some value based on what we read, write variable.
21:44:13 <wli> pejo: New features like what?
21:44:35 <Taejo> an atomic memory transaction is a sequence of reads and writes, where either all the writes occur or none of them, and the reads are consistent
21:44:36 <CakeProphet> oh... so it's for memory sharing stuff?
21:44:38 <Cale> As for mathematics itself, I feel that given the low standards which are set for highschool, the only thing of *practical* use which mathematics could be expected to teach is logic. Yet by and large highschool mathematics is taught in such a way that logic is avoided at every turn.
21:44:41 <intoverflow> CakeProphet: trouble is, if another process is doing the same thing, these operations can wind up interwoven, and the wrong result might be stored.  so we prefer to do this memory work "atomically," ie, in an un-broken-up way
21:44:44 <mpeter> cakeprophet: think about the requirements of an ATM
21:44:47 <roconnor> compactness is an important property to know about so you know what types have decidable equality.
21:44:51 <mpeter> in terms of reliability
21:45:06 <CakeProphet> ah okay.
21:45:17 <CakeProphet> so it performs all or none of the IO actions it does.
21:45:22 <pejo> wli, http://www.haskell.org/ghc/docs/6.10.1/html/users_guide/release-6-10-1.html
21:45:24 <CakeProphet> and you can "retry" them again.
21:45:33 <mpeter> yes
21:45:48 <Taejo> CakeProphet: well, so it appears to the program. In practice, things may be done and then undone, etc
21:45:48 <intoverflow> cale: I completely agree.  for some reason (in the US anyway) we're forced to justify the utility of the math we teach.  As far as I can tell, math is unique in this respect; we don't apply this standard to our other k-12 subjects.
21:46:15 * CakeProphet has never used shared memory, so doesn't know how to set it up.
21:46:28 <mpeter> what's problematic is the concept of the "subject" itself
21:46:43 <mpeter> and, to a degree, the concept of specialization within a predefined discipline
21:46:47 <Cale> intoverflow: yes. One thing which I found particularly jarring in highschool was the question "why are we studying this?", which never seemed to come up in music class.
21:47:10 <Cale> and the teachers tended to have miserable answers for it -- of course, there was no good answer quite often.
21:47:16 <inimino> CakeProphet: actually STM actions can't do any IO actions, but it does either all or none of the STM actions.
21:47:28 <mpeter> i suspect that any manner of streamlining the efficiency of an educational system would be doomed to overthrow the system itself
21:47:40 <mpeter> or at least underscore the shortcomings of the system ;)
21:47:42 <intoverflow> Cale: absolutely.  It's really the wrong question to be asking.  School doesn't make much sense outside of a context where education is valued for more than its utility.
21:48:18 <Cale> intoverflow: It's because we tell the students that mathematics is supposed to be useful in the first place!
21:48:19 <mpeter> what purpose does education have but utility
21:48:42 <intoverflow> mpeter: lots of things have a purpose other than their utility.  example: xbox
21:48:43 <Cale> It's not *supposed* to be useful, it's supposed to be beautiful.
21:48:43 <CakeProphet> inimino:  you mean in terms of types right?  I was using "IO actions" in the general sense (and in the sense that STM is converted to IO actions via atomically)
21:48:51 <mpeter> xbox is useful in that it's enjoyable
21:48:59 <Cale> The usefulness is a side effect of what it is.
21:49:00 <mpeter> although not as much as a computer with an xbox emulator
21:49:20 <ddarius> Cale, intoverflow: Students certainly ask the same questions in many other classes e.g. history.
21:49:23 <mpeter> the brain functions with several dominant heuristics, like any successful artificial intelligence would have to exhibit
21:49:32 <CakeProphet> what does the STM constructor want exactly? What functions satisfy STM (State# RealWorld -> (#State# RealWorld, a#))	
21:49:42 <Cale> ddarius: Oh, possibly, though the answers tended to be better there.
21:49:45 <mpeter> many to ensure its own survival, and then memetic tendencies created out of utility and the desire to rest
21:49:52 <mpeter> as well as out of sheer enjoyment
21:49:57 <Cale> ddarius: I never heard that question outside of mathematics classes though.
21:50:04 <ddarius> Cale: I'm pretty sure students ask such question in almost every class.
21:50:09 <mpeter> but the rule regarding those tendencies is that they have to satisfy the existing heuristics
21:50:11 <inimino> CakeProphet: in terms of types, and in terms of execution; atomically will never involve any IO since a requirement of STM is that transactions can be aborted
21:50:19 <intoverflow> ddarius: that's probably true; my perspective is decidedly biased since I only teach math
21:50:31 <inimino> CakeProphet: (and that they can be composed)
21:50:32 <Cale> ddarius: Well, in music class, it was obvious why we were learning to play music.
21:50:34 <mpeter> capitalism in its most extravagent forms forms industry purely out of perceived needs...sometimes even invented needs
21:50:42 <Cale> ddarius: Someone who asked that question would be laughed at.
21:50:45 <ddarius> Cale: I'm pretty sure I've heard it in various science classe, in geography and history, possibly even in art and music though by the time students get that attitude those classes are usually elective.
21:50:51 <mpeter> music class does a miserable job teaching students to play music
21:51:01 <mpeter> it teaches them to play other people's music with some degree of success
21:51:07 <Cale> My music classes were actually rather good.
21:51:09 <inimino> Cale: music tends to be an elective
21:51:12 <Taejo> ddarius: I think I've heard the same question of every K-12 subject (well, not accounting :) but much more frequently in maths than other subjects
21:51:18 <Cale> inimino: That's fine with me.
21:51:21 <mpeter> mine as well, cale, better than my other classes, for sure
21:51:28 <Cale> inimino: I would be quite happy with mathematics being an elective.
21:51:40 <CakeProphet> I find myself asking why tons of Haskell stuff is useful.
21:51:59 <nikki93> Man haskell is awesome!
21:52:08 <nikki93> I've been doing some stuff lately, I'm really new to it.
21:52:10 <ddarius> Taejo: I can see students asking that question a lot less often in music class because 1) they enjoy it more and 2) it's (often) easier to get good grades.
21:52:11 <Cale> nikki93: glad you like it :)
21:52:13 <mpeter> haskell seems to be an advanced language in that it's built on what appears to be the necessities experience by the designers ;)
21:52:13 <inimino> Cale: I'd be happy with every subject being an elective, but I don't expect to get elected to the school board on that platform
21:52:14 <CakeProphet> for example, all the Sum, Product, Any, All, etc monoids. I'm sure there's a place somewhere for them, I'm just not brilliant enough to figure out where.
21:52:26 <nikki93> But I've learnt that you have to just give up the old programming language ideas and think all your stuff all over again.
21:52:36 <Cale> CakeProphet: Those serve to identify which monoid you want.
21:52:49 <nikki93> getOddsDoubled lastOdd = map myDouble [1,3..lastOdd] where myDouble n = 2 * n
21:52:52 <mpeter> most popular languages work like that...but haskell eliminates so much nonsense
21:52:54 <nikki93> I just wrote that.
21:52:56 <nikki93> How's it?
21:53:01 <Cale> CakeProphet: For any instance of Num, you have two monoids, addition with 0, and multiplication with 1
21:53:06 <nikki93> It gives you the double of the odd numbers up to lastOdd. :)
21:53:11 <mpeter> looks good nikki ;)
21:53:14 <CakeProphet> Cale:  ...what.
21:53:18 <Cale> CakeProphet: The Sum and Product types just pick that.
21:53:34 <digitalexander> hey guys, what's up with rounding in Haskell? In ghci, "round 30.5" evaluates to 30, while "round 31.5" evaluates to 32...why is that?
21:53:37 <nikki93> Really, after 'map' and 'where', I'm hooked.
21:53:41 <wli> Cale: AIUI what's presumed is at least a unital semiring.
21:53:45 <mpeter> @let getOddsDoubled lastOdd = map myDouble [1,3..lastOdd] where myDouble n = 2*n
21:53:46 <FunctorSalad_> > liftM head (sequence $ repeat $ return 0)
21:53:48 <lambdabot>  Defined.
21:53:48 <lambdabot>   mueval: Prelude.read: no parse
21:53:48 <lambdabot>  mueval: GhcException mkTopLevEnv: not a hom...
21:53:48 <Cale> CakeProphet: A monoid is a set (or in our case a type), together with a binary operation which is associative, and has an identity.
21:53:53 <mpeter> > getOddsDoubled 23
21:53:54 <CakeProphet> Cale:  so they're used in a higher-order function context?
21:53:54 <lambdabot>   [2,6,10,14,18,22,26,30,34,38,42,46]
21:53:56 <inimino> digitalexander: Google for "round to even"
21:53:59 <nikki93> Its like math syntax (pure math syntax)
21:54:03 <ddarius> CakeProphet: As Cale often says (though usually about monads), the benefit of Monoids isn't specific instances, it's general functions that operate on all monoids.
21:54:06 <nikki93> mpeter: ;-)
21:54:08 <Taejo> digitalexander: it's called banker's rounding; there are mathematical reasons why it is better, and in some countries it is the "standard" rounding
21:54:10 <Cale> CakeProphet: Both addition and multiplication are such operations.
21:54:17 <intoverflow> CakeProphet: the rules for addition *and* the rules for multiplication satisfy the monoid laws; so anytime you have Num a, you have two monoids: one for +, one for *
21:54:31 <Cale> CakeProphet: The Sum and Product newtypes just serve to select which monoid you want.
21:54:36 <mpeter> multiplication is just an abstraction of addition ;)
21:54:49 <digitalexander> inimino, Taejo: ok, thanks, I'll look into the foundations...was just a bit surprised, is it also standard in other programming language implementations?
21:54:51 <Taejo> digitalexander: it's also called round-to-even
21:54:52 <Cale> CakeProphet: Because we can't make the same type an instance of Monoid more than once.
21:54:54 <intoverflow> mpeter: for multiplication by integers, anyway
21:54:56 <mpeter> until you get into decimals oO
21:54:57 <nikki93> Gimme a nice assignment for something using where and map and inner functions.
21:54:58 <mpeter> yeah
21:55:04 <nikki93> I'm on chapter 3 of real world haskell.
21:55:09 <nikki93> I need an idea for something to write.
21:55:11 <CakeProphet> ...you're repeating yourself, but I think I understand now. If you made some function that operates on multiple types of monoids, you can specify which monoid you want by passing a constructor as an argument to this function.
21:55:12 <nikki93> A small function.
21:55:17 <mpeter> nikki: take CakeProphet's last message
21:55:20 <mpeter> filter it for vowels
21:55:26 <mpeter> and then make them all uppercase
21:55:34 <Cale> CakeProphet: mm...
21:55:37 <Axman6> and pointfree...
21:55:47 <inimino> does RWH have exercises?
21:55:52 <Cale> CakeProphet: Maybe a concrete example would help.
21:55:58 <mpeter> it has pontifications
21:56:04 <mpeter> sometimes, announcements
21:56:09 <digitalexander> inimino: Yes, the exercises are quite good IMO, wide-ranging in difficulty
21:56:10 <Cale> CakeProphet: There are (at least) two valid ways to write an instance Monoid Integer
21:56:11 <mpeter> and obliterations
21:56:22 <CakeProphet> Cale:  concrete things always help.
21:56:25 <Cale> One of them has  mempty = 0; mappend = (+)
21:56:33 <Cale> The other has mempty = 1; mappend = (*)
21:56:40 <wli> Cale: Now try Integer as a poset.
21:56:42 <inimino> digitalexander: ok, good to know; I just wondered after nikki's question
21:56:52 <CakeProphet> Cale:  right, I get that... but what is the /use/ of these Sum and Product monoids. What is there benefit over, say, sum List and product List.
21:57:03 <CakeProphet> same for any and all.
21:57:09 <nikki93> Ok wiat, the equality operator in haskell is '==' or '='?
21:57:10 <kmeyer> :t putStrLn
21:57:11 <lambdabot> String -> IO ()
21:57:12 <nikki93> I mean, bool-returning
21:57:16 <Cale> CakeProphet: Oh, one nice use is along with the writer monad:
21:57:25 <CakeProphet> nikki93:  ==
21:57:25 <Cale> WriterT (Product Rational) []
21:57:25 <digitalexander> nikki93: ==
21:57:31 <Cale> Is one of my favourite monads.
21:57:34 <nikki93> Ok, thanks. Helpful guys here. :)
21:57:53 <ddarius> sum = mconcat, product = mconcat, concat = mconcat, compose = mconcat, and = mconcat, or = mconcat
21:57:56 <Cale> It lets you pick things from a list, tagged with their probabilities
21:58:04 <CakeProphet> hmmm
21:58:11 * mpeter eagerly await's nikki's function
21:58:17 <nikki93> Is there any function to check whether an element 'exists' in a list I provide?
21:58:17 <intoverflow> it *is* a cool monad
21:58:17 <Cale> and in the end, you get a list measuring the probability of each result.
21:58:17 <CakeProphet> I'll look into writer.
21:58:21 <nikki93> mpeter: Ok, ok wait. :)
21:58:25 <nikki93> mpeter: I'm very noob still.
21:58:27 <ddarius> :t mconcat
21:58:28 <lambdabot> forall a. (Monoid a) => [a] -> a
21:58:29 <digitalexander> nikki93: Yeah, I have never asked a question here which went unanswered. I'm also going through the RWH book btw, at chapter 4 now. Simultaneously I'm taking a Haskell-oriented course at uni.
21:58:32 <CakeProphet> nikki93:  elem
21:58:34 <Cale> WriterT/Writer work with an arbitrary monoid.
21:58:48 <CakeProphet> > 5 `elem` [1..10]
21:58:49 <lambdabot>   True
21:58:56 <CakeProphet> > "lolcats" `elem` [1..10]
21:58:57 <Cale> CakeProphet: There's also a monoid instance for Ordering which is a nice example.
21:58:57 <lambdabot>       No instance for (Enum [Char])
21:58:57 <lambdabot>        arising from the arithmetic sequen...
21:58:57 <intoverflow> nikki93: go to hoogle and search for   (Eq a) => a -> [a] -> Bool
21:59:17 <digitalexander> nikki93: I would strongly encourage you to do all the exercises in RWH, that's when you _really_ learn Haskell
21:59:22 <Cale> CakeProphet: data Ordering = LT | EQ | GT deriving (Eq, Ord,...)
21:59:27 <CakeProphet> Cale:  I saw that one. That'd be useful for Writer as well?
21:59:30 <intoverflow> nikki93: I mean that as a good exercise, not as a jerk's "go look it up for yourself" exercise.  Hoogle is an awesome tool for answering these sorts of questions.
21:59:36 <Cale> CakeProphet: It's more useful for sorting.
21:59:41 <mpeter> where did i put all my tobacco
21:59:46 * mpeter rummages
21:59:53 <Cale> CakeProphet: There's an instance:  instance (Monoid m) => Monoid (a -> m)
22:00:09 <Cale> where mempty x = mempty
22:00:17 <CakeProphet> I saw that one.
22:00:20 <Axman6> > toTXT "Axman has invented an automatic text to TXT converter!"
22:00:21 <lambdabot>   "xmn has nvntd an tmtc txt to TXT cnvrtr!"
22:00:26 <Cale> and (f `mappend` g) x = (f x) `mappend` (g x)
22:00:31 <CakeProphet> Cale:  I've been spending the last hour or so playing with different Monoid instances.
22:00:46 <Cale> So that means that t -> Ordering is a monoid, and so t -> t -> Ordering is as well
22:00:51 <Cale> But look at that type there!
22:00:57 <Cale> That's the type of comparison functions.
22:01:04 <ddarius> > toTXT "i c u"
22:01:06 <lambdabot>   "i c u"
22:01:21 <nikki93> intoverflow: There's a 'hoogle'? Cool!
22:01:33 <CakeProphet> @hoogle a->a
22:01:33 <lambdabot> Prelude id :: a -> a
22:01:33 <lambdabot> Data.Function id :: a -> a
22:01:33 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
22:01:34 <Cale> > sortBy (comparing length `mappend` compare) (words "here is a bunch of words to sort first by length and then alphabetically")
22:01:35 <lambdabot>   ["a","by","is","of","to","and","here","sort","then","bunch","first","words"...
22:01:45 <nikki93> Isn't string just a list of characters?
22:01:50 <nikki93> filterVowels (x:xs) = if (x == 'a') || (x == 'e') || (x == 'i') || (x == 'o') || (x == 'u') then x : (filterVowels xs) else filterVowels xs
22:01:55 <nikki93> That isn't working for some reason.
22:01:55 <CakeProphet> Cale:  ...oh wow.
22:02:04 <nikki93> It says it can't match the string to x:xs.
22:02:12 <intoverflow> nikki93: yes, and it is *awesome.*  Often you want a function that does something, and there is only a few obvious type-signatures it can have.  So you can hoogle for a type signature, and it'll come up with links to library docs.  I always have a browser tab open to it when I'm working.
22:02:23 <Axman6> nikki93: see notElem
22:02:26 <Cale> CakeProphet: Of course, this would all be so much more convenient if the methods didn't have such stupidly awkward names.
22:02:29 <kmeyer> hrm, how do I get a filename from argv?
22:02:40 <Cale> CakeProphet: mappend should be called (++) and mempty should be called zero
22:02:46 <Axman6> > let filterVowels (x:xs) = if (x == 'a') || (x == 'e') || (x == 'i') || (x == 'o') || (x == 'u') then  x : (filterVowels xs) else filterVowels xs
22:02:48 <lambdabot>   <no location info>: parse error on input `;'
22:02:48 <intoverflow> Cale: amen
22:02:50 <CakeProphet> :t comparsing
22:02:51 <lambdabot> Not in scope: `comparsing'
22:02:58 <ddarius> Cale: That's too additive.
22:02:59 <Cale> :t comparing
22:03:00 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
22:03:01 <Axman6> > let filterVowels (x:xs) = if (x == 'a') || (x == 'e') || (x == 'i') || (x == 'o') || (x == 'u') then  x : (filterVowels xs) else filterVowels xs in filterVowels "Hello there"
22:03:03 <lambdabot>   "eoee* Exception: /tmp/3796233757235636248:71:36-175: Non-exhaustive patter...
22:03:04 <CakeProphet> :t comparing
22:03:05 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
22:03:09 <Saizan> nikki93: you also have to cover the case where the list is empty
22:03:15 <Cale> ddarius: ++ already isn't such an additive operation
22:03:18 <Axman6> > let filterVowels (x:xs) = if (x == 'a') || (x == 'e') || (x == 'i') || (x == 'o') || (x == 'u') then  x : (filterVowels xs) else filterVowels xs; filterVowels [] = [] in filterVowels "Hello there"
22:03:19 <lambdabot>   "eoee"
22:03:21 <nikki93> filterVowels (x:xs) = if elem x "aeiuo" then x : (filterVowels xs) else filterVowels xs
22:03:26 <nikki93> Oh ok, Saizan sorry forgot.
22:03:29 <Taejo> Cale: not sure how I feel about mzero == 1
22:03:36 <Cale> Taejo: hm?
22:03:42 <Axman6> nikki93: also see filter
22:03:44 <Taejo> in Product
22:03:45 <chessguy> woot!
22:03:49 <Cale> Taejo: mempty you mean?
22:03:56 <Taejo> I meant zero == 1, actually
22:03:58 <Cale> Taejo: mempty is meant to be the identity of the operation
22:04:02 <Taejo> mempty == 1 I can handle
22:04:03 <ddarius> Cale: Indeed, but zero is and (++) doesn't suggest something different in the context it currently is in, where there it suggests commutativity.
22:04:05 <Cale> or zero, for that matter
22:04:05 <nikki93> filterVowels [] = []
22:04:06 <nikki93> filterVowels (x:xs) = if elem x "aeiuo" then x : (filterVowels xs) else filterVowels xs
22:04:11 <nikki93> There! Its done! :P
22:04:20 <pejo> @hoogle getArgs -- kmeyer
22:04:20 <lambdabot> Parse error:
22:04:20 <lambdabot>   --count=20 "getArgs -- kmeyer"
22:04:20 <lambdabot>                      ^
22:04:32 <kmeyer> @hoogle getArgs
22:04:32 <lambdabot> System.Environment getArgs :: IO [String]
22:04:32 <nikki93> @let filterVowels [] = []
22:04:32 <Cale> Perhaps 'identity' would indeed be better.
22:04:35 <lambdabot>  Defined.
22:04:36 <pejo> Hah. Of course it doesn't take comments.
22:04:44 <kmeyer> thanks.
22:04:50 <Cale> But the name for mappend is what bothers me most.
22:04:56 <Cale> It needs to be *much* shorter.
22:04:56 <nikki93> @let filterVowels (x:xs) = if elem x "aeiuo" then x : (filterVowels xs) else filterVowels xs
22:04:59 <lambdabot>  Defined.
22:05:00 <ddarius> Cale: I agree that it is a crappy name.
22:05:12 <Axman6> Cale: mapp?
22:05:19 <nikki93> > filterVowels "This is a test sentence, probably with a lot of 'E's"
22:05:21 <lambdabot>   "iiaeeeeoaiaoo"
22:05:24 <Cale> Axman6: Still too long, it needs to be an operator symbol.
22:05:27 <nikki93> :D
22:05:29 <ddarius> Cale: As far as I can recall, no math paper has given it a word name.  It's always represented by some operator.
22:05:33 <nikki93> mpeter: I got it! I got it!
22:05:34 <Axman6> <+>?
22:05:44 <Cale> ddarius: Well, it's usually referred to as multiplication.
22:05:46 <CakeProphet> Cale:  I suppose those monoids are useful because they describe a behavior that can be abstractly handled.
22:05:55 <kmeyer> @hoogle FilePath
22:05:55 <lambdabot> module System.FilePath
22:05:55 <lambdabot> Prelude type FilePath = String
22:05:55 <lambdabot> System.IO type FilePath = String
22:05:56 <chessguy> no more infinite loop, now i'm just always getting exactly the wrong answer
22:05:58 <Cale> CakeProphet: yes
22:06:00 <chessguy> strange, but better
22:06:02 <kmeyer> ahhhh
22:06:26 <Axman6> Cale: to be different, maybe >+<
22:06:31 <Cale> CakeProphet: Monoids abstract things which can be combined in a uniform way
22:06:33 <ddarius> chessguy: Before your result was at least <= to the answer, now it's not even that.
22:06:40 <Cale> Axman6: My suggestion is that we steal ++
22:06:45 <jeffwheeler_> kmeyer: Hoogle is also at http://haskeel
22:06:47 <Axman6> heh
22:06:48 <jeffwheeler_> Err
22:06:51 <nikki93> Where's toUpper defined?
22:06:57 <Cale> Axman6: ++ is already the mappend for the list monoid
22:06:58 <chessguy> ddarius:  that doesn't even make sense
22:06:58 <ddarius> @hoogle toUpper
22:06:59 <lambdabot> Data.Char toUpper :: Char -> Char
22:06:59 <Axman6> @hoogle toUpper
22:07:00 <lambdabot> Data.Char toUpper :: Char -> Char
22:07:05 <jeffwheeler_> Http://haskell.org/hoogle
22:07:12 <CakeProphet> > let isVowel = (`elem` "aeiou") in filter isVowel "Hello, World!"
22:07:13 <Axman6> Cale: yeah
22:07:14 <lambdabot>   "eoo"
22:07:14 <Cale> Axman6: So we lose little
22:07:26 <intoverflow> A philosophical take: monoids are /absurdly common/.  Absurdly common things deserve names, and deserve an abstraction for working with them generically.
22:07:32 <Cale> and we'd get to write things like  sortBy (comparing length ++ compare)
22:07:34 <Axman6> Cale: reddit.com/r/haskell_proposals ?
22:07:37 <nikki93> Ok, so how do I 'include' it? 'module Data.Char'?
22:07:40 <nikki93> Or something?
22:07:43 <nikki93> 'import'?
22:07:51 <Axman6> import
22:08:02 <CakeProphet> Cale:  what does comparing do.
22:08:04 <CakeProphet> :t comparing
22:08:05 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
22:08:13 <CakeProphet> hmmm
22:08:18 <Cale> CakeProphet: well, the type gives it away, pretty much.
22:08:25 <CakeProphet> Cale:  augh. no it doesn't.
22:08:28 <Cale> comparing p x y = compare (p x) (p y)
22:08:34 <enoqu_> hey, what's the best irc channel to get help for issues getting ghc --make to work on os x?
22:08:36 <CakeProphet> I can't figure functions out by types... not yet at least.
22:08:39 <wli> comparing f = compare `on` f ?
22:08:46 <Cale> wli: yes
22:09:01 <inimino> enoqu_: probably this one?
22:09:28 <nikki93> filterVowels [] = []
22:09:28 <nikki93> filterVowels (x:xs) = if elem x "aeiuo" then (toUpper x) : (filterVowels xs) else filterVowels xs
22:09:39 <ddarius> newtype MonoidToCat m a b = MonoidToCat m; type MC m = MonoidToCat m () (); instance Monoid m => Category (MonoidToCat m) where id = MonoidToCat mempty; MonoidToCat a . MonoidToCat b = MonoidToCat (a `mappend` b)
22:09:40 <Axman6> enoqu_: what's the problem? it works fine here
22:09:51 <Cale> I'm surprised at the number of CS students who are unfamiliar with monoids.
22:10:02 <Cale> They're pretty central to computer science, I would think.
22:10:12 <enoqu_> when i try to build a test program I get the following error "libgmp.dylib, file is not of required architecture"
22:10:22 <ddarius> Cale: Indeed.  Formal languages, state machines, lists, numbers, functions.
22:10:23 <intoverflow> Cale: I would agree, although I also know that many "computer science" departments are far too job-market oriented for that
22:10:30 <CakeProphet> > let cRUISECONTROL = map toUpper in cRUISECONTROL "Cale, I lack the ability to discern function from type."
22:10:31 <lambdabot>   "CALE, I LACK THE ABILITY TO DISCERN FUNCTION FROM TYPE."
22:10:35 <Axman6> enoqu_: how'd you install ghc?
22:10:43 <enoqu_> i'm using the following to configure gmp:  CFLAGS+=-m64 ./configure ABI=64
22:10:43 <enoqu_> CFLAGS+=-m64 ./configure ABI=64
22:10:57 <CakeProphet> nikki93:  that should be correct.
22:11:01 <Cale> CakeProphet: You're prepared for a dependently typed language then.
22:11:17 <CakeProphet> wat?
22:11:20 <Axman6> enoqu_: i doubt you'll get 64bit ghc working on OS X, i haven't heard of anyone else who has
22:11:22 <Cale> If you confuse values with types ;)
22:11:25 <chessguy> > any null []
22:11:27 <lambdabot>   False
22:11:36 <Elly> Cale: I'm at CMU, and the only class I've had so far which has mentioned monads was an intuitionistic logic class
22:11:37 <CakeProphet> Cale:  no no... I can't figure out what a function does if you give me its type signature.
22:11:43 <CakeProphet> too ambiguous
22:11:52 <CakeProphet> like comparing, for example.
22:12:10 <mpeter> what are you guys talking about now
22:12:22 <nikki93> mpeter: I got your function ready
22:12:22 <nikki93> filterVowels [] = []
22:12:23 <Axman6> enoqu_: just install ghc with macportss, it works fine
22:12:33 <nikki93> filterVowels (x:xs) = if elem x "aeiuo" then (toUpper x) : (filterVowels xs) else filterVowels xs
22:12:37 <enoqu_> ok I'll give that a try, thanks
22:12:38 <intoverflow> CakeProphet: the trick is to ask yourself "how would I write a function with that signature?"
22:12:38 <mpeter> > filterVowels "nikki let's see how well these vowels add up"
22:12:39 <lambdabot>   "iieeeoeeeoeau"
22:12:45 <mpeter> hmm
22:12:51 <intoverflow> there's usually only one "obvious" answer
22:12:51 <nikki93> Wait I didn't @let it yet
22:12:58 <wli> I remember "MR. THE RAT: CAN YOU HELP ME INSTALL NETBSD? I WANT TO RUN INTERNET EXPLORER" and maybe some similarly humorous quips.
22:12:59 <mpeter> > map strToUpper filterVowels "nikki let's see how well this goes"
22:12:59 <nikki93> @let filterVowels (x:xs) = if elem x "aeiuo" then (toUpper x) : (filterVowels xs) else filterVowels xs
22:13:01 <lambdabot>   Not in scope: `strToUpper'
22:13:01 <lambdabot>  <local>:26:0:
22:13:01 <lambdabot>      Warning: Pattern match(es) are overlapped
22:13:01 <lambdabot>               I...
22:13:07 <Cale> CakeProphet: ah, well, let's analyse comparing
22:13:08 <mpeter> > map chrToUpper filterVowels "nikki let's see how well this goes"
22:13:09 <lambdabot>   Not in scope: `chrToUpper'
22:13:12 <Cale> :t comparing
22:13:13 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
22:13:14 <mpeter> what's that function i'm thinking of
22:13:15 <CakeProphet> > (length.filterVowels) "I'm a pirate!"
22:13:16 <lambdabot>   4
22:13:31 <Axman6> mpeter: toUpper
22:13:35 <nikki93> Haskell allows lambda functions?
22:13:38 <ddarius> nikki93: Use guards.
22:13:41 <mpeter> > map toUpper filterVowels "nikki let's see how well this goes"
22:13:42 <lambdabot>   Couldn't match expected type `[Char]'
22:13:45 <ddarius> nikki93: Of course.
22:13:49 <CakeProphet> Cale it takes a function from some type to another, and then two values of the same type that can be passed to said function.
22:13:49 <mpeter> > map toUpper (filterVowels "nikki let's see how well this goes")
22:13:51 <lambdabot>   "IIEEEOEIOE"
22:13:52 <nikki93> I mean, I obviously can do a 'x bla where x = bla'
22:13:53 <Cale> CakeProphet: So it says that 'a' is some ordered type, and then that we give it a function from b to a, and then two values of type b, and it gives us an ordering.
22:13:55 <mpeter> there you go
22:14:12 <ddarius> :t \x -> x
22:14:13 <lambdabot> forall t. t -> t
22:14:16 <nikki93> > filterVowels "lalalala"
22:14:16 <chessguy> haha
22:14:17 <lambdabot>   "aaaa"
22:14:20 <ddarius> > (\x -> x) 3
22:14:21 <chessguy> i was missing a simple negation
22:14:21 <Cale> CakeProphet: So how might it get an Ordering? It must be comparing some things of type 'a' at some point.
22:14:22 <lambdabot>   3
22:14:23 <nikki93> @let filterVowels (x:xs) = if elem x "aeiuo" then (toUpper x) : (filterVowels xs) else filterVowels xs
22:14:24 <lambdabot>  <local>:26:0:
22:14:24 <lambdabot>      Warning: Pattern match(es) are overlapped
22:14:24 <lambdabot>               I...
22:14:36 <CakeProphet> Cale:  wait.
22:14:40 <CakeProphet> Cale:  how can you deduce that.
22:14:49 <Cale> CakeProphet: You can't, strictly speaking.
22:14:50 <nikki93> @let filterVowels2 (x:xs) = if elem x "aeiuo" then (toUpper x) : (filterVowels2 xs) else filterVowels2 xs
22:14:53 <lambdabot>  Defined.
22:14:58 <nikki93> @let filterVowels2 [] = []
22:14:58 <Cale> CakeProphet: It could just always give us EQ or something.
22:15:01 <lambdabot>  Defined.
22:15:05 <Cale> CakeProphet: But that would be dumb.
22:15:07 <nikki93> > filterVowels "Lalalallalala lalala"
22:15:09 <lambdabot>   "aaaaaaaaa"
22:15:27 <nikki93> > filterVowels2 "Lalalallalala lalala"
22:15:28 <Cale> CakeProphet: We wouldn't need the Ord a constraint unless it was comparing things of type a though.
22:15:29 <lambdabot>   "AAAAAAAAA"
22:15:31 <CakeProphet> nikki93:  you can use semicolons to string together lines.
22:15:32 <nikki93> YEAH! :P
22:15:40 <Cale> CakeProphet: So we might as well assume that it's going to do so.
22:15:50 <CakeProphet> Cale:  oh... I forgot about (Ord a)
22:15:51 <chessguy> *TestKB> resolution (PropKB [(a :\/: b) :/\: (Not a)]) b
22:15:51 <chessguy> True
22:15:51 <mpeter> > filterVowels "i enscone interpolati eons"
22:15:52 <lambdabot>   "ieoeieoaieo"
22:15:56 <chessguy> woooooT!!!
22:16:08 <mpeter> ^ say that out loud
22:16:11 <mpeter> as loud as possible!
22:16:13 <nikki93> Haskell rocks!
22:16:14 <Cale> CakeProphet: But then the question becomes "which things of type a?"
22:16:21 <nikki93> It makes me think about programming in a whole new way.
22:16:27 <mpeter> good, nikki
22:16:29 <wli> Try filterVowels = map toUpper . filter (`elem` "aeiou")
22:16:32 <mpeter> this is how programming should work ;)
22:16:34 <Cale> CakeProphet: We give it a way to turn things of type b into things of type a, and two values of type b...
22:16:37 <CakeProphet> Cale:  so how does your sort function work.
22:16:42 <Cale> CakeProphet: That could not be more suggestive.
22:17:01 <Elly> "... if you know what I mean."
22:17:03 <CakeProphet> Cale:  and can you show me that function again so I can look at it.
22:17:05 <nikki93> One thing I still love about Haskell is that people can't simply get a certificate in some course and get into a job just for the money.
22:17:13 <nikki93> You have to really love your stuff. And be clever. :)
22:17:14 <Elly> okay, that *was* more suggestive :P
22:17:19 <Cale> comparing p x y = compare (p x) (p y)
22:17:25 <mpeter> are you guys the intelligentsia
22:17:45 <nikki93> Assignments I needs assignments
22:17:48 <Cale> CakeProphet: It's a bit noisy actually, want to continue in #haskell-overflow?
22:17:51 <CakeProphet> Cale:  I mean, your sort function.
22:17:56 <mpeter> nikki: write an intelligent chat bot
22:17:56 <CakeProphet> nikki93:  try let.
22:17:58 * wli ponders a program to typeset things as he would write them in his handwriting, essentially encoding ligature rules beyond those of which METAFONT et al are capable.
22:18:03 <CakeProphet> > let x = 2 in x+4
22:18:04 <mpeter> i think you're ready ;)
22:18:05 <lambdabot>   6
22:18:22 <Cale> :t sortBY
22:18:23 <lambdabot> Not in scope: `sortBY'
22:18:23 <Cale> :t sortBy
22:18:25 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
22:18:37 <CakeProphet> Cale:  sure
22:18:40 <Cale> CakeProphet: So it takes a comparison function and a list and sorts it.
22:18:53 <Cale> So the question is just what the right comparison function is.
22:19:10 <Cale> Come to #haskell-overflow so that some things won't scroll so quickly.
22:19:21 <nikki93> CakeProphet: I know about let. :)
22:19:27 <nikki93> CakeProphet: C'mon that's simple.
22:19:42 <wli> Most of it has to do with crossing t's, f's, and the like; I connect the crossing strokes indefinitely far within a single line so long as there are no intervening letters which should not be crossed (though there are some which may be crossed despite not needing to be so).
22:19:47 <CakeProphet> nikki93:  oh... I thought you wanted variable assignment.
22:20:08 <ddarius> wli: And what would you do with this?
22:20:35 <nikki93> CakeProphet: lol I meant Haskell exercise.
22:20:41 <nikki93> filterVowels xs = let remConsonants x = if elem x "aeiou" then x else ' ' in map remConsonants xs
22:20:57 <CakeProphet> nikki93:  familiar with brainfuck?
22:20:59 <nikki93> Is there any way to return an 'empty' character? To 'remove' it.
22:21:03 <wli> ddarius: I'd generate images of text artificially written as I would write it in order to work around my RSI, which makes it very painful for me to write.
22:21:06 <nikki93> CakeProphet: Yes, not used it though.
22:21:14 <nikki93> CakeProphet: Familiar with Malbolge? :P
22:21:19 <mpeter> > strictEval nikki
22:21:21 <lambdabot>   "nikki is in #haskell"
22:21:22 <ddarius> wli: You dislike every font in existence?
22:21:23 <CakeProphet> nikki93:  my first Haskell project was to write a bf interpreter.
22:21:27 <CakeProphet> nikki93:  and yeah. :P
22:21:36 <mpeter> that's a hell of afirst project
22:21:46 <Axman6> not reaslly
22:21:46 <nikki93> I'm thinking of writing an RPN evaluator.
22:21:48 <Axman6> really*
22:21:51 <nikki93> CakeProphet: How old are ya?
22:21:52 <wli> ddarius: The fonts aren't offensive per se; they're merely not all that similar to my handwriting.
22:21:54 <mpeter> ok, it's not so bad
22:22:06 <ddarius> wli: I don't see the benefit of it being similar to your handwriting.
22:22:20 <nikki93> CakeProphet: C'mon, your mom said don't talk to strangers? :P
22:22:27 <mpeter> i have so many fonts on here ;)
22:22:30 <mpeter> abiword flips out
22:22:51 <cjb> not looking like my handwriting is usually a feature that I enjoy in fonts :)
22:23:08 <cjb> s/I/I and others/ :)
22:23:19 <Axman6> heh, same here
22:23:24 <mpeter> error: buffer overflow
22:23:41 <CakeProphet> nikki93: hmmm? I'm 17. Why?
22:23:44 <wli> ddarius: There isn't much beyond warm fuzzies and maybe throwing some ideas for ligature-formation capabilities at font people.
22:23:44 <mpeter> sie tranken regen...version
22:24:14 <ddarius> wli: Okay.
22:24:19 <wli> ddarius: The bullcrap I do with crossing t's and f's and so on may be pertinent to Devanagari ligature formation.
22:24:31 <mpeter> Caution! Under no circumstances confuse the mesh with the interleave operator, except under confusing circumstances!
22:24:36 <nikki93> CakeProphet: Just like that. :)
22:25:55 <nikki93> So... Is there function to convert a string like "243" to the number 243?
22:26:01 <mpeter> of course!
22:26:01 <nikki93> Must be, I'm still bad at hoogling
22:26:14 <mpeter> > show 243
22:26:16 <lambdabot>   "243"
22:26:19 <mpeter> whatever the opposite of that is ;)
22:26:23 <kmeyer> @hoogle String -> Integer
22:26:23 <lambdabot> Prelude read :: Read a => String -> a
22:26:23 <lambdabot> Text.Read read :: Read a => String -> a
22:26:23 <lambdabot> Prelude error :: String -> a
22:26:42 <mpeter> that's not really accurate, though
22:26:48 <kmeyer> how isn't it?
22:26:52 <nikki93> kmeyer: I searched for the very same thing lol
22:27:05 <nikki93> But I used [Char] -> Integer instad.
22:27:08 <kmeyer> nikki93: in case it isn't clear you want read
22:27:12 <mpeter> well, in that context it works fine
22:27:19 <ddarius> @hoogle [Char] -> Integer
22:27:19 <lambdabot> Prelude read :: Read a => String -> a
22:27:19 <lambdabot> Text.Read read :: Read a => String -> a
22:27:19 <lambdabot> Prelude error :: String -> a
22:27:45 <nikki93> Ok.
22:27:52 <sereven> nikki93: http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html exercises at bottom might be good right about now. and RPN calc is covered in LYAH chapter iirc, there are probably some quick projects in that tutorial too. http://www.learnyouahaskell.com
22:28:07 <mpeter> oh, nikki here's something good
22:28:10 <mpeter> go through project euler!
22:28:10 <ddarius> > foldl' (\acc c -> digitToInt c+10*acc) 0 "243"
22:28:11 <lambdabot>   243
22:28:28 * wli wonders if he'd have anything to say pertinent to Haskell tutorials.
22:28:48 <nikki93> I'm not bother by asking questions, am I? You guys might be busy. :)
22:28:54 <nikki93> How can I get the last two elements off a list
22:28:55 <Axman6> > maxBound :: Int
22:28:56 <lambdabot>   9223372036854775807
22:29:05 <Axman6> > read "9223372036854775808" :: Int
22:29:07 <lambdabot>   -9223372036854775808
22:29:07 <nikki93> > maxBound :: Integer
22:29:08 <mpeter> if we were busy, we wouldn't be here
22:29:08 <lambdabot>       No instance for (Bounded Integer)
22:29:08 <lambdabot>        arising from a use of `maxBoun...
22:29:21 <nikki93> How can I get the last two elements off a list?
22:29:22 <kmeyer> is 'when' a keyword?
22:29:22 <wli> There's always the monadic monad tutorial writing combinator library idea.
22:29:31 <Axman6> nikki93: integers are unbounded, i.e, as big as you want them to be
22:29:47 <Axman6> nikki93: (init.init)
22:29:49 <nikki93> Axman6: Yeah, I read that. But I thought there was *some* limit.
22:30:03 <ddarius> kmeyer: No
22:30:06 <Axman6> nikki93: physical RAM limit i believe :)
22:30:07 <ddarius> :t when
22:30:08 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
22:30:09 <kmeyer> ddarius: function?
22:30:12 <kmeyer> ah.
22:30:14 <ddarius> @src when
22:30:14 <lambdabot> when p s = if p then s else return ()
22:30:17 <mmorrow> > take 2 . reverse $ [0..100000]
22:30:18 <lambdabot>   [100000,99999]
22:30:24 <Axman6> > 32*2^64
22:30:25 <mmorrow> > reverse . take 2 . reverse $ [0..100000]
22:30:25 <lambdabot>   590295810358705651712
22:30:25 <kmeyer> ahhh.
22:30:26 <lambdabot>   [99999,100000]
22:30:36 <wli> My bf's in the bathroom and I'm doing gentoo upgrade on a gay bar's wifi. So, while busy, IRC'ing makes some sense still.
22:30:37 <Axman6> > 2^(32*2^64)
22:30:37 <kmeyer> so why use when instead of if?
22:30:52 <lambdabot>   thread killed
22:31:01 <ddarius> Axman6: 2^69
22:31:15 <ddarius> > 2^69
22:31:18 <lambdabot>   590295810358705651712
22:31:30 <Axman6> > 2 ^ 590295810358705651712
22:31:45 <lambdabot>   thread killed
22:32:03 <mmorrow> Axman6: are you trying to create a mini blackhole that'll destroy the earf or something?
22:32:21 <kmeyer> ddarius: I like my ifs :D
22:32:37 <kmeyer> @hoogle when
22:32:37 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
22:32:41 <kmeyer> ah, right.
22:32:42 <ddarius> kmeyer: I almost never use when, but then I almost never use if.
22:32:46 <kmeyer> heh
22:32:53 <nikki93> So... I have the following questions:
22:32:54 <kmeyer> hlint suggested it to me
22:32:54 <mmorrow> "if and when..."
22:33:03 <nikki93> How can I pop the last two elements out of a list?
22:33:08 <nikki93> How can I push things onto the list?
22:33:10 <kmeyer> the only hlint suggestions on my code were two instances of if -> when, and some extraneous parens
22:33:13 <nikki93> Concat puts in front...
22:33:17 <mmorrow> > reverse . take 2 . reverse $ [0..100000]
22:33:18 <kmeyer> nikki93: very painfully
22:33:19 <nikki93> Oh I'll do it from front. Got it.
22:33:19 <lambdabot>   [99999,100000]
22:33:46 <mmorrow> > let xs = [0..9] in 42 : xs
22:33:47 <lambdabot>   [42,0,1,2,3,4,5,6,7,8,9]
22:34:08 <mmorrow> > let xs = [0..9] in take 3 (42 : xs)
22:34:09 <lambdabot>   [42,0,1]
22:34:38 <mmorrow> > let xs = [0..9] in drop 3 (42 : xs)
22:34:40 <lambdabot>   [2,3,4,5,6,7,8,9]
22:34:46 <mmorrow> > let xs = [0..9] in splitAt 3 (42 : xs)
22:34:47 <lambdabot>   ([42,0,1],[2,3,4,5,6,7,8,9])
22:35:13 <mmorrow> > let xs = [0..9] in span (<4) xs
22:35:14 <lambdabot>   ([0,1,2,3],[4,5,6,7,8,9])
22:37:50 <elbar> @src span
22:37:50 <lambdabot> Source not found. My brain just exploded
22:38:17 <RazerWolf> is there a decent IDE for haskell in windows ?
22:39:46 <inimino> emacs?
22:40:32 <RazerWolf> *shrugs* never used it
22:40:51 <elbar> i think eclipse can handle haskell too
22:41:04 * bos crashes against a rock in parser design
22:41:12 <wli> bos: Do tell.
22:42:07 <bos> wli: pretty often, it's very useful to be able to write a parser such as "parse this character followed by that other thingy, then give me back the text that was consumed by those parsers, not the actual results of the parses"
22:42:15 <wli> Num metricSpace isn't all that big a deal.
22:42:47 <bos> this is trivial to do with a parser that knows all of its input.
22:43:17 <wli> bos: But not one consuming its input from e.g. a tty or socket.
22:43:32 <bos> but for a parser that grabs new input via a continuation, it's much trickier.
22:43:45 <bos> to the point where my head asplode.
22:44:14 <wli> bos: That sort of arbitrarily forecloses the possibility of lookahead where it may otherwise be possible.
22:44:47 <bos> what does?
22:45:06 <wli> bos: The continuation affair.
22:47:54 <mmorrow> bos: i'm not sure your underlying datastructure/whatever, but ReadP has a nice function `gather' that does this. maybe its implem would be helpful
22:47:57 <mmorrow> , readP_to_S (read `fmap` munch1 isDigit :: ReadP Int) "54234asdf"
22:47:59 <lunabot>  [(54234,"asdf")]
22:48:05 <mmorrow> , readP_to_S (gather (read `fmap` munch1 isDigit :: ReadP Int)) "54234asdf"
22:48:07 <lunabot>  [(("54234",54234),"asdf")]
22:48:15 <mmorrow> , src 'gather
22:48:27 <lunabot>  gather :: forall a . (ReadP a) -> ReadP ((String, a))
22:49:13 <mmorrow> wli: not necessarily
22:49:58 <kmeyer> hrm, anyone with parsec experience?
22:50:10 <wli> mmorrow: I can envision exceptions, yes. I consider them unlikely.
22:50:11 <kmeyer> how do I just drop characters outside of a certain set?
22:50:48 <mmorrow> wli: i don't see how the situation would be any different than without continuations
22:51:04 <nikki93> Fold can be used to map a function to a list and then use a function to add these results up together?
22:51:05 <dolio> Are we talking about, for instance, a custom Stream in parsec 3?
22:51:09 <nikki93> foldl
22:51:20 <mmorrow> dolio: not sure
22:51:40 <mmorrow> (i'm not)
22:51:47 <wli> mmorrow: It's more a matter of what's overwhelmingly common in my experience vs. logically necessary.
22:52:57 <mmorrow> wli: i guess it is completely determined by the datatype/etc that underlies your parser
22:53:18 <Gracenotes> @hoogle Num a => (a, a) -> a -> Bool
22:53:18 <lambdabot> Data.Ix inRange :: Ix a => (a, a) -> a -> Bool
22:53:18 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
22:53:18 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
22:53:22 <mmorrow> because without knowing that, it's not clear to me what it even means to take input via a continuation
22:53:32 <Gracenotes> Ix saves the day again
22:53:57 <nolrai_East> @index liftIO
22:53:57 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
22:54:20 <dolio> mmorrow: In parsec 3, there's a: class Monad m => Stream s m t | s -> t where uncons :: s -> m (Maybe (t, s))
22:54:32 * mmorrow just killed his chat window by accident
22:54:39 <wli> mmorrow: I've found the common case to be a necessarily opaque function or function-related type passed around.
22:55:14 <dolio> So you can write: instance Stream Handle IO Char where uncons h = ... something with hGetChar
22:55:24 <dolio> But if you try lookahead, it breaks.
22:55:36 <dolio> Because you can't roll back to an earlier point in the stream.
22:55:50 <mmorrow> i mean, you can't actually successfully parse a parseable unit until you've seen all the necessary input, and if you've seen the input why can't you return it along with the parse result?
22:56:01 <dolio> A similar thing happens if you try to invert parsers with delimited continuations.
22:56:31 <bos> mmorrow: just because you've seen all the necessary input doesn't mean that you can access it all any longer.
22:57:08 <mmorrow> bos: sure, you'd need to arrange for that to be retained to support a feature like this i guess
22:57:29 <wli> Do Arrow-related parsers resolve any of this?
22:58:18 <mmorrow> dolio: and couldn't you just have a function that reads a chunk from the handle, then hands that chunk to an incremental parser, which returns either a result or a continuation. if a result, return result, if a cont, proceed with the next chunk
22:58:32 * wli wishes he had the first clue about arrows.
22:59:04 <dolio> The continuation thing is unrelated to the handle. They just have a similar problem.
22:59:19 <ddarius> wli: Why?
22:59:22 <wli> Some intensional representation of a continuation beyond function pointers might help.
22:59:39 <dolio> Because getting a character is truly a side effect in the underlying monad.
22:59:53 <wli> ddarius: Basically so I can figure out how to use Arrow parsers, so I can reap their efficiency and flexibility advantages.
23:00:37 <mmorrow> dolio: i'm saying that that problem is caused by choosing to use the Handle as a Stream instead of structuring your parsing function differently
23:00:44 <wli> I guess it all drops like a rock without Arrow-based IO.
23:00:59 <bos> dolio is right.
23:01:02 <digitalexander> I'm having some trouble making an isPrime-function; can anyone see http://hpaste.org/14049 and help me out?
23:01:02 <digitalexander> I'm having some trouble making an isPrime-function; can anyone see http://hpaste.org/14049 and help me out?
23:01:02 <digitalexander> I'm having some trouble making an isPrime-function; can anyone see http://hpaste.org/14049 and help me out? The error is No instance for (RealFrac Integer) ...
23:01:12 <dolio> Right. But the signature of uncons makes doing the wrong thing attractive. :)
23:01:13 <digitalexander> sorry about that...pasting trouble
23:01:34 <mmorrow> hehe
23:02:37 <dolio> For an instance of Stream to function properly, the type s is supposed to be an index into some persistant stream, and uncons s is supposed to start from the same place in the stream no matter how many times its used.
23:03:02 <mmorrow> ah, i'm not thinking in terms of this Stream class in particular
23:03:10 <dolio> Whereas handles and naive incremental continuation parses don't work that way.
23:03:12 <ddarius> dolio: An interface that more clearly suggests/enforces the (roughly) defined constraints would be nice.
23:03:42 <dolio> ddarius: I'm not complaining or anything. I'm not sure how to make that explicit in the types.
23:04:02 <ddarius> dolio: I'm not complaining about you complaining, I'm just hoping you'd have an idea.
23:04:13 <dolio> Heh. Nope, sorry. :)
23:05:25 <wli> digitalexander: isPrime n = all (\k -> n `mod` k /= 0) [k | k <- takeWhile (\j -> j*j < n), isPrime k [2..n]]
23:05:26 <Saizan> kmeyer: what do you mean with drop?
23:05:40 <kmeyer> Saizan: consume and do nothing with
23:05:47 * mmorrow suddenly becomes motivated to finish his httpd
23:05:51 <kmeyer> it's ok, I found skipMany + noneOf
23:05:54 <mmorrow> :)
23:05:56 <wli> digitalexander: isPrime n = all (\k -> n `mod` k /= 0) [k | k <- takeWhile (\j -> j*j <= n) [2 .. n], isPrime k]
23:06:29 * mmorrow was in need of motivation for what to do next
23:06:42 <Saizan> and what you found?
23:06:56 <wli> , let isPrime n = all (\k -> n `mod` k /= 0) [k | k <- takeWhile (\j -> j*j <= n) [2 .. n], isPrime k] in take 15 $ filter isPrime [2 ..]
23:07:01 <lunabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47]
23:07:29 <digitalexander> wli: thanks, but won't that compute all primes up to the number you're checking?
23:08:30 <wli> digitalexander: Sort of. If you don't like that, then isPrime n = all (\k -> n `mod` k /= 0) [k | k <- takeWhile (\j -> j*j <= n) [2 .. n]]
23:09:22 <kmeyer> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=770 <-- my brainfuck interpreter as a learning exercise.
23:09:27 <digitalexander> wli: ok, cool. Btw, did you see my hpaste? Do you know why it wasn't working?
23:10:05 <kmeyer> Saizan: skipMany (noneOf "somechar") does what I need.
23:11:20 <RazerWolf> I"m motivated to find a good ide for haskell on windoze
23:14:53 <mmorrow> kmeyer: nice
23:15:12 <mmorrow> hah, i didn't even know this sym existed:
23:15:24 <mmorrow> ohh, it's not a single char
23:15:29 <mmorrow> "8<"
23:15:35 <kmeyer> :D
23:15:46 <mmorrow> i thought it was a unicode sym for a sec there
23:15:50 * kmeyer stole that from something else he saw on moonpatio recently
23:15:52 <nikki93> Ok, someone give me a simple function to write.
23:15:55 <nikki93> I need an assignment.
23:16:00 <kmeyer> mmorrow: from my tests, hello world works...
23:16:05 <mmorrow> kmeyer: i'm stealing that one from you now
23:16:16 <wli> digitalexander: Sort of. If you don't like that, then isPrime n = all (\k -> n `mod` k /= 0) [k | k <- takeWhile (\j -> j*j <= n) [2 .. n]]
23:16:19 <kmeyer> mmorrow: enjoy :D
23:16:28 <pumpkin> whois nikki93
23:16:29 <kmeyer> it's clever-ish, isn't it?
23:16:52 <pumpkin> nikki93: you should write a fibonacci function! just to be original :)
23:16:54 <mmorrow> the "8<"?
23:17:02 <mmorrow> i think so
23:17:42 <kmeyer> oh well
23:17:47 * kmeyer resolves to learn Monads eventually
23:18:19 <wli> pumpkin: I've written a couple Fibonacci functions.
23:18:31 <pumpkin> wli: I know :) I've seen them!
23:18:37 <pumpkin> wli: I meant the naive one though :P
23:18:47 <kmeyer> mmorrow: in that I sort of abuse BFInpState / BFResState to mean two different things in two different places -- could be better. Also I'm duplicating work Parsec has already done for me.
23:18:49 <kmeyer> oh well.
23:19:10 <nikki93> fibonacci n | n < 1 = 1 | otherwise = fibonacci (n - 1) + fibonacci (n - 2)
23:19:23 <nikki93> @let fibonacci n | n < 1 = 1 | otherwise = fibonacci (n - 1) + fibonacci (n - 2)
23:19:26 <lambdabot>  Defined.
23:19:40 <nikki93> > map fibonacci [1..7]
23:19:42 <lambdabot>   [2,3,5,8,13,21,34]
23:19:47 <nikki93> > map fibonacci [0..7]
23:19:49 <lambdabot>   [1,2,3,5,8,13,21,34]
23:19:53 <nikki93> > map fibonacci [0..10]
23:19:55 <lambdabot>   [1,2,3,5,8,13,21,34,55,89,144]
23:20:02 <nikki93> > map fibonacci [0..20]
23:20:04 <lambdabot>   [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,177...
23:20:04 <wli> pumpkin: You can find two that I wrote at http://haskell.org/haskellwiki/The_Fibonacci_sequence#Fastest_Fib_in_the_West
23:20:12 <pumpkin> yeah, saw those :)
23:20:22 <pumpkin> pretty neat
23:20:39 * wli would feel like less of an idiot if his claim to fame were something less frivolous.
23:20:58 <pumpkin> you have a kernel.org host, that's pretty decent
23:21:05 <mmorrow> kmeyer: i think it looks nice
23:21:05 <nikki93> How's m y fibonacci
23:21:18 <wli> Like making the Linux kernel run on machines with thousands of CPU's. ;)
23:21:26 <nikki93> It does the sequence all over again for each number so it sucks a bit
23:21:42 <pumpkin> > fibonacci 100
23:21:49 <pumpkin> onoes exptime
23:21:52 <mmorrow> kmeyer: ah, so you're executing it as you head it in off a Handle
23:21:57 <lambdabot>   thread killed
23:21:59 <mmorrow> s/head/read/
23:22:00 <nikki93> lol
23:22:13 <nikki93> pumpkin: Dude, I'm just new to haskell, wrote a baaad function. :)
23:22:17 <kmeyer> mmorrow: hmm?
23:22:23 <pumpkin> nikki93: NO FORGIVENESS FOR YOU!
23:22:28 <kmeyer> I'm not even sure :D
23:23:39 <nikki93> pumpkin: But how can it calculate an arbitary position of fibonacci without knowing the previous ones?
23:23:40 <mmorrow> kmeyer: it seems like it'd be nicer if you had your interp operate on a [Token] stream, and return the state once the list runs out. then you could (e.g.) read more in and resume, or any other thing you wanted
23:23:57 <kmeyer> yeah, I guess that's true
23:23:58 <pumpkin> nikki93: there's a neat formula for doing that inolving phi, but it's not good for finding huge ones
23:24:01 <nikki93> pumpkin: WAIT DONT TELL. I'll do it melf.
23:24:05 <kmeyer> I'll put that on my TODO list.
23:24:09 <nikki93> *myself
23:24:10 <pumpkin> nikki93: I'm not sure it's something you could work out on your own :)
23:24:26 <mmorrow> even something like: interp :: BFState -> [Token] -> ([Action], BFState)
23:24:26 <pumpkin> nikki93: but you can make it linear time at least
23:24:34 <ddarius> pumpkin: If you know what phi is without being told, possibly.
23:24:38 <mmorrow> where (i'm just making this up as i go along):
23:25:01 <mmorrow> oh, n/m that wont work
23:25:05 <mmorrow> i was gonna say
23:25:07 <mmorrow> Action = PutChar Char | ReadChar Char
23:25:17 * wli used to have all sorts of tuple crap on holomorphy.com
23:25:21 <mmorrow> but if you need to read a char, the rest of the exec
23:25:25 <mmorrow> depends on that val
23:25:31 <wli> Stuff more impressive than the Fibonacci bits by far.
23:25:47 <mmorrow> kmeyer: i dunno
23:25:49 <kmeyer> mmorrow: right, the I/O stuff is what makes brainfuck impure by nature
23:26:08 <mmorrow> kmeyer: i guess you could have:
23:27:32 <mmorrow> Result = Done BFState | WriteChar Char BFState (BFState -> Result) | ReadChar (Char -> Result)
23:27:45 <mmorrow> that's kinda hackish though, i don't like the WriteChar part
23:27:53 <nikki93> pumpkin: Can't we just start from 0 and 'add up as we go along'?
23:28:00 <pumpkin> nikki93: yup!
23:28:12 <mmorrow> i had to pull the BFState out to suspend the Result
23:28:18 <mmorrow> a monad would work for that
23:28:32 <kmeyer> right, just /me is confused w.r.t monads
23:28:39 <nikki93> mySequence.append(mySequence.last + mySequence.secondLast)
23:28:40 <mmorrow> Result m = Done BFState | WriteChar Char (m Result) | ReadChar (Char -> m Result)
23:28:43 <nikki93> How do you right that in Haskell?
23:28:50 <kmeyer> s/right/write/
23:28:52 <nikki93> *write
23:28:55 <nikki93> lol
23:29:06 <nikki93> kmeyer: I prefer s:right:write
23:29:17 <pumpkin> :o
23:29:19 <nikki93> s:write:write\::
23:29:23 <kmeyer> nikki93: no difference
23:29:34 <nikki93> kmeyer: Yep, that's why I prefer it. I wouldn't if it was worse.
23:29:49 <pumpkin> nikki93: so each element depends only on the previous two
23:29:58 <kmeyer> nikki93: myseq ++ (head (reverse myseq)) ++ (head (tail (reverse myseq)))
23:30:12 <kmeyer> oh, just kidding.
23:30:14 <nikki93> The think, kmeyer, is that we reverse the entire list just to get the last thing.
23:30:23 <kmeyer> yup.
23:30:31 <nikki93> So wtf are we doin' that? :P
23:30:31 <pumpkin> that's inefficient, but not as bad as the naive exponential one
23:30:57 <mmorrow> Result = Done BFState | WriteChar Char Result | ReadChar (Char -> Result)
23:31:04 <mmorrow> actually i think this would work just the same
23:31:14 * mmorrow wants to write a BF interp now
23:31:28 * kmeyer has inspired someone, wow.
23:31:35 <pumpkin> BF is fun
23:31:36 <ddarius> Then do so.  Should only take a few minutes.
23:31:37 <kmeyer> you could make it better
23:31:43 <kmeyer> or rather
23:31:45 <pumpkin> the only nontrivial part is the [ ]
23:31:52 <kmeyer> the brainfuck interpreter on hackage uses unsafeIO everywhere
23:32:00 <pumpkin> but doing it in an ST would make it pretty easy anyway
23:32:09 <kmeyer> pumpkin: well, I'm still learning haskell and the stdlib
23:32:20 <kmeyer> and I'm unfamiliar with monads
23:34:32 <pumpkin> you don't really have to understand how the monads are working behind the scenes to use ST... it basically gives you a pseudoimperative way of doing things
23:35:08 <kmeyer> yeah, I was trying to avoid imperative where possible
23:35:50 <kmeyer> ... I guess I failed a bit in that respect.
23:36:24 <ddarius> Using a zipper over a list as the data pointer would be one interesting way of implementing it.
23:36:55 <ddarius> Turing did say infinite tape.
23:36:58 <pumpkin> how would you "jump backwards" for the while loop instructions?
23:36:59 <kmeyer> zipper?
23:37:09 <kmeyer> pumpkin: recursive descent
23:37:09 <pumpkin> I guess you can preprocess it into nested chunks
23:37:54 <Saizan> recursion!
23:38:02 <wli> The infinitude of the tape totally invalidates it as a model for actual physical computers.
23:38:14 <wli> They're essentially all FSM's.
23:43:18 <dzlk> kmeyer: keep in mind it's not for nothing that the article is called "You could have invented monads, and probably already have". I implemented a state monad in scheme twice before I had any exposure to the idea of a monad.
23:43:56 <cjb> dzlk: that's more a particular monad, rather than the concept
23:45:13 <wli> It took me 10 years to get a grip on monads. Sadly, I've since lost it.
23:45:33 <dzlk> cjb: well, right, but the point is that the concept fits naturally into things you're probably already doing, so it's not as alien as it might seem.
23:47:03 <kmeyer> dzlk: right, I don't feel like it's alient
23:47:06 <kmeyer> alien
23:47:17 <kmeyer> I'm just not sure where I should use monads in my own work
23:47:24 <kmeyer> should/can
23:49:42 <nikki93> Hey, I'm just finding the sum of all multiples of 5 and 3 in a list.
23:49:54 <nikki93> This is terrible inefficient and bad code, but just tell me, what's wrong with it.
23:49:58 <nikki93> find53Sum nums = findSum (map filter53 nums)
23:50:00 <nikki93>     where filter53 n = if ((n mod 3) == 0) || ((n mod 5) == 0) then n else 0
23:50:02 <nikki93> 	  findSum [] = 0
23:50:05 <nikki93> 	  findSum (x:xs) = x + (findSum xs)
23:50:08 <nikki93> If you want I'll give you the code.
23:50:36 <dzlk> kmeyer: ah, well, that's a good question. I'm not advanced enough to have any principled answer. if a monadic solution occurs to me and feels right, I use it, if it doesn't, I don't.
23:52:31 <pumpkin> nikki93: there's a prelude function called sum that does what your findSum does
23:53:04 <pumpkin> nikki93: otherwise, there's not really anything wrong with it... however it might be easier for you to generate the multiples of 3 and 5 rather than finding them
23:53:17 <kmeyer> pumpkin: then it'd be the same thing as 1.0/0
23:53:28 <pumpkin> ?
23:53:50 <pumpkin> oh it's a predefined list
23:54:01 <pumpkin> I thought you were just finding multiples of 3 and 5 in general
23:54:15 <kmeyer> summing them would never end :D
23:54:29 <pumpkin> you can take n of them :P or give it an upper bound
23:54:44 <pumpkin> nikki93: also, your map filter53 might be better served by a filter
23:54:56 <pumpkin> > filter even [5..]
23:54:58 <lambdabot>   [6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,5...
23:55:15 <pumpkin> > filter (\x -> x `mod` 3 == 0) [1..]
23:55:17 <lambdabot>   [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78...
23:55:48 <nikki93> find53Sum :: [Integer] -> Integer
23:55:49 <nikki93> find53Sum nums = sum (map filter53 nums)
23:55:49 <nikki93>     where filter53 :: Integer -> Integer
23:55:49 <nikki93> 	  filter53 n = if ((n mod 3) == 0) || ((n mod 5) == 0) then n else 0
23:55:54 <nikki93> Still something wrong withit
23:56:08 <nikki93> (if you need the ghci error message I'll give it here)
23:56:16 <kmeyer> pumpkin: that could probably be written using some combination of (==), (.), and flip
23:56:25 <pumpkin> kmeyer: yup
23:56:27 <bos> @type asks
23:56:28 <pumpkin> it's not very flear though
23:56:28 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
23:56:31 <pumpkin> clear
23:56:37 <bos> @type gets
23:56:38 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
23:56:42 <vegai> nikki93: you might wanna check function 'filter'
23:56:47 <pumpkin> (==0) . (flip mod 3)
23:56:52 <pumpkin> or just (`mod` 3)
23:57:10 <nikki93> Yes, yes. But my version *should* work right?
23:57:17 <nikki93> I'd like to fix my version.
23:57:26 <pumpkin> nikki93: yup, what's the error? paste it on hpaste.org
23:57:27 <pumpkin> @paste
23:57:27 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:57:29 <nikki93> I know I can implemenet lots of things using the standard library functions, but still.
23:57:32 <vegai> nikki93: perhaps mod => `mod`
23:57:40 <vegai> since you're using it like an operator
23:57:44 <pumpkin> yeah
23:57:56 <pumpkin> or mod n 3
