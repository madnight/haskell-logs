00:01:21 <Gracenotes> @unpl ($ const)
00:01:21 <lambdabot> (\ b -> b (\ a _ -> a))
00:02:26 <BMeph> Happy new year, Galois! :)
00:03:10 <dmwit> centrinia: Pretty cool.
00:03:20 <dmwit> centrinia: Now, can you explain what x' does? ;-)
00:04:09 <dmwit> :t flip ($ const)
00:04:11 <lambdabot> forall a b b1 c. b1 -> ((a -> b -> a) -> b1 -> c) -> c
00:04:39 <Olathe> @pl (\b -> b (\a _ -> a))
00:04:39 <lambdabot> ($ const)
00:04:54 <Olathe> @pl (\b a _ -> b a)
00:04:55 <lambdabot> (const .)
00:04:56 <dmwit> :t ap
00:04:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:05:11 <Olathe> @pl (\b a -> b (const a))
00:05:12 <lambdabot> (. const)
00:05:27 <Olathe> @pl (\b -> b (const a))
00:05:28 <lambdabot> ($ const a)
00:05:35 <Olathe> @pl (\b a -> b (const a))
00:05:36 <lambdabot> (. const)
00:05:56 <dmwit> :t const `asTypeOf` ap
00:05:58 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
00:05:58 <lambdabot>       Expected type: m (a -> b) -> m a -> m (a -> b)
00:05:58 <lambdabot>       Inferred type: m (a -> b) -> m a -> m b
00:06:08 <Olathe> @pl (\b -> b const)
00:06:08 <lambdabot> ($ const)
00:06:32 <dmwit> oh
00:06:48 <centrinia> I have no idea what x' does. :(
00:06:56 <dmwit> "c" is the type variable in (flip ($ const)) that the other flip acts on... whoa
00:07:06 <centrinia> I only know what (x' (x' x')) and ((x' x') x') do.
00:07:33 <dmwit> Even the type is too big for me to understand.
00:07:36 <pumpkin> :t (const const) const
00:07:37 <lambdabot> forall a b. a -> b -> a
00:07:48 <pumpkin> :t const (const const)
00:07:49 <lambdabot> forall a b b1 b2. b2 -> b1 -> a -> b -> a
00:08:14 <dmwit> :t flip (flip ($ const) ap) const
00:08:16 <lambdabot> forall a b (m :: * -> *) a1 b1 c a2 b2. (Monad m) => ((a -> b -> a) -> (m (a1 -> b1) -> m a1 -> m b1) -> (a2 -> b2 -> a2) -> c) -> c
00:08:26 <centrinia> :t (let x' = \x -> x (\y _ -> y) (\a b c -> (a c) (b c)) (\y _ -> y) in x')
00:08:27 <lambdabot> forall t t1 t2 t3 t4 t5 t6 t7. ((t -> t1 -> t) -> ((t2 -> t3 -> t4) -> (t2 -> t3) -> t2 -> t4) -> (t5 -> t6 -> t5) -> t7) -> t7
00:08:28 <adrian_> I think: X A -> A (XXX)(X(XX))(XXX)
00:09:41 <adrian_> that makes X A -> A KSK
00:09:56 <dmwit> :t let x' = \x -> x const ap const in x'
00:09:56 <adrian_> X = \x.xKSK
00:09:57 <lambdabot> forall a b (m :: * -> *) a1 b1 a2 b2 t. (Monad m) => ((a -> b -> a) -> (m (a1 -> b1) -> m a1 -> m b1) -> (a2 -> b2 -> a2) -> t) -> t
00:10:04 <dmwit> adrian_: right
00:10:17 <centrinia> adrian_, yes.
00:10:20 <dmwit> adrian_: Not that I necessarily understand what that does anyway. =)
00:11:51 <adrian_> At my university its most prominent use is to scare away the beginners in "algorithms and programming I"
00:13:35 <pumpkin> :)
00:14:06 <centrinia> You studied combinatory logic in Algorithms and Programming?
00:14:16 <Lemmih> SamB: Btw, do you want commit access to lhc?
00:17:03 <adrian_> there is an introduction to computability in which the lambda calculus, SKI and (occasionally) X are taught
00:17:57 <centrinia> Why would lambda calculus and combinatory logic scare away people?
00:18:12 <centrinia> They are simpler than most other concepts that are taught in computer science.
00:18:27 <adrian_> because they'd better study liberal arts
00:18:28 <pumpkin> <3
00:18:44 <centrinia> Hell, most of what computers do are compositions of S and K with type restrictions. ;)
00:20:01 <pumpkin> you can say most of the areas you compute in elementary geometry are simple double integrals
00:20:11 <pumpkin> doesn't make the double integral easier for the elementary school kid to understand :P
00:20:13 <adrian_> btw, if anybody asks for a proof that XXX=K and X(XX)=S, that's homework
00:20:36 <adrian_> "how to write a SKI parser" is homework too
00:20:43 <CakeProphet> :t putChar
00:20:45 <lambdabot> Char -> IO ()
00:20:53 <centrinia> @pl (let x' = \x -> x (\y _ -> y) (\a b c -> (a c) (b c)) (\y _ -> y) in (x' x' x', (x' x') x'))
00:20:54 <lambdabot> (const, const)
00:21:00 <centrinia> @pl (let x' = \x -> x (\y _ -> y) (\a b c -> (a c) (b c)) (\y _ -> y) in (x' x' x', x' (x' x')))
00:21:02 <lambdabot> (const, ap)
00:21:25 <CakeProphet> http://hpaste.org/13493
00:21:33 <CakeProphet> all of a bf interpreter except the []'s
00:21:41 <Olathe> > sing "La la la"
00:21:43 <lambdabot>   * Exception: divide by zero
00:21:45 <pumpkin> CakeProphet: but those are the fun bits!
00:21:57 <Olathe> Hehehe
00:21:57 <pumpkin> :)
00:21:58 <CakeProphet> and the hard ones
00:23:17 <CakeProphet> despite having four million arguments, it's rather poetic
00:23:55 <pumpkin> CakeProphet: you should implement an OISC
00:24:05 <centrinia> URISC.
00:24:08 <CakeProphet> a bf program is a function that returns  a (possibly) infinite list of IO actions
00:24:38 <centrinia> Wait, the URISC is an OISC.
00:24:49 <pumpkin> we should devise a NISC
00:26:45 * pumpkin writes a haskell-to-OISC compiler
00:26:57 <pumpkin> the ultimate in efficiency!
00:29:54 <adrian_> at least the pure part of haskell should be fairly straightforward to translate
00:30:06 <sbahra> Haskell is annoying :)
00:30:13 <pumpkin> why? :(
00:30:16 <adrian_> sbahra: blasphemy!
00:30:18 * sbahra has been browsing reddit posts for the last 3 hours
00:30:28 <sbahra> Article after article, each very interesting :-P
00:30:28 <pumpkin> sbahra: but they're all about gaza
00:30:32 * sbahra needs to sleep already
00:30:39 <sbahra> pumpkin, I'm in Saudi Arabia right now :-P
00:30:49 <sbahra> pumpkin, it's all I hear from others
00:30:50 <pumpkin> aha
00:30:55 <sbahra> Only thing adults are playing on TV ;p
00:30:58 <CakeProphet> improved bf interpreter: http://hpaste.org/13494  (still no brackets :()
00:31:03 * sbahra goes back to reading more haskell
00:31:04 <CakeProphet> I don't know how to do them without causing a mess
00:31:17 * CakeProphet doesn't want to ruin his beautiful program.
00:31:31 <pumpkin> you could make the brackets into nested lists
00:31:39 <pumpkin> actually, that won't work
00:32:38 <CakeProphet> I'll probably just need a nexted bracket counter argument and a bool to flag backtracking
00:32:40 <CakeProphet> which is ugly.
00:32:43 <CakeProphet> *nested
00:33:46 <pumpkin> well if you aren't supporting brackets
00:33:51 <pumpkin> you could dump your ip stuff
00:33:54 <pumpkin> and the !!
00:34:23 <pumpkin> instead of brackets, you could introduce the concept of an infinite bf program
00:34:25 <pumpkin> :P
00:34:29 <pumpkin> since your input is a list
00:35:33 <CakeProphet> oh... add to the source as it goes?
00:35:56 <CakeProphet> that'd actually work nicely, I think.
00:36:18 <pumpkin> it'd be an interesting thing to play with, if nothing else
00:36:25 <pumpkin> you don't hear much about potentially infinite programs
00:37:47 <adrian_> or you could preprocess the program to replace the brackets with pointers to their matching pair
00:38:28 <adrian_> so instead of String you have [Token]
00:38:43 <adrian_> with Token = Pointer Int | Instruction Char
00:38:52 <dmwit> nah
00:39:08 <dmwit> data Token = Instruction Char | Branch [Token]
00:39:12 <dmwit> Go straight to AST.
00:39:37 <pumpkin> might as well make the instructions their own constructors
00:39:38 <dmwit> I guess it would be Branch [Token] [Token]
00:39:39 <adrian_> indeed, that would be better
00:39:54 <dmwit> depending on how you wanted to do it
00:40:20 <dmwit> pumpkin: sure
00:40:32 <pumpkin> not that it'd be any more pattern matchable than yours :P
00:40:40 <dmwit> exactly
00:40:54 <pumpkin> but you can give them purty names
00:41:04 <pumpkin> AdvanceInstructionPointerPleaseKthx
00:41:08 <dmwit> But if you give separate constructors, you need a "comment" constructor -- lame!
00:41:41 <pumpkin> what's the most in-character way to augment brainfuck to have library calls?
00:42:15 <bd_> I don't think library calls are very in-character for brainfuck
00:42:21 <dmwit> 'p' to push an argument on the stack, 'c' to jump to the address stored in the current cell
00:42:30 <CakeProphet> uh, there's actually an extension to has IPC< file, socket support I think
00:42:36 <bd_> brainfuck has a tape, not a stack, I think?
00:42:51 <CakeProphet> yes
00:42:53 <dmwit> bd_: The function-call argument stack.
00:42:55 <pumpkin> bd_: well stack for arguments, assuming something like x86
00:42:57 <CakeProphet> basically an infinite array
00:43:26 <pumpkin> on arm's abi your first arguments go into registers
00:43:28 <bd_> add in a command to splice a new cell into memory (and one to remove one)
00:43:36 <bd_> for working storage, as well as confusing hacks
00:44:02 <pumpkin> I also think your program should sit at the beginning of the tape
00:44:07 <quylui> what is the best recommended site/book for learning haskell?
00:44:09 <pumpkin> and your tape pointer should start at the end of your program
00:44:28 <dmwit> quylui: The good ones are LYAH, RWH, the Gentle Intro, and YAHT.
00:44:32 <dmwit> ?where LYAH
00:44:32 <lambdabot> www.learnyouahaskell.com
00:44:34 <dmwit> ?where RWH
00:44:34 <lambdabot> is http://www.realworldhaskell.org/blog/
00:44:40 <dmwit> ?where gentle
00:44:40 <lambdabot> http://www.haskell.org/tutorial/
00:44:52 <dmwit> I hesitate to recommend YAHT, as I found it a bit slow for my tastes.
00:44:54 <quylui> dmwit: wow, i have *every* one of those open right now. i guess i'm set.
00:45:05 <CakeProphet> LYAH is my favorite
00:45:09 <CakeProphet> I wish it had a monad section
00:45:22 <pumpkin> ask BONUS_ :)
00:45:30 <dmwit> CakeProphet: I found "You Could Have Invented Monads" pretty good, and All About Monads, too.
00:45:32 <Gracenotes> apparently there will be one soon
00:45:37 <dmwit> ?go you could have invented monads
00:45:40 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
00:45:40 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
00:45:46 <dmwit> ?go all about monads
00:45:58 <lambdabot> http://www.haskell.org/all_about_monads/
00:45:58 <lambdabot> Title: All About Monads
00:46:16 <dmwit> But more than anything, the thing that really cemented monads in my mind was using them. =)
00:47:35 <quylui> wow. #haskell has been so darn good to me, thanks all you guys for the help heretofore.
00:48:27 <quylui> just saying.
00:48:42 <chrisdone> @hoogle withCAString
00:48:43 <lambdabot> Foreign.C.String withCAString :: String -> (CString -> IO a) -> IO a
00:48:43 <lambdabot> Foreign.C.String withCAStringLen :: String -> (CStringLen -> IO a) -> IO a
00:48:53 <dmwit> > sum . map (subtract (ord 'a') . ord) $ "heretofore"
00:48:55 <lambdabot>   105
00:48:58 <dmwit> shucks
00:49:05 <dmwit> I was hoping it'd be a dollar word. =)
00:49:16 <dmwit> > sum . map (subtract (ord 'a') . ord) $ "heretofor" -- a misspelling that is worth $1.00 =)
00:49:18 <lambdabot>   101
00:49:21 <dmwit> err
00:49:22 <dmwit> ah
00:49:35 <dmwit> > sum . map (succ . subtract (ord 'a') . ord) $ "heretofore"
00:49:36 <lambdabot>   115
00:49:51 <dmwit> > sum . map (succ . subtract (ord 'a') . ord) $ "heretfore"
00:49:53 <lambdabot>   100
00:49:53 <dmwit> hehe
00:50:00 <pumpkin> :o
00:50:32 <dmwit> > sum [ord x - ord 'a' + 1 | x <- "heretofore"] -- much more readable
00:50:33 <lambdabot>   115
00:53:47 <mpwd> I love real world haskell
00:54:21 <mpwd> I'm pretty lucky I decided to learn haskell last summer right when it was coming out.
00:54:38 <mpwd> (not that I really feel adequate in haskell after so little time)
00:55:00 <pumpkin> don't feel inadequate!
00:55:08 <quylui> real world haskell feels a bit abstruse :\ at least to me
00:56:23 <dmwit> ?wn abstruse
00:56:24 <lambdabot> *** "abstruse" wn "WordNet (r) 2.0"
00:56:24 <lambdabot> abstruse
00:56:24 <lambdabot>      adj : difficult to penetrate; incomprehensible to one of ordinary
00:56:24 <lambdabot>            understanding or knowledge; "the professor's lectures
00:56:24 <lambdabot>            were so abstruse that students tended to avoid them";
00:56:26 <lambdabot>            "a deep metaphysical theory"; "some recondite problem
00:56:28 <lambdabot>            in historiography" [syn: {deep}, {recondite}]
00:56:33 <dmwit> mmm
00:56:37 <pumpkin> was it like an abstruse goose?
00:56:37 <dmwit> Which bits?
00:57:23 <quylui> dmwit: asking me?
00:57:43 <pumpkin> he didn't have time to ask me about my abstruse goose question
00:57:50 <pumpkin> profound as it may have been
00:58:02 <mpwd> pumpkin: Hehe, but there's just so much to know!  And this chat room is ridiculous.  I heard some guys sitting around casually talking about minimal combinators that give rise to the lambda calculus here the other day.
00:58:22 <pumpkin> mpwd: it's awesome!
00:58:51 <mpwd> pumpkin: Oh, no doubt.  The lambda calculus rocks.  Still, haskell is rather daunting when you think of all the ingredients.
00:59:05 <mpwd> I wish I knew more category theory...
00:59:37 <pumpkin> It’s a piece of cake to bake a pretty cake
00:59:43 <pumpkin> If the way is hazy
00:59:56 <pumpkin> you gotta do the cooking by the book!
01:00:06 <pumpkin> you know you can't be lazy
01:00:18 <mpwd> pumpkin: All my code is lazy
01:00:32 <pumpkin> you interrupted lil jon!
01:00:36 <pumpkin> :P
01:00:45 <quylui> YEAAAH
01:01:56 <mpwd> quylui: Sadly, I would say that RWH is one of the more accessible sources for haskell.  Do you know lisp or any other functional programming languages already?
01:02:42 <pumpkin> sadly? it isn't that bad is it? :P
01:03:13 <mpwd> pumpkin: He found it difficult to penetrate
01:03:13 <quylui> mpwd: don't get me wrong, it wasn't entirely incomprehensible, and i could tell it was a great resource, but it just didn't seem to really explain things as clearly as the other tutorials did. with regard to your question, no, i don't.
01:03:19 <quylui> haha
01:03:22 <nanothief> pumpkin: I think it goes a bit fast for beginners
01:03:23 <pumpkin> isn't that a good thing?
01:03:49 <nanothief> I found it perfect, but I already knew the basics before I started reading it
01:04:23 <nanothief> (except for the functional dependancies part - that part sailed right over my head)
01:04:27 <quylui> nanothief: i entirely agree. i thought taking images of barcodes and translating them into haskell code was a bit challenging for a beginner's guide.
01:04:28 <mpwd> quylui: There's a lambda the ultimate tutorial for C programmers...
01:05:22 <quylui> mpwd: presumably it's for c programmers. i don't know any other programming languages, so it would likely make things more difficult.
01:05:40 <chrisdone> oh niiice
01:05:52 <chrisdone> got a ByteString version of gd working
01:05:55 <chrisdone> that was easier than I thought
01:05:58 <mpwd> quylui: Hmm... man, that's hardcore picking haskell as your first programming language
01:06:08 <chrisdone> Graphics.GD.ByteString, anyone?
01:07:01 <quylui> mpwd: not when i have all of #haskell to walk me through :D
01:07:31 <mpwd> nanothief: There's a Peyton Jones article which has a bit more analysis on functional dependencies (at least, as they are used in multi-parameter type classes)
01:08:28 <nanothief> mpwd: Oh I figured them out later by reading the wikibook article (and a couple of others). It just that RWH tried to explain it in 2 paragraphs, which was a bit optimistic
01:08:56 <mpwd> nanothief: Hehe, that will do it :)
01:09:06 <znutar_> I thought the barcode bit of RWH was rather weak just because it basically skipped most of the real world problems with doing that sort of thing.
01:10:33 <znutar_> And that's dangerous in that it leads people to think "obviously no one really uses haskell for real world problems if they're skipping the hard parts like that"
01:10:41 * chrisdone wishes every library had a ByteString version
01:15:38 <adrian__> Most haskell tutorials don't give enough theoretical background
01:15:59 <adrian__> I newer understood monads until I read the category theory part of the wikibook
01:16:06 <adrian__> *never
01:16:47 <adrian__> I don't like the "you don't need to understand it to use it" style
01:16:53 <idnar> znutar_: it's hard to find a balance, though
01:17:10 <idnar> znutar_: most interesting "real world" problems could have several books just written about a single problem
01:17:59 <znutar_> yeah, definitely.  The impression I took away from it was that it wasn't handled as well as it could be, though.
01:18:10 <idnar> znutar_: at least the barcode thing was better than that damned "trash sorter" example I've seen used to explain C++ polymorphism / etc. so many times
01:18:47 <idnar> znutar_: back when I was learning C++, I must have banged my head against that a hundred times before I finally figured out the whole thing was just metaphorical :P
01:26:39 <adrian__> was it dijkstra who said "two or more use a for"?
01:54:55 <Lemmih> Ha, yi does unicode now.
01:55:01 <pumpkin> :o
01:56:41 <ivanm> now, if only gtk2hs built with 6.10.1, and yi still used gtk2hs... >_>
02:07:40 <stu8ball> Debian xmonad guy says this about xmonad-light: ``With my xmonad Debian package maintainer hat on, I say I support this. I might even drop the default configuration xmonad binary from Debian, and install xmonad-light as “xmonad”''
02:08:01 <stu8ball> How do I know if the xmonad that I have installed is that new -light version?
02:08:12 <stu8ball> apt-rdepends |grep ghc  ?
02:08:25 <stu8ball> (which returns nothing btw)
02:08:42 <dmwit> Join us in #xmonad! =)
02:09:00 <stu8ball> ah, didn't know it had its own channel.
02:38:52 <pumpkin> @hoogle Storable
02:38:53 <lambdabot> module Data.Array.Storable
02:38:53 <lambdabot> module Foreign.Storable
02:38:53 <lambdabot> Foreign.Storable class Storable a
03:00:20 <int80_h> bah
03:00:28 <int80_h> lemmih, hi :)
03:04:28 <int80_h> question: If I wanted to use something like HAppS, but wanted to store state on disk, what would be my choices?
03:06:13 <Lemmih> int80_h: You could store small things in memory and put large things on disk.
03:07:15 <int80_h> Lemmih: can I do that with HAppS? or would I have to use a different application server?
03:07:38 <Lemmih> int80_h: You can do that with HAppS.
03:07:41 <int80_h> I was reading a blurb on HAppS and it says I would have to store state in memory
03:07:53 <int80_h> oooh...cool. A moving target indeed.
03:08:50 <int80_h> Lemmih: I haven't been able to check my mail yet, did you get my e-mail?
03:09:07 <Lemmih> int80_h: What email was that?
03:09:21 <Lemmih> Oh, that one.
03:09:47 <int80_h> yup
03:16:55 <int80_h> no worries if you are reluctant. I'm exploring my options.
03:20:12 <ScriptDevil> Can somebody now tell me why this won't work?
03:20:17 <ScriptDevil> http://hpaste.org/13495
03:22:37 <pumpkin> just wrong type
03:22:50 <pumpkin> That BlackLeaf 6
03:23:14 <pumpkin> needs to be a RedBlackTree, but is a BlackTree
03:23:24 <ScriptDevil> pumpkin: yeah.. how else do I represent it?
03:23:35 <pumpkin> make it a BlackTree $ BlackLeaf 6
03:23:50 <pumpkin> I mean
03:23:53 <pumpkin> yeah, that
03:24:01 <ScriptDevil> I had a RedBlackTree BlackTree Ctor. So I thought it was more like BNF
03:24:06 <ScriptDevil> pumpkin: oh.. Thanks :D
03:26:10 <blackh> Q: Is there a good trick to deal with cyclic compile dependencies? The OO trick with the listener pattern doesn't seem to fit Haskell too well.
03:27:16 <augustss> You mean cyclic module dependencies?
03:27:25 <blackh> augustss: Yes.
03:27:40 <augustss> Read the ghc manual, it describes what to do.
03:27:53 <blackh> augustss: Thanks.
03:27:54 <augustss> You have to create a small file manually.
03:28:38 <ScriptDevil> pumpkin: well.. Still have it written badly.... I would appreciate it if you can help me on this!
03:29:52 <pumpkin> ScriptDevil: I don't think it's bad, but I'm a beginner too
03:30:58 <ScriptDevil> :) pumpkin: Thanks a lot for the previous tip though. I think I will rewrite it as A RBTree and then one RedTree And 1 BlackTree
03:32:28 <augustss> ScriptDevil: I think it's Chris Okasaki that has written about how to do red-black trees in Haskell so you maintain the red-black invariant.
03:32:44 <augustss> Enforced by the type system, I mean.
03:33:07 <beelsebob> okay... cool http://hackage.haskell.org/cgi-bin/hackage-scripts/package/erlang-0.1
03:33:25 <beelsebob> Eric Sessoms if he's in here deserves an enormous hug
03:33:40 <pumpkin> yeah, that did look cool
03:34:00 <pumpkin> I wonder if you can make an all-haskell set of nodes
03:34:15 <pumpkin> his description doesn't make it sound like that, but I don't see why not
03:34:21 <beelsebob> shame it's GPLed though
03:34:29 <pumpkin> yeah
03:34:31 <beelsebob> means I won't use it
03:34:46 <pumpkin> you could ask him to change it :)
03:34:50 <beelsebob> true
03:34:51 <augustss> perhaps you can make him change the license?
03:34:55 <int80_h> stupid commie licensing.
03:35:01 <pumpkin> most people I've found aren't particularly adamant about their licensing
03:35:04 <pumpkin> if someone asks nicely
03:35:16 * int80_h proposes the formation of the haskell mafia, to strongarm developers into changing licensing terms.
03:35:20 <pumpkin> lol
03:35:23 <beelsebob> hehe
03:35:28 <int80_h> let's bake him some cookies.
03:35:35 <pumpkin> I'm all for cookies
03:35:41 <beelsebob> "change your license or we'll get the lambdas out"?
03:35:42 <int80_h> tell him the first batch is free.
03:35:46 <pumpkin> well, I'm the master of disgustingly fatty bacon rolls, so I'll make him one of those
03:35:58 <beelsebob> pumpkin: GIEF!
03:36:03 <beelsebob> I could just do with bacon now
03:36:08 <pumpkin> lol
03:36:08 <beelsebob> and this country doesn't do it right
03:36:18 <pumpkin> where you at?
03:36:21 <beelsebob> Belgium
03:36:29 <int80_h> yeah man, I likes me some pancetta
03:36:31 <pumpkin> http://gallery.me.com/pumpkin#100008/photo1230271245044
03:36:35 <pumpkin> mmm pancetta
03:36:56 <beelsebob> pumpkin: mmmm... Bacon and ossiliscopes
03:37:00 <pumpkin> lol
03:37:06 <Gracenotes> *blergh*
03:37:14 <pumpkin> yeah :)
03:37:17 <pumpkin> I felt that way too
03:37:21 <pumpkin> but it was just too good to not eat
03:37:42 <pumpkin> weaving the bacon was fun, too
03:38:16 <HugoSthlm> GUI's and web pages in Haskell, would that be a good idea ?
03:38:27 <pumpkin> it's been done plenety
03:38:28 <pumpkin> plenty
03:39:16 <beelsebob> HugoSthlm: web pages are rather lovely in Haskell, GUIs are less so, but improving rapidly
03:39:18 <beelsebob> (yay reactive)
03:39:36 <HugoSthlm> Tools fro web pages ?
03:40:28 <beelsebob> HApps
03:40:55 <int80_h> from what I can tell, you *really* need to me a haskell master to use happs effectively.
03:41:00 <beelsebob> oh?
03:41:04 <int80_h> not a bad thing. gives me a goal to shoot for.
03:41:20 <pumpkin> http://www.eecs.usma.edu/webs/people/okasaki/jfp99.ps is quite pretty
03:41:34 <HugoSthlm> So, if you're a newbe you start with ?
03:42:03 <C-Keen> HugoSthlm: real world haskell is a good start
03:42:16 <C-Keen> @go rwh
03:42:18 <HugoSthlm> Is that web tool ?
03:42:19 <lambdabot> No Result Found.
03:42:19 <pumpkin> augustss: that paper doesn't look like the invariants are enforced by the type system though
03:42:23 <C-Keen> @go RWH
03:42:25 <lambdabot> No Result Found.
03:42:25 <pumpkin> @where rwh
03:42:25 <lambdabot> is http://www.realworldhaskell.org/blog/
03:42:30 <C-Keen> thanks pumpkin
03:42:36 <C-Keen> pumpkin++ :)
03:42:39 <pumpkin> :)
03:42:50 <augustss> pumpkin: No, I was wrong.  It wasn't Okasaki, it was Ralf Hinze.
03:43:04 <C-Keen> HugoSthlm: no, it is a nice book that shows you how you can do "Real Programs" with haskell
03:43:07 <pumpkin> his balancing function is quite elegant, nonetheless :)
03:45:30 <int80_h> I ordered the Okasaki book, *and* RWH
03:45:52 <int80_h> because I read on the online version of RWH, a recommendation for the other book.
03:46:16 <int80_h> hey I've been poking around. it looks like happs documentation is really improving.
03:46:26 <HugoSthlm> Read some serious literature, need to use it a little
03:47:11 <maltem> int80_h: woot, happs has *documentation* now? :)
03:47:27 <HugoSthlm> Fixed DB connection, now looking for web and/or gui tools
03:48:58 <int80_h> yeah take a look
03:49:12 <int80_h> http://happstutorial.com
03:49:12 <HugoSthlm> Well, guess I'll give HAppS a try then. Anyone can point to a nice website using it ?
03:49:23 <pumpkin> that one
03:49:26 <int80_h> look at the url I posted
03:49:38 <int80_h> I'm installing darcs right now
03:49:38 <HugoSthlm> Thanx !
03:49:49 <int80_h> so I can't actually try anything yet
03:52:12 <maltem> int80_h: ah interesting. if they now had real API docs too... :)
03:52:56 <int80_h> maltem: I thought I could write the API docs, but HAppS is beyond my current skill level.
03:53:23 <int80_h> I tried earlier this year. Was told to learn how to crawl before trying to run, in so many words.
03:54:02 <maltem> hm, happs looks a little like you have to master Template Haskell, rather than just Haskell, to use it
03:54:17 <pumpkin> happs uses TH? :o
03:54:30 * pumpkin wants to use it now :O
03:55:32 <Saizan__> yeah, to "serialize" functions
03:55:33 <ScriptDevil> pumpkin: Thanks. I guess I have to sleep over that implementation. I want to get a type definition that is able to define the tree by the structure itself.  :) I will do it
03:55:53 <ScriptDevil> bye!
03:56:02 <pumpkin> Saizan__: interesting, so it writes the AST or something to a file?
03:56:26 <Saizan__> pumpkin: no, it declares a datatype for each and connects them to the code via typeclasses
03:56:38 <pumpkin> interesting, what for?
03:57:17 <Saizan__> so that it can replay them from a log, to ensure ACID properties for the state
03:57:25 <pumpkin> ah, wow
03:57:44 <Saizan__> or send them over the network for multimaster
03:57:49 <pumpkin> interesting
03:59:01 * int80_h wonders why darcs needs a jpeg library as a dependency
03:59:13 <int80_h> that's just wierd
03:59:16 <pumpkin> maybe it has some option to display stuff to a file?
03:59:45 <int80_h> hmm, okay
04:00:37 <maltem> how has darcs a jpeg library dependency?
04:01:06 <maltem> (grepping the source for "jpeg" doesn't show anything related)
04:01:33 <ivanm> maltem: maybe for its documentation?
04:01:55 <Heffalump> that seems odd, try asking on #darcs
04:02:19 <bohdan> howdy. how would I define 'reverse' so that 'head $ reverse $ reverse [1..]' would evaluate?
04:02:38 <maltem> I'm just wondering what made int80_h say that it has
04:02:39 <int-e> reverse = id ;-)
04:03:04 <bohdan> ok, second constraint: reverse [1,2,3] -> [3,2,1] :)
04:03:26 <int-e> bohdan: you really can't do that, if you stick to the type reverse :: [a] -> [a] and the semantics for finite lists.
04:03:31 <maltem> bohdan: hm you could try a ghc rule that rewrites reverse.reverse to id, but that breaks the actual semantics
04:04:02 <bohdan> why exactly I cannot do it?
04:04:16 <maltem> bohdan: well what would reverse [1..] be then?
04:04:35 <bohdan> maltem, I don't care, because it's lazy :)
04:04:37 <pumpkin> bohdan: it would need to know more about the function's behavior to know that reverse . reverse = id
04:05:23 <maltem> bohdan: even if it lazy, it has to be somehow defined
04:05:26 <int-e> because the semantics for finite lists force all elements of to be bottom. reverse [1..] = _|_ : _|_ : _|_ : ... is the best you can do - the values can't be known before the whole original list is consumed.
04:06:07 <int-e> (which will never happen.)
04:06:18 <bohdan> ok then, what about making it work for [1..10000000] without evaluating the whole list?
04:06:20 <maltem> int-e: you mean reverse [1..] = _|_ ?
04:06:25 <pumpkin> bohdan: same issue
04:06:31 <int-e> maltem: no, I mean what I wrote.
04:06:44 <int-e> maltem: this is not the standard library reverse, of course.
04:06:53 <maltem> int-e: ok, but how do you define it?
04:07:18 <Heffalump> reverse xs@(_:_) = last xs:reverse (init xs)
04:07:33 <pumpkin> hah
04:07:45 <int-e> yeah, that works.
04:07:47 <maltem> ah I see
04:07:51 <bohdan> also in hugs or ghci, is there a way to print the function's definition (e.g. for stuff from prelude)?
04:08:10 <pumpkin> bohdan: with that lambdabot-in-ghci thing, yeah
04:08:15 <pumpkin> can't remember what it was called
04:08:22 <maltem> bohdan: unfortunately not out-of-the-box
04:08:30 <olsner> pumpkin: goa?
04:08:37 <pumpkin> that's it, I think :)
04:08:43 <maltem> bohdan: it works for data types, though (:info)
04:08:44 <olsner> ghci-on-acid :)
04:09:52 <olsner> Heffalump: reverse xs = filter (isReverseOf xs) (permutations xs)
04:10:06 <pumpkin> lol
04:10:59 <int-e> bohdan: maybe I should ask, why do you want to optimize reverse . reverse in the first place?
04:11:27 <pumpkin> oh I know! you could make a GHC rewrite rule that rewrote it to id :P
04:11:29 <bohdan> just was reading about laziness and wondered
04:11:30 <pumpkin> then it would be super optimal
04:12:06 <maltem> pumpkin: you're late :P
04:12:10 <pumpkin> boo
04:12:21 <pumpkin> I see :(
04:12:39 <int-e> bohdan: doing that can usually be avoided. and even if you can't avoid it, you can define a  data MyList a = Forward [a] | Backward [a] with  toList (Forward xs) = xs, toList (Backward xs) = reverse xs and reverseMyList (Forward xs) = Backward xs; reverseMyList (Backward xs) = Forward xs.
04:12:46 <bohdan> DISCLAIMER: I'm not optimizing anything, just messing around trying to understand the language
04:13:37 <maltem> bohdan: ok then int-e's example should help you :)
04:14:08 <bohdan> int-e, right, that's sort of like adding a wrapper class that inverts list indexes in a procedural language
04:15:26 <bohdan> so my goal here was not to optimize it but to understand why it can't be done
04:15:27 <int-e> bohdan: coming from imperative languages, maybe it's best to think of [a] as a singly linked list - you can test whether it's empty, you can access the first element and the tail. you can't access later elements directly.
04:17:31 <int-e> bohdan: There's a complication in that any of these three operations may trigger a computation to find their result, if it has not been computed before. That's what laziness does.
04:18:27 <bohdan> I can imagine a magic form of foldr that would allow to implement reverse.reverse as id
04:18:58 <pumpkin> how?
04:19:18 <pumpkin> it would need to know that the second reverse's list is actually the result of a reverse rather than an arbitrary list
04:19:25 <int-e> the compiler doesn't do induction proofs. and besides, reverse . reverse = id is false for infinite lists.
04:19:42 <pumpkin> int-e: only because it isn't smart enough! :P
04:19:49 <int-e> pumpkin: perhaps.
04:20:48 <maltem> saying that reverse . reverse = id should hold for inifinte lists is a little like saying that a / x * x = a should hold even if x = 0
04:20:59 <int-e> replacing reverse . reverse  by  id will never turn defined values into bottoms, so it's sort of safe.
04:21:31 <int-e> What could we call that, a monotonous program transformation?
04:22:31 <olsner> I don't quite get the obsession with keeping non-termination behaviour... I'm fine with transformations that make non-terminating programs terminate as long as they don't make any terminating programs loop
04:23:15 <maltem> olsner: The problem in my eyes is that the function would behave different from how it is defined
04:23:30 <pumpkin> defined where?
04:23:38 <Saizan> the problem is that optimizations aren't that predictables, and change from compiler to compiler
04:24:03 <maltem> it may be a different story if you allow the definition of reverse.reverse=id at the language level
04:24:25 <int-e> olsner: if you write a program relying on reverse . reverse = id, applied to infinite lists, it will no longer work on compilers that don't do that transformation. you can't reliably test those programs anymore.
04:24:55 <int-e> olsner: so it really should be a conscious decision by the programmer instead.
04:25:20 <olsner> yeah, I guess the compiler difference thing would be an issue
04:25:24 <bohdan> ok I understand now. even with my magic form of foldr, I might end up not reversing the actual list, but I would still have to construct and later reverse the _|_ : _|_ : ... (whatever it be called)
04:25:41 <olsner> and that it'd be bad to end up with a program that only works at all with -O or -O2 or some other optimization flag
04:25:58 <int-e> > repeat undefined
04:25:59 <lambdabot>   [* Exception: Prelude.undefined
04:26:25 <bohdan> wait but can you optimize reverse . (+ 1) . reverse ?
04:26:39 <bohdan> by the said rewrite rule
04:26:58 <int-e> you mean map (+ 1), right?
04:27:04 <bohdan> yeah
04:27:15 <int-e> you can (soundly) transform that to map (+ 1) . reverse . reverse
04:27:31 <int-e> so, in principle, the rule may apply. it really depends on what rules you allow the compiler to use.
04:27:43 <int-e> *what other rules*
04:28:00 <bohdan> really, so the compiler does this sort of combinatorial optimization?
04:28:49 <bohdan> e.g. reverse . plusone . reverse . plusone . reverse . plusone . reverse might converge to plusone.plusone.plusone.id.id ?
04:28:51 <maltem> bohdan: that's what rewrite rules are about
04:29:12 <maltem> bohdan: a typical example for a practical rewrite rule is map f , map g   ->  map (f . g)
04:29:26 <int-e> hmm, reverse . reverse . reverse = reverse  is sound :)
04:29:27 <maltem> (map f . map g) I mean
04:29:50 <mercury^> int-e: :)
04:30:18 * Gracenotes is starting SICP... time to learn a Lisp dialect!
04:31:03 <bohdan> and what about 'a . a . a where a = reverse . plusone' ?
04:31:36 <mercury^> bohdan: that's a.
04:31:39 <int-e> well, it's reverse . map (+ 3)
04:31:46 <mercury^> err, yeah
04:32:21 <olsner> hmm, what about something like reverse . reverse = \xs -> seqList (const ()) xs `seq` xs?
04:32:35 <olsner> or just length xs `seq` xs?
04:32:42 <int-e> instance Functor MyList where fmap f (Forward xs) = Forward (fmap f xs); fmap f (Backward xs) = Backward (fmap f xs)
04:33:03 <Mathematicz> Someone show me a hello world e.g on codepad please
04:33:10 <mercury^> olsner: the latter should be bottom whenever xs is infinite and xs otherwise I think.
04:33:20 <int-e> Mathematicz: main = putStrLn "Hello, world!"
04:33:39 <Mathematicz> No includes needed?
04:33:51 <Mathematicz> Just people are trying to convince me to go from c++ to haskell
04:33:52 <mercury^> No, Prelude contains everything you need.
04:33:56 <int-e> nothing. putStrLn is exported by the Prelude module
04:34:15 <int-e> you might want to pick a less trivial example :)
04:34:21 <Mathematicz> Kk
04:34:39 <Mathematicz> Just i've got 2 c++ books, and just started learning it well :/
04:34:49 <bohdan> c++ is easier to learn by far, imho
04:34:52 <Mathematicz> but people say i should go haskell -> OPENGL
04:35:02 <mercury^> Heh.
04:35:05 <pumpkin> you should definitely go from apples to corvettes
04:35:06 <mercury^> What do you want to program?
04:35:11 <maltem> bohdan: easier than Haskell you mean? I disagree, from my experience :)
04:35:12 <Mathematicz> Games.
04:35:23 <bohdan> maltem, to learn, not to master :)
04:35:25 <mercury^> C++ is currently the standard for games.
04:35:44 <mercury^> bohdan: C++ is very hard to master.
04:35:46 <maltem> bohdan: exactly
04:35:54 <idnar> bohdan: it really depends on your prior experience
04:35:59 <Mathematicz> In the long run, would it be best learning haskell?
04:36:11 <idnar> bohdan: if you're starting from scratch, I think Haskell would be quite a bit easier
04:36:21 <mbz> Mathematicz, yep it would
04:36:21 <bohdan> idnar, no C++ offers you essentially a simple computing model
04:36:29 <mbz> Mathematicz, 100%
04:36:37 <idnar> bohdan: I think Haskell offers a much simpler model
04:36:39 <olsner> hopefully the future of mainstream programming is much more haskell-like than c++-like :)
04:36:53 <bohdan> ok one example
04:36:59 <wks> hi, folks. I have two comparing functions: c1, c2.  c1 :: (Ordering a) => a -> a -> Ordering, so is c2. How to obtain another function c3 which concats c1 and c2?
04:37:00 <bohdan> recursion with memoization in haskell
04:37:05 <int-e> Mathematicz: In my opinion, learning Haskell is a good idea even if you don't end up using it, simply because it gives you a new perspective on programming.
04:37:12 <bohdan> somewhat hard
04:37:20 <bohdan> in c++? somewhat easies
04:37:22 <johnnowak> Mathematicz: what do you know already?
04:37:23 <bohdan> *easier
04:37:23 <Mathematicz> So, Haskell -> OpenGL, would that be ok? Theres not may Haskell programmingjobs though :(?
04:37:31 <wks> I mean if c1 returns EQ, then apply c2.
04:37:33 <idnar> bohdan: it's also hard in C++, because you have to transform it into an iterative implementation :P
04:37:40 <bohdan> although it's hard to get it really right in c++, it's easy to get *something*
04:37:48 <idnar> bohdan: either way, that's hardly an entry-level consideration
04:37:53 <mercury^> Mathematicz: If you want to start programming games fast, you should learn C++.
04:37:59 <idnar> bohdan: anyhow, let's turn that around
04:38:02 <wks> Just like what default comparing of pairs does, which compares the first element and then the second
04:38:11 <idnar> bohdan: mapping a function over an infinite sequence
04:38:12 <maltem> wks: \x y -> c1 x y `mappend` c2 x y
04:38:14 * bohdan is expecting a parser example :)
04:38:19 <idnar> bohdan: that's pretty easy in Haskell, and a lot harder in C++
04:38:21 <johnnowak> if you want to program games *for money* you should learn c++
04:38:26 <idnar> bohdan: :P
04:38:32 <pumpkin> Mathematicz: haskell will bend your mind, which can be a lot of fun if you're into that stuff... if you just want quickest route to having a game of your own, then c++ is probably a better bet
04:38:41 <maltem> wks: I'm not sure right now if that does the right thing though :-/
04:38:48 <olsner> idnar: just making an infinite sequence at all in C++ is hard enough
04:38:51 * bremner uses both C++ and haskell pretty much daily for research programming
04:39:01 <Mathematicz> I don't know what to do :'(
04:39:07 <mercury^> Why not learn both?
04:39:19 <idnar> bohdan: the reason why I think Haskell is a lot simpler to start off with is that when you write C++ code, you're having to get a lot closer to the underlying hardware, whereas in Haskell, you're usually working a lot closer to the conceptual problem domain
04:39:20 <bohdan> idnar, no map (+ 1) [1..] is not a goal in itself, it's a means to an end
04:39:22 <Mathematicz> I couldn't, I would get confused
04:39:27 <mbz> Mathematicz, start with scheme and sicp
04:39:28 <baaba> nah you'd be alright
04:39:30 <Saizan> > map (EQ `mappend`) [EQ,LT,GT]
04:39:31 <lambdabot>   [EQ,LT,GT]
04:39:34 <mercury^> It will take a lot of time before you will be able to write a decent game anyway.
04:39:42 <idnar> bohdan: yes, but so is "recursion with memoization"
04:40:09 <Mathematicz> Yeah I kno
04:40:12 <Mathematicz> *Know
04:40:17 <bremner> was there a cabal to debian package project?
04:40:32 <bohdan> idnar, right, I meant 'compute a recursive function with memoization'
04:40:50 <maltem> Mathematicz: actually I think that Haskell and C++ is a good combination of languages to know
04:40:57 <idnar> bohdan: still, you don't set out to write a program that computes a recursive function with memoization, unless you're doing homework for a programming course or something
04:41:03 <Mathematicz> Can someone show me some eg's of Haskell please lol, like a for loop?
04:41:14 <idnar> bremner: yeah, uhm
04:41:22 <idnar> bremner: there's a cabal-debian tool, I believe
04:41:23 <bremner> Mathematicz: get real world haskell
04:41:30 <Mathematicz> what's that
04:41:31 <maltem> Mathematicz: mapM_ print [1..10]
04:41:35 <idnar> bremner: http://src.seereason.com/cabal-debian/
04:41:40 <bremner> Mathematicz: a book
04:41:46 <Mathematicz> Kk
04:41:49 <Mathematicz> I will get a book
04:41:51 <ivanm> Mathematicz: no for loops in haskell
04:41:54 <ivanm> @where yaht
04:41:55 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
04:41:58 <ivanm> @where rwh
04:41:58 <lambdabot> is http://www.realworldhaskell.org/blog/
04:42:01 <bremner> Mathematicz: get that particular book :-)
04:42:05 <ivanm> Mathematicz: ^^ those two links
04:42:10 <pumpkin> an imperative loop is so "aimless"
04:42:14 <idnar> Mathematicz: you can read it online at http://book.realworldhaskell.org/read/ or get it in hardcopy from wherever you buy your books (Amazon, say)
04:42:15 <bremner> idnar: thanx, checking it out
04:42:22 <ivanm> bremner: you sure you're not dons, CosmicRay or bos in disguise trying to get extra cash? :p
04:42:24 <wks> maltem, seems it doesn't work.  (\x y -> c1 x y `mappend` c2 x y) is of type ( ((), ()) -> ((), ()) -> Ordering )
04:42:59 <bremner> ivanm: I think I would be past page 100 if that was the case. Just a new convert.
04:43:16 <idnar> haha
04:43:22 <ivanm> heh
04:43:34 <wks> a quick (and dirty) to do it is:  compareConcat c1 c2 -> (\x y -> if c1 x y == EQ then c2 x y else c1 x y)
04:43:39 <maltem> :t let c1, c2 :: a -> a -> Ordering; c1 = undefined; c2 = undefined in \x y -> c1 x y `mappend` c2 x y
04:43:40 <lambdabot> forall a. a -> a -> Ordering
04:43:59 <maltem> works for me :)
04:44:10 <Mathematicz> Is haskell do you a compiler or the cmd thing?
04:44:18 <pumpkin> o.O
04:44:22 <olsner> @pl \x y -> f x y `mappend` g x y
04:44:22 <lambdabot> ap (ap . (mappend .) . f) g
04:44:23 <pumpkin> I think the former
04:44:47 <bremner> Mathematicz: parse sentence verb needs cannot?
04:45:04 <pumpkin> yoda is that you?
04:45:08 <maltem> lol
04:45:13 <idnar> haha
04:45:15 <pumpkin> oh wait, understand at least yoda I could
04:45:17 <olsner> Mathematicz: you can do both - if you use ghc, you have an interactive prompt-thingy called ghci and a compiler that can build executables
04:45:41 <Mathematicz> Kk, recommend me a good compiler please?
04:45:48 <pumpkin> Mathematicz: ghc.
04:45:51 <maltem> Feel Mathematicz's thoughts olsner could
04:46:09 <pumpkin> in him, strong the force is
04:46:24 <olsner> maltem: it is the sentence reading - I could it
04:46:27 <Mathematicz> I can't find colleges that teach c++ nvm haskell
04:46:44 <pumpkin> nvm?
04:46:49 <pumpkin> oh
04:46:50 <Mathematicz> nevermind
04:46:50 <bohdan> nevermind?
04:47:06 <Mathematicz> I can't find the download link for ghc?
04:47:10 <Mathematicz> http://www.haskell.org/ghc/download.html
04:47:14 <bohdan> by the way, is there a haskell *textbook*?
04:47:17 <pumpkin> looks like you did
04:47:26 <pumpkin> bohdan: here they use hudak's SOE
04:47:43 <Saizan> Mathematicz: http://www.haskell.org/ghc/download_ghc_6_10_1.html#binaries
04:47:53 <olsner> plenty of universities do teach haskell (but finding out which they are could require a bit of research)
04:48:28 <Mathematicz> Unis do, colleges don't :/
04:48:35 <pumpkin> my university just switched from SICP with scheme to haskell a couple of years ago
04:48:41 <pumpkin> Mathematicz: mine is technically a college, and does
04:48:42 <maltem> bohdan: http://haskell.org/haskellwiki/Books_and_tutorials
04:48:44 <bohdan> pumpkin, nice, google books has a neat preview
04:49:12 <Mathematicz> I'm taking: Computer science, Maths, Further Maths, And I don't know what else, I'm rubbish with science and english(This is at college)
04:49:22 <olsner> any serious CS education should have functional programming in some flavour
04:49:31 <pumpkin> Mathematicz: are you using college in the american sense?
04:49:53 <Mathematicz> after secondary school
04:49:55 <Mathematicz> im from uk
04:50:13 <pumpkin> ah
04:51:01 <Mathematicz> When I get my new PC - 7th - It'll be like a new start for me programming, Haskell lol
04:55:27 <Mathematicz> Prelude> main = putStrLn "Hello, World"
04:55:27 <Mathematicz> <interactive>:1:5: parse error on input `='
04:55:55 <jpcooper> Mathematicz, Edinburgh University teaches Haskell
04:55:58 <jpcooper> along with Nottingham, I believe
04:56:05 <Mathematicz> thats scotland o.O
04:56:08 <Mathematicz> i live newcastle
04:56:16 <Mathematicz> im going to collefe first
04:56:18 <Mathematicz> *college
04:56:23 <jpcooper> Mathematicz, yes, but you may know that Scotland in still in the United Kingdom
04:56:32 <jpcooper> what with your being so close to Scotland
04:56:34 <Mathematicz> true;
04:56:46 <Mathematicz> Prelude> main = putStrLn "Hello, World"
04:56:46 <Mathematicz> <interactive>:1:5: parse error on input `='
04:57:09 <jpcooper> Mathematicz, precede that with "let"
04:57:16 <jpcooper> let main = putStrLn "Hello, World"
04:57:16 <Mathematicz> ?
04:57:20 <Mathematicz> kk
04:57:53 <Mathematicz> I did that, then pressed enter, then it just went prelude> again
04:58:31 <jpcooper> Mathematicz, all you have done is define a function called main
04:58:47 <Mathematicz> How Do I execute it?
04:58:53 <jpcooper> main
04:59:23 <Mathematicz> Kk thanks
05:00:11 <Mathematicz> I'll have to get a book on it
05:00:31 <mercury^> You can read RWH online and if you like it, purchase a copy.
05:00:43 <Mathematicz> yeah i'll purchase later, when i get some money
05:00:56 <Mathematicz> haskell seems like alot to write at first
05:01:07 <mercury^> Huh?
05:01:23 <mercury^> Hello World is pretty tiny compared to the C++ version..
05:01:30 <mercury^> And you have not seen much else yet.
05:01:37 <Mathematicz> I have seen more
05:01:44 <Mathematicz> I saw a e.g. before
05:02:02 <jpcooper> Mathematicz, is your mother language English?
05:02:12 <Mathematicz> yes?
05:02:15 <jpcooper> I believe that there are Haskell channels in various languages
05:02:15 <mercury^> In either case, it is usually a lot less to write than C++.
05:02:17 <jpcooper> okay
05:02:52 <Mathematicz> Probabilys it's jsut because I haven't ever seen Haskell code before
05:03:11 <bremner> Mathematicz: what code have you seen?
05:03:23 <Mathematicz> c, c++, java, php
05:03:33 <Mathematicz> delphi
05:03:45 <pumpkin> delphi :o
05:03:46 * pumpkin faints
05:04:36 <bremner> Mathematicz: I'm pretty sure that haskell is more concise than all that you mentioned. There are many examples in Real World Haskell comparing e.g. Java to Haskell
05:05:15 <Mathematicz> When I read about it i'll most likely pick it up
05:06:19 <bohdan> a short pop quiz :) what was your first complete application that you wrote/took part in writing?
05:06:33 <pumpkin> for everyone?
05:06:47 <mercury^> What do you mean by `complete'?
05:06:56 <Mathematicz> Hello world.
05:07:39 <pumpkin> my first program was a simple program that took a definition of a context-free grammar in EBNF and told you if it accepted all languages _or not_
05:08:15 <Mathematicz> Can I make Haskell play a music file?
05:08:23 <yottis> in haskell or any language?-)
05:08:35 <Mathematicz> Hask
05:08:36 <bohdan> mercury^, no an exercise, something with real world use
05:08:40 <bohdan> in haskell
05:08:55 <pumpkin> yottis: I wrote that in OISC, back in my day we didn't have any of these fancy "programming language" things you speak of
05:09:31 <mercury^> bohdan: Everything I wrote in Haskell was for toying around, but some of those things gave useful output nonetheless.
05:09:35 <mercury^> :s
05:09:41 <pumpkin> I guess my humor was a little subtle
05:09:59 <Mathematicz> I mean is it"easy"
05:10:28 <wks> Mathematicz, I think you can use some kind of interface to call another library and let it play music for you.
05:10:50 <pumpkin> there are things specifically designed to play music in haskell
05:11:02 <pumpkin> http://www.youtube.com/watch?v=xaoLbKWMwoU
05:11:22 <pumpkin> if you're on a reasonable OS, "playing music" is just writing to a dev node anyway :P
05:11:37 <czShadoW> Mathematicz: You can try read LYAH text first, it's good for start: http://learnyouahaskell.com/
05:11:48 <mercury^> Minimal Haskell music, that's surely what Mathematicz had in mind. :>
05:12:03 <bohdan> +1 for LYAH
05:12:51 <yottis> i'm inclined to say that my first real haskell application is still waiting to be born. starting to write something bigger would be good exercise, but i always get the feeling about the way i'm doing stuff currently is incredibly wrong and there must be a much better way to do it
05:13:36 <Mathematicz> Is the Haskell GUI alot simplier than the WIN32 one?
05:13:40 <yottis> call that a steep learning curve if you want; otoh most languages just stop at the sticks and stones level
05:13:56 <ivanm> Mathematicz: ummmmm...... there's no "Haskell GUI"
05:14:10 <ivanm> Haskell can use various graphical toolkits....
05:14:17 <Mathematicz> is there not?
05:14:20 <pumpkin> I wonder if people will stop calling it Win32 once 64-bit processors are more common
05:14:34 <Mathematicz> Oh nvm, on real world Haskell, I meant the thing you download it talks about
05:14:39 <ivanm> Mathematicz: Windows (aka Win32) is an operating system; Haskell is a programming language
05:14:39 <bremner> pumpkin: well, "Win" is already a misnomer, so...
05:15:17 <Mathematicz> im on about WIN32 GUI
05:15:20 <Mathematicz> C
05:15:27 <pumpkin> MFC ftw
05:15:28 <pumpkin> ;)
05:15:35 <pumpkin> epic c++ abuse
05:16:31 <ivanm> Mathematicz: WIN32 GUI /= C
05:16:35 <ivanm> C is another programming language
05:16:36 <Mathematicz> i know
05:16:39 <Mathematicz> :/
05:16:50 <ivanm> Windoes might have it's GUI _written_ in C
05:16:53 <ivanm> but it isn't C
05:16:53 <Mathematicz> How do you pronounce haskell? Has-Kell?
05:17:01 <ivanm> something like that
05:17:04 <mahogny> MFC is really nice. include MFC in any beginner c++ book and make sure they drop c++ and use something else
05:17:09 <pumpkin> I've heard has-kul too
05:17:14 <ivanm> mahogny: lol
05:17:31 <ivanm> @quote VirginiaCurry
05:17:31 <lambdabot> VirginiaCurry says: "You know, Haskell actually never liked the name Haskell." -- Virgina Curry (Haskell B. Curry's widow)
05:17:32 <pumpkin> mahogny: yeah, it's awesome that way :) pity it's not fashionable anymore
05:18:14 <Mathematicz> Paperback: 710 pages o.O
05:18:32 <pumpkin> I tend to get attracted by bigger books
05:18:39 <pumpkin> BBB, I guess
05:18:59 <Mathematicz> As long as I learn Haskell from it I'm not bothered :)
05:19:16 * mahogny is waiting for RWH2: monads strike back
05:19:17 <Mathematicz> The web version doesn't look that big
05:21:16 <Mathematicz> Is ^ read: To the power of?
05:21:27 <bremner> yes
05:21:28 <pumpkin> to the integer power of
05:21:30 <pumpkin> :P
05:21:37 <Mathematicz> :D
05:21:41 <Mathematicz> I like Haskell for math
05:21:46 <Mathematicz> 42 / 0 = Infinity
05:21:53 <pumpkin> ORLY
05:21:57 <Badger> > 42 / 0
05:21:58 <lambdabot>   Infinity
05:22:04 <pumpkin> > 42 / 0 :: CReal
05:22:10 <bremner> > 0/0
05:22:12 <lambdabot>   NaN
05:22:17 <bremner> haha
05:22:18 <stu8ball> Not undefined? :O
05:22:20 <lambdabot>   thread killed
05:24:23 <Mathematicz> what's the inequility operator in Haskell?
05:24:26 <Mathematicz> It's not !=
05:24:38 <mahogny> /=
05:24:49 * bohdan is bored of ':l foobar \n :main' -- is there a one-liner for that?
05:25:38 <bohdan> even, ':r \n :main'
05:25:39 <mahogny> :reload maybe
05:25:49 <bohdan> mahogny, doesn't run main
05:25:53 <mahogny> true that
05:25:59 <mahogny> cuts down foobar at least
05:26:06 <Mathematicz> Prelude> 2009 > 2008.99999999999999999999999999999999999999999999
05:26:06 <Mathematicz> False
05:26:26 <Badger> what
05:26:39 <pumpkin> they're equal
05:26:47 <mahogny> well. if the 9999 continued then haskell would be right :)
05:26:58 <pumpkin> it's also right in the context of floats :P
05:27:04 <Badger> > 2009 > 2008.9999999999999999999999999
05:27:05 <lambdabot>   False
05:27:07 <kaol> > 2009 > (2008.999999999999999999999::Rational)
05:27:09 <Badger> >_>
05:27:09 <lambdabot>   True
05:27:11 <pumpkin> >t 2009 > 2008.99999999999999999999999999999999999999999999 :: CReal
05:27:15 <Mathematicz> Rational?
05:27:20 <pumpkin> > 2009 > 2008.99999999999999999999999999999999999999999999 :: CReal
05:27:22 <Mathematicz> CReal gives me error
05:27:22 <lambdabot>   Couldn't match expected type `CReal' against inferred type `Bool'
05:27:24 <pumpkin> Mathematicz: fraction
05:27:27 <kaol> > 2008.999999999999999999999::Rational
05:27:29 <lambdabot>   2008999999999999999999999%1000000000000000000000
05:27:31 <pumpkin> > 2009 > (2008.99999999999999999999999999999999999999999999 :: CReal)
05:27:33 <lambdabot>   False
05:27:38 <pumpkin> o.O
05:27:40 <stu8ball>  2009 == 2008.999999999999
05:27:40 <stu8ball> False
05:28:17 <Gracenotes>  1 == 2
05:28:19 <Gracenotes> True
05:28:30 <pumpkin> :)
05:28:46 <Mathematicz> I actually like Haskell
05:28:53 <stu8ball> Of course.
05:28:56 <pumpkin> were you expecting not to?
05:29:39 <Mathematicz> Yeah
05:29:46 <idnar> @type 2009 > (2008.9999999999999999999999999 :: ?x)
05:29:46 <Mathematicz> At first glance I didn't
05:29:47 <lambdabot> parse error on input `)'
05:29:53 <idnar> meh
05:29:55 <mahogny> hm. was there a (.) that takes two functions in opposite order?
05:30:09 <Raevel> flip (.) ?
05:30:14 <idnar> @type let x = 2008.9999999999999999999999999 in (2009 > x, x)
05:30:15 <lambdabot> forall t. (Fractional t) => (Bool, t)
05:30:16 <mahogny> well. shorter :)
05:30:21 <Raevel> :*/
05:30:25 <idnar> hmm, no
05:30:27 <beelsebob> let (>) = flip (.)?
05:30:31 <bohdan> how would I print an infinite list in the same way lambdabot does?
05:30:35 <bohdan> > [1..]
05:30:36 <mahogny> considering using ..
05:30:37 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
05:30:43 <mahogny> ah shit. can't use .. :P
05:30:50 <beelsebob> bohdan: you mean with the ... on the end?
05:30:50 <pumpkin> mahogny: don't do it!
05:30:55 <bohdan> beelsebob, yeah
05:31:05 <idnar> bohdan: take 50 (show x) ++ "..." or something ?
05:31:12 <bohdan> and not just for lists?
05:31:21 <pumpkin> that wouldn't grab a full number necessarily though, idnar
05:31:21 <bohdan> > ([1..], [2..])
05:31:23 <beelsebob> what idnar said, but tweaked a bit to show complete last elements
05:31:24 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
05:31:33 <pumpkin> oh
05:31:36 <pumpkin> lambdabot already doesn't bother
05:32:05 <beelsebob> you could do something fun with taking n elements, and checking if it's short enough
05:32:09 <beelsebob> but it would be slow
05:32:21 * mahogny thinks it's time for unicode haskell
05:32:32 <beelsebob> we already have that mahogny
05:32:32 <pumpkin> mahogny: it already is
05:32:47 <Gracenotes> (5+4+(2-(3-(6+1%3))))/(3*(6-2)*(2-7))
05:32:48 <Gracenotes> > (5+4+(2-(3-(6+1%3))))/(3*(6-2)*(2-7))
05:32:49 <pumpkin> @let (♥) = (^)
05:32:52 <lambdabot>   (-43)%180
05:32:52 <bohdan> so I could say ' show' = (take 50) . show '
05:32:53 <lambdabot>  Defined.
05:32:56 <mahogny> hmmm. I thought there used to be heavy resistance against unicode? o_O
05:32:56 <Gracenotes> :/
05:33:04 <pumpkin> > 5♥7
05:33:07 <lambdabot>   78125
05:33:14 <pumpkin> mahogny: not only that
05:33:21 <Mathematicz> let main = putStrLn "Hello World!" (newline) main                      does it have to be main?
05:33:26 <pumpkin> but Chars are super unicode enabled
05:33:29 <pumpkin> > ord maxBound
05:33:31 <lambdabot>   1114111
05:33:39 <Mathematicz> nvm it doesn't
05:33:42 <mahogny> ok. time for some xmodmap:ing :)
05:33:48 <adrian_> but unicode IO is borked
05:33:52 <pumpkin> mahogny: however, that doesn't mean you automatically get utf-8
05:33:52 <Gracenotes> oh, good, twas expected after all.
05:33:57 * Gracenotes departs
05:34:05 <pumpkin> or 16, or whatever encoding you want
05:34:21 <czShadoW> > '♥'
05:34:23 <lambdabot>   '\9829'
05:34:36 <pumpkin> so the internal representation has the correct definition of a character, but it won't necessarily read it in or write it out correctly
05:34:47 <Mathematicz> is there loops in Haskell?
05:34:52 <mahogny> I see
05:34:57 <czShadoW> Mathematicz: No, just recursion.
05:34:58 <pumpkin> Mathematicz: not explicitly
05:35:09 <pumpkin> mahogny: there are libraries with correct encodings though, I think
05:35:17 <pumpkin> I've definitely seen various utf-8s in haskell
05:36:04 <Mathematicz> GHCi > Compiler?
05:36:19 <pumpkin> ghc interactive
05:36:23 <Gracenotes> not always in terms of speed :)
05:36:32 <czShadoW> Heh.
05:36:53 <Mathematicz> "let a =.." what does let stand for/mean? function?
05:36:54 <adrian_> what does:
05:36:56 <adrian_> Codec/Compression/Zlib/Internal.hs:47:7:
05:36:56 <adrian_> Could not find module Codec.Compression.Zlib.Stream':
05:36:57 <adrian_> it is hidden (in package zlib-0.5.0.0)
05:36:58 <adrian_> mean ?
05:37:26 <adrian_> let let's you define a name for an expression
05:37:42 <adrian_> > let aName = 5+6 in aName
05:37:43 <lambdabot>   11
05:38:44 <Mathematicz> I'm going to go, Hopefully i'll have the money to buy the book in this Month
05:39:17 <Mathematicz> Btw, is it oreily who does real world haskell?
05:39:31 <ivanm> Mathematicz: they're the publishers, yes
05:39:47 <Mathematicz> Kk :)
05:39:49 <Mathematicz> Bye
05:40:04 <pejo> adrian, it means that either dependencies is missing in the cabal file or that you forgot a -package, or you should run --make
05:40:32 <Actium> real world haskell is a good book, i have it
05:43:26 <Saizan> adrian_: that you've to add zlib to the build-depends field of the package you're compiling
05:44:26 <adrian_> it's no package I want to compile. I do "import Codec.Compression.Zlib" in one of my sourcefiles
05:49:48 <eu-prleu-peupeu> happy new year Hppl!
05:50:05 <ziman> to you too, eu-prleu-peupeu :)
05:50:13 <eu-prleu-peupeu> my wish for this year, is that my logo wins the competition :)
05:53:39 <Raevel> assuming yours is the unsafePerformIO: you cannot lose
05:54:16 <eu-prleu-peupeu> ahah
05:55:55 <eu-prleu-peupeu> somebody should research a way for people to be fed by monitor radiation... so i could just stay all day in front of the computer
05:58:39 <jonaskoelker> hi all.  I'm trying to understand when I would want to use Data.Function.fix; my experiments are not useful: (drop 1) gives stack overflow and (0 \mapto 0, n \mapto n-1) hangs (apparently)
05:58:58 <mahogny> eu-prleu-peupeu, it's being done. maybe not to that level of application yet though :)
05:59:04 <jonaskoelker> anyone got an example that works?
05:59:19 <jonaskoelker> (fix id) is no fun either :(
06:00:02 <pumpkin> > fix (6:)
06:00:04 <lambdabot>   [6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,...
06:00:28 <jonaskoelker> pumpkin: ah, cool :)
06:00:38 <pumpkin> I even included a smiely in it for you!
06:00:58 <pumpkin> two smilies if you're imaginative
06:00:58 <jonaskoelker> pumpkin: where?
06:01:13 <jonaskoelker> ah
06:01:20 <pumpkin> there's a :) and a (6: !
06:01:31 <jonaskoelker> I was looking in the value...
06:01:53 <adrian_> the wikibook has some examples
06:02:56 <jonaskoelker> wikibook == http://en.wikibooks.org/wiki/Haskell ?
06:03:01 <adrian_> yes
06:03:35 <adrian_> wider theory: fix and recursion
06:05:29 <sereven> jonaskoelker: http://hackage.haskell.org/packages/archive/xmonad-contrib/0.5/doc/html/XMonad-Actions-Submap.html has interesting use of fix to add key sequences to key map for xmonad user interface
06:07:08 <sereven> oops, wrong fix... never mind
06:08:53 <Aperculum> so, does haskell compilers compile to a binary file
06:09:06 <Aperculum> or is it interpreted
06:09:23 <mahogny> ghc compiles, ghci interpretes
06:10:03 <jonaskoelker> adrian_: thanks for the ref
06:10:37 <Aperculum> thanks
06:11:09 <Aperculum> so with ghc I can make standalone executables, just like with c compiler
06:14:23 <bohdan> what exactly is the naming convention around xxs@(x:xs) ?
06:14:42 <bremner> is there a command line way to paste to hpaste.org?
06:14:56 <bohdan> more specifically, is ' foo (x:y:ys) ' following the convention?
06:15:07 <bohdan> or is it (x:x':xs) ?
06:15:25 <jonaskoelker> bremner: http://mauke.ath.cx/stuff/perl/pastebin
06:15:37 <dons> Aperculum: yes, exactly.
06:15:49 <dons> Aperculum: see the 'haskell in 5 steps' on haskell.org for examples
06:16:05 <Aperculum> I've seen it, I wish for more examples
06:16:19 <Aperculum> with explanations
06:16:31 <jonaskoelker> bohdan: I think it's context-dependent, but leaning towards x:x':xs
06:16:37 <ski_> bohdan : i often use `(x0:x1:xs)'
06:17:47 <bohdan> what about xxs -- what does it mean? xs I understand is "plural" of x
06:18:07 <ski_> `xxs' might mean `x' together with `xs'
06:18:16 <bohdan> :)
06:18:31 <bohdan> so then, x0x1xs@(x0:x1:xs) ?
06:18:43 <bohdan> or xx`xs@(x:x':xs) ?
06:19:00 <bohdan> looks awkward
06:19:05 <ski_> i'd do `xs0@(x0:x1:xs)', i think
06:19:24 <ziman> i use xx, yy, ... for aliases :)
06:19:37 <bohdan> ziman, for example?
06:20:19 <ziman> f xx@(x:x':xs) = x + x' + f xs + g xx
06:20:42 <ziman> (this might not be the best convention though)
06:21:08 <bohdan> hm
06:21:14 <bohdan> so what about
06:21:26 <bohdan> f xs 0 = ...
06:21:31 <bohdan> f (x:xs) n = ...
06:21:38 <bohdan> is the first 'xs' right?
06:21:48 <bohdan> why isn't it xxs for instance
06:21:52 <kig> (x:y:rest)
06:22:10 <bohdan> maybe a better example, f xs 0 = ...; f xxs@(x:xs) = ...
06:22:17 <ski_> bohdan : because it might be `[]' ?
06:22:39 <bohdan> ok fair enough
06:22:48 <idnar> bohdan: xs is just the plural of x
06:23:01 <ziman> f customers 0 = ... ; f (customer:customers) n = ...
06:23:02 <bohdan> but in the first case xs is the whole argument, whereas in the second case it's the tail of the argument
06:23:09 <idnar> so I don't see any reason why you couldn't call a whole list xs, the same as the tail of the list
06:23:22 <idnar> that's sort of the whole point; the tail of the list is a list itself
06:23:45 <idnar> now, if you need to refer to the list itself at the same time as the tail of the list, then maybe you need a different name
06:23:55 <idnar> such as xxs
06:24:25 <bohdan> I'm trying to point out that in one case xs is the whole argument and in the other just the tail
06:24:33 <bohdan> ooh I get it
06:24:49 <bohdan> no I don't :)
06:24:54 <bohdan> ok nevermind
06:25:02 <idnar> bohdan: I think of "xs" as just meaning "a list of x"
06:25:15 <bohdan> like hungarian notation of sorts?
06:25:22 <opqdonut> indeed
06:25:55 <idnar> that list might just be an argument, or it might be the tail of some other list, or maybe even the sorted form of some list, or whatever
06:26:37 <bohdan> it's still kind of weird like writing 'foo a b 0 = ...; foo b a 1 = ...'
06:27:39 <wks> that's what mathematicians would like to write
06:27:43 <wks> fib 0 = 1
06:27:50 <wks> fib n = n*fib (n-1)
06:28:07 <wks> oh, seems a serious mistake
06:28:20 <Gracenotes> s/fib/factorial/
06:36:30 <bohdan> I'm looking at http://www.haskell.org/haskellwiki/99_questions/11_to_20
06:36:40 <bohdan> e.g. problems 16.17
06:36:51 <bohdan> isn't it more natural to take the list as the last argument?
06:38:08 <Cale> bohdan: yes
06:38:51 <Cale> bohdan: It didn't matter in the original lisp version, but in Haskell, it's probably more natural to take the integer first.
06:40:11 * ski_ wonders why the alternative iterative solution to problem 16 needlessly carries `count' around ..
06:40:31 <Cale> Good question :)
06:40:35 <bohdan> @pl \xs n -> (take n xs, drop n xs)
06:40:35 <lambdabot> ap (ap . ((,) .) . flip take) (flip drop)
06:40:39 <bohdan> @pl \n xs -> (take n xs, drop n xs)
06:40:39 <lambdabot> ap (ap . ((,) .) . take) drop
06:41:19 <ski_> @type splitAt
06:41:21 <lambdabot> forall a. Int -> [a] -> ([a], [a])
06:45:34 <hcube> is here the Hpysics guy?
06:46:02 <ski_> also, the last solution of problem 17 doesn't handle the `split [] n' case, for `n /= 0'
06:48:27 <bohdan> ski_, but that's expected
06:48:35 <bohdan> isn't it an error?
06:48:48 <ski_> > splitAt 10 "abc"
06:48:50 <lambdabot>   mueval: Prelude.read: no parse
06:48:50 <lambdabot>  mueval: GhcException mkTopLevEnv: not a hom...
06:49:43 <ski_> i get `("abc","")' at home
06:49:47 <ski_> also
06:49:53 <bohdan> "the length of the first part is given", if you're asked to return a tuple with first result of length n but you don't have N items
06:49:56 <bohdan> then it's an error
06:50:01 <ski_> > (\n xs -> (take n xs,drop n xs)) 10 "abc"
06:50:02 <lambdabot>   ("abc","")
06:50:41 <bohdan> ski_, then those solutions are incorrect :)
06:50:43 <ski_> bohdan : hm .. well i think i'd say it isn't specified :)
06:50:57 * ehird facepalm, somebody just linked to http://lisperati.com/landoflisp/ as their actual argument against purity
06:51:05 <bohdan> in the same way recursive solution doesn't handle split "abc" 4
06:51:08 <int-e> > splitAt 10 "abc"
06:51:09 <ski_> if so, all thouse solutions should be ok
06:51:10 <lambdabot>   ("abc","")
06:51:12 <sampointon> bohdan: shouldn't `take 99 "foo"` be an error too then?
06:51:13 <int-e> weird
06:51:15 <bohdan> it doesn't handle split 1 []
06:51:31 <bohdan> sampointon, no for that is not the definition of take
06:51:53 <bohdan> and the statement that splitAt is the same function is incorrect
06:52:30 <bohdan> it's a very similar function yes
06:52:37 <bohdan> but not the same :)
06:52:51 <sampointon> hmm. Documentation bug then
06:53:11 <ski_> it is the same function, under the precondition that the given (non-negative) number `n' is not greater than the length of the given list
06:55:04 <bohdan> also split as defined in the solution is broken for this case: fst $ split [1..] (-10)
06:55:47 <bohdan> funny that it shows an error for smaller lists
06:59:13 <sampointon> what's the most sensible way of having a database store a lot of STM state? Right now I'm manually keeping track of TVars that are dirty and need to be updated in the database, and having a thread in the background writing the new values to the database
07:00:45 <sampointon> plus not all of the in-memory state needs to (or should) be stored, and it's stored in a more-or-less normalised way in the database, but not in memory
07:02:28 <dons> hey all.
07:02:40 <dons> sampointon: hmm. sounds like a big design question.
07:02:51 <dons> there are some STM-backed storage ideas on hackage you could look at
07:05:05 <Axman6> hey dons
07:05:29 <Axman6> got my copy of RWH the other day, i'm really enjoying it :)
07:08:18 <dons> yay
07:09:37 <bohdan> I don't understand why an accumulator is needed for the iterative solution of problem 18 - my own solution: ' slice 1 0 _ = []; slice 1 e (x:xs) = x : slice 1 (e-1) xs; slice s e (x:xs) = slice (s-1) (e-1) xs '
07:10:10 <Axman6> dons: still a little disappointed it's ot a signed copy though :P
07:10:11 <dons> you don't need an accumulator if you're going to recurse under the (:) constructor
07:10:21 <dons> Axman6: hah. yeah, sorry about that.
07:11:07 <Axman6> dons: btw, i found the explanation about the difference between left and right folds excellent, i never really knew what the difference was
07:11:35 <luite> is there a data structure that can be converted cheaply (without copying) to a Ptr CInt, but still has a somewhat usable pure interface?
07:11:46 <bohdan> dons, is there a reason for the sample solution use it?
07:12:08 <dons> bohdan: well, both are valid solutions in haskell
07:12:18 <dons> luite: ByteString ?
07:12:33 <dons> luite: you probably want a storable array of some kind
07:13:46 <luite> dons: I currently use a UArr Int, but I copy it using pokeArray
07:14:20 <luite> but the conversion via a list seems to have some overhead
07:14:44 <Axman6> luite: use more C
07:14:45 <Axman6> >_>
07:15:15 <dons> luite: oh, interesting. UArr from uvector?
07:15:28 <dons> yes, i've not implemented the efficient conversion ops yet.
07:15:41 <Axman6> oh hooray, one of my suggestions is at the top of the haskell_proposals subreddit
07:15:42 <dons> i think the best we can do to get a Ptr is via a memcpy
07:15:56 <luite> Axman6: I thought about moving more of my code to C, because I can't get the haskell code fast enough...
07:16:10 <Axman6> aww :(
07:16:22 <dons> luite: well, converting via lists isn't good.
07:16:24 <luite> Axman6: but I did do this thing in haskell to learn more about haskell FFI and optimization :)
07:16:27 <dons> but what are you trying to do?
07:17:01 <Axman6> luite: yeah i did that recently, it was pretty fun trying to speed uo both the C and haskell versions of the same function
07:18:33 <luite> dons: I have a foreign function, that modifies an int* (about 1000 elements). My haskell program uses UArr Int, so when I call the C function, I convert it to a Ptr Int, have the C function modify it, and then convert back to a new UArr Int
07:20:25 <luite> I also have a haskell function with the same functionality, but it's not nearly as fast as the C one, as it relies heavily on pointer updates, my haskell version runs in ST, but doesn't use pointers, only MUArr and STUArray
07:22:46 <Axman6> hmm, i was just looking at http://en.wikipedia.org/wiki/Rope_(computer_science) (after seeing the haskell_proposals proposal), and i was wondering, could each node not also contain thew number of characters it contains? updating when you concatenate would be simple, just add the left and right lengths, which would make the indexing easier
07:23:16 <luite> but I find it rather difficult to make my haskell program fast, random number generation currently has a huge overhead compared to my C program
07:23:27 <Axman6> even better the nodes could contain the lengths of the left and right leaves separately
07:24:04 <int-e> Axman6: as a refinement, each node could contain the length of its left child
07:24:16 <Axman6> luite: seen http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mersenne-random (written by dons)
07:24:26 <luite> Axman6: that's what I use
07:24:48 <Axman6> int-e: ah yes, that would save some storage overhead too wouldn't it, nice work :)
07:24:52 <int-e> Axman6: the idea being to pass down the total length of the subtree as you walk down the tree.
07:26:27 <luite> Axman6: but after wrapping the unsafeInterleaveIO list of randoms in a monad, there is quite a bit of overhead compared to using the samen rng directly in C, which is at least 10x faster
07:27:48 <int-e> luite: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mersenne-random-pure64 might be a better fit.
07:28:57 <knapr> cis it possible to add Hindley-Milner type inference to a lisp?
07:29:10 <schme> knapr: Yes.
07:31:16 <pierre-> hello
07:31:25 <schme> Hello the pierre-
07:31:50 <pierre-> what is the easiest way to read a string like "1,234.0" to float?
07:32:19 <centrinia> > read $ filter (/= ',') "1,234.0"
07:32:20 <lambdabot>   * Exception: Prelude.read: no parse
07:32:28 <Axman6> centrinia: damn, beat me to it
07:32:32 <int-e> defaulting--
07:32:33 <ziman> > (read . filter (/= ',') $ "1,234") :: FLoat
07:32:34 <lambdabot>       Not in scope: type constructor or class `FLoat'
07:32:37 <int-e> > read "()"
07:32:39 <lambdabot>   ()
07:32:39 <ziman> > (read . filter (/= ',') $ "1,234") :: Float
07:32:41 <lambdabot>   1234.0
07:32:49 <pierre-> heh, lol, thanks :-)
07:33:12 <centrinia> > (read . filter (/= ',') :: String -> Float) "1,234.0"
07:33:15 <lambdabot>   1234.0
07:33:38 <int-e> aww,  read "1.0" :: Rational  doesn't work.
07:33:45 <sampointon> that'll break with i18n though
07:34:10 <centrinia> > (read . takeWhile (/= '.') :: String -> Rational) "1.0"
07:34:12 <lambdabot>   * Exception: Prelude.read: no parse
07:34:19 <centrinia> What the?
07:34:24 <paper_cc> > let readF = read . delete ',' :: String -> Float in readF "1,234.0"
07:34:26 <lambdabot>   1234.0
07:34:27 <centrinia> > (read . takeWhile (/= '.') :: String -> String) "1.0"
07:34:29 <lambdabot>   "* Exception: Prelude.read: no parse
07:35:01 <centrinia> > (takeWhile (/= '.')) "1.0"
07:35:03 <lambdabot>   "1"
07:35:19 <luite> int-e: hm, I have tried that one before, but it was quite a bit slower than the impure mersenne twister.
07:35:26 <bohdan> paper_cc, delete doesn,t work for 1,000,000,000.0
07:36:15 * paper_cc makes an unpleasant grr to Data.List
07:36:36 <centrinia> > let readF = read . until (not . elem ',') delete ',' :: String -> Float in readF "1,234,567.89"
07:36:38 <lambdabot>   Couldn't match expected type `[Char]'
07:36:46 <centrinia> > let readF = read . until (not . elem ',') . delete ',' :: String -> Float in readF "1,234,567.89"
07:36:48 <lambdabot>   Couldn't match expected type `[Char] -> [Char]'
07:37:02 <centrinia> > let readF = read . until (not . elem ',') (delete ',') :: String -> Float in readF "1,234,567.89"
07:37:04 <lambdabot>   1234567.9
07:37:07 <centrinia> Yay.
07:37:19 <centrinia> Is that rounding?
07:37:23 <centrinia> > let readF = read . until (not . elem ',') (delete ',') :: String -> Float in readF "1,234,56.89"
07:37:25 <lambdabot>   123456.89
07:37:39 <Axman6> what's wrong with filter (/= ',')?
07:37:49 <centrinia> Axman6, it has been done already.
07:38:06 <Axman6> heh
07:38:38 <Axman6> centrinia: this is not perl, so do not try and make unreadable, unnecessary code unless we really have to!
07:38:56 <centrinia> @pl let readF = read . until (not . elem ',') (delete ',') :: String -> Float in readF
07:38:57 <lambdabot> (line 1, column 56):
07:38:57 <lambdabot> unexpected ":"
07:38:57 <lambdabot> expecting variable, "(", ".", space, operator, ";" or "in"
07:38:57 <lambdabot> ambiguous use of a left associative operator
07:39:07 <adrian_> > let readF = read.filter (elem "0123456789.")
07:39:08 <lambdabot>   <no location info>: parse error on input `;'
07:39:30 <adrian_> > let readF = read.filter (elem "0123456789.") in readF "123,452.0"
07:39:31 <lambdabot>   Couldn't match expected type `Char'
07:39:51 <adrian_> > let readF = read.filter (`elem` "0123456789.") in readF "123,452.0"
07:39:53 <lambdabot>   * Exception: Prelude.read: no parse
07:40:10 <adrian_> > filter (`elem` "0123456789.") "123,452.0"
07:40:11 <lambdabot>   "123452.0"
07:40:20 <centrinia> adrian_ you need to annotate the type of readF.
07:40:24 <adrian_> ah
07:40:48 <int-e> luite: if "before" was before version 0.2, I'd try it again. (also be sure to stay away from the Random instance; use the random<type> functions instead.)
07:40:52 <centrinia> > let readF = read . filter (`elem` "012345679.") in readF "-123,452.1"
07:40:54 <lambdabot>   * Exception: Prelude.read: no parse
07:41:01 <centrinia> > let readF = read . filter (`elem` "012345679.") :: String -> Float in readF "-123,452.1"
07:41:03 <lambdabot>   123452.1
07:41:16 <centrinia> > let readF = read . filter (`elem` "012345679.+-") :: String -> Float in readF "-123,452.1"
07:41:18 <lambdabot>   -123452.1
07:41:21 <centrinia> > let readF = read . filter (`elem` "012345679.+-") :: String -> Float in readF "-123,452.1e51"
07:41:23 <lambdabot>   -123452.15
07:41:31 <centrinia> > let readF = read . filter (`elem` "012345679.+-e") :: String -> Float in readF "-123,452.1e51"
07:41:33 <lambdabot>   -Infinity
07:41:48 <luite> int-e: oh, I did use the Random instance. guess I'll try it again then
07:41:49 <adrian_> for small values of infinity
07:42:55 <olsner> > minimum [-Infinity, Infinity]
07:42:56 <lambdabot>   Not in scope: data constructor `Infinity'Not in scope: data constructor `In...
07:43:01 <Axman6> > let readF = read . filter (`elem` "012345679.+-e") :: String -> Double in readF "-123,452.1e51"
07:43:02 <lambdabot>   -1.234521e56
07:43:09 <Axman6> > let readF = read . filter (`elem` "012345679.+-e") :: String -> Double in readF "-123,452.1e100"
07:43:11 <lambdabot>   -1.234521e105
07:43:17 <Actium> > (-Infinity) + Infinity
07:43:18 <Axman6> > let readF = read . filter (`elem` "012345679.+-e") :: String -> Double in readF "-123,452.1e200"
07:43:18 <lambdabot>   Not in scope: data constructor `Infinity'Not in scope: data constructor `In...
07:43:20 <lambdabot>   -1.234521e205
07:43:25 <centrinia> Axman6, please call that readD ;)
07:43:32 <Axman6> > let readD = read . filter (`elem` "012345679.+-e") :: String -> Double in readF "-123,452.1e200"
07:43:34 <lambdabot>   Not in scope: `readF'
07:43:38 <Axman6> > let readD = read . filter (`elem` "012345679.+-e") :: String -> Double in readD "-123,452.1e200"
07:43:40 <lambdabot>   -1.234521e205
07:43:43 <Actium> how does on specify infinity?
07:43:44 <Axman6> > let readD = read . filter (`elem` "012345679.+-e") :: String -> Double in readD "-123,452.1e2000"
07:43:45 <lambdabot>   -Infinity
07:44:02 <Actium> > tail [1..]
07:44:03 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
07:44:07 <Axman6> > maxBound :: Double
07:44:08 <lambdabot>       No instance for (Bounded Double)
07:44:08 <lambdabot>        arising from a use of `maxBound...
07:44:15 <Actium> > head [..1]
07:44:16 <lambdabot>   <no location info>: parse error on input `..'
07:44:18 <Axman6> @instances Bounded
07:44:18 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Dual a, Int, Ordering, Product a, Sum a
07:44:39 <centrinia> What is an All?
07:45:06 <EvilTerran> ?src All
07:45:06 <lambdabot> Source not found. Maybe you made a typo?
07:45:12 <Actium> whats the function for getting the last element in a list?
07:45:12 <roconnor> > all True
07:45:14 <lambdabot>   Couldn't match expected type `a -> Bool'
07:45:16 <roconnor> > All True
07:45:18 <EvilTerran> newtype All = All Bool
07:45:18 <lambdabot>   All {getAll = True}
07:45:29 <EvilTerran> well, = All { getAll :: Bool }
07:45:30 <olsner> centrinia: it's a newtype with a monoid instance iirc
07:45:38 <EvilTerran> ?src All mempty
07:45:38 <lambdabot> Source not found. I am sorry.
07:45:41 <EvilTerran> grr
07:45:49 <roconnor> > all mempty
07:45:50 <lambdabot>       Overlapping instances for Show ([a] -> Bool)
07:45:50 <lambdabot>        arising from a use ...
07:45:56 <EvilTerran> > mempty :: All
07:45:58 <roconnor> > getAll mempty
07:45:58 <lambdabot>   All {getAll = True}
07:46:00 <lambdabot>   True
07:46:11 <Actium> > last [1..]
07:46:14 <roconnor> > getAny mempty
07:46:23 <centrinia> Actium, please don't kill the thread.
07:46:25 <lambdabot>   mueval: Prelude.read: no parse
07:46:30 <lambdabot>   thread killed
07:46:35 <int-e> > getAll . mconcat . map All $ [True, True]
07:46:37 <lambdabot>   True
07:46:42 <int-e> > getAll . mconcat . map All $ [True, False]
07:46:44 <lambdabot>   False
07:46:44 <Actium> erk, sorry
07:46:53 <int-e> > getAny . mconcat . map Any $ [True, False] -- and so on
07:46:54 <lambdabot>   True
07:46:56 <EvilTerran> > mplus <$> [All False, All True] <*> [All False, All True]
07:46:58 <lambdabot>   Couldn't match expected type `m a' against inferred type `All'
07:47:04 <EvilTerran> > mappend <$> [All False, All True] <*> [All False, All True]
07:47:05 <lambdabot>   [All {getAll = False},All {getAll = False},All {getAll = False},All {getAll...
07:47:22 <EvilTerran> > (^>) -- do we have these?
07:47:23 <lambdabot>   Not in scope: `^>'
07:47:30 <EvilTerran> , (^>) {- ...? -}
07:47:32 <olsner> @ty mconcat
07:47:35 <lambdabot> forall a. (Monoid a) => [a] -> a
07:47:36 <lunabot>  luna: Not in scope: `^>'
07:47:38 <centrinia> Why not define { getAll :: a -> Bool; getAll = const True }
07:47:38 <EvilTerran> hm
07:47:42 <int-e> @index (^>)
07:47:42 <lambdabot> bzzt
07:47:51 <int-e> EvilTerran: what is that supposed to do?
07:48:16 <EvilTerran> int-e, (<^) and (^>) appropriately defined so that x <^f^> y = f <$> x <*> y
07:48:49 <EvilTerran> centrinia, because All{ getAll = False } is a constructible value (as above)?
07:49:04 <int-e> x <^(+)^> y  looks silly.
07:49:09 <EvilTerran> yes
07:49:09 <Actium> lol
07:49:27 <Actium> arent backquotes useful there?
07:49:27 <EvilTerran> x <^zip^> y, say, doesn't look as bad, though
07:49:49 <Actium> is this like x `zip` y ?
07:49:53 <EvilTerran> Actium, kinda
07:50:01 <EvilTerran> it'd be x `liftM2 zip` y, if that were valid
07:50:08 <int-e> Actium: not really, because `` is part of the lexical syntax
07:51:08 <EvilTerran> it's faking arbitrary infix expressions via trickery with infix names
07:51:19 <centrinia> Is there a Mersenne Twister that has a period of 2^43112609-1  ?
07:51:34 <int-e> I guess I like <$> and <*> well enough.
07:51:54 <Actium> ah, "infix expressions" rather than just infixing a function?
07:52:06 <EvilTerran> i'd be inclined to call the two sides («) and (»), if they didn't tend to be a pain to input
07:52:17 <adrian_> > 1/0
07:52:18 <lambdabot>   Infinity
07:52:27 <adrian_> > -1/+
07:52:27 <Actium> > -(1/0)
07:52:29 <lambdabot>   <no location info>: parse error on input `;'
07:52:29 <lambdabot>   -Infinity
07:52:35 <adrian_> > -1/0
07:52:36 <lambdabot>   -Infinity
07:52:47 <Actium> > (-1/0) + 1/0
07:52:49 <lambdabot>   NaN
07:52:55 <paper_cc> @ty 1/0
07:52:57 <lambdabot> forall t. (Fractional t) => t
07:53:02 <adrian_> let Infinity = 1/0 in Infinity - Infinity
07:53:05 <EvilTerran> ?let infixl 1 «, »; («) = flip (<$>); (») = (<*>) in [1,2,3] «(,)» [4,5,6]
07:53:05 <lambdabot>   Illegal character ''\171''
07:53:10 <adrian_> >let Infinity = 1/0 in Infinity - Infinity
07:53:10 <EvilTerran> > let infixl 1 «, »; («) = flip (<$>); (») = (<*>) in [1,2,3] «(,)» [4,5,6]
07:53:12 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
07:53:29 <adrian_> > let Infinity = 1/0 in Infinity - Infinity
07:53:30 <lambdabot>   Not in scope: data constructor `Infinity'Not in scope: data constructor `In...
07:53:41 <adrian_> > let infinity = 1/0 in infinity - infinity
07:53:42 <EvilTerran> > (1/0) - (1/0)
07:53:43 <lambdabot>   NaN
07:53:44 <lambdabot>   NaN
07:53:44 <int-e> @index (<<)
07:53:45 <lambdabot> Text.Html
07:54:11 <byorgey> > 0/0 == 0/0
07:54:13 <lambdabot>   False
07:54:14 <bohdan> how would I get an infinite list of random numbers?
07:54:16 <Actium> > 1/(1/0)
07:54:17 <lambdabot>   0.0
07:54:21 <EvilTerran> > 1/0 == 2/0
07:54:22 <lambdabot>   True
07:54:24 <Actium> bohdan: [1..]
07:54:25 * adrian_ hates floating point
07:54:30 <byorgey> @type randoms
07:54:32 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
07:54:34 <Actium> oh. random
07:54:35 <EvilTerran> Actium, they're not random!
07:54:38 <adrian_> bohdan: randomRs
07:54:38 <Actium> ok ok lol
07:54:44 <byorgey> bohdan: use the 'randoms' or 'randomRs' functions
07:54:51 <centrinia> > randoms (mkStdGen 42) :: [Int]
07:54:53 <lambdabot>   [-3907187990116499535,-2519438828217931933,-8264534369199619667,86887135830...
07:54:55 <EvilTerran> ?src randoms
07:54:55 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
07:54:57 <bohdan> 'preudorandom'
07:54:57 <int-e> @type newStdGen >>= randomRs (1, 42)
07:54:59 <lambdabot>     Couldn't match expected type `IO b' against inferred type `[t]'
07:54:59 <lambdabot>       Expected type: StdGen -> IO b
07:54:59 <lambdabot>       Inferred type: StdGen -> [t]
07:55:04 <byorgey> [4,4..]  -- chosen by dice roll, guaranteed random
07:55:09 <int-e> @type newStdGen >>= flip randomRs (1, 42)
07:55:10 <lambdabot>     Couldn't match expected type `StdGen'
07:55:10 <lambdabot>            against inferred type `(a, a)'
07:55:10 <lambdabot>       Expected type: StdGen -> b -> c
07:55:10 <adrian_> > randomRs (-10,10) (mkStdGen 42)
07:55:12 <lambdabot>   [4,2,-3,-6,7,0,8,-5,-1,-10,-10,-4,-10,1,-8,-3,-2,-6,-1,-10,7,2,-10,-9,-9,-9...
07:55:22 <Badger> ooh
07:55:25 <adrian_> haha, it start's with 4,2
07:55:53 <bohdan> which module is this?
07:56:00 <adrian_> System.Random
07:56:04 <byorgey> @index randoms
07:56:04 <lambdabot> System.Random
07:56:11 <int-e> @type randomRs (1, 42) <$> newStdGen
07:56:11 <bohdan> it's not here -- http://haskell.org/ghc/docs/latest/html/libraries/base/index.html
07:56:12 <lambdabot> forall t. (Random t, Num t) => IO [t]
07:56:38 <Actium> IO?
07:56:49 <centrinia> > let rs = randoms (0,9) (mkStdGen 42) :: [Int] in map (\x -> (head x, length x)) . group . sort $ (take 5000 rs)
07:56:49 <byorgey> bohdan: it's not in the base module
07:56:51 <lambdabot>   Couldn't match expected type `StdGen -> [Int]'
07:56:57 <centrinia> > let rs = randomRs (0,9) (mkStdGen 42) :: [Int] in map (\x -> (head x, length x)) . group . sort $ (take 5000 rs)
07:56:59 <bremner> hxt question: to output xml document in some other format, I need to define my own writeDocument?
07:57:00 <lambdabot>   [(0,510),(1,503),(2,477),(3,491),(4,502),(5,480),(6,531),(7,486),(8,505),(9...
07:57:17 <bohdan> aha
07:57:20 <centrinia> Weird, 2 is occurring less often than most of the others.
07:57:21 <byorgey> bohdan: just go to  http://haskell.org/ghc/docs/latest/html/libraries/
07:57:27 <bohdan> http://haskell.org/ghc/docs/latest/html/libraries/ - here
07:57:31 <centrinia> > let rs = randomRs (0,1) (mkStdGen 42) :: [Int] in map (\x -> (head x, length x)) . group . sort $ (take 50000 rs)
07:57:32 <bohdan> or right :)
07:57:34 <lambdabot>   [(0,24904),(1,25096)]
07:57:36 <bohdan> thanks byorgey
07:57:45 <byorgey> sure =)
07:57:59 <int-e> Actium: newStdGen is in IO; it uses some global state to create a different generator each time.
07:58:12 <Actium> thanks, int-e
07:58:32 * centrinia performs a spectral test on outputs of randomRs.
07:58:36 <int-e> (obviously they'll have to repeat eventually)
07:59:06 <SamB_XP> I thought it used the time or something ;-P
07:59:14 <Actium> makes sense to use a monad for it since it needs to be different for each request. got it
07:59:15 <int-e> SamB_XP: only for seeding.
07:59:18 <SamB_XP> (still, they can't ALWAYS be different)
07:59:24 <centrinia> int-e: What prevents someone from using a random number generator?
07:59:41 <Axman6> :t (&&&)
07:59:43 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:59:43 <SamB_XP> centrinia: well, those are ALL in IO
07:59:55 <Axman6> :t  ?f &&& ?g
07:59:56 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a, ?g::a b c', ?f::a b c) => a b (c, c')
07:59:57 <SamB_XP> since, you know, random numbers can't be deterministicly generated
08:00:05 <int-e> centrinia: purity means, basically, that all randomness must come from IO
08:00:07 <Axman6> bleh, of course
08:00:14 <centrinia> SamB_XP, why be limited by determinism? :)
08:00:26 <int-e> centrinia: you can cheat, of course.
08:00:42 <centrinia> What is wrong with hooking up a Giger counter to your random number generator? :)
08:01:02 <Actium> click click click
08:01:17 <centrinia> Actium, the intervals between the clicks are supposed to be random.
08:01:22 <Actium> they were
08:01:25 <redditbot> Simulating Dependent Types with Guarded Algebraic Datatypes
08:01:59 <Actium> i made no suggestion as to the delay between those clicks
08:02:28 <Badger> click   click            clickclickclick  click click    click
08:02:35 <int-e> centrinia: making a pure computation actually nondeterministic is easily fatal, because the language actually makes no guarantee that a closure won't be evaluated twice. the ghc parallel RTS will evaluate thunks twice occasionally.
08:02:37 <Badger> click    click                                     click click
08:02:44 <Badger> boing.
08:03:32 <SamB_XP> centrinia: nothing is wrong with it!
08:03:38 <SamB_XP> but it puts your computation in IO
08:04:23 <centrinia> Oh I see.
08:06:47 <Mathematicz> Is GHCi code diffo compared to if I used a compiler/IDE?
08:08:44 <Axman6> Mathematicz: ghci compiles code to bytecode, so it'll run slightly slower than the compiled program, but faster than if it were interpreted (or, at least this is what i've heard)
08:09:13 <Cale_> GHCi will load .o files if you've previously compiled the code with GHC, otherwise it uses a bytecode interpreter like Axman6 mentioned
08:09:39 <Mathematicz> Kk
08:09:47 <Axman6> hooray, i do know stuff :)
08:09:52 <Mathematicz> I'm hoping to get the book by Febuary/Mid Jan
08:09:54 <SamB_XP> Axman6: wait a minute
08:10:00 <SamB_XP> what is this "interpreted" you speak of ?
08:10:19 <Axman6> like ruby
08:10:25 <Cale_> [1 of 1] Compiling Main             ( Free.hs, interpreted )
08:10:28 <SamB_XP> doesn't ruby have bytecode too ?
08:10:41 <Mathematicz> is main the standard?
08:10:42 <Cale_> hehe
08:10:45 <Mathematicz> just "a" works fine?
08:10:51 <Cale_> What?
08:10:55 <SamB_XP> Cale_: he was talking about compiling to bytecode and interpreting as if they were entirely different ;-P
08:11:05 <Axman6> SamB_XP: i didn't think so
08:11:18 <sampointon> SamB_XP: MRI used to use the parse tree directly, it didn't compile at all
08:11:24 <SamB_XP> hmm
08:11:49 <SamB_XP> some interpreters actually DO interpret the source text more-or-less directly
08:11:58 <Mathematicz> let a = putStrLn "Hai" works fine, but is let main the standard?
08:12:03 <SamB_XP> (though many of these actually store it in tokenized form)
08:12:46 <SamB_XP> I wonder what kind of datastructure a typical BASIC interpreter uses to store the program ...
08:12:52 <Axman6> Mathematicz: what do you mean?
08:13:09 <Botje> Mathematicz: yes, i believe the main function is the one that gets compiled as the actual entry point.
08:13:09 <Mathematicz> Is using main the default syntax?
08:13:19 <SamB_XP> (so it can handle GOTO / GOSUB efficiently, etc)
08:13:35 <SamB_XP> where by "typical" I mean 8-bit era
08:13:51 <Cale_> Mathematicz: main is an IO action which is defined by compiled Haskell programs and will be carried out when the program is run.
08:13:55 <Mathematicz> Can I combine Haskell and OPENGL?
08:14:00 <Actium> QBasic stored the source files in tokenized form....
08:14:15 <Axman6> Mathematicz: yep, using HOpenGL, or HGL
08:14:19 <pierre-> how can I get convert UTCTime to Foreign.C.CTime?
08:14:58 <SamB_XP> Mathematicz: why not ?
08:15:00 <pierre-> I tried to use fromEnum, but results are quite strange
08:15:06 <SamB_XP> pierre-: heh
08:17:39 <pierre-> some googling helped: there's fromInteger . round
08:18:29 <SamB_XP> pierre-: that still sounds like a crazy way to convert time
08:22:44 <arjanb> it seems to me Data.Time module is unfinished
08:23:10 <SamB_XP> arjanb: are there still governments?
08:23:12 <Mathematics`> Is the new o'reily real world haskell different to the one by bryan o sullivan and them?
08:23:17 <SamB_XP> if the answer is yes, you are probably right
08:23:28 <SamB_XP> Mathematics`: it is the very same
08:23:57 <SamB_XP> Mathematics`: it's RWH 1.1 (books don't come in 1.0)
08:24:01 <Axman6> Mathematics`: the new one is the only one
08:24:15 <Mathematics`> Kk
08:24:16 <Axman6> came out on december 1st
08:24:21 <Mathematics`> 5th?
08:24:22 <SamB_XP> the one on the site is RWH HEAD, I think
08:25:00 <Mathematics`> I didn't get answer before, maybe because I left, Can I combine Haskell and OpenGL?
08:25:08 <SamB_XP> Mathematics`: why not ?
08:25:21 <Mathematics`> why not what
08:25:22 <Axman6> "Mathematicz: yep, using HOpenGL, or HGL"
08:25:31 <Mathematics`> Kk
08:25:41 <bohdan> > random getStdGen
08:25:42 <leadnose> haskell has a very nice opengl binding
08:25:43 <lambdabot>       No instance for (Typeable StdGen)
08:25:43 <lambdabot>        arising from a use of `show' a...
08:25:44 <bohdan> why?
08:25:50 <Mathematics`> http://www.amazon.co.uk/Real-World-Haskell-Code-Believe/dp/0596514980/ref=sr_1_1?ie=UTF8&s=books&qid=1230827080&sr=8-1
08:26:07 <gio123> 12 stone is howmany kg?
08:26:12 <SamB_XP> bohdan: well, lambdabot doesn't allow IO computations to be run
08:26:20 <SamB_XP> it tries to display their type instead
08:26:26 <Axman6> gio123: google 12 stone in kg and you'll know
08:26:29 <SamB_XP> > putStrLn "Hi!"
08:26:30 <lambdabot>   * Exception: "<IO ()>"
08:26:50 <Mathematics`> I keep getting mixed up between putStrLn and letStrLn because of let main =..
08:26:57 <bohdan> @type random getStdGen
08:26:58 <lambdabot>     No instance for (RandomGen (IO StdGen))
08:26:58 <lambdabot>       arising from a use of `random' at <interactive>:1:0-15
08:26:58 <lambdabot>     Possible fix:
08:26:59 <Olathe> > unsafePerformIO
08:26:59 <gio123> 12 stone is howmany kg?
08:27:00 <lambdabot>   Not in scope: `unsafePerformIO'
08:27:07 <Botje> bohdan: getSstGen is an IO action
08:27:12 <Botje> *getStdGen
08:27:14 <Mathematics`> Btw, does Haskel have built in networking?
08:27:16 <Olathe> gio123: Google might know.
08:27:23 <Botje> Mathematics`: yes.
08:27:34 <Mathematics`> :)
08:27:38 <SamB_XP> bohanlon: oh, that's because you need to use bind (>>=, or <- in a do block)
08:27:39 <gio123> yes, but I have to slow internet cant open browser
08:27:46 <bohdan> Botje, url for the doc? :)
08:27:50 <Axman6> Mathematics`: well, it has networking, not sure how 'built in' it is, but how built in is netwokring in any language?
08:27:53 <SamB_XP> er. s/ bohanlon / bohdan /
08:27:59 <Olathe> gio123: http://www.google.com/search?q=12+stone+to+kg says 12 stone = 76.2035182 kilograms
08:28:01 <Botje> bohdan: use hoogle :)
08:28:03 <Mathematics`> BRB;
08:28:42 <Botje> http://www.haskell.org/hoogle/?hoogle=getStdgen
08:28:55 <paper_cc> @hoogle getStdGen
08:28:56 <lambdabot> System.Random getStdGen :: IO StdGen
08:29:05 <paper_cc> Botje, it's easier =)
08:29:13 <Olathe> > mkStdGen 5
08:29:14 <lambdabot>   6 1
08:29:57 <bohdan> LYAH has a chapter about this now: http://learnyouahaskell.com/input-and-output#randomness
08:30:05 <leadnose> Mathematics`, check this out if you haven't already: http://book.realworldhaskell.org/read/
08:30:16 <leadnose> chapter 27 is about networking
08:30:23 <Olathe> @src getStdGen
08:30:23 <lambdabot> Source not found. Do you think like you type?
08:31:37 <Axman6> :t mkStdGen
08:31:39 <lambdabot> Int -> StdGen
08:31:44 <Axman6> @src StdGen
08:31:44 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
08:31:47 <Olathe> Hmm, apparently a stone is 14 pounds.
08:31:53 <Axman6> i try not to...
08:35:04 <Mathematics`> leadnose, thanks, I'm just flicking through it atm, Haskell is good for mathematical things?
08:36:22 <Axman6> Mathematics`: heh, it's all maths basically, from low level to funky abstract stuff
08:36:39 <leadnose> Mathematics`, I'm not qualified to answer that, but I have a feeling that knowledge of helped me on a recent discrete math course
08:36:51 <leadnose> *knowledge of haskell
08:36:58 <Mathematics`> Cool :d
08:37:14 <Mathematics`> *:D I like maths, going to take it and further maths when leave school :0
08:37:16 <Mathematics`> *:)
08:37:28 <Axman6> Mathematics`: i mean, haskell is based on the lambda calculus, so... that;'s pretty mathy right? :)
08:38:13 <Axman6> anyway, sleep time. night all
08:38:42 <Mathematics`> Night
08:39:08 <Mathematics`> What is Haskell useful for? Kinda vague question I know, But like anything inperticular?
08:39:57 <deadlyx> Concurrency comes to mind.
08:40:02 <Axman6> a lot of maths stuff, but you can do pretty much anything with it
08:40:12 <sampointon> Mathematics`: if you believe the hype, massive concurrent systems with lots of moving parts
08:40:22 <leadnose> it's useful for pretty much anything that any decent general purpose language is useful for
08:40:30 <Saizan> parallelism more than concurrency
08:40:39 <Axman6> it's a very academic language, so lots of CS research is done with it
08:40:51 <Mathematics`> And I'm wanting to make games lol :P
08:41:12 <schme> Mathematics`: Good plan.
08:41:20 <mpwd> Mathematics`: I do computational logic with it.  It's a champ at this.
08:41:30 <Mathematics`> What's that?
08:41:39 <leadnose> there are some small games made in haskell, I've been contemplating on making some too
08:41:58 <Mathematics`> What are they programmed in? Haskell, or Haskell and a add on libary?
08:42:20 <leadnose> haskell and libraries
08:42:27 <Mathematics`> Kk
08:42:28 <schme> Like most other languages ;)
08:42:31 <Mathematics`> Could you show me the code?
08:43:00 <leadnose> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/frag
08:43:16 <mpwd> Mathematics`: If I have a formula in a logical language, can I prove it?  Is there a model that makes it true?  If I have a model and a formula, is the model true of the formula?  There's also methods for programming in logic (like prolog)
08:43:34 <leadnose> that's the most impressive graphicswise as far as i know
08:44:17 <leadnose> this is also nice, extremely fun to play: http://www.geocities.jp/takascience/haskell/monadius_en.html
08:45:04 <chessguy> oh, speaking of fun games, this is a nice one: http://armorgames.com/play/2205/light-bot
08:45:16 <chessguy> has some interesting functional ideas about it
08:47:07 <Mathematics`> It doesn't feel "right" using GHCi for me, seen as i've been used to using compilers
08:47:48 <leadnose> by the way, does anyone know if there are any libraries for loading 3d-models to opengl?
08:48:17 <Mathematics`> Can someone show me some "advanced" Haskell code? please.
08:48:41 <schme> Mathematics`: http://code.haskell.org/frag/src/
08:49:19 <Mathematics`> they "fail"
08:49:31 <schme> They do what?
08:49:38 <athos> hi
08:49:49 <Mathematics`> Tbh, I'm still debating over c++ and Haskell
08:49:51 <Mathematics`> I get a error
08:49:57 <Mathematics`> sayin fail or something
08:50:12 <schme> Weird.
08:50:17 <Mathematics`> C:\Users\ADMINI~1\AppData\Local\Temp\Game.hs:14:7:
08:50:18 <Mathematics`>     Could not find module `Visibility':
08:50:18 <Mathematics`>       Use -v to see a list of the files searched for.
08:50:18 <Mathematics`> Failed, modules loaded: none.
08:50:18 <Mathematics`> Prelude>
08:51:03 <Mathematics`> I don't know to go c++ or haskell lol, ill probs go haskell for the "best" position when learned
08:51:56 <schme> Best position for doing what?
08:52:42 <Mathematics`> I mean like in the long run learning haskell will be the best choice
08:53:06 <schme> That very much depends on what your goals are.
08:53:12 <Olathe> Mathematics`: Load Visibility.hs first.
08:53:15 <czShadoW> Mathematics`: You need other files too (like compiler says that you need Visibility.hs).
08:53:33 <Mathematics`> schme, I want to create games
08:54:01 <leadnose> what kind of games, and for what platform?
08:54:29 <Mathematics`> Windows, 3D games
08:54:45 <okriMMM> ?hoogle newtype
08:54:46 <lambdabot> keyword newtype
08:54:46 <lambdabot> Language.Haskell.TH NewtypeD :: Cxt -> Name -> [Name] -> Con -> [Name] -> Dec
08:54:46 <lambdabot> Language.Haskell.TH.Syntax NewtypeD :: Cxt -> Name -> [Name] -> Con -> [Name] -> Dec
08:55:01 <schme> Mathematics`: A lot of the gaming industry uses C++ actually, so it might be a more suitable language to learn if you're planning to get into that.   And a lot of the "game programming" litterature is very centered on C++.
08:55:21 <Mathematics`> I was doing that, but then people said I should go Haskell
08:55:26 <Raevel> :-)
08:55:28 <schme> Who did?
08:55:36 <leadnose> AFAIK, haskell doesn't have any pre-made game engines or such *yet*
08:55:39 <czShadoW> People are often stupid.
08:55:46 <leadnose> C++ OTOH has dozens
08:55:48 <Plouj> indeed
08:56:11 <schme> Mathematics`: I mean if you're just planning to hack on open source projects haskell will be fine. But if you are going for a job at some game producing factory.. I say go with the C++.
08:56:18 <leadnose> I'm also very interested in making 3d applications but I simply hate C++ :/
08:56:41 <Axman6> apparently Lua is rather well used in the games industry actually, Crysis and Far Cry use it a lot,  and a lot of other well known games
08:57:02 <leadnose> Also I think maybe on Windows some games are starting to use C# etc.?
08:57:07 <schme> Yes.. as extension stuffery.
08:57:13 <schme> (lua that is)
08:57:28 <centrinia> I think that Tim Sweeny gave a presentation about the virtues of some features of Haskell.
08:58:13 <Plouj> I wonder what is the approximate ratio between people who know Haskell and C, C++ and those who only Hask
08:58:30 <leadnose> here it is, the Tim Sweeney's thing http://lambda-the-ultimate.org/node/1277
08:58:41 <schme> It also seems to me that for one starting out one perhaps will be looking at a lot of game programming tutorials, and reading game programming litterature,  those tend to be very much C++ it seems to me.. and getting that tutorial knowledge to transfer to haskell w/o knowing both C++ and haskell.. weel seems tricky :)
08:58:44 <Plouj> ell
08:58:55 <schme> Plouj: Everyone knows C :)
08:58:59 <mahogny> leadnose, how about putting java on top of a c++ game engine? at least you get GC
08:59:01 <Plouj> ok
08:59:06 <Plouj> , not C++
08:59:07 <lunabot>  luna: Not in scope: data constructor `C'
08:59:09 <Plouj>  but
08:59:17 <Mathematics`> If I'm not using Haskell I'll use C++
08:59:22 <Plouj> (stupid lag is causing weird typing errors for me)
08:59:27 <Badger> be faithful
08:59:31 <Badger> use original C :)
08:59:32 <leadnose> mahogny, I've thought about that too, but Java already has a good 3d engine,
08:59:37 <leadnose> the jmonkeyengine
08:59:42 <mahogny> hm. never tried
08:59:43 <schme> Mathematics`: I suggest learning both languages ;)
08:59:52 <Mathematics`> I can hardlys learn 1
09:00:09 <schme> Also for windows gaming I dunno.. is there a haskell direct3d binding?
09:00:12 <leadnose> I've been thinking maybe using an existing C++ engine and making bindings for it in haskell might be a good solution?
09:00:19 <centrinia> You can always make your own language.
09:00:59 <schme> Mathematics`: In the long run it's not so much about language choice. C++ does however give you a lot of ready made stuff for writing games (lotsa engines etc. lotsa litterature and reading) that haskell does not at the moment :)
09:01:00 <mahogny> schme, no real reason to use d3d over gl
09:01:00 <leadnose> that too, I'd like the engine to be very scriptable
09:01:10 <schme> mahogny: So why do windows games tend to do it?
09:01:18 <Axman6> http://www.reddit.com/r/programming/comments/7mroa/why_is_haskell_so_popular_on_reddit_what_does_it/82ad uh wow at the first reply
09:01:34 <czShadoW> Mathematics`: Do you have some concrete idea for 3D game or you just want to make a 3D game?
09:01:35 <mahogny> schme, microsoft is extremely good at getting coders to use windows-only APIs
09:01:39 <Axman6> reading haskell syntax is like reading maths+english, wth
09:01:45 <Olathe> Mathematics` isn't here.
09:01:56 <leadnose> schme, I don't know, but I'm guessing maybe visual studio has better tools for using directx?
09:01:56 <schme> mahogny: Well that sounds a good reason to do it.. more use it, more support, more tools available, no?
09:02:07 <schme> leadnose: Ya me too. I really have no idea though :)
09:02:23 <czShadoW> Hm, whatever.
09:02:33 <schme> Wow.. Haskell "Has readable, pleasent syntax"  <= that made me laugh :)
09:02:35 <mahogny> schme, gl is used for all other OS' so I'd say the tooling is equivalent
09:02:58 <Zao> leadnose: DX10 is a rather pleasant API.
09:03:02 <mahogny> schme, the downside of GL is that it's very backwards compatible while microsoft prefers everyone to relearn DX for every new release
09:03:09 <schme> mahogny: Right.. But if the MS tools you use to produce the software have better support for direct3d, and you are developing for that  platform.. I see no downside to it.
09:03:10 <Zao> As was DX9 somewhat, but a bit too much fixed function for my tastes.
09:03:10 <mahogny> gl is a bit cluttered
09:03:20 <centrinia> Why do people give so much creedance to syntax?
09:03:21 <leadnose> also, openGL is graphics only, mayde other stuff integrates better with dx
09:03:28 <leadnose> don't really know, just guessing
09:03:35 <schme> Me too, also the guessing.
09:03:38 <Zao> It's said that it's rather hard to find a proper fast path in GL for all cards.
09:03:50 <mahogny> schme, not sure if the MS tools aren't adapted for it at all. in the end, it's just a library
09:03:58 <schme> mahogny: indeed.
09:03:58 <mahogny> -n't
09:04:09 <schme> Well either way it dun matter.
09:04:38 <Badger> if you're developing specifically for windows, use dx. if you're just developing, use gl, so I can play it too. :P
09:04:39 <mahogny> but as pointed out, d3d isn't the only thing. you want sound etc. so then you use SDL or you grab the entire DX API
09:04:57 <okriMMM> where is the difference between "type" and "newtype", is there one?
09:05:07 <schme> Why use SDL?
09:05:08 <centrinia> A newtype has a label.
09:05:12 <mahogny> okriMMM, type is just a synonym. newtype is  constructor
09:05:25 <mahogny> schme, well, SDL or anything equivalent
09:05:27 <schme> (surely there is something better than SDL for windows)
09:05:38 <leadnose> what O
09:05:41 <leadnose> oops
09:06:01 <mahogny> schme, if you want to stay portable and lean then SDL has rather good reputation. if you can accept bloat there are better options
09:06:01 <schme> I have no idea here, I might add, I haven't been on windows since 3.11. But I don't buy the whole "ya it's a big conspiracy that makes 'em use the direct3d"
09:06:31 <schme> mahogny: But the guy specifically said he wanted to do windows games. No need for portability :)
09:06:38 <mahogny> schme, no conspiracy. just a lot of marketing. the you-need-more-than-gl-anyway-so-use-DX is a fact that cannot be ignored
09:06:51 <schme> Hmm.. Well I dunno.
09:06:56 * schme has honestly never seen any of the marketing.
09:07:03 <mahogny> schme, no reason to throw away future possibilities unless you can motivate that windows-only tools will do the job better
09:07:06 <schme> Anyway it seems whoever left :)
09:07:10 <leadnose> I'd be rather cautious about developing for windows-only, macs seem to get more popular all the time
09:07:16 <schme> leadnose: Me too.
09:07:23 <leadnose> also I like linux and I like to play :)
09:07:34 <schme> zangband darnit!
09:07:38 <ulfdoz> write portable code.
09:07:42 <mahogny> well. I wouldn't APIs that would work on all platforms *except* mac just to get rid of it :P
09:07:45 <mahogny> +mind
09:07:57 <stevekla1nik> yeah. there's no reason to go windows only if you don't have to. why cut out a part of your user base for no reason?
09:07:58 <leadnose> lol
09:08:42 <mahogny> we have a highscore at work who has managed to trash mac the most number of times. apple has their own label for crashes when everyone was away
09:08:48 <leadnose> there are many games which seem to be doing just fine on at least the big three desktop platforms
09:09:25 <schme> There's that goo world. It seems like fun. I'm looking forward to the linux version.
09:09:31 <schme> or maybe it was world of goo
09:09:35 <Eelis> schme: it works well with wine.
09:09:48 <schme> Eelis: Ya I'm not buying it until they release the linux version.
09:09:58 <schme> No matter how well it might work.
09:10:18 <koeien> okriMMM: there is an important difference. 'newtype' is more like 'data' than like 'type'
09:10:37 <Axman6> mahogny: wow, they've really hooked you in haven't they
09:10:46 <okriMMM> "more like"?
09:10:49 <koeien> okriMMM: 'type' just gives a "type synonym", e.g. type String = [Char]. Now you can use 'String' wherever you used '[Char]'
09:11:27 <koeien> okriMMM: 'newtype T = C Int' is an example of a 'newtype'. this is like 'data T = C Int', except for one difference
09:11:27 <mahogny> Axman6, I'm converting the computers at work to linux, one at a time. I even ported some applications to linux g5 :P
09:11:40 <Axman6> 'linux g5'?
09:11:50 <Axman6> urgh
09:11:50 <koeien> okriMMM: in the data-example, there is a difference between "bottom" and "C bottom"
09:12:04 <koeien> okriMMM: in the newtype-example, there is no such difference, they are the same
09:12:34 <koeien> okriMMM: newtypes can only be used for data types with only one constructor and one field
09:12:51 <koeien> okriMMM: they are there to use strong typing without losing efficiency
09:12:52 <mahogny> Axman6, debian to be precise
09:13:06 <Axman6> newtypes carry no extra cost, so newtype C = C Int is the same as an Int to the compier, but it can be used for type checking i believe
09:13:17 <Axman6> mahogny: do you mean linux ppc?
09:13:20 <koeien> Axman6: right, after type checking they are the same
09:13:21 <mahogny> Axman6, yes
09:13:44 <Axman6> seriously, the best thing to run on a G5 would be Leopards
09:14:47 <mahogny> well, if it worked
09:15:04 <Axman6> -s
09:15:14 <Axman6> what do you mean? of course it'll work
09:15:46 <mahogny> we have found limitations as far as in the network file system that makes it unusable
09:16:07 <mahogny> some memory leak causes the stack to grow past 2gb over time
09:16:10 <mahogny> really fast
09:16:44 <bohdan> is there a division operator that takes two ints and returns a float? I want to avoid the explicit cast
09:17:08 <mahogny> bohdan, why do you want to avoid it?
09:17:18 <Axman6> OS X likes to use its memory, keeping things in memory like quit applications incase they're opened again
09:17:40 <koeien> bohdan: not that i know of. you can write one yourself easily
09:17:50 <mahogny> Axman6, this is an outright bug caused by keeping too many files. spotlight is also trashed by it, have to be disabled at system level
09:18:23 <Zao> bohdan: No. Just do it the usual way.
09:18:50 <Axman6> well anyway, i don't know what you're on about, leopard works great on our G5 iMac. and i'm off to bed
09:19:05 <mahogny> we're rather extreme users. that's all
09:19:17 <Zao> 4./3 :P
09:19:33 <koeien> > 4/3
09:19:34 <lambdabot>   1.3333333333333333
09:19:41 <Zao> Oh, never mind. I thought this was a C++ channel.
09:19:43 <Zao> Carry on.
09:19:49 <EvilTerran> > 4 % 3
09:19:50 <Axman6> > (4 :: Int) / (3 :: Int)
09:19:51 <lambdabot>   4%3
09:19:51 <lambdabot>       No instance for (Fractional Int)
09:19:52 <lambdabot>        arising from a use of `/' at <i...
09:19:57 <Zao> I thought some of the nicks looked odd :)
09:20:35 <EvilTerran> > (4 :: Integer) Data.Ratio.% (3 :: Integer) :: Rational -- it's not Float, but it is a fractional type
09:20:36 <lambdabot>   4%3
09:21:03 <koeien> yes, and you have arbitrary precision. great! but it's not a float =)
09:21:16 <centrinia> Is this true? http://lisperati.com/landoflisp/
09:21:16 <Olathe> @pl \a b -> (fromInteger a)/(fromInteger b)
09:21:17 <lambdabot> (. fromInteger) . (/) . fromInteger
09:21:23 <mpwd> mahogny: When I was in high-school, I used linux-ppc all the time on my old iMac G3.  I remember triumphantly watching DVDs after 9 hours of kernel compiling :P
09:21:37 <mahogny> mpwd, :D
09:21:47 <Axman6> Olathe: fromIntegral would probably be better
09:22:01 <mahogny> mpwd, a friend of mine installed linux on a g4. suddenly he could watch movies without lag
09:22:25 <Axman6> mahogny: heh, we've got an iMac G3 DV, worked with DVDs out of the box ;)
09:22:52 <Olathe> > (\a b -> fromIntegral a/fromIntegral b) 4 3 :: Rational
09:22:54 <lambdabot>   4%3
09:22:56 <Olathe> > (\a b -> fromIntegral a/fromIntegral b) 4 3 :: Float
09:22:58 <lambdabot>   1.3333334
09:23:01 <mahogny> Axman6, this was some newer encoding. they keep eating more and more cpu :/
09:23:16 <centrinia> @pl (\f a b -> (f a) / (f b)) fromIntegral
09:23:16 <lambdabot> (. fromIntegral) . (/) . fromIntegral
09:23:18 <Olathe> @type (\a b -> fromIntegral a/fromIntegral b)
09:23:20 <lambdabot> forall a b a1. (Integral a1, Fractional b, Integral a) => a -> a1 -> b
09:23:27 <Axman6> whoops, that last comment was for mpwd
09:23:43 <Olathe> @type (\a b -> fromRational $ toRational a/toRational b)
09:23:45 <lambdabot> forall a a1 a2. (Real a2, Real a1, Fractional a) => a1 -> a2 -> a
09:24:01 <Olathe> > (\a b -> fromRational $ toRational a/toRational b) (3::Float) (2::Integer)
09:24:02 <lambdabot>   1.5
09:24:15 <Olathe> > (\a b -> fromRational $ toRational a/toRational b) (3::Float) (2::Integer) :: Rational
09:24:17 <lambdabot>   3%2
09:24:19 <Olathe> > (\a b -> fromRational $ toRational a/toRational b) (3::Float) (2::Integer) :: Float
09:24:20 <lambdabot>   1.5
09:24:29 <koeien> pointless =)
09:24:41 <koeien> oh no, not really
09:25:36 <Olathe> I wish Haskell's numeric classes were based more on mathematics.
09:25:57 <koeien> me too. although some pragmatism is okay
09:27:00 <mpwd> Olathe: At least it isn't C, where you are reminded often that the dream of a field with the least upper bound property is an illusion...
09:27:27 <mpwd> Olathe: Have you played with Isabelle at all?
09:27:55 <Olathe> No, never heard of it before.
09:28:04 <Plouj> oy
09:28:51 <mpwd> Olathe: It's a proof verification system, based on a pure strict functional programming language, with support for classes and export to Haskell
09:29:13 <Olathe> Ahh.
09:29:48 <Plouj> I'm trying to compile monadius and it's failing at the linking stage, which is really annoying.
09:29:52 <mpwd> Olathe: Sadly, it doesn't support multi-parameter classes.  But what I love about it is that when you declare a class, you declare the laws it must obey, and when you give class instantiation, you prove that the laws are obeyed.
09:30:14 <Plouj> I think ghc should really detect the missing library beforehand and actually tell me which onte it is
09:30:52 <pejo> Plouj, ghc doesn't do the linking, that's handled by programs normally distributed with your OS.
09:30:57 <koeien> that seems hard to do, to me
09:31:31 <Saizan> Plouj: which error are you getting?
09:32:04 <leadnose> Plouj, what os?
09:32:15 <leadnose> I needed to disable the sounds on linux
09:32:27 <Plouj> http://hpaste.org/13500
09:33:04 <leadnose> yes, just change those function to foo = return ()
09:33:08 <leadnose> +s
09:33:19 <leadnose> in audio or music
09:33:20 <Plouj> leadnose: what do you mean b "disable the sounds"?
09:33:27 <mpwd> koeien: Proving that laws are obeyed?  It's all inductive proofs.
09:33:33 <Plouj> oh, ok
09:33:44 <leadnose> Plouj, by editing the source :)
09:33:54 <koeien> mpwd: No. detecting linking errors beforehand =)
09:34:03 <mpwd> mpwd: :)
09:34:43 <xav__> yeah, I also commented out all the sound stuff in monadius so that it would compile
09:35:11 <pejo> What library is it supposed to link against for those open_audio_w() etc?
09:35:27 <leadnose> I think it's something windows-specific
09:36:14 <pejo> Apparently shapr discovered this a while ago: http://www.cse.unsw.com.au/~dons/code/irc-logs/05.11.03
09:37:13 <bohdan> :r
09:37:17 <bohdan> oops sorry :)
09:37:19 <Plouj> thanks pejo
09:37:41 <xav__> someone should port monadius to use SDL
09:41:44 <Plouj> well, I tried this but it didn't work: http://hpaste.org/13501
09:42:01 <Plouj> I don't think I know enough Haskell to figure out what I'm doing wrong and how to do it right/
09:43:57 <xav__> Plouj: you need to stick some dummy parameters in the 3 functions like you did with openAudio
09:44:21 <athos> @src fix
09:44:21 <lambdabot> fix f = let x = f x in x
09:48:41 <deadlyx> @src foldM_
09:48:42 <lambdabot> foldM_ f a xs = foldM f a xs >> return ()
09:49:20 <vixey> maybe lazyness is just being able to confuse an object with a pointer to an object
09:49:33 <Plouj> dang it!
09:49:34 <Plouj> ./Main
09:49:34 <Plouj> freeglut  ERROR:  Function <glutCreateWindow> called without first calling 'glutInit'.
09:49:48 <vixey> Plouj, try calling glutInit before glutCreateWindow :p
09:49:51 <koeien> :) then call glutInit :P
09:49:53 <Plouj> :)
09:49:58 <Plouj> apparently the irc log has that too
09:51:03 <jonaskoelker> hi all.  I'm having problems compiling http://hpaste.org/13502 -- I get the following error: http://hpaste.org/13503 .  Help me, obi-wan #haskell, you're my only hope ;)
09:51:51 <Lemmih> jonaskoelker: Try with --make.
09:51:57 <bohdan> is there already a function like cmp f a b = (f a) < (f b) ?
09:52:01 <koeien> jonaskoelker: try --make
09:52:09 <jonaskoelker> fixed it, thanks :)
09:52:12 <koeien> you get automagic dependency chasing
09:52:18 <arjanb> :t comparing
09:52:19 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
09:52:54 <Lemmih> ?src on
09:52:55 <lambdabot> (*) `on` f = \x y -> f x * f y
09:53:50 <bohdan> nice. but how does this work?
09:54:01 <jonaskoelker> bohdan: sortBy (compare `on` snd)
09:54:20 <jonaskoelker> bohdan: or, I would think, sortBy (comparing snd)
09:54:37 <bohdan> jonaskoelker, no, I mean how is it implemented
09:54:41 <jonaskoelker> > sortBy (comparing snd) [(1, 9), (2, 8)]
09:54:43 <lambdabot>   [(2,8),(1,9)]
09:54:54 <jonaskoelker> ?src comparing
09:54:54 <lambdabot> Source not found. I am sorry.
09:54:57 <bohdan> it uses compare from the prelude
09:55:02 <bohdan> :t comparing fst
09:55:03 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
09:55:05 <bohdan> @type comparing fst
09:55:07 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
09:55:15 <bohdan> @type sortBy
09:55:17 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
09:55:23 <bohdan> ooh never mind
09:55:27 <jonaskoelker> :)
09:55:28 <bohdan> Ordering
09:55:31 <bohdan> but I need Bool
09:55:39 <bohdan> for groupBy
09:55:46 <jonaskoelker> bohdan: compose with (== Eq)?
09:55:51 <koeien> bohdan: ordering is just LT | EQ | GT
09:55:59 <jonaskoelker> s/Eq/EQ/
09:56:02 <sbahra> @src Ordering
09:56:02 <lambdabot> data Ordering = LT | EQ | GT
09:56:06 <Saizan> :t (==)
09:56:07 <lambdabot> forall a. (Eq a) => a -> a -> Bool
09:56:15 <Saizan> :t (==)`on`fst
09:56:16 <lambdabot> forall a b. (Eq a) => (a, b) -> (a, b) -> Bool
09:56:25 <sbahra> :t on
09:56:26 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
09:57:15 <jonaskoelker> :t (+) `on` (* 2)
09:57:16 <lambdabot> forall a. (Num a) => a -> a -> a
09:57:28 <jonaskoelker> feel free to not use _that_ in your own code ;)
09:58:04 <koeien> > let f = (+) `on` (* 2) in f 3 5
09:58:06 <lambdabot>   16
09:58:54 <bohdan> ok anyway, is 'comparing fst . (==EQ)' the idiomatic way?
09:59:37 <koeien> bohdan: you mean the other way around?
09:59:46 <jonaskoelker> :t (==EQ) . comparing fst
09:59:48 <lambdabot>     Couldn't match expected type `Ordering'
09:59:48 <lambdabot>            against inferred type `(a, b) -> Ordering'
09:59:48 <lambdabot>     Probable cause: `comparing' is applied to too few arguments
09:59:54 <koeien> :t (== EQ) . (. comparing fst)
09:59:55 <lambdabot>     Couldn't match expected type `Ordering'
09:59:55 <lambdabot>            against inferred type `(a, b) -> c'
09:59:55 <lambdabot>     In the second argument of `(.)', namely `(. comparing fst)'
10:00:01 <baaba> :t comparing $ (==EQ) . fst
10:00:02 <lambdabot> forall b. (Ordering, b) -> (Ordering, b) -> Ordering
10:00:10 <koeien> ha :)
10:00:33 <bohdan> nope
10:00:35 <koeien> that typechecks, but is not what you want
10:01:00 <jonaskoelker> where is comparing defined?
10:01:30 <bohdan> Data.Ord
10:01:37 <jonaskoelker> nvm, I can use the bots
10:01:38 <bohdan> @hoogle comparing
10:01:39 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
10:01:39 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
10:01:42 <jonaskoelker> but thx :)
10:01:50 <bohdan> yes they should understand 'where is xxx defined' :)
10:02:08 <Saizan> bohdan: the idiomatic way is "(==) `on` fst"
10:02:40 <jonaskoelker> I can't wait to say "where is undefined defined" ;)
10:02:56 <Saizan> :t ((==EQ) .) . comparing fst
10:02:57 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Bool
10:03:16 <Heffalump> :t (==) `on` fst
10:03:18 <lambdabot> forall a b. (Eq a) => (a, b) -> (a, b) -> Bool
10:04:39 <jonaskoelker> is there an offline version of hoogle?
10:04:46 <Heffalump> yes
10:04:57 <bohdan> oh very nice Saizan
10:05:09 <Heffalump> I've never installed it but Neil assures me it exists
10:08:02 <vixey> Heffalump, and if Neil said that an infinite sets exists, would you believe it? :p
10:08:29 <jonaskoelker> I would
10:08:56 <jonaskoelker> ... but not so much due to my trusting Neil as my knowledge of the axiom of infinity :P
10:09:00 * abbe thinks there is a comma missing in the /TOPIC
10:09:08 <C-Keen> hm I try to install gtk2hs (darcs checkout of 5 min ago) with ghc-6.8.3 and I get errors like: http://hpaste.org/13504
10:09:31 <jonaskoelker> abbe: I think it needs to run through cpp for great string-glueing-together-ness
10:09:35 <xav__> whatever happend to the topic line "we put the funk in funktion" ?
10:09:44 <abbe> jonaskoelker: :)
10:10:35 <jonaskoelker> > "we put the funk in funktion" : topic
10:10:37 <lambdabot>   Not in scope: `topic'
10:10:38 <vixey> xav__, Isn't that a sort of welcome message but not actually in the topic?
10:11:13 <Asztal> is it possible to look at the generated instance definitions when using GeneralizedNewtypeDeriving?
10:11:16 <ski_> @index undefined
10:11:16 <lambdabot> Prelude
10:11:29 <xav__> vixey: yeah, you are right. but i think it used to be in the topic
10:12:13 <vixey> I don't remember that ever being the case
10:13:22 <EvilTerran> -ChanServ- [#haskell] logs @ http://tunes.org/~nef/logs/haskell/ - we put the funk in funktion
10:13:34 <adrian_> Oh dear, I read this http://languagelog.ldc.upenn.edu/nll/?p=960 and thought to myself "So the 'It' is for tying the knot"
10:17:46 <jonaskoelker> is there a script :: hackage package name -> compiled binary with dependency resolution?
10:19:02 <Raevel> cabal (?)
10:19:15 <GremlinHunter> Do you mean something like cabal-install?
10:19:35 <jonaskoelker> $ cabal[tab] -> echo "\a"
10:19:55 <jonaskoelker> apt-cache search cabal -> nothing that looks good
10:20:01 <jonaskoelker> I probably _do_ mean cabal-install :)
10:20:05 <eu-prleu-peupeu> hello Hasklez0rs
10:20:07 <GremlinHunter> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
10:20:47 <Raevel> jonaskoelker: cabal is in my aptitude as libghc6-cabal-dev
10:21:26 <bohdan> Raevel, apt-cache policy libghc6-cabal-dev
10:21:30 <bohdan> i.e. which repo
10:21:48 <sampointon> cabal-install wasn't in the ubuntu or debian repos, last time I looked
10:21:52 <Saizan> Raevel: that's Cabal the library
10:22:04 <sampointon> at least not the official ones
10:22:07 <jonaskoelker> distro Raevel == Intrepid?
10:22:26 <Saizan> jonaskoelker wants cabal the executable, which is provided by the cabal-install package
10:22:30 <bohdan> jonaskoelker, not in intrepid :(
10:22:31 <Saizan> ?hackage cabal-install
10:22:31 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
10:22:40 <Raevel> uh, i forgot the names of the ubuntu versions
10:22:44 <Raevel> 8.04
10:24:15 <bohdan> how would I import Data.* in ghci ?
10:24:24 <Heffalump> you can't
10:24:48 <sampointon> why would you want to do such a thing? There;s a lot of stuff under Data
10:25:11 <bohdan> sampointon, at least import a reasonable subset
10:25:16 <bohdan> without cluttering the prompt
10:26:12 <sampointon> bohdan: hmm. I'd guess the most practical way would be to put them in a file and load that
10:26:30 <idnar> @type comparing fst
10:26:32 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
10:26:59 <idnar> ah
10:27:53 <bohdan> btw, in imperative languages there's a convention that function names are verbs of verb phrases -- is there a similar convention for hs ?
10:31:27 <centrinia> bohdan, does something like insertWithKey meet with the convention?
10:32:14 <bohdan> yes it's a verb phrase
10:32:35 <bohdan> but it's weird to have verbs for things that don't modify values
10:32:59 <bohdan> e.g. in python there's sort() which is inplace, and sorted() which is `functional' (sort-of)
10:33:14 <bohdan> sort is a verb, sorted is not
10:33:56 <jonaskoelker> bohdan: I think the important property of the word `sort' is that it's a verb in _imperative_ form
10:34:22 <bohdan> umm
10:34:38 <bohdan> is there an imperative form? i though there are imperative clauses
10:34:48 <bohdan> go get it `vs` i get it
10:34:57 <bohdan> the verb is the same :)
10:35:02 <sampointon> I thought the distinction was active vs passive
10:35:25 <bohdan> anyway, is there a convention around this?
10:35:38 <sampointon> or, active vs passive participle
10:36:07 <jonaskoelker> what's passive participle, just for the people who only know grammar of formal languages? ;)
10:36:41 <mpwd> bohdan: The analogies we make in programming to natural language are kind of tortured.
10:36:45 <conal> perhaps "passive" or "past participle"
10:37:16 <jonaskoelker> isn't it verb vs. adjective?
10:37:38 <bohdan> mpwd, I find `itemCount` to be a better name than `countItems' for a haskell function
10:38:28 <conal> passive verb forms (e.g., "sorted") are often used as adjectives
10:38:35 <geezusfreeek> conal, hey!
10:38:44 <conal> geezusfreeek: hey, back!
10:38:55 <bohdan> @pl \(a,b) f -> f a b
10:38:55 <lambdabot> uncurry (flip . flip id)
10:39:03 <CakeProphet> @src uncurry
10:39:03 <lambdabot> uncurry f p = f (fst p) (snd p)
10:39:58 <CakeProphet> > uncurry (+) (1,2)
10:40:00 <lambdabot>   3
10:40:15 <conal> bohdan: i'm with you about "sort", or any verb, being out of place in functional programming.
10:40:18 <mpwd> bohdan: I try not to name functions when I can get away with anonymity.
10:40:38 <sampointon> point-free programming gets its vindication!
10:40:51 <mpwd> I am all about the point-free programming
10:41:00 <CakeProphet> I don't think the name sort really causes any problems.
10:41:03 <geezusfreeek> conal, i have bumped into one of the problems that was discussed in the fairly recent Yampa vs. Reactive thread. i have a [Behavior a] -> Behavior [a] function and am not entirely sure how to go about garbage collecting behaviors as they are removed from the list. i haven't actually _tested_ to see if they will be garbage collected, but my intuition says they will not. have you been able to think about this yet, or is it eve
10:41:03 <geezusfreeek> n an issue in Reactive?
10:41:11 <geezusfreeek> wow, that was longer than i thought it'd be
10:41:14 <mpwd> I never thought programming needed a point :P
10:41:25 <vixey> conal, that's a bit extreme though?
10:41:31 <bohdan> @pl \(x,y) -> (x + 1, y)
10:41:32 <lambdabot> first (1 +)
10:41:44 <bohdan> @src first
10:41:45 <lambdabot> Source not found. Maybe if you used more than just two fingers...
10:41:48 <conal> vixey: i hope so.
10:41:52 <bohdan> @hoogle first
10:41:52 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
10:41:52 <lambdabot> Data.Monoid newtype First a
10:41:52 <lambdabot> Data.Monoid First :: Maybe a -> First a
10:41:58 <koeien> :t first
10:41:59 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
10:41:59 <vixey> hum.. I don't understand
10:42:20 <bohdan> Control.Arrow ???
10:42:24 <koeien> yes :)
10:42:25 <koeien> arrows
10:42:25 <bohdan> that's something new for me :)
10:42:29 <koeien> a generalisation of monads
10:42:30 <conal> geezusfreeek: how do you mean "removed from the list"?
10:42:42 <mpwd> geezusfreeek: Is Behavior a monad?
10:43:01 <geezusfreeek> conal, in this particular case i have a list of bullets, and i want them to go away eventually
10:43:13 <geezusfreeek> where the behavior describes the bullets' positions
10:43:29 <geezusfreeek> mpwd, no
10:43:38 <deadlyx> bohdan, http://en.wikibooks.org/wiki/Haskell/Arrows
10:43:39 <jonaskoelker> bohdan: what's "@pl"?
10:43:40 <deadlyx> ^_^
10:43:44 <conal> mpwd: though semantically, yes.
10:43:52 <koeien> jonaskoelker: pointless. pointfree representation of functions
10:44:14 <geezusfreeek> conal, btw, my unsafeInterleaveIO version seems to be going smoothly so far
10:44:32 <geezusfreeek> i could link you to my code, but it is a _horrible_ mess at the moment since i am prioritizing the game i'm making with it at the moment
10:44:36 <conal> geezusfreeek: cool.  with deterministic semantics?
10:44:42 <geezusfreeek> so far yes
10:44:54 <vixey> geezusfreeek, I would like to see it though
10:44:58 <bohdan> @help pl
10:44:58 <lambdabot> pointless <expr>. Play with pointfree code.
10:45:07 <geezusfreeek> i haven't actually done any quickcheck tests or anything yet though, so i can't guarantee any correctness whatsoever
10:45:15 <geezusfreeek> i'm not even using sensible function names in some places
10:45:19 <geezusfreeek> h/o, i'll grab a link
10:45:23 <vixey> lol because quickcheck would guarantee correctness?
10:45:23 <conal> geezusfreeek: i'd like to see it when the code is cleaned up to your liking.
10:45:29 <mpwd> geezusfreeek: Just out of curiosity, what drove your choice to work in the IO monad?
10:45:36 <geezusfreeek> vixey, of course not :P
10:45:52 <geezusfreeek> mpwd, i'm not in the IO monad. i only pump events from it
10:46:13 <mpwd> geezusfreeek: Oh, I see
10:46:23 <jonaskoelker> what does pointfree mean?
10:46:49 <athos> @src pl
10:46:49 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:46:49 <athos> hehe
10:47:02 <geezusfreeek> vixey, here is my yucky code http://github.com/geezusfreeek/udg08-jake/tree/master/src/Control/FRP.hs
10:47:16 <sampointon> jonaskoelker: avoiding explicitly writing arguments to functions
10:47:19 <athos> how's pl implemented? is there any cs/math background?
10:47:23 <centrinia> jonaskoelker, it means that it is not evaluated at a point.
10:47:24 <conal> geezusfreeek: it occurred to me to have a new function "safePerformIO", with the same implementation as unsafePerformIO, but with semantic preconditions.  then shun the latter but not the former.
10:47:28 <mpwd> jonaskoelker: When you declare a function, you can either declare it with an argument, or assign it to be an anonymous function or section awaiting an argument.
10:47:28 <bohdan> http://www.haskell.org/haskellwiki/Pointfree
10:47:46 <sampointon> jonaskoelker: eg, pointful style: foo xs = map frobble xs. Pointless: foo = map frobble
10:47:47 <conal> geezusfreeek: after all, pure lazy functional programming is all built on safePerformIO.
10:47:53 <geezusfreeek> conal, what kind of preconditions?
10:47:58 <Badger> @src unsafePerformIO
10:47:58 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
10:48:11 <conal> geezusfreeek: that's the interesting question, isn't it?!
10:48:25 <athos> :t lazy
10:48:26 <lambdabot> Not in scope: `lazy'
10:48:39 <bohdan> athos, it
10:48:41 <koeien> implementation details.
10:48:42 <bohdan> err
10:48:44 <centrinia> What is a realWorld# ?
10:49:16 <Badger> centrinia: go outside and you'll see :P
10:49:26 <conal> Badger: :)
10:49:33 <koeien> lol
10:49:58 <CakeProphet> :t unsafePerformIO
10:50:00 <lambdabot> Not in scope: `unsafePerformIO'
10:50:06 <koeien> CakeProphet: IO a -> a
10:50:14 <CakeProphet> ....srsly?
10:50:18 <geezusfreeek> conal, yeah. i have no problem with "unsafe" in the name though. i wish the prefix would be used for any functions that have preconditions not constrained by the types
10:50:19 <koeien> but it's unsafe and evil
10:50:26 <CakeProphet> it sounds pretty sweet.
10:50:28 <CakeProphet> ...
10:51:36 <geezusfreeek> or some other prefix at least
10:51:41 <conal> geezusfreeek: i'd also like a clear meaning and convention.  maybe "precond" instead of "unsafe", since the latter is morally loaded in these parts.
10:51:44 <sampointon> geezusfreeek: playing devil's advocate, but does that mean it should be unsafeHead and unsafeTail?
10:51:51 <koeien> geezusfreeek: veryUnsafe ? :)
10:51:59 <geezusfreeek> sampointon, perhaps something more like what conal suggested
10:53:02 <ziman> i'd like to produce some vector graphics from my haskell program; any recommendations?
10:53:03 <vixey> does renaming  head  into  fooHead  make something easier or clearer?
10:53:22 <vixey> I don't think so, you're saturated with partiality already, why not play it down?
10:53:29 <geezusfreeek> it's documentation that there are preconditions the compiler won't tell you about
10:53:37 <ziman> non-X11, just to write a file
10:53:51 <CakeProphet> lists are shallow.
10:53:55 <vixey> I know what it is, I'm just wondering is it useful
10:53:57 <sampointon> vixey: well, I was actually bitten by head not being defined for [], and forgetting to account for that, recently. So it'd definitely help me not forget if it was encoded into the name somehow
10:53:58 <koeien> ziman: svg?
10:54:12 <CakeProphet> all they give you is head and tail.
10:54:26 <vixey> sampointon, did you expect something to happen for  head []  which didn't?
10:54:42 <mpwd> > head []
10:54:44 <lambdabot>   * Exception: Prelude.head: empty list
10:54:47 <idnar> @type safeHead
10:54:48 <lambdabot> Not in scope: `safeHead'
10:54:50 <conal> geezusfreeek: your code looks pretty nice to me
10:54:52 <geezusfreeek> if it was used consistently then my spidey senses would be more likely to tingle whenever i see the prefix
10:54:56 <idnar> @type listToMaybe
10:54:57 <vixey> @let safeHead = listToMaybe
10:54:58 <lambdabot> forall a. [a] -> Maybe a
10:55:00 <idnar> @src listToMaybe
10:55:00 <lambdabot>  Defined.
10:55:00 <lambdabot> listToMaybe []        =  Nothing
10:55:00 <lambdabot> listToMaybe (a:_)     =  Just a
10:55:07 <geezusfreeek> conal, no documentation and no consistency in naming, mainly
10:55:12 <sampointon> vixey: no, I just didn't account for it and so I tried to `head []'
10:55:13 <geezusfreeek> and i want to modularize it more
10:55:13 <ziman> CakeProphet, :D
10:55:17 <CakeProphet> idnar:  ahahahaha... safeHead?
10:55:25 <idnar> CakeProphet: what's so amusing? :P
10:55:31 <CakeProphet> -ahem- nothing.
10:55:44 * CakeProphet watches soberly.
10:56:02 <conal> geezusfreeek: how do you understand your Event representation: [StrictList a]?
10:56:03 <ziman> safeTail'd be better ;)
10:56:04 * Botje seduces CakeProphet with cake
10:56:21 <CakeProphet> so like... head really isn't an evil function.
10:56:22 <vixey> Botje, cake, a made up drug?
10:56:44 <idnar> CakeProphet: it's an unsafe function :P
10:56:56 <Botje> vixey: made up with household ingredients!
10:57:00 <CakeProphet> in what way?
10:57:03 <vixey> @go cake is a made up drug
10:57:06 <CakeProphet> the undefined []?
10:57:07 <Botje> even children can make cake at home!
10:57:14 <vixey> lol
10:57:19 <lambdabot> http://en.wikipedia.org/wiki/Brass_Eye
10:57:19 <lambdabot> Title: Brass Eye - Wikipedia, the free encyclopedia
10:57:32 <geezusfreeek> conal: [] => never, [[], ...] => nothing happening right now , [[x], ...] => x occurs right now, [[x, y, z], ...] => x y and z all occur at the same time
10:57:58 <conal> geezusfreeek: thx.  i don't see time anywhere.  what do these representations mean?
10:58:29 <idnar> CakeProphet: yes
10:58:44 <bohdan> so support I have a module with a type error
10:58:50 <bohdan> how would I load it ignoring the error?
10:59:01 <bohdan> I want to debug my types with :t
10:59:08 <CakeProphet> funIO = unsafePerformIO getChar:funIO
10:59:09 <bohdan> but it's impossible until the module has been loaded
10:59:17 <koeien> bohdan: you don't :( replace the offending functions with "undefined" and retry
10:59:20 <geezusfreeek> conal, time flows from the head to the tail, and it is a semantic precondition that all events, reactives, and behaviors are "in sync" in that zipping them will only match values that occur at the same time
10:59:40 <geezusfreeek> conal, and if there is ever an absolute time needed, the FRP type provides it
10:59:54 <geezusfreeek> it's basically just a reader
11:00:38 <geezusfreeek> it's also the only declaration that has a single line of documentation in that whole file... :\
11:00:48 <mpwd> bohdan:  Alternatively, you could consider breaking your file up into different modules.
11:01:08 <koeien> that's also an option. however not always possible due to circular dependencies
11:01:14 <conal> geezusfreeek: you pad with Nothings to temporally synchronize all streams?
11:01:22 <CakeProphet> I like IO as an infinite list rather than as IO monads.
11:01:25 <CakeProphet> makes it more fun.
11:01:44 <vixey> CakeProphet, and did you see infinite trees also?
11:01:53 <CakeProphet> noep?
11:02:04 <geezusfreeek> conal, i wouldn't really say it is padding since the result of probing for IO events returns nothing anyway. the padding just falls out naturally
11:02:18 <CakeProphet> @src undefined
11:02:19 <lambdabot> undefined =  error "Prelude.undefined"
11:02:40 <jonaskoelker> no pointfree for me :( "Could not find module `Data.Graph' ... member of containers, which is hidden".  What gives?
11:02:47 <bohdan> > \a -> undefined 1 + "a"
11:02:48 <lambdabot>       Overlapping instances for Show (t -> [Char])
11:02:48 <lambdabot>        arising from a use ...
11:03:00 <geezusfreeek> the main restriction on this representation is that the top level must provide actions to poll for events, rather than just registering callbacks
11:03:10 <conal> geezusfreeek: ok, thanks.  i haven't found the probing part yet.
11:03:15 <CakeProphet> @let death x = death
11:03:17 <lambdabot>  <local>:18:10:
11:03:17 <lambdabot>      Occurs check: cannot construct the infinite type: t = t1...
11:03:25 <Raevel> jonaskoelker: cabal? you need to specify which modules you're using in your cabal file
11:03:40 <CakeProphet> I can't make an all-consuming function?
11:03:46 <geezusfreeek> conal, see mkEvent and mkReactive at the bottom
11:03:55 <sinelaw> what's the etymology for "cabal"?
11:04:02 <jonaskoelker> Raevel: my cabal file = .cabal/config?
11:04:11 <CakeProphet> @let death x y = death y
11:04:12 <lambdabot>  <local>:18:12:
11:04:12 <lambdabot>      Occurs check: cannot construct the infinite type: t = t1...
11:04:21 <kpreid> CakeProphet: Right, because it would have type a -> (b -> (c -> ...))
11:04:39 <baaba> sinelaw, it's an english word
11:04:40 <kpreid> you aren't allowed infinite type expressions
11:04:40 <CakeProphet> kpreid:  I am perfectly okay with that
11:04:42 <CakeProphet> ...
11:04:55 <CakeProphet> :(
11:04:56 <sampointon> sinelaw: latin I believe. Caballus. I think it's the same root as key and ... some other c- word meaning secret
11:04:56 <kpreid> you can break it up with a data or newtype though
11:05:19 <Raevel> jonaskoelker: oh, i assumed you were trying to compile your own cabal project, so n/m, not sure what the problem is then
11:05:32 <kpreid> newtype Consume = forall a. C (a -> Consume)
11:05:37 <sinelaw> baaba, sampointon hmm didn't know that. merriam webster actually lists it: 1: the artifices and intrigues of a group of persons secretly united in a plot (as to overturn a government)  ; also : a group engaged in such artifices and intrigues2: club  , group <a cabal of artists>
11:05:50 <sinelaw> it says:
11:06:02 <sinelaw> etymology: French cabale cabala, intrigue, cabal, from Medieval Latin cabbala cabala, from Late Hebrew qabbālāh, literally, received (lore)
11:06:04 <sampointon> sinelaw: well that was from memory, I could well be wrong
11:06:33 <sinelaw> it's from hebrew :)
11:06:41 <bohdan> how do I convert [IO ()] to IO() ? foldl (>>=) ?
11:07:07 <geezusfreeek> :t sequence_
11:07:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
11:07:31 <geezusfreeek> @src sequence_
11:07:31 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
11:07:37 <jonaskoelker> what's the name of the isomorphism that would answer bohdan's question?
11:08:14 <centrinia> What is the etymology for the world "isomorphism" ?
11:08:22 <centrinia> *word
11:08:23 <CakeProphet> @let fun = fun
11:08:24 <lambdabot>  <local>:5:8:
11:08:24 <lambdabot>      Ambiguous occurrence `fun'
11:08:24 <lambdabot>      It could refer to either `...
11:08:32 <sampointon> sinelaw: via latin though! And I just remembered what I got mixed up with, 'clavus'
11:08:33 <CakeProphet> > let fun = fun in fun
11:08:49 <lambdabot>   thread killed
11:08:54 <sinelaw> centrinia,     Etymology: International Scientific Vocabulary. Date:    circa 1828
11:09:04 <CakeProphet> > let fun = fun:fun in fun
11:09:05 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
11:09:05 <lambdabot>        Expect...
11:09:20 <CakeProphet> = can be used in types?
11:09:34 <bohdan> sequence is nice
11:09:44 <bohdan> but I'm generating the stuff with map
11:09:48 <bohdan> is there a better way?
11:10:08 <jonaskoelker> :t mapM_
11:10:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
11:10:41 <nolrai_East> If I need to access the IO monad from inside of a parser, can I do that with the parsec library?
11:10:57 <bohdan> woo supernice :)
11:11:40 <kaol> > let fun = fun:[fun] in fun
11:11:42 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
11:11:42 <lambdabot>        Expect...
11:11:43 <jonaskoelker> > mapM_ putStrLn ["hello", "world"]
11:11:45 <lambdabot>   * Exception: "<IO ()>"
11:12:02 <jonaskoelker> > mapM_ Just ["hello", "world"]
11:12:03 <lambdabot>   Just ()
11:12:10 <Saizan> nolrai_East: yes with parsec-3
11:12:39 <nolrai_East> is that what cabal gives me?
11:12:50 <ddarius> centrinia: Roughly, iso- = same, morphism = transformation from Greek.
11:13:12 <sampointon> @mw isomorphism
11:13:12 <lambdabot> Maybe you meant: . ? @ bf ft id map msg pl rc v wn yow
11:13:15 <papermachine> Does IO have a Monoid instance somewhere?
11:13:29 <conal> geezusfreeek: why *strict* lists in the repr?
11:13:33 <sampointon> how do you make lambdabot do the dictionary thing again?
11:13:37 <ziman> how do i show 0.008 as 0.008 and not 8e-3?
11:13:51 <ziman> i can't find anything relevant when browsing the hierarchical libs
11:13:54 <geezusfreeek> conal, to force the actions to run when any of them are read so that they all *actully* occur at the same time
11:13:59 <centrinia> I found that the suffix "morphism" meant form or shape.
11:14:40 <geezusfreeek> since it is lazy polling
11:14:53 <ddarius> centrinia: "morph" should be shape.  I'm not sure how the "-ism" changes it, if at all.
11:15:25 <nolrai_East> the "ism" might be English.
11:15:27 <Olidu> hi, a newbie question, I installed a package called "Data.MultiSet" by cabal (windows),  I run my program with runghc fine, but when I try to compile it use ghc, I got errors like,
11:15:28 <Olidu> histogen.o:fake:(.text+0x3c6): undefined reference to `multisetzm0zi1_DataziMultiSet_zdf3_closure'
11:15:30 <Olidu> Is it an issue of environment variable setting?
11:15:30 <conal> geezusfreeek: due to an unsafePerformIO?
11:15:31 <ddarius> nolrai_East: Indeed.
11:15:37 <geezusfreeek> conal, unsafeInterleaveIO
11:15:45 <geezusfreeek> conal, in mkEvent
11:15:45 <centrinia> What is the difference between the prefixes "homo" and "iso"?
11:15:53 <nolrai_East> ddarius: thanks!
11:16:01 <CakeProphet> > let fun = fun + fun in fun
11:16:07 <CakeProphet> :D
11:16:16 <lambdabot>   thread killed
11:16:24 <jonaskoelker> ziman: printf?
11:16:29 <ddarius> centrinia: I'm not too sure.  I think it is along the lines of "similar" v. "same"  At least that is how it is used in mathematics.
11:16:43 <Saizan> Olidu: use --make
11:16:49 <centrinia> Okay.
11:17:02 <CakeProphet> >let fun x = fun x + fun x in fun x
11:17:11 <Olidu> Saizan, thanks
11:18:09 <conal> geezusfreeek: i don't understand.  maybe something in the nature of your poll.
11:18:47 <Olidu> Now I got it compiled, but get an one-line error message "histogen.exe: Prelude.(!!): index too large"   Is it really Prelude's problem?
11:19:19 <Saizan> it's a problem in your use of (!!)
11:19:34 <Saizan> > [1,2] !! 5
11:19:36 <lambdabot>   * Exception: Prelude.(!!): index too large
11:19:47 <geezusfreeek> conal, my goal here was to make it so that when i read from the frp code at the top level it uses haskell's normal graph reduction to lazily poll the state of realworld whenever more information is needed
11:19:59 <Olidu> ok, I see, so compiled program don't have the line number any more, make sense.
11:21:04 <geezusfreeek> conal, hmm... now that i take a step back and look at mkEvent i see that the entire strictlist is returned at once from the io action anyway...
11:21:08 <HairyDude> hmm, does ubuntu not package the cabal command?
11:21:19 <pierre-> how can i link with .o files when running under ghci? "ghc --make Test.hs c.o" works, but "ghci Test.hs c.o" fails with "unknown symbol"
11:21:20 <geezusfreeek> conal, i think strictlist may be a remnant of a past formulation now...
11:21:25 <geezusfreeek> oh wait, no it's not
11:21:36 <geezusfreeek> conal, think about what happens when i mappend two event streams
11:21:47 <geezusfreeek> conal, i concatenate each corresponding strictlist
11:22:02 <geezusfreeek> conal, those need to both be evaluated at the same time, otherwise they _didn't_ occur at the same time
11:23:17 <conal> geezusfreeek: i'm getting more of a sense now.  i've never had a clear picture of unsafeInterleaveIO
11:23:18 <geezusfreeek> conal, it would be unwise to lazily read from one of them, in other words, since the occurences at the tail might be different once they are finally polled
11:24:14 <conal> geezusfreeek: also, what's "FRP code", as in "Environment for time-dependent FRP code."  By "code", do you mean syntax?
11:24:45 <geezusfreeek> conal, i didn't think very carefully about the wording that comment, so i probably don't mean anything specific at all :P
11:25:02 <jonaskoelker> I'm working on an interpreter (using alex and happy).  I can't help but notice that it'd be fairly easy to autogenerate the token datatype and the lexer.x file from the %token part of parser.y.  Is there a tool to do this?
11:25:13 <geezusfreeek> conal, maybe s/code/expressions/ or something
11:25:32 <conal> geezusfreeek: meaning syntax?
11:25:55 <geezusfreeek> conal,  it might be better to ignore that comment altogether ;)
11:26:14 <conal> geezusfreeek: maybe you meant some kind of internal STG operational representation.
11:27:13 <conal> geezusfreeek: in any case, i'm glad to see & hear it's going well.
11:28:15 <geezusfreeek> conal, you can think of FRP as a "time track" to give timing information to functions on events and reactives that otherwise have no absolute bearing on time
11:29:03 <geezusfreeek> not sure if i should include behaviors in that list, but perhaps
11:29:26 <maltem> centrinia: a homomorphism goes in one direction, an isomorphism goes in both directions
11:29:39 <geezusfreeek> conal, i have no known space leaks! (besides what to do about this [Behavior a] -> Behavior [a] thing)
11:29:52 <conal> geezusfreeek: cool :)
11:31:33 <ddarius> maltem: The discussion is the etymology of the words.
11:32:14 <bohdan> how do I profile a simple expression?
11:32:45 * maltem didn't read back :-/
11:33:28 <bohdan> ideally, from within ghci
11:33:43 <cnwdup> bohdan: By inserting cost centres by hand. http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
11:34:33 <athos> > log 1234
11:34:35 <lambdabot>   7.1180162044653335
11:35:03 <dons> ?users
11:35:04 <lambdabot> Maximum users seen in #haskell: 585, currently: 584 (99.8%), active: 30 (5.1%)
11:35:17 <dons> ?seen shapr
11:35:17 <lambdabot> Last time I saw shapr was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #funtoo, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #
11:35:17 <lambdabot> haskell-blah, #haskell-books, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #
11:35:17 <lambdabot> haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosxdev, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 26d 21h 16m 47s ago, and .
11:35:19 <dons> yikes
11:35:44 <centrinia> @shapr
11:35:44 * lambdabot decomposes  into several parts using the Banach-Tarski theorem and reassembles them to get two copies of !
11:36:20 <abbe> what is the signifcance of '@' in "search g@(Graph vl el) src dst = ...." function definition
11:36:25 <bohdan> "Perhaps you haven't installed the profiling libraries for package base?" -- on ubuntu :(
11:36:39 <centrinia> abbe, it means that  g   is (Graph v1 e1)
11:36:41 <cnwdup> abbe: You can refer to (Graph vl el) by using g. You don't have to contruct the graph again.
11:37:02 * mpwd denies lambdabot the axiom of choice.
11:37:14 <abbe> centrinia, cnwdup: okay, thanks.
11:38:17 <Saizan> bohdan: they are probably in a different .deb
11:38:31 <bohdan> yeah, libghc6-arrows-prof
11:38:47 <bohdan> that worked
11:39:22 <sampointon> bohdan: might be in ghc6-prof too, if you don't want the arrows profiling stuff
11:42:42 <HairyDude> does ubuntu package the cabal command or do I have to redundantly install it from source?
11:43:29 <bremner> HairyDude: apt-cache search cabal
11:43:40 <koeien> AFAIK you'll have to install it from source. there is a bootstrap-script
11:44:10 <sampointon> HairyDude: when I went looking a few weeks ago, cabal-install wasn't packaged by ubuntu or debian
11:44:33 <bohdan> somehow ghc's --make makes it ignore -auto-all -- why?
11:44:49 <HairyDude> sampointon: I'm talking about cabal, not cabal-install
11:44:59 <HairyDude> or are they the same thing?
11:45:20 <HairyDude> (cabal the command, I mean)
11:45:26 <koeien> the 'cabal' command comes with the 'cabal-install' package
11:45:44 <koeien> cabal in general is the build/packages system
11:46:05 <bremner> libghc6-cabal-dev exists (on debian) which I guess lets you runhaskell Setup.hs install
11:46:11 <koeien> bremner: right
11:46:24 <HairyDude> ah, I see
11:46:26 <koeien> but you won't have the cabal command then
11:47:20 <sampointon> is there anyone actively trying to get cabal-install into debian, or isn't it mature enough yet?
11:47:44 <koeien> debian testing is frozen now for 5.0 (lenny)
11:48:01 <HairyDude> hmm, I have cabal 1.2.3, cabal-install needs 1.6
11:48:05 <HairyDude> that's a pretty huge gap
11:48:23 <koeien> HairyDude: no problem. You can install Cabal 1.6.x using cabal 1.2.3
11:49:10 <HairyDude> oh well, that does mean my objection to compiling cabal again is moot:)
11:50:06 <koeien> i don't see cabal in the 'request for packaging'-list though
11:50:48 <HairyDude> in theory Debian (and hence Ubuntu) bundles Cabal with ghc, but it apparently neglects to package the cabal command
11:51:16 <koeien> they are separate packages
11:51:25 <koeien> 'cabal-install' and 'Cabal' on hackage
11:51:28 <ddarius> HairyDude: Cabal is the library.  The command 'cabal' is in the cabal-install package and is not currently distributed with implementations.
11:55:56 <HairyDude> ddarius: ah, so they are "the same" in that sense then
11:56:17 <bohdan> is this expected that things run way slower under ghci compared to compiled form?
11:56:24 <HairyDude> yes
11:56:25 <ddarius> bohdan: Of course.
11:56:41 <bohdan> why? doesn't it also compile?
11:56:43 <HairyDude> as I understand it ghci is an interpreter
11:56:59 <ddarius> bohdan: It's a bytecode interpreter and doesn't perform any optimizations.
11:57:03 <koeien> as I understand it, ghci compiles to bytecode and interprets that
11:57:14 <ddarius> bohdan: You can, though, compile the file and GHCi will load the compiled code.
11:57:18 <HairyDude> bytecode, not core?
11:57:19 <bohdan> ghci == ghc -- interactive
11:57:36 <bohdan> ` --interactive ' that is
11:57:54 <sampointon> HairyDude: bytecode is likely to be well well faster. Directly interpreting from core would have a really big overhead
11:58:07 <sampointon> HairyDude: that kind of architecture was why the original ruby interpreter ran so slowly
11:59:04 <bohdan> ok another question then, I'm getting a stack overflow from the compiled binary, and ghci version just runs albeit very slowly -- how do I debug this?
11:59:27 <beelsebob> bohdan: turn on profiling
11:59:31 <bohdan> can I get a stacktrace on stack overflow?
11:59:41 <beelsebob> see where it's spending most of its time
11:59:42 <cizra> bohdan: It would be rather large, no?
11:59:42 <beelsebob> and no
11:59:45 <bohdan> beelsebob, it was on, and that didn't provide a clue
12:00:01 <ddarius> beelsebob: If he does that he can just use the -xc run-time flag and he'll get a "stack" trace.
12:00:02 <bohdan> cizra, yes, but at least I would know *where* it happened
12:00:14 <beelsebob> bohdan: how close to Haskell 98 is your code?
12:01:15 <bohdan> -xs doesn't make too much sense to me
12:01:20 <bohdan> *-xc
12:02:08 <ddarius> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-debugging
12:03:29 <nolrai_East> where is ParsecT defined?
12:03:38 <ddarius> In the parsec3 package.
12:03:54 <ddarius> Or rather the version >=3 package of parsec
12:03:58 <sbahra> @hoogle ParsecT
12:03:58 <lambdabot> Text.Parsec.Prim data ParsecT s u m a
12:03:58 <lambdabot> Text.Parsec.Prim ParsecT :: State s u -> m (Consumed (m (Reply s u a))) -> ParsecT s u m a
12:03:58 <lambdabot> Text.Parsec.Prim runParsecT :: ParsecT s u m a -> State s u -> m (Consumed (m (Reply s u a)))
12:04:42 <nolrai_East> is Text.ParserCombinators.Parsec different from Text.Parsec?
12:04:45 <bohdan> I'm creating like a list with 1M 10-item lists items and then I do group.sort.concat on it
12:06:36 <nolrai_East> Because I seem to only have the former.
12:07:08 <ddarius> nolrai_East: Text.ParserCombinators.Parsec is parsec2 (or parsec3's compatibility interface for parsec2)
12:07:29 <ddarius> You have parsec2, if you want to use ParsecT, you need parsec3.
12:07:52 <nolrai_East> So why is cabal installing parsec2?
12:08:10 <Saizan> nolrai_East: because that's the version considered "stable"
12:08:35 <nolrai_East> Oh, can I tell it I want the newer one?
12:08:38 <bohdan> looks like Data.List.sort is the problem
12:08:44 <ddarius> Yes, just give the exact version.
12:08:55 <bohdan> @src sortBy
12:08:56 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
12:08:57 <Saizan> or even cabal install 'parsec >= 3'
12:09:15 <bohdan> @src insertBy
12:09:15 <lambdabot> insertBy _   x [] = [x]
12:09:15 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
12:09:15 <lambdabot>                                  GT -> y : insertBy cmp x ys'
12:09:15 <lambdabot>                                  _  -> x : ys
12:09:29 <ddarius> bohdan: That is -not- the implementation actually used.
12:09:39 <bohdan> ddarius, really?
12:09:55 <bohdan> oh, maybe it's used in ghci ?
12:09:58 <ddarius> bohdan: That's the code from the Report (presumably) for reference.
12:09:59 <bohdan> and not in ghc?
12:10:15 <ddarius> bohdan: GHCi and GHC use the same libraries.  In fact, they use the same machine code.
12:10:32 <bohdan> (someone just said ghci interprets bytecode)
12:10:50 <ddarius> bohdan: And if you'd read what I said before, GHCi loads compiled files (when they exist)
12:11:15 <bohdan> do I didn't read that :) sorry missed it
12:13:06 <bohdan> anyway, ` length $ sort [1..(10^6)] ' takes way longer than I'd expect it to -- why?
12:14:04 <byorgey> bohdan: how long would you expect it to take?
12:14:08 <Saizan> do you compile with -O2?
12:14:36 <bohdan> byorgey, faster than the python version:  len(sorted(range(10**7))) ;)
12:14:40 <bohdan> i.e. instantly
12:14:50 <Saizan> and use "length $ sort [1::Int..(10^6)]"
12:14:53 <bohdan> it's more visible for 10^7
12:15:00 <Saizan> with a space..
12:15:16 <sampointon> bohdan: python's sort is optimised for already-partially-sorted sequences
12:15:17 <ddarius> len is presumably a constant time operation in python
12:15:32 <sampointon> bohdan: so it passes through a very fast path and does very little actual sorting
12:16:32 <byorgey> length $ sort [1..(10^6)]  evaluates instantly for me... after I do a tiny bit of hand-optimisation  ;)
12:17:07 <ddarius> s/length $ sort [1..(10^6)]/10^6/
12:17:13 <sbahra> byorgey, what hand optimization?
12:17:21 <sbahra> heh
12:17:24 <sbahra> Ok
12:17:25 <byorgey> sbahra: replacing it by '10^6' =)
12:17:28 <sbahra> yes
12:17:38 <sampointon> bohdan: a better test in python would be len(sorted(random() for _ in range(10 ** 7))
12:18:05 <bohdan> sampointon, yeah you have a point
12:18:40 <bohdan> still it's not very much faster than python :)
12:18:54 <bohdan> and I still get those stack overflows :)
12:31:33 <bohdan> so again, I have a stack overflow when running compiled binary but not from ghci -- how should I debug this?
12:31:41 <enticingjelly> so, besides emacs, what IDEs do you use for developing with haskell?
12:31:47 <enticingjelly> most projects seem stalled?
12:31:57 <ddarius> enticingjelly: Just use what you like.
12:32:36 <enticingjelly> ddarius, that's why I want to know what there is out there... I like using emacs, but I'm curious about other options
12:32:43 <paper_cc> bohdan: try length' = foldl' (\a _ -> a + 1) 0 instead of length if it overflows there
12:32:48 <ddarius> bohdan: You can enable profiling and use the run-time -xc flag to get a stack trace (of sorts).  You can add additional cost centres for finer granularity.
12:33:06 <ddarius> enticingjelly: Everyone just uses what they like.
12:33:41 <maltem> bohdan: Are you compiling with -O2 ?
12:33:58 <enticingjelly> so, as I said, what IDEs are available? are you all using emacs or simple text editors?
12:34:01 <bohdan> maltem, yes it makes it reach the stack limit much faster :)
12:34:13 <maltem> oh
12:34:25 <enticingjelly> I saw there was an eclipse plugin, but as far as I remember it seemed abandoned
12:34:30 <maltem> A case for profiling then :)
12:34:33 <bohdan> ddarius, It doesn't tell me much, in fact it doesn't even make sense
12:34:36 <ddarius> enticingjelly: Most people just use emacs or vim.  A few others use other editors.  Some use plugins for Eclipse or Visual Studio, etc.
12:35:37 <bohdan> I upped the limit to 100M and it passes -- now, I have the profile, but it only tells me the time
12:35:51 <bohdan> how would I correlate this with stack usage?
12:36:25 <ddarius> bohdan: If you are responding to me, I didn't say look at the profiling output.  I said use the -xc run-time flag.
12:37:29 <bohdan> ddarius, it only shows two functions
12:37:50 <bohdan> or rather two instances of one (non-recursive) function
12:38:44 <michaelcdever> if i have a list of filepaths [FilePath], can i print them out as strings i.e. using putStr?
12:39:38 <ddarius> type FilePath = String
12:40:00 <Saizan> enticingjelly: yi is under active developement
12:40:12 <ddarius> Saizan: yi is an editor, not an IDE
12:40:40 <ddarius> And as far as I can tell, almost no one is using it
12:41:12 <bohdan> http://hpaste.org/13506 -- there, the source
12:42:33 <Saizan> the difference between an IDE and an editor with an haskell-mode is not that clear to me :)
12:43:03 <HairyDude> does cabal-install have a command for downloading a source package?
12:43:25 <ddarius> HairyDude: Yes
12:44:07 <HairyDude> "cabal fetch" complains that it's already installed, but if it has the source it doesn't tell me where
12:44:46 <ddarius> Go to ~/.cabal/packages/thepackage/ and unpack the tar.gz
12:45:18 <HairyDude> aha, thanks
12:47:35 <defun> Hi. How would one indent very very long lists? Would it look like this: http://hpaste.org/13507
12:47:58 <bohdan> defun, I'd put ] on a new line
12:48:14 <bohdan> defun, otherwise looks good
12:48:21 <defun> Thanks!
12:48:50 * HairyDude slaps mtl for not defining Applicative instances
12:49:37 <ddarius> mtl existed long before Applicative
12:49:49 <HairyDude> Applicative is standard now, right?
12:49:50 <ddarius> Anyway, you can just define them yourself.
12:50:03 <ddarius> HairyDude: Not in any meaningful sense of "standard"
12:50:15 <BMeph> @unpl const . succ
12:50:16 <lambdabot> (\ d _ -> succ d)
12:50:44 <HairyDude> I was going to patch MonadRandom to be Applicative, but that would require StateT having an instance.
12:51:13 <ddarius> I guess it's in base (though I can see it being moved out some time in the future)
12:51:50 <ddarius> HairyDude: Put the instance for MonadRandom (and StateT) into a separate module and call it a day.
12:52:54 <BMeph> HairyDude: Or just use the WrappedMonad type. :)
12:56:21 <bohdan> ok I'm stuck, maybe I should use arrays :)
12:58:02 <HairyDude> BMeph: aha :)
13:01:01 <michaelcdever> what does this "$" symbol i keep coming across mean lol
13:01:07 <michaelcdever> ignorant use isnt goo
13:01:10 <michaelcdever> d
13:01:11 <ddarius> @src ($)
13:01:11 <lambdabot> f $ x = f x
13:01:30 <BONUS> its an operator that means fucntion application
13:01:37 <BONUS> the trick is that it has really low precedence
13:01:56 <BONUS> and is right associative
13:01:58 <BONUS> so doing
13:02:01 <BONUS> f $ g x
13:02:01 <ray> it lets you elide lots of parentheses
13:02:03 <BONUS> is like f (g x)
13:02:05 <BONUS> and doing
13:02:09 <dibblego> someone needs to debunk the myth "Haskell is pure and so it restricts what you can do"
13:02:17 <BONUS> f $ g $ h x is f (g (h x))
13:02:26 <BONUS> although that's better written as f . g . h $ x
13:02:29 <michaelcdever> ah i get you know bonus
13:02:29 <vixey> dibblego, it's not a myth
13:02:36 <dibblego> vixey, yes it is
13:02:39 <mahogny> is there such a myth?
13:02:39 <michaelcdever> thats a neat trick
13:02:50 <vixey> dibblego, example:   (\x -> ...) you cannot  SET!  the value of x inside that lambda
13:03:01 <BONUS> you can kind of think of it like extending parentheses all the way to the right
13:03:01 <dibblego> vixey, like I said, the myth needs debunking
13:03:04 <vixey> dibblego, so that means you can't make mutable references just out of lambda
13:03:13 <michaelcdever> bonus: cheers mate
13:03:17 <BONUS> :]
13:03:24 <HairyDude> hmm, it would be convenient if you could add extra classes to be cunningly derived for newtypes defined in other modules
13:03:25 <vixey> dibblego, (which you can do in Scheme)
13:03:45 <dibblego> vixey, I will debunk that argument too
13:03:45 <HairyDude> would require the implementation to be exported of course
13:04:14 <vixey> dibblego, point here, if you didn't get it, It's not a myth it's fact. if people are thinking it's bad _that_ is the problem
13:04:38 <ray> the myth would be if people say "therefore, you can't write an X in haskell"
13:06:05 <dibblego> it's myth :)
13:07:08 <vixey> dibblego, ok? I guess i'll take your word for it if you don't have some kind of argument why what you're saying is true
13:08:58 <HairyDude> how weird, there's no instance Monad m => Monad (WrappedMonad m)
13:09:53 <HairyDude> is there any particular reason?
13:11:45 <vixey> dibblego, why do you think it's a myth?
13:12:24 <dibblego> vixey, I think your argument is a case of misintegration under the Peikoff DIM Hypothesis
13:12:36 <vixey> @go Peikoff DIM Hypothesis
13:12:39 <lambdabot> No Result Found.
13:13:22 <dibblego> vixey, essentially, the argument holds with a very broad meaning for "restricts" which is unintended by the claimant (or if it is, the argument loses its meaning immediately)
13:13:30 <vixey> dibblego, whatever
13:13:39 <vixey> dibblego, I'm wondering why you think it's a myth
13:13:57 <papermachine> Peikoff is that objectivist badger, right?
13:14:04 <dibblego> papermachine, yes
13:14:40 <SamB_XP> dibblego: there was no integrals in that argument
13:14:50 <SamB_XP> what are you talking about ?
13:16:07 <papermachine> It's no surprise that google turned up dim, then. His branch of objectivism didn't seem to like posting actual text in public places.
13:18:08 <cognominal> "Leonard Peikoff's The DIM Hypothesis available for free at aynrand.org!"
13:18:24 <cognominal> Ayn Rand? can this be serious?
13:18:28 <BMeph> HairyDude: Because There are multiple Applicative 'instances' that correspond to the same Monad. (I think I said that right, but did I?)
13:18:54 <HairyDude> there are? isn't it just pure = return and (<*>) = ap ?
13:18:59 <vixey> dibblego: it seems like something said  "Foo is true of haskell" and "Foo is bad", so you're going "Not true, Foo is not true of haskell!", when in reality Foo is true of haskell and obviously so, instead of taking on the (maybe harder, maybe more important) position that Foo is good in some cases
13:19:22 <vixey> dibblego, s/Foo/is restrictive because of being pure/ just couldn't be bothered typing it out over and over
13:19:29 <HairyDude> BMeph: you mean there are multiple possible instances that would make sense
13:19:34 <HairyDude> like Monoid
13:20:17 <BONUS> it's like when languages that don't have direct memory access came up, imho
13:20:21 <BONUS> sure it restricts what you can do
13:20:26 <BMeph> HairyDude: Yes, exactly. :)
13:20:34 <BONUS> but on the other hand it allows more and safer abstraction
13:20:58 <BONUS> if it restricts my ability to produce bugs, i'm all for it
13:20:58 <SamB_XP> BONUS: strangely it doesn't seem to be a problem that Haskell allows it ;-P
13:21:01 <BMeph> @where oblivious
13:21:02 <lambdabot> I know nothing about oblivious.
13:21:04 <BONUS> yeah haha
13:21:44 <SamB_XP> (perhaps because it's not the only choice?)
13:22:17 <Badger> @faq can Haskell make BONUS finish his tutorial?
13:22:17 <lambdabot> The answer is: Yes! Haskell can do that.
13:22:33 <Badger> \o/
13:22:38 <BONUS> gah!!!!
13:22:51 <Badger> :)
13:22:54 <BONUS> cant work on tutorials in a hung-over state :]
13:22:58 <BONUS> need H20
13:23:02 <vixey> dibblego, still think it's a "myth"?
13:23:09 <dibblego> yes
13:23:11 <Badger> > fix BONUS
13:23:13 <lambdabot>   Not in scope: data constructor `BONUS'
13:23:15 <BONUS> haha
13:23:18 <vixey> dibblego, I guess you just ignored everything I said then
13:23:28 <dibblego> vixey, you guess wrong
13:23:40 <vixey> dibblego, ok so will you explain to me why you think this?
13:23:47 <dibblego> vixey, yes, in due time, I suppose
13:24:02 <vixey> what do you meandue time?
13:24:11 <BONUS> i mean, when you say "restricts what you can do", there's i think two things that can mean
13:24:17 <BONUS> either in the turing-completeness sense
13:24:21 <dibblego> vixey, when I get around to debunking the myth, including your argument
13:24:39 <BONUS> and obviously Haskell is turing complete so you can do anything with it in that sense and that doesn't restrict anything, but that's kind of obvious
13:24:43 <vixey> dibblego, forget then, I don't care anymore. I stick to my POV and you stick to yours neither of us learned anything.
13:24:44 <SamB_XP> dibblego: could you explain how you can change a lambda-bound variable ?
13:25:02 <BONUS> on the other hand, it does restrict your ability to easily use data with mutable state and such
13:26:07 <BMeph> @go oblivious idioms
13:26:09 <SamB_XP> of course, C doesn't allow closures ...
13:26:21 <vixey> SamB_XP, Scheme does
13:26:22 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf
13:26:22 <lambdabot> Title: Idioms are oblivious, arrows are meticulous, monads are promiscuous
13:26:48 <Badger> :o
13:26:53 <Badger> promiscuous
13:27:55 <antirobotrobot> my (recently compiled) ghci is not reading backspaces or ^D characters correctly.
13:28:06 <SamB_XP> dibblego: I take your silence as an admition of defeat
13:28:18 <dibblego> SamB_XP, ok
13:28:25 <BMeph> HairyDude: I found the above paper the best explanation as to the whole monad/applicative issue. :)
13:29:15 * BMeph takes digglego's silence, and raises an arrogant leer
13:29:43 <SamB_XP> vixey: see, he admits defeat!
13:30:05 <proq> the cake is a lie
13:30:07 <vixey> SamB_XP: he lacks anything interesting to say
13:32:50 <BMeph> vixey: I'd say it was very interesting, just not substantial. :)
13:47:06 <bohdan> I don't understand how liftM2 works
13:47:28 <Heffalump> @src liftM2
13:47:28 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
13:47:37 <cnwdup_> :t liftM2
13:47:38 <bohdan> @type do a <- 1; return a
13:47:39 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:47:40 <lambdabot> forall (t :: * -> *) t1. (Monad t, Num (t t1)) => t t1
13:47:46 <bohdan> why is this valid at all?
13:48:03 <bohdan> maybe I don'
13:48:04 <Heffalump> which, do a <- 1 ?
13:48:08 <bohdan> t understand the <- operator
13:48:08 <cnwdup_> :t (<-)
13:48:08 <bohdan> yes
13:48:10 <lambdabot> parse error on input `<-'
13:48:16 <bohdan> cnwdup, exactly :)
13:48:25 <Heffalump> only because 1 is a numeric literal which can take on any type in the Num class
13:48:33 <Heffalump> the compiler can't know that there is no overlap between Monad and Num
13:48:43 <rwbarton> @type do a <- (1 :: Integer); return a
13:48:44 <lambdabot>     Couldn't match expected type `t t1' against inferred type `Integer'
13:48:44 <lambdabot>     In a stmt of a 'do' expression: a <- (1 :: Integer)
13:48:46 <Heffalump> (indeed, you could choose to make such an overlap by constructing an appropriate instance)
13:49:02 <HairyDude> <- isn't an operator
13:49:08 <HairyDude> it's part of do syntax
13:50:30 <rwbarton> And it's type is determined by the type of (>>=), technically, at least with -XNoImplicitPrelude
13:50:33 <rwbarton> "type" that is
13:51:46 <fco> hi, I have a question, I am using readFile to read a lot of files (to compute MD5 of a whole subtree) but the program fails with an exception after opening too many files, should I use another function, or how can I overcome the lazyness of haskell
13:51:47 <rwbarton> ... also, "it's"?!
13:51:49 <rwbarton> @slap rwbarton
13:51:49 <lambdabot> I don't perform such side effects on command!
13:52:08 <Qantourisc> When the required type is a function with 0 paramters, how can i put 2 functions in it and still return 1 function with 0 paramters?
13:52:38 <BONUS> fco: whats the exception/code?
13:52:48 <bohdan> so, ` 1 ' is monadic, and ' 1 :: Integer ' is not?
13:53:11 <rwbarton> fco: I suggest using ByteStrings, which come with a strict readFile equivalent
13:53:49 <fco> the function is here http://hpaste.org/13509
13:53:59 <bohdan> > liftM2 (+) (1+) (1+) $ 1
13:54:00 <lambdabot>   4
13:54:07 <rwbarton> fco: alternatively, you can use readFile from the strict package on hackage, or strictify the read yourself by e.g. evaluate (length filedata)
13:54:08 <jonaskoelker> hmake-related question: given a module name, how do I find out which -package it's in?
13:54:30 <baaba> :t liftM2 (+) (1+) (1+)
13:54:31 <lambdabot> forall a1. (Num a1) => a1 -> a1
13:54:37 <rwbarton> fco: What's D?
13:54:55 <baaba> :t liftM2 (+) (1+)
13:54:56 <lambdabot> forall a1. (Num a1) => (a1 -> a1) -> a1 -> a1
13:55:00 <Actium> :t liftM2
13:55:02 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:55:08 <fco> oh, let me take look to the strict readFile now
13:55:33 <proq> vixey: I argue that one would consider haskell "restrictive" because they failed to see the power in using a pure functional programming language, fail to see how to express normal tasks in functional style, etc.
13:55:36 <baaba> :t liftM2 (+)
13:55:37 <lambdabot> forall a1 (m :: * -> *). (Monad m, Num a1) => m a1 -> m a1 -> m a1
13:55:57 <fco> the exception is "openBinaryFile: resource exhausted (Too many open files)"
13:56:20 <rwbarton> fco: Yeah, that's a common problem when trying to use lazy IO to read many different files.
13:58:51 <proq> vixey: a programmer would have the same headache when trying to learn any other sufficiently different programming paradigm
13:59:21 <vixey> proq, yes
13:59:55 <vixey> proq, I guess, some don't have problems changing paradigm though
14:00:24 <EmmanuelCastro> After learning Haskell for a a while, I noticed there is nothing like Java's HashMap. Did I miss something?
14:00:27 <fco> ok, I imagined it was a common problem, I wil try with the strict package, thx! (though I having trouble to use cabal libs in ubuntu)
14:00:34 <gbacon> @pl \f g x -> f $ g x
14:00:35 <lambdabot> (.)
14:00:37 <vixey> EmmanuelCastro: yeah
14:00:40 <BONUS> EmmanuelCastro: Data.Map?
14:00:48 <rwbarton> fco: What are D and md5 by the way?
14:00:49 <proq> that would not necessarily make the paradigm "restrictive", rather it makes the paradigm extremely different
14:01:03 <bohdan> > (1+) >>= (\x1 -> (1+) >>= (\x2 -> return (x1 + x2))) $ 1
14:01:04 <lambdabot>   4
14:01:14 <bohdan> this is what the liftM2 above gets converted to
14:01:44 <fco> md5 is function that calculates the md5 checksum and D is Data.ByteString.Lazy
14:01:49 <rwbarton> fco: aha
14:02:02 <BONUS> > do {x1 <- (+1); x2 <- (+1); return $ x1 + x2} $ 1
14:02:04 <lambdabot>   4
14:02:09 <gbacon> @pl \f g -> f $ g
14:02:10 <lambdabot> id
14:02:17 <lucca> md5 is a hash function; useful for some non-critical uses by dangerously obsolete otherwise
14:02:21 <rwbarton> fco: You can use Data.ByteString.readFile, which is strict, and then convert the Data.ByteString.ByteString to a Data.ByteString.Lazy.ByteString somehow.
14:02:29 <EmmanuelCastro> Thank you for Data.Map. Merci beaucoup
14:02:39 <BONUS> :]
14:03:10 <fco> I am trying to find duplicate files, I use MD5 to find duplicate files in my disk, it is not something critical
14:03:42 <BONUS> how does that work for you
14:03:51 <BONUS> im thinking you can use some faster hash functions for that
14:03:57 <BONUS> that aren't as collision tollerant
14:04:00 <BONUS> but are faster
14:04:16 <fco> I am starting with RWH, and so far I love it! I have my code at http://github.com/fferreira/dup/tree/master
14:04:23 <rwbarton> fco: fromChunks . (:[]) :: Data.ByteString.ByteString -> Data.ByteString.Lazy.ByteString
14:04:45 <fco> oh!
14:04:56 <bohdan> how do I see the definition of return / >> / >>= ?
14:05:07 <fco> rwbarton: that's great!
14:05:13 <rwbarton> bohdan: they are class methods in the Monad class, so each Monad has its own definition
14:05:38 <gbacon> @src [] (>>=)
14:05:39 <lambdabot> xs >>= f     = concatMap f xs
14:05:40 <bohdan> rwbarton, for example, for ` (+1) '
14:05:44 <gbacon> @src [] return
14:05:45 <lambdabot> return x    = [x]
14:05:50 <gbacon> @src [] >>
14:05:50 <lambdabot> Source not found. You type like i drive.
14:06:00 <rwbarton> @src ((->) a) (>>=)
14:06:01 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
14:06:11 <rwbarton> @src (->) (>>=)
14:06:11 <lambdabot> f >>= k = \ r -> k (f r) r
14:06:16 <fco> BONUS: it is not too slow, it is more the problem of the lazy input, I filter first for the equally sized files though
14:06:19 <rwbarton> @src (->) return
14:06:20 <lambdabot> return = const
14:06:36 <vixey> @src Cont (>>=)
14:06:37 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
14:06:45 <vixey> @src Cont return
14:06:46 <lambdabot> return a = Cont ($ a)
14:06:51 <BONUS> ah
14:07:27 <bohdan> (->) -- is this about lambda?
14:07:36 <bohdan> @type (->)
14:07:38 <lambdabot> parse error on input `->'
14:07:46 <BONUS> -> is syntax
14:07:49 <BONUS> and it's used for a few things
14:07:52 <BONUS> one of them is lambda's, yeah
14:08:00 <bohdan> how does @src (->) work then?
14:08:03 <lucca> for speed you could use a lazily constructed hash consisting of size, then crc-16 or so of the first 1k, then MD5 of the file
14:08:07 <lucca> but this is a different problem
14:08:09 <gbacon> I have two nearly identical definitions of the form (a,b,c) = f $ g m, but how do I use a map to vary g?
14:08:12 <BONUS> > (\x -> x + 2) 2
14:08:14 <BONUS> hm
14:08:14 <lambdabot>   4
14:08:23 <BONUS> ah
14:08:27 <ddarius> :k (->)
14:08:29 <lambdabot> ?? -> ? -> *
14:08:29 <BONUS> -> is a type
14:08:31 <BONUS> (->)
14:08:33 <BONUS> as well :]
14:08:36 <BONUS> to make things a bit more sticky
14:08:43 <ddarius> type constructor
14:08:44 <Botje> gbacon: take g as an argument
14:08:46 <BONUS> yes
14:09:05 <BONUS> type constructor. so if you're talking about types, (->) is a type constructor for function
14:09:09 <lucca> fco: you can't use that lazy read function
14:09:09 <BONUS> foo :: a -> b
14:09:10 <BONUS> is like
14:09:13 <BONUS> foo :: (->) a b
14:09:22 <ddarius> :t undefined :: (->) a b
14:09:22 <BONUS> otherwise it's syntax
14:09:22 <lucca> fco:  it's going to read and close nondeterministically
14:09:23 <lambdabot> forall a b. a -> b
14:09:29 <gbacon> Botje: what's the point-free equivalent? (@pl doesn't seem helpful in this case)
14:09:30 <lucca> (via unsafeInterleaveIO)
14:09:40 <lucca> and you want to carefully sequence file closes for what you're doing
14:09:42 <gbacon> @pl \f g m -> f $ g m
14:09:43 <lambdabot> (.)
14:09:43 <Botje> gbacon: there isn't one, i think
14:09:44 <baaba> how does one declare the function monad instance?
14:09:44 * bohdan is afraid his head will explode
14:09:51 <fco> luca: yeap, it is a different problem, it has to be slow first, then I can work on speed :P
14:09:54 <vixey> @pl \f g m -> f (g m)
14:09:54 <lambdabot> (.)
14:10:03 <Botje> @hoogle uncurry
14:10:03 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
14:10:03 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
14:10:04 <Botje> @hoogle uncurry3
14:10:05 <lambdabot> No results found
14:10:08 <ddarius> instance Monad ((->) a) where ...
14:10:10 <Botje> no uncurry3, so no :)
14:10:21 <vixey> @let uncurry3 = "bamboo"
14:10:23 <lambdabot>  Defined.
14:10:40 <lucca> fco: can't use readFile, getContents, or hGetContents
14:10:44 <BONUS> you can think of ((->) a) as being a box that contains the value it will return once it's called with something
14:10:52 * Botje thinks bamboo and curry shouldn't be mixed
14:11:05 <vixey> same panda you are!
14:11:06 <ddarius> BONUS: That makes no sense.
14:11:12 <vixey> some*
14:11:21 <baaba> so each domain has its own function monad?
14:11:42 <ddarius> baaba: There's a parameterized collection of monads, yes.
14:11:44 <Qantourisc> seq only runs 1 of the function .. ?
14:11:48 <baaba> right
14:11:55 <Botje> vixey: panda with curry sounds like a good meal, then :)
14:12:00 <Qantourisc> so what if i wish to run both ?
14:12:21 <vixey> nooooo
14:12:28 <Botje> seq evaluates its first argument and returns the second
14:12:38 <bohdan> @pl \a -> 0 : map (1+) $ a (n-1)
14:12:39 <lambdabot> (0 : map (1 +)) . ($ n - 1)
14:12:39 <BONUS> ddarius: yeah, i understand what you mean, most people here say that thinking about monads as boxes is stupid
14:12:40 <Qantourisc> Botje: strange ....
14:12:44 <BONUS> but it helped me
14:12:57 <Qantourisc> Botje: so seq (getLine) (getLine) should request 2 lines of text correct ?
14:13:06 <ddarius> BONUS: It's not only that, but what you described makes no sense, e.g. for id.
14:13:20 <bohdan> @pl fix $ \f n -> 0 : map (1+) $ f (n-1)
14:13:20 <ddarius> Qantourisc: No
14:13:20 <lambdabot> fix (((0 : map (1 +)) .) . (. subtract 1))
14:13:25 <maltem> Qantourisc: evaluating a value is different from performing an action
14:13:29 <Qantourisc> Botje: (trying to wrap 2 () function in a () function)
14:13:33 <Botje> Qantourisc: that will evaluate getLine up to the (invisible for you) IO operator
14:13:49 <BONUS> hmm
14:14:04 <Botje> s/operator/data constructor/
14:14:34 <Botje> if you want to do two getLines, use replicateM 2 getLine
14:15:46 <Qantourisc> Botje: ok this is the senario: i need to return a X(), but i wish it to perform 2 X()'s ... wait i should write a function for that right ?
14:15:58 <Botje> .. what?
14:16:21 <Botje> X is a monad action or somesuch?
14:17:39 <Qantourisc> Botje: yes
14:18:10 <maltem> Qantourisc: for what its worth there's no () in the type of getLine
14:18:35 <Qantourisc> maltem: getLine was an easy way to get a function :)
14:19:07 <Botje> Qantourisc: then you use replicateM or liftM2 or somesuch
14:19:27 <Botje> :t replicateM 2 getLine
14:19:28 <lambdabot> IO [String]
14:19:34 <Botje> :t liftM2 (,) getLine
14:19:35 <lambdabot> forall a2. IO a2 -> IO (String, a2)
14:19:36 <maltem> Qantourisc: anyways when you work with a monad, you use the functions that operate on monadic values. return, (>>=), (>>) and friends
14:19:48 <Botje> :t liftM2 (,) getLine getLine
14:19:50 <lambdabot> IO (String, String)
14:20:15 <BMeph> I think a more constructive "myth" to bust would be the one of "pure languages don't allow side-effects", and not "pure languages tell you when you have side-effects, and when you don't (or shouldn't)". :)
14:21:39 <vixey> BMeph, I guess the problem is when you have a pure model of mutation and execute it using real mutation (like the ST monad), it's not really pure anymore
14:22:02 <luite> "It is similar to Data.Array.IO.IOUArray but slower. Its advantage is that it's compatible with C." <- about Data.Array.Storable, why is it slower than a IOUArray?
14:22:11 <vixey> (but every function is still a pure function, so.. ?)
14:23:28 <ddarius> luite: It's more general and it has to serialize/deserialize.
14:24:05 <BMeph> vixey: Hmm, try ST in a lens? :)
14:24:51 <geezusfreeek> conal, if you are still around i could use some wisdom about collections of behaviors. i have an event that generates behaviors which i need to run concurrently, but the behaviors don't last forever. how would you go about using them without holding on to them indefinitely?
14:25:28 <BMeph> luite: Because you have to come up with the resources yourself instead of borrowing it? ;p
14:25:47 <vixey> BMeph, I don't know about lenses
14:25:58 <BMeph> luite: Oh, right, wrong kind of "IOUArray". ;P
14:26:24 <luite> BMeph: IOUNoArray!
14:27:13 <BMeph> vixey: I don't either, but I have heard whispers about it. I keep trying to find more info about it other than the Harmony/Boomerang lit, but with no success. Maybe quickie knows... :)
14:27:15 <luite> ddarius: hm, I thought that a IOUArray was basically a wrapper around something resembling a C array (though not necessarily compatible).
14:27:38 <fco> wow! it works! and it's slow!!!
14:27:39 <vixey> yeah
14:27:47 <fco> thank you guys!
14:28:03 <conal> geezusfreeek: is your type a monoid, so that you can transition to 'pure mempty' when done?
14:28:12 <conal> geezusfreeek: and combine with mappend.
14:28:49 <ski_> (BMeph : .. but pure languages don't allow side-effects)
14:28:52 <BONUS> @pl \x -> if x > 2 then "ha" else "HA"
14:28:53 <lambdabot> flip (flip if' "ha" . (> 2)) "HA"
14:29:00 <BONUS> ah, it uses if'
14:29:29 <ski_> (BMeph : however,  they can allow effects .. such as I/O, state, nondeterminism, parsing, ...)
14:30:04 <geezusfreeek> conal, are you asking if i have something that would unify with Monoid a => Event (Behavior t a) ?
14:31:34 <ski_> (vixey : why would it not be pure anymore ?)
14:32:12 <conal> geezusfreeek: i'm trying to get a handle on what not lasting forever might mean.
14:32:14 <geezusfreeek> i assume you are hinting at using switcher to make the dead behaviors yield mempty, but the problem i see with that is that those behaviors are still in the collection
14:32:37 <conal> geezusfreeek: is it important to have a collection?
14:33:08 <conal> geezusfreeek: i.e., a collection of behaviors
14:34:14 <geezusfreeek> conal, the type is a position that is used to render a bullet later. if i need a collection to render all the current bullets then the answer is yes (this is the way i am currently doing it. there is just now way i can see to remove the old behaviors from the system entirely)
14:35:12 <geezusfreeek> ignore "later", and s/now way/no way/
14:35:26 <vixey> ski_, when you think about your model as reality
14:35:57 <BONUS> @pl do {a <- return 3; b <- return 8; return (a+b)}
14:35:58 <lambdabot> (line 1, column 4):
14:35:58 <lambdabot> unexpected "{"
14:35:58 <lambdabot> expecting variable, "(", operator or end of input
14:36:07 <vixey> ski_, like the model of mutation is executed by actual mutation
14:36:27 <ski_> yes ?
14:37:27 <ski_> presumably constructor applications are implemented by actually mutating memory too
14:37:52 <conal> geezusfreeek: how do you accumulate this collection of bullet position behaviors?
14:38:12 <ski_> (i suppose i'm asking for when you think something is pure ..)
14:39:06 <bohdan> http://haskell.org/ghc/docs/latest/html/libraries/random/System-Random.html -- crosslinks are broken
14:39:14 <bohdan> e.g. http://haskell.org/ghc/docs/latest/html/libraries/random/System-Random#globalrng.html -- 404
14:39:22 <bohdan> who can fix this?
14:39:41 <pumpkin> looks like fail to me
14:39:43 <geezusfreeek> i'm using accumE to get Event [Behavior t a], then using sequenceA to get Event (Behavior [a]), then using switcher with pure [] to get Behavior [a]
14:39:47 <geezusfreeek> conal, ^
14:40:04 <xEpicFailGuyx> howdy ho, haskellrinos!
14:40:07 <geezusfreeek> it all may be a bad idea. i just don't know how else to do it right now
14:40:42 <xEpicFailGuyx> how do I define a type such as 'data Quux a = Quux a' in such a way that 'a' belongs to a certain class?
14:40:48 <CakeProphet> :k Either
14:40:50 <lambdabot> * -> * -> *
14:41:16 <vixey> xEpicFailGuyx: I think it's lieke  Foo a => Quux a, I never do it though because type inference handles it
14:41:24 <CakeProphet> a challenge #haskell -- find the longest kind in Prelude/hackage/standard-stuff
14:41:32 <vixey> :k RWST
14:41:34 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
14:41:37 <rwbarton> xEpicFailGuyx: General opinion is that it's best not to and instead put the class contexts on your functions that need it.
14:41:47 <CakeProphet> vixey:  what on earth is that
14:41:51 <vixey> idk :P
14:42:28 <BONUS> hmm
14:42:33 <xEpicFailGuyx> rwbarton: ok ... well the reason I'm asking is because I want to make a neural network module and my neurons can either have input from signals or other neurons, both of which would belong to an Input class
14:42:45 <BONUS> you can make a very mapM'-like function using only Applicative
14:42:54 <BONUS> i mean mapM
14:43:02 <xEpicFailGuyx> It seems easier to put a class context in one place
14:43:18 <CakeProphet> alternative challenge: create a /useful/ type that has the longest kind ever.
14:43:18 <rwbarton> xEpicFailGuyx: But it wouldn't actually work that way.
14:43:26 <xEpicFailGuyx> rwbarton: Why not ...
14:43:38 <BONUS> mapM' f [] = pure []; mapM' f (x:xs) = (:) <$> f x <*> mapM' f xs
14:43:40 <BONUS> any thoughts on this?
14:43:48 <rwbarton> xEpicFailGuyx: You'd need to put the class contexts on the functions that used the data Quux anyways.
14:44:01 <geezusfreeek> CakeProphet, (,,,,,,,,,,,,,,,,,,,,,,,,,,,,...)
14:44:15 <xEpicFailGuyx> rwbarton: Ah got it ... let me write that down and I'll try to figure it out at some point
14:44:21 <ddarius> vixey: You might find this interesting.
14:44:22 <CakeProphet> :k (,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
14:44:27 <lambdabot> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> * -> *
14:44:27 <CakeProphet> :D
14:44:39 <vixey> CakeProphet, haha you win
14:44:43 <vixey> oh geezusfreek got it
14:44:44 <CakeProphet> yep. I believe you found it. it'd be hard to get much bigger.
14:44:47 <CakeProphet> vixey:  yeah
14:44:49 <BONUS> hmm, should mapM be generalized to Applicative?
14:44:59 <BONUS> in like, future versions of Haskell
14:44:59 <conal> geezusfreeek: maybe you're looking for something like Event (Behavior ([a] -> [a])), where each generated behavior starts out as a cons and then becomes an id.
14:45:01 <rwbarton> @type Data.Traversable.mapM
14:45:02 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Monad m, Data.Traversable.Traversable t) => (a -> m b) -> t a -> m (t b)
14:45:05 <BONUS> or is something lost in doing that
14:45:06 <rwbarton> @type Data.Traversable.mapA
14:45:08 <vixey> ddarius, which?
14:45:09 <lambdabot> Not in scope: `Data.Traversable.mapA'
14:45:11 <conal> geezusfreeek: as your bullet generator.
14:45:12 <rwbarton> @hoogle mapA
14:45:15 <lambdabot> Data.IntMap mapAccum :: (a -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
14:45:17 <lambdabot> Data.Map mapAccum :: (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
14:45:17 <ddarius> vixey: http://homepages.inf.ed.ac.uk/als/Talks/mfps07.pdf sorry
14:45:19 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
14:45:27 <CakeProphet> I bet handwriting the tuple instance stuff would be a huge pain
14:45:43 <enticingjelly> @doc RWST
14:45:43 <lambdabot> RWST not available
14:45:45 <bohdan> @pl \k -> (\k1 -> a (take k b) (k-1), [])
14:45:46 <lambdabot> flip (,) [] . const . ap (a . flip take b) (subtract 1)
14:45:47 <Captain_Cab> hoi
14:45:56 <xEpicFailGuyx> This channel is so helpful :D
14:46:14 <Asztal> ReaderWriterStateT?
14:46:26 <conal> geezusfreeek: which perhaps you could build out of an Event (Behavior (Maybe a))
14:46:41 <ski_> @type Data.Traversable.traverse
14:46:43 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Applicative f, Data.Traversable.Traversable t) => (a -> f b) -> t a -> f (t b)
14:46:46 <ski_> BONUS : ^
14:47:01 <rwbarton> ski_: aha
14:47:11 <rwbarton> ski_: why isn't it called mapA? :)
14:47:16 <ski_> no idea
14:47:18 <enticingjelly> sheesh. there I am, combining Monad Transformers to ridiculous lengths and of course there had to be an RWS monad,.
14:47:25 <conal> geezusfreeek: or an Event (Behavior [a]) plus (++), which is more general yet, allowing bullets to split after being fired, as well as disappearing.
14:47:30 <BONUS> ah. and it should be equivalent to mapM when ran on monads, right?
14:47:35 <ski_> aye
14:47:44 <ski_> (since monads are applicative)
14:47:48 <BONUS> yeah
14:47:52 <conal> geezusfreeek: which could generalized to arbitrary monoids
14:48:02 <bohdan> can I define a type check inside of an expression?
14:48:16 <geezusfreeek> conal, OOH i will actually need to be able to split bullets later!
14:48:27 <conal> geezusfreeek: !
14:48:38 <geezusfreeek> conal, i will mull over your suggestion. thank you!
14:48:59 <conal> geezusfreeek: i've been thinking it'd be fun to do asteroids that way.  was my motivation for event monad.
14:49:02 <eu-prleu-peupeu> why is darcs so good ?
14:49:05 <eu-prleu-peupeu> i like svn :P
14:49:11 <conal> geezusfreeek: my pleasure.  please let me know how it goes.
14:49:12 <eu-prleu-peupeu> the revisions concept
14:49:16 <geezusfreeek> conal, i _still_ don't understand the event monad
14:49:19 <eu-prleu-peupeu> and being atomic and all
14:49:25 <geezusfreeek> and the game i'm doing is asteroids-like
14:49:31 <proq> eu-prleu-peupeu: who said darcs was so good?  svn otoh isn't good either  :P
14:49:52 <eu-prleu-peupeu> i like svn, it works fine for me
14:49:53 <arjanb> bohdan: you can use (some_exp :: some_type)
14:49:59 <ski_> CakeProphet : another challenge, find the highest-order type in libs
14:50:23 <CakeProphet> highest order?
14:50:28 <rwbarton> @type callCC
14:50:29 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
14:51:00 <conal> geezusfreeek: i think of the event monad as being just like the list monad but temporally sorted.
14:51:03 <ski_> `callCC' is a value of order 3
14:51:12 * ski_ asked about *types*, though ..
14:51:18 <conal> geezusfreeek: almost equivalent to the list monad followed by a time-sort
14:51:26 <ski_> (well, at least 3 ..)
14:51:35 <conal> geezusfreeek: except that it works even when the intermediate lists are infinite.
14:51:39 <rwbarton> ski_: oh, I'd have called that the highest-order kind then
14:51:46 <ski_> @kind RWST
14:51:48 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
14:52:19 <ski_> has order 2 (we disregard curried things which might be tupled (had haskell any type tuples ..))
14:52:30 <rwbarton> category-extras probably has some crazy ones
14:52:40 <ski_> rwbarton : well, we say "`callCC' is a higher-order function (or value)"
14:53:06 <fco> ok, I modified my function, and it never runs out of file descriptors anymore, but, because of the lazy nature of the call to md5 and the strict Data.ByteString.readFile, all the contents are copied to ram until memory is exhausted!! the new code is in http://hpaste.org/13511
14:53:16 <geezusfreeek> conal, yeah i get how it works, i just don't get how it's used
14:53:20 <conal> geezusfreeek: my suggestions about Event (Behavior [a]) and Event (Behavior ([a] -> [a])) are closely related, since [a] -> [a] is one representation of lists (see the dlist package).  in the latter mappend = (.)
14:54:24 <proq> eu-prleu-peupeu: try using a nib file or other file (which is really a folder) as a template for a new nib and you'll quickly see one of svn's many failures
14:54:36 <pumpkin> that's why you use a xib file!
14:54:41 <pumpkin> ;)
14:54:48 <rwbarton> fco: it might just take changing 'return $' to 'return $!'
14:55:21 <fco> rwbarton: sorry about my ignorance, what is $! astrict version of $??
14:55:36 <eu-prleu-peupeu> proq: what is a nib file ?
14:55:38 <rwbarton> fco: Yep
14:55:40 <rwbarton> @src ($!)
14:55:40 <lambdabot> f $! x = x `seq` f x
14:58:01 <fco> rwbarton: oh, I see! learning haskell is absolutely thrilling!
14:58:19 <vixey> ddarius, it's a little strange they take the powerset I didn't know you could do this in intuitionist set theory... (infact I thought that it implies excluded middle)
14:59:06 <proq> eu-prleu-peupeu: what matters is that it's a multi-level directory with data, and svn can't handle duplicating it without the user cleaning all the .svn directories
14:59:27 <schme> evenin'
15:00:11 <fco> rwbarton if I use $! then I don't need to use the strict readFile and that would mean that I can process files bigger than my ram
15:00:55 <proq> eu-prleu-peupeu: modern version control (like darcs or git) place one .darcs/.git directory at the root directory
15:01:13 <awesame> proq: I want to hug git every time I notice not having to screw with .svn directories
15:01:41 <bohdan> > do a<-return 1 ; return b where b = a
15:01:42 <lambdabot>       No instance for (Show (t Expr))
15:01:42 <lambdabot>        arising from a use of `show' at ...
15:02:09 <Botje> bohdan: put {} around it
15:02:09 <bohdan> I get a parse error on this
15:02:27 <ski_> bohdan : `where' is not valid as a command inside `do'-expressions
15:02:39 <Botje> ah, yeah. you need to use let for that
15:02:40 <eu-prleu-peupeu> well, my webhosting provider only has svn support
15:02:46 <bohdan> why?
15:02:48 <eu-prleu-peupeu> so i guess it will have to do
15:03:05 <ski_> bohdan : what you wrote is equal to `(do {a <-return 1 ; return b}) where b = a'
15:03:13 <rwbarton> fco: Yes, true.  Good point.
15:03:23 <bohdan> so what's the right way then?
15:03:29 <bohdan> with when :)
15:03:33 <bohdan> err where
15:03:59 <ski_> do {a <- return 1; let {b = a}; return b}
15:04:46 <ddarius> vixey: The powerset is "just" a function space.
15:05:16 <vixey> I'm not sure what does that mean?
15:05:27 <Olathe> return 1 >>= return
15:05:46 <ddarius> P(X) ~ X->2  and intuitionistic set theory is surely cartesian closed.
15:05:46 <vixey> it's kind of like wring  a -> b  but not actually producing an/every inhabitant?
15:05:49 <ski_> @pl return 1 >>= return
15:05:50 <lambdabot> return 1
15:06:13 <geezusfreeek> conal, okay, i think your suggestion will work, and more elegantly that my hack of a solution. thanks again
15:06:13 <ddarius> Except we don't use 2 we use Omega which is only 2 is the classical case.
15:06:15 <Olathe> @do return 1
15:06:15 <lambdabot> return 1 not available
15:06:20 <Olathe> @redo return 1
15:06:21 <lambdabot> return 1
15:06:24 <geezusfreeek> *than
15:06:38 <Olathe> @undo { return 1 }
15:06:39 <lambdabot>  Parse error at "{" (column 1)
15:06:45 <Olathe> @undo do { return 1 }
15:06:46 <lambdabot> return 1
15:06:48 <ddarius> Which allows you to have things roughly like Omega = {true, false, undefined}
15:07:23 <ski_> (or `Omega = {true, almost true, almost (almost true), ...}'
15:07:25 <ski_> )
15:07:42 <ddarius> ski_: Or Omega = Time -> 2
15:07:54 <ski_> (`false' being `fix almost')
15:08:41 <hcube> hi! is here anyone who has experience with hopengl? i'd like to ask a question: how can i make an interleaved vertex array? I'd like to store position,norlmal,colour,texcoord in one array. what will be the type of this?  if only i store just positions then the array type is Ptr(Vertex3 GLfloat) but in interleaved case it should be Ptr(Vertex3 GLfloat + Normal3 GLfloat + TexCoord1/2/3 GLFloat + etc)
15:09:11 <ski_> (ddarius : aye)
15:12:20 <ddarius> ski_: I'm curious if you find this proof adequate for you (as in you could more or less flesh out the details and can readily see that it proves the theorem): Theorem: It is consistent with intuitionistic set theory for there to exist a set X such that X ~ X^X in which there exist a,b in X with a /= b. Proof: Apply Yoneda lemma to domain-theoretic model of untyped lambda calculus.
15:14:07 <ski_> ddarius : it's not. however, that may have something to do with me not being that familiar with Yoneda lemma
15:14:15 <conal> geezusfreeek: great! :)
15:14:54 <ski_> (as in, i don't recall exactly what it states .. i only recall it is related to Church-encodings of inductive types)
15:17:11 <ddarius> ski_: I believe all you need in this case is the corollary that the Yoneda functor Y = \X.\Y.Hom(Y,X): C -> [C^op, Set] is full and faithful.
15:18:13 <ddarius> Admittedly, there are several other results and connections needed to make sense of the proof.
15:21:26 <dufflebu1k> Sometimes, reddit comments just make my day: http://www.reddit.com/r/programming/comments/7mroa/why_is_haskell_so_popular_on_reddit_what_does_it/81z6
15:21:58 <dufflebu1k> Not to say I think it's true. But it's still funny.
15:22:01 <CakeProphet> > unsafePerformIO (print "lol")
15:22:03 <lambdabot>   Not in scope: `unsafePerformIO'
15:22:49 <Olathe> > unsafePerformIO (print "lol")
15:22:51 <lambdabot>   Intruder alert !
15:22:56 <athos> ;p;
15:22:57 <athos> :>
15:23:33 <athos> > unsafePerformIO (print "launch ICBM")
15:23:35 <lambdabot>   Intruder alert !
15:23:41 <athos> 8/
15:31:41 <mohbana> does pandoc / markdown have an irc channel?
15:34:13 <bohdan> @pl a >>= return f
15:34:14 <lambdabot> return f =<< a
15:34:26 <Saizan> nice..
15:34:41 <bohdan> isn't there a way to combine >>= return into one?
15:35:00 <pumpkin> fmap kinda does that
15:35:04 <Saizan> did you mean a >>= return . f?
15:35:04 <pumpkin> but it's a ltitle different
15:35:59 <chrisdone> mohbana: why do you ask?
15:36:32 <bohdan> just wondering
15:36:51 <bohdan> I see that I often need to write ' x >>= return z'
15:37:33 <rwbarton> @type ?x >>= return ?z
15:37:34 <lambdabot> forall (m :: * -> *) a b. (Monad m, ?z::m b, ?x::m a) => m b
15:37:39 <pumpkin> > [1,2,3] >>= return (+1)
15:37:41 <lambdabot>       The section `(+ 1)' takes one argument,
15:37:41 <lambdabot>      but its type `[b]' has none
15:37:43 <pumpkin> > [1,2,3] >>= return . (+1)
15:37:45 <lambdabot>   [2,3,4]
15:37:54 <pumpkin> > fmap (+1) [1,2,3]
15:37:55 <lambdabot>   [2,3,4]
15:37:59 <pumpkin> > fmap (+1) Just 5
15:38:01 <lambdabot>       No instance for (Num (Maybe a))
15:38:01 <lambdabot>        arising from the literal `1' at ...
15:38:03 <pumpkin> > fmap (+1) $ Just 5
15:38:05 <lambdabot>   Just 6
15:38:19 <Saizan> x >>= return z == x >> z
15:38:21 <Badger> cross your $s and dot your .s :P
15:38:28 <pumpkin> :P
15:38:29 <pumpkin> yeah
15:38:35 <pumpkin> > Just 5 >>= return . (+1)
15:38:36 <lambdabot>   Just 6
15:38:37 <rwbarton> Saizan: Are you sure it's not just z?
15:38:38 <CakeProphet> does a where clause bind to every pattern in a function or just one?
15:38:47 <sbahra> every
15:38:47 <chrisdone> Saizan: that's wrong?
15:38:51 <rwbarton> > [1,2,3] >>= return [4,5,6]
15:38:52 <CakeProphet> good.
15:38:52 <pumpkin> bohdan: is that what you're talking about?
15:38:52 <lambdabot>   [4,5,6,4,5,6,4,5,6]
15:38:55 <sbahra> yes.
15:38:59 <rwbarton> Saizan: I guess you're right
15:39:15 <Saizan> chrisdone: wrong?
15:39:29 <rwbarton> Saizan: oh, I see
15:39:31 <ddarius> It's right, but unlikely what is intended.
15:39:39 <rwbarton> bohdan: I'm sure you never write x >>= return z.
15:39:40 <ddarius> x >>= return z = x >>= const z
15:40:03 <chrisdone> you mean x >> return z = x >>= const z ?
15:40:11 <bohdan> @pl a >>= return . f
15:40:12 <lambdabot> f `fmap` a
15:40:16 <bohdan> right
15:40:19 <bohdan> . f
15:40:22 <Saizan> you need Control.Monad.Reader or .Instances to make that typecheck
15:40:23 <pumpkin> :)
15:40:24 <ddarius> chrisdone: I meant what I said.
15:41:12 <chrisdone> right...
15:41:14 <ddarius> More fully, x >>= return z = x >>= const z = x >> z,  x >> return z = x >>= const (return z)
15:42:28 <CakeProphet> > map (-1) [1..100]
15:42:29 <chrisdone> the second clause makes sense to me, but how is x >>= return z = x >>= const z?
15:42:29 <lambdabot>       No instance for (Num (a -> b))
15:42:29 <lambdabot>        arising from a use of `negate' at...
15:42:33 <CakeProphet> > map (sub 1) [1..100]
15:42:35 <lambdabot>   Not in scope: `sub'
15:42:37 <CakeProphet> > map (subtract 1) [1..100]
15:42:39 <CakeProphet> :(
15:42:39 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
15:42:50 <CakeProphet> > plus 1 2
15:42:52 <lambdabot>   Not in scope: `plus'
15:42:53 <ddarius> @src (->) return
15:42:53 <lambdabot> return = const
15:43:00 <CakeProphet> >add 1 2
15:43:05 <CakeProphet> > add 1 2
15:43:07 <lambdabot>   Not in scope: `add'
15:43:18 <pumpkin> CakeProphet: (+) ? :P
15:43:24 <CakeProphet> is there a synonym for (+)?
15:43:32 <pumpkin> don't think so, why?
15:43:32 <CakeProphet> I'm being OCD about the symmetry of my program.
15:43:33 <chrisdone> oh, right, for (->)
15:43:38 <pumpkin> CakeProphet: you mean for subtract?
15:43:45 <CakeProphet> that too
15:43:53 <pumpkin> I mean, an analog to subtract
15:43:58 <CakeProphet> -nod-
15:44:04 <ddarius> CakeProphet: subtract isn't a synonym for (-)
15:44:08 <baaba> :t (+1)
15:44:09 <lambdabot> forall a. (Num a) => a -> a
15:44:11 <sbahra> :t substract
15:44:13 <lambdabot> Not in scope: `substract'
15:44:13 <baaba> :t (-1)
15:44:14 <vixey> CakeProphet, can't use: (+)
15:44:14 <lambdabot> forall a. (Num a) => a
15:44:16 <sbahra> :t subtract
15:44:17 <lambdabot> forall a. (Num a) => a -> a -> a
15:44:19 <ddarius> Though I guess flip (+) is (+) (or at least is intended to be)
15:44:20 <CakeProphet> :t (-)
15:44:21 <lambdabot> forall a. (Num a) => a -> a -> a
15:44:22 <sbahra> :t (-)
15:44:23 <lambdabot> forall a. (Num a) => a -> a -> a
15:44:29 <CakeProphet> how does unary - work?
15:44:33 <ddarius> > (x - y, subtract x y)
15:44:34 <pumpkin> evil
15:44:34 <lambdabot>   (x - y,y - x)
15:44:38 <baaba> nasty special case :<
15:44:46 <CakeProphet> ah okay..
15:44:53 <sbahra> @src subtract
15:44:53 <lambdabot> subtract x y = y - x
15:45:01 <CakeProphet> -nod- I know the difference between the two
15:45:12 <CakeProphet> map (-1::a->a) [1..100]
15:45:20 <CakeProphet> > map (-1::a->a) [1..100]
15:45:21 <lambdabot>       Could not deduce (Num (a -> a)) from the context ()
15:45:21 <lambdabot>        arising from...
15:45:33 <ddarius> http://lambda-the-ultimate.org/node/3134#comment-45941 Wow
15:45:52 <athos> > map (-1) [1..100]
15:45:53 <lambdabot>       No instance for (Num (a -> b))
15:45:53 <lambdabot>        arising from a use of `negate' at...
15:45:57 <sbahra> > map ((-) 1) [1 .. 10]
15:45:59 <lambdabot>   [0,-1,-2,-3,-4,-5,-6,-7,-8,-9]
15:46:02 <athos> > map ((-) 1) [1..100]
15:46:03 <lambdabot>   [0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-...
15:46:05 <athos> 8]
15:46:13 <sbahra> > map (subtract 1) [1 .. 10]
15:46:14 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
15:47:00 <mohbana> chrisdone: hi, do you use it?
15:48:08 <baaba> > map (flip (-) 1) [1 .. 10]
15:48:09 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
15:49:59 <vixey> it's a bit difficult for me ddarius :(
15:50:17 <vixey> Scott Domains came up in this other thing I was reading too and I don't get it..
15:53:32 <BMeph> > map (`subtract` 1) [1 .. 10]
15:53:34 <lambdabot>   [0,-1,-2,-3,-4,-5,-6,-7,-8,-9]
15:53:48 <pumpkin> lol
15:53:49 <BMeph> \o/
15:53:58 <pumpkin> really useful
15:54:08 <athos> :)
15:54:36 <bohdan> @pl flip (-) 1
15:54:36 <lambdabot> subtract 1
15:54:48 <athos> @unpl subtract 1
15:54:49 <lambdabot> subtract 1
15:54:52 <athos> !
15:55:14 <ddarius> vixey: Here's a mildly interesting exercise from it that doesn't require anything but what was defined in the slides, or alternatively what you already know from programming: Using the Uniformity property of the fixpoint operator (p. 52) (aka the free theorem) prove the exercise on p. 53, i.e. given domains (D,_|_1) and (D,_|_2) _|_1 = _|_2
15:55:15 <athos> @pl fix x = let x = f x in x
15:55:15 <lambdabot> fix = fix (const . ($ f))
15:55:26 <athos> @unpl fix = fix (const . ($ f))
15:55:27 <lambdabot> fix = fix (\ e _ -> e f)
15:55:55 <ddarius> @pl fix = fix (\e _ -> e f)
15:55:55 <lambdabot> fix = fix ($ const . ($ f))
15:56:06 <Axman6> :t (:). ?f
15:56:07 <lambdabot> forall b a. (?f::a -> b) => a -> [b] -> [b]
15:56:17 <mohbana> does pandoc / markdown have an irc channel?
15:56:25 <Olathe> @pl fix f = f (fix f)
15:56:26 <lambdabot> fix = fix (ap id)
15:56:32 <Axman6> :t foldr ((:). ?f) []
15:56:33 <lambdabot> forall b a. (?f::a -> b) => [a] -> [b]
15:56:47 <pumpkin> mohbana: are you on a timer?
15:56:47 <athos> @unpl fix = fix (ap id)
15:56:47 <lambdabot> fix = fix (\ f -> (\ a -> a) >>= \ c -> f >>= \ b -> return (c b))
15:56:58 <athos> neat!
15:57:06 <Olathe> fix is...monadic.
15:57:15 <athos> :t ap
15:57:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
15:57:18 <Axman6> > let map f = foldr ((:). f) [] in map (2^) [1..10)
15:57:19 <lambdabot>   <no location info>: parse error on input `)'
15:57:21 <Axman6> > let map f = foldr ((:). f) [] in map (2^) [1..10]
15:57:22 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024]
15:57:24 <ddarius> vixey: Anyway, just skip details that don't make sense to you.
15:57:34 <Axman6> ah nice
15:57:53 * bohdan really wants to install goa now :)
15:58:39 <Olathe> shapr version 3 ?
15:59:15 <athos> > let map f = reverse$foldl (flip ((:).f)) [] in map f [1..10]
15:59:17 <lambdabot>   Add a type signature
15:59:20 <athos> > let map f = reverse$foldl (flip ((:).f)) [] in map (*2) [1..10]
15:59:21 <lambdabot>   Couldn't match expected type `[a]'
15:59:38 <athos> > let map f xs = reverse$foldl (flip ((:).f)) [] xs in map (*2) [1..10]
15:59:40 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
15:59:49 <athos> @pl let map f xs = reverse$foldl (flip ((:).f)) [] xs in map (*2) [1..10]
15:59:49 <Olathe> @type let map f = reverse$foldl (flip ((:).f)) [] in map
15:59:50 <lambdabot> reverse (foldl (flip ((:) . (2 *))) [] [1..10])
15:59:51 <lambdabot>     Couldn't match expected type `[a]'
15:59:51 <lambdabot>            against inferred type `[b1] -> [b]'
15:59:51 <lambdabot>     In the second argument of `($)', namely `foldl (flip ((:) . f)) []'
16:00:37 <Saizan> \f -> reverse . foldl (flip ((:).f)) []
16:00:49 <athos> @pl let map f = reverse . foldl (flip ((:).f)) [] in map (*2) [1..10]
16:00:49 <lambdabot> reverse (foldl (flip ((:) . (2 *))) [] [1..10])
16:01:00 <Olathe> > let map f = scanl1 (\a b -> f b) in map (*2) [1..5]
16:01:02 <lambdabot>   [1,4,6,8,10]
16:01:24 <Olathe> > let map f (x:xs) = scanl (\a b -> f b) (f x) in map (*2) [1..5]
16:01:25 <lambdabot>       Overlapping instances for Show ([b] -> [b])
16:01:25 <lambdabot>        arising from a use o...
16:01:29 <Olathe> Lies !
16:01:36 <Olathe> > let map f (x:xs) = scanl (\a b -> f b) (f x) xs in map (*2) [1..5]
16:01:38 <lambdabot>   [2,4,6,8,10]
16:02:02 <athos> hehe
16:02:07 <Axman6> oh noes, what about []!
16:02:17 <Olathe> > let map f (x:xs) = scanl (\a b -> f b) (f x) xs in map (*2) []
16:02:19 <lambdabot>   * Exception: /tmp/8124263584336810567:71:40-82: Non-exhaustive patterns in ...
16:02:27 <Olathe> See, nothing in the resulting list.
16:02:43 <Axman6> heh
16:02:54 <athos> @pl let map f (x:xs) = scanl (\a b -> f b) (f x) xs in map (*2) []
16:02:54 <lambdabot> scanl (const (2 *)) (head [] * 2) (tail [])
16:03:14 <athos> @pl let map f (x:xs) = scanl (\a b -> f b) (f x) xs
16:03:14 <lambdabot> (line 1, column 48):
16:03:14 <lambdabot> unexpected end of input
16:03:14 <lambdabot> expecting variable, "(", operator, ";" or "in"
16:03:20 <bohdan> @pl mapM (return . const 1) [1..100]
16:03:20 <lambdabot> mapM (return . const 1) [1..100]
16:03:22 <athos> @pl map f (x:xs) = scanl (\a b -> f b) (f x) xs
16:03:22 <lambdabot> map = (`ap` tail) . (. head) . ((.) =<< scanl . const)
16:03:30 <athos> whoa.
16:03:32 <athos> :>
16:03:37 <athos> @unpl map = (`ap` tail) . (. head) . ((.) =<< scanl . const)
16:03:38 <lambdabot> map i = (\ r -> (scanl >>= \ c d e -> c (d e)) (\ _ -> i) (head r)) >>= \ w -> tail >>= \ v -> return (w v)
16:07:25 <bohdan> so I have (head xs) : recurse ...
16:07:40 <bohdan> how would I non-lazily apply head xs ?
16:08:59 <pumpkin> seq?
16:10:14 <Olathe> C ?
16:11:13 <bohdan> hmm, actually 'f xs@(x:_)' seems to have helped here
16:11:22 <pumpkin> you could also use $!, which is just xs `seq` head xs
16:15:59 <chessguy> zzzzzz
16:16:20 <eu-prleu-peupeu> bahh
16:16:27 <eu-prleu-peupeu> seems like all the .com's are already registered
16:17:04 <eu-prleu-peupeu> someone with a lot of money must have been runing a brute-forcer for .com registrations
16:17:32 <eu-prleu-peupeu> a.com, aa.com, aaa.com, aaaa.com .. zzzzzzzzzzzzzzzzzz.com
16:18:57 <bohdan> @pl \(a,b) -> (b,a)
16:18:57 <lambdabot> uncurry (flip (,))
16:19:20 <luite> is an Int64 guaranteed to have the full 64 bit precision? Is it safe to cast a Ptr Int64 to a Ptr CInt on a 64 bit system?
16:19:45 <Cale_> luite: yes
16:19:49 <ddarius> Yes.  No in theory but probably Yes in practice.
16:20:20 <bohdan> @pl \a f -> (a, f a)
16:20:21 <lambdabot> liftM2 (.) (,) (flip id)
16:20:37 <bohdan> @pl \f a -> (a, f a)
16:20:38 <lambdabot> ap (,)
16:20:40 <Cale> oh, right, you probably should use fromIntegral...
16:20:56 <BMeph> ddarius, luite: Wouldn't that be "yes" to the first Q, but "possibly yes" to the second? ;)
16:21:02 <bohdan> @pl flip ap (,)
16:21:02 <luite> is it different from a regular Int? I just tried a castPtr from a Ptr Int to a Ptr CInt on my system (64 bit), but my program segfaulted
16:21:03 <lambdabot> (`ap` (,))
16:21:08 <koeien> can i have an existential type with more than one constructor, with different type class requirements?
16:21:32 <Cale> koeien: yes
16:21:34 <bohdan> @pl \f a -> (f a, a)
16:21:34 <lambdabot> ((,) =<<)
16:21:45 <koeien> Cale: thanks
16:21:48 <Cale> koeien: I like using the GADT syntax.
16:21:54 <sbahra> Any of you hear of or work with "Patrick Thomson"?
16:21:58 <koeien> even though it's not a GADT?
16:21:59 <sbahra> He is a "seasoned Haskell programmer".
16:22:05 <sbahra> Sorry, "seasoned Haskell hacker".
16:22:06 <Cale> koeien: right.
16:22:15 <koeien> Cale: it's probably clearer
16:22:18 <Cale> koeien: Existential types are a special case of GADTs
16:22:42 <koeien> ah, ok. i've used both in the past but never realized that :)
16:22:51 <BMeph> luite: Yes, it's different from a regular Int. :)
16:22:52 <luite> Cale: I currently use fromIntegral to convert the data, but all the conversions from my haskell to C data types (UArr Int -> Ptr CInt) and back take a lot of time
16:23:00 <HairyDude> hmm. it seems you can't add extra instances to RandT, because it's abstract.
16:24:14 <Cale> HairyDude: You can.
16:24:18 <luite> BMeph: does the regular int store some flags in the most significat bits?
16:24:25 <Cale> HairyDude: You just have to write them in terms of the existing instances.
16:24:48 <Cale> HairyDude: Or add them to the actual module where RandT is defined
16:25:01 <bohdan> @pl \f m -> (m >>= f, m >>= print)
16:25:02 <lambdabot> (`ap` (print =<<)) . ((,) .) . (=<<)
16:25:10 <bohdan> @pl \m f -> (m >>= f, m >>= print)
16:25:11 <lambdabot> ap (flip . ((,) .) . (>>=)) (print =<<)
16:25:50 <michaelcdever> i have a function that gets the contents of a directory, then should check if each content is another directory, if so, a function should be carried out, but im getting an indentation error, cant see where it is though!
16:25:54 <michaelcdever> code is at http://pastebin.com/mc8c17a
16:26:13 <koeien> michaelcdever: line 4.
16:26:20 <HairyDude> Cale: I mean, if StateT has an instance that is also the correct one to use for RandT, you can't use it because you can't get at the StateT inside the RandT constructor.
16:26:21 <koeien> michaelcdever: you're missing a -> after your lambda operator
16:26:31 <koeien> s/operator//
16:26:43 <Cale> michaelcdever: First of all, you have tabs in your code
16:26:51 <michaelcdever> ah sorry, i have thge -> in my code here, im typing across from a virtual machine
16:27:03 <Axman6_> ?users
16:27:04 <lambdabot> Maximum users seen in #haskell: 588, currently: 566 (96.3%), active: 18 (3.2%)
16:27:09 <twanvl> luite: isn't a CInt 32 bits even on many 64 bit systems?
16:27:10 <Cale> michaelcdever: It's a good policy generally to ensure that there are no tabs in your source files -- have your editor replace them with spaces automatically.
16:27:15 <michaelcdever> calie: i have tabs anyway, and all the other functions work
16:27:22 <ddarius> luite: A regular Int may be boxed and it's only guaranteed to be 29-bits.  In practice, for GHC, it matches the machine word size though things may be a little finnicky on 64-bit systems running 32-bit.
16:27:37 <Cale> michaelcdever: Yes, but you'll be annoyed by problems like this repeatedly as long as you use tabs
16:27:54 <Cale> But actually the real problem is that you're missing an else
16:28:00 <bohdan> @pl m >>= \a ->return (a, f a)
16:28:01 <lambdabot> ap (,) f `fmap` m
16:28:09 <Cale> You have an if expression there, but it has no else branch.
16:28:13 <michaelcdever> ok, but i dont want to do anything in the else case
16:28:14 <michaelcdever> :D
16:28:18 <Cale> also ->
16:28:24 <koeien> michaelcdever: that is possible, but not in haskell :)
16:28:27 <michaelcdever> how can i get around that, is there a continue command?
16:28:27 <Cale> michaelcdever: return ()
16:28:30 <koeien> michaelcdever: return ()
16:28:38 <ski_> when
16:28:47 <Cale> return ()  does nothing and returns ()
16:28:49 <HairyDude> when is it
16:28:53 <HairyDude> :t when
16:28:54 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
16:28:59 <ddarius> @src when
16:28:59 <lambdabot> when p s = if p then s else return ()
16:29:09 <Cale> Or yeah, when, or unless will work.
16:29:12 <koeien> :t unless
16:29:13 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
16:29:19 <michaelcdever> still got the indentation error :(
16:29:56 <halberd> is there some application that uses Haskell as an application scripting language?
16:30:03 <ddarius> yi
16:30:05 <koeien> yi
16:30:13 <koeien> but don't know of any other example
16:30:19 <ddarius> Arguably xmonad sorta does
16:30:23 <halberd> ok thanks
16:30:26 <Cale> http://pastebin.com/m2eec71ff -- try that maybe?
16:30:28 <koeien> disagree
16:30:36 <koeien> but "sorta"
16:30:52 <HairyDude> cale: so here I have an obvious implementation for MonadRandom m => RandT g m, but I can only actually write one for RandT StdGen IO.
16:31:01 <ski_> maybe `\dir' was meant to be `\dir ->' ?
16:31:21 <Cale> HairyDude: That instance should already be there...
16:31:29 <Cale> HairyDude: If it's not, it's a bug in the package.
16:31:39 <Cale> er
16:31:40 <twanvl> Is RandT a class?
16:31:49 <Cale> twanvl: No, a type constructor
16:31:58 <Cale> But I see what you mean
16:32:14 <Cale> HairyDude: actually, what?
16:32:16 <HairyDude> no, I mean I'm writing a class, and I can see how to write an instance for RandT g m, but because RandT is abstract, I can't
16:32:18 <michaelcdever> thanks Cale, that helped!
16:32:18 <luite> twanvl: ah you're right... maxBound::CInt indicates that it's 32 bit (both in GHC and GHCi). I wonder why, my program is a 64 bit executable
16:32:20 <michaelcdever> :D
16:32:26 <michaelcdever> now more errors :D
16:32:27 <bohdan> is there a library for combinatorics?
16:32:32 <bohdan> e.g. inverse permutation
16:32:35 <Cale> HairyDude: It should just be  Monad m => MonadRandom (RandT g m)
16:33:06 <Cale> HairyDude: Why can't you?
16:33:30 <twanvl> luite: IIRC the people who wrote 64 bit C compilers figured that 64 bits were too large for regular old ints and longs
16:33:37 <Cale> HairyDude: Everything which is needed to manipulate values of type RandT is provided by that library, as far as I know
16:33:46 <Cale> HairyDude: What's the catch?
16:35:19 <michaelcdever> couldnt match expected type bool against inferred type IO Bool :S
16:35:38 <Cale> michaelcdever: an IO Bool is not a Bool, it's an action which when executed will produce a Bool
16:35:58 <michaelcdever> ah ok i get it  :D:D stupid
16:36:03 <bohdan> @unpl map snd . sort . (flip zip) [0..]
16:36:03 <lambdabot> (\ f -> map snd (sort (zip f [0 ..])))
16:36:12 <bohdan> @pl (\ f -> map snd (sort (zip f [0 ..])))
16:36:13 <lambdabot> map snd . sort . flip zip [0..]
16:36:16 <MyCatVerbs> Cale: I want to make crude jokes about hairy Bools now.
16:36:18 <Cale> if doesDirectoryExist dir -- this has to be wrong ;)
16:36:31 <Cale> You need to write something like
16:36:41 <Cale> b <- doesDirectoryExist dir
16:36:44 <Cale> if b
16:36:49 <pumpkin> we need a bool/if' function
16:36:50 <Cale>   then ...
16:36:57 <Cale>   else ...
16:36:58 <MyCatVerbs> theDamnThingExists <- directoryExists '/wherever/'; if theDamnThingExists then foo else bar
16:37:42 <luite> twanvl: hm, I see... bah I hate having to deal with all those implementation details :)
16:37:47 <athos> @hoogle if
16:37:48 <lambdabot> keyword if
16:37:48 <lambdabot> Distribution.ParseUtils IfBlock :: LineNo -> String -> [Field] -> [Field] -> Field
16:37:48 <lambdabot> package iff
16:40:55 <MyCatVerbs> pumpkin: why not? mif a t f = a >>= (\b -> if b then t else f). Use it like so: (getLine >>= return . (>5) . length) `mif` putStr "true" $ putStr "false" -- or don't, because that confuses me even though I just wrote it. =D
16:41:04 <pumpkin> lol
16:41:24 <pumpkin> that's fine
16:42:18 <MyCatVerbs> > let mif a t f = a >>= \b -> if b then t else f in (Just True) `mif` (Just "cheese") (Just "carrots")
16:42:19 <lambdabot>   Couldn't match expected type `t -> Maybe b'
16:42:33 <MyCatVerbs> > let mif a t f = a >>= \b -> if b then t else f in (Just True) `mif` (Just "cheese") $ (Just "carrots")
16:42:34 <lambdabot>   Just "cheese"
16:43:12 <jonaskoelker> @pl \(a, b) -> [a, b]
16:43:13 <lambdabot> uncurry ((. return) . (:))
16:43:30 <michaelcdever> grrr
16:43:41 <MyCatVerbs> See, I even got it wrong trying to repeat it. I henceforth declare the abuse of operator precedence to be verboten for all who do not wish to risk being considered naughty.
16:44:03 <jonaskoelker> @pl \a b -> [a, b]
16:44:03 <lambdabot> (. return) . (:)
16:44:11 <michaelcdever> the last statement in a do construct must be ab expression
16:45:50 <koeien> michaelcdever: yes, you cannot use binding "x <- f" as last statement in a do
16:46:07 <MyCatVerbs> michaelcdever: indeed it must. Perchance that you might hpaste the code? Almost certainly it is but a trifle to fix.
16:46:15 <koeien> it would be superfluous anyway
16:47:34 <athos> @unpl (. return).(:)
16:47:35 <lambdabot> (\ d g -> ((:)) d (return g))
16:48:00 <baaba> :t (.return).(:)
16:48:01 <lambdabot> forall a. a -> a -> [a]
16:48:35 <MyCatVerbs> koeien: mmm, I bet you could come up with an example of it doing something useful quite easily. A binding causes a pattern match to be attempted. Since fail "Pattern match failure on line..." is called in the event that that match fails, you could get something out of it with a sufficiently silly Monad instance. =)
16:48:36 <michaelcdever> http://pastebin.com/m750b4779
16:48:39 <bohdan> @pl \a -> filter (length a == k)
16:48:40 <lambdabot> filter . (k ==) . length
16:48:45 <athos> > (.return).(:) 'a'
16:48:46 <lambdabot>   Couldn't match expected type `m a -> c'
16:49:09 <athos> > (.return).(:) 'a' []
16:49:11 <lambdabot>   Couldn't match expected type `a -> m a1 -> c'
16:49:23 <MyCatVerbs> koeien: but then it'd be ambiguous as to what should be returned. Presumably the binding itself would make a pretty good candidate.
16:49:28 <athos> ah
16:49:45 <bohdan> > subsequences "ab"
16:49:46 <lambdabot>   Not in scope: `subsequences'
16:49:47 <MyCatVerbs> Except for the fact that that would add complexity to the language for no real gain. So whatever.
16:49:49 <koeien> MyCatVerbs: yes. you are right.
16:49:51 <baaba> @pl \(x, y) -> [x, y]
16:49:52 <bohdan> @hoohle subsequences
16:49:52 <lambdabot> uncurry ((. return) . (:))
16:49:53 <lambdabot> No results found
16:50:05 <athos> :t uncurry
16:50:07 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
16:50:07 <bohdan> how come ?? http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v%3Asubsequences
16:50:18 <athos> @hoogle subsequences
16:50:19 <lambdabot> No results found
16:50:25 <athos> :t subsequences
16:50:26 <lambdabot> Not in scope: `subsequences'
16:50:31 <pumpkin> lambdabot is on 6.8
16:50:38 <athos> 8]
16:50:39 <pumpkin> subsequences is n 6.10
16:50:49 <bohdan> :(
16:50:52 <pumpkin> nothing inherently 6.10 about it though, as far as I know
16:50:58 <pumpkin> just grab the source and write it in yourself :P
16:51:08 <pumpkin> , subsequences [1..5]
16:51:14 <lunabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[...
16:51:16 <pumpkin> , permutations [1..6.]
16:51:18 <bohdan> I was just writing a unittest for my implementation :)
16:51:19 <lunabot>  luna: parse error on input `]'
16:51:20 <pumpkin> , permutations [1..6]
16:51:22 <lunabot>  [[1,2,3,4,5,6],[2,1,3,4,5,6],[3,2,1,4,5,6],[2,3,1,4,5,6],[3,1,2,4,5,6],[1...
16:52:31 <bohdan> @pl (b c) == (b' c)
16:52:32 <lambdabot> b c == b' c
16:52:44 <bohdan> @pl (==) (b c) (b' c)
16:52:45 <lambdabot> b c == b' c
16:52:47 <michaelcdever> got it sorted :D
16:52:48 <jonaskoelker> @pl (\f x y -> [f x y])
16:52:48 <lambdabot> flip flip [] . ((flip . ((:) .)) .)
16:52:55 <michaelcdever> cant remember what i did though :|
16:52:57 <MyCatVerbs> koeien: but what a greasy edge case! I wonder if it'd be worth submitting a patch to GHC to reword the error message.
16:53:00 <jonaskoelker> @pl (\x y -> [x + y])
16:53:00 <lambdabot> flip flip [] . ((:) .) . (+)
16:53:10 <RayNbow> , sortWith Down [1..10]
16:53:12 <bohdan> \a -> (b a) == (b a)
16:53:12 <lunabot>  luna: Not in scope: `sortWith'
16:53:15 <RayNbow> aww
16:53:16 <bohdan> \a -> (b a) == (b' a)
16:53:18 <bohdan> @pl \a -> (b a) == (b' a)
16:53:18 <lambdabot> liftM2 (==) b b'
16:53:27 <pumpkin> I assume GHC's rewrite rules are smart enough to convert map f . map g . map h to map (f . g . h) (i.e., they don't just get applied "once"?)
16:53:44 <bohdan> @pl \a a' -> (b a a') == (b' a a')
16:53:45 <lambdabot> ap (ap . ((==) .) . b) b'
16:53:57 <Eelis> can lambdabot show the precedence and associativity of expressions like  x + x + x + x  ? for example, by showing the ee expression with added parentheses?
16:53:57 <EvilTerran> pumpkin, i believe that's not so much rewrite rules as inlining and fusion
16:54:03 <EvilTerran> but yes
16:54:05 <Eelis> -ee
16:54:26 <Saizan> > x + x + x + x
16:54:27 <pumpkin> EvilTerran: hmm, I thought map f . map g => map (f . g) was the typical example given for rewrite rules
16:54:28 <lambdabot>   x + x + x + x
16:55:23 <Saizan> fusion is defined via rewrite-rules isn't it?
16:55:58 <Saizan> s/defined/implemented/
16:58:08 * EvilTerran may be confused, never mind
16:58:20 <EvilTerran> rewrite rules are still kinda black magic to me :P
16:59:44 <pumpkin> erikc: omg new elf
17:00:04 <pumpkin> and UB and archive :o
17:00:25 <michaelcdever> lol, i forget already, how do i do a multi-line comment in haskell?
17:00:30 <pumpkin> {- -}
17:01:05 <michaelcdever> cheers, gonna give up for the night, slán leat
17:06:09 <roconnor> Ugh, ``here are no lazy monads. Monads imply explicit sequencing...''
17:06:15 <roconnor> such a bad thing to say
17:06:36 <roconnor> er
17:06:39 <roconnor> ``There ...
17:06:43 <roconnor> anyhow
17:06:57 <roconnor> no wonder people get confused about monads and strictness
17:07:23 <pumpkin> where?
17:07:25 <roconnor> with such people "helping" in the haskell cafe
17:07:41 <roconnor> Message-ID: <20090102013945.221bca1f@solaris>
17:14:47 <dons> ?users
17:14:48 <lambdabot> Maximum users seen in #haskell: 588, currently: 560 (95.2%), active: 15 (2.7%)
17:38:59 <roconnor> @instances MonadFix
17:39:00 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
17:39:17 <roconnor> @instances Monad
17:39:18 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
17:40:13 <bohdan> @pl \a -> [a]
17:40:14 <lambdabot> return
17:45:29 <BlackBird> wow - this chan exists
17:45:34 <BlackBird> anyone here do fortress ?
17:45:39 <mahogny> looked at it
17:45:41 <BlackBird> beats the living fuck out of haskell
17:45:48 <BlackBird> I'm on the creative team !
17:45:57 <BlackBird> Strong makes it all work
17:46:00 <roconnor> oh, does fortress have dependent types?
17:46:01 <BlackBird> paralle processing
17:46:07 <BlackBird> thank GOD we've made it
17:46:08 <mahogny> the fortress interpreter is buggy like hell. the standard library has almost nothing
17:46:14 <BlackBird> mahogny- heh
17:46:16 <BlackBird> no, - not at all
17:46:23 <BlackBird> it IS the way out
17:46:29 <mahogny> lol
17:46:30 <pumpkin> wow
17:46:39 <pumpkin> I didn't think people actually did language spam
17:46:40 <roconnor> no dependent types I take it
17:46:42 <pumpkin> I've heard of language trolling
17:46:45 <pumpkin> but language spam?
17:46:47 <pumpkin> that's kinda sad :P
17:46:53 <mahogny> and for... fortress?
17:46:59 <mahogny> not c++? where is the world heading?
17:47:09 <mahogny> functional? :o
17:47:39 <pumpkin> http://projectfortress.sun.com/Projects/Community apparently
17:48:00 <mahogny> those people are the reason you don't have a community :P
17:48:04 <pumpkin> definitely not functional
17:48:11 <pumpkin> or not purely functional, anyway
17:48:16 <pumpkin> I can definitely see a -=
17:48:18 <jonaskoelker> @pl \x -> (f x, x)
17:48:18 <lambdabot> (,) =<< f
17:48:23 <mahogny> not pure, but many things are taken from FP
17:48:29 <mahogny> it has a pure keyword
17:48:31 <mahogny> lambdas etc
17:48:33 <pumpkin> oh!
17:48:48 <mahogny> I'm totally in on fortress. when it's ready
17:49:15 <mahogny> it's the fortran killer so expect eager evaluation
17:49:29 <ddarius> At the rate they seem to be going, it'll be ready sometime in maybe late 2010s or 2020s.
17:49:35 <roconnor> the fortran killer?
17:49:43 <mahogny> apparently they have a compiler now
17:49:47 <pumpkin> they have a common prefix
17:49:48 <pumpkin> it must be
17:49:58 <roconnor> finally, recursive functions
17:50:59 <ddarius> If you want something in that vein and purely functional, you should look at Single Assignment C.
17:51:13 <ddarius> My understanding is that it is the successor of Sisal.
17:53:17 <mahogny> sounds interesting
17:53:38 <mahogny> fortress has a few goodies I don't expect in sisal though
17:56:35 <ddarius> SAC is designed for performance, parallelism and something reasonably high-level.  As the name suggests, it's not meant to have all kinds of crazy crap to make it look like math and probably a lot of the other stuff fortress has.
17:58:09 <Adamant> I thought SISAL was dataflow and not functional anyway.
18:00:38 <hasenov> could someone help me understand how I can break laziness using foldr calls and the concept of tail recursion?
18:01:02 <EvilTerran> "break laziness"?
18:01:04 <hasenov> i have a function that gets a "stack overflow" exception
18:01:18 <roconnor> laziness doesn't cause stack overflow
18:01:23 <roconnor> strictness does :)
18:01:38 <roconnor> well
18:01:39 <roconnor> sort of
18:01:42 <pumpkin> :P
18:01:48 <hasenov> so then i have strictness when I need to have laziness
18:01:51 <sbahra> I am overflow.
18:01:51 <Saizan> lazy accumulators do :)
18:01:53 <roconnor> where is the wiki page about stack overflows?
18:02:00 <EvilTerran> if the function passed to foldr is strict in its second parameter, that could lead to stack overflow on large lists, iirc
18:02:08 <Saizan> @wiki Stack Overflow
18:02:09 <lambdabot> http://www.haskell.org/haskellwiki/Stack_Overflow
18:02:22 <pumpkin> nice one
18:02:22 <pumpkin> ;)
18:02:31 <roconnor> Saizan: try again
18:02:32 <Saizan> http://www.haskell.org/haskellwiki/Stack_overflow
18:03:11 <EvilTerran> ?bot
18:03:11 <lambdabot> :)
18:03:18 <roconnor> hasenov: check out that page.  but the super short answer is to use foldl'
18:03:34 <roconnor> taking note of the ' in foldl'
18:03:59 <hasenov> ok ill check it out, thanx
18:04:20 <sbahra> I want to analyze weather.
18:06:04 <ddarius> sbahra: Open your window.
18:06:14 <sbahra> haha
18:07:07 <EvilTerran> > foldr (flip seq) 0 [1..1e7]
18:07:09 <lambdabot>   * Exception: stack overflow
18:07:20 <EvilTerran> > foldr seq 0 [1..1e7] -- strangely
18:07:24 <lambdabot>   0
18:09:40 <Olathe> @type seq
18:09:43 <lambdabot> forall a t. a -> t -> t
18:10:17 <ddarius> EvilTerran: seq is strict in it's second argument the way id is strict or (++) is when it's first argument is [].
18:10:40 <EvilTerran> ah, i think it's that the form of the first, "... `seq` 2) `seq` 1) `seq` 0" gets built in full before it can be reduced at all
18:11:03 <EvilTerran> er, finishing at 1, that should be :P
18:27:05 <hasenov> as far as i understand on the wikibooks, foldr allows for infinite recursion because it is evaluated as f a (f b (f c z)), so the second argument of f never needs to be evaluated, correct?
18:28:19 <hasenov> however foldl is evaluated as f (f (f z a) b) c so "f z a" will be evaluated first, then the result of that will be plugged into the second function and so on
18:29:18 <hasenov> is that what causes a stack overflow usually, because it tries to evaluate "f z a" right away?
18:29:59 <ddarius> About you're earlier two statements, you are correct.  The last one is not correct.
18:30:38 <ddarius> Well maybe it is depending on what you mean.
18:31:21 <Olathe> > showfold foldl
18:31:24 <lambdabot>   "fold (+) 0 [1..10] = ((((((((((0 + 1) + 2) + 3) + 4) + 5) + 6) + 7) + 8) +...
18:32:01 <ddarius> For foldl (versus foldl') you build the accumulator up into an expression like f (f (f z a) b) c and yes, if f is strict in it's first argument, then this will need to evaluate f z a first and thus descend into the expression using stack.
18:32:02 <Olathe> @src foldl
18:32:03 <lambdabot> foldl f z []     = z
18:32:03 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
18:32:27 <kpreid> hasenov: foldl z [a,...,c] = f ... c, but there is no c in an infinite list, so foldl z [...] = _|_
18:32:59 <kpreid> er, that explanation is broken several ways.
18:33:12 <kpreid> never mind!
18:33:29 <Olathe> > let infinite [] = False; infinite (_:xs) = infinite xs in infinite [1..5]
18:33:31 <lambdabot>   False
18:33:34 <Olathe> > let infinite [] = False; infinite (_:xs) = infinite xs in infinite [1..]
18:33:38 <pumpkin> lol
18:33:50 <lambdabot>   thread killed
18:35:51 <roconnor> False
18:36:23 <Botje> ^^
18:37:06 <Botje> >> infinite (iterate (stepTM program) emptyTM)
18:37:11 <hasenov> so what happens if f is lazy?
18:37:40 <hasenov> i seem to have a little trouble understanding the example @ http://en.wikibooks.org/wiki/Haskell/List_processing#folds_and_laziness
18:38:40 <Olathe> @type let echoes = foldr (\x xs -> (replicate x x) ++ xs) [] in echoes
18:38:43 <lambdabot> [Int] -> [Int]
18:38:45 <hasenov> oh actually never mind
18:38:49 <Olathe> @type let echoes = foldr (\x xs -> (replicate x x) ++ xs) [] in [1..5]
18:38:51 <lambdabot> forall t. (Enum t, Num t) => [t]
18:38:59 <Olathe> > let echoes = foldr (\x xs -> (replicate x x) ++ xs) [] in echoes [1..5]
18:39:02 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5]
18:40:17 <ddarius> > foldl (flip const) 0 [1..10]
18:40:20 <lambdabot>   10
18:40:22 <hasenov> f a is evaluated first which corresponds to "replicate x x"
18:40:54 <ddarius> > foldl (flip const) 0 [1..10000000]
18:41:03 <Olathe> > map (floor.sqrt) [1..25]
18:41:08 <lambdabot>   [1,1,1,2,2,2,2,2,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,5]
18:41:09 <lambdabot>   thread killed
18:41:13 <ddarius> > foldl (flip const) 0 [1..1000000]
18:41:29 <lambdabot>   thread killed
18:41:32 <ddarius> > foldl (flip const) 0 [1..100000]
18:41:36 <lambdabot>   100000
18:42:31 <hasenov> so i think "replicate x x" is calculated first and the "++ xs" part is delayed until later
18:42:34 <Olathe> > threads
18:42:36 <lambdabot>   [thread killed,thread killed,thread killed,thread killed,thread killed,thre...
18:43:38 <Olathe> > let echoes = foldl (\xs x -> xs ++ (replicate x x)) [] in echoes [1,1..]
18:43:53 <lambdabot>   thread killed
18:43:59 <Olathe> @src foldl
18:44:00 <lambdabot> foldl f z []     = z
18:44:00 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
18:44:19 <Olathe> @src foldr
18:44:20 <lambdabot> foldr f z []     = z
18:44:20 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
18:45:02 <bohdan> @pl \a f a `seq` a
18:45:03 <lambdabot> (line 1, column 8):
18:45:03 <lambdabot> unexpected "`"
18:45:03 <lambdabot> expecting pattern or "->"
18:45:10 <bohdan> @pl \a (f a) `seq` a
18:45:10 <lambdabot> (line 1, column 7):
18:45:10 <lambdabot> unexpected "a"
18:45:10 <lambdabot> expecting operator or ")"
18:45:12 <Olathe> Looks like foldl computes foldl and foldr computes f.
18:45:18 <bohdan> @pl \a -> (f a) `seq` a
18:45:18 <lambdabot> seq =<< f
18:45:44 <hasenov> so lets say "foldr (\1 [2..5] -> (replicate 1 1) ++ [2..5])" goes to "[1] ++ foldr (\2 [3..5] -> replicate 2 2) ++ [3..5])" and so on
18:48:09 <ddarius> No. xs isn't the input, it is the rest of the result.
18:48:25 <ddarius> Instead of trying to make some screwy notation, just unfold the definition.
18:49:58 <ddarius> foldr (\x xs -> replicate x x ++ xs) [] [1..5] -> replicate 1 1 ++ foldr (\x xs -> replicate x x ++ xs) [] [2..5] -> ...
18:50:40 <suspect43> hi, any pointers on how to use / implement a hash table in haskell?
18:50:42 <hasenov> ddarius: yeah ok, thats what i meant
18:50:52 <ddarius> suspect43: import Data.HashTable
18:51:20 <suspect43> ah
18:51:27 <suspect43> thank you
18:53:16 <ddarius> You likely don't need/want a hash table though, and Data.HashTable is pretty slow.  A Data.Map.Map is often a better and more convenient choice, IntMap is even better if you can get away with it.
18:54:26 <hasenov> foldl (\xs x -> xs ++ replicate x x) [1..5] [] -> foldl (\xs x -> xs ++ replicate x x) (\[] 1 -> [] ++ replicate 1 1) [2..5]
18:55:37 <suspect43> ddarius: what's the difference? Data.Map.Map is a b-tree?
18:58:03 <suspect43> btw what i need is a fast -- O(1) if possible -- primality check, for small numbers (<= 10^6) and in the imperative langs, i'd use a hashtable. any more appropriate structure?
18:58:43 <ddarius> An IntMap would probably be the best choice for Haskell.
18:59:10 <ddarius> The fastest choice (in any language) would simply be an array.
18:59:42 <defun> Hi. Is there a way to dynamically load haskell values (like lists and strings) and types stored in a _.hs source file into a haskell program? Do I need parsec to do this? The said program is supposed to take an argument from the command line and import all of the types and values in a haskell file of the same name (as the argument). Basically like loading custom modules but from within the program's source code.
18:59:44 <suspect43> why array?
19:00:08 <ddarius> suspect43: It's hard to beat a single memory read.
19:00:12 <defun> * but not from within a source file.
19:00:45 <suspect43> hmm. actually, something like a bit-array is probably more cache-friendly.
19:00:58 <suspect43> since all that's needed is yes/no
19:00:58 <ddarius> suspect43: UArray Bool is a bit array.
19:01:03 <suspect43> ahhh
19:01:07 <suspect43> great. thanks.
19:01:14 <ddarius> defun: There are libraries for dynamically loading Haskell modules.
19:01:31 <redditbot> 2009: The Year Of Hackage
19:01:38 <defun> I see. That's great. Thanks.
19:01:59 <ddarius> @hackage hint
19:01:59 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hint
19:04:51 <CakeProphet> > ;
19:04:53 <lambdabot>   <no location info>: parse error on input `;'
19:05:09 <CakeProphet> :t ;?
19:05:10 <lambdabot> parse error on input `;'
19:07:33 <Olathe> @src and
19:07:34 <lambdabot> and   =  foldr (&&) True
19:07:56 <Olathe> @src all
19:07:57 <lambdabot> all p =  and . map p
19:08:54 <Olathe> Hmmm...I think I've used all id before.
19:10:44 <Nafai> I got my copy of RWH last night
19:12:57 <bremner> I'm having trouble with utf8 output from hxt. I have hacked one of the example programs http://hpaste.org/13513
19:13:01 * ddarius needs to go and comprehensively reread "Basic Concepts of Enriched Category Theory"
19:14:26 <bremner> for example \8217 is output as ^Y
19:18:31 * bremner wonders why he is not using writeDocument
19:19:12 <athos> @hoogle writeDocument
19:19:12 <lambdabot> No results found
19:19:39 <bremner> athos: its an hxt thing. should that be in hoogle?
19:20:05 <athos> i don't know, i was just curious :)
19:20:12 <Nafai> It was cool showing my wife my name in the Acknowledgements of RWH :)
19:20:23 <Olathe> > show.typeOf $ "Hello"
19:20:24 <lambdabot>   "[Char]"
19:20:27 <athos> hehe Nafai
19:20:49 <Olathe> > show.typeOf.toDyn $ "Hello"
19:20:51 <lambdabot>   "Dynamic"
19:21:04 <chessguy> Nafai:  that happened to me, too. my wife bought it when i hadn't even told her anything about it. she just knew i like haskell, and searched and found a new book coming out and bought it, and, what do you know, my name was in it
19:22:23 <Olathe> > fix toDyn
19:22:24 <lambdabot>   <<Dynamic>>
19:22:28 <Olathe> Heh
19:22:44 <Olathe> > dynTypeRep (fix toDyn)
19:22:44 <suspect43> weird problem: f a b = [n^2 + a*n + b | n <- [0..]]
19:22:44 <suspect43> g a b = (0, b) : [(n + 1, t + 2*n + a + 1) | (n, t) <- g a b]
19:22:46 <lambdabot>   Dynamic
19:23:15 <suspect43> both generate a list of values of the polynomial n^2 + an + b
19:23:46 <suspect43> first is naive, the second reuses the previous term to get the next. i thought it would be faster, but it's WAYYYY slower
19:23:49 <suspect43> any idea why?
19:24:58 <Nafai> chessguy: Awesome! :)
19:25:21 <athos> suspect43: "reusing intermediate results to compute next result" sounds like you should use scanl
19:25:37 <athos> s/should/could
19:25:45 <athos> :t scanl
19:25:46 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
19:26:13 <suspect43> how would i do that?
19:26:32 <athos> > scanl (/) 64 [8, 2, 1, 4]
19:26:34 <lambdabot>   [64.0,8.0,4.0,4.0,1.0]
19:26:49 <Olathe> > let g a b = ([b, a + b + 1, 2*a + b + 4]...) in g 1 5
19:26:51 <lambdabot>   [5,7,11,17,25,35,47,61,77,95,115,137,161,187,215,245,277,311,347,385,425,46...
19:26:51 <athos> > scanl (/) a [b, c, d]
19:26:53 <lambdabot>   [a,a / b,a / b / c,a / b / c / d]
19:26:56 <chessguy> Nafai:  yeah, my wife rocks :)
19:28:08 <Saizan> suspect43: try "g a b = let r = (0, b) : [(n + 1, t + 2*n + a + 1) | (n, t) <- r] in r"
19:28:44 <suspect43> saizan: what's the difference between the old g and this?
19:29:05 <Olathe> r
19:29:06 <suspect43> olathe: how'd that happen?!
19:29:14 <Olathe> suspect43: Evilness.
19:29:15 <Olathe> @let (...) [x] = repeat x; (...) x@(x0:xs) = scanl (+) x0 ((zipWith (-) xs x)...) --by Newsham
19:29:16 <lambdabot>  <local>:16:0:
19:29:16 <lambdabot>      Multiple declarations of `L....'
19:29:16 <lambdabot>      Declared at: <local...
19:30:11 <suspect43> alright, this one's way faster. why's that?
19:30:22 <Saizan> suspect43: the difference is that with your code you were recomputing the same list multiple times
19:30:24 <bremner> ok, I figured it out: I needed to explicitly encode to utf8 before output
19:32:02 <roconnor> bremner: text ouput in haskell is broken
19:32:08 <roconnor> so don't feel bad
19:32:53 <suspect43> saizan: i don't get it. why would using a function call instead of "r" compute it multiple times?
19:35:00 <Saizan> suspect43: well, in a simpler example "foo x = (x+x,x+x)", foo 5 -> (5+5,5+5) -> (10,10) while instead with "bar x = let r = x + x in (r,r)", bar 5 -> let r = 5 + 5 in (r,r) -> let r = 10 in (r,r) -> (10,10)
19:35:36 <Saizan> so, in the former case you perform two additions, while in the latter only one
19:35:42 <suspect43> yes.
19:36:10 <Saizan> the same applies to g
19:36:37 <suspect43> alright, i'll try and grok that. can i make the evaluation strict at each step?
19:36:42 <suspect43> in g, that is
19:36:48 <CakeProphet> > frs
19:36:49 <lambdabot>   Not in scope: `frs'
19:36:58 <CakeProphet> what's the first tuple function?
19:37:12 <Saizan> > fst (1,2)
19:37:14 <lambdabot>   1
19:37:15 <CakeProphet> ah okay
19:37:23 <Saizan> suspect43: strict? why?
19:38:16 <ddarius> It would actually be beneficial to use a head-strict list and strict tuple type here.
19:38:20 <suspect43> so that only a single value carries over at each step, not the huge thunk comprising all the previous additions
19:38:38 <suspect43> ddarius: how would i do that?
19:39:04 <ddarius> However, the quickest change would be to simply write (!n, !t) <- r (enabling BangPatterns)
19:39:48 <Saizan> well, if you consume the values as you walk down the list there shouldn't be a problem, no?
19:39:56 <ddarius> However, if you consume the list sequentially it will be fine.
19:40:10 <BMeph> BBL, lovely Ween-doze drivers... ;p
19:40:15 <suspect43> ddarius: i take it the bang makes it strict, right? but how would use a head-strict list and strict tuple type?
19:42:23 <ddarius> data HeadStrictList a = Nil | Cons !a (HeadStrictList a); data StrictPair a b = StrictPair !a !b; g a b = let r = Cons (StrictPair 0 b) [StrictPair (n+1) (t + 2*n+a+1) | StrictPair n t <- r] in r
19:42:46 <suspect43> cool. thanks, guys.
19:42:52 <ddarius> Clearly, more concise names could be used and there should be a strict pair type already defined somewhere.  Maybe a head strict list type too.
19:43:48 <ddarius> Data.Strict.Tuple in the strict package
19:44:38 <suspect43> and is there any sample code / tutorial where i can see how to use Data.Map.Map?
19:44:40 <ddarius> dons: Where's my head strict lists in the strict package?
19:45:33 <ddarius> The documentation should suffice: http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html  It should be more or less self-explanatory though.
19:46:00 <hasenov> is there an article that discusses the difference between $ and $!?
19:46:20 <ddarius> hasenov: Possibly somewhere on the wiki.  There isn't much to discuss.
19:46:22 <ddarius> @src ($!)
19:46:22 <lambdabot> f $! x = x `seq` f x
19:46:36 <hasenov> @src ($)
19:46:37 <lambdabot> f $ x = f x
19:46:38 <Saizan> also, you can't use list comprehensions
19:47:07 <ddarius> Saizan: Ah, yeah.  That's the problem with using a different list type.  You have to recreate half the standard library.
19:47:10 <hasenov> @src seq
19:47:10 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
19:47:15 <ddarius> seq is a primitive
19:47:20 <roconnor> @quote
19:47:21 <lambdabot> br1 says: <br1> un banana me abrio la puerta en la cara y me rompio un pedal de la bici :(
19:47:39 <ddarius> I was thinking about rewriting it to use map though anyway so I could tie the knot with fix.
19:48:20 <dons> ddarius: yeah, i've thought about listts..
19:48:35 <dons> there's some programs where there's a performance benefit too
19:48:54 <dons> monomorphic, unboxed head strict would be ideal, if ghc could do that.
19:49:04 <ddarius> So change g to g a b = fix (Cons (StrictPair 0 b) . mapStrict (\(StrictPair n t) -> StrictPair (n+1) (t + 2*n + a + 1))); mapStrict f Nil = Nil; mapStrict f (Cons x xs) = Cons (f x) (mapStrict f xs)
19:49:19 <dons> rewriting Data.List is a pain though. though we've done it before. hmm
19:50:56 <dons> ?users
19:50:56 <lambdabot> Maximum users seen in #haskell: 588, currently: 541 (92.0%), active: 14 (2.6%)
19:50:56 <suspect43> mapStrict is in Data.Strict?
19:51:03 <dons> didn't quite make 600 in 2008.
19:51:12 <ddarius> suspect43: No, I just defined it there.
19:51:22 <athos> good night everyone
19:51:25 <dons> dcoutts_: this is interesting, http://www.alsonkemp.com/haskell/2009-the-year-of-hackage/
19:51:33 <dons> missing cabal-install and the platform...
19:51:34 <ddarius> Probably should of just made an instance of Functor
19:51:34 <dons> ?
19:51:39 <suspect43> right, right. :) sorry
19:51:50 <CakeProphet> > null []
19:51:52 <lambdabot>   True
19:53:06 <BMeph> It's funny, and kind of sad, but of all the adjectives to describe Haskell, I'd've never chosen "terse"... ;p
19:54:44 <suspect43> ddarius: it can't find fix
19:54:50 <ddarius> @hoogle fix
19:54:51 <lambdabot> Data.Function fix :: (a -> a) -> a
19:54:51 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
19:54:51 <lambdabot> module Control.Monad.Fix
19:55:39 <dons> BMeph: yeah, it seems to be an outsider thing. though it must be fairly _concise_ given how many one liners we throw around
19:56:11 <sbahra> Is Turbinado any good?
19:56:20 <sbahra> Seems nice
19:56:45 <sbahra> But no tutorial :)
19:57:03 <ddarius> People who think Haskell is terse have never seen J.
19:57:25 <ddarius> Cripes.
19:57:31 <BMeph> dons: Aye, I might've picked "succinct" maybe. :)
19:57:39 * ddarius will write a tutorial for his next project before he writes any code.
19:57:50 * BMeph cheers
19:58:14 <CakeProphet> @pl f x = add x x
19:58:15 <lambdabot> f = join add
19:58:20 <chessguy> @seen wchogg
19:58:20 <lambdabot> Last time I saw wchogg was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #ghc, #
19:58:20 <lambdabot> haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #
19:58:20 <lambdabot> haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosxdev, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 2d 7h 5m 14s ago, and .
19:58:34 <sbahra> ddarius, why?
19:58:36 <athos> :t join
19:58:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
19:58:55 <sbahra> ddarius, maybe 1 simple example would do, at the least. :-)
19:59:03 <dons> sbahra: i think turbinado is too new to have much users yet
19:59:07 <ddarius> sbahra: So people won't complain about not being able to use my pre-alpha code due to a lack of tutorial.
19:59:24 <dons> it's only a month or so old.
19:59:27 <roconnor> ddarius: it'll probably help the design too
19:59:44 <dons> i commented on the post about hackage / turbinado on reddit, http://www.reddit.com/r/haskell/
19:59:48 <roconnor> if you get the tutorial right, the code will naturally follow from it
19:59:49 <sbahra> dons, yes, I tasted the sarcasm :)
20:00:10 <dons> if others want to weigh in. i think we need to get the platform done, for example. that'll help a lot
20:00:33 <ddarius> roconnor: You just calculate the minimal automata that produces the tutorial output.
20:01:32 <chessguy> who's the main developer for turbinado?
20:01:32 <redditbot> New: parse OSX binaries in Haskell
20:01:37 <Nafai> dons: Dang it, I keep meaning to get around to looking at some of the cabal -> .deb automation that is out there and seeing about producing packages for everything in Hackage
20:02:31 <ddarius> dons: Hackage and Cabal, etc. are still rather young
20:02:48 <dons> works for xmonad dep solving, so i figure it can work for anyone.
20:03:15 <dons> but alson's not using cabal-install i guess?
20:03:20 <dons> and not leaning on distros for support
20:03:26 * sbahra is working on cabal2port for FreeBSD
20:03:28 <dons> so he kinda paints into a corner there.
20:03:36 <suspect43> ddarius: cool, working now. how would i time a function call?
20:03:48 <dons> sbahra: feel free to hack apart cabal2arch for your needs
20:03:51 <dons> its on hackage
20:04:00 <sbahra> dons, nod, first read :)
20:04:16 <dons> night all. happy applicatives
20:04:18 <sbahra> A good amount of the FreeBSD porting community showed interest in it, BTW.
20:04:21 <sbahra> 'night
20:04:38 <ddarius> @hackage microbench
20:04:38 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/microbench
20:09:50 <hasenov> is there a way to uncompile into source code a compiled through ghc program?
20:10:06 <Zao> hasenov: Not really.
20:10:14 <hasenov> i accidentally deleted my source file, lol, but I still have the compiled binary
20:10:32 <roconnor> hasenov: that sounds ... not good
20:11:21 <ddarius> Moral of the story: use revision control... -always-
20:11:29 <chessguy> @type do { a <- return 1; b <- return 10; return (a+b); }
20:11:30 <lambdabot> forall t (t1 :: * -> *). (Monad t1, Num t) => t1 t
20:11:36 <hasenov> its not really important, just a project euler solution that I already solved but would've been nice to have for reference
20:17:23 <erikc_> dons: that reddit is not quite correct, the universal binary package is just for the universal binary format (container format for macho's), the mach-o parser will follow shortly
20:17:32 <roconnor> ddarius: I told my advisor just do "ci -l filename" every once in a while
20:17:49 <roconnor> when something goes wrong, then look up how to use rcs
20:17:52 <suspect43> hasenov: what are you using for primality, totient, etc?
20:20:45 <idesperado> hi,there..I'm using ubuntu.and now I wanna install haskell packages..and there seems so many dependencies there for xmobar...some guys said cabal-install is easier way...but I'm struggling installing it...and again it depends many...is there an easier way for me????????
20:22:58 <ddarius> There should only be two dependencies, HTTP and zlib, that you should need to install by hand to install cabal-install.
20:23:28 <suspect43> there's also Cabal and network. i'm installing right now
20:23:49 <idesperado> well...HTTP and zlib...may also depend others...
20:23:51 <ddarius> Those should be distributed with GHC.
20:24:02 <ddarius> idesperado: They don't, or not on any that aren't distributed with GHC.
20:24:28 <ddarius> I don't know if Ubuntu did this, but some distros split up GHC and you may need to install some other distro packages.
20:24:30 <suspect43> weren't with the one i have. i apt-get'ed ghc from the standard rep
20:24:45 * ddarius uses Ubuntu but has never installed GHC from it.
20:25:05 <suspect43> you installed from source?
20:25:23 <idesperado> suspect43: I also apt-get installed ghc...
20:25:28 <ddarius> I have 6.10 installed and I used the tar.bz
20:25:31 <idesperado> but the version is lower
20:25:35 <idesperado> not 6.10
20:26:24 <suspect43> ddarius: he's right, the version in the repo is 6.8.2 . is it worth the upgrade to 6.10?
20:27:09 <ddarius> suspect43: If you need the stuff in 6.10 yes, otherwise just wait.
20:28:17 <suspect43> :) newbie here. i'll wait, i think
20:28:48 <mm_freak> where f is a function, is there any difference between seq f and id?
20:29:17 <idesperado> so..if I wanna install xmobar I first have to install cabal or cabal-install or cabal-network and second I have to install HTTP and ZLIB to install the cabal thing???
20:29:50 * benl23
20:29:58 <suspect43> idesperado: http://www.haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package
20:30:51 <suspect43> idesperado: install HTTP, zlib, Cabal, and network. Follow the "Installing packages" instructions. Then, install "cabal-install"
20:33:01 <CakeProphet> is there a way to change just one value of a list and return the whole list?
20:33:09 <CakeProphet> I've made my own function but it's kind of ugly.
20:34:05 <mbz> such lists are called arrays
20:34:10 <mbz> :)
20:34:20 <CakeProphet> oh?
20:35:37 <idesperado> suspect43: I've already read that...
20:39:04 <byorgey> CakeProphet: it's a bit ugly since lists are singly-linked lists.
20:39:32 <byorgey> CakeProphet: but I'd say there's a better than even chance that's not really what you want to do. =)
20:39:44 <byorgey> why are you trying to update a single element of a list?
20:40:32 <CakeProphet> byorgey: update a list (or array) at just one index?
20:40:50 <byorgey> CakeProphet: right, why do you want to do that?  what's your use case?
20:40:51 <CakeProphet> or just lists instead of arrays?
20:41:01 <CakeProphet> byorgey:  Easy. I'm making a brainfuck interpreter.
20:41:10 <byorgey> aha!
20:41:24 <byorgey> well, in that case, you probably really do want to use a mutable array instead.
20:41:29 <rwbarton> Or a zipper
20:41:30 <CakeProphet> rofl. yeah.
20:41:36 <CakeProphet> a... zipper?
20:41:45 <rwbarton> @where zipper
20:41:45 <lambdabot> I know nothing about zipper.
20:41:46 <byorgey> oh, yeah, a list zipper would work nicely too.
20:41:59 <mbz> @google zippers in haskell
20:42:02 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Zippers
20:42:07 <byorgey> actually, come to think of it, that's what I used when *I* wrote a brainfuck interpreter =)
20:42:27 <mbz> byorgey, zippers?
20:42:38 <mbz> or just arrays?
20:42:44 <byorgey> a list zipper
20:42:51 <ddarius> mm_freak: If by "f is a function" you mean f :: A -> B for some A and B then yes, there is a difference.
20:43:15 <quylui> i installed haskell-mode-font-lock and now i can't see my double-colons. >.<
20:43:19 <byorgey> CakeProphet: in general, a zipper is a data structure with a 'focused' element, that allows you to easily modify the focused element, or move to 'adjacent' elements
20:43:30 <CakeProphet> ...oh
20:43:33 <CakeProphet> that's... exactly what I need
20:43:38 <mm_freak> ddarius: what is the difference?
20:43:42 <byorgey> CakeProphet: in the case of a list, the corresponding list zipper just consists of a single element and two lists (the elements before the focused element, and the elements after)
20:43:54 <CakeProphet> oh, beautiful
20:44:02 <byorgey> CakeProphet: it's pretty easy to code yourself, actually
20:44:07 <CakeProphet> hmmm... I could easily make that myself, actually.
20:44:09 <CakeProphet> yeah
20:44:15 <byorgey> CakeProphet: just make a data type like   ListZipper a = ListZipper a [a] [a]
20:44:21 <ddarius> Actually, it doesn't matter if f is a function or not, no matter what type f is it can be undefined.
20:44:22 <CakeProphet> is there an existing library thing for it?
20:44:30 <byorgey> CakeProphet: but I think there is also a list zipper module on hackage, as well
20:44:34 <ddarius> @hoogle Data.Zipper
20:44:34 <lambdabot> package rosezipper
20:44:41 <CakeProphet> eh. I'll just make my own. Less dependencies.
20:44:59 <byorgey> sure, it will probably be a good learning experience anyway
20:45:31 <CakeProphet> what does newtype do again?
20:45:52 <CakeProphet> I plan on making a Zipper a
20:45:54 <byorgey> CakeProphet: makes a type which is isomorphic to another type, by just adding a constructor
20:46:14 <CakeProphet> and then having Bfstate... which is the equivalent of Zipper Char
20:46:51 <byorgey> CakeProphet: you probably just want to use a type alias for that, instead of a newtype
20:47:01 <CakeProphet> so just
20:47:07 <CakeProphet> Bfstate = Zipper Char?
20:47:16 <byorgey> type Bfstate = Zipper Char
20:47:18 <CakeProphet> er
20:47:20 <CakeProphet> ah
20:47:26 <CakeProphet> yeah, mine wouldn't work
20:47:28 <CakeProphet> because they're types.
20:47:33 <byorgey> if you use a newtype you have to deal with taking the constructor off and on all the time
20:48:18 <byorgey> sometimes that's what you want, but if you're just making a convenient new name for something, you want a type alias.
20:48:33 <byorgey> CakeProphet: right.
20:56:15 <sjanssen> wow, huge Haskell v. Python thread on reddit
20:56:25 <CakeProphet> ...why?
20:56:51 <sjanssen> premise: Why is Haskell so popular on reddit? What does it offer, for instance, that Python doesn't?
20:57:07 <sjanssen> yields a fair amount of good discussion
20:57:45 <pumpkin> sjanssen: some of the comments pissed me off on there, but I guess that's to be expected
20:57:48 <pumpkin> on the whole it's interesting
20:58:09 <sjanssen> pumpkin: yeah, there are wtfs here and there
20:58:24 <sjanssen> eg. some Ruby guy whining about the syntax, but not being able to describe what is wrong
20:58:44 <pumpkin> lol yeah
20:59:06 <pumpkin> like, "ZOMG U HAZ NO SYMBOL FOR FUNCTION APPLICATION OTHER THAN SPACE"
20:59:44 <sjanssen> bah, $
21:00:04 <pumpkin> or "OMG LOOK AT f . g . h $ x, ITZ BACKWARDS" ... "but f(g(h(x))) in your language..." ... "OH"
21:00:14 <pumpkin> sorry :)
21:00:19 <CakeProphet> so like
21:00:31 <ik> DAYCHANGE!
21:00:40 <pumpkin> the best one was the pointfree complaint
21:00:51 <CakeProphet> how do you make a datatype an instance of a typeclass without overriding any definitions.
21:00:59 <sjanssen> ik: is that automated?  It is a little bit annoying
21:01:07 <ik> sjanssen: no
21:01:32 <redditbot> New release of wxHaskell!
21:01:44 <sjanssen> ik: okay :)
21:02:58 <pumpkin> ik: you should do it every time any timezone changes day
21:03:08 <ik> nah
21:03:25 <ik> daychange in local timezone only
21:04:28 <pumpkin> boo, but there are so many fun time zones
21:04:55 <sjanssen> really?
21:07:09 <alexsuraci> Is (x, y) called a double, since (x, y, z) is a triple?
21:07:20 <pumpkin> alexsuraci: a pair, I usually call it
21:07:25 <alexsuraci> Ah, that's the one.
21:07:44 <ik> pumpkin: I should meet someone in "Central western time" who daychanges ^_^
21:07:45 <alexsuraci> For some reasons I was hesitant to call them tuples since that sounds like "two".
21:07:49 <alexsuraci> *reason
21:08:01 <pumpkin> people call them 2-tuples sometimes
21:08:03 <alexsuraci> "tuple" is the general term then, right?
21:08:55 <CakeProphet> yes.
21:09:04 <CakeProphet> 2-tuple, 3-tuple... n-tuple
21:09:33 <CakeProphet> 2-tuple is sometimes called a "pair" and 3-tuple is sometimes called a "triple" (but not as commonly)
21:15:06 <CakeProphet> > apply
21:16:39 <pumpkin> > reject
21:17:05 <pumpkin> @botsnack
21:17:22 <lucca> o/~ enjoy the silence
21:17:32 <pumpkin> wow, both bots broken?
21:17:39 <pumpkin> , "ohai"
21:18:17 <pumpkin> or is this just a weird freenode issue?
21:21:25 <pumpkin> aha
21:21:47 <mbz> ouch
21:21:56 <pumpkin> pretty epic netsplit
21:24:27 --- mode: irc.freenode.net set +o ChanServ
21:29:25 <lucca> > 0
21:30:52 --- mode: irc.freenode.net set +o ChanServ
21:31:00 <svref> How do I find the source code in ghc's rusty innards on the local filesystem?
21:31:13 <svref> @src foldr
21:31:13 <lambdabot> foldr f z []     = z
21:31:13 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:32:58 <pumpkin> @botsnack
21:32:59 <lambdabot> :)
21:33:17 <lunabot>  :)
21:42:46 <pumpkin> quiet in here
21:44:20 * mbz roars
21:45:13 <int-e> loud in here (does reverse psychology work?)
21:45:36 <pumpkin> lol
21:46:19 <Heffalump> NO IT'S NOT!
21:46:56 <pumpkin> omg a heffalump
21:47:06 <Riastradh> A heffable horralump!
21:47:32 <pumpkin> wow, http://upload.wikimedia.org/wikipedia/en/7/7c/Heffalump_movie_book.jpg
21:50:22 <CakeProphet> is $ tighter than ==?
21:50:29 <Heffalump> no
21:50:39 <CakeProphet> alright.
21:50:55 <Heffalump> it's looser than (or at worst equally loose as) any other operator
21:56:06 <svref> @src foldl
21:56:06 <lambdabot> foldl f z []     = z
21:56:06 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:56:58 <svref> @src foldl
21:56:59 <lambdabot> foldl f z []     = z
21:56:59 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:59:27 <CakeProphet> > toEnum 1 ::Bool
21:59:29 <lambdabot>   True
22:09:37 <CakeProphet> what's a good Parsec tutorial?
22:11:39 <mm_freak> ddarius: if f is a function and not ⊥, is there still a difference between seq f and id?
22:12:31 <mm_freak> CakeProphet: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
22:13:26 <CakeProphet> I don't think where bindings bind to all patterns. :(
22:26:18 <ddarius> mm_freak: If the weak head normal form is \x -> ..., then no, there is no difference
22:28:51 <CakeProphet> I can't get where to bind to multiple patterns. :(
22:29:04 <Twey> With @, you mean?
22:29:30 <CakeProphet> ?
22:29:54 <Twey> Oh, I see
22:30:09 <Twey> Yes, you can't really do that, because where has access to the arguments, and the arguments won't necessarily be the same
22:30:12 <Twey> It doesn't make sense
22:30:33 <Twey> Instead, consider having a top-level function with a where clause containing the other patterns
22:30:44 <Twey> Or, alternatively, using pattern guards.
22:30:54 <Twey> Er, or just guards.
22:31:10 <CakeProphet> can you pattern match with guards?
22:31:21 <Twey> No
22:31:23 <Twey> Well
22:31:26 <Twey> You can with pattern guards
22:31:33 <Twey> I'm not sure if they're in GHC yet
22:34:07 <CakeProphet> can you nest guards?
22:34:37 <Twey> Guards are used where a function is defined; you can't define a function within a guard, so, obviously, no
22:34:39 <ddarius> Twey: Pattern guards have been in GHC for several years.
22:34:39 <mm_freak> c >>= \x -> case x of …
22:34:39 <CakeProphet> like... have a condition on which multiple other conditions will be tested?
22:34:54 <mm_freak> or:  do x <- c; case x of …
22:34:58 <Twey> However, you can use guards on a function defined in a where
22:40:22 <Twey> Oh, beg pardon, ddarius
22:40:36 <Twey> I suspected they might be, but I wasn't sure :)
22:41:59 <enticingjelly> there should be a mechanism in haskell to make your own classes derivable
22:42:06 <enticingjelly> right now it's "magic"
22:42:16 <sbahra> ye
22:42:33 <CakeProphet> mm_freak:  can you put guards inside a case?
22:43:17 <rwbarton> CakeProphet: Yes
22:43:25 <CakeProphet> ...excellent
22:44:44 <CakeProphet> pattern -> |condition = func | condition = func  ?
22:44:46 <CakeProphet> or
22:44:49 <ddarius> enticingjelly: There is though they may have finally removed it.
22:44:55 <CakeProphet> pattern |condition -> func | condition -> func
22:45:05 <enticingjelly> ddarius, ah, interesting. why?
22:46:34 <CakeProphet> > let f x = case x of '>' | otherwise = "lol" in f '>'
22:46:36 <lambdabot>   <no location info>: parse error on input `='
22:46:44 <CakeProphet> > let f x = case x of '>' -> | otherwise = "lol" in f '>'
22:46:46 <lambdabot>   <no location info>: parse error on input `|'
22:46:52 <CakeProphet> > let f x = case x of '>' | otherwise -> "lol" in f '>'
22:46:55 <lambdabot>   "lol"
22:46:58 <CakeProphet> alrighty.
22:50:00 <ddarius> enticingjelly: Well they didn't quite do that, rather they added this unused feature: http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-classes.html
22:56:17 <CakeProphet>     Occurs check: cannot construct the infinite type: t = [t]
22:56:19 <CakeProphet>     When generalising the type(s) for `shiftRight'
22:56:45 <CakeProphet> shiftRight :: Tape t -> Tape t	 ....where   data Tape t  = Tape {current::t, left::[t], right::[t]} deriving (Eq, Show)
22:56:53 <CakeProphet> any idea why I get that?
22:59:13 <ddarius> You're doing something wrong in shiftRight.
23:01:51 <drbean_> :t const
23:01:53 <lambdabot> forall a b. a -> b -> a
23:02:01 <drbean_> const 9, 'x'
23:02:14 <drbean_> > const 9, 'x'
23:02:15 <lambdabot>   <no location info>: parse error on input `,'
23:02:22 <ddarius> This isn't Visual Basic
23:13:19 <CakeProphet> ddarius:  ?
23:13:24 <CakeProphet> oh
23:13:28 <CakeProphet> commas
23:14:15 <CakeProphet> drbean_:  seperate arguments with a space. Or, if you want a tuple, put the whole thing in parens.
23:14:47 <CakeProphet> > const 9 'x'
23:14:49 <lambdabot>   9
23:14:55 <CakeProphet> > (const 9, 'x')
23:14:57 <lambdabot>       Overlapping instances for Show (b -> t)
23:14:57 <lambdabot>        arising from a use of `s...
23:15:20 <CakeProphet> (well... lambdabot can't print a function
23:15:22 <CakeProphet> )
23:17:39 <chrisdone> this is visual basic
23:17:45 <chrisdone> visual basic?
23:18:20 <arw> what?
23:18:34 <CakeProphet> chrisdone:  turns out microsoft made GHC.
23:18:45 <chrisdone> > map toUpper $ "this is spart" ++ repeat 'a'
23:18:48 <lambdabot>   "THIS IS SPARTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...
23:18:59 <chrisdone> the cake is a liar
23:23:49 <CakeProphet> > succ 'a'
23:23:51 <lambdabot>   'b'
23:23:57 <CakeProphet> excellent
23:24:35 <rwbarton> > succ '\1114111'
23:24:37 <lambdabot>   * Exception: Prelude.Enum.Char.succ: bad argument
23:25:18 <elbar> > succ False
23:25:20 <lambdabot>   True
23:25:27 <elbar> > succ True
23:25:29 <lambdabot>   * Exception: Prelude.Enum.Bool.succ: bad argument
23:26:36 <Asztal> chrisdone: http://hpaste.org/13515 <- sneaky! :)
23:29:20 <CakeProphet> ddarius, here's shiftRight - http://hpaste.org/13516
23:30:09 <int-e> CakeProphet: that doesn't typecheck.
23:30:30 <CakeProphet> int-e:  ?
23:30:38 <int-e> CakeProphet: besides, wouldn't it better to reverse the 'left' list? then shiftRight (Tape mid left (r:rs))  = Tape r (mid : left) rs
23:30:56 <int-e> CakeProphet: mid is not a list, so left ++ mid  won't work
23:31:39 <CakeProphet> ah.
23:32:36 <CakeProphet> yeah, I'll reverse it
23:33:13 <mmorrow> preflex: seen rwbarton
23:33:13 <preflex>  rwbarton was last seen on #haskell 8 minutes and 38 seconds ago, saying: > succ '\1114111'
23:33:38 <mmorrow> rwbarton: hey, i'm looking at you brainfuck->.o compiler
23:34:05 <mmorrow> where did you get your info on how to properly construct the ELF .o?
23:34:51 <mmorrow> also, cool use of mdo in writeObj ;)
23:37:27 <mmorrow> cool, it looks simple enough i guess. one of each: stringtab, symtab, progbits ...
23:37:28 <mmorrow> hmm
23:39:15 * mmorrow wants to figure out howtf to take a parsed-into-a-datatype ELF file and load it into mem correctly (all in haskell and manually)
23:41:37 <mmorrow> the elf docs aren't very direct about this, but maybe they'll look like it after i understand how :P
23:42:13 <mmorrow> quiet in here, huh
23:45:30 <cizra> mmorrow: Suggest finding out what is /lib/ld-linux.so.2, it's the thing loading elves in Linux.
23:45:51 <cizra> mmorrow: Perhaps its code has insights.
23:47:24 <mbz> mmorrow, you could also check mod. loading code in the linux kernel
23:47:25 <mmorrow> cizra: good idea. i've looked a little at the glibc src but it's kinda messy (there are test files everywhere mixed in with the actual implem file, etc).
23:47:41 <mmorrow> mbz: cool, will do.
23:48:09 <mmorrow> i also need to take a line-by-line look at ghc's Linker.c
23:48:30 * mmorrow is not looking forward to this ;)
23:49:08 <cizra> mmorrow: Is there an OS that doesn't suck?
23:49:22 <cizra> *BSD, they say, perhaps also Solaris…
23:49:26 <mmorrow> cizra: hah, good point.
23:49:57 <jql> don't worry; solaris sucks
23:50:39 <jql> solaris with the gnu userland is almost usable... but it still tends toward suckiness
23:51:19 <mmorrow> heh
23:51:46 * cizra wonders what Haiku is like. They sure have the opportunity to start from a clean slate.
23:53:59 <cizra> jql: You surely must mean Solaris sucks usage-wise? How about code cleanliness?
23:55:12 <jql> no serious complaints about the technology. although, by that metric, the NT kernel is decent as well
23:55:48 * jql mumbles something about only seeing the source on a tuesday in venezuela with his fingers crossed
23:56:41 <arw> solaris kernel code is very readable, at least the parts i've looked at. but so are certain parts of linux.
23:57:01 <cizra> I guess you can find good and bad examples everywhere.
23:57:16 <flippo> "solaris sucks" was a slogan when it first replaced SunOS back in the mid 90's, switching to SystemV.  It had some issues.
23:57:17 <cizra> However, isn't OpenBSD advertising its code beauty?
23:57:35 <arw> hm. i think "the source looks good" is the worst metric you can find.
23:59:08 <arw> i think good documentation is more important, and most of all, it should be bug-free :)
23:59:27 <cizra> OK, well, we're talking about C, anyway.
23:59:37 <cizra> (except for Haiku which is C++, which is worse yet thousandfold)
23:59:58 <Adamant> arw: how do you think you're going to get good docs?
