00:00:55 <vixey> data Huff a = Leaf a | Branch (Huff a) (Huff a) deriving Show
00:00:59 <vixey> foldHuff leaf branch = φ
00:01:00 <vixey>  where φ (Leaf o) = leaf o
00:01:00 <vixey>        φ (Branch left right) = branch (φ left) (φ right)
00:01:03 <vixey> depthFirstTraversal = foldHuff return (++)
00:01:12 <vixey> peachi did that come through ok?
00:01:29 <Raevel> what is that symbol??
00:01:36 <peachi> there's a weird symbol
00:01:40 <vixey> it's just a greek squigle
00:01:50 <Raevel> oh, phi, my client cut it in half :-P
00:01:51 <peachi> ok then, yes
00:02:04 <inimino> it's a lowercase phi
00:02:33 <koeien> vixey: which editor do you use normally?
00:02:43 <Raevel> http://ecmascript.se/etc/phi.png <-- looks pretty cool though
00:03:17 <inimino> ah, I see
00:03:27 <inimino> it's too wide for the character cell
00:03:37 <inimino> what font is that?
00:03:42 <Raevel> monaco
00:03:50 <peachi> is "return" to do with monads?
00:03:54 <inimino> ok
00:04:00 <koeien> peachi: this is the list monad.
00:04:03 <vixey> peachi, no
00:04:07 <vixey> peachi, return 3 = [3]
00:04:08 <peachi> oh, because we haven't done those yet heh
00:04:15 <koeien> peachi: just use (:[])
00:04:21 <vixey> just use return.
00:04:22 <peachi> cool
00:06:39 <peachi> so with DFS you start at a root and then go down as far as possible along each branch before coming back, is that right?
00:06:46 <Raevel> yes
00:06:55 <koeien> yes
00:07:19 <Raevel> look how similar our nicks are
00:07:44 <peachi> wikipedia have this pseudocode: http://hpaste.org/13936
00:08:16 <peachi> does this just use stack unravelling to backtrack?
00:08:32 <peachi> and what does preorder-process and postorder-process mean?
00:08:59 <Raevel> those are probably helper functions to do stuff with the graph at each step
00:09:04 <koeien> peachi: nothing, they're functions that, if called there, are called in some order
00:09:28 <peachi> ah ok
00:09:29 <vixey> peachi, wiki tells you how to implement it in BASIC or ALGOL
00:09:37 <vixey> peachi, you do it differently in haskell (usually)
00:09:37 <koeien> e.g. if you want to print all vertices in pre-order, you would put a 'print' statement in the pre-order function
00:10:02 <peachi> ah ok, so it's kind of just for displaying the progress of the search
00:10:20 <koeien> for example. normally you do more useful stuff there
00:11:46 <peachi> may I ask what "all vertices i adjacent to v" means?
00:12:02 <peachi> that it mean all the vertices i such that there exists an edge from v to i?
00:12:05 <peachi> or something different?
00:12:10 <koeien> all vertices i such that there is an edge (v,i)
00:12:18 <peachi> heh ok thanks
00:12:33 <peachi> so really DFS is quite simple?
00:12:45 <koeien> yes. it's even simple in haskell (see vixey's code)
00:12:48 <vixey> peachi, did you miss my paste earlier? I showed you DFS
00:13:16 <peachi> i saw it but don't really understand it :/
00:14:15 <vixey> any particular parts..?
00:14:30 <koeien> ok. i take it you understand the data definition
00:14:40 <peachi> yep, understand that
00:15:00 <peachi> then foldHuff is a function that takes two binary functions as arguments?
00:15:13 <vixey> well what is it's type?
00:15:15 <koeien> note that the function foldHuff gets three arguments, the first two are functions describing what to do in case of a leaf or branch
00:15:20 <vixey> its*
00:15:50 <peachi> and the third is?
00:17:14 <koeien> http://hpaste.org/13937
00:21:00 <boegel> hiya all
00:21:01 <boegel> I'm reading stuff from a file, which contains lines like "1,2,foo"
00:21:09 <boegel> and I'm trying to extract the first two numbers on the line, without caring about the foo part
00:21:17 <boegel> I'm trying to do this by using something like let (x,y,_) = read line :: (Int,Int,String)
00:21:23 <boegel> but I'm getting a "no parse" exception because the foo part can't be parsed as a string
00:21:30 <boegel> that would require the line to be something like "(1,2,\"foo\")"
00:21:37 <boegel> does anyone have any suggestions on how I might tackle this best?
00:23:33 <dons> boegel: maybe use the bytestring-csv lib to parse it?
00:24:03 <mathijs> how can I refer to the negate-operator (the unary one)?  say I want let neg = (-)
00:24:12 <dons> ?src subtract
00:24:12 <lambdabot> subtract x y = y - x
00:24:17 <dons> oh
00:24:19 <dons> ?src negate
00:24:19 <lambdabot> negate x = 0 - x
00:24:42 <dons> yeah. warts.
00:24:43 <mathijs> dons: thanks... as usual, stuff is just too logical :)
00:24:57 <dons> we're so embarassed by unary (-). i apologise.
00:25:07 <dons> n+k is beautiful in comparison :)
00:25:09 <koeien> or, (0-)
00:25:22 <dons> someone should write a 'Why n+k rocks' blog for all the new people
00:25:51 <koeien> is there a good reason why it is evil? i don't use it myself, but i remember that it was used in the intro FP course i did
00:26:02 <dons> unary negation?
00:26:07 <koeien> no, n+k patterns
00:26:16 <dons> oh, they're rather ad hoc, and restricted.
00:26:30 <dons> there's no real (+) constructor for non-negative numbers, yet that's kinda how it works.
00:26:34 <boegel> dons: well, I considered using bytestring, but it seems like overkill to me...
00:26:37 <blackh1> koeien: A good reason not to use them is that they've been voted out of the next revision of the language.
00:26:37 <dons> so too magic, too special case.
00:26:38 <koeien> they wanted to stress the induction on the integers. we only used (+1)
00:26:49 <dons> boegel: oh, just that there's a library already for parsing csv files :)
00:26:54 <dons> actually, there's one for strings too
00:26:57 <dons> the 'csv' lib
00:27:17 <dons> boegel: i guess you just want to add quotes to the string to read it, right?
00:27:21 <dons> or is it already a string?
00:27:50 <boegel> dons: well, it's a string in date format, something like 2008-12-09 or so
00:27:57 <boegel> dons: but I don't need that part (for now)
00:28:16 <dons> oh, maybe use the parsedate lib for  that.
00:28:27 <boegel> dons: even if I don't need it? :)
00:28:29 <dons> split on , map read over the first two parts, drop the second.
00:28:30 <koeien> boegel: you can always drop the last part by using some function to find the second ','.
00:28:33 <boegel> dons: I just want to ignore that part
00:28:58 <vixey> n+k is just a view pattern
00:29:03 <boegel> koeien: I could, yes, but it seems to me there should be a more efficient way just to ignore stuff
00:29:22 <boegel> koeien: dropping stuff from a list (of characters) is expensive, it seems...
00:29:28 <dons> vixey: yeah :)
00:29:30 <koeien> boegel: premature optimization is the root of all evil. i think you won't notice
00:29:33 <boegel> koeien: or, well, it doesn't have to be
00:29:40 <boegel> koeien: hmm, thanks
00:29:55 <koeien> 'read' also works character by character
00:30:03 <boegel> koeien: you've made me look at it from a different angle, which is what I was looking for :)
00:30:20 <mmorrow> , readP_to_S (do char '('; m <- munch1 isDigit; char ','; n <- munch1 isDigit; return (read m::Int, read n::Int)) "(42,9292837,!@#$%^&"
00:30:22 <lunabot>  [((42,9292837),",!@#$%^&")]
00:30:24 <boegel> koeien: yes, but it tries to read the entire string you give it
00:30:30 <koeien> no
00:30:32 <koeien> it won't :)
00:30:41 <boegel> koeien: oh
00:30:43 <boegel> hm
00:30:57 <koeien> > takeWhile (<37) [1..]
00:30:59 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
00:31:04 <koeien> hmm, bad example
00:31:06 <boegel> :)
00:31:07 <koeien> > takeWhile (<5) [1..]
00:31:09 <lambdabot>   [1,2,3,4]
00:31:24 <boegel> > take 4 [1..]
00:31:26 <boegel> :P
00:31:26 <lambdabot>   [1,2,3,4]
00:31:35 <boegel> > [1..4]
00:31:36 <boegel> !
00:31:36 <lambdabot>   [1,2,3,4]
00:31:42 <joma> takeWhile (\x -> x /= "Lisp") ["haskell", "haskell", "Lisp", "haskell"]
00:31:42 <koeien> yes, the same of course. but you see that it doesn't inspect the whole list
00:31:57 <vixey> , let (n + k) = n - k in   let f ((+3) -> e) = e in  f 32
00:31:59 <lunabot>  luna: Parse error in pattern
00:32:03 <joma> ?
00:32:11 <joma> takeWhile (\x -> x /= "Lisp") ["haskell", "haskell", "Lisp", "haskell"]
00:32:12 <vixey> , let n + k = n - k in   let f ((+3) -> e) = e in  f 32
00:32:13 <koeien> joma: use '>' to ask lambdabot
00:32:14 <lunabot>  29
00:32:27 <boegel> koeien: ok, you've rewired my brain, thanks...
00:32:28 <joma> > takeWhile (\x -> x /= "Lisp") ["haskell", "haskell", "Lisp", "haskell"]
00:32:29 <lambdabot>   ["haskell","haskell"]
00:32:33 <vixey> n+k  is translaed into  ((+k) -> n)
00:32:45 <vixey> well that doens't handle failure
00:32:49 <vixey> but roughly
00:32:56 * vixey waits for => views :/
00:32:59 <boegel> > isDigit 5
00:33:01 <lambdabot>       No instance for (Num Char)
00:33:01 <lambdabot>        arising from the literal `5' at <inte...
00:33:07 <koeien> > isDigit '5'
00:33:08 <lambdabot>   True
00:33:16 <boegel> koeien: right...
00:33:25 <ski_> vixey : "=> views" ?
00:33:38 <koeien> vixey: interesting. i haven't played with views yet. what do you mean by '=> views'?
00:33:42 <vixey> ski_, I read that => could work exactly like ->, except it would open up a Maybe
00:33:55 <mathijs> ?pl \x y -> x - (negate y)
00:33:56 <lambdabot> (. negate) . (-)
00:33:56 <koeien> talk about 'ad hoc' :)
00:33:57 <ski_> ic
00:34:12 <boegel> @hoogle isDigit
00:34:13 <lambdabot> Data.Char isDigit :: Char -> Bool
00:34:52 <koeien> mathijs: what's wrong with (+) ?
00:34:53 <ski_> it would be more interesting, imo with semi-deterministic backwards modes of some functions (possibly specially declared)
00:35:08 <mathijs> koeien: it's broken on my keyboard :P
00:35:25 <koeien> lol
00:35:34 <mathijs> koeien: just kidding. just trying out pointfree (in this case pointless) style
00:36:01 <ski_> `f ("bork" ++ xs) = xs; f xs = "bork" ++ xs'-stuff
00:36:21 <vixey> ski_, the problem I see with that sort of thing is.. where do you draw the line?
00:36:35 <ski_> aye
00:36:59 <mmorrow> , let commaP = char ','; lexemeP p = do {o <- p; skipSpaces; return o}; intP :: ReadP Int; intP = read `fmap` munch1 isDigit; myQuickyP = sepBy (lexemeP intP) (lexemeP commaP); runP p s = case readP_to_S p s of [] -> ([],[]); xs -> last xs in runP myQuickyP "432 ,432, 2222, $@$"
00:37:00 <ski_> we might end up with a full (pure) functional logic language if we don't watch out !
00:37:01 <lunabot>  ([432,432,2222],", $@$")
00:39:55 <mmorrow> , let nestedP nest p = p <++ nest (skipSpaces >> nestedP nest p); parensP = between (char '(') (char ')'); commaP = char ','; lexemeP p = do {o <- p; skipSpaces; return o}; intP :: ReadP Int; intP = read `fmap` munch1 isDigit; myQuickyP = sepBy (nestedP parensP (lexemeP intP)) (lexemeP commaP); runP p s = case readP_to_S p s of[]->([],[]); xs->last xs in runP myQuickyP "432 ,(((((432))))), (2222), $@"
00:39:57 <lunabot>  ([432,432,2222],", $@")
00:40:09 * mmorrow has been using ReadP quite a bit lately
00:40:15 <vixey> me too
00:40:52 <mmorrow> vixey: sweet. i finally got a most-of-haskell-syn ReadP parser that has no pauses or stalls :)
00:41:04 <vixey> what is syn?
00:41:07 <mmorrow> + fixity parsing
00:41:29 <mmorrow> just a generic-as-possible AST to make trans to whatever one is at hand as easy as possible
00:41:33 <mmorrow> i'll paste
00:41:59 <vixey> the way readP works, you can get away with infinite parsers
00:42:30 <vixey> I'm never sure if it's the right thing to do but it is very simple to loop things like that
00:42:50 <mmorrow> (i'm currently using a pre-given fixity+op tab, but i'm gonna do parse everything as infixl at first, then in a second pass fix up the fixities)
00:46:33 <vixey> @pl ((k =<<) . f)
00:46:33 <lambdabot> (k =<<) . f
00:46:37 <vixey> @pl \k f -> ((k =<<) . f)
00:46:37 <lambdabot> (.) . (=<<)
00:46:44 <vixey> :t (.) . (=<<)
00:46:46 <lambdabot> forall a a1 (m :: * -> *) b. (Monad m) => (a1 -> m b) -> (a -> m a1) -> a -> m b
00:46:46 <vixey> :t (<=<)
00:46:47 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
00:49:06 <mmorrow> vixey: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=766#a766
00:49:23 <mmorrow> it's self contained too
00:49:40 <vixey> mmorrow, oh! wow
00:49:53 <mmorrow> it works surprisingly well too
00:50:05 <mmorrow> i think i'm starting to get the hang of readP
00:50:23 <vixey> I don't understand <++ but I had to use it to make my parser not pause
00:51:30 <vixey> mmorrow, you will have an entire implementation soon!
00:51:47 <mmorrow> it tries the left side until it succeeds or fails, and if failure tries the right side from the original point
00:51:52 <mmorrow> vixey: :)
00:53:27 <vixey> mmorrow,  data T sym exp  works nice that's just how I did it too
00:54:09 <mmorrow> yeah that does work well. i looked at your prev paste for ideas
00:54:35 <vixey> it might not apply to your code, but there was at least one bug in mine
00:54:40 <vixey> I annotated with a fix
00:54:47 <mmorrow> hmm, /me looks
00:54:57 <vixey> specifically, having an operator like: ChainL " " 1000
00:55:45 <mmorrow> (i started writing the fixity stuff without a plan of how to incorporate it into the rest, so i'm not sure how ideal what i did wrt slipping it in is)
00:56:51 <mmorrow> ah yeah, totally. i realized the need for that last night after a good hour+ of WTFing
00:57:26 <mmorrow> i used `lexemeP' for killing spaces after stuff (==> before a ')'), and i changed my def of `nestedP' to:
00:57:40 <mmorrow> nestedP nest p = p <++ nest (skipSpaces >> nestedP nest p)
00:57:55 <mmorrow> to handle e.g. "(    42)"
01:02:19 <cjs> Oughtent fst and snd be members of a typeclass?
01:02:28 <vixey> cjs, no
01:02:35 <cjs> Why not?
01:03:09 <dolio> That would be too awesome.
01:03:17 <dolio> Might cause a space-time anomaly.
01:03:48 <cjs> I'm always wanting to fst an (a,b,c).
01:03:51 <vixey> you can make a new typeclass though and use the names fst and snd if you like
01:04:08 <vixey> frst (e,_,_) = e always worked for me thouh
01:04:41 <cjs> Ah, that's reasonable. And it extends nicely: 'first (e,_,_,_) = e'.
01:04:45 <vegai> < sjanssen> vegai: we're eventually going to reach the point where C's machine model doesn't apply any more
01:04:50 <cjs> Oh, but where do we go from there?
01:05:01 <vixey> fst
01:05:01 <vegai> sjanssen: I think that's probably a pipe dream, but I hope I'm wrong :)
01:05:04 <vixey> fst . snd
01:05:06 <vixey> fst . snd . snd
01:05:10 <vixey> caddadar
01:09:03 <dolio> "first" for 4-tuples doesn't work very well, because there's already a first and a second.
01:09:31 <dolio> But 4-tuples aren't that common an occurrence.
01:10:43 <ivanm> dons: ping!
01:29:00 <hynek> hi
01:31:49 * Baughn ponders. Is "middleware" a subtype of "library"?
01:33:33 <pozic> Why is there no MonadPlus instance for Identity?
01:33:50 <Baughn> What would it do?
01:35:54 <pozic> Baughn: not much, just to satisfy a constraint.
01:36:17 <pozic> Baughn: but maybe I can change the stacking order so the problem doesn't exist.
01:37:16 <Baughn> pozic: Well, you can always define an instance, but off-hand I'd say that it doesn't make sense and betrays a flaw in your design
01:40:29 <quicksilver> I can imagine why there would be a MonadPlus instance for Identity.
01:40:32 <quicksilver> can't
01:40:35 <quicksilver> I mean :)
01:40:38 <quicksilver> what would mzero be?
01:42:05 <Axman6> ()?
01:42:24 <Saizan_> mzero :: forall a. Identity a
01:42:41 <opqdonut> undefined, of course
01:42:49 <opqdonut> ;)
01:43:05 <Baughn> The lovely, all-encompassing, all-doing undefined. Any function can be defined as.. undefined.
01:44:22 <quicksilver> pozic: why do you seem to want a MonadPlus instance for Identity?
01:44:27 <quicksilver> I feel sure your problem has another solution.
01:45:34 <Baughn> @quote MonadPlus
01:45:35 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
01:46:08 <BONUS> does it count if we say mzero is _|_
01:46:22 <BONUS> wait i guess not, that violates the laws
01:46:27 <Baughn> opqdonut already suggested that. :P
01:46:33 <Baughn> And yes it does, but not in an observable way.
01:46:36 <Peaker> You could have: instance Monoid a => MonadPlus (Identity a) where ...
01:46:48 <BONUS> oh, excuse me
01:46:48 <pozic> quicksilver: yes, it has a different solution and it has already been solved. Thanks all.
01:47:22 <quicksilver> \o/
01:48:22 <Peaker> IMO: MonadPlus ought to be a "flag class", an empty class that subclasses Monoid (m a) and Monad m, to "flag" that the MonadPlus laws (relating mzero/>>=/etc) are abided
01:48:39 <Peaker> What's mconcat for MonadPlus?
01:48:45 <dolio> Identity a doesn't have the right kind to be MonadPlus.
01:49:11 <Peaker> dolio: oh, right, oops
01:49:25 <Peaker> you can't really say Identity is a MonadPlus only when it has Monoids inside it...
01:50:13 <MechaBlue> Finally done.  A patch for Test.HUnit documentation has been submitted.
01:50:20 <Peaker> I guess that's a significant difference between (Monoid (m a)) and (MonadPlus m) -- the latter means it cannot use the monoid-ness of the contained value
01:50:44 <quicksilver> Peaker: you'd need the constraint to be higher-rank
01:50:48 <pozic> I thought the problem was solved, but it isn't. How does one use mzero when the bottom monad is Identity? I.e., something involving MaybeT Identity? Or do I have to use lift in this case?
01:50:52 <Peaker> quicksilver: what does that mean?
01:50:56 <quicksilver> (forall a . Monoid (m a)) => MonadPlus m
01:51:06 <quicksilver> nested forall in the constraint, essentialy
01:51:11 <quicksilver> we can't express that I don't think.
01:51:43 <Peaker> @hoogle MonadPlus m => [m a] -> m a
01:51:44 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
01:51:44 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
01:51:44 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
01:51:47 <dolio> That'd be covered by the MonadPlus instance for MaybeT m.
01:51:50 <Peaker> quicksilver: oh, but it would be nice, because it would avoid code duplication between mconcat and msum
01:51:59 <Workybob> > let f (((:) x) y) = (x:y) in f [1,2]
01:52:01 <lambdabot>   <no location info>: Parse error in pattern
01:52:04 <Workybob> ghc bug?
01:52:07 <Peaker> (and the various other Monoid functions)
01:52:12 <Workybob> or is that pattern syntax really not allowed?
01:52:31 <Peaker> > let f ((:) x y) = (x:y) in f [1,2]
01:52:33 <lambdabot>   [1,2]
01:52:43 <Peaker> Workybob: the extra parens around (.. x) are not allowed
01:52:48 <Workybob> Peaker: yeh, why not?
01:52:52 <dolio> That assumes that mconcat is the same function as mplus.
01:53:01 <Peaker> dolio: as msum
01:53:08 <quicksilver> Workybob: constructors have a fixed arity, when they're in patterns.
01:53:09 <loadquo> > let f x y = (x:y) in f[1,2]
01:53:10 <lambdabot>       Overlapping instances for Show ([[t]] -> [[t]])
01:53:10 <lambdabot>        arising from a u...
01:53:16 <quicksilver> it's a simpler syntactic model.
01:53:21 <Peaker> dolio: I think MonadPlus is really just (Monad m, (forall a. Monoid (m a)), MonadPlus laws)
01:53:24 <dolio> Right. Substitute mappend for mconcat.
01:53:27 <Peaker> dolio: so why not?
01:53:32 <quicksilver> there is no 'partial application' inside patterns.
01:54:00 <Peaker> dolio: MonadPlus laws are a strict superset of the Monoid laws, right?
01:54:12 <dolio> > Just (Product 5) `mplus` Just (Product 6)
01:54:14 <lambdabot>   Just (Product {getProduct = 5})
01:54:25 <dolio> > Just (Product 5) `mappend` Just (Product 6)
01:54:26 <Peaker> dolio: so if you have a class that has a superset of the methods of another class, and a superset of the laws, why doesn't it subclass it?
01:54:26 <lambdabot>   Just (Product {getProduct = 30})
01:54:59 <Peaker> dolio: I know having multiple classes with the same laws allows people to have multiple Monoid instances without newtype'ing
01:55:06 <Peaker> dolio: but that does not mean its a good idea...
01:55:38 <Peaker> dolio: why have only 2 Monoid classes? Why not have 5 for types that can have even more valid Monoid instances?
01:55:41 <bpalmer`>  /join #prolog
01:56:05 <bpalmer`> (sorry about that)
01:56:26 <Peaker> dolio: duplicate all the code in the world that has type: (Monoid m ....) for these 5, and voila? :-)
01:56:29 * Peaker gtg
01:57:37 <dolio> There aren't two "monoid classes" simply because there are two (more, really) diffrent ways to make Maybe into a monoid.
01:57:59 <quicksilver> that's not the reason, no.
01:58:06 <quicksilver> but the fact is we have two monoid classes
01:58:27 <quicksilver> and you seemed to be suggesting that the two different instances for Maybe was a justifciation for the split?
01:58:34 <Cale> wha?
01:58:42 <Cale> We have two Monoid classes?
01:58:43 <quicksilver> myself I'm pretty sure the split is because we can't encode the higher-rank constraint.
01:58:45 <dolio> I'm saying that they don't coincide currently.
01:58:49 <quicksilver> Cale: Monoid and MonadPlus
01:59:15 <Cale> But MonadPlus doesn't have the same signature or laws as Monoid.
02:01:17 <dolio> And the fact that they don't coincide may well be justified, although I'm not particularly attached to the Monoid instance for Maybe.
02:01:34 <Cale> The default one?
02:01:46 <Cale> The default instance is the lifting instance, isn't it?
02:02:00 <dolio> Because one is "this is a monoid" and the other is "this is some kind of computation with failure and ambiguous choice."
02:02:18 <dolio> And the natural instance for the former may not coincide with the natural choice for the latter.
02:02:36 <dolio> Assuming a particular type can be seen as both.
02:03:22 <dolio> And in fact, people have argued that the latter isn't sufficient.
02:04:06 <dolio> Since you can have it mean "choose among all alternatives nondeterministically" or "try the first and only try the second if that fails."
02:04:09 <quicksilver> Cale: they do have the same laws.
02:04:26 <quicksilver> Cale: and the signatures overlap, if you happen to be dealing with types of one particular shape.
02:04:36 <quicksilver> of course, MonadPlus has more laws
02:04:38 <Cale> quicksilver: MonadPlus has interaction with the monad operations to consider.
02:04:47 <quicksilver> [*] not that there is complete agreement on the "more" laws.
02:04:56 <quicksilver> yes.
02:05:03 <Cale> I think MonadPlus should be split in order to account for the differences in laws.
02:05:11 <quicksilver> Peaker's proposal is that MonadPlus should be a method-less class.
02:05:17 <quicksilver> jsut a 'flag' to indicate the laws.
02:05:29 <dolio> So I'm not impressed by the statement, "both these classes have functions of type 'm a' and 'm a -> m a -> m a' that follow some of the same laws."
02:05:40 <quicksilver> class (forall a. Monoid (m a), Monad m) => MonadPlus m where;
02:06:08 <quicksilver> dolio: are you denying that "mzero" and "mplus" form a monoid?
02:06:12 <quicksilver> surely not.
02:06:20 <quicksilver> I think of it that way myself.
02:06:26 <quicksilver> it's just I know the haskell type system doesn't.
02:06:28 <dolio> Why would I deny that?
02:06:33 <quicksilver> at least not with a capital M.
02:06:44 <quicksilver> well, you seemed to be denigrating that view
02:06:52 <quicksilver> as if to suggest it was somehow a coincidence
02:06:58 <quicksilver> that they 'happen' to be the same laws.
02:07:45 <Cale> It would be rather nice if we had a language where Monad and Monoid could be identified.
02:07:49 <quicksilver> (On the other hand, there are other similar observations we can't codify, like the fact that "return ()" and (>>) make "m ()" a Monoid, for all m)
02:08:22 <Cale> I wonder how far away that is? :)
02:08:39 <quicksilver> it's a bit like the generators-relations problem
02:08:47 <quicksilver> there is more than one way to specify these properties
02:09:00 <quicksilver> programming languages tend to want to start somewhere and work in one direction.
02:09:07 <dolio> Well, I mean, it's not hard if you don't mind passing dictionaries by hand.
02:09:27 <quicksilver> whereas mathmeticians like to note all the properties from all directions.
02:09:35 <dolio> effectMonoid :: Monad m -> Monoid (m ())
02:09:37 <dolio> Et cetera.
02:09:53 * quicksilver nods
02:09:59 <quicksilver> true.
02:10:05 <quicksilver> Probably typeclasses are just a bad idea.
02:10:11 <dolio> Totally. :)
02:10:12 <quicksilver> datas are much nicer than classes.
02:10:34 <Cale> return = mempty, join = mappend ;)
02:11:24 <quicksilver> that's a generalisation of Monoid though, isn't it.
02:11:30 <quicksilver> at least, relative to the haskell notion.
02:11:35 <Cale> Well, yes.
02:11:36 <quicksilver> It's a monoid in a different category.
02:11:47 <Cale> Monoid presently means monoid object in Hask.
02:11:59 <quicksilver> "in a different category" is the universal truth maker.
02:12:03 <dolio> Might depend on how fancy your internal modelling of category theory gets.
02:12:10 <quicksilver> You can make any sensible looking statement true if you add that at the end.
02:12:21 <quicksilver> along with "up to some notion of equivalence"
02:12:53 <quicksilver> the haskell typeclass system is actually the US train network, in a different category (up to some notion of equivalance).
02:13:02 <Cale> heh
02:13:38 <Cale> This is not totally devoid of meaning though.
02:13:51 <quicksilver> no.
02:14:16 <quicksilver> it's actualy quite insightful, from some perspective.
02:14:26 <Cale> We just don't have enough of a categorical language to express how these things are the same shape.
02:14:29 <quicksilver> But is it insightful from the perspective of designing a good programming language?
02:16:01 <Peaker> quicksilver: passing dicts instead of typeclasses - how do you know that two dicts of the same type are indeed the same?
02:16:29 <Peaker> quicksilver: would you really prefer Haskell without typeclasses? :)
02:16:30 <Cale> Somehow I have this vague feeling that at least some programming languages will drift in that direction.
02:17:08 <Peaker> I have to go.. I'd love to hear how (return = mempty, join = mappend) sometime  - it doesn't make sense to me :)
02:17:16 <Cale> (in the direction of a category-centric view of the world)
02:17:28 <dolio> Typeclasses are just passing dictionaries, but you don't get to choose the dictionary that gets used.
02:17:35 <Cale> Peaker: sure thing, remind me at some point to tell you
02:19:04 <dolio> Or, you can choose, but you have to wrap things in newtypes to do so. :)
02:19:46 <Cale> Let's suppose that our goal is a language which really can identify return with mempty and join with mappend. What can we say about this language already?
02:20:42 <Cale> I suppose first of all that it has a type system which can represent things like the composition of functors naturally.
02:21:17 <pozic> Can someone give an example of how to combine MaybeT with RandT such that in the resulting newtyped monad one can use mzero?
02:22:04 <pozic> Whatever order I do I get either a missing (MonadRandom (MaybeT (RandT StdGen m))) or a missing (MonadPlus (RandT StdGen
02:22:11 <pozic> instance.
02:22:45 <Cale> pozic: Use lift
02:22:56 <Cale> :t lift
02:22:57 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
02:23:05 <Cale> m a -> t m a
02:23:32 <Cale> So if you have an m-action, you can turn it into a (t m)-action.
02:23:56 <pozic> Cale: you mean in the definition of the MonadPlus instance?
02:24:07 <pozic> Cale: since otherwise I need to place those lifts everywhere.
02:24:10 <Cale> If MaybeT is on the outside, then, you'll have to lift anything which came from MonadRandom
02:24:26 <Cale> You should always use monad transformers inside a newtype
02:24:33 <Cale> and define instances for that newtyped monad.
02:24:58 <Cale> (or derive the instances with newtype deriving)
02:25:15 <pozic> Cale: I have defined a newtyped version, but it cannot derive an instance for MonadPLus or MonadRandom because of the above.
02:25:27 <Cale> right, so you'll have to write one of the two
02:28:04 <quicksilver> Peaker: I would prefer haskell with typeclasses used very seldom, yes.
02:28:40 <quicksilver> Peaker: the Num family is just about the only *really* convincing case.
02:29:07 <quicksilver> Peaker: you would never know that two dictionaries are the same. If you wanted to use the same dictionary, you'd design the program so it's only passed one.
02:30:00 <quicksilver> pozic: yes, you will have to derive them yourself (because the authors of RandT and MaybeT didn't know about each other, basically)
02:30:06 <quicksilver> fortunately it's not hard to do.
02:31:24 <pozic> I tried to write the MonadPlus instance for RandT, but I don't know what it should do.
02:31:51 <pozic> for mzero I had lift mzero, but it's mplus that's the problem.
02:32:14 <quicksilver> (RandT a) `mplus` (RandT b) = RandT (a `mplus` b)
02:32:26 <Cale> er...
02:32:51 <pozic> quicksilver: the problem is that I cannot pattern match on the RandT constructor.
02:32:53 <Cale> I suppose that works, if you're writing it directly for RandT, and not just for your new monad
02:33:24 <Cale> To write it directly for RandT, you'll have to contribute the code to the Control.Monad.Random module.
02:34:03 <quicksilver> well, OK, but it must have a runRandT or something
02:34:25 <pozic> Yes, it does have that.
02:34:25 <quicksilver> x `mplus` y = RandT( runRandT x `mplus` runRandT y)
02:34:34 <quicksilver> modulo possibly threading the RNG between the two.
02:34:46 <quicksilver> I'm not looking at the source here, so I'm stabbing in the dark.
02:34:55 <Cale> I'm fairly sure that the RandT constructor is not exported.
02:35:58 <quicksilver> I would class that as a bug.
02:36:06 <quicksilver> since you need the constructor to write instances like this.
02:36:28 <pozic> quicksilver: lift works, I think
02:36:50 <quicksilver> pozic: yeah, but there isn't a binary lift
02:36:56 <quicksilver> which is the problem you found with mplus
02:38:04 <quicksilver> I can confirm the constructor isn't exported.
02:38:04 <quicksilver> I'd be inclined to consider this a bug, myself.
02:38:09 <quicksilver> as a practical solution, you may prefer to use MaybeT (RandT ....)
02:38:19 <quicksilver> since lifting MonadRandom through MaybeT should be easier.
02:39:22 <roderyk> got a new freebsd box, so I'm wondering: will the latest cabal-install run on ghc-6.8.3 (which is in ports), or do I need to mess about getting 6.10.x?
02:39:51 <blackh1> roderyk: Yes, it works on 6.8.3
02:40:12 <roderyk> blackh1: thanks, that will save me a lot of dependency tracking :)
02:44:06 <cajun-rat> I don't understand what I'm seeing with some FFI code: (in this example res is a CString)
02:44:17 <cajun-rat> poke (plusPtr res len) (0::CChar)
02:44:30 <cajun-rat> poke (plusPtr res len) '\0'
02:45:03 <cajun-rat> the first example writes 1 byte, and the second appears to write 4
02:45:21 <quicksilver> cajun-rat: that's probalby because C Chars are 1 byte long.
02:45:35 <quicksilver> whilst unicode code points are 4 bytes.
02:46:17 <cajun-rat> but given the first arg of poke is a Ptr CChar, why is a different version of poke getting called?
02:47:00 <cajun-rat> poke :: Ptr a -> a -> IO ()
02:47:03 <chrisdone> @pl \a b -> a . (>>= b)
02:47:04 <lambdabot> (. (=<<)) . (.)
02:47:18 <chrisdone> :t \a b -> a . (>>= b)
02:47:20 <lambdabot> forall c (m :: * -> *) a b. (Monad m) => (m b -> c) -> (a -> m b) -> m a -> c
02:47:33 <chrisdone> @hoogle (m b -> c) -> (a -> m b) -> m a -> c
02:47:34 <lambdabot> Control.Parallel.Strategies parFlatMap :: Strategy [b] -> (a -> [b]) -> [a] -> [b]
02:48:05 <cajun-rat> i would have expected the second example to fail to type check
02:48:09 <quicksilver> cajun-rat: hmm. are you sure the first argument isn't polymorphic?
02:48:17 <quicksilver> @hoogle poke
02:48:17 <lambdabot> Foreign.Storable poke :: Storable a => Ptr a -> a -> IO ()
02:48:17 <lambdabot> Foreign.Marshal.Array pokeArray :: Storable a => Ptr a -> [a] -> IO ()
02:48:17 <lambdabot> Foreign.Marshal.Array pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()
02:48:30 <quicksilver> :t '\0'
02:48:32 <lambdabot> Char
02:48:36 <quicksilver> :t '\0' :: CChar
02:48:38 <lambdabot> Not in scope: type constructor or class `CChar'
02:48:50 <quicksilver> cajun-rat: I agree it should fail to typecheck.
02:50:00 <quicksilver> cajun-rat: oh, it's plusPtr
02:50:08 <quicksilver> cajun-rat: plusPtr adds polymorphism.
02:50:15 <quicksilver> @hoogle plusPtr
02:50:15 <lambdabot> Foreign.Ptr plusPtr :: Ptr a -> Int -> Ptr b
02:50:22 <cajun-rat> ah
02:50:40 <quicksilver> you can kind of see why
02:50:47 <quicksilver> although conversely it also seems a bit dumb.
02:50:48 <cajun-rat> now it makes sense
02:51:31 <cajun-rat> thanks!
03:03:47 <digitalexander> noob question here: i don't really understand the Data.List.sortBy function. Can anyone show me an example, or point me to a helpful resource with examples?
03:04:38 <quicksilver> > sortBy compare [1,3,5,2,4]
03:04:39 <lambdabot>   [1,2,3,4,5]
03:04:46 <quicksilver> > sortBy (flip compare) [1,3,5,2,4]
03:04:46 <web_hi> test
03:04:47 <lambdabot>   [5,4,3,2,1]
03:04:55 <quicksilver> digitalexander: do those two examples help in any way? :)
03:05:01 <quicksilver> digitalexander: if not, what would help?
03:05:48 <digitalexander> lambdabot: depends, could compare be any function in this context? And what would it's signature have to be if I were to provide my own?
03:06:03 <quicksilver> :t sortBy
03:06:03 <digitalexander> sorry, meant quicksilver:
03:06:04 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
03:06:21 <quicksilver> the signature of compare is shown in the type
03:06:26 <quicksilver> it must be (a -> a -> Ordering)
03:06:56 <digitalexander> quicksilver: ok, this is where I don't understand, what is Ordering?
03:07:00 <hugo___> hi
03:07:09 <quicksilver> digitalexander: Ordering is a simple type with three possibilities.
03:07:13 <quicksilver> @src Ordering
03:07:13 <lambdabot> data Ordering = LT | EQ | GT
03:07:17 <digitalexander> ah, ok
03:07:25 <quicksilver> > compare 1 3
03:07:26 <lambdabot>   LT
03:07:30 <quicksilver> > compare 3 3
03:07:32 <lambdabot>   EQ
03:07:42 <quicksilver> > compare "happy" "sad"
03:07:43 <lambdabot>   LT
03:08:17 <digitalexander> so I could do something like let myordering x = if x > 0 then LT else GT (bad example maybe, but somewhere along those lines?)
03:08:50 <digitalexander> and then Data.List.orderBy myordering [1..10]
03:09:07 <digitalexander> feel free to let me know if I'm totally mistaken :)
03:09:17 <quicksilver> yes.
03:09:25 <BONUS> myordering x takes just one parameter and compares it to 0
03:09:34 <quicksilver> except you need two parameters
03:09:38 <BONUS> whereas orderBy takes a function that takes two parameters
03:09:53 <FunctorSalad> performance question... if I have something like "data Tree a ix = Leaf a | Node (ix -> Tree a ix)"... will the function calls get optimized away when I actually build a tree, probably passing some closures to Node
03:09:59 <quicksilver> > sortBy (\x y -> if x > 0 then LT else GT) [1,5,2,4,3]
03:09:59 <digitalexander> BONUS & quicksilver: yeah, of course, I understand
03:10:00 <lambdabot>   [1,5,2,4,3]
03:10:07 <quicksilver> ^^ this is not particularly useful.
03:10:08 <FunctorSalad> "ix" is the index type for children
03:10:09 <BONUS> maybe you could try partition
03:10:09 <quicksilver> but it worked :)
03:10:22 <BONUS> > partition (>0) [-1,5,-3,9,-6,10]
03:10:23 <lambdabot>   ([5,9,10],[-1,-3,-6])
03:10:27 <digitalexander> quicksilver: yeah, thanks! Finally, a real-world example from which I could work my way onwards...thanks!
03:10:29 <quicksilver> FunctorSalad: no.
03:10:46 <quicksilver> FunctorSalad: at least, I'm pretty sure they don't.
03:11:02 <quicksilver> but function "call" is a loose term in a GHC-like compiler
03:11:17 <FunctorSalad> quicksilver: hmm... what if I build a node with "Node (myMap !)", where myMap :: Map ix (Tree a ix)
03:11:32 <quicksilver> doesn't matter what you do
03:11:36 <quicksilver> all that gets stored is a thunk :P
03:11:38 <FunctorSalad> quicksilver: yes, I'm a total newbie with GHC internals
03:11:54 <quicksilver> this is not really a special case for function-type fields either.
03:12:00 <quicksilver> value-type fields are thunks too
03:12:55 <pejo> FunctorSalad, are you hoping that GHC will change the representation in that optimization?
03:13:20 <FunctorSalad> I'm not sure what exactly I mean by "optimized away", but I basically mean that if I use Ix = Bool and inline/specialize everything, then it will run just like a standard binary Tree
03:14:04 <FunctorSalad> the scheme for building the tree is in the same module if that helps
03:17:02 <FunctorSalad> I suppose I should (try to) read the generated code...
03:18:34 <lilac> @type flip (>=>)
03:18:36 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
03:18:40 <lilac> chrisdone: ^^
03:18:52 <FunctorSalad> maybe I'm looking for "Array ix a" rather than "ix -> a"
03:18:55 <lilac> @type (<=<)
03:18:57 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
03:19:37 <quicksilver> FunctorSalad: I have wondered about the efficiency of storing maps as (->) versus Data.Map myself.
03:19:42 <quicksilver> FunctorSalad: but, I don't have answers for you.
03:20:05 <FunctorSalad> :)
03:20:41 <FunctorSalad> maybe if you give the actually stored function a name and {-# INLINE #-} it?
03:20:52 <quicksilver> don't think that makes any difference
03:20:54 <quicksilver> code is still code.
03:21:11 <quicksilver> inlining is a source transformation, not a data storage transformation.
03:21:28 <lilac> FunctorSalad: it's my understanding that that won't be optimized away into a binary tree since that would leak space
03:21:32 <FunctorSalad> but couldn't there be some opportunity to totally eliminate the map if you build and then use a tree?
03:21:33 <Cale> quicksilver: It depends on the structure of the function of course. Since functions are opaque, it's hard to rebalance them when you add/change things though.
03:21:45 <FunctorSalad> (for a simple index type like Bool)
03:22:08 <quicksilver> Cale: yes. If you change a function you have to do it externally.
03:22:14 <lilac> FunctorSalad: in general, i would think (Bool -> a) will not be turned into (a, a) since that's a space leak
03:22:20 <quicksilver> Cale: so you're always adding O(number of changes) to access time.
03:22:22 <quicksilver> Cale: right?
03:22:29 <Cale> yeah
03:23:06 <quicksilver> might be quite nice to have a profiling runtime which could convert functions of finite support to lookup tables
03:23:12 <FunctorSalad> hmm, you can modify a function with a closure, no?
03:23:14 <quicksilver> based on profiling info :)
03:23:27 <mmorrow> heh, here's a super short example of how to hijack syms a dyn linked prog goes looking for: http://moonpatio.com/repos/sleepless/
03:23:38 <quicksilver> of indeed, functions of "mostly" finite support
03:23:38 <FunctorSalad> (\x -> if x == k then newVal else f x)
03:23:46 <mmorrow> (copied verbatim from http://www.benyossef.com/presentations/dlink/)
03:23:50 <quicksilver> convert into a lookup table for the common case and a fallback.
03:24:00 <quicksilver> FunctorSalad: yes, that's what I meant by externally.
03:24:21 <quicksilver> FunctorSalad: you keep wrapping up the lambdas, so you're adding a O(number of times you wrapped stuff up) to most complexities.
03:25:23 <FunctorSalad> hmm
03:25:32 <quicksilver> not all, of course.
03:25:40 <quicksilver> since some of your warpping lambdas may add fast paths
03:25:45 <quicksilver> like the x==k one in your example.
03:25:52 <quicksilver> it's a bit tricky to analyse in detail.
03:26:19 <FunctorSalad> I was hoping that the whole resulting lambda expression could be further simplified
03:27:07 <quicksilver> no, lambdas are opaque.
03:27:32 <quicksilver> the compiler can make static (compile-time) optimisations.
03:27:42 <FunctorSalad> yes, I meant static
03:27:49 <quicksilver> but the process of building them up at run-time is opaque, you can't tear them down.
03:27:58 * quicksilver nods
03:28:07 <quicksilver> well to the extent taht stuff is statically visible to the compiler
03:28:14 <quicksilver> then yes, it can and will inline and simplify.
03:30:52 <FunctorSalad> hmm... a binary tree would have lambdas such as: buildTree stuff = let (xs,ys) = partition p stuff in Node (\b -> if b then buildTree xs else buildTree ys)
03:31:31 <FunctorSalad> if that lambda is applied to True or False, would it get reduced?
03:31:59 <quicksilver> only if it's visible to the compiler, at compile time.
03:32:19 <FunctorSalad> *nod*, it seems unlikely that there would be a constant True/False
03:32:20 <quicksilver> so if that whole thing gets inlined onto the context that the application happens.
03:32:38 <PeakerWork> quicksilver: why is Num the convincing case for type-classes?
03:32:43 <pozic> Should I ever give the inner monad access to the outer monad by using a lift? I want the inner monad to use the ask operation of the outer ReaderT monad, but the problem that I get is that suddently the programmer using the inner monad needs to decide every single time whether or not he needs to use lift.
03:33:15 <quicksilver> PeakerWork: because I really do want (+) to be overloaded to work on multiple types
03:33:32 <quicksilver> and passing Num dictionaries around arithmetical expressions would be a pain indeed.
03:33:44 <PeakerWork> quicksilver: you could have type-classes really be syntactic sugar then? Expose the extra parameter that's being passed?
03:34:01 <quicksilver> well, to some extent they are.
03:34:17 * dcoutts invites people to grab the darcs version of cabal-install and test out the new improved ./bootstrap.sh
03:34:21 <quicksilver> the only part of type classes which is more than syntactic sugar is the relatively complex instance search rules.
03:35:44 <FunctorSalad> by the way, is there a type class for leaving it undecided whether you want to use (->), Map, Array and so on?
03:36:13 <FunctorSalad> (as I understand it, that will get specialized away)
03:37:59 <quicksilver> no.
03:38:02 <quicksilver> You could write one.
03:38:02 <FunctorSalad> of course it would be trivial to write, I just mean whether there is one already :)
03:38:20 <FunctorSalad> class Function f a b | f -> a, f-> b where apply :: f -> a -> b -- or so
03:38:36 <mercury^> FunctorSalad: there are containers, they might do what you want.
03:39:08 <pao> hi all :-) could Data.Set be an instance of Data.Traversable?
03:39:59 <pao> if yes, the reason for which the instance is not there, is not to introduces dependencies between different packages?
03:40:05 <FunctorSalad> pao: sadly no, it's not even a functor because functors aren't allowed to have a context (Ord, here) in the standard library :(
03:40:31 <pao> FunctorSalad: ahhh, right
03:40:32 <FunctorSalad> there's a package "rmonad" implementing restricted functors and monads...
03:41:21 <pao> FunctorSalad: nice to know... I was asking if there was a "standard" solution for restricted monads ...
03:41:43 <pao> FunctorSalad: obviously I need to define the instance myself...
03:41:55 <FunctorSalad> is it even possible to make Set a Functor by throwing runtime errors for non-Ords? I don't think you can cast to "arbitrary Ord"
03:42:07 <quicksilver> FunctorSalad: no.
03:42:18 <quicksilver> because instances are selected at compile time, not run time.
03:42:26 <quicksilver> at run time types don't exist, let alone typeclasses.
03:42:28 <FunctorSalad> makes sense...
03:44:21 <mercury^> FunctorSalad: there's an example of what you want in "Type classes with Functional Dependencies"
03:45:52 <FunctorSalad> I know it's possible if you are allowed to rewrite Functor and so on :)
03:51:40 <elliotbay> So, I'm traversing this tree of game states.  Of course, many states repeat and I'd like to avoid recalculating those states, given the time complexity difference.  I know how I'd do that in an imperative language, and I know I could shoehorn that method in with dos and whatnot.  I'm wondering if there's a good, functional way to do this, though
03:52:17 <MarcWebe1> Do you know how to make hslogger only log to a file?
03:52:31 <mmorrow> elliotbay: so you mean use a graph instead?
03:53:00 <blackh1> elliotbay: How would you do it in an imperative language? (So I can understand your problem - I'm in transition to FP, too.)
03:53:49 <elliotbay> mmorrow: I have never actually thought of it like that, but that is pretty accurate for what I'm trying to do
03:55:28 <elliotbay> blackh1: In Python, I would have a dictionary of all the game states (initially empty).  When I calculate the value of that state, I would place it in the dictionary, and could therefore just query it whenever I need to find that out for future nodes that look like that
03:55:42 <Workybob> elliotbay: so why not do that in this case?
03:55:48 <Workybob> Data.Map exists for such a purpose
03:55:49 <BONUS> you can use a map
03:55:50 <BONUS> yeah
03:56:13 <BONUS> although the states have to be in Ord :[
03:56:23 <mmorrow> elliotbay: one option (not knowing really what you're doing) might be to have a type StateId = Int; newtype GameStates s = GS {unGS :: IntMap s}, and if you in addition to that had a (s -> [StateId]) you could use graph algos or something
03:56:25 <elliotbay> It seems really non-functional
03:56:31 <Workybob> true, but if they're not, it's easy to give yourself a fake Ord implementation that means nothing much
03:56:34 <Workybob> elliotbay: why?
03:57:30 <BONUS> idk, i think that when making games, it requires tracking a lot of state, so that in itself is kidn of "non-functional"
03:58:04 <Workybob> well no
03:58:05 <mmorrow> > foldl' (\m n -> Map.insertWith' (+) n 1 m) Map.empty . take 10000 $ randomRs (0,3::Int) (mkStdGen 37198267)
03:58:06 <blackh1> elliotbay: That reminds me of my first big Haskell program, which was an adventure game. All the rooms "linked" to each other by "containing" the neighbouring room. This worked until I started modifying the rooms, because as soon as I left the room then came back, my modifications disappeared!  A map would be the proper way to do this.
03:58:06 <lambdabot>   fromList [(0,2478),(1,2464),(2,2506),(3,2552)]
03:58:08 <elliotbay> It's not that I'm making a game, but traversing a game tree.  What I have right now is just standard minimax
03:58:10 <Workybob> FRP solves that nicely BONUS
03:58:25 <Workybob> shame that Reactive isn't totally stable yet
03:58:48 <Workybob> elliotbay: you may also want to try using Data.Graph
03:58:54 <BONUS> yeah, true that
03:58:59 <mmorrow> > foldl' (\m (k,v) -> Map.insertWith' (++) k [v] m) Map.empty . zip (cycle ['a'..'d']) . take 10000 $ randomRs (0,3::Int) (mkStdGen 37198267)
03:59:01 <lambdabot>   fromList [('a',[2,1,1,1,1,2,0,3,2,2,2,2,3,1,3,1,1,0,3,3,2,3,1,1,3,2,1,0,0,0...
03:59:20 <Workybob> blackh1: actually, I had some fun with an adventure game in Haskell representing it as a two dimensional zipper
03:59:40 <mmorrow> > foldl' (\m (k,v) -> Map.insertWith' Set.union k (Set.singleton v) m) Map.empty . zip (cycle ['a'..'d']) . take 10000 $ randomRs (0,3::Int) (mkStdGen 37198267)
03:59:42 <lambdabot>   fromList [('a',fromList [0,1,2,3]),('b',fromList [0,1,2,3]),('c',fromList [...
03:59:42 <Workybob> commands just became functions that worked on the world
03:59:45 <Workybob> it was rather nice
03:59:47 <hiredman> I was just going to suggest a zipper
03:59:56 <mmorrow> that function is super handy for maps
04:00:28 <blackh1> Workybob: Bonkers! I haven't quite got to zippers yet. The DSL approach would also be brilliant for adventure games. You could write the game logic *really* nicely.
04:00:53 <BONUS> blackh1: http://www.haskell.org/haskellwiki/Zipper this is a really cool write-up of zippers
04:00:58 <Workybob> it had several really nice features
04:01:01 <BONUS> v. easy to understand
04:01:05 <blackh1> BONUS: Much appreciated.
04:01:17 <Workybob> because it was all just a zipper, I could write procedural worlds in it with next to 0 effort
04:01:33 <mmorrow> @let collect (<>) f g xs = foldl' (\a m -> M.insertWith' (<>) (f a) (g a) m) Map.empty xs
04:01:34 <lambdabot>  <local>:41:72: Not in scope: `Map.empty'
04:01:36 <Workybob> you really could have infinitely long corridors etc
04:01:39 <elliotbay> The main problem with turning it into a graph is that when I generate the states, I won't have knowledge of the other states on that level (At this point, it's just Tic-Tac-Toe, so the only way states are the same is if they're at the same depth)
04:01:40 <mmorrow> @let collect (<>) f g xs = foldl' (\a m -> M.insertWith' (<>) (f a) (g a) m) mempty xs
04:01:43 <lambdabot>  Defined.
04:01:50 <mmorrow> @type collect
04:01:51 <lambdabot>     Ambiguous occurrence `collect'
04:01:51 <lambdabot>     It could refer to either `L.collect', defined at <local>:41:0
04:01:51 <lambdabot>                           or `Test.QuickCheck.collect', imported from Test.QuickCheck
04:01:55 <mmorrow> sigh
04:02:11 <mmorrow> @let collect_ (<>) f g xs = foldl' (\a m -> Map.insertWith' (<>) (f a) (g a) m) mempty xs
04:02:12 <lambdabot>  <local>:42:39: Not in scope: `Map.insertWith''
04:02:16 <mmorrow> @let collect_ (<>) f g xs = foldl' (\a m -> M.insertWith' (<>) (f a) (g a) m) mempty xs
04:02:19 <lambdabot>  Defined.
04:02:19 <mmorrow> epic
04:02:40 <Workybob> elliotbay: so in each stage, progress all game-states by one move, then you get a list of new scenarios, and how to get to them, and you can munge them into the graph
04:03:03 <Workybob> that should work nicely as a list comprehension and a sort
04:03:03 <mmorrow> > collect (+) id (const 1) $ take 10000 (randomRs (0,3::Int) (mkStdGen 37198267))
04:03:07 <lambdabot>       Ambiguous occurrence `collect'
04:03:07 <lambdabot>      It could refer to either `L.collect...
04:03:08 <mmorrow> > collect_ (+) id (const 1) $ take 10000 (randomRs (0,3::Int) (mkStdGen 37198267))
04:03:09 <lambdabot>       Occurs check: cannot construct the infinite type: k = M.Map k a
04:03:09 <lambdabot>        ...
04:03:11 <blackh1> Workybob: My favorite idea is a "tent" which is a portable room. :) The map created annoying work in the adventure game (possible to encapsulate it, of course), so I can see where the zippers would be great.
04:03:29 * mmorrow is just botching everything
04:04:29 <mmorrow> @type let  wrangle (<>) f g xs = foldl' (\m a -> Map.insertWith' (<>) (f a) (g a) m) mempty xs in wrangle
04:04:30 <lambdabot> Couldn't find qualified module.
04:05:05 <mmorrow> @let wrangle (<>) f g xs = foldl' (\m a -> M.insertWith' (<>) (f a) (g a) m) mempty xs
04:05:08 <lambdabot>  Defined.
04:05:13 <mmorrow> there, that's the function i meant
04:05:30 <mmorrow> > wrangle (+) id (const 1) $ take 10000 (randomRs (0,3::Int) (mkStdGen 37198267))
04:05:32 <lambdabot>   fromList [(0,2478),(1,2464),(2,2506),(3,2552)]
04:06:23 <mmorrow> > wrangle (++) fst ((:[]) . snd) . zip (cycle ['a'..'d']) $ take 10000 (randomRs (0,3::Int) (mkStdGen 37198267))
04:06:25 <lambdabot>   fromList [('a',[2,1,1,1,1,2,0,3,2,2,2,2,3,1,3,1,1,0,3,3,2,3,1,1,3,2,1,0,0,0...
04:06:41 <mmorrow> > wrangle Set.union fst (Set.singleton . snd) . zip (cycle ['a'..'d']) $ take 10000 (randomRs (0,3::Int) (mkStdGen 37198267))
04:06:43 <lambdabot>   fromList [('a',fromList [0,1,2,3]),('b',fromList [0,1,2,3]),('c',fromList [...
04:07:08 <mmorrow> :: Map Char (Set Integer)
04:07:21 <mmorrow> :: Map Char [Integer]
04:07:25 <mmorrow> :: Map Char Integer
04:07:30 <mmorrow> (in reverse order)
04:08:59 * mmorrow thinks he's going to stick with "wrangle" over "collect" from now on..
04:09:42 <elliotbay> Workybob: Your suggestion is starting to solidify as something that might work with minimal change to my organization, if my concept of lazy evaluation is solid enough
04:13:18 <mmorrow> elliotbay: i think this might be especially relevant, maybe not exactly directly wrt your data structure, but imo it's a great reminder how we sometimes think ourselves into a fake corner with immutable stuff  http://www.haskell.org/pipermail/haskell-cafe/2009-January/052795.html
04:14:18 <mmorrow> (and i think it might be directly relevant some too)
04:17:06 <Saizan> 3the update operation takes constant time (for lists longer than 32 elements on 32-bit platform)
04:29:56 <blackh1> mmorrow: I like that doubly linked list implementation a lot.
04:31:38 <elliotbay> I may have to revisit this later when I feel like I have a better handle on the language
04:33:29 <elliotbay> Actually, now that I think about it, I think that's an implementation we'll be going over in my functional programming seminar later this term
04:37:47 <blackh1> I would love to be learning Haskell in a University instead of in the school of the midnight elves.
04:38:18 <Workybob> blackh1: I would recommend signing up for York uni then – Colin Runciman was an awesome teacher for functional programming
04:38:49 <quicksilver> I dunno.
04:39:01 <quicksilver> the elves are more fun than most university students, aren't they?
04:39:36 <blackh1> Workybob: Hmm - the other side of the world. When I look at it realistically, though, I hated University! Would I really want to do it again?
04:39:52 <scook0> my uni had a course that was taught with Haskell
04:39:59 <scook0> it was cancelled the year I would have taken it :/
04:40:03 <p_l> ... especially when they alter between trolling and hard science? <-- had been to lecture where he learned more sitting on IRC than listening to lecturer
04:40:20 <scook0> (though by that time I probably wouldn't have learned anything new from it)
04:40:54 <Workybob> unfortunately Kent is going increasingly towards stupid Java teaching
04:41:12 <Workybob> I don't get why people don't see that training Java monkies is the job of vocational colleges, not of unis
04:41:27 <p_l> Workybob: Tell that to my dept
04:41:48 <quicksilver> Workybob: we have some great vocational colleges in england. We call them universities :P
04:41:56 <elliotbay> It is what some students want
04:42:09 <blackh1> quicksilver: I am really enjoying myself, and there's nobody else around at this time!
04:42:14 <Workybob> quicksilver: heh, yeh
04:42:27 <Workybob> elliotbay: sure – and they should be going to vocational colleges
04:42:30 <Workybob> not to universities
04:42:39 <p_l> otoh, it appears that we have quite good AI staff in Aberdeen. Even if all this soft gets written in Java ;_;
04:42:43 <Workybob> if they want an academic qualification, they should expect to get academic training
04:43:14 <p_l> I wonder if switching from UK to Japan would be a good move
04:43:39 <Maddas> I don't even know how they pronounce Java down there :-)
04:43:52 <Maddas> never mind, it's probably further north than I am
04:44:15 <Maddas> Oh, not really.
04:45:03 <Maddas> Fine fine, that wasn't funny. :-)
04:45:51 <p_l> If I got the scholarship, I'd be facing restarting my studies in 2010 from first year. OTOH, I wouldn't have to worry about money and I'd get to learn another language better :)
04:46:40 <Maddas> Oh, you're seriously considering it, sorry for being flippant about it :-)
04:47:22 <elliotbay> Workybob: I can't say I really disagree with you.  I'm always amazed when I hear complaints that there's not enough practical, or C++ programming assignments.  Part of that stems from a differing philosophy on when you practice doing that kind of stuff.  While I fully intend to be paid to do programming or other computer science-related activity, this is one of the things I do for fun.  When I'm in class I want to learn primarily theory, but I fe
04:47:29 * Maddas wishes he had more energetically pursued the opportunity to do an exchange semester (or similar) in Japan
04:48:11 <p_l> elliotbay: The problem is when the assignment teaches bad practices. Which is the best description of my first assignment in "Foundations of Computing Science" subject.
04:48:12 <Maddas> elliotbay: Cut off after "but I fe"
04:48:40 <elliotbay> but I fear I may be in the minority there
04:49:24 <p_l> elliotbay: I think classes should primarily give you a proper understanding of the theory with some assignments to show you how to use them in practice
04:50:19 <elliotbay> right
04:50:24 <p_l> so that theory wouldn't go down the sewage pipe when you finish your degree :)
04:52:37 <p_l> Also, two things that should be taught as basic requirement should be close-to-metal assembler style programming and programming in one really high level language (Haskell, Lisp, etc. Prolog could be also nice)
04:52:50 <angelixd> quick question.  i'm still learning.... is instance what would be a 'subclassing' type relation in other programming languages
04:53:09 <angelixd> ?
04:53:23 <opqdonut> no
04:53:29 <opqdonut> there is no subtyping in haskell
04:53:49 <opqdonut> you can emulate something like it with type classes in some cases
04:54:35 <vegai> @hoogle [a] -> [a] -> Bool
04:54:35 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
04:54:35 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
04:54:35 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
04:54:38 <elliotbay> It's not creating an object out of a class, like when you hear instance in other languages, it's more like implementing an interface with your datatype
04:55:00 <vegai> hmm. Is there an (==) for lists that wouldn't care about ordering
04:55:19 <vegai> s/lists/association lists/
04:55:22 <quicksilver> vegai: either sort first, or insert into a Set first?
04:55:32 <quicksilver> insert into a Map first?
04:55:32 <vegai> @hoogle [(a,b)] -> [(a,b)] -> Bool
04:55:33 <lambdabot> No results found
04:55:37 <elliotbay> opqdonut: I found that overloading confusing at first as well
04:55:39 <vegai> I suppose
04:56:00 <opqdonut> yeah it's more like interfaces
04:56:00 <elliotbay> vegai: make one?
04:56:24 <blackh1> angelixd: 'instance' is not at all like subclassing in OO.
04:57:17 <quicksilver> angelixd: often you use ADTs instead of subtypes.
04:57:26 <quicksilver> data Shape = Circle | Rectangle | Triangle
04:57:32 <quicksilver> instead of Circle extends Shape.
04:57:42 <angelixd> aha
04:57:44 <quicksilver> obviously that's only one "level", not a hierarchy.
04:57:58 <quicksilver> but it turns out that hierarchies are actually not as useful as java programmers think ;)
04:58:00 <blackh1> angelixd: I lie. 'instance' is a bit like inheriting an interface in OO (i.e. a class with undefined methods)
04:58:05 <angelixd> i'm really just trying to figure out what instance means right now :-P  google isn't giving very many good answers
04:58:39 <vegai> hmm, crap. I was trying to fix the wrong test.
04:58:42 <quicksilver> angelixd: instance is about overloading.
04:58:51 <quicksilver> angelixd: (+) is overloaded, it works on multiple types.
04:58:58 <yakov> hey
04:59:00 <quicksilver> if you want (+) to work on your type, you add a Num instance.
04:59:06 <blackh1> angelixd: 'instance' means... a certain interface - defined by a type class = a set of function interfaces - can be used polymorphically with this datatype.
04:59:10 <quicksilver> that's the only purpose of typeclasses : overloading.
04:59:12 <vegai> looks like my technique of putting every test into one TestList and runTestTT is not the best idea
04:59:56 <mmorrow> yes! http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.66.9530
05:00:35 <mmorrow> <blackh1> mmorrow: I like that doubly linked list implementation a lot.
05:01:39 <angelixd> blackht1: alright, that's what i was thinking it meant, but wasn't sure.  are there any implicit definitions for these operators, or does the instance declaration simply state that there *should* be a definition?
05:01:44 <yakov> I can't understand why does ghc refuse to compile this http://hpaste.org/13947 with Vectorization error :/
05:01:57 <Workybob> elliotbay: you got chopped off at fe
05:02:05 <mmorrow> totally, and it's cool at both the level of how it works and the level of ideas => thinking about things from a different perspective to see what's right in front of you all along
05:02:08 <blackh1> angelixd: The instance definition is the bit where you supply the implementation.
05:02:34 <quicksilver> angelixd: (some operators are allowed to have implicit definitions on terms of each other, for convenience)
05:02:50 <quicksilver> angelixd: e.g. the default definition of (a /= b) as not (a == b)
05:02:52 <blackh1> angelixd: The 'type' definition is where you define the interface.  You can supply default implementations in the type.
05:02:57 <angelixd> ahh, okay then.  so it's like a template then, applied to data instead of function
05:03:23 <elliotbay> [04:48am] elliotbay: but I fear I may be in the minority there
05:03:27 <yakov> could anybody with DPH knowledge please take a look?
05:03:38 <tibbe> @src Data.List.foldl'
05:03:38 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
05:03:43 <tibbe> @src foldl'
05:03:44 <elliotbay> (in response to Workybob )
05:03:44 <lambdabot> foldl' f a []     = a
05:03:44 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
05:07:06 <blackh1> angelixd: The functions you define in an 'instance' declaration are each connected to the type through at least one argument (but that argument can be the return type).  So it's a bit more general than what OO does.
05:07:18 <yakov> ah.. there's no unary (-) in dph prelude..
05:10:23 <quicksilver> blackh1: and indeed the argument can be merely 'connected' rather than actually using the type.
05:10:35 <quicksilver> e.g. it might be Either (Tree a) [a]
05:10:41 <quicksilver> to give a rather ridiculous example.
05:13:54 <blackh1> quicksilver: Thanks for that. I have been using type classes a fair bit, so I must talk to you some more about your objections to the overuse of them.
05:15:00 <angelixd> thanks to the both of you; i'm just trying to figure it all out.  I've only been teaching myself for the past few weeks or so :-P
05:15:18 <blackh1> quicksilver: I'm using them to give fancy monads for a "read only context" and a "user is logged in context", etc.
05:15:52 <blackh1> quicksilver: The idea is that it prevents me making wrong assumptions about the context of the code, and it works *very* well, so I suppose I have to conclude that I'm not mis-using type classes.
05:15:59 <Ziriax> Hi all. I have a GHC API question. I have a list of [GHC.Module] of all the modules of all packages on my system, and now I want to get all the top level exported symbols of each module. I'm stuck here. Anybody has any ideas how to tackle that?
05:16:07 <quicksilver> blackh1: yeah, that's a good use.
05:16:14 <quicksilver> blackh1: type classes for capabilities I like.
05:16:43 <quicksilver> Ziriax: if nobody answers you here, try #ghc. I am unfamiliar with the GHC API myself.
05:17:10 <blackh1> angelixd: I hope you have fun.  I'm a recent convert.  I am still in the annoying-to-be-around stage. :)
05:17:12 <Workybob> @hoogle GHC.Module -> a
05:17:12 <lambdabot> Parse error:
05:17:12 <lambdabot>   --count=20 "GHC.Module -> a"
05:17:12 <lambdabot>                 ^
05:17:14 <Workybob> o.O
05:17:15 <Ziriax> oh thanks quicksilver. I did not know the existence of #ghc.
05:17:26 <Workybob> bad lambdabot!
05:19:47 <Ziriax> lambdabot: yeah it would be nice if Hoogle exposed the GHC API, but it does not yet... and it seems its not on hackage either, it comes with GHC. #ghc it will be. thx guys
05:21:07 <blackh1> quicksilver: These type classes turned into a crash course in type class subtleties and GHC extensions. At times I have been wondering if the complexity will get out of control but it hasn't done.
05:21:44 <quicksilver> blackh1: hmm. yes.
05:21:59 <blackh1> quicksilver: One thing I found was that I wondered "Hey - I wonder if it can do this? That'll never work!" then I find that it actually does work.
05:22:15 <elliotbay> Incidentally, when I do a google search for "hoogle", the top wikipedia article that comes up is on the Liger
05:22:19 <Workybob> @vixen did Ziriax just make a fool out of himself?
05:22:20 <lambdabot> who's to say?
05:22:43 <Ziriax> yes i did
05:22:47 <Workybob> @vixen you are!
05:22:48 <lambdabot> why do you look like ham?
05:23:19 <Ziriax> I hoped the lamdabot was clever enough to learn from feedback ;)
05:23:21 <Ziriax> stupid bot
05:23:23 <blackh1> quicksilver: I needed careful use of functional dependencies, etc, to make sure not too many types can't be inferred.  Also I had to learn how to use ScopedTypeVariables.  So I'm quite good at it now.  End of rant.
05:26:30 <pejo> Ziriax, I think you can install a local version of hoogle and index the ghc api. There's a console interface for hoogle.
05:27:50 <dmajnem2> where can I get pkg-config >=0.9.0 ?
05:27:50 <lambdabot> dmajnem2: You have 1 new message. '/msg lambdabot @messages' to read it.
05:27:50 <yakov> hm.. is it possible at all to use functions like "foo = 11" with DPH :/ i imported Standard Prelude as follows "import qualified Prelude" and imported dph prelude instead and GHC reports error with ``Tycon not vectorised: GHC.Integer.Internals.Integer''
05:29:53 <Ziriax> pejo: thanks, I'll take a look at that.
05:31:25 <pejo> dmajnem2, that's a package distributed with your distribution
05:32:08 <pejo> dmajnem2, (it's not haskell specific)
05:32:43 <dmajnem2> my distribution of what? ghc?
05:32:54 <pejo> dmajnem2, your linux distribution
05:33:17 <dmajnem2> hmm, I am on OS X
05:34:18 <dmajnem2> I think I found pkgconfig on ports, I'll try that
05:42:28 <pham> Ziriax: Hayoo doesn't seem to have the GHC API indexed either. What are you working on?
05:42:46 <pham> quicksilver: hey, how's it going?
05:43:02 * quicksilver is good, thanks.
05:43:12 <pham> (I am ac)
05:44:52 <Workybob> pham: we're needing to generate something not-unlike a hoogle/hayoo index actually, but were hoping not to rely on running haddoc on the sources
05:45:03 <Workybob> would be nicer to just query ghc about it
05:46:20 <quicksilver> Workybob is working on the same project as Ziriax ? or is this just a popular theme?
05:47:52 <Workybob> I'm not explicitly working on what he is, but he's made me interested now
05:48:18 <pham> what're you using the index for?
05:48:43 <int80_h> good morning!
05:48:57 <pham> goat moaning
05:49:03 <int80_h> that too
05:50:06 * Twey frowns.
05:50:57 <Twey> Oh, C# has generics
05:51:33 <Twey> Er, wrong channel :-P
05:51:41 <abbe> lol
05:51:42 <jonaskoelker> ;)
05:52:41 <jonaskoelker> I've rehashed an old theorem to show that nontrivial properties of functions which take a single argument and return another function can't be decided
05:52:45 <jonaskoelker> I call it "Rice and Curry"
05:53:56 * jonaskoelker :: (RandomGen g) => g -> [Pun]
05:54:33 <int80_h> there should be pun liscensing laws
05:54:47 <Workybob> pham: something not-unlike a Haskell IDE, but also not like it at the same time
05:55:52 <jonaskoelker> int80_h: you'd have the /.crowd screaming "Puns want to be free (as in talking beer)"
05:56:46 <int80_h> if the ./ crowd screams, and there's no one to listen, does it ... okay you know you the rest
05:56:47 <mercury^> Is there an explanation of how the old stream based io worked somewhere?
05:56:57 <jonaskoelker> :D
05:57:32 <quicksilver> int80_h: the problem is there is always someone to listen. The ./ crowd is self-sustaining, like a mould culture.
05:57:43 <quicksilver> it's not like it was in my day, sonny-me-lad.
05:57:52 <quicksilver> back when karma-whoring was new and exciting.
05:59:15 <elliotbay> The ./ crowd would be the ones that don't do anything and hang out at random parts of your paths, right?
05:59:27 <quicksilver> :P
05:59:33 <quicksilver> s/.///./g;
05:59:50 <opqdonut> syntax error etc ;)
05:59:56 <pozic> dons said something about HPC trace. What does it do?
06:03:32 <Robert___> thanks for the substitution quicksilver -- I'm part of a mould culture -- I thought I had no culture at all
06:03:59 <Robert___> :-)
06:04:01 <quicksilver> :)
06:04:53 <Robert___> I'm new again to IRC, not sure if this is good for me
06:05:11 <int80_h> well, the freenode network is okay
06:05:13 <drdozer> I've got a function that returns Maybe Double, and I want it to return Nothing if the value is infinite
06:05:22 <drdozer> is there a library function that would help me out?
06:05:30 <int80_h> but not all irc networks are okay
06:05:37 <opqdonut> :t isinfinite
06:05:39 <lambdabot> Not in scope: `isinfinite'
06:05:43 <Saizan_> ?ty isInfinity
06:05:44 <lambdabot> Not in scope: `isInfinity'
06:05:45 <opqdonut> :t isInfinite -- drooser
06:05:47 <lambdabot> forall a. (RealFloat a) => a -> Bool
06:05:52 <opqdonut> oops, drdozer
06:05:56 <opqdonut> nicely misread
06:06:00 <Robert___> But I can barely keep up with my rss feeds :-)
06:07:10 <tibbe> hmm, I feeling very slow today, what would a simple fold over a rose tree look like when both the leaves and the branches carry a value?
06:07:11 <drdozer> opqdonut: ah, great - I was obiously typing stupid things into hoogle
06:07:15 <pozic> Never mind, it's something that has bit-rotted already.
06:07:51 <Robert___> I'm a Java wannabe but I am beginning to find Haskell interesting
06:08:09 <pozic> tibbe: you need to use map to go over the children, the rest should be easy.
06:08:15 <int80_h> Robert___ : have you started a tutorial yet?
06:08:22 <tibbe> pozic: so not fold over the children?
06:08:34 <Saizan_> ?type Node
06:08:36 <lambdabot> forall a. a -> Forest a -> Tree a
06:08:43 <pozic> tibbe: no, the list is not an argument to one of your fold functions.
06:08:44 <Robert___> Looked over the 5 minute and 10 minute tutorial
06:08:57 <pozic> tibbe: or should I say yes then :)
06:09:18 <tibbe> pozic: I want an inorder walk
06:09:30 <tibbe> of all the values in the tree
06:09:30 <Saizan_> ?type let foldTree f (Node a forest) = f a (map (foldTree f) forest) in foldTree
06:09:32 <lambdabot> forall t b. (t -> [b] -> b) -> Tree t -> b
06:09:39 <Robert___> Not exactly committed yet!!!
06:09:52 <pozic> tibbe: inorder is not defined for a rose-tree, AFAIK.
06:10:04 <pozic> tibbe: since there is no notion of left and right.
06:10:09 <tibbe> Saizan_: so I don't want the folded function to get a list but instead I want it to be folded over all the values
06:10:11 <int80_h> Robert___ That's okay. It took the publishing of Real World Haskell for me to commit.
06:10:47 <tibbe> pozic: hmm, you're right
06:10:52 <pozic> int80_h: are you the blogger claiming GHC was the best compiler ever?
06:11:05 <quicksilver> no, that was intoverflow I think.
06:11:09 <elliotbay> I find that "programming in pure thought" thing to be pretty fallacious
06:11:41 <int80_h> Robert___ : and now that book has me doing this http://en.wikipedia.org/wiki/Graham_scan
06:11:41 <pozic> quicksilver: yes, but I didn't know they would all be here. It feels so crowded.
06:11:52 <int80_h> pozic: heh, no. not me
06:12:01 <Saizan_> tibbe: write a toList first then
06:12:15 <quicksilver> tibbe: You could define the inorder to say the value 'at' this node comes immediately after the median prime index of the subchildren
06:12:18 <tibbe> pozic: I actually wanted a preorder walk xD
06:12:21 <quicksilver> that should be suitably obscure.
06:12:43 <quicksilver> write a toList and then "factor out" the (:) and you have your fold!
06:12:51 <tibbe> Saizan_: I'm going to have a monadic fold so I don't want to do a toList first (although I could get a [m a])
06:13:11 <tibbe> quicksilver: I'll try that
06:13:23 <Saizan_> btw, Data.Tree is Traversable
06:13:32 <Saizan_> so there should be a fold somewhere?
06:13:41 <pozic> Is what he wants still called a fold?
06:13:41 <tibbe> Saizan_: I'm actually traversing the filesystem
06:13:48 <quicksilver> Saizan_: well the fold is in Foldable ;)
06:13:51 <pozic> AFAIK, not.
06:13:54 <quicksilver> (which is a subclass of Traversable)
06:14:06 <quicksilver> by which I mean superclass.
06:14:10 <quicksilver> damn antonyms.
06:14:53 <pozic> tibbe: hmm, also pre-order doesn't make sense, since the order in which you visit things depends on your arguments.
06:15:07 <Saizan_> pozic: it's a fold if you consider the tree as a "stream"
06:15:08 * roconnor prefers Monoid to Appendable
06:15:30 <pozic> Saizan_: ?
06:15:37 <Saizan_> who proposed Appendable?
06:15:37 <tibbe> pozic: what do you mean?
06:16:10 <vincenz> some blogpost
06:16:12 <quicksilver> maybe roconnor is just talking about '-able' words in general.
06:16:13 <tibbe> so I have data Tree a = Leaf a | Branch a [Tree a]
06:16:24 <vincenz> check reddit
06:16:31 <vincenz> hey tibbe
06:16:32 <pozic> tibbe: pre-order is when in an imperative language you first do something with the parent before you do something with the children. But that distinction doesn't exist in Haskell.
06:16:39 <tibbe> and want foldTree :: (a -> b -> a) -> a -> Tree b -> a
06:16:43 <pozic> tibbe: unless you are writing a foldM.
06:16:52 <tibbe> pozic: I am writing foldM
06:17:03 <pozic> tibbe: you never said so :)
06:17:21 <vincenz> tibbe, odd definition
06:17:25 <roconnor> Saizan_: what vincenz  said.  Some blog post
06:17:27 <tibbe> pozic: I was trying to simplify ;)
06:17:38 <pozic> tibbe: in this case it didn't help.
06:17:42 <tibbe> vincenz: it's a directory hierarchy
06:17:43 <Saizan_> pozic: if the "folding" function is (a -> b -> a) then that distiction is still valid.
06:17:47 <tibbe> pozic: right
06:18:10 <quicksilver> pozic: well a preorder toList gets the elements in a different order to a postorder toList
06:18:16 <Saizan_> and that's what i was referring to with stream
06:18:17 <pozic> Saizan_: but it depends on the argument then, and is not part of the fold itself.
06:18:19 <quicksilver> so it's observable even by pure code.
06:18:33 <vincenz> tibbe, i meant the function ,the first argument seems like an odd version of listfold
06:18:49 <PSJ> I'm looking for a function to represent an Int32 as a 4-element Word8 array, something like Int32 -> [Word8]
06:18:50 <Saizan_> pozic: no, it depends on how you feed the values in the tree to that function
06:18:55 <vincenz> besides, use a for input, more legible
06:19:08 <pozic> Saizan_: example?
06:19:12 <tibbe> you could define f seed xs = foldl f' seed xs
06:19:28 <tibbe> where f' :: a -> b -> a
06:19:47 <tibbe> Imagine you want to sum all the elements in a rose tree
06:19:51 <Saizan_> pozic: what quicksilver said, with "foldTree (:) []" you get differently sorted lists depending on how you define the fold
06:20:05 <quicksilver> pozic: well suppose your tree is A (B (C D) E)
06:20:11 <quicksilver> where I hope the notation is obvious.
06:20:19 <quicksilver> preorder gives you [A,B,C,D,E]
06:20:29 <quicksilver> postorde is [C,D,B,E,A]
06:20:38 <quicksilver> and inorder is [C,B,D,A,E]
06:20:52 <tibbe> quicksilver: right
06:21:03 <quicksilver> so that's an observable difference for any "non-commutative" folded function
06:21:43 <quicksilver> when you write your Data.Foldable instance for a type
06:21:48 <quicksilver> you are effectively choosing an order.
06:21:56 <quicksilver> this can be an abstraction leak.
06:24:23 <PSJ> Can anyone point me in the direction of a Int32 -> [Word8] function? I'm looking to represent an Int as a 4-element Word8 array
06:25:02 <roconnor> PSJ big or little endian
06:25:11 <PSJ> either way is fine
06:25:13 <quicksilver> \x -> [fromIntegral ((x `shiftR` 24) .&. 0xFF), fromIntegral ((x `shiftR` 16) .&. 0xFF), ....]
06:25:32 <Olathe> You don't need the ands.
06:25:38 <roconnor> PSJ should be something in Data.Binary
06:25:43 <pozic> quicksilver: that would only make a difference for pre-and postorder.
06:25:50 <PSJ> thanks guys, I'll try playing with that
06:25:52 <pozic> quicksilver: not for in-order.
06:26:10 <quicksilver> pozic: well, pre-order would give a different answer than in-order.
06:26:12 <quicksilver> that's my point.
06:26:20 <quicksilver> Suppose my non-commutative operation is (/)
06:26:32 <quicksilver> A/B/C/D/E is a different number from C/B/D/A/E
06:26:33 <Saizan_> that blog post doesn't even get the definition of Monoid right
06:26:48 <quicksilver> Olathe: hmm, good point
06:28:25 <loadquo> Do I need to import something to be able to specify Infinity for a number?
06:28:38 <Saizan_> no, you can't
06:28:52 <Saizan_> Infinity is just how they get shown
06:28:57 <Saizan_> > 1/0
06:28:59 <lambdabot>   Infinity
06:29:10 <tromp__> >-1/0
06:29:17 <loadquo> I want a base case in a recursion that is smaller than everything possible, any hints
06:29:19 <pozic> quicksilver: and how do you enforce one or the other, just by swapping the arguments?
06:29:21 <tromp__> > -1/0
06:29:23 <lambdabot>   -Infinity
06:29:27 <Saizan_> > read "Infinity" :: Double -- does this work?
06:29:29 <lambdabot>   Infinity
06:29:36 <tromp__> > minBound::Int
06:29:38 <lambdabot>   -9223372036854775808
06:29:43 <quicksilver> > read "Infinity" :: Rational
06:29:45 <lambdabot>   * Exception: Prelude.read: no parse
06:29:48 <nikki93> Hey guys!
06:29:55 <nikki93> I was introduced to haskell by xmonad.
06:29:57 <tromp__> > minBound::Double
06:29:59 <lambdabot>       No instance for (Bounded Double)
06:29:59 <lambdabot>        arising from a use of `minBound...
06:30:01 <quicksilver> > toRational (1/0)
06:30:01 <nikki93> I'm learning Haskell, is it worth learning it? I'm reading the 'real world haskell' book, its a nice language, but its very different from waht I already know (C/C++ et all). It IS usefull right?
06:30:04 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
06:30:04 <pozic> > -Infinity < -Infinity
06:30:06 <lambdabot>   Not in scope: data constructor `Infinity'Not in scope: data constructor `In...
06:30:08 <mercury^> @let infinity = 1/0
06:30:11 <lambdabot>  Defined.
06:30:12 <mercury^> > infinity
06:30:13 <lambdabot>       Ambiguous occurrence `infinity'
06:30:14 <lambdabot>      It could refer to either `L.infini...
06:30:21 <mercury^> :/
06:30:21 <pozic> > -infinity < -infinity
06:30:22 <lambdabot>       Ambiguous occurrence `infinity'
06:30:22 <lambdabot>      It could refer to either `L.infini...
06:30:27 <quicksilver> nikki93: evidently the authors of xmonad found it useful to write a window manager in
06:30:38 <quicksilver> nikki93: plenty of other people find it useful to write other things in :)
06:30:48 <loadquo> @let infin = 1/0
06:30:48 <nikki93> Is it good for embedding/extending C++ applications.
06:30:50 <lambdabot>  Defined.
06:30:55 <mercury^> > infin
06:30:57 <lambdabot>   Infinity
06:31:00 <mercury^> good
06:31:02 <nikki93> I write games as a hobby, using it for scripting is something I was thinking of.
06:31:16 <mercury^> > -infin
06:31:18 <lambdabot>   -Infinity
06:31:20 <loadquo> >  0 < - infin
06:31:21 <Axman6> i think it'd be easier to do it the other way
06:31:22 <lambdabot>   False
06:31:27 <loadquo> >  0 <  infin
06:31:27 <araujo> nikki93, Haskell is very bad .... it makes you hating other languages ... so be careful
06:31:29 <lambdabot>   True
06:31:48 <nikki93> Is it object-oriented, like call methods on objects, classes and stuff?
06:32:08 <Axman6> you can do OO like things quite easily, but it's not what you
06:32:08 <quicksilver> nikki93: no.
06:32:12 <Axman6> you'd usually do
06:32:14 <nikki93> Because, I saw some simple functional programming examples (quicksort etc.), and its pretty awesome (and maths like).
06:32:27 <loadquo> Thanks #haskell
06:32:27 <mercury^> nikki93: To make game object scripting easy in haskell you have to provide a FRP library.
06:32:28 <blackh1> nikki93: Haskell works well with C++ - it has a really great "foreign function interface"
06:32:48 <nikki93> Ok, I'm off, gonna read the book more.
06:32:56 <nikki93> Got less time, hafta study after (got exam). :(
06:33:13 <mercury^> blackh1: does it have specific C++ support?
06:33:20 <quicksilver> No.
06:33:22 <mercury^> Thought you had to extern "C" stuff.
06:33:27 <quicksilver> There isn't a standard C++ ABI
06:33:40 <quicksilver> well for many years there wasn't, there are some emerging standards now
06:33:48 <quicksilver> but still very fragile w.r.t compiler versions.
06:33:49 <blackh1> mercury^: No, but I've been writing wrappers and that works fine.
06:38:33 <cjs> So the documentation for "seq" says it evaluates its first argument to head normal form; is this then fully evaluated, as opposed to weak head normal form?
06:38:45 <Olathe> How do you get maxBound of the type of an input ?
06:39:41 <blackh1> cjs: No - not fully evaluated.
06:39:43 <Olathe> > let m x = 0*x + maxBound in m (5::Int32) -- Is there a better way ?
06:39:45 <lambdabot>   2147483647
06:41:05 <blackh1> cjs: You need to do it yourself by applying seq over your data structure. Control.Parallel.Strategies can help. Others may know better ways.
06:41:36 <cjs> Ah. Darn.
06:41:43 <int80_h> :t take
06:41:44 <lambdabot> forall a. Int -> [a] -> [a]
06:42:30 <cjs> Well, back to NFData, then.
06:42:58 <Olathe> > let bounds x = head [(minBound, maxBound), (x, x)] in bounds (5::Int32)
06:43:00 <lambdabot>   (-2147483648,2147483647)
06:43:25 <Olathe> > let bounds :: a -> (a, a); bounds _ = (minBound, maxBound) in bounds (5::Int32)
06:43:26 <lambdabot>       Could not deduce (Bounded a) from the context ()
06:43:26 <lambdabot>        arising from a ...
06:43:34 <Olathe> Yes, it's impossible to deduce.
06:44:05 <Workybob> Olathe: I'm not sure what you're getting at with that?
06:44:50 <Axman6> > let bounds :: Bounded a => a -> (a, a); bounds _ = (minBound, maxBound) in bounds (5::Int32)
06:44:52 <lambdabot>   (-2147483648,2147483647)
06:44:59 <Axman6> how's that Olathe?
06:46:47 <Olathe> Yes, that's fine enough :)
06:47:01 <Olathe> > let range :: (Integral a, Bounded a) => a -> Integer; range x = fromIntegral max - fromIntegral min where (min, max) = bounds x; bounds :: (Bounded a) => a -> (a, a); bounds _ = (minBound, maxBound) in range (5::Int32)
06:47:03 <lambdabot>   4294967295
06:47:20 <Olathe> Is there a nicer way than that to get range ?
06:47:45 <dpratt71> another newbie question about Monads: comparing 'fmap' and '>>=', the container and...uh...projection (?) arguments are in opposite order. Is there a good reason for that or is it just coincidence?
06:48:14 <Olathe> dpratt71: You can use =<<
06:48:16 <Ferdirand> you could always use (<<=) instead :)
06:48:25 <dpratt71> oh
06:48:29 * drdozer is happy - has a working chemical reaction stochastic simulator
06:48:38 <daf> @src (=<<)
06:48:38 <lambdabot> f =<< x = x >>= f
06:48:45 <blackh1> drdozer: Great!!
06:48:50 <daf> my favourite definition
06:49:01 <opqdonut> :)
06:50:14 <drdozer> blackh1: It doesn't seem to understand that chemicals can't go negative in concentration :)
06:50:32 <drdozer> just adding in the 'block reactions with insufficient reactants' logic
06:50:37 <quicksilver> Olathe: maxBound `asTypeOf` x
06:50:44 <dpratt71> the reason I asked is because I thought it might make the transformation from 'fmap' to '>>=' a teensy bit more obvious
06:50:45 <quicksilver> or, with ScopedTypeVariables
06:51:17 <blackh1> drdozer: I don't know what you're talking about, but I am impressed. I have a working web app!
06:51:27 <quicksilver> minmaxs :: Bounded a => a -> (a,a); minmaxs x = (minBound,maxBound)
06:51:38 <quicksilver> no need for ScopedTypeVars I was confused.
06:51:41 <quicksilver> just a type sig is enough.
06:53:36 <cjs> So let's see if my thinking is correct on this. Even if I make something an instance of NFData, and then apply rnf to it, it still won't be evaluated until I do I/O with something in that data structure, right? Though the first time I do I/O with anything in that data structure, because I'm going "through" the rnf, the entire data structure will be evaluated, right?
06:54:17 <Axman6> has anyone here made an instance of MArray (STUArray s) x (ST s) before? i'm wondering who to ask (tomorrow, i'm about to sleep), so that i can make an STUArray for my datatype, which is essencially B Double Double Double Double Double Double Double
06:55:20 <quicksilver> cjs: IO is not relevant.
06:55:46 <blackh1> cjs: I am struggling a bit here because it's 4 AM: My understanding is that if you apply rnf, .. then at the point where the application thereof gets evaluated, the whole thing gets evaluated.
06:55:47 <quicksilver> cjs: it will be all evaluated as soon as you 'force' it, by, for example, using 'case' to check the constructor
06:56:00 <quicksilver> it's ultimately case which drives haskell forcing
06:56:07 <quicksilver> (and function defintions which are a sugar for case)
06:56:09 <int-e> all force comes from IO ;)
06:56:10 <Axman6> i had a look at the code for the instances there already are, and they're basically all one byte of less in size, none of them have more complex constructors
06:56:12 <cjs> Ah!
06:56:31 <quicksilver> int-e: only because the RTS defines a complete program to have IO type.
06:56:38 <blackh1> Good night all.
06:56:43 <quicksilver> int-e: if I use ghci, I could define a complete program to have any showable type.
06:56:48 <quicksilver> say.
06:56:57 <int-e> quicksilver: I know. And ghci cheats. :)
06:56:58 <cjs> blackh1: That's my understanding, too.
06:57:07 <mercury^> int-e: do you know how the stream based io worked?
06:57:14 <int-e> mercury^: yes.
06:57:22 <mercury^> int-e: can you quickly explain it to me.
06:57:34 <mercury^> I've tried to find information on it, but it's really hard. :)
06:57:53 <int-e> @type interact
06:57:55 <lambdabot> (String -> String) -> IO ()
06:58:04 <Olathe> @index Int32
06:58:04 <lambdabot> Data.Int, Foreign
06:58:09 <mercury^> Hmm, isn't that a bit limited?
06:58:14 <cjs> quicksilver: Yes, but what ever causes the case to get evaluated?
06:59:02 <int-e> mercury^: I guess I don't know it well enough to explain it. The basic idea is that of interact, in a form of main :: [Request] -> [Reply]
06:59:20 <Saizan_> no
06:59:22 <int-e> gah
06:59:26 <int-e> [Reply] -> [Request]
06:59:33 <int-e> stupid :)
07:00:05 <mercury^> So main gets answers and asks more in return?
07:00:13 <mercury^> Like an annoying child? :D
07:00:27 <cjs> Anyway, the issue I'm struggling with is a typical one: I've got several threads doing various
07:00:28 <int-e> yes :) ... and it may even ask questions without being prompted first
07:00:33 <int-e> very annoying little brat
07:00:36 <cjs> things, and I want to evenly distribute the load between them.
07:01:17 <cjs> But I suspect I'm getting thunks put in my channels between the threads, since almost all of the work appears to be happening on just one core.
07:01:36 <mercury^> int-e: I'm asking because the application abstraction in singularity seems somewhat similar to me.
07:02:12 <mercury^> There is more structure in it, but the basic idea is the same.
07:03:14 <Saizan_> cjs: you should do something like: rnf x `seq` writeChan c x
07:03:29 <cjs> Ah!
07:03:59 <int80_h> what's the difference between calcDirectionList :: [PointXY] -> [Direction] and
07:03:59 <int80_h> wait, I pasted that wrong
07:03:59 <int80_h> let me start over
07:04:08 <int80_h> what's the difference between calcDirectionList :: [PointXY] -> Maybe [Direction] and
07:04:29 <mercury^> Anyway, off to "Husserl und die sprachanalytische Philosophie".
07:04:41 <int80_h> oh wait, nevermind. I figured out the answer by asking the question.
07:05:35 <Axman6> man, german must be so painful to have to write out
07:06:18 <chessguy_work> @seen wchogg
07:06:18 <lambdabot> wchogg is in #haskell. I last heard wchogg speak 16h 39m 39s ago.
07:06:38 <int80_h> Axman6: try reading technical German. ugh
07:07:10 <Axman6> i'd prefer not to, i don't like killing that many trees
07:07:23 <int80_h> hey, it's either you or them
07:08:41 <Saizan_> Axman6: it seems verbose, but they actually stick many words together to form one :)
07:09:26 <Axman6> still, it seems like it'd be a pain to write (and spell i guess)
07:11:13 <int80_h> seems verbose? Germans love verbosity.
07:11:53 <chessguy_work> byorgey++
07:12:01 <chessguy_work> awesome job with the Data.Split library
07:12:11 <byorgey> chessguy_work: thanks, glad you like it =)
07:12:33 <chessguy_work> very clean and well-put-together
07:13:23 <Axman6> Data.Split being that list splitting functions library?
07:13:43 <pejo> Axman, I'm not german, but don't they spell most stuff like it's pronounced?
07:13:51 <chessguy_work> Axman6, yeah, it's actually Data.List.Split
07:13:59 <chessguy_work> http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html
07:14:02 <Axman6> pejo: yeah, i was going to say that too
07:15:01 <Axman6> byorgey: ah, yes that sure is a nice looking library :)
07:15:15 <byorgey> thanks =)
07:15:20 <Axman6> chunk is something i'm glad is in there
07:15:22 <chessguy_work> byorgey, my only suggestion would be to break it up into another file or 2
07:16:01 <chessguy_work> that documentation page seems a bit unweildy
07:16:04 <chessguy_work> unwieldy
07:16:06 <chessguy_work> whatever
07:16:10 <byorgey> chessguy_work: what things would you separate out?
07:16:29 <byorgey> seems like a relatively short documentation page to me =)
07:16:42 <chessguy_work> i would move all the stuff for the internal combinator library off of the front page
07:17:11 <phercek1> is it possible to load one more module to ghci without unloading the modules I have already loaded? ... something like "load in addition to what I have already loaded"
07:17:26 <chessguy_work> but that's just me -- i'm a "big picture" kind of thinker
07:18:22 <byorgey> chessguy_work: ok, thanks for the suggestion, I'll consider it when I do another release
07:18:38 <chessguy_work> sure, just an idea, no big deal
07:18:41 <byorgey> phercek1: if it's an installed library module, you can do  :m +Module
07:18:53 <int80_h> how do I include a type in a where clause?
07:19:10 <phercek1> byorgey: it is not installed, it is just one more file on my disk
07:19:17 <int80_h> someone mentioned it, and I didn't write it down
07:19:23 <Axman6> where f :: a -> b\n f x = b
07:19:39 <byorgey> phercek1: if it's a module you've written, it's kind of weird.  the only way I've figured out how to load multiple ones is to first load a module that depends on all the ones you want to load, and then you can use :m +Module to add the ones you want
07:19:40 <Axman6> where \n is a new line...
07:20:00 <chessguy_work> Axman6, except...the type has to match ;)
07:20:17 <Axman6> hmm?
07:20:26 <chessguy_work> just teasing
07:20:43 <chessguy_work> actually, i guess if b = undefined, that does work
07:20:44 <Axman6> your types have to match :(
07:20:49 <phercek1> byorgey: ok; it is a pity it is not simpler, thanks
07:21:05 <Axman6> well, i was assuming a -> b would be replaced with the correct type signature :P
07:21:07 <chessguy_work> @type let f x = b; b = undefined in f
07:21:09 <lambdabot> forall t a. t -> a
07:21:17 <chessguy_work> there ya go
07:21:25 <chessguy_work> chessguy_work--
07:21:48 <elliotbay> Breakfast time
07:22:21 <bombshelter13> Hey guys, does anyone know where I can find some good examples of basic uses of the IO monad? I've found some showing printing single things, but I'm trying to procude a main that prints a list of numbers, one per line, with no luck so far...
07:22:49 <int80_h> bomshelter13: check out Real World Haskell online
07:23:14 <int80_h> I would also suspect All About Monads would have what you're looking for.
07:23:33 <Saizan_> bombshelter13: e.g. "mapM_ (\n -> putStrLn (show n)) [1..10]"
07:23:41 <int-e> if you want a recipe, main = mapM_ print [1..10]  (mapM_ comes from Control.Monad)
07:23:45 <Twey> print =putStrLn
07:23:47 <Twey> Er
07:23:51 <Twey> print = putStrLn . show
07:23:59 <int-e> @src print
07:23:59 <lambdabot> print x = putStrLn (show x)
07:24:00 <Saizan_> ?src print
07:24:00 <lambdabot> print x = putStrLn (show x)
07:24:13 * Saizan_ couldn't remember if it was Ln or not
07:24:20 <Twey> Yeah, 'tis :)
07:24:33 <bombshelter13> int80_h: i'll take a look in those, thanks... figured from the sounds of the name that 'All About' might be a bit in depth for a beginner, but I'll look at both.
07:24:39 <Axman6> bombshelter13: forM_ nums print whould work
07:24:49 <int-e> @src forM_
07:24:49 <lambdabot> forM_ = flip mapM_
07:24:54 <Twey> Is forM_ just flip map... oh
07:24:55 <Twey> :-P
07:24:58 <Axman6> :t forM_ [1..10] print
07:24:59 <lambdabot> IO ()
07:25:19 * Twey thinks forM_ is redundantish
07:25:29 <chessguy_work> byorgey, i really like your idea of having a typeclass, but only really exposing it via combinators. very interesting
07:25:32 <SamB> Twey: 'tis!
07:25:34 <Twey> It's not as if 'flip mapM_' is hard to type.
07:25:42 <Axman6> Twey: yeah, but it's useful being able to write a do expression at the end of the function, forM_ list $ \x -> do ...
07:25:49 <int-e> Twey: forM_ [1..100] $ \i -> do ...
07:25:53 <int-e> Twey: is quite idiomatic
07:26:04 <Twey> But you could just flip mapM_ list $ ...
07:26:10 <Axman6> ha, beelsebob'd!
07:26:26 <Twey> *blink* *blink*
07:26:26 <int-e> yes. you could. but it doesn't read as nicely, imho
07:26:30 <drdozer> redGreen: internal error: schedule: invalid what_next field
07:26:30 <drdozer>     (GHC version 6.10.1 for x86_64_unknown_linux)
07:26:30 <drdozer>     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
07:26:30 <drdozer> Aborted
07:26:30 <Axman6> i think it's easier to read
07:26:32 <sw17ch> Has some one written a DSL for a JavaScript'ed environment?
07:26:34 <Twey> Fair enough
07:26:35 <drdozer> that's scary
07:26:48 <Twey> drdozer: Very
07:26:55 * Twey cowers in fear.
07:27:00 <Axman6> for each thing in this list do this
07:27:18 <SamB> drdozer: I've seen someone complain of that before
07:27:33 <Twey> So is there a `for = flip map`?
07:27:42 <Twey> @index for
07:27:43 <lambdabot> bzzt
07:27:44 <Axman6> @hoogle for
07:27:44 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
07:27:44 <lambdabot> Data.Foldable for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
07:27:44 <lambdabot> Test.QuickCheck forAll :: (Show a, Testable b) => Gen a -> (a -> b) -> Property
07:27:49 <Twey> Aha
07:28:13 <Axman6> the ones i know of are forM and forM_
07:28:23 <Axman6> @sec mapM
07:28:23 <lambdabot> mapM f as = sequence (map f as)
07:28:30 <Axman6> @src mapM_
07:28:30 <lambdabot> mapM_ f as = sequence_ (map f as)
07:28:44 <Axman6> @src sequence_
07:28:44 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
07:29:05 <Twey> Nice
07:29:12 <SamB> @src sequence
07:29:13 <lambdabot> sequence []     = return []
07:29:13 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:29:13 <lambdabot> --OR
07:29:13 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
07:29:30 <Twey> @src foldr1
07:29:31 <lambdabot> foldr1 _ [x]    = x
07:29:31 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
07:29:31 <lambdabot> foldr1 _ []     = undefined
07:29:57 <Twey> You'd think `sequence [] = []; sequence xs = foldr1 (>>) xs`
07:30:17 <SamB> Twey: Um, no!
07:30:24 <Twey> No?
07:30:27 <Axman6> sequence [] = return [] no?
07:30:28 <Twey> Oh, it has to be m a
07:30:31 <Twey> Yeah
07:30:35 <SamB> :t foldr1 (>>)
07:30:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m a
07:30:48 <Twey> Oh
07:30:49 <Twey> Right
07:30:50 <int-e> drdozer: pretty :)
07:30:51 <Saizan_> you want m [a]
07:30:52 <Twey> Duh :-D
07:30:55 <PeakerWork> @src sequence
07:30:55 <lambdabot> sequence []     = return []
07:30:55 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:30:55 <lambdabot> --OR
07:30:55 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
07:30:57 <Twey> Yeah, makes sense now.
07:31:03 <Axman6> ah, not return []
07:31:14 <PeakerWork> @src Foldable
07:31:15 <lambdabot> Source not found. :(
07:31:25 <PeakerWork> Why is Foldable useful? Why not just "convert to list"?
07:31:28 <Twey> PeakerWork: Foldable is a constructor, no?
07:31:38 <PeakerWork> I mean the type-class
07:31:40 <Twey> @info Foldable
07:31:41 <lambdabot> Foldable
07:31:45 <PeakerWork> not sure if there's a constructor too
07:31:46 <Twey> ... OK
07:31:55 <Twey> Not helpful, \b :-P
07:31:56 <SamB> @info purple-people-eaters
07:31:57 <lambdabot> purple - people - eaters
07:31:57 <bombshelter13> Where can I learn about the functions available for controlling the way in which numbers are printed?
07:32:02 <Twey> Hahaha
07:32:07 <SamB> hmm.
07:32:11 <SamB> what IS it ?
07:32:15 <Twey> <3 purple-people eaters
07:32:23 <Twey> bombshelter13: Text.Printf perhaps?
07:32:27 <chessguy_work> @hoogle Foldable
07:32:27 <lambdabot> module Data.Foldable
07:32:27 <lambdabot> Data.Foldable class Foldable t
07:32:34 <bombshelter13> Twey: Thanks, getting the docs for that now :)
07:32:35 <wchogg> PeakerWork : why convert to a list if all you need is a foldr?
07:32:59 <Twey> bombshelter13: There's a lot of type magic, but it works basically like C printf() :)
07:33:13 <PeakerWork> wchogg: well, foldr and [] seem to be expressively equivalent?
07:33:14 <Axman6> @where printf
07:33:14 <lambdabot> I know nothing about printf.
07:33:49 <Axman6> @help
07:33:49 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:33:50 <SamB_XP> > printf "But does it segfault so well? %s" :: String
07:33:51 <lambdabot>   "But does it segfault so well? * Exception: Printf.printf: argument list en...
07:33:54 <Axman6> @help list
07:33:54 <lambdabot> list [module|command]
07:33:55 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
07:33:57 <vegai> Axman6: Text.Printf?
07:34:15 <Axman6> vegai: yeah, i'm wanting to stick the link in lambdabot
07:34:27 <Axman6> @whe
07:34:27 <lambdabot> Maybe you meant: where where+ ghc thx what wn
07:34:36 <Axman6> @where+ printf http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Printf.html
07:34:37 <lambdabot> Nice!
07:34:44 <Axman6> @where printf
07:34:44 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Printf.html
07:34:45 <vegai> Ah, indeed
07:34:51 <SamB_XP> @thx
07:34:51 <lambdabot> you are welcome
07:34:58 <SamB_XP> @ghc
07:34:58 <lambdabot> ghc says: Precedence out of range
07:35:07 <SamB_XP> @ghc
07:35:07 <lambdabot> ghc says: Exception: kevind stub
07:35:11 <SamB_XP> @ghc
07:35:12 <lambdabot> ghc says: Illegal polymorphic type signature in pattern
07:35:21 <wchogg> PeakerWork :  it seems much cleaner to me to implement the natural fold on a data structure rather than worrying about how to convert it to a list.  If you know how to convert it to a list, you're already implementing a specialized version of fold
07:35:51 <BMeph> wchogg, PeakerWork: Which is how Foldable works. :)
07:36:05 <wchogg> BMeph : yes, that's my point.
07:37:30 <dnul_> it is possible to do a permutation function like this:?  permute xs =[ x:(permute (xs\\[x]) )| x<-xs]
07:38:00 <dnul_> ah , i've just realized it isnt
07:38:30 <opqdonut> it is
07:38:47 <opqdonut> well the xs \\ [x]fails for duplicate elements maybe
07:38:57 <opqdonut> but something akin to that is the idiomatic functional solution
07:39:12 <Axman6> > [1,2,3,4,5,1,2,3,4,5]\\[1,2,3]
07:39:14 <lambdabot>   [4,5,1,2,3,4,5]
07:39:23 <PeakerWork> @type (\\)
07:39:24 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
07:39:26 <opqdonut> dnul_: but you probably want to use the list monad
07:39:47 <dnul_> opqdonut: dont know monads, can you explain it briefly for this example..
07:39:47 <PeakerWork> is it a filter notElem on all of the rhs?
07:39:53 <opqdonut> or do something like [ x:per | x<-xs, per<-permute (xs\\[x]) ]
07:39:55 <PeakerWork> oh wait, it isn't
07:40:05 <PeakerWork> @src (\\)
07:40:05 <lambdabot> (\\) = foldl (flip delete)
07:40:07 <opqdonut> dnul_: what I pasted is practically identical to the list-monad version
07:40:08 <Axman6> there's a nice version of permutations that uses zip (inits xs) (tails xs)
07:40:22 <opqdonut> Axman6: yeah, that
07:40:59 <opqdonut> that zip is just an easy way to implement select
07:41:14 <Axman6> perms [] = [[]]
07:41:15 <Axman6> perms (x:xs) = [ p ++ [x] ++ s | xs' <- perms xs, (p, s) <- zip (inits xs') (tails xs')]
07:41:16 <opqdonut> select :: [a] -> [(a,[a])]
07:41:47 <dnul_> opqdonut: works great, thx
07:41:59 <Axman6> ok, sleep time. night all
07:42:08 <opqdonut> dnul_: do you understand it
07:42:57 <dnul_> opqdonut: i think so, it is similar to what i proposed
07:43:03 <pozic> Is there a module somewhere which simply exports the union of all library Monads?
07:43:06 <dnul_> opqdonut: where is the monad in this?
07:43:29 <opqdonut> perms [] = []; perms xs = do (x,rest) <- select xs; per <- perms rest; return x:per
07:43:34 <opqdonut> that's the monadic version
07:43:55 <opqdonut> the select step just does the x<-xs and xs\\[x] things
07:44:07 <opqdonut> the point is that the list monad implement nondeterminism
07:44:11 <opqdonut> pursuing all choices at once
07:44:17 <opqdonut> and that's what you
07:44:23 <opqdonut> 're doing with that comprehension too
07:45:15 <pozic> Or how can I ignore all the Warnings identifier is being exported by module Foo and Bar?
07:45:21 <opqdonut> first, get all choices for x
07:45:31 <opqdonut> then get all choices for permutations of the rest of the list
07:45:32 <pozic> For only this module.
07:46:27 <dnul_> opqdonut: x<-... implies a monad ?
07:47:02 <opqdonut> dnul_: well it is used in the list comprehension syntax and the do-syntax
07:47:09 <opqdonut> do-syntax means monad
07:47:29 <dnul_> opqdonut: list comprehension is not a monad?
07:47:30 <opqdonut> and every list comprehension is writeable as a simple do-expression in the list-monad
07:47:30 <wolverian> I can't compile mueval on ghc 6.10. tried the darcs and hackage versions both; darcs version wants Control.OldException and cabal doesn't find it, because base is hidden (I assume it means base 4), and the hackage version fails because Language.Haskell.Interpreter.GHC doesn't export newSession. any ideas?
07:47:43 <opqdonut> but no, there's nothing monadic as such in a comprehension
07:48:00 <wolverian> (base 4 is hidden because cabal selects base 3, not because of my action)
07:48:01 <dnul_> opqdonut: ok , i used to see it as a for loop
07:48:27 <dcoutts_> wolverian: if the darcs version needs Control.OldException then it should also require base 4, and then of course cabal will pick base 4
07:48:42 <dcoutts_> wolverian: ie that's a bug in the darcs version of mueval
07:49:49 <dnul_> opqdonut: the list comprehension..
07:49:49 <opqdonut> dnul_: well that's kinda what it is, too
07:49:50 <opqdonut> and when you have multiple <-, it's a nested loop
07:49:51 <dnul_> opqdonut: right
07:49:52 <dnul_> opqdonut: thx
07:49:52 <opqdonut> originally, in haskell 1.4, there were no list comprehensions
07:49:53 <opqdonut> what looked like list comprehensions were monad comprehensions
07:49:53 <opqdonut> they were polymorphic over MonadPlus
07:49:53 <wolverian> ...and we miss them
07:49:53 <opqdonut> yes we do
07:50:03 <wolverian> dcoutts_, thanks. I'll try editing the .cabal file
07:50:41 <dcoutts_> if you were using the darcs version of cabal-install you could do it from the command line using --constraint='base >= 4'
07:51:03 <dcoutts_> in the mean time hacking the .cabal file is the way forward
07:51:36 <wolverian> WORKED.
07:51:44 <wolverian> caps. :)
07:52:49 <bombshelter13> Hmm, why does 'printf "%.2f\n" pi
07:52:56 <bombshelter13> Seem to work in GHCI but not HUGs?
07:53:08 <bombshelter13> Hugs gives 'Unresolved overloading', whereas GHCI runs it.
07:53:32 <Saizan_> Hugs doesn't have extended defaulting, probably
07:53:37 <Saizan_> give it a type signature
07:54:02 <PeakerWork> @type do 5
07:54:03 <lambdabot> forall (t :: * -> *) t1. (Num (t t1)) => t t1
07:54:18 <PeakerWork> it seems that "do" implies a container type, but not Monad, which is weird
07:54:43 <PeakerWork> its not just syntax sugar
07:54:45 <PeakerWork> @undo do 5
07:54:45 <lambdabot> 5
07:54:47 <PeakerWork> @type 5
07:54:48 <lambdabot> forall t. (Num t) => t
07:54:51 <dcoutts_> PeakerWork: yes, I think they're going to change it, so that the particular corner case is just syntactic sugar.
07:55:02 <PeakerWork> dcoutts_: Why isn't it syntactic sugar?
07:55:09 <PeakerWork> dcoutts_: in the general case?
07:55:37 <dcoutts_> PeakerWork: ghc does not desugar before typechecking, it type checks the original form
07:56:00 <PeakerWork> why?
07:56:02 <dcoutts_> PeakerWork: so given that's the case, you can see how that corner case could end up being handled oddly
07:56:09 <dcoutts_> PeakerWork: much much better error messages
07:56:46 <dcoutts_> PeakerWork: think what it would be like if type errors referred to the desugared code instead
07:56:46 <SamB_XP> anyway, it's not as if "do 5" is actually usefull ;-P
07:56:49 <SamB_XP> it's just a nit
07:56:50 <PeakerWork> it means the type-checker needs to know a much larger/more complicated language?
07:57:00 <dcoutts_> PeakerWork: yes and no
07:57:09 <SamB_XP> dcoutts: mostly yes
07:57:18 <PeakerWork> dcoutts_: Only need to have the desugared form point to the code points in the original form?
07:57:30 <SamB_XP> PeakerWork: that's not so easy though
07:57:39 <PeakerWork> SamB_XP: why not?
07:57:45 <pejo> Peaker, the more you transform your input, the harder it is to generate a good message for type errors.
07:57:56 <SamB_XP> well, if it is so easy, come on over to #lhc-compiler and help us out ;-P
07:58:29 <dcoutts_> PeakerWork: the core type checking infrastructure is not more complicated, but the part that traverses the AST does have a lot more cases
07:58:40 <SamB_XP> dcoutts: true
07:58:59 <SamB_XP> the monad wouldn't need any more state or anything
07:59:09 <PeakerWork> SamB_XP: how does lhc compare to ghc in performance and extensions' support?
07:59:18 <SamB_XP> extensions ?
07:59:26 <SamB_XP> I'm struggling to get typeclasses working
07:59:34 <gwern> PeakerWork: 5x slower, I read
07:59:41 <SamB_XP> they had the appearance of working *most* of the time before
07:59:46 * dcoutts_ wishes SamB_XP the best of luck
08:00:01 <SamB_XP> but Kleisli threw it for a loop
08:01:04 <dcoutts_> SamB_XP: I've been following the lhc blog but I don't understand the points about C/LLVM and GC etc
08:01:11 <dcoutts_> more detail on that would be interesting
08:01:14 <SamB_XP> dcoutts: I don't quite either
08:01:54 <PeakerWork> lhc's goal is to compile Haskell+extensions to LLVM?
08:02:14 <SamB_XP> PeakerWork: no
08:02:20 <dcoutts_> PeakerWork: currently it's what jhc does, which is to generate ANSI C
08:02:52 <SamB_XP> of course, we can only support 3/4 of the FFI constructs with ANSI C ...
08:03:12 <dcoutts_> SamB_XP: use libffi, you can do the last 1/4
08:03:18 <sw17ch> When the RTS is linked in with a GHC program, is the whole RTS globbed in irregardless of which pieces are needed?
08:03:20 <fasta> Why does lhc exist?
08:03:37 <fasta> I mean jhc was just a fun project to learn Haskell.
08:03:55 <sw17ch> ...which turned into a darn good haskell compiler :)
08:04:01 <dcoutts_> SamB_XP: so I understand the problem with generating C and GC. The C compiler will not tell you which registers it stashed variables into, so accurate GC is impossible. I thought LLVM might though. Perhaps that's what turns out not to be the case.
08:04:10 <SamB_XP> sw17ch: except for the part where it didn't work right
08:04:16 <sw17ch> heheheh
08:04:20 <sw17ch> yes, there is that :)
08:04:32 <fasta> I only heard stories of people that managed to get one module working on JHC. :)
08:04:37 <sw17ch> I want to see a C -> Haskell compiler
08:04:47 <dcoutts_> sw17ch: I don't think there are many bits of the RTS that you end up not needing, any in particular you were thinking of?
08:05:00 <fasta> But lhc builds here from cabal. Nice.
08:05:06 <sw17ch> dcoutts_: well, that's my impression also... i just keep hoping for ways to make it smaller :)
08:05:22 <cads> of the dependentantly typed proof assistant languages, which one work together nicest with haskell?
08:05:42 <dcoutts_> sw17ch: it would be smaller if you eliminated concurrency and used a simpler GC algorithm.
08:05:43 <sw17ch> actually, as a side note... a friend of mine took my VPN project and ran one of those utilities that compresses the EXE and decompresses it at run time...
08:05:52 <cads> I've read about coq being used with haskell for example, and I know that some of the dependant type programming languages are coded in haskell
08:06:00 <byorgey> cads: AIUI, Coq can actually generate Haskell code
08:06:01 <sw17ch> it pulled it from 4MB to 386K
08:06:07 <byorgey> cads: Agda is written in Haskell
08:06:10 <sw17ch> with hardly a difference in startup time
08:06:13 <sw17ch> (1 or 2 ms?)
08:06:15 <cads> right, adga, and cayenne
08:06:18 <cads> and others
08:06:23 <fasta> cads: Coq has actual users, so I would pick that one.
08:06:39 <sw17ch> dcoutts_: there really isn't a good way aroudn it is there
08:06:44 <SamB_XP> agda 2 is active as well
08:07:02 <dcoutts_> sw17ch: shared libs would help
08:07:25 <dcoutts_> sw17ch: it doesn't reduce the size of stuff in memory or disk, but at least you only ever get one copy
08:07:41 <cads> is agda more of a general programming language, where coq is a automated proof framework?
08:07:42 <sw17ch> =)
08:08:09 <fasta> SamB_XP: --build-hl=file.cabal  Build hakell library from given library description file <- from --help
08:08:19 <byorgey> cads: yes, although you can sort of use Agda as a proof assistant, and Coq has a built-in programming language.
08:08:30 <dcoutts_> SamB_XP: if you're going to write a code gen for lhc, perhaps you could share it with ghc's NCG
08:08:42 <SamB_XP> fasta: that doesn't quite work off of real cabal files
08:09:00 <fasta> SamB_XP: I was referring to the spelling error.
08:09:25 <dcoutts_> SamB_XP: it's basically CMM -> native code, I don't think you have to follow that many ghc conventions
08:09:36 <byorgey> cads: check out http://adam.chlipala.net/cpdt
08:18:49 * byorgey bakes lambdacream puffs
08:20:06 * vixey makes a pot of lambda-tea ..
08:28:19 <fasta> blas has been updated, so it compiles :)
08:28:38 <byorgey> has anyone read Paul Tarau's paper "Isomorphic Data Encodings in Haskell and their Generalization to Hylomorphisms on Hereditarily Finite Data Types"?
08:28:55 <byorgey> sounds tasty, but it's rather long
08:29:03 <byorgey> I wondered if it's worth taking the time to read
08:29:16 <fasta> byorgey: it sounds like that title was auto-generated by one of those bots.
08:29:23 <vixey> afaict dylomorphisms are useless
08:29:25 <byorgey> it does, doesn't it. =)
08:30:14 <byorgey> dylomorphisms = transforming data types into Bob Dylan songs?
08:30:17 <vixey> I just looked at the abstract: "The paper covers 47 data types and, through the use of the embedded combinator language, provides 2162 distinct bijective transformations between them." .. so you weren't kidding about it being long
08:31:01 <byorgey> yeah, it's like 85 pages or so.
08:31:17 <byorgey> well, it looks interesting from glancing through it, so I'll at least give it a try
08:31:23 <quicksilver> byorgey: even the title takes a while to read!+-
08:32:03 <byorgey> ah, apparently he's written a 5-page summary version
08:32:20 <tromp__> does that include basic data types like Bool, Int, Char?
08:32:39 <tromp__> don't see how you could have bijections with those...
08:33:28 <byorgey> tromp__: I think it's talking more about data *structures*
08:33:32 <byorgey> I'm not sure yet though
08:33:58 <tromp__> so type constructors?
08:34:30 * loadquo_ is considering stopping using the ubuntu haskell package....
08:34:43 <loadquo_> Any ideas what I should go to?
08:34:51 <byorgey> maybe. looking through it I see binary trees, hypergraphs, permutations, multisets...
08:34:59 <dons> for those who didn't see before, http://www.reddit.com/r/programming/comments/7pyjm/serious_net_interoperability_for_haskell_has/
08:35:05 <dons> we got a .NET interop from sigbjorn
08:35:34 <tromp__> wonder how you can have bijection between binary tree and permutation
08:35:44 <tromp__> seem to have different cardinalities...
08:36:23 <MichaelGG> dons ooh looks nice
08:36:33 <dons> yeah, its a big deal.
08:36:44 <byorgey> tromp__: aren't they both countable sets?
08:36:49 <dons> sigbjorn is the most productive programmer i've ever met.
08:37:42 <MichaelGG> The docs seem to indicate that theres only some modules available, but it also says it allows full access?
08:38:09 <tromp__> yes, but im imagined bijection between n-node tree and n-permutatiuon
08:38:29 <byorgey> tromp__: oh, yeah, that wouldn't work.
08:39:05 <tromp__> otherwise you only need bijection with natural numbers
08:39:32 <tromp__> and use numbers as intermediary between any two types
08:40:14 <byorgey> tromp__: I think that's actually exactly what he does.
08:40:27 <byorgey> but with clever ways to automatically construct the bijections with the natural numbers.
08:41:11 <byorgey> but I should actually read the paper instead of guessing what it's about by flipping through it rapidly =)
08:42:07 <vixey> every data type like
08:42:24 <vixey> data F a b c ... = C1 p1 p2 ... | ...
08:42:35 <vixey> with p1 either a, b, c, or (F a b c ...)
08:42:43 <vixey> can be bijected into N, right?
08:42:50 <tromp__> of course
08:43:21 <vixey> (**every element of that build _inductively_)
08:44:02 <tromp__> because of bijections N <-> N x N, and N <-> N + N (direct sum)
08:44:19 <vixey> I suppose the recursive part could be any permutation of a b c ..., but what nested recursion?
08:45:18 <vixey> how about allowing any (F p1 p2 ... :: *) as long as each p_i is bijectionble to N
08:46:06 <opqdonut> vixey: well i'd think it can be done to any recursive datatype
08:46:17 * ronwalf needs a state tutorial, plus maybe a state-type hider
08:46:25 <opqdonut> as there are only numerably many values
08:46:34 <vixey> opqdonut, as long as it doesn't include (->) though
08:46:44 <vixey> I think (->) breaks througuh the continuum
08:47:12 <rwbarton> It breaks through a lot.  data Weird a = Blah (Weird a -> Bool)
08:47:29 <quicksilver> dons: who needs type safety, let's just use strings for types :)
08:47:38 <vixey> what's so weird about that rwbarton?
08:48:01 <rwbarton> Well if -> is supposed to be all functions, there is no set X with an isomorphism X ~ 2^X
08:48:11 <rwbarton> (I guess I didn't need the 'a' parameter)
08:48:12 <opqdonut> yep
08:48:22 * vixey pattern matches and thinks about Scott Domains..
08:49:33 <quicksilver> rwbarton: or just untyped LC, data F = F (F -> F)
08:50:08 <opqdonut> although LC-terms can be mapped onto the naturals
08:50:09 <vixey> given Blah f, is it true that  exists b, forall weird,  f weird = k
08:50:13 <vixey> oops
08:50:15 <vixey> given Blah f, is it true that  exists b, forall weird,  f weird = b***
08:50:18 <quicksilver> rwbarton: the only set such that X ~ X^X is 1, and yet that's not the only model of lambda calculus.
08:50:34 <quicksilver> opqdonut: sure, but that's not obvious from the data definition.
08:50:37 <vixey> opqdonut, the syntax can, but the semantics couldn't
08:50:46 <opqdonut> vixey: hmm, semantics as how?
08:50:48 <quicksilver> opqdonut: (it's obvious because we have studied then and know a lot about them etc)
08:51:02 <vixey> I think I read about Bohm trees or something, which is lambda calculus and has /some/ link with the reals
08:51:05 <opqdonut> quicksilver: well lambda terms are finite trees
08:51:11 <quicksilver> opqdonut: quite.
08:51:23 <quicksilver> opqdonut: but data F = F (F -> F) doesn't teach you about lambda terms.
08:51:35 <quicksilver> you only know that because, well, we know about lambda terms :)
08:51:36 <Olathe> [Blah (const True), Blah (const False), Blah (\f -> not.f)]
08:51:43 <vixey> does anyone know the link with Böhm trees?
08:52:04 <Olathe> @hoogle Bool -> Bool
08:52:05 <lambdabot> Prelude not :: Bool -> Bool
08:52:05 <lambdabot> Data.Bool not :: Bool -> Bool
08:52:05 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
08:52:10 <vixey> Olathe, but not . f is still the constant function, because f is constant right?
08:52:14 <vixey> Just thinking about it inductively
08:52:31 <Olathe> vixey: Well, it depends on what f is.
08:52:43 <Olathe> f can be either of const True or const False.
08:52:46 * vixey thinks by induction hypotheses, f is const True or const False
08:52:55 <Olathe> So, not.f isn't constant.
08:53:02 <vixey> huh??
08:53:11 <vixey> I followed the same reasoning but I get a different conclusion :p
08:53:17 <Olathe> > not True
08:53:19 <lambdabot>   False
08:53:20 <Olathe> > not False
08:53:22 <lambdabot>   True
08:53:31 <Olathe> Ahh, I see.
08:53:32 <vixey> > id True
08:53:34 <lambdabot>   True
08:53:34 <opqdonut> quicksilver: ah I see now
08:53:36 <Olathe> Yes, not.f is constant.
08:54:26 <Olathe> So, I think there are four possible instances of Weird: Blah (const True), Blah (const False), Blah id, Blah not.
08:54:45 <Olathe> Hmm...
08:54:52 <rwbarton> But then...
08:55:01 <Olathe> Actually, a bit different.
08:55:05 <vixey> no I don't think id typechecks
08:55:18 <vixey> I suppose Weird is a bit weird.
08:55:27 <Olathe> So, I think there are four possible instances of Weird: Blah (const True), Blah (const False), Blah (\(Blah f) -> f), Blah (\(Blah f) -> not.f).
08:55:46 <Olathe> I think that'll work.
08:56:08 <rwbarton> If you can distinguish all of those, then surely you can write some more values of type Weird...
08:56:15 <vixey> um I don't think that typechecks
08:56:22 <rwbarton> And yeah, it still doesn't type check
08:56:31 <vixey> Blah :: (Weird -> Bool) -> Weird -- isn't it?
08:56:52 <Olathe> Yes.
08:56:55 <vixey> so Blah f :: Weird, f :: Weird -> Bool
08:57:20 <Olathe> Right.
08:57:21 <vixey> somehow, you can always get another  Weird -> Bool  out of a Weird
08:57:58 <qjg94hg> is there a function like 'words' that lets me choose at what character to split instead of ' ' (space)?
08:58:03 <vixey> oh no I'm wrong about that last one
08:58:51 <rwbarton> qjg94hg: Not in the standard libraries
08:59:02 <rwbarton> qjg94hg: there's a package called 'split' that has such a function.
08:59:48 <qjg94hg> k, i'll look that up.
09:01:58 <Saizan_> ?hackage split
09:01:59 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split
09:05:51 <iskaldur> are there any good uses of monads in imperative languages (or any language that allows you to modify state)? or are they really only for pure functional langs like haskell?
09:06:20 <quicksilver> osfameron wrote something about using them in perl.
09:06:29 <BMeph> iskaldur: There are Nullable types in Java.
09:06:32 <quicksilver> you can imagine using the list monad (to accumulate multiple return values)
09:06:47 <vixey> iskaldur, it is also not uncommon that people reify monads in Scheme and Ocaml
09:06:52 <quicksilver> and ErrorT is really another way of looking at exception handling.
09:07:03 <PeakerWork> iskaldur: Monads are an abstract concept. Surely you could find how much existing code in various languages maps to that concept somehow.. List comprehensions in Python, for exmaple
09:07:20 <PeakerWork> quicksilver: exceptions can be of an open type, though?
09:08:34 <iskaldur> is there a simple example? i was thinking of using the list monad to accumulate multiple return values, but the person i was talking with wasn't convinced that it was *that* much of a benefit (e.g., it's a little messy, but you can just keep a temporary working list that you store all the un-concatMap-ed values)
09:08:58 <quicksilver> iskaldur: I don't have a simple example to point you at
09:09:03 <quicksilver> I wonder where osfameron's blog is
09:09:08 <iskaldur> BMeph: how do nullable types in Java relate to monads?
09:09:21 <gio123> is there relation between  Warren's Abstract Machine and java virtual machine
09:09:22 <gio123> ?
09:09:26 <osfameron> quicksilver: http://greenokapi.net/blog/
09:09:52 <iskaldur> i think i found the perl monad link: http://osfameron.vox.com/library/post/monads-in-perl-take-1.html
09:10:02 <MichaelGG> F# makes a lot of nice use of monads for things like async
09:10:29 <ski_> Olathe : neither `Blah (\f -> not.f)' nor `Blah (\(Blah f) -> not.f)' typechecks ..
09:10:48 <quicksilver> iskaldur: that's the osfameron I was talking about, yes ;)
09:10:49 <ski_> `not.f' is not of type `Bool'
09:11:09 <BMeph> iskaldur: Nullable works like Maybe.
09:11:36 <quicksilver> ski_: not (f (Blah f))
09:11:38 <quicksilver> I guess.
09:11:43 <ski_> (however, `Blah (\(Blah f) -> f (Blah (not . f)))' would typecheck)
09:11:51 <quicksilver> hmm
09:11:57 <ski_> that too, yes
09:12:28 <iskaldur> BMeph: ah yes yes. i guess i'm asking: is there a good reason/simple example why adding monads to java would be useful, beyond java's current capabilities?
09:13:06 <quicksilver> osfameron: it seems unlikely that the positioning of your headline on your blog is as you desired it.
09:13:16 <gwern> full monads imply the ability to do continuations do they not?
09:13:24 <iskaldur> or to take a maybe better example/language :): a reason to add it to ruby, which already supports some functional language stuff like continuations?
09:13:27 <MichaelGG> iskaldur, sure, look at what MS did with LINQ
09:14:21 <iskaldur> hm, not familiar with linq, i'll take a look
09:15:18 <osfameron> quicksilver: the post headline or the blog title?  The title is certainly out, as is the navigation bar.  I really really hate css...
09:15:59 <quicksilver> osfameron: blog title.
09:16:09 <quicksilver> osfameron: you need to borrow, steal, adopt, or coerce, a CSS monkey.
09:16:54 <iskaldur> are there any good descriptions of haskell used in a large/medium company?
09:17:15 <osfameron> quicksilver: yeah I think you're right.  I could probably do it myself... except I might give up in disgust and use a <table>...
09:17:59 <quicksilver> @go haskellwiki haskell in industry
09:18:02 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_industry
09:18:02 <lambdabot> Title: Haskell in industry - HaskellWiki
09:18:08 <quicksilver> iskaldur: take a look there
09:18:32 <MichaelGG> iskaldur, http://lambda-the-ultimate.org/node/978
09:19:27 <iskaldur> cool, thanks
09:19:48 <MichaelGG> he has some other papers where he tlaks alot about VB and monads
09:19:53 <iskaldur> michaelgg: ah, ive been meaning to look at that fp with bananas paper :)
09:19:56 <MichaelGG> unfortunately , MS research's site went all web 2.0
09:20:03 <MichaelGG> and broke pretty much everything for some dumbass reason
09:20:43 <JoshTriplett> I want to parse webpages.  I use TagSoup to handle real-world "HTML", but I need to deal with similarly bad usage of character sets.  I'd like to have a function from a (lazy, preferably) bytestring to a String, which auto-detects the character set and converts to a normal Unicode String, without ever throwing an error.  Any suggestions?
09:21:20 <JoshTriplett> I don't really care *that* much if it gets non-ASCII characters right, because I don't need those to parse webpages, though I'd like it to try.
09:21:34 <dons> JoshTriplett: use utf8-string and catch the errors?
09:22:18 <JoshTriplett> dons: AFAICT utf8-string only handles UTF-8.  If that handled all the pages on the web, I wouldn't have this problem. ;)
09:22:36 <dons> right. so you might want to try one of the more exotic encoding libraries on hackage
09:22:39 <quicksilver> it's a bit difficult to do this lazily.
09:22:42 <dons> or write a binding to some foreign library
09:22:51 <quicksilver> files can have an initial segment which is valid in many encodings
09:23:01 <quicksilver> before it comes to the point where it's obvious what the encoding really was.
09:23:04 <JoshTriplett> quicksilver: I don't care about laziness here.  Parsing the whole file would probably work fine.
09:23:13 <quicksilver> then I think I suggest "iconv"
09:23:17 <JoshTriplett> quicksilver: I'd like laziness if I can have it, though. :)
09:23:23 <quicksilver> and try a few encodings in a chosen order
09:23:29 <quicksilver> falling back when they fail
09:28:33 <chillitom> What provides `Control.Parallel.Strategies'?
09:28:56 <quicksilver> chowmeined: parallel-1.1.0.1
09:29:02 <quicksilver> chillitom: sorry, that was for you
09:29:10 <telexicon> WHAT
09:29:12 <quicksilver> chillitom: look at the right-hand column in http://www.haskell.org/ghc/dist/current/docs/libraries/index.html
09:29:14 <chillitom> thanks
09:29:17 <drdozer> are there RPMs for ghc for redhat?
09:29:21 <quicksilver> yes.
09:33:24 <iskaldur> for random numbers, is 'next' the same as the 'random' function, but for Ints only (instead of any instance of Random a)?
09:34:06 <drdozer> installing on redhat isn't going smoothly for us
09:34:10 <quicksilver> @index next
09:34:10 <lambdabot> System.Random
09:34:13 <quicksilver> :t next
09:34:15 <lambdabot> forall g. (RandomGen g) => g -> (Int, g)
09:34:40 <drdozer> is there a 'lift' from `g -> (a, g)` into MonadRandom?
09:34:47 <quicksilver> iskaldur: No, not really.
09:34:54 <quicksilver> iskaldur: it might have some partial range
09:35:04 <quicksilver> it's an internal function to be used to build the other functions.
09:36:03 <quicksilver> drdozer: there can't be, because MonadRandom doesn't necessarily use a gen 'g'.
09:36:08 <quicksilver> drdozer: that's not part of its interface.
09:36:18 <quicksilver> (maybe that's a design mistake? but there it is)
09:36:25 <drdozer> quicksilver: ah!
09:36:46 <quicksilver> IO is an instance of MonadRandom in a way which wouldn't support that
09:36:50 <quicksilver> sort of, anyway
09:36:59 <quicksilver> setStdGen exists, so you could actually do it.
09:37:07 <quicksilver> but setStdGen might not exist, in principle ;)
09:37:10 <quicksilver> if you see my point.
09:37:34 <pk>  > (*2) `fmap . fmap` [(2,2)]
09:37:38 <quicksilver> more seriously, you could link a MonadRandom to a real RNG
09:37:40 <pk> > (*2) `fmap . fmap` [(2,2)]
09:37:41 <lambdabot>   <no location info>: parse error on input `.'
09:37:44 <ronwalf> Anyone know of a good example using Control.Monad.St (or .State)?
09:37:45 <quicksilver> instead of a pseudo.
09:38:02 <quicksilver> ronwalf: important distinction: those are very different.
09:38:12 <iskaldur> is there a difference b/w newStdGen and getStdGen?
09:38:18 <pk> > (*2) `(fmap . fmap)` [(2,2)]
09:38:20 <lambdabot>   <no location info>: parse error on input `('
09:38:24 <vixey> wait a second..
09:38:31 <vixey> so type theory actually can prove it's own consistency
09:38:32 <quicksilver> pk: you can't `` anything except a single smbol
09:39:21 <pk> quicksilver, k
09:40:22 <Deewiant> quicksilver: is there a particular reason for that?
09:40:27 <quicksilver> > let inc = do { s <- get; put (s+1); return s } in runState (mapM (\x -> do n <- inc; return (n,x)) "abcde") 0
09:40:29 <lambdabot>   ([(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e')],5)
09:40:44 <quicksilver> ronwalf: there is a fairly simple example of state
09:40:56 <quicksilver> (keeping an incrementing counter in state and using that to give unique labels to elements in a list)
09:41:06 <quicksilver> Deewiant: no, not really. They wouldn't nest cleanly though.
09:41:33 <rwbarton> Do the <^ ^> operators nest well?
09:41:33 <quicksilver> Deewiant: they're part of the lexical syntax rather than the expression syntax.
09:41:39 <quicksilver> rwbarton: I wonder that.
09:41:44 <quicksilver> rwbarton: I don't know the answer ;)
09:41:58 <quicksilver> rwbarton: with explicit parens they do, though
09:42:05 <quicksilver> so they become the <^( )^> operators.
09:42:22 <vixey> haskell needs bracketfix
09:42:30 <quicksilver> yes.
09:42:45 <vixey> outfix
09:42:50 <gwern> curios. anyone know why a cabal-install of gitit might fail with '<command line>: unknown package: containers-0.2.0.1
09:42:52 <rwbarton> I wanted to use curly quotes for <^ and ^>, but ghc wouldn't let me
09:42:55 <gwern> when a runhaskell succeeds?
09:43:38 <pk> is it possible to import a module qualified, exept for some functions ?
09:43:39 <dcoutts_> gwern: do you have multiple versions of containers registered? dangling dependency perhaps?
09:44:02 <gwern> dcoutts_: ghc-pkg only knows containers-0.2.0.0
09:44:32 <gwern> (ok! time to try out filestore-enabled gitit!)
09:44:33 <rwbarton> pk: I'm not sure exactly what you want to do, but probably "yes"
09:44:43 <dcoutts_> gwern: well there you go then, some of the existing code (.o / .hi files) were built against containers-0.2.0.1
09:44:47 <dcoutts_> gwern: clean first
09:44:57 <edwardk> @seen drmaciver
09:44:57 <lambdabot> drmaciver is in #scala. I last heard drmaciver speak 1h 36m 54s ago.
09:45:00 <ronwalf> quicksilver: Where are 'get' and 'put' defined?
09:45:07 <gwern> dcoutts_: it was clean
09:45:20 <gwern> this was a fresh branch gotten by git; no dist/
09:45:42 <ronwalf> ah, monad.state.class
09:45:59 <dcoutts_> gwern: it can be in a dependency, to the best of my knowledge ghc only gives that message when it finds a .hi file that references a non-existant package
09:46:05 <gwern> bah, what is this post-update shell script gitit needs and installs as a data-file >.<
09:46:08 <sleven> erh haskell is so hard
09:46:17 <sleven> how do I do a listocmprehension that makes  amatrix?
09:46:33 <gwern> dcoutts_: hm, but no idea how to find it? also, why would runhaskell not find tht .hi and cabal-install would?
09:46:38 <pk> rwbarton: G.$= is ugly
09:46:39 <sleven> makeMatrix 4 5 -> [[0,0,0,0,5]*4]
09:46:56 <rwbarton> pk: Right, so import Whatever ($=); import qualified Whatever as G
09:47:09 <dcoutts_> gwern: picking different dependencies perhaps?
09:47:11 <pk> rwbarton: thx
09:47:41 <quicksilver> ronwalf: was that a useful example?
09:47:55 <ronwalf> quicksilver: I think so
09:48:08 <ronwalf> quicksilver: We'll see if this helps simplify my code!
09:48:10 <quicksilver> rwbarton: I woudl have thought curly quotes would work.
09:48:25 <ronwalf> quicksilver: I still need some sort of state-type hiding mechanism
09:48:33 <quicksilver> rwbarton: failing that what about 'french quotes', << and >> but closer together than that.
09:48:41 <ronwalf> Maybe universal quantification is enough...
09:48:49 <quicksilver> ronwalf: ST gives you the ability to create unknown new chunks of state
09:48:51 <rwbarton> quicksilver: It just doesn't like them as valid characters
09:48:52 <quicksilver> :t newSTRef
09:48:53 <lambdabot> forall a s. a -> ST s (STRef s a)
09:48:56 <edwardk> pk: i always wished that you could do namespace lookups by postfixing when they involved infix operators, something like $=_G which looks subscriptish to anyone that uses latex ;)
09:48:57 <rwbarton> quicksilver: that wouldn't be bad
09:49:16 <quicksilver> edwardk: awesome idea.
09:49:22 <ronwalf> quicksilver: Besides lazy and strict, what's the difference between State and ST ?
09:49:28 <quicksilver> ronwalf: everything.
09:49:39 <quicksilver> State is just a simple threaded variable.
09:49:52 <quicksilver> ST is a heap that lets you create new bundles of state of chosen types
09:49:56 <quicksilver> :t newSTRef
09:49:58 <lambdabot> forall a s. a -> ST s (STRef s a)
09:50:01 <rwbarton> , let a ‘ b = a + b in 3 ‘ 4
09:50:05 <quicksilver> forall a!
09:50:07 <lunabot>  luna: lexical error at character '\8216'
09:50:09 <quicksilver> any type
09:50:21 <ronwalf> Hm, that's probably closer to what I need
09:50:36 <gwern> (bah, an error in gitit)
09:50:37 <rwbarton> , let a « b = a + b in 3 « 4
09:50:38 * ronwalf has ugly continuations wrapped in funny data types right now
09:50:39 <lunabot>  luna: lexical error at character '\171'
09:50:44 <gwern> 'Server error: UnknownError "Error in darcs query contents:\n\ndarcs failed: Couldn't match pattern \"hash HEAD\"\n"'
09:50:47 <gwern> so close!
09:50:57 <rwbarton> , let a “ b = a + b in a “ b
09:50:59 <lunabot>  luna: lexical error at character '\8220'
09:51:27 <ronwalf> ie, newtype Matcher p a = Matcher (Hit p a -> (Matcher p a, [Hit p a]))
09:52:19 <gwern> (yowch, "HEAD" is all over the bleeding place in Gitit.hs. this people is why you develop against abstractions!)
09:52:58 <rwbarton> , let a ¿ b = a + b in 3 ¿ 4
09:53:00 <lunabot>  luna: lexical error at character '\191'
09:53:09 <rwbarton> disaster
09:55:49 <rwbarton> , let a ⟨ b = a + b in 3 ⟨ 4
09:55:52 <lunabot>  luna: lexical error at character '\10216'
09:56:45 <twanvl> > let a ¿ b = a + b in 3 ¿ 4
09:56:47 <lambdabot>   7
09:57:08 <rwbarton> Huh
09:58:06 <rwbarton> , let ç = 12 in ç
09:58:10 <lunabot>  12
09:59:26 <vixey> , reverse "~ 斯科特域 ~"
09:59:28 <lunabot>  "~ \22495\29305\31185\26031 ~"
10:04:19 <Olathe> > say.reverse $ "~ 斯科特域 ~"
10:04:21 <lambdabot>   ~ 域特科斯 ~
10:04:43 <Gracenotes> eek, "flying spaghetti monster" and "finite state machine" have the same acronym
10:05:05 <Badger> One might become exceedingly confused.
10:05:08 <lament> what does this tell you about the nature of the universe?
10:05:34 <Badger> Gracenotes: funnily enough, that's also the acronym of Micronesia.
10:05:35 <sleven> how do I do a listcomprehension that creates a matrix? like makeMatrix :: Int -> Int -> [[a]] ?
10:05:43 <Olathe> The universe has the same acronym as a string in a regular language ?
10:06:22 <vixey> sleven what's a?
10:06:24 <Gracenotes> hm.
10:06:31 <Olathe> > [[x*y] | x <- [1..5], y <- [1..5]]
10:06:33 <lambdabot>   [[1],[2],[3],[4],[5],[2],[4],[6],[8],[10],[3],[6],[9],[12],[15],[4],[8],[12...
10:06:37 <pk> @hoohl a->IORef a
10:06:38 <lambdabot> Data.IORef newIORef :: a -> IO (IORef a)
10:06:38 <lambdabot> Prelude id :: a -> a
10:06:38 <lambdabot> Data.Function id :: a -> a
10:06:38 <Olathe> Heh.
10:07:10 <Olathe> > [x*y | y <- [1..5]] | x <- [1..5]]
10:07:12 <lambdabot>   <no location info>: parse error on input `|'
10:07:20 <Olathe> > [[x*y | y <- [1..5]] | x <- [1..5]]
10:07:22 <lambdabot>   [[1,2,3,4,5],[2,4,6,8,10],[3,6,9,12,15],[4,8,12,16,20],[5,10,15,20,25]]
10:07:24 <pk> no function a -> IORef a ?
10:07:24 <Gracenotes> sleven: containing which elements?
10:07:52 <pk> looks pure to me
10:07:57 <Gracenotes> you have to invoke IO to get an IORef, I'd think
10:08:03 <Olathe> > map (\x -> map (\y -> x*y) [1..5]) [1..5]
10:08:05 <lambdabot>   [[1,2,3,4,5],[2,4,6,8,10],[3,6,9,12,15],[4,8,12,16,20],[5,10,15,20,25]]
10:08:07 <pk> ok
10:09:22 <Gracenotes> Olathe: it's concatMap... without the concat!
10:09:38 <Gracenotes> :>
10:09:47 <Olathe> Of course.
10:09:52 <Olathe> No cats in this recipe.
10:09:59 <vixey> concatMap id
10:10:23 <Olathe> Chili concat.
10:13:57 <rwbarton> pk: it can't be pure, because it has to create a "new" IORef that doesn't share storage with any existing one
10:16:56 <wli> map (flip map [1..5] . (*)) [1..5]
10:22:28 <roconnor> First they came for Monoid
10:22:32 <lilac> @instances-importing Data.IORef Eq
10:22:33 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, IORef a, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
10:22:34 <roconnor> then they came for Vector
10:22:54 <roconnor> Finally they took away Integer, finding "Couting Thing" more intuative.
10:23:02 <roconnor> CountingThing
10:24:17 <lilac> roconnor: and there were no monoids left to build the collection of people who would speak up against that?
10:24:26 <roconnor> yes
10:25:09 <roconnor> Or perhaps
10:26:10 <roconnor> They take our Monoid, and we fall back.  Then they take our VectorSpace, and we fall back.  Now they've come for Integer!  No more!  The line must be drawn HERE!
10:27:19 <gwern> hm, but Counting Thing sounds like Nat
10:27:22 <dons> quick, let's sneak some prepomorphisms into the prelude!!
10:27:31 <gwern> how does one count -1000 in things?
10:27:52 <rwbarton> gwern: that's true
10:27:52 <roconnor> gwern: in the new world order, there will be no negeative numbers
10:27:54 <gwern> dons: I initially read that as 'pedomorphisms'
10:27:57 <rwbarton> gwern: you'd have to use a SignModifier
10:28:26 <roconnor> gwern: negative numbers are just too confusing for programmers
10:28:43 <gwern> rwbarton: perhaps we could just use money and avoid abstract numbers entirely
10:28:45 <lilac> gwern: to count -1000 things from n, start at m, count 1000 things and arrange to end at n
10:29:03 <erikc> gwern: would there be inflation?
10:29:06 <roconnor> gwern: from now on negative numbers will be numbers bigger than infinity
10:29:09 <gwern> so -1000 would equal 'owe 1000', and 'bankrupt' would be a synonym for '0'
10:29:11 <roconnor> where infinitiy = 2^32
10:29:19 <gwern> we can sell it to business! we'll make millions!
10:29:23 <erikc> haha
10:29:37 <gwern> erikc: inflation == perpetual job guarantee
10:29:46 <roconnor> gwern: good idea about using money
10:30:01 <roconnor> gwern: we can't let programmers use abstract ideas like numbers.  That is too confusing
10:30:08 <lilac> > let n - 1000 = m where m + 1000 = n in 42 - 1000
10:30:10 <roconnor> gwern: possibly chickens would be better than numbers
10:30:10 <lambdabot>   m
10:30:13 <roconnor> gwern: possibly chickens would be better than money
10:30:34 <pk> rwbarton: If creating IORefs isn't pure, how come GLUT has settable variable like currentWindow :: (SettableVar a)  => a .. (with no IO)
10:30:37 <gwern> you might say that integers don't support cents and fractions, but that's a feature not a bug - the language will round upwards! businesses will be able to screw customers over again and again! BWA HA HA HA
10:30:42 <rwbarton> > let n - 1000 = m where (m + 1000) = n in 42 - 1000
10:30:44 <lambdabot>   * Exception: /tmp/5007351995233018407:71:111-124: Irrefutable pattern faile...
10:31:00 * gwern applies for a business method patent on a language which rounds always upwards and generates more profits
10:31:07 <rwbarton> pk: I have no idea.  What's in the .. ?
10:31:27 <pk> Maybe Window
10:31:28 <rwbarton> > let n - 1000 = m where (m + 1000) = n in 1042 - 1000
10:31:38 <pk> @hoogle currentWindow
10:31:39 <lambdabot> No results found
10:31:44 <lambdabot>   thread killed
10:31:50 <lilac> > let (n+1000)-1000 = n in 1042 - 1000
10:32:06 <lambdabot>   thread killed
10:32:15 <rwbarton> Wait, do n+k patterns use whatever - is in scope?
10:32:25 <rwbarton> > let (-) = error "blah" in let (x+1) = 2 in x
10:32:33 <lambdabot>   * Exception: blah
10:32:46 <lilac> rwbarton: i think only with -XNoImplicitPrelude
10:33:03 <lilac> (that causes them to use whatever (-) and (>=) are in scope)
10:33:07 <rwbarton> , let (-) = error "blah" in let (x+1) = 2 in x
10:33:09 <lunabot>  1
10:33:15 <rwbarton> lilac: I see
10:33:33 <rwbarton> pk: (SettableVar a) => a Maybe Window probably isn't a valid type
10:33:41 * lilac wonders what incredible hacks are possible using this technique
10:34:38 * canadaduane pasted http://pastie.textmate.org/private/4ptfvalkfde9kujsjhwcw
10:34:50 <canadaduane> I feel very newbish, but why does that not work?
10:35:04 <pumpkin> <- takes a Monad on its right
10:35:10 <pumpkin> so it would need to be return 2 if you really wanted to
10:35:16 <canadaduane> oh
10:35:19 <pumpkin> let n = 2 is probably what you want there
10:35:21 <vixey> 2 isn't an IO computation
10:35:42 <pumpkin> n <- return 2 or let n = 2 :)
10:35:51 <canadaduane> I was trying to get a "simplest case" working
10:35:56 <roconnor> @tpe (return 2)
10:35:57 <canadaduane> couldn't believe I failed at it at first :)
10:35:58 <canadaduane> thanks
10:35:59 <roconnor> @type (return 2)
10:36:06 <pumpkin> note that that's a very imperative simplest base :P
10:36:07 <pumpkin> case
10:36:18 <roconnor> IO Int
10:36:20 <canadaduane> heh, yes
10:36:35 <Gracenotes> @pl \f a -> if a==0 then 1 else a * f (a-1)
10:37:06 <Gracenotes> hm.
10:37:53 <pumpkin> Gracenotes: @pls with if in them will give you if'
10:37:59 <lilac> @botsmack
10:37:59 <lunabot>  :)
10:38:06 <pumpkin> you killed lambdabot!
10:38:10 <Gracenotes> pumpkin: yes, I know
10:38:14 <canadaduane> lol
10:38:35 <pumpkin> @pl \f a -> if a==0 then 1 else a * f (a-1)
10:38:35 <pumpkinbot> ap (flip if' 1 . (0 ==)) . ap (*) . (. subtract 1)
10:39:19 <Gracenotes> hm. Asking lambdabot to pl the combinator might have had something to do with it...?
10:39:23 <Gracenotes> Y
10:39:43 <pk> rwbarton: why ?
10:39:45 <Gracenotes> or maybe l-bot just decided it was its time to die :/
10:39:58 <pumpkin> Gracenotes: I dunno... anyway, I summon pumpkinbot when lambdabot dies :)
10:40:18 <Gracenotes> I have seen pumpkinbot before
10:40:42 <pk> rwbarton: in fact, it is StateVar (Maybe Window)
10:40:45 <lilac> @type let a >= b = undefined; (a+1)-k = undefined in (-)
10:40:50 <pumpkinbot> forall t t1 a. (Integral t) => t -> t1 -> a
10:40:55 <lilac> ^^ why?
10:41:02 <rwbarton> pk: So what's the problem?  What does it have to do with newIORef?
10:41:23 <lilac> why am i getting an Integral context in there?
10:41:25 <Gracenotes> pumpkin: it is part of the great children's classic, It's the Great Pumpkinbot, Charlie Brown
10:41:30 <pumpkin> :)
10:41:56 <pk> rwbarton: those StateVar works like IORefs
10:42:00 <pk> rwbarton: I think
10:42:29 <rwbarton> pk: OK, but they're not actually IORefs necessarily
10:42:39 <rwbarton> pk: they're probably implemented by a global variable in the GLUT library
10:42:49 <rwbarton> (ultimately)
10:42:53 <pk> rwbarton: oh
10:42:56 <pk> rwbarton: ok thx
10:44:02 <rwbarton> pk: Or, it's not impossible that the Haskell library code has a top-level unsafePerformIO'd newIORef
10:46:29 <vixey> :(
10:46:44 <vixey> why would they do such a thing?
10:46:54 <lilac> @type let a >= b = undefined; a-b = undefined in \(a+0) -> a
10:46:55 <pumpkinbot> forall t. (Integral t) => t -> t
10:47:01 <athos> hi all
10:47:17 <lilac> @type let a >= b = undefined; a-b = undefined in \(a+1) -> a
10:47:19 <pumpkinbot> forall t. (Integral t) => t -> t
10:47:54 <lilac> @type let a >= b = undefined; a-b = undefined; f a' | a' >= 1 = a - 1 in f
10:47:56 <pumpkinbot> forall t a. t -> a
10:48:14 <rwbarton> @type 1
10:48:15 <pumpkinbot> forall t. (Num t) => t
10:48:19 <rwbarton> oh I see
10:48:21 <lilac> is -XNoImplicitPrelude working there?
10:48:36 * lilac thinks those two should be equivalent
10:48:52 <rwbarton> I assume the Report specifies an extra Integral instance
10:48:58 <rwbarton> s/instance/context/
10:49:26 <lilac> I would have thought NoImplicitPrelude would remove that
10:49:56 <Holle_> exists an if statement without an else case?
10:50:01 <lilac> even still, shouldn't the former be (Integral t) => t -> a ?
10:50:01 <rwbarton> But it can't come from (>=) or (-), so it must be specified explicitly
10:50:12 <vixey> Holle, yeah just don't write if <x> else
10:50:30 <lilac> Holle_: what value should be used in the 'else' case?
10:50:46 <rwbarton> lilac: that does seem weird, I guess
10:50:55 <Holle_> i want to write if () then do else do nothing
10:51:10 <lilac> Holle_: ah, in a Monad, there are ways out
10:51:13 <lilac> @type when
10:51:15 <pumpkinbot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
10:51:15 <lilac> @type unless
10:51:16 <pumpkinbot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
10:51:26 <vixey> you should be able to implement when and unless
10:51:51 <Holle_> isn't when impolemented?
10:52:06 <lilac> Holle_: yes, but you should be able to implement it yourself ;-)
10:52:11 <Gracenotes> millionth fibonacci number, here I come...
10:52:26 <Holle_> thanks :)
10:52:27 <lilac> Gracenotes: which algorithm are you using?
10:52:42 <Gracenotes> the recurrence formula
10:52:43 <lament> "Millionth Fibonacci Number Discovered For Millionth Time"
10:52:50 <Gracenotes> hehe
10:52:56 <Gracenotes> yeah, I'm just calculating the number of digits
10:53:05 <Gracenotes> fix (\f a b -> a:f b (a+b)) 0 1
10:53:10 <sbahra> Any Haskellers in the Washington DC area willing to give a Haskell tutorial for ACM at the George Washington University?
10:53:13 <lilac> Gracenotes: a formula defines what the result should be, an algorithm says how to calculate it
10:53:22 <Gracenotes> which is taking up a lot of memory, because I'm making a goddamn list
10:53:31 <lilac> @type iterate
10:53:32 <pumpkinbot> forall a. (a -> a) -> a -> [a]
10:53:35 <pumpkin> sbahra: I'd ask on -Cafe
10:53:37 <Gracenotes> yeah.
10:53:48 <Gracenotes> @src (!!)
10:53:48 <pumpkinbot> xs     !! n | n < 0 = undefined
10:53:48 <pumpkinbot> []     !! _         = undefined
10:53:48 <pumpkinbot> (x:_)  !! 0         = x
10:53:48 <pumpkinbot> (_:xs) !! n         = xs !! (n-1)
10:54:01 <int80_h> @seen lemmih
10:54:01 <pumpkinbot> lemmih is in #haskell. I don't know when lemmih last spoke.
10:54:13 <pumpkin> int80_h: I only just @joined the bot
10:54:17 <int80_h> lemmih, you awake?
10:54:22 <lilac> Gracenotes: there are better algorithms; you can compute Fn from Fn/2 or similar
10:54:48 <lilac> or indeed, from the golden ratio if you can do so accurately
10:54:54 <Gracenotes> hm, I'll try to implement those. Right now I'm just trying brute force and seeing where that gets me
10:54:54 <int80_h> I am trying to find out what grad schools on the west coast like haskell...
10:55:02 <int80_h> besides berkeley
10:55:09 <pumpkin> int80_h: why west coast? :(
10:55:13 <pumpkin> int80_h: prejudice!
10:55:21 <int80_h> well, I want to stay on the west coast
10:55:24 <lilac> int80_h: west coast of which country?
10:55:27 <int80_h> yes, I am biased
10:55:32 <quile> int80_h: b/c the west coast is where it's at, dudes :)
10:55:35 <int80_h> California ;)
10:55:39 <Gracenotes> lilac: one of the other things I'm doing is checking when the golden ratio formula gets wildly inaccurate when working with FPA
10:55:40 <pumpkin> Yale has hudak, he likes haskell
10:55:49 <pumpkin> ;)
10:55:49 <igowen> int80_h: Oregon has a really good theoretical PL prof, and one associate professor who's doing a seminar on haskell
10:55:51 <quile> int80_h: check in the Portland area... there's a fair amount of Haskell-y stuff going on here
10:56:07 <Gracenotes> I just decided to see how easily the regular formula would calculate the millionth one
10:56:23 <int80_h> quile: Portland looks cool. But what univeristies are there?
10:56:35 <vixey> sounds pointless/tedious
10:57:02 <byorgey> int80_h: Portland State is where all the Haskell is
10:57:09 <quile> Portland State University, University of Portland, Oregon Graduate Institute
10:57:10 <int80_h> did anyone notice I referred to California as a country. Being biased again.
10:57:22 <int80_h> Ah university of portland!
10:57:31 <pumpkin> sure beats the -15˚ F we had this morning :P
10:57:42 <int80_h> portland state. sounds like a school I could actually get into
10:57:42 <pumpkin> (The Country of California, that is)
10:57:52 <pumpkin> int80_h: grad or undergrad?
10:57:56 <Gracenotes> hey now... going to a university just for Haskell is somewhat like following a girl/boyfriend to their university. What if you guys break up? :P
10:58:07 <pumpkin> Gracenotes: I agree :)
10:58:17 <pumpkin> for undergrad, at least
10:58:21 <quile> int80_h: yeah although I am not sure what their programs are like.  for really interesting CS stuff try UBC, SFU and UVic in Canada too
10:58:24 <Gracenotes> yeah.
10:58:44 <int80_h> well I am still an undergrad. San Jose State. I'm thinking of the future. With my GPA I'll have to get my masters from San Jose State, and then it's off to a phd. But I need to see what my realistic options are now, and prepare.
10:58:55 <pumpkin> ah
10:59:10 <igowen> you know you can go straight from bachelor's to phd, right?
10:59:14 <pumpkin> yeah
10:59:20 <int80_h> igowen: not with my gpa
10:59:22 <pumpkin> and a GPA doesn't really count much
10:59:26 <int80_h> really?
10:59:31 <int80_h> then what matters?
10:59:35 <igowen> recommendations
10:59:37 <pumpkin> all a PhD program wants is a good researcher (more of an employment thing)
10:59:42 <wchogg> gpa doesn't mean much when applying for grad school.  Knowing professors does.
10:59:45 <pumpkin> so if you have research experience, that certainly helps a lot
10:59:58 <pumpkin> (papers, REU, doing work for a prof)
11:00:06 <wchogg> Grad school isn't like undergrad.  It's more of an apprenticeship.
11:00:13 <int80_h> oooh I have plenty of time to demonstrate I'm a good researcher. AFter all, everyone here is java this and OOP that. I'm about the functional programming model.
11:00:19 <pumpkin> well, masters programs are often like an extension of undergra
11:00:19 <pumpkin> d
11:00:28 <lament> with the difference that real apprenticeships prepare you for a useful profession
11:00:30 <wchogg> pumpkin : true, I wasn't talking about phd programs.
11:00:46 <wchogg> lament : :p
11:00:52 <wchogg> *was talking
11:00:52 <pumpkin> int80_h: if you have time left as an undergrad, seek out a prof who does something you like and work with him/her
11:01:05 <igowen> int80_h: UO hosts a programming languages summer school you might want to check out
11:01:21 <sw17ch> @seen dons
11:01:21 <pumpkinbot> dons is in #haskell. I don't know when dons last spoke.
11:01:26 <quile> UO = Oregon?
11:01:27 <sw17ch> D:
11:01:31 <igowen> yep
11:01:34 <pumpkin> sw17ch: the bot just joined
11:01:35 <quile> good school
11:01:42 <igowen> indeed
11:01:47 <igowen> int80_h: http://www.cs.uoregon.edu/research/summerschool/summer08/
11:01:47 <pumpkinbot> Title: Summer School on Logic and Theorem-Proving in Programming Languages, July 2008
11:01:48 <sw17ch> pumpkin: that explains a lot
11:01:56 <sbahra> Cool
11:01:59 <int80_h> pumpkin: hmm I can do that. Well I'm glad to hear about the gpa. I'm smart and curious. But I slacked off for so long, and have a horrible undergrad gpa record.
11:02:01 <pumpkin> sw17ch: I just use it as a backup for when lambdabot dies
11:02:23 <sbahra> Pretty reasonably priced, too!
11:02:41 <int80_h> I thought I would have to get a masters, as an extension of the undergrad degree, to "repent" as it were.
11:02:49 <pumpkin> int80_h: yeah, I can't speak with authority, but I'd say that if you have a "publication list" on your app to grad school (PhD) that'll be the single most important factor, along with recommendations
11:02:55 <wchogg> int80_h : yeah, you should definitely start building up your track record.  GPA doesn't count for much, but if it's bad then you need to show that you're not a slacker.
11:02:58 <rdst> how to convert POSIXTime to Integer?
11:03:04 <roconnor> > sort ["Gonthier", "Grégoire", "Gödel"]
11:03:08 <pumpkinbot>   ["Gonthier","Gr\233goire","G\246del"]
11:03:20 <sbahra> igowen, is this open to undergraduate students?
11:03:23 <roconnor> hmm
11:03:32 <roconnor> I don't suppose we have a collate function?
11:03:37 <roconnor> @hoogle collate
11:03:38 <pumpkinbot> No results found
11:03:43 <Gracenotes> > (-2 :: CReal) ** 2
11:03:43 <igowen> sbahra: I'm sure it is. I know the guy that usually organizes it
11:03:44 <pumpkinbot>   mueval: Prelude.read: no parse
11:03:44 <pumpkinbot>  mueval: *** Exception: log of negative number
11:03:46 <lambdabot> No results found
11:03:52 <lambdabot>   * Exception: log of negative number
11:03:56 <pumpkin> Gracenotes: that's a really annoying thing :/
11:04:03 <Gracenotes> you're tellin me
11:04:07 <rwbarton> @type (**)
11:04:07 <pumpkin> > (-2 :: CReal) ^^ 2
11:04:08 <pumpkinbot> forall a. (Floating a) => a -> a -> a
11:04:08 <pumpkinbot>   4.0
11:04:13 <lambdabot>   4.0
11:04:15 <Gracenotes> ah.
11:04:16 <rwbarton> Seems pretty reasonable to me
11:04:17 <roconnor> 4.0
11:04:19 <pumpkin> oh lambdabot is back!
11:04:20 <lambdabot> forall a. (Floating a) => a -> a -> a
11:04:27 <pumpkin> @part #haskell
11:04:32 <lambdabot> Not enough privileges
11:04:41 <sbahra> igowen, so this'll likely be available next Summer, too?
11:04:44 <Gracenotes> it seems a bit slow on the uptake though
11:04:49 <igowen> sbahra: as far as I know
11:04:53 <sw17ch> , @seen dons
11:04:55 <lunabot>  luna: parse error on input `@'
11:04:57 <Gracenotes> argh, so many exponentiation functions
11:04:58 <sw17ch> hahah
11:04:59 <sbahra> Cool
11:05:15 <pumpkin> Gracenotes: the different ones are more efficient in different situations
11:05:45 <Gracenotes> is there something to exponentiate CReals to CReals?
11:05:47 <mathijs> Hi all, some time ago, I read something about "myFunction x y = ..." being less optimized than "myFunction x = \y -> ...", I can't remember the case exactly, but is there some truth in this?
11:05:56 <rwbarton> Gracenotes: note that (-2 :: CReal) ** 2 is (-2 :: CReal) ** (2 :: CReal)
11:06:31 <Gracenotes> anything? :/.
11:06:33 <rwbarton> Gracenotes: which it's quite reasonable for it not to want to evaluate, because maybe the exponent is 2.00000000000...00000000001 or something
11:06:57 <saml> @hoogle CReal -> CReal -> CReal
11:06:58 <lambdabot> Warning: Unknown type CReal
11:06:58 <lambdabot> Prelude asTypeOf :: a -> a -> a
11:06:58 <lambdabot> Control.Parallel par :: a -> b -> b
11:07:00 <Gracenotes> or 1.9999999999999999..8
11:07:10 <Gracenotes> but you're right. In this case I don't actually need to use a CReal
11:07:15 <Gracenotes> for the exponent
11:07:30 <pumpkin> Gracenotes: finding a non-integral exponent of a negative number is weird :P
11:07:36 <pumpkin> your best bet is to use complex numbers
11:07:48 <Gracenotes> oh! you're right.
11:07:55 <int80_h> igowen: wow that looks totally afforadable. I'll taget that for next year.
11:07:56 <pumpkin> > (-2 :: Complex CReal) ** (2.01)
11:07:58 <lambdabot>   4.025834713113496970625594630522406874924 :+ 0.1265169527408629997313564260...
11:07:58 <Gracenotes> duh. math.
11:08:01 <int80_h> target
11:08:05 <Badger> ooh
11:08:39 <int80_h> well, I have a programming problem to post to hpaste so I have to prepare that
11:09:16 <Badger> > pi :: Complex CReal
11:09:18 <lambdabot>   3.1415926535897932384626433832795028841972 :+ 0.0
11:09:40 <Badger> oh okay that's not what I thought it was at al.
11:09:42 <Badger> all, even.
11:09:53 <rdst> > getPOSIXTime
11:09:55 <lambdabot>   Not in scope: `getPOSIXTime'
11:10:02 <Gracenotes> > (-1 :: Complex CReal) ** (2.000000000000001)
11:10:03 <lambdabot>   0.9999999999999999999999999999950651977995 :+ 0.000000000000003141592653589...
11:10:09 <Holle_> can i export a module from a module?
11:10:15 <daf> yes
11:10:21 <Gracenotes> wait... 314159... WHAT
11:10:24 <Holle_> how does it work?
11:10:27 <lilac> just add the name of the module to your exports list, i think
11:10:28 <Gracenotes> must be a Euler thing
11:10:33 <pumpkin> Gracenotes: yeah
11:10:44 <pumpkin> @src (**)
11:10:45 <lambdabot> Source not found. Take a stress pill and think things over.
11:10:50 <rwbarton> module Foo (module Bar) where...
11:10:59 <pumpkin> @src CReal (**)
11:11:00 <lambdabot> Source not found. Maybe you made a typo?
11:11:11 <lilac> Gracenotes: expand it out ;-)
11:11:14 <rwbarton> > (-2) ** 2
11:11:16 <lambdabot>   4.0
11:11:22 <rwbarton> > (-2 :: Double) ** 2
11:11:24 <lambdabot>   4.0
11:11:26 <rwbarton> > (-2 :: Double) ** 2.000001
11:11:28 <lambdabot>   NaN
11:11:32 <Holle_> i import Game.Map in Game.GamePlay and want to export Game.Map. What do i have to write?
11:11:45 * Gracenotes huggles Euler
11:11:52 <Gracenotes> which sounds weird if you pronounce it
11:11:56 <roconnor> a**b = exp (log a*b)
11:12:05 <rwbarton> module Game.GamePlay (module Game.Map) where
11:12:41 <rdst> anybody can help on getting Integer from POSIXTime or NominalDiffTime from Data.Time.Clock ?
11:12:43 <roconnor> pumpkin: CReal uses the default value of (**)
11:12:48 <pumpkin> yeah
11:12:51 <wli> You can't do that without talking about Cauchy principal values.
11:13:01 <pumpkin> or of Complex
11:13:09 <Holle_> works :) thanks!
11:13:35 <roconnor> rdst: what type of integer?
11:13:46 <rdst> roconnor: Integer
11:13:51 <rwbarton> roconnor: he means CountingThing
11:13:58 <rwbarton> roconnor: I know it's confusing :)
11:14:08 <roconnor> Ah CountingThing :)
11:14:20 <roconnor> rdst: I mean, what do you want the Integer to count?
11:14:45 <rdst> roconnor: posix time, count of seconds from 01 01 1970
11:15:27 <roconnor> rdst: a somewhat strange request, but perhaps you are interfacing with some other system
11:15:37 <roconnor> diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime
11:15:44 <mathijs> Is there some general rule for ghc's optimization settings? I mean for most c-code, gcc -O2 is safe and a bit faster than no optimization. -O3 is faster most of the time, but not in certain cases. Is the same kind of thing true for haskell?
11:16:12 <rdst> roconnor: POSIXTime is member of Data.Time.Clock.POSIX module
11:16:18 <wli> Usually the way it goes is to define n-th roots of nonnegative real numbers in terms of suprema, then generalizing to odd denominators of exponents and negative bases, then things go to complex numbers and Riemann surfaces.
11:16:21 <rwbarton> rdst: there's also utcTimeToPOSIXSeconds
11:17:19 <rwbarton> wli: (***) :: (Real a) -> Complex a -> Rational -> Set (Complex a) ?
11:17:34 <mauke> mathijs: ghc has no -O3
11:17:52 <rdst> rwbarton: I want to interact with mysql TIMESTAMP datatype, it is posix time too, and it's necessary to work with Integer values
11:17:56 <roconnor> rwbarton: ah nice
11:18:13 <roconnor> rdst: round, or floor will convert POSIXTime to Integer
11:18:27 <mathijs> mauke: I know, but can I safely assume that -O2 is safe/better most of the time compared to no optimizations?
11:18:38 <roconnor> hey, there is even a getPOSIXTime
11:18:39 <Gracenotes> wow, using CReals to get the 1000th fib number takes around 45 seconds
11:18:41 <wli> rwbarton: Mayb even Real t => Rational -> Rational -> Complex t
11:18:47 <Gracenotes> it works though, to a T
11:18:52 <mauke> mathijs: yes
11:19:09 <rdst> roconnor: thanks a lot
11:19:09 <roconnor> > toRational posixDayLength
11:19:11 <lambdabot>   Not in scope: `posixDayLength'
11:19:14 <pumpkin> Gracenotes: you mean using phi?
11:19:18 <pumpkin> that seems a little excessive
11:19:19 <Gracenotes> yes
11:19:25 <roconnor> > toRational Data.Time.Clock.POSIX.posixDayLength
11:19:26 <lambdabot>   /tmp/568387949194899:70:43:
11:19:26 <lambdabot>      Not in scope: `Data.Time.Clock.POSIX.posix...
11:19:30 <mathijs> roconner: I read that somewhere around feb 13 we will have 1234567890 posix time :)
11:19:33 <Badger> @src floor
11:19:33 <mathijs> mauke: thanks
11:19:33 <lambdabot> Source not found. :(
11:19:51 <Gracenotes> pumpkin: using let x = (1+sqrt(5))/2 :: CReal; x5 = sqrt(5) :: CReal; n = 1000 in (x^^n - (1-x)^^(n))/x5
11:19:57 <Gracenotes> how fast is it for you?
11:20:02 <roconnor> Prelude>  toRational Data.Time.Clock.POSIX.posixDayLength
11:20:02 <roconnor> Loading package old-locale-1.0.0.0 ... linking ... done.
11:20:02 <roconnor> Loading package time-1.1.2.0 ... linking ... done.
11:20:02 <roconnor> 86400%1
11:20:24 <rdst> length of a day in seconds
11:20:24 <roconnor> Prelude> floor Data.Time.Clock.POSIX.posixDayLength
11:20:24 <roconnor> 86400
11:20:26 <Gracenotes> it does compute it exactly though
11:20:31 <loadquo_> Hmm for some reason checkinstall doesn't get on with installing ghc...
11:20:42 <pumpkin> Gracenotes: can't you use ^ there?
11:20:57 <pumpkin> > (2.535 :: CReal) ^ (1000 :: Int)
11:20:59 <lambdabot>   950525274706734992973400848102827482674008002289623177333097644903077671496...
11:21:07 <pumpkin> ^ is way more efficient
11:21:10 <pumpkin> for integer exponents
11:21:13 <rwbarton> @src (^^)
11:21:14 <lambdabot> x ^^ n      =  if n >= 0 then x^n else recip (x^(negate n))
11:21:19 <Gracenotes> ah.
11:21:20 <pumpkin> oh
11:21:21 <roconnor> rdst: you can also use ceiling, but I assume you infered that from what I already said
11:21:23 <pumpkin> then I guess not :)
11:21:33 <Gracenotes> well, let me calculate it using ^ instead
11:22:01 <pumpkin> > let x = (1+sqrt(5))/2 :: CReal; x5 = sqrt(5) :: CReal; n = 1000 in (x^n - (1-x)^(n))/x5
11:22:09 * wli supposes one could represent real numbers by Cauchy sequences of rational numbers directly, e.g. newtype Real = Real [Rational] or some such.
11:22:16 <lambdabot>   thread killed
11:22:18 <pumpkin> boo :)
11:22:27 <pumpkin> it must be the sqrt taking a while
11:22:29 <Gracenotes> yep, same amount
11:22:35 <Gracenotes> 42.63 seconds
11:22:47 <lilac> wli: wouldn't it be nicer to have a type which guarantees it's a cauchy sequence? ;-)
11:22:56 <Gracenotes> doing it with ^^ took 42.72 seconds
11:23:13 <oklopol> indeed it's a pretty catchy sequence
11:23:16 <Gracenotes> using (-x)^^(-n) instead of (1-x)^n made it take twice as long
11:23:30 <Badger> hmm
11:23:36 <Badger> where does CReal come from?
11:23:45 <mauke> CReal boxes
11:23:46 <roconnor> wli: a modulus of convergence is quite useful to have
11:23:47 <pumpkin> @index CReal
11:23:47 <lambdabot> bzzt
11:23:54 <pumpkin> it's Data.Numeric.CReal or something
11:24:01 <roconnor> wli: otherwise there isn't too much that the sequence tells you
11:24:03 <Gracenotes> Data.Number.CReal
11:24:06 <wli> lilac: Assuming such is possible; I am not entirely convinced that it is in a useful fashion (e.g. continued fractions have nontermination problems around cancellation to precisely 0).
11:24:15 <lilac> wli: how about: data Real = Real Rational [NonNegativeRational]
11:24:20 <Gracenotes> the cool functions are in Data.Number.Cereal, though
11:24:48 <pumpkin> Badger: you need to get the package from cabal though
11:24:49 <wli> lilac: What's that supposed to be?
11:24:51 <roconnor> http://hackage.haskell.org/packages/archive/numbers/2008.4.20.1/doc/html/Data-Number-CReal.html
11:24:56 <lilac> value (Real a bs) = minimum (map (a+) bs)
11:24:59 <newsham> > foldr (either (first.(:)) (second.(:))) ([],[]) [Left 'c', Left 'a', Right 1, Right 2, Left 'r']
11:25:01 <lambdabot>   ("car",[1,2])
11:25:11 <lilac> wli: using the fundamental theorem
11:25:19 <rwbarton> , partitionEithers [Left 'c', Left 'a', Right 1, Right 2, Left 'r']
11:25:21 <lunabot>  ("car",[1,2])
11:25:35 <lilac> wli: and a slightly tweaked definition of 'minimum'
11:25:41 <pumpkin> @index partitionEithers
11:25:41 <lambdabot> bzzt
11:25:47 <lilac> @hoogle infimum
11:25:47 <pumpkin> rwbarton: whence comes that?
11:25:47 <lambdabot> No results found
11:25:50 <wli> lilac: It sounds very similar to continued fractions.
11:26:05 <rwbarton> pumpkin: ghc 6.10, Data.List I think
11:26:09 <pumpkin> ah :)
11:26:19 <lilac> wli: it's guaranteed to give you a unique finite real for any values in the type
11:26:28 <lilac> wli: but the representations aren't even remotely unique
11:26:33 <newsham> ?let partitionEithers = foldr (either (first.(:)) (second.(:))) ([],[])
11:26:36 <lambdabot>  Defined.
11:26:44 <lilac> i doubt it's a useful type for most calculations, too ;-)
11:26:49 <pumpkin> ah, Data.Either
11:26:52 <newsham> > partitionEithers partitionEithers [Left 'c', Left 'a', Right 1, Right 2, Left 'r']
11:26:53 <lambdabot>   Couldn't match expected type `[Either a b]'
11:27:00 <newsham> > partitionEithers [Left 'c', Left 'a', Right 1, Right 2, Left 'r']
11:27:01 <lambdabot>   ("car",[1,2])
11:27:13 <pumpkin> uncurry ++ on it :P
11:27:25 <lilac> wli: or data Game = Game [Game] [Game]
11:27:47 <wli> lilac: Continued fractions are already pretty good. Mostly what's needed is an answer to the cancellation-to-zero problem.
11:28:08 <pumpkin> , ''Either
11:28:11 <lunabot>  Data.Either.Either
11:28:12 <pumpkin> , src ''Either
11:28:13 <lilac> wli: oh, you're looking for something practical and useful? my bad. ;-)
11:28:22 <lunabot>  data Either a b = Left a | Right b
11:28:43 <rwbarton> lilac: now write a fancy version of Game that only allows Numbers
11:28:53 <lilac> rwbarton: am i allowed to use dependent types?
11:29:05 <rwbarton> lilac: uh... hmm
11:29:13 <rwbarton> lilac: maybe you can just do it with gadts somehow?
11:29:24 * wli just noticed last night that his classify :: [Either t t'] -> ([t], [t']) had been merged into the stdlib as partitionEithers
11:29:27 <lilac> sounds ... challenging
11:29:41 <roconnor> wli: I did that a year or two ago
11:29:46 <roconnor> It wasn't easy
11:29:48 <wli> Where is roconnor, anyway? He's got more and more solid material on this arbitrary-precision real number stuff than I.
11:29:50 <sw17ch> we need lambdabot to have an @bother
11:29:52 * rwbarton doesn't remember exactly how the definition of Number works
11:29:53 <sw17ch> which is like @tell
11:29:54 <lilac> not generalized for Traversible? tssk
11:29:55 <sw17ch> but more bothersome
11:30:05 <pumpkin> sw17ch: there's also an @ask I think :)
11:30:07 <roconnor> wli: here I am
11:30:19 <wli> roconnor: There you are. Are you telling me a solution to the zero cancellation problem for continued fraction subtraction exists?
11:30:21 <roconnor> @tell wli I'm here
11:30:22 <lambdabot> Consider it noted.
11:30:32 <sw17ch> pumpkin: interesting...
11:30:41 <pumpkin> sw17ch: I think it's a synonym for @tell :P
11:30:51 <sw17ch> @bother pumpkin Hah, are you bothered yet?
11:30:52 <lambdabot> Unknown command, try @list
11:30:52 <lunabot>  :)
11:30:53 <roconnor> wli: um, I don't understand the problem.
11:30:54 <lilac> @tell roconnor hello
11:30:54 <lambdabot> Consider it noted.
11:31:03 <pumpkin> :)
11:31:09 <lilac> @yell roconnor at wli
11:31:09 <lambdabot> Consider it noted.
11:31:16 * sw17ch thinks @bother should hunt down phone numbers e-mail addresses, online presences... etc...
11:31:18 <roconnor> wli: but I'm telling you that I added partitionEithers to Data.Eithers a year or two ago
11:31:18 <lambdabot> roconnor: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:31:27 <roconnor> @messages
11:31:27 <lambdabot> lilac said 33s ago: hello
11:31:27 <lambdabot> lilac said 18s ago: at wli
11:31:36 <lilac> @bask in the glory
11:31:36 <lambdabot> Consider it noted.
11:31:48 <rwbarton> @snap lilac
11:31:49 <lambdabot> go slap lilac yourself
11:31:59 <lilac> @clap your hands
11:32:00 * lambdabot will count to five...
11:32:14 <wli> roconnor: The stock Gosper algorithm for continued fraction addition/subtraction is unable to produce even a single continued fraction element for 0 when it is the result of adding/subtraction two continued fraction expansions.
11:32:41 <pumpkin> grr @ http://www.reddit.com/r/programming/comments/7pv4j/ask_reddit_whats_the_most_outrageously_useless_cs/
11:34:52 <roconnor> wli: that sounds likely for from what little I know about continued fractions
11:35:18 <roconnor> wli: does 0 even have a represenatation?
11:36:35 <wli> roconnor: Yes, [0;] as it's written in mathematical conventions, and [0] or (0,[]) for Haskell (which basically just does something besides using a semicolon to denote the special role of floor(x)).
11:36:41 <roconnor> okay
11:37:18 <roconnor> wli: can [0;x] even denote anything other than 0?
11:37:41 <wli> roconnor: [0;x] = 0 + 1/(1 + x)
11:38:03 <wli> ergh
11:38:08 <wli> roconnor: [0;x] = 0 + 1/x
11:38:21 <roconnor> hmm
11:38:22 <wli> roconnor: [0;x,y] = 0 + 1/(x + 1/y)
11:38:23 <roconnor> okay
11:38:40 <wli> roconnor: [0;x,y,z] = 0 + 1/(x + 1/(y + 1/z)) etc.
11:38:59 <wli> [w;x,y,z] = w + 1/(x + 1/(y + 1/z)) etc.
11:39:23 <roconnor> ok
11:39:25 <roconnor> still
11:39:36 <roconnor> I'm not surpised that continued fractions have troubles around 0
11:39:45 <roconnor> but I'm not really an expert on them.
11:39:57 <wli> The restriction is that the integers after the semicolon must be strictly positive. The integer before the semicolon is unrestricted beyond being required to be an integer, though for some purposes it must be restricted to be a nonnegative integer.
11:40:18 <roconnor> oh
11:40:18 <wli> roconnor: If you've not looked into it, I can probably recite more of the lore off the top of my head.
11:40:35 <roconnor> soe [0;x...] is always a nonnegative number?
11:41:04 <wli> roconnor: In some treatments. It varies depending on what's going on.
11:41:39 <wli> roconnor: Sometimes it's more convenient to pull the sign out and and other times you just let floor(x) do all the work.
11:44:14 <wli> roconnor: The thing that absolutely must not have signs creating havoc is the actual fraction part. How the rational {x} (fractional part braces { }) gets pulled out of the real number is not as big an issue.
11:46:25 <roconnor> wli: I'm still not sure, but it sounds like you don't have enough reducdency to represents all values of 0
11:46:34 <roconnor> which explains your failure to subtract
11:48:13 <dons> ?instances-importing Data.Monoid Monoid
11:48:14 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
11:51:46 <brandon> is there a way to get a DWord from a floating point value?
11:51:48 <pumpkin> lots of Monoid talk!
11:52:36 <pumpkin> the overview in the monoid docs is pretty pathetic, I must admit :P
11:52:47 <brandon> or Word32 rather
11:52:51 <wli> roconnor: What redundancy? The continued fraction expansion of a real number is unique. cf x | (q, r) <- properFraction = q : if r /= 0 then cf $ recip r else []
11:52:54 <pumpkin> "The Monoid class with various general-purpose instances.
11:52:54 <pumpkin> Inspired by the paper /Functional Programming with Overloading and Higher-Order Polymorphism/, Mark P Jones (http://citeseer.ist.psu.edu/jones95functional.h"
11:53:13 <rwbarton> brandon: like floor?
11:53:16 <rwbarton> :t floor
11:53:17 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
11:53:27 <brandon> rwbarton: no, i don't want to convert to an Integral
11:53:53 <brandon> rwbarton: i need to pipe the floating point values to a C program
11:54:29 <rwbarton> wli: If you don't have redundancy in your representations, you're guaranteed to have cases where you just can't add certain pairs of numbers at all
11:54:54 <wli> rwbarton: I'm not aware of that and don't see why that's the case.
11:56:05 <roconnor> wli: redundancy is that there is some (parital) real number expression that contains an open neighbourd around 0
11:56:20 <roconnor> by partial
11:56:22 <roconnor> I mean
11:56:24 <wli> pumpkin: springschool95.ps is also the best monad tutorial I've ever seen.
11:56:32 <rwbarton> wli: for topological reasons.  Unfortunately, I have to run
11:56:55 <pumpkin> wli: ? where
11:57:03 <roconnor> think of (0,1:2:undefined)
11:57:09 <rwbarton> wli: but basically the space of values of an algebraic data type is going to be like a Cantor set, while the reals are disconnected
11:57:17 <rwbarton> wli: you can't have a continuous bijection between them
11:57:18 <roconnor> and think of all the possible values that could go into undefined
11:57:26 <roconnor> that will represent an interval
11:57:27 <vixey> I thought you had to run because of topological reasons :p
11:57:27 <lambdabot> vixey: You have 1 new message. '/msg lambdabot @messages' to read it.
11:57:31 <vixey> @messages
11:57:31 <lambdabot> mmorrow said 4d 22h 48m 58s ago: i've got abssyn, free/bound vars, and a parser + pprinter for pisigma at http://moonpatio.com/repos/pisigma/. i've decided to use this as the interp frontend "core
11:57:31 <lambdabot> lang" for my lvm implem, so if everything goes as planned, anything you can manage to translate into this you can interpret
11:57:49 <vixey> lambdabot, didn't hear you the first 3 times could you repeat it again please?
11:57:56 <roconnor> we need to be able to put an arbitarily small such interval around every real number
11:58:09 * roconnor isn't sure he is making sense
11:58:57 <Lemmih> pao: Hi!
11:59:00 <wli> With continued fractions, that's usually formed by successive convergents (one is guaranteed to be greater than the result, the other less than it, and the product of their denominators the length of the interval formed).
11:59:08 <pao> Lemmih: hi :-)
11:59:33 <wli> A sort of telescoping alternating Egyptian fraction.
12:00:15 <rwbarton> wli: here's one quick explanation:
12:00:26 <rwbarton> wli: suppose your outermost constructor tells you whether a number is >= 0 or < 0
12:00:41 <rwbarton> wli: take some typical real number
12:01:08 <wli> okay
12:01:16 <rwbarton> wli: and try to compute x - x.  Most of the time, it would require inspecting all of each copy of x to determine that this difference is >= 0
12:02:08 <wli> That's what happens with continued fractions.
12:02:25 <rwbarton> Right, it happens whenever representations are unique
12:03:47 <leimy> wow haskell-cafe is full of people who really overcomplicate things
12:04:28 <roconnor> with real numbers, you are not allowed to compute if an arbitrary number is (>= 0) or (< 0)
12:04:36 <roconnor> doing so allows you to solve the halting problem
12:05:10 <roconnor> actually computing (>=0) or (<0) makes the halting problem look like peanuts
12:06:56 <roconnor> in BibTex, does "\ " mean a non-breaking space?
12:08:02 <wli> I don't believe so.
12:08:17 <Feuerbach> What is an easiest way to work polymorphically with Num'bers (at least Inegral's and Frac's) while being able to make division?
12:08:22 <wli> Power series it is, I guess.
12:08:39 <klugez> roconnor: I think its "~".
12:09:02 <roconnor> klugez: okay
12:09:02 <mmorrow> Feuerbach: use Double :)
12:09:14 <roconnor> "Proceedings 4th Int.\ Conf.\ on Mathematics of Program Construction, {MPC}'98, Marstrand, Sweden, 15--17 June 1998"
12:09:23 <roconnor> what does the "\ " mean there?
12:09:31 <roconnor> hmm
12:09:40 <roconnor> one of those, this is not the end of a sentence spaces?
12:09:50 <mmorrow> there's a '.' before each one...
12:10:20 <mmorrow> (and each terminates an abbrev.\)
12:10:32 <Feuerbach> mmorrow: consumer might want Double or Int, so I'd like to expose interface like Num a => a -> a
12:10:33 <mmorrow> '
12:11:21 <mmorrow> Feuerbach: you could do data GNum = IntG Int | DoubleG Double
12:11:55 <vixey> blugh... this makes no sense
12:11:56 <Feuerbach> mmorrow: yes, but isn't there an easier way?
12:12:04 <mmorrow> then do the conversion legwork in you instance of Num
12:12:21 <mmorrow> heh, i don't believe so
12:12:26 <wli> Given radix r and a nonnegative real number x to represent, find n in Z s.t. r^n <= x < r^{n+1}, k in Z with 0 <= k < r s.t. k*r^n <= x < (k+1)*r^n, recurse on x - k*r^n, etc. appears to have some uniqueness about it.
12:12:46 <mmorrow> you've gotta do the conversion somewhere or another
12:13:48 <Feuerbach> mmorrow: I hoped there's some typeclass where you may do division for integrals and fracs. I could do my one, of course.
12:14:14 <vixey> I'm so confused
12:14:31 <vixey> you know this type directed eta expansion
12:14:37 <mmorrow> Feuerbach: ah, you could just do MyNum = MyNum Rational
12:15:05 <vixey> it looks like:  r O e = e ; r (tau :->: sigma) f = VLam (\x -> r sigma (f $ (r tau x)))  for simple types
12:15:16 <mmorrow> and both Int and Double'd factor through it (for the most part)
12:15:43 <wli> Maybe find n in Z minimizing |x - r^n|, then k in Z minimizing |x - k*r^n|, then recurse on x - k*r^n?
12:15:46 <vixey> if you had dependent types.. how on earth can you do type directed eta expansion without using type inference..?
12:16:07 <vixey> (type inference is partial .. so it breaks lazyness)
12:16:11 <mmorrow> , abs (pi - (fromRational . toRational) pi)
12:16:13 <lunabot>  0.0
12:16:17 <sw17ch> Has any one used the OpenSSL libraries extensively?
12:16:31 <pao> , 1 + 1
12:16:33 <lunabot>  2
12:16:35 <mattam> vixey: you mean as soon as you can substitute type variables?
12:16:38 <roconnor> wli:  uniqueness == bad
12:16:42 <pao> :t fmap.fmap
12:16:43 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
12:16:43 <Holle_> is it difficult to add doublebuffering when drawing with cairo?
12:17:03 <pumpkin> Holle_: #cairo ;)
12:17:09 <pumpkin> or at least, I have no clue
12:17:20 <wli> roconnor: Well, that mixes up the sign decision problem and is probably not unique.
12:18:17 <mmorrow> vixey: what are you reading?
12:19:26 <vixey> mmorrow, I'm writing
12:19:43 <mmorrow> ah
12:19:46 <vixey> well not atm because I hit a brick wall
12:19:55 <mmorrow> break through!
12:20:14 <mmorrow> put on a helmet first!
12:20:17 <vixey> mattam, taking the eta normal form of the value  Pi x:tau, sigma(x)
12:20:40 <vixey> I think that I have got to expand tau, as well as sigma(x)
12:21:39 <vixey> oops
12:21:44 <vixey> no what I said was nonsense sorry
12:22:24 <vixey> taking the eta normal form of,    f : Pi x:tau, sigma(x)
12:22:44 <mattam> Yes.
12:23:14 <vixey> I would like to write   \x:<eta normal form of tau>, eta-expand_sigma(x) (f $ (eta-expand_tau x))
12:23:33 <vixey> but there is no way to find the eta normal form of tau.. without doing type inference, at least it seems that way
12:23:47 * loadquo_ wonders why he is getting a 4x increase when using par and pseq
12:24:32 <mattam> τ's type is necessarily a sort isn't it?
12:24:33 <dcoutts> Holle_: if you're using cairo with gtk then it does it automatically when you draw onto a widget in the expose handler.
12:25:35 <Holle_> i'm using now drawWindowBeginPaintRegion and drawWindowEndPaint and it works :)
12:25:54 <vixey> mattam, yes it is.. that doesn't make sense though
12:26:42 <wli> rwbarton/roconnor: My idea was little more than generalizing ordinary radix expansions whose digits d_k have 0 <= d_k < r for all k with ones where |d_k| < r and one hopes to minimize the difference at every turn.
12:26:46 <vixey> what if f happens to be  \(x : C (\i -> i)), x.. for example C being the constructor of some inductive type
12:27:30 <vixey> the term would not be definitionally equal to  \(x : C (\f x -> f x)), x..
12:27:34 <mattam> You can probably suppose that binders are annotated with their sort as well to avoid inference.
12:27:48 <wli> rwbarton/roconnor: Maybe -r/2 < d_k <= r/2 would be a better choice.
12:28:14 <vixey> mattam, but what you pointed out makes me think this eta expansion doesn't work for dependent types :(
12:28:14 <vixey> a
12:28:18 <acidjnk> What's wrong with this? I get a parse error: dec2int (j++[i]) = (dec2int j)*10+i
12:28:28 <mauke> can't use ++ in patterns
12:28:41 * maltem hates segfaults
12:28:43 <sw17ch> Are any of the crypto libraries intended for high performance?
12:28:43 <vixey> the brackets are redundant: dec2int k*10+i
12:28:57 <acidjnk> thanks
12:28:59 <Deewiant> you can only pattern-match on constructors like :, not functions like ++
12:29:02 <mattam> Hmm. (\i -> i)'s eta expansion would have to be (\f x -> f x) no?
12:29:25 <roconnor> wli: "ones where |d_k| < r"  This will work, and is a common approach.
12:29:32 <acidjnk> How can I work around to do what I want?
12:29:47 <vixey> mattam, if we let the type of C : ((* -> *) -> (* -> *)) -> Foo for this example. yeah
12:29:48 <mauke> > read "123" :: Int
12:29:50 <lambdabot>   123
12:29:56 <roconnor> wli: "-r/2 < d_k <= r/2" this would not work.  It has too little redudency
12:30:02 <vixey> mattam, maybe eta mandates uniformity..
12:30:02 <Deewiant> acidjnk: since you're running through the whole string you could reverse it first
12:30:14 <acidjnk> uff
12:30:26 <mauke> > foldl' (\z x -> z*10+x) 0 [1,2,3]
12:30:28 <lambdabot>   123
12:30:40 <mattam> vixey: oh so you mean you need inference for C?
12:30:54 <acidjnk> what's foldl'? Is it different from foldl?
12:31:19 <roconnor> ugh
12:31:22 <mauke> it's better
12:31:28 <roconnor> how to I write a ~ in BibTex
12:31:36 <acidjnk> Anyway, that appears to be the solution to the exercise, thanks :-)
12:31:42 <roconnor> so it doesn't turn into a nonbreaking space, nor an accent?
12:31:52 <vixey> mattam, it seems so.. I'm not really sure I got my self a bit lost in this
12:32:49 <mattam> roconnor: \~{} according to symbols-a4
12:32:55 <pumpkin> acidjnk: it's a strict version of foldl
12:32:55 <mattam> in LaTeX
12:33:12 <roconnor> ah right
12:33:43 <mattam> vixey: you do need inference or annotations at applications.
12:34:21 <hallongrottan> how do i get base >=4 in my system
12:34:30 <mattam> vixey: But you can implement that by just inference as you're working on well-typed terms.
12:34:33 <vixey> mattam, oh! that make sense.. the algorithm reduces terms to beta normal form.. but then constructor applications stick around
12:34:34 <nnj> What is the right way to update one element in a list? Do I always have to create new lists?
12:34:40 <hallongrottan> i have not yet fully understood darcs/cabal
12:34:46 <vixey> (before doing eta expansion)
12:34:57 <mauke> nnj: yes
12:35:00 <SubStack> > 2 ^ 43112609 - 1
12:35:14 <lambdabot>   316470269330255923143453723949337516054106188475264644140304176732811247493...
12:35:31 <nnj> mauke: but then my O(n) algos become O(n^2) or sorts, don't they?
12:35:36 <dcoutts> hallongrottan: the version of base and the version of ghc are fairly tightly related. So for example base 4 comes with ghc-6.10.
12:35:36 <SubStack> \o/
12:35:43 <mauke> nnj: depends on what you're doing
12:35:47 <vixey> because C (\i -> i) is in beta normal for
12:35:50 <vixey> form*
12:35:58 <hallongrottan> dcoutts: oh, how do i get the latest ghc then?
12:36:15 <mattam> vixey: Yep. There are presentations (for example by Barthes and Melliès) where everything is annotated: lambdas and applications.
12:36:23 <dcoutts> hallongrottan: if it's not packaged for your distro yet then you can install the generic binary.
12:36:28 <hallongrottan> hmm ok
12:36:50 <vixey> hmm
12:36:56 <dcoutts> hallongrottan: if you're just tring to use a package and it needs base 4, check if older versions of the package can work with older versions of base.
12:36:56 <vixey> when you type infer C : <whatever>
12:37:14 <nnj> mauke: if i can't combine all the operations i would perform on the elements of a list, can i still keep the complexity same?
12:37:14 <vixey> ... <whatever> can be a dependent type that causes more computation, more evaluation..
12:37:24 <hallongrottan> dcoutts: ok, thanks
12:37:37 <mauke> nnj: what?
12:37:37 <BMeph> nnj: If you're that scared^W "concerned", you should use a tree to sort on. ;)
12:38:03 <mattam> vixey: You mean type inference requires computation? yes.
12:38:26 <vixey> mattam, so it's impossible to break this mutual recursion then
12:38:33 <vixey> between all 3 of the judgements
12:38:34 <nnj> mauke: say my algo needs to update 1 element each time, and there are n such updates, how can it ever O(n)?
12:38:48 <mauke> nnj: by using something with O(1) updates
12:38:57 <mattam> Actually I wonder. For constants and variables it requires only a lookup.
12:38:58 <mauke> what do I win?
12:39:04 <mornfall> dcoutts: Btw... is it conceivable that one day, it will be possible to cabal install ghc?
12:39:25 <dcoutts> mornfall: not for several years
12:39:44 <mattam> You won't have a redex there... so that's probably the only cases.
12:39:46 <nnj> mauke: my elments can be anywhere in the list, how can it be O(1)
12:39:56 <mauke> nnj: who said anything about a list?
12:40:01 <dcoutts> mornfall: we can do it with lhc, we should move onto nhc and hugs, ghc is last.
12:40:08 <nnj> nnj: i am working with a list
12:40:14 <mauke> why?
12:40:14 * BMeph imagines hot-swappable Haskell compiler modules... take THAT, Erlang!
12:40:27 <mattam> vixey: between which judgments exactly?
12:40:28 <pumpkin> I vaguely remember there was some possibility for making "psuedo-infix unary" operators somehow
12:40:35 <nnj> nnj: why should i not?
12:40:46 <pumpkin> anyone know how?
12:40:56 <mauke> because apparently you need random access and updates
12:40:58 <vixey> mattam, type inference, normal form,  convertability
12:41:16 <nnj> mauke: is there a set library that offers such updates in O(1)?
12:41:29 <vixey> mattam, I was imagining something like   K (\i -> i) e Nat  with K : forall (f:* -> *) (n:Nat)(X:*), iterate f n X -> F,   where iterate applies a function n times
12:41:29 <pk> @t replicateM_ 3 $ return ()
12:41:29 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
12:41:29 <mauke> wait, you're using lists as sets?
12:41:31 <mauke> wtf
12:41:43 <pk> @type replicateM_ 3 $ return ()
12:41:44 <nnj> mauke: no i could use set as a list
12:41:44 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
12:41:47 <BMeph> pumpkin: "Psuedo-infix" as in post-fix, but w/o the follow-on? "Yes, Haskell can do that!" ;)
12:42:02 <pumpkin> yeah :)
12:42:06 <pumpkin> how does that work?
12:42:12 <pk> @type replicateM_ 3 $ return () :: IO ()
12:42:14 <lambdabot> IO ()
12:42:30 <pk> surprise
12:42:57 <pk> @type \n -> replicateM_ n $ return () :: Int -> IO ()
12:42:58 <lambdabot>     Couldn't match expected type `IO ()' against inferred type `()'
12:42:58 <lambdabot>       Expected type: Int -> IO ()
12:42:58 <lambdabot>       Inferred type: Int -> ()
12:43:07 <pk> why ?
12:43:23 <nnj> mauke: for a simple unordered collection, like an array in C, what should be the best data-structure in Haskell?
12:43:35 <pumpkin> nnj: an array is ordered :o
12:43:37 <mauke> @type (\n -> replicateM_ n $ return ()) :: Int -> IO ()
12:43:38 <lambdabot> Int -> IO ()
12:43:44 <pumpkin> nnj: if you want the "most native" then use a list :P
12:43:50 <mauke> nnj: an array is THE ordered collection
12:43:50 <nnj> pumpkin: the elements don't need to be
12:43:53 <pk> thx mauke
12:44:00 <pumpkin> nnj: ??
12:44:02 <mattam> vixey: yeah, with eta you can't break the cycle. There's an argument in Werner's thesis that η-conversion for a PTS can't be proved safe by a combinatorial/syntactic argument.
12:44:12 <kmeyer> nnj: you mean unsorted, I think?
12:44:15 <pumpkin> nnj: you can interpret it ignoring the order, but as a collection, it's definitely ordered
12:44:34 <BMeph> pumpkin: GHC does it this way: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#postfix-operators
12:44:45 <mauke> you access it by integral indices. it doesn't get more ordered.
12:44:53 <nnj> pumpkin: what i want is O(1) access/updates, is that possible in Haskell?
12:44:54 <pumpkin> BMeph: great! thanks!
12:45:07 <pumpkin> nnj: in that case, I'd use an Array in haskell :) there's a bunch to choose from
12:45:14 <pumpkin> updates-wise, you'll want one living in IO or ST
12:45:25 <pumpkin> but you might want to look at alternate approaches before trying to be stateful
12:45:26 <vixey> mattam, oh thank you, is that Coq in Coq?
12:45:31 <mauke> or maybe just a Data.Sequence
12:45:35 <mauke> O(1) is overrated
12:45:41 <nnj> pumpkin: like what?
12:45:48 <di3go> hello :)
12:45:49 <pumpkin> nnj: I dunno, depends on your problem :)
12:45:58 <nnj> pumpkin: okay
12:46:06 <mattam> No, Coq in Coq is Barras's thesis (a student of Werner). http://tel.archives-ouvertes.fr/tel-00196524/en/
12:46:08 <pumpkin> nnj: just saying that it's a bit like trying to literally translate idioms from one (human) language to another
12:46:13 <BMeph> nnj: DiffArray, likely. :)
12:46:17 <pumpkin> they sound stilted :P
12:46:51 <nnj> BMeph: hmm..
12:46:57 <mattam> vixey: sorry it's in french again.
12:47:14 <vixey> nothing wrong with that just takes me longer :p
12:48:28 <mauke> BMeph: isn't DiffArray ... slow?
12:48:39 <pumpkin> BMeph: muahahaha, before I could define += on STRefs, now I can define ++ on them too and be really ugly in an elegant manner :D
12:52:56 <dons> happs-driven, http://baldurkristjans.is/
12:53:50 <pumpkin> icelandic?
12:54:05 <pumpkin> I guess
12:54:31 <BMeph> mauke: I could say something about being slow, but... ;)
12:54:50 <wli> Okay, say that sum d_k*r^{n_k} is canonical whenever -r/2 < d_k <= r/2 for all k over which the sum ranges and |d_k| < r is the validity constraint.
12:55:02 <BMeph> mauke: Anyway, is it? I thought MArray was slow, and DiffArray was better, esp. for multiple shall changes. :)
12:55:09 <dons> woo, http://www.reddit.com/r/programming/comments/7pohw/why_haskell_is_beyond_ready_for_prime_time/c071tjv
12:55:21 <pejo> mattam, do you have to write the thesis in french?
12:57:11 <mattam> pejo: Yes, although one can ask for a derogatory measure.
12:57:39 <mattam> I find most theses are still written in french.
12:57:47 <MyCatVerbs> BMeph: what? DiffArray is supposed to be, like, painfully slow.
12:58:37 <dancor> whenever there is an alternative to something "painfully slow" shouldn't the slow thing be removed
12:58:51 <dons> reimplemented anyway.
12:58:57 <dons> hmm. thanks for reminding me.
13:00:21 <pumpkin> dons: have you had a chance to look at that buffer-overrun-alike behavior I was seeing in my UArrs?
13:00:25 <MyCatVerbs> Surely DiffArray couldn't possibly be made fast, though. All the operations on it have to be synchronized (MVars everywhere rather than IORefs) because it has to be threadsafe because of `par`?
13:00:31 <dons> pumpkin: ah, thanks for reminding me!
13:00:44 <dons> MyCatVerbs: does DiffArray actually use MVars?
13:00:45 <pumpkin> I put info up on that trac :) no rush from my side
13:00:47 <pumpkin> was just curious
13:00:48 <dancor> he needs a todons-list
13:00:54 <pumpkin> hah
13:00:58 <dons> i have a todo list, yeah
13:01:01 <dons> in gitit,fwiw
13:01:10 <dancor> more like ftw
13:03:42 <MyCatVerbs> dons: I don't know. Mailing list postings seem to indicate that it does.
13:04:00 <MyCatVerbs> I don't have a copy of the sources on hand to check, though.
13:04:38 <MyCatVerbs> Oh wait, they're linked from the Haddock docs. Yaaaay!
13:04:57 <roconnor> @nazi-off
13:04:57 <lambdabot> Not enough privileges
13:05:26 <dons> newtype IOToDiffArray a i e =
13:05:27 <dons>     DiffArray {varDiffArray :: MVar (DiffArrayData a i e)}
13:05:27 <dons> -- Internal representation: either a mutable array, or a link to
13:05:27 <dons> -- another diff array patched with a list of index+element pairs.
13:05:27 <dons> data DiffArrayData a i e = Current (a i e)
13:05:30 <dons>                          | Diff (IOToDiffArray a i e) [(Int, e)]
13:06:02 <mgsloan> hey, the other day I defined a Num (IO a).  This has been thought of before, right?  I thought it was pretty cool
13:06:12 <MyCatVerbs> dons: and yes. A DiffArray is roughly an MVar around either an IOArray or an IOArray and an association list.
13:06:25 <MyCatVerbs> dons: ...which you just copypasta'd. Damn. :)
13:07:20 <mauke> mgsloan: http://mauke.ath.cx/stuff/haskell/fun.hs
13:08:08 <mgsloan> mauke - ahh nice
13:08:57 <mgsloan> even more general than i made it
13:09:17 <chessguy_work> interesting discussion on -cafe on the usefulness of Data.Monoid
13:11:41 <phercek1> how can I access GHCiState from ghci command line? for example how to read the progname of the GHCiState from ghci command line?
13:13:03 <mgsloan> wow, that allows you to do some pretty atrocious things like [1,2,3] * [1,2,3]
13:13:26 <pumpkin> :o
13:13:42 <pumpkin> lol instance (Num a, Applicative f, Eq (f a), Show (f a)) => Num (f a) where
13:13:43 <mauke> mgsloan: or 1 2 3
13:14:02 <pumpkin> that is pretty awesome
13:14:10 <mgsloan>  pumpkin - mine was worse, something like...
13:14:10 <mauke> (sin + cos * pi) 3
13:14:41 <pumpkin> that allows me to get MATLAB-like behavior on lists :D
13:14:45 <pumpkin> :P
13:14:57 <dons> someone should put those scary [] instances in a package
13:15:02 <dons> as well as other Perl-ish evil
13:15:08 <chessguy_work> i came in late, what does [1,2,3] * [1,2,3] do?
13:15:09 <mgsloan> instance (Num a, Show a, Eq a, Show (IO a), Eq (IO a)) => Num (IO a) where
13:15:16 <pumpkin> *Main>  [1,2,3] * [1,2,3]
13:15:17 <pumpkin> [1,2,3,2,4,6,3,6,9]
13:15:31 <pumpkin> chessguy_work: basically liftA
13:15:33 <chessguy_work> nice
13:15:34 <chessguy_work> i like it
13:15:40 <mauke> *> ZipList [1,2,3] * ZipList [1,2,3]
13:15:40 <mauke> ZipList [1,4,9]
13:15:43 <mgsloan> stick it in the prelude ;)
13:15:52 <pumpkin> *Main> abs([1,-2,3])
13:15:53 <pumpkin> [1,2,3]
13:15:54 <mauke> someone needs to fix Num first
13:16:03 <mauke> I really don't like the Show/Eq instances for (->)
13:16:09 <mgsloan> mauke - hah, 1 2 3 is crazy
13:17:10 <pumpkin> I like the whoops on Eq for functions
13:17:38 <mgsloan> Eq shouldn't be required for Num
13:17:46 <mgsloan> because it might not terminate for reals
13:17:52 <pumpkin> mgsloan: the prelude's typeclasses for numerical things are messed up :P
13:17:58 <mgsloan> very
13:18:02 <pumpkin> there's a numeric prelude that makes it nicer :)
13:18:06 <mgsloan> yup
13:18:15 <mgsloan> TheOtherPrelude is pretty cool too
13:19:58 <gwern> dons: re gitit: was your old gitit using unsalted passwords?
13:20:06 <gwern> and your new one using salts?
13:20:57 <chessguy_work> mgsloan, where's that?
13:21:19 <chessguy_work> oh, found it
13:21:55 <Lemmih> dons: (re-gitit) Delete _local/
13:22:28 <pk> in reactive, is the Behavior type a monad ?
13:22:42 <mgsloan>  So I'm taking CSE 341 at University of Washington right now
13:22:48 <mgsloan> we're doing haskell :)
13:22:56 <chessguy_work> pk, as i recall, not quite
13:23:05 <mgsloan> I'm actually kinda surprised, the treatment of it hasn't been half bad
13:23:10 <chessguy_work> err, actually, i'm thinking of the HSOE definition of Behavior
13:23:18 <mgsloan> though students hate it with burning passion :/
13:23:19 <gwern> Lemmih: out of curiosity, would you use gitit with a darcs backend?
13:23:30 <pumpkin> mgsloan: how could students hate it??
13:23:31 <gwern> mgsloan: lol. they'll thank them some day!
13:23:38 <mgsloan> yeah I think so :)
13:23:45 <wli> At some point, there needs to be an agreement to ditch backward compatibility for the sake of fixing the predefined/whatever typeclass hierarchies.
13:24:02 <Lemmih> gwern: Yes, I definately would.
13:24:07 <mgsloan> well, haskell in 2 weeks of classes could be pretty painful when most of your previous experience is java
13:24:23 <gwern> Lemmih: cool; glad to know it's not just me then
13:24:40 <pk> chessguy_work, ok
13:25:51 <mgsloan> kinda fun, with mauke's fun.hs, readLn^5 asks you for 5 numbers and returns the product
13:26:19 <pumpkin> beautiful :P
13:26:22 <mauke> well, you need to provide Eq (IO a) and Show (IO a) first
13:26:30 <mgsloan> yeah nevermind :P
13:26:30 <mauke> in conclusion, Num--
13:26:40 <mgsloan> that was with my version
13:26:41 <chessguy_work> hehe
13:26:50 <pumpkin> ah
13:27:08 <mpeter> HASKELL!
13:27:30 <mpeter> is there a mysql_real_escape_string equivalent in the bindings
13:27:35 <mpeter> or do you have to write it yourself
13:27:41 <chessguy_work> anybody else agree that the usefulness of a typeclass is proven by the number of functions that involve an arbitrary instance of that typeclass, and not the number of instances themselves?
13:27:50 * pumpkin votes mysql_real_escape most ugly function name in API ever
13:27:52 <dons> i think that's a cool metric
13:27:59 <dons> still.
13:28:01 <pumpkin> chessguy_work: yes
13:28:07 <roconnor> ``Notice that "monoid" sounds almost *exactly* like "monad". And yet, what you
13:28:07 <roconnor> use them for is wildly unrelated.
13:28:08 <Raevel> pumpkin: but the good thing is that you know that it escapes, for real
13:28:09 <mpeter> mysqlRealEscapeString <-- better?
13:28:11 * roconnor sighs
13:28:12 <pumpkin> chessguy_work: regarding the monoid discussion we're all following you mean?
13:28:19 <olsner> still, a type class isn't much without any instances of it
13:28:26 <chessguy_work> pumpkin, yeah, just wondering if i'm the only one that thinks that
13:28:36 <mauke> mgsloan: http://mauke.ath.cx/stuff/haskell/fun.hs updated
13:28:40 <chessguy_work> olsner, well sure, you have to be able to define instances of it
13:28:48 <mpeter> dons, you run hackage or something
13:28:53 <mpeter> is there such a function already written
13:29:01 <bartek[work]> Hi, reading through real world haskell and one question so far .. On types, when you say that Tuples are fixed-size, does this mean that once they are created I cannot modify them (as in, append to them liek I could with lists) or .. ?
13:29:03 <gwern> wait, you don't use monoids in a way similar to monads? wut
13:29:05 <mauke> real_escape_string? wtf?
13:29:09 <mauke> lern2placeholders
13:29:19 <olsner> is it, btw, possible to define a type class that you can't write an instance of?
13:29:20 <pumpkin> chessguy_work: I do agree :)
13:29:26 <chessguy_work> bartek[work],  that's correct: (Int, Int) is a different type from (Int, Int, Int)
13:29:33 <mpeter> i write functions with names like fedExTruck
13:29:37 <mpeter> and inquisitiveDog
13:29:49 <Raevel> it's all gold
13:29:50 <mpeter> and then when you apply fedExTruck to inquisitiveDog
13:29:55 <mpeter> well, you need a monad, let's just say that ;)
13:29:59 <olsner> bartek[work]: you can't modify *anything* ... immutable data etc :)
13:30:03 <pumpkin> mauke: lol
13:30:54 <pumpkin> @hoogle (Monoid m)
13:30:55 <lambdabot> Warning: Unknown type Monoid
13:30:55 <lambdabot> Prelude undefined :: a
13:30:55 <lambdabot> Data.Array.Base arrEleBottom :: a
13:31:09 <chessguy_work> haha
13:31:23 <chessguy_work> @hoogle (Monoid m) => m
13:31:23 <lambdabot> Data.Monoid mempty :: Monoid a => a
13:31:23 <lambdabot> Data.Monoid mconcat :: Monoid a => [a] -> a
13:31:23 <lambdabot> Data.Foldable fold :: (Foldable t, Monoid m) => t m -> m
13:31:34 * wli writes functions with names like f, g, h, and other functions with names like singularValueDecomposition
13:31:43 <bartek[work]> chessguy_work: thanks!
13:31:43 <pumpkin> just trying to find more general functions on monoids :P
13:31:50 <bartek[work]> olsner: touche, sorry .. bad wording :)
13:31:57 <pumpkin> wli: what does g do?
13:32:07 <pumpkin> wli: I hope it does the same thing my g does!
13:32:47 <chessguy_work> bartek[work],  you could write something like append :: (a, b) -> c -> (a, b, c) though, if you wanted. append (x,y) z = (x,y,z)
13:33:12 <sbahra> pumpkin, what do you think of http://freebsd.haskell.org/?
13:33:13 <wli> pumpkin: When I use names like f, g, h, etc., it's mostly for formatting purposes that they've been given a name vs. being written inline as lambda abstractions, and they don't have any good way to be summarized.
13:33:22 <vixey> why not use (,) ?
13:33:40 <vixey> append :: (a, (b, ())) -> c -> (a, (b, (c, ())))
13:33:41 <pumpkin> sbahra: really cute, and looks nice :)
13:33:46 <sbahra> cool ;-]
13:33:54 <sbahra> thanks
13:34:00 <pumpkin> sbahra: why only 6.8 though?
13:34:14 <chessguy_work> vixey, you mean besides the fact that it makes me want to tear my eyes out?
13:34:16 <sbahra> pumpkin, because it appears I'm the only one who is bothered to update it. :)
13:34:21 <sbahra> pumpkin, and I'm busy at the moment.
13:34:22 <BMeph> Now that we're getting the rest of the CS-associated world acquainted with monads, I think we need to start seriously working with comonads. ;)
13:34:29 <sbahra> pumpkin, 6.10.1 is lined up.
13:34:33 <pumpkin> ah :)
13:34:44 <pumpkin> BMeph: and figuring out where Monoids are useful :)
13:34:48 <vixey> comonads yuck
13:34:56 <Holle_> how to create random numbers between 1 and 3
13:35:03 <chessguy_work> pumpkin, _arbitrary_ Monoids
13:35:23 <wli> BMeph: You're probably better off with arrows and hylo/para/ana/cata/etc. -morphisms and concurrency/parallelism.
13:35:29 <leimy> Man that OCaml thread is just awesome
13:35:33 <sbahra> pumpkin, I'm just wondering if I should splatter the project logo on every page or just the main page.
13:36:05 <Cale> Forget the *rest* of the CS world, I would be happy if we had a better understanding of the practical uses of comonads ourselves.
13:36:07 <pumpkin> sbahra: I dunno, it's awfully cute, you might have to put it on every page
13:36:20 <sbahra> haha
13:36:21 <olsner> BMeph: why stop there? I say we go straight for the zygohistomorphic prepromorphisms!
13:36:23 <pumpkin> Cale: have any input on the Monoid discussion on cafe?
13:36:34 <sbahra> Cale, what is your input? You seem to be artistically inclined.
13:36:36 <Cale> Which?
13:36:42 <Cale> sbahra: hm?
13:36:43 <sbahra> Cale, http://freebsd.haskell.org/
13:36:51 <sbahra> Cale, should I splatter the logo on every page or just the index?
13:36:59 <pumpkin> Cale: huge discussion on (mostly) the point of the Monoid typeclass given that it seems to have almost no general functions defined on it
13:37:19 <sw17ch> > "your " ++ (concat . (take 10) . repeat) "grandmother " ++ "was a monkey"
13:37:19 <lambdabot>   "your grandmother grandmother grandmother grandmother grandmother grandmoth...
13:37:19 <sw17ch> whoops
13:37:20 <chessguy_work> pumpkin, i wouldn't say "huge"
13:37:21 <sw17ch> > "your " ++ (concat . (take 10) . repeat) "great " ++ "grandmother was a monkey"
13:37:23 <lambdabot>   "your great great great great great great great great great great grandmoth...
13:37:27 <pumpkin> chessguy_work: fine :)
13:37:28 <pumpkin> large
13:37:38 <chessguy_work> pumpkin, most of the conversation is about nomenclature in general
13:37:40 <vixey> > replicate 10 "great"
13:37:42 <lambdabot>   ["great","great","great","great","great","great","great","great","great","g...
13:37:47 <Holle_> is it so difficult to create random numbers?
13:37:48 <Cale> pumpkin: ah, I have something about that...
13:38:00 <vixey> Holle_, what have you tried so far?
13:38:03 <Cale> pumpkin: one moment while I get you a link
13:38:34 <pumpkin> thanks :)
13:38:34 <Holle_> x <- randomRIO (1,3)
13:38:34 <vixey> Holle_, but it doesn't work?
13:38:34 <Cale> sbahra: hmm, maybe the site needs a header of some sort in which the logo would sit
13:38:34 <chessguy_work> @type randomRIO
13:38:34 <sw17ch> > "your " ++ (concat . (replicate 10)) "great " ++ "grandmother was a monkey"
13:38:34 <lambdabot> forall a. (Random a) => (a, a) -> IO a
13:38:34 <lambdabot>   "your great great great great great great great great great great grandmoth...
13:38:34 <sw17ch> yay
13:38:38 <Cale> (and which would be attached to each page)
13:38:39 <tromp__> your great^654218mother was a bacteria
13:38:44 <pumpkin> chessguy_work: true, but since I'm on the "mathematical language is good" side of things, I guess all I took out of the convo was the "what's the point of Monoid" when there are so few general operations on them
13:38:54 <sw17ch> i'm working on my haskell insults
13:38:55 <Peaker> tromp__: a lot more than that
13:39:01 <sbahra> Cale, ok. Thanks.
13:39:06 <Holle_> http://hpaste.org/13962 parse error <-
13:39:15 <Cale> pumpkin: my reply here: http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06a7da
13:39:20 <dons> MyCatVerbs: http://github.com/glguy/punionfind/blob/deea4e4b2e5d5aa1240e288511ee0e0565dfca3a/RevertArray.hs
13:39:29 <vixey> Holle_, oh that doesn't make sense
13:39:31 <mauke> Holle_: initGame :: GameState means initGame is a constant
13:39:38 <BMeph> leimy: SMTL!
13:39:38 <pumpkin> Cale: oh yeah, I saw that :) it was cool
13:39:42 <vixey> Holle_, you should have something like  newGameState :: IO GameState which actually creates a new one
13:39:52 <pumpkin> Cale: but there seem to be relatively few "higher order" monoid functions
13:39:57 <pumpkin> beyond mconcat, it seems
13:40:07 <chessguy_work> vixey, errr, you mean it's an action which creates one
13:40:16 <Peaker> Cale: hey, can you explain why (return = mempty, join = mappend)?
13:40:16 <wli> (>=>), (<=<)
13:40:24 <vixey> chessguy_work: what are you asking?
13:40:32 <BMeph> pumpkin: What do you mean, "figuring out where Monoids are useful"? Where are the *not* useful?
13:40:36 <Cale> pumpkin: What about the Writer monad?
13:40:47 <Cale> pumpkin: Or finger trees?
13:40:48 <chessguy_work> vixey, oh, i was just saying that what you said wasn't quite precisely correct
13:41:04 <Cale> Peaker: sure.
13:41:05 <pumpkin> Cale: ah, I'll take a look at them then :)
13:41:06 <vixey> chessguy_work: newGameState creates a new game state in the same way a bottle opener opens a bottle. i.e. when you use it
13:41:15 <Cale> Peaker: come to #haskell-overflow
13:41:28 <pumpkin> BMeph: they're not useful for my main = print 5 program :(
13:41:44 <chessguy_work> vixey, so monads are bottle openers? just kidding
13:42:15 <dons> no no. unsafePerformIO is a bottle opener
13:42:18 <dons> monads are the bottle
13:42:30 <pumpkin> unsafePerformM
13:42:33 <dons> monoids are like wine shelves
13:42:34 <chessguy_work> Cale, the idea from the monoid discussion is that a good metric of the usefulness of a typeclass is not the number of instances, but the number of functions that can take an arbitrary instance of the class and do something useful
13:42:47 <dons> i think it is two dimensional
13:43:06 * vixey is one dimensional
13:43:09 <dons> the number of instances also matters, if the class methods are few - it indicates a fundamental concept
13:43:15 <chessguy_work> Cale, i.e., Monad is useful because of mapM, forever, join, etc., etc.
13:43:20 <dons> like, say, map or (.)
13:43:35 <chessguy_work> dons, i'm not talking about the class methods
13:44:09 <dons> a class is useful if it a) has lots of instance types, or b) has lots of code polymorphic in it at few types (or both)
13:44:17 <chessguy_work> i'm talking about methods outside the class into which you can pass an arbitrary member of the class
13:44:25 <dons> of course.
13:44:38 <dons> that's one metric. that there's a lot of code polymorphic in that set of types
13:44:44 <chessguy_work> dons, ok. i don't understand how point a is useful without point b
13:44:44 <dons> indicating good resuse
13:45:01 <dons> well, there's not a lot of code polymorphic in say, Functor only
13:45:04 <dons> but fmap is damn useful
13:45:16 <chessguy_work> why?
13:45:18 <dons> why? because of all the instances
13:45:22 <sbahra> :t forever
13:45:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
13:45:30 <dons> so you get to use one name for the same concept everywhere
13:45:41 <vixey> hey  fmap f . fmap g = fmap (f . g)  isn't a function
13:45:43 <dons> or, say (+)
13:45:48 <Holle_> vixey: http://hpaste.org/13962#a1 it's the same problem?!
13:45:56 <dons> vixey: looks like a rewrite rule
13:46:08 <vixey> Holle_, the first two lines are good
13:46:17 <vixey> Holle_, but next you can use do notation to write something like:
13:46:22 <vixey> initGame = do
13:46:32 <vixey>   randomNumber <- randomRIO(1,3)
13:46:41 <vixey>  return $ GameState { ...
13:46:50 <chessguy_work> @hoogle fmap
13:46:51 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
13:46:51 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
13:46:51 <lambdabot> Control.Monad.Instances fmap :: Functor f => (a -> b) -> f a -> f b
13:46:52 <vixey> (and maybe with less wobbly indentation)
13:47:19 <pumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html
13:47:23 <vixey> Holle_, this works because all the IO stuff like generating numbers are done in an IO do block
13:47:35 <pumpkin> that uses Monoid
13:48:06 <chessguy_work> dons, can you give me an example of a function that uses fmap, but doesn't have (Functor f) => ... f ... somewhere in its type signature? i'm still not sure i get it
13:48:29 <mauke> (1 :) . fmap succ
13:48:31 <dons> Operations.hs:    mnew <- maybe (return Nothing) (fmap (fmap stag) . uncurry pointScreen)
13:48:41 <dons> Layout.hs:        fmap (second . fmap $ Choose R l) . runLayout (W.Workspace i r ms)
13:48:53 <dons> Layout.hs:    handleMessage (Mirror l) = fmap (fmap Mirror) . handleMessage l
13:48:59 <dons> man, i love fmap so bad.
13:49:06 <chessguy_work> @type maybe (return Nothing) (fmap (fmap ?stag) . uncurry ?pointScreen)
13:49:07 <lambdabot> forall a b (f :: * -> *) a1 b1. (?pointScreen::a1 -> b1 -> f (Maybe a), Functor f, ?stag::a -> b, Monad f) => Maybe (a1, b1) -> f (Maybe b)
13:49:09 <dons> i was a liftM man, but sjanssen put me onto a good thing.
13:49:33 <chessguy_work> hey look...Functor f => ...
13:49:34 <vixey> :t (fmap (fmap ?stag) . uncurry ?f)
13:49:35 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) a1 b1. (?f::a1 -> b1 -> f1 (f a), Functor f1, Functor f, ?stag::a -> b) => (a1, b1) -> f1 (f b)
13:49:37 <dons> just random fmap snippets not a polymorphic-in -the-functor type from xmonad
13:49:48 <dons> i'm sure you can float it out if there's no surrounding context.
13:49:51 <sbahra> What is "?x"?
13:50:06 <Holle_> vixey: now "glGameState <- newIORef initGame" won't work anymore :/
13:50:19 <vixey> Holle_, that's fine
13:50:32 <chessguy_work> dons, i think you're making the same point i am, you just don't realize it
13:50:35 <mauke> newIORef =<< initGame
13:51:27 <sbahra> Ok, I meant to ask, what does "?f" mean?
13:51:27 <Holle_> works :)
13:51:36 <chessguy_work> sbahra, it tells lambdabot that there's some value there, and lets it figure out the type
13:51:39 <pumpkin> sbahra: in @type it tells you the type
13:51:46 <sbahra> chessguy_work, ah, ok.
13:51:49 <sbahra> Useful.
13:51:55 <vixey> mmorrow are you still around?
13:51:58 <Holle_> mauke: what does =<< do?
13:52:03 <mauke> heh
13:52:08 <sbahra> @src (=<<)
13:52:08 <lambdabot> f =<< x = x >>= f
13:52:10 <chessguy_work> sbahra, i think it's called "implicit type" or something
13:52:24 <sbahra> chessguy_work, thanks
13:52:38 <mauke> Holle_: combines an IO action and a function into a single IO action
13:52:55 <Holle_> sounds crazy ^^
13:53:02 <mauke> which, when executed, runs the first action, calls the function with the result, then executes the action returned by the function
13:53:36 <mauke> in your case, it runs initGame and calls newIORef with the result
13:54:08 <gwern> dcoutts_: I figured out why cabal install didn't work with gitit and caused that containers error when runhaskell did; my runhaskell aliases enable profiling, while my .cabal/config turned off profiling of executables
13:54:10 <leimy> BMeph: what's SMTL?
13:54:16 <BMeph> Just curious, but is there somewhere that lists all of the monads that *aren't* in MonadPlus? :)
13:54:16 <pumpkin> you could've done it pointfully with x <- newIORef; initGame x
13:54:17 <Holle_> great!
13:54:37 <BMeph> leimy: Show Me The Link :)
13:54:42 <leimy> ah
13:54:53 <leimy> I'm just reading my inbox :-)
13:54:55 <pumpkin> @ pl . undo x <- newIORef; initGame x
13:54:59 <pumpkin> @. pl . undo x <- newIORef; initGame x
13:54:59 <lambdabot> Plugin `compose' failed with: Unknown command: "x"
13:55:03 <BMeph> leimy: (or Send)
13:55:08 <pumpkin> @@ @pl @undo x <- newIORef; initGame x
13:55:08 <lambdabot>  Parse error at "<-" (column 3)
13:55:10 <leimy> This one fella doesn't like having to grasp new concepts in Haskell
13:55:11 <mauke> more like g <- initGame; glGameState <- newIORef g
13:55:17 <leimy> like Monad or Monoid
13:55:21 <pumpkin> oh whoops
13:55:24 <gwern> dcoutts_: of course, this doesn't tell me why non-profiled executables want to pull on containers 2.0.0.1 or whatever...
13:55:28 <leimy> and thinks "real programmers" are put off by it.
13:55:31 <BMeph> leimy: So, which OCalm thread are you reading? :)
13:55:45 <leimy> Comments from OCaml Hacker Brian Hur
13:55:45 <vixey> Ocalm :)
13:55:46 <leimy> t
13:55:57 <leimy> It's just going and going
13:55:57 <vixey> Haskalmdown
13:56:01 <mauke> @undo do { g <- initGame; glGameState <- newIORef g; return glGameState }
13:56:01 <lambdabot> initGame >>= \ g -> newIORef g >>= \ glGameState -> return glGameState
13:56:06 <leimy> there was some kind of claim that Monoids aren't used or something
13:56:13 <mauke> @. pl undo do { g <- initGame; glGameState <- newIORef g; return glGameState }
13:56:13 <lambdabot> newIORef =<< initGame
13:56:13 <leimy> then he said "ok how many Monoids are there"
13:56:21 <BMeph> vixey: I could call it OCrazy, but... ;)
13:56:22 <leimy> it's just like feed the troll day or something.
13:56:41 <leimy> He comes close to making a valid point once in a while, but then gets filed away in my crazy bin.
13:56:49 <pumpkin> mauke: thanks :)
13:57:02 <leimy> You'd think all programmers were born that way
13:57:07 <dcoutts> gwern: I'm not sure how that would cause the problem, do you know?
13:57:10 <vixey> leimy, some do not want to hear, and cannot be reached
13:57:12 <leimy> like able to program
13:57:32 <polveroj> is there a way to make an infinite lazy set/map out of an infinite sorted list?
13:57:41 <leimy> vixey: I'm just a bit saddened by the fact that computer programming has less and less to do with computer science apparently.
13:57:55 <leimy> If I could program with boobs and porn I would, but it doesn't work that way.
13:57:57 <vixey> computer science  or  computing science ?
13:58:24 <angelixd> select beer from fridge where label != domestic;
13:58:31 <leimy> woot!
14:01:47 <augustss_> Seems monoids are even scarier than monads.
14:01:52 <dons> heh
14:02:12 <dons> no, it just hits the pet topic of naming and abstraction
14:02:38 <angelixd> the irony is that monoids are even simpler in terms of mathematical complexity
14:02:55 * vixey has come across monoids in algebra but never monads
14:03:11 <vixey> only computer related things I came across monads
14:03:16 <vixey> computing*
14:04:35 <mux> I wish people were interested in my space leak problem as much as they are in monoids ;-)
14:05:21 <augustss_> I think people agree thay monads are simple.  But they need a new name because the old one comes from maths.
14:05:44 <beelsebob> augustss_: I think actually that's the biggest point of disagreement
14:06:03 <beelsebob> 50% of haskellers say that, 50% say they need to stay named monads, and people need to learn their maths if they expect to be programmers
14:06:06 <Holle_> vixey: http://hpaste.org/13962#a2 how do i create different random numbers in list comprehension
14:06:06 <augustss_> I don't think anyone claimed monoids are difficult
14:06:09 <angelixd> augustss_: so does pretty much everything else in haskell, from what i've seen
14:06:13 <beelsebob> augustss_: no, certainly not
14:06:23 <augustss_> Sorry, I meant to say monoids.
14:06:31 <vixey> Holle_, I never use a list comprehension really
14:06:45 <dons> hehe
14:07:40 <vixey> Holle_, I could probably tell you how to do it without list comprehensions
14:07:56 <Holle_> that would also be nice :9
14:07:56 <vixey> > length [0..3]
14:07:57 <Holle_> :)
14:07:57 <lambdabot>   4
14:08:24 <vixey> Holle_, so you want to make  length getMap + 1  AreaState's each with a new random thing.. in them..
14:08:51 <vixey> Holle_, so the first step is to reduce this problem to producing _one_ AreaState with a random thing, so you have to choose a name for a function that will do that
14:09:08 <Holle_> newArea
14:09:20 <vixey> what's the type of AreaState ?
14:09:53 <Holle_> AreaState is a record
14:11:03 <Holle_> http://hpaste.org/13962#a3
14:11:37 <vixey> Holle_, well I can figure from that paste its: AreaState :: Int -> Int -> Int -> State -> AreaState
14:11:56 <Holle_> yes
14:13:06 <vixey> Holle_, for the moment it's probably easiest to have newArea take the parametrs: sIndex, sUnits, sSelect.. but generate the random sOwner. so it will have type Int -> Int -> State -> IO AreaState
14:13:19 <vixey> Holle_, (do you know how to write it?)
14:13:25 <kmeyer> wow, flamewar on haskell-cafe
14:13:50 <Holle_> i'll try
14:13:54 <vixey> Holle_, ok
14:14:34 <vixey> Holle_, once you have it something also useful would be a function,  IO a -> Int -> IO [a],  which produces however many of the IO a's in a list
14:14:46 <vixey> (you can write it with sequence and replicate I guess)
14:15:41 <Holle_> what are the border of randomRIO?
14:16:18 * vixey thinks eta conv. is impossible to implement
14:18:57 <blackh> Oh dear. The company I work for has had a sudden crisis and I am suddenly out of work. Can anyone help give me an idea of the landscape of possible paid employment in Haskell? Unfortunately I don't live in one of the "big countries".
14:19:24 <pumpkin> :(
14:19:27 <pumpkin> sorry to hear that
14:19:37 <ehird> :{
14:19:46 <gwern> @src lookup
14:19:46 <lambdabot> lookup _key []          =  Nothing
14:19:46 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
14:19:46 <lambdabot>                         | otherwise = lookup key xys
14:19:52 <blackh> There are some great things about working for start-ups, I have to say. :)
14:19:53 <gwern> blackh: not too great I'd guess
14:20:08 <ehird> blackh: Wellll... um... galois...? That's really all I can think of XD
14:20:33 <kmeyer> mgsloan: ping
14:20:34 <blackh> gwern: Yes, I get that feeling. I am not worried, because Haskell is the way of the future, but I have to take care of the present right now. :)
14:20:36 <pumpkin> blackh: there's a list on the haskell wiki of haskell in industry, but that doesn't give you an idea of the available jobs in each company, unfortunately
14:21:05 <gwern> hm, I guess lookup isn't too fast
14:21:07 <mgsloan> kmeyer: sup?
14:21:20 <kmeyer> mgsloan: I'm in your 341 class
14:21:37 <pumpkin> :o
14:21:39 <pumpkin> epic stalk
14:21:42 <kmeyer> pfff
14:21:43 <Twey> Hahaha
14:21:50 <kmeyer> he wrote on a class forum and mentioned mauke
14:21:54 <mgsloan> kmeyer - haha nice
14:22:01 <gwern> im in ur class pwning ur notes
14:22:13 <pumpkin> kmeyer: "... and I'm sitting behind you right now, watching how my messages affect that vein on the back of your neck... mmm" ;)
14:22:13 <Twey> mauke: connecting people
14:22:15 <ehird> im in the same class!*
14:22:15 <Holle_> vixey: http://hpaste.org/13962#a4 the same problem :(
14:22:16 <ehird> *lie
14:22:21 <kmeyer> :D
14:22:21 <dons> man, let people loose and the mailing list goes nuts :/
14:22:27 <mgsloan> lol he might be if he's in the 002 lab ;P
14:22:36 <kmeyer> nope, in the dorms
14:23:06 <RudyGuillan> hello ^^
14:23:09 <saml> > go <$> back
14:23:11 <gwern> 'hasExtension                   Text.Highlighting.Kate.Syntax   1.4    6.7
14:23:11 <lambdabot>   Not in scope: `go'Not in scope: `back'
14:23:13 <gwern> absurd
14:23:19 <jeffwheeler> What school?
14:23:26 <kmeyer> U of Washington
14:23:29 <blackh> pumpkin, ehird & gwern: Thanks.
14:23:29 <jeffwheeler> ah
14:23:34 <gwern> a trivial string processing function like that eating 6.7%...
14:23:37 <pumpkin> blackh: sorry can't help more :/
14:23:46 <ehird> blackh: start a startup that specializes in haskelling haskell with haskell.
14:23:56 <Twey> Haha
14:23:57 <blackh> ehird: That's exactly what I am doing!
14:24:03 <ehird> blackh: See, synergy!
14:24:04 <gwern> :t lookup
14:24:05 <blackh> I will have jobs for all of you!
14:24:05 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
14:24:08 <blackh> But not yet.
14:24:09 <Twey> Hooray!
14:24:11 <Twey> Aw.
14:24:18 <ehird> blackh: Wait wait, start a startup whose goal is to give jobs to haskell programmers
14:24:25 * Twey laughs.
14:24:30 <Twey> A Haskell-programmer agency!
14:24:32 <ehird> "Our mission: Are you a Haskell programmer? Do you need a job? We will employ you!"
14:24:35 <pumpkin> like fog creek but for haskell
14:24:39 <ehird> pumpkin: LOL
14:24:45 <Twey> :-D
14:24:46 <gwern> > lookup 'a' [('b', 'c'), ('c', 'c'), ('a', 'a')]
14:24:48 <lambdabot>   Just 'a'
14:24:49 <pumpkin> minus the fog creek products :P
14:24:53 <blackh> ehird: "If you can get it past the compiler, then it's Good Code."
14:24:56 <RudyGuillan> I have a question about lists in Haskell. I'm quite newbie, so maybe the answer is so obvious.
14:24:58 <ehird> wait wait, fog creek have PRODUCTS?!
14:24:59 <ehird> ;)
14:25:12 <gwern> there ought to be something faster than lookup
14:25:14 <Twey> RudyGuillan: That's the kind we like ;)
14:25:17 <Twey> gwern: A map
14:25:18 <gwern> data.map perhaps
14:25:21 <pumpkin> ehird: nope, fog creek has awesome chairs, desks, offices, and random stuff, but no products of any interest :P
14:25:22 <Twey> Yes
14:25:35 <ehird> pumpkin: yeah but you have to sit around with joel spolsky all day
14:25:38 <Holle_> vixey: why it is so complicated to generate a few numbers?
14:25:47 <pumpkin> ehird: sounds like an interesting guy at least :)
14:25:54 <ehird> yeah... interesting... :P
14:25:57 <RudyGuillan> I want to make a function that do this:      [True, True, True, True] 2  ----> [True, True, False, True]
14:26:03 <gwern> I've never heard of anyone who's actualy used their bug tracker
14:26:03 <pumpkin> ehird: I didn't even mean it as a euphemism :)
14:26:06 <vixey> Holle_, you are learning a bit more than just how to generate some numbers
14:26:20 <saml> RudyGuillan, why?
14:26:22 <pumpkin> gwern: same here :P I have no idea how they have so much money to spend on spoiling their employees, but I'm all for it if they can afford it :P
14:26:40 <saml> RudyGuillan, what's 2?
14:26:42 <RudyGuillan> it's more complex, but that's the idea
14:26:49 <RudyGuillan> the index in the list
14:26:50 <vixey> saml, 2 is a number
14:27:00 <pumpkin> lol, I love the latest message on the large thread in cafe
14:27:15 <pumpkin> (the ocaml one)
14:27:16 <saml> > let f [True, True, True, True] = [True, True, False, True]  in f [True, True, True, True]
14:27:18 <lambdabot>   [True,True,False,True]
14:27:29 <RudyGuillan> I codad that function with comprehenssion lists, but it's too slow
14:27:35 <Peaker> > let f 5 = 1 in f 2
14:27:37 <lambdabot>   * Exception: /tmp/7932814933631963877:71:48-54: Non-exhaustive patterns in ...
14:27:47 <RudyGuillan> *I coded
14:28:10 <Holle_> vixey: it's hopeless :/ http://hpaste.org/13962#a4
14:28:20 <RudyGuillan> no, what I want to do is a function that modifies a value in a list, and returns that list
14:28:30 <vixey> Holle_, you have almost written it
14:28:33 <Peaker> RudyGuillan: just a specific value?
14:28:44 <Holle_> vixey: but in will not work
14:28:50 <RudyGuillan> yes
14:29:00 <RudyGuillan> the value specified by the parameter
14:29:01 <vixey> Holle_, it will once you fix a couple of things
14:29:02 <Peaker> RudyGuillan: by a specific numeric index in the list?
14:29:08 <RudyGuillan> yes
14:29:15 <Holle_> what's wron?
14:29:20 <Twey> Holle_: getRandomAreaState = do st <- getStdGen; return $ AreaState 1 2 (random st) someState
14:29:55 <blackh> RudyGuillan: The function you want is !! in the Prelude.  If performance is an issue you will have to use arrays or mutable arrays instead of lists.
14:30:16 <blackh> RudyGuillan: No it isn't!!  I'm having a bad day!
14:30:22 <RudyGuillan> haha
14:30:39 <RudyGuillan> ok, I know that function, but that I want to do is
14:30:41 <blackh> RudyGuillan: You'll need to write it yourself if it's a list.
14:30:43 <Baughn> > 3 `mappend` 4
14:30:45 <lambdabot>   Add a type signature
14:31:09 <RudyGuillan> myList !! index = SOMETHING; return myList
14:31:11 * Baughn blinks. Um.. are there options?
14:31:23 <blackh> RudyGuillan: If you want performance, you might also consider a Data.Map
14:31:24 <Baughn> @instances Monoid
14:31:25 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
14:31:37 <RudyGuillan> but... in functional programming isn't so easy xD
14:31:49 <Twey> > yourFunc n xs = take n xs ++ False : drop (n + 1) xs
14:31:51 <lambdabot>   <no location info>: parse error on input `='
14:31:51 <blackh> RudyGuillan: Make that an Data.IntMap
14:31:52 <Twey> Er
14:32:02 <Twey> Yeah, shush lambdabot, instinct :-P
14:32:10 <olsner> @ty 3 `mappend` 4
14:32:12 <lambdabot> forall t. (Monoid t, Num t) => t
14:32:22 <RudyGuillan> I'll try your approach, twey
14:32:33 <RudyGuillan> now it sounds obvious xD
14:32:36 <Twey> There's probably a Prelude function for it, to be honest
14:32:46 <olsner> > (mappend `on` Product) 3 4
14:32:47 <lambdabot>   Product {getProduct = 12}
14:32:52 <blackh> Twey: There isn't.
14:33:25 <Twey> @hoogle Int -> a -> [a] -> [a]
14:33:25 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
14:33:25 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
14:33:25 <lambdabot> Distribution.ParseUtils IfBlock :: LineNo -> String -> [Field] -> [Field] -> Field
14:33:37 <Twey> @hoogle a -> Int -> [a] -> [a]
14:33:38 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
14:33:38 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
14:33:38 <lambdabot> Distribution.ParseUtils IfBlock :: LineNo -> String -> [Field] -> [Field] -> Field
14:33:41 <Twey> Hmph
14:33:56 <blackh> Twey: IntMap is a sensible thing for this problem, if the list is long.
14:34:04 <Twey> But RudyGuillan, if there isn't then there's a reason
14:34:09 <Twey> Yeah, this isn't what lists are for.
14:34:36 <cads> are you guys familiar with paul nylander's mathematical and physics visualization work? here is some of it http://bugman123.com/Fractals/Fractals.html
14:34:47 <Holle_> twey: getRan = do st <- getStdGen; return $ random st doesn't work
14:34:55 <cads> he uses C++ for a lot of his prettier graphics stuff, which makes me sad
14:35:02 <Twey> Holle_: Define 'doesn't work'
14:35:08 <Botje> :t getStdGen >>= return . random
14:35:09 <lambdabot> forall a. (Random a) => IO (a, StdGen)
14:35:21 <harovali> is it possible to do partial evaluation on non-last arguments of a function?
14:35:23 <Botje> Holle_: it compiles, at least
14:35:26 <cads> do you guys think it would be realistic to use haskell to create graphics like that?
14:35:29 <Botje> harovali: use flip liberally
14:35:51 * Twey chuckles.
14:35:55 <Twey> cads: Of course
14:35:56 <Botje> @pl (\a -> f 1 2 3 a)
14:35:56 <lambdabot> f 1 2 3
14:36:07 <vixey> Holle_, type errors should be a description of what went wrong
14:36:07 <Botje> @pl (\a -> f a 2 3 4)
14:36:07 <lambdabot> flip (flip (flip f 2) 3) 4
14:36:22 <cads> the problem I can anticipate would have to be the libraries, but I want to believe that that's not so much of a problem
14:36:26 <Twey> It would be nice to have a _ free argument, I think
14:36:46 <cads> I haven't found much in the way of graphical things in haskell
14:36:47 <Twey> foo a b _ c instead of flip (foo a b) c
14:36:51 <Twey> cads: There's plenty
14:36:54 <Holle_> ambiguous type variable 'a' in the constraint: 'Random a' arising from a use of 'random' at ...
14:37:07 <Twey> Holle_: Add a type signature, then
14:37:11 <Twey> (random :: Int)
14:37:16 <Twey> Er
14:37:20 <Twey> (random st :: Int)
14:37:43 <cads> Twey, I want to find them! I think I shall! ... haskell's ways could be so great for graphics
14:38:02 <Twey> cads: http://www.haskell.org/haskellwiki/Applications_and_libraries/Graphics
14:38:14 <Twey> There're probably more on Hackage
14:38:48 <cads> hmm
14:39:13 <pumpkin> can someone comment on "In fact, in the old days, [(x,y) |x <- [1, 2], y <- [3, 4]] was actually syntactic sugar for the above code (ie, list comprehensions were actually arbitrary monad comprehensions).
14:39:13 <pumpkin> For some reason this was deprecated." ?
14:39:28 <dons> there's an awful lot of graphics libs on hackage, cads
14:39:29 <Twey> 'I wish it wasn't'?
14:39:34 <ddarius> That is the case.
14:39:35 <Holle_> couldn't match expected type 'Int' against inferred type 'a b' http://hpaste.org/13962#a5
14:39:40 <ddarius> See the Haskell 1.4 Report.
14:39:42 <Deewiant> Haskell 98 killed a lot of polymorphism :-/
14:39:48 <pumpkin> ddarius: I mean ,why was it removed?
14:40:01 <pumpkin> it seems like a nice thing :)
14:40:12 <pumpkin> are there cons to doing that?
14:40:15 <Deewiant> pumpkin: to clarify: Haskell 98 was afraid of polymorphism
14:40:17 <ddarius> pumpkin: You can check the mailinglists for details and an authoritative source, but what I've heard was mainly that it was confusing to beginners.
14:40:26 <Twey> Can we have it back for Haskell'?
14:40:27 <pumpkin> ddarius: ugh
14:40:29 <cxbv> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
14:40:31 <cxbv> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
14:40:33 <cxbv> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
14:40:36 <pumpkin> Deewiant: that's unfortunate :/
14:40:37 <ddarius> Where "beginners" here primarily means students.
14:40:43 <Twey> Heh
14:40:49 <RudyGuillan> Twey, that function works
14:40:52 <cads> I think I've been too preoccupied with monads and grokking haskell's syntax to think of haskell doing graphics... it goes to reason that it would be a good platform for graphics, though
14:40:53 <Deewiant> pumpkin: "possibly confusing error messages" seems to be the reason a lot of cool 1.4 stuff was dropped in 98
14:41:01 <RudyGuillan> and it's much more efficient
14:41:07 <pumpkin> Deewiant: :(
14:41:32 <Twey> Deewiant: Sucks
14:41:34 <Holle_> i just want to create a random number... :/
14:41:35 <Twey> We want it back :(
14:41:37 <RudyGuillan> my list is 3-dimensional, so before this function, I had 3 comprehession lists
14:41:38 <pumpkin> Deewiant: are there any GHC options I can use to get that kind of behavior again?
14:41:48 <cads> when I think of haskell a bunch of pseudo-mathematical ascii scrolls in my head, I think it's time to include graphics in the mix!
14:41:57 <Deewiant> pumpkin: not to my knowledge
14:42:03 <Deewiant> pumpkin: use HBC :-P
14:42:10 <cads> thanks for setting me straight, twey, dons.
14:42:24 <Twey> Holle_: randomInt = getStdGen >>= \st -> return $ (random st :: Int)
14:42:27 <Twey> It's not that scary
14:42:50 <RudyGuillan> hey, I used another function, without monads
14:42:59 <Twey> Or you can type the function (better): randomInt :: IO Int; randomInt = getStdGen >>= \st -> return $ random st
14:43:01 <RudyGuillan> to generate an infinite list of random numbers
14:43:06 <Deewiant> And since Haskell prime is pretty much only going to standardize existing GHC extensions (AFAICT) it's not likely to be back any time soon
14:43:25 <Twey> RudyGuillan: With no monads?  How'd you do that?
14:43:27 <pumpkin> Deewiant: not even as GHC-specific extensions?
14:43:28 <wjt> it's not clear to me how exactly generalizing the list comprehension helps anything
14:43:35 <RudyGuillan> rands :: Integer -> [Int]
14:43:36 <Twey> Surely IO has to be involved somewhere, if just to get a seed
14:43:37 <RudyGuillan> rands seed = randoms (mkStdGen $ fromInteger seed)
14:43:40 <ddarius> I wonder if you use -fno-implicit-prelude and define concatMap as (>>=), etc. if that would produce right-ish results.
14:43:46 <wli> Deewiant: Monad comprehensions?
14:43:50 <Twey> Ah, yes
14:43:53 <RudyGuillan> of course, I get the seed with a monad
14:43:55 <Deewiant> wli: yeah
14:44:02 <Deewiant> pumpkin: well sure if somebody implements it and gets it in :-P
14:44:02 <Twey> RudyGuillan: That's all the monad is doing there
14:44:18 <Twey> RudyGuillan: The getStdGen is just getting a 'seed'
14:44:27 <Twey> If you pass that in, the function can be pure
14:44:30 <Holle_> Twey: could't match expected type Int against inferred type (a, StdGen)
14:45:13 <Twey> Oh look, we've got randomIO too
14:45:15 <Twey> I forgot about that
14:45:23 <Twey> Holle_: myInt <- randomIO
14:45:40 <RudyGuillan> the list generated with my function, is an infinite list, a "pure" list
14:45:44 <Twey> (make sure you use it as an Int, or it'll be ambiguous)
14:45:52 <Twey> RudyGuillan: That's called 'randoms'
14:46:07 <RudyGuillan> I get the seed with a monadic operation, like CPUTime
14:46:51 <Twey> RudyGuillan: yourFunction = randoms
14:47:27 <RudyGuillan> LOL, ther is a simple function to do that?
14:47:33 <Twey> Yep
14:47:41 <Twey> do st <- getStdGen {- Getting the 'seed' -}; let pureRandomList = randoms st
14:48:02 <RudyGuillan> there were hours  searching in Google... xD
14:48:06 <Twey> Hehe
14:48:21 <Twey> You should've checked out System.Random instead: http://www.haskell.org/ghc/docs/latest/html/libraries/random/System-Random.html#v%3ArandomIO
14:48:25 <Twey> Er
14:48:27 <Twey> You should've checked out System.Random instead: http://www.haskell.org/ghc/docs/latest/html/libraries/random/System-Random.html#v%3Arandoms
14:48:43 <blackh> RudyGuillan: You can even "split" your random number generator and get multiple infinite lists. I learnt that from RWH. :)
14:48:51 <RudyGuillan> I don't understand that kind of documentation
14:48:53 * cads is finally starting to feel like haskell is something that he could use for everyday coding situations
14:49:09 <RudyGuillan> my haskell is very basic
14:49:19 <Twey> RudyGuillan: The System.Random docs are a bit of a bugbear, I agree
14:49:25 <Twey> It took me some examples to get them
14:49:30 <Twey> You can find them on Google
14:49:31 <dons> cads: yay. welcome to the club.
14:50:36 <RudyGuillan> well, my program is finished, and now it's reasonably fast
14:50:52 <blackh> RudyGuillan: Great! What does it do?
14:50:52 <RudyGuillan> a perfect maze generator, my first non-trivial program in haskell
14:51:00 <jeffwheeler> > let as = replicate 5 'a' in as ++ as
14:51:02 <lambdabot>   "aaaaaaaaaa"
14:51:10 <jeffwheeler> In something like that, is replicate called twice?
14:51:13 <jeffwheeler> Or is the result cached?
14:51:25 <jeffwheeler> (In GHC, with ordinary settings.)
14:51:28 <mauke> you bound it to a name; it's only computed once
14:51:39 <jeffwheeler> mauke: yay! Thanks.
14:51:54 <jeffwheeler> Is that true with something like this?
14:52:01 <dons> RudyGuillan: using ghc -O2 to build it?
14:52:07 <jeffwheeler> > let as c = replicate c 'a' in (as c) ++ (as c)
14:52:08 <lambdabot>   Couldn't match expected type `Int' against inferred type `Expr'
14:52:08 <jeffwheeler> err
14:52:13 <jeffwheeler> > let as c = replicate c 'a' in (as 5) ++ (as 5)
14:52:14 <lambdabot>   "aaaaaaaaaa"
14:52:23 <jeffwheeler> Would that also cache the result?
14:52:29 <Twey> jeffwheeler: It's cached
14:52:32 <mauke> no
14:52:34 <RudyGuillan> using the profiler, yet
14:52:35 <Twey> let always shares work
14:52:51 <jeffwheeler> and I assume 'where' is the same way?
14:52:55 <Twey> (if the value takes no arguments)
14:53:13 <Twey> jeffwheeler: Within the same function call, obviously, I think so, yes.
14:53:27 <jeffwheeler> Sweet, thanks.
14:55:12 <cads> dons, I am not a ruby on rails programmer. Just saying. But is there a program that is in haskell what rails is on ruby?
14:55:32 <pumpkin> turbinado is working towards that
14:55:37 <Twey> Hm... we have HaPPs
14:55:43 <Twey> Turbinado eh *searches*
14:56:09 <evident> hello everybody!
14:56:12 <pumpkin> I think it's more rails-like than happs, from what I've seen
14:56:14 <pumpkin> hi evident!
14:56:58 <cads> I am betting that haskell can do a lot of the magic that rails can do, and in static compiled code
14:57:32 <Twey> Interesting, pumpkin
14:57:36 <dons> there's a bunch of web frameworks.
14:57:40 <ehird> Rails did not invent web frameworks.
14:57:40 <cads> and haskell coders would document things in a way easier to understand for mathematicians!
14:57:41 <blackh> cads: What kind of magic can rails do? (I have python knowledge.)
14:57:48 <chessguy> wchogg:  ping?
14:57:49 <Twey> cads: *laughs*
14:57:52 <pumpkin> Twey: the developer hangs out in here
14:57:56 <ehird> blackh: it can write a blog in 15 MINUTEZS!
14:58:14 <dolio> Formal mathematics is lame, am I right?
14:58:15 <wli> Any sufficiently advanced language renders frameworks superfluous.
14:58:30 <pumpkin> dolio: apparently
14:58:34 <sdf> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
14:58:36 <sdf> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
14:58:38 <sdf> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
14:58:40 <pumpkin> again?
14:58:46 <Twey> We just had that one
14:58:47 <chessguy> @op
14:58:47 <lambdabot> Maybe you meant: . ? @ bf ft id map pl rc v wn yow
14:58:49 <vixey> sounds like an awesome channel
14:58:49 <ehird> sdf: Wait, wait, you mean #ubuntu-tr?!
14:58:51 <Twey> Show us something interesting :(
14:58:52 --- mode: ChanServ set +o mauke
14:58:52 <Deewiant> @where ops
14:58:52 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
14:58:55 <ehird> Can you tell us ag-
14:58:58 <ehird> Dammit mauke :(
14:58:58 <vixey> #ubuntu-spammming-morons
14:59:01 --- mode: ChanServ set +o dcoutts
14:59:07 <Twey> Haha
14:59:18 <chessguy> thanks Deewiant
14:59:20 <angelixd> i wonder exactly how an ORM would work in haskell
14:59:22 * ehird gives #ubuntu-tr a round of "#haskell #haskell #haskell #haskell #haskell #haskell  #haskell  #haskell"
14:59:22 --- mode: mauke set -o mauke
14:59:29 <Deewiant> I was too slow though
14:59:32 <Twey> angelixd: So do I *investigates*
14:59:33 <chessguy> angelixd:  no doubt it would be a monad :)
14:59:35 <Twey> ehird: :-D
14:59:42 --- mode: ChanServ set -o dcoutts
14:59:43 <Twey> Ooh, yes, likely
14:59:45 <wli> ehird: Just tell them Ataturk programmed in Haskell.
14:59:47 <cads> blackh, well essentially it blaps a whole object relational framework together using metaprogramming, which is magical in itself, though I'm not really sure on the details
15:00:02 <ehird> You could hack something with Typeable, easy
15:00:11 <allbery_b> hm, just a bit late I see
15:00:23 <allbery_b> at least you get fast service here :)
15:00:34 <cads> the idea being that you extend the generated classes for your domain
15:00:51 <Twey>    pages <- findAllWhereOrderBy "_id like ?" [toSql $ prefix ++ "%"] "title"
15:01:03 <cads> and it has some very neat methods you call for constructing classes
15:01:10 --- mode: ChanServ set +o dcoutts
15:01:10 <blackh> cads: Ah. The whole object/relational problem. I am an SQL-hater, so I will do anything to avoid SQL. :)
15:01:21 <cads> I have been too so far
15:01:30 <cads> in fact I just can't grok the damn thing
15:01:35 <Twey> Heh
15:01:41 --- kick: ratta was kicked by dcoutts (dcoutts)
15:01:41 <cads> I'd rather study category theory
15:01:42 <Twey> SQL's quite nice really
15:01:45 <blackh> cads: Time for some evangelism: Berkeley DB XML blah blah blah!
15:01:47 <Twey> Relatively speaking
15:01:59 * mauke can thwap people faster, thanks to http://mauke.ath.cx/stuff/irssi/chanserv_auto_op.pl
15:01:59 <sjanssen> why would someone spam #ubuntu-tr in #haskell?
15:02:08 <cads> twey, I love that there's solid theory behind databases and ORM
15:02:10 <pumpkin> sjanssen: they're doing it everywhere
15:02:13 --- mode: dcoutts set +b *!*n=rya@88.231.173.*
15:02:16 <sjanssen> why?
15:02:23 <dolio> sjanssen: Some men just want to watch the world burn.
15:02:25 <pumpkin> sjanssen: not a clue, several people seem to be complaining in #freenode
15:02:25 <pshc_> Damn, I wish I could automatically derive Enum for non-nullary ctors :(
15:02:38 * wli wonders what SQL is supposed to do that logic languages don't (essentially so a logic language can be augmented with such).
15:02:40 <roconnor> So we have Monoid used in Writer, Foldable, and I'd like to add FingerTrees.  Anywhere else generic monoids are used?
15:02:47 <cads> I think if I learned in a framework more touched by the theory I'd do fine
15:02:54 <sjanssen> seems like a good way to get your (seemingly legit, otherwise) on the bad side of IRCops
15:03:22 --- mode: ChanServ set +o mauke
15:03:24 <ehird> 23:01 <blackh> cads: Time for some evangelism: Berkeley DB XML blah blah blah!
15:03:25 <pumpkin> sjanssen: the variety of IPs they've been using probably means they don't care and have lots more IPs to burn
15:03:28 <ehird> um.
15:03:36 <ehird> That's _worse_ than SQL...
15:03:38 <dolio> roconnor: Monoid w => (->) w comonad.
15:03:42 <sjanssen> roconnor: it's vaporware at the moment, but I'd like to use general Monoid ops for xmonad configuration
15:03:52 --- mode: mauke set -o mauke
15:03:53 <vixey> wli, I think that it's much more specific.. so optimized in certain ways, and just compared to Prolog, the way queries compose is much different
15:04:29 <Holle_> i don't know what to do... coul anyone please hpaste a working random function?
15:04:35 <roconnor> dolio: that's good.
15:04:40 * wli briefly notes that SQL itself qualifies as a logic language and/or having a logic sub-language.
15:04:43 <roconnor> sjanssen: that is surprising
15:05:02 <jalaa> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
15:05:04 <jalaa> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
15:05:04 <chessguy> Holle_:  random numbers in haskell are different. you have to be willing to set aside your preconceptions of how ti should work
15:05:06 <jalaa> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
15:05:29 --- mode: ChanServ set +o mauke
15:05:29 <cads> is xmonad interoperable with the gnome panels?
15:05:33 <sjanssen> roconnor: basically, we have several settings that each have a concept of empty/default and combination -- keymaps, logHooks, manageHooks, etc.
15:05:35 <mauke> gee
15:05:36 <sjanssen> cads: yes
15:05:41 <roconnor> dolio: is that the reader comonad?
15:05:53 <dolio> Uh. Cowriter, maybe?
15:06:04 <dolio> I'm not sure anyone's given a proper name to it.
15:06:11 <chessguy> Holle_:  take a look at http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Randoms
15:06:12 <dolio> But if (,) r is coreader...
15:06:19 * wli /ignores *!*@88.231.*.* ALL
15:06:25 <sjanssen> roconnor: so I want to use FRefs and Monoid to enable something like: do add Layout Full; add keys [blah blah blah]
15:06:54 <cads> sjanssen, is configuration of if simple enough, or might I want to ask around for someone's config file?
15:06:55 <roconnor> @where+ Monoid Monoid is used in Writer monad, -> (w) writer comanad(?), FingerTrees, and Foldable.
15:06:56 <lambdabot> It is forever etched in my memory.
15:07:01 <roconnor> @where Monoid
15:07:02 <lambdabot> Monoid is used in Writer monad, -> (w) writer comanad(?), FingerTrees, and Foldable.
15:07:27 <roconnor> @where+ Monoid Monoid is used in Writer monad, (->) w (Writer Comanad?), FingerTrees, and Foldable.
15:07:28 <lambdabot> It is stored.
15:07:30 <roconnor> @where Monoid
15:07:31 <lambdabot> Monoid is used in Writer monad, (->) w (Writer Comanad?), FingerTrees, and Foldable.
15:07:37 <roconnor> ugh
15:07:42 <roconnor> @where+ Monoid Monoid is used in Writer monad, (->) w (Writer Comonad?), FingerTrees, and Foldable.
15:07:43 <lambdabot> Done.
15:07:43 <dolio> Comonad.
15:07:44 --- mode: ChanServ set +o glguy
15:07:48 <roconnor> @where Monoid
15:07:48 <dolio> Yeah.
15:07:49 <lambdabot> Monoid is used in Writer monad, (->) w (Writer Comonad?), FingerTrees, and Foldable.
15:07:59 * roconnor nods
15:08:02 <pumpkin> @where Foldable
15:08:03 <lambdabot> I know nothing about foldable.
15:08:08 --- mode: glguy set -b+b *!*n=rya@88.231.173.* *!*@88.231.174.221
15:08:13 --- mode: glguy set -o glguy
15:08:22 <roconnor> @where FingerTree
15:08:23 <lambdabot> I know nothing about fingertree.
15:08:32 <vixey> @where moon
15:08:32 <lambdabot> I know nothing about moon.
15:08:48 <roconnor> @hackage fingertree
15:08:48 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fingertree
15:08:55 <loadquo_> @where love
15:08:55 <lambdabot> I know nothing about love.
15:09:01 <hallongrottan> =(
15:09:35 <Zao> Is there anyone with Windows 7 installed here?
15:09:40 --- mode: mauke set -o mauke
15:10:16 <roconnor> @where+ love http://en.wikipedia.org/wiki/Where_Is_Love%3F
15:10:17 <lambdabot> Nice!
15:10:39 <dolio> Technically the MonadPlus instance for Either e and such could use monoidal es, but it goes with the fancier Error class.
15:10:58 <chessguy> @pl c f = \a -> c (f a)
15:10:58 <lambdabot> c = fix (.)
15:11:09 <roconnor> dolio: ya, that kinda pisses me off
15:12:07 <chessguy> heh, check out the code at the bottom of http://stackoverflow.com/questions/413930/haskell-how-to-compose-not-with-a-function-of-arbitrary-arity
15:13:13 <evident> i have a little problem with working with infinite lists... do you have any ideas?: http://hpaste.org/13964
15:13:23 <jeffz`> Zao, yes
15:14:21 <Zao> jeffz`: Does ghci in 6.10 work for you when launched from the start menu?
15:14:43 <roconnor> chessguy: "What am I doing wrong?" God damn monomorphism restriction strikes again
15:15:01 <chessguy> roconnor:  yeah, i like the Predicate solution though
15:15:05 <Holle_> how to make a list of random numbers? http://hpaste.org/13965
15:15:07 <jeffz`> Zao, haven't installed it - I can try though.
15:15:22 <chessguy> evident:  that should (i think) be fairly easy to do using zipWith
15:15:27 <vixey> Holle_, did you get one random now?
15:15:33 <Holle_> http://hpaste.org/13965
15:15:35 <vixey> Holle_, I mean your paste works?
15:15:38 <pumpkin> we have more users than #python right now :)
15:15:40 <Holle_> yes :)
15:15:41 <Holle_> ^^
15:15:44 <vixey> Holle_, good!
15:15:52 <vixey> Holle_, so next to write:  IO a -> Int -> IO [a]
15:15:55 <roconnor> pumpkin: if I join to check, will it still be true?
15:15:59 <evident> nobody got an idea to my problem?
15:16:06 <vixey> Holle_, lets say...  generate :: IO a -> Int -> IO [a]
15:16:12 <evident> http://hpaste.org/13964
15:16:13 <pumpkin> roconnor: nope, head-to-head now :P
15:16:16 <vixey> Holle_, so generate m i = ...
15:16:27 <vixey> Holle_, and it will use  sequence  as well as  replicate..
15:16:29 <vixey> :t sequence
15:16:30 <chessguy> @type let crossProduct s1 s2 = [(e1,e2) | e1 <- s1, e2 <- s2] in crossProduct
15:16:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:16:30 <pumpkin> roconnor: I dare you to go in there and tell a joke to try to get people to lol and get kicked though :P
15:16:31 <lambdabot> forall t t1. [t] -> [t1] -> [(t, t1)]
15:16:32 <vixey> :t replicate
15:16:33 <lambdabot> forall a. Int -> a -> [a]
15:16:44 <pumpkin> (they have a lolbot that kicks people if they say lol)
15:16:58 <vixey> Holle_, so with replicate.. you can make a list of  [IO a] and then sequence it to make IO [a]
15:17:06 <Zao> pumpkin: What if someone invents a lolomorphism?
15:17:16 <chessguy> evident:  posting the same thing repeatedly is not a good way to get help
15:17:19 <pumpkin> Zao: lucky python has mo *morphisms
15:17:20 <pumpkin> :P
15:17:24 <vixey> Holle_, then.....   generate (ranInt 0 10) 12  will make 12 randoms between 0-10
15:17:34 <evident> well sorry i thought nobody noticed it...
15:17:48 <Zao> jeffz`: That would be nice.
15:18:09 <roconnor> evident: ah, you want to take a convolution of two lists
15:18:14 <evident> but what does that show me, chessguy?
15:18:17 <chessguy> evident:  try using zipWith and [n..1] (or [(n-1)..0]
15:18:48 <pumpkin> evident: or use Control.Monad.Omega
15:18:53 <pumpkin> which diagonalizes for you
15:19:27 <roconnor> wait, does evident want all diagonals, or just one diagonal?
15:19:28 <evident> what is Control.Monad.Omega?
15:19:29 <chessguy> evident:  you want [elem1 !! (n+1), elem2 !! n, elem3 !! (n-1)..]
15:19:34 <evident> just one diagonal
15:19:38 <pumpkin> oh
15:19:40 <pumpkin> then not :)
15:19:48 <Holle_> works :)
15:19:55 <Holle_> wuhu!
15:19:58 <chessguy> roconnor:  an input to his function says what diagonal he wants
15:19:59 <vixey> :p
15:20:01 <gbacon> how can I condense the code at http://hpaste.org/13966 ?
15:20:14 <roconnor> chessguy: ya, Omega isn't approriate for what he wants
15:20:32 <gbacon> I especially don't like two passes with the same comparisons
15:20:35 <roconnor> diag l1 l2 n = zip l1 (reverse (take n l2))
15:20:37 <chessguy> evident:  does my explanation help?
15:20:58 <roconnor> > let diag l1 l2 n = zip l1 (reverse (take n l2)) in diag [1..] [1..] 3
15:20:59 <evident> a bit... what does taht "!!" mean?
15:21:00 <lambdabot>   [(1,3),(2,2),(3,1)]
15:21:05 <jeffz`> Zao: the application failed to initialize
15:21:12 <roconnor> well
15:21:13 <chessguy> roconnor:  err, infinite ists...
15:21:16 <chessguy> +l
15:21:19 <Zao> jeffz`: Thank you. The same as I get.
15:21:19 <roconnor> > let diag l1 l2 n = zip l1 (reverse (take (n+1) l2)) in diag [1..] [1..] 3
15:21:21 <lambdabot>   [(1,4),(2,3),(3,2),(4,1)]
15:21:23 <christo_m> yea what does "!!" mean, i always wanted to know
15:21:25 <Zao> jeffz`: It works from inside a cmd by the way.
15:21:27 <chessguy> @src (!!)
15:21:27 <lambdabot> xs     !! n | n < 0 = undefined
15:21:27 <lambdabot> []     !! _         = undefined
15:21:27 <lambdabot> (x:_)  !! 0         = x
15:21:27 <lambdabot> (_:xs) !! n         = xs !! (n-1)
15:21:28 <roconnor> but I think my original was correct
15:21:34 <gbacon> > [1..3] !! 1
15:21:36 <lambdabot>   2
15:21:43 <roconnor> for some definition of correct
15:21:52 <chessguy> evident:  xs !! n returns the nth element of xs
15:22:00 <chessguy> (for some definition of nth)
15:22:07 <evident> well but I dont use the crossProduct function then at all, or do I?
15:22:15 <chessguy> evident:  sure you do
15:22:18 <vixey> crossProduct = liftA2 (,)
15:22:42 <Peaker> vixey: in that general form, is the name still appropriate?
15:22:50 <bombshelter13> Does anyone know of a project in Haskell using the PortAudio bindings for audio playback? I've got the bindings, and the documentation, but would verymuch enjoy seeing an example of them in use, if anyone knows an application that uses these bindings.
15:22:51 <vixey> you decide
15:22:53 <roconnor> oh oops
15:22:54 <vixey> :t liftA2 (,)
15:22:55 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
15:22:57 <roconnor> apparently I'm cheating
15:22:59 <chessguy> evident:  you want to zip the crossProduct of the lists with [(n+1)..1]
15:23:29 <vixey> :t liftA2 (,) (+1) (*2)
15:23:30 <lambdabot> forall a. (Num a) => a -> (a, a)
15:23:34 <vixey> > liftA2 (,) (+1) (*2) 3
15:23:36 <lambdabot>   (4,6)
15:23:41 <evident> ahh ok... i gotta read hoogle about the zipwith function and then try it... thanks for the help
15:23:42 <vixey> > liftA2 (,) "foo" "bar"
15:23:44 <lambdabot>   [('f','b'),('f','a'),('f','r'),('o','b'),('o','a'),('o','r'),('o','b'),('o'...
15:23:46 <Cale> Gah, why did people have to point out this monoid thread on the mailing list to me? :) Too many messages I need to reply to.
15:23:52 <chessguy> haha
15:24:04 <Peaker> for functions: liftA2 (,) = (&&&)
15:24:08 <mauke> DDoS
15:24:08 <chessguy> Cale:  i looked away from the thread for a minute, looked back and there were 10 new messages
15:24:14 <Peaker> Cale: hehe :-)
15:24:17 <chessguy> somebody struck a nerve
15:24:23 <evident> vixey: where is that liftA2 function included? In Prelude? Or do i have to import it?
15:24:28 <roconnor> > let diag m n = zipWith (!!) m [n,n-1..0]; crossProduct = liftM2 (,) in diag (crossProduct [1..] [1..]) 3
15:24:30 <lambdabot>   Couldn't match expected type `[a]' against inferred type `(t, t1)'
15:24:42 <Peaker> Cale: I think the guys who want to turn Haskell into another Java can be ignored safely :)
15:24:44 <polveroj> evident: Control.Applicative
15:24:46 <Cale> We *must* combat this anti-intellectualism as harshly as possible.
15:24:50 <evident> ahh ok
15:24:52 <evident> thx
15:25:00 <roconnor> Cale: ok
15:25:06 <Cale> Or we will be overwhelmed by foolish people very quickly :)
15:25:10 <mightybyte>  Is there much work on a new language spec to replace Haskell 98?
15:25:16 <vixey> Cale, yeah sure as long as it doesn't take too much brain power
15:25:24 <roconnor> @type let diag m n = zipWith (!!) m [n,n-1..0] in diag
15:25:26 <lambdabot> forall a. [[a]] -> Int -> [a]
15:25:37 <roconnor> @type liftM2 (,)
15:25:39 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
15:25:41 * Cale is reminded of the battle between the Reverend Mothers and Honored Matres. ;)
15:25:57 <wli> Cale: Kull wahad!
15:25:58 * vixey wonderes what the "thinking hurts!!" people would do with haskell...
15:26:10 <roconnor> oh, crosProduct is broken
15:26:16 <slava> @hoogle (Maybe a) -> a -> a
15:26:16 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
15:26:16 <lambdabot> Prelude asTypeOf :: a -> a -> a
15:26:16 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
15:26:17 * ddarius is probably about to post a comment that will make dons happy.
15:26:18 <blackh> mightybyte: There is - click on "Future of Haskell" on the wiki. They were talking about doing it more in stages than in a big chunk, because the workload was too great.
15:26:19 <vixey> probably DSLs or whatever is trendy
15:26:25 <dons> yes, no compromises on accuracy.
15:26:29 <dons> ddarius: oh..
15:26:35 <roconnor> evident: did anyone tell you your crossProduct function is broken?
15:26:37 <mightybyte> blackh: Ok, thanks for the pointer.
15:26:41 <chessguy> @type let crossProduct s1 s2 = [(e1,e2) | e1 <- s1, e2 <- s2] in crossProduct
15:26:42 <lambdabot> forall t t1. [t] -> [t1] -> [(t, t1)]
15:26:47 <Cale> We must absorb them, and give them our Other Memories before they overwhelm us with numbers.
15:26:53 <chessguy> @let crossProduct s1 s2 = [(e1,e2) | e1 <- s1, e2 <- s2]
15:26:55 <lambdabot>  Defined.
15:27:09 <slava> dons: does haskell have a function for this?
15:27:13 <chessguy> > L.crossProduct [1,2] [1..3]
15:27:14 <slava> foo (Just x) y = x
15:27:15 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3)]
15:27:17 <slava> foo Nothing y = y
15:27:22 <dons> :t maybe
15:27:23 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:27:25 <roconnor> > let crossProduct s1 s2 = [[(e1,e2) | e1 <- s1] | e2 <- s2] in crossProduct [1,2,3] [1,2,3]
15:27:27 <lambdabot>   [[(1,1),(2,1),(3,1)],[(1,2),(2,2),(3,2)],[(1,3),(2,3),(3,3)]]
15:27:28 <dons> ?src maybe
15:27:28 <lambdabot> maybe n _ Nothing  = n
15:27:28 <lambdabot> maybe _ f (Just x) = f x
15:27:34 <mauke> :t fromMaybe
15:27:35 <Cale> ?src fromMaybe
15:27:35 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
15:27:35 <sjanssen> slava: fromMaybe
15:27:35 <lambdabot> forall a. a -> Maybe a -> a
15:27:43 <slava> sjanssen: thanks
15:27:45 <roconnor> evident: I think you want crossProduct s1 s2 = [[(e1,e2) | e1 <- s1] | e2 <- s2]
15:27:53 <mauke> slava: hoogle!
15:28:04 <chessguy> roconnor:  err, transposed, yes?
15:28:10 <slava> mauke: sadly my hoogle-fu is weak
15:28:16 <mauke> @hoogle Maybe a -> a -> a
15:28:16 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
15:28:16 <lambdabot> Prelude asTypeOf :: a -> a -> a
15:28:16 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
15:28:21 <roconnor> > let diag m n = zipWith (!!) m [n,n-1..0]; crossProduct s1 s2 = [[(e1,e2) | e1 <- s2] | e2 <- s1] in diag (crossProduct [1..] [1..]) 3
15:28:23 <lambdabot>   [(4,1),(3,2),(2,3),(1,4)]
15:28:43 <roconnor> evident: ^^
15:29:04 <Cale> Hehe, I just realised that analogy is rather good. We have our own sort of Agony even :)
15:29:05 * wli is thinking f Nothing y = y ; f x Nothing = x ; f (Just x) (Just y) = Just $ x + y
15:29:22 <vixey> Cale, hm what is the analogue?
15:29:26 <chessguy> roconnor:  your crossProduct returns the transpose of what he wants
15:29:27 * Cale wonders what our equivalent of spice essence is.
15:29:34 <chessguy> roconnor:  (i think)
15:29:38 <roconnor> chessguy: I transposed it
15:29:39 <dons> Cale: yes, it is good to think hard about how we continue to maintain the culture as we get growth spurts.
15:29:42 <chessguy> oh ok
15:29:43 <sjanssen> wli: looks like mappend on Maybe (Sum a)
15:29:44 <wli> Cale: s/melange/monads/?
15:29:48 <mauke> wli: mappend?
15:29:57 <BONUS> hey anyone know why i'm not getting any mails from haskell-cafe even though i subscribed like a few days ago?
15:30:00 <Peaker> would it be patronizing to say that "If you don't yet understand the utility of having the Monoid type-class as general as it is, you are probably not in a great position to call to rename it"?
15:30:01 <roconnor> chessguy: actually there are two different functions that satisfy evident's example of crossProduct
15:30:06 <dons> BONUS: hmm. what email address?
15:30:07 <chessguy> gbacon:  did you get help with yours?
15:30:09 <dons> privmsg me
15:30:11 <roconnor> chessguy: I'm not sure which one he wants
15:30:19 <Cale> vixey: Intellectual Haskell Users : New Unwashed Masses :: Reverend Mothers : Honored Matres -- from the Dune series of novels.
15:30:26 <Cale> wli: haha! yes
15:30:26 <gbacon> chessguy: not that I saw. Suggestions?
15:30:37 <chessguy> gbacon:  well it's written very imperatively
15:30:40 <vixey> Cale, I got that but not what is the Agony?
15:31:06 * gbacon <- unreconstructed :-(
15:31:20 <Cale> vixey: The Spice Agony which Bene Gesserit go through when they become Reverend Mothers
15:31:26 <chessguy> gbacon:  i would try to separate the IO from the non-IO parts
15:31:28 <vixey> Cale, (btw this _ : _ :: _ : _ construct is really really common on IRC now seems like some category thing.. :) )
15:31:38 <Cale> vixey: Comparable to our brain explosions ;)
15:31:39 <Cale> hehe
15:31:42 <wli> I guess a newtype-wrapped Monoid instance on integers is required, or something.
15:31:42 <vixey> Cale, ahh!
15:31:54 <Cale> vixey: It's just an old notation for proportions and analogies.
15:32:05 <sjanssen> wli: yes, because there are multiple possible instances.  See Sum and Product
15:32:05 <roconnor> Cale: BTW, we don't use Integer anymore.  To abstract.  It is now called CountingThingy
15:32:07 <vixey> P is to Q as U is to V
15:32:10 <vixey> P --> Q
15:32:12 <vixey> |     |
15:32:16 <vixey> U --> V
15:32:18 <chessguy> Cale++
15:32:20 <vixey> reminds me of these pics
15:32:30 <chessguy> err, whoops
15:32:36 <chessguy> roconnor++
15:32:50 <roconnor> chessguy++ -- why not
15:33:32 <chessguy> @remember roconnor  [after a long -cafe thread on the suckiness of using math terms in Haskell] we don't use Integer anymore.  To abstract.  It is now called CountingThingy
15:33:32 <lambdabot> Good to know.
15:34:24 <roconnor> chessguy: Can I plead with you to change it ot Too abstract?
15:34:36 <roconnor> so I don't look as idiotic as I really am.
15:34:50 <chessguy> if i could i would
15:34:57 <sjanssen> roconnor: "ot"?
15:35:07 <roconnor> @forget roconnor  [after a long -cafe thread on the suckiness of using math terms in Haskell] we don't use Integer anymore.  To abstract.  It is now called CountingThingy
15:35:07 <pumpkin> can't Cale just edit the quotes db?
15:35:07 <lambdabot> Done.
15:35:09 <pumpkin> @quote ackbar
15:35:09 <lambdabot> ackbar says: it's a trap!
15:35:15 <pumpkin> ah
15:35:20 <roconnor> @remember roconnor  [after a long -cafe thread on the suckiness of using math terms in Haskell] we don't use Integer anymore.  Too abstract.  It is now called CountingThingy
15:35:20 <lambdabot> Okay.
15:35:29 <pumpkin> @quote abstract
15:35:29 <lambdabot> roconnor says:  [after a long -cafe thread on the suckiness of using math terms in Haskell] we don't use Integer anymore.  Too abstract.  It is now called CountingThingy
15:35:38 <dons> don't get trolled, kids. just calmly, clearly state why things are the way they are.
15:35:41 <chessguy> well, look at that. learn somethin new every day..
15:35:54 <roconnor> dons: I save my venting for here
15:36:06 <roconnor> dons: and try to make clearer comments on cafe
15:36:06 <dons> people are coming from different communities, where the rules are different
15:36:12 <dons> good, that's reasonable.
15:36:19 <Holle_> wooooot! the map is colored!!!! YEAH
15:36:35 <vixey> Holle_, ace
15:36:47 <vixey> Holle_, so you got the whole thing with the maps done?
15:36:53 <pumpkin> the latest message on that thread is pissing me off, so I won't answer it :P
15:36:57 <chessguy> hey dons, i think haskell has a nice opportunity on stackoverflow.com
15:36:59 <Holle_> yes :)
15:37:03 <vixey> great
15:37:17 <Holle_> i would show you, but this are a lot of modules..
15:37:35 <chessguy> dons:  lots of questions on there begging to be answered in ways that show how haskell rocks
15:37:50 <roconnor> pumpkin: is that Max Rabkin message?
15:38:02 <pumpkin> roconnor: the response to that
15:38:10 <vixey> bye
15:39:23 * juhp wishes cabal-install could pull down hackages and untar them
15:39:26 <chessguy> gbacon:  any luck?
15:39:38 <chessguy> "hackages"++
15:39:52 <chessguy> i like that term - "hackage package" is way too cheesy
15:39:56 <roconnor> pumpkin: ah, I see.
15:40:01 <juhp> :)
15:40:01 <gbacon> chessguy: I've been trying to cajole ghc into letting me use unicode characters for data constructor names
15:40:05 <roconnor> I liked Max's comment :)
15:40:08 <pumpkin> chessguy: I agree
15:40:21 <pumpkin> roconnor: me too :P and I felt like answering *whoosh* to the response to it :P
15:40:42 <gbacon> chessguy: i.e., data Suit = ♣ | ♦ | ♥ | ♠
15:40:55 <chessguy> gbacon:  um...ok
15:40:56 <pumpkin> gbacon: that should work, what's wrong? are you saving your file as UTF-8?
15:40:57 <mauke> gbacon: those don't look like uppercase letters
15:41:04 <pumpkin> oh actually, yeah
15:41:12 <mauke> *> Σ
15:41:12 <mauke> <interactive>: try_stub.o: unknown symbol `Safe_zdffibonaccizuhszuaM1_closure'
15:41:17 <Peaker> gbacon: those would be operator data constructors? :)
15:41:19 * mauke looks at ghci
15:41:22 <roconnor> pumpkin: I kinda know how my respondent feels.  My advisor wants me to comment about how finite sets are a monad because they are the free semi-lattice something something
15:41:24 <cadabra> Is this supposed to work: "1 2" =~ "(\\d+)" :: [String]
15:41:33 <roconnor> pumpkin: wants me to put this comment in my thesis
15:41:39 <chessguy> @remember ghc try_stub.o: unknown symbol `Safe_zdffibonaccizuhszuaM1_closure'
15:41:39 <lambdabot> Good to know.
15:41:43 <Peaker> > "1 2" =~ "(\\d+)" :: [String]
15:41:45 <lambdabot>   []
15:41:48 <roconnor> pumpkin: and I'm like.  I don't understand !!!
15:41:51 <Peaker> > "1" =~ "(\\d+)" :: [String]
15:41:52 <lambdabot>   []
15:41:59 <Peaker> > "1" =~ "(\\d+)" :: String
15:42:01 <lambdabot>   ""
15:42:27 <gbacon> mauke: I dunno, they look like P | O | V | A
15:42:28 <pumpkin> roconnor: hah well neither do I :)
15:42:32 <mauke> chessguy: solved by rm try_stub*
15:42:36 <cadabra> > "1 2" =~ "(\\d+)" :: Bool
15:42:37 <lambdabot>   False
15:42:38 <Peaker> > "1" =~ "([0-9]+)" :: [String]
15:42:40 <lambdabot>   ["1"]
15:42:41 <Peaker> > "1 2" =~ "([0-9]+)" :: [String]
15:42:43 <lambdabot>   ["1","2"]
15:42:52 <cadabra> Oh wait I'm using PCRE.
15:43:13 <cadabra> a =~ b :: [String]   doesn't even compile
15:43:17 <Peaker> \\d doesn't seem to work..
15:45:11 <dolio> > "1 2" =~ "([:digit:]+)"
15:45:12 <lambdabot>       No instance for (Text.Regex.Base.RegexLike.RegexContext
15:45:12 <lambdabot>                ...
15:45:31 <cadabra> What do I have to import to get =~ from the default implementation?
15:45:48 * abra cadabra
15:46:06 <cadabra> zimzam
15:46:23 <cadabra> Why is Haskell Regex so crappy?
15:46:24 <dolio> > "abcd efgh" =~ "([:alpha:]+)" :: [String]
15:46:26 <lambdabot>   ["a","h"]
15:46:37 <dolio> Huh, wasn't expecting that.
15:46:39 <mauke> > "abcd efgh" =~ "([[:alpha:]]+)" :: [String]
15:46:41 <lambdabot>   ["abcd","efgh"]
15:46:54 <dolio> Ah.
15:46:58 <pumpkin> :o
15:47:13 <pumpkin> why did the first one behave the way it did?
15:47:39 <cadabra> Because posix regex sucks.
15:48:00 <mauke> [:alpha:] == [ahlp:]
15:48:02 <loadquo_> How do people cope with logging? I'm thinking about my VM project and at points I would like to be able log/IO every action it does (for visualisation purposes) at other points I would rather most of the code not have to worry about side affects. Any way to change between those? In C I would #define away the logging...
15:48:18 <dolio> > "1 2" =~ "([[:digit:]]+)" :: [String]
15:48:19 <lambdabot>   ["1","2"]
15:48:30 <dolio> So much better than [0-9].
15:49:00 <dolio> > "deadbeef" =~ "([[:digit:]]+)" :: [String]
15:49:02 <lambdabot>   []
15:49:03 <pumpkin> I really have this urge to make Data.Map callable as a function :(
15:49:21 <dolio> Have you been using Arc or something?
15:49:23 <roconnor> loadquo_: in theory one would use a writer monad, and swap in a different instance to change the logging.
15:49:27 <pumpkin> dolio: Arc?
15:49:33 <roconnor> loadquo_: but I've never tried this in practice
15:50:00 <dolio> Anyhow...
15:50:06 <dolio> @type (M.!)
15:50:08 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> a
15:50:20 <loadquo_> So much to learn. sigh. Thanks.
15:50:24 <pumpkin> yeah, I know, but I'd like to use it more like a function
15:50:30 <pumpkin> say I have two Maps
15:50:32 <dolio> > fromList [(0,1),(1,2),(2,3)] ! 1
15:50:33 <lambdabot>   Not in scope: `fromList'
15:50:35 <pumpkin> I want to compose them
15:50:42 <dolio> > M.fromList [(0,1),(1,2),(2,3)] M.! 1
15:50:44 <lambdabot>   /tmp/3364051210949568306:70:60: Not in scope: `M.fromList'/tmp/336405121094...
15:50:44 <pumpkin> and call the composed one
15:50:59 <pumpkin> it seems like it would be neat
15:51:00 <roconnor> loadquo_: well, if you are just starting Haskell, I wouldn't worry too much about writing elegent logging code right away.
15:51:01 <pumpkin> :)
15:51:45 <uraa> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
15:51:45 <uraa> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
15:51:47 <uraa> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
15:51:47 <pumpkin> oh god
15:51:48 <polveroj> pumpkin: you could write an Arrow instance
15:51:49 <uraa> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
15:51:50 <dolio> Geeze.
15:51:51 --- mode: ChanServ set +o Cale
15:51:53 <uraa> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
15:51:55 --- mode: Cale set +b *!*@gateway/web/cgi-irc/ufmg/x-26cd6ba3873b6917
15:51:59 <pumpkin> polveroj: I wanted to, but Map is restricted by Ord
15:52:01 --- kick: uraa was kicked by Cale (Cale)
15:52:08 <polveroj> pumpkin: oh, right.
15:52:19 <pumpkin> polveroj: been trying to find out how difficult it would be to write RArrow like RMonad
15:52:24 <pumpkin> but not many people seem very interested in the idea :P
15:52:26 * wli is at a loss to write abs and signum instances.
15:52:30 <Itkovian> oh boy. seems like the spammers are having a good time tonight.
15:52:33 <bombshelter13> Anyone had luck getting GHC from Macports to go on OS X?
15:52:36 <roconnor> loadquo_: in any case. #haskell is here to help you on your journey.
15:52:38 <wli> pumpkin: What are RArrow and RMonad?
15:52:40 <Valodim> there should be a spam module for lambdabot
15:52:45 <Valodim> to spam the advertised channels
15:52:47 <eraa> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
15:52:48 <eraa> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
15:52:51 <eraa> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
15:52:52 <Itkovian> bombshelter13: what version?
15:52:54 <eraa> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
15:52:54 --- mode: ChanServ set +o sjanssen
15:52:58 <eraa> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
15:52:58 --- mode: sjanssen set +b *!*=c0a801fe@gateway/web/cgi-irc/ufmg/x-e868966772015131
15:52:58 --- kick: eraa was kicked by sjanssen (sjanssen)
15:53:02 <Itkovian> yeah baby!
15:53:05 <cads> why are operating system threads classically regarded as innefficient?
15:53:08 <Itkovian> hit those suckers
15:53:16 <pumpkin> wli: RMonad is a restricted monad package on hackage, that works for things like Set that are restricted by Ord. I'd like a similar RArrow for Map and certain other things like matrices
15:53:28 <pumpkin> wli: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/rmonad
15:53:29 <eraa2> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
15:53:31 <eraa2> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
15:53:33 --- mode: ChanServ set +o mauke
15:53:47 <roconnor> bank ufmg/x-* ?
15:53:48 <bombshelter13> Itkovian: OS X is 10.5.5, latest updates as of last night... GHC is... whatever version is in ports, lemme check exactly which one that is.
15:53:49 <roconnor> ban
15:53:50 <Peaker> wtf
15:54:11 <qaz> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
15:54:12 <qaz> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
15:54:14 <sjanssen> mauke: what is this left/requested by thing?
15:54:16 <cadabra> cads: the cost of creating a native thread and switching between threads
15:54:16 <bombshelter13> 6.10.1, apparently.
15:54:23 <dons> um
15:54:26 <roconnor> ban c0a801fe@gateway/web/cgi-irc/ufmg/x-* ?
15:54:28 <mauke> sjanssen: it's like a soft kick :-)
15:54:30 <pumpkin> dons: it isn't just us :/
15:54:31 <cads> that is, when concurrency in a language is described as being done by user space threads, it is usually mentioned that the implementation of threads that is used is much more efficient than OS threads
15:54:38 <sjanssen> mauke: how do I do it?
15:54:41 <Itkovian> bombshelter13: I've got that running on 10.5.5
15:54:44 <wli> roconnor: Any ideas how to do signum and abs for integers [sic] represented as sum d_k*r^k with |d_k| < r?
15:54:47 <Itkovian> not sure where I got it though ;-)
15:54:51 <cads> but if OS threads are so bad, why aren't they made more efficient?
15:54:51 <mauke> sjanssen: send the server a REMOVE command. it's a freenode extension
15:55:03 <gbacon> chessguy: how should I restructure it to be more functional?
15:55:10 <roconnor> wli: signum cannot be totally defined for real numbers
15:55:18 <bombshelter13> Itkovian: Interesting... on mine it's reporting that the command "env DYLD_FALLBACK_LIBRARY_PATH=/opt/local/lib make" returned error 2.
15:55:20 <hallongrottan> that's a cool extension
15:55:22 --- mode: Cale set -ooo Cale dcoutts mauke
15:55:23 <roconnor> wli: you have to leave signum 0 = _|_
15:55:27 <Itkovian> cads: because there is always some overhead involved when switching stuff on the CPU
15:55:30 <bombshelter13> Which seems... unusual, since that seems like a fairly sensible command to me.
15:55:31 <gwern> yay, gitit is working with darcs!
15:55:33 --- mode: ChanServ set +o mauke
15:55:33 --- mode: mauke set -o mauke
15:55:37 <pumpkin> gwern: good job :)
15:55:38 <mauke> grr
15:55:38 <roconnor> wli: abs is fine
15:55:45 <gwern> it's buggy, but I'm actually viewing and browing darcs-controlled files!
15:55:59 <loadquo_> roconnor: Heh, I'll think I'll probably go back to C for my project (which I don't like coding in, particularly) but try and get to know Haskell for other stuff. I'll need a compiler at some point and haskell seems perfectly suited for that.
15:56:00 <gwern> MISSION ACCOMPLISHED; HAPPINESS - ACHEIVED?
15:56:07 <mauke> Cale: you found a bug in my script :-)
15:56:18 <roconnor> loadquo_: sorry to hear that.  But good luck
15:56:20 <Cale> mauke: hehe
15:56:28 <wli> roconnor: Here the digits vary in sign, so even abs is "interesting."
15:56:31 <mauke> sjanssen: /alias remove quote REMOVE $C $0 :$1-
15:56:41 <Itkovian> bombshelter13: hmm, ghci got dropped into /usr/bin, so maybe we are using different packages
15:56:42 <roconnor> wli: right.  I guess I mean that abs is doable
15:57:03 <Peaker> cads: OS threads have less information about the contexts that need to be switched than the language runtime
15:57:04 <bombshelter13> Itkovian: Do you think that you may have built it from source yourself? Or did you definately get it from ports?
15:57:17 <Itkovian> No I got some binary package from somewhere
15:57:21 <bombshelter13> Hmm, mm'kay.
15:57:26 <roconnor> wli: I think you want to search through the list looking for the first non-zero digit, spitting out zero digits as you go
15:57:26 <Itkovian> Let me see if it's still in my DL folder
15:57:30 <bombshelter13> Wonder if I can dig that up.
15:57:33 --- mode: ChanServ set +o mauke
15:57:34 --- mode: mauke set -o mauke
15:57:40 <cads> Itkovian, does it differ in that process controlled threads don't have to preempt the processor, instead just jumping around between different execution contexts as part of the program control flow?
15:57:40 <mauke> what the hell
15:58:12 <roconnor> wli: then when/if you get to a non-zero digit, check the sign.  If it is negative, then start swaping all the digit signs from then on.  Otherwise return all digits as you find them
15:58:14 <bombshelter13> I'm gonna try resyncing ports and see if that helps.
15:58:22 <Itkovian> cads: it depends on how threads are really implemented
15:58:40 <bombshelter13> But if you do find that binary, I'd love a copy or a link..
15:58:54 <Itkovian> cads: but yeah, it should not kill too much, only it does not get implemented as such afaik
15:58:55 <roconnor> wli: notice how spitting out zeros is find because that works whether you find the number to be negative or not.
15:59:02 <dolio> roconnor: For integers?
15:59:20 <chessguy> why does -Wall whine about things being defined but not used, when they are?
15:59:21 <pumpkin> Heffalump: you around?
15:59:23 <dolio> Signum shouldn't be a problem, should it?
15:59:27 <chessguy> very strange
15:59:34 --- mode: ChanServ set +o mauke
15:59:34 --- mode: mauke set -o mauke
15:59:38 <mauke> chessguy: are they only used by unused definitions?
15:59:38 <dolio> Unless you have infinite integers or something.
15:59:46 <Peaker> chessguy: I think I had a bug with complaints about unused imports, but not unused definitions
15:59:48 <roconnor> dolio: ... i guess I was sort of ignoring that word that I didn't understand in that context
15:59:51 <dolio> (Which wouldn't be integers.)
15:59:51 <mauke> Cale: you found two bugs :/
15:59:52 <roconnor> :/
15:59:58 <Itkovian> bombshelter13: did you try http://haskell.org/ghc/dist/6.10.1/GHC-6.10.1-i386.pkg?
16:00:09 <Itkovian> or even http://haskell.org/ghc/dist/6.10.1/maeder/ghc-6.10.1-i386-apple-darwin.tar.bz2
16:00:09 <wli> dolio: They're represented as sum_{0 \leq k \leq n} d_k*r^k where |d_k| < r (i.e. not a unique representation).
16:00:22 <pumpkin> I need an IRC client that pretty prints latex
16:00:34 <Cale> mauke: I also discovered a stupidity in X-Chat's behaviour.
16:00:36 <bombshelter13> Itkovian: Ooh, no, but I shall try them now.
16:00:49 <conal> pumpkin: gee, that's a nice idea.  i wonder if there is one.
16:00:59 <wli> dolio: No p-adics here, though they'd be interesting, too.
16:01:01 <pumpkin> conal: I highly doubt it :)
16:01:02 <Cale> mauke: When you select a bunch of users to deop and it includes you, it doesn't leave you to last.
16:01:03 <Peaker> I need an IRC client that has a reasonable search feature
16:01:04 <pumpkin> unfortunately :/
16:01:05 <kmeyer> need to write an irc client in haskell :D
16:01:12 <conal> kmeyer: indeed!
16:01:13 <mauke> Cale: heh
16:01:16 <roconnor> wli: I guess the question is why did you say "integers" ?
16:01:19 <mpeter> kmeyer: get on it!
16:01:20 <dolio> wli: Yeah, but testing for 0 would eventually terminate, wouldn't it?
16:01:21 <Itkovian> bombshelter13: I think I've got the second one, as tere is no /opt on my drive
16:01:26 <kmeyer> mpeter: I'm just a newbie :(
16:01:29 <Itkovian> see http://haskell.org/ghc/download_ghc_6_10_1.html#macosxintel
16:01:29 <mpeter> it'll be like irssi, except written in haskell!
16:01:41 <mpeter> resiak??
16:01:42 <conal> and give it a plugin architecture so it can render haskell values in interesting ways.
16:01:46 <kmeyer> mpeter: I was thinking xchat, except in haskell
16:01:50 <mpeter> funny seeing you here
16:01:50 <conal> e.g., 3d animations.
16:01:59 <Peaker> conal: having them serialized to text is a bit limiting..
16:02:00 <bombshelter13> Itkovian: *reads it*
16:02:08 <Itkovian> kmeyer: lamdabot to the rescue
16:02:15 <dolio> Unless you add infinitely many negative digits to an infinitely far away positive one or something?
16:02:23 <kmeyer> Itkovian: hm?
16:02:29 <dolio> Anyhow, I have to go.
16:02:33 <conal> Peaker: everything we describe in haskell starts out as a serialized text string.
16:02:52 * gwern thinks the effort that'd go into an irc client would be better spent on stuff like hackage
16:03:06 <wli> dolio/roconnor: Aha, convert it to \sum_{0\leq k \leq n'} d'_k*r^k with 0 \leq d'_k < r and testing for 0 is possible for the integers. signum I'm not sure of yet.
16:03:07 <conal> purely functional code is the ultimate asfe & flexible compression format
16:03:30 <pumpkin> conal: do you have any idea whether it would be possible to make a "restricted arrow" typeclass like the RMonad one?
16:03:41 <gwern> wonder if anyone did anything with total functional programming langs as proof-carrying code
16:03:44 <roconnor> wli: I'm confused
16:04:23 <wli> dolio/roconnor: \sum_{0\leq k\leq n} d_k*r^k where |d_k| < r is not obviously positive, negative, or 0.
16:04:30 <roconnor> gwern: what do you mean?
16:04:45 <roconnor> wli: correct
16:04:50 <mattam> gwern: some PCC architectures use Coq
16:04:56 <conal> pumpkin: i haven't heard of RMonad.
16:05:08 <Peaker> conal: if you create a value by combining a bunch of functions, and "send" the value over IRC, it can't serialize the value, it has to keep track of how you built it to send it
16:05:19 <pumpkin> conal: it allows you to make Monad instances with constraints like, Ord for Set
16:05:44 <conal> pumpkin: i'll check it out. thx.
16:05:44 <conal> gotta go.
16:05:44 <Peaker> conal: IRC is so broken, if something radical like that is created, why not abandon IRC for something better, and just write a proxy to bridge the gap from #haskell to the new world? :)
16:05:47 <wli> dolio/roconnor: I basically said to convert it to a unique representation like where digits have 0 \leq d_k < r or -r/2 < d_k \leq r/2.
16:05:55 <conal> Peaker: sounds good to me.
16:05:57 <pumpkin> Peaker: good idea
16:06:05 <roconnor> wli: you cannot convert real numbers into a unique representation
16:06:13 * gwern feels so happy about gitit now. go darcs!
16:06:14 <conal> let's do it!
16:06:26 <conal> purely functional code as the protocol.
16:06:34 <wli> roconnor: s/Unique/canonical/
16:06:38 <roconnor> right
16:06:44 <roconnor> wli: you cannot convert real numbers into a canonical representation
16:06:54 <sjanssen> gwern: huh?  Did you add a darcs backend to gitit?
16:06:58 <Peaker> conal: Example session in that protocol?
16:07:05 <gwern> sjanssen: er, yes. I've been talkign about it for weeks now
16:07:09 <pumpkin> gwern: shouldn't it be called gitordarcsit?
16:07:11 <roconnor> wli: doing so would allow you to solve the halting problem
16:07:29 <gwern> pumpkin: but then we'd lose all the effort we've put into branding it!
16:07:32 <pumpkin> :)
16:07:43 <wli> roconnor: The representation converted to is "nailed down" enough that either the sign is obvious or the computation fails to terminate.
16:07:47 * gwern actually thought #haskell was sick of me talking about gitit and darcs and filestore
16:07:58 <pumpkin> "proof by crushing statement that you'd be able to solve the halting problem if you were right"
16:07:59 <roconnor> wli: but you can implement abs without such a conversion
16:08:06 <roconnor> or any other continuous function
16:08:07 <abuiles> rwbarton: Hi, Yesterday I ask about this  http://hpaste.org/13968 and you explain me about Functional dependencies . Now In the qualified types, the is this , " (HasEnvironment m) => p" is that just simple inheritance or does that means another thing if it is in the quliafied types ? Thanks
16:08:13 --- mode: ChanServ set -o sjanssen
16:08:22 <polveroj> pumpkin: I think the trick in RMonad works for Arrows, but for the general case you want a class (Suitable2 a b c) instead of (Suitable m a)
16:08:46 <pumpkin> polveroj: yeah, that makes sense
16:09:04 <pumpkin> polveroj: you think GHC's arrow implementation would be nice enough to use those definitions if the default ones were replaced?
16:09:17 <roconnor> wli: you may find it helpful to write the abs using the function rCompare :: CReal -> CReal -> CReal -> CReal
16:09:23 <polveroj> pumpkin: no clue, I've never used the arrow syntax actually
16:09:32 <pumpkin> polveroj: ah ok :)
16:09:55 <roconnor> wli: rCompare a b c d returns c if a <= b, returns d if b <= a, and requires that if a == b then c == d
16:09:56 <leimy> > fmap (\(v,o) -> o v) (Just (4, (+32)))
16:09:58 <lambdabot>   Just 36
16:10:03 <leimy> hmmm
16:10:07 <pumpkin> I dunno why I have such an urge to compose Maps
16:10:18 <mpeter> > combat wombat
16:10:20 <lambdabot>   "tomcats"
16:10:21 <roconnor> wli: it is easy to write abs directly
16:10:25 <wli> r^(n+1) - (r-1)*((r^(n+1)-1)/(r-1)) so it is possible to track the sign digit-by-digit.
16:10:28 <pumpkin> :t combat
16:10:30 <lambdabot> [Int] -> [Char]
16:10:41 <pumpkin> :t wombat
16:10:42 <lambdabot> [Int]
16:10:46 <mpeter> it's not an exciting thing happening there
16:10:46 <roconnor> wli: but rCompare may help you write all sorts of piecewise functions
16:10:56 <pumpkin> > combat [1,2,3]
16:10:58 <lambdabot>   "\SOH\STX\ETX"
16:11:02 <leimy> > fmap (\(v,o) -> (o v, o)) (Just (4, (+32)))
16:11:03 <lambdabot>       Overlapping instances for Show (a -> a)
16:11:03 <lambdabot>        arising from a use of `s...
16:11:05 <jeffwheeler> @src combat
16:11:05 <lambdabot> Source not found. You speak an infinite deal of nothing
16:11:06 <pumpkin> > combat [0]
16:11:08 <lambdabot>   "\NUL"
16:11:12 <pumpkin> hah
16:11:22 <pumpkin> > ord . combat $ [0..]
16:11:23 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
16:11:26 <pumpkin> > map ord . combat $ [0..]
16:11:27 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
16:11:33 <pumpkin> :P
16:11:38 <pumpkin> exciting :)
16:11:43 <mpeter> is not!
16:11:45 <pumpkin> ;)
16:11:48 <jah5> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
16:11:49 <jah5> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
16:11:50 <pumpkin> > map chr wombats
16:11:50 <jah5> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
16:11:52 <lambdabot>   Not in scope: `wombats'
16:11:53 <jah5> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
16:11:54 <mpeter> ubuntu sucks!
16:11:57 <jah5> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
16:11:58 <pumpkin> > map chr wombat
16:11:59 <lambdabot>   "tomcats"
16:12:01 <jah5> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
16:12:05 <sbahra> jah5, :-(
16:12:05 <jah5> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr  #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
16:12:06 <pumpkin> this is getting ridiculous
16:12:11 <sbahra> Why would someone spam #haskell?
16:12:12 <mpeter> <3 jah5
16:12:15 <jnwhiteh> interesting
16:12:17 <jeffwheeler> > wombat
16:12:18 <saml> what's -tr?
16:12:18 <lambdabot>   [116,111,109,99,97,116,115]
16:12:19 <tromp__> to test our wits
16:12:23 <mpeter> sbahra: to warn you of the incoming ubuntu-tr revolution
16:12:26 <sbahra> saml, Turkey
16:12:26 <pumpkin> sbahra: they're spamming a bunch of places... I assume it's because it's high on /list
16:12:37 <wli> roconnor: The sign is basically the sign of the digit for the largest power; however, 0 is vaguely unique.
16:12:39 <sbahra> pumpkin, I see.
16:12:41 <jeffwheeler> How do you use @check, or @test, or whatever it is? lambdabot isn't responding to my pm's.
16:12:44 <lament> trubuntu
16:12:44 <roconnor> come join #constructive-math.  Now with less spam
16:12:46 <saml> sbahra, thanks
16:12:48 <twb> Does Hackage's TRAC have a guest account like GHC's does?
16:12:51 <twb> If so, what is it?
16:12:57 <sbahra> roconnor, what is discussed there?
16:12:59 <pumpkin> maybe some op could set +s on #haskell? that might stop the onslaught of spambots?
16:13:02 <pumpkin> glguy?
16:13:07 <sbahra> roconnor, not quite sure what "constructive math" is.
16:13:08 <pumpkin> or was it +p
16:13:14 <roconnor> sbahra: Constructive Math - Bishop, Type Theory, Abstract Stone Duality, ...
16:13:14 <pumpkin> whatever stops us from showing up on /list
16:13:25 <gwern> twb: it was 'guest' 'lambda', iirc
16:13:26 <sbahra> roconnor, over my head, but always interested in learning. :)
16:13:30 <roconnor> sbahra: it is a merger of Logic and programing
16:13:34 <mpeter> glguy is an op in haskell?
16:13:35 <sbahra> Nice.
16:13:35 <gwern> twb: it's listed on the main page or something
16:13:35 <mpeter> god dammit
16:13:47 <pumpkin> mpeter: why?
16:13:53 --- mode: ChanServ set +o mauke
16:13:53 --- mode: mauke set +b *!*@gateway/web/cgi-irc/brujula5.brujula.net/*
16:13:53 <mpeter> that'll be worse than giving dons the keys to the haskell treasury!
16:13:54 <roconnor> sbahra: unfortunately we aren't very chatty
16:14:03 <pumpkin> mauke: you think that might help?
16:14:17 <sbahra> roconnor, I only hope xchat can sustain that huge user list.
16:14:17 <mpeter> mauke: what if jah5 wants to come back and learn haskell?
16:14:23 <twb> gwern: din't work :-(
16:14:34 <gwern> guest/anonymous maybe
16:14:35 <mauke> pumpkin: for now
16:14:35 <twb> Oh there; password is "haskell"
16:14:44 <roconnor> sbahra: I should advertise more often
16:14:47 <gwern> (maybe guest/lambda was the ghc trac)
16:14:53 <twb> I'm not used to reading the random "about our project" front page
16:14:54 <pumpkin> mauke: I meant setting +s on the channel (I assume the only reason they come in here is that they join the top N most popular channels on /list)
16:15:10 <sbahra> roconnor, a couple of lectures and you'll find a lot of people in there.
16:15:17 <gwern> twb: took me a while too :)
16:15:28 <twb> Sorry, "haskell'" (prime)
16:15:31 <mpeter> bans are for people who can't bother to use /ignore
16:15:39 <christo_m> does something like Django and RoR exist for haskell?
16:15:41 <mpeter> i welcome the flooders
16:15:47 <mpeter> and the irritable trolls!
16:15:48 <pumpkin> mpeter: why waste 620 people's time pressing an ignore button
16:15:49 <mauke> mpeter: server-side ignore > client-side ignore
16:15:49 <pumpkin> :)
16:15:53 --- mode: mauke set -o mauke
16:15:57 <roconnor> sbahra: oh, that is a good idea
16:16:00 <mpeter> bring me your tired, your poor, your huddled masses yearning to learn haskell!
16:16:01 <cads> christo_m: , there's happs
16:16:11 <roconnor> sbahra: I should see a few IRC lectures to learn the format
16:16:12 <mpeter> mauke: except for the people being ignored
16:16:15 <jnwhiteh> mauke: I let the server ops know as well so they should help keep an eye on it
16:16:23 <chessguy> @hoogle HUnit
16:16:23 <lambdabot> package HUnit
16:16:23 <lambdabot> module Test.HUnit
16:16:29 <Gracenotes> hm. Is there a version of the map fusion identity: foldr f v . map g = foldr (f . g) v, but for foldl instead?
16:16:32 <mpeter> i predict a great chasm opening between the sources of centralized communication and the sources of decentralized communication
16:16:38 <cads> christo_m: also, I hear that turbinado is more similar to rails
16:16:40 <mpeter> resiak knows what i'm talking about
16:16:42 <wjt> mpeter: i'm sure i said hi the other day
16:16:55 <Holle_> how to call nextShuffle x-times in shuffle? http://hpaste.org/13969
16:17:30 <sjanssen> Gracenotes: sure, you just need to jiggle the arguments a bit
16:17:39 <mpeter> well hello then
16:17:49 <Gracenotes> hm.
16:18:28 <abuiles> I guys, In a class declaration, there is something like this in the qualified types "(HasEnvironment m) => ", is that just inheritance or does it have another meaning? http://hpaste.org/13968
16:18:29 <sjanssen> foldl f v . map g = foldl (\a x -> f a (g x)) v
16:18:56 <kupopo> I'm got a question about uploading to hackage - my haddock builds with ./Setup.hs haddock, but when I run the test-upload, none of the modules show up as links - any idea why?
16:19:02 <pumpkin> abuiles: we don't really have inheritance, but it's kinda similar, if a lot more flexible
16:19:28 <christo_m> cads, thanks
16:19:32 <dublpaws> is partial application available for constructors?
16:19:46 <sjanssen> abuiles: "find   :: (HasEnvironment m) => primaryKey -> m model
16:19:46 <ziman> yes
16:19:48 <Gracenotes> hm.
16:19:49 * mpeter completely loses interest in the conversation
16:19:58 <abuiles> sjanssen: yes that one
16:20:04 <abuiles> How can I read that?
16:20:17 <sjanssen> abuiles: " means that find has that type for any 'm' that is an instance of HasEnvironment
16:20:38 <Holle_> the problem is that i have to use the result in the next call of nextShuffle
16:20:42 <dons> dublpaws: yeah.
16:20:45 <dons> ?users
16:20:46 <lambdabot> Maximum users seen in #haskell: 658, currently: 626 (95.1%), active: 47 (7.5%)
16:20:48 <dons> lots of new faces.
16:21:00 <sjanssen> abuiles: perhaps, "given that 'm' is an instance of HasEnvironment, find has the type primaryKey -> m model"
16:21:06 <dons> this community generates a lot of interesting content, http://www.reddit.com/r/programming/comments/7q28x/great_post_on_why_names_like_monoid_are_more/
16:21:11 <mpeter> yeah, dons, until you ban them all for being disagreeable
16:21:14 <mpeter> ;)
16:21:25 * mpeter sips his guava juice
16:21:27 --- mode: ChanServ set +o mauke
16:21:28 --- mode: mauke set -b *!*@gateway/web/cgi-irc/brujula5.brujula.net/*
16:21:30 <dons> hmm :/ we try not to ban people.
16:21:32 * sjanssen prepares to ban mpeter :)
16:21:36 <cads> hey, I was wondering about hugs. Is there a compelling reason to use it above ghci? I use ghci/ghc and feel like it's more compatible with what's out there than hugs. However one thing that bugs me is that working with code in ghci is different from code you'd write in a file, and if hugs is different i'd be interested. But I don't know what other considerations might make someone choose hugs. Any insights?
16:21:44 <dons> cads: there's no reason to use hugs
16:21:44 <Peaker> @type \n f -> (!!n) . iterate f
16:21:46 <lambdabot> forall a. Int -> (a -> a) -> a -> a
16:21:57 <Peaker> @hoogle  Int -> (a -> a) -> a -> a
16:21:57 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
16:21:57 <lambdabot> Data.Generics.Basics gmapQi :: Data a => Int -> (a -> u) -> a -> u
16:21:57 <lambdabot> Data.IntMap adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
16:21:58 <mauke> cads: hugs is even more restrictive than ghci
16:22:13 <mpeter> dons, i've been writing the haskell theme song
16:22:19 <abuiles> sjanssen: Thanks
16:22:19 <mpeter> you can't even imagine what it sounds like
16:22:22 <sjanssen> cads: some say that hugs loads (parses, typechecks) code more quickly than GHC
16:22:23 <Holle_> nextShuffle returns an IO [Int] and want's [Int]
16:22:50 <pumpkin> mpeter: I'm not sure you've seen the barrage of spambots joining this channel with #ubuntu-tr spam, but there've been quite a few :P normally you almost never see any bans in here
16:23:09 <mpeter> i bet it has to do with the upcoming ubuntu-tr apocalypse
16:23:15 <mpeter> that's been all over the net news
16:23:23 <pumpkin> ah
16:23:27 <sjanssen> mpeter: oh?
16:23:28 --- mode: mauke set -o mauke
16:23:37 <Holle_> no one knows?
16:23:40 <abuiles> sjanssen: So even when that is in the qualified types , is still understood has Superclass, I mena
16:23:42 <dons> mpeter: so you're learning haskell?
16:23:52 <Cale> Why would someone spam for a language-specific version of an IRC channel for a nonprofit piece of software?
16:23:53 <sjanssen> Holle_: what is the complete question?
16:23:54 <abuiles> *mean, Is not just in class type definition?
16:23:54 <mpeter> i am learning haskell
16:24:11 <Holle_> >	how to call nextShuffle x-times in shuffle? http://hpaste.org/13969
16:24:49 <sjanssen> abuiles: Haskell classes aren't really like OO classes, so superclass has a much different meaning
16:25:45 <gwern> 'Note: Real World Haskell uses the phrase “in many popular languages” all over the book when they want to refer to some language with a bad cultural habit without naming names. The language they’re talking about here is Perl. Perl 6 (may it soon be released) notably fixes the regex problem by introducing grammars consisting of rules.' <-- never bring a regexp to a parsing fight?
16:25:46 <sjanssen> abuiles: in "class (DatabaseModel model) => HasFindByPrimaryKey model primaryKey", it can be said that DatabaseModel is a superclass of HasFindByPrimaryKey
16:25:47 <abuiles> So better each  instance of X must also be an instance of B
16:26:21 <mpeter> HasFindByPrimaryKey?
16:26:25 <sjanssen> abuiles: yes, that is what it means in a class definition
16:26:28 <dons> so not going by ushdf anymore, mpeter ?
16:26:40 <mpeter> i have many nicks, dons
16:26:49 <mpeter> for reasons that should be obvious by now
16:26:58 <abuiles> thanks again
16:27:00 <abuiles> !
16:27:01 <dons> ah i see. well, that personality is particularly recognisable.
16:27:16 <mpeter> i'm so iconoclastic i'm clastic
16:27:26 <Holle_> i just want to call the functio more than one times.
16:27:55 <mpeter> you wouldn't have known it was me if i didn't go out of my way to address you directly
16:28:08 <cads> mauke, dons, can we achieve an interactive REPL environment where we can be as expressive as we are in a haskell source file?
16:28:18 <kupopo> Has anybody else used the "check" feature when uploading to hackage?  Is the haddock documentation supposed to show up?
16:28:39 <mauke> cads: in theory, yes
16:28:57 <dons> cads, yes. in practice.
16:29:02 <cads> I bet it's harder for a purely functional language
16:29:05 <dons> hbi implements a full Haskell B interface
16:29:06 <sjanssen> kupopo: no, docs are built asynchronously
16:29:23 <dons> mpeter: well thank you very much for that.
16:29:26 * cads searches
16:29:40 <mpeter> i regret it already
16:29:40 <Heffalump> pumpkin: I am now
16:29:46 <pumpkin> Heffalump: !!!
16:29:48 <kupopo> sjanssen: thanks - I've seen a lot of packages that never get docs built... how can I tell if mine will work?
16:29:48 <sjanssen> kupopo: the best way to make sure that your docs will build on hackage is to make sure that all dependencies build on hackage, and that docs build on your own machine
16:29:56 <dons> mpeter: well, you know the rules. so stick to 'em and we'll be fine.
16:30:03 <kupopo> sjanssen: ok, thanks!
16:30:09 <sjanssen> kupopo: but there isn't a sure fire way other than posting and hoping
16:30:28 <mpeter> fine, i'll just troll under a different nick
16:30:29 <Heffalump> pumpkin: ???
16:30:43 <pumpkin> Heffalump: you wrote RMonad didn't you?
16:30:52 <Heffalump> yes
16:31:10 <pumpkin> Heffalump: I've been getting an urge recently to try to apply your techniques there to Arrow :P
16:31:26 <Heffalump> that's actually a bit tricky, because of first
16:31:28 <pumpkin> Heffalump: I was wondering if you had any ideas (or just "no that won't work") or anything
16:31:45 <pumpkin> Heffalump: the function first?
16:31:47 <Heffalump> you need to be able to get from X (a, b) to X a from arbitrary constraints X (e.g. Ord)
16:31:51 <Heffalump> yeah
16:31:57 <Holle_> is it sooo difficult? : how to call nextShuffle x-times in shuffle? http://hpaste.org/13969
16:32:22 <Heffalump> Peter Gavin was having a go at it a while ago, and he did have a solution/workaround to the problem, I'm not sure where he got to
16:32:29 <pumpkin> Heffalump: is he on IRC?
16:32:50 <pumpkin> Heffalump: the idea of that (RArrow) really appeals to me, for some reason :)
16:33:00 <Heffalump> I can't remember. I have a vague feeling I've seen a pgavin, but I talked to him about it by email.
16:33:09 <pumpkin> ah ok
16:33:21 <pumpkin> (and I love RMonad btw :P)
16:33:26 <njbartlett> Anybody working on AMQP in Haskell?
16:33:29 <mpeter> heffalump: how'd you get that earth.il email?
16:33:30 <Heffalump> pumpkin: cool :-)
16:33:35 <dons> njbartlett: we gotta do it! :)
16:33:40 <mpeter> i want one
16:33:42 <dons> the dignity of haskell-cafe@ depends on it
16:33:47 <Heffalump> mpeter: a friend of mine bought the domain
16:33:52 <mpeter> i emailed him
16:34:00 <njbartlett> dons: Yeah. Screw client libs. I want a full broker in Haskell
16:34:03 <mpeter> i want one ;)
16:34:07 <mpeter> but i didn't mention you
16:34:10 <Heffalump> mpeter: it's not quite that simple, sorry :-)
16:34:12 <pumpkin> mpeter: did you major in trolling? :P
16:34:25 <mpeter> english major and computer science minor
16:34:30 <mpeter> which is like a trolling major
16:34:35 <Cale> haha
16:34:39 <pumpkin> :)
16:35:02 <pumpkin> mpeter: I was just at a talk the other day wishing it was as easy to troll real talks as easily as it is online
16:35:14 <pumpkin> but then the talk turned out to be really interesting so I didn't need to
16:35:15 <mpeter> i figured he might be reluctant to give me the email...so i signed the email "your lover"
16:35:22 <dcoutts> pumpkin: try deconstructionism :-)
16:35:28 <Heffalump> mpeter: I see...
16:35:49 <mpeter> since he would be a poor lover to deny his significant other an email address
16:35:55 <mpeter> anyway, back to haskell
16:36:09 <Heffalump> I suspect he can tell the difference between you and his wife.
16:36:21 <Holle_> why no one can help? >> how to call nextShuffle x-times in shuffle? http://hpaste.org/13969
16:36:47 <dcoutts> Holle_: you don't want to be using IO there
16:37:05 <Holle_> but i have to ?!
16:37:07 <dcoutts> Holle_: and you do want to be using recursion
16:37:31 <dcoutts> Holle_: no, pass the RNG in as a parameter to shuffle
16:37:37 <Cale> Well, he *could* use IO for the random numbers, though it's not exactly the prettiest way.
16:37:55 <mpeter> there's a better way than randomGen?
16:38:03 --- mode: ChanServ set +o dons
16:38:07 --- mode: ChanServ set -o dons
16:38:55 <Holle_> i don't know how to do it :/ could you give an example?
16:39:01 <Cale> mpeter: Either passing a StdGen as a parameter, or using the Rand monad.
16:39:26 <mpeter> but the initial seed is always created by the OS, no?
16:39:41 <mpeter> or at least communicated from it
16:40:15 <sjanssen> mpeter: you can also create a StdGen from a plain old integer
16:40:18 <chessguy> @type 0.00002
16:40:20 <lambdabot> forall t. (Fractional t) => t
16:40:31 <sjanssen> mpeter: eg. mkStdGen 42
16:40:37 <Cale> Holle_: In Haskell, all functions are proper functions in the sense that given the same value, they return the same result. So if a function needs to produce pseudorandom results, it needs to take a pseudorandom number generator as a parameter.
16:40:38 <pumpkin> chessguy: 2 cents in kilodollars!
16:41:12 <Holle_> but i don't know how to realize
16:41:37 <Cale> Holle_: So, functions like random and randomR take a value of type StdGen as a parameter
16:41:52 <Cale> Holle_: and they give not just the pseudorandom number, but a new StdGen
16:42:12 <Cale> The reason they do this is because if you pass the same StdGen, you're sure to get the same result.
16:42:24 <Cale> So they supply you with a new one for the next pseudorandom number.
16:42:37 <Cale> > randomR (1,6) (mkStdGen 42)
16:42:38 <lambdabot>   (6,1720602 40692)
16:43:12 <Cale> So it gave me my random number between 1 and 6 (I rolled a 6), along with some other data (StdGen values print as two integers)
16:43:29 <pumpkin> :t randomR
16:43:31 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
16:43:36 <pumpkin> @src RandomGen
16:43:37 <lambdabot> class RandomGen g where
16:43:37 <lambdabot>    next     :: g -> (Int, g)
16:43:37 <lambdabot>    split    :: g -> (g, g)
16:43:37 <lambdabot>    genRange :: g -> (Int,Int)
16:43:48 <Cale> > let (u,g) = randomR (1,6) (mkStdGen 42); (v,g') = randomR (1,6) g in (u,v)
16:43:50 <lambdabot>   (6,4)
16:43:59 <Cale> So I rolled a 6, and then a 4.
16:44:05 <mpeter> @hoogle md5
16:44:05 <lambdabot> package nano-md5
16:44:05 <lambdabot> package pureMD5
16:44:10 <mpeter> @hoogle puremd5
16:44:10 <lambdabot> package pureMD5
16:44:21 * mpeter glares
16:44:44 <sjanssen> @hackage pureMD5
16:44:44 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pureMD5
16:44:45 <mpeter> http://hackage.haskell.org/packages/archive/pureMD5/0.2.4/doc/html/src/Data-Digest-Pure-MD5.html#md5 oh baby
16:45:14 <tromp__> > randomR (0.5) (mkStdGen 42)
16:45:15 <lambdabot>       No instance for (Fractional (a, a))
16:45:15 <lambdabot>        arising from the literal `0....
16:45:22 <tromp__> > randomR (0,5) (mkStdGen 42)
16:45:23 <lambdabot>   (5,1720602 40692)
16:45:28 <mpeter> what's the most secure hashing algorithm in haskell atm
16:45:46 <mauke> define "most secure"
16:45:48 <pumpkin> mpeter: SHA512
16:45:52 <pumpkin> most bits :P
16:46:29 <mpeter> http://hackage.haskell.org/packages/archive/SHA/1.0.3/doc/html/src/Data-Digest-Pure-SHA.html#sha512 ooh la la
16:47:17 <pumpkin> looks like that SHA512 might benefit from some unboxing?
16:47:24 <pumpkin> data State64 = S64 Word64 Word64 Word64 Word64 Word64 Word64 Word64 Word64
16:47:24 <pumpkin> ?
16:47:32 <pumpkin> unpacking
16:48:01 <dcoutts> pumpkin: the .cabal file uses ghc-options: -funbox-strict-fields
16:48:08 <dons> pumpkin: yeah, !
16:48:11 <pumpkin> are those fields strict though?
16:48:13 <pumpkin> ah
16:48:14 <dcoutts> though the data type does not use ! so it does not make a difference
16:48:17 <dons> i bet they are.
16:48:48 <dcoutts> dons: it is for State32, not State64
16:49:24 <Holle_> cale: why this doesn't work:  test = randomR (1,6) (mkStdGen 42)
16:49:42 <inforichland> I've got a question about a monad transformer I'm trying to use; I'm trying to port the code from the tutorial at http://lisperati.com/casting.html into "proper" Haskell
16:49:52 <Cale> Holle_: it should
16:50:01 <Cale> Holle_: test should be a pair
16:50:12 <Cale> Holle_: which consists of the number 6 and another StdGen value
16:51:05 <pumpkin> dcoutts: did they just forget the ! in the State64? or is it bad to have too much strictness/unboxing on largeish constructors like that?
16:51:20 <inforichland> anyone willing to spare a few minutes for some help ?
16:51:20 <Holle_> cale: ambiguous type variable t in the constraints: num t arising from the literal 1 ....
16:51:35 <Cale> Holle_: ah, it wants to know what kind of number...
16:51:36 <dcoutts> pumpkin: I don't think there should be any problem with it being unboxed
16:51:44 <sjanssen> inforichland: ask away!
16:51:46 <Cale> Holle_: So you'll have to tell it you want an Integer somewhere.
16:52:13 <Cale> > randomR (1, 6 :: Integer) (mkStdGen 42)
16:52:15 <inforichland> sjanssen: thanks :) I'm trying to port the code from the lisp tutorial at http://lisperati.com/casting.html into haskell
16:52:15 <lambdabot>   (6,1720602 40692)
16:52:20 <Cale> > randomR (1, 6 :: Float) (mkStdGen 42)
16:52:21 <lambdabot>   (1.5520351,128694412 1655838864)
16:52:25 <sjanssen> pumpkin: on 32 bit platforms, unboxing will cause it to take twice the memory
16:52:31 <Cale> Makes a big difference ;)
16:52:41 <Cale> Holle_: GHCi and lambdabot have more aggressive defaulting.
16:52:44 <inforichland> sjanssen: and I've a state transformer set up to hold the state of the "world"
16:53:17 <pumpkin> sjanssen: why is that? I'd have thought it would take 50% more memory on 32-bit platforms and 100% more on 64-bit :o (to have it be boxed)
16:53:18 <inforichland> sjanssen: in my function which runs the 'game,', I'm trying to get the state out of the monad, using get and I get an error
16:53:44 <inforichland> sjanssen: no instance for (monadstate GS GameState) arising from a use of 'gets'
16:53:57 <sjanssen> pumpkin: in total memory, yes.  But you've also got to consider the amount of memory that must be copied when only one field is updated
16:54:02 <inforichland> I thought 'gets' just pulled the state out of the monad
16:54:39 <pumpkin> sjanssen: hmm
16:54:41 <sjanssen> inforichland: is GS your transformer?  How is it defined?
16:54:45 <dons> patches to the SHA lib here, http://code.galois.com/cgi-bin/gitweb?p=SHA.git;a=summary
16:54:53 <sjanssen> inforichland: erm, I guess GameState would be the transformer
16:54:57 <Axman6> dons: i got that n-bodies program working using ST and STArrays if you're interested: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=767#a767 the performance isn't that great though (i need to test it against the current version to see how bad it is though)
16:55:03 <inforichland> yes, GameState is the transformer
16:55:08 <pumpkin> dons: galois uses git :o
16:55:12 <dons> Axman6: woot!
16:55:13 <pumpkin> nice! :)
16:55:16 <dons> pumpkin: yup
16:55:24 <Axman6> now i
16:55:25 <inforichland> newtype GameState a = GameState { runGameState :: StateT GS IO a }  deriving (Monad, MonadIO)
16:55:27 <Axman6> bleh
16:55:30 <pumpkin> now I want to work there even more :P
16:55:34 <dons> hehe
16:55:43 <pumpkin> maybe someday
16:55:51 <sjanssen> inforichland: ah, you need to derive the MonadState instance
16:56:02 <sjanssen> inforichland: "deriving (Monad, MonadIO, MonadState GS)"
16:56:09 <inforichland> ahhh
16:56:14 <inforichland> naturally :P
16:56:21 <Axman6> now i'm looking at moving it to STUArrays, though the definition of instance MArray (STUArray s) Body (ST s) is not something i have the foggiest idea how to implement
16:56:31 <dons> did you see my defin?
16:56:33 <pumpkin> Axman6: you should try the MUArr
16:56:44 <dons> pumpkin: we dont' have uarr's on the target machien
16:56:45 <inforichland> sjanssen: thanks!
16:56:49 <dons> but that's the approach, yes
16:56:51 <pumpkin> oh
16:57:02 <pumpkin> dons: what's the target machine?
16:57:06 <dons> unless there's a debian package, which i doubt
16:57:09 <dons> the shootout quad core
16:57:13 <Axman6> dons: the one you pasted got cut off by hpaste's limited paste length :(
16:57:13 <pumpkin> oh, cool!
16:57:14 * roconnor tries to stop thinking about STFUArrays
16:57:18 <pumpkin> lol
16:57:18 <dons> Axman6: oh
16:57:21 <dons> roconnor: :D
16:57:28 <pumpkin> that actually made me chuckle
16:57:31 <Axman6> roconnor: heh
16:57:46 <dons> roconnor: great reply next time you see someone use lists inappropriately
16:57:53 <roconnor> :D
16:58:42 <Axman6> i'm going to have to play with ST more i think, it seems exteremely useful
16:58:56 <poliquin> Newbie Arrow question .. I'm working my way through "Programming with Arrows" and am stumped ..
16:58:59 <poliquin> http://hpaste.org/13970
16:59:24 <poliquin> (>>>) wants an instance of (->) ... ????
16:59:49 <dons> where's mmorrow's paste?
17:00:07 <pumpkin>  http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/ ?
17:00:15 <dons> Axman6: at the bottom of this: http://galois.com/~dons/tmp/B.hs
17:00:40 <mauke> poliquin: you're calling >>> with two functions
17:00:49 <BMeph> poliquin: What're the types of f and g? :)
17:01:00 <Axman6> oh heh, that's a lot larger than i expected
17:01:37 <poliquin> BMeph, .. I'm not sure (arr (+1))?
17:02:08 <BMeph> poliquin: To quote the l-bot, "bzzzt!"
17:02:22 <poliquin> mauke, True but I thought -> was part of the language .. I don't have any imports so it seemed like it couldn't sneak in)
17:02:35 <mauke> poliquin: huh?
17:02:41 <BMeph> poliquin: I'll ask again, "what are the types of 'f' and of 'g'? :)
17:02:42 <mauke> poliquin: yes, -> is part of the language. so?
17:02:51 <polveroj> poliquin: (->) is the type of functions -- the type (a -> b) is the same as ((->) a b)
17:04:04 <polveroj> poliquin: it's built in, but it can have instances (or fail to, in this case) of type classes like any other type
17:05:27 <poliquin> polveroj, Ok .. now it starts to make a bit of sense ..
17:05:52 <Holle_> cale: what to do with the gen? http://hpaste.org/13971
17:07:07 <Cale> Holle_: the idea is that your shuffle function is going to take a StdGen as a parameter (and maybe return one too, along with its result, though that's not strictly necessary here)
17:07:26 <Cale> Holle_: and the new StdGen you get is what you'll pass to the recursive call
17:07:44 <Axman6> dons: just curious, why do you use case statements in unsafeRead and unsafeWrite?
17:08:01 <poliquin> BMeph .. I have no idea what types f and g are ..
17:08:18 <dons> case is precise?
17:08:28 <dons> i don't want to allocate.
17:09:05 <poliquin> polveroj, Thanks for the lead .. I'll go contemplate that for awhile ..
17:09:32 <Axman6> so saying let (# s2, xd    #) = readDoubleArray# arr j         s1 would allocate then?
17:10:00 <inforichland> join #tutbot-testing
17:10:03 <inforichland> oops
17:10:20 <dolio> Axman6: What was it using before? Ptr/Addr?
17:10:47 <Axman6> dolio: what was what? my n-bodies program?
17:11:14 <dolio> n-bodies, yes. From the shootout, no?
17:11:18 <pumpkin> Axman6: I thought you were using DPH for your n-bodies program?
17:11:34 <Axman6> dolio: yeah, that's the one
17:11:55 <Axman6> pumpkin: i tried it, i would prefer it didn't eat up a gig of ram in less than three seconds tbh :P
17:12:00 <pumpkin> lol
17:12:05 <pumpkin> maybe http://is.gd/Gf7 ?
17:12:12 <pumpkin> ;)
17:12:13 <dolio> Yeah, it uses Ptr.
17:12:44 <Axman6> i've written three versions now, one list, one DPH, and now STArrays. i'll probably end up with a third that uses STUArrays
17:13:10 <roconnor> The Booleans are the coproduct of the final object with itself right?
17:13:12 <Holle_> cale: what is the stdGen paramater? snd of the result?
17:13:52 <mapreduce> I think someone here mentioned a PDF version of RWH.  Where is that?
17:14:00 <dolio> roconnor: Sounds right.
17:14:16 <Cale> So, you'll have something like  shuffle :: StdGen -> [a] -> ([a], StdGen)
17:14:36 <roconnor> dolio: Or in other words, 1+1 = 2?
17:14:41 <dolio> Yeah.
17:14:49 <Cale> shuffle g [] = ([],g)
17:14:57 <roconnor> I knew the Booleans were some fancy stuff from category theory
17:15:04 <roconnor> too complicated for programmers
17:15:08 <dolio> :)
17:17:01 <Cale> shuffle g xs = let (n, g') = randomR (0, length xs - 1) g; (us, v:vs) = splitAt n xs; (ys, g'') = shuffle g' (us++vs) in (v:ys, g'')
17:17:17 <Cale> Of course, you'll probably want to avoid recomputing the length over and over.
17:17:20 <christo_m> why am i getting an error like "parse error on input 'type' "
17:17:31 <christo_m> im trying to do something like type Number = Int
17:17:39 <christo_m> sorry im new :(
17:17:42 <mapreduce> > let tru = \t f -> t in let fls = \t f -> f in tru 5 4 * fls 2 3
17:17:43 <lambdabot>   15
17:17:47 <Cale> So it would be best to make this a helper function in a where clause, and take the remaining length as a parameter
17:19:47 <christo_m> anyone know?
17:20:22 <inforichland> christo_m: what do you have up above that? b/c that should be legal
17:20:38 <christo_m> inforichland, nothing
17:20:44 <christo_m> inforichland, i just opened ghci
17:21:05 <inforichland> christo_m: I dont' think 'type' statements are legal in GHCI
17:21:10 <christo_m> inforichland, oh :(
17:21:35 <christo_m> inforichland, im just going through RWH trying things out, but yeah apparently a lot of it is different, or not possible in GHCI
17:21:45 <steshaw> @index concatMap
17:21:45 <lambdabot> Data.List, Prelude
17:21:49 <christo_m> for instance i didnt know you had to put "let" before in the GHCI when binding values to variables
17:21:49 <Cale> christo_m: GHCi only wants expressions which it will evaluate
17:21:51 <inforichland> christo_m: more or less
17:21:59 <steshaw> @index flatMap
17:21:59 <lambdabot> bzzt
17:22:01 <Cale> christo_m: To make declarations, you put them in a file, and load it with GHCi
17:22:09 <christo_m> Cale, hey i remember you from #math
17:22:33 <Cale> christo_m: 'let' is a bit of an exception to that -- the explanation is that GHCi acts a bit like the inside of an IO monad do-block
17:22:38 <chessguy> hey, i'm drawing a blank on this one: given the definitions in http://hpaste.org/13972 , i want to write a function that converts a MetricPrime to a Metric (or maybe the other way)
17:22:50 <Cale> except that it adds 'print' to expressions which are not IO actions.
17:23:00 <Cale> (so as to print the result)
17:23:19 <Cale> But really, you're not meant to make declarations at the GHCi prompt.
17:23:28 <BMeph> pumpkin: It's a shootout on a debian machine. They won't get DPH on it unti two years after it's been used mainstream. ;p
17:23:32 <di3go> hello everyone!
17:23:37 <pumpkin> BMeph: boo :)
17:24:01 <Holle_> cale: works :) but it alway returns the same?! what can i do against it?
17:24:04 <BMeph> hello di3go!
17:24:22 <Cale> Holle_: You need to supply different StdGen values initially
17:24:40 <Cale> Holle_: To get a "random" StdGen, you can use the IO action 'newStdGen'
17:24:43 <Cale> :t newStdGen
17:24:45 <lambdabot> IO StdGen
17:25:01 <Cale> and then pass that StdGen down into functions which need it.
17:25:04 <Holle_> but uses io
17:25:17 <Cale> Right. The 'main' of your program must be in IO anyway.
17:25:23 <Cale> So you can write something like...
17:25:35 <Cale> main = do ... get some input from the user, etc ...
17:25:44 <Cale>           g <- newStdGen
17:26:00 <Cale>           let (ys,g') = shuffle xs
17:26:06 <Cale>           print ys
17:26:34 <Cale> Or if you need to call shuffle from another pure function, that function should just take a StdGen as a parameter.
17:26:53 <Holle_> ok looks nice :)
17:27:15 <Cale> er, that should have been   let (ys,g') = shuffle g xs
17:27:17 <Cale> of course
17:28:09 <Holle_> great!
17:28:14 <Holle_> thank you very much!
17:28:26 <Gracenotes> @hoogle [a] -> ([a],[a])
17:28:27 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
17:28:27 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
17:28:27 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
17:28:56 <Gracenotes> hrm. There must be a simple back-and-forth split method...?
17:30:36 <chessguy> Gracenotes:  you'd be surprised
17:31:13 <Gracenotes> > break (even . fst) $ zip [1..] "abcdefg"
17:31:14 <lambdabot>   ([(1,'a')],[(2,'b'),(3,'c'),(4,'d'),(5,'e'),(6,'f'),(7,'g')])
17:31:27 <Gracenotes> oh...
17:31:33 <Gracenotes> > span (even . fst) $ zip [1..] "abcdefg"
17:31:35 <lambdabot>   ([],[(1,'a'),(2,'b'),(3,'c'),(4,'d'),(5,'e'),(6,'f'),(7,'g')])
17:31:39 <Gracenotes> -.-
17:31:53 <BMeph> > partition (even . fst) $ zip [1..] "abcdefg"
17:31:55 <lambdabot>   ([(2,'b'),(4,'d'),(6,'f')],[(1,'a'),(3,'c'),(5,'e'),(7,'g')])
17:32:17 <Gracenotes> that's the one
17:32:53 <pumpkin> what does span do?
17:33:02 <Gracenotes> opposite of break, iirc
17:33:34 <Gracenotes> break f xs = span (not . f) xs
17:33:44 <Gracenotes> @src span
17:33:44 <lambdabot> Source not found.
17:34:16 <BMeph> Yep. breay stops splitting the first time the predicate fails, span stops when it matches.
17:34:21 <BMeph> *break
17:34:34 <Gracenotes> > uncurry (\a b -> (map snd a, map snd b)) $ partition (even . fst) $ zip [1..] "abcdefg"
17:34:36 <lambdabot>   ("bdf","aceg")
17:34:47 <Gracenotes> > uncurry (\a b -> (map snd a, map snd b)) $ partition (odd . fst) $ zip [1..] "abcdefg"
17:34:48 <lambdabot>   ("aceg","bdf")
17:34:55 <Gracenotes> yay :D
17:37:19 <pumpkin> > partitionEither $ zipWith ($) (cycle [Left, Right]) "abcdef"
17:37:20 <lambdabot>   Not in scope: `partitionEither'
17:37:29 <pumpkin> , partitionEithers $ zipWith ($) (cycle [Left, Right]) "abcdef"
17:37:31 <lunabot>  ("ace","bdf")
17:38:02 <chessguy> @pl \x -> f (f' x, s x)
17:38:02 <lambdabot> f . liftM2 (,) f' s
17:38:19 <pumpkin> , partitionEithers $ zipWith ($) (cycle [Left, Right]) "Gracenotes"
17:38:22 <lunabot>  ("Gaeoe","rcnts")
17:39:42 <gnuvince_> Is it possible in GHC to view the source code of a function or of an instance of a type class?
17:39:54 <pumpkin> not easily, but lambdabot will show you
17:39:57 <pumpkin> @src foldl
17:39:57 <lambdabot> foldl f z []     = z
17:39:57 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
17:40:38 <gnuvince_> @src (>>=)
17:40:38 <lambdabot> Source not found. Do you think like you type?
17:40:44 <sclv> gnuvince_: I tend to use the hierarchical libraries, although the src listings are broken for the 6.10 ones, which is insanely annoying.
17:40:45 <gnuvince_> @src [].(>>=)
17:40:45 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
17:40:51 <pumpkin> @src [] (>>=)
17:40:51 <lambdabot> xs >>= f     = concatMap f xs
17:44:49 <chessguy> @type sortBy (comparing snd)
17:44:50 <lambdabot> forall a b. (Ord b) => [(a, b)] -> [(a, b)]
17:51:15 <inforichland> @type liftM
17:51:16 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
17:51:29 <eu-prleu-peupeu> hello Haskl3z0rs
17:52:00 <pumpkin> Cale: around?
17:52:20 <Cale> pumpkin: yeah, sorta
17:53:15 <pumpkin> Cale: I was wondering how mathematically sound my quest for making Data.Map and matrices into instances of Arrow (or a restricted variant of it, assuming I can figure it out)
17:53:26 <eu-prleu-peupeu> are you guys all from the US of A ?
17:53:44 <Cale> eu-prleu-peupeu: no
17:53:48 <pumpkin> eu-prleu-peupeu: nope
17:53:53 <jeffz`> eu-prleu-peupeu: no
17:54:02 <Gracenotes> no. (though I am)
17:54:07 <Cale> pumpkin: Arrow is a sort of a strange class.
17:54:15 <eu-prleu-peupeu> why are you all awake then ?
17:54:15 <Cale> pumpkin: You might have trouble with arr
17:54:22 <Cale> eu-prleu-peupeu: I'm from Canada.
17:54:25 <eu-prleu-peupeu> ah ok
17:54:32 <Gracenotes> hmm? It's 8:54
17:54:44 <birdspider> eu-prleu-peupeu: because time is not usa and rest
17:54:53 <pumpkin> Cale: I'm already having trouble with Ord/Num constraints :)
17:55:01 <eu-prleu-peupeu> ok ok
17:55:10 <pumpkin> Cale: but I'd love to be able to compose them as functions if that makes sense
17:55:14 <Gracenotes> in the US it's mid-afternoon to evening
17:55:18 <eu-prleu-peupeu> im from portugal, here is like almost 2am
17:55:23 <birdspider> eu-prleu-peupeu: :) but its definitly late here in europe so good night
17:55:31 <wli> 9PM here.
17:55:33 <eu-prleu-peupeu> hehe
17:55:44 <Cale> pumpkin: Maybe just start by writing a function compose :: Map b c -> Map a b -> Map a c
17:55:48 <eu-prleu-peupeu> wli where you at ?
17:55:59 <BMeph> 5:55 PM here. :)
17:56:01 <Cale> pumpkin: But you can't really make it a good Arrow instance
17:56:02 <wli> Florida.
17:56:11 <BMeph> (In California.)
17:56:24 <Cale> Since that requires you to write  (a -> b) -> Map a b
17:56:59 <eu-prleu-peupeu> thats nice... seems like people from that side of the ocean are more haskle prone than from this side
17:57:01 <pumpkin> Cale: well I was hoping to use my recent exploration of my Enumerable/Countable (still haven't decided what to call it) class to be able to enumerate the domain :P
17:57:04 <ddarius> You know you're doing crazy crap when your type signatures are significantly longer than your code and the list of extensions is longer than most of your functions.
17:57:14 <pumpkin> (I'm not saying this is practical, just fun)
17:57:25 <pumpkin> ddarius: me?
17:57:33 <BMeph> Cale: Yeah, I've seen that that stupid arr function breaks all the fun ideas for making Arrows out of many binary types (?).
17:58:06 <pumpkin> Cale: it seems strange to have such an attractive arrow class but have almost no instances of it (that I've seen) :/
17:58:07 <ddarius> pumpkin: Does that describe your code?
17:58:16 <pumpkin> ddarius: not yet! :)
17:58:43 <BMeph> pumpkin: Have a blog describing the pkg, or do you just Tweet? ;)
17:58:45 * ddarius wants type functions.
17:58:55 <ddarius> Which is pretty typical when I do crazy crap.
17:59:09 <pumpkin> BMeph: nah, no blog! never got into it... what pkg?
17:59:18 <BMeph> (Feel free to insert "Do you" before the "Have". ;)
17:59:47 <pumpkin> @instances Arrow
17:59:47 <ddarius> BMeph: Completely unnecessary
17:59:47 <lambdabot> (->), Kleisli m
17:59:51 <BMeph> that Countable thing. Or is it just copies of Escardo's thing? :)
17:59:55 <ddarius> You can also make CoKleisli arrows.
18:00:07 <pumpkin> BMeph: not sure what Escardo's thing is :o but Countable just lives on hpaste for now :P
18:00:11 <ddarius> And there are a few examples that are properly Arrows.
18:00:15 <pumpkin> it was just me fooling around
18:00:43 <BMeph> pumpkin: http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/#comment-11186
18:00:45 <pumpkin> BMeph: http://hpaste.org/13908 if you're interested (it's massively inefficient)
18:00:52 <pumpkin> BMeph: oh no, nothing that interesting unfortunately :P
18:00:53 <eu-prleu-peupeu> check this out: http://extremepresentation.typepad.com/blog/files/choosing_a_good_chart.pdf
18:00:54 <eu-prleu-peupeu> brutal :D
18:01:14 <eu-prleu-peupeu> i guess im going to sleep now... and dream about all the haskle code that i did not produce today :)
18:02:08 <chessguy> @undo do { m <- f k1 s; m' <- f k2 s; f m m' }
18:02:08 <lambdabot> f k1 s >>= \ m -> f k2 s >>= \ m' -> f m m'
18:02:27 <chessguy> is that itching to be refactored, or is it just me?
18:03:02 <chessguy> eu-prleu-peupeu:  what is that?
18:03:04 * ddarius begins to write code by trial and error until it type checks.  When it type checks it will be the correct code.
18:03:32 <chessguy> ddarius:  Type Driven Development?
18:03:34 <pumpkin> ddarius: ddjinn!
18:03:39 <Axman6> lisfM2 f (f k1 a) (f k2 s)?
18:03:43 <Axman6> liftM2*
18:03:58 <Cale> yep
18:04:10 <Axman6> awesome :
18:04:12 <Axman6> :)
18:04:33 <eu-prleu-peupeu> chessguy: its a diagram to help choose the right chart to represent information
18:04:36 <ddarius> pumpkin: I don't think djinn will be able to handle the many higher rank types I'm using.
18:04:46 <pumpkin> ddarius: you're a more sophisticated djinn then
18:07:52 <Axman6> eu-prleu-peupeu: that chart looks quite useful actually
18:08:25 <dmajnem2> what is up with cabal and manpages? do most packages not have them or what?
18:08:48 <Cale> dmajnem2: Most packages have only haddock documentation
18:08:51 <Axman6> most packages use Haddock afaik
18:09:05 <dmajnem2> hmm, ok
18:09:25 <ddarius> pumpkin: Nah, I ended up using understanding rather brute-force or blind logic.  Oh well.
18:09:34 <MyCatVerbs> dons: sweet! But "the programmer is responsible for..." sounds like absolutely every single operation should be tagged with the word "unsafe".
18:09:45 <Cale> dmajnem2: Haddock documentation is in html format. If the package built correctly on the hackage server (which is less often than it really should be these days), you can click the links to the documentation from the package's page on hackage.
18:10:31 <Axman6> is there any way to find out which cabal-installed packages are out of date?
18:10:45 <dmajnem2> coolness, I think I will manage to adjust to that
18:11:32 <Axman6> i put a link to my local GHC docs in my bookmarks bar yesterday, very handy when i don't have a net connection
18:14:58 <BMeph> Axman6: I use it even with a connection. :)
18:15:12 <Axman6> yeah, i think i will be doing that too
18:15:37 <Axman6> when you use cabal-install to install the docs, is it possible to get those integrated into the GHC docs too?
18:17:00 <Axman6> or even to get an index page for all your cabal-installed libraries?
18:18:42 <jberryma1> I'm using a simple Zipper that stores a history list of partially-applied types. looks something like: type Zipper wrap tree = ( [wrap(tree->tree)] , tree )
18:18:47 * Axman6 thinks he might file a bug about GHC not compiling as a 64-bit program on OS X
18:18:50 <chessguy> pardon my idiocy, but i can't seem to find this - how do i find out whether there's anything in the current directory that hasn't been "darcs add"ed
18:19:21 <jberryma1> should work with any recursive type. would this be useful for others I'm wondering?
18:20:33 <chessguy> jberryma1:  sounds interesting. can you give an idea how it would be used?
18:20:54 <Cale> Axman6: If you find out a way to get integrated documentation, let me know.
18:21:01 <Cale> Axman6: I would really love that.
18:21:29 <pumpkin> Cale: so you don't think it would be worth it / possible to try to make a Map into an arrow?
18:21:35 * pumpkin pouts
18:21:47 <Cale> pumpkin: Well, maybe something built around Data.Map could be
18:22:08 <Cale> Like something which is a Map a b with a fall-through to a function (a -> b)
18:22:21 <pumpkin> hmm
18:22:29 <pumpkin> I was thinking of just throwing an error in that case :P
18:22:34 <pumpkin> but that might be better
18:24:43 <pumpkin> Cale: how about a matrix instance?
18:24:54 <jberryma1> chessguy: should have posted to hpaste, but this is what my tree would like like when we just went down the right branch from the root: ( [Left(\r-> Node 1 End r)], Node 2 End End ) :: Zipper Either BinaryTree
18:24:56 <pumpkin> (for linear maps)
18:25:51 <Cale> pumpkin: With the right interpretation that's doable...
18:26:30 <roconnor> @seen vixey
18:26:31 <lambdabot> I saw vixey leaving #scala, #perl6, ##logic and #haskell 2h 48m ago, and .
18:26:34 <Cale> pumpkin: You would perhaps have  Linear a b  where a and b were types representing the bases of vector spaces, I suppose.
18:27:18 <polveroj> pumpkin: iirc Conal did some blog posts on linear maps, although I think they were just Applicative and not full Arrows
18:27:21 <jberryma1> if you don't need to inspect where you've been you can get rid of Zipper's first variable (Either in the axample). Then going up layer is as simple as: goUp ( (f:fs),n) = (fs, f n)
18:27:22 <shapr> @users
18:27:22 <lambdabot> Maximum users seen in #haskell: 658, currently: 623 (94.7%), active: 15 (2.4%)
18:27:28 <shapr> @yow !
18:27:28 <lambdabot> I'm a GENIUS!  I want to dispute sentence structure with SUSAN SONTAG!!
18:27:32 <Axman6> bleh, it anoys me that process 1.0.1.1 is on hackage, stops me from being able to use cabal upgrade :(
18:27:37 <shapr> wassup mah homies?
18:27:39 <pumpkin> polveroj: yeah, I read those... I was hoping to make that or something like it into an arrow
18:27:47 <shapr> Er, wait, I'm channeling palomer, doh!
18:28:00 <shapr> Greetings brightest minds of IRC!
18:28:22 <roconnor> hi shapr
18:28:29 <shapr> hiya roconnor !
18:28:34 <pumpkin> yo yo
18:29:10 <shapr> hello gourd!
18:29:22 <roconnor> shapr: did you know that the Booleans is the coproduct of a final object with itself?
18:29:22 <shapr> You're looking gourdgeous today!
18:29:35 <shapr> I did not know that, can you illustrate it?
18:29:40 <roconnor> yes
18:29:42 <roconnor> 1+1 = 2
18:29:45 <shapr> oooh
18:29:59 <shapr> Now can you illustrate in some way that I can understand? :-/
18:29:59 <pumpkin> lol
18:30:22 <dolio> Booleans are too hard.
18:30:28 <shapr> Jag har ingen åning vad du säger :-(
18:30:29 <inforichland> 2 + 2 = 5
18:30:43 <roconnor> shapr: :D
18:30:54 <dolio> We should have a newtype OneOrZero = OOZ Int in Haskell instead.
18:31:11 <chessguy> @let 2 = 3 in 2 + 3
18:31:11 <lambdabot>   Parse error
18:31:17 <roconnor> shapr: 1 aka unit or () is a final object because there is always a function to ()
18:31:17 <chessguy> > let 2 = 3 in 2 + 3
18:31:19 <lambdabot>   5
18:31:21 <Cale> shapr: In the category of sets, the booleans are represented by any 2-element set, say {0,1}. A terminal object is any one-element set.
18:31:25 <BMeph> polveroj: Aren't Applicatives super-types of Arrows? ;)
18:31:32 <inforichland> > let 2 + 2 = 5 in 2 + 2
18:31:34 <lambdabot>   5
18:31:35 <chessguy> wait, what?
18:31:39 <roconnor> @type \_ -> ()
18:31:40 <lambdabot> forall t. t -> ()
18:31:43 <chessguy> shouldn't that have been 6?
18:31:53 <roconnor> Either is a coproduct
18:32:02 <roconnor> and the booleans are equivalent to Either () ()
18:32:08 <dolio> 2 isn't a variable that you can bind.
18:32:15 <polveroj> BMeph: I thought it was the other way around, although now I'm not sure
18:32:18 <roconnor> where True = Right () and False = Left ()
18:32:20 <chessguy> oh, boo
18:32:29 <polveroj> @google arrows meticulous monads applicative
18:32:30 <chessguy> it should throw an error then
18:32:31 <inforichland> dolio: how come let 2 + 2 = 5 in 2 + 2 works then ?
18:32:32 <shapr> So, why is a 2-element set the coproduct of any one-element set?
18:32:37 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf
18:32:37 <lambdabot> Title: Idioms are oblivious, arrows are meticulous, monads are promiscuous
18:32:47 <dolio> chessguy: Should "let Just x = Nothing in 5" throw an error, too?
18:32:48 <roconnor> Either is a coproduct because it is dual to the cartisian product (,)
18:32:53 <shapr> Given the choice, I'd be monadic.
18:33:11 <roconnor> the carisian product (a,b) has two function fst : (a,b) => a and snd (a,b) => b
18:33:16 <chessguy> dolio:  hmm.
18:33:25 <BMeph> @go promiscuous idioms
18:33:28 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf
18:33:28 <lambdabot> Title: Idioms are oblivious, arrows are meticulous, monads are promiscuous
18:33:35 <BMeph> I WIN! :)
18:33:45 <roconnor> Either is dual to this because Either a b has two functions Left :: a => (a,b) and Right :: b => (a,b)
18:33:55 <Cale> A coproduct of that terminal object 1 with itself is an object 1+1 together with maps i: 1 -> 1+1, j: 1 -> 1+1 such that for any Y and maps u: 1 -> Y and v: 1 -> Y, there is a unique map u + v: 1+1 -> Y such that (u+v) . i = u, and (u+v) . j = v
18:34:25 <Cale> The two-element set, together with the two obvious functions which pick out each element fits the bill perfectly.
18:34:38 <shapr> oh, that makes sense.
18:35:02 <bombshelter13> What's the usual haskell technique for changing an [[a]] into a [a] that is a concatenation of it's component [a]'s? (i.e., [[1,2][3,4]] => [1,2,3,4])
18:35:18 <shapr> Wasn't there a flatten function floating around?
18:35:21 <shapr> @index flatten
18:35:21 <lambdabot> Data.Tree
18:35:29 <roconnor> bombshelter13: concat
18:35:33 <Cale> So in an arbitrary category, if you wanted to define the booleans, you'd look for such an object -- the coproduct of a terminal object with itself.
18:35:38 <dolio> concat, join, mconcat, fold.
18:35:39 <BMeph> bombshelter13: Um, we call it "concat". ;p
18:35:46 <roconnor> bombshelter13: or if you are feeling abstract, you can use join
18:35:47 <cads_> dudes, i'm interested in the idea of an anonymous and ubiquitous computing fabric made up of volunteer computers, where autonomous agents will satisfy certain security proofs and provide decentralized services according to a social model assigning compute credits to a service according to usefulness... do you guys know of any place to read more about those kinds of notions?
18:36:03 <roconnor> > concat [[1,2][3,4]]
18:36:05 <lambdabot>   Couldn't match expected type `t -> [a]'
18:36:07 <roconnor> > concat [[1,2],[3,4]]
18:36:09 <shapr> cads_: Lots of stuff floating around on the internet, look for those volunteer computers serving up such stuff ;-)
18:36:09 <lambdabot>   [1,2,3,4]
18:36:13 <roconnor> > join [[1,2],[3,4]]
18:36:15 <lambdabot>   [1,2,3,4]
18:36:37 <cads_> shapr: I'll launch a few data dogs to sniff them out post haste :D
18:36:38 <shapr> cads_: But I've not seen anything that joins together all of those ideas.
18:36:40 <BMeph> @go distributed.net
18:36:46 <lambdabot> http://www.distributed.net/
18:36:46 <lambdabot> Title: distributed.net: Node Zero
18:36:53 <ddarius> Crap.  I really need those two overlapping instances now.
18:36:57 <shapr> cads_: The biggest problem I've seen is that there's no good way to assign compute credits.
18:37:29 <roconnor> > mconcat [[1,2],[3,4]]
18:37:31 <lambdabot>   [1,2,3,4]
18:37:35 <ddarius> Actually...
18:37:37 <roconnor> > fold [[1,2],[3,4]]
18:37:38 <lambdabot>   Not in scope: `fold'
18:37:38 <cads_> shapr, i'd imagine having to create code with security proofs would be nasty too
18:37:42 <dolio> , fold [[1,2],[3,4]]
18:37:44 <bombshelter13> roconnor:  thanks! that seems to do it :)
18:37:44 <lunabot>  luna: Not in scope: `fold'
18:37:50 <shapr> cads_: Nah, proof carrying code isn't that hard.
18:37:57 <dolio> > Data.Foldable.fold [[1,2],[3,4]]
18:37:58 <lambdabot>   [1,2,3,4]
18:38:20 <shapr> cads_: There are several type systems that can give guarantees on max memory and cpu usage.
18:38:21 <roconnor> @type Data.Foldable.fold
18:38:22 <Axman6> :t Data.Foldable.fold
18:38:22 <lambdabot> forall (t :: * -> *) m. (Monoid m, Data.Foldable.Foldable t) => t m -> m
18:38:23 <lambdabot> forall (t :: * -> *) m. (Monoid m, Data.Foldable.Foldable t) => t m -> m
18:38:31 <roconnor> ah
18:38:44 <roconnor> so many ways to concat
18:38:55 <roconnor> each special in it's own way
18:39:09 <dolio> @type Data.Foldable.concat
18:39:10 <chessguy> @type all
18:39:10 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t) => t [a] -> [a]
18:39:11 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
18:39:14 <dolio> There's that, too.
18:39:27 <BMeph> cads: How do you assign credits securely to anonymous coomponents?
18:39:37 <shapr> cads_: But to be honest, I think most of the advantages of autonomous agents are subsumed by google's column stores.
18:40:04 <BMeph> *components
18:40:21 <cads_> I don't know how anonymous the components could be, you could always inspect their code to see what they do
18:41:12 * chessguy had to purposely try to break a test to make sure i'm testing right, because i haven't seen one fail all night!
18:41:38 <cads_> but an encoding of a component's philosophical aims along with a proof showing that it's true could give your system a way of choosing whether it wants to run it
18:41:48 <BMeph> cads: Oops, I guess I meant: *fabric components
18:41:49 <chessguy> wchogg:  ^^
18:42:07 <pumpkin> BMeph: each anonymous component provides a hash of his work unit to the server, which the server signs. the anonymous component then sends his work unit, and presents the server signature later on to prove it's him
18:42:18 <shapr> cads_: I've only heard of one guy trying to encode ethics, though it does seem to me like it'll work.
18:42:34 <pumpkin> BMeph: maybe?
18:42:37 <shapr> From what he was doing, it seemed to me that security is codified ethics.
18:42:41 * pumpkin shrug
18:42:45 <cads_> there could also be a distributed karma authority
18:43:12 <BMeph> pumpkin: Hm, maybe if signed ny the server's pub key, that might work... :)
18:43:16 <shapr> cads_: I don't know how that would work. The fact that there's no currency for the internet is the biggest problem I've seen for your idea.
18:43:23 <Axman6> @karma
18:43:23 <lambdabot> You have a karma of 1
18:43:25 <shapr> @karma
18:43:25 <lambdabot> You have a karma of 1
18:43:30 <shapr> Axman6++
18:43:32 <Axman6> cads_: i suggest using lambdabot
18:43:33 <cads_> @karma
18:43:33 <lambdabot> You have a karma of 0
18:43:33 <pumpkin> @karma
18:43:33 <lambdabot> You have a karma of 2
18:43:35 <Axman6> @karma
18:43:36 <lambdabot> You have a karma of 2
18:43:38 <Axman6> whoot
18:43:41 <pumpkin> lol
18:43:44 <Axman6> shapr++
18:43:45 <roconnor> @karma
18:43:45 <lambdabot> You have a karma of 2
18:43:49 <roconnor> :)
18:44:04 <cads_> Axman6: I read the article on safely executing untrusted code, it was very interesting
18:44:15 <shapr> cads_: There's one problem with distributed karma, how do you stop inflation that would come from mutual back scratching?
18:44:19 <BMeph> shapr: I'd say that people consistently say things differently from how they act, is the biggest problem. ;)
18:44:23 <Axman6> i just meant for the karma stuff :P
18:44:26 <shapr> cads_: I think it would be more useful to have local karma.
18:44:43 <cads_> like network of trust?
18:44:45 <shapr> "This guy did something useful for me, he has credit over here."
18:45:09 <centrinia> shapr: You could have conservative karma.
18:45:19 <centrinia> You  give  your own karma to someone else.
18:45:21 <shapr> centrinia: How would that work?
18:45:29 <cads_> I think that would evolve into universal credits
18:45:39 <shapr> centrinia: That's true. You could transfer your local karma to be owned by someone else.
18:45:43 * BMeph cringes at whatever version of American Express that system will need
18:45:54 <cads_> esentially it would be a karma barter system at first :D
18:45:54 <centrinia> Oh, karma credit.
18:45:55 <flippo> Sounds like a job for eigenanalysis, like measuring relevant webpages
18:46:19 <mpeter> i hesitate to even ask but
18:46:20 <shapr> hiya flippo! Long time no see!
18:46:31 <mpeter> is it possible to use haskell to dump the memory of a program to a file that it can renew later
18:46:34 <centrinia> The karma economy will evolve to include karma credit default swaps. :)
18:46:40 <flippo> shapr, yes, I saw the door open and came in.
18:46:41 <cads_> has anyone here read the novel accelerando?
18:46:49 <shapr> flippo: Nice to see you again.
18:46:52 <shapr> cads_: Whuffie?
18:47:02 <polveroj> cads_: yep :)
18:47:08 <cads_> hah, I haven't read  down and out
18:47:12 <flippo> shapr, I'm reassured that you are still here.  Seems busier than ever.
18:47:13 <bd_> http://content3.wuala.com/contents/Dominik%2FDocuments%2FWuala%2BPapers%2Fnetecon06.pdf <-- relevant to the distributed karma discussion
18:47:14 <shapr> I didn't look too closely at whuffie, but it seems to be a zero sum game to me.
18:47:22 <shapr> flippo: I am always here ;-)
18:47:52 <cads_> I think that it's not, because there is always novelty being injected into the system, I think karma would reward that
18:47:53 <shapr> flippo: Yeah, I think we hit 670 or so, I don't know the most recent max number of clients on #haskell.
18:48:10 <shapr> @users
18:48:10 <lambdabot> Maximum users seen in #haskell: 658, currently: 620 (94.2%), active: 21 (3.4%)
18:48:14 <mpeter> anybody? out-of-bounds pointers in haskell?
18:48:32 <flippo> Bigger than ##c now.   Who would have guessed?
18:48:37 <shapr> flippo: me me me!
18:48:41 * shapr boings frumiously
18:48:51 <Axman6> shapr: well done btw :)
18:48:54 <shapr> yay!
18:49:06 <shapr> flippo: 7 years, 37 weeks, 3 days...
18:49:16 <flippo> shapr, I'm sure you're responsible for at least 600 of them.
18:49:18 <cads_> I wonder what percentage of processor utilization we have worldwide
18:49:42 <shapr> flippo: Nah, the past few years it's been dons, Cale and others. I've been busy.
18:49:52 <mpeter> a program that saves the state of another program either virtualized or just abstracted within it
18:49:57 <mpeter> is there such a program
18:50:15 <shapr> mpeter: valgrind? vmware/xen/etc?
18:50:22 <shapr> Velociraptors: Nice nickname!
18:50:29 <cads_> in could be that a computing fabric would have spare cycles that could be grabbed up just for free
18:50:29 * Velociraptors !!!
18:50:35 <Velociraptors> ta :)
18:50:50 <mpeter> valgrind looks close
18:51:06 <Axman6> hey Velociraptors :)
18:51:07 <shapr> cads_: computing cycles aren't completely free though. They cost electricity and heat.
18:51:07 <ddarius> Okay, -now- I need those overlapping instances.
18:51:13 <Axman6> ?users
18:51:13 <lambdabot> Maximum users seen in #haskell: 658, currently: 623 (94.7%), active: 21 (3.4%)
18:51:35 <roconnor> Velociraptors: how fast can you go on a hoverboard?
18:51:37 <shapr> flippo: I think I handed off maintainership of #haskell to dons around 500 users.
18:51:54 <cads_> shapr, that is true, but there may be enough volunteers
18:51:57 <mpeter> nice joy shapr ;)
18:52:00 <mpeter> job*
18:52:04 <shapr> thanks :-)
18:52:15 <Velociraptors> roconnor: 40m/s!
18:52:23 <cads_> would you volunteer your cycles to an anarchistic computing initiative, shapr?
18:52:55 <shapr> I don't think there's such a thing as pure anarchism, so I'd probably have to understand the goals of the initiative.
18:52:58 <roconnor> Velociraptors is legit
18:53:05 <shapr> cads_: Are you thinking of crypt.net from snow crash?
18:53:18 <shapr> Er, wait, that was Diamond Age?
18:53:27 <cads_> haven't read that one
18:53:29 <shapr> Right, a Young Lady's Primer
18:53:35 <shapr> cads_: It's interesting.
18:53:35 <Velociraptors> Axman6: ahoi - figured I'd lurk some.
18:53:47 <shapr> Velociraptors: Does Haskell work well on a mac?
18:53:53 <cads_> i have read that one, but I forgot about cryptnet
18:54:46 <Velociraptors> shapr: No idea - only here 'cos Axman6 evangelises haskell daily. He'd know.
18:54:53 <shapr> Velociraptors: Have you tried Haskell?
18:54:56 <shapr> it's FUN!
18:55:07 <pumpkin> it's awesome!
18:55:08 <shapr> It's not as much fun as velociraptors on hoverboards, but it is really fun.
18:55:10 * Velociraptors haven't - but curiosity's there now :)
18:55:23 <Axman6> shapr: it works pretty well on OS X, though i do hate not having 64-bit support
18:55:26 <blackh> it's pleasant
18:55:44 <shapr> Axman6: Oh, why no 64-bit on os x?
18:55:45 * Axman6 demonstrates the power
18:55:54 <shapr> blackh: How long have you been using Haskell?
18:56:13 <Axman6> shapr: no idea, it just doesn;t compile 64 bit, and i have no idea how to go about making it do so :\
18:56:16 <blackh> shapr: About 4 months, but that's every day for several hours.
18:56:29 <shapr> blackh: Wow! Do you have a job writing Haskell?
18:56:43 <shapr> Axman6: Checked the ghc trac or asked on #ghc?
18:56:59 <shapr> Axman6: It's not too hard to hack on GHC, you could fix it :-)
18:57:01 <Axman6> shapr: not as yet, but i shall do so
18:57:04 <shapr> yay!
18:57:12 <Axman6> heh, maybe i could
18:57:16 <blackh> shapr: I am wanting to start a business, and so I decided to review all my options, including programming languages.  First I tried Python, then I discovered Haskell and I haven't looked back.  I am working at night because this project has no funding.
18:57:28 <inforichland> velociraptors: anything we can do to convince you to come to the dark side?
18:57:30 <inforichland> ;)
18:57:31 <cads_> shapr, I think an admirable goal would be to create a fabric where there's enough spare compute power that interesting computations get done all the time
18:57:36 <shapr> Since I have a C# job these days, I'm interested in sof's hs-dotnet code released today.
18:57:39 <cads_> which is really vague, actually...
18:58:01 <Axman6> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
18:58:03 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
18:58:05 <shapr> cads_: Yup, pretty vague. People might use your hardware to brute force your encryption key.
18:58:08 * Velociraptors are here now! Going to lurk some, watch, and see if the coding bug kicks in again. 
18:58:11 <shapr> blackh: Wow, cool!
18:58:16 <lispy> > fix $ \fibs
18:58:17 <lambdabot>   <no location info>: parse error on input `;'
18:58:17 <lambdabot> lispy: You have 1 new message. '/msg lambdabot @messages' to read it.
18:58:18 <lispy> oops
18:58:26 <pumpkin> -8˚ F outside :/
18:58:33 <shapr> pumpkin: Where are you?
18:58:34 <lispy> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs) -- look no let!
18:58:35 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
18:58:39 <inforichland> pumpkin: go midwest!
18:58:42 <pumpkin> shapr: NH :)
18:58:42 <cads_> sharp, I guess that brings us back to some social metric of what an interesting program is
18:58:46 <pumpkin> inforichland: not quite :P
18:58:48 <sjanssen> cads_: also, wouldn't it make more sense to power down the machines that have spare compute power?
18:58:53 <Axman6> pumpkin: 26.1 here
18:58:55 <shapr> pumpkin: Oh right, you're north of me.
18:58:55 <Axman6> ... C :)
18:58:57 <inforichland> pumpkin: oh, my thermometer says -8 too
18:59:03 <pumpkin> shapr: yeah :)
18:59:06 <pumpkin> Axman6: lucky :)
18:59:09 <shapr> pumpkin: But you'll show up when I organize a Haskell group in Boston, right?
18:59:18 <pumpkin> shapr: of course!
18:59:19 <Axman6> it was almost 40 yesterday here, that sucked
18:59:19 <ddarius> > fix((1:).(1:).ap(zipWith(+))tail) -- loop no points
18:59:20 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
18:59:21 <shapr> yay!
18:59:25 <cads_> sjanssen, not if it allowed computation that would be more interesting than otherwise possible
18:59:29 <shapr> Axman6: I'll trade you...
18:59:42 <inforichland> axman6: the low tonight here is *negative* 40
18:59:48 <Axman6> ha
18:59:48 <shapr> Axman6: What's the MIME type for BTUs? You'll send me some of yours, yeah?
19:00:06 <blackh> Axman6: Even New Zealand is hot today. Unprecedented!
19:00:11 <shapr> inforichland: Wow, sounds like the arctic circle.
19:00:22 <inforichland> well, low of -20, windchill of -40
19:00:23 <pumpkin> inforichland: the nice thing about that temperature is that you don't really need to specify F or C :)
19:00:24 <shapr> I'm in bed hiding under the covers :-)
19:00:28 <Axman6> shapr: depending on your OS, it's temp/celcius, temp/kelvin or temp/farenheight (SP?)
19:00:29 <inforichland> pumpkin: :D
19:00:44 <inforichland> shapr: nope, just WI
19:00:45 <shapr> celsius and fahrenheit
19:00:47 <dibblego> fahrenheit
19:00:56 * cads_ wonders if the novelty of a program or its output can be ascertained from a information theory standpoint
19:00:59 <Axman6> blackh: not really, it's about the same distance north as i am, so makes sense
19:01:00 <centrinia> @let fToC f = (f-32)*5/9
19:01:00 * ddarius thinks he's found a foul solution.
19:01:02 <lambdabot>  Defined.
19:01:09 <centrinia> fToC 6
19:01:12 <centrinia> > fToC 6
19:01:13 <lambdabot>   -14.444444444444445
19:01:25 <inforichland> > fToC (-8)
19:01:27 <centrinia> > fToC (-40)
19:01:27 <lambdabot>   -22.22222222222222
19:01:28 <lambdabot>   -40.0
19:01:38 <pumpkin> make it rational!
19:01:44 <centrinia> > fToC (-40) :: Rational
19:01:46 <lambdabot>   (-40)%1
19:01:48 <Jedi_Stannis> hi, how do I import Data.List.Utils?
19:01:55 <centrinia> > fToC (-8) :: Rational
19:01:56 <lambdabot>   (-200)%9
19:01:57 <_40oxo_> if I have a tuple of an arbitrary size, is there one function i can use to get the first element?
19:01:59 <cads_> sjanssen: powering down the computers rather than bringing on the singularity might very well make more sense :D
19:02:07 <_40oxo_> i tried to write one but it wouldn't typecheck :P
19:02:14 <Axman6> _40oxo_: not really
19:02:43 <centrinia> _40oxo_: You can use Template Haskell.
19:02:44 <Axman6> it's possible, but would take far more code than just using a lambda when you need to do such a thing
19:03:09 <_40oxo_> alright, that's what i figured
19:03:39 <Axman6> > [1..] -- Velociraptors infinite lists :o
19:03:40 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:03:50 <Axman6> produced in constant space!
19:03:51 <_40oxo_> centrinia: i've always wanted to learn to use that. i think now's not the time though
19:04:07 <saml> > [1.]
19:04:08 <lambdabot>   <no location info>: parse error on input `]'
19:04:25 <shapr> @seen samc
19:04:25 <lambdabot> I haven't seen samc.
19:04:29 <shapr> ah well
19:04:29 <saml> > [1..0]
19:04:31 <lambdabot>   []
19:04:36 <Axman6> > [1..] !! maxBound
19:04:43 <shapr> blackh: So, can you give a vague description of what you're doing with Haskell?
19:04:49 <lambdabot>   mueval: Prelude.read: no parse
19:06:02 <pumpkin> , (toU [1..]) `indexU` maxBound
19:06:07 <lunabot>  luna: out of memory (requested 1048576 bytes)
19:06:15 <Axman6> Velociraptors: if you're interested in learning haskell, check out http://book.realworldhaskell.org/read/ it's an O'Reilly that was released recently, that's freely available on the net as well as in print :)
19:06:16 <Jedi_Stannis> how do I access Data.List.Utils?
19:06:20 <blackh> shapr: It's a web application, 15,000 lines so far. Currently it's a commercial secret, but I will reveal all in a few months.
19:06:33 <centrinia> > map (: "uck") "bflms" -- Higher order functions :O
19:06:37 <lambdabot>   ["buck","fuck","luck","muck","suck"]
19:06:40 <roconnor> Velociraptors seems more like a "Learn You A Haskell" sort of nick.
19:06:48 <roconnor> For Great Good
19:06:58 <roconnor> @where LYAH
19:06:59 <lambdabot> www.learnyouahaskell.com
19:07:16 <pumpkin> centrinia: nice
19:07:31 <saml> > ([1 .. maxBound] :: [Int]) !! 9999999
19:07:33 <lambdabot>   10000000
19:07:36 <saml> > ([1 .. maxBound] :: [Int]) !! 999999999
19:07:51 <lambdabot>   thread killed
19:08:06 <Axman6> roconnor: well, they will need to be able to read it concurrently, can many Velociraptors read it at once at their own pace? :)
19:08:42 <saml> > let succ n = ([1 .. maxBound] :: [Int]) !! n in succ 41
19:08:44 <lambdabot>   42
19:09:16 <pumpkin> I would've thought the UArr version wouldn't take long
19:09:22 * Velociraptors are plural, hence innately parallel. That works well...
19:09:30 <centrinia> @djinn ((a -> Nil) -> Nil) -> a
19:09:30 <lambdabot> Error: Undefined type Nil
19:09:37 <centrinia> @djinn ((a -> Null) -> Null) -> a
19:09:37 <lambdabot> Error: Undefined type Null
19:10:00 <centrinia> Wait, what is the bottom type called?
19:10:45 <MyCatVerbs> centrinia: Either there isn't one, OR: any free type variable. Depending on how you feel about it.
19:10:46 <dolio> > 4 * fromIntegral (maxBound :: Int) / (1024^2)
19:10:48 <lambdabot>   3.5184372088832e13
19:11:08 <dolio> > 4 * fromIntegral (maxBound :: Int32) / (1024^2)
19:11:09 <lambdabot>   8191.999996185303
19:11:14 <pumpkin> oh yeah, lambdabot's on a 64-bit machine
19:11:14 <MyCatVerbs> centrinia: undefined has the type "forall a. a", which gets shortened to "a" when you ask about it (because the top-level forall is implicit).
19:11:26 <pumpkin> :t undefined
19:11:28 <lambdabot> forall a. a
19:12:21 <MyCatVerbs> centrinia: bottom doesn't have any single type, because you can have a bottom of any type.
19:12:21 <saml> > snd (undefined, 1)
19:12:22 <centrinia> @djinn Not (Not a) -> a
19:12:22 <lambdabot> -- f cannot be realized.
19:12:23 <lambdabot>   1
19:12:31 <centrinia> @djinn a -> Not (Not a)
19:12:31 <lambdabot> f a b = b a
19:12:32 <roconnor> > fix bitSize
19:12:34 <lambdabot>   64
19:12:37 <roconnor> , fix bitSize
19:12:40 <lunabot>  32
19:12:52 <centrinia> Oh, It is called Void.
19:12:56 <saml> @src undefined
19:12:57 <lambdabot> undefined =  error "Prelude.undefined"
19:12:59 <pumpkin> :t bitSize
19:13:00 <lambdabot> forall a. (Bits a) => a -> Int
19:13:10 <pumpkin> neat
19:13:24 <pumpkin> > bitSize (undefined :: Int)
19:13:26 <lambdabot>   64
19:13:45 <ddarius> Fuck yeah!
19:14:55 <chessguy> um...
19:31:53 <shapr> @y0w!
19:31:54 <lambdabot> Isn't this my STOP?!
19:32:02 <pumpkin> @y0w
19:32:03 <lambdabot> FOOLED you!  Absorb EGO SHATTERING impulse rays, polyester poltroon!!
19:32:07 <pumpkin> o.O
19:32:10 <inforichland> @wtf
19:32:10 <lambdabot> Maybe you meant: bf ft wn
19:32:15 <shapr> @wtf is wtf
19:32:15 <lambdabot> Maybe you meant: bf ft wn
19:32:20 <shapr> @ftw Haskell
19:32:21 <lambdabot>  fd:8: hClose: resource vanished (Broken pipe)
19:32:25 <shapr> hmm
19:32:30 <inforichland> :t ftw
19:32:32 <lambdabot> Not in scope: `ftw'
19:35:18 <Axman6> dons: you still around? i manages to convert my STArray version to STUArray, but it's segfaulting for n > 22 o.O
19:37:06 <int80_h> http://hpaste.org/13973
19:37:33 <int80_h> could someone take a peek? This is problem 12 chapter 3
19:37:54 <int80_h> of RWH
19:38:54 <Raynes> int80_h: I had so much hell with that one, that I deemed it too boring to do.
19:39:03 <chessguy> int80_h:  for one thing, you should probably return a [Direction], not a [Maybe Direction]
19:39:19 <int80_h> Raynes: I find the problem it builds up to to be pretty interesting
19:39:52 <chessguy> int80_h:  there is no such thing as "DNone"
19:40:17 <Axman6> ok, somehow my n-bodies program manages to pump massive ammounts of eergy into the system after 22 iterations, going from -0.169070559 [units] to 13944298812731717000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
19:40:27 <pumpkin> lol
19:40:28 <int80_h> chessguy: I wanted an alternative for no direction
19:40:42 <chessguy> int80_h:  what does "no direction" mean?
19:40:52 <int80_h> chessguy: should I just call "no direction" Nothing?
19:41:02 <Axman6> pumpkin: strange thing is, the first 21 iterations behave as expected o.O
19:41:08 <chessguy> int80_h:  what does "no direction" mean?
19:41:15 <Cale> Axman6: Maybe you should normalise the amount of energy in the system after each iteration or so
19:41:15 <Raynes> λ
19:41:16 <pumpkin> Axman6: :o
19:41:19 <AkhIL> greetings. Is there somebody involved in H3D project?
19:41:25 <int80_h> chessguy: no direction happens when you get a set of three points all the same
19:41:35 <chessguy> all the same?
19:41:38 <Cale> Axman6: hmmm
19:41:43 <int80_h> chessguy: it was my attempt at handlingan edge case
19:41:45 <Axman6> Cale: well the thing is, when using STArrays, it works fine, but STUArrays make it go crazy
19:41:58 <chessguy> you mean they're the same point?
19:42:03 <int80_h> when point x = point y = point z
19:42:11 <Cale> Axman6: Well, that is *very* strange
19:42:13 <chessguy> oh, i'd call that DStraight
19:42:20 <int80_h> chessguy: yeah, should I just get rid of it?
19:42:27 <Axman6> Cale: i know :) want to see the code perhaps?
19:42:27 <chessguy> i would, personally
19:42:29 <pumpkin> Axman6: if it makes you feel any better, I got "buffer overrun"-like behavior from a UArr the other day
19:42:32 <pumpkin> in pure code
19:42:34 <int80_h> chessguy: okay
19:42:36 <Cale> Axman6: wait, how is that number obtained? What type of elements are in the array?
19:42:51 <Axman6> i'll paste the code, should make things a little clearer
19:43:19 <int80_h> chessguy: what about the event of an empty list? That's where my code uses it
19:44:10 <chessguy> int80_h:  i would then pattern match against [], [x], [x,y], [x,y,z] and [x,y,z:zs] (those cases may collapse)
19:44:12 <Axman6> Cale: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=767#a768 probably worth checking the MArray instance down the bottom, which i took from dons' attempt
19:44:54 <Axman6> basically i'm working with an array of 7 double datatypes
19:46:34 * Axman6 might move to not using how Vec3 types to see if that helps
19:46:38 <Cale> Why the need for that instance?
19:46:56 <Cale> Can't you just store 7 (ST)UArrays?
19:47:14 <int80_h> chessguy: what do you mean by collapse
19:47:35 <Axman6> Cale: seems rather innefficient :\
19:47:42 <chessguy> int80_h: e.g., the first 3 can probably be handled by a _
19:47:47 <Cale> Doesn't it seem exactly as efficient?
19:48:14 <Axman6> maybe, i'm not sure, but i'd rather not be messing with 7 different arrays
19:48:22 <int80_h> chessguy: thanks :)
19:51:36 <dolio> Axman6: Why aren't you UNPACKing the Doubles in Vec3 and Body?
19:51:51 <pumpkin> he has flags that do that I think
19:51:54 <dolio> I guess it doesn't actually matter due to the -funbox-strict-fields.
19:52:12 <Axman6> pos ::  {-# UNPACK #-} !Vec3 doesn't unpack them? the Core seems to show it does
19:52:37 <dolio> I mean the Doubles in Vec3 don't have {-# UNPACK #-} on them.
19:52:46 <Axman6> would that help?
19:52:49 <dolio> -funbox-strict-fields does the same thing.
19:52:54 <Axman6> ah i see
19:52:55 <dolio> But then you don't need them on the Vec3.
19:53:06 <bigorilla> @src dropWhile
19:53:06 <lambdabot> Source not found. It can only be attributed to human error.
19:53:10 <dolio> Not that it hurts.
19:53:48 <chessguy> int80_h: does that help?
19:54:01 <Axman6> anyway, my problem is very strange. going from getting -0.169070559 energy to 1394429881273171700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.000000000 energy in a single iteration
19:54:11 <pumpkin> Axman6: maybe it's related to my issue :)
19:54:19 <dolio> And not the first iteration?
19:54:29 <MyCatVerbs> Axman6: holy thermodynamics, Batman!
19:54:38 <Axman6> nope, the 22 iteration
19:54:41 <pumpkin> Axman6: does it jump to that same value each time?
19:54:41 <Axman6> 22nd*
19:54:44 <dolio> That's pretty weird.
19:54:58 <Axman6> pumpkin: yep
19:55:05 <pumpkin> that's better than mine I guess
19:55:16 <pumpkin> but it's still possible it's a real bug :P
19:55:16 <Axman6> heh
19:55:28 <Axman6> yeah, i'll ask in #ghc i guess
19:56:08 <pumpkin> with mine I was calculating a sliding mean over a UArr of relatively small, non-NaN values
19:56:22 <pumpkin> and getting NaNs, e308s and different outputs every time I run it :P
19:56:36 <pumpkin> in pure code :)
19:57:31 <dublpaws> bugs to random number generator eureka .. profit!!!
19:58:53 <Axman6> pumpkin: yeah i was getting NaNs too
19:59:09 <pumpkin> maybe it's a bigger issue than just UArrs
19:59:15 <pumpkin> I submitted my bug to dons for UArrs
19:59:29 <pumpkin> but we're both on Mac OS? maybe it's a bug specific to that? who knows :)
20:00:02 <pumpkin> I also got a segfault in similar code a few days ago
20:04:38 <Axman6> pumpkin: ah good idea, maybe we could get someone else to try it...
20:05:01 * Axman6 fires up VMWare fusion...
20:05:22 <pumpkin> I was able to reproduce my segfault on an ubuntu 64 machine
20:05:58 <cads_> Do you guys know if there's any way to get free access to the ACM? I think students at certain universities might? Surely a friend might hook you up, but then again I don't know how strict they are about that. I don't know about you guys, but I'm always, _always_ finding extremely interesting sounding papers on the acm.
20:06:24 <cads_> and I'm always to broke to pay for a membership
20:07:32 <roconnor> cads_: what I do is use Tor and restrict my exit nodes to .edu domains
20:07:57 <roconnor> cads_: that maybe needlessly complex for your needs
20:08:00 <cads_> wait
20:08:09 <Nafai> cads_: What roconnor said, because I believe we had free access to the ACM from our university, at least our university library
20:08:10 <cads_> that gets you access?
20:08:20 <roconnor> cads_: 80% of the time
20:08:31 <pumpkin> yeah, my college has access just based on the ip range
20:08:37 <cads_> good lord
20:08:51 <Elly> we do too
20:09:10 <cads_> roconnor, how do you figure that would be too complex? it's friggen free acm! :D
20:09:12 <Elly> if you want any particular paper I can grab it for you :)
20:09:27 <BMeph> roconnor: So, 80% of the time, it works every time/ ;p
20:09:43 <roconnor> cads_: well, you need to install tor, know how to configure exit nodes, and grab a list of exit nodes and filter by domain name
20:10:13 <roconnor> BMeph: not every .edu computer has free access to the ACM library
20:10:42 <Adamant> just colleges with a site license
20:10:44 <cads_> Elly, I've been looking longingly at this paper for a while: http://portal.acm.org/citation.cfm?id=1066650.1066656&coll=GUIDE&dl=GUIDE&CFID=18485558&CFTOKEN=77973890
20:11:20 <cads_> and that one about the mceliece crypto system that I can find only on the ACM (that should be a crime)
20:11:26 <pumpkin> cads_: they found the answer to be 42
20:12:03 <cads_> and man there are a lot of papers on raytracers that I've had to give up... roconnor, if that works I'm gonna kiss ya
20:12:11 <RPS> I ran up on a web page about writing an IRC Bot in Haskell and I'll quickly point out that I have never attempted to make a bot ...While I may have been around computers since the mid 80's I have No knowledge of programming and I may be thinking about something that is WAY over my head. The way I see it though is if I don't some questions I'm not going to know what is possible.
20:12:14 <cads_> also, it sounds pretty simple to do
20:12:15 <pumpkin> cads_: that's available for free...
20:12:18 <roconnor> cads_: no tongue
20:12:24 <pumpkin> cads_: http://www.cs.northwestern.edu/~pdinda/Papers/lcr04-enccomp.pdf
20:12:49 <RPS> if I don;t ask some questions ...pardon the typo
20:12:54 <Axman6> RPS: ask away :)
20:13:04 <RPS> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
20:13:07 <Axman6> RPS: also, http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
20:13:12 <pumpkin> lol
20:13:18 <Axman6> surprisingly easy thing to do
20:13:22 <Axman6> bah
20:13:27 <cads_> pumpkin: d'oh! thanks :D
20:13:28 <RPS> well more than any question ... LOL
20:13:35 <RPS> Ok that's funny right there
20:13:47 <pumpkin> cads_: in many cases, you'll find a free PDF on one of the authors' sites
20:14:01 <pumpkin> that's what I usually look for if I try to send someone a URL to a paper :)
20:14:44 <RPS> I'm not trying to be insensitive, but is Haskell the right route for my first irc bot or would I better trying something else ...something easier.
20:15:03 <Axman6> haskell is a great first language
20:15:32 <Taejo> Haskell is better as a first language than as a second language (though I quite enjoyed it as my sixth)
20:15:43 <cads_> pumpkin: in this case the pdf is actually available from the site I posted, which takes the cake.. i hadn't even tried when i saw that it was on the acm
20:15:45 <Axman6> heh
20:15:51 <Axman6> it's my first real language i guess
20:15:57 <roconnor> if you want an IRC bot that works correctly, stick with haskell
20:16:19 <roconnor> if you want an IRC bot that you can write quickly but doesn't work, you could try a different language
20:16:24 <SubStack> haskell as a first language? D:
20:16:25 <roconnor> :P
20:16:33 <SubStack> maybe only if you have a phd in mathematics
20:16:37 <Axman6> i've dabbled in things like ruby, python, C, C++, Objective-C
20:16:52 <Axman6> SubStack: bah, it's such an easy language to learn, especially if you don't know any other languages
20:16:54 <RPS> this sounds crazy to me ...but what does the tutorial wind up creating? I want a bot that will allow someone to enter a trigger and something pops up ...I figure I'll keep it real simple the first time out
20:17:36 <Axman6> RPS: well, that tutbot tutorial you end up with something that'll tell you its updime, and echo input, but it's easy to extend it
20:17:41 <SubStack> the things most beginner programmers want to do are all side-effecty
20:17:48 <SubStack> graphics and what-not
20:18:08 <Axman6> the things most programmers do are side effecty, because that's how all other languages are taught
20:18:23 <Saizan> that bot is all side-effecty, but it's extremely simple :)
20:18:31 <Axman6> yeah :)
20:19:04 <RPS> well we have a silly bot on another network  that is a !Shortbus ...you type the trigger and it toots the horn and tells how many people are on the shortbus ...it's just a funny thing
20:19:05 <gwern> hm, my wiki is going well; the neat thing is I managed to invert gitit's directory structure so the whole thing is a darcs repo
20:19:24 <Axman6> RPS: if i were you, i'd try a few haskell tutorials first, just to get used to the language. when the tutorial starts to get up to the Reader monad stuff, it will get a little confusing
20:19:28 <Raynes> NetSplit !_!
20:19:28 <gwern> I could, in theory, push it to c.h.o and let anyone have a copy of my personal wiki
20:19:28 <gwern> complete with history and everything
20:19:45 <cads_> Raynes: ahh, the old days
20:20:11 --- mode: irc.freenode.net set +o ChanServ
20:20:17 <RPS> Axman6, where can I find those tutorials?
20:20:23 <roconnor> gwern: that sounds cool
20:20:24 <Axman6> that was a pretty big netsplit too :|
20:20:24 <RPS> and is there a simple order to follow with them?
20:20:24 <RPS> Netsplit stink
20:20:34 <Saizan> ?where LYAH
20:20:34 <lambdabot> www.learnyouahaskell.com
20:21:09 <gwern> roconnor: yeah. I'm just wondering whether I want to do so - some of my writings could be embarassing - and I'm wondering whether anyone but me and john have the necessary filestore/gitit binaries
20:21:18 <RPS> lambdabot, from the pictures it looks about at my level. ;)
20:21:28 <roconnor> gwern: I mean it is cool that it is possible
20:21:32 <gwern> and I'm especially wondering about the wisdom of including the /etc/passwd if you will in the repo
20:21:33 <roconnor> not that you should do it
20:21:41 <gwern> it *is* salted and hashed, but still
20:22:10 <gwern> on the other hand, it's so cool that wikis are now as forkable and mirrorable as software repos
20:23:10 <RPS> another question guys ...should I work on this project on a Windows PC or Ubuntu? I'm a new guy to ubuntu, but I'm learning. I have my choice of two pc's to work off of (both at the same time even.)
20:23:53 <Taejo> RPS: I'd definitely go for Ubuntu
20:24:02 <gwern> RPS: down windows lies many horrors
20:24:07 <Axman6> zomg, wtf freenode :o
20:24:10 <roconnor> /me thinks that everyone should have a minor in math to be a programmer
20:24:12 <gwern> you face a maze of twisty errors, each alike
20:24:44 <Taejo> roconnor: I disagree. You should have a minor in math to be a professional programmer
20:24:47 <Saizan> for an ircbot you shouldn't need any fancy libraries, though
20:24:56 <Axman6> roconnor: sounds reasonable to me
20:24:59 <RPS> well you guys are scaring the bejesus out of me if that was the goal. LOL
20:25:01 <roconnor> Taejo: I suppose that is what I mean by programmer in this context
20:25:01 <Saizan> you should have a minor in math.
20:25:32 <roconnor> oh noes ChanServ
20:25:59 <Taejo> I programmed as a hobby long before I became a math minor (I become a math major a little later)
20:26:10 <roconnor> that's fair
20:26:27 --- mode: irc.freenode.net set +o ChanServ
20:26:30 <Spark> few people do maths as a hobby
20:26:46 <Taejo> in fact, I think programming is a great way to learn math
20:26:48 * Taejo puts up my hand
20:27:00 <Gracenotes> speaking of which, I should write something that does symbolic differentiation
20:27:02 <Taejo> but only when I'm on a break from learning to do it professionally :)
20:27:10 <Gracenotes> sometime soon
20:27:16 <roconnor> programming is (constructive) math  (according to Curry and Howard)
20:27:24 <Taejo> Gracenotes: do you know about automatic differentiation?
20:27:25 <BMeph> cads_: Which paper was that crypto one? :)
20:27:31 <Taejo> roconnor: not GWBASIC :)
20:27:38 <roconnor> :)
20:27:43 <Gracenotes> Taejo: the term is not familiar to me
20:27:46 <Saizan> Gracenotes: there's a nice -cafe post on that by oleg
20:27:59 <Spark> who do you think understands programming better?  Curry or Torvalds?
20:28:11 <roconnor> Curry
20:28:21 <Gracenotes> Saizan: ah... where? :)
20:28:28 <Axman6> Gracenotes: yeah that'd be nice. i reckon a good starting point would be the symbolic math stuff from RWH would be a great starting point
20:28:32 <roconnor> I mean Oleg
20:28:43 <BMeph> Gracenotes: Check out http://users.info.unicaen.fr/~karczma/arpap/diffalg.pdf
20:28:51 <Taejo> Gracenotes: http://sigfpe.blogspot.com/2005/07/automatic-differentiation.html
20:28:56 <RPS> I assume the Kermit the Frog pictures scattered around the tutorial is supposed to keep me from hyperventilating? LOL
20:29:06 <roconnor> RPS: :D
20:29:34 <RPS> well I've scrolled through a few pages and it looks like Latin to me
20:29:49 <Gracenotes> Taejo: I shall read
20:30:03 <Gracenotes> and which symbolic math from RWH?
20:30:19 <Gracenotes> RPN?
20:30:39 <bombshelter13> Is it unusual that I can print out the entirety of a list of 88200 doubles, but can't get the list's length with 'length' without getting 'ERROR - Garbage collection fails to reclaim sufficient space'?
20:30:44 <Axman6> yeah, that chapter
20:30:58 <chessguy> int80_h:  how you making out?
20:31:15 <sjanssen> bombshelter13: probably not
20:31:28 <sjanssen> bombshelter13: we'd need to see the code to be sure
20:31:37 <Taejo> bombshelter13: well the difference is probably in the context
20:31:46 <RPS> I'll hope its a VERY well explained tutorial that will not have me scratching my head and buggin you guys with inane questions. Somebody tell me it's simple to follow and to just trust myself. please ;)
20:32:04 <roconnor> bombshelter13: that is very common
20:32:16 <Taejo> we're very open to questions, whether inane, insane or deeply probing
20:32:27 <bombshelter13> roconnor: what typically causes it?
20:32:51 <roconnor> bombshelter13: you are holding a reference to the list after asking for the length
20:33:02 <roconnor> bombshelter13: so the system tries to put the whole thing in memory
20:33:10 <cads_> BMeph: I don't remember now what it was, but it had to do with encrypted computing
20:33:38 <cads_> I think it was  Addressing The Trust Asymmetry Problem
20:33:38 <cads_> In Grid Computing With Encrypted Computation
20:34:19 <RPS> I think you tell I'm not an idiot, but when you are looking at something soooo foreign it can make you feel like an idiot, but I enjoy learning new things ...I just hope its not too big of a bite I'm trying to take.
20:34:22 <bombshelter13> roconnor: how can I avoid this problem...?
20:34:53 <roconnor> bombshelter13: there are a couple of different solutions depending on exactly what you are trying to do.
20:35:01 <Taejo> RPS: it is a huge bite... but it's fun (hopefully)
20:35:11 <bombshelter13> roconnor: at this point just find out how long the length is, nothing super elaborate
20:35:34 <roconnor> bombshelter13: that will work if you drop all other uses of the list so that it can be GCd
20:35:51 <roconnor> main = print (length bigAssList)
20:35:57 <cads_> BMeph: the idea is you have a high stakes application that needs to execute on a completely untrusted platform
20:36:15 * roconnor notes that is a big ass-list
20:37:03 <bombshelter13> heh... well I'd hope 88200 isn't that big in the context of what the language can handle well :/
20:37:18 <roconnor> > length [1..88200]
20:37:20 <lambdabot>   88200
20:37:25 <roconnor> ta da
20:37:31 <Taejo> > length [1..88200.0]
20:37:32 <lambdabot>   88200
20:37:39 <dolio> Are you using Hugs?
20:37:47 <Gracenotes> it seems length [1..n] is optimized
20:37:49 <ddarius> length [] = 0; length (xs ++ ys) = length xs + length ys
20:37:54 <bombshelter13> ooh, miscalc by a factor of half on my math, it's actually about twice as long as I thought.
20:37:57 <ddarius> length is a monoid homomorphism
20:37:57 <bombshelter13> dolio: yes
20:38:03 <roconnor> > length [1..88200*2]
20:38:05 <lambdabot>   176400
20:38:40 <bombshelter13> strange that it doesn't like my list of doubles, at least in hugs
20:38:42 <Gracenotes> actually, hm, length is not necessarily optimized
20:38:53 <bombshelter13> if i put in the main you mentioned, and compile it, it does print the length
20:38:57 <roconnor> > length (map (fix id) [1..88200*2])
20:38:59 <lambdabot>   176400
20:39:07 <Gracenotes> length [1..10^8] took 3 seconds
20:39:08 <roconnor> Gracenotes: I don't think it is optimised
20:39:19 <roconnor> bombshelter13: good :)
20:39:24 <gwern> sweet, it works. I can push to a remote repo, darcs get it, and then run gitit in the new one and log in and everything
20:39:46 <gwern> I was afraid that gitit would see the skeleton static/ directory (containig just two controlled files) and go nuts
20:39:53 <roconnor> bombshelter13: this works because the list is garbage collected as the length is computed
20:40:09 <gwern> but it seems gitit did the right thing and merely replaced the missing files
20:40:17 <bombshelter13> roconnor: but that's a big enough length to have proplems being length-checked during runtime?
20:40:45 <roconnor> bombshelter13: yes, it is a linked list
20:41:02 <roconnor> bombshelter13: so that is a least two pointers per node
20:41:22 <roconnor> bombshelter13: when the list is unfurled.
20:41:50 <bombshelter13> hmm, it still seems like that should be well within the memory limits of this system...
20:42:10 <roconnor> > 2*4*176400
20:42:12 <lambdabot>   1411200
20:42:30 <roconnor> hmm
20:42:52 <Taejo> LYAH says: "When a function doesn't take any parameters, we usually say it's a definition (or a name)." Does anybody use these terms? What about "constant"?
20:43:22 <bombshelter13> perhaps i should be looking into some sort of vector or linear array regardless, for other reasons like speed... but it still seems like it should be computable :/
20:43:48 <ddarius> Taejo: Occasionally, but not with those meanings.
20:44:15 <bombshelter13> http://hpaste.org/13974 <-- if it gives any clues, there's the code...
20:44:35 <Taejo> ddarius: I meant with those meanings. I use "definition", but both constants and functions have definitions (and names, for that matter)
20:44:48 <ddarius> Yeah, that's how most people use it.
20:44:54 <gwern> Taejo: so, would 'add = (+)', which has no parameters, be a constant or a definition?
20:45:06 <roconnor> bombshelter13: ya, it seems like it ought to fit
20:45:13 <Taejo> gwern: that's a definition of a constant
20:45:26 <Taejo> they're two different kinds of things
20:45:41 <Taejo> a definition is a statement, a constant is a value
20:45:45 <ddarius> Taejo: Is that a function or a constant?
20:45:56 <roconnor> bombshelter13: are you sure the list is as short as you claim?
20:46:17 <Taejo> ddarius: it's both :)
20:46:37 <ddarius> Taejo: Indeed.  The term "constant" has little meaning in Haskell (because -everything- is constant)
20:47:14 <gwern> oh the irony - 'utf8-light' depends on base, bytestring, and ghc-prim; utf8-string depends on base, and bytestring
20:47:20 <Taejo> yeah, I know... but my algebra lecturer drummed into me "noollary function is isomorphic to constant"
20:47:31 <mmorrow>  , arityT [$tyQ|(+)|]
20:47:33 <ddarius> Taejo: isomorphic /= equal
20:47:35 <mmorrow> , arityT [$tyQ|(+)|]
20:47:40 <lunabot>  2
20:47:46 <ddarius> Not everything is a function.
20:47:53 <mmorrow> , arityT [$tyQ|(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)|]
20:47:58 <lunabot>  36
20:48:10 <Taejo> ddarius: in Haskell, all functions are unary
20:48:12 <mmorrow> , arityT [$tyQ|4|]
20:48:13 <bombshelter13> roconnor: Well, with 'main = print (length samples)' I get 154352, which does sound about right when i start adding up the components...
20:48:16 <ddarius> Taejo: Indeed.
20:48:18 <lunabot>  0
20:48:43 <Taejo> so is there a name for a thing-that-isn't-a-function?
20:48:45 <ddarius> Taejo: Why are you reading through LYAH by the way?
20:49:06 <Taejo> I wasn't sure if it was suitable for RPS
20:49:09 <ddarius> Taejo: Value (or constant though value is more common) is a term that contains both and is usually adequate.
20:49:40 <ddarius> Taejo: Cool.  Someone is reading what is going into beginners' heads.
20:49:45 <roconnor> bombshelter13: length cannot be (direclty) causing your problem with a list that short
20:49:54 <ddarius> I used to, but I've stopped keeping up.
20:50:46 <Taejo> it turns out it sometimes addresses imperative programmers, but it mostly seems to start at a pretty basic level
20:51:13 <Gracenotes> what's that embedded language lunabot speaks?
20:51:21 <ddarius> Gracenotes: Haskell.
20:51:43 <Gracenotes> yes, it seems to be delineating the internal structure of Haskell code
20:51:48 <pumpkin> TH
20:51:49 <BMeph> It's funny - I read that "random-thoughts-on-haskell" blog, and I'm starting to think that part of Haskell's "problem" is that there are too many places where Haskell looks like other languages, but it isn't.
20:52:01 <Gracenotes> but where can I find information on the system itself?
20:52:04 <Taejo> BMeph: for example?
20:52:10 <BMeph> Taejo: return
20:52:13 <ddarius> BMeph: In at least superficial ways that is a problem.
20:52:15 <ddarius> BMeph: class
20:52:16 <Gracenotes> the one with terms like LamE and arityT and App?
20:52:18 <Axman6> @where TH
20:52:18 <lambdabot> http://www.haskell.org/th
20:52:18 <Taejo> oh yeah, return is horrible
20:52:22 <Axman6> Gracenotes: ^^
20:52:26 <bombshelter13> roconnor: hm, curious. :/ I can seem to perform most other operations on the entirety of it so I'm having trouble imagining what it could be ;/
20:52:28 <Gracenotes> ah, thanks
20:52:42 <roconnor> bombshelter13: I'm not sure I can help without a paste
20:52:50 <vegai> return makes it a bit easier for newcomers to get a primitive understanding of IO monad
20:52:54 <Taejo> and return isn't even from mathematics (I believe it's usually called eta in category theory)
20:53:07 <bombshelter13> roconnor: http://hpaste.org/13974
20:53:11 <Taejo> vegai: I find the opposite -- since return is not a control-flow statement
20:53:22 <erikc> vegai: i dont think its an understanding tho
20:53:49 <cads_> BMeph: the paper is http://portal.acm.org/citation.cfm?id=1066650.1066656&coll=GUIDE&dl=GUIDE&CFID=18485558&CFTOKEN=77973890
20:53:54 <roconnor> bombshelter13: that looks pretty nice
20:54:01 <cads_> it mentions some profoundly interesting ideas
20:54:12 <bombshelter13> roconnor: thanks! :) I appreciate it considering I'm just starting out :)
20:54:12 <vegai> ok, not understanding, but at least an ability to use it
20:54:18 <ddarius> Taejo: return was intentionally chosen to look like typical imperative code
20:54:27 <roconnor> I don't know why people use printf, but whatever :P
20:54:30 <pumpkin> cads_: the public link is probably better :P
20:54:40 <Taejo> ddarius: but it only works that way in tail position
20:54:53 <bombshelter13> roconnor: I can appear to print samples just fine, or average it with itself (using my innapropriately named 'lsum') on it.
20:54:55 <chessguy> return is a terrible name
20:55:09 <saml> :t return
20:55:10 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
20:55:15 <bombshelter13> roconnor: Because I haven't got the portaudio bindings operational yet, and I have a language neutral utility that writes wavs from lists of flaots on stdout ;)
20:55:24 * Axman6 things wrap is a better name for return
20:55:27 <Axman6> thinks*
20:55:29 <ddarius> Taejo: Which is where return occurs almost always.
20:55:45 <BMeph> cads_: I meant the other one you mentioned - something about "that one about the mceliece crypto system"
20:56:02 <BMeph> ?
20:56:02 <ddarius> I think it was a good choice despite the confusion occasionally caused.
20:56:16 <roconnor> bombshelter13: why not simply "print float" ?
20:56:23 <ddarius> I don't remember ever having any trouble with it myself.
20:56:42 <BMeph> ddarius: Why not eta? Or eater, as the British pronounciation sounds to American ears... ;)
20:56:56 <ddarius> BMeph: Because that reads like crap.
20:56:57 <bombshelter13> roconnor: unsure what usage you're suggesting?
20:56:59 <cads_> BMeph: I was looking for an implementation of the mceliece cryptosystem and from what I had read in the abstract, that paper had low level pseudocode
20:57:01 <roconnor> bombshelter13: anyhow, what is the lenght problem :)
20:57:08 <roconnor> @type print 0.5
20:57:09 <lambdabot> IO ()
20:57:28 <bombshelter13> roconnor: try loading that in hugs and doing 'length samples'... it doesn't go for some reason, and complains about garbage collection.
20:57:36 <pumpkin> ewww hugs
20:57:48 <bombshelter13> roconnor: but just doing 'samples' or 'lsum samples samples' work fine, and output the whole list.
20:58:00 <bombshelter13> pumpkin: well it might work in ghci too, haven't tried loading it there.
20:58:05 <BMeph> bombshelter13: "Friends Don't Let Friends Use Hugs." ;)
20:58:13 <chessguy> haha
20:58:16 * roconnor installs hugs
20:58:20 <bombshelter13> BMeph: heh... maybe I'll stop? I don't know better yet!
20:58:36 <chessguy> @remember BMeph "Friends Don't Let Friends Use Hugs."
20:58:37 <lambdabot> Done.
20:58:49 <chessguy> @quote hugs
20:58:49 <lambdabot> ozone says: shapr: hugs has been ported to an apple IIIc? ; shapr: MAIN :: IO (); MAIN = DO PUTSTRLN "GODDAMN CAPS"
20:58:57 <roconnor> bombshelter13: loading ....
20:58:58 <bombshelter13> huh. in fact, 'length samples' works in GHCI!
20:59:01 <bombshelter13> maybe I'll switch.
20:59:10 <Gracenotes> @quote hugs
20:59:10 <lambdabot> Igloo says:  Did hugs' ./configure always end with "config.status: executing ultra-evil commands"?
20:59:12 <pumpkin> there's no reason not to
20:59:23 <chessguy> @quote ghc
20:59:23 <lambdabot> ghc says: Cycle in type synonym declarations
20:59:35 <Gracenotes> @ghc
20:59:35 <lambdabot> ghc says: GHC stage restriction
20:59:49 <chessguy> @ghc likes to talk about itself
20:59:49 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
21:00:01 <chessguy> @bite me
21:00:01 <lambdabot> Maybe you meant: bid dice elite gsite time vote
21:00:28 <ddarius> @help gsite
21:00:28 <lambdabot> gsite <site> <expr>. Search <site> for <expr> using google
21:00:44 <chessguy> @gsite haskell.org monad
21:00:46 <lambdabot> http://www.haskell.org/all_about_monads/
21:00:46 <lambdabot> Title: All About Monads
21:00:49 <Axman6> @help bid
21:00:49 <lambdabot> bid symbols.  Sum up the bid and ask prices for symbols.
21:00:57 <BMeph> bombshelter13: 154352 ;)
21:00:59 <chessguy> \o/
21:01:08 <chessguy> @bid GHC
21:01:09 <lambdabot> Can't find 'GHC'
21:01:18 <bombshelter13> BMeph: :)
21:01:22 <Axman6> @bid BHP
21:01:22 <lambdabot> Can't find 'BHP'
21:01:27 <chessguy> @bid
21:01:27 <lambdabot> Invalid argument ''
21:01:35 <BMeph> @ghc bites
21:01:35 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
21:01:46 <Axman6> @ghc bytes
21:01:47 <lambdabot> No quotes match. My pet ferret can type better than you!
21:01:47 <roconnor> bombshelter13: on neat.  Hugs does give that error
21:02:03 <bombshelter13> roconnor: guess it's an implementation bug somewhere. :/
21:03:33 <roconnor> @go "ERROR - Garbage collection fails to reclaim sufficient space
21:03:37 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/errors/allErrors.html
21:03:37 <lambdabot> Title: Some common Hugs error messages
21:04:15 <Axman6> heh
21:04:19 <chessguy> @pl g k s d = m k (f d) >>= m s
21:04:19 <lambdabot> g = (. m) . flip . ((>>=) .) . (. f) . m
21:04:35 <roconnor> bombshelter13: ah, Hugs default heap size is 1000000 somethings
21:05:00 <bombshelter13> roconnor: guess that's not enough, heh...
21:05:09 <roconnor> seems kinda small
21:05:15 <roconnor> maybe
21:05:15 <bombshelter13> roconnor: seems like the overall impression here is to avoid hugs and go with ghci, though, regardless...
21:05:33 <roconnor> I can't advocate for hugs
21:05:42 <roconnor> I haven't used it since ghci
21:06:09 <roconnor> but at least hugs won't trash my system with it's default options. :D
21:06:49 <roconnor> bombshelter13: anyhow, FYI, I bet if you increase the heap in hugs with "hugs -h10000000 Foo.hs" it would work
21:08:05 <roconnor> heh
21:08:18 <roconnor> the man page claims the default heap size is 250K
21:08:22 <bombshelter13> roconnor: heh, handy to know.
21:08:24 <bombshelter13> roconnor: whoah
21:08:25 <roconnor> but I don't believe that
21:08:56 <roconnor> ya
21:09:01 <roconnor> the man page is full of lies
21:09:39 <bombshelter13> heh.
21:09:48 <bombshelter13> I need to get myself some good books on this language.
21:09:52 * roconnor uninstalls hugs
21:13:31 <roconnor> so is printf "%f\n" float the same as print float ?
21:13:55 <chessguy> @type Control.Monad.liftM2 ?f (Data.Map.lookup ?k1 ?s) (Data.Map.lookup ?k2 ?s)
21:13:56 <lambdabot> forall a2 r (m :: * -> *) k. (?f::a2 -> a2 -> r, ?k1::k, Monad m, ?k2::k, ?s::M.Map k a2, Ord k) => m r
21:14:28 <chessguy> @type Control.Monad.liftM2 ?f (Data.Map.lookup ?k1 ?s) (Data.Map.lookup ?k2 ?s) :: Maybe a
21:14:29 <lambdabot>     Could not deduce (?f::a2 -> a2 -> a21) from the context ()
21:14:29 <lambdabot>       arising from a use of implicit parameter `?f'
21:14:29 <lambdabot>                    at <interactive>:1:21-22
21:15:09 <Axman6> :t printf "%f\n" (10/11 :: Float)
21:15:11 <lambdabot> forall t. (PrintfType (Float -> t)) => t
21:15:13 <Cale> > printf "%f" pi :: String
21:15:15 <Axman6> bleh
21:15:15 <lambdabot>   "3.141592653589793"
21:15:22 <Cale> > show pi
21:15:24 <lambdabot>   "3.141592653589793"
21:15:27 <Axman6> > printf "%f\n" (10/11 :: Float)
21:15:28 <lambdabot>   Add a type signature
21:15:33 <Axman6> > printf "%f\n" (10/11 :: Float) :: String
21:15:35 <lambdabot>   "0.90909094\n"
21:15:58 <Axman6> > show (10/11 :: Float)
21:16:00 <lambdabot>   "0.90909094"
21:16:09 <Axman6> seems so roconnor
21:16:20 <roconnor> is printf type safe?
21:16:27 <Saizan> no
21:16:50 <roconnor> bombshelter13: don't use printf "%f\n" float  because it isn't typesafe
21:17:01 <roconnor> use "print float" instead
21:17:04 <Saizan> you get an exception if the format doesn't match the arguments
21:17:05 <roconnor> @type print
21:17:07 <lambdabot> forall a. (Show a) => a -> IO ()
21:17:11 <mmorrow> > printf "%s" 42 :: String
21:17:12 <lambdabot>   "* Exception: Printf.printf: bad argument
21:17:29 <roconnor> @src print
21:17:29 <lambdabot> print x = putStrLn (show x)
21:18:17 <chessguy> err...
21:18:27 <chessguy> \a b -> (a, b) === (,)
21:18:29 <chessguy> right?
21:18:43 <roconnor> @pl \a b -> (a, b)
21:18:44 <lambdabot> (,)
21:18:44 <pumpkin> could TH be used to generate a useful Show instance for functions?
21:18:57 <chessguy> oh, i didn't think @pl could handle tuples
21:19:09 <roconnor> > show (id :: () -> ())
21:19:11 <lambdabot>       Overlapping instances for Show (() -> ())
21:19:11 <lambdabot>        arising from a use of ...
21:19:21 * roconnor sighs
21:19:24 <ddarius> roconnor: It's type safe insofar as it won't cause segfaults.
21:19:41 <bombshelter13> roconnor: if I do it that way, I sometimes get numbers with scientific notation like -2.156528022823068e-9
21:19:43 <roconnor> ddarius: not safe enough for me :D
21:19:57 <pumpkin> bombshelter13: that happens when they get very small or big
21:20:19 <roconnor> > printf "%f\n" (-2.156528022823068e-9) :: String
21:20:21 <lambdabot>   "-0.000000002156528022823068\n"
21:20:25 <Axman6> ew
21:20:25 <ddarius> roconnor: It's impossible, in general, to make printf "type safe" in the stronger sense.
21:20:42 <bombshelter13> roconnor: Which are no good for my wav-writer, since it maches lines with m/^[-]{0,1}\d+[.]\d+$/
21:20:45 <ddarius> (or at best you move the "type unsafety" elsewhere)
21:20:55 <roconnor> ddarius: not without dependent types or oleg's non-string format deliminated continuations
21:21:04 <bombshelter13> roconnor: yes, it's perfectly suitable as a notation for numbers, but not as input for what this pipes to...
21:21:04 <Axman6> could it be possible if you used tuples?
21:21:10 <chessguy> @pl \(a,b) -> f a b
21:21:10 <lambdabot> uncurry f
21:21:12 <roconnor> @type ShowF
21:21:13 <lambdabot> Not in scope: data constructor `ShowF'
21:21:16 <roconnor> @type showF
21:21:18 <lambdabot> Not in scope: `showF'
21:21:41 <Axman6> something like printf "string %1 %2 test %3" (Flt,Dbl,Str)?
21:21:46 <Axman6> hmm, no that's yuck
21:21:49 <ddarius> roconnor: Using dependent types just moves the problem elsewhere.  Using non-string format either doesn't help or it is less powerful than printf.
21:22:08 <roconnor> > showFFloat (-2.156528022823068e-9)
21:22:10 <lambdabot>       Overlapping instances for Show (a -> String -> String)
21:22:10 <lambdabot>        arising f...
21:22:21 <ddarius> do s <- getLine; printf s pi
21:22:23 <pumpkin> Axman6: the issue is that the contents of the string isn't delat with by the compiler
21:22:27 <Axman6> :t showFFloat
21:22:28 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
21:22:34 <roconnor> > showFloat (-2.156528022823068e-9) ""
21:22:37 <lambdabot>   "-2.156528022823068e-9"
21:22:57 <roconnor> > showFFloat  4 (-2.156528022823068e-9) ""
21:22:58 <lambdabot>       No instance for (Num (Maybe Int))
21:22:58 <lambdabot>        arising from the literal `4' a...
21:23:07 <roconnor> > showFFloat  Nothing (-2.156528022823068e-9) ""
21:23:08 <Axman6> pumpkin: that's why i was using %1 etc
21:23:09 <lambdabot>   "-0.000000002156528022823068"
21:23:10 <bombshelter13> roconnor: and really the idea is to get rid of that hack and figure out how to operate the PortAudio bindings once I've read a couple more chapters in some tutorials that seem relevant.
21:23:18 <Axman6> but then it becomes tedious
21:23:33 <pumpkin> Axman6: it also doesn't have format specifiers and the other nice printf stuff :/
21:23:45 <Axman6> ah yes, good point
21:24:07 <roconnor> bombshelter13: I guess I'd be inclined to use putStrLn (Numeric.showFFloat Nothing float "")
21:24:31 <mmorrow> , $(printf "%d") ""
21:24:33 <roconnor> bombshelter13: but meh
21:24:36 <lunabot>  luna: No instance for (GHC.Real.Integral [GHC.Types.Char])
21:24:49 <bombshelter13> roconnor: I can take a look at that too, sure. :) just explaining why i didn't go with straight 'print float' :)
21:25:02 <roconnor> bombshelter13: yep, good reason
21:25:18 <roconnor> I would understand if you said the printf was better than what I wrote
21:26:07 <chessguy> @pl \f (a,b) (c,d) -> (f a c, f b d)
21:26:08 <lambdabot> (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (flip =<< (((.) . flip . (((.) . (,)) .)) .))
21:26:15 <chessguy> ah, much better
21:26:25 <roconnor> bombshelter13: #haskell lied to me.
21:26:32 <roconnor> lied like the hugs manual!
21:26:36 <bombshelter13> roconnor: oh?
21:27:10 <roconnor> [00:16] <Axman6> seems so roconnor
21:27:15 <roconnor> :D
21:27:23 <pumpkin> chessguy: it feels like there should be a nicer pl than that :P
21:27:47 <chessguy> @pl \f x y -> (f (fst x) (fst y), f (snd x) (snd y))
21:27:48 <lambdabot> ap (ap . (liftM2 (,) .) . flip flip fst . ((.) .) . (. fst)) (flip flip snd . ((.) .) . (. snd))
21:27:59 * Axman6 reminds people that his views and advice in no way reflect officially on the views of #haskell
21:28:00 <chessguy> pumpkin:  agreed
21:28:06 <pumpkin> chessguy: even nicer than that one :P
21:28:09 <mmorrow> > flip (showFFloat (Just 2)) [] . (/100) . fromIntegral . floor . (*100) $ pi
21:28:10 <pumpkin> hmm
21:28:11 <lambdabot>   "3.14"
21:28:54 <chessguy> @type uncurry
21:28:55 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
21:29:20 <bombshelter13> anyhow... ordered a copy of RWH for something to read... should probably be off to bed though. gotte be at work at 9 helping in a lab at school... hashed out the semester's schedule today but a copy hasn't been emailed to me yet so i have no idea what room to show up in, heh. :)
21:29:25 <chessguy> @type uncurry2
21:29:26 <roconnor> I guess putStr (Numeric.showFFloat Nothing float "\n") is faster :P
21:29:27 <lambdabot> Not in scope: `uncurry2'
21:29:32 <bombshelter13> thanks for all the help, everyone, roconnor.
21:29:36 <pumpkin> chessguy: dammit now I'm trying to think about it :P
21:29:46 <chessguy> @hoogle curry
21:29:46 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
21:29:46 <lambdabot> Data.Tuple curry :: ((a, b) -> c) -> a -> b -> c
21:29:46 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
21:29:58 <mmorrow> > let fmt n = flip (showFFloat (Just n)) [] . (/(10^n)) . fromIntegral . floor . (*(10^n)) in fmt 7 pi
21:30:01 <lambdabot>   "3.1415926"
21:30:39 <chessguy> @type (&&&)
21:30:40 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
21:31:25 <chessguy> @type (***)
21:31:26 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
21:31:41 <chessguy> that looks promising
21:32:05 <pumpkin> yeh, been trying to use it :P
21:32:12 <mmorrow> @type uncurry (:) . (head&&&tail)
21:32:13 <lambdabot> forall a. [a] -> [a]
21:32:46 <pumpkin> > ((fst *** fst) &&& (snd *** snd)) ((a,b), (c,d))
21:32:47 <lambdabot>   ((a,c),(b,d))
21:32:49 <pumpkin> that should be most of it :P
21:32:56 <Axman6> hmm, anyone using ghc-6.10.1 on ubuntu 8.10? i'm getting ld errors about not being able to find gmp, and i can't seem to find gmp in synaptic
21:33:00 <mmorrow> @type list [] (uncurry (:) . (head&&&tail))
21:33:01 <lambdabot> Not in scope: `list'
21:33:04 <pumpkin> oh actually
21:33:21 <mmorrow> @let list n _ [] = n; list _ c (x:xs) = c x xs
21:33:22 <lambdabot>  Defined.
21:33:25 <pumpkin> ((join (***) fst) &&& (join (***) snd)) ((a,b), (c,d))
21:33:27 <mmorrow> @type list [] (uncurry (:) . (head&&&tail) . (:))
21:33:27 <pumpkin> > ((join (***) fst) &&& (join (***) snd)) ((a,b), (c,d))
21:33:28 <lambdabot>     Couldn't match expected type `[a]'
21:33:28 <lambdabot>            against inferred type `[t1] -> [t1]'
21:33:28 <lambdabot>     Probable cause: `:' is applied to too few arguments
21:33:29 <lambdabot>   ((a,c),(b,d))
21:33:34 <pumpkin> boo
21:33:37 <pumpkin> :)
21:33:40 <pumpkin> almost there
21:33:47 <mmorrow> @type list [] ((uncurry (:) . (head&&&tail) .) . (:))
21:33:47 <lambdabot>     The operator `.' [infixr 9] of a section
21:33:47 <lambdabot>         must have lower precedence than the operand `(.)' [infixr 9]
21:33:47 <lambdabot>         in the section: `(uncurry (:) . (head &&& tail) .)'
21:34:01 <mmorrow> @type list [] (((uncurry (:) . (head&&&tail)) .) . (:))
21:34:02 <lambdabot> forall t1. [t1] -> [t1]
21:34:17 <ddarius> mmorrow: You realize uncurry (:) . (head&&&tail) <= id right?
21:34:24 <mmorrow> :)
21:34:36 <chessguy> pumpkin:  this doesn't seem right, because it won't take a function to apply
21:34:59 <pumpkin> chessguy: well I was trying to "transpose them", then uncurry the function on to htem
21:35:02 <mmorrow> i had to add `list' since
21:35:03 <pumpkin> still thinking
21:35:11 <mmorrow> > list [] (uncurry (:) . (head&&&tail)) []
21:35:12 <lambdabot>   Couldn't match expected type `[[a1]] -> [a]'
21:35:16 <pumpkin> chessguy: my main concern was the transposition
21:35:21 <mmorrow> >uncurry (:) . (head&&&tail) $ []
21:35:26 <Gracenotes> ooh, less-than-or-equal-to applied to extensional behavior
21:35:30 <mmorrow> > uncurry (:) . (head&&&tail) $ []
21:35:31 <lambdabot>   [* Exception: Prelude.head: empty list
21:35:39 <Gracenotes> I've seen == applied, but not ordering operators
21:35:45 <ddarius> > list [] (curry (uncurry (:) . (head &&& tail)) [1,2,3]
21:35:45 <lambdabot>   <no location info>: parse error on input `;'
21:35:57 <ddarius> > list [] (curry (uncurry (:) . (head &&& tail))) [1,2,3]
21:35:57 <lambdabot>   Couldn't match expected type `(t1, [t1])'
21:36:08 <mmorrow> > list [] (((uncurry (:) . (head&&&tail)) .) . (:)) [0..4]
21:36:10 <lambdabot>   [0,1,2,3,4]
21:36:30 <mmorrow> it gets soo ugly accounting for that []
21:36:47 <mmorrow> (well, s/ugly/not-as-simple/)
21:36:51 <Gracenotes> :t list
21:36:52 <lambdabot> forall t t1. t -> (t1 -> [t1] -> t) -> [t1] -> t
21:36:56 <chessguy> @pl \f (x,y) -> (f x, f y)
21:36:56 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
21:37:00 * chessguy sighs
21:37:10 <ddarius> > id [0..4] -- seems easy to me
21:37:11 <lambdabot>   [0,1,2,3,4]
21:37:20 <mmorrow> ddarius: blasphemy!
21:37:23 <chessguy> @pl \(x,y) -> (f x, f y)
21:37:24 <lambdabot> f *** f
21:37:27 <chessguy> whwat the
21:37:48 <pumpkin> chessguy: !
21:37:50 <pumpkin> > (join (***) $ uncurry f) $ ((join (***) fst) &&& (join (***) snd)) ((a,b), (c,d)) :: (Expr, Expr)
21:37:51 <lambdabot>   (f a c,f b d)
21:37:54 <roconnor> > showFFloat (Just 2) pi ""
21:37:55 <lambdabot>   "3.14"
21:37:59 <pumpkin> :P
21:38:04 <pumpkin> seems like it can be simplified further
21:38:07 <chessguy> @pl \(w,x) (y,z) -> (f w y, f x z)
21:38:08 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. f) . flip . (((.) . (,)) .) . f)
21:38:40 <mmorrow> @let pair (<>) f g = (\x -> f x <> g x)
21:38:41 <lambdabot>  Defined.
21:38:52 <pumpkin> > (join (***) $ uncurry f) . ((join (***) fst) &&& (join (***) snd)) $ ((a,b), (c,d))
21:38:53 <lambdabot>   Add a type signature
21:39:06 <pumpkin> > (join (***) $ uncurry f) . ((join (***) fst) &&& (join (***) snd)) $ ((w,x), (y,z)) :: (Expr, Expr)
21:39:07 <lambdabot>   (f w y,f x z)
21:39:08 <mmorrow> (&&&) = pair (,)
21:39:54 <mmorrow> f *** g = pair (,) (f . fst) (g . snd)
21:40:59 <chessguy> mmorrow:  hm. so probably won't solve my problem?
21:41:08 <mmorrow> ?
21:41:10 <pumpkin> chessguy: what's your problem?
21:41:21 <chessguy> @pl \(w,x) (y,z) -> (f w y, f x z)v
21:41:21 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip v . ((flip . (flip .)) .) . (. f) . flip . (((.) . (,)) .) . f)
21:41:27 <chessguy> or
21:41:32 <chessguy> @pl \f (w,x) (y,z) -> (f w y, f x z)
21:41:33 <lambdabot> (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (flip =<< (((.) . flip . (((.) . (,)) .)) .))
21:41:35 <pumpkin> chessguy:you don't like mine :(
21:42:05 <chessguy> pumpkin:  doesn't seem much better to me
21:42:18 <pumpkin> it's less full of composed compositions and flips at least :/
21:42:24 <pumpkin> and is a bit shorter anyway
21:42:38 <chessguy> i didn't say it wasn't any better
21:42:42 <pumpkin> :(
21:43:00 <chessguy> @pl \f -> f *** f
21:43:00 <lambdabot> join (***)
21:43:03 <chessguy> nice :)
21:43:16 <pumpkin> :P
21:43:31 <chessguy> that one simplified nicely at least
21:43:36 <mmorrow> pair (,) (\a -> f (fst (fst a)) (snd (fst a))) (\a -> g (fst (snd a)) (snd (snd a)))
21:43:50 <mmorrow> @type let foo pair (,) (\a -> f (fst (fst a)) (snd (fst a))) (\a -> g (fst (snd a)) (snd (snd a))) in foo
21:43:51 <lambdabot> parse error on input `in'
21:43:56 <Gracenotes> ah, join for (->)
21:43:59 <mmorrow> @type let foo = pair (,) (\a -> f (fst (fst a)) (snd (fst a))) (\a -> g (fst (snd a)) (snd (snd a))) in foo
21:44:00 <lambdabot> forall a b a1 b1 t1 t2. (SimpleReflect.FromExpr t2, Show b1, Show a1, SimpleReflect.FromExpr t1, Show b, Show a) => ((a, b), (a1, b1)) -> (t1, t2)
21:44:08 <Gracenotes> the only useful join I know :/
21:44:09 <mmorrow> @type let foo f g = pair (,) (\a -> f (fst (fst a)) (snd (fst a))) (\a -> g (fst (snd a)) (snd (snd a))) in foo
21:44:10 <lambdabot> forall a b t1 a1 b1 t2. (a -> b -> t1) -> (a1 -> b1 -> t2) -> ((a, b), (a1, b1)) -> (t1, t2)
21:45:05 <mmorrow> @pl \f g -> pair (,) (\a -> f (fst (fst a)) (snd (fst a))) (\a -> g (fst (snd a)) (snd (snd a)))
21:45:06 <lambdabot> (. flip (ap . (. (fst . snd))) (snd . snd)) . pair (,) . (`ap` (snd . fst)) . (. (fst . fst))
21:45:41 <Gracenotes> @src Reader (>>=)
21:45:42 <lambdabot> Source not found. :(
21:45:59 <Gracenotes> :(
21:46:11 <Axman6> pumpkin: i tested out my program in ubuntu 64, and i get basically the same errors, except i starts segfaulting for smaller n :(
21:46:14 <mmorrow> @src (->) (>>=)
21:46:14 <lambdabot> f >>= k = \ r -> k (f r) r
21:46:24 <pumpkin> Axman6: must be a similar bug to mine :/
21:46:31 <pumpkin> Axman6: you can try my testcase if you want
21:46:36 <Axman6> yeah :\
21:46:37 <Axman6> sure
21:46:43 <pumpkin> http://trac.haskell.org/uvector/ticket/1
21:46:49 <chessguy> @pl \f xs -> if (null xs) then Nothing else (Just f xs)
21:46:49 <lambdabot> ap (flip if' Nothing . null) . Just
21:47:11 <chessguy> @src (>>=) Maybe
21:47:11 <lambdabot> Source not found. Are you on drugs?
21:47:18 <chessguy> @src Maybe (>>=)
21:47:18 <lambdabot> (Just x) >>= k      = k x
21:47:18 <lambdabot> Nothing  >>= _      = Nothing
21:47:47 <mmorrow> @type list mzero ((return .) . (:))
21:47:48 <lambdabot> forall (m :: * -> *) t1. (MonadPlus m) => [t1] -> m [t1]
21:47:57 <mmorrow> @type list mzero ((return .) . (:)) :: [a] -> Maybe a
21:47:58 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
21:48:05 <mmorrow> @type list mzero ((return .) . (:)) :: [a] -> Maybe [a]
21:48:06 <lambdabot> forall a. [a] -> Maybe [a]
21:48:16 <mmorrow> @type list mzero ((return .) . const)
21:48:17 <lambdabot> forall (m :: * -> *) t1. (MonadPlus m) => [t1] -> m t1
21:48:23 <Axman6> :t list
21:48:24 <lambdabot> forall t t1. t -> (t1 -> [t1] -> t) -> [t1] -> t
21:48:25 <mmorrow> @type list mzero ((return .) . const) :: [a] -> Maybe a
21:48:26 <lambdabot> forall a. [a] -> Maybe a
21:48:39 <mmorrow>  @let list n _ [] = n; list _ c (x:xs) = c x xs
21:49:07 <mmorrow> foldl = fix (\k f z -> list z (\x xs -> k f (f z x) xs))
21:49:07 <mmorrow> foldr = fix (\k f z -> list z (\x xs -> f x (k f z xs)))
21:49:20 <Axman6> @src list
21:49:20 <lambdabot> Source not found.
21:49:32 <mmorrow> i just defined it
21:49:40 <Axman6> ah, fair enough
21:49:56 <mmorrow> (do you see it ? :)
21:50:22 <pumpkin> mmorrow: could TH be used to derive useful Show instances for (a -> b) ?
21:50:47 <sjanssen> pumpkin: what do you mean by "useful"?
21:50:55 <mmorrow> pumpkin: sure, but you'd get no additional capabilities as those you'd have writing them by hand
21:50:59 <chessguy> mmorrow:  some kind of continuation-based fold?
21:51:08 <pumpkin> mmorrow: oh :/
21:51:23 <pumpkin> sjanssen: one that actually can access the other parts of the AST being compiled, I was hoping :)
21:51:39 <pumpkin> that could disply the source of that function
21:51:48 <mmorrow> chessguy: list is the (non-rec) list cata/fold
21:51:53 <chessguy> ...
21:51:57 <chessguy> right...
21:51:59 <pumpkin> non-rec?
21:52:11 <mmorrow> non-recursive
21:52:27 <pumpkin> how does that work on a list?
21:52:27 <ddarius> @pl \r1 r2 -> f (r1 + r2)
21:52:27 <lambdabot> (f .) . (+)
21:52:36 <ddarius> @pl \f r1 r2 -> f (r1 + r2)
21:52:36 <lambdabot> (. (+)) . (.)
21:52:41 <mmorrow> so you get fold{l,r} juts by fix(ing) `list' in the two possible ways
21:52:52 <chessguy> @pl \x y -> (x - y) ^ 2
21:52:52 <lambdabot> flip flip 2 . ((^) .) . (-)
21:54:50 <mmorrow> @type flip flip 2
21:54:51 <lambdabot> forall a b c. (Num b) => (a -> b -> c) -> a -> c
21:55:17 <mmorrow> > flip flip 2 (,) []
21:55:18 <lambdabot>   ([],2)
21:55:28 <mmorrow> > flip flip flip 2 (,) []
21:55:29 <lambdabot>       No instance for (Num
21:55:29 <lambdabot>                         ((a1 -> b1 -> (a1, b1))
21:55:29 <lambdabot>   ...
21:55:39 <mmorrow> > (flip . flip) flip 2 (,) []
21:55:40 <lambdabot>       No instance for (Num ([a1] -> (a -> b -> (a, b)) -> c))
21:55:40 <lambdabot>        arising ...
21:55:51 <mmorrow> > (flip . flip) flip
21:55:52 <lambdabot>       Overlapping instances for Show ((a -> b -> c) -> b -> a -> c)
21:55:52 <lambdabot>        ar...
21:55:57 <mmorrow> @type (flip . flip) flip
21:55:58 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
21:56:02 <RPS> guys I'm sure you guys need a laugh, but I have DL'ed the GHC program with the "apt get" command listed on lyah and ...is it gui program or is it something that allows the programming to be done in a Terminal window?
21:56:05 <pumpkin> I wonder if it can be done any shorter than I wrote above
21:56:24 <pumpkin> RPS: you write in a text editor usually, and pass the file to GHC
21:56:29 <pumpkin> or you can work interactively in the terminal
21:56:36 <bos> where's the manual for haddock live now?
21:56:39 <mmorrow> RPS: in your shell or DOS prompt run "ghci"
21:56:45 <bos> it doesn't seem to be distributed with ghc.
21:56:53 <RPS> pumpkin, I'm a little more confused than before you typed ..LOL
21:57:17 <RPS> sorry I'll enter the ghci right now
21:57:29 <mmorrow> RPS: then enter "[0..]"
21:57:39 <sjanssen> mmorrow: hey now :)
21:57:54 <mmorrow> sjanssen: that's what ^C is for, right? :)
21:58:05 <pumpkin> fix id :P
21:58:11 <pumpkin> that's what ^Z is for
21:58:13 <mmorrow> ooh, not that guy
21:58:21 <mmorrow> heh, that's what kill -9 is for
21:58:21 <pumpkin> Zorro!
21:58:37 <RPS> Ok ...that put a lot of energy into the terminal window ...it's scrolling by FAST
21:58:43 <mmorrow> heh
21:58:51 <mmorrow> type ctrl-c
21:58:53 <sjanssen> RPS: hit control and c
21:59:05 <chessguy> @let pair3 f (a,b) (c,d) = (f a c, f b d)
21:59:06 <lambdabot>  Defined.
21:59:06 <sjanssen> (you might need to type it a couple times)
21:59:08 <RPS> it stopped
21:59:25 <mmorrow> nice, that's how to stop stuff like that
21:59:29 <mmorrow> , [0..]
21:59:31 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
21:59:35 <sjanssen> RPS: so now you should be able to follow LYAH from there
21:59:39 <mmorrow> RPS: are you on window or unix?
21:59:46 <pumpkin> chessguy: I guess the pointful one is as short and elegant as you're going to get :P
21:59:47 <RPS> ubuntu ...so unix
22:00:06 <pumpkin> chessguy: or if there's a shorter way, it's beyond my noobish skillz :P
22:00:12 <chessguy> > foldr (pair3 (+)) (0,0) [(1,2), (3,3),(2,8)]
22:00:13 <lambdabot>   (6,13)
22:00:17 <mmorrow> RPS: ah nice, so if ^C ever doesn't work, you can ^Z (then proceed to kill ghci)
22:00:21 <RPS> how do you get into and out of ghc?
22:00:26 <pumpkin> RPS: :q
22:00:28 <pumpkin> gets you out
22:00:32 <MyCatVerbs> Or control-D.
22:00:36 <mmorrow> RPS: type ":?"
22:00:36 <chessguy> > (1,2) + (3,4)
22:00:37 <lambdabot>       No instance for (Num (t, t1))
22:00:37 <lambdabot>        arising from a use of `+' at <inte...
22:00:38 <pumpkin> to get in you type ghci :P
22:00:48 <chessguy> hmm...
22:00:50 <MyCatVerbs> pumpkin: really? I didn't know you could do that. =D
22:00:55 <pumpkin> :)
22:01:21 <chessguy> an instance Num would do it
22:01:28 <chessguy> @src Num
22:01:28 <lambdabot> class  (Eq a, Show a) => Num a  where
22:01:28 <lambdabot>     (+), (-), (*)           :: a -> a -> a
22:01:28 <lambdabot>     negate, abs, signum     :: a -> a
22:01:28 <lambdabot>     fromInteger             :: Integer -> a
22:01:38 <pumpkin> chessguy: that would allow you to use +, but what about other functions?
22:01:41 <pumpkin> or was + all you wanted?
22:01:48 * RPS is thinking ....What have I gotten myself into?
22:02:04 <mmorrow> RPS: it's too late to turn back now!
22:02:05 <chessguy> pumpkin:  most of those could be defined on (a,b)
22:02:08 <oklopol> > continueSequence [1,2,3]
22:02:09 <lambdabot>   Not in scope: `continueSequence'
22:02:15 <sjanssen> System.Posix.Process.exitImmediately System.Exit.ExitSuccess -- correct way to exit ghci
22:02:18 <chessguy> pumpkin: (defined naturally, i mean)
22:02:20 <oklopol> there was something like that right?
22:02:24 <MyCatVerbs> RPS: a cult. *yawn*
22:02:29 <RPS> so this is where the real work happens huh?
22:02:31 <MyCatVerbs> RPS: care to ask a more difficult question next time? +D
22:02:41 <MyCatVerbs> s/+D/=D/
22:02:48 <chessguy> @instances-importing Num
22:02:49 <lambdabot> Double, Float, Int, Integer
22:02:56 <chessguy> boring instances
22:02:57 <pumpkin> > uncurry (zipWith f) . (join (***) $ uncurry ((++) `on` return)) $ ((x, y), (a, b)) :: [Expr] -- chessguy... maybe this is a little better? but it gives a list :(
22:02:59 <lambdabot>   [f x a,f y b]
22:03:12 <chessguy> @src on
22:03:13 <lambdabot> (*) `on` f = \x y -> f x * f y
22:03:39 <pumpkin> oh that might help actually
22:03:44 <chessguy> indeed
22:04:11 <chessguy> actually, isn't it just on (,) ?
22:04:18 <chessguy> @type on (,)
22:04:19 <lambdabot> forall b a. (a -> b) -> a -> a -> (b, b)
22:04:29 <chessguy> err, not quite
22:06:03 <MyCatVerbs> > runST (newSTRef 0 >>= \r -> (mapM_ (\x -> readSTRef r >>= \a -> writeSTRef r (a+x)) [(1::Integer)..10]) >> readSTRef r)
22:06:04 <lambdabot>   /tmp/3632958020563773136:70:48: Not in scope: `runST'/tmp/36329580205637731...
22:06:35 <MyCatVerbs> Snap. No Control.Monad.ST or Data.STRef in \bot.
22:06:54 <mmorrow> , runST (newSTRef 0 >>= \r -> (mapM_ (\x -> readSTRef r >>= \a -> writeSTRef r (a+x)) [(1::Integer)..10]) >> readSTRef r)
22:06:56 <lunabot>  55
22:07:26 <MyCatVerbs> Oh. \bot is just broken?
22:07:33 <mmorrow> lunabot has uvector too if you're so inclined
22:07:34 <MyCatVerbs> When did that happen?
22:07:41 <MyCatVerbs> mmorrow: sweet, thanks.
22:07:53 <Axman6> ST is quite fun
22:07:59 <pumpkin> Axman6: maybe we can get lunabot to have the bug in the channel :D
22:08:09 <Axman6> heh, let's hope so!
22:08:11 <mmorrow> heh
22:08:24 <pumpkin> mmorrow: Axman6 has the same bug I'm having it seems!
22:08:25 * pumpkin cries
22:08:52 <pumpkin> @botsnack
22:08:52 <lambdabot> :)
22:08:53 <lunabot>  :)
22:09:00 * mmorrow won't give it away, but there's a way to get it to get disconnected by causing it to flood
22:09:07 <pumpkin> !
22:09:10 <chessguy> > signum 3
22:09:11 <lambdabot>   1
22:09:30 <sjanssen> mmorrow: fix error?
22:09:31 <pumpkin> mmorrow: I vote for changing lunabot's character to $
22:09:44 <mmorrow> , fix error
22:09:50 <lunabot>  Killed.
22:09:51 <Axman6> yeah, i find , pretty ugly
22:09:56 <Saizan> Cabal-1.4.x was first released with 6.8.3 ?
22:09:59 <pumpkin> , print "ohai"
22:10:02 <lunabot>  luna: No instance for (GHC.Show.Show (GHC.IOBase.IO ()))
22:10:06 <mmorrow> pumpkin: but ',' is so nice like
22:10:08 <pumpkin> :)
22:10:10 <mmorrow> ] 42
22:10:12 <lunabot>  42
22:10:23 <pumpkin> ah ] works too?
22:10:29 <pumpkin> $ makes me feel richer though
22:10:32 <mmorrow> i could just go add '$' to the list (if no one objects)
22:10:36 <mmorrow> heh
22:10:38 <pumpkin> and you can say that every time someone uses $ they give you a dollar
22:10:57 <mmorrow> very true
22:11:11 * BMeph wants to holla at the l-bot for a dolla... ;p
22:11:25 <pumpkin> lol
22:11:26 <mmorrow> , oHEARhaVA $ MMKTHX
22:11:28 <lunabot>  luna: Not in scope: `oHEARhaVA'
22:13:36 <BMeph> mmorrow: What's up with that? ;)
22:13:58 <BMeph> $ eat at joe's
22:13:59 <mmorrow> heh
22:15:05 <Gracenotes> $.$
22:15:13 <Axman6> ok, this thing is taking far too long to run on ubuntu...
22:15:31 <Olathe> > (:[]) $ 5
22:15:32 <lambdabot>   [5]
22:15:45 <mmorrow> $ 4444444
22:15:48 <lunabot>  4444444
22:15:51 <Olathe> > (:[]) $ 5 == ([5])
22:15:52 <lambdabot>       No instance for (Num [t])
22:15:52 <lambdabot>        arising from the literal `5' at <inter...
22:16:00 <pumpkin> chessguy: let me know if you find a shorter solution, I'm interested :)
22:16:02 <Olathe> Bah.
22:16:21 <chessguy> pumpkin:  will do. i probably won't waste more time on it though
22:16:24 <Olathe> > ([5]) == (:[]) $ 5
22:16:25 <lambdabot>       The section `(: [])' takes one argument,
22:16:25 <lambdabot>      but its type `[t]' has none
22:16:29 <pumpkin> chessguy: alright :)
22:17:04 <mmorrow> $ show $ "$"
22:17:06 <Olathe> Wow, that's a much better error message than I usually get.
22:17:06 <lunabot>  "\"$\""
22:17:15 <chessguy> bigger fish to fry and all that
22:17:26 <Olathe> ...a bunch of stuff about types.
22:17:45 <Olathe> > ([5]) == (\x -> [x]) $ 5
22:17:46 <lambdabot>       The lambda expression `\ x -> ...' has one argument,
22:17:46 <lambdabot>      but its type ...
22:17:49 <pumpkin> ç
22:17:50 <Olathe> Wow.
22:17:54 <pumpkin> *Main> ((*8) + (^2)) 5
22:17:54 <pumpkin> 65
22:18:01 <Olathe> > let f x = [x] in ([5]) == f $ 5
22:18:01 <lambdabot>   Couldn't match expected type `[t]'
22:18:02 <pumpkin> I love mauke's fun.hs :)
22:18:03 <Axman6> > [5] == (:[]) 5
22:18:04 <lambdabot>   True
22:18:06 <Olathe> There we go !
22:18:17 <Olathe> A nice, horrible normal error message.
22:18:24 <Gracenotes> > (:[]) $ (:[]) $ (:[]) $ (:[]) $ 0.0
22:18:25 <lambdabot>   [[[[0.0]]]]
22:18:41 <chessguy> lol
22:18:46 <chessguy> cute
22:18:52 <Olathe> Heheh
22:19:03 <BMeph> Axman6: Sup dawg, I herd u liek ubuntu, so I got u a virtual hardy heron so u can ubuntu while u ubuntu! ;p
22:19:20 <pumpkin> lol
22:19:23 <Axman6> i do not like ubuntu :(
22:19:33 <pumpkin> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
22:19:34 --- mode: ChanServ set +o mauke
22:19:41 <pumpkin> lol
22:19:46 <mmorrow> haha
22:19:58 <pumpkin> I guess mauke made a script :P
22:20:24 <Axman6> jesus, my n-bodies program runs in 2:30 in OS X, but 13:55 on ubuntu in VMWare
22:20:25 <sjanssen> nice
22:20:40 <Axman6> would've thought that it being 64-bit would have sped it up somewhat
22:20:41 <lambdabot> #ubuntu-tr
22:20:44 <chessguy> @type let f (:*) g = f . g = head . tail
22:20:45 <lambdabot> parse error on input `='
22:20:46 * BMeph thinks Evil Thoughts...
22:20:53 <pumpkin> sjanssen: can you make ubuntu speak?
22:21:06 <chessguy> @type let f (:*) g = f . g in head :* tail
22:21:06 <lambdabot> Not in scope: data constructor `:*'
22:21:06 <lambdabot> Not in scope: data constructor `:*'
22:21:08 <lambdabot> #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr #ubuntu-tr
22:21:10 <pumpkin> Axman6: compiled with -O2 on both?
22:21:14 <Axman6> yep
22:21:15 <pumpkin> lol
22:21:29 <Axman6> heh
22:21:36 <pumpkin> > text . repeat $ "#ubuntu-tr"
22:21:37 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
22:21:43 <pumpkin> > text . concat . repeat $ "#ubuntu-tr"
22:21:49 <mmorrow> heh
22:21:56 <pumpkin> > text . concat . replicate 10 $ "#ubuntu-tr"
22:21:57 <lambdabot>   mueval: Prelude.read: no parse
22:21:59 <pumpkin> :(
22:22:01 <lambdabot>   #ubuntu-tr#ubuntu-tr#ubuntu-tr#ubuntu-tr#ubuntu-tr#ubuntu-tr#ubuntu-tr#ubun...
22:22:01 <sjanssen> > unwords . repeat $ "#ubuntu-tr"
22:22:09 <mmorrow> hah
22:22:13 <pumpkin> epic DOS
22:22:13 <chessguy> haha
22:22:13 <Axman6>  text . cycle ...
22:22:42 <pumpkin> :)
22:22:45 <MyCatVerbs> , let { halfs n = if n == 0 then [] else (n-1):halfs (n`div`2); } in runST (((newArray (0,1023::Int) (1::Float) :: ST s (STUArray s Int Float)) >>= \ra -> mapM (mapM (\i -> if even i then (readArray ra i >>= \e1 -> readArray ra (i`div`2) >>= \e2 -> writeArray ra (i`div`2) (e1+e2) >> return (e1+e2)) else return 0) . enumFromTo 0) (halfs 1024)) >>= return . last . last) -- does lunabot understand STUArray too? =D
22:22:47 <lunabot>  luna: parse error (possibly incorrect indentation)
22:22:48 <chessguy> @type let f (.*) g = f . g in (.) head tail
22:22:50 <lambdabot>     Occurs check: cannot construct the infinite type:
22:22:50 <lambdabot>       t = a -> (a -> b) -> t
22:22:50 <lambdabot>     Probable cause: `.' is applied to too few arguments
22:22:57 <rwbarton> MyCatVerbs: It doesn't understand comments
22:23:01 <mae__> hi all
22:23:05 <MyCatVerbs> , let { halfs n = if n == 0 then [] else (n-1):halfs (n`div`2); } in runST (((newArray (0,1023::Int) (1::Float) :: ST s (STUArray s Int Float)) >>= \ra -> mapM (mapM (\i -> if even i then (readArray ra i >>= \e1 -> readArray ra (i`div`2) >>= \e2 -> writeArray ra (i`div`2) (e1+e2) >> return (e1+e2)) else return 0) . enumFromTo 0) (halfs 1024)) >>= return . last . last)
22:23:08 <lunabot>  2048.0
22:23:10 <MyCatVerbs> rwbarton: ah thanks.
22:23:12 <pumpkin> MyCatVerbs: see if you can get a bug!
22:23:13 <mmorrow> MyCatVerbs: ah, there's an "i'm too lazy to fix it" thing with comments at the end of the exp
22:23:22 <mmorrow> {- these are OK though -}
22:23:23 <MyCatVerbs> Damn, correct answer. So no, that didn't trip the bug. =)
22:23:26 <pumpkin> lol
22:23:28 <BMeph> MyCatVerba: Looks like lunabot only knows STFUArrays... ;)
22:23:35 <pumpkin> someone's doing evil with lambdabot
22:23:36 <rwbarton> mmorrow: wouldn't it take adding exactly two characters to the lunabot source?
22:23:50 <rwbarton> mmorrow: ) -> \n)
22:23:50 <chessguy> @type let (.*.) f g = f . g in (.*.) head tail
22:23:51 <lambdabot> forall a. [a] -> a
22:24:00 <pumpkin> sjanssen: what's the command to tell lambdabot to speak?
22:24:01 --- mode: mauke set -o mauke
22:24:03 <mmorrow> MyCatVerbs: to be honest, i'd give anyone a 1 in 10000 change of tripping the one i'm thinking of
22:24:11 <Axman6> mmorrow: try larger numbers? :\
22:24:19 <sjanssen> pumpkin: @vixen will work
22:24:20 <mmorrow> nothing to do with number
22:24:20 <mmorrow> s
22:24:27 <chessguy> @type let (.*) f g = f . g in (.*) head tail
22:24:27 <sjanssen> @vixen how do we make you speak?
22:24:28 <lambdabot> forall a. [a] -> a
22:24:28 <lambdabot> however you want
22:24:31 <Axman6> , type fix.fix
22:24:33 <lunabot>  luna: parse error on input `type'
22:24:43 <pumpkin> hmm
22:24:44 <mmorrow> , [$ty| fix . fix |]
22:24:47 <sjanssen> pumpkin: @msg, but you've got to be on lambdabot's list of operators
22:24:49 <lunabot>  Killed.
22:24:50 <mmorrow> , [$ty| fix id |]
22:24:51 <Axman6> :t fix . fix
22:24:52 <lambdabot> forall a. ((a -> a) -> a -> a) -> a
22:24:56 <lunabot>  forall a . a
22:24:59 <mmorrow> , [$ty| fix . fix |]
22:25:02 <MyCatVerbs> , let { halfs n = if n == 0 then [] else (n-1):halfs (n`div`2); squee = 1024*1024::Int } in runST (((newArray (0,squee - 1) (1::Float) :: ST s (STUArray s Int Float)) >>= \ra -> mapM (mapM (\i -> if even i then (readArray ra i >>= \e1 -> readArray ra (i`div`2) >>= \e2 -> writeArray ra (i`div`2) (e1+e2) >> return (e1+e2)) else return 0) . enumFromTo 0) (halfs squee)) >>= return . last . last)
22:25:06 <lunabot>  Killed.
22:25:09 <lunabot>  Killed.
22:25:11 <Gracenotes> HEADSHOT
22:25:16 <MyCatVerbs> BEWM
22:25:38 <mmorrow> maybe it's under load (lunabot's machine is realllly sucky)
22:25:46 <rwbarton> sjanssen: is that why lambdabot sometimes seems to say things unprovoked?
22:25:48 <BMeph> > text . cycle $ "Badger! "
22:25:52 <sjanssen> rwbarton: yes
22:25:57 <MyCatVerbs> Does luna have a way to remember old definitions? @let?
22:26:03 <lambdabot>   thread killed
22:26:09 <MyCatVerbs> Just so that I don't end up spamming huge monster things repeatedly. :)
22:26:10 <mmorrow> MyCatVerbs: unfortuanely not
22:26:24 <MyCatVerbs> mmorrow: damn. Oh well, monsters it is.
22:26:31 <mmorrow> yay!
22:26:36 <rwbarton> MyCatVerbs: I hear there's a program you can use named "ghci"
22:27:00 * mmorrow has never heard of it
22:27:03 <rwbarton> unless you're on linux ppc that is
22:27:10 <mmorrow> hehe
22:27:13 <chessguy> here's what i've been working on. i think it can still be improved: http://hpaste.org/13977
22:27:21 * rwbarton spent about 12 hours trying to get ghci working on linux ppc and failed
22:27:23 <MyCatVerbs> , let { halfs n = if n == 0 then [] else (n-1):halfs (n`div`2); } in map (\squee -> runST (((newArray (0,squee - 1) (1::Float) :: ST s (STUArray s Int Float)) >>= \ra -> mapM (mapM (\i -> if even i then (readArray ra i >>= \e1 -> readArray ra (i`div`2) >>= \e2 -> writeArray ra (i`div`2) (e1+e2) >> return (e1+e2)) else return 0) . enumFromTo 0) (halfs squee)) >>= return . last . last)) (map (2^) [10..])
22:27:29 <lunabot>  Killed.
22:27:40 <mmorrow> rwbarton: it doesn't already?
22:27:50 <mmorrow> ohhhh, /linux/ ppc
22:27:53 <MyCatVerbs> rwbarton: yes, but that wouldn't give me nearly as many oppourtunities to publically humiliate myself with basic type errors.
22:28:12 <mmorrow> MyCatVerbs: lunabot handles /msg's too
22:28:12 <rwbarton> Well, actually I spent 10 minutes starting ghc builds which ended up not working many hours later
22:28:26 <mmorrow> love that
22:28:35 <MyCatVerbs> mmorrow: what part of public humiliation did you miss? :)
22:29:01 <mmorrow> the third to last part
22:29:17 <jekor> Are there searchable logs of the channel anywhere?
22:29:20 <MyCatVerbs> mmorrow: well, that's the most important one. Don't do it again.
22:29:31 <MyCatVerbs> jekor: I think so. They come up on Google.
22:29:32 <WhoseCatVerbs> jekor: in topic
22:29:33 <BMeph> MyCatVerbs: Thanks, next time I go play on WOW, I'm making a Hunter named "Clickclickbewm" just for you. ;)
22:29:38 * mmorrow swears
22:29:47 <jekor> WhoseCatVerbs: The links to searchable versions there are broken.
22:29:48 <Axman6> bleh, why must Core names be so ugly :(
22:29:54 <mmorrow> ok, /me passes out
22:30:02 <MyCatVerbs> jekor: http://ircarchive.info/haskell.html
22:30:05 <jekor> Thanks.
22:30:19 <MyCatVerbs> BMeph: thanks. :)
22:30:42 <MyCatVerbs> BMeph: and I don't think I've ever actually played an RPG where I didn't get to be the one shooting fire from their fingertips.
22:31:19 <MyCatVerbs> BMeph: wait, tell a lie, Diablo 2. But that game is evil anyway and I naturally regret ever touching it. :)
22:32:37 <sjanssen> MyCatVerbs: don't say that name!
22:32:44 <sjanssen> I've been known to go on binges over less
22:32:45 <BMeph> MyCatVerbs: O RLY? Why so?  I love that game, esp. playing a Barbie with a whole lot of jump talent. :)
22:33:30 * BMeph wants everyone to notice how he didn't say -- er, "the name". ;)
22:33:44 <MyCatVerbs> sjanssen: "Neverwinter" does the same to me. :/
22:34:51 <MyCatVerbs> BMeph: because it actually sucks, and it's a surefire way to get RSI.
22:35:55 <jekor> Has anyone tried a literate programming tool other than lhs2tex or Noweb with Haskell?
22:36:31 <Axman6> from GHC.Tuple... yuck: (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__ i__ j__
22:37:00 <pumpkin> lol
22:37:10 <pumpkin> they actually wrote them all explicitly?
22:37:21 <pumpkin> I thought it was some hack in there to generate them
22:37:22 <Axman6> mmorrow: how do i use lunabot to find out how many arguments it takes?
22:37:32 <MyCatVerbs> Axman6: that freakish. What kind of degenerate would use underscores instead of calling them "aa" "ab" "ac"...
22:37:44 <pumpkin> http://www.haskell.org/ghc/dist/current/docs/libraries/ghc-prim/src/GHC-Tuple.html
22:37:52 <pumpkin> nice patterns
22:37:54 <MyCatVerbs> And now it transpires that I am incapable of communication. Goodnight.
22:37:55 <Axman6> well they stopped at 15-tuples for show istances
22:38:01 <pumpkin> {- Manuel says: Including one more declaration gives a segmentation fault.
22:38:12 <MyCatVerbs> *snerk*
22:38:16 <sjanssen> pumpkin: hahaha
22:38:17 <lament> tuples are proof that haskell is inherently broken and will never work.
22:38:29 <pumpkin> so now we know why they stop where they stop :)
22:38:37 <pumpkin> lament :o
22:38:38 <sjanssen> @remember lament tuples are proof that haskell is inherently broken and will never work.
22:38:38 <lambdabot> I will remember.
22:38:41 <sjanssen> 0/10
22:38:47 <lament> someone had lots of fun generating that file
22:38:49 <lament> (i hope)
22:38:50 <Axman6> data (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__ i__ j__ k__ l__ m__ n__ o__ p__ q__ r__ s__ t__ u__ v__ w__ x__ y__ z__ a___ b___ c___ d___ e___ f___ g___ h___ i___ j___ k___ l___ m___ n___ o___ p___ q___ r___ s___ t___  u__
22:38:56 <Axman6> o.O
22:38:57 <mauke> needs more TH
22:39:06 <pumpkin> yeah, couldn't this be done in a couple of lines of TH?
22:39:22 <lament> pumpkin: on the other hand, isn't it _clearer_ this way?
22:39:42 <lament> this code doesn't ever need to change, so maintainability is not a concern
22:39:50 <pumpkin> not sure it's clearer
22:39:59 <pumpkin> I don't know what the largest n-tuple is here
22:40:10 <pumpkin> if I just had a map from 1..60something
22:40:12 <lament> yeah, they could've put a comment saying that
22:40:35 <pumpkin> they could also add a nice typeclass on tuples easily
22:40:42 <leepike> QuickCheck newbie question: I want to quickCheck a property (that I know is false), but I want to execute n tests and have returned that x/n tests failed rather than to quit on the first failure.  Is there a library function to do this?  Thx.
22:40:46 <pumpkin> well, a set of typeclasses
22:40:54 <pumpkin> :P
22:41:11 <pumpkin> (HasFirst a) => a; fst a
22:41:14 <Axman6> > length . words $ "a b c d e f g h i j k l m n o p q r s t u v w x y z a_ b_ c_ d_ e_ f_ g_ h_ i_ j_ k_ l_ m_ n_ o_ p_ q_ r_ s_ t_ u_ v_ w_ x_ y_ z_ a__ b__ c__ d__ e__ f__ g__ h__ i__ j__"
22:41:16 <lambdabot>   62
22:41:27 <chessguy> {- Manuel says: Including one more declaration gives a segmentation fault.
22:41:28 <chessguy> hahaha
22:41:31 <pumpkin> (HasFifteenth a) => a; fftnth a
22:41:32 <pumpkin> :P
22:41:43 <lament> pumpkin: ugh
22:41:45 <pumpkin> ;)
22:41:46 <Taejo> pumpkin: Haskell on Rails
22:41:49 <lament> haha
22:41:51 <pumpkin> Taejo: damn right :)
22:42:05 <pumpkin> haskell needs to be on something else though
22:42:09 <lament> Haskell on Rails would also have fifteenth, fifteenthElement and take15th
22:42:19 <Taejo> lol
22:42:30 <mauke> take1th, take2th, take3th, take4th, ...
22:42:35 <Axman6> Haskell on Runways
22:42:41 <lament> mauke: :D
22:42:45 <Taejo> Haskell on Highways
22:42:55 <lament> on Hormones
22:43:06 <pumpkin> lol
22:43:08 <Taejo> Haskell on Heroine
22:43:11 <Taejo> *Heroin
22:43:15 <pumpkin> Haskell on Hashish
22:43:28 <Taejo> Heroines on Heroin
22:43:37 <profmakx> well. haskell on haskell is the way to go
22:43:44 <pumpkin> haskell `on` haskell?
22:44:03 <Taejo> :t on
22:44:04 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
22:44:15 <pumpkin> I really like it
22:44:26 <twb> cabal install gitit --error-->
22:44:26 <twb> Preprocessing library pcre-light-0.3.1...
22:44:26 <twb> Base.hsc:103:18: error: pcre.h: No such file or directory
22:44:33 <twb> ...is this Cabal's fault, or the library's?
22:44:38 <Taejo> do (b -> b -> c) and (a -> b) unify?
22:44:40 * chessguy reverts all his changes that apparently broke the tests
22:44:43 <chessguy> *sigh*
22:44:46 <chessguy> time for bed
22:44:47 <pumpkin> > ((++) `on` return) 5 6
22:44:48 <twb> (for not detecting that the C library isn't present.)
22:44:49 <lambdabot>   [5,6]
22:45:02 <Taejo> @src on
22:45:03 <lambdabot> (*) `on` f = \x y -> f x * f y
22:45:16 <pumpkin> it's pretty nice :)
22:45:31 <Taejo> I've only ever used (comparing `on`)
22:47:18 <Axman6> :t compare
22:47:20 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
22:47:23 <Axman6> :t comparing
22:47:24 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
22:47:41 <Axman6> :t (compare `on`)
22:47:42 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
22:47:56 <Axman6> Taejo: sounds like you should just use comparing ;)
22:48:16 <Taejo> oh, lol, I guess I meant (compare `on`)
22:48:27 <Taejo> @src comparing
22:48:28 <lambdabot> Source not found. I've seen penguins that can type better than that.
22:48:39 <pumpkin> @where Data.Ord
22:48:39 <lambdabot> I know nothing about data.ord.
22:48:44 <pumpkin> @source Data.Ord
22:48:44 <lambdabot> Data.Ord not available
22:48:44 <Taejo> comparing = on compare ??
22:48:50 <sjanssen> twb: the library's
22:49:16 <twb> sjanssen: ok, thanks.
22:49:21 <paolino> @hoogle comparing
22:49:22 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
22:49:22 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
22:49:24 <twb> I thought that was probably the case
22:49:41 <sjanssen> twb: the library should use a configure test of pkg-config
22:49:44 <sjanssen> s/of/or
22:49:53 <twb> Yepd
22:49:53 <Axman6> @src comparing
22:49:54 <lambdabot> Source not found. Just what do you think you're doing Dave?
22:50:02 <pumpkin> , src 'comparing
22:50:05 <lunabot>  luna: Not in scope: `comparing'
22:50:41 <paolino> eh, luna is not offensive
22:51:05 <pumpkin> boo, comparing doesn't use on
22:51:09 <pumpkin> http://hackage.haskell.org/packages/archive/base/4.0.0.0/doc/html/src/Data-Ord.html#comparing
22:52:10 <Axman6> @index (#,#)
22:52:10 <lambdabot> bzzt
22:52:16 <Axman6> @hoogle (#,#)
22:52:17 <lambdabot> Prelude undefined :: a
22:52:17 <lambdabot> Data.Array.Base arrEleBottom :: a
22:52:17 <lambdabot> Test.QuickCheck.Batch bottom :: a
22:52:24 <Axman6> :|
23:02:43 <Axman6> wow... program with -O2 runtime: 2m30~, without: 15m7
23:02:56 <Corun> Nice.
23:03:08 <RPS> guys I'm confused ...I'm working on the tutorial and I've ran into something weird.
23:03:13 <RPS> # ghci> "hello" == "hello"
23:03:13 <RPS> # True
23:03:33 <RPS> that is what I should be getting, but instead I'm getting this:
23:03:51 <lament> paper!
23:03:55 <RPS> <interactive>:1:17: lexical error in string/character literal at end of input
23:03:55 <RPS> ghci> hello == hello
23:03:55 <RPS> <interactive>:1:0: Not in scope: `hello'
23:03:55 <RPS> <interactive>:1:9: Not in scope: `hello'
23:04:04 <Axman6> RPS: you need "hello" not hello
23:04:26 <RPS> I ran it boh ways
23:04:29 <RPS> both
23:04:32 <Axman6> one is a string, the other is a function, or constant or something
23:04:35 <dons> anyone want to comment on this? http://www.reddit.com/r/programming/comments/7q4bu/is_haskell_a_ponzi_scheme/
23:04:39 <Axman6> > "hello" == "hello"
23:04:40 <lambdabot>   True
23:05:04 <lament> @faq is haskell a ponzi scheme?
23:05:04 <lambdabot> The answer is: Yes! Haskell can do that.
23:05:09 <dons> :)
23:05:14 <Axman6> ponzi?
23:05:22 <mae__> um definitely aponzi scheme
23:05:23 <mae__> :P
23:05:56 <RPS> dang I missed a " on one of the Hellos LOL
23:06:03 <intoverflow> "How many of those are applications rather than just libraries that wrap things like zlib and OpenGL?"
23:06:06 <intoverflow> this always drives me *crazy*
23:06:11 <intoverflow> code-reuse is a *good thing*
23:06:16 <dons> ah well
23:06:26 <dons> ?users
23:06:27 <lambdabot> Maximum users seen in #haskell: 658, currently: 587 (89.2%), active: 17 (2.9%)
23:06:28 <intoverflow> I don't know why people think that wrappers for well-tested, portable libraries somehow is *bad*
23:06:34 <dons> the joys of getting a lot of attention
23:06:43 <pumpkin> dons: *SCREAM*
23:06:44 <pumpkin> lol
23:06:46 <lament> intoverflow: his point is that there isn't much other stuff
23:06:52 <ikegami__> :)
23:06:55 <lament> intoverflow: not that wrappers to zlib are a bad thing
23:07:26 <sjanssen> dons: only response necessary is http://hackage.haskell.org
23:07:30 <dons> well, there's lots of stuff. most people here are writing stuff. what do they want? more xmonads? more cryptols? more credit suisse's?
23:07:35 <dons> sjanssen: yup
23:07:40 <lament> dons: probably, yes.
23:07:40 <intoverflow> more PERL 6 ??
23:07:45 <sjanssen> dons: "but no one writes much code beyond trivial copycats." is the core of the argument, apparently
23:08:09 <dons> right, just ignorance of hackage.
23:08:15 <Axman6> oh dons, i have some interesting news for you. i moved my n-bodies thing to using STUArrays... and i get segfaults for n > 21 :)
23:08:23 <Axman6> its very strange
23:08:33 <dons> hehe
23:08:38 <dons> don't walk past the end!
23:08:39 <sjanssen> Norman Ramsey has inspired me -- I wonder how quickly I can write a Unix shell in Haskell?
23:08:49 <dons> sjanssen: its a galois job interview question, fwiw :)
23:08:54 <dons> add job control...
23:09:16 <intoverflow> We need a "everything you thought you knew about haskell is wrong".org
23:09:30 <sjanssen> dons: yeah, basically Unix 101 without having to emulate ADTs in C
23:10:42 <Axman6> dons: mind taking at look at http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=767#a768 and telling me if there's anything glaringly wrong? i get the same results on ubuntu in VMware, but for lower n (n being the n given to ./nbodies n)
23:10:56 <dons> i'm about to head to bed. but can you email me?
23:11:06 <dons> i'd like nothing more than to improve fannkuch and nbody this weekend
23:11:17 <pumpkin> dons: it looks similar to my bug
23:11:19 <Axman6> sure, want to pm me your address?
23:11:19 <pumpkin> if that helps
23:11:22 <mae__> if peter schiff programmed, he would program in haskell, yeah, thats how cool he is.
23:11:24 <dons> maybe release a new xmonad too, would also make me happy
23:11:35 <dons> Axman6: dons <> galois <> com
23:11:41 <Axman6> ta :)
23:11:52 <mae__> ; )
23:12:04 <dons> anyone else note johnnowak's conversion to haskell?
23:12:19 <Axman6> who?
23:12:32 <dons> moderately famous ML programmer :)
23:12:43 <dons> serious guy.
23:12:44 <dolio> What's there to improve with fannkuch?
23:12:55 <dolio> Converting it from Ptr/Addr makes it slower. :)
23:13:04 <dons> http://www.reddit.com/r/programming/comments/7pohw/why_haskell_is_beyond_ready_for_prime_time/c071tjv
23:13:08 <dons> dolio: mm
23:13:21 <dons> the current impl. is crazy crazy business
23:13:31 <dolio> Yeah, I know.
23:13:39 <dons> seriously.
23:13:45 <dons> i don't know what i was thinking.
23:13:51 <Axman6> heh
23:13:52 <dons> but at least it is fast, eh?
23:13:58 <dolio> I have several versions on my machine. MutableByteArray#, IOUArray, 2 STUArray versions and a uvector version.
23:14:06 <dolio> And the current Addr# version.
23:14:13 <dons> caught the ## version yet?
23:14:22 <Olathe> IOU $ 5
23:14:31 <dons> STFUArray version?
23:15:00 <dolio> uvector would probably match up except for constructed product returns.
23:15:05 <dons> mm
23:15:12 <dons> maybe that's it. i'd not thought of that.
23:16:08 <dolio> Is the shootout using that? I imagine not.
23:16:20 <dons> thanks Axman6
23:16:22 <dolio> STUArray will be slower than that due to Ix specialization stuff.
23:16:25 <dons> uvector, no.
23:16:36 <dons> its gotta be ST* , Foreign* or Ptr*
23:16:42 <dolio> Yeah.
23:16:54 <Axman6> huh... my STArray version was running in about 2m30 with -O2 before, now it's as slow as without -O2 :|
23:17:00 <dons> we just have to parallelise it :)
23:17:22 <Axman6> i don't think nbodies can be parallelised very easily
23:17:50 <Axman6> there's not enough planets, and the work done foe each planet i not very much. but i could be wrong
23:17:55 <dons> yeah
23:18:43 <pumpkin> Axman6: is that a challenge!
23:19:06 <Axman6> i mean, if there were 100 bodies, then it'd work ok maybe, but 5 is not enough realy
23:19:09 <Axman6> ll*
23:19:21 <pumpkin> on an 8-core machine you could give one planet to each core :P
23:19:28 <pumpkin> but I'm not sure how smart a division that would be
23:20:31 <erikc> there we go, parsing a windows pecoff cabal.exe on my mac :)
23:20:34 <Axman6> yeah, and since each iteration relies on the previous one...
23:20:38 <dons> erikc: woo!
23:20:40 <pumpkin> erikc: :D
23:20:50 <pumpkin> erikc: what will you do when you're done with all those formats?
23:21:43 <erikc> i wanna do something similar to the dotnet package for objc on mac, and learn the cabal src to contribute to that
23:22:07 <pumpkin> ah yeah, that'll be great if you can pull it off :)
23:22:11 <pumpkin> the objc thing
23:22:29 <erikc> and i need to read up on COM interop so i can use the DIA component on windows to parse .pdb's, since MS hasnt standardized the format
23:22:46 <pumpkin> ah
23:23:00 <pumpkin> erikc: then you'll move onto an epic cross-platform disassembler I hope ;)
23:23:13 <pumpkin> in pure haskell, of course
23:27:11 <erikc> also a generator for Storable instances of c/c++ aggregate types for FFI
23:27:18 <Axman6> ok, i have no idea wtf is going on here, this n-bodies thing used to run in less than 3 mins, and afaict, i have't changed it, but now it runs in about 15 mins
23:32:42 <erikc> theres some other bits that have piqued my interest, such as ghci debugging of compiled code, but i've no idea what the technical issues are, so not sure how big a piece that'd be to bite off
23:35:37 <xpika> does hugs support a <- b bindings?
23:36:33 <duryodhan> hi .. wats wrong with splitWith :: (a-> Bool)->[a]->[[a]] splitWith f x = let pair=(span f x) in 			(fst pair):(splitWith f (snd pair) )
23:36:41 <duryodhan> a new line after the type definition
23:37:07 <pumpkin> xpika: I thought that's part of the standard? don't see why it wouldn't
23:37:09 <Olathe> > let splitWith :: (a-> Bool)->[a]->[[a]] splitWith f x = let pair=(span f x) in (fst pair):(splitWith f (snd pair) ) in splitWith
23:37:10 <lambdabot>   Not in scope: type variable `a'Not in scope: type variable `a'Not in scope:...
23:37:22 <Olathe> > let splitWith :: (a-> Bool)->[a]->[[a]]; splitWith f x = let pair=(span f x) in (fst pair):(splitWith f (snd pair) ) in splitWith
23:37:23 <lambdabot>       Overlapping instances for Show ((a -> Bool) -> [a] -> [[a]])
23:37:23 <lambdabot>        ari...
23:37:35 <Olathe> > let splitWith :: (a-> Bool)->[a]->[[a]]; splitWith f x = let pair=(span f x) in (fst pair):(splitWith f (snd pair) ) in splitWith ':' "test:test:test"
23:37:35 <lambdabot>   Couldn't match expected type `a -> Bool'
23:37:46 <Olathe> > let splitWith :: (a-> Bool)->[a]->[[a]]; splitWith f x = let pair=(span f x) in (fst pair):(splitWith f (snd pair) ) in splitWith (==':') "test:test:test"
23:37:47 <lambdabot>   ["","","","","","","","","","","","","","","","","","","","","","","","",""...
23:38:21 <Olathe> > span (==':') "test:test:test"
23:38:22 <lambdabot>   ("","test:test:test")
23:38:33 <Olathe> > span (/=':') "test:test:test"
23:38:34 <lambdabot>   ("test",":test:test")
23:38:36 <xpika> pumpkin: interactivly
23:38:41 <duryodhan> Olathe: ?
23:38:47 <duryodhan> Olathe: the type isn't matching
23:38:56 <duryodhan> Olathe: It would be ok if the correct answer didn't come
23:38:59 <Olathe> > let splitWith :: (a-> Bool)->[a]->[[a]]; splitWith f x = let pair=(span (not.f) x) in (fst pair):(splitWith f (tail $ snd pair) ) in splitWith (==':') "test:test:test"
23:39:00 <lambdabot>   ["test","test","test","* Exception: Prelude.tail: empty list
23:39:01 <duryodhan> but to me the type seems fine
23:39:41 <duryodhan> this is for http://book.realworldhaskell.org/read/functional-programming.html second exercise question
23:40:40 <Olathe> > let splitWith :: (a-> Bool)->[a]->[[a]]; splitWith f x = let (a, b)=(span (not.f) x) in a:if null b then [[]] else splitWith f (tail b) in splitWith (==':') "test:test:test"
23:40:42 <lambdabot>   ["test","test","test",""]
23:41:03 <Olathe> > let splitWith :: (a-> Bool)->[a]->[[a]]; splitWith f x = let (a, b)=(span (not.f) x) in if null b then [a] else a:splitWith f (tail b) in splitWith (==':') "test:test:test"
23:41:04 <lambdabot>   ["test","test","test"]
23:41:13 <Olathe> The type looks good.
23:41:36 <duryodhan> in the code I pasted ?
23:41:43 <Olathe> Yes.
23:42:12 <Olathe> It just had no semicolon between the type line and the definition line.
23:42:21 <Olathe> > let f :: a -> a f = id
23:42:21 <duryodhan> ohh ok
23:42:22 <lambdabot>   <no location info>: parse error on input `;'
23:42:27 <Olathe> Like that.
23:43:14 <duryodhan> ohh ok
23:43:18 <duryodhan> yeah sorry about that
23:43:25 <duryodhan> let me think .. its not working still .. but
23:43:26 <Olathe> Oh, it's no problem.
23:43:30 <duryodhan> I will manage something
23:43:35 <duryodhan> (hopefully :)
23:43:41 <Olathe> Alright :)
23:43:54 <BMeph> > let splitWith :: (a-> Bool)->[a]->[[a]]; splitWith f x = let (firstPair,secondPair)=(break f x) in if null firstPair then [] else (firstPair):(splitWith f (secondPair) ) in splitWith (==':') "test:test:test"
23:43:56 <lambdabot>   ["test"]
23:44:08 * BMeph FAILS
23:45:01 * bos uploads a new version of attoparsec that does incremental parsing
23:45:48 <Saizan> cool
23:46:01 <BMeph> > let splitWith :: (a-> Bool)->[a]->[[a]]; splitWith f x = let (firstPair,secondPair)=(break f x) in if null firstPair then [] else (firstPair):(splitWith f (tail secondPair) ) in splitWith (==':') "test:test:test"
23:46:02 <lambdabot>   ["test","test","test"* Exception: Prelude.tail: empty list
23:46:17 <BMeph> Woot! Crash and burn.
23:46:41 <Olathe> It's almost there.
23:46:41 <BMeph> Well, look at the time, I need to sleep - see you in 6 hrs...
23:46:43 <pumpkin> @google "1 attoparsec"
23:46:44 <lambdabot> No Result Found.
23:46:45 <Saizan> bos: what do you think about adding some combinators from parsec? in a .Combinator module maybe
23:46:47 <pumpkin> :(
23:46:55 * BMeph salutes...and collapses.
23:46:58 <pumpkin> @google 1 attoparsec
23:47:00 <Olathe> @src break
23:47:04 <lambdabot> http://everything2.com/e2node/attoparsec
23:47:04 <lambdabot> Title: attoparsec@Everything2.com
23:47:04 <lambdabot> break p =  span (not . p)
23:47:08 <bos> Saizan: many parsec combinators are already present in a .Combinator module
23:47:16 <Olathe> Ahh, yes, break > span
23:47:32 <pumpkin> bos: is it a complete reimplementation of parsec or an adaptation of it to bytestrings?
23:47:43 <bos> a complete reimplementation.
23:47:47 <pumpkin> awesome
23:48:02 <Saizan> bos: ah, i was still looking at 0.6, thanks :)
23:48:06 <bos> parsec3 already has bytestring support, but i think that attoparsec should be a lot faster.
23:48:08 <pumpkin> what causes some packages to not have docs on hackage?
23:48:18 <pumpkin> like attoparsec
23:48:51 <Saizan> the documentation is produced in a batch process
23:48:59 <pumpkin> oh, I see
23:50:47 <sjanssen> Unix micro-shell in about half an hour :)
23:50:50 <sjanssen> haskell++
23:51:26 <pumpkin> sjanssen: ?
23:51:26 <Axman6> @karma Haskell
23:51:26 <lambdabot> Haskell has a karma of 46
23:51:31 <Axman6> @karma haskell
23:51:31 <lambdabot> haskell has a karma of 46
23:51:40 <pumpkin> Axman6++
23:51:48 <Axman6> @karma
23:51:48 <lambdabot> You have a karma of 3
23:51:52 <Axman6> whoot!
23:51:53 <sjanssen> pumpkin: I easy it is to write a little shell in Haskell
23:52:12 <pumpkin> sjanssen: ooh
23:52:13 <sjanssen> support for ; && || and | took only about 30 minutes
23:52:24 <sjanssen> s/I easy/I wanted to see how easy"
23:52:28 <pumpkin> nice, mcilroy would be proud
23:52:44 <pumpkin> :)
23:53:13 <Axman6> sjanssen: would be nice if there were a shell as powerful as bash written in haskell
23:53:22 <sjanssen> most of that time was remembering what you're supposed to do when a piped-to process exits
23:53:35 <sjanssen> Axman6: that's a whole other kettle 'o fish
23:53:41 <pumpkin> I want a shell _in_ haskell
23:53:47 <pumpkin> I mean, the language should be haskell
23:53:57 <pumpkin> with a "prelude" of standard unix utility-like things
23:54:03 <pumpkin> which you can >>= between etc.
23:54:05 <sjanssen> oh, I also didn't write an syntax: test = (true `Seq` false) `Or` true `And` (yes "Haskell is great!" `Pipe` head')
23:54:15 <Raevel> pumpkin: you can write it!!
23:54:26 <pumpkin> Raevel: too busy with real work :(
23:54:33 <Raevel> quit!
23:54:39 <sjanssen> where true, false, yes, head' are wrappers around the proper commands
23:54:41 <pumpkin> Raevel: I asked for it :P
23:55:04 <duryodhan> cheap question .. just learning haskell ... whaddya all think of the code at http://www.mibbit.com/pb/GgpPaf  ?
23:55:40 <pumpkin> duryodhan: the spacing is a little odd :)
23:55:49 <Axman6> very odd
23:55:58 <pumpkin> duryodhan: also, have you seen byorgey's split package on hackage?
23:56:04 <pumpkin> it's got lots of split options!
23:56:26 <duryodhan> spacing in the otherwise part ? ... welll I got confused so decided to use spaces lft and right ..
23:56:34 <duryodhan> and the code is for http://book.realworldhaskell.org/read/functional-programming.html
23:56:48 <duryodhan> using that package would miss the point of the exercise
23:56:53 <pumpkin> duryodhan: oh, I see :)
23:57:02 <duryodhan> although thanks .. the package might come in handy
23:57:09 <Axman6> urgh! i'm so pissed off, i have no idea what, if anything i changed in my program to make it around 7 times slower. i don't remember making any changes at all!
23:57:22 <duryodhan> I am curious .. is there a better way to write the program ?
23:57:28 <pumpkin> Axman6: is it still generating bogus numbers?
23:57:41 <pumpkin> duryodhan: probably possible without explicit recursion
23:57:43 <Axman6> pumpkin: this is my non STUArray version
23:57:48 <pumpkin> ah :/
23:58:26 <pumpkin> I make a point of giting everything into my github account when I start on anything larger than random small tests
23:58:36 <duryodhan> pumpkin: wats implicit recursion ?
23:58:41 <pumpkin> duryodhan: I mean, using one of the higher order functions :)
23:58:54 <pumpkin> although in this case, maybe just an unfoldr :P
23:58:58 <vegai> was there in the standard libs a getChar that returns immediately after the first key has been pressed?
23:59:09 <duryodhan> pumpkin: yeah .. fold hasn't been taught yet
23:59:22 <vegai> @hoogle IO Char
23:59:22 <lambdabot> Did you mean: :: IO Char /count=20
23:59:22 <lambdabot> No results found
23:59:29 <vegai> @hoogle :: IO Char
23:59:29 <lambdabot> Prelude getChar :: IO Char
23:59:29 <lambdabot> System.IO getChar :: IO Char
23:59:29 <lambdabot> System.IO hGetChar :: Handle -> IO Char
23:59:32 <duryodhan> but I thought about it .. based on my rusty lambda calculus knowledge ...  but decided against it ..
23:59:43 <vegai> oh well, gotta see how darcs does it
23:59:53 <pumpkin> vegai: what does getChar do?
23:59:54 <Raevel> duryodhan: implicit recursion is when you do not explicitly make a recursive call to you function, but use other recursive higher-order functions
