00:00:12 <cads> especially in the united states
00:00:25 <newsham> sure, but you can learn haskell without approaching it like a mathematician.
00:00:38 <newsham> you dont have to know what equational reasoning is to appreciate it, for example
00:01:32 <Workybob> I really don't think it's the maths or formalisms they're afraid of
00:01:39 <cads> I feel like programmers are used to procedural reasoning rather than deeper logical inference rules
00:01:51 <Workybob> I think it's the "something new" aspect – these guys pride themselves on knowing everything about programming
00:02:02 <Workybob> and functional programming forces them to say "oh shit, I know nothing about this bit"
00:02:08 <cads> hm
00:02:09 <newsham> sure, people who have a large investment in other languages will be frustrated at how little their previous experience carries over
00:02:42 <newsham> but I dont think its necessarily any harder to approach things the haskell way
00:02:46 <newsham> its just different.
00:03:19 <cads> different than what is taught from gradeschool about computer programming
00:03:40 <newsham> someone with a phd in french literature wont be able to use a lot of his prior skills in tackling chinese, but there are a lot of young children who speak chinese just fine
00:03:49 <pumpkin> hmm, if I do +RTS -N5, I instantly get 400% cpu usage but it looks like the program's doing very little, however -N4 behaves as I would expect, occasionally getting around 160-180% cpu usage
00:03:53 <pumpkin> (I have 4 cores)
00:04:15 <cads> I believe that in the future when programming becomes a true engineering field, programmers will regularly use proof carrying code to effortlessly wield unimaginably complicated mathematical machinery
00:04:42 <cads> in the short term we have the core explosion opening people's ears to functional programming
00:05:28 <newsham> yup. but currently programmers expect crafting a program to be easier than engineering (perhaps only slightly harder than writing a recipe or authoring a web page)
00:05:39 <cads> but on that front too i think we'll continue to dither with stopgap measures to allow multicore programming in mainstream language, take cilk
00:05:49 <newsham> engineering requires a lot of background knowledge, study and discipline
00:06:13 <cads> yeah
00:06:59 <newsham> someday we (as a society) will stop pretending programming is supposed to be easy.
00:07:04 <cads> which is what it takes right now to get to a point where you're wielding monads comfortably and effectively
00:07:31 <cads> i've been reading haskell papers for about six months and I'm still lost :D
00:09:09 <cads> I'll quote someone though
00:09:48 <cads> "if we compare the state of software building against modern engineering - such as the building of the Empire State Building in New York City from scratch in less than one year with less than 3000 coordinated workers - then we can hardly claim "software engineering" to be much past ancient Egyptian pyramid building: millions of lines of code-bricks piled on top of each other with little coordination or discernable architecture."
00:10:31 <cads> that's unduly harsh, perhaps
00:10:40 <erikc> its true
00:11:06 <cads> that's alan kay on the subject, btw
00:12:24 <erikc> in game development, the pyramid only has to stand for a millisecond so you can take a snapshot of it, then it topples back down :)
00:12:30 <cads> the empire state building might have a thousandth of the mass of a pyramid, but is thousands of times more useful.
00:12:44 <erikc> most of my coworkers stop immediately upon seeing non-algol syntax, they dont even get to semantic differences between languages
00:13:14 <hiredman> the major change between ancient egypt and now is the materials used
00:13:47 <cads> hiredman: engineering crept into each and every single component of the structure
00:13:54 <hiredman> makes engineering a very interesting metaphor for computer programming
00:15:09 <cads> take the glass, its manufacturing complex that allows us to have glass, take the rubber insulation, the chemistry we needed to learn for that.. the insight to put the glass into a dual pane arrangement for efficiency
00:15:32 <cads> if you think about all the basic research needed for that sort of thing
00:15:43 <cads> well I think we do see the same thing in computing
00:16:23 <hiredman> glass while used in modern buildings, is not used structurally
00:16:24 <cads> all the work done by the fathers of computing, the branches of maths developed, the formalisms, the engineering of electronics
00:16:32 <newsham> a metaphor is a foggy window.  sometimes its unclear and inappropriate, and if you stretch it too far it breaks.
00:16:41 <hiredman> the main thing is steal or concrete
00:17:30 <hiredman> newsham:  I am trying to figure out if he meant something by what he said, or he just wannted to say something that sounded profound
00:18:02 <cads> I meant that if you take any one component, it has been engineered at an extremely profound level
00:18:19 <hiredman> not really
00:18:50 <cads> with the steel it's the fact that it took us thousands of years to understand the metalurgy, and that there is immense profoundly engineered infrastructure that allows us to have the steel
00:18:52 <hiredman> jesus, I was looking at a set of plans the other day, and someone left out the door to the mens bathroom
00:19:18 <cads> hehe
00:19:31 <cads> one sec and lemme show you something that will have you chuckling
00:19:38 <hiredman> damn architects
00:20:28 <cads> http://photofile.ru/photo/fishki_net/3667506/81977817.jpg
00:20:34 <cads> hehe
00:21:08 <hiredman> yeah
00:24:22 <newsham> http://www.thenewsh.com/~newsham/x/art/project-scoping.jpg
00:25:47 <cads> : )
00:26:47 <cads> I feel like right now rather than being the engineers, us programmers are the poor mooks that have to climb around on a precariously tall structure with rivet guns
00:27:31 <newsham> if something falls, its not the programmers who usually get hit on the head.
00:27:33 <newsham> its the end user
00:30:06 <daf> true that
00:36:46 <cads> I hate this trend we see now on the internet viewing development as the act of programming a blank sheet of paper to be the next killer app
00:39:52 <cads> there's something about us that has to put everything that's broken outside of the box into a bigger box, never realizing that boxes will break, and rather than trying to contain and harness what it is that keeps trying to break out, we should nurture it for its own sake
00:40:52 <cads> you know i think it just might be that hour of the night when I try to be profound rather than going to sleep
00:41:17 <cadZzZ> gnight all
00:42:52 <Gracenotes> map (map succ) (words ["yes", "no", "maybe"])... a natural transformation of sorts, perhaps? :)
00:43:02 <Gracenotes> (s/fmap/map as appropriate)
00:43:14 <Gracenotes> er, s/map/fmap/
00:43:18 <Gracenotes> :)
00:43:54 <Deewiant> > map (map succ) (words ["yes","no","maybe"])
00:43:55 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
00:44:06 <Gracenotes> er, yeah, ignore words.
00:44:43 <Gracenotes> I'm not sure I could decide whether or not to 'word' a phrase or just use a list of words
00:46:38 <Saizan> i wish there was a nice way to have multiple parallel lexical scopes, rather than nested ones
00:48:29 <Saizan> ..which would double as do-notation for applicatives now that i think of it
00:50:24 <ivanm> with some people saying every now and again that map should be replaced with fmap, is the reason that the Functor class _doesn't_ call its function just plain "map" due to that contradicting the report?
00:51:15 <Saizan> that and the fact that both map and fmap are in the Prelude
00:51:35 <Gracenotes> > runIdentity $ do { a <- return (show 400); b <- return (length a); return (b*2) }
00:51:36 <lambdabot>   6
00:51:44 <ivanm> well, if the Functor function was plain "map", that wouldn't have been a problem
00:51:49 <Gracenotes> tad verbose, though..
00:52:13 <Saizan> Gracenotes: the fact that a is in scope in the body of b is what i want to avoid
00:52:26 <Gracenotes> hm
00:53:00 <Saizan> ivanm: ah, ok, it wasn't clear to me you were proposing to remove Data.List.map
00:53:12 <ivanm> nah
00:53:22 <Gracenotes> so two functions defined in parallel scopes don't know that the other exists?
00:53:23 <ivanm> I'm not proposing anything! :p
00:54:00 <Saizan> Gracenotes: "parallel scope" is a term i coined right now :)
00:54:10 <Saizan> Gracenotes: however yes, that's the point
00:54:52 <ivanm> Saizan: is that what happens when you `par` two functions? ;-)
00:55:41 <Saizan> it's like arrow notation
00:55:52 <Saizan> but wihout the inputs
01:01:56 <cadZzZ> do you guys know what language this is: "val id : ∀α. α → α = Λα. fn (x:α) => x " ?
01:03:23 <Facedown2> no
01:04:52 <Saizan> cadZzZ: looks like ML with explicit instantiation
01:05:21 <Saizan> cadZzZ: is it supposed to be a pratical language?
01:05:28 <Zao> And silly unicode syntax, apparently.
01:08:11 <m3ga> what version  of ghc introduced Text.Regex.Posix?
01:08:15 <cadZzZ> Saizan, I think you're right about it being ml with extra type annotation
01:11:36 --- mode: irc.freenode.net set +o ChanServ
01:12:20 <bastl> good morning evryone
01:12:23 <goalieca> doh, had sounds enabled on people joining / leaving.. damn netsplit made me deaf
01:13:24 <bastl> (how) can I load and apply functions of a known type at runtime? e.g. from a file 'functions.hs' !?
01:13:27 <fasta> unlines is an inverse operation to lines. It is?
01:13:33 <fasta> >  unlines $  lines $ "ABC\nDEF"
01:13:34 <lambdabot>   "ABC\nDEF\n"
01:14:10 <fasta> If it's an inverse operation, then what's the final \n doing there?
01:14:10 <bastl> > unlines $ lines == id
01:14:11 <lambdabot>   Couldn't match expected type `String' against inferred type `Char'
01:15:17 <Zao> fasta: The converse holds though.
01:16:00 <Saizan> bastl: use the hint package
01:16:44 <Zao> > lines . unlines $ ["ABC", "", "DEF", ""]
01:16:45 <lambdabot>   ["ABC","","DEF",""]
01:17:02 <Saizan> lines is not injective, so you can't have a proper inverse
01:20:32 <bastl> Saizan: thanks alot. exactly what i was looking for
01:29:03 <Workybob> is it possible to get cabal to ignore . files?
01:29:08 <Workybob> or more specifically, ._ files
01:29:27 <Workybob> it keeps erroring, because there's a ._myLib.cabal file there, and it doesn't know which to chose
01:29:54 <daf> it is possible
01:30:01 <daf> you get the cabal source code, and then you patch it
01:30:07 <Workybob> bugger
01:30:17 <daf> (and then you send the patch to the maintainers :P)
01:32:58 <fasta> Zao: but that's not what the documentation says or am I reading the documentation incorrectly?
02:01:40 <hugo___> hi
02:05:59 <blip> is proving a program correct with Proof assistants to hard because it is too computationally expensive?
02:10:32 <tjb> hpaste is down?
02:11:34 <goalieca> ?src and
02:11:35 <lambdabot> and   =  foldr (&&) True
02:14:09 <hugo___> i dont like haskell module system
02:14:10 <hugo___> :(
02:15:02 <hugo___> importing qualified should be the default, not the other way around :(
02:16:45 <Eelis> +1.
02:16:51 <taruti> Is there something funny with code.haskell.org? My ssh key doesn't seem to be working...
02:20:11 <Zao> fasta: Well, to be precise, it uses the word "operation", not "function".
02:21:00 <fasta> Zao: and is "inverse" for an operation defined?
02:21:57 <dancor> there is a simpler way to say   maybe Nothing (Just . f)   right
02:22:19 <dancor> there has to be bc Maybe is a Monad
02:22:49 <dancor> @type (>>=) :: Maybe
02:22:50 <lambdabot>     `Maybe' is not applied to enough type arguments
02:22:50 <lambdabot>     Expected kind `?', but `Maybe' has kind `* -> *'
02:22:50 <lambdabot>     In an expression type signature:
02:23:03 <fasta> > fmap (+1) Nothing
02:23:04 <lambdabot>   Nothing
02:23:11 <fasta> > fmap (+1) (Just 3)
02:23:12 <lambdabot>   Just 4
02:23:15 <dancor> ok
02:23:20 <dobblego> @type (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
02:23:21 <lambdabot> forall a b. Maybe a -> (a -> Maybe b) -> Maybe b
02:23:24 <dancor> @type fmap
02:23:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:23:32 <dancor> @type (<$>)
02:23:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:23:56 * beelsebob hates the fact that people learn about monads before functors and applicatives and miss out on all the beauty there
02:25:43 <dancor> do applicative and arrow functions both use somethingA
02:25:56 <beelsebob> not usually
02:26:15 <beelsebob> the only one I know of there is sequenceA, because someone went and declared sequence in a not-general-enough way
02:26:15 <mib_chnudo> @src Applicative
02:26:16 <lambdabot> class Functor f => Applicative f where
02:26:16 <lambdabot>     pure  :: a -> f a
02:26:16 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
02:26:32 <mib_chnudo> @instances Functor
02:26:33 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
02:26:46 <Axman6m> damn mibbit
02:27:00 <beelsebob> oh, they un-banned mibbit?
02:27:09 <Axman6m> i guess so
02:27:18 <Axman6m> i was on yesterday with it
02:28:10 <fasta> beelsebob: what's so beautiful about applicatives?
02:28:17 <Axman6m> http://stackoverflow.com/questions/411290/why-do-people-think-functional-programming-will-catch-on could do with some more insightful responses i think
02:28:24 <beelsebob> fasta: you get to write in lovely functional, applicative style
02:28:35 <beelsebob> plus, they're more general than monads
02:28:59 <tjb> I'm trying to fix a shiftR bug in Data.LargeWord, but am having type issues -- http://pastebin.com/d26812edb
02:29:03 <bling> is proving a program correct with Proof assistants to hard because it is too computationally expensive?
02:29:31 <kalven> Axman6m: haskellbots assemble?
02:29:38 <beelsebob> bling: no, it's too hard, because often it's very very difficult to actually find a proof for what you're doing
02:29:45 <beelsebob> or what you want to be doing rather
02:29:54 <fasta> beelsebob: how does do f<-readFile foo; bar f;zork f -- with order being relevant look like then?
02:30:40 <beelsebob> fasta: it doesn't – monads are more powerful than applicatives, that doesn't stop the fact that applicatives are more beautiful
02:30:46 <beelsebob> also, either that does something useless
02:30:50 <beelsebob> or you're programming with side effects
02:30:54 <beelsebob> and have thrown away FP
02:31:20 <beelsebob> (not denying Haskell is a nice imperative language though)
02:32:10 <fasta> beelsebob: oh, right, they are more general in a mathematical sense.
02:33:10 <beelsebob> yep
02:33:15 <fasta> beelsebob: also, you have not thrown away FP, since you are building actions, you are not actually executing them.
02:33:44 <beelsebob> fasta: that makes very little difference in my head – it's really an excuse to write an imperative program "awww, we're only building a side effecting action, not using it"
02:33:49 <beelsebob> the bottom line is that the runtime does use it
02:33:50 <Itkovian> I have checked out nobench and I am trying to compile with ghc 6.10.1. I fixed a few type things that needed an explicit type to check, but right now I am getting stuck on this: handle (const $ return []) (read `fmap` readFile "huppel")
02:34:02 <fasta> beelsebob: the run-time does lots of unsafe things ;)
02:34:03 <beelsebob> and while you don't get all the drawbacks of imperative programming, you do get a lot of them
02:34:07 <Itkovian> Any idea where to state the type explicitly?
02:34:16 <beelsebob> fasta: sure – doesn't make writing that program any nicer for the programmer
02:34:49 <beelsebob> Itkovian: well, what's in the file?
02:34:52 <fasta> beelsebob: ok, so do you have a compelling example for applicatives? I read at least one paper on them, but wasn't impressed.
02:34:56 <beelsebob> are they Integers? or Strings?
02:34:58 <beelsebob> or what?
02:35:10 <Itkovian> it fails during compilation, so it hardy does matter, I'd say
02:35:21 <beelsebob> fasta: parsing is a really nice example
02:35:27 <Itkovian> Can't I give a generic type?
02:35:36 <beelsebob> Itkovian: it needs to know what read function to use
02:35:42 <beelsebob> so that the rest of the program knows what type it's getting
02:35:45 <fasta> beelsebob: which library specifically?
02:35:51 <Itkovian> beelsebob: right.
02:36:13 <Itkovian> Dang, I recall something in RWH stating this now that you mention it ;-) Thx.
02:37:06 <Axman6m> oh lame, i was about to answer a stack overflow question, and they took the site down for maintinence >_<
02:37:13 <beelsebob> fasta: well, parsec is a stunning example of why monads are bad for it... take for example bracket matching (because it's tiny and can be done here) matchBrackets = const () <$> leftParen <*> matchBrackets <*> rightParen <|> empty
02:37:24 <beelsebob> that's *way* nicer and closer to the BNF than a monadic parser would be
02:38:57 <fasta> beelsebob: it's also way harder to debug.
02:39:16 <beelsebob> not at all
02:39:26 <beelsebob> it's much easier to use an algorithmic debugger on in fact
02:39:44 <beelsebob> monads are pretty much the biggest not-solved problem in debugging functional programs
02:39:54 <fasta> beelsebob: but algorithmic debuggers don't actually exist on e.g. Hackage.
02:40:14 <beelsebob> not on hackage, but sure they do – I wrote hat's current one
02:40:54 <fasta> beelsebob: Hat didn't compile for me, on over 4 occasions that I tried it.
02:40:57 <beelsebob> also, gah, stop making me think about this – my viva's in a month or so
02:41:01 <Saizan> why is that harder to debug than the equivalent monadic expression?
02:41:10 <beelsebob> Saizan: no idea
02:41:14 <beelsebob> I would say it's easier
02:41:18 <beelsebob> because there's no side effects to look at
02:42:05 <Saizan> well there are, or you'd be using function application instead of <*>
02:42:12 <fasta> beelsebob: so, I want to see what matchBrackets is matching in every recursive call.
02:42:14 <beelsebob> true true
02:42:24 <beelsebob> fasta: so use hat-observe :)
02:42:37 <fasta> beelsebob: hat doesn't work for non-H98.
02:42:45 <fasta> beelsebob: unless you fixed that.
02:42:58 <fasta> beelsebob: well, it supports some extensions, but not all the libraries.
02:43:03 <beelsebob> actually, it works for an odd overlapping set that doesn't cover quite all of H98, but also covers lots of things not in H98
02:43:04 <malcolmw> Hat handles a whole bunch of type-system extensions
02:43:23 <Saizan> could hat work on GHC.Core, rather than haskell source?
02:43:39 <beelsebob> Saizan: potentially, but no one's looked at it yet
02:43:46 <beelsebob> give me a research grant, and I'll be happy to look at it
02:43:48 <beelsebob> :P
02:43:48 <fasta> Well, I am not going to try Hat again, until someone shows that it indeed works, with screenshots, and an installation script :)
02:44:02 <malcolmw> Saizan: it certainly could, as demonstrated by YHC's internal hat-trace generator
02:44:17 <fasta> I tried trivial examples years ago, and indeed that worked, but for an actual application I ran into various limitations.
02:44:24 <Saizan> i mean, would it still be useful after all the mangling that happens to the Core
02:44:24 <malcolmw> Saizan: but the problem with core is that it is too far away from the user's original source code
02:45:19 <Saizan> maybe to -Onot core then :)
02:45:44 <beelsebob> Saizan: you still lose things like "is this an if, a guard, a case or a pattern match?"
02:45:50 <malcolmw> Saizan: even without optimisation, core loses too much of the original structuring
02:46:09 <beelsebob> potentially though, ghc-api could be used to write a different hat-trans
02:47:02 <malcolmw> although I have been pondering the idea of just keeping source references throughout core, then reconstructing src-level expressions directly when browsing, rather than when tracing
02:47:04 <beelsebob> fasta: of note, there's also budha for algorithmic debugging
02:47:04 <Saizan> malcolmw: Yhc.Core doesn't? or YHC's hat-trace has the same problems?
02:47:10 <bling> import Control.Monad.Prompt
02:47:15 <bling> where is it?
02:47:40 <fasta> beelsebob: and not under development anymore
02:47:41 <Saizan> ?hoogle Control.Monad.Prompt
02:47:41 <lambdabot> package MonadPrompt
02:47:50 <Saizan> ?hackage MonadPrompt
02:47:51 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MonadPrompt
02:47:51 <beelsebob> malcolmw: I guess that has associated problems with the user editing their source, in between tracing and viewing
02:48:49 * beelsebob runs off back to work
02:48:56 <Axman6m> @. hackage hoogle Control.Monad.Prompt
02:48:56 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/package MonadPrompt
02:48:57 <malcolmw> beelsebob: it would be possible to squirrel away the matching source code at compilation time - maybe even hide it inside the trace file!
02:49:01 <Axman6m> :)
02:53:53 <Axman6m> is http://stackoverflow.com/questions/433595/function-application-why-is-used-here#468654 clear? want tyo make sure it makes sense to someone else
02:58:02 <Axman6m> @users
02:58:02 <lambdabot> Maximum users seen in #haskell: 646, currently: 580 (89.8%), active: 18 (3.1%)
02:58:12 <Axman6m> oh no, we're sinking, abandon ship!
03:02:07 <RayNbow> @hoogle scanr1P
03:02:07 <lambdabot> No results found
03:08:26 <RayNbow> Prelude GHC.PArr> scanr1P (+) arr
03:08:27 <RayNbow> *** Exception: Prelude.scanr1P: not implemented yet
03:08:31 <RayNbow> oh great :p
03:08:44 <Axman6m> haha
03:09:02 <RayNbow> not that I can do any useful benchmarking...
03:09:08 <Axman6m> > scanr1 (+) [1..10]
03:09:10 <lambdabot>   [55,54,52,49,45,40,34,27,19,10]
03:09:16 <RayNbow> <-- 1 core machine :p
03:09:19 <Axman6m> o.O
03:09:27 <Axman6m> > scanr (+) 0 [1..10]
03:09:29 <lambdabot>   [55,54,52,49,45,40,34,27,19,10,0]
03:09:49 <RayNbow> Prelude GHC.PArr> scanl1P (+) arr
03:09:49 <RayNbow> [:1,3,6,10,15,21,28,36,45:]
03:09:51 <Axman6m> oh, i was thinking of scanl
03:09:53 <bling> > scanl (++) [[1,2,3],[4,5],[6]]
03:09:54 <lambdabot>       Overlapping instances for Show ([[[t]]] -> [[[t]]])
03:09:55 <lambdabot>        arising from...
03:10:02 <bling> > scanl (++) [] [[1,2,3],[4,5],[6]]
03:10:03 <lambdabot>   [[],[1,2,3],[1,2,3,4,5],[1,2,3,4,5,6]]
03:10:15 <bling> > scanr (++) [] [[1,2,3],[4,5],[6]]
03:10:16 <lambdabot>   [[1,2,3,4,5,6],[4,5,6],[6],[]]
03:10:30 <Axman6m> > scanl (+) 0 [1..100]
03:10:31 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
03:12:49 <pozic> What's the difference between quotRem and divMod?
03:13:04 <Axman6m> how they handle negative numbers
03:13:10 <bling> scanr (++) "" ["A","x","m","a","n","s","c","a","n","s","a","l","o","t"]
03:13:17 <bling> > scanr (++) "" ["A","x","m","a","n","s","c","a","n","s","a","l","o","t"]
03:13:18 <lambdabot>   ["Axmanscansalot","xmanscansalot","manscansalot","anscansalot","nscansalot"...
03:13:22 <Axman6m> > quotRem (-99) 10
03:13:23 <lambdabot>   (-9,-9)
03:13:36 <Axman6m> > divMod (-99) 10
03:13:38 <Gracenotes> @src tails
03:13:38 <lambdabot> tails []         = [[]]
03:13:38 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
03:13:38 <lambdabot>   (-10,1)
03:14:33 <Saizan> > scanr (:) "" "foo"
03:14:35 <lambdabot>   ["foo","oo","o",""]
03:14:37 <Axman6m> > scanr (,) 0 [1..10]
03:14:38 <lambdabot>       Occurs check: cannot construct the infinite type: b = (a, b)
03:14:39 <lambdabot>        Exp...
03:14:42 <Axman6m> bah
03:26:22 <bling> what are IORefs goo for?
03:26:23 <bling> http://www.haskell.org/ghc/dist/current/docs/libraries/base/Data-IORef.html
03:26:57 <yitz> bling: they keep state
03:27:07 <bling> are they mutable?
03:27:07 <bling> is it like clojure's refs?
03:27:18 <yitz> bling: they are mutable, yes
03:27:42 <yitz> bling: we usually try to avoid them. but they sure are handy when there is no other way.
03:27:45 <bling> main = do
03:27:45 <bling>   let a = newIORef
03:27:45 <bling>   let b = readIORef a
03:27:45 <bling>   print 10
03:27:50 <bling> why doesnt that work?
03:28:03 <bling> well they dont seem very functional/haskellish
03:28:44 <yitz> bling: do {a <- newIORef (10 :: Int); b <- readIORef a; print b}
03:30:08 <yitz> bling: if you stick modifyIORef a (+7) in there, it will print 17 instead.
03:30:13 <yitz> get the idea?
03:30:21 <dibblego> @src Writer
03:30:21 <lambdabot> Source not found. It can only be attributed to human error.
03:33:46 <bling> i see real mutable state
03:33:50 <bling> but in a monad ofc :)
03:34:20 <yitz> bling: yep, and not just any monad. It's IO.
03:34:34 <bling> and refs can never be made clean?
03:34:51 <bling> then
03:34:51 <bling> main = do
03:34:51 <bling>   a <- newIORef 10
03:34:51 <bling>   modifyIORef a (+7)
03:34:51 <bling>   b <- readIORef a
03:34:52 <bling>   return b
03:34:58 <yitz> bling: there's also the ST monad, which is a restricted form of the IO monad that only allows mutable state, not any of the other stuff that IO does.
03:35:12 <yitz> bling: clean?
03:35:16 <bling> main :: IO Integer
03:35:33 <yitz> bling: yeah, that works
03:36:50 <yitz> bling: usually the approach is that inside main, you read the value of an IORef and then pass it as a parameter to a pure function.
03:37:33 <yitz> bling: same approach for processing stuff you read from the real world, like the keyboard or a disk file.
03:37:46 <Gracenotes> a convenient way to do this from main, btw, is to use modifyIORef with other curried arguments
03:37:57 <try_it_soon> so haskell does well on multi cores? because it has builtin pallalization?
03:38:40 <yitz> try_it_soon: yes. built-in in two ways:
03:38:43 <Gracenotes> (kind of self-evident... er, hm)
03:39:39 <yitz> try_it_soon: one is that you can tell it to run Haskell threads on separate cores when possible (that's the less exciting way)
03:40:17 <yitz> try_it_soon: the other is that you can use `par` to give the runtime hints about parallelizing pure calculations
03:41:02 <try_it_soon> hm
03:41:20 <try_it_soon> how is this superior to perl ?
03:41:35 <Zao> try_it_soon: Everything is.
03:41:42 <yitz> try_it_soon: don't know about perl
03:41:56 <yitz> try_it_soon: dons has a nice blog post with an example.
03:42:00 <Zao> Last I looked at parallelism in perl, you had to fork or use the "hey lol we copy everything when you start a thread" threads.
03:42:01 <try_it_soon> I know of one java app at work, it runs on a 8 cpu box
03:42:14 <dever_> if i execute a command within haskell, i.e. say run firefox... then i close my haskell program, will the firfox process stay executing?
03:42:15 <try_it_soon> and it is going nuts, but 7 cpu are idle
03:43:01 <try_it_soon> want to see a top of it?  I blogged the top!
03:43:07 <yitz> @go dons parallel fibonacci
03:43:09 <lambdabot> No Result Found.
03:43:20 <yitz> hmm, anyone know where that is?
03:43:30 <sjanssen> dever_: probably.  How are you starting firefox?
03:43:59 <sjanssen> yitz: his blog just moved, see planet.haskell.org?
03:44:06 <dever_> sjanssen: i did it before cant remember, i have the code somewhere  but not on this machine
03:44:21 <try_it_soon> a haskell web broswer would be cool
03:44:27 <dever_> Zao: thats the way threads are created in nix by default
03:45:04 <sjanssen> dever_: no, threads do not use fork() in Unix
03:45:18 <sjanssen> threads and processes are separate mechanisms
03:45:23 <try_it_soon> http://2.bp.blogspot.com/_IHTxHOWRA6U/SUMSxETk-sI/AAAAAAAAAEM/tKuzVU9DEvY/s1600-h/write_smart_apps.JPG
03:45:30 <dever_> afaik, they do, they fork(), then exec()
03:45:35 <try_it_soon> I want to write apps somehow that dont do this
03:45:38 <try_it_soon> http://2.bp.blogspot.com/_IHTxHOWRA6U/SUMSxETk-sI/AAAAAAAAAEM/tKuzVU9DEvY/s1600-h/write_smart_apps.JPG
03:45:42 <sjanssen> dever_: no, you're thinking of processes
03:45:46 <yitz> there's this: http://haskell.org/haskellwiki/Fibonacci_primes_in_parallel
03:46:10 <try_it_soon> http://technoninja.blogspot.com/2008/12/write-smart-apps.html
03:46:39 <dever_> thats how threads are created though? you fork the process, then address for the newly created process, thus overwriting the copied page table
03:46:52 <Zao> Threading in Perl was never meant to be.
03:46:58 <yitz> dever_:  not in Haskell
03:47:11 <sjanssen> dever_: no, that isn't how it works.  Threads live in the same memory space in Unix
03:47:35 <try_it_soon> haskell I heard can handle 100,000 threads
03:47:38 <Zao> sjanssen: Assuming that you refer to posix threads, I assume?
03:47:44 <try_it_soon> but will those threads work accross 8 cores?
03:47:51 <yitz> try_it_soon: I think a lot more
03:47:52 <sjanssen> Zao: "in Unix"
03:48:04 <Zao> try_it_soon: Provided you slap the runtime with the right number of processors to use, yes.
03:48:07 <Zao> Unless that's automagical nowadays.
03:48:13 <try_it_soon> will haskell threads use 8 cores on a 8 core box?
03:48:19 <yitz> try_it_soon: yes
03:48:20 <quicksilver> yes, if you tell them to.
03:48:22 <dever_> yes, they share the same address space, and point to similar data, but its a copy of data for each fork, copied on write?
03:48:32 <quicksilver> dever_: No.
03:48:34 <try_it_soon> how do I tell the runtime [thats the vm right?] the right # of cores?
03:48:36 <Zao> Green threads will be spread out across the available OS threads.
03:48:38 <Zao> -N, isn't it?
03:48:39 <sjanssen> dever_: no, you're confusing processes with threads
03:48:39 <quicksilver> dever_: threads share data read/write
03:48:49 <dever_> hmm... my O.S. exam isnt going to go well so :D
03:48:49 <boegel> try_it_soon: +RTS -N<n>
03:48:50 <quicksilver> dever_: that's the difference between threads and processes, on a unix-like thread model.
03:48:54 <yitz> dever_: everything is immutable in Haskell, so nothing needs to be copied.
03:49:24 <try_it_soon> boegel: that is a ghc option?
03:49:25 <try_it_soon> wow
03:49:33 <sjanssen> dever_: man 2 fork vs. man pthread_create
03:49:36 <Zao> try_it_soon: If you use GHC, http://www.haskell.org/ghc/docs/latest/html/users_guide/using-smp.html#parallel-options
03:49:52 <yitz> try_it_soon: it's a runtime option. you can apply it to any executable compiled by ghc.
03:49:59 <boegel> try_it_soon: no, you compile your tool with -threaded, and then run the app with "+RTS -N8" at the end of the command
03:50:26 <boegel> yitz: doesn't the exec need to be compiled with -threaded? (or -threads, whatever)
03:50:58 <yitz> boegel: I think so, yes.
03:51:01 <boegel> k
03:51:02 <try_it_soon> wow
03:51:04 <tjb> I'm trying to use 'map (\x -> putStrLn(x)) xs' where 'xs :: [String]' in my main function, but am having problems
03:51:07 <tjb> any suggestions?
03:51:10 <try_it_soon> are most production apps compiled?
03:51:22 <try_it_soon> I thought ghci was like interpreted haskell
03:51:24 <sjanssen> tjb: you probably want mapM_
03:51:36 <tjb> sjanssen: ah, let me go check that out
03:51:39 <boegel> tjd: use "putStrLn x" instead of "putStrLn(x)"
03:51:54 <boegel> tjb: and what sjanssen said :)
03:52:04 <yitz> tjb: map putStrLn xs
03:52:12 <yitz> tjb: mapM_ putStrLn xs
03:52:15 <yitz> oops ^^
03:52:22 <try_it_soon> so when someone for example runs a happs webapp, they use the +RTs -N8 to have it use the 8 cores
03:52:26 <boegel> try_it_soon: ghci is more for exploring small expressions
03:52:30 <drdozer> mm, I don't seem to be getting profiling output
03:52:31 <tjb> boegel:  is the "putStrLn x" better style than "putStrLn(x)" ?
03:52:35 <try_it_soon> oh ok
03:52:55 <boegel> > putStrLn "foo"
03:52:57 <lambdabot>   * Exception: "<IO ()>"
03:53:02 <drdozer> ghc --make GraphNeighboursProb.hs -prof -auto-all -o graphNeighboursProb ; ./graphNeighboursProb +RTS -p --RTS testPGraph.tab 10
03:53:03 <sjanssen> tjb: "putStrLn(x)" is very much not typical Haskell style (and is a waste of parens)
03:53:09 <boegel> > take 3 [1..10]
03:53:10 <lambdabot>   [1,2,3]
03:53:15 <boegel> > take(3,[1..10])
03:53:16 <lambdabot>   Couldn't match expected type `Int'
03:53:25 <tjb> sjanssen: good to know.  thanks
03:53:27 <drdozer> this runs graphNeighboursProb but doesn't print out profile information when it terminates :(
03:53:38 <yitz> tjb: here you don't need the x at all - you just want the function putStrLn
03:53:38 <bastl1> seems my ghc has problems: http://pastebin.com/m3418b64b  The program is just "main = putStrLn "hi" "
03:53:44 <boegel> sjanssen: I didn't even know using parentheses is correct syntax :)
03:54:23 <bastl1> damn the module is not Main
03:54:25 <tjb> 'mapM_ putStrLn xs' works great, thanks
03:54:30 <bling> what si an algorithmic debugger?
03:54:33 <sjanssen> boegel: sure, application is (roughly) "EXP EXP", and parens are valid expressions
03:54:40 <tjb> boegel: is it that obvious that I'm a "c" programmer ;)
03:54:41 <yitz> bastl1: use --make
03:54:48 <boegel> sjanssen: ah, I see
03:54:53 <bling> and i think monads ease debugging, what do you mean beelsebob when yous ay biggest unsolved problem?
03:55:13 <boegel> tjb: I coded almost exclusively in C the last 2 years two, and have only recently returned to Haskell
03:55:13 <bastl1> yitz: also true
03:55:24 <boegel> tjb: and now I keep wondering what the hell I was thinking using C :P
03:55:48 <yitz> bastl1: ghc --make -o hcc -i../bnfc/java Hcc.hs
03:56:11 <tjb> boegel: haha, I understand.  "Problem" is that I work mostly in embedded or hardware design, so haskell isn't used much on the production platforms :)
03:56:27 <boegel> tjb: time to change that!
03:56:46 <boegel> tjb: on thing with Haskell is that it's harder to control the actual memory usage for example...
03:56:48 <drdozer> ah, my bad - I was looking for output in the terminal not in a file
03:56:52 <tjb> boegel: that would be nice -- but so is a paycheck :)
03:56:59 <boegel> tjb: but, the code is a lot easier to understand a few weeks later
03:57:34 <try_it_soon> boegel: the plan9 people told me that a decent process model removed the process threaf dichotomy
03:57:44 <try_it_soon> thread that is
03:57:56 <tjb> boegel: I find haskell makes me think about the code/algorithm/problem more than when I code in C
03:58:19 <tjb> boegel: so I am learning to do my algorithm prototyping in haskell first
03:59:27 <quicksilver> try_it_soon: sure. They're probably right. But there is a different between sharing memory and not sharing it, and we need a name for these things.
03:59:37 <quicksilver> try_it_soon: those of us used to unix use the convenient shorthands.
03:59:41 <boegel> tjb: true also, yes
04:00:14 <yitz> try_it_soon: the runtime is not a full-blown vm. your code is compiled to native machine code, but some of the support code it needs (memory management etc.) is generic.
04:00:22 <Badger> is Data.Time nonstandard?
04:00:46 <try_it_soon> yitz: for ghc yes?
04:01:12 <yitz> Badger: Data.Time is standard. System.Time is deprecated, but only sort of, a lot of stuff still needs it
04:01:24 <yitz> try_it_soon: yes, ghc
04:01:25 <Badger> how odd
04:01:36 <yitz> Badger: why?
04:02:06 <Badger> oh, someone's trying to compile something and getting Coul not find module Data.Time
04:02:09 <Badger> *Could
04:02:30 <quicksilver> they don't have extralibs installed then.
04:02:50 <Saizan_> ?hoogle Data.Time
04:02:51 <lambdabot> module Data.Time
04:02:51 <lambdabot> package time
04:02:51 <lambdabot> Data.Time.LocalTime data TimeOfDay
04:02:51 <quicksilver> apt-get install libghc6-time-dev on a real OS
04:02:57 <quicksilver> for other OSes, YMMV.
04:03:28 <Saizan_> cabal install time :)
04:03:47 * quicksilver is not entirely clear if it's recommend to use cabal install for the extralibs
04:03:52 <quicksilver> isn't that risking version skew?
04:03:57 <try_it_soon> http://2.bp.blogspot.com/_IHTxHOWRA6U/SUMSxETk-sI/AAAAAAAAAEM/tKuzVU9DEvY/s1600-h/write_smart_apps.JPG  I want to program so this does not happen!  is it me or would this app run just as fast on a 1 cpu box?
04:04:14 * quicksilver tries to stick the versions of extralibs which go with his ghc version.
04:04:41 <quicksilver> try_it_soon: why do you keep reposting that URL?
04:04:48 <try_it_soon> want some response
04:04:56 <try_it_soon> doesnt it look crazy
04:04:59 <quicksilver> try_it_soon: we've told you how to write haskell apps to use multiple cors.
04:05:03 <try_it_soon> ok
04:05:06 <quicksilver> we're not interested in your java app.
04:05:12 <try_it_soon> sorry wrogn channel
04:05:31 <quicksilver> indeed :)
04:07:06 <bremner> try_it_soon: feel free to convert it to haskell, then we're interested :-). Also, maybe better SMP performance :-)
04:07:22 * Badger overuses IORefs viciously.
04:07:41 <quicksilver> and less RedunctFactoryRedundancyFactoryFactories, too.
04:07:42 <fasta> Why don't we have lambdabot auto-blast spammers?
04:08:14 <Badger> lambdabot is not a tool of destruction :P
04:08:23 <quicksilver> giving ops to a bot is not a decision to be taken lightly
04:08:23 <fasta> It could be!
04:08:30 <quicksilver> it immediately makes them a target for exploits
04:08:31 <yitz> @slap Badger
04:08:31 * lambdabot throws some pointy lambdas at Badger
04:08:50 <fasta> @kill yitz
04:08:51 <lambdabot> Maybe you meant: keal kind tell
04:09:02 <fasta> It misses an important feature.
04:09:19 <Badger> yitz: ow.
04:09:52 <fasta> quicksilver: people are putting guns on robots too, so a kick in an IRC channel is not that weird.
04:10:06 <quicksilver> I didn't say it was weird.
04:10:12 <quicksilver> I said it was a decision not to be taken lightly.
04:10:24 <quicksilver> I am in plenty of IRC channels which have operator bots.
04:10:29 <quicksilver> But this isn't one, as it happens.
04:10:34 <yitz> fasta: you would need to invest a lot of careful design and testing to make it safe.
04:10:40 <Badger> LambdaServ
04:10:47 <quicksilver> and I personally don't want to take the responsibility for making lb safe enough for that to be useful.
04:11:04 <quicksilver> and then go to the trouble of trying to find an algoritm which detects a 'spammer'
04:11:09 <quicksilver> without false positives.
04:11:14 <quicksilver> That's work I'm not interested in doing.
04:11:21 <quicksilver> If someone else wants to do it, and it works well, sure
04:11:25 <quicksilver> this is a loquacracy after all.
04:11:49 <fasta> quicksilver: I didn't know you were into lambdabot development.
04:12:23 <yitz> quicksilver: or an algorocracy
04:13:13 <quicksilver> fasta: I'm not.
04:13:22 <quicksilver> fasta: although I've glanced at the code once or twice.
04:13:51 <quicksilver> what I'm saying is "what you've suggested is not stupid, but neither is it easy. Someone would have to do it. That someone is not me. If someone wants to volunteer, I won't stand in their way."
04:14:26 <quicksilver> Although I will block the notion of giving lambdabot ops until someone has made reasonable endeavours to make that safe.
04:14:50 <Raevel> the admin auth system sure isn't safe at least :-P
04:15:03 <fasta> Also, it might not even be that interesting. It would be better to do client-side filtering.
04:15:23 <fasta> The only thing one loses with spammers is some bandwidth.
04:16:18 <quicksilver> Yes.
04:16:24 <quicksilver> and we don't really have a big problem with spammers, IMO.
04:16:30 <yitz> fasta: this channel has plenty of manual labor available at all hours of the day, we don't really need automation for the occasional boot.
04:16:39 <quicksilver> I kick around one person per day, and I think that's probably more than ayone else.
04:17:01 <daf> the thing one loses with spammers is attention
04:17:07 <daf> the bandwidth costs are small in comparison
04:17:43 <yitz> daf: yes, spammers are indeed harmful. but they get promptly booted from here without automation.
04:18:05 <daf> indeed
04:18:16 <drdozer> I've got a datatype with deriving (Show)
04:18:37 <drdozer> it is complaining: No instances for (Eq (ID n), Eq (ID e), Eq (NodeID e))
04:19:02 <yitz> drdozer: sounds like you need to provide those instances
04:19:19 <yitz> drdozer: are those your own typeclasses?
04:19:31 <drdozer> yitz: they are my own indexed types
04:19:42 <fasta> daf: I was assuming client-side filtering.
04:20:37 <quicksilver> drdozer: deriving doesn't work for all cased of indexed types, AFAIK.
04:20:42 <quicksilver> but I can't explain that precise error
04:20:47 <yitz> drdozer: so you're using your datatype in a context where those instances are required. sounds like the compiler has a legitimate complaint.
04:20:48 <quicksilver> why would a Show derivation ask for an Eq instance?
04:22:08 <drdozer> quicksilver, my bad - it's wanting both Eq and Show, since I derive both
04:22:15 <HappyGuy75> can anyone tell me how necessary learning the details of lambda calculus is to understanding Haskell fully?
04:22:48 <drdozer> yitz: would it not just add an instance of e.g. Show that is guarded by e.g. Show (ID n) => ...
04:24:43 <koeien> HappyGuy75: it's not. I don't know the details, and I pretty much understand Haskell
04:24:52 <koeien> but, define "fully" :)
04:25:08 <koeien> if you know Haskell, lambda calculus should be easy to grasp, /me thinks
04:25:42 <yitz> drdozer: no, I don't think so, as quicksilver said.
04:25:54 <HappyGuy75> well, so I know the language in depth and aren't stumped when someone mentions its relationship to lambda calculus
04:26:17 <HappyGuy75> I guess starting with lambda calculus is a bit dry...just wondering if I'm wasting my time.
04:26:36 <koeien> I wouldn't start with lambda calculus. at least I didn't when learning the language
04:26:38 <HappyGuy75> Do you need it to understnad the advanced features like monads and arrows etc?
04:26:42 <yitz> HappyGuy75: if you know both, the relationship is pretty obvious. If you know only one, it helps you learn the other, but it's not required
04:27:05 <koeien> HappyGuy75: arrows not really. monads: yes, you will need them and encounter them
04:27:33 <koeien> but, lambda calculus isn't really helping, I think
04:27:45 <HappyGuy75> yes, I know I'll use monads, but will I need lambda calculus to understnad them? No?
04:27:47 <yitz> koeien: lambda calculus was pretty happy for 60 years before people started using modads in FP
04:28:09 <Gracenotes> there are many neat lambda calculus things you can do in plain Haskell, but it's not really required.
04:28:11 <koeien> yitz: sure...
04:28:27 <Adamant> grraaah
04:28:39 <koeien> but I wouldn't start with LC if you want to learn FP or Haskell (but that's me, some might find it interesting :))
04:28:41 * yitz rubs his ears
04:28:59 <Gracenotes> at least not explicitly. I learned about monads before I learned about the lambda calculus in depth, and I found the lambda calculus easy after some Haskell
04:29:01 <HappyGuy75> \me
04:29:14 <koeien> yitz: I meant, "knowing LC" won't really impact your understanding of monads, I think
04:29:17 <Adamant> there's a programming language conference in driving distance with Haskellers there and I didn't find out about it until today
04:29:36 <Adamant> today's the second day
04:29:42 <Adamant> of three
04:29:47 <HappyGuy75> is there a REALLY easy tutorial on LC available?
04:30:13 <yitz> @go alligator eggs
04:30:20 <lambdabot> http://worrydream.com/AlligatorEggs/
04:30:20 <lambdabot> Title: Alligator Eggs!
04:30:54 <koeien> yitz: lol! very nice
04:31:30 <elbar> @go project euler problem 12
04:31:32 <lambdabot> No Result Found.
04:31:35 <Gracenotes> HappyGuy75: it's easier to learn Haskell first, I think :)
04:31:39 <elbar> typical ;)
04:32:03 <HappyGuy75> ok, thanks people.
04:32:38 <Saterus> so @go does a google search and pulls the first result? or something else?
04:32:52 <Gracenotes> hm. maybe I should write up a tutorial-like thing about implementing Church numbers, etc. in Haskell
04:33:22 <quicksilver> Saterus: that's what it does, roughly. It sometimes appears to fail and I don't know why ;)
04:34:41 <elbar> the 2nd link would have been the one i had in mind :P
04:35:15 <koeien> wargh C#
04:37:18 <scanz> hi
04:37:44 <yitz> hi scanz
04:38:54 <pejo> Adamant, there isn't that much haskell in the presentations though
04:40:20 <scanz> http://privatepaste.com/74xsyAus5c i get the error "possibly incorrect intendation" what does that mean?
04:40:58 <koeien> scanz: are you sure your parentheses are correct?
04:41:12 <koeien> i think you miss a few
04:41:58 <ski_> `Rectangle -> ...' has six opening brackets, but only four closing ones
04:42:15 <koeien> i wouldn't write if ... then ... else ...  by the way, but use guards (but that's a style issue)
04:42:28 <koeien> ski_: i was too lazy to count, but you're right :)
04:42:37 <ski_> (`Circle -> ...' has six opening brackets, but only five closing ones)
04:43:13 <koeien> a decent editor will highlight the matching parentheses.
04:45:30 <Saterus> a decent editor would be emacs or vi/m? anything else for haskell development?
04:46:22 <quicksilver> Saterus: sure. Lots of people use emacs and vim.
04:46:37 <yitz> quicksilver: in fact most people, I think
04:46:40 * quicksilver personally find emacs + kurbias-indentation makes haskell editing mostly a pleasure.
04:47:02 <yitz> quicksilver: kurbias?
04:47:14 <quicksilver> @where kuribas-indentation
04:47:15 <lambdabot> http://kuribas.hcoop.net/haskell-indentation.el
04:47:21 <quicksilver> with apologies for my inability to type.
04:47:56 <yitz> quicksilver: never mind - you at least seem to have a wonderful ability to indent.
04:48:21 <quicksilver> ;)
04:48:35 <koeien> ;)
04:48:39 <quicksilver> I do, for which I thank kuribas, who never seems to come here these days.
04:48:40 <yitz> quicksilver: how does it interact with standard haskell-mode?
04:48:50 <quicksilver> perfectly well, IME.
04:48:57 <quicksilver> just turn off the haskell-mode's indentation stuff
04:49:01 <quicksilver> and turn this one on instead
04:49:08 <yitz> quicksilver: how do you do that?
04:49:11 <quicksilver> other features like C-c C-l are unaffected.
04:49:16 <koeien> i use vim but more out of habit then anything else. is it worth my time to learn emacs for haskell?
04:49:23 <artemgr> Can somebody help me to create a haskell.org wiki account?
04:49:38 <Axman6> koeien: have you installed the vim haskell mode?
04:49:45 <dolio> Vim is prefectly fine for Haskell.
04:49:45 <quicksilver> yitz: personally, I use "'(haskell-mode-hook (quote (turn-on-haskell-doc-mode turn-on-haskell-decl-scan (lambda nil (haskell-indentation-mode)))))"
04:49:50 <artemgr> I've been kind of "invited" to edit it: http://article.gmane.org/gmane.editors.yi.devel/2790
04:49:53 <koeien> Axman6: no, just regular debian installation
04:49:53 <johnnyfreak> hi all
04:49:59 <quicksilver> yitz: in my custom-set-variables clause
04:50:09 <quicksilver> yitz: there may be better ways :)
04:50:24 <quicksilver> and also '(max-lisp-eval-depth 900)
04:50:27 <Axman6> koeien: well try it out, it's rather nice
04:50:34 <koeien> Axman6: I will
04:50:35 <quicksilver> because it's recdescent parser and it uses more than normal eval depth sometimes.
04:50:55 <koeien> i'll miss the handy vim commands in Emacs
04:51:04 <yitz> "lambda nil..."? wow, I've been really spoiled by haskell.
04:51:13 <quicksilver> Yeah.
04:51:19 <quicksilver> functons and symbols are different in elips
04:51:25 <chessguy_work> 'morning
04:51:31 <quicksilver> I don't really understand, I just get it working and then stop.
04:51:37 <johnnyfreak> can someone help me defining a non recursive function parSum (x:xs) = map sum E replacin E with an expression and with parSum [x1..xn] = [W1, ..., Wn] with Wi = x1 + ... + xi ?
04:52:42 <chessguy_work> johnnyfreak, umm.....i think i can, once i understand what you're trying to do
04:52:57 <chessguy_work> johnnyfreak, can you give an example inpupt/output?
04:52:59 <yitz> quicksilver: there should be a wiki page for all of the valuable hacks you just gave me
04:53:09 <chessguy_work> or give a little context for what you're trying to do
04:53:10 <Axman6> johnnyfreak: scanl1 (+) i think
04:53:23 <Axman6> > scanl1 (+) [1..10]
04:53:25 <lambdabot>   [1,3,6,10,15,21,28,36,45,55]
04:53:27 <koeien> > scanl1 (+) [1..4]
04:53:28 <lambdabot>   [1,3,6,10]
04:53:57 <quicksilver> yitz: this is the appropriate page, I guess : http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs
04:54:02 <Axman6> scanl is just fold l, but building a list of the accumulators right?
04:54:04 <quicksilver> yitz: you could add anything you thought relevant to there.
04:54:08 <johnnyfreak> yes but i must use map sum E
04:54:09 <koeien> Axman6: right
04:54:15 <quicksilver> Axman6: it's all the partial results of the foldl, in a sense
04:54:21 <koeien> @src scanl1
04:54:22 <lambdabot> scanl1 f (x:xs) =  scanl f x xs
04:54:22 <lambdabot> scanl1 _ []     =  []
04:54:24 <yitz> @quote homework
04:54:24 <lambdabot> Tac-Tics says: We also had a professor who spoke Chinese as his primary language. He mistyped "Pumping lemma" as "pumping lamma" and the entire semester, we just drew pictures of llamas with
04:54:24 <lambdabot> dumbbells on our homework
04:54:37 <koeien> @src scanl
04:54:37 <lambdabot> scanl f q ls = q : case ls of
04:54:37 <lambdabot>     []   -> []
04:54:37 <lambdabot>     x:xs -> scanl f (f q x) xs
04:54:54 <yitz> @where homework
04:54:54 <lambdabot> I know nothing about homework.
04:55:03 <Workybob> gyah
04:55:08 <Axman6> heh
04:55:10 * Workybob slaps whoever made mapM monadic
04:55:18 <chessguy_work> @type scanl
04:55:19 <Axman6> @remember lambdabot I know nothing about homework.
04:55:19 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
04:55:19 <lambdabot> It is stored.
04:55:25 <koeien> Workybob: that is kind of the point?
04:55:47 <yitz> @go haskell homework help
04:55:50 <lambdabot> http://www.haskell.org/haskellwiki/Homework_help
04:55:50 <lambdabot> Title: Homework help - HaskellWiki
04:55:55 <Workybob> mapA = (fmap . fmap) sequence map; sequence = foldr liftA2 (pure []) -- koeien
04:55:57 <yitz> there it is
04:55:59 <Workybob> nothing monadic about it
04:56:01 <Workybob> it's applicative
04:56:16 <koeien> Workybob: monads predate applicative iirc, in Haskell at least
04:56:23 <Workybob> koeien: yeh, I know
04:56:35 <Axman6> yeah geez Workybob
04:56:40 <chessguy_work> johnnyfreak, you're still going to have to give some more information. and we're not going to give you the answer, but we'll help you with it
04:56:49 <Workybob> still, *submits another revision to the Haskell' mailing list*
04:59:05 <quicksilver> Workybob: argubaly the observation that mapM works over a wider class of things than monad is the *exact* observation which motivate applicative.
04:59:09 <johnnyfreak> ok
04:59:15 <Workybob> quicksilver: indeed
04:59:16 <scanz> thanks for your help
04:59:16 <johnnyfreak> ive done it recursively
04:59:20 <scanz> have to go now
04:59:22 <scanz> cya
04:59:26 <johnnyfreak> now using scanl1 it's very simple
04:59:34 <quicksilver> (although the example used in the paper is sequence not mapM, but that's not really any different)
04:59:35 <Axman6> ?users
04:59:35 <lambdabot> Maximum users seen in #haskell: 646, currently: 596 (92.3%), active: 18 (3.0%)
04:59:46 <johnnyfreak> but i must begin the definition with "map sum "
04:59:49 <Axman6> 4 more users! 4 more users!
05:00:14 <chessguy_work> @type scanl (f::[a]->[a]) []
05:00:16 <lambdabot>     Couldn't match expected type `b -> [a]' against inferred type `[a]'
05:00:16 <lambdabot>       Expected type: [a] -> b -> [a]
05:00:16 <lambdabot>       Inferred type: [a] -> [a]
05:00:25 <mornfall> Axman6: For what?
05:00:29 <koeien> > map sum (inits [1..5])
05:00:30 <lambdabot>   [0,1,3,6,10,15]
05:00:35 <mornfall> Axman6: 600? : - )
05:00:36 <johnnyfreak> if i do parSum xs = map sum [] ++ scanl1 (+) [1..10]
05:00:40 <Axman6> yup :)
05:00:41 <Axman6> again
05:00:42 <chessguy_work> @type scanl1
05:00:44 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
05:00:46 <koeien> johnnyfreak: that's cheating :)
05:00:55 <mornfall> Axman6: Isn't it more like 104 more users to get to 700? : - ))
05:01:02 <johnnyfreak> yep
05:01:03 <Workybob> quicksilver: what I'm actually discovering rather nicely in all of this is that dealing with errors is not monadic at all
05:01:04 <chessguy_work> @users
05:01:05 <lambdabot> Maximum users seen in #haskell: 646, currently: 598 (92.6%), active: 18 (3.0%)
05:01:06 <koeien> ?users
05:01:07 <lambdabot> Maximum users seen in #haskell: 646, currently: 598 (92.6%), active: 18 (3.0%)
05:01:08 <Axman6> let's not get too hasty!
05:01:09 <Workybob> it all fits nicely into applicative
05:01:16 <Axman6> two more...
05:01:22 <Axman6> seems to peak around now
05:01:33 <Axman6> an hour or two ago, it was 580
05:01:35 <quicksilver> Workybob: well, applicative is a more general framework for error handling, because it can keep going despiate certain kinds of error.
05:01:46 <quicksilver> Workybob: so you can report more than one thing at once
05:01:49 <Workybob> quicksilver: you mean monad?
05:01:54 <quicksilver> yes
05:01:56 <Workybob> yep
05:02:03 <quicksilver> monads have to stop when the fail
05:02:05 <quicksilver> (in a sense)
05:02:13 <quicksilver> applicatives can keep going to some extent.
05:02:17 <Workybob> hang on, *tries to understand what you're saying*
05:02:19 <Workybob> oh, yeh
05:02:23 <Workybob> I see what you're on about
05:02:25 <Workybob> that makes sense
05:02:31 <quicksilver> for example, make your error type a Monoid
05:02:38 <quicksilver> and you can accumulate a bunch of them
05:02:39 <chessguy_work> @hoogle (a -> b) -> a -> (a,b)
05:02:39 <lambdabot> Control.Monad.Writer.Class listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
05:02:41 <Workybob> so yay, that's another thing to throw on the "traditionally made wrongly monadic" pile
05:02:48 <Workybob> quicksilver: indeed
05:02:53 <chessguy_work> @pl \f x -> (x, f x)
05:02:53 <lambdabot> ap (,)
05:02:55 <quicksilver> you should be able ot write (Monoid e) => Applicative (Either e)
05:02:57 <quicksilver> I think.
05:03:21 <chessguy_work> @type iterate (ap (,))
05:03:23 <lambdabot>     Occurs check: cannot construct the infinite type: b = (a, b)
05:03:23 <lambdabot>       Expected type: (a -> b) -> a -> b
05:03:23 <lambdabot>       Inferred type: (a -> b) -> a -> (a, b)
05:05:32 <Saizan> with (Monoid e) => Applicative (Either e) any error prevents you to produce a result, but you can collect all of them
05:05:38 <chessguy_work> ([a] -> [a]) -> [a] -> [([a],[a])]  @hoogle (a -> a) -> a -> [(a,a)]
05:05:39 <lilac> johnnyfreak: you want parSum [x1,x2,x3,...,xn] = [x1, x1+x2, x1+x2+x3, ..., x1+...+xn]. so what list do you want to give to 'map sum'?
05:05:47 <chessguy_work>  @hoogle (a -> a) -> a -> [(a,a)]
05:05:52 * chessguy_work sighs
05:06:01 <chessguy_work> it's going to be a long day
05:06:06 <chessguy_work> @hoogle (a -> a) -> a -> [(a,a)]
05:06:07 <lambdabot> Control.Monad.Writer.Class listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
05:06:11 <johnnyfreak> lilac: thank for advice, i thinking to it
05:06:55 <chessguy_work> @type unfoldr
05:06:56 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
05:07:05 <chessguy_work> !!
05:07:13 <Saizan> ?type ap zip tail . iterate ?f ?a
05:07:14 <lambdabot>     Couldn't match expected type `a -> [a1]'
05:07:14 <lambdabot>            against inferred type `[a2]'
05:07:14 <lambdabot>     In the second argument of `(.)', namely `iterate ?f ?a'
05:07:22 <Saizan> ?type ap zip tail . iterate ?f
05:07:23 <lambdabot> forall a. (?f::a -> a) => a -> [(a, a)]
05:08:02 <chessguy_work> @hoogle unfold
05:08:03 <lambdabot> Data.Tree unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
05:08:03 <lambdabot> Data.Tree unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
05:08:03 <lambdabot> Data.Tree unfoldForestM_BF :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
05:08:14 <chessguy_work> i think the unfold pattern is what i was looking for
05:08:17 <chessguy_work> @hoogle+
05:08:18 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
05:08:18 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
05:08:18 <lambdabot> Data.ByteString.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
05:08:46 <chessguy_work> @hoogle+
05:08:46 <lambdabot> Data.ByteString.Lazy unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
05:08:46 <lambdabot> Data.ByteString.Lazy.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
05:08:46 <lambdabot> Data.ByteString unfoldrN :: Int -> (a -> Maybe (Word8, a)) -> a -> (ByteString, Maybe a)
05:09:07 <gal_bolle> does emacs' haskell-mode have a bugtracker?
05:09:30 <chessguy_work> gal_bolle, i don't think it's very actively developed
05:09:51 <jeffz`> gal_bolle: usually the modes have a maintainer
05:10:09 <gal_bolle> chessguy_work: is there an equivalent that's actively developped?
05:10:15 <chessguy_work> gal_bolle, though i do seem to recall the maintainer being on -cafe, so you might ask there
05:10:22 <johnnyfreak> lilac: i must add elemento to elementi [x1, x2, ..., xn] to [0, x1, x1+x2, ..., x1+..+xn] but how can i create suc list?
05:10:22 <chessguy_work> gal_bolle, none i know of
05:10:26 <gal_bolle> ok
05:11:05 <chessguy_work> johnnyfreak, what would be the type of the function you want to write?
05:11:26 <johnnyfreak> (Num a) => [a] -> [a]
05:11:30 <gal_bolle> i'll state my wish anyway, (maybe yi does it already…): hitting tab with a selected region should indent the first line and move the following lines of the region accordingly (indent them all by the same amount))
05:11:48 <lilac> johnnyfreak: what will 'map sum [[a,b,c], [d,e,f], [g,h,i]]' give?
05:13:11 <johnnyfreak> i can't think a non imperative way to see it ( i'm a beginner inhaskell )
05:13:13 <chessguy_work> @src unfoldr
05:13:14 <lambdabot> unfoldr f b  = case f b of
05:13:14 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
05:13:14 <lambdabot>    Nothing        -> []
05:14:24 <johnnyfreak> lilac: [a+b+c,d+e+f, g+h+i]
05:16:09 <lilac> johnnyfreak: right. what list do you need to give to 'map sum' to get [x1, x1+x2, x1+x2+x3]?
05:18:39 <johnnyfreak> lilac: [[x1],[x1+x2],..,[x1+...+xn]] == [(take 1 xs), (take 2 xs), ... (take n xn)]
05:18:55 <ski_> > map sum [[a,b,c], [d,e,f], [g,h,i]]  -- hm-hm
05:18:57 <lambdabot>   [0 + a + b + c,0 + d + e + f,0 + g + h + i]
05:19:19 <Workybob> Saizan: it doesn't stop you using catch :: Monoid e => (Either e a) -> (e -> Either e a) -> Either e a
05:19:40 <koeien> johnnyfreak: you mean [[x1], [x1,x2], .., [x1,..,xn]], but otherwise you're right
05:19:54 <Workybob> catch (Left e) handler = handler e; catch x _ = x
05:19:55 <lilac> johnnyfreak: ok, good. [take 1 xs, take 2 xs, ..., take n xs] can be produced by a 'map'.
05:20:05 <lilac> johnnyfreak: do you see how?
05:20:15 <johnnyfreak> let'try
05:21:01 <johnnyfreak> koeien yes
05:21:37 <ski_> (johnnyfreak : yes, `let'-`try' is interesting)
05:21:52 <njbartlett> Hi, I don't know if this has been noted already but there's a Haskell job advert on one of the UK's biggest job sites
05:21:59 <njbartlett> http://www.jobserve.com/WC9CB6F88EDEC913E.jsjob
05:22:00 <Axman6> :o
05:22:00 <koeien> woot
05:22:03 <johnnyfreak> sky_ sorry for my english... "let's try"
05:22:09 <Workybob> @src trace
05:22:10 <lambdabot> trace string expr = unsafePerformIO $ do
05:22:10 <lambdabot>     hPutStrLn stderr string
05:22:10 <lambdabot>     return expr
05:22:26 <johnnyfreak> ski_ sorry for my english... "let's try"
05:22:34 <ski_> johnnyfreak : oh .. i thought you were refering to exceptional syntax
05:23:02 <johnnyfreak> ski_ no sorry
05:23:33 <chessguy_work> so when people talk about different "front ends" for yi, they basically just mean keybindings?
05:23:57 <pao> hi all :-)
05:24:06 <Axman6> not sure. i know you can get a Cocoa front end for OS X
05:24:34 <Saizan> Workybob: sure, i was reflecting on to which extent the applicative let you "keep going"
05:24:52 <johnnyfreak> lilac: i can't figure out how to change the "index"
05:24:54 <Plouj> so, Qt is hard in Haskell?
05:25:27 <ski_> (`let'-`try' <http://martin.jambon.free.fr/extend-ocaml-syntax.html#lettry>)
05:25:38 <njbartlett> Plouj: Define "hard"
05:26:23 <Plouj> no, I'd rather have someone tell me how it's like to program Qt in Haskell
05:27:05 <Axman6> Gtk is probably easier
05:27:47 <dolio> There's no nice Qt wrapper for Haskell.
05:28:12 <dolio> There are some bindings, but it's not particularly ideal.
05:28:49 <Plouj> does gtk2hs work with gtk2?
05:28:57 <SamB> indeed
05:29:14 <SamB> I can never figure out if gtk2hs refers to gtk2 or just gtk, though ;-P
05:29:39 <lilac> johnnyfreak: ok. in the result of 'map' there'll be bits that stay the same and bits that change.
05:30:16 <lilac> johnnyfreak: in [take 1 xs, take 2 xs, ..., take n xs], the 'take (something) xs' stays the same, and the (something) changes
05:30:30 <johnnyfreak> lilac yes
05:30:35 <lilac> johnnyfreak: (something) is 1, then 2, ... then n
05:30:55 <johnnyfreak> lilac ok
05:31:20 <chessguy_work> @hoogle (b -> Maybe (a,b)) -> b -> b
05:31:21 <lambdabot> Data.ByteString.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
05:31:21 <lambdabot> Data.ByteString.Lazy.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
05:31:21 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
05:31:59 <Axman6> johnnyfreak: i think i thought of another way to write that thing, map sum . inits
05:32:13 <Axman6> > map sum . inits $ [1..10]
05:32:14 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55]
05:32:19 <Axman6> whoot
05:32:30 <chessguy_work> @hoogle (a -> Maybe (a,a)) -> a -> a
05:32:31 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
05:32:48 <johnnyfreak> map sum . drop 1 inits $ [1..10]
05:33:42 <dolio> Is there a reason we've been working for like 3 pages to make this algorithm less efficient?
05:34:08 <chessguy_work> what algorithm
05:34:15 <dolio> The partial sums.
05:34:19 <johnnyfreak> Axman6 i want to understand lilac's method, so i can improve my "functional" way to think
05:35:15 <dolio> tail . scanl (+) 0 is more efficient than map sum . drop 1 . inits
05:35:28 <dolio> And the former was (essentially) proposed initially.
05:35:30 <Itkovian> Plouj: there is a brief intro on what used to be gtk2hs in the monad reader iirc
05:35:44 <johnnyfreak> but i must use map sum first ...
05:35:50 <johnnyfreak> i have to
05:35:57 <Itkovian> Plouj: http://www.haskell.org/sitewiki/images/9/9d/TMR-Issue1.pdf
05:36:02 <dolio> Oh, is it an assignment?
05:36:09 <johnnyfreak> yes
05:36:11 <dolio> That says "you must use map sum"?
05:36:16 <chessguy_work> @type let g f x -> case f x of Nothing -> x; (Just y') -> g f (f x) in g
05:36:18 <dolio> Okay, that answers my question, then.
05:36:18 <lambdabot> parse error on input `->'
05:36:31 <johnnyfreak> yes non recursive and startin with map sum
05:37:04 <mib_ee37rgbp> hi
05:37:43 <tromp__> >  tail . scanl (+) 0 [3,6,2]
05:37:44 <lambdabot>   Couldn't match expected type `a -> [a1]'
05:37:44 <dcoutts> Workybob: we'd appreciate a patch to ignore .cabal files that begin with a . eg ._foo.cabal
05:37:55 <tromp__> >  tail $ scanl (+) 0 [3,6,2]
05:37:57 <lambdabot>   [3,9,11]
05:38:22 <tromp__> >  map sum $ map (:[])  $ tail $ scanl (+) 0 [3,6,2]
05:38:24 <lambdabot>   [3,9,11]
05:38:32 <tromp__> there, solutions starting with map sum
05:38:42 <Workybob> dcoutts: I'll have a poke later, I'm just working round it for the mo – btw, am I right in making an assumption that gtk2hs currently doesn't work with recent versions of gtk
05:38:46 <tromp__> and efficient
05:38:59 <dolio> Heh.
05:39:04 <Workybob> I'm getting a type error in Cairo that could easily be explained by a change to the API that would make no diff in C land, but makes the difference in Haskell land
05:39:12 <Workybob> i.e. something that no longer returns (), but CInt instead
05:39:59 <dcoutts> Workybob: the IO () vs IO CInt return type? yes, that's a change in the cairo C api in 1.8
05:40:05 <lilac> johnnyfreak: (sorry for the delay, got called away)
05:40:20 <dcoutts> Workybob: I think the darcs version has been updated, you might try that
05:40:20 <mlesniak> What is the :set - option such that ghci does not show which libraries are loaded? (A hint where to find this in the documentation would be much nicer, btw ;-))
05:40:36 <johnnyfreak> lilac: thank for helping me
05:40:36 <lilac> johnnyfreak: [take 1 xs, take 2 xs, ... take n xs] has 'take <n> xs' fixed and <n> varying
05:40:50 <Workybob> dcoutts: okay, I may or may not poke that – it'll probably take quite a bit of fiddling to link with all my mac ports bits, so I may live with the nasty VM hack I have just now
05:40:52 <mib_ee37rgbp> can somebody help me in PM - its about countdown problem and eval function
05:41:10 <ski_> mib_ee37rgbp : why not here in channel ?
05:41:10 <lilac> johnnyfreak: we want <n> to be 1, then 2, ... then n
05:41:16 <mib_ee37rgbp> much text^^
05:41:16 <Workybob> dcoutts: but bug report for you – the mac ports version currently doesn't build, because MacPorts installs a newer version of Cairo than it should do
05:41:20 <johnnyfreak> lilac [1..n]
05:41:38 <pao> does there exists a library that combine the performance benefits of ByteString with UTF8 encoding? is the utf8-string library my best candidate?
05:41:39 <lilac> johnnyfreak: exactly.
05:42:01 <lilac> johnnyfreak: map f [1..n] gives us [f 1, f 2, ..., f n]
05:42:18 <SamB> mib_ee37rgbp: paste it to moonpatio.com
05:42:25 <mib_ee37rgbp> hm - i´ve given 2 versions of evan and must find out why the 2nd eval version sux more then the first^^
05:42:33 <ski_> @where hpaste2
05:42:33 <lilac> johnnyfreak: so you want a function which takes <n> and gives back 'take <n> xs'
05:42:34 <lambdabot> http://moonpatio.com:8080/
05:42:58 <johnnyfreak> lilac a minute to write this
05:43:26 <Workybob> @instances Traversable
05:43:27 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
05:43:39 <Workybob> @instances-importing Data.Traversable Traversable
05:43:39 <lambdabot> Maybe, []
05:43:44 <Workybob> bugger
05:44:21 <lilac> hmm, isn't ByteString traversable?
05:44:33 <Axman6> @instances-importing Data.Tree Traversable
05:44:33 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
05:44:46 <Workybob> @instances-importing Data.IntMap Traversable
05:44:46 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
05:44:50 <Workybob> that's the one I want
05:44:54 <Axman6> guess trees aren't traverable
05:45:01 <Axman6> traversable*
05:45:04 <Workybob> should be implementable using toList and fromList
05:45:05 <Workybob> but ugly
05:45:34 * ski_ forgets what's needed to implement `Traversable'
05:46:11 <Workybob> traverse :: Applicative f => (a -> f b) -> t a -> f (t b) isn't it?
05:46:48 <quicksilver> toList/fromList would lose the tree's shape.
05:47:01 <quicksilver> I thought there was a traversable instace for Data.Tree in the stdlib somewhere.
05:47:12 <Workybob> quicksilver: I was talking about IntMap, not Tree
05:47:18 <Workybob> in which case I don't care about the shape
05:47:20 <quicksilver> oh, sorry.
05:47:47 <Saizan> @instances-importing Data.Tree Data.Traversable Traversable
05:47:48 <lambdabot> Maybe, Tree, []
05:47:59 <Saizan> in fact there is :)
05:48:17 <johnnyfreak> lilac: if i define "f n = take n" it has type f:: Int -> [Int] -> [Int], so "map (take) [1..n]" gives me [take 1, ..., take n], Am i wrong?
05:48:56 <lilac> johnnyfreak: you're right. but you want each value to be 'take n xs' not just 'take n'
05:48:58 <drdozer> if I'm deleting a list of keys from a map, would I want 'foldl M.delete' or 'foldr M.delete'?
05:49:37 <drdozer> @src foldl
05:49:37 <lambdabot> foldl f z []     = z
05:49:37 <johnnyfreak> lilac: mmm, you're right :(
05:49:38 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
05:49:54 <lilac> johnnyfreak: you're very close, though.
05:49:55 <drdozer> @src foldr
05:49:55 <lambdabot> foldr f z []     = z
05:49:55 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:50:14 <drdozer> so foldr?
05:50:27 <chessguy_work> @type take
05:50:29 <lambdabot> forall a. Int -> [a] -> [a]
05:50:51 <chessguy_work> (for the record, take is polymorphic, not Int -> [Int] -> [Int])
05:51:23 <bling> what do you think? should webservers use threads or processes?
05:51:31 <SamB> :t take :: Int -> [Int] -> [Int])
05:51:33 <lambdabot> parse error on input `)'
05:51:42 <ski_> @type \f -> fix $ \loop (Node a ts) -> Node `liftA` f a <*> Data.Traversable.traverse loop ts
05:51:43 <lambdabot> forall t a (f :: * -> *). (Applicative f) => (t -> f a) -> Tree t -> f (Tree a)
05:51:44 <SamB> bling: I dunno, should they ?
05:51:50 <SamB> :t take :: Int -> [Int] -> [Int]
05:51:52 <lambdabot> Int -> [Int] -> [Int]
05:52:22 <dolio> > tail . reverse . map sum . tails . reverse $ [1..10]
05:52:23 <lambdabot>   [1,3,6,10,15,21,28,36,45,55]
05:52:55 <dolio> > tail . reverse . map sum . tails . reverse $ []
05:52:57 <lambdabot>   []
05:53:07 <pao> @seen koninkje
05:53:07 <lambdabot> koninkje has changed nick to koninkje_away.
05:53:07 <lambdabot> koninkje_away is in #haskell. I last heard koninkje_away speak 7h 30m 24s ago.
05:53:13 <Workybob> @importing Data.Map Data.Traversable Traversable
05:53:13 <lambdabot> Unknown command, try @list
05:53:21 <Workybob> @instances-importing Data.Map Data.Traversable Traversable
05:53:22 <lambdabot> Map k, Maybe, []
05:53:27 <Workybob> ah, bugger
05:53:33 <Workybob> so IntMap just got forgotten
05:54:08 <johnnyfreak> what $ stand for?
05:54:20 <ski_> @src $
05:54:20 <lambdabot> f $ x = f x
05:54:22 <SamB> Workybob: do yourself a favour and forget about it yourself ;-P
05:54:26 <ski_> function application
05:54:30 <Workybob> SamB: hmm?
05:54:30 <dolio> Workybob: Someone wrote into the libraries mailing list requesting such an instance not longa go.
05:54:34 <chessguy_work> > let f = case True of { True -> 1; False -> 0; } in f
05:54:36 <lambdabot>   1
05:54:39 <ski_> > (tail . reverse . map sum . tails . reverse) []
05:54:40 <lambdabot>   []
05:54:44 <SamB> Workybob: IntMap is ALWAYS forgotten
05:55:01 <Workybob> SamB: sure – but why – does it have no benefit over Map Int?
05:55:07 <SamB> I dunno
05:55:11 <elbar> > [k * (k+1) `div` 2 | k <- [1..10]]
05:55:13 <lambdabot>   [1,3,6,10,15,21,28,36,45,55]
05:55:21 <SamB> but it does not have parity
05:55:25 <SamB> feature-wise
05:55:28 <dolio> It's definitely faster than Map Int.
05:55:35 <dolio> If that's what you care about.
05:56:00 <SamB> they really should keep the interface following Map better ...
05:56:46 <elbar> i'm still searching for that triangle number that has more than 500 hundred divisors ;)
05:56:47 <ski_> module interfaces would enforce this
05:57:45 <SamB> ski_: hmm. Maybe.
05:58:45 <elbar> -00 btw ;)
05:59:04 <chessguy_work> ugh, this is going to irritate me all day
05:59:12 <bling> what do you think? should webservers use threads or processes?
05:59:18 <chessguy_work> trying to figure out the right pattern for this function
05:59:24 <quicksilver> bling: I don't think that's relevant to #haskell.
05:59:35 <quicksilver> bling: it's not even relevant to webservers, really. It's an OS question.
05:59:51 <quicksilver> (Since thread and process have different technical meanings on different OSes)
06:00:08 <SamB> bling: also, you seem to have forgotten door number 3
06:00:08 <chessguy_work> @type fix
06:00:10 <lambdabot> forall a. (a -> a) -> a
06:00:33 <Saizan> wuth GHC you'd probably use its lightweight threads, however
06:01:01 <lilac> johnnyfreak: what would you get if you used 'f n = take n xs'?
06:01:08 <SamB> I suppose using GHC's threads is just a souped-up version of number 3 ...
06:01:14 <ski_> (chessguy_work : which function ?)
06:01:33 <chessguy_work> ski_ a resolution algorithm for propositional logic
06:01:47 <johnnyfreak> lilac i was thinking in something like "\x -> map (take [1..n]) x" but this is wrong
06:02:13 <SamB> bling: using GHC's threads *should* be more portable than using OS threads in C -- but probably isn't really all that much better in practice ...
06:02:37 <quicksilver> using GHC threads is more like having one thread in C and using select()
06:02:47 <chessguy_work> ski_ it's sort of an unfold/fixpoint thing, because at every step you're deriving new children, seeint if they have any contradictions, or if they're a subset of what you already know. if either of those are true, you stop, otherwise, you add them to what you know and start over
06:02:56 <quicksilver> unless you actually genuinely service concurrent requests
06:02:59 <SamB> I've heard that GHC's use of the POSIX-style IO interface on win32 messes stuff up ...
06:03:10 <quicksilver> ah, I've got no idea what it does under win32
06:03:23 <ski_> chessguy_work : each child is a possible world ?
06:03:27 <SamB> I don't precisely remember WHICH stuff it messes up, though
06:03:28 <quicksilver> programming on win32 is like swimming across the english channel.
06:03:34 <lilac> johnnyfreak: indeed. your 'same for each element bit' is "take n xs" (with n varying) and your 'elements' is [1..n]
06:03:36 <Badger> it has been done!
06:03:43 <quicksilver> Obviously it's possible and people have done it, but a boat is so much more convenient
06:03:45 <lilac> johnnyfreak: so you want "map (\n -> take n xs) [1..n]"
06:03:49 <edwardk> @seen ddarius
06:03:49 <lambdabot> I saw ddarius leaving #haskell, #haskell-blah and #haskell-overflow 6h 55m 5s ago, and .
06:03:52 <chessguy_work> ski_ each child is a new proposition derived from resolving two clauses in what you already know
06:04:08 <lilac> johnnyfreak: sorry, i used n twice there with different meanings
06:04:16 <lilac> johnnyfreak: so you want "map (\i -> take i xs) [1..n]"
06:04:25 <ski_> chessguy_work : but several children denote possible alternative worlds, yes ?
06:04:56 <chessguy_work> ski_ err, i don't think so
06:05:04 <bling> door number 3?
06:05:11 <lilac> > let xs = [a,b,c,d,e] in map (\i -> take i xs) [1..5] :: [[Expr]]
06:05:12 <ski_> chessguy_work : ok .. then why several children ?
06:05:13 <lambdabot>   [[a],[a,b],[a,b,c],[a,b,c,d],[a,b,c,d,e]]
06:05:15 <elbar> does anyone know the solution for this http://projecteuler.net/index.php?section=problems&id=12 ?
06:05:20 <chessguy_work> ski_ they're new facts about the same world, disovered from facts already known
06:05:54 <lilac> elbar: yes, thanks ;-)
06:06:12 <ski_> chessguy_work : i was thinking of having two facts `a -> b \/ c' and also `a', then one could add `b' in one child and `c' in the other
06:06:39 <johnnyfreak> lilac i wrote it badly but i understood the idea and reached it before your solution! thanks so much! thanks for your step by step teaching
06:06:51 <chessguy_work> ski_ ermm,  i'm doing forward-chaining
06:06:55 <ski_> (you might represent `a -> b \/ c' as `not a \/ b \/ c' ..)
06:06:57 <elbar> hmm...did i query you? if yes sorry
06:07:09 <ski_> chessguy_work : yes, i was talking about forward-chaining
06:07:24 <chessguy_work> so i wouldn't add b and c unless i knew both were true
06:07:37 <lilac> johnnyfreak: great, good luck learning haskell!
06:08:14 <chessguy_work> ski_ sorry, i'm probably thinking about this too rigidly
06:08:26 <ski_> if you know `b \/ c', then you can split the universe, and add `b' in one half, and `c' in the other (these are two branches in the tree, then)
06:08:31 <johnnyfreak> lilac thanks
06:08:37 <chessguy_work> pretty new to logical inference algorithms
06:08:41 <ski_> possibly you are modelling things differently
06:09:13 <ski_> (actually s/split/duplicate\/copy/)
06:09:43 <chessguy_work> ski_ well, i've been modelling known knowledge as a single sentence which is a conjunction of everything known
06:10:38 <chessguy_work> ski_ and then if i want to know whether or not x entails y, i try to find a contradiction in x /\ -y
06:10:41 <ski_> so what are you using the children for ?
06:10:49 <ski_> (as opposed to "child")
06:11:27 <lilac> > length $ filter ((==0).(12375 `mod`)) [1..12375]
06:11:29 <lambdabot>   24
06:12:06 <chessguy_work> ski_ so for every "iteration", i take every pair of clauses in x, and resolve them, then the results of all the resolutions are what i'm calling the "children"
06:12:23 <chessguy_work> ski_ then if any of the children are a contradiction, i return true
06:12:47 <johnnyfreak> see you, bye bye
06:12:48 <chessguy_work> ski_ if the children are a subset of x, then i return False (i.e., i've run out of new inferences that can be made)
06:13:05 <chessguy_work> ski_ otherwise, i recurse on x /\ (children x)
06:14:54 <chessguy_work> heh, actually, the code i have written (not on the computer) probably explains it better than i just did. maybe that means i should keep it as is :)
06:15:18 <ski_> ok
06:15:27 <chessguy_work> does that kind of make sene though?
06:16:20 <bling> what is the diff between rem and mod?
06:16:34 <dolio> > (-2) `mod` 3
06:16:36 <lambdabot>   1
06:16:38 <dolio> > (-2) `rem` 3
06:16:39 <lambdabot>   -2
06:17:00 <chessguy_work> bling, 3, apparently :)
06:17:25 <ski_> chessguy_work : you should probably implement differential/delta optimization (can't recall the name atm)
06:17:47 <chessguy_work> ski_ hmm. sounds interesting. what's the idea?
06:18:22 <ski_> at each step, instead of keeping `x', you keep `x_old' and `x_new'
06:18:48 <ski_> and then you combine every thing in `x_new', also combine between `x_old' and `x_new'
06:19:11 <ski_> but you don't combine things in `x_old' with other things in `x_old' (since you've already done that earlier)
06:19:13 <chessguy_work> ah, but not between x_old and x_new
06:19:22 <chessguy_work> err, not between x_old and x_old
06:19:23 <chessguy_work> yeah
06:19:39 <ski_> then `x_old ++ x_new' is the next `x_old' and the newly generated stuff is the next `x_new'
06:20:03 <chessguy_work> that makes sense
06:20:38 <chessguy_work> so each iteration will be faster
06:20:57 <ski_> this is a simple optimization that can give quite large improvments
06:22:50 <chessguy_work> ski_ i was thinking i should also note which clauses are horn clauses, and do a quick check of them first (since that can be done in linear time), to see if i can determine entailment just from them
06:23:21 <ski_> (chessguy_work : ok, one name for this optimization is "seminaive evaluation" ..)
06:23:37 <chessguy_work> lol
06:24:01 <quicksilver> Robinson!
06:24:04 <ski_> (but istr it's also been called "differential evaluation" or something similar)
06:24:12 <SamB> I take it that not using it is called "naive evaluation"?
06:24:13 <ski_> chessguy_work : can you derive new clauses ?
06:24:24 <ski_> SamB : yes :D
06:24:29 <chessguy_work> ski_ what do you mean?
06:24:32 <mib_4myoxw1s> Greetings my name is Xenia. I from Russia. Studying of English language is interesting to me. I can help with Russian studying. To whom interestingly write.
06:24:52 <ski_> chessguy_work : can new horn clauses be derived, as you derive new formulae ?
06:25:02 <quicksilver> mib_4myoxw1s: is studying of Haskell language interesting to you?
06:25:09 <quicksilver> because if so, you're inthe right place.
06:25:24 <chessguy_work> ski_ i don't recall the algorithm for horn clause entailment
06:25:26 <SamB> mib_4myoxw1s: or maybe you just like maths
06:26:13 <chessguy_work> ski_ i'm sure i can't guarantee that newly-derived clauses are horn clauses, if that's what you mean
06:26:16 <ski_> chessguy_work : i'm simply asking whether any of the newly derived formulae, during your resolution iteration process, might be horn clauses
06:26:27 <chessguy_work> sure, they could be
06:26:35 <SamB> chessguy_work: can you prove it ?
06:26:35 <ski_> ok
06:26:38 <mib_4myoxw1s> That means Haskell
06:26:56 <SamB> mib_4myoxw1s: what means Haskell?
06:26:58 <ski_> (otherwise you could separate the horn clauses from the other facts)
06:27:18 <pumpkin> preved!
06:27:32 <chessguy_work> ski_ i think there's a guarantee that horn clauses only produce horn clauses, but not so for other clauses
06:27:53 <vixey> SamB: What does haskell mean
06:28:25 <ski_> mib_4myoxw1s : might you be a "bot" ?
06:28:25 <chessguy_work> @all-dict haskell
06:28:27 <lambdabot> *** "haskell" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
06:28:27 <lambdabot> Haskell
06:28:27 <lambdabot>  
06:28:27 <lambdabot>         <language> (Named after the logician {Haskell Curry}) A {lazy}
06:28:27 <lambdabot>         {purely functional} language largely derived from {Miranda}
06:28:29 <lambdabot> [167 @more lines]
06:28:34 <SamB> heh
06:28:53 <chessguy_work> 170+-line definition?
06:29:01 <SamB> chessguy_work: probably just a lot of defs ?
06:29:02 <mib_4myoxw1s> I love mathematics. But here I search for the person to which interestingly mutual studying of a foreign language
06:29:26 <SamB> chessguy_work: most of them apparantly from Gazetteer
06:29:47 <SamB> er, well, maybe it actually is that long
06:30:04 <edwardk> elbar: note that your triangle numbers are just a sum of a range of integers so the nth is n(n+1)`div`2 or just scanl a running total, then compute the prime factors of that number. from the prime factors you can work out the # of divisors much more cheaply than by brute force.
06:30:49 <edwardk> elbar: i figure that leaves you enough legwork to keep it interesting ;)
06:31:26 <sbahra> alo edwardk
06:31:34 <edwardk> heya samy
06:35:09 <chessguy_work> edwardk, :)
06:35:36 <bling> heres my try at euler 12: http://cpp.ninjacodemonkeys.org/5056
06:35:55 <bling> it works correctly but is to slow for finding one with 500 divs, works for smaller though
06:36:02 <bling> anyone can give a tip?
06:36:04 --- mode: ChanServ set +o quicksilver
06:36:05 <chessguy_work> i'm actually surprised that will all the brilliant logic guys in here, we don't more implementations of classical logical inference on hackage
06:36:15 --- kick: mib_4myoxw1s was kicked by quicksilver (#haskell-russian-brides is over that way)
06:36:32 --- mode: quicksilver set -o quile
06:36:44 <vixey> :/
06:36:46 <quicksilver> chessguy_work: well, it's not something you need all that often.
06:36:51 --- mode: quicksilver set -o quicksilver
06:37:14 <chessguy_work> i guess, but it seems like a good space for haskell
06:37:17 <edwardk> bling: the key is what i mentioned above, calculate the prime factors, then work out the # of divisors from that, much cheaper
06:37:18 * quicksilver nods
06:37:35 <quicksilver> chessguy_work: true. I did an RA proect not entirely unrelated, but I did it in sml.
06:38:05 <edwardk> bling: right now you're paying O(n^2)
06:38:05 <chessguy_work> maybe classical logic is boring to these modern logic guys ;)
06:38:18 * vixey is in #haskell-russian-brides with mib
06:38:25 <SamB> heh
06:38:34 <chessguy_work> vixey, get a room! ...oh, you have one
06:39:24 <edwardk> wouldn't #haskell-english-brides be more appropriate?
06:39:26 <quicksilver> chessguy_work: but normally you're aiming to solve a particular sub problem or investigate one. I was deriving robinson proof nets corresponding to sequent proofs, and illustration cut reduction
06:40:06 <chessguy_work> um
06:40:07 <chessguy_work> ok
06:40:15 <edwardk> mail-order mathematicians
06:40:21 <quicksilver> the actual core part is, well, simple.
06:40:31 <quicksilver> a SAT solver might be more generally useful.
06:40:37 <quicksilver> ISTR dcoutts needs one for cabal ;)
06:40:56 <chessguy_work> quicksilver, yeah, an engine like what i'm building could be used for that
06:40:59 <quicksilver> ultimately cabal will become a universal command-line interface to NP problems.
06:41:06 <Workybob> anyone know what could be going on here? http://paste.lisp.org/display/74025
06:41:30 <quicksilver> Workybob: I think that's a cabal version problem. I could be wrong.
06:41:36 <edwardk> wouldn't NM8.hs be more appropriate?
06:41:54 <chessguy_work> ok, time to get to real work
06:42:06 <lupsyn> where can i find isbst function ? or a bst library in hs ?
06:42:07 <quicksilver> Ah, is htis a library of your construction as opposed to someone elses which is supposed to work?
06:42:16 <quicksilver> in that case I withdraw my comment.
06:42:19 <Workybob> quicksilver: it's of my construction, yes
06:42:23 <quicksilver> lupsyn: binary spanning tree?
06:42:27 <h0tzenpl0tz> hello, what modules do i need to look at to query amazon rest-services?
06:42:44 <Workybob> it's exposed-modules are NM8.Program.Graph and NM8.Program.Program
06:42:53 <lupsyn> yep quicksilver
06:43:01 <lupsyn> binary search tree
06:43:05 <quicksilver> h0tzenpl0tz: http://developer.amazonwebservices.com/connect/entry.jspa?externalID=1965 ?
06:43:16 <quicksilver> lupsyn: oh, search not spanning.
06:43:22 <quicksilver> lupsyn: what would "isbst" do then?
06:43:47 <edwardk> ah, that is a directory, i misparsed what i was looking at
06:43:55 <lupsyn> isbst :: BST a -> Bool
06:43:57 <h0tzenpl0tz> quicksilver: thanks, although it's specifically s3 i will take a look at it to get the basics
06:43:59 <lupsyn> with fold function
06:44:01 <Workybob> edwardk: yep
06:44:17 <edwardk> can you pull up the cabal file and paste it?
06:44:37 <bling> edwardk: how do you mean?
06:44:49 <vixey> lupsyn, when is a BST not a binary search tree?
06:44:53 <quicksilver> lupsyn: I don't really know what you're asking. If your BST is probably constructed that will always be 'True'
06:44:54 <Workybob> edwardk: http://paste.lisp.org/display/74025#1
06:45:04 <quicksilver> lupsyn: Data.Map is one flavour of binary search tree
06:45:11 <quicksilver> it doesn't give you explicit access to its internals though
06:45:16 <quicksilver> there are alternatives on hackage
06:45:20 <quicksilver> (AVLTree or somethign)
06:45:54 <bling> prime factors of 6 are 2 and 3
06:45:59 <bling> ok what cna i dow ith this
06:46:10 <vixey> andd them to get 6 again
06:46:25 <edwardk> bling: right now you iterate through all of the numbers up to x to compute the divisors for x. on the other hand if you note that x is composed of certain prime factors you can work out the # of divisors from that decomposition.
06:46:56 <fasta> malcolmw: I was so crazy to try Hat again, but I get this (this is after I solved one problem with hmake already (any sane software should be easy to build!)):  MkConfig: user error (Can't find ghc includes at /home/fasta/lib/ghc-6.10.1/./imports). If you say Hat exists, why not make it easy to install?
06:47:56 <malcolmw> fasta: I'd love to, but have not had time to work on it properly for years now
06:48:27 <fasta> malcolmw: then, you should just put a tag on it saying that it doesn't work, just like people that work on roads do when they dig a hole.
06:48:51 <malcolmw> fasta: maybe you are right
06:49:45 <edwardk> bling: group them to find out how many you have, find the # in each group, add one to it, and compute the product of the factors:
06:49:52 <edwardk> > product $ map ((+1) . length) . group $ [2,3]
06:49:53 <lambdabot>   4
06:49:59 <edwardk> 1,2,3,6
06:50:18 <elbar> edwardk: yes..done it with brute force =) but now lets switch on the brain ... ;)
06:51:38 <bling> where is group?
06:51:48 <edwardk> Data.List
06:52:22 <bling> how do i shorten: take 1 $ take 1
06:52:22 <bling> take isnt composable?
06:53:13 <ksandstr> (take 1) . (take 1)?
06:53:14 <jfoutz> > take 1 $ take 1 [1..4]
06:53:16 <lambdabot>   [1]
06:53:54 <jfoutz> > take 1 $ [1..4]
06:53:55 <lambdabot>   [1]
06:53:57 <mornfall> bling: take (min 1 1)
06:53:57 <edwardk> basically the triangle numbers grow quadratically, so to get the # of divisors of all of the first n triangle numbers you were paying O(n^3).
06:54:31 <jeffz`> @pl f x = take x $ take x
06:54:31 <lambdabot> f = ap take take
06:55:39 <doserj> @check \xs m n -> (take m $ take n xs) == take (min m n) (xs::[Int])
06:55:41 <lambdabot>   "OK, passed 500 tests."
06:56:18 <elbar> hmm..thought is was O(n^2)
06:56:38 <nothingmuch> is there any way to specify thread prioritywith Control.Concurrent stuff?
06:57:52 <edwardk> its O(the size of a number) to check the divisors the brute force way. the size of the number grows quadratically, you check n of them. n * n^2 = n^3
06:58:08 <edwardk> er to check the divisors for one triangle number
06:58:32 <edwardk> n^2 to check one, n^3 to check them all
06:58:50 <edwardk> hence the need to avoid brute forcing the divisor count
06:59:15 <quicksilver> nothingmuch: No.
06:59:30 <elbar> gah....took only 13 hours of cpu time here ;)
06:59:35 <quicksilver> nothingmuch: the GHC RTS doesn't give you much in the way of scheduling control.
06:59:38 <edwardk> ack
06:59:48 <nothingmuch> oh well.. not a huge issue since i'm nowhere near saturating
06:59:49 <quicksilver> nothingmuch: all runnable threads get roughly equal timeslices
07:00:20 <quicksilver> nothingmuch: often , most of your threads aren't runnable
07:00:22 <Workybob> edwardk: I take it you don't see any wierdness going on there?
07:00:25 <quicksilver> (blocked on IO or MVar etc)
07:00:29 <nothingmuch> yep
07:00:48 <quicksilver> nothingmuch: in orther words, the API is really designed for concurrency as opposed to parallelism
07:00:59 <quicksilver> nothingmuch: although it has some support for parallelism if you happen to have multiple cores.
07:01:00 <nothingmuch> i'm not really concerned
07:01:08 <nothingmuch> i have some threads that read timer info
07:01:19 <edwardk> workybob, sorry i missed the paste, checking.
07:01:44 <nothingmuch> and then a thread to write resuls
07:01:52 <nothingmuch> basically i don't care if the data writer is lagging
07:01:53 <bling> im stoopid
07:01:59 <bling> f = product $ map ((+1) . length) . DL.group $ [2,3]
07:02:13 <nothingmuch> but even with 2000 timing collectors I couldn't reach 100% cpu saturation
07:02:19 <nothingmuch> so I'm really not concerned
07:02:35 <nothingmuch> and if/when the select -> kqueue/epoll ticket gets fixed that's going to be less of an issue
07:02:39 <edwardk> bling: make sense? to be fair the brute force approach is a lot more obvious
07:02:46 <nothingmuch> i'm running out of sockets much faster than any other resource
07:03:09 <nothingmuch> (i think osx is not cleaning up the file descriptors in real time, but rather in the bg)
07:03:19 <bling> what does that do exactly? what is the result i get?
07:03:57 <nothingmuch> > product $ map ((+1) . length) . DL.group $ [2,3]
07:03:57 <edwardk> bling: that # is the number of divisors for 6.
07:03:58 <lambdabot>       Failed to load interface for `DL':
07:03:58 <lambdabot>        Use -v to see a list of the f...
07:04:09 <nothingmuch> DL?
07:04:13 <nothingmuch> Data.List?
07:04:15 <edwardk> > product . map ((+1) . length) . group $ [2,3]
07:04:16 <lambdabot>   4
07:06:07 <edwardk> by the fundamental theorem of arithmetic, every divisor is some subset of the divisors, but if you have "2 2's" you only get 3 combinations out of it, not 4, so you group them.
07:06:22 <bling> yes
07:06:22 <bling> but what is 4 here?
07:06:24 <edwardk> er is a product of some subset of the prime factors
07:06:44 <edwardk> 4 indicates that there are 4 divisors, length [1,2,3,6] == 4
07:07:35 <edwardk> 4 = 2 * 2, the first 2 comes from the fact that you can include the 2 prime factor or not in the answer, and the second comes from the fact that you can include the 3 prime factor or not.
07:08:23 <edwardk> if you don't include either, you get 1, if you include the 2 but not the three you get 2, if you include the 3 but not to the two you get 3. if you include both you get 6. so the 4 possibilities are summed up more succinctly in terms of the prime factors
07:09:40 <bling> how do I make bigints
07:09:40 <bling> ?
07:09:42 <edwardk> you have to group them because if your prime factors were [2,2], then you only get '3 cases' out of the 2 2's you can have used none of the 2s, one of the 2s or both 2s. hence the same operation applied to [2,2] the prime factors of 4, that there are 3 divisors, [1,2,4]
07:09:44 <edwardk> as expected
07:10:17 <edwardk> bling: in haskell? Integer is theoretically unbounded.
07:10:40 <edwardk> bling: in haskell? Integer is theoretically unbounded (up to the amount of ram you have)
07:10:54 <bling> but i get 0 or -something after a while
07:10:58 <daf> as unbounded as, say, lists :)
07:11:06 <daf> bling: are you sure they're Integers, and not Ints?
07:11:16 <edwardk> bling: Int is not unbounded. Integer is
07:11:22 <bling> g = product $ map ((+1) . length) . DL.group $ tri 50
07:11:26 <lupsyn> isBST (Node x Void Void)=True
07:11:26 <lupsyn> isBst (Node x l r)= ?
07:11:43 <andun> i did iterate (+1) 0 and used 8G of ram in an instant (and crashed my machine), so they can get quite big, yes
07:11:46 <edwardk> > 25 * 51
07:11:47 <lambdabot>   1275
07:12:14 <edwardk> bling: you have to compute the prime factors of the 50th triangle number, not just feed it the triangle number.
07:12:38 <BMeph> bling: Also, length gives you an Int, not an Integer. :)
07:12:41 <bling> but elngth make sit an Int
07:12:46 <bling> yes
07:12:53 <edwardk> then fromIntegral it
07:13:00 <Deewiant> genericLength
07:13:06 <edwardk> or use genericLength
07:13:10 <dublpaws> > 9999999999999999999999 :: Int
07:13:12 <lambdabot>   1864712049423024127
07:13:17 <dublpaws> > 9999999999999999999999 :: Integer
07:13:19 <lambdabot>   9999999999999999999999
07:13:52 <bling> i see
07:14:12 <edwardk> personally i'd use fromIntegral . length because of the fact that you know that it is the length of a list that fit in memory so length will traverse it, and the resulting number will start out small, so its faster, but thats domain knowledge
07:15:35 <edwardk> heh, that and if you ever have more than 500 items in the list you've scored a homerun, so the list had better not be long enough to overflow an int! ;)
07:17:19 <ehird> My inferior-haskell mode is broken
07:17:22 <ehird> *Main> 2+2
07:17:22 <ehird> 2+2
07:17:23 <ehird> 4
07:17:30 <ehird> Repeats the expression before its result, wtf?
07:18:31 <cytzol> ehird: Upgraded emacs recently?
07:19:17 <cytzol> *Main> 2+2
07:19:20 <cytzol> 2+2^J4
07:19:31 <ehird> cytzol: 22.2.1
07:19:33 <ehird> So: no.
07:20:03 <cytzol> damn, I was blaming it on the cvs version being broken.
07:20:25 <edwardk> ehird: well it is an _inferior_ haskell mode after all ;)
07:21:13 <ehird> edwardk: Very...
07:22:37 <bling> what is dropWhile but dropUntil?
07:22:37 <bling> like perform this computation until you find the answers then return it
07:23:33 <bling> http://cpp.ninjacodemonkeys.org/5057
07:23:42 <bling> why does that give empty head?
07:24:00 <vixey> sokoban lvl 30 is impossible o_o
07:24:54 <lupsyn> i must write this in haskell :fun isBST EmptyTree = true
07:24:54 <lupsyn>   | isBST (Fork(L,e,R)) =
07:24:54 <lupsyn>       let fun check _ EmptyTree = true
07:24:54 <lupsyn>             | check p (t as Fork(_,e,_)) = p e andalso isBST t
07:24:54 <lupsyn>       in check (fn e' => e' < e) L andalso
07:24:55 <lupsyn>          check (fn e' => e' > e) R
07:24:59 <lupsyn>       end;
07:25:15 <vixey> lupsyn, and that's SML currently?
07:26:55 <eelco> bling, because [2..2-1] is []
07:28:32 <ehird> What is the point of the integer argument to readsPrec?
07:28:59 <vixey> that's the 'prec' part of readsPrec
07:29:05 <Deewiant> ehird: read the docs
07:29:07 <quicksilver> ehird: the 'precendence' of the context you're reading into.
07:29:08 <MyCatVerbs> bling: dropWhile (not . f) == dropUntil f
07:29:29 <ehird> Deewiant: I did.  quicksilver: that's very vague
07:30:09 <quicksilver> it's not axctually. It's perfectly precise.
07:30:23 <lilac> ehird: precedence as in 'infixl <precedence> op'
07:30:42 <ehird> ah.
07:35:28 <mib_wrzzmr1y> hey
07:35:29 <mib_wrzzmr1y> hi
07:35:34 <Axman6> 'lo
07:35:56 <bling> what i want is findFirst or something
07:36:09 <quicksilver> :t find
07:36:10 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
07:36:17 <quicksilver> find is findFirst, in some sense.
07:36:18 <bling> findFirst (> 10) [1..20] -> 11
07:36:20 <bling> ah
07:36:25 <mib_wrzzmr1y> i´ve question - what GAME! is similar to the COUNTDOWN PROBLEM?
07:36:30 <quicksilver> > find (>10) [1..20]
07:36:32 <lambdabot>   Just 11
07:36:43 <vixey> mib_wrzzmr1y, "GAME!"?
07:36:47 <mib_wrzzmr1y> y
07:36:48 <loadquo_> :t (>>)
07:36:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
07:36:53 <ehird> mib_wrzzmr1y: Uh, the countdown show? :-P
07:36:54 <mib_wrzzmr1y> some card game or something like that
07:36:54 <vixey> mib_wrzzmr1y, ..meaning what?
07:37:11 <vixey> mib_wrzzmr1y, the programming puzzle is based on the actual gameshow "Countdown"
07:37:12 <osfameron> countdown came from "les chiffres et les lettres" on french TV didn't it?
07:37:41 <ehird> countdown is from the british tv show countdown
07:37:42 <mib_wrzzmr1y> DID IT?
07:37:49 <ehird> mib_wrzzmr1y: YOU CAN TURN OFF YOUR CAPS LOCK
07:37:56 <mib_wrzzmr1y> hm
07:38:07 <osfameron> mib_wrzzmr1y: also see Wikipedia which definitely will have an article on Countdown
07:38:29 <osfameron> (possibly also on the french one, though you might want fr.wikipedia tbh)
07:38:51 <loadquo_> @where shiftl
07:38:51 <lambdabot> I know nothing about shiftl.
07:39:05 <loadquo_> @hoogle shiftl
07:39:05 <lambdabot> Data.Bits shiftL :: Bits a => a -> Int -> a
07:39:27 <mib_wrzzmr1y> hm okay
07:40:32 <bastl1> @hoogle hint
07:40:33 <lambdabot> package hint
07:40:33 <lambdabot> Data.HashTable hashInt :: Int -> Int32
07:40:57 <Axman6> > fix shiftl (1 :: Int)
07:40:58 <lambdabot>   Not in scope: `shiftl'
07:41:02 <Axman6> bah
07:41:33 <loadquo_> It is shiftL
07:41:54 <loadquo_> fix shiftL (1 :: Int)
07:42:07 <loadquo_> > fix shiftL (1 :: Int)
07:42:08 <lambdabot>       Occurs check: cannot construct the infinite type: a = Int -> a
07:42:08 <lambdabot>      Pro...
07:42:29 <Axman6> :t fix
07:42:31 <lambdabot> forall a. (a -> a) -> a
07:42:53 <Axman6> > map (join shiftL) [1..10]
07:42:55 <lambdabot>   [2,8,24,64,160,384,896,2048,4608,10240]
07:44:05 <Axman6> :t (* 2 ^)
07:44:06 <lambdabot> parse error on input `)'
07:44:09 <Axman6> bah
07:44:27 <vixey> :t (\x y -> x * 2 ^ y)
07:44:28 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
07:44:48 <lucca> * 2 ^ would be strange indeed
07:45:55 <lucca> though it might be feasible to do a transform like that, I'm not sure it would be desirable
07:46:01 <quicksilver> :t (* 2 * 3)
07:46:02 <lambdabot>     The operator `*' [infixl 7] of a section
07:46:02 <lambdabot>         must have lower precedence than the operand `(*)' [infixl 7]
07:46:02 <lambdabot>         in the section: `(* 2 * 3)'
07:46:09 <quicksilver> you can do certain double sections
07:46:11 <quicksilver> just not all ;)
07:46:18 <quicksilver> :t (4 * 2 * 3 *)
07:46:19 <lambdabot> forall t. (Num t) => t -> t
07:46:30 <lucca> yeah, but that's only missing one thing
07:46:32 <quicksilver> based on the 'l' or 'r' or the infix
07:46:36 <quicksilver> yes, indeed.
07:46:53 <lucca> :t (1,,,)
07:46:55 <lambdabot> parse error on input `,'
07:47:10 <Axman6> :t (,,,) 1
07:47:11 <lambdabot> forall t b c d. (Num t) => b -> c -> d -> (t, b, c, d)
07:47:14 <vixey> > let (*) = (,) in :t (1 * 2 * 3 *)
07:47:15 <lambdabot>   <no location info>: parse error on input `:'
07:47:17 <vixey> -_-
07:47:22 <vixey> :t let (*) = (,) in (1 * 2 * 3 *)
07:47:23 <lambdabot> forall t t1 t2 b. (Num t2, Num t1, Num t) => b -> (((t, t1), t2), b)
07:51:04 * Itkovian is trying to grok the timeout.hs code in nobench
07:51:47 <ehird> :t (!!)
07:51:48 <lambdabot> forall a. [a] -> Int -> a
07:51:54 <ehird> @hoogle [a] -> Integer -> a
07:51:54 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
07:51:54 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
07:51:54 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
07:52:30 <ehird> @hoogle genericTake
07:52:30 <lambdabot> Data.List genericTake :: Integral i => i -> [a] -> [a]
07:52:33 <ehird> @hoogle genericDrop
07:52:33 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
07:52:43 <ehird> why aren't these the default?
07:53:35 <baaba> :t 5
07:53:36 <lambdabot> forall t. (Num t) => t
07:54:08 <baaba> :t "hi" `genericIndex` 1
07:54:09 <lambdabot> Char
07:55:11 <SamB> huh. there's something wrong with my school's CS department, I can tell!
07:55:21 <SamB> they don't have latex!
07:55:25 <lupsyn> what the hell! why foldr (>) [0] [1..10]
07:55:25 <lupsyn>  doesn't work ?
07:55:32 <SamB> (installed on the computers in the lab, anyway)
07:55:33 <Axman6> SamB: :O
07:55:47 <lilac> lupsyn: what would it do?
07:55:51 <bling> http://cpp.ninjacodemonkeys.org/5058
07:55:57 <bling> it still takes forever
07:56:03 <lupsyn> check if a list is in order
07:56:18 <lilac> lupsyn: foldr (...) True [1..10]
07:56:21 <lilac> but ... != >
07:56:51 <baaba> can you even do that with foldr?
07:56:56 <lilac> not trivially
07:57:00 <vixey> lupsyn, what does "doesn't work" mean?
07:57:04 <SamB> either that or I just SSH'd to the wrong host ...
07:57:15 <lupsyn> \x y -> x>y ?
07:57:26 <lilac> > snd $ foldr (\a (b, t) -> (a, t && a < b)) (maxBound, True) [1..10]
07:57:27 <lambdabot>   Add a type signature
07:57:31 <vixey> (\x y -> x>y) = (>)
07:57:34 <baaba> you'd have to modify the function on the fly wouldn't you?
07:57:58 <baaba> to somehow have both the previous and current element available
07:58:08 <lilac> > snd $ foldr (\a (b, t) -> (a, t && a < b)) (maxBound :: Int, True) [1..10]
07:58:10 <lambdabot>   True
07:58:15 <lilac> > snd $ foldr (\a (b, t) -> (a, t && a < b)) (maxBound :: Int, True) [10..1]
07:58:17 <lambdabot>   True
07:58:21 <lilac> hmm
07:58:21 <baaba> ah right
07:58:37 <baaba> oh, nope
07:59:01 <tromp__> > ap (zipWith (>)) tail [0,3,5,6,4,8,11]
07:59:02 <lambdabot>   [False,False,False,True,False,False]
07:59:24 <vixey> :t foldl1 ?f . map Just
07:59:25 <lambdabot> forall a. (?f::Maybe a -> Maybe a -> Maybe a) => [a] -> Maybe a
07:59:29 <tromp__> > ap (zipWith (<)) tail [0,3,5,6,4,8,11]
07:59:30 <lambdabot>   [True,True,True,False,True,True]
07:59:38 <lilac> tromp__: that's not a fold ;-)
07:59:48 <vixey> :t maybe (const True) False . foldl1 ?f . map Just
07:59:49 <lambdabot>     Couldn't match expected type `a -> b -> Bool'
07:59:49 <lambdabot>            against inferred type `Bool'
07:59:49 <lambdabot>     In the second argument of `maybe', namely `False'
07:59:55 <vixey> :t maybe False (const True) . foldl1 ?f . map Just
07:59:55 <lupsyn> :/
07:59:56 <lambdabot> forall a. (?f::Maybe a -> Maybe a -> Maybe a) => [a] -> Bool
08:00:08 <lilac> > snd $ foldr (\a (b, t) -> (a, t && a < b)) (maxBound :: Int, True) [10,9..1]
08:00:08 <vixey> lupsyn, that's how I start ^
08:00:09 <lambdabot>   False
08:00:11 <lilac> (oops)
08:00:22 <tromp__> cant do it with fold:(
08:00:27 <vixey> I can...
08:00:30 <lupsyn> i have the same problem with  the bst
08:00:31 <lilac> tromp__: but... but... i just did
08:00:32 <tromp__> well, i can , but
08:00:39 <vixey> lupsyn, what...?
08:00:47 <tromp__> it
08:00:51 <tromp__> it's toio convoluted
08:01:31 <lupsyn> i resolve the problem of isbst with the list of leaves... but i must check if the list is in order etc etc...
08:01:46 <lupsyn> but i want to do a isbst with a fold
08:02:22 <lupsyn> foldt _ z Void = z
08:02:22 <lupsyn> foldt f z ( Node x l r ) = f x ( foldt f z l ) ( foldt f z r )
08:02:22 <lupsyn> for the bst
08:02:31 <vixey> lupsyn, and..?
08:02:41 <vixey> did you ever answer my question
08:02:48 <vixey> "when is a BST not a binary search tree?"
08:03:03 <lilac> when it's british summer time?
08:03:10 <vixey> ohh
08:03:16 <quicksilver> when it's a Badly Sewn Teddy
08:03:22 <baaba> acronymfinder.com
08:03:27 <lupsyn> is a BST when the root is< of all right nodes and > of all sx Nodes
08:04:13 <mercury^> oh, everyone beat me to the jokes while I was joining other channels
08:04:17 <mercury^> :(
08:04:34 <lilac> When is a BST not a binary search tree? Between 1am on the last Sunday in March and 1am on the last Sunday in October (GMT).
08:08:07 * loadquo still doesn't quite get monadic syntax
08:08:36 <MyCatVerbs> loadquo: you mean do notation?
08:08:38 <lilac> loadquo: you mean do-notation or (>>=) and return?
08:08:45 <loadquo> If I want to branch on the value returned by a readArray how would I do it? Assuming "do"
08:09:08 <lilac> loadquo: do { v <- readArray; case v of A -> a; B -> b }
08:09:09 <MyCatVerbs> e <- readArray array index; case e of { ... }
08:10:40 <SamB> ah, the bracket syntax. In addition to being of great help in formulating the layout rule, it is so useful on IRC ;-P
08:11:04 <SamB> or should I have said brace syntax ?
08:11:25 <SamB> apparantly in british brackets means ()
08:11:34 <vixey> brackets are anything
08:11:40 <vixey> [] () {} are all brackets
08:11:46 <vixey> () are just the most common ones
08:11:47 <SamB> I mean, by default
08:11:53 <ehird> vixey: um.
08:11:56 <ehird> () parens
08:11:58 <ehird> {} braces
08:11:59 <ehird> [] brackets
08:12:00 <MyCatVerbs> SamB: personally I'm willing to go with the American convention on this one. "Parens" is much less ambiguous.
08:12:15 <SamB> well, obviously if you say parens nobody will be confused
08:12:18 * MyCatVerbs waves at ehird.
08:12:32 <lilac> SamB: yep, in british, () are usuall called brackets, [] square brackets and {} braces
08:12:47 <tromp__> or curly braces
08:12:52 * vixey round opening/round closing delimiter
08:13:05 <ehird> lilac: what??
08:13:14 <ehird> I am evidently in a different Britan
08:13:18 <ehird> *britain
08:13:21 <ehird> to the rest of you
08:13:38 <lilac> ehird: you appear to be living in the britain in the USA :)
08:13:47 <quicksilver> parenthesis is a traditional british term
08:13:51 <quicksilver> especially in formal contexts
08:13:54 <lilac> what's wrong with ASCII 40 and ASCII 41
08:13:59 <quicksilver> but 'bracket' is far, far more common in relaxed contexts
08:14:01 <SamB> so basically brackets should never be used unless disambiguated either by a qualifier or by context (i.e. if you are talking about a code listing that only has one kind in it ..)
08:14:08 <osfameron> I'd call {} curlies or curly brackets, only recently started to call them "braces"
08:14:10 <MyCatVerbs> lilac: "fourty" could get confused by the number. :)
08:14:17 <vixey>  ^ all this is why we can't have unambiguous terms!
08:14:37 <SamB> vixey: well, we could before Unicode came along
08:14:56 <SamB> I suppose now we could use the codepoints if we really wanted to be unambiguous
08:14:57 <lilac> ehird: as i understand it, in the US [] are called brackets. i don't know anyone (other than you) in the UK who'd understand 'bracket' to be unambiguously referring to []
08:15:23 <cebewee_> @pl c f a b x = (a x) `f` (b x)
08:15:23 <SamB> oh, and nobody said anything about the brackety versions of <>
08:15:23 <lambdabot> c = liftM2
08:15:35 <ehird> SamB: square brackets
08:15:39 <lilac> SamB: that's 'cause they're not brackets, C++ and the french notwithstanding
08:15:45 <vixey> SamB: I call them poem brackets :p
08:15:46 <SamB> everyone read "eats, shoots, and leaves"?
08:15:53 <SamB> lilac: well, there are brackets that look a lot like that
08:15:55 <loadquo> Thanks, that has fixed that problem.
08:15:55 * loadquo would say that [] is square brackets and {} is curly brackets
08:15:57 <ehird> i have, SamB
08:16:03 <ehird> err
08:16:05 <ehird> not square brackets
08:16:07 <ehird> ohhh, <> are um
08:16:08 <ehird> brackety
08:16:10 <ehird> brackets
08:16:13 <lilac> angle brackets
08:16:13 <ehird> ... what's the name again
08:16:14 <ehird> grr
08:16:16 <ehird> YES
08:16:16 <SamB> except I might have added an oxford comma
08:16:18 <ehird> thank you
08:16:21 <ehird> angle brackets
08:16:29 <ehird> SamB: it's Eats, Shoots & Leaves
08:16:34 <SamB> ah, yes
08:16:37 <ehird> so s/, and/&/
08:16:44 <ehird> er
08:16:45 <SamB> wait, no, you forgot the panda on the ladder!
08:16:46 <ehird> so s/, and/ &/
08:16:47 <lilac> SamB: I'm not a believer in the Oxford comma :)
08:16:54 <ehird> SamB: I am not sure that is part of the title
08:17:01 <lilac> ehird: whose regexp syntax is that?
08:17:02 * ehird has always used the oxford comma
08:17:10 <ehird> lilac: Ummm... Perl's :-P
08:17:14 <ehird> Or, rather, IRC's.
08:17:15 <lilac> in vim regexps, s/<anthing>/&/ is a no-op
08:17:19 <SamB> I tend to follow the same rule as the other of that book
08:17:23 <ehird> why,lilac?
08:17:26 <SamB> do it when it makes things clearer
08:17:31 <lilac> ehird: & is the same as \0 iirc
08:17:41 <SamB> s/other/author/
08:17:42 <ehird> hm. ok
08:17:46 <SamB> how did I typo that ...
08:17:54 <ehird> SamB: soundalike typos. brilliant.
08:18:03 <lilac> SamB: thinko not typo
08:18:18 * ehird thinkos entire sentences some times
08:18:19 <lilac> "thinkographical error" if you prefer
08:20:26 <mercury^> lilac: are you sure that & works and you don't have to type \&?
08:21:07 <lilac> mercury^: works for me. though it probably depends on one of the myriad regex options.
08:21:18 <mercury^> Because I think \& works, and then how would you insert `&'?
08:21:43 <lilac> \& inserts a & for me
08:21:49 <mercury^> Hmm, k.
08:22:36 <lilac> vim is just one of those programs whose behaviour is subjective.
08:23:33 <bling> dont anyone here use ghci?
08:23:37 <SamB> lilac: well, typographical errors used to be unrelated to typing ;-P
08:23:42 <bling> or you use it in the command prompt?
08:23:49 <bling> (no emacs)
08:23:50 <andun> bling: everyone in here uses ghci
08:23:51 <SamB> (probably because typing hadn't been invented yet ;-P)
08:24:43 <bling> andun: as in ghci not ghc?
08:24:53 <Axman6> yes
08:24:55 <quicksilver> bling: probably everyone or almost everyone, yes.
08:25:10 <Axman6> we all use ghci, it's pretty much the most useful development tool for haskell
08:25:11 <loadquo_> Thanks for the help guys.
08:25:11 <quicksilver> I have ghci open in an emacs buffer for 99% of my computer time.
08:26:20 <bling> i feel so inefficient when not using a repl. such a  pain to use java or c++ now
08:27:04 <andun> well, a repl for java or c++ would be painful in its own way
08:27:22 <quicksilver> quite a few effective C++ and java programmers habitually use advanced graphical debuggers
08:27:26 <skorpan> given the nature of the two languages, i'm not sure a repl would be a good idea
08:27:45 <quicksilver> and such debuggers invariably have the appropriate equivalent of a repl built in.
08:28:11 <mercury^> gdb has a repl of some sort
08:28:13 <quicksilver> I'd go as far as "most" use at least some form of debugger, which has some kind of expression evaluation capability, even if it's only gdb.
08:28:17 <quicksilver> right.
08:32:59 <cebewee_> @pl c f a b x = (a x) `f` (b x)
08:32:59 <lambdabot> c = liftM2
08:33:00 <loadquo_> Is GHC inferring the element type of () for an Array a common problem? It should be Word32...
08:33:19 <cebewee_> why does c (||) (not) (not) work, but liftM2 (||) (not) (not) not?
08:33:45 <vixey> cebewee_, "work"?
08:34:25 <cebewee_> vixey: the liftM2 version complains about "Cannot infer instance"
08:34:39 <vixey> maybe try turning off monomorphism restriction
08:34:46 * cytzol just spent fifteen minutes wondering if there was a shorter way to say do { c <- foo; return c }
08:34:58 <mornfall> ... : - )
08:35:05 <mornfall> cytzol: Worse things happen.
08:35:32 <cytzol> I'm sure they do!
08:35:44 <h0tzenpl0tz> and....? is  there any shorter way?
08:35:47 <tromp__> foo >>= return   :-)
08:35:54 <h0tzenpl0tz> oh
08:35:55 <gwern> anyone kno what sort of format 'Thu, 01 Dec 1994 16:00:00 GMT' is?
08:35:57 <tromp__> or just foo
08:35:59 <mornfall> tromp__: I actually wrote that at least once.
08:36:11 <mornfall> (foo >>= return)
08:36:28 <mercury^> cebewee_: (not . (&&)) is the same function and might be a bit faster btw.
08:36:57 <lilac> h0tzenpl0tz: it's handy to know the monad laws in terms of do notation
08:37:31 <tromp__> there's also longer ways, like  foo >>= return >>= return    :)
08:37:37 <lilac> @wiki monad laws
08:37:37 <lambdabot> http://www.haskell.org/haskellwiki/monad_laws
08:38:17 <h0tzenpl0tz> lilac: just reread. shame onme
08:38:23 <cebewee_> mercury^: i'm not really interested in not, it was just the first unary boolean function i thought of ;)
08:38:54 <quicksilver> loadquo_: No. there will be a reason it ends up as ().
08:38:57 <tromp__> > "return" >>= return
08:38:58 <lambdabot>   "return"
08:39:04 <loadquo_> :t writeArray
08:39:06 <lambdabot> Not in scope: `writeArray'
08:40:23 <cebewee_> vixey: i don't have access to a machine with current ghc at the moment.
08:40:51 <vixey> cebewee_, I don't know what means
08:41:15 <vixey> if you have any ghc at all you should be able to turn off monomorphism
08:41:53 <thomashartman1> I'm having trouble upgrading to the latest cabal (or actually 0.6.0 which is what I have habitually used): http://rafb.net/p/10Ha4G27.html
08:42:28 <lilac> @type liftM2 (||) not not
08:42:29 <lambdabot> Bool -> Bool
08:42:31 <thomashartman1> I believe this may be related to cabal actions I did recently as root user, to resolve linker errors I was getting
08:42:59 <thomashartman1> as this didn't happen when I ran bootstrap against ghc 6.10 OOTB
08:43:19 <thomashartman1> is bootstrap still the blessed upgrade path to the newest cabal?
08:43:41 <quicksilver> are you confusing cabal and cabal-install?
08:43:51 <quicksilver> bootstrap is needed for cabal-install, not cabal.
08:44:00 <quicksilver> and it shouldn't be needed for an 'upgrade path'
08:44:12 <quicksilver> once you did it once, old cabal-installs should be able to instlal new ones.
08:44:12 <thomashartman1> cabal install
08:44:19 <thomashartman1> sorry
08:44:30 <quicksilver> you dont' need to bootstrap for an upgrade AFAIK
08:44:37 <quicksilver> bootstrap is just to get some basic libs like HTTP and Network
08:44:52 <quicksilver> if you already had those (which you must do, if you had an old working cabal-install)
08:44:56 <quicksilver> you don't need it.
08:45:06 <thomashartman1> so just do cabal install cabal-install?
08:45:14 <quicksilver> nod
08:45:17 <thomashartman1> k
08:45:25 <thomashartman1> seem to remember this hanging but I'll try again
08:46:40 <thomashartman1> seems pretty hung.
08:51:02 <Saizan> thomashartman1: are you using cabal-install < 0.6 with ghc-6.10.1?
08:51:42 <Saizan> 0.5.x in particular goes into an infinite loop with it
08:53:08 <thomashartman1> Saizan: yes.
08:53:24 <thomashartman1> But in my experience, running bootstrap.sh worked in spite of this. till now.
08:57:50 <thomashartman1> shite, I think I'm going to have to reinstall ghc as root
08:58:23 <thomashartman1> anybody got advice on installing ghc as non-root user, for sandboxing purposes?
09:01:43 <mercury^> thomashartman1: Where's the problem?
09:01:53 <mercury^> I have done it in the past and it worked fine.
09:02:21 <vixey> :t [ \x -> x,  \f x -> f x ]
09:02:22 <lambdabot> forall t t1. [(t1 -> t) -> t1 -> t]
09:06:59 <thomashartman1> mercury: just wondering what the install command was.
09:07:11 <thomashartman1> or if you modify the conf file or what
09:07:34 <vixey> @let x `hasTheSameTypeAs` y = [x,y]
09:07:35 <lambdabot>  Defined.
09:08:04 <mercury^> thomashartman1: it's all in the docs
09:08:10 <ehird> @let hasTheSameTypeAs :: a -> a -> b; x `hasTheSameTypeAs` y = undefined
09:08:11 <lambdabot>  <local>:29:35:
09:08:11 <lambdabot>      Multiple declarations of `L.hasTheSameTypeAs'
09:08:11 <lambdabot>      Decla...
09:08:32 <pao> what is the advantage of using a newtype over a type for defining a monad transformer stack?
09:08:51 <pao> newtype allows "sealing" the interface?
09:08:53 <ehird> @let also :: a -> b -> b; a `also` b = b
09:08:54 <lambdabot>  Defined.
09:12:15 <lilac> pao: you can't define instances for a type synonym
09:12:49 <lilac> plus you get additional encapsulation with a newtype
09:13:05 <lilac> ehird: also = flip const?
09:13:16 <rwbarton> pao: Some people here answered that question for me a few months ago.  I don't really remember what the outcome was though :)
09:13:17 <ehird> lilac: yep
09:13:19 <pao> lilac: so you get the orginal instance definitions for the outermost transformer... and cannot add any
09:13:23 <ehird> with my hasTheSameTypeAs, you can do
09:13:32 <ehird> (x `hasTheSameTypeAs` y) `also` (x+y)
09:13:33 <rwbarton> pao: I think it's not a terribly big deal
09:13:34 <ehird> or something
09:13:49 <lilac> pao: to be honest, i think the encapsulation is the bigger deal
09:14:01 <lilac> "sealing" the interface as you put it
09:14:02 <kkourt> Hi, I want to measure the performance of a Haskell function by calling it a number of times. Any pointers ?
09:14:22 <pao> lilac: I understand... thank you
09:14:29 <pao> rwbarton: thank you as well :-)
09:15:03 <thomashartman1> mercury: found it in INSTALL file, for ghc as non-root user I guess just ./configure --prefix=<my-dir>
09:15:04 <Raevel> kkourt: afaik haskell doesn't do memoization, was that your "problem"?
09:15:18 <pao> lilac: rwbarton: ... there was also an issue with "partially applied" types
09:15:34 <pao> I don't remember exactly...
09:16:06 <kkourt> Raevel: No. The basic problem (I guess) is that I'm not sure how to create a loop  :)
09:16:54 <ehird> kkourt: You don't loop in Haskell, in general
09:17:18 <tromp__> goto considered missing
09:17:25 <kiris> haha
09:18:09 <kkourt> ehird: yes I know that. Do you have any idea how I could execute a function a number of times ?
09:18:16 <beelsebob> kkourt: recursion
09:18:20 <beelsebob> or higher order functions
09:18:34 <kiris> > map (+1) [1..10]
09:18:36 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
09:18:55 <lilac> do { n <- new 0; a <- label; v <- n; n := v*2; if v < 10 then goto a else return v }
09:19:04 * lilac feels dirty
09:19:09 <beelsebob> lilac: ewwwwwwwww
09:19:13 <vixey> lilac, is that really implementable ?
09:19:24 <lilac> vixey: i don't see why not.
09:19:30 <vixey> I can't see /how/
09:19:43 <lilac> 'label' grabs a continuation
09:19:44 <kiris> a goto monad built on continyashuns?
09:19:46 <beelsebob> a would need to be a continuation
09:19:50 <beelsebob> what lilacsaid
09:19:56 <lilac> the rest of it is just ST
09:20:09 <vixey> so goto = id?
09:20:12 <rwbarton> You need to figure out a way for := to be a constructor though. :)
09:20:14 <lilac> actually, you can't do ':='
09:20:30 <vixey> no problem with (:=)
09:20:34 <vixey> I'm just wondering about goto
09:20:40 <lilac> rwbarton: yeah, i suppose you could add := as a constructor for the monad
09:20:44 <vixey> :t runCont
09:20:45 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
09:21:12 <vixey> > runCont (do return "I have no idea what to write in here")
09:21:13 <lambdabot>       Overlapping instances for Show (([Char] -> r) -> r)
09:21:13 <lambdabot>        arising from...
09:21:16 <vixey> :(
09:21:22 <vixey> > runCont (do return "I have no idea what to write in here") id
09:21:23 <lambdabot>   "I have no idea what to write in here"
09:21:42 <vixey> @docs Cont
09:21:43 <lambdabot> Cont not available
09:21:43 <kiris> what changed?
09:21:48 <vixey> @docs Control.Monad.Cont
09:21:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Cont.html
09:22:27 <vixey> the callCC in Cont doesn't seem quite right for your label/goto
09:24:29 <quicksilver> isn't it going to be tricky to "goto a" without resetting all the variables?
09:24:56 <quicksilver> and will the scoping do what you expect.
09:24:59 * quicksilver ponders
09:25:09 <vixey> lilac, even if you pull it off using mdo I will be amazed
09:25:52 <bos> @unpl (a -> [b]) -> [a] -> [b]
09:25:52 <lambdabot>  Parse error at "->" (column 4)
09:25:55 <rwbarton> @unmtl ContT Int ST
09:25:56 <lambdabot> err: `ContT Int ST' is not applied to enough arguments, giving `/\A. (A -> ST Int) -> ST Int'
09:25:58 <rwbarton> @unmtl ContT Int ST a
09:25:58 <lambdabot> (a -> ST Int) -> ST Int
09:27:14 <kiris> goto considered difficult to implement
09:27:36 <kkourt> also, is there a way to force the evaluation of a function ?
09:28:05 <chessguy_work> @type concatMap . map
09:28:05 <lambdabot> forall a b. (a -> b) -> [[a]] -> [b]
09:28:08 <bos> what's the name of lennart's code that generates a function from a type?
09:28:17 <rwbarton> @djinn a -> a
09:28:17 <lambdabot> f a = a
09:28:24 <bos> rwbarton: thanks!
09:28:36 <chessguy_work> @djinn (a -> [b]) -> [a] -> [b]
09:28:36 <lambdabot> Error: Undefined type []
09:28:53 <skorpan> @djinn ((forall b. b -> b) -> a) -> c
09:28:54 <lambdabot> -- f cannot be realized.
09:29:03 <rwbarton> I'm unconvinced about "v <- n" now
09:29:45 <vixey> what "v <- n"?
09:30:46 <rwbarton> in lilac's "do { n <- new 0; a <- label; v <- n; n := v*2; if v < 10 then goto a else return v }"
09:31:16 <vixey> I don't see any immediate reason that could not be made to work
09:31:18 <ozy`> @hoogle (:=)
09:31:18 <lambdabot> Warning: Unknown type :=
09:31:18 <lambdabot> Prelude undefined :: a
09:31:18 <lambdabot> Data.Array.Base arrEleBottom :: a
09:31:24 <vixey> it's label and goto that are really interesting
09:31:24 <quicksilver> Yes, I think it has to be "v <- copy n"
09:31:28 <quicksilver> or some other name.
09:31:41 <vixey> I don't see why, you haven't said what the type of 'new' is
09:31:48 <quicksilver> n can't *just* be an action that yields its own value
09:31:56 <vixey> new :: Integer -> Imp (Imp a)
09:31:56 <quicksilver> because that gives no way to update it.
09:33:18 <dolio> > let label = callCC (\k -> return (toDyn k)) ; goto l = fromJust (fromDynamic l) () in runST (runContT (do r <- lift (newSTRef 0) ; loop <- label ; lift (modifySTRef r (+1)) ; i <- lift (readSTRef r) ; if i < 10 then goto loop else return i) return)
09:33:19 <lambdabot>       Inferred type is less polymorphic than expected
09:33:19 <lambdabot>        Quantified type ...
09:34:12 <Saizan> is there a tool that parses an haskell module and prettyprints it back with sane indentation?
09:34:55 <rwbarton> I think Language.Haskell.Exts can do it
09:36:20 <dolio> Evidently mtl doesn't have typeable instances.
09:37:55 <dolio> @kind Any
09:37:56 <lambdabot> *
09:38:33 <dolio> , [$ty| unsafeCoerce |]
09:38:38 <lunabot>  luna: Exception when trying to run compile-time code:
09:38:48 <vixey> unsafeCoerce :: a -> b
09:39:00 <dolio> I was seeing if it was available.
09:40:38 <Saizan> rwbarton: too bad it strips comments
09:40:54 <quicksilver> dolio: odd. (Typeable instances for MTL)
09:41:02 <quicksilver> dolio: I'm surprised I've not noticed that hole before, too.
09:41:52 <ozy`> , (unsafeCoerce "pizza") :: Int
09:41:53 <lunabot>  luna: Not in scope: `unsafeCoerce'
09:42:08 <quicksilver> > typeOf 'a'
09:42:09 <lambdabot>   Char
09:42:20 <quicksilver> > typeOf StateT (\i -> [('a','b')])
09:42:21 <lambdabot>   Couldn't match expected type `(t1 -> [(Char, Char)]) -> t'
09:42:27 <quicksilver> > typeOf $ StateT (\i -> [('a','b')])
09:42:29 <lambdabot>       No instance for (Typeable1 (StateT Char []))
09:42:29 <lambdabot>        arising from a use ...
09:42:36 <sw17ch> how does one use --constraint with cabal install
09:42:40 <sw17ch> i can't seem to make it do what i think i want
09:42:43 <quicksilver> carefully.
09:43:02 <rwbarton> @unmtl ContT r m (ContT r m) a
09:43:03 <lambdabot> err: `ContT r m' is not applied to enough arguments, giving `/\A. (A -> m r) -> m r'
09:43:12 <rwbarton> @unmtl ContT r m (ContT r m a)
09:43:12 <lambdabot> (((a -> m r) -> m r) -> m r) -> m r
09:43:13 <Saizan> sw17ch: i think you need cabal-install-0.6.1 for that to work
09:43:23 <rwbarton> @djinn (((a -> b) -> b) -> b) -> b
09:43:24 <lambdabot> -- f cannot be realized.
09:43:46 <vixey> :t callCC
09:43:47 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
09:44:03 <Saizan> @djinn a -> (((a -> b) -> b) -> b) -> b
09:44:03 <lambdabot> f a b = b (\ c -> c a)
09:44:08 <Kamina> Hi, can someone tell me why Data.Set.insert has O(log n) according to the documentation? Doesn't it have to copy the whole Set datastructure, as it's immutable?
09:44:18 <sw17ch> Saizan: 1.6.0.1
09:44:28 <vixey> I tried to write a djinn in haskell once
09:44:37 <quicksilver> Kamina: nope.
09:44:42 <Saizan> sw17ch: that's the Cabal version
09:44:43 <sw17ch> I'm trying to reinstall the json library using parsec-3
09:44:45 <vixey> I couldn't do it thought because I couldn't represent haskells type system in values
09:44:50 <Deewiant> Kamina: it only has to copy the part that changes.
09:44:51 <quicksilver> Kamina: it has to copy one 'branch' of the tree - the path from the root to the new node.
09:44:59 <vixey> it's really annoying the way forall works in haskell :(
09:45:04 <quicksilver> Kamina: the rest is shared with the old version, by the beauty of immutability ;)
09:45:14 <sw17ch> Saizan: the --help lists --constraint as an option for cabal install
09:45:35 <Saizan> sw17ch: yeah, but it wasn't working in 0.6.0
09:45:36 <quicksilver> vixey: you mean a haskell program which constructs terms based on their type?
09:45:42 <quicksilver> vixey: oleg did it.
09:45:43 <vixey> yes
09:45:51 <vixey> yeah but I was trying to do it without typeclasses
09:45:52 <sw17ch> Saizan: then that explains things :)
09:45:54 <Kamina> quicksilver, Deewiant: hmmm strange that it's possible, while Array's look much more complicated to handle...
09:46:02 <Saizan> sw17ch: alternatively you can "cabal install json 'parsec >= 3'"
09:46:06 <vixey> I'm pretty sure it's impossible though
09:46:37 <sw17ch> when is 0.6.1 going to be on hackage?
09:46:42 <vixey> you can't represent like   forall a. a -> a -> a  because _ -> _ -> _ isn't a type ctr with kind * -> * -> * -> *
09:46:43 <quicksilver> Kamina: immutable structures are generally more pleasant to work with in haskell.
09:47:01 <quicksilver> vixey: I also think it's not possible without typeclasses.
09:47:39 <Kamina> quicksilver: but arn't there any drawbacks, like with the Data.Array.Diff array?
09:50:00 <chessguy_work> @remember emacs [comment just above a bug in haskell-mode's elsip file] ;; Not sure if it's useful/needed and if it actually works"
09:50:00 <lambdabot> It is stored.
09:50:02 <Kamina> quicksilver: maybe i should look how the operations are implemented...
09:51:41 <dons> ?users
09:51:42 <lambdabot> Maximum users seen in #haskell: 646, currently: 615 (95.2%), active: 26 (4.2%)
09:51:43 <dons> ?yow
09:51:43 <lambdabot> LBJ, LBJ, how many JOKES did you tell today??!
09:51:50 <dons> a lot of jokes.
09:52:18 <Kamina> quicksilver: ahh.. i think now i understand... thanks...
09:52:56 * sw17ch discovers that (as expected) the new json package is not the same as the older package!
09:52:57 <sw17ch> hah
09:53:30 <cytzol> They put a lot of hard work into changing the version number.
09:54:11 <dons> the new one is the biggest change.
09:54:17 <dons> previously it has only been incremental.
09:54:24 <dons> a bit of the format changed.
09:55:43 <sw17ch> dons: cool.
09:55:48 <rwbarton> @djinn ((a -> c) -> c) -> (a -> (b -> c) -> c) -> (b -> c) -> c
09:55:48 <lambdabot> f a b c = a (\ d -> b d c)
09:56:06 <sw17ch> i'm currently using json files for my app's configuration files... but i'm dropping a lot of that...
09:56:15 <ozy`> @djinn (a -> b)
09:56:15 <lambdabot> -- f cannot be realized.
09:56:20 <ozy`> @djinn (a -> [a])
09:56:20 <lambdabot> Error: Undefined type []
09:56:30 <ozy`> @djinn ([b] -> a)
09:56:30 <lambdabot> Error: Undefined type []
09:56:35 <ozy`> @djinn ([a] -> a)
09:56:36 <lambdabot> Error: Undefined type []
09:56:38 <Saizan> ozy`: no lists
09:56:45 <ozy`> awwwww sheeeiiiiit.
09:56:55 * ozy` gives up
09:57:21 <rwbarton> const []; cannot be realized; cannot be realized
09:57:58 <vixey> ?djinn  ((((((a -> a) -> b) -> b) -> c) -> c) -> d) -> d
09:57:59 <lambdabot> f a = a (\ b -> b (\ c -> c (\ d -> d)))
09:59:05 <mak__> ozy`: maybe you can make a list by fix-point recursion
10:00:17 <ddarius> @djinn a -> (r -> (a -> r -> r) -> r)
10:00:17 <lambdabot> f a b c = c a b
10:00:19 * vixey wrote a program that says 2 is not equal to 3
10:00:29 <vixey> (in haskell!)
10:00:42 * ozy` adds "learn fix-point recursion already, dammit" to his list of stuff to figure out
10:00:44 <ddarius> vixey: You can prove anything in Haskell.
10:01:25 <ddarius> :t replicate 3
10:01:26 <lambdabot> forall a. a -> [a]
10:01:28 <newsham> vixey: have you quickchecked with large values of 2?
10:01:39 <vixey> I've only tried with one value of 2 actually
10:01:42 <cytzol> Is haskell-src-exts supposed to wait for me to click on a window before it configures?
10:01:56 <newsham> > take 2 "hi" == test 3 "hi"
10:01:58 <lambdabot>   Not in scope: `test'
10:02:00 <vixey> need to get a parser and pretty printer and all this rubbish
10:02:04 <newsham> > take 2 "hi" == take 3 "hi"
10:02:05 <lambdabot>   True
10:06:34 <vixey> humf I don't know what to do next
10:07:05 * vixey is waiting for data .... deriving (Parser, PrettyPrinter)
10:07:13 <ozy`> vixey: come up with a painless procedure for building and installing gtk-cocoa and gtk2hs on macs
10:07:16 <saml> :t take
10:07:17 <lambdabot> forall a. Int -> [a] -> [a]
10:07:32 <saml> > take 1000 ""
10:07:33 <lambdabot>   ""
10:07:50 <saml> > "" !! 1000
10:07:51 <lambdabot>   * Exception: Prelude.(!!): index too large
10:12:13 <cytzol> oh! The first line is "import Distribution.Simple", not a shebang, so whenever I tried to configure it, it tried to take a screenshot of a window.
10:12:50 <Twey> Haha
10:12:50 <Twey> Nice :-D
10:13:22 <kiris> how can I make `id' monadic?
10:13:39 <Twey> kiris: There's already an Identity monad
10:14:02 <Twey> > runIdentity $ return 5 >> return 3
10:14:03 <lambdabot>   3
10:15:19 <saml> :t id
10:15:20 <lambdabot> forall a. a -> a
10:15:39 <newsham> give an 'a' get an 'a'
10:15:49 <Saizan> the monadic id is return
10:16:30 <MarcWeber> Are there some vim users who'd like to try out the new scion backend for vim? Scion is a library providing IDE like features for haksell programming. Right now getting the type of a thing at cursor and background compilation is supported
10:16:42 <cytzol> :t liftM id
10:16:43 <lambdabot> forall a1 (m :: * -> *). (Monad m) => m a1 -> m a1
10:16:53 <newsham> :t return
10:16:54 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
10:17:03 <mak__> MarcWeber: sure
10:17:42 <rwbarton> lilac: Without really understanding what I was doing, I managed to produce this: http://moonpatio.org/fastcgi/hpaste.fcgi/view?id=850#a850
10:17:48 <MarcWeber> mak__ CAn you get http://github.com/MarcWeber/scion and try to compile it?
10:18:42 <cytzol> MarcWeber: front-end-agnostic? awesome :)
10:21:06 <MarcWeber> cytzol Mmmh I didn't quite get the meaning of your statement
10:21:53 <cytzol> MarcWeber: I was just saying that it looked pretty good, that is all
10:24:30 <mak__> MarcWeber: some problem with dependencise witch seems to quite stupid...
10:24:35 <rwbarton> Apparently there is no MonadFix (ContT r m) instance...
10:24:50 <MarcWeber> mak__ Which ones?
10:25:03 <rwbarton> :t mfix
10:25:05 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
10:25:50 <mak__> with process, it said that needs process ==1.0.1.1 but this is xcluded because ghc-6.10.1 requires process ==1.0.1.0
10:26:00 <bos31337> am i the only one who found that "jquery is a monad" article to be completely worthless to the point of misinformation?
10:26:46 <MarcWeber> mak__ Who does need 1.0.1.1 ? Which ghc version do you have?
10:27:00 <lilac> rwbarton: yep, i've got something similar. i'm pretty sure it's impossible to do the "x <- v" thing without sacrificing type safety or using -XNoImplicitPrelude though :(
10:27:08 <Botje> bos: i was disappointed when they didn't say _which_ monad
10:27:13 <mak__> 6.10.1
10:27:31 <MarcWeber> mak__: Should be fine
10:27:35 <bos> Botje: it's the fuzzy wuzzy shape shifting monad, of course
10:27:46 <Botje> sure, the chaining thingie looks a bit like Maybe, but it's not terribly innovative
10:27:50 <Botje> ah, that one
10:28:00 <Botje> got any good papers about it? :)
10:28:03 <Saizan> mak__: the problem is that either Cabal-1.6.0.1 or haskell98-1.0.1.0 are built against the newer version of process
10:28:16 <rwbarton> lilac: by "type safety" you mean you can't rule out runtime pattern match errors?
10:28:16 <Saizan> mak__: probably the ones in the user packagedb
10:28:26 <lilac> rwbarton: yep.
10:28:53 <mak__> hmm okey that is my problem with cabal not with scion...
10:29:16 <Saizan> mak__: you should remove those, or rebuild them against process-1.0.1.0
10:29:26 <lilac> rwbarton: if i allow "x <- v" with x :: Int, then v :: m Int. if i also allow "v := (x+1)" then (:=) :: m Int -> Int -> m ().
10:29:37 <lilac> rwbarton: so you can assign to /any/ value of type "m a"
10:29:40 <Saizan> the other option is to configure/build/install manually and ignore the warnings about process
10:29:42 <rwbarton> lilac: right
10:30:03 <lilac> rwbarton: i think that can be solved by NoImplicitPrelude and overloading (>>=) with a /weird/ type
10:30:27 <lilac> but not using a monad seems to be cheating somewhat
10:31:22 <newsham> ?type mfix return
10:31:24 <lambdabot> forall a (m :: * -> *). (MonadFix m) => m a
10:33:46 <lilac> are there any nontrivial monads for which "mfix return" != _|_ ?
10:34:40 <lilac> hmm. mfix return = Just _|_
10:35:04 <rwbarton> > mfix return :: Maybe Int
10:35:06 <lambdabot>   Just * Exception: stack overflow
10:35:18 * lilac ponders if "mfix return" = "return _|_"
10:35:18 <idnar> > mfix return :: IO Int
10:35:20 <lambdabot>   * Exception: "<IO Int>"
10:35:37 <leimy> > undefined
10:35:39 <lambdabot>   * Exception: Prelude.undefined
10:36:05 <idnar> > mfix return :: ST s
10:36:06 <lambdabot>       `ST s' is not applied to enough type arguments
10:36:06 <lambdabot>      Expected kind `*', ...
10:36:13 <idnar> > mfix return :: ST s Int
10:36:14 <lambdabot>   /tmp/4649096148769085239:70:47:
10:36:15 <lambdabot>      Not in scope: type constructor or clas...
10:36:22 <idnar> > mfix return :: ST.ST s Int
10:36:23 <lambdabot>       Failed to load interface for `ST':
10:36:23 <lambdabot>        Use -v to see a list of the f...
10:36:25 <leimy> wha?
10:36:26 <idnar> meh
10:36:33 <idnar> > mfix return :: Control.Monad.ST s Int
10:36:34 <lambdabot>       Not in scope: type constructor or class `Control.Monad.ST'
10:36:50 <lilac> @type \f -> let x = x >>= f in x
10:36:51 <lambdabot> forall (m :: * -> *) b. (Monad m) => (b -> m b) -> m b
10:37:02 <lilac> @type mfix
10:37:03 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
10:37:19 <idnar> lilac: what is a nontrivial monad?
10:37:31 <idnar> I can't think of any monad where mfix return = _|_
10:38:12 <rwbarton> > mfix return :: Identity Int
10:38:13 <lambdabot>       No instance for (Show (Identity Int))
10:38:13 <lambdabot>        arising from a use of `sho...
10:38:19 <lilac> idnar: indeed. i was excluding "data Void a; instance Monad Void where return a = undefined; a >>= f = undefined"
10:39:05 <lilac> (where mfix return = _|_, obviously)
10:39:07 <MarcWeber> mak__: Do you think I can help you somehow?
10:40:46 <rwbarton> can I get the types of free variables in an class method type in scope in its definition in an instance?
10:41:12 <mak__> MarcWeber: no thx, I solve it already, now I'm compiling scion
10:41:30 <mak__> compiled without problems
10:41:49 <MarcWeber> :) Fine have a look at the *markdown file. There is a vim section
10:43:57 <mak__> hmm maybe im dump and get wrong code but there isn't nothing abuto vim, except that there isn't supprot for vim
10:44:09 <MarcWeber> mak__: You should run the scion_server executable with -p and add set the TCP/IP config in vim for now
10:44:41 <MarcWeber> mak__: Doh. You;re right. It has vanished. Why? Wait a minute
10:44:48 <mak__> ;]
10:45:06 <MarcWeber> mak__:  line 68 ?
10:45:20 <TuringTest> Hmmm.... my regex bug list increases.  Who here is running on Linux?
10:46:04 <mak__> MarcWeber: line 68 of markdown file?
10:46:11 <MarcWeber> Yes
10:46:29 <mak__> empty
10:46:40 <MarcWeber> mak__: Oh.. Did you clone using git?
10:47:02 <mak__> yep
10:47:09 <MarcWeber> Do you have two branches?
10:47:13 <MarcWeber> (git branch)
10:47:24 <mak__> one
10:47:37 <MarcWeber> Then the other one isn't public..
10:48:45 <MarcWeber> mak__ git branch mw_multiple_protocols origin/mw_multiple_protocols --track; git checkout mw_multiple_protocols
10:52:33 <mak__> hmm git said that's not a valid name...
10:52:34 * true\false waves
10:52:41 <astrolabe> Does anyone know whether the microsoft layoffs http://www.nytimes.com/glogin?URI=http://www.nytimes.com/2009/01/23/technology/companies/23soft.html&OQ=_rQ3D2Q26hp&OP=17ea73b2Q2FQ27Q22TqQ27Q51YQ5CluYYi@Q27@GG!Q27GKQ27@oQ27iTQ5CmVY7YQ3CQ3EQ27Q5CYdLzVPTlQ27@olYaiQ2Bmid7 are likely to affect haskell people?
10:53:00 <MarcWeber> mak__ git branch -a ?
10:53:00 <true\false> I have just over a week off now.. I'm looking to pick up Haskell through 'Real world Haskell'
10:53:19 <true\false> If anybody knows if this is a good book to learn from? I'm a C#er..
10:53:31 <mak__> HEAD/hacking/master
10:54:36 <MarcWeber> mak__: http://rafb.net/p/f1ZMB594.html Strange. Why does your result differ?
10:54:40 <TuringTest> true\false: I am not use RWH is, by itself, a good way to learn Haskell from scratch.
10:55:31 <true\false> TuringTest: So it is or is not a reasonable choice?
10:56:13 <conal> s/use/sure/ ?
10:56:21 <newsham> rwbarton: thats neat, I'm saving it (http://codepad.org/9HJLpmYN)
10:56:36 <true\false> Ahh that makes more sense :) But as a starting point?
10:56:38 <Saya_> i think rwh is a good start
10:56:38 <astrolabe> @learn
10:56:39 <lambdabot> http://www.haskell.org/learning.html
10:56:49 <astrolabe> true\false: ^^^^^^^^^^
10:56:51 <mak__> MarcWeber: hmm dunno, but I download it again and now its ok...
10:57:16 <astrolabe> true\false: Yet Another haskell tutorial from there is good.
10:57:50 <true\false> astrolabe: Also a broken link :s
10:58:37 <true\false> Well ta, I found a mirror
10:58:38 <astrolabe> true\false: http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
10:58:51 <rwbarton> newsham: I'm trying to get it to work for forward jumps, using mdo, but the slides I found about implementing mdo in this situation have about 2 typos per code sample, so it's tough going
10:59:04 <Saya_> its not broken its just fugly
10:59:21 <true\false> astrolabe: Looks quite nice. But the RWH has a lot of other things which look interesting, and helpful to programming in general for me?
11:00:08 <sw17ch> where doe the DNS lookup functions hide?
11:01:52 <newsham> ?type Network.BSD.getHostByName
11:01:54 <lambdabot> Network.Socket.HostName -> IO Network.BSD.HostEntry
11:01:57 <newsham> ?type Network.BSD.getHostByAddr
11:01:59 <lambdabot> Network.Socket.Family -> Network.Socket.HostAddress -> IO Network.BSD.HostEntry
11:02:29 <Saya_> Well i suggest you try learning with one of these and see for yourself!
11:02:49 <sw17ch> newsham: thanks
11:02:51 <pumpkin> hai 2 u all!
11:02:53 <pumpkin> i iz elikwent
11:05:27 <Saya_> kthxbye!
11:06:06 <newsham> np
11:06:41 * TuringTest swears loudly at glib's regular expressions.
11:10:13 <vixey> :t \(v :: Void) -> case v of
11:10:14 <lambdabot> parse error (possibly incorrect indentation)
11:10:49 <pumpkin> I suppose it isn't possible to bind to a data constructor?
11:11:10 <dolio> Binding to a constructor is pattern matching.
11:11:16 <mak__> MarcWeber: I've got errors thata *.vim file isn't correct
11:11:22 <rwbarton> @type f
11:11:24 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
11:11:25 <rwbarton> @type Cont
11:11:26 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
11:11:28 <rwbarton> @type Cont f
11:11:29 <lambdabot> forall a r. (SimpleReflect.FromExpr r, Show r, Show a, Test.SmallCheck.Serial a) => Cont r a
11:11:31 <rwbarton> ?
11:11:43 <dolio> SmallCheck?
11:11:51 <MarcWeber> mak__ You can use :messages to review them again. Could you private msg them to me?
11:11:55 <rwbarton> Seems that Show is coming from somewhere
11:12:03 <vixey> :t f
11:12:04 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
11:12:12 <rwbarton> :t f :: ((a -> r) -> r)
11:12:13 <lambdabot>     Could not deduce (SimpleReflect.FromExpr r,
11:12:13 <lambdabot>                       Show r,
11:12:13 <lambdabot>                       Show a,
11:12:17 <rwbarton> hmm
11:12:32 <pumpkin> dolio: I mean say I had data X = A Int Int | B Int Int, could I do f (c x y) = c (x+1) y? Such that the c would be bound to the A constructor or the B one.
11:12:43 <rwbarton> I guess the FromExpr instance for a -> b
11:12:51 <dolio> pumpkin: Oh. No, that's not possible.
11:13:06 <pumpkin> it seems like a generalization of the *** in arrow
11:13:12 <pumpkin> well, in one direction anyway
11:13:21 <dons> any Haskellers in NY?
11:13:23 <vixey> well you can write it as a view
11:13:32 <vixey> f (foo -> (c, x, y)) = c (x+1) y
11:14:16 <rwbarton> By default, the first Int in "A Int Int" would be morally unrelated to the first Int in "B Int Int"
11:14:16 <lilac> foo A x y = (A, x, y); foo B x y = (B, x, y)
11:14:53 <pumpkin> I don't want a triple
11:14:59 <rwbarton> data X = A { a, b :: Int } | B { a, b :: Int} ; f x = x { a = 1} -- does that work?
11:15:01 <vixey> , left foo (Left x) = (Left, x) ; foo (Right y) = (Right, y) ;  f (foo -> (c, x)) = c (c x) in  f (Left 3)
11:15:02 <lunabot>  luna: parse error on input `='
11:15:05 <pumpkin> I want to reconstruct the same constructor, with the function applied
11:15:09 <vixey> , let foo (Left x) = (Left, x) ; foo (Right y) = (Right, y) ;  f (foo -> (c, x)) = c (c x) in  f (Left 3)
11:15:10 <lunabot>  luna: Occurs check: cannot construct the infinite type:
11:15:12 <pumpkin> but it was mostly just curiosity
11:15:18 <vixey> , let foo (Left x) = (Left, x) ; foo (Right y) = (Right, y) ;  f (foo -> (c, x)) = c (x+1) in  f (Left 3)
11:15:19 <lunabot>  Left 4
11:15:21 <rwbarton> f x = x { a = a x + 1 } rather
11:15:35 <mauke> rwbarton: yes
11:15:37 <pumpkin> rwbarton: yeah, that should work, but I wanted to know whether it was psosible in general
11:15:47 <vixey> :t let foo (Left x) = (Left, x) ; foo (Right y) = (Right, y) in foo
11:15:48 <lambdabot> forall t a. Either t t -> (a -> Either a a, t)
11:15:54 <rwbarton> pumpkin: It's "dangerous" (non-sensical) in general.
11:16:40 <pumpkin> well, what got me started on it was the fact that I can't use Arrow's ***/&&&/first/second on the unboxed pair type :*: from UArr
11:16:48 <rwbarton> A 3 2 has nothing to do with B 3 2
11:16:53 <vixey> forall t. Either t t -> ((forall a. a -> Either a a), t)  would have been better
11:17:35 <pumpkin> and I was wondering whether the Arrow functions could be generalized somehow
11:18:03 <pumpkin> of course, you couldn't specifically with :*: because it has a constraint on its two parts
11:19:08 <dolio> (:*:) isn't actually unboxed.
11:19:14 <pumpkin> it's just strict?
11:19:23 <dolio> Polymorphic components never get unboxed (optimizationally speaking).
11:19:28 <pumpkin> ah
11:19:38 <dolio> Yeah, strict product.s
11:19:46 <pumpkin> is that an inherent limitation or just the fact that they haven't got it working in GHC?
11:20:08 <dolio> Which are actually probably nicer categorically than tuples.
11:20:42 <dolio> Well, it's a limitation with GHC's compilation model, probably.
11:20:55 <int-e> pumpkin: it's a hard problem; you have to specialise all code where the polymorphic component might end up without being boxed.
11:20:57 <dolio> If you committed to whole program optimization, you could probably do it.
11:21:05 <pumpkin> yeah
11:21:25 <pumpkin> so it would create n distinct specialized copies of all code that depended on it?
11:21:41 <dolio> Yeah. You'd have to do something more like C++ templates.
11:21:47 <pumpkin> I see
11:22:34 <int-e> does anybody know off hand which Cabal version introduced the wildcard  foo == 4.2.*  syntax for package dependencies?
11:22:35 <pumpkin> I've been tempted to write my own firstU/secondU/****/&&&& for them because I tend to use them a lot, but it's getting ugly quickly :P
11:22:51 <rwbarton> @djinn ((a -> r) -> r) -> (a -> (b -> r) -> r) -> (b -> r) -> r
11:22:52 <lambdabot> f a b c = a (\ d -> b d c)
11:23:11 <JoshTriplett> @help djinn
11:23:11 <lambdabot> djinn <type>.
11:23:11 <lambdabot> Generates Haskell code from a type.
11:23:11 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
11:23:18 <rwbarton> @undo do { x; y; z }
11:23:21 <lambdabot> x >> y >> z
11:23:38 <dolio> @djinn-add type Cont r a = (a -> r) -> r
11:23:55 <pumpkin> actually those should be firstS and secondS
11:23:58 <monochrom> next time ghc should hold a "boxing day special" :)
11:23:59 <pumpkin> according to the current naming scheme
11:24:12 <rwbarton> @pl let i = \a b c = a (\d -> b d c) in x `i` \_ -> y `i` \_ -> z
11:24:12 <lambdabot> (line 1, column 16):
11:24:12 <lambdabot> unexpected "="
11:24:12 <lambdabot> expecting pattern or "->"
11:24:23 <rwbarton> @pl let i = \a b c = a (\d -> b d c) in i x (\_ -> i y z)
11:24:23 <lambdabot> (line 1, column 16):
11:24:23 <lambdabot> unexpected "="
11:24:23 <lambdabot> expecting pattern or "->"
11:24:29 <rwbarton> @pl let i = \a b c -> a (\d -> b d c) in i x (\_ -> i y z)
11:24:29 <lambdabot> x . flip (const (y . flip z))
11:24:44 <rwbarton> @. unpl pl let i = \a b c -> a (\d -> b d c) in i x (\_ -> i y z)
11:24:45 <lambdabot> (\ j -> x (\ c -> y (\ g -> z g j)))
11:24:56 <rwbarton> I need @mediumpl :P
11:27:37 <JoshTriplett> I seem to have a problem getting GHC to do type inference that seems obvious to me: http://haskell.pastebin.com/m11fbe17
11:27:46 <JoshTriplett> Would someone mind looking at that and telling me what I've missed?
11:28:10 <JoshTriplett> (Yes, I realize I've attempted to do something insane.  Nevertheless, it seems like a well-structured insanity that GHC could handle. :) )
11:28:14 <vixey> I think:  instance Number (Prelude.Integer -> Prelude.IO ()) where
11:28:15 <vixey> is wrong
11:28:17 <lilac> @pl \c -> y (\g -> z g j)
11:28:19 <lambdabot> const (y (flip z j))
11:28:22 <vixey> how about just  instance Number (Prelude.IO ()) where
11:28:47 <JoshTriplett> vixey: That wouldn't provide the right type.
11:28:51 <lilac> @mediumpl result: \j -> x (const (y (flip z j)))
11:28:52 <lambdabot> Unknown command, try @list
11:29:05 <JoshTriplett> vixey: I really do want to allow converting an integer into either an integer or a function from integer to IO action.
11:29:15 <JoshTriplett> vixey: Look at main.
11:29:29 <rwbarton> JoshTriplett: I think you can't do it quite this way
11:29:31 <int-e> JoshTriplett: type classes are open - as far as the type checker is concerned, you may add a instance Number (Double -> IO ()) later.
11:29:41 <mauke> JoshTriplett: yeah, it doesn't know what you want to get from (fromI 5)
11:29:46 <rwbarton> JoshTriplett: Imagine you had more instances Number Foo, Number (Foo -> IO ()) -- how would ghc know which intermediate type to pick
11:29:59 <JoshTriplett> rwbarton: But I don't have those instances, and never will. :)
11:30:00 <lilac> JoshTriplett: what everyone else said
11:30:07 <JoshTriplett> rwbarton: Any way I can convince GHC that I know that?
11:30:12 <rwbarton> JoshTriplett: OK, so don't use type classes. :P
11:30:21 <JoshTriplett> rwbarton: Hrm?
11:30:51 <JoshTriplett> rwbarton: I don't see how I can implement this *without* type classes.
11:31:06 <dolio> Use two different function names.
11:31:28 <JoshTriplett> dolio: That won't work here.  As you can possibly guess, I really want to call fromI fromInteger, and then use NoImplicitPrelude.
11:31:28 <rwbarton> JoshTriplett: Well, I'm not sure what you mean by "this"; surely you know how to write "main = replicateM_ 3 (print 5)".
11:31:41 <JoshTriplett> rwbarton: Heh.  Yes, of course. :)
11:31:57 <JoshTriplett> rwbarton: But I'd like to massively abuse the language and write that as "3 5". :)
11:32:05 <dolio> Why?
11:32:42 <JoshTriplett> rwbarton, dolio: As a test case for something else, namely writing BASIC in Haskell, including line numbers. ;)
11:32:47 <idnar> hmm, I don't think I like http://haskell.org/haskellwiki/Qualified_names
11:32:48 <JoshTriplett> "because"
11:33:02 <rwbarton> JoshTriplett: Maybe it'd help to write  instance (Enum n) => Number (n -> IO ()) where ...
11:33:09 <Twey> idnar: Then don't use them
11:33:24 <Twey> Either qualify, *or* explicitly import
11:33:29 <Twey> If you don't like qualifying things, go for the latter option
11:33:36 <sw17ch> @index unsafePerformIO
11:33:37 <lambdabot> System.IO.Unsafe, Foreign
11:33:39 <Twey> Although you're stuck if it clobbers an existing function, of course
11:33:49 <JoshTriplett> rwbarton: Hmmm.  I'll try that, but I don't think it'll help.
11:33:54 <idnar> Twey: yes, that's what I'm saying
11:34:08 <rwbarton> I guess not.
11:34:14 <Twey> idnar: Why don't you like qualified imports?
11:34:35 <idnar> Twey: I find reading prefixes everywhere very distracting
11:35:10 <Twey> It wouldn't be everywhere
11:35:29 <dolio> idnar: I disagree with anything Henning Thielemann supports, as a rule. :)
11:35:30 <Twey> import Graphics.UI.SDL as SDL; blah blah blah; SDL.flip (foo)
11:35:34 <Twey> Haha
11:35:44 <idnar> Twey: except, it's more like
11:35:56 <idnar> Twey: import Graphics.UI.SDL as SDL; Moo.blah Baz.blah Quux.blah; SDL.flip (foo)
11:36:06 <idnar> I may have been influenced by writing lots of Python code, but I think the considerations are mostly the same in both languages
11:36:17 <flazz> i've read that unfoldr is a good way to implement split, can someone explain why?
11:36:33 <Twey> idnar: Nah, that's overuse
11:36:37 <mauke> just be happy that Haskell doesn't let you qualify keywords (hi, Perl!)
11:36:49 <idnar> (python has "from foo.bar import *" which is like "import Foo.Bar", "from foo import bar" which is like "import Foo.Bar as Bar", and "from foo.bar import baz" which is like "import Foo.Bar (baz)")
11:36:55 <Twey> There aren't that many functions that clobber other ones
11:37:14 <idnar> Twey: the wiki page I referenced says you should import /everything/ qualified
11:37:31 <dolio> Some people do go kind of crazy with the qualified names.
11:37:38 <dolio> Like wanting to ban unqualified import from the language.
11:37:53 <rwbarton> There are a lot of what I would describe as "fringe opinions" on the wiki.
11:38:02 <Twey> I personally like (short) qualified imports, especially when I'm initially developing something and don't know what functions I'll need yet
11:38:17 <dolio> And I've never understood why some people like "ModuleName.T" "ModuleName.C" and so on.
11:38:28 <Twey> So I often import qualified Foo as F; import qualified Bar as B; &c.
11:38:31 <idnar> if I'm just hacking, I'll probably just do "import Foo.Bar"
11:38:39 <idnar> and then turn it into an explicit import list once I start cleaning up
11:38:50 <JoshTriplett> I tend to use unqualified imports for everything unambiguous, but I like qualified imports so I can use "foo" and "Set.foo" in the same module.
11:38:55 <monochrom> Alt.Fetish.HatredFetish.Eric.Steven.Raymond.Die.Die.Die  :)
11:38:58 <idnar> once I'm more familiar with Haskell, I'll probably stop doing that, and just always use explicit lists
11:39:03 <idnar> monochrom: hahaha
11:39:05 <Twey> Haha
11:39:43 <Twey> idnar: Of course Java-like Graphics.UI.SDL.flip is hideous, but SDL.flip isn't really distracting
11:39:48 <monochrom> Control.Monad.MonadList.TheWrongWayToDoMonadList.Die.Die.Die
11:39:49 <Twey> You can just consider it part of the function name
11:39:51 <idnar> I guess I like the idea of things like "import Data.Map as M"
11:40:07 <idnar> Twey: well, that's fine, because it's a special case
11:40:14 <idnar> Twey: (clobbers something from the prelude)
11:40:18 <JoshTriplett> monochrom: Control.Monad.NotFunctor.Die.Die.Die
11:40:37 <idnar> uhm, can you do "import Graphics.UI.SDL (flip as sdlflip)" or something?
11:40:54 <dolio> Haskell's modules could stand to be a bit fancier, though. Like locally opening qualified modules and stuff.
11:40:58 <idnar> import Lingua.Romana.Haskelligata
11:41:12 <JoshTriplett> idnar: Or something.  import qualified Graphics.UI.SDL as SDL, then sdlflip = SDL.flip. :)
11:41:20 <dolio> And, uh, first-class ML-style parameterized modules.
11:41:29 <idnar> JoshTriplett: yeah, okay, I guess that's a bit awkward
11:42:00 <pumpkin> > how (formed babby)
11:42:02 <lambdabot>   http://www.somethingawful.com/flash/shmorky/babby.swf
11:42:07 <TuringTest> monochrom: But how do you really feel?
11:42:29 <monochrom> I really feel I am a computer.
11:42:48 <cinimod> @pl \x y -> (x+y,x+y)
11:42:49 <lambdabot> ap (ap . ((,) .) . (+)) (+)
11:42:59 <rwbarton> Hmm, why doesn't -XFunctionalDependencies imply -XMultiParamTypeClasses?
11:43:08 <TuringTest> monochrom: Computers do not feel.  They observe and wait.
11:43:17 <idnar> how is turing tested
11:43:28 <pumpkin> > (join (***) (+) . uncurry) x y
11:43:29 <lambdabot>   Couldn't match expected type `(b, b)'
11:43:31 <monochrom> That's what you think.
11:43:33 <pumpkin> :(
11:43:40 <rwbarton> JoshTriplett: how about this? http://haskell.pastebin.com/m8219d1c
11:43:46 <TuringTest> idnar: I am tested today by the #$%%$$%^#$@!# regexp bugs in OS X and Linux
11:43:48 <pumpkin> > (join (***) (+) . (. uncurry)) x y
11:43:48 <rwbarton> @quote wango
11:43:48 <lambdabot> wango says: do you like turing complete?
11:43:49 <lambdabot>   Couldn't match expected type `(b, b)'
11:44:04 <JoshTriplett> rwbarton: Reading...
11:44:14 <pumpkin> I don't like turing complete
11:44:25 <rwbarton> JoshTriplett: It's a bit specialized to this exact problem, but maybe it will be useful
11:44:28 <vixey> I don't like cricket
11:44:35 <pumpkin> @cricket
11:44:37 <lambdabot> Unknown command, try @list
11:44:37 <pumpkin> @quote cricket
11:44:38 <lambdabot> goltrpoat says: Lemma: three cats chasing a deranged cricket all over the living room at 4am does not provide for a good reading environment
11:44:38 <JoshTriplett> rwbarton: "specialized to this exact problem" works just fine for me. :)
11:45:25 <JoshTriplett> rwbarton: That looks...well, I hesitate to use the word "reasonable", but "understandable". :)
11:45:42 <vixey> "I don't like cricket, I love it!"
11:46:12 <rwbarton> I've basically just moved the need for a type annotation from "inside" the application (fromI 3) (fromI 5) to its result
11:46:31 <JoshTriplett> rwbarton: And since main already has one... :)
11:47:23 <JoshTriplett> rwbarton: What I want to end up with will look something like this: main = runBasic $ do 10 print "BASIC in Haskell" ; 20 goto 10
11:47:41 <lilac> JoshTriplett: wow
11:47:50 <lilac> that's ... um ... creative
11:47:50 <JoshTriplett> lilac: :)
11:47:52 <vixey> JoshTriplett, how do you intend to implement it?
11:47:59 <rwbarton> by totally abusing 'do' I assume
11:48:02 <vixey> lilac, it's pretty much the same as label/goto isn't it?
11:48:11 <JoshTriplett> rwbarton: That, and abusing NoImplicitPrelude.
11:48:16 <lilac> vixey: yep, pretty similar.
11:48:17 <rwbarton> vixey: We were trying to do it using monads
11:48:20 <edwardk> JoshTriplett: cute
11:48:30 <vixey> so anyone actually managed it yet?
11:48:37 <rwbarton> vixey: but you could also have >>= be a constructor and then just interpret the whole thing later
11:48:43 <JoshTriplett> rwbarton: Yup.
11:48:55 <vixey> that's cheating :(
11:48:58 <rwbarton> Kind of like Harpy or LLVM, I guess
11:49:00 <lilac> rwbarton had a working version of label/goto
11:49:01 <JoshTriplett> rwbarton: But I could interpret it dynamically using MonadCont or similar.
11:49:10 <pumpkin> mmorrow had a pretty elegant label/goto implementation
11:49:21 <pumpkin> it was on some hpaste
11:49:47 * lilac got as far as some type-checking code before getting distracted
11:50:13 <lilac> JoshTriplett: you're going to have do to Extreme Typeclass Hackery to avoid putting the stuff after the line number in brackets
11:50:22 <JoshTriplett> lilac: Yup. :)
11:50:36 <jway> foldr (\ x y -> (x+y)/2) 54 [3,4]  why does this give 16, not quite sure I get the foldr function
11:50:37 <JoshTriplett> lilac: Not to mention "print 2 + 2". :)
11:50:57 <vixey> > foldr (\ x y -> (x+y)/2) 54 [3,4]
11:50:58 <lilac> JoshTriplett: yow!
11:50:58 <pumpkin> JoshTriplett: make sure you also reject invalid BASIC!
11:50:59 <lambdabot>   16.0
11:51:00 <vixey> > foldr (\ x y -> (x+y)/2) 54 [3,4] :: Expr
11:51:01 <lambdabot>   (3 + (4 + 54) / 2) / 2
11:51:03 <monochrom> Why do you want line numbers? Even VB got rid of them.
11:51:07 <gwern> @undo getCacheTime = do now <- getCurrentTime; let tomorrow = addMinutes' (24 * 60) now; return (Just tomorrow)
11:51:07 <lambdabot>  Parse error at "=" (column 14)
11:51:09 <lilac> @yow
11:51:10 <lambdabot> I love ROCK 'N ROLL!  I memorized the all WORDS to "WIPE-OUT" in
11:51:10 <lambdabot> 1965!!
11:51:15 <rwbarton> pumpkin: at compile time?
11:51:18 <JoshTriplett> monochrom: You want to hold up VB as an example of good syntax? ;)
11:51:20 <gwern> @undo getCacheTime = do { now <- getCurrentTime; let tomorrow = addMinutes' (24 * 60) now; return (Just tomorrow); }
11:51:21 <lambdabot>  Parse error at "=" (column 14)
11:51:24 <JoshTriplett> monochrom: Do you really want to go down that road? :)
11:51:25 <pumpkin> rwbarton: at some time :)
11:51:35 <gwern> @undo do { now <- getCurrentTime; let tomorrow = addMinutes' (24 * 60) now; return (Just tomorrow); }
11:51:35 <lambdabot>  Parse error at ";" (column 93)
11:51:40 <gwern> @undo do { now <- getCurrentTime; let tomorrow = addMinutes' (24 * 60) now; return (Just tomorrow) }
11:51:40 <lambdabot>  Parse error at "}" (column 94)
11:51:43 <gwern> argh
11:51:46 <monochrom> I want to hold up VB as worst allowed syntax.
11:51:48 <jway> ah thanks vixey
11:51:53 <gwern> @undo do { now <- getCurrentTime; let tomorrow = addMinutes (24 * 60) now; return (Just tomorrow) }
11:51:53 <lambdabot>  Parse error at "}" (column 93)
11:51:58 <mauke> gwern: stop!
11:51:59 <gwern> ..forget it
11:52:10 <lilac> @undo do { 10 print "Hello"; 20 goto 10 }
11:52:11 <lambdabot> 10 print "Hello" >> 20 goto 10
11:52:12 <edwardk> I used something similar for a typed intermediate language at one point, using universal quantification over Cont to get <- syntax for result bindings.
11:52:29 <edwardk> (to build up an abstract syntax tree i could interpret)
11:53:15 <JoshTriplett> monochrom: To answer your question, I really do want to allow optional line numbers, just to satisfy people's ability to write things like "20 goto 10".
11:53:28 <rwbarton> JoshTriplett: What about 10 let x = 7?
11:53:38 <JoshTriplett> rwbarton: Yeah, still thinking about "let".
11:53:41 <mauke> > 10 let x = 7 in ()
11:53:42 <lambdabot>   <no location info>: parse error on input `let'
11:53:43 <monochrom> good luck
11:53:43 <rwbarton> JoshTriplett: will it be 10 let "x" = y?
11:53:57 <vixey> why don't you implement BASIC from scratch?
11:54:04 <Cale> let is a haskell keyword, so you can't rebind it
11:54:05 <vixey> this approach is silly
11:54:08 <monochrom> you should also satisfy people's ability to poke and peek
11:54:14 <JoshTriplett> vixey: You just answered your own question. :)
11:54:24 <vixey> no
11:54:34 <JoshTriplett> vixey: I want to do something silly.  Implementing a BASIC interpreter in Haskell would prove easy, but not silly. :)
11:54:44 <rwbarton> Cale: There's always LET though. :)
11:54:49 <cytzol> @hoogle throwDyn
11:54:50 <lambdabot> Control.Exception throwDyn :: Typeable exception => exception -> b
11:54:50 <lambdabot> Control.Exception throwDynTo :: Typeable exception => ThreadId -> exception -> IO ()
11:54:53 <Saizan> or let_
11:54:56 <Cale> rwbarton: good point
11:55:09 <monochrom> lET
11:55:18 <JoshTriplett> rwbarton: Yeah, conflicts with keywords seem easy enough to handle.  The inability to rebind the (=) syntax, not so much.
11:55:32 <JoshTriplett> rwbarton: But I don't mind requiring LET foo === bar, or something.
11:55:32 <monochrom> :=
11:55:43 <JoshTriplett> monochrom: Or that.
11:55:45 <JoshTriplett> Or just omitting the keyword "let".
11:55:47 <jway> foldr (\ x y -> (x+y)/2) 10 [3,4] :: Expr
11:55:50 <pumpkin> :t babby
11:55:50 <jway> > foldr (\ x y -> (x+y)/2) 10 [3,4] :: Expr
11:55:52 <lambdabot> Doc
11:55:53 <lambdabot>   (3 + (4 + 10) / 2) / 2
11:55:58 <JoshTriplett> Or abusing <-.
11:56:12 <jway> > foldr (\ x y -> (x+y)/2) 10 [3,4,5,6] :: Expr
11:56:13 <pumpkin> > how . formed $ babby
11:56:13 <lambdabot>   (3 + (4 + (5 + (6 + 10) / 2) / 2) / 2) / 2
11:56:15 <lambdabot>   http://www.somethingawful.com/flash/shmorky/babby.swf
11:56:24 <jway> can I get hugs to write the output from lamdabot?
11:56:36 <JoshTriplett> I don't need the syntax to match BASIC to the last detail.  I just want it to "feel" like BASIC.
11:56:46 <JoshTriplett> :t formed
11:56:48 <lambdabot> forall a. a -> a
11:57:00 <Cale> :t babby
11:57:01 <monochrom> Algol had it right with := . Some smartass thought "that's too academic ivory tower" and used = .
11:57:02 <lambdabot> Doc
11:57:04 <newsham> ?src mconcat Sum
11:57:05 <lambdabot> Source not found. It can only be attributed to human error.
11:57:10 <newsham> ?src Sum mconcat
11:57:11 <lambdabot> Source not found. Wrong!  You cheating scum!
11:57:17 <rwbarton> ?src mappend Sum
11:57:17 <lambdabot> Source not found. Take a stress pill and think things over.
11:57:22 <rwbarton> ?src Sum mappend
11:57:23 <lambdabot> Source not found. It can only be attributed to human error.
11:57:23 <pumpkin> if you see a type signature forall a. a -> a, is that pretty much guaranteed to be id or bottom?
11:57:24 <mauke> monochrom: I disagree. := is definition, not assignment
11:57:38 <mauke> pumpkin: yes
11:57:38 <int80_h> good afternood haskell
11:57:49 <newsham> := is whatever you LET it be
11:57:57 <cytzol> afternoon, interrupt
11:58:20 <monochrom> = is not assignment anyway
11:58:30 <newsham> it is when it is
11:58:40 <olsner> except when it isn't!
11:58:43 <vixey> assignment isn't an equivalence relation
11:58:54 <newsham> and neither is = when it means assign
11:58:57 * vixey wishes a hex on anyone that uses = for assignment
11:58:57 <cytzol> Haskell should have used := instead of =, because it's the same width as :: and makes code look nicer.
11:59:21 <vixey> Haskell using = is fine
11:59:24 <edwardk> cytzol: that or i would have been happier with : for type signatures ;)
11:59:34 <cytzol> That works too!
11:59:35 <newsham> cytzol: you're not typesetting with variable-width fonts?
11:59:44 <Cale> = in Haskell isn't assignment though
11:59:47 <monochrom> I have a friend testifying: When he learned BASIC (his first encounter with programming), he didn't understand "X = X + 1".
11:59:54 <edwardk> I'm not a huge fan of how much of the Haskell world is devoted to special syntax for lists.
12:00:20 <cytzol> > length "::" - length "="
12:00:22 <lambdabot>   1
12:00:29 <Cale> Lists are our loops, they deserve at least a little special syntax
12:00:40 <newsham> > pointWidth "::" - pointWidth "="
12:00:41 <lambdabot>   Not in scope: `pointWidth'Not in scope: `pointWidth'
12:00:56 <jway> how do I get hugs to output <expr> of an expression
12:00:58 <pumpkin> edwardk: how much special syntax is there? the [ ] constructors?
12:01:03 <rwbarton> jway: You can't.
12:01:12 <rwbarton> jway: lambdabot is using the SimpleReflect package
12:01:13 <JoshTriplett> pumpkin: And list comprehensions.
12:01:18 <pumpkin> and being unable to reassign the (:) constructor I guess
12:01:21 <pumpkin> ah yes
12:01:22 <jway> rwbarton, ah that\s sad
12:01:26 <dolio> [a,b,c] [a..b]
12:01:32 <rwbarton> jway: Which you can get from hackage
12:01:47 <pumpkin> fair enough
12:01:53 <jway> thanks
12:01:53 <rwbarton> jway: though I have no idea whether it works with hugs
12:02:00 <pumpkin> you might say the second one is special syntax for Enum
12:02:02 <vegai> I sometimes wish the [ ] special syntax went into pattern matching too
12:02:15 <JoshTriplett> vegai: What do you mean?
12:02:19 <pumpkin> it does
12:02:21 <JoshTriplett> rwbarton: I tried your example, and it worked, but then when I tried to write a second line in the do it broke because it doesn't seem convinced that I want IO () and not IO a.  Paste momentarily.
12:02:31 <rwbarton> right
12:02:40 <rwbarton> :t (>>)
12:02:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
12:02:43 <rwbarton> because of that
12:02:44 <newsham> > let (:) = (+) in [1,2,3] -- would be an amusing way to fold
12:02:46 <lambdabot>       Constructor `:' should have 2 arguments, but has been given 0
12:02:46 <lambdabot>      In t...
12:02:53 <vegai> f [a,b,c] would be identical to f (a:b:c:[]), I guess
12:02:54 <edwardk> pumkin: [1,2,3,4] lists, [ | ] comprehensions, [1..n] [1,2..n] [1..] [1,2..] enumerations, the special syntax status of :, the special syntax of [] for Null, the special syntax recycling [a] in type signatures...
12:02:55 <int80_h> What's the prerequisites in understand haskell templates? I hear it referred to as advanced haskell, but what does that mean?
12:02:56 <rwbarton> newsham: tried that :P
12:03:16 <JoshTriplett> rwbarton: http://haskell.pastebin.com/m1f5c0ed6
12:03:18 <rwbarton> newsham: I wonder whether it would work if you defined your own type with a constructor named (:), but then I don't know about []
12:03:19 <dolio> newsham: 1 + 2 + 3 + []?
12:03:29 <pumpkin> edwardk: yeah, I see
12:03:48 <newsham> dolio: [] looks kinda like a zero
12:03:55 <JoshTriplett> rwbarton: Sorry, I don't quite see what you mean.
12:03:57 <pumpkin> newsham: you'd need an instance Num ([a])
12:04:00 <pumpkin> or something :)
12:04:14 <rwbarton> @undo do { 3 5; 4 8 }
12:04:14 <lambdabot> 3 5 >> 4 8
12:04:24 <rwbarton> so 3 5 has inferred type IO a, not IO ()
12:04:37 <rwbarton> and then the functional dependency doesn't kick in
12:04:43 <rwbarton> Of course, you can fix this with your own >>
12:05:06 <JoshTriplett> rwbarton: Oh, right.  You don't have to bind results just because you have them.  You can ignore them.
12:05:23 <JoshTriplett> rwbarton: That explains why this works fine: do () <- 3 5 ; 5 3
12:05:42 <edwardk> cale: i accept the fact that they are ingrained in the culture, I just nod to Larry Wall's note that the syntax for every language feature wants to use the colon ;)
12:05:55 <JoshTriplett> rwbarton: I guess it just seemed silly in a language like Haskell to call something that returned a result and then not bind the result.
12:06:02 <Gracenotes> > (\x y -> x) 3
12:06:03 <lambdabot>       Overlapping instances for Show (t1 -> t)
12:06:03 <lambdabot>        arising from a use of `...
12:07:27 <JoshTriplett> rwbarton: It occurs to me that given the limited uses of numbers in BASIC, I don't actually need a typeclass.  I could instead just make numbers always functions, and do magic in the numeric operators and the GOTO function.
12:08:09 <mauke> A++++ excellent language abuse, would hack again
12:08:58 <JoshTriplett> rwbarton: For instance, fromInteger :: Integer -> Statement -> LabeledStatement, have LabeledStatement include the label as a field, and then make the numeric operators like (+) apply the number to a dummy statement and extract the line number. :)
12:09:00 <vixey> lol
12:09:06 <JoshTriplett> mauke: :)
12:09:10 <vixey> @quote <mauke> A++++ excellent language abuse, would hack again
12:09:10 <lambdabot> No quotes for this person. You untyped fool!
12:09:25 <ray> @remember
12:09:25 <lambdabot> Incorrect arguments to quote
12:09:27 <mauke> vixey: stop putting < > in the quote database
12:09:39 <vixey> lambdabot: stop putting < > in the quote database
12:09:50 <pumpkin> @quote abuse
12:09:51 <lambdabot> shapr says: Windows users are like the wives of alcoholics, they'll take any amount of abuse and come right back.
12:09:51 <dcoutts> int-e: Cabal 1.6 added version wildcards. Hackage now enforces correct cabal-version field
12:09:54 <mauke> fixed in preflex :-)
12:09:54 <pumpkin> @quote abuse
12:09:55 <lambdabot> shapr says: Windows users are like the wives of alcoholics, they'll take any amount of abuse and come right back.
12:10:03 <vixey> @quote abuse,
12:10:03 <lambdabot> <mauke> says: A++++ excellent language abuse, would hack again
12:10:15 <int-e> dcoutts: thanks
12:10:24 <cytzol> @hoogle throwDyn
12:10:25 <lambdabot> Control.Exception throwDyn :: Typeable exception => exception -> b
12:10:25 <lambdabot> Control.Exception throwDynTo :: Typeable exception => ThreadId -> exception -> IO ()
12:10:31 <JoshTriplett> rwbarton: Thanks for all the help.
12:10:40 <cytzol> is my Control.Exception lacking throwDyn for a reason, or did I mess something up somewhere?
12:10:44 <dcoutts> sw17ch: I'm working on cabal-install-0.6.1 at the moment, you can try the darcs version now
12:11:02 <vixey> mauke, why not run lambdabot inside preflex?
12:11:06 <mauke> cytzol: you might be on ghc-6.10
12:11:11 <mauke> vixey: because I'm not insane
12:11:13 <int-e> cytzol: try with base-3.0.* instead of base-4.*
12:11:19 <cytzol> mauke: ok
12:11:31 <sw17ch> dcoutts: i might just do that
12:11:58 <int-e> cytzol: (ghc-6.10 comes with both, and base-4.* has a new extensible exception system which makes throwDyn superfluous.)
12:12:02 <Saizan> dcoutts: i've been rewriting Distribution.Simple.Haddock in the last days, should i also fix the order of running cpp/unlit or make separate patches?
12:12:05 <dcoutts> sw17ch: in particular the --constraint flag should now work with the solver
12:12:25 <dcoutts> Saizan: you're welcome to do it all in one if that's easier
12:12:51 <Saizan> dcoutts: ok :)
12:12:59 <dcoutts> Saizan: I think a big rewrites of that code is good but probably a bit risky for Cabal-1.6.0.2, but should be in 1.7.x dev version
12:13:30 <cytzol> int-e,mauke: that works, thank you!
12:14:04 <monochrom> shapr's quote on abuse should be changed to talk about "real world" languages.
12:14:05 <Saizan> dcoutts: the logic is inherently complex, but at least i've removed the unnecessary code duplication and found some bugs in the process
12:14:19 <dcoutts> Saizan: great
12:14:21 <vixey> monochrom, don't use those words ;(
12:14:44 <Twey> @quote shapr abuse
12:14:44 <lambdabot> shapr says: Windows users are like the wives of alcoholics, they'll take any amount of abuse and come right back.
12:14:48 <Twey> Heh
12:14:49 <dcoutts> Saizan: I know it's a bit complex, I think the the haddock-2.x and 0.x support was mingled in a very confusing way
12:15:11 <dcoutts> Saizan: so I look forward to your cleanup, much appreciated
12:15:47 <dcoutts> Saizan: I've been working on a cleanup of the GHC build code based on constructing a record of ghc command flags, but as a structure rather than [String]
12:15:58 <monochrom> vixey: which words?
12:16:14 <dcoutts> Saizan: so it should make it much easier to separate construction from use, and allow little hacks in a more modular way
12:17:01 <monochrom> Real world programmers are like the wives of alcoholics, they'll take any amount of abuse and come right back. Except for this problem of the analogy: wives don't get paid.
12:17:14 <monochrom> Oh even better:
12:17:14 <dcoutts> Saizan: the same approach might help with haddock, ie data HaddockOptions = HaddockOptions { optFoo :: ...; optBar :: ...; etc }
12:17:21 <monochrom> Real world programmers are like the wives of alcoholics, they'll take any amount of abuse and come right back. Except for this problem of the analogy: wives don't get paid, programmers don't get laid.
12:18:17 <dcoutts> Saizan: then things like renderHaddockOptions :: HaddockOptions -> [String]; libraryHaddockOptions :: PackageDescription -> Library -> HaddockOptions
12:19:53 <flazz> say i have two lists, how can i generate a list that is the cross product of those?
12:20:19 <PhilRod> [(x,y) | x<-xs, y<-ys ]
12:20:29 <flazz> PhilRod: simple as that?
12:20:33 * PhilRod wonders if he got it right
12:20:37 <pumpkin> liftM2 (,) xs ys
12:21:05 <PhilRod> ok, pumpkin's way is cooler
12:21:09 <pumpkin> > liftM2 (,) [1..4] [7..11]
12:21:11 <lambdabot>   [(1,7),(1,8),(1,9),(1,10),(1,11),(2,7),(2,8),(2,9),(2,10),(2,11),(3,7),(3,8...
12:21:14 <Saizan> dcoutts: ah, yeah, i've thought something similar but didn't actually implemented it, i think it should work well as a Monoid with WriterT
12:21:17 <monochrom> > [(x,y) | x<-[1,2,3], y<-['a','b','c']]
12:21:19 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
12:21:38 <mauke> > liftM2 (,) "foo" "bar"
12:21:40 <lambdabot>   [('f','b'),('f','a'),('f','r'),('o','b'),('o','a'),('o','r'),('o','b'),('o'...
12:21:45 <pumpkin> > (,) <$> [1..4] <*> [7..11]
12:21:47 <lambdabot>   [(1,7),(1,8),(1,9),(1,10),(1,11),(2,7),(2,8),(2,9),(2,10),(2,11),(3,7),(3,8...
12:21:55 <mauke> a.k.a. liftA2
12:21:56 <dcoutts> Saizan: the FooOptions types can usually be made into a Monoid pretty easily
12:22:23 <puusorsa> http://www.usc.edu/uscnews/stories/12543.html
12:22:43 <int80_h> @where hpaste2
12:22:43 <lambdabot> http://moonpatio.com:8080/
12:24:03 <vixey> "knowledge addiction"
12:24:24 <pumpkin> flazz: is that what you wanted? if you want the cross product in the 3d vector sense, that's obviously different
12:24:31 <pumpkin> but this is the cartesian product
12:24:47 <flazz> pumpkin: yes, cartesian product
12:25:08 <flazz> like if i have firstname and lastname lists and i wanted every possible choice
12:25:14 <pumpkin> yup
12:25:23 <flazz> so this list is lazily evaluated too?
12:25:36 <leimy> > [(a,b) | a <- [1..5], b <-[6..10]]
12:25:38 <lambdabot>   [(1,6),(1,7),(1,8),(1,9),(1,10),(2,6),(2,7),(2,8),(2,9),(2,10),(3,6),(3,7),...
12:25:52 <flazz> so if the sets are huge and i just take the 2nd one, it only does a little work?
12:25:58 <pumpkin> flazz: yup, but you need to be careful cause if one of them is infinite
12:26:07 <flazz> they are both finite
12:26:08 <pumpkin> well, if the first one is infinite, it'll get "stuck" on it
12:26:21 <pumpkin> should be fine then
12:26:22 <vixey> if the first is infinite it'll be stuck on the second
12:26:31 <liff> how does Chan work in case of multiple readers and/or writers?
12:26:31 <vixey> > liftA2 (,) [1..] "xyz"
12:26:32 <pumpkin> oh yeah :)
12:26:33 <lambdabot>   [(1,'x'),(1,'y'),(1,'z'),(2,'x'),(2,'y'),(2,'z'),(3,'x'),(3,'y'),(3,'z'),(4...
12:26:39 <liff> the documentation is a bit terse..
12:26:39 <vixey> mm no
12:26:45 <pumpkin> if the second is infinite then
12:26:48 <pumpkin> one of them :P
12:26:49 <vixey> If the second is infinite, it'll get stuck on the first
12:26:56 <pumpkin> > liftA2 (,) [1,2] [1..]
12:26:58 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12)...
12:27:03 <pumpkin> there we go
12:27:40 <bos> liff: it does nothing special
12:27:56 <flazz> pumpkin: if i call length of that set will it have to evaluate it all?
12:28:00 <vixey> Has anyone written a ReadP instance which is actually a pretty printer?
12:28:15 <pumpkin> flazz: it'll have to get the "Spine" of the list, but doesn't have to evaluate each element
12:28:26 <pumpkin> flazz: so in the simple case, it'll be basicall all of it
12:28:30 <liff> bos: what would that be?
12:30:45 <liff> bos: i mean, does one writer's object get sent to every reader or just one?
12:31:18 <bos> liff: Chans are intended for use by one reader
12:31:43 <bos> liff: if you want multicast, use dupChan
12:32:07 <liff> right
12:33:07 <mauke> I'm thinking about writing a parser, and I'm not sure about the operations I should provide and the typeclasses I should define for it
12:33:32 <int80_h> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=852#a852
12:33:44 <int80_h> This is problem 1 (and 2) pg 98 RWH
12:33:45 <vixey> mauke, do you mean like ReadP/Parsec or like a use of ?
12:33:56 <int80_h> I don't understand the compile time error I recieved.
12:33:57 <mauke> like ReadP/Parsec
12:34:10 <vixey> how does it work?
12:34:33 <mauke> I haven't started with the implementation yet
12:34:46 <vixey> why do you write a new library? :p
12:34:53 <mauke> because all existing parsers suck
12:34:55 <pumpkin> use arrows!
12:35:01 <mauke> pumpkin: why?
12:35:02 <vixey> ReadP doesn't suck, does it?
12:35:08 <vixey> I haven't found out what's bad about it yet, anyway
12:35:09 <mauke> vixey: no error messages? sucks.
12:35:12 <pumpkin> mauke: because they're cool and one should always use cool things
12:35:19 <mauke> pumpkin: monads are better
12:35:23 * pumpkin is so good at reasoned arguments
12:35:36 <vixey> you can make it give error messages
12:35:47 <mauke> vixey: how?
12:35:53 <pumpkin> mauke: make it bytestring-based!
12:36:07 <pumpkin> or flexible
12:36:08 <mauke> pumpkin: I'll make it class-based
12:36:11 <pumpkin> so it can accept both
12:36:15 <pumpkin> cool
12:36:39 <mauke> what's a good name for class X a s | s -> a where {f :: s -> b -> (a -> s -> b) -> b} ?
12:36:54 <monochrom> arrows are better
12:38:08 <mauke> int80_h: wrong argument order
12:38:54 <dolio> StateTMaybeCPS? :)
12:39:09 <mauke> I'm thinking more of Stream
12:40:33 <monochrom> stream sounds right. explains why there is an "a" in "s -> b -> (a -> s -> b) -> b"
12:40:53 <dolio> Stream is what parsec uses.
12:41:01 <monochrom> f seems to be some iterator over a stream.
12:41:39 <int80_h> mauke: I thought it goes (some function) (some value) (some value)
12:41:48 <mauke> int80_h: so?
12:41:55 <int80_h> foldr :: (a -> b -> b) -> b -> [a] -> b
12:42:03 <int80_h> mauke: so isn't that what I have?
12:42:21 <mauke> int80_h: no, you have Int -> String -> Int
12:42:37 <mauke> so the compiler concludes a = Int, b = String, b = Int, String /= Int, error
12:42:54 <Deewiant> Related: why does foldl take a -> b -> a and foldr a -> b -> b (i.e. why is one flipped)
12:43:10 <int80_h> mauke: wait, were you saying that I had the wrong argument order for foldr?
12:43:16 <mauke> int80_h: no
12:43:32 <___AJ___> I'm trying to install phooey and running into problems. Where can I find Data.Pair and Data.Reactive?
12:43:41 <Deewiant> ?hoogle Data.Pair
12:43:42 <lambdabot> No results found
12:43:46 <Deewiant> ?hoogle Data.Reactive
12:43:46 <lambdabot> package reactive
12:43:55 <Deewiant> well, one out of two :-P
12:43:58 <idnar> heh
12:44:06 <___AJ___> I tried reactive and it has FRP.Reactive
12:44:16 <___AJ___> no Data.Reactive anywhere :(
12:44:17 <int80_h> mauke: so I have the wrong argument order for stoi?
12:44:27 <Deewiant> ___AJ___: try an older version
12:44:40 <___AJ___> ah ok
12:44:48 <Deewiant> (I don't know, just guessing)
12:44:48 <___AJ___> no idea about Data.Pair then?
12:44:52 <Deewiant> nope
12:45:18 <Deewiant> ?google Haskell Data.Pair
12:45:21 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-accessor
12:45:21 <lambdabot> Title: HackageDB: data-accessor-0.2.0.2
12:45:31 <Deewiant> Are you feeling lucky? ;-)
12:45:57 <___AJ___> heh okay thanks Deewiant!
12:47:01 <mauke> int80_h: well, the real problem seems to be that loop is a foldl, not a foldr
12:47:42 <int80_h> mauke: ah, well I admit I was guessing it was a foldr, I didn't really know
12:47:58 <___AJ___> no cigar with Data.Pair
12:48:07 <___AJ___> google ignores '.'
12:48:23 <___AJ___> basically got the first result with both data ad pair
12:50:44 <mauke> so ... about this parser interface
12:50:46 <tony__> my teacher's assignments are always so vague, the goal is always so unclear!
12:51:37 <mauke> I think I want an instance of Monad and the functions anyToken, failure, label, <|>
12:51:58 <mauke> and try, notFollowedBy, <|||> and maybe <||>
12:52:07 <bos> @seen augustss
12:52:07 <lambdabot> augustss is in #haskell. I don't know when augustss last spoke.
12:52:08 <mauke> I'm not sure if I should provide <||>
12:52:42 <mauke> semantics: anyToken returns the next input element, if any
12:52:51 <mauke> failure takes no arguments and just fails
12:53:21 <mauke> label attaches a name to a parser; if that parser fails without consuming any input, its errors are replaced by the name
12:53:34 <gwern> @pl foo r@(Response {rsBody=body}) =  setHeader "Content-Encoding" "gzip" $ r {rsBody = compress body}
12:53:34 <lambdabot> (line 1, column 17):
12:53:34 <lambdabot> unexpected "{"
12:53:34 <lambdabot> expecting variable, "(", operator or ")"
12:53:38 <mauke> <|> is non-deterministic choice
12:53:46 <gwern> oh good grief
12:54:14 <mauke> try also takes a parser, pretending it didn't consume any input when it fails
12:54:17 <vixey> mauke, will <|> be fair ?
12:54:21 <vixey> ReadP +++ is fair
12:54:26 <mauke> vixey: what is fair?
12:54:48 <vixey> well you know in parsec how executing   x <|> y   may do something very different to   y <|> x
12:54:59 <vixey> but with ReadP  x+++y  has the same execution as  y+++x
12:55:00 <mauke> parsec's <|> is <|||>
12:55:28 <idnar> <||!|!|!|!|||>
12:55:31 <mauke> i.e. try left path first, and if it fails without consuming input, try the right path
12:55:43 <mauke> <||> is also left-biased, but without the input restriction
12:57:51 <mauke> oh wait
12:57:54 <dolio> mauke: Fair is 'causes space leaks'. :)
12:58:05 <mauke> I don't want to provide notFollowedBy, only followedBy
12:58:12 <mauke> and getInput
12:58:20 <mauke> dolio: I doubt that
12:58:55 <daf> having my code work first time once it has compiled is still a lovely surprise to me
12:59:18 * cjb gets that occasionally with python in flymake-mode
12:59:19 <vixey> it's the way daf :)
12:59:36 <pumpkin> it's not always the case, but there's a much higher probability of it being right after it compiles
12:59:37 <pumpkin> it is nice
12:59:41 <mauke> dolio: what space leaks there?
12:59:50 <daf> cjb: it's statements like that that make me wonder whether I should invest in learning emacs
13:00:30 <cjb> daf: yeah.  my life as a python programmer got much happier when I turned on flymake.
13:01:12 <cjb> wrote about it here:  http://blog.printf.net/articles/2007/10/15/productivity-a-year-on
13:01:12 <daf> perhaps I could get the same effect by abandoning Python and continuing to write Haskell in vim :P
13:01:40 <dolio> mauke: Arbitrarily large amounts of backtracking.
13:02:02 <mauke> dolio: I don't think <||> would solve that
13:03:12 <daf> cjb: well, I suppose there are two separate things
13:03:14 <dolio> What's <||>? I haven't used parsec in a while.
13:03:45 <cjb> daf: m_stone tried to get flymake style things working in vim, I think he had some success
13:04:03 <daf> cjb: pylint and flymake; pylint would be easier to start using, but flymake would also benefit my Haskelling
13:04:15 <cjb> ah, yes
13:04:31 <mauke> dolio: it's not in parsec
13:04:49 <daf> oh really? I tried playing with doing something like that in vim (perhaps after reading your blog post, actually) and just got depressed at how stupid vim's design is
13:04:54 <mauke> I defined <|> and <||> in analogy to C :-)
13:05:15 <anthonymiller> daf: why is vim's design stupid?
13:05:28 <dolio> Oh, x <||> y = try x <|> y?
13:05:41 <mauke> yeah, pretty much
13:05:55 <dolio> Okay. Yeah, that re-introduces leak potential.
13:06:19 <dolio> The input restriction is what solves it in parsec.
13:06:30 <mauke> there's another solution: do a breadth-first parse
13:06:44 <mauke> that solves the problem for <|>, but not <||> (I think)
13:07:31 <daf> anthonymiller: I think http://upsilon.cc/~zack/blog/posts/2008/11/from_Vim_to_Emacs_-_part_2/ is a pretty good argument
13:08:15 <daf> its mainloop is very inflexible
13:08:19 <daf> and its scripting language is rubbish
13:08:27 <anthonymiller> interesting
13:08:34 <multiholle_> how to make an "IO a" out of an "a" to do somethink like this: x <- a
13:08:45 <pumpkin> return
13:08:52 <pumpkin> why not just do let x = a?
13:09:55 <mauke> vim sucks ... in some areas. too bad emacs is unusable.
13:10:12 <multiholle_> yeah of course, had a blockhead....
13:10:48 * erikc can't use a non-modal editor
13:10:50 <daf> (on the other hand, I'm very very comfortable using vim most of the time and I fear that learning emacs would be a huge investment of time)
13:11:02 <anthonymiller> haha
13:11:05 <erikc> i get by ok in emacs with viper/vimpulse
13:11:20 <erikc> and viemu for visual studio is a godsend
13:11:43 <daf> heh
13:11:59 <daf> my significant other uses a vi mode for firefox
13:12:02 <daf> I'm not *that* bad
13:12:03 <tromp__> > let a=0 in let x=a in let a=x in a
13:12:05 <lambdabot>   0
13:12:06 <mauke> vimperator++
13:12:33 <anthonymiller> daf: vimperator is pretty cool
13:12:35 <anthonymiller> hehe
13:13:08 <erikc> ideally, i'd want something with the visual looks of Textmate, the scripting of emacs and the modality of vim
13:13:20 <daf> we should all be using yi
13:13:30 <daf> and customising it to our hearts' desires
13:13:32 <anthonymiller> daf: yi?
13:13:47 <mauke> no, not the scripting of emacs
13:13:56 <mauke> I want a language with real scoping, please
13:14:05 <daf> anthonymiller: http://www.haskell.org/haskellwiki/Yi
13:14:09 <vixey> lexical scope is overrated
13:14:10 <daf> yeah, elisp--
13:14:23 <vixey> open any math textbook
13:14:29 <mauke> I wonder what happened to climacs
13:14:39 <anthonymiller> yi looks cool
13:15:24 <mauke> vixey: I don't program my editor with math textbooks
13:15:53 <anthonymiller> i always wished there was some sort of music editor that had a similiar philosophy to some of these text editors...
13:17:46 <djahandarie> Is lookup O(n) ?
13:17:51 <mauke> which one?
13:17:59 <pao> Hi all
13:18:07 <Cale> vixey: The only thing which makes non-lexical scopes work for mathematics textbooks is the fact that the people interpreting the textbooks are smart.
13:18:11 <pao> I've got StateT Foo [] a
13:18:23 <pao> I'd like to merge all solutions
13:18:37 <djahandarie> mauke, on a list
13:18:44 <pao> according the value of a, without running the StateT
13:18:47 <mauke> djahandarie: you can't do better than O(n) on a list
13:18:51 <pao> any idea?
13:18:56 <Cale> (and there usually is some implicit notion of scope regardless)
13:19:19 <djahandarie> mauke, okay, I was just wondering if the list was abstracted to a binary tree or something in the background without Haskell telling. :P
13:19:35 <mauke> no, there is no magic here
13:19:44 <CyberGarp> 2 things, what's up with hpaste and can someone look at another syntax error I have with IO/records
13:20:30 <quile> anthonymiller: i wrote a music editor based on vi in 1994
13:21:15 <asgaroth> @where hpaste2
13:21:15 <lambdabot> http://moonpatio.com:8080/
13:21:36 <rwbarton> Maybe the topic should be changed
13:21:57 <pumpkin> oh no, BONUS found a homeless armadillo!
13:22:02 <Cale> We should get hpaste2 running on hpaste.org
13:22:19 <CyberGarp> I put it on pastie.org: http://pastie.org/368132
13:22:35 <Cale> (or get the DNS entry changed...)
13:22:35 <CyberGarp> The last statement in a 'do' construct must be an expression
13:22:52 <Cale> CyberGarp: that means that you ended a do-block in something like  v <- x
13:22:58 <Cale> or a let, I suppose.
13:23:04 <rwbarton> CyberGarp: That's kind of a poor error message
13:23:05 <CyberGarp> bingo, I used a let.
13:23:16 <asgaroth> CyberGarp: Just leave out the 'in'
13:23:21 <rwbarton> CyberGarp: you could indent the 'in return ...', or just delete 'in'
13:23:31 <Cale> ah, okay
13:23:49 <Cale> (I can't see the paste yet :)
13:23:57 <byorgey_> yeah, 'let' in a do-block is subtly different than 'let' in an expression.
13:24:03 <rwbarton> it was:
13:24:05 <byorgey_> the former needs no 'in'...
13:24:07 <rwbarton> do let x = 1
13:24:09 <rwbarton>    in return x
13:24:13 <byorgey_> it's just a declaration
13:24:14 <Cale> ah
13:24:33 <rwbarton> Which should really give a better error message than "The last statement in a 'do' construct must be an expression"
13:24:34 <monochrom> This is the first paste site I encounter with colour themes.
13:24:36 <CyberGarp> I take out the 'in' and then I have a different error:
13:24:37 <CyberGarp>     Couldn't match expected type `Double'
13:24:38 <CyberGarp>            against inferred type `IO Double'
13:24:38 <CyberGarp>     In the second argument of `(+)', namely `dt''
13:24:38 <CyberGarp>     In the expression: (t cell) + dt'
13:24:38 <CyberGarp>     In the definition of `t'': t' = (t cell) + dt'
13:24:47 <Cale> CyberGarp: For reference, here's how do-notation desugars:
13:24:54 <Cale> do { x } = x -- base case
13:25:01 <anthonymiller> what can you do with () ?
13:25:13 <Cale> do { x ; <stmts> } = x >> do { <stmts> }
13:25:21 <Cale> do { v <- x ; <stmts> } = x >>= \v -> do { <stmts> }
13:25:29 <monochrom> You can pattern-math with ().  case x of () -> "whee!"
13:25:34 <Cale> do { let <decls> ; <stmts> } = let <decls> in do { <stmts> }
13:25:47 <monochrom> > case () of () -> "whee whoa!"
13:25:47 <CyberGarp> anthonymiller, construct a cantor number system?
13:25:49 <lambdabot>   "whee whoa!"
13:25:55 <rwbarton> anthonymiller: you can make it be the argument of a type constructor, like [()]
13:26:05 <byorgey> CyberGarp: dx' <- (getLevy rng 1 1)/fps'
13:26:08 <byorgey> looks wrong
13:26:09 <Cale> anthonymiller: () is a type used when there's nothing interesting to report.
13:26:18 <byorgey> CyberGarp: what's the type of getLevy?
13:26:42 <Cale> anthonymiller: Particularly handy for things like IO (), which is the type of IO actions that have no interesting result.
13:26:43 <byorgey> maybe you want  dx' <- liftM (/fps') (getLevy rng 1 1) ?
13:26:52 <Cale> anthonymiller: (that is, they're executed only for effect)
13:27:01 <asgaroth> or you might want to put it in the let instead of using <-
13:27:04 <Cale> :t putStrLn "Hello"
13:27:05 <lambdabot> IO ()
13:27:16 <CyberGarp> getLevy ::  RNG -> -> Double
13:27:16 <CyberGarp>            -> Double
13:27:16 <CyberGarp>            -> IO Double
13:27:21 <CyberGarp> errr.
13:27:31 <CyberGarp> getLevy :: RNG -> Double -> Double -> IO Double
13:27:45 <asgaroth> Ah, then you need liftM
13:27:46 <CyberGarp> getLevy is the whole reason the IO Monad was invoked.
13:27:47 <byorgey> CyberGarp: ok, right, so getLevy returns a monadic result.  so you can't divide an IO Double by a Double directly.
13:28:01 <byorgey> CyberGarp: so you'll have to use the thing with liftM that I wrote above.
13:28:07 <leimy> Is threadDelay the only sleep function in the GHC distibution?
13:28:13 * CyberGarp light goes off above head
13:28:19 <byorgey> liftM 'lifts' a pure function into a monad.
13:28:32 <Cale> :t liftM
13:28:33 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
13:28:34 <asgaroth> or "(/fps') <$> getLevy .. " which looks nicer than liftM (in Control.Applicative) :)
13:28:41 <Cale> Personally, I tend to use fmap
13:28:43 <byorgey> true =)
13:28:49 <Cale> :t fmap
13:28:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:29:02 <leimy> Cale: are all Monads Functors by definition?
13:29:15 <Cale> leimy: yes, though the library doesn't presently ensure this
13:29:16 <asgaroth> Yes
13:29:20 <byorgey> leimy: all monads are functors, but not all Monads are Functors.
13:29:23 <Cale> leimy: (but it could)
13:29:30 <byorgey> unfortunately.
13:29:37 <rwbarton> If you come across a Monad which is not a Functor, you are entitled to complain loudly.
13:29:43 <Cale> It's a bug for a declared instance of Monad not to come with an instance of Functor
13:29:49 <leimy> sounds good :-)
13:29:51 <Cale> You can always just write:
13:30:01 <pumpkin> Cale: how would you ensure that? with quickcheck fmap = liftM?
13:30:02 <Cale> instance Functor M where fmap = liftM
13:30:07 <pumpkin> oh
13:30:08 <pumpkin> :)
13:30:13 * leimy is also fond of the fmap
13:30:18 <leimy> FYI :-)
13:30:19 <Cale> (once you have an instance of Monad)
13:30:26 <leimy> I almost never use liftM
13:30:29 <Cale> liftM is the proof that all monads are functors ;)
13:30:49 <CyberGarp> thanks guys I'm back on track.
13:30:51 <asgaroth> Wouldn't a general instance (Monad m) => Functor m where ... automatically make all monads functors?
13:30:56 <Cale> (which is kind of strange sounding, for people used to the mathematical definition)
13:30:57 <rwbarton> I think it's the proof that all Monads are functors. :)
13:30:58 * CyberGarp off to get coffee and chocolate as reward.
13:31:11 <byorgey> asgaroth: that doesn't do what you think.  it would overlap with every instance of Functor.
13:31:12 <Cale> rwbarton: yes, that's a better way to put it :)
13:31:24 <leimy> I was going to say, *are* all Functors Monads?
13:31:42 <pumpkin> nope
13:32:00 <Cale> leimy: Most functors are not monads.
13:32:13 <asgaroth> byorgey: Is there some way to make that constraint do what I intend? i.e. only define an instance if m is a Monad?
13:32:14 <pumpkin> exactly 23% of all functors are monads
13:32:17 <leimy> I was thinking Monad was a bit more restrictive :-)
13:32:18 <Cale> hehe
13:32:21 <byorgey> asgaroth: not currently.
13:32:39 <Cale> pumpkin: Random functor theory ;)
13:32:50 <pumpkin> maybe it's 6/pi^2
13:32:55 * pumpkin shrugs :)
13:32:57 <byorgey> asgaroth: well, I think you can do some crazy stuff with -XOverlappingInstances and -XIncoherentInstances and other scary flags to make it work sometimes. maybe.
13:32:59 <Cale> That would actually be quite interesting.
13:33:08 <leimy> 47.2% of all statistics are made up on the spot
13:33:26 <pumpkin> leimy: 65% of made-up statistics are wrong
13:33:26 <Cale> Put a distribution on finite categories, say, and work out the actual statistics regarding their endofunctors.
13:33:39 <asgaroth> byorgey: My suggestions would actually result in a lot of "could not deduce Monad Foo from context .." errors for all the functors that aren't monads, right?
13:33:45 <leimy> 60% of the time, sex panther works... every time.
13:34:06 <byorgey> asgaroth: yes, probably.
13:34:33 <dolio> I'm Ron Burgundy?
13:34:39 <byorgey> I'm guessing the functors which are also monads would have measure zero.
13:36:10 <asgaroth> byorgey: How so? I thought that any sensible monad instance would also provide a functor instance?
13:36:25 <BMeph> Here's the heart- (and deal-)breaker: are any Monads not Functors? :)
13:36:34 <multiholle_> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=854#a854 gives the error "The last statement in a 'do' construct must be an expression" but I'm not quite sure why... anyone an idea?
13:36:44 <intoverflow> what a sick world Haskell would be if it has Monads which weren't functors
13:36:48 <byorgey> asgaroth: of course, I was talking about the other way around.
13:37:19 <mauke> multiholle_: are you using tabs?
13:37:30 <multiholle_> no all with spaces
13:37:40 <BONUS> that indentation is messed up bro
13:37:42 <asgaroth> byorgey: Hmm, so you meant "functors that _aren't_ monads have measure zero"?
13:37:42 <byorgey> multiholle_: it's hard to tell, but it looks like the last line is indented one space too few
13:38:09 <intoverflow> asgaroth: no, he meant that monads are rare among the class of endofunctors
13:38:10 <byorgey> multiholle_: it must be in the same column as the 'newState' on line 7, or else it ends the do-block
13:38:27 <byorgey> what intoverflow said.
13:38:48 <rwbarton> multiholle_: your case statement makes me all kinds of nervous what with the negative integer literals and misaligned cases.
13:38:58 <rwbarton> multiholle_: but, I don't see how it can really cause this problem
13:39:07 <mauke> hehe
13:39:13 <mauke> I blame line 14
13:39:18 <BONUS> also try indenting that -2 to the right
13:39:28 <BONUS> i think it has to be right of the c in the above "case"
13:39:38 <intoverflow> endofunctors are at least as common as objects in the category, but monads are much more special than that.  they come from adjunctions between the category and some other place; it's not obvious to me what would make that situation nearly so common
13:39:44 <mauke> BONUS: no
13:39:56 <mauke> the problems are in line 14 and 16
13:40:06 <u5h> a) what's the zero for type string and
13:40:12 <u5h> b)
13:40:14 <mauke> ""
13:40:14 <asgaroth> excuse my ignorance, but how does an endofunctor look like in Haskell in contrast to a `normal' functor?
13:40:18 <u5h> i thought so
13:40:24 <u5h> oh right
13:40:28 <u5h> can you calculate the length of a list
13:40:30 <u5h> recursively!
13:40:33 <BONUS> mauke: you're right
13:40:34 <u5h> without an accumulating parameter
13:40:40 <vixey> u5h, yes
13:40:43 <byorgey> u5h: sure you can.
13:40:43 <BONUS> very carefully
13:40:44 <mauke> u5h: trivially
13:40:45 <BONUS> ehehehe
13:40:49 <u5h> how
13:40:53 <vixey> u5h, try it
13:40:55 <BONUS> very carefully
13:40:59 <mauke> am I doing your homework here?
13:41:03 <intoverflow> asgaroth: an endofunctor is just a functor from a to a
13:41:04 <u5h> nope
13:41:07 <u5h> i tested out of this class ;)
13:41:08 <byorgey> asgaroth: all Haskell Functors are endofunctors.
13:41:20 <byorgey> from the category of Haskell types to itself.
13:41:21 <u5h> eer, the class where you have to learn haskell
13:41:24 <mauke> length [] = 0; length (_ : xs) = 1 + length xs
13:41:34 * u5h smacks his had
13:41:40 <u5h> e
13:41:41 <asgaroth> Ok, thanks. I always get baffled when trying to apply my very vague understanding of the concept to haskell
13:42:05 <dolio> > let length [] = 0 ; length (_:xs) = 1 + length xs in length [1..1000000]
13:42:07 <lambdabot>   * Exception: stack overflow
13:42:15 <intoverflow> yeah, haskell is a reasonable place to apply mathematical intuition, but it fails hard at being a good place to do the usual math
13:42:28 <u5h> really?
13:42:32 <dolio> > let length [] = 0 ; length (_:xs) = 1 + length xs in length [1..1000000] :: Natural
13:42:37 <lambdabot>   1000000
13:42:44 <mauke> ooh
13:42:51 <asgaroth> I guess it'll get better once I get to college and learn some real math there.
13:43:09 <u5h> college is overrated
13:43:14 <byorgey> ooh, \bot has Natural?  nice =)
13:43:17 <u5h> too many aging bald dudes
13:43:21 <u5h> not enough nude chicks
13:43:29 <int80_h> I have only come here seeking knowledge. The kind they would not teach me of in college.
13:43:30 <BMeph> I blame line 17 (the -1 case). :)
13:43:41 * intoverflow imagines what a world this would be if value was measured in number of nude chicks
13:43:55 <dolio> Maybe you picked the wrong college.
13:43:55 <u5h> you don't think it already is?
13:44:03 <intoverflow> int80_h: what dolio said
13:44:07 <int80_h> heh
13:44:11 <u5h> i already know that much, dolio
13:44:25 <BONUS> ah yes, the perfect example of why girls tend to stay out of CS, hehe
13:44:33 <intoverflow> BONUS: no joke
13:44:49 <u5h> i get all the girls that go into CS
13:44:53 <u5h> that's why you don't meet them
13:44:58 <u5h> they're in my massive harem complex in sudan
13:45:01 <byorgey> u5h: let's keep the discussion to Haskell, please.
13:45:09 <intoverflow> what byorgey said
13:45:16 <byorgey> you can talk about whatever you like in #haskell-blah.
13:45:16 <int80_h> what intoverflow said
13:45:18 <u5h> what intoverflow said
13:45:21 * u5h glares at int80_h
13:45:24 <BONUS> less noise, more signal
13:45:28 <BMeph> What byorgey said. :)
13:45:33 <BMeph> Ditto, BONUS. :)
13:45:33 <u5h> less signal, more noise!
13:45:46 <u5h> #haskell-blah is lame
13:46:08 <BMeph> u5h: Why don't you go and throw up now... ;)
13:46:19 <u5h> now why do you say that
13:47:18 <u5h> anyway, i'd love to argue with you all until i get banned, but i have class
13:47:38 * u5h waves goodbye
13:47:40 <vixey> gooda
13:47:46 <dibblego> bye
13:48:28 <int80_h> @where hpaste2
13:48:28 <lambdabot> http://moonpatio.com:8080/
13:49:12 <noZone> That was an unusual conversation for this channel.
13:51:24 <int80_h> noZone: expect more. As the channel gets more popular, so come the trolls.
13:51:53 <noZone> *bleh*
13:51:56 <vixey> noZone, nice thing is how 99.999% of the people here aren't some chauvinistic idiots.. :p
13:52:05 <vixey> noZone, unlike /other/ IRC channels
13:52:16 <noZone> yes... and it's very refreshing
13:52:31 <BONUS> what i like about #haskell is that it's relaxed and friendly while still being on topic
13:52:35 <dibblego> > 99.999 * 627
13:52:36 <lambdabot>   62699.373
13:52:56 <BONUS> but yeah lately some people tend to come in, ask a #haskell related question and then just veer offtopc
13:52:57 <byorgey> percent fail
13:53:16 <mauke> @let percent = (/100)
13:53:18 <lambdabot>  Defined.
13:53:23 <byorgey> I'm pretty sure u5h has gotten banned multiple times before.
13:53:27 <byorgey> under different nicks.
13:53:29 <mauke> > (99.999 `percent`) * 627
13:53:30 <lambdabot>   626.9937299999999
13:53:34 <Taejo> :t (%)
13:53:35 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
13:53:46 <joma> where is the best place to discuss webapp architecture etc?
13:53:55 <Taejo> > let (%) = (/ 100) in (99 %)
13:53:55 <BONUS> i wonder if anything will come out of this new HAppS revival thing
13:53:56 <lambdabot>   0.99
13:53:58 <byorgey> so anyway, "Fun with phantom types" by R. Hinze from "The fun of programming" is pretty cool =)
13:53:59 <joma> like what is the great challenge for huge apps like facebook etc?
13:54:08 <vixey> byorgey, it's not ushdf or whatever ?
13:54:21 <vixey> u5h looks like a l33t version... but I didn't assume
13:54:25 <byorgey> maybe, I'm not sure
13:54:33 <int80_h> BONUS: I hope so. I have visions of wordpress clones etc...
13:54:42 <byorgey> there aren't too many people from syr.edu
13:54:44 <vixey> byorgey, I saw a neat thing using phantom types for type directed partial evaluation
13:54:59 <byorgey> vixey: cool, where?
13:55:02 <vixey> can't remember the name of it...,  but that was an application of phantoms I hadn't seen
13:55:12 <vixey> probably have it saved on here somehwhere...
13:55:49 <BONUS> got a link to the pdf or something?
13:55:50 <int80_h> I found the whole idea of web programming to be pedestrian, until people started making tools in haskell.
13:55:53 <BONUS> for fun with phantom types
13:55:57 <waern> is it generally considered better to specify language extensions via LANGUAGE pragmas than turning on options for a whole package using -Xoptions?
13:56:18 <vixey> aha, www.brics.dk/RS/01/16/BRICS-RS-01-16.pdf
13:56:19 <byorgey> BONUS: it's linked from here: http://www.seas.upenn.edu/~sweirich/cis670/09/
13:56:30 <Taejo> waern, I don't know about others, but I think so
13:56:38 <BONUS> thanks!
13:56:40 <joma> BONUS: what happs revival thing?
13:56:41 <byorgey> waern: generally, yes
13:56:46 <vixey> byorgey, oh are you still implementing a dependent typed language?
13:56:52 <waern> Taejo, me too
13:56:52 <pumpkin> BONUS: did the armadillo thank you for the peanut?
13:56:58 <gwern> I wonder why 'svn log' is so dead slow
13:57:05 <BONUS> hehe did indeed
13:57:08 <byorgey> vixey: not at the moment, but perhaps in the future.
13:57:21 <vixey> ah ok
13:57:29 <waern> ok, thanks, then I can rely on this fact when thinking about Haddock improvements
13:58:10 <waern> with 'options' in that sentence above I mean extensions of course
13:58:21 <int80_h> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=852#a855
13:58:51 <int80_h> joma: hAPPs was ophaned for about a year. someone forked it, and is trying to rally people behind his cause.
13:58:57 <rwbarton> I think for Cabal packages it's suggested that you list the extensions in the .cabal file and not as LANGUAGE pragmas in individual files.
13:59:14 <rwbarton> In fact, I think I heard that in the future the latter will be disallowed
13:59:15 <gwern> really?
13:59:28 <gwern> I could've sworn the latter was preferred...
13:59:33 <pumpkin> the latter is so much easier
13:59:34 <gwern> since it lets you load in ghci
13:59:37 <joma> inth80: how do you mean pedestrian? and what did haskell tools change?
13:59:38 * Heffalump would prefer the latter for most extensions
13:59:38 <int80_h> oh, my moonpatio paste is an exercise from chapter 4 RWH. It's not quite doing what I want, and my visualization of what's happening doesn't match what actually happens.
13:59:39 <rwbarton> Yeah, I know.
13:59:43 <pumpkin> me too
13:59:48 <dcoutts> rwbarton: actually I suggest you use both.
13:59:59 <Heffalump> there's a few things I just want everywhere, like -XNoMonomorphismRestriction
14:00:08 <dcoutts> rwbarton: at some point Cabal will enforce that all extensions are listed in the .cabal file
14:00:16 <int80_h> joma: uninspired. And all you have to do is look at hackage to see the many, many web related tools.
14:00:24 <rwbarton> dcoutts: OK, that makes more sense.  I must have misunderstood before
14:00:52 <rwbarton> dcoutts: will that be separate from the current mechanism, where cabal turns on all the extensions you list in every file?
14:00:54 <int80_h> so if someone could walk me through what's actually happening with my code, I can figure out why I'm visualizing things wrongly
14:01:15 <joma> int80_h: but are they better and more exciting then? because i find the python frameworks and libs to very good.
14:01:35 <dcoutts> rwbarton: right, that's the problem, we're trying to move to a system where the extensions describe what extensions the package uses, not ones that are applied to every module
14:02:02 <rwbarton> dcoutts: sounds good
14:02:31 <int80_h> joma: more engaging. See, I'm not interested in web programming as such, but in haskell. SO where haskell goes, I'm more likely to be interested.
14:03:00 <hukolele> i need hints or suggestions on a design matter, how can i abstract video in haskell? i have streams of frames, and each one can be a Picture, an Audio or Subtitle or other,
14:03:25 <kmeyer> is there some sort of function like take that returns the first n and also the remainder?
14:03:39 <kmeyer> @search [a] -> ([a], [a])
14:03:39 <lambdabot> Unknown command, try @list
14:03:45 <mauke> @hoogle Int -> [a] -> ([a], [a])
14:03:45 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
14:03:45 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
14:03:45 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
14:03:48 <hukolele> in OOP i think it would be straight, an abstract class Frame an derived ones, but in haskell im a little bit confused with type classes, or algebraic data types or what
14:03:49 <pao> :t StateT $ map (\lm -> (lm, "")) . (undefined::[Int] -> [Int]) . map fst . runStateT undefined
14:03:50 <lambdabot> StateT [Char] [] Int
14:03:50 <hukolele> ever
14:04:03 <gwern> dcoutts: ah, I see. so extensions: will mean 'this extension is used somewhere', not 'enable this for all files'
14:04:11 <kmeyer> mauke: thanks
14:04:12 <gwern> that ameliorates my main concern then
14:04:13 <vixey> hukolele, other than the name, classes in haskell are really unlike OO style classes
14:04:20 <pao> anyone can suggest a way to simplify that expression? is it possibile to avoid "re-entering" the monad?
14:04:56 <pao> :t StateT $ map (\lm -> (lm, "")) . (undefined::[Int] -> [Int]) . map fst . runStateT undefined
14:04:57 <lambdabot> StateT [Char] [] Int
14:05:17 <hukolele> i know, if i use a type class Frame i can add types to it without recompiling, right? but i cant have a list of Frames
14:05:22 <hukolele> of diferent types
14:05:32 <pumpkin> nuncanada: you can sort of think of typeclasses as interfaces/abstract superclasses, but I wouldn't recommend it
14:05:37 <pumpkin> whoops, I meant hukolele
14:05:44 <pumpkin> not sure how that happened
14:05:54 <mauke> hukolele: well, you can with existential wrappers
14:05:57 <int80_h> pumpkin: take a look at me code?
14:05:57 <Taejo> hukolele, whatever change you make, you'll have to recompile :)
14:06:41 <hukolele> Taejo but its simpler add a type to a class than add a new Constructor to a type
14:06:47 <rwbarton> hukolele: if you take the typeclass/existentials approach, you'll instead have to change your type whenever you want to change the operations you can perform on a Frame.
14:08:24 <Taejo> IOW, with typeclasses, you can add a type in one place but if you add an operation, you have to do it in multiple places; with an algebraic datatype, you have to change lots of code to add a type, but can add an operation in one place
14:08:42 <rwbarton> This situation is called "the expression problem", there are a bunch of papers about it
14:09:22 <pumpkin> int80_h: where?
14:09:33 <Taejo> in this case, I'd guess the set of operations here is basically limited to render, so typeclasses/existentials approach is probably good
14:09:35 <pumpkin> does anyone have any links to running gitit instances?
14:11:54 <hukolele> thx for the points, ill try both
14:11:56 <dons> isn't the gitit site, and lhc site, running off gitit?
14:12:54 <pumpkin> I tried googling gitit but couldn't even find the site
14:12:57 <pumpkin> only the github repo
14:13:01 <pumpkin> @where gitit
14:13:02 <lambdabot> I know nothing about gitit.
14:13:15 <Cale> For a raytracer, I can recommend explicit existentials, that is, just pass sets of appropriate functions around.
14:13:25 <int80_h> pumpkin:http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=852#a855
14:13:33 <int80_h> pumpkin : http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=852#a855
14:14:02 <rwbarton> Right, the typeclasses in typeclasses/existentials are optional :)
14:14:10 <pumpkin> int80_h: why you sticking it into a list?
14:14:13 <pumpkin> [xs]
14:14:18 <mlesniak> What is the simplest way to make some strings bold on the console? The normal ANSI-Codes *does!* not seem to work (or I use them in the wrong way)
14:15:05 <dcoutts> mlesniak: there are other Haskell progs that use ANSI console codes, I don't think they do anything special
14:15:10 <dcoutts> see for example HsColour
14:15:38 <quicksilver> mlesniak: depends on your terminal.
14:16:19 <BMeph>  mauke: Have you tried Sleep lately? ;)
14:16:21 <int80_h> pumpkin: let me look at it again
14:16:31 <mlesniak> quicksilver: Ok, so I'll give it a second try
14:16:33 <pumpkin> what's the gitit site?
14:16:38 <mauke> BMeph: what
14:16:44 <mlesniak> dcoutts: quicksilver: Thanks
14:17:14 <BMeph> mauke: http://sleep.dashnine.org/
14:17:35 <rwbarton> mlesniak: putStrLn "\ESC[1mfoo\ESC[0m"  works for me
14:18:02 <BMeph> pumpkin: This is NOT the gitit site, just to let you know. :)
14:18:07 <mlesniak> rwbarton: Ahhh, \ESC -- thanks!
14:18:08 <pumpkin> didn't think so :P
14:18:12 <vixey> XMLambda
14:18:12 <quicksilver> ghc -e 'putStrLn "\ESC[1mfoo\ESC[0m"'
14:18:15 <quicksilver> works for me too.
14:18:35 <quicksilver> > say "\ESC[1mfoo\ESC[0m"
14:18:37 <lambdabot>   Not in scope: `say'
14:18:42 <quicksilver> > text "\ESC[1mfoo\ESC[0m"
14:18:43 <lambdabot>   [1mfoo[0m
14:18:49 <quicksilver> bah. IRC--.
14:19:07 <mauke> we're +c
14:19:11 <quicksilver> I know.
14:19:18 <quicksilver> I campaign against it occasionally.
14:19:23 <quicksilver> But the pensioners shout me down.
14:19:32 <int80_h> +c ?
14:19:32 <mauke> 4/ju>/st:/ u2/se3/ i;/rs9/sig
14:19:37 <quicksilver> ;)
14:20:19 <quicksilver> int80_h: irc server mode which strips colour codes.
14:20:41 <pumpkin> int80_h: did you get it?
14:20:57 <dons> bos: http://twitter.com/rgcottrell/statuses/1140308612
14:21:30 <pumpkin> maybe someone should start up a #haskell movement on twitter
14:21:37 <pumpkin> to tag haskell-related posts
14:21:40 <mauke> BMeph: $out = openf(">" . @ARGV[1]);
14:21:45 <mauke> BMeph: conclusion: sleep is retarded.
14:21:54 <bling> how do I read a char? read "12" :: Int only works for strings
14:22:18 <mauke> > read "'c'" :: Char
14:22:19 <lambdabot>   'c'
14:22:23 <bos> dons: wow!
14:22:42 <int80_h> pumpkin: When I don't use [], I get a type error
14:22:53 <bling> well from '1' to 1...
14:22:57 <int80_h> pumpkin: does that mean my type is wrong?
14:23:02 <mauke> > digitToInt '1'
14:23:04 <lambdabot>   1
14:23:10 <dons> bos, i pointed him out the 14k conn/s demo to give him hints last week
14:23:18 <pumpkin> int80_h: I think it's probably wrong :P
14:23:55 <ziman> @src (*>)
14:23:55 <lambdabot> (*>) = liftA2 (const id)
14:24:01 <dcoutts> @seen augustss
14:24:01 <lambdabot> augustss is in #haskell. I don't know when augustss last spoke.
14:24:01 <int80_h> pumpkin: It seems to me, it has to be Int -> String -> Int
14:24:03 <pumpkin> int80_h: you're confused with manual recursion and fold
14:24:04 <ziman> @src (<*)
14:24:05 <lambdabot> (<*) = liftA2 const
14:24:16 <pumpkin> int80_h: you don't need a "base case" on stoi for empty list
14:24:18 <ziman> @thanks
14:24:18 <lambdabot> you are welcome
14:24:25 <pumpkin> int80_h: the foldl will call you once for every list element
14:24:30 <CosmicRay> is there a function out there anywhere to convert a CalendarTime to ZonedTime?
14:24:43 <dcoutts> augustss: I'm still wondering about the cabal ticket you reported about the --package-conf= / --package-db= flag.
14:24:51 <pumpkin> as it stands, when you do [x], there is one list element of type string, and stoi is matching x:xs to that and giving you digitToInt x
14:26:09 <killerboy> hi, when trying to compile lambdabot i've got: Setup: lambdabot.cabal:55: Parse of field 'build-depends' failed:
14:26:31 <ozy`> :t (<*)
14:26:32 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
14:26:36 <killerboy> i've downloaded it through darcs
14:26:43 <mauke> (<*) is indeed awesome
14:26:48 <dcoutts> killerboy: if that field has == x.* in it, then update your version of Cabal/cabal-install
14:26:52 <int80_h> pumpkin: if stoi's second argument isn't supposed to be a String, I don't know what it should be
14:27:01 <pumpkin> int80_h: char
14:27:23 <dcoutts> killerboy: if you're running cabal-install then cabal install cabal-install to get the latest version (0.6.0)
14:27:34 <rwbarton> @type foldl
14:27:35 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:27:40 <pumpkin> does it look like http://johnmacfarlane.net/index.html is gitit? I'm trying to sell gitit to a friend of mine by showing him instances of it
14:27:49 <killerboy> i don't have cabal-install, where could i get it?
14:27:55 <int80_h> pumpkin: ah , foldl takes the front Char in the String. You're right I was confusing fold and manual recursion
14:27:56 <pumpkin> killerboy: hackage!
14:28:12 <pumpkin> int80_h: yeah, it gives you one element at a time :)
14:28:15 <vixey> (o -> x -> o) -> (o -> f x -> o)
14:28:29 <pumpkin> o o o o
14:28:47 <ozy`> @djinn o -> o -> o -> o
14:28:47 <lambdabot> f _ _ a = a
14:29:07 <vixey> and   (o -> x -> m o) -> (o -> f (m x) -> m o)   ?
14:29:13 <ozy`> @djiin it -> hurts -> my -> eyes
14:29:14 <lambdabot> -- f cannot be realized.
14:29:37 <int80_h> pumpkin: well this makes doing negative numbers tricker than I had first imagined
14:29:54 <kiris> anyone know how to get a complete module list from hoogle?
14:29:55 <pumpkin> int80_h: yeah :)
14:30:39 <byorgey> pumpkin: looks like it, from the source
14:30:53 <BMeph> mauke: Why is that retarded (explain in -blah, please)? :)
14:31:00 <byorgey> pumpkin: the source looks auto-generated and mentions pandoc
14:31:02 <pumpkin> he might just be using the same xhtml generator
14:31:13 <pumpkin> the .html extensions could be fake/rewrites
14:31:15 <pumpkin> but I dunno
14:31:21 <pumpkin> I'd expect him to use his own wiki for his site
14:31:34 <byorgey> pumpkin: true, I have no idea.
14:31:36 <pumpkin> and some of it is strangely different
14:31:49 <pumpkin> ><head vs. <div id="body" class="wrapper">
14:31:56 <pumpkin> ah well
14:31:58 <kiris> tired of typing module names out in emacs
14:31:59 <pumpkin> not that important
14:32:15 <kiris> I want to use ido-mode to do it for me but.. where to get a module list?
14:33:14 <leimy> Man, I hope microsoft's laying off of research folks doesn't impact ghc.
14:33:20 <leimy> or those involved.
14:33:33 <pumpkin> I thought it was mostly people in the game systems area
14:33:37 <byorgey> pumpkin: ah, I think it's not actually gitit, he just uses pandoc to generate it
14:33:51 <pumpkin> ah
14:35:03 <gwern> pumpkin: examples of gitit: http://lhc.seize.it/ http://johnmacfarlane.net:5001/
14:35:20 <CosmicRay> @hoogle CalendarTime -> ZonedTime
14:35:21 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
14:35:21 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
14:35:21 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
14:35:24 <pumpkin> gwern: no examples of darcs gitit? :D
14:35:31 <pumpkin> (but thanks)
14:35:32 <CosmicRay> bah you suck hoogle
14:35:36 <gwern> pumpkin: it's unreleased
14:35:39 * gwern shrugs
14:35:41 <pumpkin> gwern: yeah, just being silly
14:35:51 * CosmicRay is trying to switch HDBC to new time
14:35:54 <int80_h> leimy: wait a minuite, Microsoft laid off ghc researchers? Is there a url?
14:36:02 <leimy> no...
14:36:03 <CosmicRay> I am unsure of how to convert a CalendarTime to a ZonedTime
14:36:09 <CosmicRay> specifically the isDST field
14:36:10 <leimy> Microsoft announced layoffs are coming
14:36:19 <leimy> and that they'd be from research and other areas.
14:36:22 <gwern> int80_h: they laid off 5k people in various divisions, including research
14:36:32 <leimy> well they will lay off 5k people
14:36:33 <gwern> I didn't see any names or whether MS Research is included
14:36:35 <leimy> over the year
14:36:38 <vixey> does this mean haskell is over??
14:36:43 <int80_h> hah, yeah right
14:36:48 <leimy> yes haskell is doomed.
14:36:52 <leimy> enjoy it while you can :-)
14:36:54 <pumpkin> @hogole CalendarTime -> LocalTime
14:36:54 <gwern> vixey: alas, yes. SPJ was single-handedly keeping this community alive!
14:36:54 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
14:36:54 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
14:36:54 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
14:36:57 <SubStack> dooooooomed
14:36:57 <pumpkin> lol
14:37:01 <lucca> vixey: hah
14:37:05 <gwern> now we will begin vicious infighting until there's only one
14:37:13 <int80_h> there can be only one!
14:37:13 <pumpkin> CosmicRay: looks like ZonedTime is just a type with a LocalTime in it + timezone, maybe look for conversions from CalendarTime to LocalTime?
14:37:19 <kiris> peyote `simon` joints won't let it happen
14:37:30 <int80_h> I vote for people who have x86 register allusions in their names.
14:37:37 <CosmicRay> pumpkin: but that is the part I know how to do.
14:37:45 <ozy`> pumpkin: ..."@hogole"?
14:37:51 <CosmicRay> pumpkin: the meaning of ctIsDST and timeZoneSummerOnly are not clear to me
14:37:58 <pumpkin> ozy`: I suck, but lambdabot unsucks me
14:38:02 <pumpkin> oh
14:38:02 <SubStack> 'd' : (cycle "o") ++ "med"
14:38:04 <leimy> @hogole poop
14:38:04 <lambdabot> No results found
14:38:08 <leimy> ?
14:38:23 <leimy> :t cycle
14:38:23 <ozy`> @hgooel desu -> desu -> desu
14:38:24 <pumpkin> @hogole [a] -> [a]
14:38:24 <lambdabot> Unknown command, try @list
14:38:24 <lambdabot> forall a. [a] -> [a]
14:38:24 <lambdabot> Prelude cycle :: [a] -> [a]
14:38:24 <lambdabot> Prelude init :: [a] -> [a]
14:38:24 <lambdabot> Prelude reverse :: [a] -> [a]
14:38:50 <pumpkin> @lp \x -> x y x
14:38:50 <kmeyer> @hooogle Int -> [a] -> ([a], [a]
14:38:50 <lambdabot> Maybe you meant: . ? @ bf ft help id let map pl rc slap v wn
14:38:50 <lambdabot> Parse error:
14:38:50 <lambdabot>   --count=20 "Int -> [a] -> ([a], [a]"
14:38:50 <lambdabot>                                     ^
14:38:53 <kmeyer> @hooogle Int -> [a] -> ([a], [a])
14:38:54 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
14:38:54 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
14:38:54 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
14:38:55 <leimy> >  'd' : (take 10 (cycle "o")) ++ "med"
14:38:56 <lambdabot>   "doooooooooomed"
14:39:00 <gwern> well hopefully we'll see a gitit reHAHA DISREGARD THAT I SUCK LAMBDAS
14:39:01 <pumpkin> @pl \x -> x y x
14:39:02 <lambdabot> join ($ y)
14:39:23 <joma> @quote spj
14:39:23 <pumpkin> can such an x exist?
14:39:24 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
14:39:29 <pumpkin> I guess id
14:39:38 <pumpkin> :t \x -> x y x
14:39:39 <lambdabot>     Occurs check: cannot construct the infinite type:
14:39:40 <lambdabot>       t = Expr -> t -> t1
14:39:40 <lambdabot>     Probable cause: `x' is applied to too many arguments
14:40:10 <ozy`> gwern: I was recently informed that the capital lambda was a major gay pride symbol for a few decades there, so that's not necessarily so far off
14:40:14 <ddarius> pumpkin: Lambda bound variables are monomorphic (without [higher-rank] type signatures).
14:41:49 <Gracenotes> hm. The rules for evaluating Haskell could be probably considered a superset of the rules for evaluating an untyped lambda calculus, right?
14:42:03 <pumpkin> what's that email on -cafe about alloca giving memory on heap?
14:42:24 <killerboy> i'm extreme beginner in haskell, what do "import Paths_lambdabot (version)" means in haskell, i'm asking because i haven't found Paths_lambdabot anywhere, only in this file and one another which imports it too?
14:42:54 <kiris> it's provided by cabal
14:43:01 <kiris> for accessing files installed by cabal
14:43:02 <killerboy> oh, ok
14:43:06 <kiris> and stuff like that
14:43:27 <killerboy> so cabal knows about lambdabot?
14:43:34 <pumpkin> "alloca allocs memory in heap, so it should be safe if you are not going to allocate lots of megabytes." ??
14:43:38 <kiris> http://neilmitchell.blogspot.com/2008/02/adding-data-files-using-cabal.html
14:43:40 <BMeph> :t ($ ?f)
14:43:41 <lambdabot> forall a b. (?f::a) => (a -> b) -> b
14:44:36 <roconnor> I wonder how much my Modula-3 book is worth
14:45:21 <killerboy> kiris, thanks
14:45:22 * BMeph wonders when "Antique Book Roadshow" will air...
14:45:40 <anthonymiller> > :t appendFile
14:45:41 <lambdabot>   <no location info>: parse error on input `:'
14:45:47 <anthonymiller> @t appendFile
14:45:47 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
14:45:56 <anthonymiller> @type appendFile
14:45:58 <lambdabot> FilePath -> String -> IO ()
14:46:06 <anthonymiller> @type hAppendFile
14:46:07 <lambdabot> Not in scope: `hAppendFile'
14:46:13 <Taejo> anthonymiller, :t or @type, but not > :t
14:46:28 <anthonymiller> ^_^
14:46:53 <anthonymiller> @type hPutStrLn
14:46:55 <lambdabot> Not in scope: `hPutStrLn'
14:47:06 <kiris> :t Prelude.hPutStrLn
14:47:08 <lambdabot> Not in scope: `Prelude.hPutStrLn'
14:47:17 <kiris> ~ (@_ @)/`
14:48:03 <leimy> @src Text.Printf.printf
14:48:03 <lambdabot> Source not found. My brain just exploded
14:48:06 <leimy> doh!
14:48:54 <ozy`> > (\_@(_:_)->(/)`liftA2`(sum)(length))$"tasty"++"pizza"
14:48:55 <lambdabot>   <no location info>: parse error on input `@'
14:49:17 <mauke> printf = collect id
14:49:27 <pumpkin> ozy`: why use a @ there?
14:50:05 <ozy`> pumpkin: to see if it would work
14:50:14 <ozy`> > (\(_:_)->(/)`liftA2`(sum)(length))$"tasty"++"pizza"
14:50:15 <lambdabot>   Couldn't match expected type `[f a]'
14:50:21 <augustss> @seen dcoutts
14:50:21 <lambdabot> dcoutts is in #haskell, #ghc, #darcs, #haskell-soc, #gentoo-haskell and #haskell-overflow. I last heard dcoutts speak 22m 58s ago.
14:50:26 <int80_h> pumpkin: I did it! thanks :)
14:50:27 <dcoutts> hia augustss
14:50:31 <pumpkin> yay
14:50:40 <dcoutts> augustss: http://hackage.haskell.org/trac/hackage/ticket/464
14:50:43 <augustss> Are you telling me the flags I want are already there?
14:50:55 <dcoutts> augustss: I think so
14:50:59 <int80_h> stupid dentist appointment. I'm not finished with this!
14:51:10 <augustss> dcoutts: Maybe I'm using an old version
14:51:17 <dcoutts> augustss: I was just hoping to confirm it
14:51:28 <leimy> :t collect
14:51:28 <augustss> dcoutts: They didn't show up when I did --help
14:51:29 <lambdabot> forall a prop. (Testable prop, Show a) => a -> prop -> Property
14:51:33 <dcoutts> augustss: this flag is in Cabal-1.4+ I think
14:51:42 <leimy> @src collect
14:51:43 <lambdabot> Source not found. My brain just exploded
14:51:49 <augustss> dcoutts: I'll check tomorrow at work
14:51:59 <killerboy> Would it be enough if i add my plugin to Modules.hs and to lambdabot.cabal?
14:52:07 <dcoutts> augustss: ok, thanks
14:52:09 <vixey> have you seen this:  "Erik Meijer is an accomplished programming-language designer who has worked on a wide range of languages, including Haskell, Mondrian, X#, Cω, C#, and Visual Basic."
14:52:16 <vixey> and xsharp.com
14:52:25 <leimy> X#?
14:52:32 <vixey> .org **
14:52:33 <leimy> should I phear that?
14:52:37 <augustss> dcoutts: btw, is there a way to specify which .cabal file to use?
14:52:39 <vixey> yeah phear it
14:52:43 <mauke> XML based programming
14:52:47 <mauke> what could possibly go wrong
14:52:53 <dcoutts> augustss: not yet, except by cd'ing to the right dir
14:52:57 <leimy> my eyes could go blind
14:52:57 <byorgey> Erik Meijer worked on that !?!?
14:53:03 <byorgey> I refuse to believe that.
14:53:09 <leimy> I'm sad to say I'm a contributing author of "xar"
14:53:17 <augustss> dcoutts: I'd like to have several .cabal files in the same directory
14:53:18 <int80_h> mauke : Isn't that what people say right before their computers explode?
14:53:19 <leimy> distributed on every Mac that runs Leopard :-(
14:53:24 <mauke> int80_h: yep
14:53:24 <dcoutts> augustss: so would I
14:53:25 <vixey> byorgey, hehe :p
14:53:26 <leimy> XML archive.
14:53:26 <bling> is haskell actually used for some real and exciting? it is a very cool language, but  isn anyone really using it for something real?
14:53:42 <augustss> bling: what's real?
14:53:44 <mauke> bling: does a window manager count as real?
14:53:47 <ozy`> bling: people are writing lawnmower software in haskell. I kid you not.
14:54:04 <leimy> I played around with redoing it with a better TOC format than XML, but the fact that it started as a joke makes me feel better :-)
14:54:08 <ozy`> also, epic compiler is epic. GHC has awesome optimizations.
14:54:09 <int80_h> bling (morpheus impression) what is real? how do you define 'real'?
14:54:24 <byorgey> must be a different X#.
14:54:46 <killerboy> have anybody seen my question?
14:54:46 <idnar> byorgey: I think it's Xen
14:55:24 <idnar> as in the thing that got assimilated into Cω
14:55:37 <tentd> stating the obvious bad joke: http://en.wikipedia.org/wiki/Construction_of_the_real_numbers
14:55:37 <ozy`> was the Xen hypervisor named after the planet in Half-life?
14:55:52 <bling> computer games, machine learning, space rocket software, huge-scale webapps
14:56:18 <ozy`> bling: there's a QIII engine clone implemented in haskell
14:56:21 <bling> ozy`: you mean like a robot-lawnmower?
14:56:47 <int80_h> bling: no, software around inventory and other buisness needs.
14:56:47 <ozy`> bling: you know, I'm not too clear on that. gimme a minute
14:56:48 <bling> ozy`: frag? well was that ever used for something real? what is that guy doing today?
14:57:08 <int80_h> it's buisness software, that it's for lawnmowers is incidental.
14:57:48 <ozy`> bling: it was never sold in stores if that's what you're asking. I know it's not being actively maintained, either
14:58:10 <bling> and what is the guy doing? wokring in the video games industry?
14:58:20 <ozy`> hell if I know
14:58:31 <int80_h> I hope not...video game programmers don't get paid shit.
14:58:37 <mauke> machine learning? is this the 80s?
14:59:05 <kiris> mauke: do you hear rick astley?
14:59:07 <kiris> wait
14:59:24 <jeffwheelerPhone> @pl repeat' x = fix (x:)
14:59:24 <lambdabot> repeat' = fix . (:)
14:59:54 * Taejo is never gonna give mauke up, never gonna let him down
15:00:06 <Taejo> kiris, yes, he hears Rick Astley
15:00:21 <mauke> you are now breathing manually.
15:00:38 <kiris> you are now typing manually
15:01:25 <ray> you are now singing never gonna give you up, manually
15:01:26 <br1> Anybody works with EHC here? I'm having trouble loading the prelude.
15:01:41 <pumpkin> > how (formed babby)
15:01:43 <lambdabot>   http://www.somethingawful.com/flash/shmorky/babby.swf
15:01:52 <pumpkin> (manually)
15:01:57 * anthonymiller is grepping for Astley
15:02:03 <conal> i love how old manual type-writers didn't have a "1" key.
15:02:17 <pumpkin> they used the L?
15:02:23 <ozy`> pumpkin: yeah
15:02:27 <Taejo> all your distinct characters are belong to a single glyph
15:02:34 <pumpkin> I'm sure the typographers were happy with that
15:02:40 <ozy`> and <!> was <'> + <.>
15:02:54 <Taejo> ! = ' <backspace> .
15:02:55 <conal> and people had to get used to the idea that there is more to a character than what it looks like.  mind blowing!
15:03:05 <Taejo> oh, ozy` beat me
15:03:07 <mauke> 1lI|! oO0Ø rnm
15:03:10 <ozy`> typesetting was completely separate from typewriting
15:03:29 <conal> ozy`: wow.  i forgot about that one '^H.
15:04:39 <Taejo> @how is babby formed?
15:04:39 <lambdabot> Maybe you meant: show yow
15:04:56 <mauke> @vixen how is babby formed?
15:04:56 <lambdabot> how? it depends...
15:05:02 <mauke> excellent answer
15:05:15 <ozy`> > how (shot web)
15:05:16 <lambdabot>   Not in scope: `shot'Not in scope: `web'
15:05:19 <Taejo> @faq can Haskell form babby?
15:05:19 <lambdabot> The answer is: Yes! Haskell can do that.
15:05:21 <kiris> preflex: be poppavic and tell me how babby formed?
15:05:22 <preflex>  no quotes found for poppavic and tell me how babby formed?
15:05:29 <kiris> v_v
15:05:46 <ozy`> bling: way to succumb to peer pressure, dude
15:07:01 <anthonymiller> is there an IO function to remove lines/chars from files?
15:07:13 <mauke> no, because that's not possible
15:07:27 <anthonymiller> mauke: really? @_@
15:07:53 <ozy`> anthonymiller: what do you mean exactly? you might read the contents of the file, filter out some of the text, and write the result back to the file
15:07:57 <mauke> unless you have a rather unusual operating system
15:08:20 <mauke> you can only overwrite existing stuff, append at the end, or truncate the file
15:08:49 <Taejo> haven't there been record-oriented filesystems where you can remove records in the middle of a file?
15:08:55 <pumpkin> anthonymiller: you could make a readFilterWrite but it seems a little specific :P
15:09:26 <bling> mauke: what do you mean the 80s? machine learning is bugger than ever.
15:09:28 <bling> and game programming is fun
15:09:31 <ozy`> Taejo: surely Mr. Miller is not using such an esoteric filesystem.
15:09:31 <anthonymiller> i see what you mean, deleteing text is not a standard operation...
15:09:43 <Badger> game programming is hard in haskell. :P
15:09:53 <leimy> FRP!
15:10:22 <Taejo> ozy`, well, I don't think there is a Haskell compiler for any such operating system
15:10:26 <dons> isn't game programming a beginner exercise in haskell?
15:10:36 <Badger> leimy: is also hard. :P
15:10:40 <Botje> it's right up there with monad tutorials :)
15:10:44 <leimy> damn viagra
15:10:51 <Botje> "to understand monads, you must write a monad tutorial"
15:11:02 <pumpkin> ...and compare them to burritos
15:11:07 <leimy> "to understand recursion, one must first understand recursion"
15:11:08 <pumpkin> byorgey's meme
15:11:48 <bling> Badger why is game programming  hard in haskell?
15:12:00 <ozy`> bling: anyway. half the fun in working with haskell is doing stuff nobody expects you to do with haskell
15:12:13 <Badger> because haskell is hard, and I'm used to imperative style. :P
15:12:17 <bling> yes but that wasnt was i was asking
15:12:19 <ozy`> the other half is having your brain expand until it takes up the entire room
15:12:32 <leimy> Haskell is only difficult until you figure out that it isn't difficult
15:12:48 <Taejo> @vixen why is game programming  hard in haskell?
15:12:49 <lambdabot> church is my favourite computer scientist.
15:12:49 <ray> haskell is hard, let's go shopping for a copy of RWH
15:12:50 <ozy`> "there is no spoon. it is yourself that bends."
15:13:16 <Botje> Badger: imperative coding is keeping you down! stick it to the man and ignore the von neumann model!
15:13:28 <bling> it is only difficult until you realize mutable state is an illusion. things have identity not state
15:13:38 <ray> if you ignore the von neumann model it won't return the favor
15:13:43 <leimy> It's not variables that count, but values!
15:14:04 <ozy`> "optimize this."
15:14:13 * ozy` segfaults
15:14:58 <Badger> hrm
15:15:20 <Badger> there don't happen to be any cunningly convenient tutorials on this kind of thing? :)
15:15:22 <leimy> I just used ReaderT because I felt like it today...
15:15:28 <leimy> no real reason to do so.
15:15:44 <leimy> arbitrary Monad employment for the lose?
15:17:09 <ray> you're becoming a perl programmer (but in haskell)!
15:18:12 <leimy> actually right now this one part of the program is just one function, so the ReaderT is overkill, but later I see it being used in a few chains of expressions where I'd rather not just pass this String along.
15:18:38 <leimy> ReaderT makes me feel really lazy
15:19:00 * BMeph wants to ask in a ##c channel: "If a++ adds 1 to the value of a, why can't I do 4++ and add one to the value of 4?" >;)
15:19:33 <Botje> BMeph: "because it's a compile error! duh!"
15:19:34 <ray> don't, i've heard horror stories about ##c
15:19:52 <leimy> BMeph: because a++ doesn't *just* add one to a.
15:19:57 * cjb presents the word "lvalue"
15:20:00 <int-e> > let 4 = 5 in 4 -- BMeph: why isn't this 5?
15:20:01 <lambdabot>   4
15:20:09 <ray> a++ doesn't add one to a in the haskell sense
15:20:12 <ray> you'd want ++a there
15:20:26 <ozy`> int-e: shit... didn't know you could do that
15:20:31 <leimy> and even that doesn't *just* add 1 to ad
15:20:32 <leimy> er a
15:20:36 <int-e> BMeph: but the real reason is that 4 isn't an lvalue ;-)
15:20:52 <Botje> it is in fortran :)
15:20:58 <noZone> http://users.info.unicaen.fr/~karczma/arpap/lazypi.ps.gz <-- this paper on a lazy Haskell/BBP Pi algorithm is a hoot, esp. the conclusions.
15:21:08 <pao> @seen Cale
15:21:08 <lambdabot> Cale is in #ghc, #haskell and #haskell-overflow. I last heard Cale speak 1h 7m 53s ago.
15:21:10 <pumpkin> > let 1+1=3 in 1+1
15:21:12 <lambdabot>   3
15:21:17 <int-e> ozy`: but it's perfectly logical - 4 is a pattern (it doesn't bind anything, but who cares).
15:21:22 <Cale> pao: hello
15:21:32 <ozy`> int-e: well when you put it that way, yeah
15:21:39 <gio123> @seen Cale
15:21:39 <lambdabot> Cale is in #ghc, #haskell and #haskell-overflow. I last heard Cale speak 16s ago.
15:21:46 <ozy`> > pi
15:21:47 <lambdabot>   3.141592653589793
15:21:50 <pumpkin> everyone's looking for Cale!
15:21:51 <ozy`> @let pi = 3
15:21:53 <lambdabot>  Defined.
15:21:59 <ray> zomg
15:22:04 <int-e> > let !4 = 5 in 4 -- I'm never sure of the behaviour of this one.
15:22:04 <pumpkin> it'll conflict
15:22:05 <lambdabot>   * Exception: /tmp/8435696861926401677:71:48-53: Non-exhaustive patterns in ...
15:22:18 <pao> Cale: Saizan told me the you showed something about using the list monad for non deterministic search applied to Sudoku ... have you got any pointer?
15:22:19 <Taejo> @let pi = 3.2 in indiana
15:22:19 <killerboy> ok i managed to write this plugin for lambdabot without knowing haskell ;-)
15:22:19 <lambdabot>   Parse error
15:22:48 <ozy`> Taejo: @let saves a top-level declaration >_>
15:22:50 <Cale> pao: http://www.haskell.org/haskellwiki/Sudoku
15:22:51 <pumpkin> hpaste is still down?? who runs that site?
15:22:57 <Cale> pao: the first one on that page :)
15:22:57 <Taejo> ozy`, oh right
15:22:58 <ozy`> pumpkin: THE DEVIL
15:23:00 <Taejo> >let pi = 3.2 in indiana
15:23:01 <ray> > let (+) 1 1 = 3 in 1 + 1
15:23:02 <lambdabot>   3
15:23:02 <pao> Cale: thanks :-)
15:23:14 <ray> it doesn't seem so odd that way
15:23:28 <Taejo> > let 2 + 2 = 5 in 1 + 2
15:23:29 <lambdabot>   * Exception: /tmp/7180333227606687485:71:56-64: Non-exhaustive patterns in ...
15:23:36 <Taejo> @let 2+2 = 5
15:23:37 <lambdabot>  <local>:34:37:
15:23:37 <lambdabot>      Ambiguous occurrence `+'
15:23:37 <lambdabot>      It could refer to either `...
15:23:53 <Taejo> @let (Prelude.+) 2 2 = 5
15:23:53 <lambdabot>   Parse error in pattern: HsVar (Qual (Module "Prelude") (HsSymbol "+"))
15:23:54 <killerboy> oh, hello Cale, i was told to ask you about lambdabot issues
15:24:00 <Taejo> @let (+) 2 2 = 5
15:24:01 <lambdabot>  <local>:34:37:
15:24:01 <lambdabot>      Ambiguous occurrence `+'
15:24:01 <lambdabot>      It could refer to either `...
15:24:10 <pumpkin> > let (a+1) + b = a + b in 2 + 2
15:24:10 <Saya> Hey is there a way to have   instance (A a) => (B a) where A and B are type classes? so that an instance of type A is automatically an instance of type B but not the other way around
15:24:12 <lambdabot>   * Exception: /tmp/3404328210130879387:71:48-64: Non-exhaustive patterns in ...
15:24:12 <Cale> killerboy: I run lambdabot, but I only sort of maintain it.
15:24:18 <ray> @let Prelude.(+) 2 2 = 5
15:24:18 <lambdabot>   Parse error in pattern: HsVar (UnQual (HsSymbol "+"))
15:24:23 <Cale> killerboy: I don't actually claim to know anything about how it works ;)
15:24:28 <ozy`> what precisely did I do wrong there x_x
15:24:31 <Cale> killerboy: (but I can try :)
15:24:38 <loadquo> :t shiftR
15:24:39 <lambdabot> forall a. (Bits a) => a -> Int -> a
15:24:41 <vixey> Saya, doesn't exactly what you wrote there work?
15:24:57 <Cale> killerboy: Normally I just accept patches that I receive.
15:24:59 <killerboy> Cale, oh, because i've written plugin for it, but dont know haskell, and i suppose somebody should look into it
15:25:02 <Saya> again :( ? no
15:25:07 <loadquo> @instances Bits
15:25:08 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
15:25:13 <Saya> oh wait
15:25:16 <Cale> killerboy: Does the plugin work? What does it do?
15:25:38 <Saya> nope
15:26:04 <killerboy> Cale, i'ts based on hello world plugin, so it's very simple,  but as i said i donno haskell, so cannot write anything more complicated :-(, it writes unicode logical symbols
15:26:27 <pumpkin> in UTF-8?
15:26:28 <Saya> hmmm
15:26:31 * wli tries to figure out what gentoo package has the containers cabal/etc. packae.
15:26:32 <killerboy> yes
15:26:43 <Cale> Saya: Instance selection is normally performed on the structure of the type *alone* and not on the instances which the type belongs to. The reason for this is that typeclasses are open, and so the instances which a type belongs to is never fixed.
15:26:57 <Cale> Saya: (it could always be made an instance later)
15:26:58 <killerboy> as i said it's VERY simple
15:27:03 <Saya> oh indeed
15:27:24 <killerboy> but i donno such issues, like should i watch something etc...
15:27:33 <killerboy> because i donno haskel
15:27:34 <Cale> Saya: So with the various overlapping instances extensions, you can write such an instance, but it will tend to overlap with everything.
15:27:55 <Cale> killerboy: Well, if the thing works, it works ;)
15:28:18 <killerboy> and still i cannot compile it to check if it works, because cabal takes ages to download
15:28:28 <Saya> so i have to do that explicitely thats a shame :p !
15:28:36 <cads> Vixey, remember my tree representation problem?
15:28:41 <Cale> ah
15:28:42 <vixey> cads, no
15:28:48 <cads> well I solved the tree canonization problem! But I wasn't able to create data CanonicallyTopologicallyIsopmorphicTrees = Zero | succ CanonicallyTopologicallyIsopmorphicTrees : (. It's not impossible, just that any enumeration would be arbitrary and unwieldly
15:28:59 <vixey> cads, I remmeber it now!
15:29:04 <killerboy> Cale, so what should i do, when i create patch from darcs, should i use send option of darcs?
15:29:14 <vixey> cads, cool! what did you come up with?
15:29:17 <Cale> killerboy: There's no general caveats that I know of... lambdabot is not the pinnacle of good program design, it's sort of been hacked together by a large group of people over the years -- it started out with a coherent design, but it's been reworked many times.
15:29:29 <Cale> killerboy: Yeah
15:29:59 <Cale> killerboy: You can use darcs send -o filename to make a file
15:29:59 <killerboy> Cale, ok, that's what i'll do.
15:30:24 <killerboy> and give it to you?
15:30:27 <Cale> and then you can send that file to me, yeah
15:30:32 <killerboy> ok
15:30:55 <killerboy> as i said it's VERY basic now, but i suppose i can improve it later
15:32:27 <cads> we construct a total order on the trees by taking each subtree and ordering its branches according to lexicographical comparison between branches. Starting from the bottom up means that each branch at one level has already been made comparable to the rest!
15:33:09 <cads> so lexicographic order and bottom up application works to uniquely sort the tree
15:35:11 <cads> and I also worked one other scheme where each subtree is run through a cryptographic digest to create a unique fingerprint of that subtree, but that's flakier
15:35:43 <cads> it will work barring hash collisions :D
15:35:50 <loadquo> Can anyone explain to this bear of little brain why new hash numBits = MB hash `liftM` newArray (0,numBits-1) False, doesn't need to pass a parameter s to the newArray function. I'm trying to do something similar but not exactly the same....
15:35:58 <vixey> yeah
15:36:11 <loadquo> To be clear it is this "new hash numBits = MB hash `liftM` newArray (0,numBits-1) False"
15:36:33 <loadquo> The code is from RWH.
15:38:41 <bling> one thing that really bothers me with python and java is that if you really want to make your code exception safe you really have to litter your code with try-excepts. this is something that always really felt wrong to me but i dont know what to do about it. does haskells monadic approach solve this?
15:38:43 <byorgey> noZone: yeah, that's a fun one =)
15:38:55 <byorgey> that paper I mean
15:39:13 <vixey> which ?
15:39:27 <byorgey> http://users.info.unicaen.fr/~karczma/arpap/lazypi.ps.gz
15:39:46 <vixey> ah I remember that
15:40:40 <noZone> :)
15:40:45 <dibblego> bling, you can use the Either/Error monad, which has been implemented in Java
15:44:05 <cads> I love how important seeming that paper makes pi computation seem
15:44:18 <cads> though a bit tongue in cheek
15:45:00 <chessguy_work> 'evening, ya'all
15:45:37 <ozy`> bling: there are a couple of monads that are really useful for error checking and error handling. the Maybe monad is the haskell version of null pointers (where Nothing is "null" and Just x is a non-null variable x)--gaaaahhhh
15:46:14 <ray> gaaaahhhh?
15:46:22 <ozy`> bling vanished!
15:46:34 <ray> he seems to do that
15:46:39 <ozy`> aha
15:46:43 <vixey> /topic
15:47:10 <SubStack> bling blong
15:47:26 <bling> The three computational processes (recursion, ?-calculus, and Turing machine) were shown to be equivalent by
15:47:30 <bling> what is the diff between recursion and lambda calculus?
15:47:35 <ozy`> bling: there are a couple of monads that are really useful for error checking and error handling. the Maybe monad is the haskell version of null pointers (where Nothing is "null" and Just x is a non-null variable x). stringing together multiple Maybe functions in a do block will make the whole block return Nothing if anything in the block returned Nothing
15:48:32 <gweiqi> b-bling-bling
15:48:38 <vixey> bling, recursion theory takes primitive "combinators" like  projection and so on, as well as mu-minimization
15:49:56 <ozy`> bling: dude you need a more reliable connection if we're gonna answer your questions :p
15:50:22 <vixey> /topic has a link to the logs
15:50:28 <jeltsch> Hi, I just wanted to upload a Cabal package to Hackage and received the following error message:
15:50:36 <jeltsch> This package requires Cabal version: >=1.2 && <1.7
15:50:44 <jeltsch> I ask myself: “So what?”
15:51:02 <jeltsch> Unfortunately, Hackage doesn’t tell me what it doesn’t like about that version range.
15:51:57 <porges> in the spirit of `on`:
15:52:18 <porges> @let (p `equals` y) x = p x == y
15:52:20 <lambdabot>  Defined.
15:52:25 <porges> @let is = flip (.)
15:52:26 <lambdabot>  Defined.
15:53:02 <bling> im switxhing provider next month
15:53:07 <bling> never use glocalnet
15:53:59 <rwbarton> "is"?
15:54:10 <pumpkin> o.O
15:54:22 <roconnor> logBase 2 ((6^5)^7)
15:54:25 <roconnor> > logBase 2 ((6^5)^7)
15:54:26 <lambdabot>   90.47368752524046
15:54:39 <Taejo> porges, why?
15:54:59 <pumpkin> @let isn't = (.)
15:55:01 <lambdabot>  Defined.
15:55:11 <roconnor> > logBase 2 ((6^5)^9)
15:55:12 <lambdabot>   116.32331253245204
15:55:17 <roconnor> > logBase 2 ((6^5)^10)
15:55:18 <porges> data Color = Blue | Red
15:55:19 <lambdabot>   129.24812503605781
15:55:19 <Taejo> :t is `isn't` is
15:55:21 <lambdabot> forall c a b c1. (a -> b) -> ((a -> c1) -> c) -> (b -> c1) -> c
15:55:24 <rwbarton> > is sqrt (== 4) 16
15:55:27 <gwern> does anyone know how the channel logs on tunes.org get there?
15:55:27 <lambdabot>   True
15:55:28 <pumpkin> > (+5) `isn't` (*2) $ 5
15:55:29 <porges> data Thing = { color :: Color }
15:55:31 <lambdabot>   15
15:55:32 <rwbarton> Seems pretty contrived to me
15:55:35 <porges> filter (color `is` Blue)
15:55:43 <porges> err
15:55:53 <porges> filter (color `equals` Blue)
15:56:02 <porges> filter (length `is` (>3))
15:56:03 <pumpkin> porges: even you get confused with your naming! :P
15:56:12 <gwern> @seen nef
15:56:13 <lambdabot> I haven't seen nef.
15:56:19 <sjanssen> gwern: clog, I think
15:56:19 <porges> pumpkin:  :P
15:56:31 <gwern> sjanssen: indeed, I just saw that
15:56:33 <pumpkin> porges: I can see that being nice for that kind of predicate, but it's rather specific
15:56:39 <gwern> for some reason I was convinced lb did the logging
15:56:40 <porges> pumpkin: that's the idea :)
15:56:55 <pumpkin> porges: how about my isn't operator! :P
15:56:55 <chessguy_work> jeltsch, you can tell what version you have by doing "cabal --version"
15:56:58 <porges> module Data.Function.Predicates
15:57:00 <gwern> sjanssen: we'd like logging in #happs, but no info seems to be available on how to get clog
15:57:15 <sjanssen> gwern: lambdabot can do logging
15:57:19 <sjanssen> it might be disabled now
15:57:33 <gwern> I think it is. the Plugin.Log module looks old
15:57:34 <sjanssen> or whomever is hosting lambdabot nowadays just hasn't made the logs available
15:57:37 <jeltsch> chessguy_work: This tells me the version of cabal-install, not Cabal (the Haskell package).
15:57:44 * loadquo believes that lambdabot will 'wake up' one day
15:57:54 <jeltsch> chessguy_work: In addition, my problem has nothing to do with my locally installed Cabal.
15:58:19 <chessguy_work> jeltsch, ah, sorry
15:58:24 <bling> The three computational processes (recursion, ?-calculus, and Turing machine) were shown to be equivalent by
15:58:24 <bling> what is the diff between recursion and lambda calculus?
15:58:27 <jeltsch> chessguy_work: It is Hackage not accepting the Cabal-Version range in the .cabal file.
15:58:34 <gwern> loadquo: I personally believe it will go into a comma some day
15:58:53 <jeltsch> chessguy_work: It seems to accept an upper bound of < 1.8 instead of < 1.7 however.
15:59:02 <loadquo> Not a full stop?
15:59:17 <killerboy> bling, same as between Sparc and x86
15:59:17 <roconnor> > (logBase 2 6)*50
15:59:18 <lambdabot>   129.24812503605781
15:59:22 <killerboy> rotfl
15:59:30 <pumpkin> roconnor: whatcha up to?
15:59:34 <jeltsch> chessguy_work: Don’t know why. AFAIK, there is no Cabal 1.7 yet so that I cannot test whether my package works with it.
16:00:08 <roconnor> how many diceware word do you need to memorize for a 128 bit identifier/password
16:00:17 <roconnor> http://www.reddit.com/r/programming/comments/7rozs/identity_and_authentication_are_separate_things/c077nxx
16:00:46 <anthonymiller> i dont understand the need for a haskell package manager...why isnt it just integegrated into portage, aptitude, pacman, etc...
16:01:05 <killerboy> anthonymiller, exactly
16:01:41 <anthonymiller> killerboy: are you agreeing with me or is that an answer? :)
16:01:47 <pumpkin> anthonymiller: it's supposed to be convertable to shoe
16:01:50 <pumpkin> those
16:01:51 <killerboy> agreeing
16:01:58 <pumpkin> why does gem exist?
16:02:05 <Taejo> anthonymiller, the answer is portage, aptitude, pacman, etc...
16:02:41 <killerboy> Taejo, isn't it better to select existing solution?
16:03:20 <pumpkin> not if it isn't really a solution
16:03:20 <ozy`> anthonymiller: package managers are working on cabal compatibility. in the meantime, cabal does what the haskell community needs, and does it well
16:04:43 <anthonymiller> i just hope Yi and Cabal and Haskell don't combine into some super functional operating system
16:04:49 <ozy`> not every OS (or distro) has a package manager... much less one that can replace cabal
16:05:02 <Taejo> killerboy, for one thing, most existing package formats are not declarative -- they typically have shell scripts that are difficult to translate
16:06:55 <killerboy> Taejo, so problems is as usual with windows
16:06:55 <gwern> anthonymiller: with shsh as the shell!
16:06:55 <killerboy> i understand now
16:06:55 <pumpkin> no
16:06:55 <pumpkin> well, it's part of the problem
16:06:55 <jeltsch> anthonymiller: If you use Debian stable, for example, you won’t be able to install current Haskell library versions via Debian’s package manager. There it is an advantage to have Cabal.
16:06:55 <islon_s> question: i have a "Attributes" data inside a "Player" data. i have to change on field of this attributes to reflect some change in the player, how i do this? some function that take a player and return a new player with the new attributes?
16:06:55 <Taejo> killerboy, that's not the problem that I'm talking about -- it's as difficult to translate a Debian pre-inst script to Gentoo as to Windows
16:06:55 <killerboy> oh, ok
16:06:56 <anthonymiller> jeltsch: i think that also has to do with debian's conservative definition of "stable" ;)
16:06:56 <killerboy> FHS?
16:07:15 <jeltsch> anthonymiller: Of course but this doesn’t change the fact that Cabal helps me.
16:07:50 <anthonymiller> jeltsch: true
16:08:20 <jeltsch> anthonymiller: The idea is obviously that package maintainers of different Linux distributions can convert Cabal packages to their distribution’s packages automatically or semi-automatically. This is done already for Debian and Gentoo and probably others.
16:08:31 <SamB> jeltsch: if you use debian stable, how are you going to have a version of GHC that will run the latest stuff ?
16:08:41 <killerboy> Configuring cabal-install-0.6.0...\nSetup: At least the following dependencies are missing:\nHTTP >=3000 && <3002, network >=1 && <3\nSorry, something went wrong.
16:08:47 <pumpkin> arch too
16:08:58 <killerboy> damn, thats what cabal-install can do
16:09:18 <pumpkin> killerboy: did you use bootstrap.sh?
16:09:27 <pumpkin> it does most of the work for you
16:09:27 <killerboy> yup
16:09:33 <anthonymiller> jeltsch: interesting
16:09:33 <killerboy> as you see it doesn't
16:09:35 <pumpkin> one of your packages must've failed then
16:11:10 <killerboy> which one?
16:11:10 <SamB> do you, in fact, have wget?
16:11:10 <killerboy> of course
16:11:10 <anthonymiller> i just want the software eco-system to be simple and perfect but in real life it just doesn't work that way lol
16:11:10 <jeltsch> SamB: I download GHC from its website. :-)
16:11:20 <Taejo> I had to install libghc6-http-dev and libghc6-network-dev on Ubuntu, before bootstrap.sh worked
16:11:22 <jeffz`> islon_s: yes
16:12:00 <chessguy_work> anthonymiller, what would be so bad about that combination? :)
16:12:19 <islon_s> jeffz`: hmmm... thats a lot of work for something you can do in one line with imperative code
16:12:30 <chessguy_work> we can call it......skynet!
16:12:33 <Saya> speeking of cabal, im trying to install yi and it tells me i need alex so i install alex and then i retry installing yi and it tells me i dont have alex :)
16:12:50 <killerboy> Taejo, ok thanks
16:13:01 <chessguy_work> Saya, haha, i'm installing yi right now too, and just got the same error
16:13:21 <loadquo> Not a full stop?
16:13:25 <loadquo> Oops
16:13:29 <Saya> woop dee doo :)
16:13:42 <jeffz`> islon_s: I don't see it as a lot of work, you can usually write a simple function for doing such things, so that you are then operating at higher level and nolonger think about the small details
16:14:10 <chessguy_work> installed alex, trying yi again
16:14:31 <chessguy_work> uh-oh, "'yi-0.5.2' is cache"...wonder what that means
16:14:52 <chessguy_work> ByteRope (!)
16:14:56 <chessguy_work> that sounds interesting
16:14:57 <Saya> ??
16:15:23 <Saya> maybe by uncaching yi it would work
16:15:41 <chessguy_work> i think it's going through for me
16:15:48 <chessguy_work> maybe
16:16:02 <Saya> what did you do?
16:16:11 <chessguy_work> just "cabal install alex"
16:16:24 <Saya> yeah that worked for me
16:16:26 <islon_s> jeffz`: maybe i'm not seeing how to do such simple function in two nested complex data structures (i'm a newbie btw)
16:16:28 <Saya> but yi still wont install
16:16:41 * wli seems to av eeper gentoo problems.
16:16:52 <chessguy_work> Saya, it just finished for me :)
16:16:59 * wli seems to have deeper gentoo problems, that is.
16:17:13 <Saya> !!!
16:17:48 <rwbarton> Saya: probably because the alex executable installed into ~/.cabal/bin which isn't on your path
16:17:50 <dcoutts> jeltsch: the problem is that hackage is running Cabal-1.7, so it cannot handle your package because your package says so.
16:18:03 <Saya> rwbarton: exactly just saw that :p
16:18:27 <jeltsch> dcoutts: There is a Cabal 1.7???
16:18:39 <Saya> and indeed now it works :)
16:18:43 <gio123> @seen Cale
16:18:43 <lambdabot> Cale is in #ghc, #haskell and #haskell-overflow. I last heard Cale speak 48m 16s ago.
16:18:43 <jeltsch> dcoutts: I cannot find it on Hackage.
16:18:55 <dcoutts> jeltsch: that's the current version of the Cabal HEAD branch
16:19:08 <dcoutts> jeltsch: ie Hacakge is running the development version
16:19:09 <jeltsch> dcoutts: And it’s running in production use?
16:19:11 <gwern> @tell Cale I'm going to add #happs to the list of default lb channels
16:19:11 <lambdabot> Consider it noted.
16:19:36 <chessguy_work> now if i can just figure out where the keybindings for emacs are...
16:19:58 <dcoutts> jeltsch: yes. We often do that. It meant that we were able to add some needed QA checks.
16:19:59 <jeltsch> doutts: What happens if one day Hackage will be Cabal-1.8-powered. Will my package not be handled correctly then?
16:21:16 <dcoutts> jeltsch: it should be ok because it's backwards compatible
16:21:45 <dcoutts> jeltsch: that's also why typically you do not need an upper bound in the cabal-version field, unless you're using a complex Setup.hs script.
16:21:48 <jeltsch> dcoutts: But it will complain because of the Cabal-Version entry in the .cabal file.
16:21:54 <chessguy_work> what does this mean: "A good way to start is to copy yi.hs in your ~/.yi directory (create it if needed), and hack as needed."?
16:21:55 <killerboy> some dependencies of lambdabot
16:22:02 <killerboy> what is base?
16:22:06 <killerboy> cabal cannot get it
16:22:17 <SamB> killerboy: uh, you are supposed to have that already
16:22:19 <dcoutts> jeltsch: it checks that when you upload, so long as it can still parse it in future it should be ok.
16:22:27 <SamB> you probably have it, but lambdabot doesn't like that version
16:22:29 <killerboy> ?
16:22:35 <SamB> that's the way it usually works ;-P
16:22:43 <killerboy> it's better with each step
16:23:01 <killerboy> and i just wanted to install smal patch to lambdabot
16:23:06 <SamB> though, in the old days, it didn't actually check, it just didn't build right, I think ;-P
16:23:11 <killerboy> i screw it all, and send untested patch
16:23:13 <killerboy> fuck
16:23:28 <loadquo> :t runST
16:23:29 <lambdabot> forall a. (forall s. ST s a) -> a
16:23:30 <jeltsch> dcoutts: I don’t get it. I thought, Cabal is run on the package if I upload and that’s why Cabal-Version is checked. What if Cabal is later run on the package because the documentation is rebuilt or the package is checked for compliance with a newer GHC?
16:23:31 <killerboy> don't have time for fucking with it
16:23:42 <killerboy> i have an idea
16:23:53 <gwern> killerboy: what are you doing to lb?
16:23:54 <killerboy> i'll send patch to someone on this channel
16:24:06 <killerboy> and he will compile it and test if it works for me
16:24:08 <killerboy> ok?
16:24:09 <dons> send it to the maintainer.
16:24:26 <killerboy> ok, i'll send it with annotation: i don't know if it compiles
16:24:32 <dons> then don't send it.
16:24:39 <killerboy> I need it
16:24:45 <gwern> what is it?
16:24:56 <killerboy> utf8 lofical symbols
16:24:58 <killerboy> *logical
16:25:08 <gwern> hm? what do you mean?
16:25:12 * loadquo could do with examples of using STUArrays in data structures other than RWH if anyone has them
16:25:23 <killerboy> minute please
16:25:26 <dons> loadquo: the nprimes examples on the shootout
16:25:38 <dcoutts> jeltsch: yes and no. What happens immediately when you upload is just a bunch of QA checks. It does not build the package. Then there's a separate build server that downloads, builds and uploads reports.
16:25:53 <loadquo> Thanks dons
16:26:01 <SamB> dcoutts: and docs?
16:26:08 <dcoutts> SamB: yep
16:26:28 <dcoutts> jeltsch: and it's true that the build server would not be able to build the package if it needed a different Cabal version
16:26:31 <gwern> dcoutts: incidentally, I noticed hackage is now doing more checks than cabal check apparently? (specifically the one for stuff like base==3.*)
16:26:46 <dcoutts> gwern: yep
16:26:49 <jeltsch> dcoutts: So I better not give an upper bound?
16:27:03 <gwern> dcoutts: this is bad since I do cabal check and then cabal upload :)
16:27:06 <dcoutts> gwern: hackage is using the dev version of the Cabal lib so has all the latest QA checks
16:27:15 <gwern> and it yields a mysterious failure
16:27:24 <dcoutts> gwern: if we built cabal-install against that version then it'd give the same
16:27:43 <jeltsch> Is it possible that a different person uploads a package to Hackage for me.
16:27:53 <gwern> jeltsch: yes
16:27:54 <dcoutts> jeltsch: not unless you really need it, eg if you've got a very complex Setup.hs
16:28:32 <Saya> chessguy_work: i put that yi-vim.hs file inside .yi  and renamed it yi.hs i now have vim key bindings :)
16:29:13 <jeltsch> gwern: Do you have Hackage upload access?
16:29:15 <loadquo> dons, I'm not finding it?
16:29:29 <gwern> jeltsch: I do
16:29:58 <loadquo> Nbody?
16:30:02 <killerboy> ok, i'm back
16:30:13 <dons> loadquo: http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsievebits&lang=ghc&id=1
16:30:27 <jeltsch> gwern: Could you upload the type-equality-check package for me? I don’t have my password here but want to make the Grapefruit installation instruction valid. (It needs a Hackage-release type-equality-check package.)
16:30:51 <gwern> jeltsch: where might that be?
16:31:05 <loadquo> Thanks.
16:31:19 <jeltsch> darcs get http://softbase.org/type-equality-check/darcs/main
16:31:40 <jeltsch> gwern: Then please do a runghc Setup.lhs sdist.
16:33:01 <gwern> jeltsch: I'm compiling it
16:33:22 <Saya> how do you activate the gtk ui with yi?
16:33:55 <jeltsch> gwern: You don’t need to compile it in order to make a Cabal package.
16:34:00 <gwern> Saya: you compiled with it?
16:34:02 <chessguy_work> Saya, where did you find .yi?
16:34:10 <gwern> jeltsch: I'm not going to upload a bad package, but it did compile
16:34:15 <Saya> i just did cabal install yi
16:34:20 <Saya> i created the directory
16:34:22 <gwern> jeltsch: although I question a versio number like 0.0.0.0 :)
16:34:28 <chessguy_work> Saya, oh, in ~ ?
16:34:33 <Saya> ye
16:34:34 <Saya> a
16:34:37 <jeltsch> gwern: I don’t produce bad packages. :-)
16:34:41 <jeltsch> gwern: I already checked.
16:34:49 <jeltsch> gwern: What’s wrong with 0.0.0.0?
16:34:54 <gwern> Saya: well, to see whether you even have gtk compiled in, you'd do something like yi -f gtk
16:34:58 <killerboy> wanna see this patch to test it?
16:35:05 <jeltsch> gwern: Four-digit version numers are common for Cabal packages.
16:35:08 <gwern> jeltsch: it's just that this code seems to've been through multipe maintainers and versions
16:35:33 <gwern> but other thanthat it seems good
16:35:37 <Saya> Panic: frontend not found :)
16:35:42 <jeltsch> gwern: And 0.1 is not sensible since, for example, 1.* version numbers also start with 1.0 instead of 1.1.
16:35:44 <Taejo> is it jeltsch's client or mine that's not encoding/decoding apostrophes correctly?
16:35:59 <killerboy> Cale, are you there?
16:36:00 <jeltsch> Taejo: Are you using UTF-8?
16:36:07 <gwern> Saya: there you go. cabal-install installed it with the default vty interface
16:36:14 <jeltsch> Taejo: I use the nice typographic apostrophes.
16:36:16 <gwern> Saya: you'd need to do soemthing like cabal install -fgtk
16:36:17 <Taejo> jeltsch, I think so
16:36:26 <Saya> ok thxd ill try that
16:36:30 <gwern> Saya: assuming gtk is available for your ghc (it isn't for 6.10 still)
16:36:30 <Saizan> "cabal install yi -fgtk"
16:36:42 <gwern> yes, thank you Saizan
16:36:45 <gwern> jeltsch: uploaded
16:36:56 <Taejo> jeltsch, I realise that, but I fear you're encoding them in Latin-1 or some windows codepage
16:37:00 <jeltsch> gwern: Thanks a lot! :-)
16:37:05 <killerboy> ok, so nobody interested, fine :-)
16:37:19 <gwern> killerboy: I'm the other lb maintainer, I'd like to see it
16:37:19 <Saya> oh im on 6.10 so nevermind ill try with the normal interface :)
16:37:29 <killerboy> gwern, ok
16:37:44 <gwern> jeltsch: incidentally, I'm not familiar with you so I don't know you create good packages :0
16:37:45 <jeltsch> gwern: The multiple copyright holders are there because I’ve basically stolen the code from HList.
16:38:20 <gwern> (hlist. now that was a pain in the ass to cabalize)
16:38:31 <_40oxo_> why do i need to define a readsPrec instead of read when instantiating Read?
16:38:37 <jeltsch> gwen: You did cabalize it?
16:39:16 <gwern> jeltsch: I certainly have harrowing memories of cabalizing it
16:39:17 <gwern> along with zfs
16:39:18 <killerboy> gwern, http://unoduetre.republika.pl/killerboy.patch
16:39:25 <Taejo> jeltsch, ah, it seems I'm not in a UTF-8 locale like I'm used to
16:40:18 <gwern> killerboy: so what is the point of this? convenient access to some symbols?
16:40:26 <augustss> _40oxo_: because when reading a compound value, the read function need to parse something, and also return the rest of the input.  that's what readsPrec does.
16:40:27 <killerboy> yes
16:40:43 <killerboy> you can copy-paste them if you need
16:40:48 <Saya> So is there a user guide for yi? :p what special haskelly features does it have?
16:40:48 <augustss> _40oxo_: (and it allows backtracking)
16:41:06 <gwern> Saya: look at my config, in yi/src/users/Gwern.hs
16:41:13 <killerboy> it's for users who cannot set their applets, or don't have them (like windows users)
16:41:32 <glguy> ?where could be used for that
16:41:32 <lambdabot> I know nothing about could.
16:41:37 <rwbarton> killerboy: couldn't you just use @quote ?
16:41:38 <gwern> Saya: there's hoogle completion, smart indenting, ghci-based inferred-type-pasting, and pretty lambdas
16:41:40 <glguy> a new module isn't necessary
16:41:49 <rwbarton> or @where, or ...
16:41:57 <killerboy> rwbarton, how quote works?
16:42:05 <glguy> not really even lambdabot related
16:42:11 <gwern> @fact-cons unicode ⊤⊥¬∧∨⊕↑↓⇒⇐⇔∃∀⊢⊬⊨⊭
16:42:12 <lambdabot> A fact must exist to alter it
16:42:15 <Saya> sweet
16:42:17 <gwern> @fact-
16:42:17 <lambdabot> Maybe you meant: fact-cons fact-delete fact-set fact-snoc fact-update fact
16:42:24 <gwern> @fact-set unicode ⊤⊥¬∧∨⊕↑↓⇒⇐⇔∃∀⊢⊬⊨⊭
16:42:24 <lambdabot> Fact recorded.
16:42:29 <gwern> @fact unicode
16:42:29 <lambdabot> unicode: ⊤⊥¬∧∨⊕↑↓⇒⇐⇔∃∀⊢⊬⊨⊭
16:42:31 <killerboy> @unicode
16:42:31 <lambdabot> Unknown command, try @list
16:42:39 <killerboy> @fact unicode
16:42:39 <lambdabot> unicode: ⊤⊥¬∧∨⊕↑↓⇒⇐⇔∃∀⊢⊬⊨⊭
16:42:43 <killerboy> ok
16:42:45 <killerboy> thanks
16:42:59 <killerboy> it's because someone suggested me to write a patch
16:43:17 <killerboy> so i thought such functionality is unavailable
16:43:23 <gwern> killerboy: incidentally, there's a nice selection of unicode in http://code.haskell.org/yi/Yi/Char/Unicode.hs
16:43:33 <killerboy> people, people, people
16:44:22 <_40oxo_> augustss: i see. I'm having trouble implementing it for a simple data type. the tree example in the ghc docs seems very confusing, but maybe i just have to stare at it for another hour or so :)
16:44:29 <killerboy> ok, thanks for help
16:44:39 <killerboy> of course patch isn't needed now
16:45:26 <ptolomy2> hm. hpaste is done?
16:45:31 <ptolomy2> "down"?
16:45:41 <augustss> _40oxo_: typically, it just returns a list with one element, which is a pair if what it parsed, and the remaining string
16:45:42 <gwern> yes
16:45:48 <gwern> ptolomy2: use moonpatio
16:46:53 <killerboy> thank you all for your help
16:46:59 <killerboy> good night
16:47:00 <ptolomy2> well, I was looking for a particular post.
16:47:23 <chessguy_work> Saya, i don't get it. so you actually did "mkdir .yi" from your ~ directory?
16:47:41 <Saya> i mkdir .yi and then put a yi.hs inside
16:47:54 <Saya> http://code.haskell.org/yi/examples/
16:48:56 <_40oxo_> augustss: my readsPrec returns a list with one tuple, with the first item as the datatype, the second an empty string. When i try to read in a type i get the error "Ambiguous type variable `a' in the constraint Read a"
16:49:59 <lgas> hi.  I'm trying to define a function like so:  integer_pow a b = a ^ b    which I would like to have the type Int->Int->[Integer], because for large enough values of a and/or b, the result will not fit in an Int... but I get a "Couldn't match expected type `Integer' against inferred type `Int'" error when I try.  what am I missing?
16:50:10 <lgas> er, sorry, Int->Int->Integer
16:50:32 <augustss> _40oxo_: that always happens if you don't tell read which type it's reading
16:50:41 <augustss> > read "5"
16:50:42 <lambdabot>   * Exception: Prelude.read: no parse
16:50:48 <augustss> hmmm
16:50:58 <_40oxo_> augustss: of course! i forgot! it works now. thanks
16:51:45 <augustss> _40oxo_: if you want to be able to read, e.g., a list of your things, you have to do better than returning the empty string
16:52:30 <rwbarton> > let integer_pow :: Int -> Int -> Integer; integer_pow a b = (fromIntegral a) ^ b in integer_pow 10 100
16:52:31 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
16:53:04 <lgas> thanks, rwbarton
16:53:37 * dcoutts encourages people to try the darcs version of cabal-install
16:53:57 <dcoutts> with new improved list, info and update commands :-)
16:54:15 <augustss> dcoutts: only darcs?  not on hackage?
16:54:28 <dcoutts> augustss: I'm hoping people will test it before I put it on hackage
16:54:41 <augustss> dcoutts: wimp! ;)
16:54:52 <dcoutts> augustss: and there are a few more big tickets to knock off:
16:54:55 <dcoutts> http://hackage.haskell.org/trac/hackage/query?status=new&status=assigned&status=reopened&milestone=cabal-install-0.6&order=priority
16:55:18 <Taejo> :t fix id
16:55:19 <lambdabot> forall a. a
16:55:20 <u5h> ./` and that's when i say ./
16:55:24 <u5h> ./` exact  change please
16:56:54 <hiredman> you know thanks to unicode you can have real musical notes ♩
16:57:06 <chessguy_work> Saya, ok, got it. have you been able to interface with ghci through it yet? or set up a front end?
16:57:16 <Kamina> Hi
16:57:31 <emptnr_> i don't know how to type those though
16:57:35 <emptnr_> i know the HTML character codes
16:58:15 <dcoutts> augustss: mm, it's a point though. I added a feature to tell people when there's a new version of cabal-install on hackage, but the danger is that it encourages everyone to upgrade too quickly and prevents me from putting betas on hackage.
16:58:17 <Kamina> Does anyone know, if there any "abstraction" from zipWith, which works not just on lists but also on other data structures like trees?
16:58:35 <Itkovian> @seen dons
16:58:35 <lambdabot> dons is in #arch-haskell, #haskell, #xmonad, #darcs, #concatenative and #ghc. I last heard dons speak 28m 22s ago.
16:58:41 <porges> is there currently a function ignore = (>> return ())
16:58:57 <augustss> dcoutts: perhaps there should be a cabal-install-beta package
16:59:04 <porges> would be nice to use with, for example, <|> in Parsec
16:59:09 <emptnr_> what are the RETURN values for the IO MONAD?
16:59:24 <dcoutts> augustss: or I can use the preferred versions thing
16:59:32 <dcoutts> that's probably best and easiest
16:59:35 <wli> porges: I think it's not kept around because it's easy enough to write out inline.
16:59:51 <emptnr_> i assume that it contains a REPRESENTATION of the relevant OPCODES for accessing MUTABLE STATE
16:59:58 <mauke> WHAT are the return VALUES for THE IO monad?
17:00:09 <emptnr_> you tell me!
17:00:19 <Kamina> i guess he meant he didn't understand the question...
17:00:35 <Saya> chess_guy: nope not at all , i barely god to use it in vim mode :)
17:00:41 <tromp__> porges, ignore bla is not much more concise than bla >> return ()
17:00:59 <tromp__> and the latter is directly clear
17:01:16 <Itkovian> dons: Is somebody still maintaining nobench?
17:01:21 <mauke> porges: you could install data-default and shorten return () to def
17:01:22 <dons> malcolm w
17:01:46 <emptnr_> DONS, you're some sort of haskell GURU, do you know what the RETURN VALUES for the IO monad ARE?
17:02:03 <mauke> emptnr_: what's WITH the random CAPITALIZATION?
17:02:16 <emptnr_> mauke: self GRAFITIFICATION!
17:02:16 <dons> ?yow
17:02:16 <lambdabot> Did I say I was a sardine?  Or a bus???
17:02:18 <SamB> he's doing his ZIPPY the PINHEAD immitation
17:02:19 <Taejo> emptnr_, (a) stop shouting; (b) rephrase the question so we can understand it
17:02:26 <emptnr_> samb got it
17:02:27 <SamB> darnit dons, why'd you have to beat me to it
17:02:29 <BONUS> geez what is it with the trolls today
17:02:36 <emptnr_> i don't know how else to phrase it
17:02:37 <Itkovian> dons: ok. any idea if there are other large benchmarks lying around? I'm thinking of picking up the HaBench thingie.
17:02:46 <dons> Itkovian: mmm.
17:02:47 <SamB> dons got it too, obviously ;-)
17:02:51 <dons> Itkovian: ask on -cafe@
17:02:53 <emptnr_> what are the UNIQUE return values for the io monad
17:03:05 <mauke> emptnr_: what
17:03:09 <Kamina> emptnr_: can you give an example?
17:03:09 <porges> tromp__, wli, mauke: on second thought, maybe it would just be easier to define a <|> that ignores everything :)
17:03:21 <emptnr_> i can't, i'm trying to keep it as general as possible
17:03:30 <mauke> yeah, good luck with that
17:03:33 <Taejo> emptnr_, IO is a type. It doesn't have a "return value"
17:03:41 <emptnr_> well... let's say i write the result of function blahBlah to disk
17:03:49 <augustss> emptnr_: mostly 42
17:03:57 <emptnr_> if the function that writes blahBlah to disk has result type IO
17:04:03 <mauke> IO is not a type
17:04:09 * emptnr_ frowns
17:04:17 <SamB> Taejo: why did you just say it was a type ?
17:04:24 <Taejo> It is. It just doesn't have kind *
17:04:30 <BONUS> a function that writes something to the disk usually has a type of IO ()
17:04:33 <SamB> Taejo: no, that's not actually a type
17:04:38 <mauke> only type constructors of kind * deserve the name type!
17:04:41 <BONUS> i mean return type
17:04:47 * emptnr_ frowns some more
17:05:09 <emptnr_> so what is the return value of that function on success, BONUS
17:05:11 <augustss> IO lives in the type world, but the word type is typocally reserved for things of kind *
17:05:25 <Taejo> SamB, haskellwiki says, "Kinds classify types. Kinds are to types and type-constructors what types are to values. Ordinary types have kind *."
17:05:34 <wli> Understanding kinds helps.
17:05:41 <emptnr_> @kind Num
17:05:43 <lambdabot> Class `Num' used as a type
17:05:45 <mauke> emptnr_: there is only one value of type (), namely () and _|_
17:05:47 <SamB> Taejo: well, we take "type" to mean "ordinary type"
17:05:56 <wli> IO :: * -> *
17:05:59 <BONUS> whether it succeeds when performed or not or not, it has a return value of IO (), meaning it's an I/O action
17:06:00 <BONUS> :]
17:06:07 <SamB> and I don't know what we use for that articles "type"
17:06:15 <wli> "Type constructor" perhaps is the best term for types of higher kind.
17:06:19 <emptnr_> so how are the alterations to state performed
17:06:24 <SamB> wli: I guess that's what I use
17:06:31 <emptnr_> and how does that not qualify as impure!
17:06:36 <mauke> emptnr_: magic (implementation detail)
17:06:43 <porges> anyone else getting cabal getting stuck on downloading?
17:06:48 <BONUS> emptnr_: read IO () as: an I/O action that has a result contained within it.
17:06:48 <Taejo> SamB, yeah, so do I... I meant (IO something) is a type
17:06:55 <Taejo> noooo
17:06:58 <BONUS> when you use do notation, you're glueing several of those IO actions into one
17:07:16 <BONUS> and then when you run your program that I/O action is "performed"
17:07:18 <mauke> emptnr_: easy, the string "rm -rf /" is a pure value. but you can still run it with your shell and wreak havoc
17:07:22 <SamB> emptnr_: um, they somehow take away the side or something so it's no longer a "side" effect -- just an honest-to-goodness one
17:07:25 <dcoutts> porges: would you mind trying the darcs version of cabal-install and tell me if it's any better?
17:07:27 <BONUS> so that's the only part that isn't pure (assuming we don't use unsafe stuff)
17:07:28 <Taejo> IO () is the type of IO actions that yield () when run; it doesn't contain anything
17:07:50 * emptnr_ frowns even more
17:07:50 <BONUS> Taejo: that's a better way of putting it, yes
17:07:51 <pumpkin> someone called out coppin on -cafe :P
17:08:08 <chessguy_work> pumpkin, yeah, whassupwiddat?
17:08:09 <SamB> Taejo: sure it does
17:08:14 <augustss> emptnr_: e.g., print 5, is a pure value.  it does have an effect when executed, but it's still a pure value (of type IO ())
17:08:15 <pumpkin> chessguy_work: which bit of it?
17:08:24 <chessguy_work> pumpkin, "yeah, you're a sucky coder"
17:08:24 <SamB> it contains instructions to reformat your hard drive -- if you run it as root -- well, maybe.
17:08:38 <emptnr_> not reformat
17:08:40 <emptnr_> just empty ;)
17:09:04 <Taejo> SamB, to say that getContents "contains" a string contradicts the fact that it might yield "blah" or "ah" depending on when it is run
17:09:05 <pumpkin> chessguy_work: there seems to be some particular issues between Jonathan Cast and Coppin, but I don't really blame Cast :P
17:09:06 <SamB> emptnr_: oh, I guess I was thinking of the DOS version of that
17:09:14 <SamB> which is FORMAT C: or something ...
17:09:27 <emptnr_> watching rm -rf / on ubuntu is more fun than watching football
17:09:30 <emptnr_> much more
17:09:41 <SamB> Taejo: I agree that it doesn't contain the string
17:09:54 <porges> dcoutts: actually just realized I wasn't even using the latest version
17:10:18 <porges> dcoutts: forget that "cabal upgrade" doesn't install newer versions of things that are installed as part of GHC's installation
17:10:26 <Taejo> SamB, ok, I picked a nit, you picked a nit. fair enough.
17:12:04 <augustss> pumpkin: glad you like timeIt, btw.  I've been using it for years, but it seemed too simple to put on hackage
17:12:12 <emptnr_> haha, now i'm op in #haskell-cafe
17:12:13 <emptnr_> !
17:12:16 <emptnr_> take that, world
17:12:29 <pumpkin> augustss: it's nice simple idea that people rewrite far too often :)
17:12:43 <augustss> pumpkin: yes, i know
17:12:53 <emptnr_> augutss: you did it?
17:12:55 <porges> augustss: write it to work with QuickCheck and figure out the O(x) of an arbitrary function ;)
17:13:03 <porges> QuickTime?
17:13:06 * emptnr_ wanders over
17:13:11 <augustss> lol
17:13:16 <pumpkin> emptnr_: no you aren't :
17:13:18 <pumpkin> :o
17:13:29 <emptnr_> that sucks
17:13:36 <emptnr_> well, i'm op in #haskell-cafeteria, at least
17:13:37 <Taejo> personally, I'd have timeIt :: IO a -> IO (a, Double)
17:13:47 <pumpkin> lol
17:13:57 <emptnr_> the food isn't as good
17:14:06 <emptnr_> :/
17:14:29 <augustss> Taejo: Feel free to add a function, but most often I just want to print the CPU time and nothing else
17:14:31 <Botje> try #haskell-bistro
17:14:35 <Botje> "sausages included!"
17:14:43 <emptnr_> i'm op there too
17:14:48 <emptnr_> i'm trying to consolidate the market
17:14:52 <augustss> #haskell-gourmet-restaurant
17:14:59 <pumpkin> that's more like it
17:15:17 <emptnr_> @seen emptnr_
17:15:18 <lambdabot> You are in #haskell. I last heard you speak just now.
17:15:35 <emptnr_> why would you even write a separate conditional for that
17:16:15 <augustss> emptnr_: are you just spouting random nonsense? :)
17:16:31 <emptnr_> no, a separate conditional to see if the author of the @seen query is the same as the argument
17:16:34 <pumpkin> , randE()
17:16:40 <lunabot>  x1 (- 4) (x5 x5) (x1 (\ x4 -> case x5 of { "This " | x1 -> "Th"}))
17:16:43 <pumpkin> , randE()
17:16:45 <lunabot>  ()
17:16:50 <pumpkin> , randE()
17:16:52 <lunabot>  ()
17:16:59 <emptnr_> i never spout nonsense...only sometimes i spout things that are difficult to understand ;)
17:17:03 <augustss> , randE()
17:17:06 <lunabot>  case x0 of { x2 | "Th" -> 1 :: (->) x2}
17:17:17 <mauke> emptnr_ was last seen in #haskell 0s ago, saying: @seen emptnr_
17:17:17 <augustss> they don't look well typed
17:17:22 <rwbarton> Wow, that's hard to parse
17:17:34 <pumpkin> augustss: it's just generating a randomish AST in TH and pretty printing it I think
17:17:46 <porges> lol
17:17:54 <Axman6> :t ?x1 (- 4) (?x5 ?x5) (x1 (\ ?x4 -> case ?x5 of { "This " | x1 -> "Th"}))
17:17:55 <lambdabot> Parse error in pattern
17:18:06 <porges> , randE()
17:18:08 <lunabot>  \ (~x0) -> "Th" x3 :: x1 x0
17:18:15 <emptnr_>  /join #haskell-pizzarrhea
17:18:29 <pumpkin> looks like randE is a valid substitute for emptnr_
17:18:32 <pumpkin> ;)
17:18:49 <emptnr_> i'm a poet baby
17:19:28 <Itkovian> seems like I have subscribed to -cafe using my work email address
17:19:32 <islon_s`> can i define functions inside data definitions?
17:19:59 <Axman6> islon_s`: technically record syntax does that
17:20:18 <Axman6> but they're not very exciting functions
17:20:30 <rwbarton> equally technically every nonempty data definition does that
17:20:52 <emptnr_> if type constructors are objects
17:20:54 <augustss> islon_s`: you can't really define function inside data definitions
17:20:58 <emptnr_> aren't functions with fixed types just methods???
17:21:01 <islon_s`> =/
17:21:02 <Taejo> islon_s`, what exactly do you want to do?
17:21:12 <emptnr_> or data types, not type constructors >:OO#
17:21:13 <islon_s`> something like this:  data Whatever = Whatever {
17:21:13 <islon_s`> 	exciting :: Int -> Int
17:21:13 <islon_s`> 	exciting x = x + x
17:21:13 <islon_s`> 	}
17:21:25 <mauke> huh?
17:21:29 <pumpkin> islon_s`: why?
17:21:30 <mauke> how would you use that?
17:21:42 <pumpkin> islon_s`: why do you want to do it "inside" like that? what does it buy you?
17:21:44 <emptnr_> @let exciting x = x+x
17:21:46 <lambdabot>  Defined.
17:21:47 <islon_s`> its just a dumb example
17:21:48 <emptnr_> > exciting 20
17:21:49 <lambdabot>   40
17:21:55 <emptnr_> o>o.O
17:22:15 <pumpkin> islon_s`: there's no "this/self" like you find in OO, so there's not really much advantage to being "inside"?
17:22:20 <chessguy> hey ski_  you're not around, are you?
17:22:20 <augustss> islon_s`: you can do 'data W = W { f :: Int->Int }; aW = W { f = \ x -> x+x }
17:22:21 <emptnr_> > map (exciting.exciting.exciting) [1..100]
17:22:23 <lambdabot>   [8,16,24,32,40,48,56,64,72,80,88,96,104,112,120,128,136,144,152,160,168,176...
17:22:40 <rwbarton> islon_s`: thee only sense I can make of that is as a "default value" for the exciting field
17:22:49 <pumpkin> @let very f = f . f . f
17:22:50 <rwbarton> islon_s`: which is basically what augustss suggested
17:22:51 <lambdabot>  Defined.
17:22:57 <pumpkin> map (very exciting) [1..10]
17:23:00 <pumpkin> > map (very exciting) [1..10]
17:23:00 <islon_s`> ok, thats exactly what i wanna do: data Person = Person {
17:23:00 <islon_s`> 	dex :: Int
17:23:00 <islon_s`> 	critical x = dex * 2
17:23:01 <lambdabot>   [8,16,24,32,40,48,56,64,72,80]
17:23:03 <islon_s`> }
17:23:06 <Axman6> :t very
17:23:07 <lambdabot> forall c. (c -> c) -> c -> c
17:23:15 <emptnr_> > let pConstrToodle x = x : x^2
17:23:16 <lambdabot>   <no location info>: parse error on input `;'
17:23:17 <augustss> rwbarton: default values for fields would be a bit cool, though
17:23:21 <emptnr_> no you
17:23:25 <chessguy> ok, guys, the noise-signal ratio is getting a little high
17:23:25 <mauke> islon_s`: what is x there?
17:23:32 <Axman6> > fery (+1) 1
17:23:33 <lambdabot>   Not in scope: `fery'
17:23:34 <pumpkin> chessguy: yeah :/
17:23:35 <Axman6> > very (+1) 1
17:23:35 <islon_s`> i just want to define critical as 2 times dex
17:23:37 <lambdabot>   4
17:23:37 <Axman6> even
17:23:47 <mauke> islon_s`: critical x = dex x * 2
17:23:48 <rwbarton> islon_s`: how about  data Person = Person { dex :: Int }; critical x = dex x * 2
17:23:54 <mauke> islon_s`: why does it need to be in the data type?
17:24:04 <Axman6> islon_s`: just define  normal function
17:24:19 <islon_s`> it doesnt its just my long years of OO talking =D
17:24:24 <chessguy> dex :: Person -> Int
17:24:35 <chessguy> you don't want to use that on a number :)
17:25:16 <pumpkin> it's record
17:26:25 <jeffz`> islon_s`: maybe this will help http://learnyouahaskell.com/making-our-own-types-and-typeclasses#record-syntax
17:27:36 <islon_s`> thanks its the best haskell tutorial i've found
17:28:04 <mauke> I read it for the pictures
17:28:26 <pumpkin> I think BONUS spends most of the time on some substance or another
17:30:35 <emptnr_> ok let's say i do
17:30:37 <emptnr_> @let pConstrToodle (x:xs) = pConstrToodle(x**2:xs)
17:30:38 <lambdabot>  Defined.
17:30:53 <emptnr_> to construct the series of powers of 2, lower on the right hand side
17:30:58 <emptnr_> now what ;)
17:31:09 <emptnr_> err
17:31:11 <emptnr_> @undefine
17:31:13 <emptnr_> @let pConstrToodle (x:xs) = pConstrToodle(x**2:x:xs)
17:31:15 <lambdabot>  Defined.
17:31:34 <emptnr_> > pConstrToodle 2
17:31:35 <lambdabot>       No instance for (Num [t1])
17:31:36 <lambdabot>        arising from the literal `2' at <inte...
17:31:42 <emptnr_> why :(
17:31:59 <emptnr_> > take 25 (pConstrToodle 2)
17:32:01 <lambdabot>       No instance for (Num [t1])
17:32:01 <lambdabot>        arising from the literal `2' at <inte...
17:32:07 <emptnr_> this makes me very sad
17:32:21 <mauke> emptnr_: 2 is not a list
17:32:27 <emptnr_> > take 25 (pConstrToodle [2])
17:32:37 <lambdabot>   mueval: Prelude.read: no parse
17:32:44 <mauke> your definition has the form f x = f (...)
17:32:48 <mauke> this is an infinite loop
17:32:52 <emptnr_> yes
17:32:55 <emptnr_> it is
17:32:59 <monochrom> What is emptnr_ doing and why is that creature not using pm.
17:33:30 <emptnr_> > take 25 [1..]
17:33:34 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]
17:34:34 <emptnr_> well, how do i phrase it such that it evaluates
17:34:34 <Corun> TIAIL stands for THIS is an infinite loop. Where THIS stands for TIAL has insane sylables.
17:35:28 <cads> do you guys know if there's a haskell system for symbolic algebraic calculus?
17:35:40 <cads> err, symbolic calculus I meant
17:35:55 <wli> cads: AIUI most such systems are written in other programming languages.
17:36:28 <cads> really what I'd like to find would be a system similar to mathematica that has typed expressions
17:37:07 <cads> wli, aye.. but that tends to be the case with most applications
17:37:26 * sw17ch wants something like GNU screen that works across reboots and also works with X11
17:37:27 <wli> cads: Haskell's type system is rarely expressive enough to capture such. You'd probably be better off with some dependently-typed language for such.
17:37:44 <cads> having weak typing in a system like mathematica seems pretty lame though...
17:38:28 <wli> cads: Go dependently typed for this. Haskell's going to be awkward at best.
17:38:45 <cads> wli, I wouldn't want the type system to do the work of actually integrating functions or anything like that, but being able to interrogate a function to know its type would make programming in mathematica a lot more... possible
17:38:53 <emptnr_> @let acceleration a v t = 0.5*a*t^2 + v*t^2
17:38:56 <lambdabot>  Defined.
17:38:58 <cads> wli, hmm
17:39:12 <cads> I'll look for existing work
17:39:15 <emptnr_> > acceleration 9.801 0 30
17:39:16 <lambdabot>   4410.45
17:39:22 <emptnr_> that's pretty fast!
17:39:30 <wli> cads: The type system can't handle the rings and fields needed for work in such affairs.
17:40:11 <rwbarton> It *can* handle them, but it's difficult and awkward.
17:40:12 <wli> cads: e.g. Q(x,y)/(y^2 - x^2 - 1) a.k.a. Q(x,(x^2+1)^(1/2))
17:40:37 <cads> it seems like research computer algebra systems don't really intersect with type theory and programming language theory in general, it's very specific to formula transforms and heuristics
17:41:21 <wli> rwbarton: The formation of Q(x,(ax^2+bx+c)^(1/2)) on the fly as the result of user input sounds implausible in Haskell at best.
17:41:23 <cads> also most packages work with integral and differential calculus over the reals and have limited ability for analysis in other domains
17:41:47 <cads> it would be interesting to see what dependent types could do for a generalized system of algebra
17:42:18 <emptnr_> joule is meter*newton, right?
17:42:48 <intoverflow> http://en.wikipedia.org/wiki/Joule
17:42:58 * emptnr_ frowns
17:43:21 <cads> the thing is that I'm pretty sure mathematica is coded in c++, and it seems like something like haskell could be so much more appropriate for that kind of endeavor
17:43:21 <emptnr_> latex + links = :(
17:43:22 <rwbarton> wli: Take a look at www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
17:44:18 <intoverflow> it's a meter*newton
17:44:26 <emptnr_> ok
17:44:30 <cads> there was the very interesting paper on overloading types to automatically differentiate functions
17:44:36 * sw17ch wishes for dependent types with no runtime requirements and a flying car that uses no energy
17:44:55 <cads> I still need to finish that to learn how the heck it can evaluate the derivative of sin and other functions
17:45:17 <chessguy> @hpaste2
17:45:17 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:45:25 <mauke> sin is a method. you just define it appropriately
17:45:30 <chessguy> @where moonpaste
17:45:30 <lambdabot> http://moonpatio.com:8080/
17:47:48 <int80_h> howdy #haskell
17:48:16 <int80_h> hi chessguy, hi pumpkin
17:48:25 <pumpkin> yo
17:48:27 <chessguy> 'evnin
17:48:27 <int80_h> et. al
17:48:29 <emptnr_> so is this here correct
17:48:38 <pumpkin> this here correct what?
17:48:44 <pumpkin> this here program?
17:48:47 <cads> > dVar 10
17:48:48 <lambdabot>   10~~
17:48:52 <emptnr_> @let hitTheGroundAtMperS g y = sqrt(g*y)
17:48:58 <lambdabot>  Defined.
17:49:14 <emptnr_> or am i remembering things incorrectly
17:49:17 <int80_h> I'm tempted to post my answer to some of the exercises in chapter 4 on the RWH website. I'll go check to see what people have done so far
17:49:46 <cads> > let x = dVar(pi/2) in sin x
17:49:48 <lambdabot>   1.0~~
17:49:53 <pumpkin> emptnr_: you could just ask that in terms of math, you know :P
17:50:05 <emptnr_> not if i'm trying to write a physics engine X:O
17:50:22 <cads> > let x = dVar(pi/4) in sin x
17:50:23 <lambdabot>   0.7071067811865475~~
17:50:26 <emptnr_> although i doubt i'll ever use that function...
17:50:37 <cads> > let x = pi/4 in sin x
17:50:39 <lambdabot>   0.7071067811865475
17:50:39 <emptnr_> unless...
17:51:32 <emptnr_> anyway, looks like it's actually 2*sqrt(g*y)
17:53:17 <pumpkin> just solve mgh = 1/2mv^2, I guess
17:53:26 <pumpkin> assuming constant gravity
17:53:34 <emptnr_> gh = 1/2v^2
17:53:40 <int80_h> ah I could have used filter
17:53:44 <emptnr_> v = sqrt(2*gh)
17:53:51 <gio123> @seen Cale
17:53:51 <lambdabot> Cale is in #ghc, #haskell and #haskell-overflow. I last heard Cale speak 2h 23m 23s ago.
17:54:06 <emptnr_> close enough ;)
17:54:25 <pumpkin> only off by sqrt2
17:54:43 <gio123> @seen emptnr_
17:54:43 <lambdabot> emptnr_ is in #haskell. I last heard emptnr_ speak 36s ago.
17:54:45 <emptnr_> 2*sqrt2
17:54:52 <ian_calvert> evening all
17:54:53 <emptnr_> oh nevermind :O
17:54:54 <ian_calvert> if I have a return value like: "if (f(x)<y) then f(x) else y", does f(x) get called once or twice?
17:54:59 <emptnr_> too tired for maths
17:55:01 <pumpkin> but if you're writing a general physics engine, maybe you should model real gravity?
17:55:07 <emptnr_> yeah, yeah
17:55:08 <bd_> ian_calvert: it doesn't matter
17:55:08 <gio123> @seen emptnr_
17:55:08 <lambdabot> emptnr_ is in #haskell. I last heard emptnr_ speak just now.
17:55:15 <emptnr_> it's not that much different
17:55:26 <emptnr_> except for that weird potential energy at infinite distance is 0 thing
17:55:40 <rwbarton> ian_calvert: probably twice, in practice
17:55:41 <pumpkin> well, the g in there isn't constant, as it depends on y
17:55:43 <mauke> ian_calvert: twice
17:55:47 <emptnr_> or was my teacher just lying to me...
17:55:47 <ian_calvert> bd_: more specifically, does f(x) get *evaluated* once or twice
17:55:50 <ian_calvert> muake: ah thanks
17:56:02 <bd_> ian_calvert: it's undefined. the compiler may or may not get clever and do CSE
17:56:08 <cads> this is an awfully silly question guys, but how do I evaluate fractional exponents in general: 2^(1/2)  => Ambiguous type variable
17:56:12 <mauke> ghc is rather conservative wrt CSE
17:56:19 <mauke> > 2^^0.5
17:56:20 <lambdabot>   Add a type signature
17:56:26 <pumpkin> cads: or **
17:56:26 <mauke> :-/
17:56:31 <ian_calvert> right, thanks guys
17:56:34 <bd_> > 2 ^^ 0.5 :: Float
17:56:35 <mauke> > 2^^0.5 :: Double
17:56:36 <lambdabot>   Add a type signature
17:56:36 <lambdabot>   Add a type signature
17:56:41 <mauke> > 2 ^^ (0.5 :: Double)
17:56:42 <pumpkin> > 2 ^^ (0.5)
17:56:42 <lambdabot>       No instance for (Integral Double)
17:56:42 <lambdabot>        arising from a use of `^^' at ...
17:56:43 <lambdabot>   Add a type signature
17:56:46 <mauke> er
17:56:47 <pumpkin> anyway,
17:56:50 <pumpkin> > 2 ** 0.5
17:56:52 <lambdabot>   1.4142135623730951
17:56:54 <mauke> NEGATIVE, NOT FRACTIONAL
17:56:55 <emptnr_> remind me what ^^ does
17:57:00 <mauke> mauke--
17:57:03 <ian_calvert> is there a better way of doing that thing then? It must be quite a general operation to perform.
17:57:13 <mauke> emptnr_: integral exponents
17:57:13 <emptnr_> if anything
17:57:17 <rwbarton> ian_calvert: min (f x) y
17:57:17 <emptnr_> integral exponents
17:57:18 <wli> cads: 2**(1/2) might do better.
17:57:30 <emptnr_> what does that mean
17:57:41 <pumpkin> uh, whole numbers
17:57:46 <cads> > (**)
17:57:47 <emptnr_> nevermind
17:57:47 <lambdabot>       Overlapping instances for Show (a -> a -> a)
17:57:47 <lambdabot>        arising from a use ...
17:57:54 <emptnr_> i thought that was the difference between ** and ^
17:57:56 <cads> > :t (**)
17:57:57 <lambdabot>   <no location info>: parse error on input `:'
17:58:02 <sw17ch> is there a good way of making a haskell program into a windows service?
17:58:08 <pumpkin> emptnr_: ^^ allows negative ones
17:58:11 <emptnr_> sw17ch: stop using windows
17:58:14 <emptnr_> gotcha
17:58:16 <chessguy> @hoogle [a] -> [a] -> [(a,a)]
17:58:17 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
17:58:17 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
17:58:17 <lambdabot> Prelude divMod :: Integral a => a -> a -> (a, a)
17:58:24 <emptnr_> don't allow your clients to use windows, either
17:58:26 <sw17ch> emptnr_, welcome to the real world, we have to use windows here
17:58:28 <emptnr_> there's only one way out of this mess we're in ;)
17:58:29 <chessguy> @hoogle+
17:58:29 <lambdabot> Prelude quotRem :: Integral a => a -> a -> (a, a)
17:58:29 <lambdabot> Data.ByteString breakSubstring :: ByteString -> ByteString -> (ByteString, ByteString)
17:58:29 <lambdabot> Data.ByteString.Char8 breakSubstring :: ByteString -> ByteString -> (ByteString, ByteString)
17:58:43 <sw17ch> emptnr_, well, as long as the mess keeps handing me $$$ :P
17:58:53 <emptnr_> that's the sort of attitude that enslaves half the world
17:58:55 <sw17ch> and this is open source... and i'd rather have it work across platforms
17:58:58 <ian_calvert> rwbarton: sorry, this was a simplified version of what I meant. "if (f(x)<f(y)) then x else y" is more accurate
17:59:03 <sw17ch> emptnr_, i'm a slave to my stomach, what can i say
17:59:13 <emptnr_> grow your own food ;)
17:59:14 <rwbarton> @hoogle minBy
17:59:15 <lambdabot> No results found
17:59:27 <sw17ch> aannnyyy way, since he's not helpful, any one else?
17:59:29 <ian_calvert> apologies didn't think that one through before posting!
17:59:33 * pumpkin enjoys his spam
17:59:38 <rwbarton> ian_calvert: That doesn't have any repeated computations in it, so I'm not sure what you're looking for
17:59:47 <sw17ch> pumpkin, i'd be glad to sign you up for some more!
17:59:56 <pumpkin> sw17ch: thanks! this can is almost empty
18:00:07 * wli attempts to figure out how to navigate a 4-parameter family of solutions to a system of quadratic equations for the purposes of optimizing some functional.
18:00:30 <int80_h> if your application is web based, you can use any damn platform you please
18:00:49 <int80_h> which I guess is one good argument for web based applications
18:00:50 <chessguy> is there some non-comprehension version of \xs ys -> [(x,y) | x <- xs, y <- ys]
18:00:53 <emptnr_> int80_h: i have a dual boot on here, web apps go across both OSes ;)
18:00:56 <wli> (e.g. the variance of the function described by the parameters).
18:01:05 <emptnr_> mysqld/mysql service + apache/lighttpd
18:01:05 <mauke> @undo \xs ys -> [(x,y) | x <- xs, y <- ys]
18:01:05 <lambdabot> \ xs ys -> concatMap (\ x -> concatMap (\ y -> [(x, y)]) ys) xs
18:01:10 <mauke> @. pl undo \xs ys -> [(x,y) | x <- xs, y <- ys]
18:01:10 <lambdabot> (. flip ((=<<) . flip flip [] . ((:) .) . (,))) . (>>=)
18:01:13 <pumpkin> chessguy: sure
18:01:13 <Botje> chessguy: liftM2 (,) ?
18:01:25 <pumpkin> liftM2, liftA2, <$>
18:01:29 <int80_h> so there are bindings to Java, right?
18:01:39 <chessguy> @type liftM2
18:01:40 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:01:46 <ozy`> int80_h: eheheheheh.
18:01:47 <chessguy> ah
18:01:58 <emptnr_> anyway, sw17ch
18:02:01 <emptnr_> you still there?
18:02:03 <int80_h> ozy` : no?
18:02:13 <pumpkin> > (,) <$> [1..3] <*> [7..11]
18:02:15 <lambdabot>   [(1,7),(1,8),(1,9),(1,10),(1,11),(2,7),(2,8),(2,9),(2,10),(2,11),(3,7),(3,8...
18:02:18 <int80_h> ozy` : or is that code for "let's not go there"
18:02:21 <rwbarton> @type flip flip []
18:02:22 <lambdabot> forall a c a1. (a -> [a1] -> c) -> a -> c
18:02:23 <pumpkin> there's also the infix applicative stuff
18:02:25 <ian_calvert> rwbarton: gah sorry I'm trying to shrink the horrible line of code I've got :) x and y in this are generated by another function
18:02:29 <ozy`> int80_h: not directly. there are C bindings for both haskell and java.
18:02:37 <rwbarton> ian_calvert: In general, if you want to control sharing, use let
18:02:41 <rwbarton> (or where)
18:02:51 <emptnr_> sw17ch: i know there are methods to do it for delphi and visual C++, otherwise you might have to thread it through svchost as a DLL
18:02:52 <sw17ch> emptnr_, yes
18:02:52 <ian_calvert> rwbarton: so i wasn't sure if x would get repeatedly generated
18:03:01 <ian_calvert> rwbarton: thanks I'll go have a look at that
18:03:16 <pumpkin> ian_calvert: you can also use (to play with it) Debug.Trace to figure out when stuff gets called
18:03:28 <sw17ch> emptnr_, yeah, i'm afraid that the daemonizing will be the second part of this project that needs to be per-platform
18:03:29 <sw17ch> :\
18:03:37 <koninkje> When installing a Cabal package, does anyone know how to pass --includedir through to autoconf?
18:03:42 <ian_calvert> rwbarton: ah thanks, that's going to be *very* useful
18:03:45 <emptnr_> i'm a big fan of writing things for linux and letting other suckers port them >:D
18:03:48 <sw17ch> so far, i only need a little bit of C code for the network driver, and a very short CPP statement in one haskell file
18:03:49 <ozy`> int80_h: but since haskell doesn't (and might never) run on the JVM, it's not all that easy to make them interact
18:04:06 <ian_calvert> rwbarton: my first day with haskell, that's certainly a good time to find out about traces!
18:04:14 <sw17ch> emptnr_, help me add cool features to my project and i'll port them :P
18:04:21 <emptnr_> what's your project
18:04:23 <Adamant> ping dons: would you be interested in an article that shows what of those Top 25 security bugs are preventable in the typesystem?
18:04:39 <ozy`> Adamant: I'd be interested in that....
18:04:42 <sw17ch> emptnr_, http://code.google.com/p/scurry/
18:05:18 <sw17ch> I'm killing the first bullet on the "Doesnt Have" list right now
18:06:49 <emptnr_> what are you adding to VPns
18:06:55 <emptnr_> VPNs
18:07:05 <sw17ch> emptnr_, it's P2P
18:07:14 <emptnr_> so like alliance?
18:07:22 <sw17ch> any one can join the network by connection to any one else already present on it
18:07:29 <sw17ch> alliance? not familiar wiht it
18:07:30 <emptnr_> nifty
18:07:53 <sw17ch> it's riddled with security holes and has no model for any sort of security yet at all :)
18:08:01 <sw17ch> aka: it's useful for LAN games
18:08:12 <emptnr_> it's useful for more than that
18:08:13 <sw17ch> perhaps, i should say that there are no security holes
18:08:17 <sw17ch> there's no security!
18:08:18 <emptnr_> write the code solidly and you've got yourself
18:08:19 <emptnr_> a darknet!
18:08:21 <emptnr_> :D
18:08:22 <chessguy> @pl d x y = c (u r) $ p x y
18:08:22 <lambdabot> d = (c (u r) .) . p
18:08:24 <rwbarton> ian_calvert: the other place that sharing comes from is when applying a function
18:08:26 <emptnr_> and a nifty darknet
18:08:39 <sw17ch> emptnr_, i'm debating writing the security later with OpenSSL or libgcrypt...
18:08:43 <sw17ch> i can't decide
18:08:44 <Adamant> emptnr_: any darknet worth it's salt at least obfuscates
18:08:51 <emptnr_> exactly, adamant
18:08:56 <sw17ch> either way, some serious binding work will be needed
18:08:57 <rwbarton> ian_calvert: if I write  double x = x + x,  and then call  double (3 + 5),  you can think of it as expanding to  let x = 3 + 5 in x + x
18:09:05 <emptnr_> openssl should be good until somebody cracks SSL ;)
18:09:14 <emptnr_> which i'm assuming the NSA already has
18:09:19 <sw17ch> Adamant, for the record, it wouldn't be hard to put TOR style routing in this
18:09:21 <rwbarton> ian_calvert: evaluating x + x will force the evaluation of x, so it becomes  let x = 8 in x + x, or 8 + 8, or 16
18:09:27 <Adamant> or they let Coverity loose on the codebase again
18:09:34 <rwbarton> ian_calvert: So the parameter to double only gets evaluated once
18:09:34 <emptnr_> sw17ch: so long as it doesn't have a set number of nodes per connection
18:09:35 <Adamant> or was it Fortify
18:09:39 <Adamant> can't remember
18:09:41 <emptnr_> and a constant stream of noise in lieu of signal
18:09:50 <ian_calvert> rwbarton: ahh I see
18:09:53 <emptnr_> such that traffic timing analysis can't be performed
18:10:00 <emptnr_> <3
18:10:06 <sw17ch> emptnr_, umm... it uses a single socket ... so it should be able to connect to anything
18:10:11 <Adamant> emptnr_: that's a great idea but it's going to be slow as hell
18:10:15 <rwbarton> ian_calvert: Technically none of these sharing properties are guaranteed by the language specification, but they're reliable guidelines in practice.
18:10:17 <sw17ch> emptnr_, well, patches are accepted :)
18:10:20 <Adamant> as in even more unusable than Tor
18:10:26 <Adamant> which is just usable enough
18:10:29 <chessguy> > concatMap (uncurry f) $ [1..5] [6..10] :: Expr
18:10:29 <sw17ch> :)
18:10:30 <lambdabot>   Couldn't match expected type `t -> [(a, b)]'
18:10:37 <emptnr_> adamant: no, it'll be just as fast as before ;)
18:10:43 <sw17ch> *sigh*
18:10:45 <ian_calvert> rwbarton: good to know, thanks :)
18:10:48 <sw17ch> i just want to play LAN games :)
18:10:52 <Adamant> :)
18:10:53 <sw17ch> and didn't want to use hamachi any more
18:11:10 <emptnr_> think big, sw17ch ;)
18:11:21 <Adamant> he's already thinking big
18:11:22 <emptnr_> and don't sign any non-disclosure agreements!
18:11:26 <Adamant> there's already OpenVPN
18:11:36 <sw17ch> Adamant, a quick tidbit about that...
18:11:39 <chessguy> > liftM2 (,) [1,2] [3..5]
18:11:40 <lambdabot>   [(1,3),(1,4),(1,5),(2,3),(2,4),(2,5)]
18:11:44 <sw17ch> OpenVPN's codebase is between 50K and 80K lines
18:11:48 <ian_calvert> rwbarton: I've been very nicely surprised by lazy evaluation of things so far, particularly in the construction of lists
18:11:51 <sw17ch> i stole their TUN/TAP driver on windows
18:11:52 <emptnr_> you guys would have self-deployable youtubes ala wordpress by now if it weren't for my NDAs
18:12:05 <sw17ch> my code base is <3K lines of haskell + C
18:12:12 <Adamant> sweet
18:12:14 <sw17ch> and reproduces most of the functionality + P2P
18:12:17 <ian_calvert> rwbarton: but it's going to take some getting used to before I stop getting confused about whether or not something will be evaluated
18:12:21 <sw17ch> and - security
18:12:44 * sm prints the first and last line of eg logfiles: | ghc -e 'let fl ls = [head ls] ++ [last ls] in interact $ (unlines . fl . lines)'
18:13:03 * sw17ch publishes personal work immediately to avoid tricky legal situations later
18:13:33 <emptnr_> hehe
18:13:51 <emptnr_> maybe if i just release the code anonymously
18:14:04 <islon_s``> how i convert from a Fractional to Int?
18:14:13 <sw17ch> most of my code has my fingerprints all over it... perhaps it's not the same for you :)
18:14:19 <emptnr_> it's not exactly complicated, just a normal web framework with ffmpeg jammed in
18:14:27 <ian_calvert> rwbarton: Yes! I changed it to use "let" and it makes my code fantastically cleaner
18:14:33 <ian_calvert> rwbarton: thanks for all the help
18:15:27 <jeffz`> sw17ch: did you get an answer re windows service? iirc, you just need to define an non-main entry point that follows some basic semantics, there's a small C example in the platform SDK
18:15:58 <sw17ch> jeffz`, no, i didn't. there's nothing on hackage for this yet, is there?
18:16:04 <emptnr_> jeffz': how do you get it to run as a recognized service in that little service manager? through svchost?
18:16:36 <sw17ch> emptnr_, i don't care about service right now
18:16:46 <sw17ch> well, i suppose i do... but not too much :)
18:17:06 <jeffz`> emptnr_: darned if i can remember, I did it two years ago just using the platform sdk example, don't think it was very hard.
18:17:12 <islon_s``> /msg lambdabot @define blah :: Int -> Int
18:17:12 <islon_s``> blah x = x / 2
18:19:06 <rwbarton> ian_calvert: ah, so now you're nicely set up to be confused the first time you come across an expression that lazy evaluation doesn't handle well :)
18:19:30 <rwbarton> ian_calvert: but it is massively useful to be able to say things like "head (filter f [1..])", and so on
18:19:59 <Nafai> Anyone familiar with the feed package on Hackage?
18:20:12 <rwbarton> Nafai: I've used it
18:20:23 <pumpkin> rwbarton: why not find?
18:20:31 <pumpkin> oh
18:20:39 <Nafai> I want to "filter" an existing RSS feed that I've downloaded
18:20:39 <pumpkin> that wasn't your point :P
18:20:44 <ian_calvert> rwbarton: yeah. I'm using it at the moment because I need to generate a set of neighbours to an input and find one which is "fitter" than the input
18:20:47 <rwbarton> pumpkin: Well, sure, ..., yeah. :)
18:20:47 <jeffz`> emptnr_: iirc, the example code in the sdk had something to install the service
18:21:09 <rwbarton> ian_calvert: right, it's good at separating generation from processing.
18:21:18 <ian_calvert> rwbarton: it's likely to only have to check 4/5 neighbours to find this, but there might be 20 M neighbours
18:21:24 <Nafai> I've got the feed, I've got the items from the feed, filtered the items, but I'm not sure if there is a straight-forward way of creating a new feed object that is all the same except the items
18:21:29 <Nafai> Or updating the old one
18:22:18 <ian_calvert> rwbarton: yeah, that's what drew me to the language in the first place. I think in for loops, so that change is infuriating at times, but this is great
18:22:52 <rwbarton> Nafai: like \feed -> feed { feedEntries = filter good (feedEntries feed) }?
18:23:06 <Nafai> Yeah, that might work
18:23:13 <ozy`> "On the TV show Heroes, the villain Sylar has the meta-ability of taking the abilities of other super-powered characters for himself.  Similarly, Lisp has the ability to take features from other programming languages and make them its own." <- I'm still laughing
18:23:14 <Nafai> Sorry, still a bit of a Haskell newb :)
18:24:36 <gwern> '
18:24:37 <gwern> 'Not really.  My company *advertises* for Haskell developers, and then
18:24:38 <gwern> when they come in to interview, informs them that the code base is
18:24:38 <gwern> actually written in Perl.  Works, too --- we have several Haskellers
18:24:38 <gwern> working here.  If all you care about is the quality of the developers,
18:24:40 <gwern> and not their productivity once you've got them, you don't actually need
18:24:42 <gwern> to let them use Haskell after the interview is over...'
18:25:11 <rwbarton> Nafai: It'd be nicer with functional references, you have to get your hands a little dirty using the record syntax directly (duplication of feed and feedEntries)
18:25:36 <cads> ozy`, that's good :D
18:25:42 <rwbarton> gwern: What I don't get is why you wouldn't care about their productivity...
18:26:09 <ozy`> cads: http://web.mac.com/jimbokun/iWeb/Site/Blog/AB35C167-7755-4113-938C-968F65256D76.html
18:26:15 <QtPlatyp1s> gwern: Thats nasty, though there seems to be a strong corraspondence between very good perl programers and very good haskellers.  Though I'm not sure why since on the surface there compleatly oppisite lanuages.
18:26:24 <cads> it seems like s-expressions are a lowest common denominator that can embed just about any semantics
18:26:38 <pumpkin> cads: it's just a simple AST representation
18:26:42 <cads> but never super consisely
18:26:45 <rwbarton> ... unless you're trying to steal other companies' programmers, or something
18:26:50 <gwern> rwbarton: I assume that the (high-quality haskellers - cost of retraining) > (low quality perlers - 0)
18:27:08 <ozy`> QtPlatyp1s: well after all, perl allows much of the same shredding and juggling of bits of code and data that haskell allows
18:27:47 <cads> ozy, the title of that article is a little humorous
18:28:09 * cads remembers going around as a tot asking that question
18:28:15 <QtPlatyp1s> ozy`: True and books like Higher Order Perl show that Perl can be a (abit dynamically typed) functional lanauge.
18:28:33 <sw17ch> ozy`, in haskell, i can index a string :)
18:28:43 <cads> "I should learn c++, right you guys?"
18:29:06 <ozy`> QtPlatyp1s: I almost mentioned HOP actually
18:29:14 <gwern> cads: why would you?
18:29:26 <gwern> c would seem to be more learnable and more applicable to haskell
18:29:43 <ozy`> cads: were you one of those kids who insisted that programs written in C should be written in C++ with the expectation that the result would increase the program's feature set?
18:29:58 <cads> qwern, I was making fun of myself from years ago
18:30:33 <cads> ozy, I was trying to write raytracers, and there were these strange abstract things I'd heard about called virtual functions
18:30:45 <cads> and I didn't know what they were but i sure as hell knew I didn't want them in my raytracer
18:30:57 <cads> so I wasn't sure if C++ was the way to go..
18:31:11 <cads> also, this story might be from the java phase..
18:33:00 <QtPlatyp1s> It took me years after learning C to relize why it was the way it was on a fundermental leval.  For want of a better word untill I groked its philosphy.
18:34:42 <Nafai> rwbarton: *nods*
18:37:25 <koninkje> @seen dons
18:37:25 <lambdabot> dons is in #arch-haskell, #haskell, #xmonad, #darcs, #concatenative and #ghc. I last heard dons speak 40m 43s ago.
18:38:39 <Nafai> What does cabal-install do with the source of the packages it installs?
18:39:36 <porges> keeps it
18:40:04 <porges> ~/.cabal/packages/hackage.haskell.org/
18:42:14 <Nafai> porges: Thanks
18:42:25 * pumpkin proposes dons change his nick to donst lest people think it's donsd
18:43:17 <wli> QtPlatyp1s: C could be much different without compromising its design goals. There is a lot about C that's a product of when it was designed, the culture in which it was designed, etc.
18:44:25 <sw17ch> i've been half tempted to use Language.C to make a variant that has type inference and is immutable by default
18:44:47 <lgas> an example of a much different C is: http://cyclone.thelanguage.org/
18:45:55 * wli would probably leave out a lot of things Cyclone chose to put in, though Cyclone does some of what I'd want out of a "better C."
18:47:02 <wli> I don't remember what I considered missing; I suspect affairs in/around the module system.
18:47:20 <Adamant> ozy`: honestly, most dynamically typed programming languages in any kind of real current use are in some way milking stuff that was previously developed in a Lisp. I think ML, Haskell, and Prolog are the only major languages that didn't just rehash stuff from Lisp but with infix syntax. I'd include Smalltalk but it was heavily influenced by Lisp though it deserves it's own mention for it's take on objects.
18:47:30 <Adamant> well, Forth as well
18:47:35 <Adamant> and APL
18:48:26 <emptnr_> have you seen lua adamant ;)
18:48:29 <koninkje> Adamant: and, of course, many of the Prolog derivatives
18:48:36 <emptnr_> if haskell is a porcupine, lua is a baby duck
18:49:05 <Adamant> emptnr_: Lua admits Scheme and Smalltalk influence, along with Ruby
18:49:08 <Nafai> rwbarton: You wouldn't happen to know how to output the actually RSS after you are done processing it, are you?  I'm not finding anything obvious :)
18:49:25 <emptnr_> sounds about right
18:49:49 <Adamant> koninkje: I agree but I sort of covered that with Prolog, and stuff like Mercury is sort of pulling from Prolog and Lisp/ML/Haskell
18:50:05 * wli is a mercury user as well.
18:50:25 <Adamant> I need to sit down and really learn Mercury at some point beyond minor futzing
18:51:15 <emptnr_> i need to learn S++
18:51:21 <ray> haskell is more of a hedgehog than a porcupine
18:51:25 <ray> it's spiny in a *cute* way
18:51:33 <emptnr_> so it's like a really fast rhinoceros
18:51:39 <koninkje> Adamant: sure. I was thinking of stranger ones like lambda-prolog and dyna. Mercury is like Prolog with practicality, instead of Prolog with more Prolog ;)
18:51:41 <emptnr_> in cubism
18:51:43 <Nafai> ray: :)
18:52:12 <koninkje> (or Goedel: Prolog with FORTRAN!)
18:52:23 <Adamant> wli: I think a lot of Cyclone is influenced by legacy concerns. BitC is sort of an attempt to do a new wave modern C from scratch. I'm not counting on it ever being useable for anyone beyond the creators though
18:52:57 <Adamant> koninkje: I have never even heard of those! thank you for introducing me!
18:53:10 * wli remembers looking at BitC but not muc concrete besides not being much more enthused about it than Cyclone.
18:53:17 * koninkje is working on implementing Dyna v2 in Haskell
18:53:31 <Adamant> it looks much nicer to me than Cyclone, but that's mostly on paper
18:53:37 * wli hasn't heard about Dyna.
18:53:40 <Adamant> I think Cyclone has more infrastructure
18:53:44 <koninkje> lambda-prolog, though interesting, is sadly dead-ish mush like Goedel
18:54:37 <koninkje> wli: Dyna is a typed weighted-logic language with memoization. Designed for dynamic programming goodness
18:54:42 <Adamant> SNOBOL turns out to have an interesting history
18:54:54 * wli has generally been rather happy with Mercury when logic languages are wanted/needed.
18:55:13 <Adamant> I wonder if it wasn't named after the -BOL family languages if more people would be interested in it
18:55:19 <Adamant> it has no direct connection to them
18:55:37 <Adamant> they named it that instead of Snowball
18:55:53 <sw17ch> > if True else 1 then 0
18:55:54 <lambdabot>   <no location info>: parse error on input `else'
18:55:59 <sw17ch> gosh, too bad i can't do that
18:56:15 <sw17ch> if True else [short thing] then [really long thing]
18:56:25 <koninkje> Dyna v1 stuff can be found <http://www.cs.jhu.edu/~jason/research.html#acl04-dyna> though that version is untyped, can only do semiring weighting, and has a single namespace
18:56:34 <emptnr__>                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
18:56:40 <sw17ch> though, i'm sure that'd confize the whatchamawhozit out of people
18:56:48 <emptnr_> stupid freenode
18:56:59 <ray> template haskell can solve that!
18:57:23 <koninkje> sw17ch: why not just invert the predicate? ghc should be able to optimize that away
18:57:30 <Nafai> rwbarton: Nevermind, I figured it out
18:57:56 <koninkje> sw17ch: that is @if not (...) then ... else ...@
19:00:01 <mofmog> If you can access IRC but not websites in general, does that mean comcast is throttling your internet?
19:00:30 <sw17ch> koninkje, ... let me go back to school for 4 more years after that one
19:00:45 <sw17ch> thanks for pointing out my stupid mistake... and crap. the internet remembers everything
19:01:00 <jeffz`> sw17ch: I might have a play with the win32 stuff and see if I can come up with that missing services library
19:01:25 <sw17ch> jeffz`, if you make any progress... plesae let me know ... or announce on -cafe or something
19:01:30 <sw17ch> i'd love to have something like that
19:01:32 * jeffz` nods
19:01:38 <chessguy_work> this is thoroughly awesome and mind-blowing: http://obfuscatedcode.wordpress.com/2008/02/16/functional-pearl-trees/
19:03:21 <Gracenotes> chessguy_work: lazy pattern evaluation still blows my mind :>
19:03:35 <chessguy_work> totally
19:04:51 <Gracenotes> > let (a, b, c) = (b+1, c+1, 1) in a   --weeeiiiird
19:04:53 <lambdabot>   3
19:06:08 <pumpkin> Gracenotes: that's cute
19:06:10 <ozy`> chessguy_work: dude................ dude.
19:06:19 * chessguy_work grins
19:06:25 <chessguy_work> this is why we love haskell :)
19:07:00 <Gracenotes> I pledge allegiance to the Haskell... and to the lambda calculus on which it stands...
19:07:48 <int80_h> several combinators, under Curry...
19:08:41 <int80_h> with Purity and Monads for all.
19:09:31 * Gracenotes puts his hat back on
19:09:45 <Adamant> ah. how do you force a new default ghc when you have both ghc-6.8 and 6.10 on your system?
19:10:38 <Adamant> installer for OS X didn't do it, I don't know if I should have deleted ghc-6.8 first
19:10:58 <chessguy_work> hmm, strange. why did i think Gracenotes was not male?
19:11:02 <SamB> Adamant: ls -l $(which ghc)
19:11:14 <Gracenotes> androgynous name?
19:11:16 <SamB> chessguy: the "Grace" at the beginning ?
19:11:30 <koninkje> anyone know how to pass Cabal the extra-lib-dirs field on the command line?
19:11:38 <chessguy_work> Gracenotes, did we use to chat sometimes on #javascript?
19:11:54 <Gracenotes> yeah.
19:11:59 <int80_h> chessguy hangs out in #javascript!!!!
19:12:01 * Gracenotes visits there sometimes
19:12:05 <int80_h> oh the scandal!
19:12:06 <chessguy_work> weird. i thought you were female there too
19:12:19 <Adamant> ah, the Macports version is probably getting in the way
19:12:28 <chessguy> int80_h, not so much these days
19:12:31 <Gracenotes> I'll probably come back the next time I'm working on a JS project :) I just haven't used it in a very long time
19:12:45 <ddarius> The technique in that blog post is called circular programming.  One particularly handy application of it is handing various forms of forward reference.
19:12:59 <int80_h> what is forward reference?
19:13:17 <MyCatVerbs> int80_h: a forward reference is where you refer to something that hasn't been fully defined yet.
19:13:35 <chessguy> yes, i've heard of circular programming before. this is a very nice example of it
19:13:47 <ddarius> chessguy: It's the archetypical example.
19:13:56 * wli sees a lot of it with arrays.
19:14:04 <Gracenotes> arrays, hm?
19:14:24 <dolio> It makes dynamic programming particularly elegant.
19:14:34 <dolio> Which is usually where the arrys show up.
19:14:35 <MyCatVerbs> Gracenotes: I have a program for calculating Levenstein differences...
19:14:36 <chessguy> dolio, hm. how so?
19:14:53 <MyCatVerbs> Er, Levenshtein.
19:15:31 <MyCatVerbs> chessguy: every position in the array is assigned to a function of its indices and the array.
19:16:03 <Gracenotes> ah! I've used that before with an LCS problem
19:16:20 <chessguy> hmm
19:16:24 <MyCatVerbs> chessguy: the function looks at the indices. If it's working on a cell whose value it can work out right away, it does so. Otherwise it indexes to look up the other cells that the one it's calculating for depend upon.
19:16:36 <dolio> chessguy: You don't have to worry about building up the array bit by bit in a loop. You just make a circularly defined array and it all works out naturally.
19:16:48 * wli forgets the definition of Levenshtein distance.
19:16:50 <ddarius> I have an example of using circular programming to resolve forward references on http://web.archive.org/web/20061011010615/www.haskell.org/hawiki/TyingTheKnot near the bottom.  (The code containing the function 'fixup'.)
19:16:54 * chessguy is not visualizing it
19:17:23 <islon_s``> can i make a function that receive only a positive Int?
19:17:25 <ddarius> chessguy: It works like a spreadsheet (roughly)
19:18:13 <ddarius> islon_s``: What do you want to happen if someone attempts to pass a negative or zero Int?
19:18:15 <MyCatVerbs> chessguy: http://www.cs.bris.ac.uk/home/rb6822/Levenshtein.hs
19:18:19 <dolio> let foo n = ... fooMemo n ; fooArr = listArray (k,k') (map foo [k..k']) ; fooMemo n = fooArr ! n in ...
19:18:33 <islon_s``> ddarius: hmmm... Nothing =D
19:18:34 <Gracenotes> islon_s``: you could make it throw an error if the predicate is not met, return NaN, or return Maybe <ResultType>. Depends on the func, I think
19:18:41 <wli> Yeah, DFA's are one of the better examples.
19:18:50 <MyCatVerbs> Levenshtein distance is edit distance between two strings. Total number of insertions, deletions, replacements.
19:19:14 * wli is still foggy on the algorithms and data structures for LBA's.
19:19:30 <Gracenotes> MyCatVerbs: oh, really, it's that simple? Do you take into account the length of insertions, etc.?
19:19:42 <xpika> @src return
19:19:42 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
19:19:54 <MyCatVerbs> Gracenotes: IIRC the definition of insertions and deletions says one character at a time.
19:20:04 <Gracenotes> ah.
19:20:11 <MyCatVerbs> xpika: return is defined individually for each monad.
19:20:34 <Gracenotes> so you could recursively find the longest common subsequences, take length of both strings - (2*length of LCS's)
19:20:41 <MyCatVerbs> xpika: e.g. return in the list monad is (\x -> [x]). In the Maybe monad, it's (\x -> Just x).
19:21:12 * Gracenotes isn't sure about the time complexity of that, though :/
19:21:13 <xpika> MyCatVerbs: what about IO?
19:21:24 <MyCatVerbs> xpika: compiler magic. :)
19:21:55 <xpika> MyCatVerbs: meowy!
19:22:10 <MyCatVerbs> xpika: roughly, (\x -> do_nothing_and_return x).
19:22:36 <xpika> MyCatVerbs: id?
19:22:47 <MyCatVerbs> xpika: yeah, more or less.
19:22:53 <MyCatVerbs> IO is implemented internally in GHC using world-passing style.
19:23:07 <sbahra> Well.
19:23:19 <sbahra> I tried teaching Haskell to some undergraduates.
19:23:31 <chessguy> @quote explode
19:23:31 <lambdabot> cjeris says: Cale: I like how you conveniently gloss over the part where your head explodes.
19:23:32 <sbahra> Started with 12, by end of tutorial...4.
19:24:14 <Gracenotes> wait, what? Did they walk out? :(
19:24:18 <ray> solution: find better undergraduates
19:24:37 <ray> fallback plan: build better undergraduates
19:24:40 <MyCatVerbs> xpika: So ((return x) >>= somethingElse) compiles to (\world -> somethingElse x world). And somethingElse compiles to something that looks like (\x world -> ...), where '...' does more stuff to the world. :)
19:25:12 <chessguy> ray, i think there's a hackage library for that...
19:25:26 <sbahra> Gracenotes, yes.
19:25:27 <int80_h> sbhara: I noticed a similar rate of attrition when I was an ancient greek student. Day 1 Semester 1, 24, Day 2 12. Last day second semester 4.
19:25:28 <ray> @faq Can Haskell build the perfect undergraduate?
19:25:28 <lambdabot> The answer is: Yes! Haskell can do that.
19:25:32 <porges> returnIO x = IO (\ s -> (# s, x #))
19:25:47 <emptnr_> how do i write functions in haskell that write functions ;)
19:25:49 <sbahra> Gracenotes, it was supposed to be an hour, so some people walked out after that. More after 1.5.
19:25:54 <sbahra> emptnr_, Template Haskell
19:26:02 <emptnr_> that's beautiful eh
19:26:18 <int80_h> sbahra, what's the prerequisites for learning Template Haskell?
19:26:23 <emptnr_> heart-renderingly so
19:26:26 <sbahra> int80_h, I wouldn't know.
19:26:30 <sbahra> int80_h, I'm a Haskell noob. :-)
19:26:30 <int80_h> being that it's advanced...
19:26:47 <sbahra> int80_h, I haven't learned it yet, either.
19:27:08 <ray> didn't seem too hard when i glanced over it yesterday, which means it's probably brain-melting
19:27:08 <int80_h> sounds like a question for haskell-cafe
19:27:20 <porges> int80_h, sbahra: you basically just build up haskell expressions using the data types and return then
19:27:35 <emptnr_> sounds like a question for #haskell-feedingtrough
19:27:36 <Gracenotes> interesting.. unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
19:27:51 <emptnr_> assembly-line force-feeding haskell
19:27:55 <porges> note also the magical unIO function :D
19:28:32 <sbahra> Gracenotes, I think I cared too much about them learning Haskell.
19:28:42 <sbahra> Gracenotes, instead of simply advocating it.
19:28:53 <int80_h> ah, you wanted results too badly.
19:29:07 <Gracenotes> You should have presented them with a lolcat instructing them to learn Haskell
19:29:19 <sbahra> I think that could've been it. Usually any tutorials I do result in very good feedback.
19:29:24 <SamB> Gracenotes: we haven't got one have we?
19:29:31 <sbahra> int80_h, how do you usually go about it?
19:29:33 <Gracenotes> in retrospect, it is indeed clear that was the mistake with your tutorial
19:29:33 <SamB> I still like simon cat and xmonad cat ...
19:29:39 <int80_h> sbhara: I don'
19:29:50 <int80_h> I don't know enough to run a haskell tutorial.
19:29:56 <sbahra> I'm sure you do.
19:30:27 <Gracenotes> right now I'm trying to write a tutorial about implementing Church encoding in plain Haskell... except it's gonna be online, and there's no danger of anyone walking out ;)
19:30:30 <int80_h> although I promise not to forget what it's like to be a no-nothing-newbie when I do.
19:30:31 <islon_s``> i think i just had an epiphany on programming in a functional way o.o
19:30:40 <ray> gracenotes: people walk out of your website all the time
19:30:43 <Gracenotes> including a basic, informal introduction to lambda calculus
19:30:49 <ray> you just don't know without fancy log analysis :)
19:30:56 <Gracenotes> ray: not in the middle of an HTTP request, I hope :P
19:31:07 <ray> sadly no those are automated :(
19:31:20 <int80_h> Gracenotes: there's this methodical lisp tutorial in Germany. The haskell equivilent would be nifty.
19:31:41 <Gracenotes> hm. what do you mean by "tutorial" in this context?
19:31:47 <MyCatVerbs> Would the Haskell equivalent work?
19:31:52 <int80_h> ah, I will give you a url.
19:31:53 <sbahra> Gracenotes, want to see a copy of my slides?
19:32:00 <int80_h> MyCatVerbs, the method would word just fine
19:32:18 <MyCatVerbs> I thought a couple of the traditional Church encodings didn't work in Haskell because they have infinite types.
19:32:38 <int80_h> http://apsymac33.uni-trier.de:8080/art/login-e.html
19:32:40 <Gracenotes> sbahra: sure, I'd love to
19:32:58 <sbahra> Gracenotes, http://carte.kerneled.org/haskell.pdf
19:32:58 <int80_h> they ask questions and track your progress per chapter, and overall.
19:33:04 <MyCatVerbs> e.g. coding up lists as Church pairs doesn't work at all, because lists of different lengths have differing types, so you need to do things a little differently.
19:33:21 <Gracenotes> MyCatVerbs: I'm kind of cheating :> it's rather informal. The church numeral n is just applying a function n times to an initial argument
19:33:34 <ddarius> MyCatVerbs: Church encodings are all doable in System F2.
19:33:52 <int80_h> also, stanford has a C Data structures tutorial. The haskell equivilent would probably stress different problems, but the form would work.
19:34:01 <chessguy> "last words of a c/c++ programmer: if (launchMissiles = true) { fireNukes(); }" (seen on stackoverflow.com)
19:34:19 <ddarius> chessguy: They'd never write that.
19:34:28 <chessguy> ddarius, dude, it's a joke
19:34:34 <chessguy> geez man
19:34:49 <SamB> yes, everyone knows you write your missle control software in Haskell tutorials
19:34:52 <sbahra> Gracenotes, any feedback would be appreciated.
19:34:52 <MyCatVerbs> ddarius: system F2? I've heard of System F (but I thought nobody implemented it?) but googling "System F2" doesn't get me any sane results within the first page.
19:34:53 <ddarius> But only insane people write if ( x == true ), you'd just write if(x)
19:34:59 * chessguy sighs
19:35:01 <Gracenotes> MyCatVerbs: it's just applying functions... informal, but enough to get the point across and get a working model. For instance, two s z =s (s z)
19:35:03 <sbahra> Gracenotes, eitherway, if I ever spend time on such a thing again it'll definitely be a completely new format.
19:36:53 <ddarius> MyCatVerbs: System F is implemented.  Heck, GHC uses a (variant) as an intermediate language.
19:37:02 <ddarius> MyCatVerbs: System F is just the polymorphic lambda calculus.
19:37:33 <int80_h> is this a typo, it's from RWh "asInt_either :: String -> Ei"
19:37:44 <int80_h> should n't it be s/Ei/Either ?
19:37:54 <SamB> shouldn't there be MORE than that ?
19:38:04 <sbahra> MORE?
19:38:07 <int80_h> that's just the type signature
19:38:15 <SamB> you know, like some arguments for Either would probably be good ?
19:38:26 <int80_h> it's a type signature!
19:38:37 <SamB> :k Either
19:38:38 <lambdabot> * -> * -> *
19:38:39 <sbahra> Still.
19:38:41 <sbahra> nod
19:38:43 <Gracenotes> sbahra: the first few pages before the "Introduction" are a little overwhelming :)
19:38:49 <Gracenotes> but I assumed you explained those
19:39:02 <sbahra> Gracenotes, yes.
19:39:03 <Nafai> What data structure would y'all recommend?  I have potentially hundreds of thousands (eventually) of 32 character strings (always 32 characters).  I want to be able to 1) quick insert into the list, 2) quickly search for the presence of a given string.  I don't care about deletion time.
19:39:07 <sbahra> Gracenotes, I wanted to show something "cool".
19:39:16 <ztirf_> omg - GeneralizedNewtypeDeriving is the bestest thing ever!
19:39:45 <ztirf_> it just saved me from hundreds of lines of boilerplate
19:40:08 <Gracenotes> sbahra: did you get the feeling that you weren't giving enough examples...?
19:40:15 <sclv> Nafai: stringtries ?
19:40:16 <chessguy> Nafai, by 1, do you mean insert into one of the 32-character strings, or insert into the list of strings?
19:40:29 <wli> ztirf: Remind me of what that is.
19:40:34 <MyCatVerbs> ddarius: oh, fun.
19:40:47 <Nafai> chessguy: Insert into list of strings
19:40:50 <Gracenotes> if I had never heard of Haskell, I'm not sure one example would be enough to 'get' a concept.
19:40:59 <ztirf_> wli:  newtype Luminosity = L_sun { l_sun :: Double } deriving (IArray UArray,Floating,Fractional,Num,Eq,Ord,Show)
19:41:04 <sbahra> Gracenotes, no. But I believe I should've had a section just about types.
19:41:16 <ztirf_> it's like dimensional but less fascist!
19:41:20 <Gracenotes> ah... you use various concepts throughout the talk
19:41:21 <SamB> sbahra: yes.
19:41:23 <SamB> you should.
19:41:24 <sbahra> Gracenotes, so start with simple types then work my way to functions, etc...
19:41:31 <SamB> I an remember they used to be pretty confusing
19:41:39 <SamB> s/an/can/
19:41:39 <sbahra> SamB, I just talked through them.
19:41:40 <Nafai> sclv: Is there something in hackage that implements them ? :)
19:41:41 * wli wonders if there are B+ tree libraries for Haskell, or more properly, what such should look like.
19:41:44 <sbahra> SamB, nod, it was a mistake.
19:41:53 <sclv> Nafai: yep -- I think its called string-trie :-)
19:41:59 <sbahra> I have some (very trivial) background in some logics, so I guess it seemed natural to me
19:42:21 <chessguy> Nafai, lookup and insert in Data.Map are both log n
19:42:56 <sclv> but tries for 32 character strings are always log2(32) !!!
19:42:59 <mriou> hi, question about types: I have something like
19:43:10 <mriou> data MyType = Foo | Bar | Baz
19:43:25 <Nafai> chessguy: Yeah, I was imagining a map would work, but didn't know if there was anything better in the Haskell world :)
19:43:29 <mriou> then many of my functions take or return MyType
19:43:35 <sclv> or, erm, actually, maybe just 32. but still.
19:43:51 <mriou> but a few of them I know will only ever take a Foo, so how can I enforce that?
19:44:14 <chessguy> mriou, you would need a separate type
19:44:16 <Gracenotes> sbahra: seems comprehensive... you do have some useful applications :) It is just a feature list, though... maybe people in the audience didn't see the reason for all the neat Haskell features you introduced?
19:44:19 <mriou> as with a data definition, Foo is actually not a type but just a constructor
19:44:20 <sbahra> You can't really "enforce" it at compiler level unless you have a separate type.
19:44:27 <sclv> so in any case if n > 2^32 then tries will probably be better.
19:44:32 <chessguy> data MyType = Foo Foo | Bar | Baz; data Foo = Meh
19:44:33 <sbahra> Gracenotes, exactly.
19:44:40 <Adamant> should ghc be parsing cabal's package.conf files?
19:44:42 <sclv> > 2^32
19:44:44 <lambdabot>   4294967296
19:44:46 <Gracenotes> i.e., why monads, typeclasses are a good idea
19:44:52 <sclv> erm, oh.
19:44:53 <chessguy> mriou, ^^
19:44:55 <sbahra> Gracenotes, crammed too much in because I automatically assumed the audience would be interested.
19:45:03 <sbahra> Gracenotes, mistook real life with #haskell. :-P
19:45:11 <mriou> chessguy: that's sort of what I had started but then it's kind of heavy
19:45:13 <sclv> my numbers are wrong here, but i'm too tired to figure out why.
19:45:13 <Gracenotes> :)
19:45:19 <mriou> you always need to wrap and unwrap
19:45:25 <Gracenotes> > logBase 2 32
19:45:26 <lambdabot>   5.0
19:45:42 <mriou> so I was wondering if there was another miracle solution :)
19:45:47 <sbahra> Gracenotes, I guess I could augment some slides in some months and give it another spin. :-P
19:46:14 <int80_h> ah, RWH hasn't introduced Either yet. But it's part of a chapter 4 exercise.
19:46:21 <int80_h> all is clear now
19:46:31 <Gracenotes> sbahra: maybe try to have as few features as possible? And then sneakily introduce them (not forcedly) as the talk continues?
19:46:32 <int80_h> I thought I had missed something, I tend to skim text and miss things
19:46:38 <Gracenotes> forcefully, even
19:46:42 <chessguy> int80_h, did you get your spltBy function written?
19:47:01 <int80_h> chessguy: almost done with chapter 4, then I'll take a shot at it
19:47:25 <Gracenotes> i.e., show a basic Haskell function with a main method. That does something, like, uh, basic grep (if the undergrads are of the Unix persuasion)
19:47:36 <lgas> is there an easy way to time the execution of a chunk of haskell code, e.g. for microbenchmarking?
19:47:54 <Gracenotes> well maybe that's a bad example. Something better suited to Haskell's very-good-at domain :)
19:48:02 <chessguy> lgas,  http://haskell.org/haskellwiki/Timing_computations
19:48:07 <Gracenotes> why laziness is a good idea
19:48:14 <lgas> thanks chessguy
19:48:27 <blackh> lgas: I have some code for this...
19:48:32 <chessguy> lgas, (you'll have to liftM it into IO if it's pure)
19:48:53 <lgas> yeah it's pure in the case I am looking at right now
19:48:53 <Gracenotes> everything can identify with math! That's why many languages with REPLs often have online tutorials start out with using the function as a calculator
19:48:58 <Gracenotes> *everyone
19:49:03 <wli> I've got a better "hard for Haskell" example: cutting off computations after some amount of time, or regulating the fraction of CPU consumed.
19:49:07 <mriou> chessguy: so there's no other solution than wrapping and unwrapping?
19:49:31 <chessguy> lgas, see also http://hackage.haskell.org/cgi-bin/hackage-scripts/package/timeit
19:49:40 <chessguy> mriou, what do you mean by wrapping and unwrapping?
19:49:43 <blackh> lgas: chessguy's is better than mine
19:49:50 <chessguy> mriou, (i think i know, but i'm not sure)
19:49:54 <pumpkin> wli: can't you do those in haskell in the same way you'd do in other languages?
19:49:54 <ozy`> hmm, there's an OS X trojan with an embedded lua interpreter
19:49:55 <lgas> ok
19:49:59 <pejo> Gracenotes, there's a risk that giving a too positive view of lazy evaluation will backfire, I think.
19:50:26 <Gracenotes> true. That's why you bring up examples where it's a good fit ;)
19:50:27 <pumpkin> wli: like spawn a separate thread, sleep, kill thread if not already dead?
19:50:45 <pumpkin> not a particularly good solution
19:50:46 <mriou> chessguy, so I'll always have to do Foo Foo and then pattern match on Foo Foo to extract the inner Foo
19:50:49 <wli> pumpkin: That's not how it's done in other languages.
19:50:51 <mriou> if that makes sense :)
19:51:15 <SamB> wli: how is it done then ?
19:51:38 <chessguy> mriou, yeah, i've been annoyed with that kind of thing lately. i'm not sure the right answer, but i'm wondering if making an instance of functor would help
19:52:31 <chessguy> mriou, bring the functions to the data, instead of the data to the functions :)
19:52:43 <int80_h> @src concat
19:52:43 <wli> SamB/pumpkin: They have a mutator thread go around modifying state as it goes, interrupt the mutator, and then pick apart the state it was mutating from some other context (whether via some continuation invoked from a signal handler or another standing thread).
19:52:43 <lambdabot> concat = foldr (++) []
19:53:04 <Nafai> Great.  Now I have to learn ByteStrings
19:53:05 <mriou> chessguy: I'll give it some thoughts, thanks :)
19:53:39 <chessguy> mriou, just don't quote me :)
19:53:52 <mriou> chessguy: I won't, promiss
19:54:15 <mriou> chessguy: I've also tried with a type class but it gets ugly
19:54:25 <chessguy> mriou, do you have some real code?
19:54:31 <mriou> pretty much all your functions end up being in the class...
19:54:36 <mriou> chessguy: sure
19:54:52 <wli> There are other, similar schemes, e.g. a mutator thread operates under some OS-enforced CPU bandwidth restriction while some high-priority thread is periodically woken in order to summarize the state.
19:55:08 <chessguy> mriou, i'd like to see if my idea has any merit or if i'm just spitting in the wind
19:55:52 <wli> Interruption is not a strict requirement; read-only access to state with a potential for inconsistency on account of in-progress updates being visible somehow is.
19:56:28 <mriou> chessguy: there's going to be quite a bit of code but I can give you pointers
19:56:30 <mriou> http://is.gd/gUHe
19:57:03 <mriou> chessguy: the type that annoys me is WyType
19:57:52 <wli> Sometimes the mutator will cooperate by only ever updating the read-accessed state in some sort of atomic fashion, e.g. swizzling individual pointers and using indirection in the data format to enable such.
19:57:59 <mriou> as you can see I've used the "wrapping" technique with WyLambda and WyPrimitive but pattern matching gets ugly
19:59:07 <wli> In other instances, the reader is insensitive to gibberish being around (e.g. there are no pointers and if you get gibberish data nothing serious happens).
19:59:18 <porges> mriou: view patterns could help a little
19:59:23 <chessguy> mriou, hm, yes, you can sort of encapsulate the wrapping idea with fmap, right?
19:59:28 <int80_h> @type concat
19:59:28 <lambdabot> forall a. [[a]] -> [a]
20:00:23 <mriou> chessguy: I'm not sure, so I guess you mean that I'd use a function that would "filtrate" all but a given type I'm interested in
20:00:24 <int80_h> @src concat
20:00:24 <lambdabot> concat = foldr (++) []
20:00:25 <mriou> correct?
20:02:24 <Axman6> yep
20:02:26 <int80_h> okay I don't understand what foldr is operating on , in the concat definition.
20:02:27 <chessguy> hm
20:02:29 <roconnor> is Denis Bueno here?
20:02:31 <Axman6> whoops
20:02:44 <ddarius> roconnor: Sometimes.
20:02:44 <int80_h> when I wrote concat, it looked almost the same except I wrote
20:02:54 <roconnor> under what handle?
20:02:55 <ddarius> preflex: seen dbueno
20:02:56 <preflex>  dbueno was last seen on #haskell 138 days, 2 hours, 37 minutes and 45 seconds ago, saying: @type concatMap . (intersperse "\\" . return)
20:03:02 <roconnor> oh
20:03:03 <int80_h> concat [[x]] = foldr (++) [x]
20:03:09 <roconnor> that was a long time ago
20:03:13 <int80_h> but that didn't work
20:03:38 <chessguy> mriou, i think i'm probably just blowing smoke. i don't really know what i mean
20:03:43 <int80_h> but there, I could see foldr folding ++ on [x]
20:03:48 <ddarius> roconnor: I'm pretty sure I've seen him more recently than that, but I haven't seen him for like a month or so (or haven't noticed)
20:04:04 <int80_h> I don't see how foldr gets any input
20:04:13 <porges> concat = foldr (++) [] is the same as concat x = foldr (++) [] x
20:04:15 <int80_h> in this case
20:04:25 <int80_h> porges , oooh!
20:04:37 <int80_h> okay that makes much more sense
20:05:04 <porges> you don't have to explicitly put the variable there
20:05:09 <blackdog> i'm having a bit of a problem with the FFI. If I have a list of ByteStrings, and I want to create a normal array of null-terminated C strings that will live in the C heap, how would i go about it? withStorableArray seems to get me part of the way there, but I can't work out how to copy a string over to the C side...
20:05:12 <chessguy> mriou, that is an....interesting Num instance
20:05:36 <porges> say as you can say "plusOne x = x + 1" or "plusOne = (+1)"
20:05:39 <porges> *same
20:06:02 <chessguy> mriou, what are the functions that are only ever supposed to take one constructor of WyType?
20:07:21 <mriou> chessguy: matchMacro or runMacro
20:07:43 <blackdog> (i've been using useAsCString but getting odd results - i suspect they're getting garbage collected)
20:07:43 <mriou> the WyType there can only be a WyMacro
20:08:27 <mriou> there are quite a few others
20:10:02 <mriou> are view patterns a feature of GHC only?
20:10:31 <ddarius> mriou: Yes.
20:10:45 <lowki> what are acceptable licences for cabal?
20:11:05 <mriou> ddarius: that's neat, thanks
20:11:07 <chessguy> @pl \x y -> r $ x ++ y
20:11:08 <lambdabot> (r .) . (++)
20:11:24 <lowki> i tried BSD and BSDL but it only seems to accept GPL
20:11:31 <ddarius> lowki: BSD3
20:11:46 <lowki> what if i have a modified version of BSD?
20:12:00 <ray> BSD2 is nice
20:12:00 <ddarius> lowki: Then it presumably is Other.
20:12:05 <lowki> other kk
20:13:14 <chessguy> @pl \n -> f . g n
20:13:14 <lambdabot> (f .) . g
20:13:40 <ddarius> > on (f :: Expr -> Expr) (g :: Expr -> Expr -> Expr) x :: Expr
20:13:41 <lambdabot>   Couldn't match expected type `Expr -> c'
20:13:54 <ddarius> > on (f :: Expr -> Expr -> Expr) (g :: Expr -> Expr) x :: Expr
20:13:55 <lambdabot>   Couldn't match expected type `Expr'
20:13:57 <ddarius> :t on
20:13:58 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
20:14:11 <ddarius> > on (f :: Expr -> Expr -> Expr) (g :: Expr -> Expr) x y :: Expr
20:14:12 <lambdabot>   f (g x) (g y)
20:14:48 <Axman6> > f `on` g x
20:14:49 <lambdabot>       Overlapping instances for Show (a -> a -> c)
20:14:49 <lambdabot>        arising from a use ...
20:14:57 <Axman6> > f `on` g x :: Expr
20:14:58 <lambdabot>   Couldn't match expected type `Expr'
20:15:03 <Axman6> :\
20:16:16 <ddarius> @pl curry (r . uncurry (++))
20:16:16 <lambdabot> curry (r . uncurry (++))
20:16:26 <ddarius> @pl \x -> curry (r . uncurry (++)) x
20:16:26 <lambdabot> curry (r . uncurry (++))
20:16:35 <ddarius> @pl map f . map g
20:16:36 <lambdabot> map (f . g)
20:17:44 <gwern> @seen dons
20:17:45 <lambdabot> dons is in #arch-haskell, #haskell, #xmonad, #darcs, #concatenative and #ghc. I last heard dons speak 2h 21m 2s ago.
20:17:45 <chessguy> mriou, i'm out of ideas, sorry
20:17:55 <porges> even if you write an alternative prelude you can't get rid of "fail" in Monad >.<
20:18:49 <gwern> @tell dons you were interested in darcs support for ohloh? look at https://www.ohloh.net/announcements/mercurial_support - their DVCS parsing library is now Free. perhaps recruit some ruby hackers to add darcs support?
20:18:49 <lambdabot> Consider it noted.
20:18:54 <Nafai> I'm trying to make a type alias for a Data.Map, I know this is syntactically correct, but:
20:18:58 <Nafai> type IdCountMap = Map.Map String Integer
20:19:06 <Nafai> I'm using that type later and the compiler seems confused
20:19:13 <wli> porges: There are numeric hierarchy issues that can't be dealt by turning off the implicit Prelude, either.
20:19:26 <mriou> chessguy: no worries, thanks for looking :)
20:19:42 <Nafai> oh n/m
20:19:44 <Nafai> I was confused
20:19:46 <porges> wli: like fromInteger?
20:19:51 <Nafai> Had parameters in the wrong order :)
20:20:00 <wli> porges: That's the biggest one.
20:20:36 <wli> porges: s/fromInteger/fromNatural/ is not obvious how to do. I've gone digging through the ghc source and failed.
20:23:30 <lowki> ddarius: Other is not accepted
20:23:50 <Nafai> Does Data.Binary already have support for serializing simple Data.Map instances containing just Strings and Integers? :)
20:24:30 <pumpkin> it can definitely serialize a list of pairs :P
20:25:33 <dolio> Map is in the list of instances.
20:26:48 <sjanssen> Nafai: yep
20:27:04 <sjanssen> Nafai: for full list of instances: http://hackage.haskell.org/packages/archive/binary/0.4.4/doc/html/Data-Binary.html#t%3ABinary
20:27:19 <Nafai> That's what I get for skimming :)
20:27:26 <Nafai> I didn't see it at the top of the instances :)
20:32:10 <Nafai> Dang it.  Now I'm wanting to use impure code in the middle of pure code
20:32:23 <pumpkin> unsafePerformIO!
20:32:23 <pumpkin> ;)
20:32:58 <ddarius> lowki: http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution-License.html
20:34:04 <Gracenotes> hello Impure Coders Anonymous, my name is Gracenotes, and sometimes I temporarily add "unsafePerformIO (print x) `seq`" for debugging
20:34:20 <dolio> You should use trace, instead.
20:34:45 <Gracenotes> what is this trace you speak of?
20:34:52 <dolio> @hoogle Debug.Trace
20:34:52 <lambdabot> module Debug.Trace
20:34:53 <lambdabot> Debug.Trace trace :: String -> a -> a
20:34:53 <lambdabot> package traced
20:35:06 <Gracenotes> mm, I see
20:35:37 <Axman6> > show (1+1)
20:35:38 <lambdabot>   "2"
20:35:55 <Gracenotes> usually the uPIO is just for working out temporary kinks, but if there's a more elegant (and not time-intensive) solution, I'll use it
20:36:01 <Axman6> > show (cos pi)
20:36:03 <lambdabot>   "-1.0"
20:36:20 <rwbarton> @quote trace
20:36:21 <lambdabot> Peaker says: It depends how much of the door you want to model. In a ray tracer, it would be quite different than in an alarm system
20:36:23 <rwbarton> @quote trace
20:36:23 <lambdabot> Peaker says: It depends how much of the door you want to model. In a ray tracer, it would be quite different than in an alarm system
20:36:25 <dolio> Well, I mean, 'import Debug.Trace' can't be longer than what you're importing to get unsafePerformIO.
20:36:31 <dolio> And trace is definitely shorter.
20:36:37 <ray> @quote ray
20:36:38 <lambdabot> ghc says: DsExpr.dsExpr: Infinite parallel array!
20:36:47 <rwbarton> @quote trace.function
20:36:48 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
20:36:49 <Gracenotes> hm.
20:36:50 <ray> good to know!
20:37:00 <Gracenotes> true
20:37:50 <Nafai> So I want to add functionality to deDupItems and deDupItems' (from here: http://github.com/Nafai77/recent-feeds/blob/8f4454c460a3a66ef46a56bc75a16a6900de9e89/recent-feed.hs) to load and save the seenMap from the disk
20:38:09 <rwbarton> Wait, what?  A "refreshing desert"?
20:38:13 <Nafai> I was worried about changing those to use IO
20:38:36 <Nafai> But, then again, if the results would change depending on what's in the map, they should properly be IO, right?
20:40:08 <Nafai> Also, regardless, is there a better way of implementing what I did there?
20:40:22 <int80_h> @type takeWhile
20:40:23 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
20:45:50 <lowki> :q
20:46:24 * wli wishes for something that would do f xs = zip (inits xs) (tails xs) in some more efficient way than literally that.
20:47:19 <ddarius> wli: That should be reasonably efficient.
20:47:45 <ddarius> Certainly both inits and tails are lazy and so you will get streaming behavior.
20:48:01 * wli mostly wants more sharing.
20:48:02 <dolio> It's going to be hard to do much better unless you don't mind the inits part being reversed.
20:48:48 <wli> It's not so much asymptotic efficiency as sharing.
20:48:50 <ddarius> wli: There's already a lot of sharing there.
20:49:07 <ddarius> @src inits
20:49:10 <lambdabot> inits []     =  [[]]
20:49:10 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
20:49:58 <ddarius> In fact, short of sharing == values using a table of some sort, I believe it has -maximal- sharing.
20:50:49 <wli> Not sure.
20:50:52 <porges> We're sorry...... but your query looks similar to automated requests from a computer virus or spyware application.
20:51:12 <porges> rage
20:51:22 <Axman6> @hoogle iterateWhile
20:51:22 <lambdabot> No results found
20:51:25 <ksf> I'm confused.
20:51:28 <sjanssen> porges: did you just fail a Turing test?
20:51:29 <Axman6> hmm, seems like a useful function
20:51:37 <ksf> Is a downcast a cast to a subtype or a supertype?
20:51:41 <p_l> sjanssen: That's not hard nowadays
20:51:42 <porges> sjanssen: I googled "stream fusion"
20:51:45 <Axman6> inits = iterateWhile (not.null) init
20:51:46 <ddarius> Axman6: Use iterate and takeWhile or until.
20:51:47 <sjanssen> ksf: subtype
20:51:55 <ddarius> Axman6: That would be a horrible definition.
20:52:05 <Axman6> why?
20:52:09 * ksf fixes his compass
20:52:10 <ddarius> Axman6: The analogous would be fine for tails.
20:52:23 <ddarius> Axman6: Your version is O(n^2) and doesn't share anything.
20:52:32 <Axman6> fair enough
20:53:23 <sjanssen> ddarius: but inits can't share anything
20:54:03 <ddarius> > inits [1,2,3,4]
20:54:04 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4]]
20:54:22 <ddarius> Ah, you're right.
20:55:35 * porges requests cabal upgrade ghc
20:55:41 <the_unmaker> hey guys n gals, I saw yesterday that ghc can be told to use 16 cpu-s on a box with a command line flag
20:55:47 <dolio> > let f Nothing = Nothing ; f (Just p@(l,[])) = Just (p, Nothing) ; f (Just p@(l,x:xs)) = Just (p, Just (x:l,xs)) in unfoldr f (Just ([],[1..10]))
20:55:49 <dons> right
20:55:49 <lambdabot>   [([],[1,2,3,4,5,6,7,8,9,10]),([1],[2,3,4,5,6,7,8,9,10]),([2,1],[3,4,5,6,7,8...
20:55:54 <dons> the_unmaker: +RTS -N16
20:56:00 <the_unmaker> it seems java does nto have the same ability, or its hard to get a good idea either way
20:56:02 <ddarius> Presumably you can tell it to use 1000 CPUs.
20:56:07 <dons> right
20:56:15 * dons has used +RTS -N32
20:56:17 <sjanssen> the_unmaker: but only if your application actually uses 16 threads (or 16 par sparks)
20:56:18 <the_unmaker> so is haskell on of the only langs to offer that?
20:56:22 <dons> yes.
20:56:35 <dons> 3. profit
20:56:42 <the_unmaker> would a web app using mysql be inherently non multi threaded?
20:56:44 <sjanssen> the_unmaker: lots of languages can do that, but they don't generally do it as well
20:56:47 <ksf> :t void
20:56:48 <lambdabot> Not in scope: `void'
20:56:54 <ksf> :t Foreign.void
20:56:55 <lambdabot> forall a. IO a -> IO ()
20:57:05 <sjanssen> eg. C and pthreads can saturate 16 CPUs (in fact, GHC's threading is built on the same primitives)
20:57:15 <porges> note to self: +RTS -N100 is bad
20:57:23 <dons> unless you have 100 coress
20:57:33 <porges> that day is not yet here ;D
20:57:36 <the_unmaker> you see I have  a java tomcat app and the thing blows up 1 cpu, but 7 sit 99% idle
20:57:40 <dons> it is in some labs
20:57:44 <the_unmaker> I am working out with support howto avoid that
20:57:51 <pumpkin> dons: will it be supported to have programs be able to specify -N within the program?
20:57:52 <the_unmaker> haskell apps must be FAST
20:57:54 <dons> use ghc to coordinate N java sessions?
20:58:04 <dons> pumpkin: i think that could actually be done today
20:58:14 <wli> > let splits :: [t] -> [([t],[t])] ; splits [] = [([],[])] ; splits xss@(x:xs) = ([], xss) : [(x : ys, zs) | (ys, zs) <- splits xs] in splits [(1::Int)..3]
20:58:16 <sjanssen> the_unmaker: tomcat is probably inherently serial, rather than concurrent
20:58:16 <lambdabot>   [([],[1,2,3]),([1],[2,3]),([1,2],[3]),([1,2,3],[])]
20:58:27 <ksf> that's a useless function.
20:59:00 <sjanssen> pumpkin: you can control RTS options at link time
20:59:01 <hiredman> the_unmaker: you would mostl iekly do better to run multiple tomcat instances and load balance across them
20:59:02 <pumpkin> dons: is it possible to detect how many CPUs/cores within the program?
20:59:16 <sjanssen> pumpkin: GHC.Conc.numCapabilities
20:59:22 <pumpkin> ah
20:59:23 * wli is not sure but thinks that is somehow "better" than splits xs = zip (inits xs) (tails xs)
20:59:27 <dons> numCapabilties, but that is just    the value of +RTS -N
20:59:33 <dons> there's no lib for discovery of the cores
20:59:48 <sjanssen> dons: yeah, we need that
21:00:00 <int80_h> wait, isn't there an interface to sysctl?
21:00:10 <dons> on windows?
21:00:15 <dons> on irix?
21:00:15 <int80_h> oops, nebbermind
21:00:20 <bos> i've written such a library, actually.
21:00:25 <sjanssen> as a link option to GHC, so we can just "ghc --make myprogram -autocores"
21:00:30 <bos> just haven't uploaded it to haddock yet.
21:00:41 <ddarius> wli: It fuses zip with inits and tails, but is otherwise identical.
21:00:45 <wli> > let splits :: [t] -> [([t],[t])] ; splits [] = [([],[])] ; splits xss@(x:xs) = ([], xss) : map (first (x:)) (splits xs) in splits [(1::Int)..3]
21:00:47 <lambdabot>   [([],[1,2,3]),([1],[2,3]),([1,2],[3]),([1,2,3],[])]
21:01:22 <ddarius> wli: The stream fusion framework should be able to do such fusion automatically.
21:01:47 <ddarius> wli: I don't know if GHC has any rewrite rules for zips that would do such fusion.
21:01:57 <dons> bos: numCapabilities discovery?
21:02:01 <wli> ddarius: Not sure, but I was hoping that there was a copying of list elements between the inits and tails portions that splits avoided.
21:02:11 <p_l> there is POSIX interface reporting the number of cores as well as how many of them are online
21:02:14 <p_l> _SC_NPROCESSORS_CONF in sysconfig
21:02:15 <sjanssen> ddarius: GHC can fuse either argument to zip, but not both
21:02:23 <dons> that's posix?
21:02:44 <p_l> dons: yup
21:02:45 <bos> dons: automatic setting of numCapabilities on both unix and windows
21:03:06 <the_unmaker> you know I thought about running multiple tomcats, but this is a proprietary app, and I didn't write it, and I am not sure how the bugger would react,.....although it would be interesting as hell
21:03:07 <Nafai> Dang it.
21:03:11 <dons> oh yes, i recall you working on that.
21:03:15 <Nafai> It's time for bed and I'm having fun coding Haskell :/
21:03:31 <the_unmaker> dream without side effects! haskell!!
21:03:40 <wli> p_l: Available via C FFI calls as well as via some program.
21:03:44 <Nafai> the_unmaker: hehe
21:03:46 <the_unmaker> [woa I should patent that catchy line]
21:04:05 <Nafai> That should go in this week's haskell news
21:04:08 <ddarius> wli: Tails doesn't actually copy any of the conses of the original list, tails essentially just make a list of pointers into the original list.  inits inherently must copy the conses.  Your splits avoids creating some conses and then immediately consuming them, but that's it.
21:04:27 <p_l> wli: It's quite simple on POSIX systems, it's one function call :)
21:05:01 <wli> ddarius: Hmm. That doesn't sound promising.
21:05:04 <sjanssen> so what's going on?  We're trying to find the best function to produce all splitAts of a list?
21:05:16 <porges> import Data.List.Stream
21:06:26 <the_unmaker> so do you guys spend like 0 time worrying f an app will run fast on a 16 cpu production server?
21:06:34 <wli> sjanssen: Not very hard. I was merely hoping for something that looked slightly more efficient than splits xs = zip (inits xs) (tails xs)
21:06:54 <sjanssen> splits xs = map (flip splitAt xs) $ zipWith const [0 ..] xs -- should compete with the fastest
21:07:09 <ddarius> the_unmaker: I don't have a 16-core production server nor write programs for one, so I do indeed spend 0 time worrying about it.
21:07:36 <int80_h> I can say I spend less than 0 time worrying about it. I'm running a deficit
21:07:52 <sjanssen> the_unmaker: I think you might have some misconceptions about Haskell.  Haskell won't automatically scale to 16 cores, your application has to be written to take advantage of concurrency
21:08:24 <int80_h> right now I'm worrying how I can find some functions with the type signature (a -> a -> Bool)
21:08:40 <ozy`> the_unmaker: hey, this is haskell, not erlang
21:08:41 <pumpkin> @hoogle a -> a -> Bool
21:08:42 <lambdabot> Distribution.Simple.Utils equating :: Eq a => (b -> a) -> b -> b -> Bool
21:08:42 <lambdabot> Prelude (<) :: Ord a => a -> a -> Bool
21:08:42 <lambdabot> Prelude (<=) :: Ord a => a -> a -> Bool
21:09:07 <pumpkin> @hoogle+
21:09:08 <lambdabot> Prelude (>) :: Ord a => a -> a -> Bool
21:09:08 <lambdabot> Prelude (>=) :: Ord a => a -> a -> Bool
21:09:08 <lambdabot> Data.Ord (<) :: Ord a => a -> a -> Bool
21:09:15 <sjanssen> ozy`: you still have to think about scalability in Erlang too
21:09:23 <int80_h> pumpkin: thanks :)
21:09:25 <BMeph> That's sick - I got to import a Cabal module to get equating? Bah. :|
21:09:45 <ddarius> @hoogle equating
21:09:46 <lambdabot> Distribution.Simple.Utils equating :: Eq a => (b -> a) -> b -> b -> Bool
21:10:13 <ddarius> @hoogle+
21:10:22 <pumpkin> BMeph: what does equating do?
21:10:30 <pumpkin> oh I see
21:10:51 <pumpkin> == `on` f ?
21:11:11 <sjanssen> int80_h: there are 5 functions with that type (disregarding seq)
21:11:18 <pumpkin> :t (==) `on` f
21:11:20 <lambdabot>     Ambiguous type variable `b' in the constraints:
21:11:20 <lambdabot>       `SimpleReflect.FromExpr b'
21:11:20 <lambdabot>         arising from a use of `f' at <interactive>:1:10
21:11:28 <pumpkin> :t (==) `on` (\x -> x + 1)
21:11:29 <lambdabot> forall a. (Num a) => a -> a -> Bool
21:11:37 <ddarius> @tell ndm http://www.haskell.org/hoogle/?hoogle=a+-%3E+a+-%3E+Bool  The ordering here seems pretty poor
21:11:38 <lambdabot> Consider it noted.
21:11:46 <pumpkin> so equating is just on (==) ?
21:12:11 <the_unmaker> 'this ain't erlang'
21:13:15 <int80_h> sjanssen: thanks, pumpkin showed me, with hoogle
21:13:29 <int80_h> I just wanted to verify that I knew what groupBy does
21:13:50 <int80_h> now I need to write groupBy with a fold
21:13:53 <sjanssen> int80_h: no, pumpking showed you functions of type Ord a => a -> a -> Bool
21:14:02 <sjanssen> there are a lot more of those than "a -> a -> Bool" :)
21:14:11 <ddarius> sjanssen: We're ignoring using seq but allowing it to distinguish between our functions?
21:14:11 <int80_h> oooh
21:14:18 <sjanssen> ddarius: yep
21:14:28 <pumpkin> sjanssen: why thank you for the suffix :D
21:14:35 * pumpkin is the king of pumps
21:14:53 <int80_h> is the pimpking
21:14:59 <the_unmaker> what kinds of apps are you gents working on?
21:15:06 <int80_h> I mean he is
21:15:14 <pumpkin> the_unmaker: number crunching for me
21:15:29 <roconnor> colour lib
21:15:53 <int80_h> the_unmaker : working through Real World Haskell for me. Getting prepped to write a Haskell binding for libnova
21:16:10 <int80_h> that's step one of many, for my final application.
21:16:22 <lgas> I have what is effectively a matrix, represented as a list of rows where each row is a list of the values in each column... e.g. [[1,2], [3,4]] and I need to transpose the rows to columns, (e.g. to get [[1,3], [2,4]])... I imagine this is trivial in haskell but I am new to it and no clean solution is occuring to me... I'm picturing some combination of zip/map/head/tails but I feel like I must be over complicating it.  Any suggestions?
21:16:28 <ozy`> the_unmaker: trying to hack together a GLTerminal clone. it's slow going...
21:16:33 <wli> pumpkin: What kind of number crunching?
21:16:42 <roconnor> > transpose [[1,2], [3,4]]
21:16:44 <lambdabot>   [[1,3],[2,4]]
21:16:49 <lgas> hahah
21:16:55 <lgas> well at least I was right that it was simple :)
21:16:57 <int80_h> @transpose
21:16:58 <lambdabot> Unknown command, try @list
21:17:02 <int80_h> @src transpose
21:17:02 <lambdabot> transpose []             = []
21:17:02 <lambdabot> transpose ([]   : xss)   = transpose xss
21:17:02 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
21:17:07 <pumpkin> wli: machine learning stuff, with some basic feature computation with sliding entropies and the like
21:17:07 <roconnor> @hoogle transpose
21:17:07 <lambdabot> Data.ByteString transpose :: [ByteString] -> [ByteString]
21:17:07 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
21:17:07 <lambdabot> Data.ByteString.Char8 transpose :: [ByteString] -> [ByteString]
21:18:10 <int80_h> what the hell is xss, in the context of transpose?
21:18:11 <the_unmaker> what is libnova? ozy terminal liek mrxvt or something
21:18:21 <lgas> the plural of xs
21:18:27 <lgas> since it's a list of lists
21:18:33 <int80_h> (x:xs) : xss ... oh!
21:18:48 <int80_h> I learn at least 5 things about haskell each day
21:19:16 <int80_h> the_unmaker: it's a C library for astrophysics
21:19:21 <lgas> I'm so new that it's like 5 a minute
21:19:38 <lgas> it's pretty awesome
21:19:44 <int80_h> it does the calculations you need to project maps on the celestial sphere
21:20:17 <int80_h> when I'm done, I'll have an online map using happs
21:20:32 <int80_h> buy, one step at a time, haskell binding for the C api.
21:20:36 <int80_h> but
21:20:52 <int80_h> at first, I was going to re-write libnova
21:21:08 <int80_h> but I don't think that's the Haskell Way (tm)
21:21:59 <int80_h> I mean, if I have to I will, or when I'm satisfied with my web app, I might go back and re-write it in haskell
21:23:30 <cads> ozy`: that blog post is interesting, though he writes from the perspective of an outsider to each of those languages, like he's studied them all but not done much with any of them, though I may be projecting :). He also makes the grave error of not covering LOLCode, which is The up and coming language of our times.
21:25:19 <cads> I've heard of haskell described as an exercise in a kinky kind of strict BDSM which some might find pleasurable. And the blog author describes it as a "Functional Straighjacket" language
21:25:41 <sjanssen> cads: do you have a link to the blog?
21:26:06 <the_unmaker> I want a webapp that is 1 fast 2 easy to move from box to box 3 handles 1000 users
21:26:14 <cads> and I wonder if those people have actually learned the languages
21:26:20 <ozy`> cads: I pictured him sitting in a brightly lit room, eating popcorn one piece at a time, staring past acres and acres of programming language documentation and comprehending none of it
21:26:23 <cads> sjanssen: nothing super illuminating
21:26:39 <sjanssen> cads: I'm still curious :)
21:26:46 <ozy`> sjanssen: http://web.mac.com/jimbokun/iWeb/Site/Blog/AB35C167-7755-4113-938C-968F65256D76.html
21:26:51 <cads> http://tinyurl.com/bxf9mv
21:26:52 <cads> aw
21:27:30 <dolio> Sounds like a Lisp person.
21:28:18 <int80_h> cads: in writing, we ask critics "where were you when the page was blank?". There has to be a programming language equivilent. Point is, much easier to critizise than it is to build something
21:29:08 <cads> well he's informative enough, I suppose
21:29:24 <cads> as a beginning I still identify with the feeling that haskell is a bit of a straightjacket, as he says
21:30:00 <cads> beginner, rather... but at the same time I see much more, and he reduces it to that label
21:30:30 <pumpkin> it's a good straight jacket
21:30:37 <sjanssen> I think people focus on the purity of Haskell too much
21:30:41 <pumpkin> like all straight jackets, they protect you against yourself! ;)
21:31:00 <cads> sometimes you just wanna see your own blood though
21:31:07 <dolio> Actually reading it, it doesn't really sound like a lisp person.
21:31:14 <dolio> I was thinking the "BSDM" would be the type system. :)
21:31:26 <dolio> BDSM, even.
21:31:32 <cads> hehe, it was another author that wrote that
21:31:40 <cads> gave me a chuckle
21:31:48 <Axman6> pumpkin: heh, well put
21:32:25 <cads> have you guys read this little anecdote: http://www.xent.com/pipermail/fork/Week-of-Mon-20070219/044101.html ?
21:33:06 <cads> reminds me of a girl I know
21:33:26 <BMeph> cads, sjanssen: Sounds like Philippa. :)
21:33:46 <cads> hah, I'll tell you said that
21:34:07 <cads> ... wow, just the mention of her and I can hardly form english..
21:35:50 <shapr> @users
21:35:50 <lambdabot> Maximum users seen in #haskell: 646, currently: 573 (88.7%), active: 14 (2.4%)
21:36:40 <cads> anyways, I wonder where the author places concatenative languages, array processing languages, stream processing languages, logic languages, and the proof systems
21:37:26 <rwbarton> I suspect most people who should be using one of those languages already know about them
21:37:34 <Axman6> cads: seems to me like they'd say something like "lol, good one, as if someone would make something as stupid as that"
21:38:09 * cads feels kinship with the authors' desire to know and explain about languages, but at the same time regrets the analysis paralysis that not just diving in gives.
21:41:51 <int80_h> @when sjanssen
21:41:52 <lambdabot> Maybe you meant: seen what where wn
21:41:58 <int80_h> @seen sjanssen
21:41:58 <lambdabot> sjanssen is in #haskell-overflow, #ghc, #haskell-blah, #xmonad and #haskell. I last heard sjanssen speak 26s ago.
21:42:08 <int80_h> sjanssen: you around?
21:42:16 <sjanssen> int80_h: yep
21:42:42 <BMeph> @go haskellondage
21:42:44 <lambdabot> No Result Found.
21:42:45 <int80_h> sjanssen: you said there were 5 functions with the type signature I mentioned earlier. what are they?
21:42:51 <cads> successful programmers I've known got their hands dirty in their field rather than trying to learn all about every exotic thing being done... I'm able to talk to them about stuff they do and cool experimental ideas that intrigue them, but i have little to show for myself in actual creations
21:42:57 <BMeph> @go haskell bondage
21:43:00 <lambdabot> http://syntaxfree.wordpress.com/2007/01/08/haskell-bondage-and-discipline-and-separation-of-concerns-programming/
21:43:00 <lambdabot> Title: Haskell, bondage-and-discipline and separation-of-concerns programming « Data.S ...
21:43:11 <sjanssen> int80_h: undefined, const undefined, const (const undefined), const (const False), const (const True)
21:43:23 <sjanssen> int80_h: but that was really just a smart aleck answer :)
21:43:31 <int80_h> yeah I figured ;)
21:44:03 <int80_h> (a -> a -> Bool)
21:44:04 <pumpkin> mmm bondage
21:44:07 <int80_h> that's the signature
21:44:20 <BMeph> :t (/=)
21:44:21 <lambdabot> forall a. (Eq a) => a -> a -> Bool
21:44:22 <int80_h> I'm trying to implement groupBy, so ity will help
21:44:22 <sjanssen> int80_h: there aren't really any useful functions with tha ttype
21:44:34 <sjanssen> ahh, it's passed as an argument?
21:44:38 <int80_h> yup
21:44:49 <sjanssen> then it could be anything -- caller determines the real type of 'a'
21:45:04 <int80_h> I've having trouble wrapping my head around what this code is going to look like, except fold plays a central role
21:45:25 <int80_h> ah, okay
21:46:12 <cads> a -> a -> bool for a given a is the type of binary relations on a set, right?
21:46:39 <BMeph> :t on (==) length
21:46:41 <lambdabot> forall a. [a] -> [a] -> Bool
21:46:53 <ddarius> cads: The analogous thing in set theory is (isomorphic to that) yes.
21:46:55 <pumpkin> BMeph: so is that equating?
21:47:21 <BMeph> pumpkin: Yep. The on (==) part, anyway.
21:47:27 <pumpkin> yeah
21:47:45 <BMeph> pumpkin: Just like comparing is 'on compare'. :)
21:47:55 <pumpkin> yeah, makes sense
21:48:03 <cads> ddarius: I like how concisely we may express the nature of a mapping with the arrow syntax, and wonder why we don't really see the syntax in set theory
21:48:04 <pumpkin> BMeph: haven't seen any more tweets from you!
21:48:09 <pumpkin>  you need to get that bird going
21:48:42 <cads> I asked a question involving functions described by types in the math channel and the folk there were polite in saying "we don't realy use types, that's more of a cs thing, dear"
21:48:48 <ddarius> cads: That almost exact notation -is- commonly used in set theory.
21:49:47 <BMeph> pumpkin: So far, I've done...one? In a half-year. Be glad you saw one from me. I'm too wordy for tweets, really. I need something on the other side of blogging from Twitter. Like maybe a book. ;p
21:49:56 <rwbarton> R a relation on X means R : X x X -> {T, F}
21:50:21 <pumpkin> BMeph: condense condense condense! only write the first letter of each word you wanted to write ;)
21:51:04 <BMeph> pumpkin: Bah. I'd rather blog. And I don't blog, either. ;p
21:51:11 <pumpkin> you should :P
21:51:19 <wli> cads: There is mathematical culture involved from certain angles. Certain sub-fields of logic and category theory concern themselves with such. It's probably not going to find anyone in #math to help, though.
21:53:11 <cads> F :: A -> B -> C is equivalent to the map notation F : (A x B) - > C except the former is curried form, right?
21:53:33 <ddarius> cads: Yes.  They are isomorphic.
21:53:35 <cads> they were having none of it :)
21:53:55 <mmorrow> well it depends what "x" is
21:54:12 <rwbarton> Category theorists would usually write f : A -> C^B and f : A x B -> C
21:54:36 <rwbarton> just saying that there is a small gap that needs to be bridged
21:54:48 * cads must grok exponentials soon.
21:55:00 <ddarius> rwbarton: It's not uncommon to see notation like f : A -> [B => C]
21:55:04 <cads> those have been driving me crazy
21:55:09 <ddarius> cads: Do you understand higher order functions?
21:55:23 <cads> yes
21:55:30 <ddarius> cads: Then you understand exponents.
21:55:51 <pumpkin> is there much category theory in #math?
21:55:52 <rwbarton> yes, there are certainly other notations for internal mapping objects, but just "B -> C" is not one of them
21:56:06 <cads> pumpkin: none
21:56:08 <wli> pumpkin: Not that I'm aware of.
21:56:21 <ddarius> rwbarton: I think most categorists would understand, but dislike, that.
21:56:38 <rwbarton> yeah, probably.
21:56:40 <pumpkin> most of what I saw in there was "arg i have 2 find out what x is in x^2 + 2x - 5 = 7 before tmrw can u halp me?
21:57:03 <ddarius> #not-math is better
21:57:11 <rwbarton> the denizens of #math are likely to let you know if they dislike your notation.
21:57:18 <ddarius> But still, I left both channels after being there for a few monts.
21:58:29 <cognominal> where is the source repository for prelude?
21:58:36 * ksf wants to call variadic c functions
21:58:51 <cads> ddarius: I think it's got to be like monads where I had already used something similar before learning about them. It took a while before I could understand the overall pattern and the motivation to call them something. Similarly with exponentials the most niggling question is what motivates that notation, and what concrete thing in my mind does that notation correspond to.
21:59:13 <ddarius> cads: C^B is just (B -> C)
21:59:40 <ddarius> cads:  The internal language of a cartesian closed category is the simply typed lambda calculus with products.
21:59:42 <cads> C^B is a function from elements of B to elements of C?
21:59:48 <mmorrow> ksf: just generate an ffi import decl for each arity you wan to call a function at
21:59:53 <ddarius> cads: In Set, yes.
21:59:57 <pumpkin> what's the motivation? the number of functions from B->C given |C| and |B|?
22:00:13 <cads> oo, right, we have different categories
22:00:19 <mmorrow> (i meant s/generate/write/, but generate would be easier)
22:00:22 <roconnor> C^(B*A) == (C^B)^A
22:00:23 <ddarius> pumpkin: All the usual "arithmetic" laws you expect hold.
22:00:25 <pumpkin> assuming set, that is
22:00:34 <roconnor> C^(B+A) == (C^B)*(C^A)
22:00:46 <ddarius> pumpkin: They actually hold in any symetric monoidally closed category.
22:00:48 <cads> is + the union operation?
22:00:49 <pumpkin> that makes sense
22:01:03 <pumpkin> ddarius: ah, I was just talking about simple combinatorics, which that reminded me of
22:01:07 <ddarius> pumpkin: And indeed, the original use was motivated by relations between cardinalities.
22:01:14 <pumpkin> but that's neat
22:01:20 <roconnor> @djinn ((Either a b) -> c) -> (b -> c, a -> c)
22:01:21 <lambdabot> f a = (\ b -> a (Right b), \ c -> a (Left c))
22:01:36 <roconnor> @djinn (b -> c, a -> c) -> ((Either a b) -> c)
22:01:36 <lambdabot> f (a, b) c =
22:01:36 <lambdabot>     case c of
22:01:36 <lambdabot>     Left d -> b d
22:01:36 <lambdabot>     Right e -> a e
22:01:48 <ksf> mmorrow, well...
22:02:07 <roconnor> @djinn ((a,b) -> c) -> (a -> b -> c)
22:02:07 <lambdabot> f a b c = a (b, c)
22:02:08 <ksf> I'm going to need something more general, but it's not priority.
22:02:22 <roconnor> @djinn (a -> b -> c) -> ((a,b) -> c)
22:02:23 <lambdabot> f a (b, c) = a b c
22:02:32 <ddarius> cads: The internal language of a CCC being the STLC means that you lose nothing from viewing a cartesian category as 'the STLC plus stuff'  I.e. understanding the STLC means you understand cartesian closedness.
22:02:34 <ksf> plus c2hs completely chokes on varargs, I'm gonna write a c wrapper.
22:02:38 <cads> hmm, I remember seeing a blog post titles an introduction to haskell through category theory (though however cool that would be, that category theorists would desire such an introduction, the title might have been reversed). I think I'll look that up.
22:02:49 <roconnor> (C*B)^A = C^A*B^A
22:03:06 <roconnor> @djinn (a -> (b,c)) -> (a -> b, a -> c)
22:03:06 <lambdabot> f a =
22:03:06 <lambdabot>     (\ b ->
22:03:06 <lambdabot>      case a b of
22:03:06 <lambdabot>      (c, _) -> c,
22:03:06 <lambdabot>      \ d ->
22:03:08 <lambdabot>      case a d of
22:03:10 <lambdabot>      (_, e) -> e)
22:03:22 <roconnor> @djinn (a -> b, a -> c) -> (a -> (b,c))
22:03:22 <lambdabot> f (a, b) c = (a c, b c)
22:03:49 <cads> wow
22:03:56 <ksf> ...first i need to figure out how to pass pointers to haskell functions.
22:03:56 <porges> I think I'll start writing plain numerical exponentiation as variously b ← e or e → b
22:04:20 <ddarius> porges: That notation already means something else.
22:04:40 <ddarius> (Admittedly, something that is rarely used.)
22:05:05 <porges> ddarius: I'm not exactly aiming for clarity
22:05:16 <dolio> http://en.wikipedia.org/wiki/Conway_chained_arrow_notation
22:05:37 <porges> conway had it backwards then ;)
22:05:57 <roconnor> oh and [X] = 1/(1+X) :P
22:06:38 <roconnor> or is that [X] = 1/(1-X) /
22:06:39 <roconnor> ?
22:06:49 <dolio> 1/(1-X), i think.
22:06:57 <ddarius> dolio: I guess it does reduce to this case, so it would be fine to use that notation (carefully)
22:07:12 <ddarius> -
22:07:24 <dolio> Yeah, if you only ever use one arrow.
22:07:41 <ddarius> The limit of the power series Sum_n(x^n)
22:07:55 <dolio> Actually, it's not right, because p -> q = p^q in Conway notation.
22:08:11 <porges> hence my comment ;)
22:08:55 <roconnor> that's okay <= means ==> in haskell
22:09:05 <roconnor> > False <= True
22:09:07 <lambdabot>   True
22:09:17 <mmorrow> , let f name args = text "foreign import ccall unsafe"<+>doubleQuotes (text name) <+> text name <> text "_" <> int (length args) <+> text "::" <+> hcat (punctuate (text " -> ") (fmap text args)) <+> text "-> IO asdf" in vcat $ fmap (\n -> f "foo" (replicate n "CInt")) [0..2]
22:09:19 <lunabot>  foreign import ccall unsafe "foo" foo_0 :: -> IO asdf
22:09:19 <lunabot>  foreign import ccall unsafe "foo" foo_1 :: CInt -> IO asdf
22:09:19 <lunabot>  foreign import ccall unsafe "foo" foo_2 :: CInt -> CInt -> IO asdf
22:09:39 <mmorrow> heh, oops of ":: -> IO asdf"
22:09:50 <ddarius> roconnor: But False <= True is also natural.
22:10:14 <mmorrow> ksf: there's a Ptr type
22:10:40 <pumpkin> can you do inline asm? you can just push more and more things onto the stack and jump manually
22:10:41 <mmorrow> ksf: you can also export haskell functions as function ptrs to C
22:10:48 <pumpkin> of course that's rather arch-dependent
22:10:54 <roconnor> ddarius: well, False ≤ True is natural
22:11:12 <mmorrow> pumpkin: (i386) harpy!
22:11:18 <pumpkin> :)
22:11:29 <pumpkin> can you use harpy in TH to output code though? :P
22:11:36 <pumpkin> into your final executable?
22:11:44 <pumpkin> I sort of doubt it :/
22:11:52 <mmorrow> hmm, i bet you could do something interesting with that idea
22:12:30 <mmorrow> you could always just somehow get harpy to produce a [Word8] of machine code
22:12:50 <mmorrow> lift that into an ExpQ (which'll splice to itself)
22:12:59 <pumpkin> and then somehow unsafely jump to it?
22:13:00 <mmorrow> then jumpo into that [Word8]
22:13:00 <rwbarton> compile-time harpy, mmm
22:13:07 <pumpkin> I'd assume you'd not want a list of Word8
22:13:10 <pumpkin> but some unboxed array
22:13:20 <pumpkin> or a Ptr I guess
22:13:37 <mmorrow> well, a list of [Word8] works, as does pretty much anything you could manage to make an ExpQ rep of
22:13:39 <pumpkin> however you'd probably need to call a mprotect
22:14:02 <mmorrow> http://code.haskell.org/~morrow/code/haskell/misc/Call.hs
22:14:11 <mmorrow> that works with [Word8]
22:14:29 <pumpkin> o.O
22:14:35 <mmorrow> (although in ghc >= 6.10, it'll work but willsegfault upon return)
22:14:40 <mmorrow> ghcI i meant
22:14:44 <pumpkin> aw
22:14:48 <mmorrow> in compiled code it works fine
22:14:52 <pumpkin> make it clean up after itself better
22:15:02 <mmorrow> it's somehow on account of libffi
22:15:05 <rwbarton> hmm, "withCString"... you know that list isn't a C string right?
22:15:10 <mmorrow> and the interaction with bytecode
22:15:17 <mmorrow> fmap w2c
22:15:30 <pumpkin> mmorrow: I'm sure you could still get it to clean up after itself in a more ghci-friendly manner :P
22:15:32 <mmorrow> i have some code that does that nicer though
22:15:37 <rwbarton> I means since its full of 0s
22:15:55 <pumpkin> do any string functions operate on it?
22:15:59 <rwbarton> I guess withCString isn't picky. :)
22:16:06 <mmorrow> pumpkin: the issue is how the bytecode allocates stuff for ccalls via lib ffi i think
22:16:14 <pumpkin> hmm
22:16:26 <rwbarton> withCString docs: "#  the Haskell string may not contain any NUL characters "
22:16:32 <mmorrow> but again, it works 100% fine in compiled code
22:16:41 <mmorrow> rwbarton: heh
22:16:49 <pumpkin> mmorrow: well it returns immediately doesn't it? :P
22:16:50 <mmorrow> we're jumping into it though..
22:16:57 <pumpkin> or does it work even if you do other stuff after it?
22:17:12 <rwbarton> Yeah, I'm not sure exactly what would break.
22:17:18 <mmorrow> pumpkin: it works no matter what the context
22:17:25 <pumpkin> ah, interesting
22:18:08 <mmorrow> here's a version of that that doesn't use withCString
22:18:09 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=712
22:18:24 <mmorrow> (i realized there wasa no harpy involved after i titles that paste)
22:18:42 <mmorrow> withCode :: [Word8] -> (FunPtr a -> IO b) -> IO b
22:18:42 <mmorrow> withCode code = bracket
22:18:42 <mmorrow>   (castPtrToFunPtr `fmap` mallocList code)
22:18:42 <mmorrow>   (free . castFunPtrToPtr)
22:19:23 <mmorrow> and you get the FunPtr -> IO by using a dummy ffi "dynamic" import
22:19:35 <mmorrow> foreign import ccall "dynamic" mkF :: FunPtr a -> IO Word32
22:19:50 <mmorrow> the choice of Word32 is arbitrary
22:20:53 <mmorrow> the harpy disassembler is sooo handy
22:21:11 <pumpkin> I'm really looking forward to playing with it
22:21:26 <mmorrow> hehe, do it and tell me about it! :)
22:21:30 <pumpkin> pity there's not an ARM one :P
22:21:34 <mmorrow> yeah
22:21:54 <mmorrow> but the nice thing is that this streategy'll work on any arch
22:22:05 <mmorrow> it's just doing what harpy does but manually
22:22:13 <pumpkin> ah
22:22:37 <pumpkin> I wonder how fast harpy's disassembler is
22:22:48 <mmorrow> i'm not sure
22:22:53 <mmorrow> compared to what?
22:22:58 <pumpkin> something like IDA
22:23:02 <mmorrow> hmm
22:23:07 <pumpkin> granted, IDA's doing a lot more
22:23:10 <ddarius> It would be straightforward to extend/adapt harpy to different architectures.
22:23:34 * ddarius wouldn't think optimizing speed of disassembly would be high on the priority list.
22:23:36 <pumpkin> ddarius: maybe I'll write an ARM disasm module for it... I have one mostly implemented in ruby I could move over
22:23:50 <wli> Other architectures have a way of having quirks that make x86-oriented affairs break down.
22:24:06 <pumpkin> I don't know how flexible its instruction representation is
22:24:13 <pumpkin> because ARM is pretty different :/
22:24:51 <Adamant> wli: and vice versa
22:25:36 <pumpkin> maybe whatever system they have in place to deal with cmov can be adapted to most arm instructions
22:26:11 <ddarius> Most of the tricky design parts have already been given a solution in harpy and there's not too much about them that have to do with any particular architecture.  Adding a new architecture should be tedious, but straightforward.
22:26:55 <ddarius> pumpkin: Why would there need to be a "system in place" to deal with cmov?
22:27:06 <pumpkin> for dealing with inbuilt conditionals in instructions?
22:27:20 <mmorrow> how tedious would depend on how smart one is about autogenerating code
22:27:25 <ddarius> pumpkin: What is complicated about assembling this?
22:27:56 <pumpkin> ddarius: nothing, I was just wondering what (if any) constraints they put on their instruction representation
22:27:59 <pumpkin> just looking now
22:28:15 * wli generally avoids such presumptions until enough architectures with enough variation between them are handled.
22:28:23 <crazyboy> hii
22:29:17 <pumpkin> lol
22:29:21 <ddarius> wli: Harpy is just an assembler.  There aren't too many complex problems that assemblers have to deal with.  Most of the complex problems are pushed onto the user.
22:29:30 <pumpkin> they represent all the possible suffixes for CMOV explicitly
22:29:37 <wli> Point.
22:29:47 <pumpkin> which means I'd have a pretty huge number of opcodes for ARM :)
22:29:54 <pumpkin> not terrible, but not the most elegant way
22:30:34 <glguy> is the new that GHC 6.10 reports recursive type errors now a feature or a bug...
22:30:48 <glguy> it seems to strip away all of the context that would make the problem solvable
22:30:51 <wli> A data structure where the op is parametrized by Maybe Flag or some such would be nice.
22:31:00 <ddarius> pumpkin: You can easily factor it.
22:31:03 <Axman6> Velociraptors: so, learnt any haskell yet? or are the pack hunting?
22:31:33 <pumpkin> ddarius: yeah :) I guess they just didn't see a need to for x86 given that only a few instructions can have conditionals
22:31:41 * Velociraptors have pixelwork to get done for friends, lately. 
22:41:07 <scook0> is there a short(er) mathematical name for a directed line segment?
22:41:26 <scook0> (i.e. a point and a nonzero vector, or an ordered pair of distinct points)
22:41:26 <mmorrow> pumpkin: i think i'd start with a clean slate if i were to do harpy for another arch
22:42:00 <mmorrow> personally, i don't like how they use all those classes for instructions
22:42:03 <pumpkin> mmorrow: given that they have X86Disassembler and not much in the way of helpers, I probably would too
22:42:10 <mmorrow> pumpkin: totally
22:42:35 <pumpkin> being able to bit-level pattern matching would be excellent in this kind of application too
22:42:50 <pumpkin> I guess we could make a type with 32 Bools
22:42:59 <pumpkin> (given that ARM has fixed instruction width)
22:43:11 <pumpkin> but it'd probably be simpler to just do bit operations
22:43:37 <ddarius> Well adapting harpy to a different architecture would require rewriting most of it anyway.  What you'd be reusing is the design ideas.
22:43:59 <porges> pumpkin: there is a package which emulates Erlangs BitSyntax
22:44:07 <mmorrow> ddarius: yes, definitely reusing its good ideas, and learning from its bad
22:44:13 <porges> it would be awesome to do a quasiquotes version of it
22:44:43 <mmorrow> porges: that would be cool. there's a "core-erlang" package on hackage giving a core AST
22:44:49 <mmorrow> maybe that'll help
22:45:14 <pumpkin> erlang?
22:45:17 <pumpkin> :o
22:45:27 <ksf> foo.o: file not recognized: File format not recognized
22:45:32 <ksf> file foo.o
22:45:33 <ksf> foo.o: GCC precompiled header (version 013) for C
22:45:45 <ksf> talk about ghc, ld and smartness.
22:49:18 <porges> mmorrow: I'm trying to think of how it would be possible to do the pattern matching aspect though
22:49:48 <porges> the only thing I've come up with would be to have a function (say 'bits') that is (Bits a) ⇒ a → [Bool]
22:50:03 <porges> then generate the pattern matching against the Bool list
22:51:15 <porges> so [$bits| firstByte:8, secondTwoBytes:16 |] would generate (firstByte@(_:_:_:_:_:_:_:_):secondTwoBytes@(_:.....:_):[])
22:51:24 <porges> although I'm not sure if that syntax even works
22:51:32 <porges> plus it would be damn slow :P
22:52:38 <mmorrow> porges: i ran into the issue of the TH AST not having pattern guards with my regex QQ
22:52:55 <mmorrow> but i don't think that'll be a problem here
22:52:58 <mmorrow> hmm
22:53:10 * mmorrow tries to remeber exactly what the issue was
22:53:10 <porges> actually that syntax doesn't work
22:53:13 <porges> I seem to have made it up
22:53:13 <porges> :)
22:53:17 <mmorrow> heh
22:53:40 <mmorrow> i don't know erlang though
22:53:50 <mmorrow> so this would be an actual example:
22:53:58 <mmorrow> [$bits| firstByte:8, secondTwoBytes:16 |]
22:53:59 <mmorrow> ?
22:54:04 <porges> yeah
22:54:07 <mmorrow> ok
22:54:11 <porges> it lets you write bitmatching like this <<H:8,T:8>>
22:54:24 <mmorrow> ah
22:54:26 <porges> then in following H is bound to first byte, T to second
22:54:36 <porges> can also be used in an expression context
22:54:44 <porges> so it would seem a good match for TH's quasiquotes
22:54:45 <mmorrow> ohh, i see now
22:55:19 <mmorrow> unfortunately, this has the same problem as the regex QQ
22:55:23 <porges> so we want to be able to write "f [$bits| 1:1, rest:15 |] = "first bit is 1""
22:55:29 <porges> thought so
22:55:34 <mmorrow> in particular, since the TH Pat can't do:
22:56:15 <pumpkin> porges: but you can't change the fundamentals of the pattern match
22:56:16 <mmorrow> case 42 of _ | a <- ... shiftL ... xor .. , b <- ... , c <- ...  ->
22:56:19 <pumpkin> you could add it as a guard
22:56:21 <pumpkin> I guess
22:56:30 <porges> pumpkin: that's the problem :P
22:56:42 <mmorrow> in particular, the TH Pat type needs to have either (1) pattern guards, or (2) view patterns added to it
22:57:12 <mmorrow> once this happens, QQs in pattern context will become 100x more useful
22:57:13 <porges> it would be good to have freeform pattern guards with a 'bind' construct
22:57:34 <porges> or just able to add 'let's
22:57:46 <porges> i guess that's the same thing :P
22:57:56 <mmorrow> yeah, some way to bind vars to expressions in a pattern
22:57:57 <ksf> ugh. c2hs generates foo a $ \a' -> but i need foo a >>= \a'
22:58:10 <wli> What are you referring to as QQ's?
22:58:15 <porges> quasi quoets
22:58:18 <porges> tes
22:58:26 <mmorrow> Language.Haskell.TH.Quote.QuasiQuoter
22:58:34 <mmorrow> , src ''QuasiQuoter
22:58:35 <lunabot>  luna: Not in scope: type constructor or class `QuasiQuoter'
22:58:40 <mmorrow> grrr
22:59:17 <porges> are there any proposals for it?
22:59:38 <ksf> additionally, i find the practice of generating wrappers around haskell functions by specifying dummy foreign imports excessively kludgy.
22:59:46 <mmorrow> there is a ticket for it, but we need to follow up on it
23:00:17 <te> quick: give me an infinite list of integers in haskell
23:00:18 <mmorrow> now that i'm reminded of this, i definitely intend to
23:00:25 <ksf> > [1..]
23:00:27 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
23:00:38 <mmorrow> also, TH needs GADTs BADLY
23:00:54 <porges> could you link? Google thinks I'm a spambot
23:00:58 <mmorrow> heh
23:01:02 <mmorrow> i'll try to find it
23:01:07 <ksf> what did you do?
23:01:30 <ksf> being to clueless and searching too much?
23:01:36 <porges> maybe :(
23:02:07 <porges> Google Error We're sorry...... but your query looks similar to automated requests from a computer virus or spyware application. To protect our users, we can't process your request right now. We'll restore your access as quickly as possible, so try again soon. In the meantime, if you suspect that your computer or network has been infected, you might want to run a  virus checker or spyware remover to make sure that your systems are fre
23:02:22 <pumpkin> epic fail
23:02:22 <ksf> crashing some part of their software with valid xhtml on your homepage?
23:02:25 <pumpkin> or something like that
23:03:00 <ksf> dynamic ip?
23:03:14 <ksf> you could be mistaken for someone else.
23:03:19 <porges> dynamic but rarely changed
23:03:20 <mmorrow> porges: http://hackage.haskell.org/trac/ghc/ticket/2399
23:04:06 <BMeph> Is there a simple method for computing the inverse of a (math) function? I feel like I've see it before, but can't remember what to look it up under....
23:05:00 <te> That's a good question I'd be interested to hear the answer--
23:05:03 <pumpkin> (math)?
23:05:21 <mmorrow> BMeph: you mean inverting a matrix or something? (ie inverting a linear map)
23:05:26 <Cale> BMeph: If it's a composite of invertible functions, the inverse is easy.
23:05:26 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
23:05:28 <porges> mmorrow: your proposal would be enhanced more if you weren't just going for viewpatterns
23:05:38 <ksf> I suppose you don't want to have something that works for things other than bijections, do you?
23:05:47 <dancor> is there a cool way to do (a, Maybe b) -> Maybe (a, b)
23:05:47 <mmorrow> porges: yes, i'm all for pattern guards
23:05:48 <BMeph> Er, s/math/function of a polynomial/
23:05:49 <Cale> If it's a linear map, you can tell if it has an inverse by taking the determinant, and invert it using Gaussian elimination.
23:06:05 <porges> if you can bind variables as well, then we get: example [$rx|.*foo.*(var)]  = "contains foo followed by " ++ var
23:06:08 <Cale> BMeph: Oh, if it's a polynomial? Hmm...
23:06:12 <te> BMeph: taking calc?
23:06:32 <BMeph> te: No, it's a Project Euler problem. :)
23:06:37 <porges> which would be hella sweet, and pretty similar to what I'm trying to accomplish
23:06:37 <pumpkin> BMeph: which one?
23:06:54 <Cale> BMeph: Well, polynomials are continuous, so they're invertible if and only if they're monotone increasing.
23:07:00 <te> ah-ha :) -- I'm in calc this semester and I was thinking perhaps you were trying to build your own calculator for calculus :)
23:07:00 <Cale> er, or decreasing
23:07:09 <mmorrow> porges: ohhh, yes totally. that would be rad.
23:07:13 <Cale> So, if it has even degree, it's not invertible
23:07:13 <BMeph> te: I haven't taken any calc in twenty years, so I think I'm past the statue of limitations. ;)
23:07:19 <mmorrow> (and i think pattern guard would get us this)
23:07:24 <te> haha -- I'm probably a young one in this room
23:07:25 <Cale> If it has odd degree, you have to be more careful.
23:07:27 <BMeph> *statute
23:07:29 <te> 23 y/o here
23:07:35 <mmorrow> (assuming the QQ's parser handles this too)
23:07:44 <pumpkin> te: that's about the age of many people in here
23:07:47 <pumpkin> from what I gather
23:07:57 <te> we're all trying to be really radical by learning Haskell
23:07:57 <pumpkin> at least the active ones, it's hard to tell if they never speak
23:07:59 <dancor> also if you the degree is over 5 there's not likely to be an analytic form for the inverse anyway
23:08:02 <Axman6> te: 19 here
23:08:10 <pumpkin> te: I think most of us just enjoy it :P
23:08:13 <te> Axman6: You've been saying that for years ;)
23:08:21 <Axman6> :P
23:08:31 <pumpkin> his full nick is axman66
23:08:37 <pumpkin> he was born in 66
23:08:44 <pumpkin> he just tries to lure us young'uns
23:08:45 <Axman6> nuh uh :'(
23:09:35 <pumpkin> don't deny it, we know your secret
23:09:44 <pumpkin> BMeph: which problem are you working on?
23:10:03 <dancor> try catch a predator
23:11:42 <ray> i guess people like programming languages their own age
23:12:38 <monochrom> I don't like Algol68.
23:12:54 <int80_h> I was born in 70, not a big fan of algol myself
23:13:02 * BMeph works to figure out the degree of the fibonacci generating function...
23:13:31 <BMeph> pumpkin: Looking at 137. :)
23:13:35 * ray is of unknowable age and doesn't like proto-indo-european that much
23:13:48 <monochrom> hahahaha
23:13:52 <pumpkin> BMeph: :o
23:13:55 <monochrom> I like Chinese more. :)
23:14:30 <monochrom> I supervised Turing's thesis.
23:14:43 <BMeph> I have the ultimate birthdate. Well, except if I were Australian (e.g.), it'd be in September, instead of June. :)
23:14:59 <pumpkin> lol
23:15:00 <pumpkin> rude
23:15:01 <ddarius> :t uncurry (fmap . (,))
23:15:02 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
23:16:00 <pumpkin> strength?
23:16:02 <pumpkin> or something like that
23:16:08 <ddarius> pumpkin: Yes.
23:16:42 <ksf> meh. Agar event's aren't working, I got no idea why and dunno how to start to debug.
23:16:56 <ddarius> The strength part really comes in in being able to pass fmap to uncurry.
23:17:02 <wy> Hello!
23:17:19 <ddarius> (or to compose it using (.))
23:17:44 <pumpkin> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Strong.html
23:17:46 <mmorrow> wli: to answer you question about which QuasiQuoter (now that lunabot is fixed):
23:17:51 <mmorrow> , src ''QuasiQuoter
23:17:52 <lunabot>  luna: Not in scope: type constructor or class `QuasiQuoter'
23:17:54 <mmorrow> hehe
23:17:58 <mmorrow> i'm an idiot
23:18:09 <pumpkin> so strength is just the fmap . (,) bit?
23:18:31 <porges> what's the use of strength?
23:18:52 <ddarius> pumpkin: The whole thing is called a "strength", but it is equivalent to another idea.
23:18:56 <pumpkin> I used it the other day and was quite happy with it, but I'm not sure how typical my use case was
23:18:58 <wy> Let me see if I can get some ideas about the best way to CPS this program: if (if x then (f a) else b) then c else d
23:18:59 <pumpkin> ah
23:19:24 <mmorrow> , src ''QuasiQuoter
23:19:27 <lunabot>  data QuasiQuoter = QuasiQuoter {quoteExp :: (String -> Q Exp),
23:19:27 <lunabot>                                  quotePat :: (String -> Q Pat)}
23:20:02 <pumpkin> porges: I used it in a rather ugly way to get from an association list of (key, IO value) to IO (key, value)
23:21:18 <mmorrow> , src 'strength
23:21:21 <lunabot>  strength :: forall f a b . Functor f => a -> f b -> f ((a, b))
23:21:29 <mmorrow> , 'strength
23:21:30 <lunabot>  Control.Functor.Strong.strength
23:21:45 <pumpkin> Functor could be the name of a superhero
23:21:59 <pumpkin> if you pronounced the O more strongly
23:22:00 <mmorrow> it does have that ring to it i guess
23:22:03 <pumpkin> Funct-OR
23:22:04 <mmorrow> haha
23:22:06 <mmorrow> totally
23:22:11 <pumpkin> and he could be super strong
23:22:12 <ray> what i want to know is why it's called a strength
23:22:18 <mmorrow> or like
23:22:23 <mmorrow> Funct-ORRRRRRRRRRR
23:22:26 <pumpkin> lol
23:22:35 <quicksilver> it's called a strength because it is the property of being strong
23:22:39 <ddarius> ray: The notion comes from enriched category theory.
23:22:50 <pumpkin> we need to get a ridiculous haskell comic going
23:22:57 <quicksilver> and "Strong" is just a traditional term for a mathematical property which is "like this, but a little more"
23:22:59 <pumpkin> even more ridiculous than some of BONUS' pics
23:23:01 <kaol> land of lisp doesn't count?
23:23:40 <mmorrow> that one logo submission that's pencil-drawn about haskell nomads is hillarious x10
23:23:48 <ddarius> If you have a category enriched in another category, V, a strong functor between those enriched categories is a normal functor except that the action on arrows can be represented as an arrow in V.
23:23:52 <mmorrow> don't remember the link..
23:24:14 * pumpkin watches the categories whoosh over his head
23:24:40 <porges> oh god jaworski submitted one
23:24:43 <quicksilver> category theory is, ultimately, a competition
23:24:43 <ddarius> Every closed category can be viewed as a category enriched over itself and in that case a strong (endo)functor is one where the action on arrows is itself an arrow of the category.
23:24:55 <quicksilver> to see who can pile up the most adjectives into one theorem
23:25:04 <ddarius> All this amounts to is that you can pass 'fmap' around like any other function.
23:25:08 <quicksilver> "consider a strong, lax, pointed, separable, ...."
23:25:27 <ddarius> quicksilver: Topology can get pretty bad.
23:25:30 <mmorrow> just like every ring is a trivial module over itself
23:26:47 <ray> well, that's not too difficult for category stuff
23:27:17 <quicksilver> ddarius: true, but a lot of topology feels very like category theory
23:27:34 <quicksilver> (lots of topological things are good examples of categorical things)
23:27:44 <ddarius> quicksilver: Category theory came out of algebraic topology.
23:27:49 * quicksilver nods
23:28:27 <pumpkin> alright, bedtime for me
23:28:41 <Axman6> night pumpkin
23:28:44 <pumpkin> night :)
23:36:01 <dancor> @djin (a, Maybe b) -> Maybe (a, b)
23:36:01 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
23:36:07 <dancor> @djinn (a, Maybe b) -> Maybe (a, b)
23:36:07 <lambdabot> f (a, b) =
23:36:07 <lambdabot>     case b of
23:36:07 <lambdabot>     Nothing -> Nothing
23:36:07 <lambdabot>     Just c -> Just (a, c)
23:38:09 <dancor> @pl \ (a, b) -> ((,) a) <$> b
23:38:09 <lambdabot> uncurry ((<$>) . (,))
23:39:41 <luqui> @pl let f (a,b) = case b of Nothing -> Nothing; Just c -> Just (a,c) in f
23:39:41 <lambdabot> (line 1, column 33):
23:39:41 <lambdabot> unexpected ">"
23:39:41 <lambdabot> expecting variable, "(", operator, ";" or "in"
23:39:49 <luqui> @pl let f (a,b) = case b of { Nothing -> Nothing; Just c -> Just (a,c) } in f
23:39:49 <lambdabot> (line 1, column 25):
23:39:49 <lambdabot> unexpected "{"
23:39:49 <lambdabot> expecting variable, "(", operator, ";" or "in"
23:39:53 <luqui> aww...
23:40:13 <luqui> @pl let f (a,b) = maybe Nothing (\c -> (a,c)) b
23:40:13 <lambdabot> (line 1, column 44):
23:40:13 <lambdabot> unexpected end of input
23:40:13 <lambdabot> expecting variable, "(", operator, ";" or "in"
23:40:18 <luqui> @pl let f (a,b) = maybe Nothing (\c -> (a,c)) b in f
23:40:19 <lambdabot> uncurry (maybe Nothing . (,))
23:44:38 <BMeph>  @pl f (a,b) = case b of Nothing -> Nothing; Just c -> Just (a,c)
23:46:13 <BMeph> Cale: It's degree -1, so that's good, right? ;)
23:46:41 <Cale> BMeph: by that do you mean that it's the zero polynomial?
23:46:57 <dancor> it's funny that pl didn't think of maybe Nothing === (<$>) there
23:47:02 <dancor> but did in the other one
23:47:44 <BMeph> Cale: It better not be, I'm trying to solve it. No, it's the gen'r function for fib. :)
23:48:07 <Cale> oh, then it's not a polynomial at all.
23:48:26 <BMeph> f x = -x/(x^2+x-1)
23:48:30 <dancor> it's a rational function
23:48:50 <mathijs> can someone please explain to me why this happens:
23:48:54 <mathijs> [1,3..10]
23:49:09 <mathijs> map (/10) [1,3..10]
23:49:10 <Cale> > [1,3..10]
23:49:11 <lambdabot>   [1,3,5,7,9]
23:49:12 <BMeph> > [1,3..10]
23:49:13 <lambdabot>   [1,3,5,7,9]
23:49:30 <Cale> > map (/10) [1,3..10]
23:49:31 <lambdabot>   [0.1,0.3,0.5,0.7,0.9,1.1]
23:49:45 <Cale> > [1.0,3..10]
23:49:46 <mmorrow> > [1,3..10] :: [Double]
23:49:48 <lambdabot>   [1.0,3.0,5.0,7.0,9.0,11.0]
23:49:48 <lambdabot>   [1.0,3.0,5.0,7.0,9.0,11.0]
23:49:56 <Cale> Yeah, the instance for Double is a little odd.
23:50:07 <Axman6> @hoogle enumFrom
23:50:07 <lambdabot> Prelude enumFrom :: Enum a => a -> [a]
23:50:08 <lambdabot> Prelude enumFromThen :: Enum a => a -> a -> [a]
23:50:08 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
23:50:10 <mmorrow> personally, i don't use Enum for floatingp types
23:50:13 <Cale> I think that should probably be considered a bug.
23:50:25 <Axman6> enumFromThenTo 1 3 10
23:50:30 <mmorrow> i think an instance at all is slightly a bug
23:50:32 <Axman6> > enumFromThenTo 1 3 10
23:50:33 <lambdabot>   [1,3,5,7,9]
23:50:36 <Cale> I can understand including the end when it's really close.
23:50:36 <BMeph> Cale: No such luck, it's officially a "feature". ;p
23:50:37 <porges> having an instance at all is probably a bug
23:50:42 <mmorrow> yes
23:50:43 <Cale> mmorrow: It's a handy instance.
23:50:53 <Cale> It's nice for sampling.
23:51:11 <mmorrow> perhaps, but i usually use iterate or fmap fromIntegral myself
23:51:20 <Axman6> > [0.0,0.1..1.0]
23:51:21 <lambdabot>   [0.0,0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.89999...
23:51:22 <BMeph> Someone decided that sequences with floating-point numbers should "round"
23:51:25 <hiredman> is there a pdf of learnyouhaskell out and about?
23:51:27 <Axman6> > [0.0,0.1..1.0] :: [CReal]
23:51:28 <lambdabot>   [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
23:51:30 <mathijs> well... I came to the (/10) solution because [0.1,0.3..1] is buggy. I can see why floats aren't enumerable, but as I see it, the 1,3..10 part are ints?
23:51:53 <Axman6> hiredman: heh, decided to finally learn haskell then? :)
23:51:54 <mmorrow> > fmap ((/10) . fromIntegral) [1,3..10]
23:51:55 <hiredman> Axman6: why hello again
23:51:55 <lambdabot>   [0.1,0.3,0.5,0.7,0.9]
23:52:09 <Axman6> o/
23:52:10 <dancor> :t (/)
23:52:12 <lambdabot> forall a. (Fractional a) => a -> a -> a
23:52:26 <hiredman> yeah, well, I have been lurking here for a week or two
23:52:45 <mathijs> mmorrow: ok thanks... I didn't see the implicit assumption for [1,3..10] to be Double...
23:52:53 <mmorrow> :)
23:53:01 <porges> > [0,0.1..1.0]
23:53:01 <porges> [0.0,0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.6000000000000001,0.7000000000000001,0.8,0.9,1.0]
23:53:02 <lambdabot>   [0.0,0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.89999...
23:53:07 <BMeph> dancor: So, is there a procedure to find the inverse of a rational function? ;)
23:53:13 <porges> doesn't even match across machines?
23:53:34 <BMeph> dancor: That you know, or know where to point? :)
23:53:42 * Axman6 suhhests dividing 1 by it...
23:53:51 <Axman6> suggests even
23:54:07 <mathijs> mmorrow: why are you using fmap though? won't map suffice?
23:54:24 <mmorrow> mathijs: it would, i just have the habit of always using fmap
23:54:43 <mmorrow> i don't even think before i type anymore
23:54:45 <mathijs> ok, in that case... fmap you very much :)
23:54:48 <mmorrow> heh
23:54:51 <porges> tbh fmap should just be called map
23:54:59 <mmorrow> yeah, i'd like that
23:55:04 <porges> RAAAAAAAAGE
23:55:09 <mmorrow> GRRRRRR
23:55:33 <porges> the more general the usual functions are the better :)
23:55:36 <dancor> BMeph: idk, probably nothing very general since it should be at least as hard as polynomials which become non-analytic in general after quartics
23:56:12 <mmorrow> also, mappend should be (++)
23:56:24 <porges> yes
23:56:24 <mmorrow> and mempty "zero" or something
23:56:53 <mmorrow> (mconcat concat, etc)
23:56:53 <porges> class Monoid m where
23:56:53 <porges> 	zero ∷ m
23:56:53 <porges> 	(⊕) ∷ m → m → m
23:56:55 <Axman6> porges: i believe it used to be called map
23:57:03 <mmorrow> yay, nice
23:57:35 <ddarius> Axman6: It did.  I'm pretty sure it was in previous version of Haskell.  It certainly was when the Functor type class was first introduced in Gofer.
23:57:58 <Cale> Yeah, in Haskell 1.4, I believe
23:58:17 <porges> class Functor f where
23:58:18 <porges> 	(⊙) ∷ (a → b) → (f a → f b)
23:58:35 <porges> :P
23:59:09 <mmorrow> unicode syms need to be raided sooo bad
23:59:19 <mmorrow> we're just missing out until then
23:59:55 <Cale> I don't think they should be used for the most common stuff though.
