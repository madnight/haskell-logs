00:07:20 <ksf> su -
00:07:26 <ksf> waaaaaait.
00:07:34 <ksf> wrong terminal.
00:07:38 * Badger chuckles
00:07:43 <lfeagan> lol, happesn all the time to me too
00:07:44 <Badger> ksf: PAssword:
00:07:49 <Badger> (oops)
00:08:09 <lfeagan> esp since I use focus under mouse
00:09:21 <ksf> vi secret_plans/world_domination
00:09:28 <ksf> dammit ;)
00:09:54 <Badger> vi? psht :P
00:09:59 <lfeagan> "The same thing we do everynight Pinky...try to take over the world!"
00:10:48 <dolio> @brain
00:10:49 <lambdabot> But where are we going to find a duck and a hose at this hour?
00:11:08 <Badger> erk
00:11:51 <lfeagan> Curious question, is there a syntax file for vim that handles the indent rules of Haskell? Is there one for emacs? Other?
00:12:27 <lfeagan> I am rather new to Haskell. Vim does the highlighting just fine. Its the indents that aren't so hot.
00:13:01 <lgas> I'm new to haskell too, so I don't know if it's perfect or not (it feels off sometimes) but haskell-mode for emacs handles it pretty well.
00:14:42 <lfeagan> Does it line up things like multi-line let statements without having to pound away on the spacebar?
00:14:49 <lgas> yeah, you just hit tab
00:15:14 <lfeagan> Alrightly, even with my love of vim, that would be very compelling.
00:15:21 <sereven> lfeagan: http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/ for vim
00:15:25 <lgas> although that's one of the areas where I've seen it do weird things... like overindent each subsequent line
00:15:29 <sereven> or check out yi, too
00:15:41 <lgas> (but it only takes one tab to over indent it :))
00:15:49 <lfeagan> alrighty, appreciate the input
00:16:00 <lfeagan> Yes, one tab is far better than hitting space 20+ times
00:16:45 <wli> amen
00:16:46 <lfeagan> sweet, a haskell plugin, i will give this a try, exciting
00:31:05 <Gracenotes> inBoundsX array coord = inRange (join (***) fst (bounds array)) coord  -- :\
00:48:12 <augustss> @pl inBoundsX array coord = inRange (join (***) fst (bounds array)) coord
00:48:13 <lambdabot> inBoundsX = inRange . (fst *** fst) . bounds
00:49:06 <Gracenotes> hm. maybe the join isn't really worth it
00:53:36 <xenoblitz> Hi people can anyone tell me the meaning of neumonic... I met it in a paper about Fran and I can't find its meaning anywhere. thanks
00:56:04 <Gracenotes> @pl \x -> f (fst x) && f (snd y)
00:56:05 <lambdabot> (&& f (snd y)) . f . fst
00:56:20 <Gracenotes> @pl \x -> f (fst x) && f (snd x)
00:56:20 <lambdabot> ap ((&&) . f . fst) (f . snd)
00:56:32 <Gracenotes> @pl \x f -> f (fst x) && f (snd x)
00:56:32 <lambdabot> ap (ap . ((&&) .) . flip id . fst) (flip id . snd)
00:56:40 <Gracenotes> @pl \f x -> f (fst x) && f (snd x)
00:56:40 <lambdabot> ap (ap . ((&&) .) . (. fst)) (. snd)
00:56:47 <Gracenotes> pointful it is...
00:57:01 <idnar> @type \f x -> f (fst x) && f (snd x)
00:57:02 <lambdabot> forall a. (a -> Bool) -> (a, a) -> Bool
00:57:33 <Gracenotes> f is just (==0), in this case
00:57:36 <idnar> @type \f x -> f &&& f
00:57:38 <lambdabot> forall t (a :: * -> * -> *) b c. (Arrow a) => a b c -> t -> a b (c, c)
00:58:12 <idnar> hmm ,no
00:58:34 <idnar> @type \f -> uncurry ((&&) `on` f)
00:58:35 <lambdabot> forall a. (a -> Bool) -> (a, a) -> Bool
00:58:44 <idnar> @pl \f -> uncurry ((&&) `on` f)
00:58:44 <lambdabot> uncurry . ((&&) `on`)
00:58:45 <Gracenotes> @type on
00:58:46 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
00:58:51 <idnar> @src on
00:58:51 <lambdabot> (*) `on` f = \x y -> f x * f y
00:59:14 <Gracenotes> @src liftA2
00:59:14 <lambdabot> liftA2 f a b = f <$> a <*> b
00:59:19 <Gracenotes> @src liftA
00:59:19 <lambdabot> liftA f a = pure f <*> a
00:59:32 * Gracenotes must be thinking of another function..
00:59:35 <Gracenotes> seems very much like it
01:00:00 * Gracenotes will remember `on`
01:04:37 <Workybob> I'd love the definitions of liftA and liftA2 to be more consistant than that
01:04:49 <Workybob> it really should be liftA2 f a b = pure f <*> a <*> b
01:05:53 <idnar> why not <$>?
01:06:55 <Workybob> well, yeh, liftA f a = f <$> a would make it symetrical too
01:07:16 <Workybob> but I prefer the pure f <*> a <*> b, because it demonstrates that <*> really is "apply"
01:07:24 <Workybob> and that you still get currying
01:08:29 <idnar> @src liftM
01:08:29 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
01:08:50 <idnar> er, duh
01:09:24 * Workybob would really love to see that without do notation too -- liftM f m1 = return . f =<< m1 is much nicer
01:09:44 <Workybob> but I guess that one doesn't scale to liftM2
01:09:48 <idnar> that's subjective >:)
01:10:13 <Gracenotes> ah. liftA2 differs from on, because whereas on has two arguments applied to one function and combined, liftA2 for functions has one argument applied to two functions and combined
01:10:33 * Gracenotes is confused no more, so he thinks
01:10:46 <idnar> liftM f a = return f `ap` a
01:11:01 <Workybob> idnar: that one's nice, but I guess it shows less it being monadic
01:11:15 <Workybob> and if we didn't want to show that, we'd just write liftM = fmap
01:11:21 <Workybob> and liftA = fmap
01:11:26 <idnar> indeed
01:12:22 <Workybob> having said that, liftMn never made much sense to me – liftAn makes sense because there's no fmap2, fmap3 etc
01:12:33 <Workybob> but liftMn is just duplicating a set of functions that already exist
01:13:29 <Workybob> the only way it makes sense is fitting in with the chronology of Haskell
01:13:46 <idnar> what does liftMn duplicate?
01:13:58 <Workybob> liftAn
01:14:16 <idnar> ah
01:14:27 <idnar> well, yes, it should be Functor => Applicative => Monad
01:14:55 <Workybob> similarly (and worse in fact) mapM being monadic needs updated
01:15:10 <Workybob> that's worse because there *is* no mapA that I'm aware of
01:15:33 <idnar> @src mapM
01:15:33 <lambdabot> mapM f as = sequence (map f as)
01:15:45 <idnar> how do you implement mapA?
01:15:52 <Workybob> same as that
01:15:53 <Workybob> sequence = foldr (liftA2 (:)) (pure [])
01:16:06 <idnar> hmm
01:18:33 <Cale> :t traverse
01:18:34 <lambdabot> Not in scope: `traverse'
01:18:40 <Cale> :t Data.Traversable.traverse
01:18:42 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Applicative f, Data.Traversable.Traversable t) => (a -> f b) -> t a -> f (t b)
01:19:02 <Workybob> ohhh, neat
01:19:05 <Cale> :t Data.Traversable.for
01:19:06 <lambdabot> forall (t :: * -> *) a (f :: * -> *) b. (Applicative f, Data.Traversable.Traversable t) => t a -> (a -> f b) -> f (t b)
01:19:11 <Workybob> cheers Cale
01:19:44 <Cale> no problem :)
01:25:39 <Gracenotes> @hoogle /^\
01:25:40 <lambdabot> No results found
01:25:47 <Gracenotes> ..does that kind of look like a delta?
01:26:09 <Gracenotes> uppercase
01:30:09 <quicksilver> Gracenotes: no, it looks like an emoticon doing a handstand ;)
01:30:24 <Gracenotes> lol.
01:31:02 <Gracenotes> I guess I'll use (quantity) <+ (change in quantity), then.
01:31:19 <Gracenotes> < being an arrow of sorts
01:31:35 <Gracenotes> in the typographical sense..
01:32:11 <quicksilver> I tend to reserve symmetric-looking-operators (like /^\) for symmetric operations
01:32:14 <quicksilver> YMMV.
01:32:42 <Workybob> /_\ looks kinda delta like
01:32:50 <Workybob> but _ counts as a letter doesn't it?
01:32:53 <quicksilver> Control.Applicative notably ignores this property.
01:33:04 <xenoblitz> Hi people I need to read up about Functional Reactive Programming... any introductory papers you can suggest are highly appreciated!
01:33:19 <Workybob> quicksilver: so does haskell – ' ' (apply) isn't a symetric operation
01:33:23 <Gracenotes> > let (/_\) = (+) in 34 /_\ 16
01:33:24 <lambdabot>   <no location info>: parse error on input `\'
01:33:29 <quicksilver> Workybob: indeed :)
01:33:44 <Workybob> xenoblitz: the Yampa arcade paper is a good start, and then conal's reactive paper
01:33:49 <Workybob> the Fruit paper too
01:34:10 <xenoblitz> Workybob: you mean Functional Reactive Animation by Elliott and Hudak right? :)
01:34:12 <Workybob> xenoblitz: it's a good idea to read at least one yampa and one reactive paper though, to get an idea of which set of the problems each one solves
01:34:19 <Workybob> xenoblitz: no, that's the fran one
01:34:29 <Workybob> it's truely functional user interfaces or something like that
01:34:37 <Workybob> also a conal one
01:34:40 <quicksilver> I'm not sure conal's reactive paper is a good way to learn about FRP.
01:34:47 <Workybob> no, it's really not
01:34:53 <quicksilver> it's very specific and fairly details about a particular implementaiton
01:34:58 <Workybob> but after the 13th read, it's a good way to get into what reactive is
01:35:06 <quicksilver> and also I have no grammar or spelling this morning
01:35:19 <quicksilver> ENOTENOUGHCOFFEE
01:35:47 <xenoblitz> Anyones from here? http://www.haskell.org/yale/publications.html
01:35:52 <Workybob> xenoblitz: http://netsuperbrain.com/blog/posts/category/reactive-tutorials/ <-- these are a good way to get into reactive, but not FRP in general
01:35:56 <yitz> quicksilver: coffee makes me type faster yith moremstakes
01:36:02 <Workybob> xenoblitz: yes! Yampa arcade
01:36:15 <Workybob> Yampa arcade is an excellent start for the arrows based approach to FRP
01:36:43 <quicksilver> the fran webpage/tutorial thing is not a bad place to pick up some of the general concepts, IIRC>
01:37:29 <Workybob> xenoblitz: to clarify, FRP can be (mostly) split into two categories "classical" FRP, and arrows based FRP
01:37:31 <xenoblitz> I'll read this Yampa one... coloured pictures impress me still apparently :P
01:37:43 <Workybob> hehe, it's proabbyl the easiest one to get into it with
01:37:50 <Workybob> classical FRP lets you play with the signals directly
01:38:04 <Workybob> arrows based restricts you, and in doing so, solves some memory performance problems
01:38:10 <Workybob> but also makes your code look horrible in the process
01:38:18 <xenoblitz> has anyone read this one?
01:38:19 <xenoblitz> http://www.haskell.org/yale/papers/pldi00/index.html
01:38:56 <Workybob> can't say I've read that one specifically
01:39:44 <xenoblitz> I'm attracted to the title since it says first principles (which I kinda need)
01:40:55 <Workybob> hmm, neat
01:41:03 <Workybob> that one appears to be a nice introduction to classical FRP
01:41:08 <xenoblitz> nice :)
01:41:31 <xenoblitz> i need to read up on arrows i guess then
01:41:35 <xenoblitz> i have met them from time to time
01:41:40 <xenoblitz> but i never got into them
01:41:49 <Workybob> the Yampa arcade paper has pretty diagrams that explain them
01:42:01 <xenoblitz> ok i'll start reading :)
01:42:03 <xenoblitz> thanks Workybob
01:42:05 <Workybob> np
01:56:12 <MacNala> can anyone help with a question about Real World Haskell?
01:56:24 <quicksilver> not until you ask it :)
01:56:56 <MacNala> in the 'Getting Started' section there are exercises are there answers anywhere?
01:57:35 <xydyx> some people put their answers on github
01:57:50 <MacNala> what is github?
01:58:16 <xydyx> a code hosting service
01:58:32 <MacNala> how do you access it?
01:58:39 <xydyx> http://github.com/search?q=real+world+haskell&type=Repositories
01:59:18 <MacNala> thanks - I have only got interested in haskeel and thought that Real World might be a teaching book
02:01:35 <goalieca> ?src unfold
02:01:35 <lambdabot> Source not found. Just try something else.
02:01:47 <goalieca> ?src unfoldr
02:01:47 <lambdabot> unfoldr f b  = case f b of
02:01:47 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
02:01:47 <lambdabot>    Nothing        -> []
02:35:52 <hugo___> hi
02:42:39 <hugo___> im with a big dillemma
02:45:19 <Cale> What are the options?
02:45:35 <hugo___> :(
02:46:03 <hugo___> im currently taking a course on digital arts, and coding haskell for 500 euros/month, almost full time (i take two afternoons for the course)
02:46:14 <hugo___> i spend the money on the course and food :/
02:46:32 <Workybob> ouch, 500 a month for haskell is pretty fail
02:46:49 <hugo___> yeh... big time fail, thats functional programming in portugal for you...
02:46:56 <Workybob> nasty
02:47:12 <hugo___> but im learning along the way, wich makes it tolerable
02:48:05 <quicksilver> 500 euros a month full time is under the EU minimum wage.
02:48:10 <quicksilver> quite considerably under :-/
02:48:16 <hugo___> is it ?
02:48:23 <Workybob> good point quicksilver
02:48:25 <hugo___> in PT the minimum wage is 385 euros/month
02:48:41 <hugo___> i guess things are also cheaper here
02:48:56 <hugo___> the average wage is 900 euros / month
02:49:00 <Workybob> wow
02:49:20 <quicksilver> hmm, my source says 470
02:49:21 <quicksilver> still...
02:49:28 <Workybob> I spend 800 euro/month just on rent
02:49:57 <hugo___> oh maybe its 470 yes... last time i checked was 385, wich was 2 years ago
02:50:28 <hugo___> :/
02:50:40 <Workybob> apparently the minimum wage here is 1309.59 a month
02:51:22 <dolio> > 470 * 1.3 / 160
02:51:23 <lambdabot>   3.81875
02:51:38 <Workybob> why *1.3?
02:51:44 <hugo___> euribor ?
02:51:45 <dolio> I live in the US.
02:51:48 <hugo___> ah
02:51:50 <Workybob> ah, I see
02:52:24 <hugo___> anyway, this python/java coding oportunity came up
02:52:33 <hugo___> which pays really well (for pt standards)
02:52:52 <hugo___> but is totally full-time... so i would have to stop the course on digital arts, and haskell coding :P
02:53:03 <earthy> mininum monthly wage for an eighteen year old in .nl is EUR 628 gross
02:53:36 <earthy> this goes up to EUR 1381,20 gross for people over 23
02:53:54 <hugo___> hmm, im 26
02:54:06 <Workybob> makes you realise how much the "value" of the euro is averaged out
02:54:22 <Workybob> in that it's probably not really that hugo___ earns less money – just a euro is worth more in PT
02:54:37 <hugo___> yeh
02:55:06 <hugo___> i can manage well with 500 euros/month, but i'm not making any savings, and spending 280 euros/month on the arts course
02:55:15 <hugo___> the rest in food/cellphone bill
02:55:15 <Workybob> wow
02:55:21 <Workybob> how much is your rent?
02:55:38 <yitz> if there is free trade, those difference ought to gradually smooth out
02:55:39 <hugo___> my brother is paying it... 200 euros/month
02:55:46 <Workybob> blimeh
02:55:51 <earthy> yitz: not necessarily
02:55:57 <Workybob> you'd never get somewhere that cheep here
02:55:58 <earthy> yitz: regional differences *do* exist
02:56:06 <Workybob> indeed
02:56:08 <earthy> (even within .nl, which is 400km tall and 200km wide)
02:56:22 <Workybob> take for example that a pint costs £3.50 in london, but £1.50 in St. Andrews
02:56:42 <yitz> earthy: if it's cheaper in PT, why not buy all of it and ship it to FR or whatever?
02:56:55 <Workybob> yitz: how much does shipping cost?
02:57:00 <earthy> yitz: shipping is not free
02:57:01 <mmorrow> is there any portable (or save that, any) way to trap a mem access outside of a pre-specified region (at the user level)?
02:57:11 <hugo___> with a big nice view over the river
02:57:20 <Saizan> @where hpaste2
02:57:21 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
02:57:23 <mmorrow> (so for instance you don't have to constantly be bounds checking)
02:57:25 <yitz> Workybob: depends on the commodity, of course, but usually in quantity it's not a big issue.
02:57:29 <daf> hugo___: do you enjoy the Haskell job?
02:57:44 <yitz> the main issue is usually trade restrictions and taxes.
02:57:53 <yitz> but the eu gets rid of all that, no?
02:58:08 <Workybob> indeed
02:58:19 <Workybob> except sometimes mainland -> UK
02:58:23 <Workybob> and back
02:58:28 <earthy> plus, taxes are not uniform in .eu
02:58:29 <mmorrow> computers are built/organized totally from the opposite perspective they should be (imho) :)
02:58:39 <earthy> e.g. VAT rates vary across europe
02:58:39 <hugo___> the view from my room: http://reverie.dreamhosters.com/room.jpg
02:58:42 <daf> Workybob: er, what?
02:59:01 <Workybob> daf: you can end up paying taxes for moving something to/from the UK
02:59:07 <earthy> wow. good spot, hugo
02:59:10 <Workybob> e.g. I had to pay import duty to take my car from the UK to .be
02:59:17 <Workybob> because VAT was different
02:59:24 <hugo___> daf: i enjoy the coding a lot... i dislike my boss, he doesn't know a thing about programming, and is always arguing that with m$ everything would already be done (like magic)
02:59:53 <daf> Workybob: I'm not sure that's specific to the UK though
02:59:58 <Workybob> hugo___: haha, my boss had a dose of that, then tried writing something in Haskell and got a "holy shit, I couldn't have coded this this fast in .Net"
03:00:19 <Workybob> daf: I *think* it's specific to countries that didn't join the euro
03:00:24 <daf> hugo___: well, that's worth something
03:00:27 <jeffz`> mmorrow: i don't know the details, but atleast on windows i've seen plenty of programs which have exception handlers that effectively hide such bugs.
03:00:34 <earthy> workybob: it isn't
03:00:39 <Workybob> oh?
03:00:40 <Workybob> okay
03:01:01 <earthy> importing a car from germany in to .nl requires you to pay the .nl duties for cars e.g.
03:01:03 <daf> mmorrow: you can write a SIGSEGV handler
03:01:03 <hugo___> daf: yeh, i guess
03:01:12 <mmorrow> jeffz: hmm
03:01:15 <mmorrow> daf: oh?
03:01:32 <daf> mmorrow: but finding out the address of the unmapped access might involve magic
03:01:34 <mmorrow> daf: but what if it turns out to be a legal mem access
03:01:40 <mmorrow> hmm
03:01:52 <daf> if it's a legal mem access, you won't get a sigsegv :P
03:02:18 <daf> the only time a mem access to unmapped memory is legal is when your stack is expanding
03:02:37 <hugo___> put a handle on the sigsegv, and restart the app :D
03:03:07 <yitz> mmorrow: why do you care about this hardware detail?
03:03:25 <mmorrow> ohhhh, so i can map a chunk of mem (which is my desired "region"), and then count on any accesses outside (but intended to be in) of it to cause a SIGSEGV?
03:03:32 <mmorrow> yitz: just curious
03:03:49 <daf> mmorrow: no, you can't
03:03:52 <mmorrow> crap
03:04:17 <daf> accesses to your heap or to your bss/data regions will still be valid
03:04:22 <Saizan> > False `mappend` True
03:04:24 <lambdabot>       No instance for (Monoid Bool)
03:04:24 <lambdabot>        arising from a use of `mappend' at...
03:04:25 <daf> but they won't be included in your mapped segment
03:04:33 <yitz> this doesn't sound like an issue that will come up too often in Haskell
03:04:35 <hugo___> where is the new hpaste ?
03:04:41 <Saizan> @where hpaste2
03:04:41 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
03:04:45 <daf> mmorrow: I'm curious what you're trying to achieve
03:04:47 <hugo___> thanks
03:05:19 <daf> mmorrow: if you want really specific information about memory access, you probably need a tool like valgrind
03:05:25 <daf> i.e. emulation
03:05:30 <mmorrow> daf: i was wondering if somehow instead of constantly bounds checking your heap, you could just have the first mem access outside of it trigger a gc
03:05:49 <mmorrow> or analogously for stack overflow
03:05:57 <yitz> mmorrow: ah, this is for the lhc gc?
03:05:59 <hugo___> anyway, yesterday i finished the unique random number generator i was making at home as a hobby for a possible noise lib in haskell, check it: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1006#a1006
03:06:17 <hugo___> started/finished
03:06:20 <daf> mmorrow: oh, hmm
03:06:20 <mmorrow> yitz: it's for this thing i'm working on slash just in general
03:07:00 <mmorrow> yitz: but yeah, i want to look at lhc's c output to see what it'd take to add (any sort of) gc
03:07:49 <mmorrow> if it still looks like jhc's, it's very readable for generated code (well i guess the readable part isn't generated so much as dumped to the file)
03:07:51 <hugo___> does ghc works out all possible pure functions values at compile time ?
03:08:22 <hugo___> and replace them with the output value ? :P
03:08:57 <mmorrow> heh
03:09:13 <mmorrow> what about (\x -> x) ?
03:09:28 <mmorrow> oh, n/m i see how you mean that
03:09:37 <mmorrow> what if you do
03:09:56 <mmorrow> print . (*2) . read =<< getLine ?
03:10:24 <mmorrow> you mean like constant-subexpression-elimination?
03:10:32 <hugo___> i dont know :/
03:10:44 <lilac> also, what if you do "let fibs = fix ((0:).(1:).(zipWith (+)`ap`tail)) ?
03:10:54 <lilac> the compiler can't work out the value of an infinite type at compile time
03:11:27 <hugo___> what about accessin an imutable array built by pure functions ?
03:11:39 <hugo___> like an array of sin's and cos's
03:11:47 <hugo___> of static values
03:11:52 <lilac> what if the array is huge and might never be used?
03:11:55 <hugo___> sin 90, cos 0...
03:11:59 <lilac> should the compiler speculatively build it?
03:12:03 <yitz> hugo___: even if it's not infinite, a value could be a very large list that is very expensive to generate and memoize.
03:12:14 <mmorrow> hugo___: you could for instance use template-haskell to do an arbitrary amount of precomputation at compile-time
03:12:35 <hugo___> hmm, ok i see
03:12:47 <augustss> hugo___: The compiler does constant folding, but if recursive or C functions are involved it doesn't do much.
03:12:59 <hugo___> ok
03:13:16 <mmorrow> heh, *common*-subexpression-elim i meant ;)
03:13:20 <daf> mmorrow: it seems like it might be possible using the right hacks, but I'm not sure how it would work exactly
03:13:25 <yitz> but you can force it to by putting it in a let
03:13:32 <hugo___> then TH is the solution for fast run-time execution
03:13:50 <yitz> hugo___: you usually don't need TH for that
03:13:50 <daf> mmorrow: it depends where the possible out-of-bounds access would go
03:13:50 <hugo___> so the lets are diff from the wheres ?
03:13:57 <yitz> or where
03:13:59 <lilac> hugo___: by a combination of inlining and case folding, many pure values /will/ get precomputed, though
03:14:09 <augustss> hugo___: only syntactically different
03:14:12 <QtPlatypus> Why does this overflow the stack?
03:14:14 <hugo___> ok
03:14:21 <daf> mmorrow: if they will always be just above where your current heap is, it could work
03:14:28 <yitz> QtPlatypus: use foldl'
03:14:31 <daf> mmorrow: but you would have to mmap your heap
03:14:32 <QtPlatypus> fib = [1,1] ++ zipWith (+) (tail fib) (tail . tail $ fib)
03:14:50 <mmorrow> daf: yeah i guess you'd have to count on some error condition rather than just being able to express your intent
03:14:51 <daf> mmorrow: and then have a separate read-only mmaped region just above it
03:14:52 <yitz> oh no
03:14:56 <mmorrow> daf: oh, hmm
03:15:05 <daf> mmorrow: and then try to recognise that in a segfault handler
03:15:15 <hugo___> can't i turn the memoization automatically on ? without much mangling ?
03:15:16 <augustss> QtPlatypus: what are you doing with that definition?
03:15:20 <hugo___> like the sparks in par ?
03:15:22 <daf> mmorrow: then, when you expand your "heap", move the read-only segment up accordingly
03:15:35 <mmorrow> daf: interesting
03:15:36 <daf> mmorrow: depends how your memory allocation is implemented
03:15:46 <daf> mmorrow: i.e. you can't just use libc malloc
03:16:10 <QtPlatypus> augustss: Trying to create a list of fibonacci sequence
03:16:12 <mmorrow> i'm currently mallocing a huge (fixed) heap, then allocating out chunks from there, so i could mmap just the same
03:16:23 <daf> mmorrow: ah, might be possible
03:16:37 <daf> mmorrow: come to think of it, I have a very vague impression about hearing of this being done before
03:16:37 <mmorrow> cool, i'll check it out
03:16:40 <daf> maybe it was SBCL
03:16:40 <augustss> > let fib = [1,1] ++ zipWith (+) (tail fib) (tail . tail $ fib) in fib!!10
03:16:45 <lilac> QtPlatypus: how do you /use/ that list?
03:16:48 <mmorrow> daf: oh sweet
03:16:56 <lambdabot>   thread killed
03:16:56 <yitz> > let fib = [1,1] ++ zipWith (+) (tail fib) (tail . tail $ fib) in take 10 fib
03:17:04 <daf> mmorrow: but I'm into very hazy territory here :)
03:17:07 <lilac> QtPlatypus: it fails because it can't compute the third element
03:17:09 <yitz> > let fib = [1,1] ++ zipWith (+) (tail fib) fib in take 10 fib
03:17:10 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
03:17:11 <lambdabot>   thread killed
03:17:19 <yitz> QtPlatypus: too many tails
03:17:19 <lilac> QtPlatypus: tail.tail fib is defined in terms of itself
03:17:20 <mmorrow> daf: heh, thx for the info :)
03:17:32 <daf> mmorrow: np; would be interested to hear if anything comes of it
03:17:47 <mmorrow> daf: for sure
03:17:48 <lilac> QtPlatypus: that is, head.tail.tail$fib = (head.tail$fib) + (head.tail.tail$fib)
03:17:53 <augustss> daf: what was this about a write protected memory area?
03:18:35 <mmorrow> augustss: i was wondering if there's some way to, rather than constantly bounds check when you're allocating from your heap, to just have to first out-of-heap mem access trigger a gc
03:18:45 <QtPlatypus> Oh I see.
03:18:54 <augustss> mmorrow: ah
03:19:40 <augustss> mmorrow: it should be possible, but you'll get the access violation at an arbitrary point in your code rather than at a safe point
03:20:26 <mmorrow> hmm, but what if i ensured that it was always the allocator itself that was triggering this somehow
03:20:28 * Workybob ponders what's advantagous about the zipWith definition of fibs
03:20:48 <Workybob> (over fibs n m = n : fibs m (n+m) for example)
03:21:18 <mmorrow> or saying that differently, i bet there's some way to make it happen when it's ok (maybe)
03:21:23 <augustss> mmorrow: you could touch the memory at the end of the allocation first, but that would be more expensive than the compare&branch
03:21:44 <mmorrow> ah dang, that's exactly what i was thinking to do
03:22:04 <mmorrow> yeah, now that i think about it that's obviously more expensive
03:22:05 <augustss> mmorrow: you could also arrange the allocation carefully so that for each exception PC you know what safe point to back up to and then rerun the allocation after gc
03:22:50 <mmorrow> innteresting
03:23:25 <augustss> mmorrow: but that limits what you can do while filling allocated memory
03:24:28 <Saizan> Workybob: it's more declarative
03:24:38 <Workybob> Saizan: it is?  How?
03:24:39 <augustss> mmorrow: it's nice to hear that some are still interesting in the low level gory details :)
03:24:47 <mmorrow> augustss: hehe
03:25:51 <augustss> mmorrow: the check for heap overflow is typically not that expensive because you amortize over a number of allocations.
03:25:55 <Saizan> Workybob: in your you've to assume that the arguments to fibs are fib (n-1) fib (n-2) while in the zipWith version it's more ovbious because you reference the value directly
03:26:27 <Saizan> Workybob: but the principal value of that definition is to bend the minds of newbies :)
03:26:34 <mmorrow> augustss: ah, yeah i've heard that said before. how do you do this?
03:26:40 <Workybob> Saizan: not at all – in mine I make a more general statement that you can generate lots of sequences like the fibonacci numbers based on different starting values
03:26:41 <augustss> mmorrow: for instance, on function entry you can check for the maximum needed in any branch of the function code (up to the next call/jump)
03:26:50 <Workybob> there's no assumption about what those starting values are
03:27:10 <mmorrow> augustss: ah, i think i see the idea
03:27:33 <Workybob> but I take your point about newby mind bending
03:29:01 <SamB_XP> Workybob: except then it's not the fibonacci sequence, just A fibonacci sequence
03:44:17 <akillah> hi, i think i could solve my encoding problem by defining a custom instance of ToMessage for Html. the problem is that HAppS already defines one. Is there another way to redefine it than to scrap if from HAppS & recompile it ?
03:45:08 <augustss> akillah: that's the only way, relly.
03:45:33 <akillah> no funky language extension ? ;-(((
03:46:29 <Saizan> akillah: use a newtype
03:46:30 <augustss> I've not looked at the problem, but it's very unlikely
03:46:50 <SamB_XP> akillah: why don't you just decode your INPUT ?
03:47:06 <Saizan> akillah: or write your own function :: Html -> Response
03:48:34 <akillah> samb_xp i decode my input but something forces all the diacritic characters into trigraphs. i'll try to re-encode the output of renderHtml to see if it helps ...
03:49:50 <akillah> saizan: thanks for the nice tips
04:26:10 <bastl> hi all.
04:27:00 <akillah> hi
04:27:11 <alexeevg> hiya
04:29:30 <yitz> > let generalFibs initialFibs delta = fix $ (initialFibs ++) . (zipWith (+) `ap` (drop delta)) in take 20 $ generalFibs [1,1,1] 2
04:29:31 <lambdabot>   [1,1,1,2,3,4,6,9,13,19,28,41,60,88,129,189,277,406,595,872]
04:29:45 <bastl> i come from an OO background. Now i want to model my datastructures wth typeclasses and data. Is there any text that deals with the transition from OO-modeling (e.g. java-Interfaces, associations, design-patterns, UML etcpp) to functional features (types, type-classes, functions) ??
04:30:06 <yitz> bastl: there's a wiki page
04:30:19 <yitz> @go haskell wiki OO
04:30:22 <lambdabot> http://en.wikipedia.org/wiki/O'Haskell
04:30:25 <yitz> nope
04:30:36 <alexeevg> @go type classes vs OO
04:30:41 <lambdabot> http://www.haskell.org/haskellwiki/OOP_vs_type_classes
04:30:41 <lambdabot> Title: OOP vs type classes - HaskellWiki
04:30:46 <yitz> yep
04:31:11 <drdozer> what's the cabal command to unpack a package into the current directory?>
04:31:19 <daf> cabal get
04:31:19 <alexeevg> bastl: but this is kind of more or less advanced stuff, I'd try to go with ADTs and plain functions first
04:31:35 <dcoutts> drdozer: cabal unpack, but it's only in the darcs version atm
04:31:43 <bastl> thanks, that looks good.
04:31:52 <drdozer> thanks - I will do it manually then :D
04:31:55 <daf> oh, get puts it somewhere esle
04:32:07 <dcoutts> daf: there is no 'get'
04:32:19 <daf> ok, never mind me then
04:32:28 * bastl has to transform his way of thinking about data-structures. Did to much OO. Until now ;-)
04:33:07 <alexeevg> bastl: been there, done that. that's why it's recommended to avoid typeclasses and try some basic FP stuff
04:33:31 * alexeevg means, it's recommended for beginner
04:36:12 <akillah> daf: get -> fetch
04:56:18 <nanothief_> @pl \x -> if x == 0 then Nothing else Just (x `mod` 10, x `div` 10)
04:56:19 <lambdabot> ap (flip if' Nothing . (0 ==)) (Just . liftM2 (,) (`mod` 10) (`div` 10))
04:57:50 <ziman> > 0 `divMod` 10
04:57:51 <lambdabot>   (0,0)
04:58:06 <nanothief_> ooh nice
04:58:30 <opqdonut> > 0 `quotRem` 10
04:58:32 <lambdabot>   (0,0)
05:00:19 <loadquo> > 100 `quotRem` 0
05:00:21 <lambdabot>   * Exception: divide by zero
05:00:43 <dublpaws> Every few years an ice storm will take down a bunch of tree limbs, and with them, power to many towns.  If the trees were kept to a strict pruning regiment, the power losses wouldn't be so extensive.  The power companies are lazy.  If they could which branches were going to fall, they could save a lot of money and frustration.
05:00:56 <loadquo> > 100/0
05:00:57 <lambdabot>   Infinity
05:02:48 <nanothief_> thats weird, I though 100 / 0 would be NaN
05:03:09 <loadquo> > 0/100
05:03:10 <lambdabot>   0.0
05:03:23 <loadquo> > sqrt(-1)
05:03:25 <lambdabot>   NaN
05:03:28 <nanothief_> > 0/0
05:03:29 <lambdabot>   NaN
05:04:17 <ziman> > sqrt (-1 :+ 0)
05:04:19 <lambdabot>       precedence parsing error
05:04:19 <lambdabot>          cannot mix prefix `-' [infixl 6] and ...
05:04:34 <dublpaws> @let x = 100/0
05:04:36 <lambdabot>  Defined.
05:04:39 <dublpaws> :t x
05:04:40 <lambdabot>     Ambiguous occurrence `x'
05:04:40 <lambdabot>     It could refer to either `L.x', defined at <local>:33:0
05:04:40 <lambdabot>                           or `SimpleReflect.x', imported from SimpleReflect at /home/cale/.lambdabot/State/L.hs:73:0-32
05:04:47 <loadquo> > sqrt((-1) :+ 0)
05:04:49 <lambdabot>   0.0 :+ 1.0
05:05:20 <loadquo> @type :+
05:05:22 <lambdabot> parse error on input `:+'
05:05:25 <loadquo> @type (:+)
05:05:26 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
05:05:27 <Cale> nanothief_: IEEE floating point is a bit strange.
05:06:00 <ivanm> Cale: does haskell/ghc even fully implement IEEE floating point stuff completely?
05:06:08 <nanothief_> Cale: yeah I don't know the details of IEEE, I was just thinking about it from a mathematical viewpoint
05:06:13 <ivanm> IIRC, someone once said that there were some points it wasn't up to spec...
05:06:22 <quicksilver> I don't think haskell *implements* the IEEE stuff
05:06:30 <quicksilver> it just exposes the underlying IEEE of your platform
05:06:32 <quicksilver> if it has one.
05:06:35 <Cale> right.
05:06:41 <ivanm> nanothief_: from a mathematical viewpoint, forall x, x / 0 is undefined
05:06:48 <ivanm> (except maybe in some complex stuff...)
05:06:50 <quicksilver> (and it doesn't expose all the nitty and gritty either)
05:06:51 <ivanm> quicksilver: *nod*
05:07:02 <Cale> The Haskell standard doesn't explicitly say that floating point numbers have to fit the IEEE spec, but it does provide:
05:07:05 <Cale> :t isIEEE
05:07:06 <lambdabot> forall a. (RealFloat a) => a -> Bool
05:07:13 <ivanm> *nod*
05:07:37 <quicksilver> it is quite consistent to add a point at infinity and define x/0 to be Infinity, for x itself nonzero.
05:07:54 <quicksilver> in fact there is more than one  way to do it, and they can all be seen as consistent in the right frame
05:08:02 <quicksilver> I've got no idea why the IEEE chose what they chose though :)
05:08:10 <Cale> Except that it destroys a lot of the algebraic properties to do that.
05:08:18 <quicksilver> sure.
05:08:21 <ivanm> quicksilver: quite consistent maybe, but it isn't mathematically sound AFAIK
05:08:26 <quicksilver> ivanm: perfectly sound.
05:08:40 <quicksilver> ivanm: projective real geometry, the topology of S1, etc.
05:08:48 <Cale> ivanm: sound isn't quite the word... it's just inelegant from the perspective that it ruins the ring structure.
05:08:49 <quicksilver> it's just a different formal system.
05:08:55 <ivanm> *nod*
05:09:02 <ivanm> quicksilver: OK, the more "basic" math ;-)
05:09:02 <quicksilver> you lose some stuff, you gain some other stuff
05:09:11 <quicksilver> it depends what you're hoping to do :)
05:09:17 <Cale> But extending the complex numbers with an additional point makes other topological and analytic properties nice.
05:09:19 <quicksilver> projective geometry is certainly useful sometimes.
05:09:22 <nanothief_> > -3 / 0
05:09:24 <lambdabot>   -Infinity
05:09:34 <ivanm> Cale: then again, IIRC you can do a complex formulation with _two_ infinities...
05:09:38 <nanothief_> > -3 / -0
05:09:39 <lambdabot>       precedence parsing error
05:09:39 <lambdabot>          cannot mix `(/)' [infixl 7] and prefi...
05:09:44 <bastl> hmm. just read "OOP vs type-classes" wikipage. it deals with implementation specific differences. I want to _design_ my datastructures in terms of type-classes (thinking "programming against interfaces") and i am used to classes (types), interfaces (type-classes) and associations (functions)  (all the ugly UML stuff). How does that translate to haskell? Any interesting pointers to _design_ of such structures ?
05:09:44 <Cale> ivanm: Er, a real one.
05:09:48 <nanothief_> > -3 / (-0)
05:09:50 <lambdabot>   Infinity
05:10:30 <Saizan> bastl: we use abstract types for that
05:10:44 <Saizan> bastl: i.e. types for which the constructors are not exported
05:10:56 <ivanm> Cale: well, -ve inf and +ve inf...
05:10:57 <loadquo> > (1/0) :+ (1/0)
05:10:59 <lambdabot>   Infinity :+ Infinity
05:11:05 <Cale> ivanm: right, with real numbers
05:11:22 <quicksilver> type-classes are not interfaces.
05:11:34 <quicksilver> type-classes are for overloading.
05:11:35 <Saizan> bastl: assuming their internal structure is not semantically relevant like in Data.Set
05:11:36 <bastl> but how do i represent an association between a class and a interface (in java / UML terms) ?
05:11:47 <bastl> Saizan. ok, thats information hiding.
05:11:53 <Cale> ivanm: With complex numbers, you'd either add a single point at infinity, making the complex plane into a sphere, a circle at infinity, making it into a disc, or a projective line at infinity, making it into a projective plane.
05:12:45 <ivanm> Cale: hmmmm.... when I did complex analysis a few years ago, we only covered the point at inf (at briefly discussed having a double inf)
05:12:49 <Saizan> our interfaces are the export lists of modules, we don't have a particularly expressive module system though
05:12:54 <ivanm> not having a circle, disk or line ;-)
05:13:04 <loadquo> > (1 :+ 1) / (0 :+ 0)
05:13:06 <lambdabot>   NaN :+ NaN
05:13:06 <ivanm> bastl: you don't ;-)
05:13:17 <ivanm> since Haskell /= Java (for which we are all grateful!)
05:13:21 <ivanm> @quote kolmodin Java
05:13:22 <lambdabot> No quotes for this person. Do you think like you type?
05:13:25 <ivanm> @quote kolmodin java
05:13:26 <lambdabot> No quotes for this person. I feel much better now.
05:13:29 <ivanm> hmmm....
05:13:35 <ivanm> I could have sworn he had one :s
05:13:56 <ivanm> @quote lennart java
05:13:56 <lambdabot> lennart says: I would rather lose my left arm than write it in Java
05:14:08 <ivanm> maybe it wasn't kolmodin (just thought it was, since his first name is lennart)
05:14:17 <bastl> well we all have types, functions and calculations. the question is how the concepts are implemented in different languages. (and for me how to transfer my OO-Knowledge to haskell ...)
05:14:28 <dublpaws> haskell classes don't have a "data block", it's just methods, and even then, their not implemented, just their type signatures.
05:14:35 <dublpaws> is that right?
05:14:37 <bastl> for me class and interface in java  is the same as type and typeclass in haskell
05:14:49 <quicksilver> dublpaws: haskell has no classes.
05:14:51 <opqdonut> bastl: don't transfer OO-Knowledge to haskell :)
05:14:58 <quicksilver> bastl: well, I'm afraid you are misunderstanding.
05:14:58 <dublpaws> quicksilver: well, typeclasses then
05:15:01 <bastl> classes as modules is a different thing
05:15:01 <opqdonut> bastl: you need to re-learn
05:15:13 <dublpaws> quicksilver: some books call them classes
05:15:27 <quicksilver> dublpaws: I was being pedantic - but for pedagogical reasons.
05:15:33 <bastl> opqdonut: a java-method withoput sideeffects is a pure function
05:15:41 <opqdonut> bastl: it doesn't matter
05:15:43 <Cale> dublpaws: It's best not to think of Haskell classes as being all that related to OO classes at all.
05:15:45 <quicksilver> thinking of haskell typeclasses as being in any way shape or form anything like 'classes' in other langauges, is asking for pain.
05:15:47 <opqdonut> bastl: the concepts just don't map
05:15:54 <dublpaws> but bastl does a disservice to himself to even try to relate themm... what cale said
05:15:56 <opqdonut> bastl: functional design is another design paradigm
05:16:06 <opqdonut> just like oo design
05:16:10 <quicksilver> bastl: a haskell typeclass is a mechanism for overloading.
05:16:13 <opqdonut> you just need to learn it
05:16:23 <quicksilver> bastl: Num - which overloads (+) and various other operations - is a good example.
05:16:26 <Cale> Typeclasses are sort of like Java interfaces, but more expressive.
05:16:35 <quicksilver> a haskell typeclass is not a general abstraction mechanism
05:16:38 <quicksilver> it's a very specific one.
05:16:53 <bastl> Cale: thats the point. and im very used to java interfaces so i want to transfer ...!
05:16:56 <Cale> My favourite typeclass to show beginners is something like:
05:17:03 <nanothief_> maybe haskell classes are more like type safe duck-typing?
05:17:04 <Cale> class MyRead a where
05:17:10 <Cale>   myRead :: String -> a
05:17:38 <Cale> This is a type of polymorphism you don't tend to get in OO languages at all.
05:17:56 <bastl> I understand these things. But how do i _model_ a complex business domain (as an example)
05:18:01 <Saizan> the big difference is that interfaces are types, whicle typeclasses aren't, so you can't use them to "hide" the concrete type you are using
05:18:17 <bastl> Saizan. ah!
05:18:31 <bastl> exactly the problem i ran into
05:18:34 <Saizan> and in FP you usually don't want to hide it
05:18:43 <Saizan> and if you want you use the module system
05:18:55 <Saizan> but only to hide the implementation
05:19:11 <Cale> I'm not altogether sure what constitutes a 'business domain' here.
05:19:16 <lilac> although you can say 'data FooInterface = Foo x => FI x' which converts your typeclass into an interface
05:19:41 <Cale> But usually, we invent libraries which act like little programming languages to express things in our problem domain, and project out solutions to those problems.
05:20:18 <Cale> Come up with a datatype which represents the possible situations, and then functions which give you important information about them.
05:20:35 <Cale> and ways to combine simple situations into more complicated ones
05:21:38 <bastl> hmm, i have to think/meditate about the last statements. Thanks so long :-)
05:21:58 <Cale> Usually the information-extracting functions will be more-or-less recursive -- replacing primitive situations with the solution in that case, and combining solutions when the situations are combinations of simpler ones.
05:22:10 <Cale> That's really vague, I'll admit.
05:25:13 <dublpaws> I think there are two maps of a haskell program, the type graph, A->B->C, and how the data declarations nest.
05:27:27 <loadquo> > 100 `divMod` 0
05:27:28 <lambdabot>   * Exception: divide by zero
05:28:06 <idnar> @type divMod
05:28:08 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
05:28:36 <idnar> @djinn a -> a -> (a, a)
05:28:36 <lambdabot> f a b = (b, a)
05:29:23 <bastl> are there any attempts for visualizing a set of datatypes and their relations (like conversion functions) ?
05:30:31 <MarcWeber> bastl: visualizing? Are you talking about a rolational view which can be found in database forms?
05:30:48 <MarcWeber> bastl: If you find one let me know :-)
05:31:40 <dublpaws> bast < thoughtpolice> dublpaws: also this might interest you - http://hackage.haskell.org/cgi-bin/hackage-scripts/package/SourceGraph
05:32:11 <dublpaws> < thoughtpolice> dublpaws: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/graphmod
05:32:28 <Martijn> How do I define a Show instance for newtype Fix f = In (f (Fix f))
05:32:30 <Martijn> ?
05:32:36 <dublpaws> I think they both require ghc 6.10 bastl
05:32:38 <quicksilver> carefully.
05:33:05 <lilac> Martijn: presumably ghc can't derive one? :)
05:33:44 <Martijn> lilac: yeah :-(
05:33:59 <Cale> bastl: A good example would be, say, recipes. You might say that a recipe is either a basic ingredient, or it's one of a number of things you can do to a recipe that you've already made (whip, chop, stir, etc.), or one of a number of ways of combining other recipes (mix, layer, ...)
05:34:00 <quicksilver> it's been done in this channel, I think
05:34:03 <gio123> @seen Cale
05:34:03 <lambdabot> Cale is in #haskell, #haskell-overflow and #ghc. I last heard Cale speak 4s ago.
05:34:18 <quicksilver> , In (Just (In (Just (In (Nothing)))))
05:34:20 <lunabot>  luna: Not in scope: data constructor `In'
05:34:24 <quicksilver> hmm
05:34:29 <quicksilver> > In (Just (In (Just (In (Nothing)))))
05:34:30 <idnar> @type In
05:34:31 <lambdabot>       No instance for (Show (Mu Maybe))
05:34:31 <lambdabot>        arising from a use of `show' a...
05:34:31 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
05:35:20 <Cale> bastl: Then, you might be interested in the nutritional content of the recipe, and you'd write a function which recurses over the way that it's built up -- basic ingredients would have defined nutritional contents, and then various things you do with them will compose the nutritional content in various ways (usually adding it)
05:35:21 <byorgey> instance (Show (f a)) => Show (Fix f) where show (In x) = "In (" ++ show x ++ ")"  -- something like that??
05:35:37 <lilac> @type let showMu (In x) = "In (" ++ show x ++ ")" in showMu $ In (Just (In (Just (In (Nothing)))))
05:35:38 <lambdabot>     No instance for (Show (Mu Maybe))
05:35:38 <lambdabot>       arising from a use of `showMu' at <interactive>:1:47-52
05:35:38 <lambdabot>     Possible fix: add an instance declaration for (Show (Mu Maybe))
05:36:05 <lilac> @type let showMu (In x) = "In (" ++ show (showMu <$> x) ++ ")" in showMu $ In (Just (In (Just (In (Nothing)))))
05:36:06 <lambdabot> [Char]
05:36:11 <lilac> > let showMu (In x) = "In (" ++ show (showMu <$> x) ++ ")" in showMu $ In (Just (In (Just (In (Nothing)))))
05:36:12 <lambdabot>   "In (Just \"In (Just \\\"In (Nothing)\\\")\")"
05:36:16 <idnar> @type In (Just (In (Just (In (Nothing)))))
05:36:17 <lambdabot> Mu Maybe
05:36:22 <Cale> bastl: Of course, if that's not business-like enough, you can replace recipes with financial contracts, and nutritional content with any of various ways of determining the value of a contract :)
05:36:27 <idnar> uhm
05:36:30 <idnar> @kind Mu Maybe
05:36:30 <byorgey> lilac: ah, there you go
05:36:31 <lambdabot> *
05:36:36 <idnar> @kind Maybe
05:36:37 <lambdabot> * -> *
05:36:42 <idnar> meh
05:36:42 <Cale> bastl: Or perhaps process plans, and something like the total completion time.
05:36:54 <idnar> Mu always makes my head hurt
05:36:56 <quicksilver> well lilac's one adds rather a lot of nested ""
05:37:17 <quicksilver> I'm fairly sure we had a solution which didn't do that.
05:37:32 <Cale> bastl: Does that help at all? :)
05:37:41 <lilac> quicksilver: it wouldn't if it were an actual show instance; i only needed to do that because i needed something within the f which was already showable
05:37:47 <lilac> (and Mu f isn't)
05:37:55 * quicksilver nods
05:38:17 <lilac> byorgey's instance looks fine to me
05:38:56 <skorpan> hey. where does cabal store its information on installed packages?
05:39:08 <Martijn> Hmm
05:39:21 <dcoutts> skorpan: the ghc-pkg database
05:39:30 <Martijn> skorpan: ~/.cabal, ~/.ghc
05:39:30 <yitz> skorpan: it uses ghc-pkg to register them
05:39:54 <skorpan> nothing global?
05:40:11 <yitz> skorpan: by default no
05:40:15 <Martijn> Maybe I can write a show instance that leaves out the In's
05:40:42 <skorpan> can cabal-install "remove" packages?
05:40:48 <lilac> Martijn: show is intended to produce valid Haskell
05:40:59 <Martijn> lilac: Okay, a MyShow instance then
05:41:11 <hackage> Uploaded to hackage: cflp 2009.1.28
05:41:26 <bastl> Cale: sorry, i was AFK for a minute and had to read up. Probably the first answers were correct, i have to relearn. But still ... since the problems are the same, there should be a mapping between the modeling approches (/me is getting vague too :-) )
05:43:06 <yitz> skorpan, dcoutts: hmm, did I get that wrong? on my system at least I see that the default is to install packages globally.
05:43:25 <skorpan> i had a bunch of packages installed globally as well
05:43:35 <Martijn> byorgey: GHC complains about your instance: Could not deduce (Show (f (Fix f))) from the context (Show (Fix f), Show (f a))
05:43:48 <dcoutts> yitz: the default for cabal-install is user installs, for runghc Setup the default is global.
05:44:07 <byorgey> Martijn: hm, interesting
05:44:12 <dcoutts> yitz: the default for cabal-install can be changed via its config file
05:44:23 <lilac> Martijn: weird... Show (f a) => Show (f (Fix f)) surely?
05:44:31 <byorgey> I would have thought that the "Show (f a)" covered "Show (f (Fix f))", but I guess not
05:44:32 <yitz> dcoutts: $ cabal register --help ... --global (default) ...
05:44:42 <Martijn> I'd say so too
05:44:55 <Martijn> I did have to turn on FlexibleContexts, UndecidableInstances
05:45:07 <nothingmuch> 0/w #git
05:45:12 <lilac> actually, it's "Show a => Show (f a)" and "Show (Fix f)" that it has, and it wants "Show (f (Fix f))". this is getting a little close to theorem proving...
05:45:24 <Cale> bastl: Well... there is a mapping of sorts, but it tends to be a little unnatural.
05:45:26 * byorgey goes off to actually try it
05:45:26 <bastl> Calse, Saizan: my specific problem is that i want a generic interface to parsers and ASTs, independet of the concrete language (XML, Java, etc). I want to hide BNFC, HaXML and the like and provide a "good" API to ppl using these. So i started with something like "class Parser a where parse :: FilePath -> AST a", and thought of AST as a generic AST, hiding the concrete implementation.
05:45:45 <Cale> bastl: Especially so when you have deeply nested object hierarchies.
05:45:51 <quicksilver> nominally you need "(forall a . Show a => Show (f a)) => Show (Mu f a)
05:46:00 <quicksilver> which is a higher-ranked context, if you like
05:46:01 <quicksilver> which we can't do.
05:46:10 <quicksilver> however, I'm *sure* we did solve this, a couple of months ago :)
05:46:16 <quicksilver> I just don't remember the answer.
05:46:37 <lilac> quicksilver: how about...
05:46:38 <dcoutts> yitz: oh, that's misleading. The default for register depends on how you configured which is as I described previously.
05:47:09 <skorpan> which packages are included in ghc 6.10.1?
05:47:11 <yitz> dcoutts: I didn't do any configuration, just have the defaults
05:47:24 <skorpan> i seem to have e.g. syb-0.1.0.0, parsec-2.1.0.1... etc.
05:47:56 <byorgey> hah, it actually works if you write "instance (Show (f (Fix f))) => Show (Fix f) where..."
05:48:04 <dcoutts> yitz: I mean whether the configure step is using --user or --global which of course depends on what your default is.
05:48:12 <yitz> ah
05:48:13 <byorgey> I guess that makes sense, since it only looks at the constraint after selecting the instance
05:48:14 <lilac> byorgey: aww :(
05:48:14 <vixey> "In my limited experience with haskell, laziness has only served to bite me in the ass. Give me an eager version of haskell."
05:48:18 * lilac gives up on creative solution
05:48:22 <byorgey> hehe
05:48:35 <byorgey> vixey: who said that?
05:49:04 <lilac> newtype MyString = MyString String; instance Show MyString where show (MyString s) = s; showMu (In x) = "In (" ++ show (MyString . showMu <$> x) ++ ")"
05:49:08 <Saizan> quicksilver, lilac: instance Show (f (Mu f)) => Show (Mu f) where show ..
05:50:03 <Saizan> show (In x) = "In (" ++ show x ++ ")"
05:50:08 <vixey> sorry just looking on reddit
05:50:42 <Martijn> quicksilver, Saizan: yes, that does work. interesting.
05:51:03 * Cale guesses that the reason laziness has only served to bite this person in the ass is that they are still decomposing problems like a programmer used to strict evaluation.
05:51:10 <Martijn> I was trying a class ShowF f where showF :: ShowF g => f g -> String
05:52:20 <ozy`> vixey: heh, what thread?
05:52:34 <Saizan> class ShowF f where showF :: Show a => f a -> String and instance ShowF f => Show (Mu f) where .. will also work, but it's not needed
05:52:44 <yitz> vixey: that makes sense. someone with only limited experience with haskell, and presumably extensive experience with some imperative language, will get bitten if they are obnoxious.
05:53:29 <Saizan> do we have a wikipage on Mu?:)
05:53:55 <Martijn> Saizan: that doesn't work: instance ShowF Fix gives: Expected kind `* -> *', but `Fix' has kind `(* -> *) -> *'
05:54:01 <augustss> vixey: link?
05:54:45 <vixey> http://www.reddit.com/r/programming/comments/7sqew/to_tail_recurse_or_not_part_2_a_follow_up_for/
05:54:48 <Saizan> Martijn: you're not supposed to make Fix an instance of ShowF
05:54:51 <vixey> http://www.reddit.com/r/programming/comments/7sqew/to_tail_recurse_or_not_part_2_a_follow_up_for/c07bgvi
05:55:06 <Martijn> Saizan: Ah... only my ExprF then?
05:55:18 <Saizan> Martijn: yeah
05:55:43 <Saizan> however it's a complication that you don't need
05:55:48 <vixey> http://www.reddit.com/r/types/ blegh
05:55:53 <Martijn> Saizan: okay
05:55:53 <vixey> nothing new in ages
05:56:08 <augustss> Martijn: that class definition doesn't look kind correct.  or maybe i need more coffee
05:56:27 * Martijn doesn't like coffee. :-(
05:57:15 <Saizan> "class ShowF f where showF :: ShowF g => f g -> String" will give you an infinite kind, i think :)
05:57:58 <Martijn> I didn't get that to work, so yeah, you're probably right
05:58:23 <poliquin> I'm trying to dig through "Arrows and Computation" .. Map Transformers have stumped me. Any hints on where I can read more about transformers?
05:58:24 <chessguy> Saizan, http://codepad.org/wiFKTg6C
05:58:26 <augustss> Martijn: you are forcing f and g to have the same kind, so (f g) makes no sense
05:58:55 <mornfall> Is there a cartesian product operator for lists? (Other than the obvious comprehension, that is...)
05:59:03 <vixey> liftA2 (,)
05:59:15 <Martijn> augustss: *nods*
05:59:36 <mornfall> vixey: Oh. Interesting. :)
05:59:53 <augustss> or liftM2 (,)
06:00:12 <Martijn> Nice, now I can finally define my instance Num Expr where newtype Expr = Fix ExprF
06:00:21 <Cale> mornfall: or sequence
06:00:29 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
06:00:31 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
06:00:55 <blackh> @seen dons
06:00:55 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 12h 40m 23s ago.
06:01:02 <mornfall> I like the lift(A/M)2 trick.
06:01:50 <Cale> > liftM2 (==) (length . sequence) (product . map length) [[1,2,3],[4,5],[6,7,8]]
06:01:51 <lambdabot>   True
06:02:13 <Cale> @check liftM2 (==) (length . sequence) (product . map length)
06:02:20 <lambdabot>   mueval: Time limit exceeded
06:02:30 <Cale> expensive thing to test :P
06:03:47 <Martijn> :t sequence
06:03:50 <blackh> I just wrote a nice fast version of that k-nucleotide benchmark on the shootout, and I can't submit it because the website has a bug!
06:03:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
06:04:06 * blackh is looking for sympathy
06:04:15 <Martijn> That almost looks like a join. Almost.
06:04:36 <Cale> Martijn: in the database sense?
06:04:39 <SamB_XP> @scheck liftM2 (==) (length . sequence) (product . map length)
06:04:39 * byorgey pets blackh sympathetically
06:04:45 <Martijn> Cale: No, in the monad sense
06:04:47 <lambdabot>   mueval: Time limit exceeded
06:04:51 <Martijn> I wonder if sequence can abstract over []
06:05:01 <Cale> ah, it's more of a distributive law in the monad sense :)
06:05:01 <vixey> sequence . toList
06:05:14 <Cale> almost...
06:05:34 <Cale> I think it probably fails one of the axioms for a distributive law
06:05:35 <Saizan> ?type Data.Traversable.sequence
06:05:38 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => t (m a) -> m (t a)
06:06:03 <Martijn> sequence :: ([] . m) a -> (m . []) a
06:06:13 <quicksilver> distributive laws are just commutative laws viewed from 90 degrees
06:07:06 <vixey> #  play tetris free says:
06:07:07 <vixey> December 4th, 2008 at 3:09 am
06:07:07 <vixey> I really like tetris, I waiste all of my time at work playing it.
06:07:20 <Cale> quicksilver: :)
06:07:29 <vixey> is that a joke or somithing? how weird is that comment
06:07:47 <blackh> Does anyone here have a login on GFORGE?
06:07:51 <Cale> I particularly like the spelling 'waiste'
06:08:21 <blackh> If so you will help me make Haskell look faster in the programming language shootout!
06:10:26 <smtms> blackh, isn't gforge a generic sourceforge that can be installed on any site?
06:11:07 <blackh> smtms: Ah - you know more than I do.  It's alioth.debian.org I'm talking about.
06:13:54 <blackh> Ah - the problem turned out to be between the screen and the chair.
06:14:42 <smtms> blackh, shall we replace the failing part? :-)
06:15:00 <skorpan> hey. having trouble installing xmonad-contrib from cabal: http://pastebin.com/d7ff268c .. exactly what is pkg-config?
06:15:11 <blackh> smtms: I think that would definitely help.
06:15:56 <dcoutts> skorpan: it's a utility program used to discover the configuration of C libraries
06:16:15 <dcoutts> skorpan: it should be packaged for your distro
06:16:42 <skorpan> i wonder in which package though...
06:16:50 <dcoutts> probably pkg-config :-)
06:17:09 <skorpan> oh, it's "pkgconfig" without the dash
06:18:02 <true\false> $ is a replacement for parenthis?
06:18:03 <lunabot>  luna: Not in scope: `is'
06:18:16 <skorpan> true\false: you can think of it like that, yes
06:18:24 <true\false> All I need for now, ta
06:23:39 <mmorrow> this might be useful http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1007#a1007
06:23:57 <hugo___> ouch
06:24:24 <mmorrow> it uses TH to generate a .c, build it with gcc, capture and parse the output to TH, and return ExpQ's for #define'd C constants
06:24:29 <mmorrow> (at compile-time)
06:24:48 <hugo___> i have been checking the MA thesis from my univ. it saddens me that there are quite a few of them completly useless :(
06:25:15 <hugo___> "Opengl vs Direct3d, what future?" :(
06:25:29 <Martijn> hugo___: which uni is that?
06:25:50 <hugo___> ist
06:25:51 <hugo___> http://www.ist.utl.pt/
06:27:01 <hugo___> how can someone make a MA with a thesis like "Opengl vs Direct3d, what future?" :-/
06:27:13 <hugo___> bahhh
06:27:46 <hugo___> it looks like one of those articles from pc-answers magazine
06:27:49 <Martijn> hugo___: here's your chance to write something awesome :-)
06:28:13 <nothingmuch> screw that, start an ma program on starcraft
06:28:19 <hugo___> well that is not mine...
06:28:20 <hugo___> yeh
06:30:22 <yottis> is that computer science or what? MA sounds sort of humanistic to me
06:31:15 <Martijn> MA is masters
06:31:16 <hugo___> no i say ma, but it writes like "MsC" or whatever
06:31:17 <hugo___> i dont know
06:31:39 <hugo___> i can't translate properly to english
06:31:45 <yottis> ach ok
06:31:59 <hugo___> yeh, its like master thesis
06:32:06 <Martijn> and MSc = master of science
06:32:57 <arjanb> it happens everywhere, keeping student numbers up seems more important than quality :/
06:32:57 <hugo___> academic world is quite ugly
06:33:15 <yottis> in here (finland) half the university is "master of philosophy" due to historical reasons, but i think they're translated to english depending from which faculty your major is
06:33:21 <yitz> at some unis, mathematics is part of arts, and cs is together with mathematics, so the degree is actually an MA.
06:33:29 <hugo___> yeh, univ. actually compete for who publishes more papers!
06:33:59 <zachk> so many schools in upstate new york are just java for comp sci i have changed to just math :-D
06:34:13 <hugo___> hehe
06:34:38 <vixey> you are doing math because you don't like java
06:34:43 <vixey> you are not doing math because you like math?
06:34:56 <zachk> i was comp sci and math im just dropping the comp sci
06:35:29 <zachk> id rather teach people algebra then work in a cubicle coding java
06:35:57 <hugo___> they should rename the graduation here to "Java/C#/Paper engineering"
06:36:04 <hugo___> nice zachk
06:36:15 <zachk> i feel ya man
06:36:24 <hugo___> i'm also doing some algebra explanations to 1st year students, it pays good
06:36:41 <hugo___> and feels good when they pass with good grades
06:36:50 <Martijn> teaching rocks
06:37:25 <mmorrow> zachk: the nice thing about math is that you can pick up most other tech things again after you graduate, but i think the opposite would be harder
06:37:30 <zachk> i am still interested in comp sci, just not java
06:37:34 <ozy`> "If you want to see more indications of activity in the Haskell world, drop by the #haskell irc channel on irc.freenode.net. The channel averages 170 users or so." <== LtU comment from march 2006
06:37:57 * ozy` looks up at the over-600 users in the channel now
06:38:01 <yottis> luckily we have this distinction that what is actually called a university only teaches abstractish stuff and is above teaching anything that might be useful, and then there are "high schools" (translated to universities also in english) that are more focused on the real world
06:38:45 <mmorrow> is learning about the real world stuff what the real world's for? ;)
06:39:00 <hugo___> eh
06:39:05 <ozy`> mmorrow: learning about the real world is what economic depressions are for.
06:39:09 <hugo___> it depends on where you will work, and who will be your boss
06:39:09 <zachk> the real world isnt so real
06:39:21 <stevan> hi, is it possible to implement fromList :: [a] -> Vec n a, where Vec is Nil :: Vec Zero a and Cons :: a -> Vec n a -> Vec (Succ n) a    somehow? the straight forward way doesn't work, because n in the resulting Vec depends on the input... is there any trick to get around this? thanks.
06:39:32 <vixey> zachk, btw I think 'java' is a red herring
06:39:34 <BONUS> yottis: we have that too. my uni is mostly about getting to know the theory behind stuff. it's easy to practice on concrete examples in your own time
06:39:49 <vixey> zachk, people could screw up teaching CS and turn it into a complete joke regardless of what language they use
06:39:55 <mmorrow> zachk, hugo___: suck it up, work for yourself, only code in haskell, profit!
06:40:12 <hugo___> mmorrow: haskell and profit usually dont go along
06:40:13 <vixey> stevan, you can implement  fromList :: [a] -> n -> Maybe (Vec n a)
06:40:21 <yottis> i think the idea is to panic if something is too close to the real world, because then it must be normal people stuff and not academic enough
06:40:27 <zachk> vixey: forgive my ignorance, but what is a "red herring"?
06:40:29 <mmorrow> hugo___: that kind of attitude will get you knowhere :)
06:40:39 <BONUS> i rly like math but i can't say i'm very good at it. going to work on that though
06:40:48 <hugo___> mmorrow: i guess you're right...
06:41:06 <vixey> zachk, I mean there are better reasons to hate the way CS is taught than "because they used a language I don't like"
06:41:09 <hugo___> mmorrow: so i should quit my job, and only work in haskell, by myself ?
06:41:11 <hackage> Uploaded to hackage: stm-io-hooks 0.1.0
06:41:19 <mmorrow> hugo___: well you need a plan
06:41:27 <yottis> though then we also have something that could be translated to "profession high school" that's less academic than "high school"
06:41:38 <yottis> i'm pretty sure all of these are translated into plain "university" in english
06:41:51 <quicksilver> stevan: You can manage something like Cons :: (PlusOne n m) => a -> Vec n a -> Vec m a
06:42:00 <hugo___> mmorrow: got any that you can spare ?
06:42:18 <quicksilver> stevan: there are various other tricks. oleg discusses some of them
06:42:23 <ozy`> hugo___: dude, I don't know if you see it this way but to me it looks like mmorrow was talking about designing bridges and you just said "so you mean I should jump off a bridge?"
06:42:38 <hugo___> ozy`: heheh :D
06:42:40 <yottis> bonus, yes but the thing is that most people don't spend all nights and weekends on the applications
06:42:47 <hugo___> okey, enough about this trolling
06:42:59 <mmorrow> hugo___: i don't have spare plans, but i'm sure you could come up with one if you really want it
06:43:40 <hugo___> ok
06:46:13 <stevan> vixey: are you sure? what would the first n there be? a data Nat = Zero | Succ Nat? the empty data declarations: data Zero and data Succ n are not pattern-matchable?
06:46:22 <stevan> quicksilver: thanks, do you remember the name of that discussion / paper?
06:46:44 <vixey> stevan:  fromlist "abc" (undefined :: Succ (Succ (Succ Zero))) ~> Just (Cons 'a' (Cons ...
06:46:56 <vixey> stevan, actually nvm that is impossible
06:47:00 <vixey> stevan, but you can do,
06:47:00 <quicksilver> stevan: e.g. http://okmij.org/ftp/Haskell/number-parameterized-types.html
06:47:05 <vixey> data N n where
06:47:08 <vixey>  Z :: N Zero
06:47:16 <vixey>  S :: N n -> N (Succ n)
06:47:25 <vixey> stevan, and then  fromList :: [a] -> N n -> Vec a n
06:47:28 <PeakerWork> is there a good C parser in hackage? Something that gets me an AST real easy?
06:47:49 <vixey> (because you have to tear down the type level numeral by getting at the values, when you cons up the vector)
06:47:57 <quicksilver> PeakerWork: yes, I recall that there is.
06:48:19 <bastl> PeakerWork: bnfc
06:48:22 <PeakerWork> can "cabal list" find who provides Language.C?
06:48:24 <PeakerWork> bastl: thanks
06:48:49 <PeakerWork> bastl: its not on hackage I suppose (cabal list can't find it)
06:48:52 <bastl> which is a parser generator but there is a c grammar as an example
06:49:00 <bastl> @go bnfc
06:49:08 <bastl> hm
06:49:11 <dcoutts_> PeakerWork: not at the moment. If you'd like to help implement it I can tell you the ticekts to look at. btw, It's language-c that provides Language.c
06:49:17 <lambdabot> Plugin `search' failed with: thread killed
06:49:18 <bastl> http://www.cs.chalmers.se/Cs/Research/Language-technology/BNFC/
06:49:27 <vixey> stevan, (but I haven't found this sort of thing to actually work well in practice)
06:49:37 <PeakerWork> dcoutts_: thanks
06:50:26 <vixey> that is Vec and similar
06:50:39 <bastl> are there attempts to get bnfc into hackage?
06:51:22 <shapr> bastl: Try it!
06:52:22 <bastl> shapr: what? prepare it for upload to hackage?
06:52:27 <shapr> Sure, why not?
06:52:52 <bastl> shapr: why?
06:53:09 <shapr> bastl: Well, you asked about it, so I assume you'd be interested in such an occurence?
06:53:20 <bastl> hmm. sounds like a bot imho
06:53:48 <shapr> nej, jag aer INTE en baat.
06:53:52 * shapr has a hissy fit
06:54:08 <bastl> ok :-)
06:54:17 <bastl> you were too fast ...
06:54:20 * shapr throws lambdas at bastl 
06:54:25 <shapr> Just because I can TYPE!
06:54:33 <shapr> shee
06:54:37 <shapr> z
06:54:38 <bastl> type safe , hm?
06:54:45 <shapr> Well, quickly, if nothing else.
06:54:46 <quicksilver> shapr represents the pinnacle of scannedinavian bot technology
06:54:49 <shapr> yarr!
06:54:53 <shapr> @arr
06:54:54 <lambdabot> Drink up, me 'earties
06:54:59 <quicksilver> with non-optional pirate module
06:55:02 <shapr> EXACTLY!
06:55:09 <yitz> @vixen are you a bot?
06:55:09 <lambdabot> no, why? do i seem "botty"?
06:55:26 <shapr> hej Eleanore, hur mår du?
06:55:34 <vegai> vixen is disturbingly clever sometimes
06:55:38 <shapr> truly
06:55:57 <Martijn> Do vixen and vixen have to do anything with each other?
06:56:08 <shapr> bastl: So, back to the subject at hand... if you would like to see bnfc on hackage, why not go ahead and upload it?
06:56:23 <shapr> Martijn: Probably so. But if you meant vixey and vixen, then no.
06:56:37 <shapr> Man, I always get accused of being a bot.
06:56:45 * quicksilver thinks vixen and vixey have lots in common.
06:56:49 <quicksilver> Four letters, to be precise.
06:56:56 <quicksilver> (80%)
06:57:02 <Martijn> shapr: ah yes, that's what i meant. silly me.
06:57:10 <quicksilver> I get accussed of being a bot too.
06:57:13 <skorpan> shapr: where did you learn swedish?
06:57:15 <quicksilver> I don't waste time denying it though.
06:57:24 <yitz> quicksilver: you don't type well enough
06:57:49 <quicksilver> bots can have spelling mistakes programmed in.
06:57:57 <quicksilver> @vixen do you ever make typos?
06:57:57 <lambdabot> maybe. do you?
06:58:00 <bastl> shapr: true, but i think it should be done by the maintainers ...
06:58:05 <Martijn> Type inference for newtype (f :. g) a = Comp (f (g a)) is just plain weird
06:58:18 <yitz> if quicksilver used shapr for typing, they would pass the inverse turing test
06:58:25 <shapr> skorpan: Where do you think I learned Swedish? I keep saying stuff like "Ska vi fära?" instead of ska vi gå
06:58:34 <shapr> yitz: Wait, what's the inverse turing test?
06:58:37 <quicksilver> i tried to use shapr but he charges too much.
06:58:45 * shapr snickers
06:58:59 <shapr> bastl: Isn't bnfs by Ranta and Hughes?
06:59:02 <shapr> er, bnfc
06:59:08 <shapr> Bah, spelling mistakes already!
06:59:14 <yitz> shapr: you would be indistinguishable from a bot
06:59:20 <shapr> heh
06:59:43 <bastl> shapr: was that your "humanizer"-filter?
07:00:14 <bastl> shapr: by Björn Bringert, Markus Forsberg, and Aarne Ranta
07:00:33 <bastl> just wondered since there is already a debian package
07:00:50 <PeakerWork> hmm.. the AST Language.C returns has no Show instance.. so much harder to toy with an API that has no Show
07:02:02 <quicksilver> PeakerWork: *hear* *hear*
07:02:15 <quicksilver> PeakerWork: I made this exact complaint to malcolmw about HaXML
07:02:22 <quicksilver> evidently not everyone programs the way I do
07:02:25 <quicksilver> (exploring stuff in ghci)
07:02:44 <Martijn> Comp $ (True, (True, True)) :: (:.) ((,) Bool) ((,) Bool) Bool
07:04:33 <paper_cc> , src '':.
07:04:34 <lunabot>  luna: parse error on input `:.'
07:04:40 <bastl> I still dont get the clue: How should i write a good typeclass for "parse :: File -> AST" where both File and AST are somehow typed over the respective language.
07:05:25 <Workybob> bastl: class AST a where { parse :: String -> a }
07:05:26 <Workybob> ?
07:05:40 <shapr> bah humbug
07:05:43 <shapr> What did I miss?
07:06:17 <Workybob> quicksilver used unsafePerformIO launchMissiles and Isreal disapeared
07:06:47 <Cale> bastl: What operations does a general AST have?
07:07:06 <shapr> uhoh
07:07:26 <bastl> not yet sure: just want to access or navigate all elements of the tree
07:07:42 <Workybob> which reminds me... did we ever get as far as voting on a new Haskell logo?
07:07:53 <Cale> bastl: Okay, so it's a tree for certain? :)
07:08:16 <shapr> Workybob: I dunno, why don't you volunteer to organize that effort?
07:08:47 <bastl> probably...
07:08:51 <Workybob> shapr: conflict of interests – I'd organise a voting scheme that gave all logos involving missiles an insurmountable lead
07:08:53 <Workybob> http://www.haskell.org/haskellwiki/Image:UnsafeHaskell.png
07:08:59 <vixey> Martijn, about type inference
07:09:02 <shapr> hehe
07:09:26 <shapr> Workybob: You could always write a chunk of Haskell to take votes, and if someone complains that it could be improved, solicit patches.
07:09:28 <Cale> bastl: If you can say nothing about the actual structure of the thing (not even that it's a tree), then you're just looking for a general interface to parsers.
07:09:28 <vixey> Martijn, things like  F x y z  will match with   f x y z,  but you can't match  f x y z  with  x -> y -> z  :(
07:09:32 <shapr> That sort of thing has worked for me in the past.
07:09:51 <bastl> lets assume its a tree :-)
07:09:55 <Cale> bastl: Which is something that's at least crudely provided by the read class.
07:10:04 <Cale> Read class, rather
07:10:58 <Cale> (then again, perhaps you'd want a similar, but separate class for your ASTs, given that Read is typically used to parse data structures in the format that they'd be directly typed into a Haskell program)
07:12:25 <loadquo>  /msg lambdabot > trace "hi" (+) 1 1
07:12:41 <loadquo>  /msg lambdabot > (+) 1 1
07:12:42 * shapr boings randomly
07:12:43 <bastl> Cale: yes and i though of something like: class Parseble a where { parse :: a -> AST b }, but thats not valid
07:12:49 <shapr> skorpan: So, where do you think I learned Swedish?
07:13:03 <Cale> bastl: Oh, perhaps you want b as a second type parameter to your typeclass.
07:13:20 <bastl> oh
07:13:27 <Cale> bastl: Probably also along with a functional dependency, if the type 'a' is supposed to uniquely determine 'b'
07:13:30 <vixey> Switzerland and Sweden
07:13:48 <shapr> vixey: Don't they speak German in Switzerland?
07:13:48 <Cale> class Parseable a b | a -> b where { parse :: a -> AST b }
07:13:51 <zachk> man i gave in. first cigarette of the day and boy does my body feel like shit after it
07:13:57 <vixey> I don't know
07:14:03 <bastl> Cale: yep. thats it
07:14:04 <shapr> zachk: Sucker... I have the patch.
07:14:13 <bastl> sorry i couldnt express myself better.
07:14:17 <Cale> Or, using the new TypeFamilies extension, it would look like this:
07:14:21 <zachk> patch feels like a drug to me
07:14:23 <vixey> zachk, on the bright side, smoking is pretty cool!
07:14:32 <shapr> zachk: PS. That subject is more on topic on #haskell-blah
07:14:43 <bastl> tension rises
07:14:44 <Cale> class Parseable a where type AST a; parse :: a -> AST a
07:15:03 <vixey> Cale, (why ?)
07:15:18 <Cale> Well, that's not quite equivalent.
07:15:23 <Cale> It's more general actually.
07:15:42 <vixey> is so you can parse from a string or byte string and the result has got bits of strings or bits of bytestrings in it depending
07:15:43 <vixey> ?
07:15:45 <Cale> To be directly equivalent, it would be:
07:16:35 <Cale> oh, yeah, there's a bit of a problem with this -- we're basing the parser on the type of its input here.
07:16:48 <vixey> I wonder why
07:16:50 <bastl> what does "type AST a;" do?
07:16:56 <Cale> Yes, that's unnecessary.
07:17:24 <Cale> bastl: It means there's a type (AST a) which is associated to the type a, and defined by each instance.
07:17:51 <Cale> bastl: Where's the string input in this picture though? :)
07:18:19 <bastl> just escaping haskell code from irc blah ...
07:18:35 <chessguy_work> @hoogle (<$)
07:18:35 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
07:18:35 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
07:18:35 <lambdabot> Text.ParserCombinators.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
07:19:46 <Cale> vixey: I was thinking the 'a' is perhaps a phantom type parameter here.
07:20:14 <Cale> vixey: Or maybe we're newtyping the input...
07:20:22 <Martijn> @vixen you're not very good.
07:20:22 <lambdabot> thanks, i do my best to be good
07:20:30 <Cale> ...
07:20:43 <vixey> ?vixey You could just learn ML if you want eager evaluation.
07:20:43 <lambdabot> oh, but only if, right?
07:21:05 <Cale> bastl: Perhaps it would help focus things if you give an example of what we're trying to abstract over (or better yet, two examples)
07:21:32 <Cale> Where's the repetition of code which we're trying to remove?
07:21:50 <chessguy_work> @vixen do you want eager evaluation?
07:21:50 <lambdabot> yes, and i always get what i want
07:22:49 <vixey> hehe
07:23:02 <ehird> @vixen what is 2+2
07:23:02 <lambdabot> why are you giving me a math test?
07:23:11 <ehird> ... Creepily accurate.
07:23:12 <icqn> @src enclose
07:23:12 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
07:23:20 <ehird> @vixen is the answer to this question no?
07:23:21 <lambdabot> what was the question again?
07:23:24 <ehird> :|
07:23:28 <ehird> how does @vixen work?
07:23:59 <shapr> ehird: @go vixenlove
07:24:00 <bastl> Its more about a general interface or API to a number of parsers. Ultimate goal is to get a DSL to analyse and resolve inconsistencies in software projects (cross language, e.g. a java classname occuring in a xml-configuration file.
07:25:08 <bastl> Cale: so assume i want a unified interface to the java parser i obtained by BNFC and a XML-parser by haxml
07:25:24 <ehird> http://code.haskell.org/lambdabot/Plugin/Vixen.hs
07:25:42 <chessguy_work> ehird, http://code.haskell.org/lambdabot/Plugin/Vixen.hs
07:25:48 <Cale> bastl: Okay. So what do they have in common? They both take strings and turn them into *something*.
07:25:51 <ehird> I just linked to that, chessguy_work
07:25:59 <bastl> Cale: trees
07:26:01 <chessguy_work> bah
07:26:03 <vixey> shapr how goes kata ?
07:26:09 <vixey> if it is being worked on
07:26:29 <Cale> bastl: Okay, should we agree on a tree type? data Tree a = Branch a [Tree a] perhaps?
07:26:29 <shapr> I haven't done anything with it lately, I've been spending my spare time doing capoeira instead.
07:26:41 <bastl> ok
07:26:52 <malcolmw> bastl: the thing is, all functional data is basically trees, in one shape or another.
07:26:52 <lambdabot> malcolmw: You have 1 new message. '/msg lambdabot @messages' to read it.
07:27:03 <Cale> right.
07:27:04 <vixey> oo cool
07:27:14 <Cale> (well, nearly so...)
07:27:24 <chessguy_work> @palomer
07:27:24 <lambdabot> Learning vim is pointless
07:27:48 <chessguy_work> @stewie
07:27:48 <lambdabot> Unknown command, try @list
07:27:49 <Cale> There are some primitive things like arrays, which aren't directly trees, but close enough.
07:28:16 <Cale> (and you might argue that after abstraction, sets and maps aren't trees anymore, though they're implemented with them)
07:28:38 <Cale> Oh, and functions, of course :)
07:28:48 <chessguy_work> @brain
07:28:48 <lambdabot> Well, I think so Brain, but what if we stick to the seat covers?
07:28:59 <bastl> yeah and thats confusing me. :-) i see the haskell term for my is a tree but still its hard to extract information. i have to write a lot of functions to access inner values. so i'd like to unify that as far as possible
07:29:09 <malcolmw> bastl: the question is only how much of the specific structure of any particular datatype do you want to erase, and replace with a generic (untyped) tree
07:29:16 <bastl> for my *ast* is ...
07:29:30 <bastl> true, malcolmw
07:30:07 <Cale> So maybe the problem has nothing to do with parsing at all, but is more about what makes some type into an AST?
07:30:08 <bastl> id to have a standard tree, but the nodes should carry their type information with them ...
07:30:33 <vixey> bastl, for type inference
07:30:35 <vixey> ?
07:30:52 <vixey> or checkng
07:31:00 <Cale> (perhaps all you need to specify is the function which turns the type into a generic Tree?)
07:31:04 <bastl> vixey: how do the tree constructors look like then?
07:31:21 <vixey> I don't know, I'm asking to try and gauge what you are doing exactly
07:31:43 <vixey> actually:
07:31:56 <vixey> bastly, what sort of stuff are you doing with the AST ?
07:33:10 <malcolmw> class TreeLike a where { parse :: Parser String a;  nodeType :: a -> Type;  children :: TreeLike b => a -> [b]; }
07:33:41 <dublpaws> haskell job trends: http://www.indeed.com/jobtrends?q=+haskell&l=
07:34:15 <Cale> malcolmw: Is that an existential?
07:34:29 <malcolmw> Cale: something like that, I'm not being too precise
07:34:29 <chessguy_work> dublpaws, i doubt that's accurate
07:34:41 <bastl> malcomw: that looks good.
07:35:02 <chessguy_work> dublpaws, or at least, i doubt it means what you think it means: http://www.indeed.com/jobs?q=+haskell&l=
07:35:35 <Cale> Or how about just   class Treelike a where type Element a; tree :: a -> Tree (Element a)
07:36:02 <Cale> Or equivalently,  class Treelike a b | a -> b where tree :: a -> Tree b
07:36:11 <malcolmw> in some respects, the TreeLike class is just Uniplate (or Biplate) with an added parser.
07:36:12 <dublpaws> haskell job trends: http://www.indeed.com/jobtrends?q=haskell+programming&l=
07:36:14 <bastl> last question for today: how do i get the Type of a value (as a value, if you know what i mean :-) )
07:36:35 <Cale> bastl: Well, it doesn't normally exist at runtime.
07:36:46 <Cale> bastl: Types are normally erased by compilation.
07:36:56 <vixey> normally ?
07:37:06 <chessguy_work> hmm. http://www.haskell.org/haskellwiki/Hitchhikers_Guide_to_the_Haskell
07:37:07 <Cale> bastl: However, there's some typeclass trickery in the libraries which you can use to restore this information.
07:37:07 <vixey> what cases aren't they .., I guess it's because of typeclasses ?
07:37:12 <Cale> :t typeOf
07:37:13 <lambdabot> forall a. (Typeable a) => a -> TypeRep
07:37:39 <Cale> (it only works for Typeable types, which is basically everything)
07:37:55 <Cale> > typeOf (5 :: Integer)
07:37:56 <lambdabot>   Integer
07:38:09 <bastl> :info Type
07:38:11 <Cale> However, not for polymorphic types.
07:38:18 <Cale> > typeOf (5 :: (Num a) => a)
07:38:19 <lambdabot>   Integer
07:38:28 <Gracenotes> -.-
07:38:29 <Cale> You get defaulting in that case ;)
07:38:34 <alexeevg> > typeOf id
07:38:34 <Martijn> > typeOf typeOf
07:38:36 <lambdabot>   Add a type signature
07:38:36 <lambdabot>   Add a type signature
07:38:42 <Gracenotes> denied!
07:38:55 <Cale> > typeOf (id :: Integer -> Integer)
07:38:57 <lambdabot>   Integer -> Integer
07:39:04 <Gracenotes> @type typeOf
07:39:05 <lambdabot> forall a. (Typeable a) => a -> TypeRep
07:39:34 <Gracenotes> > let o = (o :: String -> Int) in typeOf o
07:39:35 <lambdabot>   [Char] -> Int
07:39:44 <bastl> in malcomws typeclass there was the Type type. is that the same as TypeRep?
07:39:51 <Cale> But it's rare to actually need this information. You should usually know before compiling what the type of anything is.
07:40:15 <Cale> bastl: No, it'd be the type representation for your given language.
07:40:23 <Cale> (not necessarily Haskell)
07:40:37 <vixey> I tried to define a GADT for haskells type system
07:40:49 <vixey> something like,   INT :->: BOOL :: Type (Int -> Bool)
07:41:02 <chessguy_work> > v
07:41:03 <lambdabot>   v
07:41:07 <chessguy_work> @type v
07:41:08 <lambdabot> Expr
07:41:17 <vixey> but I think it's impossible to represent quantifiers
07:41:24 <redditbot> Learning to Reason in Haskell, Part 1
07:41:28 <vixey> like,   ? :: Type (forall a. a -> a -> a)
07:41:47 <vixey> because  _ -> _ -> _  isn't in the form  f :: * -> * -> *
07:42:24 <vixey> it seems a shame to me.. it would be fixed by adding type lambda, but if you added type lambda type inference (and checking of GADT using functions) would require HOU
07:42:36 <Cale> vixey: It would require an Oleg or two to ensure that the variables are bound.
07:42:37 <bastl> ok, thanks alot for today, quite interesting conversations ...
07:42:42 <bastl> gtg now.
07:43:05 <vixey> Cale, I have only one Oleg, so I got like,
07:43:18 <vixey>  FORALL1 :: forall t. (TYPE x -> TYPE (t x)) -> TYPE (forall x. t x)
07:43:18 <vixey>  FORALL2 :: forall t. (TYPE x -> TYPE (t x x)) -> TYPE (forall x. t x x)
07:43:29 <vixey> so you can do  FORALL2 (\a -> a :->: a)
07:43:37 <vixey> which has type  Type (forall a. a -> a)
07:43:50 <vixey> but you can't express  (forall a. a -> a -> a)  or anything like that sadly
07:43:53 <Cale> oh, also, you're reflecting the whole type
07:43:58 <vixey> (or maybe it is possible! but I haven't found any way)
07:44:24 <vixey> Cale, the idea was to write:   djinn :: Type a -> Maybe a
07:44:26 <Cale> It would perhaps be easier just to represent Haskell's type system only up to ensuring kind-correctness, rather than reflecting the actual type
07:44:34 <Cale> ah
07:44:43 <Cale> I think Oleg actually *did* do that
07:44:51 <Cale> and I don't think he even needed GADTs
07:44:54 <vixey> Cale, yeah but he uses typeclasses
07:44:58 <Cale> right...
07:45:30 <vixey> anyway I gave up on it because I couldn't figure out quanifiers
07:45:35 <bastl> dublpaws: http://www.indeed.com/jobtrends?q=functional+programming seems more promising
07:45:42 <bastl> bye now
07:48:08 <chessguy_work> @where+ v http://tunes.org/~nef/logs/haskell/06.04.09
07:48:08 <lambdabot> It is forever etched in my memory.
07:48:25 <chessguy_work> very amusing reading :)
07:48:29 <augustss> vixey: anything using type classes can be encoded without
07:48:57 <lilac> chessguy_work: which time range?
07:49:24 <Gracenotes> chessguy_work: a 24-hour-long conversation? ;)
07:49:32 <chessguy_work> starting about 11:25
07:51:27 <lilac> haha
07:51:47 <lilac> lambdabot's doing 'let v = show <expr> in v' or something isn't it?
07:52:06 <chessguy_work> it's finally explained by dons at around 17:10
07:52:26 <vixey> augustss, why?
07:52:48 <augustss> vixey: because you can pass the dictionaries yourself
07:53:04 <augustss> vixey: you might need rank 2 polymorphism
07:53:40 <lilac> chessguy_work: i'm half expecting someone to write:
07:53:48 <lilac> > 0:1:zipWith (+) v (tail v)
07:53:49 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
07:54:57 <Gracenotes> > Right v
07:54:59 <lambdabot>   Right v
07:55:09 <Gracenotes> ah... to avoid confusion :)
07:56:26 <chessguy_work> first recorded log entry in #haskell history (at least on tunes): "08:06:47 <esap> Whoa, ghc-6.2 supports the arrow notation"
07:56:59 <vixey> http://okmij.org/ftp/Haskell/de-typechecker.lhs
07:57:10 <vixey> I don't even see how he handles forall quantifiers
07:57:47 <lilac> he's oleg. forall quantifiers handle him
08:00:06 <vixey> oh I guess Olegs code doesn't handles forall quantifiers
08:01:57 <lilac> chessguy_work: sjanssen gets it at 12:42:48
08:02:26 <chessguy_work> yeah
08:02:29 <chessguy_work> or something :)
08:02:44 <alexeevg> yes it seems he handles only rank-1 polymorphic functions
08:03:01 <lilac> chessguy_work: explained fully at 12:51:48
08:03:25 <chessguy_work> @v
08:03:25 <lambdabot> Just 'J'
08:03:30 <chessguy_work> > Just 'J'
08:03:31 <lambdabot>   Just 'J'
08:03:40 <chessguy_work> @help v
08:03:40 <lambdabot> let v = show v in v
08:03:41 <jkff> Hi folks. What's the best way to parse a big logfile (20-30Gb)? IterateeM? Lazy bytestrings? Something else? I want the thing to be as fast as possible and I also want it to be un-gzippable (again,for speed; t.i. I should be able to unzip the file with zlib on-line before sticking into my parser without too much effort)
08:03:46 <vixey> > show (Just 'J')
08:03:48 <lambdabot>   "Just 'J'"
08:03:53 <vixey> > head . show (Just 'J')
08:03:54 <lambdabot>   Couldn't match expected type `a -> [a1]'
08:04:01 <vixey> > (head . show . Just) 'J'
08:04:03 <lambdabot>   'J'
08:04:11 <vixey> > fix (head . show . Just)
08:04:13 <lambdabot>   'J'
08:04:15 <chessguy_work> @v
08:04:15 <lambdabot> "\"#$%&'()*+,\""
08:04:27 <vixey> > fix (fromJust . head . show)
08:04:29 <lambdabot>   Couldn't match expected type `Maybe a' against inferred type `Char'
08:04:37 <vixey> > fix (head . show . fromJust)
08:04:39 <lambdabot>   Couldn't match expected type `Maybe a' against inferred type `Char'
08:04:40 <chessguy_work> > let v - show v in v
08:04:42 <lambdabot>   <no location info>: parse error on input `in'
08:04:45 <chessguy_work> > let v = show v in v
08:04:47 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
08:05:02 <vixey> > fix (listToMaybe . show)
08:05:04 <lambdabot>   * Exception: stack overflow
08:05:12 <lilac> > let v = show ("0\n1\n" ++ (unlines . map show $ zipWith (+) (map read $ lines v) (map read . tail $ lines v))) in v
08:05:14 <lambdabot>   "\"0\\n1\\n* Exception: stack overflow
08:05:47 <jkff> By the way I wonder, why there isn't an iteratee package on hackage, and also no corresponding kind of parsec
08:06:19 <alexeevg> jkff: I guess no-one uploaded it :)
08:06:21 <jkff> My general question is: Is lazy IO as bad as it is, even for a one-pass parse of a huge file?
08:06:48 <vixey> yes
08:07:04 <jkff> vixey: Why so?
08:07:30 <jkff> I'm not going to run out of handles or something, I don't care at all about closing the file
08:08:06 <dublpaws> "In music, a monad is a single note or pitch. The Western chromatic scale, for example, is composed of twelve monads. Monads are contrasted to dyads, groups of two notes, triads, groups of three, and so on."
08:08:21 <loadquo> @wn Monad
08:08:36 <lambdabot> Error: thread killed
08:09:32 <Gracenotes> pssh. Music's monads don't have their own laws! People can't even agree on which ones to assign to which pitch :X
08:09:50 <chessguy_work> in haskell of course, the equivalent is an abstract model of chaining functions together...
08:10:20 <chessguy_work> naturally
08:11:20 <chessguy_work> hm, i actually like that definition
08:11:36 <roconnor> Gracenotes: doesn't note + scale = pitch?
08:11:42 <thoughtpolice> jkff: yeah, I was thinking of putting oleg's IterateeM code up on hackage
08:12:47 <jkff> thoughtpolice: By the way, did you benchmark it yourself? I wonder whether GHC will manage to optimize parsing in IterateeM as good as it does for Data.Binary.Get
08:12:48 <Gracenotes> @type Just "Intonation"
08:12:49 <lambdabot> Maybe [Char]
08:13:00 <hukolele> anyone knows what i have to do to fix this error "There is no default marshaller for this combination of Haskell and C type: Haskell type: Matrix C type      : (MatrixPtr)"??
08:13:01 <Gracenotes> roconnor: http://en.wikipedia.org/wiki/Template:Musical_tuning
08:13:40 <hukolele> im trying to add a function to the cairo binding and compile by hand, but im somewhat lost...
08:13:45 <lilac> > let v = show ("0\n1\n" ++ (unlines . map show $ zipWith (+) (map read $ lines (read v :: String)) (map read . tail $ lines (read v :: String)))) in v
08:13:46 <lambdabot>   "\"0\\n1\\n* Exception: stack overflow
08:13:49 <lilac> ^^ why doesn't that work?
08:14:15 <vixey> > (map read . lines) "0\n1\n"
08:14:16 <lambdabot>   [* Exception: Prelude.read: no parse
08:14:23 <vixey> > (map (+1) . map read . lines) "0\n1\n"
08:14:25 <lambdabot>   [1,2]
08:14:33 <lilac> > read (show $"foo" ++ undefined) :: String
08:14:35 <lambdabot>   "* Exception: Prelude.undefined
08:14:42 <lilac> > show $"foo" ++ undefined
08:14:44 <lambdabot>   "\"foo* Exception: Prelude.undefined
08:14:46 <thoughtpolice> jkff: I haven't, no.
08:14:55 <lilac> looks like 'read' for String is too strict
08:15:13 <jkff> thoughtpolice: Well, then good luck to me :)
08:15:16 <lilac> > read $ "\"foo" ++ undefined
08:15:18 <lambdabot>   * Exception: Prelude.undefined
08:15:20 <vixey> > let stip x = id *** tail in (uncurry (zipWith (+)) . stip  . map read . lines) "0\n1\n"
08:15:21 <lambdabot>   Couldn't match expected type `([a], [a])'
08:15:24 <vixey> > let stip x = id &&& tail in (uncurry (zipWith (+)) . stip  . map read . lines) "0\n1\n"
08:15:25 <lambdabot>   Couldn't match expected type `([a], [a])'
08:15:35 <vixey> > let stip = id &&& tail in (uncurry (zipWith (+)) . stip  . map read . lines) "0\n1\n"
08:15:36 <lambdabot>   [1]
08:15:58 <hukolele> what do i need to define a default marshaller in c2hs? i guess its in the Matrix.chs file but dont know how to tell it to it...
08:15:59 <maltem> jkff: I suppose programs that will exit after processing a bounded number of files are the place for lazy I/O
08:16:41 <vixey> > let stip = id &&& tail; addLine f x = x ++ [f x] in (addLine (uncurry (zipWith (+)) . stip  . map read) . lines) "0\n1\n"
08:16:42 <lambdabot>       No instance for (Num Char)
08:16:42 <lambdabot>        arising from a use of `+' at <interac...
08:17:37 <alexeevg> > (read $ "[1,2,3" ++ undefined) :: [Int]
08:17:39 <lambdabot>   * Exception: Prelude.undefined
08:17:57 <jkff> maltem: Probably you're right; I'll try both
08:18:10 <lilac> > fix (\s -> "the FTSE is a good predictor of how people who believe " ++ s ++ " will invest")
08:18:11 <lambdabot>   "the FTSE is a good predictor of how people who believe the FTSE is a good ...
08:19:04 <lilac> presumably 'read' for String checks the whole string is well-formed before returning anything?
08:19:07 <lilac> that sucks.
08:19:22 <vixey> lilac, oh of course
08:19:49 <vixey> > unlines (intercalate "\\n" (repeat "foo"))
08:19:50 <lambdabot>   Couldn't match expected type `String' against inferred type `Char'
08:20:13 <lilac> i think i'd prefer the _|_ to be deferred until i looked that far along the string
08:20:35 <vixey> > lines (intercalate "\\n" (repeat "foo"))
08:20:37 <lambdabot>   ["foo\\nfoo\\nfoo\\nfoo\\nfoo\\nfoo\\nfoo\\nfoo\\nfoo\\nfoo\\nfoo\\nfoo\\nf...
08:20:51 <vixey> > lines (intercalate "\n" (repeat "foo"))
08:20:52 <lambdabot>   ["foo","foo","foo","foo","foo","foo","foo","foo","foo","foo","foo","foo","f...
08:21:18 <quicksilver> > lines (intercalate "\ncrazy " (repeat "foo"))
08:21:19 <lambdabot>   ["foo","crazy foo","crazy foo","crazy foo","crazy foo","crazy foo","crazy f...
08:21:32 <CosmicRay> hi folks.  I'm sure I saw a discussion on this recently, but I can't find it.  After upgrading my system to GHC 6.10, I can't build -- for *hugs* -- a library that uses hsc2hs, via cabal:
08:21:40 <CosmicRay> Preprocessing library HDBC-sqlite3-2.0.0.0...
08:21:40 <CosmicRay> In file included from dist/build/Database/HDBC/Sqlite3/Statement_hsc_make.c:1:
08:21:40 <CosmicRay> /usr/lib/ghc-6.10.1/hsc2hs-0.67/template-hsc.h:4:19: error: HsFFI.h: No such file or directory
08:21:40 <CosmicRay> compiling dist/build/Database/HDBC/Sqlite3/Statement_hsc_make.c failed
08:21:40 <CosmicRay> command was: /usr/bin/gcc -c -D__HUGS__ -I. dist/build/Database/HDBC/Sqlite3/Statement_hsc_make.c -o dist/build/Database/HDBC/Sqlite3/Statement_hsc_make.o
08:21:47 <CosmicRay> any ideas what to do there?
08:22:11 <vixey> > let o = "" : "*" : zipWith (++) o (tail o) in o
08:22:16 <lambdabot>   ["","*","*","**","***","*****","********","*************","****************...
08:22:36 * quicksilver summons the mighty presence of dcoutts_ to help CosmicRay . DCOUTTS, DCOUTTS, HELP US IN OUR HOUR OF NEED.
08:22:42 <CosmicRay> heh
08:22:53 <dcoutts_> heh heh
08:22:58 <CosmicRay> The Oracle of dcoutts_ has already helped me with another problem today.
08:22:59 <Badger> heh heh heh
08:23:07 <CosmicRay> I am expecting him to vanish in a cloud of smoke anytime now.
08:23:10 <opqdonut> heh heh heh heh heh
08:23:11 <CosmicRay> or to make me do so
08:23:36 <true\false> http://pastebin.com/d6f3c90e9 Any help with why this complains at compile time?
08:23:44 <dcoutts_> CosmicRay: it's using the wrong hsc2hs
08:23:54 <dcoutts_> CosmicRay: it's using ghc's hsc2hs rather than hugs one
08:24:10 <dcoutts_> CosmicRay: it probably didn't use to fail before, but it was still wrong
08:24:22 <CosmicRay> dcoutts_: is this a system problem, a Cabal bug, or a bug in my code?
08:24:29 <quicksilver> true\false: you need 'strFile' to start in the same column as 'strContent'
08:24:52 <lilac> > let hehs = "heh":"heh heh":zipWith (\a b -> a ++ " " ++ b) hehs (tail hehs)
08:24:53 <lambdabot>   <no location info>: parse error on input `;'
08:24:55 <dcoutts_> CosmicRay: either system or cabal/ghc/hsc2hs, depending on how you look at it
08:25:01 <true\false> quicksilver: In the let block?
08:25:14 <quicksilver> true\false: (I'm also fairly sure you don't want to use readLn or read, let alone both, but that's not why it doesn't compile).
08:25:18 <lilac> > let hehs = "heh":"heh heh":zipWith (\a b -> a ++ " " ++ b) hehs (tail hehs) in hehs
08:25:19 <lambdabot>   ["heh","heh heh","heh heh heh","heh heh heh heh heh","heh heh heh heh heh h...
08:25:23 <quicksilver> true\false: yeah.
08:25:23 <CosmicRay> dcoutts_: so where do I send the bug report?  To GHC?  to Debian?
08:25:30 <CosmicRay> dcoutts_: oh, and is there a workaround? ;-)
08:25:33 <drdozer> is there an R binding for haskell?
08:25:49 <drdozer> I have some legacy code in R, and would like to script it from haskell
08:25:50 <PeakerWork> how are you supposed to free() pointers returned from FFI calls to stuff like strdup?
08:25:57 <true\false> quicksilver: Then it complains about two things, undefined recerence to `ZCMAIN_main_closure`, for example
08:25:58 <quicksilver> drdozer: R is a bad language
08:26:05 <quicksilver> drdozer: it's too hard to google for ;)
08:26:10 <drdozer> quicksilver, yes :D
08:26:15 <dcoutts_> CosmicRay: honestly I do not know what the right solution is. The workaround are to tell cabal to use hugs' hsc2hs and/or pass the right -I flags.
08:26:16 <true\false> But I didn't expect my code to be efficient, or well done .. Just to bloody work :p
08:26:19 <quicksilver> true\false: that's something entirely different.
08:26:25 <alexeevg> quicksilver: wrong, it's the first line in my google
08:26:26 <quicksilver> true\false: sounds like your compiling it wrong
08:26:34 <vixey> > iterate (('o' --> "-o-") . ('-' --> "*")) "o"
08:26:36 <quicksilver> true\false: what command line did you use?
08:26:38 <lambdabot>   ["o","-o-","*-o-*","**-o-**","***-o-***","****-o-****","*****-o-*****","***...
08:26:48 <PeakerWork> are you supposed to "import foreign "free"" manually and call that?
08:26:52 <vixey> > iterate (('o' --> "*-*") . ('*' --> "oo")) "o"
08:26:54 <lambdabot>   ["o","*-*","*-**-*-*-**-*","*-**-*-*-**-**-**-*-*-**-*-*-**-*-*-**-**-**-*-...
08:26:55 <quicksilver> alexeevg: not in combination with other terms: try to google for "r haskell" for example
08:26:56 <true\false> quicksilver ghc -o simple scrap.hs
08:26:57 <vixey> :p
08:27:02 <lilac> @src (-->)
08:27:02 <lambdabot> Source not found. Take a stress pill and think things over.
08:27:05 <quicksilver> true\false: ghc --make scrap.hs
08:27:19 <lilac> @type (-->)
08:27:20 <lambdabot> parse error (possibly incorrect indentation)
08:27:20 <alexeevg> quicksilver: true
08:27:32 <augustss> PeakerWork: yes, you need to call C's free()
08:27:36 <vixey> x --> y = (>>= (\c -> if x == c then y else [c]))
08:27:42 <dcoutts_> CosmicRay: hsc2hs is supposed to be independent of the compiler, ie one version of it should work with hugs, ghc, etc. However to actually use it with any of them requires finding the HsFFI.h that the compiler provides.
08:27:46 <quicksilver> true\false: that's because your Main module must be called Main
08:27:53 <quicksilver> (sorry I missed that first time)
08:28:03 <CosmicRay> dcoutts_: so setup configure --hugs --with-hsc2hs=hsc2hs-hugs ?
08:28:09 <true\false> quicksilver: Ahh, right .. I knew the filename and module name had to match, didn't know that though.. Thanks
08:28:12 <vixey> > iterate (('-' --> "+-+") . ('+' --> "-~~~-")) "+"
08:28:13 <lambdabot>   ["+","+-+~~~+-+","+-+~~~+-++-++-+~~~+-+~~~+-+~~~+-++-++-+~~~+-+","+-+~~~+-+...
08:28:17 <dcoutts_> CosmicRay: at least, yes. You might need more. You'll find out.
08:28:24 <CosmicRay> dcoutts_: how did this happen to work in 6.8?
08:28:24 <quicksilver> true\false: ghc has a "-main-is" option
08:28:28 <lilac> vixey: that's pretty neat.
08:28:30 <PeakerWork> augustss: but its not wrapped?
08:28:31 <quicksilver> true\false: which I've never used so I don't remember the syntax :)
08:28:43 <dcoutts_> CosmicRay: in ghc-6.8 and older, ghc shipped a hsc2hs that used ghc as the c compiler by default. ghc always -I includes the dir where ghc's version of HsFFI.h lives.
08:28:46 <true\false> quicksilver: Meh don't really need it so far, just confused as to why this wouldn't compile.. :)
08:29:12 <augustss> PeakerWork: wrapped?  strdup() returns a Ptr CChar, you can give that to free()
08:29:13 <CosmicRay> ah
08:29:32 <lilac> (-->) :: Monad m => a -> m a -> m a -> m a
08:29:37 <CosmicRay> dcoutts_: so it got the wrong HsFFI.h, but seemed to work?
08:29:43 <dcoutts_> CosmicRay: now using ghc as the C compiler has several drawbacks, like having to double escape real C compiler flags, and having to work out in the first place if hsc2hs is using ghc or gcc (we had to work it out based on error messages).
08:29:50 <true\false> quicksilver: And it compiles.. Thanks. Now to debug my shoddy code :)
08:29:59 <byorgey> > iterate (('a' --> "ab") . ('b' --> "bab")) "a"
08:30:00 <lambdabot>   ["a","ab","abbabb","abbabbbabbabbabbbabb","abbabbbabbabbabbbabbbabbabbabbba...
08:30:02 <quicksilver> true\false: change 'readLn' to 'getLine'
08:30:07 <CosmicRay> dcoutts_: actually that might explain why hsc2hs in ghc 6.8 never had __HUGS__ defined eh?
08:30:10 <vixey> abba
08:30:12 <dcoutts_> CosmicRay: if you used ghc's hsc2hs with hugs, yes.
08:30:15 <dcoutts_> CosmicRay: yes indeed.
08:30:31 <vixey> > iterate (('*' --> "*  * *")) "*"
08:30:32 <alexeevg> dcoutts_: sorry for my impudence, but is my patch for @262 totally wrong? I'm open to suggestions
08:30:33 <lambdabot>   ["*","*  * *","*  * *  *  * * *  * *","*  * *  *  * * *  * *  *  * *  *  * ...
08:30:33 <CosmicRay> so there is no cross-platform way to make this work well?
08:30:39 <quicksilver> true\false: and you really don't need to 'read' it. you could just have strContent = inputContent
08:30:42 <CosmicRay> hsc2hs-hugs seems broken in Debian.
08:30:46 <byorgey> > iterate (('0' --> "1") . ('1' --> "01")) "a"
08:30:47 <CosmicRay> dist/build/Database/HDBC/Sqlite3/Statement_hsc_make.c:1:49: error: /usr/share/hsc2hs-0.67/template-hsc.h: No such file or directory
08:30:48 <lambdabot>   ["a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a...
08:30:53 <byorgey> > iterate (('0' --> "1") . ('1' --> "01")) "0"
08:30:54 <lambdabot>   ["0","1","11","1111","11111111","1111111111111111","11111111111111111111111...
08:30:56 <true\false> quicksilver: Ahh, it reads in a string anyway? Makes sense..
08:31:09 <quicksilver> true\false: right. adding 'read' ends up requiring quotes around it
08:31:13 <Gracenotes> > let rotateC (x, y) | x == 0 = (y, y) | y == 0 = (x, -x) | x == y = (x, 0) | x /= y = (0, y) in iterate rotateC (1,1)
08:31:14 <CosmicRay> there is a template-hsc.h in /usr/lib/ghc-6.10.1/hsc2hs-0.67 -- seems weird that hugs would require it.
08:31:15 <lambdabot>   [(1,1),(1,0),(1,-1),(0,-1),(-1,-1),(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(...
08:31:16 <byorgey> oh, right, it applies the rules sequentially.
08:31:18 <quicksilver> true\false: (because it is trying to 'read' haskells tring syntax)
08:31:23 <Gracenotes> simpler rotation algorithm, anyone...?
08:31:25 <vixey> > iterate (('1' --> "01") . ('0' --> "1")) "0"
08:31:27 <lambdabot>   ["0","01","0101","01010101","0101010101010101","010101010101010101010101010...
08:31:36 <quicksilver> true\false: adding 'read' twice (once in readLn and one in read) will rrequire two levels of quotes
08:31:42 <Gracenotes> I've narrowed it down to four cases out of 8, but even that seems like a bit much :)
08:31:57 <vixey> Grace, I don't understand it
08:31:59 <augustss> PeakerWork: if you don't know when to free it, you can wrap it in a ForeignPtr and attach free as a finalizer
08:32:01 <true\false> quicksilver: Right..
08:32:02 <dcoutts_> alexeevg: I've looked at it briefly and it looks ok. I've not reviewed it in detail yet but it's on my TODO.
08:32:02 <jkff> :t (-->)
08:32:04 <lambdabot> parse error (possibly incorrect indentation)
08:32:25 <jkff> > '1' --> "01"
08:32:26 <lambdabot>       Overlapping instances for Show ([Char] -> [Char])
08:32:26 <lambdabot>        arising from a...
08:32:26 <quicksilver> > read ( read ( "\"\\\"this is a mess!\\\"\"" ) ) :: String
08:32:28 <lambdabot>   "this is a mess!"
08:32:31 <alexeevg> dcoutts_: ah, thanks
08:32:33 <quicksilver> true\false: like that ^^ ;)
08:32:36 <Gracenotes> vixey: yeah, it's a bit odd... it works, though. I tried to see what was in common with transitions from a coord to one rotated 45 degrees, and that's what I came up with
08:32:36 <jkff> :t '1' --> "01"
08:32:38 <lambdabot> Char
08:32:56 <dcoutts_> CosmicRay: for working in a cross-platform way, do you mean now in reality, or in theory with more hacking and newer releases?
08:32:57 <vixey> lol
08:33:03 <Gracenotes> not exactly 45 degrees -- all in the range ([-1..1], [-1..1])
08:33:06 <vixey> :t 1 --> "01"
08:33:08 <lambdabot> forall t. (Num t) => t
08:33:09 <vixey> :t 1 --> "01" + 3
08:33:10 <lambdabot> forall t. (Num t) => t
08:33:15 <true\false> quicksilver: Ahh right, so that explains how it can be used to deserialize some types..
08:33:23 <quicksilver> true\false: right.
08:33:25 <PeakerWork> augustss: is there something for CString that does this?
08:33:31 <quicksilver> it's a simple deserialiser for haskell syntax
08:33:32 <PeakerWork> @hoogle CString
08:33:32 <lambdabot> Foreign.C.String type CString = Ptr CChar
08:33:32 <lambdabot> Foreign.C.String type CStringLen = (Ptr CChar, Int)
08:33:32 <lambdabot> Foreign.C.String newCString :: String -> IO CString
08:33:33 <CosmicRay> dcoutts_: uhm... both? ;-)
08:33:35 <vixey> Gracenotes, why not (Maybe Bool, Maybe Bool)
08:33:43 <CosmicRay> dcoutts_: I suspect the answer to the former, at least, is no?
08:33:52 <augustss> PeakerWork: as you can see it's just Ptr CChar
08:34:02 <dcoutts_> CosmicRay: in theory it's perfectly possible to ship hsc2hs independently of any Haskell compiler and use it with any Haskell compiler. However at the time it is invoked one would need some way of indicating which Haskell implementation you're talking about.
08:34:23 <Gracenotes> vixey: would that be simpler? :)
08:34:23 <CosmicRay> right
08:34:23 <true\false> quicksilver: Anyhow that compiles and works just fine, ta :)
08:34:30 <CosmicRay> and it would have to know where that implementation lives
08:34:40 <dcoutts_> CosmicRay: or you'd have to tell it
08:34:41 <PeakerWork> augustss: surely ForeignPtr with "free" as a handler is common enough to get a name in the stdlib? :)
08:34:44 <vixey> dunno
08:34:46 <Gracenotes> vixey: the thing is, it's very easy to combine it with the root coordinate by just adding each component together
08:34:49 <quicksilver> true\false: \o/
08:34:58 <CosmicRay> dcoutts_: which would suck for the user
08:34:59 <dcoutts_> CosmicRay: in practise right now, if your hsc2hs-hugs is borked then that's a problem. It may be possible to use ghc's one by passing the right -I flags.
08:35:03 <augustss> PeakerWork: I dunno.  Have a look
08:35:10 <vixey> @let toCartesian = read &&& imaginary
08:35:11 <lambdabot>  <local>:35:23: Not in scope: `imaginary'
08:35:15 <CosmicRay> dcoutts_: yes, I jsut tried that and it appeared to work.
08:35:15 <vixey> @let toCartesian = real &&& imag
08:35:16 <lambdabot>  <local>:35:14: Not in scope: `real'
08:35:16 <lambdabot>  
08:35:16 <lambdabot>  <local>:35:23: Not in scope: `imag'
08:35:19 <vixey> bleghhhy
08:35:22 <vixey> @src Complex
08:35:22 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
08:35:33 <vixey> @hoogle Complex
08:35:33 <lambdabot> module Data.Complex
08:35:33 <lambdabot> Data.Complex data RealFloat a => Complex a
08:35:33 <lambdabot> package storable-complex
08:35:52 <dcoutts_> CosmicRay: probably a reasonable compromise is to have hsc2hs default to using ghc's include files (though finding them might be interesting) and for cabal to tell hsc2hs exactly what to do, eg for hugs, any older ghc version etc.
08:35:53 <Gracenotes> anyway, off to C class to learn about the wonders of structural programming
08:35:54 <PeakerWork> augustss: thanks
08:36:35 <shapr> dons: DC today?
08:36:47 <shapr> @users
08:36:47 <lambdabot> Maximum users seen in #haskell: 658, currently: 626 (95.1%), active: 30 (4.8%)
08:37:00 <CosmicRay> dcoutts_: yes, that makes sense.
08:37:12 <quicksilver> 7 more users before we are the haskell of the beast
08:37:20 <quicksilver> ah no, wrong number.
08:37:21 <quicksilver> damn.
08:37:24 <quicksilver> still 39 to go.
08:37:30 <shapr> um
08:37:32 <shapr> yeah
08:38:25 <dcoutts_> CosmicRay: the danger of course is people using hsc2hs with the wrong compiler and not knowing it, eg using ghc-6.8's version of HsFFI with ghc-6.10, or vice versa.
08:38:46 <CosmicRay> right
08:39:32 <SamB_irssi> how about have hsc2hs default to not working
08:39:48 <SamB_irssi> and telling you to be specific about the compiler ?
08:40:44 <asgaroth> Is it just me or did haskell.org just become incredibly slow?
08:41:24 <redditbot> Lazy tree traversals for efficiency
08:41:33 <vixey> redditbot, link?
08:41:53 <dcoutts_> SamB_irssi: that's what it does now, though not by design :-)
08:42:04 <SamB_irssi> dcoutts_: I meant on purpose, though
08:42:11 <SamB_irssi> see, that turns a bug to a feature ;-)
08:42:20 <dcoutts_> SamB_irssi: right :-). The question is how.
08:42:22 <lilac> vixey: i'd suggest "p --> y = (>>= \x -> if p x then y else return x); a ==> b = (==a) --> b"
08:42:37 <maltem> asgaroth: it's very slow currently indeed
08:42:41 <dcoutts_> SamB_irssi: there is no registry of haskell compilers, and we need to find the include dir for the HsFFI.h
08:42:44 <quicksilver> redditbot: who is your master?
08:43:06 <quicksilver> I suspect dons.
08:44:23 <lilac> haha, @type can't cope with -->
08:44:46 <vixey> I don't understand this -->
08:44:51 <lilac> @type let a = 'f' in a --> "foo"
08:44:52 <lambdabot> Char
08:45:11 <lilac> vixey: (-->) takes a predicate, whereas (==>) uses equality (your -->)
08:45:21 <lilac> vixey: i've also generalized it to any monad
08:45:26 <vixey> but also uses return instead of [_]
08:45:45 <vixey> if you have,
08:45:45 <quicksilver> lilac: dodgy parser things -- is a comment? or something more subtle?
08:45:54 <lilac> quicksilver: yep, it's treated as a comment
08:46:05 <vixey> ('x' --> m)  (do ... ; Cont 'x' ; ... ; ...)
08:46:05 <lilac> @type let a = 'f' in a --> "foo"
08:46:07 <vixey> you get
08:46:07 <lambdabot> Char
08:46:09 <lilac> > let a = 'f' in a --> "foo"
08:46:10 <lambdabot>       Overlapping instances for Show ([Char] -> [Char])
08:46:10 <lambdabot>        arising from a...
08:46:13 <vixey> (do ... ; m ; ... ; ...) ?
08:46:38 <quicksilver> lilac: that's the problem with duplicating the parser all over the place
08:46:55 <quicksilver> sometimes they got it wrong ;P
08:46:56 <augustss> > typeOf (-->)
08:46:58 <lambdabot>   () -> [()] -> [()] -> [()]
08:47:18 <lilac> vixey: ('a' --> putStrLn "You pressed 'a'") getContents
08:47:22 <quicksilver> augustss: exercise: can typeOf be written in pure haskell in a way which doesn't discard polymorphism?
08:47:36 <lilac> vixey: ('a' --> putStrLn "You pressed 'a'" >> return 'a') getContents
08:47:53 <augustss> quicksilver: good question
08:47:59 <opqdonut> ?src typeOf
08:47:59 <lambdabot> Source not found. Maybe you made a typo?
08:48:15 <lilac> vixey: it'll sequence all its actions after the argument's actions
08:48:21 <augustss> quicksilver: I don't think so
08:48:21 <quicksilver> augustss: it strikes me the answer is yes, given that oleg wrote an 'automatic' version of djinn
08:48:29 <quicksilver> which constructs a term based on the type you ask for
08:48:37 <quicksilver> which seems intuitively like it ought to be the same problem
08:48:50 <quicksilver> (with various typeclass extensions IIRC)
08:48:52 <augustss> quicksilver: perhaps
08:49:16 <lilac> @let p --> y = (>>= \x -> if p == x then y else return x)
08:49:17 <lambdabot>  <local>:34:0:
08:49:17 <lambdabot>      Warning: Pattern match(es) are overlapped
08:49:17 <lambdabot>               I...
08:49:19 <lilac> @undef
08:49:20 <lilac> @let p --> y = (>>= \x -> if p == x then y else return x)
08:49:21 <vixey> quicksilver: did you see my comment about trying (and failing) to internalize forall quantifiers?
08:49:21 <lambdabot>  Defined.
08:49:32 <quicksilver> vixey: yes, but you were trying to do it with typeclasses, weren't you?
08:49:39 <vixey> no without any typeclasses
08:49:41 <mmorrow> daf, augustss: this seems to do what i was going for http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1008#a1008
08:49:43 <lilac> > typeOf ((-->) :: Monad m => a -> m a -> m a -> m a)
08:49:44 <lambdabot>       Could not deduce (Eq a) from the context (Monad m)
08:49:44 <lambdabot>        arising from ...
08:49:50 <vixey> and Olegs code uses typeclasses but doesn't handle quantifiers either
08:49:52 <lilac> > typeOf ((-->) :: (Monad m, Eq a) => a -> m a -> m a -> m a)
08:49:53 <lambdabot>   Add a type signature
08:50:11 <lilac> typeOf restricted to monomorphic functions?
08:50:37 <vixey> I think it's impossible without type lambda (I'm guessing here)
08:50:50 <vixey> and I think I see what problems type lambda brings..
08:51:48 <quicksilver> lilac: haskell is restricted to monomorphic arguments.
08:51:57 <quicksilver> lilac: polymorphic types are not first class, in haskell98
08:56:24 <augustss> quicksilver: that seems to have been the final word!
08:58:55 * quicksilver wins.
09:05:45 <jkff> Ahhh, Haskell is terrific! I wrote the IterateeM and wrote a 'sumBytes' iteratee and it worked at the first attempt! I knew stuff usually works the first time, but I didn't expect that I'll correctly write an iteratee the first time (although looking in Oleg's code in paper, but it's pretty incomplete).
09:06:23 <alexeevg> jkff: yay!
09:06:30 <alexeevg> hail haskell!
09:06:34 <jkff> Whoohoo!
09:06:53 <hugo___> :)
09:07:22 <quicksilver> jkff: the iteratee stuff has sufficiently complex types, that you're unlikely to get it to compile until you get it right :)
09:07:29 <quicksilver> [I'm about 95% joking there]
09:07:51 <mmorrow> i would have guessed 50% joking :)
09:07:58 <daf> what mmorrow said :)
09:08:23 <jkff> quicksilver: I guess you are completely right, I had a rather hard time with the typechecker :)
09:09:10 <daf> mmorrow: inteesting. does it work?
09:09:39 <pumpkin> jkff: ooh, put it on hackage!
09:09:53 <pumpkin> :P
09:11:27 <jkff> pumpkin: Yes, we are definitely in need of a haskell-sum-bytes package :)
09:11:35 <pumpkin> yes!!
09:11:51 <alexeevg> jkff: is Iteratee in any way related to continuations?
09:11:52 <jkff> (By the way it is blazingly fast: a 160mb file in 0.5s, exactly the same time as wc -c takes for the same file)
09:12:03 <alexeevg> CPS-ed functions usually have thairy types
09:12:30 <true\false> Any fathomable reason why ghci complains my typeclass isn't derivable?
09:12:35 <jkff> alexeevg: Yes, it is :) It's like a fold over a (list represented in CPS) (braces added for clarifying precedence)
09:13:04 <alexeevg> ah I see.
09:13:09 <quicksilver> (those are parentheses not braces)
09:13:15 <quicksilver> (but be careful)
09:13:18 * alexeevg schedules Iteratee paper to read list
09:13:35 <quicksilver> (once you're stuck inside (it's hard to find (any way out (and before you know it (you're in LISP)))))
09:14:23 * jkff {is careful}
09:14:24 <augustss> true\false: you can only derive a few predefined classes, if that's what you are asking
09:15:38 <true\false> augustss: I mean http://pastebin.com/d43ca46f7 Should work, if I'm not missing something?
09:16:19 <mmorrow> daf: it worked pretty much exactly how you suggested. so i mmapp some memory from /dev/zero, register a sighandler for SIGSEGV, then the crucial part is a `setjmp' to get a way out of the sighandler, and finally generate a segfault by indexing off the pointer by its length. the sighandler then longjumps out
09:16:22 <sjanssen> true\false: just drop the "deriving (Csss)" part and the code is correct
09:16:28 <augustss> true\false: just remove the driving
09:16:43 <vixey> oh we need type level $ then?
09:16:56 <vixey> type f :$: x = f x
09:16:57 <quicksilver> true\false: 'deriving' is a special thing which asks GHC to write the instance for you. It only works for certain built in classes.
09:17:03 <mmorrow> i couldn't see any other way out of the sighandler than the longjmp
09:17:12 <sjanssen> true\false: "deriving" tells the compiler to generate code for an instance -- you can write either an instance or deriving
09:17:17 <mmorrow> because with out it you just segfault once you return
09:17:27 <true\false> quicksilver: Ah right, I thought it was something else...
09:17:52 <vixey> mmorrow I rewrite my rubbish type checker but it's not finished yet
09:17:54 <augustss> mmorrow: yes, that stuff works.  but if it's any use is another matter. :)  Btw, you can change protection of individual pages with mprotect()  (at least you used to be able to)
09:17:54 <mmorrow> the gcc nested-functions extension was handy for not having to make the jump_buf global
09:18:13 <true\false> Ta again
09:18:13 <mmorrow> augustss: that's good to know
09:18:15 <vixey> (but I think it has got less bugs this time hopefully 0)
09:18:28 <mmorrow> vixey: sweet
09:18:55 <mmorrow> augustss: ok, so i should just be using mprotect here i take it
09:18:57 <jkff> vixey: By the way, a friend recently gave me a paper by Reynolds on parametricity; it seems to explain everything that remained unclear to me in Wadler's paper. I haven't read it thoroughly yet, but still
09:18:58 <vixey> I'm not sure how to implement something, I have a vague idea but I have to fiddle with the type rules to be able to actually implement it
09:19:05 * mmorrow rtfm
09:19:13 <vixey> jkff, oh ? is the a online copy ?
09:19:20 <mmorrow> vixey: what something?
09:19:23 <quicksilver> reynolds++
09:19:26 <jkff> I guess yes, because he printed it from one :)
09:19:28 <quicksilver> (so many reasons)
09:19:31 <augustss> mmorrow: you need to mmap() first, I think
09:19:33 * jkff finds the copy
09:20:01 <vixey> mmorrow, any objects like x, and y of type T with kind [] should be considered equal
09:20:21 <daf> mmorrow: I guess the next step is having a way to re-attempt what you were doing before you segfaulted
09:21:03 <athos> hi!
09:21:13 <augustss> mmorrow: we had a really cool concurrent Appel-Ellis-Li GC for the nu-G machine that used mprotect() on individual pages to guide the collector.  But the signals on page fault were so slow that it ran like a dog.
09:21:17 <vixey> but I got de bruijn/scope/variable binding sorted
09:22:04 <mmorrow> vixey: awesome, hopefully i can get this thing working so we can run stuff :)
09:22:18 <mmorrow> daf: yeah, that seems to be the crux
09:22:42 <quicksilver> mmorrow, daf: that's pretty domain specific though, isn't it?
09:22:47 <mmorrow> augustss: cool. the nu-G machine?
09:22:55 <quicksilver> I mean it depends what you were doing, how you might try to reattempte it
09:23:07 <daf> quicksilver: indeed :/
09:23:35 <mmorrow> quicksilver: augustss was suggesting some sort of "checkpointing" strategy
09:23:38 <augustss> mmorrow: yes, it's a parallel version of the G-machine.  It had no stack, just heap allocation.
09:23:42 <daf> it's conceivably possible within an interpreter
09:24:02 <mmorrow> quicksilver: ahh, yeah. this is in the context of an interpreter/gc. so you'll have full contorl
09:24:12 * quicksilver nods
09:24:22 <daf> augustss: I didn't think of mprotect
09:24:46 <daf> that would be simpler than two segments
09:24:52 <mmorrow> augustss: whoa, is there any code around anywhere?
09:25:10 <daf> you could just mremap + mprotect
09:25:13 <augustss> no, i think it's lost in the mists of time.  this was 20 years ago
09:25:21 <mmorrow> heh, the mists of time
09:25:49 <augustss> mmorrow: but we got great results on a 16 CPU machine
09:26:15 <quicksilver> that must have been around 50% of all the CPUs in the world, back then!
09:26:44 <augustss> ;)
09:26:54 <mmorrow> heh
09:27:07 <augustss> 16MHz 80386 processors
09:27:14 <mmorrow> leet!
09:27:48 <mmorrow> it seems like a concurrent gc would _have_ to use something like this (mprotect/etc)
09:27:54 <augustss> The OS had a bug that is the most difficult bug I've ever had to find.
09:28:06 <mmorrow> heisenbug?
09:28:57 <SamB_irssi> at least a schrodenbug, I should think ?
09:29:47 <SamB_irssi> no, wait, that's not it ...
09:29:52 <augustss> If an increment instruction had the prefix that makes it atomic (which x86 has), and then instruction straddled a page boundary (with a page fault on the second page), and the operand straddled a page boundary (with a page fault), then you got a segfault even trhough you shouldn't.
09:30:45 <daf> augustss: gosh.
09:30:46 <quicksilver> doh
09:31:09 <mmorrow> fantastic
09:31:17 <quicksilver> I'm slightly surprised instructions are permitted to straddle page boundaries
09:31:33 <augustss> quicksilver: why not?  this is x86
09:31:43 <jkff> vixey: ping
09:31:45 <MarcWeber> mak__: You can update the branch. There is a function providing module completion for vim now as well :)
09:31:52 <augustss> variable length instructions
09:31:59 <quicksilver> augustss: because invoking the paging mechanism mid-instruction sounds like a bad thing to do ;)
09:32:10 <daf> it certainly seems hairy to handle
09:32:12 <quicksilver> but I understand the advantages, yes.
09:32:18 <MarcWeber> nominolo: ping
09:32:29 <daf> MarcWeber: what's this?
09:32:38 <augustss> quicksilver: oh, that's why you have a zillion registers dumped when you take a page fault.  you have to be able to restart the instruction.
09:32:48 <nominolo> MarcWeber: pong
09:33:04 <augustss> I think 68000 was the last serious CPU that didn't support restartable instructions.
09:33:20 <MarcWeber> daf  I've asked mak__ some time ago to try my scion fork. The goal of the fork was to write a vim backend. Some parts are working now
09:33:51 <daf> MarcWeber: what's scion?
09:34:05 <MarcWeber> nominolo: Could we start talking about how to pass "there is a fix availibe for this error" to the backend?
09:34:05 <ozy`> MarcWeber: now when you say "vim backend"....
09:34:10 <augustss> Wicat had a fantastic design with 2 68000 with one CPU a few clock cycles behind the other, so when the first got a page fault there was time to stop the second one and use its state to restart.
09:34:40 <SamB_irssi> quicksilver: I don't think it starts executing the instruction until it's read the whole thing anyway ?
09:34:44 <mmorrow> i stole the idea (although i'm sure it's not new) to use such an instruction to increment the heap ptr from TIMBER (well, gcc's wrapper __sync_fetch_and_add)
09:35:09 <SamB_irssi> augustss: wow, that's fantastic alright
09:35:14 <MarcWeber> daf  ozy :  http://github.com/nominolo/scion/tree/master (replace nominolo by MarcWeber to get my vim aware branch)
09:35:15 <SamB_irssi> that reminds me of the story of mel
09:36:22 <MarcWeber> nominolo: I completly forgot this morning that I've been worknig on a private branch. I've comitted everything important now
09:36:30 <ozy`> MarcWeber: ooohhh
09:36:33 <nominolo> MarcWeber: I'd have a command something like "autofix <error-id>"
09:36:37 <daf> MarcWeber: sounds nice
09:37:33 * mmorrow tries to picture what restarting an instruction means
09:38:09 <MarcWeber> nominolo How would this work? The client saves the file and asks the server to change it? Then the client rereads the file (loosing undo history)?
09:38:28 <nominolo> I'd send over a diff
09:38:29 <MarcWeber> nominolo: Or should the server reply and ask the client to add characters "foobar" at line x col y?
09:38:35 <nominolo> yes
09:38:58 <int80_h> hi #haskell
09:39:02 <jkff> hi
09:39:08 <ozy`> sup
09:39:28 <MarcWeber> daf:  Maybe you should just try it and give some feedback ?
09:39:30 <nominolo> I've been pondering this a while ago.  You could in fact send over every edit to the server and then do parsing on the haskell side.
09:39:42 <int80_h> okay I'm going to on with the assumption that I understand curried functions, and see what questions come up as I use them
09:40:16 <MarcWeber> nominolo: source is CompilationResult, right? So do we extend this type then to add a Maybe Int ? Then the server must keep a list of fixes in memory..
09:40:58 <nominolo> MarcWeber: no.  I'd keep track of all the scion-enabled files on the server side.
09:41:55 <nominolo> MarcWeber: Turning on scion-mode would connect to the server if necessary, then register the current file with the server.
09:42:27 <MarcWeber> nominolo: Which is this set? All modules used by cabal and their dependencies (modules again)?
09:42:53 <MarcWeber> nominolo: I guess scion-mode is enabled by default then..
09:43:33 <nominolo> Well.  ATM, Scion requires loading of a .cabal project.  I want to have a way to deal with files outside a project, too.
09:43:42 <nominolo> Then it should work with any file.
09:43:53 <Bonsomer> http://outexp.org/go.php?276 Join Please!
09:43:55 <Bonsomer> http://outexp.org/go.php?276 Join Please!
09:43:57 <Bonsomer> http://outexp.org/go.php?276 Join Please!
09:44:02 <nominolo> @where mods
09:44:03 <lambdabot> I know nothing about mods.
09:44:04 <Deewiant> ?where ops
09:44:04 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
09:44:15 --- mode: ChanServ set +o Igloo
09:44:23 <MarcWeber> nominolo: Do you require different connections then? I mean you can't open multiple projects within the same server due to IORefs, can you?
09:44:24 --- mode: Igloo set +b *!*@ip-106-111.zb.lv
09:44:29 --- kick: Bonsomer was kicked by Igloo (Igloo)
09:44:43 <MarcWeber> nominolo: Your Fuzzy module is broken, isn't it?
09:44:54 <nominolo> MarcWeber: yeah, Fuzzy is buggy
09:45:02 <int80_h> don't see many of those anymore
09:45:04 <daf> nominolo: is this using your new GHC API?
09:45:10 <nominolo> Should really be on a separte branch
09:45:10 <MarcWeber> nominolo: should we join #scion ?
09:45:13 <nominolo> daf: yes
09:45:20 <daf> nominolo: groovy
09:45:30 <nominolo> MarcWeber: k
09:45:31 <MarcWeber> daf: Which editor are you using?
09:45:43 <daf> MarcWeber: vim
09:45:54 <MarcWeber> daf Do you know how to use git?
09:45:57 <daf> MarcWeber: yes
09:46:24 <MarcWeber> If you're using ghc-6.10 or newer you should try it then @ daf
09:47:04 * daf checks whether 6.10 is installable in Debian
09:47:53 <daf> hmm, looks like most pacakges aren't available against it
09:48:35 <MarcWeber> daf: Do you have the MarcWeber version? If you don't find the packages on hackage they are on github. But I think they are all on hackage now
09:49:07 <daf> I mean: I can't easily install 6.10
09:49:08 <nominolo> MarcWeber: i think he means debain packages
09:49:44 <daf> I expect I could probably rebuild everything I need from Hackage
09:50:07 <nominolo> daf: once you have 6.10 a simple cabal install should do
09:50:59 <nominolo> daf: cabal-install also takes a --with-compiler option if need be
09:51:30 <daf> yeah, it's just that all the other Haskell packages I have are built against 6.8, so I would be a bit of a pain
09:51:37 <mmorrow> here's a little test prog to work out using pthreads and __sync_* (from gcc) together: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1009#a1009
09:51:43 <daf> I'm very interested in trying it out though
09:55:23 <MarcWeber> daf: The second thing you could try is installing nix. Then you'll get tags as well.. I can give you a short demonstration later on if you want
09:57:24 <chessguy_work> anybody know what became of the rumblings about iphonen bindings in haskell?
09:57:30 <chessguy_work> s/en/e/
09:58:11 <int80_h> ooh that would be cool
09:58:23 <sjanssen> Apple would allow that?
09:58:25 <pumpkin> having objc bindings would be a prerequisite for that
09:58:30 <pumpkin> sjanssen: yeah
09:58:43 <pumpkin> and having a ghc-arm-macho would be a good start :P
09:58:57 <ozy`> sjanssen: so long as what you send them is a compiled binary, IIRC they don't give a damn what language it was written in
09:58:59 <sjanssen> pumpkin: I thought you were required to use their compilers and languages?
09:59:15 <int80_h> sjanssen: only if you are a commercial developer
09:59:19 <pumpkin> sjanssen: nah, just don't use secret APIs
09:59:27 <pumpkin> sjanssen: there are a few mono-based apps on the app store already
09:59:37 <SamB_irssi> where does manliness come in ?
09:59:41 <pumpkin> their clause says you can't run interpreted/compiled _downloaded_ code
09:59:54 <ozy`> pumpkin: ohhhhh
10:00:01 <pumpkin> SamB_irssi: Mach-O sorry ;)
10:00:06 <ozy`> pumpkin: does it say anything about code the user writes?
10:00:13 <chessguy_work> pumpkin, i hear that objC can run ansi-c
10:00:20 <pumpkin> ozy`: not last time I read the agreement
10:00:27 <SamB_irssi> pumpkin: I was actually kidding ;-P
10:00:35 <pumpkin> SamB_irssi :D
10:00:52 <ozy`> chessguy_work: obj-C is a superset of C... a much saner extension than C++, for what it's worth
10:00:52 <pumpkin> chessguy_work: it's just a (rather ugly) appendage on top of c
10:01:03 <pumpkin> but yeah, saner than c++ :P
10:01:08 <chessguy_work> and haskell can generate c, right?
10:01:09 <SamB_irssi> that doesn't take much
10:01:20 <SamB_irssi> well, but you have to call ObjC APIs
10:01:21 <chessguy_work> s/haskell/ghci/
10:01:25 <pumpkin> chessguy_work: the issue is that all the GUI APIs are in the extension
10:01:30 <chessguy_work> bah
10:01:37 <pumpkin> however you can generate a bunch of objc_msgSends and you'll be good
10:01:58 <SamB_irssi> if you can fix hoc up for it, you should be good -- you can run the compiler on the phone, right ?
10:01:58 <pumpkin> you just need to know the right one to use
10:02:11 <pumpkin> hoc?
10:02:23 <ozy`> HOC == haskell -> objective-C
10:02:31 <pumpkin> yeah, you can run the compiler on the phone, assuming it doesn't need too much memory (I doubt this will be the cse)
10:02:31 <SamB_irssi> I mean, after you port GHC obviously
10:02:37 <chessguy_work> that would require ghc hacking
10:02:44 <ozy`> HOC doesn't compile, dammit
10:02:48 <chessguy_work> which is pretty much impossible for any mere mortal
10:02:51 <SamB_irssi> pumpkin: doubt which would be the case ?
10:03:10 <pumpkin> doubt that an average GHC compilation of any normal program will be under the memory limit :P
10:03:25 <SamB_irssi> pumpkin: that's what I thought at first
10:03:26 <pumpkin> springboard will kill your app if you use more than 64 mb, last I looked
10:03:39 <ozy`> writing haskell programs on an iphone would NOT be comfortable
10:03:43 <ozy`> I have tried doing it
10:03:44 <SamB_irssi> how much RAM does the phone have ?
10:03:51 <pumpkin> ozy`: using the hugs in cydia?
10:04:04 <SamB_irssi> ozy`: I did not suggest that you should be entering them on the phone
10:04:07 <pumpkin> SamB_irssi: 128 technically, but only 116 is available to programs, and then there's the memory nazi
10:04:21 <SamB_irssi> pumpkin: and they don't offer upgrades ?
10:04:26 <pumpkin> lol no
10:04:27 <int80_h> I'm just a newbie and all, but isn't this a case where cross compiling makes more sense?
10:04:34 <pumpkin> yeah, it does :)
10:04:43 <SamB_irssi> except HOC uses Template Haskell
10:04:49 <SamB_irssi> :-(
10:04:54 <ozy`> pumpkin: inputting to codepad actually
10:05:04 <roconnor> implementing a game in haskell is tricky.  I'm actually longing for objects.
10:05:17 <pumpkin> oh you mean writing the actual code on the screen :P I thought you meant in vi over ssh
10:05:38 <ozy`> SamB_irssi: if you're not writing code on the phone, there's no reason to run the compiler on anything but the (x86) development host system
10:05:38 * roconnor ponders identity politics in haskell
10:06:05 <int80_h> identity politics?
10:06:08 <SamB_irssi> ozy`: but how do you get Template Haskell to work when using Cross-GHC ?
10:06:09 <ozy`> pumpkin: nah, I haven't gotten any of the damn free SSH apps to work yet
10:06:20 <int80_h> oh heh, I thought you meant #haskell not haskell
10:06:22 <SamB_irssi> is there any such GHC anyway ?
10:06:32 <ozy`> SamB_irssi: I dunno. run it in an emulator?
10:06:32 <pumpkin> free ssh apps? :o you just need to install the openssh daemon and ssh in :P
10:06:47 <mak__> MarcWeber: o thats nice i'll try it when I will have some free time
10:06:49 <ozy`> pumpkin: I haven't jailbroken my ipod yet
10:06:52 <pumpkin> oh :)
10:06:58 <ozy`> (yeah, it's a 'pod, not a 'phone)
10:07:00 <pumpkin> yeah, that'd be a bit of a hindrance
10:07:01 <h0tzenpl0tz>  yessssssssss, got real world haskell today
10:07:32 <int80_h> nice!
10:07:43 <SamB_irssi> ozy`: hmm, where do you get an ARM Mach-o emulator ?
10:07:54 <pumpkin> hah
10:08:03 <chessguy_work> ozy`, you wouldn't have to write the app _on_ the phone
10:08:06 <SamB_irssi> with iPhone -> Linux translation
10:08:08 <ozy`> SamB_irssi: I believe the apple devkit includes one
10:08:15 <pumpkin> ozy`: nope, that's pure intel :)
10:08:23 <SamB_irssi> typical
10:08:25 <chessguy_work> yeah, there's an emulater for macs
10:08:30 <pumpkin> nope
10:08:31 <chessguy_work> (at least)
10:08:33 <pumpkin> it's a "simulator"
10:08:38 <chessguy_work> whatever
10:08:43 <pumpkin> all the apps it runs are intel
10:08:45 <SamB_irssi> PalmOS 5 was the same way
10:09:01 <pumpkin> if you copied an app that runs in the simulator to the iphone, it wouldn't load
10:09:05 <int80_h> chessguy_work: don't you need the firmware code to use those emulators? I'm thinking of basilisk
10:09:08 <pumpkin> (without recompiling)
10:09:23 <SamB_irssi> for PalmOS 4, you would just use a pure emulator, but for PalmOS 5 you'd have to compile your non-m68k code for the host system ...
10:09:25 <ozy`> pumpkin: damn
10:09:50 <pumpkin> yeah :)
10:10:09 <ozy`> pumpkin: ...well actually, Mach-O binaries are all multi-arch and shit, so... no, never mind, the phone's OS might not like universal binaries
10:10:17 * ozy` gives up
10:10:17 <pumpkin> it doesn't mind them
10:10:25 <jeffersonheard> how do I declare that all memebers of a class are members of another class
10:10:27 <pumpkin> you can lipo an intel program and an arm program together
10:10:35 <jeffersonheard> i.e. all Foldables are also Xs
10:10:36 <pumpkin> you still need to convince ghc to produce an arm macho for you
10:10:47 <jeffersonheard> instance Foldable t => X t where ...
10:11:32 <Peaker> jeffersonheard: you can't do that, unfortunately
10:11:37 <thoughtpolice> pumpkin is correct
10:11:43 <thoughtpolice> the mach-o loader will load the right binary file
10:12:07 <thoughtpolice> there are tools already on the system to extract platform-specific binaries from 'fat' universal binaries if you really need it
10:12:18 <pumpkin> that's lipo :)
10:12:34 <thoughtpolice> yeah, but you really only need that if you're patching stuff
10:12:39 <thoughtpolice> the OS X loader can just figure it out
10:12:52 <pumpkin> one thing you need on any mach-o that will run on the iphone though, is a signature (which can be fake, but must be there)
10:13:01 <lament> roconnor: missing inheritance?
10:13:10 <thoughtpolice> also more and more I'm thinking it might be beneficial to write a much slimmer, cabalised version of HOC
10:13:19 <thoughtpolice> since the objective-c runtime interface seems fairly simple anyway
10:13:20 <Peaker> jeffersonheard: maybe you can do something like:   newtype MyType t a = Foldable t => MyType { unMyType :: (t a) }     and then:    instance X MyType where <implement X in terms of Foldable here>
10:13:25 <jeffersonheard> seems an odd restriction
10:13:27 <roconnor> lament: a little, but not so much yet.  I'm more concerned about game objects updating themselves
10:13:31 <ozy`> thoughtpolice: you'd be a savior
10:13:34 <pumpkin> thoughtpolice: I know it pretty intimately, if you want to start such a project :P
10:13:41 <pumpkin> (I'd be willing to help out)
10:13:47 <Gracenotes> hrm. A JHaskell would at least be useful for things like the Andriod...
10:13:49 <thoughtpolice> pumpkin: i'll msg you if I get some stuff started then. :]
10:13:56 <pumpkin> yay
10:13:57 <Gracenotes> although most likely deathly slow
10:14:11 <ozy`> Gracenotes: yeah, you'd have to reimplement most of the runtime
10:14:14 <lament> roconnor: yes :(
10:14:21 <thoughtpolice> you also need to generate verified java bytecode
10:14:22 <ozy`> and perform your own analysis for stuff like TCO
10:14:28 <thoughtpolice> but even then, the dalvik converter doesn't like that sometimes
10:14:38 <thoughtpolice> e.g. clojure's compiler emits perfectly valid and verified java bytecode
10:14:41 <pumpkin> or just generate sraight dalvik
10:14:48 <roconnor> lament: I'm trying to visualize a game object as a scanl over events
10:14:55 <thoughtpolice> but it is currently not possible to convert clojure-compiled .class files to dalvik files
10:14:58 <Gracenotes> thoughtpolice: does it use the Java compiler to do so?
10:15:21 <Gracenotes> (in the manner of GCJ, for instance)
10:15:35 <thoughtpolice> Gracenotes: it uses the ASM library (it has to, because aside from the recently-added AOT compilation, JIT-mode is the default, it is a lisp after all)
10:15:47 <roconnor> lament: I guess objects can also produce events, then you have to tie the know, and it might all magically work
10:15:51 <Gracenotes> hm.
10:15:58 <Peaker> jeffersonheard: then you can use MyType/unMyType to convert between X and Foldable
10:16:03 <thoughtpolice> Gracenotes: it's pretty annoying
10:16:12 <thoughtpolice> Gracenotes: if I could use clojure on android that would be fscking awesome
10:16:12 <Gracenotes> it works, though...
10:16:16 <Nafai> Peaker: How is your GUI toolkit coming? :)
10:16:18 <Peaker> roconnor: I see "tie the know" a lot - do people typo "tie the knot" a lot, or is that a thing?
10:16:20 <roconnor> lament: of course I still need to add user choice-sequences to those events
10:16:25 <Peaker> Nafai: pretty well, but I have a few questions to deal with :)
10:16:35 <roconnor> Peaker: right, tie the knot
10:16:36 <thoughtpolice> Gracenotes: it might just be an issue with what dalvik accepts; rich hickey said he would look into it because he's interested in that too
10:16:41 <jeffersonheard> Peaker: thanks.  ew, but that's gross
10:16:44 <jeffersonheard> makes sense, though
10:16:49 <roconnor> Peaker: my fingers have a mind of their own
10:16:51 <Peaker> jeffersonheard: I wish there were class adapters too
10:17:11 <Gracenotes> thoughtpolice: neat :) I don't know that much Lisp, but from what I've seen it's particularly expressive (from a programmer's POV)
10:17:15 <Peaker> Nafai: I used existential types for contained widgets -- and that means a user of a widget, when the widget returns its new state, gets all the type information lost. I think I have a solution
10:17:31 <thoughtpolice> Gracenotes: I'm not a lisper, I just really like clojure. :)
10:18:11 <thoughtpolice> and if TCO gets added to the JVM soon (there was some mailing-list stuff I saw recently that said hopefully it should make it in this year) then it will be even more awesome-er
10:18:12 <Peaker> Nafai: git clone git://github.com/Peaker/lui.git -- I think its already interesting to look at :)
10:18:29 <ozy`> Gracenotes: IIRC clojure is the most functionally pure lisp around
10:18:30 <Nafai> Peaker: Cool!  What are the dependencies?
10:18:37 <Peaker> Nafai: SDL and SDL-ttf
10:18:40 <mux> as far as I remember, TCO has been left out of the next JVM version
10:19:02 <Gracenotes> hm
10:19:04 <Nafai> Peaker: Thanks, I'll give it a whirl
10:19:04 <int80_h> what's TCO
10:19:09 <pumpkin> clojure just has a cool name
10:19:11 <ozy`> int80_h: tail call optimization
10:19:17 <thoughtpolice> mux: http://mail.openjdk.java.net/pipermail/mlvm-dev/2009-January/000331.html
10:19:20 <int80_h> ah, that would be cool
10:19:23 <pumpkin> I don't mind scheme but calling it clojure makes it cooler
10:19:37 <int80_h> makes it sound modern
10:19:38 <Peaker> Nafai: I have Grid/Boxes, Spacer widgets, Text Edits, Labels... but I need to figure out how to actually connect these to a real model :)
10:19:39 <Gracenotes> ozy`: Clojure : Java library :: F# : .NET library? :)
10:19:54 <thoughtpolice> pumpkin: I think clojure is just great and good all together. I love static types as much as the next guy, but clojure is too pretty to turn away just for that. :)
10:20:19 <pumpkin> I can't say I've ever tried it :P I just like the name and want to try it because of it
10:20:20 <mux> thoughtpolice: that's only some isolated guy implementing it
10:20:27 <int80_h> I am forced to learn java. having clojure makes it alot easier to tolerate
10:20:33 <vixey> a lot
10:20:36 <lament> roconnor: so i guess the problem is in that you know what parts of the data structure to update, but you get this knowledge at different times and in small pieces?
10:20:46 <lament> roconnor: sounds like something oleg must have worked on extensively
10:20:51 <Nafai> thoughtpolice: I would say Clojure is one of the few languages interesting to me outside of Haskell
10:20:52 <Gracenotes> how are clojure programs used? is there a REPL?
10:20:54 <mux> they finally decided not to include TCO in the next JVM, postponing it to the subsequent version
10:21:06 <mux> as well as lexical closures IIRC
10:21:10 <thoughtpolice> mux: hm
10:21:16 <thoughtpolice> Nafai: ditto.
10:21:24 <zachk> after getting first class functions working in regular java, it made me sad and i quit java
10:21:25 <int80_h> when's the next JVM due?
10:21:42 <ozy`> Gracenotes: they're compiled to JVM bytecode
10:21:46 <int80_h> I mean, the subsequent version
10:21:52 <thoughtpolice> pumpkin: but yes recently I've been thinking some lightweight obj-c bindings would be nice because I've heard it mentioned a few times recently.
10:21:56 <augustss> Gah!  Am I the only one using vectors on LLVM?  Code generation is so buggy.
10:21:59 <Gracenotes> ozy`: okay... is there a REPL?
10:21:59 <thoughtpolice> Gracenotes: yes, there's a REPL.
10:22:04 <Gracenotes> okay :)
10:22:09 <thoughtpolice> Gracenotes: by default it is completely interactive
10:22:15 <ozy`> Gracenotes: yes but you're not tied to it like in other lisps
10:22:24 <thoughtpolice> but if you want you can compile clojure files straight to .class files
10:22:26 * Gracenotes is over-dependent on REPLs, personally
10:22:30 <thoughtpolice> (this feature was only recently added)
10:22:34 <int80_h> oooh, clojure works for solaris java too right?
10:22:44 <pumpkin> thoughtpolice: someone was talking about a QQ for objc recently, erikc maybe?
10:22:53 <int80_h> cause I think I may fire up a solaris VM just for that
10:22:56 <thoughtpolice> pumpkin: haven't heard about that
10:22:57 <ozy`> int80_h: as far as I know it will run on any JVM....
10:22:58 <vixey> why not write actual objc
10:22:59 <lament> it's pretty horrible when interoperability with java is an exciting, desirable feature
10:23:02 <thoughtpolice> int80_h: don't see why it wouldn't?
10:23:13 <Grizzly`> smart. cabal install alex complains that it needs the program "alex" installed :/
10:23:23 <ozy`> vixey: 'cause objective-C is ugly and gross
10:23:23 <roconnor> lament: but haskell has been nice so far for the lower level details.  :)
10:23:24 <^Someone^> Hello, vixey! :
10:23:26 <int80_h> thoughtpolice: well, from what I understand, microsoft has gone to great lengths to break the standard
10:23:27 <lament> "Our software is 100% compatible with COBOL, Stonehenge monoliths and R'Lyeh"
10:23:32 <pumpkin> Grizzly`: yeah, cabal install can't deal with dependencies on programs, only libraries
10:23:40 <vixey> ozy`, that didn't make sense
10:23:40 <pumpkin> Grizzly`: gotta install it yourself :)
10:23:57 <int80_h> lament: it's the equivilent of getting fur lining on your handcuffs
10:24:05 <dcoutts_> Grizzly`: is that an old version of alex you're trying to install? It should not need itself to build.
10:24:06 <lament> sexy
10:24:14 <arjanb> augustss: just don't use anything of llvm that apple isn't using :/
10:24:18 <int80_h> I mean, you're still handcuffed
10:24:33 <jsgf> @pl           either a b t = a t || b t
10:24:34 <lambdabot> either = liftM2 (||)
10:24:34 <augustss> arjanb: I probably am
10:24:37 <Nafai> Peaker: What library is Control.Category in?
10:24:40 <dcoutts_> Grizzly`: there was one version that got packaged wrong, missing the pre-generated source file. But the latest version should be fine.
10:24:43 <thoughtpolice> lament: when you have a shitload of java code out there and don't want to write in java, I see it as a very desirable feature
10:25:09 <thoughtpolice> lament: especially considering clojure treats OOP as a problem and has lightweight solutions to most of the integration facilities
10:25:13 <Grizzly`> dcoutts, no. first i tried alex-2.2 (seems to be the latest release), but there cabal complains "not in scope buildVerbose" and fails
10:25:13 <ozy`> lament: think of it this way. half the people who still use perl are only there because of CPAN. now imagine that it was suddenly opened up for haskell programs to use.
10:25:18 <pumpkin> Nafai: base?
10:25:23 <Nafai> Weird
10:25:25 <Grizzly`> then i tried darcs alex, and it says it depends on alex already installed
10:25:28 <int80_h> yeah, and what if you want a web app that needs the jvm. do it in clojure!
10:25:32 <pumpkin> Nafai: Arrow relies on it
10:25:34 <Peaker> Nafai: are you with ghc 6.8 or 6.10?
10:25:36 <leimy> Hmmm
10:25:38 <Nafai> 6.8
10:25:47 <pumpkin> oh it's in base 4 at least
10:25:48 <Nafai> On Ubuntu Intrepid
10:25:56 <pumpkin> I haven't used 6.8 much
10:26:29 <thoughtpolice> augustss: also I hit a segfault with llvm-0.6.0.3 and optimizeFunctionCG yesterday
10:26:34 <Peaker> Nafai: oh, 6.10 refactored (.) out of Control.Arrow into Category
10:26:35 <leimy> you can't send functions over a Chan can you? :-)
10:26:43 <Peaker> Nafai: (>>>) was renamed (.) and put in Category, that is
10:26:48 <leimy> Erlang lets you send "fun()" over channels.
10:26:55 <Grizzly`> so... I can't build gtk2hs since i can't get alex installed :(
10:26:58 <dcoutts_> Grizzly`: the latest alex is 2.3.1 from hackage, cabal install alex will install it for you. If it's downloading an older version then you need to cabal update to get the latest list of packages.
10:26:59 <augustss> thoughtpolice: well, it could be your own fault ;)
10:27:03 <Peaker> Nafai: I can rewrite my func stuff to be 6.8 compatible, sec
10:27:07 <Nafai> Thanks :)
10:27:10 <Grizzly`> ahh...
10:27:13 <dcoutts_> Grizzly`: cabal list alex  will say what it thinks the latest version is.
10:27:29 <mux> leimy: I see no reasons why you couldn't
10:27:37 <ozy`> leimy: can't you? that'd be pretty weird...
10:27:40 <leimy> Hmmm
10:27:50 <thoughtpolice> augustss: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1010#a1010
10:27:51 <leimy> I've never honestly tried
10:27:54 <pumpkin> leimy: I could understand not being able to send a function over a socket or something :P but a Chan is all on the same computer
10:27:55 <leimy> I'm just not sure how it'd work.
10:27:56 <roconnor> crap!
10:28:02 <mux> leimy: if it doesn't work, I'd say this is a bug.
10:28:08 <leimy> Ok... I'll try it :-)
10:28:18 <roconnor> Could not find module `Graphics.Rendering.Cairo.SVG':
10:28:22 <leimy> I want to do all but evaluate the function I want to send
10:28:23 <Toxaris> Peaker: not (<<<)?
10:28:25 <SamB_irssi> leimy: the same way doing anything ELSE with functions work
10:28:31 <leimy> so I figure I'll just write the expression with "const"
10:28:35 <roconnor> dcoutts: what version of cairo do I need to get  Graphics.Rendering.Cairo.SVG?
10:28:35 <dcoutts_> roconnor: when you configure gtk2hs, use --enable-svg
10:28:39 <leimy> and evaluate them with () on the other side.
10:28:48 <roconnor> configure?
10:28:51 <Peaker> Toxaris: yeah (.) is flip (>>>)
10:28:59 <dcoutts_> roconnor: yes, when you build it from source.
10:29:03 <SamB_irssi> leimy: just send an unevaluated closure!
10:29:04 <pumpkin> so (.) is (<<<) ?
10:29:07 <roconnor> dcoutts: so the ubuntu package is a no go?
10:29:10 <Grizzly`> dcoutts, what is the propper way to install something globally and in /usr prefix using cabal? run cabal build as normal user, then su and run cabal install --global?
10:29:11 <SamB_irssi> you don't need to use a function for that
10:29:11 <dcoutts_> roconnor: if you're using distro packages then get the svg bit
10:29:17 <leimy> SamB_irssi: that's what const gives me :-)
10:29:25 <leimy> :t const
10:29:26 <lambdabot> forall a b. a -> b -> a
10:29:31 <vixey> (.) (<<<) (fmap) ...  Theres more than one way to do it in haskell
10:29:33 <pumpkin> send an unevaluated clojure!
10:29:35 <leimy> :t const (1 + 2)
10:29:36 <lambdabot> forall t b. (Num t) => b -> t
10:29:48 <roconnor> dcoutts_: svg bit?
10:29:53 <leimy> :t let f=const (1+2) in f()
10:29:54 <lambdabot> forall t. (Num t) => t
10:30:01 <SamB_irssi> leimy: I didn't say unapplied function ... I mean, just send any old value that hasn't been computed yet
10:30:07 <augustss> thoughtpolice: looks bad.  could be my fault
10:30:10 <leimy> > let f = const (1+2) in f()
10:30:11 <lambdabot>   3
10:30:18 <pumpkin> leimy: I don't think the Chan forces it to evaluate
10:30:31 <thoughtpolice> pumpkin: but yes, I might try to get some obj-c stuff up this weekend (I would really like to use c2hs if possible since it makes life so much easier, but I've had a few problems here on OS X with it...)
10:30:31 <Peaker> Nafai: try to repull now
10:30:31 <pumpkin> leimy: bung a Debug.Trace in there and check! :P
10:30:33 <dcoutts_> roconnor: the haskell package is called svgcairo, so debian packages might be something like libghc6-svgcairo-dev
10:30:37 <thoughtpolice> pumpkin: do you mind git? :)
10:30:40 <ddarius> pumpkin: It doesn't.
10:30:50 <pumpkin> thoughtpolice: I mind _not git_ :P
10:30:50 <leimy> SamB_irssi:  I guess my point is
10:30:57 <thoughtpolice> pumpkin: :)
10:31:08 <dcoutts_> Grizzly`: one way is to cabal install --global --root-cmd=sudo, or just run the whole install --global as root
10:31:10 <leimy> (\_ -> 1) and (const 1) are equivalent
10:31:13 <Nafai> @hpaste2
10:31:13 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:31:22 <Nafai> Where's the new hpaste?
10:31:24 <ozy`> @src const
10:31:25 <lambdabot> const x _ = x
10:31:32 <ddarius> @where hpaste2
10:31:32 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
10:31:33 <pumpkin> @where hpaste2
10:31:33 <SamB_irssi> leimy: yes, you could just send (1 + 2)
10:31:33 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
10:31:40 <dcoutts_> Grizzly`: the default for global install is /usr/local which is sensible, you almost certainly to not want to install direct to /usr
10:31:56 <Gracenotes> const is a nice function... its just like the mathematical constant function :)
10:32:03 <SamB_irssi> and that wouldn't force it to evaluate either (though GHC would probably do so anyway because it's easy to see what the result would be ...)
10:32:06 <pumpkin> ddarius: great, that makes Chans even cooler (even though I didn't see any reason for them to break laziness in the first place)
10:32:09 <Gracenotes> *it's
10:32:18 <Nafai> Peaker: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1011#a1011
10:32:28 <leimy> SamB_irssi:  I see what you mean
10:32:29 <SamB_irssi> @hpaste2
10:32:30 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:32:33 <Peaker> Nafai: btw there's a fake table of keys there - its not updating yet because of said model troubles.. basically its enter/escape to go in/out, and arrow keys, and the usual text editing operations
10:32:46 <nomeata> Hi. If I want some basic control over where my output lands on the console (e.g. second line from below), what module should I use?
10:32:54 <pumpkin> thoughtpolice: just let me know what to clone (or @tell if I'm not around) and when :)
10:32:54 <roconnor> dcoutts_: doesn't seem available. :(  Should I nuke my distribution's copy before I install from sources
10:33:00 <Nafai> Peaker: I installed sdl from cabal ("cabal install sdl")
10:33:05 <vixey> nomeata, I'd recommend not using a console at all in that case
10:33:07 <nomeata> System.Console.ANSI has some handy functions, but for example it can not tell me where the lowest line is
10:33:14 <shapr> hmm
10:33:17 <nomeata> vixey: instead?
10:33:18 <Peaker> Nafai: the exception stuff is new in 6.10 too, not sure about the best way to be backwards compatible with 6.8
10:33:20 <dcoutts_> roconnor: they're probably different versions so there's probably no need to uninstall the distro packages.
10:33:23 <Nafai> :(
10:33:28 <Nafai> shapr: Hey!
10:33:35 <Grizzly`> dcoutts, and if i do want?
10:33:38 <Peaker> Nafai: I can just put a stub there...
10:33:49 <Peaker> Nafai: btw, its really worth it to upgrade to 6.10 :)
10:33:56 <dcoutts_> Grizzly`: you don't, but if you did, you'd set the prefix explicitly.
10:34:00 <andun> nomeata: you mean something like ncurses?
10:34:01 <Grizzly`> rofl
10:34:17 <nomeata> andun: maybe, but it’s realy simple stuff :-)
10:34:23 <dcoutts_> Grizzly`: the only reason you might is if you're making distro packages, and you'd not be using the cabal-install program in that case.
10:34:46 <roconnor> dcoutts: how do I label my dependencies for my cabal project?
10:35:24 <nomeata> hmm. maybe I can use System.Console.ANSI if I only use relative movements.
10:35:37 <dcoutts_> roconnor: you mean the build-depends list? or something else? what do you mean by label?
10:35:57 <Nafai> Peaker: I actually was going to see how much work it would be to create a .deb for 6.10
10:35:58 <roconnor> dcoutts_: build dependencies
10:36:20 <andun> nomeata: if you only need something _really_ simple perhaps you can use the environment variables COLUMNS and LINES?
10:36:39 <dcoutts_> roconnor: you list them in the build-depends field, comma separated list with optional version constraints. Look at the user guide or any other .cabal file for examples.
10:37:02 <nomeata> andun: might actually be enough. how does it work, BTW, that these are updated when I resize my terminal?
10:37:21 <Peaker> Nafai: ok, I pushed a new one
10:37:24 <andun> yes they are
10:37:25 <Peaker> Nafai: should work 6.8
10:38:40 <Nafai> Peaker: Still getting the same compile error
10:38:56 <Peaker> Nafai: you sure you pulled?
10:38:59 <Nafai> Yeah
10:39:23 <Nafai> I have commit  633b5a17
10:39:26 <Peaker> Nafai: oh whoops its in a different place
10:40:19 <rwbarton> nomeata: I think you get a signal, SIGWINCH
10:40:34 <nomeata> rwbarton: ah, that’s that signal. I always wondered about this when I was stracing something :-)
10:40:49 <rwbarton> nomeata: but I don't think COLUMNS and LINES actually change.  But I've never tried this.
10:41:05 <Peaker> Nafai: ok sorry, try again?
10:41:11 <hackage> Uploaded to hackage: flow2dot 0.3.1
10:41:36 <lilac> rwbarton: right, COLUMNS and LINES aren't the way to get the terminal size.
10:41:59 <lilac> rwbarton: except if you're talking about a shell script, in which case the shell updates them for you
10:42:13 * lilac digs out the source code to his line editor
10:42:16 <rwbarton> right.  I guess you have to send a control sequence to the terminal
10:42:24 <Peaker> Nafai: the idea is that it should look & feel very much like a text editor, but edit AST's -- so the widgets are all rendered as positioned text, but are actually grids and boxes containing text edits
10:43:03 <lilac> @where hpaste2
10:43:03 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
10:44:44 <lilac> rwbarton: http://moonpatio.com:80/fastcgi/hpaste.fcgi/view?id=1012#a1012
10:44:53 <lilac> ^^ that's what I do, and it works pretty reliably
10:44:54 <Nafai> Peaker: ooo
10:44:56 * Nafai runs
10:45:14 <rwbarton> lilac: ah, that doesn't look too painful
10:45:20 <Peaker> Nafai: nowhere to run :)
10:45:25 <lilac> rwbarton: yeah, it's not too gucky
10:45:26 <rwbarton> nomeata: the above is really for you
10:45:55 <lilac> nomeata: the libcurses bit is completely optional, but i think there are some obscure systems where neither ioctl is available but libcurses /is/
10:45:59 <Peaker> Nafai: basically there's much to improve in the looks department, its less than a week's worth of work, but its already more keyboard-usable than the same information presented in a typical Gtk form :)
10:46:22 <Nafai> Nice!  I got it to work.
10:46:30 <lilac> nomeata: although in such cases, falling back to LINES / COLUMNS is going to be about as good as falling back to curses
10:46:30 <Peaker> Nafai: cool
10:46:33 <Peaker> Nafai: had to do anything?
10:46:39 <vegai> mm, Crypto doesn't install on ghc-6.10. Triggers a compiler bug
10:46:50 <lilac> (since LINES / COLUMNS will be set to the terminfo values by the shell anyway)
10:47:23 <Nafai> Yeah, I can edit the individual boxes
10:47:48 <Nafai> Is anyone here familiar with GHC packaging for Debian/Ubuntu?
10:48:19 <Peaker> Nafai: now the textedit responds to "left/right" keys, if you move right after the end of the text edit, it will go to the next box - simply because the text edit stops stealing the "right arrow" so the container box starts getting that.  Its a really simple design for focus policy
10:48:32 <Peaker> (to the next box/grid element, that is)
10:48:41 <Nafai> I'm wondering how hard it would be to make packages for 6.10
10:48:55 <Nafai> Yeah that is nice
10:49:04 <Peaker> Nafai: I think Debian/Ubuntu are so far behind in the Haskell department that unless someone packages only ghc + cabal-install, its not very useful
10:49:37 <Peaker> "apt-get install ghc-6.10 && apt-get install cabal-install && cabal update && ..." would be nice
10:49:39 <Nafai> That's frustrating
10:49:50 <lilac> nomeata: it'd be worth at least googling for a Haskell wrapper for curses, since that's probably the best way to go
10:49:59 <Peaker> Nafai: I just download ghc-6.10 and run the bootstrap script of cabal-install on every machine I use
10:50:13 <dcoutts_> Peaker: is there a debian ticket to get cabal-install packaged?
10:50:31 <Peaker> dcoutts_: no idea
10:50:50 <dcoutts_> Peaker: someone should check
10:50:51 <Peaker> dcoutts_: I think its against Debian policy to have alternate package managers
10:51:04 <mightybyte> A new article on Happstack: http://www.reddit.com/r/programming/comments/7t4lx/happstack_an_interview_with_matthew_elder/
10:51:07 <int80_h> I should hope so
10:51:24 <Nafai> I might be going to debconf this summer, I might try to organize a Haskell meet-up
10:51:35 <dcoutts_> Peaker: it's not an alternate package manager, it's a per-user and secondary package manager, and also general build tool.
10:51:36 <rwbarton> Peaker: but there is cpan
10:52:19 <Nafai> Because Debian/Ubuntu are great distributions, we should have Haskell be a first-class citizen
10:52:21 <Peaker> I guess there shouldn't be a problem then
10:53:22 <decafbad> interpreters may have their own package managers. almost all have similair tools
10:56:35 <roconnor> svgcairo/Graphics/Rendering/Cairo/SVG.chs:201:2:
10:56:36 <roconnor>     Couldn't match expected type `()' against inferred type `CInt'
10:56:37 <roconnor>       Expected type: Render ()
10:56:39 <roconnor>       Inferred type: Render CInt
10:56:42 <roconnor> dcoutts: ^^ I got a build error
10:57:07 <dcoutts_> roconnor: your cairo is too new for that gtk2hs release. Either downgrade cairo or use the latest version of gtk2hs.
10:57:24 <dcoutts_> roconnor: I think there's a pre-release tarball of gtk2hs 0.10
10:58:03 <dcoutts_> roconnor: cairo made an api change. In C that would be ok, but we get a type error.
10:58:05 <roconnor> I suspect that downgrading cairo on Unbuntu is very hard ?
10:58:13 <int80_h> @seen chessguy
10:58:13 <lambdabot> I saw chessguy leaving #haskell and #novalang 4h 31m 50s ago, and .
10:58:16 <dcoutts_> roconnor: I expect you're right.
10:58:21 <int80_h> bah
10:58:26 <Gracenotes> roconnor: I don't know... I just used apt-get
10:58:34 <roconnor> "In C that would be ok"  god damn C
10:58:52 <Debugger> C doesn't care about types :P
10:59:00 <Debugger> void * all over the place
10:59:16 <int80_h> "if you don't care, I don't care" is the approach
10:59:40 <Badger> int main( void *)
10:59:42 <roconnor> dcoutts_: so basically, what we are saying here is that if I didn't upgrade ubuntu last night in order to get the lastest gtk2hs, then I probably would have been able to build the source?
10:59:44 <roconnor> :P
10:59:46 <dcoutts_> roconnor: in particular, in C you can change a function that returns void to one that returns int and it's ABI compatible (on all standard ABIs)
10:59:55 <dcoutts_> roconnor: yes :-)
11:00:01 <roconnor> god damn it
11:00:17 <roconnor> that is ironic
11:00:28 <dcoutts_> roconnor: you can get the latest (pre)release though
11:01:08 <dcoutts_> http://code.haskell.org/~pgavin/gtk2hs-0.10.0/
11:01:08 <roconnor> dcoutts_: how do you feel about the prerelase
11:01:22 <dcoutts_> roconnor: I've not tried it but some people have :-)
11:01:39 <decafbad> roconnor: did you upgrade from hardy to intrepid or did a minor upgrade?
11:02:12 <roconnor> decafbad: hardy to intrepid
11:02:42 <roconnor> decafbad: I was waiting, but I really wanted svgcairo.  So I figured I needed gtk2hs-0.9.13
11:02:56 <Taejo> dcoutts, so void functions put a return value on the stack?
11:03:01 <roconnor> er libghc-cairo-0.9.13
11:03:11 <roconnor> but apparently that is not the case
11:03:21 <dcoutts_> Taejo: I thought it was in a register
11:03:29 <roconnor> I need libghc-svgcairo-foo, which doesn't exist
11:03:40 <decafbad> roconnor: let me check that cairo downgrade is possible or not
11:03:55 <roconnor> decafbad: thanks
11:04:02 <dcoutts_> Taejo: so for void, the caller is just ignoring the return register, but I could be wrong.
11:04:22 <Taejo> dcoutts_, ah, in that case it wouldn't matter... I thought the standard ABIs did everything on the stack, with registers as a "when you know it's safe" optimisation
11:04:32 <dcoutts_> Taejo: that's my guess anyway. But people certainly do do this and claim it's ABI compatible.
11:05:11 <dcoutts_> Taejo: args are usually passed on the stack, I'm less sure about the return
11:07:43 <decafbad> roconnor: it seems working, get hardy's libcairo2 and libcairo2-dev packages from packages.ubuntu.com and install them with dpkg
11:08:03 <decafbad> roconnor: you also need package version holding capabilites of aptitude
11:10:16 <ksf_> d'oh.
11:10:24 <decafbad> roconnor: oops, synaptic borked. sorry, this wasn't a good idea. don't force downgrading  :)
11:10:42 <ksf> "you failed to identify in time for the nick "irc"".
11:11:53 <roconnor> roconnor: what version of libcairo2 does hardy have?
11:12:15 <decafbad> roconnor: 1.6.0
11:12:53 <roconnor> decafbad: what borked?
11:13:35 <decafbad> roconnor: "synaptic". it's most widely used package manager on ubuntu
11:13:58 <roconnor> decafbad: Oh, I assumed you had a dependency violation
11:14:11 <roconnor> decafbad: I'm reviewing my depencencies on libcairo2
11:14:20 <roconnor> 1.6.0 is the highest I've seen so far
11:15:35 <roconnor> oh
11:15:47 <roconnor> libpango1.0 requires 1.7.2
11:16:08 <dcoutts_> roconnor: I'm sure it's easier to just use the latest gtk2hs version
11:16:15 <roconnor> ya
11:16:40 <roconnor> dcoutts_: if there were no dependencies over 1.6 I'd consider instailling an old cairo
11:17:19 <dcoutts_> roconnor: cairo sits underneath gtk+ in the package dep graph, so best not to mess with it
11:18:52 <shapr> hiya Nafai!
11:19:02 <roconnor> dcoutts_: should I uninstall my distributions gtk2hs before installing 0.10 from source?
11:19:21 <dcoutts_> roconnor: doesn't matter, they're different versions so they will not clash
11:22:23 <Taejo> dcoutts_, in cdecl on x86, all parameters go on the stack and return values go in EAX
11:22:30 <Peaker> hmm, ghc's error messages are nicer for  f $ g $ h $ x   than f . g . h $ x
11:22:40 <icqn> @src lookup
11:22:40 <lambdabot> lookup _key []          =  Nothing
11:22:40 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
11:22:40 <lambdabot>                         | otherwise = lookup key xys
11:22:47 <dcoutts_> Taejo: ok, that explains it then
11:23:25 <vixey> lookup  key ((x,y):xys)
11:23:28 <vixey>  | key == x  = Just y
11:23:31 <vixey>  | otherwise = lookup key xys
11:23:35 <vixey> is how I wrote it
11:25:21 <BMeph> Peaker: I'd say that's because there's more wrong with f $ g $ h $ x than f . g . h $ x. ;)
11:25:25 <icqn> vixey ?
11:25:34 <vixey> what
11:25:41 <Peaker> BMeph: heh I convert to the ugly first form to clear the error messages and then when I fix it I convert back :)
11:26:03 <vixey> icqn, #
11:26:20 <icqn> vixey, what was that?
11:26:27 <Peaker> > let lookup key = fmap snd . listToMaybe . filter ((==key) . fst) in (lookup 5 [], lookup 5 [(1,2),(5,6)])
11:26:29 <lambdabot>   (Nothing,Just 6)
11:26:37 <vixey> icqn, no idea what you are asking
11:29:19 <icqn> vixey, what was this "is how i wrote it"- part about?
11:29:43 <vixey> icqn, about 'lookup'
11:31:41 <icqn> Do some one wants to remove this _ character?  in "lookup _key []          =  Nothing" in
11:31:45 <icqn> @src lookup
11:31:45 <lambdabot> lookup _key []          =  Nothing
11:31:45 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
11:31:45 <lambdabot>                         | otherwise = lookup key xys
11:31:56 <vixey> icqn, why remove it?
11:32:22 <ksf> does ghc support that?
11:32:28 <Gracenotes> if might be nice if there were a [(a, b)] -> a -> [b]
11:32:34 <vixey> > let _x = _x in 3
11:32:35 <lambdabot>   3
11:32:36 <luqui> variables are allowed to start with underscores
11:32:37 <ksf> I saw it on the list of rjected h' proposal.
11:32:43 <ksf> ah.
11:32:45 <ksf> sur.
11:33:05 <Gracenotes> it would be easy to implement too
11:33:06 <ksf> that one was about data decls and similar uppercase stuff.
11:33:11 <icqn> vixey, what is it for? looks ugly
11:33:20 <ksf> documenting that it's unused.
11:33:27 <ksf> ...but still naming it.
11:33:31 <Gracenotes> _
11:33:32 <rwbarton> the reason to write  lookup _key [] = Nothing  is so that ghc with -Wall won't give a warning
11:33:34 <ksf> see -Wsomething
11:34:50 <Gracenotes> lookups key xs = map snd $ filter ((==key) . fst) xs
11:34:58 <psnively> Hello.
11:35:09 <Gracenotes> and a useful function too :/
11:35:35 <roconnor> @seen jeffwheeler
11:35:35 <lambdabot> I saw jeffwheeler leaving #haskell 3d 22h 59m 2s ago, and .
11:35:37 <Gracenotes> greetings, psnively
11:35:43 <psnively> :-)
11:36:11 <rwbarton> :t let lookup key xs = msum [ if x == key then return y else mzero | (x, y) <- xs ] in lookup
11:36:13 <lambdabot> forall t t1 (m :: * -> *). (MonadPlus m, Eq t) => t -> [(t, t1)] -> m t1
11:38:46 <newsham> ?src lookup
11:38:46 <lambdabot> lookup _key []          =  Nothing
11:38:46 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
11:38:46 <lambdabot>                         | otherwise = lookup key xys
11:39:22 <luqui> :t let lookup key xs = msum [ guard (x == key) >> return y | (x, y) <- xs ] in lookup
11:39:23 <lambdabot> forall t t1 (m :: * -> *). (MonadPlus m, Eq t) => t -> [(t, t1)] -> m t1
11:39:25 <BMeph> :t let lookup key xs = msum [ guard (x == key)>> return y | (x, y) <- xs ] in lookup
11:39:26 <lambdabot> forall t t1 (m :: * -> *). (MonadPlus m, Eq t) => t -> [(t, t1)] -> m t1
11:39:33 <vixey> :o
11:39:34 <BMeph> luqui: Jinx!
11:39:40 <luqui> 12345678910
11:40:01 <BMeph> 0123456789ABCDEF
11:40:11 <luqui> daft!
11:40:26 <BMeph> ...punk. ;p
11:40:39 <nomeata> andun, rwbarton, lilac: Thanks for your hints, the result for now is done: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/concurrentoutput-0.1
11:40:41 <luqui> Hmm, I've used this pattern quite a bit:  guarded c x = guard c >> return x
11:40:53 <nomeata> I chose to just use plain ANSI escape sequences for now.
11:41:03 <newsham> i like   guarded p f x = guard (p x) >> return (f x)
11:41:06 <vixey> :t liftA2 (>>) guard return
11:41:07 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m Bool
11:41:12 <hackage> Uploaded to hackage: concurrentoutput 0.1
11:41:15 <vixey> :/
11:41:19 <BMeph> luqui: I believe dmwit calls it 'ensure'. :)
11:41:54 <luqui> newsham, i like the feel of that better, but I don't think it's quite as convenient in most cases...
11:42:07 <vixey> @let liftF2 m f g = \x y -> m (f x) (g y)
11:42:08 <lambdabot>  Defined.
11:42:10 <luqui> but maybe it is. I hadn't considered it.
11:42:15 <vixey> :t liftF2 (>>) guard retur
11:42:16 <lambdabot> Not in scope: `retur'
11:42:17 <vixey> :t liftF2 (>>) guard return
11:42:17 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => Bool -> b -> m b
11:42:49 <newsham> useful with unfoldr
11:42:59 <Saizan> ?type liftF2
11:43:00 <lambdabot> forall t2 t3 t4 t t1. (t2 -> t3 -> t4) -> (t -> t2) -> (t1 -> t3) -> t -> t1 -> t4
11:43:17 <nomeata> BTW, has some checked hackage for license problems? E.g. a library that is BSD, but that depends on a GPL library?
11:43:39 <vixey> http://en.wikipedia.org/wiki/Pattern_matching
11:43:41 <vixey> wtf
11:43:42 <nomeata> It should be doable quite easily...
11:43:46 <vixey> it's a haskell tutorial
11:44:28 <chessguy_work> nomeata, i suspect that dcoutts_ would be the one to ask
11:45:14 <roconnor> Not in scope: type constructor or class `Event'
11:45:20 <roconnor> Not in scope: data constructor `Expose'
11:45:26 <dcoutts_> nomeata: technically it's not a problem, but it's obviously useful to know the licenses for transitive deps to get the effective license of any package.
11:45:29 <roconnor> Not in scope: `eventArea'
11:45:30 <igel> can't hugs parse code containing #ifdefs?
11:45:30 <MyCatVerbs> vixey: that seems fair enough. The only other languages I know of offhand where pattern matching is heavily used are ML and Prolog.
11:45:40 <roconnor> dcoutts_: ^^ should I expect these new errors
11:45:53 <roconnor> dcoutts: with gtk2hs 0.10.0?
11:46:00 <dcoutts_> roconnor: you mean building it?
11:46:04 <nomeata> dcoutts_: right. BSD is never a problem, as it can be anything. basically a pattern match with  _ :_)
11:46:06 <MyCatVerbs> vixey: IMO, ML's syntax is less pretty than Haskell's (though it's arguably a toss-up), and discussing Prolog would've likely gotten the issue confused with unification.
11:46:27 <dcoutts_> nomeata: but I mean a bsd package depending on a gpl package
11:46:39 <Toxaris> vixey: the best is the "Pattern Matching in Mathematica" section, which uses, surprise, Haskell syntax
11:46:50 <nomeata> dcoutts_: right, I understood that :-)
11:48:05 <BMeph> newsh: It's so useful, I have it in my Utility module, as 'unFFunc'. :)
11:48:23 <Peaker> @let infixr 2 ~> ; (x ~> y) f = x >>> f >>> y
11:48:23 <lambdabot>  Defined.
11:48:26 <Toxaris> MyCatVerbs: the article starts by defining sequence patterns and tree patterns, then states some nonsense about regular expressions, and explains Haskell pattern matching at great length
11:48:27 <roconnor> dcoutts_: oops.  I mean when building my program
11:48:46 <roconnor> dcoutts_: installing the gtk prerelease worked fine
11:49:04 <roconnor> dcoutts_: but it looks like you have made an interface change
11:49:14 <roconnor> dcoutts_: so my code doesn't work
11:49:40 <newsham> what does unFFunc mean?
11:50:52 <BMeph> newsham: UnFold Function. :)
11:51:25 <dcoutts_> roconnor: I've not made any change, but it looks like the module was switched over to a new one.
11:51:32 <newsham> hmm.. guarded = unfold function?  i dont get the name.
11:51:44 <roconnor> dcoutts_:  what does that mean?
11:51:55 <newsham> oh... "funciton useful for use with unfoldr"?
11:52:13 <rwbarton> :t (\m f g x y -> m (f x) (g y), \m f g x y -> (.) (.) (.) m f x g y)
11:52:14 <lambdabot> forall t t1 t2 t3 t4 t5 a b a1 t6. ((t2 -> t3 -> t4) -> (t -> t2) -> (t1 -> t3) -> t -> t1 -> t4, (b -> t5 -> t6) -> (a -> a1 -> b) -> a1 -> a -> t5 -> t6)
11:52:23 <dcoutts_> roconnor: oh, did you build with --disable-deprecated?
11:52:29 <newsham> lately I just define   unfoldUntil = unfoldr (\x -> guard (not (p x)) >> return (f x))
11:52:37 <newsham> unfoldUntil p f = ...
11:52:46 <roconnor> dcoutts_:  I did configure --enable-svg
11:52:59 <roconnor> dcoutts_: it's hard to compare to before since I was using a distribution package
11:53:00 <newsham> usually i dont need to bother with the Maybe in unfoldr.
11:53:24 <roconnor> dcoutts_: but this is the code I copied form the examples you pointed me to earlier
11:53:25 <dcoutts_> roconnor: I don't see why it should not be exported, it's clearly in Graphics/UI/Gtk/Gdk/Events.hsc and that module is re-exported from the top
11:54:15 <roconnor> import Graphics.UI.Gtk hiding (fill)
11:54:17 <roconnor> import Graphics.Rendering.Cairo
11:54:21 <nolrai_East> I would put this on hpaste but its down.
11:54:22 <roconnor> dcoutts_: that should get it right?
11:54:32 <dcoutts_> roconnor: should do
11:54:38 <nolrai_East> is there a better way to write:
11:54:38 <BMeph> @where hpaste2
11:54:39 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
11:54:58 <nolrai_East> thanks
11:55:02 <dcoutts_> roconnor: you can check in ghci, it's a record member of Event exported from Graphics.UI.Gtk.Gdk.Events
11:55:03 <BMeph> nolrai_East: I made you a hpaste, but I eated it. ;)
11:55:53 <MyCatVerbs> Toxaris: okay, it should really really have links to finite automata and suffix trees too, but still. It's nowhere near off topic, at least.
11:56:49 <rwbarton> @pl \a b c d -> a (b c d)
11:56:50 <lambdabot> (.) . (.)
11:56:59 <vixey> @pl \a b c d -> a (b c a d)
11:56:59 <lambdabot> ap ((.) . (.) . (.)) (flip flip)
11:56:59 <Toxaris> MyCatVerbs: yeah thats true. actually, I don't really understand the goals of wikipedia anyway
11:57:02 <vixey> @pl \a b c d -> a (b a c a d)
11:57:02 <lambdabot> ap ((.) . (.) . (.)) (flip =<< (flip .) . flip id)
11:57:05 <rwbarton> @pl \a b c d e -> a (b c d e)
11:57:06 <lambdabot> (.) . (.) . (.)
11:57:12 <roconnor> Prelude Graphics.Rendering.Cairo Graphics.UI.Gtk> :type Event
11:57:13 <roconnor> <interactive>:1:0: Not in scope: data constructor `Event'
11:57:16 <roconnor> dcoutts_: ^^
11:57:32 <vixey> @pl \a b c d e -> e (a b b a) (d b d b)
11:57:33 <lambdabot> (const .) . (`ap` (flip =<< join . flip id)) . (((.) . flip . flip id) .) . (flip =<< join)
11:57:44 <dcoutts_> roconnor: I said try module Graphics.UI.Gtk.Gdk.Events
11:58:01 <roconnor> oh ya, well if I import that, it'll work
11:58:19 <dcoutts_> roconnor: and Event is a type not a data constructor
11:58:23 <rwbarton> :t (.) (.) ((.) (.) (.)) (.) (.)
11:58:24 <lambdabot> forall a b c a1 b1. (b1 -> b -> c) -> (a -> b1) -> a -> (a1 -> b) -> a1 -> c
11:58:25 <Gracenotes> does anyone off-hand know how to include >'s in grep search strings?
11:58:32 <roconnor> dcoutts_: it is both
11:58:37 <mauke> grep 'wat>'
11:59:01 <beelsebob> @pl \a b c d e f g h i j k l m -> i (a b d (c d f e (j k) (j k) (j l m d k i)) (g h) a
11:59:01 <lambdabot> (line 1, column 83):
11:59:01 <lambdabot> unexpected end of input
11:59:01 <lambdabot> expecting variable, "(", operator or ")"
11:59:09 <Gracenotes> ah... thanks... I don't know what was wrong before
11:59:09 <dcoutts_> roconnor: oh yes, you're right, there's a generic Event constructor too
11:59:11 <beelsebob> @pl \a b c d e f g h i j k l m -> i (a b d (c d f e (j k) (j k) (j l m d k i)) (g h) a)
11:59:14 <lambdabot> (((((((ap ((.) . (.) . (.) . (.)) .) .) .) .) .) .) .) . ap (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((
11:59:14 <lambdabot> ((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((flip .) .) .) .) .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) . (((((((((((flip .) .) .) .) .) .) .) .)
11:59:14 <lambdabot> .) .) .) . ((((((.) .) .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((flip .) .) .) .) .) .
11:59:14 <lambdabot> ) .) .) .) . flip flip (flip ap (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . (flip .) . ((flip .) .) . flip (flip . (flip .))) . (flip .) . ((flip .) .) . ((((.) .) .) .) . (((ap .) .) .) . (
11:59:17 <lambdabot> (((ap .) .) .) .) . ((((((.) .) .) .) .) .) . ((((((.) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((ap .) .) .) . ((((ap .) .) .) .) . ((((.) .) .) .) . (flip .)) id) . ((.) .) . (ap .)
11:59:20 <lambdabot>  . (((.) .) .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . (((.) .) .)) id
11:59:21 <ehird> ...
11:59:22 <Gracenotes> erm
11:59:22 <lambdabot> optimization suspended, use @pl-resume to continue.
11:59:22 <beelsebob> oops
11:59:25 <Peaker> beelsebob: thanks
11:59:26 <roconnor> dcoutts_: my point is that I now have to import Graphics.UI.Gtk.Gdk.Events, but last version I didn't.
11:59:32 <vixey> @pl-resume
11:59:33 <CosmicRay> https://www.ohloh.net/languages/compare?commit=Update&l0=haskell&l1=-1&l2=-1&measure=contributors <-- big buildup to ghc 6.10 being released?
11:59:34 <roconnor> dcoutts_: is this the expected result?
11:59:36 <beelsebob> maybe we need to have a spam limit on that
11:59:38 <beelsebob> >.<
11:59:38 <lambdabot> (((((((ap ((.) . (.) . (.) . (.)) .) .) .) .) .) .) .) . join (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((
11:59:38 <lambdabot> ((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((flip .) .) .) .) .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) . (((((((((((flip .) .) .) .) .) .) .) .
11:59:38 <lambdabot> ) .) .) .) . ((((((.) .) .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((flip .) .) .) .) .)
11:59:38 <lambdabot>  .) .) .) .) . flip flip (flip ap (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . (flip .) . ((flip .) .) . flip (flip . (flip .))) . (flip .) . ((flip .) .) . ((((.) .) .) .) . (((ap .) .) .) .
11:59:41 <lambdabot>  ((((ap .) .) .) .) . ((((((.) .) .) .) .) .) . ((((((.) .) .) .) .) .) . flip flip id . (flip .) . ((flip .) .) . (((ap .) .) .) . ((((ap .) .) .) .) . ((((.) .) .) .) . (flip .)) . ((.) .) . (ap .)
11:59:43 <ehird> XD
11:59:44 <lambdabot>  . (((.) .) .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . (((.) .) .) . (((.) .) .))
11:59:46 <lambdabot> optimization suspended, use @pl-resume to continue.
11:59:48 <Peaker> vixey: thank you too!
11:59:49 <Gracenotes> you done killed the lambdabot
11:59:51 <Deewiant> @pl \x -> x
11:59:51 <lambdabot> id
11:59:56 <ehird> @pl-resume
11:59:56 <lambdabot> pointless: sorry, nothing to resume.
11:59:59 <ehird> :<
12:00:00 <vixey> @pl (\x -> x) (\x -> x)
12:00:00 <lambdabot> id
12:00:10 <vixey> @pl ((\x -> x) (\x -> x)) ((\x -> x) (\x -> x))
12:00:10 <lambdabot> id
12:00:14 <Deewiant> ehird: I was afraid someone would continue :-P
12:00:21 <Taejo> @pl id . id . id . id
12:00:21 <lambdabot> id
12:00:22 * beelsebob giggles
12:00:27 <mauke> @pl (\x _ -> x x) (\x _ -> x x)
12:00:30 <lambdabot> (const . ap id id) (const . ap id id)
12:00:30 <lambdabot> optimization suspended, use @pl-resume to continue.
12:00:40 <CosmicRay> don't make me resurrect megamonad.
12:00:47 <Taejo> @pl iterate id (.id)
12:00:47 <lambdabot> iterate id id
12:00:57 <Peaker> @pl \f -> f f
12:00:59 <vixey> 2pl \x -> x (x x) (x (x x) (x (x x) x) x) (x x) (x x (x x))
12:01:04 <vixey> @pl \x -> x (x x) (x (x x) (x (x x) x) x) (x x) (x x (x x))
12:01:13 <beelsebob> hmm
12:01:15 <Taejo> stupid \bot, iterate id id == repeat id
12:01:16 <roconnor> @type iterate id (.id)
12:01:25 <beelsebob> I wonder if it's possible to get the bot to generate a figlet by doing that
12:01:25 <CosmicRay> @megamonad
12:01:30 * beelsebob must find the perfect expression
12:01:36 <dcoutts_> roconnor: I don't see why that should be the case, if you look at the code for Graphics.UI.Gtk, it clearly re-exports that module. Unless they've changed the tarball without changing the darcs version.
12:01:42 <BMeph> @type iterate (.id) id
12:01:46 <ehird> @pl (\x -> x x) (\x -> x x)
12:01:57 <Deewiant> @bot
12:01:57 <lunabot>  :)
12:02:04 <ehird> lol ded
12:02:04 <jeffersonheard> @seen conal
12:02:10 <BMeph> @type iterate (.id)
12:02:10 <ehird> hahahahaha
12:02:11 <Deewiant> vixey: you killed \bot
12:02:15 <ehird> no
12:02:19 <ehird> me Deewiant
12:02:28 <ehird> no
12:02:29 <Deewiant> no, it was Peaker
12:02:30 <ehird> vixey
12:02:32 <vixey> x (x x) (x (x x) (x (x x) x) x) (x x) (x x (x x)) <-- the funniest joke in the world (in one combinator basis)
12:02:35 <ehird> oh
12:02:44 <beelsebob> yeh... thanks Peaker
12:02:45 <beelsebob> >.>
12:02:46 <Deewiant> Taejo still got a response, Peaker didn't
12:02:48 <nolrai_East> Can some one look at my hpastetwo?
12:02:49 <jeffersonheard> The Aristocrats
12:02:56 <lament> it's funnier if you use 'o' instead of 'x'
12:02:59 <Peaker> Deewiant: lambdabot handles my pl ok
12:03:00 <roconnor> dcoutts_: is the code in gtk2hs-0.10.0/gtk/Graphics/UI/Gtk.hs ?
12:03:03 <dcoutts_> roconnor: to check you could compare the file gtk/Graphics/UI/Gtk.hs.pp in the tarball and the current darcs version
12:03:12 <Deewiant> Peaker: yes, ordinarily :-P
12:03:14 <dcoutts_> roconnor: yes, but hs.pp
12:03:23 <Deewiant> (But yeah, most likely it was indeed vixey.)
12:03:39 <vixey> not naming any names or anything
12:03:49 <Deewiant> Exactly
12:03:54 * beelsebob is proud to have got away with not being blamed for this
12:03:56 <beelsebob> >.>
12:03:59 <roconnor> dcoutts_: there is no Events module exported
12:04:05 * vixey too
12:04:27 <dcoutts_> roconnor: ok, diff it against the darcs version and go and complain on the gtk2hs users list
12:04:27 <Deewiant> I place partial blame on roconnor, CosmicRay, BMeph and ehird for continuing to bombard it with commands ;-)
12:04:28 <roconnor> \o/ I found a bug!
12:04:28 <conal> jeffersonheard: hey there
12:04:36 <ehird> lol
12:04:43 <ray> bombard it with comonads
12:04:54 <Deewiant> That'd've been even worse
12:04:55 <beelsebob> poor lambdabot, she needs a big cookie when she gets back
12:04:59 <roconnor> dcoutts_: do I have to subscribe to a mailing list?
12:05:00 <jeffersonheard> Hi, conal.  I'm pretty well done with the latest interface to Hieroglyph
12:05:02 <Deewiant> lambdabot--
12:05:11 <Peaker> @bot
12:05:12 <lunabot>  :)
12:05:22 <dcoutts_> roconnor: I expect so
12:05:22 <jeffersonheard> Thought you might want to look at it before I unleashed it on an unsuspecting populace
12:05:32 <conal> jeffersonheard: i'd be happy to.
12:05:41 <roconnor> dcoutts_: is there a bugtracker?
12:05:52 <conal> jeffersonheard: is the semantic model spelled out in the code?
12:05:53 <dcoutts_> roconnor: yes, see the gtk2hs homepage for the link
12:06:12 <Peaker> > concat . cycle $ "A bot has returned. "
12:06:13 <PeakerLambda>  Terminated
12:06:17 <roconnor> dcoutts_: darcs get cvs.haskell.org/darcs/gtk2hs ?
12:06:20 <vixey> @pl \x -> x (x x) (x (x x) (x (x x) x) x) (x x) (x x (x x))
12:06:21 <PeakerLambda> ap id (join id) `ap` join (ap id (join id) `ap` join (ap id (join id))) `ap` join id `ap` ap (join id) (join id)
12:06:44 <vixey> :t join id
12:06:45 <PeakerLambda>     Occurs check: cannot construct the infinite type: m = (->) (m a)
12:06:45 <PeakerLambda>     Probable cause: `id' is applied to too few arguments
12:06:45 <PeakerLambda>     In the first argument of `join', namely `id'
12:06:48 <dcoutts_> roconnor: see the gtk2hs homepage for the link, but you don't need to get the whole thing to compare one file
12:06:49 <ehird> @pl \f -> f f
12:06:50 <jeffersonheard> conal: better than it was, certainly.  I'm still working on documenting things, and I'm sure there are places where i need to change names that I haven't yet.
12:06:50 <PeakerLambda> join id
12:07:01 <jeffersonheard> but it's close
12:07:29 <roconnor> http://darcs.haskell.org/darcsweb/darcsweb.cgi?r=gtk2hs :P
12:07:35 <Taejo> :t \f -> f f
12:07:36 <PeakerLambda>     Occurs check: cannot construct the infinite type: t = t -> t1
12:07:36 <PeakerLambda>     Probable cause: `f' is applied to too many arguments
12:07:36 <PeakerLambda>     In the expression: f f
12:07:39 <roconnor> that's what they get for using python!!
12:07:42 <Taejo> :t join id
12:07:43 <PeakerLambda>     Occurs check: cannot construct the infinite type: m = (->) (m a)
12:07:43 <PeakerLambda>     Probable cause: `id' is applied to too few arguments
12:07:43 <PeakerLambda>     In the first argument of `join', namely `id'
12:07:44 <dcoutts_> roconnor: no, it's on code.haskell.org
12:07:59 <dcoutts_> roconnor: the links are all on gtk2hs homepage
12:08:49 <conal> jeffersonheard: cool.
12:09:00 <jeffersonheard> This time, conal, a visualization is f data -> Visual,
12:09:19 <jeffersonheard> A Visual is an unstructured collection of primitives meant to be seen as a whole
12:09:40 <jeffersonheard> that's the core of my implementation
12:09:52 <jeffersonheard> and my idea behind it
12:10:07 <nolrai_East> BMeph: thanks :P
12:10:35 <conal> jeffersonheard: your implementation == your semantics?
12:11:15 <Peaker> > concat . cycle $ "A bot has returned. "
12:11:16 <PeakerLambda>   Couldn't match expected type `[a]'
12:11:25 <Peaker> > concat . repeat $ "A bot has returned. "
12:11:26 <PeakerLambda>   "A bot has returned. A bot has returned. A bot has returned. A bot has retu...
12:11:33 <jeffersonheard> the part that is exposed to the user.  At least, I feel this is true.  I've had a wide canyon to cross in only a few days to make it towards semantic thinking.
12:11:33 <mauke> concat . repeat = cycle
12:11:42 <conal> woot!  new blog post: http://conal.net/blog/posts/what-is-automatic-differentiation-and-why-does-it-work/
12:11:43 <Peaker> oops :-)
12:11:47 * beelsebob is really tempted to throw PeakerLambda that expression to @pl again
12:11:57 <PeakerLambda> Title: Conal Elliott » What is automatic differentiation, and why does it work?, http://tinyurl.com/db74cl
12:12:49 <conal> jeffersonheard: i'm glad you're moving in that direction :)
12:13:10 <jeffersonheard> conal: I know you are.  It's simplified my implementation considerably
12:13:59 <jeffersonheard> conal: I'm still not entirely happy with the way interactivity is handled, but I like the way that data maps directly to a visual.  I'm not enamoured, truth be told, of FRP, and I hesitate to move in that direction for interactivity
12:14:01 <conal> jeffersonheard: sometime soon, i hope you blog about your experience in shifting your thinking and the benefits.  to help spread the word.
12:14:07 <jeffersonheard> I plan on it
12:15:12 <conal> jeffersonheard: maybe in the process you'll come up with a semantically founded approach to interactivity other than frp.
12:16:01 <chessguy_work> conal++
12:16:19 <conal> :D
12:16:21 <jeffersonheard> for now, my model of interactivity is a fold across an infinite stream of data, where the data consists of user input
12:17:21 <conal> i'm excited about my new automatic differentiation (AD) post, as it cleared up my fuzziness on what is *really* going on in AD, beyond the mechanics.  what it all *means*.  and i'm delighted that yet again, type class morphisms are at the heart of the interpolation and its correctness.
12:17:30 <roconnor> jeffersonheard: hey, I'm think of exactly the same thing
12:17:36 <roconnor> conal++
12:17:47 <pumpkin> conal++
12:17:51 <pumpkin> @karma conal
12:17:52 <PeakerLambda> conal has a karma of 3
12:17:56 <jeffersonheard> conal++
12:18:07 <mauke> preflex: karma conal
12:18:07 <preflex>  karma for conal: 12
12:18:12 <conal> whee! :D
12:18:19 <Badger> conal++
12:18:24 <mauke> preflex: karma php programmers
12:18:24 <preflex>  karma for php programmers: -1
12:18:30 <Badger> heh
12:18:38 <Gracenotes> preflex: karma haskell
12:18:39 <preflex>  karma for haskell: 16
12:19:17 <Gracenotes> it's true, Haskell is only negative 16000% as good as PHP programmers :/
12:19:38 <mauke> preflex: karma php
12:19:39 <preflex>  karma for php: -67
12:19:48 <jeffersonheard> roconner: yes?
12:19:53 <Gracenotes> >_>
12:19:54 <Badger> preflex: karma c
12:19:54 <preflex>  karma for c: 59482
12:20:02 <Badger> :D
12:20:14 <Gracenotes> heh
12:20:45 <ray> see, this is why C should be renamed to C++ and C++ should be renamed to C++--
12:20:50 <pumpkin> preflex: karma pumpkin
12:20:50 <preflex>  karma for pumpkin: 5
12:20:50 <Gracenotes> preflex: karma c++
12:20:52 <preflex>  karma for c++: -25
12:20:57 <ray> that way karma bots can keep good score
12:21:00 <pumpkin> c++--
12:21:08 <jeffersonheard> roconnor: my implementation of the fold is a bit clunky at the moment, partially because it's based on the code that I wrote before I had the model nailed down
12:21:14 <jeffersonheard> --c++--
12:21:19 <Taejo> preflex: karma c
12:21:19 <preflex>  karma for c: 59485
12:21:21 <Taejo> preflex: karma c++
12:21:22 <preflex>  karma for c++: -26
12:21:24 <Taejo> c++--
12:21:27 <Taejo> preflex: karma c
12:21:28 <preflex>  karma for c: 59486
12:21:32 <Taejo> preflex: karma c++
12:21:32 <preflex>  karma for c++: -27
12:21:36 <ray> =D
12:21:41 <jeffersonheard> preflex: karma lisp
12:21:42 <preflex>  karma for lisp: 5
12:21:42 <roconnor> jeffersonheard: my application is a turn based game, so I hope this makes interactivity a little bit easier to handle.
12:21:48 <Taejo> c++++
12:21:52 <mauke> you know, "c++--" doesn't change c's karma
12:22:04 <Taejo> preflex: karma c+++
12:22:04 <preflex>  c+++ has no karma
12:22:08 <Taejo> preflex: karma c++
12:22:08 <preflex>  karma for c++: -26
12:22:09 <jeffersonheard> preflex: karma scheme
12:22:10 <preflex>  karma for scheme: 1
12:22:12 <Gracenotes> which programming language accepts c++-- ? :)
12:22:13 <jeffersonheard> scheme++
12:22:20 <tromp__> c--++
12:22:23 <Gracenotes> preflex: karma miranda
12:22:23 <preflex>  karma for miranda: 1
12:22:24 <mauke> Gracenotes: c++
12:22:29 <Gracenotes> wow. jeez
12:22:38 <Gracenotes> preflex: karma factor
12:22:38 <preflex>  karma for factor: 1
12:22:40 <jeffersonheard> karma: algol
12:22:45 <mauke> assuming c has an appropriate type/overloaded operators
12:22:46 <Peaker> Gracenotes, mauke: C doesn't?
12:22:48 <trofi> haskell = fix (1+)
12:22:49 <jeffersonheard> preflex: karma algol
12:22:49 <preflex>  algol has no karma
12:22:53 <jeffersonheard> excellent
12:22:56 <Badger> heh
12:23:01 <Peaker> oh of course not, (c++) is an rvalue
12:23:02 <Badger> preflex: karma c--
12:23:02 <preflex>  karma for c--: 6
12:23:06 <mauke> Peaker: no, because C doesn't support operator overloading
12:23:15 <tromp__> preflex: karma haskell
12:23:15 <preflex>  karma for haskell: 16
12:23:18 <roconnor> dcoutts_: Events is not exported (directly) in the darcs version
12:23:25 <liff> if old-locale is old then what's the new locale?
12:23:26 <jeffersonheard> preflex: karma java
12:23:26 <Gracenotes> so c++-- is interpreted as (c++)-- in c++?
12:23:26 <preflex>  karma for java: -17
12:23:28 <roconnor> dcoutts_: I suppose it still migh be exported indirectly
12:23:33 <ksf> mauke, sure it does.
12:23:34 <roconnor> dcoutts_: should I check that?
12:23:41 <mauke> Gracenotes: yes (also in C)
12:23:41 <ksf> macros.
12:23:49 <mauke> ksf: no
12:23:50 <tromp__> preflex: karma go
12:23:50 <preflex>  karma for go: 1
12:24:00 <Gracenotes> preflex: karma lambdabot
12:24:01 <preflex>  karma for lambdabot: 2
12:24:07 <Gracenotes> preflex: karma preflex
12:24:07 <preflex>  karma for preflex: 11
12:24:12 <Peaker> mauke: I didn't know all forms of ++ and -- convert to rvalue
12:24:12 <tromp__> preflex: karma karma
12:24:13 <preflex>  karma for karma: 4
12:24:41 <tromp__> preflex: karma god
12:24:41 <preflex>  god has no karma
12:25:05 <jeffersonheard> roconnor: my application is general interactivity for a visualization.  I need to be able to interact with the surface of a window with a number of different methods.
12:25:13 <Badger> preflex: karma goto
12:25:14 <preflex>  karma for goto: 4
12:25:18 <Badger> :)
12:25:37 <jeffersonheard> Mouse, continuous stream of time valued data, multitouch gesture engine, etcetera
12:25:43 <SamB_irssi> huh. I think gmane needs donations designated for weaverd ...
12:25:43 <tromp__> preflex: karma obama
12:25:44 <preflex>  karma for obama: 7
12:25:45 <ksf> (-1)--
12:25:59 <ksf> "\t"--
12:26:13 <conal> jeffersonheard: really continuous i hope, rather than discrete.
12:26:15 <Gracenotes> > maxBound :: Int
12:26:16 <PeakerLambda>   2147483647
12:26:31 <conal> jeffersonheard: i.e., temporally resolution-independent
12:26:50 <ray> > maxBound :: Integer
12:26:51 <PeakerLambda>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
12:26:51 <PeakerLambda>    arising...
12:27:08 <jeffersonheard> conal: yes, that's the idea
12:27:23 <conal> :)
12:27:26 <jeffersonheard> I may be wrong in the way I've implemented it so far, but that's where I'm going.
12:27:26 <conal> continuity++
12:27:31 <Gracenotes> wow, Bounded supports up to 15-tuples
12:27:35 <Gracenotes> scary stuff.
12:27:45 <conal> composability++
12:27:45 <mauke> data D a = D a (D a)
12:27:49 <mauke> dadaism?
12:27:54 <Badger> FRP++
12:28:04 <conal> mauke:  apparently!
12:28:04 <ray> data Art = Dead
12:28:11 <ksf> you won't get a truly continuous stream of mouse positions w/o interpolating, it's physically impossible.
12:28:31 <jeffersonheard> ksf, no, but you get them along a continuous stream of time
12:28:42 <jeffersonheard> the fact that some of that time is uninteresting is unimportant
12:28:44 <dublpaws> mauke: is data D a = D a (D a)  legal syntax?
12:28:44 <jeffersonheard> time is still time
12:29:04 <Taejo> ray: (_|_ :: Art) == television
12:29:11 <mauke> dublpaws: yes
12:29:19 <dublpaws> \o/ thanks.
12:29:22 <mauke> it's just an infinite list
12:29:36 <mauke> (data List a = Cons a (List a))
12:29:41 <roconnor> dcoutts_: http://hackage.haskell.org/trac/gtk2hs/ticket/1152
12:29:51 <PeakerLambda> Title: #1152 (Graphics.UI.Gtk.Gdk.Events not exported by Graphics.UI.Gtk) - Gtk2Hs - Tr ...
12:29:57 <dublpaws> seems like the data keyword is used for a whole lotta things.
12:30:08 <tromp__> > minBound :: ((),Bool,Char,Int,Data.Word8,Data.Word16,Float,Double)
12:30:09 <PeakerLambda>   Not in scope: type constructor or class `Data.Word8'Not in scope: type cons...
12:30:14 <ray> television == undefined
12:30:15 <conal> ksf: i've found that continuous models (time or space) are more composable.  i keep the discrete stuff on the outside of the model so it doesn't interfere with composability.  which means something like reconstruction (e.g., interpolation) on the input and sampling on the output.
12:30:23 <tromp__> > minBound :: ((),Bool,Char,Int,Float,Double)
12:30:24 <PeakerLambda>   No instances for (GHC.Enum.Bounded GHC.Types.Float,
12:30:24 <PeakerLambda>                    GHC....
12:30:33 <tromp__> > minBound :: ((),Bool,Char,Int)
12:30:34 <PeakerLambda>   ((),False,'\NUL',-2147483648)
12:30:53 <baaba> > [()..]
12:30:55 <PeakerLambda>   [()]
12:31:01 <Taejo> dublpaws, no, data introduces (generalised) algebraic datatypes, and nothing else
12:31:31 <ray> > () > ()
12:31:32 <PeakerLambda>   False
12:31:34 <tromp__> > minBound :: ((),(),(),(),(),(),(),(),(),(),(),(),(),(),())
12:31:36 <PeakerLambda>   ((),(),(),(),(),(),(),(),(),(),(),(),(),(),())
12:31:40 <ksf> conal, yes, I noticed that I ended up snapshotting stepped Behaviours with the event that created them ;)
12:31:49 <tromp__> > minBound :: ((),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),())
12:31:50 <PeakerLambda>   No instance for (GHC.Show.Show
12:31:51 <PeakerLambda>                     ((),
12:31:51 <PeakerLambda>                    ...
12:31:53 <bos> @seen dcoutts
12:31:53 <PeakerLambda> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
12:32:17 <Gracenotes> > length "(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()" `div` 3
12:32:18 <PeakerLambda>   19
12:32:20 <conal> ksf: hm.  you might be fighting the paradigm.
12:32:40 <dublpaws> Taejo: correction noted. :D
12:32:52 <ksf> I don't think so.
12:33:03 <ksf> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=937
12:33:41 <ozy`> @pl \oh god what's going on -> Nothing
12:33:41 <PeakerLambda> const (const (const (const (const Nothing))))
12:33:48 <ksf> I'd be surprised if foo can be simplified.
12:34:36 <vixey> > count (==',') "(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()"
12:34:37 <PeakerLambda>   Not in scope: `count'
12:34:46 <ksf> the point is that event's just don't cache their value.
12:34:53 <Peaker> ksf: what about accumE?
12:34:56 <vixey> @let count p = length . filter p
12:34:57 <PeakerLambda>  Defined.
12:35:04 <vixey> > count (==',') "(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()"
12:35:05 <PeakerLambda>   19
12:35:50 <ksf> nah i've got two events.
12:36:38 <ksf> zip might help, though.
12:37:36 <ksf> I suppose zipE occurs on every occurrence of either event and carries the most recent value of both?
12:38:10 <Peaker> @type (<|>)
12:38:12 <PeakerLambda> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
12:38:39 <Peaker> What does the Alternative instance do differently from the Monoid instance, on Events?
12:39:13 <ksf> as far as behaviours are concerned, I observed that <|> == mappend == mplus
12:39:34 <Peaker> Events' Monoid instance is a:  Monoid (Event a)  and not a   Monoid a => Monoid (Event a)  -- right?
12:39:58 <Peaker> ksf: you're using <|> between Events though
12:40:14 <ksf> I stand corrected.
12:40:15 <Badger> :t mplus
12:40:17 <PeakerLambda> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
12:40:28 <tromp__> http://www-ps.informatik.uni-kiel.de/~sebf/haskell/tabulated-binomial-coefficients.lhs.html looks a little clumsy
12:40:46 <vixey> what does this mean? "If you have an itch for designing a new programming languiage, scratch it: it might be the next big thing."
12:40:48 * ksf wants source links for instances
12:40:58 <vixey> "scratch it" meaning what ?
12:40:58 <conal> Peaker: yeah.  the Behavior (& Reactive) instance requires Monoid a.
12:41:11 <Deewiant> vixey: scratch the itch, i.e. design the language
12:41:12 <hackage> Uploaded to hackage: incremental-sat-solver 0.1
12:41:17 <vixey> ah!
12:41:18 <vixey> ok
12:41:23 <ksf> "If you have an itch for designing a new programming language, learn INTERCAL, Haskell and agda"
12:41:26 <redditbot> Haskell web frameworks reinvent too much
12:41:26 <redditbot> Learning to Reason in Haskell, Part 1
12:41:31 <conal> because behaviors are always in sync.  thanks to continuous time.
12:43:24 <hukolele> anyone knows if can i render something and then create a surface to continue rendering over the image/pixmap with cairo?
12:43:30 <tromp__> binomial coefficients can be computed more simply as
12:43:34 <tromp__> > iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1]
12:43:37 <PeakerLambda>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
12:43:43 <Peaker> ksf: foo sE bE = fmap reversal bE <*> se ?
12:44:33 <hukolele> cairo has a fuction cairo_image_surface_create_for_data but it is not in the binding, and i dont know if it is not there because there r other way to do the same or something
12:44:36 <Peaker> I guess that won't work -- how does Event's Applicative instance work?
12:44:47 <tromp__> @pl (\row -> zipWith (+) ([0] ++ row) (row ++ [0]))
12:44:51 <PeakerLambda> ap (zipWith (+) . ([0] ++)) (++ [0])
12:44:51 <PeakerLambda> optimization suspended, use @pl-resume to continue.
12:45:22 <ksf> http://hackage.haskell.org/packages/archive/reactive/0.10.5/doc/html/FRP-Reactive.html#t%3AEventG
12:45:56 <ksf> admittedly, I was put back by the multiplication and didn't want to look into using Reactive's.
12:46:02 <Gracenotes> @pl -- truly a dangerous plugin
12:46:03 <PeakerLambda> (line 1, column 1):
12:46:03 <PeakerLambda> unexpected "-"
12:46:03 <PeakerLambda> expecting white space, "()", natural, identifier, lambda abstraction or expression
12:46:38 <Taejo> Gracenotes, not as bad as @launch-the-missiles
12:48:10 <Taejo> <emotion><category set="everydayEmotions" name="incredulity" confidence="++"/> </emotion> <!-- W3C must be crazy -->
12:49:17 <Deewiant> Taejo: you do realize it's just a proposal :-P
12:49:29 <Peaker> ksf: I don't think you're really supposed to use Reactives directly
12:49:56 <Deewiant> Taejo: In particular, "[p]ublication of this document by W3C as part of the W3C Incubator Activity indicates no endorsement of its content by W3C, nor that W3C has, is, or will be allocating any resources to the issues addressed by it."
12:50:16 <Taejo> Deewiant, I did not realise
12:50:18 <Taejo> whoops
12:51:09 <Peaker> ksf: Reactive really does make sense here though, exposing discrete occasions
12:51:25 <Deewiant> Calling the Emotion Markup Language Incubator Group insane is fine, though. :-P
12:51:39 <dmajnem2> how do I ask lambdabot the source for some function in the prelude?
12:51:46 <Deewiant> ?src fix
12:51:47 <PeakerLambda> fix f = let x = f x in x
12:51:51 <dmajnem2> thanks
12:51:54 <dmajnem2> ?src floor
12:51:54 <PeakerLambda> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
12:52:00 <Deewiant> :-P
12:52:17 <rwbarton> dmajnem2: floor is a class method
12:52:20 <rwbarton> , src 'floor
12:52:23 <lunabot>  Class op from RealFrac: floor :: forall a . RealFrac a => forall b . Inte...
12:52:23 <lunabot>                                                                           ...
12:52:24 <Deewiant> ?src Float floor
12:52:24 <PeakerLambda> Source not found. And you call yourself a Rocket Scientist!
12:52:30 <Deewiant> ?src floor Float
12:52:31 <PeakerLambda> Source not found. My mind is going. I can feel it.
12:52:34 <Deewiant> oh well
12:52:44 <Peaker> conal: The Reactive type is not exposed, right?
12:52:54 <Deewiant> dmajnem2: most likely it's just a call to a compiler intrinsic anyway
12:53:19 <dmajnem2> Deewiant: I was trying to figure out why floor(1/0) is the same as 2^1024
12:53:53 <Deewiant> dmajnem2: refer to the IEEE 754 spec
12:54:00 <Deewiant> > floor (1/0)
12:54:02 <PeakerLambda>   179769313486231590772930519078902473361797697894230657273430081157732675805...
12:54:09 <Deewiant> amusing
12:54:12 <rwbarton> > floor (1/0) - 2^1024
12:54:13 <PeakerLambda>   0
12:54:27 <conal> Peaker: it depends on how you import.
12:54:35 <dmajnem2> why is it using IEEE 754?
12:54:42 <Peaker> conal: I assume no "Internal" stuff should be imported :)
12:55:16 <conal> Peaker: you can import FRP.Reactive.Reactive.
12:55:36 <Deewiant> dmajnem2: refer to the people on the standard haskell committee :-P
12:56:03 <conal> Peaker: if you import Internal stuff you'll get a representation view, but if you import non-Internal, you'll get a semantically consistent view, including the Reactive type.
12:56:16 <conal> Peaker: also Future and Improving.
12:56:20 <Peaker> conal: cool, I thought you didn't want to expose the Reactive type
12:56:49 <vixey> how often/what sort of cases does higher order unification just become useless?
12:56:58 <vixey> (which problems are too hard for it?)
12:57:09 <Deewiant> > floor (1/0 :: Float)
12:57:11 <PeakerLambda>   340282366920938463463374607431768211456
12:57:33 <conal> vixey: what kind of useless?  it's a complete enumation algorithm.
12:57:36 <Deewiant> > 2^128
12:57:36 * Grizzly` wishes he could give his talk at university tomorrow about reactive instead of grapefruit which the tutor recommended. at least there are some papers and documentation about reactive.
12:57:37 <PeakerLambda>   340282366920938463463374607431768211456
12:57:55 <conal> *enumeration
12:58:21 <vixey> conal, but I mean if you used HOU in a type checker for example.. there could be some badly typed programs it loops on.. or if you set a computation threshold some well typed programs it didn't check because it gave up first
12:58:26 <Peaker> conal: is there an "unstepper" to break a reactive to  (a, Event a) ?
12:58:55 <conal> Peaker: a semantically consistent unstepper?
12:59:06 <Peaker> conal: yeah
12:59:07 <vixey> (at least I think that is the case ?)
12:59:25 <conal> Peaker: what semantics would you like for unstepper?
12:59:46 <Peaker> conal: unstepper (x `stepper` e) == x
13:00:07 <conal> Peaker: is that definition semantically consistent?
13:00:15 <Peaker> conal: Why not?
13:00:15 <conal> vixey: if you're using unification instead of matching, you're probably doing type inference, right?
13:00:31 <Peaker> conal: "obviously" (I'm kidding :-)
13:01:02 <conal> does anyone see the problem with Peaker's "definition"?
13:01:06 <vixey> conal, I suspected type checking GADTs would require full unification
13:01:14 <Peaker> conal: not for Behaviors in general, just for Reactives
13:01:22 <conal> Peaker: i understand.
13:01:32 <vixey> I mean functions that destruct values that are from GADTs
13:01:42 <conal> vixey: oh.  i haven't thought about GADT checking.
13:02:08 <vixey> conal, just something like  data Eq a b where Refl :: a -> Eq a a
13:02:09 <conal> vixey: the reason i asked is that HOU produces *multiple* most general unifiers, unlike FOU
13:02:24 <conal> vixey: oh yeah.
13:02:29 <Heffalump> vixey: GADT checking or GADT inferring?
13:02:40 <vixey> just checking Heffalump
13:03:02 <vixey> mm about it giving multiple solutions... I am not sure what that would entail
13:03:29 <Heffalump> well, the reason GADTs need signatures is otherwise there are multiple possible results
13:03:34 <vixey> if something had 3 different types for example, what do you do about type class dispatch ?
13:03:37 <Peaker> ksf: what about something like this: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=937#a1018 ?
13:03:59 <conal> here's a big hint about Peaker's definition:  how about this function definition on numbers: unAdd (a + b) = (a,b)
13:04:11 <vixey> what I should probably do is just prototype something in lambda prolog and write some code in it
13:04:19 <Peaker> conal: too big :-)
13:04:32 <conal> Peaker: yeah.  i didn't think of a smaller hint.
13:05:05 <conal> vixey: lambda prolog is fun stuff.  i worked on andn used an implementation when i was a grad student at cmu.
13:05:07 <Peaker> conal: but a Reactive value is an initial value and discrete future occurances, right?
13:05:09 <pumpkin> :t either
13:05:10 <PeakerLambda> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
13:05:10 <ksf> peaker, I don't see any revision.
13:05:25 <conal> Peaker: depends on what you mean by "is"
13:05:27 <Peaker> ksf: its not simpler, just factors stuff out
13:05:47 <Peaker> conal: well, in the Behavior-like interpretation, its not, but I think this interpretation is a more useful one?
13:06:00 <ksf> now it's there.
13:06:18 <Peaker> conal: if you think of (Reactive a) as simply (a, Event a) -- that makes unstepper unambiguous, right?
13:06:50 <Peaker> ksf: also the "ignore" is unnecessary as snapshot_ already ignores
13:06:54 <conal> Peaker: yes, you can make your unstepper semantic by changing the semantics.  you can do the same trick to make unAdd semantic also.
13:06:55 <conal> ;)
13:07:11 <Peaker> conal: hehe, right. but I thought "Reactive" already had those semantics :-)
13:07:21 <conal> :)
13:07:22 <conal> heh
13:07:25 <Peaker> conal: any reason for Reactive not to have these semantics?
13:07:58 <Peaker> (you wouldn't want "add" to have these semantics because we already have (,) for that :-)
13:08:00 <conal> i just got job spam addressed to "Dear lords".  wtf?
13:08:13 <Badger> heh
13:08:24 <ksf> peaker, ef <|> is going to throw a type error on you
13:08:30 <ksf> I like it, though.
13:08:38 <Peaker> ksf: oh, right
13:08:39 <ksf> *ef <|> ex
13:08:47 <ksf> there's eitherE.
13:09:14 <Peaker> ksf: I'd put ignore outside and call it ignoreE, its useful out of this context too
13:09:20 <ksf> that ignore stuff is a desperate attempt of mine to reduce push-lagging...
13:09:43 <Peaker> ksf: also, I think if independent functions are declared independently, you're telling the reader that they don't depend on any values in that where/let clause - which makes it easier to understand
13:09:53 <conal> Peaker: as for a reason: to keep the semantics simple and compelling.  for instance, it's interesting now that the semantic function for Reactive is a morphism over Functor, Applicative, Monad, Monoid, Num, ... .
13:10:07 <Taejo> conal, you are on the Lords of Haskell spam list
13:10:17 <conal> Taejo: lol
13:10:23 <Peaker> conal: the (a, Event a) can still have all these instances, I thinki
13:11:02 <Gracenotes> arrr... accidentally write 'contact' in an email as 'concat'
13:11:05 <Gracenotes> *wrote
13:11:12 <conal> Peaker: you mean the representation can?
13:11:28 <Badger> Gracenotes: and lists, afterwards? :P
13:11:29 <Peaker> conal: Functor does the only thing it can. Applicative does what http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=937#a1018 (eventAp) does, etc
13:11:35 <ksf> ACCIDENTELY THE WHO!
13:11:40 <Gracenotes> :X
13:12:21 <Peaker> conal: I think if the interpretation of (Reactive a = Stepper a (Event a)) is "a single occurrence of a at -infinity, rest of occurances" -- then the instances make sense too
13:12:58 <Peaker> conal: I'm not sure about what the exact difference is, between the representation having law-abiding instances, and the semantics having "type class morphisms"
13:13:49 <Peaker> conal: I guess the "-infinity" is a bad idea because Reactive/Event are defined corecursively. But you could say "prior to all events in the (Event a)" instead
13:13:57 <thaldyron> Hello, I'm wondering if there's a type class for datastructures with keys that implement a Data.Map-like interface  (lookup, insert, delete)?
13:14:24 <vixey> ?where associated types
13:14:24 <PeakerLambda> I know nothing about associated.
13:14:32 <vixey> @go associated type families
13:14:33 <PeakerLambda> Maybe you meant: google googleit . ? @ bf ft ghc id pl rc v wn yow
13:14:35 <conal> Peaker: i don't follow your suggestion about what the type class morphisms would be for the semantics you propose.  if indeed you're making such a proposal.
13:14:39 <vixey> @google associated type families
13:14:54 <PeakerLambda> Plugin `search' failed with: thread killed
13:14:54 <Peaker> conal: by "type class morphisms" do you mean something else than instances on the representation?
13:14:58 <vixey> useless
13:15:12 <vixey> thaldyron, here is what I wanted to show you http://www.haskell.org/haskellwiki/GHC/Type_families
13:15:14 <conal> Peaker: also, i think you're suggesting erasing the non-trivial distinction between representation and semantics.  is that so?
13:15:22 <PeakerLambda> Title: GHC/Type families - HaskellWiki
13:15:42 <conal> Peaker: i mean the specification of those instances.  i.e., the properties that the implementation must satisfy.
13:15:51 <Peaker> conal: I find it easier to think and reason about representations, and then "semantics" are just a philosophical interpretation
13:16:03 <thaldyron> vixey: Looks interesting, thanks!
13:16:03 <CosmicRay> @hoogle stringUtf8CStr
13:16:04 <PeakerLambda> No results found
13:16:10 <conal> Peaker: the simple and compelling definition of correctness of the implementation.
13:16:15 <CosmicRay> PeakerLambda?
13:16:19 * ksf has to keep an eye on argument orders and opportunities to use functions infix
13:16:22 <CosmicRay> what happened to lambdabot
13:16:44 <conal> Peaker: how do you reason about representation if you don't have semantics?
13:17:26 <roconnor> wow my cairo rendering seems really sluggish since upgrading to ubuntu 8.10 yesterday.  I wonder if I lost 2-d accelleration or something like that
13:18:23 <conal> Peaker: i like the semantics TCMs because they tell me what correctness means.
13:18:24 <Peaker> conal: I am a bit confused about the terminology.  Is it not "semantics" for Reactive to represent an Event that also has an occurance at an unspecified time before all the others?
13:18:30 <ksf> roconnor, Xrandr should be usually implemented in terms of 3d accel.
13:19:07 <conal> Peaker: yes.  (in a trivial sort of sense, given that the semantic model mirrors the representation.)
13:19:11 <Peaker> conal: and then the semantics of Monoid, Applicative would be a "merge" of Reactives, such that the separate occurance prior to all the others is merged, and the Events are merged as usual, etc?
13:19:17 <wli> apt-get dist-downgrade would be nice.
13:19:18 <ksf> If an event has no time of occurence, did it ever occur?
13:19:34 * conal parses that sentence
13:19:40 <roconnor> ksf: is there something I can run to check things?
13:20:29 <ksf> if cabal sdist works, yes.
13:20:45 <ksf> you'd need to compile libagar, though.
13:20:54 <Peaker> conal: I think this semantic is useful - e.g ksf's code could just use a Reactive and <*>  instead of Events
13:20:56 <conal> Peaker: are you describing the same Monoid meaning as currently?
13:21:06 <Peaker> conal: for the Events? yes
13:21:08 <ksf> it might be faster to re-do the main in gtk or whatever.
13:21:25 <conal> Peaker: oh.  you want to change the semantics for Reactive to match Event?
13:21:27 <Peaker> conal: oh wait, there's a problem there, I see it :)
13:21:39 <ksf> roconnor, sorry.
13:21:42 <ksf> topic mixup.
13:21:56 <Peaker> conal: I can't Ord the "prior to all others" occurance for the Event merge..
13:22:46 <conal> Peaker: i didn't realize you wanted to change the meanings of the reactive operations as well.
13:22:46 <ksf> ...and I confused Xrandr with Xrender, again.
13:23:02 <conal> Peaker: to make them like event instead of like behavior
13:23:55 <ksf> roconnor, something like this: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1019#a1019
13:24:18 <Peaker> ksf: btw your thing might be "buggy" in the sense of exposing the empty string there
13:24:27 <conal> Peaker: i think the whole model (the one in "simply efficient functional reactivity") would come out much less pretty that way.  you could give it a try, though.
13:24:34 <ksf> in the end, it depends on your graphics card driver.
13:24:34 <Peaker> conal: Yeah, I'm starting to realize why this doesn't work out
13:24:41 <roconnor> ksf: (II) intel(0): direct rendering: Disabled
13:24:44 <conal> oh, okay.
13:24:49 <roconnor> ksf: sounds bad doesn't it :)
13:25:10 <ksf> direct rendering should be glx stuff.
13:25:34 <ksf> ...directly using libGL instead of going via the server, that is.
13:26:20 <Gracenotes> eek, I'm such an obsessive-compulsive saver. I save every time I write a code expression like (0, 0)
13:26:25 <ksf> peaker, I didn't even care to check whether agar sends a content-changed on initialisation of a textbox.
13:26:41 * Gracenotes makes the little asterisk go away...
13:26:42 <Taejo> conal, the TeX in your latest blog post is a little borked: derivfx instead of deriv f x
13:26:53 <roconnor> ksf: I don't understand.  You are saying this line is irrelevent to cairo rendering?
13:27:13 * vixey saves like that too
13:27:16 <conal> Taejo: yeah, sigh.  my latex plugin (or something) chokes on "\," :(
13:27:25 <ksf> I guess so.
13:27:36 <ksf> I don't know your graphics driver.
13:27:40 <conal> Taejo: which is why i changed those derivative laws to code :(
13:27:43 <roconnor> ksf: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1019#a1020
13:27:46 <conal> instead of latex
13:27:47 <roconnor> ksf: ah okay
13:28:03 <ksf> (and would rather smash his head repeatedly against a wall than suffer the agony of using intel graphics)
13:28:50 <roconnor> #       Load    "glx"
13:28:59 <roconnor> is commented out in my xorg.conf
13:29:10 <conal> jeffersonheard: i suspect your new Hieroglyph could be improved by distinguishing between model (semantics) and representation.
13:29:44 <ksf> ...so you won't be able to do gl graphics.
13:30:09 <ksf> Xrender does 2d alpha image composition.
13:30:32 <ksf> including anti-aliasing.
13:30:39 <roconnor> ksf: okay, but cairo doesn't use gl does it?
13:30:50 <ksf> I wouldn't think so.
13:31:03 <roconnor> what would cause cairo slowness?
13:31:16 <jeffersonheard> roconnor: what kind of surface are you outputting to?
13:31:28 <loadquo> Is lambdabot borked?
13:31:29 * stepcut is pissed that C-c C-r does not work in inf-haskell anymore
13:31:39 <ksf> It might try to use gl and fall back to software rendering or stuff.
13:31:41 <roconnor> jeffersonheard: canvas <- drawingAreaNew
13:31:41 <chessguy_work> @bot
13:31:42 <lunabot>  :)
13:31:42 <PeakerLambda> :)
13:31:52 <roconnor> jeffersonheard: it was much faster before my system upgrade yesterday
13:32:09 <jeffersonheard> Odd...  same program, no changes?
13:32:19 <roconnor> nothing substatial
13:32:21 <conal> stepcut: (local-set-key "\C-c\C-r" '(lambda () (interactive) (inferior-haskell-load-file t)))
13:32:22 <chessguy_work> loadquo, why?
13:32:36 <roconnor> but to be sure
13:32:41 <roconnor> I'll try without the changs
13:32:46 <stepcut> conal: thanks
13:32:48 <conal> stepcut: i added it to my haskell-mode-hook a while ago
13:32:50 <conal> :)
13:32:57 <jeffersonheard> conal: more specifically? Part of the problem may be in controlling what I export to the world and documenting the library better
13:33:04 <roconnor> jeffersonheard: oh. my changes are commented out already
13:33:04 <chessguy_work> conal, that gets rid of the reloading problem?
13:33:07 <loadquo> I've been /msging it not getting replies. It didn't reply to @bot either...
13:33:28 <stepcut> conal: heh. I would submit a patch, but last time I tried to find the maintainer I found too many different repositories for haskell-mode to know which one was active
13:33:30 <conal> chessguy_work: if the reloading problem is the loss of C-cC-r, yeah.
13:33:40 <jeffersonheard> roconnor...  are you double buffering on your surface?
13:33:52 <conal> stepcut: stefan monnier.  quite responsive in my experience.
13:33:54 <roconnor> jeffersonheard: not to my knowledge
13:34:01 <stepcut> conal: cool
13:34:02 <chessguy_work> hmm, maybe there's multiple problems
13:34:21 <jeffersonheard> roconnor, that might be part of the problem...
13:34:36 <stepcut> conal: I also want to submit a patch so that when the ghci prompt is just > in the first column, haskell-mode does not get lost
13:34:36 <Heffalump> roconnor: did you sort out your Debian issues?
13:34:39 <roconnor> jeffersonheard: I had less of a problem yesterday
13:34:49 <roconnor> Heffalump: yes
13:34:50 <chessguy_work> loadquo, hm, yeah, seems to be down
13:34:56 <chessguy_work> Cale
13:35:07 <roconnor> Heffalump: it was very sad.  I mourn for nix
13:35:28 <loadquo> chessguy_work: Looks like peakerbot is a lambdabot replacement though.
13:35:28 <Heffalump> why do you mourn for it?
13:35:31 <stepcut> conal: looking at comint-prompt-regexp, I am not sure why it doesn't work already :-/ I'll hae to experiment
13:35:33 <roconnor> jeffersonheard: okay, boosting my cpu speed had no appriciable effect
13:35:45 <chessguy_work> loadquo, lambdabot cannot be replaced :)
13:35:55 <jeffersonheard> roconnor. hrm.  hpaste?
13:36:03 <roconnor> Heffalump: because I expect nix can uninstall easially
13:36:04 <jeffersonheard> I've got 20 minutes or so to look at it
13:36:09 <conal> jeffersonheard: my first goal is to make the semantic model as simple and compelling as possible; then make the implementation agree with the model and work efficiently, and ideally (as in my latest AD post) flow from the model.
13:36:13 <roconnor> jeffersonheard: what do you want to look at?
13:36:13 <Heffalump> why not use it then? :-)
13:36:25 <roconnor> Heffalump: learning curve
13:36:36 <roconnor> Heffalump: I'm not even sure these packages are available
13:36:41 <conal> jeffersonheard: if you don't distinguish between the two, these goals will be pulling you in different directions, and you'll make compromises that are suboptimal for both model and implementation.
13:36:45 <roconnor> Heffalump: but I will try some day
13:37:15 <jeffersonheard> curious about the loop that you're rendering in
13:37:40 <roconnor> jeffersonheard:  canvas `onExpose` updateCanvas canvas
13:37:51 <roconnor> and then I have my own updateCavas function
13:37:59 <roconnor> I copied this from a gtk2hs example
13:38:39 <Taejo> :t fmap . fmap
13:38:40 <PeakerLambda> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
13:38:51 <jeffersonheard> conal: what's wrong with the model of a visualization being f data -> Visual, and a Visual = some Foldable t that is defined over Primitives?
13:39:22 <conal> stepcut: well, you've dived more deeply than i have
13:39:28 <jeffersonheard> roconnor, the binding of the event is fine -- I was interested in the updateCanvas
13:39:31 <stepcut> conal: :)
13:39:51 <conal> jeffersonheard: model i'm talking about is the meaning of Visual.
13:40:09 <conal> jeffersonheard: and the implementation, the implementation of Visual
13:40:20 <roconnor> jeffersonheard:
13:40:21 <roconnor> drawHex r (x,y) =
13:40:23 <roconnor>      polyLine[(r*cos (i*pi/3)+x, r*sin (i*pi/3)+y) | i<-[0..5]]
13:40:24 <roconnor>   >> fill
13:40:32 <roconnor> It calls that a bunch of times, with different colours
13:40:36 <roconnor> to fill the window
13:40:36 <jeffersonheard> A Visual is an arbitrary collection of Primitive
13:41:12 <hackage> Uploaded to hackage: FindBin 0.0.2
13:41:34 <conal> jeffersonheard: yep.  i was just looking at Primitive.
13:41:53 <jeffersonheard> conal: I figured as much
13:42:26 <jeffersonheard> beacuse yeah, it does seem pretty arbitrary
13:42:44 <conal> jeffersonheard: yeah.  and the attributes are repeated for every constructor.
13:42:45 <jeffersonheard> but the point of this library originally wsa to be a pure-functional wrapper to Cairo
13:43:09 <jeffersonheard> roconnor: i <- [0..5]...  those are floats
13:43:15 <jeffersonheard> Doubles, actually
13:43:28 <conal> jeffersonheard: that goal didn't include semantic clarity, and hence nice reasoning properties, right?
13:43:39 <roconnor> jeffersonheard: I want your pure-fuctional wrapper.  I was almost ready to write one
13:43:46 <roconnor> jeffersonheard: nice catch
13:43:58 <roconnor> jeffersonheard: but still, the code hasn't changed since yesterday
13:44:10 <jeffersonheard> roconnor: could be the way you compiled it
13:44:17 <roconnor> so the problem is peresumably with the display drivers
13:44:26 <conal> jeffersonheard: the problem i have is that i don't know what's "purely functional" about a purely functional wrapper to cairo that doesn't also hold for cairo as it is.
13:44:27 <roconnor> jeffersonheard ...
13:44:31 <jeffersonheard> roconnor: could also be the system upgrade upgradint the compiler
13:45:18 <jeffersonheard> roconnor: not sure about that.  depends on the system.  Cairo doesn't use GL directly unless you're using Glitz, so it shoudln't change in perf. much
13:45:24 <jeffersonheard> from one day to the next
13:45:38 <conal> jeffersonheard: people use the term "purely functional" in different ways.  often haskellers even include programming with IO.
13:45:45 <roconnor> jeffersonheard: well, I did upgrade from ubuntu 8.04 to ubuntu 8.10
13:45:50 <jeffersonheard> conal: I mean IO-free
13:45:55 <augustss> @seen thoughtpolice
13:45:55 <PeakerLambda> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
13:46:12 <jeffersonheard> roconnor, that's an upgrade from 6.8.2 to 6.8.3 if you're letting apt control your GHC version
13:46:12 <roconnor> jeffersonheard: even with -O2, it is slower than I remember
13:46:20 <roconnor> jeffersonheard: yes
13:46:21 <conal> jeffersonheard: the program i have with simply "IO-free" is that it can be gotten trivially.
13:46:29 <roconnor> jeffersonheard: new version of gtk
13:46:32 <roconnor> jeffersonheard: new version of gtk2hs
13:46:38 * roconnor sighs
13:46:39 <conal> jeffersonheard: via "newtype NotIO a = NotIO (IO a)
13:46:39 <loadquo> PeakerLambda, fails us :(
13:46:42 <roconnor> a million things have changed
13:46:52 <jeffersonheard> roconnor, I'm using 8.10 myself, and i have fine perf. with Cairo
13:47:01 <conal> jeffersonheard: which just hides the semantic rats' nest that is IO
13:47:02 <jeffersonheard> on an nVidia card using the default setup
13:47:09 <roconnor> jeffersonheard: are you double buffering?
13:47:21 <jeffersonheard> roconnor, yes
13:47:27 <roconnor> how do I enable that?
13:47:37 <roconnor> or is it messy like I remember
13:47:43 <roconnor> from my java days
13:48:07 <jeffersonheard> conal: the difference being that the geometry is specified declaratively and in a completely unordered fashion
13:48:38 <jeffersonheard> conal: conceptually, there's nothing that prevents me from parallel rendering pipelines and letting the compiler optimize the order in which things are rendered
13:48:42 <conal> jeffersonheard: (a) "declaratively" is subjective, and (b) i think you do depend on order.
13:48:55 <jeffersonheard> conal: I don't believe I depend on order at all
13:49:21 <conal> jeffersonheard: let's table the second point and focus on the first, which is the heart of what i'm offering you.
13:49:22 <jeffersonheard> internally, I sort all the primitives based on the layer that is specified, and then again based on how hard it is to change Cairo's state
13:50:07 <conal> in other words, what makes something "declarative" and something else not?
13:50:16 <chessguy_work> @seen dpiponi
13:50:16 <PeakerLambda> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
13:50:19 <chessguy_work> bh
13:50:20 <chessguy_work> bah
13:50:45 <conal> what's a tangible observation one can make, to replace the subjective evaluation of "declarative"?
13:50:50 <jeffersonheard> not a worry -- I understand to an extent what you're offering me.  And what i have, in using Cairo, is a set of arbitrary axioms, which are the primitives
13:51:07 <roconnor> conal: whatever is or isn't "declarative", using "setSourceRGB" is definitely not declarative. :)
13:51:28 <Botje> conal: declarative code does not worry about intermediate steps?
13:51:46 <conal> roconnor: wouldn't it be nice to be able to say why?  and then to use that clarity to classify other less clear examples?
13:51:55 <roconnor> conal: yes
13:51:58 <Botje> just like recursion doesn't make the intermediate results explicit?
13:52:45 <vixey> I mean by declarative, you are putting emphasis on /what/ instead of /how/
13:53:03 <vixey> so most stuff you write in haskell for example..
13:53:10 <conal> vixey: me too.  but then one can play a trick of turning a how into a what.
13:53:17 <conal> vixey: which is the trick of the IO type.
13:53:17 <jeffersonheard> conal: Declarative in my sense of the word is a razor of mapping of input into another space.  That is...  if what i have is anything more than a map from space a into space b, or system a into system b, then what I have is not declarative.
13:53:42 <jeffersonheard> y = mx + b, is a mapping of x to y
13:53:51 <conal> jeffersonheard: okay.  i like that.  then i'd say that IO is declarative.
13:53:59 <vixey> yes it very much depends on what level of detail you look at things
13:54:22 <jeffersonheard> but IO is more than declarative, it is destructive
13:54:39 <conal> jeffersonheard: and yet its meaning is a mapping from one space to another.
13:54:53 <conal> jeffersonheard: perhaps here "destructive" is just another subjective label.
13:55:15 <conal> jeffersonheard: technically IO values don't do anything at all.
13:55:24 <doserj> @src IO
13:55:24 <PeakerLambda> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
13:55:34 <conal> yep.  a pure function.
13:55:40 <doserj> yep
13:55:51 <conal> it's their *execution* that's destructive.  and one cannot express execution in a haskell program.
13:56:04 <jeffersonheard> RealWorld is not a pure value, though
13:56:25 <conal> isn't it?
13:56:33 <jeffersonheard> Not to my understanding
13:56:49 <conal> that's the usual argument i think people give to justify calling haskell purely functional.  but i think that argument misses the deeper value of functional programming.
13:56:49 <jeffersonheard> but that knowledge comes from way back, so it may be wrong
13:57:07 <doserj> jeffersonheard: what do you mean with "pure value"?
13:57:43 <jeffersonheard> doserj: I mean evaluating it twice without changing the parameters in the program is not guaranteed to give the same results
13:57:57 <augustss> IO is an abstract type in Haskell.  Looking at ghc's implementation of it doesn't reveal the whole truth.
13:58:12 <conal> augustss: agreed.
13:58:28 <jeffersonheard> augustss: I suppose that was more to my point
13:58:28 <conal> and that model *cannot* serve as a semantics, iiuc.
13:58:40 <jeffersonheard> and I totally agree with you there, conal
13:58:40 <conal> because it doesn't work with concurrency.
13:58:54 <mauke> @src forkIO
13:58:55 <PeakerLambda> forkIO action = IO $ \ s -> case (fork# action_plus s) of (# s1, id #) -> (# s1, ThreadId id #)
13:58:55 <PeakerLambda>     where action_plus = catchException action childHandler
13:59:02 <augustss> conal: But I agree with you.  Haskell isn't pure more than in some technical sense.
13:59:28 <conal> augustss: :)  you're the first person i've heard that from (other than myself).
14:00:22 <conal> augustss: that's why i cringe at the label "purely functional" about haskell.  i'm afraid people won't realize what *really* (deeply) purely functional programming is about.
14:00:37 <augustss> conal: But the good thing is that you can tell if you're using the pure subset or not.
14:00:40 <doserj> jeffersonheard: how could you evaluate RealWorld twice without changing the Realworld? (for example the time?)
14:00:41 <conal> for instance, backus's criticism of imperative programming languages applies to Haskell-with-IO
14:00:50 <conal> augustss: yes, that's wonderful!
14:00:55 <jeffersonheard> doserj, you can't -- that's my point
14:01:04 <dIaNpEpIuX> necesito un culo que me raspe la verga
14:01:16 <conal> augustss: so i'd describe haskell as a hybrid functional/imperative language that makes the distinction statically, in the type system.
14:01:17 <mauke> zomg, a lammer
14:01:24 <doserj> jeffersonheard: no. you said that if you could do it, it would result in different values
14:01:29 <jeffersonheard> therefore RealWorld doesn't exist in a purely functional space.  There are ways of evaluating RealWorld that aren't functions
14:01:35 <augustss> conal: It's somewhat ironic that FL, the successor of FP, had basically monadic IO (but it wasn't called that in those days)
14:01:42 <rwbarton> preflex: nickometer dIaNpEpIuX
14:01:42 <preflex>  dIaNpEpIuX is 99.969370% lame
14:01:45 <mattam> referential transparency/persistence is the key thing.
14:01:54 <conal> augustss: :P  monadic IO began the dark ages of functional programming.
14:02:44 <jeffersonheard> and I also agree that I've somewhat moved away from Cairo, and I am seeking a semantically pure way of doing arbitrary 2D vector drawing (and I do distinguish vector and raster drawing)
14:02:50 <conal> jeffersonheard: so i'm still not sure Hieroglyph is "purely functional" in a sense that's not also true of the Cairo library.
14:03:06 <mattam> It's hard to sell though. Tarjan failed to sell it to imperative programmers for example.
14:03:25 <jeffersonheard> I would agree with you to a limited point...  not the same sense that's not true of the Cairo library.  SOme of the same senses, but not the exact same sense
14:03:27 <conal> jeffersonheard: in that both are functional in the technical sense of IO being functional, and neither has a semantic explanation that doesn't appeal to IO.
14:03:49 <jeffersonheard> conal: I'm not sure where I'm appealing to IO in anything that is exposed to the user
14:03:54 <Heffalump> what's so wrong about IO?
14:04:03 <Badger> It makes things asplode.
14:04:06 <conal> Heffalump: ask backus
14:04:08 <jeffersonheard> A primitive is simply a shape with attributes
14:04:15 <Heffalump> he's not here, you are :-p
14:04:41 <conal> Heffalump: he explained it so well.
14:04:47 <conal> @go "can programming be liberated"
14:04:47 <PeakerLambda> Maybe you meant: google googleit . ? @ bf ft ghc id pl rc v wn yow
14:04:53 <conal> @google "can programming be liberated"
14:05:09 <PeakerLambda> Plugin `search' failed with: thread killed
14:05:09 <Heffalump> I'm aware of the paper
14:05:53 <Heffalump> I thought the criticism was more of state
14:06:13 <piroko> Hello. How might I obtain an account for the haskell wiki?
14:06:23 <roconnor> maybe cario was just as slow before
14:06:26 * roconnor sighs
14:06:26 <augustss> What is IO if not state on steroids?
14:06:30 <chrisdone> piroko: there is a sign up page iirc
14:06:32 <roconnor> it's impossible to be sure
14:06:38 <piroko> chrisdone: It's been disabled due to spammers
14:06:42 <piroko> I figured there was an alternate way
14:06:56 <jeffersonheard> roconnor: still not working?
14:06:59 <Heffalump> augustss: well, there's the stream model of IO
14:07:01 <jeffersonheard> I won't be here much longer today
14:07:15 <roconnor> jeffersonheard: I mean, it always worked
14:07:27 <roconnor> I just think it is slower than before my system upgrade
14:07:35 <jeffersonheard> sorry, conal: I sound like I'm arguing, but really I'm trying to get you to give me specifics so I can see what to work on next
14:07:38 <roconnor> I'd like to blame my video acceleration or something
14:07:43 <roconnor> but I don't know how cairo works
14:07:46 <roconnor> so I don't know what to check
14:08:11 <jeffersonheard> roconnor: heh.  that I can't help you with.  I don't know how it works either.  You'd have to ask the Gnome programmers
14:09:42 <conal> jeffersonheard: iiuc, the heart of your model/implementation (same?) is the Primitive type.  my primary design goal is always to make the model simple and compelling.
14:10:37 <conal> jeffersonheard: since it's complex, i want to understand it in terms of something else.  all i have at this point for the something else is IO.  if that's the case, it's no simpler (semantically) than IO itself.
14:10:43 <conal> jeffersonheard: does that explanation help?
14:10:50 <jeffersonheard> A Primitive is an attributed shape on a 2D plane.
14:10:59 * ksf now intended to cd ~/cabal/xhb ; darcs get for two hours.
14:11:11 <conal> jeffersonheard: now make that statement precise.
14:11:21 <conal> jeffersonheard: and then measure its complexity.
14:11:26 * ksf instead does cd ; mv cabal hackage
14:11:42 <jeffersonheard> shoot..  gotta go
14:12:02 <conal> jeffersonheard: i measure complexity *after* making precise, so i don't fool myself with thinking that something like "stuff" is simple.
14:12:31 <conal> jeffersonheard: for example ;)
14:12:39 <conal> jeffersonheard: okay.  take care
14:12:42 <jeffersonheard> wife's downstairs with the car...  Sorry to cut off short, conal
14:12:52 <jeffersonheard> will talk to you later after thinking further
14:16:50 * loadquo reads a bit of the backus paper
14:19:11 <conal> loadquo: :)  it's one of my favorites.  i didn't appreciate it at first.
14:19:27 <loadquo> Its interesting but he is criticising the von Neumann model too much. The beauty of the von Neumann model is that it can be reprogrammed. That is it will be impure.
14:20:42 <conal> loadquo: not only is code-state changable between executions (reprogammable), but even execution state.
14:21:13 <conal> and yeah -- the idea of a universal (programmable) machine is brilliant!
14:21:37 <elly> :O
14:21:40 <elly> mmm, turing machines
14:22:09 <conal> mmm, software!
14:22:19 <conal> soft-ware
14:22:40 <loadquo> mmm, bootstrapping!
14:23:13 <ksf> what's the package for Text.StringTemplate?
14:23:34 <Saizan> HStringTemplate ?
14:23:51 <ksf> yeah. I was missing th h.
14:23:54 <ksf> *the
14:24:11 <loadquo> Since learning about functional programming I have wondered whether it is possible to create a functional low level computer architecture.
14:24:24 <loadquo> Lazy as well.
14:25:03 <jganetsk> yeah, it's called lambda calculus
14:25:06 <Badger> we need functional asm
14:25:37 <stepcut> loadquo: graph reduction machine?
14:25:38 <enticingjelly> okay, question
14:25:40 <Saizan> the reduceron?
14:25:41 <conal> loadquo: keep wondering.  i don't think there's much innovation at all with such things any longer.
14:25:48 <conal> yay reduceron
14:25:56 <enticingjelly> every finite set is decidable.
14:25:57 <enticingjelly> right?
14:26:02 <enticingjelly> so let's have the set
14:26:05 <vixey> decidable ??
14:26:15 <conal> enticingjelly: assuming decidable equality?
14:26:21 <enticingjelly> is that not how you translate "entscheidbar"?
14:26:22 <stepcut> conal: I think GHC killed that momentum, it was too good on stock hardware to justify custom stuff ;)
14:26:36 <vixey> enticingjelly, what do you mean by decidable
14:26:39 <Grizzly`> hmm... in Control.Arrow the standard definition of &&& says f &&& g = arr (\b -> (b,b)) >>> f *** g. when I try the same (for learning...) it is rejected because "Occurs check: cannot construct the infinite type: a = (a1, a) When generalising the type(s) for `&&&` "...
14:26:39 <enticingjelly> maybe... determinable? i don't know?
14:26:46 <conal> stepcut: perhaps a local optimum. :(
14:26:48 <Grizzly`> Is there trick about this?
14:27:02 <enticingjelly> vixey, i don't know, i'm german :( we call it "entscheidbarkeit"
14:27:03 <jganetsk> decidable
14:27:05 <jganetsk> like, decidability?
14:27:06 <enticingjelly> and turing wrote a paper about it
14:27:09 <jganetsk> yeah
14:27:17 <augustss> loadquo: we tried designing new architectures for FP a lot in the 80s
14:27:23 <enticingjelly> it's this really really really important concept %)
14:27:26 * Grizzly` is working through hughes "programming with arrows"
14:27:46 <enticingjelly> the halteproblem is very closely associated with it
14:27:50 <jganetsk> enticingjelly: is the language finite?
14:27:51 <enticingjelly> geez, how do you translate halteproblem.
14:28:02 <doserj> halting problem
14:28:03 <joga> halting problem
14:28:03 <jganetsk> yeah, decidable is the correct term
14:28:18 <enticingjelly> jganetsk, huh, so it is decidable?
14:28:28 <vixey> jganetsk, what does it mean
14:28:31 <enticingjelly> so why's everybody asking what I mean? 8)
14:28:40 <ksf> translating "pointer" into german isn't decidable.
14:28:44 <vixey> I am asking you because I don't know what you mean
14:28:50 <conal> heh
14:29:00 <jganetsk> vixey: something is decidable if there's an always-terminating algorithm that can calculate it
14:29:13 * loadquo goes into googling mode
14:29:17 <augustss> loadquo: but I don't believe there's some magic arch for FP, unless it's something totally radical that nobody has thought about yet
14:29:37 <enticingjelly> okay
14:29:38 <enticingjelly> anyway
14:29:38 <vixey> jganetsk, then every finite set is not decidable
14:29:42 <enticingjelly> multiple sources state that:
14:29:46 <enticingjelly> every finite set is decidable
14:29:50 <enticingjelly> vixey, that's EXACTLY my problem!
14:29:55 <vixey> enticingjelly, what is?
14:30:00 <enticingjelly> vixey, multiple sources state that every finite set is decidable
14:30:01 <augustss> loadquo: replacing both CPU and memory
14:30:07 <vixey> enticingjelly, What do they mean?
14:30:08 <enticingjelly> yet I can, for example
14:30:17 <stepcut> conal: I hate local optimums ;)
14:30:20 <Grizzly`> :/
14:30:24 <enticingjelly> M_i = { f(i) } where f(i) = 0 if i is decidable, 1 if not
14:30:33 <enticingjelly> and that set's definitely finite (it is, isn't it?)
14:30:36 <enticingjelly> so it's decidable?
14:30:40 <enticingjelly> I don't understand!
14:31:04 <vixey> enticingjelly, The statements rubbish, ask them to rewrite it in formal language
14:31:14 <jganetsk> enticingjelly, ok so let me give you scenario
14:31:20 <bodq> @pl \a -> a - b
14:31:20 <PeakerLambda> subtract b
14:31:21 <doserj> enticingjelly: well, M_i is either {0}, or {1}
14:31:31 <vixey> enticingjelly, just saying  every quux is a womble  is nonsense, if you haven't got formal def.s of quux and so on
14:31:33 <doserj> enticingjelly: both are decidable
14:31:45 <jganetsk> you have to have a "universal set" that makes up all possible strings in the language
14:31:52 <jganetsk> if that universal set is finite
14:31:57 <Saizan_> vixey: http://en.wikipedia.org/wiki/Recursive_set
14:32:01 <loadquo> CPU + Memory is not the only way to compute, look at real life neurons for example. So there are probably different ways out there.
14:32:01 <jganetsk> then any set is decidable
14:32:02 <PeakerLambda> Title: Recursive set - Wikipedia, the free encyclopedia
14:32:27 <Saizan_> (assuming that wasn't made clear in my absence)
14:32:34 <vixey> it wasn't
14:32:51 <enticingjelly> doserj, jganetsk, ahah, I think I'm beginning to understand
14:33:07 <jganetsk> enticingjelly, the reason a finite set is decidable is
14:33:11 <enticingjelly> doserj, jganetsk, so that the set is decidable doesn't mean that I know what the set looks like?
14:33:11 <jganetsk> you can store the set
14:33:23 <jganetsk> and all you have to do is check for membership in the set
14:33:49 <jganetsk> but
14:33:53 <jganetsk> that would assume
14:34:05 <enticingjelly> jganetsk, but in my example, I might not ever finish with storing the set, which is why I might never start checking for membership, but it doesn't matter, right?
14:34:20 <enticingjelly> thing is, I could, if I could? %)
14:34:28 <conal> stepcut: me too :(  "the good is the enemy of the great".
14:34:35 <vixey> this doesn't make any sense
14:34:57 <doserj> enticingjelly: huh? the set only has one element. so it is trivial to store the set.
14:35:10 <jganetsk> vixey: http://en.wikipedia.org/wiki/Formal_language
14:35:12 <blackh> @seen dons
14:35:13 <PeakerLambda> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
14:35:14 <PeakerLambda> Title: Formal language - Wikipedia, the free encyclopedia
14:35:16 <enticingjelly> doserj, but I don't know what that element is.
14:35:35 <doserj> enticingjelly: the funnz thing is that that doesn't matter
14:35:36 <jganetsk> enticingjelly: the question is, does there exist an algorithm that decides
14:35:43 <jganetsk> if the set is finite
14:35:49 <jganetsk> then, yes, there exists an algorithm that decides
14:35:51 <rwbarton> enticingjelly: every finite set is decidable.  "M_i = { f(i) } where f(i) = 0 if i is decidable, 1 if not" <-- I don't understand a word of this
14:35:51 <jganetsk> you just might not know it yet
14:36:14 <vixey> vty do you think it's got something to do with "Formal language" ?
14:36:15 <bodq> > 0x0ffl0ad
14:36:16 <PeakerLambda>   Not in scope: `l0ad'
14:36:17 <doserj> enticingjelly: you don't need to "know" the concrete algorithm. You just need to know that there is one
14:36:26 <bodq> > 0x0ff10ad
14:36:27 <PeakerLambda>   16715949
14:36:52 <bodq> > 0xba11ad
14:36:53 <PeakerLambda>   12194221
14:36:53 <jganetsk> vixey: formal languages was an approach to studying computer science
14:36:53 <enticingjelly> rwbarton, that's a set with one member, that member being either 0 if the program represented by i is decidable, 1 if not
14:36:59 <tromp__> > 0011
14:37:00 <PeakerLambda>   11
14:37:05 <enticingjelly> or maybe i should have formulated it with termination
14:37:08 <tromp__> > 0o11
14:37:08 <bodq> > 0xca11ab1e
14:37:10 <PeakerLambda>   9
14:37:10 <PeakerLambda>   3390155550
14:37:21 <doserj> either "return input == 0" or "return input == 1" will decide M_i
14:37:24 <tromp__> > 0b0110
14:37:25 <PeakerLambda>   Not in scope: `b0110'
14:37:27 <rwbarton> enticingjelly: right, so the set is either {0} or {1}.  Either way, it is decidable :)
14:37:27 <stepcut> conal: heh
14:37:35 <ozy`> can a function of type "(Foo a) => a -> a" be a valid implementation of "(Foo a, Foo b) => a -> b"?
14:37:44 <conal> does anyone know where the term "functional programming" came from?
14:37:46 <bodq> > 0xcaba1 -- !!
14:37:48 <PeakerLambda>   830369
14:37:48 <Taejo> enticingjelly, decidability is not a property of programs, it is a property of sets
14:37:55 <vixey> rwbarton, but which one is it?
14:37:57 <jganetsk> vixey: int theory, any problem can be formulated as trying to deterimine if a string exists in a certain language
14:37:59 <bodq> 830369, the number of haskell :)
14:37:59 <Botje> ozy`: i'm guessing yes
14:38:05 <rwbarton> vixey: depends on i of course
14:38:10 <enticingjelly> Taejo, yes, I meant to write "terminates" but fucked up
14:38:13 <Taejo> ok
14:38:16 <conal> i think "functional programming" confuses people into thinking it's all about functions rather than about pure (immutable) values.
14:38:21 <vixey> this is all completely ad-hoc
14:38:23 <enticingjelly> rwbarton, so, can I say that it doesn't matter if I could ever know what the set looks like?
14:38:32 <vixey> you will not make sense if you don't set a context
14:38:46 <jganetsk> conal: try system F, every singe pure immutable value is expressed as a function
14:38:55 <jganetsk> vixey: what's ad-hoc, formal languages?
14:39:04 <conal> i have a hunch that the term came from the heritage of the pure untyped lambda calculus, made up of functions only.
14:39:07 <Taejo> enticingjelly, M_i is indeed decidable for any i. M_i = {0} or M_i = {1}. both of those are decidable
14:39:15 <jganetsk> conal: both untyped and typed
14:39:17 <doserj> conal: functional programming just means that functions are first class values. purity is orthogonal to that.
14:39:19 <conal> and so has become a misnomer.
14:39:25 <rwbarton> enticingjelly: right, all you have to do to show that a language is decidable is to prove that there *exists* *some* program which decides it
14:39:35 <vixey> conal, a better term imo would be compositional programming
14:39:42 <doserj> conal: you wouldn't call ML, Scheme, Lisp functional?
14:39:56 <conal> doserj: perhaps.  but i doubt it, since people say "purely functional programming", not "pure, functional programming"
14:40:14 <jganetsk> conal: in lambda calculus, both typed and untyped... everything is a function... even integers, booleans, lists...
14:40:19 <enticingjelly> rwbarton, so for every i there *does* *exist* a program which can tell me if i terminates?
14:40:25 <rwbarton> also conal is talking about functional programming, not functional (programming languages)
14:40:39 <rwbarton> enticingjelly: Yes, of course.
14:40:43 <conal> rwbarton: exactly.  thx.
14:40:44 <doserj> conal: well, than that is a misnomer, not "functional programming" as such :)
14:40:45 <enticingjelly> rwbarton, ah. nice. didn't know that.
14:40:50 <enticingjelly> rwbarton, I got it now. thank you very much!
14:40:51 * Peaker found a use for HLists :-)
14:40:58 <rwbarton> enticingjelly: Either the program that outputs False, or the program that outputs True :)
14:41:12 <hackage> Uploaded to hackage: incremental-sat-solver 0.1.1
14:41:20 <hugo___> hello
14:41:20 <enticingjelly> rwbarton, heh. you're right 8)
14:41:27 <Taejo> Peaker, dressing up as Oleg for Halloween?
14:41:43 <vixey> rwbarton, seems like a dodgy reasoning
14:41:50 <conal> sometimes people say about haskell that everything is a function.  and i can see how that belief could be rationalized but not arrived at.
14:42:01 <vixey> rwbarton, how do you know a given program well either terminate or not terminate?
14:42:08 <rwbarton> vixey: it is an axiom of logic
14:42:11 <Peaker> Taejo: heh -- I am writing a widget set, and I need my widget containers to be able to hold a list of any widget type, without losing the type information. I currently use existentials and lose the types
14:42:31 <tromp__> he was not asked about a program given to the deciding algorithm
14:42:32 <vixey> it's not an axiom of "Formal Language" or whatever
14:42:38 <ozy`> conal: if you consider lazy evaluation, literally everything in haskell -is- a function
14:42:44 <Peaker> conal: the convention of "a -> b -> ... -> n" = function of (n-1) args kind of yields that "b" is a function of 0 arguments :)
14:42:46 <conal> rwbarton: depends on the choice of logic, right.  personally, i prefer classical to intuitionistic.
14:42:47 <rwbarton> vixey: I'm using the law of the excluded middle
14:42:53 <tromp__> he was asked about a program given to him
14:42:56 <conal> ozy`: you mean implementation, not semantics, right.
14:43:05 <jganetsk> conal: Haskell descends directly from System Fw, where every value is expressed as a function
14:43:09 <rwbarton> conal: me too.  You can always model intuitionistic logics in classical logic if the need arises.  Same with the negation of the Axiom of Choice, etc.
14:43:13 <conal> ozy`: i'm guessing that reason is a rationalization.
14:43:33 <conal> jganetsk: my kids descend from me, but they're not "purely conal" :)
14:43:38 <vixey> lol
14:43:40 <Taejo> rwbarton, you can also model classical logic in intuitionistic logic
14:44:02 <vixey> conal, (for what/why do you prefer classical?)
14:44:03 <rwbarton> Taejo: Sure, but I like to be able to prove things in my underlying logic. :)
14:44:15 <tromp__> it's simple, vixey; for every program, the question whether it halts is decidable. but there is no algorithm for deciding if a given program halts
14:44:27 <jganetsk> conal: right, but the "pure" is separate from the "functional programming"
14:44:29 <vixey> tromp__, I do not agree with that
14:44:45 <jganetsk> conal: it's a "pure, functional programming" language
14:44:54 <Taejo> vixey, note the order of quantifiers in tromp__'s statement
14:44:59 <vixey> tromp__, I can definitely give you some arbitrary program that you absolutely will not be able to prove it halts or not
14:45:11 <tromp__> we're not talking about proof
14:45:15 <conal> jganetsk: got it.  i doubt that's what people usually mean.
14:45:15 <vixey> yes we are
14:45:30 <tromp__> just about existence of a correct answer
14:45:37 <vixey> "for every program, the question whether it halts is decidable." -- this is not true
14:45:39 <vixey> You said:
14:45:40 <conal> jganetsk: and i appreciate the perspective of "pure, functional", which i was missing before.
14:45:49 <vixey> forall P : Program, halts(P) \/ ~halts(P)
14:46:28 <conal> jganetsk: e.g., the first line on the haskell wiki main page
14:46:30 <ehird> http://aftnn.org/journal/661 This seems ridiculous to me.
14:46:35 <PeakerLambda> Title: aftnn.org: afternoon's journal
14:46:38 <Taejo> vixey, program P either halts or does not halt. if it halts, then f(P) = "halts" decides whether it halts; otherwise, g(P) = "does not halt" does
14:47:44 <vixey> Taejo, Every set is decidable:
14:47:49 <tromp__> you need infinitely many questions to be answered by a single algorithm to make things undecidable
14:47:59 <vixey> Proof: exactly the same argument
14:48:08 <conal> jganetsk: and now i doubt my old interpretation ("purely functional") of what people mean also.  thx. :)
14:48:14 <Taejo> vixey, no, my argument only applies to finite sets
14:48:26 <vixey> finite sets ... such as the set of all programs?
14:48:36 <jganetsk> vixey: the set of all programs is infiite
14:48:37 <conal> "Doubt is not a pleasant condition, but certainty is absurd." - Voltaire
14:48:44 <Taejo> vixey, {P} is finite
14:48:47 <vixey> jganetsk, (I know.. that's my point)
14:49:02 <doserj> but the set of all programs is trivially decidable :)
14:49:10 <jganetsk> heh, nice
14:49:11 <rwbarton> the "question" of whether a fixed program P halts is not really a question at all
14:49:42 <Taejo> rwbarton, it certainly is... for normal people. computer scientists prefer infinite families of questions.
14:49:50 <rwbarton> or rather, it is not the sort of thing that computability theory talks about; it's a value, not a function
14:50:09 <adekoba> how can one use ReaderT with monads without return values (e.g. Put)?
14:50:29 <Taejo> rwbarton, and the fact that it is decidable whether P halts is one of the reasons *why* we prefer functions and infinite sets
14:51:18 <conal> rwbarton: as in that the halting problem is decidable for each program?
14:51:58 <rwbarton> I guess it would have been more correct to say that it's not a "problem", in the computability theory sense of the word
14:52:13 <conal> yeah.  s/the halting problem/halting/
14:52:37 <vixey> People seem to be saying:  if it's an arbitrary program, the problem is undecidable.. but for any given fixed program.. the problem is deciable
14:52:38 <chessguy> rwbarton, it's a boolean, not a function :)
14:52:53 <rwbarton> chessguy: exactly
14:53:00 <doserj> "problems" are always about deciding if the input is in some given set.
14:53:05 <vixey> This is very weird reasoning, it seems like when you replace arbitrary on the object level with arbitrary on the meta level... suddenly you are allowed to use LEM
14:53:18 <doserj> the halting problem is the set of all halting programs
14:53:29 <Taejo> vixey, arbitrary == any given fixed; the problem is decidable for arbitrary finite subsets of the set of all programs
14:53:33 <rwbarton> vixey: Of course you are, because the LEM is true. :)
14:53:47 <vixey> I have no clue wha 'true' is supposed to mean
14:54:01 <conal> s/true/beautiful/
14:54:09 <conal> ;)
14:54:21 <rwbarton> vixey: If we didn't accept the LEM, what would it even mean to say whether a program decides whether a statement is true
14:55:10 <vixey> rwbarton, I'm not sure what you asked.. what does it mean when a program () -> Bool gives an answer ?
14:55:16 <vixey> is that what you meant
14:55:22 <tromp__> vixey, we're talking about algorithms that get a program as input, and have to output whether that program halts
14:55:26 <rwbarton> vixey: Once you write Bool you are talking about classical logic
14:55:36 <vixey> tromp__, well known result no such program exists
14:55:43 <tromp__> an algorithm can be correct for a particular fixed input
14:55:47 <vixey> rwbarton, I don't think so
14:55:52 <tromp__> but not for all possible inputs
14:55:55 <vixey> Haskell is not a classical logic
14:56:27 <vixey> tromp__: I don't agree with that reasoning, you just shifted the problem into the meta level and used LEM -- that doesn't change anything, it's the same problem
14:57:20 <doserj> @check \a -> a || not a
14:57:21 <PeakerLambda>   "OK, passed 500 tests."
14:57:28 <doserj> looks classical to me
14:57:46 <vixey> doserj, that is not the definition of classical logic
14:57:59 <dever> hey all, quick question, can i overload a function i.e. func :: Bool -> Bool and func :: String -> String ?
14:58:03 <Peaker> @check \x -> reverse x == x
14:58:04 <PeakerLambda>   "OK, passed 500 tests."
14:58:09 <vixey> doserj, there is a very important diff. between {True, False} :: Bool,  and {Void, ()} :: *
14:58:25 <Taejo> @remember <doserj> @check \a -> a || not a <PeakerLambda>   "OK, passed 500 tests." <doserj> looks classical to me
14:58:25 <PeakerLambda> Good to know.
14:58:34 * loadquo laughs at people using empiricism to prove logic...
14:58:43 <Peaker> Taejo: its not lambdabot, it will be forgotten :P
14:58:46 <Gracenotes> loadquo: counterexample now
14:58:57 <Peaker> Dependently-typed programming with Haskell type-classes is pretty nuts
14:59:04 <vixey> loadquo, all mathematical reasoning should be a purely finite, syntactic game?
14:59:05 <Taejo> Peaker, what have you done to the real Mr Lambdabot?
14:59:08 <Gracenotes> :X
14:59:15 <Peaker> Taejo: don't look in my trunk
14:59:18 <rwbarton> vixey: suppose I have a language L, a subset of {0, 1}^*.  I want to write a program P that takes an element x of {0, 1}^* and returns true if x is in L and false if x is not in L.  If I'm in a non-classical logic, what is P supposed to do if the statement (x in L) or (x not in L) does not hold?
14:59:32 <rwbarton> vixey: I just don't know how you would construct a theory of computability inside a non-classical logic.
14:59:35 <Gracenotes> we killed Mr. LambdaBot with pl'ing an omega-like combinator
14:59:37 <Taejo> vixey, I thought David Hilbert was dead
14:59:39 <ehird> yes
14:59:41 <ehird> @pl \x -> x x
14:59:42 <PeakerLambda> join id
14:59:44 <vixey> rwbarton: the issue isn't even classic vs constructive
14:59:45 <ehird> killed it
14:59:51 <conal> doserj: better try more tests, just in case.
15:00:01 <Gracenotes> except we also pl'd a much more complicated one
15:00:03 <doserj> conal: :)
15:00:08 <conal> heh
15:00:18 <vixey> doserj, (did my remark about {Void, ()} :: *  make sense to you?)
15:00:19 <Gracenotes> @botsnack
15:00:20 <lunabot>  :)
15:00:20 <PeakerLambda> :)
15:00:28 <doserj> vixey: no
15:00:54 <chessguy> are all the old hpaste pastes gone? i wish tehy had been archived
15:01:38 <ozy`> @src join
15:01:38 <PeakerLambda> join x =  x >>= id
15:01:43 <conal> i'm in a chipper mood today.  happy about understanding automatic differentiation more clearly and stumbling on another nice use of type class morphisms.
15:01:55 <ozy`> :t id >>= id
15:01:57 <PeakerLambda>     Occurs check: cannot construct the infinite type: a = a -> b
15:01:57 <PeakerLambda>     Probable cause: `id' is applied to too many arguments
15:01:57 <PeakerLambda>     In the second argument of `(>>=)', namely `id'
15:02:05 <loadquo> vixey: Many people treat maths as such. I don't know just the use of quickcheck to argue that something followed a certain logic, was a little strange...
15:02:45 <Gracenotes> @type id >> id
15:02:46 <PeakerLambda> forall a. a -> a
15:02:53 <Gracenotes> @type id >>= const id
15:02:54 <PeakerLambda> forall a. a -> a
15:02:58 <vixey> hah how strange
15:03:02 <vixey> > (id >> id) 3
15:03:03 <PeakerLambda>   3
15:03:24 <vixey> > (undefined >> id) 3
15:03:26 <PeakerLambda>   3
15:04:16 <Gracenotes> @pl \f -> f >> id
15:04:16 <PeakerLambda> (>> id)
15:04:55 <Gracenotes> @type (>> id)
15:04:56 <PeakerLambda> forall a b. (b -> a) -> b -> b
15:05:25 <loadquo>  > let x = True || undefined in x
15:05:39 <Gracenotes> the deadly leading space :3
15:05:49 <doserj> > True || undefined
15:05:50 <PeakerLambda>   True
15:05:52 <loadquo> > let x = True || undefined in x -- <- Proof that haskell is not classical?
15:05:54 <PeakerLambda>   True
15:05:56 <vixey> rwbarton, if |- x in L isn't derivable, and |- x is not in L isn't derivable either, .. that doesn't show up as some incongruence
15:06:02 <Gracenotes> loadquo: it's not strict, certainly
15:06:39 <Gracenotes> neither is short-circuit evaluation in imperative languages
15:06:54 <Taejo> @check undefined || (not undefined)
15:06:55 <PeakerLambda>   Undefined
15:07:04 <Taejo> @check undefined || (not undefined) == True
15:07:05 <PeakerLambda>   Undefined
15:07:26 <Taejo> that, I would say, is more compelling evidence than True || undefined
15:08:31 <vixey> ?djinn-env
15:08:31 <PeakerLambda> data () = ()
15:08:32 <PeakerLambda> data Either a b = Left a | Right b
15:08:32 <PeakerLambda> data Maybe a = Nothing | Just a
15:08:32 <PeakerLambda> data Bool = False | True
15:08:32 <PeakerLambda> data Void
15:08:34 <PeakerLambda> type Not x = x -> Void
15:08:35 <PeakerLambda> class Eq a where (==) :: a -> a -> Bool
15:09:03 <doserj> If you want to argue that Haskell Bools are not 2-valued, and therefore not classical, sure.
15:09:45 <vixey> that doesn't even make sense
15:10:01 <rwbarton> I don't think that Haskell Bools are not 2-valued in the same way that truth values in a non-classical logic are not 2-valued.
15:10:37 <vixey> non-classical -- specifically ?
15:11:32 <Gracenotes> don't forget about Maybe Bool, too >_>
15:14:24 <pumpkin> Maybe (Either (Maybe ()) (Maybe Bool))
15:14:32 <pumpkin> just to be complete
15:14:41 <pumpkin> you never know what you might get
15:14:51 <ray> Maybe () is a great type
15:14:57 <pumpkin> yeah
15:15:08 <vixey> what is great about it?
15:15:13 <pumpkin> is gmail down for anyone but me?
15:15:16 <skorpan> it's a two-way monad!
15:15:21 <skorpan> works here pumpkin
15:15:26 <pumpkin> bah :(
15:15:30 <Gracenotes> indeed, I've just been using it
15:18:50 <BMeph> pumpkin: Nope, it's just you. :|
15:19:23 <pumpkin> http://mail.google.com/support/bin/answer.py?hl=en&answer=91343 is my issue, apparently
15:19:27 <PeakerLambda> Title: 'Bad Request: Your client has issued a malformed or illegal request' - Gmail Hel ...
15:19:46 <dever> does anyone know if theres a library that can find what program to open a file with?
15:20:04 <dever> I thought there might be one under System.* but there isnt :(
15:20:09 <vixey> an operating system
15:20:24 <vixey> oh from haskell no idea
15:20:36 <vixey> sounds very OS specific though
15:20:57 <dever> i know :(
15:20:59 <rwbarton> I have an emacs buffer visiting a .cabal file which is in Haskell-Cabal mode.  I have no idea how it got that way, but I want my other .cabal file buffers to be like it.  Any ideas?
15:21:15 <dever> looks like ill have to write my own library :(
15:21:15 <bodq> what is the simplest scrambling alrorithm you know>
15:21:19 <bodq> *argorithm
15:21:28 * bodq is developing a programmer's puzzle
15:22:04 <pumpkin> ?botsnack
15:22:05 <PeakerLambda> :)
15:22:15 <pumpkin> @botsnack
15:22:16 <lunabot>  :)
15:22:16 <PeakerLambda> :)
15:22:28 <pumpkin> lambdabot is down and no pumpkinbot :(
15:22:32 <pumpkin> peakerlambda came instead :(
15:22:40 <Badger> , botsnack
15:22:41 <lunabot>  luna: Not in scope: `botsnack'
15:22:47 <Badger> :'(
15:23:26 <chessguy_work> bodq, pick two elements randomly and swap them. repeat for some number of iterations
15:23:42 <pumpkin> sounds like a sorting algorithm!
15:23:43 <bodq> chessguy_work: well it should be reversible :)
15:23:56 <chessguy_work> um, ok...
15:24:07 <pumpkin> all permutations are reversible!
15:24:12 <vixey> [0,1,2,3,4,..]
15:24:19 <vixey> first swap 0 with a random thing from [1..]
15:24:23 <chessguy_work> bodq, you need to explain the problem more then, because i don't get it
15:24:24 <bodq> and not /too/ easy :)
15:24:26 <vixey> then first swap 1 with a random thing from [2..]
15:24:27 <vixey> etc
15:24:58 <pumpkin> bodq: zip with a random list and sort by the random list
15:25:04 <pumpkin> *sort by snd
15:25:12 <chessguy_work> vixey, apparently randomness isn't reversible, whatever that means
15:25:15 <bodq> ok sorry here's a more detailed description
15:25:32 <bodq> two routines, encode and decode, the input to both is a string
15:25:32 <vixey> I don't know what you mean but your algorithm isn't perfect
15:25:43 <bodq> invariands: decode.encode = id
15:25:48 <chessguy_work> oh
15:25:50 <chessguy_work> encyrption
15:26:08 <vixey> (maybe I made a mistake with mine too..)
15:26:28 <bodq> yeah, not shuffling
15:26:36 <chessguy> then i'd just go with some kind of substitution
15:26:42 <chessguy> a=1,b=c,etc.
15:26:45 <chessguy> err, b=2
15:27:08 <bodq> so the attacker will have black box access
15:27:17 <bodq> i.e. one can try to encrypt random text and see the result
15:27:31 <bodq> we must prevent them from guessing how to decrypt it
15:27:33 <pumpkin> can he pick the text?
15:27:39 <bodq> pumpkin: yes
15:27:59 <pumpkin> http://en.wikipedia.org/wiki/Ciphertext_indistinguishability ?
15:28:04 <chessguy> > zipWith (\x y -> x:'=':[y]) ['a'..] [1..26]
15:28:05 <PeakerLambda>   No instance for (GHC.Num.Num GHC.Types.Char)
15:28:05 <PeakerLambda>    arising from the literal `1...
15:28:06 <bodq> pumpkin: the idea that it should take ~10 minutes to crack it
15:28:23 <tromp__> ROT13 is pretty simple
15:28:35 <chessguy> > zipWith (\x y -> x:'=':[show y]) ['a'..] [1..26]
15:28:36 <PeakerLambda>   Couldn't match expected type `GHC.Types.Char'
15:28:36 <bodq> tromp__: too simple
15:28:40 <bodq> tromp__: as is base64
15:28:48 <chessguy> > zipWith (\x y -> x:'=':show y) ['a'..] [1..26]
15:28:49 <PeakerLambda>   ["a=1","b=2","c=3","d=4","e=5","f=6","g=7","h=8","i=9","j=10","k=11","l=12"...
15:29:02 <vixey> monochrom, I came across your thing about Cont monad
15:29:03 <pumpkin> bodq: just do an aribtrary substitution cipher on pairs of letters, maybe?
15:29:06 <chessguy> @pl \x y -> x:'=':show y
15:29:09 <PeakerLambda> flip ((.) . (:)) (('=' :) . show)
15:29:10 <PeakerLambda> optimization suspended, use @pl-resume to continue.
15:29:10 <bodq> attack #1: give 'a', 'b', 'c' as inputs
15:29:26 <vixey> monochrom, this 'setjmp' is so cool...
15:30:12 <monochrom> Thanks! :)
15:30:31 <bodq> pumpkin: with fixed key it's too easy
15:30:37 <chessguy> bodq, you could do like a double substitution or something
15:31:02 <bodq> chessguy: same thing, with fixed key it's too easy, and the key is too large to send with the encrypted string every time
15:31:10 <baaba> > flip (zipWith \x y -> x:'=':show y) =<< ord $ ['a'..]
15:31:11 <PeakerLambda>   <no location info>: parse error on input `\'
15:31:21 <baaba> > flip (zipWith (\x y -> x:'=':show y)) =<< ord $ ['a'..]
15:31:22 <PeakerLambda>   Couldn't match expected type `[GHC.Types.Char]'
15:31:25 <chessguy> well then you need to define "too easy" and "too large", this is silly
15:31:29 <pumpkin> bodq: ask them to break a single round of AES or something then
15:31:29 <rwbarton> bodq: It seems clear that your initial question was a lie :P
15:31:30 <baaba> erf
15:31:39 <bodq> rwbarton: eh?
15:31:46 <rwbarton> "the simplest scrambling method you know"
15:31:48 <chessguy> rwbarton, clearly
15:31:51 <bodq> rwbarton: sorry
15:31:53 <rwbarton> You actually mean, like, the least simple
15:31:54 <rwbarton> :)
15:31:58 <chessguy> lol
15:32:13 <chessguy> he forgot a (not .)
15:32:15 <bodq> yes it was a lie :) i mean the simplest non-trivial method :)
15:32:18 <ksf> is someone of you guys hacking on xhb?
15:32:25 <chessguy> bodq, define "trivial"
15:32:27 <ksf> (on it, i mean, not just using it)
15:32:46 <rwbarton> chessguy: I think "trivial" is a black box and we have to do binary search against it
15:32:47 <bodq> chessguy: it takes  < 10 minutes to crack it by a reasonably skilled individual
15:32:58 <chessguy> define "reasonably skilled"
15:33:06 * chessguy wonders how far this is going to go
15:33:07 <bodq> chessguy: like you or me
15:33:11 <bodq> chessguy: :)
15:33:27 <chessguy> it would take me a lot longer than 10 minutes for some of these methods
15:33:33 <chessguy> apparently i'm just stupid
15:33:34 <bodq> > let reasonably_skilled = "Adrian Lamo"
15:33:35 <PeakerLambda>   <no location info>: parse error on input `;'
15:34:06 <chessguy> whatever
15:34:07 * chessguy gives up
15:34:20 <baaba> > flip (zipWith (\x y -> x:'=':show y)) =<< (map ord) $ ['a'..]
15:34:21 <PeakerLambda>   ["a=97","b=98","c=99","d=100","e=101","f=102","g=103","h=104","i=105","j=10...
15:35:06 * rwbarton is amazed at the contortions people will go through to avoid list comprehensions :)
15:35:23 <baaba> just having fun ;)
15:37:05 <_knapr_> ok im finally starting to play with concurrency, writing an mp3player in Java/clojure. now here is haskells strength so how would you achieve a threa dthat polls another thread to se eif it has finished its task?
15:37:07 <pumpkin> I'm boycotting list comprehensions until they make them back into arbitrary monad comprehensions
15:37:26 <wli> rwbarton: my guess is they're trying to @pl by hand
15:37:30 <pumpkin> _knapr_: you're getting on my nerves
15:37:32 <_knapr_> also, does haskell have libs for making a decent mp3player with a small effort(say 10 hours)
15:37:46 <_knapr_> pumpkin: why?
15:38:18 <bodq> so I guess I would stick with something like encoded(i) = source(i) ^ (key(i) ** i & 0xff) where key = cycle("key phrase")
15:38:25 <ksf> if you're writing it in Java, why do you ask haskell questions?
15:39:13 <ddarius> There is an mp3 player written in Haskell already.
15:39:39 <tromp__> or use key phrase to seed a PRNG
15:39:40 <bodq> which has the advantage of being symmetrical so there's no need to write decoding routine
15:39:41 <pumpkin> _knapr_: 16:02:18 <knapr> so how will haskell get popular when neither webapps and guis is easy to make?
15:39:48 <decafbad> ddarius: pure haskell?
15:39:49 * ksf wont' be impressed by anything worse than amarok.
15:39:50 <_knapr_> ksf: im asking how it would be easier to do concurrency in haskell
15:39:58 <bodq> ksf: how it this preudocode java?
15:39:59 <pumpkin> you type `par`
15:40:00 <bodq> *is
15:40:11 <_knapr_> pumpkin: seems like a fair question...
15:40:19 <ksf> bodq, I was talking to knapr
15:40:19 <bodq> tromp__: yeah that's a good idea
15:40:27 <bodq> ksf: my apologies :)
15:40:27 <ksf> knapr, STM.
15:40:51 <Taejo> _knapr_, this case is pretty easy... just have your "waiting" thread read an MVar, and have the other thread write to that MVar when it's done
15:41:05 <pumpkin> _knapr_: what are you trying to parallelize?
15:41:12 <hackage> Uploaded to hackage: debian 3.21
15:41:19 <ksf> if you don't use STM, you have to suffer the same deadlocking pain as in any other language.
15:41:21 <ddarius> decafbad: It's not an mp3 decoder.  My understanding is that it just calls system mp3 programs.  It may also support using a library.
15:41:29 <redditbot> Fun wth ΠΣ
15:41:43 <nolrai_East> :t foldr
15:41:44 <PeakerLambda> forall a b. (a -> b -> b) -> b -> [a] -> b
15:41:48 <vixey> redditbot--
15:41:48 <vixey> redditbot--
15:41:49 <vixey> redditbot--
15:41:49 <vixey> redditbot--
15:41:51 <vixey> redditbot--
15:41:58 <sbahra> You can't define unary operators in Haskell, right?
15:41:59 <ddarius> All for nothing vixey.
15:42:05 <pumpkin> sbahra: you can define postfix ones
15:42:06 <nolrai_East> > foldr op s [a,b,c,d]
15:42:07 <PeakerLambda>   Not in scope: `op'
15:42:11 <pumpkin> sbahra: with a language extensions
15:42:11 <pumpkin> -s
15:42:15 <sbahra> vixey, you might find this useful http://pastie.org/373745
15:42:20 <PeakerLambda> Title: #373745 - Pastie
15:42:20 <ddarius> sbahra: There aren't any (except for negation which you can overload)
15:42:28 <Badger> preflex: karma redditbot
15:42:28 <preflex>  karma for redditbot: -4
15:42:30 <nolrai_East> > foldr f x [a,b,c,d]
15:42:30 <PeakerLambda>   Ambiguous occurrence `f'
15:42:31 <PeakerLambda>  It could refer to either `L.f', defined at <local...
15:42:40 <Taejo> sbahra, you can make fake postfix operators in GHC
15:42:42 <sbahra> pumpkin, -XPostfixOperators
15:42:48 <sbahra> pumpkin, thanks
15:42:57 <sbahra> Taejo, ok.
15:43:06 <chessguy> sbahra, what is that?
15:43:11 <Taejo> > let (n !) = product [1..n] in (6 !)
15:43:12 <PeakerLambda>   <no location info>: Parse error in pattern
15:43:17 <chessguy> specifically, what is (-->)
15:43:32 <Taejo> apparently PeakerLambda doesn't have that extension enabled
15:43:45 <rwbarton> I think you just can't use it to define a function.
15:43:51 <sbahra> chessguy, no idea what it will be. I want to support non-classical logic as well. For now, it generates validity trees for PL and does various transformations to WFF.
15:43:51 <rwbarton> > let (!) n = product [1..n] in (6 !)
15:43:53 <PeakerLambda>   720
15:43:57 <Taejo> oh, ok
15:43:59 <sbahra> chessguy, material implication
15:44:08 <ddarius> You can fake postfix (or prefix) much nicer using just Haskell 98.
15:44:13 <sbahra> chessguy, I plan on adding support for FoL as well.
15:44:26 <pumpkin> ddarius: how?
15:44:29 <sbahra> ddarius, how?
15:44:36 <chessguy> sbahra, hm, interesting. i'm in the process of building a representation of propositional logic and possibly FOL myself
15:44:45 <pumpkin> he needs three people to ask him before he'll tell
15:44:47 <pumpkin> anyone else?
15:44:52 <chessguy> ddarius, why?
15:44:53 <sbahra> chessguy, ah, really :)
15:44:59 <chessguy> oh, is that the wrong question? :)
15:45:03 <pumpkin> :(
15:45:06 <azathoth99> so lisp guy says dynamic type is nicer than static
15:45:07 <pumpkin> you ruined it!
15:45:09 <sbahra> chessguy, what do you have so far?
15:45:17 <sbahra> chessguy, how do you handle Truth/Falsity?
15:45:19 <pumpkin> azathoth99: define nicer
15:45:28 <chessguy> sbahra, i have a representation that automatically keeps propositions in CNF
15:45:33 <Badger> preflex: y'know, *nicer*
15:45:35 <ddarius> http://www.eecs.usma.edu/webs/people/okasaki/pubs.html#hw02 http://www.eecs.usma.edu/webs/people/okasaki/pubs.html#jfp03 http://www.informatik.uni-bonn.de/~ralf/publications/Quote.pdf
15:45:40 <PeakerLambda> Title: Chris Okasaki's Publications
15:45:54 <chessguy> sbahra, it allows you to do conjunction, disjunction, implication, biconditionals
15:45:57 <sbahra> chessguy, "keeps propositions CNF"?
15:46:08 <roconnor> pumpkin: nicer as in easier to write programs ... with errors
15:46:11 <chessguy> sbahra, are you familiar with CNF?
15:46:13 <sbahra> chessguy, this is NP-complete, yes?
15:46:16 <sbahra> chessguy, yes, I am.
15:46:18 <pumpkin> roconnor: I've always wanted that!
15:46:25 <rwbarton> Huh, I was just wondering about writing expressions without parentheses earlier today.
15:46:25 <sbahra> chessguy, maybe a copy/paste example would help me understand.
15:46:26 <roconnor> pumpkin: you should try lisp
15:46:34 <pumpkin> I had that with ruby
15:46:36 <chessguy> sbahra, i don't have the code handy, unfortunately
15:46:42 <roconnor> pumpkin: I hear their programs have even more errors than haskell programs
15:46:46 <pumpkin> sweet
15:47:00 <chessguy> sbahra, basically it says that a sentence is a [[Term]]
15:47:16 <sbahra> chessguy, ok. Well, when you do, it would be great if we could discuss our approaches.
15:47:21 <sbahra> chessguy, where Term is a WFF?
15:47:34 <chessguy> each Term is a (possibly-negated) literal
15:48:00 <chessguy> e.g., if i do p /\ q, it just concatenates the two lists
15:48:19 <chessguy> but if i do p \/ q, it distributes all the terms of q, to keep it in CNF
15:48:42 <pumpkin> sbahra: it's np-complete to figure out if the sentence is satisfiable
15:48:58 <chessguy> pumpkin, yes, unless it's all horn clauses
15:49:20 <sbahra> pumpkin, yes, sure. Wasn't arguing that.
15:49:36 <chessguy> sbahra, does that make any sense?
15:49:46 <ExtreTux> Good Night"
15:49:48 <ExtreTux> !
15:50:08 <FalconNL> Is lamdabot not working for anyone else? I'm trying to do an @pl but I'm not getting an answer.
15:50:14 <sbahra> chessguy, yes, it does.
15:50:17 <chessguy> sbahra, so a /\ (b \/ c) would be represented as [[a],[b,c]]
15:50:27 <chessguy> ok, good
15:50:39 <pumpkin> FalconNL: it's down
15:50:43 <pumpkin> use PeakerLambda
15:50:44 <chessguy> sbahra, i also wrote a simple (read slow) forward-chaining algorithm
15:50:46 <pumpkin> or pumpkinbot
15:50:46 <sbahra> vlTree . toTree $ (foldr1 (/\) premises) --> conclusion
15:50:51 <ksf> @seen sjannsen
15:50:52 <PeakerLambda> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
15:50:55 <sbahra> ;-p, haskell is nice
15:50:57 <ksf> wut?
15:51:06 <ksf> preflex, seen sjannsen
15:51:06 <preflex>  Sorry, I haven't seen sjannsen
15:51:13 <sbahra> chessguy, forward-chaining?
15:51:15 <chessguy> sbahra, and i'm trying to build something on top of the basic /\,\/,==>,<=> primitives to make it easier to define propositions
15:51:18 <rwbarton> preflex: seen sjanssen
15:51:18 <preflex>  sjanssen was last seen on #xmonad 1 hour, 58 minutes and 37 seconds ago, saying: asgaroth: sure
15:51:23 <FalconNL> pumpkin: thanks
15:51:27 <chessguy> sbahra, satisfiability algorithm
15:51:33 <sbahra> I'll check it out.
15:51:45 <sbahra> Validity trees are pretty fast.
15:51:53 <chessguy> sounds interesting
15:52:05 <sbahra> And the benefit is you can then map a variable to a truth value simply based on expression/structure.
15:52:13 <sbahra> So hopefully I'll be able to support some three-valued logics
15:52:22 <pumpkin> preflex: seen dons
15:52:22 <preflex>  dons was last seen on #haskell 3 days, 20 hours, 37 minutes and 45 seconds ago, saying: yep. i think the killer app for this year's google SoC is wiki+ haddock
15:52:28 <pumpkin> wow :)
15:52:32 <chessguy> sbahra, are you using Data.Tree ?
15:52:35 <ExtreTux> Can anyone explain me, if it's possible, to define a matrix datatype of Int with a defined length, for example, matrix 2 = [[Int Int Int Int][Int Int Int Int][Int Int Int Int][Int Int Int Int]]
15:52:39 <sbahra> chessguy, yes, it's ugly. :(
15:52:49 <chessguy> sbahra, lol
15:52:56 <sbahra> chessguy, but atleast I didn't have to write drawTree. ;-p
15:52:59 <chessguy> sbahra, i always thought it worked pretty well
15:52:59 <pumpkin> ExtreTux: you could wrap a list in a type with a type-level number
15:53:05 <pumpkin> ExtreTux: but it's not particularly pretty
15:53:20 <sbahra> chessguy, it seems strange to do child !! 1 to evaluate right child.
15:53:21 <chessguy> ok, i'm off to dinner.
15:53:30 <sbahra> chessguy, I imagine this breaks some laziness
15:53:34 <sbahra> chessguy, enjoy
15:53:41 <pumpkin> sbahra: last!
15:53:43 <chessguy> well, yeah, if all you have is binary trees
15:53:44 <pumpkin> if it's binary
15:54:01 <chessguy> it won't fully evaluate the first element anyway
15:54:07 <sbahra> pumpkin, makes no difference though.
15:54:22 <sbahra> @src last
15:54:22 <PeakerLambda> last [x]    = x
15:54:22 <PeakerLambda> last (_:xs) = last xs
15:54:22 <PeakerLambda> last []     = undefined
15:54:27 <pumpkin> how does it break laziness?
15:54:50 <pumpkin> it evalutes the "spine" of the list (is that what it's called?), but not the elements in it
15:55:30 <sbahra> pumpkin, yes, I see the wildcard.
15:55:31 <ExtreTux> A lot of thanks pumpkin ;)
15:55:40 <BMeph> ExtreTux: Have you tried a 2-D Array? :)
15:55:50 <sbahra> pumpkin, the other issue is that it is O(n).
15:56:05 <pumpkin> yeah, but if you have small branching factors that's not a big issue is it?
15:56:12 <sbahra> No, it isn't.
15:56:21 <sbahra> Atleast I hope not.
15:56:23 <pumpkin> but I agree, it's kinda ugly
15:56:25 <sbahra> I should write a random generator.
15:56:34 <sbahra> pumpkin, yes, it definitely is ugly.
15:56:45 <ExtreTux> BMeph, my problem is how to get the list with a determined size
15:56:49 <pumpkin> but having a Sequence there instead is pretty heavyweight
15:57:36 <sbahra> pumpkin, in terms of memory, sure (depending on what heavyweight is).
15:57:42 <sbahra> I don't mind that though.
15:58:26 <BMeph> ExtreTux: Does it have to be a list, though? Why not just have an Array? :)
15:58:44 <QtPlatyp1s> Is doing all the Project Eular problems in haskell a good way to learn the lanague?
15:58:56 <vixey> no not at all
15:59:41 * BMeph points vixey's way, saying "Bitter, Party on One..." ;p
15:59:44 <pumpkin> lol
15:59:46 <ivanm> vixey: were you responding to QtPlatypus there?
15:59:47 <rwbarton> QtPlatypus: *All* of them? No.  A few of them? Possibly.
15:59:48 <BMeph> *of
15:59:50 <sbahra> chessguy's stuff sounds cool
15:59:55 <pumpkin> QtPlatypus: I found it helpful to an extent
16:00:14 * QtPlatypus nods.
16:01:41 <ozy`> QtPlatypus: project euler is much more about the math than the programming
16:01:56 <pumpkin> but finding efficient solutions is a bit of both
16:02:04 <pumpkin> as you get to later ones
16:02:38 * QtPlatypus nods
16:07:06 <CakeProphet> does anyone know of a Microsoft Office file parsing library of some sort? I want to modify Word documents.
16:08:36 <ddarius> CakeProphet: Office 2007 uses a open, documented format.
16:08:43 <ddarius> (based on XML)
16:08:49 <CakeProphet> yeah, I'm reading the spec right now.
16:08:51 <BMeph> CakeProphet: So use it and make a lib! :)
16:09:17 <CakeProphet> ...well, I'll likely just parse and ignore everything but font, which is what I'm modifying with this program
16:10:02 <Hirvinen> ddarius: ... and the spec is only 6 k pages compared to ODF's 600 or somethin like that.
16:10:26 <ddarius> Hirvinen: That's for many different formats and you don't need to read all of it just to modify some stuff.
16:10:49 <arw> CakeProphet: perhaps it would be easier to script some conversion to odf, make the modifications in odf and convert back.
16:11:07 <CakeProphet> arw:  ...no if I have to convert it myself.
16:11:10 <CakeProphet> *not
16:11:27 <CakeProphet> it would be easier, I think, to modify the font bits... unless there's a pre-existing conversion tool I could use.
16:12:49 <arw> not really. the traditional ms office format is sufficiently convoluted that 'just looking for the font bits' won't work.
16:13:06 <arw> except perhaps if you try replacing the font-name string.
16:13:22 <arw> but that will of course break if the new name is longer...
16:13:43 <ddarius> arw: It sounds like he's using the newest (open) format.
16:15:01 <CakeProphet> ...I probably will, since the binary is more confusing and since the friend I'm doing this for has 2007 it would be unnecessary to support previous formats.
16:15:21 <arw> then it could even work. except for some special cases like wordart, embedded graphics and some other obscure features.
16:16:18 <CakeProphet> eh, basically what I'm doing is randomly changing the font between multiple fonts.
16:16:53 <CakeProphet> because my friend wants to make a font of his handwriting, but wants it to "not look like a font" by randomly changing font.
16:17:13 <arw> then you are looking at the wrong problem.
16:17:19 <arw> fonts can be procedural.
16:17:22 <ddarius> CakeProphet: Tell him to explore the details of TTF
16:17:32 <CakeProphet> ...ah.
16:17:39 <CakeProphet> so you can specify that?
16:17:59 <ddarius> TTF fonts are programs
16:18:16 <arw> you can make a font that 'calculates' the shape of the next letter. and of course you can use (pseudo-)random components in that calculation.
16:19:15 <CakeProphet> ....aaah
16:19:21 <CakeProphet> cool.
16:19:24 * CakeProphet never knew that.
16:19:38 <CakeProphet> most fonts look pretty simple, so I never suspected you could apply arbitrary logic to them
16:19:51 <pumpkin> they're monstrously complex :)
16:20:06 <X-Scale> typeset design is a art by itself
16:20:26 <Taejo> arw, there's not enough state in a TTF to make a letter look different in different places
16:20:31 <CakeProphet> TrueType is what Word uses, right?
16:20:51 <ddarius> CakeProphet: Almost everything supports ttf.
16:21:02 <Taejo> CakeProphet, TrueType is a subset of OpenType, Word uses OpenType and possibly PostScript
16:21:07 <arw> Taejo: i don't know if ttf supports this. but i'm pretty sure metafont does.
16:21:38 <ddarius> I'm pretty sure I've seen ttf fonts that do the sort of thing CakeProphet is talking about.
16:21:39 <pumpkin> I don't really like opentype/truetype
16:21:54 <Taejo> arw, metafont is different, the glyphs are actually produced programatically (though I don't know how much state there is in MF either)
16:22:16 <pumpkin> you can't make it behave a ttf behave randomly but you can make pretty arbitrary contextual substitutions (a bit like rewrite rules in ghc)
16:22:29 <Taejo> pumpkin, that's OpenType
16:22:29 <pumpkin> except you only get one level of rewrite
16:22:37 <pumpkin> yeah, sorry
16:22:46 <CakeProphet> basically I just need something that works with Word 2007 to allow the font to appear unpredictable.
16:23:00 <pumpkin> has he played with zapfino?
16:23:08 <CakeProphet> ...no
16:23:12 <Taejo> a TTF glyph is a collection of quadratic beziers, plus (optionally) a program to modify those beziers at different sizes
16:23:19 <pumpkin> it's a pretty fun font, and is available on all macs
16:23:47 <thedward> SIL has an opentype extension that lets you do all sorts of fun stuff. One of their example fonts is a pig-latin font.
16:24:04 <pumpkin> it would be nice if they supported more than 65k glyphs in a font though
16:24:36 <Taejo> pumpkin, doesn't OTF?
16:24:40 <pumpkin> nope
16:25:31 <sbahra> pumpkin, http://www.eecs.usma.edu/webs/people/okasaki/pubs.html#hw02 was for us
16:25:35 <PeakerLambda> Title: Chris Okasaki's Publications
16:25:40 <pumpkin> sbahra: yeah, saw it :)
16:25:48 <Taejo> pumpkin, doesn't Arial Unicode MS have more than 65k glyphs?
16:25:50 <pumpkin> I thought I acknowledged it, maybe not
16:25:53 <CakeProphet> so which approach should I take. The font level or the document level?
16:26:31 <Taejo> oh, it looks like it only has around 50k glyphs
16:26:33 <pumpkin> Taejo: I don't believe so
16:26:34 <pumpkin> yeah
16:26:41 <pumpkin> the largest font I have was split into two parts
16:26:43 <Taejo> CakeProphet, I'd right opentype rules
16:26:45 <pumpkin> because it didn't fit
16:27:58 <pumpkin> what's a good way to structure a program (in haskell) that can read arbitrary message types from a file stream, and needs to do vaguely different things based on what kind of message it sees?
16:28:08 <roconnor> how do I double buffer with cairo?
16:28:09 <CakeProphet> Taejo:  and random substition will work in opentype (and be compatible with word?)
16:28:21 <dcoutts> roconnor: are you using gtk?
16:28:46 <Taejo> CakeProphet, I have no idea about Word -- I believe it doesn't enable contextual substitution in all scripts, so you'd have to check that out
16:28:50 <dcoutts> roconnor: if you're using cairo to paint onto gtk widgets then gtk does it for you, so long as you use gtk right.
16:29:05 <dcoutts> roconnor: which means only ever painting in an expose handler.
16:29:10 <roconnor> dcoutts: oh
16:29:16 <Taejo> and you won't get anything approaching a good PRNG, let alone true randomness
16:29:25 <Taejo> but it's probably enough to *look* random
16:29:32 <CakeProphet> Taejo:  but opentype (in general) is compatible with Word right?
16:29:35 <CakeProphet> most of it, at least
16:29:37 <Taejo> yes
16:29:38 <pumpkin> I have a binary stream where I can read a number that indicates the message type that follows...
16:29:54 <dcoutts> roconnor: doing drawing exclusively in the expose handler is the one true way
16:29:58 <pumpkin> is there a standard pattern for that?
16:29:59 <Taejo> CakeProphet, the problem is that each script has a separate shaping engine, and not all shaping engines are complete
16:30:10 <ddarius> pumpkin: It's called a case statement.
16:30:19 <CakeProphet> ...I don't know enough about fonts to understand what that means, Taejo
16:30:42 <ddarius> or you could use a lookup table
16:30:44 <roconnor> dcoutts_: do you know how cairo redenering works in gtk?  It feel slower than before I upgraded.  So many things have changed in the upgrade.  I'd like to blame the video driver, but I don't know what to look for
16:31:00 <Taejo> CakeProphet, not all shaping engines enable all opentype tables... so some of them ignore contextual substitutions (which is what you'd be using)
16:31:01 <pumpkin> ddarius: hmm, I had a case statement but a lookup table might be nicer
16:31:06 <pumpkin> or lookup association list
16:31:09 <CakeProphet> ddarius:  I have problems with function lookup tables because the types have to be uniform.
16:31:13 <pumpkin> given that it's pretty small
16:31:40 <CakeProphet> Taejo: why do they all use different shaping engines?
16:32:05 <sbahra> CakeProphet, why do they have to be uniform?
16:32:22 <Taejo> CakeProphet, they have to... the shaping rules for Arabic are different from the ones for Tibetan
16:32:25 <sbahra> CakeProphet, can't you use existential types to abstract this away?
16:32:29 <CakeProphet> sbahra:  well, is there a way to satisfy to type signature for Map if all the functions have different type signatures?
16:32:54 <CakeProphet> ....I don't know how to use existential types work here.
16:33:24 <CakeProphet> and aren't they unsupported?
16:33:37 <sbahra> GHC extension.
16:34:01 <CakeProphet> hmm... so how would it work? to make a look up table that has different function type signatures.
16:34:17 <sbahra> No idea. That's why I asked you.
16:34:26 <CakeProphet> oh... heh.
16:34:30 <sbahra> http://www.haskell.org/haskellwiki/Existential_type , I'd love to know what you come up with ;-p
16:34:33 <dcoutts> roconnor: cairo rendering in gtk uses the cairo X11 backend.
16:34:34 <PeakerLambda> Title: Existential type - HaskellWiki
16:35:23 <roconnor> dcoutts: right.  I blame my X11 for making cairo slow.  But I'm not sure, and wouldn't know where to start looking
16:35:30 <roconnor> dcoutts: undoing the upgrade is impossible
16:37:35 <pumpkin> ddarius: my issue is that I have a bunch of different reader functions for the different messages, and my lookup table would have type (Message a) => [(Int, ByteString -> (a, ByteString))], which seems like it might need rank-2 types or something, with a forall for that a?
16:38:14 <sbahra> pumpkin, rank-2 types?
16:38:35 <Taejo> pumpkin, you've got the right idea, but that's existentials, not rank-2 types
16:38:39 <pumpkin> oh sorry
16:39:12 <pumpkin> so as long as I have general-enough functions in that Message typeclass to do what I need, that should work?
16:39:19 <Taejo> pumpkin, exactly
16:39:26 <pumpkin> sounds good :)
16:40:26 <Taejo> well, I would say specific-enough functions :) -- without the class constraint, you'd have the type (exists a. a), and all you can do with that is apply the most general function, id (or undefined, or const undefined)
16:41:14 <pumpkin> how would I write it? forall a. (Message a) => [(Int, ByteString -> (a, ByteString)] ?
16:42:18 <Taejo> pumpkin, no, you want [(Int, forall a. Message a => ByteString -> (a, ByteString)] I think
16:42:36 <pumpkin> oh okay :)
16:42:54 <Taejo> :t [] :: [(Int, forall a. Message a => ByteString -> (a, ByteString)]
16:42:55 <PeakerLambda> parse error on input `]'
16:43:03 <Taejo> :t [] :: [(Int, forall a. Message a => ByteString -> (a, ByteString))]
16:43:04 <PeakerLambda>     Not in scope: type constructor or class `Message'
16:43:04 <PeakerLambda>     Not in scope: type constructor or class `ByteString'
16:43:04 <PeakerLambda>     Not in scope: type constructor or class `ByteString'
16:43:21 <Taejo> :t [] :: [(Int, forall a. Num a => String -> (a, String))]
16:43:22 <PeakerLambda> [(Int, forall a. (Num a) => String -> (a, String))]
16:43:28 <Taejo> well, it's a valid type
16:44:12 <pumpkin> alright :)
16:44:19 <pumpkin> I'll give it a go
16:45:27 <pumpkin> it wants me to use -XImpredicativeTypes
16:46:17 <rwbarton> that's a universal type.
16:46:43 <JoshTriplett> If I have some data type with several constructors, does some kind of single-pass multi-way partition exist to help me get a list of the instances of each constructor?
16:46:49 <pumpkin> rwbarton: ?
16:46:53 <rwbarton> you want an existential wrapper like  data MessageHandler where MessageHandler :: forall a. Num a => (String -> (a, String)) -> MessageHandler
16:46:58 <CakeProphet> ah... OpenType has a easier to read format to work in
16:47:19 <pumpkin> rwbarton: alright, I'll try tha
16:47:21 <ski_> rwbarton : are you sure pumpkin wants that ?
16:47:22 <pumpkin> so that's a GADT?
16:47:40 <rwbarton> It is.  You don't really need GADTs for this but the syntax is easier to remember
16:47:45 <rwbarton> there is an equivalent non-GADT syntax
16:47:48 * ddarius waits and sees how many different things people will say pumpkin wants.
16:47:49 <rwbarton> ski_: no
16:48:16 <Taejo> ddarius, I'm afraid rwbarton is right
16:48:28 <pumpkin> all I want is an elegant way to deal with needing to read in different message types from a file :)
16:48:45 <rwbarton> I don't see what is wrong with data Message = Message1 ... | Message2 ...
16:48:46 <Taejo> pumpkin, I think rwbarton is leading you down the right path
16:48:58 <Taejo> rwbarton, too easy :)
16:49:17 <ski_> pumpkin : do you want each reader function to potentially be able to read values of any type `a' in class `Message' ?
16:49:43 <stepcut> I am trying to write some code which looks at the packages that are installed (aka, ghc-pkg list), but I can't seem to find the function that reads that information in...
16:49:43 <ski_> pumpkin : or should each reader function just be able to read values of some specific type `a' (in class `Message') =
16:49:47 <ski_> s/=/?/
16:50:01 <ski_> (pumpkin : or something else entirely ?)
16:50:25 <pumpkin> well, each message is of a specific type... I just want a function that can read in a message and based on a tag in the binary representation decide how to parse it
16:50:57 <roconnor> dcoutts_: vlc screwed up my X, so I guess I have big problems :)
16:51:06 <ski_> so the tag should determine the type `a', then ?
16:51:12 <pumpkin> ski_: yeah
16:51:24 <ski_> ok, then i think you're after existentials
16:51:25 <rwbarton> pumpkin: what are you going to do with this message after you've parsed it, if you don't know its type?
16:51:27 <pumpkin> but obviously I can't get the specific type, so all I have is a general typeclass
16:51:34 * stepcut finally finds the function
16:51:43 <pumpkin> rwbarton: call typeclass methods on it, I guess :)
16:51:46 <pumpkin> that's the best I can do isn't it?
16:52:09 <rwbarton> In that case, you can use typeclasses and existentials
16:52:11 <ddarius> pumpkin: What are the type class methods?
16:52:25 <ski_> pumpkin> :i Message
16:52:57 <pumpkin> ddarius: I haven't quite decided yet :/
16:54:11 <pumpkin> I have a data format with a variety of different message types in it, and need to spit each message type out to a different file after processing specific to the type
16:55:16 <ddarius> pumpkin: Is there any context sensitivity?
16:55:41 <pumpkin> a bit
16:56:40 <pumpkin> messages are timestamped and while they can't arrive out of order, I need to know when the last one of the same class arrived
17:00:34 <pumpkin> anyway, I'll bbiab
17:10:16 <jamii> @seen dons
17:10:16 <PeakerLambda> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
17:11:15 <jamii> > print "LambdaBot is alive!"
17:11:16 <PeakerLambda>   * Exception: "<IO ()>"
17:11:19 <jamii> I see
17:13:13 <ksf> preflex, seen dons
17:13:13 <preflex>  dons was last seen on #haskell 3 days, 21 hours, 58 minutes and 36 seconds ago, saying: yep. i think the killer app for this year's google SoC is wiki+ haddock
17:13:28 <JoshTriplett> hpaste seems down at the moment.
17:13:37 <ksf> @where hpaste2
17:13:37 <PeakerLambda> I know nothing about hpaste2.
17:13:43 <ksf> lamdabot, too.
17:13:47 <JoshTriplett> Ow.
17:13:47 <ksf> moonpatio.com
17:14:29 <JoshTriplett> How can I write http://haskell.pastebin.com/d551cb060 more cleanly?
17:15:14 <rwbarton> wow, ghc really does generate awful code for Int64 on 32-bit architectures.
17:15:14 <ivanm> JoshTriplett: probably can't
17:15:20 <saml> how can I generate all Int pairs that are less than r?   like given r = 5,  (0,0), (0,1), (0,2), (0,3), (0,4)... (1,0), (1, 1), ....., (5,5)
17:15:25 <ivanm> without multiple passes, anyway
17:15:26 <sbahra> rwbarton, what did it generate?
17:15:44 <rwbarton> sbahra: I will paste something
17:15:45 <ivanm> JoshTriplett: I mean, you could do four lots of filter on the list
17:15:55 <saml> > [(x,y) | x <- [0..5], y <- [0..5]]
17:15:57 <PeakerLambda>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(1,0),(1,1),(1,2),(1,3),(1,4),(1,5),(2...
17:15:59 <ksf> > [(x,x) | x <- [0..5]
17:15:59 <JoshTriplett> ivanm: Yeah, but the predicates seem equally annoying to write.
17:16:00 <saml> i'm a genius
17:16:00 <PeakerLambda>   <no location info>: parse error on input `;'
17:16:10 <ksf> > [(x,x) | x <- [0..5]
17:16:11 <PeakerLambda>   <no location info>: parse error on input `;'
17:16:16 <ksf> > [(x,x) | x <- [0..5]]
17:16:17 <PeakerLambda>   [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5)]
17:16:18 <Cale> > liftM2 (,) [0..5] [0..5]
17:16:19 <PeakerLambda>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(1,0),(1,1),(1,2),(1,3),(1,4),(1,5),(2...
17:16:26 * ksf fails
17:16:30 <Cale> > replicateM 2 [0..5]
17:16:31 <PeakerLambda>   [[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[1,0],[1,1],[1,2],[1,3],[1,4],[1,5],[2...
17:16:37 <ivanm> saml: modest, too ;-)
17:16:46 <JoshTriplett> Cale: Whoa, that last one seems nice.
17:17:18 <JoshTriplett> > let f = replicateM 2 . enumFromTo 0 in f 5
17:17:20 <PeakerLambda>   [[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[1,0],[1,1],[1,2],[1,3],[1,4],[1,5],[2...
17:17:22 <JoshTriplett> > let f = replicateM 2 . enumFromTo 0 in f 2
17:17:23 <PeakerLambda>   [[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]
17:17:49 <ddarius> JoshTriplett: The last one produces list of lists which isn't particularly nice.
17:18:31 <JoshTriplett> ivanm: Oh, a friend of mine came up with a better approach.
17:18:40 <JoshTriplett> ivanm: Four list comprehensions with pattern matching.
17:18:44 <Cale> Well, it's by necessity of the way that it generalises the problem :)
17:18:52 <Cale> > replicateM 3 [0..5]
17:18:54 <PeakerLambda>   [[0,0,0],[0,0,1],[0,0,2],[0,0,3],[0,0,4],[0,0,5],[0,1,0],[0,1,1],[0,1,2],[0...
17:19:10 <rwbarton> sbahra: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1023#a1023 ; I had to cut off some from the end
17:20:07 <saml> how can i count elements in a list that satisfies predicate?
17:20:18 <Cale> length . filter p
17:20:20 <saml> length (filter p l)   that's what i'm doing and it's stupid and slow
17:20:28 <saml> i mean, stupidly slow
17:20:48 <Cale> Then you need to do something else entirely, which will depend on what the list and predicate are.
17:21:14 <floyd> what does the // operator do?
17:21:25 <saml> Cale, wouldn't length and filter traverse the list twice?
17:21:35 <rwbarton> floyd: updates elements of an array (by copying it)
17:21:37 <saml> floyd, i think it's difference.. of sets
17:21:40 <rwbarton> @type (//)
17:21:40 <PeakerLambda> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
17:21:45 <saml> oh never mind
17:22:05 <bla123> problem: ghc 6.10 depends on libedit.so.0, but i only have libedit.so (softlinking helps, but did i do sth wrong?)
17:22:09 <floyd> thanks
17:22:09 <Cale> saml: depends what you mean... the elements will be counted as they pass the filter.
17:22:29 <Cale> saml: It doesn't build the whole list first and then apply length.
17:22:32 <olivierp> hi, I'm writing a monad that encapsulates IO, declared like this: newtype Solution a = Solution { runSolution :: Calls -> IO (a, Calls) }. Is there a way for the IO to only apply to a, like  this: newtype Solution a = Solution { runSolution :: Calls -> (IO a, Calls) } ?
17:22:54 <monochrom> softlinking is right, bla123.
17:23:28 <olivierp> I tried the second style first but wasn't able to write >>= - I felt like I would need something to do IO a -> a, which of course doesn't exist.
17:23:46 <Cale> olivierp: My guess is that no there isn't.
17:23:48 <arw> bla123: ldconfig also does soft links. its perfectly ok and expected to use softlinks for that.
17:24:01 <ksf> bla123, your distro got it wrong.
17:24:03 <SamB> why oh why didn't he remember to push this before :-( http://hackage.haskell.org/trac/ghc/ticket/2191/
17:24:15 <ksf> libedit.so should be a link to the latest libedit.so.*
17:24:36 <bla123> arw,ksf: thanks :)
17:24:42 <JoshTriplett> > range ((0, 0), (5, 5))
17:24:43 <PeakerLambda>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(1,0),(1,1),(1,2),(1,3),(1,4),(1,5),(2...
17:25:13 <JoshTriplett> saml: ^
17:25:33 <CakeProphet> @instances Enum
17:25:34 <PeakerLambda> (), Bool, Char, Double, Float, Int, Integer, Ordering
17:25:39 <olivierp> Cale: ok, that makes sense... thanks
17:25:40 <saml> @hoogle range
17:25:41 <PeakerLambda> Data.Ix range :: Ix a => (a, a) -> [a]
17:25:41 <PeakerLambda> Language.Haskell.TH data Range
17:25:41 <PeakerLambda> Language.Haskell.TH.Syntax data Range
17:25:43 <CakeProphet> .... ()?
17:26:00 <JoshTriplett> @instances Ix
17:26:01 <PeakerLambda> Couldn't find class `Ix'. Try @instances-importing
17:26:09 <CakeProphet> range ((), ())
17:26:17 <CakeProphet> > range ((), ())
17:26:19 <PeakerLambda>   [()]
17:26:23 <CakeProphet> ...wat.
17:26:33 <Gracenotes> > range (1, 1)
17:26:34 <CakeProphet> > succ ()
17:26:35 <PeakerLambda>   [1]
17:26:35 <PeakerLambda>   * Exception: Prelude.Enum.().succ: bad argument
17:26:37 <JoshTriplett> CakeProphet: () has precisely one index. :)
17:26:44 <CakeProphet> ...how is that even useful.
17:26:49 <CakeProphet> > pred ()
17:26:51 <PeakerLambda>   * Exception: Prelude.Enum.().pred: bad argument
17:26:56 <JoshTriplett> > succ 1
17:26:57 <PeakerLambda>   2
17:27:06 <JoshTriplett> Generality, I suppose.
17:27:11 <Gracenotes> () is good to have around.
17:27:26 <Gracenotes> Not necessarily for Arrays... but in general (?)
17:27:35 <CakeProphet> @hoogle (Enum a)
17:27:36 <PeakerLambda> Warning: Unknown type Enum
17:27:36 <PeakerLambda> Prelude undefined :: a
17:27:36 <PeakerLambda> Data.Array.Base arrEleBottom :: a
17:27:42 <CakeProphet> @hoogle (Enum a) => a
17:27:42 <PeakerLambda> Prelude pred :: Enum a => a -> a
17:27:42 <PeakerLambda> Prelude succ :: Enum a => a -> a
17:27:42 <PeakerLambda> Prelude toEnum :: Enum a => Int -> a
17:27:59 <CakeProphet> > toEnum 1 :: ()
17:28:00 <PeakerLambda>   * Exception: Prelude.Enum.().toEnum: bad argument
17:28:00 <JoshTriplett> @hoogle (Ix a) => a
17:28:01 <PeakerLambda> Prelude undefined :: a
17:28:01 <PeakerLambda> Data.Array.Base arrEleBottom :: a
17:28:01 <PeakerLambda> Test.QuickCheck.Batch bottom :: a
17:28:03 <Gracenotes> CakeProphet: it's not an Enum
17:28:05 <CakeProphet> > toEnum 0 :: ()
17:28:06 <PeakerLambda>   ()
17:28:17 <Gracenotes> @type range
17:28:17 <PeakerLambda> forall a. (Ix a) => (a, a) -> [a]
17:28:21 <CakeProphet> ...oh
17:28:26 <CakeProphet> well, it's an Enum too
17:28:33 <Gracenotes> er, yeah, meant that
17:29:02 <CakeProphet> ...I don't really understand what seperates an Enum from a Ix
17:29:04 <Gracenotes> > index ((), ()) ()
17:29:06 <PeakerLambda>   0
17:29:12 <ddarius> It is often useful to handle/have trivial cases.
17:29:30 <CakeProphet> so is there a way to make all instances of Enum an instance of Ix?
17:29:41 <Gracenotes> not all Enums are appropriate as array positions
17:29:59 <CakeProphet> ...such as?
17:30:03 <rwbarton> Double
17:30:05 * rwbarton ducks
17:30:22 <CakeProphet> what's stopping double from being one?
17:30:27 <CakeProphet> rwbarton:  heh
17:30:56 <Gracenotes> LT, EQ, GT -- not that useful as array indices, I should think?
17:31:07 <CakeProphet> @instances Ix
17:31:08 <PeakerLambda> Couldn't find class `Ix'. Try @instances-importing
17:31:08 <rwbarton> > range (LT, GT)
17:31:10 <PeakerLambda>   [LT,EQ,GT]
17:31:17 <rwbarton> > range (0::Double, 4)
17:31:18 <PeakerLambda>   No instance for (GHC.Arr.Ix GHC.Types.Double)
17:31:18 <PeakerLambda>    arising from a use of `GHC...
17:31:20 <Gracenotes> ...eh :/
17:31:32 <CakeProphet> Gracenotes:  bool is one too
17:31:41 <CakeProphet> () is about as useful as Ordering I think.
17:31:53 <JoshTriplett> > [0..5] ! ()
17:31:54 <PeakerLambda>   Couldn't match expected type `GHC.Arr.Array i e'
17:31:59 <JoshTriplett> > [0..5] !! ()
17:32:01 <PeakerLambda>   Couldn't match expected type `GHC.Types.Int'
17:32:13 <rwbarton> > succ (3%5)
17:32:14 <PeakerLambda>   8 % 5
17:32:14 <Gracenotes> > succ (4.43 :: Double)
17:32:15 <JoshTriplett> > array [0..5] ! ()
17:32:15 <PeakerLambda>   5.43
17:32:16 <CakeProphet> but my question is this: can you /make/ all instances of Enum an instance of Ix with only one definition.
17:32:16 <PeakerLambda>   Couldn't match expected type `(i, i)' against inferred type `[a]'
17:32:32 <Gracenotes> instance (Enum a) => Ix a where...
17:32:33 <rwbarton> CakeProphet: "yes", but not really
17:32:38 <CakeProphet> instance (Enum a) => Ix a where ...
17:32:46 <CakeProphet> @src Ix
17:32:47 <PeakerLambda> class (Ord a) => Ix a where
17:32:47 <PeakerLambda>     range           :: (a,a) -> [a]
17:32:47 <PeakerLambda>     index           :: (a,a) -> a -> Int
17:32:47 <PeakerLambda>     inRange         :: (a,a) -> a -> Bool
17:32:47 <PeakerLambda>     rangeSize       :: (a,a) -> Int
17:32:54 <rwbarton> it will overlap with all other instances, and you want other instances like (a, b)
17:32:55 <CakeProphet> and just define each of those in terms of succ and pred.
17:33:05 <CakeProphet> ...ah
17:33:12 <Gracenotes> CakeProphet:: did you notice the succ of the Double?
17:33:23 <CakeProphet> yes?
17:33:25 <rwbarton> > range (3%5, 13%5)
17:33:26 <PeakerLambda>   No instance for (GHC.Arr.Ix (GHC.Real.Ratio t))
17:33:27 <PeakerLambda>    arising from a use of `G...
17:33:34 <CakeProphet> Gracenotes:  what about it?
17:34:02 <Gracenotes> how would you handle Double as an Ix? Floor it?
17:34:15 <CakeProphet> Double really doesn't have much reason to be an Enum, theoretically. I suppose it's useful to make ranges that increment by one.
17:34:25 <CakeProphet> Gracenotes:  ...just use succ and pred?
17:34:39 <rwbarton> It's kind of unclear what Enum is supposed to represent
17:34:51 <Gracenotes> what if you want to insert something in a spot between, say, 3.43 and 4.43 (succ of the first)?
17:35:06 <JoshTriplett> Amusingly, you can count the rational numbers but you still can't make a useful Ix out of them.
17:35:09 <CakeProphet> I just think of Enum as something with a successor and a predeccesor. I suppose Double has those, but it's infinitely ambiguous.
17:35:29 <Cale> I think of Enum as the class of types for which the list enumeration notation is defined.
17:35:32 <CakeProphet> Gracenotes:  ...you couldn't, because it's not in range.
17:35:37 <JoshTriplett> > rangeSize ((0,0,0,0,0),(5,5,5,5,5))
17:35:38 <PeakerLambda>   7776
17:35:46 <JoshTriplett> > 6*6*6*6*6
17:35:47 <PeakerLambda>   7776
17:36:02 <Gracenotes> CakeProphet: that seems like a bit of an arbitrary behavior
17:36:26 <CakeProphet> Gracenotes:  so are the behaviors for succ and pred on Doubles?
17:36:30 <CakeProphet> ... minus the ?
17:36:39 <JoshTriplett> Also note that depending on how your decimal numbers quantize into Doubles, you'll get inclusive or exclusive ranges.
17:36:46 <JoshTriplett> > succ 1.0
17:36:47 <PeakerLambda>   2.0
17:36:55 <JoshTriplett> > succ 1.0 < 2.0
17:36:56 <PeakerLambda>   False
17:36:59 <JoshTriplett> > succ 1.0 <= 2.0
17:36:59 <rwbarton> @src Enum
17:37:00 <PeakerLambda> class  Enum a   where
17:37:00 <PeakerLambda>     succ                     :: a -> a
17:37:00 <PeakerLambda>     pred                     :: a -> a
17:37:00 <PeakerLambda>     toEnum                   :: Int -> a
17:37:00 <PeakerLambda>     fromEnum                 :: a -> Int
17:37:02 <PeakerLambda> [3 @more lines]
17:37:04 <PeakerLambda>   True
17:37:13 <chessguy_work> err, what is haskell's problem with this code? http://codepad.org/iwGUeZAs
17:37:39 <saml> !paste
17:38:10 <rwbarton> chessguy_work: Ord is not a superclass of Num
17:38:13 <Taejo> chessguy_work, another instance of Hugs giving less informative errors than GHCi
17:38:13 <Gracenotes> chessguy_work: is Ord defined for an arbitrary Num?
17:38:16 <Cale> chessguy_work: It doesn't know what type 2 is. Also, I think it will complain about that instance overlapping.
17:38:25 <Taejo> @src Num
17:38:25 <PeakerLambda> class  (Eq a, Show a) => Num a  where
17:38:26 <PeakerLambda>     (+), (-), (*)           :: a -> a -> a
17:38:26 <PeakerLambda>     negate, abs, signum     :: a -> a
17:38:26 <PeakerLambda>     fromInteger             :: Integer -> a
17:38:35 <chessguy_work> oh, weird
17:38:39 <Cale> Oh, right, there's that as well.
17:38:44 <chessguy_work> @src Ord
17:38:44 <PeakerLambda> class  (Eq a) => Ord a  where
17:38:45 <PeakerLambda>     compare      :: a -> a -> Ordering
17:38:45 <PeakerLambda>     (<), (<=), (>), (>=) :: a -> a -> Bool
17:38:45 <PeakerLambda>     max, min         :: a -> a -> a
17:38:45 <Cale> chessguy_work: Consider complex numbers.
17:38:56 <chessguy_work> bah
17:39:08 <rwbarton> That instance declaration is also not Haskell 98
17:39:30 <Taejo> why is Show a superclass of Num?
17:39:31 <chessguy_work> @instances-importing Ord
17:39:32 <PeakerLambda> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
17:39:39 <chessguy_work> rwbarton, why?
17:39:42 <Cale> Taejo: not any particularly good reason
17:39:43 <rwbarton> Apparently hugs doesn't care: http://codepad.org/UB6SpBOb
17:39:55 <JoshTriplett> @instances-importing Ix
17:39:56 <PeakerLambda> Couldn't find class `Ix'. Try @instances-importing
17:40:01 <JoshTriplett> Gee, thanks.
17:40:02 <Cale> Taejo: I can explain why Eq is, though (though it's also not a great reason).
17:40:04 <saml> > let f r = (length . filter (\(x,y) -> x^2 + y^2 <= r^2)) (range ((-r,-r), (r,r))) in f (10^10)
17:40:09 <rwbarton> chessguy_work: Because the instance "head" (the thing after Signed) is not of the form C t1 t2 ... tn where C is a constructor and the ti are type variables
17:40:17 <PeakerLambda>   mueval: Prelude.read: no parse
17:40:17 <PeakerLambda>  mueval: out of memory (requested 1048576 by...
17:40:19 <Cale> Eq is a superclass of Num because it's needed to support n-patterns.
17:40:25 <Cale> like f 0 = ...
17:40:27 <saml> how can I make that faster?
17:40:28 <Taejo> yeah
17:40:39 <saml> and less memory consuming.
17:40:46 <Gracenotes> ix is... WordX, IntX, tuples of Ixes, Chars, Ints, Bools, Orderings, ()'s, and GeneralCategories
17:40:58 <rwbarton> chessguy_work: in fact ghc will reject this instance without UndecidableInstances
17:41:02 <Gracenotes> (up to 5-tuples)
17:41:02 <Cale> saml: Are you computing pi?
17:41:09 * chessguy_work sighs
17:41:22 <Cale> saml: That's an inherently inefficient way to do it ;)
17:41:30 <rwbarton> I don't know why hugs allows it
17:41:30 <redditbot> Software Simply: Happstack: An Interview with Matthew Elder
17:41:30 <saml> Cale, http://en.wikipedia.org/wiki/Gauss_circle_problem  this one.
17:41:32 <JoshTriplett> > let f (x,y) = ((x,x),(y,y)) in range . f (0,5)
17:41:33 <PeakerLambda>   Couldn't match expected type `a -> (a1, a1)'
17:41:34 <PeakerLambda> Title: Gauss circle problem - Wikipedia, the free encyclopedia
17:41:40 <JoshTriplett> > let f (x,y) = ((x,x),(y,y)) in range $ f (0,5)
17:41:41 <PeakerLambda>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(1,0),(1,1),(1,2),(1,3),(1,4),(1,5),(2...
17:41:47 <JoshTriplett> > let f (x,y) = ((x,x),(y,y)) in range $ f $ f (0,5)
17:41:49 <PeakerLambda>   [((0,0),(0,0)),((0,0),(0,1)),((0,0),(0,2)),((0,0),(0,3)),((0,0),(0,4)),((0,...
17:41:59 <JoshTriplett> > let f (x,y) = ((x,x),(y,y)) in length $ range $ f (0,4)
17:42:00 <PeakerLambda>   25
17:42:04 <Gracenotes> PeakerLambda: has a title plugin?
17:42:07 <JoshTriplett> > let f (x,y) = ((x,x),(y,y)) in length $ range $ f (0,1)
17:42:09 <PeakerLambda>   4
17:42:10 <Gracenotes> -:
17:42:15 <JoshTriplett> > let f (x,y) = ((x,x),(y,y)) in length $ range $ f $ f $ f $ f (0,1)
17:42:16 <PeakerLambda>   65536
17:43:00 <Cale> saml: The reason that is slow is simply that it has to do a lot of work.
17:43:32 <Cale> > 10^(10*2)
17:43:33 <PeakerLambda>   100000000000000000000
17:43:54 <Gracenotes> > length [1..100000000000000000000]
17:43:59 <Cale> That's how many times you're computing (\x y -> x^2 + y^2)
17:44:09 <JoshTriplett> GeneralCategories?
17:44:09 <saml> Cale, someone posted on haskell-cafe with C code.. and C code runs fast. haskell version eats up memory and swap space
17:44:09 <PeakerLambda>   thread killed
17:44:24 <Cale> saml: Oh, it shouldn't eat memory.
17:44:30 <Cale> saml: How are you compiling it?
17:44:35 <saml> -O2
17:45:05 <Gracenotes> JoshTriplett: of Unicode characters, I suppose
17:45:13 <saml> let me try without -O2
17:45:13 <JoshTriplett> Ah.
17:45:30 <rwbarton> Cale: You can see the offending code and the core output here: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1023#a1023
17:45:35 <dons> unintended side effect of a recent blog post: googling "what is haskell good for?" turns up something useful!
17:45:48 <Gracenotes> UppercaseLetter, DecimalNumber, ClosePunctuation, NotAssigned, MathSymbol, etc.
17:46:03 <Gracenotes> a few dozen other categories
17:46:17 <JoshTriplett> @src GeneralCategory
17:46:17 <PeakerLambda> Source not found. My brain just exploded
17:46:19 <JoshTriplett> @src GeneralCategories
17:46:19 <PeakerLambda> Source not found.
17:46:23 <rwbarton> , src ''GeneralCategory
17:46:26 <lunabot>  data GeneralCategory = UppercaseLetter
17:46:26 <lunabot>                       | LowercaseLetter
17:46:26 <lunabot>                       | TitlecaseLetter
17:46:40 <Gracenotes> and about 30 lines more
17:46:44 <blackh> dons: I wrote a version of knucleotide and submitted it.
17:47:00 * Gracenotes couldn't imagine that being useful as an array index, but eh, who knows
17:47:37 <rwbarton> Gracenotes: It means someone took the 0.5 seconds to add "Ix, " to the middle of a deriving clause :)
17:47:43 <CakeProphet> I guess you dispatch certain categories to different values.
17:47:56 <ozy`> dons: say, is it possible to crosspost the same thread on multiple subreddits? I ask because I see a lot of duplicate links in both /r/haskell/ and /r/programming/
17:48:00 <Gracenotes> ...using an Array. right ;)
17:48:19 <Cale> oh!
17:48:22 <Cale> I think I see why.
17:48:24 <Gracenotes> I guess that's a case for efficiency-when-you-absolutely-need-it
17:48:33 <Cale> That's unfortunate...
17:48:38 <dons> blackh: awesome! parallel!
17:48:46 <Cale> It's hanging on to the list [-r..r]
17:49:00 <Cale> (well, in any of various incarnations)
17:49:02 <Cale> i
17:49:03 <blackh> dons: Here it is: http://alioth.debian.org/tracker/index.php?func=detail&aid=311378&group_id=30402&atid=411646
17:49:05 <Cale> oops :)
17:49:06 <dons> blackh: now we have to beat ocaml.
17:49:10 <PeakerLambda> Title: Alioth: The Computer Language Benchmarks Game: Detail: 311378 Haskell, k-nucleot ..., http://tinyurl.com/aeqrj4
17:49:11 <dons> blackh: it's already live
17:49:19 <blackh> dons: No way!
17:49:19 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=knucleotide&lang=ghc&id=1
17:49:25 <PeakerLambda> Title: k-nucleotide Haskell GHC program | x64 Ubuntu : Intel® Q6600® quad-core Comput ..., http://tinyurl.com/aupdz4
17:49:32 <JoshTriplett> > let ridiculouslyInefficientBitDecomposition x = range ((False,False,False,False,False),(True,True,True,True,True)) !! x in ridiculouslyInefficientBitDecomposition 17
17:49:34 <PeakerLambda>   (True,False,False,False,True)
17:49:53 <Gracenotes> success!
17:49:58 <dons> do you get better performance if you unbox the Hashtable data type ?
17:50:08 <blackh> dons: I thought I did better than that. On my machine it runs faster than "C++ GNU g++ #2"!
17:50:21 <dons> so check the flags, and check the data size.
17:50:29 <dons> sometimes they compile it wrong.
17:50:54 <Cale> waaait...
17:51:01 <Cale> Oh, it's a GHC bug!
17:51:07 <Gracenotes> :|
17:51:19 <CakeProphet> I wonder if GHC optimizes in cases where you use !! multiple times
17:51:21 <Cale> It's not supposed to hang on to that list.
17:51:22 <dons> much better spae use
17:51:44 <Cale> (I'm referring to saml's code)
17:51:46 <dons> still, we should beat ocaml imo.
17:51:53 <Cale> saml: Try it without -O2
17:51:54 <blackh> dons: I know what the problem is. They're using a different data set, right?  My hash table doesn't automatically grow.  I'll fix that.
17:52:00 <CakeProphet> like translating the use of list!!1, list!!2, list!!3  into a where clause.
17:52:07 <Cale> saml: You'll find that it doesn't waste memory.
17:52:08 <CakeProphet> er... let
17:52:19 <Cale> saml: of course, that also means that it's going to run slowly
17:52:20 <dons> blackh: good idea.
17:52:33 <dons> also check what ocaml #3 is doing, and any other gc/ par tweaks
17:52:35 <Gracenotes> CakeProphet: memoization? No, not really, although the items of the list are remembered once evaluated
17:52:40 <azathoth99> is free clone of world of warcraft done in haskell out yet?
17:52:58 <SamB> azathoth99: who claimed to be working on that ?
17:53:01 <dons> (btw guys, i'm on business travel this week, so not in #haskell much, as @seen has indicated :)
17:53:08 <Cale> azathoth99: No, I'm afraid it's your job to write it, and you're letting us all down :(
17:53:28 <SamB> azathoth99: you also have to pay for the servers
17:53:41 <CakeProphet> Gracenotes:  no, just using the already tailed list to compute the use of !! with greater indices... rather than unraveling the list multiple times.
17:54:23 <Gracenotes> you mean treating it as an array, basically?
17:54:30 <CakeProphet> seems like a simple optimization, but I guess most programmers are smart enough to not do that so it's not really worth the extra cycles to check for
17:54:48 <CakeProphet> Gracenotes:  no... I mean it makes it more efficient.
17:55:00 <dons> yeah, knuck is currently the worst performer relative to ocaml.
17:55:09 <dons> it is the only one > 2x slower.
17:55:18 <sbahra> Hrm.
17:55:19 <dons> all others are faster, or no worse than half as fast.
17:55:23 <sbahra> Why isn't lambdabot in ##FreeBSD?
17:55:26 <sbahra> NickServ?
17:55:38 <blackh> dons: Is it possible to obtain this big data set, or is that cheating?
17:55:39 <Gracenotes> RIP, lambdabot
17:55:43 <ivanm> sbahra: why should lambdabot be in ##FreeBSD?
17:55:56 <ivanm> after all, lambdabot is the _haskell_ IRC bot...
17:56:11 <sbahra> ivanm, because we would like him to be there? :)
17:56:17 <sbahra> ivanm, I think it's a good way to introduce people to Haskell.
17:56:18 <ddarius> ivanm: lambdabot is more places than you expect
17:56:25 <rwbarton> Not at the moment, though.
17:56:37 <rwbarton> preflex: seen lambdabot
17:56:37 <preflex>  lambdabot was last seen on #haskell 5 hours, 55 minutes and 49 seconds ago, saying: iterate id id
17:56:39 <sbahra> ivanm, consider ##FreeBSD has > 300 people a good amount of time.
17:56:40 <dons> blackh: you can obtain it.
17:56:45 <Gracenotes> heh
17:56:49 <Gracenotes> famous last words :/
17:56:50 <dons> blackh: use the fasta program
17:57:05 <CakeProphet> Gracenotes, like it would translate list!!1, list!!2, list!!3 into something the equivalent of (x:ls) = drop 1 list; (y:ls2) = ls; (z:ls3) = ls2
17:57:10 <sbahra> ivanm, so, why shouldn't he be there? Considering that he's a useful tool, at the least.
17:57:15 <Cale> dons: Perhaps you'd know if this space usage is a known bug? It seems that compiling this program with O2 creates a space leak...
17:57:22 <Cale> dons: main = print $ let f r = length . filter (\(x,y) -> x^2 + y^2 <= r^2) $ [(x,y) | x <- [-r..r], y <- [-r..r]] in f (10^10)
17:57:23 <blackh> dons: Thanks kindly.
17:57:37 <sbahra> Cale, any ideas on this issue? Maybe NickServ?
17:57:45 <CakeProphet> Gracenotes:  not a syntatic translation, but a semantic translation... so that the list is traversed multiple times when it's not necessary.
17:57:51 <CakeProphet> *isn't
17:57:59 <Cale> (actually, just -O does it as well)
17:58:16 <Cale> sbahra: hm?
17:58:18 <kmeyer> jhc produces portable C code, right?
17:58:32 <ivanm> sbahra: s/he/she/ ;-)
17:58:35 <Cale> oh, lambdabot didn't join?
17:58:41 <sbahra> Cale, apparently, lambdabot failed to rejoin ##FreeBSD after a netsplit.
17:58:44 <Gracenotes> CakeProphet: suppose you encounter a dataset such that you're generally requiring indices in a reverse direction -- for example, first you need index 1000, then 982, then 943, then 832, etc.
17:58:51 <Cale> ah
17:58:54 <sbahra> Cale, we don't allow unidentified nicks to join, so that could be it.
17:58:59 <Gracenotes> will all the work for optimization be worth it then? If I understand you, I'm not sure it would be...
17:59:00 <saml> Cale, without -O2.. it still eats memory
17:59:02 <saml> main = print (let f r = (length . filter (\(x,y) -> x^2 + y^2 <= r^2)) (range ((-r,-r), (r,r))) in f (10^9))
17:59:04 <sbahra> If nickserv had issues.
17:59:05 <Cale> I don't know. Lambdabot is in more channels than a normal user is able to join.
17:59:11 <saml> ghc --make Gauss.hs
17:59:17 <Cale> saml: Try my version
17:59:28 <Cale> saml: main = print $ let f r = length . filter (\(x,y) -> x^2 + y^2 <= r^2) $ [(x,y) | x <- [-r..r], y <- [-r..r]] in f (10^10)
17:59:30 <rwbarton> sbahra, Cale: You know lambdabot is also not here, right?
17:59:39 <sbahra> lambdabot, hi
17:59:44 <sbahra> @botsnack
17:59:44 <CakeProphet> Gracenotes:  it would traverse up to the lowest index, then use the tail of that list to compute the other subscriptions.
17:59:44 <lunabot>  :)
17:59:44 <PeakerLambda> :)
17:59:46 <Cale> rwbarton: it appears to be.
17:59:50 <ivanm> lambdabot, oh lambdabot, where art though lambdabot?
17:59:51 <ivanm> ;-)
17:59:51 <rwbarton> Cale: Look closer :)
17:59:53 <Cale> rwbarton: But perhaps is dead.
17:59:57 <rwbarton> Fair enough
18:00:09 <ivanm> s/though/thou/
18:00:44 * wli encounters datasets such that nearest neighbors having norm above some lower bound are required.
18:00:48 <CakeProphet> Gracenotes:  as long as the identifier for that list never changes and the indices are constants... I think it would be a reasonable optimization with no case where it would lead to bugs.
18:01:02 <Cale> okay, it's slowly joining channels now
18:01:23 <Gracenotes> > "hello, world"
18:01:24 <PeakerLambda>   "hello, world"
18:01:35 <lambdabot>   "hello, world"
18:01:38 <sbahra> :D
18:01:39 <ivanm> lol
18:01:45 <chessguy> @bot
18:01:45 <lunabot>  :)
18:01:45 <PeakerLambda> :)
18:01:46 <ivanm> @slap lambdabot
18:01:46 * PeakerLambda slaps lambdabot
18:01:53 <CakeProphet> > "now we have too many bots"
18:01:54 <PeakerLambda>   "now we have too many bots"
18:01:54 <lambdabot> :)
18:01:59 <chessguy> @where v
18:01:59 <PeakerLambda> I know nothing about v.
18:02:00 <CakeProphet> ...
18:02:01 <lambdabot>   "now we have too many bots"
18:02:02 <ivanm> lambdabot seems quite pingy...
18:02:03 <CakeProphet> rofl
18:02:07 <lambdabot> Plugin `slap' failed with: thread killed
18:02:10 <CakeProphet> gee, lambdabot sure is being slow right now.
18:02:13 <lambdabot> I know nothing about v.
18:02:13 <ivanm> s/pingy/laggy/
18:02:20 <ddarius> Presumably she's still joining channels
18:02:34 <CakeProphet> > map (/2) [1..]
18:02:35 <PeakerLambda>   [0.5,1.0,1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0,5.5,6.0,6.5,7.0,7.5,8.0,8.5,9.0,9....
18:02:43 <lambdabot>   [0.5,1.0,1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0,5.5,6.0,6.5,7.0,7.5,8.0,8.5,9.0,9....
18:02:48 <CakeProphet> psh, copypasta.
18:02:49 <saml> Cale, thanks. it doesn't eat memory!
18:02:51 <ivanm> CakeProphet: OK, you've made your point ;-)
18:03:06 <Gracenotes> lambdabot's answer is More Correct than PeakerLambda's
18:03:07 <chessguy> @v
18:03:08 <PeakerLambda> "\""
18:03:13 <lambdabot> Exception: <<loop>>
18:03:20 <sbahra> Oh, hi chessguy
18:03:26 <chessguy> sbahra, howdy
18:03:31 <Cale> saml: Let me see if I can write something which fails to trick GHC into wasting memory when optimised.
18:03:34 <sbahra> chessguy, when do you plan on releasing your PL/FoL library?
18:03:39 <chessguy> sbahra, i reproduced the core of my code here: http://codepad.org/UK8w6G3R
18:04:05 <sbahra> chessguy, I'll forward this thing once I'm done with it for review before releasing it publicly, if you're interested.
18:04:12 <chessguy> sbahra, i'd like to build a nicer little interface on top of that for making statements
18:04:14 <CakeProphet> @seen CakeProphet
18:04:14 <lambdabot> You are in #haskell. I last heard you speak just now.
18:04:14 <PeakerLambda> Plugin `seen' failed with: too few bytes. Failed reading at byte position 8
18:04:23 <CakeProphet> ...rofl.
18:04:25 <chessguy> sbahra, sure, i'll look at it. i'm pretty new to inference algorithms myself though
18:04:32 <sbahra> data Signed a => Term a = T | F | Lit a
18:04:35 * sbahra had issues with this
18:04:49 <ddarius> Don't do that.
18:04:53 <sbahra> Yes.
18:04:53 <chessguy> sbahra, that's just an idea i had. you can just make it a string instead
18:05:03 <chessguy> um
18:05:04 <sbahra> chessguy, well, I didn't make them the same type.
18:05:07 <chessguy> is someone going to say WHY
18:05:28 <chessguy> or just inform me that it's Evil and I Shouldn't Do That because You Said Spo
18:05:30 <chessguy> so
18:05:35 <sbahra> chessguy, instead, I map literals to some other type (can be arbitrary) and plan to break out an "operators" type class.
18:05:58 <gio123> ski
18:06:03 <CakeProphet> .... multi-param type classes are some deep voodo
18:06:08 <chessguy> you can represent the terms however you want
18:06:15 <Gracenotes> hmm... how *are* typeclasses dealt with in ADTs?
18:06:19 <chessguy> that's not really the point
18:06:26 <sbahra> chessguy, well, let's say I want to introduce something other than T or F (atleast from engineering point of view). More importantly, formally, T | F are truth values, "meta-language", I guess?
18:06:41 <Cale> saml: this works http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1024#a1024
18:06:49 <sbahra> chessguy, you must fix an interpretation for them. I didn't want True --> False to be something valid (as it isn't, AFAIK).
18:07:20 <sbahra> chessguy, this is one reason why I went with validity trees even.
18:07:23 <chessguy> sbahra, yeah, i should probably have just literal terms. like i said, i'm not done yet
18:07:27 <ddarius> chessguy: The constraint doesn't really do anything and tends to cause more problems than it solves (but then it doesn't really solve any problems)
18:07:36 <Gracenotes> oh, Happy Global Privacy Day, everybody
18:07:54 <sbahra> chessguy, cool.
18:07:55 <CakeProphet> ...oh
18:07:57 <chessguy> ddarius, wow, can you possible be any more vague? i almost caught a hint of not begging the question
18:08:00 <CakeProphet> I thought you said Piracy day.
18:08:31 <SamB> chessguy: but they DON'T do anything useful
18:08:35 <rwbarton> chessguy: I suggest you try it out and see if it solves any problems for you.
18:08:46 <sbahra> chessguy, also, isn't "=>" meta-language implication and not object implication?
18:08:56 <sbahra> chessguy, could be confusing if later you want to add support for different systems.
18:09:02 <Cale> saml: It would be much more efficient to look for the points (x,y) at which the transition occurs.
18:09:02 <chessguy> ack, overload
18:09:13 <chessguy> samB what is "they"?
18:09:14 <Cale> saml: as a first optimisation
18:09:33 <chessguy> rwbarton, do you mean the code i pasted? i did "try it out", or something like it, and it was fine
18:09:39 <saml> Cale, transition?
18:09:47 <saml> from negative plane to positive one?
18:09:50 <Cale> saml: from being inside the circle to being outside
18:09:51 <Cale> yes
18:09:53 <SamB> I assume you are talking about contexts on data types ?
18:10:02 <chessguy> sbahra, i'm not sure what you mean about the different implications
18:10:10 <CakeProphet> is there a good graphing library for Haskell?
18:10:30 <CakeProphet> I want to graph .wav data so I can visualize it better.
18:10:37 <Cale> saml: Still, computing 10^10 integer square roots is not going to be cheap.
18:10:43 <sbahra> chessguy, well, "->" or similar is implication dealing with objects of the language.
18:10:44 <saml> Cale, your 2nd version with enumerateBox doesn't blow up the memory with -O2
18:10:49 <Cale> saml: I know.
18:10:54 <chessguy> yeesh, it was just an idea i had. just define data Term a = Term Bool a if it makes you feel better
18:11:01 <sbahra> chessguy, but I see "=>" used for implication involving meta-language.
18:11:02 <Cale> (that's why I wrote it, though I shouldn't have had to)
18:11:09 <rwbarton> chessguy: Well, you can delete the "Signed a => " without affecting that program at all.
18:11:16 <Gracenotes> what kind of graph?
18:11:24 <Cale> saml: We can consider it a bug in GHC that the list comprehension uses so much space when optimised.
18:11:33 <chessguy> rwbarton, really? it doesn't constrain the a on the RHS?
18:11:35 <saml> Cale, http://www.nabble.com/C-like-Haskell-td21717584.html  i'm not sure how people there get like 3~4 seconds
18:11:39 <PeakerLambda> Title: Nabble - Haskell - Haskell-Cafe - C-like Haskell
18:11:50 <rwbarton> chessguy: I mean in the strictest sense, that I can delete it and that program will compile and run just as well. :)
18:11:54 <sbahra> chessguy, P_a => P_b (where a and b can be different systems or maybe just "follows from" which isn't necessarily implication)
18:12:03 <rwbarton> chessguy: So so far, it hasn't made any difference.
18:12:05 <Cale> saml: They're using a very different algorithm.
18:12:24 <chessguy> sbahra, oh, so you want a different operator for implication?
18:12:24 <Gracenotes> CakeProphet: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:graphics
18:12:27 <Cale> (first of all)
18:12:32 <PeakerLambda> Title: HackageDB: packages by category, http://tinyurl.com/yqov7f
18:12:34 <CakeProphet> Gracenotes:  byte value graph. the x axis is byte offset or something, and y is the byte value
18:12:38 <saml> oh darn somehow i thought mine is more efficient one
18:12:38 <sbahra> chessguy, I personally think that would be better.
18:12:43 <gwern> @remember RossMellgren Apparently 64-bit GHC is sufficiently advanced to be indistinguishable from magic.
18:12:43 <lambdabot> Nice!
18:12:43 <PeakerLambda> I will remember.
18:12:47 <sbahra> chessguy, since (=>) is not (-->).
18:12:51 <gwern> hm
18:12:52 <gwern> @flush
18:12:57 <rwbarton> Cale: do you have permissions to @part PeakerLambda?
18:13:05 <Cale> PeakerLambda: @part
18:13:06 <PeakerLambda> Plugin `system' failed with: Prelude.last: empty list
18:13:08 <gwern> guess I have admin on PeakerLambda too :)
18:13:09 <Cale> PeakerLambda: @part #haskell
18:13:18 <rwbarton> thanks :)
18:13:19 <chessguy> sbahra, ok
18:13:26 <chessguy> rwbarton, i really don't know what you mean
18:13:28 <ptolomy2> I was looking at the code for circ2 from that thread in haskell-cafe, and I can't help but notice that when I use Int64, Num instance functions are C calls. Seeing as I have a 64-bit machine, this seems non-optimal. Is this the consequence of macports having a non-optimal version?
18:13:37 <gwern> Cale: so, how does the update of darcs repo state/? :)
18:13:41 <CakeProphet> Gracenotes:  hmmm... cabal: cannot configure Chart-0.9. It requires cairo >=0.9.11 and gtk >=0.9.11
18:13:42 <gwern> @quote magic
18:13:42 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
18:13:47 <sbahra> chessguy, could I dump what you have so far in ##logic? Maybe some people would have a use for it
18:13:50 <Cale> gwern: wha?
18:13:52 <gwern> @quote magic
18:13:52 <lambdabot> dons says: yes, i have magic powers.
18:13:57 <chessguy> rwbarton, it keeps me from having, e.g., a Term ("foo", "bar") right?
18:13:58 <Gracenotes> CakeProphet: then install those :)
18:14:04 <JoshTriplett> @quote sufficiently
18:14:04 <lambdabot> RossMellgren says: Apparently 64-bit GHC is sufficiently advanced to be indistinguishable from magic.
18:14:11 <Gracenotes> if you're on Ubuntu, apt-cache search ghc cairo
18:14:15 <Gracenotes> and the same for gtk
18:14:16 <gwern> Cale: take the cyrrent lambdabot's state/ files and push'em to the darcs repo
18:14:21 <chessguy> sbahra, i'd rather you didn't, since it's from memory, and not tested
18:14:32 <chessguy> and seems to send #haskellers into convulsions :)
18:14:40 <Cale> @seen
18:14:41 <sbahra> chessguy, ok, no problems. :-P
18:14:43 <Cale> @seen Cale
18:14:43 <lambdabot> You are in #ghc, #haskell-overflow and #haskell. I last heard you speak just now.
18:14:47 <CakeProphet> Gracenotes:  bah... I wish cabal didn't have dependencies it doesn't support because apt-get supports them.
18:14:47 <Cale> okay
18:15:11 <gwern> CakeProphet: this is more a reflection of gtk2hs not being hackeable
18:15:13 <Gracenotes> CakeProphet: you could install them all :)
18:15:16 <chessguy> sbahra, i'll try to release it properly this weekend, and then maybe build FOL on top of it
18:15:16 <gwern> *hackageable
18:16:01 <Gracenotes> plus, GTK does require that GTK is, you know, installed :) as gwern said, I don't think Cabal can ensure that prettily
18:16:04 <CakeProphet> Gracenotes:  well, based on the dependency tree for cairo, I might be doing just that right now.
18:16:06 <ddarius> chessguy: Why don't you add arbitrary constraints to all of your functions?
18:16:10 <gwern> CakeProphet: if gtk2hs was on hackage, then it'd be in the same situation as all the other bindings vis-a-vis cabal & apt-get
18:16:19 <Gracenotes> gwern: lovely weather we're having today, eh
18:16:32 <chessguy> rwbarton, i'd really like to understand what you're saying, because i'm sure it's important, i just haven't got it through my thick skull
18:16:46 <gwern> Gracenotes: no kidding. it didn't matter I screwed up my schedule for today because I certainly wasn't making anything scheduled at 8 am...
18:16:58 <dcoutts> CakeProphet: all the information is there to generate distro packages, including generating deps on other native packages. The .cabal files declare what C libs etc they need.
18:16:58 <chessguy> ddarius, why whould i?
18:17:16 <sbahra> chessguy, cool
18:17:19 <rwbarton> chessguy: Well, the main reason you might want to write a class context on the Term data type is if it meant you then didn't have to write it on your functions that used it.
18:17:24 <ddarius> chessguy: That's exactly what you are doing when you use type class constraints on data types.
18:17:29 <sbahra> chessguy, I'll let you know about mine, a review of it would be much appreciated.
18:17:35 <rwbarton> chessguy: At least, that is what I expected the first time I tried putting a class context on a data type.
18:17:45 <rwbarton> chessguy: But it doesn't do that.
18:18:17 <chessguy> rwbarton, ohhhhh, i see. i do recall reading this in RWH now
18:18:18 <chessguy> gotcha
18:18:44 <rwbarton> chessguy: But you are right that it stops you from writing Lit ("foo", "bar").  I don't know whether that's useful.
18:19:18 <CakeProphet> rwbarton:  hmmm... would using GADTs make class constraints cover other functions as well?
18:19:33 <chessguy> rwbarton, my idea was just that you could only make terms of things that had signs. it doesn't matter how you represent them, as long as you can tell what sign they are, and reverse that sign
18:19:34 <CakeProphet> like
18:19:38 <ddarius> rwbarton: Not usually.  That would make errors that would happen any way happen a bit earlier, but it often keeps you from doing nice things like putting a String there when pretty printing, for example.
18:19:53 <chessguy> rwbarton, and then as long as you construct the term right, the functions don't require any constraints
18:19:54 <CakeProphet> rwbarton, data X where lol :: (C a) a -> X
18:20:00 <CakeProphet> + =>
18:20:00 <ddarius> chessguy: When you use functions that need that, the constraint will be added anyway.
18:20:17 <chessguy> ddarius, it still saves typing :)
18:20:18 <ddarius> chessguy: Ah, then as rwbarton said, that's not how it works.
18:20:29 <ddarius> chessguy: No it doesn't.
18:20:41 <chessguy> well, if it worked as i thought it would
18:20:52 <chessguy> anyway
18:21:10 <chessguy> the class constraint was just an idea i had while i was trying to reproduce my code from memory. i'll just throw it out the window
18:21:28 <CakeProphet> Gracenotes:  oh great... I downloaded cairo and gtk for Haskell and I still don't have the right versions to install Chart.
18:22:04 <sbahra> chessguy, http://pastie.org/373846
18:22:10 <wli> There are cairo and gtk hs packages?
18:22:16 <rwbarton> CakeProphet: Well, the existential version is different.  But what about  data X a where lol :: C a => a -> X a
18:22:30 <Gracenotes> CakeProphet: :/
18:22:37 <sbahra> chessguy, is what I'm using, omitting type classes which I need to design properly. :)
18:22:49 <CakeProphet> rwbarton:  would the class constraint be necessary in functions that deal with X?
18:22:54 <rwbarton> CakeProphet: I've heard rumors that that behaves the way I originally expected, but I've never tried it
18:22:55 <Gracenotes> CakeProphet: you could always manual install and see what's going wrong
18:22:58 <ozy`> wli: yeah man. there's even an objC (Cocoa) package... if you can get the fucker to compile
18:23:07 <CakeProphet> Gracenotes:  ...
18:23:07 * ozy` isn't bitter at all, I swear....
18:23:10 <chessguy> sbahra, yeah, that becomes a pain in the neck when you need to convert to CNF though
18:23:19 <sbahra> Yes.
18:23:27 <CakeProphet> Gracenotes:  or you know... I could just beat my face in with a club.
18:23:27 <Gracenotes> CakeProphet: plus, I don't see why it doesn't work. what's the versioning error message...?
18:23:31 <CakeProphet> same thing, really.
18:23:31 <chessguy> which most SAT solvers need
18:23:42 <sbahra> I'll find some clever way.
18:23:47 <CakeProphet> Gracenotes:  after apt-getting the relevant cairo and gtk packages it gives me the exact same error.
18:24:09 <wli> ozy`: I tend to give up early.
18:24:31 <ozy`> wli: me too. I might do better now that I know haskell better though
18:25:01 <islon_s> what's the function that take a Monad m and execute a function f inside the monad??
18:25:03 <sbahra> chessguy, I will be changing variable though
18:25:05 * wli mostly can't afford the time.
18:25:14 <sbahra> chessguy, so you can use ordinals for identifiers.
18:25:15 <Gracenotes> CakeProphet: lemme try it myself...
18:25:25 <sbahra> chessguy, well, numbers, that is.
18:26:08 <rwbarton> preflex: seen dcoutts
18:26:08 <preflex>  dcoutts was last seen on #haskell 9 minutes and 10 seconds ago, saying: CakeProphet: all the information is there to generate distro packages, including generating deps on other native packages. The .cabal files declare what C libs etc they need.
18:26:17 <dcoutts> rwbarton: mm?
18:26:22 <Gracenotes> CakeProphet: WORKSFORME, sorry
18:26:39 <rwbarton> dcoutts: as far as I can tell the Int64 implementation on 32-bit architectures is doing FFI calls
18:26:44 <Gracenotes> configuration said that I have cairo-0.9.12.1 and gtk-0.9.12.1, but obtained via apt-get
18:26:47 <dcoutts> rwbarton: yes
18:26:53 <Gracenotes> CakeProphet: have you updated your sources list lately...?
18:26:56 <dcoutts> rwbarton: hence really slow
18:27:02 <rwbarton> dcoutts: yeah
18:27:06 <islon_s> anyone?
18:27:10 <dcoutts> rwbarton: compared to shuffling values between registers in a loop
18:27:19 <sbahra> chessguy, I'm not happy at all with what I have for FoL though.
18:27:25 <chessguy> @type liftM
18:27:26 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:27:26 <sbahra> *FOL> forall P $ exists Q <|> p --> q
18:27:26 <sbahra> forall p. exists q. (p --> q)
18:27:36 <chessguy> islon_s, is that what you mean?
18:27:42 <islon_s> chessguy, thanks!
18:27:49 <Gracenotes> CakeProphet: you got libghc6-cairo-dev and libghc6-gtk-dev, right?
18:27:56 <tromp> http://www.photoshoptalent.com/images/contests/stone fingers/fullsize/stone fingers_478fc739a1585.jpg
18:28:08 <tromp> that reminds me of some datastructure...
18:28:09 <rwbarton> dcoutts: I'd think it could be made faster just by defining data Int64 = Int64 Int32# Int32# and writing the Num instance in haskell
18:28:33 <chessguy> sbahra, try something like this: http://www.cs.yale.edu/homes/cc392/node4.html
18:28:35 <SamB> rwbarton: what would you do for * ?
18:28:36 <CakeProphet> Gracenotes:  yeah
18:28:48 <dcoutts> rwbarton: I think those operations require lower level support
18:28:52 <chessguy> sbahra, the code you pasted reminds me of that
18:28:58 <rwbarton> hmm, I guess division at least will be hard
18:29:01 <dcoutts> rwbarton: because it relies on overflow bits etc at the cpu level
18:29:06 <SamB> rwbarton: you realize that native multiply can usually do 32*32 -> 64 ?
18:29:30 <rwbarton> SamB: yes
18:29:52 <Gracenotes> CakeProphet: okay... er, in the Synaptic Packager Manager, what version does it say those two packages are?
18:29:58 <rwbarton> SamB: I guess "in haskell" was an exaggeration, I meant more like "using a compiler primitive"
18:30:43 <Gracenotes> CakeProphet: just saying, it works for me... I dunno what's wrong :/
18:30:52 <mgs`> hey guys, where is a good place to start if i want to write a little plaintext to code generator?
18:31:24 <mmorrow> rwbarton: wow, that Int64 code is surprising
18:31:24 <lambdabot> mmorrow: You have 2 new messages. '/msg lambdabot @messages' to read them.
18:31:35 <rwbarton> Oh wait, I was confused about something...
18:31:37 <CakeProphet> Gracenotes:  libghc6-cairo-dev is 0.9.13 and libghc6-gtk-dev is the same.
18:31:54 <mgs`> (haha, didn't mean to hey guys (question). i was idling and actually did return so the Hey! is genuine. ;)..)
18:32:23 * gwern wonders what a plaintext to code generator is
18:32:26 <Gracenotes> heh, that's newer than mine. Mind pastebining the results of cabal install Chart, then?
18:32:43 <rwbarton> OK, I must have done one of my experiments wrong.  Ignore me, then :)
18:32:43 <mgs`> gwern: interpreter?
18:32:54 <mmorrow> gwern: /usr/bin/dowhatisay # ?
18:33:02 <gwern> mmorrow: ROT13?
18:33:09 <mmorrow> ahh
18:33:30 * mmorrow was thinking machine code..
18:33:44 * gwern was joking with that suggestion
18:33:45 <mgs`> gwern: basically the samething as markdown.pl (if you are familiar)
18:34:25 <mmorrow> mgs`: check out the pandoc homepage
18:34:27 <inv> hi all
18:34:31 <dcoutts> rwbarton: my guess is that it'd have to be done at the c-- level
18:34:53 <mmorrow> pandoc has a parser for markdown that they benchmark against markdown.pl and it's noticeably faster
18:35:08 <gwern> mgs`: so you want markdown to html?
18:35:24 <mmorrow> rwbarton: http://darcs.haskell.org/ghc/rts/PrimOps.cmm  !!
18:35:34 <mgs`> i want to write my own markdown that will create xml actually
18:35:38 <inv> what does 1 return code mean? stack overflow ?
18:35:43 <mmorrow> rwbarton: someone wrote a blog post about how to add a new primop to ghc too
18:35:57 <mmorrow> rwbarton: (i don't remember the link though)
18:35:57 <rwbarton> dcoutts: I think now that perhaps the Int64 operations are not as fast as they could be, but telling the strictness optimizer they are strict would be a much bigger factor (at least in this case)
18:36:14 <dcoutts> rwbarton: yes
18:37:40 <mmorrow> mgs`: yeah, the pandoc code would probably give you a good example of how to do exactly that
18:37:41 <gwern> mgs`: so... xhtml you mean?
18:38:01 <mgs`> mmorrow: yeah, i'm looking at it now, looks perfect!
18:38:06 <mgs`> mmorrow: tyvm
18:38:10 <mmorrow> np
18:38:15 <mgs`> gwern: xml actually
18:39:05 * gwern can't help but feel there's a gap here - 'I want to print out a String!' 'But what encoding? UTF8?' 'A String, I said!' - but is unsure who is who
18:39:11 <rwbarton> :k Int64#
18:39:13 <lambdabot> Not in scope: type constructor or class `Int64#'
18:39:41 <gwern> 'XHTML can be thought of as the intersection of HTML and XML in many respects, since it is a reformulation of HTML in XML.' <-- WP seems to think XHTML is a kind of XML
18:40:04 <mgs`> it is
18:40:09 <mgs`> xhtml is a subset
18:40:28 <mgs`> if you were writing a markdown tool for yourself though
18:40:32 <ozy`> gwern: XHTML is a redefinition of HTML in terms of XML.
18:41:04 <ozy`> hence the name....
18:41:05 <mgs`> you could specify the little shortcuts *you* want and then the parse will know what string you mean when you want UTF-8
18:41:06 <gwern> that's - that's what my quote said -_- (in the exact same grammatical structure as well...)
18:41:12 <mgs`> ;)
18:41:26 <ozy`> ah, I only read your commentary
18:41:55 <ozy`> damn lazy evaluation getting to my head...
18:44:39 <gwern> mgs`: I think I would just write a pandoc plugin...
18:45:09 <mgs`> i hate teh bloat
18:45:42 <gwern> in the greater view, it's less bloat to write a small plugin leveraging pandoc than it would be to reimplement pandoc
18:46:05 <mgs`> to the contrary
18:46:10 <mgs`> source is open to be learned from
18:46:25 <mgs`> AND leveraged in new ways
18:46:44 * gwern sees no logical connection there
18:47:16 <mgs`> writing a small tool based on pandoc is just fine in my opinion. it's fine that you prefer plugins.
18:48:11 <mgs`> just to point out though: your tool depends on another, not sure how that's less bloat
18:48:14 <gwern> we're all fine?
18:48:18 <mgs`> ;)
18:48:30 <gwern> mgs`: oh noes, I write stuff in haskell which depends on tons of tools
18:48:47 <SamB> mgs`: well, it's better to leave the pandoc code in pandoc
18:48:47 <gwern> why was I such a fool? I should be using an exokernel written in asm
18:49:00 <SamB> oh noes, cabal-install has not been written!
18:49:18 <gwern> SamB: MY MEMORIES ARE LIES
18:49:18 <mgs`> ..
18:50:04 <gwern> but srsly pandoc plugins are a cool new tool
18:50:27 <SamB> rape and paste means you have to maintain the rape-n-pasted code
18:50:27 <gwern> they'd be very useful for gitit except gitit is using pandoc as a library and so turns out we can already do that
18:50:56 <gwern> for example, I plan to implement interwiki links and signatures this week using that plugin-style functionality
18:50:58 <mgs`> SamB: i wasn't suggesting surgery on pandoc, scroll through the looks and you'll realize that i am just responding to gwern (who seems to be maniacal)
18:51:31 <SamB> <mgs`> source is open to be learned from
18:51:31 <SamB> <mgs`> AND leveraged in new ways
18:51:42 <ray> gwern has latent maniacal tendencies
18:51:47 <gwern>  maniacal?? I am merely unappreciated by lesser minds! those small-minded fools will regret banning my research into the resurrection of haskell packages!
18:51:56 <mgs`> here's how it all started : 21:30 < mgs`> hey guys, where is a good place to start if i want to write a little plaintext to code generator?
18:52:11 <ray> it's the severed nose of dr. gwern, returned on the anniversary of the night we betrayed him!
18:52:18 <gwern> (to life! to life! I'll bring them - to life! MWa Ha Ha Ha Ha!)
18:52:26 <SamB> mgs`: you need to be a bit more specific than "plaintext"
18:52:38 <SamB> or than "code"
18:53:05 <SamB> oh, you want to make a markdown thing
18:53:18 <mgs`> here's where i got into trouble : 21:33 < mgs`> gwern: basically the samething as markdown.pl (if you are familiar)
18:53:29 <mgs`> SamB: yeah ;)
18:53:50 <mgs`> SamB: i'm just trying to write a tiny parser for my own mini markdown language
18:54:00 <mgs`> parser generator
18:54:30 <gwern> mgs`: to be fair, I would've reacted much the same way if you had said something like 'you know what would be cool? a minimalist window manager that did all the arranging for you'
18:54:47 <SamB> gwern: you would have told him to use pandoc?!??!?
18:54:47 <chessguy> haha
18:54:58 <gwern> SamB: YES
18:55:11 <gwern> SamB understands me! why can't the rest of you :(
18:55:12 <SamB> I would've thought Xmonad would be more appropriate ...
18:55:33 <mgs`> gwern: that's because you don't understand what i'm talking about doing.
18:55:53 <gwern> that's obvious to even a lesser mind like yourself
18:56:28 <Gracenotes> mgs`: just what would you parse it into? An AST?
18:56:59 <mgs`> Gracenotes: the xml gets processed in java
18:57:13 <Gracenotes> wait what
18:57:51 <Gracenotes> why not do XML processing in Haskell...?
18:57:56 <mgs`> the tool is like markdown- takes plain text input spits out modified output.
18:57:59 <gwern> Gracenotes: no, that way lies madness!
18:58:06 <mgs`> gwern: shhh
18:58:14 <Gracenotes> and do you really really want to use XML to communicate between two languages?
18:58:25 <Gracenotes> (hint: rhetorical question)
18:58:29 <Gracenotes> :)
18:58:33 <mgs`> Gracenotes: maybe not, this is the conversation i needed!
18:58:34 <mgs`> haha
18:58:34 <mgs`> :)
18:58:55 * gwern is confused. it's a rhetorical question, but on the other hand, xml does seem like a good way of communicating data between langs
18:58:55 <mgs`> well, the app is in java
18:59:04 <Gracenotes> anyway, if you're using Java, there is something called JParsec
18:59:07 <mgs`> xml is not a good way for anything :(
18:59:27 <Gracenotes> gwern: yes, but do you want to?
18:59:39 <ivanm> mgs`: did you see the thing recently about coding for .NET in xml? :s
18:59:45 <ivanm> that's even scarier!
18:59:59 <Gracenotes> mgs`: anyway, there's http://jparsec.codehaus.org/ for Java parsing in a Haskell-esque manner
19:00:03 <gwern> ivanm: well, if everything you're dealing with is already xml...
19:00:31 <Gracenotes> clearly, YAML is the superior means of communicating between two languages
19:00:48 <thotypous> JSON :P
19:00:51 <chessguy> ivanm, link?
19:01:02 <Gracenotes> WDDX!
19:01:19 <mgs`> whew
19:01:20 <mgs`> http://c2.com/cgi/wiki?XmlSucks
19:01:26 <ivanm> chessguy: I'll try to find it
19:01:30 <ivanm> IIRC, it was on reddit...
19:01:34 <mgs`> ivanm: i have not, cehck out that link i posted
19:01:44 <mgs`> Gracenotes: thank you, i'm heading over to it now
19:01:58 <Gracenotes> how, that's an old page.
19:02:00 <Gracenotes> *wow
19:02:01 <ray> clearly, CSV is the best
19:02:02 <ivanm> mgs`: lol
19:02:08 <ivanm> we should use lisp! ;-)
19:02:15 <Gracenotes> I mean, if people are still comparing sexprs and XML...
19:02:27 <ray> it is an old page, i assure you
19:02:30 <Gracenotes> I'd hate to claim that one won out over the other, but... er...
19:02:32 <saml> xml is cool.
19:02:33 <ray> at least most of it is
19:02:37 <ivanm> chessguy: http://www.xsharp.org/samples/
19:02:49 <Gracenotes> ray: yeah, the first wiki :)
19:03:05 <Gracenotes> it has a special place in Wikipedia history. Way way way back.
19:03:07 <ivanm> hmmmm.... it uses the JVM, but calls itself X#...
19:03:14 * ivanm thinks someone has their runtime environments mixed up
19:03:35 <ray> it uses JVM.NET
19:03:46 <ray> the implementation of one on the other, but we're not sure which
19:04:01 <gwern> maybe sometimes one is top and the other bottom
19:04:02 <mgs`> i'm actually thinking of releasing the source to my markdown language, it's called xxx or simply "triple-x".
19:04:04 <gwern> for variety
19:04:17 <Gracenotes> ray: if that were the case, Mono might not be needed
19:04:18 <gwern> mgs`: please don't, there are already enough markdown languages
19:04:31 <ivanm> chessguy: apparently, the idea was to create a graphical programming language :s
19:04:32 <mgs`> gwern: not like triple-x
19:04:37 <dobblego> that X# is not to be confused with Erik Meijer's X#
19:04:47 <ivanm> http://www.reddit.com/r/programming/comments/7rc5v/x_xml_oriented_programming_language_i_cant/c076ujf
19:05:09 <ivanm> dobblego: why, what's his X#
19:05:12 <ivanm> ?
19:05:17 <ray> you could make a graphicsl C if you wanted
19:05:19 <ray> graphical
19:05:33 <gwern> this is boring. I'm going to go read up on the famous librarian Llewellyn C. Puppybreath III
19:05:47 <dobblego> ivanm, http://research.microsoft.com/en-us/um/cambridge/projects/comega/
19:06:32 <mgs`> gwern: past your bedtime?
19:06:34 <lunabot>  luna: lexical error in string/character literal at end of input
19:06:57 <mgs`> (apparently past mine.)  :)
19:06:59 <ivanm> wtf? why is lunabot suddenly complaining?
19:07:08 <gwern> mgs`: you've never heard of the founder of sig/con? that distinguished personage?
19:07:22 <gwern> mgs`: I assure you, were you a information science specialist, you would know his name
19:07:49 <gwern> 'The following long list of important research activities, especially when considered in the light of the rich and full professional life evidenced above, goes some way in explaining why Dr. Puppybreath has been so infrequently able to attend SIG/CON sessions (although according to the taped record, he did attend New Member's Breakfast in 1989). These research activities were without exception conveyed by David Batty, and have been ...
19:07:55 <gwern> ... edited only minimally for inclusion here...'
19:08:12 <Gracenotes> gwern: past your bedtime?
19:08:22 <Gracenotes> ...okay, that didn't set off lunabot
19:08:24 <gwern> (quoted from http://web.simmons.edu/~schwartz/con/sig-con-lcp.html )
19:09:02 <Gracenotes> wait
19:09:03 <gwern> Gracenotes: man, I'm always past my bedtime! I'm a wide-eyed 11 year old who never went to bed! this whole world is up way too late on some bad trip!
19:09:28 <mgs`> right
19:09:52 <rwbarton> @yow
19:09:52 <lambdabot> Yow!  Are we wet yet?
19:10:02 <pumpkin> what's the most efficient way to go from a lazy bytestring to an DiffUArray?
19:10:06 <rwbarton> ? 3
19:10:34 <mgs`> does lambdabot learn?
19:10:43 <ivanm> mgs`: only by hacking on her code ;-)
19:10:50 <gwern> mgs`: yes. the unfortunate corollary is that she can also forget
19:10:55 <gwern> truly, there is no free lunch!
19:11:07 <mgs`> ivanm: ;)
19:11:25 <ivanm> gwern: yeah, so-called "free lunches" often require you to bother staying awake enough to listen to a boring speech
19:11:26 <ivanm> ;-)
19:12:15 <gwern> ivanm: but no free lunches are also full employment opportunities
19:13:22 <gwern> (in case anyone hasn't caught on, Llewlyyn C. Puppybreath III is a standing information science in-joke)
19:15:45 <pumpkin> how about the easiest way to go from a lazy bytestring to a list of Word16 ?
19:15:58 <pumpkin> Data.Binary.Get looks fine, but how do I "keep going" until I'm done
19:16:20 <gwern> Gracenotes: http://thelibraryclub.wordpress.com/sbus-banned-books/ <-- interesting link. one wonders about the kind of person who would take the time to challenge The Analects. a joke?
19:17:15 <pumpkin> :t unfoldM
19:17:16 <lambdabot> Not in scope: `unfoldM'
19:17:24 <pumpkin> @hoogle unfold
19:17:25 <lambdabot> Data.Tree unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
19:17:25 <lambdabot> Data.Tree unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
19:17:25 <lambdabot> Data.Tree unfoldForestM_BF :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
19:17:28 <pumpkin> ack
19:18:21 <bigorilla> @hoogle (a -> Bool) -> [a] -> [[a]]
19:18:21 <lambdabot> Distribution.Simple.Utils breaks :: (a -> Bool) -> [a] -> [[a]]
19:18:21 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
19:18:21 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
19:19:23 <pumpkin> anyone have any idea?
19:19:25 <Gracenotes> gwern: oh, the title of the page alarmed me momentarily
19:19:37 <pumpkin> I'd use mapM but I don't have a list to map over
19:20:39 <Gracenotes> then do sequence on the unfoldr-ed list...?
19:20:53 <gwern> Gracenotes: me too, but university libraries are pretty ornery institutions so I assumed it would be blank
19:20:55 <pumpkin> hmm, that makes sense
19:21:44 <Gracenotes> sequence is lazy, after all. iirc
19:22:01 <pumpkin> this still feels like a bad way to be doing it
19:22:04 <pumpkin> but ah well
19:22:10 <pumpkin> I mean in general
19:22:13 <pumpkin> not the sequence bit
19:22:38 <Gracenotes> just what're'ya'tryin'to'do?
19:23:14 <gwern> apostrophe fail
19:23:23 <Gracenotes> ya'don't'say
19:23:51 <gwern> you shouldn't've'd added 2 of those
19:23:54 <gwern> *add
19:24:06 <gwern> *to add, actually, hm.
19:24:43 <pumpkin> Gracenotes: I have a list of lazy bytestrings that should be interpreted as signed little-endian 16-bit ints, and need to cram them all into a DiffUArray
19:26:05 <Gracenotes> hm
19:26:16 <pumpkin> :t Word16
19:26:17 <lambdabot> Not in scope: data constructor `Word16'
19:26:32 <gwern> pumpkin: I would ask why you're storing numbers in bytestrings, but I'd probably regret knowing the whole story
19:26:49 <pumpkin> gwern: I'm reading them in from a file?
19:27:16 <Cale> pumpkin: maybe the stuff in Data.Binary would be useful
19:27:25 <pumpkin> yeah, I'm trying to use it
19:27:39 <pumpkin> but calling a string of repeated getWord16le seems silly
19:27:52 <pumpkin> I guess I can't do much better considering the bytestring is lazy
19:28:13 <pumpkin> also, isn't there a getInt16le to deal with unsigned to signed conversion for me?
19:30:14 <saml> in cabal-install, how can i get list of installed packages?
19:30:55 <gwern> I don't believe cabal-install tracks whether it installed a package
19:31:05 <gwern> just whether it is installed period
19:31:06 <pumpkin> ghc-pkg list :P
19:31:12 <saml> oh shit i just did cabal upgrade  and it is doing a lot of things
19:31:15 <pumpkin> (i.e., not cabal install)
19:31:23 <saml> i only installed llvm through cabal-install...
19:31:48 <saml> can I ctrl+c  ?
19:32:46 <saml> oh it's finished. i thought it'd take an hour
19:33:07 <gwern> it's just a binding isn't it
19:33:38 <saml> yes. but since i only installed llvm biding through cabal-install, i thought i'd only upgrade that package
19:35:01 <Cale> saml: To do that, you normally just update, and then tell it to install the package again... if it complains, you can give an explicit version to install, like foo-1.2.3
19:35:22 <saml> ah i see
19:36:09 <lpjhjdh> @pl min
19:36:09 <lambdabot> min
19:37:01 <Cale> If there's no lambda, it can't get any more points free...
19:37:06 <lpjhjdh> @pl \x y -> if x < y then x else y
19:37:06 <lambdabot> join . (flip =<< (if' .) . (<))
19:37:22 <lpjhjdh> I see, thanks :)
19:38:33 <Gracenotes> lambdabot and the ((->) r) Monad, sitting in a tree, K-I-S-S-I-N-G
19:39:11 <pumpkin> bah
19:39:44 <Olathe> @type min
19:39:45 <lambdabot> forall a. (Ord a) => a -> a -> a
19:41:13 <hackage> Uploaded to hackage: MonadLab 0.0.2
19:41:31 <redditbot> Grand Challenges in Programming Languages: POPL Edition
19:41:31 <redditbot> Declarative Aspects of Multicore Programming: Inviited talks up
19:44:15 <pumpkin> this IOArray stuff is really confusing
19:44:20 <pumpkin> everything's all over the place
19:44:25 <pumpkin> and the MArray
19:44:27 <pumpkin> blah
19:45:21 * wli must confess to being thoroughly annoyed by the weirdness about getting things in and out from array result type constructors to general monads.
19:47:13 <pumpkin> there's just so much abstraction and indirection going on with all the different array types and wrappers
19:47:27 <pumpkin> I have to jump over three different doc pages to figure out what's going on
19:48:20 <SamB> pumpkin: too bad the source is probably not there :-(
19:50:25 <pumpkin> it's like, DiffUArray Int a, so what's that a? I look up DiffUArray, and get that it's actually IOToDiffArray IOUArray ! so I look up IOToDiffArray and get IArray (IOToDiffArray IOUArray) Int16
19:50:57 <gwern> see, this is why I stay the hell away from arrays
19:51:06 <pumpkin> I do too
19:51:12 <pumpkin> but the library I need uses them
19:51:20 <gwern> I am willing to pay the (performance) price for my ignorance!
19:51:32 <pumpkin> I use UArrs when I need arrays :P
19:51:39 <pumpkin> still doesn't help me here
19:53:22 <Gracenotes> just what are you woring on?
19:53:26 <Gracenotes> working, too
19:53:29 <Gracenotes> >_<
19:53:50 <pumpkin> trying to load a data format and spit parts of it out to an audio file
19:53:52 <pumpkin> as a .wav
19:54:15 <wli> At times, I don't even need performance: just something that behaves like an array in various senses.
19:55:11 <wli> I wouldn't care if it were Data.Map under the covers so long as it looked like an array.
19:55:14 <pumpkin> now somehow an Int64 constraint crept in
19:56:28 <dublpaws> a typeclass example by noob for noob ;) http://theegghatched.blogspot.com/2009/01/class-shape-where-perimeter-float-area.html
19:57:15 <pumpkin> @hoogle (<.>)
19:57:15 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
19:57:15 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
19:57:57 <ddarius> "Essentially, you've remade PHP, but somehow made it *even worse.*"
19:58:40 <ozy`> ddarius: I think I need to see that....
20:01:36 <Gracenotes> is there a point when the number of items in an ADT affects performance quite a bit?
20:02:01 <Gracenotes> e.g., dozens?
20:02:23 <Gracenotes> to the point where using them in a manner similar to C/C++ constants becomes a bad idea
20:02:35 <Gracenotes> (each constructor is *)
20:03:11 <Gracenotes> er, actually, constructors don't have kind. But no args, anyway.
20:03:14 <ddarius> Gracenotes: Not really.  In GHC, a small number of constructors will be encoded with data tagging, but that won't cause a huge difference in most cases.
20:03:29 <chessguy> @kind Just
20:03:30 <lambdabot> Not in scope: type constructor or class `Just'
20:03:38 <Gracenotes> ah, okay
20:03:50 <Gracenotes> I'll see if it becomes a bottleneck :)
20:04:02 <chessguy> Gracenotes, whatcha working on?
20:04:38 <Gracenotes> chessguy: a port from C++ to Haskell of http://caravelgames.com/distfiles/DROD32Source.rar
20:04:50 <Gracenotes> http://en.wikipedia.org/wiki/DROD#Gameplay
20:04:58 <Gracenotes> heaven knows if I'll ever finish, but it's going well so far :)
20:05:23 <Cale> Oh, DROD is cool :)
20:05:53 <Gracenotes> it definitely won't be as involved -- I'll be lucky if I have as much functionality as the first version, Webfoot (without even a level editor)
20:06:56 <Gracenotes> DROD has fun gameplay :) Everything is very intricate, though. Orderings matter a lot.
20:07:37 <Cale> yeah...
20:07:40 <ozy`> Gracenotes: it's sure easier than porting to java or perl, isn't it? ;)
20:07:56 <chessguy> i would think porting to haskell from c++ would suck
20:08:10 <Gracenotes> I don't know... if I were porting to Java, at least I could preserve the imperative foibles
20:08:26 <SamB> foibles are good to preserve now ?
20:08:40 <Gracenotes> they're not. They're just somewhat hard to get rid of :)
20:09:20 <Gracenotes> at the moment I'm trying to find the general structure of the program and pick the important parts for basic initial functionality
20:09:40 <Gracenotes> making sure, however, that expanding to the more complicated features won't require a huge restructuring
20:10:24 <Debugger> You can't correctly port for imperative to functional :/
20:10:25 * chessguy downloads it and check it out
20:10:25 <Debugger> imo..
20:10:30 <Debugger> *from
20:10:44 <Gracenotes> a total of 170000 or so lines to pick through :)
20:11:07 <Gracenotes> er, 17000. At least. (an order of magnitude can mean quite a bit)
20:11:55 <Gracenotes> Debugger: yeah. It is a game, though, so everything is nonetheless very procedural, despite the underlying data structures/operations on them.
20:13:04 <Gracenotes> chessguy: in Journey to Rooted Hold, you can get the best idea of gameplay
20:13:07 <dsrogers> what does: src/Database/HaskellDB.hs:87:7:
20:13:07 <dsrogers>     Could not find module `Text.PrettyPrint.HughesPJ':
20:13:08 <dsrogers>       it is a member of package pretty-1.0.1.0, which is hidden
20:13:08 <dsrogers> mean?
20:13:18 <dsrogers> pretty is installed.
20:13:27 <dsrogers> who is hiding the package?
20:13:58 <geezusfreeek> dsrogers, cabal is hiding the package from ghc, usually
20:14:01 <Gracenotes> chessguy: the 3rd game, The City Beneath, is a bit more of showcase of scripting, etc., doesn't get into the meat right away. Although, there is more of a story
20:14:13 <geezusfreeek> dsrogers, add pretty to the build-depends field of the .cabal file
20:14:26 <dsrogers> ah
20:14:41 <dsrogers> so the answer is... haskelldb doesn't work with ghc 6.10
20:14:53 <SamB> dsrogers: eh ?
20:15:00 <SamB> oh, was that in base before ?
20:15:09 <dsrogers> I believe so, yes.
20:15:25 <SamB> you could ask gwern or someone to help you update the cabal file
20:15:37 <dsrogers> I can do it.
20:15:42 <dsrogers> well I can't update the repo...
20:15:58 <SamB> so that it would work with both new AND old GHC
20:16:40 <dsrogers> ah
20:20:20 <geezusfreeek> just to see i built haskelldb. the .cabal file did take a fair bit of updating
20:20:50 <dsrogers> yeah, I'm getting through it.
20:20:51 <SamB> geezusfreeek: but did you make a multi-GHC cabal file ?
20:21:00 <geezusfreeek> no, i did not. i was just verifying that it would build
20:21:19 <geezusfreeek> i have never made a multighc build
20:21:34 <Gracenotes> chessguy: I must remark, though, that's inconvenient to play on a keyboard without a Number pad
20:21:42 <Gracenotes> that it's
20:23:50 <dsrogers> ah, got it.
20:24:02 <dsrogers> yeah, a bunch of new extensions, and 3 new build deps.
20:24:34 <dsrogers> err, 4
20:24:54 <dsrogers> and a warning about a missing build-type
20:27:09 <gwern> if it was anything but 'Simple' you'd've a much more... enjoyable... experience getting it to build
20:27:14 <dsrogers> lol
20:27:29 <dsrogers> yeah, it assumes simple...
20:27:40 <dsrogers> I have a patch, I'll send to the maintainer...
20:27:50 <dsrogers> actually I should make sure it works...
20:28:25 <dsrogers> though... if it compiles, it works...
20:28:28 <dsrogers> right?
20:28:31 <inv> re
20:28:53 <inv> is where any visualiser for ghci debugger ?
20:28:55 <dsrogers> ooooooo
20:29:03 <dsrogers> cabal build worked.
20:29:05 <chessguy> Gracenotes, ohh, i could see this becoming very addicting
20:29:14 <dsrogers> but cabal install caused a GHC bug.
20:29:19 <Gracenotes> it is :)
20:29:25 <Gracenotes> there are plenty of fun user-made holds, too
20:29:35 <inv> which one ?
20:30:04 <dsrogers> 	idInfo r{tv adJo} [tv]
20:30:07 <inv> ow, one inportant point
20:30:11 <inv> for windows :)
20:30:30 <dsrogers> what's the difference between cabal build and cabal install?
20:30:37 <dsrogers> (eg. why does install build again?)
20:31:01 <gwern> because the /tmp dir is deleted
20:31:01 <chessguy> Gracenotes, holds?
20:31:03 <gwern> probably
20:31:45 <dsrogers> huh
20:31:52 <dsrogers> a build works, but a rebuild fails...
20:31:59 <dsrogers> so if I clean, then build, I'm all good.
20:32:06 <Gracenotes> chessguy: a series of levels (>= 1 levels). To beat the hold, you must defeat the individual levels. To beat a level, you must beat the rooms in it
20:32:25 <ozy`> hey cool, REBOL looks like smalltalk but works like lisp
20:33:02 <gwern> so... it is the worst of both worlds?
20:33:29 <ozy`> you might say that :p
20:33:35 <Gracenotes> chessguy: e.g. these. You can import them in the "Change Location" menu.. http://forum.caravelgames.com/holds.php
20:38:44 <monochrom> roconnor's laziness strategy is great!
20:40:46 <gwern> monochrom: was that incredibly long delay your idea of a joke?
20:41:32 <redditbot> Happstack 0.1 release scheduled for wednesday
20:41:43 <monochrom> I don't know. The roconnor quote on HWN is "I was going to read about laziness, but I decided to do it later, when I need to understand it."
20:42:02 <pumpkin> > groupBy (\x y -> x - y > 2) [1,2,3,4,7,8,9,50,51]
20:42:03 <lambdabot>   [[1],[2],[3],[4],[7],[8],[9],[50],[51]]
20:42:07 <pumpkin> > groupBy (\x y -> x - y < 2) [1,2,3,4,7,8,9,50,51]
20:42:09 <lambdabot>   [[1,2,3,4,7,8,9,50,51]]
20:42:21 <pumpkin> > groupBy (\x y -> y - x < 2) [1,2,3,4,7,8,9,50,51]
20:42:23 <lambdabot>   [[1,2],[3,4],[7,8],[9],[50,51]]
20:42:27 <monochrom> Oh I see what you mean now. I have been busy and not reading HWN in time.
20:42:34 <pumpkin> o.O
20:42:46 * wli would've used abs
20:43:01 <pumpkin> > groupBy (\x y -> abs (y - x) < 2) [1,2,3,4,7,8,9,50,51]
20:43:02 <lambdabot>   [[1,2],[3,4],[7,8],[9],[50,51]]
20:43:28 <SamB> I don't think that's a sensible thing to pass to groupBy ?
20:43:32 <pumpkin> I'd prefer [[1,2,3,4],[7,8,9],[50,51]]
20:43:45 <pumpkin> the docs aren't very helpful with the meaning of the function
20:43:55 <pumpkin> I assumed it was testing adjacent elements
20:44:03 <pumpkin> and would add to the current group until it returned false
20:44:03 <wli> SamB: Contiguous subsequences when ascending.
20:44:31 <SamB> actually, it is only documented to work on equivalence relations
20:44:43 <SamB> which is why it doesn't behave in a particularly helpful manner otherwise
20:44:46 <pumpkin> ah, true
20:45:00 <wli> Is it lazy?
20:45:06 <dsrogers> is there any reason to prefer hsql over HDBC?
20:45:47 <wli> If it's lazy you can probably get away with it.
20:46:09 <pumpkin> is there a function that behaves the way I want?
20:46:33 <wli> You'd have to go to some lengths to devise a lazy variant that doesn't work like that.
20:46:42 <SamB> wli: work like what ?
20:46:55 <SamB> there is a version of groupBy that works as pumpkin desribes
20:47:01 <dsrogers> crimany  all kinds of stuff is broken by 6.10.
20:47:07 <SamB> I dunno where you get it
20:47:12 <SamB> but it can be written
20:48:45 <wli> unfoldr, scanl, something.
20:48:45 <pumpkin> I'm sure it can be :P
20:49:01 <pumpkin> was just hoping there was one there already, but I'll play around
20:49:19 <dsrogers> can someone point me at a doc for writing cabal files that work on 2 versions of GHC?
20:50:08 <Ralith> @src +
20:50:08 <lambdabot> Source not found. Sorry.
20:50:14 <Ralith> @src (+)
20:50:14 <lambdabot> Source not found. Just what do you think you're doing Dave?
20:51:33 <gwern> 6.10 breakage hasn't been too bad. the real annoyance is Control.Exception
20:52:03 <dsrogers> gwern: well all the packages I'm looking at work build because the .cabal file needs to be updated.
20:52:14 <dsrogers> *work=won't
20:56:20 <wli> > map reverse $ foldl (\xss y -> case xss of [] -> [[y]] ; (xs:xss') | (x:_xs') <- xs, abs (x - y) < 2 -> (y : xs) : xss' | otherwise -> [y] : xss) [] ([1,2,3,4,7,8,9,50,51] :: [Int])
20:56:21 <lambdabot>   [[50,51],[7,8,9],[1,2,3,4]]
20:56:49 <wli> Or even reverse . map reverse $ ...
20:58:55 <dsrogers> so because of the changes to exceptions, is it possible to have code that compiles on 6.10 and 6.8?
20:59:27 <wli> It was foldl.
20:59:33 <SamB_XP> there is some compat package that smooths over the differences
20:59:59 <SamB_XP> and many programs just handle it themselves anyway
21:00:21 <dsrogers> SamB_XP: indeed, but the compat package is OldException ....
21:00:23 <gwern> @seen greenrd
21:00:24 <lambdabot> I haven't seen greenrd.
21:00:38 <dsrogers> and if you use that, it won't compile under 6.8, right?
21:00:52 <SamB_XP> dsrogers: I meant, a package that that works on either one
21:00:56 <ddarius> There's a package on hackage that abstracts over the difference.
21:00:57 <gwern> Control.OldException isn't in base in 6.8 don't think so
21:01:03 <ddarius> @hackage extensible-exceptions
21:01:03 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/extensible-exceptions
21:01:25 <dsrogers> ah
21:01:29 <ddarius> You could also always use CPP...
21:01:45 <SamB_XP> ddarius: isn't there also another one that's more like the old interface ?
21:02:17 <ddarius> SamB_XP: I haven't heard of anything, but that doesn't mean much.
21:02:49 <pumpkin> thanks wli
21:04:45 <wli> listCase :: [t] -> t' -> (t -> [t] -> t') -> t'?
21:05:03 <dsrogers> so, I'm having a similar error.
21:05:18 <dsrogers> Database/HDBC/Utils.hs:40:7:
21:05:19 <dsrogers>     Could not find module `Control.OldException':
21:05:19 <dsrogers>       it is a member of package base, which is hidden
21:05:27 <dsrogers> however "base" is in my Build-Depends
21:05:34 <dsrogers> why is it complaining?
21:07:08 <SamB_XP> maybe it's using the wrong version of base ?
21:07:21 <dsrogers> the version specified is unversioned
21:07:32 <dsrogers> and I only have version 4 installed
21:07:41 <SamB_XP> how can you only have version 4 installed ?
21:08:07 <dsrogers> ah.
21:08:08 <dsrogers> I see.
21:08:11 <dsrogers> I have both.
21:08:12 <ksf> how can I tell ghc to ignore that a module is marked as hidden in a package?
21:08:37 <SamB_XP> ksf: I don't think you can ?
21:08:42 <SamB_XP> you could ask in #ghc though
21:11:52 <dsrogers> oic.
21:12:17 <dsrogers> if some dependency links to v.3 of base does that mean I can't use v.4 of base?
21:12:32 <SamB_XP> dsrogers: hmm, good question ...
21:12:43 <SamB_XP> I think v3 actually uses v4 ...
21:12:47 <dsrogers> ah
21:13:03 <SamB_XP> ... but I'm not sure if it's something mere mortals can get away with
21:13:07 <wli> listCase ((:[]) . (:[])) (\xs xss -> (if maybe False (\x -> abs (x - y) < 2) (listToMaybe xs) then y : xs else [y]) : xss) and I forgot what I was doing.
21:14:34 <wli> No mapHead or whatever it would be called.
21:16:17 <wli> There's no span equivalent operating on adjacent elements.
21:16:34 <wli> That'd make things real easy real quick.
21:19:44 <dsrogers> hmm.
21:20:14 <dsrogers> and why is it, after I install two deps by hand, installing the third insists on trying to reinstall the deps I did by hand?
21:20:50 <SamB_XP> dunno!
21:20:58 <SamB_XP> is it installing the same versions ?
21:21:02 <dsrogers> yes
21:21:20 <SamB_XP> with the same of --user/--global ?
21:21:37 <dsrogers> um, I don't know that one...
21:21:55 <dsrogers> I'm never passing --user or --global though
21:22:14 <SamB_XP> I have no real clue then ...
21:23:28 <dsrogers> yeah.. --user doesn't make a difference.
21:27:48 <dsrogers> ahhh
21:27:52 <dsrogers> I get it.
21:28:00 <dsrogers> so I "fix" the haskell packages..
21:28:28 <dsrogers> only cabal thinks it's smarter than me and decides to reinstall because the dependcies it was installed with were changed.
21:28:55 <dsrogers> and it wants to try really hard to make everything look like the hackage version...
21:29:32 <dsrogers> how do I tell cabal I'm smarter than it?
21:30:26 <Raynes> dsrogers: Beat the stupid out of it.
21:30:40 <Raynes> dsrogers: Better yet, beat the smart out of it.
21:31:11 <dsrogers> I have to admit, this is pretty stupid... so now I can "fix" cabal by inserting my modified .cabal file into the index.tar...
21:31:23 <dsrogers> BUT!  it'll get overwritten if I ever do a cabal update
21:32:15 <sjanssen> dsrogers: so you installed two packages with 'runghc Setup'?  That will default to the global package DB
21:32:20 <dsrogers> no.
21:32:22 <sjanssen> cabal install defaults to the user's DB
21:32:32 <dsrogers> I fixed a .cabal file that didn't build on ghc6.10
21:32:42 <dsrogers> and I don't control the repo for this pacakge.
21:33:16 <dsrogers> when I install packages that depend on this fixed package (which I fixed locally) cabal wants to reinstall it, because the version from hackage is different.
21:33:21 <sjanssen> dsrogers: what did you change?  The base version dependency?
21:33:25 <dsrogers> yeah
21:33:28 <dsrogers> err, no.
21:33:34 <sjanssen> what?
21:33:42 <dsrogers> for one yes, I changed the base version dependency.
21:34:01 <sjanssen> so you've got one package that uses base-3, and one that uses base-4?
21:34:01 <dsrogers> for the other I added all the additional build deps to make it build on base 4.
21:34:07 <dsrogers> essentially, yes.
21:34:20 <dsrogers> though I suppose if I up the version, hackage will stop complaining...
21:34:24 <sjanssen> and you're trying to depend on both packages in a third package?
21:34:56 <sjanssen> dsrogers: please don't go uploading packages to hackage that you don't maintain
21:35:02 <dsrogers> what no?
21:35:07 <dsrogers> I'm not.
21:35:10 <dsrogers> I can't anyway...
21:35:13 <dsrogers> and I don't want too.
21:35:22 <dsrogers> but yes, you have the idea.
21:35:24 <sjanssen> oh, I misunderstood
21:35:57 <dsrogers> so, in particular, I fixed HDBC and haskelldb to build under 6.10
21:36:01 <sjanssen> the problem is that Cabal wants a consistent set of dependencies -- linking together two packages which use two different versions of base is liable to break
21:36:14 <dsrogers> really?
21:36:26 <dsrogers> so I can't use base-4 unless /everything/ is using base-4?
21:36:47 <sjanssen> well, it is not advisable to
21:36:52 <dsrogers> but in any case, that's not the issue.
21:37:19 <dsrogers> cabal wants to rebuild HDBC simply because the build-deps are different.
21:37:24 <dsrogers> everything is using base-4...
21:37:35 <dsrogers> but the list of build-deps changed.
21:37:59 <sjanssen> I doubt that is why cabal wants to rebuild it
21:38:02 <dsrogers> it is.
21:38:07 <dsrogers> it doesn't like that.
21:38:13 <sjanssen> how do you know this?
21:38:13 <dsrogers> I checked with -v
21:39:03 <sjanssen> could you pastebin that output?
21:39:04 <dsrogers> In order, the following would be installed:
21:39:05 <dsrogers> HDBC-1.0.1 (reinstall) changes: containers-0.2.0.0 removed, old-time-1.0.0.1
21:39:05 <dsrogers> removed
21:39:05 <dsrogers> HDBC-sqlite3-1.0.1.0 (new package)
21:39:05 <dsrogers> haskelldb-0.10 (reinstall) changes: directory-1.0.0.2 removed,
21:39:08 <dsrogers> oh sorry.
21:39:12 <dsrogers> yes, I could have...
21:39:23 <dsrogers> .I'll give you the whole thing though.
21:39:34 <dsrogers> what's the url for pastebin?
21:39:44 <sjanssen> @where hpaste2
21:39:44 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
21:41:25 <dsrogers> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1030#a1030
21:41:39 <dsrogers> I left off all the noise from the actual build.
21:42:47 <ksf> waaagh
21:42:56 <wli> > let span2 p xs = let zs = map Just xs ; ys = zip zs $ tail zs ++ repeat Nothing in (\ws -> maybeToList (join . fmap fst $ listToMaybe ws) ++ catMaybes (map snd ws)) *** (catMaybes . map snd) $ span (fromMaybe False . uncurry (liftM2 p)) ys in span2 (\x y -> abs (x - y) < 2) ([1,2,3,4,7,8,9,50,51] :: [Int])
21:42:58 <lambdabot>   ([1,2,3,4],[7,8,9,50,51])
21:43:09 <ksf> at first, I liked -XExistentialQuantification
21:43:31 <dsrogers> ah.
21:43:38 <ksf> now it seems like the type checker doesn't know what I'm talking about.
21:43:51 <ksf> ...which wouldn't be a problem, if he was able to tell me why.
21:44:56 <sjanssen> dsrogers: "HDBC-1.1.3" is the one you hacked and installed yourself?
21:45:28 <dsrogers> err, there is no 1.1.3...
21:45:32 <wli> span2 as I wrote it seems messy.
21:45:35 <dsrogers> if you mean 1.0.1, then yes.
21:45:43 <dsrogers> it's one of them.
21:45:50 <ddarius> wli: That's because it is.
21:46:13 <wli> Maybe someone else can write a cleaner version of it.
21:47:28 <sjanssen> dsrogers: oh, so is there a reason you need that specific version?  HDBC is up to 1.1.6 and the Cabal file seems to support GHC 6.10
21:47:38 <dsrogers> no.
21:47:55 <dsrogers> I thought I was updated.
21:48:04 <dsrogers> I just installed cabal and ghc 6.10 yesterday...
21:48:18 <sjanssen> ah "HDBC==1.0.1" from haskelldb-hdbc-sqlite3-0.10
21:48:27 <sjanssen> so haskelldb-* is the bitrotted thing
21:48:39 <dsrogers> ah
21:48:41 <dsrogers> I see.
21:49:07 <ddarius> wli: I suspect a direct recursive version would be clearer.
21:49:34 <sjanssen> so I'd try to install the latest versions of HDBC*, and then see if you can hack haskelldb* to build with modern versions
21:49:47 <dsrogers> indeed.
21:50:03 <dsrogers> my install of cabal didn't automatically do a cabal-update
21:50:08 <dsrogers> err, cabal update
21:50:11 <sjanssen> dsrogers: I also note that haskelldb-hdbc-sqlite3 has no successfull builds on hackage
21:50:21 <dsrogers> so I still had my cabal index from months ago.
21:50:26 <sjanssen> including 6.6, 6.8 and 6.10.  One wonders if it ever actually worked
21:51:55 <sjanssen> dsrogers: the upload date is also nearly 2 years past
21:52:03 <dsrogers> can cabal uninstall a package?
21:52:18 <dsrogers> ah, so that answers a previous question.
21:52:22 <dsrogers> I should use hsql
21:52:23 <sjanssen> "ghc-pkg unregister" is the closest you'll get
21:52:23 <ddarius> > let span2 p xs = takeWhile snd $ zip xs $ zipWith p xs (tail xs) in span2 (\x y -> abs (x - y) < 2) ([1,2,3,4,7,8,9,50,51] :: [Int])
21:52:25 <lambdabot>   [(1,True),(2,True),(3,True)]
21:53:00 <dsrogers> oh, I think it works.
21:53:08 <dsrogers> the build box might not have the C library installe.d
21:53:11 <wli> Yeah, without some trickery it'll lose either the first or last.
21:53:32 <ddarius> > let span2 p xs = takeWhile snd $ zip xs $ True : zipWith p xs (tail xs) in span2 (\x y -> abs (x - y) < 2) ([1,2,3,4,7,8,9,50,51] :: [Int])
21:53:33 <lambdabot>   [(1,True),(2,True),(3,True),(4,True)]
21:53:36 <chrisdone> woot, just paid for my copy of Real World Haskell. it will arrive on Friday, perfect for the weekend! ^_^
21:53:41 <ddarius> > let span2 p xs = map snd $ takeWhile snd $ zip xs $ True : zipWith p xs (tail xs) in span2 (\x y -> abs (x - y) < 2) ([1,2,3,4,7,8,9,50,51] :: [Int])
21:53:42 <lambdabot>   [True,True,True,True]
21:53:48 <ddarius> > let span2 p xs = map fst $ takeWhile snd $ zip xs $ True : zipWith p xs (tail xs) in span2 (\x y -> abs (x - y) < 2) ([1,2,3,4,7,8,9,50,51] :: [Int])
21:53:49 <lambdabot>   [1,2,3,4]
21:54:05 <ddarius> > let span2 p xs = map fst $ span snd $ zip xs $ True : zipWith p xs (tail xs) in span2 (\x y -> abs (x - y) < 2) ([1,2,3,4,7,8,9,50,51] :: [Int])
21:54:06 <lambdabot>   Couldn't match expected type `[(a, b)]'
21:54:14 <ddarius> > let span2 p xs = span snd $ zip xs $ True : zipWith p xs (tail xs) in span2 (\x y -> abs (x - y) < 2) ([1,2,3,4,7,8,9,50,51] :: [Int])
21:54:15 <lambdabot>   ([(1,True),(2,True),(3,True),(4,True)],[(7,False),(8,True),(9,True),(50,Fal...
21:54:42 <wli> This is clearly going to end up cleaner.
21:55:10 <ddarius> I'm not recommending this way.  As I said, an explicit recursive version is probably clearest.
21:56:03 <ddarius> > let span2 p xs = join (***) (map snd) $ span snd $ zip xs $ True : zipWith p xs (tail xs) in span2 (\x y -> abs (x - y) < 2) ([1,2,3,4,7,8,9,50,51] :: [Int])
21:56:04 <lambdabot>   ([True,True,True,True],[False,True,True,False,True])
21:56:10 <ddarius> > let span2 p xs = join (***) (map fst) $ span snd $ zip xs $ True : zipWith p xs (tail xs) in span2 (\x y -> abs (x - y) < 2) ([1,2,3,4,7,8,9,50,51] :: [Int])
21:56:11 <lambdabot>   ([1,2,3,4],[7,8,9,50,51])
21:56:13 * ddarius keeps doing that
21:56:31 <ddarius> > let span2 p xs = join (***) (map fst) $ span snd $ zip xs $ True : zipWith p xs (tail xs) in span2 (\x y -> abs (x - y) < 2) ([1] :: [Int])
21:56:32 <lambdabot>   ([1],[])
21:56:36 <ddarius> > let span2 p xs = join (***) (map fst) $ span snd $ zip xs $ True : zipWith p xs (tail xs) in span2 (\x y -> abs (x - y) < 2) ([] :: [Int])
21:56:37 <lambdabot>   ([],[])
21:56:54 <ddarius> > let span2 p xs = join (***) (map fst) $ span snd $ zip xs $ True : zipWith p xs (tail xs) in span2 (\x y -> abs (x - y) < 2) ([1..10] :: [Int])
21:56:56 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10],[])
21:57:05 <pumpkin> mmm join ***
21:57:33 <dsrogers> bah
21:57:39 <ddarius> @pl span2 p xs = join (***) (map fst) $ span snd $ zip xs $ True : zipWith p xs (tail xs)
21:57:40 <lambdabot> span2 = ((join (***) (map fst) . span snd) .) . ap zip . ((True :) .) . (`ap` tail) . zipWith
21:57:49 <dsrogers> haskelldb hasn't been updated.
21:58:01 <BMeph> I call that function '<>'. :)
21:58:08 <pumpkin> how smart is pl?
21:58:14 <pumpkin> @pl (fst *** fst)
21:58:14 <lambdabot> fst *** fst
21:58:20 <dsrogers> so I'm still in the same place, only with a different package
21:58:31 <pumpkin> boo no join
21:58:55 <wli> That would be te clean way to deal wit the initial condition.
22:01:27 <ddarius> @pl span2 p xs = join (***) (map snd) $ span fst $ zip (True : zipWith p xs (tail xs)) xs
22:01:27 <lambdabot> span2 = ((join (***) (map snd) . span fst) .) . join . ((zip . (True :)) .) . (`ap` tail) . zipWith
22:02:54 * wli for some reason finds these things involving ap stunningfly foul.
22:03:04 <ray> @unap
22:03:04 <lambdabot> Maybe you meant: map slap undo unpf unpl
22:03:54 <wli> I'd have preferred a different combinator besides ap.
22:06:25 <wli> Seriously, liftM2 ($) is not really that useful.
22:06:52 <dsrogers> *sigh* so much for typesafe embedded sql.
22:06:53 <ddarius> wli: (<*>) is basically the same thing
22:07:06 <dsrogers> is there a reason to prefer HSQL over HDBC?
22:07:29 <sbahra> HSQL works?
22:07:41 <wli> ddarius: Where's (<*>)?
22:07:46 <ddarius> @hoogle (<*>)
22:07:46 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
22:07:56 <dsrogers> HDBC doesn't?
22:08:02 <sbahra> HDBC does.
22:08:05 <sbahra> And has a chapter in RWH.
22:08:13 <dsrogers> hoookay
22:08:22 <sbahra> HSQL doesn't, though.
22:08:26 <sbahra> And HaskellDB didn't build for me.
22:08:31 <sbahra> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskelldb
22:08:38 <ddarius> wli: liftMn f x1 x2 ... xn = f `ap` x1 `ap` x2 `ap` ... `ap` xn
22:08:53 <wli> ddarius: liftA2 ($) blah
22:09:10 <ddarius> @src liftA2
22:09:10 <lambdabot> liftA2 f a b = f <$> a <*> b
22:09:13 <pumpkin> liftA2 >> liftM2
22:09:25 <ddarius> That first `ap` should have been an `fmap`
22:09:43 <ddarius> @src liftA3
22:09:44 <lambdabot> Source not found. My pet ferret can type better than you!
22:09:52 <pumpkin> > ((+1) >> (*2)) 4
22:09:53 <lambdabot>   8
22:09:55 <pumpkin> > ((+1) >>> (*2)) 4
22:09:56 <lambdabot>   10
22:09:57 <pumpkin> zomg
22:10:04 <pumpkin> > ((+1) <<< (*2)) 4
22:10:05 <lambdabot>   9
22:10:19 <pumpkin> I can count with angle brackets
22:11:26 * wli suddenly realizes one of the big reasons he never touches Control.Applicative
22:14:20 <wli> fmap, pure, and some bizarre meaningless and useless third operation
22:14:37 <ddarius> wli: It's application, lifted.
22:15:32 <wli> Well, yes. liftM2 ($) / liftA2 ($) etc.
22:19:38 <ddarius> wli: 'f x' in ML means 'ap f x' using some monad suitable for modelling the effects in ML.  fmap f x = ap (pure f) x.  ap is, quite arguably, fundamental, but usually more general than needed.
22:21:30 <wli> Well, you can choose a lot of different sets of combinators to be the primitive set. The trick is picking ones that are enlightening or conceptually easy to deal with or comprehensible etc.
22:23:40 <sjanssen> wli: "useless and meaningless" because you haven't bothered to learn it?
22:25:58 <wli> Maybe. I could be onto something if liftM2 ($) / liftA2 ($) is a poor match for the intuitions of a broader sample set.
22:28:54 <sjanssen> wli: ap is a good primitive because it provides a uniform way to define the liftMX functions
22:29:29 <sjanssen> I wouldn't say that "ap = liftM2 ($)", I'd say that "liftM2 f x = ap (return f) x"
22:30:14 <wli> I'd bet the way people make sense of ap is as liftM2 ($)
22:31:21 <sjanssen> you may only think that because you learned Monad before Applicative
22:32:54 <wli> "ap = liftM2 ($)" ---> ap is application (i.e. ($)) lifted
22:33:33 <wli> "liftM2 f x = ap (return f) x" ---> uh, it's primitive
22:34:30 <sjanssen> "ap (return f) x" lift f, apply it to x
22:34:49 <sjanssen> (return is just liftM0)
22:34:56 <wli> Except it's a partial application.
22:35:19 <sjanssen> oh, I didn't finish that
22:35:25 <ddarius> "liftM2 f x y = return f `ap` x `ap` y" --> liftM2 is applying a pure function to two "impure" values
22:35:32 <sjanssen> "liftM2 f x = return f `ap` x `ap` y"
22:35:35 <ddarius> "ap = liftM2 ($)" --> uh, it's primitive
22:36:01 <lgas> is there an idiom in haskell for naming predicates?  e.g. fooP or isFoo ?
22:36:10 <ddarius> lgas: Use isFoo.
22:36:22 <lgas> okidokie
22:36:41 <wli> The explanations going the other way around still seem awkward.
22:38:15 <sjanssen> the explanations of liftM2 defined via ap are more complex because liftM2 is more complex
22:38:16 <ddarius> "ap is application lifted" is not self-contained.
22:38:35 <sjanssen> the explanation of ap defined via ap is simpler because ap is simpler
22:39:11 <sjanssen> s/via ap/via liftM2
22:40:14 <BMeph> wli: So, what's your opinion of bind? :)
22:40:24 <wli> It all depends on a survey of the rest of the world's intuitions.
22:41:01 <wli> BMeph: x >>= f = join $ fmap f x
22:41:15 <mmorrow> dsrogers: i've got the some haskelldb stuff built: haskelldb-0.11, haskelldb-hsql-0.11, haskelldb-hsql-sqlite3-0.11,
22:41:23 <mmorrow> dsrogers: i don't use cabal install though
22:41:40 <mmorrow> to fix the Exception problem, i do:
22:41:56 <mmorrow> for i in `find . | grep -vE "_darcs" | grep -E "\.hs"`;do cat $i | sed -r 's/Control.Exception/Control.OldException/g' > a; mv -f a $i; done
22:41:56 <dsrogers> mmorrow: yeah... I got the build problems fixed.  It's the cabal problems that didn't like me much
22:41:59 <BMeph> wli: Yes, that's a definition it it. But what's your opinion?
22:42:00 <sjanssen> mmorrow: those versions are larger than the versions on hackage
22:42:12 <mmorrow> sjanssen: darcs
22:42:23 <sjanssen> somebody needs to release!
22:42:32 <sjanssen> early, often, etc.
22:42:40 <ddarius> To actually make a not-retarded argument, here's a description of liftM2 and ap at an equal level.  liftM2 takes executes two "impure" computations and applies a "pure" function to the results.  ap executes two "impure" computations applying the result of the former to the result of the latter.
22:42:49 <mmorrow> dsrogers: yeah cabal-install is tough when you've gotta hack a bunch of packages
22:43:06 <mmorrow> (or when you just hack a bunch of packages, whether it's needed or not)
22:43:06 <wli> BMeph: fmap, return, join are a better set of primitives.
22:44:17 <mmorrow> dsrogers: i also try to use the darcs version of everything if it's available
22:44:18 <Gracenotes> "you should avoid recursion at all costs in any language! recursion causes unnecessary repeating computations and will slow your program to a crawl. Try generating factorials by recursion and you'll see what I mean."
22:44:24 <BMeph> wli: But fmap is just 'ap . return .', so isn't ap more primitive? ;p
22:44:25 <Gracenotes> oh, stack overflow, how I love thee
22:45:02 <wli> BMeph: The choice of primitives is done for the sake of accommodating human intuition etc.
22:45:44 <mmorrow> Gracenotes: heh, he probably meant fib instead of fac
22:46:08 <mmorrow> (end even so, he must be using the naive algo)
22:46:11 <wli> BMeph: Or should be.
22:46:11 <mmorrow> *and
22:46:12 <ddarius> wli: join is a more powerful primitive than ap, hence their being a difference between Monad and Applicative.
22:47:06 <ddarius> (and why ap isn't a primitive, but (<*>) is)
22:48:25 <wli> It's all tied up with CPS or some such.
22:48:49 <ddarius> I don't know what you are talking about.
22:49:32 <wli> I wasn't arguing in favor of re-basing Applicative on something else. I was mostly just barfing on lambdabot spewing @pl results in terms of ap.
22:50:09 <wli> @pl is unreadable enough as it is.
22:50:09 <lambdabot> (line 1, column 31):
22:50:09 <lambdabot> unexpected end of input
22:50:09 <lambdabot> expecting white space or simple term
22:50:30 <mmorrow> yeah, i dislike ap in @pl too
22:50:41 <ddarius> What would you prefer?
22:50:44 <mmorrow> (i'm not sure if the (an) alternative would be preferable though)
22:50:58 <mmorrow> yeah, i don't know what the options are
22:51:15 <ddarius> liftM2 ($) zip tail does not strike me as noticeably clearer.
22:51:28 <mmorrow> it would probably require changes to the other prim combinators as well
22:51:31 <wli> Well, liftM2/liftA2 are not necessarily hot.
22:51:31 <ddarius> ap does at least have the benefit of being closely related to the S combinator.
22:51:55 <dsrogers> :info callCC
22:52:00 <wli> unlambda is noted for being unreadable.
22:52:17 <dsrogers> what package is callCC in?
22:52:19 <mmorrow> my main "beef" with ap is that it's behavior is dependent on the Monad instance
22:52:30 <wli> Control.Monad.Cont
22:52:37 <mmorrow> i think it'd be cooler if @pl didn't rely on any typeclasses
22:52:49 <ddarius> mmorrow: Unless you started with ap, @pl only ever uses ap for the function instance.
22:52:59 <mmorrow> nice, i was just about to ask that
22:53:12 <mmorrow> so then it can easily be replaced
22:53:17 <sjanssen> @pl \f x y -> liftM2 ($) f x y
22:53:18 <lambdabot> ap
22:53:30 <ddarius> mmorrow: Yes.  You can replace it with the S combinator.
22:53:33 <sjanssen> erm
22:53:41 <sjanssen> @pl liftM2 ($) x y
22:53:41 <lambdabot> x `ap` y
22:53:44 * mmorrow votes for ddarius's suggestion
22:53:54 * ddarius votes against ddarius's suggestion
22:54:07 * wli isn't wild about the S combinator either.
22:54:13 <sjanssen> mmorrow: one problem is that we don't have S in base
22:54:20 <sjanssen> (except via ap)
22:54:26 * mmorrow changing it to use S in lunabot's @pl ;)
22:54:31 <mmorrow> hehe
22:54:34 <mmorrow> yeah, true
22:54:39 <sjanssen> also, S is a constructor
22:54:40 <mmorrow> ok, i accept ap now
22:54:42 <ddarius> mmorrow: Note ap = flip S (or C S)
22:54:57 <mmorrow> sjanssen: heh
22:55:11 <mmorrow> ddarius: cool
22:55:26 <ddarius> Or am I wrong?
22:55:35 <mmorrow> i'm not sure, i don't recall the SKI defs
22:55:37 <ddarius> > ap f g x :: Expr
22:55:38 <lambdabot>   Add a type signature
22:55:42 <mmorrow> have to look em up
22:55:43 <sjanssen> I think ap == S
22:55:58 <ddarius> Yeah, I think I'm thinking of (>>=) which is something flipped.
22:56:04 <mmorrow> , [$pl| liftM2 ($) x y |]
22:56:07 <ddarius> Sfgx=fx(gx)
22:56:09 <wli> I'd probably go for a broader set of combinators. It'd take some experimentation to see what comes out readable.
22:56:10 <lunabot>  x `ap` y
22:56:39 <BMeph> ddarius: =<< is the Kleisli star, if that's what you mean. :)
22:57:03 <wli> Or what comes out most readable across some set of "benchmark" expressions to simplify etc.
22:58:12 <sjanssen>  @pl is most definitely not about readable
22:58:20 <sjanssen> @help pl
22:58:20 <lambdabot> pointless <expr>. Play with pointfree code.
22:58:31 <sjanssen> there is a reason we call it "pointless"
23:00:48 <mmorrow> on a related topic, and while i'm bitching anyways, i also dislike how @unpl uses the ((->)a) Monad instance
23:01:22 <ddarius> @unpl ap
23:01:22 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
23:01:31 <ddarius> mmorrow: What are you talking about?
23:01:34 <mmorrow> so rarely is (@unpl . @pl) == id
23:02:07 * mmorrow tries to think of an example
23:02:14 <ddarius>  @unpl -doesn't- use the instance (because that wouldn't be sound).  @pl using the instance is (part) of what makes @unpl . @pl /= id.
23:02:35 <mmorrow> ddarius: hmm, you may be right, but i'm not sure yet
23:03:25 <ddarius> mmorrow: Since @unpl (or @pl) doesn't do any type checking, it has no way of knowing when it's safe to use a specific instance.  If it ever does, then that's a bug in @unpl.
23:03:27 <sjanssen> mmorrow: the problem is that @pl frequently generalizes code
23:04:05 <mmorrow> ddarius: right. i meant "uses (>>=) for ((->)a) rather than inlining the def"
23:04:17 <mmorrow> sjanssen: that's a good point too
23:04:23 <wli> Yeah, the types are tricky.
23:04:24 <ddarius>  @unpl is basically just "expand combinators into definitions"
23:04:48 <mmorrow> ddarius: yeah, my preference would be to expand (>>=) to
23:04:53 <mmorrow> @src (->) (>>=)
23:04:53 <lambdabot> f >>= k = \ r -> k (f r) r
23:04:55 <ddarius> mmorrow: Without performing type checking, it can't do any better.
23:05:07 <mmorrow> oh shit! i see what you're saying
23:05:10 <mmorrow> heh
23:05:14 <mmorrow> ok
23:05:26 <mmorrow> hmm
23:05:54 <mmorrow> @unpl \ r -> k (f r) r
23:05:55 <lambdabot> \ r -> k (f r) r
23:06:20 <mmorrow> ok
23:07:03 * wli likes @pl to see the compositionality going on, except it's better to do it by hand because @pl seems to do it in a way that ruins the effect.
23:07:23 <ddarius> wli: You need to choose parameters carefully.
23:07:36 <ddarius> @pl \f g x -> map f . map g $ x
23:07:36 <lambdabot> (. map) . (.) . map
23:07:45 <ddarius> @pl \x -> map f . map g $ x
23:07:45 <lambdabot> map (f . g)
23:08:06 <glguy> ?unpl map (f.g)
23:08:07 <lambdabot> map (\ c -> f (g c))
23:08:09 <ddarius> Real "point-free" code does not get rid of -all- arguments.
23:10:11 <ddarius> For example, "the" point-free definition of (=<<) is (=<<) f = join . fmap f, not (=<<) = (join .) . fmap
23:11:28 <ddarius> Admittedly, point-free style doesn't lend itself well to curried functions.
23:11:36 <wli> Well, you can understand (unary .) . binary as an idiom.
23:12:31 <mmorrow> @pl \a b -> g (f a b)
23:12:32 <lambdabot> (g .) . f
23:12:35 <mmorrow> @pl \a b c -> g (f a b c)
23:12:35 <lambdabot> ((g .) .) . f
23:12:38 <mmorrow> @pl \a b c d -> g (f a b c d)
23:12:38 <lambdabot> (((g .) .) .) . f
23:13:07 <wli> I didn't recommend it.
23:13:09 <ddarius> wli: And you can understand (. unary) . (.) . unary as idiom too, but you aren't gaining much enlightenment this way.
23:13:29 <mmorrow> i understand (g .) . f as an idiom
23:13:36 <wli> I was about to recommend something analogous to Data.Function.on
23:13:39 <ddarius> mmorrow: At this point, several people do.
23:13:47 <ddarius> (at least of the people who play with @pl)
23:13:51 <mmorrow> personally, i like it
23:13:54 <mmorrow> heh
23:14:04 <quicksilver> some people suggest spelling it g .: f
23:14:07 <quicksilver> (for example)
23:14:07 <mmorrow> it's pretty clear once you know the pattern
23:14:23 <dsrogers> why can't the definition of callCC end with a _?
23:14:28 <wli> I doubt it'll fly with the unwashed masses who need to be able to read things.
23:14:28 <quicksilver> personally I tend to stick to unary pipelines, though
23:14:33 <mmorrow> but it'd probably be a "wtf!!?" if you don't
23:14:39 <quicksilver> or uncurry things for binary parts
23:14:52 <mmorrow> yeah, me too for the most part
23:15:00 <dsrogers> I don't see how the final "c" is actually used, since it's applied to a continuation of the form \_ -> c a, so the argument is ignored...
23:15:27 <ddarius> @src Cont callCC
23:15:27 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
23:15:28 <mmorrow> @src callCC Cont
23:15:28 <lambdabot> Source not found. Just try something else.
23:15:38 <mmorrow> @djinn-env
23:15:38 <lambdabot> data () = ()
23:15:38 <lambdabot> data Either a b = Left a | Right b
23:15:38 <lambdabot> data Maybe a = Nothing | Just a
23:15:38 <lambdabot> data Bool = False | True
23:15:38 <lambdabot> data Void
23:15:40 <lambdabot> type Not x = x -> Void
23:15:42 <lambdabot> class Eq a where (==) :: a -> a -> Bool
23:15:57 <ddarius> dsrogers: _ isn't a value
23:16:09 <ddarius> And it can very well be used.
23:16:15 <mmorrow> @djinn-add type Cont r a = (a -> r) -> r
23:16:33 <mmorrow> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
23:16:33 <lambdabot> f a b = a (\ c _ -> b c) b
23:16:42 <mmorrow> i love how djinn gets it right
23:16:59 <wli> curry (map . uncurry (.)) isn't all that hot either, thoug.
23:16:59 <mmorrow> um
23:17:14 <mmorrow> @djinn-add type Cont' r a = Cont' (a -> r) -> r
23:17:14 <lambdabot> Error: Recursive types are not allowed: Cont'
23:17:18 <mmorrow> @djinn-add data Cont' r a = Cont' (a -> r) -> r
23:17:18 <lambdabot> Cannot parse command
23:17:29 <mmorrow> @djinn-add data Contt r a = Contt (a -> r) -> r
23:17:29 <lambdabot> Cannot parse command
23:17:32 <mmorrow> oh
23:17:38 <mmorrow> @djinn-add data Cont' r a = Cont' ((a -> r) -> r)
23:17:52 <mmorrow> @djinn ((a -> Cont' r b) -> Cont' r a) -> Cont' r a
23:17:52 <lambdabot> f a =
23:17:52 <lambdabot>     Cont' (\ b ->
23:17:52 <lambdabot>            case a (\ c -> Cont' (\ _ -> b c)) of
23:17:52 <lambdabot>            Cont' d -> d b)
23:18:04 <mmorrow> @src Cont callCC
23:18:04 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
23:18:15 <dsrogers> yeah...
23:18:38 <mmorrow> nice
23:18:51 <ddarius> Personally, I'd prefer if control were the method of MonadCont, control differing from callCC in that that final 'c' is 'id' instead.
23:18:59 <ddarius> (or 'return' in the ContT case)
23:19:23 <wli> .: looks nice.
23:19:39 <mmorrow> ddarius: or even the more primitive function that takes a parameter(s) for the differences between control/shift/callCC
23:20:09 <wli> It might also be that the set of things to do it with might not be a set of functions taken to be primitive but a sort of set of non-orthogonal things to optimize something over.
23:20:34 <mmorrow> wli: totally
23:21:12 <ddarius> wli: That is what @pl is now.  There is no system to the choice of primitives.
23:21:12 <dsrogers> the outer Cont is a function that takes a continuation (of course) and returns another continuation constructed from the result of applying f to the inner continuation.  Assuming c ever exits (it doesn't have too, of course), f will return a continuation that applies it's return value to "c"
23:21:36 <dsrogers> but the continuation of f is extracted and applied to c again.
23:21:53 <dsrogers> but f's returned continuation is of the form \_ -> c a
23:22:06 <dsrogers> so the inner most c is used, but the last c is ignored.
23:22:15 <dsrogers> AFAICT, you could set it too undefined
23:22:26 <ddarius> dsrogers: You are not considering all the possibilities.
23:22:39 <dsrogers> ok... what am I missing?
23:22:41 <ddarius> f is an arbitrary function.  It is not required to use it's arguments at all.
23:22:56 <dsrogers> ahhh
23:22:59 <dsrogers> I see.
23:23:00 <dsrogers> thank you
23:23:06 <mmorrow> > flip runCont id (callCC (\k -> return 42))
23:23:07 <lambdabot>   42
23:23:26 <mmorrow> > flip runCont id (callCC (\k -> (*2) `fmap` k 42))
23:23:27 <lambdabot>   42
23:23:35 <dsrogers> but it has to return a continuation of some kind, just not the one you built for it.
23:23:37 <wli> Wait, I think (.:) is (.) . (.)
23:23:39 <mmorrow> > flip runCont id (callCC (\k -> (*2) `fmap` return 42))
23:23:40 <lambdabot>   84
23:24:01 <ddarius> wli: Yes.
23:24:09 <dsrogers> and in which case, you cant to make sure you run the "real" continuation, c.
23:24:12 <dsrogers> thanks.
23:24:25 <dsrogers> *cant=have
23:25:08 <mmorrow> can has real kontinution?
23:25:14 <wli> (.) . (.) isn't all that enlightening as an expression per se, though you can smoke out what it means if you stare at it long enough.
23:25:48 <ddarius> @unpl (.) . (.)
23:25:49 <lambdabot> (\ i b c f -> i (b c f))
23:26:01 <dsrogers> wli: I a disagree.  It's quite enlightening as an expression.  Enlightenment just takes patience.
23:26:14 <dsrogers> I last looked at this stuff pre-holidays.
23:26:15 <ddarius> @unpl (.) . (.) . (.) . (.)
23:26:15 <lambdabot> (\ o b c f i l -> o (b c f i l))
23:26:17 <dsrogers> my head is clearer now.
23:26:22 <dsrogers> stupid holiday's
23:26:30 <dsrogers> stupid online retail...
23:26:38 <dsrogers> stupid long hours no hobbies.
23:26:41 <dsrogers> bah
23:26:43 <dsrogers> lol
23:26:53 <mmorrow> heh
23:26:53 <dsrogers> bah humbug, rather.
23:27:38 <wli> There's a pattern, yeah.
23:28:22 <wli> That pattern is very enlightening, not the expression itself.
23:28:52 <mmorrow> totally, the pattern always makes the instances obvious
23:29:04 <wli> (.) . (.) is the owl combinator?
23:29:07 <mmorrow>  @pl and @unpl are sweet
23:29:45 <dsrogers> so ... if f doesn't use the current continuation, it won't return f's value from callCC, right?
23:30:06 <dsrogers> whcih is another way of stating that last "c"
23:30:51 <wli> Something based on that pattern that makes it all clear would help.
23:31:13 <wli> It's basically composition of unary with n-ary.
23:31:16 <ddarius> dsrogers: callCC's continuation gets called no matter what f does.  f has two ways of "returning."  It can either call the continuation it was passed or it can return normally.
23:31:37 <mmorrow> > flip runCont id (callCC (\k -> return 42))
23:31:38 <lambdabot>   42
23:31:40 <mmorrow> > flip runCont id (callCC (\k -> k 42))
23:31:41 <lambdabot>   42
23:32:03 <wli> composeUnaryWIthBinary, composeUnaryWithTernary, composeUnaryWithArity4, etc.
23:32:20 <mmorrow> > flip runCont id (callCC (\k -> return 42 >>= \_ -> return 99))
23:32:21 <lambdabot>   99
23:32:25 <mmorrow> > flip runCont id (callCC (\k -> k 42 >>= \_ -> return 99))
23:32:26 <lambdabot>   42
23:32:36 <ddarius> What's wrong with (>>) ?
23:32:39 <dsrogers> flip runCont id (callCC (\k -> return 27))
23:32:46 <dsrogers> > flip runCont id (callCC (\k -> return 42))
23:32:47 <lambdabot>   42
23:32:48 <wli> Maybe someone has a better non- line noise interpretation.
23:33:01 <dsrogers> > flip runCont id (callCC (\k -> return 27))
23:33:02 <mmorrow> ddarius: i didn't have the outcome planned out until i wrote it
23:33:02 <lambdabot>   27
23:33:03 <wagle> goose typing: sometimes its not a duck
23:33:20 <dsrogers> > flip runCont id (callCC (\k -> k 42))
23:33:22 <lambdabot>   42
23:34:09 <dsrogers> alrighty.
23:34:13 <dsrogers> thanks for that.
23:34:15 <dsrogers> nighty night.
23:34:29 <mmorrow> > flip runCont id (callCC (\k -> let go n = if n < 10 go (n+3) else k n in go 0))
23:34:30 <lambdabot>   <no location info>: parse error on input `else'
23:34:39 <mmorrow> > flip runCont id (callCC (\k -> let go n = if n < 10 then go (n+3) else k n in go 0))
23:34:40 <lambdabot>   12
23:35:05 <mmorrow> err, that doesn't really show a good example
23:35:10 <mmorrow> > forever'
23:35:11 <lambdabot>   Not in scope: `forever''
23:35:23 <mmorrow> @let forever' m x = m x >>= forever' m
23:35:24 <lambdabot>  Defined.
23:35:27 * Workybob wonders how anyone managed to get metaplug to work before http://hackage.haskell.org/cgi-bin/hackage-scripts/package/metaplug
23:35:47 <wli> I'm all ears for non- line noise names for (.) . (.) . (.) . ... with N .'s in the middle and N+1 (.)'s around them.
23:35:50 <mmorrow> > flip runCont id (callCC (\k -> let go n = if n < 10 then go (n+3) else k n in forever' go 0))
23:35:52 <lambdabot>   12
23:35:58 <mmorrow> > flip runCont id (callCC (\k -> let go n = if n < 10 then go (n+3) else return n in forever' go 0))
23:36:13 <lambdabot>   thread killed
23:37:27 <wli> But the basic idea of composeUnaryWithArityN being an end-product of some @pl-ish affair is where I'd like to see compositionality go.
23:37:27 <quicksilver> wli: well ".....:" was suggested once.
23:37:42 <quicksilver> you just count the dots to get the arity.
23:37:44 <wli> Or something.
23:37:46 <mmorrow> oh nice, i like that idea
23:38:16 <quicksilver> (excluding the dot in the top row, which is just a marker)
23:38:27 <wli> quicksilver: I'm game. The acid test is what proportion of newbies understand that vs. other things.
23:38:46 <quicksilver> 0% == 0%
23:38:46 <quicksilver> ;)
23:39:15 <mmorrow> , ppDoc `fmap` (let dots n = foldr (|.|) [|(.)|] (replicate (n-1) [|(.)|] in dots 7)
23:39:16 <lunabot>  luna: parse error on input `in'
23:39:23 <mmorrow> , ppDoc `fmap` (let dots n = foldr (|.|) [|(.)|] (replicate (n-1) [|(.)|]) in dots 7)
23:39:24 <lunabot>  (.) . ((.) . ((.) . ((.) . ((.) . ((.) . (.))))))
23:39:27 * BMeph imagines tassels every time he sees '(.) . (.)'
23:39:30 <wli> quicksilver: The last thing to do is to take the Haskell98 route and not do it at all (i.e. never go the H98 route).
23:39:56 <wli> mmorrow: Yeah, that's pretty much it.
23:40:10 <mmorrow> , (\n -> mkName ("(" ++ replicate n '.' ++ ")")) 7
23:40:11 <lunabot>  (.......)
23:41:00 <mmorrow> , src 'ValD
23:41:03 <lunabot>  data Dec = ... | ValD Pat Body ([Dec]) | ...
23:41:03 <lunabot>  infixl 9
23:41:20 <wli> The next trick is to get @pl or some @pl-ish thing to reduce to (map .:) under various circumstances instead of (map .) . (.)
23:41:36 <quicksilver> if ever I feel human endeavour may have limits, watching mmorrow dance with TH cheers me up
23:41:47 <wli> or whatever; maybe it needs some plain English -like name or whatever.
23:42:07 <mmorrow> , ppDoc `fmap` (let f = mkName ("(" ++ replicate n '.' ++ ")"); dots n = let go n = foldr (|.|) [|(.)|] (replicate (n-1) [|(.)|] in valD [varP f] (normalB (go n)) [])
23:42:08 <lunabot>  luna: parse error on input `in'
23:42:13 <mmorrow> quicksilver: :)
23:43:31 <mmorrow> , ppDoc `fmap` (let f n = mkName ("(" ++ replicate n '.'); dots n = let go n = foldr (|.|) [|(.)|] (replicate (n-1) [|(.)|]) in valD (varP (f n)) (normalB (go n)) [] in dots 7)
23:43:32 <lunabot>  (......) = (.) . ((.) . ((.) . ((.) . ((.) . ((.) . (.))))))
23:43:35 <mmorrow> yay
23:44:20 <mmorrow> i had to hack around a seeming bug in either the Name something or the prettyprinter
23:44:28 <mmorrow> , let f n = mkName ("(" ++ replicate n '.') in f 7
23:44:29 <lunabot>  (.......
23:44:40 * BMeph hands a box of tassels to mmorrow, and wishes him a good time...
23:44:50 <mmorrow> weeee
23:45:00 <wli> mmorrow: (..) won't parse. It clashes with enumeration syntax.
23:45:29 <mmorrow> wli: ah, good point. i guess a check for n > 2 or something
23:46:04 <mmorrow> oh, yeah of course
23:46:14 <quicksilver> that's one of the reasons for .:
23:46:17 <mmorrow> heh, you'd just check for n==2 and spit out
23:46:19 <mmorrow> ahhh
23:46:21 <mmorrow> i see :)
23:46:23 <quicksilver> (the enumeration syntax taking away ..)
23:46:30 <wli> , ppDoc `fmap` (let f n = mkName (replicate n '.' ++ ":"); dots n = let go n = foldr (|.|) [|(.)|] (replicate (n-1) [|(.)|]) in valD (varP (f n)) (normalB (go n)) [] in dots 7)
23:46:31 <lunabot>  (.......:) = (.) . ((.) . ((.) . ((.) . ((.) . ((.) . (.))))))
23:46:39 <mmorrow> nice
23:46:44 <wli> , ppDoc `fmap` (let f n = mkName (replicate n '.' ++ ":"); dots n = let go n = foldr (|.|) [|(.)|] (replicate (n-1) [|(.)|]) in valD (varP (f n)) (normalB (go n)) [] in dots 2)
23:46:45 <lunabot>  (..:) = (.) . (.)
23:47:00 * mmorrow copy/pastes that one-liner to clean up
23:47:04 <wli> Hmm. Maybe not quite what I had in mind.
23:47:29 <mmorrow> what are you thinking?
23:47:33 <wli> I think it's supposed to be N-1 dots with a : after.
23:47:58 <mmorrow> ah, yeah so there's no overlap for n==1 with (.)
23:48:20 <wli> , ppDoc `fmap` (let f n | n == 1 = '.' | n > 1 = mkName (replicate (n-1) '.' ++ ":"); dots n = let go n = foldr (|.|) [|(.)|] (replicate (n-1) [|(.)|]) in valD (varP (f n)) (normalB (go n)) [] in dots 2)
23:48:21 <lunabot>  luna: Couldn't match expected type `GHC.Types.Char'
23:48:34 <mmorrow> (i defined (|.|) = \g f -> [|$g . $f|]) in lunabot
23:48:35 <mmorrow> )
23:49:02 <mmorrow> , ppDoc `fmap` (let f n | n == 1 = '(.) | n > 1 = mkName (replicate (n-1) '.' ++ ":"); dots n = let go n = foldr (|.|) [|(.)|] (replicate (n-1) [|(.)|]) in valD (varP (f n)) (normalB (go n)) [] in dots 2)
23:49:03 <lunabot>  (.:) = (.) . (.)
23:49:11 <mmorrow> , '(.)
23:49:13 <lunabot>  GHC.Base..
23:49:18 <mmorrow> , '(,,,,,)
23:49:20 <lunabot>  GHC.Tuple.(,,,,,)
23:49:22 <mmorrow> , ''(,,,,,)
23:49:23 <lunabot>  GHC.Tuple.(,,,,,)
23:49:26 <mmorrow> , ''(.)
23:49:28 <lunabot>  luna: parse error on input `.'
23:49:32 <mmorrow> , ''Monad
23:49:33 <lunabot>  GHC.Base.Monad
23:49:35 <mmorrow> , 'Monad
23:49:37 <lunabot>  luna: Not in scope: data constructor `Monad'
23:50:07 <wli> , ppDoc `fmap` (let f n | n == 1 = mkName "." | n > 1 = mkName (replicate (n-1) '.' ++ ":"); dots n = let go n = foldr (|.|) [|(.)|] (replicate (n-1) [|(.)|]) in valD (varP (f n)) (normalB (go n)) [] in dots 2)
23:50:08 <lunabot>  (.:) = (.) . (.)
23:50:09 <mmorrow> so one ' for a value name, and two '' for a ty[pe name
23:51:32 <wli> , ppDoc `fmap` (let f n | n == 1 = mkName "." | n > 1 = mkName (replicate (n-1) '.' ++ ":"); dots n = let go n = foldr (|.|) [|(.)|] (replicate (n-1) [|(.)|]) in valD (varP (f n)) (normalB (go n)) [] in dots 3)
23:51:34 <lunabot>  (..:) = (.) . ((.) . (.))
23:51:42 <wli> , ppDoc `fmap` (let f n | n == 1 = mkName "." | n > 1 = mkName (replicate (n-1) '.' ++ ":"); dots n = let go n = foldr (|.|) [|(.)|] (replicate (n-1) [|(.)|]) in valD (varP (f n)) (normalB (go n)) [] in dots 1)
23:51:44 <lunabot>  (.) = (.)
23:52:14 <Workybob> has anyone tried building ghc-haskeline on OS X?
23:52:24 <mmorrow> , (vcat . fmap ppDoc) `fmap` (let f n | n == 1 = mkName "." | n > 1 = mkName (replicate (n-1) '.' ++ ":"); dots n = let go n = foldr (|.|) [|(.)|] (replicate (n-1) [|(.)|]) in valD (varP (f n)) (normalB (go n)) [] in mapM dots [3..20])
23:52:25 <lunabot>  (..:) = (.) . ((.) . (.))
23:52:25 <lunabot>  (...:) = (.) . ((.) . ((.) . (.)))
23:52:25 <lunabot>  (....:) = (.) . ((.) . ((.) . ((.) . (.))))
23:52:28 <mmorrow> ...
23:52:41 <Workybob> I'm getting a link error, but I'm really not sure why
23:53:22 <mmorrow> (without worrying about unique varnames, which don't matter here), ppDoc =
23:53:37 <Workybob> @where hpastetwo
23:53:37 <lambdabot> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/new
23:53:51 <mmorrow> ppDoc = text . pprint . everywhere (mkT (mkName . nameBase))
23:54:05 <Workybob> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1031#a1031
23:54:31 <mmorrow> preflex: zdec _ghczm6zi10zi1_LibFFI_Czuffizutype_closure_tbl
23:54:31 <preflex>  _ghc-6.10.1_LibFFI_C_ffi_type_closure_tbl
23:55:21 <mmorrow> Workybob: looks like you need the iconv c lib?
23:55:36 <Workybob> mmorrow: as the ls shows, it's sat there in /opt/local/lib
23:55:46 <mmorrow> ah, :)
23:56:00 * Workybob is confused
23:56:04 <mmorrow> oh, maybe ghc needs to know to look in /opt?
23:56:16 <mmorrow> err, i'm not sure on a mac
23:56:17 <Workybob> --extra-lib-dirs=/opt/local/lib
23:56:23 <Workybob> :/
23:56:31 <Workybob> I *thought* that's what that did
23:56:35 <mmorrow> heh, it is
23:56:42 <mmorrow> i keep missing everything ;)
23:56:55 <mmorrow> oh, i'm not sure if that _what_ it does
23:57:12 <mmorrow> i thought you said "i thought that's what _i_ did"
23:57:26 <wli> mmorrow: Looks good.
23:57:27 <Workybob> :/
23:57:39 * Workybob is shit at getting random things to build
23:57:51 <mmorrow> Workybob: maybe pass in some flags for ld
23:58:01 <Workybob> hm, possibly
23:58:03 * Workybob tries that
23:58:36 <mmorrow> wli: i wanna fill a module with those from [3..?] :)
23:58:44 <mmorrow> err, i mean [2..?]
23:58:48 <Workybob> hmm, no runhaskell Setup.hs build --ld-options="-L/opt/local/lib -liconv" gives the same result
23:59:41 <wli> mmorrow: Sure, though you might want type signatures so -Wall doesn't scream bloody murder.
23:59:43 <mmorrow> ohhhh, maybe hs-haskeline was built against a diff iconv lib
23:59:48 <mmorrow> wli: hehe
23:59:55 <Workybob> mmorrow: oh, interesting idea
