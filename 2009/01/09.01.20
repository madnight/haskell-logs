00:02:31 <dons> should be ok. most of uvector is overloaded
00:07:25 <elbar> @src (>>)
00:07:26 <lambdabot> m >> k      = m >>= \_ -> k
00:07:40 <elbar> > [1,2] >> [3,4]
00:07:42 <lambdabot>   [3,4,3,4]
00:08:42 <elbar> why not [3,4]?
00:08:59 <cnwdup> elbar: Because (>> [3,4]) is evaluated for each element in the first list.
00:09:04 <cnwdup> > [1,2,3] >> [3,4]
00:09:05 <lambdabot>   [3,4,3,4,3,4]
00:09:19 * Axman6 has a new blog! http://axman6.wordpress.com/
00:09:25 <papermachine> wordpress--
00:09:26 * Axman6 needs a better name though :\
00:09:26 <vixey> > do _ <- [1,2]; [3,4]
00:09:27 <lambdabot>   [3,4,3,4]
00:09:46 <idnar> xs >> ys is concat . take (length xs) $ repeat ys
00:09:59 <cnwdup> axman6: Font's a little small for my taste.
00:10:18 <dons> Tom Schrijvers, Louis-Julien Guillemette and Stefan Monnier.
00:10:19 <dons> Type Invariants for Haskell
00:10:21 <elbar> ah, k...thx =)
00:10:23 <dons> -- being presented tomorrow.
00:10:29 <dons> sounds interesting (at the verification workshop)
00:13:43 <cnwdup> @src intercalate
00:13:43 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
00:13:48 <cnwdup> @src intersperse
00:13:49 <lambdabot> intersperse _   []     = []
00:13:49 <lambdabot> intersperse _   [x]    = [x]
00:13:49 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
00:14:09 <ivanm> dmwit: ping!
00:22:02 <dmwit> ivanm, pong!
00:22:13 <ivanm> dmwit: yeganesh says nothing :(
00:22:21 <ivanm> I'll try building it again once my system has updated
00:22:44 <dmwit> It says nothing... and when you run it and select something, it doesn't make any output?
00:22:51 <ivanm> it doesn't even show up :s
00:22:55 <dmwit> Neat!
00:23:00 <dmwit> What's in ~/.yeganesh?
00:23:00 <ivanm> yup :s
00:23:17 <ivanm> oh, wait, I have to pass it dmenu_path, don't I ...
00:23:22 <dmwit> You shouldn't.
00:23:39 <ivanm> just run "yeganesh"?
00:23:44 <dmwit> yup
00:23:58 <dmwit> Assuming you've ever passed it dmenu_path in the past. =)
00:24:08 <cnwdup> dons: Whats actually the status of arch's overlay? Is it still first choice as I read its currently broken.
00:24:15 <ivanm> something that appears to be of the form (UTC Date, fromList [(String,Int)] )
00:24:16 <dmwit> There should be a file called ~/.yeganesh/default that contains the output of dmenu_path.
00:24:19 <dons> overlay is disabled
00:24:21 <dmwit> exactly
00:24:31 <dmwit> Okay, so that file is there, and it still won't show anything?
00:24:31 <dons> we've not found a satisfactory rebuilding mechanism for when nodes in the tree change
00:24:33 <dmwit> hum
00:24:40 <ivanm> dmwit: yup
00:24:46 <dmwit> I wonder if the format of dates changed... have you updated GHC recently?
00:24:48 <dons> cnwdup: some modification/hook into cabal-install would be required to keep it working. or else just rebuild eveyrthiiing.
00:24:53 <ivanm> yeganesh --help works...
00:25:00 <ivanm> dmwit: I've run yeganesh since upgrading ghc ;-)
00:25:03 <dons> cnwdup: so for now we're moving things into pacman instead, and using that.
00:25:07 <dons> there may be other ways too
00:25:23 <ivanm> dmwit: should I try a new profile?
00:25:25 <cnwdup> dons: Moving into pacman? As in support haskell over via AUR?
00:25:36 <cnwdup> *only
00:25:37 <dmwit> ivanm, sure
00:26:01 <dmwit> ivanm, You'll have to pass it something interesting on stdin the first time you use a new profile.
00:26:21 <dons> cnwdup: so currently AUR is where 99.5% of the support is, right (literally)
00:26:36 <dons> cnwdup: we're moving things from AUR into [extra] and [community]
00:26:41 <ivanm> dmwit: OK, it complains about not being able to cd to ~/bin and ~/.cabal/bin (which are in my path))
00:26:48 <dons> like cabal-install and haskell-binary and gtk2hs et al
00:26:50 <ivanm> and they are there...
00:26:54 <dons> now, the other 900 libs, what to do.
00:27:10 <dmwit> ivanm, err... hum
00:27:12 <dons> there's too many for the community repo, but we don't yet have a good binary dep rebuilder
00:27:18 <cnwdup> dons: And how will this save the trouble with the rebuilding thing?
00:27:23 <dmwit> ivanm, "it" is your shell or yeganesh?
00:27:41 <dons> cnwdup: most things will have been built for you
00:27:44 * dmwit sees no reason yeganesh should be changing directories
00:27:47 <ivanm> oh, wait, that's dmenu_path complaining
00:27:52 <dons> so an update means pacman -S rather than rebuilding something.
00:28:00 <dmwit> ah
00:28:02 <ivanm> dmwit: OK, "dmenu_path | yeganesh -p test" prints the item out to STDOUT.... running "yeganesh -p test" afterwards just hangs :s
00:28:16 <ivanm> dmwit: hmmmm..... what deps does yeganesh have? maybe one of them stuffed up...
00:28:24 <dmwit> ivanm, It's not hanging, you just need to send it an EOF.
00:28:25 <cnwdup> dons: Is the discussion saved somewhere where I can read it? I am still not really getting whats the problem with the overlay. I still think it was a terrific approach.
00:28:44 <dmwit> ivanm, Try "echo | yeganesh -p test".
00:28:49 <dons> ah , so the overlay is very useful, yes?
00:28:59 <ivanm> dmwit: that works \o/
00:29:01 <dons> but the problem is that if one library changes, everything that is upstream from that need to rebuilt
00:29:09 <dons> and we don't have a tool to do that automatically
00:29:13 <ivanm> dmwit: so its because dmenu_path doesn't end in an EOF? :o
00:29:14 <dmwit> ivanm, Okay, what about "echo | yeganesh -p default"?
00:29:21 <dons> we're looking into ways of doing that.
00:29:25 <ivanm> dmwit: yup, works
00:29:28 * bos boggles at the amount of work to do on Data.Text
00:29:35 <cnwdup> dons: Okay. And this tool would be hard to build? Or is it the available resources used for compiling that restrict progress?
00:29:39 <dons> so what does Data.Text do, bos?
00:29:53 <dmwit> ivanm, Okay... then the only thing left to test is to type in exactly what's in xmonad.hs at a shell and see what it does, I guess.
00:29:53 <ivanm> dons, bos: is there going to be a patch file released to fix all the errata in RWH? ;_
00:29:54 <bos> dons: packed Unicode text, sioraiocht's stuff
00:29:59 <ivanm> * ;-)
00:30:06 <dons> wooo!
00:30:07 <dmwit> ivanm, so "dmenu_path | yeganesh" or something like that
00:30:20 <dons> right, so is it the size of Data.ByteString? or does it reuse that stufF?
00:30:22 <bos> dons: the basic module is about half done
00:30:31 <ivanm> dmwit: this is the xmonad.hs command: spawn "exe=`dmenu_path | yeganesh -- -i -b` && eval \"exec $exe\""
00:30:33 <bos> dons: it uses the newer stream fusion machinery
00:30:46 <dons> ah ok. so more reuse i guess/smaller code
00:30:59 <bos> well, not smaller, unfortunately.
00:31:01 <dons> i wonder if you can use the stream combinators directly for the uvector implementation?
00:31:08 <dons> bytestrings' in the 3k loc range, iirc
00:31:09 <bos> i think it will end up a lot bigger than bytestring.
00:31:25 <dmwit> ivanm, Okay, so try the bit inside the backticks: "dmenu_path | yeganesh -- -i -b".
00:31:27 <ivanm> dmwit: weird... running "dmenu_path | yeganesh" works now :s
00:31:44 <bos> dons: i'll have to take another look at uvector, it would be nice to pare back the amount of code if possible
00:31:46 <dons> does it use the same stream fusion definition?
00:31:48 <dons> http://code.haskell.org/~dons/code/uvector/Data/Array/Vector/Stream.hs
00:31:50 <ivanm> maybe a temporary glitch in dmenu_path?
00:31:55 <dons> if so, those functions might be reused easily
00:31:59 <bos> yes, it does
00:32:26 <dons> ok. so the ones in uvector are all very carefully optimised to the asm level. so feel free to steal.
00:32:32 <dons> those kind of ones, replicateS :: Int -> a -> Stream a
00:32:40 <bos> cheers!
00:32:57 <dons> we really just need a single fusion lib with  that Stream defin and associated functions
00:33:05 <dons> since the implementations are actually pretty stable.
00:33:05 <bos> yes, we do.
00:33:22 <dons> if say, uvector, the list-fusion one, and Data.Text all reused the one i just posted
00:33:25 <dons> we'd be in business
00:33:29 <Axman6> lisp isn't statically types is it?
00:33:50 <bos> we would indeed.
00:33:51 <sioraiocht> dons: well, Text, at least, has length hints in the stream fields
00:33:52 <dons> so i wonder what the relationship between Data.Text and uvector is
00:33:55 <sioraiocht> as dones BS, I believe
00:33:57 <dons> are uvectors ForeignPtrs ?
00:33:58 <ivanm> dons: with STM, you mention alwaysSucceeds, but never actually show how to use it... >_>
00:33:58 <sioraiocht> *does
00:34:01 <dons> sorry, Data.Text's?
00:34:06 <sioraiocht> dons: yes
00:34:09 <ivanm> Axman6: I don't think so, no
00:34:18 <dons> right. so that's different then to uvector
00:34:25 <dons> it means you can't layer one on top of the other
00:34:26 <ivanm> but you can "tag" the values with types using tuples
00:34:31 <dmwit> ivanm, So, is it fixed?
00:34:31 <vixey> Axman6, lisps are untyped -- but in i.e. common lisp you can statically declare types and optimizations to be done
00:34:34 <bos> what? no they're not.
00:34:38 <ivanm> though IIRC, it seems some scheme implementations have optional typing
00:34:40 <bos> they're UArray
00:34:41 <ivanm> dmwit: appears to be...
00:34:43 <dmwit> \o/
00:34:50 <Axman6> righto
00:34:52 <dons> oh
00:35:07 <sioraiocht> bos: although ideally they would be ByteArray#
00:35:13 <dons> i use these,
00:35:13 <dons> data MBUArr s e =
00:35:13 <dons>         MBUArr {-# UNPACK #-}!Int
00:35:13 <dons>                (MutableByteArray# s)
00:35:14 <sioraiocht> at least for Data.Text
00:35:17 <ivanm> dmwit: the test is when I try using it with a fresh boot... >_>
00:35:20 <dons> data BUArr    e =
00:35:20 <dons>         BUArr  {-# UNPACK #-}!Int
00:35:20 <dons>                {-# UNPACK #-}!Int
00:35:20 <dons>                ByteArray#
00:35:44 <dmwit> ivanm, heh
00:35:52 <dons> bos, sioraiocht well, anyway. great news. good to see progress!
00:35:59 * dons heads off to bed.
00:36:37 <bos> a UArray really is a ByteArray# with some other goo, anyway
00:36:50 <dmwit> goo
00:37:15 <dolio> It's UArray and uvector are pretty close.
00:37:17 <dmwit> ?remember bos a UArray is really a ByteArray# with some other goo
00:37:17 <lambdabot> It is forever etched in my memory.
00:37:37 <dolio> It's just that UArray has Ix stuff which messes up optimization.
00:37:49 <dolio> (And no fusion for the pure arrays.)
00:38:02 <sioraiocht> dons: well, you can use unsafe* do get around that ;)
00:38:05 <sioraiocht> err
00:38:06 <sioraiocht> dolio:
00:38:30 <dolio> Even if you use unsafeRead/Write, it doesn't optimize as well.
00:38:57 <dolio> At least, last I checked.
00:39:24 <Axman6> cnwdup: seems fine in my browers (it's not my theme, and i'm not too sure how to change it :\)
00:40:13 <brain_damege> main = putStrLn "Hello World!"
00:44:13 <adrian_> @pl (\x -> x*log x / log 2)
00:44:13 <lambdabot> (/ log 2) . ap (*) log
00:44:42 <ivanm> dmwit: hmmm.... I seem to be having the same trouble with dmenu proper now :s
00:44:45 <adrian_> @pl (\x -> x*log x)
00:44:46 <lambdabot> ap (*) log
00:45:58 <Axman6> @unpl ap f
00:45:59 <lambdabot> (\ e -> f >>= \ b -> e >>= \ a -> return (b a))
00:47:20 <joma> module Test where, how do I hide in a module? ie hiding what should be exported, not when importing....?
00:49:52 <dmwit> ivanm, urk
00:49:58 <dmwit> I'm about to hit the sack...
00:50:02 <ivanm> and the same problem with gmrun... :s
00:50:05 <ivanm> dmwit: don't worry about it
00:50:12 <ivanm> (for now, anyway :p )
00:50:17 <dmwit> =)
01:03:52 <Axman6> joma: module Test (sharedFunc, DataType(..), DataTypeHidingConstructors) where
01:07:01 <pozic> I have a custom monad transformer XT, which is an instance of MonadReader Int, and I have another monadtransformer YT which should access the Int, but how? I don't want all the operations available in XT to be available to YT.
01:11:05 * Axman6 hates it when #haskell goes quiet
01:11:33 <vixey> Axman6, I was looking at the ST monad implementation in Ynot today
01:11:44 <Axman6> Ynot?
01:12:18 <vixey> the type of STbind is 7 lines long :p
01:12:37 <vixey> http://www.eecs.harvard.edu/~greg/ynot/
01:13:49 <Axman6> i'm not familliar with dependent types :( but i'm open to learning about the, ;)
01:16:24 <Axman6> vixey: also, was it 7 lines for clarity, or because it's insanely complex?
01:17:04 <vixey> I couldn't tell
01:17:09 <Axman6> heh
01:23:44 <Axman6> so, anyone got any nice examples for using the ST monad?
01:23:55 <quicksilver> pozic: use 'ask' ?
01:24:08 <vixey> Axman6, I like my program
01:24:22 <Axman6> is it wikiable?
01:24:24 <vixey> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=62
01:24:52 <vixey> type Variable s a = STRef s (Maybe a)
01:24:57 <vixey> data Atom s = VarA (Variable s (Atom s))
01:24:57 <vixey>             | Atom String
01:25:10 <vixey> that 'Variable' def. and usage is the most important bit really
01:25:20 <vixey> (representing logic variables)
01:25:47 <quicksilver> Axman6: STRefs can be seen as a cleaner alternative "Map String Dynamic"
01:26:01 <quicksilver> they (a) replace the 'String' part with real, lexically scoped symbols
01:26:02 <pozic> quicksilver: won't ask need a MonadReaderinstance for the YT level? There only exists an instance for XT.
01:26:14 <quicksilver> and (b) replace the 'Dynamic' part with real, typed variables.
01:26:16 <Axman6> quicksilver: wut? o.O
01:26:19 <Workybob> {-# GHC_OPTIONS -Wall #-} is the right syntax for turning on -Wall for a file, right?
01:26:40 <pozic> I thought it was OPTIONS_GHC
01:26:48 <Workybob> ah, that'll be why it's not working!
01:27:05 <quicksilver> pozic: Well. The thing is, YT isn't a level, it's a transformer. You can presumably apply YT to things which don't have an inner XT.
01:27:11 <Axman6> Workybob: {-# OPTIONS -O2 -funbox-strict-fields #-} is one i'm using
01:27:17 <vixey> Workybob, it should have said: Unrecognised pragma
01:27:25 <quicksilver> pozic: So I imagine it's the actual final tower which has the reader isntance, not the YT.
01:28:11 <Axman6> vixey: wow, i have  no idea what that code does >_<
01:28:18 <vixey> Axman6, which?
01:28:26 <Axman6> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=62
01:28:55 <vixey> Axman6, the first paste is a first order unifier abstracted over data types,  the second paste is some instances and examples of it
01:29:00 <pozic> quicksilver: yes, one can apply YT to other things, but XT should really access some reader parameter of the right type from the surrounding monad transformer.
01:29:04 <quicksilver> Axman6: Can you imagine using 'Map String Dynamic' for a concrete symbol table?
01:29:15 <vixey> 'Unifiable' wil probably not make sense until you know what it does
01:29:16 <Axman6> quicksilver: i have no idea what that is...
01:29:19 <quicksilver> pozic: there is no notion of surrounding monad transforerm.
01:29:32 <quicksilver> Axman6: You don't know what Map is? Or String? or Dynamic?
01:29:59 <quicksilver> pozic: Does it help if you think of monad transformers as an implementation technique, not a final product?
01:30:05 <Axman6> Data.Map, and [Char]? no idea what Dynamic is
01:30:23 <quicksilver> pozic: and classes like MonadReader are like a capability system.
01:30:30 <pozic> quicksilver: ok, I thought I needed to lift this ask operation.
01:30:36 <quicksilver> pozic: so you declare which capabilities a function needs from its parameter.
01:30:41 <quicksilver> pozic: s/parameter/monad/.
01:31:16 <quicksilver> pozic: and then you can *use* that function on a particular concrete monad (Which may be a transformer tower) iff the concrete monad provides all the functionalities your classes ask for.
01:31:30 <quicksilver> pozic: you should never need to lift ask. The purpose of "ask" is that it is auto-lifted.
01:31:39 * boegel pulls dons' dingeling
01:31:42 <joma> so i have to explicitly list all functions i want to export?
01:31:49 <quicksilver> pozic: that's the idea about MonadState/MonadReader and similar classes. They lift their operations automatically.
01:31:52 <joma> can i just do hiding?
01:31:59 <Axman6> yes
01:32:01 <pozic> quicksilver: Normally one uses Identity as the innermost monad. Currently, I only get it working when I use Reader Int as the bottom one, instead of ReaderT in the outer layer.
01:32:08 <quicksilver> joma: Unless you want to export everything. You either expoert everything, or you list the ones you want.
01:32:33 <quicksilver> Axman6: Dynamic is a way of 'hiding' a value of any type inside a box, and getting it out again later, as long as you really knew the type.
01:32:36 <joma> so if i have a 200-function program and want to hide 5 then i need to list 195 functions!?
01:32:44 <quicksilver> joma: Yes.
01:32:45 <pozic> quicksilver: ok, I understand the purpose, but still it's asking about all kinds of impossible instances like Monad (t m).
01:32:54 <joma> ok thats insane
01:32:56 <vixey> joma, when you have 200 functions in a file the rules change :P
01:32:58 <boegel> quicksilver:  or you can just hide the 5, right?
01:33:03 <quicksilver> boegel: No.
01:33:13 <quicksilver> boegel: joma is talking about export lists not import lists.
01:33:19 <boegel> quicksilver: ah, sorry
01:33:23 * boegel hides in a corner again
01:33:26 <quicksilver> ;)
01:33:29 <Axman6> joma: sounds like you need to break things up into modules
01:33:31 <Peaker> joma: if you have 195 functions you want to export, you're probably designing a pretty bad API.  Your punishment: explicitly listing those 195 functions :-)
01:33:39 <vixey> haha
01:33:52 <quicksilver> pozic: Monad (t m) doesn't sound like an unreasonable constraint.
01:33:55 <joma> i have a matrix lib
01:34:05 <joma> 200 fucntons was an example
01:34:07 <quicksilver> pozic: for example, if (t === StateT s) then Monad (t m) holds if Monad m holds.
01:34:08 <joma> i dont
01:34:11 <joma> but too many to list
01:34:22 <quicksilver> pozic: Monad m => Monad (t m) is a property you expect if 't' is a monad transformer.
01:34:37 <quicksilver> pozic: I may need a concrete example to give more precise guidance.
01:34:42 <Peaker> joma: you could also just publish everything in the module, and put the stuff you want to hide in another module that you import qualified (qualified imports are not re-exported)
01:35:10 <quicksilver> Peaker: No imports are re-exported, unless listed explicitly.
01:35:22 <Peaker> quicksilver: what if you have no listing (export all)
01:35:29 <quicksilver> Peaker: No imports are re-exported, unless listed explicitly.
01:35:37 <Peaker> ah, ok
01:35:39 <quicksilver> ;)
01:35:44 <vixey> Axman6, other than unification.. can't think of many algorithms which I'd use mutation for though
01:35:47 <Peaker> joma: so you can do that
01:35:56 <Axman6> yeah :\
01:36:07 <quicksilver> Axman6: So, dynamic is a hack for storing a variable of any type, and String is a hack for making up your own symbols.
01:36:18 <quicksilver> Axman6: STRef is a "cleaner" solution than those two hacks.
01:36:33 <quicksilver> (the "String" part is worse than the "Dynamic" part, in my opinion)
01:36:45 <pozic> quicksilver: ok, so now I get no instance for MonadRandom Identity again.
01:36:54 <vixey> quicksilver, I just don't see the need for unsafeCoerce in dynamic
01:37:01 <Axman6> quicksilver: ah... sound yuck
01:37:15 <quicksilver> vixey: How would you implement it without unsafeCoerce?
01:37:39 <pozic> quicksilver: is it because XT and YT are really separated?
01:37:39 <quicksilver> pozic: without seeing the code Im' not sure I can help ;)
01:37:42 <adrian_> is there an efficient way to group stuff by equality without having an ord constraint?
01:37:52 <vixey> hm I suppose (for it to be open) it would require type families...
01:38:00 <adrian_> so that [1,2,1,2] -> [[1,1],[2,2]]
01:38:01 <vixey> :t group
01:38:03 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
01:38:08 <vixey> not group...
01:38:31 <adrian_> you could group.sort, but that has Ord a =>
01:38:31 <joma> is there no way to fix so i can do in ghci:
01:38:34 <Axman6> > group [1,2,1,2]
01:38:36 <lambdabot>   [[1],[2],[1],[2]]
01:38:36 <joma> doc mul
01:38:41 <vixey> adrain_, there isn't an /efficient/ way
01:38:47 <boegel> has anyone else experienced problems when trying to install alex-2.2?
01:38:49 <Axman6> > group . sort $ [1,2,1,2]
01:38:51 <lambdabot>   [[1,1],[2,2]]
01:38:52 <adrian_> thought so
01:38:58 <joma> and then i egt a docstring like: "timecomplexity O(n^3) , multiplies 2 matrices"
01:39:09 <adrian_> maybe a hashmap
01:39:12 <Peaker> adrian_: its pretty inherent
01:39:18 <Peaker> adrian_: that would just make the worst case even worse
01:39:32 <adrian_> why?
01:39:41 <Peaker> adrian_: because a hash table lookup is O(N*N) worst-case
01:39:41 <adrian_> I thought hashmaps have O(1) amortized lookup
01:39:42 <jberg> can you search hoogle with haskell-mode for emacs?
01:39:46 <Peaker> oops
01:39:48 <Peaker> O(N)
01:40:05 <Peaker> adrian_: so if you have N lookups in a hash table, you get O(N*N) instead of O(N log N)
01:40:27 <quicksilver> Peaker: wtf?
01:40:38 <Peaker> quicksilver: a hash table lookup is O(N) worst-case
01:40:47 <quicksilver> in what sense? what kind of worst case?
01:40:58 <quicksilver> the problem here is that Eq doesn't give you a hash implementation.
01:40:59 <Peaker> quicksilver: CS-kind of worst-case.  If you have a lot of collisions
01:41:09 <adrian_> all your key hash to the same value?
01:41:17 <Peaker> quicksilver: you could have the type  Hash a => [a] -> [[a]], that's probably ok
01:41:29 <adrian_> that shouldn't happen with any decent hashing function
01:41:31 <Peaker> adrian_: yes. Or any constant percentage of them
01:41:32 <quicksilver> that worst case point was just ridiculous :P
01:41:41 <quicksilver> the problem here is not that the hash function might be bad.
01:41:46 <quicksilver> the problem is that you don't have a hash function.
01:41:49 <vixey> @let a = [1,2,1,2]
01:41:51 <lambdabot>  Defined.
01:41:52 <vixey> > let filter (==head a) a
01:41:52 <Peaker> quicksilver: the worst-case analysis in CS generally considers hashes to be O(N) lookup
01:41:53 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
01:41:57 <vixey> > filter (==head a) a
01:41:58 <lambdabot>       Ambiguous occurrence `a'
01:41:58 <lambdabot>      It could refer to either `L.a', defined a...
01:42:23 <quicksilver> Peaker: it's not hard to construct hashing algorithms which (provably) do not hit that case.
01:42:35 <quicksilver> Peaker: I've never heard that used as an argument against using hash tables.
01:42:37 <Peaker> adrian_: if you have a hash function where 1% of the hashes collide its also O(N)  (though it will have a very small constant)
01:42:53 <Axman6> mauke: i'm trying to decide if i hate you or should worship you: http://mauke.ath.cx/stuff/poly.html
01:43:00 <Peaker> quicksilver: I think its pretty common to use search trees instead of hash tables for the better worst case
01:43:05 <adrian_> peaker: that's rather hard to believe
01:43:07 <Peaker> quicksilver: in hard-real time, for example
01:43:19 <quicksilver> Peaker: Sure, but that's slightly different.
01:43:30 <quicksilver> Peaker: that's using search trees for the *predictability* of the time.
01:43:34 <adrian_> I'm looking for an efficient average case
01:43:46 <adrian_> with a sufficiently unlikely worst case
01:43:46 <quicksilver> Peaker: it's not because you can't prevent the worst case.
01:43:52 <Peaker> adrian_: I did say "make the worst case worse", not the average case :)
01:44:06 <quicksilver> adrian_: anyway, this is a serious distraction.
01:44:14 <Peaker> quicksilver: if you don't know much about the data you're going to have, how can you get a provably good hashing function?
01:44:35 <quicksilver> adrian_: the correct answer to your question is "You can't use a hashtable because Eq a does not give you enough information to construct a hash key"
01:44:37 <Peaker> adrian_: if you want it to use a hash, you can place a Hash restriction on the type
01:44:45 <quicksilver> adrian_ doesn't want to use a hash.
01:44:49 <quicksilver> This is a stupid conversation.
01:44:53 <quicksilver> Sorry, but it is.
01:45:08 <quicksilver> < adrian_> is there an efficient way to group stuff by equality without  having an ord constraint?
01:45:11 <quicksilver> that was the question.
01:45:16 <quicksilver> The answer is "No."
01:45:19 <vixey> hehe
01:45:23 <adrian_> ok
01:45:27 <quicksilver> Eq does not give enough information to efficiently group stuff.
01:45:30 <ivanm> quicksilver: surely you could with repeated passes...
01:45:32 <vixey> but if you wanted to implement it at all, you could use  rip :: Eq a => [a] -> ([a], [a])
01:45:35 <vixey> oops
01:45:36 <ivanm> oh, wait, _efficiently_
01:45:41 <vixey> rip :: Eq a => a -> [a] -> ([a], [a])
01:45:56 <vixey> so like  rip 1 [1,2,1,2] ~> ([1,1],[2,2])
01:46:10 <vixey> and probably unfoldr with it
01:46:13 <Peaker> quicksilver: I did not see that original question :)
01:46:18 <Peaker> quicksilver: I saw the followups
01:46:19 <quicksilver> Yeah, you can do repeated passes through the list, looking for other occurences of the first element.
01:46:30 <quicksilver> but that's O(n^2) of course.
01:46:36 <quicksilver> So, not 'efficiently'.
01:46:53 <quicksilver> adrian_: in practice, you really do want Ord to do much which is efficient.
01:47:03 <vixey> quicksilver, (but I suspect by efficiently, it was really meant: already exists in the Prelude)
01:47:10 <adrian_> I thought so
01:47:25 <jberg> if you want to make a webapp with haskell and mix in ajax, and it has to work on windows too, is that possible? can you use apache and some haskell library for linux/windows?
01:47:44 <quicksilver> or a function into some other type which has an Ord instance. (Which is what a hash function is)
01:47:46 <adrian_> jberg: we have hApps
01:48:12 <quicksilver> jberg: most natural ways to write a webapp in haskell would work on windows too.
01:48:12 <Axman6> " If Opera gets its way, new Windows computers in the EU will have either zero or five browsers installed on them." heh
01:48:24 <quicksilver> jberg: but what kind of idiot would run a web server on windows? ;)
01:48:29 <jberg> adrian_, is happs a webserver?
01:48:39 <Axman6> and web framework
01:48:44 <quicksilver> happs has its own http server but you don't have to use it, I think.
01:48:46 <adrian_> jberg: it runs your stuff, kinda like jboss
01:48:49 <jberg> quicksilver, hehe.. the people who want to run my app :)
01:49:03 <quicksilver> you can use it with an external http server instead if you want. At least I believe so?
01:49:22 <jberg> dont know what jboss is. but i need to be able to use some ajax as well
01:49:31 <quicksilver> jberg: haskell tends to be cross-platform unless you try pretty hard to make it not so.
01:49:43 <quicksilver> (e.g. by using functions from System.Posix, whichis not cross-platform)
01:49:54 <jberg> quicksilver, yea i guess.
01:50:04 <quicksilver> from the server side, ajax is nothign interesting.
01:50:10 <quicksilver> It's just more http requests.
01:50:18 <quicksilver> From the client side, well that's javascript not haskell :)
01:50:27 <quicksilver> So really, ajax makes no different at either end.
01:50:40 <jberg> quicksilver, hmm okay. but can happs handle those requests?
01:50:48 <adrian_> I remember some kinde of haskell -> javascript compiler?
01:51:31 <adrian_> jberg: afaik the webserver needs no knowledge of ajax
01:51:35 <quicksilver> jberg: Yes. They are no different.
01:51:44 <quicksilver> jberg: an http request is an http request.
01:51:59 <quicksilver> it makes no difference if it was initiated by a javascript call or a link clicked or a URL typed in.
01:52:12 <quicksilver> adrian_: yeah, there is some interesting work there.
01:52:20 <quicksilver> adrian_: I don't *think* it is was jberg is asking about though :)
01:52:57 <adrian_> I would be cool though
01:53:03 <adrian_> *it
01:53:11 <Peaker> how often do types have Eq but not Ord?  IMO Complex really can/should have Ord
01:53:31 <Axman6> how do you order complex numbers?
01:53:37 <Axman6> by magnitude?
01:53:38 <Peaker> Axman6: arbitrarily
01:53:48 <Axman6> real then imaginary?
01:53:52 <idnar> if you pick some arbitrary order, someone will want another order
01:53:55 <jberg> but would you recommend using happs as a standalone webserver or use it with apache?
01:53:56 <Peaker> Axman6: by real, then imaginary part, for example.  Just for things like having them as Keys to Maps/etc
01:54:09 <Axman6> :\
01:54:21 <Peaker> idnar: They can write their own comparison function then. the order just has to be consistent for there to be more utility than no ord at all
01:54:24 <quicksilver> Peaker: the problem is we use Ord for two things.
01:54:29 <quicksilver> Peaker: it's a bit annoying
01:54:38 <quicksilver> we want 'arbitrary ord' for efficient maps
01:54:44 <idnar> Peaker: there should... what quicksilver said
01:54:46 <quicksilver> but we want 'useful ord' for numbers.
01:54:58 <Peaker> quicksilver: I agree, but distinguishing them with different methods will cause code duplication
01:55:06 <quicksilver> and because complex is a number type, it's expected that if it supports ord it would be the 'useful type'
01:55:09 <Peaker> quicksilver: so we should just distinguish them with convention
01:55:10 <quicksilver> yeah.
01:55:16 <quicksilver> I don't see a nice solution.
01:55:23 <quicksilver> I can understand how the current situation has arisen.
01:55:39 <quicksilver> similarly you'd like Ord for IORef, STRef, and so on.
01:55:44 <quicksilver> occasionally you would, anyway.
01:55:53 <Axman6> you would?
01:55:53 <Peaker> those ones are harder as we discussed last time
01:56:00 <quicksilver> Axman6: not very often.
01:56:04 <pozic> quicksilver: http://paste.debian.net/26445/
01:56:09 <quicksilver> but occasionally you want to associate external data with them
01:56:10 <Axman6> what would you use them for perhaps?
01:56:12 <quicksilver> in a Map or similar
01:56:17 <quicksilver> or store a "seen list"
01:56:18 <quicksilver> etc etc
01:56:19 <Axman6> ah right
01:56:27 <quicksilver> Peaker: right.
01:56:29 <quicksilver> frustrating, though.
01:56:35 <quicksilver> I dont' see the right answer :)
01:56:41 <quicksilver> I see plenty of reasons why some answers aren't right.
01:57:00 <joma> is the association fo some operators (like $ and &&) not what you expect in Haskell?
01:57:06 <joma> diagonalMatrix m &&
01:57:07 <joma>                      (all (== True) $ map (== 1.0) $ mainDiagonal m)
01:57:17 <joma> why do i ahve to parenthesize then all expression?
01:57:17 <Peaker> quicksilver: you can build your own   data OrdIORed a = OrdIORef { counter :: Int, ioRef IORef a }
01:57:25 <vixey> joma, use  and  instead of  all (== True)
01:57:28 <Peaker> quicksilver: and have newOrdIORef that increases a global counter
01:58:04 <quicksilver> Peaker: yup.
01:58:09 <vixey> joma, (then use  all (== 1.0)  instead of  and . map (== 1.0))
01:58:10 <cnwdup> quicksilver: Is there a way in Haskell to order arbitrarily? I mean aside from a sane standard implementation but implement that manually for the type forall a. SomeClass a => a.
01:58:31 <Peaker> cnwdup: SomeClass=Ord?
01:58:39 <cnwdup> peaker: Nope
01:59:01 <quicksilver> pozic: so "process" wants to both read and write?
01:59:39 <pozic> quicksilver: yes
01:59:50 <quicksilver> pozic: then the type of process should be
01:59:53 <Peaker> joma: Use . for multiple compositions, not $   and as vixey said your all + map should just be all
02:00:11 <hugo___> hi
02:00:16 <quicksilver> "(MonadReader Int m, MonadWriter [String] m) => m a"
02:00:24 <quicksilver> pozic: and it doesn't have any 'run' or anything inside it.
02:00:32 <quicksilver> pozic: it just uses 'ask' and 'tell' whenever it wants to.
02:00:51 <pozic> quicksilver: ok, so I can use that to restrict the type?
02:00:56 <Peaker> joma: the reason the rhs of && has to be paren'd is because $ (and (.) which should replace it) have low precedence
02:01:13 <pozic> quicksilver: I don't want it to access other operations than those in MonadReader from RT.
02:01:19 <quicksilver> pozic: Yes. You declare teh capabilities of the monad you want
02:01:20 <Peaker> joma: if you use parens inside the expression instead of (.) and ($) you might avoid those parens on the outside
02:01:23 <quicksilver> pozic: ability to use 'ask' and 'tell'
02:01:37 <quicksilver> pozic: and that abstracts away from the actual implementation (the actual tower in use)
02:01:51 <quicksilver> pozic: enabling you to change the tower later, as long as you continue to provide the facilities.
02:02:38 <quicksilver> pozic: have you taken at  look at http://cale.yi.org/index.php/How_To_Use_Monad_Transformers ?
02:03:07 <pozic> quicksilver: but I do need to place the runWT than in the running of the complete tower.
02:03:36 <pozic> quicksilver: Yes, it's just that I don't use monad transformers that often.
02:04:03 <quicksilver> pozic: when you actually use process, you would do something like "runRT $ runWT $ process"
02:04:16 <quicksilver> pozic: except that's not quite right, because runRT takes a parameter
02:04:26 <quicksilver> pozic: normally you'd do "runMyMonad $ process"
02:04:57 <quicksilver> where newtype MyMonad a = MyMonad (ReaderT Int (Writer [String]) a)
02:05:21 <quicksilver> and runMyMonad appropriately.
02:06:02 <pozic> quicksilver: thank you, I also managed to get the scoped type variables thing to work without evil hacks, btw.
02:06:08 <quicksilver> woot :)
02:06:12 <quicksilver> \o/
02:06:19 <pozic> ^^
02:08:12 <pozic> quicksilver: no, there is one problem, because WT should contain a fresh StateT state every time it is being run.
02:08:30 <pozic> quicksilver: that's where the difficulty with the lifting comes from.
02:08:31 <jberg> does anyone remember that monad reader issue where someone solved a logic problem using only haskells typesystem? the problem was something like there are 5 houses and 5 persons of different nationalities who each has a different hobby etc and then you get information about some of it and you have to solve it blabla.. does anyone remember? :) not even sure it was that problem, but something similar
02:08:31 <quicksilver> WT doesn't contain a StateT. The way you wrote it.
02:08:41 <pozic> quicksilver: right, but the real thing does.
02:08:56 <pozic> quicksilver: and a lot of other cruft, naturally ;)
02:08:57 <quicksilver> just define your "run" primitve to supply the new default state
02:09:00 <quicksilver> :T runStateT
02:09:10 <quicksilver> :t runStateT
02:09:12 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
02:09:17 <Trollinator> can you give me a link to a good standard prelude reference?
02:09:29 <vixey> ?where report
02:09:29 <lambdabot> http://www.haskell.org/onlinereport/
02:09:32 <quicksilver> set the second parameter to your (fresh) default state
02:10:04 <quicksilver> Trollinator: what vixey said, and also http://www.haskell.org/ghc/dist/current/docs/libraries/base/Prelude.html
02:10:27 <pozic> quicksilver: I mean that when one "process" has run, it should not see the history of other processes (in particular the changing of variables in the StateT state parameter).
02:11:12 <Axman6> Trollinator: i've not a fairly nice printable version of the standard prelude if you want it
02:11:22 <pozic> quicksilver: that's why I wrote runWT inside runRT.
02:11:39 <Axman6> which can be found here (the site of the course i got it from) http://cs.anu.edu.au/Student/comp1100/haskell/TourOfPrelude.pdf
02:11:53 <Axman6> oh wow, my lecturer wrote it, ha
02:11:54 <pozic> quicksilver: the most easy solution would be to reinitialize everytime "process" ends.
02:12:18 <quicksilver> pozic: there is nothing to "reinitialize"
02:12:26 <Axman6> the last few pages are very useful indeed
02:12:27 <quicksilver> pozic: these aren't your ordinary mutable variables.
02:12:36 <quicksilver> pozic: there is no 'stored value' you need to 'wipe'.
02:12:48 <quicksilver> pozic: every time you call runStateT, you choose the initial value of the state.
02:13:03 <pozic> quicksilver: in the program "process" will be run many times within the same "run".
02:13:04 <quicksilver> you simple choose that appropriately, or write your helper 'run' function to always do so.
02:13:12 <quicksilver> pozic: Yes. That is no problem.
02:13:14 <quicksilver> There is no mutation.
02:13:17 <quicksilver> There is no mutable variable.
02:13:30 <quicksilver> You can call a State method as many times as you want - in multiple concurrent threads, if you choose.
02:13:48 <pozic> quicksilver: if process = modify (+1) and x = process;process, the variable is modified twice.
02:13:49 <quicksilver> Each is entirely independent, and runs with its own state, which you pass in in the 'run' call.
02:14:04 <quicksilver> pozic: yes, that is the purpose of (>>).
02:14:23 <quicksilver> pozic: but in (runStateT process 8) ; (runStateT process 9)
02:14:38 <quicksilver> pozic: they are entirely independent, and one was given an initial value of 8 and the other of 9.
02:14:59 <Trollinator> OK, i still can't find what i'm looking for
02:15:00 <pozic> quicksilver: yes, but we want process to have access to this reader parameter still.
02:15:10 <Axman6> Trollinator: what are you looking for?
02:15:21 <Trollinator> what is the "quot" function in the "Integral" class supposed to do?
02:15:22 <pozic> quicksilver: and the combination of these things is what makes it difficult.
02:15:54 <Axman6> :t quot
02:15:56 <lambdabot> forall a. (Integral a) => a -> a -> a
02:16:03 <Axman6> > quot 2 3
02:16:05 <lambdabot>   0
02:16:08 <Axman6> > quot 4 3
02:16:10 <lambdabot>   1
02:16:14 <Axman6> > quot 5 3
02:16:16 <lambdabot>   1
02:16:22 <Axman6> > quot 7 3
02:16:23 <lambdabot>   2
02:16:32 <Peaker> > map (`quot` 3) [-5..5]
02:16:34 <Axman6> Trollinator: looks like integer division
02:16:34 <lambdabot>   [-1,-1,-1,0,0,0,0,0,1,1,1]
02:16:43 <Peaker> > map (`div` 3) [-5..5]
02:16:44 <lambdabot>   [-2,-2,-1,-1,-1,0,0,0,1,1,1]
02:16:51 <Trollinator> integer division is `div`
02:17:04 <Peaker> quot and div differ in how they handle negative division
02:17:06 <adrian_> map (\x -> (quotRem x, divMod x)) [-5..5]
02:17:10 <pozic> quicksilver: so, I ideally want to run runWT like I did in the code I posted, but it should have access to this reader parameter (because it needs to have a fresh state every time).
02:17:15 <adrian_> > map (\x -> (quotRem x, divMod x)) [-5..5]
02:17:22 <Peaker> div rounds to lower abs value, quot to floor, I think
02:17:22 <lambdabot>       Overlapping instances for Show (a -> (a, a))
02:17:22 <lambdabot>        arising from a use ...
02:17:32 <Peaker> > map (quotRem &&& divMod) [-5..5]
02:17:34 <lambdabot>       Overlapping instances for Show (a -> (a, a))
02:17:34 <lambdabot>        arising from a use ...
02:17:36 <Trollinator> i see...
02:17:39 <Axman6> > map (\x -> (quotRem 3 x, divMod 3 x)) [-5..5]
02:17:41 <lambdabot>   [((0,3),(-1,-2)),((0,3),(-1,-1)),((-1,0),(-1,0)),((-1,1),(-2,-1)),((-3,0),(...
02:17:54 <Peaker> > map (flip (quotRem &&& divMod) 3) [-5..5]
02:17:56 <lambdabot>   Couldn't match expected type `b -> c'
02:18:00 <cnwdup> :t (&&&)
02:18:02 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
02:18:10 <Peaker> > map (((`quotRem` 3) &&& (`divMod` 3))) [-5..5]
02:18:12 <lambdabot>   [((-1,-2),(-2,1)),((-1,-1),(-2,2)),((-1,0),(-1,0)),((0,-2),(-1,1)),((0,-1),...
02:18:15 <cnwdup> Am I the only one who finds Arrow types hard to read. \-:
02:18:21 <cnwdup> s/.$/?/
02:18:26 <Trollinator> what if i don't have negative numbers?
02:18:34 <joma> hmm after coding a few weeks in lisp(Clojure) and now a few days in Haskell I do really appreciate the static typing. it catches a lot of dumb bugs and is not in the way like Javas
02:18:42 <Axman6> cnwdup: i can't understand them either :\
02:18:59 <joma> vixey: eheh yes ofc i dont knwo what i was thinking
02:19:58 <quicksilver> Trollinator: then it doesn't really matter which you use
02:20:08 <quicksilver> Trollinator: although people tend to use div
02:20:20 <Trollinator> ok
02:21:08 <Trollinator> > rem 5 3
02:21:09 <lambdabot>   2
02:21:12 <Trollinator> > rem 5 1
02:21:14 <lambdabot>   0
02:21:30 <joma> what does it matter if i use . or $ really?
02:21:54 <jberg> can someone explain what seq is? does it evaluate the argument to a function no matter what? so you get a strict function?
02:22:06 <Zao> (.) is handy when you want to pass your composed function around.
02:22:53 <ivanm> jberg: it evaluates the LHS, throws it away and then evaluates the right
02:23:14 <ivanm> typically, you use it something like this: ... let x = f y in x `seq` g x
02:23:29 <ivanm> that forces the evaluation of (f y)
02:23:38 <quicksilver> (only as far as the first constructor, that is)
02:23:41 <Peaker> in that typical case, g $! (f y)  right?
02:23:44 <ivanm> quicksilver: true
02:23:52 <joma> because . can be used without an argument right?
02:23:54 <ivanm> note that doing something like: (f x) `seq` (f x) just wastes CPU cycles
02:23:55 <joma> or i mean declared
02:24:24 <ivanm> joma: yes.... $ is typically used to end a chain of (.) usages
02:24:34 <ivanm> e.g. f . g . h $ x
02:24:37 <jberg> ivanm, hmm.. i dont see how it evaluates f y.. is seq defined internally or in haskell?
02:24:43 <ivanm> jberg: internally
02:24:45 <ivanm> @src seq
02:24:46 <lambdabot> Source not found. Just try something else.
02:25:00 <joma> like: sumAll m = sum $ DA.elems $ repr m VS sumAll m = sum . DA.elems $ repr m, doe sit matter?
02:25:18 <ivanm> jberg: it forces x to be evaluated to the outermost constructor, and then calls g x
02:25:25 <ivanm> joma: personally taste, really
02:25:45 <ivanm> I myself find $ too intrusive.... it sticks out like a sore thumb IMHO ;-)
02:26:14 <jberg> ivanm, okay, so if you need x to be evaluated in f x you do x `seq` f x ?
02:26:22 <ivanm> jberg: yup
02:26:22 <Axman6> joma: (.) is usually prefered when performing function composition
02:26:35 <jberg> ivanm, okay thanks
02:26:50 <ivanm> note, however, that if you have that f :: a -> [b], then seq will only evaluate f until it can tell that it is a list
02:26:59 <ivanm> it won't evaluate all the elements in the list
02:28:12 <jberg> ivanm, i see
02:28:20 <pozic> quicksilver: so, is there any way to make it do what I want: fresh states every time "process" is being run, but the reader parameter coming from outside?
02:28:47 <jberg> why would you do map ($ 0) xs? http://www.haskell.org/onlinereport/basic.html im reading strict evaluation
02:29:21 <ivanm> jberg: if xs is a list of functions of type (Num a) => a -> b
02:29:41 <ivanm> > map ($ 0) [id, pred, succ]
02:29:42 <lambdabot>   [0,-1,1]
02:29:52 <jberg> ivanm, ah
02:29:53 <quicksilver> pozic: sure.
02:29:54 <ivanm> jberg: ^^ it evaluates each function with 0 as its argument
02:30:11 <quicksilver> pozic: run process each time with a fresh state but take the parameter from the outside ;)
02:30:32 <jberg> ivanm, yep thanks
02:30:36 <quicksilver> runProcess = do { r <- ask; runMyMonad process r 0; }
02:30:47 <quicksilver> where '0' stands in for your fresh state
02:30:55 <quicksilver> and 'r' has obviously been drawn from the environment.
02:31:40 <pozic> quicksilver: I thought using runMyMonadT and then lift in process would work.
02:32:29 <pozic> quicksilver: or do you think that's just a bad solution?
02:33:29 <quicksilver> pozic: that is just no what 'lift' means.
02:33:38 <quicksilver> Tehre is no way to access the enclosing environment.
02:33:44 <quicksilver> That's just not something possible in haskell.
02:33:49 <quicksilver> that's a break of abstraction, or somethin.
02:34:02 <quicksilver> functions only have access to variables in scope
02:35:27 <Trollinator> is there a nicer way to do "head (reverse foo)"
02:35:28 <Trollinator> ?
02:35:37 <cnwdup> trollinator: last
02:35:49 <Trollinator> makes sense.
02:36:04 <joma> instance Num (Matrix m)
02:36:04 <joma>     where
02:36:20 <Workybob> Trollinator: similiraly init = tail . reverse
02:36:24 <joma> can i add anything there? like \ or there are predefined thinsg that should be in num?
02:36:59 <Workybob> joma: the operations in Num are predefined
02:37:00 <joma>  `/' is not a (visible) method of class `Num'
02:37:13 <Workybob> you can ofc add a function (/) :: Num a => a -> a -> a
02:37:23 <Workybob> but not to the class
02:37:32 <cnwdup> joma: (/) ist defined in the Fractional class.
02:37:38 <joma> and lets say i can have my own instance Numstuff where i d such things? exactly what is Num? a typeclass?
02:37:53 <Workybob> joma: Num is a type class yes
02:38:04 <Trollinator> :(
02:38:06 <Workybob> you *probably* don't want to add a new one
02:38:09 <Trollinator> i don'
02:38:11 <Workybob> not certain though
02:38:18 <Trollinator> t find anything in those standard prelude references.
02:38:20 <Axman6> @check \xs -> not . null xs ==>  init xs == tail . reverse xs
02:38:21 <lambdabot>   Couldn't match expected type `a -> Bool'
02:38:27 <cnwdup> trollinator: What are you looking for?
02:38:29 <Axman6> :t (==>)
02:38:31 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
02:38:47 <Axman6> @check \xs -> not . null xs ==> (init xs == tail . reverse xs)
02:38:48 <lambdabot>   Couldn't match expected type `a -> Bool'
02:38:49 <Workybob> Axman6: reverse $ xs
02:38:55 <Axman6> @check \xs -> not . null xs ==> (init xs == tail . reverse $ xs)
02:38:56 <lambdabot>   Couldn't match expected type `a -> Bool'
02:38:59 <Trollinator> cnwdup: just a function to get the x-th element in a list.
02:39:00 <Axman6> bah
02:39:05 <cnwdup> trollinator: (!!)
02:39:05 <Axman6> @check \xs -> not . null $ xs ==> (init xs == tail . reverse $ xs)
02:39:07 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Bool'
02:39:07 <Axman6> of course
02:39:17 <Trollinator> > [1,2,3] !! 1
02:39:18 <Axman6> @check \xs -> (not . null $ xs) ==> (init xs == tail . reverse $ xs)
02:39:19 <lambdabot>   2
02:39:19 <lambdabot>   Couldn't match expected type `[a]'
02:39:26 <Trollinator> oO
02:39:26 <Workybob> Axman6: parens round init xs
02:39:31 <Workybob> and tail . reverse $ xs
02:39:34 <cnwdup> trollinator: Apparently it starts with 0.
02:39:36 <Axman6> fuck it >_<
02:39:42 <cnwdup> > [1..3] !! 0
02:39:43 <lambdabot>   1
02:39:45 <Trollinator> cnwdup: i know, that's what i had expected.
02:39:58 <cnwdup> trollinator: Ah, okay. Interpreted it as confusion.
02:40:07 <Workybob> Trollinator: of note, if you're using (!!) you're probably using the wrong type with a list
02:40:21 <Trollinator> Workybob: why? is it O(n)?
02:40:27 <Workybob> yes
02:40:33 <Workybob> [a] is a linked list
02:41:00 <Trollinator> so what would the alternative be?
02:41:16 <Workybob> an array, a set, or posibly a map
02:41:33 <cnwdup> trollinator: I think a Map has O(log n) lookup and an immutable array has O(1). Not quite sure, though.
02:41:35 <Workybob> it may also just be that you're using the wrong algorithm
02:42:00 <Axman6> cnwdup: type ax<tab> and see what happens
02:42:02 <Trollinator> do all those list operations work with arrays, too?
02:42:14 <Trollinator> map, zipWith and all that.
02:42:15 <Axman6> Trollinator: different operators usually
02:42:17 <cnwdup> axman6: Hum?
02:42:18 <Axman6> no
02:42:36 <Axman6> cnwdup: you're typing out people's nicks aren't you?
02:42:39 <Trollinator> well, i guess i'll just ignore efficiency then.
02:42:56 <cnwdup> axman6: Nope. *g*
02:43:04 <Trollinator> for now.
02:43:12 <Axman6> your irc client fails then :P
02:43:23 <cnwdup> axman6: Because its tab-completing in lower case?
02:43:29 <Axman6> yeah
02:43:43 <Axman6> axman6 isn't my nick Axman6 is
02:44:30 <Trollinator> is "length foo" also O(n)?
02:44:30 <cnwdup> Axman6: I'll try to remember that. ( ;
02:44:40 <Axman6> Trollinator: yes
02:44:59 <pozic> quicksilver: ok, for the reader monad that approach works, but is note as nice as I would have wanted it to be, but for MonadRandom that doesn't work, because there is no way to get the current generator.
02:45:03 <Trollinator> good to know.
02:45:21 <quicksilver> pozic: yes, that is a liability in the MonadRandom interface.
02:45:30 <quicksilver> pozic: you will need a different approach there.
02:45:47 <quicksilver> you should be able to 'unwrap' the state part of "process"
02:45:56 <quicksilver> so that what is left is a RandomT monad
02:46:07 <quicksilver> which you can just directly place into the enclosing context.
02:46:53 <joma> hat lookup does Data.Array have?
02:47:12 <joma> O(log(n) or O(1)?
02:47:13 <Axman6> O(1) i think, i could be wrong though
02:47:47 <cnwdup> joma: O(1) since they're immutable
02:48:08 <Axman6> lists are immutable  too...
02:48:24 <pozic> quicksilver: I don't understand what you mean by 'unwrap' in this context.
02:55:04 <quicksilver> pozic: suppose process :: StateT s (RandomT Identity a)
02:55:12 <quicksilver> pozic: reasonably?
02:56:51 <pozic> quicksilver: ok
02:57:12 <quicksilver> pozic: then "runStateT process 0" :: RandomT Identity a
02:57:17 <quicksilver> erm
02:57:18 <Axman6> @users
02:57:19 <lambdabot> Maximum users seen in #haskell: 653, currently: 592 (90.7%), active: 14 (2.4%)
02:57:19 <quicksilver> try again
02:57:23 <quicksilver> pozic: then "runStateT process 0" :: RandomT Identity (s,a)
02:57:27 <trofi_> :\
02:57:31 <quicksilver> so you've "unwrapped" the state part.
02:57:55 <quicksilver> and you can then simply put that into your outer context
02:58:02 <quicksilver> where it will combine with the other monady stuff.
02:58:08 <pozic> quicksilver: and then I can simply call getRandomR etc?
02:58:42 <hynek> map (\p -> hi p) channel
03:00:08 <Axman6> hynek: map hi channel ;)
03:00:38 <hynek> Axman6:  true, i wanter first use output, but realized i can'T use inpure functions ;)
03:01:11 <Axman6> heh
03:02:41 <pozic> quicksilver: but then I need an instance MonadRandom(InnerT ), it looks likes I am going in circles. :/
03:06:40 <quicksilver> pozic: I don't think you do, no.
03:07:34 <pozic> quicksilver: it runs, but I get the same random number over and over.
03:08:20 <quicksilver> pozic: that ought to depend what random seed you pass to the outer function: the whole thing.
03:08:50 <pozic> quicksilver: I derived the MonadRandom instance for the InnerT, but I have no idea what exactly it is calling. It should call the outer one.
03:09:19 <quicksilver> I believe one of the problems is exactly what "inner" and "outer" mean.
03:09:42 <quicksilver> In one sense, if you have FooT (BarT m), then we think of Foo as the outer transformer and bar as the inner transformer
03:09:52 <quicksilver> in another sense if you have f = .... g x ... g x ...
03:10:00 <quicksilver> then f is the outer function and g is the inner function.
03:10:05 <quicksilver> however, these are unrealted things.
03:10:09 <quicksilver> and I'm not always sure what you mean.
03:10:16 <pozic> quicksilver: yes, I am going in circles, since now I need this MonadRandom Identity instance again...
03:11:38 <quicksilver> then you're doing something wrong.
03:11:44 <quicksilver> ;)
03:11:55 <quicksilver> You don't need a MonadRandom Identity instance if process has type RandomT Identity
03:12:06 <quicksilver> because you have a MonadRandom instance for RandomT Identity.
03:16:53 <pozic> quicksilver: in the previous version I had a Monadplus m contraint on the process function, do I now need to make that MonadPlus(RandT g m)?
03:17:08 <pozic> quicksilver: it's hardly elegant that way
03:17:46 <joma> anyone can post a short snippt of Agda, Isabelle or ProofGeneal code where you rove an algorithm to be correct so I can see what it looks like?
03:18:32 <paolino> is accum  the function for modifying elements of an IArray using the elements already present ?
03:18:32 <drdozer> anyone here got some probabilities/stats smarts?
03:18:34 <dolio> What sort of algorithm? Anything interesting wouldn't be short.
03:18:42 <drdozer> I've got thinking about the relationship between conditional probabilities and lambdas, and how this could be encoded in Haskell
03:19:03 <dolio> That reminds me, I should finish proving my insertion sort correct...
03:20:13 <joma> what relationship drdozer?
03:20:31 <joma> dolio: id love to see your proof of insertionsort
03:21:07 <dolio> Yeah, well, I would to. But it isn't easy. Primarily because agda quickly starts eating up lots of memory.
03:21:11 <dolio> ls
03:21:20 <joma> why?
03:21:26 <joma> would it eat upa  lot of memory?
03:21:40 <joma> does it bruteforce check?
03:21:48 <drdozer> joma: p(a|b) needs something of the type p(b) to reduce it to a probability
03:22:13 <Spark> all theorem provers are essentially brute force
03:22:37 <dolio> Proofs require, essentially, doing runtime-like evaluation in the compiler.
03:22:45 <dolio> And it doesn't seem too good about garbage collecting that stuff.
03:22:57 <dolio> So each time you reload a file to check more of a proof, it eats more memory.
03:23:08 <Spark> ah is it just checking a proof
03:23:11 <dolio> Agda isn't exactly the most optimized program out there.
03:23:12 <Spark> or trying to find a proof
03:23:36 <dolio> It isn't searching for proofs, no.
03:23:56 <Spark> i did some stuff with isabelle a while ago
03:24:22 <dolio> Yeah, I can't speak about Isabelle or Coq. Presumably they do a bit better, since they've been around longer.
03:25:38 <Spark> isabelle is a bit of a horrible hack though
03:25:59 <dolio> Anyhow, I have some lemmas that go towards proving the insertion sort correct. I could paste those somewhere...
03:26:10 <dolio> Evidently hpaste is down.
03:26:53 <joma> so can you restrict yourself to a certain coding style to make the proving easier for the program?
03:26:57 <drdozer> joma: p(a|b) seems to have a relationship with p(a,b) that is analogus to currying
03:27:08 <joma> is it like prolog?
03:27:20 <joma> kind of? i mean proofchecking
03:27:44 <Spark> it's a bit like beating yourself to death with a spade
03:27:55 <dolio> http://paste.lisp.org/display/73914
03:28:05 <dolio> So, there's some code.
03:28:31 <dolio> insert-lemma proves that if a list is sorted, then the first element is the minimum element.
03:30:34 <Spark> i like the definition of Sorted
03:31:06 <pozic> quicksilver: ok, I made a small example and indeed there it works.
03:36:01 <quicksilver> pozic: :)
03:36:16 <quicksilver> pozic: I hope you can find the critical difference between the small and the large
03:39:42 <dcoutts> augustss: re cabal's --package-db= flag, did you get it working?
03:40:15 <dcoutts> augustss: or is the problem just the massive output of cabal configure --help which makes it hard to find the right flag?
03:40:32 <dcoutts> it needs to be divided into sections and perhaps simplified
03:44:56 <nikki93> Hey guys! ;-)
03:45:07 <Axman6> oh no
03:45:09 <Axman6> >_>
03:45:12 <Axman6> kidding!
03:48:57 <nikki93> Axman6: >_<
03:50:07 <nikki93> Axman6: For timewasting, here's a video I made: http://www.youtube.com/watch?v=U9doRd2TjxA
03:50:16 <Axman6> of what?
03:51:11 <nikki93> Axman6: Of stick-figure fighting. :P
03:52:46 <quicksilver> nikki93: did you make it with haskell code?
03:54:23 <Axman6> heh, nice
03:56:21 <Trollinator> how do i flip a pair?
03:57:21 <Trollinator> i. e. is there a function in the prelude equivalent to \(x,y) -> (y,x)
03:57:21 <Twey> @hoogle (a, b) -> (b, a)
03:57:22 <trofi_> @hogle :: (a,b) -> (b,a)
03:57:22 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
03:57:22 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
03:57:22 <lambdabot> Control.Arrow (<<<) :: Arrow a => a c d -> a b c -> a b d
03:57:22 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
03:57:22 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
03:57:24 <lambdabot> Control.Arrow (<<<) :: Arrow a => a c d -> a b c -> a b d
03:57:34 <Twey> 'pparently not
03:57:47 <trofi_> @pl \(a,b) -> (b,a)
03:57:47 <lambdabot> uncurry (flip (,))
03:57:57 <byorgey> Trollinator: there isn't, actually
03:58:02 <Trollinator> OK.
03:59:58 <joma> would it make sense to define my own class for Matrix? is a haskell-class like an interface in Java? so I define some operations on a Matrix like: add,sub,mul,inv,svd,eigenv etc?
04:00:23 <Axman6> joma: do you need a class for it?
04:01:14 <joma> nikki93: those are friggin awesome videos
04:01:40 <quicksilver> joma: normally you don't define a class for something like that.
04:01:45 <quicksilver> you just define a type, and some functions.
04:01:55 <quicksilver> Rule 1: If you think you want a class, you don't. Sorry.
04:02:24 <Zao> quicksilver: Object obsessed programming ftw.
04:02:33 <Twey> quicksilver: I disagree
04:02:53 <joma> nikki: you should amke a game out of it for Android or iphone.
04:03:16 <joma> lol
04:03:18 <quicksilver> Twey: There are reasons you might want to make a Matrix class. joma has not given any indication those reasons apply to him.
04:03:22 <Twey> quicksilver: I wish every type were automatically a typeclass :(
04:03:26 <joma> i only need subtract and branch right?
04:04:08 <pozic> quicksilver: thx and it works :)
04:04:09 <Twey> It's irritating to define, say, a String-compatible type and then have to redefine *every* operation on it
04:04:25 <Twey> And not only that, but have to give them different names too
04:04:59 <quicksilver> pozic: hurrah.
04:05:08 <quicksilver> Twey: I think you are programming haskell poorly.
04:05:20 <quicksilver> there is in my experience very rarely a need for a "StringLike" class.
04:05:27 <quicksilver> there is a ListLike class on hackage, which nobody uses.
04:05:33 <quicksilver> nobody uses it because it is, in fact, useless.
04:05:48 <Twey> Because we have Traversible, Foldable, &c.?  :-P
04:06:05 <quicksilver> they are much more interesting that StringLike would be.
04:06:09 <Twey> Er, Traversable
04:06:14 <quicksilver> They actually abstract over a useful oncept.
04:06:24 <Twey> quicksilver: Well, you could use, for example, bytestrings
04:06:29 <quicksilver> I say again: If you think you want a class, you don't.
04:06:40 <quicksilver> Overuse of typeclasses is one of the main sources of confusion for beginner haskell programmers.
04:06:47 <quicksilver> typeclasses are for overloading, and not anything else.
04:07:13 <osfameron> and for interface inheritance, no?
04:07:22 <Twey> You know how you've got all these string functions... then the bytestrings comes along and have to reimplement all of them?
04:07:45 <Twey> Even down to things like Parsec
04:07:52 <quicksilver> Twey: that's because they're all different.
04:08:02 <quicksilver> Twey: bytestring has different complexity in 100 different ways.
04:08:05 <dolio> Parsec works with both strings and bytestrings.
04:08:09 <Twey> It does
04:08:10 <quicksilver> You *do* have to reimplement algorithms to use them usefully.
04:08:12 <Twey> By reimplementing everything
04:08:17 <Twey> Hmm
04:08:39 <pozic> Twey: the lazy semantics are not the same, AFAIK.
04:08:50 <quicksilver> it's nearly pointless specifying a common interface if you can't specify common performance constraints.
04:08:52 <pozic> Twey: so, the code won't do the same.
04:08:55 <Twey> 'kay then.
04:09:03 <quicksilver> Otherwise someone using the interface on the wrong type gets something not useful.
04:09:16 <quicksilver> what you can do is indicate useful parts which *do* have common performance characteristics
04:09:27 <quicksilver> Like "grab a bit off the front of the stream"
04:09:35 <quicksilver> which is essentially all you need to implement a parser
04:09:39 <Twey> I'd still like a way to say 'this type can be used anywhere a String can', though.
04:09:39 <quicksilver> and that would be a useful typeclass
04:09:42 <Twey> Aye
04:09:46 <quicksilver> GrabTheFrontBitsOff s
04:09:52 <Twey> Heh
04:10:04 <quicksilver> Twey: you do that by implementing an efficiently lazy 'toString' method.
04:10:06 <quicksilver> that is the lazy way.
04:10:14 <Twey> f :: (FrontBitGrabbable a, Bit b) => a -> b
04:10:19 <quicksilver> you can put 'toString' into a Stringable class if you like.
04:10:25 <quicksilver> just for the purpose of overloading toString
04:10:32 <quicksilver> (that's fine : overloading is what typeclasses are for)
04:10:34 <Twey> quicksilver: That's a nice idea
04:10:56 <quicksilver> Foldable already is 'Stringable' modulo some kind constraints.
04:11:02 <trofi_> :t toException
04:11:03 <lambdabot> Not in scope: `toException'
04:11:12 <quicksilver> Foldable f => toList :: f Char -> String
04:12:20 <Twey> http://www.haskell.org/haskellwiki/Foldable_and_Traversable  Sequences recommended over lists?  o.@
04:14:19 <quicksilver> Twey: I wrote that page in fact.
04:14:33 <quicksilver> Twey: now I look back at it, out of context that sentence doens't really explain itself well.
04:14:42 <quicksilver> Twey: they are an efficient alternative to lists in certain cases, I mean.
04:14:52 <quicksilver> Twey: e.g. fast access to the last element, fast append, etc.
04:15:06 <Twey> Ah
04:15:29 <quicksilver> normally it's access to both ends in my experience
04:15:35 <quicksilver> (is when I stop using lists and switch to Seq)
04:15:40 <quicksilver> e.g. a simple minded queue.
04:16:04 <Twey> Yeah, that's usually when I've used it
04:20:30 <h0tzenpl0tz> hello, why is putChar  -> IO (), whats the purpose of the empty tuple?
04:20:55 <trofi_> it does not return any value
04:21:00 <quicksilver> h0tzenpl0tz: returns no value of interest.
04:21:00 <kmeyer> h0tzenpl0tz: the computation doesn't have any meaningful result
04:21:09 <quicksilver> () is a placeholder for 'no interesting information here'
04:21:13 <kmeyer> what he said
04:21:27 <trofi_> :t ()
04:21:29 <lambdabot> ()
04:21:42 <h0tzenpl0tz> and why exactly () for non-interesting? is it the only "type" to have 2 values? () and _|_ ?
04:21:53 <trofi_> > ()
04:21:55 <lambdabot>   ()
04:21:56 <trofi_> > undefined
04:21:57 <lambdabot>   * Exception: Prelude.undefined
04:22:11 <trofi_> > length [()]
04:22:13 <lambdabot>   1
04:22:24 <Deewiant> ?src ()
04:22:25 <lambdabot> data () = ()
04:22:30 <Cale> h0tzenpl0tz: Well, it's the standard type with 2 values in that sense.
04:22:31 <pozic> h0tzenpl0tz: you can also use data X = X
04:22:36 <daf> h0tzenpl0tz: I think it's the only stan... what Cale said
04:22:38 <trofi_> > map (const ()) [1,2,3]
04:22:39 <lambdabot>   [(),(),()]
04:22:41 <h0tzenpl0tz> k, thank you alot
04:22:47 <Twey> :t Void
04:22:49 <lambdabot> Not in scope: data constructor `Void'
04:22:53 <Twey> Er
04:22:56 <Twey> @info Void
04:22:57 <lambdabot> Void
04:23:01 <Twey> Why don't we use IO Void?
04:23:10 <quicksilver> because Void isn't haskell 98
04:23:12 <Twey> Ah
04:23:13 <trofi_> ()  
04:23:20 <trofi_> oops
04:23:22 <Twey> Heh
04:23:25 <Twey> Wrong layout
04:23:28 <quicksilver> sometimes we like to pretend haskell has a total sublanguage
04:23:28 <trofi_> yep
04:23:37 <trofi_> () is shorter
04:23:41 <Twey> 's true
04:23:42 <quicksilver> and Void wouldn't exist in that sublanguage
04:23:47 <quicksilver> but m () would.
04:23:57 <daf> what is Void?
04:23:58 <Twey> Does anything actually use Void?
04:24:03 <Twey> daf: A type with no constructors
04:24:06 <quicksilver> daf: the type with no values at all.
04:24:08 <trofi_> > Void
04:24:10 <lambdabot>   Not in scope: data constructor `Void'
04:24:17 <Twey> :t undefined :: Void
04:24:19 <lambdabot> Not in scope: type constructor or class `Void'
04:24:22 <quicksilver> (except _|_)
04:24:24 <Twey> Eh
04:24:32 <Twey> :-\
04:24:50 <Twey> What's that all about?
04:24:59 <quicksilver> values of type (() -> a) are just values of type a.
04:25:01 <trofi_> :t (error ())
04:25:02 <lambdabot>     Couldn't match expected type `[Char]' against inferred type `()'
04:25:02 <lambdabot>     In the first argument of `error', namely `()'
04:25:08 <quicksilver> there is only one value of type (Void -> a)
04:25:14 <quicksilver> this makes () more useful in >>= than Void
04:25:17 <quicksilver> theoretically at least.
04:25:18 <trofi_> :t (error "hi") :: ()
04:25:19 <lambdabot> ()
04:25:24 <quicksilver> In haskell it doesn't matter, I don't think.
04:25:26 <Twey> Ah
04:25:37 <Twey> But... 'type constructor or class Void'?
04:26:01 <trofi_> @inctanceof ()
04:26:01 <lambdabot> Unknown command, try @list
04:26:06 <trofi_> @instanceof ()
04:26:07 <lambdabot> Couldn't find class `()'. Try @instances-importing
04:26:19 <Trollinator> is there a dropWhile from the back?
04:26:28 <trofi_> reverse.dropWhile
04:26:35 <trofi_> flip it
04:26:46 <Trollinator> i. e. reverse.(dropWhile foo).reverse
04:27:04 <joma> quicksilver: http://cpp.ninjacodemonkeys.org/5051 , im just trying to understand how type classes worj there, but why doeesnt it work but compile?
04:27:49 <Twey> Argh, require spaces around . *please*
04:27:58 <Axman6> heh
04:28:09 <quicksilver> joma: beacuse it doesn't know what type "10" and "20" are.
04:28:14 * Axman6 adds another, not so different example to http://www.haskell.org/haskellwiki/Monad/ST
04:28:18 <quicksilver> joma: try f (10 :: Int) (20 :: Int)
04:28:22 <quicksilver> joma: that should work.
04:28:31 <Axman6> i need more simple ST examples, ones that don't use lists :\
04:28:35 <Axman6> oh, fibs!
04:28:36 <dolio> There are multiple values of type Void -> a (for particular as) in Haskell.
04:28:45 <dolio> Since you can do: \_ -> v
04:29:19 <Cale> In fact, just f 10 20 :: Int  should work fine
04:29:30 <quicksilver> dolio: yeah, that's what I was alluding to
04:29:38 <quicksilver> dolio: IMO this makes Void a bit useless in haskell
04:29:51 <quicksilver> dolio: but the idea of Void is still useful for thought/discussion.
04:30:00 <Cale> joma: Because of the ambiguity surrounding numeric literals, the standard Num class has a special defaulting rule which normally saves you this trouble when working with Integer values.
04:30:00 <Twey> @hoogle Void
04:30:00 <dolio> At the very least, it's not the same as Void in a language without bottom.
04:30:01 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
04:30:07 <Twey> @hoogle Void -> a
04:30:07 <Cale> (or Doubles)
04:30:08 <lambdabot> Warning: Unknown type Void
04:30:08 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
04:30:08 <lambdabot> Prelude id :: a -> a
04:30:17 <Twey> Unknown type?
04:30:33 <PeakerWork> Cale: unless you use -Wall
04:32:02 <dolio> Well, I figured out why I quit my proof of correctness for insertion sort...
04:32:28 <nikki93> Speaking of void, void-returning-functions don't make sense in Haskell do they?
04:32:34 <joma> http://cpp.ninjacodemonkeys.org/5052
04:32:37 <nikki93> I mean, a function IS an expression that gets evaluated.
04:32:43 <nikki93> Nothing to return etc.
04:33:17 <dolio> I'm using one of the lemmas that wants a proof that "insert k (y :: zs) == e :: e' :: es", and despite the fact that I match on "insert k (y :: ys)" with the pattern "e :: e' :: es", I can't figure out how to conjure up such a proof.
04:33:26 <dolio> Even though they're by-definition equal.
04:34:02 <Axman6> nikki93: well ou can look at returning () as void
04:34:14 <quicksilver> nikki93: correct.
04:34:22 <quicksilver> nikki93: f :: a -> () is not very useful.
04:34:37 <nikki93> quicksilver: I see.
04:34:39 <trofi_> :t seq
04:34:39 <quicksilver> nikki93: because it only has two choices (1) loop forever (2) return ()
04:34:40 <lambdabot> forall a t. a -> t -> t
04:34:46 <quicksilver> nikki93: however, f :: a -> m () is useful.
04:34:48 <Axman6> f :: a -> IO () slightly more useful
04:34:53 <quicksilver> nikki93: because the 'm' may do quite a lot.
04:35:16 <quicksilver> and sloppily we sometimes call f :: a -> m () as "returning ()"
04:35:25 <quicksilver> which is an abuse of language.
04:35:28 <kmeyer> yes.
04:35:30 <quicksilver> but convenient.
04:35:34 <kmeyer> really it's a function that returns a computation in a monad
04:35:41 <Cale> :)
04:36:13 <joma> dolio: if it is that hard to prove a program correct mechanically, how much furure does it have then?
04:37:04 <dolio> So, your question is predicated on "it's hard now in its infancy, so it will be hard forever"?
04:37:19 <joma> :)
04:37:22 <Cale> dolio: Man, I misread :: as "has type" for a moment there.
04:37:33 <joma> yes a common but stupid predicate
04:37:45 <quicksilver> Cale: me too.
04:37:52 <quicksilver> Cale: I read it four times and was none the wiser :)
04:37:58 <joma> just asking,
04:38:12 <kmeyer> what is it actually?
04:38:18 <quicksilver> :
04:38:20 <dolio> Vector cons.
04:38:22 <Cale> kmeyer: Some languages swap : and ::
04:38:23 <kmeyer> ah
04:38:38 <kmeyer> wait, and a vector differs from a list how?
04:38:52 <dolio> It's size is part of its type.
04:39:03 <kmeyer> so cons-ing a vector means a resizing?
04:39:17 <quicksilver> well cons-ing a vector returns a new value of a different type
04:39:24 <kmeyer> er, right.
04:39:32 <dolio> _::_ : {a : Set} {n : Nat} -> a -> Vec a n -> Vec a (succ n)
04:39:49 <Cale> dolio: I'm not sure that I understand what you're trying to prove... that the expression consisting of the pattern matched by a term is equal to that term?
04:39:58 <Cale> (inside a case?)
04:40:52 <Twey> Everyone knows that '::' is the paamayim nekudotayim!
04:40:53 <quicksilver> Cale: I think he's trying to prove that insert k (y :: zs) has length at least 2.
04:41:12 <Cale> ah... that can't be so hard, can it?
04:41:14 <quicksilver> Cale: so it can definitely be pattern matched against e :: e' :: es.
04:42:22 <Cale> If that really is hard, I would definitely consider it a design flaw in the formal system of proof :)
04:42:36 <joma> Cale: you have a proof you can show me of a short haskell program?
04:42:50 <Cale> joma: I could write one up.
04:43:27 <dolio> The problem is that I split out part of the proof into a lemma, and pass the lemma an equality between two terms that so that it can unify two terms that, if I left it in the larger proof, would be unified simply due to dependent pattern matching.
04:43:57 <dolio> But I can't create the proof of equality from within the context of the match.
04:44:04 <dolio> Because the types aren't getting refined right.
04:44:14 <dolio> Or something.
04:44:34 <Cale> dolio: So basically a strange technical issue? :)
04:44:49 <dolio> I think it means I've structured my proof totally wrong. :)
04:45:49 <Raevel> wow, it takes a while to install cabal-install on ubuntu :-( complains about a lot of missing packages and stuff
04:45:51 <nikki93> Anyone used Qt?
04:46:01 <Raevel> perhaps ill save my bash_history
04:46:17 * Twey has used Qt, but not in Haskell.
04:46:47 <nikki93> Twey: How is it? I've used wxWidgets, didn't like it much.
04:47:09 <CakeProphet> dolio:  would it be easier to proof that the length couldn't be less than 2?
04:47:14 <whoppix> nikki93, Qt is nice, but its MOC (not plain C++, it needs a preprocessor).
04:47:31 <whoppix> nikki93, but I like the API, Its well structured and easy to use.
04:47:32 <dolio> It's not about proving their length. I already know their length.
04:47:32 <nikki93> whoppix: Wait... So you have to run your code through some app?
04:47:38 <Twey> nikki93: It's nice
04:47:42 <Twey> For C++, yes
04:47:42 <whoppix> nikki93, yes, the meta object compiler
04:47:47 <Twey> Not for Haskell, I think
04:47:54 <nikki93> whoppix: qmake?
04:48:02 <whoppix> nikki93, qmake does that automatically, yes.
04:48:08 <nikki93> whoppix: Ahh.
04:48:08 <kmeyer> whoppix: qmake handles it for you, though
04:48:48 <Twey> http://qthaskell.berlios.de/
04:48:49 <whoppix> kmeyer, yes, but the fact that its not plain code might still repel some people.
04:48:58 <kmeyer> mhm
04:49:06 <kmeyer> however, it being GPL shouldn't anymore
04:49:11 <kmeyer> seeing as how Nokia made it LGPL
04:49:16 <kmeyer> (the open source version, anyways)
04:49:21 <whoppix> Also, I think it makes it pretty hard to write bindings to other languages.
04:49:30 <kmeyer> probably, though I wouldn't know
04:49:55 <kalven> is there a lack of qt bindings?
04:50:13 <Axman6> what do people think of my ST examples? http://www.haskell.org/haskellwiki/Monad/ST the fib one seems clunky
04:50:25 <dolio> It's about something like this: "match (insert k (y :: zs)) with (e :: e' :: es) -> ...". Now in the "..." make a proof of "insert k (y :: zs) == e :: e' :: es".
04:51:15 <whoppix> kalven, a lack of working Qt bindings, yes
04:51:59 <Trollinator> is foo' a legal identifier in haskell?
04:52:02 <quicksilver> Trollinator: yes.
04:52:03 <dolio> If you match at the same time with something like "insert k (y :: zs) == insert k (y :: zs)" you end up with a proof of "e :: e' :: es == e :: e' :: es", which doesn't work.
04:52:16 <quicksilver> Trollinator: ' is a letter as far as haskell names are concerned.
04:52:23 <Trollinator> i see.
04:52:25 <Cale> joma: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=816#a816
04:52:25 <kalven> whoppix: for what languages?
04:52:40 <Cale> joma: There's a short proof of the associativity of ++
04:52:46 <quicksilver> > let don't = (+); feed = 1; bears = 3 in don't feed bears
04:52:48 <lambdabot>   4
04:52:54 <Twey> Heh
04:53:09 * Twey ponders...
04:53:23 <Twey> > let don't = (+); feed = 1; the = negate; bears = 3 in don't feed the bears
04:53:25 <lambdabot>       No instance for (Num (a -> a))
04:53:25 <lambdabot>        arising from a use of `+' at <int...
04:53:27 <Twey> Argh
04:53:29 <Twey> :(
04:53:31 <whoppix> kalven, Well, I basically only ever used Qt in C++, but I heard that the perl bindings are completely broken, the python bindings are still beta (or something), so are the haskell bindings. As far as I've heard the only serious bindings that are considered stable are the Qt Jambi bindings for Java.
04:53:56 <SamB> Qt has Haskell bindings ?
04:54:03 <quicksilver> whoppix: I thought there was some quite recent progress on the haskell qt bindings
04:54:09 <quicksilver> and they were usable for some things.
04:54:12 <quicksilver> I haven't tried them though.
04:54:21 <SamB> news to me
04:54:26 <whoppix> me neither, but they still call themselves "beta"
04:54:29 <Twey> SamB: Yeah... developed by Trolltech though
04:54:38 <SamB> Twey: wait, is that bad ?
04:54:39 <Twey> So I don't know where they're going now :(
04:54:51 <Twey> SamB: Nokia own Qt now
04:54:58 <SamB> oh.
04:55:01 <kalven> whoppix: ok
04:55:13 <SamB> what happened to trolltech?
04:55:16 <SamB> they didn
04:55:20 <Twey> Sold out, I think
04:55:52 <whoppix> "This is the second preview release of qtHaskell."
04:56:25 <Trollinator> whoppix: PyQt isn't beta
04:56:25 <Twey> Oh, they're now 'Qt Software', a subsidiary of Nokia
04:56:31 <Trollinator> at least it isn't supposed to be.
04:56:37 <SamB> Twey: ah.
04:56:48 <Twey> So presumably it's still being developed
04:56:48 <whoppix> Trollinator, ok. I wouldn't know, I don't code any python, usually.
04:57:23 <Trollinator> anybody know a good pasting site? hpaste is down...
04:57:28 <yottis> it is, and i think they're even going to release $something with a less restrictive license
04:57:34 <SamB> @where hpaste2
04:57:34 <lambdabot> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/
04:58:11 <kalven> yottis: yes, lgpl
04:58:53 <SamB> well, Haskell bindings would almost have to be released with a less restrictive license ...
04:59:14 <nikki93> Axman6: What's 'ST'?
04:59:46 <Axman6> it's a crazy cool monad. look at the wikipage (ST stands for State Transformer)
05:00:20 <nikki93> Axman6: I'm haskell noob, don't understand monads yet. I'll get there though. :)
05:00:58 <Axman6> nikki93: basically it lets you do things like modify make a variable, and then modify it in place, but all in a pure way. so you cqan write imperative algorithms in haskell, and have them still be pure
05:01:42 <Axman6> nikki93: take a look at my examples, they're pretty self explanitary (with the comments anyway)
05:03:14 <nikki93> Amagawd... fibST is.. FAST!
05:04:29 <Raevel> when i try to install X11-xft-0.3 with cabal i get "exit: ExitFailure 1", any tips? :-)
05:05:28 <nikki93> My fib is fast at getting a list of fibs.
05:05:29 <nikki93> fib n = reverse (fib' [1,0] (n - 2))
05:05:29 <nikki93>     where fib' nums n = if (n > 0) then fib' ((head nums) + (secondInList  nums) : nums) (n - 1) else nums
05:05:32 <nikki93> 	  secondInList (_:x:xs) = x
05:05:46 <nikki93> Not the fastest though (there's almost always something faster than what I write in haskell. :P )
05:06:29 <Cale> joma: Just for fun, I've written a couple more: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=817#a817
05:07:14 <Axman6> nikki93: do you understand how this works? (sec)
05:07:32 <Axman6> > let fibs = 0 : 1 : zipWith fibs (tail fibs) in fibs
05:07:33 <lambdabot>   Couldn't match expected type `[a]'
05:07:40 <Axman6> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs -- whoops
05:07:42 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
05:09:18 <nikki93> Axman6: yeah, i know that one
05:09:34 <Axman6> nikki93: do you understand it though?
05:09:54 <nikki93> Axman6: yup
05:10:50 <nikki93> Axman6: add everything to everything before
05:11:05 <nikki93> Axman6: its lazy so works
05:12:12 <koeien> just out of curiosity, how is ``sort'' implemented in GHC? merge sort?
05:12:20 <Trollinator> > % 1 8
05:12:22 <lambdabot>   <no location info>: parse error on input `%'
05:12:27 <dolio> Yes.
05:12:30 <nikki93> @src sort
05:12:31 <Trollinator> how do i construct a rational?
05:12:31 <lambdabot> sort = sortBy compare
05:12:35 <Trollinator> > 1/2
05:12:36 <lambdabot>   0.5
05:12:38 <nikki93> @src sortBy
05:12:38 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
05:12:39 <Axman6> > 1 % 2
05:12:41 <lambdabot>   1%2
05:12:53 <koeien> hmm. this is insertion sort?
05:13:06 <dolio> Yeah. That's the implementation in the report.
05:13:14 <Trollinator> but my ghci keeps saying "Not in scope: `%'"
05:13:15 <adrian_> koeien: ghc uses mergesort
05:13:21 <koeien> adrian_: ah. thanks.
05:13:30 <koeien> dolio: thanks
05:13:55 <adrian_> koeien: the source is there: http://www.haskell.org/ghc/docs/6.8.3/html/libraries/base/src/Data-List.html
05:14:16 <SamB> dolio: I bet they used that one only because it looked pretty!
05:14:29 <dolio> I can't blame them. :)
05:14:38 <koeien> ah yes, i see.
05:14:43 <joma> *Matrix> groupBy (\x y -> x > y) $ [1..10]++[5,4,55,4,12,34,56,78]
05:14:43 <joma> [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10,5,4],[55,4,12,34],[56],[78]]
05:14:49 <joma> i dont understand that
05:15:04 <nikki93> anyone written true qsort in haskell?
05:15:11 <joma> why is 34 in the same group as 12?
05:15:16 <PeakerWork> joma: its grouping sequences that are "going down"
05:15:18 <dolio> Yes.
05:15:31 <adrian_> nikki93: what's true quicksort?
05:15:32 <joma> nikki93: true quicksort uses inplace sorting which I think isnt possible in Haskell?
05:15:35 <PeakerWork> joma: the function groupBy is given tests for each element whether to group it with the previous element
05:15:39 <koeien> nikki93: in the same file, there is a "true" quicksort ocommented out
05:15:48 <quicksilver> joma: groupBy doesn't work very well if it's not used with something "like =="
05:15:51 <PeakerWork> joma: its possible in the imperative subset of Haskell
05:15:59 <Axman6> nikki93: there's one written using ST on that same wiki page
05:16:05 <PeakerWork> quicksilver: why? It might very well be something you want to do (the above (>)
05:16:09 <SamB> joma: you can't use it on lists, anyway
05:16:23 <quicksilver> PeakerWork: because. That is the function. That's how it was written.
05:16:30 <quicksilver> PeakerWork: if it was something else, it would be something else.
05:16:43 <PeakerWork> quicksilver: I mean, why do you say it doesn't work very well -- seems to be useful as it is
05:16:50 <PeakerWork> quicksilver: (even with an argument function like (>))
05:17:03 <SamB> PeakerWork: well, the documentation doesn't SAY it's okay to use it that way
05:17:11 <PeakerWork> oh, who reads documentation? :-)
05:17:26 <quicksilver> PeakerWork: really? how is it useful with (>) ?
05:17:30 <Trollinator> can anybody tell me why my ghci keeps saying that % is not in scope?
05:17:36 <quicksilver> PeakerWork: how would you describe what it does in that case?
05:17:46 <nikki93> quicksilver: for lols? ;-)
05:17:48 <adrian_> trollinator: have you imported ratio?
05:17:56 <Trollinator> adrian_: no.
05:18:01 <Trollinator> do i have to?
05:18:03 <Trollinator> ok
05:18:04 <SamB> oh, also, it isn't useful here -- it isn't finding runs!
05:18:22 <quicksilver> "greedily picks out an increasing subsequence, and bundles any aberrants behind their representative"
05:18:24 <adrian_> Trollinator: yes
05:18:48 <quicksilver> I mean, it does something, and you can see what it does by looking at the code.
05:18:57 <quicksilver> But it's not obvious to me that what it does has a name, or is particularly useful.
05:19:24 <SamB> quicksilver: and I don't think the report requires that that be the result, either
05:19:30 <h0tzenpl0tz> has ghc a predefined "wrap" function? is it like "wrap x = [x]" ?
05:19:47 <daf> use the robot monkey
05:19:49 <SamB> @quote i.saw.it.eat
05:19:50 <lambdabot> No quotes match. Just try something else.
05:19:54 <adrian_> h0tzenpl0tz: (:[])
05:19:55 <SamB> @quote eat
05:19:56 <lambdabot> Cale says: Also, I want people to write things using (.) instead of repeated ($) because of my hidden agenda to flip the associativity of ($)
05:19:56 <PeakerWork> quicksilver: it groups decreasing sequences together
05:20:02 <SamB> @quote comment
05:20:03 <lambdabot> blackdog says: I'm not encouraged by the comment "i don't know haskell, but CL is much better", though. it doesn't suggest careful thought and objectivity...
05:20:06 <h0tzenpl0tz> > wrap
05:20:07 <quicksilver> PeakerWork: no it doesn't.
05:20:07 <lambdabot>   Not in scope: `wrap'
05:20:12 <daf> > (:[]) 42
05:20:12 <quicksilver> PeakerWork: take another look
05:20:14 <lambdabot>   [42]
05:20:16 <SamB> @quote I.saw
05:20:17 <lambdabot> Philippa says:  in this case using the FFI sounds rather like masturbating with a running chainsaw
05:20:25 <quicksilver> PeakerWork: how is "[55,4,12,34]" decreasing?
05:20:26 <PeakerWork> quicksilver: oh, there's 4,12 in there, missed that
05:20:33 <SamB> @quote I\ saw
05:20:34 <lambdabot> No quotes for this person. I feel much better now.
05:20:40 <PeakerWork> @src groupBy
05:20:41 <lambdabot> groupBy _  []       =  []
05:20:41 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
05:20:41 <lambdabot>     where (ys,zs) = span (eq x) xs
05:20:42 <SamB> @quote SamB comment
05:20:43 <lambdabot> No quotes match. My brain just exploded
05:20:48 <SamB> @quote SamB_XP comment
05:20:49 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
05:20:51 <PeakerWork> oh, I thought groupBy did something else
05:21:38 <SamB> quicksilver: I think Peaker was thinking it did the OTHER thing it could reasonably and legally do
05:22:10 <nikki93> @quote nikki93
05:22:11 <lambdabot> No quotes match. It can only be attributed to human error.
05:22:15 <nikki93> :-(
05:22:43 <joma> nikki93: that stick video, is it programmed in Haskell? it is very cool. like i said before you should amke an iphone or Android game out of it.
05:23:17 <daf> I don't think you can compile Haskell code for Android
05:23:31 <joma> no
05:23:34 <nikki93> joma: nothing to do with haskell
05:23:52 <joma> but he could write it in objective-C or Java respectively
05:23:57 <joma> nikki93: c++?
05:24:01 <SamB> respectively what ?
05:24:09 <joma> iphone and adroid
05:24:14 <SamB> ah
05:24:31 <nikki93> joma: its an animation, why program?
05:25:05 <quicksilver> nikki93: this is a programming language channel, full of programmers. When we write animations, we write computer programs to produce them :)
05:25:23 <nikki93> quicksilver: oh
05:25:50 <SamB> quicksilver: always ?
05:26:03 <quicksilver> SamB: generalisations have to generalise.
05:26:05 <quicksilver> ;)
05:26:07 <SamB> true
05:26:30 <SamB> that's, like, the only totally true generalization I've seen in a while
05:26:50 <joma> nikki93: im just thinking it could eb a cool thing to do a computergame of, good for cellphones since it is not processing-heavy
05:26:55 <nikki93> quicksilver: not always. ;-)
05:29:08 <PeakerWork> quicksilver: I thought it meant this:
05:29:09 <PeakerWork> > let groupBy f = foldr (\x r -> if null r then [[x]] else if x `f` (head.head) r then (x:head r):tail r else [x]:r) [] in groupBy (>) $ [1..10]++[5,4,55,4,12,34,56,78]
05:29:10 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10,5,4],[55,4],[12],[34],[56],[78]]
05:32:04 <nikki93> What makes Haskell awesome?
05:32:26 <CakeProphet> > partition even [1..]
05:32:28 <lambdabot>   ([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
05:32:29 <CakeProphet> that
05:32:56 <nikki93> OK.
05:33:10 <nikki93> Whoever puts up the coolest piece of Haskell code for lambdabot gets a hug.
05:34:15 <RayNbow> > let merge = mergeByR compare (const (:)) (:) (:) []; merge3 as bs cs = merge as (merge bs cs); hammings = 1 : merge3 (map (2*) hammings) (map (3*) hammings) (map (5*) hammings)    in   hammings
05:34:15 <joma> Peakerwork; thats what i thought too
05:34:17 <lambdabot>   [1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,7...
05:35:02 <joma> hmm nikki it seems stickmen fighting is popular on youtube? a whole artform?
05:35:23 <nikki93> joma: heh
05:36:15 <adrian_> nikki93: we need someone to do some magic with loeb then
05:36:23 <Workybob> @seen dcoutts
05:36:24 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 1h 55m 51s ago.
05:36:26 <adrian_> @src loeb
05:36:26 <lambdabot> Source not found. I feel much better now.
05:36:29 <Workybob> hmm
05:36:32 <nikki93> adrian_: loeb?
05:36:43 <Workybob> has anyone met this before while building gtk2hs... http://paste.lisp.org/display/73916
05:36:48 <Workybob> (hpaste is down btw)
05:36:48 <Shurique> > SimpleReflect.var $ (\x -> x ++ show x)"SimpleReflect.var $ (\\x -> x ++ show x)"
05:36:50 <lambdabot>   SimpleReflect.var $ (\x -> x ++ show x)"SimpleReflect.var $ (\\x -> x ++ sh...
05:37:21 <adrian_> nikki93: it seems I got the name wrong. It's supposed to be like fix, only for functors
05:37:53 <adrian_> ah, no. loeb it is
05:38:12 <adrian_> http://sigfpe.blogspot.com/2006/12/tying-knots-generically.html
05:38:31 <Axman6> http://www.reddit.com/r/programming/comments/7r2ic/why_the_gpl_is_not_free/ from out own Workybob
05:38:53 <Workybob> o.O
05:38:54 <Workybob> :)
05:38:57 <adrian_> nikki93: http://haskell.org/haskellwiki/Blow_your_mind
05:39:36 * ehird has intended to write a long anti-GPL piece for a while now, but cannot find the time to be angry enough
05:39:38 <Workybob> Axman6: I suspect the people in here already know my arguments for/against the GPL anyway
05:39:51 <Workybob> ehird: hehe, I was being very careful not to be angry actually
05:39:55 <Workybob> or trying to be at least
05:39:57 <Axman6> indeed, but it might help get it noticed in other places if people vote it up
05:40:05 <Workybob> true true
05:40:10 <ksandstr> is that sulphur i smell?
05:40:21 <joma> http://se.youtube.com/watch?v=aVi4gg_Ck1w&feature=related <- which abnd is that? slipknot? "let the bodies hit the floor, let the..."
05:40:25 <Workybob> ksandstr: hmm?
05:40:38 <skorpan> sounds like disturbed
05:40:48 <ehird> Workybob: meh, you know the gpl fans will just reply with a stupid oneliner like "it means that people can't profit off of your work" or some other rubbish
05:41:06 <Workybob> ehird: yeh, and that's actually exactly the argument I try to attack in it
05:41:10 <dolio> Drowning Pool.
05:41:11 <Workybob> it's a complete falacy
05:41:15 <Adamant> unless you're running a company, why do you care if people can profit off your work?
05:41:16 <CakeProphet> > let lol s a = s ++ show s ++ a; a = " in lol x"; x = "let lol s a = s ++ show s ++ a; a = \" in lol x\"; x = " in lol x
05:41:17 <lambdabot>       Overlapping instances for Show ([Char] -> [Char])
05:41:17 <lambdabot>        arising from a...
05:41:20 <CakeProphet> :(
05:41:27 <ehird> < Adamant> unless you're running a company, why do you care if people can  profit off your work?
05:41:34 <ehird> misguided notions of The Wonderful Community Of Free Software.
05:41:39 <Adamant> ?
05:41:41 <ehird> Where Ponies Abound.
05:41:44 <Workybob> Adamant: that, and as your work is open source  they can't profit from them (except from dumb people)
05:41:48 <Adamant> que?
05:41:54 <Workybob> all they can do is profit from their aditional work on top of your work
05:41:59 <h0tzenpl0tz> > wtf
05:42:00 <lambdabot>   Not in scope: `wtf'
05:42:07 <ehird> Adamant: most GPL advocates talk about "well they should have to contribute back to the open source commuuuuuunity"
05:42:08 <Workybob> and whether that extra work is worth the money or not is up to the consumers
05:42:11 <CakeProphet> > let lol s a = s ++ (show s) ++ a; a = " in lol x a"; x = "let lol s a = s ++ (show s) ++ a; a = \" in lol x a\"; x = " in lol x a
05:42:12 <lambdabot>   "let lol s a = s ++ (show s) ++ a; a = \" in lol x a\"; x = \"let lol s a =...
05:42:17 <CakeProphet> rofl
05:42:27 <ehird> meh
05:42:43 <ehird> > ap ((++) . show) $ "ap ((++) . show) $ "
05:42:44 <lambdabot>   Couldn't match expected type `a -> [Char]'
05:42:47 <Adamant> ehird: that's a perfectly reasonable argument, if you're Red Hat and want to make other companies share code they use
05:42:48 <ehird> oops.
05:43:06 <CakeProphet> @pl let lol s a = s ++ (show s) ++ a; a = " in lol x a"; x = "let lol s a = s ++ (show s) ++ a; a = \" in lol x a\"; x = " in lol x a
05:43:08 <lambdabot> liftM2 (.) (++) ((++) . show) "let lol s a = s ++ (show s) ++ a; a = \" in lol x a\"; x = " " in lol x a"
05:43:15 <ehird> Adamant: yes, I'm talking about individuals
05:43:23 <ehird> the situation gets more sticky around corporations
05:43:27 <Adamant> if you're not going to create a business from your code though, the GPL isn't really useful
05:43:36 <CakeProphet> unfortunately making it pointfree doesn't preserve the quality of being a quine.
05:43:49 <Cale> joma: each group is determined by comparing the *first* element of the group with each of the following ones.
05:43:54 <ehird> CakeProphet: it's an equiviquine!
05:44:04 <ehird> (outputs an identical-functionality but syntactically-different quine)
05:44:37 * Axman6 pastes http://www.reddit.com/r/programming/comments/7r2ic/why_the_gpl_is_not_free/ again so that more GPL disliking or disagreeing people may vote it up
05:44:39 <ksandstr> saw a quine once that was written in five languages. at the same time.
05:44:41 <CakeProphet> hmm... Haskell makes the possibilities even more fun. You could have an "infinite quine" where the source code is endlessly printing a string of its source code.
05:44:51 <Cale> joma: So groupBy (>) will break a list into maximal groups such that the first element of each group is greater than all the others.
05:45:09 <ehird> Axman6: Karma whore :-)
05:45:50 <Axman6> i don't care about the karma on this one, and i'd do the same if someone else posted it. though if you feel that i need more karma, vote for my haskell proposals :)
05:45:54 <CakeProphet> :t randomRs
05:45:56 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> [a]
05:46:10 <Axman6> @instances RandomGen
05:46:10 <lambdabot> Couldn't find class `RandomGen'. Try @instances-importing
05:46:22 <Axman6> @instances-importing System.Random RandomGen
05:46:23 <lambdabot> StdGen
05:46:59 <CakeProphet> > groupBy (<) $ randomRs (1,100) (mkStdGen 2390743)
05:47:01 <lambdabot>   [[14],[14,95,92],[9],[5,76,48,78,98,13,21,57,38,72,74,35,37,32,91,63],[1,16...
05:47:18 <CakeProphet> > groupBy (>) $ randomRs (1,100) (mkStdGen 2390743)
05:47:18 <PeakerWork> Cale: really maximal groups? In that case you'd expect that when the maximum element in a list will always start a group till the end of the list
05:47:20 <lambdabot>   [[14],[14],[95,92,9,5,76,48,78],[98,13,21,57,38,72,74,35,37,32,91,63,1,16,5...
05:47:40 <Cale> PeakerWork: yes, it will.
05:47:58 <CakeProphet> > groupBy even $ randomRs (1,100) (mkStdGen 2390743)
05:47:59 <lambdabot>   Couldn't match expected type `a -> Bool'
05:48:15 <CakeProphet> > groupBy (const even) $ randomRs (1,100) (mkStdGen 2390743)
05:48:16 <lambdabot>   [[14,14],[95,92],[9],[5,76,48,78,98],[13],[21],[57,38,72,74],[35],[37,32],[...
05:48:25 <Axman6> o.O
05:48:26 <adrian_> > let l = randomRs (1,100) (mkStdGen 42) in groupBy (>=) (maximum l: l)
05:48:30 <CakeProphet> I don't even know what that does. :P
05:48:40 <Axman6> i was just thinking about that one CakeProphet, and i did not expect that :o
05:48:59 <adrian_> > let l = take 100 $ randomRs (1,100) (mkStdGen 42) in groupBy (>=) (maximum l: l)
05:49:00 <CakeProphet> > groupBy (flip.(const even)) $ randomRs (1,100) (mkStdGen 2390743)
05:49:01 <Deewiant> makes groups where all elements after the first are even
05:49:09 <lambdabot>   Couldn't match expected type `b -> c' against inferred type `Bool'
05:49:11 <lambdabot>   [[99,72,72,18,15,17,92,19,72,59,76,66,80,77,19,5,46,88,52,94,37,67,5,33,95,...
05:49:14 <CakeProphet> meh
05:49:27 <adrian_> > let l = take 10 $ randomRs (1,100) (mkStdGen 42) in groupBy (>=) (maximum l: l)
05:49:33 <lambdabot>   [[92,72,72,18,15,17,92,19,72,59,76]]
05:49:34 <Deewiant> > groupBy ((flip.const)even) $ randomRs (1,100) (mkStdGen 2390743)
05:49:41 <lambdabot>   [[14,14,95,92,9,5,76,48,78,98,13,21,57,38,72,74,35,37,32,91,63,1,16,55,40,6...
05:50:06 <CakeProphet> @instances Random
05:50:17 <lambdabot> Couldn't find class `Random'. Try @instances-importing
05:50:35 <CakeProphet> @instances-importing System.Random Random
05:50:40 <igel> what's the best thing to do, if an assertion is violated?
05:50:43 <lambdabot> Bool, Char, Double, Float, Int, Integer
05:51:04 <igel> i mean i've got a data structure and at some point a make case foo of ... destinctions
05:51:16 <igel> and one of those cases *should* never occur
05:51:31 <Deewiant> I use 'error "Module.func :: internal error"'
05:51:35 <CakeProphet> > groupBy id $ randomRs (False, True) (mkStdGen 42)
05:51:41 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> Bool
05:51:47 <lambdabot>      Pr...
05:52:04 <CakeProphet> hmmm...
05:52:04 <igel> Deewiant: yes... the other way would be to return Nothing (it's a view function)
05:52:16 <igel> or is there some specific exception for this case?
05:52:33 <CakeProphet> I don't understand that error.
05:52:48 <Deewiant> igel: there's whatever GHC throws by default when you do case [] of x:xs
05:52:49 <CakeProphet> :t id
05:52:51 <lambdabot> forall a. a -> a
05:52:57 <Deewiant> igel: i.e. when it doesn't match
05:53:16 <Deewiant> CakeProphet: id is a -> a, groupBy wants a -> a -> Bool, the first a's match so then it tries to unify a with a -> Bool
05:53:27 <CakeProphet> oh... right
05:53:42 <igel> there is Control.Exception.AssertionFailed
05:53:48 <Deewiant> that's different
05:53:54 <Deewiant> I'm thinking of something like PatternMatchFailure
05:53:55 <adrian_> > groupBy (||) $ randomRs (False, True) (mkStdGen 42)
05:53:56 <lambdabot>   [[True,True,True,False,False,True,False,True,False,True,True,True,False,Fal...
05:54:08 <adrian_> > groupBy (&&) $ randomRs (False, True) (mkStdGen 42)
05:54:10 <lambdabot>   [[True,True,True],[False],[False],[True],[False],[True],[False],[True,True,...
05:54:37 <igel> yeah, but a decent error message would be useful instead of just a wrong pattern match
05:54:43 <CakeProphet> > groupBy (const not) $ randomRs (False, True) (mkStdGen 42)
05:54:45 <lambdabot>   [[True],[True],[True,False,False],[True,False],[True,False],[True],[True],[...
05:54:46 <igel> more useful i mean^^
05:55:08 <Workybob> > map (head &&& length) . groupBy (&&) . randomRs (False,True) $ mkStdGen 42
05:55:10 <lambdabot>   [(True,3),(False,1),(False,1),(True,1),(False,1),(True,1),(False,1),(True,3...
05:55:13 <Deewiant> igel: well, if it's never meant to happen, I think something like "internal error" is sufficient
05:55:20 <Workybob> > map (head &&& length) . groupBy (==) . randomRs (False,True) $ mkStdGen 42
05:55:22 <lambdabot>   [(True,3),(False,2),(True,1),(False,1),(True,1),(False,1),(True,3),(False,3...
05:55:32 <CakeProphet> > all id $ map head $ take 10000 $ groupBy (const not) $ randomRs (False, True) (mkStdGen 42)
05:55:34 <lambdabot>   True
05:55:43 <CakeProphet> each list starts with True.
05:55:55 <Workybob> CakeProphet: ?
05:56:04 <CakeProphet> > groupBy (const id) $ randomRs (False, True) (mkStdGen 42)
05:56:05 <lambdabot>   [[True,True,True],[False],[False,True],[False,True],[False,True,True,True],...
05:56:15 <CakeProphet> with groupBy (const not)
05:56:20 <Workybob> > groupBy (>=) . randomRs (False,True) $ mkStdGen 42
05:56:22 <lambdabot>   [[True,True,True,False,False,True,False,True,False,True,True,True,False,Fal...
05:56:24 <Deewiant> const id = flip const
05:56:35 <igel> Deewiant: sure, but (throw (AssertionError "empty seq at ...")) or (error "empty seq at") ? :)
05:56:46 <whoppix> @hoogle mkStdGen
05:56:47 <lambdabot> System.Random mkStdGen :: Int -> StdGen
05:57:02 <Deewiant> igel: isn't it the same thing? :-P
05:57:16 <Workybob> > groupBy (>) . randomRs (False,True) $ mkStdGen 42
05:57:16 <Deewiant> well, one is ErrorCall and the other is AssertionError
05:57:17 <lambdabot>   [[True],[True],[True,False,False],[True,False],[True,False],[True],[True],[...
05:57:22 <Deewiant> but same difference really
05:57:27 <igel> Deewiant: it's a different type :)
05:57:29 <Deewiant> I'd use error, that's what it's for
05:57:37 <Deewiant> igel: no, they're both Exception e => e ;-)
05:57:54 <Workybob> > filter (/=[True]) . groupBy (>) . randomRs (False,True) $ mkStdGen 42
05:57:56 <lambdabot>   [[True,False,False],[True,False],[True,False],[True,False,False,False],[Tru...
05:57:57 <CakeProphet> > all head $ take 10000 (groupBy (const not) $ randomRs (False, True) (mkStdGen 42))
05:57:58 <lambdabot>   True
05:58:05 <igel> yes, but that's about it ;)
05:58:12 <CakeProphet> > all head $ take 1000000000000000 (groupBy (const not) $ randomRs (False, True) (mkStdGen 42))
05:58:15 <Deewiant> igel: AssertionFailed is for assert, ErrorCall for error
05:58:17 * CakeProphet waits. :D
05:58:21 <Deewiant> I wouldn't throw either of those manually
05:58:28 <lambdabot>   thread killed
05:58:45 <Deewiant> > groupBy (const not) $ repeat False
05:58:47 <lambdabot>   [[False,False,False,False,False,False,False,False,False,False,False,False,F...
05:59:04 <CakeProphet> > groupBy (const not) $ repeat True
05:59:06 <lambdabot>   [[True],[True],[True],[True],[True],[True],[True],[True],[True],[True],[Tru...
05:59:20 <Deewiant> > groupBy (const not) $ cycle [False,True]
05:59:24 <lambdabot>   [[False],[True,False],[True,False],[True,False],[True,False],[True,False],[...
05:59:30 <igel> i'd use 'assert' if it allowed me to give it an error message
05:59:45 <Deewiant> why do you want to give an error message?
05:59:53 <igel> because it is not some you-want-the-head-of-an-empty-list error, it's a violated assertion
06:00:07 <Deewiant> Is not "assertion failed in file foo, line bar, column baz" sufficient? :-P
06:00:08 <igel> so that i can read it and find it in the code :)
06:00:16 <igel> they give line numbers? :)
06:00:24 <Deewiant> assert should
06:00:24 <Axman6> > length $ (inits . repeat) ['a'..'z'] >>= sequence
06:00:37 <CakeProphet> > assert (2==3)
06:00:39 <lambdabot>   Not in scope: `assert'
06:00:40 <lambdabot>   thread killed
06:00:41 <Deewiant> at least in GHC
06:00:56 <Axman6> > (inits . repeat) ['a'..'z'] >>= sequence
06:01:01 <adrian_> Axman6: there are 26^26
06:01:01 <lambdabot>   ["","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r"...
06:01:05 <igel> well than it's what i need!
06:01:08 <igel> thanks
06:01:12 <Axman6> > drop 1000 $ (inits . repeat) ['a'..'z'] >>= sequence
06:01:16 <lambdabot>   ["all","alm","aln","alo","alp","alq","alr","als","alt","alu","alv","alw","a...
06:01:32 <Axman6> > drop 10000 $ (inits . repeat) ['a'..'z'] >>= sequence
06:01:34 <lambdabot>   ["ntp","ntq","ntr","nts","ntt","ntu","ntv","ntw","ntx","nty","ntz","nua","n...
06:01:37 <CakeProphet> > map generalCategory ["a".."Z"]
06:01:40 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
06:01:59 <CakeProphet> > map generalCategory ['a'..'Z']
06:02:01 <lambdabot>   []
06:02:06 <Workybob> o.O
06:02:11 <Workybob> uhhh?
06:02:12 <CakeProphet> > map generalCategory ['A'..'z']
06:02:14 <lambdabot>   [UppercaseLetter,UppercaseLetter,UppercaseLetter,UppercaseLetter,UppercaseL...
06:02:17 <Axman6> heh
06:02:17 <Workybob> oh, okay
06:02:24 <Axman6> :t filterM (const [True, False])
06:02:28 <lambdabot> forall a. [a] -> [[a]]
06:02:32 <CakeProphet> > filter isAlpha $ map generalCategory ['A'..'z']
06:02:34 <lambdabot>   Couldn't match expected type `Char'
06:02:35 <CakeProphet> er
06:02:38 <Axman6> > filterM (const [True, False]) [1..3]
06:02:41 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
06:02:47 <Workybob> > map generalCategory [' ', 'z'..]
06:02:50 <lambdabot>   [Space,LowercaseLetter,UppercaseLetter,UppercaseLetter,LowercaseLetter,Uppe...
06:02:53 <CakeProphet> >  map generalCategory $ filter isAlpha  ['A'..'z']
06:02:55 <lambdabot>   [UppercaseLetter,UppercaseLetter,UppercaseLetter,UppercaseLetter,UppercaseL...
06:03:03 <CakeProphet> :(
06:03:03 <Workybob> > map generalCategory [' ', '9'..]
06:03:06 <lambdabot>   [Space,DecimalNumber,UppercaseLetter,LowercaseLetter,Control,Control,OtherS...
06:03:48 <Deewiant> > map (head.show.generalCategory) ['A'..'z']
06:03:50 <lambdabot>   "UUUUUUUUUUUUUUUUUUUUUUUUUUOOCMCMLLLLLLLLLLLLLLLLLLLLLLLLLL"
06:04:20 <adrian_> Deewiant: now we know how OCaml got its name
06:04:26 <Workybob> > [' ', '9'..]
06:04:27 <Deewiant> :-D
06:04:28 <lambdabot>   " 9Rk\132\157\182\207\232\257\282\307\332\357\382\407\432\457\482\507\532\5...
06:05:17 <CakeProphet> > groupBy (>) $ map generalCategory (randomRs ('\0', 'z') (mkStdGen 42))
06:05:19 <lambdabot>   [[OtherPunctuation],[OtherPunctuation],[Control,OpenPunctuation],[Control,O...
06:05:59 <Axman6> > let loeb x = fmap ($ loeb x) x in loeb [ (!!5), const 3, liftM2 (+) (!!0) (!!1), (*2) . (!!2), length, const 17]
06:06:01 <lambdabot>   [17,3,20,40,6,17]
06:06:06 <CakeProphet> > groupBy ((>) `on` generalCategory) $ randomRs ('\0', 'z') (mkStdGen 42)
06:06:07 <lambdabot>   ["\\","*","\DC3[","\DC4\"c_","\ESCTiKunq","\az","\DC33le","\ESC","\NULX","\...
06:06:52 <Deewiant> > concatMap (filter isUpper.show.generalCategory) ['A'..'z']
06:06:53 <lambdabot>   "ULULULULULULULULULULULULULULULULULULULULULULULULULULOPOPCPMSCPMSLLLLLLLLLL...
06:08:00 <Axman6> :t generalCategory
06:08:02 <lambdabot> Char -> GeneralCategory
06:08:19 <Axman6> > generalCategory maxBound
06:08:21 <lambdabot>   NotAssigned
06:08:27 <Axman6> > generalCategory minBound
06:08:29 <lambdabot>   Control
06:08:47 <CakeProphet> ... I wouldn't really call \0 a "control character"
06:09:05 <Deewiant> what else
06:10:44 <Axman6> > let (f:fs) + (g:gs) = f+g : fs+gs; fs + [] = fs; [] + gs = gs; (f:fs) * (g:gs) = f*g : [f]*gs + fs*(g:gs);  _ * _ = [] in [1,1]*[1,1]*[1,1]*[1,1]
06:10:47 <lambdabot>       Occurs check: cannot construct the infinite type: t = [t]
06:10:47 <lambdabot>        Expect...
06:11:35 <Deewiant> Axman6: let (f:fs) + (g:gs) = f+g : fs+gs cannot be well-typed
06:11:40 <lilac> > (\a -> a ++ show a) "(\a -> a ++ show a) "
06:11:42 <lambdabot>   "(\a -> a ++ show a) \"(\\a -> a ++ show a) \""
06:12:15 <lilac> > say $ (\a -> a ++ show a) "(\\a -> a ++ show a) "
06:12:17 <lambdabot>   (\a -> a ++ show a) "(\\a -> a ++ show a) "
06:12:27 <lilac> @pl (\a -> a ++ show a) "(\\a -> a ++ show a) "
06:12:28 <lambdabot> ap (++) show "(\\a -> a ++ show a) "
06:13:10 <Deewiant> > ap (++) show"ap (++) show"
06:13:12 <lambdabot>   "ap (++) show\"ap (++) show\""
06:13:15 <lilac> > ap (++) show "ap (++) show "
06:13:17 <lambdabot>   "ap (++) show \"ap (++) show \""
06:13:32 <Workybob> anyone seen this while building Gtk2Hs before? http://paste.lisp.org/display/73916
06:14:31 <nikki93> Haskell is so awesome! Here's a little thing I wrote to check whether two fib functions I wrote return the same results, for each of the results.
06:14:34 <nikki93> zip [1..100] (zipWith (==) (fib1 100) (fib2 100))
06:14:50 <nikki93> Allows me to do cool stuff in such less and beautiful code. :)
06:14:55 <Workybob> nikki93: quickcheck!
06:15:10 <nikki93> Workybob: Eh?
06:15:20 <Workybob> prop_fibsAreEqual = \x -> fib1 x == fib2 x
06:15:22 <ehird> yeah use quickcheck! :-)
06:15:25 <ehird> it's awesome
06:15:26 <adrian_> nikki93: quickcheck is a framework for testing your code
06:15:32 <ehird> @qc \x -> fib1 x == fib2 x
06:15:32 <lambdabot> Not enough privileges
06:15:33 <Workybob> nikki93: it randomly generates test data and throws it at the functions
06:15:37 <ehird> @quickcheck \x -> fib1 x == fib2 x
06:15:37 <lambdabot> Unknown command, try @list
06:15:41 <ehird> o.o
06:15:43 <ehird> we used to have it.
06:15:47 <Deewiant> @check True
06:15:48 <lambdabot>   "OK, passed 500 tests."
06:15:56 <ehird> aj
06:15:57 <ehird> ah
06:16:01 <ehird> @check \x -> fib1x == fib2 x
06:16:02 <lambdabot>   Not in scope: `fib1x'Not in scope: `fib2'
06:16:03 <nikki93> In ghci?
06:16:05 <ehird> @check \x -> fib1x == fib2 x
06:16:06 <lambdabot>   Not in scope: `fib1x'Not in scope: `fib2'
06:16:07 <ehird> @check \x -> fib1 x == fib2 x
06:16:08 <lambdabot>   Not in scope: `fib1'Not in scope: `fib2'
06:16:15 <ehird> nikki93: define fib1,fib2 in lambdabot and try that
06:16:26 <ehird> it'll spew a bunch of test data at the funcs
06:16:37 <faXx> ehird: or he could do it in ghci :P
06:16:42 <ehird> Well, yeah.
06:16:48 <ehird> But lambdabot is usefu lf or demonstartion
06:17:11 <faXx> ehird: true
06:17:17 <SamB> ehird: jees, I'm going to be calling you orbitz if you keep that up
06:17:29 <ehird> SamB: wut
06:17:37 <SamB> that typing
06:17:39 <nikki93> @let fib2 n = map (\x -> floor (((phi ^ n) / (sqrt 5)) + 0.5)) [0..(n-1)]
06:17:40 <lambdabot>  <local>:22:29: Not in scope: `phi'
06:17:49 <ehird> SamB: Sometimes my fingers break :-P
06:18:02 <SamB> it's her trademark, it is
06:18:08 <nikki93> @let phi = 1.618033988749895
06:18:11 <lambdabot>  Defined.
06:18:15 <Axman6> nikki93: phi == exp 1
06:18:22 <nikki93> @let fib2 n = map (\x -> floor (((phi ^ n) / (sqrt 5)) + 0.5)) [0..(n-1)]
06:18:25 <lambdabot>  Defined.
06:18:26 <Deewiant> Axman6: no
06:18:28 <lilac> @check \n -> (fix$(0:).(1:).(zipWith(+)`ap`tail))!!n == (fst . flip runState (0,1) $ let next = do (a, b) <- get; put (b, a+b); return a in sequence (repeat next))!!n
06:18:30 <lambdabot>   "* Exception: Prelude.(!!): negative index
06:18:31 <Axman6> no?
06:18:32 <Deewiant> > exp 1
06:18:34 <lambdabot>   2.718281828459045
06:18:35 <nikki93> Axman6: e = exp1
06:18:36 <Deewiant> Axman6: e == exp 1
06:18:38 <Axman6> oh my bad
06:18:38 <faXx> ehird: i have the experience too whenever i typ at a dvorak keyboard :P
06:18:42 <faXx> type *
06:18:51 <nikki93> > fib 10
06:18:53 <ehird> faXx: I do Dvorak just... veeeeeery slowly.
06:18:53 <lambdabot>   Not in scope: `fib'
06:18:54 <nikki93> > fib2 10
06:18:59 <ehird> (The previous sentence would take me ~2mins on Dvorak)
06:19:00 <lambdabot>   [55,55,55,55,55,55,55,55,55,55]
06:19:09 <nikki93> Something horribly wrong lol
06:19:09 <lilac> @check \n -> n < 0 || (fix$(0:).(1:).(zipWith(+)`ap`tail))!!n == (fst . flip runState (0,1) $ let next = do (a, b) <- get; put (b, a+b); return a in sequence (repeat next))!!n
06:19:11 <lambdabot>   "OK, passed 500 tests."
06:19:16 <Japsu> I'm using a non-standard layout called DAS
06:19:23 <luqui> > let phi = (1+sqrt 5)/2
06:19:24 <lambdabot>   <no location info>: parse error on input `;'
06:19:25 <Japsu> (no, it has nothing to do with the Das Keyboard)
06:19:27 <ehird> nikki93: yes. very horribly :P
06:19:28 <luqui> > let phi = (1+sqrt 5)/2 in phi
06:19:29 <lambdabot>   1.618033988749895
06:19:32 <ehird> Japsu: link?
06:19:45 <luqui> > let phi = (1+sqrt 5)/2 in phi^2
06:19:47 <lambdabot>   2.618033988749895
06:19:51 <luqui> > let phi = (1+sqrt 5)/2 in 1/phi
06:19:53 <lambdabot>   0.6180339887498948
06:19:56 <Japsu> ehird: http://cristian.seres.fi/DAS_en.html http://pajukanta.fi/blogs/destruction_preventer/a_customized_das_layout/
06:19:58 <Deewiant> ehird: http://cristian.seres.fi/DAS.html
06:20:15 <nikki93> @let fib2 n = map (\x -> floor (((phi ^ x) / (sqrt 5)) + 0.5)) [0..(n-1)]
06:20:16 <lambdabot>  <local>:23:0:
06:20:16 <lambdabot>      Warning: Pattern match(es) are overlapped
06:20:16 <lambdabot>               I...
06:20:24 <nikki93> @let fibPhi n = map (\x -> floor (((phi ^ x) / (sqrt 5)) + 0.5)) [0..(n-1)]
06:20:26 <lambdabot>  Defined.
06:20:30 <ehird> Deewiant: do all finns know each other or something
06:20:31 <nikki93> > fibPhi 10
06:20:33 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
06:20:38 <nikki93> Yeah! ;-)
06:20:42 <Japsu> ehird: wtf :D
06:20:56 <Deewiant> ehird: no, but I know keyboard layouts
06:20:59 <Axman6> ehird: sounds like canberra
06:20:59 <ehird> I'm fairly sure all finns are exactly the same
06:21:00 <ehird> :D
06:21:12 <Japsu> yes and let's not forget santa claus and the polar bears
06:21:24 <Japsu> and penguins, definitely not those
06:21:26 <Japsu> -_-
06:21:36 <Japsu> for functor's sake.
06:21:36 <Axman6> > fibPhi 100 !! 99
06:21:38 <lambdabot>   218922995834555138048
06:21:52 <ehird> For functor's sake. I like it.
06:22:29 <saml> > fibPhi 1 !! 10
06:22:30 <luqui> zipWith (-) (fix ((0:) . scanl (+) 1)) (fibPhi 100)
06:22:31 <lambdabot>   * Exception: Prelude.(!!): index too large
06:22:33 <luqui> > zipWith (-) (fix ((0:) . scanl (+) 1)) (fibPhi 100)
06:22:34 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
06:22:36 <pozic> Is there a function to get a random element (with uniform probability) from a list?
06:22:39 <nikki93> @let fibUsual n = take n (fibs) where fibs = 1 : 0 : zipWith (+) fib (tail fib)
06:22:40 <lambdabot>  <local>:25:60: Not in scope: `fib'
06:22:40 <lambdabot>  
06:22:40 <lambdabot>  <local>:25:70: Not in scope: `fib'
06:22:45 <nikki93> @let fibUsual n = take n (fibs) where fibs = 1 : 0 : zipWith (+) fibs (tail fibs)
06:22:46 <saml> > fibPhi 10000 !! 1000
06:22:49 <luqui> > filter (/= 0) $ zipWith (-) (fix ((0:) . scanl (+) 1)) (fibPhi 100)
06:22:49 <lambdabot>  Defined.
06:22:50 <lambdabot>   434665576869373362581838031072093641655828166009266380758517484743763125194...
06:22:51 <lambdabot>   [1,1,3,9,10,7,9,48,57,73,162,299,461,632,837,1981,3842,5823,11713,21632,128...
06:22:54 <ehird> pozic: get a random mumber up to the length
06:22:55 <nikki93> > fibUsual 20
06:22:56 <ehird> then use (!!)
06:22:58 <lambdabot>   [1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584]
06:22:59 <adrian_> :t random
06:23:00 <saml> oh this is a fast fibonacci
06:23:02 <lambdabot> forall g a. (RandomGen g, Random a) => g -> (a, g)
06:23:09 <ehird> @check \x -> fibPhi x == fibUsual x
06:23:10 <lambdabot>   Not in scope: `fibPhi'Not in scope: `fibUsual'
06:23:14 <nikki93> @let fibUsualFixed n = take n (fibs) where fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
06:23:14 <ehird> :{
06:23:17 <lambdabot>  Defined.
06:23:19 <ehird> @src fibUsualFixed
06:23:20 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
06:23:21 <adrian_> :t fst.random (mkStdGen 42)
06:23:22 <lambdabot>     Couldn't match expected type `a -> (a1, b)'
06:23:24 <lambdabot>            against inferred type `(a2, StdGen)'
06:23:26 <lambdabot>     In the second argument of `(.)', namely `random (mkStdGen 42)'
06:23:36 <adrian_> :t random (mkStdGen 42)
06:23:37 <lambdabot> forall a. (Random a) => (a, StdGen)
06:23:43 <adrian_> :t fst $ random (mkStdGen 42)
06:23:45 <lambdabot> forall a. (Random a) => a
06:23:45 <saml> man you guys are so smart i wish i can code like you
06:24:04 <pozic> ehird: yes, I know how to do it. I was just asking whether there was already something which did that.
06:24:07 <nikki93> We're so smart that you wish you'd code like us? Or are those two seperate sentences?
06:24:19 <nikki93> > fibUsualFixed 20
06:24:20 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
06:24:27 <joma> what is rgb of red?
06:24:28 <adrian_> let randomElement l = l !! (randomR (0,length l -1) (mkStdGen 42)
06:24:29 <nikki93> Test time!
06:24:33 <nikki93> joma: 1,0,0
06:24:38 <ehird> joma: (255,0,0)
06:24:40 <adrian_> > let randomElement l = l !! (randomR (0,length l -1) (mkStdGen 42)
06:24:41 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:24:45 <nikki93> ehird: That sucks, use floats. ;-)
06:24:49 <adrian_> > let randomElement l = l !! (randomR (0,length l -1) (mkStdGen 42))
06:24:50 <lambdabot>   <no location info>: parse error on input `;'
06:24:59 <nikki93> ehird: Check fibPhi and fibUsualFixed now
06:25:07 <nikki93> > fibPhi 20
06:25:08 <ehird> nikki93: gimme the source?
06:25:08 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
06:25:12 <ehird> they're only in your namespaceration
06:25:13 <lilac> @let fibA = floor.(0.5+).(/sqrt 5).(phi ^)
06:25:16 <lambdabot>  Defined.
06:25:23 <ehird> also, nikki93
06:25:30 <ehird> it'll be easier to test them if they only give one result
06:25:32 <ehird> I guess last.fib will work
06:25:33 <nikki93> > fibUsualFixed 20
06:25:34 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
06:25:38 <Axman6> Workybob: when did you decide to start that blog anyway?
06:25:40 <lilac> @let fibB n = (fix$(0:).(1:).(zipWith(+)`ap`tail))!!n
06:25:40 <lambdabot>   Parse error in expression: HsPostOp (HsLit (HsInt 0)) (HsQConOp (Special Hs...
06:25:47 <ehird> nikki93: source to fibUsualFixed and fibPhi?
06:26:01 <nikki93> fibUsualFixed n = take n (fibs) where fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
06:26:15 <nikki93> fibPhi n = map (\x -> floor (((phi ^ x) / (sqrt 5)) + 0.5)) [0..(n-1)]
06:26:15 <lilac> @let fibC n = (fst . flip runState (0,1) $ let next = do (a, b) <- get; put (b, a+b); return a in sequence (repeat next))!!n
06:26:17 <adrian_> > let randomElement l = l !! (fst $ randomR (0,length l -1) (mkStdGen 42))
06:26:19 <lambdabot>  Defined.
06:26:19 <lambdabot>   mueval: Prelude.read: no parse
06:26:19 <lambdabot>  mueval: GhcException mkTopLevEnv: not a hom...
06:26:24 <ehird> @let fibUsualFixed n = take n (fibs) where fibs = 0 : 1 : zipWith  (+) fibs (tail fibs)
06:26:24 <lambdabot>  <local>:29:0:
06:26:24 <lambdabot>      Multiple declarations of `L.fibUsualFixed'
06:26:24 <lambdabot>      Declared ...
06:26:25 <lilac> @let fibB n = (fix$(0:).(1:).(zipWith(+)`ap`tail))!!n
06:26:25 <lambdabot>   Parse error in expression: HsPostOp (HsLit (HsInt 0)) (HsQConOp (Special Hs...
06:26:26 <adrian_> randomElement [1..10]
06:26:28 <ehird> oh
06:26:30 <adrian_> > randomElement [1..10]
06:26:31 <lambdabot>   Not in scope: `randomElement'
06:26:46 <ehird> @check \x -> (last $ fibUsualFixed x) == (last $ fibPhi x)
06:26:46 <pozic> select_random_element list = do  random_index <- getRandomR (0, length list - 1) return (list !! random_index)
06:26:46 <lambdabot>   Not in scope: `fibUsualFixed'Not in scope: `fibPhi'
06:26:50 <ehird> Grrrrrrrr.
06:26:57 <ehird> @check \x -> (last $ fibUsualFixed x) == (last $ fibPhi x) where fibUsualFixed n = take n (fibs) where fibs = 0 : 1 :  zipWith  (+) fibs (tail fibs)
06:26:57 <lambdabot>   Parse error at "where" (column 53)
06:26:58 <lilac> @check \n -> n < 0 || fibA n == fibB n
06:27:00 <lambdabot>   Not in scope: `fibA'Not in scope: `fibB'
06:27:00 <ehird> oops.
06:27:02 <ehird> oh, eff it.
06:27:07 <adrian_> @let randomElement l = l !! (fst $ randomR (0,length l -1) (mkStdGen 42))
06:27:07 <ehird> check needs to inherit scope.
06:27:13 <lambdabot>  Defined.
06:27:17 <adrian_> > randomElement [1..10]
06:27:18 <lambdabot>   mueval: Prelude.read: no parse
06:27:18 <lambdabot>  mueval: UnknownError "GHC reported errors a...
06:27:26 <nikki93> > fibPhi 24
06:27:26 <lambdabot>   Not in scope: `fibPhi'
06:27:30 <nikki93> ???
06:27:35 <nikki93> @let fibPhi n = map (\x -> floor (((phi ^ x) / (sqrt 5)) + 0.5)) [0..(n-1)]
06:27:36 <lambdabot>  <local>:1:31: Not in scope: `phi'
06:27:45 <chessguy_work> 'morning
06:27:46 <Axman6> someone must have @undefined
06:28:08 <Deewiant> somewhat annoying that @undef just wipes everything :-/
06:28:21 <nikki93> @let phi = (1 + (sqrt 5)) / 2
06:28:22 <lambdabot>  Defined.
06:28:24 <nikki93> > phi
06:28:26 <lambdabot>   1.618033988749895
06:28:30 <nikki93> @let fibPhi n = map (\x -> floor (((phi ^ x) / (sqrt 5)) + 0.5)) [0..(n-1)]
06:28:31 <lambdabot>  Defined.
06:28:38 <nikki93> > fibPhi 24
06:28:40 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
06:28:49 <nikki93> Goldenratioismftw.
06:29:01 <nikki93> Y'know? C++ ain't bad. ;-)
06:29:19 <Axman6> yeah it is
06:29:38 <Axman6> doesn't handle infinite stuff very well
06:29:41 <SamB> what does Barendregt mean ?
06:30:08 <saml> > let fib = zipWith (+) [1..] [2..] in fib !! 24
06:30:10 <lambdabot>   51
06:30:19 <saml> i'm so smart too
06:30:35 <nikki93> saml: ;-)
06:30:35 <Axman6> except that's not the fibonacci sequence :\
06:30:36 <Twey> Hmm
06:30:38 <Twey> Yeah :-P
06:30:42 <Deewiant> > let fib = [0..] in fib !! 24
06:30:44 <lambdabot>   24
06:30:50 <Deewiant> close enough
06:30:52 <Twey> xD
06:30:53 <saml> oh darn it's not
06:31:04 <Axman6> > zipWith (+) [1..] [2..]
06:31:06 <lambdabot>   [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,...
06:31:14 <nikki93> oddnumbersftw
06:31:24 <Axman6> what an odd sequence
06:31:30 * Twey grooooans.
06:31:31 <Axman6> bah boom cha
06:31:37 <Axman6> :)
06:31:59 <nikki93> let blahblah = zipWith (+) (blahblah) (reverse blahblah)
06:32:01 <saml> if i had written financial backbone system for america, economy would have died 42 years ago
06:32:06 <Cale> SamB: It's the last name of a famous person with respect to the development of the lambda calculus.
06:32:06 <nikki93> @let blahblah = zipWith (+) (blahblah) (reverse blahblah)
06:32:07 <lambdabot>  Defined.
06:32:12 <Twey> nikki93: Not lazy
06:32:12 <nikki93> > blahblah
06:32:24 <nikki93> Yay stuck. :P
06:32:27 <lambdabot>   thread killed
06:32:30 <Twey> Heh
06:32:33 <SamB> Cale: well, as a compiler pass
06:32:46 <Cale> SamB: Oh, I have no idea then.
06:32:47 <Axman6> > let blahblah = 0:1:zipWith (+) (blahblah) (reverse blahblah)
06:32:49 <lambdabot>   <no location info>: parse error on input `;'
06:32:52 <Workybob> Axman6: a while ago, only got round to doing it today though
06:32:55 <Axman6> > let blahblah = 0:1:zipWith (+) (blahblah) (reverse blahblah) in blahblah
06:32:57 <lambdabot>   [0,1* Exception: stack overflow
06:33:02 <Axman6> ha
06:33:06 <Cale> SamB: Maybe something to do with the lambda cube? :)
06:33:08 <nikki93> Axman6: Loosah!
06:33:16 <Axman6> Workybob: as long as it wasn't before me... or i swear i will kill you
06:33:28 <SamB> Cale: it would be that, yes
06:33:29 <Axman6> nikki93: at least i got output!
06:33:30 <Workybob> >.>
06:33:30 <nikki93> How long you guys been coding haskell?
06:33:35 <chessguy_work> can someone enlighten me about a little abstract algebra here? it's actually for a data structure in haskell, and i'm missing something that's probably pretty obvious
06:33:39 <Axman6> bit less than a year
06:33:40 <pozic> SamB: http://www.cs.ru.nl/staff/Henk.Barendregt
06:33:46 <pozic> SamB: it is this guy
06:33:47 <Cale> chessguy_work: What?
06:33:49 <nikki93> 3 days or so. :)
06:34:03 <nikki93> Axman6: You programmed in C++ before?
06:34:17 <Axman6> i've done a little, nothing major
06:34:27 * Workybob cries at Gtk2hs failing to build :(
06:34:28 <Axman6> that's a very small little
06:34:40 <Axman6> Workybob: blog it!
06:34:45 <Axman6> plus i added you to my blogroll :)
06:34:48 <nikki93> Why would one need typeclasses?
06:34:55 <pozic> Workybob: yeah, that will teach them ;)
06:34:56 <Workybob> Axman6: nah, this is probably a bob is incompetent problem
06:34:59 <saml> nikki93, to make things happen
06:35:02 <ehird> blogroll?
06:35:04 <nikki93> Axman6: You saw www.grall.uni.cc?
06:35:04 <PeakerWork> > (5+3, 5.3+3)
06:35:05 <lambdabot>   (8,8.3)
06:35:06 <ehird> wow, that's so.. 2004
06:35:08 <saml> 1 + 2    and 1.0 + 2.0
06:35:09 <PeakerWork> @type (5+3, 5.3+3)
06:35:10 <lambdabot> forall t t1. (Fractional t1, Num t) => (t, t1)
06:35:14 <Axman6> nikki93: yes
06:35:22 <nikki93> Axman6: How's it?
06:35:24 <chessguy_work> we know that in regular algebra, x*(y+1) = (x*y)+(x+1). similarly, in logical sentences, a /\ (b \/ c) = (a /\ b) \/ (a /\ c). they also share a number of other properties (associativity, etc.). is there some underlying algebraic structure they have in common that causes the similar properties?
06:35:33 <ehird> chessguy_work: 42
06:35:34 <Axman6> nikki93: didn't take much of a look
06:35:38 <nikki93> Axman6: You're not on Windows, but you can run it through wine. I did, it works.
06:35:54 <adrian_> chessguy_work: a ring I think
06:36:01 <luqui> chessguy_work, hmm, good question.  distributivity is usually an axiom.
06:36:02 <nikki93> So what're typeclasses for?
06:36:09 <saml> chessguy_work, x(y+1) = xy + x
06:36:12 <Saizan> nikki93: overloading
06:36:13 <nikki93> They're like abstract classes or interfaces?
06:36:23 <Axman6> Site unavailable
06:36:23 <adrian_> chessguy_work: http://en.wikipedia.org/wiki/Ring_(mathematics)
06:36:24 <daf> yes
06:36:24 <Axman6> The site at grall.uni.cc cannot be displayed
06:36:31 <Cale> chessguy_work obviously meant (x*y)+(x*1)
06:36:34 <Vq^> nikki93: they are comparable to interfaces
06:36:40 <saml> ah sorry
06:36:50 <nikki93> Axman6: Search grall on google, it'll work.
06:36:53 <saml> i bet monad is what you want
06:37:08 <Vq^> nikki93: and the instance declarations can be compared with adapters
06:37:13 <nikki93> Axman6: Talking to moi?
06:37:13 <saml> m1*(m2+m3) = m1*m2 + m1*m3
06:37:18 <Axman6> yes
06:37:23 <chessguy_work> saml,  yeah, sorry for the typo
06:37:36 <nikki93> Axman6: Oops I wasn't talking to you, that was a mistake. I meant saml lol.
06:37:44 <luqui> (m `mplus` m') >>= f  =  (m >>= f) `mplus` (m` >>= f)
06:37:48 <nikki93> Axman6: (embarrassing url) http://grall.freejoomlas.com/
06:38:04 <Cale> Regular algebras are boolean, aren't they?
06:38:08 <nikki93> Any french guys here?
06:38:19 <saml> nikki93, typeclasses are for polymorphism
06:38:20 <nikki93> Cale: Eh?
06:38:28 <nikki93> saml: That's it? Nothing else?
06:38:38 <Cale> So I think the appropriate structure is just a boolean algebra.
06:38:42 <nikki93> saml: Just for specifying a 'general interface' for a certain kind of dataTYpes?
06:38:58 <saml> nikki93, yes
06:39:01 <ehird> I'm a french guy, for values of french equal to not french
06:39:13 <luqui> nikki93, specifying what a set of datatypes has in common, in some sense
06:39:24 <daf> nikki93: a typeclass isn't inherently bound to specific types
06:39:24 <luqui> (the set is open, so more can be added later)
06:39:27 <Cale> oh, huh... wikipedia says it's the other way around.
06:39:35 <adrian_> ehird: b == !b => b == undefined?
06:39:36 <daf> you can always add more instances to a type class
06:39:51 <ehird> adrian_: the french in not french is evaluated as the french outside of the scope of the redefinition.
06:39:57 <chessguy_work> Cale, well, that is a ring, isn't it?
06:40:04 <chessguy_work> (that=boolean algebra)
06:40:05 <Cale> oh, it's just a notational confusion
06:40:24 <Cale> chessguy_work: yes
06:40:30 <Cale> It's a kind of ring
06:40:33 <saml> to get most general, maybe categories
06:40:34 <luqui> adrian_, ?  ! = not ?
06:41:27 <adrian_> > not undefined
06:41:29 <lambdabot>   * Exception: Prelude.undefined
06:41:31 <Axman6> Workybob: someone voted down the reddit post >_< some linux devout believer no doubt
06:41:39 <Workybob> heh
06:41:44 <adrian_> > undefined == not undefined
06:41:46 <lambdabot>   * Exception: Prelude.undefined
06:41:56 <Workybob> Axman6: 8 up, 11 down
06:41:56 <adrian_> :(
06:42:06 <ehird> < Axman6> Workybob: someone voted down the reddit post >_< some linux  devout believer no doubt
06:42:09 <ehird> orrrrrr
06:42:11 <ehird> someone who likes the gpl?
06:42:15 <chessguy_work> Cale, and "regular" algebra (not sure what the right term is, but algebra as taught in middle school) is also a boolean algebra?
06:42:15 <quicksilver> nikki93, saml, luqui : typeclasses are not for specifying what several types have in common.
06:42:16 <ehird> or doesn't find the article interesting?
06:42:20 <quicksilver> they are for overloading.
06:42:22 <ehird> just sayin'
06:42:25 <Workybob> ehird: indeed
06:42:41 <Cale> chessguy_work: A regular algebra is a sort of algebra which looks like regular expressions.
06:42:47 <luqui> adrian_, but you are correct, _|_ = not _|_.  It's just that that equivalence is not computable.
06:42:59 <Cale> chessguy_work: That is, on top of multiplication and addition, it also has an operation *
06:43:19 <Workybob> hmm
06:43:26 <chessguy_work> oh, that's not the term i meant then
06:43:27 <Workybob> it seems pretty random what reddit reports for up/down
06:43:33 <Workybob> it varies massively
06:43:36 <luqui> quicksilver, you mean overloading notation?   I disagree.
06:43:43 <chessguy_work> what's the proper name for the first algebra usually taught in grade school
06:43:46 <quicksilver> luqui: I mean overloading functions and operators.
06:44:03 <luqui> quicksilver, what are they to a mathematician, for whom that word makes no sense.
06:44:04 <Cale> chessguy_work: That's usually just the real numbers.
06:44:07 <adrian_> luqui: all _|_ are the same, no?
06:44:13 <Cale> chessguy_work: Or perhaps the rationals/integers.
06:44:33 <quicksilver> luqui: to a mathematician, they are nothing.
06:44:39 <quicksilver> luqui: they have no mathematical significance at all.
06:44:44 <luqui> adrian_, we like to say so.  you could say that error "foo" /= error "bar".  But it is more useful not to say that.
06:44:44 <quicksilver> luqui: any more than 'haskell module' does.
06:44:45 <saml> overloading means foo can have different semantics but same type
06:44:51 <Cale> chessguy_work: The properties you talk about tend to be ones which follow from the ring and field axioms
06:44:54 <quicksilver> luqui: they are just a programming technique.
06:44:55 <luqui> quicksilver, that I also disagree with. :-)
06:45:03 <luqui> quicksilver, what is a ring?
06:45:06 <roconnor> _|_ is simply a tool to give semantics to partial functions
06:45:13 <roconnor> #haskell takes it way to seriously
06:45:24 <chessguy_work> Cale, ok. thanks
06:45:45 <luqui> roconnor, haskell is a language of partial functions.  _|_ is how we give semantics to our language.  serious business! :-)
06:45:52 <chessguy_work> Cale, trying to figure out this very strange property i discovered last night
06:45:52 <adrian_> is there a way to tell error "Foo" apart from error "Bar"?
06:45:53 <saml> ring is: the set must be an Abelian group under addition, a monoid under multiplication
06:45:59 <Cale> chessguy_work: A field is a ring where every element other than 0 has a multiplicative inverse (and which is not the trivial ring)
06:46:00 <quicksilver> luqui: a set equipped with two operations, such that blah.
06:46:05 <quicksilver> luqui: it's certainly not a typeclass.
06:46:21 <roconnor> appendable under multiplication
06:46:26 <quicksilver> luqui: a typeclass might be a convenient tool to overload those operations so you can write code which is polymorphic over all rings.
06:46:29 <quicksilver> but that's all it is.
06:46:30 <luqui> quicksilver, couldn't a typeclass be a set equipped with n operations, such that blah.
06:46:40 <quicksilver> the typeclass is the tool that lets you overload the operations.
06:46:41 <quicksilver> and nothing more.
06:46:41 <luqui> quicksilver, hmm....
06:46:43 <chessguy_work> Cale,  ever heard of something called Conjunctive Normal Form, for logical sentences?
06:47:21 <Cale> chessguy_work: yes
06:48:01 <saml> conjunctive normal form is  (a/\b)\/(c/\d) ...
06:48:11 <Cale> er...
06:48:14 <luqui> quicksilver, I think <>you are correct.  But I also think there are other interpretations with more meaning.
06:48:18 <saml> no i'm wrong
06:48:20 <Cale> saml: I think it's the other way
06:48:29 <chessguy_work> saml,  the other way
06:48:30 <saml> yes. connectors are conjunction
06:48:35 <chessguy_work> it's a conjunction of disjunctions
06:48:37 <luqui> or maybe exploring their meaning is the way to fix them.
06:48:46 <quicksilver> luqui: sure. My interpretation is viciously biased to discourage people from writing new typeclasses.
06:48:58 <luqui> quicksilver, touche ;-)
06:49:01 <quicksilver> luqui: because my experience is that 99.9% of the people in #haskell who write a new typeclass, do so in error.
06:49:03 <chessguy_work> Cale, saml , i was playing around last night with adding clauses to sentences in that form and putting it back in CNF
06:49:12 <quicksilver> luqui: so I bias my pedagogical style to over-compensate.
06:49:19 <luqui> gotcha
06:49:47 <chessguy_work> Cale, saml : e.g., if p is in normal form, "p \/ q" puts q in every clause of p
06:50:03 <Cale> chessguy_work: sure, that follows from distributivity
06:50:12 <chessguy_work> Cale, yep
06:50:19 <chessguy_work> Cale, here's the weird one though
06:50:29 <chessguy_work> Cale, if you _negate_ a CNF sentence
06:50:59 <saml> then you might need de moore or something
06:51:02 <saml> de morgan
06:51:05 <chessguy_work> Cale, de morgan
06:51:09 <chessguy_work> err, saml
06:51:16 <Cale> yes
06:51:23 <h0tzenpl0tz> hello, is there any rule-of-thumb when to use foldl or foldr besides style-of-recursion?
06:51:34 <Cale> You end up with the DNF with all the variables negated.
06:51:34 <quicksilver> chessguy_work: CNF suffers from nasty blow-up problems.
06:51:38 <saml> negation of CNF is not CNF. but negation is inversible
06:51:40 <chessguy_work> you wind up having to form a new clause for every way you can choose an element from each of the existing clauses
06:51:51 <luqui> h0tzenpl0tz, one rule of thumb is if you're folding over an operator, use the associativity of the operator.  but it is a weak thumb.
06:51:54 <Cale> (after pushing the negation inwards to the variables)
06:51:58 <quicksilver> chessguy_work: some natural incremental changes cause exponential explosion in term size. Maybe you already know this.
06:51:59 <chessguy_work> saml, well yes, i mean negate it and put it back into CNF
06:52:01 <Cale> chessguy_work: yes
06:52:16 <Cale> Then to put it back into CNF, you need to apply distributivity again
06:52:16 <luqui> h0tzenpl0tz, another rule is foldl for strict, foldr for lazy.
06:52:21 <chessguy_work> > sequence [[1,2,3],[4,5,6]]
06:52:23 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
06:52:25 <quicksilver> h0tzenpl0tz: foldl' when you reduce to a summary value.
06:52:36 <quicksilver> h0tzenpl0tz: fold when you produce a list or other structure which can be consumed lazily.
06:52:44 <quicksilver> h0tzenpl0tz: sorry, foldr for the second.
06:52:47 <luqui> h0tzenpl0tz, but these are all special cases of "the correct one"...
06:52:56 <chessguy_work> so if your original CNF is ((1 \/ 2 \/ 3) /\ (4 \/ 5 \/ 6)), thats' what you come up with
06:53:06 <Cale> chessguy_work: that's right.
06:53:10 <quicksilver> A more precise rule is "foldr when you can examine part of the result without consuming the entire input"
06:53:19 <luqui> when foldl = foldr, foldl (or foldl' to be explicit) is usually right, I think...
06:53:23 <chessguy_work> Cale, that seems out of left field to me
06:53:35 <chessguy_work> quicksilver, i think perhaps that's what i'm discovering
06:53:48 <luqui> but you have to be careful that foldl actually does equal foldr, not just for finite inputs or something...
06:53:55 <nikki93> Waitaminnit... GHC compiles to HC files?
06:54:14 <nikki93> One can just 'include' this file into a C program and... Hack around? :P
06:54:14 <h0tzenpl0tz> k, so besides laziness/inifinite structures and recursion-style, i have severe problems when i need the e-accu to the  left and when to the right.
06:54:23 <quicksilver> chessguy_work: its the disadvantage of both CNF and DNF as general purpose normal forms.
06:54:27 <Cale> chessguy_work: Well, - /\ \/ ==> \/ - /\ ==> \/ /\ - and then to get back to /\ \/, you need to apply distributivity, and that's what distributivity does.
06:54:39 <quicksilver> chessguy_work: whichever one you pick, there is a way to produce exponential blowup.
06:54:40 <Cale> er...
06:54:56 <Cale> - /\ \/ ==> \/ - \/ ==> \/ /\ -  rather
06:55:11 <Cale> If you catch what I mean.
06:55:34 <Cale> (it's just applying De Morgan's laws twice)
06:55:58 <luqui> h0tzenpl0tz, can you give an example of one that trips/tripped you up?
06:56:13 <chessguy_work> Cale, but there's no equivalent in any other algebraic system i can think of, where negation causes such combinatorial explosion
06:56:40 <Cale> chessguy_work: Well, multiplication always does this.
06:56:52 <quicksilver> chessguy_work: do you study many algebraic systems with normal forms?
06:56:59 <Cale> chessguy_work: It's just that most algebraic systems don't have De Morgan's laws.
06:57:01 <quicksilver> chessguy_work: it's more of a normal form issue than an algebraic one.
06:57:19 <quicksilver> if your rules for reducing to normal form contain some rules which increase term size
06:57:22 <h0tzenpl0tz> luqui: implementing a map using fold(l|r): you want to use (:) due to O(1) but whats the immediate reason to use foldl or foldr?
06:57:23 <quicksilver> (like distributivity does)
06:57:31 <quicksilver> then there will be worst cases which stress these rules
06:57:36 <Cale> chessguy_work: Expand (a + b + c) (d + e + f) (g + h + i)
06:57:36 <quicksilver> for major term size increase.
06:57:52 <Cale> chessguy_work: and you'll see that the same thing happens in any ring
06:57:56 <luqui> h0tzenpl0tz, well most of our rules of thumb apply there.  map has to work on infinite lists, for one.
06:58:29 <Cale> You get one term for each possible way of selecting a term from each of the factors.
06:58:47 <chessguy_work> well sure, if you're multipling
06:58:50 <chessguy_work> multiplying
06:58:59 <h0tzenpl0tz> luqui: is the infinite-liste the primary reason or how the (:) operator works?
06:59:11 <luqui> h0tzenpl0tz, and because lists are constructed in a right-associative way; i.e. 1:(2:(3:(4:[]))), as opposed to (((1:2):3):4):5  or some such nonsense
06:59:12 <Cale> It's not really the multiplication which is so important, it's the fact that you're applying the distributive law.
06:59:21 <Cale> You get:
06:59:47 <Cale> a (d+e+f)(g+h+i) + b (d+e+f)(g+h+i) + c (d+e+f)(g+h+i)
06:59:53 <h0tzenpl0tz> luqui: thank you!
06:59:56 <Cale> and then
07:00:13 <Cale> (ad+ae+af)(g+h+i) + (bd+be+bf)(g+h+i) + (cd+ce+cf)(g+h+i)
07:00:40 <Cale> (using distributivity again)
07:01:17 <Cale> and then you get to: (ad(g+h+i)+ae(g+h+i)+af(g+h+i)) + (bd(g+h+i)+be(g+h+i)+bf(g+h+i)) + (cd(g+h+i)+ce(g+h+i)+cf(g+h+i))
07:01:30 <Cale> and then applying distributivity once more:
07:01:37 <h0tzenpl0tz> luqui: one more question: so using foldl on a right-associative structure like [] would simply reverse the structure?
07:01:45 <chessguy_work> Cale, sure
07:02:04 <chessguy_work> i guess it's just unusual for negation to cause distribution like that
07:02:12 <Cale> ((adg+adh+adi)+(aeg+aeh+aei)+(afg+afh+afi)) + ((bdg+bdh+bdi)+(beg+beh+bei)+(bfg+bfh+bfi)) + ((cdg+cdh+cdi)+(ceg+ceh+cei)+(cfg+cfh+cfi))
07:02:24 <Cale> It's not the negation which caused the distribution.
07:02:41 <Cale> It's the fact that you applied the distributive law to put it back into CNF.
07:03:13 <chessguy_work> well, ok
07:03:21 <Cale> (after applying De Morgan's laws)
07:03:51 <chessguy_work> so there's no equivalent to DeMorgan's laws in most algebras
07:03:52 <Cale> De Morgan's laws don't apply to normal numbers though.
07:03:54 <Cale> yeah
07:04:45 <Cale> Normally, when you negate a product, there's nothing more you can do with it.
07:05:02 <Cale> Except possibly to push the negation into one of the factors.
07:05:04 <chessguy_work> yeah
07:05:41 <quicksilver> well e^(a+b) is e^a * e^b
07:05:52 <quicksilver> so you get a demorgan-like transformation for exponentiation.
07:06:18 <quicksilver> I think you can find things a bit like this all over the place.
07:06:20 <Cale> Er, but not the reverse...
07:06:34 <quicksilver> no, it's not self-dual in quite the same sense.
07:07:09 <Cale> However, for set complement, you get the same thing
07:07:21 <Cale> (since De Morgan's laws apply naturally there)
07:07:25 <luqui> > foldl (flip (:)) [] [1,2,3,4,5]
07:07:27 <lambdabot>   [5,4,3,2,1]
07:07:31 <quicksilver> (which is not suprising because sets are a model of boolean logic)
07:07:36 <luqui> h0tzenpl0tz, ^^
07:07:48 <luqui> though I had to flip (:) to make the types match up
07:07:56 <nikki93> Is it possible to use Haskell as an extension/scripting language for a C++ program?
07:08:18 <Cale> nikki93: Yes, I suppose.
07:08:27 <nikki93> Cale: How? :)
07:08:31 <Cale> nikki93: It will involve using the C ffi
07:08:34 <luqui> not terribly pretty though...
07:08:54 <Cale> nikki93: as well as possibly the GHC API or one of its wrappers, like hint
07:08:57 <quicksilver> "scripting" language implies dynamic files
07:09:02 <quicksilver> which implies embedding ghci
07:09:07 <quicksilver> can be done, though.
07:09:12 <chessguy_work> Cale, i wonder if any regular algebraic ideas could be used for the problem of turning sentences into conjunctions of horn clauses
07:09:15 <quicksilver> it's not a very natural match.
07:09:15 <h0tzenpl0tz> luqui: thats what i meant. thank you alot
07:09:33 <Trollinator> nikki93: i wouldn't use a statically typed language for that sort of thing
07:09:52 <Cale> Static typing really isn't the main problem...
07:09:52 <luqui> Trollinator, ??
07:10:13 <roconnor> probably should do the opposite of what Trollinator says
07:10:20 <Trollinator> and i would use something a lot of people know and that is well-supported in the C++ community
07:10:24 <daf> is there a standard term for functions which start producing output before they have finished consuming their input?
07:10:29 <Trollinator> read: python (with boost.python).
07:10:30 <daf> (re: foldl vs. foldr)
07:10:32 <quicksilver> daf: "productive"
07:10:37 <daf> aha
07:10:43 <daf> this is interesting and not something I'd encountered before
07:10:45 <nikki93> Trollinator: I already use Squirrel with SQPlus, and it works.
07:10:46 <luqui> I think Trollinator's point could be that it's a pain when two static type systems don't agree
07:10:49 <quicksilver> daf: is not entirely standard, but would be understood in the right context.
07:10:54 <nikki93> Trollinator: Just though haskell was awesome. :)
07:11:02 <nikki93> s/though/thought/
07:11:23 <Cale> nikki93: If I had a choice, I'd probably do the whole project in Haskell though.
07:11:27 <daf> I was thinking about this in the context of parsing
07:11:35 <luqui> daf, informally we use 'lazy' to mean that too.
07:11:46 <Cale> nikki93: If it's open-source, the xmonad-style approach to extension is really nice.
07:11:48 <daf> I wanted a parser that was productive
07:11:49 <nikki93> Cale: What's 'embedding' ghci like?
07:12:01 <ehird> is productive really the technical term?
07:12:06 <ehird> I've only ever heard lazy
07:12:08 <Cale> nikki93: The basic idea being that you just implement your program as a library, and its configuration becomes the main program.
07:12:22 <daf> I suppose a productive funtion is necessarily non-strict
07:12:24 <nikki93> Cale: Hah yeah, the xmonad way.
07:12:30 <luqui> daf, ah!  for a parser to be productive, it needs to start giving output before it knows whether there is a parse failure.
07:12:37 <ehird> luqui: ah right
07:12:40 <daf> luqui: precisely
07:12:51 <ehird> so, (ParseTree,Maybe Error) output, essentially
07:13:11 <Saizan> or [Either Parsed Error]
07:13:13 <roconnor> ehird: have you seen the wikipage on making things lazy?
07:13:19 <ehird> Saizan: indeed.
07:13:20 <daf> what Saizan said
07:13:23 <ehird> roconnor: I don't think so.
07:13:28 <daf> in this case, it was a Parser [a]
07:13:38 <daf> it can be done in parsec, but it's not obvious
07:13:40 <ehird> [Either Parsed Error] also lets you continue parsing post-error
07:13:41 <ehird> like gc
07:13:42 <ehird> gcc
07:13:52 <nikki93> Cale: I was thinking something like, you know, I have a small game-like program in C++, where I have different kinds of objects, and if I type 'createObject("Box",1,2,3)' into a console (in squirrel, a scripting language), it creates a Box at 1,2,3.
07:13:59 <nikki93> Cale: It'd be cool to use Haskell for that.
07:14:09 <nikki93> Cale: I don't know why Haskell but. ;)
07:14:21 <daf> (you have to make a Parser (ParseState, a))
07:14:30 <luqui> nikki93, like you said, because haskell is awesome ;-)
07:14:54 <luqui> nikki93, but it will be a pain to get it working.  haskell has not been terribly streamlined for that type of thing.
07:14:59 <nikki93> Cale: (I've already written this program, its a test of a physics engine wrapper I wrote, just though of checking out haskell and now am thinking of mixing it with C++)
07:15:09 <nikki93> luqui: You mean the GHC haskell right?
07:15:12 <luqui> yeah
07:15:28 <luqui> APIs and whatnot.  the language is fine for it; the extra support isn't really there though.
07:15:31 <nikki93> luqui: Ok, forget the implementation part. Do you think Haskell is a good scripting language?
07:15:39 <luqui> yeah
07:15:45 <roconnor> @wiki Maintaining_laziness
07:15:46 <lambdabot> http://www.haskell.org/haskellwiki/Maintaining_laziness
07:15:47 <Cale> nikki93: It can be.
07:15:51 <roconnor> ehird: ^^
07:15:59 <nikki93> Cale: That could be my next big project. :)
07:16:06 <luqui> To me, a language cannot be good unless it is a good scripting language.
07:16:11 <Cale> nikki93: Though interfacing with C++ can be a pain.
07:16:11 <roconnor> ehird: see section 2.1
07:16:13 <ehird> roconnor: I propose a page move to "Procrastination".
07:16:32 <Cale> nikki93: (basically, it's similar to interfacing C and C++ code)
07:16:37 <lilac> re [Either Parsed ParseError], see http://metafoo.co.uk/darcs/hc++/Utils/Parser.hs -- see runMany
07:16:41 <daf> my feeling is that Haskell is more oriented towards larger-scale software
07:16:46 <roconnor> ``I was going to read about laziness, but I decided to do it later, when I need to understand it''
07:16:53 <daf> at least, I find it difficult to write small programs quickly in it
07:16:58 <ehird> daf: I disagree
07:16:59 <nikki93> Cale: Actually, SQPlus (and luabind and boost.python etc.) provide a very high level interface to using the respective languages for scripting,and they do a good job at making it easy.
07:17:04 <luqui> daf, you just need to get used to it more
07:17:06 <daf> I think the benefits pay off more with longer development time and larger software
07:17:11 <ehird> I also disagree.
07:17:16 <nikki93> daf: Nope. I actually found it good for writing small things.
07:17:26 <daf> luqui: perhaps
07:17:49 <luqui> There seems to be some assumption that a language cannot good at both small and large scale software...
07:17:59 <daf> I don't think I'm assuming that
07:18:03 <nikki93> @remember roconnor I was going to read about laziness, but I decided to do it later, when I need to understand it
07:18:03 <lambdabot> Done.
07:18:04 <lilac> roconnor: ``I started reading about eagerness, but then I found I needed to know about eagerness, so I started reading about eagerness, but then...''
07:18:20 <quicksilver> daf: interestingly, most people assume the opposite. (That haskell is only good for small things).
07:18:35 <lilac> roconnor: better: ``I started reading about eagerness, but then I found a reference to eagerness, so I started reading about eagerness, but then...''
07:18:37 <luqui> well that's a common attack on a language
07:18:38 <nikki93> Probably I'm just too sleepy now and unable to think. :)
07:18:47 <nikki93> quicksilver: Me too. :)
07:18:50 <roconnor> lilac: :D
07:19:03 <daf> quicksilver: I'm expecting a number of refutations of that in code form any year now
07:19:05 <nikki93> @quote daf
07:19:05 <luqui> because it's hard to refute, and obviously large scale software is 'real' software, whereas small scale is not.
07:19:06 <lambdabot> No quotes match. Do you think like you type?
07:19:12 <nikki93> @quote quicksilver
07:19:13 <lambdabot> quicksilver says: I ACCIDENTALLY THE WHOLE VERB
07:19:17 <ehird> @quote ehird
07:19:17 <lambdabot> No quotes match. Take a stress pill and think things over.
07:19:18 <nikki93> lol
07:19:19 <ehird> :(
07:19:26 <nikki93> quicksilver: You actually said that?
07:19:30 <nikki93> quicksilver: In full caps?
07:19:32 <quicksilver> I did indeed.
07:19:37 <nikki93> lolll
07:19:38 <quicksilver> It is a meme.
07:19:41 <quicksilver> I like memes.
07:19:44 <lilac> @quote YO DAWG
07:19:45 <lambdabot> No quotes for this person. The more you drive -- the dumber you get.
07:19:50 <nikki93> @quote lilac
07:19:50 <lambdabot> lilac says: <bohdan> how do I see the number of reductions required to calculate somethig? <lilac> bohdan: the usual method is to ask Cale to reduce it by hand :)
07:19:55 <ehird> @quote ehird @quote ehird; < lambdabot> No quotes match. Take a stress pill and think things over.; < ehird> :(
07:19:55 <lambdabot> No quotes for this person. Maybe if you used more than just two fingers...
07:20:00 <ehird> @remember ehird @quote ehird; < lambdabot> No quotes match. Take a stress pill and think things over.; < ehird> :(
07:20:00 <lambdabot> I will remember.
07:20:04 <ehird> @quote ehird
07:20:05 <lambdabot> ehird says: @quote ehird; < lambdabot> No quotes match. Take a stress pill and think things over.; < ehird> :(
07:20:07 <nikki93> @quote lambdabot
07:20:07 <PeakerWork> is it likely that ghc will ever generate counter examples to make error messages easier to debug?
07:20:07 <lambdabot> lambdabot says: ghc-6.5: panic! (the `impossible' happened, GHC version 6.5):        checkPr...
07:20:11 <ehird> Meta.
07:20:13 <nikki93> @quote lambdabot
07:20:14 <lambdabot> lambdabot says: lambdabot
07:20:17 <nikki93> @quote lambdabot
07:20:17 <lambdabot> lambdabot says:  lambdabot hasn't said anything memorable
07:20:21 <nikki93> @quote lambdabot
07:20:22 <lambdabot> lambdabot says: <chessguy> sorry, this is the bird book: http://www.amazon.com/Introduction-Functional-Programming-2nd-Bird/dp/0134843460/sr=8-6/qid=1159309594/ref=pd_bbs_6/104-1423720-3100708?ie=
07:20:22 <lambdabot> UTF8&s=books <lambdabot> http://tinyurl.com/root7
07:20:41 <nikki93> @remember lamdbabot I will remember.
07:20:41 <lambdabot> I will remember.
07:20:42 <Trollinator> what would you call a function that does for polynoms what divMod does for integers?
07:20:52 <ehird> nikki93: lamdbabot
07:20:54 <Trollinator> i can't call it divMod since polynoms are not integral.
07:20:55 <nikki93> divPlynom
07:20:56 <ehird> Lame DBA bot?
07:21:06 <nikki93> ehird: lik
07:21:12 <ehird> Trollinator: divModButForPolynomials
07:21:17 <nikki93> ehird: s/lik/lol/ (I wonder how that type happened)
07:21:25 <nikki93> ehird: s/type/typo/
07:21:32 <nikki93> ehird: lol
07:21:40 <ehird> Four lines to say lol.
07:21:43 <ehird> I applaud you, sir.
07:22:12 <nikki93> Trollinator: How about theDivModThatYouCanUseOnPolynomials?
07:22:13 <luqui> nikanj, divPlynml, of course
07:22:18 * quicksilver was pretty sure he also made a YO DAWG comment but can't remember it.
07:22:26 <nikanj> luqui: Huh?
07:22:29 <Trollinator> ...
07:22:31 <luqui> grr
07:22:33 <Trollinator> i guess i'll stick with divPolynom
07:22:36 <nikki93> luqaknakan, divPlynml, yes. :|
07:22:36 <ehird> itBehavesInTheSameWayAsDivModExceptYouCanOnlyApplyItToPolynomialsUnlikeDivMod
07:22:39 <luqui> nikanj, autocomplete death, sorry.
07:22:47 <nikanj> Ok, oki :)
07:22:55 <nikki93> nikanj: hi! :)
07:22:56 <lilac> @quote @remember
07:22:57 <lambdabot> fasta says: I think the @remember command is way overused.
07:23:03 <ehird> @quote @quote
07:23:03 <lambdabot>  @quote says: CakeProphet brainfuck is synonymous with efficiency.
07:23:14 <nikki93> @quote lol
07:23:14 <lambdabot> xerox says: > take 10 lol where lol = "ol" : zipWith (:) (intersperse 'o' $ cycle "l") lol
07:23:18 <ehird> @quote @quote
07:23:19 <lambdabot>  @quote says: CakeProphet brainfuck is synonymous with efficiency.
07:23:29 <nikki93>  > take 10 lol where lol = "ol" : zipWith (:) (intersperse 'o' $ cycle "l") lol
07:23:31 <Trollinator> > take 10 lol where lol = "ol" : zipWith (:) (intersperse 'o' $ cycle "l") lol
07:23:32 <lambdabot>   ["ol","lol","olol","lolol","ololol","lololol","olololol","lolololol","ololo...
07:23:40 <Trollinator> -.-
07:23:47 <lilac> @quote @remember
07:23:47 * nikki93 lolsalot
07:23:48 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
07:23:54 <quicksilver> or in Java, we'd make it more generic by using a PolynomialDivisionOperatorFactory.
07:23:55 <Ferdirand> would be fun to define an Integral instance for a polynom though
07:24:02 <nikki93> @quote nikki93
07:24:02 <lambdabot> No quotes match. Sorry.
07:24:02 <ehird> @remember quicksilver or in Java, we'd make it more generic by using a  PolynomialDivisionOperatorFactory.
07:24:02 <lambdabot> Done.
07:24:05 <nikki93> :(
07:24:07 <Cale> nikki93: Prelude Language.Haskell.Interpreter> runInterpreter (setImportsQ [("Prelude", Nothing)] >> interpret "(1,\"hello\",[4,5,6])" (as :: (Integer, String, [Integer])))
07:24:07 <Cale> Right (1,"hello",[4,5,6])
07:24:10 <quicksilver> Ferdirand: doesn't really feel right.
07:24:12 <Trollinator> Ferdirand: you can't.
07:24:17 <Trollinator> you can't enumerate polynoms.
07:24:24 <quicksilver> Ferdirand: you'd have to "lie" about toInteger.
07:24:27 <Trollinator> oh, wait.
07:24:32 <Trollinator> perhaps you can.
07:24:37 <nikki93> Cale: Eh?
07:24:37 <Trollinator> but toInteger will fail.
07:24:38 <quicksilver> ignore higher order terms, for example.
07:24:41 <Cale> Prelude Language.Haskell.Interpreter> runInterpreter (setImportsQ [("Prelude", Nothing)] >> interpret "foldr (+) 0 [1..10]" (as :: Integer))
07:24:42 <Cale> Right 55
07:24:45 <quicksilver> I think it would be wrong to do so.
07:24:45 <baaba> wouldn't that be a DivisionOperatorFactoryFactory?
07:24:48 <nikki93> Cale: You mean a haskell interpreter in haskell?
07:24:51 <Ferdirand> sort of what was i thinking
07:24:54 <Cale> nikki93: It embeds GHC.
07:24:55 <ehird> Trollinator: toInteger failing is not very ... Integral.
07:24:57 <baaba> which then returns a PolynomialDivisionOperatorFactory
07:25:08 <nikki93> Cale: In haskell?
07:25:08 <Cale> nikki93: So it's actually a compiler in disguise :)
07:25:08 <Ferdirand> well
07:25:11 <Cale> nikki93: yes
07:25:22 <Cale> nikki93: It's a wrapper around the GHC API
07:25:23 <Ferdirand> you can see it as evaluating the polynom when the variable is 0
07:25:33 <faXx> > take 10 $ iterate (++"ol") "lol"
07:25:35 <lambdabot>   ["lol","lolol","lololol","lolololol","lololololol","lolololololol","lololol...
07:25:40 <Cale> GHC is of course written in Haskell, and exposes itself as a library.
07:25:40 <nikki93> Cale: So I should embed ghci to embed haskell in c++ to embed haskell to embed ghc to compile haskell code?
07:25:59 <ehird> PRECISELY.
07:26:04 <Zao> Trivial.
07:26:05 <nikki93> Sounds easy. :)
07:26:16 <ehird> (Yo dawg I herd u liek oh god I can't do this kill me please I am an awful human being)
07:26:23 <papermachine> lol
07:26:25 * nikki93 kills ehird
07:26:41 * nikki93 says: This is a new way to talk on IRC.
07:26:51 <Cale> nikki93: Well, you'd probably do something like write a Haskell module which compiles/interprets your (haskell) extension code, and then use FFI to expose that functionality via C.
07:27:09 <quicksilver> I think what ehird couldn't quite bear to say was YO DAWG I HEARD YOU LIKE HASKELL SO I PUT A GHCI IN YOUR GHCI SO YOU CAN INTERPRET WHILE YOU INTERPRET
07:27:15 <quicksilver> I have a stronger stomach, I can say it.
07:27:20 <Cale> nikki93: You'd need some data interface to convert between C and Haskell structures.
07:27:20 * nikki93 says: That's easier than having the whole haskell compiler/interpreter in C/C++ right?
07:27:47 <ehird> quicksilver: On a related note, this video is hilarious: http://uk.youtube.com/watch?v=oHg5SJYRHA0
07:27:50 <nikki93> Even quicksilver can be crazy some times.
07:27:56 <luqui> cabal: dependencies conflict: ghc-6.10.1 requires process ==1.0.1.1 however
07:27:57 <luqui> process-1.0.1.1 was excluded because ghc-6.10.1 requires process ==1.0.1.0
07:28:01 <luqui> huh?
07:28:05 <nikki93> Cale: Have you ever said a joke? :)
07:28:21 <leimy> hmmm
07:28:27 <nikki93> @quote Cale
07:28:27 <lambdabot> Cale says: Woo! Lambda Calculus and lots of pretty colours!
07:28:35 <nikki93> Ok answered.
07:28:37 <leimy> SO this Vista GHC stuff kind of concerns me...
07:28:45 <Saizan> luqui: did you reinstall Cabal after installing process-1.0.1.1
07:28:48 <Saizan> luqui: ?
07:28:53 <roconnor> @quote stereo
07:28:54 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
07:28:55 <luqui> Saizan, hmm, dunno.  I'll try that.
07:28:59 <nikki93> leimy: Want me to make lambdabot remember that?
07:28:59 <Cale> did I actually say that?
07:29:05 <Cale> I don't remember saying that.
07:29:06 <Saizan> luqui: no, that would cause that problem
07:29:09 <Cale> @quote Cale
07:29:10 <Saizan> luqui: i meant
07:29:10 <lambdabot> Cale says: Ruby is kind of a nice language, for an imperative object oriented language that isn't smalltalk.
07:29:12 <Cale> @quote Cale
07:29:13 <lambdabot> Cale says: Screw standardisation, let's just work on base 2.0 now so that by the time Haskell' comes out, it'll be completely out of date.
07:29:16 <nikki93> Cale: You must have been young.
07:29:21 <leimy> nikki93: I don't know, that's up to you :-)
07:29:25 <Cale> I remember saying those two.
07:29:27 <Cale> @quote Cale
07:29:28 <lambdabot> Cale says: They're using continental drift as a means of communication.
07:29:30 <luqui> Saizan, oh...
07:29:33 <Cale> @quote Cale
07:29:34 <lambdabot> Cale says: They're using continental drift as a means of communication.
07:29:36 <quicksilver> I think Cale is still young.
07:29:42 <leimy> @quote leimy
07:29:42 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
07:29:42 <Cale> I'm 25.
07:29:43 <luqui> Saizan, any idea what to do about it?
07:29:50 <leimy> woot!
07:29:51 <Cale> I guess that's kinda young :)
07:29:51 <nikki93> Cale is olldddd...
07:29:57 <Workybob> @quote Beelsebob
07:29:57 <lambdabot> beelsebob says: <lambdabot> Parse error <beelsebob> where bitch?
07:30:00 <Workybob> :)
07:30:02 <nikki93> What did you do for 10 years before me dude?
07:30:17 <luqui> I know _one_ thing
07:30:19 <ehird> 25 is olldddd, lol
07:30:30 <gio123> Cale is a god
07:30:35 <nikki93> ehird: Why you 57?
07:30:45 <Saizan> luqui: first see if Cabal-1.6.0.1 is depending on process-1.0.1.1, and if you also have a Cabal-1.6.0.1 in the user database unregister it
07:30:47 <ehird> nikki93: I am actually 4 years from birth.
07:31:00 <ehird> I'm going to assume your nick implies you were born in 1993 :-P
07:31:01 <skorpan> do all functions which take a polymorphic function as an argument have a rank 2 type?
07:31:04 <nikki93> ehird: You're gonna be reborn? You're WAY to old.
07:31:09 <lilac> if one more person says 25 is old, i'm gonna cry
07:31:18 <ehird> lilac: 25 is o- no, I can't do it
07:31:21 <ehird> can't bring myself to it
07:31:22 * ehird weeps
07:31:23 <lilac> :)
07:31:24 <nikki93> ehird: It doesn't imply that. Me being born in 1993 implied my ick.
07:31:26 <leimy> I'm 31
07:31:31 <nikki93> s/ick/nick/
07:31:35 <ehird> your ick
07:31:41 <gio123> I am 10 years old
07:31:44 <ehird> leimy: wow, you're practically DEAD.
07:31:45 <ehird> :-P
07:31:49 <leimy> ehird: nearly
07:31:58 <nikki93> leimy: Nearly practically dead?
07:32:05 <leimy> Almost
07:32:15 <orbitz> almost nearly practically dead?
07:32:15 <leimy> leimy [n]: almost nearly practically dead
07:32:16 <nikki93> leimy: You're almost nearly practically dead?
07:32:33 <luqui> Saizan, how do I check deps.  (and there seems only to be one cabal in global+user combined)
07:32:52 <Saizan> luqui: ghc-pkg field Cabal depends
07:32:53 <leimy> nasdaquiri [n] : What you drink while your 401k melts down.
07:32:54 <Cale> I plan on forming a symbiotic relationship with sandtrout, which, as they merge with my body, will sustain me as I slowly turn into a sandworm, and make use of my billions of other memories and prescience to rule over everyone and everything for millenia.
07:33:20 <luqui> Saizan, nope, just process-1.0.1.0
07:33:20 <osfameron> can you do that monadically?
07:33:21 <Workybob> @seen dcoutts
07:33:21 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I don't know when dcoutts last spoke.
07:33:24 <Workybob> :(
07:34:01 <luqui> Saizan, oh, right, I'm trying to install hint, so maybe it's depending on a different version of the ghc api than I have
07:34:19 <Saizan> luqui: no, it's not that
07:34:24 <luqui> oh...
07:34:32 <Saizan> luqui: ghc-pkg field haskell98 depends ?
07:35:13 <ehird> @remember Cale I plan on forming a symbiotic relationship with sandtrout, which,  as they merge with my body, will sustain me as I slowly turn into  a sandworm, and make use of my billions of other memories and  prescience to rule over everyone and everything for millenia.
07:35:14 <lambdabot> I will remember.
07:35:18 <luqui> Saizan, there are two entries.  one of which depends on process-1.0.1.0, the other on process-1.0.1.1
07:35:36 <luqui> Saizan, unregister haskell98 from user?
07:35:41 <nikki93> @let whatIsLeimy n = if (n > 0) then ["almost", "practically", "nearly", "kind of", "not quite", "unlike"]!!((n `rem` 5) + 1) ++ " " ++ whatIsLeimy(n - 1) else "DEAD!"
07:35:42 <lambdabot>  Defined.
07:35:47 <Saizan> luqui: yeah
07:35:51 <nikki93> > whatIsLeimy 5
07:35:52 <lambdabot>   "practically unlike not quite kind of nearly DEAD!"
07:35:59 <luqui> Saizan, w00t.  thanks! :-)
07:36:08 <nikki93> > whatIsLeimy 10
07:36:09 <lambdabot>   "practically unlike not quite kind of nearly practically unlike not quite k...
07:36:16 <leimy> >whatIsLeimy
07:36:32 <nikki93> > whatIsLeimy 7
07:36:33 <lambdabot>   "kind of nearly practically unlike not quite kind of nearly DEAD!"
07:36:34 <leimy> >  whatIsLeimy 1
07:36:35 <lambdabot>   "nearly DEAD!"
07:36:43 <leimy> > whatIsLeimy 100
07:36:45 <lambdabot>   "practically unlike not quite kind of nearly practically unlike not quite k...
07:36:47 <nikki93> Haskell FTW!
07:36:49 <ehird> > whatIsLeimy 30
07:36:50 <lambdabot>   "practically unlike not quite kind of nearly practically unlike not quite k...
07:36:52 <nikki93> I wrote that MYSELF! :D
07:36:55 <ehird> > whatIsLeimy 20
07:36:56 <ehird> yes, we saw
07:36:57 <lambdabot>   "practically unlike not quite kind of nearly practically unlike not quite k...
07:37:01 <ehird> > whatIsLeimy 10
07:37:02 <lambdabot>   "practically unlike not quite kind of nearly practically unlike not quite k...
07:37:04 <ehird> ...
07:37:11 <nikki93> lol
07:39:35 <pozic> quicksilver: I have another very "fun" problem. I just want to select a field, but that even seems too much to ask: http://paste.debian.net/26463/
07:40:44 <nikki93> @let whatIsLeimy n = if (n > 0) then ["almost", "practically", "nearly", "kind of", "not quite", "unlike"]!!((n `rem` ) + 1) ++ " " ++ whatIsLeimy(n - 1) else "DEAD!"
07:40:44 <lambdabot>  Couldn't match expected type `Int'
07:40:49 <nikki93> @let whatIsLeimy n = if (n > 0) then ["almost", "practically", "nearly", "kind of", "not quite", "unlike"]!!((n `rem` 6) + 1) ++ " " ++ whatIsLeimy(n - 1) else "DEAD!"
07:40:50 <lambdabot>  <local>:4:0:
07:40:50 <lambdabot>      Warning: Pattern match(es) are overlapped
07:40:50 <lambdabot>               In...
07:40:57 <nikki93> > whatIsLeimy 20
07:40:59 <lambdabot>   "practically unlike not quite kind of nearly practically unlike not quite k...
07:41:04 <nikki93> > whatIsLeimy 10
07:41:05 <lambdabot>   "practically unlike not quite kind of nearly practically unlike not quite k...
07:41:11 <nikki93> @let whatIsLeimy2 n = if (n > 0) then ["almost", "practically", "nearly", "kind of", "not quite", "unlike"]!!((n `rem` 6) + 1) ++ " " ++ whatIsLeimy(n - 1) else "DEAD!"
07:41:13 <lambdabot>  Defined.
07:41:16 <nikki93> > whatIsLeimy2 10
07:41:17 <lambdabot>   "unlike unlike not quite kind of nearly practically unlike not quite kind o...
07:41:28 <nikki93> > whatIsLeimy2 5
07:41:29 <lambdabot>   "* Exception: Prelude.(!!): index too large
07:41:33 <nikki93> :(
07:41:45 <nikki93> > whatIsLeimy2 4
07:41:46 <lambdabot>   "unlike not quite kind of nearly DEAD!"
07:42:17 <quicksilver> pozic: it would be better style, nd make it easier to test your code, if you'd put the extensions at the top.
07:42:57 <Olathe> > let whatIsLeimy n = (++" DEAD !").intercalate " ".map (["almost", "practically", "nearly", "kind of", "not quite", "unlike"]!!).take n.randomRs (0,5).mkStdGen $ n in whatIsLeimy 5
07:42:58 <lambdabot>   "unlike practically practically almost nearly DEAD !"
07:43:04 <Olathe> > let whatIsLeimy n = (++" DEAD !").intercalate " ".map (["almost", "practically", "nearly", "kind of", "not quite", "unlike"]!!).take n.randomRs (0,5).mkStdGen $ n in whatIsLeimy 6
07:43:05 <lambdabot>   "unlike almost unlike unlike nearly practically DEAD !"
07:43:14 <nikki93> leimy: How's the whatIsLeimy function?
07:43:26 <Olathe> > let whatIsLeimy n = (++" DEAD !").intercalate " ".map (["almost", "practically", "nearly", "kind of", "not quite", "unlike"]!!).take n.randomRs (0,5).mkStdGen $ n in whatIsLeimy 11
07:43:27 <lambdabot>   "unlike kind of kind of unlike almost practically unlike not quite unlike n...
07:43:34 <nikki93> Olathe: I was thinking of randomness but I'm not familliar with monads yet
07:43:47 <pozic> quicksilver: oh, right, sorry.
07:43:49 <Olathe> Oh, you can use randomness without monads.
07:43:50 <leimy> @let gonads="monads"
07:43:51 <lambdabot>  Defined.
07:43:56 <leimy> > gonads
07:43:57 <lambdabot>   "monads"
07:44:01 <nikki93> leimy: lol
07:44:12 <Olathe> > randomRs (0, 5).mkStdGen $ 5
07:44:13 <lambdabot>   [5,1,1,0,2,1,4,0,4,3,1,1,0,1,5,3,1,3,1,2,1,3,4,3,1,0,4,0,5,3,2,1,3,4,4,2,2,...
07:44:22 <leimy> :t randomRs
07:44:23 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> [a]
07:44:29 <leimy> no monad!
07:44:30 <quicksilver> pozic: anyhow this is nothing more serious than the monomorphism restriction.
07:44:41 <nikki93> But randomness... Isn't... Pure?
07:44:43 <leimy> well except list of course being a monad
07:44:50 <quicksilver> pozic: that code compiles fine with the appropriate type sig on on z
07:44:59 <quicksilver> pozic: z :: (MonadState Int m) => Poly m
07:44:59 <Olathe> It is if you seed it yourself.
07:45:02 <leimy> > randomRs (0, 5).mkStdGen $ 5
07:45:04 <lambdabot>   [5,1,1,0,2,1,4,0,4,3,1,1,0,1,5,3,1,3,1,2,1,3,4,3,1,0,4,0,5,3,2,1,3,4,4,2,2,...
07:45:08 <leimy> see same sequence
07:45:11 <pozic> quicksilver: oh, I thought I disabled the monomorphism restriction.
07:45:12 <leimy> idempotence assured!
07:45:21 <Olathe> It's impure if you take a seed from the environment.
07:45:33 <quicksilver> pozic: if you listed your extensions at the top you wouldn't have made this mistake ;)
07:45:42 <Olathe> @type mkStdGen
07:45:43 <lambdabot> Int -> StdGen
07:45:46 <Olathe> @type getStdGen
07:45:47 <lambdabot> IO StdGen
07:45:48 <pozic> quicksilver: the code I posted, compiles, but I want to have foo z work
07:45:54 <Olathe> getStdGen is impure.
07:45:56 <pozic> quicksilver: are you also talking about that?
07:46:01 <quicksilver> pozic: No.
07:46:02 <gal_bolle> it seems code.haskell.org is having a hard time
07:46:06 <quicksilver> pozic: I was talking about it not compiling at all.
07:46:09 <nikki93> What is mkStdGen?
07:46:18 <pozic> quicksilver: it was compiling here already.
07:46:19 <Olathe> mkStdGen lets you specify a seed.
07:46:24 <Olathe> > mkStdGen 5
07:46:26 <lambdabot>   6 1
07:46:30 <Olathe> @type mkStdGen 5
07:46:31 <lambdabot> StdGen
07:46:40 <Olathe> Now you have a generator that's been seeded with 5.
07:46:46 <pozic> quicksilver: but excuse me for the confusion I caused.
07:46:49 <Olathe> You can do whatever you want with it.
07:46:58 <nikki93> > let f = (+3) in f 2
07:47:00 <lambdabot>   5
07:47:02 <nikki93> cool
07:47:15 <quicksilver> pozic: OK, if I add NoMonomorphismRestriction I agree it compiles :)
07:47:18 <cycloid> Hi there.  I'm beginning to read RWH, and can't quite get into fluent reading of type sigs, etc.  One thing that bugs me is I don't have a good symbol to word map for things like: ->, <-, and =>.  If you were to read some code aloud, what would you say when you read those?
07:47:36 <quicksilver> pozic: now the problem is that "z" is a polymorphic value.
07:47:43 <nikki93> cycloid: Actually, its saying that it makes a function of that type.
07:47:48 <quicksilver> pozic: you can't call 'foo' on it until you resolve the polymorphism.
07:47:50 <h0tzenpl0tz> why is this possible: Just . (+1) $ 1 ? are Type-Constructors functions?
07:47:51 <Olathe> to, from, in
07:47:54 <quicksilver> pozic: that's what the error message means.
07:48:02 <nikki93> cycloid: x -> y means takes x and gives y.
07:48:07 <leimy> h0tzenpl0tz: ys
07:48:09 <leimy> er yes
07:48:13 <Workybob> h0tzenpl0tz: yes, type constructors are functions
07:48:20 <leimy> > Just . (+1) $ 21949239
07:48:21 <h0tzenpl0tz> uh, didnt know that
07:48:21 <quicksilver> no they're not.
07:48:21 <lambdabot>   Just 21949240
07:48:22 <Olathe> @type Just
07:48:23 <lambdabot> forall a. a -> Maybe a
07:48:24 <Workybob> they're functions that only kinda have a result though
07:48:27 <quicksilver> data constructors are functions.
07:48:33 <h0tzenpl0tz> ah, k
07:48:34 <leimy> yes fine
07:48:35 <quicksilver> type constructors (like Maybe) are something different :)
07:48:35 <Workybob> oh, well corrected quicksilver
07:48:37 <cycloid> nikki93: thanks, how 'bout <- and =>?
07:48:39 <leimy> data constructors :-)
07:48:39 <quicksilver> but Just is a data constructor.
07:48:47 <Olathe> cycloid: from and in
07:48:49 <nikki93> cycloid: x -> y -> z may be looking like 'take x and y and give z'.
07:48:58 <quicksilver> data constructors are functions... but are also something more.
07:48:58 <nikki93> cycloid: I don't know, I'm a noob, those are for monads and stuff.
07:49:00 <h0tzenpl0tz> so Data-Constructors are functions which also may be used in pattern-matching?
07:49:07 <quicksilver> h0tzenpl0tz: precisely.
07:49:12 <h0tzenpl0tz> great, thanks
07:49:17 <leimy> yes... that's called deconstruction
07:49:19 <cycloid> Olate: thanks, that helps
07:49:38 <nikki93> cycloid: x -> y -> z, if it takes only one argument, gives a function of type y -> z though.
07:49:56 <nikki93> cycloid: Watch this.
07:49:56 <quicksilver> cycloid: "x -> y -> z" I read as "x to y to z".
07:50:08 <quicksilver> cycloid: "=>" I read as "such that" or I just pause
07:50:15 <quicksilver> normally just pause, in fact.
07:50:20 <nikki93> @let f x y = x + y
07:50:21 <lambdabot>  Defined.
07:50:24 <quicksilver> cycloid: "<-" I read as "gets"
07:50:32 <nikki93> :type f
07:50:42 <h0tzenpl0tz> :t ($)
07:50:43 <lambdabot> forall a b. (a -> b) -> a -> b
07:50:54 <h0tzenpl0tz> :type ($)
07:50:56 <nikki93> cycloid: You saw the function f?
07:51:00 <nikki93> cycloid: See this.
07:51:05 <nikki93> @let y = f 3
07:51:06 <lambdabot>  <local>:8:4:
07:51:06 <lambdabot>      Ambiguous occurrence `f'
07:51:06 <lambdabot>      It could refer to either `L....
07:51:19 <nikki93> Better use better names next time lol.
07:51:29 <nikki93> @let cycloidFunc1 x y = x + y
07:51:31 <lambdabot>  Defined.
07:51:33 <h0tzenpl0tz> is $ a normal infix-function or something special?
07:51:44 <adrian_> h0tzenpl0tz: nothing special
07:51:45 <nikki93> @let cycloidFunc2 = cycloidFunc1 2
07:51:46 <lambdabot>  Defined.
07:51:49 <adrian_> @src ($)
07:51:49 <lambdabot> f $ x = f x
07:51:59 <roconnor> dcoutts: adding dependencies in order to provide instances can make packages less portable
07:52:13 <nikki93> > cycloidFunc2 3
07:52:14 <lambdabot>   5
07:52:15 <cycloid> thanks quicksiler, nikki93
07:52:17 <nikki93> > cycloidFunc2 5
07:52:19 <lambdabot>   7
07:52:22 <nikki93> > cycloidFunc2 20
07:52:23 <lambdabot>   22
07:52:38 <cycloid> (hands won't work correctly): thanks quicksilver, nikki93
07:52:44 <h0tzenpl0tz> adrian_: what is it`s exact purpose? i try it when using fct-composition and the types cripple...
07:52:45 <nikki93> See that? One argument is already bound to 2 because it is actualy cycloidFunc1 partially evaluated.
07:53:00 <nikki93> cycloidFunc1 x y = x + y
07:53:01 <adrian_> h0tzenpl0tz: it saves brackets
07:53:16 <adrian_> f $ g x = f (g x) = (f.g) x
07:53:28 <cycloid> nikki93: yah, working through the how-many-args thing helped me last night.  Much relief now.
07:53:30 <Olathe> > flip cycloidFunc1 2
07:53:31 <lambdabot>       Overlapping instances for Show (a -> a)
07:53:31 <lambdabot>        arising from a use of `s...
07:53:47 <adrian_> h0tzenpl0tz: f.g.h $ x is a common idiom
07:53:56 <h0tzenpl0tz> hm
07:54:05 <nikki93> cycloudFunc2 = cycloidFunc1 2 = cycloidFunc2 y = cycloidFunc1 2 y
07:54:17 <adrian_> it's much more readable than f ( g ( h x ) )
07:54:33 <nikki93> adrian_: I still don't get the . and $ stuff.
07:54:36 <nikki93> adrian_: Explain. :)
07:54:49 <nikki93> adrian_: Using examples or genericly.
07:54:49 <adrian_> . is function composition, like in mathematics
07:55:01 <Olathe> @src (.)
07:55:01 <lambdabot> (f . g) x = f (g x)
07:55:03 <nikki93> adrian_: I haven't reached functions yet in school actually.
07:55:08 <adrian_> f.g is the same as "do g first, then f"
07:55:19 <nikki93> adrian_: We had just polynomials first time this year.
07:55:27 <Olathe> @src ($)
07:55:28 <lambdabot> f $ x = f x
07:55:36 <nikki93> adrian_: What's function compisition? Call function x on function y's result with z?
07:55:37 <Olathe> Bah, that's an uninformative source.
07:55:55 <adrian_> say f x= x+1 and g x= 2*x then f.g = 2*(x+1)
07:56:10 <nikki93> Ohhhh...
07:56:13 <Olathe> No, it would be (2*x) + 1
07:56:19 <nikki93> Its like a polynomial except the variable IS the function.
07:56:20 <nikki93> :)
07:56:22 <adrian_> right
07:56:24 <Olathe> > let f x = x + 1; g x = 2*x in f.g $ x
07:56:26 <lambdabot>   2 * x + 1
07:56:51 <Olathe> > let f x = x + 1; g x = 2*x in g.f $ x
07:56:53 <lambdabot>   2 * (x + 1)
07:57:00 <adrian_> I got it backwards
07:57:02 <nikki93> Olathe: wtf? You can use variables and make it show the thunk?
07:57:04 <nikki93> Olathe: Nice.
07:57:08 <Olathe> @type x
07:57:09 <lambdabot> Expr
07:57:15 <adrian_> lambdabot is awesome
07:57:17 <Olathe> x is a nice object.
07:57:17 <nikki93> Olathe: That's only for x then?
07:57:25 <nikki93> > x + 1
07:57:26 <lambdabot>   x + 1
07:57:30 <Olathe> Well, I think y and z and a and b as well.
07:57:33 <adrian_> > y + 1
07:57:34 <nikki93> > 2 * (x + x)
07:57:35 <lambdabot>   y + 1
07:57:35 <Olathe> But, you can make your own.
07:57:35 <lambdabot>   2 * (x + x)
07:57:43 <Olathe> @let zomg = fun "zomg" :: Expr
07:57:44 <lambdabot>  Defined.
07:57:49 <Olathe> > let f x = x + 1; g x = 2*x in g.f $ zomg
07:57:50 <lambdabot>   2 * (zomg + 1)
07:57:53 <nikki93> > zomg + 1
07:57:54 <lambdabot>   zomg + 1
07:58:04 <ziman> nikki93, it's this library: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/simple-reflect
07:58:04 <nikki93> Ok, the thing is, I know WHAT . and $ are.
07:58:22 <nikki93> I just need a little bit of insight into their order and 'side' order.
07:58:34 <sw17ch> :t (.)
07:58:35 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
07:58:36 <Olathe> What do you mean by order ?
07:58:37 <bastl> I write a function that adds "indices" to duplicates in a list: ["a","b","b","c","c","a"] => ["a","b1","b2","c1","c2","a"]. How can i get it to number the a's to?? my code is here: http://pastebin.com/m702c6b18
07:58:38 <sw17ch> :t ($)
07:58:39 <lambdabot> forall a b. (a -> b) -> a -> b
07:58:40 <nikki93> Like, left first? right first? which first?
07:58:54 <sw17ch> (hello everyone)
07:59:08 <adrian_> bastl: sorting?
07:59:29 <adrian_> nikki93: you read from right to left
07:59:41 <adrian_> f.g.h is first h, then g, then f
07:59:47 <bastl> adrian_: then the order of the list is gone. how can i revert 'sort' ?
07:59:51 <Olathe> nikki93: With $, it does both sides before combining anything.
07:59:52 <nikki93> > let f x = x + 1, g x = x * 2 in g.f x
07:59:53 <lambdabot>   <no location info>: parse error on input `,'
08:00:00 <nikki93> > let f x = x + 1; g x = x * 2 in g.f x
08:00:01 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Expr'
08:00:02 <adrian_> bastl: you can't
08:00:07 <bastl> see ?
08:00:10 <bastl> :-)
08:00:11 <nikki93> > let f x = x + 1; g x = x * 2 in g.f $ x
08:00:13 <lambdabot>   (x + 1) * 2
08:00:19 <Olathe> nikki93: With (.), it does everything on the right first.
08:00:33 <nikki93> Olathe: Shh I'm experimenting.
08:00:34 <adrian_> bastl: if efficiency doesn't matter you can make multiple passes
08:00:48 <Olathe> You can do a indexed sort.
08:00:53 <nikki93> > let f x = x + 1; g x = x * 2; e x = x / 3 in g.f.e $ x
08:00:54 <lambdabot>   (x / 3 + 1) * 2
08:01:04 <nikki93> > let f x = x + 1; g x = x * 2; e x = x / 3 in g.e.f $ x
08:01:06 <lambdabot>   (x + 1) / 3 * 2
08:01:12 <bastl> Olathe: whats that?
08:01:13 <nikki93> > let f x = x + 1; g x = x * 2; e x = x / 3 in f.e.g $ x
08:01:14 <lambdabot>   x * 2 / 3 + 1
08:01:28 <Olathe> > let f = sortBy (comparing snd).zip [0..] in f ["a","b","b","c","c","a"]
08:01:30 <nikki93> Ahahaha! Its right to left! :)
08:01:30 <lambdabot>   [(0,"a"),(5,"a"),(1,"b"),(2,"b"),(3,"c"),(4,"c")]
08:01:43 <nikki93> I got it now.
08:01:56 <nikki93> . gives functions, $ gives result of function on right hand side.
08:01:59 <Olathe> > let f = map (map fst).groupBy snd.sortBy (comparing snd).zip [0..] in f ["a","b","b","c","c","a"]
08:02:00 <lambdabot>       Occurs check: cannot construct the infinite type:
08:02:00 <lambdabot>        b = (a, b) -> ...
08:02:01 <bastl> thanks
08:02:19 <nikki93> Is . like $ but for functions?
08:02:25 <loadquo>  > let f x = x + 1; g x = x * 2; e x = x / 3 in f.e.g  x
08:02:37 <loadquo> > let f x = x + 1; g x = x * 2; e x = x / 3 in f.e.g  x
08:02:38 <nikki93> loadquo: You need $ right?
08:02:39 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Expr'
08:03:11 <nikki93> > let f x = x + 1; g x = x * 2; e x = x / 3 in f.e.g $ x -- put '$' there
08:03:12 <lambdabot>   x * 2 / 3 + 1
08:03:29 <loadquo> You do, because otherwise g x binds first.
08:03:53 <nikki93> loadquo: I see...
08:04:06 <nikki93> loadquo: So if g x returns a function then?
08:04:35 <Olathe> > let f = map (sort.map fst).groupBy (\a b -> snd a == snd b).sortBy (comparing snd).zip [0..] in f ["a","b","b","c","c","a"]
08:04:37 <lambdabot>   [[0,5],[1,2],[3,4]]
08:04:46 <nikki93> > let f x = x + 1; g x = x [2,3,4]; e x = x / 3 in f.e.g product -- put '$' there
08:04:47 <lambdabot>       No instance for (Num (a -> b))
08:04:47 <lambdabot>        arising from a use of `g' at <int...
08:04:56 <nikki93> > let f x = x + 1; g x = x [2,3,4]; e x = x / 3 in f.e.g x
08:04:57 <lambdabot>   Couldn't match expected type `[t] -> t1'
08:05:05 <nikki93> > let f x = x + 1; g x = x [2,3,4]; e x = x / 3 in g x
08:05:06 <lambdabot>   Couldn't match expected type `[t] -> t1'
08:05:14 <nikki93> > let f x = x + 1; g x = x [2,3,4]; e x = x / 3 in g product
08:05:15 <lambdabot>   24
08:05:18 <adrian_> @hoogle on
08:05:19 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
08:05:19 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
08:05:19 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
08:05:24 <nikki93> > let f x = x + 1; g x = x [2,3,4]; e x = x / 3 in f.e.g product
08:05:25 <lambdabot>       No instance for (Num (a -> b))
08:05:25 <lambdabot>        arising from a use of `g' at <int...
08:05:46 <nikki93> loadquo: You said it binds g x first before all the dots?
08:05:52 <nikki93> So.. Why...
08:05:54 <nikki93> AHH I GOT IT
08:06:02 <nikki93> > let f x = x + 1; g x = x [2,3,4]; e x = x / 3 in f $ e $ g product
08:06:03 <lambdabot>   9.0
08:06:07 <nikki93> AHA!
08:06:09 <nikki93> Haskell FTW!
08:07:29 <nikki93> So... It does ((product [2,3,4]) / 3) + 1
08:07:31 <nikki93> Wonderful.
08:07:44 <nikki93> This stuff can eliminate the need for parentheses.
08:08:03 <nikki93> Both . and $ are left to right?
08:08:05 <loadquo> Because function application is the highest priority in binding
08:08:39 <sw17ch> > let f = (+1); g = (+2) in f $ g 10
08:08:41 <lambdabot>   13
08:08:47 <sw17ch> > let f = (+1); g = (+2) in f $ g 10 :: Expr
08:08:48 <lambdabot>   10 + 2 + 1
08:08:55 <sw17ch> > let f = (+1); g = (+2) in f . g 10 :: Expr
08:08:56 <lambdabot>   Couldn't match expected type `Expr' against inferred type `a1 -> a'
08:09:02 <nikki93> > let f x = x + 1; g x = x [2,3,4]; e x = x / 3 in f $ e $ g product :: Expr
08:09:04 <sw17ch> > let f = (+1); g = (+2) in f . g 10
08:09:04 <lambdabot>   1 * 2 * 3 * 4 / 3 + 1
08:09:05 <lambdabot>       No instance for (Num (a1 -> a))
08:09:05 <lambdabot>        arising from the literal `10' at...
08:09:10 <nikki93> Ohh cool.
08:09:15 <nikki93> Expr allows to SHOW the expression! :D
08:09:26 <sw17ch> > let f = (+1); g = (+2) in (f . g) 10
08:09:28 <lambdabot>   13
08:09:33 <sw17ch> > let f = (+1); g = (+2) in (f . g) 10 :: Expr
08:09:34 <lambdabot>   10 + 2 + 1
08:09:35 <nikki93> Does Expr work on lists of expressions?
08:09:48 <sw17ch> > map (+1) [1..10] :: Expr
08:09:49 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[a]'
08:09:50 <adrian_> > [x]
08:09:51 <lambdabot>   [x]
08:09:56 <adrian_> works
08:09:56 <sw17ch> > map (+1) [1..10] :: [Expr]
08:09:57 <lambdabot>   [1 + 1,2 + 1,3 + 1,4 + 1,5 + 1,6 + 1,7 + 1,8 + 1,9 + 1,10 + 1]
08:10:11 <nikki93> sw17ch: Got it.
08:10:19 <nikki93> sw17ch: Thanks a lot man, you explained well without even talking. :)
08:10:24 * sw17ch nods :P
08:10:31 <nikki93> You're dumb. :P
08:10:40 <sw17ch> occasionally, yes
08:10:53 <nikki93> sw17ch: This way I can look into a lot of my functions and see them in action.
08:11:07 <sw17ch> it's more useful to see the difference in foldl and foldr
08:11:21 <sw17ch> > foldr (+) 0 [1..10]) :: Expr
08:11:22 <lambdabot>   <no location info>: parse error on input `)'
08:11:22 <nikki93> sw17ch: Ok, wait. Where's Expr? (which module)
08:11:26 <sw17ch> > foldr (+) 0 [1..10] :: Expr
08:11:27 <lambdabot>   1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + 0)))))))))
08:11:37 <sw17ch> i think it's built into lambdabot
08:11:44 <sw17ch> i'm not entirely sure how itw orks
08:11:51 <nikki93> sw17ch: But it'd be really usefull in ghci!
08:11:58 <sw17ch> that's been stated before :)
08:12:02 <quicksilver> @where Expr
08:12:02 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
08:12:08 <quicksilver> ask and ye shall receive.
08:12:20 <ksf> cabal: dependencies conflict: ghc-6.10.1 requires process ==1.0.1.0 however
08:12:20 <ksf> process-1.0.1.0 was excluded because ghc-6.10.1 requires process ==1.0.1.1
08:12:23 <ehird> quicksilver: a million pounds?
08:12:24 <ksf> now come on
08:12:49 * sw17ch notes that complaining about something in Haskell--like the difficulty with names like Monoid--usually prompts a book's worth of documentation describing the topic of discussion
08:13:00 <ehird> warm fuzzy things
08:13:19 <quicksilver> and on hackage here : http://yoast.com/twitter-analytics/
08:13:43 <quicksilver> I'm not sure if that's the exact version LB uses.
08:13:57 <nikki93> How to unparenthesise this: findSumInFac n = sum (map digitToInt (show (factorial n)))
08:14:01 <quicksilver> Cale: would be nice if LB could show the versions of the packages it has loaded.
08:14:06 <ehird> nikki93: $
08:14:15 <ehird> sum . map . digitToInt . show . factorial $ n
08:14:24 <nikki93> ehird: Wait.. What? That works?
08:14:26 <quicksilver> nikki93: sum . map digitToInt . show . factorial $ n
08:14:30 <quicksilver> ehird: has one too many .
08:14:34 <ehird> nikki93: Err, yes, but what quicksilver said
08:14:38 <ehird> And why wouldn't it?
08:14:39 <ehird> :t (.)
08:14:44 <ehird> :t ($)
08:14:45 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:14:47 <lambdabot> forall a b. (a -> b) -> a -> b
08:14:48 <nikki93> No I still don't get the . vs $ thing.
08:14:48 <Saizan> ksf: you either have an haskell98-1.0.1.0 or Cabal-1.6.0.1 compiled against process-1.0.1.1
08:14:54 <ehird> nikki93: see those two type sigs
08:14:54 <nikki93> I know the technical part but the 'concept'.
08:15:02 <ehird> (a . b) c        ==                a (b c)
08:15:06 <ehird> a $ b         ==      a b
08:15:07 <quicksilver> > sum . map digitToInt . show . factorial $ 10
08:15:07 <lambdabot>   Not in scope: `factorial'
08:15:12 <quicksilver> duh
08:15:15 <ehird> so        a . b $ c              ==                   a (b c)
08:15:27 <nikki93> @let factorial n = product [1..n]
08:15:28 <lambdabot>  Defined.
08:15:34 <faXx> ehird: coding whitespace alot? :P
08:15:37 <quicksilver> > sum . map digitToInt . show . factorial $ 10
08:15:38 <lambdabot>   27
08:15:39 <nikki93> > sum . map digitToInt . show . factorial $ 10
08:15:39 <ehird> faXx: heh
08:15:40 <lambdabot>   27
08:15:43 <nikki93> > sum . map digitToInt . show . factorial $ 100
08:15:44 <lambdabot>   648
08:15:55 <nikki93> Yeah its correct. I did it for Project Euler. :)
08:16:13 <Twey> Arrrgh, so much idiocy on php.net
08:16:19 <nikki93> > sum . map digitToInt . show . factorial $ 100 :: Expr
08:16:21 <lambdabot>   Couldn't match expected type `Expr' against inferred type `Int'
08:16:32 <nikki93> > 1 + 2
08:16:33 <lambdabot>   3
08:16:37 <nikki93> > 1 + 2 :: Expr
08:16:38 <lambdabot>   1 + 2
08:16:47 <nikki93> > product [1..10] :: Expr
08:16:48 <lambdabot>   1 * 1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 * 10
08:16:55 <Twey> nikki93: a $ b applies a to b, and a . b creates a new function which is the result of applying first b, then a, to the provided argument
08:17:09 <tromp__> > product [1..100]
08:17:11 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
08:17:20 <Twey> . is like + for functions :)
08:17:28 <ehird> Twey: not really
08:17:29 <sw17ch> @pl findSumInFac n = sum (map digitToInt (show (factorial n)))
08:17:29 <lambdabot> findSumInFac = sum . map digitToInt . show . factorial
08:17:38 <Twey> ehird: Kind of
08:17:43 <nikki93> > let getPowersOfTwo n = map (\n -> 2 ^ n) [0..n] in (getPowersOfTwo 5) :: Expr
08:17:44 <ehird> Not really
08:17:44 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[t]'
08:17:44 <ehird> :P
08:17:50 <Twey> It 'adds them together' to produce a new function
08:18:01 <Twey> Are you just saying that because it isn't associative?  :-P
08:18:05 <faXx> function composition i believe it is called
08:18:09 <nikki93> > let getPowersOfTwo n = map (2^) [0..n] in (getPowersOfTwo 5) :: Expr
08:18:09 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[t]'
08:18:12 <Twey> Yes, that's what it is
08:18:21 <nikki93> > let getPowersOfTwo n = map (2^) [0..n] in getPowersOfTwo 5
08:18:22 <lambdabot>   [1,2,4,8,16,32]
08:18:25 <loadquo> > let getPowersOfTwo n = map (\n -> 2 ^ n) [0..n] in (getPowersOfTwo 5) :: [Expr]
08:18:27 <lambdabot>   [1,2,2 * 2,2 * 2 * 2,2 * 2 * (2 * 2),2 * 2 * (2 * 2) * 2]
08:18:31 <nikki93> > let getPowersOfTwo n = map (2^) [0..n] in (getPowersOfTwo 5) :: [Expr]
08:18:32 <lambdabot>   [1,2,2 * 2,2 * 2 * 2,2 * 2 * (2 * 2),2 * 2 * (2 * 2) * 2]
08:18:43 <nikki93> loadquo: You stole my idea! >_<
08:18:51 <nikki93> I thought of it before you typed it. :)
08:18:55 <vixey> > let double = join (+) in iterate double 1
08:18:56 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
08:19:11 <nikki93> vixey: I'm not that good yet. :)
08:19:18 <nikki93> @hoogle iterate
08:19:18 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
08:19:18 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
08:19:18 <lambdabot> Data.ByteString.Lazy iterate :: (Word8 -> Word8) -> Word8 -> ByteString
08:19:19 <ksf> Saizan, both of those came with ghc 6.10.1
08:19:24 <nikki93> :t iterate
08:19:24 <lambdabot> forall a. (a -> a) -> a -> [a]
08:19:25 <vixey> > iterate f x
08:19:26 <lambdabot>       Ambiguous occurrence `f'
08:19:26 <lambdabot>      It could refer to either `L.f', defined a...
08:19:32 <Twey> > let double = (*2) in iterate double 1
08:19:33 <nikki93> vixey: Loosah!
08:19:33 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
08:19:35 <vixey> @undef
08:19:35 <faXx> > iterate id 'e'
08:19:36 <lambdabot>   "eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee...
08:19:37 <Saizan> ksf: sure you haven't rebuild those?
08:19:37 <ksf> ...dunno what pulled process 1.0.1.1 yet, though.
08:19:39 <vixey> > iterate f x
08:19:40 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
08:19:44 <Twey> Shorter :-P
08:19:58 <vixey> nikki93, here is what iterate does ^
08:20:08 <ksf> yes. they're installed system-wide, and portage doesn't report having installed them.
08:20:11 <nikki93> > map f [1..n]
08:20:11 <lambdabot>   Add a type signature
08:20:16 <Saizan> ksf: you can tell their dependencies with ghc-pkg field $pkg depends
08:20:17 <nikki93> lambdabot: Get out!
08:20:22 * Twey chuckles.
08:20:26 <nikki93> > map f [1..10]
08:20:27 <Twey> > map f [1..n] :: Expr
08:20:27 <lambdabot>   Add a type signature
08:20:28 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[b]'
08:20:30 <Olathe> bastl: http://pastebin.com/m1a2e2d48
08:20:31 * ksf wants cabal uninstall
08:20:32 <Twey> Duh
08:20:34 <Twey> > map f [1..n] :: [Expr]
08:20:35 <lambdabot>   * Exception: not a number
08:20:37 * nikki93 chucklesalot
08:20:40 <Twey> T_T
08:20:42 <Twey> Oh
08:20:44 <Twey> n isn't a number
08:20:46 <Twey> Silly
08:20:52 <nikki93> Twey: Hahahahahahahaahha looosaaahh!
08:20:53 <Twey> > map f [1..] :: [Expr]
08:20:55 <lambdabot>   [f 1,f 2,f 3,f 4,f 5,f 6,f 7,f 8,f 9,f 10,f 11,f 12,f 13,f 14,f 15,f 16,f 1...
08:20:55 <tromp__> > map f [1..9]
08:20:56 <lambdabot>   Add a type signature
08:21:01 <Twey> Hey, it's your code :-P
08:21:30 <ksf> ah wth, i'm going to move .cabal and .ghc aside.
08:21:34 <vixey> > 30 `mod` (3 :: Expr)
08:21:35 <lambdabot>   30 `mod` 3
08:21:44 <nikki93> > let laughAtTwey n = if (n > 0) then "ha" ++ laughAtTwey (n - 1) else "aa Twey! :P
08:21:45 <lambdabot>   <no location info>:
08:21:45 <lambdabot>      lexical error in string/character literal at chara...
08:21:45 <vixey> > mod 30 (3 :: Expr)
08:21:46 <lambdabot>   30 `mod` 3
08:21:53 * Twey chuckles.
08:21:58 * Twey pats \b.
08:22:01 <nikki93> > let laughAtTwey n = if (n > 0) then "ha" ++ laughAtTwey (n - 1) else "aa Twey! :P" in "Ha" + (laughAtTwey 5)
08:22:02 <lambdabot>       No instance for (Num [Char])
08:22:02 <lambdabot>        arising from a use of `+' at <inter...
08:22:09 <faXx> :D
08:22:09 <bastl> Olathe: wow!
08:22:10 <nikki93> > let laughAtTwey n = if (n > 0) then "ha" ++ laughAtTwey (n - 1) else "aa Twey! :P" in "Ha" ++ (laughAtTwey 5)
08:22:11 <lambdabot>   "Hahahahahahaaa Twey! :P"
08:22:15 <bastl> Thanks!
08:22:22 <ksf> there, works.
08:22:29 <Olathe> bastl: You're welcome.
08:22:46 <loadquo> > itererate ++ "ha"
08:22:48 <lambdabot>   Not in scope: `itererate'
08:22:51 <nikki93> > let laughAtTwey n = if (n > 0) then "ha" ++ laughAtTwey (n - 1) else "aa Twey! :P" in "Ha" ++ (laughAtTwey 8)
08:22:52 <lambdabot>   "Hahahahahahahahahaaa Twey! :P"
08:22:55 <loadquo> > iterate ++ "ha"
08:22:56 <lambdabot>   Couldn't match expected type `[a]'
08:22:57 <nikki93> loadquo: Hahaha loosah!
08:23:06 <ehird> > iterate (++) "ha"
08:23:06 <nikki93> > let laughAtTwey n = if (n > 0) then "ha" ++ laughAtTwey (n - 1) else "aa loadquo! :P" in "Ha" ++ (laughAtTwey 8)
08:23:07 <lambdabot>   Couldn't match expected type `[a]'
08:23:08 <lambdabot>   "Hahahahahahahahahaaa loadquo! :P"
08:23:23 <ehird> > "Ha" + iterate ("ha":) []
08:23:24 <lambdabot>   Couldn't match expected type `Char'
08:23:30 <ehird> :t iterate
08:23:31 <lambdabot> forall a. (a -> a) -> a -> [a]
08:23:36 <faXx> > iterate (++"ha") "Ha"
08:23:36 <Olathe> + is bad there
08:23:37 <ehird> > "Ha" ++ iterate ("ha":) []
08:23:37 <lambdabot>   ["Ha","Haha","Hahaha","Hahahaha","Hahahahaha","Hahahahahaha","Hahahahahahah...
08:23:38 <lambdabot>   Couldn't match expected type `Char'
08:23:49 <ehird> > "Ha" ++ (iterate ("ha":) [] !! 10) ++ " nikki93"
08:23:50 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
08:23:53 <nikki93> > let laughAtPerson n y = if (n > 0) then "ha" ++ laughAtTwey (n - 1) else "aa " ++ y ++ "! :P" in "Ha" ++ (laughAtTwey 8 "luadquo")
08:23:54 <lambdabot>   Not in scope: `laughAtTwey'Not in scope: `laughAtTwey'
08:23:59 <faXx> > concat . iterate (++"ha") $ "Ha"
08:24:00 <lambdabot>   "HaHahaHahahaHahahahaHahahahahaHahahahahahaHahahahahahahaHahahahahahahahaHa...
08:24:11 <nikki93> > let laughAtPerson n y = if (n > 0) then "ha" ++ laughAtPersony (n - 1) y else "aa " ++ y ++ "! :P" in "Ha" ++ (laughAtPerson 8 "luadquo")
08:24:12 <lambdabot>   Not in scope: `laughAtPersony'
08:24:14 <ehird> > iterate ("ha":) []
08:24:16 <lambdabot>   [[],["ha"],["ha","ha"],["ha","ha","ha"],["ha","ha","ha","ha"],["ha","ha","h...
08:24:19 <nikki93> > let laughAtPerson n y = if (n > 0) then "ha" ++ laughAtPerson (n - 1) y else "aa " ++ y ++ "! :P" in "Ha" ++ (laughAtPerson 8 "luadquo")
08:24:20 <lambdabot>   "Hahahahahahahahahaaa luadquo! :P"
08:24:22 <ehird> > iterate ("ha"++) ""
08:24:23 <lambdabot>   ["","ha","haha","hahaha","hahahaha","hahahahaha","hahahahahaha","hahahahaha...
08:24:26 <ehird> > iterate ("ha"++) "Ha"
08:24:28 <lambdabot>   ["Ha","haHa","hahaHa","hahahaHa","hahahahaHa","hahahahahaHa","hahahahahahaH...
08:24:29 <nikki93> > let laughAtPerson n y = if (n > 0) then "ha" ++ laughAtPerson (n - 1) y else "aa " ++ y ++ "! :P" in "Ha" ++ (laughAtPerson 8 "ehird")
08:24:30 <lambdabot>   "Hahahahahahahahahaaa ehird! :P"
08:24:42 * vixey . o O ( { x | f(x) < x } )
08:24:57 <ehird> @let laugh p n = unwords [iterate ("ha"++) "Ha" !! n, p ++ "!"]
08:24:57 <nikki93> @remember nikki93 > let laughAtPerson n y = if (n > 0) then "ha" ++ laughAtPerson (n - 1) y else "aa " ++ y ++ "! :P" in "Ha" ++ (laughAtPerson 8 "ehird")
08:24:58 <lambdabot>  Defined.
08:24:58 <lambdabot> I will remember.
08:25:01 <ehird> > laugh "nikki93" 10
08:25:03 <lambdabot>   "hahahahahahahahahahaHa nikki93!"
08:25:09 <ehird> @let laugh p n = unwords [iterate (++"ha") "Ha" !! n, p ++ "!"]
08:25:10 <lambdabot>  <local>:1:0:
08:25:10 <lambdabot>      Warning: Pattern match(es) are overlapped
08:25:10 <lambdabot>               In...
08:25:14 <nikki93> ehird: lol the capitalised Ha comes last.
08:25:15 <ehird> @undefine laugh
08:25:20 <ehird> @let laugh p n = unwords [iterate (++"ha") "Ha" !! n, p ++ "!"]
08:25:21 <lambdabot>  Defined.
08:25:28 <ehird> > laugh "nikki93" 10
08:25:30 <lambdabot>   "Hahahahahahahahahahaha nikki93!"
08:25:34 <BONUS> haha, edward kmett owns http://www.reddit.com/r/programming/comments/7r31t/is_this_even_doable/c075ovl
08:25:35 <ehird> Tada.
08:25:41 <nikki93> @quote nikki93
08:25:42 <lambdabot> nikki93 says: > let laughAtPerson n y = if (n > 0) then "ha" ++ laughAtPerson (n - 1) y else "aa " ++ y ++ "! :P" in "Ha" ++ (laughAtPerson 8 "ehird")
08:25:49 <nikki93> > let laughAtPerson n y = if (n > 0) then "ha" ++ laughAtPerson (n - 1) y else "aa " ++ y ++ "! :P" in "Ha" ++ (laughAtPerson 8 "ehird")
08:25:51 <lambdabot>   "Hahahahahahahahahaaa ehird! :P"
08:25:53 <ehird> > laugh "nikki93" 20
08:25:54 <lambdabot>   "Hahahahahahahahahahahahahahahahahahahahaha nikki93!"
08:25:55 <nikki93> Easily accessible too. :P
08:26:04 <nikki93> > let laughAtPerson n y = if (n > 0) then "ha" ++ laughAtPerson (n - 1) y else "aa " ++ y ++ "! :P" in "Ha" ++ (laughAtPerson 23 "ehird")
08:26:05 <lambdabot>   "Hahahahahahahahahahahahahahahahahahahahahahahahaaa ehird! :P"
08:26:16 <ehird> @remember laugh laugh p n = unwords [iterate (++"ha") "Ha" !! n, p ++ "!"]
08:26:16 <lambdabot> It is forever etched in my memory.
08:26:20 <ehird> @quote laugh
08:26:21 <lambdabot> laugh says: laugh p n = unwords [iterate (++"ha") "Ha" !! n, p ++ "!"]
08:26:23 <ehird> Tada.
08:26:28 <ehird> Hm.
08:26:30 <ehird> Should be laugh n p
08:26:35 <ehird> @forget laugh
08:26:35 <lambdabot> Incorrect arguments to quote
08:26:39 <ehird> @forget laugh laugh p n = unwords [iterate (++"ha") "Ha" !! n,  p ++ "!"]
08:26:40 <lambdabot> No match.
08:26:46 <nikki93> > let laughAtPerson n y = if (n > 0) then "ha" ++ laughAtPerson (n - 1) y else "aa " ++ y ++ "! :P" in "Ha" ++ (laughAtPerson 23 "ehird")
08:26:47 <lambdabot>   "Hahahahahahahahahahahahahahahahahahahahahahahahaaa ehird! :P"
08:26:48 <ehird> @forget laugh p n = unwords [iterate (++"ha") "Ha" !! n, p ++ "!"]
08:26:48 <lambdabot> No match.
08:26:51 <ehird> Bah.
08:27:08 <Twey> Heh
08:27:10 <nikki93> > let laughAtPerson n y = if (n > 0) then "ha" ++ laughAtPerson (n - 1) y else "aa " ++ y ++ "! :P, you couldn't make lambdabot undremember it!" in "Ha" ++ (laughAtPerson 23 "ehird")
08:27:14 <lambdabot>   "Hahahahahahahahahahahahahahahahahahahahahahahahaaa ehird! :P, you couldn't...
08:27:20 <nikki93> > let laughAtPerson n y = if (n > 0) then "ha" ++ laughAtPerson (n - 1) y else "aa " ++ y ++ "! :P, you couldn't make lambdabot undremember it!" in "Ha" ++ (laughAtPerson 5 "ehird")
08:27:27 <Olathe> > let intersperseEvery n x = concat.intersperse [x].map (take n).takeWhile (not.null).iterate (drop n) in concat.intersperseEvery 2 "*hack cough*".iterate (++"ha") $ "Ha"
08:27:27 <ehird> You failed at laughing at me. The irony is delicious.
08:27:33 <lambdabot>   "Hahahahahahaaa ehird! :P, you couldn't make lambdabot undremember it!"
08:27:35 <lambdabot>   "HaHaha*hack cough*HahahaHahahaha*hack cough*HahahahahaHahahahahaha*hack co...
08:27:38 <ehird> Undremember.
08:27:41 <ehird> UNDREMEMBER
08:27:47 <nikki93> ehird: HAhahahahaah.
08:28:29 <nikki93> Haskell is FTW for laughing at people?
08:28:33 <kaol> @users
08:28:34 <lambdabot> Maximum users seen in #haskell: 612, currently: 610 (99.7%), active: 23 (3.8%)
08:28:37 <nikki93> @faw can Haskell be used to laugh at people?
08:28:37 <lambdabot> The answer is: Yes! Haskell can do that.
08:28:41 <nikki93> @faw can Haskell be used to laugh at people?
08:28:42 <lambdabot> The answer is: Yes! Haskell can do that.
08:28:44 <kaol> can't you find a bit smaller audience for that?
08:28:48 <ehird> faw
08:28:49 <nikki93> 'faw'? :o
08:29:12 <nikki93> The fun part is it actually understood? O_O
08:29:14 <Olathe> @let intersperseEvery n x = concat.intersperse [x].map (take n).takeWhile (not.null).iterate (drop n)
08:29:15 <lambdabot>  Defined.
08:29:19 <Olathe> @type intersperse
08:29:20 <lambdabot> forall a. a -> [a] -> [a]
08:29:21 <Olathe> @type intersperseEvery
08:29:22 <lambdabot> forall a. Int -> a -> [a] -> [a]
08:29:31 <vixey> kaol, it's been like this for days.. :p
08:29:46 <ehird> define this
08:29:50 <nikki93> > interpserseEvery 3 "Hhaha" "Olathe"
08:29:51 <lambdabot>   Not in scope: `interpserseEvery'
08:29:58 <nikki93> > intersperseEvery 3 "Hhaha" "Olathe"
08:29:59 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
08:30:04 <nikki93> Bah.
08:30:10 <Olathe> @type intercalate
08:30:11 <lambdabot> forall a. [a] -> [[a]] -> [a]
08:30:30 <Olathe> Hmm...
08:30:33 <nikki93> > let laughAtPerson n y = if (n > 0) then "ha" ++ laughAtPerson (n - 1) y else "aa " ++ y ++ "! :P" in "Ha" ++ (laughAtPerson 8 "Olathe")
08:30:34 <lambdabot>   "Hahahahahahahahahaaa Olathe! :P"
08:30:45 <ehird> Your laugh at is still way inferior to mine.
08:30:46 <nikki93> Works == good
08:31:05 <nikki93> ehird: I'm newHaskellBoy aka nikki93.
08:31:15 <ehird> and?
08:31:24 <Olathe> > let insertEvery n x = concat.intersperse x.map (take n).takeWhile (not.null).iterate (drop n) in insertEvery 3 "test" "zomg kthx gdbai"
08:31:25 <nikki93> ehird: And I'm new to haskell
08:31:25 <lambdabot>   "zomtestg ktestthxtest gdtestbai"
08:31:35 <Olathe> @let insertEvery n x = concat.intersperse x.map (take n).takeWhile (not.null).iterate (drop n)
08:31:37 <lambdabot>  Defined.
08:31:53 <nikki93> > insertEvery 3 "Olathe" "Hahahahaha hahahaha hahaha"
08:31:55 <lambdabot>   "HahOlatheahaOlathehahOlathea hOlatheahaOlathehahOlathea hOlatheahaOlatheha"
08:31:59 <Olathe> Heheh
08:31:59 <nikki93> > insertEvery 3 " Olathe " "Hahahahaha hahahaha hahaha"
08:32:01 <lambdabot>   "Hah Olathe aha Olathe hah Olathe a h Olathe aha Olathe hah Olathe a h Olat...
08:32:10 <nikki93> > insertEvery 7 " Olathe " "Hahahahaha hahahaha hahaha"
08:32:11 <lambdabot>   "Hahahah Olathe aha hah Olathe ahaha h Olathe ahaha"
08:32:22 <nikki93> Haskell, the new way to laugh.
08:32:23 <vixey> :t filterM (const [True,False])
08:32:25 <lambdabot> forall a. [a] -> [[a]]
08:32:31 <vixey> > filterM (const [True,False]) =<< "Hahahahaha hahahaha hahaha"
08:32:32 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
08:32:34 <Olathe> @src filterM
08:32:34 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
08:32:36 <vixey> > filterM (const [True,False]) "Hahahahaha hahahaha hahaha"
08:32:37 <lambdabot>   ["Hahahahaha hahahaha hahaha","Hahahahaha hahahaha hahah","Hahahahaha hahah...
08:32:43 <Olathe> @src [] filterM
08:32:44 <lambdabot> Source not found. Take a stress pill and think things over.
08:32:51 <vixey> > filterM (const [True,False]) "Haha"
08:32:52 <lambdabot>   ["Haha","Hah","Haa","Ha","Hha","Hh","Ha","H","aha","ah","aa","a","ha","h","...
08:32:54 <nikki93> Olathe, you need ze pillz.
08:32:54 <Ferdirand> is there a standard wipWith-like function that instead of dropping the tail of the longer list, would append it to the result ?
08:32:55 <Olathe> > filterM (const [True,False]) "Hahahahaha hahahaha hahaha"
08:32:57 <lambdabot>   ["Hahahahaha hahahaha hahaha","Hahahahaha hahahaha hahah","Hahahahaha hahah...
08:33:10 <vixey> Ferdirand, no.. you can write it though..
08:33:11 <nikki93> WAIT CUSTOMER.
08:33:18 <Olathe> Ferdirand: Not a standard one, but you can make one.
08:33:30 <Twey> Ferdirand: Doesn't make sense
08:33:33 <ehird> nikki93 could you stop it please
08:33:39 <nikki93> ehird: Stopped.
08:33:40 <Twey> It's not type-safe
08:33:44 <Ferdirand> Twey: it does if it takes (a->a->a) instead of (a->b->c)
08:33:45 <Twey> :t zip
08:33:46 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
08:33:47 <Twey> Yes
08:33:56 <vixey> of course it's type safe
08:34:01 <Ferdirand> which is not that uncommon
08:34:05 <nikki93> ReturnType should be equal to type of longer list.
08:34:07 <Twey> vixey: ?
08:34:14 <Olathe> > let zipWith' _ as [] = as; zipWith' _ [] bs = bs; zipWith' f (a:as) (b:bs) = f a b:zipWith' f as bs in zipWith' (+) [1..3] [1..10]
08:34:15 <lambdabot>   [2,4,6,4,5,6,7,8,9,10]
08:34:17 <vixey> .. this is haskell (*hides the unsafe...*)
08:34:22 <Olathe> @type let zipWith' _ as [] = as; zipWith' _ [] bs = bs; zipWith' f (a:as) (b:bs) = f a b:zipWith' f as bs in zipWith'
08:34:23 <Twey> Hahaha
08:34:24 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a] -> [a]
08:34:27 <Ferdirand> except you cannot predict which list will be the longer one, but yes
08:34:32 <Olathe> The function has to be (a -> a -> a), of course.
08:34:34 <earthy> or it could take a 'missing element value' to be repeated for the tail of the other list
08:34:54 <quicksilver> or you could pass a function
08:35:01 <quicksilver> (Maybe a -> Maybe b -> c)
08:35:04 <quicksilver> which encodes that choice
08:35:13 <Twey> That's a nice idea
08:35:15 <Ferdirand> quicksilver: i like that
08:35:19 <nikki93> Ferdirand: Are you sure that both lists have the same type and that the function returns and takes same types?
08:35:20 <quicksilver> would be a faff for those cases where you don't need the generality of couse.
08:35:25 <Olathe> > let zipWith' _ as [] = as; zipWith' _ [] bs = bs; zipWith' f (a:as) (b:bs) = f a b:zipWith' f as bs in zipWith' (++) ["zomg"] ["kthx", "kthx"]
08:35:26 <lambdabot>   ["zomgkthx","kthx"]
08:35:28 <Twey> nikki93: We are now
08:35:36 <nikki93> Twey: Yay?
08:35:41 <Twey> 16:33:44 < Ferdirand> Twey: it does if it takes (a->a->a) instead of (a->b->c)
08:35:57 <Twey> nikki93: IOW, 'be safe or burn'
08:36:03 <nikki93> Twey: Oh I thought Olathe said that and he assumed.
08:36:06 <Ferdirand> well that was for the sake of generality
08:36:15 <Ferdirand> of course i can write my own, it just feels redundant
08:36:30 <nikki93> Ferdirand: Why redundant?
08:37:04 <Olathe> @type let zipWith' _ as [] = map (flip f Nothing) as; zipWith' _ [] bs = map (f Nothing) bs; zipWith' f (a:as) (b:bs) = f a b:zipWith' f as bs in zipWith'
08:37:05 <lambdabot> forall a a1 b. (Show a1, SimpleReflect.FromExpr b, Show a) => (a -> a1 -> b) -> [a] -> [a1] -> [b]
08:37:16 <Olathe> @type let zipWith' f as [] = map (flip f Nothing) as; zipWith' f [] bs = map (f Nothing) bs; zipWith' f (a:as) (b:bs) = f a b:zipWith' f as bs in zipWith'
08:37:17 <lambdabot> forall a a1 c. (Maybe a -> Maybe a1 -> c) -> [Maybe a] -> [Maybe a1] -> [c]
08:37:25 <Olathe> Hmm...
08:37:51 <Olathe> @type let zipWith' f as [] = map (flip f Nothing.Just) as; zipWith' f [] bs = map (f Nothing.Just) bs; zipWith' f (a:as) (b:bs) = f (Just a) (Just b):zipWith' f as bs in zipWith'
08:37:52 <lambdabot> Couldn't find qualified module.
08:38:00 <Olathe> Qualified module ?
08:38:07 <Olathe> @type let zipWith' f as [] = map (flip f Nothing . Just) as; zipWith' f [] bs = map (f Nothing . Just) bs; zipWith' f (a:as) (b:bs) = f (Just a) (Just b):zipWith' f as bs in zipWith'
08:38:08 <lambdabot> forall a a1 c. (Maybe a -> Maybe a1 -> c) -> [a] -> [a1] -> [c]
08:38:17 <nikki93> I see 'x <- getLine' in some places.
08:38:22 <nikki93> What does that mean?
08:38:24 <nikki93> 'binding'?
08:38:32 <nikki93> > xyz <- 3
08:38:33 <lambdabot>   <no location info>: parse error on input `<-'
08:38:38 <Ferdirand> nikki93: monadic bind, yes
08:38:38 <Olathe> @type getLine
08:38:40 <lambdabot> IO String
08:38:43 <vixey> nikki93, where?
08:38:57 <Olathe> nikki93: getLine gives an IO String. <- takes off the IO.
08:38:58 <nikki93> vixey: RWH, IO chapter, just started it.
08:39:03 <vixey> uhh
08:39:08 <Olathe> nikki93: So, x is a String.
08:39:09 * vixey wonders if RWH explains it.
08:39:17 <nikki93> vixey: I guess it does. :P
08:39:40 <loadquo> Nikki93: In a do block?
08:39:54 <Olathe> nikki93: Similarly, [1, 2, 3] is a [Int]. <- takes off the []. So, x <- [1, 2, 3] means x is an Int.
08:39:54 <nikki93> loadquo: Yep.
08:40:11 <nikki93> Is 'Monad' a 'built in' thing or an 'add-on'.
08:40:22 <nikki93> Like std::string and C++ vs char [] and C++.
08:40:42 <quicksilver> nikki93: it's not built-in, in the sense that you could write it yourself and it would work.
08:40:59 <quicksilver> nikki93: however, it is built-in in the sense that "do" is a keyword which is hardware to translate into Monad code.
08:41:13 <quicksilver> however "do" is pretty trivial syntactic sugar.
08:41:21 <nikki93> quicksilver: So it has a keyword for something that's not in the language? O_o
08:41:22 <Twey> quicksilver: ... computers on the brain?
08:41:23 <quicksilver> you don't need it.
08:41:28 <Gracenotes> hardware?
08:41:35 <quicksilver> hardwired
08:41:38 <Twey> Heh
08:41:38 <quicksilver> (sorry)
08:41:44 <nikki93> Wait...
08:41:53 <quicksilver> nikki93: it's in the language, in the sense that it's in the haskell98 spec.
08:41:59 <Olathe> nikki93: It has a keyword that translates certain operators to others, I think.
08:42:00 <Twey> nikki93: It is 'in the language'  it's part of the standard libraries
08:42:03 <Gracenotes> undoing is easily do-it-yourself
08:42:03 <quicksilver> nikki93: however it's not "special" in the sense that you could write it yourself.
08:42:06 <nikki93> Monad -> Haskell as char [] -> C++? or as std::string -> C++?
08:42:09 <Gracenotes> or you could get lambdabot to do it
08:42:10 <Olathe> nikki93: What those operators mean is defined after the language.
08:42:11 <quicksilver> except for the special do notation.
08:42:13 <Twey> in the sense that you couldn't**
08:42:15 <nikki93> quicksilver: Oh you mean override the 'usual' monad?
08:42:21 <quicksilver> in that sense it's more like std::sring
08:42:28 <quicksilver> i.e. you could write std::string yourself, if you wanted
08:42:33 <quicksilver> but it's parts of the standard library.
08:42:54 <Twey> There's nothing magical about it.
08:42:55 <nikki93> @src Monad
08:42:55 <ksf> wth does cabal-install try to install wxcore-0.10.5 even though it's clearly listed by ghc-pkg?
08:42:55 <lambdabot> class  Monad m  where
08:42:55 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
08:42:55 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
08:42:55 <lambdabot>     return      :: a -> m a
08:42:55 <lambdabot>     fail        :: String -> m a
08:43:02 <quicksilver> nikki93: you could write your own and call it MyMonad
08:43:08 <quicksilver> nikki93: and it would work exactly the same
08:43:17 <quicksilver> (except you couldn't use the "do" keyword with it)
08:43:18 <Twey> (except you wouldn't get do-notation)
08:43:20 <Twey> Heh
08:43:26 <nikki93> quicksilver: So *where* *is* this 'source code for Monad'?
08:43:26 <Olathe> @undo do { a <- x; return a }
08:43:26 <lambdabot> x >>= \ a -> return a
08:43:33 <Twey> nikki93: You just saw it
08:43:37 <quicksilver> nikki93: being a class, it doesn't have source code.
08:43:40 <Olathe> See, it turns <- into >>= and so on.
08:43:40 <quicksilver> it just has a list of methods.
08:43:44 <baaba> > fail "hi" :: Maybe Int
08:43:44 <Cale> nikki93: In the Prelude
08:43:44 <quicksilver> its instances have source code.
08:43:45 <lambdabot>   Nothing
08:43:50 <gwern> https://secure.wikimedia.org/wikipedia/en/wiki/John_Goerzen <-- huh. who knew?
08:43:58 <Twey> Individual monads just implement those functions
08:44:01 <Cale> It's sad that fail is in there.
08:44:24 <gwern> Cale: now don't start that 'fail is fail' thread again...
08:44:25 <Twey> Where is fail supposed to be, again?
08:44:26 <nikki93> Ok wait, quick question, entirely haskell-unrelated, can I ask?
08:44:41 <Cale> Twey: Perhaps in its own class.
08:44:45 <gwern> nikki93: you just did?
08:44:50 <Cale> Twey: MonadFail or something.
08:44:53 <Twey> Ah
08:44:58 <nikki93> Twey: I mean, I saw *what* it is, but not *where* it is...
08:45:00 <Twey> Yes, fair enough
08:45:02 <quicksilver> gwern: i didn't know he was involved in gopher.
08:45:06 <Olathe> Monorail
08:45:07 <Twey> nikki93: Ah.  Prelude, then.
08:45:10 * nikki93 kicks gwern. Hard.
08:45:11 <Cale> It used to be that there was MonadZero, and that was used to implement pattern match failure for do-notation.
08:45:20 <quicksilver> gwern: I think it's absurd that that gets higher billing than being former SPI president.
08:45:32 <gwern> quicksilver: well, he does have some sort of gopher-caching bot on his software page
08:45:42 <nikki93> Are HP dekstops good? My mom got an offer for getting HP stuff at low cost.
08:45:45 <gwern> quicksilver: it was probably written by a gopher fan
08:46:07 * gwern is legion. the individual gwer disperse under the force of nikki93's kick, and suffer minimal damage
08:46:13 * ksf thinks the wxhaskell build system is an utter mess
08:46:34 <Olathe> nikki93: If your mom is just surfing the Internet and sending e-mails, anything modern should be fine.
08:46:47 <nikki93> > let laughAtPerson n y = if (n > 0) then "ha" ++ laughAtPerson (n - 1) y else "aa " ++ y ++ "! :P" in "Ha" ++ (laughAtPerson 8 "gwern")
08:46:48 <lambdabot>   "Hahahahahahahahahaaa gwern! :P"
08:46:54 <nikki93> Olathe: Its for meee! :D
08:47:00 <Olathe> nikki93: Ahh.
08:47:42 <gwern> @seen CosmicRay
08:47:42 <lambdabot> CosmicRay is in #haskell and #haskell-blah. I don't know when CosmicRay last spoke.
08:47:48 <gwern> preflex: seen CosmicRay
08:47:49 <preflex>  CosmicRay was last seen on #haskell 19 hours, 23 minutes and 21 seconds ago, saying: heh
08:48:04 <nikki93> preflex: seen quicksilver
08:48:05 <preflex>  quicksilver was last seen on #ghc 28 seconds ago, saying: (Tag,Node)
08:48:05 <gwern> CosmicRay is goerzen, isn't he?
08:48:23 <Nafai> gwern: I believe so
08:49:17 <ksf> cabal-install _does_ use ghc-pkg to find out whether a dep is installed, doesn't it? if not, I'm going to be forced to hurt someone.
08:49:18 <gwern> @ask CosmicRay 1) do you know about the Wikipedia article on you? 2) looks like someone else is interested in cabal->deb, http://therning.org/magnus/archives/458 , did you ever get anywhere with that?
08:49:18 <lambdabot> Consider it noted.
08:49:19 <quicksilver> gwern: correct.
08:49:47 <gwern> it's kind of sad that by my count we've now had 4 or 5 groups work on cabal->deb, and we *still* don't have any usable tool
08:50:04 <nikki93> Quick question: I use ghc --make whutevah.hs now for quick compiling, what can I do to make all intermediate files go in a seperate 'obj' directory or something?
08:50:07 <gwern> (the linspire/seereason group, goerzen, therning, and someone I forget)
08:50:21 <gwern> nikki93: the manual covers that iirc
08:50:29 <nikki93> (with still having to type one command for building)
08:50:32 <nikki93> (without makefiles)
08:50:35 <PeakerWork> IMO, cabal is solving the wrong problem
08:51:03 <PeakerWork> if libraries aren't backwards-compatible, they should be renamed/imported in a different way- and cabal shouldn't try heuristically to put a bunch of incompatible versions in the same system under the same name
08:51:05 <quicksilver> gwern: you'd imagine Igloo would have some kind of interest.
08:51:23 <quicksilver> gwern: since he produced the existing debian packages (or at least, uploaded them)
08:51:46 <gwern> nikki93: there are options listed in the manual for modifying the build to stash files in various places
08:51:52 <gwern> quicksilver: well, I thought his big project used to be ghc, which such a tool wouldn't help with
08:51:55 <gwern> much
08:52:27 <gwern> PeakerWork: you say it's wrong, but then why does it feel so good?
08:52:42 <Igloo> gwern: The time consuming part of making package for the Debian archive is things like digging through all the copyright info
08:52:45 <Olathe> Is there a Windows installer for Cabal ?
08:52:54 <Twey> unsafePerformIO incest
08:53:23 <PeakerWork> gwern: it doesn't feel good to me - I have to manually prevent cabal from installing the new process-1.0.1.1 and bork my install
08:53:36 <nothingmuch> bah, No instance for (Show UTCTime), but the docs say there is one
08:53:48 <PeakerWork> gwern: if process-1.0.1.1 is installed in parallel with 1.0.1.0, I get packages that depend on both, and then I can't have them compile together
08:53:53 <quicksilver> nothingmuch: it's in Data.Time.Format
08:53:56 <quicksilver> nothingmuch: or something like that.
08:54:01 <quicksilver> Data.Time.Clock.Format?
08:54:04 * quicksilver is too lazy to check.
08:54:06 <gwern> PeakerWork: yes, I know about that
08:54:26 <nothingmuch> so there's no defaullt show = format "%something_standard" ?
08:54:27 <Olathe> Ahh, I think I found one.
08:54:37 <PeakerWork> gwern: Why is it a good idea to have a bunch of incompatible versions installed under the same name, if it causes real problems (can't compile these stuff together in the same compilation)?
08:55:03 <PeakerWork> if we had process1.0.1.0 and process1.0.1.1 as different package names, we could compile both in the same compilation
08:55:03 <gwern> I'm not defending it, as I've forgotten what that issue was about
08:55:17 <Twey> nothingmuch: There is, but only if the type elects to derive Show
08:55:24 <PeakerWork> if process1.0.1.1 is backwards compatible, it can share the name, and replace process1.0.1.0
08:55:38 <Twey> You can just stick a "... deriving Show" on the end of your type and it will get the default one
08:55:46 <nothingmuch> i'm showing a tuple ( UTCTime, String )
08:55:46 <dons> for those who didn't see it earlier, haskell for lawnmowers, http://www.reddit.com/r/programming/comments/7r3zz/haskell_for_lawnmowers/
08:55:48 <quicksilver> nothingmuch: the answer to your question is "No".
08:55:57 <quicksilver> nothingmuch: the answer to your problem, is to import the right module.
08:56:13 <int-e> code.haskell.org is back :)
08:56:14 <lambdabot> int-e: You have 1 new message. '/msg lambdabot @messages' to read it.
08:56:38 <nothingmuch> quicksilver: oh i get it now... and that works
08:56:39 <nothingmuch> thanks =)
08:56:43 <quicksilver> ;)
08:57:29 <nothingmuch> so the type class instance is imported separately from the type?
08:58:54 <newsham> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
08:59:07 <newsham> 100% exactly right.  i said that before but people say i'm wrong.. *sigh*
08:59:07 <PeakerWork> maybe cabal-install -- instead of hiding all but the depended version, could just "alias" the import-name to the right library name? So two incompatible versions are considered different names and thus can be installed at the same time, but the .cabal alias chooses which to use?
09:00:21 * ksf checks since when reactive doesn't come with Data.Reactive and gives up hoping phooey to work out of the box
09:00:26 <ehird> < newsham> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
09:00:27 * nothingmuch can relate to that
09:00:27 <quicksilver> nothingmuch: in this case. It's a misguided attempt to separate code.
09:00:29 <ehird> yes.
09:01:03 <ksf> is by any chance anyone hacking on a gui lib for reactive?
09:01:09 <quicksilver> nothingmuch: separating instances from their types doesn't really work very well in haskell, and it's probably not worth the hassle.
09:01:35 <nothingmuch> evidently it confuses n00bs
09:02:17 <Cale> I'm annoyed at having to import Control.Monad.Instances or Control.Monad.Reader to get an instance for (->) e
09:03:31 <Cale> also, it seems there's no instance (Monoid w) => Monad ((,) w) anywhere.
09:03:50 <quicksilver> Cale: well the reason is supposed to be error messages.
09:04:00 <quicksilver> agreed it's pretty dubious.
09:04:09 <Ferdirand> 8
09:04:11 <Ferdirand> oops
09:05:50 <nikki93> A function with a 'do' doesn't returnanything?
09:05:53 <nikki93> Its not an expression?
09:06:02 <quicksilver> nikki93: it is an expression.
09:06:08 <Zao> nikki93: The type of the do expression depends on the contents of it.
09:06:19 <quicksilver> nikki93: it returns something of the form (m a)
09:06:22 <nothingmuch> is there a prelude function that is like flip const?
09:06:25 <Zao> do { return () } :: m ()
09:06:26 <quicksilver> where m is some monad and a can be anything.
09:06:32 <quicksilver> @pl flip const
09:06:32 <lambdabot> const id
09:06:35 <newsham> nikki: the result of a do-block is the result of its last action
09:06:37 <quicksilver> nothingmuch: ^^
09:09:06 <nikki93> One can put a 'do' anywhere?
09:09:27 <newsham> do-blocks always have a type like "m a"
09:09:33 <ksf> it seems the easiest way to get a gui with haskell is to make a web interface.
09:09:42 <Trollinator> > repeat 0
09:09:43 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
09:09:46 <newsham> you can only use them in a context that expects such a type
09:10:08 <Gracenotes> ksf: that's the easiest way to get a GUI with any language :)
09:10:12 <newsham> ie. you cant use a do-block in a context where you want a normal "Int" result
09:10:15 <cnwdup> @src sum
09:10:16 <lambdabot> sum = foldl (+) 0
09:10:20 <vincenz> Congratulations on your new president, usa.
09:10:46 <ehird> vincenz: Yes! I heard they elected an indonesian fabric!
09:11:01 <ehird> I think it was muslin?
09:11:04 <ksf> I'd use grapefruit, but it doesn't seem to run on ghc 6.10 and it seems to be quite insane to use two FRP libraries simultaneously.
09:11:35 * vincenz peers at ehird 
09:11:53 <ksf> phooey would be really cool, but i don't seem to be able to get wxhaskell to install, and it's rather dated... but builds on reactive, at least.
09:12:22 <quicksilver> nikki93: yes. A do block is just an expression former.
09:12:22 <lucca> vincenz: now we don't need to claim to be canadians anymore, maybe
09:12:31 <quicksilver> nikki93: you can put it anywhere you want an expression.
09:12:49 <quicksilver> nikki93: of course, the type checked will complain if it is not the expected type
09:13:22 <Gracenotes> @undo do { x <- y; return (f x)}
09:13:22 <lambdabot> y >>= \ x -> return (f x)
09:13:38 <vincenz> lucca: :)
09:13:47 <Gracenotes> aka liftM
09:13:52 <ksf> I'm almost tempted to roll my own tk, with reactive doing the plumbing it should only be a matter of painting+layouting.
09:14:00 <monochrom> This function has a do-block and returns a list.  f x = do { y <- [x, x+1]; return (y*y) }
09:14:47 <ehird> monochrom: Still (m a).
09:14:52 <quicksilver> ksf: it would be good to have people working on attaching 'conventional' guis to reactive.
09:15:11 <quicksilver> ehird: nope.
09:15:17 <quicksilver> ehird: Num a => [a]
09:15:26 <monochrom> This function returns a maybe.  f x = do { guard (x>0); return (x*x) }
09:15:35 <quicksilver> :t let f x = do { y <- [x, x+1]; return (y*y) } in f
09:15:36 <ehird> quicksilver: [] is a monad.
09:15:36 <lambdabot> forall t. (Num t) => t -> [t]
09:15:38 <ehird> Thus, it is (m a).
09:15:52 <quicksilver> ehird: it conforms to that form, but it is not that type
09:15:59 <ehird> ...
09:16:01 <Gracenotes> monochrom: does it...?
09:16:02 <ehird> no duh
09:16:05 <quicksilver> as a type, (m a) is shorthand for forall m . m a
09:16:11 <quicksilver> (forall a as well)
09:16:16 <quicksilver> but yes, your point is taken.
09:16:17 <monochrom> Oh! Darn.
09:16:28 <Gracenotes> it'll work for any monad
09:16:41 <quicksilver> it's just a question of what "is" is supposed to mean, and where we choose to see the implicit foralls
09:17:02 <Gracenotes> monochrom: you could set the type of the function as a -> Maybe a, tho
09:17:15 <monochrom> I am following http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/ --- use more concrete examples.
09:17:39 <ksf> I don't even need a full-fledged gui system, just a few buttons and boxes. you wouldn't want to write shell bindings for qt if all you need is xmessage, either.
09:17:49 <monochrom> This function returns a maybe.  f x = do { guard (x>0); y <- Just x; return (sqrt y) }
09:17:56 <newsham> ?type return undefined
09:17:58 <lambdabot> forall a (m :: * -> *). (Monad m) => m a
09:18:20 <quicksilver> ksf: Tk sounds like a good target then
09:18:28 <quicksilver> ksf: it's a very good target for really lightweight stuff
09:18:35 <Gracenotes> @undo do { guard (x>0); y <- Just x; return (sqrt y) }
09:18:36 <lambdabot> guard (x > 0) >> Just x >>= \ y -> return (sqrt y)
09:18:40 <sw17ch> ugh... i think the hardest thing about going back to C from Haskell is that all the functions need to manually filter the data input to make sure they don't blow up
09:18:47 <sw17ch> properly typging things makes the code way to wordy
09:19:05 <sw17ch> and the succinct version explodes if you pass it a negative value
09:19:07 <Gracenotes> monochrom: the first function will work too
09:19:31 <Trollinator> sw17ch: C is a horrible, horrible language that just shouldn't be used IMO.
09:19:47 <newsham> C has its moments
09:19:55 <vixey> what? C is so much easier to use than haskell! :p
09:20:01 <sw17ch> Trollinator: C is actually a very nice language for what it was designed for. I'm an embedded programmer, so I have 16K of RAM on a *good* day
09:20:12 <monochrom> Use a ton of concrete counterexamples to derail a newbie's preconception.
09:20:13 <tromp__> C is more suited for the IOCCC
09:20:18 <Trollinator> and this comes from someone who makes his living by programming in C.
09:20:20 <gnuvince> sw17ch: Forth then?
09:20:34 <joma> well C doesnt have an alternative does it?
09:20:36 <sw17ch> gnuvince: ah, embedded programmer that has to work with others :)
09:20:42 <Trollinator> joma: C++.
09:20:53 <gnuvince> sw17ch: "Hell is other people"
09:21:05 <Trollinator> sw17ch: you can write programs that are just as efficient in C++.
09:21:12 <sw17ch> Trollinator: you'd be surprised...
09:21:15 <Trollinator> actually, more efficient in some cases.
09:21:21 <sw17ch> besides, C++ is a much worse language than C
09:21:22 <newsham> c++ is a horrible language :)
09:21:41 <newsham> and this comes from someone who used to make his living by programming in c++
09:21:41 <Trollinator> sw17ch: std::sort is usually faster than qsort
09:21:44 <vixey> o_O
09:21:47 <gnuvince> I imagine C compilers are much more readily available for small embedded systems that complete C++ compilers
09:21:48 <Trollinator> AND it's easier to use.
09:21:52 <ksf> actually, i was thinking fltk.
09:21:55 <ehird> 17:20 < joma> well C doesnt have an alternative does it?
09:22:06 <Trollinator> gnuvince: there are C++ compilers that generate C.
09:22:06 <monochrom> I don't like bashing other languages. If you do it because you are dissatisfied with your job, you should seek help.
09:22:08 <sw17ch> Trollinator: what about on my 8-bit microprocessor with 256 words of memory?
09:22:10 * vixey I think C vs C++ is not a worthwhile discussion here
09:22:30 <vixey> can only go bad :p
09:22:34 <sw17ch> these discussions are always my fault
09:22:49 <sw17ch> eventually i can't overcome the urge to whine on #haskell about C, and then this is the fallout
09:22:54 <sw17ch> :(
09:22:57 <Trollinator> sw17ch: many features in C++ don't have any runtime cost.
09:23:06 <Trollinator> such as templates.
09:23:12 <vegai> hey guys, note the nick ;)
09:23:20 <ddarius> monochrom: You shouldn't seek help, you should seek a new job.
09:23:21 <monochrom> I have Casio FX-702P with two 4-bit processors. Dual core do more. :)
09:23:32 <ksf> c++ vs c would be a valid discussion in #haskell if it wasn't clear that c++ ffi bindings are pain.
09:23:41 <sw17ch> ksf++
09:23:45 <roconnor> monochrom: together they are an 8-bit processor
09:23:49 <Trollinator> sw17ch: well, the software that runs on a 256-word processor is probably simple enough for the language not to matter.
09:24:18 * sw17ch notes Trollinator probably has never had to write for an embedded environment
09:24:18 <newsham> roconnor: quad-core em64_t == 256bit?
09:24:25 <Trollinator> sw17ch: true :)
09:24:40 <monochrom> ddarius: "seek help" is more general. It means consulting counsellors and psychiatrists. They may suggest seeking a new job, or other measures.
09:24:47 <roconnor> newsham: presumably :P
09:24:50 <quicksilver> maybe I should start a blog called haskell hate
09:24:51 <lilac> c++ ffi bindings are a pain because they require exposing c++' OO in haskell
09:24:55 <quicksilver> to focus my negative neergies.
09:25:14 <quicksilver> there are some quite interesting ways C++ ffi has been done. wx, for example.
09:25:17 <Trollinator> sw17ch: still, i don't see your point. Templates for example don't incur *any* runtime cost whatsoever.
09:26:00 <lilac> qtHaskell's ffi looked pretty poor (there was no obvious way to derive from one of Qt's classes)
09:26:14 <joma> 17:20
09:26:21 <joma> ehird?
09:26:40 <joma> > 17:20
09:26:40 <joma> @quote joma
09:26:41 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
09:26:42 <lambdabot>       No instance for (Num [t])
09:26:42 <lambdabot>        arising from the literal `20' at <inte...
09:28:13 <sw17ch> Trollinator: the point is that you need things like v-tables
09:28:15 <sw17ch> i don't have room for those
09:28:30 <Trollinator> sw17ch: no you don't. If you don't have room for them, don't use virtual functions.
09:28:42 <quicksilver> lilac: allowing haskell to derive new classes would indeed be advanced FFI
09:28:47 <sw17ch> i *literally* have to write my c-lib when i write at this level
09:28:50 <sw17ch> i *implement* printf
09:28:54 <joma> > let foreach f m = (map . map) (\x -> x*x+1) in let flatten = foldl1 (++) in (foreach . flatten) [[[[1,2,3],[4,5,6]]]]
09:28:54 <quicksilver> lilac: I'm not quite sure I can imagine how that is possible.
09:28:55 <lambdabot>       Overlapping instances for Show (t -> [[a]] -> [[a]])
09:28:55 <lambdabot>        arising fro...
09:29:03 <lilac> quicksilver: right. there's huge impedance mismatch between an OO interface and an FP interface
09:29:09 <quicksilver> lilac: I was just talking about interfacing to existing hierarchies.
09:29:18 <sw17ch> (that is if i even have room for things like printf)
09:29:26 <quicksilver> lilac: I'm not convinced subclassing is ever a sane part of an interface, though. Even in a pure C++ project.
09:29:36 <lilac> non-member interfaces implemented in C++ aren't a problem, though, as far as I'm aware
09:29:45 <lilac> so it's not C++, it's OO that's hard to FFI
09:29:50 <quicksilver> lilac: it is my experience that designing a class to be subclassable sanely is hard.
09:30:07 <lilac> quicksilver: right. this is perhaps a deficiency in Qt itself.
09:30:07 <quicksilver> lilac: (and I mean "subclassable by an external party without knowledge of internals")
09:30:17 <newsham> lilac: hmm.. what is the impedence of OO?
09:30:26 <newsham> (does that cause a lot of reflections?)
09:30:28 <monochrom> 345 ohms
09:30:32 <quicksilver> lilac: to make it sane you have to specify *precisely* which methods are expected to be overloaded.
09:30:41 <lilac> newsham: i'd guess that OO is all capacitance and FP is all resistance ;-)
09:30:44 <quicksilver> lilac: at whichpoint you have something more like a java interface
09:31:04 <quicksilver> lilac: I.e. you don't subclass the libraries class, you provide a new delegate object which implements a set of operations.
09:31:10 <lilac> quicksilver: well, some would argue that's why C++ distinguishes between virtual and non-virtual functions
09:31:19 <quicksilver> lilac: and *that* I could imagine implementing in a haskell bridge.
09:31:30 <quicksilver> lilac: Sure. I am aware of that argument, I just don't buy it.
09:31:39 <lilac> but yes, i'd agree that it's better style to design things as you suggest
09:31:45 <quicksilver> lilac: I'm not saying it's pure rubbish, I'm saying that on balance I don't think it's a path I'd take.
09:31:51 <newsham> lilac: i heard FP has a lot of induction
09:32:01 <joma> is the guy who wrote Frag here sometimes? who is he? what does he do now?
09:32:23 <quicksilver> newsham: YO DAWG I HEARD YOU LIKE INDUCTION SO I PUT A PROGRAM IN YOUR PROGRAM SO YOU CAN RECURSE WHILE YOU RECURSE.
09:32:29 <quicksilver> joma: I don't think he's ever in here.
09:33:11 <joma> > let quicksilverspeak = "yo dawg" in take 10 $ repeat quicksilverspeak
09:33:12 <lambdabot>   ["yo dawg","yo dawg","yo dawg","yo dawg","yo dawg","yo dawg","yo dawg","yo ...
09:33:13 <sw17ch> out of all the meems, i hate YO DAWG the most
09:33:14 <newsham> fold'r, I cant even type'er!
09:33:41 <joma> lol why did i laugh at that joke newsham?
09:33:42 <lilac> quicksilver: YO DAWG I HEARD YOU LIKE INDUCTION SO I PUT A PROGRAM OF SIZE ZERO AND A MAP FROM PROGRAMS OF SIZE n TO PROGRAMS OF SIZE n+1 IN YOUR PROGRAM SO YOU CAN RECURSE WHILE YOU RECURSE WHILE YOU RECURSE WHILE YOU RECURSE WHILE **killed: stack overflow
09:33:44 <sw17ch> the rest i think "oh, that's funny" and some i actually lol to, but that one fills me with disgust for my fellow man
09:33:51 <quicksilver> lilac: :)
09:33:56 <sw17ch> lilac++
09:34:01 <quicksilver> sw17ch: I have seen one or two funny examples.
09:34:10 <quicksilver> sw17ch: typically they're shit, tho.
09:34:15 <sw17ch> quicksilver: lilac just showed me the second one i've enjoyed
09:34:15 <monochrom> haha lilac
09:34:19 <joma> @meme
09:34:19 <lambdabot> Maybe you meant: more time
09:34:20 * quicksilver nods
09:34:26 <quicksilver> it's a hard meme to make funny.
09:34:38 <sw17ch> the first was a picture of that guy looking at a set of those doll-inside-a-doll russian thingys
09:34:38 <monochrom> Now someone please come up with yo-dawg-coinduction jokes. :)
09:34:38 <ddarius> quicksilver: Not with mathematics.
09:34:43 <Trollinator> sw17ch: i don't see your point. for example, printf is not type-safe, while a C++ iostream is.
09:34:57 <newsham> dawgs recursion is primitive
09:35:14 <joma> let python = "haskell" in [python, python]
09:35:21 <quicksilver> sw17ch: http://xkcd.com/286/
09:35:24 <joma> > let python = "haskell" in [python, python]
09:35:25 <lambdabot>   ["haskell","haskell"]
09:36:06 <Trollinator> sw17ch: now you probably wouldn't use iostreams in the embedded sector, but overloading << for different argument types allows one to build a type-safe printf clone anyway.
09:36:06 <quicksilver> ddarius: there was a 'derive' one that made me laugh. Although the main reason it was funny is that 'derive' sounds like 'drive'.
09:36:26 <quicksilver> sw17ch: http://xkcd.com/286/
09:36:29 <ddarius> quicksilver: Yeah, that one was decent.
09:36:35 <newsham> An introduction to Abstract Algebra through internet memes?
09:36:40 <sw17ch> Trollinator: wc -c /usr/lib32/libstdc++.so.2.8.0 => 255788
09:36:44 <vixey> heh
09:36:58 <ksf> http://libagar.org/ looks sexy
09:37:12 <sw17ch> My point is that your standard c++ library is *huge*
09:37:29 <ksf> pure ansi c, 3-clause bsd, utterly cross-platform, currently targets sdl and opengl.
09:37:52 <sw17ch> Trollinator: it has nothing to do with type safety, or succinct code, or anything, the freaking standard libraries that it depends on are enormous
09:38:28 <lilac> sw17ch: for embedded, you'd use a freestanding implementation rather than a hosted one, though, right?
09:38:42 <sw17ch> lilac: of C?
09:38:47 <lilac> sw17ch: of C++
09:39:00 <sw17ch> lilac: well, we don't use c++ is my point :)
09:39:11 <quicksilver> ksf: does look interesting.
09:39:17 <lilac> sw17ch: no point throwing the baby out with the bathwater.
09:39:31 <quicksilver> lilac: interesting, widget toolkits are about the only really convincing example of implementation inheritance I know.
09:39:34 <sw17ch> lilac: i think i'm missing something
09:39:50 <lilac> sw17ch: C-with-little-bits-of-C++ is a better language than C, as far as i'm concerned (at least for C89)
09:40:17 <sw17ch> lilac: we're c99 for this project
09:40:34 <lilac> sw17ch: ah, well then i'm out of my depth ;-)
09:40:50 <sw17ch> =)
09:41:03 <lilac> quicksilver: i'm still not convinced they need it, but i can see why they're designed that way
09:41:28 <psnively> Hello everyone.
09:41:37 <sw17ch> m68k processor, 20Mhz, 32K RAM... supporting an FPGA, 256K program flash, some external flash accessed over SPI... and running a webserver as well as a rs485 bus :\
09:42:01 <digitalexander> Off-topic (sorry), but when using a simple fold, would you guys prefer a lambda over an explicit function? If the lambda is short & simple I mean?
09:42:03 <quicksilver> lilac: I'm not claiming they "need" it. But I do note that it does seem quite a natural thing in that context.
09:42:11 <newsham> seems pretty anemic for 2009, sw17ch.
09:42:21 <newsham> why not some embedded mips or arm with much more ram?
09:42:26 <sw17ch> newsham: the project started in 2006 :)
09:42:27 <quicksilver> lilac: and all the OO tutorials I've seen use it as an example (after they progress beyond really stupid stuff like Circle ISA Shape)
09:42:33 <newsham> even for 2006 seems kinda small
09:42:35 <h0tzenpl0tz> are there other predefined functions than mapX that are Functors?
09:42:38 <lilac> digitalexander: i'd use a lambda or an operator section if it's short enough that the code is still clear
09:42:47 <sw17ch> newsham: yeah, it is... i still give the guy who speced the hardware initially a hard tiem about it
09:42:48 <quicksilver> lilac: and yes, it's the *only* convincing example I know with a hieararchy > 2 deep
09:42:59 <sw17ch> but it's too late to switch now :\
09:43:05 <digitalexander> lilac: yeah, like in this example for instance? some_sort xs = foldr (\x ys -> insert x ys) [] xs
09:43:08 <quicksilver> digitalexander: if the lambda is short and simple, why not use it, is my attitude.
09:43:29 <newsham> 68k is great for asm though
09:43:30 <lilac> quicksilver: at work we have Cell Instance is-a Gate is-a Module (this is in the field of EDA)
09:43:55 <digitalexander> quicksilver, lilac: It seems the RWH book advises the reader to avoid lambdas in most cases, but I agree that if it's short&sweet, why not?
09:44:33 <digitalexander> lilac: btw, I'm a little noob, what's an operator section?
09:44:39 <quicksilver> lilac: superficially I find that less convincing but I'd need to understand more about it to make a case :)
09:44:43 <quicksilver> digitalexander: (*2)
09:44:45 <lilac> quicksilver: the heirarchy goes 8 levels deep, of which at least 5 are sensible
09:45:05 <digitalexander> quicksilver: ah, yeah, remember now :)
09:45:28 <lilac> digitalexander: in general, for any operator <> you can write (a <>) as a shorthand for (\b -> a <> b) and (<> b) as a shorthand for (\a -> a <> b)
09:45:57 <lilac> digitalexander: plus (<>) as a shorthand for (\a b -> a <> b)
09:46:09 <vixey> hrmf .. I think I finally figured out this algorthm.. and there is still no haskell implementation
09:46:10 <lilac> i'm not sure whether that last one is generally considered to be an operator section or not
09:46:13 <jkff> Hi people. Has anyone made something like Data.Binary but with random seeks? Or, generally, a generic seekable interface for handles and bytestrings?
09:46:18 <ztirF> @pl \x -> g x (f x)
09:46:18 <lambdabot> ap g f
09:46:31 <ztirF> I can never remember that definition
09:46:35 <sw17ch> newsham: there's a good chance this project will hit a V2 on the hardware... if that happens we'll be using a full OS and much more hardware.
09:46:38 <sw17ch> probably an ARM
09:46:48 <lilac> ztirF: it's the good old S combinator
09:47:01 <quicksilver> jkff: I have constructed part of such a thing in code fragments.
09:47:08 <ztirF> lilac: I thought S was >>=
09:47:12 <quicksilver> jkff: I used it to let me write pure tests over code which would also run in IO.
09:47:18 <quicksilver> jkff: (for file format stuff)
09:47:28 <lilac> @type ap
09:47:29 <ztirF> @pl \x -> g (f x) x
09:47:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:47:30 <lambdabot> g =<< f
09:47:34 <quicksilver> jkff: it's not uploaded anywhere thoug. I've not noticed anything on hackage along those lines.
09:48:01 <lilac> @type ap :: (a -> b -> c) -> (a -> b) -> (a -> c)
09:48:02 <lambdabot> forall a b c. (a -> b -> c) -> (a -> b) -> a -> c
09:48:25 <jkff> quicksilver: Nice :) I've just written such a tiny thingy myself and now I realized that I am actually having problems not in the genericity part, but with lazy IO in general, Oleg is completely right :-\
09:48:37 <quicksilver> jkff: of course.
09:48:42 <ztirF> S is Sxyz = xz(yz) right
09:48:43 <digitalexander> lilac: thanks, what you said about sections made my code a lot clearer. I keep being baffled by how expressive Haskell is, takes a little getting used to :)
09:48:55 <jkff> Looks like I'll have to rewrite it with iteratees, however that's going to be fun
09:48:56 <newsham> jkff: I needed to access some data by offset to unmarshall dns and i just passed in an extra argument to the gettors that was a function that could fetch by offset fromthe original data.
09:49:00 <ztirF> gotcha, so that's ap
09:49:00 <vixey> ztirF,  s x y z = x z (y z)
09:49:10 <lilac> digitalexander: great, glad to hear it.
09:49:12 <newsham> jkff: ie. I did it without modifying the GET interface by manually using an extra argument
09:49:42 <quicksilver> jkff: it's not really that hard :)
09:49:45 <jkff> newsham: Do you mean Data.Binary's 'Get' interface?
09:49:48 <newsham> yes.
09:50:05 <newsham> jkff: the code is http://www.thenewsh.com/~newsham/x/machine/dns/DNS.hs in the final "get" method, the "gettor" variable
09:50:24 <jkff> newsham: Thanks! I'll have a look; your approach sounds great
09:51:09 <vixey> newsham, oh you gave up with the GADT stuff in the end?
09:51:12 <jkff> newsham: Oops, I need seeks from end, and I don't want to force the entire bytestring :-|
09:51:23 <newsham> for the putter I used a StateT to keep track of the offset as I Put data out
09:51:37 <newsham> vixey: no, this is older code
09:51:42 <vixey> ok
09:52:21 <newsham> vixey: also i dont know how well the marshaller gadt stuff would work for dns
09:52:23 <quicksilver> jkff: if you want to seek form the end without forcing the whole bytestring then you need something altogether more sophisticated, I think.
09:52:40 <quicksilver> jkff: lazy bytestring is designed for a primarily left-to-right access pattern.
09:52:42 <jkff> quicksilver: That's what I thought. However, this seems to perfectly fit within the iteratees
09:53:05 <quicksilver> it can, yes.
09:53:20 <quicksilver> You've still got to actually write the code which reads on demand from various different parts of the file somewhere :)
09:53:45 <vixey> newsham, you can implement data.dynamic (for a closed universe) with this GADT technique, but the barrier is stuff like  a -> a -> a  couldn't be expressed without a type level lambda
09:53:54 * vixey wishes for type level lambda
09:54:14 <jkff> Hmm, is hpaste down for a long time already?
09:54:15 <newsham> vixey: perhaps another language? ;-)
09:54:32 <vixey> well I use a lot of languages
09:54:47 <vixey> I don't see type level lambda detracting from haskell though
09:56:13 <jkff> In case anyone is interested, my small, perverted and non-working 'generic' code for seekable stuff is here: http://paste.org/4919 . It also made me lose my monad transformer virginity.
09:56:18 <sw17ch> @define type-level lambda
09:56:28 <PeakerWork> vixey: what languages do you use besides C/Haskell/Coq?
09:56:47 <vixey> various
09:57:08 <vixey> jkff, why is this called generic?
09:57:18 <newsham> python? :)
09:57:31 <vixey> I've only written one program in python
09:57:36 <jkff> vixey: Because it works in the same way for pure bytestrings and unpure handles
09:57:48 <jkff> Or, it was intended to work, but it doesn't, because of lazy IO
09:58:00 <PeakerWork> vixey: what program did you write in Python? only one because you hated it? :)
09:58:27 <joma> python is super
09:58:31 <Twey> What is it with negation these days?  Recently I've seen a lot of people saying things like 'unpure'
09:58:36 <joma> awesome for prototyping
09:59:01 <vixey> prototyping is silly
09:59:27 <joma> why?
09:59:59 <vixey> joma, I think in programming, a prototype is as likely to be useful as a real-thing so why bother with the intermediate stage
10:00:13 <PeakerWork> joma: I liked Python too, before diving in deeper into Haskell :)
10:00:15 <newsham> some of us like our real-thing to work well.
10:00:20 <PeakerWork> joma: Hey, I even loved it :)
10:00:25 <Nafai> PeakerWork: Heh, me too
10:00:27 <newsham> but i think your side has won, vixey.  all i see on the internet are prototypes
10:00:46 <vixey> newsham, my side ?
10:00:58 <newsham> the "prototypes are as useful as a real-thing" side
10:01:05 <Nafai> PeakerWork: But I'm writing more Python lately, for work.  Better than Java, I suppose.
10:01:12 <vixey> ..I thought I was on my own with my ridiculous skewed perspective
10:01:24 <newsham> vixey: apparently not!
10:01:42 <Spark> s/prototype/hack
10:01:44 <Spark> may as well be honest here
10:01:53 <PeakerWork> Nafai: heh, yeah me too
10:02:01 <PeakerWork> Nafai: I hope to convince my entire workplace to switch to Haskell :)
10:02:25 <Nafai> PeakerWork: Yeah, I'm not so certain for that myself.
10:02:40 <PeakerWork> Nafai: one coworker at a time :)
10:02:53 <vixey> jkff,     seek mode n  = ask >>= h -> liftIO $ hSeek h mode (fromIntegral n)
10:02:56 <vixey> looks wrong
10:03:01 <Nafai> I'm actually in the ops division of my company
10:03:01 <vixey> maybe it didn't paste right or something
10:03:09 <Nafai> So I just have to convince the other developer in ops :)
10:03:39 <PeakerWork> Nafai: you could rewrite some of the tools in Haskell and show them how much nicer it comes out :)
10:04:08 <Nafai> Yeah, sometime soon
10:04:34 <joma> again, would it be possible to make a haskell game for a console?
10:04:35 <jkff> vixey: A backslash got lost. Anyways, I already threw the code away
10:04:51 <vixey> good
10:04:54 <chessguy_work> joma, sure it would, why wouldn't it?
10:09:27 <Twey> joma: Of course.  Depending on the architecture you might need a special compiler, but nothing stopping you.
10:10:04 <chessguy_work> Twey, special compiler?
10:10:12 <chessguy_work> oh!
10:10:20 <CosmicRay> gwern: I haven't had anything to do with the wikipedia page about me, on purpose
10:10:21 <lambdabot> CosmicRay: You have 1 new message. '/msg lambdabot @messages' to read it.
10:10:24 <chessguy_work> i was thinking he meant like a console app, as in text-based
10:10:27 <sw17ch> @seen dons
10:10:27 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 7m 7s ago.
10:10:31 <dons> yo
10:10:32 <sw17ch> @summon dons
10:10:32 <lambdabot> Unknown command, try @list
10:10:35 <sw17ch> hah
10:10:36 <sw17ch> preemptive even
10:11:24 <Twey> chessguy_work: Heh
10:11:41 <Philippa_> joma: there's likely to be a lot of porting work involved. Nominally doable, but right now I'd take the codegen DSL approach instead
10:12:21 * Philippa_ really would /not/ want to try to do serious PS3 work in Haskell alone right now, at least not without time for a research project
10:14:11 <int80_h> good morning #haskell
10:14:29 <elbar> > show "Hi"
10:14:31 <lambdabot>   "\"Hi\""
10:14:31 <dons> hey int80_h
10:15:03 <elbar> hmm...next time without the quotes ;)
10:15:16 <int80_h> I'm almost done with the graham scan exercise. I can feel it.
10:15:25 <int80_h> finally.
10:15:40 <int80_h> it was a very good exercise
10:16:02 <int80_h> now I'm wondering about other algorithms explicated on wikipedia that I can implement for fun
10:16:33 <facedown> Wow
10:21:53 <chessguy_work> int80_h,  got code?
10:22:35 <chessguy_work> oh, i read that as "already", not "almost"
10:22:39 <Saizan> ("got change?")
10:22:45 <gbacon> how can I tell darcs send not to consult the repo format?
10:22:46 <lilac> chessguy_work: i ain't readin' no code, foo'!
10:22:59 <chessguy_work> ummm
10:23:03 <lilac> gbacon: sounds like a question for #darcs ;-)
10:23:11 <chessguy_work> i guess i hit some reference i didn't mean to
10:23:21 <chessguy_work> i was going for more of a "got milk" reference
10:23:34 <lilac> chessguy_work: yeah, i got to Mr T via milk
10:26:01 <int80_h> chessguy_work: for the graham scan exercise?
10:26:11 <chessguy_work> int80_h, yeah
10:26:24 <int80_h> chessguy_work: yup. I'm finishing it up right now
10:26:50 <int80_h> chessguy_work: might run into a few problems, but I don't think it's going to be much of a problem
10:26:56 <chessguy_work> cool
10:29:03 <gbacon> lilac: nothing but crickets over there :-(
10:30:40 * jkff notices that relative seeks with iteratees are going to look scary
10:30:51 <chessguy_work> @get-slap
10:30:51 <lambdabot> shapr!!
10:31:17 <erikc> i should make a voting webapp along the lines of will it blend, 'Will It TypeCheck?'
10:31:34 <chessguy_work> heh. "don't try this one at home, folks!"
10:32:13 <nikki93> I must thank you guys.
10:32:18 <erikc> now for my little typing question... http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=818#a818
10:32:34 <nikki93> Till now, I was an imperative c++ object oriented kinda guy, you people helped expand my brain.
10:32:37 <nikki93> Thanks.
10:32:44 <erikc> what is the type inferenced for the castPtr? (Storable b => b) ?
10:32:50 <nikki93> Whether I'll be using Haskell or not, it certainly made me a better programmer.
10:33:55 <EvilTerran> ?hoogle castPtr
10:33:56 <lambdabot> Foreign.Ptr castPtr :: Ptr a -> Ptr b
10:33:56 <lambdabot> Foreign.Ptr castPtrToFunPtr :: Ptr a -> FunPtr b
10:33:57 <lambdabot> Foreign.StablePtr castPtrToStablePtr :: Ptr () -> StablePtr a
10:34:05 <leimy> nikki93: It's definitely made me rethink things here and there
10:34:24 <EvilTerran> ?hoogle poke
10:34:25 <lambdabot> Foreign.Storable poke :: Storable a => Ptr a -> a -> IO ()
10:34:25 <lambdabot> Foreign.Marshal.Array pokeArray :: Storable a => Ptr a -> [a] -> IO ()
10:34:25 <lambdabot> Foreign.Marshal.Array pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()
10:34:28 <nikki93> leimy: I'm afraid of one thing.
10:34:38 <nikki93> leimy: Will I forget C++? (funny question i know, laugh if you wanna)
10:34:45 <PeakerWork> nikki93: no
10:34:49 <PeakerWork> nikki93: you won't forget it
10:34:49 <leimy> nikki93: you might want to :-)
10:34:55 <nikki93> leimy: No, I don't.
10:34:56 * dolio still knows C++.
10:34:58 <SamB_irssi> is it just me, or is code.haskell.org down (at least for SSH)?
10:35:00 <nikki93> leimy: That language rocks.
10:35:03 <int80_h> shock therapy can help with the forgetting
10:35:03 <dolio> As much as I ever did, anyway.
10:35:04 <tromp__> :t concatMap
10:35:05 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
10:35:20 <SamB_irssi> nikki93: no more than usual, unless you work at it
10:35:24 <erikc> EvilTerran: right, but what is the type for 'a' in that context? Storable a => a ?
10:35:33 <leimy> nikki93: I know C++ pretty well, and I've gotten to the point where stuff is so much easier for me to do in Haskell, that I rewrote a few things.
10:35:37 <EvilTerran> you may find yourself trying to wedge haskell-isms into other languages, but i find i can still force myself to program idiomatically in other languages
10:35:45 <nikki93> leimy: Heh.
10:35:54 <dolio> SamB_irssi: Seems down to me, too.
10:35:57 <leimy> nikki93: and got my work done faster
10:36:08 <nikki93> leimy: I'd totally love to use Haskell for scripting/extensions in my C++ apps but it seems too hard. :(
10:36:16 <SamB_irssi> EvilTerran: hey, I probably used some Haskell idioms in Python before I knew Haskell ...
10:36:17 <erikc> a lot of haskellisms work pretty well in c++ using templates
10:36:39 <EvilTerran> SamB_irssi, well, a lot of haskell-isms are kinda python-isms anyway :)
10:36:40 <leimy> I'm not sure if I've seen Monads in C++, but I can see how something like that would be definitely interesting.
10:36:47 <EvilTerran> (and/or vice-versa)
10:36:49 <nikki93> erikc: Yep. When I tried my first factorial functions I though 'template metaprogramming'
10:36:58 <dolio> Monads in C++ are terrible.
10:37:04 <SamB_irssi> EvilTerran: darn it! I was gonna say "or is it the other way round?"
10:37:04 <nikki93> leimy: I thought Monads were for functional languages.
10:37:11 <nikki93> leimy: C++ not being functional, how'd that help?
10:37:16 <lament> functions are for functional languages :)
10:37:22 <nikki93> leimy: (I don't know what a monad is anyway)
10:37:27 <leimy> nikki93: the C++ template evaluation stuff is a functional language
10:37:29 <Badger> remove all the functions from C/++!
10:37:29 <EvilTerran> erikc, well, in "poke p (SB a) = poke (castPtr p) a", the type of "a" will be "forall s. Storable s => s"
10:37:33 <nikki93> leimy: Functional as in 'very truly purely functional'.
10:37:36 <SamB_irssi> nikki93: monads are useful for, among other things, imperating
10:37:48 <leimy> nikki93: and that's what Templates are.
10:37:56 <erikc> evilterran: ah thx, i wasnt sure if that counted as a 'type', guess so
10:37:58 <nikki93> leimy: Didn't mean you, meant lament. :P
10:38:07 <jkff> nikki: monads are useful for thinking about many processes, including side-effects, parsers, statistical distributions, iteratees, continuations etc.
10:38:16 <SamB_irssi> Monad support in a langauge has been summarized loosely as the ability to overload the semicolon ;-P
10:38:18 <leimy> nikki93: nope, templates in C++ are VERY functional :-)
10:38:21 <nikki93> I'm a haskell noob, so shaddup now.
10:38:23 <maltem> I'm just reading the cafe thread about Haskell naming and documentation, and I'd like to add a documentation advice
10:38:27 <maltem> I'm going to shout this
10:38:36 <maltem> EXPAND YOUR ACRONYMS!
10:38:43 <SamB_irssi> leimy: the datatypes sort of suck, though, as does the typechecking ...
10:38:45 <nikki93> leimy: Yeah, I GOT IT. I wanted to type 'lament', a USER here, but autocomplete of username failed.
10:38:49 <erikc> i have a logic monad in c++ using template expressions and overloading >>= to bind expressions
10:38:55 <nikki93> leimy: *phew*
10:39:02 <erikc> no garbage collection makes closures and monads pretty annoying to use though
10:39:05 <leimy> SamB_irssi: yeah I didn't say it was a great type system.
10:39:07 <nikki93> @quote nikki
10:39:07 <lambdabot> No quotes match. :(
10:39:11 <nikki93> @quote nikki93
10:39:11 <lambdabot> nikki93 says: > let laughAtPerson n y = if (n > 0) then "ha" ++ laughAtPerson (n - 1) y else "aa " ++ y ++ "! :P" in "Ha" ++ (laughAtPerson 8 "ehird")
10:39:29 <nikki93> > let laughAtPerson n y = if (n > 0) then "ha" ++ laughAtPerson (n - 1) y else "aa " ++ y ++ "! :P" in "Ha" ++ (laughAtPerson 8 "leimy")
10:39:30 <lambdabot>   "Hahahahahahahahahaaa leimy! :P"
10:39:39 <dolio> http://www.cc.gatech.edu/~yannis/fc++/FC++.1.5/monad.h
10:39:44 * Twey sets traps for Badger.
10:39:52 <leimy> dolio: I just googled that myself.
10:40:10 * Badger *snap*
10:40:21 <Twey> Bloody hell
10:40:34 <nikki93> dolio: I started reading that.
10:40:36 <leimy> template <class Rep> struct ThisTypeIsNotAnInstanceOfAnInferrableMonad {};
10:40:36 <leimy>   <--- phear!
10:40:36 <nikki93> dolio: And stopped.
10:40:45 <Twey> That file is precisely 1000 LoC.
10:40:45 <dolio> nikki93: Exactly. :)
10:40:46 <nikki93> dolio: Fast. :P
10:40:55 <Twey> Haskell equivalent:
10:40:55 <nikki93> dolio: See, yo don't try to put one language in another.
10:41:00 <Twey> @src Monad
10:41:01 <lambdabot> class  Monad m  where
10:41:01 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
10:41:01 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
10:41:01 <lambdabot>     return      :: a -> m a
10:41:01 <lambdabot>     fail        :: String -> m a
10:41:08 <nikki93> dolio: We don't try to make haskell like c++ neither c++ like haskell.
10:41:10 <Twey> Five LoC.
10:41:20 <nikki93> They're two different languages for some #&$^ing reason.
10:41:22 <leimy> Well the monads in C# aren't too bad :-)
10:41:23 <nikki93> Diversity is good.
10:41:25 <leimy> comparatively
10:41:27 <nikki93> Let 'em be diverse.
10:41:43 <nikki93> You wouldn't like haskell if it was like C++ would it?
10:41:45 <leimy> http://blogs.msdn.com/wesdyer/archive/2008/01/11/the-marvels-of-monads.aspx
10:41:48 <roconnor> what would be a good sampling rate for transcribing reel to reel tape?
10:41:55 <nikki93> Probably it'd be vice versa for something else.
10:42:04 <Twey> They're two different languages because C++ isn't powerful enough to mimic Haskell, and the Haskell folk scorn to mimic C++ :-P
10:42:08 <nikki93> Swiss knife == bah. Many tools == good.
10:42:24 <MichaelGG> leimy, that post made it worse imo
10:42:28 <nikki93> Twey: No, you just don't know how to use C++ or don't know what its supposed to be used like. :P
10:42:32 <MichaelGG> leimy, "getting" monads, that is
10:42:40 <leimy> MichaelGG: oh perhaps.
10:42:43 <MichaelGG> wasnt until F# workflows that it was a bit clear
10:42:50 <MichaelGG> C#'s syntax is so obfuscated
10:42:53 <leimy> F# is definitely cool
10:42:56 <Twey> nikki93: We've just seen that the former is true
10:42:59 <leimy> C# is like a cornucopia of syntax
10:43:02 <Twey> nikki93: And you can hardly deny the latter :-P
10:43:05 <leimy> but at least it's not Objective-C 2.0
10:43:06 <leimy> yuck
10:43:11 <nikki93> Twey: Ahh then your opinion doesn't matter. :)
10:43:33 <nikki93> Twey: But you like haskell, know how to use it, and it works for you, so use it.
10:43:33 <Twey> Hey Haskell folks!  What do you think of mixing IO and pure code?
10:43:36 <nikki93> Twey: Done. :)
10:43:43 <Twey> nikki93: I know how to use C++ too :)
10:43:47 <vixey> "mixing"?
10:43:50 <leimy> Twey: it happens all the time?
10:43:55 <nikki93> Twey: I'm too noob to answer that yet, but one day, ONE day I tell you!
10:44:04 <nikki93> Twey: I mean the IO pure stuff.
10:44:13 <EvilTerran> Twey, i don't believe in IO ;)
10:44:16 <int80_h> IO pure stuff?
10:44:17 <Twey> vixey: Having no clear distinction between pure functions and IO.  :)
10:44:17 <nikki93> Twey: Ok, everyone knows C++. Its easy
10:44:26 <leimy> EvilTerran: everything happens in "interact"
10:44:30 * Twey laughs.
10:44:41 <leimy> nikki93: I know a lot of people who don't know C++ or who think they do, but not really :-)
10:44:42 <nikki93> Twey: Wait... You want the computer to do something, but not tell it what you want to do and know find out what its doing?
10:44:48 <nikki93> Twey: Fail?
10:44:55 <Twey> nikki93: Pardon?
10:44:57 <leimy> :t interact
10:44:58 <lambdabot> (String -> String) -> IO ()
10:45:10 <leimy> That is a beautiful thing right there
10:45:10 <nikki93> Twey: I thought you don't want IO sorry. :P
10:45:14 <Twey> Left "sentence does not compute"
10:45:16 <int80_h> know find out what it's doing?
10:45:22 <Twey> Didn't say that :)
10:45:37 <nikki93> Twey: Wait... You want the computer to do something, but not tell it what you want to do and also not find out what its doing?
10:45:50 <nikki93> Twey: Wait... You want the computer to do something, but not tell it what you want it to do and also not find out what its doing/has done?
10:45:53 <Twey> Ah
10:46:01 <Twey> No, that's the province of Miranda
10:46:16 <leimy> Clean looks neat.
10:46:24 <ksf> there's one argument against agar... thousands of vararg functions.
10:46:25 <nikki93> leimy: That's because its Clean.
10:46:33 <nikki93> leimy: Otherwise it'd be perl. :P
10:46:43 <Twey> Haha
10:46:45 <Twey> Or C++ :-P
10:46:50 <leimy> or line noise
10:46:56 <nikki93> Or malbolge.
10:46:56 <leimy> oh wait, you said Perl already
10:46:57 <Twey> leimy: What's the difference?
10:46:58 <EvilTerran> perl++.net
10:46:59 <Twey> Heh
10:47:02 <EvilTerran> <.<  >.>
10:47:05 <MichaelGG> whats the best book/intro on category theory, and what prerequisites are necesary?
10:47:17 <leimy> MichaelGG: someone recommended a winner on haskell-cafe
10:47:19 <leimy> recently
10:47:21 <leimy> I can't remember it though.
10:47:25 <jkff> MichaelGG: Barr & Wells, Category Theory for Computing Science
10:47:27 <Twey> 18:47:02 < EvilTerran> <.<  >.>  BF
10:47:35 <leimy> I think that was it.
10:47:53 <EvilTerran> Twey, isn't any string with matched [...]s valid BF?
10:47:57 <nikki93> Perl++.net == #%syste@$!%m.printStrLineForScreenOnComputer(@%#%"Hello"s/@#%@%#); System.EndProgramThatHasToEndNow@!%
10:48:10 <MichaelGG> that's a bit softer to get into than Pierce's "Basic Category Theory for Computer Scientists"?
10:48:17 <Twey> EvilTerran: Think so
10:48:32 <Twey> In the same manner that $*#1!@{*:me+
10:48:36 <Twey> ... is valid Perl
10:48:40 * EvilTerran gets very confused by all these "... category theory for comp(...) scien(...)" books
10:48:41 <jkff> MichaelGG: It is much more well-written, and yet it covers many more topics
10:48:55 <nikki93> When a cartoon character swears its perl.
10:48:59 <MichaelGG> jkff, cause the other one seemed much harder up front
10:48:59 <jkff> MichaelGG: And it has plenty of exercieses
10:49:03 <MichaelGG> cool
10:49:04 <leimy> Ah yes this one
10:49:05 <leimy> http://www.amazon.com/Category-Computer-Scientists-Foundations-Computing/dp/0262660717/ref=sr_1_1?ie=UTF8&s=books&qid=1232477332&sr=8-1
10:49:17 <jkff> ..And all exercises have solutions at the end of the book.
10:49:20 <vixey> MichaelGG: another approach to learning category theory, (which I'm doing, very very slowly without actually wanting to) .. is just reading various books which /make use of it/ and usually they have an appendix with notations and definitions..
10:49:27 <jkff> Although the book is not available online anywhere
10:49:32 <MichaelGG> What kind of prerequisites would be needed to fully understand it?
10:49:40 <jkff> Some abstract algebra
10:49:41 <EvilTerran> Twey, sure, that's the variable $* followed by a comment :P
10:49:47 <leimy> What I'd like to know is if there is a lot of value in learning things like pi-calculus
10:49:52 <jkff> A bit of it
10:49:54 <leimy> for studying concurrent/parallel systems.
10:49:56 <nikki93> Anyone seen 'Hello, World' in malbolge?
10:49:57 <nikki93>  (=<`:9876Z4321UT.-Q+*)M'&%$H"!~}|Bzy?=|{z]KwZY44Eq0/{mlk**
10:49:59 <nikki93>  hKs_dG5[m_BA{?-Y;;Vb'rR5431M}/.zHGwEDCAA@98\6543W10/.R,+O<
10:50:02 <nikki93> That's it.
10:50:11 <lament> that's impressively short
10:50:19 <EvilTerran> nikki93, ... it's shorter than the java version
10:50:22 <leimy> Ever seen hello world in whitespace?
10:50:26 <MichaelGG> one used for $175
10:50:26 <MichaelGG> wow
10:50:27 <leimy> it looks like this
10:50:29 <leimy> :
10:50:39 <leimy> MichaelGG: yeah! :-)
10:50:40 <nikki93> Ever seen hellowold in nikkislanguage?
10:50:41 <leimy> pricey
10:50:52 <leimy> Yeah but whitespace exists :-)
10:50:54 <EvilTerran> leimy, i don't think anyone has, to be literal :P
10:50:58 <leimy> heh
10:51:00 <nikki93> i hw shw
10:51:10 <nikki93> That's 'import helloworld showhelloworld'
10:51:15 <nikki93> Hello world is a library. :P
10:51:15 <MichaelGG> It just seems that there isnt any harm in learning more maths
10:51:19 <leimy> Someone started scribbling on some paper on my desk, and I was like NOOOOO THAT'S MY WHITESPACE CODE!
10:51:25 <Badger> nikki93: cheater
10:51:28 <nikki93> leimy: lol
10:51:36 <MichaelGG> Coming from VB/C/C#, the power available in Haskell or even OCaml is so amazing
10:51:36 <vixey> MichaelGG: No I don't think so, knowing things can be dangerous
10:51:38 <leimy> http://compsoc.dur.ac.uk/whitespace/
10:51:50 <nikki93> MichaelGG: VB?
10:51:52 <MichaelGG> vixey, how so , in this case?
10:51:55 <nikki93> MichaelGG: YOU MEAN VEEEBEEE?
10:52:06 * MichaelGG hangs head in shame.
10:52:09 <Twey> Hahahaha
10:52:09 * jkff is afraid to compile the Monad instance for seekable iteratees
10:52:12 <nikki93> > let laughAtPerson n y = if (n > 0) then "ha" ++ laughAtPerson (n - 1) y else "aa " ++ y ++ "! :P" in "Ha" ++ (laughAtPerson 8 "MichaelGG")
10:52:13 <lambdabot>   "Hahahahahahahahahaaa MichaelGG! :P"
10:52:30 <MichaelGG> Not my fault! My Atari used Basic when i was 5. so did a TRS80. and so on....
10:52:34 <nikki93> MichaelGG: You mean VirtualBanana?
10:52:44 <leimy> I had a TI-99/4a
10:52:47 <leimy> and TI BASIC
10:52:51 <leimy> as my first machine
10:52:54 <int80_h> MichaelGG: I first learned assembly on my atari
10:52:55 <nikki93> I started qith QBasic first.
10:53:02 <MichaelGG> Now, I see things like frameworks to stop XSS, and I'm thinking, damn, wouldnt a decent type system fix that in the first place?
10:53:05 <nikki93> My dad asked me to write a sort algorithm, I was a kid.
10:53:05 <leimy> TI BASIC rocked, not so much
10:53:07 <leimy> 10 call clear
10:53:09 <nikki93> Wrote some funny algorithm.
10:53:10 <int80_h> I started with pet commodore basic
10:53:11 <nikki93> And it worked.
10:53:20 <nikki93> Later I saw it somewhere, it was called 'gnome sort' or something.
10:53:41 <MichaelGG> i never got any real learning done on programming till I had to make some money with it :P
10:53:57 <nikki93> I first learnt by copy-paste.
10:54:01 <leimy> me too
10:54:03 <anthonymiller> gnome sort that sounds like fun
10:54:11 <leimy> then dorking with the stuff I copied
10:54:12 <roconnor> The only way I learn haskell is by writing ICFP entries.
10:54:26 <int80_h> I was motivated by being able to manipulate these games written in BASIC.
10:54:28 <nikki93> anthonymiller: Basically its bubblesort but without doing (n-1) iterations, just going back and sorting again for every interchange.
10:54:51 <nikki93> int80_h: My first game in QBasic was a maze thing
10:55:04 <leimy> I wrote some weird QBasic stuff
10:55:08 <MichaelGG> But I'm annoyed that computing industry has done such a shitty job overall. I mean, seriously, why the hell do they keep pushing C-like languages? Seriously, wtf. People who've gone to university and should know better.
10:55:16 <nikki93> Then I started making games with Game Maker.
10:55:16 <leimy> including a program to break up QBasic code so it could be uploaded to Prodigy
10:55:20 <nikki93> Then I moved to C++ and Ogre.
10:55:36 <nikki93> leimy: Prodigy? That industrial rock band?
10:55:37 <leimy> the old days of 2400 baud modems :-)
10:55:40 <leimy> Hah
10:55:45 <leimy> no the old online network.
10:55:54 <nikki93> leimy: How old is it that you are?
10:55:55 <leimy> peer of AOL, Compuserve, GEnie
10:56:00 <leimy> 31 :-)
10:56:02 <nikki93> > whatIsLeimy
10:56:03 <EvilTerran> MichaelGG, big corporations have a *lot* of money invested in C-like languages :P
10:56:03 <lambdabot>   Not in scope: `whatIsLeimy'
10:56:05 <leimy> I was like 12 or something when I did that.
10:56:14 <nikki93> leimy: Oh my...
10:56:16 <MichaelGG> EvilTerran, so why's that make things like Java and C# suck?
10:56:23 <nikki93> leimy: I mean... ALl these years programming.
10:56:33 <nikki93> leimy: You should've been famous by now right? :P
10:56:34 <EvilTerran> MichaelGG, because sucking is part of their nature
10:56:37 <nikki93> leimy: Or are you lazy? :P :P
10:56:38 <leimy> EvilTerran: I suspect that code will be around a long time...
10:56:39 <MichaelGG> I mean, take C# -- clean slate, and they start off without generics, lambdas, etc. then they add it slowly and suckily
10:56:49 <leimy> nikki93: Google for "leimy" :-)
10:56:55 <MichaelGG> Java too :P
10:57:02 <Zao> MichaelGG: Well, it's not that clean if you inherit most of the C++ syntax.
10:57:02 <ozy`> MichaelGG: C# was Java Prime, dude
10:57:05 <EvilTerran> MichaelGG, it's hardly a clean slate; the "C" part of the name gives that much away
10:57:05 <joma> embedding code into html vs embedding html in code?
10:57:09 <nikki93> http://en.wikipedia.org/wiki/Lemmy <-- You're this guy?
10:57:17 <Cale> MichaelGG: I have the impression that most of the programmers in the industry are not interested in learning something new.
10:57:17 <nikki93> EvilTerran: NO! C++ IS GOOD!
10:57:18 <MichaelGG> The C name came later
10:57:23 <lilac> MichaelGG: if you start asking questions like that, you'll get answers containing "words" like "leverage"
10:57:25 <ozy`> and Java was about as shitty as it gets when C# was created
10:57:29 <erikc> MichaelGG: it isnt just programming languages, SQL is a mess for data management, it sticks cause of ignorance and big industry support
10:57:31 <Zao> joma: Just one level of embedding? :)
10:57:32 <MichaelGG> Cale, they jump on Ruby, Python, C#, etc.....
10:57:33 <EvilTerran> nikki93, piffle :P
10:57:44 <nikki93> Its made by Micrsoft (C) (R) (TM) so it, well, y'know.
10:57:48 <Cale> MichaelGG: But those are all basically the same language with minor variations.
10:57:52 <nikki93> ... Microsofts.
10:57:53 <leimy> nikki93: no that guy is way older :-)
10:57:54 <leimy> and cooler
10:57:58 <nikki93> lol
10:58:05 <MichaelGG> Cale good point
10:58:20 <MichaelGG> lilac, leverage?
10:58:22 * EvilTerran saw a page somewhere that picked out all of C++'s flaws, but can't find it now
10:58:29 <MichaelGG> oh as in leveraging existing skillsets?
10:58:41 <nikki93> Whoever writes the coolest haskell code for lambdabot here gets a nikkiHug.
10:58:43 <ozy`> EvilTerran: http://yosefk.com/c++fqa/ ?
10:58:57 <ozy`> EvilTerran: also http://yosefk.com/c++fqa/defective.html
10:59:01 <nikki93> EvilTerran: Listen. C++ is good. Haskell is good.
10:59:08 <nikki93> EvilTerran: Everything is good.
10:59:08 <EvilTerran> ozy`, ah, that's the one, yeah
10:59:14 <nikki93> EvilTerran: Except Java.
10:59:15 <MichaelGG> nikki93, oh god are you an agnostic
10:59:16 <arussel> has anyone experienced programming an arduino in haskell ?
10:59:34 <nikki93> MichaelGG: No I'm just a C++-liker but I need to give SOME explanation. :P
10:59:40 <MichaelGG> The one mindset that annoys me more than the C mindset is the one of "hey man, different tools for different things man!"
11:00:10 <ozy`> I dunno that I'll ever say "C++ is good" again... sheesh, even perl is nicer
11:00:17 <nikki93> MichaelGG: Annyone you /= wrong.
11:00:22 <ozy`> (well, perl is a -lot- nicer)
11:00:23 <nikki93> s/.*//
11:00:32 <nikki93> MichaelGG: Annoying you /= wrong.
11:00:36 <nikki93> MichaelGG: I don't care about you anyway. :P
11:00:38 <elbar> @src Maybe (>>)
11:00:39 <lambdabot> (Just _) >>  k      = k
11:00:39 <lambdabot> Nothing  >>  _      = Nothing
11:00:40 <MichaelGG> nikki93, sure
11:00:47 <ozy`> it was on the news this mroij ng
11:00:49 <ozy`> oh god
11:01:00 <nikki93> ozy`: It must still be morning lol
11:01:03 <ozy`> s/j //
11:01:04 <elbar> @src [] (>>)
11:01:04 <lambdabot> xs >> ys      = concatMap (const ys) xs
11:01:06 <MichaelGG> nikki93, i just find most arguments of that nature to be a "hmm, i cant decide so ill just agree with everyone" -- not that youre doing that.
11:01:37 <MichaelGG> Does anyone know of pages that describe FP's faults, and why other styles are better? Cause the main arguments I get are "its too hard"
11:01:47 <newsham> "Monads are a programmable '; x ='" just doesnt have the same ring to it as "monads are a programmable semicolon"
11:01:47 <PeakerWork> why does [] implement (>>)?
11:01:57 <nikki93> MichaelGG: The thing is, I still can't imagine writing a big program in haskell.
11:01:58 <Cale> PeakerWork: Because every monad does.
11:02:06 <nikki93> MichaelGG: Yeah, now you'll say xmonad.
11:02:09 <newsham> you get (>>) for free when you make (>>=)
11:02:30 <PeakerWork> Cale: it implements >>=, why also implement >> and not use the default?
11:02:36 <MichaelGG> nikki93, not really. im not very knowledgeable about haskell. I use F#
11:02:39 <ozy`> PeakerWork: x >> y = x >>= \_ -> y
11:02:40 <Cale> nikki93: What in particular do you find to be a stumbling block in that matter?
11:02:42 <PeakerWork> @src Maybe (>>)
11:02:43 <lambdabot> (Just _) >>  k      = k
11:02:43 <lambdabot> Nothing  >>  _      = Nothing
11:02:47 <newsham> err.. I guess that should be  "are a programmable '=: x;'"
11:02:52 <MichaelGG> nikki93, I just find haskell has so much to teach
11:02:54 <PeakerWork> ozy`: does lambdabot give you the src for (>>) based on that reduction?
11:02:56 <ozy`> PeakerWork: ah, I didn't realize it redefined it
11:03:01 <Cale> PeakerWork: Oh, I'm not sure that it does.
11:03:20 <Cale> PeakerWork: That code from @src is pulled from a number of sources. It's not necessarily what's actually used.
11:03:25 <ozy`> let's find out
11:03:28 <ozy`> @src >>
11:03:28 <lambdabot> m >> k      = m >>= \_ -> k
11:03:58 <trofi_> lunabot: when i'll se your actual sources?
11:04:04 <ozy`> PeakerWork: you'd have to look in the GHC library sources to see what's actually going on for real
11:04:16 <Cale> nikki93: I can't really imagine any specific *problem* in writing a large program in Haskell, apart from personal resources.
11:04:32 <erikc> personnel?
11:04:50 <ksf> ksf's second law: Investigating any arcane topic, you will stumble across Oleg.
11:04:52 <EvilTerran> personal resourcefulness? :P
11:04:55 <Cale> erikc: No, personal, in that I'm imagining writing such a program on my own.
11:04:59 <elbar> @src [] (>>=)
11:04:59 <lambdabot> xs >>= f     = concatMap f xs
11:05:01 <erikc> ah hehe
11:05:23 <anthonymiller> @let people_watching_a_lecture_right now = ["anthonymiller"]
11:05:25 <lambdabot>  Defined.
11:05:29 <Cale> But perhaps personnel as well, in that hiring Haskell programmers who live nearby would perhaps be an issue.
11:05:39 <ozy`> nikki93: haskell is enough of a paradigm shift away from (for example) C++ that writing a large program in haskell as you're still exploring how it works is tantamount to writing a large program in C++ while you're still exploring what programming means
11:06:06 <arussel> is there a avr compiler for haskell ?
11:06:13 <ozy`> nikki93: however, people can and do write large programs in haskell, and the properties of haskell help with their projects rather than hurting them
11:06:19 <ksf> with the difference that you'll be only writing unidiomatic haskell, not software that inherently sucks.
11:06:33 <erikc> i wonder if sony would count -fvia-C as 'being compiled with our approved c++ compiler' for certification purposes
11:06:55 <Olathe> > let laugh n = concat.concat.filterM (const.take n.randoms.mkStdGen $ n) $ ["HA", "ha"] in laugh 5
11:06:56 <lambdabot>   "HAhaHAhaHAhaHAHAHAhaHAhaHAhaHAHAHAhaHAhaHAhaHAHAhahahahahaha"
11:06:56 <ksf> they have to, haven't they?
11:06:57 <ozy`> ksf: well, haskell has its own gotchas, like getting tail recursion right
11:06:57 <Twey> erikc: I suppose it must
11:07:13 <Cale> arussel: avr?
11:07:18 <ozy`> ksf: so "unidiomatic" haskell is pretty bad for large projects anyway :p
11:07:19 <Twey> If they decline, you could simply show them the intermediate C code rather than the original Haskell :)
11:07:28 <vixey> @let haskell = "weird"
11:07:29 <lambdabot>  Defined.
11:07:30 <Cale> Twey: haha
11:07:34 <erikc> haha
11:07:44 <erikc> 'we totally coded it this way, its more powerful'
11:07:47 <arjanb> arussel: i don't think so
11:07:48 <arussel> Cale: for Atmel micro controller
11:07:48 <Twey> Hehe
11:08:07 <Twey> It's something I've always wondered about with the GPL and similar open-source licenses
11:08:32 <Twey> What if you say 'I coded it by hand and made it look like it was machine-compiled for fun'?
11:08:39 <erikc> course i'd also have to port the ghc runtime to a non-posix system...and i wouldnt be able to release the results cause of licensing...closed platforms suck
11:08:49 <Twey> There can't be any defence against that, surely
11:09:09 <ozy`> stop calling us Shirley
11:09:11 <arussel> arjanb: and to write one would not be trivial I suppose?
11:09:19 <Cale> Twey: Well, if you're the copyright holder, you can release whatever the heck you want...
11:09:47 <Twey> Cale: Not if it links with GPL'd apps
11:09:58 <ozy`> I saw a thread recently where people were arguing about whether music could be released under the GPL
11:10:06 <Cale> Twey: ah, okay
11:10:24 <Twey> You have to release the source code  but if you argued that it had been written by hand, the object code *is* the source code
11:10:34 <erikc> haha
11:10:36 <skorpan> is dat sum em dash
11:10:39 <ozy`> the main claim being, a particular song used samples, and the source for the samples wasn't available
11:10:42 <ksf> well, source form might be a video of jimi hendrix doing the teeth, with a note saying "well, you just gotta learn it"
11:10:51 <Twey> ozy`: Hahaha
11:11:00 <Cale> Twey: Another game you can play is that if you don't publically distribute your code, there's no need to release the source for it.
11:11:10 <erikc> google plays that game well
11:11:13 <Twey> Aye
11:11:15 <arjanb> arussel: it might possible to port a compiler to avr32, but i think other microcontrollers aren't powerfull enough
11:11:18 <Twey> Thus the AGPL &c.
11:11:19 <ozy`> crafty, crafty google
11:11:52 <cnwdup> How again can I test for 100 test cases with quickCheck even though my implications are quite restricting? I only get something like "Arguments exhausted after 0 tests.", etc.
11:12:43 <ski_> cnwdup : maybe you could build a custom generator
11:12:47 <Cale> "I wrote the program in an obfuscated programming language whose operations are encoded in the low order bits of a video file. This is the video file. Good luck."
11:12:58 <Twey> Bwahahaha
11:13:36 <Saizan> cnwdup: write a custom generator
11:13:41 <arussel> arjanb: too bad. I would have like to mix my 2 hobbies. Maybe I'll give a shot at writing one, one day.
11:13:48 <Saizan> cnwdup: and use forAll
11:13:59 <nikki93> Anything that is type IO something is an I/O action. You can store it and nothing will happen. I could say writefoo = putStrLn "foo" and nothing happens right then. But if I later use writefoo in the middle of another I/O action, the writefoo action will be executed when its parent action is executed -- I/O actions can be glued together to form bigger I/O actions. The () is an empty tuple (pronounced unit), indicating that there is no return value from
11:14:06 <nikki93> So WHEN are they executed?
11:14:16 <Cale> nikki93: main is executed
11:14:23 <cnwdup> Saizan, ski_: Okay. I'll do. Thanks. (-:
11:14:42 <nikki93> Cale: So 'main' is the IO-action-god?
11:14:48 <Twey> Indeed
11:14:50 <Cale> nikki93: Yes.
11:14:56 <nikki93> Ah.
11:15:04 <nikki93> What if I want input NOW?
11:15:04 <leimy> right off the bat you're in pollution land
11:15:07 <arjanb> arussel: using haskell as a DSL to generate code for them might work
11:15:08 <Cale> nikki93: Also, if you type an IO action at the ghci prompt, ghci will execute it.
11:15:17 <mstr> > let fac n = foldr (*) 1 [1..n]
11:15:18 <lambdabot>   <no location info>: parse error on input `;'
11:15:23 <Twey> nikki93: You get it
11:15:36 <Twey> The way to look at it is... Haskell never does IO
11:15:36 <Cale> nikki93: Take the input as a parameter to the function, perhaps?
11:15:38 <mstr> ?
11:15:47 <Saizan> mstr: @let
11:15:48 <Cale> mstr: no 'in'
11:15:57 <nikki93> Cale: Oh so its executed only when 'inspected'?
11:15:59 <mstr> > @let fac n = foldr (*) 1 [1..n]
11:16:00 <Twey> Your entire Haskell program is actually *generating* a data structure that is the 'real program'
11:16:00 <lambdabot>   <no location info>: parse error on input `@'
11:16:07 <Twey> Which the runtime then executes
11:16:10 <trofi_> > let a = 1 in a^a
11:16:12 <lambdabot>   1
11:16:21 <Cale> nikki93: You can imagine that running a Haskell program consists of two separate but interleaved processes:
11:16:25 <Twey> (retrieving it from main)
11:16:25 <ozy`> nikki93: the solution is to inspect all the input you want before you actually need it
11:16:27 <Twey> Of course, since it's Haskell it's generated lazily
11:16:41 <Cale> nikki93: 1) Evaluation, which is the reduction of expressions to values, and is completely pure.
11:16:49 <leimy> there is no spoon
11:17:05 <Cale> nikki93: 2) Execution, which inspects an IO action and carries out the effects that it describes.
11:17:26 <nikki93> Cale: Ok. I'll read the rest of the chapter now.
11:17:37 <leimy> it is you that bends
11:17:44 <Twey> Hahaha, leimy
11:17:51 <Cale> Evaluating an IO action simply reduces it to itself. It doesn't actually cause the effects described to occur (similar to how loading the source code of a program into a text editor won't cause that program to run)
11:18:24 <leimy> liking C++ after haskell is like wanting to be plugged back into the matrix, except the C++ matrix is dumb.
11:18:34 <tromp__> @pl \x -> if null x then [0] else x
11:18:34 <lambdabot> flip if' [0] =<< null
11:18:52 <tromp__> :t if'
11:18:54 <lambdabot> Not in scope: `if''
11:19:13 <ski_> if' :: Bool -> a -> a -> a
11:19:18 <trofi_> c++ is a little more portable :]
11:19:19 <Olathe> @type trace
11:19:20 <ozy`> yeah, you can do stuff like this with no observable effects: putStrLn "You will never see this output" `seq` (12, 13)
11:19:21 <lambdabot> Not in scope: `trace'
11:19:24 <nikki93> leimy: Bah. C++ is good.
11:19:35 <nikki93> leimy: HAskell programming is a lot about the language.
11:19:38 <nikki93> leimy: C++ isn't.
11:19:43 <trofi_> is
11:19:45 <skorpan> that doesn't make any sense
11:19:46 <PeakerWork> nikki93: what do you mean "a lot about the language"?
11:19:52 <trofi_> look at templates and inheritance
11:19:56 <chessguy_work> @type putStrLn "You will never see this output" `seq` (12, 13)
11:19:58 <lambdabot> forall t t1. (Num t1, Num t) => (t, t1)
11:20:01 <lucca> > fix $ seq 1
11:20:02 <nikki93> Just C++ is nothing.
11:20:13 * Twey laughs.
11:20:13 <leimy> No
11:20:17 <lambdabot>   thread killed
11:20:19 <leimy> > Just ("C++")
11:20:20 <ozy`> leimy: like if Cypher was trading his freedom for a steady diet of cheap fries instead of steak?
11:20:21 <lambdabot>   Just "C++"
11:20:25 <leimy> see it's Just C++
11:20:31 <Twey> Maybe ProgrammingLanguage
11:20:33 <leimy> ozy`: right
11:20:40 <skorpan> nikki93: C++ is nothing?
11:20:42 <nikki93> Once you 'understand' a part of it, its all about libraries and bla.
11:20:53 <leimy> > :t (Just "C++")
11:20:54 <lambdabot>   <no location info>: parse error on input `:'
11:21:00 <leimy> :t (Just "C++")
11:21:01 <lambdabot> Maybe [Char]
11:21:06 <nikki93> Haskell, I've seen, the language ITSLELF does stuff.
11:21:13 <leimy> :t Nothing :: [Char]
11:21:14 <lambdabot>     Couldn't match expected type `[Char]'
11:21:14 <lambdabot>            against inferred type `Maybe a'
11:21:17 <leimy> doh!
11:21:20 <Twey> nikki93: You mean the language isn't useless :-P
11:21:26 <trofi_> :]
11:21:27 <vixey> @remember <nikki93> Haskell, I've seen, the language ITSLELF does stuff.
11:21:27 <lambdabot> Done.
11:21:30 <nikki93> Twey: Probably,
11:21:35 <Olathe> @type Nothing :: m [Char]
11:21:37 <lambdabot>     Couldn't match expected type `m' against inferred type `Maybe'
11:21:37 <lambdabot>       `m' is a rigid type variable bound by
11:21:37 <lambdabot>           the polymorphic type `forall (m :: * -> *). m [Char]'
11:21:39 <nikki93> Twey: Probably without PRelude its nothing though,
11:21:42 <ozy`> nikki93: most of the functionality in haskell is provided as normal functions, dude
11:21:48 <ozy`> it's written in itself for the most part
11:21:55 <anthonymiller> @vixen have you met C++?
11:21:56 <lambdabot> good question
11:22:00 <Twey> nikki93: The prelude is just part of the stdlib
11:22:15 <Olathe> @@ @vixen @run laugh 6
11:22:16 <lambdabot>  whatever
11:22:22 <chessguy_work> haha
11:22:24 <Cale> nikki93: Huh, from my perspective, C++ is actually quite complicated.
11:22:25 <Twey> Heh
11:22:31 <nikki93> The thing is, beyond a certain point, the language doesn't matter any more.
11:22:34 <nikki93> Ches.
11:22:35 <Twey> C++ is more complicated than Haskell is
11:22:36 <nikki93> Chess.
11:22:41 <nikki93> "Oh I know all the rules"
11:22:47 <nikki93> "But does that mean you're a master yet?"
11:22:50 <Cale> nikki93: That is, the language itself. In Haskell most of the ideas really can be in libraries.
11:22:51 <nikki93> "No"
11:23:06 <trofi_> true
11:23:10 <skorpan> nikki93: you're saying once you know the rules of C++ you master it?
11:23:12 <nikki93> Art = mixing colours or?
11:23:21 <nikki93> skorpan: I'm saying the exact opposite.
11:23:34 <Twey> nikki93: That's not really the point  involved in using a programming language are two different disciplines: the language, and computer science
11:23:45 <PeakerWork> nikki93: knowing all of the C++'s syntax (quite a feat, even that is) and basic rules does not mean you "know C++" either
11:23:54 <mstr> most c++ coders don't even know the rules :D
11:23:58 <nikki93> There are two aspects to everything, the 'technical' and the 'human' aspect.
11:24:10 <Twey> You can be a master of a given programming language, but still be a useless programmer, if you don't understand the abstract concepts of CS
11:24:14 <trofi_> mstr: and that's a problem :]
11:24:24 <nikki93> In painting, you have mixing colours, holding the brush etc.
11:24:28 <nikki93> Everyone can do that.
11:24:29 <nikki93> But what makes a good artist?
11:24:39 <skorpan> what's your point nikki93?
11:24:45 <ozy`> nikki93: I think the "mental" and the "spiritual" aspects are more appropriate to talk about. see, C++ is like a burrito. it's a spiritual thing.
11:24:46 * Saizan sees the signal to noise ratio rapidly declining
11:25:06 <nikki93> skorpan: My point is, after you see the irrelevance and triviality of the 'technical' part, you see the real difference.
11:25:11 <Twey> nikki93: But even the best artists would have trouble painting if they had to paint with a trowel :)
11:25:32 <Twey> Not to say that they couldn't do it
11:25:38 <nikki93> Twey: They could make a different kind of art though.
11:25:42 <hallongrottan> ...
11:25:43 <Twey> But it wouldn't be particularly easy, or fun.
11:25:52 <nikki93> Twey: If it isn't fun then don't do it.
11:25:56 <nikki93> Twey: Its THAT simple.
11:26:03 <Olathe> If you don't know what a burrito is, it's a bit like a monad.
11:26:11 <Twey> nikki93: I think you're missing the point :)
11:26:19 <nikki93> Twey: But you don't paint with a brush and say painting with a towel sucks. Other artists might be doing it and liking it.
11:26:37 <nikki93> Everything has to be done by someone.
11:26:52 <Twey> Yes, but in CS we generally have to make something useful  a realistic painting, say
11:26:56 <nikki93> A world where everyoned does the same thing is... Well... YOu really wont like what you do anymore.
11:27:21 <Twey> A trowel might be OK for impressionism or something where accuracy doesn't matter too much
11:27:32 <nikki93> I don't know really. The thing with C++ and haskell is, they're so different that they don't intersect in 'use space'.
11:27:44 <vincenz> Anyone remember the website with info on FRP and how you could just drag gui components?
11:27:47 <Twey> But for realism, it's not a good choice at all.
11:27:53 <MichaelGG> nikki93, they shouldnt, except people use C++ for too many things.
11:27:56 <Twey> vincenz: There was a GTT video
11:28:03 <vincenz> Twey: GTT?
11:28:07 <Twey> Google Tech Talks
11:28:09 <orbitz> google tech talk
11:28:13 <Twey> It's called Eros
11:28:20 <nikki93> Actually.
11:28:25 <nikki93> I don't know why I use C++ either.
11:28:26 <nikki93> :P
11:28:29 <SamB_irssi> I thought he said towel
11:28:33 <nikki93> But I don't 'use' it anyway.
11:28:33 <SamB_irssi> not trowel
11:28:36 <nikki93> I don't have a job or whatever.
11:28:41 <Twey> nikki93 misread my 'trowel' as 'towel' :)
11:28:42 <orbitz> http://www.youtube.com/watch?v=faJ8N0giqzw is probably what you are thinking of
11:28:46 <Twey> vincenz: http://www.haskell.org/haskellwiki/Eros
11:28:51 <vincenz> Twey: thanks
11:29:05 <mauke> am I still allowed to troll here now that I have +o powers?
11:29:18 <nikki93> Twey: Ahh... You meant trowel? *dict trowel*
11:29:20 <orbitz> mauke: only if you trol lme
11:29:27 <nikki93> You mean the cylindrical brush that absorbs fluid?
11:29:38 <nikki93> Cylidrical on a stick perpendicular to axis of rotation?
11:29:57 <Twey> nikki93: A trowel is a heavy metal instrument used for laying cement.
11:30:00 <nikki93> BTW, are there any physical simulation libraries written in Haskell?
11:30:09 <Twey> Er, digging rather.
11:30:17 <nikki93> Twey: Oh. You mean the kite-shaped spade-thing?
11:30:18 <Twey> What's the name of the cement tool?  I feel it's rather similar to 'trowel'.
11:30:31 <nikki93> Twey: #^$% you I'll google it.
11:30:36 <Twey> Oh, they're both trowels.
11:30:42 <Twey> nikki93: http://en.wikipedia.org/wiki/Trowel
11:30:48 <nikki93> Twey: Yeah that's it wikipediad it.
11:30:48 <Olathe> I have let f x y = trace ("f " ++ show x ++ " " ++ show y) (x + y), but ghci doesn't think that the arguments are in class Show. How does that happen ?
11:30:50 <nikki93> Twey: Yeah.
11:30:59 <ozy`> nikki93: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:physics
11:31:09 <nikki93> Anyway, I'll stop discussing C++ vs. Haskell now because it feels pointles really.
11:31:13 <nikki93> Its like French vs English lol.
11:31:16 <Olathe> f :: (Num a) => a -> a -> a
11:31:32 <Saizan> ?src Num
11:31:32 <lambdabot> class  (Eq a, Show a) => Num a  where
11:31:32 <lambdabot>     (+), (-), (*)           :: a -> a -> a
11:31:32 <lambdabot>     negate, abs, signum     :: a -> a
11:31:32 <lambdabot>     fromInteger             :: Integer -> a
11:31:33 <ksf> I'm reading rumors that libffi supports dynamic calling of varags functions on x86 and amd64.
11:31:39 <cnwdup> ski_: Mh, can I somehow tell test until you have passed 100 tests or until one fails? Writing a custom generator is tricky in my case.
11:31:41 <Saizan> Olathe: see the superclasses
11:31:51 <Olathe> Ahh, thanks.
11:31:54 <Twey> nikki93: More like Vietnamese vs. Lojban
11:32:03 <ksf> ...which is cool 'cos fixed-arity wrappers suck.
11:32:11 <ozy`> Twey: as a linguist I take offense to the mention of Lojban
11:32:33 <Twey> ozy`: As a linguist I take offence to your taking offence to the mention of Lojban
11:32:47 <ozy`> Twey: as a linguist, NO U
11:32:56 <Olathe> As a linguist,
11:32:56 <Twey> ozy`: As a linguist, UR MUM
11:32:58 <Olathe> > laugh 6
11:33:00 <lambdabot>   HAhaHAHAhaHAhaHAHAhahahahahaHAhaHAHAhaHAhaHAHAhaHAhaHAHAhaHAhaHAHAhahahahah...
11:33:17 <Twey> (le'o)
11:33:18 <ski_> cnwdup : i don't know that much about it ..
11:33:26 <nikki93> Perform vs evaluate. What is it?
11:33:32 <vegai> hey, at least it's not esperanto
11:33:39 <cnwdup> ski_: ok
11:33:53 <Twey> u vi ne amas esperanton?!
11:33:53 <ozy`> vegai: that would be Java, I suppose
11:33:57 <Twey> Heh
11:34:06 <Twey> nikki93: Hmm
11:34:09 <nikki93> @quote nikki93
11:34:10 <lambdabot> nikki93 says: > let laughAtPerson n y = if (n > 0) then "ha" ++ laughAtPerson (n - 1) y else "aa " ++ y ++ "! :P" in "Ha" ++ (laughAtPerson 8 "ehird")
11:34:17 <mauke> what is u?
11:34:20 <nikki93> > let laughAtPerson n y = if (n > 0) then "ha" ++ laughAtPerson (n - 1) y else "aa " ++ y ++ "! :P" in "Ha" ++  (laughAtPerson 8 "ehird")
11:34:22 <lambdabot>   "Hahahahahahahahahaaa ehird! :P"
11:34:28 <Twey> mauke: Yes/no question marker
11:34:34 <nikki93> > let laughAtPerson n y = if (n > 0) then "ha" ++ laughAtPerson (n - 1) y else "aa " ++ y ++ "! :P" in "Ha" ++  (laughAtPerson 8 "Olathe")
11:34:35 <lambdabot>   "Hahahahahahahahahaaa Olathe! :P"
11:34:41 <trofi_> wtf?
11:34:54 <vegai> Twey: I don't like it because it's supposed to be simple and it's not
11:35:08 <nikki93> > laugh
11:35:09 <lambdabot>       Overlapping instances for Show (Int -> Expr)
11:35:09 <lambdabot>        arising from a use ...
11:35:12 <Olathe> > laugh 3
11:35:14 <lambdabot>   HAhaHAhaHAHAhaHAhaHAhaha
11:35:17 <nikki93> > laugh 4
11:35:18 <lambdabot>   HAhaHAHAHAhahahahahaHAhaHAHAHAha
11:35:47 <PeakerWork> > laugh (-5)
11:35:49 <lambdabot>   mueval: Prelude.read: no parse
11:35:49 <nikki93> > replicate 2 (laugh 2 ++ " Olathe ")
11:35:50 <vegai> Twey: or rather I'm suspicious about its worth
11:35:51 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
11:35:52 <Twey> nikki93: Cale and I were making the same point: running of a Haskell program proceeds in two steps.  Firstly, it evaluates your program to obtain a datatype detailing what to do next; then, it evaluates that script
11:36:13 <PeakerWork> > hahahahhahaha
11:36:14 <lambdabot>   Not in scope: `hahahahhahaha'
11:36:17 <nikki93> > repeat (laugh 2 ++ " Olathe ")
11:36:17 <Twey> vegai: It could have been done better, but it has some worth as it is
11:36:18 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
11:36:25 <vegai> Twey: I suppose I feel quite the same about
11:36:25 <nikki93> > laugh 2 ++ " Olathe "
11:36:26 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
11:36:30 <vegai> Twey: ... java
11:36:36 <nikki93> :t laugh
11:36:37 <lambdabot> Int -> Expr
11:36:42 <Olathe> > let laughAt n xs = say $ show (laugh n) ++ " " ++ xs in laughAt 2 "nikki93"
11:36:43 <nikki93> laugh 2
11:36:44 <lambdabot>   HAhaHAhaHAhaHAha nikki93
11:36:46 <Twey> It's obviously not *that* simple, but it's clearly0 simpler than, say, English
11:36:54 <Twey> s/clearly0/clearly/
11:37:07 <ksf> is everyone using c2hs or why else is hsffig abandonware?
11:37:08 <nikki93> > repeat (show (laugh 2) ++ " Olathe ")
11:37:09 <lambdabot>   ["HAhaHAhaHAhaHAha Olathe ","HAhaHAhaHAhaHAha Olathe ","HAhaHAhaHAhaHAha Ol...
11:37:33 <vegai> hey, haskell is serious business! Stop having fun!
11:37:34 <nikki93> > let laughAtPerson n y = if (n > 0) then "ha" ++ laughAtPerson (n - 1) y else "aa " ++ y ++ "! :P" in "Ha" ++  (laughAtPerson 8 "Olathe")
11:37:36 <lambdabot>   "Hahahahahahahahahaaa Olathe! :P"
11:37:39 <idnar> > concat . repeat $ show (laugh 2) ++ " Olathe "
11:37:40 <lambdabot>   Not in scope: `laugh'
11:37:52 <Olathe> Hahaha
11:37:52 <idnar> eek
11:37:52 * nikki93 kills vegai 
11:37:56 <Twey> nikki93: main is the function that returns the 'script' to be executed.
11:37:56 <vegai> :)
11:38:09 <nikki93> > let laughAtPerson n y = if (n > 0) then "ha" ++ laughAtPerson (n - 1) y else "aa " ++ y ++ "! :P" in "Ha" ++  (laughAtPerson 8 "vegai")
11:38:10 <lambdabot>   "Hahahahahahahahahaaa vegai! :P"
11:38:32 <skorpan> is gmapT :: (forall b. Term b => b -> b) -> a -> a just an overly verbose notation for gmapT :: (Term b => b -> b) -> a -> a or is the explicit quantifier important here?
11:38:58 <ozy`> Twey: human language has a lower bound of complexity because of the things humans must be able to express. attempting to reduce complexity (as with Esperanto) only results in the generation of additional complexity which in turn usually goes unnoticed by the language-smith
11:39:03 <tromp__> @instances Maybe
11:39:04 <lambdabot> Couldn't find class `Maybe'. Try @instances-importing
11:39:16 <sw17ch> @let kill = undefined
11:39:17 <lambdabot>  Defined.
11:39:28 <ski_> skorpan : i'm not sure, but i'd wager it is important
11:39:29 <tromp__> @instances Maybe a
11:39:29 <lambdabot> Couldn't find class `Maybe a'. Try @instances-importing
11:39:31 <int80_h> chessguy_work: you there?
11:39:58 <ski_> (skorpan : i.e. i'd expect `gmapT :: (Term b => b -> b) -> a -> a' to mean `gmapT :: forall a b. (Term b => b -> b) -> a -> a')
11:40:04 <Twey> ozy`: That's a bit Einsteinian: 'as simple as possible, but no simpler'
11:40:08 <tromp__> @classes Maybe
11:40:08 <lambdabot> Unknown command, try @list
11:40:11 <tromp__> @list
11:40:12 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:40:25 <skorpan> ski_: so that means that the quantifier isn't important?
11:40:36 <ski_> skorpan : the opposite
11:40:45 <skorpan> i don't follow...
11:40:55 <Twey> ozy`: I can certainly see where you're coming from, but I don't know if I agree that Esperanto crosses the bound
11:41:13 <int80_h> hpaste is down for me, what's an alternative?
11:41:18 <ski_> skorpan : `gmapT :: forall a. (forall b. Term b => b -> b) -> a -> a' is definitely not the same as `gmapT :: forall a b. (Term b => b -> b) -> a -> a'
11:41:23 <kiris> http://paste.lisp.org/
11:41:42 <skorpan> ski_: why not?
11:42:18 <EvilTerran> http://moonpatio.com:8080/fastcgi/hpaste.fcgi
11:42:51 <ski_> skorpan : in the latter, you can pass in a function of type `Term b => b -> b' for any specific `b' you like .. in the latter, you have to pass in a function polymorphic in `b'
11:43:03 <skorpan> ah
11:43:08 <ozy`> Twey: the Esperanto community has "filled in" a lot of unspecified behavior, sometimes in inconsistent and contradictory ways, because Zamenhof didn't quite understand what he was doing
11:43:22 <EvilTerran> lojban!
11:43:43 <ski_> (skorpan : sorry, the latter "latter" should be "former")
11:43:54 <ozy`> Lojban is something of an improvement but it still looks and sounds like ass :p (that's subjective though, I admit)
11:44:10 <Twey> .ie-nai
11:44:30 <skorpan> ski_: i got the point nevertheless! :) thanks for the explanation
11:44:36 <Twey> I find it has nice-sounding parts and nastier-sounding parts
11:44:40 <Twey> Much like most languages :)
11:45:10 <ozy`> Twey: for a true linguistic mindfuck, check out Ithkuil
11:45:16 <Twey> Yeah, been there
11:45:27 <Twey> You mean ikuil, IIRC :-P
11:45:46 <EvilTerran> ick
11:45:46 <int80_h> hey, would someone help me out the my graham scan algorithm code? I'm almost done
11:45:47 <EvilTerran> :P
11:45:50 <int80_h> http://paste.lisp.org/display/73934
11:45:55 <ozy`> I'm sticking to ASCII unless necessary :p
11:46:01 <Twey> Oh no
11:46:02 <int80_h> btw, this is an exercise from RWH
11:46:04 <Twey> ikul
11:46:15 <trofi_> sounds like SQL? :]
11:46:21 <Twey> Wow, I can type that.  <3 Compose.
11:46:30 <vincenz> @seen apfelmus
11:46:30 <lambdabot> I haven't seen apfelmus.
11:46:54 <vincenz> int80_h: easy
11:47:00 <vincenz> int80_h: filterPoint _ = [x]
11:47:04 <vincenz> int80_h: where does it get that x from?
11:47:23 <int80_h> @seen chessguy_work
11:47:23 <lambdabot> I saw chessguy_work leaving #novalang and #haskell 21m 27s ago, and .
11:47:37 <ozy`> int80_h: maybe you meant: filterPoint (x:_) = [x]
11:47:38 <int80_h> oh crap!
11:47:43 <vincenz> ozy`: that is broken
11:47:46 <vincenz> ozy`: what if he has an empty list?
11:47:54 <int80_h> this is a scope problem
11:48:04 <ozy`> vincenz: he'll need another case, yeah
11:48:13 <ozy`> int80_h: well the compiler told you that already....
11:48:16 <ozy`> ;)
11:48:39 * ksf must stop thinking high-level while thinking about c.
11:48:52 <ksf> I'm just going to pretend to read asm.
11:48:53 <waterman> Considering using a monadic interpreter (cf Liang Hudak & Jones) for a data mining DSL.  Anyone have an actual example of monadic interpreter code?  is the GHCI interpreter constructed this way?
11:49:24 <ski_> int80_h : `calcDirectionList (x:y:z:zs) = (calcTurn x y z) : (calcDirectionList (y:z:zs))' might be written `calcDirectionList (x:rest@(y:z:_)) = calcTurn x y z : calcDirectionList rest'
11:49:29 * mux hasn't got a single answer to his haskell-cafe@ post about the space leak with Data.Binary :-/
11:49:35 <EvilTerran> waterman, GHCI doesn't work that way; i imagine there are things that do, though
11:49:53 <ksf> ghci is constructed in terms of the ghc RTS...
11:49:59 <EvilTerran> quite
11:50:05 <EvilTerran> it doesn't exactly interpret
11:50:23 <ksf> ...and the ghc lib is monadic, for most definitions of monadic.
11:50:51 <ksf> there are also people who like to talk about the "expression monad", though you'll never stumble across source for it.
11:51:32 <ksf> dunno if the bytecode interpreter works monadic, but i'll guess so.
11:51:50 * EvilTerran would have to look up Liang Hudak & Jones to know exactly what kinda thing waterman's thinking of
11:51:50 <Twey> Where does GHC get its C compiler for -fvia-C?
11:52:02 <waterman> OK - the GHCI thought seems to be a distractor.
11:52:08 <Twey> Can I make it use mingw32?
11:52:24 <ksf> I bet there is a flag for that.
11:52:41 <ksf> that failing, I bet there is a flag to keep .c files.
11:52:56 <Twey> Mm
11:53:05 <ksf> anyway, -viac is evil, you shouldn't use it.
11:53:10 <acidjnk> hello
11:53:16 <acidjnk> What's chop8 and where can I get it?
11:53:21 <Twey> ksf: Oh, I'm sorry, I'll use the new built-in cross-compiler then?  ;)
11:53:26 <erikc> twey: ghc on windows comes with a copy of g++
11:53:28 <EvilTerran> ?hoogle chop8
11:53:29 <lambdabot> No results found
11:53:43 <sw17ch> Twey: what are you trying to do?
11:53:44 <waterman> The monadic interpreter idea is to use separate monads to handle various kinds of state within the program flow.  e.g. an Env monad to handle execution environment (scope), a Cont monad for continuation state, etc.  They get layered up as a set of monad transformers.
11:53:50 <Twey> sw17ch: Cross-compile
11:53:51 <Twey> Clearly
11:54:05 <sw17ch> Twey: have you cross-compiled the RTS?
11:54:11 <waterman> There's some more discussion of the architecture style at http://lambda-the-ultimate.org/node/552
11:54:12 <EvilTerran> waterman, ah, that kinda thing; i'm afraid the only example i know of is in my lecture notes =/
11:54:13 <Twey> Linux32 -> Win32, specifically
11:54:19 <Twey> sw17ch: Not yet
11:54:20 <sw17ch> (is that part even necessary?)
11:54:25 <Twey> I don't know
11:54:26 <sw17ch> ah!
11:54:29 <Twey> I'm trying to find out what is :)
11:54:36 <sw17ch> yeah, there's a way to override the C compiler..
11:55:14 <sw17ch> ghc -pgmc gcc
11:55:18 <sw17ch> Twey: ^^
11:55:31 <Twey> Ooh, thanks :)
11:55:47 <sw17ch> Twey: see REPLACING PHASES in the ghc man page
11:55:54 <vixey> waterman yes ?
11:56:06 <Twey> sw17ch: I don't have a ghc man page :(
11:56:21 <Twey> For some strange reason none of the Arch Haskell pages come with docs.
11:56:26 <Twey> Er, packages**
11:56:53 <sw17ch> Twey: http://linux.die.net/man/1/ghc
11:57:04 <tromp__> :t unfold
11:57:05 <lambdabot> Not in scope: `unfold'
11:57:09 <tromp__> :t unfoldL
11:57:10 <EvilTerran> waterman, actually, you can get at the notes i was thinking of, although i now recall that the lecturer used some slightly odd notations in order to skirt around such things as typeclasses: http://tinyurl.com/plwiki
11:57:10 <lambdabot> Not in scope: `unfoldL'
11:57:17 <Twey> On die.net?  Seriously?  Wow
11:57:18 <tromp__> :t unfoldl
11:57:19 <lambdabot> Not in scope: `unfoldl'
11:57:20 <tromp__> :t unfoldr
11:57:21 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
11:57:49 <Twey> Ah
11:57:52 <Twey> The section says:
11:57:54 <Twey> -pgmL cmd -pgmP cmd -pgmc cmd -pgmm cmd -pgms cmd -pgma cmd -pgml cmd -pgmdll cmd -pgmF cmd -pgmwindres cmd
11:58:07 <Twey> This is helpful
11:58:10 <sw17ch> look for the second occurance
11:58:20 <Twey> Ah, I see it :)
11:58:24 <sw17ch> :)
11:58:41 <Twey> Thankee!
11:58:50 <waterman> @EvilTerran - thanks for the notes pointer. looks like a good resource for me.
11:58:50 <lambdabot> Unknown command, try @list
11:58:59 * sw17ch had some horrid experience with a mingw32 bug under vista with ghc 6.8.3
11:59:09 * sw17ch which taught him all sorts of nifty things in GHC
11:59:56 <ozy`> will foldl be strict by default in haskell prime?
12:01:48 <waterman> ozy - foldl is lazy be default.  foldl' is strict.  huge difference in runtime behavior.
12:02:16 <mauke> how does that answer the question?
12:02:27 <Cale> ozy`: I doubt it.
12:02:39 <vixey> hwy is haskell` so stupid
12:02:41 <PeakerWork> maybe we should pass strictness as a strategy or such?
12:02:52 <PeakerWork> (as a function argument, that is)
12:02:53 <joma> "yo dawg I heard you like html so I put some html in your code so you can put code in your html" , lamest yet?
12:02:54 <vixey> giving specifications for all the -X<whatever> stuff is a great idea
12:02:57 <ozy`> waterman: I know this. foldl' is generally a lot more useful because it can be tail recursive
12:03:03 <ozy`> hence my question
12:03:13 <PeakerWork> joma: ?
12:03:15 <PeakerWork> as to parameterize strictness
12:03:38 <Cale> My hope is that eventually strictness analysis gets good enough that the difference between foldl and foldl' becomes mostly irrelevant.
12:03:40 <RayNbow> :t foldl
12:03:41 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:03:50 <ozy`> Cale: that'd be nice, too
12:04:00 <RayNbow> the question is, does a strict left fold make sense for *all* a and b?
12:04:12 <mux> PeakerWork: that would just be very inconvenient
12:04:23 <PeakerWork> mux: unless we find the right abstraction for it :)
12:04:41 <mux> well you were suggesting adding a function parameter
12:04:42 <PeakerWork> mux: The "right" way to do things often starts out inconvenient, but promotes the search of how to do it both right and convenient (e.g purity)
12:04:56 <gds> Is there anything in ghci like "dir" in python - to get a list of functions/types exported by a module?
12:04:59 <eu-prleu-peupeu> hello haskl3z0rs
12:05:24 <mux> I'm not willing to add an extra parameter to all my folds and the gazillon other functions where there are strict vs lazy variants
12:05:27 <gds> So I could do something like :m + Network.HTTP  ; dir Nework.HTTP
12:05:28 <Cale> There are a fair number of cases where foldl makes more sense than foldl', for example, in the case of reverse = foldl (flip (:)) [], foldl' just seems to waste a bit of extra time.
12:05:45 <RayNbow> has this been posted in #haskell today? http://apfelmus.nfshost.com/monoid-fingertree.html "How can one tree be useful for so many different data structures? The answer: monoids!"
12:05:47 <ziman> gds, you can try :browse Data.List, for example
12:06:00 <gds> ziman: Thanks :)
12:06:02 <ziman> (or Network.HTTP)
12:06:20 <ozy`> Cale: all right, I'll buy that
12:06:57 <conal> hooray Monoid !
12:07:25 <Cale> It's nice to see that people are finally taking an interest in the monoid class.
12:07:33 <mauke> parse errors almost form a monoid
12:07:46 <vixey> haha
12:07:56 <vixey> Cale is this sacarsm??
12:08:02 <Cale> vixey: No.
12:08:16 <vixey> all I saw was this ridiculous thread about it
12:08:22 <PeakerWork> mux: maybe you can just compose the folds you use together, and your function gets the extra parameter and passes it on for free, or some such?
12:08:27 <sm> I'm finding it informative
12:08:32 <PeakerWork> mux: maybe you put your folding functions in some strictness monad?
12:08:37 <Cale> vixey: Well, that ridiculous thread has started to transform into intelligent discussion.
12:08:43 <eu-prleu-peupeu> im going to create the haskell library that is going to take haskell out of the dark ages!
12:08:52 <eu-prleu-peupeu> i just dont know what library it is yet
12:09:09 <Cale> I'm going to create the library that will sing the song that ends the world!
12:09:13 <RayNbow> Cale: just wondering, when did you learn about monoids?
12:09:18 <eu-prleu-peupeu> ahah
12:09:20 <Cale> RayNbow: Before Haskell.
12:09:37 <vixey> in abstract algebra?
12:09:38 <eu-prleu-peupeu> Cale: will it rain a lot ?
12:09:42 <Cale> RayNbow: Sometime around when I learned what a group was.
12:09:47 <Cale> vixey: yeah
12:09:55 * RayNbow learnt 'bout monoids by hanging out in #haskell :p
12:09:55 <eu-prleu-peupeu> because if it will, maybe i should start building the ark then
12:10:23 * roconnor tries to remember when he learnd monoids
12:10:23 <RayNbow> Cale: was that in college/university?
12:10:50 --- mode: irc.freenode.net set +o ChanServ
12:10:58 <Cale> RayNbow: Yeah... though I'm not sure, I might have even bumped into it before that... I had a tendency to read bits of mathematics encyclopedias.
12:11:04 <RayNbow> ah
12:11:25 <int80_h> jebus! chanel join attack
12:11:44 <Cale> It's the network reconnecting.
12:11:46 <bd__> int80_h: no, netsplit recovery
12:11:59 <int80_h> ah
12:12:29 <RayNbow> when in middle/high school, I browsed the web for math articles... but it was fairly simple stuff
12:13:22 <RayNbow> but then again, I have the feeling not a whole lot of math is taught here in the Netherlands until you decide to study math at a university
12:13:34 <Cale> RayNbow: Oh, it's the same here.
12:13:51 <RayNbow> (imo, more math should be taught before people go to college/uni)
12:14:01 <sw17ch> we have a problem where people don't understand that 27% interest on a pay-day loan is a bad deal
12:14:15 <sw17ch> more math should be taught before people are allowed to go into debt
12:14:19 <Cale> RayNbow: I just ended up getting interested in it after reading Gdel, Escher, Bach, and then started reading everything I could find.
12:14:44 <idnar> hmm
12:14:44 <Cale> (even things I didn't properly understand ;)
12:14:50 <RayNbow> :p
12:14:52 <idnar> I also started with GEB, except that's also pretty much where I ended
12:15:01 <idnar> everything else I know is just bits and pieces from here and there
12:15:02 * RayNbow didn't really have guidance when he was in his teenage years :p
12:15:08 <int80_h> Cale: Knuth turned me around on math. I didn't like it until I read him.
12:15:13 <RayNbow> so I didn't really read the good stuff
12:15:22 <idnar> although I think I wasn't even a teenager when I first tried to read GEBX
12:15:23 <idnar> *GEB
12:15:39 <cnwdup> @src maximum
12:15:39 <lambdabot> maximum [] = undefined
12:15:40 <lambdabot> maximum xs = foldl1 max xs
12:15:43 <Cale> Yeah, it would have been nice to have had at least one person who could point me at the right things to read in turn.
12:15:43 <idnar> took a couple of years and readings before things started to make sense :P
12:15:46 <int80_h> yeah I read GEB, can't say I understood everything. it's pretty dense
12:15:54 * RayNbow has Knuth's TAOCP, but hasn't read it yet... (at most a few chapters/sections)
12:16:06 <cnwdup> Why are so many functions which are defined using foldl? I thought that would lead to poor performance.
12:16:17 <Cale> cnwdup: It can.
12:16:27 <cnwdup> Cale: So why isn't foldl' being used in the std libs?
12:16:43 <cnwdup> Or is lambdabot not showing the actual implementation?
12:17:03 <sw17ch> > foldr (:) 0 [1..10]
12:17:04 <lambdabot>       No instance for (Num [a])
12:17:04 <lambdabot>        arising from the literal `0' at <inter...
12:17:10 <RayNbow> cnwdup: the latter
12:17:12 <Cale> Because those functions are polymorphic enough that in some cases you don't want the extra strictness. That's not a great excuse though. Both versions should be available.
12:17:12 <sw17ch> > foldr (:) 0 [1..10] :: Expr
12:17:13 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[a]'
12:17:17 <sw17ch> > foldl (:) 0 [1..10] :: Expr
12:17:18 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
12:17:18 <lambdabot>        Expect...
12:17:35 <sw17ch> > foldl (:) [] [1..10]
12:17:36 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
12:17:36 <lambdabot>        Expect...
12:17:38 <cnwdup> Okay.
12:17:42 <sw17ch> > foldr (:) [] [1..10]
12:17:43 <Cale> Oh, also, lambdabot's @src does not necessarily show the actual implementation, yeah.
12:17:44 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
12:17:47 <sw17ch> there we go
12:18:06 <Cale> > foldl (flip (:)) [] [1..10]
12:18:07 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
12:18:20 <PeakerWork> > foldr (flip (:)) [] [1..10]
12:18:21 <lambdabot>       Occurs check: cannot construct the infinite type: b = [b]
12:18:21 <lambdabot>        Expect...
12:18:27 <sw17ch> > foldl (flip (:)) [] [1..10] :: [Expr]
12:18:28 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
12:18:36 <sw17ch> well, that's hardly what i had in mind :P
12:21:12 <nikki93> @src flip
12:21:12 <lambdabot> flip f x y = f y x
12:21:46 <nikki93> @src reverse
12:21:46 <lambdabot> reverse = foldl (flip (:)) []
12:21:57 <nikki93> Aha!
12:22:13 <Cale> Near the end of highschool, my favourite function was the Gamma function (the generalisation of the factorial to complex values). I used it to define a generalisation of the iterated derivative for polynomials, so that you could take essentially any complex power of the derivative/integral.
12:22:17 <ray> @pl flip
12:22:17 <lambdabot> flip
12:22:43 <ray> @pl f g x y = g y x
12:22:44 <lambdabot> f = flip
12:22:47 <mauke> @. pl src flip
12:22:47 <lambdabot> (line 1, column 1):
12:22:47 <lambdabot> unexpected end of input
12:22:47 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
12:22:53 <ray> that's not what i mean lambdabot
12:23:14 <Cale> ray: what do you mean?
12:24:59 <ray> something starting with \f
12:25:06 <Cale> @unpl flip
12:25:06 <lambdabot> (\ a b c -> a c b)
12:25:18 <jberg> is there some cool article/tutorial on what you can do with type classes? i remember monad reader solved a logic problem using only haskell types
12:25:19 <Cale> ray: @pl's job is to remove lambdas
12:25:33 <ray> ah, i see
12:25:50 <ray> i figured it was more to remove patterns
12:25:55 <ski_> @pl flip f x y = f y x
12:25:55 <lambdabot> flip = flip
12:26:00 <Olathe> pl is pointless, though.
12:27:19 <idnar> heh.
12:31:03 <sw17ch> Cale: you were way more hard core in highschool than i was
12:34:53 <ksf> quick, quick, how do i set a make variable to the output of a shell program?
12:35:09 <ksf> OR I'LL BE TEMPTED TO HARDCODE IT
12:35:21 <trofi_> $$VAR
12:35:22 <lunabot>  luna: Not in scope: data constructor `VAR'
12:35:28 <sw17ch> woa
12:35:35 <sw17ch> $ 1
12:35:36 <lunabot>  1
12:35:42 <Trollinator> the dark side of the force is strong within you
12:35:46 <trofi_> , $( [ 1 ] )
12:35:48 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Lib.ExpQ'
12:35:58 <trofi_> , $( [| 1 |] )
12:36:00 <lunabot>  1
12:36:56 <Trollinator> ksf: FOOBAR := $$(command)
12:37:53 <Trollinator> > 1
12:37:54 <lambdabot>   1
12:38:18 <mauke> $(shell command)
12:38:19 <lunabot>  luna: Not in scope: `shell'
12:38:34 <trofi_> $ [1]
12:38:36 <lunabot>  [1]
12:39:44 <ztirF> if I have a function whose signature is f :: (Ix a) => x -> a, why can't I return either Int, (Int, Int), (Int, Int, Int)
12:39:45 <Trollinator> > map ((flip map) [1,2,3]) (map (*) [1,2])
12:39:48 <lambdabot>   [[1,2,3],[2,4,6]]
12:39:59 <mauke> ztirF: because those are not general enough
12:40:04 <zMarcWeber> ksf: foo=$(shell echo value)
12:40:23 <mauke> ztirF: the caller gets to choose the type, not you
12:41:11 <ztirF> mauke: sigh.  so the only way to do it is make data Bin = B1 Int | B2 (Int,Int) | ... right?
12:41:42 <Trollinator> > map ((flip map) [1,2,3]) (map (+) [1,2])
12:41:43 <lambdabot>   [[2,3,4],[3,4,5]]
12:41:59 <ztirF> writing a multidimensional histogram function is turning out to be a huge PITA
12:42:00 <Trollinator> haskell is sweet :)
12:42:05 <trofi_> yep
12:42:17 <trofi_> (^2) `fmap` [3,2,1]
12:42:21 <trofi_> > (^2) `fmap` [3,2,1]
12:42:23 <lambdabot>   [9,4,1]
12:43:04 <ztirF> I bet this is what scrap your boilerplate is for
12:43:17 <ztirF> too bad it's big and scary
12:44:02 <Trollinator> what is fmap?
12:44:16 <Trollinator> > map (^2) [3,2,1]
12:44:21 <lambdabot>   [9,4,1]
12:44:23 <Trollinator> > fmap (^2) [3,2,1]
12:44:24 <lambdabot>   [9,4,1]
12:44:27 <PeakerWork> Trollinator: lets you modify the contents that are "inside" types
12:44:35 <PeakerWork> Trollinator: without affecting the container itself
12:44:44 <ziman> Trollinator, fmap is more general, applicable to all functors, while map is specific for the [] functor
12:45:08 <trofi_> :t fmap
12:45:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:45:10 <trofi_> :t map
12:45:11 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
12:45:11 <Trollinator> so why should one use map at all?
12:45:25 <trofi_> map is lispy
12:45:49 <ziman> sometimes you want to indicate explicitly you're working with lists
12:45:52 <mauke> lisp map is forM_
12:45:59 <PeakerWork> Trollinator: no good reason, IMO
12:46:05 <Trollinator> OK.
12:46:10 <PeakerWork> Trollinator: I think older Haskell didn't have map, just fmap
12:46:27 <trofi_> flip map,fmap ?
12:46:29 <PeakerWork> Trollinator: we now have map and fmap for newbie-friendliness, I think, though I disagree with it
12:47:22 <Trollinator> so fmap works with arrays too?
12:47:26 <PeakerWork> Trollinator: should
12:47:38 <Trollinator> nice.
12:47:38 <mak__> functional language without map? can't be ;]
12:47:39 <PeakerWork> @type array
12:47:43 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
12:47:58 <PeakerWork> > array (0, 10) (zip [0..] [1..10])
12:47:59 <lambdabot>   array (0,10) [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),...
12:48:04 <PeakerWork> > fmap (*2) $ array (0, 10) (zip [0..] [1..10])
12:48:05 <lambdabot>   array (0,10) [(0,2),(1,4),(2,6),(3,8),(4,10),(5,12),(6,14),(7,16),(8,18),(9...
12:48:09 <mauke> :t listArray
12:48:11 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
12:48:23 <trofi_> :t fromList
12:48:24 <lambdabot> Not in scope: `fromList'
12:48:58 <asgaroth> I'm currently reading the ghc manual about existential quantification and this is given as an explanation for the `existential': " MkFoo :: (exists a . (a, a -> Bool)) -> Foo
12:49:21 <joma> PeakerWork: how do you mean inside tyes?
12:49:21 <asgaroth> How exactly am I to interpret this? For every a, there is a pair of a an a and a function a -> Bool?
12:49:23 <joma> *Matrix> fmap (\x -> x*x) [Haha 5, Haha 12]
12:49:28 <joma> data Haha m = Haha m deriving(Eq,Ord,Show)
12:49:38 <joma> PeakerWork == Peaker at work?
12:49:38 <PeakerWork> joma: you can try to derive Functor, if that doesn't work, then define it
12:49:44 <PeakerWork> joma: yes
12:50:01 <joma> how do I derive a functor?
12:50:14 <asgaroth> joma: either use deriving or define an fmap
12:50:17 <joma> very woot because then i actually use a Functor for once
12:50:19 <asgaroth> the former doesn't always work
12:50:20 <mauke> asgaroth: no, there exists a type 'a' inside MkFoo, but you don't know what it is
12:50:33 <asgaroth> mauke: ah, ok, thanks
12:50:52 <mauke> asgaroth: basically, the only thing you can do with that is case v of MkFoo (x, f) -> f x
12:50:53 <joma> deriving(Eq,Ord,Show,Functor) ?
12:50:56 <Saizan> btw, it's MkFoo :: exists a. ((a, a -> Bool) -> Foo)
12:51:14 <vixey> does forall mean exists in haskell?
12:51:14 <asgaroth> Hmm, then there's a bug in the ghc manual
12:51:16 <Saizan> no?
12:51:20 <asgaroth> vixey: no
12:51:28 <vixey> what is exists?
12:51:32 <mak__> asgaroth: be
12:51:35 <mak__> can be*
12:51:40 <Saizan> vixey: exists is fictional syntax
12:51:47 <vixey> yes
12:51:53 <joma> how should I define an fmap for this specifically?
12:51:59 <vixey> does it have a clear meaning though?
12:52:05 <vixey> I've never understood what is meant by it
12:52:14 <trofi_> fmap (Haha x) = Haha (f x)
12:52:28 <mak__> it meens forall a but under 'arrow' afair
12:52:38 <Saizan> vixey: exists a. a  == forall b. (forall a. a -> b) -> b
12:52:49 <mak__> witch meen exists
12:53:15 <vixey> exists a. F(a) = forall b. (forall a. F(a) -> b) -> b  ?
12:53:46 <Saizan> depends on what you mean by F
12:54:00 <vixey> any function * -> *
12:54:22 <Saizan> then yes
12:55:19 <kau> hello
12:56:11 <dmead> hi
12:57:04 <vixey> why does exists mean this?
12:57:17 <PeakerWork> vixey: exists a. means that "a" must have the ability to be any type, so the code must not assume anything about the type.   forall a. means that "a" gets to be whatever the code wants it to be
12:57:22 <vixey> it's basically a CPS conversion?
12:57:45 <Cale> exists a. F(a) = not (forall a. not F(a))
12:58:00 <Cale> That might be more intuitive.
12:58:20 <vixey> in ocaml they tried to explain to me exists also.. but I don't know I think I can't undurstand it
12:58:24 <Cale> (though perhaps less intuitionistic ;)
12:58:34 <mak__> its normal logic law isn't it? ;]
12:58:48 <Gracenotes> mak__: for logic, not types :P
12:59:01 <Gracenotes> (just cause it's isomorphic doesn't mean it's easy)
12:59:05 <mak__> Gracenotes: but its quite isomorphic ;]
12:59:22 <kau>  > map (+1) [1..10]
12:59:57 <kau> sorry, someone told me about lambdabot so i came here
13:00:23 <vixey> kau, do it again with one less space :p
13:00:33 <kau>  >map (+1) [1..10]
13:00:36 <PeakerWork> hehe
13:00:38 <kau> >map (+1) [1..10]
13:00:39 <SKuhn> hi, if you look at  the where clause in this code (http://de.pastebin.ca/1313903)  ... is it compiler optimization that it's not executed in the otherwise guard or haskell spec?
13:00:42 <joma> i do agree . look better than $ ! . looks very elegant
13:00:46 <PeakerWork> kau: "> " at your beginning of line
13:00:47 <asgaroth> > map (+1) [1..10]
13:00:49 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
13:00:53 <kau> > map (+1) [1..10]
13:00:54 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
13:00:56 <kau> super
13:01:09 <asgaroth> kau: You can also /msg lambdabot if you don't want to post some query to the channel
13:01:18 <kau> yes of course
13:01:29 <kau> thanks
13:01:29 <Gracenotes> heaven knows I've had many intimate private conversations with lambdabot
13:01:59 <Gracenotes> it never initiates the conversation though :/
13:02:20 <asgaroth> Gracenotes: Sometimes it does, but it only tells you that you have messages though :)
13:02:22 <kau> not a good point for him:)
13:02:58 <Gracenotes> well, yes, but you do have to speak for that to happen
13:03:05 <h0tzenpl0tz> SKuhn: no, it does not get executed.
13:03:29 <Gracenotes> @botsnack
13:03:29 <lunabot>  :)
13:03:29 <lambdabot> :)
13:03:35 <PeakerWork> :)
13:04:21 <h0tzenpl0tz> foo
13:04:21 <h0tzenpl0tz>   | True  = one + two
13:04:21 <h0tzenpl0tz>   | False = 0
13:04:21 <h0tzenpl0tz>   where (one,two) = bar
13:04:21 <h0tzenpl0tz> will bar get executed in the False-guard?
13:04:40 <vixey> h0tzenpl0tz, no
13:04:46 <h0tzenpl0tz> why?
13:04:49 <vixey> at least I think it shouldn't.
13:04:54 <asgaroth> h0tzenpl0tz: because you don't mention it there
13:04:57 <vixey> maybe it can be tested
13:05:08 <SKuhn> vixey: it won't
13:05:11 <asgaroth> if you want it to be executed for some reason you can use: bar `seq` 0
13:05:11 <h0tzenpl0tz> is it compiler-optimization or haskell/language-feature/lazy-stuff
13:05:12 <mak__> h0tzenpl0tz: becouse you didn't it ;]
13:05:14 <vixey> > let foo True = one + two ; foo False = 0 where (one,two) = (1,2) in foo True
13:05:15 <lambdabot>   Not in scope: `one'Not in scope: `two'
13:05:24 <vixey> > let foo True = one + two ; foo False = 0 in foo False where (one,two) = (1,2)
13:05:26 <lambdabot>   0
13:05:30 <vixey> > let foo True = one + two ; foo False = 0 in foo True where (one,two) = (1,2)
13:05:31 <idnar> h0tzenpl0tz: it's basically a result of laziness
13:05:31 <lambdabot>   3
13:05:32 <vixey> > let foo True = one + two ; foo False = 0 in foo True where (one,two) = undefined
13:05:33 <lambdabot>   * Exception: Prelude.undefined
13:05:35 <vixey> > let foo True = one + two ; foo False = 0 in foo False where (one,two) = undefined
13:05:36 <lambdabot>   0
13:05:38 <h0tzenpl0tz> thank you
13:05:41 <vixey> my test seems to show it doesn't
13:05:52 <vixey> I wonder if there is any way to be certian though
13:05:53 <asgaroth> > let foo False x = 0; foo True x = 2*x in foo False undefined
13:05:55 <lambdabot>   0
13:06:00 <SKuhn> vixey: mak__ : the question was if it's by (compiler-) optimization or on purpose?
13:06:09 <idnar> vixey: use your own undefined?
13:06:12 <trofi_> haskell standards: guards are desugarified into nested IFs, no?
13:06:13 <nikki93> WTH? I compiled a fibs listing with ghc, and it listed fib n uptill 1024 almost instantaneously?
13:06:16 <nikki93> How's it so fast?
13:06:29 <andun> i have a question about data types/organization for an application for evolutionary algorithms at uni (homework-related). the thing is, they want us to make a distinction between genotypes and phenotypes, and i don't really know how to represent it in haskell. i'm thinking about something like http://codepad.org/EpTLBKwy, but i could really need some opinions. any ideas?
13:06:38 <idnar> > product [1..1024]
13:06:39 <lambdabot>   541852879605885728307692194468385473800155396353801344448287027068321061207...
13:06:43 <idnar> > length . show $ product [1..1024]
13:06:45 <lambdabot>   2640
13:06:51 <idnar> that's not a very big number ;)
13:06:54 <joma> how can a functor make that more elegant?
13:06:56 <joma> a f xs = (map Haha . map f . map fromHaha) xs
13:06:56 <idnar> oh wait
13:06:59 <idnar> fibs, not factorial
13:07:03 <ztirF> mauke: so in general, if I have some X -> a, I have to return a specific type a and not just a member of a typeclass?
13:07:04 <idnar> don't mind me
13:07:22 <nikki93> idnar: Not that, its LIST of fibs! :o
13:07:23 <asgaroth> joma: map f `fmap` xs
13:07:25 <PeakerWork> joma: map f . map g = map (f . g)
13:07:29 <nikki93> idnar: EVERY fib until 1024!!
13:07:29 <Trollinator> i guess product == foldl1 (*)?
13:07:31 <joma> a f xs = (map Haha . map f . map fromHaha) xs  //// <- will that be evaled lazily so it only iterates 1 time rather than 3?
13:07:40 <PeakerWork> joma: a f xs = map (Haha . f . fromHaha) xs
13:07:42 <Trollinator> or rather foldl 1 (*)
13:07:55 <PeakerWork> joma: you can reduce that: a f = map (Haha . f . fromHaha)
13:08:04 <chessguy_work> is there no RSS for http://www.reddit.com/r/haskell ?
13:08:10 <PeakerWork> joma: if its specific to lists, doesn't matter much if you use map or fmap
13:08:13 <idnar> nikki93: in order to calculate fib 1024, you need to calculate the rest of them anyway
13:08:17 <PeakerWork> joma: its not more "elegant" either way
13:08:29 <trofi_> nikki93: how inefficient your implementation is?
13:08:39 <idnar> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in last . take 1024 $ fibs
13:08:40 <lambdabot>   450669963367781981310438323572888604936786059621860483080302314960003064570...
13:08:41 <asgaroth> PeakerWork: Shouldn't one be able to skip the Haha and fromHaha by using fmap though?
13:08:50 <asgaroth> map (fmap f) xs
13:08:51 <idnar> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in length . show . last . take 1024 $ fibs
13:08:52 <lambdabot>   214
13:09:02 <PeakerWork> asgaroth: oh, I didn't assume anything about "Haha" there :)
13:09:07 <idnar> 214 digits is also not a very big number
13:09:13 <chessguy_work> "There is very little you can do in Haskell without understanding monads..." ... hmm, doesn't seem very fair
13:09:22 <PeakerWork> joma: oops, asgaroth is right, you can do:  a = map . fmap
13:09:33 <andun> chessguy_work: isn't it somewhat true?
13:09:37 <idnar> chessguy_work: yeah, you can do quite a bit with just the IO monad, which you can use without understanding Monads
13:09:46 <vixey> give it a positive spin,  Once you understand monads the world is your oyster
13:09:48 <asgaroth> andun: Well, you just need to know how to use them, not understand them
13:09:50 <idnar> er, ...understanding monads in general
13:09:55 <PeakerWork> @where semantic editor combinators
13:09:55 <lambdabot> I know nothing about semantic.
13:09:59 <sw17ch> besides, the hardest part about Monads is learning that they aren't scary
13:10:00 <chessguy_work> idnar, i'd say there's a lot you can do using monads without understanding them, in general
13:10:02 <PeakerWork> @go semantic editor combinators
13:10:05 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
13:10:05 <lambdabot> Title: Conal Elliott  Semantic editor combinators
13:10:07 <luite_> andun: maybe the genotype should expose more of the internal structure, perhapse something about the type of solution (for example binary representation, permutation, genetic program)? don't know how I'd represent it or how useful it is to make a distinction.
13:10:09 <PeakerWork> joma: its really a special case of a semantic editor combinator, see that
13:10:13 <sw17ch> other than that, the learning experience ends with "oh... that's it?"
13:10:22 <nikki93> trofi_: I was just doing it as a 'how fast is my computer- check'. :)
13:10:35 <trofi_> heh :]
13:11:11 <ztirF> does anyone know if I have some X -> a, do I have to return a specific type a and not just a member of a typeclass?
13:11:17 <nikki93> Its certainly faster than running from ghci though.
13:11:26 <andun> luite_: the system is supposed to handle "any" representation etc. i really want a general typeclass
13:11:58 <luite_> andun: I personally don't really like all those biological names, they distract from the fact that it's just a local search (meta)heuristic, and that it often helps to combine it with regular local search methods
13:12:02 <andun> luite_: the problem is still how to relate the genotype and the phenotype
13:12:52 <asgaroth> ztirF: functions can be polymorphic on the return value, if that's what you mean
13:12:55 <asgaroth> @type fromInteger
13:12:56 <lambdabot> forall a. (Num a) => Integer -> a
13:13:16 <joma> how does this make sense: instance Functor RV where
13:13:16 <joma>     fmap = liftM
13:13:17 <joma> ?
13:13:25 <andun> asgaroth: yeah. but one genotype maps to only one phenotype, not all
13:13:44 <vixey> joma, fmap and liftM coincide in that context
13:14:06 <joma> a = map . fmap doesnt work
13:14:06 <asgaroth> joma: fmap and liftM should be the same for any decent monad instance afaik
13:14:22 <joma> Ambiguous type variable `f' in the constraint:
13:14:22 <joma>       `Functor f' arising from a use of `fmap' at
13:14:30 <luite_> andun: I don't think Double is general enough for fitness, Ord seems more appropriate. there are many problems that don't have an absolute measure of fitness, but the quality of different solutions can be compared
13:14:31 <ztirF> asgaroth: here's my problem: I have a type X = X1 Array | X2 Array Array ... and I want to write a function whichBin :: (Ix a) => X -> a
13:14:47 <idnar> @type map . fmap
13:14:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> [f a] -> [f b]
13:15:01 <ztirF> where whichBin gives me an Int for X1, an (Int,Int) for X2, etc
13:15:35 <andun> luite_: maybe not, but that's not what's troubling me.
13:15:40 <ztirF> but the compiler doesn't seem to want me to do that
13:15:52 * ksf stumbles over ghc's -I, again.
13:16:05 <andun> maybe i just need to make explictic conversion between genotypes and phenotypes whenever i need the latter.
13:16:16 <andun> explicit*
13:16:45 <mak__> ztirF: hmm have you try phantom class? maybe it should help
13:16:51 <luite_> andun: hm, I don't really understand what the difference should be
13:16:58 <ztirF> mak__: ahh, what's that?
13:17:16 <mak__> a class without 'methods'
13:17:36 <mak__> you define Class Foo and members
13:18:01 <mak__> then make type (Ix a,Foo a) => X -> a
13:18:19 <andun> luite_: me neither, sorta. so far a single "Individual" class works well, but the assignment clearly states there should be a distinction between them. maybe i'll just ask the professor
13:18:44 <andun> (it's not a haskell class, but we can choose language)
13:19:09 <luite_> andun: I'd say that fitness may belong to the Phenotype, but in haskell, being a lazy language, you could just as well add it to a more general Solution class and only actually calculate it when it's needed
13:19:13 <ztirF> mak__: I see - let me try it
13:19:22 <kau> i am trying to write a peg solitaire solver in haskell as a beginner's exercice
13:19:26 <kau> i am definning newtypes for the board, moves etc
13:19:30 <kau> like this:
13:19:34 <kau> data Emplacement = B | T | I	deriving Eq
13:19:38 <kau> data Plateau = Plateau { deconsPlat :: [[Emplacement]]}
13:19:43 <kau> but i am puzzled because i cannot use those handy function definned in prelude without deconstructing/recontructing all the time...
13:19:47 <kau> in the other hand using type synonyms will drive me into instances problems!
13:19:49 <vixey> kau, sounds fun.. I am always wanting to memorize the solution for this game but not managed yet :p
13:19:58 <andun> luite_: yeah. thanks for the input :)
13:19:58 <kau> sorry for the flood!
13:20:06 <mak__> ztirF: have fun, I naver can get over its ;p
13:20:14 <vixey> kau, do you know 'type' ? as opposed to 'data'?
13:20:18 <luite_> andun: is it a course about haskell or about evolutionary algorithms? :)
13:20:19 <mak__> s/can/can't/
13:20:40 <asgaroth> vixey: that are type synonyms which seem not to work in his case
13:20:41 <jberg> is there some cool article/tutorial on what you can do with type classes? i remember a monad reader issue where they solved a logic problem using only haskell types
13:20:44 <kau> as far as i know, newtype = data and type is only a synonym
13:20:47 <andun> luite_: EA.
13:21:12 <andun> luite_: not about haskell at all. but we can use any language
13:21:41 <mak__> jberg: almost  everything ;]
13:21:44 <vixey> kau, not 'newtype' but 'type'
13:21:44 <kau> i tried "type" but i weren't able to do knew instances for the == anymore
13:21:49 <vixey> kau, ahh.........
13:22:04 <vixey> maybe you can just not use (==) name it something else?
13:22:08 <jberg> mak__, yeah.. but how to use them to do cool things, like solve a logic puzzle :)
13:22:15 <kau> yeah
13:22:28 <kau> but i was less cool ;)
13:22:41 <luite_> andun: ah ok. I have done some EA in haskell as well, but hardly use any type classes like this (only a very small Solution type class with a fitness function)
13:22:53 <mak__> jberg: lookup for simple exemples ;]
13:23:03 <mak__> I can tell you how count on types ;]
13:23:24 <jberg> mak__, im trying to find that monad reader issue, but noone seems to remember it :X
13:23:26 <kau> i want to redefine == because two simetrical boards are egal in this game
13:23:48 <andun> luite_: oh, right. i'll post the code whenever i get something interesting =)
13:23:51 <vixey> kau, why not call it  equalBoards  instead of (==)?
13:24:10 <kau> why not :)
13:24:32 <PeakerWork> vixey: because then there are lots of existing Eq a => ...     functions that he can use on his boards?
13:24:34 <mak__> couse it's less cool? ;p
13:24:42 <kau> yes
13:24:56 <kau> yes indead
13:25:03 <kau> PeakerWork
13:25:19 <PeakerWork> who's dead?
13:25:26 <mpeter> obama
13:25:34 <koeien> i'm on x86_64. can i create an x86 (32 bit) binary with ghc? if so, how?
13:25:34 <kau> reducing board egalities with nub etc.
13:26:13 <luite_> andun: my code makes quite a lot of use of monads, using a monad transformer stack for local state for genetic operators, the termination criterion and the random number generator. that was actually most of the work (apart from implementing the actual genetic operators and local search for specific problems)
13:26:24 <mpeter> i was kicking the same question around in my head last night, koeien, as to how you design compilers
13:26:46 <mpeter> if the language abstracts away those differences, then the compiler should be able to produce both
13:27:06 <Toxaris> kau: it may be easier to use equalBoards together with nubBy etc.
13:27:12 <mpeter> at the same time, your development environment should be the same processor you're working for
13:27:17 <mpeter> so in short, i have no answer for you
13:27:52 <koeien> :)
13:27:55 <Toxaris> kau: it may be that symmetrical boards are equivalent for some purposes, but are they really *equal*, is it impossible to distinguish them?
13:28:05 <mpeter> let's see what google says
13:28:38 <kau> Toxaris: yes, perhaps later i'll get in trouble...
13:28:53 <andun> luite_: i use MonadRandom, don't have any local state (yet). maybe i'll need it. i don't really know much about EAs yet
13:29:08 <luite_> andun: but I just pass my recombination operator (for example) as a function argument to the EA 'main loop' function. It doesn't make much sense to me to implement the operator as a typeclass function, as you probably want to be able to experiment with different operators for the same type of problem
13:29:15 <koeien> mpeter: couldn't find it.
13:29:25 <ksf> yes! I'm finally past the error messages and have advanced to a segfault.
13:29:37 <mpeter> ksf: progress!
13:29:46 <andun> luite_: yeah. right, hmm.
13:30:14 <luite_> andun: I did use MonadRandom, but switched to my own random monad, because MonadRandom and StdGen are rather slow
13:30:30 <kau> one other question is to generate all possible boards from one move and one board.
13:30:35 <kau> This seams to be similar to the classical searching/replace for sub string in a string.
13:30:40 <CyberGarp> Is it possible to define a user type that is a function?
13:30:41 <kau> But i was not able to find that around in libraries...
13:30:44 <andun> luite_: are they? what are the fast ones?
13:30:49 <PeakerWork> CyberGarp: sure
13:31:03 <PeakerWork> CyberGarp: type Blah a = a -> Int
13:31:03 <CyberGarp> Okay, then it must be my syntax
13:31:05 <ksf> ...and it's not even in the ghc runtime!
13:31:09 <mpeter> cabal is awesome!
13:31:20 <luite_> andun: there are faster mersenne twister based random generators on hackage, I use the pure64 one
13:31:27 <CyberGarp> PeakerWork: I was doing this: 'newtype WalkFunction = Cell -> IO Cell'
13:31:32 <mpeter> look at all this stuff :)
13:31:37 <PeakerWork> CyberGarp: oh, newtype/data are not functions, if that's what you meant
13:31:51 <CyberGarp> ahhh
13:31:52 <PeakerWork> CyberGarp: you can't apply them, but you can have an: apply :: YourType -> TheFunctionYouWant
13:32:06 <PeakerWork> CyberGarp: so you can use yourValue `apply` theargs
13:32:07 <luite_> andun: they are less flexible than StdGen (for example not splittable), but quite a bit faster
13:32:09 <CyberGarp> type will work
13:32:14 <PeakerWork> CyberGarp: or (apply yourValue) are your function
13:32:30 <mpeter> what does unix-compat do, exactly?
13:32:38 <kau> nobody have an idea
13:32:40 <CyberGarp> PeakerWork, that worked.
13:32:41 <kau> ?
13:32:43 <luite_> andun: still way slower than using the simd mt generator directly in native code though :(
13:33:16 <andun> noted.
13:33:22 <Stephan202> @pl x >>= \a -> return (b, a)
13:33:22 <lambdabot> (,) b `fmap` x
13:33:52 <nothingmuch> @pl f x = g . h x
13:33:52 <lambdabot> f = (g .) . h
13:34:10 <nothingmuch> parens--
13:34:19 <PeakerWork> @type result
13:34:20 <lambdabot> Not in scope: `result'
13:34:28 <PeakerWork> @let result = (.) ; argument = flip (.)
13:34:29 <lambdabot>  Defined.
13:34:35 <PeakerWork> f = result g . h
13:36:55 <luite_> andun: let me know when you have some code (if you want to share). I can show you my code when it's done, although it's rather messy, because it's my first haskell program that I really wanted to optimize for speed
13:37:19 <ztirF> arggg why is this not valid: class Bin i where B1 :: Int -> i
13:37:46 <koeien> ztirF: try "b1"
13:37:52 <ztirF> oh
13:37:55 <mak__> whats B1 ?
13:37:56 <ztirF> I feel dumb
13:38:22 <drdozer> http://pastebin.com/m496b93ed
13:38:48 <drdozer> I have a feeling that these ideas for modelling probabilities will require some use of GADTs?
13:39:06 <andun> luite_: i will. thanks :)
13:39:42 <drdozer> (that paste doesn't compile by the way - it's a sort of sketch of what I'm aiming toward)
13:39:43 <chessguy_work> drdozer, some thought has been put into probability distributions, have you seen ekidd's blogs about them?
13:39:59 <drdozer> chessguy_work, no - I will google
13:40:07 <chessguy_work> http://www.randomhacks.net/articles/2007/02/21/refactoring-probability-distributions
13:40:42 <chessguy_work> (note, i haven't read your code to see how/if the ideas relate yet)
13:41:06 <drdozer> chessguy_work, what I've learned is that you need a sepparation between the event language and the probability expressions
13:42:14 <chessguy_work> lots of interesting links on that page, and the sequels are good too
13:42:38 <drdozer> chessguy_work, I've already written a fairly useable API for probability distributions themselves
13:43:03 <drdozer> with parameter estimation and things
13:43:33 <chessguy_work> cool. i don't think his required any type hackery/extensions
13:47:14 <drdozer> chessguy_work, that blog was fun, but it wouldn't work well for me - my distributions are typically over spaces that are arbitrarily large, and certainly not enumerable
13:47:35 <nikki93> What's the best option for gui coding with haskell
13:47:36 <nikki93> ?
13:48:14 <drdozer> chessguy_work, e.g. distributions over all paths in graphs with probabilities on their edges
13:48:37 <chessguy_work> that's not enumerable?
13:48:58 <drdozer> chessguy_work, it is but enumerating it so you can sample from it will take a *very* long time
13:49:09 <chessguy_work> ah, that's different
13:49:24 <research_applied> is there a parallel app for sorting text in haskell that can run on 100 servers? like java hadoop?
13:49:45 <pumpkin> I doubt it
13:49:49 <chessguy_work> anyway, as i said, i don't know if/how his ideas are related, just thought i'd point it out
13:49:58 <pumpkin> @faq can haskell parallel sort text on 100 servers? like java hadoop?
13:49:59 <lambdabot> The answer is: Yes! Haskell can do that.
13:50:01 <pumpkin> aha
13:50:04 <drdozer> chessguy_work, thanks - it is interesting
13:50:10 * chessguy_work rolls his eyes at pumpkin 
13:50:18 <research_applied> http://hadoop.apache.org/
13:50:19 <research_applied> ok
13:50:29 <research_applied> how easily though?
13:50:49 <research_applied> I am pretty sure haskell is a smarter language
13:51:03 <pumpkin> probably not too easily for now, until someone comes up with an easy-to-use distributed computing framework
13:51:14 <pumpkin> although you could use that "haskell as erlang node" code that appeared recently on hackage
13:51:22 <Gracenotes> Haskell's concurrency is somewhat... primitive at the moment, as far as I can tell
13:51:37 <pumpkin> Gracenotes: on shared-memory machines, it's awesome
13:51:42 <pumpkin> big distributed networks however :P
13:51:48 <kiris> \C-xb*haskell*\C-m\C-r> :load\C-m\C-[xsearch-fo\C-i-r\C-i\C-m[^:]*:[0-9]*:[0-9]*:\C-m\C-a\C-@\C-s:\C-b\C-[w\C-x\C-f\C-x\C-f\C-y\C-m\C-xb*haskell*\C-m\C-r> :load\C-m\C-[xsear\C-ifo\C-i-r\C-i\C-m[^:]*:[0-9]*:[0-9]*:\C-m\C-a\C-s:\C-m\C-@\C-s:\C-m\C-b\C-[w\C-xb\C-m\C-[g\C-y\C-m\C-l\C-a
13:51:58 <kiris> take you to the line in the file of the last GHCi error!
13:52:16 <Gracenotes> \C?
13:52:25 <kiris> it's a keyboard macro
13:52:33 <kiris> for emacs
13:52:38 <Gracenotes> oh, I see
13:52:38 <pumpkin> ugh :)
13:52:43 <Gracenotes> .-.
13:52:48 <kiris> _
13:52:53 <Gracenotes> -.-
13:52:55 <kiris> ._.
13:53:12 <research_applied> hm
13:53:23 <research_applied> is haskell every bit as nice as perl for text sorting?
13:53:23 <h0tzenpl0tz> > inits [1,2,3]
13:53:25 <lambdabot>   [[],[1],[1,2],[1,2,3]]
13:53:30 <h0tzenpl0tz> aaaaaaaaaaaaaaaaaaah
13:53:36 <kiris> with a regex library, yah
13:54:55 <Gracenotes> @faq Can Haskell [[0.0]]?
13:54:56 <lambdabot> The answer is: Yes! Haskell can do that.
13:55:06 <Gracenotes> proof:
13:55:08 <research_applied> heh
13:55:09 <Gracenotes> > let o_o = 0.0 ;o' =(, ); ;o (*)=(*) ;( lol, xD :p )= o' o' $o.o$ (:[]) $o.o$ (:[]) o_o in (:[]) o_o :p
13:55:10 <lambdabot>   [[0.0]]
13:55:17 <Gracenotes> QED...
13:55:21 <vixey> lol Grace
13:55:22 <research_applied> anyone got a running happs site?
13:55:28 <vixey> this is wonderful
13:55:34 <vixey> @remember <Gracenotes> > let o_o = 0.0 ;o' =(, ); ;o (*)=(*) ;( lol, xD :p )= o' o' $o.o$ (:[]) $o.o$ (:[]) o_o in (:[]) o_o :p
13:55:35 <lambdabot> Done.
13:55:50 <waterman_> in answer to my own previous questions about monadic interpretters:  http://www.ittc.ku.edu/Projects/SLDG/projects/project-InterpreterLib.htm
13:55:52 <Gracenotes> Haskell is very expressive
13:56:02 <kiris> vixey: hahaha oh god
13:56:04 <vixey> waterman, what was the question
13:56:08 <waterman_> and http://people.eecs.ku.edu/~palexand/teaching/eecs368/page3/files/Duponcheel.pdf
13:56:36 <kiris> Gracenotes: glorious
13:57:18 <Gracenotes> not as obfuscated as it could be, though :)
13:57:18 <waterman_> the question was: does anyone have real examples of layering interpreters using monad transformers ?
13:58:17 <vixey> ah you make a distinction between real and not-real, this is fuzzy ground I don't tread on
13:58:31 <olsner> Gracenotes++ :)
13:58:35 <elly> Gracenotes++ # you are my hero
13:58:39 <elly> (or heroine, as appropriate)
13:58:54 <pumpkin> or heroin
13:59:03 <Gracenotes> thank you, I'll be here all week. Try the veal
13:59:21 <CakeProphet> what's a good example of a non-standard-lib monad I could check the implementation of?
13:59:31 <CakeProphet> for ideas, or whatever.
13:59:44 <elly> there are now a half-dozen CS majors in this computer cluster trying to figure it out :)
13:59:48 <vixey> CakeProphet, some ideas on fplunch look promising
14:00:16 <waterman_> vixey: well, code, anyway - more than one finds in an 8 page paper.
14:00:25 <pumpkin> CakeProphet: you could check out the non-standard-lib Data.Set monad instance ;)
14:00:25 <joma> what is ea?
14:00:30 <olsner> so what do we have in ways of obfuscated haskell code snippets? IOHCC doesn't seem to have been active since 2004 or something...
14:03:31 <dons> ?users
14:03:31 <lambdabot> Maximum users seen in #haskell: 642, currently: 635 (98.9%), active: 28 (4.4%)
14:03:48 <nikki93> As I asked, what's the best option for haskell gui coding?
14:03:53 <nikki93> Gtk? Qt? wxWidgets?
14:03:58 <pumpkin> nikki93: define best :o
14:04:00 <research_applied> html!
14:04:05 <pumpkin> but I know a lot of people use gtk
14:04:06 <research_applied> HTML best GUI
14:04:21 <Trollinator> what does the @ mean in "span p xs@(x:xs') "
14:04:21 <roconnor> GuiTV is awesome!
14:04:49 <Gracenotes> GTK is nice. It has useful little event handlers.
14:04:51 <sm> roconnor: really ?
14:04:52 <roconnor> Trollinator: the xs variable is bound to the entire (x:xs')
14:04:55 <nikki93> pumpkin: Aha! Its ze pumpkin.
14:04:58 <roconnor> sm: yes
14:05:15 <sm> is it practical and snappy ?
14:05:16 <Trollinator> thanks.
14:05:32 <roconnor> sm: I found it very good for making tiny UIs for my own personal little aps
14:05:42 <sm> I'll have to give it a whirl
14:05:49 <roconnor> a step up from the GHCi command line that I often use
14:05:51 <nikki93> > let helloPerson n y = if (n > 0) then "hello" ++ helloPerson (n - 1) y else "oo " ++ y ++ "! :P" in "Hello" ++  (helloPerson 8 "pumpkin")
14:05:52 <lambdabot>   "Hellohellohellohellohellohellohellohellohellooo pumpkin! :P"
14:06:03 <roconnor> sm: the only hard part was getting wxHaskell installed
14:06:05 <CakeProphet> my favorite standard lib monad is actually []
14:06:12 <roconnor> rumour has it that that is easier now
14:06:15 <CakeProphet> *standard lib / Prelude
14:06:16 <nikki93> List is a monad?
14:06:17 <sm> oh, rats
14:06:25 <PeakerWork> nikki93: prefix func application binds strongest so you don't need () around helloPerson, and   if .. then  doesn't need () either
14:06:30 <CakeProphet> nikki93:  yep
14:06:30 <pumpkin> nikki93: most certainly!
14:06:30 <PeakerWork> nikki93: yes
14:06:39 <pumpkin> but Set is the best monad
14:06:40 <roconnor> I still kinda want to put a gtk backend on GuiTV
14:06:41 <asgaroth> > [1,2,3] >>= (+1)
14:06:42 <lambdabot>       No instance for (Num [b])
14:06:43 <lambdabot>        arising from the literal `1' at <inter...
14:06:49 <PeakerWork> pumpkin: Set is a monad with a restriction, isn't it?
14:06:50 <asgaroth> > [1,2,3] >>= return .(+1)
14:06:52 <lambdabot>   [2,3,4]
14:06:58 <pumpkin> PeakerWork: yeah, in RMonad :)
14:07:04 <pumpkin> > fmap (+1) [1,2,3]
14:07:05 <lambdabot>   [2,3,4]
14:07:21 <PeakerWork> pumpkin: RMonad has its own methods?
14:07:26 <PeakerWork> pumpkin: or does it share (>>=) and return?
14:07:36 <pumpkin> PeakerWork: it's a reimplementation of all of Monad, basically
14:07:37 <CakeProphet> I like the do syntax with lists because the variable bound with <- represents more than one value.
14:07:41 <pumpkin> with restrictions allowed
14:07:43 <PeakerWork> pumpkin: bummer
14:07:52 <pumpkin> PeakerWork: why?
14:07:53 <PeakerWork> pumpkin: you can't use the huge set rich world of Monadic functions then?
14:08:01 <pumpkin> I wish they'd put it in the standard lib :P
14:08:14 <PeakerWork> pumpkin: clearly its not nice to have Monad and RMonad, and then X and RX forall X
14:08:19 <pumpkin> PeakerWork: well, it reimplements all the obvious ones, but it is necessarily a different typeclass :/
14:08:49 <pumpkin> PeakerWork: well, RMonad is a strict superset of Monad, so if someone felt like renaming it to Monad and killed the one in the stdlib
14:08:50 <nikki93> PeakerWork: I'm absolutely the last person you'd look forward to for remembering operator precedence.
14:08:52 <pumpkin> it should all work
14:08:55 <PeakerWork> pumpkin: maybe we can have *only* RMonad, and not Monad?
14:08:59 <PeakerWork> pumpkin: and call it Monad?
14:09:01 <nikki93> PeakerWork: Even in my C++ code you'll see parentheses EVERYwhere.
14:09:04 <pumpkin> PeakerWork: I'd love to
14:09:08 <PeakerWork> pumpkin: ah that's what you said :)
14:09:14 <pumpkin> PeakerWork: but I don't make the decisions around here :/
14:09:27 <PeakerWork> nikki93: that's why the prefix-stronger-than-all-infix rule is easy - its one rule and so simple
14:09:36 <pumpkin> http://hackage.haskell.org/packages/archive/rmonad/0.3/doc/html/Control-RMonad.html if you're interested
14:09:44 <PeakerWork> pumpkin: I'll look into it, thanks
14:09:44 <faXx> nikki93: ever considered lisp?
14:09:49 <nikki93> faXx: lol
14:09:59 <nikki93> faXx: My aunt's first programming language was lisp.
14:10:03 <SKuhn> inits2 []     =  [[]]
14:10:03 <SKuhn> inits2 (x:xs) =  [] : map (x:) (inits2 xs)
14:10:03 <SKuhn> for what do I need the leading [] :   ?
14:10:30 <nikki93> faXx: (she's one of 'em good ol' programmers, she learnt C before the 'The C Programming Language' book was published by K&R)
14:10:34 <Heffalump> I don't think it's a strict superset, because I suspect type checking gets a bit more complicated with it - i.e. more type signatures might be needed - and it's not H98
14:10:40 <Heffalump> (re RMonad vs Monad)
14:10:42 <faXx> nikki93: ok :D
14:10:46 <research_applied> I must learn lisp.
14:10:48 <PeakerWork> when is ghc 6.10.2 going to be released?
14:10:50 <research_applied> I heard ti is great.
14:10:51 <pumpkin> Heffalump: yeah :) but it's pure awesomeness
14:10:54 <nikki93> faXx: Heh. Must've been one HELL of a headahce.
14:11:00 <pumpkin> Heffalump: so creating the extra suitable classes is well worth it
14:11:14 <pumpkin> in my arrogant opinion :)
14:11:20 <vixey> research_applied: yeah it is
14:11:20 <lunabot>  luna: lexical error in string/character literal at end of input
14:11:29 <nikki93> Anyone here used/uses FORTH?
14:11:40 <ray> what's so great about TI?
14:11:51 <research_applied> can clisp be ok
14:11:56 <research_applied> for parallel apps
14:11:57 <Heffalump> pumpkin: it needs an mtl-a-like
14:12:00 <SKuhn> inits2 (x:xs) =  [] : map (x: ) (inits2 xs)      -- the leading [] :  is crucial ... why?
14:12:02 <vixey> research_applied: probably more relevant to a lisp channel
14:12:03 <Cale> research_applied: Compared to a lot of stuff, that's true. I found Common Lisp annoying to use after Haskell though.
14:12:10 <mak__> research_applied: try conjure
14:12:12 <pumpkin> Heffalump: what's mtl?
14:12:14 <vixey> research_applied: try #cl-gardeners
14:12:19 <research_applied> well
14:12:20 <Heffalump> SKuhn: because [] is an init of any list
14:12:26 <research_applied> if haskell is sifficient then great
14:12:30 <Cale> research_applied: It lacks a decent type system, and it treats functions as not-quite-first-class.
14:12:35 <research_applied> can haskell get really abstract n stuff?
14:12:36 <PeakerWork> Cale: I find lisp-2 dumb
14:12:38 <ray> haskell spoiled me for common lisp as well
14:12:41 <ksf> agar is a charm.
14:12:42 <vixey> aaaaaaaaa
14:12:42 <ray> not for lisp in general though
14:12:43 <PeakerWork> Cale: (the separate function namespace)
14:12:44 <pumpkin> research_applied: enough abstraction to blow your mind
14:12:45 <vixey> see what you did :p
14:12:56 <Heffalump> pumpkin: Control.Monad.State etc
14:12:58 <Cale> PeakerWork: Yeah, that's what I'm referring to.
14:13:06 <research_applied> and haskell is parallel so great on the coming wave of 64 cpu commodity hardware?
14:13:08 <pumpkin> Heffalump: ah, yeah
14:13:09 <ray> defun
14:13:10 <SKuhn> Heffalump: yes, but why do I need it if it's already inside?
14:13:11 <ksf> it's so plain c89 and high-level I amost want to code C again.
14:13:14 <Cale> research_applied: If you're going to learn a lisp, learn scheme.
14:13:19 <research_applied> really?
14:13:20 <Heffalump> SKuhn: where would you expect it to be?
14:13:29 <research_applied> paul graham says common lisp macroesa re where the power is
14:13:30 <ddarius> pumpkin: If my mind is not blown, do I get my money back?
14:13:31 <research_applied> over scheme
14:13:36 <PeakerWork> Cale: someone wanted to name his variable "list" and couldn't, and so this was born :)
14:13:38 <ray> paul graham says a lot of things
14:13:44 <research_applied> heh
14:13:47 <pumpkin> Heffalump: I'd definitely like to see something like RMonad have more people behind it (that's why I've been advertising it so much recently!) and eventually have something similar make it into the standard lib though :)
14:13:51 <ray> he says microsoft's dead too
14:14:03 <pumpkin> ddarius: I'll give you one dollar if your mind has never been blown!
14:14:05 <Heffalump> I'm not really aware of many users.
14:14:17 <vixey> @w80 sensationalist
14:14:25 <ksf> microsoft was a zombie from its first days.
14:14:28 <lambdabot> *** "sensationalist" wn "WordNet (r) 2.0"
14:14:28 <lambdabot> sensationalist
14:14:28 <lambdabot>      n : someone who uses exaggerated or lurid material in order to
14:14:28 <lambdabot>          gain public attention [syn: {ballyhoo artist}]
14:14:31 <SKuhn> Heffalump: I don't understand why the function is just working with "[] :" instead of without ...  - the result is pretty different
14:14:48 <Heffalump> SKuhn: think about how any specific result would be built up
14:14:52 <nikki93> @w80 trowel
14:14:53 <lambdabot> *** "trowel" wn "WordNet (r) 2.0"
14:14:53 <lambdabot> trowel
14:14:53 <lambdabot>      n : a small hand tool with a handle and flat metal blade; used
14:14:53 <lambdabot>          for scooping or spreading plaster or similar materials
14:14:53 <lambdabot>      v : use a trowel on; for light garden work or plaster work
14:14:55 <lambdabot>      [also: {trowelling}, {trowelled}]
14:15:04 <nikki93> @w80 haskell
14:15:04 <lambdabot> No match for "haskell".
14:15:06 <Cale> I don't know how Paul Graham manages to write so much and say so little, and half of what he manages to say is dubious.
14:15:10 <Axman6> quit abusing the bot
14:15:19 <pumpkin> Cale: who's paul graham?
14:15:26 <ray> http://paulgraham.com/
14:15:34 <Cale> pumpkin: This guy who writes a popular blog.
14:15:35 <nikki93> pumpkin: The hackers, painters, artists, architecture etc. fellow.
14:15:56 <nikki93> @w80 dubious
14:15:57 <lambdabot> *** "dubious" wn "WordNet (r) 2.0"
14:15:57 <lambdabot> dubious
14:15:57 <lambdabot>      adj 1: fraught with uncertainty or doubt; "they were doubtful that
14:15:57 <lambdabot>             the cord would hold"; "it was doubtful whether she
14:15:57 <lambdabot>             would be admitted"; "dubious about agreeing to go"
14:15:59 <lambdabot> [9 @more lines]
14:16:03 <pumpkin> we know what dubious means
14:16:05 <repnop> cale: he got rich...so he has the time! ;)
14:16:12 <nikki93> pumpkin: I don't. >_<
14:16:21 <steven_ashley> nikki93, You can send messages to the bot as a PM
14:16:22 <ray> he got rich so people take him more seriously than they necessarily should
14:16:23 <PeakerWork> Paul Graham wrote viaweb, a web application to build shopping web sites in Lisp, when "everyone else was using C++ on the server side", and sold his company to Yahoo! to become a millionare
14:16:23 <steven_ashley> they still work
14:16:30 <ddarius> Peaker: You can name a variable 'list' it just shadows the function list.
14:16:32 <PeakerWork> then he became famous advocating "I am rich because of Lisp"
14:16:41 <pumpkin> nikki93: but do 631 people really need to see the definition? :)
14:16:52 <PeakerWork> ddarius: yeah, but then you can't call the original list heh
14:17:10 <ddarius> Cale: Just ignore Paul Graham.  That's what I do.
14:17:27 <vincenz> nikki93: lambdabot can also be talked to in private via /msg
14:17:28 <Cale> ddarius: I do, but he comes up from time to time :)
14:17:30 <ray> haskell did not spoil me for scheme. it actually made me appreciate it more
14:18:02 <Cale> Scheme is okay, much nicer than CL, but I really have trouble programming without a type system.
14:18:06 <ddarius> Cale: When that happens, simply advise people to ignore him (which, admittedly, is pretty close to what you did.)
14:18:21 <leimy> > fmap (\(x,y) -> fmap (\(a,b) -> (x,a,b)) y) $ Just (2, Just (1,2))
14:18:22 <ksf> learning to know haskell made me stop craving scheme.
14:18:23 <lambdabot>   Just (Just (2,1,2))
14:18:26 <vixey> I feel sorry for Paul Graham...
14:18:34 <steven_ashley> Is anyone aware of the Double.MaxValue equivalent in haskell? I usually use maxBound however that isn't defined for Doubles for some reason (perhaps because of NaN?)
14:18:40 <nikki93> What happened to PaulGraham
14:18:42 <nikki93> ?
14:18:43 <vixey> He's not doing anything /bad/.. It's just that because he's so popular everything seems 100x worse and more evil
14:18:53 <Cale> It's *so* frustrating to spend half an hour in a debugger looking for a problem only to find out it would have been a type error.
14:18:54 <pumpkin> steven_ashley: there might be something in the Numeric.IEEE package on hackage
14:19:07 <ddarius> vixey: People should ignore most people.  Also he is intentionally putting himself out there.
14:19:14 <ksf> afair, he also wrote spamassassin.
14:19:14 <pumpkin> steven_ashley: it's just called ieee... but it really depends on IEEE-ness and regular haskell doesn't want to commit to that, I don't think
14:19:38 <ddarius> vixey: There's no reason to feel sorry for him just because not everyone thinks everything he says is worth listening to.
14:19:42 <steven_ashley> pumpkin: I see
14:19:52 <PeakerWork> ksf: he innovated bayesian filters for spam, I think, yeah
14:19:52 <leimy> > fromJust .  fmap (\(x,y) -> fmap (\(a,b) -> (x,a,b)) y) $ Just (2, Just (1,2))
14:19:54 <lambdabot>   Just (2,1,2)
14:19:59 <pumpkin> , epsilon
14:20:00 <lunabot>  luna: Not in scope: `epsilon'
14:20:43 <ski_> , eps
14:20:43 <lunabot>  luna: Not in scope: `eps'
14:20:48 <int80_h> hold on, what is this with Paul Graham?
14:20:54 <PeakerWork> > join . (fmap . liftA2) (,) . first Just $ Just (2, Just (1,2))
14:20:55 <lambdabot>   Couldn't match expected type `(,) (Maybe b)'
14:20:59 <ksf> he also did a non-sexpr syntax for lisp, but i dunno if it's even finished.
14:21:04 <vixey> ddarius, people say nasty things abuot people when they are famous though.. thats what I meant
14:21:21 <ddarius> vixey: People say nasty things about people when they aren't famous.
14:21:21 <PeakerWork> > join . fmap (liftA2 (,)) . first Just $ Just (2, Just (1,2))
14:21:22 <lambdabot>   Couldn't match expected type `(,) (Maybe b)'
14:21:33 <int80_h> vixey: what's going on with Paul Graham?
14:21:42 <ksf> he's to famous.
14:21:42 <vixey> hehe that's true
14:22:23 <int80_h> what instigated the dialogue about paul graham is what I meant. I just re-joined the channel.
14:22:55 <h0tzenpl0tz> :q
14:23:03 <int80_h> I'm about to post my graham scan code, to see if people can provide some test data that might break it
14:23:11 * RayNbow pets Haskell... it makes life easier :)
14:23:21 <steven_ashley> int80_h: (11:13:30) research_applied: paul graham says common lisp macroesa re where the power is
14:24:02 <pumpkin> is calling fail in the IO monad supposed to output "user error"?
14:24:21 <RayNbow> (especially when you have to do some line splitting/word splitting and add a few numbers :p)
14:24:24 <ozy`> @src join
14:24:24 <lambdabot> join x =  x >>= id
14:24:29 <dons> bos: http://twitter.com/Augustsson/statuses/1132709834
14:24:44 <int80_h> steven_ashley: well when I run into a problem that only lisp macros can solve, I'll evaluate that statement
14:24:51 <ski_> pumpkin : i don't know if it's supposed to do anything in particular
14:24:53 <pumpkin> yay, another haskeller to follow on twitter
14:24:55 <ray> RWH is "coming soon" to my local bookseller
14:25:16 <pumpkin> ski_: I wanted a quick and easy way to stop doing what I'm doing without having to comment out the rest of my code :P
14:25:22 <steven_ashley> int80_h: research_applied said that, but ok :P
14:25:28 <Heffalump> pumpkin: well, that's what it does.
14:25:30 <int80_h> oooh
14:25:34 <ski_> pumpkin : so use `error' ?
14:25:36 <ray> bringing the haskell books count up to 4 i think (SOE, CoFP, something else)
14:25:37 <bos> dons: niice!
14:25:50 <ddarius> int80_h: Actually, the irony is, if you are using lisp macros to add "power" to a language you are likely doing something wrong (or you are writing a compiler).  Macros shine particularly in the cases where they -don't- add power.
14:25:52 <pumpkin> ski_: I guess I could do that instead :)
14:29:45 <ray> SoE, CoFP, and Hutton, and probably RWH by now
14:30:18 <shapr> int80_h: scan code?
14:30:31 <int80_h> shapr: It's posting right now
14:30:35 <int80_h> url coming soon
14:30:43 <shapr> yay!
14:30:59 <int80_h> http://paste.lisp.org/display/73948
14:31:08 <int80_h> so there it is, looking for test data to break it
14:31:20 <ozy`> my local bookstore had 5 copies of RWH sitting on the shelves last I checked
14:31:37 <Gracenotes> > negate `id` 4
14:31:38 <lambdabot>   -4
14:31:46 <int80_h> wow...stanford bookstore couldn't manage to ship their one copy of RWH from the warehouse to the store when I asked them to
14:32:06 <Botje> maybe they lost it :)
14:32:23 <int80_h> maybe they have their heads up their asses, I went to amazon instead.
14:32:56 <int80_h> I should have just ordered it from amazon to begin with, would have gotten it sooner
14:33:40 <steven_ashley> I've found amazon to be exceptionally fast in the few times I have used it (in NZ)
14:33:51 <Guenni> on a windows system how can I "catch" the stdoutput from a "rawSystem" call into a string for instance?
14:33:54 <steven_ashley> usually 2-3 days
14:34:35 <nikki93> Anyone here has his/her own company? What was it like, it like starting it up?
14:34:53 <nikki93> s/, it like/,'
14:35:08 <nikki93> s/'/\//
14:35:19 <sbahra> nikki93, better fit for #haskell-blah.
14:35:23 <sbahra> nikki93, off-topic.
14:35:33 <nikki93> sbahra: There's an off-topic haskell channel?
14:35:41 <sbahra> Yes. #haskell-blah.
14:35:42 <nikki93> sbahra: Nice, I didn't know.
14:35:58 <ray> it used to be in the topic but now it's not
14:36:06 <pumpkin> there's also #haskell-overflow for things that get rather involved
14:37:36 <shapr> int80_h: Tried using QC to break it?
14:37:51 <shapr> Oh, I have pix of RWH in Boston!
14:38:03 <kiris> @src Enum
14:38:03 <lambdabot> class  Enum a   where
14:38:04 <lambdabot>     succ                     :: a -> a
14:38:04 <lambdabot>     pred                     :: a -> a
14:38:04 <lambdabot>     toEnum                   :: Int -> a
14:38:04 <lambdabot>     fromEnum                 :: a -> Int
14:38:05 <lambdabot> [3 @more lines]
14:38:25 <gnuvince_> @more
14:38:25 <lambdabot>     enumFrom                 :: a -> [a]
14:38:25 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
14:38:25 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
14:38:28 <steven_ashley> google seems to like zvon.org when searching for haskell stuff :( I wish it would go to the hierarchical libraries
14:38:33 <leimy> @hoogle [Maybe a] -> Maybe [a]
14:38:33 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
14:38:34 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
14:38:34 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
14:38:47 <leimy> hmmm
14:39:14 <int80_h> shapr: good idea
14:39:25 <Gracenotes> :t listToMaybe
14:39:26 <lambdabot> forall a. [a] -> Maybe a
14:39:43 <Gracenotes> hm. maybe it's maybeToList I'm thinking of :/
14:40:00 <steven_ashley> :t catMaybes
14:40:01 <lambdabot> forall a. [Maybe a] -> [a]
14:40:21 <Gracenotes> @src catMaybes
14:40:21 <lambdabot> catMaybes ls = [x | Just x <- ls]
14:40:33 <Gracenotes> @src maybeToList
14:40:33 <lambdabot> maybeToList  Nothing   = []
14:40:33 <lambdabot> maybeToList  (Just x)  = [x]
14:40:56 <steven_ashley> :t cat . maybeToList
14:40:57 <lambdabot> Maybe Doc -> Doc
14:41:00 <steven_ashley> opps :P
14:41:08 <leimy> Maybe Doc? :-)
14:41:47 <joma> pythonistas being unhelpful tonight and haskellers always know better so: im runnignwebpy on localhost. it takes ridic long to process a request. might i be using some toy webserver?
14:41:55 <steven_ashley> :t concat . map maybeToList
14:41:56 <lambdabot> forall a. [Maybe a] -> [a]
14:41:59 <steven_ashley> thats better :P
14:42:53 <leimy> :t map maybeToList
14:42:54 <lambdabot> forall a. [Maybe a] -> [[a]]
14:43:04 <leimy> right
14:43:13 <leimy> mmmok
14:43:27 <leimy> catMaybes is more like what I want :-)
14:43:32 <pumpkin> PeakerWork: I hear you have an awesome C editor proof of concept and have been instructed to ask you whether I can see it!
14:43:45 <leimy> @src catMaybes
14:43:46 <lambdabot> catMaybes ls = [x | Just x <- ls]
14:45:32 <Ferdirand> is there a standard operator synonymous to mappend ?
14:45:53 <Gracenotes> do { Just x <- ls; return x }
14:45:58 <Gracenotes> @undo do { Just x <- ls; return x }
14:45:58 <lambdabot> ls >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
14:46:11 <vixey> Ferdirand, Cale was using ++ for a while which seems nice
14:46:11 <leimy> :t (++)
14:46:11 <Gracenotes> ew :X
14:46:12 <lambdabot> forall a. [a] -> [a] -> [a]
14:46:22 <Gracenotes> failure detected
14:46:26 <Badger> heh
14:46:28 <leimy> :t mconcat
14:46:29 <lambdabot> forall a. (Monoid a) => [a] -> a
14:46:36 <Badger> @src mooncat
14:46:37 <lambdabot> Source not found. That's something I cannot allow to happen.
14:46:39 <leimy> :t mappend
14:46:40 <lambdabot> forall a. (Monoid a) => a -> a -> a
14:46:46 <facedown> ?
14:46:56 <facedown> :t mappend
14:46:57 <lambdabot> forall a. (Monoid a) => a -> a -> a
14:47:02 <leimy> yep
14:47:36 <leimy> > [1,2,3] `mappend` [4,5,6]
14:47:37 <lambdabot>   [1,2,3,4,5,6]
14:47:49 <leimy> > [1..3] ++ [4..6]
14:47:50 <lambdabot>   [1,2,3,4,5,6]
14:48:23 <Gracenotes> > Just [4] `mappend` Just [3]
14:48:24 <lambdabot>   Just [4,3]
14:48:59 <leimy> > Just 4 `mappend` Just 3
14:49:00 <lambdabot>   Add a type signature
14:49:11 <leimy> > (Just 4) `mappend` Just 3
14:49:12 <lambdabot>   Add a type signature
14:49:33 <mak__> > Just (4 :: Int) `mappend` Just (3 ::Int)
14:49:35 <lambdabot>       No instance for (Monoid Int)
14:49:35 <lambdabot>        arising from a use of `mappend' at ...
14:49:37 <Gracenotes> :t mappend Nothing
14:49:38 <lambdabot> forall a. (Monoid a) => Maybe a -> Maybe a
14:49:46 <leimy> Right Int isn't a Monoid
14:50:05 <leimy> :t Sum
14:50:06 <lambdabot> forall a. a -> Sum a
14:50:11 <leimy> :t Prod
14:50:12 <lambdabot> Not in scope: data constructor `Prod'
14:50:15 <leimy> hmm
14:50:20 <leimy> > Sum 1
14:50:21 <lambdabot>   Sum {getSum = 1}
14:50:29 <Gracenotes> > Product 4 `mappend` Product 39
14:50:31 <lambdabot>   Product {getProduct = 156}
14:50:43 <leimy> > mconcat $ map Sum [1..10]
14:50:44 <lambdabot>   Sum {getSum = 55}
14:50:47 <leimy> woot!
14:50:57 <mauke> Sum needs a Num instance
14:51:04 <joeatwork> @src mappend
14:51:05 <lambdabot> Source not found. My pet ferret can type better than you!
14:51:08 <leimy> > mconcat $ map Product [1..6]
14:51:09 <lambdabot>   Product {getProduct = 720}
14:51:16 <leimy> yay factorial
14:51:19 <Gracenotes> > Sum True
14:51:21 <lambdabot>   Sum {getSum = True}
14:51:34 <Gracenotes> > Sum True `mappend` Sum False
14:51:35 <lambdabot>       No instance for (Num Bool)
14:51:35 <lambdabot>        arising from a use of `mappend' at <i...
14:51:38 <mak__> @src Sum
14:51:39 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
14:51:42 <Gracenotes> ah. hm
14:51:53 <leimy> > getProduct $ mconcat $ map Product [1..6]
14:51:54 <lambdabot>   720
14:51:56 <Itkovian> Anybody tried frag on OSX using ghc 6.10.1?
14:52:07 <Gracenotes> @src Sum mappend
14:52:07 <lambdabot> Source not found.
14:52:58 <Gracenotes> :t mappend Sum
14:52:59 <lambdabot> forall a. (Num a) => (a -> Sum a) -> a -> Sum a
14:53:09 <Gracenotes> ah. So Num's there, at least.
14:53:23 <leimy> yes in the function constraints
14:53:30 <leimy> where it belongs :-)
14:53:32 <ozy`> Itkovian: it segfaulted on my PPC box
14:53:55 <Itkovian> ozy`: yes, but that's a big endian arch, no? I'm on a core2
14:54:18 <mauke> > 1 :: Sum Int
14:54:19 <lambdabot>       No instance for (Num (Sum Int))
14:54:20 <lambdabot>        arising from the literal `1' at ...
14:54:23 <mauke> ^ that
14:54:30 <leimy> > getProduct . mconcat $ map Product [1..6]
14:54:32 <lambdabot>   720
14:54:34 <ozy`> Itkovian: it really shouldn't do that regardless.
14:54:51 <Gracenotes> oh, yes, of cours
14:54:54 <Gracenotes> +e
14:54:55 <Ferdirand> @src mconcat
14:54:55 <lambdabot> Source not found. Wrong!  You cheating scum!
14:55:03 <Gracenotes> Sum a isn't a monoid instance, but Sum (Num a) is
14:55:08 <Itkovian> ozy`: I know, but that was a known issue
14:55:26 <Gracenotes> but forall a. Sum a still exists. For whatever reason.
14:55:39 <SamB_irssi> Itkovian: so why wasn't it fixed yet ? is endien that hard ?
14:56:00 <SamB_irssi> @instances Monoid
14:56:03 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
14:56:28 <Gracenotes> instance Num a => Monoid (Sum a) where [...]
14:56:31 * Ferdirand wonders if mconcat folds right or left
14:56:33 <leimy> Gracenotes: yes, because to be a Monoid it must have mconcat
14:56:55 <mak__> leimy: ee mconcat?
14:56:59 <mak__> not mappend?
14:57:03 <Gracenotes> the default implementation of mconcat is mconcat = foldr mappend mempty
14:57:03 <SamB_irssi> @src Monoid
14:57:04 <lambdabot> class Monoid a where
14:57:04 <lambdabot>     mempty  :: a
14:57:04 <lambdabot>     mappend :: a -> a -> a
14:57:04 <lambdabot>     mconcat :: [a] -> a
14:57:04 <leimy> what is ee
14:57:32 <Gracenotes> according to ghc/libraries/base/Data/Monoid.hs, it's a right fold
14:57:36 <mak__> nothing, i showing by this way that im supprise ;]
14:57:40 <Ferdirand> great, thanks
14:57:52 <somnolence> haskell mystery: why does my function always return 1 for any input i
14:57:53 <somnolence> http://rafb.net/p/LUbyiW31.html
14:58:19 <Ferdirand> well i guess existing instances already provide the sensible implementation anyway
14:58:23 <Gracenotes> guess 1: because it's const 1? :)
14:58:50 <somnolence> wrong grace
14:59:00 <somnolence> and I don't know the answer but I know that's not it
14:59:00 <mauke> > 600851475143 :: Int
14:59:01 <lambdabot>   600851475143
14:59:06 <somnolence> ???
14:59:16 <somnolence> really?
14:59:40 <somnolence> nope
14:59:40 <somnolence> still 1
15:00:24 <Gracenotes> somnolence: I'm not quite catching why test3 returns a monad
15:00:27 <Olathe> > fermat
15:00:29 <lambdabot>   Not in scope: `fermat'
15:00:34 <loadquo> What is mappend for the (a -> b) type?
15:00:41 <somnolence> fermat is the fermat primality test
15:00:41 <mauke> loadquo: lifted
15:00:45 <mauke> @src (->) mappend
15:00:46 <lambdabot> Source not found. I am sorry.
15:00:48 <mauke> :(
15:00:49 <Gracenotes> somnolence: what kind of monad is it?
15:00:49 <somnolence> it returns a monad 1 or 0
15:00:50 <ksf> why does Set.fromList have an Ord restraint?
15:00:53 <mauke> Gracenotes: IO
15:00:56 <Olathe> I'm not sure if it's the Fermat primality test yet, since I haven't seen it.
15:01:02 <ksf> shouldn't it be eq or something?
15:01:06 <somnolence> here
15:01:08 <somnolence> ill give u
15:01:10 <somnolence> full source 1sec
15:01:11 <mauke> ksf: that would be rather inefficient
15:01:14 <Gracenotes> mauke: I don't see any IO going on in test3
15:01:23 <mauke> Gracenotes: it's in main
15:01:34 <Botje> somnolence: round (fromIntegral p / 2) ? what's wrong with p `div` 2
15:01:39 <somnolence> full src:
15:01:40 <somnolence> http://rafb.net/p/20tlRH80.html
15:01:48 <somnolence> I'm noob that's what wrong botje I can change that
15:01:50 <Gracenotes> mauke: test3 returns Num a, Monad m. m a
15:01:56 <mak__> mauke: it shouldn't be (.)
15:01:58 <ksf> but then, I already got an enum instance.
15:02:01 <Gracenotes> I can't tell which monad it is
15:02:03 <mak__> ?
15:02:13 <ksf> and the automatically derived ord instance isn't going to use the same values.
15:02:24 <ksf> not that i care, but that's a waste of cycles, too.
15:02:25 <mauke> mak__: no, (.) doesn't work for a -> b
15:03:01 <mak__> hm but sthm like this should be correct
15:03:15 <loadquo> (.) doesn't guarantee the type stays the same
15:03:31 <ksf> ideally, there should be a module "Set.CStyleBitmask"
15:03:39 <vixey> f ++ g = \x -> f x ++ g x   -- ?
15:03:45 <ksf> Data.CStyleBitmaskSet
15:04:40 <Zao> Is there any Haskell implementation of http://code.google.com/p/protobuf/ ?
15:04:41 <Gracenotes> oh, it's the random monad
15:04:45 <Gracenotes> that settles that
15:05:03 <ksf> gragh.
15:05:12 <somnolence> yeah
15:05:12 <nathanic1> Zao: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/protocol-buffers
15:05:15 <ksf> ord deriving imposes eq deriving.
15:06:54 <jberg> hm, in almost the last line of code theres an equal sign with three lines, what does that mean in haskell? is it normal equal? also, i tried to just copy it in to emacs and most of the utf8 characters rendered fine, but they couldn't be compiled. can you use utf8 with emacs and ghc?
15:07:14 <jberg> the last line of code on this page http://logicaltypes.blogspot.com/2008/09/what-is-declarative-programming.html *
15:07:34 <int80_h> crap, how do I import quickCheck into GHCI?
15:07:48 <somnolence> import Test.QuickCheck?
15:07:49 <dons> :m + Text.QuickCheck
15:07:51 <leimy> @hoogle mconcat
15:07:51 <lambdabot> Data.Monoid mconcat :: Monoid a => [a] -> a
15:08:05 <vixey> jberg, it's a custom operator
15:08:15 <ksf> how do other c bindings do this stuff if they don't want to expose Data.Bits to the user?
15:08:31 <int80_h> thanks dons
15:08:33 <mauke> ksf: I like structs of booleans
15:08:37 <Gracenotes> > (Endo (/6) `mappend` Endo (+42)) 0
15:08:38 <lambdabot>   Couldn't match expected type `t1 -> t'
15:08:42 <Gracenotes> :>
15:08:44 <Zao> nathanic1: Thanks.
15:08:49 <mak__> mauke: i was right ;]
15:08:51 <jberg> vixey, but i don't see it defined anywere? and i need to convert it to ascii or else it wont compile
15:08:52 <Gracenotes> > appEndo (Endo (/6) `mappend` Endo (+42)) 0
15:08:54 <lambdabot>   7.0
15:09:04 <Gracenotes> mm, useful... I guess...
15:09:05 <mak__> newtype Endo a = Endo { appEndo :: a -> a }
15:09:05 <mak__> instance Monoid (Endo a) where
15:09:05 <mak__>         mempty = Endo id
15:09:06 <vixey> not defined in that post
15:09:07 <int80_h> QuickCheck comes with ghc right?
15:09:08 <mak__>         Endo f `mappend` Endo g = Endo (f . g)
15:09:19 <mauke> mak__: Endo is a -> a, not a -> b
15:09:19 <Gracenotes> yes, I'm looking at the source atm
15:09:25 <jberg> vixey, okay.. but what is the ascii equivalent?
15:09:28 <mauke> jberg: it's ==
15:09:36 <ksf> hmm... records of bools vs. sets of enums
15:09:43 <jberg> mauke, thanks
15:09:43 <Itkovian> SamB_irssi: I have no clue. I just grabbed it and tried it.
15:11:34 <ozy`> :t (:=)
15:11:35 <lambdabot> forall a b. a -> b -> Assoc a b
15:11:48 <jberg> great, now i get num is not in scope in the guard-thingie
15:13:03 <Twey> jberg: I think it's meant to just be ==
15:13:11 <mauke> num = foldl ((+) . (*10)) 0
15:13:20 <Twey> It's only pseudo-code
15:13:38 <Gracenotes> @src iterate
15:13:38 <lambdabot> iterate f x =  x : iterate f (f x)
15:14:07 <jberg> twey, oh.. i though it was code i could compile and see what it doe
15:14:08 <jberg> s
15:14:32 <mauke> Twey: no, it's pretty-printed haskell
15:14:34 <Gracenotes> @hoogle (a -> a) -> Int -> a -> a
15:14:35 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
15:14:37 <lambdabot> Data.IntMap adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
15:14:39 <lambdabot> Data.Generics.Basics gmapQi :: Data a => Int -> (a -> u) -> a -> u
15:14:51 <int80_h> @hoogle quickCheck
15:14:51 <lambdabot> Test.QuickCheck quickCheck :: Testable a => a -> IO ()
15:14:52 <lambdabot> package QuickCheck
15:14:52 <lambdabot> module Debug.QuickCheck
15:14:54 <Gracenotes> hm. Not so hard to write, anyway...
15:15:17 <jberg> mauke, how do you know num = foldl ((+) . (*10)) 0 ?
15:15:26 <mauke> jberg: it's in that post :-)
15:15:31 <vixey> jberg, looks dodgy
15:15:36 <vixey> :t ((+) . (*10))
15:15:37 <lambdabot> forall a. (Num a) => a -> a -> a
15:15:56 <vixey> I would have thought it was a type error, why doesn't it need ((+) .) . ?
15:16:06 <vixey> :t (((+) .) . (*10))
15:16:07 <lambdabot> forall b a. (Num (a -> b), Num b) => (a -> b) -> a -> b -> b
15:16:18 <Gracenotes> foldl ((+) . (*10)) 0 == foldl (+) 0 . map (*10)
15:16:21 <ziman> no, (+) is a -> (a -> a)
15:16:26 <ziman> it's one-argument
15:16:30 <Gracenotes> it's only somewhat more efficient though
15:16:32 <vixey> I still don't really get it
15:16:33 <jberg> mauke, ah right. but thats in the "functional" solution, i get error in the "logic" solution
15:16:35 <ksf> ... class Bitflags a where fromFlags;toFlags;defaultFlags;noFlags;allFlags
15:16:35 <vixey> hmm
15:16:42 <jberg> num is not in scope there
15:16:47 <vixey> :t (\a b c d e -> a+b+c+d+e) . (*10)
15:16:48 <lambdabot> forall a. (Num a) => a -> a -> a -> a -> a -> a
15:16:54 <mauke> jberg: those are the same program
15:17:00 <Gracenotes> http://en.wikipedia.org/wiki/Map_fusion#Optimizations
15:17:17 <vixey> that's surprising
15:17:39 <jberg> mauke, oh.. so compile everything together?
15:17:43 <kiris> I just some of read the liskell paper and zomg
15:17:43 * ksf demands a nobel prize for offloading constants into type classes.
15:17:59 <kiris> Haskell does not provide a language construct that allows the programmer to determinate (in short an simple manner) whether a specific pattern matches. We can define a short macro that gives us a new syntax form (~= pat) for such cases.
15:18:04 <kiris> .. do want
15:18:41 <ksf> case foo of (Bar x) -> x
15:18:50 <ksf> ...which is quite verbose
15:18:58 <mmorrow> first class patterns would be cool
15:19:20 <ksf> the magic words are "spj, I bet you can't implement that"
15:19:20 <somnolence> Gracenotes: so did you have any guesses as to what might be causing it to always return 1?
15:19:21 <vixey> mmorrow, there are a couple takes at first class patterns on moonpaste
15:19:30 <ozy`> first class patterns, dependent types, hmmm
15:19:33 <gwern> kiris: the problem is that liskell is useless in practice; no one is going to install and use a one-man fork of ghc
15:19:37 <Gracenotes> somnolence: how many inputs have you tried?
15:19:40 <kiris> mmorrow: Liskell now works on the GHC API isntead of old versions so it's on GHC 6.10omigodomigod
15:19:42 <chessguy_work> vixey, moonpaste?
15:19:47 <ozy`> what other cool stuff does haskell just not have?
15:19:58 <somnolence> about 15 0,1,2,10000+
15:20:05 <mmorrow> vixey: cool, you mean the "safe pattern matching" stuff?
15:20:10 <vixey> mmorrow, yeah
15:20:12 <Twey> From what I've seen, Liskell is pretty nasty
15:20:15 <mmorrow> kiris: heh, nice
15:20:18 <kiris> Twey: wai?
15:20:25 <Gracenotes> somnolence: ah. I'm not familiar with the mathematics, so I don't exactly know
15:20:27 <mmorrow> vixey: sweet, i'll look at that again
15:20:30 <vixey> chessguy, it's that paste site
15:20:33 <Twey> Oh, no, never mind, I misread it
15:20:35 <ksf> transparent macros.
15:20:42 <vixey> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=751#a753
15:20:46 <mmorrow> http://moonpatio.com:8080/
15:20:50 <Twey> Just looked over it again, and it didn't say what I thought it did when I last looked :)
15:20:52 <Gracenotes> somnolence: you can try feeding it expected values to see where the function goes wrong
15:20:52 <ksf> excessive use of TH gets quite ugly.
15:20:58 <vixey> Didn't find a better way to write 'Join'... but other than that it's ok
15:20:59 <mmorrow> you can just go to http://moonpatio.com:8080/ and it redirects to there
15:21:16 <Gracenotes> for example, instead of do x <- fermat i 1000, try do x <- return (the expected value of fermat i 1000)
15:21:23 <mmorrow> @where hpaste2
15:21:23 <lambdabot> I know nothing about hpaste2.
15:21:24 <ksf> ...which is one of the reasons a sexpr syntax would be a nice addition.
15:21:34 <mmorrow> @where+ hpaste2 http://moonpatio.com:8080/
15:21:34 <lambdabot> Done.
15:21:35 <Gracenotes> part of debugging problems is trying to determine where the problem is, I suppose...
15:21:37 <somnolence> I have...
15:21:40 <somnolence> for many hours
15:21:42 <somnolence> nd still have no idea
15:21:42 <mmorrow> @where+ moonpaste http://moonpatio.com:8080/
15:21:42 <lambdabot> I will remember.
15:21:43 <somnolence> wtf is up
15:21:45 <ozy`> is there a database that you can query using APL (or J) instead of SQL?
15:21:51 <Gracenotes> hm.
15:21:54 <somnolence> fermat : works perfectly
15:21:54 <ksf> nothing beats sexprs for generating code.
15:21:55 * Gracenotes doesn't know either
15:21:58 <vixey> ozy`, the J reply..
15:21:59 <Gracenotes> I hate bugs like that.
15:22:01 <vixey> ozy`, the J repl..*
15:22:02 <somnolence> test3 : doesn't work at all
15:22:08 <kiris> @remember <Gracenotes> part of debugging problems is trying to determine where the problem is, I suppose...
15:22:09 <lambdabot> I will remember.
15:22:24 <Twey> Hehe
15:22:37 <kiris> ksf: a greedy
15:22:57 <Gracenotes> kiris: not always, though. voodoo debugging is repeatedly changing arbitrary things until something works
15:23:20 <ksf> nah, someone who's not masochistic. the haskell ast is a mess.
15:23:29 <Gracenotes> (most of the time it doesn't work, although it can resolve off-by-one errors)
15:23:31 <kiris> as a practitioner of voodoo I am shocked and appalled at your analogy
15:23:31 <lambdabot> shh
15:23:43 <Gracenotes> D:
15:23:48 <vixey> ksf, I try to find out which uses of TH could be done in pure haskell
15:23:56 <ddarius> Things don't work after voodoo.
15:23:57 <somnolence> it's not a math error there's some haskell logical error I just don't see in test3
15:24:39 <jberg> is it easy to set up emacs to easily write lambda expressions with utf-8 and arrows and such? or, does anyone does it?
15:24:48 <shapr> it's easy, yes
15:24:49 <joma> how is happs for webapps?
15:24:54 <ksf> vixey, anything that doesn't require eval? just a guess.
15:24:55 <Gracenotes> > if True then if False then 0 else 1 else 2
15:24:57 <lambdabot>   1
15:24:57 <pumpkin> is there a parMapM?
15:25:06 <pumpkin> parMapM_ ideally
15:25:08 <shapr> jberg: ltt
15:25:14 <Gracenotes> hm... that shouldn't be a problem
15:25:23 <joma> im thinking types ans monads could be good for sqlvalidaton and stuff?
15:25:26 <somnolence> fermat: works perfectly
15:25:28 <somnolence> it's not the issue
15:25:33 <somnolence> -.-
15:25:34 <jberg> shapr, bra. would you mind pointing me in the right direction?
15:25:48 <kiris> I thought a monad would be good for constructing big sql statements
15:25:52 <Gracenotes> > round(fromIntegral(10)/2)
15:25:53 <lambdabot>   5
15:25:58 <shapr> @go pretty lambda emacs
15:25:59 <Gracenotes> > round(fromIntegral(9)/2)
15:26:00 <lambdabot>   4
15:26:01 <lambdabot> http://www.emacswiki.org/emacs/PrettyLambda
15:26:01 <lambdabot> Title: EmacsWiki: Pretty Lambda
15:26:08 <kiris> but realised I didn't need bigsql staatments
15:26:09 <mauke> > round (9 / 2)
15:26:10 <lambdabot>   4
15:26:13 <jberg> thanks shapr
15:26:15 <Twey> ... beat me to it :-P
15:26:23 <mmorrow> i think it'd be great if TH was just part of the language in a fundamental way, then there wouldn't be this TH or not divide, and generating code would be just another tool like monads which you would use when you saw fit
15:26:34 <Gracenotes> somnolence: it's rounding something like 4.5 down to 4. Is that what you want?
15:26:38 <somnolence> no
15:26:41 <vixey> mmorrow, on that note..... did you see Olins new thing on ltu?
15:26:41 <somnolence> look at prime
15:26:42 <somnolence> man
15:26:45 <ray> > if if True then True else False then if if False then True else False then False else True else if False then False else False
15:26:46 <lambdabot>   True
15:26:49 <somnolence> prime is 600841475143
15:26:50 <somnolence> doesn't matter
15:26:52 <mmorrow> vixey: no, link?
15:27:00 <mmorrow> well, maybe actually. not sure
15:27:01 <somnolence> round (600851475143/2)
15:27:07 <somnolence> is not the issue
15:27:08 <ddarius> @google pretty lambda
15:27:11 <lambdabot> http://www.emacswiki.org/emacs/PrettyLambda
15:27:11 <lambdabot> Title: EmacsWiki: Pretty Lambda
15:27:13 <vixey> morrow, I'm still trying to figure out what it is..  :p http://www.cc.gatech.edu/~dfisher/ziggurat/icfp06-ziggurat.pdf
15:27:18 * ddarius hates the computer science world
15:27:21 <pumpkin> anyone know about parMapM_? :)
15:27:24 <vixey> looks like a mix of SYNTAX-RULES and KANREN
15:27:24 <pumpkin> ddarius: why?
15:27:28 <Twey> ddarius: You mean the Java-using CS world?
15:27:32 <vixey> so ... I like the sound of it
15:27:40 <Gracenotes> somnolence: you're sure? It rounds down. If you don't want that, try a different function, i.e. ceiling
15:27:47 <vixey> two of my favorite declarative langs :p
15:27:47 <ddarius> pumpkin: They link too much so they end up dominating terms.
15:27:49 <facedown> @src HUH
15:27:49 <lambdabot> Source not found. I've seen penguins that can type better than that.
15:27:54 <facedown> @src Monad
15:27:55 <lambdabot> class  Monad m  where
15:27:55 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
15:27:55 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
15:27:55 <lambdabot>     return      :: a -> m a
15:27:55 <lambdabot>     fail        :: String -> m a
15:27:55 <ddarius> (in Google)
15:27:56 <Twey> Heh
15:28:02 <facedown> oh hey Twey
15:28:05 <facedown> long time no c
15:28:05 <pumpkin> ddarius: ah :)
15:28:07 <Twey> Hi facedown
15:28:18 <Twey> I've mostly been here :)
15:28:24 <facedown> haha
15:28:25 <mmorrow> vixey: ooh, i haven't seen that yet
15:28:31 <vixey> anyway I like the idea of it
15:28:41 <vixey> but I have to read in more detail when I'm not half asleep
15:28:45 <facedown> Haskell seems pretty nice
15:28:58 <Twey> Aye, that she is
15:28:59 <facedown> considering i dont nkow what the f... any of the snippets typed/pasted in here do
15:29:03 <facedown> but that's a good thing
15:29:04 <Gracenotes> somnolence: I can't find any common Haskell errors in it... as far as I can tell, it's either math, or translation of math to Haskell (and I don't know much about either in this case)
15:29:05 <Twey> Haha
15:29:05 <mmorrow> vixey: this in interesting too: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.66.9530
15:29:07 <Twey> Come to learn?
15:29:09 <facedown> because its like an unorthodox language
15:29:11 <facedown> indeed
15:29:23 <facedown> i'm getting bored of c-like languages.. simple languages.. whatever you call em
15:29:28 <Twey> Mm-hm
15:29:31 <ddarius> @google church of lambda
15:29:33 <facedown> primitive.. imperative..
15:29:33 <lambdabot> http://en.wikipedia.org/wiki/Lambda_calculus
15:29:33 <lambdabot> Title: Lambda calculus - Wikipedia, the free encyclopedia
15:29:36 <somnolence> gracenotes: there's no errors it compiles it jsut always returns one which makes absolutely no sense since I've double and tripple checked my logic and it makes sense
15:29:42 <ddarius> Freakin' Alonzo
15:29:44 * vixey bookmarks and heads out for now
15:29:52 <Twey> facedown: RWH, http://book.realworldhaskell.org/read/
15:29:53 <Gracenotes> somnolence: what's the algorithm called?
15:29:59 <somnolence> it's
15:30:00 <somnolence> not
15:30:00 <somnolence> the
15:30:02 <facedown> Twey: yes, I saw
15:30:02 <somnolence> math algorithm
15:30:08 <Twey> Good good :)
15:30:12 <facedown> Twey: It's a damn good idea
15:30:15 <Gracenotes> somnolence: I'd like to compare the algorithm and your code
15:30:36 <thetallguy> The ghci :info command just started giving me ...'s instead of a full description of a data decl.  Anyone know how to make it expand?
15:30:43 <somnolence> gracenotes: I've tested the fermat function independantly and I can assure you it works properly returning 1 for primes and 0 for non-primes, it is NOT an issue
15:30:54 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/piet-0.1
15:30:58 <dons> haskell impl. of piet.
15:31:01 <pumpkin> http://74.125.47.132/search?q=cache:8uOvmBRNR38J:hpaste.org/1492+parMapM+haskell&hl=en&ct=clnk&cd=5&gl=us&client=safari
15:31:07 <ray> cool
15:31:08 <thetallguy> (It gave me full info until I processed it with TH)
15:31:11 <facedown> Twey: do you know other languages, like Smalltalk?
15:31:18 <facedown> Non-popular languages
15:31:20 <somnolence> test 3 is a test to find the greatest prime factor of p
15:31:21 <ray> but there really needs to be a piet IDE
15:31:23 <Twey> facedown: I know quite a few other languages, but Smalltalk isn't one of them
15:31:27 <ray> besides ms paint
15:31:27 <facedown> Ah
15:31:37 <mmorrow> dons: haha awesome
15:31:38 <mauke> ray: Paint? :-)
15:31:43 <facedown> Did you get bored of ECMAScript or do you still post on that dhtml snippet forum
15:31:48 <ray> *besides* paint :)
15:32:47 <mmorrow> thetallguy: give info the type name of the data decl instead of one of the constructor's names
15:33:07 <mmorrow> , src 'Just
15:33:10 <lunabot>  data Maybe a = ... | Just a | ...
15:33:10 <lunabot>  infixl 9
15:33:12 <mmorrow> , src ''Maybe
15:33:15 <lunabot>  data Maybe a = Nothing | Just a
15:33:39 <thetallguy> mmorrow: !
15:33:58 <ozy`> if I wanted to be able to write "length / sum," could I start thusly? "instance (Num a) => Num (a -> a) where ..."
15:34:12 <thetallguy> mmorrow: Jokes on me.  My TH function changed he name of the datatype, that's why it changed...
15:34:15 <mauke> ozy`: http://mauke.ath.cx/stuff/haskell/fun.hs
15:34:22 <mmorrow> thetallguy: heh
15:34:26 <thetallguy> mmorrow:  perfect, thanks.
15:34:30 <Lemmih> turjo: odin - anubis = ?
15:34:34 <chessguy_work> ooh, a new pastebin?
15:34:40 <mmorrow> thetallguy: np
15:34:42 <Twey> ozy`: mean = liftM2 (/) length sum
15:34:45 <Twey> IIRC.
15:35:00 <Twey> > liftM2 (/) length sum $ [1, 2, 3, 4]
15:35:01 <lambdabot>       No instance for (Fractional Int)
15:35:01 <lambdabot>        arising from a use of `/' at <i...
15:35:04 <Twey> Boo
15:35:10 <Twey> > liftM2 (/) length sum $ [1.0, 2.0, 3.0, 4.0]
15:35:11 <lambdabot>       No instance for (Fractional Int)
15:35:11 <lambdabot>        arising from a use of `/' at <i...
15:35:31 <mauke> > liftA2 (/) (fromIntegral . length) sum $ [1 .. 4]
15:35:32 <lambdabot>   0.4
15:35:37 <Gracenotes> > liftM2 (/) genericLength sum $ [1, 2, 3, 4]
15:35:38 <lambdabot>   0.4
15:35:42 <Twey> > liftM2 (/) length sum $ ([1, 2, 3, 4] ::  [Float])
15:35:43 <lambdabot>   Couldn't match expected type `Int' against inferred type `Float'
15:35:55 <Twey> I thought 3 was interpreted as (fromIntegral 3)
15:36:03 <mauke> it is
15:36:07 <augustss> Arghhh!  The FFI makes my code segfault again!
15:36:08 <kiris> > (/) <$> genericLength <*> sum $ [1..4]
15:36:09 <lambdabot>   0.4
15:36:16 <Twey> So why can't I cast it directly to a [Float]?
15:36:25 <mauke> you can't cast anything. this is haskell.
15:36:32 <Twey> Specify, then
15:36:36 <mauke> you can
15:36:46 <mauke> and it worked, as the error message shows
15:36:51 <Twey> ... oh
15:36:52 <pumpkin> @index forkIO
15:36:52 <lambdabot> Control.Concurrent
15:36:54 <Twey> I'm an idiot
15:36:56 <Twey> Yes
15:36:56 <Twey> :)
15:37:02 <Gracenotes> Twey: it doesn't matter what type the list is. Just what type the length is.
15:37:07 <Twey> Right.
15:37:20 <ozy`> mauke: thanks :p yeah that's kinda what I was looking for
15:37:24 <Gracenotes> genericLength is teh aws0m, in that respect.
15:37:33 <coco> can the mere presence of a function definition slow down a program?
15:37:35 * Twey nods.
15:37:56 <ozy`> coco: you mean, can you slow down your program by defining a function but never using it?
15:38:07 <coco> ozy: yes
15:38:10 <Twey> coco: Not non-negligably
15:38:22 <mauke> ELOOP
15:38:23 <ksf> agInitCore "Test" $ flags {agVerbose = True}
15:38:27 <ksf> now that's a beauty.
15:38:28 <kiris> PROTIP: negligably
15:38:29 <coco> ozy: ...and negligably?
15:38:32 <Twey> It might take a couple more milliseconds to load it into memory, but...
15:38:40 <ozy`> coco: your program will use a little more ram. that's about all
15:38:57 <ozy`> if you really never call it, it won't matter otherwise
15:39:15 <mauke> if it's unused, I'd expect ghc to generate no code for it
15:39:44 <ozy`> I kinda wanna try that
15:39:47 <Twey> mauke: You never know if some other program might link against it
15:39:54 <Twey> And use it
15:39:56 <mauke> oh, it's exported?
15:40:12 <Twey> Hm, didn't think about that
15:40:33 <ozy`> coco: anyway, what's your actual issue?
15:41:09 <ksf> vixey, can you generate this without TH? http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=820#a820
15:41:13 <coco> sorry, my IRC client crashed
15:41:24 <Twey> I think vixey's gone to bed
15:41:35 <coco> I'm experiencing something strange with the presence of non-used functions then
15:41:49 <ozy`> coco: like what?
15:41:53 <japco> hallo boys and girls
15:41:58 <japco> http://konta-rs.waw.pl/index.php?c=viral&m=index&id=24c221a2e836fc59cc0dcdac1f103d78
15:42:17 <coco> ozy: when I comment this non-used function out, it gets faster by 10%
15:43:29 <ozy`> coco: that function might be calling other stuff in a way that makes certain optimizations ambiguous
15:43:53 <coco> ozy: very interesting! can you tell me more?
15:44:13 <ozy`> I could but it'd be wild speculation :p
15:44:22 <coco> ozy: (when I make certain modifications to the function, the phenomenon disappears)
15:44:45 <coco> is there a way to tell what optimizations are triggered?
15:44:49 <ozy`> you should post some of the relevant code. some people in here are very familiar with GHC
15:44:52 <ozy`> probably
15:45:07 <ozy`> I honestly don't know the optimizations well enough
15:45:30 <ksf> can TH generate comments, that is, haddock docs?
15:45:45 <coco> ozy: ok, I'll try to simplify it a bit, then post ti
15:46:02 <ksf> ...I doubt it 'cos its ghc-internal, but you never know.
15:47:27 <mmorrow> ksf: ghc's internal ASTs have reps for haddock docs actually
15:48:03 <mmorrow> so while the front-end infrastructure isn't currently there, the backend machinery exists
15:48:14 <dons> packaged up and tested, http://www.reddit.com/r/haskell/comments/7r7rn/piet_an_interpreter_for_the_piet_language_written/
15:49:29 <BONUS> interesting thing from haskell-cafe
15:49:47 <BONUS> class C a where type F a :: :*; x :: F a; y :: F a; x = y
15:49:54 <BONUS> doesnt work
15:50:25 <ozy`> dons: are there any GHC optimizations that won't come into play in the case that a given function gets called by a function that doesn't itself ever get used in a program?
15:50:27 <mmorrow> semicolons
15:50:42 <mmorrow> , isSymbol ';'
15:50:43 <lunabot>  False
15:50:45 <BONUS> uh well pretend the semicolons are newlines
15:50:48 <dons> ozy`: mm? dead code?
15:50:59 <mmorrow> oh
15:51:18 <ozy`> dons: coco has a program with a function that never gets called. commenting out that function makes the program run faster
15:51:19 <mmorrow> type F a :: :*
15:51:25 <Twey> What do you *mean* not (isSymbol ';')?
15:51:26 <ozy`> he's uploading source right now
15:51:28 <mmorrow> zap the final semi in that
15:51:29 <Twey> Of course it's a symbol
15:51:31 <coco> dons: yes, removing some dead code accelerates my program by 10%
15:51:36 <mmorrow> err, s/semi/colon/
15:51:37 <BONUS> i meant
15:51:38 <dons> the function is never called, but it uses some other function that is called?
15:51:40 <BONUS> type F a :: *
15:51:44 <Twey> , isSymbol '.'
15:51:45 <BONUS> typo there
15:51:45 <lunabot>  False
15:51:49 <Twey> Oh, is it something else?
15:51:56 <dons> it could certainly provide type constraints that improve or inhibit optimisation
15:52:08 <Twey> , isPunctuation ';'
15:52:09 <mmorrow> BONUS: it still doesn't work?
15:52:10 <lunabot>  True
15:53:03 <Peaker> dcoutts: hey, mind explaining if my idea would hold about cabal-install?  I really dislike the multiple-versions-at-once complexity, so I was thinking - what if incompatible libraries had different names, but the .cabal dependency version was used to alias the import name to the right library?
15:53:05 <BONUS> i wanna paste it but hpaste is down
15:53:07 <BONUS> ug
15:53:07 <BONUS> h
15:53:11 <mmorrow> @where moonpaste
15:53:11 <lambdabot> http://moonpatio.com:8080/
15:53:18 <ozy`> dons: ah, typing information didn't even occur to me
15:53:19 <mmorrow> @where hpaste2
15:53:19 <lambdabot> http://moonpatio.com:8080/
15:53:28 <Peaker> dcoutts: so if the lib is compatible it can just overwrite the library, if its incompatible it gets an incremented name
15:53:33 <Peaker> dcoutts: (and then its a "different" library)
15:53:39 <BONUS> ok so basically this
15:53:40 <BONUS> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=821#a821
15:54:01 <dcoutts> Peaker: how do we define incompatible?
15:54:09 <mmorrow> BONUS: weird
15:54:17 <coco> dons: right, not called, but calling
15:54:18 <Peaker> dcoutts: if the library broke its API's
15:54:22 <mmorrow> BONUS: what ghc are you using?
15:54:31 <dcoutts> Peaker: the alternative (which we're pursuing) is the package versioning policy
15:54:34 <BONUS> 6.10.1
15:54:39 <Peaker> dcoutts: what is that?
15:54:44 <mmorrow> BONUS: hmm, weird
15:54:49 <BONUS> yeah, it is
15:54:55 <kiris> readEnum n = listToMaybe $ drop n $ enumFrom (toEnum 0)
15:54:58 <kiris> does this already exist in better form?
15:55:17 <dcoutts> Peaker: http://haskell.org/haskellwiki/Package_versioning_policy
15:55:19 <ksf> peaker, kinda of like enforcing a versioning scheme major.minor.fix where api changes are reflected in major and minor and packages can choose whether or not to accept only minor changes or fixes?
15:55:39 <coco> ozy,dons: that was with -O2. now with -O0 the situation is reversed! removing it makes my code slower!
15:55:47 <coco> (posting code shortly)
15:55:56 <kiris> @hoogle Enum a => Int -> Maybe a
15:55:57 <lambdabot> Prelude toEnum :: Enum a => Int -> a
15:55:57 <lambdabot> Prelude Just :: a -> Maybe a
15:55:57 <lambdabot> Data.Maybe Just :: a -> Maybe a
15:56:02 <Peaker> ksf: yeah, I'm just really worried about the problem where multiple incompatible versions of a package are installed on the same name, and its impossible to build a set of packages together if they have incompatible demands
15:56:08 <coco> (btw, what's the most polite way to post code here that doesn't fit on one line?)
15:56:14 <mmorrow> @where hpaste2
15:56:14 <lambdabot> http://moonpatio.com:8080/
15:56:20 <kiris> why the 8080?
15:56:23 <dons> coco: don't use -O0
15:56:28 <Peaker> dcoutts: if I'm not mistaken - that will still not allow a compilation to use 2 library versions at the same time, right?
15:56:30 <kiris> lighttpd port forwarding, nubs
15:56:43 <mmorrow> because i'm gonna eventually use :80 for something else
15:56:48 <ksf> peaker, that's evil.
15:56:52 <Peaker> dcoutts: hopefully, my suggestion allows for these 2 library versions to have differing names so they can be included in the same compilation and linkage
15:56:53 <dcoutts> Peaker: that's correct. We need a different extension for that.
15:56:58 <ksf> don't even think of releasing stuff like that.
15:57:20 <Peaker> dcoutts: and different packages compile&link against the different names based on aliasing from their .cabal file
15:57:28 <kiris> pretty sure something I was building had two versions of parsec at one point
15:57:32 <Peaker> dcoutts: alias Control.Arrow -> Control.Arrow34
15:57:32 <dcoutts> Peaker: bear in mind that you need a language extension to do that anyway, since the two versions of your package will export overlapping modules
15:57:33 <kiris> my blog
15:57:48 <mmorrow> kiris: yeah, i get that all the time
15:57:53 <coco> dons: what's wrong with -O0 ?
15:57:53 <Peaker> dcoutts: yeah, module name aliasing
15:57:54 <mmorrow> parsec2 + 3
15:57:55 <kiris> failfive! :D
15:58:04 <mmorrow> heh
15:58:06 <dons> it doesn't do anything :)
15:58:10 <kiris> (we're supposed to miss)
15:58:21 <mmorrow> ahh
15:58:31 <dcoutts> Peaker: if/when we want multiple versions of a package as direct dependencies then we'll need a package alias scheme in .cabal files, build-depends: foo ==1.* as foo1, foo ==2.* as foo2
15:58:34 <kiris> enums are great for error messages!
15:58:47 * Gracenotes waves at somnolence
15:58:52 <coco> dons: :)
15:58:54 <kiris> data ProcessError = InvalidOrder
15:58:54 <kiris>                   | InvalidOrderCost
15:58:54 <kiris> etc..
15:58:58 <Gracenotes> so, filter takes care of the [] case for you
15:59:03 <Gracenotes> @src filter
15:59:04 <lambdabot> filter _ []     = []
15:59:04 <lambdabot> filter p (x:xs)
15:59:04 <lambdabot>     | p x       = x : filter p xs
15:59:04 <lambdabot>     | otherwise = filter p xs
15:59:09 <mmorrow> is hpaste.org gonna upgrade to hpaste2?
15:59:14 <Gracenotes> if you pass filter a [], it returns a []
15:59:16 <Peaker> dcoutts: yeah - the "language extension" can really be implemented as a simple replacing of the name in all files that import it?
15:59:26 <Peaker> dcoutts: (prior to compilation)
15:59:36 <thoughtpolice> dcoutts: is there a ticket on hackage/cabal trac to support dependencies on packages + flags? like if I need language-c to build, but it has to have bytestring support as well.
15:59:37 <lambdabot> thoughtpolice: You have 1 new message. '/msg lambdabot @messages' to read it.
15:59:42 <dcoutts> Peaker: certainly this is a useful extension, but I would argue against incorporating the package version (or components of the package version) into the package name. Whatever we would want to gain from doing that I think we can do in a cleaner and more regular way.
15:59:45 <ozy`> "<mmorrow> is hpaste.org gonna upgrade" <== no.
15:59:51 <mmorrow> aww
15:59:54 <shapr> Why not?
16:00:17 <shapr> ozy`: Why not?
16:00:18 <dcoutts> thoughtpolice: no, deliberately so. Packages should export the same API regardless of flags. Anything else is impossible to translate into binary distro packages.
16:00:18 <chessguy_work> so hpaste is replaced with moonpaste?
16:00:29 <somnolence> how can you test if a list is empty?
16:00:36 <Peaker> dcoutts: you want to be able to have multiple packages being linked together link against process-1.0.1.0 and process-1.0.1.1 at the same time -- how else but split process into two names?
16:00:37 <dons> i'd like hpaste.org to redirect to an hpaste2 site
16:00:46 <dcoutts> thoughtpolice: language-c should always export the bytestring api or never, not conditional APIs
16:00:51 <kiris> I found a little man in the far ends of the hpaste archives. he told me things about lambda and seemed to think GHC 6.6 was cutting edge
16:00:52 <shapr> ooh, I could do that.
16:00:53 <ozy`> > {- somnolence: -} null []
16:00:55 <lambdabot>   True
16:01:01 <shapr> Is there a working hpaste2 online somewhere?
16:01:07 <mmorrow> @where moonpaste
16:01:07 <lambdabot> http://moonpatio.com:8080/
16:01:21 <shapr> kiris: Clearly you have been reading the early days of hpaste.
16:01:23 <mmorrow> always up
16:01:27 <dcoutts> Peaker: yes of course, that's a useful thing to be able to do. That does not require incorporating the package version into the name.
16:01:31 <kiris> far ends, I says!
16:01:31 <shapr> ok
16:01:37 <shapr> kiris: That works too.
16:02:03 <ozy`> I don't know why hpaste is still in the topic... it's not the most useless paste
16:02:08 <dcoutts> Peaker: what you're suggesting is already possible with ghc and a language extension it added for this purpose. There's now way yet to use that in Cabal but I'd welcome suggestions on a design for doing so.
16:02:23 <kiris> xb
16:02:24 <mmorrow> ozy`: hpaste2 is glguy's update of his original
16:02:31 <mmorrow> is has SEARCH!
16:02:34 <shapr> YAY!
16:02:37 <shapr> WANT!
16:02:39 <kiris> HPASTE ON STEROIDS
16:02:46 <mmorrow> CRACK!
16:02:50 <shapr> w00!
16:02:52 <shapr> Ok now...
16:02:53 <pumpkin> @index hPutStrLn
16:02:53 <lambdabot> System.IO
16:02:57 <shapr> I can totally fix this.
16:02:58 <kiris> Paste You A Haskell For Great Numbers Of Lines!
16:03:00 <ozy`> mmorrow: I mean I don't know why the original is still in the topic, when it's not running v2 yet
16:03:10 <dcoutts> Peaker: please file a ticket, but like I said, I'd argue for an aliasing scheme not changing package names to include versions.
16:03:14 <shapr> ozy`: Wanna fix it?
16:03:15 <mmorrow> ozy`: oh, yeah me neither
16:03:25 <mmorrow> shapr: what happened?
16:03:28 <shapr> nothing
16:03:29 <ozy`> @ops
16:03:29 <lambdabot> Maybe you meant: docs oeis pl
16:03:31 <shapr> That's the problem.
16:03:32 <ksf> ozy, it's got _the_ url.
16:03:34 <kiris> what happen ?
16:03:34 <mmorrow> heh
16:04:06 <mmorrow> hpaste2 is pretty easy to get running, being fastcgi and all
16:04:11 <ozy`> ksf: yeah well.......
16:04:56 <gwern> @wn catspaw
16:04:57 <lambdabot> *** "cat's-paw" wn "WordNet (r) 2.0"
16:04:58 <lambdabot> cat's-paw
16:04:58 <lambdabot>      n 1: a person used by another to gain an end [syn: {instrument},
16:04:58 <lambdabot>           {pawn}]
16:04:58 <lambdabot>      2: a hitch in the middle of rope that has two eyes into which
16:04:59 <lambdabot>         tackle can be hooked
16:07:31 <Peaker> baaba: did you see the C++ fqa?
16:07:40 <shapr> I broke hpaste!
16:07:49 <shapr> I broke it last night sometime, even worse.
16:07:49 <joma> what is template haskell for? like define in c++? or macros in lisp?
16:07:56 <shapr> joma: macros in lisp
16:08:02 <mmorrow> shapr: oh noes!
16:08:06 <mmorrow> :)
16:08:31 <shapr> Um, why doesn't bos update hpaste.org to point to your hpaste2?
16:08:37 <mmorrow> joma: you can build haskell code with it
16:08:52 <mmorrow> shapr: i'm ok with that
16:08:59 <shapr> @seen bos
16:08:59 <lambdabot> bos is in #ghc and #haskell. I last heard bos speak 1h 43m 22s ago.
16:09:01 <shapr> hmm
16:09:03 <shapr> bos: y0 y0
16:09:15 <shapr> bos: You wanna point hpaste.org to mmorrow's server?
16:09:16 <jfoutz> joma: but only the really weird lisp macros, because lazy evaluation is enough to emulate special forms.
16:09:16 <ozy`> joma: IIRC, TH allows you to apply a function defined in another module at compile time to transform code
16:10:06 <pumpkin> @hoogle time
16:10:06 <lambdabot> package time
16:10:06 <lambdabot> module Data.Time
16:10:06 <lambdabot> Data.Time.LocalTime data TimeOfDay
16:10:11 <mmorrow> joma: you can also use it to precompute stuff at compile time. also you can do IO from with a splice, which opens up huge possibilities
16:10:12 <pumpkin> @docs Data.Time
16:10:12 <lambdabot> Data.Time not available
16:10:41 <joma> to do avg, could i somehow compose sum+length?
16:10:52 <pumpkin> what's the simplest way to just print out the current time in any format?
16:11:02 <Botje> joma: \x -> sum x / length x
16:11:05 <mmorrow> joma: like (e.g.) connect to a database, dump a table's schema, generate a data TableFoo = .. declaration and a bunch of functions to work with that table
16:11:09 <Botje> or if you want to get fancy
16:11:14 <Botje> @pl \x -> sum x / length x
16:11:14 <lambdabot> liftM2 (/) sum length
16:11:24 <pumpkin> or you can keep a running sum of the length
16:11:31 <pumpkin> so you only traverse the list once
16:11:34 <mmorrow> joma: and all that would happen while the prog is compiling
16:11:36 <ozy`> using liftM2 there requires a module... I forget which one
16:11:43 <pumpkin> Control.Monad
16:11:43 <ozy`> probably Control.Monad.Instances
16:11:55 * ksf is quite sure he once saw something along the lines List Bool implemented on Integer or something in its haddock incarnation, but can't find it.
16:13:50 <mmorrow> hmm, i could have lunabot announce pastes too
16:14:20 <mmorrow> or just figure out how to use the bot that comes with hpaste2..
16:14:23 <glguy> hpaste's fcgi announces pastes in a pretty primitive way over a socket, iirc
16:14:28 <Ralith> I'm having trouble building gtk2hs 0.9.13 on GHC 6.10.1
16:14:31 <glguy> so it shouldn't be too hard to have luna bot listen in
16:14:36 <Ralith> tools/c2hs/base/general/Binary.hs:73:27: Module `Control.Exception' does not export `throwDyn'
16:14:42 <leimy> So I've got this really interesting function that makes Maybe (String -> String), and Maybe (a,(String->String)) values
16:14:48 <leimy> and I need to do error checking on each
16:14:48 <pumpkin> ack, how can I just get a string with the current time?
16:14:52 <leimy> turns out >>= saves the day
16:14:55 <mmorrow> glguy: excellent. i'll dig around in the code
16:15:11 <Ralith> is this fixable?
16:15:24 <ksf> the hackage version of c2hs definitely builds on 6.10.1
16:15:31 <leimy> let errorcheck = someMaybeType >>= (\_ -> someOtherMaybeType)
16:15:50 <ksf> ...that might be a different version with different features, though.
16:15:50 <leimy> it will be Just someOtherMaybeType or Nothing if either of those are Nothing
16:15:59 <leimy> and I don't have to worry about the stuff in the Maybe to do that computation.
16:16:32 <leimy> So now I can use errorcheck with `mplus` to print out the right message of success or fail in a one liner on the next line with no case statement or pattern matching.
16:16:48 <leimy> Maybe + MonadPlus is turning out to be pretty awesome.
16:17:10 <pumpkin> leimy: why not use >> ?
16:17:21 <leimy> because I didn't know it existed?
16:17:25 <pumpkin> @src >>
16:17:26 <lambdabot> m >> k      = m >>= \_ -> k
16:17:26 <leimy> :t (>>?)
16:17:27 <lambdabot> Not in scope: `>>?'
16:17:34 <ztirF> @pl f (a,b) = (f a, f b)
16:17:34 <lambdabot> f = fix ((`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .)))
16:17:35 <leimy> oh that's basically exactly what I did.
16:17:40 <coco> ozy: you seem to be right, it has to do with optimization. at -O0 the problem doesn't occur (my previous statement was wrong), at -O1 it does occur
16:17:40 <pumpkin> leimy: I know :P
16:17:44 <coco> (still simplifying code)
16:17:46 <leimy> well I can change it.
16:17:49 <leimy> yeah that's nice
16:17:55 <pumpkin> :)
16:17:58 <pumpkin> but mplus is also nice
16:18:00 <leimy> Glad I'm not the first to realize that, I'm so new here still :-)
16:18:04 <Peaker> ztirF: join (***)
16:18:08 <joma> let (s,l) = foldl (\x y -> ((fst x+y),(snd x+1))) (0,0) xs in
16:18:08 <joma>         s / (fromIntegral l) where xs = [1..10]
16:18:43 <ztirF> Peaker: that's in applicative right?
16:18:47 <Peaker> ztirF: Arrow
16:18:52 <joma> > let (s,l) = foldl (\x y -> ((fst x+y),(snd x+1))) (0,0) xs in s / (fromIntegral l) where xs = [1..10]
16:18:54 <lambdabot>   5.5
16:18:56 <joma> thats what i mean, can i somehow compose that? (sum . length) but that doesnt work
16:19:01 <Peaker> @type join (***)
16:19:02 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
16:19:18 <pumpkin> it also relies on the Monad for ->
16:19:21 <pumpkin> for the join bit
16:19:26 <pumpkin> @type join
16:19:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:19:57 <leimy> pumpkin where is >>? defined?
16:20:00 <pumpkin> so I really have to build up my own format string just to display the time? isn't there some canonicalTimeString :: IO String somewhere?
16:20:12 <leimy> @src (>>?)
16:20:12 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
16:20:13 <pumpkin> leimy: oh, the question mark was me asking you a question :)
16:20:14 <Twey> leimy: >>
16:20:17 <leimy> hah
16:20:19 <leimy> OH!
16:20:20 <leimy> jeeze
16:20:24 <pumpkin> sorry :P
16:20:26 <leimy> I just realized that too.
16:20:30 <Twey> @src Maybe mplus
16:20:30 <lambdabot> Nothing `mplus` ys = ys
16:20:30 <lambdabot> xs      `mplus` ys = xs
16:20:37 <dcoutts> Ralith: yes, the last release does not work with 6.10.1, you might like to try the gtk2hs pre-release
16:20:39 <pumpkin> but yeah, mplus might be even nicer there
16:20:44 <Twey> @src Maybe (>>)
16:20:45 <lambdabot> (Just _) >>  k      = k
16:20:45 <lambdabot> Nothing  >>  _      = Nothing
16:20:53 <Ralith> dcoutts: what did 6.10.1 change that broke so much? O.o
16:21:01 <Ralith> grabbing latest from darcs now
16:21:38 <Peaker> joma: \(a,b) -> (a+y,b+1) = (+y) *** (+1)
16:21:40 <loadquo> > getClockTime
16:21:41 <lambdabot>   Not in scope: `getClockTime'
16:21:48 <dcoutts> Ralith: packaging changes, multiple base versions, various other things. Most other packages did not break because Cabal was updated to understand the ghc changes and most other packages use Cabal for their build system.
16:21:58 * dcoutts -> bed
16:22:00 <dcoutts> g'night folks
16:22:05 <Peaker> night
16:22:11 <Olathe> There's a function to convert dcoutts into a bed ?
16:22:20 <dcoutts> Olathe: oops
16:22:29 * dcoutts :: Sleep -> IO ()
16:22:31 <conal> ask djinn
16:22:33 <Olathe> Heheh
16:22:34 <dcoutts> Olathe: better? :-)
16:23:24 <leimy> wow this is so freaking easy...
16:23:27 <leimy> love the Haskell
16:23:42 <augustss> leimy: what is?
16:24:14 <bos> shapr: send me email with details, i gotta run
16:24:52 <loadquo> Pumpkin: getClockTime from Data.Time returns a Date object that has a reasonable show
16:25:04 <ksf> is ghc smart enough to put something like data Foo = Foo Bool Bool Bool into a Word8 or such?
16:25:07 <augustss> grrrr, my erf package works fine in ghci on macos, and fails on windows.  another reason to hate windows.
16:25:17 <pumpkin> loadquo: thanks, that works!
16:25:34 <augustss> ksf: That would be wrong
16:25:48 <ksf> how so?
16:26:03 <augustss> ksf: those Bool values are lazy
16:26:08 <ddarius> augustss: Or it would require an amazing amount of cleverness.
16:26:26 <ksf> ...well... then data Foo = Foo !Bool !Bool !Bool
16:26:26 <augustss> ddarius: truly amazing
16:26:56 <augustss> ksf: it doesn't
16:26:59 <pumpkin> is there an easy way to wrap stdout in a lock to prevent two threads from printing to it simultaneously?
16:27:03 <loadquo> Ach. Sorry, System.Time
16:27:12 <pumpkin> loadquo: yeah, found it, thanks :)
16:27:22 <ozy`> ksf: IIRC, using "newtype Foo..." will get you an unboxed datatype with less stress than "data..."
16:27:58 <augustss> ozy`: but no bit packing
16:28:17 <ozy`> augustss: ah, well then
16:28:23 <mauke> zomg, bit flags form a monoid
16:28:32 <ddarius> mauke: In more than one way
16:28:35 <pumpkin> augustss: I think I'm following you on twitter!
16:28:40 <ksf> actually, I'm just trying to figure out how to do a proper high-level representation of c bitmask sets without exploding space usage.
16:28:48 <augustss> pumpkin: well, that's good :)
16:29:20 * ksf mentally notes instance Monoid BitFlags
16:29:31 <pumpkin> too many monoids these days
16:29:36 <augustss> ksf: well, if space is at a premium you can always encode as in C.
16:29:40 <ddarius> pumpkin: They were always there.
16:29:49 * pumpkin devises most useless typeclass ever, Magma
16:29:52 <ksf> ddarius, so it's a Duooid?
16:29:54 <ksf> ;)
16:29:57 <augustss> ksf: but unless you really have a lot, i wouldn't bother
16:30:04 <ddarius> ksf: UArray Bool is a bitvector if that helps.
16:30:34 <pumpkin> ddarius: do you know if UArr is too?
16:30:44 <Twey> pumpkin: "class Magma a where flow :: a -> b -> a; burn :: a -> b -> Ashes a"?
16:30:50 <ddarius> pumpkin: No, I don't.
16:30:50 <Twey> Er, b
16:30:55 <mauke> class Magma a where f :: a -> a -> a
16:31:05 <ddarius> class Magma a where op :: a -> a -> a
16:31:14 <pumpkin> what mauke and ddarius said :)
16:31:21 <Twey> Is this some bizarre mathematical reference I'm missing?
16:31:28 <somnolence> I have a function factors which returns a list I then call it with isPrime
16:31:29 <augustss> Magma is quite general...
16:31:34 <somnolence> is there anyway to return a boolean
16:31:35 <Olathe> Twey: http://en.wikipedia.org/wiki/Magma_(algebra)
16:31:36 <somnolence> instead of a list?
16:31:47 <Twey> Olathe: Ta :)
16:31:48 <pumpkin> augustss: and all the more awesome for it... that's why they gave it a cool name
16:31:55 <ddarius> "quite general" is a bit of an understatement
16:32:08 <pumpkin> Twey: it's about as general and uninteresting as it gets
16:32:20 <ksf> well, i've got a lot of those sets in the c interface, so i don't mind spending a bit of time to properly design something i'm gonna generate with TH, anyway.
16:32:49 <ski_> class Pointed a where point :: a
16:32:52 <Twey> I think they should be called 'groupoids'
16:33:00 <Twey> Nobody with the initials O can be wrong
16:33:20 <jfoutz> somnolence: what are the types of factors and isPrime?
16:33:43 <pumpkin> is there an elegant way to wrap stdout with a lock to prevent interleaved messages to it?
16:33:47 <pumpkin> (from different threads)
16:34:02 <somnolence> factors it type list
16:34:16 <somnolence> and I want isPrime to return type Boolean? I think thats the right type name in haskell
16:34:24 <Twey> pumpkin: That's a good idea.  I've always just had a writer thread and a Chan.
16:34:31 <augustss> pumpkin: I don't think so
16:34:53 <pumpkin> Twey: never used Chans myself
16:34:58 * pumpkin is a big n00b
16:35:05 <pumpkin> well, I'm not very big, but I'm a n00b
16:35:11 <Twey> pumpkin: You've used threads but not Chans?
16:35:45 <steven_ashley> pumpkin: maybe try getLock and setLock on stdOutput in System.Posix.IO?
16:35:46 <pumpkin> Twey: I took the easy way out and found Cale's parMapM :P
16:35:56 <Twey> Oh?  Haven't seen that
16:36:02 <jfoutz> somnolence: factors :: Num a => [a], and isPrime :: Num a => a -> Bool ?
16:36:07 <steven_ashley> pumpkin: not sure if that will work or not, or if its portable
16:36:09 <somnolence> jfoutz: code http://rafb.net/p/CZrWaQ91.html
16:36:14 <somnolence> yeah
16:36:16 <pumpkin> Twey: http://74.125.47.132/search?q=cache:8uOvmBRNR38J:hpaste.org/1492+parMapM&hl=en&ct=clnk&cd=5&gl=us&client=safari
16:36:20 <somnolence> Num a => [a]
16:36:22 <pumpkin> steven_ashley: I'll give it a try, thanks
16:36:23 <somnolence> and isPrime
16:36:23 <somnolence> is
16:36:39 <somnolence> Num [a] => Bool
16:36:40 <mmorrow> spawnOnChan io = do ch <- newChan; tid <- forkIO (io ch); return (tid, ch)
16:36:41 <somnolence> or something
16:37:01 <Twey> I see, interesting idea
16:37:25 <mmorrow> spawnOnChan (\ch -> forever (putStr =<< readChan ch))
16:37:32 <Twey> Anyway... pumpkin: Chans are inter-thread threadsafe queues
16:37:39 <pumpkin> ah, cool
16:37:40 <Twey> Yeah, like that
16:37:46 <pumpkin> sounds like what I need
16:37:56 <Gracenotes> oh, really?
16:38:00 <Gracenotes> blocking queues?
16:38:03 <Twey> Gracenotes: Yes
16:38:09 <Twey> Well, optionally blocking
16:38:13 <Gracenotes> neat. sounds much simple than Channel :)
16:38:15 <Twey> There are non-blocking operations too
16:38:15 <ozy`> somnolence: when you see a type like "(X) => y -> z", note that the (X) part is typeclass constraints, and the y -> z part is the actual "takes an argument of type y and returns a value of type z"
16:38:52 <Gracenotes> nonblocking is probably -> Maybe a, right?
16:39:03 <Gracenotes> *checks*
16:39:08 <Twey> Gracenotes: What is Channel?
16:39:23 <Gracenotes> oh. heh. Chan
16:39:35 <Twey> Gracenotes: No, there's a isEmptyChan
16:39:47 <Twey> :: Chan -> IO Bool
16:39:50 <pumpkin> there's a writeChan?
16:39:52 <Twey> Er, Chan a
16:39:54 <pumpkin> @hoogle writeChan
16:39:55 <lambdabot> Control.Concurrent.Chan writeChan :: Chan a -> a -> IO ()
16:39:57 <Twey> pumpkin: Of course
16:39:58 <mmorrow> pumpkin: yes
16:40:00 <somnolence> I see
16:40:10 <mmorrow> pumpkin: check out the Control.Concurrent.Chan haddocks
16:40:21 <Twey> pumpkin: http://www.haskell.org/ghc/docs/6.8.3/html/libraries/base/Control-Concurrent-Chan.html
16:40:26 <pumpkin> thanks :)
16:40:58 <Gracenotes> oh. mm. so, nonBlockingRead c = if isEmptyChan c then Nothing else readChan c... or something like
16:41:06 <Gracenotes> subject to race conditions, unfortunately
16:41:13 <Twey> Gracenotes: Oh, and getChanContents
16:41:22 <mmorrow> and hold onto the ThreadId that spawnOnChan (or however you write it) returns from the forkIO call if you want to killThread the writer
16:41:28 <jfoutz> somnolence: it seems like, given your definition of factors, is prime should just test if the length of the list is 2
16:41:38 <Twey> Hmm, yes, it does seem to be
16:41:50 <Twey> Gracenotes: TChan has more advanced features, at the cost of some performance
16:42:02 <Twey> Gracenotes: http://www.haskell.org/ghc/docs/6.8.3/html/libraries/stm/Control-Concurrent-STM-TChan.html
16:42:04 <somnolence> in haskell can 1 be type Bool?
16:42:11 <mmorrow> a fairly large performance hit it seems too
16:42:29 <ozy`> somnolence: False
16:42:34 <bd_> somnolence: you could write a Num instance for Bool
16:42:34 <Twey> somnolence: 0
16:42:43 <Twey> mmorrow: Aye
16:42:44 <jfoutz> somnolence: isPrime 5 = 2 == (length $ (factors n))
16:42:45 <mmorrow> Gracenotes: you can solve that race though by having somthihng like (MVar (Chan a))
16:42:49 <Twey> What was it, 100%?
16:42:57 <jfoutz> :t (==)
16:42:58 <lambdabot> forall a. (Eq a) => a -> a -> Bool
16:43:00 <Gracenotes> mmorrow: hm. seems a little primative
16:43:02 <somnolence> k
16:43:04 <Gracenotes> *primitive
16:43:11 <Twey> Gracenotes: So wrap it
16:43:14 <Gracenotes> I wants mah high-level concurrency :)
16:43:22 <pumpkin> mmorrow, Twey: works beautifully, thanks :)
16:43:29 <Gracenotes> Does Haskell have compare-and-swap, by any chance?
16:43:30 <mmorrow> Gracenotes: well build your high level prims with MVars!
16:43:34 <Twey> pumpkin: Welcome :)
16:43:36 <Twey> Haha
16:43:38 <mmorrow> Chans are completely made of MVars
16:43:49 <mmorrow> @src Chan
16:43:49 <lambdabot> Source not found. I feel much better now.
16:43:56 <jfoutz> hehehe
16:44:15 <mmorrow> data Chan a
16:44:15 <mmorrow>  = Chan (MVar (Stream a))
16:44:15 <mmorrow>         (MVar (Stream a))
16:44:20 <mmorrow> type Stream a = MVar (ChItem a)
16:44:24 <mmorrow> data ChItem a = ChItem a (Stream a)
16:45:17 <Gracenotes> what kind of utility do MVars have in distributed computing?
16:45:30 <pumpkin> not much?
16:45:36 <Gracenotes> mmm... yeah
16:45:40 <mmorrow> what do you mean by that?
16:45:41 <Gracenotes> hm
16:45:41 <mpeter> leave
16:45:47 <pumpkin> if you mean physically distinct computers that is
16:45:56 <Gracenotes> yes.
16:46:00 <mmorrow> yeah, obviously they won't help you there :)
16:46:12 <jfoutz> somnolence: oh, duh. pfactors dosn't include 1 and the number. haha. null (pfactors n) should have worked
16:46:13 <pumpkin> they might help your communications thread talk to your worker thread :P
16:46:21 <pumpkin> assuming you work it that way
16:46:24 <Ralith> grah
16:46:34 <Ralith> where can I find a gtk2hs that works on ghc 6.10.1
16:46:38 <Ralith> darcs version dies with
16:46:44 <somnolence> jit doesn't work though because pfactors returns a type list?
16:46:45 <Ralith> gio/System/GIO/AsyncResult.chs:37:0: Failed to load interface for `System.GIO.Base':
16:46:46 <Gracenotes> hm. Does Erlang play nice with distributed systems, by chance?
16:47:02 <mmorrow> um
16:47:04 <pumpkin> Gracenotes: that's what its main purpose is
16:47:05 <Ralith> Gracenotes: isn't erlang *for* distributed systems?
16:47:12 <steven_ashley> Ralith: I got it working just yesterday, however not with that error {
16:47:19 <jfoutz> somnolence: no. not quite pfactors returns a list that you're putting in another list
16:47:19 <pumpkin> Gracenotes: and there's a hackage package that allows your haskell to act like an erlang node
16:47:25 <jfoutz> > []:[]
16:47:27 <lambdabot>   [[]]
16:47:30 <Gracenotes> ah. I knew it worked for multiple cores, but I wasn't so sure about distributed things.
16:47:34 <jfoutz> > null $ []:[]
16:47:36 <lambdabot>   False
16:47:47 <pumpkin> Gracenotes: on shared memory machines there are better things than erlang
16:47:55 <Ralith> steven_ashley: darcs version?
16:47:57 <jfoutz> somnolence: just don't do the (:[]) bit, and you're good.
16:48:00 <Gracenotes> mm.
16:48:12 <steven_ashley> Ralith: yep
16:48:14 <Gracenotes> the :[] monster D:
16:48:16 <somnolence> I get a parse error :(
16:48:33 <steven_ashley> ahh
16:48:33 <Ralith> steven_ashley: hm. Wanna tell me how to make darcs grab whatever revision you have?
16:48:58 <pumpkin> Cale: you around?
16:49:39 <steven_ashley> Ralith: Sorry, I don't really know how to use darcs :P My num patches is at 1861, "darcs show repo"
16:49:43 <pumpkin> or does anyone know how I might make the parMapM take an int parameter so that it only lets that many things happen concurrently?
16:49:50 <steven_ashley> Ralith: try running autoreconf
16:50:05 <somnolence> jfoutz: any idea why that would cause a parse error on the isPrime line?
16:50:12 * Gracenotes should perhaps study Erlang a tad
16:50:32 <pumpkin> Gracenotes: whatcha wanna distribute?
16:50:33 <steven_ashley> Ralith: then ./configure followed by make and make install
16:50:34 <Ralith> steven_ashley: did that when I checked out.
16:50:36 <jfoutz> somnolence: you're running in ghci and need a let?
16:50:41 <Ralith> how else would I build it? :P
16:50:48 <somnolence> jfoutz: no I'm :load(ing) into ghci
16:50:54 <somnolence> and don't need a let :)
16:50:58 <steven_ashley> Ralith: Well you can try without auto reconf and not get very far ;)
16:51:08 <Gracenotes> pumpkin: for now, just wondering. However, my school has a cluster, and it would be fun to let Haskell programs run wild on it.
16:51:08 <Ralith> steven_ashley: I pasted my error; it was obviously from the build process :P
16:51:14 <ksf> I'm just gonna do newtype Foo = Foo CUInt and add a couple of functions from Data.Bits.
16:51:16 <Gracenotes> (actually, several clusters)
16:51:26 <somnolence> jfoutz:null(pfactors n):[] fixes the parse error on the isPrime line causing one on the maximum line
16:51:57 <Gracenotes> concurrent algorithms are very interesting to me, except in the past I've always used them imperatively
16:52:17 <Gracenotes> and with a shared memory model
16:52:35 <h0tzenpl0tz> anybody still there?
16:52:36 <pumpkin> ideally you'd have both, I guess
16:52:40 <pumpkin> shared memory on each node
16:52:42 <Gracenotes> 'twould be interesting using functional+distributed
16:53:08 <steven_ashley> Ralith: I'm not sure other than that, sorry
16:53:15 <Ralith> steven_ashley: alright.
16:53:33 <Ralith> anybody got gtk2hs working on ghc 6.10?
16:53:39 <Gracenotes> pumpkin: well, I mean that everything is shared, easily. You could have one computer be the central brain, but its efficiency depends on the extent to which you can serialize tasks...
16:53:45 <h0tzenpl0tz> [0,1,0] -> replace every zero with a 2 and collect the possible single replacement-results.... -> [2,1,0] and [0,1,2]  whats the "pattern" to approach?
16:53:46 <jfoutz> > (\n -> let pfactors = filter (\x -> (n `mod` x) == 0) [2..n-1] in isPrime null pfactors)) 5
16:53:47 <lambdabot>   <no location info>: parse error on input `)'
16:53:56 <pumpkin> Gracenotes: yeah, I know
16:54:04 <jfoutz> somnolence: d'oh. no, it works in my ghc.
16:54:26 <jfoutz> > (\n -> let pfactors = filter (\x -> (n `mod` x) == 0) [2..n-1] in isPrime null pfactors) 5
16:54:26 <lambdabot>   Not in scope: `isPrime'
16:54:46 <somnolence> jfoutz: what is the 5 doing there?
16:54:51 <ksf> that's way to many lambdas.
16:55:07 <h0tzenpl0tz> any idea anyone?
16:55:21 <ksf> @pl (\n -> let pfactors = filter (\x -> (n `mod` x) == 0) [2..n-1] in isPrime null pfactors) 5
16:55:22 <lambdabot> isPrime null (filter ((0 ==) . (5 `mod`)) [2..4])
16:55:26 <ksf> that's better.
16:55:33 <h0tzenpl0tz> [0,1,0] ->  [ [X,1,0], [0,1,X] ] i dont get any approach...
16:56:15 <steven_ashley> h0tzenpl0tz: you might want to have a look at zippers
16:56:38 <mmorrow> what do you mean by "collect the possible single replacement-results"
16:56:39 <mmorrow> ?
16:56:54 <mmorrow> oh, i think i just understood
16:57:12 <h0tzenpl0tz> i want to replace the zeros with X, but only once and collect all replacements
16:57:26 <somnolence> jfoutz: where would I put that?
16:57:30 <h0tzenpl0tz> steven_ashley: isn't zipping to zip two lists into one using a fct?
16:58:09 <steven_ashley> yes, a zipper is something different, im googling for some info for you :P
16:58:28 <mmorrow> i'd in the first pass collect the indices of all the cells you want to replace, then in a second pass emit a replcacement for each of those collected indices
16:58:31 <h0tzenpl0tz> just reading zipWith ...
16:58:47 <mmorrow> hmm, that could be done in one pass
16:59:01 <steven_ashley> mmorrow: yep
16:59:18 <h0tzenpl0tz> mmorrow: thats my problem, i implemented it using pre and post accumulators but that is not haskellish
16:59:23 <dolio> data Context a = C [a] a [a]
16:59:58 <mmorrow> h0tzenpl0tz: some things the exiting pre-package higher order funcs can't handle, so you need to write a new one (using explicit recursion)
17:00:09 <mmorrow> s/exiting/existing/
17:00:43 <h0tzenpl0tz> mmorrow: yes but i dont get the fp-approach to this problem. im always ending with imperative style :(
17:00:44 <jfoutz> somnolence: sorry, that last example of mine was just confusing. if you take your pasted in code and remobe the :[] from line 3, you should be fine.
17:00:59 <pumpkin> mmorrow: do you have any idea on how to modify parMapM to only start n threads at a time?
17:01:23 <ksf> is there a way not to export instances?
17:01:24 <somnolence> jfoutz: try it yourself you will get a parse error on the isPrime line -.-
17:01:27 <steven_ashley> h0tzenpl0tz: You can write a toList, fromList, setValue and next function for dolio's Context data-type above. that should get you 90% there.
17:01:42 <mmorrow> , let go _ _ [] = []; go (from,to) xs (y:ys) | y==from = (xs++to:ys) : go (from,to) (y:xs) ys in go (0,2) [0,1,0]
17:01:43 <lunabot>  luna: No instance for (GHC.Show.Show ([t] -> [[t]]))
17:01:47 <mmorrow> , let go _ _ [] = []; go (from,to) xs (y:ys) | y==from = (xs++to:ys) : go (from,to) (y:xs) ys in go (0,2) [] [0,1,0]
17:01:49 <lunabot>  luna: <interactive>:1:54-140: Non-exhaustive patterns in function go
17:02:18 <mmorrow> , let go _ _ [] = []; go (from,to) xs (y:ys) | y==from = (xs++to:ys) : go (from,to) (y:xs) ys | otherwise = go (from,to) (y:xs) ys in go (0,2) [] [0,1,0]
17:02:20 <lunabot>  [[2,1,0],[1,0,2]]
17:02:30 <h0tzenpl0tz> uh
17:02:31 <mmorrow> oops
17:02:36 <ksf> somnolence, tab/space mixup?
17:02:46 <somnolence> ksf: I sincerely wish
17:02:48 <inforichland> cakeprophet: how's your project ?
17:03:02 <ksf> :set et
17:03:04 <ksf> :retab
17:03:15 <somnolence> ksf: http://rafb.net/p/8b6Fwz85.html
17:03:16 <Ralith> is cabal's soegtk == gtk2hs?
17:03:19 <somnolence> no tabs needed
17:03:24 <somnolence> no indents needed at all
17:03:34 <mmorrow> oh
17:03:45 <jfoutz> somnolence: hahaha, no your maximum line is busted.
17:03:46 <mmorrow> , let go _ _ [] = []; go (from,to) xs (y:ys) | y==from = reverse (xs++to:ys) : go (from,to) (y:xs) ys | otherwise = go (from,to) (y:xs) ys in go (0,2) [] [0,1,0]
17:03:47 <lunabot>  [[0,1,2],[2,0,1]]
17:03:51 <mmorrow> gah
17:03:55 <dolio> contexts :: [a] -> [Context a] ; contexts [] = [] ; contexts (x:xs) = go (C [] x xs) where go c = c : case c of (C l f []) -> [] ; (C l f (r:rs)) -> go (C (f:l) r rs)
17:04:04 <somnolence> jfoutz: :(
17:04:09 <mmorrow> , let go _ _ [] = []; go (from,to) xs (y:ys) | y==from = (reverse xs++to:ys) : go (from,to) (y:xs) ys | otherwise = go (from,to) (y:xs) ys in go (0,2) [] [0,1,0]
17:04:10 <lunabot>  [[2,1,0],[0,1,2]]
17:04:18 <h0tzenpl0tz> awesome, give me some minutes to study your codes
17:04:21 <mmorrow> , let go _ _ [] = []; go (from,to) xs (y:ys) | y==from = (reverse xs++to:ys) : go (from,to) (y:xs) ys | otherwise = go (from,to) (y:xs) ys in go (0,2) [] [0,1,0,0,0,1,0]
17:04:22 <lunabot>  [[2,1,0,0,0,1,0],[0,1,2,0,0,1,0],[0,1,0,2,0,1,0],[0,1,0,0,2,1,0],[0,1,0,0...
17:04:23 <dolio> focus :: Context a -> a ; focus (C _ a _) = a
17:04:26 <somnolence> jfoutz: sorry for my noobness but I don't suppose you could tell me an easy fix ? :O
17:04:35 <jfoutz> maybe maximum = filter ... instead of maximum . filter?
17:04:51 <dolio> whatever = filter ((== 0) . focus) . contexts
17:05:36 <somnolence> 1?
17:05:37 <somnolence> !?
17:06:03 <h0tzenpl0tz> mmorrow, dolio: thank you very much! i have to think about these approachs....
17:06:10 <ksf> i don't get a parse error if maximum is commented away or prepended by foo = ...
17:06:12 <mmorrow> np :)
17:06:40 <somnolence> i c
17:06:40 <mmorrow> <pumpkin> mmorrow: do you have any idea on how to modify parMapM to only start n threads at a time?
17:06:46 <mmorrow> just saw that, hmm
17:06:50 <Gracenotes> what's the next function for Context?
17:06:54 <Gracenotes> the type, at least?
17:07:01 <pumpkin> mmorrow: talking about the parMapM in http://74.125.47.132/search?q=cache:8uOvmBRNR38J:hpaste.org/1492+parMapM&hl=en&ct=clnk&cd=5&gl=us&client=safari
17:07:01 <mmorrow> pumpkin: remind me what parMapM is
17:07:04 <pumpkin> mmorrow: or anything similar :)
17:07:08 <mmorrow> heh, /me looks
17:07:12 <pumpkin> mmorrow: it's like parMap and mapM :P
17:07:18 <pumpkin> almost
17:07:31 <Gracenotes> next function, anyone? :X
17:07:33 <ksf> somnolence, if you had been writing signatures for your functions, ghc would have complained about a missing implementation...
17:07:54 <pumpkin> mmorrow: my issue is that my individual IOs are using a lot of memory
17:07:59 <pumpkin> and if I try to spawn them all at once
17:08:03 <pumpkin> it gets a little ridiculous
17:08:09 <pumpkin> so I'd like to only do two or three at a time
17:08:18 <mmorrow> pumpkin: do you require that the results come back in the same order as the original list? or do you want them in the order of completion?
17:08:30 <pumpkin> I honestly don't even need the results
17:08:36 <pumpkin> a parMapM_ would be just as good
17:08:45 <mmorrow> (because in the first case, if the first one takes a year and the others take a second, you'll have to wait a year)
17:08:54 <mmorrow> oh, nice. that'll simplify things
17:08:57 <pumpkin> mmorrow: they're pretty homogeneous
17:08:59 <Gracenotes> time for targeted interrogation... steven_ashley, what type would the next function for Context be? :)
17:09:19 <ksf> pumpkin, split the list into thunks of three and sequence the parmap over that.
17:09:42 <steven_ashley> Gracenotes: the next function to do what?
17:09:50 <mmorrow> pumpkin: i've got an idea, but i need to write it out (this'll be useful to me too). i'll get back to you
17:10:01 <Gracenotes> steven_ashley: I don't know. "You can write a toList, fromList, setValue and next function for dolio's Context data-type above"
17:10:04 <pumpkin> ksf: I was thinking of that, but I wanted it to start a new one as soon as any of the current three end
17:10:35 <pumpkin> mmorrow: thanks a lot :)
17:10:39 <Gracenotes> type signatures would be extremely useful
17:10:49 <dolio> next :: Context a -> Maybe (Context a)
17:11:05 <dolio> Although you could make a different choice.
17:11:12 <Gracenotes> -.-
17:11:27 <dolio> You could have it return "Context a" by not changing anything if it's 'at the end'.
17:11:32 <dolio> Or error out, but that's bad.
17:11:46 <Gracenotes> setValue :: Context a -> Int -> a -> Context a, right?
17:11:55 <Gracenotes> or without the Int?
17:11:59 <steven_ashley> without the int
17:12:01 <Gracenotes> yeah, the Int wouldn't make much sense.
17:12:01 <dolio> setValue :: Context a -> a -> Context a
17:12:34 <somnolence> ksf: is this what you meant? http://rafb.net/p/TxcXji12.html
17:12:46 * ksf wants a Num a with only fromInteger
17:13:15 <ksf> yeah.
17:13:20 * gwern wants a Num too. with fries
17:13:20 <Gracenotes> and you'd want to collect all the occurrences where getValue == 0, using toList, I'd imagine
17:13:25 <somnolence> I got the error
17:13:31 <ksf> add a few type signatures to clear things up.
17:13:32 <somnolence> in the comments from that >_<
17:13:54 <ksf> usually, adding them makes ghc point you directly to the error.
17:13:54 <somnolence> >_< k
17:14:18 <steven_ashley> Gracenotes: yes, you want a list of contexts where getValue == 0, then you can call setValue 2 and toList on all of them
17:14:19 <Gracenotes> Wikibooks had a good article on zippers I should re-read
17:15:11 <ksf> (and (\x -> (n `mod x) == 0) is ((==0) . (n `mod))
17:15:59 <monochrom> ksf: add lots of parentheses to your "maximum . ..." line to make sure there is no misunderstanding between you and computer.
17:16:01 <ksf> *(n `mod`))
17:16:15 <somnolence> I don't understand how I write the type signature for isPrime n = null(pfactors n)
17:16:17 <monochrom> All parse errors are misunderstandings on the human's part.
17:16:24 <somnolence> it takes an Int [a]
17:16:29 <somnolence> and returns a Bool a...
17:16:45 <ozy`> ksf: it'd be nice to be able to use a single backtick, but alas....
17:16:51 <ksf> isPrime :: Int -> Bool
17:16:52 <wli> somnolence: isPrime :: Integer -> Bool
17:17:03 <ksf> or, wait, [Int]
17:17:13 <ksf> nope.
17:17:15 <ksf> the former.
17:19:06 <wli> somnolence: Try isPrime n = not $ any (\k -> n `mod` k == 0) (takeWhile (\k -> k*k <= n) [2..])
17:19:37 <Gracenotes> collectAll ctxt list = maybe list (\nxt -> let nxt' = collectAll nxt list in if getValue ctxt==0 then toList ctxt:nxt' else nxt') (next ctxt)
17:19:45 <Gracenotes> ...something like. I should think. :/
17:19:58 <monochrom> Oh is somnolence rather than ksf the original anonymous poster?
17:20:11 <monochrom> somnolence: add lots of parentheses to your "maximum . ..." line to make sure there is no misunderstanding between you and computer.
17:20:15 <Ralith> grah.
17:20:30 <ksf> yeah, but the "foo" is mine.
17:20:31 <Ralith> surely somebody other than me has tried to make gtk2hs run on ghc 6.10.1
17:20:32 <ozy`> wli: that desperately needs to be memoized if it's called more than once.
17:20:38 <ksf> ralith, yes.
17:20:41 <Gracenotes> oh, wait.
17:20:46 <Ralith> ksf: is there a way?
17:20:53 <ksf> there might be.
17:20:56 <Ralith> :P
17:21:00 <Gracenotes> I should be append to list, not to the result of the collectAll call
17:21:08 <Ralith> well failing that
17:21:20 <Ralith> what's a simple way to take a darcs repo back a few revisions?
17:21:24 <ksf> ...I decided to write agar bindings instead.
17:21:49 <wli> ozy`: Nah, different algorithms altogether should be used.
17:22:04 <ozy`> wli: ideally, but..... eh. blah.
17:22:15 <Gracenotes> collectAll ctxt list = maybe list (\nxt -> let list' = if getValue ctxt==0 then toList $ setValue 2 ctxt:list else list in collectAll nxt list') (next ctxt)
17:22:23 <ozy`> is there a primes library in Base? (there ought to be.)
17:22:30 <wli> ozy`: poke around hpaste.org for various bits of Eratosthenes code I've written based on the JFP paper.
17:22:54 <ztirF> wait a minute
17:23:07 <Gracenotes> Is there a good shorthand for if <bool> then x:list else list?
17:23:08 <ztirF> there has to be a better way to find what bin a value belongs in in a histogram
17:23:13 <ztirF> than binary search
17:23:39 <Peaker> ztirF: what's wrong with O(log N) search?
17:23:41 <Gracenotes> hm. >_>
17:23:44 <somnolence> what's the type signature for an Int to an [Int] Int ->[Int] doesn't work mentions inferred type [a] :(????
17:23:49 <monochrom> binary search is still not good enough? do you want quadratic search instead?
17:24:03 <Peaker> somnolence: paste your code
17:24:07 <ksf> there's no such thing as a [Int] Int
17:24:11 <wli> How the heck do I search hpaste.org? google isn't turning things up.
17:24:31 <somnolence> http://rafb.net/p/hRz2uM23.html
17:24:47 <monochrom> Int -> [Int] is the type signature you have in mind. If the compiler rejects it, it is because your code does not conform.
17:24:48 <ztirF> Peaker: well, with a 2D histogram with 100^2 bins, and 10000 points, it takes a minute to generate
17:25:03 <Peaker> ztirF: a minute to binary search?
17:25:10 <Peaker> ztirF: are you by any chance "binary-searching" on lists?
17:25:11 <pumpkin> must be epicly large
17:25:18 * ksf needs to reset his english parser
17:25:31 <pumpkin> ksf: never seen the epicly adverb? :o
17:25:50 <ztirF> Peaker: it takes 1min to histogram 10000 points into 100^2 bins
17:26:01 <monochrom> wli: "site:hpaste.org monochrom" works for me.
17:26:10 <Peaker> ztirF: what data structure do you use for the bins?
17:26:35 <ztirF> UArray Ind Int where Ind is (Int,Int) in this case
17:26:46 <pumpkin> ztirF: to histogram 10k points into 10k bins?
17:26:46 <somnolence> peaker: do you know what the type signature for factors would be?
17:27:16 <ztirF> pumpkin: yes
17:27:17 <pumpkin> ztirF: are you generating those points randomly? the random generators can be pretty slow :P
17:27:30 <pumpkin> ztirF: I'd use an IntMap, btw
17:27:33 <pumpkin> for your histogram
17:27:36 <ztirF> pumpkin: yes I am...actually that means laziness might be biting me
17:27:49 <Peaker> @type mod
17:27:50 <lambdabot> forall a. (Integral a) => a -> a -> a
17:28:01 <ksf> factors :: Integral a => a -> [a]
17:28:12 <Peaker> somnolence: seems like: Integral a => a->[a]
17:28:18 <pumpkin> lol
17:28:18 <steven_ashley> is anyone aware of a build-in for (a -> Maybe a) -> [a] ? Kind of like iterate but have it terminate on Nothing
17:28:21 <somnolence> lol ok
17:28:37 <Peaker> steven_ashley: mapM?
17:28:40 <Peaker> @type mapM
17:28:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
17:28:55 <Peaker> > mapM [Just 5, Just 6]
17:28:57 <lambdabot>   Couldn't match expected type `a -> m b'
17:28:57 <pumpkin> ahh, the beauty of monads
17:29:03 <steven_ashley> Peaker: the result from the maybe, is fed back into the function.
17:29:04 <dolio> @type \f -> unfoldr (fmap (join (,)) . f)
17:29:05 <lambdabot> forall a. (a -> Maybe a) -> a -> [a]
17:29:08 <Peaker> > mapM Just [5,6]
17:29:10 <lambdabot>   Just [5,6]
17:29:14 <monochrom> somnolence: How should I parse "maximum . filter isPrime $ factors [1..600851475143]"?  Should I parse it as "(maximum . filter isPrime) $ factors [1..600851475143]"?
17:29:16 <Olathe> @hoogle (a -> Maybe b) -> [a] -> [b]
17:29:17 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
17:29:17 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
17:29:17 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
17:29:18 <Peaker> > mapM id [Just 5,Nothing]
17:29:19 <lambdabot>   Nothing
17:29:22 <steven_ashley> Peaker: and a list of results is returned
17:29:35 * wli watches hpaste.org be down right when he needs to look.
17:29:46 <Olathe> > mapMaybe (\x -> if x < 5 then Nothing else Just x) [1..10]
17:29:47 <lambdabot>   [5,6,7,8,9,10]
17:29:49 <pumpkin> wli: I've been using google cache on it with pretty decent success
17:29:49 <Peaker> steven_ashley: why a list of a's then?
17:29:53 <dolio> > (\f -> unfoldr (fmap (join (,)) . f)) (\x -> if x < 10 then Just (x+1) else Nothing) 0
17:29:54 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
17:29:57 <somnolence> monochrom: It's written correctly I don't understand your question.
17:30:04 <Olathe> So, it looks like mapMaybe.
17:30:14 <monochrom> Clearly the compiler thinks it is not written correctly.
17:30:33 <wli> It's also not turning up much more recent revisions.
17:30:44 <somnolence> I don't understand why I need type signatures the result is the same...
17:30:50 <pumpkin> steven_ashley: sounds like you want a takeWhile?
17:30:59 <pumpkin> steven_ashley: where it stops on a Nothing instead of a False
17:31:00 <somnolence> <ksf> factors :: Integral a => a -> [a]
17:31:03 <steven_ashley> pumpkin: yeah, its just a pain to write it each time
17:31:08 <monochrom> Without type signatures the compiler is still rejecting your code.
17:31:10 <somnolence> Couldn't match expected type `Int' against inferred type `[a]'
17:31:16 <ksf> ...so you understand what you did. which is the cure for every type error i came across.
17:31:18 <pumpkin> steven_ashley: takeWhile (isNothing . f) ?
17:31:29 <pumpkin> or ratehr
17:31:30 <pumpkin> isJust
17:31:39 <somnolence> for a good reason the original problem I was having factors returns a list
17:31:51 <Gracenotes> > let foldMaybe f z (Just x:xs) = foldMaybe f (f z x) xs; foldMaybe f z l = z in foldMaybe (+) 0 [Just 1, Just 2, Just 3, Nothing, Just 4]
17:31:53 <lambdabot>   6
17:32:00 <somnolence> and I don't see how I can convert that cleanly to a bool it keeps giving me type/parse errors
17:32:21 <Olathe> somnolence: What are you converting to a Bool ?
17:32:27 <Peaker> steven_ashley: You say the a feeds back into the function, but your function is to (m b) not (m a), can you clarify?
17:32:28 <dolio> > (\f -> unfoldr (liftM2 fmap (,) f)) (\x -> if x < 10 then Just (x+1) else Nothing) 0
17:32:29 <ztirF> pumpkin: is IntMap's insertWith (+) really more efficient than accumArray (+)
17:32:29 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
17:32:53 <somnolence> I'm trying to run null(factors n)
17:32:53 <monochrom> I don't believe "factors [1..whatever]" makes sense.
17:32:56 <somnolence> which should be null(list)
17:33:08 <Peaker> Gracenotes: why not use sequence and then a normal fold?
17:33:17 <Gracenotes> Peaker: I'
17:33:19 <Gracenotes> er
17:33:19 <pumpkin> ztirF: not sure, try both?
17:33:29 <Gracenotes> I'm working my way up to a different function, actually
17:33:31 <pumpkin> @source Data.IArray
17:33:32 <lambdabot> Data.IArray not available
17:33:35 <Olathe> somnolence: Well, if it's not a list, I'd say you should keep working on factors rather than that.
17:34:05 <monochrom> @let factors n = filter (\x -> (n `mod` x) == 0) [1..n]
17:34:06 <lambdabot>  Defined.
17:34:09 <somnolence> it is a list...
17:34:13 <Gracenotes> Peaker: plus, the function would be totally obliterated if there was a Nothing, right?
17:34:13 <Peaker> > let foldMaybe f g = foldr f g . sequence in foldMaybe (+) 0 [Just 1, Just 2, Just 3]
17:34:14 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Maybe t'
17:34:15 <monochrom> > L.factors 60
17:34:17 <lambdabot>   [1,2,3,4,5,6,10,12,15,20,30,60]
17:34:24 <monochrom> > L.factors [1..60]
17:34:28 <lambdabot>       No instance for (Integral [t])
17:34:28 <lambdabot>        arising from a use of `factors' a...
17:34:29 <pumpkin> somnolence: you might want to return factors as a list of pairs, with the prime as fst, and the exponent (for repeated factors) as snd?
17:34:33 <Gracenotes> Peaker the idea is to stop folding when a Nothing is reached
17:34:42 <monochrom> That is a problem.
17:34:42 <Gracenotes> not kill the result
17:34:50 <Peaker> Gracenotes: that will happen with sequence and then a normal foldr
17:35:01 <Peaker> Gracenotes: sequence will "stop" then
17:35:32 <Gracenotes> mm
17:35:34 <ski_> > foldr (:) [] . sequence $ [Just 0, Just 1, Just 2, Nothing, Just 3]
17:35:35 <lambdabot>   Couldn't match expected type `[]' against inferred type `Maybe'
17:35:45 <Olathe> > let prime n = null.tail.tail.factors in prime 7
17:35:46 <lambdabot>       Overlapping instances for Show (a -> Bool)
17:35:46 <lambdabot>        arising from a use of...
17:35:49 <ski_> > fmap (foldr (:) []) . sequence $ [Just 0, Just 1, Just 2, Nothing, Just 3]
17:35:50 <lambdabot>   Nothing
17:35:55 <Olathe> > let prime = null.tail.tail.factors in prime 7
17:35:57 <lambdabot>   True
17:36:03 <Olathe> > let prime = null.tail.tail.factors in prime 50
17:36:04 <lambdabot>   False
17:36:07 <Peaker> > let foldMaybe f g = fmap (foldr f g) . sequence in foldMaybe (+) 0 [Just 1, Just 2, Just 3]
17:36:09 <lambdabot>   Just 6
17:36:14 <Peaker> > let foldMaybe f g = fmap (foldr f g) . sequence in foldMaybe (+) 0 [Just 1, Nothing, Just 3]
17:36:16 <lambdabot>   Nothing
17:36:19 <ski_> Peaker : `sequence' will give `Nothing' whenever there's any `Nothing' in the list
17:36:23 <somnolence> pumpkin: it's returning a list so far as I can tell it should work I honestly don't know wtf is wrong people have been telling me to add type signatures, it's not helping here is pastebin so far:http://rafb.net/p/vjY3SI66.html
17:36:43 <Peaker> ski_, Gracenotes: Oh, sorry, I missed that
17:36:48 <Peaker> Gracenotes: by "stop" you means use the result till then
17:36:52 <Peaker> meant
17:36:56 <Gracenotes> yep.
17:37:08 <pumpkin> somnolence: what's your problem then?
17:37:20 <pumpkin> somnolence: apart from your technique being woefully inadequate for a number that large :P
17:37:20 <Twey> Peaker: Use mplus
17:37:22 <Gracenotes> except, I ended up solving the wrong problem :) right now I'm trying to implement (a -> Maybe a) -> a -> a
17:37:23 <somnolence> pumpkin: I'm getting a syntax error and a type mismatch
17:37:42 <pumpkin> somnolence: can I see the actual error?
17:37:43 <somnolence> pumpkin: I was using the fermat function then someone suggested I take this approach, now I have syntax errors instead of logic errors which make no sense
17:37:45 <ski_> @djinn (a -> Maybe a) -> a -> a
17:37:46 <lambdabot> f a b =
17:37:46 <lambdabot>     case a b of
17:37:46 <lambdabot>     Nothing -> b
17:37:46 <lambdabot>     Just c -> c
17:37:55 <somnolence>     Couldn't match expected type `Int' against inferred type `[a]'
17:37:55 <somnolence>     In the first argument of `factors', namely `[1 .. 600851475143]'
17:37:55 <somnolence>     In the second argument of `($)', namely
17:37:55 <somnolence>         `factors ([1 .. 600851475143])'
17:37:56 <somnolence>     In the expression:
17:37:58 <somnolence>             maximum . filter isPrime $ factors ([1 .. 600851475143])
17:38:00 <somnolence> Failed, modules loaded: none.
17:38:02 <somnolence> in your pm
17:38:02 <Twey> Oh, but then it won't stop.  Hmm.
17:38:08 <monochrom> somnolence: "factors [1..whatever]" does not make sense. And I don't mean doesn't not make sense to me. I mean does not make Haskell sense.
17:38:08 <Gracenotes> ski_: see, a bit of a problem
17:38:11 <Gracenotes> a isn't used at all
17:38:14 <pumpkin> somnolence: you pasted it in the channel :P
17:38:17 <pumpkin> somnolence: but thanks
17:38:18 <Olathe> somnolence: Does isPrime work by itself ?
17:38:24 <Gracenotes> ski_ because djinn doesn't have to use it
17:38:25 <ski_> Gracenotes : huh ?
17:38:39 <somnolence> lol
17:38:43 <somnolence> *smooth*
17:38:47 <Gracenotes> oh, wait. :/ damn noise, confusing me.
17:38:54 <somnolence> sorry people
17:38:59 <ddarius> Gracenotes: I believe djinn always tries to use variables exactly once if possible.
17:39:05 <monochrom> somnolence: Try L.factors [1..60] right here with lambdabot. Here it is:
17:39:11 <monochrom> > L.factors [1..60]
17:39:12 <lambdabot>       No instance for (Integral [t])
17:39:12 <lambdabot>        arising from a use of `factors' a...
17:39:22 <monochrom> L.factors is straight copy of your factors code.
17:39:26 <steven_ashley> > let foo f = catMaybes . takeWhile isJust . iterate (f . fromJust) . Just in foo (\x-> if x < 10 then Just (x+1) else Nothing) 0
17:39:27 <Gracenotes> ddarius: yeah, sorry about assuming that. The idea is to keep applying the first argument until a Nothing is reached.
17:39:28 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10]
17:39:32 <MyCatVerbs> somnolence: don't you just want to change wtf to say wtf = maximum . filter isPrime $ factors [1..600851475143]
17:39:32 <somnolence> monchrom: see filter?
17:39:32 <pumpkin> > L.factors 60
17:39:34 <lambdabot>   [1,2,3,4,5,6,10,12,15,20,30,60]
17:39:41 <Gracenotes> argh. noise X_X
17:39:53 <somnolence> MyCatVerbs: that is what my code is
17:39:57 <MyCatVerbs> somnolence: ah, crap, sorry. I mean, don't you just want to change wtf to say wtf = maximum . filter isPrime $ factors 600851475143
17:40:00 <Olathe> How about filter isPrime [1..600]
17:40:08 <pumpkin> somnolence: even if you fix it, you'll be waiting several decades for it to run
17:40:17 <Olathe> Heheh
17:40:18 <Gracenotes> oh, wait... can't unfoldr be used for that?
17:40:30 <dolio> steven_ashley: Mine's shorter. :)
17:40:33 <Gracenotes> no, that's not what I want. argh.
17:40:36 <MyCatVerbs> somnolence: I meant to paste into the edit box, but I pasted a line ending on the end as well, causing my IRC client to send it straight away.
17:40:37 <dolio> And does fewer list traversals. :)
17:40:39 <somnolence> pumpkin: so basically I have to go back to fermat abandon this and the time I spent trying to fix this :(
17:40:43 <pumpkin> Gracenotes: unfoldr is all-powerful!
17:40:47 <steven_ashley> where is yours :P?
17:40:55 <ztirF> pumpkin: ok wow, nevermind - it was all generating the random sample
17:41:06 <pumpkin> somnolence: well, figure out what's wrong then abandon it :) your haskell-fu will go up, but your math-fu still needs work :P
17:41:13 <pumpkin> ztirF: yay :)
17:41:14 <steven_ashley> I see
17:41:19 <steven_ashley> dolio: your nuts ;)
17:41:24 <pumpkin> ztirF: did you compare the accumArray and fromListWith?
17:41:26 <pumpkin> on IntMap
17:41:26 <dolio> > let foo = unfoldr . liftM2 fmap (,) in foo (\x -> if x < 1 then Just (x+1) else Nothing)
17:41:27 <lambdabot>       Overlapping instances for Show (a -> [a])
17:41:27 <lambdabot>        arising from a use of ...
17:41:31 <pumpkin> steven_ashley: be polite!
17:41:45 <dolio> > let foo = unfoldr . liftM2 fmap (,) in foo (\x -> if x < 1 then Just (x+1) else Nothing) 0
17:41:47 <lambdabot>   [0]
17:41:48 <steven_ashley> pumpkin: in a good way of course ;)
17:41:49 <steven_ashley> :)
17:41:50 <Olathe> somnolence: I'd recommend not writing an entire complex chain of function calls.
17:41:53 <pumpkin> steven_ashley: what about his nuts?
17:42:03 <dolio> > let foo = unfoldr . liftM2 fmap (,) in foo (\x -> if x < 10 then Just (x+1) else Nothing) 0
17:42:04 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
17:42:07 <MyCatVerbs> somnolence: That code was giving you a type error because you were applying the function "factors" to a list of integers, when you wrote "factors" to take only a single integer as a parameter, rather than a list.
17:42:11 <Olathe> somnolence: First, get the first function working, then the second, then the third, etc.
17:42:12 <ztirF> pumpkin: no - but if I forced evaluation of the sample by printing the sum, then it took almost no time after that to generate the histogram
17:42:34 <Gracenotes> dolio: yes, I
17:42:37 <somnolence> bahh
17:42:41 <Gracenotes> er, I'm pretty sure that's what I was thinking of
17:42:45 <Olathe> somnolence: Like, you have ...... $ factors [1..600....]
17:42:47 <pumpkin> ztirF: ah cool :) anyway, check out IntMap, it's neat for many things, and if you have histograms with large numbers of bins it'll be more efficient than an array
17:42:48 <Gracenotes> :t unfoldr . liftM2 fmap (,)
17:42:49 <lambdabot> forall a. (a -> Maybe a) -> a -> [a]
17:42:52 <Olathe> somnolence: Does that part to the right of $ work ?
17:42:54 <somnolence> and pumpkin
17:42:56 <pumpkin> ztirF: assuming you don't have full coverage
17:42:58 <Gracenotes> hm, maybe not.
17:43:19 <somnolence> as I said I implemented the fermat primality test unfortunately this requires a PRNG which requres Monad Random type
17:43:31 <Gracenotes> instead of returning all the results, which I'm not interested in, I'd like the last result before it stops
17:43:32 <pumpkin> somnolence: is this for euler?
17:43:32 <ztirF> pumpkin: will do, thanks.  Now I have to try to make generating that sample faster...
17:43:36 <somnolence> which means you have to pass do statements down(to my one day of knowledge)
17:43:45 <somnolence> pumpkin: yes
17:43:51 <Gracenotes> I could just use last, I suppose, but constructing a huge list just to get the last element seems a bit silly
17:44:09 <somnolence> pumpkin: but I'll go find my old code and try to get the control code to work the primality test was fine :(
17:44:09 <dolio> @type until
17:44:11 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
17:44:44 <Gracenotes> unfortunately, that doesn't unwrap the Just a for the next iteration
17:44:54 <chessguy> @type untilM
17:44:55 <lambdabot> Not in scope: `untilM'
17:45:01 <ksf> somnolence, the Random interface can give you an infinite list of numbers.
17:45:15 <chessguy> @hoogle untilM
17:45:15 <lambdabot> No results found
17:45:19 <chessguy> hmph
17:45:35 <anthonymiller> @hoogle writeFile
17:45:35 <lambdabot> Prelude writeFile :: FilePath -> String -> IO ()
17:45:35 <lambdabot> Data.ByteString writeFile :: FilePath -> ByteString -> IO ()
17:45:35 <lambdabot> System.IO writeFile :: FilePath -> String -> IO ()
17:45:59 <dolio> @type \f -> until (isNothing . f) (f . fromJust) . Just
17:46:00 <lambdabot>     Occurs check: cannot construct the infinite type: a = Maybe a
17:46:00 <lambdabot>       Expected type: Maybe a -> Maybe a
17:46:00 <lambdabot>       Inferred type: Maybe a -> a
17:46:47 <pumpkin> mmorrow: no need to spend much time on it if it's a pain!
17:47:13 <anthonymiller> @hoogle openFile
17:47:14 <lambdabot> System.IO openFile :: FilePath -> IOMode -> IO Handle
17:47:17 <Peaker> @type until
17:47:19 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
17:47:32 <Gracenotes> > let untilNothing f a = maybe a (untilNothing f) (f a) in untilNothing (\x -> if (x<10) then Just (x+1) else Nothing) 0
17:47:33 <lambdabot>   10
17:47:37 <somnolence> ksf: I heard that yesterday unfortunately I have no idea how to implement that at this time.
17:47:40 <Gracenotes> hm... that works
17:48:04 <augustss> Hah!  LLVM beats the crap out of ghc. :)
17:48:13 <pumpkin> augustss: :o
17:48:19 <Gracenotes> finally, a useful utility function for crawling through Contexts :D
17:48:26 <pumpkin> surely it's impossible to beat the crap out of the most advanced compiler in the world?!?!
17:48:44 <Gracenotes> one would hope, anyway :/ Now for some results-collecting utility...
17:48:58 <augustss> pumpkin: I just blogged about my little experiment.  8 times faster on computing Black-Scholes.
17:49:17 <Peaker> Gracenotes: why not  map fromJust . takeWhile (/=Nothing)  ?
17:50:22 <Gracenotes> Peaker: you don't have an initial list. You have an initial argument, to which you repeatedly apply a function, until the function yields Nothing
17:50:35 <BONUS> /=Nothing forxes an Eq context though
17:50:38 <steven_ashley> :t iterate
17:50:39 <Gracenotes> lists aren't really involved at all.
17:50:39 <lambdabot> forall a. (a -> a) -> a -> [a]
17:50:43 <MyCatVerbs> somnolence: hang on, I'll pastebin something you might even find useful.
17:50:46 <Peaker> BONUS: yeah, not . isNothing
17:50:47 <Gracenotes> and isNothing works too
17:50:53 <chessguy> is there something simpler than, but isomorphic to, "data Foo = Yes String | No String" ?
17:51:05 <pumpkin> augustss: looks awesome
17:51:07 <BONUS> Either?
17:51:13 <Peaker> @type \f -> takeWhile (not . isNothing) . iterate f
17:51:15 <lambdabot> forall a. (Maybe a -> Maybe a) -> Maybe a -> [Maybe a]
17:51:25 <chessguy> oh, good call
17:51:26 <steven_ashley> chessguy: Either String String ?
17:51:30 <steven_ashley> ops :P
17:51:31 <Peaker> Gracenotes: what was your type again?
17:51:38 <Gracenotes> (Maybe a -> a) -> a -> a
17:51:42 <mmorrow> pumpkin: heh, this is actually not that straightforward, but here's a first go that i suspect to not work correctly, but i'm not sure yet if that's my fault or the scheduler tricking me (also, i think QSem might make this simple): http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=822#a822
17:51:43 <ski_> chessguy : `(Bool,String)' ?
17:51:47 <pumpkin> Peaker: there's an isJust too
17:52:05 <Peaker> Gracenotes: not (a -> Maybe a) ?
17:52:07 <mmorrow> pumpkin: going to eat now, but now i'm determined to get this to work a little later ;)
17:52:16 <pumpkin> mmorrow: yay, thank you so much :) I'll give it a go
17:52:36 <Gracenotes> Peaker: er, you're right. I have tendency to occasionally confuse things off-the-cuff
17:52:45 <mmorrow> i've only come up with one test so far, which seemingly says that it doesn't work
17:53:00 <mmorrow> but the test is using threadDelays and might be lying to me
17:53:18 <pumpkin> ah okay :)
17:53:32 <Peaker> Gracenotes: hard to compose this nicely, indeed
17:53:44 <Peaker> @djinn (a -> Maybe a) -> a -> a
17:53:45 <lambdabot> f a b =
17:53:45 <lambdabot>     case a b of
17:53:45 <lambdabot>     Nothing -> b
17:53:45 <lambdabot>     Just c -> c
17:54:04 <Gracenotes> a correct results, but not the correct one, it seems
17:54:07 <Peaker> @djinn (a -> Maybe a) -> a -> [a]
17:54:08 <lambdabot> Error: Undefined type []
17:54:13 <Peaker> Gracenotes: you want the list, right?
17:54:14 <somnolence> for pumpkin this is the code I was trying to use earlier but the test3 function's logic is broken in a way I can't determine : http://rafb.net/p/CgQcVu37.html
17:54:20 <mmorrow> pumpkin: here's the test i tried http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=822#a823
17:54:28 <Gracenotes> Peaker: just the last result before Nothing
17:54:37 <Peaker> Gracenotes: ah
17:54:46 <steven_ashley> Gracenotes: are you sure about that?
17:54:51 * ksf is testing wits with the type checker
17:54:57 <Gracenotes> so one could do last . f, f :: (a -> Maybe a) -> a -> [a].
17:55:06 <Gracenotes> although that needlessly involves lists
17:55:07 <steven_ashley> Gracenotes: if you have the list you can apply a function to each context easily
17:55:10 <MyCatVerbs> somnolence: here's a Fermat, using System.Random: http://rafb.net/p/H0GI1268.html
17:55:11 <Peaker> > let pp = flip mplus in Just 5 `pp` Nothing
17:55:12 <lambdabot>   Just 5
17:55:16 <ksf> can I unbox the Bar of newtype Foo = Foo Bar via a typeclass?
17:55:16 <Peaker> > let pp = flip mplus in Just 5 `pp` Just 6
17:55:18 <somnolence> mycatverbs
17:55:18 <lambdabot>   Just 6
17:55:24 <Peaker> Gracenotes: flip mplus could be nice then
17:55:36 <somnolence> I'm sorry this might sound rude: but I said I already implemented it and just linked a pastebin of it's implementation :(
17:55:49 <MyCatVerbs> somnolence: oh. I wasn't looking at the channel. ^^
17:55:53 <somnolence> np
17:56:00 <Gracenotes> steven_ashley: hm, true. Although, I've come across the situation of needing an (a -> Maybe a) -> a -> a before
17:56:09 <steven_ashley> ahh sure
17:56:10 <Gracenotes> it's very convenient in single-step evaluators
17:56:37 <Gracenotes> e.g., maybe board eliminateLines (liftM (eliminateLine board) (findFilledLine board))
17:56:44 <Gracenotes> which eliminates lines in Tetris, one-by-one
17:56:44 <somnolence> mycatverbs: if you can see the logical flaw in my test3 function I would greatly appreciate it however let me re-pastebin it there's a slight glitch right now
17:56:55 <steven_ashley> yep, myself also, i'm surprised those sorts of functions aren't in Data.Maybe to be honest :P
17:57:06 <mmorrow> pumpkin: yeah, i think that isn't working. don't see why atm, but bbl
17:57:11 <ztirF> how do I install the profiling libraries for packages I've installed via cabal?
17:57:45 <Peaker> > let gn f i = case (f i) of Nothing -> i ; Just x -> gn f x in gn (\x -> if x < 10 then Just (x*2) else Nothing) 1
17:57:47 <lambdabot>   16
17:57:53 <somnolence> MyCatVerbs: http://rafb.net/p/0uhoLI70.html
17:57:59 <Gracenotes> ooh. nice
17:58:08 <somnolence> if you can take a look at it, I am not sqrting the prime because that introduces a Float type
17:58:13 <Peaker> now how to PL: gn f i = case f i of Nothing -> i ; Just x -> gn f x
17:58:52 <dolio> @type \f -> until (isNothing . (>>= f)) (>>= f) . Just
17:58:53 <lambdabot> forall a. (a -> Maybe a) -> a -> Maybe a
17:58:56 <ksf> ztirF, look at your .cabal/config
17:59:08 <Peaker> @type until
17:59:09 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
17:59:19 <Gracenotes> steven_ashley: but, you mean: getting the list of contexts, then filtering ones where the value == 0, then setting their value to 2 and toList-ing them, right?
18:00:04 <ksf> somnolence, there's newton's method for integer sqrt somewhere in the haskell wiki.
18:00:25 <somnolence> ksf: thanks I'll check it out
18:00:36 <monochrom> > floor (sqrt (fromIntegral (45 :: Int))) :: Int
18:00:38 <lambdabot>   6
18:00:46 <ksf> monochom, that's evil.
18:01:07 <monochrom> It uses newton's method for sqrt in hardware
18:01:10 <Gracenotes> it is often inconvenient to use floor and sqrt
18:01:11 <ksf> besides being incorrect in a couple of cases, it doesn't work for large numbers.
18:01:44 <MyCatVerbs> somnolence: (a > sqrt(b)) == ((a*a) > b), is the other way to work without sqrt.
18:02:43 <Gracenotes> > filter ((==0) . flip mod 2) [1..floor $ sqrt 111]
18:02:44 <lambdabot>   [2,4,6,8,10]
18:02:46 <MyCatVerbs> somnolence: also, why have fermat n k return 1 or 0 instead of True or False?
18:02:52 <Gracenotes> ...hm, that works :\
18:03:33 <somnolence> MyCatVerbs: No particular reason I can change it if it makes you happy =P
18:04:06 <ksf> @check \n -> let rt = floor (sqrt (fromIntegral n)) in rt*rt == n
18:04:07 <lambdabot>   "Falsifiable, after 1 tests:\n-2\n"
18:04:15 <ksf> gragh.
18:04:16 <MyCatVerbs> somnolence: you know the thing you pastebinned me ends with "main = do x <- test3 (600851475143 `div` 2) 600851475143;print(show(x :: Int))"? Unless you're on a 64-bit CPU and OS, Int doesn't have enough precision to store some of those numbers. Use Integer instead.
18:04:21 <ksf> Nat, anyone?
18:04:28 <Peaker> > let gn f = fix (\x -> (x>>=f) `mplus` x) in gn (\x -> if x < 10 then Just (x*2) else Nothing) 1
18:04:30 <lambdabot>   Couldn't match expected type `t1 -> t'
18:04:44 <Botje> ksf: Word?
18:04:48 <pumpkin> Peaker: couldn't you use a guard in the lambda?
18:04:53 <ksf> @check \n -> let rt = floor (sqrt (fromIntegral n)) in rt*rt == n
18:04:55 <lambdabot>   "Falsifiable, after 2 tests:\n-2\n"
18:04:57 <Peaker> pumpkin: I'm not a guardy person
18:05:02 <pumpkin> aw
18:05:16 <ksf> @check \n -> let rt = floor (sqrt (fromIntegral n)) in rt*rt == n `and` n > 0
18:05:17 <lambdabot>       precedence parsing error
18:05:17 <lambdabot>          cannot mix `(==)' [infix 4] and `(>)'...
18:05:26 <monochrom> ksf: Use the condition n<=0 || rt*rt == n
18:05:33 <monochrom> perhaps n<0
18:05:34 <Peaker> @type let gn f = fix (\x -> (x>>=f) `mplus` x) in gn
18:05:35 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => (a -> m a) -> m a
18:05:43 <MyCatVerbs> somnolence: in fact, if you're working on numbers that might be large enough to be interesting, you should always be using Integers instead. Integer is arbitrarily-large (it's implemented using libgmp), whereas Int is only guaranteed to store results up to I think 2^28.
18:05:44 <ksf> @check \n -> let rt = floor (sqrt (fromIntegral n)) in (rt*rt) == n `and` n >= 0
18:05:45 <lambdabot>       precedence parsing error
18:05:45 <lambdabot>          cannot mix `(==)' [infix 4] and `(>=)...
18:05:55 <Peaker> > let gn f = fix (\x -> (x>>=f) `mplus` x) in gn (\x -> guard (x < 10) ; return (x*2)) $ Just 1
18:05:56 <lambdabot>   <no location info>: parse error on input `;'
18:06:01 <somnolence> k
18:06:04 <ksf> @check \n -> let rt = floor (sqrt (fromIntegral n)) in (rt*rt == n) `and` n >= 0
18:06:05 <lambdabot>   Couldn't match expected type `[Bool]' against inferred type `Bool'
18:06:10 <dolio> Peaker: That won't work because it starts off with (essentially) x = _|_.
18:06:11 <Peaker> > let gn f = fix (\x -> (x>>=f) `mplus` x) in gn (\x -> do guard (x < 10) ; return (x*2)) (Just 1)
18:06:12 <lambdabot>       No instance for (MonadPlus ((->) (Maybe t)))
18:06:12 <lambdabot>        arising from a use ...
18:06:13 <pumpkin> Peaker >> maybe?
18:06:29 <ksf> @check \n -> let rt = floor (sqrt (fromIntegral n)) in (rt*rt == n) && n>=0
18:06:29 <dolio> _|_ >>= f `mplus` _|_ is likely to be _|_
18:06:30 <lambdabot>   "Falsifiable, after 1 tests:\n3\n"
18:06:47 <Peaker> dolio: :-Z
18:06:49 <MyCatVerbs> somnolence: your functions could all be breaking just because they've defaulted to Ints, and they're overflowing the numerical types. Make sure test3 has a type declaration that declares it to take Integer parameters. type3 :: Integer -> Integer -> ...
18:07:04 <ksf> well, that was kinda obvious.
18:07:15 <somnolence> ok
18:07:20 <ksf> you should really quickcheck it against newton.
18:07:27 <Peaker> dolio: if I use iterate instead of fix, then eventually I get infinite Nothings, so I'd like mplus to short circuit that somehow
18:07:27 <monochrom> Defaulting is Integer.  show (x::Int) is forcing to Int.
18:07:32 <MyCatVerbs> somnolence: I can't actually remember whether Haskell defaults to Ints or Integers, but Murphy's Law says it'll be the wrong one nine times out of tem. ;)
18:07:52 <monochrom> Defaulting is Integer.
18:08:01 <Peaker> dolio: so my Just x `mplus` rest-of-recursion      -- don't recurse
18:08:08 <somnolence> yah that's it =P
18:08:10 <somnolence> it's ints
18:08:15 <somnolence> they are overflowing to -xxx
18:08:31 <Ralith> MyCatVerbs: Integers.
18:08:31 * ksf still isn't shure that he really can't unbox Bar out of newtype Foo = Foo Bar via a typeclass
18:08:47 <Peaker> dolio: but my lhs is also recursing, my head explodes, till tomorrow :)
18:08:57 <dolio> :)
18:09:14 <MyCatVerbs> Ralith: also, I don't want to know, because I don't ever want to write code that depends on it one way or another. :)
18:09:16 <monochrom> Haskell does not conform to Murphy's Law. Haskell is not C.
18:09:33 <SamB> monochrom: sure it does!
18:09:39 <SamB> it's just that less can go wrong
18:09:41 <Gracenotes> I have come to the conclusion that Haskell's numbers system is pleasantly surprising
18:09:46 <ski_> (Peaker : "lhs is also recursing" ? .. view patterns ?)
18:09:55 <Peaker> ski_: my fix above
18:10:00 <Peaker> ski_: but I'm confused I'll let it go :)
18:10:00 <Gracenotes> when it does surprise you, most of the time it's pleasant...
18:10:14 <Peaker> Gracenotes: until you hit unary (-)!
18:10:28 <monochrom> http://haskell.org/onlinereport/decls.html#sect4.3.4  tells you about defaulting and how to make sure you get the default you want.
18:10:32 <Gracenotes> heh
18:10:38 <ski_> Peaker : oh .. i thought you mean the left-hand side of a `... = ...'
18:10:41 * ksf wants a shorthand for \(Foo x) -> x
18:10:50 <pumpkin> ksf: records! :P
18:10:56 <pumpkin> (j/k)
18:11:03 <Peaker> ksf: unFoo ?
18:11:06 <ski_> ksf : `newtype Foo = MkFoo {unFoo :: Bar}'
18:11:15 <Peaker> ski_: why the "Mk" convention?
18:11:16 <ksf> ski, that's it.
18:11:19 <Gracenotes> ksf: identity comonad? :P
18:11:37 <ski_> Peaker : i don't like naming my data constructors the same as the type constructor
18:11:45 <pumpkin> aw
18:12:04 <somnolence>     but its type `Integer -> Integer' has only one
18:12:05 <Peaker> ski_: why not?
18:12:37 <ksf> somnolence, kind error.
18:12:47 <ksf> (even if I only see the last part of it)
18:12:58 <somnolence> lol ksf don't worry about it
18:13:02 <somnolence> just failing pms
18:13:08 <ski_> Peaker : .. because it feels unclean to me ?
18:13:15 <Peaker> ski_: weird :)
18:13:26 <ski_> Peaker : i also don't like `[]' and `(,)', et.c. in types
18:13:28 <ksf> the namespaces are distinct, so it's not dirty.
18:14:08 <ski_> (Peaker : this may have something to do with me having tried a few dependently typed languages, where identifiers for types and other values are in the same namespace)
18:14:18 <Peaker> ski_: ah
18:14:21 <Peaker> ski_: makes sense
18:14:23 <Ralith> steven_ashley: worked out how to step back revisions in darcs, it was surprisingly easy.
18:15:13 <pumpkin> augustss: how did the LLVM people argue it was a feature not a bug?
18:15:32 <steven_ashley> Ralith: So its all working now :)?
18:16:48 <Ralith> steven_ashley: dunno, building based on a week old version
18:18:28 <Lemmih> pumpkin: What was a bug/feature?
18:19:14 <pumpkin> what's the most efficient way to build up a large UArr from a list of smaller ones? there doesn't seem to be a concatU :: [UArr a] -> UArr a
18:19:36 <Gracenotes> folding arrays?
18:19:55 <pumpkin> Lemmih: apparently using 2-element float vectors gives you bad code
18:20:01 <pumpkin> Lemmih: and it's a feature not a bug
18:20:03 * Gracenotes knows not
18:20:04 <dolio> Lemmih: "Do not use two element vectors of type 32 bit floats. This will generate code that is wrong on the x86. I sent in a bug report about this, but was told that it is a feature and not a bug. (I kid you not.)"
18:20:10 <Ralith> steven_ashley: now I got a different error.
18:20:15 <Ralith> oh wait no
18:20:16 <Ralith> same error
18:20:24 <Ralith> gio/System/GIO/AsyncResult.chs:37:0: Failed to load interface for `System.GIO.Base':
18:20:33 <pumpkin> dolio: do you happen to know about my UArr question? I know you've used them a bit
18:21:00 <steven_ashley> http://www.mail-archive.com/gtk2hs-devel@lists.sourceforge.net/msg00195.html
18:21:06 <dolio> Hmmm...
18:21:19 <steven_ashley> Ralith: that mailing list post may interest you
18:21:40 <steven_ashley> Ralith: ""I assumed it was because I didn't have the GIO framework installed. ""
18:22:16 <dolio> pumpkin: The answer is probably that it needs library support for the stream fusion to be optimal.
18:22:25 <Ralith> steven_ashley: haha
18:22:28 <Ralith> that could be it
18:22:35 <Ralith> didn't find that in google, but then I didn't google my exact error
18:22:54 <pumpkin> dolio: ah :/
18:22:58 <Ralith> steven_ashley: er, which package is the gio framework in?
18:23:05 <Ralith> not in cabal?
18:23:26 <dolio> pumpkin: Other than that, find the length of the resulting array, and use newU and copyMU.
18:23:52 <steven_ashley> Ralith: you probably want libgio
18:23:57 <steven_ashley> libgio-dev
18:24:06 <pumpkin> dolio: I was thinking of that, but copyMU only takes one Int argument, and I don't think it's the starting index?
18:24:11 <pumpkin> I thought it was the length to copy
18:24:25 <steven_ashley> Ralith: http://packages.ubuntu.com/hardy/libdevel/libgio-dev its the glib IO library
18:24:27 <dolio> Oh, yeah, that may be right.
18:24:53 <pumpkin> so you can only ever copy the UArr to the beginning of the MUArr
18:25:03 <Ralith> steven_ashley: oh, it's a *system* lib
18:25:03 <Ralith> heh.
18:25:05 <pumpkin> and there's no way to get a slice of a MUArr it seems
18:25:35 <steven_ashley> System.GIO
18:25:38 <steven_ashley> opps :P
18:25:49 <steven_ashley> Ralith: that was supposed to be a search ;)
18:26:01 <dolio> , newU 6 (\a -> copyMU a 2 (toU [1,2,3]))
18:26:02 <lunabot>  toU [-2.2203288570178485e-43,-2.220327708959221e-43,1.0,2.0,3.0,2.4285489...
18:26:11 <dolio> Nope, offset.
18:26:22 <pumpkin> ah, great
18:26:30 <Ralith> steven_ashley: hm, trying to find it in ports...
18:26:30 <pumpkin> dolio: you think that'll be efficient?
18:26:56 <pumpkin> , newU 6
18:26:57 <lunabot>  luna: No instance for (GHC.Show.Show
18:27:03 <steven_ashley> Ralith: you might be able to get away with just disabling it, the mailing list had an option for configure you can use
18:27:19 <dolio> It's probably as good as you'll get currently, at least.
18:27:25 <Ralith> steven_ashley: maybe; will look a minute longer first. thanks
18:27:29 <pumpkin> dolio: fair enough :) I'll try that, thanks
18:27:47 <dolio> It won
18:28:04 <dolio> Oops. It won't fuse down to some kind of stream concatenation if applicable, though.
18:28:11 <pumpkin> yeah, I didn't expect it to
18:28:15 <dolio> It'll always go through an intermediate mutable array.
18:28:45 <pumpkin> yeah
18:29:23 <gwern> any happs experts around?
18:29:36 <coco> gwern: not expert, but novice
18:29:39 <Lemmih> gwern: I wouldn't count on it.
18:29:54 <pumpkin> :t sumBy
18:29:55 <lambdabot> Not in scope: `sumBy'
18:30:02 <gwern> oh. so this a bad place to ask whether happs supports gzipping html responses then
18:30:28 <coco> gwern: it's probably not happs' duty, you could just do that with zlib
18:30:42 <coco> you cand definetly send binaries with it
18:30:47 <Lemmih> gwern: You can add a wrapper to do that.
18:30:53 <gwern> not interested in binaries; interested in wiki pages
18:31:06 <coco> gzipped wiki page = binary
18:31:24 <gwern> Lemmih: oh? how would that work?
18:31:31 <monochrom> ascii  binary
18:31:48 <Gracenotes> binary is ASCII on acid
18:31:59 <gwern> oh la la look at monochrom's fancy Unicode, well la di da!
18:32:02 <shapr> ascid!
18:33:11 <Lemmih> gwern: withCompression GZip $ ...
18:33:35 <Gracenotes> in MediaWiki, pages are binaries, by the way
18:33:49 <Gracenotes> (stored as blobs)
18:33:54 <Ralith> steven_ashley: well, updating glib seems to have done the trick; thanks!
18:34:01 <gwern> binaries? THIS. IS. GITIT!!!!
18:34:06 <steven_ashley> Ralith: np :)
18:34:08 * gwern kicks Gracenotes into the void
18:34:10 <Ralith> still building, but it looks promising.
18:34:35 * Gracenotes falls in slow motion
18:34:44 <mmorrow> pumpkin: this parMapN_ works: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=822#a824
18:34:48 <ztirF> ok I've isolated my problem - I'm spending 97% of my time calculating partial sums of arrays
18:35:02 <pumpkin> mmorrow: thanks!
18:35:10 <pumpkin> the other one seemed to be working for n = 1 at least :P
18:35:23 <chessguy> > sequence [[1,2],[3,4]] [[5,6],[7,8,9]]
18:35:24 <lambdabot>   Couldn't match expected type `[[t1]] -> t'
18:35:34 <gwern> Lemmih: I don't quite follow, withCompression GZip is coming from some existing library?
18:35:34 <ztirF> did hpaste blow up
18:35:45 <chessguy> @where paste
18:35:45 <lambdabot> http://hpaste.org/new
18:35:48 <chessguy> oops
18:35:53 <chessguy> @where moonpaste
18:35:53 <lambdabot> http://moonpatio.com:8080/
18:35:58 <chessguy> ztirF:  ^^
18:36:03 <ztirF> gotcha
18:36:17 <Lemmih> gwern: The definition is left as an exerice for the reader.
18:36:29 <chessguy> > sequence [[1,2],[3,4]]
18:36:30 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
18:36:42 <mmorrow> pumpkin: what i changed was instead of sending an mvar down the out Chan, the threads the runner forks write their results to the out Chan, then once the runner sees a Nothing on the input chan, it waits until all the threads it has forked are done, then writes a Nothing to the out Chan, which prompts `go' in parMapN_ to terminate
18:37:01 <Lemmih> gwern: Take the response, gzip the contents, change some headers.
18:37:16 <ztirF> can anyone help me see why my partialSums function is really slow: it's quite simple (http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=825#a825)
18:37:43 <mmorrow> before, i was having `go' in parMapN_ takeMVar the status MVars of the threads that `runner' forked, which wasn't working for some reason
18:37:47 <chessguy> wow, that's an ugly address
18:38:13 <ztirF> I promise it was cut and pasted
18:38:31 <gwern> Lemmih: I think I don't know enough about happs to do this myself. I take it there are no existing implementations I can crib from?
18:38:36 <chessguy> ztirF:  oh i'm not blaming you
18:38:47 <Lemmih> gwern: Not that I know of.
18:39:15 <gwern> dang :( gzipping seems like it'd help with my larger wiki pages too
18:39:18 * ksf tries hard to believe that c2hs cannot do such a simple thing as convert a #define'd constant into a nullary function
18:40:32 <ksf> I guess I'm going to end up generating my .chs's.
18:40:53 <mmorrow> gwern: http://tools.ietf.org/html/rfc2616
18:41:57 <pumpkin> mmorrow: cool :)
18:44:13 <gwern> mmorrow: your sarcasm is wasted on me
18:44:38 <chessguy> err, surely there's a shorter version of this: combine cs1 [[]] = cs1; combine cs2 [(x:xs)] = combine (map (/\ x) cs1) cs2
18:45:40 <pumpkin> dolio: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=826#a826 for my concatU... look good?
18:45:45 <chessguy> @type let combine cs1 [[]] = cs1; combine cs2 [(x:xs)] = combine (map (?f x) cs1) cs2 in combine
18:45:46 <lambdabot> Not in scope: `cs1'
18:45:47 <pumpkin> whoops
18:46:22 <int80_h> chessguy: hey there. I finally finished the graham scan algorithm implementation
18:46:36 <chessguy> @type let combine cs1 [[]] = cs1; combine cs1 [(x:xs)] = combine (map (?f x) cs1) xs in combine
18:46:37 <lambdabot>     Occurs check: cannot construct the infinite type: t = [t]
18:46:37 <lambdabot>       Expected type: [a] -> [t] -> [a]
18:46:37 <lambdabot>       Inferred type: [a] -> [[t]] -> [a]
18:46:43 <chessguy> int80_h:  yeah? whatcha got
18:46:55 <mmorrow> gwern: heh
18:47:07 <dons> conal: what are you using for syntax highlighting in your blog?
18:47:17 <dons> its generating nice links back to the libraries. very cool
18:47:28 <dons> what flags/version of hscolour?
18:48:31 <int80_h> chessguy: http://paste.lisp.org/display/73948
18:50:03 <chessguy> int80_h:  hrmm, you know there's a standard sort that can handle tuples
18:50:28 <int80_h> chessguy: yeah but I was sticking to the constraints of the exercise
18:50:46 <chessguy> wait, you're not even using sortListByY
18:51:18 <int80_h> chessguy: I suspect that will be the last time I have to do that. Chapter 4 introduces most of the basic constructs of the language. No list comprehensions though.
18:51:36 <int80_h> chessguy: yes I am. I'll give you am example
18:51:47 <porges> what happened to -foverloaded-strings?
18:51:52 <int80_h> chessguy: I forgot to post example usage
18:52:10 <chessguy> oh, well don't push that on the client code
18:52:46 <chessguy> if every usage has to call a function from your code, then you should provide a function that does that already :)
18:53:18 <mmorrow> pumpkin: actually parMapN_ could have a more general type for free http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=822#a828
18:53:37 <mmorrow> (parMapN_ :: Int -> [IO a] -> IO ()    instead of     parMapN_ :: Int -> [IO ()] -> IO ())
18:53:43 <pumpkin> ah, nice :)
18:54:06 <int80_h> chessguy: http://paste.lisp.org/display/73948#1
18:54:21 <chessguy> hm, the requirements don't say you can't use 'sort'
18:55:06 <int80_h> chessguy: you mean so I don't have to to this createHull (sortByCotangent (sortByY [(foo)]))
18:55:12 <chessguy> yeah
18:55:34 <int80_h> chessguy: they don't but I asked dons
18:55:41 <int80_h> @quote dons chapter
18:55:41 <lambdabot> dons says: - yeah, the idea is that you use the tools in the chapter
18:55:48 <chessguy> bah
18:56:06 <chessguy> i don't think that means you can't use any standard functions, but whatever
18:56:10 * pumpkin gets ready to write this monster: [(Int, (UArr Bool, [Feature]))] -> (UArr (Int :*: Bool), [(FeatureType, UArr (Int :*: Double))])
18:56:29 <mmorrow> sweet
18:56:32 <roconnor> type synonyms?
18:56:44 <mmorrow> are you using parMapN_ for UArr stuff?
18:56:55 <roconnor> UArr Bool -- Bool indexed arrays?
18:57:02 <chessguy> you should still have a createHull' = createHull . sortListByCoTangent . sortListByY
18:57:05 <mmorrow> (with an unsafePerformIO/unsafeIOToST or something?)
18:57:12 <pumpkin> mmorrow: well the threads I'm running are doing UArr stuff
18:57:18 <mmorrow> ah, i see
18:57:21 <pumpkin> roconnor: nope, UArrs containing Bools
18:57:42 <pumpkin> roconnor: the indices are automatically ints
18:57:56 <chessguy> int80_h:  does that make sense?
18:58:32 <int80_h> chessguy: yeah, I've been holding myself to some artifical constraints thus far
18:58:48 <int80_h> chessguy: the book hasn't covered function composition yet
18:59:27 <chessguy> well fine, then make it createHull' points = createHull (sortListByCoTangent (sortListByY points))
18:59:33 <int80_h> chessguy: if I had used sortBy, I would have missed some things about pattern matching.
18:59:47 <chessguy> int80_h:  the pointless composition wasn't the ... err... point
18:59:49 <int80_h> chessguy: yeah I can do that
19:00:35 <chessguy> the point is, if you don't supply a createHull' like that (or whatever you want to call it), it virtually forces code duplication
19:00:46 <int80_h> got it
19:01:31 <int80_h> I think chapter 4 frees me up considerably
19:02:02 <chessguy> hm, sortListByY still seems suspicious to me
19:02:09 <porges> how can you import Data.String hiding (IsString [Char]) ? :/
19:02:14 <chessguy> wonder if there's a way you can be rid of the explicit recursion
19:02:24 <mmorrow> porges: you can't
19:02:39 <mmorrow> porges: but you can make a newtype wrapping String
19:02:49 <mmorrow> newtype MyString = MyString String
19:02:53 <chessguy> porges:  why would you want to do that?
19:03:06 <porges> chessguy: attempting something :P
19:03:28 <int80_h> chessguy: it works. It was the first function I did
19:03:28 <sw17ch> hello all
19:03:42 <chessguy> int80_h:  there also seems to be some interesting duplication between the two sortBy... functions
19:03:56 <int80_h> chessguy : I made each function and tested them before moving on to createHull
19:04:00 <chessguy> int80_h:  oh, i'm sure it works. i was just pointing out some stylistic things
19:05:20 <chessguy> int80_h:  personally, i would be more interested in making it as idiomatic as possible than with sticking with the constraints
19:05:40 <sw17ch> can any one in a short phrase say why functional programming is suitable for industry as opposed to procedural languages?
19:06:12 <int80_h> chessguy: I can alway re-write it. But the constraints were useful, I learned some things about pattern matching I didn't understand before. Some things I wasn't even aware that you could do.
19:06:33 <chessguy> sw17ch:  parallelism is hard in an impure environment
19:06:35 <int80_h> sw17ch: more efficient quality control.
19:06:45 <Twey> sw17ch: Increased code reusability, faster development speed, and less time wasted on boilerplate?
19:06:45 <dublpaws> Eb7sus4 = (sus 4 (add 7 (Major E-:4)))
19:06:54 <dublpaws> yes, haskell can swing
19:06:58 <gwern> > let alphabet b = filter (elem a) ['a'..'z'] in alphabet "foo"
19:06:59 <lambdabot>   Couldn't match expected type `[Expr]' against inferred type `Char'
19:07:00 <chessguy> int80_h:  that's fine, i'm suggesting another exercise
19:07:11 <chessguy> this is a good start, it's just not very readable
19:07:25 <int80_h> chessguy: I can do that. The exercise is redo the algorithm in idiomatic haskell?
19:07:26 <gwern> [Expr]? que?
19:07:40 <chessguy> int80_h:  yep
19:07:54 <int80_h> well, it seems to me that's much easier than what I did
19:07:54 <Twey> gwern: [a..z] :: Expr
19:07:57 <Twey> In \b
19:08:00 <sw17ch> tyanks
19:08:05 <Twey> @info Expr
19:08:05 <lambdabot> Expr
19:08:11 <ozy`> sw17ch: it's not functional programming per se that improves reliability; it's the guarantee that you can restrict the mutation of state outside places where it's explicitly allowed to change
19:08:17 <Twey> Expr is Expr.  It lets you do stuff like this:
19:08:18 <chessguy> int80_h: heh. it will certainly be shorter
19:08:37 <Twey> > map (*2) [x, y, z]
19:08:39 <monochrom> functional programming tends to be more high-level.
19:08:39 <lambdabot>   [x * 2,y * 2,z * 2]
19:08:50 <sw17ch> ozy`, this is going into a presentation to my boss and the sales guys tomorrow. they are technical, but if i go down that route, it's not going to get anywhere
19:09:05 <mmorrow> sw17ch: also, i'd ask what is inherently beneficial about an imperative lang other than that a particular one is already entrenched in routine
19:09:17 <ozy`> Ada provides the mutable-state thing (as well as a type system even stricter than haskell's) but doesn't provide the expressiveness of functional programming
19:09:24 <ozy`> sw17ch: ah, well then
19:09:25 <int80_h> sw17ch, I would expect if you keep the discussion toward efficiency and cost, you'll be speakinh their language
19:09:33 <sw17ch> that's what i'm hoping for
19:10:02 <ozy`> sw17ch: functional programming is expressive, which cuts down on programmer time (and development cost)
19:10:20 <monochrom> High-levelness may be a double-edged sword. It implies less work and should lead to cost reduction. It implies less work less control and should lead to dissentment among employees who are job security freaks or control freaks.
19:10:44 <mmorrow> (re: ozy`) which would more than make up for any short-term costs/trouble to make the switch
19:10:50 <ozy`> and in the case of haskell, the strict type system (and purity) increase robustness, which means less maintenance cost
19:11:02 <ozy`> mmorrow: exactly
19:11:28 <monochrom> There tends to be a much higher than average proportion of control freaks among programmers. It took 10-20 years to just convince them to give up goto...
19:11:36 <chessguy> speaking of idiomatic...
19:11:41 <mmorrow> goto rulz though..
19:11:50 <porges> chessguy: was trying to get string interpolation to look natural
19:11:50 <int80_h> who gave up goto. All constructs have their uses.
19:11:58 <CakeProphet> > goto hell
19:11:59 <lambdabot>   Not in scope: `goto'Not in scope: `hell'
19:12:00 <jeffz`> yeah, goto is great
19:12:01 <mmorrow> i can't wait til everyone has given up this silly call/return nonsense
19:12:05 <monochrom> OK, s/give up/weaken on/
19:12:12 <porges> chessguy: instead of [$s|interpolate \V{this}|], "interpolate \V{this}"
19:12:27 <monochrom> OK hahaha you're sarcastic :)
19:12:27 <porges> chessguy: but it seems it won't be possible because of stage restrictions
19:12:36 <int80_h> the netbsd kernel source has goto in many places
19:12:52 <repnop> well goto makes sense in certain idioms in c
19:12:54 <ddarius> NetBSD being an example of a modern development.
19:12:56 <repnop> mostly for errors
19:13:51 <int80_h> I know of know other OS that was designed to be portable across so many machines types
19:13:53 <monochrom> I bet most of industry doesn't deal with kernel code.
19:14:00 <int80_h> erm *no
19:14:08 <chessguy> ok, i have a data Foo a = [[a]]. how can i use map, (++), etc., without having to constantly pattern match and re-construct?
19:14:09 <repnop> int80_h: all the versions of linux :)
19:14:26 <mmorrow> monochrom: heh, i'm actually serious :) (but goto "rulz" not in that it can make code convoluted (which is why giving up its explicit exclusive use was good), but because it's the essence of tail recusion (well, if it weren't limited to a single function))
19:14:30 <int80_h> repnop: you just made the argument against portability right there.
19:14:50 <mmorrow> C would be soooo much better if it just had "jump"
19:15:01 <Twey> It does
19:15:02 <CakeProphet> chessguy:  I'd use a higher-order function. Something like applyf. Or even fmap from Functor.
19:15:02 <ddarius> mmorrow: Forget C, use assembly.
19:15:04 <int80_h> against ^linux portability.
19:15:06 <Twey> longjmp()
19:15:07 <mmorrow> which was like goto, but wasn't restricted to a target in the same function
19:15:08 <Twey> FOR SPEED
19:15:12 <MyCatVerbs> chessguy: what are you after? (Foo . map (map function) . unfoo) ?
19:15:15 <Twey> mmorrow: longjmp()
19:15:20 <mmorrow> ddarius: right on
19:15:22 <repnop> it runs on all the systems i have here :)
19:15:24 <int80_h> I wonder if ghc has goto anywhere
19:15:27 <SamB> mmorrow: thats called tail call
19:15:30 <mmorrow> Twey: bah
19:15:31 <int80_h> I'll guess, ye it does.
19:15:31 <chessguy> CakeProphet:  how so?
19:15:33 <repnop> (arm, sparc, mips, ppc, ia32, ia64)
19:15:36 <SamB> int80_h: of course it has
19:15:39 <chessguy> MyCatVerbs:  i'm not sure what i'm after
19:15:40 <repnop> ia32_64 hehe
19:15:45 <repnop> no itanium here :)
19:15:45 <MyCatVerbs> Twey: actually longjmp() is surprisingly fast for me. gcc linux, i686.
19:15:49 <mmorrow> int80_h: many places
19:15:56 <chessguy> MyCatVerbs:  just trying to figure out if there's a good idiom to use
19:16:04 <MyCatVerbs> Twey: it's getcontext() and setcontext() that are really expensive.
19:16:04 <Twey> MyCatVerbs: I didn't run the benchmark, but was it faster than the loop?
19:16:06 <Pseudonym> longjmp() is very fast, but it's horribly unsafe.
19:16:12 <ozy`> MyCatVerbs: try using it to jump back to the beginning of a loop
19:16:15 <Pseudonym> Nothing on the stack gets to clean itself up.
19:16:21 <Twey> Welcome to C
19:16:23 <Pseudonym> Which in a non-GC'd language is horrible.
19:16:24 <CakeProphet> chessguy:  well if you made foo an instance of Functor, you could define its fmap to apply its first argument to the [[a]] of Foo in the second argument.
19:16:33 <MyCatVerbs> Twey: no. But IIRC it was only a small epsilon slower than a while loop last time I tried it.
19:16:39 <int80_h> repnp: serious refactoring was required for those ports. It was never part of the original design. Plus linux is a kernel, not an OS. I was speaking of operating systems.
19:16:39 <Twey> 'Unsafe?  Hah!  I laugh in the face of danger!'
19:16:40 <CakeProphet> chessguy:  so you don't have to pattern match as much.
19:16:41 <Pseudonym> C++ exceptions are thousands of time slower, but at least they work.
19:16:59 <MyCatVerbs> Twey: setcontext() is thousands of times slower, but then it involves making some syscalls. :)
19:17:02 <int80_h> anyway, I didn't want to start a holy war just because I wuv netbsd.
19:17:04 <Twey> Aye :)
19:17:08 <chessguy> CakeProphet:  ah, i see
19:17:09 <Pseudonym> Actually, the thing I'd like from C is structured gotos.
19:17:16 <Twey> int80_h: Yeah, everyone knows Linux is better anyway.
19:17:21 <Pseudonym> Instead of naming a program point, you name a block.
19:17:22 <Twey> </troll:blatant>
19:17:25 <int80_h> hee hee
19:17:28 <int80_h> busted!
19:17:29 <CakeProphet> chessguy:  is [[a]] the only field in Foo?
19:17:30 <mmorrow> Pseudonym: but if every call was really a jump, then we wouldn't have to worry about a messy stack
19:17:40 <Twey> I'm sorry, I couldn't pull it off with a straight face.  :-P
19:17:48 <chessguy> CakeProphet:  yes
19:17:48 <mmorrow> because that would be implied in "calling" anything
19:18:05 <mmorrow> down with call/ret!!
19:18:14 <Pseudonym> mmorrow: Interestingly, one of the reasons why some languages don't support tail recursion is precisely because stack frames need to be destroyed.
19:18:17 <int80_h> netbsd ports need serious help where ghc/haskell tools are concerned. If I wasn't working on my own project I would help out in that area. As it stands I use lemmih's debian server for haskell stuff
19:18:23 <CakeProphet> chessguy:  it might be easier to use type Foo a = [[a]]  ....so then Foo a /is/ [[a]] instead of being a wrapper around one that you have to constantly deal with.
19:18:23 <Pseudonym> That's the complaint from C++, for example.
19:18:41 <Pseudonym> The Mercury virtual machine used GCC's computed gotos for tail recursion.
19:18:53 <mmorrow> nice, yeah gcc has some interesting extensions
19:18:55 <SamB> Pseudonym: hmm, you mean that's why C++ compilers almost never decide that they can get away with it ?
19:19:02 <ozy`> Pseudonym: argumentum ab C++...?
19:19:12 <SamB> kind of like trying to use a graph-coloring register allocation algorithm in GHC?
19:19:14 <ddarius> mmorrow: That's not an "interesting extension"
19:19:22 <ddarius> mmorrow: Again, just use assembly.
19:19:35 <jasondew> hi all; anyone know how to fix the "Control.OldException" not found problem when building HDBC on 6.8.3?
19:19:36 <chessguy> CakeProphet:  you mean a newtype, right?
19:19:37 <Pseudonym> Also of interest is that Mercury implemented "middle recursion".
19:19:38 <ddarius> C is such a boring language compared to assembly.
19:19:42 <mmorrow> well, i should say "slightly and ever so reducing the suck"
19:19:44 <Pseudonym> If you had a function like this:
19:19:55 <Pseudonym> f Pat1 = baseCase
19:20:05 <Pseudonym> f Pat2 = somethingInvolvingaCallTo f
19:20:08 <CakeProphet> chessguy:  no no. a type synonym. type keyword makes type synonyms. type String = [Char], for example.
19:20:10 <Pseudonym> In pseudo-Haskjell.
19:20:25 <SamB> Pseudonym: hmm, isn't the real problem that C++ doesn't free variables until the block end ?
19:20:25 <mmorrow> ddarius: if there was only a portable asm lang (like C--) that had a compiler as ubiquitous as gcc, the world would be a much better place
19:20:32 <CakeProphet> chessguy:  newtype just has weird semantics on undefined (I don't actually understand newtypes entirely.)
19:20:34 <Pseudonym> SamB: Yes.
19:20:53 <Pseudonym> So that code would look like this, in intermediate code:
19:20:59 <chessguy> oh, i was thinking type synonyms couldn't be parameterized
19:21:23 <Pseudonym> f() { if (isBaseCase) { baseCase; } else { something; f(); somethingElse(); } }
19:21:41 <Pseudonym> So it would implement this by doing however many iterations of "something", pushing local vars onto the stack.
19:21:43 <Pseudonym> Then doing the base case.
19:21:47 <Pseudonym> Then unwinding the stack.
19:21:57 <Pseudonym> Implementing the recursion as a stack-based loop.
19:22:03 <Pseudonym> Kinda cool, actually.
19:22:16 <CakeProphet> chessguy:  hmmm... I'm pretty sure they can. I'll check.
19:22:18 <Pseudonym> SamB: That makes sense when you consider RAII.
19:22:25 <chessguy> CakeProphet:  yeah, you're right
19:22:31 <chessguy> CakeProphet:  don't mind me
19:22:34 <SamB> I thought it was the other way round
19:22:42 <CakeProphet> chessguy:  heh. :D
19:22:42 <Pseudonym> Hmm?
19:22:43 <SamB> RAII makes sense given that rule
19:22:50 <Pseudonym> That too.
19:22:56 <Pseudonym> They make sense together. :-)
19:23:04 <Pseudonym> They don't make sense separately.
19:24:41 <CakeProphet> chessguy:  not sure if there's any benefits of defining Matrix a = [[a]] over just typing [[a]]
19:24:46 <CakeProphet> but that's how you'd do it.
19:25:03 <ddarius> Languages supporting data flow/logic variables are capable of expressing some patterns tail recursively that can't be in (typical) functional languages.
19:25:07 <chessguy> yeah
19:25:12 <pumpkin> wow, I just wrote that epic function
19:25:14 * pumpkin feels proud
19:25:14 <chessguy> and i'm not making a matrix :)
19:25:37 <mmorrow> ddarius: what is one such pattern?
19:26:05 <Pseudonym> ddarius: But Mercury had strong modes, which sometimes required that constructions happen after the tail call.
19:26:17 <Pseudonym> So one of the things I worked on was "tail call modulo constructor" optimisation.
19:26:19 <ztirF> uggg
19:26:54 <ztirF> trying to optimize this function is really painful
19:27:00 <Riastradh> Optimization, Pseudonym, or guarantee?
19:27:31 <Pseudonym> When I was doing it, it was an optimisation.
19:27:43 <Pseudonym> And only for self-recursion.
19:27:55 <Pseudonym> The idea was to make it a guarantee, though.
19:28:05 <chessguy> @pl f c1 c2 = n $ c1 ++ c2
19:28:06 <lambdabot> f = (n .) . (++)
19:28:13 <chessguy> bah
19:28:17 <Riastradh> Does your choice of words imply that it is now a guarantee or that any guarantee is still only an idea?
19:28:50 <Pseudonym> My choice of words implies that I have no idea.
19:29:19 <Riastradh> Aha.  No wonder they sounded noncommittal and vague about the present.
19:29:26 <Pseudonym> However, the person who does know is now an official convert to Haskell.
19:29:33 <monochrom> haha
19:29:42 <monochrom> Who is that person?
19:29:47 <Pseudonym> Dave Overton.
19:29:55 <somnolence> hey anyone have some really obfuscated haskell code?
19:30:04 <Pseudonym> I think he was dmo when he turned up here last.
19:30:05 <ddarius> mmorrow: Some examples that can be handled in constant stack in a lazy language are map or append.  E.g. append(Xs,Zs,Zs). append([X|Xs],Ys,Zs) :- Zs = [X|Zs'], append(Xs,Ys,Zs').
19:30:12 <elly> somnolence: let o_o = 0.0 ;o' =(, ); ;o (*)=(*) ;( lol, xD :p )= o' o' $o.o$ (:[]) $o.o$ (:[]) o_o in (:[]) o_o :p
19:30:16 <somnolence> thanks
19:30:16 <elly> courtesy of gracenotes ;)
19:30:17 <somnolence> thats quality
19:30:21 <monochrom> "f = (n .) . (++)
19:30:31 <monochrom> is some obfuscated haskell code
19:30:50 <Pseudonym> http://www.cs.mu.oz.au/mercury/information/papers/tail_lopstr_lncs.ps.gz <- If you care.
19:30:59 <ztirF> is there a reason why my program should explode if I specify -fvia-c and -O ?
19:31:03 <ddarius> somnolence: There were three or so International Obfuscated Haskell Code Contests.
19:31:05 <Gracenotes> elly: you could also do o' lol instead of o' o'
19:31:06 <ztirF> it segfaults that way
19:31:15 <ztirF> but compiles fine without -fvia-c
19:31:25 <Gracenotes> elly: it's okay that it's bottom, because it never gets evaluated
19:31:44 <elly> heh :P
19:32:05 <monochrom> ztirF: if you use -O but not -fvia-C is it ok?
19:32:10 <ztirF> monochrom:
19:32:14 <ztirF> monochrom: yes
19:33:35 <monochrom> The default answer is "compiler bug" if -O breaks your program. or if -fvia-C breaks your program. Unless your program is very corner-case.
19:33:51 <mmorrow> http://www.haskell.org/haskellwiki/Obfuscation
19:34:29 <Pseudonym> Yeah, if your program depends on unsafe* or evaluation order, and -O breaks your program because of that, it's not a bug.
19:34:34 <Pseudonym> Or, at least, probably not a bug.
19:34:50 <conal> dons: ping
19:35:12 <Pseudonym> BRB
19:35:39 <ztirF> sigh, there's no unsafe going on
19:35:56 <monochrom> -fvia-C breaking things is more interesting. compiler bug. 32-64 mismatch. bad gcc. bad program.
19:36:16 <dons> conal: pong
19:36:30 <dons> gcc breaks many of my shootout programs, monochrom
19:36:31 <conal> dons: (conal: what are you using for syntax highlighting in your blog?) i use a combination of Markdown Extra and GeSHi.  see http://conal.net/blog/posts/switching-blog-engines/ .   i'd love to have others taking this route also and helping to improve it.
19:36:50 <dons> oh huh. so that's how you get the links back to the libraries?
19:36:53 <monochrom> Oh haha then.
19:37:11 <dons> conal: great. i'm switching to wordpress
19:37:29 <conal> dons: yeah.  via GeSHi.  all i do is indent code by four spaces.  it gets colored as haskell.  i changed the default language.
19:37:37 <dons> awesome
19:37:43 <chessguy> @pl \cs -> n (x ++ cs)
19:37:43 <lambdabot> n . (x ++)
19:37:45 <conal> yeah.  pretty sweet. :)
19:37:52 <monochrom> "The Memoir of a ... Geshi?" :)
19:37:54 <dons> thanks.
19:37:57 <conal> :)
19:38:13 <porges> anyone knowledgeable about TH patterns
19:38:29 <monochrom> A blog on switching blog implementations is a bit meta...
19:38:32 <conal> dons: would be cooler if the auto doc linking somehow kept up to date with hackage.
19:38:46 <conal> dons: though the ambiguities would be tricky.
19:39:14 <conal> i'm happy with being able to compose posts in markdown.
19:39:53 <conal> i'd still like haddock to get out of the markup business and work orthogonally to something like markdown.
19:39:57 <MyCatVerbs> Ah, Markdown. My favourite thing about Markdown is that it's not goddamn Structured Text.
19:40:04 <chessguy> @pl \x -> map (nub.(x++))
19:40:06 <lambdabot> map . (nub .) . (++)
19:41:13 <chessguy> @pl f c d = n (c ++ d)
19:41:14 <lambdabot> f = (n .) . (++)
19:41:18 <chessguy> hrmmmmm
19:41:27 <mmorrow> conal, dons: hpaste2 uses that python pigments lib for code highlighting (which it ffi imports) and it's really nice. maybe that could be adapted for something nice?
19:41:48 <int80_h> hpaste2, what happend to hpaste?
19:41:51 <ddarius> Has someone actually given a "why" reason to making code "least-strict"?
19:42:02 <mmorrow> oh, but i guess the blog itself would need to be written in haskell for that to be useful..
19:42:17 <conal> mmorrow: interesting possibility.
19:42:40 <conal> a nicely hackable haskell-based blog platform.
19:42:50 <conal> though there sure are a lot of free plugins for wordpress.
19:42:51 <mmorrow> yes, that would rule school.
19:42:56 <conal> yeah.
19:43:26 <monochrom> lambdablog ?
19:43:43 <MyCatVerbs> conal: isn't Wordpress supposed to be, y'know, terrible?
19:43:49 <monochrom> xblogad ?
19:43:52 <mmorrow> i think hpaste2 could probably be made (somewhat easily) into a blog, (as could gitit, but that uses HAppS instead of fastcgi which might be undesireable)
19:44:03 <conal> MyCatVerbs: which aspects of wordpress?
19:44:09 <sclv> ddarius: do you doubt, or do you have a neat reason you'd like to present?
19:44:09 <int80_h> the PHP part?
19:44:19 <jeffz`> security problems?
19:44:27 <ddarius> sclv: Doubt what?
19:44:31 <mmorrow> MyCatVerbs: it looks pretty though, which matters for a lot in a blog
19:44:50 <sclv> the utility of making code least-strict?
19:45:06 <ddarius> sclv: No one has presented a utility for it as far as I can tell.
19:45:11 <mmorrow> what does "least-strict" mean?
19:45:14 <conal> gotta go.  catch you all later.
19:45:17 <ddarius> sclv: I'm asking for someone to do so so that I have something to doubt.
19:45:18 <mmorrow> strict wrt what?
19:45:21 <mmorrow> conal: see ya
19:45:32 <sclv> cheers
19:45:42 <monochrom> perhaps non-strict is a special case of least-strict
19:45:42 <chessguy> @type \x -> map (nub.(x++))
19:45:43 <lambdabot> forall a. (Eq a) => [a] -> [[a]] -> [[a]]
19:45:46 <mmorrow> oh
19:45:46 <MyCatVerbs> conal: performance and security. The security woe being that it's so widely deployed as to be very commonly targetted, and the authors apparently aren't paranoid. The performance woes... you'll hear all over the place, if you look.
19:45:53 <mmorrow> strictness, gotcha
19:45:54 <int80_h> nah, tech-blogs are supposed to be minimilist. Like you cobbled it together with ed and as
19:45:55 <chessguy> @type map.(nub .).(++)
19:45:56 <lambdabot> forall a. (Eq a) => [a] -> [[a]] -> [[a]]
19:46:10 <conal> parting shot: lazy is good; lazier is gooder; laziest is goodest.  least-strict = laziest.
19:46:43 <mmorrow> parthian shot?
19:46:44 <sclv> handling explicit bottom (i.e. undefined) isn't that interesting i think, but handling divergence is.
19:46:48 <int80_h> funnier: lazy is good; lazier is gooder; laziest is ... um .. Zzzzz
19:46:56 <MyCatVerbs> conal: not... necessarily. See: stack overflows trying to build large data structures... :)
19:46:57 <monochrom> hehehe
19:47:57 <monochrom> @remember int80_h lazy is good; lazier is gooder; laziest is ... um .. Zzzzz
19:47:58 <lambdabot> It is stored.
19:48:06 <conal> MyCatVerbs: i'm talking about semantic benefits.  as often with semantic benefits, there are implementation puzzles to solve.
19:48:27 <sclv> the lazier something is, the less unneccesary work there is to do, and less chance of divergence, no?
19:48:30 <MyCatVerbs> conal: fair 'nuff. Well put, even.
19:49:01 <sclv> but of course unamb style solutions provide the lack of divergence but don't give the same performance benefit as writing it directly.
19:49:52 <sclv> and for something like zip, arguably, it makes no sense at all that there are cases where it treats its arguments differently, so having code that doesn't means that you can think about what it does cleanly.
19:50:29 <ddarius> sclv: I have no problem with -particular- cases being -more- lazy.  It's easy to find those.
19:50:41 <sclv> so isn't that all least-strict means?
19:50:58 <sclv> functions should be as strict as they need to be and no stricter
19:51:05 <pumpkin> well at least now I know why my program is gobbling up so much memory
19:51:17 <ddarius> sclv: No, there can be cases where the extra laziness costs more than it's worth.
19:51:35 <sclv> right, so the argument isn't that least-strict is always correct
19:51:56 <pumpkin> I'm constructing a 2604 x 221k matrix :o
19:51:58 <MyCatVerbs> ddarius: that's "just" an implementation issue, though. :)
19:51:59 <pumpkin> of Doubles
19:52:13 <sclv> but just like laziness is a better default than strictness, aiming for laziness unless proven otherwise arguably makes sense too
19:52:37 <ddarius> MyCatVerbs: And 5MB v. 5GB or 5min v. 5 days is "just" a quality of implementation issue.
19:53:29 <chessguy> @paste
19:53:29 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:53:31 <chessguy> @where paste
19:53:31 <lambdabot> http://hpaste.org/new
19:53:39 <pumpkin> fail
19:53:41 <chessguy> @where moonpaste
19:53:41 <lambdabot> http://moonpatio.com:8080/
19:53:42 <ddarius> sclv: My experience is that a balance between laziness and strictness is necessary.  My opinion is that either is a fine default.  There are some benefits to laziness being the default, but not because "everything should be lazy"
19:53:45 * chessguy sighs
19:53:58 <ddarius> Trying to make things "as lazy as possible" is how we got foldl.
19:55:06 <int80_h> I get this error when trying to compile InteractWith from chapter 4 RWH. "Could not find module `System.Enviroment'" Is there a switch I can use to get ghc to find it?
19:55:08 <sclv> but its also how we got foldr, no?
19:55:12 <MyCatVerbs> ddarius: not quite. It's "just" a constant factor difference. :)
19:55:16 <chessguy> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=829#a829 is interesting. if i move f out of there clause, or put the same type signature on f as on (/\), or replace f with (/\) completely, it fails
19:55:26 <pumpkin> MyCatVerbs: you computer scientist!
19:55:29 <chessguy> int80_h: did you give up on my challenge?
19:55:30 <pumpkin> (insult)
19:55:33 <ddarius> MyCatVerbs: The difference between foldl and foldl' is -not- a constant factor difference.
19:55:39 <MyCatVerbs> pumpkin: that shouldn't be an insult here of all places!
19:55:45 <pumpkin> MyCatVerbs: just being silly :P
19:55:50 <monochrom> After all these years I am still uncomfortable with "lazy vs strict" as opposed to "lazy vs eager, non-strict vs strict"
19:55:53 <int80_h> chessguy: no, I'm doing chapter 4. I figure there's something about idiomatic haskell I can learn there.
19:56:02 <sclv> int80_h: the --fcorrect-my-spelling-of-the-module switch?
19:56:06 <pumpkin> MyCatVerbs: but it's only a constant factor if you have infinite stack space isn't it?
19:56:13 <chessguy> int80_h:  nah, there's nothing to learn after chapter 3 :)
19:56:21 <sclv> ghc really *does* do everything :-)
19:56:23 <pumpkin> MyCatVerbs: otherwise they just behave differently
19:56:28 <MyCatVerbs> ddarius: yes, but the space wasted is "only" linear in the time wasted. :)
19:56:29 <ddarius> sclv: No.  I highly suspect that foldr-like things existed before lazy-by-default languages.
19:56:55 <sclv> lazy-by-default languages existed before computer languages. :-)
19:57:05 <monochrom> which one?
19:57:11 <int80_h> engrish
19:57:17 <pumpkin> japanese?
19:57:21 <sclv> as she is spoke
19:57:41 <MyCatVerbs> monochrom: all natural languages allow forward references, if that counts.
19:58:01 <pumpkin> *all*
19:58:05 <pumpkin> MyCatVerbs: are you positive?
19:58:05 <mmorrow> @tell conal wow, i just found out that highlighting-kate is pure haskell, /and/ it autogenerates parsers/highlighters from kate xml syntax files
19:58:05 <lambdabot> Consider it noted.
19:58:45 <monochrom> I don't understand why it counts. Forward references do not require laziness.
19:59:06 <MyCatVerbs> pumpkin: with high probability, I will not meet any living human being who speaks a natural language in which forward references are disallowed. :)
19:59:14 <SamB> monochrom: self-references do
19:59:15 <dibblego> what's the function to read from stdin :: IO String ?
19:59:31 <pumpkin> MyCatVerbs: you refuse to meet such a person if one existed? :P
19:59:38 <roconnor> @hoogle hread
19:59:38 <pumpkin> dibblego: getContents?
19:59:38 <lambdabot> System.IO hReady :: Handle -> IO Bool
19:59:39 <lambdabot> Control.Concurrent isCurrentThreadBound :: IO Bool
19:59:39 <lambdabot> Control.Concurrent killThread :: ThreadId -> IO ()
19:59:39 <MyCatVerbs> monochrom: wellll... arguably, it requires support for Prolog-style data structures with unfixed variables in them.
19:59:44 <dibblego> pumpkin, yeah got it thanks
19:59:51 <roconnor> @hoogle hgetline
19:59:51 <lambdabot> Data.ByteString hGetLine :: Handle -> IO ByteString
19:59:51 <lambdabot> System.IO hGetLine :: Handle -> IO String
19:59:51 <lambdabot> Data.ByteString.Char8 hGetLine :: Handle -> IO ByteString
19:59:54 <monochrom> I think it stretches too much.
19:59:58 <pumpkin> MyCatVerbs: sorry, I'll stop stupidly missing the point :P
20:00:35 <int80_h> forward references?
20:00:45 <MyCatVerbs> pumpkin: I only didn't reply because I couldn't think of one.
20:01:12 <MyCatVerbs> pumpkin: and you failed to note the qualifier *living* human being.
20:01:16 <pumpkin> MyCatVerbs: I didn't expect one :P I'm just detracting from your actual conversation
20:02:00 <pumpkin> we haven't had any good trolls in here for a little while
20:02:17 <MyCatVerbs> pumpkin: if it ever becomes a problem, I reserve the right to retain sniper teams to eliminate anyone who might come too close to me and be able to speak a natural language with Pascal-or-C style restrictions. :)
20:02:25 <monochrom> Haskell is like Burito
20:02:27 <int80_h> haskell sux0rz! Perl rulez 4ll!
20:02:32 <int80_h> is that good?
20:02:37 <MyCatVerbs> pumpkin: are you kidding? I've been trolling since I arrived.
20:02:49 <pumpkin> MyCatVerbs: I said good troll
20:03:04 <ddarius> int80_h: No.
20:03:08 <pumpkin> you're clearly not a very good one because you don't have hordes of haskell lovers trying to argue with you
20:03:12 <MyCatVerbs> pumpkin: on the contrary, I've failed hard enough to have accidentally helped a few people here and there.
20:03:24 <MyCatVerbs> pumpkin: ah yes indeed. :(
20:03:51 <int80_h> ddarius: you aren't very nurturing. I may give up trying to troll altogether.
20:03:51 * pumpkin stamps MyCatVerbs with his stamp of phail, right on the forehead
20:03:52 <Olathe> In some ways, burritos are like Mexican food.
20:04:05 <monochrom> Haskell is not used in industry. This is because Haskell is counterintuitive.
20:04:05 * ddarius is really the troll.
20:04:18 <Gracenotes> jasmine rice... still delicious
20:04:26 <bombshelter13> Would it be possible to produce a 'don't control statement, that would not evaluate it's argument, unless nested?  I.e., 'don't exp' would not eval exp, but 'don't (don't exp)' would?
20:04:34 <ddarius> Haskell is not used in industry.  This is because Haskell is not C#.
20:04:36 <int80_h> jasmine rice is awesome. real ric, take 15 minutes to make
20:04:49 <pumpkin> bombshelter13: o.O
20:04:55 <bombshelter13> (well, evenly nested)
20:04:59 <monochrom> Oh haha, "don't control statement" is a much better troll attempt :)
20:05:02 <bombshelter13> pumpkin: :D
20:05:09 <MyCatVerbs> bombshelter13: I don't think so. Haskell functions are required to be monotonic in defined-ness.
20:05:21 <bombshelter13> monochrom: it's not really a troll, I just like to see how far I can bend a language.
20:05:33 <monochrom> just kidding
20:05:37 <pumpkin> bombshelter13: maybe you could have some sort of flipping of pairs
20:05:44 <pumpkin> bombshelter13: you'd need an external evaluator though
20:06:02 <pumpkin> oh wait
20:06:04 <pumpkin> no
20:06:07 <int80_h> ah hah! flipping pairs is something a troll would do!
20:06:13 <int80_h> troll!
20:06:14 <pumpkin> what do you even mean wouldn't evaluate?
20:06:21 <pumpkin> what would don't exp return?
20:06:23 <pumpkin> ()?
20:06:27 <int80_h> too late, we found the troll.
20:06:31 <bombshelter13> pumpkin:  sounds good
20:06:40 <pumpkin> ?
20:06:54 <pumpkin> then you could have some system where you ((), val)
20:06:59 <pumpkin> and then each don't would flip those two
20:07:08 <pumpkin> and you'd have an external statement that was basically just fst :P
20:07:12 <pumpkin> *function
20:07:17 <MyCatVerbs> How about if you do it with a typeclass hack?
20:07:27 <pumpkin> that's probably way better than mine :P
20:07:28 <bombshelter13> pumpkin:  that's a pretty clever idea
20:07:32 <ddarius> If "don't" is allowed to be a class method I can do it.
20:07:59 <dibblego> what is the parser example that Graham Hutton uses in PiH?
20:08:07 <ddarius> If not, I'm pretty sure I can do it, but it would take some hacky, impure ickiness.
20:08:08 <pumpkin> ddarius: how? I'm curious
20:08:42 <ddarius> pumpkin: Actually it might be harder than I though, but I suspect I could still do it.
20:08:45 <pumpkin> it's actually a pretty interesting question, even if it looks completely useless for any real-world application
20:08:47 <dibblego> what is the parser example that Graham Hutton uses in PiH? (i.e. the type signature - I remember it was simple enough to be used as a good introduction to parsers)
20:09:14 <bombshelter13> yeah... I'm not sure where it would actually be useful
20:09:23 <SamB> dibblego: was it the doctor seuss one ?
20:09:31 <dibblego> SamB, doesn't ring a bell
20:10:08 <dibblego> got it String -> [(a, String)] (though I think I'll use Maybe and not [])
20:10:30 <bombshelter13> but it seems pretty easy to parse for a human, it seems curious that it's so hard to express to a computer
20:11:16 <mmorrow> dibblego: thats the "list of successes" technique
20:11:51 <mmorrow> (which is inefficient but nice and simple)
20:12:35 <mmorrow> http://portal.acm.org/citation.cfm?id=5288
20:12:42 <mmorrow> "How to replace failure by a list of successes"
20:12:53 <mmorrow> http://www.cs.nott.ac.uk/~gmh/pearl.pdf
20:13:01 <pumpkin> > let run = snd; don't = (snd &&& fst); ugh = (,) () in run . don't . don't . ugh $ 5
20:13:02 <lambdabot>   5
20:13:06 <pumpkin> > let run = snd; don't = (snd &&& fst); ugh = (,) () in run . don't . ugh $ 5
20:13:07 <lambdabot>   ()
20:13:11 <pumpkin> bombshelter13: ugliest solution ever
20:13:48 <pumpkin> > let run = snd; don't = (snd &&& fst); ugh = (,) undefined in run . don't . ugh $ 5
20:13:49 <lambdabot>   * Exception: Prelude.undefined
20:13:54 <pumpkin> > let run = snd; don't = (snd &&& fst); ugh = (,) undefined in run . don't . don't . ugh $ 5
20:13:55 <ddarius> pumpkin: I don't think that meets the spirit.
20:13:55 <lambdabot>   5
20:14:01 <pumpkin> ddarius: didn't think so :(
20:14:46 <mmorrow> data Dont a = Dont a | Do (Dont a)
20:14:54 <Gracenotes> heh. I was about to execute "tail $ grep -ir 'gracenotes.*random' irclogs/" in bash, when I forgot that it wasn't Haskell :P
20:14:59 <coco> if a view pattern fails, the view function isn't evaluated again if it appears in another pattern, right?
20:15:12 <coco> (applied to the same arguments)
20:15:18 <Gracenotes> I then reversed the order properly :/
20:15:33 <pumpkin> Gracenotes: I really want a haskshell
20:15:52 <Gracenotes> lazy bash would be quite cool
20:15:57 <mmorrow> an sh parser/interp would be the hardest part
20:16:07 <pumpkin> mmorrow: that's already up, but that's not really what I want
20:16:07 <Gracenotes> to an extent, bash is lazy
20:16:10 <mmorrow> everything else would be easy peasy (relative)
20:16:19 <mmorrow> pumpkin: o rly?
20:16:21 <mmorrow> where?
20:16:39 <Gracenotes> in bash, many processes input/output text as it comes in
20:16:47 <mmorrow> pumpkin: so you want piping, redirecting, etc
20:16:52 <Gracenotes> making chaining processes psuedo-lazy
20:16:54 <mmorrow> yeah, that wouldn't be very hard
20:17:02 <pumpkin> mmorrow: I basically want it as close as possible to haskell syntax
20:17:07 <mmorrow> oh
20:17:14 <mmorrow> hmm
20:17:25 <pumpkin> you could implement most typical shell commands in a few lines of haskell
20:17:29 <rwbarton> I have a shell script 'interact', so I can write 'interact reverse < input-file' and so on
20:17:34 <pumpkin> and just call them from a ghci-like interpreter
20:17:53 <pumpkin> mmorrow: but http://hackage.haskell.org/cgi-bin/hackage-scripts/package/language-sh
20:17:53 <Gracenotes> one big IO monad :P
20:17:56 <pumpkin> that's if you want SH
20:18:01 <mmorrow> rad
20:18:04 <ddarius> pumpkin: One way that would kind of work, but it would require type annotations is: class Dont a b where dont :: a -> b; instance Dont Nonce () where dont x = seq x (); instance Dont EachOtherType () where dont = const () -- or perhaps overlapping/incoherent instances would help here.
20:18:06 <bombshelter13> pumpkin: hmm, what is the '&&&' operator? Can't seem to see it on the operator list.
20:18:16 <ddarius> @hoogle (&&&)
20:18:16 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
20:18:32 <pumpkin> bombshelter13: I'm just using it to flip the pair
20:18:33 <ddarius> pumpkin: But I don't find that solution acceptable.
20:18:44 <Gracenotes> bombshelter13: one has to "import Control.Arrow" though
20:19:01 <ddarius> For the other solution, "nested" would need to be better defined.
20:19:20 <ddarius> Actually...
20:19:23 <bombshelter13> pumpkin:  yeah, that was what I was guessing in context, just didn't know where it was from...
20:19:49 <rwbarton> > let don't = const id in (don't (+1) 3, don't don't (+1) 3)  -- yes, I bent the rules a little
20:19:50 <lambdabot>   (3,4)
20:19:51 <pumpkin> > (f &&& g) x
20:19:52 <lambdabot>   Add a type signature
20:19:57 <bombshelter13> ddarius: well, if it should basically flip back and forth, even numbers of applications would get done while odd ones would not.
20:20:06 <pumpkin> > (f &&& g) x :: (Expr, Expr)
20:20:07 <lambdabot>   (f x,g x)
20:20:33 <ddarius> bombshelter13: That's not what you said originally and what I'm actually asking is would dont (1 + dont exp) be considered nested (assuming that expression was valid)
20:22:03 <mmorrow> rwbarton: exec ghc -e "interact ($1)" #?
20:23:23 <rwbarton> mmorrow: cat | ghc -e "interact ($*)" ~/bin/imports.hs
20:23:27 <bombshelter13> ddarius: nah, nested in the sense of one don't expression being passed another don't expression, i.e., not a don't expression being passed an addition expression as in above
20:23:41 <rwbarton> mmorrow: the 'cat' is there to make it interact with the terminal better.  I forget exactly what it fixed.
20:24:08 <conal> sclv: ("the utility of making code least-strict?") i like your question.  i'd like to see it get discussed, so i hope you'll ask in on my blog post or in the email thread.
20:24:08 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
20:24:12 <mmorrow> but isn't that the same thing as no cat there?
20:24:27 <rwbarton> mmorrow: I think it was only necessary because I wanted the imports
20:24:32 <mmorrow> ah
20:24:34 <rwbarton> mmorrow: You'd think so, but no
20:24:38 <mmorrow> weird
20:24:42 <rwbarton> mmorrow: something to do with the terminal.  dmwit figured it out
20:24:50 <mmorrow> maybe if you exec'ed it
20:24:54 <mmorrow> it'd be the same
20:26:00 <mmorrow> gah! language-sh uses parsec.
20:26:19 <MyCatVerbs> http://rafb.net/p/1lYSrH81.html <-- I'm stuck here. GHC doesn't appear to pick up on the (Inv Do Donut) and (Int Donut Do) instances.
20:26:24 * mmorrow start the gah! use ReadP pleezk! initiative
20:26:39 <mmorrow> *starts
20:27:06 <Gracenotes> oh dear lord... "Objects First with Java, Using BlueJ (with CD)" is a textbook next semester. And it's $103.00 new.
20:27:08 <MyCatVerbs> (dooo $ val 40) returns (Just 40), great, but (dooo . dont $ val 40) fails with, "No instance for (Inv Do db)". Bugger.
20:27:10 <Gracenotes> What the hell.
20:27:26 <pumpkin> Gracenotes: just say no!
20:27:29 * Gracenotes doesn't know why this is a requisite :
20:27:29 <mmorrow> Gracenotes: take a different class
20:27:44 <SamB> yeah, refuse to purchase such a clearly ungrammatical textbook
20:27:45 <Gracenotes> but, indeed, it is a prerequisite for many other classes, and a requisite period for graduation
20:27:59 <MyCatVerbs> Any type-level hackers care to take a look and tell me what I'm going wrong, please? Is my approach even workable?
20:28:02 <pumpkin> Gracenotes: can't you place out of it?
20:28:15 <mmorrow> Gracenotes: there're no other courses which fill that requ?
20:28:19 <Gracenotes> yeah, I should have tried to do that earlier
20:28:28 <mmorrow> it's nevar too late!
20:28:29 <SamB> no other sections ?
20:28:31 <Gracenotes> mmorrow: it's undergrad. There's a set course, to a certain extent
20:28:46 <pumpkin> Gracenotes: often they let you take exams if you can convince them you already know the stuff
20:28:49 <pumpkin> to satisfy prerequisites
20:28:51 <mmorrow> Gracenotes: what year are you?
20:28:55 <Gracenotes> there's only one section. It's from the CS Honors program, though, so not entirely bad
20:28:57 <Gracenotes> freshman
20:29:00 <mmorrow> ah
20:29:04 <mmorrow> yer screwed :)
20:29:05 <pumpkin> also, prerequisites can be rather flexible depending on where you are
20:29:17 <mmorrow> but i'd still try to not take it
20:29:25 <Gracenotes> there's a part two; I'll see if I can place out of that by various means
20:29:30 <pumpkin> I skipped a couple of required CS courses
20:29:36 <milton13_> yo, what are the indentation rules for the "do" constructs?
20:29:47 <Gracenotes> unfortunately part of one's grade is a project
20:30:04 <MyCatVerbs> milton13_: terrible. :)
20:30:16 <milton13_> MyCatVerbs: you're telling me.... -_-
20:30:28 <Gracenotes> argh. I'll try my best to be a stuck-up functional programming advocate throughout, though.
20:30:38 <mmorrow> milton131: the first token after "do" sets an imaginary vertical line which all procedding stmts have to start on
20:30:55 <mmorrow> oops, (@milton13_)
20:31:04 <milton13_> our teacher gave us this assignment, and if you change ANYTHING in it, ghci complains "parse error! incorrect indentation!"
20:31:17 <pumpkin> Gracenotes: yeah, you should refuse to use any variables
20:31:19 <Gracenotes> time for JHaskell, maybe? :P
20:31:22 <pumpkin> Gracenotes: as a form of protest
20:31:28 <pumpkin> Gracenotes: write java like you'd write haskell
20:31:34 <Gracenotes> disallowing immutable variables? :P
20:31:40 <Gracenotes> er, mutable
20:31:48 <pumpkin> yup
20:31:48 <MyCatVerbs> milton13_: http://haskell.org/ghc/docs/6.8.3/html/libraries/base/src/Control-Concurrent-Chan.html <- copy this formatting. :)
20:31:49 <mmorrow> have every function be in its own class
20:31:51 <milton13_> you guys have to take java AFTER haskell??? wackyyyyy
20:31:51 <Gracenotes> the only variable mutation that takes place is within a monad
20:32:02 <pumpkin> yeah, if you make every function its own class you can make higher-order functions
20:32:12 <pumpkin> class Function... all the other ones can derive from it
20:32:19 <Gracenotes> I'll claim to use the command pattern :)
20:32:19 <mmorrow> leet!
20:32:31 <pumpkin> Gracenotes: that could actually be quite fun if your grader had a sense of humor and respected functional languages
20:32:32 <MyCatVerbs> Er, that will take *all day* to type. Besides, for it to fit Java's type system properly, you'll have to use Generics.
20:32:34 <Gracenotes> milton13: I haven't taken any programming languages yet... I've just learned ones on my own
20:32:40 <ddarius> milton131: In some respects, it's a (more) natural progression (than the other way)
20:32:48 <pumpkin> Gracenotes: unfortunately you'd get into stack issues if you insisted on using recursion
20:32:54 <Gracenotes> MyCatVerbs: yay parametric polymorphism!
20:33:07 <MyCatVerbs> Gracenotes: ahahahahha, no.
20:33:07 <milton13_> Gracenotes: respek! :)
20:33:16 <pumpkin> MyCatVerbs: you only need generics if you want type safety :P
20:33:20 <Gracenotes> down with ad-hoc!
20:33:22 <pumpkin> just make function return Object :P
20:33:25 <pumpkin> and cast it
20:33:25 <monochrom> Haskell is easier to teach to clean slates.
20:33:30 <MyCatVerbs> Gracenotes: the term you're after is, "the bastard crippled nephew of parametric polymorphism!". This is *Java* we're talking about after all.
20:34:03 <milton13_> ddarius: yeah sometimes it feels backwards that i learned java first...i mean they shove you into this imperative world and THEN they explain what it all meant back then... ;)
20:34:04 <Gracenotes> Generics: restricted parametric polymorphism. But not as cool as typeclasses, by several orders of magnitude.
20:34:07 <pumpkin> augustss: you around?
20:34:27 <SamB> monochrom: I've never known a rock, regardless of type or cleanliness, to learn anything, much less a programming language
20:34:39 <Gracenotes> yeah, I actually learned Java before learning Haskell. So I can respect its flaws, but also accept that it can do a lot.
20:34:46 <chessguy> hey conal
20:34:53 <Gracenotes> or is that backwards :|
20:34:54 <MyCatVerbs> Gracenotes: well, <? implements Foo> or <? extends Foo> is probably just about polymorphic enough in practice for most purposes. :)
20:35:11 <pumpkin> Gracenotes: you might still be able to convince people to let you take a placement test
20:35:27 <dino-> It's tough. Being unable to really do closures.
20:35:40 <Gracenotes> Java has its own little idioms, instead of closures
20:35:48 <Gracenotes> albeit, the idioms are much more verbose
20:35:51 <SamB> Gracenotes: horrible idioms
20:36:10 <Gracenotes> MyCatVerbs: well, it is polymorphism, undoubtedly. It's probably the closest to parametric polymorphism
20:36:21 <Gracenotes> and primitive variables are the thorn in the side of Java polymorphism
20:36:49 <SamB> just pretend those type names end in #
20:36:56 <SamB> problem solved
20:37:20 <chessguy> a complete implementation of propositional logic, maintaining sentences in conjunctive normal form, in <30 lines of code, without trying to be cute or anything: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=830#a830
20:37:28 <Gracenotes> at least primitive Haskell variables play nicely with types :P
20:37:36 <chessguy> i'm pretty proud of that one
20:38:00 <dino-> You can I suppose force yourself to use the object versions of EVERYTHING. :o  And let the verbosity ensue.
20:38:27 <SamB> oh, of course then you run into the lack of binop method names in Java ...
20:38:30 <ddarius> Java generics are just as much parametric polymorphism as Haskell's.
20:38:49 <Gracenotes> except for types like int and byte
20:38:55 <Gracenotes> (lowercase)
20:39:02 <SamB> Gracenotes: have you ever had a [Int#] ?
20:39:10 <Gracenotes> personally, no.
20:39:20 <SamB> well, try it now ;-P
20:39:26 <Gracenotes> I don't generally work with internals. Is it a bad idea? :>
20:39:43 <SamB> hint: you can't do it!
20:39:50 <ddarius> Indeed that can be addressed the same way.  You have 'forall t : *' but 'int : #'
20:39:59 <Gracenotes> eek.
20:40:08 <ddarius> Though I will agree that it is a wart on Java's part.
20:40:11 <Gracenotes> is Haskell not as wondrous as thought? o:
20:40:14 <mmorrow> but you can do: data List a = Nil | Cons {-# UNPACK #-} !a (List a)
20:40:18 <mmorrow> which is the same thing
20:40:27 <ddarius> The bounded quantification though is actually quite powerful.
20:40:32 <ddarius> Gracenotes: Those are GHC extensions.
20:40:47 <pumpkin> what's the opposite of extension?
20:40:52 <pumpkin> restriction?
20:40:55 <mmorrow> intension?
20:40:57 <Gracenotes> True. you need to have some kind of implementation, though.
20:40:59 <ddarius> Gracenotes: But the way GHC folds them into the language is (or can be) principled and readily applied to Java as well.
20:41:02 <Gracenotes> messy as it may be.
20:41:03 <SamB> mmorrow: I don't think you can {-# UNPACK #-} a field of unknown type
20:41:13 <MyCatVerbs> Gracenotes: these are the things that the nice types you see are implemented in terms of.
20:41:20 <Gracenotes> ddarius: hm. how so?
20:41:45 <pumpkin> > drop 3 . take 5 $ [1..10]
20:41:46 <lambdabot>   [4,5]
20:41:47 <Gracenotes> does it have to do with a G-machine I've read about? Or entirely different?
20:41:49 <int80_h> if you were required to take either c++ or java as a freshmen, which would you pick?
20:41:55 <mmorrow> SamB: i'm not sure. if it was smart it'd just ignore that in the case where it's impossible
20:42:03 <ozy`> int80_h: :(
20:42:09 <pumpkin> > drop 3 [1..10]
20:42:09 <MyCatVerbs> Gracenotes: for example, if you play around, you'll find that Int is actually (I# Int#).
20:42:10 <lambdabot>   [4,5,6,7,8,9,10]
20:42:11 <scottsd> are there any concrete benefits to learning lambda calculus? Beyond the generic "it'll make you a better programmer"
20:42:12 <monochrom> pick c++ but skip all classes :)
20:42:30 <pumpkin> ah, duh, I'm stupid
20:42:35 <SamB> mmorrow: what I mean is, it can't get unpacked
20:42:40 <int80_h> skip classes, turn in homework
20:42:42 <ddarius> Gracenotes: I "explained" it (albeit very cryptically if you don't know the syntax and notions) above.  Expanding.  Simply state that you have parametric polymorphism over all types (i.e. things of kind *) but give int and bool different kinds (# in GHC Haskell).
20:42:54 <SamB> I don't know why I said "I don't think you can", since I *know* that you *can't*
20:42:57 <Gracenotes> ah.
20:43:04 <int80_h> I remember when I took an advanced C class I would sit in the back practicing Lisp
20:43:07 <mmorrow> SamB: sure, but that doesn't matter since the only reason we're doing that here is to get a [a::#]
20:43:08 <ddarius> :k Int#
20:43:09 <lambdabot> Not in scope: type constructor or class `Int#'
20:43:23 <ddarius> :k Integer#
20:43:24 <lambdabot>     Not in scope: type constructor or class `Integer#'
20:43:27 <int80_h> so I could just sit in the back of the auditorium doing haskell
20:43:27 <ddarius> @hoogle Int#
20:43:28 <lambdabot> No results found
20:43:36 <ddarius> @hoogle GHC.Base.Int#
20:43:36 <lambdabot> No results found
20:43:38 <mmorrow> , src ''Int
20:43:39 * ddarius gives up.
20:43:41 <lunabot>  data Int = I# Int#
20:43:48 <Gracenotes> what's I#?
20:43:51 <ddarius> :k GHC.Base.Int#
20:43:52 <lambdabot> #
20:43:53 <mmorrow> a contructor
20:43:55 <ddarius> There we go.
20:44:03 <ddarius> :k Int
20:44:04 <lambdabot> *
20:44:11 <ddarius> :t map
20:44:13 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:44:18 <mmorrow> @type GHC.IO.IO undefined
20:44:19 <lambdabot> Not in scope: data constructor `GHC.IO.IO'
20:44:19 <conal> chessguy: hi.
20:44:22 <mmorrow> , ''IO
20:44:23 <lunabot>  GHC.IOBase.IO
20:44:27 <mmorrow> @type GHC.IOBase.IO undefined
20:44:28 <lambdabot> forall a. IO a
20:44:31 <mmorrow> heh
20:44:36 <SamB> :t [] :: [GHC.Base.Int#]
20:44:37 <lambdabot>     Expecting a lifted type, but `GHC.Prim.Int#' is unlifted
20:44:37 <lambdabot>     Expected kind `*', but `GHC.Prim.Int#' has kind `#'
20:44:37 <lambdabot>     In the type `[GHC.Prim.Int#]'
20:44:46 <Gracenotes> ooh. fancy error message, eh.
20:45:07 <chessguy> hiya conal  -- just thought you'd appreciate the simplicity of this code: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=830#a830
20:45:07 <Gracenotes> so, how could this be applied to Java?
20:45:11 <ddarius> In GHC Haskell, the fully expanded types tend to look like forall (a :: *) (b :: *). (a -> b) -> [a] -> [b]
20:45:24 <mmorrow> @type GHC.Base.I# 42#
20:45:25 <lambdabot> Int
20:45:38 <conal> chessguy: urg.  my isp blocks this url.  maybe it's the 8080
20:45:39 <Gracenotes> int is considered just as much a type as, say, Integer, in Java. At least at a cursory glance
20:45:40 <SamB> ddarius: well, that's nothing.
20:45:42 <chessguy> conal:  it's an implementation of propositional logic, maintaining every sentence in a normalized form
20:45:44 <ddarius> Gracenotes: Simply do exactly the same thing for Java.  Or rather it's just wordplay.  Simply say that int and bool have kind # not * and thus forall doesn't abstract over them.
20:45:47 <chessguy> aww
20:45:48 <pumpkin> conal: your ISP blocks stuff? :o
20:45:48 <SamB> in E, they tend to look like...
20:45:54 <Gracenotes> Java has kinds?
20:46:00 <mmorrow> conal: ah yeah, that's right. i know how to proxify that now. /me does it
20:46:03 <janine101> HI There Horn y GUys Pm me on Private....
20:46:09 <ddarius> Gracenotes: Not explicitly (but then neither does Haskell 98)
20:46:11 <int80_h> I think my ISP does traffic shaping, for limewire
20:46:17 <Gracenotes> mm.
20:46:22 <conal> mmorrow: swell
20:46:27 <int80_h> so I hear. I personally would never try and download files with limewire
20:46:27 <Gracenotes> the JVM specs might be the place for that
20:46:45 <pumpkin> mmorrow: why is it on 8080 btw?
20:47:29 <mmorrow> i guess not really any good reason. i just started it on that port one day and never took it down
20:47:33 <SamB> (a::*).(b::*).(a  b)  [a]  [b]
20:47:39 <Gracenotes> however, Java's type system is obviously different, so I'm not so sure about the parametric polymorphism claim (merely because the languages *could be* analogous)
20:48:02 <ddarius> SamB: Unicode makes it better?
20:48:07 <mmorrow> hmm, maybe i'll switch it
20:48:13 <pumpkin> mmorrow: omg I found your secret!
20:48:14 <SamB> ddarius: well, I thought it was going to be more impressive
20:48:32 <mmorrow> pumpkin: uhoh, which one?
20:48:33 <pumpkin> mmorrow: you could alwys keep 8080 as a redirect
20:48:40 <mmorrow> yeah, true
20:48:44 <pumpkin> mmorrow: you have directory listing on /images
20:48:50 <SamB> oh, and maybe those s get printed as s
20:48:51 <mmorrow> heh, i have a bunch
20:48:57 <Gracenotes> there's much more scholarly research on Java's type system, as far as I know :)
20:48:58 <mmorrow>  /repos
20:48:59 <Gracenotes> *not
20:49:05 <mmorrow> uh, others
20:49:06 <SamB> also it's in color, and the ::s are one char each ;-P
20:49:13 <pumpkin> mmorrow: omg, /pr0n
20:49:19 <mmorrow> oh noes!
20:49:54 <pumpkin> oh yesses
20:49:55 <mmorrow>  /docs
20:50:03 <monochrom> /haskell
20:50:05 <Gracenotes>  /tmp
20:50:37 <chessguy> @bot
20:50:37 <lunabot>  :)
20:50:38 <lambdabot> :)
20:50:47 <monochrom> :)
20:51:00 <pumpkin> epic name clash: http://moonpatio.com/repos/zfs/ZFS.hs
20:51:09 <janine1018> HI There Horn y GUys Pm me on Private....\
20:51:14 <pumpkin> omg monochrom's a bot!
20:51:34 <ddarius> pumpkin: Everyone knowns that.
20:51:36 <SamB> what's this? http://moonpatio.com/images/Rieger-Nishimura.svg
20:51:38 <pumpkin> any ops around?
20:51:39 <monochrom> Don't you think "pm me on private" is redundant? Like "automatic ATM teller machine".
20:51:40 <Gracenotes> even non-bots can appreciate a good botsnack
20:51:54 <pumpkin> monochrom: it's the RAS syndrome sort of
20:51:58 <sw17ch> it's very hard to decompose why one likes Haskell so as to describe why some one else should use it
20:52:20 * SamB sends a privmsg to the channel -- oh, but wait, this is actually an ACTION!
20:52:22 <ddarius> monochrom: Your ATMs are automatic?!
20:52:22 <monochrom> simple and elegant
20:52:35 <sclv> it makes you smarter
20:52:42 <conal> sw17ch: i like the reasons given in "why functional programming matters".  essentially modularity/reuse.
20:52:44 <SamB> monochrom: here we have to steal our money from our ATMs
20:52:50 <SamB> we don't got no automation
20:52:58 <pumpkin> I can't get no, automation
20:53:10 <chessguy> is it not legal to do "data Foo a = Foo [[a]]"?
20:53:14 <sw17ch> conal: wow. i can't believe i forgot that. i'm so nervous about this i'm missing the easy answers
20:53:23 <ddarius> chessguy: That is legal.
20:53:47 <sclv> alternately, you could just try to convince ppl that the law of excluded middles is a lie
20:54:19 <ddarius> The law of excluded middle -is- a lie!
20:54:42 <sclv> ddarius: I agree -- just not so easy to convince foax of that.
20:54:49 <pumpkin> foax?
20:54:58 <pumpkin> folks?
20:55:06 <ddarius> pumpkin: foax are fake folks
20:55:11 <pumpkin> hah
20:55:13 <monochrom> fox?
20:55:15 <chessguy> oh, i see the problem, never mind
20:55:16 <pumpkin> faux
20:55:23 <sclv> conal: btw, the question w/r/t least-strictness wasn't mine, it was ddarius'
20:55:27 <pumpkin> are faux foax folks?
20:55:35 <sclv> pumpkin: yes, foax = folks. everytime i type that somebody calls me out on it though.
20:55:54 <pumpkin> sclv: it'll sink in eventually :)
20:56:21 <mmorrow> conal. pumpkin: http://moonpatio.com
20:56:23 <conal> sclv: oh, thanks.
20:56:40 <pumpkin> mmorrow: but what about the diagrams??
20:56:44 <sclv> interestingly enough, i picked up the mannerism from thomas pynchon, who devoted quite some space in gravity's rainbow to the excluded middle...
20:57:02 <Nafai> Hrm
20:57:13 <mmorrow> i'm gonna shuffle some stuff around (including point moonpatio.com at this other better server i've got)
20:57:15 <Nafai> I wonder what kind of cool tools I can write in Haskell for work
20:57:30 <dibblego> @type \e f -> case e of Left x -> Left (f x); Right y -> Right y -- does this exist in the standard libraries somehow?
20:57:31 <lambdabot> forall t a b. Either t b -> (t -> a) -> Either a b
20:57:32 * ddarius should take another (deeper) look at call-by-push-value.
20:57:41 <ddarius> dibblego: Yes.
20:57:48 <ddarius> @src ArrowChoice
20:57:48 <lambdabot> Source not found. Just what do you think you're doing Dave?
20:57:53 <ddarius> :t left
20:57:54 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
20:57:58 <dibblego> ah thanks
20:58:04 <conal> ddarius: i hope you'll ask on the blog or email thread about why least-strict is useful, if you're still curious.
20:58:22 <mmorrow> throwing down the gauntlet!
20:58:26 <mmorrow> :)
20:58:38 <ddarius> conal: I've actually been meaning to for a while on the mailing list.
20:58:45 <conal> mmorrow: thanks!  now i can see hpastetwo
20:58:49 <mmorrow> yay!
20:59:16 <int80_h> what's teh address for hpastetwo?
20:59:27 <mmorrow> moonpatio.com:8080
20:59:37 <mmorrow> (it's at moonpatio.com also for the moment)
20:59:49 <conal> chessguy: tight!
20:59:58 <mmorrow> i'm gonna eventually today move it to moonpatio.com/paste
21:00:04 <mmorrow> where it'll be permanently
21:00:36 <chessguy> conal:  :)
21:00:56 <chessguy> conal:  i didn't even have to try to be clever to do it, once i had the right abstraction
21:01:24 <conal> chessguy: yep.  when the ideas/types are right, it just flows.
21:02:02 <conal> "Simplicity is the most difficult thing to secure in this world; it is the last limit of experience and the last effort of genius." - George Sand
21:02:12 <chessguy> nice
21:02:22 <mmorrow> that is nice
21:02:38 <rwbarton> chessguy: you could define  cs1 \/ cs2 = neg (neg cs1 /\ neg cs2)
21:03:01 <chessguy> rwbarton:  yeah, but i don't really like neg anyway
21:03:03 <int80_h> so what was wrong with the first hpaste?
21:03:08 <int80_h> seemed fine to me
21:03:09 <mmorrow> @quote octopus
21:03:09 <lambdabot> No quotes match. Do you think like you type?
21:03:32 <mmorrow> upon adding that to my "quotes" file, i found this gem
21:03:34 <mmorrow> <mwc> C++ is multiparadigm in the same way a dog with 4 table legs nailed onto it is an octopus
21:03:34 <conal> rwbarton: good call.
21:03:43 <pumpkin> mmorrow: awesome
21:03:52 <conal> mmorrow: lol
21:03:52 <rwbarton> chessguy: for some reason, I find the definition of (\/) in the hpaste very difficult to understand.  I think it's because I almost never use foldr except with an associatve operation
21:03:56 <ddarius> mmorrow: Don't make fun of octopooch.
21:04:05 <mmorrow> octopooch!
21:04:15 <SamB_XP> ddarius: you mean someone actually DID that???
21:04:16 <pumpkin> new name for lunabot!
21:04:18 <SamB_XP> horrible person!
21:04:26 <chessguy> rwbarton:  oh, i thought i switched that to a foldl'
21:04:27 <chessguy> hm
21:04:30 <pumpkin> or if nothing else, new name for pumpkinbot
21:04:34 <rwbarton> Well, same thing
21:04:36 <pumpkin> cause pumpkinbot kinda sucks as a nick
21:04:46 <chessguy> rwbarton:  yeah. it's a strange definition, to be sure
21:04:55 <conal> chessguy: also, (\/)'s f == (/\), right?
21:05:00 <mmorrow> octopooch is great
21:05:03 <chessguy> rwbarton:  as is "sequence" showing up in neg!
21:05:04 <dino-> Was hpaste the one done with happs?
21:05:21 <chessguy> conal:  eh?
21:05:23 <mmorrow> crap!!! someone already has octopooch.com
21:05:23 <int80_h> how about dinobot
21:05:24 <rwbarton> Of course, my definition is unnecessarily double-exponential
21:05:27 <chessguy> conal:  oh
21:05:39 <mmorrow> Leslie McGuirk
21:05:44 <mmorrow> Created on: 14-Mar-07
21:05:45 <sclv> the use of sequence is lovely.
21:05:48 <conal> chessguy: and you can eta-reduce (\/): (\/) = foldr (map . (/\))
21:05:49 <conal>  
21:05:50 <dino-> I should say "Is" instead of "Was"
21:05:57 <chessguy> conal:  i couldn't get that duplication to go away. sent an email to the mailing list. something's weird with the generalization of the type
21:06:05 <sclv> couldn't neg be: map (neg term) <$> sequence ?
21:06:05 <chessguy> conal:  yeah, i tried to do that, but it won't type check
21:06:07 <rwbarton> Yeah, 'neg' was much clearer, just de morgan + distributivity
21:06:11 <conal> chessguy: oh, sure.
21:06:29 <conal> chessguy: maybe because (/\) isn't given its most general type.
21:06:43 <chessguy> conal:  yeah, i guess, but it is annoying
21:07:09 <conal> @ty (nub .) . (++)
21:07:11 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
21:07:21 <SamB_XP> mmorrow: worse! it's squatters!
21:07:26 <rwbarton> @type union
21:07:27 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
21:07:33 <gwern> wonder why the committee picked 'Ix' instead of 'Idx'
21:07:33 <rwbarton> @src union
21:07:34 <lambdabot> union = unionBy (==)
21:07:35 <conal> rwbarton: that's my guess also.
21:07:38 <rwbarton> @src unionBy
21:07:38 <lambdabot> unionBy eq xs ys = xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
21:07:47 <int80_h> @src union
21:07:47 <lambdabot> union = unionBy (==)
21:07:48 <gwern> only just now did I realize what Ix was supposed to be short for Index
21:07:54 <int80_h> @src head
21:07:55 <lambdabot> head (x:_) = x
21:07:55 <lambdabot> head []    = undefined
21:08:02 <mmorrow> SamB_XP: scum!!@
21:08:10 <llayland> Is this just GHCi screwing with me?      let divM n d = n >>= \a ->  d >>= \b -> return $ div a b in (Just 1) `divM` (Just 0)   outputs    Just *** Exception: divide by zero
21:08:33 <mmorrow> , 1 `div` 0
21:08:34 <lunabot>  luna: divide by zero
21:08:43 <rwbarton> llayland: What would you expect? Nothing?
21:08:49 <chessguy> anyway, rwbarton's idea of writing \/ in terms of neg is probably best
21:08:58 <llayland> I know it should exception, not sure why it managed to get "Just" output
21:09:07 <monochrom> GHCi is not screwing with you. This is what the code does.
21:09:11 <SamB_XP> llayland: that's laziness for you
21:09:53 <mmorrow> , fix show
21:09:54 <lunabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\...
21:09:55 <mmorrow> , foldr (.) id (repeat read) $ fix show
21:10:00 <lunabot>  Stack space overflow: current size 8388608 bytes.
21:10:00 <lunabot>  Use `+RTS -Ksize' to increase it.
21:10:00 <llayland> SamB_XP - interesting,  unsafeIO or just more lazy than I thought?
21:10:08 <mmorrow> oh, usually prints a single "
21:10:11 <sclv> llayland: just more lazy.
21:10:12 <mmorrow> > foldr (.) id (repeat read) $ fix show
21:10:15 <monochrom> printing out "Just (1 `div` 0)" goes by printing out the Just part first before anyone cares about what 1 `div` 0 becomes.
21:10:15 <lambdabot>   "* Exception: stack overflow
21:10:15 <SamB_XP> llayland: lazier than you thought, is all
21:10:20 <mmorrow>  "*
21:10:25 <mmorrow> "
21:10:47 <SamB_XP> mmorrow: what ?
21:10:47 <llayland> This language never ceases to amaze and confound me :)  Thanks all
21:10:54 <mmorrow> > let x = x in show x
21:10:59 <newsham> llayland: one of its finest features
21:11:09 <lambdabot>   thread killed
21:11:15 <mmorrow> aww
21:11:29 <mmorrow> SamB_XP: ?
21:11:35 <pumpkin> when I took a scheme course, I was really disappointed when I found they'd stuck set! in
21:11:39 <mmorrow> , Just undefined
21:11:40 <lunabot>  luna: Prelude.undefined
21:11:40 <SamB_XP> why'd you paste that quoty stuff?
21:11:43 <newsham> > let x = show x in x
21:11:45 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
21:11:46 <mmorrow> , show (Just undefined)
21:11:47 <lunabot>  luna: Prelude.undefined
21:12:01 <lpjhjdh> has anyone discovered a clever way of doing something like "f : Int -> Peano n" with n being phantom?
21:12:23 <mmorrow> what would n be in that case?
21:12:23 <pumpkin> lpjhjdh: don't think it's possible
21:12:27 <SamB_XP> lpjhjdh: it's not possible
21:12:30 <lpjhjdh> as I suspected, thanks
21:12:32 <mmorrow> it's impossible without dependent types
21:12:34 <SamB_XP> you need dependant types for that stuff
21:12:48 <pumpkin> GHC 6.12! :P
21:12:52 <SamB> then you could have
21:12:53 <pumpkin> more like GHC 8
21:12:54 <mmorrow> i hope
21:12:56 <rwbarton> lpjhjdh: the standard trick is to instead write a function like reifyIntegral here: http://hackage.haskell.org/packages/archive/type-level/0.2.2/doc/html/Data-TypeLevel-Num-Sets.html
21:12:57 <mmorrow> :(
21:13:41 <pumpkin> rwbarton: I don't really get how that works, still :P
21:13:43 <mmorrow> pumpkin: hopefully there'll be a deptype lang that's useable for general purpose/everyday things before ghc8
21:13:51 <mmorrow> (lang + implementation)
21:14:02 <SamB> f :: n::Int. someTypeFunction n
21:14:02 <pumpkin> mmorrow: or just a GHC extension to haskell, which I'd be quite happy with
21:14:09 <lpjhjdh> what about agda?
21:14:12 <mmorrow> that would be sweet
21:14:27 <pumpkin> lpjhjdh: it looks nice, but ghc/haskell makes me feel warm and fuzzy
21:14:31 <mmorrow> lpjhjdh: personally i want a turing complete language
21:14:32 <pumpkin> when I get some time I'd like to play with agda to
21:14:41 <pumpkin> *too
21:14:43 <lpjhjdh> doesn't agda have codata?
21:14:51 <SamB> mmorrow: turing complete + dependantly type is a combination that makes me nervous
21:14:52 <mmorrow> i want arbitrary general recursion
21:15:08 <mmorrow> let x = x in x -- yay!!!
21:15:11 <SamB> I might never get my type errors!
21:15:18 <mmorrow> ^C
21:15:43 <SamB> of course, GHC can loop the optimizer as it is ...
21:15:47 <pumpkin> SamB: would still be nice as a language option :)
21:16:18 <SamB> well, I guess it would make sense to allow recursion if the user promises to be extra careful
21:16:22 <monochrom> I want telepathic interface.
21:16:25 <mmorrow> also, i want to use the same exact constructs/syntax for both types _and_ expressions
21:16:33 <pumpkin> type functions!
21:16:38 <mmorrow> just functions
21:16:43 <SamB> mmorrow: that's fairly standard
21:17:05 <pumpkin> http://upload.wikimedia.org/wikipedia/commons/4/41/Mediawiki-database-schema.png? ugh
21:17:12 <mmorrow> SamB: but not being able to use general recursion + IO in the computation of types
21:17:26 <SamB> that's where it gets tricky
21:17:35 <SamB> (the general computation, not the IO ;-P)
21:17:37 <Gracenotes> pumpkin: considering how much it has to scale, not-that-ugh
21:17:50 <mmorrow> SamB: indeed
21:18:02 <monochrom> krad database schema :)
21:18:11 <pumpkin> Gracenotes: considering the realities of relational DBs, yeah, it's impressive, but ideally a schema designer should have an easier time than that :)
21:19:23 <dons> hey guys. i've moved my blog posts from the last 3.5 years to a new site, they should be much more accessible now. i'd like feedback on the layout and design. http://donsbot.wordpress.com/
21:19:37 <dons> apparently i write a lot about haskell, i've discovered.
21:19:51 <Nafai> dons: No way!
21:19:57 <dons> for real.
21:20:11 <sw17ch> dons: pretty pie graph :)
21:20:16 <monochrom> This is the fastest wordpress site I've ever seen.
21:20:26 <mmorrow> dons: looks nice
21:20:48 <dons> the tag cloud is interesting. i actually learnt something from it.
21:21:05 <mmorrow> being?
21:21:30 <dons> i'm interested in performance and packaging.
21:21:34 * Gracenotes clicks the zipper tag
21:21:37 <mmorrow> heh
21:21:48 <pumpkin> dons: I like it, but I think the main content column could be a teensy bit wider
21:21:58 <pumpkin> unless you're aiming for people with small screens
21:22:07 <pumpkin> I'm on a macbook air and it's still pretty small :)
21:22:22 <mmorrow> oh, my browser wasn't maximized
21:22:26 <dons> yeah, me too.
21:22:26 <dons> i wonder how to adjust that. mmm
21:22:26 <mmorrow> i agree with pumpkin
21:22:33 <dino-> dons: Let me guess: you don't speak nearly as much about cylons as you ought to?
21:22:52 <dons> that's true enough.
21:22:55 <Gracenotes> <div id="content" class="narrowcolumn">
21:23:14 <Gracenotes> #content -- with: 400px
21:23:17 <Gracenotes> *width
21:23:22 <dino-> Also, boy do we need to do something with all the Other things on hackageorama.
21:23:41 <dino-> It's a big green junk drawer.
21:23:44 <dons> Gracenotes: thanks. i'll see if i can tweak it
21:23:53 <Gracenotes> it's defined here: http://s3.wordpress.com/wp-content/themes/pub/whiteasmilk/style.css?m=1219803973b
21:24:10 <Gracenotes> so, probably, make a modified copy, attribute, etc. :)
21:24:18 * sw17ch senses FireBug-foo
21:24:31 <davidL> is it possible to do recursion using only lambdas?
21:24:43 <Gracenotes> me? Firebug? X>X
21:24:53 * Gracenotes backs away slowly from the browser
21:24:53 <dibblego> where is instance Monad (Either e) hiding?
21:24:58 * sw17ch points accusingly at Gracenotes
21:25:15 <QtPlatyp1s> davidL: It is in simply typed LC.
21:25:33 <davidL> QtPlatyp1s: what about in haskell?
21:25:51 <mmorrow> y = \f -> (\x -> f (x x)) (\x -> f (x x))
21:25:52 <newsham> davidl: is it fair to use "fix" ?
21:26:00 <mmorrow> @type \f -> (\x -> f (x x)) (\x -> f (x x))
21:26:01 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
21:26:02 <lambdabot>     Probable cause: `x' is applied to too many arguments
21:26:02 <lambdabot>     In the first argument of `f', namely `(x x)'
21:26:04 <mmorrow> @type fix
21:26:06 <lambdabot> forall a. (a -> a) -> a
21:26:07 <pumpkin> dibblego: Control.Monad.Instances has a Functor for it
21:26:09 <ddarius> QtPlatyp1s: Untyped
21:26:09 <sw17ch> FireBug is such a fantastic tool... i suggest you all install it even if you don't do much web development
21:26:19 <mmorrow> fix is the same thing
21:26:24 <dibblego> pumpkin, I want the Monad
21:26:31 <davidL> @src fix
21:26:31 <lambdabot> fix f = let x = f x in x
21:26:35 <QtPlatyp1s> ddarius: Yeah, untyped.
21:26:40 <Gracenotes> dibblego: grep -ir 'instance Monad' code/extproj/ghc/ | grep Either
21:26:43 <Gracenotes> yields nothing :/
21:26:51 <dibblego> @instances Monad
21:26:52 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
21:26:54 <newsham> > fix (\f n -> if n == 0 then 1 else n * f (n-1)) 5
21:26:56 <lambdabot>   120
21:26:59 <rwbarton> dibblego: Control.Monad.Error I think
21:27:00 <pumpkin> @src Either (>>=)
21:27:00 <lambdabot> Left  l >>= _ = Left l
21:27:00 <lambdabot> Right r >>= k = k r
21:27:01 <ddarius> davidL: Types were explicitly designed (originally) to keep you from making fix with just lambdas.
21:27:12 <pumpkin> rwbarton: I hope not :(
21:27:18 <mmorrow> , fix (\go x -> if x > 10 then x else go (x+3)) 0
21:27:19 <lunabot>  12
21:27:29 <rwbarton> Gracenotes: there's a context on the 'a' in 'Either a', I think
21:27:32 <davidL> ah
21:27:51 <Gracenotes> rwbarton: oh, good point
21:28:03 <pumpkin> , Left 4 >>= return (+1)
21:28:04 <lunabot>  luna: The section `GHC.Num.+ 1' takes one argument,
21:28:20 <mmorrow> , fix (\me -> Node () [me,me]) {- infinite binary tree -}
21:28:21 <lunabot>  Node {rootLabel = (), subForest = [Node {rootLabel = (), subForest = [Nod...
21:28:22 <newsham> davidl: also if you define your data types appropriately you can define them with structural recursion built in to them
21:28:31 <mmorrow> , levels (fix (\me -> Node () [me,me])) {- infinite binary tree -}
21:28:32 <lunabot>  [[()],[(),()],[(),(),(),()],[(),(),(),(),(),(),(),()],[(),(),(),(),(),(),...
21:28:33 <newsham> so that you dont need to use recursion directly to traverse them
21:28:44 <Gracenotes> rwbarton: no... can't find it
21:29:55 <mmorrow> , fmap length $ levels (fix (\me -> Node () [me,me]))
21:29:58 <lunabot>  luna: out of memory (requested 1048576 bytes)
21:30:00 <rwbarton> instance (Error e) => Monad (Either e) -- Defined in Control.Monad.Error
21:30:04 <rwbarton> says ghci
21:30:07 <mmorrow> , fmap length $ levels (fix (\me -> Node () [me,me]))
21:30:10 <lunabot>  luna: out of memory (requested 1048576 bytes)
21:30:19 <Gracenotes> as far as I can tell, Either, Monad, and instance don't appear on the same line, says grep
21:30:22 <mmorrow> , fmap length . take 10 $ levels (fix (\me -> Node () [me,me]))
21:30:24 <lunabot>  [1,2,4,8,16,32,64,128,256,512]
21:30:56 <chessguy> @src unionBy
21:30:56 <lambdabot> unionBy eq xs ys = xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
21:31:40 * ddarius wonders how important polymorphic recursion is to OO.
21:31:48 <rwbarton> Gracenotes: It's in the mtl package, maybe that's the problem?
21:32:05 <Gracenotes> ...that's certainly it, yes
21:32:15 <ddarius> @pl  unionBy eq xs ys = xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
21:32:16 <lambdabot> unionBy = liftM2 (.) (++) . flip . ap ((.) . foldl . flip . deleteBy) nubBy
21:32:19 <Gracenotes> I don't have the source for MTL anywhere in the GHC directory; it's just for reference
21:32:35 <Gracenotes> I think I should download some useful packages for more grepping :)
21:50:17 <llayland> quick shameless plug before I have to run: llayland.wordpress.com/2009/01/21/understanding-monads-i/
21:59:12 <nikki93> How does one know when a user last came here?
21:59:19 <nikki93> Some bot, andthen 'seen blah' or something?
21:59:50 <jeffz`> @seen nikki93
21:59:50 <lambdabot> nikki93 is in #haskell. I last heard nikki93 speak 30s ago.
22:01:32 <Gracenotes> and preflex has an even better memory
22:04:16 <Gracenotes> a Context is basically equal to a Zipper, right?
22:04:26 <pumpkin> can anyone think of a better way of doing this?
22:04:27 <pumpkin> columnU :: (UA a) => [UArr a] -> Int -> UArr a
22:04:27 <pumpkin> columnU xs i = toU $ map (`indexU` i) xs
22:04:45 <Gracenotes> if not in type, in use?
22:05:32 <pumpkin> the way I did it there makes me cringe
22:05:49 <pumpkin> and not surprisingly eats up most of my time, in a profiling session
22:06:18 <pumpkin> dons: do you know if indexU is really O(1) on a UArr?
22:09:58 <dons> pumpkin: there's two of them.
22:10:01 <dons> the fused, and unfused ones.
22:10:18 <pumpkin> hmm
22:10:48 <pumpkin> I'm rewriting it using a preallocated UArr with unfoldU now
22:10:49 <dons> i'm not sure you currently get to choose, but i sure would like to have that.
22:11:02 <dons> i.e. two separate apis, one which tries to always fuse, one which doesn't.
22:11:10 <pumpkin> ah
22:11:19 <pumpkin> many of the methods say "fusion" in them
22:11:30 <pumpkin> I assume those are the ones that do stuff specific to UArr
22:11:43 <pumpkin> whereas the rest defer to the S functions?
22:13:08 <pumpkin> boo, MaybeS isn't a MonadPlus :(
22:20:45 <pumpkin> bah, no faster
22:21:43 <pumpkin> what's a better way to do this, hmm
22:25:59 <bos> dons: is uvector going to retain the ticcy U and S suffixes on the ends of names?
22:27:39 <nikki93> I'm reading 'Real world haskell', but after a while, it got boring.
22:27:44 <nikki93> I've reached the IO chapter.
22:27:52 <nikki93> From there, it starts teaching a lot of library functioons.
22:28:03 <nikki93> Is it fine to skp all that and jump to Monads?
22:28:12 <nikki93> Right now I'm interested in learning the language itself.
22:28:17 <pumpkin> nikki93: boring :o
22:28:38 <pumpkin> the two non-me people to speak before you are two of the authors btw :)
22:29:00 <pumpkin> nikki93: but sure, I don't think anyone will kill you if you skip around a bit and use it more as a reference
22:29:20 <pumpkin> , [$ty| 1 |]
22:29:25 <lunabot>  forall a . Num a => a
22:29:45 <pumpkin> , [$ty| replicate 5 $ newMU 5 |}
22:29:46 <lunabot>  luna: lexical error in string/character literal at end of input
22:29:46 <mmorrow> this is interesting: implicit params + GADTs interaction: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=831#a831
22:29:53 <pumpkin> , [$ty| replicate 5 (newMU 5) |}
22:29:54 <lunabot>  luna: lexical error in string/character literal at end of input
22:29:58 <mmorrow> }
22:29:59 <pumpkin> , [$ty| replicate 5 (newMU 5) |]
22:30:01 <lunabot>  forall a b . UA a => [] (ST b (MUArr a b))
22:30:40 <dons> bos, we can negotiate..
22:30:43 <pumpkin> anyone have any idea how I'd get from a list of those
22:30:43 <dons> nobody likes them.
22:30:48 <bos> :-)
22:30:54 <pumpkin> to a list of UArrs, using unsafeFreezeAllST?
22:30:55 <pumpkin> MU
22:30:56 <dons> they're in RWH though
22:30:56 <pumpkin> sorry
22:31:08 <dons> in a tiny little corner
22:31:14 * juhp builds darcs-2.2.0 for Fedora 10
22:31:25 <dons> see my email anyway. i'm keen to make this work.
22:31:48 <pumpkin> this damn transpose function is hard :P
22:32:37 <dons> hey, this is cool. http://hackage.haskell.org/cgi-bin/hackage-scripts/package/progressbar-0.0.1
22:33:36 <dons> HackageDB statistics
22:33:36 <dons> 273 users have uploaded 3160 versions of 999 packages.
22:33:38 <dons> ...
22:33:45 <Heffalump> lol
22:34:00 * dons is happy
22:34:15 <pumpkin> hrm
22:34:48 <Heffalump> mmorrow: how is it any better than just having the a value in the GADT explicitly?
22:35:16 <bos> dons: thanks for the email
22:35:17 <dons> bos, we might want to set up uvector as a community project with join commit access
22:35:18 <Heffalump> or indeed different in any observable way
22:35:29 <dons> so we can interleave development until Data.Text is done.
22:35:29 <bos> dons: i think that makes sense
22:35:41 <dons> ok. i'll make it so.
22:35:46 <bos> dons++
22:35:48 * Heffalump disappears to work, but I'll read any replies this evening
22:35:50 <bos> thanks!
22:35:53 * pumpkin needs zipWithU651
22:35:59 <dons> i think this is a good chance to demand the evaluation of uvector :)
22:35:59 <pumpkin> *651U
22:36:16 <pumpkin> dons: I have a few things I'd like to contribute to it :P
22:36:26 <dons> yay!
22:36:27 <pumpkin> most of all, better docs :P
22:36:30 <dons> yes. good good.
22:36:42 <pumpkin> and, of course, zipWith651U
22:36:43 <pumpkin> ;)
22:36:46 <dons> well, its never been "officially" released. it got most of the way there, and people started using it.
22:36:53 <dons> so now we can actually finish it.
22:36:55 <pumpkin> ah, that explains a lot
22:37:19 <dons> in particular, some small API changes, and docs (due to haddock not working on associated types till recently)
22:37:21 <pumpkin> fstU is faster than mapU fstS I assume?
22:37:35 <dons> one will be linear. pick which one.
22:37:44 <pumpkin> :)
22:39:01 <pumpkin> dons: do you have any hints on how I might do transposeU efficiently (with a list of UArrs)?
22:39:14 <pumpkin> I was thinking of breaking it into chunks of 3 and using zipWith3U
22:39:21 <pumpkin> but was hoping there'd be a less painful way
22:39:40 <dons> pumpkin: i'm not sure of the best way, no.
22:40:04 * bos <*> bed
22:40:43 <pumpkin> oh I can't use zipWith3U
22:42:41 <pumpkin> oh maybe sliceU will be the answer
22:42:58 <pumpkin> or just tailU
22:44:35 <mmorrow> Heffalump: i'm not sure
22:45:26 <mmorrow> Heffalump: but i /have/ used the similar trick of a putting either a class constraint or an equality constraint on a GADT con so i didn't have to write the context in any type sigs
22:45:56 <mmorrow> so that's my main motivation for this, not having to write out the annoying (?foo::...) => before every type sig
22:46:07 <mmorrow> but then i got to thinking ....
22:46:30 <mmorrow> i wonder if there's something cool that this would enable
22:47:19 <mmorrow> (in particular i've found this super nice for eliminating the need to constantly be writing (Ord a):
22:47:25 * pumpkin 's head explodes trying to think about this
22:47:28 * pumpkin perseveres
22:47:37 <mmorrow> data a:->b where Map (Ord a) => Map a b -> (a:->b)
22:47:48 <mmorrow> then you get to do
22:48:13 <mmorrow> (a :-> b) -> a -> Maybe b   for lookup
22:48:16 <mmorrow> etc
22:49:11 <mmorrow> the GADTs seem to _remember_ the class constraint, fixing the annoyingness of how class constraints on regular ADTs are useless
22:49:30 <mmorrow> (because you have to write the constraint all over the place anyways)
22:50:15 <Uzi-Suicide> hello
22:50:15 <pumpkin> I'm trying to use a foldM to fold over a list of UArrs and set values in a list of MUArrs as an (ST) sideffect
22:50:19 <pumpkin> does that sound wrong?
22:50:37 <mmorrow> Uzi-Suicide: don't do it!!@
22:50:56 <Uzi-Suicide> someone stole my nick Uzi
22:50:57 <mmorrow> pumpkin: that sounds ok to me
22:51:02 <mmorrow> Uzi-Suicide: :)
22:51:10 <Uzi-Suicide> :-)
22:51:15 <Uzi-Suicide> big channel
22:51:17 <pumpkin> mmorrow: not sure it's possible the way I want to do it
22:51:26 <pumpkin> I'm actually folding over the list of MUArrs
22:51:33 <pumpkin> and using the list of UArrs as my accumulator
22:51:39 <Axman6m> @users
22:51:39 <lambdabot> Maximum users seen in #haskell: 642, currently: 568 (88.5%), active: 11 (1.9%)
22:51:41 <mmorrow> pumpkin: ah yeah, that sounds dubious
22:51:48 <Axman6m> we're shrinking!
22:51:51 <pumpkin> mmorrow: but I need to do it that way :/
22:51:59 <mmorrow> (are you getting "the s escapes" thing?)
22:52:10 <pumpkin> mmorrow: I can barely even write the expression :P
22:52:19 <mmorrow> pumpkin: sounds like you need an "unsafeThaw"
22:52:26 <pumpkin> mmorrow: my issue is that foldM wants a -> b -> m a
22:52:32 <pumpkin> and I'm really giving it a -> b -> m b
22:52:37 <Uzi-Suicide> only 11 users active
22:52:40 <Uzi-Suicide> haha
22:52:41 <pumpkin> which is clearly wrong
22:52:45 <mmorrow> ohh, so foldM is really a foldl
22:52:51 <pumpkin> mmorrow: well, not even though
22:52:54 <mmorrow> sounds like you need a foldr
22:52:59 <Axman6m> :t foldM
22:52:59 <pumpkin> mmorrow: I guess I'm trying to accumulate two things at once
22:53:00 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
22:53:26 <pumpkin> mmorrow: I'm accumulating my "edits" to the list of MUArrs and changes to the list of UArrs at once
22:53:26 <mmorrow> pumpkin: hmm, but couldn't you just flip your binary ufunction you pass in?
22:53:46 <mmorrow> hmm
22:53:54 <mmorrow> i dunno
22:54:03 <mmorrow> (exactly what the situation is)
22:54:12 <pumpkin> :(
22:54:14 <pumpkin> hmm
22:54:45 <pumpkin> mmorrow: I'm trying to write transposeU avoiding indexU
22:55:28 <mmorrow> why don't you just foldM and accumulate only MUArrs, then unsafeFreeze at the end?
22:55:45 <int80_h> @src head
22:55:45 <lambdabot> head (x:_) = x
22:55:45 <lambdabot> head []    = undefined
22:55:51 <pumpkin> mmorrow: well, I have a list of UArrs as input and need to give a list of UArrs as output
22:56:01 <pumpkin> mmorrow: I was going to unsafeFreezeAllMU
22:56:16 <mmorrow> , [$ty| unsafeFreezeAllMU |]
22:56:18 <lunabot>  forall a b . UA b => (MUArr b a) -> ST a (UArr b)
22:56:25 <mmorrow> , [$ty| unsafeFreezeMU |]
22:56:25 <pumpkin> but I need to maintain the (size of other dimension) MUArrs
22:56:27 <lunabot>  forall a b . UA b => (MUArr b a) -> Int -> ST a (UArr b)
22:56:39 <mmorrow> um, what's the diff?
22:56:59 <pumpkin> you'd call unsafeFreezeMU mu (lengthMU mu)
22:57:04 <pumpkin> or unsafeFreezeAll mu
22:57:18 <mmorrow> ah, so unsafeFreezeMU just lets you freeze a prefix
22:57:22 <pumpkin> yup
22:57:22 <mmorrow> as a convenience
22:57:42 <mmorrow> so you're trying to write:
22:58:04 <mmorrow> transposeMU :: [UArr a] -> [UArr a]  ?
22:58:08 <pumpkin> so what I'm trying to do is fold over the list of UArrs as input, and each iteration, map tailU to the UArrs, writing map headU into my current MUArr
22:58:18 <pumpkin> transposeU, but yeah
22:58:21 <int80_h> @src tail
22:58:21 <lambdabot> tail (_:xs) = xs
22:58:21 <lambdabot> tail []     = undefined
22:58:23 <mmorrow> ueah
22:58:23 <nikki93> @quote nikki93
22:58:23 <lambdabot> nikki93 says: > let laughAtPerson n y = if (n > 0) then "ha" ++ laughAtPerson (n - 1) y else "aa " ++ y ++ "! :P" in "Ha" ++ (laughAtPerson 8 "ehird")
22:58:35 <pumpkin> mmorrow: I have a really naive one that's a complete slug
22:58:35 <nikki93> > let laughAtPerson n y = if (n > 0) then "ha" ++ laughAtPerson (n - 1) y else "aa " ++ y ++ "! :P" in "Ha" ++ (laughAtPerson 8 "pumpkin")
22:58:36 <lambdabot>   "Hahahahahahahahahaaa pumpkin! :P"
22:58:39 <nikki93> :D
22:58:52 <mmorrow> pumpkin: can you assume that all the UArrs have the same length?
22:58:55 <pumpkin> yeah
22:59:11 <pumpkin> if I could just figure out how to maintain "two accumulators" over my fold
22:59:21 <pumpkin> I think it would be marginally more efficient, assuming tailU is constant time
22:59:23 <nikki93> ghci(i) is implemented in haskell?
22:59:31 <nikki93> Are there any haskell implementations around in C++?
22:59:35 <dons> nikki93: nope.
22:59:42 <pumpkin> nikki93: all of ghc is in haskell, except for the runtime
22:59:42 <int80_h> why would there be?
22:59:43 <dons> there's one in C, all others in Haskell.
22:59:52 <dons> (hugs is written in C)
22:59:56 <nikki93> Also, ghc has the option to compile to '.hc', what's that?
23:00:07 <pumpkin> it doesn't have to use its own native code generator
23:00:22 <dons> they're c files, with macros to hook back into the ghc runtime
23:00:27 <nikki93> dons: Hugs vs. GHC, what's the difference? (not comparision, but I mean language differences)
23:00:36 <nikki93> dons: Hmm?
23:00:47 <dons> .hc files.
23:00:59 <nikki93> dons: Yes, I didn't understand what you said fully.
23:01:03 <dons> hugs implements haskell 98 plus some small set of extensions
23:01:18 <dons> ghc implements 80% of all extensions ever created by computer science  ;)
23:01:22 <nikki93> lol
23:01:30 <int80_h> just 80%?
23:01:31 <Axman6m> nikki: i think it's time you moved away from repetitiuos string insults and learned some monads :P
23:01:45 <pumpkin> Axman6m++
23:01:56 <Axman6m> Axman6++ *
23:02:04 <Axman6m> @karma Axman6
23:02:04 <lambdabot> Axman6 has a karma of 6
23:02:08 <Axman6m> :)
23:02:11 <int80_h> one step at a time, he might want to complete a good tutorial first
23:02:19 <mmorrow> \us@(u:_) -> runST (do mus <- mapM (newMU (lengthU u)); foldM (\i u -> zipWithM_ writeMU mus (toListU u) >> return (i+1)) 0 us; mapM unsafeFreezeAll mus) -- ?
23:02:22 <Axman6m> bah!
23:02:31 <pumpkin> int80_h: I think the point is, he might want to not do the repetitious string insults anymore ;)
23:02:35 <nikki93> I was thinking of, you must have heard by now, using haskell as a scripting language for a computer game in C++ blabla.
23:02:36 <int80_h> @karma int80_h
23:02:36 <lambdabot> You have a karma of 0
23:02:38 <pumpkin> mmorrow: let me digest that
23:02:39 <mmorrow> (i dunno what toListU is)
23:02:42 <mmorrow> , toListU
23:02:43 <lunabot>  luna: Not in scope: `toListU'
23:02:45 <nikki93> @karma nikki93
23:02:45 <lambdabot> You have a karma of 0
23:02:47 <nikki93> :(
23:02:51 <mmorrow> what's the func for that?
23:02:58 <nikki93> @givemekarmassss
23:02:58 <lambdabot> Unknown command, try @list
23:03:04 <mmorrow> , readU
23:03:05 <lunabot>  luna: Not in scope: `readU'
23:03:05 <nikki93> lambdabot: Go #^$% yerself.
23:03:11 <mmorrow> , indexU
23:03:12 <lunabot>  luna: No instance for (GHC.Show.Show
23:03:23 <mmorrow> oh, now i know what you don't want to do
23:03:24 <nikki93> So will checking out Hugs source code help?
23:03:36 <pumpkin> mmorrow: toU/fromU?
23:03:41 <mmorrow> ah
23:03:41 <nikki93> Will having hugs and ghc(i) on the same computer cause conflict? (lol_
23:03:43 <pumpkin> mmorrow: yeah, indexU seems pretty slow
23:03:52 <pumpkin> mmorrow: or at least simply doing the obvious thing
23:03:52 <mmorrow> , [$ty| fromU |]
23:03:54 <lunabot>  forall a . UA a => (UArr a) -> [] a
23:04:01 <mmorrow> , [$ty| indexU |]
23:04:03 <lunabot>  forall a . UA a => (UArr a) -> Int -> a
23:04:15 <int80_h> @src last
23:04:15 <lambdabot> last [x]    = x
23:04:15 <lambdabot> last (_:xs) = last xs
23:04:15 <lambdabot> last []     = undefined
23:04:30 <pumpkin> mmorrow: the thing is, I'd expect indexU to be fast, given that it's an array and all
23:04:53 <int80_h> nikki93: didn't you say you were working through RWH?
23:05:06 <mmorrow> , let xpose us@(u:_) = runST (do mus <- mapM (newMU (lengthU u)); foldM (\i u -> zipWithM_ writeMU mus (toListU u) >> return (i+1)) 0 us; mapM unsafeFreezeAll mus); xs = fmap toU [[0..3],[4..7]] in xpose xs
23:05:07 <lunabot>  luna: Not in scope: `toListU'
23:05:14 <mmorrow> , let xpose us@(u:_) = runST (do mus <- mapM (newMU (lengthU u)); foldM (\i u -> zipWithM_ writeMU mus (fromU u) >> return (i+1)) 0 us; mapM unsafeFreezeAll mus); xs = fmap toU [[0..3],[4..7]] in xpose xs
23:05:15 <lunabot>  luna: Not in scope: `unsafeFreezeAll'
23:05:27 <nikki93> int80_h: I was, it got boring as hell.
23:05:40 <nikki93> {- .* -} is blockcomment?
23:05:46 <pumpkin> yes
23:05:54 <int80_h> nikki93: what about YAHT?
23:05:58 <nikki93> pumpkin: Aha! I KNEW IT! KNEEEW IT!
23:06:11 <nikki93> pumpkin: I really knew it! Reallly!
23:06:13 <pumpkin> , let xpose us@(u:_) = runST (do mus <- mapM (newMU (lengthU u)); foldM (\i u -> zipWithM_ writeMU mus (fromU u) >> return (i+1)) 0 us; mapM unsafeFreezeAllMU mus); xs = fmap toU [[0..3],[4..7]] in xpose xs
23:06:14 <lunabot>  luna: Couldn't match expected type `a -> m b'
23:06:38 <nikki93> , sdsd
23:06:39 <lunabot>  luna: Not in scope: `sdsd'
23:06:43 <nikki93> > sdsd
23:06:44 <lambdabot>   Not in scope: `sdsd'
23:06:55 <nikki93> lunabot is lambdabot's girlfriend or somethin'?
23:06:59 <pumpkin> yeah
23:07:06 <nikki93> Her name's hot
23:07:56 <int80_h> ah exercise 1, chapter 4 is easy. for a change.
23:08:04 <int80_h> prolly just a warm up
23:08:19 <nikki93> int80_h: which book?
23:08:22 <int80_h> RWH
23:08:46 <mmorrow> , let xpose us@(u:_) = runST (do mus <- replicateM (lengthU u) (newMU (length us)); foldM (\i u -> zipWithM_ (flip writeMU i) mus (fromU u) >> return (i+1)) 0 us; mapM unsafeFreezeAllMU mus); xs = fmap toU [[0..3],[4..7]] in xpose xs
23:08:47 <lunabot>  [toU [0.0,4.0],toU [1.0,5.0],toU [2.0,6.0],toU [3.0,7.0]]
23:08:49 <int80_h> I'm willing to go through the boring stuff to get to the interesting stuff
23:08:58 <int80_h> quid pro quo
23:09:04 <pumpkin> mmorrow: o.O
23:09:25 <mmorrow> pumpkin: so i guess that's just trading a one-off fromU for every UArr for a bunch of indexUs
23:09:31 <mmorrow> maybe that's faster though
23:10:03 <nikki93> int80_h: How's YAHT?
23:10:08 <int80_h> nikki93: implementing the graham scan algorithm, with language constraints, proved to be engaging, edifying, and interesting.
23:10:38 <pumpkin> mmorrow: I'll run a test
23:10:44 <nikki93> int80_h: In RWH, is it ok to skip the JSON part?
23:10:47 <int80_h> nikki93: well, it will give you a broad introduction to the language. But you won't be using it to build any applications. Not directly. RWH is good about that.
23:10:51 <nikki93> int80_h: Its ultraboring.
23:11:08 <int80_h> nikki93: I was thinking the same thing. I'm not going to skip it in hopes it proves to be a good example in library design
23:11:20 <mmorrow> pumpkin: (err, i meant trading a bunch of indexUs for a one-off fromU for each u, but you knew that)
23:11:28 <nikki93> int80_h: No, you just have too much free time.
23:11:32 <nikki93> int80_h: :P
23:11:36 <int80_h> the JSON part I mean. Also JSON is used in later chapters. So you might lose some continuity
23:11:51 <nikki93> int80_h: Ok.
23:11:56 <nikki93> int80_h: I'm gonna go do it now.
23:11:59 <nikki93> int80_h: How long does it take?
23:12:21 <int80_h> I haven't done the exercises. I just skipped ahead in the reading. As far as the exercises go, I'm on chapter 4
23:12:33 <int80_h> I just finished the graham scan algorithm
23:12:43 <pumpkin> mmorrow: quite a bit better :o
23:12:44 <int80_h> took me, oh...a freaking week and a half to do that.
23:12:49 <int80_h> but I learned alot
23:12:51 <mmorrow> pumpkin: cool
23:12:57 <mmorrow> hmm
23:13:21 <nikki93> int80_h: What's graham scan?
23:13:21 <pumpkin> mmorrow: my idea was to make myself a list of MUArrs of the right size, and then repeatedly map tailU to my accumulator on the original
23:13:30 <mmorrow> i guess you could also just        fmap toU (transpose (fmap fromU us))
23:13:32 <pumpkin> sticking map headU into my list of MUArrs
23:13:44 <mmorrow> ohh, i see yeah
23:13:53 <int80_h> nikki93: it's an algorithm to find the hull of a set of points.
23:13:58 <pumpkin> mmorrow: but I couldn't get the ST-ness  to work out there
23:14:03 <int80_h> giving a set a points, it will return the hull
23:14:17 <mmorrow> the nice thing about mutable things is you don't need to bother taking them along in an accumulator
23:14:20 <int80_h> the end of chapter three explains where you can find details.
23:14:47 <pumpkin> mmorrow: well, the issue was that I still need to pass around the ST for the mutable thing, but I also needed to pass my list of tails around
23:14:50 <pumpkin> *tailUs
23:14:54 <int80_h> @src init
23:14:55 <lambdabot> init [x]    = []
23:14:55 <lambdabot> init (x:xs) = x : init xs
23:14:55 <lambdabot> init []     = undefined
23:14:58 <mmorrow> ah yeah, true
23:15:23 <int80_h> the functions I've been looking at the source for, I have to implement the safe version of. Easy.
23:18:06 <nikki93> int80_h: COnvex hull?
23:18:22 <int80_h> nikki93: that's right
23:19:00 <int80_h> if you stick to the restriction of using only what's been introduced by the text, there's some behaviors of pattern matching to be discovered
23:19:19 <int80_h> but, you can use idiomatic haskell, and be done much faster
23:19:54 <nikki93> How's Hugs
23:20:01 <int80_h> it's a toy
23:20:23 <mmorrow> pumpkin: you could also make that function support UArrs of differing lengths by giving (minimum (fmap lengthU us)) to replicateM
23:20:35 <nikki93> I'm thinking of checking out the source and writing a haskell interpretter library for C++ to use haskell for scripting (of course this is a big project I'm gonna put off till later)
23:20:36 <mmorrow> (it would just chop)
23:20:44 <mmorrow> ((via zipWithM_)
23:20:44 <pumpkin> I'm really just transposing matrices, so it doesn't make that much difference to me
23:20:45 <mmorrow> )
23:20:55 <pumpkin> they just happen to be ****ing huge
23:20:57 <pumpkin> and dense
23:20:58 <int80_h> I mean, you *can* use it to learn things. However, everything interesting in terms of libraries assume you're using ghc. So you may as well use the ghci for an interpreter. Hugs offers no advantage as far as I can see.
23:21:02 <nikki93> pumpkin: Quaternions are better for rotations.
23:21:13 <nikki93> (pardon me I'm a 3d graphics and games guy had to say it)
23:21:28 <pumpkin> nikki93: I must be in very high dimensions if I need a matrix of my dimensions to do rotations ;)
23:21:34 <mmorrow> pumpkin: in that case i wouldn't either since you'd have to scan the incoming list to get those lengths
23:21:43 <nikki93> int80_h: Other than the fact that its written in C and ghci in haskell.
23:21:51 <nikki93> pumpkin: I was assuming 3d. :)
23:22:14 <int80_h> nikki93: there's that. I also thought hugs would be a good place to begin writing a mud engine
23:22:16 <mmorrow> homogenous coords!
23:22:21 <mmorrow> (ftw)
23:22:27 <pumpkin> :P
23:22:35 <pumpkin> I really like the idea of quaternions
23:22:45 <int80_h> I've since changed my mind. When I begin that (rather large paroject) I'll start by writing haskell bindings for lpmud.
23:22:49 <nikki93> pumpkin: Quaternions is FTW!
23:22:59 <pumpkin> but have never really used them beyond the "impress your friends with not just one, but three imaginary bases" or something
23:23:11 <nikki93> pumpkin: Its the smallest and very intuitive way of storing rotations.
23:23:16 <nikki93> Its more intuitive than you think.
23:23:20 <pumpkin> I know how they work :P
23:23:57 <nikki93> Let q = a + bi + cj + dk, so q(w,v) = w + (v.x)i + (v.y)j + (v.z)k
23:24:31 <nikki93> Then q(cos(theta/2), sin(theta/2) * u) gives a rotation of theta around vector u.
23:24:36 <mmorrow> homogenous coords are nice for doing transforms of the colors in an image, since you can use the 4th dim for the alpha channel
23:24:38 <nikki93> Provided that u is normalised.
23:24:56 <nikki93> mmorrow: They're also nice for storing length of vectors.
23:25:12 <nikki93> mmorrow: Provided that you modify vectors less often than you compute their length. ;-)
23:25:19 <mmorrow> heh
23:26:15 <int80_h> @src words
23:26:15 <lambdabot> words s = case dropWhile isSpace s of
23:26:15 <lambdabot>     "" -> []
23:26:15 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
23:26:22 <nikki93> i ^ 2 = j ^ 2 = k ^ 2 = ijk = -1
23:26:30 <pumpkin> nikki93: ;)
23:26:39 <pumpkin> nikki93: why don't you implement a quaternion class for haskell
23:26:42 <pumpkin> I haven't seen one
23:26:45 <pumpkin> well not class
23:26:50 <pumpkin> type, instance of Num or something
23:26:54 <nikki93> pumpkin: I've implemented one for Cg (that shader language) lol
23:27:04 <pumpkin> yes, but this is #haskell
23:27:09 <emptnr_> wow...arch without x is
23:27:12 <emptnr_> actually not bad ;)
23:27:14 <nikki93> pumpkin: I'm not familliar with types yet.
23:27:21 <nikki93> pumpkin: Ok wait, I am. :P
23:27:23 <emptnr_> oh wrong channel
23:27:26 <emptnr_> types are easy
23:27:32 <nikki93> But what about functions?
23:27:39 <emptnr_> functinos are easy too ;)
23:27:40 <nikki93> Take a handle to a quaternion and comput?
23:27:44 <emptnr_> did you finish your program nikki?
23:27:50 <nikki93> (C-like member functions lol)
23:27:53 <nikki93> emptnr_: WHich one?
23:27:58 <emptnr_> 6~the one you were talking to me about
23:28:08 <nikki93> emptnr_: Elaborate? :P
23:28:19 <emptnr_> let's see here
23:28:24 <int80_h> riddlin use adversly affects memory
23:28:30 <emptnr_> int80_h: ritalin*
23:28:31 <pumpkin> ritalin?
23:28:40 <nikki93> He forgot. :P
23:28:40 <emptnr_> it's only methylphenidate
23:28:42 <int80_h> hah yes ritalin
23:28:46 <emptnr_> not as bad as dextroamphetamine salts >:
23:28:57 <nikki93> emptnr_: WHATCHA TALKIN ABOUT (the program).
23:29:03 <emptnr_> nikki: let's see
23:29:06 <emptnr_> you wrote a function
23:29:07 <emptnr_> to
23:29:10 <emptnr_> filter for vowels
23:29:13 <emptnr_> i think
23:29:15 <nikki93> lol that was long back.
23:29:17 <emptnr_> then i told you
23:29:19 <emptnr_> to write an IRC bot
23:29:24 <nikki93> Yeah?
23:29:27 <mmorrow> a logical next step
23:29:32 <nikki93> Sorry I suck too much to do that right now.
23:29:36 <nikki93> (At haskell)
23:29:51 <emptnr_> no you don't
23:29:56 <emptnr_> it's a piece of cake, scouts honor
23:29:56 <int80_h> a better attitude would be "hmm, what do I have to learn to do that?"
23:30:02 <nikki93> Also I'm not sure about the myProgram-IRC interface. Files? Sockets? std(in\out)?
23:30:10 <emptnr_> IRC bots taught me most of python ;)
23:30:17 <emptnr_> i'm taking a different approach to haskell
23:30:18 <pumpkin> nikki93: maybe if you spent more time pushing your boundaries and less writing string repeaters ;)
23:30:18 <nikki93> int80_h: Hah. Don't worry I got no problem with attitude I'm just being lazy.
23:30:24 <emptnr_> "do something which normally requires 120 people"
23:30:47 <mmorrow> nikki93: you could use any of those 3, but handles would be the easiest probably
23:30:57 <int80_h> your attitude comes shining through nikki93
23:31:03 <nikki93> int80_h: Eh?
23:31:04 <mmorrow> (but offer less control, but that prob wouldn't matter much in an irc bot)
23:31:15 <nikki93> int80_h: Where?
23:31:20 <pumpkin> nikki93: I seriously don't think it would take you long to write a quaternion instance of Num
23:31:21 <mmorrow> you can turn sockets into Handles
23:31:31 <nikki93> pumpkin: Its hella easy to write quaternions dude.
23:31:43 <pumpkin> nikki93: so learn how typeclasses work and play around with it?
23:31:56 <nikki93> pumpkin: Ok I'll do it now.
23:32:02 <pumpkin> you could release a library for quaternions too!
23:32:06 <nikki93> But I'm thinking of reading YAHT instead.
23:32:18 <mmorrow> @hackage quaternionsNOW
23:32:18 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/quaternionsNOW
23:32:24 <pumpkin> boo
23:32:42 <pumpkin> oh wow, there's a paper by bos
23:32:55 <nikki93> No really, I came to haskell to learn the differentness of it.
23:32:56 <mmorrow> on what?
23:32:59 <nikki93> I want to read YAHT.
23:33:06 <nikki93> Is YAHT good?
23:33:06 <pumpkin> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.6250
23:33:14 <emptnr_> i liked uh
23:33:17 <emptnr_> haskell for c programmers
23:33:23 <emptnr_> that was a good tutorial
23:33:24 <int80_h> the ibm paper
23:33:55 <pumpkin> mmorrow: <3
23:33:55 <int80_h> @src words
23:33:56 <lambdabot> words s = case dropWhile isSpace s of
23:33:56 <lambdabot>     "" -> []
23:33:56 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
23:34:19 <pumpkin> mmorrow: with my previous implementation, I killed it after 114 minutes and it still hadn't produced anything... with your transpose function, it took 5 minutes :)
23:34:29 <nikki93> pumpkin: Sorreh, I'll read YAHT instead.
23:34:35 <nikki93> pumpkin: It starts off very well.
23:34:51 <pumpkin> nikki93: whatever works best for you :)
23:34:59 <mmorrow> pumpkin: sweet!
23:35:13 <nikki93> pumpkin: BTW, where did you learn about Quaternions? Uni?
23:35:18 <pumpkin> mmorrow: if I manage to squeeze a paper in by the deadline, I'll acknowledge you
23:35:22 <pumpkin> nikki93: my own time
23:35:37 <mmorrow> pumpkin: ooh nifty :)
23:35:41 <pumpkin> nikki93: I went through an insane "3d engine" phase too in my mid-teens :P
23:35:43 <nikki93> pumpkin: Ahh. Have you been to Uni? Whats it like?
23:35:51 <nikki93> pumpkin: Wrote any games?
23:35:59 <pumpkin> nikki93: nope, I like to tinker :)
23:36:03 <pumpkin> nikki93: yeah, I've been
23:36:21 <nikki93> Check out the Ogre forums some time, I'm nikki there.
23:36:35 <pumpkin> mmkay :)
23:36:37 <mmorrow> for some reason i was just reminded of StarFox for super nintendo
23:36:42 <pumpkin> :o
23:36:44 <mmorrow> one of the BEST GAMES EVAR
23:36:47 <nikki93> http://www.ogre3d.org/forums/index.php
23:37:08 <emptnr_> what's it like
23:37:13 <pumpkin> nikki93: university is awesome, depending on how free you manage to make yourself while there and how constrained you feel in high school
23:37:16 <int80_h> hey can someone give me a usage example for problem 2, chapter 4 RWH?
23:37:18 <emptnr_> nikki: what's your bot going to be like?
23:37:25 <emptnr_> pumpkin: my attitude exactly
23:37:28 <emptnr_> except for the "awesome" part
23:37:34 <pumpkin> lol
23:37:54 <emptnr_> i own this damn place though
23:37:56 <emptnr_> seriously
23:38:07 <pumpkin> I managed to get away with doing exactly what I wanted to be doing for the whole time there, and very little of that was what would typically be considered "work"
23:38:08 <nikki93> pumpkin: At what age did you start programing.
23:38:17 <pumpkin> nikki93: 12ish maybe?
23:38:19 <nikki93> The thing is, I write programs, am interested in programming, physics, math, music.
23:38:27 * mmorrow started at 18
23:38:29 <emptnr_> nikki: marry me
23:38:34 * emptnr_ started at 7
23:38:37 <emptnr_> private school++
23:38:39 <pumpkin> lol
23:38:41 <aeolist> alert, we have basic programmers on #haskell
23:38:46 <Axman6m> @karma Axman6
23:38:47 <lambdabot> Axman6 has a karma of 6
23:38:49 * pumpkin whistles
23:38:50 <emptnr_> basic was my first language
23:38:54 <aeolist> oh guys, you are soooo getting banned
23:38:58 <etate> alert, we have marriage proposals on #haskell
23:39:01 <int80_h> off with their heads. yeah pet basic was my first
23:39:02 <emptnr_> i'd recommend either basic or logo to total n00bs
23:39:03 <pumpkin> oh no, Axman6m is ****urbating to his karma
23:39:04 <nikki93> I wrote a few libraries connecting physics and Ogre 3D, wrote a GameObject management system, and loads of other stuff.
23:39:04 <emptnr_> goto or not
23:39:14 <emptnr_> maybe javascript, if i felt daring, or some basic php
23:39:17 <nikki93> My mom says I should get into a 'good unviersity'. What's that?
23:39:23 <emptnr_> nikki: one that people think is good
23:39:30 <etate> nikki93: how old are you?
23:39:33 <nikki93> emptnr_: I'm not marrying you.
23:39:34 <pumpkin> nikki93: one that doesn't teach you how to use a mouse and keyboard in the "intro to CS" course
23:39:37 <emptnr_> that's ok
23:39:38 <int80_h> he was born in 93. do the math
23:39:40 <aeolist> we started old school, pascal!
23:39:40 <emptnr_> i wasn't serious
23:39:44 <pumpkin> and ideally has functional programming as a prerequisite
23:39:44 <nikki93> etate: 15.
23:39:57 <etate> nikki93: and you're learning haskell?
23:39:57 <emptnr_> functional programming IS computer science ;)
23:40:00 <etate> sweet
23:40:06 <emptnr_> there are 15 year old girls learning haskell
23:40:08 <emptnr_> ??
23:40:09 <nikki93> etate: <3 haskell
23:40:11 <nikki93> I'm no girl.
23:40:13 <nikki93> I'm male.
23:40:17 <emptnr_> oh well
23:40:17 <pumpkin> lol
23:40:18 <aeolist> nikki93: that's a pitty
23:40:23 <etate> rofl @ emptnr_
23:40:26 <emptnr_> at least there are still 15yos learning haskell
23:40:30 <repnop> that phrase assumptions make ... comes to mind
23:40:30 <nikki93> aeolist: Eh, I like life without periods, thank you.
23:40:33 <emptnr_> the future is looking brighter
23:40:56 <nikki93> repnop: ass u me?
23:41:01 <int80_h> I always thought a mud engine a la lpmud written in haskell would be a good way to bring the kids in.
23:41:10 <repnop> kids play muds?
23:41:11 <nikki93> mud engine == ?
23:41:14 <kmeyer> repnop: hell yes
23:41:18 <emptnr_> i played nethack when iw as 8
23:41:22 <etate> on another note, does anyone here maintain the SDL gfx lib?
23:41:23 <repnop> nethack != mud :)
23:41:24 <kmeyer> nikki93: telnet anguish.org 2222
23:41:24 <emptnr_> beats the hell out of chess..
23:41:33 <repnop> but this really belong in -blah
23:41:35 <int80_h> hell yes they do. then they go on to learn lpc. a totally useless toy language. we can do better than that.
23:41:35 <emptnr_> repnop: they're not THAT different
23:41:40 * emptnr_ bans repnop
23:41:47 <nikki93> ANyone saw the telnet towel.blinkenlights.nl?
23:41:50 <nikki93> You need popcorn.
23:41:54 <mornfall> (I guess girls don't do pissing contests that much...)
23:41:58 <pumpkin> #haskell-blah
23:42:05 <nikki93> pumpkin: GTFO
23:42:05 <nikki93> lol
23:42:14 <rastar> whats the commmand to exit Prelude> screen >
23:42:19 <pumpkin> rastar: :q
23:42:20 <jeffz``> nikki93: #haskell-blah is for off-topic chat
23:42:26 <etate> Lemmih: hello, let me know whe you are alive :)
23:42:27 <rastar> pumpkin: thnks
23:42:29 <nikki93> jeffz``: Ok, I'm going there.
23:42:30 <kmeyer> nikki93: it's the same thing on ipv6
23:42:31 <kmeyer> they lie
23:42:41 <kmeyer> > :q
23:42:42 <lambdabot>   <no location info>: parse error on input `:'
23:42:46 <kmeyer> :'(
23:42:48 <emptnr_> i want some popcorn
23:42:54 <emptnr_> i can't wait until ipv9
23:42:59 <emptnr_> it'll have unicorns
23:43:02 <emptnr_> and free hookers
23:43:13 <int80_h> in fact skip the unicorns
23:43:13 <etate> emptnr_ are you 15 too?
23:43:17 <emptnr_> i'm 20
23:43:18 <int80_h> and the protocol
23:43:25 <emptnr_> <3 int80
23:43:29 <mornfall> #haskell gone wild.
23:43:30 <etate> ah ok, the unicorn thing threw me off
23:43:31 <nikki93> etate: WHy are you like 57 or something?
23:43:40 <etate> lol
23:43:40 <emptnr_> lol
23:43:44 * emptnr_ glares at etate
23:43:51 * emptnr_ arches his back!
23:43:54 <etate> nikki93: no i'm 22
23:43:58 * emptnr_ starts hissing
23:44:00 <int80_h> back in my day, we didn't have first class functions.
23:44:01 * mornfall feels old.
23:44:13 <nikki93> int80_h: BAck in cavemen days they did't have functions.
23:44:14 <mornfall> int80_h: You're older than lisp?
23:44:18 <int80_h> we had punch cards. and it was good enough!
23:44:22 * int80_h kidding!
23:44:22 <emptnr_> there's already RFC standards for thsoe jokes
23:44:27 <etate> int80_h: rofl, you're older than the lambda calculus?
23:44:35 <nikki93> RFC = rentucky fried chicken?
23:44:38 * pumpkin doesn't see much moving to #haskell-blah
23:44:44 <emptnr_> nikki93: yes
23:44:44 <Lemmih> etate: Hi.
23:44:54 * emptnr_ ignores pumpkin and urinates on the sofa
23:45:05 <etate> Lemmih: hey I see your name on the SDL gfx library, do you maintain it?
23:45:06 * nikki93 urinates on pumpkin
23:45:17 <pumpkin> Saizan: ci sei? :P
23:45:20 * nikki93 sends pumpkin back to halloween
23:45:22 <mornfall> I see you're all having great fun, so maybe you want to help me debug a RTS problem I'm seeing? : -)
23:45:23 <Lemmih> etate: Yes.
23:45:27 <emptnr_> lemmih: thank god
23:45:29 <emptnr_> i need your help
23:45:31 <nikki93> mornfall: Ok. :)
23:45:39 <etate> Lemmih: There are a couple of constants that I need defined, is that possible :)
23:45:46 <mornfall> http://bugs.darcs.net/msg7151
23:45:54 <Lemmih> etate: Sure thing. Send me the patch.
23:46:06 <mornfall> It seems #ghc does not love me as much as I'd like.
23:46:12 <emptnr_> it's ok
23:46:18 <emptnr_> you can always coem to me for meaningless sex, mornfall
23:46:19 <etate> Lemmih: okay, i haven't written it yet, but its simple stuff, just the set attribute colour constants
23:46:26 * emptnr_ np slowdive - morningrise
23:46:41 <etate> Lemmih: theres the green one atm, but no others
23:46:51 <mornfall> emptnr_: Hm.
23:47:24 <int80_h> mornfall: I'm obsessed with chapter 4 of RWH right now.
23:47:41 <mornfall> int80_h: What's chapter 4? (I don't have a copy... yeah, I'm such a heretic...)
23:48:00 <nikki93> int80_h: Functional programming?
23:48:03 <etate> int80_h: thats a brilliant chapter :)
23:48:04 <nikki93> int80_h: Thats the funnest chaptah.
23:48:15 * mornfall blinks eyes.
23:48:27 <int80_h> mornfall: it's just teaching the "Haskell Way." if you wanted could you take a look at problem 2, chapter 4 and give me a usage example?
23:48:47 <int80_h> etate : it's pretty awesome
23:49:23 <etate> int80_h: wait til you get to typeclasses, then monads, so much fun.
23:49:24 <mornfall> int80_h: Problem as in Exercise?
23:49:31 <mornfall> int80_h: Ie. splitWith?
23:49:56 <int80_h> mornFall: yeah splitWith. I just want to see a usage example. I'm having trouble visualizing
23:50:00 <nikki93> IRC FTW
23:50:05 <etate> man #haskell is a mad channel
23:50:08 <etate> lol
23:50:30 <pumpkin> it's usually mad with awesome math/CS
23:50:37 <emptnr_> i blame the trolls
23:50:40 <emptnr_> give me ops and i'll get rid of em all
23:51:07 <etate> pumpkin: yeah it was last time i checked. tbh i prefer this to #lisp. :)
23:51:47 <pumpkin> :)
23:52:16 <int80_h> I don't understand what (a -> Bool) is going to look lie, when I give splitWith input
23:52:38 <etate> pumpkin: I think a lot of haskell converts are refugees from the lisp community lol
23:52:47 <int80_h> etate: that would be me
23:52:56 <etate> int80_h: and me
23:53:03 <mornfall> int80_h: Something like splitWith (\x -> x < 10) [100,5,20,3,80]?
23:53:10 <X-Scale> why did you leave Lisp being ?
23:53:14 <repnop> programming languages aren't zero-sum games. you can enjoy more than one.
23:53:36 <int80_h> ywah, but I only have so much time in the day. I have actual goals to fufill.
23:53:36 <etate> i've programmed in CL and Scheme for the past 4 years, ocasionally in production
23:53:47 <etate> sometimes in real time critical applications
23:54:09 <etate> but CL is just not as good as haskell anymore (IMO)
23:54:24 <emptnr_> CL?
23:54:28 <etate> GHC is a brilliant compiler, and the haskell community seems to have grown exponentially
23:54:28 <emptnr_> oh clisp
23:54:42 <emptnr_> <3 haskell
23:54:49 <int80_h> mornfall: thanks, that's exactly what I needed.
23:55:17 <etate> and i don't think i can live without typeclasses, monads, and pattern matching any longer
23:55:33 <etate> even at the expense of macros :p
23:55:36 <pumpkin> is it true that fmap a . fmap b == fmap (a . b) ?
23:55:51 <Saizan> that's a law
23:56:03 <pumpkin> that's what I thought
23:56:10 <dfjoerg> http://rafb.net/p/lND2tm75.html <-- this gives me a GC error in hugs within a few ms, am I missing something about the GC?
23:57:32 <etate> i've never used hugs, is it in some way better than GHC? or just more newbie friendly?
23:57:32 <pumpkin> fmap (mergeData (255, 521)) . fmap (zip [0..]) $ mapM readFeatures names works fine, but fmap (mergeData (255, 521) . fmap (zip [0..])) $ mapM readFeatures names doesn't
23:57:38 <Saizan> dfjoerg: zeroes probably won't be collected because there's a toplevel reference to it
23:57:41 <pumpkin> I must be missing something obvious
23:58:23 <dfjoerg> etate: much easier to bootstrap
23:58:40 <Saizan> pumpkin: what's the problem with the latter?
23:58:53 <pumpkin>     Couldn't match expected type `(Int,
23:58:53 <pumpkin>                                    (UArr Bool, [(FeatureType, UArr Double)]))'
23:58:53 <pumpkin>            against inferred type `[(t, b)]'
23:59:03 <pumpkin> I guess without more information that might not be very helpful
23:59:40 <etate> dfjoerg: another q, i've never come across a haskell implementation that doesn't support multi param typeclasses, do they exist?
23:59:53 <Saizan> pumpkin: ah, wait, you've a spurious fmap in the latter
23:59:58 <pumpkin> oh
