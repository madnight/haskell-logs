00:01:21 <vixey> data family T a ; data instance T Int  = A ; data instance T Char = B ; nonsense :: T a -> Int ; nonsense A = 1 -- WRONG: These two equations together... nonsense B = 2 ...will produce a type error.
00:01:31 <vixey> that makes sense
00:01:41 <vixey> you can't define functions over the family of types, only methods
00:01:57 <vixey> now I wonder what type families do that normal typeclasses can't..
00:05:34 <vixey> type instance F Float              = forall a.a  -- WRONG: right-hand side may not be a forall type
00:05:35 <vixey> :(
00:07:48 <rwbarton> vixey: http://hpaste.org/13738#a2
00:09:20 <vixey> [1 of 1] Compiling Main             ( N.hs, interpreted )
00:09:21 <vixey> *** Exception: Maybe.fromJust: Nothing
00:09:22 <vixey> hahaha....
00:09:34 <rwbarton> Yeah :)
00:09:34 <vixey> that's me trying to load this code into ghci :p
00:09:48 <rwbarton> you'd need a more recent development version
00:09:50 <vixey> well typed programs!
00:11:14 <vixey> rwbarton, very interesting though
00:11:28 <vixey> it's like a mix between typeclasses and GADTs
00:11:34 <rwbarton> yes, exactly
00:11:57 <Saizan_> rwbarton: what happens if you've a data family Foo a :: * and data instance Bar a where Bar :: Bar Int?
00:12:04 <Saizan_> err
00:12:07 <rwbarton> the type of project is now (HasParts a) => Parts a i o -> a -> o
00:12:17 <Saizan_> data instance Bar Bool where Bar :: Bar Int
00:12:37 <Saizan_> make the first Bar a Foo..
00:13:25 <rwbarton> data family Foo a :: *; data instance Foo Bool where Bar :: Foo Int ?
00:14:06 <Saizan_> yes.
00:14:10 <rwbarton> "Data constructor `Bar' returns type `Foo Int' instead of an instance of its parent type `Foo Bool'"
00:14:20 <Saizan_> ah ok
00:17:42 <Saizan_> maybe we can implement Data.Dynamic without unsafeCoerce then..
00:21:45 <vixey> http://hpaste.org/13738#a3
00:22:04 <vixey> I don't see yet, what type families can do which is not possible by FunctionalDependencies
00:22:26 <vixey> but definitely it is simpler and more straightforward than functional dependencies
00:25:10 <Saizan_> they are more cumbersome if you need bidirectional predicates
00:25:28 <vixey> which are more cumbersome, the type families?
00:25:33 <Saizan_> yes
00:25:50 <vixey> and by bidirectional, does that mean for example like  fromIntegral?
00:26:03 <Saizan_> you need two type families to get what a single class would give you
00:26:11 <Saizan_> i mean like in prolog
00:26:34 <vixey> I never saw the like with typeclass dispatch and Prolog actually
00:27:20 <Saizan_> they are surely more limited, but with functional dependencies you can do logic programming to some extent
00:27:28 <vixey> (when I write programs in Prolog they tend to work.. and with typeclasses it just say thisg like:  Could not deduce (HasParts NTH [a] elt (Maybe a))  from the context (HasParts NTH [a] a (Maybe a))
00:27:33 <vixey> and when I make a functional dependency,
00:27:47 <vixey> HasParts selector obj elt proj | obj -> elt proj
00:27:48 <Elly> I wish prolog had types
00:27:54 <Elly> I really, really wish it had types
00:27:54 <vixey> it's not non-deterministic anymore
00:28:06 <mjrosenb> Elly: me too
00:28:12 <Elly> hey, mjrosenb!
00:28:16 <vixey> Elly, that would be horrendous and you couldn't write any *Prolog* programs anymore
00:28:16 <Elly> fancy seeing you here ;)
00:28:25 <mjrosenb> Elly: fancy that
00:28:31 <mjrosenb> vixey: you've said this before
00:28:35 <Saizan_> Mercury has types, right?
00:28:35 <vixey> Elly, but stuff like Mercury and Curry are very similar in style
00:28:37 <Elly> vixey: I think it'd be nice if prolog propositions could be quantified over types
00:28:41 <vixey> mjrosenb, it's a fact :P
00:28:49 <vixey> Elly, really it would ruin Prolog
00:28:51 <rwbarton> vixey: here's another interesting thing you can do: http://hpaste.org/13738#a4
00:28:54 <mjrosenb> vixey: i still haven't seen any of your prolog code that can't be typed in a useful manner
00:29:03 <Elly> (or at least in a harmless manner)
00:29:34 <mjrosenb> Elly: to be fair, there are constructs in prolog that are scary as all hell
00:29:45 <Elly> "scary as all hell" is okay when you can type-infer it
00:29:49 <mjrosenb> Elly: like :- and assertz
00:29:54 <rwbarton> vixey: still it is also possible with functional dependencies
00:29:57 <vixey> but there is a huge spectrum of declarative/proof search based programming languages -- you don't have to ruin prolog
00:30:12 <Elly> I do not find that a convincing argument
00:31:02 <vixey> mjorsenb, simple types ala ocaml/SML/haskell aren't enough, you can't have dependent types thought because there's no lambda
00:31:08 <rwbarton> vixey: but note, I could generalize Part' over constructors like Part, and then I don't know whether it can be done with functional dependencies
00:31:36 <rwbarton> data List e a b where Nil :: List e a a; Cons :: e a b -> List e b c -> List e a c
00:31:46 <rwbarton> then set e = Part
00:31:46 <mjrosenb> vixey: i'd still like a concrete example
00:31:46 <vixey> mjrosenb, but just consider giving types to lisp macros, Prolog has a similar thing, also multimoded types are probably even more difficult than subtyping to implement
00:32:08 * jonaskoelker :: caffeine -> awakeness
00:32:46 <Saizan_> vixey: you mean the primitive that let you deconstruct a term generically?
00:32:48 <Elly> programmer :: caffeine -> code -- is the traditional one, I believe
00:32:55 <Saizan_> "primitives"
00:33:01 <vixey> Saizan, hm?
00:33:05 <jonaskoelker> Elly: true :)
00:33:13 <Saizan_> what part of prolog is like lisp macros?
00:33:16 <Elly> programmer ought to be a type class there
00:33:16 <mjrosenb> Elly: itym mathematician :: coffee -> proofs
00:33:21 <vixey> Saizan, term_expansion/2
00:33:30 <vixey> Saizan, do you know DCG in Prolog?
00:34:00 * mjrosenb saw dcg's from the wikipedia page on prolog, but i've never bothered to use them
00:34:12 <jonaskoelker> perl :: code -> ()
00:34:26 <vixey> Saizan, it's like   expr(M) --> ['('], expr(M), [')'].   for writing parsers, but you could define it by compiling it back into the primitive :- using term_expansion/2
00:34:37 <vixey> it's basically equivalent to DEFMACRO
00:34:51 <vixey> xgiving types to this sort of thing would be hell...
00:35:09 <Saizan_> well, TH tells you that's not so hard to type a macro system
00:35:26 <Saizan_> not sure about this particular case..
00:35:59 <rwbarton> vixey: oh, one other interesting thing
00:36:21 <rwbarton> vixey: ah never mind
00:36:30 <vixey> huh?
00:36:42 <mjrosenb> vixey: while we're on the topic of prolog, is there any way to implement a predicate that does something similar to map?
00:36:47 <rwbarton> vixey: I think there are cases where the translation to use functional dependencies rather than indexed types requires undecidable instances
00:36:51 <vixey> mjrosenb, yes
00:37:42 <rwbarton> vixey: but this example is slightly too simple
00:37:46 <vixey> rwbarton, ah, I can believe that but I never used an undecidable instance so I don't really know when they occur
00:38:20 <papermachine> Hey, you know, there's Curry Howard for code <-> proofs, sorta, so there should be a component of a natural transformation that goes between coffee and caffeine.
00:38:28 <vixey> rwbarton, ohh.. that :> stuff just made sense, very nic!
00:38:29 <vixey> nice
00:38:33 <papermachine> And, now that you mention it, there is...
00:40:18 <vixey> mjrosenb: if you ripped types from haskells claws you'd lose typeclasses, phantom types etc.. same thing happens if you add types to Prolog, all the best programming idioms die
00:40:34 <vixey> mjrosenb, doesn't mean you don't get new things like HOU in lambda prolog for example
00:40:51 <mjrosenb> vixey: well lambda prolog seems very dead
00:40:52 <vixey> just not sure why anybody would want to do it :p
00:41:05 <Elly> hm
00:41:10 <Elly> I can't make map work in prolog
00:41:12 <vixey> not sure what dead means, ithe implementation is rock solid and in development
00:41:13 <mjrosenb> vixey: so how do you implement something like map in prolog?
00:41:16 <Elly> here's my best guess at it:
00:41:31 <vixey> mjrosenb, um.. easily :p
00:41:32 <Elly> map(f,[],[]). map(f,[X|Xs],[Y|Ys]) :- f(X,Y), map(f,Xs,Ys).
00:41:39 <Elly> but it does not appear to work
00:41:44 <vixey> you should real Learn Prolog Now! if you want a decent intro
00:41:51 <mjrosenb> vixey: where, i haven't been able to find a codebase that compiles with anything newer than sml-nj-110.0.7
00:42:01 <Saizan_> Elly: f is a term there, not a predicate
00:42:23 <Elly> is there some syntax that means "this is a predicate here"?
00:42:27 <mjrosenb> and you can't say F(X,Y) afiak
00:42:43 <Saizan_> no, but there's apply, or something like that
00:42:44 <vixey> mjrosenb, I find this built for me recently with no problems http://code.google.com/p/teyjus/
00:42:48 <Elly> oh, yeah, if I make it uppercase, it dies
00:42:58 <Saizan_> that takes a term and applies the predicate with the same name
00:43:39 <pumpkin> how did I end up with an IO (IO ()) :P
00:43:50 <vixey> Elly, which implementation are you using?
00:43:51 * pumpkin just joins it
00:43:53 <Elly> gprolog
00:43:59 <vixey> Elly, ugh.
00:44:04 <vixey> Elly, that's the worst one.
00:44:09 <Elly> apply/2 and apply/3 appear not to exist
00:44:12 * vixey recommends SWI
00:44:29 * Elly switches to swprolog
00:45:09 <Saizan_> maybe it's "call"?
00:45:17 * mjrosenb has a minimal 400 line sml prolog interpreter
00:45:18 <Elly> hm
00:45:21 <Elly> apply is not correct
00:45:40 <Elly> call is
00:45:41 <Saizan_> ?google higher-order prolog
00:45:46 <lambdabot> http://www.cs.mu.oz.au/~lee/papers/ho/
00:45:46 <lambdabot> Title: Higher-order logic programming in Prolog
00:47:53 <rubber> what is logic programming.?
00:48:00 <rubber> can it be practical?
00:48:04 <vixey> I wonder if something like lazy narrowing would be a better fit for typeclass dispatch in haskell
00:48:05 <Elly> declarative programming!
00:48:17 <vixey> rubber, no, like scheme it's only purpose is boring students to death :p
00:48:26 <Elly> I think of it as: You tell the language what the solution looks like, and the language tells you what the answer(s) are :)
00:48:30 <Saizan_> vixey: btw, if i wanted to implement some limited form of higher-order unification in prolog, do you think it could be done in a meta-circular style?
00:48:51 <vixey> Saizan_, I don't really know what you mean by meta-circular, since Prolog doesn't start with HOU?
00:49:04 <rubber> tall blonde busty about 5-6 145
00:49:10 <rubber> go prolog go
00:49:15 <Elly> ha ha
00:49:24 <Saizan_> vixey: well, where variables of my terms are prolog variables
00:49:47 <jonaskoelker> vixey: HOU?  Hordes of the Underdark?
00:49:56 <rubber> specialization and division of labor
00:50:26 <rubber> so are there a lot of haskell startups?
00:50:33 <rubber> anything to take on amazon or ebay?
00:50:39 <vixey> Saizan_, I don't think it would be nice at all, I'm pretty sure there would have to be a toplevel 'interpreter' for it but I haven't thought about it much
00:50:39 <rubber> do target advertizing?
00:51:16 <vixey> Saizan_, (I mean the implementation would probably be a bit nasty, the usage would be fine once you did the hard work though)
00:51:56 <vixey> (but I think that is something which would be better done from scratch in a functional language than in Prolog :p)
00:52:13 * Elly grabs a copy of mercury
00:52:51 * vixey mentioned curry, mercury, lambda prolog but forgot about Oz..
00:54:00 * Saizan_ needs to write something in prolog for uni
00:54:11 <Elly> prolog is fun :)
00:54:15 <Elly> I wish I had more experience with it
00:54:40 <Saizan_> i thought something related to typechecking would be appropiate
00:55:12 <vixey> the type rules of STLC and HM are a Prolog program :)
00:56:52 <Saizan_> yeah, but that's a little too simple :)
00:57:50 <vixey> I fun program would be something that you could put in a type, like  (a -> b) -> ([a] -> [b])  and then it fill in the holes to write a function
00:58:04 <vixey> could use the types and so on to give a list of options to plug the hole
00:58:45 <Saizan_> you mean something like djinn?
00:58:53 <vixey> yeah except interactive
00:59:05 <vixey> (so that you could do recursive programs)
01:00:18 <Saizan_> so, a guided theorem prover for HM :)
01:04:43 <rubber> what is a higher order function? who is doing data warehousing in haskell?
01:05:21 <Saizan_> an higher order function is one that takes another function as argument
01:05:24 <Saizan_> like map
01:05:30 <Saizan_> ?src map
01:05:31 <lambdabot> map _ []     = []
01:05:31 <lambdabot> map f (x:xs) = f x : map f xs
01:05:41 <Saizan_> > map (+1) [1..5]
01:05:43 <lambdabot>   [2,3,4,5,6]
01:07:45 <mjrosenb> Saizan_: a higher order function can also be a function that returns a function
01:08:18 <vixey> that's an awkward kind of term 'higher order function'
01:08:32 <vixey> it mostly is just a useless buzzword I think
01:08:45 <vixey> (in practice, of course it is important theoretically)
01:09:10 * mjrosenb likes the buzz-phrase "functions are first class"
01:09:13 <Peaker> also, all the imperative languages have "higher order functions"..
01:09:24 <Peaker> (mainstream, that is)
01:09:50 <vixey> currying throws a spanner in the works too
01:10:04 <Saizan_> mjrosenb: that doesn't look right
01:10:04 <mjrosenb> Peaker: pretty sure fortran doesn't
01:10:42 <Saizan_> is const an higher order function?
01:10:59 <Saizan_> "const ()" returns a function.
01:11:02 <joha1> I'm doing the exercises in Real World Haskell at found that my "checkPalindrome list = (list == (reverse list))" function didn't work unless I added "Eq a => " in the type declaration (checkPalindrome :: Eq a => [a] -> Bool). What exactly does the "Eq a =>" mean and why is it so important?
01:11:03 <Elly> Peaker: how are you defining "higher order functions"?
01:11:07 <mjrosenb> Saizan_: i'd say yes.
01:11:07 <osfameron> Java doesn't
01:11:19 <Peaker> Elly: functions that takes other functions as arguments
01:11:22 <vixey> there is a difference between (LAMBDA (X Y) X) and (LAMBDA (X) (LAMBDA (Y) X)) in Scheme, but not in haskell
01:11:26 <Elly> osfameron: it' *sort of* does - you can pass Method arguments around
01:11:34 <Elly> er, you can pass Method objects around
01:11:40 <Elly> and use .call() on them
01:11:45 <mjrosenb> Saizan_: since you can then use that as an argument for other function
01:11:45 <Elly> it's hideous to look at
01:12:09 <osfameron> ah!  that'll be with reflection?  Most of my experience with Java is early J2ME which doesn't have most of the reflection capabilities
01:12:36 <Elly> osfameron: indeed
01:12:54 <vixey> Elly, I would think anonymous classes was a more 'higher order' kind of thing that passing the codes of methods around in Java
01:13:14 * mjrosenb has not used java in about 4 years
01:13:16 <vixey> (since Java is class based OO rather than message/method based)
01:13:20 * mjrosenb is sad that he ever used it
01:13:22 <Elly> vixey: I dunno; I have not done anything heavy with it
01:13:35 <Elly> I just know that you can pass the bound methods of objects around as objects themselves
01:13:40 <vixey> I've done a lot of java programming it's great fun :p
01:13:42 <Elly> it still seems like a sick parody of smalltalk to me :P
01:13:51 <vixey> but everyone still hates it today which is a shame
01:14:04 <vixey> (but how many people hate brainfuck? A lot less..)
01:14:39 <Elly> vixey: it's like how people get most angry about the lies they fear might be believed
01:14:43 <Peaker> vixey: Java's got good IDE's working for it
01:14:44 <ivanm> vixey: are you serious about finding java fun? :o
01:14:58 <Peaker> Good IDE's can make programming fun
01:15:04 <Saizan_> mjrosenb: that's a not useful definition of higher-order function, the fact that functions are first-class in the language as a whole is related but not determinant
01:15:18 * vixey considers syntax hilighting and paren matching a good IDE :)
01:15:23 * Elly uses vim
01:15:37 * mjrosenb uses emacs
01:15:40 <Peaker> vixey: except good IDE's, what made Java fun?
01:15:50 <ivanm> Peaker: every time I've tried a "real" IDE, it sickened me...
01:15:52 <Elly> I think that it is apparent that vixey is not serious
01:15:54 * mmorrow does all indentation manually
01:15:55 <Peaker> ivanm: why?
01:16:08 <Elly> based on the ":p" above and the mention of features even nano provides as being a good IDE :)
01:16:13 <ivanm> Peaker: maybe sickened isn't quite the right term..... but all that garbage just to code? :s
01:16:17 <Peaker> ivanm: The main problems I see with "Real" IDE's is that they are slow and they epically fail in many situations
01:16:18 <ivanm> didn't get the point *shrug*
01:16:21 <vixey> learning to program useful things, and later on metaprogramming via reflective embeddings of mini-languages
01:16:25 <mjrosenb> Saizan_: so what language has first class functions and *not* higher order functions?
01:16:39 <Peaker> ivanm: "just to code"? Coding is probably one of the most difficult things to do right :)
01:16:44 <ivanm> mmorrow: with a magnetized fine needle? :p
01:16:50 <Saizan_> mjrosenb: having higher order functions is one thing, a particular function being higher order or not is another
01:16:56 <_Dae_> ivanm: IDE's does make some things simpler. It's not like haskell couldn't use a good IDE sometimes
01:17:06 <ivanm> Peaker: well, quite a few people seem to manage just fine without an IDE...
01:17:13 <ivanm> _Dae_: in what way?
01:17:16 <mjrosenb> Saizan_: gotcha
01:17:26 <mmorrow> ivanm: magnetism is of crucial importance, among other things.
01:17:28 <ivanm> what could an IDE do for me that a text editor can't?
01:17:29 <vixey> but also learning Java taught me to read documentation
01:17:35 <ivanm> vixey: heh
01:17:36 <Peaker> ivanm: "manage just fine", sure, and they could do much better if they had effectively used a good IDE (I don't think there is a good Haskell IDE yet)
01:17:38 <mjrosenb> _Dae_: i've had no issues using emacs to code haskell
01:17:41 <vixey> I wonder how others got used to reading documentation?
01:17:46 <Elly> things I wish vim could do for haskell: "Tell me the type of the highlighted expression in its local context"
01:17:47 <vixey> because it is not really natural, is it?
01:17:53 <Elly> vixey: K&R, here
01:17:56 <vixey> (at least initially)
01:17:58 <cizra> ivanm: I don't know about Haskell, but Visual Studio can show class members etc for a given object, very useful.
01:17:58 <ivanm> Peaker: *shrug* I've never used an IDE, and I like to think my code is reasonable
01:18:12 <ivanm> cizra: emacs can do that, and it isn't an IDE ;-)
01:18:15 <_Dae_> ivanm: the instant  I have a project of a size where I honestly can't remember what every method is called everywhere. For instance.
01:18:22 <Elly> ivanm: that is totally a debateable point :P
01:18:24 <Peaker> ivanm: emacs is an IDE, even if a poor one :)
01:18:24 <vixey> ivanm, yes it is
01:18:26 <Elly> (emacs not being an IDE)
01:18:26 <ksf> i'm missing such things as source->haddock linkage, jump to declaration, show usages and simple refactoring like global renaming.
01:18:30 <mmorrow> , [$ty| let fix f = let x =f x in x in fix |]
01:18:30 <ivanm> Elly: heh
01:18:35 <ivanm> Peaker: I beg to differ
01:18:36 <_Dae_> ivanm: noone is saying that you can't code without an IDE, just that it's sometimes easier with
01:18:38 <Peaker> ivanm: I don't think not having an IDE makes your code worse, its just that it will take you longer to do the same things
01:18:42 <pumpkin> we all know IDEs make up for language shortcomings and that haskell has no shortcomings! now come my friends! it's tome for our five minutes of hate
01:18:42 <lunabot>  forall a . (a -> a) -> a
01:18:43 <mmorrow> come one lunabot
01:18:59 <Peaker> ivanm: emacs is a great editor and a bad IDE.. All the good IDE's I know have bad editors...
01:19:01 <pumpkin> *time
01:19:12 <Peaker> ivanm: it is indeed more important for the editor to be good than to have the IDE functions
01:19:16 <ivanm> Peaker: if you mean that it generates code for you, then that's a good indicator that that language sucks IMHO ;-)
01:19:37 <mmorrow> all the pieces are there. someone just needs to start spitting out the cash to pay people to write such things.
01:19:38 <vixey> ivanm, ever heard of Template Haskell?
01:19:47 <ivanm> vixey: yeah, never touched it though
01:19:49 <Peaker> ivanm: No, I mean it has a notion of "project" in many senses, and can help you manage one.  For example, tag files support, or compilation support, etc
01:20:13 <ivanm> Peaker: *shrug* again, that's not exclusive to an IDE
01:20:36 <mmorrow> absent that, no one will dedicate the time it'll take to make a "enterprise with lots of leverage" ide that's "industrial strength"
01:20:49 <Peaker> ivanm: IDE means that your editor is an "integrated environment" -- meaning it also handles compilation, debugging (emacs's gdb mode), tag finding, etc
01:21:03 <ksf> I'd be happy with a slightly extended yi.
01:21:07 <vixey> Peaker, kinda doubt you are going to get through to ivanm..
01:21:11 <mmorrow> yi++
01:21:16 <vixey> Peaker, seems to have already decided
01:21:22 <ivanm> Peaker: I don't think that emacs fits the requirement of a "traditional" IDE though....
01:21:25 <ivanm> vixey: heh
01:21:49 <vixey> ivanm, I bring up TH because I don't think a language sucks if there exists a tool to generate code for it
01:21:58 * mjrosenb uses emacs for everything Peaker mentioned
01:22:08 <vixey> parser generators don't make a language suck etc..
01:22:12 <ivanm> vixey: but you're programming the generating code, are you not?
01:22:14 <earthy> actually, languages that you cannot generate code for suck more.
01:22:20 <mmorrow> TH is great because it is self-sustaining
01:22:29 <mmorrow> you can use it to make using it easier
01:22:30 <ivanm> I was referring to IDEs which create all the getter/setter functions for you, etc.
01:22:47 <mmorrow> every line of TH code that's written extends TH's capabilities
01:22:56 <mmorrow> because you can turn it on itself
01:23:10 <vixey> why is getter/setter any different from parser generator? it's just a bit of complexity
01:23:20 <mmorrow> , $(lift =<< reify ''Exp)
01:23:23 <lunabot>  TyConI (DataD [] Language.Haskell.TH.Syntax.Exp [] [NormalC Language.Hask...
01:23:29 <vixey> there is no /real/ difference, in both cases there is metaprogramming that cannot be internalized
01:23:50 <pumpkin> mmorrow: what did that do? :o
01:23:57 <ivanm> vixey: my original point was, every time I've tried to use eclipse, net beans, etc. to code (in Java usually when I tried them) after listening to everyone say how great they are, I've been extremely disappointed
01:24:12 <vixey> yeah I don't use stuff like that
01:24:16 <vixey> it just gets in the way
01:24:26 <mmorrow> pumpkin: it gave you the complete AST (of type :: Exp) of the type Exp
01:24:37 <pumpkin> ah :o
01:24:54 <mmorrow> , ppDoc $(lift =<< reify ''Exp)
01:24:57 <lunabot>  data Exp = VarE Name
01:24:57 <lunabot>           | ConE Name
01:24:57 <lunabot>           | LitE Lit
01:25:00 <mmorrow> ...
01:25:07 <mmorrow> (about 12 more cons)
01:25:08 <pumpkin> neat
01:25:12 <mmorrow> totally
01:25:16 <ivanm> the few times on my most recent Java project that I've had to do refactoring, my limited knowledge of sed and emacs' regex sufficed
01:25:45 <pumpkin> , ppDoc $(lift =<< reify ''DataD)
01:25:47 <lunabot>  luna: Not in scope: type constructor or class `DataD'
01:25:54 <Peaker> ivanm: Good refactoring tools make it so much more fun :)
01:25:59 <pumpkin> :o
01:26:17 <_Dae_> Peaker when has refactoring ever been *fun* ?
01:26:18 <Peaker> ivanm: e.g: Refactor this variable out to a method -- that takes all the necessary parts from all your loops/etc to a separate method that computes it
01:26:21 <ivanm> Peaker: well, in most cases refactoring == new workflow logic of what I was doing
01:26:24 <fasta> mjrosenb: Emacs modes are often low-quality mud balls; since this is #haskell. Haskell-mode cannot even syntax highlight correctly.
01:26:26 <Peaker> _Dae_: I find refactoring very fun
01:26:36 <Peaker> _Dae_: almost as fun as deleting code
01:26:38 <ivanm> fasta: :o
01:26:40 <vixey> fasta, (or paren match properly)
01:26:46 <ivanm> when doesn't it highlight correctly?
01:26:51 <vixey> fasta, (which is idiotic)
01:26:56 <ivanm> vixey: paren matches properly here... :s
01:26:59 <vixey> even I know how to write a paren matcher
01:27:03 <fasta> vixey: oh, I don't think I have seen that one.
01:27:31 <_Dae_> Peaker: and I just go "ohh bugger, more wasted work"
01:27:32 <Peaker> fasta: I am sure elisp-mode is good :)
01:27:52 <ivanm> the only issue I've had with haskell-mode is when I without thinking do: C-x h ; C-A-\ ;-)
01:28:02 <Peaker> _Dae_: Its not wasted, it was part of the path to finding the better way to write it
01:28:26 <Peaker> ivanm: the indentation of haskell-mode is dumb :-(
01:28:39 <fasta> slime-mode for CL is the only thing that comes near being called a really useful Emacs mode.
01:28:39 <_Dae_> Peaker: it still means you did it wrong the first time around.
01:28:42 <ivanm> Peaker: well, AFAIK, making it smarter is non-trivial
01:28:46 <vixey> fasta, not true
01:28:50 <ivanm> fasta: auctex is nice
01:28:57 <Peaker> _Dae_: yes, doing it wrong is often a prerequisite to doing it right
01:29:02 <fasta> ivanm: auctex also contains lots of problems.\
01:29:08 <ivanm> fasta: such as?
01:29:39 <vixey> fasta, (SLIME is great, but it's not the only useful one)
01:29:40 <fasta> ivanm: such as syntax highlighting again :)
01:29:57 <ivanm> fasta: what syntax highlighting problems have you had with haskell-mode and auctex?
01:30:03 <_Dae_> Peaker: true that, but... ohh well, to each his own
01:30:08 <fasta> vixey: rcirc is nice too, but cannot handle proxies and so on.
01:30:56 <fasta> ivanm: regarding the haskell code: I don't have it here, but it's simply a non-trivial module, also containing CPP macros (I don't know whether that matters).
01:31:36 <ivanm> could be
01:31:49 <fasta> ivanm: and regarding the auctex mode, I haven't used auctex for a long time.
01:31:59 <fasta> ivanm: since 11.84 or something.
01:32:53 <fasta> Really, one shouldn't defend software that is buggy. Software should have a bug list of zero and a wishlist that might be of non-zero length.
01:33:39 <ivanm> fasta: that's only one version ago ;-)
01:33:53 <rubber> does haskell use memory mapped files? are they cool?
01:33:55 <ivanm> but I'm not sure in what way you claim it to be buggy...
01:34:32 <ivanm> fasta: btw, which software matches your criteria then? ;-)
01:35:00 <fasta> ivanm: for what purpose? Or in general?
01:37:57 <Peaker> @hoogle mmap
01:37:58 <lambdabot> package mmap
01:37:58 <lambdabot> package bytestring-mmap
01:38:28 <pumpkin> @instances Ix
01:38:29 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
01:41:38 <sbahra> pumpkin, what is "Ix"?
01:41:53 <sbahra> pumpkin, BTW, are you hacking on any specific projects with Haskell or still in reading mode?
01:41:55 <pumpkin> I thought it was a possible index for an array
01:42:18 <pumpkin> sbahra: trying to do my (machine learning) research using it, with varying degrees of success :P
01:42:28 <pumpkin> but enjoying it a lot
01:42:42 <sbahra> Yeah, Haskell is fun. Whether or not you finish a project. :-P
01:43:06 <ivanm> fasta: in general
01:43:16 <pumpkin> I forced myself to actually learn it by doing my final project last term, AND leaving it to the last minute :P
01:43:25 <pumpkin> (that was the first thing I'd really written in it)
01:43:28 <ivanm> pumpkin: yeah, that's what Ix is for (array indices)
01:43:29 * sbahra nods at his statistics project 
01:43:32 <sbahra> pumpkin, what did you write?
01:44:27 <pumpkin> more machine learning stuff, attempting to segment data automatically according to some criteria... the precursor to what I'm doing now, really
01:45:00 <pumpkin> ivanm: thanks... any idea on what's allowed as an index... if I use a pair of Ints, for example, will it be smart and make me a nice 2d array, or will that not even be allowed?
01:45:43 <pumpkin> aha, pairs are allowed
01:45:46 <ivanm> pumpkin: yes
01:45:55 <ivanm> up to 5-tuples are allowed IIRC
01:46:02 <pumpkin> yeah, looks like it
01:46:02 <fasta> ivanm: Oh, well I like how Data.Sequence was proved to be correct by some Coq people. But I don't know about any piece of open-source code which values fixing bugs over fixing features, but probably there are projects that have that property.
01:46:07 <ivanm> @hoogle Ix
01:46:08 <lambdabot> module Data.Ix
01:46:08 <lambdabot> Data.Ix class Ord a => Ix a
01:46:08 <lambdabot> Data.Array.Base ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
01:46:21 <pejo> sbahra, I bet it's more fun to actually finish the phd than failing it in Haskell though. ;)
01:46:23 <pumpkin> ivanm: is it doing smart column/row-major mappings for this, or how is this represented?
01:46:25 <ivanm> @instances-importing Data.Ix Ix
01:46:26 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
01:46:36 <ivanm> pumpkin: however you use it ;-)
01:46:54 <ivanm> but you mean in terms of allocation? not sure, but I'd guess however C does it
01:47:00 <pumpkin> pejo: lol, but mastery of haskell is much better than a phd, surely!
01:47:08 <_Dae_> pumpkin: internally it's be a 1 dimensional array
01:47:09 <pumpkin> ivanm: interesting, I'll try it out then
01:47:10 <ivanm> it might even literally be in one long line
01:47:15 <_Dae_> *it'll
01:47:16 <pumpkin> yeah, that's what I meant
01:47:31 <ivanm> > (1,2) < (2,2)
01:47:32 <lambdabot>   True
01:47:41 <ivanm> > (1,2) < (1,3)
01:47:43 <lambdabot>   True
01:47:45 <pumpkin> @src (,) <
01:47:46 <lambdabot> Source not found.
01:48:01 <ivanm> pumpkin: so increment the second element first
01:48:07 <vixey> @w80 enmity
01:48:10 <lambdabot> *** "enmity" wn "WordNet (r) 2.0"
01:48:10 <lambdabot> enmity
01:48:10 <lambdabot>      n 1: a state of deep-seated ill-will [syn: {hostility}, {antagonism}]
01:48:10 <lambdabot>      2: the feeling of a hostile person; "he could no longer contain
01:48:10 <lambdabot>         his hostility" [syn: {hostility}, {ill will}]
01:48:12 <pumpkin> ivanm: okay, cool :)
01:48:28 <ivanm> (0,0) -> (0,1) -> ... -> (1,0) etc.
01:48:48 <pumpkin> lexicographic then?
01:50:29 <ivanm> pumpkin: ummmmmm....... what do you mean by that? ;-)
01:51:20 <pumpkin> like a dictionary of same-length words? :P
01:51:39 <sbahra> pejo, I wouldn't know. I'm not a PHd student. :-P
01:51:52 <sbahra> pejo, and the ones I work with have been at it for > 5 years (average).
01:51:52 <vixey> @w80 syriac
01:51:52 <pumpkin> sbahra: how could you!
01:51:53 <lambdabot> No match for "syriac".
01:52:04 <ivanm> pumpkin: you referring to ordering of the tuples?
01:52:05 <pumpkin> sbahra: you must become a PhD student!
01:52:10 <pumpkin> ivanm: yeah :)
01:52:10 <ivanm> yeah, looks something like that
01:52:25 <sbahra> I had issues with academia, mainly due to the institution I'm in. I just recently worked through them. Haskell helped. :-P
01:52:40 <pumpkin> :o
01:53:52 <Badger> @faq can Haskell fix sbahra's academic issues?
01:53:52 <lambdabot> The answer is: Yes! Haskell can do that.
01:54:08 <pumpkin> @faq can Haskell get me a PhD in a month?
01:54:09 <lambdabot> The answer is: Yes! Haskell can do that.
01:54:11 <pumpkin> sweet
02:20:27 <ac> how do I unbind something in ghci?
02:20:52 <ac> ah, :undef (stupid question)
02:21:03 <EvilTerran> i don't think that does what you think it does
02:21:26 <EvilTerran> :undef <cmd>                undefine user-defined command :<cmd>
02:23:25 <sbahra> http://developers.slashdot.org/developers/09/01/07/2316227.shtml
02:26:08 <jesusabdullah> I forget /. still exists sometimes.
02:28:27 <sbahra> For good reason. :-)
02:28:37 <sbahra> Anyone here use the gnuplot package before? http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gnuplot
02:30:00 <chylli> I have an huge table like (key,value), which data type should I use ? Data.Map or Data.HashTable or something else ?
02:30:21 <sbahra> chylli, what is the key?
02:30:25 <sbahra> chylli, the type of key.
02:30:47 <chylli> sbahra: the key is a sting with max length 4
02:31:01 <quicksilver> chylli: not hashtable.
02:31:04 <EvilTerran> chylli, are the keys unique?
02:31:10 <chylli> yes
02:31:13 <sbahra> chylli, you could go with Data.Map. If the keys are unique, IntMap is great.
02:31:24 <sbahra> But you'll need a mapping to the int values.
02:31:25 <quicksilver> Data.Map should be OK. Something Trie-based would be better.
02:31:34 <quicksilver> I think there is a String Trie on hackage now?
02:31:35 <sbahra> quicksilver, any recommendations on this?
02:31:47 <sbahra> quicksilver, I'm implementing a caching web server, currently using a Data.Map.
02:32:00 <chylli> lookup operation must be quick
02:32:12 <quicksilver> "quick" is relative.
02:32:13 * sbahra was planning on using bytestring-trie.
02:32:18 <chylli> will not change after construct it
02:32:28 <sbahra> But I don't see the benefit of a trie when filenames are unique (tree depth is very limited).
02:32:33 <quicksilver> Data.Map has decent complexity but a highish constat factor
02:32:53 <quicksilver> Data.HashTable has a better complexity and a boggling bad constant factor.
02:33:45 * EvilTerran would use Data.Map
02:33:49 <chylli> quicksilver: in fact, I want to write a input methold for yi editor. this table is Chinese character encoding table.
02:34:01 <sbahra> That is, very likely to be unique even at start (different prefix).
02:34:01 <quicksilver> I would start with Data.Map
02:34:03 <quicksilver> it's simple.
02:34:24 <quicksilver> if it turns out to be too slow for your needs, then find something else
02:34:34 <quicksilver> data.map lookups are in microseconds not milliseconds
02:34:39 <quicksilver> that should be fine for an input method.
02:34:48 <quicksilver> it's only a problem if you're trying to do millions per second.
02:34:53 <sbahra> quicksilver, what algorithm does Data.Map use?
02:34:59 <quicksilver> balanced tree
02:35:03 <quicksilver> redblack, I think.
02:35:07 <sbahra> Ah, ok. :)
02:35:19 <chylli> thanks very much.
02:35:44 <quicksilver> beware premature optimisation :)
02:35:49 <EvilTerran> some immutable tree structure that means that, when adding/removing/changing a node in a Map of n elements, only O(log n) nodes need be replaced, and the rest are shared
02:36:21 <sbahra> Sure, I just was hoping it wasn't simply "balanced tree". :-P
02:37:23 <quicksilver> yeah, Data.Map is a huge win if you need to hold on to alternative versions of the structure (e.g. for an undo history)
02:37:27 <quicksilver> that's a pretty unusual case, though.
02:37:38 <quicksilver> in that case it beats hashtable in complexity too.
02:37:44 <quicksilver> as well as constant factor :)
02:38:05 <sbahra> This is my case.
02:38:22 <sbahra> Well, similar. History is built incrementally (and concurrently).
02:42:48 <Saizan_> it's size-balanced, if they haven't changed it recently
02:44:07 <chylli> I tried some example at http://nobugs.org/developer/yi/example-comment-region.html but failed :(
03:59:39 <vixey> anyone know some easier texts online about normalization by evaluation?
04:00:30 <sbahra> Yes.
04:16:03 <chrisdone> sbahra: gee, useful answer
04:19:33 <sbahra> chrisdone, Yes. :-)
04:26:23 <vixey> I don't see how it works for  \(f :: (a -> a) -> b) (x :: a -> a) -> f x
04:27:25 <vixey> (because how does it reach in to eta expand the x if it never enters applications?)
04:37:44 <vixey> I invented my own algorithm which works... but I bet the (simpler) usual one works too I just can't see how
04:44:08 <chessguy_work> 'morning
04:44:49 <Axman6> evenin'
04:45:19 <vixey> hi
04:45:20 <chessguy_work> hey Axman6 , how goes the RWH study?
04:45:51 <Axman6> haven't done that much lately, been doing other things, and watching SICP videos
04:45:58 <chessguy_work> ah, nice
04:46:20 <chessguy_work> i probably need to go back an watch those again, been a little while
04:47:56 <Axman6> found a really interesting article on reddit today: http://www.reddit.com/r/programming/comments/7nl9r/they_write_the_right_stuff_how_nasa_writes/
04:49:30 <Axman6> i'd never thought about the process NASA must go through to write their software, but it truly does have to be perfect
04:49:45 <chessguy_work> true!
04:50:18 * vixey I thought they just hack like everyone ese
04:50:37 <vixey> didn't they have that parsing bug with dangling else which made a space-thing completely break
04:51:30 <Axman6> something like 1/3 of the system is already done before they start coding anything.
04:52:08 <whoppix> Axman6, so.. uhm.. where is the article?
04:52:27 <Axman6> they needed a 2500 page document on every single change they were going to make when they added the ~6000 lines of code to make the shuttle use GPS
04:52:32 <vixey> design/programming/testing ? :p
04:52:35 <Axman6> could have been 25000 actually
04:52:46 <chessguy_work> '"Houston, we have a problem," may make for a good movie; it's no way to write software'
04:53:04 <Axman6> whoppix: never used rddit before? http://www.fastcompany.com/magazine/06/writestuff.html?page=0%2C0
04:53:09 <Axman6> reddit*
04:53:25 <whoppix> Axman6, Hm, i tried that, but it doesn't load.
04:53:30 <Axman6> vixey: pretty much, but the design is insanely detailed
04:53:31 <whoppix> and no, I've never used reddit.
04:53:38 <Axman6> click the skip this add link
04:53:46 <whoppix> ah. took hell of a long time to load.
04:54:45 <vixey> any real world languages with linear types about?
04:54:48 <vixey> It seems not..
04:55:11 <vixey> there's ATS but I don't count it because the section about them in the manual is missing
04:55:23 <chessguy_work> Axman6, that's a really interesting article
04:55:44 <Axman6> read it all already?
04:56:49 <chessguy_work> i'm a fast reader :)
04:57:01 <dolio> Hey, I have received a black macbook air.
04:57:05 <Axman6> all 6 pages of it? damn
04:57:09 <dolio> Thanks WinnerNotification@daggerz.net
04:57:19 <chessguy_work> haha
04:57:21 <Axman6> dolio: they come in vlack now?
04:57:27 <Axman6> black even
04:57:38 <dolio> I guess. I have one that I didn't even know about.
04:57:49 <Axman6> oh, well done
04:57:58 <dolio> I had to find out from some e-mail.
04:58:13 <vixey> dolio, wait is it spam or you really got a book?
04:58:20 <dolio> It's spam.
04:59:12 <chessguy_work> dolio, http://blogs.msdn.com/officeoffline/archive/2007/12/28/you-get-what-you-pay-for.aspx
05:01:11 <vixey> I found a very simple description of logical relations: www.cs.princeton.edu/~dpw/courses/spring02/logical.ps
05:01:25 <vixey> on simple typed lambda calculus
05:03:40 <Axman6> this is pretty sweet: http://www.galaxiki.org/web/main/_blog/all/build-your-own-nasa-apollo-landing-computer-no-kidding.shtml
05:04:26 <mopped> @src scanl
05:04:26 <lambdabot> scanl f q ls = q : case ls of
05:04:26 <lambdabot>     []   -> []
05:04:26 <lambdabot>     x:xs -> scanl f (f q x) xs
05:05:52 <mopped> How do I build a list of infinite 1s? ;s
05:06:18 <ecraven> hey :) anyone here using hledger?
05:06:20 <ksf> Well... I've seen a couple of zaroo-bugs 30k - 40k lines java programs.
05:06:22 <liff> mopped: repeat 1?
05:06:26 <vixey> mopped: ones = 1 : ones
05:06:35 <ksf> ...not using objects, mind you.
05:08:37 <Axman6> Jedai: what were they for?
05:08:45 <Axman6> uh, ksf, sorry Jedai
05:08:50 <ksf> games.
05:08:52 <ksf> j2me.
05:08:56 <Axman6> ah
05:10:43 <ksf> it's surprising what assigning a single, able coder to one game can do if QA has zero tolerance and sales isn't allow to interfere.
05:15:14 <Axman6> ksf: indeed
05:15:40 <Axman6> i like the way NASA do things, having a sort of rivalry between the testers and the coders, both wanting to find the bugs first
05:16:28 <ksf> basically, you'd see a lot of specialized, turing-incomplete versions of half of common lisp.
05:16:45 <vixey> ksf wow I never heard that a million times before
05:17:29 <ksf> nope, that'll be the informally-specified, bug-ridden version.
05:19:20 <ksf> it's even worse if you take over maintanance of a game and the only bug you're able to find in three months is the fault of a certain mobile's vm.
05:26:13 <chessguy_work> @hoogle a -> (a -> a) -> [a]
05:26:14 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
05:26:14 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
05:26:14 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
05:27:05 <chessguy_work> @hoogle a -> a -> (a ->a -> a) -> [a]
05:27:05 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
05:27:05 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
05:27:05 <lambdabot> Prelude scanr :: (a -> b -> b) -> b -> [a] -> [b]
05:29:26 * ksf thinks specs are bogus.
05:29:32 <stevan> hi, i'm having a problem with haskell-mode for emacs. i got both ghc 6.8.3 and 6.10.1 on the system. using the same .emacs file, same haskell-mode version (2 day old cvs version), same haskell file: C-c C-l loads the file in 6.8.3, but in 6.10.1 i get: http://hpaste.org/13757 . note the second load there ':load "'... i'm not doing that myself, it seems i get that as a bonus everytime i load a file using an absolute path (which C-c C-l ...
05:29:39 <stevan> ... always does)... any ideas? thanks.
05:29:43 <ksf> as, obviously, a program is its own spec.
05:32:15 <asgaroth> stevan: Not a solution for your real problem, but the annoying repetition of entered commands can be solved by writing a wrapper that runs "cat | ghci $*" and using that for the emacs mode
05:33:02 <Lanjiao> some one knows a real website built by haskell?
05:34:16 <fldr> stevan: I also had this problem. I wrote a patch and sent it to the haskell-mode maintainer, but haven't heard from him since.
05:34:20 <stevan> Lanjiao: http://johnmacfarlane.net:5001/  http://hpaste.org
05:34:33 <chessguy_work> Lanjiao, also http://hope.bringert.net/about
05:37:06 <fldr> stevan: btw, does C-u C-c C-t work for you in 6.10?
05:39:43 <stevan> nope, "No type info:"
05:41:16 <Lanjiao> chessguy_work: thanks and what haskell software is bringert.net built on? happs?
05:42:27 <fldr> stevan: Ok, can you please send a bug report to the haskell-mode maintainer? My patch fixes this problem for me (in 6.10), maybe the package maintainer will apply it if we'll nag him a bit.
05:42:45 <chessguy_work> Lanjiao, as the site says, it's built with a CMS called "Hope". there's a darcs repo link in the 'About' section
05:43:59 <Lanjiao> chessguy_work: thanks. i plan to build a website using haskell, so thanks again for your valuable info.
05:44:12 <chessguy_work> sure thing
05:44:32 <chessguy_work> @seem bringert
05:44:32 <lambdabot> I saw bringert leaving #haskell.se, #ghc and #haskell 1m 5d 15h 43m 28s ago, and .
05:44:44 <chessguy_work> i believe bringert still hangs out on here, but not 100$ sure
05:44:49 <chessguy_work> %
05:45:25 <stevan> fldr: mind sending over your patch to me? so that i can test it. if it works for me i'll email the maintainer and tell him your patch fixed my problem too.
05:51:17 <baaba> @pl f x = fmap ($ f x) x
05:51:17 <lambdabot> f = fix (fmap . flip id =<<)
05:51:36 <vixey> obsessed..
05:51:39 <baaba> haha ;)
05:51:51 <vixey> I think you have a problem
05:51:56 <vixey> addiction
05:52:03 <idnar> a pointless addiction?
05:52:07 <baaba> no it was more about the pointless part than the loeb part
05:52:30 <Raynes> Haskell is an addiction.
05:52:43 <baaba> but seeing the pl transformations is indeed addictive
05:54:33 <vixey> :t (flip id =<<)
05:54:34 <lambdabot> forall a c. ((a -> c) -> a) -> (a -> c) -> c
05:54:47 <vixey> :t (fmap . flip id =<<)
05:54:48 <lambdabot> forall (f :: * -> *) a c. (Functor f) => (f (a -> c) -> a) -> f (a -> c) -> f c
05:54:54 <vixey> :t (fmap . (flip id =<<))
05:54:55 <lambdabot> forall (f :: * -> *) a c. (Functor f) => ((a -> c) -> a) -> f (a -> c) -> f c
05:55:01 <vixey> :t ((fmap . flip id) =<<)
05:55:03 <lambdabot> forall (f :: * -> *) a c. (Functor f) => (f (a -> c) -> a) -> f (a -> c) -> f c
05:55:07 <vixey> :t (fmap . flip id)
05:55:09 <lambdabot> forall (f :: * -> *) a c. (Functor f) => a -> f (a -> c) -> f c
05:55:24 <vixey> :t (<$>)
05:55:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:55:37 <vixey> there must be a better way to write fmap . flip di?
05:55:44 <vixey> :t (<*>)
05:55:45 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:56:00 <vixey> @src (<*>)
05:56:00 <lambdabot> Source not found. My pet ferret can type better than you!
05:56:18 <vixey> :t (?x . flip id)
05:56:19 <lambdabot> forall c a c1. (?x::((a -> c1) -> c1) -> c) => a -> c
05:56:37 <dublpaws> :t (<->)
05:56:39 <lambdabot> Not in scope: `<->'
05:57:05 <vixey> ?djinn a -> (e -> (a -> b)) -> (e -> b)
05:57:05 <lambdabot> f a b c = b c a
05:57:12 <vixey> @pl f a b c = b c a
05:57:12 <lambdabot> f = flip flip
05:57:24 <vixey> :t fix (flip flip =<<)
05:57:26 <lambdabot> forall a c. (a -> (a -> c) -> c) -> a -> c
05:57:50 * vixey gives up..
05:59:47 <Lanjiao> someone knows how to install HAppS?
05:59:49 <lilac> @type \x -> fmap ($x)
05:59:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => a -> f (a -> b) -> f b
05:59:53 <Lanjiao>    1.  1. darcs get http://happs.org/repos/happs.org MyProject
05:59:55 <Lanjiao>    2. 2. cd MyProject
05:59:57 <Lanjiao>    3. 3. sp ghc -isrc src/Main.hs --make --run --http-port=5000
05:59:59 <lilac> @type (<$> ($x))
06:00:01 <lambdabot> forall b b1. (b1 -> b) -> (Expr -> b1) -> b
06:00:18 <Lanjiao> the steps in the websites not work for me
06:00:18 <lilac> @type \x -> (($x) <$>)
06:00:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => a -> f (a -> b) -> f b
06:00:27 <Lanjiao> sp: command not found
06:00:40 <vixey> :t ($ ?x)
06:00:41 <lambdabot> forall a b. (?x::a) => (a -> b) -> b
06:00:43 <vixey> :t (($) ?x)
06:00:44 <lambdabot> forall a b. (?x::a -> b) => a -> b
06:00:51 <vixey> :t flip ($)
06:00:53 <lambdabot> forall a b. a -> (a -> b) -> b
06:01:01 <vixey> :t (<$>) (flip ($))
06:01:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> f ((a -> b) -> b)
06:01:09 <vixey> :t flip (<$>) (flip ($))
06:01:10 <lambdabot> forall b a b1. (((a -> b1) -> b1) -> b) -> a -> b
06:01:15 <vixey> weird..
06:01:24 <lilac> @type (<$>) . flip ($)
06:01:25 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
06:01:58 <vixey> @src Functor
06:01:58 <lambdabot> class  Functor f  where
06:01:59 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
06:02:51 <vixey> ?djinn ((a -> b) -> b) -> (e -> (a -> b)) -> (e -> b)
06:02:51 <lambdabot> f a b c = a (b c)
06:02:59 <lilac> @type \f x -> f <*> pure x
06:03:01 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> a -> f b
06:03:14 <lilac> @pl \f x -> f <*> pure x
06:03:14 <lambdabot> (. pure) . (<*>)
06:03:29 <vixey> @pl \x f -> f <*> pure x
06:03:29 <lambdabot> flip (<*>) . pure
06:04:02 <fldr> stevan: have you got the file?
06:04:16 <stevan> fldr: hmm, after your patch it still works in 6.8.3 but in 6.10.1 i now only get the ':load "'... http://hpaste.org/13757#a1
06:05:32 <lilac> @@ @pl @djinn a -> (x -> a -> b) -> x -> b
06:05:33 <lambdabot>  f = flip flip
06:05:36 <fldr> stevan: hmm, weird
06:06:17 <fldr> stevan: does C-c C-t work?
06:06:18 <stevan> fldr: send me you whole inf-haskell.el? perhaps we didn't have the same haskell-mode version?
06:07:12 <stevan> yes, C-c C-t works.
06:08:27 <stevan> nope, our inf-haskell.el files are identical. hmm...
06:09:56 <fldr> stevan: maybe there are spaces in the path of the file you are trying to load? and btw, which emacs version do you use?
06:10:15 <stevan> 22.3.1
06:10:56 <fldr> and which OS?
06:11:43 <stevan> linux
06:12:21 <stevan> there are no spaces in the path.
06:12:47 <fldr> hmm, I use linux and emacs 23, and everything works fine with my patch.. even with spaces in the path
06:14:25 <fldr> that is, both C-c C-l and C-c C-t
06:15:25 <fldr> i'll try to reproduce this on emacs 22
06:20:48 <int80_h> hi everyone :)
06:21:10 <vixey> hi
06:23:15 <pk> @src cycle
06:23:15 <lambdabot> cycle [] = undefined
06:23:16 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
06:23:30 <pk> why isn't cycle defined as :
06:23:39 <vixey> pk, because that wouldn't work
06:23:46 <vixey> @src repeat
06:23:46 <lambdabot> repeat x = xs where xs = x : xs
06:23:47 <vixey> :t cycle
06:23:48 <fldr> stevan: sorry, but I can't reproduce your problem, it works for me even with emacs 22
06:23:49 <lambdabot> forall a. [a] -> [a]
06:23:49 <vixey> :t repeat
06:23:50 <lambdabot> forall a. a -> [a]
06:24:05 <lilac> pk: it's not defined as "cycle xs = xs ++ cycle xs" because that would use more memory
06:24:09 <fldr> stevan: but at least my patch fixed C-c C-t :-)
06:24:23 <pk> why ?
06:24:48 <lilac> pk: the real definition creates a cyclic linked list
06:24:55 <lilac> the end of the list points back to the start
06:25:09 <vixey> cycle xs = xs' () where xs' () = xs ++ xs' ()
06:25:14 <lilac> the recursive definition calls cycle again when it gets to the end
06:25:18 <stevan> fldr: :-), thanks for the help.
06:25:33 <blathijs> What does ! in a type mean?
06:26:04 <lilac> blathijs: strict field
06:26:04 <blathijs> One of the fields in the CoreModule data type is cm_types :: !TypeEnv
06:26:14 <blathijs> lilac: Ah, thanks
06:27:14 <lilac> pk: does that make sense?
06:28:00 <pk> lilac: I think I see
06:28:15 <pk> lilac: The good definition doesn't expand to xs ++ xs ++ xs ...
06:28:18 <pk> does it ?
06:28:23 <fldr> stevan: write a bug report to the package maintainer nevertheless, maybe he'll be more helpful
06:28:41 <EvilTerran> pk, well, semantically it does, but it's represented as a circular list in memory
06:30:29 <EvilTerran> pk, it's related to the fact that (in ghc, and probably most sensible implementations) a value bound to a name is only ever calculated once
06:30:37 <lilac> pk: right. the result is xs ++ xs', where xs' is the result. so if xs' = cycle [1,2,3], you get xs' = 1:2:3:xs'
06:30:44 <stevan> fldr: i will.
06:30:52 <lilac> which uses a finite amount of storage no matter how far down xs' you look
06:30:58 <pk> ok, I get it
06:31:01 <EvilTerran> pk, while a function that takes one or more parameters is calculated every time it's called
06:33:44 <pk> I guess it's the same for every cyclic data structure ?
06:34:49 <vixey> what's the same?
06:35:56 <pk> I mean, if building a cyclic tree, I should assure that my nodes are pointing to elements, not functions that generates elements
06:36:08 <vixey> you could do either one
06:36:17 <vixey> > iterate (+1) 0
06:36:21 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
06:36:26 <EvilTerran> btw, a "cyclic tree" is a directed graph :P
06:36:32 <lilac> pk: semantically, it doesn't matter. but yes, if you want to minimize the size of your structure.
06:36:51 <pk> ok, thank you
06:37:40 <lilac> EvilTerran: in a tree, every non-root node has one parent. not so in a directed graph
06:38:25 <lilac> so presumably a cyclic tree would be a connected directed graph where every node has an in-degree of 1
06:39:35 <EvilTerran> eh
06:39:41 <EvilTerran> trees aren't cyclic, that's the problem :P
06:39:52 <pk> well, I meant a directed graph
06:45:21 <augustss> @pl x >>= \ x' -> y >>= op x'
06:45:21 <lambdabot> (y >>=) . op =<< x
06:46:37 <ziman> i guess it could be liftM2 op
06:47:16 <lilac> that's do { x' <- x; y' <- y; op x' y' }, which looks like liftM2 to me too
06:47:24 <lilac> @type liftM2
06:47:26 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:47:30 <ziman> @src liftM2
06:47:31 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
06:47:37 <ziman> hm.
06:47:42 <lilac> @type (liftM2 .) . return
06:47:44 <lambdabot> forall a1 a2 r (m :: * -> *) a. (Monad m) => (a1 -> a2 -> r) -> a -> m a1 -> m a2 -> m r
06:48:28 <ziman> :t (join .) . liftM2
06:48:30 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a2)
06:48:30 <lambdabot>     Probable cause: `liftM2' is applied to too many arguments
06:48:30 <lambdabot>     In the second argument of `(.)', namely `liftM2'
06:49:06 <ziman> :t ((join .) .) . liftM2
06:49:07 <lambdabot> forall a a1 a2 (m :: * -> *). (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
06:50:01 <lilac> @pl \o a b -> join (liftM2 o a b)
06:50:01 <lambdabot> ((join .) .) . liftM2
06:50:59 <lilac> @@ @pl @undo \o a b -> do { a' <- a; b' <- b; a' `o` b' }
06:51:00 <lambdabot>  flip ((.) . (>>=)) . flip ((.) . (>>=))
06:51:14 <ziman> i guess the poinful style would be the most readable :)
06:51:23 <ziman> *pointful
06:52:40 <lilac> @type let x = flip ((.) . (>>=)) in x . x
06:52:42 <lambdabot> forall a a1 (m :: * -> *) b. (Monad m) => (a -> a1 -> m b) -> m a -> m a1 -> m b
06:52:45 <lilac> @type let x = flip ((.) . (>>=)) in join (.) x
06:52:47 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
06:52:47 <lambdabot>     Probable cause: `join' is applied to too few arguments
06:52:54 <lilac> @pl \x -> x . x
06:52:55 <lambdabot> join (.)
06:53:20 <vixey> :t iterate (?f .) id
06:53:20 <lilac> weird
06:53:21 <lambdabot> forall a. (?f::a -> a) => [a -> a]
06:53:22 <Deewiant> the two x's have different types
06:53:37 <Deewiant> which is why it doesn't work
06:53:58 <Deewiant> ?ty join (.)
06:53:58 <lilac> Deewiant: but the x itself is polymorphic? right
06:54:00 <lambdabot> forall b. (b -> b) -> b -> b
06:54:07 <ziman> MR?
06:54:15 <vixey> ziman, no just lambda vs let
06:54:15 <Deewiant> no, it just can't work :-P
06:54:20 <lilac> @type let x = flip ((.) . (>>=)) in (\y -> y . y) x
06:54:21 <Deewiant> ?ty join (***)
06:54:21 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
06:54:22 <lambdabot>       Expected type: (m a -> a -> m b) -> m a -> a -> m b
06:54:22 <lambdabot>       Inferred type: (m a -> a -> m b) -> m a -> m a -> m b
06:54:23 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
06:54:32 <Deewiant> ?ty \x -> x *** x
06:54:33 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
06:54:42 <Deewiant> meh
06:54:44 <Deewiant> bad example
06:55:01 <ski_> maybe there ought to be combinators for `(a0 -> ... -> m b) -> (m a0 -> ... -> m b)' ?
06:55:01 <lilac> Deewiant: you can't show it that way
06:55:11 <Deewiant> yep
06:55:27 <lilac> ski_: <$> and <*> work if the Applicative instance has been provided
06:56:14 <ski_> @type \f ma mb -> f <$> ma <*> mb
06:56:16 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
06:56:29 <ski_> not quite what i wanted
06:56:29 <Deewiant> ?ty let x = (+1) in x *** x
06:56:30 <Deewiant> ?ty join (***) (+1)
06:56:31 <lambdabot> forall a b'. (Num a, Num b') => (a, b') -> (a, b')
06:56:32 <lambdabot> forall c. (Num c) => (c, c) -> (c, c)
06:56:34 <Deewiant> there we go
06:56:39 <vixey> ski, do you happen to know this NbE method?
06:56:50 <ski_> vixey : know what about it ?
06:57:00 <vixey> well just this one thing confuses me,
06:57:10 <vixey> \(f :: (a -> a) -> b) (x :: a -> a) -> f x
06:57:16 <vixey> for this term, I thought it shoudl expand into
06:57:23 <vixey> \(f :: (a -> a) -> b) (x :: a -> a) -> f (\i -> x i)
06:57:41 <vixey> but you know the reify/reflect rule... never traverses inside an application
06:58:00 <vixey> so it can't possible expand like that.. but of course it must... so I don't know what I am missing
06:58:14 <dolio> Why would that be expanded like that?
06:58:26 <vixey> I made up my own algorithm which works a bit different, but the normal way is different to mine (and it's simpler)
06:58:33 <ski_> i think the `NbE' i recall would be type-directed, not syntax-directed
06:58:36 <vixey> dolio, to get eta equality
06:58:47 <vixey> yes I eta expand x because of the type a -> a
06:58:59 <dolio> You don't normally eta expand to get a normal form.
06:59:10 <dolio> You'd reduce, if anything.
06:59:28 <dolio> But I suppose that doesn't answer the question.
06:59:28 <ski_> so, we have `e :: ((a -> a) -> b) -> (a -> a) -> b' and do induction on the type structure
06:59:41 <vixey> you can beta-reduce and eta-expand to get beta-eta-normal-forms
07:01:24 <vixey> oh! so you change e into \f x -> e (\i -> x i)
07:01:34 <vixey> and if e started out as,  \(f :: (a -> a) -> b) (x :: a -> a) -> f x
07:01:35 <vixey> then,
07:01:43 <ski_>     [||]_R e
07:01:50 <vixey> \f x -> (\(f :: (a -> a) -> b) (x :: a -> a) -> f x) (\i -> x i), ... gives a type error :?
07:01:54 <ski_>   = `(\(x :: (a -> a) -> b) -> ,[|e `x|]))
07:02:09 <ski_> hm
07:02:48 * ski_ manages to do three (small) mistakes at the same time
07:03:06 <vixey> I think NbE is very confusing :S
07:03:32 <vixey> ohh
07:03:37 <ski_>     [|e|]_R
07:04:04 <ski_>   = `(\(x :: (a -> a) -> b) -> ,[|e [|x|]_r|]_R))
07:04:13 <ski_> (was what i meant to say)
07:05:02 <ski_> (where the `R' denotes reification, and `r' denotes reflection .. i don't recall the original notation)
07:05:27 <ski_> (hm, it might be a good idea to keep the types visible, actually)
07:05:34 <vixey> down arrow for R, up arrow for r
07:05:46 <ski_> that sounds familiar
07:06:01 <ski_>     [|e :: ((a -> a) -> b) -> (a -> a) -> b|]_R
07:07:48 <vixey> so, e = \f x -> f x :: ((a -> a) -> b) -> (a -> a) -> b
07:07:58 <vixey> and the fully expanded thing gives:  \f x -> e (\i -> f i) (\i -> x i)
07:08:03 <vixey> = \f x -> (\f x -> f x) (\i -> f i) (\i -> x i)
07:08:20 <vixey> but that beta reduces down (by NbE) to  \f x -> f (\i -> x i)
07:09:01 <vixey> that's really amazing you don't need to inspect the term /at all/
07:09:18 <vixey> ski_, I think I see it now, thank you :)
07:09:32 <ski_> nice, since i don't think i see it atm ;)
07:10:17 <ski_> (also, istm there were some fun stuff with delimited continuations mixed in somewhere)
07:10:37 <int80_h> test
07:10:45 <RayNbow> > let roundUp = fromIntegral . truncate . (+0.5) in map roundUp [0.5, 1.5..]
07:10:46 <ski_> > test
07:10:47 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
07:10:48 <lambdabot>   Not in scope: `test'
07:10:51 <vixey> ski_, oh
07:10:56 <pippijn> hi all
07:11:06 <ski_> lo any
07:11:19 <int80_h> hi, I have a problem with the palindrome test problem in RWH.
07:11:21 <int80_h> http://hpaste.org/13758
07:11:34 <pippijn> is there a tool, feature of ghc/hugs or online utility that can show me the precedences of haskell expressions
07:11:43 <lilac> pippijn: :info in ghci
07:11:50 <vixey> [[e :: ((a -> a) -> b) -> (a -> a) -> b]]  ~~> \f x -> e [f :: ((a -> a) -> b)] [x :: (a -> a)] ~~> \f x -> e (\i -> f i) (\i -> x i)
07:11:59 <vixey> ski_, I think it's just like that basically
07:12:07 <vixey> except this might not be the whole story
07:12:28 <ski_> int80_h : why is `[42]' not a palindrome ?
07:12:46 <vixey> unless I am mixing up quotation back into syntactic terms with reflect
07:12:51 <int80_h> because the first element doesn't equal the last
07:12:57 <lilac> int80_h: yes it does :)
07:13:11 <int80_h> um, it does?
07:13:15 <ski_> > head xs == last xs  where  xs = [42]
07:13:17 <lambdabot>   True
07:13:23 <ski_> > (head xs,last xs)  where  xs = [42]
07:13:25 <lambdabot>   (42,42)
07:13:33 <grul> oh and there's a problem in "isPalindrome (xs)
07:14:04 <int80_h> I don't understand how 4 == 2
07:14:19 <grul> it's a number, it's not "42", it's 42
07:14:19 <PeakerWork> int80_h: its [42], not 42
07:14:23 <ski_> > [42] == [4,2]
07:14:25 <lambdabot>   False
07:14:35 <ski_> > (length [42],length [4,2])
07:14:36 <lambdabot>   (1,2)
07:15:35 <int80_h> ski_: okay I got that
07:15:37 <pippijn> lilac: can you give me an example for :info on how to find the precedence for: print $ show System.getArgs
07:16:05 <lilac> pippijn: ":info ($)" ghci says: "infixr 0 $"
07:16:12 <pippijn> oh..
07:16:19 <ski_> int80_h : now, `[0,1,0]' ought to be a palindrome, agree ?
07:16:26 <int80_h> ski_ yes
07:16:29 <pippijn> I'd like to see that expression completely bracketed
07:16:30 <lilac> pippijn: do you want something which says "(print) $ (show System.getArgs)"
07:16:33 <pippijn> yes
07:16:53 <ski_> int80_h : so when you call `isPalindrome [0,1,0]', which equation will be used ?
07:16:54 <lilac> pippijn: ah. then i'm not sure. but function application always binds tighter than infix operators.
07:17:20 <pippijn> okay
07:17:44 <lilac> pippijn: so if you see "foo bar $ baz + quux * griblit smarm" you know it's "(foo bar) $ (baz) + (quux) * (griblit smarm)"
07:17:58 <lilac> you can then use :info on the operators to find out which one will be done first
07:18:00 <ski_> int80_h : hint, either `isPalindrome [] = ...' or `isPalindrome (x:xs) | ...' will be used
07:18:18 <pippijn> lilac: okay, thanks
07:18:28 <int80_h> ski_ : right, I was cutting and pasting...
07:18:28 <lilac> int80_h: you want to recursively call isPalindrome on all but the first and the last element, right?
07:18:30 <int80_h> | x == last (xs)     = isPalindrome (xs)
07:18:48 <ski_> int80_h : yes .. so what values will `x' and `xs' have in this specific case ?
07:18:54 <int80_h> oh crap, yeah I see that problem lilac. I'll fix that now
07:19:01 <ski_> (namely `isPalindrome [0,1,0]')
07:19:02 <lilac> > init "Hello"
07:19:04 <lambdabot>   "Hell"
07:19:18 <int80_h> lilac, can't use init yet
07:19:27 <int80_h> ski_ 0 and 0
07:19:53 <ski_> int80_h : are you sure that `xs' will have value `0' ?
07:20:12 <int80_h> ski_ two conversations going on right now. I'll check it again
07:20:22 <ski_> > test [0,1,0]  where  test (x:xs) = (x,xs)
07:20:24 <lambdabot>   (0,[1,0])
07:20:43 <vixey> ski_, but proving that it gives beta-eta normal forms would be a different matter
07:21:12 <vixey> I think I saw it done with logical relations and kripke models but I don't know about kripke yet
07:21:41 <ski_> vixey : aye
07:22:07 <ski_> (vixey : currently i'm trying to recall the actual rules for the cases ..)
07:22:21 <vixey> I can get them from omething
07:22:29 <SamB_XP> omething ?
07:22:31 <ski_> "omething" ?
07:22:32 <vixey> yes
07:22:38 <vixey> 1 sec
07:22:42 <int80_h> ski_ : uh I'm throughly confused by that test
07:22:56 <int80_h> what does x:xs have to do with x,xs?
07:23:37 <ski_> int80_h : the only thing that test accomplishes is it see what `x' and `xs' becomes bound to, if you match `[0,1,0]' against the pattern `x:xs' (like in your `isPalindrome' definition)
07:23:52 <SamB_XP> > test []  where  test (x:xs) = (x,xs)
07:23:53 <lambdabot>   * Exception: /tmp/1103122028593505389:71:48-67: Non-exhaustive patterns in ...
07:24:00 <ski_> *nod*
07:24:23 <SamB_XP> @tell gwern could mueval perhaps stand to use slightly shorter filenames ?
07:24:23 <lambdabot> Consider it noted.
07:24:45 <ski_> int80_h : so by that test, we know that if we call `isPalindrome [0,1,0]' and if the `isPalindrome (x:xs) | ...' equation is selected, then `x' will be `0' and `xs' will be `[1,0]'
07:24:47 <int80_h> hmm, okay I'm going to try a different approach
07:24:50 <ski_> (which was what i asked)
07:24:53 <vixey> reify :: [[ a ]] -> Exp a;  reify_* e = e;  reify_(sig -> tau) f = \x -> reify_b (f (reflect x))
07:24:54 <SamB_XP> @tell gwern <SamB_XP> > test []  where  test (x:xs) = (x,xs)
07:24:54 <lambdabot> Consider it noted.
07:25:05 <SamB_XP> @tell gwern <lambdabot>   * Exception: /tmp/1103122028593505389:71:48-67: Non-exhaustive patterns in ...
07:25:05 <lambdabot> Consider it noted.
07:25:19 <ski_> int80_h : also, lilac was getting at the same issue as me .. possibly in a less roundabout way
07:25:29 <vixey> oops
07:25:35 <vixey> reify :: [[ a ]] -> Exp a;  reify_* e = e;  reify_(sig -> tau) f = \x -> reify_tau (f (reflect x))
07:25:46 <vixey> reflect :: Exp a -> [[ a ]];  reflect_* e = e;  reflect_(sig -> tau) e = \d -> reflect_tau (e (reify x))
07:25:51 <int80_h> ski_ yeah paying attention to what she was saying, and what you were saying at the same time was rather discombobulating
07:26:13 <vixey> one thing which is a little bit strange is:  \d -> reflect_tau (e (reify x)) -- abstract ''d, but use 'x'
07:26:21 <ski_> int80_h : feel free to ignore at least one of us :)
07:26:24 <vixey> but x comes from (GENSYM) here
07:27:04 <vixey> but ski_ I took this from some notes by Peter Dybjer
07:27:46 <int80_h> ski_ so if x is [0] and xs [1,0] then last xs is [0] right?
07:27:54 <ski_> (vixey : yes, i was porbably mixing up quotation and reflection ..)
07:28:16 <ski_> > last xs  where  x = [0] ; xs = [1,0]
07:28:18 <lambdabot>   0
07:28:21 <ski_> aye
07:29:01 <int80_h> okay, then the problem isn't x == last (xs) but how I do the recursion
07:29:22 <ski_> > init xs  where  x = [0] ; xs = [1,0]
07:29:23 <lambdabot>   [1]
07:29:49 <int80_h> ski_ can't use init yet
07:29:59 <int80_h> trying to stick to the book
07:30:22 <pippijn> can ghc be made to compile the code to C?
07:30:36 <pippijn> oh wait
07:30:38 <pippijn> I might have found it
07:31:23 <pippijn> I might have found it
07:31:25 <pippijn> oops
07:31:39 <pippijn> alright, found it
07:31:40 <pippijn> nice
07:32:36 <vixey> I don't really get why they use x though
07:32:39 <ski_> int80_h : ok
07:32:44 <vixey> but this is the basic idae
07:33:05 <ski_> int80_h : so, another approach is to generalize
07:33:11 <FunctorSalad> I'm wondering about the semantics of zeroArrow... are arrows supposed to be "strict" as in: any composition chain containing a zeroArrow is a zeroArrow?
07:33:11 <lambdabot> FunctorSalad: You have 1 new message. '/msg lambdabot @messages' to read it.
07:33:16 <ski_> vixey : the identifier `x' ?
07:33:37 <vixey> ski_, yeah instead of d, apparently it comes from (GENSYM) but that seems a bit odd
07:33:43 <ski_> FunctorSalad : that's a standard property of zero morphisms, yes
07:34:05 <ski_> FunctorSalad : well, that is `foo . zero = zero' and `zero . bar = zero'
07:34:18 <ski_> FunctorSalad : `foo *** zero' need not be `zero'
07:34:20 <FunctorSalad> hmm zero morphisms? as in abelian categories?
07:34:21 <vixey> ski_, the insight you trigged for me was that.. before I was doing recursion over the syntax of the term _and_ the type, simultaneously
07:34:33 <ski_> FunctorSalad : as in Ab-categories, yes
07:34:52 <SamB_XP> vixey: is there a problem with that ?
07:34:58 <FunctorSalad> agreed, foo *** zero needn't be zero...
07:35:07 <vixey> ski_, but it's possible only by inspecting the type, because instead of expanding something, you can just apply it to an expanded term and get the same result module beta-reduction
07:35:24 <vixey> SamB_XP, no I think both ways work but this second one is much simpler
07:35:25 <vixey> a
07:35:31 <ski_> vixey : you're just introducing a fresh local identifier .. it is just an aftefact of the low-level implementation that you need to express it as a `gensym'-sideeffect, imo
07:35:44 <ski_> (s/aftefact/artefact/)
07:35:48 <SamB_XP> I guess I would be able to make more intelligent comments if I knew what you were up to
07:35:59 <int80_h> @src init
07:35:59 <lambdabot> init [x]    = []
07:35:59 <lambdabot> init (x:xs) = x : init xs
07:35:59 <lambdabot> init []     = undefined
07:36:10 <vixey> SamB_XP: did you see Shortest Beta Normalizer? on fplunch?
07:36:55 <ski_> int80_h : if you've got `isPalindrome [0,1,0,2,0,1,0]' we've already seen you can't reduce that problem to `isPalindrome [1,0,2,0,1,0]', since that latter won't be a palindrome
07:37:00 <FunctorSalad> ski_: the context is arrows and error handling... I'm not sure what the interaction of fan-out and errors should be :)
07:37:14 <SamB_XP> vixey: no I didn't
07:37:19 <stevan> fldr: hmm, i asked two other users on the system (the same ghc installation) to use my emacs config (and therefore also the exact same files of haskell-mode)... and it works for both of them! i can't figure out what could possibly differ their setup from mine...
07:37:23 <vixey> SamB_XP, it's like this:  http://sneezy.cs.nott.ac.uk/fplunch/weblog/?m=200804
07:37:30 <ski_> int80_h : the problem is generalizing `isPalindrome' to something, such that the tail of the list also has this generalized property
07:37:32 <FunctorSalad> similarly, hxt's ArrowState runs f first, then g, in f &&& g...
07:37:38 <int80_h> ski_: I'm working out how to generalize init
07:37:44 <SamB_XP> vixey: I was just going to look it up in Google Reader
07:37:47 <vixey> SamB_XP, but if you instead... you can use recursion on the type of the expression, and perform eta expansions
07:37:51 <ski_> int80_h : ok, that might work too
07:37:58 <FunctorSalad> (which is kinda unintuitive since you expect f &&& g to be parallel)
07:38:07 <vixey> SamB_XP, so you get beta-eta normal forms and so alpha-beta-eta equality for lambda terms
07:38:33 <int80_h> ski_ : well, what you said is more accurate. But the point is, I know what the problem is and I'm trying to work out how to fix it
07:38:37 <ski_> vixey : ty
07:38:42 <SamB_XP> why has google reader decided I've read all kinds of stuff I haven't actually read ...
07:38:45 <int80_h> so, thanks for your help :)
07:38:50 <vixey> ski_, for ?
07:38:52 <ski_> int80_h : i see, np
07:38:57 <ski_> vixey : the link :)
07:39:14 <vixey> ski_, oh that doesn't do eta expansiosns though
07:39:24 <vixey> that one is just beta reduction
07:39:26 <SamB_XP> hmm, that entry in the feed has broken images anyway
07:39:33 <ski_> (i was just going to ask about "fplunch")
07:39:44 <int-e> SamB_XP: maybe it's clairvoyant
07:40:07 <SamB_XP> I think it's just lazy
07:40:19 <FunctorSalad> so this is a bit weird... if you collect errors in the state, then "(f *** throwingArrow) >>> arr fst" will have the error state
07:40:26 <ski_> (int80_h : if you get stuck, i have another (?) approach that might work, that i used in Logic Programming)
07:40:37 <FunctorSalad> but with (f *** zeroArrow) >>> arr fst, the error will be lost
07:40:53 <int80_h> ski_ : thanks :)
07:41:01 <vixey> but I wonder if mixing in the quotation/reification with it forces it to be call by value?
07:41:12 <vixey> ideally.. call by name would be better...
07:41:38 <ski_> FunctorSalad : "fan-out" ?
07:41:48 <FunctorSalad> ski_: (&&&)
07:42:21 <gnuvince_> :t (&&&)
07:42:22 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:42:28 <FunctorSalad> (actually the (&&&) isn't the issue per se, but the things I wrote later :))
07:43:06 <dfan> I'm having trouble with Haskell's numeric tower
07:43:06 <pippijn> can anyone point me at an example of passing an array of strings to C?
07:43:17 <ski_> hm, iirc, Hughes didn't specify `(foo &&& bar) >>> arr fst = foo'
07:43:19 <dfan> I probably need to add some explicit coercion somewhere but I can't figure out where and how
07:43:23 <dfan> Here is my function:
07:43:28 <dfan> pyth x y = z == floor z where z = sqrt (x*x + y*y)
07:43:39 <vixey> dfan, where is the type error?
07:43:39 <ski_> (so not quite categorical product .. possibly a weak one, iirc)
07:43:48 <int80_h> > init [1,2,3,4,5]
07:43:49 <lambdabot>   [1,2,3,4]
07:43:52 <dfan> and then when I type 'pyth 3 4'
07:43:55 <ski_> @type floor
07:43:57 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
07:43:57 <int80_h> @src init
07:43:57 <lambdabot> init [x]    = []
07:43:57 <lambdabot> init (x:xs) = x : init xs
07:43:57 <lambdabot> init []     = undefined
07:44:02 <dfan> I get
07:44:03 <dfan> Ambiguous type variable `t' in the constraints:
07:44:07 <mattam> vixey: why is would it be call-by-value?
07:44:08 <dfan> `RealFrac t' arising from a use of `pyth' at <interactive>:1:0-7
07:44:15 <dfan> `Integral t' arising from a use of `pyth' at <interactive>:1:0-7
07:44:19 <dfan> `Floating t' arising from a use of `pyth' at <interactive>:1:0-7
07:44:19 <mattam> s/is //
07:44:22 <dfan> Probable fix: add a type signature that fixes these type variable(s)
07:44:34 <int80_h> > init []
07:44:36 <lambdabot>   * Exception: Prelude.init: empty list
07:44:53 <FunctorSalad> ski_: right, and not "arr swap >>> (f *** g) >>> arr swap = (g *** f)" either, where swap (a,b) = (b,a)
07:45:04 <ski_> *nod*
07:45:07 <FunctorSalad> unexpected asymmetry imho :)
07:45:08 <Deewiant> dfan: you're using (==) to compare an integer, floor z, to a floating-point value, z
07:45:12 <Deewiant> ?ty (==)
07:45:14 <lambdabot> forall a. (Eq a) => a -> a -> Bool
07:45:15 <ski_> FunctorSalad : ugly, yes
07:45:19 <Deewiant> dfan: as you can see, it's a -> a
07:45:50 <ski_> FunctorSalad : of course `arr f' would always be central
07:45:55 <Deewiant> dfan: meaning that, in a == b, a and b have to have the same type
07:46:01 <Deewiant> dfan: and in your case, they don't.
07:46:05 <dfan> OK, so my next try is
07:46:06 <dfan> pyth x y = (z == ((floor z) :: Float)) where z = sqrt (x*x + y*y)
07:46:07 <dfan>  
07:46:11 <vixey> mattam, well the normal HOAS kind of eval is lazy because haskell is.. but I haven't thought hard about NbE yet
07:46:13 <Deewiant> dfan: that still won't work.
07:46:13 <dfan> and I get
07:46:14 <dfan> No instance for (Integral Float)
07:46:17 <dfan> I know :)
07:46:29 <dfan> Oh, I have to cast it by hand?
07:46:31 <vixey> I only just understood it a few mins ago
07:46:33 <Deewiant> dfan: before it was "some integral type" == "some floating point type"
07:46:37 <mattam> vixey: NbE uses the head normalizer of Haskell I think.
07:46:38 <dfan> rather than just asserting that it's a Float?
07:46:40 <Deewiant> dfan: now it's "some integral type" == "Float"
07:46:44 <ski_> vixey : maybe delimited continuations would make it strict .. hm
07:46:50 <Deewiant> dfan: which is still problematic because Float isn't an Integral. :-)
07:46:51 <FunctorSalad> ski_: of course, there's no way to do better with ArrowState unless you have some way to "reconcile" two different states into one
07:47:08 <Deewiant> dfan: er, scratch that, I said it the wrong way around
07:47:34 <ski_> (FunctorSalad : and even that doesn't guarrantee commutativity)
07:47:35 <Deewiant> dfan: floor returns an Integral, and Float isn't an Integral, so you can't say floor z :: Float.
07:47:41 <FunctorSalad> yep
07:47:49 <Deewiant> ?ty fromIntegral
07:47:51 <lambdabot> forall a b. (Num b, Integral a) => a -> b
07:48:00 <Deewiant> dfan: you can, however, say fromIntegral (floor z) :: Float. ;-)
07:48:26 <dfan> Aha, this works
07:48:26 <dfan> pyth x y = (z == (fromIntegral $ floor z)) where z = sqrt (x*x + y*y)
07:48:37 <Deewiant> yep
07:48:41 <dfan> Super, thanks
07:48:51 <ski_> pyth x y = z == fromIntegral (floor z)  where  z = ...
07:48:51 <Deewiant> No problem.
07:49:02 <Deewiant> Oh noes, extra brackets!
07:49:16 <ski_> that's *less* brackets, actually
07:49:36 <dfan> I can never remember what Integral means in haskell
07:49:37 <Deewiant> Yeah, I was exclaiming what you were likely thinking
07:49:52 <Apocalisp> *fewer* brackets
07:49:57 <Apocalisp> sheesh
07:50:01 <ski_> Apocalisp : ty
07:51:06 <FunctorSalad> dfan: why not "round" there? (instead of "floor")
07:51:07 <ski_> FunctorSalad : so where do these throwing arrows come from ?
07:51:13 <ski_> (and who throws them ?)
07:51:47 <FunctorSalad> ski_: to be specific I was trying to write a ArrowError instance for IOStateArrow :)
07:51:58 <ski_> @src ArrowError
07:51:59 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
07:52:12 <ski_> @index ArrowError
07:52:13 <lambdabot> bzzt
07:52:15 <dfan> Why would I use round?
07:52:44 <FunctorSalad> ski_: IOStateArrow has several different ways of handling errors... it's a ArrowList, so there's zeroArrow, but it also keeps an error state, and I guess you could also throw and catch exceptions since it's an IOArrow
07:52:49 <ski_> > 1 == (1/3 * 1/3 + 1/3)  -- dfan
07:52:51 <lambdabot>   False
07:53:11 <FunctorSalad> here's ArrowError: http://hackage.haskell.org/packages/archive/arrows/0.4/doc/html/Control-Arrow-Operations.html#t%3AArrowError
07:53:14 <ski_> @google what every computer scientist should know about floating-point
07:53:21 <Deewiant> > 1 == round (1/3 * 1/3 + 1/3)
07:53:21 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
07:53:23 <lambdabot>   False
07:53:29 <ski_> @botsmack
07:53:29 <lambdabot> :)
07:53:29 <lunabot>  :)
07:53:58 <dfan> Hmm
07:54:14 <dfan> I guess I should not expect sqrt to be exact when it can be
07:54:51 <dfan> and round won't give me any false positives
07:55:10 <FunctorSalad> dfan: yes, that was my thought too (about the sqrt)
07:55:33 <ski_> What Every Computer Scientist Should Know About Floating-Point Arithmetic <http://www.physics.ohio-state.edu/~dws/grouplinks/floating_point_math.pdf>
07:55:38 <FunctorSalad> > map sqrt . map (\x -> x*x) [1..] -- let's test...
07:55:40 <lambdabot>   Couldn't match expected type `a -> [a1]'
07:55:47 <FunctorSalad> > map sqrt . map (\x -> x*x) $ [1..] -- let's test...
07:55:49 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17....
07:56:21 <FunctorSalad> > map (\x -> sqrt (x*x) == x) [1..]
07:56:23 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
07:56:34 <FunctorSalad> hmm :)
07:57:02 <Deewiant> > map (\x -> sqrt(x*x) == x) [fromIntegral (maxBound :: Int)..]
07:57:05 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
07:58:13 <Gracenotes> :t [fromIntegral (maxBound :: Int)..]
07:58:15 <lambdabot> forall b. (Enum b, Num b) => [b]
07:58:52 <Gracenotes> :t [(maxBound :: Int)..]
07:58:54 <lambdabot> [Int]
07:59:54 <yaxu> http://claudiusmaximus.goto10.org/cm/2009-01-07_dvd2473.html # dvd made with haskell
07:59:58 <Deewiant> > [maxBound :: Int..]
08:00:00 <lambdabot>   <no location info>: parse error on input `Int..'
08:00:03 <Deewiant> > [maxBound :: Int ..]
08:00:05 <lambdabot>   [9223372036854775807]
08:00:16 <Gracenotes> heh
08:00:32 <yaxu> http://lists.lurk.org/pipermail/haskell-art/2009-January/000230.html
08:00:36 <Gracenotes> after all, one could think of Int as an ADT
08:00:58 <pippijn> how can I declare a foreign C function taking a char*[]?
08:00:58 <polveroj> is there a way to evaluate type functions in ghci?
08:01:03 <pippijn> that is, an array of C strings
08:01:04 <vixey> ...type functions? o_o
08:01:13 <Deewiant> Well, it is: data Int = I# Something# ;-)
08:01:52 <Gracenotes> it's more convenient to think of it not-as-an-adt, though
08:02:03 <Gracenotes> as a primitive
08:02:15 <Gracenotes> (of course, Java actually does make ints primitive, so go figure)
08:02:27 * ski_ aahs at `tryInUnless'
08:02:32 <polveroj> vixey: er, maybe they're called associated types
08:02:33 <Deewiant> The only primitives are things that end in # ;-)
08:02:55 <Gracenotes> ja
08:03:01 <b4taylor> Gracenotes: Didn't they add boxing and unboxing when the generics stuff got shoved in?
08:03:22 <b4taylor> "Java's never looked more like C++! Sweet!"
08:03:51 <Deewiant> There was always boxing and unboxing, they made it automatic
08:04:04 <Gracenotes> b4taylor: Yeah. It's kind of messy, though -- the JLS specification of boxing is calling the Integer construction, and of unboxing is calling the intValue method
08:04:26 <Gracenotes> that's what the compiler does; it's not particularly magical :)
08:04:30 <vixey> polveroj, can you really write function swith it?
08:04:33 <Gracenotes> *constructor
08:06:17 <b4taylor> Gracenotes: I'd imagine they do some kind of analysis and transform to primatives if deemed safe. If not ... I've got something to add to my CS444 compiler this term.
08:06:35 <FunctorSalad_> re...
08:06:37 <FunctorSalad_> ski_: so I guess what I was trying to say is that if one does "raise = zeroArrow", then an error thrown in the first argument to tryInUnless could get lost
08:07:34 <polveroj> vixey: yep.  For instance, you can write a type family that lets you get e.g. (Curried (a, (b, ())) c) ~ (a -> b -> c)
08:07:48 <Gracenotes> b4taylor: yeah, I'm sure it the interpreter makes optimizations where allowed. Still, a naive implementation could do that
08:07:53 <ski_> (vixey : now i think i recall .. delimited continuations were to be used when handling sum types)
08:08:09 <dfan> Thanks to your help, Project Euler problem 39 has been vanquished
08:08:10 <Gracenotes> although I'm not sure how things would work with generics
08:08:17 <vixey> polveroj, could you write  (a -> b -> ... -> y -> z) ~ (y -> ... -> b -> a -> z)?
08:08:21 <vixey> I just mean, is it possible
08:08:22 <Gracenotes> I can't help shake the feeling that the implementation of generics is very messy under the hood
08:08:52 <ski_> FunctorSalad_ : can you clarify on why ?
08:08:53 <vixey> ski_, would it be sum like Either, or sum like intersection?
08:09:00 <ski_> the former
08:09:16 <ski_> (intersection is not a sum, in my book)
08:09:58 * ski_ instantiates `z' to `z0 -> z1'
08:10:39 <polveroj> vixey: probably. You can do recursion on type-level lists (instance Foo b c => Foo (a, b) c), and you should be able to use (->) instead of (,)
08:10:54 <ski_> (int80_h : any progress ?)
08:11:20 <vixey> polveroj, and you can write functions which destruct/construct  forall  quantifications with it?
08:12:25 <FunctorSalad_> ski_: like you said essentially :) "f = (g1 &&& errorThrower) >>> arr fst" will forget the error.... (this is only a problem if we require that the error handler /must/ be called if the first argument raises an error)
08:12:55 <polveroj> vixey: I think you're not allowed to have quantifiers in associated types
08:13:00 <FunctorSalad_> ski_: I mean, it will forget the error if raise = zeroArrow
08:13:09 <ski_> FunctorSalad_ : well, i did't say that ..
08:14:01 <vixey> polveroj: :(
08:14:40 <ski_> <ski_> hm, iirc, Hughes didn't specify `(foo &&& bar) >>> arr fst = foo'
08:15:02 <ski_> so `(g1 &&& errorThrower) >>> arr fst' need not forget the error, i think
08:15:19 <ski_> (assuming `errorThrower = zeroArrow')
08:15:33 <FunctorSalad_> ski_: I meant that you said that (g *** zeroArrow) needn't be zeroArrow
08:15:55 <ski_> but it might be
08:16:03 <ski_> (i think)
08:16:18 <FunctorSalad_> yes, it might be... I was thinking of ArrowZero instances like list arrows
08:16:50 <ski_>   data ListArrow a b = Mk (a -> [b])  -- ?
08:17:20 <ski_> then `g *** zeroArrow = zeroArrow', i think
08:17:28 <FunctorSalad_> ski_: yes. wait... with ListArrow the result is zero after all :)
08:18:24 <int80_h> ski_ I'm stuck
08:18:32 <ski_> on ?
08:18:51 <int80_h> ski_: I can't see how to remove the last element of xs
08:19:14 <FunctorSalad_> assuming (Mk f) *** (Mk g) = Mk (\pairs -> [(x, y) | (x0,y0) <- pairs, x <- f x0, y <- g y0])
08:19:21 <int80_h> I mean, given with what I'm allowed to use
08:19:28 <ski_> int80_h : maybe you could manage without removing it ?
08:19:29 <FunctorSalad_> dff
08:19:35 <FunctorSalad_> sorry hit enter :)
08:19:48 <dfan> How do I express (\n -> n - 1) as a partial function without Haskell thinking I mean the number negative one?
08:20:02 <FunctorSalad_> (wanted to correct the last line by saying that pairs isn't a list but a single pair actually)
08:20:22 <ski_> ic
08:20:23 <int80_h> ski_ then I'm faced with a non-palindrome, right?
08:20:35 <tromp__> dfan: pred
08:20:47 <ski_> int80_h : yes .. but maybe you could add some extra parameters to the recursion to make up for that
08:20:50 <ski_> ?
08:20:54 <FunctorSalad_> > (subtract 1) 7
08:20:56 <lambdabot>   6
08:21:13 <dfan> Perfect, thanks
08:21:27 <tromp__> > pred 7
08:21:29 <lambdabot>   6
08:21:40 <ski_> @pl flip subtract 1
08:21:40 <lambdabot> (-) 1
08:21:51 <ski_> @pl flip (-) 1
08:21:52 <lambdabot> subtract 1
08:22:36 <blathijs> Is there some way to see the actual value of an expression at runtime? Ie, which constructor was used to create it? I've tried using the Data.Generics module, but the data I'm working with doesn't seem to have the deriving Data set...
08:22:50 <blathijs> I've looked around in ghci as well, but I can't find anything there either
08:23:21 <FunctorSalad_> blathijs: about the latter problem, you could try a stand-alone deriving instance for Data
08:23:33 <FunctorSalad_> let me look up the syntax ;)
08:24:01 <ski_> int80_h : .. one way of solving your problem might be to consider `reverse [0,1,0,2,0,1,0]'
08:24:02 <FunctorSalad_> "deriving instance (Data Foo)"
08:25:57 <int80_h> ski_ I thought about reverse. Not allowed to use it
08:26:27 <int80_h> if I could compare foo with reverse foo, problem would be solved
08:26:37 <int80_h> oh wait, nevermind
08:26:41 <ski_> int80_h : you could still be inspired by `reverse' ..
08:26:53 <int80_h> ski_ okay I'll think it out
08:27:11 <ski_> (like, writing a fused version of `\xs -> xs == reverse xs' ..)
08:28:00 <blathijs> FunctorSalad_: After adding -XStandaloneDeriving -XFlexibleInstances  -XDeriveDataTypeable to the commandline (as suggested by the three error messages that I received after each other) it seems to work somewhat
08:28:06 <int80_h> I don't know that notation. I'm on chapter 3 of RWH
08:28:21 <blathijs> FunctorSalad_: Now let me try the same thing for all the data types that are used by this data type :-)
08:28:38 <blathijs> There's probably no way to do that recursively and automatically...
08:30:39 <ski_> @hoogle m a -> (a -> m b) -> (e -> m b) -> m b
08:30:40 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
08:30:40 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
08:30:40 <lambdabot> Data.Generics.Aliases extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
08:30:44 <ski_> bah
08:31:46 <int80_h> > drop (-1) [1,2,3,4,5,6]
08:31:48 <lambdabot>   [1,2,3,4,5,6]
08:32:14 <int80_h> that didn't do what I wanted
08:32:18 <int80_h> @drop
08:32:18 <lambdabot> Unknown command, try @list
08:32:22 <int80_h> @src drop
08:32:22 <lambdabot> drop n xs     | n <= 0 =  xs
08:32:22 <lambdabot> drop _ []              =  []
08:32:22 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
08:32:45 <idnar> > reverse . drop 1 . reverse [1..6]
08:32:46 <lambdabot>   Couldn't match expected type `a -> [a1]'
08:32:55 <idnar> > reverse . drop 1 . reverse $ [1..6]
08:32:56 <int80_h> can't use reverse
08:32:57 <lambdabot>   [1,2,3,4,5]
08:33:07 <blathijs> FunctorSalad_: Hmm, that didn't really work out. I'm seeing these errors: deriving instance (Data (Expr CoreBndr))
08:33:32 <blathijs> uh, these errors: http://pastebin.com/m6b1ad05 (when trying to derive Data for (Expr CoreBndr))
08:33:34 <idnar> > (\xs -> take (length xs - 1) xs) [1..6]
08:33:36 <lambdabot>   [1,2,3,4,5]
08:33:48 <blathijs> FunctorSalad_: I can't say I understand half of that, any suggestions?
08:34:01 <idnar> > inits [1..6] !! -1
08:34:03 <lambdabot>       precedence parsing error
08:34:03 <lambdabot>          cannot mix `(!!)' [infixl 9] and pref...
08:34:06 <int80_h> can't use lambda...ooh but I can use take and length
08:34:09 <idnar> > (inits [1..6]) !! -1
08:34:11 <lambdabot>       precedence parsing error
08:34:11 <lambdabot>          cannot mix `(!!)' [infixl 9] and pref...
08:34:16 <idnar> huh?
08:34:21 <idnar> oh
08:34:23 <int80_h> I'm working from a book
08:34:29 <idnar> !! can't do that anyway
08:34:37 <int80_h> if I could use whatever I wanted, the problem would be solved by now
08:34:56 <vixey> int80_h, what is the exact problem statement?
08:35:09 <FunctorSalad_> blathijs: Data is a subclass of Typeable, so you need to derive (Typeable Var) and (Typeable1 Expr) too. ('Typeable1' is the variant of Typeable for type constructors)
08:35:12 <vixey> can'tuse lambda isn't a big deal btw,
08:35:19 <vixey> just define s and k combinators :D
08:35:47 <ski_> vixey : and `c',`b' for sanity
08:35:51 <FunctorSalad_> blathijs: btw, why not use show for the original problem? (showing a value at runtime)
08:35:53 <int80_h> "Write a function that determines whether it's input list is a palindrome.
08:36:11 <int80_h> The implication is, with what's been given in the book so far.
08:36:24 <fasta> How do I define a GADT with a constructor Foo which has a field named foobar?
08:37:50 <blathijs> FunctorSalad_: I'm trying to show Expr (http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/CoreSyn.html#t%3AExpr) which is not showable
08:38:07 <int80_h> take (-2) [1,2,3,4]
08:38:23 <blathijs> FunctorSalad_: It is Outputable, but that does pretty printing (using the "ppr" function anyway) and hides the actual structure
08:38:48 <int80_h> > take (-2) [1,2,3,4]
08:38:50 <lambdabot>   []
08:39:03 <ski_> fasta : <http://use.perl.org/~autrijus/journal/26921?from=rss> might be relevant, though possibly there's more up-to-date documentation ..
08:40:18 <FunctorSalad_> blathijs: ah. hmm, I guess then it doesn't matter much whether you derive Show for all the involved types, or derive Data and then use gshow
08:40:34 <athos> hi all
08:40:59 <blathijs> FunctorSalad_: Nope, but I'm afraid there's a very big bunch of types involved...
08:41:05 <vixey> int80_h, no idea what book or where you are in thugh
08:41:16 <int80_h> no worries.
08:41:31 <int80_h> I just looked online at some user comments for RWH
08:41:45 <int80_h> everyone is using functions that haven't been introduced yet in their solutions
08:41:57 <int80_h> init and reverse
08:42:00 <vixey> I don't like this "don't use what you haven't been told to use" stuff
08:42:03 <FunctorSalad_> blathijs: apparently gshow throws an exception if you try to show a function type (and Show simply isn't derivable for function types)
08:42:05 <int80_h> so I don't feel so bad for not being able to do this
08:42:21 <int80_h> vixey: the goal is to work form first principles
08:42:39 <int80_h> it's an extra challenge
08:42:49 <vixey> just sounds tedious to me
08:42:50 <FunctorSalad_> blathijs: (just saying in case there are function types involved too)
08:43:01 <blathijs> FunctorSalad_: But I don't think I need to show function types, so that shouldn't matter
08:43:24 <int80_h> vixey: there's a payoff
08:43:48 <blathijs> FunctorSalad_: I've looked around Outputable a bit, but can't seem to find anything there either (showSDoc . ppr makes a pretty string, but hides the structure)
08:45:33 <fasta> ski_: http://www.haskell.org/ghc/docs/6.10.1/html/users_guide/data-type-extensions.html#gadt
08:45:41 <fasta> ski_: it is implemented.
08:45:53 <ski_> (fasta : i seemed to recall so ..)
08:47:42 <int80_h> > take 5 [1,2,3,4,5,6]
08:47:43 <lambdabot>   [1,2,3,4,5]
08:47:47 <int80_h> got it!
08:47:56 <int80_h> take is it
08:48:00 <int80_h> hee hee
08:48:04 <fasta> ski_: it's not optimized for terseness, though.
08:48:11 <int80_h> ski_ thanks for your help
08:48:22 <pippijn> how do I get the length of an IO [a]?
08:48:29 <fasta> ski_: one needs to specify the return type completely, even though it is obvious what it will be.
08:48:49 <vixey> :t >>= length
08:48:50 <lambdabot> parse error on input `>>='
08:48:53 <vixey> :t (>>= length)
08:48:54 <lambdabot>     Couldn't match expected type `m b' against inferred type `Int'
08:48:54 <lambdabot>       Expected type: [a] -> m b
08:48:54 <lambdabot>       Inferred type: [a] -> Int
08:48:57 <gnomnain> return.length
08:48:58 <ski_> int80_h : ok, i assume you went for a numeric-solution
08:48:58 <vixey> :t (>>= return . length)
08:48:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => m [a] -> m Int
08:49:13 <ski_> int80_h : i think one can make nice non-numeric ones, too
08:49:31 <blathijs> FunctorSalad_: Hmm, new error message:     The data constructors of `Module' are not all in scope so you cannot derive an instance for it
08:49:37 <ski_> @type liftM length
08:49:38 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> m Int
08:49:43 <int80_h> ski_ : I'll work this one out, then let's talk about the non-numeric solutions
08:49:52 <ski_> int80_h : sure
08:50:08 <FunctorSalad_> blathijs: hmm I haven't seen that one :(
08:50:31 <FunctorSalad_> blathijs: did you import the package containing the datatype in question?
08:51:00 <blathijs> I'm not completely sure which datatype that is :-)
08:51:27 <blathijs> I've also got one for Type
08:52:03 <blathijs> Both of which are so generic, I'm not sure where they come from
08:52:56 <FunctorSalad_> blathijs: try searching for it on hoogle or hayoo
08:54:17 <dfan> Is there an idiomatic way to search for an element in an ordered list or was I right to just write it by hand:
08:54:19 <dfan> elemSorted n list = head (dropWhile (<n) list) == n
08:54:30 <Martijn> If Parser s a is a parser with input :: [s] and result a, and I have a function f :: (t -> s) -> Parser s a -> Parser t a, then what is a good name for f?
08:54:44 <dfan> (I guess I should check for empty lists too)
08:54:44 <blathijs> FunctorSalad_: I've tried the index on ghc's docs, but all the ones listed there don't work
08:54:51 <Martijn> It's sort of a mapInput, but not quite.
08:54:52 <vixey> dfan, try it with foldr
08:54:58 <blathijs> FunctorSalad_: But I'm outta time, I'll continue next week
08:55:04 <blathijs> FunctorSalad_: Thanks for the help so far!
08:55:10 <vixey> dfan: just start with:  foldr (\x ys -> _) False
08:55:28 <vixey> dfan: (well,  elemSorted n = foldr (\x ys -> _) False)
08:56:17 <dfan> I'll chew on that for a minute
08:57:21 <fasta> Cale: what's the license on MonadRandom?
08:57:56 <dfan> though I thought foldr works from the end of the list towards the beginning
08:58:25 <fasta> Cale: never mind
08:58:40 <Stephan202> Martijn: what does f do? Unless I'm mistaken, the first argument cannot be applied to the second. So what should the result be?
08:58:53 <vixey> dfan, I think of foldr as a completely simultaneous change
08:59:13 <vixey> dfan, it just rips out all the constructors and replaces them with functions in one go
08:59:31 <dfan> So my foldr implementation will work for searching infinite lists too?  Hmm
08:59:36 <vixey> yes
08:59:37 <Stephan202> If you mean "f :: (t -> s) -> Parser t a -> Parser s a" (last s and t switched), then I'd say mapInput is an appropriate name
09:00:17 <ozy`> dfan: foldr is good for working with lazy lists. foldl' is good for reducing a list to a single value.
09:00:22 <ozy`> that's my rule of thumb, anyway.
09:00:39 <Martijn> Stephan202: It's not possible to write that function: I didn't mistakenly switch t and s.
09:01:19 <vixey> for me foldl with a list like  [a, b, c, ...] is what to use if you have some piece of state, and want to run it through each element,  like  s --(a)--> s' --(b)--> s'' --...
09:01:21 <gour> anyone uses Takusen and know if it supports blobs? according to the description on hackage it looks it does not...
09:01:44 <Stephan202> Martijn: yes, you're right. I was not thinking hard enough
09:02:21 <Martijn> Stephan202: But it's still sort of a mapInput, so I'll just stick to that, I guess. The name comapInput comes to mind, but I don't know if that means what I think it means. :-P
09:02:41 <Stephan202> Neither do I, sorry :)
09:03:06 <Martijn> Stephan202: Thanks anyway :-)
09:03:20 <vixey> in bidirectional typechecking of  inferring a b : tau,  why infer a : sigma -> tau then check b : sigma, .. instead of the other way around?
09:04:34 <vixey> I realized the answer just after asking it
09:04:34 <dfan> OK, well, I have a elemNonSorted using foldr :)
09:04:42 <vixey> dfan, hey that was quick
09:05:01 <dfan> elemNonSorted n = foldr (\x y -> y || (x == n)) False
09:05:17 <vixey> hmmm
09:05:25 <vixey> @let elemNonSorted n = foldr (\x y -> y || (x == n)) False
09:05:28 <lambdabot>  Defined.
09:05:35 <vixey> > elemNonSorted 32 [1..]
09:05:38 <lambdabot>   * Exception: stack overflow
09:05:45 <vixey> @undef
09:05:47 <dfan> Now to try to figure out how to take advantage of the sortedness of the list
09:05:50 <vixey> @let elemNonSorted n = foldr (\x y -> (x == n) || y) False
09:05:52 <lambdabot>  Defined.
09:05:54 <vixey> > elemNonSorted 32 [1..]
09:05:55 <lambdabot>   True
09:05:57 <int80_h> > let xs = [1,2,3,4,5]
09:05:58 <lambdabot>   <no location info>: parse error on input `;'
09:06:00 <dfan> Oho
09:06:04 <vixey> > elemNonSorted 33 [2,4..]
09:06:09 <int80_h> what?!
09:06:11 <vixey> ^ this is next bug to fix :p
09:06:20 <lambdabot>   thread killed
09:06:24 <int80_h> > let x:xs = [1,2,3,4,5]
09:06:25 <lambdabot>   <no location info>: parse error on input `;'
09:06:37 <vixey> dfan, but yeah, once you're seeing things bigger than 'n' it's time to give up
09:06:40 <chessguy_work>  > let x:xs = [1,2,3,4,5] in x
09:06:44 <chessguy_work> > let x:xs = [1,2,3,4,5] in x
09:06:45 <dfan> Right, that's why this name is elemNonSorted :)
09:06:47 <lambdabot>   1
09:06:50 <dfan> I'm not taking advantage of the sortedness yet
09:06:58 <int80_h> > let x:xs = [1,2,3,4,5] in x
09:07:00 <lambdabot>   1
09:07:16 <int80_h> length xs
09:07:21 <int80_h> > length xs
09:07:22 <lambdabot>   Not in scope: `xs'
09:07:46 <ski_> (vixey : .. the answer being ?)
09:07:53 <vixey> answer to what?
09:08:01 <vixey> elemNonSorted 33 ? it should say False
09:08:12 <vixey> and Non shouldn't be there
09:08:34 <dfan> elemSorted n = foldr (\x y -> (x == n) || (x <= n && y)) False
09:08:46 <vixey> @let elemSorted n = foldr (\x y -> (x == n) || (x <= n && y)) False
09:08:47 <lambdabot>  Defined.
09:08:52 <vixey> > elemSorted 33 [2,4..]
09:08:54 <lambdabot>   False
09:08:55 <vixey> > elemSorted 34 [2,4..]
09:08:57 <lambdabot>   True
09:08:58 <vixey> !!!
09:09:14 <dfan> My non-foldr definition was shorter, though :)
09:09:21 <vixey> what's that?
09:09:28 <dfan> elemSorted n list = head (dropWhile (<n) list) == n
09:09:42 <vixey> @let elemSorted' n list = head (dropWhile (<n) list) == n
09:09:42 <lambdabot>   Parse error
09:10:05 <vixey> > elemSorted 34 []
09:10:06 <dfan> though it doesn't work on empty lists
09:10:07 <lambdabot>   False
09:10:13 <EvilTerran> dfan, that's easily enough fixed
09:10:15 <dfan> Right
09:10:40 <vixey> :t (\x y -> (x == ?n) || (x <= ?n && y))
09:10:41 <lambdabot> forall a. (Ord a, ?n::a) => a -> Bool -> Bool
09:10:46 <vixey> :t (\x y -> x == ?n || x <= ?n && y)
09:10:48 <lambdabot> forall a. (Ord a, ?n::a) => a -> Bool -> Bool
09:11:31 <EvilTerran> elemSorted' n = any (==n) . take 1 . dropWhile (<n)
09:11:35 <EvilTerran> :D
09:11:56 <int80_h> sky_ : okay my solution doesn't work on strings
09:11:57 <dfan> Ah, take 1 is safe
09:12:14 <ski_> vixey : sorry .. answer to your question wrt `bidirectional typechecking' (which i'm not quite sure what it is)
09:12:36 <EvilTerran> dfan, indeed, take and drop stop short instead of failing when the list is "too short"
09:12:38 <vixey> ski_, oh right, it's about mode correctness
09:12:41 <EvilTerran> > drop 1 []
09:12:43 <lambdabot>   []
09:12:45 <EvilTerran> > tail [] -- cf
09:12:47 <lambdabot>   * Exception: Prelude.tail: empty list
09:13:05 <vixey> ski_, for m n : tau, if you infer n : sigma, then you can't check  m : tau -> ?  because ti's not a complete term yet
09:13:17 <vixey> (oh we are inferring tau atm, so that's not known yet)
09:13:52 <vixey> ski_, bidirectional typechecking is just splitting it into two modes,  gamma |- term : type  where you check type is right, or you infer type
09:14:04 <vixey> ski_, it seems to fit really well with NbE for some reason
09:14:29 <ski_> vixey : so no partially instantiated types ?
09:14:35 <vixey> no
09:14:55 <vixey> the applications are for languages with really undecideable inference
09:15:37 <vixey> so you can have a rule  (ann)  gamma |-> type : annotation ==> gamma |-? (type : annotation) : infType
09:15:52 <int80_h> sky_ : I'll post it on hpaste
09:15:55 <vixey> (using |-> to mean infer type, and |-? to mean check)
09:16:08 <ski_> (`.. |-> .. : ..' being "algorithmic typing relation" ?)
09:16:19 <int80_h> heh, I mean't ski_
09:17:09 <ski_> s k y _ = k _ (y _) = _ = k _ (i _) = s k i _
09:17:20 <int80_h> ski_ : my solution doesn't work on strings.
09:19:06 <ozy`> ski_: I see what you did there.
09:19:12 <lilac> int80_h: you also meant meant ;-)
09:19:13 <int80_h> ski_: http://hpaste.org/13758#a1
09:19:27 <int80_h> lilac, yeah I got that too. I was hoping noone noticed ;)
09:19:45 <lilac> int80_h: your solution doesn't work on odd-length lists
09:19:57 <lilac> int80_h: because it doesn't work on length-1 lists
09:19:59 <ski_> (ozy` : where ?)
09:20:06 <lilac> int80_h: because you say length 1 lists aren't palindromes
09:20:22 <int80_h> bah...okay I goofed
09:21:39 <EvilTerran> int80_h, i note you're working with the far end of the string quite frequently there
09:21:49 <lilac> int80_h: there's a better solution. give a definition of 'palindrome'
09:22:03 <lilac> (that is, what does the word palindrome mean?)
09:23:15 <ski_> lilac : specification is `forall xs. palindrome xs = (xs == reverse xs)'
09:23:34 <EvilTerran> ski_, erm, "specification"? looks like "implementation" to me :P
09:23:57 <mattam> executable specification :)
09:24:02 <lilac> ski_: that's somewhat jumping straight to the answer i was hoping to derive
09:24:08 <ski_> EvilTerran : it just so happens that it is also an implementation (eliding the `forall xs. ') ;)
09:24:21 <ski_> lilac : sorry, realized that after the fact
09:24:55 <lilac> #haskell: where we'll only do your homework for you by accident :-)
09:25:27 <int80_h> okay I fixed it
09:25:44 <int80_h> ski_: let's talk about non-numeric solutions
09:26:57 <ski_> (EvilTerran : though that implementation isn't admissible for int80_h)
09:27:29 <EvilTerran> oh?
09:27:37 <int80_h> I'm working from RWH
09:28:05 <int80_h> if I could use whatever I wanted, it would have been done some time ago
09:28:17 <EvilTerran> i see
09:28:21 <PeakerWork> int80_h: what can you use?
09:28:49 <int80_h> PeakerWork: it's all done. But ski_ wanted to talk about non-numeric solutions
09:29:31 <int80_h> PeakerWork: the recursive case is "| x == last (xs)     = isPalindrome (take ((length xs) - 1) xs)"
09:30:08 <igowen> write your own reverse function if that makes you feel better
09:30:15 <igowen> I'm pretty sure that's an exercise at some point
09:30:25 <EvilTerran> an O(n) one
09:31:03 <lilac> > foldl' (flip (:)) [] "Hello"
09:31:05 <lambdabot>   "olleH"
09:31:07 <int80_h> igowen : yeah I have my reverse function, but the exercise implies this can be done with just one function
09:31:24 <int80_h> ski_ you there?
09:31:35 <vixey> >foldr (\x ys -> x + 10 * ys) [1,2,3,6,2]
09:31:37 <vixey> > foldr (\x ys -> x + 10 * ys) [1,2,3,6,2]
09:31:38 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
09:31:38 <lambdabot>        arising from a use...
09:31:40 <ski_> int80_h : not yet
09:31:41 <vixey> > foldr (\x ys -> x + 10 * ys) 0 [1,2,3,6,2]
09:31:43 <lambdabot>   26321
09:31:50 <vixey> > foldl (\ys x -> x + 10 * ys) 0 [1,2,3,6,2]
09:31:52 <lambdabot>   12362
09:32:16 <vixey> @let plinkdome = liftA2 (foldr (\x ys -> x + 10 * ys) 0) (foldl (\ys x -> x + 10 * ys) 0)
09:32:18 <lambdabot>  Defined.
09:32:41 <EvilTerran> "plinkdome"?
09:32:58 <vixey> > map plinkdome [ [1,2,3,2,1], [3,1,4,1,5,9], [9] ]
09:33:00 <lambdabot>   Couldn't match expected type `[[b -> c]] -> b'
09:33:08 <ddarius> :t plinkdome
09:33:08 <vixey> akch..... doesn't work I guess
09:33:10 <lambdabot> forall b c. (Num (b -> c), Num [b -> c]) => ([[b -> c]] -> b) -> [[b -> c]] -> c
09:33:14 <ddarius> Looks broken to me.
09:33:16 <int80_h> @src sortBy
09:33:16 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
09:33:17 <lilac> int80_h: have you done the 'turn a list into a palindrome' exercies? if so, how did you do it?
09:33:29 <igowen> int80_h: I think your test case is flawed
09:33:30 <EvilTerran> vixey, should that "liftA2" be "liftA2 (,)"?
09:33:38 <int80_h> lilac: yeah I did that. Let me look
09:33:41 <vixey> @undef
09:33:44 <vixey> @let plinkdome = liftA2 (==) (foldr (\x ys -> x + 10 * ys) 0) (foldl (\ys x -> x + 10 * ys) 0)
09:33:46 <lambdabot>  Defined.
09:33:47 <vixey> > map plinkdome [ [1,2,3,2,1], [3,1,4,1,5,9], [9] ]
09:33:48 <lambdabot>   [True,False,True]
09:33:49 <igowen> try your function on the string "abba", not "aba"
09:33:50 <int80_h> igowen: how so?
09:33:58 <int80_h> igowen: okay
09:33:59 <igowen> I think it's broken on odd-length palindromes
09:34:01 <igowen> not strings
09:34:21 <int80_h> woah, it's broken alright
09:34:23 <igowen> and "write a function" does not imply that you only need one function
09:34:44 <lilac> int80_h: isPalindrome x = makePalindrome x == (x ++ x)
09:35:13 <igowen> s/need/should only write/
09:35:20 <lilac> there, i didn't use reverse ;-)
09:35:36 <igowen> cute
09:36:14 <ddarius> isPalindrome = ap(flip(==))reverse; makePalindrom = ap(flip(++))reverse
09:36:34 <int80_h> makePalindrom: not in scope
09:36:49 <igowen> there are probably 5 million different ways of writing this, but 99% of those are going to confuse someone at his level
09:37:00 <lilac> int80_h: makePalindrome is the function you wrote for exercise 4
09:37:16 <int80_h> lilac: yes, I know.
09:37:36 * ddarius was just pointing out the very close similarity of isPalindrome and makePalindrome.
09:37:47 * int80_h was making a joke about a typo
09:39:06 <dons> ?yow
09:39:06 <lambdabot> Hello, GORRY-O!!  I'm a GENIUS from HARVARD!!
09:39:11 <dons> ?users
09:39:12 <lambdabot> Maximum users seen in #haskell: 668, currently: 629 (94.2%), active: 20 (3.2%)
09:39:30 <int80_h> igowen: okay I fixed my isPalindrome function
09:42:16 <int80_h> @src sortBy
09:42:16 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
09:42:34 <int80_h> @insertBy
09:42:34 <lambdabot> Unknown command, try @list
09:42:40 <int80_h> @src inseryBy
09:42:40 <lambdabot> Source not found. Wrong!  You cheating scum!
09:42:43 <int80_h> @src insertBy
09:42:43 <lambdabot> insertBy _   x [] = [x]
09:42:44 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
09:42:44 <lambdabot>                                  GT -> y : insertBy cmp x ys'
09:42:44 <lambdabot>                                  _  -> x : ys
09:44:23 <vixey> I'm confusd..
09:44:38 <vixey> with the NbE, you evaluate the term.. then reflect it, then reify it.. then quote?
09:45:38 <EvilTerran> NbE?
09:45:44 <ski_> doesn't the reification involve quoting ?
09:45:55 <ski_> Normalization-by-Evaluation
09:46:12 <vixey> I'm so confused
09:46:25 <ski_> then stop it
09:46:30 <ski_> (joking)
09:47:01 <vixey> I don't know if I'm supposed to do type inference during NbE or not.. I really hope not though
09:47:49 <ski_> i think you're supposed to already have a type for the term
09:47:58 <vixey> yeah
09:48:07 <vixey> it's just I have this one case left which I can't do:
09:48:14 <vixey> reflect i O (App m n) = ...
09:48:29 <ski_> is `m' and `n' types ?
09:48:39 <vixey> O is the unit type, m and n are values
09:48:59 <ski_> why are you inducting on the term ?
09:49:47 <vixey> well I had separated out Terms vs Values
09:50:02 <vixey> so I have e.g.:  reflect i O Unit = UNIT
09:50:21 <vixey> maybe it should be,  reflect i O = FUN (\x -> x) ?
09:50:36 <ski_>   reflect :: ? -> Type -> Term -> Value  -- ?
09:50:46 <vixey> reflect :: Ref -> Type -> Term -> Val
09:50:47 <vixey> reify :: Ref -> Type -> Val -> Term
09:50:55 <vixey> Ref = Integer, just needed for quotation
09:51:00 <vixey> (basically gensym)
09:51:01 <Valodim> ok I totally need to remove the nickalert for the string "val"
09:53:09 <ski_> maybe i'm misrecalling something, but possible it should be `reflect _ O _ = UNIT' ?
09:54:05 <vixey> well if I had extensionality for O, but in general I wouldn't for example if I had use Bool or Nat instead
09:54:34 <ski_> well `Bool' is harder than a unit type
09:54:41 <vixey> :(
09:54:46 <ski_> (istr)
09:54:47 <vixey> I wanted to support a full programming languages
09:55:13 <ski_> have you read "Type-directed partial evaluation" yet ?
09:55:45 <int80_h> ski_ : so can we talk about non-numeric solutions for isPalindrome?
09:55:55 <ski_> int80_h : yes
09:56:03 <ski_> do you have any ideas to begin with ?
09:56:26 <int80_h> ski_ : just a quesion, what do you mean by non-numeric solution?
09:56:44 <ski_> int80_h : not using `length' or `take' or `drop'
09:56:51 <ski_> (or similar stuff)
09:56:59 <int80_h> ooh! that's intersting
09:57:07 <int80_h> okay let me think on it
09:58:18 * ski_ wonders whether there's a printout of that paper in any of the old heaps around here ..
09:58:34 <vixey> ,I've got the paper
09:58:43 <lunabot>  luna: Not in scope: data constructor `I've'
09:58:45 <vixey> and a lot of notes about NbE
09:59:51 <int80_h> ski_ : well the only idea I've got so far is init, and that's off limits
10:00:04 <int80_h> ski_ : so I guess I could replicate init
10:00:12 <Deewiant> ?ty replicate init
10:00:15 <lambdabot>     Couldn't match expected type `Int'
10:00:15 <lambdabot>            against inferred type `[a] -> [a]'
10:00:15 <lambdabot>     In the first argument of `replicate', namely `init'
10:00:37 <int80_h> @src replicate
10:00:37 <lambdabot> replicate n x = take n (repeat x)
10:00:50 <int80_h> @src init
10:00:50 <lambdabot> init [x]    = []
10:00:50 <lambdabot> init (x:xs) = x : init xs
10:00:50 <lambdabot> init []     = undefined
10:01:30 * ski_ wonders why he's to lazy to fire up a viewer, but not too lazy to rummage in old heaps
10:01:37 <ski_> (s/to/too/)
10:03:07 <int80_h> ski_ is that thr right track?
10:03:23 <redditbot> Haskell database interfaces
10:03:33 <ski_> int80_h : it might be .. but i'm not sure
10:03:34 <vixey> redditbot...
10:03:56 <int80_h> okay
10:04:02 <ski_> int80_h : i'm thinking on how `xs == reverse xs' would execute
10:04:18 <ski_> int80_h : possibly there is a way to simulate that .. explicitly
10:05:02 <ski_> i.e., in `[0,1,2,3]' suppose we could compare `0' with `3',`1' with `2', `2' with `1' and `3' with `0'
10:05:23 <ski_> of course, we can't get a hold of `3' before we've reached the end of the list
10:05:40 <ski_> but maybe we could traverse to the end of the list, and then, on the way back, compare the elements
10:05:49 <ski_> (that's an idea)
10:06:18 <ddarius> Optimizing slightly, you recurse down the list, effectively pop/pushing (leading to a reversal) then, as you come back up, you compare with the original list character by character.
10:07:39 <FunctorSalad_> is the Control.Exception doc lying? :) it warns that catch catches all types of exceptions, so you have to re-throw any unhandled ones http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#v%3Acatch
10:07:42 <ddarius> (This reflects a heap allocated list onto the stack thus taking stack instead of heap.)
10:08:04 <FunctorSalad_> but it seems that only Exceptions of the type actually caught by the passed handler are caught
10:08:15 <FunctorSalad_> @type Control.Exception.catch
10:08:16 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
10:08:53 <FunctorSalad_> bot is out of date, the current sig is: catch :: Exception e => IO a -> (e -> IO a) -> IO a
10:09:37 <vegai> Oh, John Goerzen has to deal with Progress 4GL as well
10:09:39 <ski_> (FunctorSalad_ : possibly the doc is out-of-date, too ..)
10:09:41 <FunctorSalad_> if I define an f of type ErrorCall -> IO Something, then only ErrorCalls are caught
10:10:02 <FunctorSalad_> (as it should be)
10:10:11 <FunctorSalad_> ski_: yes
10:11:16 <jad4> question on monads
10:11:19 <pk> @src num
10:11:20 <lambdabot> Source not found. There are some things that I just don't know.
10:11:29 <pk> @src Num
10:11:29 <lambdabot> class  (Eq a, Show a) => Num a  where
10:11:29 <lambdabot>     (+), (-), (*)           :: a -> a -> a
10:11:29 <lambdabot>     negate, abs, signum     :: a -> a
10:11:29 <lambdabot>     fromInteger             :: Integer -> a
10:12:00 <jad4> intuitively is seems like     u o n_TA = id_ TA   (u = mu , n = eta , T = monad)
10:12:17 <jad4> but is it so? how can you tell that from the monad definition
10:12:41 <jad4> the only property for u as to do with associativity...
10:12:47 <ddarius> jad4: It is one of the monad laws.
10:12:52 <ski_> jad4 : that's one of the monad laws (in one formulation)
10:13:12 <rwbarton> jad4: Specifically, one of the unit laws
10:13:16 <ski_> jad4 : are you asking how to prove that, in terms of the laws for `(=<<)' ?
10:13:40 <Botje> :t (>=>)
10:13:41 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
10:13:43 <jad4> my head now is thinking on the classical definition for monads
10:13:58 <jad4> in the mathematica sense
10:14:03 <ski_> jad4 : which is ?
10:14:05 <jad4> as it shows on Moggis work
10:14:20 <jad4> two diagrams, one says
10:14:46 <jad4> u_TA  o  u_A = T u_A  o  u_A
10:14:55 <jad4> oh damn
10:14:57 <jad4> never mind
10:15:01 <jad4> found it
10:15:08 <ski_> found what ?
10:15:12 <jad4> yeah and the other has the law I wanted
10:15:32 <jad4> the other says n_TA o u_A = id_TA
10:16:05 <jad4> actually
10:16:12 <ddarius> It should say that as well as u_TA o n_A = id_TA
10:16:15 <jad4> the other says u_A  o n_TA = id_TA
10:16:17 <jad4> yes
10:16:29 <jad4> I keep switching between using   o  and ;
10:25:11 <dons> wow, getting trolled by erlang guys on the haskell list. a sad day
10:25:27 <flux> dons, subject?
10:26:39 <Martijn> flux: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/50015/focus=50050
10:27:11 <flux> ah, reading troll threads, always a good way to spend time..
10:27:18 <flux> martijn, thanks
10:27:23 <dons> 50k?
10:27:26 <dons> that's a lot of -cafe
10:27:48 <vixey> > let walk k r [] = k == r ; walk k r (x:xs) = walk (x:k) r xs in join (walk []) [0,1,2,3]
10:27:50 <lambdabot>   False
10:27:55 <vixey> > let walk k r [] = k == r ; walk k r (x:xs) = walk (x:k) r xs in join (walk []) [3,2,2,3]
10:27:57 <lambdabot>   True
10:28:28 <flux> quite tame that was, not much amusement :/
10:31:31 <byorgey> vixey: why write your own 'walk' function instead of just saying (==) `ap` reverse  or something like that?
10:31:47 <byorgey> > (==) `ap` reverse $ [1,2,3,4]
10:31:47 <ski_> byorgey : can't use `reverse'
10:31:48 <lambdabot>   False
10:32:01 <vixey> byorgey, just liked the idea ddarius said
10:32:44 <byorgey> ok, sorry, I missed the backstory I guess =)
10:32:56 <byorgey> just seems like you've basically reimplemented reverse within 'walk' anyway
10:33:21 <ski_> byorgey : in some sense, that's necessary, yes
10:35:45 <vixey> do you use NbE byorgey?
10:35:58 <vixey> just curious because you said you would implement a typechecker
10:36:15 <byorgey> vixey: what's NbE?
10:36:26 <ski_> Normalization-by-Evaluation
10:36:47 <byorgey> er, what's that?
10:37:09 <int80_h> dons: what's the subject field for the erlang trolls?
10:38:09 <vixey> byorgey, it's this interesting technique for computing normal forms that I just found about recently
10:38:25 <vixey> I don't really understand well enough yet to describe it thugh
10:38:46 <byorgey> ok, well, given that I hadn't heard of it, I guess the answer is "no, I don't use it" =)
10:39:04 <byorgey> unless I am just THAT CLEVER that I came up with it on my own without realizing it
10:39:07 <byorgey> (which I doubt)
10:40:49 <wchogg> int80_h : it was really just one guy complaining that Haskell can't do what Erlang can.  I asked him what specifically was missing & I got a fairly useless answer and a scolding from dons for an erroneous assumption.
10:46:38 * bos spent last night hacking on continuation-based parsing combinators for bytestrings.
10:46:54 <bos> might have a nice programming model going here.
10:47:19 * Trafalgard wonders what you just said :P
10:47:45 <Trafalgard> Nobody speaks in english anymore
10:47:54 <dons> bos, cool. will users know there's CPS underneath?
10:47:58 <mmorrow> bos: ReadP rules
10:48:03 <dons> Trafalgard: welcome to #haskell
10:48:10 <Trafalgard> :P
10:48:12 <wchogg> bos : what'll be different between yours & the parsec w/ bytestring support?
10:48:16 <bos> dons: nope, only if you run out of data.
10:48:20 <dons> cool
10:48:46 <bos> wchogg: mine will (i hope) be much faster, and will support resumable parsing.
10:49:08 <bos> wchogg: as in, you read a packet off the network, try to parse it, and find that you'll need to read another packet before you can succeed.
10:49:31 <wchogg> bos : Ah!  That'd be pretty cool.  Is that going to be part of that attoparsec package?
10:49:34 <Trafalgard> now THAT sounds useful
10:49:42 <bos> wchogg: so you'll get handed back a partial result along with a continuation that you can give another bytestring to, which will give you back the final parse or another partial parse.
10:49:44 <bos> wchogg: yes
10:50:08 <augustss> bos: that sounds excellent!
10:50:10 <wchogg> awesome
10:50:12 <bos> i have the basic plumbing working, now it's a matter of adding a few more bits.
10:50:19 <polveroj> bos: a bit like iteratees, then?
10:50:21 <Trafalgard> except that generally I would say disable the nagle algorithm and send everything needed at once so it all arrives at the other end together
10:50:28 <bos> polveroj: yes, but an easier programming model.
10:50:37 <bos> Trafalgard: only that doesn't work in practice
10:50:40 <Trafalgard> but I haven't learned networking stuff with haskell yet so dunno if it's the same as c++ etc
10:50:43 <Trafalgard> eh?
10:50:50 <Trafalgard> worked fine for ultima online
10:51:05 <bos> turning off nagle only works for small payloads.
10:51:19 <bos> and in fact it makes things worse for larger payloads.
10:51:20 <wchogg> Trafalgard : networking in Haskell is pretty simple
10:52:12 <Trafalgard> Come to think of it, UO never sent really large payloads
10:52:23 <Trafalgard> depending on what you mean by large
10:52:39 <int80_h> < head []
10:52:44 <int80_h> > head []
10:52:45 <lambdabot>   * Exception: Prelude.head: empty list
10:52:58 <wli> bos: How much of the partial parse may be inspected?
10:53:24 <Trafalgard> the packet size was capped at 64 KB or something like that. I'm probably misremembering the number but it was something small in kilobytes like that.
10:53:42 <Trafalgard> dialogs were the biggest things that would get sent
10:53:47 <int80_h> > Just head []
10:53:48 <lambdabot>   Couldn't match expected type `[a] -> t'
10:54:29 <Trafalgard> Would you call that large, or no?
10:55:14 <ski_> > Just (head [])
10:55:16 <lambdabot>   Just * Exception: Prelude.head: empty list
10:55:26 <dfan> Trafalgard: you worked on UO?
10:55:37 <bos> on the largish side. that would be fairly likely to be split up by the TCP stack into several segments.
10:55:38 * ski_ mutters about missing `Cont2' in lambdabot ..
10:55:51 <bos> wli: that depends.
10:56:12 <bos> wli: i've got a "yield" action that lets you drop out to your caller whenever you like.
10:56:17 <Trafalgard> dfan, no, messed around with UO server emulators
10:56:27 <bos> wli: otherwise, your caller hears nothing until you have a complete result.
10:56:36 <dfan> Aha
10:56:43 <bos> oh, hi dfan!
10:57:04 <mmorrow> bos: are you using a modifed version of the ReadP `P' datatype + something like Part a = None | One a (ByteString -> Part a) | Cont (Maybe ByteString -> Part a)  ?  (this was my strategy for this, which i still have to work out some minor kinks in)
10:57:18 <bos> mmorrow: nope.
10:57:24 <dfan> Hi bos!  Your compatriots here have been very helpful
10:57:30 <mmorrow> ooh, cool. what is it then?
10:57:38 <bos> a hand-rolled monad.
10:57:47 <bos> and hand-rolled result types.
10:57:57 <mmorrow> interesting
10:58:47 <bos> http://hg.serpentine.com/haskell/attoparsec/file/tip/src/Data/ParserCombinators/Attoparsec/Incremental.hs
10:59:18 <wli> bos: The question has more to do with how much of what you've parsed thus far the caller can figure out you've done. e.g. if you're doing some predictive scheme and have figured out that e.g. a shell is in a for loop within a case statement within .. etc. but not parsed the whole interior of the innermost as-of-yet-parsed construct.
11:00:03 <bos> wli: if you explicitly yield, you can tell the caller whatever you like.
11:00:17 <bos> wli: otherwise, there's not much a generic library can offer that i can think of.
11:01:10 <bos> of course, i'm open to suggestions.
11:02:00 <wli> zsh-style command-line editing is the example I have in mind.
11:02:59 <bos> wli: i don't use zsh, so i'm not following you.
11:03:23 <redditbot> Software Transactional Memory: The Current State of the Art
11:04:22 <wli> bos: command editing deals with multiline commands, and prompts with the results of a partial parse like "for while case if> " ... "for while case then> " etc.
11:05:06 <bos> wli: i think i see what you're getting at.
11:07:08 <jad4> what about this one: for  f : A -> B   it seems to me like  we should have  T f  o  n_A = n_B  o  f
11:07:22 <jad4> am I right?
11:07:38 <jad4> T monad , n eta
11:08:26 <ski_> jad4 : that's a naturality condition of `eta'
11:08:44 <monochrom> 
11:08:49 <jad4> ski_: Ah of course!
11:09:05 <ski_> monochrom : !
11:09:08 <jad4> monochrom: oh, is there an easy way to input that?
11:09:21 <jad4> ski_: thank you ski_!
11:09:26 <monochrom> We are living in such dark age.
11:09:42 <monochrom> I installed SCIM and added the "TeX input method".
11:09:48 <int80_h> This is the first line in my function
11:09:54 <int80_h> MySortList unsorted []    = MySortList ((tail unsorted) (head unsorted))
11:10:05 <ski_> s/MySortList/mySortList/
11:10:11 <jad4> hmm SCIM never herad of it
11:10:12 <int80_h> ghci reports that MySortList is a data constructor
11:10:29 <int80_h> ooooh!
11:10:45 <ski_> also, `(tail unsorted) (head unsorted)' looks like a type error
11:10:59 <wli> bos: I've yet to see anything of comparable power to zsh's command-line parsing.
11:11:14 <dons> lovely, http://www.reddit.com/r/programming/comments/7ocdk/building_a_wiki_in_haskell_functional_web/
11:11:26 <int80_h> shi_ : yeah it's a type error...bah
11:11:59 <bos> wli: hm
11:12:10 <marcot> Good afternoon.
11:12:52 <ski_> int80_h : maybe you wanted `mySortList (tail unsorted) (head unsorted)' ?
11:12:58 <elbar> :t head
11:12:59 <lambdabot> forall a. [a] -> a
11:13:09 <int80_h> ski_ : yeah I fixed it
11:13:36 <ski_> (sorry, s/wanted/meant/)
11:17:08 <leimy> dons: neat!
11:17:22 <leimy> dons: anyone know if anyone's working on an SNMP stack for Haskell?
11:17:33 <leimy> er sorry, didn't mean to send that to dons specifically :-)
11:18:22 <FunctorSalad> hint: the "safe" in "cast is a type-safe cast" just means that it won't segfault, not that it won't cause hard-to-find bugs :)
11:18:48 <leimy> Looks like ASN.1 may be there already.
11:19:13 <leimy> alpha stability...
11:19:27 <leimy> and it doesn't appear to build on 6.10
11:19:28 <FunctorSalad> (I was wondering wth my exception type wasn't caught... culprit: "fromException = cast" ...)
11:19:32 <mmorrow> bos: that looks sweet. here's some snippets from what i was experimenting with (starts with modifed ReadP, then wrapper since i didn't specialize to ByteString (pita in hidsight), then some HTTP-related parsers, then incrementally grabbing an HTTP header from a socket)  http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=741#a745
11:19:42 <FunctorSalad> (should be "fromException (SomeException ex)= cast ex")
11:19:49 <mmorrow> it seems to actually work too! :)
11:19:57 <lilac> FunctorSalad: ouch :(
11:20:11 <bos> mmorrow: nice
11:20:34 <mmorrow> gotta clean it up, but i'm excited about it
11:22:11 <leimy> mmorrow: what is it?
11:22:54 <mmorrow> leimy: parts of this webserver i've been working on
11:22:59 <leimy> neat
11:23:21 <leimy> mmorrow: what is "P"?
11:23:29 <mmorrow> it's from ReadP
11:23:42 <mmorrow> it's this neat datatype that it uses
11:23:43 <leimy> Ah I need to look at that I guess :-)
11:24:05 <leimy> fail = const Fail!
11:24:07 <leimy> :-)
11:24:09 <mmorrow> heh
11:24:20 <leimy> I wish more Monads did that.
11:24:22 <mmorrow> yeah, check out the ReadP code. i love it
11:24:27 <leimy> rather than toss an exception I can't deal with.
11:24:36 <mmorrow> i hate exceptions
11:24:43 <leimy> I've become a fan of MonadPlus on the other hand
11:25:06 <leimy> mplus with Maybe is great for writing expressions that would have been big case statements :-)
11:25:17 <pumpkin> like what?
11:25:18 <mmorrow> ReadP is so cool, because it uses that P datatype + its MonadPlus instance to do breadth-first searching for parses
11:25:19 <leimy> though I question whether anyone else can read what I've written.
11:25:29 <leimy> oh not necessarily case but if.
11:25:55 <lilac> i find it saddening that mzero is in MonadPlus rather than in its own typeclass :(
11:26:11 <leimy> pumpkin: I've got a program that accepts requests for "get" and "set" to a Data.Map
11:26:19 <leimy> and if something isn't in a map I need to return an error string
11:26:22 <pumpkin> ah
11:26:29 <Trafalgard> So I'm in chapter 6 of Real World Haskell and it has this line by itself, not in the JSON class definition: jaryToJValue :: (JSON a) => JAry a -> JValue
11:26:30 <leimy> so if I get back a Nothing... I can `mplus` it with the default
11:26:35 <leimy> and fromJust the whole expression
11:26:45 <leimy> And I never fail, because of `mplus` :-)
11:27:01 <Trafalgard> The book doesn't explain this here, but am I reading this right - is it actually adding this function definition to the JSON class?
11:27:07 <Trafalgard> *typeclass
11:27:14 <rwbarton> Trafalgard: No
11:27:23 <FunctorSalad> lilac: it's fixed in Arrow
11:27:25 <leimy> totally excellent.. got the idea from the Real World Haskell book
11:27:30 <pumpkin> leimy: what if they all fail, and fromJust will fail too? :P
11:27:39 <Trafalgard> What's going on then?
11:27:39 <rwbarton> Trafalgard: that function will probably be defined out of the JSON class operations
11:27:44 <FunctorSalad> lilac: I haven't encountered anything that has a zero but not a plus though
11:27:54 <lilac> FunctorSalad: i'm not using kleisli arrows just for that! :)
11:27:56 <ski_> Trafalgard : just an auxilary function
11:28:08 <leimy> pumpkin: the right hand side of `mplus` is *always* "Just" something.
11:28:11 <leimy> so it never fails
11:28:15 <pumpkin> ah ok :)
11:28:20 <ski_> FunctorSalad : "plus" in which sense ?
11:28:27 <leimy> so in this case, it totally saved me many lines of code.
11:28:28 <lilac> ski_: mplus
11:28:53 <lilac> FunctorSalad: fair point, i can't think of any examples :)
11:28:58 <leimy> anyway, the Haskell code is started by Erlang
11:29:06 <leimy> and the two communicate over stdin/stdout
11:29:09 <ski_> @wiki MonadPlus_reform_proposal
11:29:09 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
11:29:12 <lilac> FunctorSalad: but requiring an mplus for 'guard' saddens me
11:29:15 <leimy> for transaction processing.
11:29:18 <ski_> lilac : which of those two variants ?
11:29:26 <mmorrow> leimy: err, in that paste `P' is two different things in different pastes
11:29:38 <leimy> mmorrow: ah.. ok
11:29:41 <mmorrow> the first being the ReadP thing
11:29:49 <leimy> I need to learn about ReadP.
11:29:50 <mmorrow> the further down, a synonym
11:29:54 <mmorrow> type P a = ReadP ByteString Word8 a
11:30:04 <mmorrow> newtype ReadP s c a = R {unR :: forall b . (a -> P s c b) -> P s c b}
11:30:14 <mmorrow> (where the P in ReadP is the first P..)
11:30:30 <mmorrow> kinda convoluted .. :)
11:30:53 <mmorrow> (by "first P" i mean the one from ReadP
11:30:53 <mmorrow> )
11:30:58 <leimy> yeah that can happen :-
11:31:05 <rwbarton> mmorrow: I'm confused
11:31:13 <rwbarton> mmorrow: those two definitions you wrote here, are they mutually recursive?
11:31:18 <monochrom> pumpkin: http://www.haskell.org/haskellwiki/Dynamic_programming_example has an example of a case-chain vs a Maybe-do-block.
11:31:26 <rwbarton> mmorrow: oh probably not
11:31:26 <mmorrow> no, _not_ mutually rec
11:31:38 <mmorrow> heh, in trying to clarify i made it worse
11:31:43 <monochrom> Or rather, a mplus-do-block
11:31:56 <pumpkin> monochrom: ah, nice, thanks :)
11:31:59 <lilac> ski_: i only see one proposal there?
11:32:36 <ski_> lilac : yes .. but two classes for "plus" : `MonadPlus' vs. `MonadOr'
11:32:42 <lilac> ski_: though i've not seen MonadOr before, and it looks a bit like Alternative
11:32:54 <lilac> ski_: doesn't that page suggest having both?
11:33:00 <ski_> sure
11:33:07 * TuringTest is writing bug reports to apple against its regex library.
11:33:08 <FunctorSalad> lilac: on that page there's also a suggestion "I'd actually suggest almost the opposite, that MonadPlus be dispensed with and merged into Monad."
11:33:25 <schme> hey #haskell. are there any neat ncurses bindings around?
11:33:28 <ski_> lilac : what's why i wondered which sense of "plus" FunctorSalad had in mind
11:33:39 <TuringTest> Anyone care to run "echo XababaYababaZ | sed -E 's/((X)(aba|a*b)(aba|a*b)(Y)(aba|a*b)*(Z))/[\1] => [\2][\3][\4][\5][\6][\7]/'" and see what \6 matches?
11:33:40 <dons> schme: yes. always check hackage.haskell.org
11:33:54 <TuringTest> It is wrong on OS X 10.4 and 10.5
11:33:55 <schme> dons: Ok I will look there.
11:34:01 <FunctorSalad> ski_: I wasn't aware of the left-distributive vs. left-catch thing
11:34:05 <schme> dons: Do you guys not have some command line tool to search it? :)
11:34:22 <schme> I see jack bindings here. Are they usable?
11:34:26 <thoughtpolice> schme: yes
11:34:33 <thoughtpolice> schme: it's called 'cabal install'
11:34:50 <schme> hmmm..
11:34:55 <schme> Ineed to install thata cabal.
11:35:00 <thoughtpolice> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hscurses
11:35:19 <schme> ah the jack thing is not usable :(
11:35:23 <schme> well thanks for the info there :)
11:35:35 * schme looks on how to resetup cabal.
11:35:36 <lilac> TuringTest: invalid reference to \7 on RHS
11:35:45 <monochrom> "you can't do jack with it" :)
11:35:51 <thoughtpolice> schme: it probably still builds, it's dependencies just need to be updated
11:35:55 <lilac> TuringTest: also, my sed doesn't have a -E
11:36:00 <schme> thoughtpolice: cabal?
11:36:01 <FunctorSalad> what would be right-distributivity btw?
11:36:05 <thoughtpolice> schme: no the jack bindings
11:36:10 <schme> monochrom: That's hillarious.
11:36:16 <TuringTest> lilac:  ummm... "sed -r" instead of "sed -E"
11:36:16 <schme> thoughtpolice: I'm sure they build, they are just not usable :)
11:36:35 <Botje> [XababaYababaZ] => [X][ab][aba][Y][aba][Z]
11:36:36 <TuringTest> Thats the GNU vs BSD annoyance
11:36:48 <lilac> TuringTest: [XababaYababaZ] => [X][ab][aba][Y][aba][Z]
11:36:51 <thoughtpolice> schme: http://code.haskell.org/jack/ <-
11:36:52 <TuringTest> Yup... [aba] for the \6 is right.  OS X is printing [b]
11:37:01 <thoughtpolice> those are the actual bindings and they are apparently updated
11:37:03 <thoughtpolice> quite recently
11:37:27 <thoughtpolice> examples here - http://code.haskell.org/jack/examples/
11:37:28 <TuringTest> And getting
11:37:39 <schme> thoughtpolice: Ya man. I know where they are at. :)
11:37:42 <TuringTest> And getting "b" for \6 is crazy wrong.
11:37:59 <schme> thoughtpolice: Even the site for it claims it is unusable :)
11:38:16 <lilac> TuringTest: in (...)*, is it supposed to reference the first match of ... or the last?
11:38:25 <lilac> either way it's wrong, but...
11:38:26 <schme> But nevermind. I'll poke around this cabal thing. I remember I had it working at one time.
11:38:39 <thoughtpolice> it just says that real time audio processing in haskell probably won't work very well. not that the bindings don't work.
11:38:45 <TuringTest> lilac: If it matched "b" then how did it match the lone "a" next to it?
11:38:46 <dons> thoughtpolice: ?
11:38:54 <mauke> lilac: the last
11:38:56 <schme> thoughtpolice: Yees.. making 'em unusable.
11:39:15 <mauke> also, just use perl :-)
11:39:23 <schme> (:
11:39:27 <luite_> 4 gig is niet stoer
11:39:31 <luite_> ooops
11:39:31 <lilac> TuringTest: right, it's obviously wrong. it's presumably done (aba)(b) then backtracked but kept the "b" for some reasone
11:39:32 <TuringTest> lilac: So it could not possibly, in any algorithm, have matched "b" and reached the (Z) at the end.
11:39:34 <thoughtpolice> dons: http://open-projects.net/~shahn/index.cgi?seite=code (see there)
11:39:35 <schme> Whi is there no cabal in debian :(
11:39:38 <olsner> mauke: blasphemer!
11:40:00 <mauke> single implementation => single set of bugs to work around
11:40:01 <lilac> TuringTest: perhaps it keeps the rightmost instance it sees?
11:40:05 <TuringTest> lilac: And this infects the Haskell regex-posix package that regex-compat uses to present Text.Regex
11:40:30 <TuringTest> lilac: One could download the source, but I have job.
11:41:28 <dons> doesn't say much
11:41:39 <TuringTest> I just wish, in 2009, that the POSIX certified OS X actually had a working regex library.
11:42:03 <mauke> regex is hard, let's go shopping
11:42:45 <lilac> TuringTest: try this: echo ababcZ | sed -E 's/(a|b|abc)*Z/\1/'
11:42:47 <TuringTest> mauke: It is hard. But my regex-tdfa libary in pure Haskell does not have these bugs.  Hell, QuickCheck found a different regex bug in OS X 10.4 last year.
11:42:56 <lilac> TuringTest: rather, echo abcZ | ...
11:42:57 <mauke> heh
11:43:27 <TuringTest> lilac: I get "abc"
11:43:57 <schme> So.. who has a nice packaged .deb of this cabal stuff? :)
11:44:27 <Saizan_> schme: have you tried the bootstrap.sh script in the cabal-install tarball?
11:44:44 <lilac> TuringTest: one more:  echo abcZ | sed -E 's/(a|)(b|abc)*Z/\2/'
11:44:50 <schme> Saizan_: I can't even find cabal-install tarball :)
11:44:50 <TuringTest> mauke: Yep, it randomly found wierd bugs in 10.4 that are no longer in OS X 10.5, so there has been progress.
11:45:01 <pumpkin> anyone know if there are any plans to add more functions to statistics-fusion?
11:45:04 <thoughtpolice> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
11:45:09 <mauke> pfft
11:45:09 <dons> pumpkin: i'll accept more
11:45:22 <dons> i'll even rewrite non-fused versions
11:45:24 <mauke> I've written a regex library in C with much more interesting bugs
11:45:36 <mauke> OS X is disappointing
11:45:36 <Saizan_> schme: there http://hackage.haskell.org/packages/archive/cabal-install/0.6.0/cabal-install-0.6.0.tar.gz
11:45:39 <pumpkin> dons: I was thinking of writing more, but I'm not sophisticated enough yet to pay attention to the generated code as the comments say you do in the current ones :)
11:45:48 <TuringTest> echo abcZ | sed -nE 's/(a|())(b|abc)*Z/[\2]/p'  results in []
11:45:53 <dons> so you just do the 'model' versinos
11:45:58 <dons> and i can reimplement them as fused ones
11:46:02 <schme> Saizan_: thanks mate!
11:46:03 <thoughtpolice> pumpkin: ghc-core helps a lot on that note, fwiw
11:46:07 <TuringTest> ooops
11:46:11 <mauke> TuringTest: I hope so
11:46:11 <pumpkin> okay :) I'll submit some patches when I get some time then, dons
11:46:13 <lilac> TuringTest: well that's wrong :) should be 'abc'
11:46:14 <TuringTest> echo abcZ | sed -nE 's/(a|())(b|abc)*Z/[\3]/p' is [abc]
11:46:25 <pumpkin> thoughtpolice: I keep meaning to learn how to read it, but it doesn't mean much to me right now
11:46:27 <lilac> ah, you've added parens
11:46:36 <TuringTest> lilac: I had to add () to make it happy
11:46:45 <Saizan_> schme: when you need a package here is the first place where to look http://hackage.haskell.org/packages/archive/pkg-list.html
11:46:45 <TuringTest> I should have used ?
11:46:58 <TuringTest> echo abcZ | sed -nE 's/(a?)(b|abc)*Z/[\2]/p' is [abc]
11:46:59 <schme> Saizan_: man it's not working .(
11:47:02 <thoughtpolice> pumpkin: core is very simple, there are only about 4 constructs. it's just that the names generated etc. are kind of unhelpful, and it uses fully qualified type names
11:47:12 <schme> I remember this being a pain :)
11:47:15 <schme> Hrrrmmm.
11:47:15 <thoughtpolice> pumpkin: 4 constructs being let, case, application and abstraction
11:47:16 <pumpkin> yeah, the naming is what's thrown me off so far
11:47:16 <Saizan_> schme: what's the error?
11:47:24 <erikc> is the analysis for ghc's fusion similar to loop fusion analysis in imperative compilers?
11:47:34 <dons> nope
11:47:37 <pumpkin> thoughtpolice: seeing a bunch of rather verbose code with unfamiliar names is daunting :)
11:47:40 <schme> Saizan_: HPPT >= 3000 && <3002, network >=1 && <3       Sorry, somethnig went wrong.
11:47:51 <thoughtpolice> erikc: lots of that stuff is based on RULES
11:47:52 <mauke> you fail at copy/paste
11:47:53 <schme> oh
11:47:56 <schme> HTTP even.
11:47:58 * erikc will read the paper(s)
11:47:58 <dons> its a term rewriting transformation based on algebraic laws
11:48:03 <schme> mauke: I type it by hand! I'm a pro!
11:48:08 <Saizan_> schme: ah, install libghc6-network-dev
11:48:17 <Saizan_> schme: from apt-get
11:48:22 <schme> ehhm..
11:48:25 <schme> aptitude ;)
11:48:28 <thoughtpolice> pumpkin: ghc-core does remove a lot of unnecessary stuff too which is good
11:48:36 <Saizan_>  fine
11:48:42 <pumpkin> yeah, I used that
11:48:44 <schme> ya cool there we go.
11:49:01 <Saizan_> you might also need the -dev version of zlib
11:49:01 <thoughtpolice> pumpkin: but yeah ghc-core helps a lot when analyzing the generated code. you just have to keep track of the names really.
11:49:21 <pumpkin> cool, I'll set some time aside and give it a good look sometime soon
11:49:30 <schme> is there something like make -j2 for this bootstrap?
11:49:37 <TuringTest> echo XababaYababaZ | sed -E 's/((X)(aba|b|ab|aab)(aba|b|ab|aab)(Y)(aba|b|ab|aab)*(Z))/[\1] => [\2][\3][\4][\5][\6][\7]/' is still [XababaYababaZ] => [X][ab][aba][Y][b][Z]
11:49:45 <thoughtpolice> pumpkin: also, using uvector should off the bat help you *a lot*
11:49:50 <Saizan_> schme: no, it's a very simple script
11:49:52 <thoughtpolice> pumpkin: it's pretty aggressively optimized
11:49:53 <TuringTest> So the * in a*b is not the trigger.
11:50:01 <schme> ah man.
11:50:09 <pumpkin> thoughtpolice: yeah, that's what I'm using :) it's how it came up, I wanted more UArr stats functions
11:50:14 <lilac> TuringTest: i have a theory. if i'm right, "echo aZ | sed -r 's/(a|aZ|Zx)*/\1/'" will print Z
11:50:17 <schme> well it works. horray
11:50:19 <schme> thanks!
11:50:40 <thoughtpolice> pumpkin: lots of it comes down to making parameters unboxed etc. and unpacking fields. none of it is too bad or difficult, i suggest RWH's chapters on performance or dons' blog posts on the matter
11:50:47 <schme> In general for ghc though.. ?
11:50:47 <TuringTest> lilac : it prints [aZ]
11:50:56 <lilac> TuringTest: then i have no idea what's going on ;-)
11:51:04 <pumpkin> thoughtpolice: okay :) I'll check it out!
11:51:05 <TuringTest> lilac: And it is not a sed bug here, I see it in the return from the c-library calls.
11:51:10 <thoughtpolice> pumpkin: remember that polymorphism kills some of your optimizations, so settle for unboxed monomorphic types when you can
11:51:16 <schme> cool I'll try this out tomorrow :)
11:51:28 <TuringTest> lilac: It is illogical.  Lovecraftian.
11:51:29 <Gracenotes> @djinn (a -> a ) -> a -> a
11:51:30 <lambdabot> f a = a
11:51:51 <Gracenotes> :/
11:51:57 <athos> :/
11:52:02 <dancor> :D
11:52:02 <Gracenotes> :/
11:52:04 <thoughtpolice> i do believe it's easier than ever to really get highly performant haskell code. uvector, good RULES, optimized libraries like bytestring = win
11:52:14 <Gracenotes> @djinn (a -> b) -> a -> b
11:52:15 <lambdabot> f a = a
11:52:23 <rwbarton> TuringTest: Don't you know -E is short for --erroneous-regexps? :)
11:52:24 <pumpkin> :)
11:52:41 <Gracenotes> wait, what
11:52:55 <int80_h> TuringTes: Lovecraftian? Does it haunt your dreams and drive you insane with the Terrible Truth?
11:52:58 <Gracenotes> @djinn a -> b
11:52:59 <lambdabot> -- f cannot be realized.
11:53:02 <TuringTest> rwbarton: The man page disagrees. Heh
11:53:24 <Gracenotes> > let f a = a in f show 4
11:53:26 <lambdabot>   "4"
11:53:29 <TuringTest> int80_h: OS X regex's are a crack in the logical reality of the world. Madness escapes.  Use \
11:53:43 <Gracenotes> oh... Djinn uses pointless-ish style.
11:54:53 <sjanssen> Gracenotes: no, djinn always uses a pointful style
11:55:05 <dancor> @pl \ a -> a
11:55:06 <lambdabot> id
11:55:22 <dancor> > id show 4
11:55:24 <lambdabot>   "4"
11:55:27 <Gracenotes> yeah.
11:55:55 <pumpkin> is there a partitionU or a simple way to make it?
11:56:15 <ski_> (sjanssen : though it appears it will sometimes use an eta-contracted version of the induced code)
11:56:16 <Gracenotes> sjanssen: it does confuse things somewhat, because (as far as I can tell) the types that generate equivalent code are not isomorphic
11:56:30 <Botje> how does it differ from partition?
11:56:38 <pumpkin> Botje: takes a UArr instead of a list?
11:56:41 <Botje> oh
11:56:44 <Botje> no idea :)
11:56:47 <mauke> does [XababaYababaZ] => [X][ab][aba][Y][aba][Z] look right?
11:58:17 <TuringTest> mauke: Yes that is right.
11:58:28 <TuringTest> \3 and \6 agree
11:58:41 <mauke> @s/// #<"XababaYababaZ" "{{X}{aba|b|ab|aab}{aba|b|ab|aab}{Y}{aba|b|ab|aab}*{Z}}" @OMFG "[\V\0] => [\V\6][\V\5][\V\4][\V\3][\V\2][\V\1]"#> _"
11:58:41 <lambdabot> Unknown command, try @list
11:58:53 <mauke> nice to see that my own regex lib gets it right :-)
11:59:27 <pumpkin> @src partition
11:59:28 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
11:59:28 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
11:59:28 <lambdabot>                               | otherwise = (ts, x:fs)
11:59:47 <pumpkin> that looks pretty easy to convert to UArr
11:59:50 <athos> :t partition
11:59:52 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:01:39 <sjanssen> Gracenotes: I'm not sure what you mean
12:03:02 <Gracenotes> @djinn a -> a
12:03:02 <lambdabot> f a = a
12:03:04 <Gracenotes> @djinn (a -> b) -> a -> b
12:03:04 <lambdabot> f a = a
12:03:22 <Gracenotes> sjanssen: isn't there supposed to be an isomorphism between types and code?
12:03:24 <redditbot> Lazyness and Cabal Packages
12:03:24 <redditbot> Building a Wiki in Haskell: Functional Web Programming
12:03:49 <Gracenotes> whereas "f a = a" seems to be the same code
12:04:17 <sjanssen> Gracenotes: there is a correspondence: types are theorems; code is proof
12:05:01 <rwbarton> Gracenotes: (a -> b) -> a -> b is just a more specific type (corollary?) compared to a -> a
12:05:33 <sjanssen> "(a -> b) -> (a -> b)" -- makes the similarity more clear
12:06:37 <Gracenotes> oh... Djinn associates application from the right?
12:06:51 <EvilTerran> Gracenotes, all of haskell does
12:06:53 <EvilTerran> ?type map
12:06:54 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
12:06:55 <Gracenotes> well, yes
12:06:56 <sjanssen> Gracenotes: it uses the same scheme as Haskell
12:07:12 <pumpkin> :*: do I need a special option to make that a type?
12:07:18 <rwbarton> -XTypeOperators
12:07:19 <Gracenotes> yeah. silly me.
12:07:33 <Gracenotes> Okay, that makes a lot more sense
12:07:37 <pumpkin> rwbarton: thanks, it suggested that but I was surprised that I'd need a special option for it
12:08:17 <Gracenotes> @djinn a -> (a -> b) -> b
12:08:17 <lambdabot> f a b = b a
12:09:21 <dolio> @djinn a -> Not a -> b
12:09:21 <lambdabot> f a b = void (b a)
12:10:23 <athos> :t void
12:10:25 <lambdabot> Not in scope: `void'
12:10:34 <mauke> @djinn-env
12:10:34 <lambdabot> data () = ()
12:10:34 <lambdabot> data Either a b = Left a | Right b
12:10:34 <lambdabot> data Maybe a = Nothing | Just a
12:10:34 <lambdabot> data Bool = False | True
12:10:34 <lambdabot> data Void
12:10:36 <lambdabot> type Not x = x -> Void
12:10:38 <lambdabot> class Eq a where (==) :: a -> a -> Bool
12:11:19 <rwbarton> pumpkin: According to Haskell 98 there are no infix type {variables, construtors, classes}
12:11:28 <pumpkin> ah, weird :)
12:11:33 <rwbarton> Also no infix modules, which I find an entertaining notion :)
12:11:37 <athos> thanks mauke
12:11:47 <pumpkin> GHC allows infix modules? :o
12:12:20 <rwbarton> I don't think so.  What would that even mean?
12:12:51 <rwbarton> (GHC doesn't allow infix type classes either AFAIK)
12:12:59 <ski_> athos : `void :: Void -> a'
12:13:21 <athos> ok
12:13:40 <ski_> rwbarton : might be useful for module system "functors"
12:14:00 <EvilTerran> ?type get :: (s `MonadState` m) => m s
12:14:01 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
12:14:09 <EvilTerran> rwbarton, it does :)
12:14:41 <rwbarton> EvilTerran: Ah, cool.  I think you can't use the notation in instance definitions, though
12:14:44 <EvilTerran> although i recall infix classes not working in instance heads in an earlier version
12:14:56 <EvilTerran> i dunno if that's still the case
12:14:59 <rwbarton> EvilTerran: (note how I choose something you can't prove me wrong about with lambdabot :P)
12:15:02 <monochrom> If you allow parameterized modules, you can have a module parameterized with two parameters, and then you will want an infix notation...
12:15:20 <monochrom> (See SML and OCaml for parameterized modules. They are called "functors" there.)
12:15:33 <rwbarton> ski_: monochrom: Makes sense
12:15:48 <dcoutts_> we're pretty terrible about exposing opportunities for parallelism
12:15:55 <dcoutts_> even for things that are trivially parallelisable
12:16:13 <dcoutts_> we tend to think in ways that modularise and serialise
12:16:33 <dcoutts_> when you've got more than ~8 cores that's really noticeable
12:16:43 <pumpkin> what's a good way to get started with heap profiling on my program that uses heaps of memory? :P
12:16:55 * dcoutts_ has 50 threads sitting idle while running a 'parallel' testsuite
12:18:03 <ztirF> I have a question about the ((->) r) monad - it has something to do with S and K combinators, right?
12:18:26 <sjanssen> ztirF: yes, it that monad return = K
12:18:30 <sjanssen> s/it/in
12:18:35 <Saizan_> ap = S
12:18:36 <sjanssen> and ap = S
12:18:42 <monochrom> . o O ( everythign has something to do with S and K ... )
12:19:09 <ztirF> ok, so >>= is like S but backwards?
12:19:55 <ski_> `(=<<)' isn't like `s'
12:19:56 <Saizan_> x >>= f = S (flip f) x
12:20:36 <mauke> ski_: it totally is
12:20:48 <ski_> @type (=<<)
12:20:49 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
12:20:53 <ski_> @type ap
12:20:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:21:07 <mauke> ap and (>>=) are duals, sort of
12:21:17 <ski_> mauke : care to elaborate on what you mean ?
12:21:19 <mauke> they're the one-branch versions of liftM2
12:21:38 <mauke> liftM2 c f g x = f x `c` g x
12:21:46 <ski_> liftM1 = liftM = fmap
12:22:04 <mauke> ap f g x = liftM2 f id g x
12:22:13 <mauke> (>>=) just has the 'id' on the other side
12:22:33 <ztirF> ok, so "normally" I think of Monads as "holding" something -- that's how IO and List made sense to me
12:22:34 <Saizan_> it's also flipped
12:22:34 <monochrom> Interesting!
12:22:51 <ztirF> what can I think of ((->) r) holding
12:23:02 <ski_> mauke : i still don't see what you refer to ..
12:23:15 <rwbarton> @pl \x -> f x (g x)
12:23:15 <lambdabot> ap f g
12:23:19 <rwbarton> @pl \x -> f (g x) x
12:23:20 <lambdabot> f =<< g
12:23:28 <mauke> rwbarton: ah, thanks
12:23:32 <monochrom> If I know what you think IO holds, I may be able to tell you what ((->) r) holds.
12:23:33 <ski_> ztirF : `(r ->) a' holds a value of type `a', for every value of type `r'
12:23:35 <mauke> ztirF: return values
12:23:46 <ski_> ztirF : e.g. `(Bool ->)' holds pairs of values
12:24:39 <rwbarton> mauke: I bet this answers that question roconnor had about ap vs. >>= in the Reader monad
12:25:11 <rwbarton> @pl \x -> flip f x (g x)
12:25:11 <lambdabot> ap (flip f) g
12:25:49 <rwbarton> well, maybe this is cheating
12:26:56 <roconnor> rwbarton: huh?
12:27:09 * roconnor reads back
12:27:57 <ski_> mauke : ok
12:28:25 <ski_> mauke : so this appears to be related to that we have `(a -> m b) -> m (a -> b)' here
12:28:39 * ski_ wonders what that might be called
12:29:43 <rwbarton> roconnor: f =<< g === \x -> f (g x) x === \x -> flip f x (g x) === ap (flip f) g, but I think using flip counts as cheating
12:30:07 * sw17ch wonders how hard it would be to write a layer under the RTS to allow haskell to run without an OS
12:30:21 <ski_> (i think i've seen `flip :: (a -> m b) -> m (a -> b)' in some paper, actually ..)
12:30:39 <olsner> sw17ch: easy enough to have been done a few times already, but not so easy that everyone's doing it :P
12:30:46 <mauke> ski_: http://mauke.ath.cx/tmp/flow.png :-)
12:30:53 <sw17ch> olsner: references? !! :D ?
12:30:55 <ztirF> ok so yesterday my question was about delete =<< minimum -- in that case delete is a ([a] ->) monad?
12:30:57 <ski_> (might be something for Cale to chew on, with his `(.) :: (a -> b) -> (f a -> f b)')
12:31:38 <roconnor> clearly (.) is for category composition rather than fmap
12:31:50 <roconnor> something else needs to be used for fmap, such as <$>
12:32:14 <rwbarton> roconnor: Yes!!
12:32:19 <rwbarton> roconnor: Glad someone agrees with me on this :)
12:32:23 <ski_> roconnor : tell that to Cale :D
12:32:24 <abuiles1> Hi guys, I have a Regular expression, And I want after the evaluation of this, return some values from the string but no all. any clue?
12:32:33 <olsner> sw17ch: I know of House and hOp at least
12:32:33 <mattam> (.) is fmap in Caleskell?
12:32:44 <pumpkin> hmm, my heap profiling didn't generate any data
12:32:49 <ski_> mattam : aye-aye
12:32:49 <pumpkin> do I need to tell it anything special?
12:32:54 <pumpkin> I used -hcy
12:32:59 <mauke> > liftM2 h f g x
12:33:00 <lambdabot>   Add a type signature
12:33:01 <roconnor> @tell Cale clearly (.) is for category composition rather than fmap. something else needs to be used for fmap, such as <$>
12:33:01 <sw17ch> olsner: was hOp an OS?
12:33:01 <lambdabot> Consider it noted.
12:33:10 <EvilTerran> ... surely "(a -> m b) -> m (a -> b)" can't be done for monads in general, because the parameter's side-effects can depend on it's parameter?
12:33:16 <mauke> > liftM2 h f (g :: Expr -> Expr) x
12:33:17 <lambdabot>   Add a type signature
12:33:18 <roconnor> mattam: I think Caleskell has been renamed Hascale
12:33:28 <ski_> EvilTerran : indeed
12:33:40 <roconnor> or maybe HasCale
12:33:45 <roconnor> hmm
12:33:50 <olsner> sw17ch: hOp later became House, apparently
12:33:53 <mattam> :)
12:33:59 <EvilTerran> ?type \f x -> ($x) <$> f -- although this goes the other way
12:33:59 <RayNbow> hasCale :: a -> Bool -- ?
12:34:00 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
12:34:06 <EvilTerran> er, no it doesn't
12:34:09 <olsner> @where house
12:34:09 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
12:34:10 <abuiles1> I mean if I have something like "XX XX 00 XX:XX:XX 00 XX XXXX", After check that the string match with the expression that I need, I want to get just "XX XX 00 XX XXXX"
12:34:13 * ski_ refrains from incurring "lolcats"
12:34:34 * EvilTerran continues thinkin
12:34:49 * BMeph fails to resist: I can HasCaleplz? Kthxbai! ;p
12:34:51 <sw17ch> @where lambadacats
12:34:51 <ski_> EvilTerran : it seems a "similar" property to monadic strength
12:34:51 <lambdabot> I know nothing about lambadacats.
12:35:05 <wchogg> sw17ch : dancing cats?
12:35:15 <olsner> @where+ House http://programatica.cs.pdx.edu/House/
12:35:15 <lambdabot> Okay.
12:35:23 <sw17ch> http://arcanux.org/lambdacats.html
12:35:37 <ski_> (BMeph : bad cat, no tuna for you)
12:35:44 <polveroj> @where fnords
12:35:44 <lambdabot> I know nothing about fnords.
12:36:01 * sw17ch sneaks BMeph tuna.
12:36:04 * sw17ch loves \cats
12:36:24 * BMeph purrs and rubs sw17ch's ankles
12:37:02 * sw17ch gets creeped out by the metaphor and runs away
12:37:32 <wchogg> ...yeah, #haskell just got a little more uncomfortable
12:37:48 <TuringTest> @users
12:37:49 <lambdabot> Maximum users seen in #haskell: 668, currently: 636 (95.2%), active: 34 (5.3%)
12:37:59 <ski_> MORE TYPES
12:38:05 <pumpkin> must. find. where. all. the. memory. is. going.
12:38:08 <Raevel> MORE BETTER
12:38:28 <sw17ch> My use of Haskell has people here asking me how we can run it on an embedded platform, and i shall persist in looking for a way until i have it working or i die
12:38:34 <sw17ch> here being my workplace
12:38:52 <roconnor> @quote
12:38:52 <lambdabot> NormanRamsey says: Type annotations in OCaml are completely broken and always have been.
12:39:00 <TuringTest> sw17ch: Use haskell to generate the code for the platform?
12:39:22 <Cale> Write a GHC backend?
12:39:23 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
12:40:05 <sw17ch> Cale: i don't have enough memory to do the sorts of things i'm thinking currently :)
12:40:13 <Cale> roconnor: You mean Control.Category?
12:40:25 <roconnor> if you wish
12:40:28 <sw17ch> unless some one knows how to make GHC play happily in 1 to 8 MB of memory
12:40:34 <sw17ch> (or less!)
12:41:00 <ski_> (Cale : actually, probably it was `flip :: f (a -> b) -> (a -> f b)' ..)
12:41:03 * roconnor doesn't understand te Data / Control distiction
12:41:05 <roconnor> the
12:41:28 <Cale> sw17ch: Well, you wouldn't likely run GHC itself on the embedded platform
12:41:37 <TuringTest> sw17ch: the JHC project aspires to really small binaries.
12:41:41 <pumpkin> my profiling output is meaningless... http://hpaste.org/13761 :(
12:42:04 <sw17ch> Cale: i know. i like hoping for it though :)
12:42:18 <BMeph> roconnor: "The first lesson of Haskell is to know, that there is no Control/Data distinction..." ;p
12:42:18 <Cale> roconnor: I don't see enough good examples of instances of Control.Category to warrant using (.) for it.
12:42:19 <sw17ch> TuringTest: i've looked a lot at JHC
12:42:29 <sw17ch> and it's a lot closer to what i wnt
12:42:36 <dolio> roconnor: Control is for things pulled out of category theory, obviously. :)
12:42:56 <Cale> dolio: Like Control.Parallel? ;)
12:43:09 <sjanssen> Control.Parallel should be Data.Parallel
12:43:13 <roconnor> Cale: all of arrows?
12:43:21 <dolio> Yeah, there are a couple of those, too.
12:43:34 <TuringTest> Control.Monoid
12:43:36 <Cale> roconnor: Yeah, not enough.
12:43:44 <dolio> Control.Exception, too.
12:43:50 <ztirF> @pl g x = k x (f x)
12:43:50 <lambdabot> g = ap k f
12:43:53 <ztirF> yay!
12:44:29 <ski_> we should create a `CategoryTheory' partition already
12:44:33 <Cale> roconnor: fmap, on the other hand, occurs in almost every program I write
12:44:45 <pumpkin> anyone know why my profiling output is so uninteresting? :(
12:44:49 <ski_> CategoryTheory.EilenbergMoore, et.c.
12:45:23 <dolio> pumpkin: Did you -auto-all?
12:45:31 <pumpkin> dolio: on ghc, yup
12:45:37 <pumpkin> (when compiling, that is)
12:45:37 <TuringTest> Monoid / Foldable / Traverable  are not really "Data" like the rest
12:45:50 <ski_> (or maybe that's what `Control.Category' is for ?)
12:45:57 <pumpkin> I'm just trying to figure out who/what is eating up so much memory, really
12:46:00 <rwbarton> > let fx = f x in sin3  -- :(
12:46:01 <lambdabot>   <no location info>: lexical error at character '\8289'
12:46:27 <roconnor> we should just flatten the whole Data and Control levels
12:46:56 <roconnor> GHC will produce faster code. :P
12:47:17 <RayNbow> Cale: could you help me a bit with slice categories? Awodey's text mentions there exists a functor from C/A to C, but I can't see that such functor exists for any category C and for any object A in C
12:48:14 <rwbarton> RayNbow: it is just the functor that takes an object (X, f : X -> A) of C/A and forgets about f
12:48:53 <Cale> RayNbow: yep, what rwbarton said :)
12:51:14 <RayNbow> but C/A only contains arrows f from C as objects with cod(f) = A, right?
12:53:09 <Cale> Yeah, the objects of C/A are the arrows X -> A in C.
12:53:14 <RayNbow> what if category C contains objects B and D and an arrow g : B -> D... then g won't even appear in C/A?
12:53:43 <intoverflow> yeah
12:53:53 <rwbarton> RayNbow: C/A is not a sub-anything of C
12:53:54 <Cale> g will appear as an arrow (possibly many times) so long as it makes the appropriate diagram commute
12:54:24 <intoverflow> oh, duh, cale makes a good point: g might not be an object of C/A, but it could be an arrow
12:54:24 <rwbarton> RayNbow: so "appears in" is not really a sensible concept
12:55:20 <RayNbow> perhaps I should start drawing a few example diagrams :p
12:55:55 <Cale> If there are maps b: B -> A and d: D -> A, then g: B -> D will occur as an arrow b -> d in the slice category so long as d.g = b
12:59:21 <pumpkin> bah, too many ByteStrings
12:59:28 <pumpkin> don't know which is which
12:59:55 <ski_> give them different types ?
13:00:40 <pumpkin> I mean, just the Lazy ByteString vs. the strict one, etc.
13:00:41 <augustss> pumpkin: I agree.  Far too many.
13:00:53 <pumpkin> they all have the same name and it's hard to tell what does what
13:00:58 <pumpkin> like my encode is giving me a lazy one
13:01:03 <pumpkin> and I'm trying to figure out how to write it to a file
13:01:11 <pumpkin> aha, encodeFile
13:02:08 <augustss> It used to be that Haskell had overloading so you could just write a function once, and it would work with all related types.  Not so with ByteString.  Or unboxed vectors, etc.
13:03:14 <pumpkin> :(
13:03:53 <noZone> What is it about ByteString types that makes them so naughty?
13:05:06 <Cale> noZone: The operations on them are all monomorphic, and they're collected together only using the module system.
13:05:57 <ztirF> @pl \x -> delete =<< minimum . map f x
13:05:57 <lambdabot> (delete =<<) . (minimum .) . map f
13:06:57 <lasts> @pl \x -> f x >> g
13:06:57 <lambdabot> (>> g) . f
13:07:13 <ztirF> > let f = (^2) in delete =<< minimum . map f [-2,1,3]
13:07:15 <lambdabot>   Couldn't match expected type `[a] -> [a1]'
13:07:46 <ztirF> > let f = (^2) in delete =<< minimum . (map f) [-2,1,3]
13:07:47 <lambdabot>   Couldn't match expected type `[a] -> [a1]'
13:08:32 <ztirF> > let f = (^2) in delete =<< minimum (map f [-2,1,3])
13:08:33 <lambdabot>       Overlapping instances for Show ([a] -> [a])
13:08:34 <lambdabot>        arising from a use o...
13:08:52 <ski_> @type \x y -> x --> y
13:08:53 <lambdabot> forall t t1. t -> t1 -> t
13:09:24 <ski_> @type (-->)
13:09:25 <lambdabot> parse error (possibly incorrect indentation)
13:09:58 <ztirF> > let f = (^2) in (delete =<< minimum) (map f [-2,1,3])
13:09:59 <lambdabot>   [4,9]
13:10:11 <pumpkin> this is frustrating! I'm trying to do stuff with a CSV containing 11426x651 matrix of floats, and even just loading the CSV takes up 600 MB of ram :/ I'm trying to encode it to binary to avoid loading the CSV each time, but it wants loads more RAM now
13:10:33 <ztirF> @pl \x -> (delete =<< minimum) (map f x)
13:10:33 <lambdabot> (delete =<< minimum) . map f
13:10:52 <ztirF>  /facepalm
13:12:21 <RayNbow> Cale, rwbarton, http://i296.photobucket.com/albums/mm178/ShinNoNoir85/SliceCategory.png <-- is this a correct example or?
13:12:42 <mathijs> Hi all, I tried to prove to myself that "map (/ (sum xs)) xs" only evaluates "sum xs" once. please check http://hpaste.org/13762 and tell me if it's right. Is this the real evaluation order?
13:13:39 <Cale> RayNbow: er...
13:14:00 <RayNbow> I'll take that as a no? :p
13:14:12 <Cale> RayNbow: Are these intended to be complete pictures of the respective categories?
13:14:56 <RayNbow> well, the left diagram is supposed to be some complete picture of a category (some category I just made up)
13:15:28 <augustss> mathijs: Haskell doesn't really make any guarantees how many times "sum xs" is evaluated.  You can test an implementation by inserting Debug.Trace.trace at the sum to see how many times it prints.
13:16:03 <rwbarton> RayNbow: the category C/A should look more like (X,f) --g--> (X',f')
13:16:09 <Cale> The g from X to X' might not even be there in the slice if it doesn't make the triangle commute. However, given that there are no other arrows X -> A, it must commute, so that would be there. However, there's also f.h : B -> A and h'.f': D -> A
13:16:15 <mathijs> augustss: Cool, I was looking for something like that.
13:17:18 <rwbarton> RayNbow: that's kind of a technical point, but it might help your understanding
13:17:19 <walski> Hi there
13:17:40 <rwbarton> RayNbow: I'm not sure exactly what the category C is supposed to be, but it looks as though every object has a unique map to A, in which case C/A = C
13:17:48 <walski> I have to use a "random Set generating thing" ;) which is given to our class. It looks like this: http://hpaste.org/13763
13:18:00 <RayNbow> Cale: ah, composed arrows are also considered?
13:18:03 <walski> But I don't have a clue where to get "vector" and "choose" from
13:18:05 <walski> any ideas?
13:18:10 <Cale> RayNbow: they're arrows too
13:18:32 <rwbarton> RayNbow: one of the axioms of a category is that you can compose arrows
13:18:40 <Cale> RayNbow: In order for C to be a category, there must be an arrow B -> A which is the composite h . f
13:18:50 <Cale> er, f . h rather
13:19:14 <Cale> If this is the preorder category though... any triangle in a preorder category commutes, and there's at most one arrow X -> A for any given X. So the slice over A will just be all the objects with an arrow to A, and all the arrows between them.
13:19:19 <Cale> (sort of boring)
13:20:29 <Cale> Somewhat more interesting to consider would be in the category of sets, to take the slice over some 2-element set.
13:20:34 * RayNbow just completely forgot about arrow composition when he was reading pg. 15 of Awodey's book :)
13:20:42 <Cale> (call it 2)
13:20:56 <Cale> So then the objects of this slice are functions X -> 2
13:21:24 <Cale> Which naturally correspond to partitions of X into two parts, or subsets of X.
13:21:48 <Cale> Then the arrows X -> Y in the slice are the functions X -> Y which preserve this partitioning.
13:22:49 <Cale> say 2 = {0,1}, just for concreteness' sake
13:23:22 <Cale> and that f: X -> 2 and f': X' -> 2 are objects in the slice category.
13:24:05 <ski_> @index choose
13:24:05 <lambdabot> Test.QuickCheck, Debug.QuickCheck
13:24:07 <ski_> @index vector
13:24:07 <lambdabot> Test.QuickCheck, Debug.QuickCheck
13:24:15 <Cale> then g: f -> f' in the slice category if f' . g = f
13:24:29 <Cale> That is, f' (g x) = f x for all x in X.
13:24:29 <ski_> walski : ^ one of those .. i don't recall which one of them is the deprecated one, though
13:24:43 <Cale> (this is the category of sets, so I can take it apart like that :)
13:25:13 <walski> ski_: Thanks!
13:25:54 <Cale> That is to say, each x in X is sent to the same thing by f as the image of x under g is sent to by f'
13:27:49 * RayNbow nods
13:27:57 <Cale> RayNbow: so that makes sense?
13:28:01 <RayNbow> yes
13:28:04 <RayNbow> thanks :)
13:28:39 <walski> Now I'm getting a "Occurs check: cannot construct the infinite type: a1 = Set a1
13:28:39 <walski>       Expected type: Set a1 -> a1 -> a1" on the return of the above example (http://hpaste.org/13763)
13:29:03 <pumpkin> bahhh
13:29:13 <Cale> Perhaps more visual would be to say that the function f: X -> A has the job of painting the elements of X with colours selected from A, and then an arrow from the slice category g: f -> f' is required to preserve colour assignments.
13:29:26 <ski_> walski> :t add
13:29:29 <ski_> walski> :t empty
13:29:39 <pumpkin> btw, I was thinking about "unsafety"
13:29:58 <pumpkin> can encode and decode be joined to do unsafe coerces without the word unsafe in the function?
13:30:08 <pumpkin> seems like it should be possible
13:31:06 <augustss> pumpkin: which encode and decode are these?
13:31:11 <pumpkin> augustss: Data.Binary ones
13:31:25 <augustss> pumpkin: what would be unsafe about them?
13:31:30 <RayNbow> btw Cale, also thanks for recommending Awodey's text some time ago :)
13:31:46 <walski> ski_: *Set> :t add \ add :: (Ord a) => Set a -> a -> Set a \ *Set> :t empty \ empty :: Set a
13:32:07 <ski_> walski : s/add/(flip add)/
13:32:12 <RayNbow> (although I'm advancing slowly through it... but that might be because I tend to read it late at night in bed :p)
13:32:19 <augustss> pumpkin: It's just a mapping from one type to another.  It might be a crazy one, but not unsafe.
13:32:27 <pumpkin> ah ok
13:32:47 <ski_> @djinn a -> Maybe b
13:32:48 <lambdabot> f _ = Nothing
13:33:24 <walski> ski_: Sorry don't understand? Are the parameters of add twisted?
13:33:26 <Olathe> > Data.Binary.decode
13:33:27 <lambdabot>       Overlapping instances for Show (BSLC.ByteString -> a)
13:33:27 <lambdabot>        arising fr...
13:33:33 <Olathe> > Data.Binary.decode "hello"
13:33:34 <lambdabot>   Couldn't match expected type `BSLC.ByteString'
13:33:45 <pumpkin> so does it seem reasonable to have a 7629x652 matrix (represented as a list of UArray Int Double) use up 116 MB?
13:33:47 <Olathe> > Data.Binary.encode "hello"
13:33:48 <lambdabot>   /tmp/887176019953972648:70:32: Not in scope: `Data.Binary.encode'
13:33:49 <pumpkin> (after encode)
13:33:54 <ski_> walski : yes
13:33:57 <vixey> /tmp/887176019953972648:70:32: is nice and meaningful
13:33:58 <ski_> @type foldr
13:34:00 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:34:07 <rwbarton> > 7629*652*8/(10^20)
13:34:08 <lambdabot>   3.9792864e-13
13:34:09 <Olathe> Why is lambdabot giving filenames ?
13:34:12 <augustss> > 7629*652*8
13:34:13 <rwbarton> > 7629*652*8/(2^20)
13:34:13 <lambdabot>   39792864
13:34:14 <lambdabot>   37.949432373046875
13:34:24 <augustss> No
13:34:35 <Badger> huh
13:34:36 <pumpkin> augustss: that's the size I would've expected, but I assumed there might be overhead or something :P
13:34:46 <walski> ski_: Thanks a lot!
13:34:47 <pumpkin> wasn't quite sure how the Data.Binary was encoding it
13:34:48 <Badger> > fix insanity
13:34:49 <lambdabot>   Not in scope: `insanity'
13:34:55 <mreh> how does one define your own infix operator?
13:35:06 <vixey> mreh, you just use it
13:35:29 <RayNbow> > let (*) x y = x+y    in 3*7
13:35:30 <lambdabot>   10
13:35:32 <vixey> > let x =$= y = (x + y)/2 in  3 =$= 5
13:35:33 <ski_> > let (a + b) x = b * (x - a) in (15 + 18) 10
13:35:34 <lambdabot>   4.0
13:35:35 <lambdabot>   -90
13:35:38 <mreh> yeah, that's it
13:35:52 <mreh> cheers RayNbow
13:36:15 <mercury^> It will get low precedence and left associativity by default iirc.
13:36:20 <pumpkin> augustss: only other thing I can think of is that the list of UArrays (the list length is 651, each UArray is 7629) is in a Pair with some small metadata
13:36:31 <mreh> can i change that?
13:36:42 <Saizan_> Olathe: because you haven't written the code to clean the error messages from GHC yet! ;)
13:36:44 <mercury^> mreh: yes, have a look at infixl and infixr
13:36:47 <mreh> all i want to do is be able to use it in a section
13:36:59 <ski_> (mercury^ : and `infix' ..)
13:37:05 <mercury^> mreh: you can use `bleh' in sections
13:37:08 <mreh> it's my own version of concatonate for two data types
13:37:14 <mercury^> err, `bleh`
13:37:14 <mreh> oh okay
13:37:26 <augustss> pumpkin: is everything evaluated?  no closures around?
13:37:37 <rwbarton> pumpkin: are you talking about memory usage or size of Data.Binary output?
13:38:09 <pumpkin> rwbarton: size of Data.Binary output... the memory usage is pretty epic in between (but I'm pretty sure that's just the CSV parsing, which is why I'm trying to avoid it by writing the parsed file as binary)
13:38:21 <pumpkin> augustss: don't think so... what should I look out for?
13:38:43 <pumpkin> I could just rnf it before sticking it in?
13:38:45 <rwbarton> pumpkin: I don't know for sure how Data.Binary represents Doubles
13:38:56 <augustss> Not sure.  How are you measuring the size btw?
13:39:08 <pumpkin> writing it to a file and looking at the file size
13:39:18 <pumpkin> using encodeFile
13:39:59 <augustss> Oh, I see.  It's not heap size you're talking about.
13:40:16 <pumpkin> yeah, the heap size is enormous
13:40:34 <pumpkin> way larger than 116 MB :)
13:40:55 <augustss> Hmmm, sounds large for file size.  But I don't know how Data.Binary encodes things.
13:41:08 <pumpkin> I get the impression bytestring csv wasn't designed with large CSV files in mind (this one's around 40 MB)
13:41:27 <pumpkin> I am surprised to find that my binary encoded version of that CSV is larger than the CSV though
13:41:35 <pumpkin> given that the CSV is representing these are large doubles with lots of digits
13:41:43 <pumpkin> in decimal
13:41:58 <Lemmih> @seen mae
13:41:58 <lambdabot> mae is in #xmonad and #haskell. I last heard mae speak 19h 56m 22s ago.
13:42:16 <pumpkin> *as
13:42:54 <mpwd_> Hmm... anyone know a quick 1-liner that generates the list of all forests of four elements?
13:43:17 <Olathe> What's a forest of four elements ?
13:43:26 <pumpkin> mpwd_: what representation?
13:43:43 <mpwd_> pumpkin: Doesn't matter.  I guess (,) would be intuitive
13:43:48 <pumpkin> hmm
13:43:52 <rwbarton> pumpkin: Data.Binary seems to use 25 bytes to store a Double
13:43:54 <tromp__> give one example of a forest
13:43:58 <pumpkin> rwbarton: holy crap :P
13:44:14 <pumpkin> I might as well just save it as CSV with each character tripled
13:45:21 <augustss> rwbarton: wow!  that's really bad
13:45:27 <pumpkin> anything that stores it in a plain ol' IEEE 754 format?
13:45:39 <Heffalump> how many bytes does it use to store 2 Doubles?
13:45:51 <mpwd_> tromp__: It's a list of trees
13:45:52 <Heffalump> it just stores the decodeFloat output, doesn't it?
13:45:56 <Olathe> We can check.
13:46:01 <jonaskoelker> tromp__: []
13:46:22 <jonaskoelker> :P
13:46:37 <rwbarton> Heffalump: 58
13:46:54 <Heffalump> rwbarton: umm?
13:47:01 <pumpkin> 83 for 3 floats
13:47:02 <Heffalump> I thought Data.Binary didn't have overhead for things like tuples.
13:47:03 <rwbarton> Heffalump: to store a list
13:47:06 <Heffalump> oh, right.
13:47:08 <augustss> I guess storing the decodeFloat output is nice and portable.
13:47:11 <rwbarton> Heffalump: Sorry, will try a tuple
13:47:19 <Olathe> > fst.head.dropWhile (not.snd).zip [1..].map (\n -> fromIntegral (2^n + 1) == (fromIntegral (2^n) :: Float)) $ [1..]
13:47:20 <Heffalump> augustss: yes, that's the idea
13:47:20 <lambdabot>   24
13:47:26 <rwbarton> Heffalump: Yeah, 50 for the (Double, Double)
13:47:26 <vineet> mpwd_: is the powerset what you're looking for?
13:47:40 <Heffalump> @type decodeFloat
13:47:42 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
13:47:47 <Heffalump> so what does an Integer take?
13:47:55 <rwbarton> variable I suppose
13:48:09 <rwbarton> the Integer 3 takes 5 bytes
13:48:22 <Heffalump> ok, then I still don't understand what Double is storing.
13:48:39 <vineet> mpwd_: e.g. [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4],[2],[3,4],[3],[4],[]]
13:48:40 <pumpkin> anyone have any suggestions? I'm just trying to do some fairly computationally intensive data processing and these memory requirements are killing me... parsing the CSV takes over 1G for some of my csv files (the CSV itself is only 70 MB)
13:48:42 <augustss> Heffalump: the Integer is typically very big for a Double
13:48:50 <augustss> > decodeFloat 1
13:48:52 <lambdabot>   (4503599627370496,-52)
13:48:52 <Heffalump> oh, yeah.
13:49:01 <Heffalump> I was incorrectly assuming it'd fit in 32 bits
13:49:19 <EvilTerran> ... that's kinda unfortunate
13:49:34 <augustss> if isIEEE is true then you could store in a more efficient way.
13:49:50 <Heffalump> augustss: that's still not portable
13:49:55 <Heffalump> isIEEE might not be true on the reading end
13:50:07 <augustss> Heffalump: then you convert, it's simple
13:50:16 <Olathe> > fst.head.dropWhile (not.snd).zip [1..].map (\n -> 2.0^n == 2.0^(n + 1) :: Float)) $ [1..]
13:50:17 <Heffalump> then why not convert when storing too?
13:50:17 <lambdabot>   <no location info>: parse error on input `)'
13:50:18 <pumpkin> someone could still just write an IEEE 754 reader on the other end to convert to whatever's native
13:50:27 <Olathe> > fst.head.dropWhile (not.snd).zip [1..].map (\n -> 2.0^n == 2.0^(n + 1) :: Float) $ [1..]
13:50:29 <lambdabot>   Couldn't match expected type `Float' against inferred type `Bool'
13:50:36 <Olathe> > fst.head.dropWhile (not.snd).zip [1..].map (\n -> 2.0^n == (2.0^(n + 1) :: Float)) $ [1..]
13:50:37 <lambdabot>   128
13:50:46 <rwbarton> Doubles might not be in base 2 on the reading end!
13:50:47 * rwbarton ducks
13:50:51 <Olathe> > fst.head.dropWhile (not.snd).zip [1..].map (\n -> 0.5^n == (0.5^(n + 1) :: Float)) $ [1..]
13:50:51 <colouragga> RayNbow: :)
13:50:52 <lambdabot>   150
13:50:54 <augustss> Heffalump: you don't want to loose precision when storing, so you'd have to know it fits in an IEEE Double
13:51:04 <tromp__> so a forest is a cycle free map from 1..n into 0..n ?
13:51:13 <augustss> Heffalump: which you could figure out
13:51:19 <Heffalump> couldn't you figure that out by inspecting the values^Uyeah
13:51:31 <pumpkin> any practical suggestions? :/
13:51:38 <Olathe> > map (0.5^) [149..151]
13:51:40 <lambdabot>   [1.401298464324817e-45,7.006492321624085e-46,3.503246160812043e-46]
13:51:42 <pumpkin> should I write my own binary encoder/decoder from scratch?
13:51:51 <augustss> Heffalump: given that everything these days is IEEE I think a special case would be good.
13:51:52 <vixey> no
13:51:58 <Olathe> > map (0.5^) [149..170]
13:51:59 <lambdabot>   [1.401298464324817e-45,7.006492321624085e-46,3.503246160812043e-46,1.751623...
13:52:12 <Heffalump> I did try to persuade Duncan of this a while ago. He wasn't very keen.
13:52:14 <Olathe> Ahh.
13:52:26 <Olathe> > fst.head.dropWhile (not.snd).zip [1..].map (\n -> show (0.5^n) == show (0.5^(n + 1) :: Float)) $ [1..]
13:52:27 <lambdabot>   1075
13:52:38 <Olathe> > fst.head.dropWhile (not.snd).zip [1..].map (\n -> show (2.0^n) == show (2.0^(n + 1) :: Float)) $ [1..]
13:52:40 <lambdabot>   1024
13:52:52 <augustss> Heffalump: 25 bytes for a Double is ludicrous
13:53:10 <pumpkin> vixey: what are my options? I'm processing what should take around 30-40MB of RAM in doubles... and the whole shabang is using more than a gig before I even start doing anything interesting :/
13:53:42 <sioraiocht> pumpkin: using unboxed values
13:53:45 <EvilTerran> pumpkin, custom de-serialisation from bytestrings?
13:53:47 <pumpkin> sioraiocht: already am
13:54:04 <pumpkin> EvilTerran: that's what I was asking but vixey said no (I think it was to me, but maybe not)
13:54:06 <sioraiocht> pumpkin: how are you unboxing them? sometimes the compiler is stubborn
13:54:11 <rwbarton> sioraiocht: the problem is with Data.Binary using 25 bytes to store a Double
13:54:20 <sioraiocht> ah
13:54:28 <pumpkin> sioraiocht: I'm using UArray to store to disk, and UArr to actually do work in memory
13:54:28 <sioraiocht> that's what i get for coming part way into a convo
13:54:38 <walski> Hm, how do I tell Haskell to recognize that the a in this: "containsAll :: Ord a => Set a -> Set a -> Bool" can be "shown" (show a) ;)
13:54:41 <augustss> pumpkin: parse it line by line and stick each line in an unboxed array
13:54:53 <sioraiocht> walski: (Ord a, Show a) =>
13:55:00 <walski> thanks
13:55:05 <Olathe> @type show
13:55:06 <lambdabot> forall a. (Show a) => a -> String
13:55:15 <pumpkin> augustss: the original CSV you mean?
13:55:17 <wli> Mulptiple precision can go beyond Double, e.g. quad precision, but I doubt you mean that.
13:55:18 <pumpkin> I guess it has to be
13:55:21 <augustss> pumpkin: yes
13:55:27 <pumpkin> hmm, okay
13:55:28 <Lemmih> walski: (Show a, Ord a) =>
13:55:47 <augustss> pumpkin: and make sure you force the line parsing before going to the next line.
13:55:52 <Saizan_> walski: most of the times you can just comment out the type signature and ask ghci to infer one for you, and paste it back
13:55:53 <pumpkin> augustss: would it be stupid to just stick "[" ++ line ++ "]" and try to read that?
13:55:58 <pumpkin> rather than doing it by hand
13:55:58 <walski> Hm: http://hpaste.org/13764
13:56:08 <walski> This is the error I get now :/
13:56:09 <augustss> pumpkin: seems OK to me
13:56:14 <pumpkin> okay
13:56:20 <augustss> pumpkin: If you know that the data looks like that
13:56:25 <mpwd_> vineet: \
13:56:25 <Deewiant> hah, Data.Binary uses the decodeFloat representation as the storage format
13:56:28 <pumpkin> yeah, it's just plain CSV
13:56:29 <Deewiant> no wonder
13:56:35 <rwbarton> walski: you're trying to show a 'Set a', not an 'a'
13:56:39 <pumpkin> augustss: but then I have no bytestrings, is that wise?
13:56:40 <Heffalump> Deewiant: we just said that
13:56:54 <rwbarton> walski: so, you need to write a Show instance for Set most likely
13:56:55 <Deewiant> Heffalump: I didn't see it so I figured I'd laugh at it myself
13:56:57 <augustss> pumpkin: try it
13:56:59 <EvilTerran> ?instances-importing Data.Set Show
13:56:59 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Set a, Sum a, [a]
13:57:00 <walski> hm it is showable
13:57:03 <Guest45143> pumpkin: that doesn't always work for "plain CSV", depends on which "plain" and what your data actually looks like
13:57:09 <pumpkin> augustss: can't hurt any more than the current solution works
13:57:14 <walski> so if I do show with a set in GHCI it works
13:57:22 <walski> just derives from "Show" ;)
13:57:26 <pumpkin> Guest45143: true, but it does look like a Show of list minus the brackets :)
13:57:39 <pumpkin> okay, time for epic experiment
13:57:39 <Guest45143> pumpkin: ok
13:57:49 <rwbarton> walski: hmm
13:57:54 <sioraiocht> hrm,
13:57:54 <Guest45143> btw, yitz here. having some nick trouble.
13:57:55 <rwbarton> walski: maybe the error is coming from somewhere else then
13:58:01 * sioraiocht desparately needs to release source code next week
13:58:10 <walski> rwbarton: ok :/
13:58:26 <bos> sioraiocht: yes you do! :-)
13:58:44 <sioraiocht> bos: I just got back from the Caribbean this morning, I'm on the case :)
13:58:51 <bos> awright mate
13:59:20 <Heffalump> source for what?
14:00:18 <pumpkin> @src ($!)
14:00:18 <lambdabot> f $! x = x `seq` f x
14:02:31 <pumpkin> is there an elegant way to make map (\line -> read $ "[" ++ line ++ "]") strict? I don't think replacing $ with $! will have any effect in this case, right? it'll just force the string to evaluate?
14:03:39 <pumpkin> should I just rnf at each step? that feels kinda dirty
14:03:47 <olsner> pumpkin: can't you just write [read line]?
14:04:10 <gsan> Hello all! Does any of you get a "Segmentation fault" while running programs compiled with GHC-6.10.1 with the -G3 RTS option?
14:04:16 <pumpkin> olsner: I need the square brackets on the ends
14:04:19 <pumpkin> or you mean using a list comprehension?
14:04:35 <yitz___> am i yitz
14:04:41 <yitz___> sort of...
14:04:48 <olsner> do you have your own read instance that parses '[' and ']'?
14:04:59 <walski> good night
14:04:59 <pumpkin> olsner: nope, I'm abusing the read of [Double]
14:05:14 <olsner> oh, is it a comma-separated string in line? I see
14:05:17 <pumpkin> yeah
14:05:29 <pumpkin> just trying to parse CSV myself, but want to force it to evaluate
14:05:43 <olsner> isn't there a CSV module on hackage somewhere?
14:06:09 <pumpkin> yeah, that's what I was using, but it's using up enormous amounts of memory that shouldn't be necessary
14:06:19 <pumpkin> both the String and the ByteString ones
14:08:03 <rwbarton> pumpkin: if you store the result of that read in a UArray, you shouldn't have any strictness problems
14:08:19 <yitz___> has my nick really been hijacked, or is there something wrong that i can fix? how do i check that?
14:08:21 <pumpkin> ah true
14:09:16 <yitz___> anyone know anything about irc?
14:09:25 <Heffalump> ahah, we can all abuse dcoutts about Data.Binary and Double :-)
14:09:59 <yitz___> @seen yitz
14:09:59 <lambdabot> I saw yitz leaving #haskell 9h 30m 6s ago, and .
14:10:19 <pumpkin> :)
14:10:41 <rwbarton> Data.ByteString.Lazy.unpack . runPut $ put (3 :: Double)
14:10:42 <rwbarton> [1,1,0,0,0,0,0,0,0,7,0,0,0,0,0,0,24,255,255,255,255,255,255,255,205]
14:10:45 <mercury^> yitz___: freenode supports killing the perpetrator if you registered your nick
14:10:51 <dcoutts> Heffalump: mm?
14:11:07 * dcoutts forgets what we did about double
14:11:10 <Heffalump> there's a general feeling that 25 bytes is excessive when the IEEE encoding could be used in most cases
14:11:16 <Heffalump> you use the decodeFloat result
14:11:25 <dcoutts> ah, so we went for the portable approach
14:11:38 <yitz___> mercury^: ok. is that what's really happening? how do i chuck them then?
14:11:52 * dcoutts couldn't remember which way we decided in the end
14:11:56 <Heffalump> the point is that IEEE encoding is well defined and so also portable, if you have an escape hatch too
14:12:00 <mercury^> yitz___: /msg nickserv ghost [nick] [password]
14:12:06 <mercury^> yitz___: or sth like that
14:12:14 * yitz___ tries it
14:12:22 <dcoutts> Heffalump: as I recall the problem is that we cannot decode IEEE on platforms that do not do IEEE natively
14:12:32 <Heffalump> oh, how come?
14:12:42 <augustss> dcoutts: it's just some bit twiddling
14:13:13 <dcoutts> Heffalump: there's no equivelent of decodeFloat that goes to/from IEEE <-> Double
14:13:24 <Heffalump> it's not hard to implement manually
14:13:29 <dcoutts> augustss: great, if someone can write that then we can do it
14:13:32 <augustss> Just view the IEEE format as a compact way to store the output of decodeFloat
14:13:45 <Heffalump> I'm sure I offered you my code to do that a while ago and you refused :-)
14:13:55 <dcoutts> Heffalump: really? I don't recall that
14:13:56 <Heffalump> when I was complaining about having to decode from binary file formats by hand
14:14:00 <Heffalump> I might be misremembering.
14:14:15 <Heffalump> or it might have been Lennart (Kolmodin) I was speaking to
14:14:20 <dcoutts> Heffalump: seems to me if we can make it portable and in the good case fast too then that's ideal
14:14:38 <dcoutts> Heffalump: the problem was we thought we could not make it both fast and portable
14:14:47 <yitz> am i yitz now?
14:14:48 <augustss> pumpkin: the problem with read is that the generic read for Double is extremely slow :(
14:14:54 <yitz> yay! thanks mercury^ !
14:14:58 <pumpkin> augustss: boo hoo hoo :(
14:15:07 <dcoutts> Heffalump: so the next practical problem is changing the format for old files, we've got no solution to that atm
14:15:20 <yitz> mercury^: perhaps i should change my password now to be safe. how do i do that?
14:15:30 <dcoutts> Heffalump: perhaps we can do it at a major API break and tell users the format is not the same
14:15:38 <mercury^> yitz: you don't have to change the password.
14:15:52 <pumpkin> dcoutts: the encoding doesn't have some versioning scheme in those 25 bytes anywhere? :P
14:16:05 <pumpkin> I would hope it stored every version of Data.Binary ever released
14:16:06 <mercury^> But if you want to, I think the command is `password new old old'
14:16:09 <pumpkin> for something that size :)
14:16:10 <Heffalump> are any bits wasted in the list constructor encoding?
14:16:19 <Heffalump> Is each constructor one byte rather than one bit?
14:16:35 <gsan> Uh, I just found another bug (other than my program segfaulting with +RTS -G3). When I compile "main = forever $ print $ sum [1 .. 100000]", it crashes saying "internal error: schedule: invalid what_next field" after a few iterations...
14:16:35 <dcoutts> pumpkin: it's hard to do in the low level layer, you really want that kind of meta-data at the beginning of a data stream
14:16:36 <yitz> mercury^: as a msg to nickserv?
14:16:38 <karan> Heffalump, tigger ftw
14:16:45 <pumpkin> dcoutts: true :/
14:16:49 <Saizan_> pumpkin: you want HAppS.Data.Serialize :)
14:16:52 <dcoutts> Heffalump: yes it's all byte aligned
14:16:59 <Heffalump> ok, so 2 is available :-)
14:17:13 <dcoutts> Heffalump: I don't see how that helps
14:17:18 <Heffalump> then it's just a backwards compatibility issue, not a complete change
14:17:33 <Heffalump> you can still read old files with the new code that way
14:17:34 <pumpkin> Saizan_: it does things smartly? all I really want to be able to do is load and save a reasonable number of doubles efficiently
14:17:40 <pumpkin> without having to parse CSV each time
14:18:11 <augustss> pumpkin: it took 5 minutes to parse the file size you want :(
14:18:15 <Saizan_> pumpkin: it's a layer above Data.Binary.Get/Put iirc
14:18:23 <pumpkin> Saizan_: ah
14:18:32 <Saizan_> pumpkin: i was referring to the versioning
14:18:46 <pumpkin> augustss: yeah, I'm getting a couple of minutes even on the ByteString CSV thing which gives me all strings
14:18:50 <Saizan_> so maybe you don't want it at all
14:18:58 * pumpkin cries
14:19:05 <dcoutts> Heffalump: but there being space in the list cons stuff doesn't help for decoding double / float
14:19:11 <pumpkin> I have so much nice data processing code
14:19:30 <Heffalump> oh, duh
14:19:40 <Heffalump> for some reason I convinced myself a list was involved
14:19:48 <Heffalump> how about in the Integer encoding?
14:20:18 <Heffalump> that is either just an Int or an Int + gmp stuff, right? So there still ought to be a 2 available.
14:21:14 <pumpkin> so in my situation, what would Oleg do?
14:21:49 <dcoutts> Heffalump: yes, so for Integer there is flexibility, oh I see so you want to use that because we encode the Double into Integers
14:22:01 <Heffalump> right
14:22:14 <Heffalump> we just need to find some unused bitpattern
14:22:25 <dcoutts> Heffalump: honestly I'm not sure that it's the right layer to add this kind of forwards/back compat
14:22:31 <yitz> pumpkin: ask what dons would do
14:22:33 <Heffalump> that may well be ture
14:22:37 <Heffalump> s/ture/true/
14:22:46 <pumpkin> what would dons do in my situation?
14:22:48 <Heffalump> anyway, bedtime for me
14:22:51 <dcoutts> Heffalump: I don't think we've got the binary stuff factored right yet
14:23:01 <Heffalump> I hope noone is relying on the file format then :-)
14:23:27 * yitz hopes that dons will now respond
14:24:09 <dons> mm??
14:24:09 <pumpkin> Heffalump: did you happen to notice how much memory your thing used for that CSV?
14:24:33 <dons> what's the question, sorry?
14:24:38 <yitz> dons: thanks! pumpkin is trying to parse a 70MB csv full of doubles.
14:24:50 <pumpkin> even a 40MB is almost unmanageable
14:24:52 <dons> oh, using the bytestring-lexing and csv packages?
14:25:00 <pumpkin> dons: yup yup
14:25:01 <dons> i was parsing gigabyte csv files with that lib.
14:25:05 <pumpkin> :o
14:25:24 <pumpkin> I was getting pretty huge memory usage... maybe I'm just doing something wrong
14:25:24 <dons> if you can put the sample input somewhere, and the code, i can have a look.
14:25:28 <dons> yeah, maybe.
14:25:37 <dons> parsing with bytestrings is one of the few things we know to be fast :)
14:25:46 <pumpkin> dons: it's not so much the speed as the memory usage
14:25:55 <pumpkin> exceeding my poor macbook air's capacity
14:25:57 <dons> sure. stick the code and some sample data somewhere.
14:27:33 <mmorrow> what's a good cms/whatever with a web interface that can properly deal with sensitive (financially) information properly (both from other users and from the outside internet) and is suitable to be put on the public internet?
14:27:56 <mmorrow> (sry offtopic)
14:28:07 <dons> mm
14:28:18 <dons> sounds like something that might not be available
14:28:21 <dons> how sensitive?
14:28:52 <mmorrow> just needs to be encrypted in-transit and protected from other users, nothing special.
14:29:10 <yitz> mmorrow: can we move to #haskell-blah?
14:29:28 <mmorrow> yitz: sure
14:29:47 <pumpkin> dons: sorry for the delay, just trying to cut out the cruft and give you a minimal test case
14:30:56 <dons> sure. no rush.
14:31:18 <augustss> pumpkin: OK, so I can do it in about 1 minute and maximum heap of 85M
14:31:31 <pumpkin> augustss: I'm probably just doing it wrong then :)
14:31:50 <augustss> pumpkin: but I'm calling C to do the string->double conversion
14:33:39 <pumpkin> augustss: doubt that would increase my memory that much :) I'm probably just leaving something to evaluate lazily
14:33:43 <pumpkin> I just can't find it :/
14:33:46 <augustss> pumpkin: http://hpaste.org/13768
14:33:47 * pumpkin is a noob :(
14:37:03 <pumpkin> dons: http://pumpkinpat.ch/minimal.zip have pity on me, for I am but a noob :(
14:38:23 <dons> ByteString -> Double is in the bytestring-lexing package, fwiw, lennart
14:38:53 <pumpkin> how does it compare to atof?
14:39:32 <bos> hi jsgf
14:39:37 <ztirF> what do you need to import for foldl' again
14:39:42 <pumpkin> Data.List
14:39:44 <dons> my_strtod :: ByteString -> Double
14:39:44 <dons> my_strtod b = inlinePerformIO $ B.useAsCString b $ \ptr -> c_strtod ptr nullPtr
14:39:44 <dons> {-# INLINE my_strtod #-}
14:39:44 <dons> foreign import ccall unsafe "stdlib.h strtod"  c_strtod :: CString -> Ptr CString -> IO Double
14:39:48 <Saizan_> ?index foldl'
14:39:49 <lambdabot> Data.List
14:39:56 <ztirF> thanks
14:42:33 <augustss> pumpkin: if you take my code and switch to lazy bytestrings you can probably speed it up some
14:43:09 <dons> well, for 70M, you could just use bytestring-csv plus that double parser, and be done.
14:43:50 <waterson> is it still the case that HDBC only supports MySQL through ODBC?
14:44:31 <dons> waterson: i believe so.
14:44:46 <augustss> is there a bytestring-csv?
14:44:55 <dons> yeah
14:45:09 <dons> http://hackage.haskell.org/packages/archive/bytestring-csv/0.1.2/doc/html/Text-CSV-ByteString.html
14:45:20 <waterson> dons: gotcha -- thanks. nice book, btw. lots of "a ha!" moments for me ;)
14:45:24 <dons> cool!
14:45:28 <augustss> Good.  But disgusting.
14:45:32 <dons> :)
14:45:50 <augustss> There should only be one CSV package, overloaded in the string type.
14:45:53 <pumpkin> CSV disgusts me too :P
14:45:54 <pumpkin> oh
14:46:08 <dons> we'd need a stringable class with enough guts
14:46:15 <augustss> dons: yes
14:46:35 <augustss> I really dislike all this code duplication that all the different string types force upon us.
14:46:53 <pumpkin> but I thought typeclasses made things slow?
14:46:59 <pumpkin> (oversimplification)
14:47:05 <dons> pumpkin: no. not really.
14:47:18 <pumpkin> oh okay :)
14:47:26 <Saizan_> maybe for things like these we should only have the ByteString version, given how simple is to pack/unpack
14:47:27 <augustss> pumpkin: not if the compiler specializes the code
14:47:43 <pumpkin> does anything jump out at you in my horrible code as being the culprit of the huge memory consumption?
14:47:46 <byorgey> compilers++
14:47:53 <augustss> Saizan_: but there are different kins of ByteString
14:48:10 <pumpkin> and I really like the unicode-awareness of String
14:48:19 <pumpkin> and like that it's the default :P
14:48:23 <pumpkin> despite the speed
14:48:32 <augustss> unicode is a must, I'd say
14:48:40 <Saizan_> for the external world you've to choose an encoding anyway
14:49:01 <pumpkin> yeah, but you shouldn't be operating in an encoding, you should encode to one, I'd think
14:49:17 <Saizan_> totally
14:50:30 <Saizan_> but overloading doesn't help there, unless you have the encoding in the type
14:51:17 <pumpkin> augustss: I might just use your code, but I'd really like to know what I'm doing wrong in mine... it's not pretty code but I thought I was being relatively safe
14:52:18 <dons> pumpkin: i'm looking at it now.
14:52:26 <pumpkin> dons: thanks a lot :)
14:52:32 <dons> csvToLabel = map $ read . C8.unpack . head
14:52:42 <pumpkin> bad?
14:52:48 <pumpkin> well badder than I thought it was
14:52:48 <dons> yes. never unpack a bytestring
14:53:05 <dons> csvToDouble = map (map (maybe 0 fst . readDouble))
14:53:08 <dons> looks iffy.
14:53:16 <ddarius> Don't most languages just specialize on a single "string" type.
14:53:17 <pumpkin> I just wanted to get rid of the NaNs in my data :P
14:53:30 <dons> anyway, checking...let's see.
14:53:36 <pumpkin> dons: the CSV has a few NaNs written that way in the actual text
14:53:41 <dons> ok.
14:54:12 <pumpkin> dons: but yeah, I'd appreciate any suggestions (short of stop coding and chop of your fingers now for the benefit of humanity)
14:54:14 <eu-prleu-peupeu> helloo
14:54:22 <dons> its short enough we can solve this :)
14:54:32 <eu-prleu-peupeu> i want to become a l33t haskell programmer, what do i need to do ?
14:54:38 <mmorrow> in case anyone might find this useful, (i need a way to securely give users an interface to pdfs of image and have each user's data be secure from other users, and i need this _fast_) looks like  http://plone.org/about/security/overview/security-overview-of-plone  has the least suck.
14:54:47 <dons>  eu-prleu-peupeu you always ask this.
14:54:48 <ddarius> eu-prleu-peupeu: Start using proper grammer, diction, and punctuation.
14:54:53 <dons> and i always say: write some code.
14:54:57 <pumpkin> grammer? :P
14:55:05 <ddarius> pumpkin: I didn't include spelling.
14:55:13 <pumpkin> troo :)
14:55:35 <yitz> eu-prleu-peupeu: read RWH, do all the exercises, then come back and ask again.
14:55:39 <LoneTech> I'm still having trouble thinking about folds.
14:55:47 <pumpkin> LoneTech: Cale has some good diagrams of them
14:55:59 <dons> pumpkin: sure leaks memory.
14:56:02 <eu-prleu-peupeu> dons: yes... im finding it hard to become a l33t in haskell :/
14:56:08 <dons> eu-prleu-peupeu: are you writing haskell code?
14:56:12 <eu-prleu-peupeu> yes
14:56:12 <pumpkin> dons: you're telling me! :P you think it's the unpacking?
14:56:20 <dons> not sure. investigating.
14:56:24 <pumpkin> LoneTech: http://cale.yi.org/index.php/Fold_Diagrams
14:56:41 <LoneTech> thanks
14:56:43 <ddarius> eu-prleu-peupeu: Expecting to become a "l33t haskell programmer" over the course of a weekend?
14:56:47 <Saizan_> > foldr f z [a,b,c]
14:56:49 <lambdabot>   f a (f b (f c z))
14:56:51 <pumpkin> eu-prleu-peupeu: you need a PhD in getting PhDs to be l33t in haskell, btw
14:56:53 <Saizan_> > foldl f z [a,b,c]
14:56:54 <lambdabot>   f (f (f z a) b) c
14:57:02 <eu-prleu-peupeu> it shouldn't be necessary
14:57:08 <dons> eu-prleu-peupeu: have you written any haskell yet?
14:57:14 <yitz> pumpkin: you don't really
14:57:16 <eu-prleu-peupeu> dons: yes yes
14:57:21 <dons> you keep asking these questions, but not writing any code :/
14:57:38 <LoneTech> right now I work on a function that processes a list, and I want it to be efficient. It's pretty much a map, but for every item, it needs to see the closest n, too.
14:57:41 <eu-prleu-peupeu> i will write lots of haskell code, starting this month :)
14:57:49 <pumpkin> yitz: I was being silly :P I can't be serious when suggesting getting a PhD in getting PhDs :) but yeah, IRC isn't good on my silliness
14:58:00 <LoneTech> atm I do this with a recursion and a list of neighbouring values
14:58:04 <yitz> pumpkin: ok i know :)
14:58:14 <eu-prleu-peupeu> is there any haskell hackatons ? (like in bsd)
14:58:18 <dons> yeah
14:58:36 * LoneTech wanders off to read diagrams
14:58:39 <eu-prleu-peupeu> is there any being planned in the near future ?
14:59:48 <dons> pumpkin: i think it is just parseCSV that is doing its thing here.
15:00:00 <dons> it is parsing your 70M file into a linked list of values. that's going to take up space.
15:00:08 <hml> has the laval project been a success? (haskell for fpgas); i'm thinking of something similar
15:00:25 <Saizan_> LoneTech: you could also paste a code snippet on hpaste.org
15:00:29 <dons> hml: yes.
15:00:31 <eu-prleu-peupeu> i guess im too lazy for haskell -_-
15:00:41 <pumpkin> eu-prleu-peupeu: don't worry, haskell's too lazy for you too :P
15:01:02 <pumpkin> dons: but I thought even in the worst case, each cell would take up 16 bytes (I'm on a 32-bit machine), which still wouldn't explain how big the memory use is :/
15:01:18 <pumpkin> anyway, I'll try making it into a UArr(ay) and see how much that helps
15:01:36 <yitz> pumpkin: you need the entire thing in memory?
15:01:51 <pumpkin> yitz: nope!
15:01:55 <pumpkin> :P
15:02:20 <Saizan_> then explain that to the RTS :)
15:03:04 <pumpkin> -- hey RTS, wouldja mind doing the right thing here, please? thanks!
15:03:07 <eu-prleu-peupeu> how does the name "zaqueu" sounds in english ?
15:03:24 <pumpkin> eu-prleu-peupeu: I'd be moderately less confused at how to pronounce it than your current nick
15:04:00 <dons> hm. maybe it isn't parseCSV actually...
15:04:01 <eu-prleu-peupeu> eheh
15:04:05 <eu-prleu-peupeu> ok, thanks
15:04:15 <roconnor> what does "class Monad (m Maybe) => C m where" mean?
15:04:23 <pumpkin> dons: btw, my 520 MB for the 40MB CSV was with -O2
15:04:28 <eu-prleu-peupeu> ill start by doing some works with haskell, and write them out in a blog... maybe called zaqueu
15:04:29 <pumpkin> didn't try any other options like -threaded and so on
15:04:38 <dons> no no.
15:04:51 <roconnor> is the kind of m in that case * -> * -> * ?
15:04:53 <pumpkin> just giving you all the info, I realized I didn't include how I built it in the zip
15:04:56 <ddarius> roconnor: It should mean "syntax error".
15:05:06 <Saizan_> roconnor: (* -> *) -> something
15:05:13 <roconnor> ddarius: cafe thread says this is haskell 98
15:05:31 <dons> yeah, parseCSV simply constructs a  638 MB list from the 40M csv bytestring
15:05:34 <roconnor> Saizan_: how do you figure?
15:05:34 <LoneTech> ok, I did a hpaste of the function as it is now at http://hpaste.org/13769
15:05:38 <Saizan_> ah, no, (* -> *) -> * -> *, sine Monad is for (* -> *
15:05:47 <dons> lots and lots of tiny bytestring ForeignPTrs
15:06:06 <roconnor> Saizan_: ah right.
15:06:23 <Saizan_> so, m is a monad transformer
15:06:41 <roconnor> Saizan_: okay, the variable name confused me.  I figured type variables with a name like m should have kind * -> *.
15:06:46 <Saizan_> in spirit at least
15:07:03 <roconnor> certainly with all the Monad's hanging around
15:07:09 <roconnor> in that context
15:07:12 <Saizan_> yeah, 't' is usually the variable for transformers
15:07:16 <ddarius> Ohh, I parsing it all wrong
15:07:23 <pumpkin> dons: yeah, that sounds bad :) 4966479 little bytestrings I guess?
15:07:27 <sjanssen> http://www.cs.chalmers.se/~hallgren/wwwbrowser.html interesting!
15:07:27 <ddarius> and losing my ability to speak.
15:07:51 <dons> pumpkin: i think it is expected though. [[ByteString]] isn't space efficient. but its simple.
15:08:28 <pumpkin> dons: yeah, that makes sense... I was just hoping they'd be magically consumed by the lexer and made into pretty 8-byte doubles, rather than sticking around in memory as bytestrings
15:08:59 <dons> they do get deallocated, and then you have a really big [[Double]]
15:09:49 <pumpkin> so a pair-indexed UArray of them would be better I guess?
15:09:57 <pumpkin> or the fused UArr?
15:10:04 <pumpkin> not sure I can make that 2d though
15:10:28 <dons> do you have to keep the entire 2D table in memory?
15:10:33 <dons> or are you building it only to consume it?
15:10:50 <pumpkin> yeah, just consuming it
15:11:02 <pumpkin> I was crossing my fingers for haskell to just make it consume as I eat it
15:11:06 <pumpkin> I mean as I produce it :)
15:11:08 <dons> mm
15:11:22 <pumpkin> I need one column at a time really
15:11:27 <dons> parseCSV should be lazier
15:11:29 <LoneTech> Saizan_: I keep thinking it should be doable with a foldr, but I'm not sure how to shape it, yet.
15:11:34 <pumpkin> which means I typically take the transpose of that enormous list of lists, which makes me shudder
15:11:41 <eu-prleu-peupeu> i like haskell, it makes me feel artsy
15:11:48 <pumpkin> eu-prleu-peupeu: glad to hear it
15:11:54 <dons> eu-prleu-peupeu: anything useful to contribute?
15:12:01 <Saizan_> maybe transpose is not lazy enough
15:12:26 <Saizan_> you can probably do better if you know that your matrix is rectangular
15:12:41 <pumpkin> Saizan_: yeah... and not using lists would probably help a lot
15:13:07 <eu-prleu-peupeu> not much, sorry... ill go back to work now :)
15:13:55 <Saizan_> pumpkin: well you're seeking laziness here, so lists should help
15:14:19 <pumpkin> Saizan_: true... hmm
15:17:57 <pumpkin> is it possible to make a Stream of Streams ?
15:18:20 <pumpkin> maybe that's what I want? or maybe I should just get it to not use up ridiculous amounts of memory with lists first, and then think of optimizing it
15:18:44 <grahamhutton> @users
15:18:45 <lambdabot> Maximum users seen in #haskell: 668, currently: 628 (94.0%), active: 23 (3.7%)
15:18:49 <grahamhutton> !
15:18:58 <Saizan_> well, the concrete datastructure doesn't matter much, but you want something that's lazy in the spine, and you've to avoid forcing it needlessly, and make it fuse.
15:19:14 <dons> grahamhutton: yeah :)
15:19:17 <pumpkin> Saizan_: yeah :/
15:19:28 <ddarius> Saizan_: You don't need to have it fuse.
15:19:31 <grahamhutton> it's been a while since I've been on IRC -- numbers have increased a lot!! :-)
15:19:41 <Pseudonym> So who have we overtaken now?
15:20:01 <yitz> Pseudonym: just about everyone
15:20:08 <ddarius> The actual high is 674 or 676 I think.
15:20:10 <Saizan_> ddarius: ah, yeah, right, if the GC does its work
15:20:26 <Pseudonym> We've garbage collected a few users/
15:20:49 <hml> suggestion for RWH: it should tell me how to exit from ghci right before it tells me about 'a simple programm' in chapter 1
15:23:43 <hml> i realize the responses here may be biased; i need to write my own IC tool (research purpose); i'm debating haskell vs scheme/lisp. thoughts?
15:24:22 <dons> haskell has a bigger community and more libs and faster code and an smp runtime
15:24:39 <dons> hml: re. ghci, interesting idea!
15:24:44 <dons> did you work out ^D / :q
15:24:44 <wchogg> Oh no, scheme all the way.  I just use Haskell to be all indie-rock ironic.
15:24:45 <dons> ?
15:24:47 <Olathe> What's an IC tool ?
15:24:50 <dons> wchogg: :)
15:24:58 <StoneToad> lo wchogg
15:25:05 <Pseudonym> ^Z kill %1     <- Usually works for me.
15:25:17 <Elly> wchogg: ever since scheme sold out it's just not the same :(
15:25:31 <hml> nah, i ended up using a killall :-P
15:25:36 <thoughtpolice> hml: haskell does seem to have a bigger and more active community - if you include clojure in that comparison though it gets a lot more interesting :)
15:25:37 <wchogg> Elly : you liked it back when it was underground on Lisp Machines?
15:25:48 <Elly> :)
15:25:52 <Pseudonym> BRB
15:26:07 * ddarius is pretty sure either Scheme's or CL's community is both bigger and more active than Haskell's.
15:26:45 <Elly> "All the haskell programmers in the world would fit on a 747."
15:26:52 * ddarius doesn't think there ever was a Scheme on a Lisp Machine.
15:26:53 <juhp_> hml: chip design?
15:27:02 <wchogg> ddarius : I know but I wanted to make the joke.
15:27:07 <ddarius> Elly: That would have to be a
15:27:07 <hml> juhp_: yeah
15:27:14 <ddarius> -very- big 747.
15:27:19 <juhp_> nod
15:27:20 <Elly> ddarius: "And if it crashed, nobody would notice." ;)
15:27:48 <wchogg> Elly : my family _might_ notice.  I give it 30% odds.
15:27:48 <ddarius> Elly: Well yeah, everybody that cared about Haskell would be dead.
15:28:06 <dons> Elly: i don't think all the #haskell programmers would fit on a 747 would they?
15:28:08 <dons> ?users
15:28:08 <lambdabot> Maximum users seen in #haskell: 668, currently: 631 (94.5%), active: 28 (4.4%)
15:28:11 <yitz> Elly: unfortunately, the avionics on the 747 are not written in Haskell.
15:28:22 <wchogg> dons : if we were _very_ friendly it might be possible
15:28:28 <dons> heh
15:28:36 <ddarius> You take all the seats out and everybody stands up.
15:28:41 <sw17ch> yitz: i just got done with a long conversation with some people at work dealing with putting Haskell onto airplanes :)
15:28:55 <dons> sw17ch: oh?
15:29:04 <StoneToad> ddarius: why not just put seats in the cargo bay?
15:29:15 <ddarius> StoneToad: Why not put people in the cargo bay?
15:29:25 <ddarius> Without seats.
15:29:25 <sw17ch> dons: yes. i'm an aerospace contractor (depending on the project i get put on)
15:29:39 <Elly> the record for people in a 747 is something absurd
15:29:49 <Elly> like 1100 or something
15:29:50 <dons> sw17ch: using haskell, or just considering?
15:29:54 <StoneToad> I'm guessing it's like the record for people in a car
15:30:11 <StoneToad> they all have to sync breathing to fit the last couple guys in
15:30:11 <ddarius> Elly: Did they fly it though?
15:30:18 <yitz> Elly: remind me not to be among them next time they set the record
15:30:18 <Elly> i think so
15:30:22 <Elly> it was an emergency evacuation
15:31:00 <wchogg> Heh, so it wasn't really for kicks then.  That would have been scary.
15:31:04 <Elly> yeah
15:31:13 <Elly> Operation Solomon: 1087 passengers on an El Al 747
15:31:29 <Elly> so you *could* fit all of #haskell on a 747!
15:31:38 <Elly> if you were trying to escape a genocide in ethiopia
15:31:45 <Elly> a genocide of haskell programmers, I guess
15:31:48 <yitz> Elly: ah, that was the Ethiopia thing?
15:31:55 <tromp__> were they all buckled up?
15:32:03 <eyeris> I am trying to figure out why GHC's installPackage.hs would exit with status code 9 (some sort of error, obviously). main calls error, but the error message is not printed out when it exits with status 9. What else could cause a non-0 exit status?
15:32:05 <StoneToad> so, I suggest that we don't ever have a convention with all theworlds haskell programmers then elly
15:32:11 <Elly> yep!
15:32:26 <wchogg> Well we don't all have to take the same flight
15:32:29 <StoneToad> also, we should get worried if people stop chatting one by one
15:32:32 <pumpkin> dons: so nothing really obvious I'm doing wrong? I just happen to have a lot of data and lists have a lot of overhead?
15:32:50 <StoneToad> cause maybe there's a secret antihaskell group assassinating everyone slowly
15:33:09 <Elly> that would be bad
15:33:42 * ddarius will just replace the dead people with bots.  No one will ever notice.
15:33:57 <StoneToad> I'd trigger a ping timeout now for effect, but it's more effort then I feel like spending :)
15:33:58 <pumpkin> @quote wango
15:33:58 <lambdabot> wango says: do you like turing complete?
15:33:59 <Elly> more and more lambdabots will appear!
15:37:49 <dons> pumpkin: yes, there's nothing you're doing wrong.
15:39:35 * thoughtpolice thinks he's going to use the fancy llvm bindings for a compiler he's writing.
15:39:48 <thoughtpolice> need to output ASM directly, but opt+llc == win :)
15:40:26 <wchogg> sounds cool
15:40:54 <thoughtpolice> at the very least it will get me up and running way faster I hope
15:41:26 <baaba> @hoogle monad (->)
15:41:26 <lambdabot> Warning: Unknown type ->
15:41:26 <lambdabot> Control.Applicative unwrapMonad :: WrappedMonad m a -> m a
15:41:26 <lambdabot> Control.Applicative empty :: Alternative f => f a
15:41:33 <pumpkin> dons: alright, I'll try to slim it down in other ways then :(
15:41:50 <pumpkin> @docs Array
15:41:50 <lambdabot> Array not available
15:42:06 <EvilTerran> @docs Data.Array
15:42:06 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
15:47:12 * loadquo tries to learn to love the let...in syntax
15:47:43 <Botje> oh, you will :)
15:47:45 <monochrom> At least you can try to love the where syntax :)
15:48:46 <loadquo> I already like the where syntax. The let... in does seem to have some advantages, so I should try and not completely avoid coding in it.
15:55:24 <mercury^> Saizan_: Do I?
15:55:44 <Saizan_> mercury^: i hope so!
15:56:21 * Saizan_ now thinks Mercury is a pretty slow language
15:56:59 <yitz> pumpkin: just a thought. are you compiling -O2?
15:57:59 <mercury^> Saizan_: I was busy solving decision problems.
15:58:51 <mercury^> With answers like the one I gave you.
15:59:19 <user317> does anyone know what program typically provides ph?  the commandline tool for querying users
16:01:55 <Boney> Saizan_: I work on mercury.  We beleive that it's faster than Haskell :-)
16:02:10 <dons> Boney: do you have any numbers to back that up? ;)
16:02:22 <Boney> dons: Zoltan might.
16:02:32 * dons bets GHC has had more corner cases optimised, and more optimisation work
16:02:35 <Boney> I havn't tested this myself.
16:02:48 <Boney> Yeah,  GHC has many more man-years of work.
16:03:08 <Boney> and alot of work trying to make thunks inexpensive.
16:03:10 <dons> Pseudonym might know.
16:03:24 <dons> well, thunks are hardly even present in very fast code.
16:03:34 <dons> where the particular execution strategy has been sorted all the way out
16:03:41 <Boney> dons: I imagine GHC tries to compile them away.
16:03:45 <dons> right.
16:03:57 <Boney> I expect that last time Mercury was compared to Haskell (GHC) was many years ago.
16:04:09 <Boney> and in the meantime Haskell has had a lot more work and Mercury hasn't had much work.
16:04:36 <Boney> no-body is really 'paid' to work on Mercury.
16:04:48 <Boney> there are people where it's part of their job, but not their whole job.
16:05:11 * ddarius rarely uses let.
16:05:22 <Boney> Anyway, I'd probably find a comparison quite interesting.
16:05:43 <ddarius> Boney: Make some benchmarks and compare.
16:06:08 <Boney> ddarius: If I can remember the name of that haskell benchmark library I'll re-write it in mercury.
16:06:16 <Boney> because I'll want to use it for my work anyway.
16:06:32 <Saizan_> nofib?
16:06:38 <ddarius> Or submit entries to the shootout
16:06:47 <Boney> Saizan_: perhaps.  I'll find the paper I read about it in.
16:06:51 <Boney> ddarius: ooh.
16:08:05 <dons> just beat the shootout entries
16:08:09 <dons> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
16:09:17 <Saizan_> @hoogle Lift
16:09:17 <lambdabot> Language.Haskell.TH.Syntax class Lift t
16:09:17 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
16:09:17 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
16:09:36 <Saizan_> @docs Language.Haskell.TH.Syntax
16:09:36 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/template-haskell/Language-Haskell-TH-Syntax.html
16:11:03 <pumpkin> yitz: yeah I am :)
16:11:28 <yitz> pumpkin: ok
16:14:40 <LoneTech> dons: just fooling around with the shootout, I really wonder why gcc C++ seems much faster than gcc C.
16:15:00 <pumpkin> is split '\n' equivalent to lines, on a bytestring?
16:15:07 <dons> LoneTech: they've taken the time
16:15:11 <dons> pumpkin: yeah
16:15:14 <pumpkin> thanks :)
16:19:29 <pumpkin> dons: the best I can do (in terms of memory) with a strict bytestring is roughly the size of the file I'm parsing, right?
16:20:11 <pumpkin> the String-based one runs in constant memory but is slow, this bytestring one uses about 2x the CSV size but is berfast
16:20:19 <pumpkin> I can deal with 2x the CSV size thoug
16:20:32 <EvilTerran> pumpkin, what about lazy bytestrings?
16:20:56 <pumpkin> EvilTerran: my only constraint really is the ByteString lexer
16:21:04 <dons> pumpkin: right.
16:21:08 <LoneTech> I think I figured out how to do my fold, but it still hurts my head.
16:21:34 <Debugger> LoneTech: The more information the compiler has, the better it can optimise
16:21:48 <pumpkin> does the bytestring lexer for doubles use lazy or strict bytestrings?
16:25:14 <eu-prleu-peupeu> is there any good gui architectures in haskell ?
16:26:59 <Axman6> GTK2Hs eu-prleu-peupeu
16:27:00 <dons> eu-prleu-peupeu: come on man, time to do your research.
16:27:05 <dons> you've been here for months!
16:27:12 <dons> pumpkin: strict
16:27:46 <pumpkin> thanks :) is there a good way to figure out at a glance (from :t or something) whether a given ByteString type is lazy or not?
16:27:53 <pumpkin> can I ask for a fully qualified name somehow?
16:28:50 <eu-prleu-peupeu> ill try to produce something soon... :/
16:30:07 <LoneTech> I already made a silly graphical program, and found out that HGL's timeouts required a multithreaded RTS.
16:30:30 <eu-prleu-peupeu> timeouts ?
16:31:04 <Boney> Saizan_: Yes.  I was thinking of nofib.
16:31:48 <LoneTech> eu-prleu-peupeu: it was a simple animation (bouncing ball), so it needed regular updates.
16:32:18 <dons> this is kind of depressing, http://www.cse.unsw.edu.au/~dons/tmp/eu-prleu-peupeu.txt
16:32:50 <eu-prleu-peupeu> ahah
16:32:53 <LoneTech> wow.
16:33:16 <pumpkin> what happened to Ezla btw?
16:33:20 <eu-prleu-peupeu> you have forgoten my other nick, the eu-prleu-peupe1 or whatever :P
16:33:25 <Axman6> eu-prleu-peupeu: yeah, you need to learn tp use google, and the haskell wiki search
16:33:38 <pumpkin> omg an Axman6
16:33:51 <Axman6> pumpkin: killed himself bcause he was so furious at record syntax
16:33:59 <Axman6> o/
16:34:05 <pumpkin> lol, don't joke about that, there are very strange people on IRC :P
16:35:19 <noZone> Well apparently one less strange person anyway...
16:36:09 <Axman6> dons: i like the patterns the timestamps make in that logfile :P
16:38:20 <chessguy> > tail []
16:38:22 <lambdabot>   * Exception: Prelude.tail: empty list
16:44:54 <lucca> I think people get that wrong fairly often
16:45:08 <lucca> If you really want to troll, just claim to love the record syntax ^_^
16:45:46 <eu-prleu-peupeu> you mean the { a=b, ... } stuff ?
16:45:54 <lucca> Yes.
16:45:59 <pumpkin> OMG I <3 RECORD SYNTAX
16:46:28 <wchogg> NO SHOUTING
16:46:39 <dons> come on, the dude loves record syntax.
16:46:41 <dons> its only natural
16:47:02 <wchogg> "When a dude & a record syntax truly love each other..."
16:47:18 * chessguy  has about 3/4 of the trivial part of Wumpus World built
16:47:18 <pumpkin> wchogg: sorry, I can't contain my enthusiasm :/ I'll see if I can find a pillow to scream my love into next time :)
16:47:25 <igowen> hey dons, just thought I'd mention that I'm enjoying RWH immensely
16:47:32 <dons> sweet!
16:47:58 <chessguy> @remember pumpkin OMG I <3 RECORD SYNTAX
16:47:59 <lambdabot> Done.
16:48:00 <wchogg> dons : you guys did a really good job with that book.  I think it might be the Haskell version of The Pickaxe
16:48:01 <LoneTech> I am, too, though I haven't gotten far.
16:48:08 <pumpkin> lol
16:48:18 <erikc> my friend manually writes haskell-style record access functions in f# cause f#'s record syntax doesnt compose
16:48:18 <pumpkin> @. elite quote wango
16:48:19 <lambdabot> \/\/4ngo zays: Do yOU 1ixE 7uRINg CompLE7E?
16:48:28 <erikc> he wishes f# had haskell records :)
16:48:57 <pumpkin> anyone know what this means?     Function binding for `rnf' has no equations
16:48:57 <pumpkin>     When splicing generated code into the program (from Data.Derive.NFData)
16:48:59 <chessguy> mm, haskell records don't exactly compose either
16:49:06 <Saizan_> it tryly must be horrendous..
16:49:30 <dons> pumpkin: no body for the functions
16:49:59 <pumpkin> dons: I assume that's because I'm trying to derive NFData on something that it can't figure out? UArr
16:50:01 * pumpkin looks guilty
16:50:16 <eyeris> Could someone take a look at this GHC installation problem and let me know what I am missing? http://hpaste.org/13770
16:53:10 <pumpkin> oh I guess UArrs are already strict
16:53:29 <eu-prleu-peupeu> i want to become a specialist in useless stuff
16:54:17 <eu-prleu-peupeu> like those forgotten mathematicians from the past
16:54:19 <pumpkin> eu-prleu-peupeu: if you consider a many "I wants" to be a specialty, you might already have succeeded in that one :)
16:56:00 <eu-prleu-peupeu> ill just wrap them up in a letter, and send it to santa claus
16:56:24 <dons> good to see you're keeping up the content-free track record, eu-prleu-peupeu
16:56:26 <pumpkin> dons, augustss: anyway, got it down to 80 MB and 9 seconds using strict bytestrings and the bytestring lexer in combination with the paste augustss made :)
16:56:29 <dons> cool
16:56:48 <pumpkin> eu-prleu-peupeu: take your fate into your own hands! don't wish, do! :)
16:56:57 <eu-prleu-peupeu> im just adding chrome to the #
17:00:52 <pumpkin> @pl headStrict (x:xs) = seq x (x : headStrict xs)
17:00:53 <lambdabot> headStrict = fix ((`ap` tail) . (. head) . liftM2 (.) seq . flip ((.) . (:)))
17:00:56 <pumpkin> oh my
17:01:09 <pumpkin> that's not in any way equivalent to map (join seq) right?
17:01:14 <pumpkin> I thought I was being clever
17:01:58 <eu-prleu-peupeu> sometimes i get confused about (.) and $ :/ but i think im grasping it slowly...
17:02:34 <dolio> map (join seq) = id
17:02:35 <pumpkin> eu-prleu-peupeu: good to hear it :) if you're looking for something to do in haskell, there are several sets of exercises to sharpen your haskell-fu, or you could do something like project euler
17:02:43 <pumpkin> dolio: now I feel stupid :P
17:03:14 <pumpkin> dolio: it doesn't even evaluate the elements?
17:03:18 <eu-prleu-peupeu> oh
17:03:26 <pumpkin> > id [1,2,3,4,undefined]
17:03:27 <lambdabot>   [1,2,3,4,* Exception: Prelude.undefined
17:03:31 <dolio> It gives you a list full of things like "seq x x"
17:03:35 <dolio> And seq x x = x.
17:03:38 <pumpkin> dolio: yeah, that's what I was hoping for
17:03:38 <pumpkin> oh
17:03:51 <pumpkin> well, yeah, I expect it to be like id, but force evaluation
17:03:55 <pumpkin> like rnf, sortakindmaybe
17:04:05 <eu-prleu-peupeu> where can i find those exercises ?
17:04:13 <dolio> No.
17:04:17 <dolio> seq x x = x
17:04:24 <eu-prleu-peupeu> pumpkin: are you a single human, or a colective of human people ?
17:04:27 <dolio> It says, "when you go to evaluate x, evaluate x first."
17:04:40 <pumpkin> eu-prleu-peupeu: I believe I am one person, but how would I breally know?
17:04:45 <pumpkin> dolio: oh :(
17:04:55 <eu-prleu-peupeu> ok
17:05:02 <pumpkin> how is rnf implemented internally?
17:05:02 <dolio> headStrict, on the other hand, says "when you destruct (x : headStrict xs), evaluate x first."
17:05:09 <pumpkin> ah
17:05:50 <dons> pumpkin: inductively with seq
17:05:54 <pumpkin> I'm a real fan of rnf, probably mostly because my lack of knowledge of laziness makes me want to be a control freak
17:05:59 <dons> hehe
17:06:03 <dolio> rnf [] = () ; rnf (x:xs) = rnf x `seq` rnf xs, or something like that.
17:06:11 <pumpkin> ah :)
17:06:14 <erikc> is the garbage collector in Non-Stop Haskell available, or bitrotted?
17:06:51 <dons> erikc: i think it was only ever in a research branch
17:06:55 <dons> its a good question though.
17:07:31 <wchogg> was Non-Stop Haskell a real-time gc runtime or something?
17:07:50 <erikc> an incremental compacting gc
17:07:55 <wchogg> Ah
17:08:03 <ddarius> pumpkin: rnf is just a class.
17:08:10 <ddarius> (or rather a method of a class)
17:08:21 <pumpkin> ddarius: yeah :) I know, I meant for lists, sorry
17:08:21 <ddarius> And you should avoid it in almost all cases.
17:08:28 <dolio> Just like seq should be. :)
17:08:30 <erikc> it occurred to me last night that purity means no write barriers are needed in the gc, is that true?
17:09:01 <ddarius> erikc: It would be if it weren't for laziness.
17:09:27 <pumpkin> is there any way to convert a lazy ByteString to a strict one and back?
17:09:30 <ddarius> erikc: 'turns out that pure lazy languages tend to mutate about as often as impure strict (functional) languages.
17:09:33 <dons> pumpkin: yup
17:13:20 <SamB_XP_> ddarius: but it tends to be a bit more predictable what will be mutated ...
17:14:01 <ddarius> SamB_XP: Strictness analysis has become decidable?
17:14:42 <SamB_XP> ddarius: I meant by node type
17:14:49 <SamB_XP> not static analysis
17:15:04 <pumpkin> dons: can't find any obvious way to do it in the docs, and it's rather hard to hoogle for :/
17:15:27 <SamB_XP> for instance, cons nodes aren't mutable...
17:15:43 <ddarius> SamB_XP: cons nodes aren't mutable in SML either
17:15:59 <dons> pumpkin: oh, fromChunks/ toChunks
17:16:00 <pumpkin> oh, fromChunks and toChunks
17:16:07 <pumpkin> aha! :)
17:16:25 <SamB_XP> ddarius: oh
17:16:28 <kmeyer> can I assert things in my haskell code?
17:16:59 <SamB_XP> kmeyer: sure you can!
17:17:06 <kmeyer> how? :D
17:17:14 <dolio> -- Raspberry ice cream is great
17:17:16 <chessguy> kmeyer:  just call error if it's not true
17:17:27 * chessguy rolls his eyes at dolio 
17:17:38 <kmeyer> chessguy: ok.
17:17:44 <rwbarton> @hoogle assert
17:17:44 <lambdabot> Control.Exception assert :: Bool -> a -> a
17:17:44 <lambdabot> Test.HUnit.Base assert :: Assertable t => t -> Assertion
17:17:44 <lambdabot> Test.HUnit.Base class Assertable t
17:17:50 <chessguy> oh!
17:17:51 <pumpkin> dons: <3 I got the best of both worlds... constant space and super fast parsing! the parsing is still 9 seconds, but I now have constant space usage of 2.4 megs :D
17:17:51 <kmeyer> dolio: I meant programmatically, but I suppose that works
17:18:00 * pumpkin has his cake and eats it too
17:18:15 <chessguy> kmeyer:  ignore me, i don't know what i'm talking about
17:18:29 <kmeyer> rwbarton: thanks
17:18:29 <pumpkin> 2.4 MB sure beats half a gig
17:18:59 <rwbarton> kmeyer: according to the docs, compiling with -O will turn off assertions (just something to be aware of)
17:19:13 <kmeyer> thanks
17:20:29 <chessguy> heh. that's quite an optimization
17:20:57 <Twey> Well, that's understandable
17:22:07 <chessguy> seems like it changes the semantics though
17:22:19 <chessguy> i mean, changing whether or not the program terminates at a certain point...
17:24:24 <intoverflow> So when using OpenGL on xwindows, I find that the GL window doesn't get the usual application border/title that I'd expect; it just pops up as a borderless rectangle.  Has anyone else seen this?
17:24:50 <SamB> intoverflow: how'd you make the window ?
17:25:24 * pumpkin does a little dance
17:25:38 <intoverflow> The GLUT createWindow
17:26:16 <intoverflow> http://hackage.haskell.org/packages/archive/GLUT/2.1.1.2/doc/html/Graphics-UI-GLUT-Window.html#v:createWindow
17:29:31 <intoverflow> I get the same behavior when running the reactive-glut Test.hs
17:34:06 <Axman6> intoverflow: try reactive-fieldtrip
17:35:15 <intoverflow> caballing...
17:37:12 <intoverflow> same behavior
17:37:31 <pumpkin> :t curry
17:37:32 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
17:41:00 <intoverflow> well, slightly different behavior -- ghc took my machien down right after I said "same behavior"
17:41:05 <thoughtpolice> yay pumpkin!
17:41:11 <thoughtpolice> pumpkin: what was necessary for it to use constant space?
17:41:35 <pumpkin> thoughtpolice: I'm using lazy bytestrings to load the file in, and strictifying only when needed to pass to the bytestring lexer
17:41:59 <pumpkin> even with only strict bytestrings, it wasn't using nearly as much memory as before
17:42:07 <erikc> ddarius: so a thunk would be colored grey after being updated? (very late reply, grabbed the stg machine paper)
17:42:15 <thoughtpolice> yeah lazy bytestrings help a lot of stuff
17:42:24 <pumpkin> I'm very happy... now I need to rebuild my analysys code on top of uvector, but it's a pleasure :)
17:42:28 * pumpkin does another little dance
17:42:29 <thoughtpolice> just be careful - lazy IO is a very dangerous place
17:42:39 <thoughtpolice> sometimes, anyway
17:43:04 <pumpkin> thoughtpolice: in what kinds of situations? mine really just involves reading a static file, doing some computations on what I read, and spitting some stuff out to stdout (or sometimes writing to another file)
17:43:22 <ddarius> thoughtpolice: It's usually more of an issue if you are doing something mildly complex.
17:43:32 <thoughtpolice> ddarius: true
17:44:24 <pumpkin> yeah, I'm not :)
17:44:28 <pumpkin> well, not at the IO level, anyway
17:45:08 <ddarius> erikc: I'd have to refresh my memory on GC theory to answer you sensibly.  I'm sure you can arrive at a conclusion yourself.
17:45:51 <thoughtpolice> pumpkin: i.e. using a lazy hGetContents - you can pass the resulting stream to a pure function, effectively making it an impure function because it's side-effecting (i.e. its still reading from disk) - it gives less predictable results about e.g. when to close your handle, or when your resources are finished. this makes error handling for example a bit tough.
17:46:20 <pumpkin> thoughtpolice: ah, that makes sense
17:46:22 <thoughtpolice> but like ddarius this stuff normally bites when you're doing something a little complicated
17:47:09 <thoughtpolice> pumpkin: this is why I find olegian enumerators very awesome - you still get all the benefits of a 'lazy' stream (you never process more than you need,) but you get pretty exact resource handling too
17:47:30 <thoughtpolice> pumpkin: oleg talked about this on -cafe a while back, lemme see if I can find a link...
17:47:48 <pumpkin> I've heard of them, but the moment I hear the word "oleg" I think "omg l33t, *must hide*"
17:48:13 <thoughtpolice> oleg's enumerators are one of his very approachable ideas, i'm happy to say :)
17:49:13 <augustss> pumpkin: for your purposes (just reading a static file), lazy IO is no problem.
17:49:31 <pumpkin> yay
17:49:37 <pumpkin> augustss: thakns again for the help earlier btw
17:49:41 <augustss> np
17:49:58 <augustss> so the bytestrings made the trick, eh?
17:50:09 <ddarius> As far as I can tell, the enumerators stuff is just a (relatively straightforward) purely functional rendition of what people normally do in imperative languages.
17:50:17 <thoughtpolice> lazy io does give good results though - lazy bytestrings in particular are great for many things.
17:50:25 <thoughtpolice> you just need to be a little careful sometimes
17:50:27 <pumpkin> augustss: both things did awesome things to my memory and execution times
17:50:41 <pumpkin> combined, even better :)
17:50:55 <thoughtpolice> augustss: oh also, your latest llvm release on hackage doesn't build, and the darcs repo says there are no changes to be pulled in?
17:51:17 <augustss> thoughtpolice: oh?  maybe I missed a file.  Lemme check
17:52:57 <thoughtpolice> pumpkin: http://www.haskell.org/pipermail/haskell-cafe/2008-September/047738.html <- here's what oleg has on the matter, the context is here - http://www.haskell.org/pipermail/haskell-cafe/2008-September/047681.html
17:53:13 <pumpkin> thoughtpolice: thanks a lot :)
17:53:18 <pumpkin> I'll do my homework!
17:53:59 <thoughtpolice> pumpkin: but yes enumerators are one of his very approachable and practical ideas
17:54:13 <thoughtpolice> pumpkin: here's the first draft on the matter - http://okmij.org/ftp/papers/LL3-collections-enumerators.txt
17:54:14 <pumpkin> is there an implementation on hackage?
17:54:25 <thoughtpolice> pumpkin: i also recommend this - http://okmij.org/ftp/Haskell/fold-stream.lhs
17:54:31 <thoughtpolice> it has a good haskell example of streams
17:54:36 <pumpkin> great, thanks :)
17:54:42 * pumpkin enables infospunge mode
17:54:45 <thoughtpolice> pumpkin: no, but that -cafe thread (with oleg's reply) has a link to some code he wrote
17:54:51 <pumpkin> ah, cool
17:54:53 <thoughtpolice> that implements iteratee-based IO
17:54:56 <thoughtpolice> so you could use that
17:55:17 <thoughtpolice> but anyway
17:55:21 * thoughtpolice --away --reason=food
17:59:17 <pumpkin> thanks again :)
18:00:30 <augustss> thoughtpolice: it should build now
18:00:48 <thoughtpolice> augustss: ty
18:01:13 <thoughtpolice> augustss: are you pushing patches to http://darcs.serpentine.com/llvm ?
18:02:14 <augustss> No, I've been pushing to another repo on bos' machine.  there were some permission problems.  but let me try again
18:03:13 <pumpkin> @src transpose
18:03:13 <lambdabot> transpose []             = []
18:03:13 <lambdabot> transpose ([]   : xss)   = transpose xss
18:03:13 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
18:03:15 <pumpkin> is that correct?
18:03:38 <pumpkin> I'm trying to adapt it to [UArr a] and it's saying I have an overlapped pattern
18:05:33 <thoughtpolice> augustss: new version builds great, ty. :)
18:07:00 <conal> pumpkin: that def looks right to me.  cons the heads onto the transpose of the tails
18:07:12 <pumpkin> yeah, okay :)
18:07:21 <pumpkin> maybe I shouldn't be working with transpose in my situation anyway
18:07:33 <pumpkin> doesn't feel very lazy
18:07:51 <conal> oh
18:08:36 <conal> hm.  i wonder about that second case ([]:xss)
18:08:40 <sclv> > transpose [[0,1,2,3],[4,5,6,undefined]]
18:08:42 <lambdabot>   [[0,4],[1,5],[2,6],[3,* Exception: Prelude.undefined
18:08:59 <sclv> > transpose [[0,1,2,3,4],[4,5,6,undefined,7]]
18:09:00 <lambdabot>   [[0,4],[1,5],[2,6],[3,* Exception: Prelude.undefined
18:09:15 <pumpkin> looks lazy enough, but my UArrs aren't
18:09:21 <pumpkin> I don't think
18:09:39 <sclv> conal: btw, did you take a look at what i sent?
18:09:51 <conal> sclv: hm.  what was that?
18:10:17 <sclv> the segment stuff with polynomials baked in
18:10:41 <conal> sclv: oh yeah.  sry.  i got distracted and forgot.  and i did have a few comments.
18:11:29 <sclv> fyi -- the caching of integrals etc and offsets seems more trouble than its worth, and is gone again for ease of working with and since it introduced more bugs than it helped efficiency.
18:11:55 <conal> sure.
18:11:59 <sclv> i'm pretty sure with more math chops, multivariate polynomials could probably be handled too...
18:13:03 <augustss> @seen bos
18:13:03 <lambdabot> I saw bos leaving #ghc and #haskell 2h 17m 35s ago, and .
18:13:05 <conal> yeah.  i see you used power series stuff from doug mcilroy.  i like his work.
18:13:45 <conal> sclv: one comment: your Num instance for Bound doesn't look correct.  assuming you'd define correct the same way i would.
18:14:08 <Cale> The most fun way to represent multivariate polynomials is via the monoid ring construction :)
18:14:10 <sclv> yeah, its a bit sloppy -- i'm not sure what the "right thing" is in all cases
18:14:24 <conal> sclv: most people aren't.  that's why semantics is important.
18:14:58 <conal> lots of "implementation decisions" can be eliminated.
18:15:01 <pumpkin> Cale: o.O
18:15:09 <Cale> If you implement arbitrary monoid rings, then multivariate polynomials just come from the multiset monoid.
18:15:53 <pumpkin> is indexU O(1) (UArr from uvector)?
18:16:03 <pumpkin> Cale: *whoosh*
18:16:16 <pumpkin> I know what a monoid is, and what a ring is :P
18:16:28 <pumpkin> and what a multivariate polynomial is, and what a multiset is
18:16:36 <pumpkin> however... :P
18:16:36 <augustss> pumpkin: there you go!
18:16:39 <sclv> Cale: do you get cheap partial integration and derivation over them?
18:16:42 <rwbarton> And just as the monoid ring is the free ring on a commutative monoid, so is the multiset monoid the free commutative monoid on a set
18:16:55 <Twey> 02:15:09 < Cale> If you implement arbitrary monoid rings, then multivariate polynomials just come from the multiset monoid.
18:16:58 * Twey sneezes.
18:17:08 <ddarius> Cale: Read the "Provenance Semi-Rings" paper?
18:17:16 <sclv> conal: hmm, makes sense.
18:18:42 <sclv> i'm not sure if its a step forwards or backwards to use the poly stuff to implement switchers, etc... which seems like how this might fit into your more general project.
18:18:42 <Cale> If M is any monoid, and R is any other ring, then the monoid ring MR has as its elements functions M -> R with finitely many elements of the domain being sent to nonzero elements of R.
18:18:42 <Cale> (which you can represent nicely using a Data.Map
18:18:42 <Cale> )
18:18:42 <pumpkin> :o
18:18:47 <conal> sclv: i do intend to extend Fun with a bit more smarts, which can then replace function segments and become part of signals.
18:19:30 <conal> sclv: or some other way to track the amount of non-linearity in behaviors and surfaces.
18:20:17 <conal> sclv: since graphics hardware mostly does piecewise-linear approximations, and i want to tessellate adaptively.
18:20:43 <Cale> Or, actually, usually it's denoted R[M]
18:21:16 <Cale> The addition is elementwise, and the multiplication is by convolution: (f * g)(x) = sum over u v = x of f(u) g(v)
18:21:23 <sclv> ah -- so you're optimizing for graphics hardware then, which is why piecewise linear is mainly what you're concerned with?
18:22:56 <pumpkin> do people decide what order to set their arguments up based on what they're most likely to curry on?
18:23:03 <Cale> Which amounts to saying that (sum over x of f(x) x) (sum over y of g(y) y) = sum over (x,y) of f(x) g(y) x y
18:23:10 <ddarius> pumpkin: Yes.
18:23:15 <Twey> pumpkin: I do
18:23:21 <ddarius> (after other considerations of course)
18:23:29 <pumpkin> sounds good, thanks :)
18:23:36 <Twey> After what other considerations?
18:23:36 <Cale> pumpkin: Yeah, the arguments go in ascending order of expected rate of change.
18:23:40 <conal> sclv: yeah mainly.  some years ago i did something similar for behaviors.  a very fast engine that interpolated simple behaviors (linear, quadratic, cubic) with a higher level FRP implementation that produced the simple segments.  the fast engine could do hundreds of frames per sec.  http://conal.net/papers/padl99/
18:23:42 <SamB> darnit, why can't firefox *OR* elinks be as sensible as IE about what to do with text/x-darcs-patch ...
18:23:47 <pumpkin> Cale: how mathematically phrased!
18:23:52 <Twey> Heheh
18:24:03 <Twey> SamB: What does IE do?
18:24:10 <SamB> Twey: show it!
18:24:13 <Twey> SamB: Ah
18:24:21 <Twey> SamB: That's not actually IE being sensible about the MIME typ
18:24:22 <Twey> e
18:24:32 <Twey> It's IE ignoring the MIME-type altogether and just deciding to guess
18:24:32 <SamB> it isn't ?
18:24:36 <SamB> oh.
18:24:38 <conal> sclv: now a lot of this tessellation can be done on the gpu as well.
18:24:40 <Twey> It likes to do that sometimes
18:24:51 <SamB> I thought it just did that for file://
18:24:57 <Twey> Alas no.
18:25:17 <sclv> conal: nice. i'm not sure if the result that one can do lazy, piecewise spline solutions of differentials is novel or not, nor quite how it stacks up to RK & co?
18:25:22 <Twey> I don't really know when it does it.  I'm not sure that anyone outside of Microsoft does.
18:25:27 <Twey> It happens 'sometimes'.
18:25:28 <Cale> So, for example, if we take the additive monoid of the naturals, and, just for notation's sake, we choose to write the natural n as x^n
18:25:45 <pumpkin> is indexU 1-based or 0-based?
18:25:52 <Cale> and we take, say, the real numbers as our ring R
18:26:04 <pumpkin> oh I can test that easily
18:26:04 * SamB thinks html and suchlike should be expelled from text/
18:26:06 <ddarius> pumpkin: 0-based is the Only True Way.
18:26:10 <pumpkin> oh okay :)
18:26:12 <Twey> SamB: You and everyone else
18:26:13 <pumpkin> yeah, I prefer it too
18:26:17 <Cale> Then the monoid ring R[M] here is just polynomials with coefficients in R
18:26:20 <pumpkin> it takes less twiddling
18:26:26 <Twey> SamB: That's why XHTML is at application/xhtml+xml
18:26:32 <SamB> ah
18:26:36 <conal> sclv: do you ever blog?  it sounds worth at least a blog post or two.
18:26:47 <SamB> what does the +xml mean ?
18:27:01 <Twey> SamB: That it's a subset of XML (can also be parsed as)
18:27:08 <pumpkin> yup, zero-based
18:27:13 <Cale> If instead we take multisets of elements of some fixed set {x_1,...,x_n}, then we get the polynomials in those indeterminates
18:27:15 <SamB> I think there ought to be some sort of indicator that a format is textual ...
18:27:19 <sclv> conal: yeah, at the least. i'm just not deeply familiar with the field, prior work, etc.
18:27:23 <Cale> (the monoid under multiset union)
18:27:27 <conal> sclv: in any case, i encourage you to get the semantics clear and then see if the implementation is correct.
18:27:30 <Twey> SamB: Well, +xml covers that really.
18:27:37 <sclv> ah -- i.e. the Bound question.
18:27:40 <Cale> (anyone still following that? :)
18:27:42 <Twey> The point is that it's not meant to be interpreted as text
18:27:43 <conal> sclv: that's fine when blogging.  your readers will fill you in.
18:27:53 <Saizan_> SamB: https://addons.mozilla.org/en-US/firefox/addon/8207
18:28:29 <Cale> Another way to express that monoid is just the monoid of n-tuples of naturals.
18:28:39 <sclv> is there anything else besides bound that you felt the semantics was sloppy on?
18:28:48 <SamB> hopefully addons.mozilla.org still recognizes iceweasel...
18:29:48 <conal> sclv: and the other types.  one semantic model per type.
18:30:03 <conal> sclv: and then define the meaning of each operation in terms of the models of their types.
18:30:13 <conal> sclv: if you can't do it, you have an abstraction leak.
18:30:23 <SamB> huh, that only works with 3.0 browsers ...
18:30:37 <conal> sclv: and if you can, you've defined correctness and can check for it.
18:30:39 <pumpkin> whee, more laziness and efficiency! /me is falling deeper in love
18:30:45 <sclv> ah -- gotcha -- for the most part I thought I was doing that, but maybe not rigorously enough. If I hadn't been working that way at all, I think I wouldn't have gotten nearly as far...
18:31:12 <sclv> defining the morphisms explicitly I suppose would help in that...
18:31:21 <Saizan_> pumpkin: so you used toChunks and parsed each chunk separately?
18:31:41 <conal> sclv: oh, the semantic design method was there in the background.
18:32:49 <Cale> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=746#a746 -- monoid rings
18:34:14 <pumpkin> Saizan_: I split on '\n' and ',' using the lazy bytestring, and only do toChunks just before I need to lex the double
18:36:53 <SamB> hhu
18:36:55 <SamB> er. huh.
18:37:46 * SamB upgrades to iceweasel 3
18:37:59 <SamB> ... which uses xulrunner
18:46:00 <Saizan_> Cale: if you use the set monoid you get linear transformations?
18:46:54 <ddarius> Saizan_: Affine
18:47:09 <ddarius> sort of (?)
18:47:13 <Cale> er...
18:47:53 <ddarius> Well, no.  You'd still have xy
18:47:55 <Cale> You sort of get polynomials in those indeterminates modulo the relation that x^n = x
18:48:20 <sclv> hmm... looking at that code I see how multivariate polys just fall out.
18:48:28 <ddarius> Basically, all using a set would do is make all the exponents be either 1 or 0.
18:48:39 <Cale> I just had a lovely idea though. Category rings!
18:49:13 <Cale> Let R be any ring, and let C be an arbitrary small category. Let Arr(C) denote the set of all arrows of C (the disjoint union of its hom sets).
18:49:32 <Cale> Let R[C] be the set of functions Arr(C) -> R with finite support.
18:49:37 <rwbarton> Cale: If C has infinitely many objects, you won't have an identity element
18:49:54 <sclv> in which case I suppose a map is significantly more efficient for large numbers of variables than e.g. a multidimensional matrix which will become very sparse very quick.
18:50:20 <ddarius> Cale: What about a functor from C -> R where R is an abelian category?
18:50:34 <cknapp> haha... I log on for the first time in nearly a month, and the first thing I see is a category theory discussion...
18:50:34 <Cale> hmmm...
18:50:39 <ddarius> Rather a monoid viewed as a category that's abelian.
18:50:46 <ddarius> (the category not the monoid)
18:51:00 <ddarius> cknapp: More abstract algebra than CT.
18:51:20 <cknapp> Ah. Well... close enough... I guess.
18:51:26 <cknapp> :)
18:51:38 <ddarius> Cale: (Taking functors with "finite support" for "polynomials" and without restriction for "formal power series")
18:52:07 <Cale> Yes, that looks like it might work well :)
18:53:10 <cknapp> Hmm... apparently, either I am way over my head or I came in too late to follow the discussion. What's going on?
18:53:51 <Saizan_> you lost the part that makes most sense! :)
18:53:54 <Saizan_>     Cale : http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=746#a746 -- monoid rings
18:53:56 <Cale> cknapp: Generalising monoid rings to category rings.
18:54:22 <cknapp> Ah, so it's the former (way over my head)
18:54:37 <cknapp> Or rather, I don't have the background to discuss monoid rings, no less a generalization
18:54:53 <Cale> Monoid rings themselves have a fairly simple definition
18:55:45 <shapr> I want to wear a monoid ring!
18:55:48 <Cale> You take a ring R, and a monoid M, and define R[M] as the set of functions from M to R with finite support (that is, with finitely many elements of M being set to nonzero elements of R)
18:56:22 <Cale> and you define the sum pointwise, and the product by convolution: (f * g)(x) = sum over u v = x of f(u) g(v)
18:56:48 <Cale> So it's easy to see how polynomials come from that, using the naturals as your monoid.
18:57:02 <cknapp> Yeah, just read the wikipedia definition.
18:57:05 <Cale> Or polynomials in multiple indeterminates, using n-tuples of naturals
18:57:08 <sclv> its really lovely, now that i'm looking at it.
18:57:35 <ddarius> If you remove the restriction of finite support you end up with formal power series like things.  In the case of the Naturals monoid, we get normal (formal) power series, but N -> R is just a stream of R.
18:58:12 <rwbarton> You have to be careful then that you don't try to add infinitely many elements of your base ring R
18:58:28 <rwbarton> e.g., it's OK for the monoid N, since any x in N can only be written as x = a + b in finitely many ways
18:58:36 <sclv> next evolution of the code i'm working on, explicit power series go out, and monoid rings go in.
18:58:38 <Cale> Well, to make the formal power series thing work, you need to have some assurance that any element has only finitely many factorisations into two parts.
18:58:53 <Cale> (or else an appropriate topology)
18:58:59 <sclv> s/explicit power series/explicit polynomials/
18:59:26 <sclv> are there any other handy common monoid rings?
18:59:37 <ddarius> @google "Provenance semirings"
18:59:43 <lambdabot> http://db.cis.upenn.edu/DL/07/pods07.pdf
18:59:43 <lambdabot> Title: Provenance Semirings
19:00:04 <ztirF> @pl max_ind_of f z = fst $ foldl1' (\(i,x) (j,y) -> if f y > f x then (j,y) else (i,x)) b where b = zip [0..length z-1] z
19:00:05 <lambdabot> (line 1, column 95):
19:00:05 <lambdabot> unexpected "="
19:00:05 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or end of input
19:00:17 <cknapp> I hate/love this channel... discussion is always just beyond my power of comprehension... frustrating to no end, but so, so much fun. :D
19:00:34 <ddarius> cknapp: So change that.
19:00:44 <cknapp> Trying. :D
19:00:48 <shapr> cknapp: Yay!
19:01:20 <ztirF> @pl max_ind_of f z = fst $ foldl1' (\(i,x) (j,y) -> if f y > f x then (j,y) else (i,x)) (zip [0..length z-1] z)
19:01:23 <lambdabot> max_ind_of = (fst .) . (. join (zip . enumFromTo 0 . subtract 1 . length)) . foldl1' . flip ap snd . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (. (,)) .
19:01:23 <lambdabot> ap . ((flip . (flip .)) .) . flip flip (,) . ((.) .) . (ap .) . ((if' .) .) . join ((.) . flip . ((>) .))
19:01:23 <lambdabot> optimization suspended, use @pl-resume to continue.
19:01:28 * sclv goes off to google up differential polynomial rings to see if they're handy
19:01:56 <ddarius> With a name like "differential polynomial ring" how could it NOT be handy?
19:02:03 <ztirF> hmm that's not what I was expecting
19:02:15 <shapr> ztirF: What were you expecting?
19:02:20 <pumpkin> ztirF: that's almost as bad as one of those ones that's intentionally bad
19:02:39 <pumpkin> (the @pl output, that is)
19:02:49 <ztirF> well I have a function f and a list z, and I want the index of min (map f z)
19:03:08 <ztirF> what I wrote above does that but I would like to know if there's a prettier way
19:03:16 <Axman6> y not use monimumBy?
19:03:19 <Axman6> why*
19:03:25 <Axman6> minimumBy even
19:03:25 <pumpkin> minimumBy (comparing snd) . map f $ z ?
19:03:31 <pumpkin> it's not super efficient, but it's not ugly
19:03:34 <sclv> ddarius: until somebody writes up some pretty haskell code for it, i'm pretty sure i won't fully grok it.
19:03:36 <pumpkin> whoops
19:03:38 <pumpkin> no snd :)
19:03:41 <pumpkin> you know what I mean though
19:03:54 <Axman6> minimumBy (comparing f)
19:04:01 <kpreid> for an index...zip with [0..]
19:04:03 <pumpkin> oh that's even easier :)
19:04:05 <ztirF> ahhh that sounds more like it
19:04:20 <ddarius> sclv: Often one can write up code for something without fully grokking it.  Oftentimes that code can be helpful in grokking.
19:04:39 <Axman6> fst . minimumBy (comparing (f.snd)) . zip [0..]
19:04:58 <Axman6> > fst . minimumBy (comparing (f.snd)) . zip [0..] $ take 10 randoms
19:04:58 <lambdabot>   Couldn't match expected type `[b]' against inferred type `g -> [a]'
19:05:05 <Axman6> :t randoms
19:05:06 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
19:05:08 <sclv> no doubt -- that's what i've been doing all week :-)
19:05:21 <Axman6> > fst . minimumBy (comparing (f.snd)) . zip [0..] $ take 10 $  randoms (mkStdGen 1)
19:05:22 <lambdabot>   Add a type signature
19:05:28 <Axman6> > fst . minimumBy (comparing (f.snd)) . zip [0..] $ take 10 $  randoms (mkStdGen 1) :: [Int]
19:05:29 <mmorrow> here's some "agebraic geometry" for db-where-clauses http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=747
19:05:29 <lambdabot>       No instance for (Enum [Int])
19:05:29 <lambdabot>        arising from the arithmetic sequenc...
19:05:35 <Axman6> > fst . minimumBy (comparing (f.snd)) . zip [0..] $ take 10 $  (randoms (mkStdGen 1) :: [Int])
19:05:36 <mmorrow> *algebraic
19:05:36 <lambdabot>   Add a type signature
19:06:07 <cknapp> Question: trying to understand monoid rings. We have our monoid G, and our ring R, and the functions which satisfy [etc] from G->R... How exactly is multiplication defined, and what is addition? I don't really understand the wikipedia article
19:06:30 <ddarius> Abstract algebra is very useful for programming.
19:06:38 <intoverflow> mmorrow: cool
19:06:46 <cknapp> ddarius: I've noticed
19:06:53 <mmorrow> intoverflow: it works too :)
19:06:55 <ddarius> cknapp: Addition is pointwise, multiplication is convolution.
19:06:58 <mmorrow> ddarius: very
19:07:11 <cknapp> Ok.
19:07:43 <Saizan_> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=746#a746 <-- look at the code here, the Map G R represents the functions
19:07:44 <rwbarton> cknapp: It's not really best to think of the elements as functions, but rather as formal linear combinations r_1 g_1 + ... + r_n g_n
19:07:49 <intoverflow> mmorrow: needs sheaves!
19:07:56 <cknapp> Ah!
19:07:57 <mmorrow> intoverflow: yes!!
19:07:58 <rwbarton> cknapp: With the relations being that multiplication in the ring is the same as multiplication in the monoid
19:07:59 <cknapp> That helps.
19:08:17 * ddarius knows very, very little algebra geometry.
19:08:23 <ddarius> s/alegbra/algebraic/
19:09:20 <cknapp> Ok. I was having trouble convincing myself that a ring was hidden in there, but that falls right out of the "formal linear combination"
19:09:24 <cknapp> Thanks.
19:10:49 <ksf> any reactive-fieldtrip experts around?
19:11:35 <rwbarton> That also tells you the functoriality of the construction, if h : G -> G' is a monoid homomorphism, then the induced map is R[G] -> R[G'], not R[G'] -> R[G] as you might think from the function definition
19:12:14 <ksf> I currently can't figure out how to do a Anim3 with UI-dependent transformation and static geometry and'd be grateful for an example that I can take apart.
19:12:40 <cknapp> Damnit, right when I was starting to feel smug because I know what's going on...
19:13:09 <cknapp> Induced map?
19:13:35 <rwbarton> For example, say h : Z -> Z/2 is the mod-2 map
19:13:44 <cknapp> ok
19:14:23 <conal> ksf: is it defining the ui-dependent transfo that's tricky?  or putting the pieces back together? to get an Anim3?
19:14:23 <rwbarton> then R[Z] is polynomials in a variable, say x; R[Z/2] is polynomials in x but with x^2 = 1
19:14:54 <rwbarton> if we have some r_1 g_1 + ... + r_n g_n we just apply h to each of the g_i
19:14:59 <ksf> I'm not sure, I'm lost in type errors or missing instances.
19:15:19 <rwbarton> I think I've made my example kind of tautological, and thus confusing :(
19:15:25 <Saizan_> x^2 = x?
19:15:39 <cknapp> Ok... let me think about this. I understand it, sort of, but I don't really grok it.
19:15:48 <Saizan_> ah, no 2 `mod` 2 = 0 :)
19:16:02 <Axman6> :t iterate
19:16:03 <lambdabot> forall a. (a -> a) -> a -> [a]
19:16:28 <conal> ksf: oh.  try using (*%) on geometry behaviors.
19:16:47 <conal> ksf: you'll use 'pure' to promote the static geometry to a behavior.
19:17:08 <ksf> ...and then I need a Behaviour (Transform3 a)
19:17:10 <Saizan_> rwbarton: so in the functional formulation you'd have to sort of enumerate the elements of the monoid?
19:17:41 <Axman6> > let ls = iterate cos 1 in dropWhile (\(a,b) -> (abs (a-b)) < 0.0000001) . zip ls $ (tail ls)
19:17:42 <conal> ksf: what's the type of your ui-dependent transformation?
19:17:42 <lambdabot>   [(1.0,0.5403023058681398),(0.5403023058681398,0.8575532158463934),(0.857553...
19:18:05 <Axman6> :/
19:19:13 <ksf> I figured it should be UI -> Behaviour (Transform3 Float)
19:19:40 <conal> ksf: sounds good.  then i'd try  \ u -> xfo u *% pure g
19:19:55 <rwbarton> Saizan_: you'd have to sum over the preimages of an element
19:21:56 <schme> mornin'
19:22:17 <ksf> conal, No instance for (Transform (Behavior (Transform3 Float)) (BehaviorG (FRP.Reactive.Improving.Improving TimeT) TimeT Geometry3))
19:22:28 <ksf> that's the *%.
19:23:27 <cknapp> On a completely unrelated note, my 3 weeks of mountains has left me braindead... I'm writing a simple Game of Life program to remember the little bit of haskell I know, but I'm not sure the best way to store the board... lists are cumbersome... Better idea?
19:23:34 <cknapp> morning, schme
19:23:49 <chessguy> cknapp:  an array if you want constant random access
19:24:05 <conal> ksf: are you importing FRP.Reactive.FieldTrip ?
19:24:15 <conal> ksf: which is part of reactive-fieldtrip
19:24:49 <ksf> that hit the spot.
19:24:57 <ksf> I was only importing the adapter.
19:25:05 <conal> ksf: :)
19:25:09 <ksf> thanks.
19:25:17 <conal> my pleasure
19:29:36 * ksf is going to meditate about "\u -> xfo u" vs. "xfo" in the shower and come out of it either confused or laughing at his own idiocy.
19:29:41 -AshTray(n=tj@65.31.222.144)- !ping Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !!
19:29:41 -Marcy(n=iq@65.31.222.144)- !ping Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! A
19:29:41 -Dutchess(n=qo@65.31.222.144)- !ping Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !
19:29:41 -DimpalKapaDia(n=gk@65.31.222.144)- !ping Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of 
19:29:41 -l00p(n=co@65.31.222.144)- !ping Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Aw
19:29:41 -DimpalKapaDia(n=gk@65.31.222.144)- !ping Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of 
19:29:41 -AshTray(n=tj@65.31.222.144)- !ping Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !!
19:29:42 -Marcy(n=iq@65.31.222.144)- !ping Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! A
19:29:42 -Dutchess(n=qo@65.31.222.144)- !ping Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !
19:29:42 -l00p(n=co@65.31.222.144)- !ping Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Aw
19:29:46 -AshTray(n=tj@65.31.222.144)- !ping Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !!
19:29:46 -Marcy(n=iq@65.31.222.144)- !ping Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! A
19:29:46 -Dutchess(n=qo@65.31.222.144)- !ping Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !
19:29:46 -DimpalKapaDia(n=gk@65.31.222.144)- !ping Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of 
19:29:46 -l00p(n=co@65.31.222.144)- !ping Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Awesome Server IN mIRC UPDATED type /Server Atom.aseanchat.net 6667 And join Channel #Bangalore For Lots of Fun !! Aw
19:29:56 <chessguy> err
19:30:09 <schme> derrr
19:30:10 <intoverflow> that was... cool
19:30:18 --- mode: ChanServ set +o Igloo
19:30:18 <hydo> whee!
19:30:20 <schme> intoverflow: I *am* pretty cool, ya :)
19:30:30 --- mode: Igloo set +b *!*@65.31.222.144
19:30:39 --- mode: Igloo set -o Igloo
19:30:39 <intoverflow> schme: ind33d :)
19:30:47 <Zao> I can see how the set of people coding in haskell and the set of people interested in Bangalore overlap.
19:31:28 <intoverflow> the connection is pretty obvious -- people who like Haskell are all about having "Lots of Fun !!"
19:33:09 <MyCatVerbs> It'd be fitting in a way if a few hundred thousand people hopped onto that ircd simultaneously, and it melted.
19:34:12 <ksf> actually, it should have been obvious that *% binds way tighter than ->, and that the semantics of currying aren't a negotiable topic.
19:37:29 <MyCatVerbs> ksf: well, they're not really negiotable *now*. But come around again when you feel like designing another language from scratch. :)
19:38:41 <int80_h> when I see a pattern match like "fooFunction x y _ = ..." does it mean that _ is an optional parameter?
19:38:47 <MyCatVerbs> ksf: and all infix languages with anonymous functions that I know of like to have them extend as far as possible to the right. Hence -> has to be very loose indeed. It's what people expect by now.
19:38:51 <MyCatVerbs> int80_h: no.
19:39:00 <ksf> well, it's a wonderful thing that \x -> f x == f, for arititys > 0
19:39:02 <int80_h> what does it mean then?
19:39:04 <MyCatVerbs> int80_h: it means that the third parameter doesn't matter. Read it as "whatever".
19:39:26 <Olathe> int80_h: It means that that argument is thrown away.
19:39:35 <Axman6> @src const
19:39:35 <lambdabot> const x _ = x
19:39:41 <int80_h> ahhh
19:39:43 <Axman6> int80_h: ^^
19:39:46 <Olathe> > const 5 "omg zeus !"
19:39:47 <lambdabot>   5
19:39:49 <Axman6> that's the same as const x y = x
19:40:16 <ksf> modulo -Wmore-than-necessary.
19:43:17 <kpreid> cknapp: http://kpreid.livejournal.com/8629.html is a fun way to store a life board :-)
19:44:06 <pumpkin> kpreid: very nice
19:44:24 <cknapp> :) Thanks.
19:45:24 <ksf> can haskell proficiency be measured in terms of degree of digging pointless style?
19:45:40 <Olathe> I doubt it.
19:49:10 <Pispireto> HoLa
19:49:13 <Pispireto> h
19:49:14 <Pispireto> O
19:49:15 <Pispireto> L
19:49:17 <Pispireto> a
19:49:28 <Axman6> ...
19:49:48 <cknapp> Bonjour?
19:50:52 <schme> jourbon
19:51:04 <Olathe> bourbon
19:51:05 <Cale> Aha, that's the condition! We need the category to be locally-finite, in the sense that any arrow f has finitely many factorisations (g,h) such that f = g . h
19:51:23 <Cale> Then the sums will always work out properly without having to worry about convergence.
19:51:55 <Cale> ddarius, rwbarton, etc. ^^
19:52:03 <cknapp> :)
19:52:51 <rwbarton> Sure.  I think the term "locally finite" is taken, though :)
19:53:01 <cknapp> So, that's the condition for a category ring?
19:53:10 <Cale> yeah
19:53:32 <Cale> Then you have (f * g)(x: A -> B) = sum over u: A -> X, v: X -> B of f(u) g(v)
19:53:49 <Cale> (and you know there will be finitely many such pairs (u,v) because of the condition)
19:53:58 <cknapp> RIght.
19:54:20 <mmorrow> noetherian?
19:54:24 <rwbarton> Cale: Actually, the web agrees with your definition of locally finite
19:54:45 <cknapp> rwbarton: I think that's why he used it. :)
19:54:46 <rwbarton> Well, it also agrees with my definition :)
19:54:55 <Cale> This agrees with the incidence algebras of Gian-Carlo Rota, if we take C to be a poset category.
19:54:59 <cknapp> Ah. Which is?
19:55:21 <rwbarton> Hom(X, Y) is a finite set for every pair of objects X and Y
19:55:44 <rwbarton> like the definition of "locally small"
19:55:54 <Cale> rwbarton: Well, this kind of locally finite is a little stronger than that.
19:56:03 <Cale> er...
19:56:08 <Cale> Yeah.
19:56:25 <Cale> You also need that there are finitely many objects through which you can factor an arrow.
19:57:04 <rwbarton> Right
19:57:16 <Cale> Let (X, <=) be any poset which is locally-finite in the sense that any closed interval [a,b] has finitely many elements.
19:57:43 <Cale> Then it's locally-finite in my sense treated as a category with exactly one arrow x -> y when x <= y.
19:58:01 <mmorrow> i think this property is related to the ring being noetherian, but i'm not sure how to phrase it
19:58:40 <rwbarton> It seems like both definitions are in common use
19:58:52 <int80_h> I'm doing expercise 6 on page 70 of RWH. I'd like to know if I have the type definition right
19:58:54 <Cale> mmorrow: Well, I really just need it so that I can define multiplication sensibly... but it would be interesting if it turned out to guarantee Noetherian (or make Noetherian-ness hereditary)
19:59:07 <int80_h> sortList :: [unsorted] -> [sorted] -> [sorted]
19:59:26 <mmorrow> Cale: it would
19:59:40 <mmorrow> (be interesting)
19:59:57 <Cale> int80_h: hmm... that could only be right if you don't use any elements of the first list
20:00:12 <Cale> int80_h: unsorted and sorted are being treated as type variables there
20:00:23 <int80_h> Cale: oops, that would explain the errors I'm getting
20:00:29 <rwbarton> int80_h: What's sortList supposed to do?
20:00:37 <rwbarton> (I guess I should look up the exercise)
20:00:54 <int80_h> Cale: well, how would I change the type definition?
20:00:57 <cknapp> int80_h: what section is that exercise in?
20:01:02 <int80_h> I guess I should name it sortLists
20:01:27 <int80_h> Chapter 3, "Conditional Evaluation of Guards"
20:02:15 <rwbarton> "sorts a list of lists based on the length of each sublist" ?
20:02:32 <Cale> So one example of a category ring would be any matrix ring, using the category which has {1,...,n} as objects, and exactly one arrow i -> j for any i and j.
20:02:57 <Cale> Then (f * g)(i -> j) = sum over k of f(i -> k) g(k -> j)
20:03:03 <Axman6> can someone see what's wrong with this definition? data Num a => Pair = P !a !Int
20:03:14 <rwbarton> Cale: That's kind of cool
20:03:27 <cknapp> int80_h: You have a list of lists, and you want a list of lists, right?
20:03:28 <rwbarton> Cale: I wonder whether equivalent categories have Morita equivalent category rings
20:03:40 <Cale> By restricting to the ordinal category n, we get upper-triangular matrices.
20:03:42 <chessguy> Axman6:  i think that's ok
20:03:52 <int80_h> cknapp, yeah would I do this then ...
20:04:23 <chessguy> Axman6:  compiles for me
20:04:25 <int80_h> sortLists :: [[unsorted]] -> [[sorted]] -> [[sorted]]
20:04:28 <Axman6> gmm
20:04:33 <cknapp> Closer.
20:04:34 <Axman6> hmm even -_-
20:04:42 <cknapp> But...
20:05:13 <cknapp> The type declaration says what's in the lists, and nothing else. We have the same thing in each list, right, just a new order?
20:05:31 <int80_h> cknapp, yup thats right
20:05:38 <cknapp> So, we have a function which takes a list of lists of (something) and returns a list of lists of (the same thing).
20:06:28 <int80_h> well, the function will use two lists. list two starts as empty
20:06:41 <cknapp> Ah!
20:06:55 <int80_h> I put the sorted lists in the second function
20:07:03 <int80_h> and keep doing that until I'm done
20:07:19 <cknapp> Oh, so you're doing a selection sort?
20:07:21 <int80_h> I've worked out the right algorithm, but my type definition is wrong.
20:07:35 <int80_h> ya
20:07:42 <chessguy> int80_h:  how about @hpaste'ing your code
20:08:05 <int80_h> chessguy: my current code is wrong. I worked out a new algorithm, but wanted to fix the type definition before implementing.
20:08:39 <chessguy> oh ok
20:09:01 <cknapp> Each list has the same data in it. Give that data a type, say a, then you have sortList :: [[a]] -> [[a]] -> [[a]]
20:09:24 <int80_h> chnapp: okay. I keep still thinking is C, is the problem
20:09:24 <chessguy> i don't get why you have lists of lists
20:09:31 <cknapp> Does that make sense?
20:09:34 <int80_h> chessguy: it's in the spec
20:09:37 <cknapp> chessguy: It's an exercise
20:09:37 <chessguy> what's the actual problem specification?
20:09:41 <int80_h> chnapp: makes perfect sense.
20:09:55 <cknapp> "Sort a list of lists by length of the lists"
20:10:11 <int80_h> chessguy: sort a list of lists based on the length of sublists
20:10:19 <chessguy> ooooooooooooooooooohhhhhhhhhhhhhhhhhhh
20:10:23 <cknapp> :D
20:10:26 <chessguy> whoops
20:10:27 <SamB> that's actually drop dead easy these days
20:10:32 <chessguy> my keyboard just went wonky
20:10:33 <SamB> chessguy: don't tell 'em how!
20:10:51 <chessguy> Axman6:  well, you're over-complicating it again :)
20:11:00 <chessguy> err, int80_h
20:11:02 <int80_h> SamB, I've got the algorithm, but my type definition was broken due to my non-haskell thinking.
20:11:05 <ztirF> @pl \x y -> (compare . snd) x (snd y)
20:11:06 <lambdabot> (. snd) . compare . snd
20:11:12 <Axman6> chessguy: data Num a => Pair a = P !a !Int is what i needed btw
20:11:25 <chessguy> Axman6:  cool
20:11:35 <chessguy> strictness ftw?
20:11:37 <int80_h> chessguy: you're saying that I don't need a second list of list?
20:12:15 <chessguy> int80_h:  yep
20:12:31 <SamB> int80_h: oh, well, would it depress you if we golfed it down to one line using combinators you probably aren't allowed to use ?
20:12:41 * chessguy sniggers
20:12:54 <int80_h> SamB: no it wouldn't depress me. It's just not useful.
20:12:59 <SamB> oh okay then
20:13:09 <BMeph> Axman6: Yeah, I was gonna warn you, your Pair type uses a as a constraint, but not as a parameter. Good show. :)
20:13:12 <int80_h> I need to get used to haskell notation anyway.
20:13:16 <chessguy> well, for one thing, in case you didn't know:
20:13:18 <chessguy> @hoogle sort
20:13:18 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
20:13:18 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
20:13:18 <lambdabot> Data.ByteString.Char8 sort :: ByteString -> ByteString
20:13:24 <cknapp> Just sort the rest behind the first element
20:13:27 <Axman6> BMeph: :)
20:14:00 <SamB> > sortBy (comparing length) ["Hello!", "Goodbye!", "Hi!", "Bye!"]
20:14:02 <lambdabot>   ["Hi!","Bye!","Hello!","Goodbye!"]
20:14:07 <Axman6> i'm going through implementing http://lethain.com/entry/2009/jan/02/genetic-algorithms-cool-name-damn-simple/ in haskell. wondering if i'm going to run into any state type issues that might trip me up...
20:14:27 <BMeph> Axman6: I will claim just coming back home from a class as my defense for being such a slow reader and answerer, though.
20:14:35 <ztirF> @pl \x y -> compare  (snd x) (snd y)
20:14:36 <lambdabot> (. snd) . compare . snd
20:14:37 <chessguy> Axman6:  now that sounds cool
20:14:38 <int80_h> cknapp: Oh crap, I just thought of something!
20:14:46 <ztirF> @type \x y -> compare  (snd x) (snd y)
20:14:47 <lambdabot> forall a a1 b. (Ord b) => (a, b) -> (a1, b) -> Ordering
20:14:50 <BMeph>  Now if I could just use that excuse all of the time, I'd be olden! ;p
20:14:50 <SamB> ztirF: oh, btw, try "comparing snd"
20:14:51 <cknapp> ?
20:14:54 <Axman6> chessguy: yeah, read through it, should be really easy to haskellise :)
20:15:17 <SamB> @src comparing
20:15:17 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
20:15:21 <SamB> @src on
20:15:21 <lambdabot> (*) `on` f = \x y -> f x * f y
20:15:30 <int80_h> cknapp: well I couldn't think on how to do an "in place" modification of the list. But now it just hit me
20:15:39 <int80_h> I can modify xs
20:15:43 <ztirF> ahhh nice
20:15:43 <BMeph> > sortBy (comparing length) ["Howdy","Hello!", "Goodbye!", "Hi!", "Bye!"]
20:15:45 <lambdabot>   ["Hi!","Bye!","Howdy","Hello!","Goodbye!"]
20:16:00 <BMeph> > sortBy (comparing length `mappend` compare) ["Howdy","Hello!", "Goodbye!", "Hi!", "Bye!"]
20:16:01 <lambdabot>   ["Hi!","Bye!","Howdy","Hello!","Goodbye!"]
20:16:04 <cknapp> into80_h: Modify? In Haskell? :)
20:16:19 <cknapp> /s/into/int
20:16:25 <BMeph> > sortBy (comparing length `mappend` compare) ["Howdy.","Hello!", "Goodbye!", "Hi!", "Bye!"]
20:16:26 <lambdabot>   ["Hi!","Bye!","Hello!","Howdy.","Goodbye!"]
20:16:32 <int80_h> okay not modify...
20:16:39 * BMeph breathes a sigh of relief
20:17:28 <ztirF> @hoogle comparing
20:17:28 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
20:17:28 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
20:17:57 <chessguy> int80_h:  want a hint?
20:18:09 <chessguy> Axman6:  seen http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hgalib ?
20:18:19 <BMeph> Axman6: Now if you can use Escardo's searchable type in your algorithms, that'd be spectacular. :)
20:18:31 <Axman6> BMeph: say what now?
20:18:36 <pumpkin> hmm, I'm trying to think of how to implement variance efficiently on UArr
20:18:40 <Axman6> chessguy: nope, but looks good :)
20:19:01 <BMeph> Axman6: http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/
20:19:15 <cknapp> Who posted the life link?
20:19:27 <Axman6> i'll have to check those out later i think :)
20:19:55 <Axman6> is there a Data.List function to replace the nth element of a list?
20:20:45 <chessguy> Axman6:  no, i don't believe so
20:21:28 <cknapp> replace n e x:xs = x: (replace n-1 e xs) --plus proper boundary condition :)
20:21:41 <pumpkin> I'm trying to implement the variance the way dons implemented the mean but it's very difficult :P
20:21:42 <chessguy> @type replace n x xs = take (n-1) xs ++ [x] ++ drop n xs
20:21:43 <lambdabot> parse error on input `='
20:22:11 <pumpkin> chessguy: wouldn't that be more efficient as (x : drop n xs) or does that make no difference?
20:22:19 <pumpkin> oh it's infixr, right?
20:22:30 <chessguy> @type \n x xs -> ake (n-1) xs ++ [x] ++ drop n xs
20:22:31 <lambdabot> Not in scope: `ake'
20:22:48 <chessguy> pumpkin:  i doubt it would matter with laziness
20:23:06 <chessguy> @type \n x xs -> take (n-1) xs ++ [x] ++ drop n xs
20:23:07 <lambdabot> forall a. Int -> a -> [a] -> [a]
20:23:48 <cknapp> You people and your... "haskell thinking"
20:24:33 <chessguy> pumpkin:  probably a better idea in general though
20:28:30 <sw17ch> is it true that the haskell heap only ever grows? no deallocation is done?
20:28:41 <Adamant> no
20:30:03 <mmorrow> no memory is ever released back to the OS (if that's what you meant)
20:30:45 <Adamant> I thought he meant something else
20:31:01 <sw17ch> mmorrow, yes, that's it
20:31:46 <sw17ch> i guess that isn't that big of a problem
20:31:49 <sw17ch> normally, is it?
20:32:22 <cknapp> It depends on what you're doing and how you're doing it. :)
20:32:29 <cknapp> Normally, not.
20:32:31 <sw17ch> well, of course :)
20:32:47 <sw17ch> is the heap usually contiguous?
20:32:57 <sw17ch> and is there a way of making sure the heap stays a certain size?
20:33:02 <sw17ch> ah... fixing it?
20:33:06 <sw17ch> "you have 100 MB and no more"
20:33:24 <mmorrow> i know that on unix ghc gets mem by mmapping /dev/zero, but i'm not sure if this means it's contiguous
20:33:28 <Cale> sw17ch: The garbage collector compacts things from time to time.
20:33:56 <sw17ch> Cale: compacting is fine, but i'm wondering if it's possible to prevent it from using more than X MB
20:34:01 <Cale> Oh, and yes, there's an RTS option for a maximum heap size
20:34:05 <sw17ch> or statically sizing the heap on startup
20:34:42 <Cale> -M<size> Sets the maximum heap size (default unlimited)  Egs: -M256k -M1G
20:34:47 <Cale> -H<size> Sets the minimum heap size (default 0M)   Egs: -H24m  -H1G
20:35:04 <sw17ch> ah, perfect!
20:35:12 <Cale> Any Haskell program compiled with GHC supports those options, after +RTS on the commandline
20:35:27 <sw17ch> yes, i guess i haven't looked hard enough at the RTS options
20:35:39 <Cale> You can see the other available ones using  foo +RTS --help
20:35:43 <cknapp> ghc is a programmer's best friend...
20:35:46 <Cale> (where foo is any Haskell program)
20:35:52 <sw17ch> Are there tools that are used to statically analyze how much memory the program could use?
20:36:01 <mmorrow> sw17ch: you can also link in "char *ghc_rts_options = ..." to get fixed RTS options (i think that's the sym name..)
20:36:28 <cknapp> sw17ch: What do you mean statically? There are profiling options.
20:36:29 <sw17ch> that's handy to know morrow
20:36:42 <sw17ch> statically as in the way a lint tool works
20:37:05 <ksf> lint doesn't do memory analysis.
20:37:07 <mmorrow> the times i've done that i stuck it in a one-line .c and it worked nicely
20:37:18 <sw17ch> ksf, i just threw that out as an example of static tools
20:37:26 <sw17ch> i'm aware of what lint does
20:37:28 <ksf> i'd doubt static analysis is possible, smells like the halting-problem to me.
20:37:44 <sw17ch> oh, there are of course cases where you can't
20:37:50 <sw17ch> but you should be able to come up with a lower bound
20:38:00 <sw17ch> some functions it can be discovered for
20:38:10 <ksf> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
20:38:28 <ksf> ...and there are loads of tools and tutorials accompying it.
20:38:36 <Axman6> what would this be in haskell (from python)? graded = [ x[1] for x in sorted(graded)] (the sorted graded is a [[a]])
20:38:37 <ksf> eg. rwh and dons blog.
20:38:39 <sw17ch> i don't really want a profiler in this case though
20:39:03 <Twey> Axman6: graded = map (!! 1) (sort graded)
20:39:11 <sw17ch> i'm aware of how to use the profiler... i just want a set of static analysis tools
20:39:15 <Twey> Er, except with different identifiers, obviously.
20:39:21 <Axman6> Twey: cheers
20:39:43 <sw17ch> i'm curious if they exist yet, or if that's something i'd have to chase down on my own
20:39:43 <Twey> Literally, with an LC, graded = [ x !! 1 | x <- sort graded ]
20:41:42 <Axman6> and parents = graded[:retain_length]?
20:41:50 <Axman6> tahe or drop retainLength?
20:41:53 <Axman6> take*
20:42:14 <Twey> parents = take retainLength graded
20:42:43 <Axman6> thanks
20:42:49 <Twey> No problem
20:44:21 <Cale> Axman6: however, do you *really* want that recursive definition of graded?
20:44:47 <Axman6> Cale: nope, so i made it graded' =...
20:44:53 <Cale> yeah.
20:45:23 <Cale> graded' = [x | (_:x:_) <- sort graded]
20:45:30 <Cale> that would also work
20:47:19 <Axman6> hmm, i think i'm going to have to rework evolve on http://lethain.com/entry/2009/jan/02/genetic-algorithms-cool-name-damn-simple/ to be more haskellish if i want to use it, it's getting too long, and i'm less than a third of the way through converting it
20:49:16 <mmorrow> it seems pointless to sort if you only want the second smallest element
20:49:17 <twb> I'm compiling GHC 6.10 in a VM.  If I give the VM 4GB instead of 1GB of RAM, will it build faster?
20:49:20 <mmorrow> O(n lg n) vs. O(n)
20:49:24 <mmorrow> well, i guess laziness'd give you O(n) back (maybe..)
20:49:26 <mmorrow> but with a larger constant surely
20:51:00 * ksf is looking for withRealTimeE and can't find it.
20:51:40 <ksf> like, you might want to launch missiles only at exactly 13:00.
20:51:42 <edwardk> mmorrow: taking the first k element from a sort in haskell has the same asymptotic cost as performing selection of the k smallest elements. constants suck as usual but sorting to extract kth smallest,  etc isn't that terrible.
20:52:03 * edwardk realizes he doesn't have the entire context and goes to check the logs
20:52:30 <Axman6> hmm, finding this a little more difficult to haskellise:
20:52:31 <Axman6> for individual in graded[retain_length:]:
20:52:31 <Axman6>         if random_select > random():
20:52:31 <Axman6>             parents.append(individual)
20:52:54 <rwbarton> Axman6: probably some sort of filterM
20:52:59 <Axman6> random_select i'm passing to the functon as rnd
20:53:04 <Axman6> rwbarton: ah, good idea
20:53:30 <ksf> conal, are there any guarantees given for some TimeT increment to correspond to some particular real-world measure?
20:54:40 <Twey> :t filterM
20:54:41 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
20:55:40 * edwardk wants functional reactive relativity... where you have to sample with both a time and a position for it to make sense ;)
20:58:35 <Axman6> @hoogle comparing
20:58:35 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
20:58:35 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
20:59:06 <edwardk> where you can see info from an event if it causally precedes the response. pedantically it might solve some infinite self-referential loops, since you have to observe something from a different point in space, making an argument that two actors responses can't be based on the insantaneous evaluation of each other's responses
21:00:02 * edwardk puts down the physics and backs away slowly.
21:00:19 <twb> Waah!
21:00:20 <twb> [   98.794201] Kernel panic - not syncing: Out of memory and no killable process
21:00:33 <edwardk> hrmm, how would that affect Futures... no, no... stop stop stop..
21:01:23 <rwbarton> edwardk: It sounds not entirely unlike having two Reactives on different computers communcating over a network
21:01:27 <edwardk> yeah
21:02:33 <edwardk> i had that thought, the nice thing is you can fix the bottoms that can occur between circular dependencies by having a pauli exclusion principle. no two actors can be in the same space at the same time, then any mutual observers would have to have a delay. ;)
21:03:44 <ddarius> So Cale, what is the full definition of a "category ring" and has someone done it before?
21:03:45 <ksf> now here comes a noob question... how do I format a Fractional to n decimal digits?
21:04:30 <intoverflow> ksf: http://haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html#v:showEFloat
21:04:55 <intoverflow> ...and the functions near there, of course
21:05:11 <rwbarton> ddarius: Cale's definition is the second one on this page: http://en.wikipedia.org/wiki/Categorical_algebra
21:05:28 <ksf> those beat snprintf by leagues.
21:05:54 <Axman6> rwbarton: thanks for the filterM idea, seems like it'll do the trick
21:06:24 <ddarius> Coolsville
21:06:48 <ddarius> > printf "%f" pi :: String
21:06:49 <lambdabot>   "3.141592653589793"
21:07:21 <BMeph> Axman6:
21:07:38 <ddarius> Everybody loves partial magmas.
21:09:29 * ksf is happy, he's got an fps display.
21:11:21 <cknapp> Night everyone, thanks for the lesson on monoid rings and category rings. :)
21:14:43 <Axman6> bah, python programmers need to learn to break things up into functions more often
21:15:01 <Axman6> i do no like 38 line functions >_<
21:15:36 <Ralith> Axman6: 38 is short for imperative code.
21:15:43 <Axman6> yeah :\
21:15:52 * Axman6 needs a py2hs converter
21:15:55 <Ralith> heh
21:16:22 <Axman6> trying to convert evolve on http://lethain.com/entry/2009/jan/02/genetic-algorithms-cool-name-damn-simple/ and it's not fun
21:16:45 <Axman6> struggling to see what functions i  need to write
21:19:28 <pumpkin> dons: I think I came up with pretty decent UArr var and stddev
21:19:58 <Axman6> pumpkin: you know python right?
21:20:09 <pumpkin> I vaguely do, haven't ever written much in it
21:20:14 <pumpkin> more of a ruby guy
21:20:14 <pumpkin> why?
21:20:50 <Axman6> want to pawn off converting this python function into haskell :P
21:21:04 <pumpkin> lol
21:21:06 <pumpkin> what is it?
21:21:29 <Axman6> evolve on http://lethain.com/entry/2009/jan/02/genetic-algorithms-cool-name-damn-simple/
21:21:40 <pumpkin> ah :)
21:21:47 <pumpkin> I thought you were doing that for the educational value in the first place?
21:22:10 <Axman6> yeah, but not the pait of converting inperative code to functional :\
21:22:17 <pumpkin> like what?
21:22:20 <Olathe> > 96 + 65
21:22:21 <lambdabot>   161
21:22:50 <Axman6> pain*
21:23:04 <pumpkin> @seen dons
21:23:04 <lambdabot> dons is in #novalang, #haskell, #ghc, #concatenative, #darcs, #xmonad and #arch-haskell. I last heard dons speak 4h 7m 5s ago.
21:23:06 <Olathe> > [239, 189, 161]
21:23:07 <lambdabot>   [239,189,161]
21:23:10 <pumpkin> ack
21:23:20 <pumpkin> I'm so excited about my uarr stats
21:23:31 <Axman6> pumpkin: did you take a look at evolve? it's a massive function compared to most haskell ones, and it's full of for loops :(
21:24:06 <pumpkin> not too bad, really
21:24:15 <pumpkin> the randomness makes it kinda icky though
21:24:28 <Axman6> nah i've got randomness worked out ok
21:24:41 <pumpkin> I don't do impure code, sorry
21:24:42 <pumpkin> ;)
21:24:46 <Axman6> it's just the population processing that'd difficult
21:25:12 <Axman6> s*
21:25:21 <Axman6> far out my typing's terrible today
21:27:26 <Olathe> > ''
21:27:27 <lambdabot>   '\65313'
21:27:54 <ddarius> Blech.  Let's use comments instead of procedural abstraction.
21:32:00 <BMeph> Axman6: I just looked at that article you referred to, and the first two lines are a clunky execution of a Schwartzian Transform. Seeing the preceding line helps to see what's going on... ;)
21:32:30 <Axman6> BMeph: yeah i turned it into takeTop target xs = [ x !! 1 | x <- sortBy (comparing (fitness target)) xs]
21:32:55 <Axman6> though i'm unsure whay i'm supposed to get back. i have a feeling it should be [[a]] not [a]
21:34:12 <Axman6> ah, i get it, x[1] refers to the list
21:34:35 <Axman6> so all i really need is takeTop target xs = sortBy (comparing (fitness target)) xs
21:35:21 <BMeph> Axman6: ...er, that x[1] is the original graded list. the preceeding line turns the list into a list of pairs, which sorted sorts by. Then the line you mentioned strips off the sorting data to give the original list, just sorted by the fitness function.
21:35:45 <Axman6> yep :)
21:35:48 <BMeph> Axman6: It's not as difficult as you're trying to make it; Python's just that difficult to weild. :p
21:35:50 <ddarius> takeTop = sortBy . comparing . fitness
21:37:42 <BMeph> Er, *wield. Someday, I will learn to get the correct finger of the two I'm using to type first. Really... :\
21:38:29 <ddarius> BMeph: Your fingers are poorly coordinated, concurrent actors.  Race conditions are to be expected.
21:40:35 <BMeph> ddarius: Dude, you have to stop chugging that Erlang Kool-Aid, it's rotting your brain. ;p
21:40:44 <Axman6> ha
21:42:33 <ksf> what's a good blog provider that a) supports hscolour and b) isn't owned by google or any other data miners?
21:43:08 <BMeph> Axman6: Okay, if you "know" what's going on,...what's with the 'x !! 1' aftefact? :)
21:43:44 <Axman6> BMeph: keep up, i already said i removed it :P
21:46:30 * BMeph catches up.
21:49:20 <mriou> hi, I was looking for a monadic version for foldr, just like mapM for map
21:49:31 <mriou> is there one? couldn't find it
21:49:39 <pumpkin> :t foldM
21:49:40 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
21:49:41 <dolio> @type foldrM
21:49:42 <lambdabot> Not in scope: `foldrM'
21:50:01 <mriou> yeah, I tried that :)
21:50:17 <mriou> I looked in hoogle
21:50:28 <sjanssen> mriou: it is easy to make a monadic fold out of foldr
21:50:30 <dolio> foldrM and foldlM are in Data.Foldable.
21:50:31 <sjanssen> what type do you want?
21:50:55 <dolio> foldM is Control.Monad, I believe.
21:51:23 <ddarius> @hoogle foldM
21:51:24 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
21:51:24 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
21:51:24 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
21:51:31 <mriou> sjanssen: what type of?
21:52:12 <sjanssen> mriou: what type do you want for your fold function
21:52:30 <mriou> dolio, ddarius: perfect thanks
21:52:44 <mriou> sjanssen: folding over a classic list
21:54:27 * ddarius recommends that sjanssen just leave it alone.
21:55:33 <sjanssen> yes, I came to that conclusion :).  If you've got a library function that does what you need, no reason to look further
21:56:39 <mriou> ddarius, sjanssen: although I don't like when I don't understand the question :)
21:57:15 <sjanssen> mriou: I meant "type" as in "the type of the function"
21:57:18 <sjanssen> @type foldr
21:57:19 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
21:58:24 <mriou> I see: (a -> b -> m b) -> b -> [a] -> m b
21:59:20 <sjanssen> @type \f z xs -> foldr (\x xs -> xs >>= f x) z xs
21:59:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m b) -> m b -> [a] -> m b
22:01:26 <mriou> sjanssen: got it, thanks for the explanation
22:06:48 <pumpkin> quiet in here :(
22:07:14 <Trafalgard> Uh, before I say anything, are we allowed to curse?
22:07:31 <Trafalgard> not in response to what you just said, mind you
22:07:42 <pumpkin> don't think it's disallowed
22:07:49 <pumpkin> but I don't think it's encouraged :P
22:07:57 <Heffalump> Trafalgard: I don't think there's any explicit prohibition, though there is a general feeling that the place should have a friendly atmosphere.
22:09:29 <SamRH> "mitten"
22:10:12 <Trafalgard> Well, I wanted to use visual haskell, except I don't have visual studio, and use the express editions of visual c# or c++, but it isn't compatible with those
22:10:13 <Trafalgard> however
22:11:11 <Trafalgard> microsoft released a visual studio 2008 shell thing which basically means that people don't need visual studio if it were written for that instead
22:11:11 <Axman6> whoot! finally got this evolve function working (i think)
22:11:54 <Trafalgard> it's basically the visual studio 2008 framework with no languages in it, but with the plugin capability
22:12:59 <Trafalgard> but there's a problem
22:13:27 <Trafalgard> someone has to update it to work with visual studio 2008
22:14:50 <Trafalgard> I downloaded the visual haskell source from darcs and poked it, but neither visual c++ express 2008 nor 2005 particularly like the fact that there's a haskell project in the solution
22:14:50 <Trafalgard> there's no chicken to lay the egg
22:15:49 <Trafalgard> I ignored that for the moment and fixed vs 2008 so it was looking for the includes in the right places and such, and then got what prompted me to ask if cursing was around
22:15:52 <Trafalgard> *allowed
22:16:16 <Trafalgard> since my reaction was basically "FFS"
22:17:33 <Trafalgard> 687 errors, being things like error C2440: 'return' : cannot convert from 'const char *' to 'AnsiStr'
22:18:25 <Trafalgard> Those are probably fixable en masse
22:19:07 <Trafalgard> but I have NFC what prompted this: error C2065: '_Module' : undeclared identifier, and...
22:19:09 <Trafalgard> ... wtf
22:19:25 <Trafalgard> that's in an include file in a [Censored!] microsoft SDK
22:19:50 * Trafalgard mutters
22:20:17 <Trafalgard> guess I need a more up to date platform sdk or something.
22:20:39 <Trafalgard> still, that's weird.
22:29:21 <Axman6> anyone know how to write a function iterateIO :: (a -> IO a) -> a -> IO [a]?
22:30:05 <rwbarton> If you want it to ever return, you'll have to use unsafeInterleaveIO
22:30:37 <Axman6> well i want to use take on it. maybe -
22:30:47 <Axman6> well i want to use take on it. maybe -> [IO a]
22:31:12 <SamRH> still can't
22:31:33 <scook0> what are you actually trying to achieve?
22:32:06 <Heffalump> I think if [IO a] is ok you can do it with join
22:32:26 <Heffalump> @let iterateIO f x = iterate (join . f) (return x)
22:32:26 <Axman6> evolving a population, which uses random numbers, so i need it to be in IO
22:32:27 <lambdabot>  Defined.
22:32:31 <Heffalump> @type iterateIO
22:32:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => (m a -> m (m a)) -> a -> [m a]
22:32:46 <Heffalump> @let iterateIO f x = iterate (join . liftM f) (return x)
22:32:47 <lambdabot>  <local>:8:49:
22:32:47 <lambdabot>      Occurs check: cannot construct the infinite type: a = m a...
22:32:59 <Heffalump> @let iterateIO f x = iterate (>>= f) (return x)
22:33:00 <lambdabot>  <local>:8:40:
22:33:00 <lambdabot>      Occurs check: cannot construct the infinite type: a = m a...
22:33:10 <rwbarton> @undefine iterateIO
22:33:18 <Heffalump> hmph
22:33:19 <rwbarton> @let iterateIO f x = iterate (join . liftM f) (return x)
22:33:20 <lambdabot>  Defined.
22:33:23 <Heffalump> oh, right :-)
22:33:29 <Heffalump> anyway, >>= is superior.
22:33:32 <Heffalump> @type iterateIO
22:33:33 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m a) -> a -> [m a]
22:33:37 <Heffalump> so yeah
22:33:51 <SamRH> Axman6 you can use random numbers outside of IO..
22:34:06 <Axman6> i'd have to rewrite a lot of code :\
22:34:54 <int80_h> @last dons
22:34:54 <lambdabot> No module "dons" loaded
22:34:59 <int80_h> @wheren dons
22:34:59 <lambdabot> Maybe you meant: where where+
22:35:03 <int80_h> @when dons
22:35:04 <lambdabot> Maybe you meant: seen what where wn
22:35:09 <int80_h> @seen dons
22:35:10 <lambdabot> dons is in #novalang, #haskell, #ghc, #concatenative, #darcs, #xmonad and #arch-haskell. I last heard dons speak 5h 19m 11s ago.
22:35:35 <pumpkin> int80_h: o.O
22:36:10 <int80_h> pumpkin: dons was helping me with problem 6, page 70
22:36:29 <scook0> do you perhaps want something along the lines of Int -> (a -> IO a) -> a -> IO a?
22:36:56 <int80_h> pumpkin: I had had two list of lists for parameters, and he said I could get by with just one
22:37:36 <int80_h> pumpkin: so I wanted to know if I only need one paramter total, or if I need another paramter to keep track of list position
22:38:14 <int80_h> I want to render the simplest solution, within what the book has presented so far.
22:38:25 <pumpkin> trying to find my copy but I can't
22:38:30 <pumpkin> that'll teach me to clean up
22:38:44 <int80_h> pumpkin: want the url?
22:38:51 <pumpkin> sure, if you have it handy
22:39:07 <pham> anybody here used hsc3 (SuperCollider API)?
22:39:17 <BMeph> int80_h: You may want to re-read those chapters, if only to gather more of the "zen" of writing in Haskell.
22:39:41 <int80_h> http://book.realworldhaskell.org/read/
22:39:54 <int80_h> BMeph: well, I have a solution, but it's not as simple as it could be
22:39:58 <Axman6> basically, i take in a population, and evolve it, into an IO Population, and i need a list of populations (or IO Populations) based of the previous populations
22:40:09 <BMeph> int80_h: Think more about what the goal of the program is, and not so much on what details the computer will need to keep track of in order to get it done. :)
22:40:43 <pumpkin> dem's fighting words!
22:40:45 <pumpkin> oh wait, wrong one
22:40:50 <pumpkin> wise words indeed, is what I meant
22:40:56 <pumpkin> :P
22:42:00 * BMeph looks at the plate before him: how did pumpkin serve up a ROFL falafel? ;p
22:42:09 <Ralith> rofalafel
22:42:31 <int80_h> I can do that transformation, in 3 moves
22:43:05 <BMeph> int80_h: If you're trying to "keep track of list position", you're thinking too hard about how to get the computer to do what you want, instead of just what you want the computer to do. :)
22:43:09 <int80_h> okay, no one here ever watches "name that tune"
22:43:23 <pumpkin> lol
22:45:26 <int80_h> BMeph: hmm, I've sorted by hand a list using the method I think I would need. Maybe it's the wrong method
22:45:36 <Axman6> hmm, uess i should just write a function to evolve until i reach the desired point
22:46:53 <ksf> is there a way for the haskell wiki syntax highlighting to generate links to hackage docs?
22:47:22 <BMeph> int80_h: Hm, I may have to read the preceeding chapters myself, just to see 1) what the guys expect you to use to solve it, and 2) what's the attitude they're cultivating. :)
22:47:27 <gnut> ls
22:47:29 <gnut> hi
22:47:48 <gnut> anyone here run xmonad with the new ghc 6.10.1 ?
22:49:00 <ksf> not yet, but didn't try, either. Recently a bug concerning this was fixed, I saw it on the mailing list.
22:49:21 <ksf> if in doubt, use the darcs version and/or ask in #xmonad.
22:49:21 <int80_h> BMeph: I expect to solve this with ++, head, last and tail
22:49:28 <int80_h> either some or all of those
22:49:39 <int80_h> perhaps I need drop
22:50:29 <int80_h> hold on, it's coming to me I think
22:51:28 <gnut> ksf: I did ask. I guess everyone's asleep.
22:52:11 <gnut> but if you say a fix was found, then I'll try darcs to get it.
22:53:09 <pumpkin> my UArr variance/stddev function is around 9 times faster than the list version :D and it can actually work on large lists, whereas the Math.Statistics ones runs out of stack space
22:53:22 <int80_h> I'm pretty sure I've almost got this
22:53:31 <Ralith> pumpkin: submit it in a patch?
22:53:54 <BMeph> pumpkin: Pimp Yo' Sigma! ;)
22:54:08 <pumpkin> Ralith: I've @tell'ed it to dons, waiting for him to come back and make it even more awesome :)
22:54:19 <Ralith> cool.
22:54:30 <pumpkin> and he's the maintainer of statistics-fusion
22:57:54 <mmorrow> pumpkin: the math-stats one uses foldr instead of foldl' iirc :(
22:58:11 <pumpkin> mmorrow: the var in there is explicitly recursing
22:58:19 <pumpkin> I took a peek to see if it was worth basing my UArr one on it
22:58:24 <pumpkin> but it was scary
22:58:35 <mmorrow> ah, i don't recall the stddev one.
22:58:37 <pumpkin> and I don't trust myself to recurse by hand on something like a UArr
22:58:38 <mmorrow> yeah, scary
22:59:07 <int80_h> ugh, I can do this with two list of lists, but not one
23:00:21 <Raevel> int80_h: what was the excercise?
23:00:27 <intoverflow> yeah, now I'm curious
23:01:15 <pumpkin> me too :P
23:01:21 <int80_h> it's from RWH
23:01:44 <pumpkin> mmorrow: I hear you're in on sbahra's SIMD project too?
23:01:45 <int80_h> "Create a function that sorts a list of lists based on the length of each sublist
23:02:06 <pumpkin> int80_h: are you allowed to use everything in Data.List? :P
23:02:14 <pumpkin> (and possibly Data.Ord)
23:02:25 <int80_h> I can do it this way sortLists :: [[a]] -> [[a]] -> [[a]]
23:02:30 <mmorrow> pumpkin: i talked with him about it, but am too overflowed with stuff atm :(
23:02:35 <mmorrow> very interesting though
23:02:51 <pumpkin> mmorrow: oh no! it would be even more awesome to make something like a UArr that outputs vectorized code :D
23:02:52 <int80_h> pumpkin: no, that's just a clue. I'm stuck with head,tail,drop,length
23:03:07 <int80_h> and a few other functions from the begining of the book
23:03:28 <Raevel> and what do they want, [[a]] -> [[a]] i presume?
23:03:30 <pumpkin> int80_h: :o, not even sort? they want you to write your own sorting algo? need it be efficient?
23:03:38 <mmorrow> pumpkin: that would rock!
23:03:53 <int80_h> Ravel: well dons said I should do it that way. I want to have the simplest solution
23:04:06 <int80_h> pumpkin: no, doesn't need to be efficient
23:04:12 <mmorrow> i think it'd be especially cool too if said type generated mmx and/or sse code dynamically at runtime
23:04:26 <mmorrow> a la harpy
23:04:28 <pumpkin> mmorrow: !
23:04:29 <Raevel> int80_h: what are your arguments in [[a]] -> [[a]] -> [[a]] ?
23:04:30 <int80_h> Raevel: I mean, the way you said [[a]] -> [[a]]
23:04:33 <pumpkin> that would be insane :P
23:04:43 <pumpkin> mmorrow: let's throw in gpugen while we're at it :D
23:04:50 <mmorrow> imagine the crazy shit you could write with that :)
23:05:02 <int80_h> pumpkin: you mean I should keep it the ay I had it? because I'm pretty sure I can handle that
23:05:05 <pumpkin> it'll compute it faster than you can think of how to compute it
23:05:32 <mmorrow> *poof*... and yer mind meltz
23:05:34 <pumpkin> int80_h: the insane comment was for mmorrow :) it was a positive insane :)
23:05:59 <pumpkin> int80_h: so how are you doing it? can you paste some code?
23:06:07 <int80_h> Raevel: I stopped working on the function with the old typedef, when dons said it was too complicated. I worked a list out by hand using two lists though. It's easy enough, if perhaps more complicated than it needs to be
23:06:08 <BMeph> int80_h: Just curious, but did dons ever mention the phrase "worker-wrapper" to you? ;)
23:06:28 <int80_h> BMeph: no, do I need a helper function for this?
23:07:29 <BMeph> int80_h: I assumed that since you're using a two-argument function, that it /was/ the helper function. :)
23:08:25 <int80_h> BMeph: no, I had two lists, I built a sorted list from the unsorted list
23:08:46 <int80_h> BMeph: to be clear, I'm not doing it that way anymore
23:09:01 <int80_h> I'm trying it this way [[a]] -> [[a]]
23:10:59 <pumpkin> you allowed to use the typical higher-order functions? fold,map,filter, etc.?
23:11:36 <int80_h> pumpkin: nope
23:11:38 <int80_h> I wish
23:11:45 <pumpkin> ack :)
23:11:54 <int80_h> see why I want two lists
23:12:06 <Raevel> obviously the outermost function should be [[a]] -> [[a]], but i don't see why a helper that' [[a]] -> [[a]] -> [[a]] would be "too complicated", you'd probably end up with a selection sort?
23:13:17 <int80_h> Raevel: yeah I had selection sort in mind. dons said there was a simpler solution, so I was intrigued
23:13:41 <int80_h> plus I'm a perfectionist, and if there's a better way that's the way I want.
23:13:48 <intoverflow> [l | l <- foo, length l == 1] ++ [l | l <- foo, length l == 2] ++ ...
23:14:17 <pumpkin> wouldn't that look nicer as a filter?
23:14:31 <pumpkin> oh you can't use filter but you can use list comprehensions?
23:14:39 <int80_h> no lists comprehensions
23:14:43 <intoverflow> hrmph
23:14:48 <int80_h> I know I know
23:14:57 <pumpkin> we've all forgotten how to write raw haskell code, sorry :P
23:15:04 <Raevel> yes :*/
23:15:05 <Twey> Haha
23:15:09 <Twey> :t sortBy
23:15:10 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
23:15:21 <int80_h> leave it to a newbie to remind you of the fundamentals.
23:15:22 <Twey> sortBy (comparing length) foo
23:15:43 <pumpkin> Twey: epicly disallowed, sry
23:15:46 <intoverflow> I'm going to go consult MacLane, surely there's a universal arrow for this
23:15:46 <Twey> :(
23:16:04 <Raevel> but oh, it's time to get my javascript on
23:16:07 <pumpkin> dammit, I need two more twitter followers
23:16:20 <intoverflow> pumpkin: I'll follow, what's your handle?
23:16:24 <pumpkin> pumpkingod :P
23:16:26 <int80_h> okay I'll settle for doing my clumsy selection sorty, then we can raid dons' brain for a better solution
23:16:27 <matthewp> I only have 556
23:16:28 <pumpkin> thanks! :)
23:16:40 <pumpkin> matthewp: "only" :P
23:16:53 <matthewp> yeah, mattpodwysocki go figure
23:17:03 <matthewp> why people listen to me....
23:17:22 <pumpkin> oh no, I can't diss microsoft in front of you
23:17:23 * pumpkin hides
23:17:44 <int80_h> hey microsoft is promoting haskell aren't they?
23:17:49 <int80_h> which is wierd, I know
23:18:00 <pumpkin> that's where most of the haskell research comes from :P
23:18:02 <matthewp> This was fun, isolating the IO monad for HDBC transactions http://hpaste.org/13774
23:18:03 <intoverflow> MSR does a lot of great stuff
23:18:38 <matthewp> yeah, we've put a few $$ into things
23:18:47 <pumpkin> > succ $ maxBound :: Int -- can I highlight you like this?
23:18:49 <lambdabot>   * Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
23:20:24 <matthewp> is it me or is twitter acting really flaky lately?
23:20:50 <sjanssen> lately?
23:21:02 <sjanssen> every so often I get an "over capacity" message
23:21:08 <sjanssen> (ruby, lol)
23:21:20 <intoverflow> ruby is lolx0rz
23:21:23 <matthewp> I haven't gotten the fail whale yet, but sending messages has failed quite a bit
23:21:37 <pumpkin> intoverflow: you didn't notice :(
23:21:43 <pumpkin> my epic highlight
23:21:46 <matthewp> I thought they rewrote parts in Scala, no?
23:22:07 <sjanssen> really?  That is an interesting choice
23:22:07 <intoverflow> pumpkin: bwahahahahaha wow I just got it
23:22:19 <intoverflow> man, I *must* be tired
23:22:23 <pumpkin> :P
23:22:26 <vegai> int80_h: promoting, how?
23:22:28 <pumpkin> it was pretty lame, I must admit
23:22:39 * vegai imagines an ad: "Hi, I'm C++. And I'm Haskell"
23:22:42 <BMeph> Raevel: Did you mean insertion source? :)
23:22:46 <int80_h> vegai: like pumpkin said, most haskell research comes from them
23:22:58 <vegai> yes, ok
23:23:00 <intoverflow> vegai: except Haskell is lazy, so it'd be more like "Hi, I'
23:23:12 <intoverflow> well thanks, Shift, for taking down all comedic timing
23:23:22 <pumpkin> lol
23:23:25 <Ralith> intoverflow: more like
23:23:36 <Ralith> "Hi, I'm C++. Uh, Haskell was supposed to be here by now..."
23:23:49 <pumpkin> omg just one follower away from 500!
23:23:52 <intoverflow> I'm !Haskell
23:23:56 <vegai> would C++ be a really big fella?
23:24:09 <int80_h> pumpkin: how did you get 500?
23:24:17 <Ralith> give him one of those huge steel-frame hiking backpacks
23:24:22 <pumpkin> int80_h: only 499 :(
23:24:35 <int80_h> vegai: yeah he'd be the guy you need to bulldoze a walls down to get him out of bed when he died.
23:24:37 <pumpkin> int80_h: I created 498 accounts and then asked intoverflow to follow me :/
23:24:49 <intoverflow> hahaha
23:24:50 <intoverflow> yeah
23:25:30 <pumpkin> int80_h: mostly cause I'm linked from the iphone dev team blog and it gets a lot of traffic
23:25:39 <BMeph> More like, (C++) "Hi, I'm C++. Haskell was supposed to - <Haskell appears in a bright beam of light> - (Haskell:) "...save the day? Well, that's kind of cliche, isn't it? ;)"
23:25:44 <int80_h> pumpkin: you work at apple?
23:25:48 <pumpkin> lol no
23:25:50 <int80_h> I live in palo alto :)
23:26:04 <pumpkin> ah cool :)
23:27:01 <int80_h> I need a new handle
23:27:19 <pumpkin> you find yourself interrupting too often with this one? :P
23:27:24 <int80_h> I was thinking 'knf'
23:27:42 <intoverflow> you're already the systemcall interrupt
23:27:44 * int80_h groans...
23:27:47 <intoverflow> you could just becomse System.IO
23:27:55 <vegai> perhaps C++ should be juggling chainsaws while talking
23:28:13 <Twey> What is C, then?
23:28:22 <vegai> ahh
23:28:32 <intoverflow> vegai: I can't wait to see how the commercial handles a null pointer reference
23:28:35 <vegai> C = Teller, C++ = Penn
23:28:38 <Twey> Heheh, I like the idea of an Apple-style Haskell commercial
23:28:44 <pumpkin> int80_h: maybe call yourself sysenter or syscall?
23:28:48 <vegai> I wonder how expensive those two would be
23:28:55 <pumpkin> or swi if you're feeling adventurous
23:29:38 <int80_h> hmm syscall...generic enough
23:29:46 <Ralith> now we just need someone with a studio.
23:29:57 <int80_h> I know people locally
23:29:59 <pumpkin> int80_h: sysenter is still correct but a little more searchable
23:35:33 <BMeph> int80_h: Maybe take a feather from Dan Piponi's cap, and call yourself sigalm. ;)
23:35:49 <pumpkin> what's with the sigs?
23:36:48 <BMeph> Sorry, *sigalrm. ;)
23:38:13 <Saizan_> ooh, never connected sigfpe with SIGFPE! (mostly because i'm not familiar with the latter)
23:41:02 <chrisdone> mmorrow: got a good email validating regex?
23:41:17 <intoverflow> is there a "smart" way to do network programming in Haskell?
23:43:47 <intoverflow> the obvious way just doesn't feel very haskell at all
23:44:25 <Saizan_> what part of it? parsing data from a socket or managing connections in the first place?
23:44:48 <intoverflow> the low-level business, like managing connections
23:45:15 <intoverflow> though parsing as well, I suppose
23:45:18 <pumpkin> alright, time for bed
23:45:33 <pumpkin> g'night!
23:45:59 <intoverflow> I mean, it's more complicated for all of the classic reasons: timing, reliability, etc
23:46:16 <intoverflow> It's just surprising that there isn't a better way to build an interface
23:46:50 <vegai> intoverflow: RWH has something about that
23:46:54 <Saizan> i think there hasn't been much work on making a nicer abstraction
23:47:10 <vegai> but quite low level as well.
23:47:17 <Saizan> the problem is that abstractions over the network tend to be very leaky
23:47:23 <intoverflow> yeah
23:47:34 <vegai> even in erlang you have to go through some hoops to get tcp/ip connections, iirc
23:48:03 <vegai> if you need something more than just erlang messages, that is
23:48:16 <Saizan> a good approach might be something like widgets
23:48:32 <vegai> we should all be running plan9, then it'd be rather simple :P
23:48:48 <intoverflow> I refuse to use any software named for the WORST MOVIE EVER MADE
23:49:11 <intoverflow> best foot forward, and all
23:49:18 <vegai> intoverflow: lookup "Manos: Hands of Fate"
23:49:24 <Saizan> i.e. premade servers/clients in multiple variants that you can hopefully customize without a great loss of performance
23:49:46 <int80_h> heh, I've been googling dan piponi
23:50:30 <intoverflow> "directed and produced by... a fertilizer salesman from El Paso, Texas."
23:50:47 <int80_h> I have to assert that Kevin COnsner has been in worse movies than Plan9 from Outer Space.
23:50:56 <int80_h> Cosner
23:51:55 <intoverflow> Saizan: for network protocols with simple state diagrams, there really should be tools for generating a protocol-specific API automatically, the same way we can build parsers automatically for certain languages
23:52:04 <vegai> intoverflow: also, amusingly... http://www.codebeach.com/item/Source-Code/C-Plus-Plus/Operating-Systems/MANOS-Open-Source-Network-Operating-System-691.asp
23:52:21 <vegai> I wonder if the acronym is an accident
23:52:25 <intoverflow> I'd be surprised if this hasn't already been investigated
23:52:58 <CakeProphet> The choice of names for Maybe's value constructors is a little weird.
23:53:16 <CakeProphet> Nothing makes sense. But Just?
23:54:27 <intoverflow> CakeProphet: what'd be better?  OhHereItIs ?
23:54:33 <vixey> Some
23:54:37 <Saizan> intoverflow: so true, though i find that there isn't even something like that for [de]serializing packets!
23:54:55 <intoverflow> yeah, it's a sad state of affairs
23:55:05 <CakeProphet> rofl. Stuff.
23:55:11 <CakeProphet> Stuff and Nothing.
23:55:25 <CakeProphet> once I implement a compiler for CakeHaskell.
23:55:58 <intoverflow> data Maybe a = Stuff a | SorryBud
23:56:00 <Saizan> it's a library problem, more than a compiler one
23:56:02 <mm_freak_> is there a memory-efficient way to save a fully evaluated list?
23:56:13 <mm_freak_> currently i'm using UArray, but that seems inelegant to me
23:56:45 <CakeProphet> data Maybe a = Something a | Nothing   would be nice, if a bit more verbose.
23:57:04 <CakeProphet> but Just is fine. -shrug-
23:57:42 <Saizan> i imagined you were going to abandon the language because of this :)
23:58:19 <vegai> aww, why cannot UTCTime have a Show instance
23:58:20 <chrisdone> Kevin Conser/Cudder
23:58:39 <chrisdone> vegai: I thought that yesterday
23:59:06 <chrisdone> vegai: presumably because it'd have to default to something for the format function
23:59:08 <vegai> well, I suppose Date.Time.Format will have to do
23:59:12 <vegai> aye
23:59:34 <vegai> might just as well be some RFC/IEEE/whatnot standard
23:59:41 <chrisdone> sure
