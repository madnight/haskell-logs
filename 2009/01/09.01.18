00:07:07 <Lemonator> How would I call Haskell library functions from C?
00:07:57 <kmeyer> Lemonator: carefully
00:07:59 <nikki93> Ok, final version:
00:08:00 <nikki93> find53Sum upperLimit = (sum union) - (sum intersect)
00:08:00 <nikki93>     where union = [3,6..(upperLimit - 1)] ++ [5,10..(upperLimit - 1)]
00:08:00 <nikki93> 	  intersect = [15,30..(upperLimit - 1)]
00:08:05 <kmeyer> Lemonator: http://haskell.org/haskellwiki/Calling_Haskell_from_C
00:08:12 <kmeyer> you add wrappers.
00:08:36 <nikki93> Writing programs to solve Project Euler problems is a GREAT way to learn haskell.
00:08:41 <pumpkin> yeah :)
00:08:50 <pumpkin> that's how I learned most of it
00:08:58 <Lemonator> oh hey
00:09:00 <Lemonator> thanks.
00:09:02 <nikki93> Learning Haskell IS usefull (for me) right? (no offence to haskell ro anything)
00:09:11 <Ralith> @src groupBy
00:09:11 <lambdabot> groupBy _  []       =  []
00:09:11 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
00:09:11 <lambdabot>     where (ys,zs) = span (eq x) xs
00:09:14 <pumpkin> depends what you consider useful ) I'd say yes :P
00:09:24 <nikki93> I'm a school student who writes 3d games as a hobby.
00:09:25 <pumpkin> it's a new way of thinking about things
00:09:26 <nikki93> Useful?
00:09:38 <pumpkin> if you want to write a 3d game with it, probably not immediately useful
00:09:40 <vegai> it's probably impossible to learn anything that *cannot* be useful
00:09:41 <pumpkin> but in the long run, yup
00:09:56 <Lemonator> wai
00:09:57 <Lemonator> t
00:09:58 <nikki93> pumpkin: No, don't wanna write a 3d game with it.
00:10:09 <vegai> even learning things that are wrong might have some benefit in the future..
00:10:10 <nikki93> pumpkin: But it'll probably be a good experience in... Logical thinking and stuff.
00:10:21 <pumpkin> nikki93: it'll definitely help you think more carefully about your programs, no matter how or what language you decide to write them in
00:10:23 <pumpkin> yeah
00:10:28 <nikki93> @let find53Sum upperLimit = (sum union) - (sum intersect) where union = [3,6..(upperLimit - 1)] ++ [5,10..(upperLimit - 1)] intersect = [15,30..(upperLimit - 1)]
00:10:29 <lambdabot>   Parse error
00:10:33 <nikki93> :(
00:10:44 <Lemonator> One has to explicitly export functions with "foreign export ccall" before C can call them?
00:11:05 <nikki93> Lemonator: You're trying to use Haskell for C programming scripting/
00:11:07 <nikki93> Nice.
00:11:34 <nikki93> Its incredibly awesome as a math problem solving utility though. :P
00:11:42 <Lemonator> aye.
00:11:44 <pumpkin> it's useful for a whole bunch of stuff :)
00:11:45 <sjanssen> preflex: seen dcoutts_
00:11:46 <preflex>  dcoutts_ was last seen on #haskell 1 day, 13 hours and 30 minutes ago, saying: dons: is h4sh dead? I'm just cleaning up a page on the hackage wiki about packages that are not on hackage yet.
00:11:58 <nikki93> @let find53Sum upperLimit = (sum union) - (sum intersect)
00:11:59 <nikki93>     where union = [3,6..(upperLimit - 1)] ++ [5,10..(upperLimit - 1)]
00:11:59 <nikki93> 	  intersect = [15,30..(upperLimit - 1)]
00:12:00 <lambdabot>  Couldn't match expected type `[a]'
00:12:05 <nikki93> :|
00:12:08 <nikki93> Someone define it here.
00:12:10 <pumpkin> nikki93: semicolons
00:12:12 <sjanssen> dcoutts_: around?
00:12:17 <sjanssen> @localtime dcoutts_
00:12:17 <lambdabot> Local time for dcoutts_ is Sun Jan 18 08:12:16
00:12:29 <nikki93> @let find53Sum upperLimit = (sum union) - (sum intersect)
00:12:30 <lambdabot>  Couldn't match expected type `[a]'
00:12:33 <nikki93> @let find53Sum upperLimit = (sum union) - (sum intersect);
00:12:34 <lambdabot>  Couldn't match expected type `[a]'
00:12:40 <nikki93> How?
00:13:37 <nikki93> preflex: seen lambdabot
00:13:37 <preflex>  lambdabot was last seen on #haskell 1 minute and 3 seconds ago, saying:  Couldn't match expected type `[a]'
00:13:43 <nikki93> HAhahahahaha
00:13:53 <nikki93> Hahhahhhahah
00:14:00 <nikki93> This needs a program.
00:14:26 <dzlk> > x + y where x = 2; y = 3
00:14:27 <lambdabot>   5
00:14:54 <nikki93> @let ha n = if (n > 0) then "HA" + ha (n - 1) else "H!"
00:14:55 <lambdabot>  <local>:35:23:
00:14:55 <lambdabot>      No instance for (Num [Char])
00:14:55 <lambdabot>        arising from a use o...
00:15:03 <pumpkin> ++
00:15:11 <nikki93> @let ha n = if (n > 0) then "HA" ++ ha (n - 1) else "H!"
00:15:14 <lambdabot>  Defined.
00:15:23 <nikki93> > ha 20
00:15:25 <lambdabot>   "HAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAH!"
00:15:27 <nikki93> :P
00:15:47 <nikki93> Haskell is the ultimate loopinator.
00:15:48 <dzlk> hee.
00:16:07 <pumpkin> > (concatMap (const "HA") [1..19]) ++ "H!"
00:16:08 <lambdabot>   "HAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAH!"
00:16:15 <nikki93> @let hee n = if (n > 0) then "HEE" ++ ha (n - 1) else "EEEE11!11!!11!"
00:16:18 <lambdabot>  Defined.
00:16:21 <nikki93> > hee 20
00:16:23 <lambdabot>   "HEEHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAH!"
00:16:32 <nikki93> Woops
00:16:32 <pumpkin> ;)
00:16:33 <nikki93> lol
00:16:51 <nikki93> @let hee2 n = if (n > 0) then "HEE" ++ hee2 (n - 1) else "EEEE11!11!!11!"
00:16:54 <lambdabot>  Defined.
00:16:59 <pumpkin> nikki93: you should try playing around with some higher-order functions
00:16:59 <nikki93> > hee 20
00:17:01 <lambdabot>   "HEEHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHAH!"
00:17:02 <pumpkin> they're incredibly useful
00:17:06 <nikki93> > hee2 20
00:17:08 <lambdabot>   "HEEHEEHEEHEEHEEHEEHEEHEEHEEHEEHEEHEEHEEHEEHEEHEEHEEHEEHEEHEEEEEE11!11!!11!"
00:17:16 <nikki93> Shh pumpkin I'm laughing programmatically.
00:17:32 <nikki93> Messing low-level is a great way to learn the basics.
00:17:35 <nikki93> (I guess)
00:17:37 <dzlk> @let hee' n = (concatMap (const "hee ") [1..(n-1)]) ++ "hee."
00:17:40 <lambdabot>  Defined.
00:17:44 <Ralith> lol
00:17:45 <dzlk> > hee' 3
00:17:47 <nikki93> > hee1 3
00:17:47 <lambdabot>   "hee hee hee."
00:17:48 <lambdabot>   Not in scope: `hee1'
00:18:00 <Ralith> > hee' 0
00:18:02 <lambdabot>   "hee."
00:18:12 <Ralith> > hee' -1
00:18:12 <dzlk> oops.
00:18:13 <lambdabot>       No instance for (Num (a -> [Char]))
00:18:13 <lambdabot>        arising from the literal `1'...
00:18:31 <nikki93> @let whatIs str = if (str == "lambdabot") then "Its an idiot!" else "I dunno!"
00:18:34 <lambdabot>  Defined.
00:18:37 <Saizan_> > hee' (-1)
00:18:39 <lambdabot>   "hee."
00:18:41 <nikki93> > whatIs "lambdabot"
00:18:43 <lambdabot>   "Its an idiot!"
00:18:47 <nikki93> HAHAHAHAHA
00:18:52 <Gracenotes> > whatIs "Lambdabot"
00:18:54 <lambdabot>   "I dunno!"
00:18:56 <Saizan_> nikki93: less noise please
00:18:59 <Gracenotes> hm, I don't either
00:19:07 <nikki93> Saizan_: Sorreh. :(
00:19:15 <dzlk> > [1..0]
00:19:16 <lambdabot>   []
00:19:17 <nikki93> Saizan_: Playing with lambdabot is allowed?
00:19:26 <Saizan_> nikki93: in private :)
00:19:31 <Saizan_> you can query it
00:19:45 <nikki93> Saizan_: But we can't play with lambdabot together? :(
00:19:48 <pumpkin> > fix (('h':'a'):)
00:19:49 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
00:19:59 <nikki93> pumpkin got owned. :P
00:20:03 <pumpkin> lol
00:20:17 <Saizan_> with moderation :)
00:20:51 <pumpkin> nikki93: people are generally fine with you playing around with lambdabot in public, but doing actually productive stuff might be best :)
00:21:19 <nikki93> pumpkin: ;-)
00:21:29 <nikki93> pumpkin: I have ghci, its ok.
00:22:18 <pumpkin> I mean, trying stuff in here and failing, and having someone else do it right for you, is quite a common way of doing things around here :) don't be scared off, but I think finding ways of making lambdabot say ridiculous stuff gets old fast :P
00:22:24 <kmeyer> my ghci is broken :(
00:22:28 <Saizan_> i guess there's a difference in exploring a little problem or playing golf with an expression and just making it print "funny" strings
00:22:31 <pumpkin> kmeyer: broken, how?
00:22:40 <kmeyer> 6.10.x's editline doesn't work
00:22:45 <kmeyer> so ghci is largely useless
00:22:49 <pumpkin> kmeyer: aw :/
00:22:53 <kmeyer> yeah ;(
00:22:58 <pumpkin> what platform?
00:22:59 <kmeyer> I used ghci a lot on 6.8.x
00:23:03 <kmeyer> fedora rawhide
00:23:03 <Saizan_> seen ghci-haskeline?
00:23:09 <kmeyer> nope
00:23:11 <kmeyer> what is it?
00:23:17 <pumpkin> kmeyer: do you have cabal-install?
00:23:22 <Saizan_> it's another frontend for ghci
00:23:26 <kmeyer> yes, but I prefer to not use it
00:23:33 <pumpkin> kmeyer: how come?
00:23:38 <Saizan_> which uses haskeline, which is a reimplementation of readline in pure haskell
00:23:54 <Saizan_> you can find it on hackage
00:23:55 <kmeyer> pumpkin: I like making keeping everything I install in rpm form
00:24:03 <pumpkin> o.O
00:24:12 <pumpkin> everything on hackage is available as RPM?
00:24:14 <intoverflow> kmeyer: I may have had the same problem as you; is your issue that backspace, arrows, tab, etc don't work?
00:24:23 <kmeyer> intoverflow: yeah.
00:24:29 <kmeyer> i.e. editline isn't working.
00:24:38 <kmeyer>  / isn't linked in
00:25:11 <kmeyer> between 6.8.x and 6.10.x ghci switched from readline to editline
00:25:36 <intoverflow> kmeyer: http://www.nabble.com/6.10-candidate-tested-td19647000.html
00:26:09 <dzlk> anyway, for making lambdabot say amusingly ridiculous things it's kind of hard to beat @pl (\y -> you y off).
00:26:25 <pumpkin> @pl (\y -> you y off)
00:26:25 <lambdabot> flip you off
00:26:28 <pumpkin> :)
00:26:33 <intoverflow> pumpkin++
00:26:49 <nikki93> In the page: http://book.realworldhaskell.org/read/functional-programming.html, do I really need that file-in-file-out thing?
00:26:54 <pumpkin> @pl \q w e r t y u i o p -> t y p e w r i t e r
00:26:55 <kmeyer> intoverflow: ah, we need a library not shipped with ghc for editline support?
00:26:58 <lambdabot> const ((((((const . (const .)) .) .) .) .) . flip flip id . ((ap . (flip .) . ((flip .) .)) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . join . (flip .) . ((flip .) .) . (((flip .) .) .) .
00:26:58 <lambdabot> ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip flip id . (flip .) . ((ap .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((flip .) .) .) .) . (flip .) . ((flip
00:26:58 <lambdabot> .) .) . (((flip .) .) .) . flip (flip . (flip .) . ((flip .) .) . flip (flip . (flip .))))
00:26:58 <lambdabot> optimization suspended, use @pl-resume to continue.
00:26:59 <nikki93> I want to just play with files and gchi :load file.hs
00:27:09 <intoverflow> kmeyer: iirc that was the issue on my machine (ubuntu)
00:27:38 <pumpkin> > scanl1 (+) [1,3..]
00:27:40 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
00:27:56 <intoverflow> kmeyer: in particular, if editline isn't installed, ghci defaults to not supporting that functionality; for me, I just didn't have editline installed.  So I did the apt-get, then built ghc from source and it was all good
00:28:32 <intoverflow> at least I *think* that was the issue; my memory might be false in this case :/
00:28:35 <kmeyer> ah, our haskell packagers definitely make sure editline is in the build root, but they told me for some reason ghc isn't finding it
00:28:40 <kmeyer> maybe I'll take a stab at it this weekend.
00:28:46 <pumpkin> > scanl1 (+) . scanl (+) 1 $ repeat 2
00:28:47 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
00:29:00 <sjanssen> hmm, are there any other names for ghc -O0?
00:29:06 * sjanssen is trying to fool Cabal
00:29:18 <pumpkin> sjanssen: tell it your name is nobody
00:29:41 <pumpkin> not sure that would work though :/
00:29:48 <sjanssen> pumpkin: huh?
00:30:28 <sjanssen> I want to turn off GHC's optimizations (since it blows up on our code), but hackage says: "'ghc-options: -O0' is not needed. Use the --disable-optimization configure flag.
00:30:59 <pumpkin> that's silly :/
00:31:09 <sjanssen> yeah
00:31:14 <Saizan_> -Onot, but i think that's checked too
00:31:23 <pumpkin> why would cabal do that?
00:31:41 <sjanssen> it is seriously broken to have these last minute checks that are only available when you've already made your package distributable
00:31:56 <harblcat> is there a simple way to delay execution for a set number of milliseconds?
00:32:00 <erikc> does anyone know what state the 'com' package is? is there a package for ihc (the haskelldirect generator)?
00:32:02 <harblcat> like sleep?
00:32:04 <Saizan_> sjanssen: "cabal check" does the same thing
00:32:14 <pumpkin> @hoogle treadDelay
00:32:14 <lambdabot> No results found
00:32:18 <pumpkin> @hoogle threadDelay
00:32:18 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
00:32:20 <sjanssen> it is also ridiculous to assume that the package system always knows better than the package author
00:32:28 <pumpkin> ^^ harblcat
00:32:32 <sjanssen> Saizan_: ah, that's good to know, but still not good enough IMO
00:32:47 <Saizan_> i guess sdist should run it
00:32:48 <sjanssen> I don't typically use the cabal tool when developing
00:33:18 <pumpkin> so even with no -O flag, it still has some basic optimizations?
00:33:31 <Saizan_> Cabal builds with -O by default
00:33:36 <pumpkin> oh I see
00:33:39 <sjanssen> pumpkin: Cabal automatically enables optimizations (which is a good default)
00:34:04 <pumpkin> it seems really silly for it to explicitly check for you telling it not to and tell you not to
00:34:21 <pumpkin> it's like the ridiculous bc ctrl+c handler
00:34:44 <pumpkin> (if it's going to handle my ctrl+c input and tell me to type quit, it might as well just quit for me)
00:34:51 <Saizan_> well, sometimes developers put those things in packages just because they don't want to pass flags to runghc Setup
00:35:01 <harblcat> pumpkin: thanks
00:35:47 <Saizan_> and if you've such options in the .cabal then --disable/enable-optimization don't work anymore
00:36:19 <Saizan_> the right solution might be to specify different defaults in packages
00:36:31 <Saizan_> rather than bypassing options
00:36:59 <sjanssen> Saizan_: in this case I want to bypass the option
00:37:26 <pumpkin> does anyone know how difficult it would be to get ghc up and running on the iphone? the mac os version knows how to output mach-o, and there's an ARM code generator it seems, so I just need to get both to work together
00:37:37 <sjanssen> even if the user explicitly passes --enable-optimization, I still need -O0
00:38:37 <nikki93> Is my implementation of 'breakIntoWords' correct?
00:38:38 <nikki93> breakIntoWords [] = []
00:38:38 <nikki93> breakIntoWords str = pre : breakIntoWords(drop 1 suf)
00:38:38 <nikki93>     where (pre, suf) = break isSpace str
00:38:38 <nikki93>           isSpace c = c == ' '
00:39:23 <pumpkin> nikki93: try it on a sentence :o
00:39:44 <nikki93> Tried, it died. :P
00:39:47 <pumpkin> :o
00:39:54 <nikki93> Oh wait it works now! :D
00:39:59 <nikki93> Man I rock! :P
00:40:04 <pumpkin> good job :)
00:40:18 <nikki93> breakIntoWords :: String -> [String]
00:40:18 <nikki93> breakIntoWords "" = []
00:40:18 <nikki93> breakIntoWords str = pre : breakIntoWords(drop 1 suf)
00:40:18 <nikki93>     where (pre, suf) = break isSpace str
00:40:18 <nikki93>           isSpace c = c == ' '
00:40:20 <pumpkin> there's a channel full of people working on RWH on freenode somewhere but it had a weird name
00:40:24 <pumpkin> I can't remember it now
00:40:26 <nikki93> There it is!
00:40:34 <pumpkin> what did you change?
00:40:36 <Saizan_> #novalang , iirc
00:40:39 <pumpkin> ah yeah
00:40:47 <nikki93> Added 'function type definition' or whatever its called.
00:40:49 <sjanssen> Saizan_: but yes, a "build ways" system, like in GHC would be generally useful
00:40:54 <nikki93> And changed [] to ""
00:41:02 <pumpkin> nikki93: those two are basically synonyms
00:41:10 <nikki93> pumpkin: I know, but it fixed it. :o
00:41:11 <sjanssen> eg. turn on -Werror when the "development way" is selected
00:41:35 <pumpkin> @src words
00:41:35 <lambdabot> words s = case dropWhile isSpace s of
00:41:35 <lambdabot>     "" -> []
00:41:35 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
00:41:52 <nikki93> pumpkin: Higher-order functions eh?
00:41:52 <nikki93> :P
00:41:58 <pumpkin> not in that case :)
00:42:08 <pumpkin> well, I guess you might think of break as one
00:42:27 <nikki93> Man haskell rocks.
00:42:32 <pumpkin> I think you'd need an unfold to do that using a typical higher-order function
00:42:33 <nikki93> Yeah, break is a cool function though
00:43:01 <Saizan_> sjanssen: i've seen that discussed in the past, but there wasn't an agreement on the UI, and if that information belongs in the .cabal file or not
00:43:14 <nikki93> I'm currently listening to the http://www.dnbradio.com/hi.pls radio station. It helps with Haskell. O_O
00:43:20 <pumpkin> :)
00:43:47 <pumpkin> nikki93: you should try more euler problems!
00:43:52 <pumpkin> nikki93: they're so fun
00:44:00 <pumpkin> I haven't had time to work on any in a couple of weeks :/
00:46:37 <nikki93> pumpkin: I just saw case and pattern matching
00:46:41 <nikki93> pumpkin: It pwns. :P
00:47:10 <pumpkin> damn right :)
00:47:22 <nikki93> It was wondering, how could I write a lambda function, *right* where its needed?
00:47:37 <pumpkin> \param1 param2 -> param1 * param2
00:47:37 <nikki93> I don't want to have to make a name and put it in a 'where' clause.
00:47:46 <pumpkin> just the slash and the arrow
00:47:51 <nikki93> Oh cool.
00:48:10 <pumpkin> > map (\x -> (x - 1)^2) [1..] -- for example
00:48:11 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,...
00:48:20 <nikki93> So slash means "following are arguments" and arrow means "function body starts here"?
00:48:21 <Saizan_> sjanssen: btw, i only need -O0 on xmonad-contrib to have it work on 6.10.1 then? :)
00:48:26 <nikki93> Nice!
00:48:38 <pumpkin> yup
00:48:53 <nikki93> CAn there be a space between the slash and the arguments?
00:49:00 <pumpkin> if you want there to be
00:49:12 <nikki93> Ok, that's just cleaner, thats why.
00:49:13 <pumpkin> I think the slash is meant to look like a lambda
00:49:29 <nikki93> pumpkin: Doesn't though (or I just can't appreciate art).
00:49:48 <pumpkin> Î» yeah, it's a bit of a stretch
00:50:11 <Cale> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=771#a771
00:50:46 <nikki93> Nice. Now breakIntoWords looks like this (with the other guards and obious stuff):
00:50:47 <pumpkin> :o
00:50:49 <nikki93> breakIntoWords str = pre : breakIntoWords(drop 1 suf) where (pre, suf) = break (\c -> c == ' ') str
00:50:59 <Twey> breakIntoWords = words
00:50:59 <Cale> (exceedingly slow though)
00:51:01 <Twey> >.>
00:51:09 <pumpkin> Twey: this is an exercise ;)
00:51:12 <Twey> Ah, OK :)
00:51:13 <nikki93> Twey: I know, but I'm learning.
00:51:34 <nikki93> "You have to learn addition" "But lots of people added before us!". "Oh ok then you don't"
00:51:37 <nikki93> lol
00:52:03 <pumpkin> my macbook air likes to go on strike periodically
00:52:11 <sjanssen> Saizan_: the -O0 works around a bug we've hit with GHC 6.10.1 and x86_64
00:52:26 <sjanssen> Saizan_: if you were having trouble with prompt or tabbed, this should fix it
00:53:20 <nikki93> map (\x -> if (x `mod` 100) == 0 then goOnStrike else work) [1..]
00:53:42 <pumpkin> :)
00:54:11 <nikki93> The \ and -> are evaluated last, right? Or do I have to put bracketses?
00:54:31 <pumpkin> that's fine
00:55:20 <Cale> Hehe, anyone try my prime number generator?
00:55:33 <pumpkin> Cale: not yet, my computer's being unusably slow :/
00:55:57 <Cale> The prime number generator is unusably slow anyway :P
00:56:38 <Cale> I've had it running for a few minutes now and it's at 89 :)
00:56:41 <pumpkin> lol
00:56:43 <Cale> oh, 97
00:57:08 <pumpkin> what if it outputs 99 next? will we have to change all of math?
00:57:17 <pumpkin> our most fundamental assumptions will be challenged!
00:57:37 <Cale> phew, 101
00:58:01 <sleven> HaPPs is to complicated and seemingly impossible to get up and running
00:58:21 <sleven> is there a production-quality webserver available for haskell?
00:58:34 <Cale> HAppS is to complicated what seemingly impossible is to running?
00:58:43 <Cale> hehe
00:58:57 <Saizan_> sleven: tried "cabal install HAppS-Server"?
00:59:32 <pumpkin> Cale: as a math person, do you have to memorize all the primes?
00:59:41 <Cale> pumpkin: heh
00:59:59 <dolio> Yes.
01:00:02 <Cale> pumpkin: I've seen the small ones so often by now that I recognise them.
01:00:14 <pumpkin> dolio: do you know them all?
01:00:17 <pumpkin> Cale: ah
01:00:25 <Cale> pumpkin: But there's no real fundamental reason to memorise anything past the first few.
01:00:31 <dolio> I didn't major in math.
01:00:32 <Cale> There are infinitely many of them, you know.
01:00:45 <pumpkin> sorry, I guess tone doesn't come across very well on IRC :)
01:01:02 <mmorrow> here's a brainfuck: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=772
01:01:11 <pumpkin> I just like being ridiculous as I'm sure people have gathered by now
01:01:28 <shapr> gwern: shae ERISSON
01:01:28 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
01:02:46 <mmorrow> you could implem multiple threads of brainfuck talking to each other and roundrobin scheduled pretty easily with that
01:02:49 <papermachine> I know all the primes. And if you believe that, I've got a Turing Oracle to sell you...
01:02:50 <mmorrow> that would be sweet!
01:03:40 <Cale> The only numbers you regularly see in pure mathematics are: -1,0,i,1,2,e,3,pi,perhaps 4 and occasionally 6, and various combinations thereof.
01:03:42 * mmorrow shakes off bf and returns do doing stuff
01:04:12 <pumpkin> I like your ordering there
01:04:18 <pumpkin> with i between 0 and 1
01:04:22 <Cale> hehe
01:04:31 <pumpkin> I guess i^i is between 0 and 1
01:04:33 <Cale> Had to put it somewhere :)
01:04:35 <pumpkin> :)
01:04:51 <pumpkin> > (0 :+ 1) ** (0 :+ 1)
01:04:52 <lambdabot>   0.20787957635076193 :+ 0.0
01:05:33 <Cale> Oh, and of course 163.
01:05:38 <Cale> hehe
01:05:47 <Cale> (half jokingly)
01:05:57 <pumpkin> http://mathworld.wolfram.com/163.html !
01:06:10 <Cale> Yeah, it's fairly special.
01:06:15 <pumpkin> how about claitlin's omega?
01:06:18 <jethr0> cale, how about pi?
01:06:19 <pumpkin> chaitlins
01:06:23 <jethr0> and why "6"?
01:06:24 <pumpkin> he had pi
01:06:29 <jethr0> sorry
01:06:52 <Cale> 6 is the smallest composite number which is the product of distinct primes
01:07:06 <pumpkin> also, 6/pi^2 and its inverse are kinda cute aren't they?
01:07:06 <Cale> So it shows up in counterexamples from time to time
01:07:10 <Cale> yeah
01:07:22 <mmorrow> > 6 / (pi ^ 2)
01:07:24 <lambdabot>   0.6079271018540267
01:07:38 <mmorrow> > (1 + sqrt 2) / 2
01:07:39 <lambdabot>   1.2071067811865475
01:07:40 <mmorrow> > (1 + sqrt 5) / 2
01:07:41 <lambdabot>   1.618033988749895
01:07:43 <jethr0> > 1/(6/pi^2)
01:07:45 <lambdabot>   1.6449340668482264
01:07:47 <mmorrow> > 2 / (1 + sqrt 5)
01:07:48 <lambdabot>   0.6180339887498948
01:08:00 <mmorrow> what is cute about 6/pi^2 ?
01:08:03 <pumpkin> > sum .  map (\x -> 1 / (x^2)) [1..100]
01:08:05 <lambdabot>   Couldn't match expected type `a -> [a1]'
01:08:08 <pumpkin> > sum .  map (\x -> 1 / (x^2)) $ [1..100]
01:08:09 <lambdabot>   1.6349839001848923
01:08:13 <pumpkin> > sum .  map (\x -> 1 / (x^2)) $ [1..1000]
01:08:14 <lambdabot>   1.6439345666815615
01:08:22 <mmorrow> ah
01:08:45 <pumpkin> the inverse is the coprime probability for reasons beyond me
01:09:17 <mmorrow> , scanl (\a x -> a + (1 / (x^2)) [1..]
01:09:19 <lunabot>  luna: parse error (possibly incorrect indentation)
01:09:23 <mmorrow> , scanl (\a x -> a + (1 / (x^2))) [1..]
01:09:25 <lunabot>  luna: No instance for (GHC.Show.Show ([[t]] -> [[t]]))
01:09:29 <mmorrow> , scanl (\a x -> a + (1 / (x^2))) 1 [2..]
01:09:31 <lunabot>  [1.0,1.25,1.3611111111111112,1.4236111111111112,1.4636111111111112,1.4913...
01:09:43 <mmorrow> , drop 1000 $ scanl (\a x -> a + (1 / (x^2))) 1 [2..]
01:09:45 <lunabot>  [1.6439355646845573,1.6439365606965253,1.6439375547234176,1.6439385467711...
01:10:06 <pumpkin> http://en.wikipedia.org/wiki/Relatively_prime
01:10:17 <mmorrow> , fmap (uncurry subtract) . (zip`ap`tail) $ scanl (\a x -> a + (1 / (x^2))) 1 [2..]
01:10:19 <pumpkin> there's a discussion on the 6/pi^2 thing there
01:10:19 <lunabot>  [0.25,0.11111111111111116,6.25e-2,4.0000000000000036e-2,2.777777777777768...
01:10:38 <pumpkin> and http://en.wikipedia.org/wiki/Basel_problem
01:11:28 <mmorrow> , length . takeWhile (> 1e-10) . fmap (uncurry subtract) . (zip`ap`tail) $ scanl (\a x -> a + (1 / (x^2))) 1 [2..]
01:11:32 <lunabot>  99999
01:11:39 <mmorrow> , length . takeWhile (> 1e-26) . fmap (uncurry subtract) . (zip`ap`tail) $ scanl (\a x -> a + (1 / (x^2))) 1 [2..]
01:11:45 <lunabot>  Killed.
01:11:52 <pumpkin> aw
01:12:14 <mmorrow> running in ghci
01:12:55 <mmorrow> ok killed it
01:13:12 <pumpkin> gobbling up too much memory?
01:13:26 <mmorrow> taking long, doing another on ethough
01:13:35 <pumpkin> you could do a binaryish search
01:13:57 <nikki93> Can *all* functions be used as infix?
01:14:04 <mmorrow> @let fooble n = length . takeWhile (> 1/(10^n)) . fmap (uncurry subtract) . (zip`ap`tail) $ scanl (\a x -> a + (1 / (x^2))) 1 [2..]
01:14:05 <pumpkin> nikki93: with ``
01:14:07 <lambdabot>  Defined.
01:14:13 <mmorrow> > fooble 10
01:14:14 <lambdabot>   99999
01:14:16 <mmorrow> > fooble 11
01:14:18 <lambdabot>   316228
01:14:19 <mmorrow> > fooble 12
01:14:23 <lambdabot>   1000010
01:14:27 <pumpkin> nice name :)
01:14:29 <Twey> nikki93: Yes, if you surround them with ``
01:14:30 <mmorrow> heh
01:14:37 <nikki93> Twey: Got it.
01:14:39 <Twey> > let foo = (+) in 1 `foo` 2
01:14:41 <lambdabot>   3
01:14:51 <mmorrow> > fooble 13
01:14:59 <mmorrow> it gets really long here or at 14
01:14:59 <lambdabot>   3161785
01:15:01 <Cale> Oh, another special thing about 6
01:15:02 <pumpkin> nikki93: if the function "takes more than 2 parameters" you'll get a function out of the "operator application"
01:15:07 <mmorrow> > fooble 14
01:15:17 <Cale> It's the only n for which Aut(S_n)/Inn(S_n) is nontrivial.
01:15:22 <lambdabot>   thread killed
01:15:25 <mmorrow> 9948905
01:15:34 <pumpkin> Aut? Inn?
01:15:37 <pumpkin> my math knowledge is too shallow :P
01:15:48 <nikki93> So this is correct:
01:15:53 <Cale> S_n is the group of permutations of {1..n}
01:16:08 <nikki93> 2 `(\x y -> x + y)` 3?
01:16:12 <nikki93> > 2 `(\x y -> x + y)` 3
01:16:14 <lambdabot>   <no location info>: parse error on input `('
01:16:21 <pumpkin> nikki93: named functions :P
01:16:26 <nikki93> Oh heh.
01:16:39 <nikki93> > (\x y -> x + y) 3 2
01:16:41 <lambdabot>   5
01:16:45 <nikki93> Nice. :P
01:17:02 <Cale> Aut(G) is the automorphism group of G, that is, the group of bijective functions f: G -> G such that f(1) = 1, f(uv) = f(u)f(v) and f(u^-1) = f(u)^-1
01:17:04 <nikki93> Lambda functions are awesome.
01:17:28 <Cale> Inn(G) is the group of inner automorphisms of G, an inner automorphism is one of the form \x -> a x a^(-1) for some a.
01:17:41 <pumpkin> ah
01:17:59 <Cale> So for all S_n other than S_6, every automorphism is an inner automorphism.
01:18:10 <Cale> S_6 has one which isn't.
01:18:37 <pumpkin> :o
01:19:58 <pumpkin> Cale: interesting... it's small enough not be scary too :P
01:20:06 <pumpkin> , permutations [1..6]
01:20:08 <lunabot>  [[1,2,3,4,5,6],[2,1,3,4,5,6],[3,2,1,4,5,6],[2,3,1,4,5,6],[3,1,2,4,5,6],[1...
01:20:13 <pumpkin> , length $ permutations [1..6]
01:20:15 <lunabot>  720
01:20:19 <pumpkin> duh
01:20:34 <pumpkin> :)
01:23:34 <pumpkin> Cale: are you a student?
01:24:12 <Cale> I was... I've been in between things for a while now.
01:24:40 <pumpkin> ah
01:24:44 <Stinger> read : unemployed
01:24:47 <Stinger> *ducks*
01:24:51 <pumpkin> you seem to enjoy teaching a lot :)
01:24:59 <pumpkin> in text, at least :P
01:25:11 <Twey> Stinger: 'Gentleman of leisure'
01:25:12 <pumpkin> (quite well, I might add)
01:25:46 <Stinger> hmm I might have to borrow that one
01:26:18 * Twey chuckles.
01:26:36 <Cale> gap> Size(AutomorphismGroup(SymmetricGroup(6)));
01:26:36 <Cale> 1440
01:28:27 <Cale> gap> Size(Filtered(AutomorphismGroup(SymmetricGroup(6)), f -> IsInnerAutomorphism(f)));
01:28:27 <Cale> 720
01:28:48 <mercury^> That's trivial. :P
01:28:49 <Cale> So the quotient has 2 elements.
01:29:01 <pumpkin> what language is that?
01:29:04 <Cale> gap
01:29:12 <pumpkin> I guess I could've inferred that
01:29:51 <mercury^> Hmm, what do the outer automorphisms of S_6 look like?
01:30:31 <Cale> [ (1,2,3,4,5,6), (1,2) ] -> [ (2,4,3)(5,6), (1,6)(2,4)(3,5) ]
01:30:39 <Cale> (is one of them)
01:30:55 <Cale> That notation is [gens] -> [where each is sent]
01:31:10 <mercury^> k
01:31:41 <Cale> [ (1,2,3,4,5,6), (1,2) ] -> [ (1,2,3)(4,5), (1,3)(2,4)(5,6) ]
01:31:50 <Cale> There's a particularly nice one
01:32:45 <Cale> They all have that shape of course -- all the others are obtained by composing with an inner automorphism, which just means that the numbers are permuted before being put into the cycles.
01:33:30 <Gracenotes> by chance, do lists and arrays share a typeclass?
01:33:41 <Gracenotes> it doesn't seem they have any common functions
01:33:45 <mercury^> Is there a short explanation for that property?
01:34:06 <mercury^> Gracenotes: I think there was a container typeclass defined somewhere.
01:34:45 <Cale> Foldable
01:34:59 <Cale> also Traversable
01:35:47 <Gracenotes> yep,Ix i => Traversable (Array i) (same for Foldable)
01:35:54 <Gracenotes> neat
01:36:23 <Cale> mercury^: Let's see if I can explain it coherently...
01:36:38 <nikki93> Ok, here it is.
01:36:43 <nikki93> Here's my new fib implementation.
01:36:46 <nikki93> @let fib nums n = if (n > 0) then fib (nums ++ [((head (reverse nums)) + (head (tail (reverse nums))))]) (n - 1) else nums
01:36:50 <lambdabot>  Defined.
01:36:59 <nikki93> > fib [0,1] 20
01:37:01 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946]
01:37:07 <pumpkin> nice :)
01:37:12 <nikki93> > fib [0,1] 12
01:37:13 <pumpkin> now, can you make it more efficient?
01:37:14 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233]
01:37:27 <pumpkin> keeping in mind that reverse is O(n)
01:37:35 <nikki93> Yeah, I need a better way to get last element... O wait, last n.. Yeah.
01:37:38 <nikki93> And what about second last?
01:37:44 <pumpkin> last works, but it's still slow
01:38:46 <mercury^> nikki93: I suppose you know that the "classical" way to write that in haskell is fibs = 0:1:zipWith(+) fibs (tail fibs)
01:38:50 <nikki93> Why?
01:38:56 <mercury^> Which is quite a bit more efficient than what you wrote. :)
01:39:09 <nikki93> I mean, pumpkin, why?
01:39:14 <mercury^> But if you want just a specific number, you can get that much faster yet.
01:39:22 <pumpkin> nikki93: why is last slow? it needs to walk across the entire list to find the last element
01:39:32 <pumpkin> which could take literally forever :P
01:39:35 <Gilly> Cale: would you as a group theorists have any ideas how to approach the following problem: how many permutations of the elements of G are such that the first differences of the permutation are a permutation of G \ {e}... i've mainly looked at this in the cyclic groups but haven't found good lower/upper bounds for the number...
01:39:38 <nikki93> Why is there no easy way to get the end of a list?
01:39:40 <nikki93> :|
01:39:45 <nikki93> Oh now I get it.
01:39:49 <nikki93> Its a linked list. :o
01:39:52 <Gracenotes> I personally like fix (\f a b -> a:f a (a+b)) 0 1
01:40:05 <Gracenotes> just my preference :3
01:40:05 <pumpkin> might as well use an unfold :P
01:40:15 <pumpkin> which is a lot clearer
01:40:17 <pumpkin> :P
01:40:22 <Saizan_> that's too low level :)
01:40:24 <Cale> Gilly: first differences in which sense?
01:40:42 <Gracenotes> pumpkin: hey, just because I don't have corecursion doesn't make many any uglier! It's a unique snowflake!
01:40:47 <Gracenotes> *mine
01:40:49 <pumpkin> :)
01:41:04 <pumpkin> > inits [1..10]
01:41:06 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[...
01:41:11 <Gilly> Cale: well, in C_6 we have [0,1,5,2,4,3] which has first differences [1,4,3,2,5]
01:41:16 <Gracenotes> now, 'twould be fine implementing the zipWith fibs as a continuation
01:41:29 <nikki93> Tell.. me... how... to... get... end... or... second... last... of..... lissttttsss.....
01:41:34 <nikki93> ;-)
01:41:50 <Cale> Gilly: ah, okay
01:42:02 <mercury^> Gilly: Why are you permuting a group?
01:42:15 <pumpkin> nikki93: easiest way is probably the way you're doing it
01:42:23 <nikki93> pumpkin: You're the guys that suggested adding as we go up is good right?
01:42:28 <nikki93> pumpkin: Ahh I remember you.
01:42:31 <pumpkin> nikki93: yup
01:42:31 <Gilly> mercury^: hmm, because i like this problem? :)
01:42:32 <nikki93> pumpkin: How's my method?
01:42:43 <nikki93> pumpkin: Man haskell is genius-requiring. :P
01:42:51 <pumpkin> nikki93: way better than your first method, but can still be improved without going into the fancy sublinear algorithms
01:43:07 <mercury^> Gilly: well, does the Group bring anything into the problem? Wouldn't any countable set do?
01:43:19 <Cale> Gilly: That seems dual in a sense to the sort of problem I already know how to solve quite well, which is how many permutations have a particular pattern of ups and downs.
01:43:44 <Gilly> mercury^: well the group operation defines the first differences
01:43:51 <Gilly> Cale: can you explain? :) sounds interesting
01:44:12 <nikki93> fibonacci n = fib [0,1] n where fib nums n = if (n > 0) then fib (nums ++ [((last nums)) + (head (tail (reverse nums)))]) (n - 1) else nums
01:44:21 <nikki93> @let fibonacci n = fib [0,1] n where fib nums n = if (n > 0) then fib (nums ++ [((last nums)) + (head (tail (reverse nums)))]) (n - 1) else nums
01:44:22 <lambdabot>  <local>:42:0:
01:44:22 <lambdabot>      Multiple declarations of `L.fibonacci'
01:44:22 <lambdabot>      Declared at: ...
01:44:31 <nikki93> How to clear lambdabot?
01:44:41 <Cale> Gilly: Well, there's something which was done by Jackson and Goulden called the pattern algebra...
01:45:10 <Gilly> Cale: alright :) frightening name but if it's not requiring too much prerequirisities i'm listening
01:45:20 <Gilly> prerequisities
01:46:44 <pumpkin> nikki93: @undefine
01:46:59 <pumpkin> nikki93: you should probably avoid overusing the @let and go for > let x = y in ...
01:47:20 <nikki93> pumpkin: You're right.
01:47:21 <Lanjiao> hi, anyone knows how to define gunfold on List?
01:47:31 <pumpkin> gunfold?
01:47:38 <nikki93> lol gunfold
01:47:42 <blip> I need a random nbr between 0 and 2
01:47:55 <Cale> Gilly: I'm just trying to see if I can explain this reasonably in a few lines.
01:47:58 <blip> import qualified System.Random as R
01:47:59 <blip> randDoor = R.randomR (0,2)
01:48:05 <blip> Ambiguous type variable `t' in the constraints:
01:48:05 <blip>       `Num t'
01:48:05 <blip>         arising from the literal `0'
01:48:13 <pumpkin> tell it the type you want
01:48:37 <blip> how?
01:48:39 <pumpkin> (0 :: Double) presumably
01:48:41 <blip> randDoor = R.randomR (0,2)::Double
01:48:44 <blip> ah
01:48:44 <pumpkin> or that
01:48:49 <mercury^> randDoor :: Int
01:48:49 <Gilly> Cale: as long as you are willing to explain, I don't bother the number of lines :)
01:49:03 <blip> mbiguous type variable `g' in the constraint:
01:49:03 <blip>       `R.RandomGen g'
01:49:03 <blip>         arising from a use of `R.randomR'
01:49:16 <nikki93> Is there any way to look how a function works?
01:49:21 <pumpkin> nikki93: like what?
01:49:24 <nikki93> I mean, 'watch it be evaluated'.
01:49:37 <nikki93> Because some of them are beautiful and I want to 'watch them in action'.
01:49:43 <pumpkin> not easily, but you can stick Debug.Trace.trace around the place with messages to yourself
01:49:53 <Saizan_> ?pl update f z = replace (f (cursor z)) z
01:49:54 <lambdabot> update = join . (replace .) . (. cursor)
01:50:07 <pumpkin> or if you're feeling more ambitious, use the Writer monad as sigfpe described today
01:50:17 <nikki93> Ok, I wanted to ask, what's 'dot' (.)?
01:50:23 <pumpkin> function composition
01:50:23 <Saizan_> ?pl update z = replace (f (cursor z)) z
01:50:24 <lambdabot> update = replace =<< f . cursor
01:50:36 <pumpkin> @src (.)
01:50:36 <lambdabot> (f . g) x = f (g x)
01:50:46 <Lanjiao> pumpkin: yes
01:50:53 <pumpkin> Lanjiao: what's gunfold?
01:51:21 <Lanjiao> pumpkin: pls check http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Data.html
01:54:29 <nikki93> I just found that doing 'map xyz [1..n]' is a great way of looping.
01:54:41 <pumpkin> looping to do what, is the question :)
01:54:55 <nikki93> Like, I wrote a function just now, 'printPowersOfTwo'.
01:55:02 <nikki93> printPowersOfTwo n = map (\n -> 2 ^ n) [0..n]
01:55:10 <pumpkin> ah, true :)
01:55:15 <pumpkin> but is it really printing?
01:55:23 <nikki93> Sorry. :(
01:55:25 <Cale> Gilly: How well do you know the basic idea of generating series? Basically, there's a way to construct appropriate rings and homomorphisms/functions with fairly nice properties that allow you to count permutations with particular patterns of ups and downs, or with certain kinds of maximal increasing substrings (that is, you can impose restrictions on the length). Actually, you can go a bit further and talk about seque
01:55:25 <Cale> nces which are not permutations, as well as other pairs of mutually disjoint relations
01:55:38 <nikki93> s/printPowersOfTwo/getPowersOfTwo
01:55:45 <nikki93> it ++ /
01:55:47 <Cale> (but the case which is best worked out is permutations and (<, >=)
01:55:49 <Cale> )
01:56:35 <Gilly> Cale: generating series means the same as generating functions?
01:56:39 <mercury^> nikki93: powersOfTwo = 1:map (*2) powersOfTwo
01:56:40 <Cale> yeah, basically.
01:56:47 <Gilly> well, yea, i know the basics there
01:57:04 <pumpkin> mercury^: you forgot the 0 ;)
01:57:10 <Cale> Generating functions is a poor term, since you're not really using them as functions...
01:57:11 <pumpkin> oh no you didn't
01:57:14 <pumpkin> I'm stupid :)
01:57:16 <blip> but hello
01:57:26 <Gilly> well, that's true :)
01:57:48 <blip> if u want haskell to be popular perhaps you shouldnt do: haskell :: 1+1 -> rocket science -> result
01:58:00 <blip> i just want a random number
01:58:07 <pumpkin> blip: who says we want it to be popular?
01:58:15 <pumpkin> we love being obscure
01:58:21 <blip> randon.randint(0,2)
01:58:34 <blip> give me that
01:58:41 <pumpkin> sure,
01:58:42 <mercury^> blip: what's wrong with just specifying the type of the random number you want?
01:58:49 * pumpkin hands blip a dynamic scripting language
01:58:50 <mercury^> blip: I told you, randDoor :: Int
01:59:20 <blip> i dont get how to use it i get weird type error with funny math names
01:59:39 <mercury^> Have you worked through a basic tutorial already?
01:59:48 <Cale> As an example of the sort of thing which comes out of this theory, you get things like that the number of <-alternating permutations of even length is [x^n/n!] sec x
01:59:53 <blip>  Couldn't match expected type `Int'
01:59:53 <mercury^> That should have covered type annotations.
01:59:53 <blip>            against inferred type `g -> (t, g)'
01:59:59 <blip> randDoor :: Int
02:00:00 <blip> randDoor = R.randomR (0,2)
02:00:08 <pumpkin> heh
02:01:12 <Gilly> Cale: "<-alternating" ?
02:01:19 <mercury^> blip: randomR takes two arguments.
02:01:31 <mercury^> (and returns a tupel)
02:01:34 <Cale> That is, adjacent elements go up, down, up, down, and so on.
02:02:00 <Gilly> ahh
02:02:13 <harblcat> blip: I was just working on something like that...
02:02:13 <Gilly> i don't quite see the relation to ups and downs in my problem
02:02:14 <mercury^> blip: what you should do depends on where you want to use the random number.
02:02:30 <pumpkin> there's a convenient random monad too
02:02:41 <mercury^> blip: maybe randDoor = randomRIO (0,2) is what you want
02:02:46 <harblcat> pumpkin: What is that?
02:02:48 <pumpkin> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MonadRandom
02:02:49 <Cale> Gilly: yeah, rather than ups or downs, you're concerned about the absolute distances.
02:02:53 <pumpkin> by Cale :o
02:02:53 <harblcat> oh.
02:02:56 <mercury^> In which case you can use it in the io monad.
02:03:20 <Cale> But this algebra does work with other disjoint pairs of relations, and it's possible that it could be generalised further...
02:03:41 <Cale> hmm
02:03:41 <Gilly> Cale: I see :)
02:03:54 <Cale> Probably not the most straightforward thing to do.
02:04:26 <Gilly> btw, there's another formulation of the problem: we can consider the resulting first differences, and note, that the first differences are valid iff. they don't have a consecutive subsequence summing to 0
02:04:37 <blip> mercury: type stuff again
02:04:44 <blip> ossible cause: the monomorphism restriction applied to the following:
02:04:52 <Gilly> then we can just pick some starting number and apply the first differences to get the original sequence back
02:04:52 <blip> what is the monomoprhism restriction?
02:05:03 <mercury^> blip: you used it in the io monad now?
02:05:19 <mercury^> like main = do i <- randDoor; print i
02:05:21 <pumpkin> blip: you didn't specify a type so it decided on one for you that may not be what you wanted
02:05:35 <pumpkin> sort of
02:05:39 <blip> i dont care¨
02:05:45 <blip> just whatever give a random nbr function
02:06:11 <mercury^> blip: randomRIO (0,2) is probably what you want, but it has type IO Int, you need to use it in the IO monad.
02:06:14 <pumpkin> blip: if your goal is to just get random numbers, and not figure out how the language works, why not just ask python?
02:06:19 <mercury^> Or unsafePerformIO
02:07:09 <blip> randDoor = do
02:07:10 <blip>   return $ R.randomRIO (0,2)
02:07:16 <blip> Ambiguous type variable `m' in the constraint:
02:07:16 <blip>       `Monad m'
02:07:21 <mercury^> err
02:07:35 <mercury^> just R.RandomRIO (0,2)
02:07:44 <mercury^> not do return $ R.randomRIO (0,2)
02:07:45 <blip> yeah but just fucni
02:07:52 <blip> just write the whole thing
02:07:56 <nikki93> > map (\c -> map (\c -> map (\c -> 2^c) [1..c]) [1..c]) [1..5]
02:07:58 <lambdabot>   [[[2]],[[2],[2,4]],[[2],[2,4],[2,4,8]],[[2],[2,4],[2,4,8],[2,4,8,16]],[[2],...
02:07:59 <blip> i dont know when you write one small part
02:08:09 <blip> it doesnt work ok
02:08:12 <mercury^> randDoor = R.randomRIO (0,2)
02:08:12 <pumpkin> blip: is this for homework?
02:08:26 <mercury^> I told you, you have to use it in the io monad or unsafePerform it.
02:08:29 <nikki93> pumpkin: Saw the lolfunction?
02:08:37 <nikki93> > map (\c -> map (\c -> map (\c -> 2^c) [1..c]) [1..c]) [1..4]
02:08:39 <lambdabot>   [[[2]],[[2],[2,4]],[[2],[2,4],[2,4,8]],[[2],[2,4],[2,4,8],[2,4,8,16]]]
02:08:46 <pumpkin> nice :)
02:09:05 <mercury^> blip: write just that definition and main = do i <- randDoor; print i -- into a faile
02:09:08 <mercury^> file*
02:09:11 <mercury^> heh
02:09:18 <harblcat> nikki93: are you actually using that code somewhere?
02:09:30 <nikki93> harblcat: Nope. Just messing around with Haskell.
02:09:34 <harblcat> that'd be kinda funny
02:10:01 <nikki93> harblcat: lol
02:10:23 <nikki93> harblcat: Printing a list of lists of 2^n with increasing 'n's? Hmm...
02:10:49 <nikki93> Its like a kid stuttering over his memory of the powers of two.
02:10:53 <Cale> mercury^: btw, http://cale.yi.org/share/conjugate.png -- this picture gives some intuition for why conjugation is like permutation of the underlying set.
02:10:58 <blip> http://hpaste.org/14051
02:11:01 <blip> no it doesnt work
02:11:15 <mercury^> Thanks.
02:11:15 <Cale> mercury^: Imagine the top and bottom row being collapsed down along the lines.
02:11:19 <harblcat> I can't come up with a legitimate reason to need that...
02:11:25 <pumpkin> blip: we've already told you how to specify the type
02:11:39 <pumpkin> add a :: Int somewhere
02:13:23 <blip> pumpkin: and i dont get it so just write something that works so i can see
02:13:35 <Gilly> Cale: would you have any pointers for the pattern theory you were describing?
02:13:40 <blip> ive tried a::Int in every way ti doesnt work still
02:13:53 <mercury^> Cale: Hmm, I don't yet get it. Why are the numbers in the visualisation of xax^{-1} in the order they are in?
02:13:58 <Cale> Gilly: Goulden and Jackson's "Combinatorial Enumeration" has it.
02:14:40 <Cale> mercury^: take the 1 in the upper left corner of the first picture and slide it down the line so that it takes the place of the 2
02:14:50 <Gilly> okies, guess i'd have to visit the bookstore at some point then :)
02:15:06 <Cale> Gilly: You might want to check the library first, if possible
02:15:28 <Cale> I'm sorry that I can't really give a better reference...
02:15:29 <mercury^> Cale: oh, silly me.
02:15:34 <pumpkin> blip: just where I said earlier
02:15:36 <mercury^> I kept sliding it down all the way.
02:15:38 <Gilly> yea probably
02:15:45 <pumpkin> blip: randDoor = R.randomRIO (0 :: Int,2) will fix it, for example
02:15:53 <mercury^> silly I*
02:15:54 <Cale> Gilly: It's much more clearly explained in Jackson's course notes for C&O 330 at the University of Waterloo
02:16:01 <pumpkin> blip: there's various other ways you can do that, but that should work
02:16:32 <Gilly> Cale: are they available online somewhere?
02:16:45 <Cale> Gilly: So if you wanted, you could try giving printing services a call. I think you can order things. But I don't think they're online, sadly.
02:17:35 <Cale> The 330 course notes are my favourite presentation of enumerative combinatorics and generating series, in what I've found.
02:17:47 <pumpkin> 330?
02:17:50 <mercury^> Cale: ah, in that case that's just a visualization of x (1,2,3) x^{-1} = (x(1),x(2),x(3)) though, isn't it?
02:17:55 <Cale> pumpkin: Course number.
02:17:56 <Gilly> okies - well thanks for your help :) i've been wondering for a while if a nice formula even exists, so i've been trying to devise upper/lower bounds
02:18:42 <Cale> Gilly: yeah, probably your best bet is just to keep working at it :) I haven't personally run into anything like that...
02:18:59 <Cale> Have you done any brute force counting?
02:19:01 <pumpkin> Cale: I figured as much, but was wondering what the course was :P
02:19:03 <Gilly> yup, i have
02:19:05 <Cale> Maybe you could try Sloane?
02:19:12 <pumpkin> oh I missed the earlier message
02:19:14 <pumpkin> sorry :)
02:19:16 <Gilly> well, it is there but gives no pointers whatsoever
02:19:35 <Gilly> i remember looking at it a year or two before and at that time it wasn
02:19:37 <Gilly> 't yet there
02:19:50 <Cale> curious :)
02:19:58 <mercury^> Cale: I was more interested in the "reason" for conjugation being insufficient in the S_6 case, while it is sufficient everywhere else.
02:19:59 <Gilly> now when i looked again someone had looked at the same problem but had no better ideas about exact enumeration / bounds than me
02:20:15 <ac> so I've got a type of "Maybe Foo" and a function of "Foo -> Maybe Bar". I start out with a "Maybe Foo" and I want to do a pattern match on Bar. If either the "Maybe Foo" is Nothing, or the "Maybe Bar" is nothing, or the pattern match on Bar fails, I want to "return ()" (I'm in the IO monad). Is there a more elegant way than 3 nested cases?
02:20:37 <Gilly> so, i've been looking at the problem myself and introducing it to other folks, hoping someone had an idea :)
02:20:42 <Cale> mercury^: ah
02:21:11 <mercury^> (In case I'm missing the obvious all the time - which I am sure I am - just tell me. To my excuse, I had a weekend seminar the last 3 days and hardly slept.)
02:21:28 <Cale> Gilly: yeah, I don't think I've ever seen anything quite like it... maybe counting of partitions into distinct parts is slightly similar.
02:21:44 <Cale> er, not really though
02:22:03 <Cale> mercury^: it's not really obvious
02:22:07 <Gilly> anyways the first numbers are 1, 2, 8, 24, 192, 2880, 46272, 1250592, 44095488, ...
02:22:13 <Gilly> for C_{2n}
02:22:22 <Gilly> it's easy to see for C_{2n+1} no solutions exist
02:22:33 <harblcat> blip: I changed your paste, it should work, perhaps.
02:22:51 <ac> I can hpaste it if you want to see my actual code (and I guess I only need two cases)
02:22:53 <Cale> Gilly: What about S_n?
02:23:25 <Gilly> if we fix the starting to number, say, 0, then you just divide those numbers by n
02:23:33 <pumpkin> ac: yeah, a paste would be good
02:23:47 <Gilly> http://www.artofproblemsolving.com/Forum/viewtopic.php?t=199166&sid=8ef6cacf2f94a8eb910b194fa7c4c10a
02:23:49 <pumpkin> ac: sounds like you want the Maybe monad's bind though
02:24:00 <Gilly> the guys here have done some research to that direction
02:25:10 <Gilly> No good permutations in S_3 or D_{2*4} or Q... 320*10 in D_{2*5}, 3072*12 in D_{2*6}, 2304*12 in A_4
02:25:21 <ac> http://hpaste.org/14052
02:25:38 <ac> ^ is there a more elegant way?
02:25:53 <pumpkin> yeah
02:26:09 <mercury^> ac: write it in the maybe monad
02:26:21 <ac> mercury^: but it's already in the IO monad...
02:26:28 <pumpkin> you can still do that :)
02:26:30 <mercury^> use transformers
02:28:17 <pumpkin> or just e >>= ?
02:28:29 <ac> so if I said "e <- Am.receiveEvent mymidi" in the Maybe monad, than would e be of type Event instead of "Maybe Event"? And what if it returned Nothing?
02:28:48 <ac> Am.receiveEvent returns "IO (Maybe Event)"
02:29:03 <pumpkin> yeah, so keep the e <- receiveEvent
02:29:11 <pumpkin> but now e is Maybe Event
02:29:14 <pumpkin> you can just use its bind
02:29:24 <Gracenotes> oh, darn all those deceptively simple boolean expressions :/
02:29:38 <ac> :t (>>=)
02:29:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:29:52 <pumpkin> @src Maybe (>>=)
02:29:53 <lambdabot> (Just x) >>= k      = k x
02:29:53 <lambdabot> Nothing  >>= _      = Nothing
02:30:21 <ac> that's exactly what I want ;)
02:30:26 <pumpkin> :)
02:30:51 <blip> im trying to !! a list but I have IO Int instead of Int
02:30:58 <pumpkin> so now e >>= Am.eventToChannelMsg will be Nothing if e was Nothing, or Just eventToChannelMsg e' if e was Just e'
02:30:59 <ac> one of these days I'll be able to write and read code like that naturally
02:31:05 <cnwdup> :t liftM2 !!
02:31:06 <lambdabot> parse error (possibly incorrect indentation)
02:31:08 <mercury^> You still want to use transformers.
02:31:11 <cnwdup> :t liftM2 (!!)
02:31:12 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> m Int -> m a
02:31:32 <maltem> Just wondering... Does the community generally agree that having libraries organized into Control vs. Data etc. is a good thing?
02:31:53 <pumpkin> blip: then pull the Int out of the IO Int using <- maybe, in your do block?
02:33:11 <blip> ok but it cant be done ina  cute way
02:33:12 <pumpkin> blip: x <- myIOInt
02:33:15 <blip> i have to separate it
02:33:16 <pumpkin> blip: sure it can be
02:33:23 <blip> in an expression?
02:33:31 <blip> let x <- rand2 in blah
02:33:49 <pumpkin> well, that's not correct syntax
02:33:50 <blip> what if it is really expensive and i only want to do in a branch
02:34:03 <blip> where x <- rand2?
02:34:12 <pumpkin> just x <- rand@
02:34:13 <pumpkin> 2
02:34:19 <pumpkin> you don't need a let or a where
02:34:26 <pumpkin> since you can only do that x <- stuff in a do block
02:34:43 <pumpkin> it's just syntactic sugar for the bind operator with a lambda function that takes x as an argument
02:35:03 <pumpkin> >>=, that is
02:35:54 <blip> else let i >>= rand2 in filter (/= choice) [0,1,2] !! i
02:36:10 <pumpkin> heh, no :P
02:37:48 <blip> so how then?
02:38:25 <Cale> mercury^: Ah, I think I see why 6 is the exceptional case. To prove that other automorphism groups have no outer automorphisms, you show first that any automorphism which preserves the conjugacy class of transpositions is an inner automorphism, and then that every automorphism (except for what happens in S_6) stabilises transpositions. Any automorphism will send conjugacy classes to conjugacy classes, and will preserv
02:38:25 <Cale> e the order of elements.
02:38:31 <pumpkin> write it out in do notation first, then once that works it might be easier to simplify it
02:39:47 <Cale> So if you look at the conjugacy class of transpositions, if that's not sent to the conjugacy class of transpositions, it's got to be sent to a conjugacy class of elements of order 2.
02:39:53 <Cale> (at least)
02:40:39 <Cale> and moreover, that class has to have the same number of elements as the class of transpositions
02:40:54 <blip> hmm this is the typesystem really getting in the way.
02:41:06 <Gilly> Cale: by any chance, would this be it? http://www.contrib.andrew.cmu.edu/~calmost/pdfs/co330_lec.pdf
02:41:10 <pumpkin> blip: what is?
02:41:14 <blip> i know it is correct but the function can give as far as ghc can see sometime s[a] and sometimes a
02:41:16 <kmeyer> blip: um, the type system is very helpful
02:41:33 <blip> but I can see that it never can be incorrect and will always yield a
02:41:43 <blip> kmeyer: yes most of the time but not here
02:41:54 <pumpkin> blip: you can't yield different types from one function/expression
02:41:59 <kmeyer> exactly
02:42:05 <Cale> Gilly: Oh! That's not it, but it's notes taken by a friend of mine. I didn't know he'd written them up.
02:42:06 <kmeyer> it's not even a good idea in languages that allow it
02:42:22 <Cale> Gilly: It's the same course, and there's stuff about the pattern algebra in there.
02:42:50 <Gilly> heh, nice :)
02:43:01 <blip> thats what im saying, it cant in reality but it looks to ghc like it could
02:43:12 <pumpkin> blip: can I see?
02:43:22 <pumpkin> @paste
02:43:22 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:43:22 <blip> wait iw as wrong
02:43:29 <blip> *embarassed*
02:43:30 <kmeyer> no, really?
02:43:40 <pumpkin> blip: ghc is usually pretty good at proving things like that, being a machine and all :)
02:43:52 <Cale> heh, that's got to be the most awesome 30 pages of mathematics I've seen in a while
02:43:55 <pumpkin> but there are cases it can't get, obviously
02:44:07 <Gilly> hehe
02:44:08 <blip> Cale: where?
02:44:15 <Cale> I wonder if it's comprehensible without the actual course notes.
02:44:26 <Cale> blip: http://www.contrib.andrew.cmu.edu/~calmost/pdfs/co330_lec.pdf
02:45:32 <Cale> It's got a proof of the formal power series version of Lagrange's Implicit Function Theorem, the Pattern Algebra, Polya Theory...
02:45:49 <Cale> :)
02:46:00 * kmeyer needs to take more math
02:46:28 <Cale> aw, it doesn't have the proof, actually
02:46:42 <Cale> Just the statement.
02:48:05 <Cale> It's a strange theorem, but it's really very useful. It lets you solve for the generating series of recursive structures.
02:49:33 <nikki93> So, if the usual lists are just linked list, what about things like std::vector and std::map in C++? Is there a library defining things like that?
02:49:44 <pumpkin> Data.Map
02:49:53 <pumpkin> is std::map, pretty much
02:49:53 <Cale> and Data.Sequence
02:50:05 <pumpkin> there's also Data.Set
02:50:14 <nikki93> For those, getting size or last or second last element is constant time?
02:50:15 <pumpkin> Data.Array, for O(1) access arrays
02:50:22 <Cale> nikki93: yeah
02:50:26 <ac> there. I annotated that paste with a version that uses (>>=). I could use it twice and eliminate the Just in the pattern match, but I think it would make it more ugly
02:50:28 <nikki93> Good.
02:50:43 <ac> Because then I would have to use monad transformers I believe
02:50:59 <Cale> A Data.Sequence of size n can be split at position k in O(min(log k,log (n-k)) time.
02:51:23 <Cale> and merged in log time as well
02:51:26 <Cale> and can be accessed at the ends in constant time
02:51:45 <Cale> and it's immutable
02:51:57 <ac> pumpkin: would you say that's as good as it could reasonably get?
02:53:36 <pumpkin> ac: if you made something to pull out that consish midi thing
02:53:47 <pumpkin> you could make a very simply chain
02:53:49 <pumpkin> simple
02:55:01 * pumpkin would still like a both = join (***) in Control.Arrow
02:58:37 <ac> pumpkin: I think I see what you're saying... however, I'm eleminating a whole class of MIDI messages with that pattern match
02:59:12 <ac> so interestingly, every time I run that function, the midi port that's opened increments, unless I kill the thread off before deleting the MIDI client
02:59:54 <ac> I mean the client number reported by "aconnect -o -l"
03:00:28 <Gracenotes> > (\ a@(x:xs) -> a) [1..5]
03:00:30 <lambdabot>   [1,2,3,4,5]
03:00:37 <ac> another interesting behavior (that's slightly annoying), is when I run killThread, it hangs until I press a key on my MIDI instrument, and then the thread dies
03:00:52 <ac> so if I delete the MIDI client before I kill the thread, I can no longer kill the thread
03:01:41 <ac> so it would seem killThread does not actually kill the thread until the RTS switches to that thread one last time
03:03:19 <Saizan_> that's true, because that thread has the opportunity to catch the exception
03:04:16 <ac> Saizan_: is there a way around that?
03:04:43 <ac> Saizan_: that thread spends all its time waiting for a MIDI event, so it will not be executed until a key is pressed. And it's annoying having to press a key to kill the thread :-P
03:05:17 <Saizan_> ac: first of all, are you compiling with -threaded ?
03:05:27 <ac> Saizan_: so far I have not compiled this program
03:06:13 <Saizan_> ok, then you're using the threaded runtime
03:06:50 <Saizan_> i guess that thread is stuck in a foreign call and can't be preempted
03:07:11 <ac> lame. would it be different if I used forkOS?
03:08:14 <Saizan_> i don't think so
03:09:01 <Saizan_> i'd ask on haskell-cafe or ghc-users
03:09:31 <ac> Saizan_: yeah, you're right. forkOS gives the same behavior
03:10:11 <ac> the same thing happens if I run receiveEvent in ghci's main thread and hit ctrl+c
03:10:20 <Saizan_> killThread just delivers an exception to that thread, but it can't be done if e.g. it's blocked in a C function
03:13:28 <Saizan_> in fact the standard IO is all based on non-blocking primitives and select
03:16:46 <nikki93> Ok, I'm trying to solve this problem: http://projecteuler.net/index.php?section=problems&id=5
03:16:52 <nikki93> calculateDiv1toX n x = if (and (map (\div -> n `mod` div == 0) [1..x])) then n else calculateDiv1toX (n + 1) x
03:17:15 <pumpkin> this one can be done really elegantly :P
03:17:17 <nikki93> How's my function? Calculates the number greater than n divisible by all integers from 1 to x. :)
03:17:24 <nikki93> pumpkin: I know, I suck. :P
03:17:35 <pumpkin> nah :) if it works, that's good
03:17:44 <nikki93> I checked with 10 and 15, it works.
03:17:47 <nikki93> Now to do it with 20. :D
03:18:11 <pumpkin> how long did it take on 15?
03:18:47 <nikki93> Around one second.
03:18:52 <nikki93> 10 was damn quick.
03:18:55 <pumpkin> I imagine 20 might be a bit beyond your reach
03:19:01 <nikki93> I know.
03:19:03 <pumpkin> it has 9 digits
03:19:10 <pumpkin> so adding 1 each time might take you a while
03:19:18 <nikki93> I'll just check divisibility by primes to 20, its better that way.
03:19:27 <nikki93> If its divisible by 6, it is divisible by 3 anyway.
03:19:36 <nikki93> But wait.
03:19:37 <pumpkin> what are you really looking for? it has a name
03:19:49 <nikki93> Forget it, I'll just wait for a while. :)
03:20:11 <pumpkin> I mean, if you're finding the smallest number that's divisible by 3 and 5, it's 15, and it's called the ...?
03:20:30 <nikki93> lol I know, LCM, c'mon. :|
03:20:42 <pumpkin> so you're looking for the LCM of 20 numbers
03:20:45 <nikki93> so just check divisibility by LCM of all 20.
03:20:47 <nikki93> Exactly
03:21:01 <pumpkin> well, it's pretty easy to compute the LCM
03:21:11 <pumpkin> so why not compute it directly rather than testing divisibility?
03:21:22 <nikki93> Wait sshh.
03:21:25 <nikki93> No more.
03:21:29 <pumpkin> :)
03:21:31 <nikki93> I'll do it self.
03:21:47 <nikki93> Waitaminnit.
03:21:58 <nikki93> Forget it. :P
03:22:25 <ac> nikki93: that's the problem with asking a room full of smart people an interesting problem that you haven't solved yet ;)
03:23:35 <pumpkin> keep in mind that if 15 took about a minute, 20 will take around 10 hours
03:23:47 <nikki93> 232792560
03:23:54 <nikki93> YEAH!
03:23:56 <pumpkin> fair enough :)
03:23:56 * Saizan_ finds a function that passes around an integer accumulator and never uses it
03:24:02 <Saizan_> amusing :)
03:24:06 <pumpkin> nikki93:  wanna see the simple one?
03:24:44 <nikki93> No wait, I did use lcm algorithm but without 3, 4 and few other numbers that were accounted for by their multiples
03:24:55 <pumpkin> alright
03:26:09 <ac> I love it how you can use a library to get some sort of data type, than start writing a function that retrieves it and simply prints it (assuming it has an instance for Show), than copy and paste the printed form in to a pattern match :)
03:26:20 <dolio> FYI: and (map p l) = all p l
03:27:03 <FunctorSalad_> > liftM head $ sequence $ repeat $ (return 'a' :: State Int Char)
03:27:05 <lambdabot>       No instance for (Show (State Int Char))
03:27:05 <lambdabot>        arising from a use of `s...
03:27:16 <FunctorSalad_> > runState (liftM head $ sequence $ repeat $ (return 'a' :: State Int Char)) 0
03:27:21 <nikki93> Haskell is an awesome language for solving math problems. :P
03:27:28 <nikki93> Solved another problem.
03:27:30 <nikki93> Easy one.
03:27:42 <nikki93> Difference between square of sum and sum of squares of numbers till 100.
03:27:43 <FunctorSalad_> why that diverges confused me for quite some time... (where State Int was Rand StdGen)
03:27:59 <ac> nikki93: Haskell is an awesome language.
03:28:04 <pumpkin> nikki93: yup :) they can get pretty hard later on though... or many of them have an obvious solution, but then ask you to find the 10^40th number in the sequence and force you to find a smarter way to do it
03:28:05 <FunctorSalad_> it evaluates the infinite list to get the final state, right?
03:28:16 <Axman6> lambdabot!
03:28:22 <pumpkin> Axman6!
03:28:34 <Axman6> pumpkin!
03:28:43 <nikki93> 5050 ^ 2 - (sum (map (\x -> x ^ 2) [1..100]))
03:28:48 <nikki93> > 5050 ^ 2 - (sum (map (\x -> x ^ 2) [1..100]))
03:28:57 <lambdabot>   25164150
03:29:05 <pumpkin> nikki93: btw, you can write just (^2) rather than \x -> x^2
03:29:19 <pumpkin> > map (^3) [1..10]
03:29:21 <nikki93> Oh. Its a function! Of course!
03:29:27 <lambdabot>   [1,8,27,64,125,216,343,512,729,1000]
03:29:31 <Axman6> everything's a function :)
03:29:45 <FunctorSalad_> I'm a literal you insensitive clod :(
03:29:50 <nikki93> > map (+3) [1..10]
03:29:57 <lambdabot>   [4,5,6,7,8,9,10,11,12,13]
03:30:04 <nikki93> Nice.
03:30:08 <FunctorSalad_> @type runRand
03:30:09 <pumpkin> you can also go on either side of an infix
03:30:12 <Axman6> nikki93: one thing to take note of:
03:30:15 <pumpkin> > map (3^) [1..10]
03:30:15 <lambdabot> Not in scope: `runRand'
03:30:18 <Axman6> > map (-3) [1..10]
03:30:21 <nikki93> > 5050 ^ 2 - (sum (^2) [1..100]))
03:30:21 <lambdabot>   [3,9,27,81,243,729,2187,6561,19683,59049]
03:30:28 <lambdabot>       No instance for (Num (a -> b))
03:30:29 <lambdabot>   <no location info>: parse error on input `)'
03:30:30 <dolio> > evalState (sequence . repeat $ return 'a') 0
03:30:35 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
03:30:38 <nikki93> Yes, that's unary negative 3
03:30:51 <dolio> > evalState (liftM head . sequence . repeat $ return 'a') 0
03:30:53 <lambdabot>   'a'
03:30:54 <pumpkin> the negative sign is a real pain
03:31:00 <FunctorSalad_> > runState (sequence . repeat $ return 'a') 0
03:31:01 <lambdabot>   ("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
03:31:02 <Axman6> indeed
03:31:03 <pumpkin> they made the subtract function to get around it
03:31:43 <FunctorSalad_> dolio: hmm with Rand StdGen it diverges :( I thought RandT was just StateT
03:32:09 <FunctorSalad_> > snd (runState (sequence . repeat $ return 'a') 0)
03:32:21 <Axman6> would it be safe to say that in haskell, if it's not data, it's a function?
03:32:24 <lambdabot>   mueval: Prelude.read: no parse
03:32:30 <Axman6> (though not vice versa though)
03:32:32 <pumpkin> Axman6: how about if ?
03:32:33 <dolio> Which State does it use?
03:32:50 <pumpkin> Axman6: you'd have to qualify "it"
03:32:53 <FunctorSalad_> dolio: StdGen I think
03:32:56 <Axman6> yeah good point
03:33:06 <dolio> No, I mean strict or lazy?
03:33:43 <Axman6> you know what's cool? ST
03:33:54 <pumpkin> Axman6: did you fix your STUArray?
03:34:34 <dolio> If it uses strict state, that won't work. If lazy, it should.
03:34:37 <Axman6> nah, and i haven't heard from dons about it at all except to say that i reminded him to take a loot at it. i was hoping he'd compile it and let me know if he's getting the same error :\
03:34:38 <FunctorSalad_> dolio: lazy   (newtype (RandomGen g) = RandT g m a = RandT (Control.Monad.State.Lazy.StateT g m a))
03:34:57 <FunctorSalad_> err: newtype (RandomGen g) => RandT g m a = RandT (Control.Monad.State.Lazy.StateT g m a)
03:35:09 <Axman6> look*
03:35:20 <pumpkin> Axman6: I can give it a go on my machine tomorrow if you email me the broken code, or give me a link to it
03:35:23 <FunctorSalad_> dolio: maybe I force the state somewhere...
03:35:29 <pumpkin> or on a few machines that I have control over
03:35:39 <pumpkin> Axman6: did you try it on the debug runtime with -DS?
03:35:53 <Axman6> never heard of it...
03:36:10 <pumpkin> if you do ghc -debug when you're compiling
03:36:18 <pumpkin> it'll give you extra options to the RTS
03:36:22 <pumpkin> one of which is -DS
03:36:32 <pumpkin> which tells it to do a ridiculous amount of sanity checking
03:36:35 <pumpkin> apparently
03:36:54 <pumpkin> it didn't find my problem, but maybe it'll help with yours
03:36:55 <Axman6> pumpkin: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=767#a768
03:40:21 <pumpkin> cool, I'll try it out
03:40:33 <pumpkin> ...tomorrow, exhausted now :P
03:40:33 <Axman6> pumpkin: some progress, slightly different numbers, and "Warning: 0x200600 still allocated at shutdown"
03:40:42 <pumpkin> that's with -DS?
03:40:48 <Axman6> yeah
03:40:57 <pumpkin> interesting, it made my app take way way longer
03:41:02 <pumpkin> it took half an hour for me
03:41:06 <pumpkin> before it segfaulted anyway :P
03:41:06 <Axman6> yeah, took a while too
03:41:21 <FunctorSalad_> dolio: apparently my use of "filter" on the infinite list causes it...
03:41:30 <Axman6> i get the segfault when i use n=23 though, and no other output
03:41:34 <FunctorSalad_> @src filter
03:41:35 <lambdabot> filter _ []     = []
03:41:35 <lambdabot> filter p (x:xs)
03:41:35 <lambdabot>     | p x       = x : filter p xs
03:41:35 <lambdabot>     | otherwise = filter p xs
03:41:36 <pumpkin> Axman6: :/
03:42:07 <dolio> I'd have to see the whole thing to have any chance of explaining why.
03:42:44 <Axman6> > let filt p xs = foldl (\acc x -> if p x then acc else x:acc) xs in filt even [1..100]
03:42:45 <lambdabot>       Overlapping instances for Show ([b] -> [b])
03:42:45 <lambdabot>        arising from a use o...
03:42:46 <pumpkin> Axman6: maybe tell the people in #ghc about that warning, might give them some idea?
03:42:59 <Axman6> yeah, will do
03:43:20 <Axman6> > let filt p xs = foldl (\acc x -> if p x then acc else x:acc) [] xs in filt even [1..100]
03:43:22 <lambdabot>   [99,97,95,93,91,89,87,85,83,81,79,77,75,73,71,69,67,65,63,61,59,57,55,53,51...
03:43:26 <FunctorSalad_> @let unitR = do { g <- get; let (a,g') = randomR (0,1) g; put g'; return a }
03:43:27 <lambdabot>   Parse error
03:43:29 <pumpkin> it's all kinda scary... I usually take my compiler for granted :P
03:43:42 <pumpkin> not being able to fully trust it is scary :)
03:43:43 <Axman6> indeed
03:44:06 <Gracenotes> > let a@(x:xs) = [1..5] in a
03:44:08 <lambdabot>   [1,2,3,4,5]
03:44:12 <dolio> > evalState (liftM (filter even) . sequence . cycle $ [return 0, return 1]) 0
03:44:14 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
03:44:16 <FunctorSalad_> @let unitR = do { g <- get; let (a,g1) = randomR (0.0,1.0) g; put g1; return a }
03:44:17 <lambdabot>   Parse error
03:45:02 <FunctorSalad_> dolio: I must be doing something wrong :(
03:45:45 <pumpkin> Gracenotes: :o
03:46:08 <pumpkin> > let a@(x:xs) [1..5] in x:a:xs
03:46:09 <lambdabot>   <no location info>: parse error on input `in'
03:46:15 <pumpkin> > let a@(x:xs) = [1..5] in x:a:xs
03:46:16 <lambdabot>       Occurs check: cannot construct the infinite type: t = [t]
03:46:16 <lambdabot>        Expect...
03:46:26 <pumpkin> > let a@(x:xs) = [1..5] in x:(a:xs)
03:46:27 <lambdabot>       Occurs check: cannot construct the infinite type: t = [t]
03:46:27 <lambdabot>        Expect...
03:46:30 <pumpkin> boo, I suck
03:46:38 <pumpkin> > let a@(x:xs) = [1..5] in x:(a ++ xs)
03:46:40 <lambdabot>   [1,1,2,3,4,5,2,3,4,5]
03:46:48 <Axman6> pumpkin: a = [1..5], xs = [2..5], so a:xs makes no sense
03:47:02 <pumpkin> yeah I realized :P it's too early/ate
03:47:03 <pumpkin> late
03:47:17 <Gracenotes> lambdabot knew
03:47:21 <Gracenotes> she was just too smug to tell you
03:47:24 <blip> meh i get a stackoverflow when going 1000000 calls  deep
03:47:25 <pumpkin> lol
03:47:38 <pumpkin> blip: strictify it, or increase your stack
03:47:47 <pumpkin> blip: or find something that's tail recursive
03:47:49 <blip> http://hpaste.org/14053
03:48:46 <dolio> FunctorSalad_: Do you have an example of a function that doesn't work?
03:48:55 <dolio> Hopefully a short one.
03:48:59 <Axman6> blip: (\x -> x == car || x == choice) == (`notElem` [car,choice])
03:49:15 <FunctorSalad_> dolio: yes, brb...
03:49:50 <Cale> Axman6: surely you mean elem
03:49:50 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
03:50:18 <Axman6> uh yeah, probably. i was using notElem earlier, so it seemed right
03:52:36 <blip> where is that supposed to go?
03:53:48 <blip> how can I make it tailrecursive?
03:55:35 <Cale> It is tail recursive.
03:55:57 <Cale> The problem is, I'm willing to bet, that you're not evaluating wins, until the very end
03:56:16 <Cale> at which point it looks like (...((0+1)+1)...)+1
03:56:27 <Cale> and evaluating that gives you a stack overflow
03:57:06 <blip> so how do I force it?
03:57:26 <pumpkin> seq
03:57:32 <Cale> So, you can replace runMonty totruns (runs+1) newWins  with newWins `seq` runMonty totruns (runs+1) newWins
03:58:00 <Cale> Or you can add {-# LANGUAGE BangPatterns #-} to the top of your file, and just stick ! before the wins parameter to runMonty
03:58:17 <Cale> runMonty totruns runs !wins = ...
03:58:35 <Gracenotes> hm. would there be a huge performance penalty using a [[Maybe MyEnum]] instead of an (Array Int (Array Int (Maybe MyEnum))) on a 20-by-20 structure?
03:58:51 <pumpkin> Gracenotes: depends how you access it
03:58:53 <Cale> One oddity is that you're passing totruns around unchanged.
03:59:10 <Gracenotes> pumpkin: it's a tetris board
03:59:13 <Cale> ah, okay, I see why you sort of need that.
03:59:27 <Gracenotes> more often 10-by-20, but possibly up to that size
03:59:28 <pumpkin> Gracenotes: so you index into it a lot with !! ?
03:59:41 <Gracenotes> in this case, with !
03:59:47 <nikki93> @hoogle Integer -> String
03:59:47 <lambdabot> Prelude show :: Show a => a -> String
03:59:47 <lambdabot> Text.Show show :: Show a => a -> String
03:59:47 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
03:59:50 <pumpkin> yeah
03:59:57 <pumpkin> nikki93: show ?
03:59:57 <Gracenotes> most of it's reading, through. Not writing.
04:00:23 <blip> wee
04:00:29 <blip> you should switch the door people!
04:00:34 <Cale> blip: yes
04:00:39 <pumpkin> I would never ahve guessed!
04:00:54 <blip> Cale: how could I avoid passing totruns?
04:00:59 <pumpkin> surely monty might open the door with the prize! ;)
04:01:19 <Gracenotes> there's no rule that says that monty can't!
04:01:31 <nikki93> @hoogle String -> Integer
04:01:31 <lambdabot> Prelude read :: Read a => String -> a
04:01:31 <lambdabot> Text.Read read :: Read a => String -> a
04:01:31 <lambdabot> Prelude error :: String -> a
04:02:11 <Pellwurst> is there a function which splits a string into several parts using a special char serving as seperator?.... kind of like the function "lines"
04:02:14 <pumpkin> Gracenotes: if he can, there's no advantage to switching, you'll just occasionally have an additional outcome of "I lost because monty stole my prize"
04:02:27 <ziman> Gracenotes, you can as well use Array (Int,Int), that's easier & faster, IMO.
04:02:34 <pumpkin> Pellwurst: look at byorgey's split package on hackage :)
04:03:10 <nikki93> @hoogle Integer -> [Char]
04:03:11 <lambdabot> Prelude show :: Show a => a -> String
04:03:11 <lambdabot> Text.Show show :: Show a => a -> String
04:03:11 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
04:03:13 <Gracenotes> ziman: you can use an int tuple as an access element?
04:03:23 <nikki93> String == [Char]?
04:03:27 <pumpkin> nikki93: yup
04:03:32 <pumpkin> @src String
04:03:32 <lambdabot> type String = [Char]
04:03:51 <pumpkin> Gracenotes: yeah
04:03:54 <pumpkin> @instances Ix
04:03:56 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
04:04:07 <ziman> Gracenotes, yes, you can use any type belonging to the Ix class.
04:04:08 <Gracenotes> yeah, I have Ix in front of me
04:04:22 <Gracenotes> oh.... that's what the tuples were for
04:04:23 <skorpan> for a while i thought we had a 16 year old girl trying to learn haskell here
04:04:25 <nikki93> > read "23"
04:04:27 <lambdabot>   * Exception: Prelude.read: no parse
04:04:35 <pumpkin> > read "23" :: Int
04:04:37 <lambdabot>   23
04:04:45 <Gracenotes> so it acts like a sparse matrix, basically
04:04:48 <nikki93> Ohhh.
04:04:57 <pumpkin> > read "23" :: Double
04:04:58 <lambdabot>   23.0
04:05:12 <pumpkin> > read "(23,53)" :: (Double, Integer) -- poor man's parser
04:05:13 <lambdabot>   (23.0,53)
04:05:24 <nikki93> sum (map read (show (factorial 100)))
04:05:28 <nikki93> > sum (map read (show (factorial 100)))
04:05:30 <lambdabot>   Not in scope: `factorial'
04:05:31 <pumpkin> it's generally safer to use reads over read though
04:05:34 <nikki93> Woops.
04:05:52 <nikki93> Ok, I'll try read.
04:05:55 <nikki93> *reads
04:05:55 <pumpkin> @let factorial n = product [1..n]
04:05:58 <lambdabot>  Defined.
04:06:14 <nikki93> > sum (map read (show (factorial 100)))
04:06:16 <lambdabot>   Couldn't match expected type `String' against inferred type `Char'
04:06:26 <nikki93> That's the problem I'm getting.
04:06:32 <ziman> Gracenotes, it acts as a (dense) contiguous linear array, which can be indexed by tuples (because tuples can be converted to linear indices).
04:06:34 <pumpkin> well given taht show gives a String
04:06:38 <pumpkin> and you're calling map on it
04:06:42 <pumpkin> and String is a list of chars
04:06:47 <pumpkin> read will be passed a single char
04:06:51 <pumpkin> and it expects a string...
04:07:00 <vixey> :t factorial 100
04:07:01 <nikki93> No, I want to convert the string into a list of digits.
04:07:01 <Gracenotes> ah.
04:07:01 <lambdabot> forall t. (Enum t, Num t) => t
04:07:03 <FunctorSalad_> dolio: I tried to minimize it... http://hpaste.org/14054
04:07:20 <pumpkin> > digitToInt '4' -- nikki93
04:07:22 <lambdabot>   4
04:07:22 <nikki93> foreach char in string do convertchartointegerandreturnit
04:07:23 <ziman> Gracenotes, an array lazy in elements, that is; dense but lazy.
04:07:28 <nikki93> OHH
04:07:38 <vixey> foreach
04:07:40 <pumpkin> (it's in Data.Char)
04:08:10 <FunctorSalad_> dolio: apparently it is because "sample10 foo" nests two calls of "stream"
04:08:21 <Gracenotes> ziman: so making one would we something like... listArray ((1,1),(20,20)) (repeat Nothing)
04:08:23 <Gracenotes> right?
04:08:27 <Gracenotes> *be
04:08:49 <ziman> Gracenotes, i guess replicate 400 Nothing, but yes.
04:09:05 <Gracenotes> I suppose that's what my array would have anyway in two dimensions
04:09:21 <Gracenotes> all right. Sounds good :)
04:09:30 <nikki93> The downright dirtiest way to do it:
04:09:34 <nikki93> > findSumInFac n = sum (map digitToInt (show (factorial n)))
04:09:36 <lambdabot>   <no location info>: parse error on input `='
04:09:47 <nikki93> > let findSumInFac n = sum (map digitToInt (show (factorial n))) in findSumInFac 100
04:09:49 <lambdabot>   648
04:09:52 <pumpkin> :)
04:09:54 <ziman> Gracenotes, it's also very useful for dynamic programming, enabling the programmer to retain declarativeness of the array definition ;)
04:09:54 <Cale> blip: You could put the loop inside of a where clause
04:09:57 <pumpkin> at least it's correct
04:10:01 <nikki93> pumpkin: I know.
04:10:03 <nikki93> pumpkin: hahaha
04:10:03 <ziman> (i mean laziness)
04:10:09 <Cale> blip: You might also be interested in this, which I just hacked up quickly.
04:10:13 <Cale> blip: http://hpaste.org/14055
04:10:14 <vixey> :t divMod
04:10:16 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
04:10:21 <vixey> > divMod 323 10
04:10:22 <lambdabot>   (32,3)
04:10:33 <nikki93> pumpkin: How's it?
04:10:44 <pumpkin> nikki93: that's pretty much exactly how I solved that one :P
04:10:45 <Gracenotes> ziman: I also don't run into the problem of jagged arrays
04:10:53 <pumpkin> nikki93: except syntaxwise
04:11:06 <Gracenotes> everything's in a nice little rectangle, not a stack of lines
04:11:10 <pumpkin> > sum . map digitToInt . show . factorial $ 100
04:11:11 <lambdabot>   648
04:11:17 <pumpkin> I don't like parentheses :)
04:11:35 <ziman> Gracenotes, i've just tested `listArray ((1,2),(4,4)) [1..]' and it was ok, so you can just use `repeat Nothing' and it'll take the first n elements correctly.
04:12:05 <Cale> *Main> montyKeep
04:12:05 <Cale> RV [(2 % 3,False),(1 % 3,True)]
04:12:05 <Cale> *Main> montySwap
04:12:05 <Cale> RV [(1 % 3,False),(2 % 3,True)]
04:12:19 <blip> and why is it so slow? 1000000 runs in like 20 seconds
04:12:42 <vixey> @let decimate = flip divMod 10
04:12:45 <Cale> Probably mostly the inefficiency of StdGen
04:12:45 <lambdabot>  Defined.
04:12:47 <Gracenotes> ziman: all right. Time to convert code..
04:13:33 <vixey> > let whop (0,0) = Nothing ; whop e = Just e in unfoldr (whop decimate) (factorial 100)
04:13:34 <lambdabot>   Couldn't match expected type `(t, t1)'
04:13:36 <vixey> > let whop (0,0) = Nothing ; whop e = Just e in unfoldr (whop . decimate) (factorial 100)
04:13:38 <lambdabot>   [93326215443944152681699238856266700490715968264381621468592963895217599993...
04:13:47 <ziman> Gracenotes, when you find out how efficiency of the program changes in this case, i'd like to know.
04:13:49 <vixey> > let whop (0,0) = Nothing ; whop (e,o) = Just (o,e) in unfoldr (whop . decimate) (factorial 100)
04:13:50 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,6,8,6,1,9,0,1,2,5,8,1,1,...
04:14:13 <vixey> > let whop (0,0) = Nothing ; whop (e,o) = Just (o,e) in foldr (+) 0 . unfoldr (whop . decimate) $ factorial 100
04:14:14 <lambdabot>   648
04:14:29 <nikki93> > sum (digits (factorial 100))
04:14:30 <lambdabot>   Not in scope: `digits'
04:14:40 <Gracenotes> ziman: it's kind of hard to tell, because Tetris isn't exactly performance-intensive. However, I think it'll make it much easier to read and maintain
04:14:44 <pumpkin> @hoogle digits
04:14:44 <lambdabot> Prelude floatDigits :: RealFloat a => a -> Int
04:14:44 <lambdabot> Numeric floatToDigits :: RealFloat a => Integer -> a -> ([Int], Int)
04:14:44 <lambdabot> Numeric lexDigits :: ReadS String
04:15:06 <nikki93> > sum (floatToDigits (factorial 100))
04:15:07 <lambdabot>   Couldn't match expected type `[a]'
04:15:13 <nikki93> lambdabot: Get lost.
04:15:48 <Gracenotes> ziman: that is, readings of the array are far and few between in computer time, but when they do occur they should be snappy, so as not to cause GUI lag
04:16:01 <Axman6> > floatDigits (pi :: Double)
04:16:03 <lambdabot>   53
04:16:09 <Axman6> > floatDigits (pi :: CReal)
04:16:10 <lambdabot>   * Exception: CReal.floatDigits
04:16:29 <nikki93> > sum (floatToDigits ((factorial 100) :: Double))
04:16:31 <lambdabot>   Couldn't match expected type `Integer'
04:16:33 <pumpkin> > showCReal $ exp 1
04:16:35 <lambdabot>       Overlapping instances for Show (CReal -> String)
04:16:35 <lambdabot>        arising from a ...
04:16:37 <pumpkin> > showCReal 100 $ exp 1
04:16:39 <lambdabot>   "2.718281828459045235360287471352662497757247093699959574966967627724076630...
04:16:55 <nikki93> What are the dots and dollar signs for?
04:17:01 <nikki93> Unparanthesisizing?
04:17:01 <pumpkin> @src ($)
04:17:01 <lambdabot> f $ x = f x
04:17:05 <pumpkin> @src (.)
04:17:06 <lambdabot> (f . g) x = f (g x)
04:17:15 <pumpkin> applying a function, and composing
04:17:18 <nikki93> @src factorial
04:17:19 <lambdabot> Source not found. Maybe if you used more than just two fingers...
04:17:20 <pumpkin> $ has lowest precedence
04:17:35 <lunabot>  luna: Not in scope: `has'
04:17:37 <pumpkin> so it essentially acts as an "execution delayer"
04:17:38 <nikki93> @src :
04:17:38 <lambdabot> Source not found. Are you on drugs?
04:17:39 <blip> Cale: cool but i dont really understand the code :)
04:17:49 <nikki93> @src (+)
04:17:50 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
04:17:53 <ziman> Gracenotes, i see. I suppose it'll run without any problems (a 20x20 array is rather tiny); and readability of the source code is usually my objective #1 ;)
04:19:03 <Cale> blip: Basically, it's a monad for making selections and keeping track of their probability as if they were random (but we actually do it in all possible ways)
04:19:26 <blip> can someone link me to a proof of why 1 + 1 = 2? and is that even interesting since Gödel showed no formal system can b complete and consistent? so you have to start with something selfevident but not proven anyway(and then 1+1=2 seems like a good start)?
04:19:30 <Cale> blip: the collect function just simplifies the representation, by collecting together the values which are equal
04:19:59 <pumpkin> > let 1 + 1 = 3 in 1 + 1
04:20:00 <lambdabot>   3
04:20:18 <nikki93> O_O
04:20:39 <nikki93> > let 1 / 0 = 7 in 1 / 0
04:20:41 <lambdabot>   7
04:20:45 <nikki93> O_O O_O
04:20:54 <nikki93> Haskell can divide by zero!
04:21:07 <Cale> 1 + 1 = 2 isn't really a good axiom of course -- usually the things which you take as "self-evident" are the useful properties like there exists a number 0 such that for any a, 0 + a = a, and a + (b + c) = (a + b) + c, and similar things.
04:21:43 <Cale> Actually in modern mathematics, we tend to take a set theory as foundational, and build numbers out of sets.
04:21:45 <nikki93> Cale: (a + b
04:22:08 <Cale> But you can prove 1 + 1 = 2 given a definition of 1, 2, and +
04:22:31 <Cale> and what the proof looks like depends on those definitions
04:22:33 <nikki93> Cale: (a + b) + c == a + (b + c) arises fromthe definition of addition. Its not a 'no-proof' type thing, if that's what you mean.
04:22:33 <pumpkin> assuming that for those definitions, the statement is actually true :P
04:22:49 <Cale> nikki93: Well, it's a ring axiom.
04:22:58 <nikki93> Cale: Whatever that is...
04:23:12 <blip> what is the easiest way to get a gui up?
04:23:16 <pumpkin> a ring's a mathematical structure
04:23:18 <Cale> nikki93: It's fairly common to define the real numbers axiomatically.
04:23:29 <Cale> and that would be one of the axioms you'd take
04:23:50 <Cale> (and not worry about actually defining + directly)
04:23:53 <Saizan_> blip: use gtk2hs
04:24:26 <nikki93> Cale: In that case, commutativity and no-order-for-additionitivity (what ever its called) stems from the definition of addition, and is not without reason.
04:24:37 <vixey> blip:  refl_equal 2 : 1 + 1 = 2
04:24:50 <nikki93> > 1 + 1 == 2
04:24:52 <lambdabot>   True
04:24:57 <nikki93> > 1 + 1 == 5
04:24:59 <lambdabot>   False
04:25:04 <Axman6> > check (\a b c -> a + (b + c) == (a + b) + c)
04:25:05 <lambdabot>   Not in scope: `check'
04:25:07 <pumpkin> nikki93: but other things one might take for granted like a * b = b * a depend on what you're working on
04:25:10 <Axman6> @check (\a b c -> a + (b + c) == (a + b) + c)
04:25:11 <lambdabot>   "OK, passed 500 tests."
04:25:22 <Axman6> @check (\a b c -> a + (b + c) == (a + b) + (c::CReal))
04:25:23 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Arbitrary
04:25:23 <lambdabot>          ...
04:25:24 <nikki93> (1 + 1) * 0 == (5) * 0
04:25:28 <Axman6> @check (\a b c -> a + (b + c) == (a + b) + (c::Double))
04:25:29 <lambdabot>   "Falsifiable, after 7 tests:\n5.5\n-5.142857142857143\n0.6666666666666667\n"
04:25:35 <nikki93> > (1 + 1) * 0 == (5) * 0
04:25:37 <lambdabot>   True
04:25:42 <nikki93> Dividing by zero on both sides, we get 1 + 1 = 5.
04:25:43 <pumpkin> Axman6: not sure == works very well on CReal
04:25:53 <Cale> nikki93: Uh, no, they'd stem from the fact that you're assuming they're true.
04:26:02 <Axman6> pumpkin: doesn't work very well on doubles, that's for sure :P
04:26:18 <nikki93> Cale: Yes. That doesn't mean we assumed commutativity is true.
04:26:27 <Cale> nikki93: We normally would.
04:26:28 <pumpkin> nikki93: except dividing by zero doesn't make sense... :P
04:26:33 <Cale> (in that setting)
04:26:38 <nikki93> Cale: You assume x, so and x being true makes y true doesn't mean we're assuming y.
04:26:42 <blip> does old-locale and process and time come with ghc?
04:26:58 <nikki93> Cale: Assuming x, and x being true making y true doesn't mean we're assuming y.
04:26:59 <Axman6> process and time do i believe
04:27:03 <Cale> nikki93: A quick way to get started with the reals is actually not to define the reals in terms of sets, but just to take the fact that they're a field for granted, and then the fact that they're totally ordered, and then order-complete
04:27:05 <nikki93> (better formed sentence last one)
04:27:24 <nikki93> Cale: I'm just going to give up and live with it.
04:27:27 <nikki93> Cale: How about you?
04:27:36 <pumpkin> o.O
04:27:48 <Cale> In that case, you're assuming about 13 things...
04:27:51 <nikki93> pumpkin: Shh, you're just a fruti.
04:27:54 <nikki93> *fruit
04:27:59 <pumpkin> a squash, actually
04:28:01 <Cale> One of which is commutativity and one of which is associativity.
04:28:02 <ziman> I thought 2 was a shortcut notation for succ(succ(0)) = 1 + (1 + 0) = (1 + 1) + 0 = 1 + 1
04:28:17 <pumpkin> ziman: if you like peano :)
04:28:22 <vixey> ziman, it could be, it could be shorthand for {{},{{}}} also
04:28:48 <Cale> Of course, you can later on define the reals in terms of sets (say, sets of rational numbers), and then define addition and multiplication and the ordering and show that they have all the required properties.
04:28:49 <nikki93> We can prove associativity from our definition of terms (which we assume), that doesn't mean that we assume associativity
04:28:52 <nikki93> Cale is my friend.
04:28:54 <nikki93> We assume his name is CAle.
04:28:57 <ziman> uh, i'm not familiar with the set concept. Any keywords I should google?
04:29:01 <nikki93> That doesn't mean we assume he's my friend.
04:29:09 <Cale> nikki93: We *may* assume associativity, if we like.
04:29:13 <vixey> nikki93, it's as good as an assumption
04:29:23 <nikki93> vixey: May be, but not quite.
04:29:44 <nikki93> When I refered to Cale, I meant Cale himself (whatever he is), not his name or 'through' his name
04:29:57 <papermachine> Hunh?
04:30:02 <Cale> Of course, without a model for the reals, there's no way to actually know whether there's a set satisfying all those properties we assumed.
04:30:16 <oklopol> nikki93: Cale: Assuming x, and x being true making y true doesn't mean we're assuming y. <<< yes it means
04:30:20 <Cale> So we might go on to prove a bunch of nonsense.
04:30:27 <Cale> But there is, so it's cool.
04:30:43 <nikki93> > let whoIsRight = "nikki is right!"
04:30:45 <lambdabot>   <no location info>: parse error on input `;'
04:30:51 <nikki93> So, Cale is right.
04:30:56 <nikki93> :|
04:31:00 <pumpkin> nikki93: he tends to be ;)
04:31:03 * Twey chuckles.
04:31:04 <nikki93> lol
04:31:08 <Cale> We can choose to take things as axioms which are provable from our other axioms as well. That's fine.
04:31:18 <Cale> It's just slightly inelegant.
04:31:43 <nikki93> But its been proven to be a pretty good model of the real world.
04:31:57 <Cale> Oh, I don't mean that sort of model...
04:32:02 <nikki93> For example, physics in computer games are based on our understanding of math and physics.
04:32:10 <nikki93> It's pretty realistic, I should say. :)
04:32:10 <Yoric[DT]> hi
04:32:15 <Cale> I mean a model in terms of sets, just in case you're confused about that.
04:32:16 <vixey> hi
04:32:17 <nikki93> Yoric[DT]: Hi.
04:32:18 * papermachine blinks.
04:32:25 <nikki93> Cale: Ok.
04:32:37 <oklopol> nikki93: what do you suggest as a definition of + for reals then?
04:32:56 <vixey> just reuse (+) :: Q -> Q -> Q
04:32:57 <nikki93> oklopol: Provided their order is defined, you increment one by the other.
04:33:05 <oklopol> nikki93: increment by what?
04:33:08 <Cale> Mathematics never really justifies itself in terms of the real world. At least, most mathematicians these days don't really care very much if the mathematics they're doing is useful for modelling the real world.
04:33:19 <nikki93> oklopol: By the smallest real. :P
04:33:24 <pumpkin> o.O
04:33:27 <oklopol> nikki93: a basic property of reals is that makes no sense.
04:33:40 <pumpkin> you can't even do that for rationals
04:33:44 <nikki93> oklopol: Ok, you win. Now, don't use reals.
04:33:45 <Axman6> 1/infinity nikki93 ?
04:33:49 <oklopol> i suggest you stop doubting and start learning :P
04:34:02 <Cale> Of course, it usually turns out to be, because mathematics reflects the way that we think about things, and when we go to construct models of what we see in the real world, mathematics has probably looked at a lot of the patterns we might notice.
04:34:08 <nikki93> Emm... I wasn't doubting any thing. Really.
04:34:08 <vixey> if reals were convergent sequences of rationals
04:34:12 <Axman6> 1/â
04:34:14 <FunctorSalad_> dolio: nevermind, fixed it by rewriting filterR to use if/then/else recurse
04:34:29 <pumpkin> Axman6: ooh! 0.(0)1!
04:34:29 <nikki93> Axman6: Whaddya say that is? 0?
04:34:44 <pumpkin> yup
04:34:48 <blip> ziman: zermel frankel set theory on wikipedia
04:34:52 <Axman6> > 1/infinity
04:34:54 <lambdabot>       Ambiguous occurrence `infinity'
04:34:54 <lambdabot>      It could refer to either `L.infini...
04:34:58 <Axman6> > 1/L.infinity
04:34:58 <nikki93> Oh wait, I can't talk to you guys.
04:34:58 <pumpkin> limt as x goes to infinity of 1/x is 0
04:34:59 <lambdabot>   0.0
04:35:04 <nikki93> My mother said don't talk to strangers.
04:35:07 <nikki93> Sorry. :(
04:35:10 <pumpkin> o.O
04:35:12 <Axman6> pumpkin: that's the limit though
04:35:15 <athos> @hoogle lim
04:35:16 <lambdabot> Text.XHtml.Transitional lime :: String
04:35:16 <lambdabot> System.Posix.Types type Limit = CLong
04:35:19 <pumpkin> Axman6: that's all infinity means
04:35:29 <Axman6> which, from my understanding, is not the same as the value at infinity
04:35:37 <vixey> blip did you see my proof?
04:35:38 <pumpkin> there is no value at infinity except in ieee754 :P
04:35:40 <Axman6> or at x i should say
04:35:44 <Axman6> :P
04:35:51 <nikki93> Waitaminnit.
04:35:53 <Cale> pumpkin: heh, I have to cringe when I see people write things like that "decimal expansion" you gave ;)
04:35:57 <nikki93> pumpkin: So you're saying 1/0 = infinityness?
04:36:04 <Axman6> you should not be able to recite IEEE spec numbers :P
04:36:10 <pumpkin> Cale: sorry, didn't mean to make you cringe :)
04:36:10 <Axman6> > 1/0
04:36:11 <lambdabot>   Infinity
04:36:14 <Cale> pumpkin: hehe
04:36:29 <nikki93> > 2/0
04:36:31 <lambdabot>   Infinity
04:36:32 <vixey> 1/0 is a very different thing to lim [x -> infinity] 1/x
04:36:34 <Cale> pumpkin: It seems that people get that one into their head when not realising that 0.999... = 1
04:36:35 <Gilly> > (-1)/0
04:36:36 <nikki93> > 5/0
04:36:37 <pumpkin> nikki93: well, I'd say the limit as x goes to 0 of 1/x grows unboundedly
04:36:38 <lambdabot>   -Infinity
04:36:38 <lambdabot>   Infinity
04:36:40 <Gilly> haha
04:36:43 <Gilly> that's bad...
04:36:50 <nikki93> Therefore, Infinity * 0 = everypositivenumber
04:37:02 <pumpkin> nikki93: the fallacy is that infinity isn't a number
04:37:04 <Cale> Gilly: heh, you think that's bad...
04:37:04 <Gilly> since 1/0 could be -infinity as well... this makes no sense
04:37:08 <Cale> > (0/0) == (0/0)
04:37:10 <lambdabot>   False
04:37:10 <nikki93> > 0/0
04:37:12 <lambdabot>   NaN
04:37:23 <Cale> > let x = (0/0) in x == x
04:37:24 <jesusabdullah> Ah, good ol' calculus
04:37:25 <lambdabot>   False
04:37:26 <nikki93> > Infinity - 3
04:37:27 <lambdabot>   Not in scope: data constructor `Infinity'
04:37:29 <jesusabdullah> This I understand
04:37:37 <Axman6> > 1/NaN
04:37:38 <FunctorSalad_> floating point infinity is pretty nice for order purposes though
04:37:38 <lambdabot>   Not in scope: data constructor `NaN'
04:37:38 <athos> 12:36:51 < nikki93> Therefore, Infinity * 0 = everypositivenumber
04:37:39 <nikki93> > ChuckNorris == Infinity
04:37:41 <Gilly> :)
04:37:41 <lambdabot>   Not in scope: data constructor `ChuckNorris'Not in scope: data constructor ...
04:37:41 <Axman6> bah
04:37:42 <Cale> jesusabdullah: IEEE arithmetic has very little to do with calculus ;)
04:37:42 <athos> i think that's nonsense
04:37:52 <jesusabdullah> Indeed
04:37:53 <nikki93> ChuckNorris ain't in scope.
04:37:53 <Axman6> > 1/(read "NaN")
04:37:53 <blip> Cale: then what is the purpose? something that still works to solve some problems?
04:37:55 <lambdabot>   NaN
04:38:00 <FunctorSalad_> it gives you a minimum/maximum for the empty set
04:38:02 <athos> it contradicts with the axiom of archimedes
04:38:04 <nikki93> read "Infinity"
04:38:04 <Cale> blip: of what?
04:38:06 <pumpkin> Cale: does IEEE fall into some mathematical structure?
04:38:07 <nikki93> > read "Infinity"
04:38:09 <athos> (i think it was that one..)
04:38:09 <lambdabot>   * Exception: Prelude.read: no parse
04:38:20 <pumpkin> Cale: other than "Abomination"
04:38:22 <nikki93> > read "Infinity" :: Integer
04:38:24 <lambdabot>   * Exception: Prelude.read: no parse
04:38:25 * Maddas chuckles
04:38:33 <Gilly> ieee itself is a mathematical structure somehow approximating numbers :P
04:38:42 <Cale> pumpkin: The operations are commutative and they have an identity, but not much else.
04:38:42 <vixey> blip, ah... it's /you/ now I get why you're ignoring me
04:38:43 <pumpkin> nikki93: only IEEE (Double, Float) has infinity
04:38:44 <FunctorSalad_> pumpkin: complete order
04:38:59 <nikki93> > 1/0.00000000000000001
04:39:00 <pumpkin> FunctorSalad_: how about the bad values?
04:39:01 <lambdabot>   1.0e17
04:39:13 <pumpkin> > (0/0) > (0/0)
04:39:15 <lambdabot>   False
04:39:17 <nikki93> > 1/100000000000000000000000000000000000000
04:39:17 <pumpkin> > (0/0) < (0/0)
04:39:19 <lambdabot>   False
04:39:19 <lambdabot>   1.0e-38
04:39:21 <pumpkin> > (0/0) == (0/0)
04:39:22 <Cale> pumpkin: They're not even associative, which sucks.
04:39:23 <lambdabot>   False
04:39:30 <jesusabdullah> Why are we trying to divide by zero?
04:39:31 <FunctorSalad_> pumpkin: ok NaN is bad I guess, but infinity is necessary for 0,1,2, ... to have a least upper bound :)
04:39:33 <Axman6> > (0/0) /= (0/0)
04:39:35 <lambdabot>   True
04:39:38 <Axman6> whoot
04:39:41 <jesusabdullah> umm
04:39:46 <jesusabdullah> does infinity count as a lub?
04:39:47 <nikki93> jesusabdullah: Because its useful for making black holes.
04:39:52 <blip> Cale: the purpose of mathematics, or abstract mathematics
04:39:58 <FunctorSalad_> pumpkin: but as has been said the arithmetic is off...
04:40:01 <Cale> blip: What is the purpose of music?
04:40:03 <pumpkin> yeah
04:40:05 <Ringo48> why did it return false before 1.0e-38?
04:40:12 <Cale> blip: The answer is similar.
04:40:14 <pumpkin> Ringo48: because I asked it something
04:40:24 <pumpkin> Ringo48: to which the answer was False
04:40:25 <Axman6> @karma Ringo48
04:40:25 <lambdabot> Ringo48 has a karma of 0
04:40:28 <Axman6> @karma pumpkin
04:40:29 <lambdabot> pumpkin has a karma of 2
04:40:30 <nikki93> > 5 * 0 = 2 * 0
04:40:31 <ghostscript> jesusabdullah: I think the purpos is to handle situations when you don't know what you would end up dividing by at runtime
04:40:31 <lambdabot>   <no location info>: parse error on input `='
04:40:35 <skorpan> @karma skorpan
04:40:35 <lambdabot> You have a karma of 1
04:40:36 <nikki93> > 5 * 0 == 2 * 0
04:40:38 <lambdabot>   True
04:40:38 <Axman6> @karma Axman6
04:40:38 <lambdabot> You have a karma of 3
04:40:40 <vixey> "What's Jazz?"
04:40:41 <skorpan> aw yeah, hot with karma
04:40:42 <nikki93> Hence, 5 = 2
04:40:52 <pumpkin> nikki93: you tried that one on us earlier ;)
04:40:53 <nikki93> Similarily, everyNumber = everyOtherNumber
04:40:57 <FunctorSalad_> @let NaN = 0/0
04:40:59 <lambdabot>  <local>:44:0: Not in scope: data constructor `NaN'
04:41:02 <Ringo48> lol, I didn't know about that
04:41:05 <FunctorSalad_> ;)
04:41:07 <nikki93> Similarly, I have one-centillion-billion-gazzillion dollars.
04:41:18 <ghostscript> jesusabdullah: So you can handle that as a special case in the representation itself
04:41:24 <Cale> blip: The fact that mathematics happens to be very useful is secondary to the way we construct it. We tend to do mathematics because it's beautiful and intrinsically interesting.
04:41:26 <jesusabdullah> Hmm
04:41:27 <Ringo48> @karma lambdabot
04:41:28 <lambdabot> lambdabot has a karma of 0
04:41:29 <jesusabdullah> I suppose
04:41:30 <Axman6> Ringo48: the real answer i think is that lambdabot forks off tasks, and just prints them in the order they finish
04:41:33 <ghostscript> @karma ghostscript
04:41:33 <lambdabot> You have a karma of 0
04:41:36 <Axman6> lambdabot++
04:41:37 <ziman> zygohistoparametazillion :)
04:41:39 <ghostscript> :-)
04:41:42 <Axman6> @karma
04:41:42 <lambdabot> You have a karma of 3
04:41:43 <Ringo48> oh
04:41:48 <pumpkin> nikki93: you gotta play by the rules or your conclusions are meaningless :)
04:41:49 <Axman6> ghostscript: shortcut hacks!
04:41:52 <jesusabdullah> but why not just be like, "if this doesn't return a real-valued number it's garbage" ?
04:42:00 <Gracenotes> @pl \f g x = filter f (map g x)
04:42:00 <lambdabot> (line 1, column 8):
04:42:00 <lambdabot> unexpected "="
04:42:00 <lambdabot> expecting pattern or "->"
04:42:01 <pumpkin> Axman6++
04:42:01 <nikki93> pumpkin: I make the rules.
04:42:03 <jesusabdullah> or, a complex one, whichever
04:42:05 <Gracenotes> eek
04:42:11 <Gracenotes> @pl \f g x -> filter f (map g x)
04:42:11 <lambdabot> (. map) . (.) . filter
04:42:12 <ghostscript> Axman6: I never new there was this nifty karma thing available
04:42:14 <ghostscript> :-D
04:42:15 <jesusabdullah> idk :/
04:42:16 <Ringo48> @karma ChanServ
04:42:17 <lambdabot> ChanServ has a karma of 0
04:42:17 <pumpkin> nikki93: if you make rules that allow for meaningless conclusions, you're not going to get very far :)
04:42:26 <athos> @karma
04:42:26 <lambdabot> You have a karma of 0
04:42:27 <pumpkin> @karma karma
04:42:28 <lambdabot> karma has a karma of 0
04:42:28 <jesusabdullah> Could have something to do with the sorts of problems I tend to work on
04:42:29 <Cale> blip: It's sort of what's left over when you take logical thought and remove the outside world from the picture -- it's everything which you can precisely define in your head without having to refer to something physical.
04:42:30 <Axman6> ChanServ++
04:42:32 <jesusabdullah> boring engineering ones.
04:42:34 <Axman6> very handy
04:42:35 <jesusabdullah> :v
04:42:35 <pumpkin> ?users
04:42:35 <lambdabot> Maximum users seen in #haskell: 612, currently: 611 (99.8%), active: 26 (4.3%)
04:42:40 <Gilly> Cale: well - i guess that depends on the person - some ppl may approach mathematics just because it's useful elsewhere
04:42:42 <nikki93> pumpkin: No, the rule is that I get very far.
04:42:48 <Cale> Gilly: That's true...
04:42:49 <Gilly> Cale: actually most of the non-mathematicians :)
04:42:57 <athos> nikki93: by breaking rules
04:42:59 <blip> where does cabal want to isntallt hings on windows? i get permission denied when running runhaskell setup install
04:43:06 <Cale> Gilly: Right, I'm mostly talking about why mathematicians do mathematics.
04:43:19 <jesusabdullah> I always figured it was because it's fun.
04:43:21 <Cale> There are applied mathematicians who have their favourite real-world applications too.
04:43:23 <jesusabdullah> >_<
04:43:26 <Maddas> Gilly: It doesn't really make much sense to attribute intrinsic purpose to a field of study, anyhow.
04:43:28 <Cale> But mostly it's because it's fun.
04:43:28 <nikki93> I made a resolution.
04:43:33 <Gilly> Cale: yup :)
04:43:36 <jesusabdullah> I like real-world applications
04:43:38 <nikki93> I wont waste time with you guys anymore, and will go learn Haskell instead.
04:43:40 <jesusabdullah> but then again I'm not a mathematician
04:43:48 <jesusabdullah> I'm an engineering major with a math MINOR
04:43:48 <Axman6> nikki93: good idea ;)
04:43:53 <Axman6> pumpkin++
04:44:02 <Axman6> because we're unbooxed error budies
04:44:05 <nikki93> > 1++
04:44:06 <lambdabot>   <no location info>: parse error on input `;'
04:44:06 <Axman6> unboxed*
04:44:14 <pumpkin> nikki93: feel free to ask more questions though :)
04:44:17 <nikki93> > let x = 1 in x++
04:44:18 <lambdabot>   <no location info>: parse error on input `;'
04:44:19 <Axman6> far out darcs is slow
04:44:22 <ghostscript> Axman6++
04:44:23 <nikki93> > let x = 1 in ++x
04:44:25 <lambdabot>   <no location info>: parse error on input `++'
04:44:28 <nikki93> > let x = 1 in x + 1
04:44:30 <pumpkin> nikki93: but be careful, people here tend to get very deep into issues you present if you're not careful
04:44:30 <lambdabot>   2
04:44:31 <Cale> blip: I don't have a windows machine to look... but on linux, it makes a directory under your home directory, so you might check in Windows/Profiles
04:44:32 <oklopol> my real-world application is theoretical algorithmics
04:44:35 <Gilly> Maddas: that's true
04:44:40 <oklopol> hi Gilly
04:44:41 <nikki93> pumpkin: BAH! :P
04:44:44 <Gilly> oklopol: heya
04:44:44 <ghostscript> @karma Axman6
04:44:45 <lambdabot> Axman6 has a karma of 5
04:44:46 <Cale> blip: Or... that's moved now... documents and settings?
04:44:50 <Axman6> :)
04:45:01 <jesusabdullah> ...I should learn me a haskell. >_<
04:45:03 <Axman6> i'ma movin up!
04:45:03 * jesusabdullah rolls his eyes.
04:45:05 <oklopol> quite floody in here, can't get anything done today if i keep reading.
04:45:06 <oklopol> ->
04:45:10 <ghostscript> Axman6: Sorry! I should be off now
04:45:17 <Cale> blip: But this is just a guess. Someone with an actual windows machine should know.
04:45:17 * ghostscript admonishes himself
04:45:22 <pumpkin> nikki93: you can actually define x++ in haskell to work just like in c, in certain contexts, but it isn't built in
04:45:23 <Vq^> Cale: i think it differs in every version
04:45:24 <Axman6> o.O
04:45:27 <pumpkin> nikki93: you can also do +=
04:45:40 <PeakerWork> @index ($>)
04:45:40 <lambdabot> bzzt
04:45:42 <nikki93> @let pumpkinFTW x = if (x > 0) then "pumpkin FTW! " ++ pumpkinFTW (x - 1) else "(not)"
04:45:45 <lambdabot>  Defined.
04:45:49 <pumpkin> lol
04:45:53 <Gracenotes> @hoogle (a -> b) -> (a -> Bool) -> [a] -> [b]
04:45:54 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
04:45:54 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
04:45:54 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
04:45:56 <nikki93> > pumpkinFTW 4
04:45:59 <lambdabot>   "pumpkin FTW! pumpkin FTW! pumpkin FTW! pumpkin FTW! (not)"
04:45:59 <pumpkin> thanks! (not)
04:46:02 <nikki93> lol
04:46:05 <Gracenotes> @hoogle (a -> Bool) -> (a -> b) -> [a] -> [b]
04:46:05 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
04:46:05 <abbe> hi all
04:46:06 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
04:46:06 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
04:46:10 <Gracenotes> hrm.
04:46:14 <Gracenotes> filterMap, where art thou?
04:46:21 <Vq^> abbe: hello there
04:46:24 <Cale> Gracenotes: concatMap?
04:46:27 <pumpkin> Gracenotes: why would you need that?
04:46:27 <ghostscrip1> @quit
04:46:28 <lambdabot> Not enough privileges
04:46:31 <abbe> hi Vq^
04:46:35 <Gilly> For myself I'm into mathematics just because it's fun... I'm a bit worried about the future though :) Having fun doesn't always pay too much... So I probably have to find something else to do after my studies, too...
04:46:49 <pumpkin> Gilly: stick to fun things!
04:46:52 <pumpkin> work out the details later :P
04:46:53 <Gracenotes> wait... wrong type
04:46:54 <Maddas> Gilly: It might work out fine :-)
04:46:58 <Cale> Gilly: I'm stuck in that post-studies limbo-realm :)
04:47:09 <Gracenotes> @hoogle (a -> b) -> (b -> Bool) -> [a] -> [b]
04:47:09 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
04:47:09 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
04:47:09 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
04:47:11 <Axman6> Gilly: concatMap (\x -> guard (p x) (return x)) xs?
04:47:12 <Gracenotes> argh.
04:47:14 <Cale> Gilly: I'm hoping to get back into it soon though.
04:47:16 <Axman6> uh, Gracenotes
04:47:18 <Axman6> even
04:47:25 <Maddas> Cale: Into the limbo-realm? :-)
04:47:34 <Cale> Maddas: Into academia.
04:47:37 <pumpkin> Cale: to grad school? or have you been there done that?
04:47:39 <Gracenotes> I can't even figure out the type signature
04:47:44 <Cale> pumpkin: exactly
04:47:49 <pumpkin> which? :P
04:47:54 <Cale> pumpkin: the first
04:47:55 <Gilly> Heh yea... well, I'm in the army at the moment, but going to start studying next autumn.
04:47:57 <pumpkin> ah :)
04:48:08 <Axman6> the mor an more time i spend at uni, the more i feel i'd quite like to end up lecturing or something
04:48:11 <pumpkin> Cale: I had assumed you were already a grad student
04:48:15 <Axman6> more*
04:48:21 <Cale> pumpkin: No, I've just been studying on my own.
04:48:49 <vixey> bleugh. I hate formal education
04:49:09 <pumpkin> it can be fun, if free enough
04:49:22 <abbe> I'm having this problem related to types, which I've pasted at http://hpaste.org/14057
04:49:30 <Axman6> i'm finding i reallt fit into university, far more than i did with all my prior schooling. i'm actually doing the work and assignments, because they interest me
04:49:30 <Gracenotes> aha. filterMap would be of type (a -> Bool) -> (a -> b) -> [a] -> [b]. It would only map elements that passed an initial predicate
04:49:37 <Gracenotes> and it would be useful in this case
04:50:10 <vixey> abbe, what if you remove  printMaybe :: (Show a) => Maybe a -> IO ()  ?
04:50:46 <abbe> vixey: no changes :(
04:50:49 <vixey> Axman6, you are very lucky... all my classes are stuff I did years ago, it's horribly tedious
04:50:54 <Axman6> > let filtMap p xs = xs >>= \x -> guard (p x) (return . f $ x) in filt even [1..10]
04:50:55 <lambdabot>   Not in scope: `filt'
04:50:56 <abbe> I'm unable to figure out the error. Though removing the line 'printMaybe $ Nothing' removes the error
04:51:05 <Gilly> I've been scaried about becoming a high school maths teacher or something like that - I fear the repetion...
04:51:06 <Axman6> > let filtMap p xs = xs >>= \x -> guard (p x) (return . f $ x) in filtMap even [1..10]
04:51:07 <lambdabot>   Couldn't match expected type `m b' against inferred type `()'
04:51:09 <nikki93> A pumpkin tribute.
04:51:16 <pumpkin> ?
04:51:19 <Axman6> :src guard
04:51:19 <abbe> but I can evaluate printMaybe $ Nothing in ghci fine, after the module is loaded.
04:51:22 <Axman6> @src guard
04:51:22 <lambdabot> guard True  =  return ()
04:51:22 <lambdabot> guard False =  mzero
04:51:22 <Twey> Gracenotes: filterMap p f = map f . filter p
04:51:31 <Axman6> oh, bleh
04:51:52 <Axman6> > let filtMap p xs = xs >>= \x -> guard (p x) (return . f $ x) else [] in filtMap even [1..10]
04:51:52 <Cale> abbe: ghci has more aggressive defaulting
04:51:53 <lambdabot>   <no location info>: parse error on input `else'
04:51:54 <Gilly> Teaching at uni could be more interesting, but I'd hope to do some actual research too.
04:51:56 <nikki93> pumpkin: http://hpaste.org/14058#a0
04:52:03 <Axman6> > let filtMap p xs = xs >>= \x -> if (p x) then (return . f $ x) else [] in filtMap even [1..10]
04:52:04 <lambdabot>   Add a type signature
04:52:05 <Cale> abbe: try giving the Nothing an explicit type
04:52:22 <abbe> how Cale ?
04:52:24 <Cale> abbe: printMaybe (Nothing :: Maybe Integer)
04:52:42 <abbe> oh, typecasting
04:53:12 <Cale> I'm not sure that it's really appropriate to call it a cast.
04:53:18 <abbe> Cale: Illegal signature in pattern: Maybe Integer
04:53:27 <Cale> uh...
04:53:39 <Cale> I mean, when you *call* printMaybe with Nothing
04:53:45 <abbe> Cale: Use -XPatternSignatures to permit it.
04:53:49 <Cale> Not in the pattern when you're defining it.
04:53:52 <Axman6> printMaybe $ Just (30::Integer)
04:54:01 <nikki93> pumpkin: Saw that?
04:54:06 <Gracenotes> Cale: thanks, that work. Had trouble wrapping my mind around it :/ I'm using it to write another function of type (a -> Bool) -> [[a]] -> [(Int, Int)]...
04:54:08 <Gracenotes> *worked
04:54:09 <pumpkin> nikki93: yeah, um :)
04:54:15 <Axman6> printMaybe $ (Nothing :: Maybe Integer)
04:54:15 <pumpkin> thanks!
04:55:12 <abbe> Axman6: okay, that works.
04:55:26 <Cale> http://hpaste.org/14057#a1
04:55:40 <nikki93> > break isSpace "Hahaha haha"
04:55:42 <lambdabot>   ("Hahaha"," haha")
04:55:57 <pumpkin> nikki93: what time zone are you in?
04:55:59 <abbe> Cale: that works
04:56:10 <nikki93> pumpkin: Doha, Qatar, GMT + 3 or something.
04:56:18 <pumpkin> ah :)
04:56:19 <nikki93> 4:00 PM here.
04:56:26 <nikki93> pumpkin: Why?
04:56:30 <pumpkin> just curious
04:56:43 <Axman6> @src words
04:56:43 <lambdabot> words s = case dropWhile isSpace s of
04:56:43 <lambdabot>     "" -> []
04:56:43 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
04:56:44 <pumpkin> thought maybe you were high from lack of sleep or something :P
04:56:44 <abbe> Cale, Axman6 : what is the error ?
04:56:47 <pumpkin> cause I certainly am
04:56:55 <nikki93> How old are you?
04:56:56 <nikki93> pumpkin: lol
04:57:01 <athos> :-)
04:57:09 <pumpkin> I'm 24
04:57:29 <nikki93> You sound a lot younger though.
04:57:31 <nikki93> Heh.
04:57:33 <pumpkin> ;)
04:57:45 <nikki93> So what do you use haskell for?
04:57:45 <pumpkin> I like to be stupid
04:57:48 <Axman6> abbe: the function knows it needs something of type (Show a) => Maybe a, but Nothing could have any type
04:57:50 <athos> some people are scared of even getting behind 24
04:57:50 <athos> :-))
04:57:54 <Axman6> or something like that
04:58:04 <pumpkin> nikki93: fun and work!
04:58:10 <pumpkin> nikki93: which most of the time coincide
04:58:16 <nikki93> pumpkin: Work? Where do you work? What do you work as?
04:58:18 <abbe> Okay, Axman6. :t Nothing, :t Just 30 mentions this.
04:58:20 <pumpkin> cause I'm lucky like that
04:58:25 <nikki93> pumpkin: Whaddya do.
04:58:28 <Axman6> :t Nothing
04:58:29 <lambdabot> forall a. Maybe a
04:58:30 <pumpkin> nikki93: I'm a student :P
04:58:41 <nikki93> pumpkin: Oh. I thought work as in income-generating stuff.
04:58:52 <abbe> Axman6: so, a in (Nothing :: Maybe a) is not necessarily derived from Show class.
04:59:03 <pumpkin> well it technically generates income, but it's pretty pitiful :P
04:59:04 <Axman6> yes
04:59:19 <abbe> cool, thanks Axman6 and Cale :)
04:59:20 <Cale> abbe: The problem is that in order to use the show function, you need an instance of Show class. There is an instance of Show for Maybe a only if there is an instance of Show for a
04:59:46 <Cale> abbe: Which means that you need to know *something* about the type a in order to apply show to a value of type Maybe a
05:00:20 <Cale> abbe: With the  Just 30  you had no problem, since numeric defaulting turned the 30 into an Integer, and so it was definitely a Maybe Integer at that point.
05:00:33 <Cale> abbe: With Nothing, it's ambiguous which type that belongs to.
05:00:52 <nikki93> ghc compiles to bytecode?
05:01:03 <pumpkin> in ghci, yes
05:01:06 <pumpkin> otherwise, native code
05:01:06 <abbe> thanks for this explanation, Cale.
05:01:07 <Cale> (and so it's ambiguous which instance of Show to use)
05:01:13 <Cale> abbe: no problem
05:01:33 <nikki93> What's haskell most useful for?
05:01:35 <nikki93> What kinds of programs?
05:01:39 <Axman6> anything
05:01:58 <Axman6> possibly not device drivers though... but you could make a nice interface with it i guess
05:02:06 <nikki93> Yes, in theory, anything can be written, but whats best to writein haskell>
05:02:16 <vixey> factorial
05:02:20 <nikki93> Cool.
05:02:21 <pumpkin> fibonacci
05:02:23 <Cale> nikki93: I've had good luck with combinatorial optimisation problems.
05:02:24 <blip> transposing a 500*500 matrix, should that be instant? ie, if it is not, then my algorithm sucks?
05:02:36 <Cale> blip: represented how?
05:02:38 <pumpkin> blip: depends on your representation of it...
05:02:38 <nikki93> What about 'usual applications' like firefox.
05:02:51 <pumpkin> nikki93: no reason not to, other than less than ideal GUI libs
05:02:52 <nikki93> IS it hard to write applications like firefox in haskell?
05:03:12 <Cale> nikki93: There are not enough open source Haskell programmers to reasonably support an effort as large as Firefox and still do other things, I think.
05:03:14 <pumpkin> nikki93: I've done a lot of fairly large number crunching in haskell since I started on it
05:03:30 <Cale> But it's not technically any harder, and possibly quite a bit easier.
05:03:34 <Axman6> > transpose (replicate 500 [0..500])
05:03:36 <lambdabot>   [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
05:03:43 <Axman6> > tail $ transpose (replicate 500 [0..500])
05:03:45 <lambdabot>   [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:03:50 <nikki93> What about using it a scripting language to embed in c/c++ programs?
05:03:51 <nikki93> Like in games.
05:03:54 <Axman6> > last $ transpose (replicate 500 [0..500])
05:03:56 <lambdabot>   [500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,500,50...
05:04:02 <nikki93> I know I mentioned this before, but lets discuss more. :P
05:04:08 <Axman6> blip: looks like it should be fairly fast...
05:04:14 <Cale> nikki93: It could be done. Check out the FFI documentation.
05:04:37 <Axman6> sounds like a pretty lame way to use haskell though. just write the game in haskell!
05:04:39 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html
05:05:38 <pumpkin> wow, that's a lot of FFIs
05:06:11 <Cale> Well, that's interfacing to Haskell code from C and vice versa...
05:06:28 <Cale> For pluggable Haskell objects, you'd need a little more work.
05:06:41 <Cale> I suppose you could rig something up with the GHC API
05:06:46 <PeakerWork> Cool, I wrote a text edit widget on top of SDL.. now need to refactor some so it looks sane
05:09:36 <Cale> Out of all the standard widgets I could possibly be asked to implement, I think a text edit widget is pretty high up on the list of those I'd fear having to do.
05:10:00 <Zao> Text is hard.
05:10:03 <ray> > "http://www.cse.unsw.edu.au/~chak/haskell/" ++ (concat $ repeat "ffi/") ++ "ffi.html"
05:10:05 <lambdabot>   "http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi/ffi/ffi/ffi/ffi/ffi/f...
05:10:10 <Zao> Especially if you're to support IMEs and other assorted magic.
05:10:20 <Cale> Zao: yeah
05:10:30 * vixey would use the OS one
05:12:40 <ray> if it has one
05:14:42 <PeakerWork> Cale: heh, I only have 140 lines of code in there or so
05:15:00 <PeakerWork> Cale: del backwards, forwards, move left, right, insert char, home, end, and a few other tidbits. Not yet complete, of course
05:15:15 <Cale> PeakerWork: That's not bad. Mouse selection? :)
05:15:49 <PeakerWork> Cale: nah, this is for an experimental non-textual code editor, I won't have mouse support :)
05:15:55 <Cale> ah
05:16:20 <nikki93> why does zipwith not just take a list of lists?
05:16:25 <PeakerWork> I wrote it in Python long ago, realized I was trying to invent a functional language and some of FRP (in retrospect, ofcourse, I didn't know FRP back then :-) So I decided to learn Haskell to see how others did the FP thing :)
05:16:35 <Cale> nikki93: What's it's type then?
05:16:40 <PeakerWork> nikki93: zipWith can have a function of hetrogenous types
05:16:45 <Cale> nikki93: Would it just be map?
05:16:45 <PeakerWork> s/have/take
05:17:06 <Cale> its*
05:17:09 <nikki93> PeakerWork: Ahh, k.
05:17:18 <Cale> > zipWith [0..] "hello"
05:17:20 <lambdabot>   Couldn't match expected type `a -> b -> c'
05:17:30 <blip> I'm all for trying to get some huge cool FOSS project going in Haskell. anyone want to write a computer game?
05:17:34 <Cale> > zipWith replicate [1..] "hello"
05:17:36 <lambdabot>   ["h","ee","lll","llll","ooooo"]
05:17:36 <nikki93> Cale: Youre talking zip
05:17:47 <Cale> > concat . zipWith replicate [1..] $ "hello"
05:17:49 <lambdabot>   "heelllllllooooo"
05:17:50 <golubovsky> Hi, Dimitry here.
05:18:00 <vixey> hello Dimitry
05:18:11 <Raevel> blip: i have a friend that was just talking about it
05:18:23 <Raevel> unless you're him in disguise
05:18:25 * Cale is half asleep :) Time to go to bed.
05:18:29 <daf> blip: what kind of game?
05:18:29 <PeakerWork> nikki93: also, if you have a function take [a]->b and then apply it to [[a]], its just a map, as Cale said
05:18:31 <golubovsky> I have a Hackage-DB related question. Maybe it was asked before, I'm not sure.
05:19:27 <golubovsky> Suppose there is a package C dependent on B, while B depends on A. A failed to build, so did B and C.
05:19:36 <nikki93> PeakerWork: I meant it takes arguments from each list at the same index.
05:19:39 <blip> daf/raevel: well, fps with cool physics. terror-fps
05:19:42 <blip> perhaps
05:19:53 <Cale> nikki93: transpose
05:20:03 <golubovsky> Now A was updated and built OK, will B and C eventually rebuilt without re-upload (and thus bumping versions)?
05:20:05 <Cale> (and then map)
05:20:20 <Raevel> scary
05:20:48 <Cale> golubovsky: That's a good question, I was sort of wondering about that myself.
05:21:18 <paolino> golubovsky: I think so
05:21:21 <Cale> I think they might have a script which runs every so often.
05:21:39 <paolino> or I was lucky, someone did it for me
05:21:50 <Cale> and builds things, but I'm not sure if it just builds everything, or just recently uploaded things
05:21:55 <Cale> (or if it's clever)
05:22:02 <golubovsky> Cale: I noticed when they upgraded GHC everything was rebuilt. For clarity, A is yhccore, B is ycextra, C is hugs2yc.
05:22:45 <golubovsky> Yhccore did not build by GHC 6.10 because of some pragmas that were no used by Cabal install anyway. I removed them and reuploaded yhccore.
05:22:58 <daf> blip: that would be nice
05:23:06 <daf> blip: I've played around some
05:23:12 <golubovsky> Then I reuploaded hugs2yc as I also corrcted it. No changes to ycextra, why reupload it?
05:23:29 <Saizan_> golubovsky: the long term plan is to accept build reports from users, rather than building everything on the server
05:23:36 <golubovsky> But while yhccore built, hugs2yc did not because ycextra did not.
05:24:12 <daf> blip: I think the graphics side is fairly well covered by hOpenGL, but writing a physics engine seems like a lot of work
05:24:19 <billy> how can I tell gchi in emacs no to change to ~/.cabal on inferior-haskell-load-file
05:24:21 <Saizan_> currently maybe you can bug the admins to reschedule the building
05:26:04 <Saizan_> ordnungswidrig: the workaround is to create a foo.cabal file in the directory where you are working
05:26:32 <ordnungswidrig> Saizan_: dummy foo.cabal or a correct cabal file
05:26:38 <Saizan_> dummy
05:27:07 <golubovsky> Is there a ticket on hackage trac about auto-rebuild? If not, I'll create one.
05:27:21 <paolino> noting that a package fails to build on its main page is not fair if that is not true on every system
05:27:34 <Saizan_> ordnungswidrig: though i think it has been fixed in a newer version of haskell-mode
05:30:13 <ordnungswidrig> Saizan_: I touched ~/project/foo.cabal and in buffer for ~/project/Test.hs when I c-x c-l ghci still do :cd ~/.cabal loads Test.hs successfully but fails in Test2.hs which is refered to by Test.hs
05:32:58 <ordnungswidrig> upgrading haskell-mode fixed it
05:35:34 <golubovsky> OK, probobaly no such ticket: will word it out and create.
05:35:41 <golubovsky> Bye all.
05:43:10 <Axman6_> just added an example to http://www.haskell.org/haskellwiki/Monad/ST could someone take a look and help me fix the explanation?
05:43:19 <Liskni_si> hey ppl, I need to create a web interface to a tool transforming some sgml (html input type=file) to latex and then texing that into a pdf, shall I use happs or something else?
05:43:52 <vixey> Axman6, I think you should remove the line  -- (forM_ is just flip mapM_)
05:44:16 <Axman6> yeah, i think the line above is clear enough
05:44:26 <vixey> but also you say 'constant space'
05:44:29 <vixey> is that true?
05:45:06 <Axman6> probably not
05:45:20 <vixey> like you might need to seq something I guess
05:45:53 <Axman6> maybe i should say it's more like how you might do it in an imperative laguage, updating a variable, rather than making new ones and passing them around
05:46:01 * vixey wonders.. modifySTRef n ((+x) $!)
05:47:12 <nikki93> repeat gives me infinit list of 'x's.
05:47:17 <Axman6> ST is strict by default i believe
05:47:24 <nikki93> How can I have finit list of 'x's?
05:47:32 <Axman6> nikki93: replicate
05:47:37 <nikki93> Axman6: Aha!
05:47:55 <vixey> > modifySTRef
05:47:56 <lambdabot>       Overlapping instances for Show (STRef s a -> (a -> a) -> ST s ())
05:47:56 <lambdabot>      ...
05:47:58 <Axman6> there is Control.Monad.ST.Lazy
05:48:10 <vixey> and Control.Monad.ST.Strict
05:48:14 <Axman6> yep
05:48:34 <Axman6> but Control.Monad.ST is a reexport of Control.Monad.ST.Strict
05:48:58 <Axman6> heh, i almost sound like i'm beginning to know something about haskell :)
05:49:03 <Axman6> fuck i love this language
05:49:56 <cads> hey, I'm trying to build ghc from source and having trouble with hs-colour, even though I installed hs_colour to my system from the darcs source
05:49:56 <nikki93> How can I make a lambda function recursive?
05:49:57 <cads> http://hpaste.org/14060?lines=true
05:50:10 <vixey> nikki93, fix it
05:50:12 <cads> that is the error its giving me
05:50:18 <stu8ball> They're not named, so they can't recurse.
05:50:19 <olsner> hehe, dons is the submitter of every article on the haskell reddit frontpage. except one :)
05:50:23 <pumpkin> nikki93: also, if you ever get an infinite list in general, take and takeWhile are your friends
05:50:24 <cads> anyone know what I should do?
05:50:29 <vixey> > (fix (\recursion x -> x : recursion (x+1))) 0
05:50:31 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
05:50:46 <pumpkin> nikki93: you can using fix, but it's rather complicated for something you could just do in another way :P
05:51:05 <olsner> @pl \recursion x -> x : recursion (x+1)
05:51:06 <lambdabot> ap (:) . (. (1 +))
05:52:22 <nikki93> > (\recursion x -> x : recursion (x+1) 0
05:52:24 <lambdabot>   <no location info>: parse error on input `;'
05:52:37 <nikki93> > (fix (\recursion x -> x : recursion (x+1)) 0
05:52:39 <lambdabot>   <no location info>: parse error on input `;'
05:53:01 <nikki93> > (fix (\recursion x -> x : recursion (x+1))) 0
05:53:03 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
05:53:12 <nikki93> > (\recursion x -> x : recursion (x+1)) 0
05:53:12 <cads> does anyone know how I can resolve this compile error: http://hpaste.org/14060?lines=true ?
05:53:13 <lambdabot>       No instance for (Num (a -> [a]))
05:53:13 <lambdabot>        arising from the literal `0' at...
05:53:22 <nikki93> Ahh
05:54:06 <nikki93> Someone here showed a fibonnacci that uses zipWith.
05:54:08 <nikki93> How?
05:54:12 <nikki93> I mean, what?
05:55:18 <Axman6> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
05:55:20 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
05:56:04 <pumpkin> nikki93: there's a lot going on in that one
05:56:11 <pumpkin> but it's a pretty awesome definition
05:56:17 <Axman6> > let fibs = 0 : 1 : zip fibs (tail fibs) in fibs
05:56:19 <lambdabot>       Occurs check: cannot construct the infinite type: a = (a, a)
05:56:19 <lambdabot>        Exp...
05:56:26 <Axman6> ah yes, heh
05:56:38 <Axman6> > let fibs = 0 : 1 : zipWith (%) fibs (tail fibs) in fibs
05:56:40 <lambdabot>       Occurs check: cannot construct the infinite type: a = Ratio a
05:56:40 <lambdabot>        Ex...
05:56:48 <bolrod> > let fibs = 0:1:[a+b | (a,b) <- zip fibs (tail fibs)] in take 10 fibs
05:56:50 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
05:57:02 <pumpkin> > let fibs = 0 : 1 : zipWith (/) fibs (tail fibs) in fibs :: [Rational]
05:57:04 <lambdabot>   [0%1,1%1,0%1,* Exception: Ratio.%: zero denominator
05:57:07 <pumpkin> :P
05:57:42 <Axman6> > let fibs = 1 : 2 : zipWith (/) fibs (tail fibs) in fibs :: [Rational]
05:57:44 <lambdabot>   [1%1,2%1,1%2,4%1,1%8,32%1,1%256,8192%1,1%2097152,17179869184%1,1%3602879701...
05:57:59 <Axman6> :o
05:58:04 <Axman6> > let fibs = 1 : 2 : zipWith (/) fibs (tail fibs) in fibs
05:58:06 <lambdabot>   [1.0,2.0,0.5,4.0,0.125,32.0,3.90625e-3,8192.0,4.76837158203125e-7,1.7179869...
05:58:16 <Stephan202> > letlet fibs = 0 : scanl (+) 1 fibs in fibs
05:58:17 <lambdabot>   <no location info>: parse error on input `='
05:58:21 <Stephan202> > let fibs = 0 : scanl (+) 1 fibs in fibs
05:58:23 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
06:03:13 <pumpkin> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in map (\x -> let [a, b] = take 2 x in b / a) $ tails fibs
06:03:21 <lambdabot>   [Infinity,1.0,2.0,1.5,1.6666666666666667,1.6,1.625,1.6153846153846154,1.619...
06:03:40 <pumpkin> > (5**(1/2) + 1) / 2
06:03:42 <lambdabot>   1.618033988749895
06:11:08 <blip> so basically there really is no way to ever create a list randomized list outside of IO?
06:11:30 <Axman6> you can use randoms
06:11:33 <Axman6> :t randoms
06:11:34 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
06:11:40 <Axman6> and just give it a seed
06:11:46 <Axman6> :t mkStdGen
06:11:48 <lambdabot> Int -> StdGen
06:12:08 <Axman6> > randoms (mkStdGen 123456789) :: [Int]
06:12:09 <lambdabot>   [6726650665529141880,6197171939106802697,4025148897354699108,19041808172424...
06:12:14 <Axman6> > randoms (mkStdGen 123456789) :: [Int8]
06:12:15 <lambdabot>       No instance for (Random Int8)
06:12:15 <lambdabot>        arising from a use of `randoms' at...
06:12:21 <Gracenotes> @hoogle Eq a => [a] -> Bool
06:12:21 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
06:12:21 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
06:12:21 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
06:12:28 <Axman6> > randoms (mkStdGen 123456789) :: [Bool]
06:12:30 <lambdabot>   [True,False,True,False,False,True,False,True,True,True,True,True,False,Fals...
06:13:01 <Axman6> > map (\x -> if x then 1 else 0) $ randoms (mkStdGen 123456789) :: [Bool]
06:13:03 <lambdabot>       No instance for (Num Bool)
06:13:03 <lambdabot>        arising from the literal `1' at <inte...
06:13:12 <Axman6> > map (\x -> if x then 1 else 0) $ (randoms (mkStdGen 123456789) :: [Bool])
06:13:14 <lambdabot>   [1,0,1,0,0,1,0,1,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,...
06:13:18 <blip> ah wait i see, now i have to do the <- inside the monad then I can pass the matrix out of there
06:13:29 <Axman6> > show . map (\x -> if x then 1 else 0) $ (randoms (mkStdGen 123456789) :: [Bool])
06:13:30 <lambdabot>   "[1,0,1,0,0,1,0,1,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1...
06:14:24 <Axman6> > concatMap show . map (\x -> if x then 1 else 0) $ (randoms (mkStdGen 123456789) :: [Bool])
06:14:26 <lambdabot>   "10100101111100111000100101000001010111101001110000011000000101010100000010...
06:16:31 <dublpaws> if brains were recognized as computers by the law, then human perception would be the execution of software and subject to license.
06:16:45 <ehird> cool.
06:17:25 <Gracenotes> @pl \a -> enumFromThenTo a (a-1) 1
06:17:26 <lambdabot> flip (ap enumFromThenTo (subtract 1)) 1
06:17:42 <blip> the <- part cant be done in an expression?
06:18:06 <blip> like: foreach (\x -> <- randF) m ?
06:18:26 <nikki93> So foldl is basically doing a function on a list and accumulating as it goes?
06:18:26 <Axman6> no
06:18:36 <Axman6> nikki93: yep, that'
06:18:40 <Axman6> s exactly it
06:18:55 <Axman6> blip: sounds like you need a nice monad tutorial
06:18:55 <blip> so exactly it youve never been that exactly right before
06:19:02 <nikki93> > foldl (+) 0 [1..10]
06:19:04 <lambdabot>   55
06:19:07 <nikki93> Awesome.
06:19:11 <blip> there are so many and they all suclk
06:19:26 <blip> foldr (+) [1..10] 0
06:19:29 <blip> > foldr (+) [1..10] 0
06:19:30 <lambdabot>       No instance for (Num [t])
06:19:30 <lambdabot>        arising from a use of `+' at <interact...
06:19:34 <Axman6> blip: i tried writing one, maybe you'll find it helpful
06:19:38 <blip> :t foldr
06:19:40 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:19:52 <Saizan_> ?wiki Monads as computation
06:19:52 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_computation
06:20:02 <blip> > foldr (+) 0 [1..10]
06:20:03 <lambdabot>   55
06:20:06 <Axman6> i didn';t like either of them
06:20:09 <nikki93> > foldl (*) 0 [1..10]
06:20:10 <blip> > scanl (+) 0 [1..10]
06:20:12 <lambdabot>   0
06:20:12 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55]
06:20:21 <nikki93> > foldl (*) 1 [1..10]
06:20:23 <lambdabot>   3628800
06:20:24 <blip> > scanl (+) 0 [0.3,0.4,0.2,0.1]
06:20:26 <lambdabot>   [0.0,0.3,0.7,0.8999999999999999,0.9999999999999999]
06:20:29 <nikki93> > foldl (*) 1 [1..3]
06:20:31 <lambdabot>   6
06:20:55 <Axman6> > foldl f x [a,b,c]
06:20:57 <lambdabot>   f (f (f x a) b) c
06:21:03 <Axman6> > foldl' f x [a,b,c]
06:21:05 <lambdabot>   f (f (f x a) b) c
06:21:05 <blip> > let fac n = foldl' (*) 1 [1..n] in fac 5
06:21:07 <lambdabot>   120
06:21:13 <Axman6> bah, guess that makes sense
06:21:17 <nikki93> @let fac n = foldl (*) 1 [1..n]
06:21:18 <lambdabot>  <local>:45:0:
06:21:18 <lambdabot>      Multiple declarations of `L.fac'
06:21:18 <lambdabot>      Declared at: <local...
06:21:36 <nikki93> blip: Funny! I wrote the same thing concurrently!
06:21:37 <nikki93> :D
06:21:55 <Axman6> nikki93: @let is generally used for more useful functions tha that :)
06:22:01 <Axman6> than*
06:22:06 <nikki93> Axman6: sorreh.
06:22:10 <Axman6> or things you're building up in the chan
06:23:06 <nikki93> > let sorrehAxman x = if (x > 0) then "Sorreh " ++ sorrehAxman (x - 1) else "Axman6!" in sorrehAxman 6
06:23:08 <lambdabot>   "Sorreh Sorreh Sorreh Sorreh Sorreh Sorreh Axman6!"
06:23:28 <Axman6> heh, you do love those functions don't you :P
06:23:33 <nikki93> :)
06:24:14 <nikki93> > foldl (++) ["a", "abc", "ababccacac"]
06:24:16 <lambdabot>       Overlapping instances for Show ([[[Char]]] -> [[Char]])
06:24:16 <lambdabot>        arising ...
06:24:19 <blip> @let Cale = "genius" in cale?
06:24:20 <lambdabot>   Parse error
06:24:20 <nikki93> > foldl (++) "" ["a", "abc", "ababccacac"]
06:24:22 <lambdabot>   "aabcababccacac"
06:24:33 <blip> @let Cale = "genius" in "cale?"
06:24:33 <lambdabot>   Parse error
06:24:41 <blip> @let cale = "genius" in "cale?"
06:24:41 <lambdabot>   Parse error
06:24:49 <Gracenotes> @src nub
06:24:49 <lambdabot> nub = nubBy (==)
06:24:58 <nikki93> > let cale = "genius" in cale
06:24:58 <Gracenotes> @src nubBy
06:24:59 <lambdabot> nubBy eq []             =  []
06:24:59 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
06:24:59 <Axman6> blip: > let f = ...
06:25:00 <lambdabot>   "genius"
06:25:02 <Axman6> not #let
06:25:03 <blip> > let lambdabot = "donkey" in lambdabot
06:25:04 <lambdabot>   "donkey"
06:25:04 <Axman6> @let*
06:25:07 <lambdabot>  Defined.
06:25:12 <Axman6> :o
06:25:13 <Axman6> shit
06:25:15 <nikki93> :o
06:25:16 <Gracenotes> > *
06:25:17 <Axman6> > *
06:25:17 <lambdabot>   <no location info>: parse error on input `*'
06:25:18 <lambdabot>   <no location info>: parse error on input `*'
06:25:22 <ehird> >
06:25:27 <nikki93> > qui
06:25:29 <lambdabot>   Not in scope: `qui'
06:25:29 <ehird> @let* just typo corrects to @let
06:25:29 <lambdabot>   Parse error
06:25:30 <nikki93> > quit
06:25:31 <lambdabot>   Not in scope: `quit'
06:25:32 <ehird> @lett
06:25:32 <blip> lambdabot
06:25:32 <nikki93> > exit
06:25:34 <blip> > lambdabot
06:25:35 <lambdabot>   Not in scope: `exit'
06:25:36 <lambdabot>  Defined.
06:25:36 <lambdabot>  Terminated
06:25:39 <ehird> @lett
06:25:42 <lambdabot>  Defined.
06:25:45 <ehird> see?
06:25:45 <nikki93> Can we kill lambdabot?
06:25:50 <nikki93> > die
06:25:51 <ehird> nikki93: no.
06:25:52 <lambdabot>   Not in scope: `die'
06:25:53 <ehird> it is totally sandboxed.
06:25:55 <nikki93> lol
06:26:04 <nikki93> Not in scop: `die`, I liek that
06:26:12 <nikki93> s/wrong/right/
06:26:51 <nikki93> @let whoIsLambdaBot x = "I'm lambdabot, hello!"
06:26:54 <lambdabot>  Defined.
06:27:00 <nikki93> > whoIsLambdaBot 2
06:27:02 <lambdabot>   "I'm lambdabot, hello!"
06:27:21 <nikki93> @undefine whoIsLambdaBot
06:27:29 <nikki93> > whoIsLambdaBot 2
06:27:30 <lambdabot>   Not in scope: `whoIsLambdaBot'
06:27:38 <nikki93> lambdabot: ;-)
06:28:02 <blip> @let whoIsAxman = "some cool english dude"
06:28:03 <lambdabot>  Defined.
06:28:08 <blip> > whoIsAxman
06:28:09 <lambdabot>   "some cool english dude"
06:28:27 <blip> @undefine whoIsAxman
06:28:27 <nikki93> > map (^2) [1..20]
06:28:29 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400]
06:28:31 <blip> > whoIsAxman
06:28:32 <lambdabot>   Not in scope: `whoIsAxman'
06:28:43 <nikki93> > map (2^) [1..20]
06:28:45 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
06:28:52 <Axman6> i'm not english!
06:29:07 <Axman6> well, i'm half english i guess
06:29:11 <blip> > filter (== English) [haskelldudes]
06:29:12 <lambdabot>   Not in scope: data constructor `English'Not in scope: `haskelldudes'
06:29:17 <nikki93> @let whoIsAxman = "1/2 English"
06:29:18 <lambdabot>  Defined.
06:29:23 <nikki93> > whoIsAxman
06:29:25 <lambdabot>   "1/2 English"
06:29:33 <blip> > whatIsAxman
06:29:34 <lambdabot>   Not in scope: `whatIsAxman'
06:29:43 <blip> 1/2 half of axman?
06:30:04 <nikki93> No, 1/4th of English is 1/2 of axman.
06:30:24 <Axman6> > nikki93
06:30:25 <lambdabot>   some strange Axman6 obcessed dude
06:30:36 <Axman6> magic!
06:32:01 <ehird> > nikki93
06:32:02 <lambdabot>   haskell stalker
06:32:06 <blip> structure-preserving mapping , what does it mean to be structure-preserving in the mathematical sense? preserving order and commutativity? validat of some operations?
06:32:20 <nikki93> > Axman6
06:32:21 <lambdabot>   Not in scope: data constructor `Axman6'
06:32:33 <nikki93> > nikki93
06:32:35 <lambdabot>   haskell stalker
06:32:41 <nikki93> > nikki93 - 2
06:32:42 <lambdabot>       No instance for (Num Doc)
06:32:43 <lambdabot>        arising from the literal `2' at <inter...
06:32:51 <nikki93> > :t nikki93
06:32:52 <lambdabot>   <no location info>: parse error on input `:'
06:32:57 <ehird> :t nikki93
06:32:58 <lambdabot> Doc
06:32:59 <Axman6> > limerick
06:33:00 <lambdabot>   int factorial(int sum) {
06:33:00 <lambdabot>  if (sum == 1) return 1;
06:33:00 <lambdabot>  if (sum != 1)
06:33:00 <lambdabot>  return pr...
06:33:04 <Axman6> damn it
06:33:17 <nikki93> @src nikki93
06:33:18 <lambdabot> Source not found. Do you think like you type?
06:33:25 <Axman6> limerick = magic "int factorial(int sum) {\nif (sum == 1) return 1;\nif (sum != 1)\nreturn product(sum,\nfactorial(sum - 1)); }"
06:33:40 <nikki93> :t magic
06:33:41 <lambdabot> Not in scope: `magic'
06:33:59 <nikki93> > nikki93
06:34:01 <lambdabot>   haskell stalker
06:34:09 <gio123> .seen RLa
06:34:21 <Axman6> anyway, enough lambdabot spam
06:34:24 <ehird> @help .
06:34:24 <lambdabot> . <cmd1> <cmd2> [args].
06:34:24 <lambdabot> . [or compose] is the composition of two plugins
06:34:24 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
06:34:31 <nikki93> @help magic
06:34:31 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:34:34 <ehird> @. seen run nikki93
06:35:08 <Axman6> nikki93: i changed what the actual function was with magic :P
06:35:26 <Axman6> @.
06:35:26 <lambdabot> Not enough arguments to @.
06:35:38 <Axman6> bah, i was wondering if there was a @..
06:35:42 <Axman6> @help ..
06:35:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:36:09 <blip> @quote SPJ
06:36:09 <lambdabot> twifkak says: [on dons] i wonder if he and SPJ have a bet going for "most newbies recruited in '07"
06:36:12 <blip> @quote SPJ
06:36:13 <lambdabot> davidhasselh0f says: [on SPJ's "A Taste of Haskell" tutorial]: It's better than sex.
06:36:15 <blip> @quote SPJ
06:36:15 <lambdabot> twifkak says: [on dons] i wonder if he and SPJ have a bet going for "most newbies recruited in '07"
06:36:17 <blip> @quote SPJ
06:36:18 <lambdabot> pl0nk says: I wonder what SPJ sees when he closes his eyes before answering a question.
06:36:21 <blip> @quote SPJ
06:36:21 <lambdabot> twifkak says: [on dons] i wonder if he and SPJ have a bet going for "most newbies recruited in '07"
06:36:24 <blip> @quote SPJ
06:36:24 <lambdabot> shapr says: [on Oleg:]  And ccshan and he would argue furiously for a minute or two and then SPJ would say "Why don't you send an email to the Haskell list about that so we can have time to understand
06:36:24 <lambdabot>  what you just said?"
06:36:33 <nikki93> @quote Axman6
06:36:34 <lambdabot> No quotes match. I am sorry.
06:36:40 <nikki93> @quote SPJ
06:36:40 <lambdabot> pl0nk says: I wonder what SPJ sees when he closes his eyes before answering a question.
06:36:42 <blip> @quote dons
06:36:42 <lambdabot> dons says: yeah, good idea. use C++ as the prototyping language
06:36:43 <Axman6> what? where'd my quote go!
06:36:47 <blip> @quote dons
06:36:48 <lambdabot> dons says: yes, i have magic powers.
06:36:50 <blip> @quote dons
06:36:50 <lambdabot> dons says: that's 3 things i've never seen in the one sentence before: my assembler .. a bunch of type classes .. a natural syntax
06:36:55 <blip> @quote dons
06:36:55 <lambdabot> dons says: <dons> and you can just zoom in until you see the locations at full res. huh. so this is how I track my enemies
06:37:01 <nikki93> @quote pumpkin
06:37:01 <lambdabot> pumpkin says: OMG I <3 RECORD SYNTAX
06:37:02 <blip> @quote Cale
06:37:03 <lambdabot> Cale says: We have GHC-as-a-Library, why not GHC-as-a-Virus
06:37:05 <blip> @quote Cale
06:37:05 <lambdabot> Cale says: Screw standardisation, let's just work on base 2.0 now so that by the time Haskell' comes out, it'll be completely out of date.
06:37:07 <nikki93> @quote pumpkin
06:37:08 <lambdabot> pumpkin says: OMG I <3 RECORD SYNTAX
06:37:09 <nikki93> @quote pumpkin
06:37:10 <lambdabot> pumpkin says: OMG I <3 RECORD SYNTAX
06:37:12 <blip> @quote Cale
06:37:12 <nikki93> @quote pumpkin
06:37:13 <lambdabot> Cale says: GADT pattern match in non-rigid context. There are prescriptions available for that sort of thing.
06:37:13 <lambdabot> pumpkin says: OMG I <3 RECORD SYNTAX
06:37:15 <blip> @quote Cale
06:37:15 <lambdabot> Cale says: I know I always have trouble explaining what the weather is like without involving foldr somehow.
06:37:19 <nikki93> @quote pumpkin [1..3]
06:37:19 <lambdabot> pumpkin says: OMG I <3 RECORD SYNTAX
06:37:23 <Axman6> both of you, quit it
06:37:26 <Axman6> seriously
06:37:36 <nikki93> How to record quote?
06:37:44 <nikki93> I wanna put some spam there.
06:37:48 <Axman6> you haven't earned that power yet
06:37:53 <nikki93> www.grall.uni.cc
06:37:53 <nikki93> :)
06:38:14 <ehird> stop it stop it STOP IT
06:38:28 <nikki93> ehird: If they didn't want it they wouldn't put it here. :P
06:38:43 <nikki93> But I stp.
06:38:43 <ehird> there's a difference between wanting quotes and wanting 5 billion quotes
06:38:45 <nikki93> *stop
06:44:37 <blip> @faq can haskell eat c++ for brekfast?
06:44:38 <lambdabot> The answer is: Yes! Haskell can do that.
06:45:02 <blip> @faq can haskell jump through hoops and dance on a line?
06:45:02 <lambdabot> The answer is: Yes! Haskell can do that.
06:45:43 <Axman6> can we talk about haskell again now?
06:47:14 <nikki93> @help id
06:47:15 <lambdabot> id <arg>. The identiy plugin
06:47:47 <nikki93> id = does nothing!
06:47:49 <nikki93> Of course.
06:47:57 <nikki93> identify matrix, identity quaternion etc.
06:47:58 <nikki93> Nice.
06:48:00 <Axman6> id is very useful
06:48:39 <ehird> identiy plugin
06:48:42 <ehird> identiy
06:48:47 <ehird> tiy
06:49:08 <nikki93> ehird: lol didn't notice.
06:49:14 <ehird> someone fix it :D
06:49:17 <Axman6> > zipWith id [(^2),(^3),(2^),(3^)] [10,20..]
06:49:18 <lambdabot>   [100,8000,1073741824,12157665459056928801]
06:49:56 <Axman6> :t const id
06:49:57 <lambdabot> forall a b. b -> a -> a
06:50:16 <nikki93> @src id
06:50:17 <lambdabot> id x = x
06:50:32 <nikki93> @src (+)
06:50:32 <lambdabot> Source not found. Sorry.
06:50:38 <nikki93> @src +
06:50:39 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
06:50:46 <blip> is there a function for swapping elesm in a list? like swapElems 1 2  [1,3,2,4] -> [1,2,3,4]
06:51:02 <blip> can I hoogle here btw?
06:51:08 <nikki93> @hoogle lolol
06:51:09 <lambdabot> No results found
06:51:14 <nikki93> @hoogle id
06:51:15 <lambdabot> Prelude id :: a -> a
06:51:15 <lambdabot> Data.Function id :: a -> a
06:51:15 <lambdabot> Text.Read Ident :: String -> Lexeme
06:51:24 <Axman6> nikki93: please stop abusing lambdabot
06:51:31 <blip> @hoogle Int -> Int -> [a] -> [a]
06:51:31 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
06:51:31 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
06:51:31 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
06:51:33 <nikki93> blip: He wanted to know how to hoogle.
06:52:01 <nikki93> Axman6: He wanted to know how to hoogle.
06:52:42 <blip> how do I make lamdabot remember quotes?
06:52:58 <int-e_> @help remember
06:52:58 <lambdabot> quote <nick>
06:52:58 <lambdabot> remember <nick> <quote>
06:52:58 <lambdabot> Quote somebody, a random person, or save a memorable quote
06:53:29 <nikki93> zipWith id [(+2),(*2),(/2)] [1,5,4]
06:53:32 <nikki93> > zipWith id [(+2),(*2),(/2)] [1,5,4]
06:53:34 <lambdabot>   [3.0,10.0,2.0]
06:53:49 <nikki93> Wait.
06:53:56 <blip> quote <Axman6> <nikki93: please stop abusing lambdabot>
06:53:59 <nikki93> So here, we do 'id' with two arguments, a function and a value?
06:54:10 <blip> @quote Axman6
06:54:11 <lambdabot> No quotes match.
06:54:14 <blip> @quote <Axman6>
06:54:14 <Axman6> blip: the <>'s aren't necessary
06:54:14 <lambdabot> No quotes match. Maybe you made a typo?
06:54:15 <nikki93> blip: I'm learning. But you're right, I'll use ghci/
06:54:26 <Axman6> and it's remember, not quote
06:54:29 <blip> im just kidding
06:54:48 <blip> ^^ niki
06:54:51 <blip> are you 15?
06:54:55 <nikki93> Yeah.
06:54:58 <blip> cool
06:55:03 <nikki93> remember blip im just kidding
06:55:06 <blip> bright future ahead of you
06:55:06 <nikki93> @remember blip im just kidding
06:55:07 <lambdabot> Done.
06:55:12 <nikki93> @quote blip
06:55:12 <lambdabot> blip says: im just kidding
06:55:16 <nikki93> ;P
06:55:28 <blip> @remember blip im just kidnapping
06:55:28 <lambdabot> I will never forget.
06:55:32 <blip> @quote blip
06:55:33 <lambdabot> blip says: im just kidding
06:55:35 <blip> @quote blip
06:55:35 <lambdabot> blip says: im just kidnapping
06:55:39 <nikki93> Shh.
06:55:57 <nikki93> Axman6 doesn't like noise. :P
06:56:29 <Axman6> i don't think i'm the only one. noticed how no one else has said anything for the last half hour, in a channel with 600+ people?
06:56:38 <nikki93> :(
06:56:49 <nikki93> > id (+2) 3
06:56:50 <lambdabot>   5
06:57:12 <nikki93> > id (+2)
06:57:13 <lambdabot>       Overlapping instances for Show (a -> a)
06:57:14 <lambdabot>        arising from a use of `s...
06:57:23 <nikki93> > (+2) 3
06:57:24 <lambdabot>   5
06:57:38 <nikki93> map id (+2) [1,2,3]
06:57:41 <nikki93> >map id (+2) [1,2,3]
06:57:44 <nikki93> > map id (+2) [1,2,3]
06:57:45 <lambdabot>       The section `(+ 2)' takes one argument,
06:57:45 <lambdabot>      but its type `[a]' has none
06:58:03 <nikki93> > map (+2) [1,2,3]
06:58:05 <lambdabot>   [3,4,5]
06:59:10 <nikki93> @help scanl
06:59:10 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:59:21 <Raevel> anyone have any fp book recommendations? i've read rwh, sicp, tapl and some more basic books
07:00:28 <Axman6> nikki93: lambdabot also replies to /msg's
07:00:51 <nikki93> Axman6: That's fine, I have ghc. And hoogle. So I'll be more private now. ;-)
07:00:54 <pejo> Raevel, attapl is nice too. What is your main interest, type theory, building compilers, something else?
07:01:34 <Raevel> pejo: it's all gold
07:01:51 <Axman6> knowledge is powah!
07:02:21 <nikki93> What exactly does scanl do?
07:02:37 <BONUS> like foldl, only you get a list of intermediate results
07:02:52 <BONUS> > scanl (+) 0 [1,2,3,4]
07:02:53 <pejo> Raevel, SPJ has both (?) his books available on his homepage.
07:02:53 <lambdabot>   [0,1,3,6,10]
07:03:22 <sioraiocht> dcoutts: ping?
07:03:29 <nikki93> > foldl (+) 0 [1,2,3,4]
07:03:30 <lambdabot>   10
07:03:34 <int-e> > fix ((0:) . scanl (+) 1) -- it's that time of the year again
07:03:35 <lambdabot>   mueval: Prelude.read: no parse
07:03:36 <nikki93> > scanl (+) 0 [1,2,3,4]
07:03:37 <Raevel> i've been doing mostly oop until recently, DDD, patterns, etc, but it's getting less and less interesting i think
07:03:37 <dpratt71> @src foldl
07:03:38 <lambdabot>   [0,1,3,6,10]
07:03:38 <lambdabot> foldl f z []     = z
07:03:38 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:03:48 <int-e> > fix ((0:) . scanl (+) 1)
07:03:50 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
07:03:52 <int-e> mueval--
07:03:52 <nikki93> Oh I get it now.
07:03:58 <dcoutts> sioraiocht: pong
07:03:58 <lambdabot> dcoutts: You have 3 new messages. '/msg lambdabot @messages' to read them.
07:04:00 <nikki93> It returns the intermediate steps of foldl
07:05:11 <Raevel> pejo: oh right, i was gonna read http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/index.htm , forgot about it :-)
07:05:16 <Raevel> what is the other book?
07:05:36 <Raevel> wish it wasn't out of print though :*/
07:05:43 <dcoutts> gwern: re: the missing hackage packages, I think they were removed at the request of the package authors
07:05:53 <Axman6> urgh, my uni's isis thing is busted. just entered the same login info about 8 times, then it finally worked
07:06:53 <pejo> Raevel, http://research.microsoft.com/en-us/um/people/simonpj/papers/pj-lester-book/
07:07:02 <Raevel> thanks!
07:07:57 <pejo> Raevel, I think you're heading into paper-land pretty soon if you keep that pace up.
07:08:38 <Raevel> heh :-), can't say i completely understand everything i've read so far though
07:09:03 <oklopol> paper land?
07:09:29 <Raevel> pejo: oh, and what's aatapl?
07:09:48 <Raevel> oklopol: research papers, i assume
07:10:09 <pejo> Raevel, attapl, the sequel of tapl.
07:10:13 <Raevel> ooo
07:10:24 <oklopol> paper land == research papers? i'm more wondering if that's some turn of phrase i haven't heard.
07:11:23 <pejo> oklopol, I just made it up
07:12:01 <oklopol> pejo: i liked it. is paper land where you read and read and never actually do anything?
07:12:09 <oklopol> or did i misunderstand it
07:14:22 <pejo> oklopol, I was just trying to convey that he's going to run out of books (on type theory for example) and have to read papers to learn new stuff. I hope he still has time to do something. :-)
07:15:02 <roconnor_> how do I check out the darcs repo for the libraries?
07:15:31 <int-e> which libraries?
07:15:50 <blip> http://hpaste.org/14061
07:15:57 <dolio> They're included in a ghc checkout.
07:16:18 <blip> why deosnt it work?
07:16:25 <dolio> Except for the ones that have been split off.
07:16:34 <blip> i can generate a matrix with 1 random number in each elem
07:16:39 <blip> but not one with different ones
07:16:54 <Axman6> @instances Bits
07:16:54 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
07:16:58 <roconnor_> int-e: base
07:17:04 <Axman6> @instances-importing Data.Bits Bits
07:17:05 <lambdabot> Int, Integer
07:17:08 <Axman6> hmm
07:17:19 <int-e> roconnor_: if the question is about ghc, ./darcs-all get
07:17:35 <blip> http://hpaste.org/14061#a1
07:17:35 <roconnor_> I thought the libs were shared with hugs
07:17:39 <roconnor_> somewhat
07:17:49 <roconnor_> dunno about base
07:17:56 <maltem> they are
07:17:59 <mauke> blip: I don't know what randrange is, but randomelems is bound to the same value each time
07:18:00 <int-e> roconnor_: for individual libraries have a look at http://darcs.haskell.org/packages/ http://darcs.haskell.org/ghc-6.10/packages/
07:18:08 <Saizan_> roconnor_: they are under http://darcs.haskell.org/libraries
07:18:26 <Saizan_> yeah, one of those :)
07:19:17 <matthew-_> how typical is it for the pi-calculus to include and if-statement?
07:19:41 <Axman6> pi-calculus?
07:19:46 <roconnor_> oops, did wget instead of darcs get
07:19:50 <roconnor_> habit
07:19:54 <matthew-_> Axman6: right, it doesn't, I know
07:20:08 <Axman6> huh?
07:20:14 <int-e> Saizan_: one of those (packages and libraries) is a symlink to the other, I believe.
07:20:14 <blip> Possible fix: add an instance declaration for (Show (IO Double))
07:20:16 <blip> how?
07:20:33 <Axman6> blip: you don't
07:20:48 <Axman6> get the double out of IO and then use print
07:20:49 <blip> bah doesnt matter it is still IO [Double] not [Double]
07:21:00 <blip> i got it ou but it is still in
07:21:03 <pejo> matthew, you can encode the lambda calculus in it, so implicitly it normally does
07:21:07 <int-e> blip: you need to run the IO Double  thing before printing the result.
07:21:09 <blip> randomelems <- take (r*c) $ repeat (randrange 0 1)
07:21:14 <blip> gets it out?
07:21:17 <Axman6> do { ds <- (f :: IO [Double]); print ds}
07:21:21 <mauke> blip: what is "it"?
07:21:22 <blip> im not printing
07:21:27 <blip> the randomlist
07:21:32 <mauke> what
07:21:47 <blip> i want a random fakking lsit
07:22:04 <blip> http://hpaste.org/14061#a2
07:22:06 <mauke> your code generates r*c copies of the value (randrange 0 1) and iterates over them
07:22:22 <Axman6> blip: i showed you how to get one over an hour ago
07:22:39 <pejo> matthew, do you have some more context?
07:22:45 <Axman6> > randomRs (0,100 :: Int) (mkStdGen 9868768)
07:22:46 <lambdabot>   [51,55,3,20,40,54,4,57,50,83,45,72,88,55,1,53,96,85,59,91,51,9,35,62,95,0,8...
07:22:51 <blip> randList 10 -> [0.03,0.83883
07:22:54 <dpratt71> @src sqr
07:22:55 <lambdabot> Source not found. Sorry.
07:23:09 <Axman6> @istances Random
07:23:10 <lambdabot> Couldn't find class `Random'. Try @instances-importing
07:23:22 <Axman6> @istances-importing System.Random Random
07:23:23 <lambdabot> Bool, Char, Double, Float, Int, Integer
07:23:40 <Axman6> > randomRs (0,1 :: Double) (mkStdGen 9868768)
07:23:41 <lambdabot>   [0.15930455868581883,0.9981330217556406,0.711758606883641,8.01345823752076e...
07:23:56 <dolio> Someone really ought to write an instance for pairs.
07:24:07 <int-e> blip: try  randomelems <- sequence (take (r*c) $ repeat (randrange 0 1)
07:24:08 <matthew-_> pejo: hmm. Ok, what I mean is, if you were reading a paper and it said "we use the pi calculus" and then you started seeing "if" statements in example code, would that surprise you?
07:24:08 <dolio> Etc.
07:24:25 <Axman6> dolio: (Random a, Random b) => (a,b)?
07:24:46 <int-e> blip: Or, simpler:  randomelems <- replicateM (r*c) (randrange 0 1)
07:25:03 <dolio> Axman6: Yeah.
07:25:17 <dolio> I've wanted it before.
07:26:24 <int-e> blip: another take on it would be:  gen <- newStdGen; let randomelems = take (r*c) $ randomRs (0, 1) gen
07:26:33 <pejo> matthew, I think it's obvious what you mean, but I can't say how a pi calculist would react.
07:27:10 <int-e> blip: which takes the generation of random values out of IO, which is generally a good practice.
07:27:14 <nikki93> Why is Haskell lazy?
07:27:18 <nikki93> Doesn't that make it slower sometimes?
07:27:22 <Axman6> > let isEven x = find x rs where rs = zip (randoms (mkStdGen 2139471235)) (randoms (mkStdGen 235987235) :: [Bool]) in isEven 12345
07:27:23 <lambdabot>       No instance for (Num ((a, Bool) -> Bool))
07:27:23 <lambdabot>        arising from the liter...
07:27:27 <mauke> nikki93: because we already have enough strict languages
07:27:29 <matthew-_> nikki93: only when it doesn't make it faster
07:27:49 <dolio> Haskell isn't about being the fast.
07:27:53 <dolio> Fastest, even.
07:28:09 <nikki93> Ok.
07:28:16 <int-e> nikki93: yes it does. but it's also powerful. and sometimes, figuring out exactly what needs to be evaluated is so complicated that laziness actually wins.
07:28:18 <Twey> nikki93: Laziness in itself results in better performance, generally
07:28:27 <Axman6> :t find
07:28:28 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
07:28:29 <Twey> But it comes with overhead, alas
07:28:48 <iwannalog> nikki93: for infinite list lazyness is very usefull
07:28:51 <Axman6> > let isEven x = find (==x) rs where rs = zip (randoms (mkStdGen 2139471235)) (randoms (mkStdGen 235987235) :: [Bool]) in isEven 12345
07:28:52 <lambdabot>       No instance for (Num (a, Bool))
07:28:52 <lambdabot>        arising from the literal `12345'...
07:29:04 <pejo> Twey, "generally"? Do you have any references?
07:29:07 <blip> an how can I fetch a seed? can I get systemTime or something ? but then the Monad asshole comes back and fucks with me?
07:29:10 <int-e> nikki93: but the real power, in my opinion, is being able to code in terms of infinite data structures (list in particular) without having to write any boilerplate code
07:29:14 <Twey> 'Mad, they called us mad!  But when we're all running Reducerons we'll show them, we'll show them all!  Mwahaha!'
07:29:21 <Twey> pejo: Mmmm, hang on
07:29:23 <mauke> blip: dude. stop trying to fight the interface and START USING IT
07:29:24 <Axman6> :t let isEven x = find (==x) rs where rs = zip (randoms (mkStdGen 2139471235)) (randoms (mkStdGen 235987235) :: [Bool]) in isEven
07:29:25 <lambdabot> forall a. (Eq a, Random a) => (a, Bool) -> Maybe (a, Bool)
07:29:30 * Twey racks brains and bookmarks.
07:29:38 <iwannalog> @users
07:29:38 <lambdabot> Maximum users seen in #haskell: 624, currently: 624 (100.0%), active: 26 (4.2%)
07:30:32 <Axman6> :t lookup
07:30:34 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
07:30:59 <oklopol> pejo: ahh!
07:30:59 <pejo> Twey, "More haste, less speed: The complexity of lazy evaluation"?
07:31:03 <Axman6> > let isEven x = lookup x rs where rs = zip (randoms (mkStdGen 2139471235)) (randoms (mkStdGen 235987235) :: [Bool]) in isEven 12345
07:31:15 <oklopol> pejo: i still like it :P
07:31:18 <lambdabot>   thread killed
07:32:04 <Twey> pejo: I read it here: http://en.wikibooks.org/wiki/Haskell/Graph_reduction#Lazy_eval_.3C_Eager_eval but no proof presented.  Not much of a reference, sorry.
07:32:27 <Twey> Someone like Cale could probably give you the reasoning behind it
07:32:45 <defun> hi, i am solving problem 5 of project euler. I tried using the following program: (http://hpaste.org/14062) to find the smallest number divisible by all the numbers from 1 to 20. I get the following ghc error (http://hpaste.org/14063). The above program works when trying to find all number divisible from 1 to 10 though. If the list is empty, then there is no solution? Or is it a problem with my program?
07:33:06 <mauke> oh wow
07:33:38 <pejo> Twey, that sounds funky. Evaluate "show (1+1)" and count the stpes.
07:33:44 <mauke> defun: the solution is probably bigger than 1000000, so you don't find it
07:34:25 <mauke> Twey: eh, that's pretty obvious
07:34:25 <defun> mauke: so I can't find solutions greater than 1000000? Why? Is there a way around this?
07:34:33 <Axman6> > let isEven x = lookup x rs where rs = zip (randoms (mkStdGen 2139471235)) (randoms (mkStdGen 235987235) :: [Bool]) in isEven 1
07:34:44 <mauke> Twey: the whole point of lazy eval is that sometimes it doesn't actually evaluate stuff because the result is never needed
07:34:48 <lambdabot>   thread killed
07:35:03 <mauke> defun: 'x <- [1..1000000]'
07:35:29 <mauke> that's your search space
07:35:31 <pejo> mauke, but the page is stating that "But knowing that lazy evaluation always performs less reduction steps than eager evaluation".
07:35:33 <defun> oh, right.
07:35:41 <defun> I should've seen that.
07:35:44 <defun> thanks.
07:36:01 <mauke> pejo: well, s/less/not more than/
07:36:13 <iwannalog> > foldr lcm 1 [1..20]
07:37:01 <pejo> mauke, sure, that's not controversial.
07:37:04 <defun> is it possible to define a list like this: [1..infinity]
07:37:10 <blip> what is a reduceron?
07:37:20 <mauke> defun: [1..]
07:37:20 <Twey> Good point, pejo
07:37:26 <lambdabot>   232792560
07:37:40 <Twey> Fix?
07:37:41 <defun> mauke: brilliant! Haskell is amazing!
07:37:43 <Axman6> > foldr lcm [1..8]
07:37:44 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
07:37:44 <lambdabot>        arising from a use...
07:37:48 <pejo> blip, there's some papers from york about it, Colin Runciman and one of is students.
07:37:48 <iwannalog> defun: [1..]
07:37:55 <Axman6> > foldr lcm 1 [1..8]
07:37:56 <lambdabot>   840
07:38:07 <mauke> > foldl1' lcm [1 .. 20]
07:38:08 <lambdabot>   232792560
07:38:14 <Gracenotes> yay, I just (almost) finished my Haskell Tetris implementation! There are 134 lines, and all I have to do is code a Start Screen and an End Game (also possibly a GUI) :D
07:38:15 <Axman6> iwannalog: damn, i never though of that, i think i brute forced it :(
07:38:18 <cknapp> Morning.
07:38:28 <iwannalog> Axman6: for the euler project ?
07:38:28 <Twey> blip: It's a CPU that does graph reduction very very fast.
07:38:38 <cknapp> Gracenotes: Nice!
07:38:40 <Twey> Google it for the paper.
07:38:44 <Axman6> yeah
07:38:49 <Twey> Haha, nice, Gracenotes :)
07:38:50 <iwannalog> Axman6: :D
07:38:59 <blip> IntMaps are what keys of int and values of ints?
07:39:05 <Gracenotes> I used the Maybe monad a lot...
07:39:07 <Twey> In an interesting coincidence, I'm currently learning SDL :-P
07:39:16 <Twey> blip: Int keys, any type of value
07:39:19 <mauke> blip: no, only Int keys, the values can be anything
07:39:22 <blip> i want o(1) insert and keys as (int,int) and value as double, what datstructure should i use?
07:39:41 <Twey> blip: Array
07:39:45 <mauke> blip: you should use Data.Map first and see if it's too slow
07:39:46 <iwannalog> [((int, int), double)]
07:39:48 <Axman6> iwannalog: that's brilliant, well done :)
07:39:51 <Twey> But yes
07:39:59 <Twey> Make sure you really need that first
07:40:15 <Gracenotes> Twey: neat! I did mine in GTK
07:40:17 <Twey> If you really do, an immutable array's the way to go.
07:40:20 <iwannalog> Axman6: but we could do faster
07:40:21 <Twey> Gracenotes: Gtk2Hs?
07:40:21 <Gracenotes> using the Cairo vector rendering technique
07:40:26 <Twey> Ooh
07:40:28 <Gracenotes> yeah
07:40:32 <Axman6> blip: i don't think you'll find anything that'll give you O(1) insert in haskell
07:40:41 <Twey> Axman6: Eh?
07:40:46 <blip> pejo: google no find, what is it about roughly?
07:40:50 <Twey> Mutable arrays have O(1) insert, no?
07:41:03 <blip> Gracenotes: please post code
07:41:09 <Axman6> Twey: replacement sure, not insert
07:41:12 <mauke> Twey: arrays don't have insert at all
07:41:17 <Axman6> or am i wrong?
07:41:21 <Twey> Oh!
07:41:23 <Twey> Yes, of course
07:41:26 <blip> twey: i see, so specialized hardware for haskell?
07:41:38 <Twey> blip: Functional/lazy programming in general
07:41:49 <Twey> But Haskell in mind, yeah
07:41:50 <Gracenotes> blip: my tetris! http://hpaste.org/14064
07:42:06 <Gracenotes> some of the lines are pretty long... hm...
07:42:09 <pejo> blip, http://www.cs.york.ac.uk/fp/reduceron/reduceron.pdf, but Twey gave the high level overview.
07:42:13 <Axman6> by the way, for anyone who doesn't know about it, matt's traceroute is fantastic. a must have for anyone working with networks (expecially crappy ISP's)
07:42:27 <mauke> who is matt?
07:42:32 <Axman6> no idea
07:42:34 <blip> Twey: sparse matrix? im using listArray for my current general Matrix but I need a lib for Sparse ones(huge ones).
07:42:41 <mauke> how is it different from normal traceroute?
07:42:42 <Axman6> the program is usually called mtr
07:42:42 <blip> does hmatrix support sparse matrices btw?
07:42:45 <pejo> blip, ("reduceron author:runciman" on scholar.google.com gave me the first hit, but it's on springer).
07:42:49 <Twey> blip: Is it bounded (at a size sensible to hold in memory)?
07:42:58 <Gracenotes> blip: I have yet to implement a GUI, with scores, etc.
07:43:09 <Gracenotes> but the block-falling works
07:43:17 <Axman6> blip: you might want to look into DPH, it's basically designed for that wort of work
07:43:34 <mauke> Data.Map.
07:43:35 <Twey> blip: If no, forget O(1) and see IntMap
07:43:44 <Twey> Er
07:43:45 <pejo> blip, it's not special hardware in the custom made sense, you can buy it from basically anywhere.
07:43:50 <Twey> Yeah, Map, sorry... tuple keys
07:44:18 <Twey> 'Anywhere'?
07:44:25 <Twey> They don't sell 'em down at PC World :-P
07:44:52 <Axman6> mauke: http://www.bitwizard.nl/mtr/
07:45:09 <Gracenotes> okay time to move onto bigger and better things... like breakout :<
07:45:49 <Twey> Heh, Gracenotes
07:45:55 <Twey> Have fun :)  Nice to see you around here by the way
07:45:58 * maltem first read 'breakfast'
07:46:10 <Axman6> mauke: basically, it can let you pinpoint exactly where you're say losing packets, getting lag, and all in realtime
07:46:17 <Gracenotes> Twey: yeah :) If you're interested, by the way, here's the source so far: http://hpaste.org/14064
07:46:34 <Twey> Gracenotes: Saw it already :-P
07:46:53 <Gracenotes> most of the code is not specific to the rendering engine or windowing system. So feel free to reuse ;)
07:47:02 <Twey> Gracenotes: Too much monadic code there for my liking :(
07:47:29 * Twey hates it when a program ends up being >50% IO
07:47:39 <Gracenotes> yeah... I got carried away. it's mostly the Maybe monad, though
07:48:19 <blip> dph?
07:48:21 <Gracenotes> plus, all of the GUI's callback functions are IO
07:48:32 <Twey> Yeah :(
07:48:35 <Gracenotes> Twey: in fact, most programs are 100% IO :P
07:48:39 <Twey> Separate them out more :)
07:48:41 <Twey> Hah :-P
07:48:48 <defun> with the infinite list, the program seems to do nothing...
07:49:07 <Twey> defun: Code
07:49:22 <mauke> defun: it just keeps running
07:49:25 <Gracenotes> mode of the stuff is just reading IO, playing around in let statements, and then writing IO
07:49:28 <Gracenotes> *most
07:49:29 <maltem> blip: Data parallel Haskell, but in case you wondered, dph isn't related to linear algebra or sparse matrices, it's about parallel processing
07:49:33 <Axman6> defun: you might also want to reduce the numbers you check to only the prime numbers below 20
07:49:33 <Gracenotes> so it could definitely be sorted out
07:49:46 <mauke> defun: 'minimum' has to check all elements to find the minimum. unfortunately the list never ends, so it never stops
07:49:46 <defun> mauke: meaning it will reach a result evenually?
07:49:47 <Twey> Gracenotes: Aye
07:49:54 <defun> damn
07:50:13 <mauke> defun: but you don't need minimum
07:50:29 <mauke> defun: you already generate the results in ascending order, so all you need to do is take the first one
07:50:35 <defun> i need the head function?
07:50:38 <mauke> yes
07:50:40 <Gracenotes> hm, modifyIORef looks interesting
07:50:44 <defun> thanks.
07:50:44 <Gracenotes> it would work for most of my stuff
07:50:49 <Twey> Gracenotes: *wince*
07:50:54 <Twey> Famous last words
07:51:09 <Gracenotes> is it to be avoided?
07:51:21 <Twey> Gracenotes: IORefs generally are to be avoided where possible
07:51:45 <Twey> There are some places where they're necessary, but Yours Is Probably Not One.
07:51:54 <Gracenotes> oh. >_> my program is basically mostly IORefs, in terms of how the state is stored. Any ideas how to restructure?
07:52:03 <Twey> Recurse more
07:52:07 <Axman6> there's a difference between STRefs and
07:52:11 <Axman6> IORefs
07:52:18 <Twey> Aye
07:52:20 <Saizan_> well, if you're dealing with callbacks in IO that need to communicate, then IORefs are fine
07:52:28 <Axman6> STRefs make me feel safe
07:52:30 <Gracenotes> it's convenient, because the callback functions are IO anyway.
07:52:34 <Saizan_> the only way, actually
07:52:36 <Axman6> inface, ST is just plain awesome
07:52:51 <Axman6> infact*
07:52:54 <Gracenotes> however... I could keep the ST variables in the main function, and pass them to callbacks
07:53:07 <Saizan_> Gracenotes: no
07:53:14 <Gracenotes> er, no?
07:53:14 <Axman6> @remember Axman6 inface, ST is just plain awesome
07:53:14 <lambdabot> Done.
07:53:21 <Gracenotes> inface!
07:53:32 <Twey> Hehe
07:53:40 <Gracenotes> Saizan_: other suggestions for using ST, then?
07:54:05 <Saizan_> you can use a STRef only in a single ST computation
07:54:06 <Gracenotes> given shared game state and callbacks that need to access it?
07:54:18 <Saizan_> i think you want IORefs there
07:54:31 <maltem> Gracenotes: StateT GameState IO would come to mind, even if that doesn't gain you much, or anything, over IORefs
07:54:35 <Saizan_> maybe you can hide them behind a MonadState or something
07:54:58 <mauke> you have unconnected states
07:55:02 <mauke> use IORefs
07:55:10 <Saizan_> maltem: that type doesn't work for callback, without some particular juggling that goes via IORefs
07:55:32 <Stephan202> @pl \a b -> a : b : []
07:55:32 <lambdabot> (. return) . (:)
07:55:35 * Twey sees.
07:55:44 <Twey> This is One, huh :)
07:55:47 <maltem> Saizan_: mm ok
07:55:58 <Gracenotes> okay. I did use IORefs, actually
07:56:16 <Gracenotes> the callbacks are like (board, piece) <- readIORef boardRef .... writeIORef boardRef (board, block')
07:56:40 <Gracenotes> okay :) great
07:56:52 <mauke> modifyIORef boardRef (second f)
07:57:17 <Gracenotes> it does need the board to calculate the next block's position
07:58:10 <Gracenotes> but, yes. that function.
07:58:21 <Twey> Right, then
07:58:27 <Twey> Sleep for me :)  'night
07:58:29 <Gracenotes> well, it took 14 hours, but I think it's playable :) Hopefully the next one will go quicker
07:58:34 <Gracenotes> g'night
07:58:45 <Twey> Woah, 14h
07:58:54 <Twey> Gracenotes: I recommend Glade, by the way
07:58:56 <Twey> It's nice
07:59:06 <Axman6> g'night Twey
07:59:08 <Gracenotes> yeah, I had read about it in RWH
07:59:23 <Gracenotes> vector graphics is pretty simple just for blocks
07:59:33 <Gracenotes> I shall definitely take a look though...
07:59:47 <Stephan202> @pl \x y -> [(a, b) | a <- x, b <- y]
07:59:47 <lambdabot> (. (return . (b <-))) . (:) . (((a, b) | a) <-)
08:00:37 <Axman6> o.O
08:01:01 <Axman6> i don't think @pl understands list comprehensions
08:01:24 <mauke> @. pl undo \x y -> [(a, b) | a <- x, b <- y]
08:01:24 <lambdabot> (. flip ((=<<) . flip flip [] . ((:) .) . (,))) . (>>=)
08:01:46 <skorpan> looks right to me
08:01:53 <mauke> liftM2 (,)
08:02:08 <Axman6> heh
08:04:01 <Axman6> @pl \x y -> do { a <- x; b <- y; return (a,b)}
08:04:02 <lambdabot> (line 1, column 12):
08:04:02 <lambdabot> unexpected "{"
08:04:02 <lambdabot> expecting variable, "(", operator or end of input
08:04:14 <beelsebob> x <^(,)^> y
08:04:38 <asgaroth> @src <^
08:04:38 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
08:04:47 <beelsebob> it's in InfixApplicative
08:04:51 <beelsebob> it's flip fmap
08:04:55 <beelsebob> ^> is <*>
08:04:59 <asgaroth> ah
08:05:49 <Axman6> @src (<^)
08:05:49 <lambdabot> Source not found. :(
08:05:57 <Axman6> @hoogle (<^)
08:05:57 <lambdabot> Control.Arrow (<<^) :: Arrow a => a c d -> (b -> c) -> a b d
08:06:06 <Axman6> :y (<^)
08:06:09 <Axman6> :t (<^)
08:06:10 <lambdabot> Not in scope: `<^'
08:06:29 <Axman6> far out ghc takes forever to checkout
08:07:32 <beelsebob> Axman6: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/InfixApplicative
08:08:59 <pejo> Is code.haskell.org not responding to connections for anyone else as well?
08:09:20 <beelsebob> nope, not getting anything here
08:09:21 <kerlo> @doc Dynamic
08:09:21 <lambdabot> Dynamic not available
08:09:25 <kerlo> @index Dynamic
08:09:25 <lambdabot> Data.Dynamic
08:09:27 <mauke> http://downforeveryoneorjustme.com/code.haskell.org
08:09:31 <kerlo> @doc Data.Dynamic
08:09:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Dynamic.html
08:11:08 <pejo> mauke, nice.
08:15:10 <kerlo> Hmm. Is there a way to say "read this string into a value of type <some Data.Typeable>"?
08:15:19 <kerlo> Rather...
08:15:32 <kerlo> "Read this string into a Dynamic with a value of type <some Data.Typeable>"?
08:17:37 <mauke> f :: (Typeable a) => a -> String -> Dynamic?
08:20:20 <kerlo> f :: TypeRep -> String -> Dynamic
08:20:33 <skorpan> what is the haskell equivalent to python's ', '.join(arr)?
08:20:39 <mauke> hmm, TypeRep
08:20:46 <kerlo> Or maybe it should be Maybe Dynamic, giving Nothing if it isn't readable.
08:20:48 <mauke> skorpan: intercalate ", "
08:21:12 <skorpan> :t intercalate
08:21:13 <lambdabot> forall a. [a] -> [[a]] -> [a]
08:21:14 <mauke> kerlo: I don't see how to do it with TypeRep
08:21:26 <sbahra> heh
08:21:29 <skorpan> where is intercalate?
08:21:32 <sbahra> What do you guys think of http://importantshock.wordpress.com/2009/01/18/jquery-is-a-monad/ ?
08:21:41 <mauke> @index intercalate
08:21:41 <lambdabot> bzzt
08:21:46 <skorpan> Data.List?
08:21:47 <mauke> should be in Data.List
08:22:12 <skorpan> thanks
08:23:43 <Raevel> sbahra: well i don't like jquery :-P
08:24:01 <mauke> kerlo: the best I can do is f :: (Read a, Typeable a) => a -> String -> Dynamic
08:24:11 <jeffwheeler> sbahra: seems like a stretch, but I'm not sure why
08:24:40 <boxy> niggers
08:24:52 <jeffwheeler> op?
08:24:55 --- mode: ChanServ set +o mauke
08:25:23 --- mode: mauke set +b *!?=yxxob@*
08:26:43 <Badger> > null
08:26:45 <lambdabot>       Overlapping instances for Show ([a] -> Bool)
08:26:45 <lambdabot>        arising from a use ...
08:26:49 <Badger> ah.
08:27:12 <mauke> f y s = case reads s of [(x,"")] -> Just (toDyn (x `asTypeOf` y)); _ -> Nothing
08:27:22 --- mode: mauke set -o mauke
08:27:57 <mauke> while we're at it ...
08:28:06 <mauke> @let a === b = cast a == Just b
08:28:08 <lambdabot>  Defined.
08:28:32 <asgaroth> @type case
08:28:34 <lambdabot> parse error (possibly incorrect indentation)
08:28:35 <asgaroth> @type cast
08:28:35 <mauke> > 'x' === 'x'
08:28:37 <lambdabot>   True
08:28:37 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
08:28:41 <mauke> > 'x' === ()
08:28:42 <lambdabot>   False
08:29:09 <Pellwurst> when i use a function with the signature "String -> IO String", can i use this function within another one, which has the signature "String -> String"? or must the second signature then be "String -> IO String" as well?
08:29:14 <jethr0> > Just 4 === 4
08:29:16 <lambdabot>   False
08:29:35 <skorpan> does anyone have an emacs program which sorts haskell function definitions?
08:29:35 <mauke> Pellwurst: you can "use" it if you ignore the result, which is not useful
08:29:47 <mauke> Pellwurst: to make sense, you need a return type of IO something
08:31:04 <Pellwurst> mauke: right, thx
08:33:00 <augustss> Pellwurst: you can certainly use them together, but the result will be  function of type String -> IO String
08:38:14 <CakeProphet> threads in Haskell look fun.
08:40:08 <skorpan> @pl \((Family d _ k1), (Family _ m k2)) -> Family d m (k1 ++ k2)
08:40:08 <lambdabot> (line 1, column 11):
08:40:09 <lambdabot> unexpected "d"
08:40:09 <lambdabot> expecting operator or ")"
08:41:38 <mstr> http://pastebin.com/m27982cc6
08:41:44 <mstr> why does that fail?
08:42:02 <Gracenotes> @pl \b -> maybe b f (g b)
08:42:02 <lambdabot> ap (flip maybe f) g
08:42:21 <lamda> Any wise folks can please help me. How do I peek from a mmap'd location after doing: (p,n) <- mmapFileForeignPtr "an.txt" WriteCopy Nothing
08:42:21 <lamda> http://hackage.haskell.org/packages/archive/mmap/0.2/doc/html/System-IO-MMap.html
08:43:39 <nikki93> head xs is O(1)?
08:43:45 <nikki93> @src head
08:43:46 <lambdabot> head (x:_) = x
08:43:46 <lambdabot> head []    = undefined
08:44:03 <nikki93> @src tail
08:44:03 <lambdabot> tail (_:xs) = xs
08:44:03 <lambdabot> tail []     = undefined
08:44:09 <mauke> mstr: because ++ takes two lists. reverse' xs is a list, but x is just an element
08:44:27 <mstr> ahh, thanks :)
08:45:40 <nikki93> 	  secondInList (_:x:xs) = x
08:45:49 <nikki93> That's the best way to implement 'second in list'?
08:46:00 <nikki93> I could do head (tail xs) though.
08:46:03 <Axman6> mstr: that's a vert inefficient way of defining reverse though
08:46:03 <mauke> > head . tail $ "abcd"
08:46:04 <dmajnem2_> what is the best way to get cabal on openSuse
08:46:05 <lambdabot>   'b'
08:46:18 <nikki93> mauke: Hah! I got it before ya! :P
08:46:28 <mauke> nikki93: you win :-)
08:46:28 <Axman6> O(n^n) or something
08:46:29 <mstr> Axman6: I'm just browsing beginner tutorials and trying stuff out, so no problem yet
08:47:00 <bremner> nikki93: but the head . tail one is unsafe(ish)
08:47:23 <nikki93> fib n = reverse (internalFib [1,0] (n - 2))
08:47:23 <nikki93>     where internalFib nums n = if (n > 0) then internalFib ([(head nums) + (secondInList  nums)] ++ nums) (n - 1) else nums
08:47:26 <nikki93> 	  secondInList (_:x:xs) = x
08:47:28 <nikki93> My new fibonacci! :D
08:47:39 <pejo> dmajnem2, cabal comes with your haskell compiler
08:47:43 <dcoutts> dmajnem2_: do you mean the cabal-install package?
08:48:01 <dmajnem2_> pejo: this is good to know
08:48:09 <nikki93> > fib n = reverse (internalFib [1,0] (n - 2)) where internalFib nums n = if (n > 0) then internalFib ([(head nums) + (secondInList  nums)] ++ nums) (n - 1) else nums ; secondInList (_:x:xs) = x
08:48:10 <lambdabot>   <no location info>: parse error on input `='
08:48:42 <Axman6> > let reverse (x:xs) = reverse xs ++ [x]; reverse [] = [] in reverse [1..100]
08:48:43 <lambdabot>   [100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,7...
08:48:48 <Axman6> > let reverse (x:xs) = reverse xs ++ [x]; reverse [] = [] in reverse [1..10000]
08:48:50 <lambdabot>   [10000,9999,9998,9997,9996,9995,9994,9993,9992,9991,9990,9989,9988,9987,998...
08:48:54 <Axman6> > let reverse (x:xs) = reverse xs ++ [x]; reverse [] = [] in reverse [1..100000]
08:48:54 <dmajnem2_> dcoutts: I suppose
08:49:03 <dmajnem2_> pejo: it does not seem to be on my system
08:49:07 <lambdabot>   [100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,9...
08:49:21 <Axman6> > reverse [1..1000000]
08:49:23 <lambdabot>   [1000000,999999,999998,999997,999996,999995,999994,999993,999992,999991,999...
08:49:40 <dmajnem2_> but I have ghc and ghci but no cabal nothing
08:50:01 <dcoutts> dmajnem2_: you want the cabal-install package from hackage
08:50:08 <mstr> hmm, I thought that this should work, but doesn't?
08:50:09 <mstr> reverse' x = reverse' (tail x) ++ head x
08:50:25 <mauke> mstr: head x is still not a list
08:50:32 <mstr> argh :D
08:50:36 <nikki93> > let fib n = let internalFib nums n = if (n > 0) then internalFib ([(head nums) + (secondInList  nums)] ++ nums) (n - 1) else nums ; secondInList (_:x:xs) = x in reverse (internalFib [1,0] (n - 2))
08:50:38 <lambdabot>   <no location info>: parse error on input `;'
08:50:50 <nikki93> > let fib n = let internalFib nums n = if (n > 0) then internalFib ([(head nums) + (secondInList  nums)] ++ nums) (n - 1) else nums ; secondInList (_:x:xs) = x in reverse (internalFib [1,0] (n - 2)) in fib 2
08:50:52 <lambdabot>   [0,1]
08:50:55 <mauke> mstr: see what Axman6 wrote above
08:50:57 <nikki93> > let fib n = let internalFib nums n = if (n > 0) then internalFib ([(head nums) + (secondInList  nums)] ++ nums) (n - 1) else nums ; secondInList (_:x:xs) = x in reverse (internalFib [1,0] (n - 2)) in fib 10
08:50:58 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
08:51:03 <nikki93> ;-)
08:51:22 <nikki93> IRC ftw!
08:51:53 <Axman6> nikki93: fib' would be more common than internalFib
08:52:00 <mauke> :t (0:) . (1:) . ap (zipWith (+)) tail
08:52:01 <lambdabot> forall a. (Num a) => [a] -> [a]
08:52:03 <Axman6> just tends to be the style
08:52:08 <mauke> > fix $ (0:) . (1:) . ap (zipWith (+)) tail
08:52:09 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:52:10 <nikki93> Axman6: Ohk.
08:52:20 <sbahra> Haskell'98 is very well-written
08:52:20 <CakeProphet> is there any sort of Queue in the standard library? Particular for message-passing concurrency?
08:52:22 <nikki93> mauke: I'm not that good yet.
08:52:26 <CakeProphet> +ly
08:52:29 <sbahra> CakeProphet, look at Chan
08:52:40 <mauke> nikki93: you'll get there soon :-)
08:52:49 <nikki93> mauke: Yeah, but my method is better than yours.
08:52:52 <nikki93> ;-)
08:52:56 <mstr> mauke: ya, got it. thx
08:52:58 <mauke> s/better/slower/
08:52:58 <CakeProphet> I'm thinking message-passing is the way to go in order to avoid a concurrency headache
08:53:06 <sbahra> CakeProphet, what is the problem?
08:53:40 <CakeProphet> sbahra:  no problem yet, I'm just planning ahead of time for problems. I want to make a massively concurrent MUD client in Haskell without it breaking.
08:53:53 <nikki93> > let fib n = let internalFib nums n = if (n > 0) then internalFib ([(head nums) + (secondInList  nums)] ++ nums) (n - 1) else nums ; secondInList (_:x:xs) = x in reverse (internalFib [1,0] (n - 2)) in fib 25
08:53:54 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:54:10 <nikki93> But just look at the obscurity of it. :P
08:54:25 <chessguy> roconnor++
08:54:32 <chessguy> freaking awesome
08:54:33 <skorpan> anyone using inf-haskell here? is there any way to make getChar work right?
08:55:07 <Gracenotes> @djinn [a] -> Maybe a
08:55:07 <lambdabot> Error: Undefined type []
08:55:17 <mauke> @hoogle [a] -> Maybe a
08:55:18 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
08:55:18 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
08:55:18 <lambdabot> Prelude head :: [a] -> a
08:55:29 <Gracenotes> ah, yes.
08:55:41 <mauke> nikki93: (head nums + secondIntList nums) : nums
08:55:44 <Gracenotes> there are never enough useful Maybe functions :)
08:55:46 <CakeProphet> sbahra:  chan looks like it'll be perfect. I can make a Message type that supports various commands/actions/whatever, to pass around.
08:56:26 <CakeProphet> oh wow... unGetChan would be handy. I don't think I've seen a queue that has that.
08:56:57 <nikki93> mauke: Ok, that works. Doesn't make you any better though. :D
08:57:37 <CakeProphet> dupChan is cool too...
08:58:44 <nikki93> I'm happy that its at least faster than my old fib n = fib (n - 1) + fib (n - 2) version
08:59:03 <elbar> i think this one is obscure : fix ((1:) . scanl (+) 1)
08:59:28 <dmajnem2_> dcoutts: thanks
08:59:41 <smarmy> elbar: it's (0:) isn't it?
09:00:03 <elbar> > take $ fix ((1:) . scanl (+) 1)
09:00:05 <lambdabot>   Couldn't match expected type `Int' against inferred type `[a]'
09:00:12 <Saizan_> > fix ((1:) . scanl (+) 1)
09:00:13 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
09:00:20 <Saizan_> > fix ((0:) . scanl (+) 1)
09:00:21 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
09:00:28 <elbar> is the 0 part of it?
09:00:29 <smarmy> k
09:01:00 <Saizan_> @oeis fibonacci
09:01:02 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
09:01:02 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
09:01:36 <elbar> then its 0: ;)
09:01:40 <roderyk> http://hpaste.org/14065
09:01:46 <roderyk> can someone take a quick peek at that?
09:01:55 <CakeProphet> sbahra:  is it better style to include class constraints in a functions type signature, or is it less trouble to simply let type inference do it.
09:02:00 <roderyk> I'm looking for the equivelant "id" of an XmlTree Arrow :)
09:03:54 <Saizan_> roderyk: arr id?
09:04:25 <sbahra> CakeProphet, better style to be explicit
09:04:31 <CakeProphet> alright.
09:05:07 <CakeProphet> except for some cases I'd imagine: like it would be silly to include class constraints for a class you're defining.
09:05:23 <roderyk> saiam_: ah, right! *head on brick*
09:05:28 <roderyk> Saizan_: ^^
09:05:34 <CakeProphet> class Ord a where comparse (Ord a) => a -> a -> Ordering
09:05:37 <CakeProphet> -s
09:05:42 <Heffalump> CakeProphet: if you give a type signature at all, you have to give all constraints; except that in the specific case you mention, the constraint is implicitly included and should be left out.
09:06:27 <CakeProphet> Heffalump:  ah okay. so if you give a type signature, Haskell doesn't implicitly add class constraints and will complain if you don't include them?
09:06:39 <Heffalump> correct
09:07:12 <CakeProphet> alright.
09:08:31 <CakeProphet> sbahra:  is there a mutable map in the standard libs?
09:09:14 <maltem> CakeProphet: when defining a class, the class constraint is indeed implicit, or in other words, the type variable from the head is in scope
09:10:13 <Heffalump> does cabal (the command-line tool) have any documentation beyond its usage message(s) and if so, where? I've just wandered around the various web pages about it a bit without finding anything.
09:10:40 <dcoutts> Heffalump: no, of course the docs for the command line interface to Setup.hs all apply
09:10:53 <dcoutts> Heffalump: so that describes all the configure flags etc
09:11:16 <Heffalump> I'm trying to work out how to set some default flags, if that's possible at all - specifically --global --root-cmd=sudo --enable-library-profiling --enable-executable-profiling
09:11:35 <dcoutts> Heffalump: yes, in the ~/.cabal/config file
09:11:48 <Heffalump> I got that far, but the wiki page claims that's self-documenting, and it isn't.
09:11:52 * dcoutts notes the darcs version of cabal-install mentions this in the --help output
09:12:02 <Heffalump> At least, it doesn't have any line that is obviously the place to put those flags.
09:12:04 <dcoutts> Heffalump: make a backup, rm it and let it be re-created
09:12:15 <dcoutts> Heffalump: you've got a config file created by an older version
09:12:26 <Heffalump> ah, right :-)
09:12:33 <nikki93> How's Haskell's FFI?
09:12:42 <nikki93> I'm very interested in using it for game scripting.
09:12:42 <dcoutts> nikki93: excellent
09:12:45 <Liskni_si> how do I tell cabal to fetch all dependencies for my package? (it's not on hackage, so cabal install won't work)
09:13:08 <Saizan_> Liskni_si: you can run "cabal install" from its directory
09:13:12 <Heffalump> dcoutts: thanks, working now.
09:13:13 <pejo> Liskni, just run "cabal install" in your directory.
09:13:15 <nikki93> dcoutts: Nice way to put it. :P
09:13:17 <Liskni_si> oh
09:13:32 <nikki93> The current standard in ghc, what's it called?
09:13:36 <nikki93> 'Haskell 98'?
09:13:36 <Liskni_si> Saizan_, pejo: thx a lot :)
09:13:46 <dcoutts> Liskni_si: we're going to add a command to install just the deps, so you don't have to install the current package too
09:14:01 <mauke> Haskell's FFI is at least two orders of magnitude better than Perl's XS system
09:14:23 <Heffalump> on the "mauke likes it" scale?
09:14:52 <mauke> I think most people would agree with me there, so it's not just me :-)
09:15:15 <jql> it's one order of magnitude better on the kelvin scale. :)
09:15:24 <sbahra> I don't know Perl's XS system, but I derive from mauke's scale.
09:15:34 <ozy`> nikki93: haskell would be a fascinating choice for a scripting language, considering you really ought to compile it....
09:15:39 <sbahra> rhrhr
09:16:17 <Liskni_si> dcoutts: ok, that will be fine, but I am happy even if it does install it :)
09:16:34 <Heffalump> Haskell's getting easier and easier to run dynamically, if you don't mind shipping something the size of ghci.
09:16:36 <{g}> Hey People! Whats the name of that comment-style, where you write "@param type description" etc?
09:16:48 <Heffalump> {g}: javadoc?
09:16:49 <mauke> in terms of easy of writing bindings to a C library, OCaml is pure bliss compared to Perl
09:16:56 <mauke> and Haskell's FFI makes it downright trivial
09:17:02 <mauke> er, ease
09:17:18 <{g}> Heffalump: really? i thought its language independant
09:17:24 <mauke> (this assumes you know C)
09:17:24 <Heffalump> ok, then I don't know
09:17:52 <jql> all new technologies invented in that three-year-period were prefixed with 'java'
09:18:35 <scsibug> {g}: doxygen?
09:19:07 <arw> not quite doxygen. doxygen has a mode where it emulates javadoc.
09:19:11 <maltem> Heffalump: the compiler size is actually what cripples some arguments. Consider xmonad advertised as lightweight with little dependencies, but once you want to configure something, you need a ghc environment :)
09:19:22 <{g}> scsibug: i think its javadoc or phpdoc. i thought it was language independant.
09:19:25 <arw> but there is also some other syntax one can use, which i don't remember.
09:19:46 <nikki93> Here's my implement of getDigitAt. It gets the digit at position 'p' in number 'n' from the right.
09:19:50 <nikki93> getDigitAt p n = floor (n / (10 ^ (p - 1))) - ((floor (n / (10 ^ (p)))) * 10)
09:20:04 <mjb> {g}: There is doxygen, which works in a similar manner.
09:20:08 <skorpan> that almost looks like lisp
09:20:24 <arw> ah, \param, \whatever
09:20:33 <maltem> > reverse (show 1234567) !! 2
09:20:35 <lambdabot>   '5'
09:20:38 <ozy`> maltem: in other words we need a lightweight embedded scripting language that interfaces nicely with haskell....
09:20:50 <{g}> mjb: im only thinking about comment-style. not about tools that parse it.
09:21:33 <maltem> ozy`: heh, sounds like lots of work
09:21:39 <mm_freak> > let getDigitAt k = (`rem` 10) . (`div` 10^k) in getDigitAt 0 12345
09:21:41 <lambdabot>   5
09:21:44 <mm_freak> > let getDigitAt k = (`rem` 10) . (`div` 10^k) in getDigitAt 1 12345
09:21:46 <lambdabot>   4
09:21:50 <mm_freak> > let getDigitAt k = (`rem` 10) . (`div` 10^k) in getDigitAt 3 12345
09:21:51 <lambdabot>   2
09:21:56 <ozy`> maltem: doesn't have to be, surely....
09:22:00 <ehird> 17:20 <ozy`> maltem: in other words we need a lightweight embedded scripting language that interfaces nicely with haskell....
09:22:01 <arjanb> the compiler doesn't have to be large is you stick to haskell98
09:22:01 <ehird> Haskell.
09:22:15 <arjanb> -is +if
09:22:27 <Heffalump> arjanb: what compiler would you use?
09:22:32 <bremner> ozy`: scheme?
09:22:45 <ozy`> ehird: GHC is not lightweight. that's why I made that comment in the first place
09:23:05 <ehird> so don't use ghc
09:23:12 <ozy`> bremner: maybe. I'd prefer something a little more haskell-ish than scheme... or at least python-ish, if nothing else
09:23:25 <maltem> ozy`: wouldn't interfacing with ghc-compiled libs be hell, considering the ABI is not stable?
09:24:21 <ozy`> maltem: that's another issue to take into account, yes
09:24:37 <ozy`> ehird: what compiler/interpreter would be better suited for embedding into a program?
09:24:52 <gwern> maybe one could use the very small versions of ech
09:24:54 <gwern> *ehc
09:24:58 <arjanb> Heffalump: well the problem is all are either large or some toy project
09:25:21 <Heffalump> arjanb: right
09:25:22 <ehird> ozy`: depends, there are a lot of haskell interps
09:25:28 <ehird> but, consider Scheme
09:25:36 <Heffalump> so "doesn't have to be large" is kind of unproven
09:25:39 <nikki93> > let getDigitAt p n = floor (n / (10 ^ (p - 1))) - ((floor (n / (10 ^ (p)))) * 10) in getDigitAt 5 16526546
09:25:41 <lambdabot>   2
09:25:48 <ozy`> ehird: there are a lot of things I don't like about scheme.
09:25:58 <ozy`> for one thing, I am no longer very fond of parentheses
09:26:03 <maltem> ozy`: right, I think this (interfacing ghc libs) would have been the point of the hypothetic "lightweight embedded scripting language"
09:26:03 <ozy`> that's me though
09:26:06 <ehird> why not GHC, anyway
09:26:08 <mm_freak> nikki93: getDigitAt k = (`rem` 10) . (`div` 10^k)
09:26:27 <bremner> javascript FTW
09:26:31 <nikki93> mm_freak: How does that work?
09:26:41 <gwern> although cooler would probably be a customtotal version of haskell which you would put into a sandbox, and feed it the text of a page
09:26:45 <ozy`> maltem: I'm thinking just for configuration purposes, it might not be such a hard problem
09:26:47 <nikki93> mm_freak: I'm new to haskell.
09:27:11 <mm_freak> nikki93: infix notation:  f a b = a `f` b
09:27:17 <bremner> we should make a new "enterprise" scripting language, and call it hasbeans
09:27:21 <maltem> ozy`: if you say so; I haven't thought about it much
09:27:23 <nikki93> mm_freak: Ok, that I know.
09:27:31 <nikki93> mm_freak: whats rem function?
09:27:37 <mm_freak> remainder
09:27:47 <Axman6> > rem 5 23
09:27:49 <lambdabot>   5
09:27:57 <Axman6> > rem 23 5
09:27:58 <lambdabot>   3
09:28:04 <ozy`> ehird: apps can be lightweight if they're distributed as binaries. GHC is decidedly not lightweight. having GHC as a dependency is bad for normal users.
09:29:35 <bremner> does ghci work without ghc?
09:29:40 <ozy`> maltem: it doesn't have to be general-purpose; if you're actually extending the "host" program in significant ways, you might as well use haskell.
09:30:12 <ozy`> maltem: a configuration language more powerful than, say, JSON, would be nice, though
09:30:49 <ozy`> bremner: not to my knowledge. IIRC it's a thin layer over GHC's dynamic compiling and relinking abilities
09:31:14 <bremner> ozy`: yeah, just figured that out.
09:31:28 <maltem> ozy`: ah that's what you're thinking about, more like a configuration language library rather than a programmer's interface
09:31:31 <bremner> on my system, ghci == ghc --interactive
09:32:30 <nikki93> mm_freak: Why not use`mod`?
09:32:47 <mm_freak> nikki93: because rem is faster
09:33:04 <Axman6> @src rem
09:33:04 <lambdabot> Source not found. Just what do you think you're doing Dave?
09:33:06 <ozy`> maltem: exactly. the program's author would explicitly expose functions to the interpreter
09:33:07 <Axman6> @src mod
09:33:07 <lambdabot> Source not found. :(
09:34:21 <nikki93> mm_freak: So... You divide the reminder by 10^k?
09:34:31 <nikki93> Hm
09:34:52 <mm_freak> (f . g) x = f (g x)
09:35:00 <roconnor> @src (.)
09:35:01 <lambdabot> (f . g) x = f (g x)
09:35:21 <mm_freak> or in words:  feed 'x' to 'g' and feed the result to 'f'
09:35:45 <nikki93> AHA! Now I got it! div divides and qives quotient without remainder.
09:35:58 <nikki93> div x y = floor (x / y)
09:36:03 <nikki93> @src div
09:36:03 <lambdabot> Source not found. That's something I cannot allow to happen.
09:36:11 <nikki93> lambdabot: Get lost. :P
09:36:25 <roconnor> > div (-3) 2
09:36:27 <lambdabot>   -2
09:36:28 <kerlo> I imagine div is a single CPU instruction or something.
09:36:34 <dons> yup
09:36:34 <roconnor> floor (-3/2)
09:36:37 <roconnor> > floor (-3/2)
09:36:38 <lambdabot>   -2
09:36:47 <roconnor> > quot (-3) 2
09:36:48 <lambdabot>   -1
09:37:06 <kerlo> @check div x y == floor (fromInteger x / fromInteger y)
09:37:07 <lambdabot>   Couldn't match expected type `Integer' against inferred type `Expr'
09:37:20 <kerlo> @check \x y -> div x y == floor (fromInteger x / fromInteger y)
09:37:21 <roconnor> @check \x y -> (x `div` y)*y + (x`mod`y) == x
09:37:21 <lambdabot>   "* Exception: divide by zero
09:37:23 <lambdabot>   "* Exception: divide by zero
09:37:32 <roconnor> @check \x y -> y/=0 ==> (x `div` y)*y + (x`mod`y) == x
09:37:33 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
09:37:33 <lambdabot>           ...
09:37:40 <kerlo> @check \x y -> y == 0 || div x y == floor (fromInteger x / fromInteger y)
09:37:41 <lambdabot>   "OK, passed 500 tests."
09:37:51 <roconnor> no fair
09:38:23 <skorpan> @check x == x
09:38:24 <roconnor> @check \x y -> (y/=0) ==> ((x `div` y)*y + (x`mod`y) == x)
09:38:25 <lambdabot>   "OK, passed 500 tests."
09:38:25 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
09:38:25 <lambdabot>           ...
09:38:46 <alsonk> Anyone know when Debian will move to GHC 6.10?
09:39:07 <roconnor> > x == x
09:39:09 <lambdabot>   True
09:39:48 <CakeProphet> :t when
09:39:49 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
09:39:55 <roconnor> lambdabot: no instance for what?
09:39:59 <roconnor> whaaaaaaat?
09:40:05 <roconnor> oh
09:40:07 <roconnor> Testable
09:40:10 <nikki93> Ok, I've now improved my version, to this:
09:40:12 <nikki93> getDigitAt p n = (n `div` (10 ^ (p - 1))) `rem` 10
09:40:26 <roconnor> @check \(x::Integer) (y::Integer) -> (y/=0) ==> ((x `div` y)*y + (x`mod`y) == x)
09:40:27 <lambdabot>   Parse error in pattern at "(y::I..." (column 15)
09:40:30 <kerlo> @check \x y -> y == 0 || quot x y == floor (fromInteger x / fromInteger y)
09:40:31 <lambdabot>   "Falsifiable, after 1 tests:\n-1\n3\n"
09:40:41 <nikki93> But, mm_freak, you returned a function object from the function right?
09:40:42 <roconnor> @check \x y -> (y/=0) ==> ((x `div` y)*y + (x`mod`y) == (x::Integer))
09:40:44 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
09:40:44 <lambdabot>           ...
09:40:48 <nikki93> mm_freak: You used only one argument@
09:40:55 <nikki93> mm_freak: You returned a function object or something?
09:40:57 <kerlo> @type (==>)
09:40:58 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
09:41:23 <nikki93> @let getDigitAt k = (`rem` 10) . (`div` 10^k)
09:41:25 <lambdabot>  Defined.
09:41:27 <kerlo> > const 3 (==> True)
09:41:28 <roconnor> @type (/=)
09:41:29 <lambdabot>   3
09:41:30 <lambdabot> forall a. (Eq a) => a -> a -> Bool
09:41:31 <nikki93> :t getDigitAt
09:41:33 <lambdabot> forall b a. (Integral a, Integral b) => b -> a -> a
09:41:45 <kerlo> > const 3 (==> (True ==> True))
09:41:46 <lambdabot>   3
09:42:33 <maltem> nikki93: the right-hand side is a function of one argument, so the same applies to the lhs
09:42:41 <roconnor> @type \x y -> (y/=0) ==> ((x `div` y)*y + (x`mod`) == x)
09:42:42 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
09:42:42 <lambdabot>     Probable cause: `mod' is applied to too few arguments
09:42:42 <lambdabot>     In the second argument of `(+)', namely `(x `mod`)'
09:42:45 <mm_freak> nikki93: you can treat functions as values in haskell
09:42:48 <roconnor> @type \x y -> (y/=0) ==> ((x `div` y)*y + (x`mod`y) == x)
09:42:50 <lambdabot> forall a. (Integral a) => a -> a -> Property
09:42:54 <mm_freak> the (.) function takes two functions and returns a function
09:43:04 <roconnor> what's wrong with my check?
09:43:14 <roconnor> @check (True ==> True)
09:43:15 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
09:43:15 <lambdabot>           ...
09:43:22 <nikki93> mm_freak: I know.
09:43:24 <roconnor> check is borked
09:43:29 <nikki93> mm_freak: You returned a function object.
09:43:40 <roconnor> @tell Cale @check (True ==> True)
09:43:41 <lambdabot> Consider it noted.
09:43:41 <nikki93> mm_freak: If it weren't for function objects, things like map foldl wouldn't work. :)
09:43:52 <Botje> @check (\x -> True ==> True)
09:43:53 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
09:43:53 <lambdabot>           ...
09:44:34 <maltem> nikki93: I think noone said just "yes" to your question because the wording "function object" is uncommon for Haskell
09:44:35 <nikki93> > let f x = (+x) in f 2 3
09:44:37 <lambdabot>   5
09:44:49 <nikki93> It works. Nice.
09:44:58 <nikki93> maltem: Got it. Its a 'fundamental thing'. :)
09:45:07 <maltem> nikki93: yeah sort of :)
09:45:16 <nikki93> > let f x = (+x) in (f 2) 3
09:45:18 <lambdabot>   5
09:45:32 <nikki93> So basically, I'm creating a function out of f 2 there and calling it on 3?
09:46:20 <mm_freak> nikki93: just look at the lambda calculus
09:46:45 <nikki93> mm_freak: So that's the boolean algebra of haskell? :P
09:46:46 <mm_freak> it makes things much clearerâ¦  there are only single argument functions, but a function may return another function
09:47:12 <mauke> > ((+) 2) 3
09:47:14 <lambdabot>   5
09:47:16 <nikki93> mm_freak: OH MY... That means.. All this while... The two argument functions I wrote simply apply a function of one argument on another argument!
09:47:22 <nikki93> Discovery!
09:47:31 <mauke> nikki93: meditate on 'flip id'
09:47:35 <mm_freak> (\x -> (\y -> x + y)) 3 5 â (\y -> 3 + y) 5 â 3 + 5 â 15
09:47:47 <nikki93> > flip id
09:47:48 <lambdabot>       Overlapping instances for Show (b -> (b -> c) -> c)
09:47:48 <lambdabot>        arising from...
09:47:55 <nikki93> :t flip
09:47:57 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
09:48:24 <nikki93> Bah.. Its to crazy for us imperative minded people.
09:48:27 <ozy`> @unpl flip id
09:48:27 <lambdabot> (\ b c -> c b)
09:48:38 <mauke> @src flip
09:48:39 <lambdabot> flip f x y = f y x
09:48:41 <mauke> @src id
09:48:41 <nikki93> > flip id 3
09:48:41 <lambdabot> id x = x
09:48:42 <Elly> For "imperatively minded" read "miseducated" :P
09:48:42 <lambdabot>       Overlapping instances for Show ((b -> c) -> c)
09:48:42 <lambdabot>        arising from a us...
09:48:51 <ozy`> nikki93: this is why people say that learning haskell will expand your brain ;)
09:49:08 <mm_freak> nikki93: don't worry, it's just unusual, but not magic =)
09:49:40 <nikki93> I absolutely loved lambda functions in C++ for passing small functions like (+2) for a foreach on a container, but this is insanity! O_o
09:50:02 <nikki93> (I mean, boost::lambda, a (hacky) way of getting (not-so-good) lambda functions in C++)
09:50:47 * maltem considers starting off talking about C++ and insanity
09:51:02 * nikki93 laughs
09:51:04 <mm_freak> nikki93: with a little GCC extension, you can get closures to work in (non-standard) C
09:51:24 <mm_freak> nikki93: http://ertes.de/cfact/cfact3.c
09:51:31 <nikki93> But one thing I don't understand is, how can you write 'normal' programs just by evaluating expressions.
09:52:05 <nikki93> Most programs I can think of have their concept 'naturally' (for me at least) translated into command sequences (with loops and 'if' constructs and the usual).
09:52:17 <mm_freak> by treating the program as a computation, which you can build from smaller computations
09:52:53 <nikki93> For example, the IRC client, irssi, I use.
09:52:56 <mm_freak> you'll get that when getting in touch with monads
09:53:08 <nikki93> How would one go about implementing it in haskell (at a very high level)?
09:53:47 <ozy`> nikki93: much of that would be imperative, actually, since it's chiefly an network/IO app
09:53:59 <mauke> heh
09:54:05 <nikki93> ozy`: So we'd be cheating on our functional language and doing imperative in it?
09:54:06 <ozy`> (IO is still mostly imperative in haskell)
09:54:15 <mauke> there's a very nice implementation of irssi's signal system in Haskell :-)
09:54:33 <ozy`> nikki93: not as such. haskell provides an interesting way to separate imperative from functional programming ;)
09:54:47 <nikki93> The monad part of xmonad makes sense now.
09:54:58 <mauke> nikki93: http://mauke.ath.cx/stuff/haskell/how-to-io.html
09:55:04 <nikki93> I thank xmonad for introducing haskell to me. :)
09:55:17 <Raevel> tomorrow it's xmonad time for me
09:55:19 <mm_freak> nikki93: you may want to review and comment my monads tutorial =)
09:55:19 <nikki93> Do you guys use haskell for 'serious' stuff? (not meant as an insult to haskell or anything of any sort)
09:55:51 <Heffalump> nikki93: Haskell is the primary language I use at work
09:56:13 <mauke> depends on your definition of "serious"
09:56:19 <mauke> I've written a bot in it
09:56:22 <nikki93> mm_freak: Umm, not yet. I'm still at a very basic haskell level and the word 'monad' scares me unless you do a (xs) = 'x' : xs to it. ;-)
09:56:46 <chessguy> Heffalump:  what company?
09:56:48 <ehird> mm_freak: did you just say monad tutorial?
09:56:50 <ehird> /facepalm
09:56:52 <Heffalump> chessguy: Credit Suisse
09:56:57 <chessguy> ah
09:57:10 <nikki93> One serious consideration I have for Haskell is using it as a scripting language for computer games.
09:57:24 <nikki93> I write 3d computer games in C++.
09:57:25 <Heffalump> nikki93: I think that'd work really nicely
09:57:30 <mm_freak> nikki93: it's written with beginners in mind, that's why i'm asking youâ¦  i received some feedback, but mainly from people, who don't really need a tutorial anymore =)
09:57:31 <nikki93> www.grall.uni.cc was one of mine.
09:57:43 <mm_freak> ehird: i think so =)
09:57:47 <nikki93> mm_freak: Ok, give me the link, I'll see it. I'm still new to it though.
09:57:55 <nikki93> where it = haskell
09:57:58 <ehird> nikki93: don't :P
09:58:07 <nikki93> ehird: I never said I'd do anything.
09:58:15 <nikki93> ehird: I asked mm_freak to give the link to me.
09:58:15 <ehird> seeing is an action ;)
09:58:20 <ehird> :-)
09:58:22 <ehird> I'm just kidding
09:58:24 <nikki93> Damn I didn't see mah sentence.
09:58:25 <mm_freak> nikki93: http://ertes.de/articles/monads.html
09:58:26 <mm_freak> hehe
09:58:33 * nikki93 fails at reading his own messages
09:58:35 <mauke> monads should be ignored
09:59:02 <ehird> monads should be understood, then you should write a terrible tutorial about them that tries to explain them in the way that you mistakenly think made them clear to you.
09:59:09 <ehird> wait, skip the second part.
09:59:11 <ehird> :D
09:59:12 <nikki93> mauke: Never found any use for 'em till now (although most of what I did now was just math problem solving in haskell (which I've discovered its incredibly good for (no, no more parentheses nesting, sorry) ) ).
09:59:19 <Heffalump> you can write it, just don't publish it
09:59:21 <DrSyzygy> So I guess I'm going to be teaching a course in Category Theory for Computer Science at Stanford in the fall.
09:59:22 <maltem> looking at that game, a labyrinth combinator library sounds like fun
09:59:35 <ozy`> nikki93: people write -games- in haskell. it's not a terribly good scripting language though
10:00:00 <mauke> nikki93: you can write many programs without using "monads"
10:00:03 <chessguy> nikki93:  that game looks hard
10:00:07 <Heffalump> I think it's a good scripting language; type safe composition of primitives.
10:00:11 <nikki93> ozy`: I, unfortunately, like what I do in C++ a lot already. Just would LOVE using haskell for scriptin though.
10:00:21 <wolverian> I'm having serious problems with mueval. it's eating all the memory and taking very long to evaluate simple expressions. this is on GHC 6.10.1. any hints?
10:00:24 <mauke> all you need to understand is a few types that are monads, but understanding monads itself is unimportant
10:00:29 <nikki93> chessguy: I know. I made it insanely hard for anyone human (read: everyone) to play it for some reason.
10:00:37 <mm_freak> nikki93: monads are great, as soon as you understand themâ¦  and it's really not that hardâ¦  the only problem is that they are abstract, so interpreting them correctly is the obstacle you need to climb
10:01:02 <mm_freak> > do x <- [1,2,3]; y <- [4,5,6]; return (x, y, x+y)
10:01:03 <lambdabot>   [(1,4,5),(1,5,6),(1,6,7),(2,4,6),(2,5,7),(2,6,8),(3,4,7),(3,5,8),(3,6,9)]
10:01:06 <nikki93> Y'know, using haskell for scripting would be really cool.
10:01:12 <mauke> there is no obstacle here, which is what makes climbing it hard
10:01:15 <ozy`> it's best to see the type of problem that monads solve before you try to understand monads themselves
10:01:19 <gwern> wolverian: details pls
10:01:28 <wolverian> gwern, what kind of details?
10:01:34 <wolverian> (or, how to produce them :)
10:01:39 <RafaelGCPP> nikki93: some guys pointed me to Phillip Wadler's paper... It is a good "how to use monads" tutorial
10:01:42 <mm_freak> ozy`: that's not easy, because they solve a number of seemingly unrelated problems
10:01:48 <gwern> wolverian: dunno, what options are you using, how long is too long, where did you install from, etc.
10:01:55 <ozy`> nikki93: the only problem being that embedding either a compiler or an interpreter in your program wouldn't be... well.... stuff.
10:01:58 <maltem> Fwiw, to me "understanding monads" means just to understand Haskell types and type classes, really
10:02:04 <nikki93> let createPlayers x = if (x > -5) then createPlayerAtPosition(x,10) + createPlayers (x - 1) else 0 in createPlayers(5)
10:02:31 <nikki93> ozy`: I've embedded squirrel.
10:02:33 <mm_freak> maltem: and understanding what 'generalizing functionality' is and what it can give you
10:02:35 <nikki93> ozy`: Was fun, got bored.
10:02:38 <nikki93> ozy`: :P
10:02:49 <ozy`> nikki93: never heard of it
10:02:52 * ozy` googless
10:02:52 <maltem> mm_freak: I think that belongs to type classes
10:02:53 <gwern> wolverian: how well does do the mueval tests do, etc
10:02:54 <wolverian> gwern, darcs version, evaluating 1+1 takes 5 seconds (though the result is output in about two seconds, but the process exits in 5), no special options
10:02:59 <wolverian> it has tests?! :)
10:03:10 <nikki93> ozy`: Squirrel is incredibly easy to embed.
10:03:14 <wolverian> ah, trying.
10:03:16 <gwern> wolverian: no, I just put a tests.sh in the repo to fool people
10:03:22 <wolverian> :]
10:03:22 <ozy`> nikki93: haskell isn't.
10:03:26 <nikki93> But incredibly old and boring (like most languages) compared to haskell.
10:03:40 <wolverian> running them now.
10:03:41 <nikki93> ozy`: Ahh you're just lazy. I'll do it. You can watch. :P
10:03:43 <Botje> @fac can Haskell be old and boring?
10:03:43 <lambdabot> Maybe you meant: fact fact-cons fact-delete fact-set fact-snoc fact-update faq
10:03:47 <Botje> @faq can Haskell be old and boring?
10:03:47 <lambdabot> The answer is: Yes! Haskell can do that.
10:03:49 <ozy`> http://squirrel-lang.org/ <== this the one you mean?
10:03:50 <vixey> ozy`, are you saying this out of experience or extrapolation?
10:04:00 <nikki93> lambdabot: I'm laughing at you.
10:04:13 <ozy`> vixey: proof by induction, my dear watson
10:04:26 <vixey> no straight answer then..
10:04:28 <wolverian> gwern, the tests are not quite as slow.
10:04:51 <wolverian> which is rather strange.
10:04:52 <wolverian> hmm.
10:04:54 <nikki93> > let haha n = if (x > 0) then "ah" ++ haha (n - 1) else "a!" in "H" ++ haha (20)
10:04:56 <lambdabot>   "Hahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahaha...
10:05:01 <nikki93> > let haha n = if (x > 0) then "ah" ++ haha (n - 1) else "a!" in "H" ++ haha (10)
10:05:03 <lambdabot>   "Hahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahaha...
10:05:04 <chessguy> @fact-snoc
10:05:04 <lambdabot> I can not handle empty facts.
10:05:14 <gwern> wolverian: try running manually with --inferred-type
10:05:21 <nikki93> > let haha n = if (x > 0) then "ah" ++ haha (n - 1) else "a!" in "H" ++ haha (2)
10:05:23 <lambdabot>   "Hahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahaha...
10:05:27 <wolverian> running individual tests manually?
10:05:30 <mauke> > cycle "ha"
10:05:31 <lambdabot>   "hahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahaha...
10:05:32 <vixey> nikki93, it looked terribly easy to embed haskell to me, not that I have tried it.. but I imagine most don't because they are purists
10:05:39 <mm_freak> > "Ha" ++ cycle "ha"
10:05:41 <lambdabot>   "Hahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahaha...
10:05:48 <nikki93> No, I want finit has.
10:05:50 <gwern> wolverian: it's possible printing inferred types is doing some forcing or something; just curious
10:06:00 <Botje> nikki93: you're comparing x against 0 but the parameter is called n :)
10:06:05 <wolverian> I stopped the test suite now, it was taking its time :)
10:06:14 <nikki93> > let haha n = if (n > 0) then "ah" ++ haha (n - 1) else "a!" in "H" ++ haha (2)
10:06:17 <Botje> normally haskell would warn about that, but lambdabot has some silly defaults
10:06:18 <lambdabot>   "Hahaha!"
10:06:21 <nikki93> > let haha n = if (n > 0) then "ah" ++ haha (n - 1) else "a!" in "H" ++ haha (5)
10:06:22 <lambdabot>   "Hahahahahaha!"
10:06:27 <nikki93> lol Botje what a fun mistake. :P
10:06:39 <ozy`> > let haha n | n > 0 = "ah" ++ haha (n - 1); haha n = "a!" in 'H' : haha 2
10:06:40 <lambdabot>   "Hahaha!"
10:06:41 <wolverian> no diff between -i and without it
10:06:42 <wolverian> hmm
10:06:42 <mjb> > take 10 ("Ha" ++ cycle "ha")
10:06:43 <nikki93> Haskell FTFW for writing 'beautiful' programs.
10:06:43 <lambdabot>   "Hahahahaha"
10:06:58 <nikki93> cycle!!1 "Ha"
10:07:02 <nikki93> > cycle!!1 "Ha"
10:07:04 <lambdabot>   Couldn't match expected type `[a]'
10:07:17 <nikki93> > (cycle "Ha")!!5
10:07:18 <lambdabot>   'a'
10:07:23 <RafaelGCPP> nikki93: Hahahaha :-P
10:07:23 * nikki93 sucks
10:07:40 <mm_freak> > let 2 + 2 = 5 in 2 + 2
10:07:41 <lambdabot>   5
10:07:50 <ozy`> (!! 5) . cycle $ "Ha"
10:07:56 <ozy`> gah
10:07:57 <nikki93> Haskell can divide by zero!
10:07:59 <ozy`> > (!! 5) . cycle $ "Ha"
10:08:01 <lambdabot>   'a'
10:08:10 <RafaelGCPP> > let 1/0=100 in 1/0
10:08:11 <lambdabot>   100
10:08:14 <nikki93> > let 1 / 0 = 7 in 1 / 0
10:08:16 <lambdabot>   7
10:08:19 <nikki93> lolation.
10:08:21 <mauke> > 1/0
10:08:23 <lambdabot>   Infinity
10:08:23 <nikki93> Haskell FTFW
10:08:31 <wolverian> gwern, want some profiling info?
10:08:34 <RafaelGCPP> > let a+b= 10 in a+b
10:08:35 <lambdabot>   10
10:08:41 <dcoutts> @seen bos
10:08:41 <dublpaws> > Infinity + 123
10:08:41 <lambdabot> bos is in #ghc and #haskell. I don't know when bos last spoke.
10:08:43 <lambdabot>   Not in scope: data constructor `Infinity'
10:08:48 <nikki93> > let a + b = 10 in a
10:08:50 <lambdabot>   a
10:08:54 <vixey> > infinite + 123
10:08:54 <mm_freak> > 1/0 + 123
10:08:54 <nikki93> > let a + b = 10 in x
10:08:55 <lambdabot>   Not in scope: `infinite'
10:08:56 <lambdabot>   Infinity
10:08:56 <lambdabot>   x
10:08:58 <vixey> > infinity + 123
10:09:00 <lambdabot>   * Exception: stack overflow
10:09:04 <ozy`> > let 1 / 0 = "pizza" in 1 / 2
10:09:05 <lambdabot>   "* Exception: /tmp/433827886262055677:71:52-66: Non-exhaustive patterns in ...
10:09:09 <mm_freak> :t x
10:09:10 <lambdabot> Expr
10:09:31 <ozy`> :t unfoldr
10:09:32 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
10:09:58 <nikki93> mm_freak: Your tutorial is the most boring in the world.
10:10:00 <nikki93> mm_freak: It sucks.
10:10:12 <nikki93> mm_freak: ;-)
10:10:18 <dublpaws> > fold space time | grep timelord
10:10:19 <mm_freak> nikki93: great ;)
10:10:19 <lambdabot>   <no location info>: parse error on input `|'
10:10:54 <gwern> dublpaws: is that a left fold or right?
10:10:56 <mm_freak> nikki93: if it's boring, at least you understand it ;)
10:11:22 <dublpaws> gwern: depends the direction of time travel
10:11:29 <nikki93> mm_freak: Hey no bad feelings. Its nice.
10:11:39 <ozy`> > foldl space time >> grep "timelord"
10:11:40 <lambdabot>   Not in scope: `time'Not in scope: `grep'
10:11:48 <mm_freak> nikki93: i've got that =)
10:11:50 <ozy`> damn = ey
10:11:52 <ozy`> *key
10:11:54 <nikki93> Show me some cool code
10:12:02 <nikki93> Some really cool stuff.
10:12:09 <nikki93> I've seen cool C++, Perl, Python code.
10:12:17 <ozy`> @src map
10:12:17 <lambdabot> map _ []     = []
10:12:17 <lambdabot> map f (x:xs) = f x : map f xs
10:12:26 <nikki93> Haskell is awesome, most things I've seen are 'cool'.
10:12:29 <ozy`> damn, the naive definition
10:12:35 <nikki93> Cool haskell code must be even better. :P
10:12:36 <gwern> wolverian: ok, I've tried implementing something with waitForProcess
10:12:55 <ozy`> nikki93: http://www.willamette.edu/~fruehr/haskell/evolution.html
10:13:49 <mm_freak> > mapM (\x > mapM (\x -> [x-1, x+1]) [1,3,5]
10:13:50 <lambdabot>   <no location info>: parse error on input `>'
10:13:50 <mm_freak> > mapM (\x -> [x-1, x+1]) [1,3,5]
10:13:51 <lambdabot>   [[0,2,4],[0,2,6],[0,4,4],[0,4,6],[2,2,4],[2,2,6],[2,4,4],[2,4,6]]
10:14:01 <gwern> wolverian: incidentally, how are you profiling? a profiled mueval breaks on 6.10 for me
10:14:22 <mm_freak> > sequence ["you", "suck", "bad"]
10:14:23 <lambdabot>   ["ysb","ysa","ysd","yub","yua","yud","ycb","yca","ycd","ykb","yka","ykd","o...
10:14:34 <gwern> wolverian: pushed
10:14:39 <mm_freak> > sequence ["you", "suck"]
10:14:40 <lambdabot>   ["ys","yu","yc","yk","os","ou","oc","ok","us","uu","uc","uk"]
10:15:01 <wolverian> gwern, let's see
10:15:14 <mm_freak> > fix (\k x y -> x : k y (x+y)) 0 1
10:15:16 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:15:46 <wolverian> gwern, I haven't tried profiling it yet.
10:16:02 <nikki93> > zip "you" "suck"
10:16:03 <lambdabot>   [('y','s'),('o','u'),('u','c')]
10:17:01 <mm_freak> nikki93: 'sequence' takes a list of monadic computations and returns a list of the respective results
10:17:01 <roderyk> xunpickleVal xpRect >>> arr (\(Rect w h _ _) -> show (w * h)) >>> \s -> mkelem s [] []
10:17:17 <wolverian> gwern, ! much better now
10:17:20 <ozy`> > concat $ zipWith (\x y -> [x,y]) "you" "suck"
10:17:21 <lambdabot>   "ysouuc"
10:17:23 <roderyk> type issues with that last part, how do I feed the string to the mkelem correctly?
10:17:24 <wolverian> gwern, -e'1+1' takes 1.2 s now
10:17:29 <wolverian> gwern, (on a rather slow computer)
10:17:31 <mm_freak> > sequence [return 1, return 2, return 3] :: [[Int]]
10:17:32 <lambdabot>   [[1,2,3]]
10:17:38 <ozy`> > [,] 'x' 'y'
10:17:39 <lambdabot>   <no location info>: parse error on input `,'
10:17:42 <ozy`> damn
10:18:02 <mm_freak> > sequence [[10], [20], [30]]
10:18:03 <gwern> wolverian: yes, it was always sleeping 5s before because I hadn't figured out how to use waitForProcess safely
10:18:04 <lambdabot>   [[10,20,30]]
10:18:12 <mm_freak> > sequence [[10,11], [20,21], [30]]
10:18:13 <nikki93> mm_freak: Shaddup. :P
10:18:13 <lambdabot>   [[10,20,30],[10,21,30],[11,20,30],[11,21,30]]
10:18:20 <wolverian> gwern, ah.
10:18:22 <gwern> wolverian: it'll probably be a tad faster on subsequent invocations and if you run with multiple OS threads
10:18:22 <wolverian> gwern, thanks.
10:18:37 <nikki93> @help sequence
10:18:38 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:18:40 <wolverian> gwern, do I need to call it with +RTS -N2 -RTS? lambdabot doesn't.
10:18:56 <nikki93> @help help
10:18:57 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:18:59 <ozy`> :t sequence
10:19:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:19:01 <nikki93> @list
10:19:02 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:19:02 <gwern> wolverian: you don't need to, since I added a process level watchdog, but I think it might make it a little faster as I said
10:19:08 <gwern> I haven't actually tried tho
10:19:21 <wolverian> okay.
10:19:25 <wolverian> well, it seems to work okay now.
10:19:26 <ozy`> @src sequence
10:19:26 <lambdabot> sequence []     = return []
10:19:26 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:19:26 <lambdabot> --OR
10:19:26 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
10:19:54 <nikki93> I wont' get what sequence means for a while. :P
10:20:02 <beelsebob> oh, *didn't realise sequence only needed an applicative*
10:20:13 <wolverian> gwern, thanks a lot.
10:20:23 <beelsebob> why is it not rewritten foldr (liftA2 (:)) (pure [])
10:20:27 <beelsebob> so we can use it more generally
10:20:48 <ozy`> beelsebob: because the author of that function was a butthead
10:20:51 <mm_freak> sequence [a, b, c] = do x <- a; y <- b; z <- c; return [x,y,z]
10:20:59 <beelsebob> mm_freak: ?
10:21:10 <mm_freak> > sequence [[1,2], [3,4], [5,6]]
10:21:11 <lambdabot>   [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
10:21:18 <beelsebob> mm_freak: ?
10:21:23 <beelsebob> I don't see what you're saying?
10:21:32 <mm_freak> > do x <- [1,2]; y <- [3,4]; z <- [5,6]; return [x,y,z]
10:21:33 <lambdabot>   [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
10:21:35 <mm_freak> beelsebob: ?
10:21:41 <ozy`> beelsebob: isn't there a sequenceA or something somewhere?
10:22:08 <beelsebob> ozy`: I dunno, but that really does need to be rewritten for applicative always
10:22:31 <ski_> > sequence [[1,2],[3,4],[5,6]]
10:22:32 <lambdabot>   [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
10:22:36 <beelsebob> it would be another step in the forcing of everyone to actually write applicative and functor instances ;)
10:23:01 <nikki93> > let concatenate x = foldr (++) [] x in concatenate ["This ", "is ", "a ", "sentence!"]
10:23:01 <roderyk> xunpickleVal xpRect >>> arr (\(Rect w h _ _) -> show (w * h)) >>> \s -> mkelem s [] []  -- getting XmlFilter -> a n XmlFilter (at the end), instead of XmlFilter -> XmlFilter. Any suggestions on how to "lift" this?
10:23:02 <lambdabot>   "This is a sentence!"
10:23:09 <roderyk> Saizan_: ^^ maybe you could help? :)
10:23:11 <CakeProphet> > unsafePerformIO do {when (2==3) (return "lol"); when (3==3) (return "olol")}
10:23:14 <lambdabot>   <no location info>: parse error on input `do'
10:23:14 <ozy`> beelsebob: go to the HaskellPrime wiki and start smacking people with a proposal
10:23:16 <importantshock> oh lambdabot, you are so earnestly correct.
10:23:16 <smarmy> beelsebob: check out Traversable
10:23:22 <beelsebob> ozy`: I will do :)
10:23:23 <mm_freak> beelsebob: well, i'm not from the applicative functor sect =)
10:23:24 <CakeProphet> > unsafePerformIO (do {when (2==3) (return "lol"); when (3==3) (return "olol")})
10:23:25 <lambdabot>   Not in scope: `unsafePerformIO'
10:23:29 <nikki93> concatenate x = foldr (++) [] x is the right way to implement concatenate? (I know about concat, but asking)
10:23:30 <ski_> > Data.Traversable.sequenceA [[1,2],[3,4],[5,6]]
10:23:31 <lambdabot>   [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
10:23:32 <nikki93> @src concat
10:23:33 <lambdabot> concat = foldr (++) []
10:23:59 <mm_freak> i think, if something is a monad, you can just as well use its monadic properties, even if Applicative features would suffice
10:24:00 <CakeProphet> @hoogle unsafePerformIO
10:24:00 <lambdabot> Foreign unsafePerformIO :: IO a -> a
10:24:00 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
10:24:16 <beelsebob> mm_freak: yeh, but sequence *doesn't need* a monad
10:24:28 <beelsebob> i.e. sequence still works on applicatives that aren't monads
10:24:32 <beelsebob> it's type is overly restrictive
10:24:50 <CakeProphet> > System.IO.Unsafe.unsafePerformIO (do {when (2==3) (putStrLn "lol"); when (3==3) (putStrLn "olol")})
10:24:52 <lambdabot>   /tmp/5267838812153996381:70:48:
10:24:52 <lambdabot>      Not in scope: `System.IO.Unsafe.unsafe...
10:24:56 <CakeProphet> :(
10:25:00 <Elly> lambdabot does not have System.IO loaded
10:25:14 <mm_freak> beelsebob: that's true, but that's a flaw in haskell's base libs
10:25:17 <CakeProphet> so I can't extract IO actions with lambdabot at all?
10:25:20 <beelsebob> mm_freak: indeed :)
10:25:28 * beelsebob bimbles over to the haskell-prime list to moan
10:25:47 <smarmy> beelsebob: map is the same case.  map -> fmap as sequence -> sequenceA.  it's there, just not in the prelude
10:25:57 <mm_freak> beelsebob: and there is no nice syntactic sugar for Applicative =)
10:26:21 <beelsebob> mm_freak: sure there is â the operations it provides â what there's no nice syntactic sugar for is monads
10:26:29 <CakeProphet> basically I'm trying to figure out if you can string together whens.
10:26:33 <beelsebob> there's only a nasty one that enforces this lie that monads sequence things
10:26:59 <mm_freak> beelsebob: other than the 'do' keyword, IMO there is nothing wrong with it
10:27:06 <mm_freak> the 'do' is misleading, but that's it
10:27:38 <mm_freak> > when True $ when True $ when True $ [1]
10:27:39 <lambdabot>       No instance for (Num ())
10:27:39 <lambdabot>        arising from the literal `1' at <intera...
10:27:41 <beelsebob> mm_freak: it still requires a very sequential definition of what to be, I'm not certain that there's a better one though
10:27:43 <mm_freak> uhm
10:27:47 <mm_freak> > when True $ when True $ when True $ [(), (), ()]
10:27:49 <lambdabot>   [(),(),()]
10:27:50 <smarmy> beelsebob: in what way are applicatives expressed more cleanly than monads?
10:27:54 <mm_freak> > when True $ when True $ when False $ [(), (), ()]
10:27:55 <lambdabot>   [()]
10:28:41 <mm_freak> beelsebob: you need to write statements one after another anyway, be it sugared or not
10:28:43 <beelsebob> smarmy: applicatives use the same style as the rest of haskell
10:28:46 <CakeProphet> I guess I'll just make If versions of all my when functions.
10:28:47 <beelsebob> you apply one thing to another thing
10:28:58 <Heffalump> beelsebob: in what way do monads not sequence things? Even applicatives define an ordering, they just hide it better.
10:28:58 <beelsebob> it just so happens that the things you're applying aren't always functions now though
10:29:23 <beelsebob> Heffalump: yes, but the ordering that monads define is not the ordering that the do notation shows you
10:29:24 <smarmy> beelsebob: monadic operations can be expressed similarly.  just look at 'ap'
10:29:33 <mm_freak> beelsebob: it is
10:29:36 <Heffalump> well, the dataflow order is
10:29:38 <beelsebob> Heffalump: as evidenced by people getting confused by lazy IO not always happening the way they expect
10:29:52 <beelsebob> smarmy: yes â that's because all monads are applicatives
10:29:52 <nikki93> takeWhile' f (x:xs) = if (f x) then x : (takeWhile' f xs) else []
10:29:52 <nikki93> takeWhile' _ _ = []
10:29:56 <beelsebob> ap is an applicative operator smarmy
10:29:58 <mm_freak> > do x <- [1,2,3]; y <- [4,5,6]; return (x,y)
10:29:59 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
10:30:08 <mm_freak> > liftM2 (,) [1,2,3] [4,5,6]
10:30:10 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
10:30:15 <mm_freak> > liftM2 (,) [4,5,6] [1,2,3]
10:30:16 <lambdabot>   [(4,1),(4,2),(4,3),(5,1),(5,2),(5,3),(6,1),(6,2),(6,3)]
10:30:28 <smarmy> beelsebob: agreed.  so you're just saying the extra power beyond applicatives that monads provide is ugly?
10:30:29 <Heffalump> well, the >>= implementation doesn't have to use the ordering, that's true
10:30:36 <Heffalump> but the interface clearly requires the user to select one
10:30:44 <beelsebob> smarmy: no, I'm saying that the syntactic sugar for monads is ugly
10:30:45 <Heffalump> but the same is true of applicative!
10:31:00 <mm_freak> Heffalump: yes, and that's natural
10:31:11 <beelsebob> Heffalump: yes â but applicative doesn't have a syntactic sugar that implies that there is an ordering
10:31:11 <smarmy> beelsebob: ah.  we're just arguing over do.  got it
10:31:12 <mm_freak> just as natural as you need to choose the order, in which you give functions arguments
10:31:21 <beelsebob> smarmy: indeed :)
10:31:27 <smarmy> beelsebob: ;)
10:31:34 <mm_freak> and just as there are commutative functions, there are commutative monads
10:31:43 <CakeProphet> basically this argument boils down to a simple truth: Emacs is superior to monads /and/ applicatives.
10:31:49 <DrSyzygy> ...
10:31:54 <Heffalump> but giving applicative arguments is rather more order-defining than giving normal functions arguments
10:32:02 <Heffalump> because the order of "evaluation" actually matters
10:32:06 <beelsebob> CakeProphet: lol
10:32:08 <smarmy> CakeProphet: right. and vi is superior to emacs.  glad we settled that
10:32:14 <beelsebob> Heffalump: is it?
10:32:15 <beelsebob> why?
10:32:23 <CakeProphet> swarmy ...no no no.
10:32:36 * smarmy ducks fire
10:32:38 <Heffalump> @type <$>
10:32:39 <lambdabot> parse error on input `<$>'
10:32:42 <Heffalump> @type (<$>)
10:32:42 <int80_h> I thought everyone already knew about vi's superiority
10:32:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:32:47 <CakeProphet> emacs can play Quake. There is no quake mode for vi.
10:32:51 <Heffalump> @type (<*>)
10:32:53 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
10:33:02 <smarmy> CakeProphet: lol.  point
10:33:14 <CakeProphet> emacs can also be Windows. We all knows the benefits of that.
10:33:28 <smarmy> CakeProphet: hmm... i think you just took a step backwards with that one
10:33:29 <int80_h> vi is true to the original design philosophy of unix "one utility does one thing"
10:33:32 <Heffalump> pure f <*> x <*> y  is not equal to pure (flip f) <*> y <*> x for all applicatives
10:33:50 <nikki93> How do I tell foldl to stop iterating from my step function?
10:34:02 <Heffalump> nikki93: you can't
10:34:05 <Heffalump> only foldr can be stopped
10:34:07 <smarmy> int80_h: and then 90 million other things as it evolved
10:34:17 <nikki93> Ok, how to stop foldr?
10:34:17 <Heffalump> @src foldl
10:34:21 <lambdabot> foldl f z []     = z
10:34:22 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:34:25 <Heffalump> just make your step function not use its second parameter
10:34:31 <int80_h> smarmy: I think yer thinking of *gasp* perl.
10:34:45 <smarmy> int80_h: oh right... ;)
10:34:55 <Heffalump> e.g. f x e = if x == 0 then 0 else e + 1
10:34:57 * int80_h remembers when perl did one thing really well.
10:34:57 <nikki93> takeWhile' f xs = foldr (\xs x -> if f x then xs ++ [x] else xs) [] xs
10:34:57 <nikki93> takeWhile' _ _ = []
10:35:02 <nikki93> Is that right?
10:35:15 <mauke> oh god wtf
10:35:17 <Heffalump> does it typecheck?
10:35:23 <nikki93> (I know its in Prelude but still)
10:35:26 <nikki93> Heffalump: no
10:35:29 <Heffalump> then no :-)
10:35:46 <Heffalump> and it doesn't ignore its second argument
10:35:47 <beelsebob> smarmy: actually â I have one other complaint about monads in Haskell â (>>=) shouldn't be one of the basic operators, it should be (=<<) -- (a -> m b) -> (m a -> m b) is a much nicer type signature
10:35:47 <mauke> that looks more like a filter
10:35:51 <Heffalump> because of the f x test
10:36:01 <nikki93> :t takeWhile
10:36:02 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
10:36:06 <nikki93> mauke: I know. :(
10:36:19 <nikki93> mauke: I'll figure out how to stop iterating mysself though, shh
10:36:51 <mm_freak> > let takeWhile' = fix $ \k p (x:xs) -> if p then x : k p xs else [] in takeWhile' even [2,4,6,7,8]
10:36:52 <lambdabot>   Couldn't match expected type `Bool'
10:36:58 <smarmy> beelsebob: sort of.  except if you were to actually use it as a function transformer, it'd be (f =<<) which is ugly
10:36:59 <mm_freak> > let takeWhile' = fix $ \k p (x:xs) -> if p x then x : k p xs else [] in takeWhile' even [2,4,6,7,8]
10:37:00 <lambdabot>   [2,4,6]
10:37:16 <mm_freak> sorry, i'm being evil again
10:37:17 <beelsebob> smarmy: true
10:37:27 <beelsebob> so maybe it should be called bind too
10:37:31 <beelsebob> (bind f) is much nicer
10:38:16 <RafaelGCPP> the whole idea on >>= is to indicate some kind of sequence
10:38:26 <beelsebob> yes â and that's stupid
10:38:30 <RafaelGCPP> (do something) >>= (filter and do another thing)
10:38:32 <smarmy> beelsebob: for the record, i like >>= and do
10:38:32 <beelsebob> because monads are not about sequencing
10:38:45 <beelsebob> (not always at least)
10:38:48 <dons> ?users
10:38:48 <lambdabot> Maximum users seen in #haskell: 647, currently: 645 (99.7%), active: 22 (3.4%)
10:38:50 <nikki93> takeWhile' :: (a -> Bool) -> [a] -> [a]
10:38:50 <nikki93> takeWhile' f xs = foldr (\xs x -> if f x then xs ++ [x] else xs) [] xs
10:38:50 <nikki93> takeWhile' _ _ = []
10:38:54 <nikki93> Fix it or I'll shoot.
10:39:02 <mm_freak> beelsebob: i like >>=, too
10:39:03 <int80_h> nikk193: have you worked through a tutorial yet?
10:39:12 <nikki93> int80_h: Have. ;-)
10:39:15 <nikki93> int80_h: Doing RWH.
10:39:17 <mm_freak> getArgs >>= mapM_ print
10:39:20 <Heffalump> most monads are actually about sequencing
10:39:28 <Heffalump> e.g. state, exceptions
10:39:30 <mm_freak> in a sense, it's flip (.) for monads
10:39:32 <smarmy> beelsebob: no, but there is a nice natural ordering to composition that >>= expresses nicely, and in 90% of the monadic use haskellers are involved in, it works
10:39:34 <int80_h> nikki93: nice! I'm working out the final exercise in chapter 3
10:39:55 <mm_freak> only few monads are commutative, like Reader
10:40:08 <mm_freak> so we actually _want_ sequencing
10:40:12 <nikki93> int80_h: I'm chapter 4, near end.
10:40:19 <Heffalump> but having better syntax for commutative monads would definitely be nice
10:40:24 <beelsebob> smarmy: that's actually mostly why I don't like it â 90% of the monadic use haskellers are involved in is hiding imperative programming, because they didn't think hard enough
10:40:26 <nikki93> int80_h: But I'm doing a LOT of my own stuff and stuff from Project Euler.
10:40:29 <beelsebob> 80% rather
10:40:34 <beelsebob> 10% of it really needed to be imperative
10:40:43 <smarmy> beelsebob: and truthfully, a lot of programming is about sequential code, and having a way of expressing that helps haskell be a bit more grounded in reality
10:40:50 <mm_freak> Heffalump: how would you improve it?  you _need_ to write text sequentially anyway, the same holds for source code
10:40:53 * Heffalump requests beelsebob link to some code that demonstrates his point
10:41:02 <beelsebob> Heffalump: parsec
10:41:03 <beelsebob> ;)
10:41:17 <beelsebob> parsec could be entirely applicative
10:41:22 <mm_freak> so there is NOTHING you could do about itâ¦  you need to mention computations in a certain order
10:41:22 <beelsebob> and in fact comes out much nicer if it is
10:41:27 <Heffalump> in what way is sequencing not appropriate there? You have to decide what order to process the data.
10:41:34 <mm_freak> it's a fact that source code doesn't support superpositions
10:41:36 <Heffalump> Applicative still implies an ordering!
10:41:37 <int80_h> nikki93: Project Euler is a great idea. I'm holding off until after chapter 4 though
10:41:50 <beelsebob> Heffalump: sure, doesn't stop the code being way nicer
10:41:58 <beelsebob> and not implying ordering anywhere near as much
10:42:08 <Heffalump> mm_freak: but some ways of writing it don't imply ordering nearly as much :-)
10:42:16 <mm_freak> for example?
10:42:28 <Heffalump> well, as beelsebob says, applicative syntax is better that way
10:42:56 <mm_freak> do x <- asks something; y <- asks somethingElse
10:43:02 <mm_freak> how could you improve this?
10:43:26 <Heffalump> let x = something ; y = somethingElse really is commutative, because you can switch the x and y bindings without changing the meaning
10:43:30 <Heffalump> and people know this
10:43:36 <Heffalump> or should know it
10:43:53 <Heffalump> whereas with do notation there's no such guarantee, so people understand there to be a sequence whether it's present or not
10:44:04 <mm_freak> indeed
10:44:42 <beelsebob> of note, there are in limited cases examples of syntactic sugars for monads that don't imply the ordering
10:44:46 <beelsebob> e.g. monad comprehensions
10:45:02 <mm_freak> monad comprehensions don't?
10:45:09 <mm_freak> well, they aren't standard anymore anyway
10:45:11 <Heffalump> except that those are just as order-sensitive as do-notation...
10:45:11 <mm_freak> for whatever reason
10:45:12 <beelsebob> no :(
10:45:14 <RafaelGCPP> >>= don`t really need to be sequential
10:45:15 <Heffalump> (and indeed applicative)
10:45:23 <beelsebob> RafaelGCPP: exactly
10:45:32 <beelsebob> yet the name of it implies that it is
10:45:39 <beelsebob> and the do notation
10:45:42 <RafaelGCPP> wadler's paper has a *' operator that is parallel
10:45:53 <mm_freak> because it _might_ be and usually is
10:46:10 <mm_freak> >>= looks natural for most monads
10:46:12 <beelsebob> mm_freak: yeh, which is much like the thread on Haskell cafe recently about calling monoid Appendable instead
10:46:26 <mm_freak> yeah
10:46:27 <beelsebob> lets call it appendable, becasue that's what it means most times
10:46:59 <mm_freak> well, many things are named with similar motivations
10:47:09 <RafaelGCPP> ihmo the 'star'notation is pretty good
10:47:26 <ski_> RafaelGCPP : what's its type ?
10:47:39 <nikki93> Oh my God... Discovery again.
10:47:39 <mm_freak> well, i still like the >>=, because if the monad is commutative, then it's simply that >>= is the same as =<<
10:47:49 <Heffalump> @type (=<<)
10:47:51 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
10:47:53 <ski_> mm_freak : huh ?
10:47:56 <Heffalump> mm_freak: huh ?
10:47:58 <nikki93> Pass an argument to a function that takes more than one, and get a function that's 'partially done' that you can use later
10:48:02 <mm_freak> uhmâ¦  not the same
10:48:03 <Heffalump> @type (<<)
10:48:04 <lambdabot> Not in scope: `<<'
10:48:08 <nikki93> Ultimate functionexploitingness.
10:48:17 <PeakerWork> @let x<<y = y>>x
10:48:18 <lambdabot>  Defined.
10:48:20 <PeakerWork> @type (<<)
10:48:21 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m b -> m a -> m b
10:48:27 <mm_freak> but describing the same sequencing:  namely none =)
10:48:34 <mm_freak> however, i gotta go now, have fun
10:48:36 <Heffalump> PeakerWork: thank you for that :-)
10:48:40 <roconnor> in a commutative monad do x<- foo; y<-bar;return (x,y)  is the same as do y <-bar; x<-foo; return (x,y)
10:49:03 <Heffalump> flip (liftM2 (,)) == liftM2 (flip (,))
10:49:11 <roconnor> ya
10:49:14 <roconnor> what Heffalump said
10:49:30 <Heffalump> in fact that's probably true for any f
10:49:34 <Heffalump> so flip . liftM2 = liftM2 . flip
10:49:34 <PeakerWork> Maybe we need cummutative Applicative and Monad classes? :)
10:50:06 <roconnor> PeakerWork: they wouldn't have any new methods, but they could be useful for documentation purposes
10:50:11 <beelsebob> PeakerWork: or more specifically â a non-commutative monad class, and do notation only working for that
10:50:12 <roconnor> so I wouldn't be opposed
10:50:23 <ski_> PeakerWork : might be nice .. but are there any specific operations associated ? or just more guarantees ?
10:50:27 <nikki93> > map (dropWhile (== 'x')) ["asaxaxaxa", "aaaasdaxaxa", "asdiwufasdiaxasduaisd"]
10:50:29 <lambdabot>   ["asaxaxaxa","aaaasdaxaxa","asdiwufasdiaxasduaisd"]
10:50:40 <nikki93> > map (dropWhile (/= 'x')) ["asaxaxaxa", "aaaasdaxaxa", "asdiwufasdiaxasduaisd"]
10:50:42 <lambdabot>   ["xaxaxa","xaxa","xasduaisd"]
10:50:42 <ski_> beelsebob : noo
10:50:49 <PeakerWork> (>>=) implies its non-cummutative, you'd need to only have (>>) in which case you're just Applicative
10:50:55 * beelsebob giggles at ski_
10:51:03 <beelsebob> I thought that one would prove contentios
10:51:13 <PeakerWork> @type liftA2 (flip const)
10:51:15 <lambdabot> forall b a (f :: * -> *). (Applicative f) => f a -> f b -> f b
10:51:22 <PeakerWork> (>>) is Applicative ..
10:51:34 <ozy`> > map (filter (/= 'x')) ["asaxaxaxa", "aaaasdaxaxa", "asdiwufasdiaxasduaisd"]
10:51:35 <lambdabot>   ["asaaaa","aaaasdaaa","asdiwufasdiaasduaisd"]
10:51:55 <PeakerWork> beelsebob, roconnor, ski_: Monads cannot really be cummutative, only Applicatives
10:51:57 <Arnar> hi all
10:52:06 <RafaelGCPP> gotta go...
10:52:09 <RafaelGCPP>  /leave
10:52:16 <beelsebob> PeakerWork: sounds believable
10:52:20 <Arnar> do you guys know of any functional languages / compilers for the low end PIC microprocessors (i.e those with only about 20 instructions)
10:52:26 <beelsebob> PeakerWork: so what about the list monad?
10:52:27 <Heffalump> monads can be commutative
10:52:28 <PeakerWork> m a -> (a -> m b) -> m b -- totally dictates order
10:52:30 <beelsebob> that's commutative isn't it?
10:52:40 <ski_> (PeakerWork : but monads are applicative functors .. but, yes, it would probably be better to specify this at the applicative level)
10:52:44 <Heffalump> the law roconnor and I stated is precisely what makes them commutative
10:52:45 <beelsebob> PeakerWork: no it doesn't
10:52:48 <int80_h> sweet, I think my sort-by-tangent function works. Have to check the math
10:52:52 <PeakerWork> beelsebob: why not?
10:52:54 <augustss> PeakerWork: order of what?
10:53:01 <beelsebob> PeakerWork: because it doesn't specify any evaluation order at all
10:53:04 <Heffalump> beelsebob: it's commutative if you don't care about the order in the result list
10:53:12 <PeakerWork> beelsebob: oh, not evaluation order, dependency order
10:53:13 <ski_> augustss : dependence of the `b' on the `a'
10:53:30 <beelsebob> PeakerWork: still, dependancy order can be non-commutative too
10:53:38 <augustss> ski_: a potential dependence
10:53:44 <PeakerWork> you can't have the "m a" and "m b" effects be switched, because the "m b" effect requires the "a" as input. Only if "a" is discarded it is possible
10:53:46 <ski_> augustss : agreed
10:53:59 <beelsebob> PeakerWork: it doesn't say that the b *is* dependant on the a
10:54:01 <beelsebob> it says it could be
10:54:06 <augustss> ski_: of the same kind as  a -> (a->b) -> b
10:54:08 <PeakerWork> beelsebob: right, when it is
10:54:16 <ski_> (in the same was as a function of type `A -> B' might really be `const b' for some `b :: B')
10:54:18 <PeakerWork> beelsebob: if its not, you're just using Applicative, or (>>), not (>>=)
10:54:19 <Heffalump> when it is, you can't make use of commutativity.
10:54:23 <Heffalump> When it isn't, you can.
10:54:53 <Heffalump> but the monad can still be commutative
10:55:03 <PeakerWork> [1,2,3] >>= (\x -> [x])      surely [x] cannot be on the left instead of [1,2,3]
10:55:09 <beelsebob> PeakerWork: so x <- Just 5; y <- Just 3; return (x,y) can't be rewritten with the binds the other way round?
10:55:41 <PeakerWork> beelsebob: I see what you did there :-)  Yeah, the action doesn't need to fully discard it, only part of the action needs to
10:55:45 * Heffalump has to leave this enthralling discussion to change a nappy.
10:55:49 <PeakerWork> beelsebob: That's applicative again, though
10:55:54 <beelsebob> PeakerWork: oh, so it is
10:55:55 <beelsebob> >.<
10:56:05 <ski_> PeakerWork : that desugars to `(>>=)'
10:56:15 <beelsebob> ski_: sure, but (>>=) is not needed
10:56:16 <PeakerWork> ski_: yeah, but expressive-power-wise, its just Applicative
10:56:19 <ski_> (assuming beelsebob forgot an initial `do')
10:56:34 <beelsebob> it *could* be written (Just 5) <^(,)^> (Just 3)
10:56:35 <Heffalump> there are things you can write that combine essential use of bind with applicative-like things
10:56:47 <Heffalump> commutativity means you can reorder the applicative-like bits leaving the other pieces alone
10:56:55 <smarmy> you could have do x <- Just 5; y <- Just x; return (x,y)
10:57:32 <PeakerWork> Functor => Applicative => (CummutativeApplicative, Monad) (CummutativeApplicative places an additional restriction, so its a subclass with no methods)
10:57:41 <ski_> beelsebob,PeakerWork : i think one point is that in commutative monad, you can reorder things described by `(>>=)', if they do not depend on each other
10:58:05 <PeakerWork> ski_: if they don't depend on each other, then you can use the Applicative rather than Monad instance
10:58:19 <PeakerWork> ski_: and in that case, you could use the CummutativeApplicative instance
10:58:49 <PeakerWork> but maybe for optimization purposes, its better to have CummutativeApplicative duplicate the Applicative methods
10:59:14 <ski_> (PeakerWork : yes, but still *can* use the monad operations to express the commutativity)
10:59:39 <PeakerWork> ski_: In which case its reasonable to lose the automatic reorderings :-)
10:59:48 <ski_> (also, other parts of the comuputation may make it more natural to use the monadic operations)
11:00:01 <PeakerWork> ski_: Monadic parsers could in theory get DSM built from them if they don't have grammar depending on input
11:00:05 <ski_> "automatic reorderings" referring to ?
11:01:02 <PeakerWork> ski_: any theoretical/hypothetical mechanism to reorder stuff for optimization reasons
11:02:07 <yitz> ha! +1 roconnor! http://www.haskell.org/pipermail/haskell-cafe/2009-January/053892.html
11:02:23 <ozy`> PeakerWork: is there any particular reason you spell it <Cummutative>?
11:02:31 <ski_> i'd expect an optimizer to *possibly* reorder in the monadic operations, if its a commutative monad
11:02:34 <ozy`> as opposed to <...o...>?
11:02:38 <PeakerWork> ozy`: I'm a bad speller? :)
11:02:40 <ski_> (i.e. i see no reason to forbit it)
11:02:41 <PeakerWork> ozy`: English is not my first language
11:03:00 <ozy`> PeakerWork: that's plenty reason enough. just wondering :p
11:03:01 <PeakerWork> ski_: sure, but then only optimizers that can see the code internals can do it
11:03:13 <smarmy> so is the final result here that commutative use of an arbitrary monad is no more expressive than an applicative?
11:03:41 <PeakerWork> @type liftA2 (flip const)
11:03:42 <lambdabot> forall b a (f :: * -> *). (Applicative f) => f a -> f b -> f b
11:03:49 <ski_> PeakerWork : yes .. usually compilers can do that, no ?
11:03:50 <PeakerWork> smarmy: I think that shows that yes
11:04:12 <PeakerWork> ski_: Yeah, but a CummutativeApplicative instance user/library/code could do that, rather than a compiler
11:04:15 <ski_> smarmy : by itself, yes
11:04:27 <PeakerWork> smarmy: the type of that expression that I built, that is
11:04:34 <PeakerWork> @type (>>)
11:04:34 <smarmy> right.  because commutative use implies lack of a dependency, which is where the extra expressiveness of a monad comes from?
11:04:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
11:04:38 <ski_> PeakerWork : by writing `RULES' ?
11:04:50 <PeakerWork> smarmy: yeah, monad sequencing is allowed to be dynamic based on previous outputs
11:05:16 <smarmy> awesome.  i love this channel
11:05:16 <PeakerWork> ski_: or by building/manipulating a data structure that is built with the <*> applications/etc
11:06:26 <ski_> PeakerWork : i'm not sure what the optimizer in here is ?
11:06:42 <PeakerWork> ski_: consider the arrow-based parser rather than a monadic one
11:07:23 <ski_> what is the code that the optimizer should optimizer ?
11:07:28 <ski_> (s/r//)
11:07:43 <PeakerWork> ski_: it doesn't necessarily optimize code, it can optimize a parser you're building, for example, by converting it to a DSM
11:09:25 <nikki93> Guys, I need an exercise to learn combining functions with '.'.
11:09:26 <nikki93> Got ideas?
11:09:47 <ddarius> nikki93: Just write any code whatsoever.
11:10:17 <nikki93> ddarius: I need motivation. Motivation stems from a reason to do it.
11:10:28 <nikki93> ddarius: The reason is, yes, to learn '.', but whatever.
11:10:29 <smarmy> nikki93: practice converting functions to pointfree form
11:10:32 <BONUS_> its not hard, just cut off the last parameters
11:10:33 <nikki93> ddarius: Gimme homework.
11:10:55 <Raevel> nikki93: do a sudoku solver
11:11:06 <nikki93> Raevel: Ehm, small example, please, thx.
11:11:28 <smarmy> nikki93: take any function in the standard prelude, write it yourself, then make it pointfree
11:11:49 <mauke> nikki93: write a program that counts the number of words in each line
11:12:00 <nikki93> mauke: Ok that one's nice.
11:12:02 <mauke> nikki93: use 'interact' to for IO
11:12:07 <mauke> s/to //
11:12:27 <Raevel> implement inBoth :: Eq a => [a] -> [a] -> [a]
11:12:35 <BONUS_> e.g: how would you pointfree: concat (map (replicate 3) (show (sqrt (negate (max 200 y)))))
11:12:47 <mauke> that is pointfree :-)
11:12:52 <mauke> at least if you ask @pl
11:13:10 <BONUS_> uh i mean
11:13:24 <BONUS_> f y = concat (map  (replicate 3) (show (sqrt (negate (max 200 y)))))
11:14:16 <mauke> boring
11:14:26 <nikki93> findNumWordsInLines = map (length . words) . lines
11:14:27 <mauke> try \map sqrt -> concat (map (replicate 3) (show (sqrt (negate (max 200 y)))))
11:15:01 <mauke> nikki93: good, but that's not a complete program yet :-)
11:15:12 <nikki93> mauke: Never written a complete program.
11:15:25 <nikki93> I'm guess main = interact findNumWordsInLines where fin..
11:15:32 <mauke> not quite
11:15:34 <mauke> :t interact
11:15:35 <lambdabot> (String -> String) -> IO ()
11:15:48 <mauke> but it should be easy to extend
11:15:50 <Saizan_> roderyk: solved?
11:16:03 <nikki93> I'm guess main = interact show . findNumWordsInLines where fin..
11:16:36 <mauke> try it
11:16:38 <mauke> do you have ghc?
11:16:44 <nikki93> findNumWordsInLines has type [Integer], which can be shown.
11:16:48 <nikki93> mauke: Hell yeah!
11:16:49 <nikki93> :P
11:17:03 <mauke> so put it in a file and compile it :-)
11:17:08 <ozy`> would it be possible for (+) to be of type (Num a, Num b, Num c) => a -> b -> c ?
11:17:22 <BONUS_> uh .. no
11:17:29 <PeakerWork> Don't think so, no
11:17:30 <mauke> ozy`: no, because you can't interconvert between arbitrary types
11:17:40 <vixey> :t fromIntegral . toInteger
11:17:42 <lambdabot> forall b a. (Integral a, Num b) => a -> b
11:17:51 <vixey> :t fromIntegral . toInteger . floor
11:17:52 <lambdabot> forall b a. (RealFrac a, Num b) => a -> b
11:18:16 <ozy`> mauke: mind explaining in a bit more detail? :p
11:18:36 <mauke> ozy`: well, how would you write such a (+)?
11:18:37 <smarmy> ozy': ask yourself, how would you create something of type c?  what information do you have to generate it?
11:19:33 <ozy`> mauke: how would you write (+) in the first place for all integers?
11:19:53 <BONUS> if you have a function of type b -> c, c has to be undefined
11:20:17 <mauke> ozy`: by calling gmp_add or whatever
11:20:20 <nikki93> mauke: Got pwnt.
11:20:28 <PeakerWork> consider that even (Num a => b -> a) can be a valid Num instance
11:20:28 <nikki93> mauke: How exactly does 'interact' work?
11:20:45 <mauke> @src interact
11:20:45 <lambdabot> interact f = do s <- getContents; putStr (f s)
11:20:46 <int-e> @type \a b -> const 0 (negate a, negate b)
11:20:48 <lambdabot> forall t a a1. (Num a1, Num a, Num t) => a -> a1 -> t
11:21:01 <mauke> nikki93: what exactly do you want to know?
11:22:21 <nikki93> mauke: Its ok, I knowed it.
11:22:50 <int-e> BONUS: It's really a matter of which functions the Num class provides. (The only way of constructing new values of a Num instance is to use fromInteger.)
11:23:05 <BONUS> yeah
11:23:09 <ozy`> mauke: I'm not worried about how it would actually be implemented for real numbers (obviously, you -would- call out to a library or assembler, but, big deal). my real question is, would it be possible for (+) to be designed in such a way that you could add two values which are of different types, but both still Num instances?
11:23:34 <mauke> not with the existing Num interface
11:23:35 <ozy`> s/real numbers/actual numbers/
11:23:57 <vixey> ozy`, you ever saw C or whatever, with the lattice of types?
11:24:13 <vixey> float + int = float
11:24:15 <mauke> at some point you actually need to do stuff, and then you need to know which types you're working with
11:24:18 <ozy`> vixey: yep
11:24:24 <mauke> C can't do float + int
11:24:30 <vixey> ALGOL is a better example
11:24:32 <ozy`> can't it?
11:24:48 <mauke> no, what it actually does is that it converts both to double, then uses double + double
11:24:58 <sjanssen> dcoutts_: thanks for the quick response on #461!  However, it seems it is not quite fixed
11:25:12 <nikki93> main = interact (\x -> show (findNumWordsInLines x)) where findNumWordsInLines = map (\x -> show ((length . words) x) ++ ": " ++ x ++ "\n") . lines
11:25:19 <nikki93> mauke: How's that?
11:25:21 <sjanssen> dcoutts_: check-pkg works, but upload-pkg fails with the same error as before
11:26:40 <mauke> nikki93: don't bother preserving the original lines; just replace each line by a number
11:26:52 <mauke> nikki93: then get rid of all \x  :-)
11:28:01 <nikki93> mauke: I wanted to preserve.
11:28:06 <nikki93> mauke: I wanted to see the original lines. :)
11:28:08 <nikki93> main = interact (\x -> concat (findNumWordsInLines x)) where findNumWordsInLines = map (\x -> show ((length . words) x) ++ (if ((length. words) x) < 10 then " " else "") ++ ": " ++ x ++ "\n") . lines
11:28:23 <nikki93> This one is better, it puts a space if wordcount < 10 to make lines line up.
11:28:24 <mauke> I don't know what that does, but it's too complicated
11:28:29 <nikki93> mauke: lol
11:28:43 <mauke> nikki93: you can trivially get rid of the first \x
11:29:28 <daf> I'd move the map outside
11:29:39 <vixey> nikki93, findNumWordsInLines is a strange name compared to numWordsInLines
11:29:47 <daf> main = interact (concat . map findNumWords)
11:30:06 <daf> which is, of course, interact (concatMap findNumWords)
11:30:12 <mauke> main = interact (unlines . map countWords . lines)
11:30:33 <daf> ah yes
11:30:33 <mauke> countWords = show . length . words
11:31:38 <daf> if you want to preserve the lines, you could do: countWords s = printf " %2d %s" (length $ words s) s
11:31:53 <mauke> excellent use of printf
11:32:22 <mauke> for 500 bonus points, figure out how to get rid of s
11:32:40 <olsner> @ty ap (printf "...") (length . words)
11:32:42 <lambdabot> forall b. (PrintfType b) => String -> b
11:33:18 <daf> nice
11:33:29 <mauke> > ""++ ap (printf "%2d %s") (length . words) "a b"
11:33:31 <lambdabot>   "* Exception: Printf.printf: bad argument
11:33:34 <mauke> failed
11:34:08 <nikki93> :type ap
11:34:13 <daf> I want to know the answer but I need to run to the shops if I'm going to make cookies tonight
11:35:00 <mauke> > ""++ (=<<) (printf "%2d %s") (length . words) "a b"
11:35:01 <lambdabot>   " 2 a b"
11:35:20 <mauke> countWords = printf "%2d %s" =<< length . words
11:35:39 <olsner> hmm, ap == (=<<) . flip?
11:35:51 <vixey> :t (=<<) . flip
11:35:52 <lambdabot> forall a b c. (a -> b -> c) -> (a -> b) -> a -> c
11:35:56 <olsner> > ap (flip $ printf "%d %s") (length . words) "asf" :: String
11:35:58 <lambdabot>   "1 asf"
11:36:04 <mauke> olsner: yeah, pretty much
11:36:21 <dpratt71> I've just finished up a couple blog posts about functional vs. imperative...
11:36:34 <olsner> phew, at least I wasn't *that* far off then :)
11:36:35 <nikki93> main = interact (concat . eachLine) where eachLine = map (\x -> show ((length . words) x) ++ (if ((length. words) x) < 10 then " " else "") ++ ": " ++ x ++ "\n") . lines
11:36:42 <mauke> olsner: http://mauke.ath.cx/tmp/flow.png
11:36:48 <AirCastle> dpratt71: i wanna see
11:37:11 <dpratt71> ...given my general Haskell ignorance, any takers on making sure I didn't say something stupid?
11:37:43 <ddarius> dpratt71: Unless you have previous FP experience, you've almost certainly said something stupid.
11:37:57 <chessguy> wow, that's encouraging
11:38:02 <dpratt71> AirCastle: I'm gonna try to message you the url...but I also have general IRC ignorance ;)
11:38:06 <ddarius> mauke: You should look into J.
11:38:06 <AirCastle> ok
11:38:20 <chessguy> dpratt71:  just dump the link in the channel.
11:38:26 <chessguy> or are you worried about spam
11:38:53 <dpratt71> chessguy: ok, didn't want to spam, but I guess it's on topic: http://www.danielgpratt.com/2009/01/comparing-functional-and-imperative.html
11:38:55 <AirCastle> /msg AirCastle blah blah
11:39:28 * dpratt71 cringes in anticipation
11:39:43 <mauke> ap c g = liftM2 c id g; (=<<) c f = liftM2 c f id
11:39:51 <ddarius> dpratt71: "Don't Fear the Monads" was a -horrible- video.
11:39:59 <foo-nix> twanvl, Dear twanvl, would you allow me to pm you?
11:40:20 <chessguy> dpratt71:  to be precise, a() isn't quite equivalent, as it can only return an int, whereas numbers in Haskell are polymorphic
11:40:22 <ketil_> @seen bos
11:40:22 <lambdabot> bos is in #ghc and #haskell. I don't know when bos last spoke.
11:40:32 <dpratt71> ddarius: interesting that you say that...
11:40:43 <ddarius> dpratt71: In that vein, 'a' is not a function.
11:41:06 <dpratt71> ...I had a heck of a time getting what he was saying in that video...maybe it wasn't just me
11:41:24 <ddarius> (Well, technically it could be with a suitably devious instance of NUm)
11:41:25 <dpratt71> ddarius: I thought that might technically be true, but...
11:42:00 <dpratt71> ...I thought it might be true enough without confusing the point
11:42:04 <ddarius> dpratt71: Unless you're saying that in reference to lazy evaluation (in which case it still isn't really true), it's simply not the case.
11:42:47 <chessguy> dpratt71:  umm, the link at the bottom of the first page points to itself. trying to make a subtle point about recursion?
11:42:49 <ddarius> dpratt71: See, now b is just wrong.
11:43:33 <vixey> http://mauke.ath.cx/stuff/haskell/hax.pl lol
11:43:33 <ddarius> Well, technically it could be accurate, but in practice it is very much not.
11:43:50 <dpratt71> chessguy: whoops! let me fix that
11:44:07 <smarmy> i might say that the blog post is describing declarative programming, not functional programming.  or maybe both, but not drawing a distinction
11:44:18 <chessguy> righto, game-time. catch ya'll in a bit
11:44:23 <mauke> vixey: :-)
11:45:43 <dpratt71> chessguy: link fixed thanks
11:45:57 <jonathan_> ddarius: funny you should mention that about "Don't Fear the Monads" - I found him to be a bit off in some of the other videos too
11:46:08 <jonathan_> ddarius: "him" being Beckman
11:46:54 <dpratt71> ddarius: what did you mean "b is just wrong"? can you clarify?
11:47:32 <RayNbow> hmm, is there a nicer solution to sigfpe's Min/Max monoid exercise than http://hpaste.org/14067 ?
11:47:39 <dons> roconnor: why isn't fewdigits on hackage?
11:47:56 <ddarius> dpratt71: For the love of Pete, longer names don't hurt performance.
11:48:24 <ddarius> jonathan_: His blog is actually alright.  His videos are amazingly bad.
11:48:31 <RayNbow> dons: maybe roconnor is being lazy, waiting till the fewdigits package is being demanded? :p
11:48:35 <dpratt71> ddarius: I read somewhere recently that longer param names = longer error messages = non-inlined code
11:48:48 <ddarius> dpratt71: That's a bug in a particular version of a particular compiler.
11:48:56 <ddarius> dpratt71: No one has been using short names due to it.
11:48:56 <dons> in a particular corner case.
11:49:01 <dons> its not a general thing with names
11:49:02 <dpratt71> ddarius: ah
11:49:24 <dpratt71> so then...why do ya'll love short parameter names so much?
11:49:30 <ddarius> dpratt71: The reason short names are common is the values are usually so abstract that longer names would be just as meaningless.
11:49:34 <jonathan_> hehe, like "xs" ;)
11:49:48 <dons> ?src map
11:49:48 <lambdabot> map _ []     = []
11:49:48 <lambdabot> map f (x:xs) = f x : map f xs
11:49:55 <dons> what would you call f and x and xs ?
11:50:04 <ddarius> Consider map.  map function (headOfList:tailOfList) = function headOfList : map function tailOfList  doesn't really add much.
11:50:07 <mstr> head tail?
11:50:22 <ddarius> mstr: head/tail are taken, though you could shadow the names.
11:50:36 <dons> what about `f`?
11:50:37 <RayNbow> map funkyFunction (funkyHead:funkyTail) = funkyFunction funkyHead : map funkyFunction funkyTail -- ? :p
11:50:39 <luite_> RayNbow: you can remove the Bounded dependency like this: http://pastebin.com/m17f6f0df , but I'm not sure how to do that without duplicating some of the Maybe code
11:50:59 <mstr> ddarius: yea, just pointing out that there are more clear names than x and xs
11:51:02 <sjanssen> dpratt71: also, function bodies tend to be much smaller in Haskell, so it is easier to keep track of variable names
11:51:09 <dons> its the same reason java programmers use 'o' for generic objects
11:51:15 <ddarius> mstr: Actually that's a convention that is rather clear to me.
11:51:20 <mstr> but I use i,j,k for loops in C, and they don't really make sense either, so... :)
11:51:22 <dpratt71> sjanssen: I agree with that
11:51:38 <sjanssen> mstr: on the other hand, (x:xs) is such a prevalent convention in Haskell that I think it is more readable
11:51:39 <mstr> ddarius: yep, exactly. they'll feel normal after a while
11:51:49 <RayNbow> luite_: the alternative would be to newtype Maybe... but then you'll have to do more pattern matching :p
11:51:55 <RayNbow> erm wait
11:51:56 <sjanssen> 'xs' means 'x' plural
11:52:03 <ehird> sjanssen: really?
11:52:05 <ddarius> item:items
11:52:07 <ehird> i thought it meant excess
11:52:07 <RayNbow> newtyping Maybe ain't possible :p
11:52:08 <ehird> xs, excess
11:52:22 <jonathan_> I totally agree about "xs" just saying it was the first one I noticed when I started reading about Haskell
11:52:28 <ehird> you have what you're dealing with right now, and the excess you'll pass in a recursion later
11:52:32 <mstr> 1st, rest ;)
11:52:33 <mauke> (x : xs) (y : ys)
11:52:45 <ehird> yeah i thought ys was just a pun based on x/xs
11:52:47 <luite_> RayNbow: I could imagine doing a conversion between Maybe and Maximum, and then using liftM2 max
11:52:52 <ddarius> mstr: And when you have two lists?
11:52:55 <vixey> what comes after z?    w
11:53:01 <ddarius> vixey: Often.
11:53:02 <sjanssen> ehird: I don't think 'excess' is the intention, since we also have ys, ns, etc.
11:53:02 <luite_> RayNbow: but I don't think that would make the code any shorter, or clearer
11:53:09 <vixey> what comes next, 0, 1, ...?  infinity
11:53:09 <ehird> sjanssen: i prefer my name :D
11:53:13 <mstr> ddarius: just joking, I don't really have a problem with short names :)
11:53:22 <mauke> ehird: explain xss@((x : xs) : _)
11:53:29 <ddarius> @src concat
11:53:29 <lambdabot> concat = foldr (++) []
11:53:33 <ddarius> Damn abstraction
11:53:33 <ehird> mauke: excessess... sort of.
11:53:38 <ehird> I saw things like,
11:53:40 <vixey> stop abstracting!
11:53:44 <pejo> mstr, isn't i the first integer variable?
11:53:47 <ehird> xss and ys as just puns after the base analogy of x and excess
11:53:47 <ehird> XD
11:53:48 * vixey should make posters
11:53:57 <ozy`> pejo: in fortran, yes....
11:54:19 <sjanssen> dpratt71: another reason we tend to use short names in Haskell is because horizontal space is often at a premium
11:54:27 <mstr> pejo: i,j,k are used in vector math too. I guess it comes from there?
11:54:32 <pejo> vixey, å, ä and ö.
11:54:43 <dpratt71> sjanssen: hadn't thought of that
11:54:52 <mauke> vixey: {
11:55:29 <ozy`> sjanssen: not that most programmers care.... even in haskell I frequently see lines that are clearly meant to be read on a 72" monitor
11:55:39 <ddarius> > succ 'z'
11:55:40 <lambdabot>   '{'
11:55:51 <ddarius> ozy`: I do that in C# too.
11:55:57 <PeakerWork> Has anyone here heard of Ur?
11:56:04 <ddarius> PeakerWork: Yes.
11:56:13 <ozy`> ddarius: you are in fact worse than Windows Vista.
11:56:14 <sjanssen> ozy`: and sometimes I'm lazy and write those sort of lines :)
11:56:14 <PeakerWork> ddarius: what are your thoughts?
11:56:19 * vixey plays sokoban
11:56:24 <mauke> "what are ur thoughts?"
11:56:32 <PeakerWork> hehe
11:56:44 <ddarius> PeakerWork: I've only looked at the demos.  I don't make web programs on my own time, so I could care less about that aspect.
11:56:52 <vixey> I think "Ur" sounds like txt speak and not the seed of natural languages or whatever
11:57:11 <mstr> could care less or coulnd't care less?
11:57:17 <mauke> couldn't
11:57:19 <ddarius> PeakerWork: Adam posted links on LtU.
11:57:29 <mstr> though so too
11:57:29 <smarmy> mstr: lol... i was holding back on that one ;)
11:57:32 <ddarius> I said what I mean and mean what I said dammit!
11:57:45 <mauke> so you care about web programs?
11:57:52 * mmorrow hates when it's said "could care less"!
11:57:54 <PeakerWork> ddarius: LtU?
11:58:07 <PeakerWork> ddarius: I got a link from the creator of Ur, with whom I'm discussing. it seems interesting
11:58:10 <vixey> PeakerWork, Homework the Ultimate
11:58:21 <vixey> It's a place to post CS homework
11:59:20 <kerlo> @docs Data.Map
11:59:21 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
11:59:42 <ddarius> PeakerWork: http://lambda-the-ultimate.org/node/3068
11:59:44 <kerlo> Unfortunately, that page doesn't actually exist...
11:59:54 <PeakerWork> vixey: you talking about his banning from #haskell?
12:00:07 <vixey> PeakerWork, I'm talking about the low quality of recent posts on it..
12:00:07 <mauke> kerlo: http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html
12:00:24 <BONUS> the most common license for haskell packages is BSD, right?
12:00:33 <ddarius> BONUS: Yes.
12:02:14 <CakeProphet> do the types of values in a data constructor have to be concrete?
12:02:16 <PeakerWork> vixey: oh
12:02:24 <ddarius> CakeProphet: No.
12:02:32 <ddarius> @src Maybe.
12:02:32 <lambdabot> Source not found.
12:02:34 <ddarius> @src Maybe
12:02:34 <lambdabot> data Maybe a = Nothing | Just a
12:02:46 <BONUS> fields have to be concrete types
12:02:49 <CakeProphet> can you have have data Message v = (Chan s) MessageType v
12:02:52 <CakeProphet> right.
12:03:01 <CakeProphet> or does it have to be data Message s v
12:03:10 <CakeProphet> well
12:03:15 <CakeProphet> Message v = Message
12:03:20 <ddarius> I don't know what you expect the first to mean.
12:03:20 <CakeProphet> and then all that stuff
12:03:26 <kerlo> CakeProphet: would that be the same as data Message v = Chan s MessageType v?
12:03:37 <sjanssen> CakeProphet: for one thing, you're missing a data constructor
12:03:38 <CakeProphet> no I mean
12:03:42 <CakeProphet> right...
12:03:44 <CakeProphet> I forgot it.
12:03:45 <CakeProphet> ...
12:03:58 <CakeProphet> data Message v =Message (Chan s) MessageType v
12:04:02 <ddarius> That's fine.
12:04:07 <mauke> s is not in scope
12:04:09 <sjanssen> well, not quite
12:04:10 <kerlo> Don't you have to stick a "forall s." somewhere?
12:04:22 <sjanssen> data Message v = forall s. Message (Chan s) MessageType v
12:04:35 <sjanssen> CakeProphet: but I bet you'll have trouble actually using that type
12:04:41 <CakeProphet> hmmm
12:04:47 <CakeProphet> I guess Message s v will be fine
12:09:05 <ddarius> CakeProphet: It might be better, in the future, to simply say what you'd like to do/accomplish rather than or in addition to asking about features you think my help.
12:09:39 <int80_h> I've written a function that is supposed to sort by the tangent made by the first point and each point following. My logic is hosed. Could someone take a look at my hpaste. It has more details. http://hpaste.org/14047#a3
12:09:41 <mauke> ah, good old xy problem
12:09:58 <dons> roconnor: btw, i posted your libraries patch to the programming reddit.
12:10:20 <nikki93> main = interact (show . calc)
12:10:20 <nikki93>     where calc x = foldl oneWord [] (words x)
12:10:20 <nikki93> 	         where
12:10:20 <nikki93> 		     oneWord (x:y:xs) ("+") = (x+y) : xs
12:10:20 <nikki93> 		     oneWord (x:y:xs) ("-") = (y-x) : xs
12:10:22 <nikki93> 		     oneWord (x:y:xs) ("*") = (x*y) : xs
12:10:25 <nikki93> 		     oneWord (x:y:xs) ("/") = (y/x) : xs
12:10:27 <nikki93> 		     oneWord xs y = (read y) : xs
12:10:30 <nikki93> My RPN calculator done! :D
12:10:33 <CakeProphet> basically Message is a type that gets wrote/read to Chans by threads... a message has a reply Chan, an enumerated MessageType, and a value v
12:10:54 <vixey> nikki93, you didn't have to write  where  twice
12:11:13 <nikki93> vixey: Really?
12:11:18 <nikki93> vixey: Ok, I'll try
12:11:27 <CakeProphet> -ahem- dispatch tables ftw.
12:11:29 <mauke> you can put multiple definitions in the same where block
12:12:15 <ddarius> mauke: Namespace control, man!
12:12:49 <gnuvince_> @src liftM
12:12:49 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:13:04 <gnuvince_> @src liftM2
12:13:04 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
12:13:15 <PeakerWork> @src liftA2
12:13:15 <lambdabot> liftA2 f a b = f <$> a <*> b
12:15:36 <int80_h> http://hpaste.org/14047#a3, could someone take a peek?
12:16:36 <roconnor> Is it really true that the naive way of making a "Haskell" category doesn't even work?
12:17:00 <ddarius> roconnor: Prove it!
12:17:27 <roconnor> (.) is associative
12:17:32 <roconnor> f . id = f
12:17:36 <roconnor> id . f = f
12:17:55 <ddarius> At least one of those three equations is false
12:17:56 <roconnor> am I done?
12:17:59 <ddarius> Nope.
12:18:11 <roconnor> I'm most concerned about (.) being associative
12:18:23 <vixey> (f . g) . h = f . (g . h)
12:18:28 <nikki93> How do I get rid of the parentheses in something like this: (show (head (foldl oneWord [] (words str)))) ++ "\n"
12:18:30 <ddarius> roconnor: That's the hardest one to verify.
12:18:58 <BONUS> nikki93: (show . head . foldl oneWord [] . words $ str) ++ "\n"
12:19:04 <daf> mauke: that flow diagram seems useful
12:19:09 <ozy`> nikki93: (show $ head $ foldl oneWord [] $ words str) ++ "\n"
12:19:11 <ozy`> or that
12:19:14 <BONUS> w00t
12:19:24 <vixey> I would suggest against using $ like thta
12:19:40 <BONUS> or (++"\n") . show . head . foldl oneWord [] . words $ str
12:19:52 <ozy`> vixey: yeah, I overuse it. mainly because I still haven't gotten the hang of (.)
12:20:16 <kerlo> foldr (:) "\n" . show . head . foldl oneWord [] . words $ str
12:20:17 <roconnor> ((f . g) . h) x = (f.g) (h x) = f (g (h x))
12:20:32 <roconnor> same the other way
12:20:41 <roconnor> ddarius: I'm done
12:20:46 <nikki93> What's '.' and what's '$'?
12:20:51 <kerlo> That still has parentheses, though.
12:21:02 <ddarius> You've only stated the latter two identites, you certainly haven't proved them.
12:21:10 <ozy`> nikki93: they're operators that apply the stuff on the left to the stuff on the right in subtly different ways.
12:21:12 <int80_h> no huh?
12:21:21 <nikki93> ozy`: Explain? :)
12:21:22 <kerlo> nikki93: (f . g) x = f (g x); and f $ g = f g
12:21:23 <vixey> nikki93, you didn't ask that yesterday?
12:21:31 <roconnor> (f . id) x = f (id x) = f x
12:21:40 <nikki93> vixey: Nope.
12:21:54 <roconnor> (id . f) x= id (f x) = f x
12:22:01 <roconnor> ddarius: done
12:22:03 <ozy`> vixey: someone asks about ($) every day, surely. must not've been nikki93 :p
12:22:05 <ddarius> roconnor: You might want to be more careful there.
12:22:13 <kerlo> And $ has very low precedence, so f . g $ h = (f . g) $ h = (f . g) h = f (g h)
12:22:30 <nikki93> With $, what happens first? Left side or right side?
12:22:39 <roconnor> ddarius: first step is definition of ., second step is definition if id.
12:23:12 <ddarius> roconnor: All you've proved is that (f . id) x = f x.  That does not imply that f . id = f
12:23:20 <BONUS> right side gets applied to the function on the left side
12:23:21 <ozy`> nikki93: you're gonna have to be a little clearer there. ($) doesn't evaluate either of its arguments.
12:23:40 <vixey> ((f . g) . h) x = (f . (g . h)) x    (f . g) (h x) = f ((g . h) x)    f (g (h x)) = f (g (h x))
12:23:44 <roconnor> ddarius: you are saying that functions are not extensional?
12:23:58 <ddarius> roconnor: eta reduction does not hold in Haskell.
12:24:09 <int-e> int80_h: I'm not sure, but I think you need  myTan p1 p2 = (fst p2 - fst p1) / (snd p2 - snd p1)
12:24:11 <nikki93> ozy`: (x $ y $ z) = (x y) z? or x (y z)?
12:24:21 <vixey> ddarius, given both sides have a -> b, applying both to a fresh variable should be fine though, isn't it?
12:24:22 <ddarius> > (undefined . id) `seq` ()
12:24:23 <lambdabot>   ()
12:24:26 <ddarius> > undefined `seq` ()
12:24:27 <lambdabot>   * Exception: Prelude.undefined
12:24:33 <roconnor> nikki93: x (y z)  sadly
12:24:48 <ddarius> > (id . undefined) `seq` ()
12:24:49 <lambdabot>   ()
12:25:06 <roconnor> ddarius: well seq is stupid
12:25:14 <pejo> ddarius, is it seq that destroys eta reduction?
12:25:15 <ddarius> roconnor: seq is always the problem child
12:25:17 <int-e> int80_h: why are you reimplementing sorting btw? isn't sortBy (compare `on` myTan a) or something like that better?
12:25:19 <roconnor> can we have the Seq class back in Haskell prime?
12:25:25 <ddarius> pejo: For functions, yes.
12:25:33 <roconnor> the reasons given for removing Seq are dumb.
12:25:38 <roconnor> really really dumb
12:25:43 <vixey> what's good about Seq compared to Normalize?
12:25:59 <Heffalump> vixey: Seq is the class for shallow forcing
12:26:01 <pejo> ddarius, is this stuff written down somewhere?
12:26:04 <nikki93> roconnor: That's goodly.
12:26:05 <Heffalump> Normalize is for deep forcing
12:26:12 <nikki93> roconnor: I find myself wanting to do right side first most often.
12:26:22 <int80_h> int-e : better yes. But I'm doing an exercise from RWH. I'd be missing the point of the exercise if I used sortBy when it hasn't ben introduced in the text yet.
12:26:24 <nikki93>     where calc str = (show $ head $ foldl oneWord [] (words str)) ++ "\n"
12:26:30 <nikki93> Doesn't make error, while
12:26:34 <ddarius> pejo: It's all on the mailing lists somewhere.  It's all folklore.
12:26:35 <vixey> Heffalump, (I just made up the name but that is what I meant by it)
12:26:40 <roconnor> nikki93: x . y $ z  is prefered for x (y z)
12:26:41 <nikki93> where calc str = (show $ head $ foldl oneWord [] (words str)) ++ "\n"
12:26:43 <Heffalump> Seq is shorter :-)
12:26:50 <nikki93> roconnor: Oh ok.
12:26:55 <pejo> ddarius, the best kind of knowledge. :-)
12:26:58 <roconnor> nikki93: which is why we are sad about the associativity of $
12:27:00 <vixey> well I will call it Nf then
12:27:12 <Heffalump> I think that's confusing, because it implies deep forcing
12:27:19 <Heffalump> Whnf perhaps...
12:27:26 <PeakerWork> Did anyone try to write a Laziness monad or some such -- that would allow an eager language to have code that can be either strict or lazy?
12:27:29 <vixey> Seq could be called Whnf
12:27:32 <vixey> Normalize could be Nf
12:27:36 <int80_h> int-e : I thought tan= y2 - y1 / x2 - x1
12:27:36 <PeakerWork> (or the same in Haskell/lazy language)
12:27:39 <nikki93>     where calc str = (show . head . (foldl oneWord [] words $ str)) ++ "\n"
12:27:43 <nikki93> Fails! Why?
12:27:44 <Heffalump> vixey: Nf is unimplementable
12:27:46 <int-e> @type rwhnf
12:27:46 <vixey> Peaker, yes
12:27:47 <lambdabot> forall a. a -> Done
12:27:48 <Heffalump> I think
12:28:02 <nikki93> Oh wait I got it.
12:28:04 <byorgey_> @type foldl
12:28:05 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:28:14 <byorgey_> nikki93: that looks like too many arguments to foldl.
12:28:21 <roconnor> I've never used seq for anything other than integers myself.
12:28:30 <ozy`> nikki93: whenever you use (.), it has to evaluate to a function.
12:28:32 <int-e> int80_h: yes, but you need to find the angle to the y axis because you sorted by y.
12:28:43 <vixey> whnf would be the same as nf for GMP integers
12:28:44 <roconnor> and it is pretty useless by itself for other datastructures.
12:28:56 <Heffalump> how would you implement nf for function types?
12:29:11 <vixey> Heffalump, I think that is impossible
12:29:21 <ozy`> so: (show . head . (foldl oneWord []) . words $ str) should work
12:29:22 <PeakerWork> vixey: who/where?
12:29:26 <vixey> me
12:29:30 <roconnor> Heffalump: isn't the idea that functions are not a member of the Nf class?
12:29:39 <Heffalump> ah, ok
12:29:44 <vixey> I use the Computation monad to write code that is more lazy than haskell
12:29:48 <PeakerWork> vixey: cool, can you paste it?
12:30:03 <int80_h> int-e: the alorithm said, sort by y, then find the tangent made by point P and some point, made with the x-axis
12:30:12 <vixey> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=562
12:30:57 <vixey> most of that code is just stolen from some slides
12:31:38 <dpratt71> ddarius: are you still around?
12:31:42 <ddarius> Yes
12:32:05 <dpratt71> I reworked the opener of the blog post a bit to try to make it more technically accurate...
12:32:31 <int-e> int80_h: oh btw, have you checked whether you really get the point (1,2) for a? after sorting by y, the first element will be (4,1), won't it?
12:32:35 <dpratt71> ...care to give your opinion of whether I succeeded?
12:32:39 <int-e> int80_h: (note, I have not tried any of that code)
12:32:45 <int80_h> int-e: http://en.wikipedia.org/wiki/Graham_scan
12:32:53 <int80_h> int-e: oops I'm slow with the pasting
12:33:01 <PeakerWork> vixey: thanks
12:33:07 <nikki93> > let x = (+2) ; y = (*3) ; in (((x $ y $ 4) == x (y 4) ), ((x $ y $ 4) == (x y) 4 ))
12:33:09 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a
12:33:09 <lambdabot>      Proba...
12:33:27 <vixey> > let x = (+2) ; y = (*3) ; in (((x $ y $ 4) == x (y 4) ), ((x $ y $ 4) == (x . y) 4 ))
12:33:28 <lambdabot>   (True,True)
12:33:30 <dpratt71> ddarius: I also remove the incorrect bit about the length of variable names
12:33:36 <dpratt71> removed, even
12:33:47 <vixey> > let x = (+2) ; y = (*3) in (((x $ y $ 4) == x (y 4) ), ((x $ y $ 4) == (x . y) 4 ))
12:33:48 <lambdabot>   (True,True)
12:33:57 <vixey> > let x = (+2) ; y = (*3) in ((x $ y $ 4) == x (y 4), (x $ y $ 4) == (x . y) 4)
12:33:59 <lambdabot>   (True,True)
12:34:39 <nikki93> The problem is I have a high operator-precedence fear, whether it be operators or brackets or whatnot.
12:34:39 <ddarius> dpratt71: You never actually asked me why I thought they were wrong.
12:34:43 <nikki93> I use parentheses like the plauge.
12:34:54 <nikki93> (bad simile)
12:34:59 <int80_h> int-e: Oh I forgot to supply test data. I'll post that now
12:35:11 <int-e> int80_h: ah, the article is wrong there, where it says "it suffices to find the tangent" - the angle in question ranges from 0 to pi; the tangent will change its sign at pi/2. The cotangent works much better.
12:35:19 <dpratt71> ddarius: well...why did you think they were wrong?
12:35:38 <vixey> ddarius, that would just take the fun out of it :p
12:35:39 <ddarius> dpratt71: One problem is that, in practice though the Report doesn't require it, these values are shared so that they are only computed once.  This is rather significant because otherwise evaluating Haskell would be extremely slow.
12:35:51 <ozy`> nikki93: if you write enough haskell code, you'll get used to it
12:36:14 <nikki93> ozy`: I write a lot of C++ code and I still have parentheses all over the place.
12:36:23 <int-e> int80_h: (which brings me to my original suggestion of using delta_x / delta_y instead of delta_y / delta_x)
12:36:25 <dpratt71> that's interesting, but...
12:36:26 <int80_h> int-e: shame on me for taking wikipedia authoritatively
12:36:56 <dpratt71> ...I'm trying to create a 'logical' model for thinking about functional languages
12:38:09 <vixey> dpratt71, not a formal model to use for proofs?
12:38:17 <int80_h> int-e : okay I'll change that. But I think my sort will still be screwy
12:38:19 <int-e> int80_h: alternatively, you can pick the leftmost point as your pivot.
12:38:25 <ddarius> dpratt71: You have to consider the audience.
12:38:46 <int80_h> int-e : it sdaid point P should be the one with the lowest Y value
12:38:49 <AirCastle> a logical model for thinking about functional languages would be nice. i'd like to find one of those on the web, so i can figure out what functianal languages are before i learn one.
12:38:55 <dpratt71> ddarius: what would I do if I were considering the audience...wait, which audience?
12:39:17 <ddarius> dpratt71: Your audience is presumably not people who are already familiar with how lazy functional programming languages work.
12:39:23 <dpratt71> I don't consider folks here to be my intended audience
12:39:31 <ddarius> dpratt71: Me neither
12:39:33 <dpratt71> ddarius: right
12:40:03 <ddarius> dpratt71: They are probably not going to see that you can safely share work, they are going to see that you repeat work though.
12:40:40 <ddarius> Also, laziness is not an integral feature of functional programming, though it is for Haskell.
12:41:04 <int-e> int80_h: Oh I guess I should suggest  -delta_y / delta_x (cotan is strictly decreasing on (0, pi))
12:41:18 <ddarius> dpratt71: On a side note, I don't understand the title of that section.
12:41:48 <dpratt71> ddarius: the bit about "context" ?
12:41:58 <int80_h> int-e : what I'm wondering about is this. RWH suggests using wikipedia to find the right algorithm. Would they do that if the page on the graham scan algorithm was wrong?
12:42:03 <ddarius> The "Context determines meaning" part, yes.
12:42:41 <dons> gwern: hashell depends on ghc 6.8.x ?
12:42:49 <dons> Hashell/Eval.hs:45:19: Not in scope: `GHC.newSession
12:42:50 <dpratt71> well, I guess my point was that the meaning of "a = 3" differs greatly based on the context where it appears...
12:43:08 <int-e> int80_h: I'd guess the author(s) knew the algorithm already. The article seems fine if you just skim it.
12:43:40 <dpratt71> the statement in an imperative language implies something quite different from the same statement in a functional language
12:44:23 <dpratt71> ddarius: I'm trying to address the fact that the same or similar syntax has different meaning in a functional language context (as compared to imperative)
12:45:28 <ddarius> dpratt71: That's what I thought you might mean.  Personally, I find it stating the obvious, but it is your post.
12:45:38 <nikki93> Who here thinks school sucks?
12:45:51 <smarmy> hopefully no one
12:46:15 <ddarius> It's been several years since I've went to school.
12:46:33 <int80_h> int-e : okay with my changes my list is totaslly hosed. Point P is completely wrong
12:46:44 <dpratt71> ddarius: I certainly appreciate you taking the time to give me feedback, even if I don't agree with all of it.
12:47:28 <ddarius> dpratt71: In that framework though, one example you might want to add is ones = 1 : ones.
12:47:51 <ddarius> Because, besides being cool, it illustrates the stack behavior of lazy code.
12:48:10 <vixey> nikki93, what's favorite color?
12:48:14 <ddarius> Of course, here the lack of sharing bites even harder.
12:48:18 <vixey> nikki93, what's your*** favorite color?
12:48:42 <int-e> int80_h: well P is (4,1) if you pick the point with the smallest Y coordinate from [(1,2),(2,3),(4,1),(5,9)]
12:48:57 <vixey> > sort [(1,2),(2,3),(4,1),(5,9)]
12:48:58 <lambdabot>   [(1,2),(2,3),(4,1),(5,9)]
12:49:07 <int80_h> (sortListByY [(1,2),(2,6),(3,10),(4,9),(5,10),(2,20),(6,15)])
12:49:18 <int80_h> [(1.0,2.0),(2.0,6.0),(4.0,9.0),(3.0,10.0),(5.0,10.0),(6.0,15.0),(2.0,20.0)]
12:49:21 <int80_h> but then
12:49:22 <nikki93> vixey: Dark blue, or black, why?
12:49:30 <int80_h>  sortListByCoTangent (sortListByY [(1,2),(2,6),(3,10),(4,9),(5,10),(2,20),(6,15)]
12:49:41 <int80_h> \
12:49:45 <dpratt71> ddarius: back to your earlier point, for a long time now I've taken it for granted that the compiler is not going to interpret my code literally in all cases...
12:49:53 <int80_h> sortListByCoTangent (sortListByY [(1,2),(2,6),(3,10),(4,9),(5,10),(2,20),(6,15)])
12:49:59 <int80_h> [(6.0,15.0),(2.0,20.0),(1.0,2.0),(5.0,10.0),(2.0,6.0),(4.0,9.0),(3.0,10.0)]
12:50:11 <int80_h> see, with my previous code, point P was always right
12:50:12 <dpratt71> ddarius: ...for me the important thing is that the program does what I expect it to with acceptable performance
12:50:19 <int80_h> even if the rest of the list was hosed
12:50:24 <ddarius> dpratt71: The thing is you are making the interpretation here.
12:50:26 <int80_h> but now, even point P is wrong
12:51:02 <ddarius> dpratt71: Personally, I'd just suggest adding a note that computations can and are shared in practice avoiding repeated work.
12:51:26 <ddarius> In fact, that they -can- be shared is a property of the language being purely functional.
12:51:59 <dpratt71> ddarius: I'd not be surprised if the C# code were optimized such that the constant functions became just constant values in the compiled program
12:52:08 <int-e> int80_h: insert [b] = (a:[b]) is also wrong - the a ends up in the middle of the list that way. instead, you can define sortListByTangent (a:as) = a : insert (sortListByTangent as)
12:52:26 <ddarius> dpratt71: That is what happens in, say, GHC, but that's not laziness.
12:52:42 <dpratt71> ddarius: you said it was lazy, not me
12:53:15 <dpratt71> ddarius: correction, I never used the term 'lazy'
12:53:17 <ddarius> dpratt71: No, -that- is an optimization.  Even with optimizations turned off, GHC will only execute a+2 once and then store the result.
12:53:41 <ddarius> With optimizations on, GHC will never execute a+2, it will just inline and constant fold to 3.
12:53:44 <ddarius> er 5
12:53:59 <dpratt71> ddarius: I get what you're saying...
12:54:23 <gwern> dons: yes, hashell is 6.8 only because of the ghc api. I don't particularly feel like updating it to 6.10 GHC API or making it use hint
12:54:57 <ddarius> The ones example is another good one.  With call-by-name, i.e. what your interpetation suggests, you will make an arbitrarily long list of 1s.  With lazy evaluation it will be tied into a circular list containing just one 1.
12:55:03 <dpratt71> ddarius: ...let me ask you this: if given "a = 3", if I think of 'a' as being a function, will that lead me to incorrect conclusions about what I can do with 'a' and the logical conclusions of referencing 'a' in a program?
12:55:27 <int80_h> int-e: the latest line you gave me resulted in a type error
12:55:51 <dpratt71> ddarius: ah, I think I may see what you're driving at...
12:55:56 <ddarius> dpratt71: No.  I never said it would and I did suggest adding a note that it is actually shared in practice would be sufficient.
12:56:16 <ddarius> dpratt71: It -will- lead to wildly wrong conclusions about time and space behavior though.
12:56:45 <int80_h> int-e : nevermind. I got it wrong. I fixed it and it compiles now
12:56:57 <dpratt71> ddarius: ...my thought about what you're driving at just evaporated ;)
12:56:57 <dons> gwern: you should put those constraints in the .cabal file
12:57:01 <skorpan> what do i use in haskell to get the command line arguments passed to the program?
12:57:04 <int-e> int80_h: please, do yourself a favour, and implement sortBy.
12:57:07 <dons> (similarly for many other ones you released that depend on base < 4)
12:57:14 <pejo> skorpan, getArgs
12:57:19 <skorpan> thanks
12:57:45 <ddarius> dpratt71: Actually, with things like getContents (and in particular the unsafeInterleaveIO it's based on), call-by-name would yield different behavior to call-by-need.
12:57:56 <int80_h> @src sortBY
12:57:56 <lambdabot> Source not found. It can only be attributed to human error.
12:57:59 <gwern> dons: bah I added a tested-with field, what more d'you want :(
12:58:05 <int80_h> @sort SortBy
12:58:05 <lambdabot> Maybe you meant: more part src
12:58:12 <int-e> int80_h: sortListByTangent (a:as) = a : insert (sortListByTangent as) is also wrong, what you is needed instead is a  sortListByTangent p xs  function, that sorts xs with respect to the pivot p.
12:58:14 <int80_h> @src sortBy
12:58:14 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
12:58:46 <skorpan> and is there any way to simulate command line arguments in ghci?
12:59:00 <gwern> yes
12:59:01 <skorpan> say that i have "args <- getArgs" in my main... how would i make that work in ghci?
12:59:01 <int-e> int80_h: (I didn't see it at first, but the sortListByTangent function uses a different pivot in its recursive call than in the other calls. And that's the real problem.)
12:59:03 <dpratt71> ddarius: in C# I can do call-by-name using delegates...I can't see how it applies to my example, though
12:59:27 <int80_h> int-e : a is P
12:59:33 <pejo> skorpan, have a main2 that is called from main with the arguments in a string
12:59:51 <skorpan> pejo: i don't get it...
13:00:09 <ddarius> dpratt71: You do realize to actually pass 'a' to something, you'd have to pass a delegate, yes?
13:00:13 <kerlo> :set args, isn't it?
13:00:21 <int-e> int80_h: yes, in the outermost call it is. Now look at the first recursive call of sortListByTangent ... it uses a different point for a!
13:00:22 <pejo> skorpan, main = do args <- getArgs; main2 args, and put what you had in main before into main2.
13:00:24 <kerlo> :set args <arg> ...         set the arguments returned by System.getArgs
13:00:24 <gwern> wasn't it :main?
13:00:39 <int80_h> int-e : the ouput of sortListByY guarantees that the first point in the list is point P. This is the list that gets passed to the (now) sortListByCoTangent
13:00:51 <pejo> skorpan, or do as Kerlo says. :-)
13:00:56 <ddarius> You realize that if you wrote b x = x + 2 and the b a, it would not translate to b(a()) or b(a())().
13:00:57 <skorpan> okay
13:00:58 <pejo> kerlo, has that feature been around for long?
13:01:01 <dpratt71> ddarius: yes, I realize that, but in this case would you consider that I'm passing 'a'?
13:01:13 <ddarius> dpratt71: No, but it's still call-by-name.
13:01:17 <kerlo> pejo: it's been around as long as I can remember.
13:01:38 <int-e> int80_h: sortListByCoTangent calls itself recursively, right?
13:02:06 <int80_h> int-e: I've made many changes. I'll re-post. Sort answer is yes. It recurses
13:02:11 <ddarius> dpratt71: The "call" part might be misleading you.
13:02:22 <dpratt71> ddarius: maybe so
13:02:28 <ddarius> dpratt71: And you are passing a to the + function.
13:02:46 <dpratt71> ddarius: good point, wrt the + function
13:02:48 <int80_h> int-e : http://hpaste.org/14047#a4
13:02:55 <ddarius> So your translation of b is technically wrong for a different reason, albeit not something you can easily fix in C#.
13:03:24 <int-e> int80_h: the problem is still the same: a is not passed to the recursive call, so it will use a different pivot.
13:03:52 <gwern> hm. what's the math symbol for 'is convertible to', ie a -> b && b -> a ?
13:04:06 <dons> gwern: oh, i want it to build out of the box (or not) with ghc 6.10
13:04:08 <vixey> gwern, =
13:04:09 <dpratt71> ddarius: not with (+) per se, but I can render laziness in C#...
13:04:18 <dons> gwern: i had to add --constraint='base<4' to most of them
13:04:20 <gwern> vixey: no, that's identity :) I know that one
13:04:35 <vixey> gwern, = with 3 lines if you want to disambiguate
13:04:37 <dpratt71> ddarius: ...I'm just concerned that the facts may distract from the understanding
13:04:38 <ddarius> dpratt71: Technically, laziness = call-by-need (which is indeed easy to render in C#), not call-by-name.
13:04:52 <ddarius> dpratt71: That's why I suggested just adding a note.
13:04:54 <gwern> vixey: does it have a name I can google for the unicode symbol?
13:05:10 <Pellwurst> does anyone know how to write a concatM function for Monads, similar to e.g. mapM
13:05:27 <ddarius> Pellwurst: What would it's type be?
13:05:30 <dpratt71> ddarius: how do you describe the differences re: need vs. name
13:05:37 <dpratt71> ddarius: ?
13:05:48 <chessguy_work> @hoogle (Monad m) => m a -> m a -> m a
13:05:49 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
13:05:49 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
13:05:49 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
13:05:51 <Pellwurst> its io
13:06:02 <int80_h> int-e: okay I'm totally confused. In my function sortListByY, I also don't pass a to the recursive call. But I don't have the same problem you pointed out
13:06:25 <ddarius> dpratt71: call-by-need is call-by-name with sharing.
13:06:36 <int-e> int80_h: that's because there is no pivot - you can compare two points without any additional data
13:06:43 <gwern> 'The symbol "â¡" (Unicode character 2261) is often used to indicate an identity, or a congruence relation in modular arithmetic. The symbol "â" can be used to express that an item corresponds to another.'
13:06:45 <chessguy_work> @hoogle (Monad m) => m [a] -> m [a] -> m [a]
13:06:46 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
13:06:46 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
13:06:46 <lambdabot> Control.Concurrent mergeIO :: [a] -> [a] -> IO [a]
13:07:19 <gwern> I like the second one. looks like a hamburger
13:07:25 <dpratt71> ddarius: are you referring to "memoization" obviating the need to call a function more than once with the same inputs?
13:07:40 <ddarius> dpratt71: NO.  Memoization is something else entirely.
13:08:00 <int80_h> int-e : I don't see how to pass "a" in the recursive call without screwing up the recursion.
13:08:19 <gwern> vixey: better actually seems to be â
13:08:22 <ddarius> dpratt71: I'm saying when you write a = 2+2; b = a + a, 2+2 only gets evaluated once and then stored into a which is then used for the second occurence of a.
13:09:26 <dpratt71> ddarius: is not what you're describing a form of memoization? I realize 'a' is constant, but...
13:09:47 <int-e> int80_h: http://hpaste.org/14047#a5 ... if you really don't want to use the library sortBy, implement your own one.
13:10:02 <int-e> @src on
13:10:03 <lambdabot> (*) `on` f = \x y -> f x * f y
13:11:32 <ddarius> dpratt71: If you view values as functions as you are doing, you can view them as having type () -> a and then it would correspond to memoizing on the (single) input () to functions of that type, but it does not generalize and in practice if you do actually write a value f :: () -> Int; f () = 3 it will not be "memoized" in this way.
13:11:36 <int80_h> int-e: it's not a matter of wanting to or not wanting to. If certain constructs or functions haven't been introduced yet, I have to believe it's for a reason
13:11:57 <int80_h> and I would be doing myself a disservice by using things I know about, but have not been introduced yet
13:12:05 <dpratt71> ddarius: don't confuse me with the facts ;)
13:12:24 <ddarius> dpratt71: Just don't use the word "memoization" at all.  No implementation of Haskell does memoization.
13:12:31 <int-e> int80_h: oh and the easiest way to pass the "a" in would be something like http://hpaste.org/14047#a6
13:13:00 <int-e> int80_h: (I called 'a' 'p' for 'pivot', but that's a detail)
13:13:02 <dpratt71> ddarius: I shall delete it from my vocabulary...wait, what was the word again?
13:13:59 <int-e> int80_h: I believe the RWH authors would disagree. (dons? care to chime in?)
13:15:02 <int80_h> int-e: in an earlier exercise, if I was able to use constructs that hadn't been introduced yet, I would have missed an important fact about pattern matching.
13:15:04 <ddarius> dpratt71: There's a common misconception that laziness means that Haskell "memoizes everything" so people complain that comparing e.g. fib 0 = 1; fib 1 = 1; fib n = fib (n-1) + fib (n-2) to equivalent definitions in other languages is "unfair" because Haskell will "memoize" this and produce a linear version.  That is not the case at all as a quick fib 100 will amply demonstrate.
13:16:17 <dpratt71> ddarius: I wasn't under that misconception...in fact I was surprised that Haskell would evaluate 'a' once and only once
13:16:42 <dpratt71> ddarius: I assumed it was either compiled as a constant value or as a function
13:16:47 <ddarius> dpratt71: I didn't think you were, but others are or easily get led to that misconception especially if memoization is brought up.
13:17:47 <dpratt71> ddarius: side-note: are there languages that do memoization or is that merely conceptual?
13:18:01 <vixey> Haskell does memoization :)
13:18:10 <int-e> @index comparing
13:18:10 <lambdabot> bzzt
13:18:27 <ddarius> dpratt71: There is no remotely practical language that does memoization on all arguments all the time.  It's easy enough to add annotations or functions that will do it to any language.
13:19:11 <dpratt71> ddarius: agreed as to the practicality...does Haskell have such annotations?
13:19:19 <vixey> fib 0 = 1; fib 1 = 1; fib n = fib' (n-1) + fib' (n-2)
13:19:24 <vixey> fib' n = fibs !! n
13:19:28 <vixey> fibs = map fib [0..]
13:19:28 <ddarius> dpratt71: No, but you can easily write functions to do it so it has no need for them.
13:19:47 <vixey> dpratt71, compare my 3 lines with ddarius' original version
13:19:52 <vegai> hah! http://article.gmane.org/gmane.comp.lang.haskell.cafe/50951
13:19:55 <vixey> (try fib 100 with both of them)
13:20:23 <int-e> vegai: yupp. roconnor made my day :)
13:21:04 <dpratt71> vixey: there are things in Haskell that screw with my mind, but so far that about takes the cake
13:24:45 <ddarius> dpratt71: Without optimizations your b = a + 2 is compiled roughly like:  class Thunk<A> { bool isEvaluated; A result; Action<A> action; Thunk(Action<A> f) { isEvaluated = false; result = null; action = f; }; static int operator()() { if(!isEvaluated) { result = action(); action = null; isEvaluated = true; }; return result; } }; Thunk<int> b = new Thunk(delegate { return a() + 2; };
13:25:07 <ddarius> You'll have to paste that to a file and format it to ease reading.
13:25:44 * gwern edits a little essay on my gitit. man, between markdown, the unicode symbols and pandoc, it's a nice looking page
13:25:52 <ddarius> Oh, and the operator() declaration is wrong but you should get the idea.  I forget if C# even allows that.
13:27:22 <dpratt71> ddarius: very interesting
13:28:01 <defun> how would i convert a long string of whole numbers into a list of whole numbers?
13:28:15 <Heffalump> defun: separated how?
13:28:35 <dpratt71> ddarius: in C# you can overload a very basic set of operators and only on a specific class
13:28:50 <gwern> > (map read "12334567895332") :: [Int]
13:28:51 <lambdabot>   Couldn't match expected type `String' against inferred type `Char'
13:29:05 <gwern> hm.
13:29:05 <capitrane> what does ghc mean with " Could not find module `Data.Array.IArray':
13:29:08 <capitrane>       it is a member of package array-0.2.0.0, which is hidden"
13:29:21 <gwern> > (map read $ map return "12334567895332") :: [Int]
13:29:22 <lambdabot>   [1,2,3,3,4,5,6,7,8,9,5,3,3,2]
13:29:25 * trygvis pokes jberg- 
13:29:26 <gwern> there we go
13:29:36 <defun> thanks.
13:29:46 <gwern> capitrane: deit the cabal file to add a 'array' into build-depends
13:30:19 <ddarius> I program C# for a living, I just forgot whether you could (I've also programmed in C++ for years where you can.)  I'm pretty sure you can't but you can make a delegate return function to get this behavior with this syntax.
13:31:19 <dpratt71> ddarius: you're pretty sure, but I'm certain you can't do that
13:32:00 <ddarius> dpratt71: You can't get operator overloading, but you can get this example and many like it.
13:32:56 <ddarius> static Action<A> MakeThunk(Action<A> action) { A result = null; bool isEvaluated = false; return delegate { if(!isEvaluated) { result = action(); isEvaluated = true; action = null; }; return result; }; }
13:33:20 <ddarius> Action<int> b = MakeThunk<int>(delegate { return a() + 2; });
13:33:52 <ddarius> Alternatively you could overload the [] syntax.
13:34:02 <dpratt71> ddarius: yeah, that second one looks doable
13:34:11 <mauke> whoa, what's going on here
13:34:11 <capitrane> i am trying install http://andrew.bromage.org/darcs/numbertheory/ package but ghc complains about the arrays, i updated the array with cabal to the latest
13:36:32 <ddarius> A result = null; needs to be replaced with A result = default(A), but otherwise that should compile with MakeThunk put into some static class (and a defined).
13:37:01 <dpratt71> ddarius: just to be pedantic, I think you want Func<A>, not Action<A>
13:37:13 <gwern> hm, the new diff handling in gitit is much better; who'd've thunk the Diff package would produce so much more pleasing results than 'diff'?
13:37:56 <ddarius> dpratt71: Func<A> isn't defined in C# 2.0 I don't believe.
13:38:15 <ddarius> Ah, but you are right.
13:38:23 <ddarius> I had the result and argument backward.
13:40:36 <dpratt71> ddarius: this is all very well and good, but if I add that to the post, folks are going to run away screaming :)
13:40:49 <ddarius> dpratt71: Which is why I never suggested you do that.
13:41:15 <dpratt71> ddarius: just sayin'
13:41:47 <ddarius> dpratt71: Of course if they could understand that C# code, they'd be well positioned to understand FP and Haskell.  (In fact, they'd probably already understand FP.)
13:42:16 <dpratt71> ddarius: hence my post would be even more useless ;)
13:42:33 <ddarius> dpratt71: GHC doesn't actually work quite that way, instead it updates the actual function pointer so that there is no need for an "isEvaluated" check.
13:42:45 <dpratt71> ddarius: makes sense
13:43:19 <dpratt71> ddarius: is t
13:43:30 <dpratt71> ddarius: ignore that
13:48:25 <pumpkin> roconnor: I love your clarification on the bool type :D
13:49:16 <ddarius> pumpkin: I know!  It makes it so clear that Bool is preserved by the left adjoint (,) a and so (a,Bool) ~ Either a a!
13:49:31 <pumpkin> I'm sure this will go a long way to appeasing coppin & co. :)
13:50:32 <pumpkin> ddarius: sure! I know just what you mean ;)
13:50:41 * pumpkin jumps up and down with excitement
13:51:22 <monochrom> <3 #haskell
13:52:06 <roconnor> pumpkin: Cale unwittingly helped too
13:52:38 <ddarius> @users
13:52:38 <lambdabot> Maximum users seen in #haskell: 653, currently: 636 (97.4%), active: 14 (2.2%)
13:52:39 <dpratt71> pumpkin: I think I just read what you're referring to...thanks a bunch for ruining my career because I no longer understand boolean math
13:53:00 <pumpkin> dpratt71: :P blame roconnor :) it means nothing to me either :)
13:53:14 <pumpkin> (and Cale too, apparently)
13:53:18 <gwern> you know, before I understood Bool. after reading those emails, I have no idea what it means anymore
13:53:28 <gwern> now the concept of negative knowledge makes sense to me
13:53:35 <dpratt71> pumpkin: fine, but you share the blame for bringing it to my attention :)
13:54:40 <pumpkin> sowwy :-[
13:55:24 <ddarius> Yes, but now we know that Booleans are for high falutin' ivory tower types and have no significance to real world programmers.
13:56:34 <ddarius> Just think of all the language features you can avoid using: if, while, for, etc.  Remove these from your language and just imagine how much simpler it will be.
13:58:28 <pao> hi all :-)
13:58:48 <pao> can anyone suggest any more idiomatic wat to do this? http://hpaste.org/14068
13:58:56 <mauke> yeah, we don't need loops, jumps or recursion
13:59:20 <monochrom> hahaha
13:59:43 <mauke> all you need is the ability to copy yourself
14:00:14 <monochrom> Who needs "if (x>0) A else B" when you can do (x>0)*A + (!(x>0))*B.
14:00:28 <roconnor> sartak write ``That's the least accessible documentation I've seen.''
14:00:36 <monochrom> There are also hacks using sqrt and abs to replace "if".
14:00:39 <roconnor> That is exactly the response I was aiming for :D
14:00:40 <pumpkin> can you call if a catamorphism on booleans, and thus make it "ivory tower" material too?
14:00:48 <ddarius> monochrom: You can't use x>0 or ! !
14:00:53 <pumpkin> useless to real programmers
14:01:06 <dons> ?users
14:01:07 <lambdabot> Maximum users seen in #haskell: 653, currently: 636 (97.4%), active: 15 (2.4%)
14:01:11 <ddarius> pumpkin: It is the catamorphism for booleans.
14:01:21 <Botje> pao: the second can be written as map (second return)
14:01:21 <pumpkin> yay, more useless stuff
14:01:34 <Botje> (the list comprehension, that is)
14:01:35 <dpratt71> ddarius: you've inspired another silly question: 1. what is the nature of "if" in Haskell? It's not a function, right?
14:01:38 <pumpkin> we're whittling away what those poor programmers have to work with
14:01:45 <monochrom> Oh, the sqrt and abs hacks can replace "x>0" too. I saw a post in alt.algebra.help going into great lengths doing it.
14:01:45 <dons> so its just a tension: haskell is all about applying new ideas to programming. sometimes they'll have funny names and formal definitions. but we also want to be accessible.
14:01:49 <pumpkin> there's an if' / bool
14:01:51 <pao> Botje: let me try...
14:01:53 <pumpkin> (idea)
14:02:00 <ddarius> dpratt71: It could be a function, but it's just syntactic sugar for case.
14:02:12 <dons> it will always mean there is background work and new terms people aren't familiar with
14:02:15 <pumpkin> dpratt71: I'd like to get rid of it myself :P it feels out of place
14:02:18 <ddarius> Of course if it was a function it would be using pattern matching which is again just syntactic sugar for case.
14:02:20 <dons> so we should just make sure people can find out what those things mean, if we use   them
14:02:34 <ddarius> dpratt71: You could, if you like, get rid of the case and use only functions.
14:02:42 <Heffalump> dons: that would certainly help a lot
14:03:07 <dons> then we wouldn't need to worry about using 'monoid' say.
14:03:09 <Heffalump> but I think it's more than that; there's a cognitive cost to any new term, however easy it is to find out the meaning of it, when learning something
14:03:17 <dons> yep
14:03:20 <mauke> if c t e = [e, t] !! fromEnum c
14:03:21 <pumpkin> I think the new monoid docs look a lot better
14:03:26 <dons> so reuse where appropriate, and explain where necessary
14:03:30 <dons> but don't dumb things down.
14:03:31 <Heffalump> think about understanding code you haven't seen before, in a language you do know
14:03:39 <dpratt71> thanks for the explanation, ddarius & pumpkin
14:03:45 <dons> the tension is that the background of obviousness is shrinking as the community grows
14:03:49 <dons> less people have read all the papers.
14:03:55 <Heffalump> you have to keep re-reading it, graduallying filling in understanding of how bits work and what the calls to external pieces are for
14:04:01 <dons> so we need to do more linking and explaining up front. more documenting
14:04:05 <pumpkin> dpratt71: if you use an if in @pl, for example, it'll give you back an if' function that doesn't really exist (but could be defined easily)
14:04:08 <ddarius> dpratt71: I rarely use if-then-else or case.  I usually use guards and pattern matching.
14:04:28 <olsner> wow, over 650 users here now! failing yet again not to succeed...
14:04:48 <ddarius> olsner: The actual high is 674 I believe.
14:05:11 <mauke> if' should go in Data.Function
14:05:21 <ddarius> It should go somewhere, that's for sure.
14:05:23 <dpratt71> "if" is dependent on the Bool type, right? Are there other cases where syntax takes a dependency on a specific type?
14:05:35 <ddarius> dpratt71: List comprehensions.
14:05:44 <dpratt71> oh, shoot, gotta run but I'll be back..
14:05:47 <gwern> olsner: we fail at fail
14:05:50 <mauke> guards
14:06:06 <mauke> n+k patterns
14:06:38 <ddarius> mauke: Then so do numeric patterns.
14:06:55 <mauke> yep
14:07:30 <mauke> the list syntax in general, string/character/numeric literals
14:07:38 <gwern> http://code.haskell.org/~dons/code/liboleg/ -_-
14:07:49 <ddarius> mauke: lambda notation
14:07:53 <mauke> heh
14:08:51 <gwern> http://www.haskell.org/pipermail/haskell-cafe/2009-January/053754.html <-- I wonder why pipermail doesn't verify emails automatically but waits for you to click the button
14:08:54 <dons> i need to finish that work, gwern. thanks for reminding me.
14:09:43 * gwern gladly takes the credit
14:10:12 <ddarius> pao: The code looks reasonable enough.
14:10:56 <pao> ddarius: thanks
14:11:29 <pao> :t fromListWith (++) . (map $ \(a,c) -> (a,[c]))
14:11:31 <lambdabot> Not in scope: `fromListWith'
14:11:46 <pao> :t Data.Map.fromListWith (++) . (map $ \(a,c) -> (a,[c]))
14:11:47 <lambdabot> forall a k. (Ord k) => [(k, a)] -> M.Map k [a]
14:11:57 <ddarius> :t Data.Map.fromListWith (++) . map (second return)
14:11:58 <lambdabot> forall b d. (Ord d) => [(d, b)] -> M.Map d [b]
14:12:33 <ddarius> :t Data.Map.fromListWith (++) . map (second (:[]))
14:12:33 <olsner> ooh, wiki-editable documentation linked to the source repositories... that's actually quite awesome
14:12:34 <lambdabot> forall b d. (Ord d) => [(d, b)] -> M.Map d [b]
14:12:43 <pao> ddarius: nice ... you return in the list monard... right?
14:12:49 <ddarius> pao: Yes.
14:12:55 <ddarius> But that's somewhat abusive.
14:12:57 <dons> olsner: worked for RWH. I think it might be the next big efficiency gain
14:13:02 <pao> ddarius: why so?
14:13:07 <dons> i'd definitely like to see that get up for the summer of code.
14:13:26 <dons> so it would look exactly like the current haddocks. but you could edit it. saving a patch that's sent in.
14:13:32 <monochrom> dons's point reminds me of computer manuals. (I just bought a new laptop, and out of boredom I flipped through its manual.) They have a "glossary" section at the end, e.g., "data: information that is factual, measurable or statistical that a computer can process, store, or retrieve", "delete: to remove data from a disk or other data storage device. Synonymous with erase."
14:13:36 <olsner> and haddock really should fix the thing with the anchor names
14:13:44 <pumpkin> ddarius: how's it abusive?
14:13:49 <dons> monochrom: huh
14:13:53 <dons> a haskell glossary?
14:13:59 <dons> why don't we have such a think!?
14:14:01 <dons> g.
14:14:14 <ddarius> pao, pumpkin: It's somewhat unreasonable.  The equivalent (:[]) is shorter and clearer and more explicit (if slightly harder to type)
14:14:20 <dons> i guess hoogle is somewhat of a glossary
14:14:21 <roconnor> I actually just barely know enough category theory to make that post.
14:14:33 <roconnor> This is part of the reason I got some arrows backwards
14:14:42 <monochrom> Look at the examples I chose! :)
14:14:54 <pao> ddarius: what I was missing was second :-)
14:15:05 <roconnor> I haven't yet made a million push out diagrams in my life.
14:15:11 <pao> :t sencond (:[])
14:15:12 <lambdabot> Not in scope: `sencond'
14:15:15 <ddarius> pao: I'm not saying that these versions are much clearer than the code you started with.
14:15:23 <blip> to define a new monad would I need : instance Monad X where...?
14:15:29 <pao> ddarius: yep... I understand
14:15:36 <ddarius> I'd probably have written them that way, but I don't particularly care how readable most of my code is to people who aren't me.
14:15:40 <pumpkin> blip: you need a bind, a return, at least
14:16:03 <roconnor> @seen dcoutts
14:16:04 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 2h 22m 52s ago.
14:16:09 <olsner> (nm, that haddock bug is marked as fixed now)
14:16:51 <pao> ddarius: It's a useful exercise, at least for me, in order to understand what can be considered idiomatic in haskell
14:16:55 <pumpkin> blip: in general, in typeclass documentation, you'll see things about "minimal complete definition"
14:17:01 <pao> :t second (:[])
14:17:02 <lambdabot> forall b d. (d, b) -> (d, [b])
14:17:08 <pumpkin> blip: in Monad's case, it says "Minimal complete definition: >>= and return."
14:17:10 <ddarius> roconnor: Here's a great exercise from Toposes, Triples and Theories.  There are two functors 1 -> 2 where 2 is the category consisting of two objects and one non-identity arrow.  What is their coequalizer?
14:17:17 <pao> :t id *** (:[])
14:17:18 <lambdabot> forall a b'. (a, b') -> (a, [b'])
14:17:42 <roconnor> coequalizer means subset right?
14:18:16 <monochrom> I think coequalizer generalizes equivalence relation.
14:18:24 <roconnor> oh, I thought that was equalizer
14:19:15 <monochrom> I was actually surprised at the co part.
14:19:19 <ddarius> No.  If we call the two functors f and g : 1 -> 2, the coequalizer would be a functor e : 2 -> CoEq(f,g) such that for any arrow h : 2 -> X such that h . f = h . g there exists a unique arrow h* : CoEq(f,g) -> X.
14:19:32 <papermachine> Isn't that N?
14:19:43 <ddarius> papermachine: Yes.
14:19:53 <dons> yay for new bloggers and the haskell culture. http://nattermorphisms.blogspot.com/2009/01/category-theory-of-appendages.html
14:20:11 <ddarius> roconnor: Coequalizers are related to quotients and thus to equivalence relations.
14:20:18 <roconnor> oh
14:20:28 <roconnor> then equalizers are about subsets?
14:20:53 <dons> dcoutts_: gtk2hs getting updated for 6.10 soon?
14:21:08 <ddarius> roconnor: They are related to them.  Monomorphism are usually used but "regular monomorphism" are those monomorphism that are the mediating map of an equalizer (all such maps being monomorphisms).
14:21:43 <ddarius> monochrom: The equalizer of those two functors would be the empty category.
14:22:36 <monochrom> Oh! Oops, quotient, not exactly relation.
14:24:08 <ddarius> Another fun related example is to consider the equivalent scenario in the category of graphs and graph homomorphisms and to compare the coequalizer to the pushout.
14:24:35 <olsner> hmm, if I define a foo-set as a set that contains exactly one foo-set, how many distinct foo-sets are there?
14:25:08 <ddarius> olsner: With well-foundedness, none.
14:25:13 <Elly> you also need a base case
14:25:15 <olsner> d'oh :)
14:25:23 <ddarius> Without well-foundedness, an incomprehensible number.
14:25:30 <Elly> if you have a base case, there are countably infinite of them
14:25:33 <ddarius> s/number/cardinal/
14:26:15 <ddarius> Actually, a proper class of them.
14:27:54 <blip> would it make any sense to create a matrix monad to do something that always emits a Matrix?
14:28:10 * ddarius goes to eat chinese food.
14:28:42 * olsner attempts to leave the computer and go to bed
14:30:33 <skorpan`> where can i find the documentation for regex.tdfa?
14:32:42 <dons> skorpan`: on hackage?
14:33:01 <skorpan`> can't seem to find it :|
14:33:03 <skorpan`> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regex-tdfa
14:34:09 <olsner> skorpan: :browse :P
14:34:33 <skorpan`> que?
14:34:41 <skorpan`> that's it?
14:35:13 <olsner> no, not really a serious solution that, but it is available as a fall-back
14:35:55 <olsner> iirc, it follows the interface of another regexp library precisely, so you can just change the imports to point to TDFA to use that instead of posix or pcre regexps
14:38:10 <blip> would it make any sense to create a matrix monad to do something that always emits a Matrix?
14:38:18 <blip> and a printmonad?
14:38:53 <olsner> skorpan: that is, look at the docs for http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regex-base-0.93.1 and that'll tell you how to use regex-tdfa as well
14:39:04 <pumpkin> blip: what would bind do?
14:39:14 <blip> like if i do maniplations on my matrix which go like matrix -> do stuff on array -> matrix. could i then abstract some if out with a monad?
14:39:19 <Cale> roconnor: I love your documentation for Bool :)
14:39:19 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
14:39:36 <blip> or does all use of monads "trap" the computation nside it?
14:39:47 <mauke> blip: [] is a monad
14:39:54 <mauke> I don't know if that helps
14:39:55 <pumpkin> blip: nope, but it sounds like you just want a "matrixMap" function or something?
14:40:24 <olsner> yeah, roconnor++ for Bool docs :)
14:40:33 <blip> and could I have a DebugMonad that somehow print all the args of a function?
14:40:40 <mauke> monads aren't magic :-)
14:40:44 <Cale> blip: Matrices might just form a monad, but the join would be a little odd...
14:41:00 <Cale> blip: You need a canonical way to turn a matrix of matrices into a matrix.
14:41:20 <eyeris> I'm trying to install happs but I am getting an error from SearchPath that I don't know how to solve: http://hpaste.org/14007
14:42:06 <blip> pumkpin: well i have a foreach function but all my matrix functions involves a lot of annoying donking around with datastructures. i need better abstractions
14:42:17 <mauke> you need three operations: a constructor to wrap arbitrary values (a -> M a), a way to map through your type ((a -> b) -> M a -> M b), and something to collapse nested values (M (M a) -> M a)
14:42:23 <mauke> then you have a monad
14:42:29 <Cale> blip: Probably what you need is not a monad, but just some decent higher-order functions.
14:43:49 <blip> Cale: i guess
14:44:19 <loadquo> What dimensionality matrix?
14:44:34 <Cale> blip: If you're looking for inspiration, you might check out Conal's linear algebra library, and perhaps some of the others that are on hackage. It actually doesn't have explicit *matrices* as such, but rather abstract linear maps.
14:45:14 <Cale> There's hmatrix, which does do matrix stuff directly.
14:47:42 <Cale> Oh, Conal's library is called vector-space
14:52:24 <monochrom> Referring to an earlier discussion, here is the alt.algebra.help thread of the (disgusting) attempt to eliminate "if" and ">": http://groups.google.com/group/alt.algebra.help/browse_thread/thread/1c7577de66928508/2ea97ccd724f7921?#2ea97ccd724f7921
14:55:23 <roconnor> eliminating if and > is helpful for real number expressions
14:55:36 <roconnor> although not /really/ necessary
14:57:05 <stingeraj> where can i learn about simple record syntax?
14:57:45 <BONUS> most tutorials cover record syntax sooner or later :)
14:57:56 <BONUS> are you going by any specific tutorial maybe
14:58:16 <stingeraj> is there a simple way to request a field from from a record without using curly brackets?
14:58:17 * monochrom thinks about suggesting the haskell report. :)
14:58:46 <monochrom> try: field_name record_variable_name
14:59:03 <Saizan_> eyeris: don't use searchpath
14:59:13 <BONUS> data Foo = Foo {a :: Int, b :: Int}
14:59:14 <Saizan_> eyeris: just "cabal install HAppS-Server"
14:59:17 <kmeyer> anyone intimate with ghc development?
14:59:23 <BONUS> and then you can do: a foo
14:59:29 <BONUS> where foo is a value of type Foo
14:59:30 <BONUS> or b foo
14:59:36 <BONUS> basically the field names are functions
14:59:39 <Saizan_> eyeris:  http://articles.bluishcoder.co.nz/Haskell/NotAHAppSTutorial
14:59:46 <stingeraj> ah cool, thx BONUS
15:00:13 <mgs> hey guys, i breezed through 'real world haskell' last night and I'm very interested in exploring deeper. I have a sort of odd use for programming though and wanted to see if there is any reason Haskell might not be the best fit (seems superb to me, i use scheme/C mostly now)
15:00:33 <BONUS> what do you program
15:00:36 <mgs> I use programming as a means for generating massive data sets that are semi-random
15:00:49 <mgs> BONUS: sorry hadn't mean to hit enter before ;)
15:00:55 <BONUS> ah haha
15:00:55 <ehird> here is the language for you: random()
15:00:55 <mgs> i'm an architect
15:00:55 <ehird> :P
15:01:01 <ehird> [random(),random(),random()] :-D
15:01:10 <BONUS> mgs: i think haskell is a very good fit for that
15:01:14 <mgs> and i use programming as way to create my own tools
15:01:20 <BONUS> because you can use types to your advantage
15:01:34 <BONUS> for instance, are you familiar with QuickCheck?
15:01:45 <mgs> BONUS: no, not yet
15:01:54 <kmeyer> :t liftM
15:01:55 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:01:56 <BONUS> you give it a function and then it generates a lot of random data to feed to that function to test it
15:02:15 <mgs> BONUS: can you specify rulesets?
15:02:25 <BONUS> it figures out what kind of data to generate based on the types of your functions etc.
15:02:31 <mgs> BONUS: ahhh
15:02:35 <mgs> very neat!
15:02:42 <kmeyer> > liftM repeat random
15:02:44 <lambdabot>       Overlapping instances for Show (g -> [(a, g)])
15:02:44 <lambdabot>        arising from a us...
15:03:01 <BONUS> check out chapter 11 of rwh for more info on it :)
15:03:18 <mgs> BONUS: I think i might go back to the bookstore and buy rwh tonight
15:03:29 <mgs> BONUS: i was on the fence but have been thinking about it nonstop
15:03:37 <BONUS> haha, it's definitely a good buy
15:04:39 <mgs> BONUS: are there any other definitive resources to make sure I know of?
15:04:52 <mgs> BONUS: i've perused the topic
15:04:58 <BONUS> you mean on QuickCheck or haskell in general?
15:05:56 <mgs> BONUS: in general really, (my other focus in programming is on pattern analysis where I often use perl( :(((( ) )
15:06:52 <BONUS> check out this page http://haskell.org/haskellwiki/Books_and_tutorials 8)
15:07:34 <BONUS> but either way, haskell is great to learn because there's a very good chance it will be useful somehow and a 100% chance that it'll be a fun and insightful learning experience
15:07:46 <mgs> BONUS: cool ;)
15:07:48 <BONUS> that broadens your horizons, ekcetera
15:07:49 <BONUS> :]
15:07:52 <mgs> BONUS: that's all i want really
15:08:13 <BONUS> it gets you in a whole new mindset and that's really fun
15:08:15 <mgs> BONUS: i learn best through new perspectives
15:08:41 <mgs> BONUS: totally!! haha, well, i'm off to begin then. see you again soon ;)
15:08:48 <BONUS> i remember learning about some new concept in haskell and understanding it and then finding myself literally grinning
15:08:52 <BONUS> haha, see ya!
15:09:01 <mgs> BONUS: i love that feeling
15:09:33 <erikc> does anyone have an image of the cover of spj's book?
15:09:44 <erikc> its the one book in my delicious library with no cover :P
15:10:52 <mgs> BONUS: one other quick thing, how easy to work with haskell and CGI?
15:11:11 <ehird> mgs: pretty easy, but you want to use a more advanced framework, probably
15:11:50 <mgs> so for super simple scripting i would still want to use something like perl/php?
15:12:02 <pumpkin> erikc: that's unacceptable!
15:12:16 <erikc> totally, if i cant find a cover its getting deleted
15:12:48 <erikc> right now i have this picture instead, which is charming in its own way: http://www.dotnetrocks.com/dnr_photos/SimonPeytonJones.jpg
15:13:08 <BONUS> yeah, usually for web stuff i find it easier to use python
15:13:13 <pao> ddarius: thanks for the help
15:13:17 <BONUS> although there are a few haskell web frameworks and such
15:13:31 <BONUS> happs is pretty solid i hear now, and turbinado is getting off the ground
15:13:54 <ehird> 23:11 <mgs> so for super simple scripting i would still want to use something like perl/php?
15:13:59 <ehird> not neccessarily :)
15:14:28 <mgs> BONUS: what about doing lexical analysis? how difficult would it be to write basic parsing tools?
15:14:39 <mgs> ehird: :)
15:14:42 <BONUS> haskell owns at parsing
15:14:50 <BONUS> one of its major strong suits really
15:14:51 <mgs> i'm sold then
15:15:03 <ehird> mgs: oh heck yes
15:15:04 <BONUS> you can make parsers that look like grammar more or less
15:15:05 <ehird> Parsec
15:15:08 <BONUS> and then you just run them
15:15:08 <monochrom> mgs: Congratulations for ability and agility to learn from new perspectives. Most people can't do it.
15:15:11 <ehird> it's the best parser ever.
15:15:11 <mgs> i've been using lex/yacc
15:15:14 <ehird> eww
15:15:15 <ehird> :-)
15:15:20 <ehird> you'll never look back with parsec
15:15:22 <mgs> :)
15:15:34 <dons> text handling is like 15% of all haskell libraries, http://galois.com/~dons/images/chart-hackage.png
15:15:42 * roconnor wonders which nicks here are 15 year olds
15:15:43 * Saizan_ prefers ReadP
15:15:45 <dons> second largest category after data   structures (that we parse into)
15:15:54 <ehird> roconnor: wat?
15:16:03 <roconnor> oh damn, that sounded bad
15:16:11 <Valodim> hahaha
15:16:12 <roconnor> http://www.reddit.com/r/programming/comments/7mroa/why_is_haskell_so_popular_on_reddit_what_does_it/8mu0
15:16:17 <BONUS> and basically #haskell is really helpful and nice so you probably won't find yourself in need of assistance with no one to give it to you
15:16:18 <roconnor> I was reading that comment
15:16:36 <roconnor> for the record the comment states ``The vast majority don't have grad level CS. Seriously, drop by #haskell and talk to the 15 year old kids there.
15:16:36 <dons> roconnor: i was thinking of sorear :)
15:16:42 <ehird> i am 15![*]\n[*]: Blatant lie.
15:16:51 <BONUS> i'm a baby. literally a baby
15:17:01 <mgs> monochrom: ty ;) it's really nice to feel commended for that. it usually gets me into trouble! ;)
15:17:09 <mgs> i'm 26 :(
15:17:12 <mgs> haha
15:17:17 <roconnor> @seen sorear
15:17:18 <lambdabot> I haven't seen sorear.
15:17:39 <jeffwheeler> 18. I wonder what the avg age is?
15:17:50 <dons> my guess: around 22?
15:17:57 * loadquo is an old 29
15:18:00 <BONUS> 21 here
15:18:05 <ehird> 4 years old
15:18:06 <roconnor> wow
15:18:26 <ehird> yes. i am the best 4 year old haskell programmer in the world.
15:18:32 <jeffwheeler> I'm betting it's higher than 22; hard to get a PhD by 22. ;)
15:18:34 <Corun> Nope.
15:18:59 <monochrom> Old dogs can't learn new tricks. That's why 15-year-olds find Haskell so easy.
15:19:00 <roconnor> wow.  I unconisously assume everyone is a 31 year old like me.
15:19:02 <dons> jeffwheeler: but i think the majority of haskellers don't have grad. degrees.
15:19:10 <dons> maybe 10 years ago that was the majority, but not now.
15:19:14 <jeffwheeler> dons: bah :P
15:19:14 <Corun> Haskell _is_ easy ;-)
15:19:18 <mgs> dons: i have grad degrees :)
15:19:25 <ztirF> can anyone tell me why this doesn't work:
15:19:32 <ehird> wait, i missed a minus sign, I'm actually 4 years from birth.
15:19:35 <ehird> :|
15:19:36 <nomeata> Hi. Can someone explain me why http://hackage.haskell.org/packages/archive/category-extras/latest/doc/html/Control-Category-Monoidal.html#t%3AHasIdentity defines HasIdentity Hask (,) Void
15:19:37 <mgs> dons: but they didn't teach me much :\
15:19:39 <roconnor> I don't have a grad degree.  But don't ask me again in 6 months
15:19:47 <arjanb> i don't think the average is that young, #haskell isn't a phd student channel anymore
15:19:50 <dons> roconnor: :D
15:20:04 <dons> arjanb: right.
15:20:15 <nomeata> Iâd expect "HasIdentity Hask Either Void", as Either a Void seems equivalent to a, but not (a,Void).
15:21:36 <jeffwheeler> What is () called?
15:21:43 <leimy> openclose!
15:21:50 <jeffwheeler> :(
15:22:00 <leimy> ok not really
15:22:11 <Botje> jeffwheeler: i like to call it coin
15:22:15 <Botje> other people call it unit
15:22:26 <jeffwheeler> Unit! I think that's what I was thinking of . . . thanks. :)
15:22:28 * loadquo has an Computer related MSc but in something that didn't touch on category theory at all
15:22:46 * leimy had no category theory either
15:22:53 * jeffwheeler imagines most CS-graduates haven't worked with cat. theory at all
15:23:06 <leimy> Seems a shame too
15:23:10 <mgs> BONUS: hehe, i should have just said computational geometry when i was describing my area but in reality I'm deconstructing computational geometry. So 50% is historical 50% is manipulation/randomization
15:23:11 <leimy> it's pretty relevant :-)
15:24:23 <monochrom> () is called unit.
15:24:34 <BONUS> ah, cool
15:25:02 <mgs> I've had zero formal education in programming hehe, I started with k&r, read all of bwk's work, read SICP and a bunch of others.
15:25:31 <mgs> BONUS: but it's left me with a very strange way of looking at programming so most classical languages really really mess me up
15:25:52 <gwern> jeffwheeler: I'd imagine that most *functional programming* graduates don't touch on category theory!
15:25:59 <BMeph> mgs: Really? ;)
15:26:09 <mgs> BMeph: =) can't you tell?
15:26:28 <ztirF> does anyone know why I can't do this?
15:26:30 <ztirF> type Arr i a = (Ix i, IArray arr a) => arr i a
15:26:56 <bbs> > 256 + 8
15:26:58 <lambdabot>   264
15:27:04 <mgs> BMeph: but, i hope it will bring us new types of building systems so .. meh
15:27:26 <mgs> adios, thanks for the help guys. talk to you more i'm sure
15:27:42 <jeffwheeler> bbs: math is hard.
15:27:58 <bbs> jeffwheeler: i just wanted to see if that bot was back
15:28:08 <bbs> so i did a calculation for asm that i could have done in my head too
15:28:11 <loadquo> > succ succ succ succ succ
15:28:11 <jeffwheeler> bbs: sure . . . :P
15:28:12 <lambdabot>       Overlapping instances for Show (a -> a)
15:28:12 <lambdabot>        arising from a use of `s...
15:28:23 <bbs> jeffwheeler: err ok
15:28:25 <loadquo> Bah mis-type
15:28:33 <jeffwheeler> bbs: kidding, of course
15:29:19 <gwern> @version
15:29:20 <lambdabot> lambdabot 4.2.2
15:29:20 <lambdabot> darcs get http://code.haskell.org/lambdabot
15:29:41 <gwern> oops. I knew I forgot something
15:29:53 <roderyk> can that be some kind of lambdabot plugin? it will send private messages to users w/ math quiz questions and you need to reply within a certain time... :D
15:30:18 <gwern> faster than lambdabot could eval the problem?
15:31:21 <roderyk> it will be like the good ole' quake days; we'll have 56k'ers complaining about lag and timeouts
15:31:57 <gwern> oh wait, I don't need to manually update @version since it calls cabal
15:31:59 <gwern> cool!
15:32:43 <monochrom> "compute the pushout of f:Int->() and g:Int->Double"
15:33:58 <BMeph> monochrom: What's "pushout"? :)
15:34:09 <Gracenotes> @hoogle Monoid a => a -> Maybe a
15:34:10 <lambdabot> Prelude Just :: a -> Maybe a
15:34:10 <lambdabot> Data.Maybe Just :: a -> Maybe a
15:34:10 <lambdabot> Distribution.ParseUtils ignoreUnrec :: UnrecFieldParser a
15:34:18 <Gracenotes> :\
15:36:37 <bbs> jeffwheeler: well in that case :D -- i have had a long day :/
15:36:38 <ddarius> #haskell didn't seem to have a majority of PhD students or graduates when I arrived here.  I was 17 or 18 then.  I'm 24 now.
15:36:41 <bbs> thats why i'm testy
15:36:51 <ddarius> And I don't have a college degree of any sort.
15:36:56 <jeffwheeler> bbs: no worries
15:37:04 <bbs> ddarius: well there you go
15:37:10 <bbs> lots of college is overatted
15:37:25 <bbs> i see so many people wasting there parents money here
15:37:51 <loadquo> Colleges are ways of getting lots of smart people together and letting them do what they want to do, without costing the earth
15:37:56 <leimy> bbs: some of us paid our own way
15:38:43 <monochrom> loadquo is so ideal :)
15:39:22 <loadquo> Or that is the use I put them to :P
15:39:29 <bbs> leimy: thats true
15:40:33 <erikc> i learned all the wrong things at school ("ok, theres these languges, C, C++, Java, thats what you program computers in, fyi theres other languages, dont bother")
15:40:34 <loadquo> Which is possibly why I'm not at one at the moment.
15:40:45 <erikc> altho grad school looks tempting now as a socially acceptable form of unemployment :)
15:42:10 <sioraiocht> erikc: grad school is like being unemployed except without unemployment benefits, and you still have to work =p
15:43:00 <sioraiocht> erikc: That's due to a larger issue, imo, of universities being pressured into becoming worker factories instead of places of learning
15:44:07 <loadquo> Some universities are also pressured to be knowledge factories for businesses rather than places of exploration.
15:44:31 <erikc> yup :\, last year i replaced all my textbooks with 'the right books', im not sure how they decide what books to use for classes, but they had chosen pretty all the non-canon books for given topics
15:44:56 <monochrom> My impression is that most people are excited about college because they are excited about the prospect of getting drunk and laid every night.
15:46:01 <monochrom> Most US colleges are liberal arts colleges, and most programmes there are just more classes and more homework --- more highschool. Don't tell me they prepare you for jobs.
15:46:07 <loadquo> Monochrom, my initial comment was about grad students and above. The normal students just provide the cash to allow the grads+ to do what they want to do.
15:47:32 <xfls> can someone help me to write funcion for quadratic equations?
15:48:12 <monochrom> f x = x*x + 5*x - 4
15:49:43 <loadquo> xfls, generalise what monochrom wrote.
15:50:00 <loadquo> > f x = x*x + 5*x - 4
15:50:01 <lambdabot>   <no location info>: parse error on input `='
15:50:32 * loadquo 's lambdabot fu is weak
15:50:33 <xfls> i know what is quadratic equations, but i can not get the roots ot it using haskell and winhugs
15:50:47 <monochrom> lambdabot takes function definitions with a different command.
15:51:02 <xfls> roots :: (Float, Float, Float) -> (Float, Float)
15:51:02 <xfls> roots (a,b,c) = (x1, x2) where
15:51:02 <xfls> x1 = (-b+sqrt(b*b-4*a*c))/2*a
15:51:02 <xfls> x2 = (-b-sqrt(b*b-4*a*c))/2*a
15:51:17 <xfls> and i get Undefined variable "a" error
15:51:25 <monochrom> IIRC it's "@define f x = x*x + 5*x - 4".  And then the function becomes L.f, i.e., in the L module.
15:51:29 <beelsebob> xfls: you need to do some indentation
15:51:40 <beelsebob> specifically, x1 and x2 need to be more indented than roots
15:53:22 <erikc> anyone know what the state of the 'com' packages is? it seems to be a cabal packaging of hdirect, but the idl compiler isnt there
15:56:33 <ddarius> monochrom: multisorted algebra is sin!
15:56:34 <Cale> xfls: Your x1 and x2 definitions need more indentation
15:56:41 <ddarius> monochrom: That will undefine everything.
15:56:44 <ddarius> monochrom: It's @let
15:56:54 <Cale> xfls: They're part of the where clause, which is part of the definition of roots, so they should be indented more than it.
15:57:07 <Cale> ah, beelsebob already said that :)
15:57:12 <monochrom> multisorted algebra is strongly typed
15:58:03 <monochrom> But anyway I'm glad no one tried my faulty suggestion of @define
15:58:32 <xfls> yeah, but i can't understand what exactly do you mean. can you give me an example
16:00:15 * tristes_tigres just realized why bot is denoted as _|_
16:01:09 <monochrom> xfls: http://hpaste.org/14070  I also added necessary parentheses because blah/2*a is not what you think it is.
16:01:26 <dcoutts> dons: yes, gtk2hs will be released shortly I'm told
16:01:28 <dcoutts> roconnor: pong
16:01:57 <kmeyer> tristes_tigres: hm?
16:02:16 <tristes_tigres> kmeyer: what (_|_) looks like ?
16:02:26 <Peaker> the reddit thing about Haskell has so much about syntax and so little about semantics. its kind of sad.  Someone ought to get non-textual editor ready so people understand syntax is a superficial front for something much deeper
16:03:15 <kmeyer> tristes_tigres: open parens underscore pipe underscore close parens?
16:03:38 <monochrom> It does not explain why top is T
16:03:39 <tristes_tigres> kmeyer: use your imagination
16:03:47 <monochrom> Or rather, â¤
16:04:04 <tristes_tigres> monochrom: does too
16:04:11 <monochrom> kmeyer: think of (_|_) it as ASCII art
16:04:17 <kmeyer> :t bot
16:04:18 <lambdabot> Not in scope: `bot'
16:04:21 <kmeyer> :t _|_
16:04:21 <parodyoflanguage> Peaker, is there such a project?
16:04:22 <lambdabot> parse error on input `|'
16:04:27 <kmeyer> :t (_|_)
16:04:28 <lambdabot> parse error on input `|'
16:05:06 <monochrom> tristes_tigres: What is the explanation?
16:05:22 <Peaker> parodyoflanguage: There's subtext, but its not about Haskell. I really want to work on it, but probably won't have anything read until I go full time on this, which I plan to do in a couple of years or so
16:05:34 <Peaker> parodyoflanguage: Conal's Eros is a step in that direction too
16:06:04 <monochrom> @karma hpaste
16:06:05 <lambdabot> hpaste has a karma of 0
16:06:09 <tristes_tigres> monochrom: if you add two brackents and some suspesion of disbelief, it may look like a cleavage
16:06:35 <monochrom> Oh! I see now. You people are indecent and wicked!
16:06:52 <tristes_tigres> monochrom: took you that long too notice ?
16:06:57 <scsibug> tristes_tigres: are you just referring to the location of the horizontel bar? That is what i've always assumed as the reason for the denotation of bottom versus top types.
16:07:06 <monochrom> Yes, because I am decent and just.
16:07:14 <xfls> monochrom, thank you
16:07:31 <xfls> now i understand what what my problem..
16:07:35 <tristes_tigres> scsibug: not really, that would be too obvious
16:10:20 <Peaker> I think maybe "purity" is a bad name -- it implies that there's no escape from purity.  Perhaps "typed impurity" or "typed effects" would do better?
16:10:39 <scsibug> I guess i'm decent and just too, because my mind took way too long to go there.
16:10:41 <Peaker> To emphasize that the language just makes it clear what parts are pure and what aren't?
16:10:59 <monochrom> I do not agree about implying no escape.
16:11:14 <tristes_tigres> monochrom: were are not decent, but we are pure
16:11:32 <tristes_tigres> Peaker: I secobnd that
16:12:20 <monochrom> In fact in real life every time we talk about pure water, pure oxygen, ... we mean they are hard to get, and if you get them, they're surely to be polluted in no time.
16:12:25 <Peaker> monochrom: What do people think when they hear its "purely functional"? I think that when I first heard it, I thought "How could that be? It has no side effects at all?"
16:12:27 * tristes_tigres thinks calling Haskell "pure" is misleading
16:12:58 <cjb> tristes_tigres: is "supports purity" as problematic for you?
16:13:16 <dons> here's a fun graph: hackage version numbers per project over time: http://galois.com/~dons/images/hackage/vectors.png
16:13:20 <dons> aka how many things reach 1.0?
16:13:25 <tristes_tigres> cjb: That can be said about C/C++ too
16:13:40 <tristes_tigres> they too, "support" purity
16:13:40 <dons> just looking at the version releases from 0.0 to 2.0 http://galois.com/~dons/images/hackage/2.0.png
16:13:52 <pumpkin> tristes_tigres: forces you to keep impurity seperate?
16:14:02 <tristes_tigres> also, gallows support the exectued om it by his neck
16:14:16 <tristes_tigres> pumpkin: yes, something like that
16:14:50 <tristes_tigres> pumpkin: "separates pure and impure at the type level"
16:14:53 <johnnowak> does anyone know the rate at which work on the disciplined disciple compiler is going along?
16:15:08 <RayNbow> dons, that last pic looks like some tentacle monster
16:15:14 <ddarius> johnnowak: The author probably does.
16:15:15 <dons> johnnowak: it's a phd project, and the author is now working on ghc's sparc compiler.
16:15:24 <dons> so i would say: there is no active work on DDC.
16:15:30 <johnnowak> ah, good to know. thanks.
16:16:01 <dons> RayNbow: i think its interesting. very few projects have slow trends to 1.0. they either suddenly reach it, or stop somewhere in the 0.x
16:18:02 <leimy>   no one likes code maintenance as much as the first time they've written something cool :-)
16:18:17 <dublpaws> error while loading shared libraries: libgmp.so.3 -- while make'ing the binary dist of 6.10.  Have exported LD_LIBRARY_PATH from .bashrc, fresh installed libgmp.so.3, ldupdate'd, ln -s the .so everywhere I can think including ./ghc/library... these are the symptoms of a bug report last year or so.. not sure what to try next.  linux x86 pentium3.
16:19:00 <scsibug> dons: do you know why several hackage projects (HTTP, xhtml, probably others) have huge version numbers like "3000"?
16:19:15 <RayNbow> the thing with version numbering is... it's just an arbitrary number
16:19:15 <dons> yeah, that's bjorn's style
16:19:20 <dons> i had to filter those out :)
16:19:32 <dons> well, what does this say: http://galois.com/~dons/images/hackage/vectors.png
16:19:38 <dons> lots of people *start* their projects at 1.0
16:19:50 <dons> a lot of projects don't get past 0.5
16:20:03 <dons> and the sharp spikes in this http://galois.com/~dons/images/hackage/2.0.png
16:20:06 <scsibug> I'll have to ask him sometime.  I know he has automated version naming scripts ;)
16:20:09 <dcoutts> yes, it's not very dense from 0.5 to 1
16:20:10 <dons> tell me that people just decide to jump to 1.0
16:20:17 <dons> they rarely have smooth progression past 0.5
16:21:01 <dons> many projects have < 5 releses
16:21:25 <ddarius> GHC 6.8.3 -> GHC 6.10
16:21:28 <RayNbow> that's why it's just some arbitrary number, most people just pick a version number that probably looks okay :p
16:21:52 <leimy> well what's the general accepted meaning of 1.0?
16:21:56 <dons> and its hard for people to map their work onto a montonic, regular scale from 0.0 to 1.0
16:21:57 <leimy> I don't see one
16:22:02 <leimy> and hackage doesn't define it.
16:22:04 <dons> they just start, then eventually they stop, and maybe they make 1.0 or not
16:22:07 <leimy> so people use arbitrary stuff.
16:22:14 <dons> right.
16:22:21 <dons> xmonad may never reach 1.0 :)
16:22:28 <dons> even though i'd say v0.3 was actually 1.0
16:22:33 <dons> in terms of "everyone can use it"
16:22:39 <leimy> anyone remember the blackbox window manager?
16:22:45 <RayNbow> the only sensible thing you could say about a version number is that if version x < y, than x must be older :p
16:22:45 <leimy> I think it peaked at 0.65 :-)
16:22:48 <dublpaws> versions ending in 0 have more bugs than those ending in 1-9
16:22:50 <RayNbow> or wait
16:22:54 <ddarius> I think I used blackbox
16:22:57 <RayNbow> even that doesn't have to be necessarily true...
16:22:59 <litb> now that qt is lgpl, i think most of the gnome and monad ppl will switch to kde
16:24:02 <erikc> litb: death first :)
16:24:33 <dons> litb: heh.
16:24:37 <ddarius> I wouldn't bother with KDE.  The only reason I have any gnome stuff is because that's what's installed by default on Ubuntu.
16:24:50 <ddarius> dons: I wouldn't worry about version numbers.
16:25:26 <jeffwheeler> litb: franky, I use GNOME because it is more pixel-perfect
16:25:34 <jeffwheeler> litb: not the license . . .
16:25:58 * dublpaws waits for the curses windows manager
16:26:17 * dublpaws gobbles an s
16:26:22 <dons> well, i imagine if we come back in 5 years, there'll be more projects , and more with higher numbers
16:26:46 <ddarius> dons: I bet that will be true in 5 days.
16:26:50 <dons> :)
16:27:19 <dons> the criticism that hackage is all experimental 0.0 versions irks me.
16:27:40 <dons> this at least says that there's a decent percent with multiple releases
16:27:52 <dons> and a decent percent where the author has marked '1.0' (not nec. meaningful)
16:27:58 <dons> so i'm comforted.
16:28:24 <ddarius> My impression is that most people just install what they need and don't care (or notice) what the version number is.
16:28:25 <luite> how many packages are actually marked stable?
16:28:30 <dons> ddarius: yup
16:28:40 <ddarius> When they do care about stability/reliability they don't use the version number to establish this.
16:28:46 <ddarius> (they use the community)
16:28:56 <dons> yep. lots of heuristics come in to play
16:29:29 <ozy`> speaking of using the community
16:29:46 <ozy`> how should I go about getting an SDL binding going on OS X?
16:31:56 <litb> erikc: :)
16:33:03 <dons> here's the long term moving average of project releases, http://galois.com/~dons/images/hackage/hackage-daily-graph.png
16:33:09 <dons> flattening out all the noise. good trend line
16:33:50 <dons> so we've seen a 250% increase in the 200-day release average in the past 2 years
16:33:56 <roconnor> dcoutts: is there anything in Cabal that could support compiling a module under the condition that some other package is installed?
16:34:15 <roconnor> dcoutts: I'm thinking of a module that has instances, but isn't needed unless some other package is around.
16:34:26 <defun> ok, I came up with the following solution to project euler problem 8: (http://hpaste.org/14071). I get the following error when I try to run it: (http://hpaste.org/14072). Why is it not working? How come the compiler didn't complain?
16:34:27 <scsibug> dons: seeing simple traffic (pageviews/package downloads) would be an interesting metric as well.
16:34:54 <roconnor> dcoutts: tricky because the module would have to be retoractively added at the time the other package is installed.
16:35:29 <RayNbow> defun: next time, it might be nicer to put the code and the error message in one paste ;)
16:35:32 <Peaker> IMO: if libraries change interfaces, that the imports should explicitly change. So import SomeLib3.  I think cabal's support of multiple installed versions should be in the same way as it is with apt. The way its done now is too problematic -- why should someone import Lib -- if its really Lib3 that it depends on?
16:35:41 <defun> oh, sorry.
16:35:46 <dcoutts> roconnor: we explicitly do not want to do that, have conditional on other packages being installed, because it's impossible to translate into native distro packages or even into binary packages.
16:35:49 <dons> scsibug: yes
16:36:01 <RayNbow> defun: about the error message, it's something that happens at runtime
16:36:24 <RayNbow> prodList []   -- defun, what happens in this case?
16:36:24 <dcoutts> roconnor: I'm sorry, the instances problem is hard. It does not interact well with packages.
16:36:43 <roconnor> aw crap
16:36:49 <roconnor> I understand
16:37:19 <roconnor> dcoutts: is the best practice to simply have a third package with the instance that depends on the other two?
16:37:46 <dcoutts> roconnor: that gets ugly quickly. If possible just depend on that other package you're providing instances for.
16:37:48 <roconnor> that could potentially be automatically fetched by cabal install
16:38:00 <dcoutts> roconnor: again, that does not help for distro packages
16:38:17 <defun> RayNbow: it is supposed to list all of the products of fst 5 elems. However, with each recursion, it omits the head of the list, and finds the product of elems 2-6, etc, etc. Get it?
16:38:25 <roconnor> dcoutts: ya but someone wanting PointedLists may feel that installing all of category-extras is a bit much.
16:38:39 <roconnor> and that is just the tip of the iceburg
16:38:43 <RayNbow> defun: yeah, but the (x:xs) pattern in prodList only matches non-empty lists
16:39:01 <roconnor> dcoutts: should category-extras be diced?
16:39:20 <RayNbow> so when you apply prodList to an empty list, you get that error message in http://hpaste.org/14072
16:39:38 <defun> I see. thanks.
16:40:45 <RayNbow> > map digitToInt "1234"
16:40:46 <lambdabot>   [1,2,3,4]
16:41:01 <RayNbow> ^ defun, you might want to use digitToInt (from Data.Char)
16:41:44 <Axman6> > foldl (\acc x -
16:41:46 <lambdabot>   <no location info>: parse error on input `-'
16:42:16 <Axman6> > foldl (\acc x -> digitToInt x + 10*acc) (-0) "12345"
16:42:18 <lambdabot>   12345
16:42:25 <kerlo> > map digitToInt "12:00"
16:42:26 <lambdabot>   [1,2,* Exception: Char.digitToInt: not a digit ':'
16:43:11 <ddarius> Hmm.  Linking the Setup.hs for lhs2tex took quite a while/quite a bit of memory
16:43:44 <ddarius> @pl \acc x -> digitToInt x + 10*acc
16:43:45 <lambdabot> (. digitToInt) . (+) . (10 *)
16:44:13 <ddarius> @pl \x acc -> digitToInt x + 10*acc
16:44:13 <lambdabot> (. (10 *)) . (+) . digitToInt
16:49:31 <OneClickB> www.myspace.com/oneclickbeats   <- best producer online right now, Awesome music check it out
16:49:31 <OneClickB> www.myspace.com/oneclickbeats   <- best producer online right now, Awesome music check it out
16:49:31 <OneClickB> www.myspace.com/oneclickbeats   <- best producer online right now, Awesome music check it out
16:49:31 <OneClickB> www.myspace.com/oneclickbeats   <- best producer online right now, Awesome music check it out
16:49:32 <OneClickB> www.myspace.com/oneclickbeats   <- best producer online right now, Awesome music check it out
16:49:33 <OneClickB> www.myspace.com/oneclickbeats   <- best producer online right now, Awesome music check it out
16:49:34 --- mode: ChanServ set +o dcoutts
16:49:35 <OneClickB> www.myspace.com/oneclickbeats   <- best producer online right now, Awesome music check it out
16:50:28 <dcoutts> roconnor: that's up to you. I think with decent package management, depending on more stuff is not that much of a problem
16:51:10 <Axman6> http://vis.renci.org/jeff/?p=33 pretty awesome amount of data there
16:51:24 --- mode: ChanServ set -o dcoutts
16:51:41 <roconnor> dcoutts: That is an intersting opinion.
16:51:50 <dolio> ddarius: Does Hask fail to be a category due to seq? Or is there something more to it?
16:51:56 <roconnor> I don't beleive it, but I'll reflect on it.
16:52:18 <roconnor> dolio: I think it is just seq.  My Haskell doesn't have seq
16:52:19 <ddarius> dolio: seq mainly, but I'm sure there are plenty of other issues that make it not a very pretty category
16:52:29 <Gracenotes> has anyone here used Yampa..?
16:52:40 <dolio> Well, yeah, tuples aren't products and whatnot.
16:52:45 <roconnor> my Haskell also doesn't have bottoms, so maybe I shouldn't be talking
16:52:47 <Gracenotes> is it somewhat easy to grok?
16:53:06 <kerlo> I want roconnor's Haskell.
16:53:16 <roconnor> kerlo: it's called Agda :P
16:53:28 <ddarius> roconnor: Heck, at that point Hask just becomes Set.
16:53:30 <roconnor> or perhaps Epigram 2
16:53:31 <dcoutts> roconnor: I half-believe it myself
16:53:57 <dcoutts> roconnor: the argument goes, if you can apt-get foo, then who really cares if it pulls in 10 packages rather than 5
16:54:09 <roconnor> ddarius: I don't think it is Set.  For example all my haskell functions are continuous
16:54:26 <ddarius> roconnor: True.
16:54:35 <dcoutts> roconnor: the cost is measured in disk space and network bandwidth rather than time spent running configure scripts manually. So the costs are dramatically reduced.
16:54:38 <ddarius> So some topos.
16:54:43 <Axman6> "./configure --with-gcc=ghc-4.2" whoops
16:54:56 <roconnor> dcoutts: ya
16:55:12 <roconnor> dcoutts: you might be right
16:55:14 <kerlo> Does Epigram 2 exist yet?
16:55:25 <roconnor> kerlo: no, which makes it wonderful to refer to
16:55:35 <roconnor> because I can imagine it to be as awsome as I like
16:55:41 <kerlo> roconnor: all your Haskell functions are continuous? Does that mean that all your Haskell types are topological spaces?
16:55:54 <roconnor> kerlo: yes.
16:56:00 <kerlo> Cool.
16:56:20 <roconnor> kerlo: your finite types and integers have the discrete topology
16:56:41 <roconnor> your coinductive streams and function types have more interesting topologies
16:57:15 <kerlo> What's a coinductive stream?
16:57:37 <roconnor> kerlo: in haskell there is no distiction between inductive and coinductive types
16:57:42 <Axman6> argh, i can't get ghc head to compile, i keep getting:
16:57:43 <Axman6> config.status: executing mk/stamp-h commands
16:57:44 <roconnor> so it is hard to explain in terms of haskell
16:57:44 <Axman6> Looks like you're missing base's configure script.
16:57:44 <Axman6> Did you run 'sh boot' at the top level?
16:58:00 <roconnor> kerlo: but inductive types can only have a finite number of constructors
16:58:17 <roconnor> kerlo: and correspond to a "least fixed point".
16:58:29 <kerlo> I think I can see that.
16:58:31 <roconnor> kerlo: coinductive type can, potentially, have an infinite number of constructors
16:58:32 <Axman6> i have of course run sh boot many times
16:58:40 <roconnor> and correspond to a greatest fixed point
16:59:04 <roconnor> ... and apparently have some theoretical issues when it comes to soundness of the type system
16:59:06 * roconnor grumbles
16:59:09 <roconnor> anyhow
16:59:12 <dolio> kerlo: There's a repository somewhere with epigram 2 code. But neither I nor anyone I know has been able to get it to do anything yet. :)
16:59:25 <kerlo> Hmm, I remember doing some fancy stuff with the fixed points of... those things that these are fixed points of.
16:59:28 <roconnor> data Stream a = a :> Stream a
16:59:39 <roconnor> above is the cannotical example of a coinductive type
16:59:42 <Peaker> that's a happy stream
16:59:53 <roconnor> as an inductive type, it is empty
17:00:04 <roconnor> so haskellers are used to viewing that coinductively
17:00:21 <kerlo> Oh, right. Starting with no Stream a, you can't get any.
17:00:22 <dolio> I don't know about that.
17:00:52 <roconnor> kerlo: we take the fixpoint of F X = a :> X
17:00:54 <roconnor> to get streams
17:01:11 <roconnor> notice that F (F (F (F (..) = a :> a :> a :> ...
17:01:22 <dolio> I suspect most Haskellers haven't bothered studying the right stuff to think about inductive vs. coinductive types.
17:01:30 <dolio> Not yet, at least.
17:01:52 <kerlo> Haskell is neither inductive nor coinductive, then, is it? fix (() :>) == fix (() :>) is neither true nor false; it loops forever.
17:02:01 <roconnor> dolio: Oh I agree.  I'm just saying that when haskellers see the Stream a type, they usually end up thinking about the coinductive data type
17:02:11 <roconnor> although they don't have a name for the concept
17:02:36 <roconnor> kerlo: here I'm talking about using fixpoints to define a type, rather than a value.
17:02:44 <kerlo> Okay.
17:02:48 <roconnor> although the principles are similar
17:03:08 <roconnor> the fixpoint of a funciton f is f (f (f (f...
17:03:10 <kerlo> I understand the concept of defining types with fixpoints like this.
17:03:15 <roconnor> and produces a value
17:03:20 <roconnor> same thing on the datatype level
17:03:28 <roconnor> we define a _functor_ F
17:03:34 <roconnor> (of kind * -> *)
17:03:45 <roconnor> and take it's fixpoint F (F (F (F (F
17:03:50 <roconnor> and we get a data type
17:04:03 <kerlo> "type Foo = One Foo | Two Foo" is the fixed point of (>>= \x -> {One x, Two x}), yes?
17:04:28 <kerlo> Where the braces denote a set containing all the values of a type.
17:04:32 <schme_> Hello #haskell. I am curious about where I would look for signal handling ?
17:04:35 <schme_> (in ghc)
17:04:36 <roconnor> kerlo: yes, it is the fixpoint of F X = One X | Two X
17:04:38 <ddarius> @hackage dsp
17:04:38 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dsp
17:04:40 <kerlo> And >>= is defined as for lists, pretty much.
17:04:45 * kerlo nods
17:04:55 <roconnor> kerlo: I wouldn't use >>= here
17:05:08 <roconnor> just /\X -> One X | Two X
17:05:13 <roconnor> if I may abuse notation
17:05:18 <roconnor> just /\X -> One X `Either` Two X
17:05:21 <kerlo> Perhaps I would describe Haskell as coinductive, really, as values are constructed from the top down.
17:05:21 <roconnor> if you prefer
17:05:39 <roconnor> kerlo: it is reasonable to think of all haskell definitions as coinductive
17:05:45 * kerlo nods
17:05:53 <roconnor> maybe it is even accurate
17:06:17 <ddarius> no more or less than thinking them as all inductive
17:06:25 <roconnor> the coinductive type always contains the inductive part as a subset
17:06:42 <kerlo> So a "coinductive stream" is pretty much just a Haskell-style stream?
17:06:47 <roconnor> because the coinductive type is the greatest fixpoint and the inductive type is the least fixpoint
17:07:01 <roconnor> kerlo: I think I'd say yes to that
17:07:07 <kerlo> What's the topology on those?
17:07:22 <roconnor> oooh
17:07:38 <roconnor> I don't know how to describe it formally.
17:07:53 <schme_> No ?
17:08:03 <kerlo> I wonder if it's at all like the topology on the real numbers.
17:08:10 <roconnor> although I know intutively how to describe specific example
17:08:21 <roconnor> for the Stream, say Stream Bool
17:08:25 <kerlo> Okay.
17:08:28 <ddarius> roconnor: It's easy.  It the union of the inverse images of the function Stream a -> () at ().
17:08:29 <roconnor> this has the topology of the cantor set
17:09:15 <roconnor> you can measure the distace between two streams by counting how long of a prefix they share
17:09:26 * kerlo nods
17:09:28 <roconnor> in this case this metric gives rise to the topology of streams
17:09:37 <kerlo> Okay, that makes sense.
17:09:40 <roconnor> and I beleive this is one of the standard infinite product topologies
17:09:59 <ddarius> @google Sierpinski space
17:10:02 <lambdabot> http://en.wikipedia.org/wiki/Sierpinski_space
17:10:02 <lambdabot> Title: SierpiÅski space - Wikipedia, the free encyclopedia
17:10:34 <roconnor> ddarius: my data types have no bottoms
17:10:41 <kerlo> So for an open set containing {F, F, F, F, ...}, there must be some n such that every stream beginning with n F's is also in the set?
17:11:06 <roconnor> ddarius: so you are describing something different (and more in line with usual haskell semantics)
17:11:44 <roconnor> kerlo: the basic open sets are, for any prefix, all streams with that prefix
17:11:46 <ddarius> roconnor: Well if you figure out whatever the Sierpinski space looks like for your stuff, (the functor from topologies to) open sets are represented by it.
17:11:49 <cgibreak> a
17:11:52 <roconnor> is that what you are saying
17:12:27 <kerlo> roconnor: I believe so.
17:12:36 <roconnor> then you are correct
17:14:47 <roconnor> Stream Integer has the topology of Baire space
17:15:50 <kerlo> I want to see a picture of Stream Integer.
17:16:10 <roconnor> kerlo: it is an infite tree with infinite branching
17:16:17 <roconnor> infinite
17:16:21 <kerlo> Not like that.
17:17:19 <kerlo> A bounded set of points in R^2 consisting of infinitely many similar sets of points in R^2.
17:17:46 <kerlo> I want to see *that*.
17:18:06 <roconnor> a julia set?
17:18:32 <kerlo> Perhaps.
17:18:45 <roconnor> Baire space is not compact
17:18:56 <roconnor> so it cannot be represented as a bounded set of points in R^2
17:19:12 <BONUS> lol
17:19:13 <BONUS> ... possibility of renaming of the existing monoid typeclass to "Appendable"... which is a daft idea, not least because then we'd need to rename Monad to be "Appendage".
17:20:08 <kerlo> There are plenty of non-compact spaces that can be represented as a bounded set of points in R^2; R^2 itself is one, representable by an open disk.
17:20:24 <roconnor> kerlo: ah, good point
17:20:36 <gwern> > 47 - 29
17:20:37 <lambdabot>   18
17:20:59 <roconnor> kerlo: sorry, for me, "picture" means drawable by computer which implies compact.
17:21:37 <kerlo> "Picture" for me implies something that can actually be stored in an image file. :-)
17:21:43 <monochrom> Some streams of integers are not producible by computer either. :)
17:22:16 * kerlo scrolls up to find if we have any outstanding points of discussion
17:22:48 <kerlo> Nope.
17:23:21 <roconnor> kerlo: that's pretty restrictive :) Some subset of the finite sets
17:23:49 <roconnor> but if you like floating point
17:24:01 <roconnor> you probably like storable in an image file
17:25:16 <kerlo> Okay, define a picture of a set as an image file where every pixel is white if and only if its corresponding region of R^2 is disjoint to the set.
17:26:05 <gwern> > 51 - 17
17:26:06 <lambdabot>   34
17:26:17 <roconnor> okay, but each image corresponds to multiple sets
17:26:38 <roconnor> (similar to each floating point number correspoding to multiple real numbers)
17:26:57 <kerlo> The set of all possible photographs is smaller than the set of all things that can possibly be photographed; this doesn't mean that things cannot be photographed.
17:27:07 <kerlo> Anyway, I think I tried to figure out something akin to this inductive/coinductive type stuff on my own once.
17:27:33 <roconnor> yep
17:27:48 <chessguy_work> heh. jquery is a monad: http://importantshock.wordpress.com/2009/01/18/jquery-is-a-monad/
17:27:52 <roconnor> we can argue about pictures and compact sets later
17:28:08 <kerlo> The result was a lot like taking a bunch of objects and trying to specify which ones are the same as which ones by labeling each one with either "SAME" or "DIFFERENT".
17:29:08 <dogmaT> Does anyone know what this `cabal: Couldn't read cabal file "./Glob/0.1/Glob.cabal"' cabal-install error mean?
17:29:42 <kerlo> To be more concrete, I figured you could define each type as either "recursive" or "non-recursive", but that doesn't help if a recursive and a non-recursive type refer to each other. What happens in that case? I dunno.
17:30:57 <roconnor> for simplity, let us say that type are form form void, unit, Either, (,) and Mu
17:31:05 <dcoutts> dogmaT: cabal install cabal-install  to get the latest version
17:31:17 <roconnor> data Mu F = In {out :: F (Mu F)}
17:31:40 <dogmaT> dcoutts thanks
17:31:56 <roconnor> I type is recursive if it uses Mu
17:31:59 <roconnor> A type
17:32:59 <kerlo> My "recursive" was probably "coinductive", and my "non-recursive" was probably "inductive".
17:33:22 <roconnor> ah
17:33:39 <roconnor> actually there are both Mu and Nu
17:33:47 <roconnor> data Nu F = In {out :: F (Nu F)}
17:33:49 <kerlo> The problem is you can't just specify whether each type is to be coinductive or inductive.
17:33:57 <roconnor> you see that Nu is written the same as Mu in Haskell
17:34:09 <roconnor> but Mu is supposed to be the least fixpoint (inductive)
17:34:19 <roconnor> and Nu is the greatest fixpoint (coinductive)
17:34:19 <kerlo> It's like the following problem: "x + y = 0. Maximize x and y."
17:34:26 <roconnor> but both are recursive
17:34:29 <kerlo> Oh, that's nifty.
17:35:18 <kerlo> That probably solves the problem completely.
17:35:52 * kerlo suddenly wonders if he could get any job offers by simply hanging out in #haskell
17:37:52 <kerlo> What branch of math or computer science is this, anyhow?
17:38:01 <ddarius> kerlo: If you're notable enough, possibly.
17:38:02 <roconnor> computer science is math
17:38:15 <ddarius> programming is logic
17:38:29 <Raevel> it's all the same to me!
17:38:40 <roconnor> types are propositons
17:39:09 <kerlo> Would you say plain old theoretical computer science, then?
17:39:31 <roconnor> kerlo: anyhow, this is type theory
17:39:48 <roconnor> kerlo: when we extend it further you get dependent type theory
17:39:54 <roconnor> which is both computer science and logic
17:40:35 <roconnor> dependently typed function program is exactly the same as natural deduction predicate logic
17:40:43 <roconnor> functional programming
17:41:25 <nicou> and everything is SAT :p
17:41:26 <roconnor> and possibly the same as topos theory
17:41:46 <kerlo> Cool.
17:41:53 * pumpkin decides to write everything as 4SAT!
17:41:56 <pumpkin> it's better than 3SAT
17:42:20 <kerlo> Say, is there a type of all types? If so, what's its topology? >:-)
17:42:34 <nicou> let's get creative and rewrite all human knowledge as 3-colorability :)
17:42:46 <nicou> or minesweeper, cellular automaton? anybody?
17:43:16 <kerlo> I would prefer translating mathematics into a game that you can play with a Go set.
17:43:32 <kerlo> (A 19x19 board, and 180 each of white pieces and black pieces.)
17:43:33 <monochrom> These days mentioning "cellular automaton" is like mentioning "intelligent design". :)
17:43:40 <cjb> haha
17:43:41 <nicou> Go is very complicated
17:44:00 <cjb> well, really what you're saying is that 19x19 boards with counters are complicated
17:44:06 <cjb> since we weren't talking about playing Go on the board
17:44:14 <kerlo> I once saw a set of rules for playing Go in arbitrary topological spaces.
17:44:14 <cjb> also, Go is actually extremely simple IMO, moreso than chess :)
17:44:42 <monochrom> we should rewrite everything as haskell or quickcheck
17:44:46 <nicou> Yes, probably more than chess, honestly, I've never played Go, but I can play celullar automata really well :p
17:44:54 <cjb> Go has something like five rules
17:45:04 <cjb> and no "this piece moves like this and this piece moves like this" set of rules
17:45:18 <nicou> I'll look it up. Wikipedia to the rescue!
17:45:31 <kerlo> Here's a set of rules: http://senseis.xmp.net/?TrompTaylorRules
17:45:39 <kerlo> The longest one is this: a point P, not colored C, is said to reach C, if there is a path of (vertically or horizontally) adjacent points of P's color from P to a point of color C.
17:45:44 <jml> it's difficult to master though.
17:46:06 <monochrom> Go moves consist of adding and removing tokens.
17:46:57 <nicou> > It has also been argued to be the most complex of all games, with most advocates referring to the difficulty in programming the game to be played by computers and the large number of variations of play.
17:46:59 <lambdabot>   <no location info>: parse error on input `of'
17:47:12 <nicou> lol sorry
17:47:45 <johnnowak> go has a lot more than 5 rules. you try teaching a novice to score a game.
17:47:49 <kerlo> There's probably a game that has all other games as subgames.
17:47:56 <johnnowak> hell, you need to help the computer to score a game...
17:48:00 <cjb> johnnowak: I was treating scoring as one rule :)
17:48:04 <johnnowak> hah
17:48:13 <kerlo> johnnowak: only if you use a stupid scoring rule. :-)
17:48:30 <cjb> nicou: that's not a very good way of describing the complexity of the game
17:48:42 <monochrom> kerlo is looking for a cosmos that has all cosmoses as sub-cosmoses.
17:48:44 <kerlo> s/stupid/silly/, really, since adding complexity can make a scoring rule better.
17:48:48 <johnnowak> kerlo: i don't think that's the case. being able to look at a board and tell what's dead and alive is not always easy
17:49:00 <kerlo> Anyway, here's a non-silly scoring rule: "# A player's score is the number of points of her color, plus the number of empty points that reach only her color."
17:49:10 <kerlo> In other words, "if it's on the board at the end of the game, it's alive".
17:49:13 <nicou> cjb: no, I know, but AI programming difficulty is a factor to be considered
17:49:27 <johnnowak> kerlo: no one plays like that
17:50:25 <kerlo> That's why there's the extended Tromp-Taylor scoring rule: "at the end of the game, if both players agree it's dead, it's dead; if there's a disagreement, the game starts again, and if both players immediately pass, everything is alive."
17:50:31 <dmajnem2_> I am running bootstrap.sh w/ ghc 6.8 and it wants me to install some additional things. Shouldn't it take care of this?
17:50:33 <ddarius> That jQuery is a monad thing is... pretty uh, fucked up.
17:51:07 <nicou> ddarius: monads are the fashionable thing now, it's all right to see some weird posts.
17:51:52 <Gracenotes> jQuery does have function composition with extras
17:51:57 <Gracenotes> other than that... er
17:53:15 <kerlo> And yes, for all X, I'm looking for an X that has all X's as sub-X's.
17:53:42 <ddarius> X = empty set
17:53:53 <monochrom> hehe nice!
17:54:08 <kerlo> Hey, I think the empty set does have all empty sets as subsets. :-)
17:54:19 <monochrom> least fixedpoints for the win!
17:55:03 <Stephan202> empty sets. all of them
17:55:57 <kerlo> The most important case, though, is where X = fast, good approximate probability maximizer.
17:55:57 <monochrom> > floor (1.0/0.0)
17:55:59 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
17:56:19 <Stephan202> eh?
17:56:22 <kerlo> I now know the first digits of infinity.
17:56:25 <monochrom> haha
17:56:25 <Gracenotes> yeah... a weird bug
17:56:40 <nicou> > 1.0/0.0
17:56:42 <lambdabot>   Infinity
17:56:49 <nicou> > floor Infinity
17:56:49 <monochrom> http://sequence.complete.org/hwn/ and look for the "Quotes of the Week" section. :)
17:56:50 <lambdabot>   Not in scope: data constructor `Infinity'
17:56:53 <Gracenotes> also works with 1/0
17:57:01 <nicou> mmm
17:57:12 <monochrom> Actually...
17:57:16 <monochrom> @quote Olathe
17:57:17 <lambdabot> Olathe says: You can never tell if a lazy person has been executed yet.
17:57:21 <nicou> how come do we accept that 1/0 is infinity?
17:57:23 <monochrom> @quote <Olathe>
17:57:24 <lambdabot> Olathe says: <Olathe> > floor (1.0/0.0) <lambdabot> 179769... <Olathe> But you can see that Haskell can calculate the maximum Integer.
17:57:29 <monochrom> That one! :)
17:57:33 <Gracenotes> nicou: floating point arithemetic
17:57:37 <pumpkin> @quote wango
17:57:37 <lambdabot> wango says: do you like turing complete?
17:57:41 <Cale> kerlo: you might be interested in http://en.wikipedia.org/wiki/Rado_graph
17:58:11 <Gracenotes> nicou: it's not the same as operating from reals to reals. FPA is its own system, and it works very well for most purposes
17:58:22 <Cale> Every finite and countably infinite graph is an induced subgraph of that countable graph.
17:58:40 <Gracenotes> nicou: for instance
17:58:43 <Gracenotes> > (1::CReal)/(0::CReal)
17:58:48 <Gracenotes> it should hang
17:58:58 <lambdabot>   thread killed
17:59:07 <nicou> Gracenotes: Oooh:O
17:59:26 <monochrom> CReal is the computable reals
18:00:04 <nicou> Gracenotes: Yes, I thought it's part of the FPA. Can we isolate that impurity for maths' sake? Or are all literal numbers implicitly defined as floating point?
18:00:09 <pumpkin> > (0 :+ 1) ** (0 :+ 1) :: Complex CReal
18:00:11 <lambdabot>   0.2078795763507619085469556198349787700339 :+ 0.0
18:00:28 <monochrom> Default, not all.
18:00:32 <mauke> > 1/0 :: Rational
18:00:34 <lambdabot>   * Exception: Ratio.%: zero denominator
18:01:35 <Gracenotes> nicou: yeah, all literal numbers in Haskell, unless explicitly cast.
18:01:57 <mauke> what the fuck
18:02:08 <Gracenotes> ..?
18:02:10 <nicou> Gracenotes: Thanks. That's what I thought.
18:02:18 <mauke> there are no implicit casts. haskell has no casts. numbers don't default to floating point in haskell.
18:02:34 <Gracenotes> mauke: oh... yeah. Sorry. Confusing it with other languages :/
18:02:58 <nicou> mauke: So what is the logic behind 1/0 = Infinity?
18:03:12 <Gracenotes> :t (3.2)
18:03:14 <lambdabot> forall t. (Fractional t) => t
18:03:15 <mauke> floating point math
18:03:21 <Gracenotes> :t (1/0)
18:03:23 <lambdabot> forall t. (Fractional t) => t
18:03:45 <mauke> haskell numbers and arithmetic operations are overloaded
18:03:56 <Gracenotes> I have yet to grasp the full beauty (or monstrosity) of Haskell's arithmetic system
18:03:58 <mauke> the compiler has to choose a particular type to display the result
18:04:09 <pumpkin> :t 1
18:04:10 <lambdabot> forall t. (Num t) => t
18:04:17 <mauke> (because it has to know which operations to actually execute)
18:04:29 <nicou> nicou: and it chooses floating point instead of arbitrary precision
18:04:41 <mauke> the default default is to use Integer where possible and Double otherwise
18:04:52 <mauke> but you can change the defaults
18:06:35 <nicou> mauke: I see. I suppose this Infinity thing is complicated anyway, whether you should display something like NaN, or Infinity, or an error, or whatever.
18:06:50 <monochrom> http://haskell.org/onlinereport/decls.html#default-decls  on default
18:06:51 <mauke> infinity isn't that complicated
18:07:05 <mauke> floating point numbers simply have three special values: +inf, -inf and nan
18:07:26 <Heoooo> Is | a mathematic OR or XOR?
18:07:27 <gnuvince_> Is there a way to turn off GHCi's outputting of an expression?  I'm trying to do: words' <- liftM lines (readFile "ods4.txt") where ods4.txt is several thousand lines long and this causes my Emacs ghci buffer to lag considerably.
18:07:47 <Gracenotes> :t let f :: CReal -> CReal; f b = sqrt b in sqrt 2
18:07:48 <lambdabot> forall t. (Floating t) => t
18:07:53 <Gracenotes> mauke: yeah.... what?
18:07:54 <gnuvince_> Heoooo: neither.  logical or is ||, bitwise or is .|.
18:08:14 <nicou> man, this is too deep for me, I should try to learn Haskell first.
18:08:20 <monochrom> > True || True
18:08:22 <lambdabot>   True
18:08:28 <monochrom> That should answer all questions.
18:08:29 <Cale> Logical exclusive or is /=
18:08:31 <Gracenotes> mauke: a bit confusing. Is Haskell not taking tips from my type?
18:08:45 <mauke> Gracenotes: huh? your type was on f. you didn't use f.
18:08:59 <Gracenotes> oh... right >_>
18:09:02 <Heoooo> True || False
18:09:08 <Gracenotes> :t let f :: CReal -> CReal; f b = sqrt b in f 2
18:09:09 <lambdabot> CReal
18:09:12 <Gracenotes> okay.
18:09:24 <Heoooo> > True || False
18:09:26 <lambdabot>   True
18:09:56 <Heoooo> > True .|. False
18:09:57 <lambdabot>       No instance for (Bits Bool)
18:09:57 <lambdabot>        arising from a use of `.|.' at <inte...
18:10:01 <Gracenotes> mauke: okay then. Sorry about the weirdly typed answer earlier :)
18:10:06 <mauke> Gracenotes: Haskell is actually mostly sane :-)
18:10:11 <pumpkin> > 5 .|. 3
18:10:12 <lambdabot>   Add a type signature
18:10:13 <monochrom> .|. is for binary numbers.
18:10:16 <pumpkin> > 5 .|. 3 :: Int
18:10:17 <lambdabot>   7
18:11:33 <Gracenotes> mauke: I can see. non-integer number systems are always somewhat complicated in most languages I've seen, though :)
18:11:46 <Botje> @pl \(xs,ys) -> (map fst xs, map fst ys)
18:11:46 <lambdabot> map fst *** map fst
18:11:59 <Gracenotes> type classes help quite a bit, it seems
18:12:10 <mauke> > 0.1 + 0.1 + 0.1 + 0.1 + 0.1 :: Rational
18:12:11 <lambdabot>   1%2
18:12:18 <Cale> Oh, that is cool. For any partition of the vertices of the Rado graph into disjoint subsets A and B, at least one of the subgraphs induced by A and B is isomorphic to the Rado graph :)
18:12:22 <mauke> (can't do that in most other languages)
18:12:41 <Heoooo> >  2 /= 2
18:12:43 <lambdabot>   False
18:13:02 <Heoooo> >  0 /= 1
18:13:03 <lambdabot>   True
18:13:11 <Heoooo> >  0 /= 7
18:13:13 <lambdabot>   True
18:13:24 <pumpkin> > (0/0) /= (0/0
18:13:25 <lambdabot>   <no location info>: parse error on input `;'
18:13:26 <pumpkin> > (0/0) /= (0/0)
18:13:26 <dublpaws> Cale does that give it a fractal like quality?
18:13:27 <lambdabot>   True
18:13:30 <Gracenotes> :t (0 /=)
18:13:31 <lambdabot> forall t. (Num t) => t -> Bool
18:13:35 <Cale> dublpaws: I suppose so.
18:14:05 <Cale> dublpaws: To really formalise that, I suppose you'd need a topology.
18:14:21 <mauke> Cale: can you make lambdabot use the Text.Printf.Mauke variant?
18:14:29 <Cale> mauke: What's that?
18:14:44 <mauke> my own printf, which is more compatible with C and Perl
18:15:00 <Heoooo> >  0 | 1
18:15:01 <lambdabot>   <no location info>: parse error on input `|'
18:15:23 <monochrom> | is for something else entirely in Haskell
18:15:40 <Cale> | is used in several places in the Haskell syntax
18:15:43 <monochrom> Godawful. Why do you people impose other, inferior language habits on Haskell?
18:16:01 <Gracenotes> :(
18:16:07 * Gracenotes begs monochrom's forgiveness
18:16:11 <gnuvince_> Is it possible to do: words' <- liftM lines (readFile "ods4.txt") without having ghci spit out the thousands of elements this generates?
18:16:15 <Cale> For guards, for list comprehensions (separating the expression from the generators and conditions), and for separating the cases in a data declaration.
18:16:28 <Heoooo> what is this: data Bool = False | True  ?   OR or XOR?
18:16:34 <mauke> (yay, cabal install printf-mauke works)
18:16:36 <monochrom> Neither. OK?
18:16:43 <Cale> Heoooo: It's just a separator, a fancy sort of comma.
18:16:59 <chessguy> Heoooo:  it's exclusive or
18:17:04 <Gracenotes> as far as I can tell, it comes from notation used in formal languages
18:17:41 <gwern> gnuvince_: yes; but I forget how. maybe a let
18:17:50 <Cale> I suppose you could consider it to sort of be like exclusive or, in the sense that this is saying that a value of type Bool is either the value True, or the value False, and it can't be both.
18:18:00 <monochrom> gnuvince_: Yes. It'll take me a minute to find out the ghci option for turning it off.
18:18:23 <Heoooo> great thanks for the clarification!
18:18:27 <chessguy> and it can't be neither
18:18:30 <chessguy> whatever that means
18:18:33 <mauke> gnuvince_: my ghci doesn't do that
18:18:35 <monochrom> Cale everything can be considered to be sort of everything else. It should not be encouraged.
18:18:37 <pumpkin> | Neither
18:18:51 <Gracenotes> pumpkin: Maybe Bool time :)
18:18:56 <gnuvince_> mauke: it doesn't print all the lines?
18:19:03 <mauke> prints nothing
18:19:05 <Cale> monochrom: Well, it could be read aloud as "or".
18:19:20 <mauke> gnuvince_: well, what I actually tested was 'x <- return 42'
18:19:31 <pumpkin> Gracenotes: why use Maybe Bool when you can write data KindaSorta = Yeah | Nope | NotTooSureButYouKnow Double
18:19:37 <gnuvince_> mauke: try with /etc/passwd
18:19:42 <gnuvince_> You should see all the lines
18:19:44 <monochrom> gnuvince_ :set -fno-print-bind-result
18:19:52 <mauke> *> _ <- readFile "/etc/passwd"
18:19:53 <mauke> *>
18:19:55 <mauke> I don't
18:20:08 <chessguy> heh, i remember the first time i heard that "(p => q) /\ !p" was true, i said "then all of mathematics should be based on some kind of ternary logic, True, False, or Unknown"
18:20:11 <pumpkin> gnuvince_: doesn't print out for me either
18:20:12 <inforichland> > readFile "/etc/passwd"
18:20:13 <lambdabot>   * Exception: "<IO [Char]>"
18:20:31 <monochrom> "imply" is always read aloud as "and".  "You say it again and I'll beat you up".
18:20:42 <chessguy> pumpkin:  google PerhapsT
18:20:53 <pumpkin> chessguy: you don't like my data type? :(
18:20:54 <monochrom> reading aloud is sloppy reasoning.
18:21:01 <chessguy> pumpkin:  just saying, it's been done
18:21:11 <pumpkin> pre-empted again!
18:21:15 <kerlo> Well, "data Bool = False | True" really just means "False is a Bool and True is a Bool", I think.
18:21:15 <mauke> close $fh and print "that was a success\n";  # perl
18:21:38 <kerlo> And False can be distinguished from True using pattern matching as well as a ton of built-in syntactic sugar.
18:21:39 <pumpkin> chessguy: oh I remember PerhapsT
18:21:44 <chessguy> pumpkin:  a nice series of articles too
18:21:56 <dolio> > let p = True ; q = True in (p <= q) && not p
18:21:57 <lambdabot>   False
18:22:12 <monochrom> You want an operator that behaves like (True `operator` True == False) in Haskell and it is never going to be | , no matter how aloud you reading |
18:22:46 <chessguy> kerlo:  actually, there's not much syntactic sugar built around Boolans, i don't htink
18:22:54 <chessguy> guards, i guess
18:23:17 <kerlo> And if.
18:23:21 <chessguy> yes
18:23:34 <ski_> and list comprehensions
18:23:54 <ski_> > [() | False]
18:23:55 <lambdabot>   []
18:24:00 <mauke> heh, <= is pretty ironic
18:24:10 <mauke> > [True | False]
18:24:11 <lambdabot>   []
18:24:13 <chessguy> well....ok. i wouldn't say that's really "built around" booleans, as it de-sugars to something that just uses normal booleans, i think
18:24:19 <chessguy> or could, anyway
18:24:20 <dolio> > [ (p, q, p <= q) | p <- [False,True] , q <- [False, True] ]
18:24:20 <kerlo> > [() | True]
18:24:22 <ski_> mauke : yeah, it should be written `=<' like in Prolog ..
18:24:22 <lambdabot>   [()]
18:24:22 <lambdabot>   [(False,False,True),(False,True,True),(True,False,False),(True,True,True)]
18:24:41 <pumpkin> if you drop the implicit prelude, and redefine the guard function, can you stick something else in a comprehension?
18:24:41 <mauke> ski_: wait, =< is implication in prolog?
18:24:52 <ski_> mauke : no, "lesser than or equal"
18:25:17 <kerlo> There's a guard function in the Prelude?
18:25:22 <ski_> (mauke : i thought you were refering to the `let p = True ; q = True in (p <= q) && not p' rendering of "(p => q) /\ !p")
18:25:24 <Riastradh> `less than or equal to'
18:25:30 <mauke> ski_: I was
18:25:36 <dolio> > [ (p <= q) && not p | p <- [False,True], q <- [False, True] ]
18:25:38 <lambdabot>   [True,True,False,False]
18:25:41 <ski_> (Riastradh : ty)
18:25:52 <pumpkin> kerlo: nope, but the comprehension just desugars into the guard function I think?
18:26:00 <pumpkin> the conditions in the comprehension, at least
18:27:18 <ozy`> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/baskell-0.1.1 <== hmmmm
18:28:01 <monochrom> All of compilation is desugaring.
18:28:02 <dolio> > [ (q <= p) && not p | p <- [False,True], q <- [False, True] ]
18:28:03 <lambdabot>   [True,False,False,False]
18:28:37 <pumpkin> > [1 | x]
18:28:37 <dublpaws> and gate
18:28:38 <lambdabot>   Couldn't match expected type `Bool' against inferred type `Expr'
18:28:40 <dolio> > [ (p <= q) || p | p <- [False,True], q <- [False, True] ]
18:28:42 <lambdabot>   [True,True,True,True]
18:28:43 <pumpkin> > [1 | f]
18:28:44 <lambdabot>       No instance for (SimpleReflect.FromExpr Bool)
18:28:45 <lambdabot>        arising from a use...
18:28:57 <pumpkin> > [1 | x >= 0]
18:28:58 <lambdabot>   [1]
18:29:01 <pumpkin> :/
18:29:02 <Cale> heh
18:29:27 <mauke> > join (liftM2 (<=)) [minBound..maxBound]
18:29:28 <lambdabot>   [True]
18:29:57 <mauke> what
18:29:58 <dolio> > [ not (p <= q) && not p | p <- [False,True], q <- [False, True] ]
18:29:59 <lambdabot>   [False,False,False,False]
18:30:43 <Olathe> > join (liftM2 (\p q -> p <= q && not p)) [True, False]
18:30:44 <lambdabot>   [False,False,True,True]
18:30:54 <Olathe> > join (liftM2 (\p q -> not p)) [True, False]
18:30:55 <lambdabot>   [False,False,True,True]
18:31:14 <dublpaws> :t liftM2
18:31:15 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:31:48 <Olathe> > join (liftM2 (\p q -> q <= p && not p)) [True, False]
18:31:49 <lambdabot>   [False,False,False,True]
18:32:02 <Olathe> > join (liftM2 (\p q -> not q && not p)) [True, False]
18:32:03 <lambdabot>   [False,False,False,True]
18:32:20 <Olathe> > join (liftM2 (\p q -> not (q || p))) [True, False]
18:32:21 <lambdabot>   [False,False,False,True]
18:34:01 <cjs> Hm. Ought there to be a standard instance of NFData ByteString somewhere?
18:35:11 <pumpkin> don't think so, but derive can probably do the lazy one for you?
18:35:24 <pumpkin> not that the strict one needs doing
18:37:16 <cjs> Yeah, I'm not too (well, not at all :-)) familiar with the derive package. I guess that just length won't be enough for the lazy one?
18:38:43 <CakeProphet> > foldr (const f) undefined (repeat undefined)
18:38:44 <lambdabot>   Add a type signature
18:38:51 <CakeProphet> > foldr (const f) undefined (repeat undefined) :: Expr
18:38:52 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
18:39:49 <cjs> No, I somehow need to force the chunks, as well.
18:40:08 <pumpkin> cjs: you could just use the strict bytestring?
18:40:26 <CakeProphet> hmmm... I wonder why I needed a type signature.
18:40:34 <CakeProphet> :t foldr (const f) undefined (repeat undefined)
18:40:35 <lambdabot> forall b. (SimpleReflect.FromExpr b, Show b) => b
18:42:06 <CakeProphet> > foldr (const f) 0 (repeat 0)
18:42:07 <lambdabot>   Add a type signature
18:42:18 <CakeProphet> :t const f
18:42:19 <lambdabot> forall a b. (SimpleReflect.FromExpr a) => b -> a
18:42:30 <pumpkin> where does the Show b come from in the one you typed earlier?
18:42:41 <cjs> pumpkin: I'm using lazy bytestrings throughout this program, and for good reason, actually. I need an NFData instance for stuff at a much higher level.
18:43:02 <pumpkin> cjs: ah, then derive is probably your best bet...it's pretty easy to use, particularly the TH version
18:43:24 <pumpkin> @hackage derive
18:43:24 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/derive
18:44:12 <pumpkin> you just need a single line of TH saying derive an NFData for this type
18:44:37 <pumpkin> I've only ever used it on relatively simple types though, but I don't see why it would fail
18:44:55 <cjs> Hm. Well, maybe it's time to learn something new, then. I've got lots of relatively simple types for which I need an NFData instance.
18:45:07 <cjs> Though it probably means extending my build system again, too....
18:45:28 <pumpkin> you can just add a {-# LANGUAGE to the top of the file that needs it
18:45:30 <CakeProphet> :t derive
18:45:30 <pumpkin> for TemplateHaskell
18:45:31 <lambdabot> Not in scope: `derive'
18:45:58 <pumpkin> cjs: http://hackage.haskell.org/packages/archive/derive/0.1.4/doc/html/Data-DeriveTH.html that's pretty much it
18:46:07 <cjs> I don't need to do anything special otherwise? ghc -make will deal with everything?
18:46:08 <pumpkin> $( derive makeNFData ''YourType )
18:46:12 <pumpkin> cjs: yeah
18:46:14 <lunabot>  luna: Not in scope: `derive'
18:46:22 <pumpkin> whoops :)
18:46:25 <cjs> I can see that this would be useful for some of my custom instances, too.
18:46:56 <pumpkin> derive also know how to make many other handy things
18:50:30 <pumpkin> wow, the NFData deriver looks like an entry to an obfuscated code competition: http://hackage.haskell.org/packages/archive/derive/0.1.4/doc/html/src/Data-Derive-NFData.html#makeNFData
18:51:12 <chessguy> maybe it is
18:52:22 <ddarius> Not with "\field ->"
18:52:48 <ddarius> I like the "++[]" though.
18:53:01 <pumpkin> I get the impression the generator itself was generated
18:53:02 <pumpkin> :P
18:53:20 <mauke> by a perl script
18:53:31 <ddarius> pumpkin: You don't normally write "id [1..10]"?
18:53:49 <pumpkin> lol
18:54:00 <pumpkin> I dunno, you never know when that might come in handy!
18:54:16 <pumpkin> it's sort of more [1..10] than just [1..10]
18:54:27 <pumpkin> > iterate id [1..10]
18:54:28 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10],[1,2,...
18:55:02 <pumpkin> they may _look_ the same, but if you read between the elements, the later ones are more true
18:55:21 <kerlo> > 10 == True
18:55:22 <lambdabot>       No instance for (Num Bool)
18:55:22 <lambdabot>        arising from the literal `10' at <int...
18:55:28 <kerlo> I guess the world may never know.
18:55:30 <idnar> haha
18:55:40 <mauke> > 10 === True
18:55:42 <lambdabot>   False
18:55:44 <kerlo> > let fromInteger = const True in 10 == True
18:55:45 <lambdabot>       No instance for (Num Bool)
18:55:45 <lambdabot>        arising from the literal `10' at <int...
18:55:48 <idnar> > fix id $ 5
18:55:49 <lambdabot>   * Exception: stack overflow
18:55:50 <pumpkin> @src (===)
18:55:51 <lambdabot> Source not found. I am sorry.
18:55:51 <kerlo> :t (===)
18:55:52 <lambdabot> forall a b. (Typeable a, Typeable b, Eq b) => a -> b -> Bool
18:55:55 <pumpkin> ah
18:56:03 <kerlo> Oh dear.
18:56:12 <mauke> > 10 === 10
18:56:13 <lambdabot>   True
18:56:18 <pumpkin> > 10 === 9
18:56:19 <lambdabot>   False
18:56:19 <kerlo> > 10 === 10.0
18:56:21 <lambdabot>   False
18:56:21 <idnar> I'm afraid to ask why only b needs Eq
18:56:29 <idnar> oh, I suppose that does make some sense
18:56:37 <ddarius> We tried to implement PHP's equality, but failed.
18:56:39 <kerlo> If they're of different types, you don't really need to compare them.
18:56:45 <idnar> kerlo: yeah
18:57:02 <idnar> ddarius: implement JS's == instead ;)
18:57:15 <kerlo> @index unsafeCoerce
18:57:15 <lambdabot> bzzt
18:57:30 <mauke> > 10.0 === (10 `asTypeOf` 10.0)
18:57:32 <lambdabot>   True
18:57:36 <kerlo> > let unsafeCoerce = const False in (unsafeCoerce 10) == True
18:57:37 <lambdabot>   False
18:58:02 <ddarius> We all know that fromInteger 10 = False
18:58:13 <kerlo> Yes, but watch this:
18:58:24 <kerlo> > let unsafeCoerce = const True in (unsafeCoerce (id 10)) == True
18:58:25 <lambdabot>   True
18:58:30 <kerlo> See? Applying id to it made it truer.
18:58:34 <pumpkin> > toEnum 10 :: Bool
18:58:35 <lambdabot>   * Exception: Prelude.Enum.Bool.toEnum: bad argument
18:58:41 <mauke> @let a /== b = not (a === b)
18:58:42 <lambdabot>  Defined.
19:01:56 <gwern> @seen malde
19:01:56 <lambdabot> I haven't seen malde.
19:01:59 <idnar> kerlo: haha
19:02:00 <gwern> @seen kmalde
19:02:00 <lambdabot> I haven't seen kmalde.
19:02:03 <gwern> @seen ketil
19:02:03 <lambdabot> I saw ketil leaving #haskell 5m 2d 4h 8m 40s ago, and .
19:02:27 <gwern> @ask ketil you know that darcs bio is currently broken with 6.10 because of a data.map change right?
19:02:28 <lambdabot> Consider it noted.
19:02:36 * dcoutts pushes new `cabal info` command
19:02:38 <idnar> > fromInteger 10 :: Bool
19:02:39 <lambdabot>       No instance for (Num Bool)
19:02:39 <lambdabot>        arising from a use of `fromInteger' a...
19:02:46 <gwern> @ask ketil which also breaks xml2x as it deps on darcs bio AFAIC
19:02:46 <lambdabot> Consider it noted.
19:02:48 <ddarius> dcoutts: What does it do?
19:02:54 <dcoutts> gwern, ddarius: feedback appreciated :-)
19:03:00 <gwern> ddarius: tells you information about a package, Id guess
19:03:12 <dcoutts> http://hackage.haskell.org/trac/hackage/ticket/456#comment:1
19:03:19 <dcoutts> ddarius: for example ^^
19:03:24 <idnar> did anyone implement cabal destroy-the-sun yet?
19:03:37 <dcoutts> idnar: patches accepted ;-)
19:03:43 <idnar> maybe that should be unsafe-cabal destroy-the-sun
19:03:49 <ddarius> So it saves you from having to go to the hackage page?
19:04:26 <gwern> dcoutts: what is the downloaded: field for?
19:04:27 <dcoutts> ddarius: I guess so yes, it also tells you info about installed packages
19:04:46 <dcoutts> gwern: yeah, I'd appreciate suggestions on that in particular, see the comment
19:04:52 <kerlo> Can I ask Agda questions in here?
19:05:18 <gwern> dcoutts: 'cached'
19:05:21 <pumpkin> kerlo: not sure many people in here know agda
19:05:23 <gwern> since that's what the other messages use
19:05:31 <dcoutts> gwern: true
19:05:41 <gwern> dcoutts: does that field even work? 'cabal info xmonad' told me No, but cabal fetch told me 'already cached'
19:05:45 <dolio> More here than anywhere else you're likely to go.
19:05:52 <dcoutts> gwern: that's one of the remaining TODOs
19:06:07 <kerlo> There is #agda, with about six people in it.
19:06:16 <dcoutts> ddarius: for example where the docs got installed, in future we might record if the profiling libs are installed etc
19:06:44 <dolio> Are they all here, too?
19:07:17 <ddarius> dcoutts: Does it say if it is installed globally v. user-level ?
19:08:19 <kerlo> dolio: I think you're the only one there who's also here.
19:09:26 <dolio> No, I just checked. They're all in this room. :)
19:09:35 <dcoutts> ddarius: not at the moment, add a comment to that ticket
19:10:04 <CakeProphet> > [] > [2]
19:10:06 <lambdabot>   False
19:10:19 <dcoutts> ddarius: we don't actually track what packages come from what package dbs, so it'd be a bit hard
19:10:25 <kerlo> Oh.
19:10:32 <dcoutts> ddarius: we can say where it is installed though
19:10:54 <ddarius> dcoutts: That would suffice.
19:11:08 <ddarius> In fact it is probably more useful information.
19:11:27 <dcoutts> ddarius: though we do not know it for programs
19:11:38 <dcoutts> we do not track the installed status of programs
19:11:44 <dcoutts> since they do not get registered
19:11:57 <dolio> kerlo: I think I've only seen two of them talk, ever. But I don't know if they talk in #agda, either.
19:11:59 <dcoutts> ddarius: so we can only say where the lib is, ie the .a and .hi files
19:12:18 <dcoutts> ddarius: it may have other files installed but we do not track those
19:12:38 <dcoutts> ddarius: we've only got the info that "ghc-pkg describe" has
19:14:32 <ddarius> Except that it is theoretically not ghc specific, what is the benefit of cabal info over ghc-pkg describe?
19:15:16 <dcoutts> ddarius: it's a summary of the most useful bits and it merges the info about installed and available packages
19:16:05 <dcoutts> ddarius: the info provided by ghc-pkg describe is in a format defined by Cabal. Other compilers will eventually provide the same info (even if we do it just by dropping files in the package dirs)
19:16:29 <pumpkin> anyone here have any experience with the matlab package on hackage?
19:18:12 <dcoutts> ddarius: you'd be surprised but many new users are not aware of ghc-pkg at all and just use the cabal-install command.
19:19:08 <roconnor> hmm
19:19:14 * roconnor tries to unaway
19:20:06 <ddarius> edwardk: I'm working on an article for the Monad Reader.  Once I actually have something readable, would you mind looking it over?
19:20:32 <ddarius> edwardk: I have code today that you might find interesting related to it as well.
19:20:57 <edwardk> ddarius: sure, i should be able to find time
19:21:06 <roconnor> ah
19:21:10 <pejo> ddarius, what is the article about?
19:21:10 <roconnor> unaway worked
19:21:24 <edwardk> i am taking tomorrow off of work to recover from a fandom con.
19:21:58 <ddarius> pejo: How the monads in Haskell arise from fundamental categorical constructs.
19:22:01 <elly> edwardk: which one?
19:22:06 <ddarius> And how they're related, etc.
19:22:09 <edwardk> elly: arisia
19:22:17 <elly> hm, I have not heard of that
19:22:24 <edwardk> its out here in boston
19:22:34 <elly> oh, neat
19:22:37 * elly googled
19:25:40 * edwardk can't recall if joachim breitner uses irc here or if i just talk to him over blogs
19:25:59 <ddarius> I don't think he does.  I can't think of his nick, but I could just not know the mapping.
19:26:19 <edwardk> yeah thats what was bugging me too, going to guess not then ;)
19:26:48 <mauke> preflex: seen nomeata
19:26:48 <preflex>  nomeata was last seen on #haskell 4 hours, 6 minutes and 33 seconds ago, saying: Iâd expect "HasIdentity Hask Either Void", as Either a Void seems equivalent to a, but not (a,Void).
19:26:49 <dons> edwardk: nomeata
19:26:55 <edwardk> ah
19:27:34 <edwardk> i lost my pidgin settings a few months back which had included the real world names of everyone i talked to and knew them for on here, bah
19:27:59 <mauke> preflex knows a few
19:28:04 <ddarius> edwardk: There's a page on the wiki that has such a mapping for many people (or maybe it was on the old wiki)
19:28:25 <edwardk> yeah i had raided that and extended it for a couple of years in passing, oh well.
19:28:32 --- mode: ChanServ set +o mauke
19:28:32 --- mode: mauke set -b *!?=yxxob@*
19:28:53 <fy-co> edwardk, jabber?
19:28:54 <fy-co> edwardk  jabber.org  can sometimes help you to recover
19:29:06 <ddarius> http://haskell.org/haskellwiki/Haskell_user_locations, but it doesn't have nomeata
19:30:32 --- mode: mauke set -o mauke
19:37:52 <cjs> Hm. So in building the derive package under cabal 1.6, I specified --package-db, and the dist/setup config indeed has '      withPackageDB = SpecificPackageDB "/u/cjs/co/client/tsuru/2trader/release/package.conf' in it, yet the final executable, when run, complains that it can't find Data.Derive.All.
19:38:15 <pumpkin> is there some way I can tell cabal-install custom parameters to pass to ./configure?
19:38:30 <cjs> Any thoughts on how to deal with this?
19:38:39 <pumpkin> if I run configure myself with special parameters, I can get it to work fine, but cabal install does't
19:40:08 <pumpkin> aha, --configure-option
19:42:42 <pumpkin> hmm, doesn't seem to be doing it
19:42:51 <cjs> Wow, ghc gets really upset when you give it a  GHC_PACKAGE_PATH that doesn't include the base libs. :-)
19:43:07 <mauke> GHC SMASH!
19:43:17 <kiris> -- space-char <- [.\t\n\r?!\u0020]
19:43:17 <kiris> spaceChar = satisfy $ flip any ".\t\n\r?!\0020" . (==)
19:43:17 <kiris> -- non-space <- !space-char .
19:43:18 <kiris> nonSpace = ... -- how can I define this with ReadP?
19:44:35 <pumpkin> MATLAB is such a POS on mac os
19:46:52 * mmorrow loves how ghosting is called "ghosting"
19:47:13 <mmorrow> apt name
19:47:16 <monochrom> which ghosting? copying hard disks?
19:47:36 <mmorrow>  /ghost mmorrow ***
19:48:38 <monochrom> Oh, now I see.
19:48:59 <mmorrow> :)
19:49:26 <mmorrow> oh sweet! ReadP!
19:49:32 * mmorrow is looking at the logs
19:49:59 * mmorrow pastes it again since so it's in hist scrollback
19:50:11 <mmorrow> 19:43:17 <kiris> -- space-char <- [.\t\n\r?!\u0020]
19:50:11 <mmorrow> 19:43:17 <kiris> spaceChar = satisfy $ flip any ".\t\n\r?!\0020" . (==)
19:50:11 <mmorrow> 19:43:17 <kiris> -- non-space <- !space-char .
19:50:11 <mmorrow> 19:43:18 <kiris> nonSpace =
19:50:40 <kiris> haha what
19:50:48 <kiris> I was just wondering if you were here
19:51:36 <pumpkin> I WILL DEFEAT THIS PACKAGE
19:51:41 <kiris> I think I can define a function f where `f p' succeeds if p fails, with `look'. but I was wondering if there was a cleverererer way
19:51:41 <byorgey> @type satisfy
19:51:42 <CakeProphet> is there any particular reason why Haskell's type system couldn't support polymorphic types of two or more concrete types.
19:51:42 <lambdabot> Not in scope: `satisfy'
19:51:51 <kiris> satisfy :: (Char -> Bool) -> ReadP Char
19:52:11 <mmorrow> myIsSpace = (`elem` "\t\n\r?!\x20"); spaceChar = satisfy myIsSpace; nonSpaceChar = satisfy (not . isSpace)
19:52:11 <CakeProphet> like (IO | ST)... for instance.
19:52:36 <Olathe> @type satisfy
19:52:37 <lambdabot> Not in scope: `satisfy'
19:52:51 <byorgey> I mean, you could always do  satisfy $ flip all ".\t\n\r?!\0020" . (/=), of course
19:53:14 <byorgey> but I realize you're asking how to negate spaceCar specifically.
19:53:18 <byorgey> *spaceChar
19:53:48 <kiris> mmorrow: the problem is I need a `not' for parsers, so they can be composed and such
19:53:56 <byorgey> @seen gwern
19:53:57 <lambdabot> gwern is in #darcs, #xmonad and #haskell. I last heard gwern speak 48m 15s ago.
19:53:58 <parodyoflanguage> > map (+1) [1..10]
19:54:00 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
19:54:07 <kiris> (there are more complex rules than just checking for space)
19:54:50 <mmorrow> kiris: yes, this may be possible
19:54:52 * mmorrow thinks
19:55:00 <kiris> initial <- (affricate / sibilant? other? liquid?) !consonant !glide
19:55:00 <kiris> etc
19:55:10 <byorgey> @tell gwern thanks for the report, I'll try to upload a fix release tomorrow
19:55:11 <lambdabot> Consider it noted.
19:55:24 <mmorrow> although i've been able to work around this seeming omission without too much trouble
19:55:40 <monochrom> kiris: notFollowedBy of Parsec may be helpful
19:55:47 <mmorrow> kiris: that's what `choice' is for
19:56:18 <mmorrow> ah, disregard that comment, just parsed that
19:56:49 <mmorrow> i usually "work around it" by making a bunch of (Char -> Bool)'s, and not parsers as primitives
19:57:00 <mmorrow> then it's easy to handle `not'
19:57:13 <kiris> monochrom: yeah, I'm familiar with that. when I used Parsec to write this parser I used notFollowedBy to do `!'
19:57:57 <mmorrow> kiris: ReadP is excellent (and better (different approach) than parsec imo)
19:58:53 <pumpkin> does cabal-install build docs automatically?
19:59:09 <pumpkin> if so, where does it put them?
19:59:13 <kiris> mmorrow: the deepth searching of parsec was too slow. took 10 seconds to parse a word "this" long, because the way the parsing grammar is written it relies on recursion and look ahead and such like. I'm basically trying to translate it into haskell
19:59:14 <chessguy> @go ReadP haskell
19:59:16 <lambdabot> http://cvs.haskell.org/Hugs/pages/libraries/base/Text-ParserCombinators-ReadP.html
19:59:16 <lambdabot> Title: Text.ParserCombinators.ReadP
19:59:34 <kiris> mmorrow: I'm thinking readP's +++ will be much better for this task
19:59:43 <mmorrow> kiris: there're some utility/misc functions in here that might be helpful if you're looking to make the switch (util funcs toward the bottomish) http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=766
19:59:48 <mauke> bah, look :: ReadP String -- fail!
20:00:06 <mmorrow> kiris: totally. Parsec depth-first is sucky.
20:00:14 <kiris> mauke: should be look :: ReadP a -> ReadP () ?
20:00:16 <mmorrow> mauke: it's easy to modify
20:00:21 <monochrom> kiris: in general perhaps something like: (p >> fail "blah") `mplus` return ()
20:00:32 <mauke> mmorrow: no, it isn't, it's a standard library
20:00:45 <monochrom> there are some backtracking subtlety for specific parsers.
20:00:57 <monochrom> err, s/parsers/parser libraries/
20:00:58 <mmorrow> there's a bytestringreadp on hackage, and i've seen it modded many times in larger projects
20:01:38 <kiris> mmorrow: some nice utils there, cheers ears
20:02:12 <mauke> so ... no parse errors?
20:02:18 <b\6> how to fix this ghc 6.10.1 and process issue? http://hpaste.org/14074
20:02:19 <mmorrow> np. also, lunabot has ReadP in-scope if you want to mess around
20:02:46 <mmorrow> mauke: parse errors are for those that admit failure!
20:02:46 <kiris> neat
20:03:10 <mauke> one day I'm going to finish my parser (hah) and upload it to hackage
20:03:17 <mmorrow> mauke: (also, Parsek (which ReadP came out of from what i understand) has support for that)
20:03:38 <kiris> , readP_to_S (char "Î©") "Î©"
20:03:40 <lunabot>  luna: Couldn't match expected type `GHC.Types.Char'
20:03:46 <kiris> , readP_to_S (char 'Î©') "Î©"
20:03:48 <lunabot>  [('\937',"")]
20:03:54 <kiris> ^_ ^!
20:03:54 <mauke> what other parser libraries are there?
20:04:03 <ddarius> mauke: There's armies.
20:04:11 <kiris> mmorrow: have you been learning lisp?
20:04:13 <ddarius> mauke: UU has some of it's own.
20:04:15 <mmorrow> mauke: here's ReadP dressed up with the full Parsec interface http://www.augustsson.net/Darcs/Parsek/
20:04:27 <mmorrow> (and polymorphic in the "String")
20:04:42 <mauke> http://hackage.haskell.org/packages/archive/Encode/1.1/doc/html/Parsek.html
20:04:42 <ddarius> @google uulib
20:04:44 <lambdabot> http://search.cpan.org/dist/Convert-UUlib/
20:04:44 <lambdabot> Title: Marc Lehmann / Convert-UUlib - search.cpan.org
20:05:03 <mmorrow> kiris: not in particular, but i guess it's unavoidable to do so to some extent by just reading various functional prog stuff
20:05:31 <kiris> mmorrow: I was referring to your parentheses (in your messages (which isn't a bad thing (probably)))
20:05:32 <ddarius> http://www.cs.uu.nl/wiki/bin/view/HUT/ParserCombinators
20:05:54 <mmorrow> kiris: haha, that one flew right by me ;)
20:05:56 <pumpkin> what's happening at the cabal step "Preprocessing library..." ?
20:06:13 <kiris> mmorrow: but which is better? parsek or readP?
20:06:35 <mmorrow> kiris: they use they same underlying datatype/method/algo/what-have-you
20:07:11 <mmorrow> so it's just a question of preference/convenience
20:07:36 <kiris> mmorrow: readP doesn't seem to support uhh thingies, the cool "unexpected" stuff that parsek does
20:07:48 <mmorrow> the one thing though that parsek /does/ have that ReadP doesn't is direct support for attaching error info to the `P' type
20:07:55 <mmorrow> yes, exactly
20:08:07 <mmorrow> that's definitely a plus
20:08:21 <kiris> could probably monad transform the ReadP if you really wanted to?
20:08:41 <kiris> probably be basically rewriting it, though
20:08:44 <mmorrow> kiris: you could with some hacking
20:09:13 <kiris> write combinators use ErrorT or w/e
20:09:37 <kiris> think I'll try parsek instead
20:09:55 <mmorrow> i sat down and hacked my own personal ReadP variant starting with the ReadP src and i learned a ton (the P datatype is really cool, along with its mplus instance)
20:10:43 <kiris> where's the P datatype?
20:10:51 <pumpkin> this is the most painful thing ever, getting the matlab package to compile on mac os
20:10:53 <mmorrow> it's hidden
20:10:57 <mauke> parsek sucks because it requires lists
20:11:15 <monochrom> lists are bad?
20:11:21 <Olathe> What would be better than lists for that ?
20:11:35 <kiris> oh yeah I see it, mmorrow
20:11:38 <mauke> the UU stuff has no good docs
20:12:05 <mauke> Olathe: something like (Stream s) => s
20:12:11 <mmorrow> mauke: oh yuk, yeah true. you can hack up a ReadP for ByteStrings though
20:12:27 <monochrom> I see. That kind of "require".
20:12:49 <mmorrow> ReadP is also great because it's so short and sweet
20:12:56 <mauke> how does Parsek handle error locations?
20:13:12 <mmorrow> mauke: i'm not sure, but i've been meaning to find out actually
20:13:43 <mauke> this could be done with a custom stream transformer that keeps track of where you are
20:14:59 <kiris> http://www.augustsson.net/Darcs/Parsek/Text/ParserCombinators/Parsek/Pos.hs
20:15:01 <Olathe> mauke: Ahh.
20:15:11 <mmorrow> mauke: (i'm not sure how parsek does it but) i think it'd be straightforward to get precise location info for errors by having [Expected]/etc attached to Fail, and then in the `run' (or equivalent in parsek) function you'd cound chars/whatever consumed and then attach the curr location to the info attached to Fail as it comes
20:15:33 <mmorrow> (which'll be a lot even in a successful parse of course, on account of breadth-first)
20:15:42 * pumpkin is getting pissed off at how convoluted this whole build process is :(
20:16:30 <mmorrow> mauke: that'd be awesome if there was a way to add location info without requiring modification
20:17:41 <cjs> Hm. Getting derive to derive an NFData instance for ByteString seems tricky. Has anyone done this before?
20:18:42 <mmorrow> cjs: i think it'd just be "id" for strict ByteStrings
20:19:18 <cjs> Hm. But I'm trying to do lazy.
20:19:21 <ddarius> cjs: Just write it yourself instead of deriving it then.
20:19:22 <mmorrow> (and lazy one'd be the list NFData + id i'd ugess)
20:19:24 <cjs> http://hpaste.org/14075
20:19:24 <mmorrow> *guess
20:19:40 <cjs> Yes, it's looking as if I'll have to. There also seem to be issues with qualified imports....
20:20:14 <kiris> let p = char 'k'; read = readP_to_S ((p >> fail "blah") `mplus` return ()) in (read "k",read "x")
20:20:16 <kiris> , let p = char 'k'; read = readP_to_S ((p >> fail "blah") `mplus` return ()) in (read "k",read "x")
20:20:19 <lunabot>  ([((),"k")],[((),"x")])
20:20:21 * pumpkin screams
20:20:32 * kiris massages pumpkin
20:20:46 <pumpkin> I HATE THIS MATLAB PACKAGE BUT I WANT IT :(
20:20:52 <mmorrow> heh
20:20:53 <kiris> that's what she said
20:21:22 <intoverflow> pumpkin: what package?
20:21:29 <pumpkin> the matlab one on hackage
20:21:32 <intoverflow> ah
20:21:37 <kiris> mmorrow: doesn't look right? ^
20:21:50 <pumpkin> I've spent the past hour massaging it to compile on my system
20:22:01 <pumpkin> where it's full of linux-specific defaults
20:22:07 <intoverflow> matlab is the most unstable programming environment I've worked in
20:22:23 <pumpkin> intoverflow: oh, I hate MATLAB too, but I hate this package more for now
20:22:25 <intoverflow> I can't fathom why you'd want to *infest* Haskell with it
20:22:31 <mauke> great, parsek has the broken notFollowedBy from parsec
20:22:49 <kiris> mauke: broken in what respect?
20:22:50 <pumpkin> intoverflow: it's handy for "playing with data" and graphing things quickly, so I'd like to be able to pass data back and forth
20:23:04 <pumpkin> integral: all I really need is the .mat output module
20:23:11 <Nafai> If I do a "let x = 1" in ghci, and then do :show bindings, it shows "x :: Integer = _"
20:23:14 <mauke> kiris: look at the type signature
20:23:17 <Nafai> Why is it _ instead of 1?
20:23:17 <intoverflow> pumpkin: it also gives me an opportunity to judge your abilities as an engineer without having any background in what you're trying to do.
20:23:29 <pumpkin> :o
20:23:43 <intoverflow> (the last comment meant to criticize myself for getting involved)
20:23:54 <Olathe> > let x :: Integer = 5 in x
20:23:55 <lambdabot>   5
20:24:03 <Nafai> intoverflow: Was it your blog that has the post about IDEs?
20:24:03 <Olathe> Well, that should shorten some things.
20:24:13 <intoverflow> Nafai: yeah
20:24:21 <Olathe> > let f _ :: a -> Integer = 5 in f "Hello"
20:24:22 <lambdabot>   <no location info>: Parse error in pattern
20:24:27 <Olathe> Maybe not.
20:24:35 <Olathe> > let f :: a -> Integer = const 5 in f "Hello"
20:24:36 <lambdabot>   Not in scope: type variable `a'
20:24:39 <kiris> mauke: what about it?
20:24:42 <ironfroggy_> the tutorial section 7, lists this code but is the last mention of 'sequence' a typo that should be 'sequence_'? http://mibbit.com/pb/TWhZQS
20:24:43 <cjs> Darn, that was easy to write. Took me like 15 seconds.
20:24:45 <mmorrow> pumpkin: a pure-haskell .mat output pkg would be sweet
20:24:47 <mauke> kiris: it doesn't make sense
20:24:52 <pumpkin> mmorrow: yes :/
20:24:55 <Nafai> intoverflow: I've found IDE is too charged of a word, people think of big bulky things that do everything for you
20:25:02 <Nafai> intoverflow: I prefer "language aware tool"
20:25:05 <pumpkin> mmorrow: I'd write one but really just need to have one working right now :/
20:25:17 <cjs> http://hpaste.org/14076
20:25:19 <mmorrow> pumpkin: i hate those times ..
20:25:24 <Nafai> intoverflow: I need those features, like code navigation, completion, etc to be productive
20:25:25 <cjs> Lemmie know if that looks wrong....
20:25:38 <bd_> ironfroggy_: indeed, it should be sequence_
20:25:42 <Nafai> intoverflow: Even as simple as easily jumping to the definition of some std library code
20:25:42 <mmorrow> pumpkin: maybe snake something from the octave src?
20:25:54 <intoverflow> Nafai: heh.  In the case of my article, I was claiming that Haskell has enough tools to support serious development.  For many people, since the tools weren't integrated into a single application, Haskell wasn't actually production-ready
20:26:18 <pumpkin> mmorrow: maybe, hmm, but I haven't written any FFI code so far and am not sure deadline time is a good time to be figuring it out
20:26:21 <Nafai> intoverflow: Well, I want to tie them all in together better in Emacs :)
20:26:42 <pumpkin> mmorrow: but later, I'll probably at least use the octave code to figure out the .mat format for a pure .mat lib :P
20:26:44 <Nafai> Olathe: Interestingly, I note that after I use x in something, 1 does show up in the bindings
20:26:51 <Nafai> Olathe: Is this due to laziness or something?
20:26:54 <mmorrow> pumpkin: i mean as in maybe the fmt is super simple as is already spelled out for you by some octave code (or not)
20:26:59 <cjs> pumpkin: FFI is easy and sweet.
20:27:02 <mmorrow> pumpkin: yeah, exactly
20:27:05 <Olathe> Nafai: I think so.
20:27:22 <pumpkin> mmorrow: I'll take a peek in the source
20:27:22 <intoverflow> pumpkin: you could also look to use the python bindings to get into SAGE
20:27:38 <cjs> intoverflow: Got a reference to your article? I'm planning an experience report for ICFP.
20:27:51 <pumpkin> mmorrow: given the rest of the MATLAB engineering though, I seriously doubt .mat is a very simple format :P
20:28:01 <intoverflow> cjs: http://intoverflow.wordpress.com/2009/01/13/why-haskell-is-beyond-ready-for-prime-time/
20:28:02 <cjs> Part of that will be an examination of the state of the tools. (My opinion: ghc is great.)
20:28:04 <pumpkin> intoverflow: not a big fan of python :/
20:28:12 * intoverflow high-fives pumkin
20:28:34 <Nafai> I used to be
20:28:47 <Nafai> But now that I actually got away from Java to do Python dev work at work
20:28:50 <Nafai> I want Haskell
20:29:06 <intoverflow> cjs: ghc really is great; interactive mode is absurdly useful for navigating a project.  Second on my list is hoogle and hayoo.
20:29:22 <pshc_> So is there anyway to have a list of values of different types but all in the same typeclass?
20:29:44 <intoverflow> pshc_: existential types can do that
20:29:54 <pshc_> oho
20:30:07 <intoverflow> pshc_: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#Example:_heterogeneous_lists
20:30:20 <Nafai> intoverflow: Can you use interactive mode to jump to the source of a given function?
20:30:42 <pshc_> Heterogeneous, that's the word I was looking for :)
20:30:44 <pshc_> Thanks!
20:30:59 <intoverflow> Nafai: iirc it won't show the source, but it will tell you the file and line number
20:31:31 <kiris> mmorrow: here's the grammar I'm trying to port to haskell, btw. if you know of a way to use this from haskell without having to essentially rewrite all of it, I'd like to hear it: http://www.lojban.com/tiki/tiki-index.php?page=BPFK%20Section:%20PEG%20Morphology%20Algorithm
20:31:51 <intoverflow> Nafai: nevermind, it will show source.  use :list <name>
20:32:30 <Nafai> Just for interpreted code it seems
20:32:32 * mmorrow looks
20:32:40 <pumpkin> when ghc reports it can't find a symbol, is it pre-c-demangled? unknown symbol `_mxCreateNumericArray'... does that mean the actual symbol name it's looking for is __mxCreateNumericArray or _mxCreateNumericArray?
20:33:10 <mmorrow> kiris: chrisdone is way into lojban and is using haskell for some related stuff, i'd bet he has a bunch of info
20:33:22 <kiris> mmorrow: that's me
20:33:26 <mmorrow> haha
20:33:26 <Olathe> pumpkin: It's usually because you didn't use --make
20:33:39 <adityam> @pl f (a,b) (c,d) = (c, b+d)
20:33:40 <lambdabot> f = (`ap` snd) . (. fst) . flip ((.) . (,)) . (+) . snd
20:33:43 <kiris> mmorrow: nice to see you're recommending me to lojban enthusiasts though :P
20:33:44 <Olathe> pumpkin: I'm not sure what magic --make does, though.
20:33:46 <pumpkin> Olathe: wasn't me! this is from a cabal-install nightmar :P
20:33:48 <mmorrow> kiris: heh
20:33:50 <intoverflow> heh
20:33:58 <Olathe> pumpkin: Ahh.
20:34:24 <mmorrow> pumpkin: the horror! http://hg.savannah.gnu.org/hgweb/octave/file/0eb83938c8bc/src/ls-mat5.cc
20:34:43 <pumpkin> mmorrow: :(
20:34:52 <pumpkin> yeah, it is rather gross
20:35:29 <kiris> mmorrow: I dabble about with the idea of parsing from native haskell from time to time. currently there are no C library parsers, just a Java program that can be used as a pipe which is slow as fuck for heavy text analysis
20:36:03 <ddarius> goto data_read_error; ..... data_read_error: return 1;
20:36:13 <ddarius> And this is C++ !
20:36:19 <mmorrow> kiris: omg the pipe to java, horror!1
20:36:24 <kiris> mmorrow: haha
20:37:24 * kiris dabbles more with readp
20:38:00 <mmorrow> kiris: i think it'd be at least helpful (possibly extremely) to parse that actual grammar itself to some AST. then you could transform that maybe into some form that could (in an ideal case) be used to construct a haskell parser for the grammar it describes
20:38:54 <pstickne> isn't there Happy or something?
20:39:02 <mauke> join :: Parser (Parser a) -> Parser a :-)
20:39:29 <mmorrow> pstickne: but you have to write it in happy's syntax in such a way that happy is happy :)
20:39:30 <kiris> happy does that but last I used it it was really broken and gave enragingly bollocks errors
20:39:43 <kiris> mmorrow: heh
20:39:49 <pstickne> mmorrow:  :(
20:39:49 <mauke> .oO( C++ )
20:39:55 <kiris> mmorrow: yeah, maybe I can translate it automatically to readp
20:39:56 <pstickne> mauke--
20:40:00 <kiris> mauke++
20:40:05 <CakeProphet> > throwDyn "Hello"
20:40:06 <lambdabot>   Not in scope: `throwDyn'
20:40:16 <mmorrow> kiris: yes! that's what i was thinking (that'd be really cool if this works out)
20:40:48 <mauke> pstickne: :-(
20:41:01 <pstickne> mauke:  don't worry, kiris loves you! :)
20:41:04 * mmorrow imagines a parser for some grammar description lang w/ associated automatic generation of ReadP parsers
20:41:09 <pumpkin> alright, fuck this library, back to CSV for me :(
20:41:14 <mmorrow> hah
20:41:21 <pumpkin> it's ridiculous
20:41:25 <pumpkin> MATLAB is such a piece of shit
20:41:28 <mmorrow> yes
20:42:04 <pumpkin> they seem to have decided to add a _700 suffix to all their function names
20:42:19 <pumpkin> that this haskell lib doesn't expect
20:42:38 <mmorrow> maybe that's what they were charging for that student version or something?
20:43:05 <pumpkin> so: unknown symbol `_mxCreateNumericArray' should actually go after mxCreateNumericArray_700
20:43:12 <pumpkin> or so my nm on the relevant libraries tells me
20:43:35 <pumpkin> mmorrow: didn't know they made a distinction, I just got my copy through my school
20:44:32 <kiris> hhhm
20:44:57 <mmorrow> i had a numerical analysis class where matlab was used and i refused to buy it or use it, and suffered with trying to write octave code that would run in matlab
20:45:06 <mmorrow> (i never broke either!)
20:45:15 <pumpkin> :)
20:45:26 <monochrom> You should refuse to buy it, but you should accept to use it.
20:45:38 <pumpkin> my school has a site license or something similar for it
20:45:47 <ddarius> You should accept to buy it, but you should refuse to use it.
20:45:47 <pumpkin> I can just download it, but it doesn't mean I like using it
20:45:53 <mmorrow> yeah, i didn't actually have to buy it i guess
20:46:02 <mmorrow> but i stil refuse to use it :)
20:46:22 <monochrom> Oh, I don't like using English at school either. Should I refuse to use it?
20:46:23 <intoverflow> I used it at work; I admit, I got a lot of stuff done very quickly in it.  But I couldn't ever imaging paying what they want for it.
20:46:33 <mmorrow> monochrom: yes.
20:46:40 <pumpkin> it's very handy for playing around with data and graphing it
20:46:49 <monochrom> OK! My next presentation will be in Chinese!
20:46:50 <ddarius> intoverflow: The cost wasn't worth the productivity you gained?
20:46:51 <pumpkin> but I dread doing anything more significant than that in it
20:46:56 <mmorrow> monochrom: yay!
20:47:18 <intoverflow> ddarius: for my employer I am sure that it was.  For the signals work I do in my garage, it certainly is not.
20:47:21 <kiris> word <- lojban-word / non-lojban-word
20:47:22 <kiris> lojban-word <- cmene / cmavo / brivla
20:47:22 <kiris> maybe for this?
20:47:22 <kiris> data T_Word = Word_LojbanWord T_LojbanWord | Word_NonLojbanWord T_NonLojbanWord
20:47:25 <kiris> data T_LojbanWord = LojbanWord_Cmene | LojbanWord_Cmavo | LojbanWord_Brivla
20:47:28 <kiris> where T_ is some provided prefix to the parser generator
20:47:36 <mmorrow> hmm
20:47:56 <kiris> uh, with the Strings in there..
20:47:59 <ddarius> intoverflow: "signals work [you] do in [your] garage" sounds interesting
20:48:55 <kiris> mmorrow: either generating custom types or.. every parse result is a tuple of what the parser was called and the value it returned, perhaps? or, I dunno another way
20:49:01 <intoverflow> ddarius: it really isn't.  I've been learning some signal analysis so that I can later take up software-defined radio, but for the time being I've just been writing things that deal with audio
20:49:05 <mmorrow> kiris: i'm think maybe something non-particular to the content of the description at first, as a way to just the structure of the description in
20:49:25 <ddarius> intoverflow: Signal processing is fun!
20:49:31 <nodogbite> intoverflow: i assume you've seen gnuradio
20:49:33 <kiris> mmorrow: yeah
20:49:40 <mmorrow> data Production = Production Name PegExp
20:49:44 <mmorrow> data PegExp = ....
20:49:51 <gwern> hm jeffersonheard  == jeff heard?
20:49:51 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
20:49:52 <intoverflow> ddarius: I 100% agree.  I'm taking a course in wavelets this term
20:50:06 <gwern> @messages
20:50:06 <lambdabot> byorgey said 54m 55s ago: thanks for the report, I'll try to upload a fix release tomorrow
20:50:14 <gwern> @seen jeffersonheard
20:50:15 <lambdabot> jeffersonheard is in #haskell. I don't know when jeffersonheard last spoke.
20:50:19 <kiris> mmorrow: what would PegExp be?
20:50:20 <gwern> @seen jeffheard
20:50:20 <lambdabot> I haven't seen jeffheard.
20:50:24 <mauke> preflex: seen jeffersonheard
20:50:25 <preflex>  jeffersonheard was last seen on #haskell 4 days, 7 hours, 58 minutes and 37 seconds ago, saying: gwern: think teleconferencing, but instead of a virtual whiteboard for people to draw on, you have a virtual map for people to pin things to and draw on, and "things" can be anything from quick snippets of text to anything that can be viewed on the web currently
20:50:25 <intoverflow> nodogbite: yeah, although I don't have any A-to-D equipment so I haven't done much with it
20:50:36 * mmorrow is trying to decipher 
20:50:49 <nodogbite> intoverflow: yeah, that's what hung me up about gnuradio too
20:50:59 <ddarius> Make some A/D stuff.
20:51:12 * ddarius has considered making and ADC just for the heck of it.
20:51:52 <gwern> @ask jeffersonheard re http://vis.renci.org/jeff/?p=52 - how open is the RENCI license? the cabal file claims BSD3 but your LICENSE is different
20:51:52 <lambdabot> Consider it noted.
20:51:53 <nodogbite> ddarius: unfortunately it would take me too long to make A/D stuff
20:51:54 * Nafai is doing the RHW exercises in literate haskell
20:51:59 <nodogbite> ddarius: not enough hardware skillz
20:52:00 <ddarius> nodogbite: Why?
20:52:11 <Nafai> Anyone know if there is an lhs -> markdown converter?
20:52:11 <gwern> actually, how is gnu radio doing? I read a long article about it like 4 years ago and have heard nothing since
20:52:22 <mmorrow> data PegExp = Concat PegExp PegExp | OrderedAlt [PegExp] | Optional (Maybe PegExp) PegExp | Rep PegExp [PegExp] | ...
20:52:24 <nodogbite> gwern: it seems to have stalled slightly
20:52:27 <intoverflow> ddarius: I don't have much circuits experience.  The EE dept here at Utah does a lot of software defined radio work, so I've been meaning to head up to give them a visit, but grad school being what it is time is in short supply
20:52:31 <gwern> Nafai: that doesn't really make sense?
20:52:36 <nodogbite> gwern: IMO, the hardware is too expensive
20:52:43 <mmorrow> kiris: i'd just encode that numbered list more or less directly
20:52:44 <gwern> Nafai: you know files can be lhs and markdown at the same time right
20:52:50 <mmorrow> (somehow)
20:52:58 <ddarius> EE is a nice application of signal processing.
20:52:59 <kiris> u'i
20:53:01 <gwern> nodogbite: still? moore's law not working for radios?
20:53:14 <kiris> mmorrow: but where do the strings come in?
20:53:23 <ddarius> MIT OpenCourseWare has a decent lecture series (videos) for an introductory course on circuit design.
20:53:27 <mmorrow> kiris: those would be something like:
20:53:31 <nodogbite> gwern: i suspect somebody with skill could build their own just fine
20:53:32 <gwern> nodogbite: or to put it another way, how expensive is too?
20:53:34 <mmorrow> data PegVar = PegVar String
20:53:45 <nodogbite> gwern: the hardware that's for sale is something like $850
20:53:50 <mmorrow> so this stage just captures the structure of the rules
20:54:07 <gwern> whoa. that's like a couple netbooks or a decent desktop computer
20:54:11 <mmorrow> then another pass would dip down into those Strings in PegVar/whatever
20:54:12 <ddarius> I do wish I had an oscilloscope though...
20:54:24 <intoverflow> Ettus Research makes the least expensive ADC equipment I've seen, and it's over $700.  Part of the trick is that the conversion burns up bandwidth, so you generally need an FPGA to take a pass at the data before sending it out via gigE or usb
20:54:29 <mmorrow> (w/ full knowledge of the structure of the currounding context)
20:54:35 <mmorrow> *surrounding
20:55:04 <kiris> mmorrow: sure
20:55:05 <nodogbite> intoverflow: yeah, i was referrign to Ettus Research -- to expensive for my mild desire to hack
20:55:19 <gwern> Nafai: but if you need to do stuff with .lhs and markdown, you should be looking at Pandoc IMO
20:55:40 <intoverflow> nodogbite:  same here.  TA pay isn't compatible with such things
20:56:01 <mmorrow> PegExp = ... | VarExp PegVar | ...
20:56:02 <kiris> mmorrow: not? data DataPeg = .. | PegVar String
20:56:13 <kiris> err yeah
20:56:13 <ddarius> intoverflow: What bandwidth are you aiming at?
20:56:14 <kiris> pegexp
20:56:21 <mmorrow> or that, sure. any sensible rep should do
20:56:51 <Nafai> gwern: Okay.  I'm just doing my RHW stuff in lhs, just using the default type.  But my blog uses markdown and was wondering what I needed to do to publish
20:56:55 <mmorrow> kiris: (and you probably know what is sensible here more than me since i'm not familiar with peg grammars)
20:57:15 <intoverflow> ddarius: I don't have an application in mind; I was just speaking as a general rule of thumb.  As a frame of reference, I know that it's an issue for real-time processing of GSM signals
20:57:30 <gwern> Nafai: if you're using birdtrack, then you simply make the non-birdtracked sections writing in markdown
20:57:41 <ddarius> I meant for your own stuff, the stuff you'd like to do.
20:58:03 <kiris> mmorrow:  once it's in a proper structure you can write haskell code to bring it into awhatever haskell data structures you need. sounds good to me
20:58:04 <gwern> Nafai: _foo_ [link](bar)\n\n> id a = a\n\nmore _foo_
20:58:06 <gwern> if you follow
20:58:10 * Nafai nods
20:58:22 <mmorrow> kiris: any two representation that both capture all the "information" that's there in that description should be interconvertible/isomorphic
20:58:36 <mmorrow> kiris: yes, exactly!
20:59:19 <gwern> Nafai: and that's basically it. there are subtlteies, like if you're using gitit, or if you use the 'extended' markdown syntax pandoc supports (like to get haskell highlighting), but if your blog software is doing the conversion from markdown to HTML, then you wouldn't be using them I suppose
20:59:50 <kiris> mmorrow: good point
20:59:51 <Nafai> K
21:00:58 <intoverflow> ddarius: I really don't have an application.  I could imaging wanting to look at 802.11 frames or something, but really the business of SDR has an odd attraction
21:01:32 <chessguy> @hoogle [Maybe a] -> [a]
21:01:32 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
21:01:32 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
21:01:32 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
21:01:39 <gwern> Nafai: incidentally markdown goes very well with gitit
21:01:45 * gwern plugs gitit yet again :)
21:02:14 <kiris> pandoc<3
21:02:18 <gwern> gitit and darcs, two great flavors that go great together!
21:02:30 <kiris> like marmite and ham!
21:02:36 <pumpkin> oh I think I know my problem
21:02:39 <pumpkin> mmm marmite
21:02:48 <gwern> I've never tried the former, so I will enthusiastically agree!
21:03:11 <pumpkin> if I see #include <matrix.h> in a .hsc file, will that automatically be run through the c preprocessor and have #defined symbols replaced?
21:03:49 <mauke> not directly
21:04:03 <mauke> hsc2hs actually turns your source into a bunch of printf statements
21:04:11 <kiris> mmorrow: writing a parser for a parsing expression grammar to produce a parser... fun!!
21:04:48 <pumpkin> mauke: my issue is that the matlab .h files redefine things like mxCreateNumericArray to mxCreateNumericArray_700, and that doesn't seem to be happing in this .hsc file (the output is looking for the suffixless one)
21:04:52 <roconnor> yo dawg, I head you like parsers ...
21:04:59 <kiris> roconnor: haha
21:05:02 <roconnor> heard
21:05:18 <kiris> mmorrow: oh, shabba. did you see System.Process's additions? readProcess and readProcessWithExitCode?
21:06:05 <pumpkin> mauke: any way I can get that preprocessor subsitution to work right?
21:06:59 <pumpkin> (or anyone else)
21:07:01 <mauke> probably not easily
21:07:06 <ztirf_> @pl \x -> amap (/s) x where s = sum x
21:07:06 <lambdabot> (line 1, column 27):
21:07:06 <lambdabot> unexpected "="
21:07:06 <lambdabot> expecting variable, "(", operator or end of input
21:07:28 <ztirf_> @pl \x -> let s = sum x in amap (/s) x
21:07:28 <lambdabot> ap (flip (amap . flip (/))) sum
21:07:36 <pumpkin> mauke: isn't there a CPP option to ghc that'll ask it to run the preprocessor over the code?
21:07:57 <mauke> yeah, but aren't foreign imports basically string literals?
21:08:12 <pumpkin> oh :/
21:08:52 <mmorrow> kiris: i have, but i'm glad you reminded me because they'd actually had slipped my mind ..
21:09:18 <ddarius> intoverflow: I suspect you could build the things you need for -way- cheaper than you could buy them, though it would take learning a good bit and some finesse.
21:09:52 <mmorrow> kiris: heh, totally. parsing parser representations with parsers (once bootstrapped) produced by parsing parser representation with parsers ...
21:13:32 <kiris> ;-]
21:14:47 <Gracenotes> @instances Comonad
21:14:47 <lambdabot> Couldn't find class `Comonad'. Try @instances-importing
21:16:15 <kiris> mmorrow: got a really neat, nice-looking example of formlets: http://chrisdone.com/code/haskell/formlet-example/Pay.hs.html
21:16:25 <kiris> mmorrow: have you been using them for your web dev work yet? :P
21:18:31 <ddarius> @hoogle Comonad
21:18:32 <lambdabot> No results found
21:19:33 <chessguy> @pl \(x,y) -> x < y
21:19:33 <lambdabot> uncurry (<)
21:22:01 <ozy`> @pl \x y z -> let [x', y', z'] = map ((/ 2.0) . (+ 1.0)) [x, y, z] in f x' y' z'
21:22:01 <lambdabot> (line 1, column 15):
21:22:02 <lambdabot> unexpected "["
21:22:02 <lambdabot> expecting "()", natural, identifier or "in"
21:22:13 <ozy`> bah
21:22:21 <mauke> no pattern matching
21:22:28 <cjs> pumpkin: Thanks for the TH hint. It's easier to use than I thought.
21:22:40 <cjs> Well, so far, anyway. I've yet to try a profiling build.....
21:22:42 <ozy`> mauke: (,) doesn't count?
21:22:57 <mauke> (a,b) is special cased
21:23:02 <ozy`> fine, fine
21:23:04 <mauke> even (a,b,c) will not work
21:23:07 <ozy`> ah
21:24:41 <ozy`> @pl \x y z -> let x' = (x + 1.0) / 2.0; y' = (y + 1.0) / 2.0); z' = (z + 1.0) / 2.0 in f x' y' z'
21:24:41 <lambdabot> (line 1, column 57):
21:24:41 <lambdabot> unexpected ")"
21:24:41 <lambdabot> expecting ";" or "in"
21:24:54 <ozy`> @pl \x y z -> let x' = (x + 1.0) / 2.0; y' = (y + 1.0) / 2.0; z' = (z + 1.0) / 2.0 in f x' y' z'
21:24:55 <lambdabot> flip flip ((/ 2 . 0) . (1 . 0 +)) . ((.) .) . (. ((/ 2 . 0) . (1 . 0 +))) . f . fix . const . (/ 2 . 0) . (1 . 0 +)
21:25:02 <ozy`> D:
21:25:11 <Fractalizator> @pl \x y z -> x + y + z
21:25:12 <lambdabot> ((+) .) . (+)
21:25:20 <chessguy> @type foldr
21:25:21 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
21:25:25 <ddarius> @pl 2.0
21:25:25 <lambdabot> 2 . 0
21:25:28 <ddarius> That's great.
21:25:45 <ozy`> > 1       .        0
21:25:46 <lambdabot>       Overlapping instances for Show (a -> c)
21:25:46 <lambdabot>        arising from a use of `s...
21:25:54 <dolio> @pl flip (+)
21:25:54 <lambdabot> (+)
21:25:55 <ozy`> > 1       .        0 ::Double
21:25:56 <lambdabot>   Couldn't match expected type `Double'
21:26:33 <Fractalizator> @pl \x y -> 10  x - 7  y
21:26:34 <lambdabot> (. 7) . (-) . 10
21:26:59 <ozy`> @pl \x y z -> let x' = (x + 1) / 2; y' = (y + 1) / 2; z' = (z + 1) / 2 in f x' y' z'
21:27:00 <lambdabot> flip flip ((/ 2) . (1 +)) . ((.) .) . (. ((/ 2) . (1 +))) . f . fix . const . (/ 2) . (1 +)
21:27:03 <Fractalizator> @pl \x y -> (10  x) - (7  y)
21:27:03 <lambdabot> (. 7) . (-) . 10
21:27:24 <ddarius> :t \x y -> 10x-7y
21:27:25 <lambdabot> forall t a t1. (Num a, Num (t1 -> a), Num (t -> a)) => t -> t1 -> a
21:28:07 <pumpkin> I can't believe I'm manually being the c preprocessor
21:28:12 <ozy`> > (\x y -> (10 x) - (7 y)) 13 23
21:28:13 <lambdabot>       No instance for (Num (t -> a))
21:28:13 <lambdabot>        arising from the literal `10' at ...
21:28:23 <pumpkin> ozy`: * ?
21:28:26 <chessguy> @pl \s -> f g 0 . m' (s' s)
21:28:26 <lambdabot> (f g 0 .) . m' . s'
21:29:13 <chessguy> @unpl (f .) . g
21:29:14 <lambdabot> (\ d i -> f (g d i))
21:30:38 <chessguy> @pl v x = x >= 0 && x <= 3
21:30:39 <lambdabot> v = liftM2 (&&) (>= 0) (<= 3)
21:31:12 <ozy`> :t liftM2
21:31:13 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
21:31:41 <pumpkin> > liftM2 (&&) f g
21:31:42 <lambdabot>       No instance for (Show (m Bool))
21:31:42 <lambdabot>        arising from a use of `show' at ...
21:32:07 <chessguy> > liftM2 (&&) f g :: Maybe Bool
21:32:08 <lambdabot>       No instance for (SimpleReflect.FromExpr (Maybe Bool))
21:32:08 <lambdabot>        arising fr...
21:32:10 <mauke> :t inRange
21:32:11 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
21:32:45 <pumpkin> where does cabal put its docs?
21:33:04 <chessguy> you mean haddock?
21:33:09 <pumpkin> yeah, sorry
21:33:22 <pumpkin> I can't find any haddock docs for any of my packages
21:34:27 <blackh1> pumpkin: Well, cabal puts them in ~/.cabal/share/doc/<module>/html/ if you did --enable-documentation when you installed the module
21:34:57 <blackh1> s/module/package/g :)
21:35:54 <pumpkin> haddock seems to barf on -- ^ RHS input arguments
21:36:00 <chessguy> pumpkin:  http://www.haskell.org/haddock/doc/html/invoking.html
21:36:16 <chessguy> (look under the -o option)
21:36:34 <pumpkin> I think the haddock comments in this package are just messed up
21:36:40 <pumpkin> and that's why the one on hackage doesn't have haddock either
21:37:24 <pumpkin> ahh, there we go
21:38:04 * chessguy seems to be in a cycle of "fix error message", "fix infinite loop problem", "repeat"
21:39:35 <ozy`> where might I find sources for the definition of the Monad ((->) r) instance?
21:40:00 <pumpkin> Control.Monad.Instances I think
21:40:33 <ddarius> @src (->) return
21:40:33 <lambdabot> return = const
21:40:37 <ddarius> @src (->) (>>=)
21:40:38 <lambdabot> f >>= k = \ r -> k (f r) r
21:41:36 <chessguy> @pl \r -> k (f r) r
21:41:36 <lambdabot> k =<< f
21:41:41 <chessguy> heh
21:42:01 <ozy`> that works
21:44:06 <cjs> Wow. My trading simulator just took over my entire machine and ate up all my CPU.
21:44:31 <chessguy> sell! sell! sell!
21:45:33 <pumpkin> cjs: I love it when that happens
21:46:35 <cjs> I had to kill my X server to recover.
21:46:39 <pumpkin> I actually got the MATLAB package working after so much struggling!
21:46:47 <intoverflow> pumpkin: congrats
21:46:53 * cjs shoots off fireworks.
21:47:26 <pumpkin> thanks :) it was almost as bad as adapting an old academic project (eww academic code) to a newer version of TAO after undocumented API changes...
21:47:44 <pumpkin> other people's code is always the worse
21:47:46 <pumpkin> *worst
21:48:18 <chessguy> where clauses are scoped to the individual branch of the function, right?
21:49:01 <ibid> depends on how you define "branch"
21:49:09 <chessguy> e.g., foo [] = bar; foo _ = []; where bar = blah
21:49:19 <chessguy> assuming the semi-colons are newlines
21:49:23 <chessguy> this won't work, right?
21:49:31 <ibid> no, it won't
21:49:43 <chessguy> bah
21:50:07 <ddarius> clauses is the term by the way
21:50:17 <chessguy> ah, thanks
21:50:29 <chessguy> i didn't think branches was right, but couldn't come up with the right one
21:50:56 <ibid> the reason is that any variables you bind in the patterns are visible in the where
21:51:28 <ibid> but if you have several guarded clauses that share the pattern matches, they also share the where
21:52:06 <chessguy> oh?
21:52:07 <ibid> (which is why i asked about what you meant by "branch")
21:52:41 <pumpkin> any way I can stop ghci from giving me full names in :t ? y :: matlab-0.1:Foreign.Matlab.Internal.MAnyArray
21:53:01 <ibid> foo x | x >= 0 = ... blah ... | x < 0 = ... blah ... where blah = ...
21:53:16 <ztirf_> is there an instance declaration for Data.Array.Unboxed somewhere or do I have to write it myself?
21:53:52 <dmwit> pumpkin, Maybe if you :m + that module.
21:54:12 <dmwit> ztirf_, instance of what?
21:54:14 <chessguy> ibid:  so this is a valid rewrite to make sure that newClauses only gets fired once? http://hpaste.org/14077#a1
21:54:24 <pumpkin> dmwit: doesn't give me the option to, maybe becausee it's Internal?
21:54:30 <ztirf_> dmwit: err, Foldable and Functor
21:54:51 <ztirf_> so fmap foldl etc
21:54:58 <dmwit> No, Functor is not possible.
21:55:26 <dmwit> However, it should have a suitably class-restricted fmap-alike in the module.
21:55:31 <dmwit> If it doesn't, I'll be very surprised.
21:56:06 <ztirf_> dmwit: yes it does, amap - ahhhh because f . g would be boxed by definition?
21:56:42 <dmwit> ztirf_, Because you would have to guarantee that the first argument to fmap gives an unboxed type as its result, which doesn't fit into the type fmap actually has in the Functor class.
21:56:45 <ibid> chessguy: haskell's semantics does not guarantee laziness, only nonstrictness, which is why you can't *guarantee* it. but that does look like it ought to work in the typical implementation
21:56:50 <dmwit> :t fmap -- not restrictive enough
21:56:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:57:28 <ztirf_> I see
21:57:38 <dmwit> ztirf_: There is a Functor instance for Data.Array if that helps.
21:57:57 <dmwit> ?src Foldable
21:57:57 <lambdabot> Source not found.
21:58:02 <dmwit> , src 'Foldable
21:58:06 <lunabot>  luna: Not in scope: data constructor `Foldable'
21:58:15 <dmwit> oy
21:58:26 <ztirf_> it's not crucial, but it would have been nice - I wanted to write a generic version of normalize
21:58:26 <dmwit> Anyway, it's probably not an instance of Foldable for the same silly reason.
21:59:12 <ztirf_> oh well
21:59:41 <ztirf_> I'll just write an "anormalize" instead that takes arrays or something
22:00:26 <chessguy> ibid:  cool, that's good enough for me. i'm mainly after readability in this pass anyway, not performance
22:02:32 <chessguy> @pl \k s -> l $ c . t . t' (f s) $ k
22:02:33 <lambdabot> (l .) . flip (((c . t) .) . t' . f)
22:02:45 <pumpkin> oh my
22:02:52 <ztirf_> @src foldl1'
22:02:52 <lambdabot> Source not found. You type like i drive.
22:03:12 <pumpkin> chessguy: if that's your readability, I'd hate to see your unreadable code :P
22:03:16 <chessguy> @pl \s k -> l $ c . t . t' (f s) $ k
22:03:16 <lambdabot> ((l . c . t) .) . t' . f
22:03:26 <chessguy> pumpkin:  :P
22:03:50 * chessguy copies and pastes directly from @pl as much as possible
22:04:19 <ztirf_> and they say perl is unreadable...
22:04:23 <ddarius> Even the original code was icky.  In the latter case the @pl is an improvement.
22:04:40 <ddarius> ztirf_: We can out golf perl, I'm sure we can out obfuscate them.
22:04:42 <mauke> ztirf_: http://mauke.ath.cx/stuff/haskell/hax.pl -- have both!
22:04:59 <chessguy> ddarius:  you don't like "resolution kb s = loop $ cnfElements . toSentence . tell (Not s) $ kb"
22:05:01 <chessguy> ?
22:05:32 <ztirf_> mauke: haha!
22:05:53 <ztirf_> now you just need to make it compile in bash too
22:05:58 <ztirf_> and C for good measure
22:06:02 <mauke> ztirf_: btdt
22:06:11 <mauke> ztirf_: http://mauke.ath.cx/stuff/poly.poly
22:06:19 <mauke> be careful what you wish for
22:06:37 <chessguy> hahaha
22:06:45 <ztirf_> oh my god did you really write that
22:06:49 <chessguy> mauke++
22:06:53 <mauke> this is also currently on reddit
22:06:59 <mauke> ztirf_: yes
22:07:00 <chessguy> freaking. awesome.
22:07:06 <pumpkin> mauke: what is it
22:07:07 <ztirf_> jesus there's even brainfuck
22:07:12 <pumpkin> oh, lol
22:07:37 <chessguy> looks like it's a valid program in at least 8 languages?
22:07:50 <mauke> more like 12 or 13, depending on how you count
22:07:57 <ddarius> That's pretty fucking great.
22:08:00 <pumpkin> impressive :)
22:08:20 <elly> which languages does it work in?
22:08:20 <elly> heh
22:08:28 <chessguy> mm, more like 15
22:08:41 <mauke> 3 shells, ruby, perl, tcl, make, c, c++, haskell, brainfuck, python, "html", perl6, whitespace
22:08:43 <chessguy> good golly miss molly
22:08:54 <cjs> So why do we use *_p.a for profiling libraries, but *.p_hi for profiling interface files?
22:09:07 * pumpkin claps
22:09:29 <chessguy> that is....impressive
22:09:35 <chessguy> sick, but impressive
22:09:39 <conal> amazing
22:09:41 <ztirf_> I'm in awe
22:09:58 <chessguy> ddarius:  i do wish you wouldn't use such words. let's keep the channel clean, eh?
22:10:07 <pumpkin> lol
22:10:15 <pumpkin> I was swearing quite a bit earlier
22:10:18 <chessguy> just no need for it
22:10:37 <conal> hey, if perl is okay, then "fucking" is.
22:10:47 <chessguy> it usually is pretty clean. it'd be nice to keep it that way
22:11:09 <cjs> Man, that's sick.
22:11:30 <ztirf_> @src foldl'
22:11:30 <lambdabot> foldl' f a []     = a
22:11:30 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
22:11:34 <cjs> But I think we already won over perl. Two years ago we were using perl to build GHC; now people are using GHC to build perl.
22:11:48 <pumpkin> I don't believe in cleanliness of language, but I try to keep swearwords out of mine for people who do :P
22:12:00 <ddarius> chessguy: And I rarely curse, but I have no compunction about it and am not going to start now
22:12:14 <chessguy> pumpkin: thanks. at least someone has manners
22:13:17 <pumpkin> mauke: how long did that take you?
22:13:43 <mauke> pumpkin: I don't know; it sort of grew over several months (years?)
22:15:48 <chessguy> hmm. i know there has been some discussion around here of an early-terminating fold (that is, one that could terminate even on an empty list, based on a condition). anybody know of a successful implementation?
22:16:10 <ddarius> You can just use foldM with an error monad.
22:16:42 <chessguy> mmm, i'm not terminating on an error condition
22:17:01 <ddarius> It doesn't have to be an error just because you are using an error monad.
22:17:21 <chessguy> i suppose
22:17:36 <pumpkin> chessguy: what are you making?
22:17:40 <ddarius> I hear in O'Caml they use exceptions for control flow quite often.
22:17:47 <chessguy> pumpkin:  still working on my inference engine
22:17:51 <pumpkin> ah yeah :)
22:18:31 <ztirf_> haha I just found one written in COBOL, Pascal, Fortran, C, Postscript, sh, and 8086 asm
22:19:04 <chessguy> the idea is, it takes some clauses, tries to figure out if there are any new ones. if any of the new ones are a contradiction, then it returns true. otherwise, it adds the new ones to the ones it started with, and starts over again
22:19:19 <ztirf_> http://www.nyx.net/~gthompso/poly/polyglot.txt
22:19:59 <chessguy> i guess it's probably ok as it is (http://hpaste.org/14077#a1)
22:20:17 <chessguy> it does appear to be some kind of fold though
22:22:04 <chessguy> i actually think it's pretty readable as is, which i'm pretty proud of
22:23:55 <chessguy> maybe more readable than the pseudocode i started with
22:25:32 <ztirf_> @src sum
22:25:32 <lambdabot> sum = foldl (+) 0
22:27:56 <chessguy> > [1,2,3] \\ [2,2,2]
22:27:57 <lambdabot>   [1,3]
22:28:38 <chessguy> > [2,2,2] \\ [1,2,3]
22:28:40 <lambdabot>   [2,2]
22:28:52 <pumpkin> I think it treats the list like a mutiset
22:30:26 <chessguy> @pl i x = a (`e` x)
22:30:26 <lambdabot> i = a . flip e
22:30:53 <pumpkin> you didn't need that one!
22:31:07 <pumpkin> that's @pl-able in your head!
22:31:10 <chessguy> :)
22:31:12 <chessguy> i'm lazy!
22:31:22 <ddarius> pumpkin: It assumes they are already nubbed.  I'm not sure if it all works out so that they behave like multiset operations, but maybe.
22:31:57 <chessguy> heh. i had that whole complicated algorithm, and it turns out my isSubset implementation was broken :)
22:34:40 <chessguy> oh, well, i'm glad, because it made me make the complicated part more readable
22:36:48 <chessguy> ugh, more infinite loops :(
22:40:05 <chessguy> hmm, how is it that i make quickcheck show me its test cases?
22:43:46 <chessguy> @hoogle verboseCheck
22:43:47 <lambdabot> No results found
23:02:17 <pumpkin>       Expected type: [(String, MXArray a)]
23:02:17 <pumpkin>       Inferred type: [(String, IO MAnyArray)]
23:02:31 <pumpkin> can anyone think of an easy way to pull that out inside a do block?
23:02:43 <pumpkin> MAnyArray is an MXArray
23:02:43 <int80_h> how do I use lambdbot to send a message to someone?
23:02:54 <pumpkin> int80_h: you can only do that if you're an admin
23:02:58 <pumpkin> @msg in that case
23:02:58 <lambdabot> Not enough privileges
23:03:04 <int80_h> damn
23:03:23 <int80_h> @seen int-e
23:03:23 <lambdabot> I saw int-e leaving #ghc, #haskell-overflow and #haskell 7h 38m 29s ago, and .
23:03:38 <int80_h> oh well, I'll thank him later.
23:03:57 <pumpkin> oh, you mean @tell
23:04:01 <pumpkin> sorry :)
23:04:06 <pumpkin> just @tell nick something
23:04:10 <int80_h> cool
23:04:29 <pumpkin> :t mapM
23:04:30 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
23:04:43 <int80_h> @tell int-e thanks for the help with the graham scan algorithm. I had to leave in a hurry earlier. Catch you later.
23:04:43 <lambdabot> Consider it noted.
23:05:14 <int80_h> @seen dons
23:05:14 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 3h 38m 25s ago.
23:05:59 <int80_h> @tell dons as an author of RWH, did you intend for exercises (at least in the begining) to be done only with parts of the language that have been introduced?
23:05:59 <lambdabot> Consider it noted.
23:06:38 <int80_h> int-e and I had a disagreement about the intent of the authors of RWH
23:06:48 <pumpkin> :o
23:06:57 <pumpkin> never disagree with int-e!
23:07:03 <pumpkin> 'tis dangerous
23:07:15 <int80_h> I say they intended for us to only use parts of the language introduced prior to exercises. int-e disagrees.
23:07:21 <int80_h> bah
23:07:28 <pumpkin> you have a rather large common prefix
23:07:40 <int80_h> heh
23:07:53 <int80_h> well I know what my name means. not sure about his
23:12:03 <pumpkin> bah, this should be simple but I'm not getting it
23:18:28 <ryant5000> i'm trying to learn some pieces of topology
23:18:39 <ryant5000> specifically, i was just looking at metric spaces
23:18:43 <ryant5000> i.e.: spaces with "distance"
23:18:49 <ryant5000> is there an equivalent for spaces with "direction"?
23:20:00 <ryant5000> vector spaces have direction, but they also have other stuff (i think)
23:20:18 <ryant5000> i'm looking for a kind of space that has direction and nothing else, if possible
23:20:26 <pumpkin> well, what are the prerequisites for direction?
23:20:29 <ryant5000> i'm not sure
23:20:50 <ryant5000> i was hoping the answer to these questions would help me figure that out :P
23:21:08 <pumpkin> seems like you'd need the idea of "difference", which would imply additive inverse and addition, or scalar multiplication and addition
23:21:09 <ryant5000> it seems plausible to me that direction depends on distance
23:21:13 <pumpkin> which is all a vector space really gets you
23:21:27 <pumpkin> "all"
23:21:27 <ryant5000> hm
23:21:52 <mmorrow> lunabot got a faster machine
23:21:53 <ryant5000> yeah i suppose i can't really think of a definition of direction that doesn't somehow imply dimensionality
23:21:58 <pumpkin> any easy way to go from (1, [1,2,3]) to [(1,1),(1,2),(1,3)] ?
23:22:17 <dolio> @type uncurry (map . const)
23:22:18 <pumpkin> mmorrow: nice, what's it on now?
23:22:19 <lambdabot> forall a a1. (a1, [a]) -> [a1]
23:22:25 <dolio> @type uncurry (map . (,))
23:22:26 <lambdabot> forall a a1. (a1, [a]) -> [(a1, a)]
23:22:32 <pumpkin> ah :) thanks
23:22:35 <mmorrow> pumpkin: same hosting co, better package
23:22:40 <mmorrow> , src ''Exp
23:22:42 <pumpkin> ah
23:22:43 <lunabot>  data Exp = VarE Name
23:22:43 <lunabot>           | ConE Name
23:22:43 <lunabot>           | LitE Lit
23:23:02 <mmorrow> , maxBound :: Int
23:23:03 <lunabot>  2147483647
23:23:11 <pumpkin> how about [(String, IO X)] to IO [(String, X)]? :P
23:24:04 <pumpkin> mmorrow: still 32 bit?
23:24:13 <mmorrow> yeah, unfortunately
23:24:28 <ryant5000> pumpkin: i'm reading about matroids now; they might be relevant
23:24:38 <ryant5000> (they were listed under generalizations on the wikipedia page for vector space)
23:24:44 <dolio> @type let strength (a,f) = fmap ((,) a) f in mapM strength
23:24:45 <lambdabot> forall t (f :: * -> *) a. (Monad f, Functor f) => [(t, f a)] -> f [(t, a)]
23:25:10 <mmorrow> , [$ty| strength |]
23:25:12 <lunabot>  forall a b c . Functor b => c -> (b a) -> b ((c, a))
23:25:13 <pumpkin> dolio: great... what's the naming?
23:25:24 <mmorrow> , src 'strength
23:25:27 <lunabot>  strength :: forall f a b . Functor f => a -> (f b) -> f ((a, b))
23:25:32 <mmorrow> err
23:25:37 <mmorrow> , 'strength
23:25:38 <lunabot>  Control.Functor.Strong.strength
23:25:43 <pumpkin> :o
23:25:51 <pumpkin> @hoogle strength
23:25:52 <lambdabot> No results found
23:25:53 <mmorrow> , ''Strong
23:25:54 <lunabot>  luna: Not in scope: type constructor or class `Strong'
23:25:55 <dolio> Where's that from? category-extras?
23:25:59 <mmorrow> yeah
23:26:01 <pumpkin> ah
23:26:13 <mmorrow> do you know any names in that module?
23:26:19 <mmorrow> , ''Strength
23:26:19 <lunabot>  luna: Not in scope: type constructor or class `Strength'
23:26:35 <mmorrow> need :browse
23:26:37 <dolio> It might be just functions. All Haskell functors are strong.
23:26:43 <mmorrow> ah, cool
23:27:10 <mmorrow> now that lunabot crushes, i can't think of any expressions to run that got killed before ..
23:27:29 <mmorrow> that always happens with this sort of thing
23:27:38 <dolio> Yeah, only has strength and costrength.
23:27:49 <mmorrow> , [$ty| costrength |]
23:27:51 <lunabot>  forall a b c . Traversable c => (c (Either b a)) -> Either b (c a)
23:28:11 <mmorrow> @instances Traversable
23:28:12 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
23:28:23 <mmorrow> @instances-importing Traversable
23:28:24 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
23:29:01 <pumpkin> I find myself using =<< more than >>=
23:29:04 <pumpkin> is that normal?
23:29:21 <dolio> Depending on what you're doing, yes.
23:29:35 <pumpkin> it just feels like a more natural direction to do things
23:29:36 <dolio> =<< works well with <- in do notation, and with function composition.
23:29:40 <pumpkin> yeah
23:29:49 <pumpkin> function composition is where I typically use it
23:30:12 <dolio> >>= is more natural for desugaring do notation. That may be about it.
23:30:52 <dolio> Unless you're a concatenative language fan, and want stuff to be left-to-right.
23:30:59 <dolio> And use >>> for composition and such.
23:33:05 <Workybob> pumpkin: I find =<< a *much* nicer operation
23:33:13 <Workybob> it's type is lovely compared to >>=
23:33:24 <pumpkin> yeah :)
23:34:36 <Workybob> at some point I think I need to see if I can cook up a better alternative to do notation
23:34:44 <mmorrow> , [$ty| (fmap . fmap) (\n -> if n < 2 then Left n else Right n) . concat . unfoldForestM_BF (\n -> return $ if n < 4 then (n+1,replicate n (n+1)) else (n+1,[])) $ [0,1] |]
23:34:47 <Workybob> tentatively called the "be" notation instead
23:34:47 <lunabot>  [] (Tree (Either Int Int))
23:34:59 <mmorrow> , [$ty| fmap costrength . (fmap . fmap) (\n -> if n < 2 then Left n else Right n) . concat . unfoldForestM_BF (\n -> return $ if n < 4 then (n+1,replicate n (n+1)) else (n+1,[])) $ [0,1] |]
23:35:02 <lunabot>  [] (Either Int (Tree Int))
23:35:11 <mmorrow> that'll be handy
23:35:35 <pumpkin> how can I add a library search path to ghc for compilation?
23:35:51 <mmorrow> -L../asd/f
23:35:54 <pumpkin> aha
23:35:55 <pumpkin> thanks :)
23:37:02 <mmorrow> unfoldForestM_BF is great for generating Forests (especially to get something notrivial to use for an example/testing)
23:37:25 <mmorrow> , concat . unfoldForestM_BF (\n -> return $ if n < 4 then (n+1,replicate n (n+1)) else (n+1,[])) $ [0,1]
23:37:26 <lunabot>  [Node {rootLabel = 1, subForest = []},Node {rootLabel = 2, subForest = [N...
23:38:03 <mmorrow> (i always just use the list monad, and concat afterwrds, but you could use e.g. IO)
23:44:52 <int80_h> anyone up to helping me with my graham scan algorithm exercise from RWH?
23:45:59 <int80_h> I'm up to the part where I have to sort the points by the cotangent made with point P and the x-axis
23:46:07 <int80_h> my function sorts, but incorrectly
23:46:31 <pumpkin> fix the sort function!
23:46:39 <mmorrow> so are you computing the angle wrong, or is it the sort?
23:46:39 <int80_h> the spec requires I use previous code written for other exercises
23:46:48 <int80_h> pumpkin: that's what I need help on
23:47:05 <int80_h> I'm computing the cotangent correctly, but I do the wrong thing
23:47:11 <int80_h> for the sort
23:47:17 <int80_h> I'll post the code
23:47:49 <int80_h> I'm limited to using theparts of the language introduced up to the point of chapter 3 of RWH, by the way.
23:48:04 <int80_h> so I can't use sortBy, or other things that would make this trivial.
23:48:08 <int80_h> posting...
23:48:37 <luqui> hmm, such limitations don't seem very "real world" :-)
23:49:15 <ryant5000> why not just recreate all those handy library functions?
23:49:22 <ryant5000> prefixed with "my" or some such
23:49:26 <pumpkin> or make less efficient ones!
23:49:28 <ryant5000> yeah!
23:49:30 <pumpkin> @src sort
23:49:30 <lambdabot> sort = sortBy compare
23:49:32 <pumpkin> @src sortBy
23:49:33 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
23:49:37 <pumpkin> ^^
23:50:47 <int80_h> http://hpaste.org/14079
23:51:16 <int80_h> luqui: begining exercises often have an artifical flavor to them.
23:51:31 <int80_h> I'd say things get better from chapter 4 on
23:52:26 <int80_h> fold hasn't been introduced yet. I believe the authors had a solution in mind with what's been introduced
23:52:57 <int80_h> mmy insert is screwy somehow, but it can be fixed.
23:53:57 <int80_h> int-e says my pivot point changes
23:54:15 <int80_h> and that's what is screwing up my insert
23:55:38 <int80_h> I was guessing that the pivot point doesn't change, because a new scope is created when the recursive call happens
23:55:47 <int80_h> does that even make sense?
