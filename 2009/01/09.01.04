00:00:47 <int80_h> oh man
00:03:21 <dmwit> You called?
00:03:33 <lucca> GLUT is nearly useless for anything other than a brief test of an idea
00:03:58 <mm_freak> lucca: yeah, indeed, but all GL libraries use it, for whatever reason
00:04:06 <mm_freak> even reactive-fieldtrip
00:04:40 <lucca> GLU is not GLUT
00:04:51 <lucca> GLU is the GL utility lib
00:05:10 <lucca> calculates mipmaps and nurbs stuff, other goodies
00:05:24 <mm_freak> i know, it uses GLUT
00:05:32 <lucca> Hm, disappointing.
00:06:11 <mm_freak> yeah, it should leave initialization abstract
00:06:26 <lucca> I haven't been able to get any of the GL stuff to work in haskell yet, mostly because there are so many other entertaining distractions
00:07:13 <mm_freak> i've got most of them to work, including frag
00:07:34 <mm_freak> and i've written a few tests myself using SDL and OpenGL
00:07:34 <eyeris> In emacs, how do you cancel the mini-buffer cmd?
00:07:43 <mm_freak> eyeris: C-g
00:07:47 <eyeris> (totally new to emacs, trying to use the haskell mode, sorry for OT)
00:07:49 <eyeris> thanks
00:08:15 <moxiee> eyeris: me too! :)
00:09:13 <mm_freak> i think, #haskell is a very tolerating channel, we often talk about other languages or operating systems, etc.
00:09:24 <mm_freak> i think, the emacs operating system is worth mentioning, too
00:10:17 <quylui> i just figured out emacs can also handle irc
00:10:27 <quylui> which i knew of course, but just didn't consciously think about
00:11:07 <quylui> it's only a matter of time before emacs becomes sentient
00:11:36 <eyeris> Is there an alternative for M-TAB completion? GNOME bings M-TAB to switch-windows
00:12:40 <mmorrow> after haskell (well, ghci), i can barely bear to write C anymore because i don't have an interpreter going as i'm coding.
00:12:42 <eyeris> M-/ looks like it works
00:13:38 <mmorrow> hmm, actually didn't someone write a c interpreter somehow...
00:13:41 * mmorrow googles
00:13:57 <geezusfreeek> aw, the SDL bindings don't have a binding to SDL_PeepEvents :(
00:14:11 <Adamant> mmorrow: it's been done
00:14:17 <Adamant> both open source and commercial
00:14:52 <jonaskoelker> is there a Bool-typed expression that evaluates to True iff a value matches a pattern, that's shorter than "case expr of {pattern -> True; _ -> False}"?
00:14:54 <int80_h> I swear, if this code breaks on me again I'll cry.
00:15:21 <jonaskoelker> (... and where do I RTFM to find the answer myself?)
00:15:57 <lucca> mm_freak: cool.  frag just segfaults here (osx, intel, 6.10)
00:16:19 <geezusfreeek> yeah, frag segfaults on my mac as well
00:16:36 <pumpkin> jonaskoelker: doubt it, as you can't "pass" patterns around
00:16:39 <geezusfreeek> jonaskoelker, as far as i know that is the only way
00:16:41 <mm_freak> geezusfreeek: do you really need PeepEvents?  you've got PollEvent
00:17:29 <int80_h> Would haskell make a good match for the OS toolkit?
00:17:31 <mm_freak> on mac, haskell seems to be infant yet
00:17:39 <int80_h> like replacing the C bits little by little with haskell?
00:17:54 <int80_h> until you have a haskell OS?
00:18:03 <mm_freak> int80_h: there is already an experimental haskell OS
00:18:09 <mm_freak> called 'house'
00:18:13 <ddarius> There's at least two
00:18:18 <int80_h> oooh nice
00:18:18 <mmorrow> Adamant: i remember seeing one that looked nonsucky, maybe two-three months ago. someone in here linked to it actually. any idea?
00:18:34 <int80_h> then it would be workable, for exercise purposes
00:18:42 <geezusfreeek> mm_freak, i'm playing with left fold enumerators and peepevents would be the most natural fit for doing it with sdl
00:18:57 <ddarius> geezusfreeek: So add a binding and submit a patch
00:19:02 <ddarius> Should be pretty straightforward.
00:19:04 <geezusfreeek> ddarius, yeah i plan to
00:19:16 <geezusfreeek> not tonight though. i must go to bed
00:19:21 <int80_h> bed shmed
00:19:22 <Adamant> mmorrow: rantmeister Marcus Ranum talks about a old commercial one
00:19:54 <int80_h> I know, I came to my room intending to go to bed. Then I thought "I think I'll fix up some code" That was an hour ago.
00:20:03 <geezusfreeek> happens to me all the time
00:20:10 <geezusfreeek> hence me being up at 2:30am
00:20:17 <geezusfreeek> time to try this bed thing again though
00:20:42 <mmorrow> int80_h: you can download a house bootable floppy image and run it in qemu
00:20:52 <mm_freak> geezusfreeek: i understand…  until then, you could emulate it using PollEvent and PushEvent
00:21:06 <mmorrow> Adamant: the one i'm thinking of is new and free and looked cool
00:21:15 <geezusfreeek> mm_freak, yeah it's not a big deal. not like i expect thousands of events per second or anything
00:21:22 <mmorrow> i think maybe dons linked to it in here now that i think about it
00:21:29 <geezusfreeek> but as i said i will probably just submit a patch
00:21:32 <mmorrow> grrrr, can't find it on google
00:21:41 <Adamant> mmorrow: sorry man, no idea
00:21:45 <mm_freak> yeah, makes more sense =)
00:21:54 <mmorrow> Adamant: thx for thinking :)
00:22:21 <mm_freak> i'd like to see the SDL binding support access to the video memory as SDL does
00:24:22 <int80_h> mmorrow: that sounds intriguing. They fit it on a floppy.
00:25:13 <mm_freak> a compiled haskell program under linux would already fill up half of a floppy disk =)
00:25:16 <int80_h> bollocks
00:25:16 <mmorrow> int80_h: i'm not sure if it actually fits on a real floppy or not
00:25:31 <mmorrow> http://web.cecs.pdx.edu/~kennyg/house/
00:26:58 <mmorrow> heh, this cmd will grab it and have it booting within 10 seconds:
00:27:00 <mmorrow> wget http://web.cecs.pdx.edu/~kennyg/house/House.flp && qemu -fda House.flp -boot a
00:28:46 <mmorrow> mm_freak, int80_h: house uses a ghc rts that's been modified to run on bare hardware apparently
00:30:14 <mm_freak> i just wanted to install qemu, but it doesn't compile with GCC 4
00:32:11 --- mode: ChanServ set +o mauke
00:32:11 --- mode: mauke set +v lambdabot
00:32:17 <mauke> crap
00:32:26 <mauke> well, it was almost successful :-)
00:36:33 <pumpkin> omg +v in #haskell
00:36:34 * pumpkin faints
00:38:35 --- mode: mauke set -o mauke
00:40:16 <mm_freak> i'm installing an ancient PC emulator now:  bochs
00:40:17 <ikegami__> > :m + Text.Regex.Posix
00:40:18 <lambdabot>   <no location info>: parse error on input `:'
00:40:34 <mm_freak> i wonder if house works with it =)
00:40:51 <ikegami__> > "foobar" =~ "(oo|ar)" :: [String]
00:40:52 <lambdabot>   ["oo","ar"]
00:41:01 <ikegami__> @version
00:41:01 <lambdabot> lambdabot 4.2.2
00:41:02 <lambdabot> darcs get http://code.haskell.org/lambdabot
00:41:31 <jonaskoelker> in .ghci I have ":module +Data.Ratio +Data.List +Control.Monad".  When I run ghci, I get "syntax:  :module [+/-] [*]M1 ... [*]Mn".  What gives?
00:41:44 <jonaskoelker> bah, nvm, I can't read
00:41:50 <mm_freak> jonaskoelker: use import
00:42:39 <jonaskoelker> mm_freak: is there any difference between the two?
00:43:00 <dmwit> Yes, import won't work. =)
00:43:10 <ikegami__> thanks forks and lambdabot, see you
00:43:13 <dmwit> Just give only the first + sign.
00:43:32 <mauke> jonaskoelker: :module [+/-] [*]M1 ... [*]Mn does not match ":module +Data.Ratio +Data.List +Control.Monad"
00:43:50 <mmorrow> awesome: http://www.haskell.org/pipermail/haskell-cafe/2003-May/004343.html
00:43:51 <jonaskoelker> I got that now :)  ^^^ <jonaskoelker> bah, nvm, I can't read
00:43:51 <mm_freak> dmwit: it works for me
00:43:57 <dmwit> Okay!  Never mind, then.
00:44:02 <jonaskoelker> and for me :)
00:44:58 <int80_h> Lemmih: hi :)
00:45:43 <blackh1> Lemmih: Hi there. I'm Stephen Blackheath, by the way.
00:46:00 <Lemmih> int80_h: Hiya. Haven't gotten around to make your account yet.
00:46:00 <lambdabot> Lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
00:46:36 <Lemmih> blackh1: Hey. Good to know. I'm Lemmih. (:
00:46:37 <int80_h> Lemmih: no worries. I wanted to make sure I sent you the file you asked for.
00:46:58 <blackh1> Lemmih: I sent you an email recently about Berkeley DB bindings. That's who Stephen Blackheath is.
00:48:29 <Lemmih> blackh1: Right. Good luck with that binding. It certainly is a bit silly to have three separate ones.
00:49:04 <blackh1> Lemmih: Thanks kindly. I'm working on it right now!
00:50:29 --- mode: ChanServ set +o mauke
00:50:29 --- mode: mauke set -v lambdabot
00:50:54 <mauke> success. transparent auto-opping has been achieved.
00:50:59 --- mode: mauke set -o mauke
00:51:22 <jeffwheeler> But you silenced lambdabot! :(
00:51:28 <jeffwheeler> > head [1..]
00:51:29 <lambdabot>   1
00:51:34 <jeffwheeler> Oh, nevermind.
00:54:03 <jeffwheeler> Programming in other languages makes me appreciate Haskell's "it'll work if it compiles" mentality.
00:54:43 * pumpkin wants to kill himself from working in matlab for the past couple of days
00:55:19 <int80_h> oh yeah...I'm trying to learn netbsd kernel programming. It just breaks and breaks and breaks.
00:55:21 <jeffwheeler> Objective-C will compile _anything_. It just fails immediately thereafter.
00:55:36 <int80_h> makes a guy want to just express himself with crayons instead.
00:55:40 <afabian> I had to do a project in haskell for a university class... that's sort of what got me interested in haskell.  Everything worked perfectly by the time I had beaten the type errors into submission :o
00:55:49 <mm_freak> how do i close a window in House?
00:56:00 <jeffwheeler> afabian: that's the same way I feel. And I love that!
00:56:24 <jeffwheeler> Objective-C: "Oh, that method doesn't exist? Heh, it's probably okay." "Oh, you tried to run a method that doesn't exist! Ha! *crash*"
00:56:24 <int80_h> I got to haskell via lisp
00:57:09 <int80_h> I can't remember how I got to lisp. I think I started hearing voices saying "there's a better way. try Lisp."
00:57:30 <jeffwheeler> I'd also forgotten about missing semicolon errors . . . where the compiler doesn't tell you what file it's in. :P
00:57:50 <jeffwheeler> pumpkin: oh, you're in #freebase, too?
00:58:00 <pumpkin> jeffwheeler: yup :)
00:58:10 <jeffwheeler>  /love
00:58:16 <pumpkin> a haskell freebase API would be nice
00:58:29 <jeffwheeler> Yeah. I don't think I'm up to it, yet. :P
00:58:31 <pumpkin> maybe I'll submit that to haskell_proposals
00:58:41 <jeffwheeler> pumpkin: that'd be great.
00:58:44 <pumpkin> jeffwheeler: you a freebase employee?
00:58:51 <pumpkin> most of the people in #freebase seem to be :)
00:58:52 <jeffwheeler> pumpkin: nah, just a high-school student. ;)
00:58:55 <pumpkin> ah cool
00:58:56 <oklosol> mm_freak: how do i close a window in House? <<< you can't. tv shows don't do that yet
00:59:13 <oklosol> i know, i'm hilarious.
01:00:29 <jeffwheeler> I laughed. :)
01:00:48 <oklosol> :)
01:00:59 <afabian> It's always funny to watch the TV/movie take on something you actually know.  I vaguely remember a "unix system" in jurassic park.  It would be fun to be a movie "expert".. just green light anything that sounds even vaguely plausible.
01:02:02 <oklosol> i remember watching j-pod. there was a physics system that was "O(n lg n)", i was like "k?"
01:02:18 <SubStack> neat
01:03:26 <SubStack> nothing but showboating globetrotter algebra
01:03:28 <oklopol> it was a show about guys making games, but turned out it was more about their social lives (killing people etc.)
01:03:40 <oklopol> i wish there was a show about actual programming
01:03:44 <Lemmih> ?users
01:03:45 <lambdabot> Maximum users seen in #haskell: 637, currently: 565 (88.7%), active: 15 (2.7%)
01:04:05 <jeffwheeler> 637!? We probably were ahead of #php.
01:04:06 <oklopol> whole episodes about trying to find a good abstraction for a task, and such
01:04:12 <int80_h> oklopol: you mean the way bones is about forensic anthropology?
01:04:28 <SubStack> with real-world metaphors for the tasks at hand to bring it all down to earth maybe
01:04:35 <SubStack> and algorithm enactments
01:04:37 <oklopol> int80_h: no. bones has a *lot* of fa compared to j-pod vs. programming
01:04:43 <int80_h> I dunno, I think we'd be the only ones watching it
01:04:56 <SubStack> mostly good metaphors but now and then really really campy bad ones
01:04:58 <Lemmih> Advertising about 600 users gave us a bump, apparently. We should have done it when we reached 570. (:
01:05:00 <SubStack> just to keep it interesting
01:05:02 <jberryman> I wouldn't watch it
01:05:22 <chrisdone> oklopol: dude, SICP
01:05:35 <chrisdone> http://www.youtube.com/watch?v=YyuBG-TDBcw
01:05:39 <oklopol> int80_h: an important part of bones is the nerds talking about nerd stuff.
01:05:50 <chrisdone> Title: SICP / Whats wrong with Purely Function Paradigm / Part 2.4
01:05:57 <oklopol> and it's often very nerdy, at least to me, since i don't understand much of it.
01:06:08 <SubStack> my really crazy data structure regular expression thing is up to 180 lines :Z
01:06:16 <SubStack> for sequence prediction
01:06:23 <oklopol> SubStack: and algorithm enactments <<< yes!
01:06:30 <SubStack> \m/
01:06:59 <SubStack> actually, *any* show could do with a few algorithm enactments
01:07:01 <chrisdone> I often wished there was maybe programming TV, like an online stream
01:07:38 <oklopol> chrisdone: yes, that's probably better to start with than one show.
01:07:47 <mm_freak> oklopol: ok, good to know ;)
01:07:58 * int80_h prays to the gods of kernel hacking that his build doesn't break.
01:08:05 <SubStack> or even a few short clips on the youtube
01:08:12 <int80_h> again
01:08:38 <SubStack> kernel hacking, now that's something I hope I never have to do again by necessity
01:09:02 <SubStack> lousy wireless card
01:09:35 <jberryman> patching the kernel for realtime audio ftw
01:10:16 <chrisdone> I like how the guy asks if there is a way of localising effects
01:10:19 <chrisdone> he wants haskell, not scheme!
01:11:42 <oklopol> chrisdone: couldn't merge just assume bill and dave output tuples containing the time of transaction too?
01:11:43 <Adamant> chrisdone: I don't think Haskell had monads yet
01:11:49 <oklopol> and be the merge of mergesort
01:12:10 <SubStack> my mathematical-leaning engineering friend is always commenting how readable haskell is whenever I show off these little projects of mine
01:12:34 <ManateeLazyCat> How to make this "String -> URI"?
01:12:44 <jeffwheeler> Alright, let's be honest. $ and . don't make things readable.
01:12:46 <chrisdone> @hoogle String -> URI
01:12:47 <lambdabot> Warning: Unknown type URI
01:12:47 <lambdabot> Prelude error :: String -> a
01:12:47 <lambdabot> Debug.Trace trace :: String -> a -> a
01:13:03 <pumpkin> jeffwheeler: I think they do in some cases, but not always
01:13:04 <dmwit> jeffwheeler: No, good programming makes things readable.
01:13:13 <dmwit> jeffwheeler: (.) and ($) can be part of good programming.
01:13:16 <arw> jeffwheeler: yes, but i accidentially typed $ in scheme :)
01:13:23 <dmwit> jeffwheeler: They can also be an integral part in very confusing programming.
01:13:29 <jeffwheeler> Woah.
01:13:36 <pumpkin> I really love double (.)s though, even if they aren't super clear
01:13:36 <SubStack> I'd rather look at a chain of function compositions than have to figure out where the parens start and end
01:13:39 <chrisdone> haha
01:14:09 <jeffwheeler> People that have no idea what they mean are definitely intimidated by those operators. :P
01:14:22 <chrisdone> oklopol: dunno
01:14:25 <jeffwheeler> I agree that once you know what they mean, they're wonderful. :D
01:14:40 <jeffwheeler> (I should have made that more clear from the get-go.)
01:14:48 <arw> those two are the harmless sort of operators. there is definitely the tendency to define more and more obscure operators in haskell :)
01:16:00 <oklopol> chrisdone: but that's a pretty funny vid, it sounds like it's composed of finding what oo, monads and erlang solve, and list them as problems of lisp
01:16:01 <pumpkin> > (((^2) .) . (+)) 5 6 -- this is clear, right?
01:16:01 <lambdabot>   121
01:16:01 <pumpkin> wow, that was slow
01:16:11 <mm_freak> @pl \r x y -> if y == 0 then x else r y (mod x y)
01:16:12 <lambdabot> ap (ap . flip (if' . (0 ==))) . (. mod) . ap
01:16:25 <mm_freak> > fix (ap (ap . flip (if' . (0 ==))) . (. mod) . ap) 12 15
01:16:26 <lambdabot>   Not in scope: `if''
01:16:31 <pumpkin> lol
01:16:41 <chrisdone> oklopol: heh. the naive 80s, eh?
01:16:42 <mm_freak> @let if' p x y = if p then x else y
01:16:43 <lambdabot>  Defined.
01:16:45 <mm_freak> > fix (ap (ap . flip (if' . (0 ==))) . (. mod) . ap) 12 15
01:16:47 <lambdabot>   3
01:16:48 <jberryman> > let (.:)=(.)(.)(.) in ((+1) . (*2) . (^5)) .: (*) 2 3
01:16:49 <lambdabot>       No instance for (Num (a -> a1 -> b))
01:16:49 <lambdabot>        arising from the literal `2...
01:17:11 <pumpkin> you might need more parentheses
01:17:21 <jberryman> > let (.:)=(.)(.)(.); f = ((+1) . (*2) . (^5)) .: (*) in f 2 3
01:17:23 <lambdabot>   15553
01:18:08 <chrisdone> :t (.) (.) (.)
01:18:10 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
01:18:31 <chrisdone> :t on
01:18:32 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
01:18:45 <mm_freak> > let (.:) = (.).(.); f = ((+1) . (*2) . (^5)) .: (*) in f 2 3
01:18:47 <lambdabot>   15553
01:19:33 <Peaker> @let result f = (f.) ; argument f = (.f)
01:19:34 <pumpkin> (. flip (.)) . (.) . (.) is my favorite
01:19:34 <lambdabot>  Defined.
01:20:02 <oklopol> anyway, the merge problem can easily be solved without monads. you need time, and the model doesn't have that built-in? just encode it in the input, duh.
01:20:08 <mm_freak> i don't like any of those
01:20:10 <Peaker> > (result ((+1) . (*2) . (^5)) . (*)) 2 3
01:20:11 <lambdabot>   15553
01:20:14 <oklopol> noobs
01:20:15 <mm_freak> i'd rather write lambdas
01:20:39 <mm_freak> "merge problem"?
01:20:54 <oklopol> mm_freak: youtube vid
01:21:54 <Peaker> mm_freak: lambdas are one step further from more general code :)
01:21:55 <pumpkin> mm_freak: you don't like my favorite? :(
01:22:06 <pumpkin> I really like that one
01:22:13 <chrisdone> :t (. flip (.)) . (.) . (.)
01:22:15 <lambdabot> forall b b1 c a. (b1 -> c) -> (a -> b) -> (b -> b1) -> a -> c
01:22:31 <jberryman> mm_freak: I've started using the (.:) because my program is full of functions that look like: f a b = g$ h$ i a b, just wish there were a way to get rid of the parens around the expression before the .:
01:22:38 <Peaker> result blah . bleh -- do bleh and then apply blah on the result of bleh's result
01:22:39 <pumpkin> @let sandwich f g = (f .) . (. g)
01:22:40 <lambdabot>  Defined.
01:22:41 <oklopol> mm_freak: http://www.youtube.com/watch?v=YyuBG-TDBcw if you didn't feel like reading back
01:22:46 <pumpkin> :t sandwich
01:22:47 <lambdabot> forall c1 c a b. (c1 -> c) -> (a -> b) -> (b -> c1) -> a -> c
01:23:20 <oklopol> :t .:
01:23:21 <lambdabot> parse error on input `.:'
01:23:25 <oklopol> :t (.:)
01:23:27 <lambdabot> Not in scope: `.:'
01:23:29 <Peaker> @let infixr 2 ~> ; f~>g = result g . argument f
01:23:30 <lambdabot>  Defined.
01:23:39 <Peaker> :t (~>)
01:23:40 <lambdabot> forall a b c1 c. (a -> b) -> (c1 -> c) -> (b -> c1) -> a -> c
01:23:52 <mm_freak> Peaker: yes, but overusing pointfree style leads to pointless code
01:24:05 <pumpkin> @let sandwichMap f g = (f .) . (. g) . map
01:24:06 <lambdabot>  Defined.
01:24:32 <Peaker> :t ((+1) ~> (*2) ~> id) (+)
01:24:33 <lambdabot> forall a. (Num a) => a -> a -> a
01:24:57 <Peaker> The above means "modify (+) so that the first arg is (+1)'d, the 2nd arg is (*2)'d, and the result of (+) is unchanged
01:25:07 <Peaker> its a pretty cool way to "edit" functions :)
01:25:13 <pumpkin> neat :)
01:25:26 <chrisdone> ooo
01:25:37 <Peaker> ((+1) ~> (*2) ~> id) (+) 5 5
01:25:39 <Peaker> > ((+1) ~> (*2) ~> id) (+) 5 5
01:25:40 <lambdabot>   16
01:25:46 <Peaker> 6+10
01:25:54 <Peaker> > ((+1) ~> (*2) ~> (`div` 2)) (+) 5 5
01:25:56 <lambdabot>   8
01:26:09 <Peaker> that's kinda readable PL style :)
01:26:26 <pumpkin> :)
01:26:37 <Peaker> you've got a function, you can edit any "part" of that function (any arg or result of it)
01:27:02 <pumpkin> are those conal's semantic editors?
01:27:06 <pumpkin> they look familiar
01:27:09 <baaba> is there a name for ~>?
01:27:19 <pumpkin> baaba: twiddlydoo
01:27:21 <Peaker> pumpkin: no, they are someone else's, I forget who
01:27:25 <baaba> :P
01:27:35 <Peaker> http://matt.immute.net/content/pointless-fun
01:27:38 <pumpkin> ah :)
01:27:48 <Peaker> They are hellige's
01:28:24 <Peaker> @type ((+1) ~> (*2)) id
01:28:25 <lambdabot> forall a. (Num a) => a -> a
01:28:32 <pumpkin> seems fun
01:28:38 <Peaker> > (((+1) ~> (*2)) id) 5
01:28:39 <lambdabot>   12
01:28:47 <pumpkin> has the twiddlydoo been used for other things?
01:28:57 <pumpkin> it looks familiar
01:28:58 <Peaker> pumpkin: I think its a rather new idea. conal started using it
01:28:59 <mm_freak> oklopol: i've had the impression that guy doesn't know what he's talking about
01:29:30 <chrisdone> mm_freak: Hal Abelson? @_@
01:30:10 <mauke> THE ANTICUDDER
01:30:10 <pumpkin> Peaker: yeah, that post you linked to cites him
01:30:21 <chrisdone> Peaker: that is cool
01:30:25 <oklopol> well he's simply saying having two lists containing values, you can't know which element was appended when.
01:30:31 <chrisdone> Peaker: it makes me wonder how I wrote pointless code to do this before
01:30:38 <oklopol> and gives an example where that would be nice to know.
01:30:44 <mm_freak> probably he's chosen a bad example to introduce FP
01:31:02 <mm_freak> i think he was talking about merging infinite lists together
01:31:03 <oklopol> mm_freak: no, the point is to show where the paradigm trips
01:31:13 <oklopol> see caption
01:31:24 <oklopol> and what he says at introduction
01:31:34 <Peaker> it took me a while to grasp how (~>) works :)
01:31:48 <Peaker> a bit confusing :)
01:32:06 <pumpkin> when is that video from?
01:32:13 <ddarius> mm_freak: He's right but there are ways of dealing with it (to varying degrees), but ultimately he's write.  Anyway, this was all in the 70's or so.
01:32:13 <mm_freak> oklopol: yes, i've got that, but it appears to me that he tries to make it difficult artifically
01:32:16 <pumpkin> the audience's clothing looks vintage
01:32:25 <pumpkin> :P
01:32:36 <ddarius> He references Miranda, and I think he references it as being rather new.
01:32:52 <pumpkin> he has less hair now
01:32:53 <chrisdone> 80s
01:32:54 <mm_freak> indeed
01:32:55 <jeffwheeler> http://downforeveryoneorjustme.com/haskell.org :-/
01:32:59 <sbahra> I cannot paste. :/
01:33:01 <jeffwheeler> haskell.org doesn't seem to be responding
01:33:04 <chrisdone> haven't you read SICP?
01:33:07 <oklopol> mm_freak: i think he's more trying to get the point across that the lists can't be built during the program, from the program's perspective
01:33:20 <oklopol> which clearly that one guy in the audience doesn't understand
01:33:26 <oklopol> (i lolled)
01:33:29 <oklopol> (:P)
01:33:34 <ddarius> The audience members are amusing.
01:33:49 <mm_freak> oklopol: rather, think of two infinite lists generated by some unsafeInterleaveIO operation…  and merged by alternating elements
01:33:52 <pumpkin> "Richard Stallman reportedly enjoys sleeping on Abelson's couch."
01:34:00 <mm_freak> if one list stops, then the whole list stops at that spot
01:34:11 <mm_freak> the other list doesn't continue to produce
01:34:16 <pumpkin> lol: "If I have not seen as far as others, it is because giants were standing on my shoulders".
01:34:22 <chrisdone> I like the guy who looks like he ate all the pies; they keep zooming in on his face all the time
01:34:22 <mm_freak> that's what i've understood
01:34:24 <sbahra> Let's say I have the following: x :: ByteString = "asdadasd". When I set -XOverloadedStrings in ghci I get a compile error, ByteString is not an instance of IsString.
01:34:31 <sbahra> Am I doing something wrong?
01:34:44 <pumpkin> sbahra: aren't there 3 or 4 different ByteStrings?
01:34:52 <pumpkin> some of them might be less friendly than others?
01:34:56 <sbahra> Yes, I am using Data.ByteString.Char8 pumpkin.
01:35:02 <pumpkin> ah, hmm
01:35:04 <ddarius> Or you might not have an instance in scope.
01:35:06 <sbahra> I tried Data.ByteString.Lazy.Char8 too.
01:35:11 <ddarius> Perhaps it's in some other module.
01:35:13 <mm_freak> IsString?
01:35:14 <oklopol> mm_freak: well yes that's the same thing really... not that i'm sure what your point is :P
01:35:19 <mm_freak> > "test" :: BS.ByteString
01:35:21 <lambdabot>   Couldn't match expected type `BSC.ByteString'
01:35:26 <mm_freak> > "test" :: BSC.ByteString
01:35:27 <lambdabot>   Couldn't match expected type `BSC.ByteString'
01:35:28 <ddarius> At any rate, instance IsString ByteString where fromString = pack
01:35:31 <chrisdone> http://www.youtube.com/watch?v=YyuBG-TDBcw#t=2m47s --- there he is on the end
01:35:47 <sbahra> ddarius, but I thought ByteString really was an instance of it.
01:36:01 <sbahra> @info Data.ByteString.Char8
01:36:01 <lambdabot> Data.ByteString.Char8
01:36:03 <mm_freak> oklopol: my point is that either the stream of those requests isn't a list, or it's technically not generated by merging two lists
01:36:04 <sbahra> oh
01:36:05 <sbahra> ya
01:36:17 <mm_freak> oklopol: that's why i think, he's trying to make it look difficult artifically
01:36:29 <mm_freak> in today's FP languages you would use something like Chan
01:36:41 <ddarius> Chan isn't purely functional which proves his point.
01:36:52 <pumpkin> mm_freak: <argument by authority with whom I agree> QED
01:37:00 <chrisdone> Peaker: is this combinator in a Hackage package? admittedly it's only a few combinators, worth a package? but...
01:37:07 <mm_freak> ddarius: lists generated with unsafeInterleaveIO are
01:37:25 <ddarius> unsafeInterleaveIO is not purely functional
01:37:41 <mm_freak> but the list as well as the bank is
01:38:10 <ddarius> Yes, you can add an (impure) mergeStream function and keep everything else pure for the stream-based IO approach.
01:39:05 <mm_freak> i think, unsafeInterleaveIO is safe in many places
01:39:14 <ddarius> That's moot
01:39:17 <jberryman> I'm finishing a SplayTree module and not sure about the interface. I'm thinking the main tree functions should return (tree, x) where x might be Bool for insertion and deletion, to show whether it was successful or not...?
01:39:19 <ManateeLazyCat> I want to use uriPath get path from "uri string", so how to transform *string* to *uri* ?
01:39:38 <ddarius> The point is that you can't solve the problem from within the purely functional model.
01:40:16 <mm_freak> ddarius: there is no purely functional language, which doesn't do impure things under the hood
01:40:22 <oklopol> not without having someone wrap the inputs into a sensible infinite list first
01:40:34 <ddarius> That's fine, but unsafeInterleaveIO isn't impure "under the hood".
01:40:58 <chrisdone> mm_freak: I thought that was the point
01:41:18 <mm_freak> well, taking it further, he'll be right, but his point is void IMO
01:41:21 <Cale> mm_freak: What about the lambda calculus? ;)
01:41:37 <sbahra> jberg, whether what was successful or not?
01:41:46 <mm_freak> it's like saying you can't find the largest integer, because integers are limited by concept
01:41:48 <chrisdone> ManateeLazyCat: http://haskell.org/ghc/docs/latest/html/libraries/network/Network-URI.html#v%3AparseURI
01:41:49 <sbahra> jberryman, whether what was successful or not?
01:42:10 <ManateeLazyCat> chrisdone: Thanks
01:42:18 <mm_freak> Cale: ?
01:42:25 <sbahra> jberryman, are you familiar with State monad?
01:43:03 <mm_freak> Cale: let's add "general purpose" to "language" ;)
01:43:05 <enticingjelly> I try to intertwine to routines using continuations
01:43:06 * sbahra is having a Haskell program decide the fate of his academic career 
01:43:07 <jberryman> sbahra: for example of one tries to delete an element not present.
01:43:13 <Cale> mm_freak: okay ;)
01:43:18 <enticingjelly> it's not easy :(
01:43:30 <jberryman> sbahra: yes, I was thinking of State with that output tuple
01:43:43 <sbahra> jberryman, many ways to do this. Throw an exception (which can be caught), Either or Maybe.
01:43:55 <int80_h> well fellas, I'm off to bed
01:44:00 <int80_h> talk to you later
01:44:15 <ddarius> enticingjelly: You're probably not doing it in a disciplined way.
01:45:05 <enticingjelly> ddarius, what do you mean?
01:45:26 <sbahra> jberryman, but tuple seems better.
01:45:43 <sbahra> jberryman, (Tree,Bool)
01:46:21 <ddarius> enticingjelly: You're probably just "trying to do it" rather than thinking about how it should be organized, the interfaces, how to make it uniform, and such.
01:46:42 <jberryman> sbahra: so maybe invent my own approach? I wasn't sure if there was some standard way. I know with the splay tree I want to be able to pass the tree state even when the operation fails. to keep the tree optimized
01:46:45 <enticingjelly> ddarius, I think you're right, I'm more trying around. maybe I should think harder about it.
01:47:54 <Peaker> chrisdone: not AFAIK
01:48:02 <Peaker> chrisdone: pretty trivial to define though
01:48:23 <sbahra> jberryman, I'm a noob, but I've seen tuples used for such cases.
01:49:02 <sbahra> jberryman, as a noob, I would personally prefer (Tree, Bool). I can easily use that in compositions
01:49:12 <Peaker> @let res = (>>>) ; arg = (<<<) ; infixr 2 ~~> ; f ~~> g = res g . arg f
01:49:12 <lambdabot>  Defined.
01:49:18 <Peaker> @type (~~>)
01:49:19 <lambdabot> forall (a :: * -> * -> *) c d b b1. (Arrow a) => a c d -> a b b1 -> a b1 c -> a b d
01:49:33 <Peaker> > (((+1) ~~> (*2)) id) 5
01:49:34 <lambdabot>   11
01:49:41 <pumpkin> :o
01:49:47 <Peaker> chrisdone: I guess this is the way it should be defined...
01:50:25 <sbahra> That's very cool
01:51:21 <Peaker> > sortBy ((length ~> length ~> id) compare) ["a","bc"]
01:51:22 <lambdabot>   ["a","bc"]
01:51:46 <Peaker> > sortBy ((((length ~> length) . flip) ~> id) compare) ["a","bc"]
01:51:47 <lambdabot>   Couldn't match expected type `[a]' against inferred type `a1 -> c'
01:51:59 <sbahra> ;[
01:52:00 <chrisdone> =o
01:52:02 <Peaker> heh
01:52:21 <sbahra> Any good program to read that makes use of arrows?
01:52:34 <Peaker> sbahra: there's the monads-to-arrows paper about parsers
01:52:48 <sbahra> Is it full of non-ASCII symbols?
01:52:56 <Peaker> they all are :(
01:52:59 <sbahra> :(
01:53:58 <jberryman> ⚥
01:54:03 <Peaker> > sortBy ((length ~> length ~> id) (flip compare)) ["a","bc"]
01:54:04 <lambdabot>   ["bc","a"]
01:54:24 <sbahra> That doesn't seem to do what you want?
01:54:38 <afabian> hmm?  I'm not a very experienced haskell user, but everything I've seen is ascii.  why is non-ascii needed for papers...?
01:54:54 <Peaker> @type let f `on` g = (g ~> g ~> f) id in f
01:54:55 <lambdabot>     Occurs check: cannot construct the infinite type: b = b -> c1
01:54:55 <lambdabot>     Probable cause: `id' is applied to too many arguments
01:54:55 <lambdabot>     In the first argument of `(g ~> g ~> f)', namely `id'
01:55:00 <sbahra> afabian, I'm kidding. But I'm talking about formalisms (mathematical symbols, etc...)
01:55:02 <Peaker> @type let f `on` g = (g ~> g ~> id) f in f
01:55:03 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
01:55:05 <ManateeLazyCat> I use (uriPath (parseURI "http://www.google.com")) got against inferred type `Maybe URI', how to fix it?
01:55:12 <Peaker> @type let f `on` g = (g ~> g ~> id) f in on
01:55:13 <lambdabot> forall b c1 a. (b -> b -> c1) -> (a -> b) -> a -> a -> c1
01:55:17 <sbahra> afabian, too sleep deprived for something that requires much focus
01:55:18 <Peaker> @type on
01:55:19 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
01:55:42 <sbahra> ManateeLazyCat, can you paste error?
01:56:13 * ManateeLazyCat pasted "error" at http://paste2.org/p/124361
01:56:15 <Peaker> afabian: Well, the ASCII Haskell symbols are approximations for various unicode symbols, and the papers use the symbols themselves...
01:56:20 <ManateeLazyCat> sbahra: see http://paste2.org/p/124361
01:56:41 <sbahra> @hoogle fromJust
01:56:41 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
01:57:00 <sbahra> > fromJust (Just "wat")
01:57:01 <lambdabot>   "wat"
01:57:08 <sbahra> > fromJust Nothing
01:57:09 <lambdabot>   * Exception: Maybe.fromJust: Nothing
01:57:13 <sbahra> ManateeLazyCat, ^-
01:57:14 <pumpkin> eww
01:57:50 <sbahra> lambda is a trap
01:58:17 <sbahra> ManateeLazyCat, got it?
01:58:27 <chrisdone> ManateeLazyCat:  fmap uriPath parseURI
01:58:38 <sbahra> :t fmap
01:58:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:59:44 <chrisdone> :t fmap Network.URI.uriPath Network.URI.parseURI
01:59:45 <lambdabot>     Couldn't match expected type `Network.URI.URI'
01:59:45 <lambdabot>            against inferred type `Maybe Network.URI.URI'
01:59:45 <lambdabot>       Expected type: String -> Network.URI.URI
01:59:58 <sbahra> Seems strange
02:00:01 <chrisdone> :t Network.URI.uriPath
02:00:01 <sbahra> yes
02:00:03 <lambdabot> Network.URI.URI -> String
02:00:14 <chrisdone> uh, woops
02:00:17 <ManateeLazyCat> sbahra: Still can't work
02:00:19 <chrisdone> :t fmap Network.URI.uriPath . Network.URI.parseURI
02:00:20 <sbahra> chrisdone, ;p
02:00:21 <lambdabot> String -> Maybe String
02:00:56 <sbahra> That's cool.
02:01:08 <sbahra> ManateeLazyCat, fmap is better
02:01:09 <chrisdone> :t maybe
02:01:11 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
02:01:37 <sbahra> ManateeLazyCat, fmap Network.URI.uriPath . Network.URI.parseURI -- as chrisdone pointed out
02:02:25 <ManateeLazyCat> sbahra: fmap uriPath parseURI "http://www.google.com" can't works, is write like this?
02:03:04 <sbahra> fmap (uriPath . parseURI) (Just "http://www.google.com")
02:03:05 <chrisdone> ManateeLazyCat: what do you want to do with the value?
02:03:28 <ManateeLazyCat> chrisdone: display
02:03:36 <chrisdone> ManateeLazyCat: what if it's not in the URL?
02:03:43 <chrisdone> what if the URL is invalid?
02:03:59 <ManateeLazyCat> chrisdone: I have use function `isUri' check it,
02:04:11 <ManateeLazyCat> chrisdone: isURI
02:04:19 <sbahra> I take it he doesn't care :)
02:04:22 <sbahra> Lazy cat
02:04:37 <baaba> ManateeLazyCat, unfortunately, the type system can't know that you've satisfied that condition
02:05:14 <chrisdone> ManateeLazyCat: you might as well not bother using isUri and use parseURI which will validate it for you anyway and return Nothing if it's invalid
02:05:40 <chrisdone> "Turn a string containing a URI into a URI. Returns Nothing if the string is not a valid URI; (an absolute URI with optional fragment identifier)."
02:06:25 <ManateeLazyCat> chrisdone: before i use uriPath, i have use isURI check it. "http://www.google.com" in this just for test.
02:06:53 <ManateeLazyCat> chrisdone: If isURI return False, i will interrupt program.
02:07:12 <baaba> ManateeLazyCat, but you don't gain anything in this case because isURI doesn't really work in conjunction with uriPath
02:07:52 <chrisdone> Prelude Network.URI> maybe (putStrLn "invalid URL!") (putStrLn . uriPath) $ parseURI "http://www.google.com/blah"
02:07:52 <chrisdone> /blah
02:07:52 <chrisdone> Prelude Network.URI> maybe (putStrLn "invalid URL!") (putStrLn . uriPath) $ parseURI ""
02:07:52 <chrisdone> invalid URL!
02:08:02 <chrisdone> (seeing as lambdabot doesn't seem to import Network.URI)
02:08:08 * ManateeLazyCat pasted "my code" at http://paste2.org/p/124364
02:08:10 <baaba> er sorry, i mean parseURI
02:08:37 <ManateeLazyCat> baaba: See http://paste2.org/p/124364 , i check it.
02:08:56 <ManateeLazyCat> sbahra: fmap (uriPath . parseURI) (Just "http://www.google.com") still can't works
02:08:57 <baaba> yeah but parseURI has no way of knowing that you check it
02:09:08 * sbahra is severely confused
02:09:53 <sbahra> ManateeLazyCat, look at chrisdone's example
02:09:55 <sbahra> :t maybe
02:09:56 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
02:10:37 <chrisdone> case parseURI "dfgdfg" of
02:10:37 <chrisdone>   Just path -> valid uri
02:10:37 <chrisdone>   Nothing -> invalid uri
02:10:40 <chrisdone> there are tonnes of ways to do this
02:10:43 <ManateeLazyCat> baaba: Why? In my code, if is isURI return False, i will interrupt program, if True, i will transform to parseURI
02:10:44 <sbahra> > maybe (putStrLn "ERROR!") (putStrLn "SUCCESS") $ Just 5
02:10:45 <lambdabot>   Couldn't match expected type `a -> IO ()'
02:10:51 <sbahra> god I fail
02:11:08 <chrisdone> sbahra: the second argument should be a function of one argument
02:11:12 <baaba> ManateeLazyCat, yeah but parseURI still has no way of knowing the fact that you have checked isURI
02:11:21 <chrisdone> > maybe 0 (+1) $ Just 1
02:11:23 <lambdabot>   2
02:11:25 <chrisdone> > maybe 0 (+1) $ Nothing
02:11:25 <sbahra> > maybe (putStrLn "ERROR!") (putStrLn) $ Just "5"
02:11:27 <lambdabot>   * Exception: "<IO ()>"
02:11:27 <lambdabot>   0
02:11:28 <baaba> it's unfortunate that it can't, and there are ways of doing it in some type systems, but not in haskell (as far as i know)
02:11:29 * sbahra is dyslexic at this stage
02:11:34 <sbahra> ok, there we go ;p
02:12:00 <sbahra> yes
02:12:13 <chrisdone> > (+1) <$> Just 1
02:12:15 <lambdabot>   Just 2
02:12:20 <baaba> of course, isURI might return a ValidatedURIString value or something which parseURI could then accept and return a plain URI without wrapping it in a Maybe
02:12:23 <sbahra> :t <$>
02:12:23 <baaba> but it doesn't
02:12:24 <lambdabot> parse error on input `<$>'
02:12:29 <sbahra> :t (<$>)
02:12:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:12:41 <chrisdone> (it's the same as fmap)
02:12:45 <sbahra> ye
02:12:49 <sbahra> but pretty
02:12:52 <chrisdone> ie
02:12:55 <sbahra> cash money
02:12:56 <chrisdone> indeed
02:13:29 * beelsebob ponders why no one is pointing out to ManateeLazyCat the lack of need to use isURI at all
02:13:41 <chrisdone> beelsebob: read up
02:13:43 <baaba> it has been pointed out more than once :P
02:13:47 <sbahra> ah, cool
02:13:57 <beelsebob> ah, okay
02:14:06 <sbahra> ah, damn
02:14:20 <chrisdone> ah, ah
02:14:24 <ManateeLazyCat> baaba: Why i need isURI again?
02:14:31 <sbahra> ManateeLazyCat, no need
02:14:31 <baaba> you don't
02:14:46 <beelsebob> you don't
02:15:06 <beelsebob> parseURI verifies it for you, and even does it in a way the type system can see
02:15:43 <ManateeLazyCat> So anyone can write a write code for me? I'm confusion now.
02:15:45 <sbahra> @hoogle (<$>)
02:15:46 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
02:16:02 <chrisdone> man xmonad is so damn stable
02:16:37 <Peaker> @src maximumBy
02:16:38 <lambdabot> Source not found. There are some things that I just don't know.
02:16:44 <sbahra> :t maximumBy
02:16:45 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
02:17:03 <Peaker> I wonder what is a pretty way to use compare's type to "max", there's no maxBy
02:17:15 <baaba> ManateeLazyCat, you replace isURI with parseURI and do a case result of Just uri -> dosomethingwithURI uri; Nothing -> putStrLn "ERROR!"
02:17:18 <Peaker> @src sortBy
02:17:18 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
02:17:24 <Peaker> @src insertBy
02:17:24 <lambdabot> insertBy _   x [] = [x]
02:17:24 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
02:17:24 <lambdabot>                                  GT -> y : insertBy cmp x ys'
02:17:24 <lambdabot>                                  _  -> x : ys
02:17:34 <Peaker> I guess there is no pretty way..
02:17:36 <pumpkin> I love that definition of sortBy
02:17:58 <sbahra> pumpkin, why?
02:18:14 <pumpkin> it's epicly efficient
02:18:23 <ziman> i thought it would be an O(n log n) algorithm
02:18:39 <pumpkin> ziman: the real one is, but lambdabot seems to think that'sit
02:18:46 <ziman> oh, i see.
02:18:52 <ManateeLazyCat> baaba: I use isURI in *case* is not correct?
02:21:33 <ManateeLazyCat> sbahra: So how write those simple code? Can you give me a work version? I'm confusion now.
02:21:48 <sbahra> ManateeLazyCat, yes you are
02:23:13 <ManateeLazyCat> sbahra: parseURI return "Maybe URI" if valid uri, and uriPath just accept URI type, so how to do make "Maybe URI -> URI"?
02:24:40 <sbahra> ManateeLazyCat, what is Maybe?
02:25:10 <beelsebob> ManateeLazyCat: you fmap uriPath over the Maybe, or you use a case to get the uri out of the Maybe
02:25:40 <dmwit_> > do { x <- Just 3; if x == 0 then Nothing else Just (x+1) }
02:25:41 <lambdabot>   Just 4
02:25:46 <dmwit_> > do { x <- Just 0; if x == 0 then Nothing else Just (x+1) }
02:25:48 <lambdabot>   Nothing
02:25:52 <dmwit_> > do { x <- Nothing; if x == 0 then Nothing else Just (x+1) }
02:25:54 <lambdabot>   Nothing
02:27:59 <mm_freak> > do { x <- Just 3; guard (x /= 0); return (x+1) }
02:28:01 <lambdabot>   Just 4
02:28:04 <mm_freak> > do { x <- Just 0; guard (x /= 0); return (x+1) }
02:28:04 <beelsebob> ewwww, what a horrible way to deal with maybes
02:28:06 <lambdabot>   Nothing
02:28:26 <beelsebob> > maybe (Just 3) Nothing (Just . (+1))
02:28:27 <lambdabot>   Couldn't match expected type `a -> Maybe t'
02:28:37 <beelsebob> > maybe Nothing (Just . (+1)) (Just 3)
02:28:38 <lambdabot>   Just 4
02:28:44 <beelsebob> > maybe Nothing (Just . (+1)) Nothing
02:28:45 <lambdabot>   Nothing
02:28:58 <sbahra> :t guard
02:28:59 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
02:29:11 <ManateeLazyCat> Okay, this (uriPath (fromJust (parseURI "http://www.google.com/intl/en/"))) can work
02:29:13 <beelsebob> > maybe 0 (+1) Nothing
02:29:14 <ManateeLazyCat> Thanks all.
02:29:15 <lambdabot>   0
02:29:24 <beelsebob> ManateeLazyCat: no no no
02:29:30 <beelsebob> never use fromJust
02:29:37 <ManateeLazyCat> beelsebob: Why?
02:29:49 <sbahra> > fromJust Nothing
02:29:50 <beelsebob> if parseURI doesn't get a valid URI, it'll crash trying to take something out of a Nothing
02:29:51 <lambdabot>   * Exception: Maybe.fromJust: Nothing
02:30:17 <dmwit_> ?let ensure p x = guard (p x) >> return x
02:30:17 <lambdabot>  Defined.
02:30:18 <beelsebob> ManateeLazyCat: maybe is a safer version
02:30:29 <dmwit_> > ensure (/= 0) 3
02:30:30 <lambdabot>       No instance for (Show (m b))
02:30:30 <lambdabot>        arising from a use of `show' at <in...
02:30:34 <dmwit_> > ensure (/= 0) 3 :: Just Int
02:30:35 <lambdabot>   Not in scope: type constructor or class `Just'
02:30:36 <beelsebob> it tells it what to do in the "oh bugger" case
02:30:42 <dmwit_> > ensure (/= 0) 3 :: Maybe Int -- aaa
02:30:43 <lambdabot>   Just 3
02:30:46 <sbahra> haha
02:30:49 <dmwit_> > ensure (/= 0) 0 :: Maybe Int
02:30:50 <lambdabot>   Nothing
02:31:17 <Gracenotes> > ensure (/= 0) 3 :: [Int]
02:31:17 <dmwit_> > Just 3 >>= ensure (/= 0) >>= return 9001
02:31:18 <lambdabot>       No instance for (Num (Maybe b))
02:31:18 <lambdabot>        arising from the literal `9001' ...
02:31:18 <lambdabot>   [3]
02:31:24 <mm_freak> i wonder why list comprehensions are special to lists
02:31:29 <dmwit_> > Just 3 >>= ensure (/= 0) >> return 9001
02:31:30 <lambdabot>   Just 9001
02:31:39 <mm_freak> > [ x+1 | x <- Just 5, x /= 2 ]
02:31:40 <dmwit_> mm_freak: To make the error messages readable to newcomers. =/
02:31:41 <lambdabot>   Couldn't match expected type `[t]' against inferred type `Maybe t1'
02:31:51 <Gracenotes> mm_freak: monads were originally called monad comprehensions, I think :P
02:31:54 <mm_freak> hmm
02:31:55 <dmwit_> mm_freak: Haskell 1.4 had monad comprehensions.
02:32:06 <dmwit_> Gracenotes: not exactly
02:32:14 <mm_freak> monad comprehensions?
02:32:17 <Gracenotes> yeah, probably not.
02:32:20 <mm_freak> generalized list comprehensions?
02:32:26 <sbahra> dmwit_, are you serious, to make error messages readable?
02:32:30 <dmwit_> mm_freak: exactly
02:32:34 <Gracenotes> but I seem to recall that the paper Comprehending Monads referred to monads in the context of list comprehensions
02:32:35 <dmwit_> sbahra: Yes.  I'm dead serious.
02:32:43 <sbahra> :(
02:33:00 <sbahra> I guess that's the cost of popularity.
02:33:12 <dmwit_> [ foo | pattern <- bar, baz ] --> do { pattern <- bar; guard baz; return foo }
02:33:13 <mm_freak> although i wouldn't know what to do with a generalized version of them anyway…  i hardly use list comps =)
02:33:38 <Gracenotes> "The first contribution is a new language feature, the monad comprehension. This generalises the familiar notion of list comprehension [Wad87], due originally to Burstall and Darlington, and found in KRC [Tur82], Miranda, Haskell and other languages."
02:33:42 <Gracenotes> ^ dmwit_
02:34:01 <Gracenotes> from Philip Wadler's Comprehending Monads, published in 1990
02:34:05 <dmwit_> Gracenotes: Yes.  I'm not debating whether monad comprehensions existed.
02:34:43 <Gracenotes> So why were they gotten rid of?
02:34:44 <ManateeLazyCat> beelsebob: So how to write *maybe* version?
02:34:53 <dmwit_> Gracenotes: My only claim is that "monads used to be called monad comprehensions" is imprecise to the point of being wrong.
02:35:03 <sbahra> Gracenotes, <dmwit_> mm_freak: To make the error messages readable to newcomers. =/
02:35:03 <dmwit_> Gracenotes: To make error messages more readable for newbies.
02:35:03 <beelsebob> ManateeLazyCat: well, what would you like to give back if there isn't a valid URI?
02:35:30 <ManateeLazyCat> beelsebob: Just use "http://www.google.com/intl/en/" for test.
02:35:31 <dolio> The 1.4 report actually calls them list comprehensions, but they still work for all monads.
02:35:34 <mm_freak> dmwit_: that could have been done without abandoning them
02:35:38 <sbahra> haha
02:35:49 <Gracenotes> dmwit_: would it be accurate to say that programmatic monads were introduced as monad comprehensions?
02:35:50 <mm_freak> the compiler could output special error messages in the context of the list monad
02:35:50 <beelsebob> ManateeLazyCat: no, I want to know what you want to happen in an error case
02:35:50 <dmwit_> mm_freak: I'm totally with you.
02:35:54 <beelsebob> when the URI is not a URI at all
02:35:55 <sbahra> ManateeLazyCat, out of curiosity, what is your native language?
02:36:01 <Peaker> the error messages are unreadable by Newbies anyhow! :-)
02:36:04 <sbahra> Maybe one of us speak it.
02:36:08 <dmwit_> mm_freak: The Simons have agreed to accept a patch putting them back into GHC, if you feel ambitious... =)
02:36:16 <beelsebob> ManateeLazyCat: why should it return if I give it the "URI" "htk*2s/4\1thdakn"
02:36:19 <ManateeLazyCat> beelsebob: Interrupt program
02:36:23 <dmwit_> sbahra: Chinese
02:36:31 <Gracenotes> dmwit_: that is, they were first comprehensions
02:36:39 <dmwit_> Gracenotes: No.
02:36:44 <ManateeLazyCat> sbahra: Chinese
02:36:51 <Gracenotes> okay, so what's the chronological relationship?
02:36:52 <sbahra> Ah, sorry
02:36:58 <dmwit_> Gracenotes: Monads were always monads.  Comprehensions and do blocks were always sugar for (>>=) and return.
02:36:59 <mm_freak> dmwit_: however, i don't use comprehensions anyway
02:37:05 * sbahra could do little French and Arabic
02:37:09 <mm_freak> i usually use list functions or do-notation
02:37:10 <beelsebob> okay, then maybe (error "your URI is bullshit, use me right") uriPath . parseURI
02:37:16 <dmwit_> Gracenotes: Monads were studied before Haskell existed.
02:37:46 <Gracenotes> in programming languages specifically, or just in category theory?
02:37:55 <dmwit_> Mostly in CT, yes.
02:38:38 <Gracenotes> okay, got that. Then what (if not Wadler's paper) largely introduced monads as programming features?
02:39:00 <dmwit> The old model for IO sucked.
02:39:06 <dolio> Moggi's papers originally introduced it to the programming languages community.
02:39:17 <dolio> Wadler may have been the first to see it as a tool for practical programming.
02:39:24 <dmwit> And then Moggi descended and gave us the tablets. ;-)
02:39:41 <ManateeLazyCat> beelsebob: Can't work
02:39:50 <beelsebob> ManateeLazyCat: why not?
02:39:52 <Gracenotes> Okay, that makes sense, thanks. I'll go off and read Moggi's papers then :)
02:39:54 <ManateeLazyCat> I'm crazy....
02:40:07 <beelsebob> @type (maybe (error "jam") useURI) parseURI
02:40:08 <lambdabot> Not in scope: `useURI'
02:40:08 <lambdabot> Not in scope: `parseURI'
02:40:09 <mm_freak> dmwit: what was the old model?  state-passing?
02:40:18 <Gracenotes> grazie, dolio + dmwit
02:40:21 <beelsebob> >.<
02:40:56 <beelsebob> @type maybe (error "jam") Network.URI.uriPath . Network.URI.parseURI
02:40:57 <lambdabot> String -> String
02:41:02 <dmwit> mm_freak: Everything was pure.
02:41:04 <beelsebob> looks like it works to me
02:41:14 <mm_freak> dmwit: so there was no I/O at all?
02:41:19 <dmwit> mm_freak: If you wanted to do anything impure, you had to write a C wrapper that called your pure function!
02:41:28 <sbahra> heh
02:41:30 <mm_freak> oh, that's nasty
02:41:34 <sbahra> haha
02:41:35 <beelsebob> > maybe (error "jam") Network.URI.uriPath . Network.URI.parseURI $ "http://www.google.com/intl/en/"
02:41:35 <dmwit> I'm not sure if I have all the details right here.
02:41:36 <lambdabot>   /tmp/3140638573274259990:70:52: Not in scope: `Network.URI.uriPath'/tmp/314...
02:41:46 <ManateeLazyCat> beelsebob: Is this (maybe (error "test") uriPath) parseURI "http://www.google.com" ?
02:41:49 <mm_freak> dmwit: even Clean got that better =)
02:41:58 <Gracenotes> hehreally?
02:41:58 <dmwit> But that was the idea of it.
02:41:58 <beelsebob> awww :(
02:41:58 <dmwit> There was a standard wrapper like today's "interact".
02:42:04 <sbahra> ManateeLazyCat, no, use it exactly as he showed
02:42:04 <ManateeLazyCat> beelsebob: Can you please write complete version?
02:42:05 <Gracenotes> dmwit: eh, this was all probably going on before I was born >_>
02:42:12 <beelsebob> ManateeLazyCat: I just did
02:42:17 <sbahra> ManateeLazyCat, keep parens same
02:42:17 <beelsebob> maybe (error "jam") Network.URI.uriPath . Network.URI.parseURI $ "http://www.google.com/intl/en/"
02:42:21 <dmwit> But that doesn't do any file IO, or pointer manipulations, or... etc etc.
02:42:56 <sereven> Prelude Network.URI> maybe (error "jam") Network.URI.uriPath . Network.URI.parseURI $ "http://www.google.com/intl/en/"
02:42:58 <dmwit> Gracenotes: If the history interests you, I think they just wrote a retrospective recently.
02:43:03 <ManateeLazyCat> beelsebob: Yep, thanks, it's works.
02:43:11 <sbahra> dmwit, "they"?
02:43:23 <ManateeLazyCat> beelsebob: I need study too many with Haskell programming *style*.
02:43:25 <mm_freak> i find the current monadic model incredibly great
02:43:28 <dmwit> sbahra: Various authors.
02:43:55 <mm_freak> when i was a Young Boy (an imperative programmer), i thought, there couldn't be anything better than what i've got
02:43:57 <dmwit> huh
02:44:01 <dmwit> ?go haskell retrospective
02:44:02 <mm_freak> monads bent my mind a lot
02:44:02 <sbahra> monads are of biblical quality
02:44:04 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-retrospective/
02:44:16 <beelsebob> ManateeLazyCat: I think you may need to study a bit more programming in all honesty – learn to think more about the things that can go wrong, than the things that can go right
02:44:18 <Gracenotes> *takes a look*
02:44:23 <dmwit> "The service is unavailable."
02:44:24 <sbahra> not available :{
02:44:25 <Gracenotes> er, hm
02:44:36 <dmwit> Right all the way up to research.microsoft.com.
02:45:26 <Gracenotes> hm. the actual PDF link is http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-retrospective/HaskellRetrospective.pdf (not working either)
02:45:41 <ManateeLazyCat> beelsebob: I'm not fitted to programming with Haskell.
02:45:53 <sbahra> ManateeLazyCat, I think language barrier is big problem.
02:45:57 <beelsebob> ManateeLazyCat: I'm sure you are – you probably just haven't got your brain round it yet
02:46:11 <Gracenotes> dmwit: anyway, thank Google, there are plenty of old monadic papers available
02:46:38 <ManateeLazyCat> Thanks all.
02:47:32 <Gracenotes> dmwit: well, I found the PPT version
02:47:35 <Gracenotes> http://www.cs.nott.ac.uk/~gmh/appsem-slides/peytonjones.ppt
02:48:01 <sbahra> thanks
02:48:19 <dmwit> http://www.haskell.org/haskellwiki/History_of_Haskell
02:48:32 <dmwit> This is what I was talking about.
02:48:41 <dmwit> The retrospective is the wrong thing.
02:48:59 <Gracenotes> ah. The retrospective seems interesting too :P
02:49:05 <dmwit> Yeah.
02:49:17 <Gracenotes> although that service may be unavailable as well
02:49:22 <dmwit> I think the retrospective focuses on adding classes to Haskell, which was also a pretty big deal.
02:59:20 <killerstorm> hi. i have problems with ghci, it often reports weird problems when i'm trying to execute larger code pieces. i'm using version 6.6 available via Debian Linux 4.0
02:59:42 <killerstorm> it is only this version is bad, or ghci is freaky by nature?
03:00:05 <bremner> killerstorm: pretty old version.
03:00:09 <dmwit> I've never seen that happen on any version of ghci.
03:00:21 <dmwit> You do have an old version, but it shouldn't be doing that.
03:02:39 <killerstorm> i guess it might be a problem of Debian's build, i see some IO errors in compiled programs (such as darcs) too. for example what ghci prints me when trying to open 2kb XML file:
03:02:40 <killerstorm> *** Exception: book1.xml: openFile: resource exhausted (Resource temporarily unavailable)
03:02:59 <killerstorm> looks like i need to build ghc myself. <sigh>
03:03:30 <killerstorm> or there are some newer debian binary packages available?
03:03:38 <crashit> hi
03:04:26 <blackh1> killerstorm: I'm using Ubuntu and the pre-built binary for ghc 6.10.1 works well for me.  So, I think that would be worth a try on Debian.
03:05:08 <crashit> can someone help me with some code?i am new in this language!!?
03:05:48 <blackh1> crashit: Hi there! Do tell! If you want to paste an example, use the pastbin at http://hpaste.org
03:05:51 <pumpkin> crashit: sure :)
03:06:01 <pumpkin> crashit: nice substring :P
03:06:29 <killerstorm> kthx
03:07:05 <crashit> i have code which i need to repair..i do some work but seems that something dont work well but i dont know what
03:08:05 <blackh1> crashit: Put it on the pastebin and we will help.
03:08:21 <crashit> here this link
03:08:25 <crashit> http://www.nabble.com/I-need-help-with-this-code!-td21214267.html
03:08:45 <crashit> i think that there need to be code
03:09:10 <dmwit> Can you narrow it down a bit?
03:09:34 <crashit> what?
03:09:40 <jonaskoelker> I try to build my project with hmake -hat, but there's no hat-.../Data/Ord.hx.  What do I do?  If I try to symlink everything into my own project, I end up in dependency hell :(
03:10:03 <pumpkin> crashit: what doesn't work?
03:10:18 <dmwit> What lovely code. =P
03:11:04 <crashit> it need to take one line from code.txt to pareit and to find one paricular line from 3500 line and to write it in find.txt
03:11:06 <pumpkin> http://www.google.com/search?q=%22basic+Code+Verification+procedure%22
03:11:30 <Gracenotes> argh. http://downforeveryoneorjustme.com/research.microsoft.com
03:11:37 <pumpkin> oh it's for mod-x
03:11:51 <pumpkin> crashit: so you just want to get it working? :P
03:12:20 <crashit> she working but dont get that result
03:12:30 <crashit> i can give u and code.txt
03:12:45 <crashit> but i can get return result
03:14:05 <dmwit> crashit: Maybe you should get some sleep.
03:14:13 <crashit> :D
03:14:24 <crashit> i did that
03:14:30 <Gracenotes> what does DIY mean in DIY infix? do-it-yourself?
03:14:38 <crashit> i do a job few days ago
03:14:40 <dmwit> Gracenotes: where?
03:14:51 <crashit> but i can figure this out
03:15:13 <Gracenotes> in the Haskell retrospective, SPJ points out features of Haskell, including "DIY infix operators", with the example f `map` xs
03:15:30 <dmwit> Gracenotes: Yeah, do-it-yourself.
03:15:54 <Gracenotes> it `do` yourself...
03:16:00 <mm_freak> maybe you guys are interested…  i've never actually found a direct comparison between UArray and STUArray, so i just tried it
03:16:01 <IWannaLog> Hi is it possible to create a function with type: m (IO a) -> IO (m a)  I'm almost sure it's impossible in the genric case (m is a monad)
03:16:04 <IWannaLog> ?
03:16:07 <pumpkin> crashit: not that this helps you much, but isn't the point of mod-x to be doing it yourself?
03:16:11 <mm_freak> STUArray is orders of magnitude faster =/
03:16:19 <dmwit> IWannaLog: Impossible in general.
03:16:23 <IWannaLog> ok
03:16:25 <int-e> mm_freak: what are you doing with it?
03:16:27 <dmwit> IWannaLog: However, you may be interested in monad transformers.
03:16:54 <mm_freak> int-e: sieve of erathosthenes, hold on, i'll paste the code
03:16:57 <int-e> mm_freak: updating an UArray is expensive, because the array is copied. lookups should be cheap
03:17:01 <IWannaLog> It because I got a monad which is just an alias of IO and I ws asking myself if like sequence we could wrap monad into
03:17:11 <dmwit> mm_freak: That's awesome!
03:17:14 <IWannaLog> but only the monad we know could move in another monad
03:17:16 <int-e> mm_freak: that's updating a lot. so, yes, use STUArray.
03:17:50 <dmwit> mm_freak: Did you compare IOUArray and STUArray?
03:17:56 <dmwit> mm_freak: It's probably a fair-er comparison.
03:18:13 <mm_freak> http://hpaste.org/13599
03:18:23 <int-e> dmwit: they /should/ perform the same - after all, the underlying code is just a newtype apart.
03:18:27 <mm_freak> dmwit: they should give the same performance
03:18:33 <IWannaLog> And is it possible to create a function of type IO a -> a when we're in main, I'm almost sure it's impossible but want some confirmation
03:18:33 <dmwit> right
03:18:48 <dmwit> IWannaLog: We have such a function.
03:18:51 <mm_freak> dmwit: and i need less convenient code to compare them =P
03:18:51 <dmwit> IWannaLog: But we don't use it.
03:19:01 <dmwit> mm_freak: =)
03:19:11 <IWannaLog> A function I could create in Haskell without unsafePerformIO
03:19:13 <mm_freak> IWannaLog: well, you've got (>>=)
03:19:28 <IWannaLog> mm_freak: >>= doesn't get out the IO
03:19:39 <dmwit> IWannaLog: No.  You lift more things into the monad, rather than dropping things out of the monad.
03:19:39 <mm_freak> when you're in main, you're in IO anyway
03:19:49 <mm_freak> otherwise, no, it's incorrect to "get out of IO"
03:19:57 <mm_freak> it's the whole point of IO that you can't get out
03:20:09 <IWannaLog> and impossible to create a get out function inside the IO ?
03:20:09 <int-e> mm_freak: yes, using UArray instead of STUArray there turns an O(n log(n)) algorithm into an O(n^2 / log(n)) algorithm.
03:20:15 <dmwit> (>>=) lifts a function on non-monadic inputs to a function on monadic inputs. =)
03:20:19 <beelsebob> IWannaLog: that's the point of the IO monad -- it traps things in there
03:20:25 <mm_freak> int-e: yes
03:20:26 <beelsebob> it makes sure that non-functional things never escape it
03:20:36 <beelsebob> IWannaLog: sure it is – it's called unsafePerformIO
03:20:40 <beelsebob> it's just not safe to do so
03:20:40 <dmwit> :t flip (>>=) :: Monad m => (a -> m b) -> (m a -> m b)
03:20:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
03:20:42 <beelsebob> (usually)
03:20:55 <mm_freak> int-e: but i found that UArray is still fast enough in many cases…  for example, i implemented RC4 using State and UArray
03:20:57 <dmwit> IWannaLog: You might like:
03:20:58 <dmwit> :t join
03:20:59 <pumpkin> beelsebob: I thought the unsafe prefix meant it was safe
03:20:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
03:21:04 <mm_freak> it wasn't as fast as the C version, but it was fast
03:21:22 <dmwit> IWannaLog: join m = do { x <- m; y <- x; return y }
03:21:22 <beelsebob> pumpkin: actually, I'd really love to see it renamed to verifyItsSafeYourselfPerformIO
03:21:32 <beelsebob> it's a longer name, so it would desuade casual use more
03:21:32 <IWannaLog> It was theorical question to to really understand the haskell's type system (I came form ocaml's one)
03:21:34 <dmwit> (= do { x <- m; x })
03:21:43 <beelsebob> but it would also remove some stigma, about using it when you have verified it yourself
03:21:50 <pumpkin> yeah
03:22:51 <dmwit> join is pretty neat
03:22:56 <mm_freak> IWannaLog: in fact, it has more to do with haskell's pureness than with its type system
03:23:01 <int-e> mm_freak: sure. UArray is good when you recompute the whole array anyway.
03:23:12 <IWannaLog> I'm still new
03:23:13 <pumpkin> > join (==) 5
03:23:14 <lambdabot>   True
03:23:15 <mm_freak> however, the typesystem allows it to _stay_ pure, even in the presence of 'impure' code
03:23:25 <mm_freak> int-e: you don't in RC4
03:23:33 <mm_freak> int-e: you recompute at most two elements per output byte
03:24:18 <IWannaLog> I saw in my libraries "class (Monoid w, Monad m) => MonadWriter w m | m -> w where"
03:24:28 <IWannaLog> Can I create this things without -fglasgox-exts ?
03:24:40 <mm_freak> IWannaLog: you can't in haskell98
03:24:48 <mm_freak> but you can without -fglasgow-exts
03:25:12 <ddarius> beelsebob: There's no way to "verify it yourself" and anyways presumably all your code is "verified" to be correct by you before you release it.
03:25:17 <Peaker> nice, my little minimax tictactoe worked correctly on the first try
03:25:30 * Peaker wants to create minimax/alphabeta as generic libraries for any game
03:25:32 <IWannaLog> Won't it say that there is too many type for class declaration and to use -XAllow...
03:25:37 <beelsebob> ddarius: sure there are – the ghc manual gives the exact rules you need to follow for it to be safe
03:25:47 <pumpkin> Peaker: ooh!
03:26:05 <dv_> anyone ever came up with declarative vector graphics?
03:26:15 <int-e> mm_freak: I see. hmm. I guess 256 bytes is just really small.
03:26:18 <ddarius> beelsebob: I don't think any of those are formal and even if they were, I don't believe any of them are formally verifiable.
03:26:19 <beelsebob> unsafePerformIO . return $ 5 -- I can easily verify this is safe for example ddarius
03:26:22 <dv_> most of the time I see some graphics done on-demand I see imperative code
03:26:30 <mm_freak> int-e: yes, as said, the C version is still much faster
03:26:34 <pumpkin> dv_: how would that work?
03:26:34 <dv_> like, "draw rect at X Y, then draw line here etc."
03:26:41 <mm_freak> likely it wouldn't be faster, if i used STUArray
03:26:52 <dmwit> ?hackage diagrams
03:26:52 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/diagrams
03:26:58 <dmwit> dv_: Check that out.
03:26:59 <mm_freak> but UArray with State is so much more convenient to deal with
03:27:04 <beelsebob> dv_: look at FieldTrip
03:27:19 <dolio> beelsebob: Can you? :)
03:27:20 <dv_> instead, I would see something like a bunch of constraints, and some variables attached to it, turning the vector graphics into a function
03:27:28 <dolio> What if unsafePerformIO launches missiles?!
03:27:47 <pumpkin> then it would be called unsafeLaunchICBM wouldn't it?
03:27:48 <beelsebob> dolio: heh, what if fromJust launches missiles
03:27:53 <pumpkin> names are proofs!
03:28:00 <mm_freak> dolio: then at least it's less likely evaluated than the actual IO action =)
03:28:11 <beelsebob> fromJust is no less likely to do so than unsafePerformIO
03:28:18 <dv_> for example, see this: http://upload.wikimedia.org/wikipedia/commons/9/96/Schneckenwelle.png   now add a "* x" to one of of the lengths, and the specification becomes a function f(x) whose result is the entire thing
03:28:31 * dv_ looks into FieldTrip and diagrams
03:28:43 <dolio> Well, anything could launch missiles if unsafePerformIO is around.
03:28:59 <mm_freak> main :: RealWorld -> RealWorld
03:29:01 <beelsebob> dolio: really? surely only the thing inside the unsafePerformIO could
03:29:08 <beelsebob> and return $ 5 doesn't look so likely to do that
03:29:24 <mm_freak> main w = execIO myApp w
03:29:34 <dolio> Well, yeah, but anything could be using unsafePerformIO without your knowledge.
03:29:34 <beelsebob> mm_freak: main :: Behavior RealWorld
03:29:34 <beelsebob> dolio: ?
03:29:38 <dmwit> beelsebob: But how do you know what values have unsafePerformIO inside?
03:29:45 <beelsebob> that's kinda my point
03:29:52 <mm_freak> beelsebob: i've yet to grok FRP
03:30:04 <beelsebob> that to the same extent that I can verify 5 is a referentially transparent computation
03:30:10 <dolio> Like "fromJust m = unsafePerformIO launchMissiles `seq` maybe (error "Nothing") id m
03:30:12 <beelsebob> I can also verify that unsafePerformIO . return $ 5 is
03:30:21 <ddarius> Actually, 5 may not be a referenttially transparent computation...
03:30:27 <beelsebob> ddarius: exactly
03:30:35 <beelsebob> so I get *exactly* the same guarentees
03:30:42 <ddarius> What, none?
03:30:47 <beelsebob> yes
03:31:00 <beelsebob> I can verify by hand that unsafePerformIO is safe in that situation
03:31:02 <ddarius> My real emphasis was on the latter part of my original statement.
03:31:06 <beelsebob> or a least as safe as a pure computation
03:31:13 <beelsebob> "pure"
03:31:51 <crashit> here is mine prob if someone want to help!!    i wanna to get one line from file and parse it than,if is matched to put it in another file but i am not sure does it this good? >   main :: IO ()
03:31:51 <crashit> main = do wholeFile <- readFile "C:\\codes.txt"
03:31:51 <crashit> 	  let theLines = lines wholeFile
03:31:51 <crashit> 	      numsNlines = zip [0 ..] (map runIt theLines)
03:31:51 <crashit> 	      succeededNumsNLines = filter goodChars numsNlines--
03:31:53 <crashit> 	      nonFailed (_,"Failed") = False
03:31:55 <crashit> 	      nonFailed (_,_       ) = True
03:31:57 <crashit> 	      sucTry    (_,""   ) = True
03:31:59 <crashit> 	      sucTry    (_,_       ) = False
03:32:01 <crashit> 	      goodChars (_,s) = all goodChar s
03:32:03 <crashit> 	      goodChar c = c `elem` "-^af!&*s%" || isDigit c
03:32:05 <crashit> 	  writeFile "c:\\find.txt" (unlines (map show succeededNumsNLines))
03:32:06 <beelsebob> crashit: I'd suggest finding a pastebin if you want help
03:32:11 <beelsebob> and stopping spamming the channel
03:32:23 <beelsebob> I'd recommend hpaste.org
03:36:36 <crashit> http://hpaste.org/13600#a0
03:37:15 <pumpkin> removed the credits this time? :P
03:38:14 <crashit> :p
03:38:23 <crashit> its harder to findit
03:38:33 <beelsebob> it looks good crashit, although I'd write goodChar as goodChar = (`elem` "-^af!&*s%") <^(||)^> isDigit
03:38:45 <pk> what does the :+-> mean in a type declaration ?
03:38:48 <beelsebob> and I'd move the bulk of the work out of main
03:38:58 <beelsebob> so you don't have to do it in the gigantic let block
03:39:23 <beelsebob> and the parsers I would write in applicative style, not monadic
03:39:38 <crashit> to make that and to remove let block
03:42:04 <crashit> i am not sure does parsers work good because i only need to fix them and to get return success
03:44:28 <beelsebob> something like this... http://hpaste.org/13600#a1
03:44:54 <beelsebob> oops, got a type sig wrong
03:45:14 <beelsebob> I'm sure you can fix that
03:45:54 <IWannaLog> @type all
03:45:55 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
03:50:01 <Peaker> mm_freak: FRP is merely expressing dynamism as a combination of varying inputs, as well as input events - rather than using destructive writes/callbacks
03:50:15 <enticingjelly> yay. the interpreter i'm writing for a small functional language now has monadic IO.
03:50:56 <mm_freak> Peaker: i know, but i can't find useful examples
03:51:52 <mm_freak> most tutorials describe how to make those expressions, but up to now i don't even know how to use them with real data
03:51:52 <Peaker> mm_freak: Look at the Phooey examples in HaskellWiki
03:51:56 <crashit> beelsebob: i dont get it??what did u want to tell?
03:52:17 <beelsebob> crashit: I wanted to show you how to tidy up your code a chunk
03:52:29 <pumpkin> crashit: is the challenge to produce something that the program you pasted will accept?
03:52:57 <crashit> goodChar = (`elem` "-^af!&*s%") <^(||)^> isDigit > say undefined variable
03:53:10 <beelsebob> add the appropriate import then ;)
03:53:19 <beelsebob> it's in Control.Applicative.Infix
03:53:39 <mm_freak> Peaker: thanks
03:55:52 <kalven> how is the <^(||)^>-operator pronounced?
03:55:57 <Peaker> mm_freak: no problem.. I really like the calculator there
03:56:03 <pumpkin> kalven: batoperator
03:56:55 <jberryman> that's a real thing??
03:57:24 <Peaker> beelsebob: did you see the (~>) stuff?
03:57:41 <beelsebob> kalven: it's pronounced "liftA2 (||)"
03:57:49 <EvilTerran> kalven, i'd probably pronounce it "liftA2 or"
03:57:58 <beelsebob> yeh, what EvilTerran said
03:58:04 <kalven> thanks
03:58:06 <EvilTerran> seeing as (||) is "or" and x <^f^> y = liftA2 f x y
03:58:29 <mpwd> :t or
03:58:31 <lambdabot> [Bool] -> Bool
03:58:38 <beelsebob> damn you mpwd
03:58:39 <beelsebob> :P
03:59:18 <EvilTerran> i said {(||) is "or"}, not {(||) = or}, for that very reason :P
04:00:45 <mpwd> @src liftA2
04:00:45 <lambdabot> liftA2 f a b = f <$> a <*> b
04:01:24 <mpwd> :t (<$>)
04:01:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:01:40 <EvilTerran> ?src (<$>)
04:01:40 <lambdabot> f <$> a = fmap f a
04:02:00 <pumpkin> ?src (<*>)
04:02:01 <lambdabot> Source not found. Just what do you think you're doing Dave?
04:02:07 <EvilTerran> <*> is a typeclass method
04:02:09 <mpwd> All this is right associative, correct?
04:02:11 <pumpkin> ah
04:02:13 <EvilTerran> ?src [] (<*>)
04:02:13 <lambdabot> (<*>) = ap
04:02:18 <EvilTerran> mpwd, left
04:02:19 <pumpkin> I see :)
04:02:26 <mpwd> :t (<*>)
04:02:27 <EvilTerran> f <$> x <*> y = (f <$> x) <*> y
04:02:27 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
04:02:33 <EvilTerran> like f x y = (f x) y
04:02:47 <mpwd> EvilTerran: Hmm... that goes against my religion I think...
04:02:49 <beelsebob> it would be nice if liftA2 was written in the more currying like style
04:02:57 * IWannaLog thinks there are too many operators in world.
04:03:00 <beelsebob> liftA2 f x y = pure f <*> x <*> y
04:03:11 <pumpkin> IWannaLog: no such thing as too many :)
04:03:13 <EvilTerran> mpwd, er, okay...
04:03:31 <beelsebob> IWannaLog: that's why I started inventing meta-operators that create more operators :D
04:03:42 * IWannaLog remembers the time where only + * / - exits.
04:03:52 <pumpkin> IWannaLog: when was that?
04:03:54 <mpwd> EvilTerran: Well, just recall in the type system that -> is right associative, and that in symbolic logic everything is right associative.
04:04:04 <beelsebob> pumpkin: 12AD
04:04:11 <IWannaLog> When i developped in Basic
04:04:14 <BONUS> kindergarden
04:04:19 <pumpkin> lol
04:04:29 <pumpkin> IWannaLog: you remember that time with nostalgia or hate?
04:04:35 <pumpkin> I'd be inclined to say the latter :P
04:04:48 <IWannaLog> nostalgia, there where not alias of alias of alias of function
04:04:52 <beelsebob> I'd be inclined to have an urge to kick people who say nostalgia
04:05:09 <pumpkin> IWannaLog: define operator then :P
04:05:17 <mm_freak> Peaker: a very interesting library, but unfortunately it doesn't teach me FRP, it just uses FRP internally =/
04:05:22 <pumpkin> and what you think should be an operator
04:05:24 <IWannaLog> a operator b (infix notation)
04:05:41 <mm_freak> isn't there a simple Reactive example?
04:05:43 <Peaker> mm_freak: it shows how FRP is applied to "real data"
04:05:59 <IWannaLog> and something which uses symbols other than letters so you read you don't understand it
04:06:02 <Peaker> mm_freak: its not exactly used only "internally", see the use of "accum" there
04:06:14 <pumpkin> IWannaLog: there aren't that many, really
04:06:22 <IWannaLog> <*>
04:06:30 <IWannaLog> <$>
04:06:39 <IWannaLog> (||)
04:06:45 <IWannaLog> three operators I don't know
04:06:48 <IWannaLog> damned
04:06:54 <Peaker> IWannaLog: there often is an English name and "operator name". Surely you know ||
04:07:03 <mpwd> IWannaLog: (||) is just "or" from C
04:07:08 <IWannaLog> i prefer "or" and "and"
04:07:16 <beelsebob> > True || False
04:07:17 <lambdabot>   True
04:07:20 <mpwd> It has a brother "and" (&&)
04:07:26 <beelsebob> > or [True, True, False, False, True]
04:07:26 <bremner> > True or False
04:07:28 <lambdabot>   True
04:07:28 <lambdabot>   Couldn't match expected type `([Bool] -> Bool) -> Bool -> t'
04:07:34 <mm_freak> Peaker: i'd like a purer introduction into Reactive
04:07:37 <Peaker> IWannaLog: operators are more readable than words, once you know them well
04:07:38 <pumpkin> <$>, <*>, >>>, <<<, &&&, ***, >>=, =<<, >>, ||, &&, ==, >=, <=, **, ^^, >, <, +, -, /, *, ^ are the common ones I can think of
04:07:53 <pumpkin> in no particular order
04:07:54 <mm_freak> define a few behaviours and see them in action
04:07:57 <mm_freak> in a real program
04:08:01 <mm_freak> not some theoretical source code
04:08:06 <Peaker> mm_freak: Reactive by itself is not usable, you need adapters to IO.  Reactive-glut and Reactive-fieldtrip, for example
04:08:11 <icqnumber> > :type head
04:08:11 <deadlyx> :t (<$>)
04:08:12 <lambdabot>   <no location info>: parse error on input `:'
04:08:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:08:27 <pumpkin> did I miss any common ones?
04:08:29 <beelsebob> Peaker: it's usable – just not for producing programs that run in time
04:08:31 <IWannaLog> Peaker: I find words more readable than operators known by only 1000 people in earth
04:08:38 <mm_freak> Peaker: then what i actually want to know is how to write those adapters myself
04:08:39 <mpwd> pumpkin: Some enjoy (!!), but people should know that lists aren't arrays.
04:08:43 <beelsebob> you can create programs that reason about time based effects without adapters for example
04:09:00 <pumpkin> IWannaLog: I've been learning haskell for a couple of weeks now, and know the ones I've listed above off the top of my head :P
04:09:05 <pumpkin> IWannaLog: seriously, it isn't that bad :)
04:09:06 <beelsebob> mm_freak: look at the reactive-glut source code then
04:09:07 <beelsebob>  :)
04:09:13 <pumpkin> mpwd: oh yeah, I never use that one
04:09:13 <IWannaLog> pumpkin: Good for you.
04:09:35 <pumpkin> IWannaLog: my point isn't that I'm brilliant :P
04:09:40 <mpwd> pumpkin: You shouldn't.  It is O(n)
04:09:46 <mm_freak> beelsebob: good point =)
04:09:48 <pumpkin> mpwd: yeah, that's why I stay away from it :)
04:11:41 <mpwd> pumpkin: Data.Set uses some funny infix operations.
04:11:58 <mpwd> (\\)
04:12:00 <pumpkin> oh I forgot \\
04:12:05 <pumpkin> yeah, lists have that too
04:12:16 <mpwd> Orly?
04:12:24 <pumpkin> there's also :, obviously
04:12:27 <mpwd> > [1,2] \\ [2]
04:12:28 <lambdabot>   [1]
04:12:35 <mpwd> Sweet
04:12:40 <michie1> good-day.  Haskell noobie heer, I'm looking for a constant that's the maximum value for all doubles (i.e. like C has MAXINT for integers)
04:12:44 <pumpkin> as inefficient as you'd expect :)
04:12:44 <mm_freak> sometimes i confuse \\ and //
04:12:46 <pumpkin> @src (\\)
04:12:46 <lambdabot> (\\) = foldl (flip delete)
04:13:06 <IWannaLog> :t flip
04:13:07 <mm_freak> > maxBound :: Double
04:13:08 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
04:13:08 <lambdabot>       No instance for (Bounded Double)
04:13:08 <lambdabot>        arising from a use of `maxBound...
04:13:09 <pumpkin> O(nm) I guess in the lengths
04:13:15 <mm_freak> > maxDouble
04:13:17 <lambdabot>   Not in scope: `maxDouble'
04:13:31 <michie1> (tried 'infinity' from the Bird book, but that doesn't particularly seem to work)
04:13:43 <michie1> mm_freak: hmm, so no such constant is defined?
04:13:49 <pumpkin> > maxF :: Double
04:13:50 <lambdabot>   Not in scope: `maxF'
04:14:13 <pumpkin> boo :) I'd be wrong anyway
04:15:22 <mm_freak> michie1: seems like no
04:15:44 <IWannaLog> @src Double
04:15:44 <lambdabot> data Double = D# Double#
04:15:47 <mm_freak> > floatRange 10
04:15:48 <lambdabot>   (-1021,1024)
04:15:57 <mm_freak> > floatRange (10 :: Float)
04:15:57 <IWannaLog> ?instances Double
04:15:59 <lambdabot> Couldn't find class `Double'. Try @instances-importing
04:15:59 <lambdabot>   (-125,128)
04:16:03 <mm_freak> > floatRange (10 :: Double)
04:16:05 <lambdabot>   (-1021,1024)
04:16:26 <michie1> okay, thanks
04:16:44 <mm_freak> well, seems like the exponent can be as large as 1024
04:16:50 <IWannaLog> How can we ask to lambdabot which classes are implemented by a type ?
04:16:58 <mm_freak> which gives you some hint as to how large a Double can get
04:17:46 <mm_freak> :i Double
04:17:47 <pumpkin> IWannaLog: don't think it supports that
04:17:53 <michie1> mm_freak: yeah, the input for the function reasonably won't get much larger than 1000000 or so, so I can just use an arbitrarily larger value.  I just wanted to do it the proper way
04:17:53 <IWannaLog> :(
04:18:13 <mm_freak> michie1: does it _need_ to be a floating type?
04:18:22 <mpwd> pumpkin: Is lambdabot open source?
04:18:30 <pumpkin> certainly!
04:18:34 <IWannaLog> maybe you can try u_(n+1) = 2 * u_n + 1
04:18:36 <pumpkin> @where lambdabot
04:18:37 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
04:18:37 <michie1> mm_freak: actually, I'm looking for a currency type, but I couldn't find one
04:18:40 <IWannaLog> until you reach the limit
04:18:44 <mercury^> There is a Rational type, which supports arbitrary rational numbers.
04:18:55 <michie1> mercury^: hey, that's true
04:19:02 <mm_freak> michie1: for currencies, floating types with base 2 (including Float and Double) are highly inappropriate
04:19:02 <michie1> that's probably a better choice
04:19:03 <IWannaLog> mpwd: yes it's open source
04:19:10 <mm_freak> you can't even represent 0.1 with them exactly
04:19:23 <mm_freak> > length [0.0, 0.1 .. 1]
04:19:25 <lambdabot>   11
04:19:30 <mm_freak> uhm
04:19:39 <michie1> mm_freak: true.  It's not a production application, I'm just trying out if I could write a function in Haskell
04:19:45 <mm_freak> > last [0.0, 0.1 .. 1]
04:19:46 <michie1> mm_freak: (and am sort of glad it compiles)
04:19:47 <lambdabot>   0.9999999999999999
04:19:53 <IWannaLog> Isn't there a Decimal type in Haskell ?
04:19:57 <pumpkin> CReal
04:20:01 <pumpkin> > 0.1 :: CReal
04:20:02 <lambdabot>   0.1
04:20:06 <pumpkin> that was an awesome demo
04:20:08 * pumpkin bows
04:20:22 <mm_freak> > floatRadix (0.1 :: CReal)
04:20:24 <lambdabot>   * Exception: CCeal.floatRadix
04:20:32 <mm_freak> @src CReal
04:20:33 <lambdabot> Source not found. Are you on drugs?
04:20:35 <pumpkin> fail typeclasses
04:20:36 <IWannaLog> @src CReal
04:20:37 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
04:20:47 <ivanm> mm_freak: you want the source of a data structure?
04:20:50 <pumpkin> > showCReal 50 pi
04:20:52 <lambdabot>   "3.14159265358979323846264338327950288419716939937511"
04:20:54 <sbahra> IWannaLog, on hackage, yes
04:20:58 <IWannaLog> What is CReal ?
04:21:06 <pumpkin> IWannaLog: arbitrary precision decimal
04:21:07 <dolio> newtype CReal = CReal (Int -> Integer)
04:21:10 <mm_freak> michie1: well, for values as small as 1000000, just use Double
04:21:12 <mercury^> @hoogle creal
04:21:12 <lambdabot> No results found
04:21:13 <IWannaLog> Yes it's good
04:21:14 <mm_freak> even Float would suffice
04:21:15 <dolio> Or something like that.
04:21:18 <ivanm> IWannaLog: what do you refer to as a "decimal type"?
04:21:21 <mm_freak> > 1000000 :: Float
04:21:23 <lambdabot>   1000000.0
04:21:27 <pumpkin> dolio: does that mean it can only support maxBound :: Int digits?
04:21:30 <pumpkin> :(
04:21:34 <pumpkin> oh wait
04:21:37 <pumpkin> no it doesn't
04:21:39 <IWannaLog> It use the functionality of the processor ? (I remember x86 know number in base 10)
04:21:40 <dolio> pumpkin: No.
04:21:59 <pumpkin> IWannaLog: I think it's in pure haskell
04:22:10 <mm_freak> ivanm: sure, why not?
04:22:13 <mm_freak> @src Maybe
04:22:16 <IWannaLog> pumpkin: :) we must write one in C
04:22:29 <dolio> pumpkin: It means you can get an approximation that's accurate to within B^-(maxBound :: Int)
04:22:29 <lambdabot> data Maybe a = Nothing | Just a
04:22:29 <ivanm> @src Maybe
04:22:29 <lambdabot> data Maybe a = Nothing | Just a
04:22:29 <dolio> Where B is whatever the base is (probably 2).
04:22:31 <ivanm> *shrug* fair enough
04:22:32 <pumpkin> dolio: I see
04:22:35 <ivanm> @src Either
04:22:35 <lambdabot> Source not found. There are some things that I just don't know.
04:22:36 <IWannaLog> ivanm: decimal type is something written in base 10
04:22:43 <IWannaLog> like human used
04:22:44 <dolio> pumpkin: Or something along those lines.
04:22:47 <pumpkin> IWannaLog: no, we're moving away from c! I want pure haskell :)
04:23:00 <ivanm> IWannaLog: ummmmmm...... isn't that extremely inefficient?
04:23:04 <ivanm> in terms of storage, etc.
04:23:23 <Peaker> mm_freak: then look at those adapters
04:23:24 <IWannaLog> ivanm: no base is better than another
04:23:35 <pumpkin> IWannaLog: it is when you have a native representation
04:23:38 <ivanm> IWannaLog: the base of the computer is more efficient
04:23:39 <mm_freak> ivanm: a floating type in base 10 takes _less_ storage, but is slower
04:23:40 <pumpkin> and they are relatively prime
04:23:42 <IWannaLog> we got base 2 computer so there is a loss with base 10
04:24:00 <ivanm> mm_freak: oh? don't you need four bits IIRC just for each decimal place?
04:24:18 <ivanm> IWannaLog: which was my point...
04:24:31 <mm_freak> ivanm: no, a floating number is represented as m * b^e, where m is the mantissa, b is the base and e is the exponent
04:24:33 <IWannaLog> but it's just space you lost, not time
04:24:42 <mm_freak> e serves to 'move the decimal point'
04:24:47 <mm_freak> hence "floating point"
04:24:56 <ivanm> mm_freak: well, for each digit you need four bits, do you not?
04:24:58 <mm_freak> uhm, the point, not the decimal point =)
04:25:04 <ivanm> if you want to truly store it as a base-10 number
04:25:05 <mm_freak> it's just decimal, if b = 10, obviously
04:25:21 <IWannaLog> To count money decimal is great
04:25:29 <mm_freak> ivanm: for each decimal digit you need 3.32 bits, but that's independent of the base
04:25:40 <bremner> IWannaLog: use integers for money
04:25:48 <IWannaLog> no Decimal,
04:25:54 <ivanm> mm_freak: yes, but we don't store them as decimal digits... we just use conversions
04:26:04 <ivanm> IWannaLog: how is it any better?
04:26:10 <ivanm> you don't use it any differently....
04:26:12 <mm_freak> ivanm: we store them in dual in either case
04:26:13 <IWannaLog> I could use two integers (one for the number and one for the exposant of 10)
04:26:34 <IWannaLog> But I don't use haskell when I work for banks
04:26:38 <IWannaLog> :)
04:26:38 <ivanm> all that will make a difference is numbers that aren't directly encodable in base 2 but are encodable in base 10
04:26:39 <mm_freak> the base of a floating point number doesn't change its radix of representation, it just changes the base of the point
04:27:07 <IWannaLog> ivanm: but you got a great gain when you want to display them to a human (no conversion needed)
04:27:08 <mm_freak> that's enough to allow encoding of values like 0.1 as dual numbers
04:27:14 <ivanm> mm_freak: surely it changes how you represent it...
04:27:32 <mm_freak> 0.1 = 1 * 10^(-1)
04:27:32 <ivanm> IWannaLog: at a loss of precision/increase of space
04:27:42 <mm_freak> you still save 1 and (-1) in base 2
04:27:45 <sbahra> @hoogle (Ord a) => [a] -> M.Map a
04:27:45 <lambdabot> Parse error:
04:27:45 <lambdabot>   --count=20 "(Ord a) => [a] -> M.Map a"
04:27:45 <lambdabot>                                 ^
04:27:53 <ivanm> mm_freak: besides, normally you use "intelligent" printing to do that rounding for you
04:27:57 <sbahra> @hoogle (Ord a) => [a] -> Data.Map.Map a
04:27:58 <lambdabot> Parse error:
04:27:58 <lambdabot>   --count=20 "(Ord a) => [a] -> Data.Map.Map a"
04:27:58 <lambdabot>                                    ^
04:28:13 <sbahra> owellfkit
04:28:19 <IWannaLog> ivanm: when you deal with money you deals with base 10 (and bankers are rich :) they could buy big computer)
04:28:30 <ivanm> that reminds me... I just read in RWH that lookup in Data.Map now uses Maybe rather than any monad... why is that?
04:28:30 <mercury^> sbahra: fromList
04:28:30 <mercury^> or fromAscList
04:28:30 <mercury^> or any other variant
04:28:43 <sbahra> mercury^, nah, something else
04:28:49 <mm_freak> ivanm: you change the representation (the value of mantissa and exponent), but you don't change the radix of representation
04:28:52 <ivanm> IWannaLog: rich tight-wads ;-)
04:28:54 <sbahra> mercury^, i mean i have it implemented just checking there isn't a library function for it
04:28:55 <mm_freak> the numbers are still saved in base 2
04:29:03 <ivanm> mm_freak: sorry, yes
04:29:35 <IWannaLog> And when user uses an application they don't understant precision problems (they think in base 10, so the computer must do)
04:29:36 <ivanm> but for decimal representations, don't you use precisely 4 bits for each digit, rather than the 3.32 you mentioned?
04:29:44 <ivanm> @go binary coded decimals
04:29:53 <mm_freak> i wonder if it's possible/feasible to represent numbers as polynomial roots =)
04:29:55 <lambdabot> http://en.wikipedia.org/wiki/Binary-coded_decimal
04:29:55 <lambdabot> Title: Binary-coded decimal - Wikipedia, the free encyclopedia
04:29:57 <IWannaLog> Are we computer's slaves ? Or are computer our slaves ?
04:30:01 * ivanm seems to recall learning this in data structures/algorithms
04:30:09 <mm_freak> ivanm: you use 4 bits in either case
04:30:14 <ivanm> mm_freak: IIRC, that's one approach used/proposed for arbitrary precision
04:30:20 <mm_freak> because you can't save 3.32 bits ;)
04:30:33 <ivanm> mm_freak: no, because with base 2 we don't reserve 4 bits _just_ for one decimal digit...
04:30:53 <mm_freak> but for two decimal digits, you don't need 8 bits, but only 7 (ceiling 6.64) bits, again in either case
04:30:54 <ivanm> i.e. in bcd form (which I'm talking about), 10 == 00010000
04:31:09 <IWannaLog> You could use 0.68 for error detection
04:31:12 <ivanm> rather than 1010 which we use with standard binary
04:31:19 <mm_freak> BCD isn't a floating type
04:31:41 <ivanm> mm_freak: well, that's what I thought IWannaLog was talking about... >_>
04:31:51 <IWannaLog> The BCD ? Yes.
04:32:00 <mm_freak> BCD is something completely different and usually not used anymore these days
04:32:07 <IWannaLog> But I don't remember what we can do with it.
04:32:13 <mm_freak> you would use some fixed point type like Integer
04:32:25 <ivanm> mm_freak: "usually"? you mean someone still uses that for any real reason (teaching/legacy doesn't count)?
04:32:44 <IWannaLog> Did someone know how .net Decimal type works ?
04:32:45 <mm_freak> ivanm: it may be used in some embedded systems
04:33:04 <ivanm> mm_freak: hmmm..... maybe....
04:33:12 <ivanm> IWannaLog: what differentiates it from Float/Double?
04:33:17 <Martijn> @pl \xss -> f xss `max` f (transpose xss)
04:33:18 <lambdabot> liftM2 max f (f . transpose)
04:33:18 <mm_freak> although there is really no reason other than fast display =)
04:33:24 <IWannaLog> ivanm: base 10
04:33:28 <Gracenotes> @hoogle Monad m => (a -> b) -> m a -> m b
04:33:28 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
04:33:28 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
04:33:28 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
04:33:28 <ivanm> mm_freak: it "makes more sense"
04:33:34 <ivanm> IWannaLog: encoding or representation?
04:33:41 <IWannaLog> they write on their site (crosoft) that it's for financial application
04:33:49 <mm_freak> but many embedded systems don't feature division/modulo, so there is really some reason to use BCD
04:33:59 <beelsebob> lambdabot needs to be told to use liftA2 there, for added generality
04:34:34 <IWannaLog> Decimal are encoded without BCD and like "floating integer"
04:34:37 <dolio> Get patching. :)
04:34:46 <beelsebob> hehe
04:34:53 <dolio> While you're at it, teach her to use uncurry more often.
04:35:06 <dolio> (And curry)
04:35:13 <ivanm> IWannaLog: my guess is that it uses a standard float/double (probably the latter), but just does pretty-printing etc. to "guess" the proper representation
04:35:24 <IWannaLog> ivanm: it's that
04:35:39 <ivanm> well, in that case it's not that hard/difficult
04:35:49 <IWannaLog> So BCD is useless.
04:35:57 <mm_freak> IWannaLog: my guess is they are simply integers
04:36:07 <ivanm> a lot of languages (python, java, etc.) do that kind of pretty-printing by default when "printing" values (as opposed to String representation)
04:36:17 <mm_freak> data Decimal = Decimal Integer Int
04:36:19 <bauchus> hi! I'm using fastcgi+takusen/pgsql and it works great. But is it safe to compile with -threaded and use runFastCGIConcurrent? (All my shared datas are stored in MVars and each thread uses its own connection with takusen). Would it be better to use (runFastCGIConcurrent' forkIO) instead of runFastCGIConcurrent, which uses forkOS?
04:36:23 <IWannaLog> I found a website where they say there are 128bits data with 102 for mantiss
04:36:26 <sbahra> :t liftA2
04:36:27 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
04:36:29 <sbahra> :t liftA
04:36:30 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
04:36:44 <mm_freak> or they are indeed floating point numbers in base 10
04:37:22 <IWannaLog> no sorry 102 bits, with 96 for the mantissa
04:37:35 <mm_freak> IWannaLog: in which base?
04:37:39 <IWannaLog> and 5 for the exponent
04:37:49 <IWannaLog> in base 10 like it's name Decimal
04:38:19 <mm_freak> 5 for the exponent?  that's a bit spare =)
04:38:42 <ivanm> mm_freak: just a different Show instance is my guess ;-)
04:39:00 <mm_freak> ivanm: ?
04:39:44 <ivanm> mm_freak: data Decimal = Decimal Double deriving (Eq,Ord), but having a specified Show instance where the number is pretty-printed to make it look more "normal"
04:39:48 <ivanm> > 0.1
04:39:49 <lambdabot>   0.1
04:39:56 <ivanm> hmmm...... Haskell seems to do it already
04:40:01 <IWannaLog> ivanm: it's cheat
04:40:10 <Martijn> @pl max<$>g<*>g.transpose
04:40:10 <lambdabot> (line 1, column 12):
04:40:10 <lambdabot> unexpected "."
04:40:10 <lambdabot> expecting letter or digit, variable, "(", "!!", white space, operator, "<*", "*>", "<$>", "<$", "<**>", "==", "/=", "<", "<=", ">=", ">", "`elem`", "`notElem`" or end of input
04:40:10 <lambdabot> ambiguous use of a right associative operator
04:40:15 <ivanm> (if you type "0.1" into a python prompt for example, it will do something like 0.1000000001)
04:40:38 <Martijn> @pl max <$> g <*> g . transpose
04:40:38 <lambdabot> (line 1, column 17):
04:40:38 <lambdabot> unexpected "."
04:40:38 <lambdabot> expecting variable, "(", "!!", space, operator, "<*", "*>", "<$>", "<$", "<**>", "==", "/=", "<", "<=", ">=", ">", "`elem`", "`notElem`" or end of input
04:40:38 <lambdabot> ambiguous use of a right associative operator
04:40:48 <ivanm> Martijn: try brackets ;-)
04:41:04 * Martijn is trying to solve http://codegolf.com/grid-computing in Haskell
04:41:28 <mm_freak> ivanm: what would be the point of it?  you don't need that, since you've got other means of pretty-printing
04:41:51 <ivanm> mm_freak: well, AFAICT from what IWannaLog is saying, that's all it is
04:42:08 <mm_freak> how can you tell?
04:42:18 <IWannaLog> AFAICT ? What's that ?
04:42:22 <ivanm> mm_freak: my interpretation ;-)
04:42:27 <ivanm> AFAICT: as far as I can tell
04:42:35 <ivanm> wtf++ ;-)
04:42:35 <mm_freak> ok =)
04:42:36 <IWannaLog> thx
04:43:12 <pumpkin> wow Text.CSV is epicly slow
04:43:15 <ivanm> mm_freak: then again, for a project I'm working on, the lead coder chose to call his real number datatype "Decimal" (despite it being math-oriented) >_>
04:43:38 <ivanm> pumpkin: well, we can't blame the long module name bug for that... ;-)
04:43:39 <sbahra> pumpkin, why aren't you using bytestring-csv?
04:43:47 <sbahra> Oh, you are
04:43:48 <pumpkin> sbahra: because it doesn't output CSV
04:43:49 <mm_freak> ivanm: what's wrong with that?  is it floating point in base 2?
04:43:55 <sbahra> nm, you arne't
04:44:08 <IWannaLog> so it's not a decimal
04:44:10 <pumpkin> sbahra: I used it to parse a CSV, but I'm using the normal string one to write one out
04:44:24 <sbahra> ya
04:44:29 <sbahra> sucks :(
04:44:30 <ivanm> mm_freak: it's a wrapper around Java's BigDecimal type, actually.... but it's representing real numbers, so why call it Decimal? *shrug*
04:44:38 <ivanm> @wn decimal
04:44:49 <lambdabot> *** "decimal" wn "WordNet (r) 2.0"
04:44:49 <lambdabot> decimal
04:44:49 <lambdabot>      adj 1: numbered or proceeding by tens; based on ten; "the decimal
04:44:49 <lambdabot>             system" [syn: {denary}]
04:44:49 <lambdabot>      2: divided by tens or hundreds; "a decimal fraction"; "decimal
04:44:49 <ivanm> isn't @wn the dictionary lookup plugin?
04:44:51 <lambdabot> [4 @more lines]
04:44:54 <mm_freak> ivanm: because calling it Real would be inappropriate
04:44:56 <ivanm> oh, it is... lambdabot is just slow tonight
04:45:01 <ivanm> mm_freak: why?
04:45:09 <pumpkin> because it can only represent rationals? :P
04:45:18 <ivanm> pumpkin: rationals are a subset of the reals...
04:45:19 <mm_freak> ivanm: consider that you can't represent real numbers discretely in memory
04:45:43 <ivanm> mm_freak: true..... but for the purposes of the project that's beside the point
04:45:52 <pumpkin> mm_freak: you could say that pi :: CReal is actually pi couldn't you?
04:46:02 <ivanm> since we use it to create math expression trees
04:46:16 <mm_freak> good, but being math-oriented means to give things appropriate names
04:46:20 <ivanm> pumpkin: only as long as you don't print the result ;-)
04:46:26 <pumpkin> ivanm: yeah :)
04:46:31 <ivanm> mm_freak: which in this case is Real ;-)
04:46:37 <pumpkin> it's like saying a certain infinite primes list is all the primes
04:46:47 <mm_freak> pumpkin: you can
04:47:04 <sbahra> induction sucks
04:47:11 <ivanm> sbahra: why?
04:47:16 <pumpkin> so call it ComputableReal
04:47:30 <pumpkin> is that what C stands for in CReal?
04:47:35 <ivanm> pumpkin: yeah
04:47:39 <pumpkin> ah :)
04:47:46 <pumpkin> I'm good at rediscovering the obvious
04:48:24 <dolio> I used to be very confused when I thought it was one of the types out of CTypes or whatever.
04:48:31 <ivanm> but in the case of this project, it's used to represent a real number in a calculation
04:48:35 <sbahra> ivanm, because deduction is better, when as long as you aren't reasoning about complex structures
04:48:37 <dolio> I was wondering why the C compatibility type for floats had so much precision.
04:48:47 <pumpkin> sbahra: bah, it only outputs CSV of strings :/ so everything is surrounded by quotes
04:49:00 <ivanm> and since it uses Java's BigDecimal class, it _isn't_ just a subset (since IIRC BigDecimal isn't limited to computable reals)
04:49:05 <sbahra> pumpkin, ?
04:49:16 <sbahra> pumpkin, how are you converting to string?
04:49:16 <pumpkin> sbahra: the String-based Text.CSV
04:49:22 <sbahra> Oh
04:49:46 <Martijn> What's the shortest definition of transpose you guys know of? Assume rectangular input.
04:49:54 <pumpkin> I guess I could sed out all the quotes
04:50:03 <pumpkin> Martijn: I saw a beautiful one in scheme once :P
04:50:05 <IWannaLog> Martijn: In which context ?
04:50:06 <sbahra> pumpkin, maybe you should write a patch to support printing CSV in bytestring-csv
04:50:10 <pumpkin> I'm sure it could be applied to haskell
04:50:10 <Martijn> In Haskell
04:50:17 <dolio> @type foldr (zipWith (:)) (repeat [])
04:50:18 <lambdabot> forall a. [[a]] -> [[a]]
04:50:24 <sbahra> pumpkin, if you don't do it, I'll do it after some much needed sleep
04:50:35 <dolio> > foldr (zipWith (:)) (repeat []) [[1,2,3],[4,5,6],[7,8,9]]
04:50:37 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
04:50:37 <pumpkin> sbahra: you're telling me :P it's almost 8 am
04:50:46 <sbahra> I don't know what time it is here
04:50:46 <pumpkin> dolio: that's pretty elegant :)
04:50:54 <scook0> that's frightening
04:50:56 <sbahra> but it has been > 28 hours for sure
04:51:03 <pumpkin> sbahra: how easy is it to update a hackage package?
04:51:05 <Martijn> dolio: Now if that one turns out to be shorter than import Data.List and then writing transpose, I've saved another few bytes :-P
04:51:07 <pumpkin> (I don't have an account there yet)
04:51:15 <dolio> :)
04:51:27 <sbahra> pumpkin, took 1 day for me to get an account, updating your own packages is a very easy process
04:51:44 <pumpkin> sbahra: I guess I should just contact the author of bytestring-csv
04:51:45 <scook0> once you have the tarball ready, uploading a package is pretty much instantaneous
04:51:50 <mm_freak> > length "import Data.List\ntranspose"
04:51:52 <lambdabot>   26
04:51:56 <sbahra> pumpkin, dons
04:52:00 <mm_freak> > length "foldr (zipWith (:)) (repeat [])"
04:52:00 <pumpkin> ah :)
04:52:02 <lambdabot>   31
04:52:12 <sbahra> pumpkin, darcs makes it easy 4 u to send the patch
04:52:14 <mm_freak> Martijn: use Data.List ;)
04:52:27 <mm_freak> likely you'll need other functions from it anyway =)
04:52:31 <Martijn> dolio: It's longer, sadly.
04:52:33 <dolio> Martijn: It's slightly different than Data.List.transpose. But not on rectangles, I think.
04:52:39 <pumpkin> sbahra: trying to decide a good way to do it though that doesn't assume all fields are strings :/
04:52:50 * sbahra looks
04:53:05 <Martijn> dolio: That's fine, rectangular input is good enough. But importing Data.List is shorter
04:53:18 <dolio> > map length ["import Data.Listtranspose","foldr(zipWith(:))(repeat[])"]
04:53:20 <lambdabot>   [25,27]
04:53:22 <dolio> Oh well.
04:53:34 <pumpkin> sbahra: I found a beautiful way! I'm filtering out all quote characters :P
04:53:41 <sbahra> nod
04:53:44 <mm_freak> dolio: don't forget \n
04:53:53 <sbahra> but thinking about making formatting sexy
04:53:58 <Martijn> mm_freak: no, transpose is the only one I need :-)
04:54:07 <sbahra> you do not need quotes for a lot of cases, need to escape some chars but that's easy
04:54:11 <sbahra> @hoogle printf
04:54:12 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
04:54:12 <lambdabot> module Text.Printf
04:54:12 <lambdabot> package printf-mauke
04:54:15 <pumpkin> sbahra: seems like Field should really be a ByteString | Int Integer | Double Double or something
04:54:17 <mm_freak> Martijn: are you participating in a shortest-code contest or something? ;)
04:54:30 <Martijn> mm_freak: yes: http://codegolf.com/grid-computing
04:54:42 <Martijn> mm_freak: I have a 131 byte solution now.
04:54:45 <sbahra> pumpkin, slow
04:54:57 <Martijn> mm_freak: Make that 130
04:54:59 <pumpkin> Martijn: that site annoys me, last I looked they only support a couple of languages
04:55:01 <sbahra> pumpkin, i think he meant for bytestring-csv to be rly fast
04:55:08 <pumpkin> sbahra: I guess :/
04:55:14 <Martijn> pumpkin: I know, it's sad they don't support Haskell
04:55:34 <sbahra> pumpkin, problem is also that with csv data is not guaranteed to be regular
04:55:40 <pumpkin> sbahra: true :/
04:55:51 <sbahra> pumpkin, so some general specificiers wont cut it
04:56:13 <pumpkin> so make an existential (Show a) wrapper thing?
04:56:18 <pumpkin> and beautifully slow
04:56:21 <sbahra> fuck strings
04:56:22 <sbahra> haha
04:56:32 <pumpkin> :)
04:57:01 <Martijn> 108 now. hmm.
04:57:07 <sbahra> ye,formatting will obviously just make things terribly slow
04:57:30 <sbahra> pumpkin, might as well do as you said, just strip quotes and escape from the bytestring
04:57:36 <scook0> Martijn: at what point does it become easier to use brute-force search? ;)
04:57:46 <pumpkin> sbahra: feels really ugly though :)
04:58:01 <Martijn> scook0: Ease is not the point here :-P
04:58:10 <mm_freak> Martijn: haskell has never been designed to produce incredibly short code…  it does create shorter codes for larger problems though
04:58:18 <sbahra> pumpkin, why?
04:58:20 <mm_freak> and it creates more elegant code for this particular problem =)
04:58:26 <sbahra> pumpkin, another interface could be provided for formatting
04:58:31 <Martijn> mm_freak: I know, but that doesn't help right now
04:58:34 <pumpkin> sbahra: I guess, yeah
04:59:06 <sbahra> a trivial one is going to have to be there anyways for people who are looking for performance
04:59:14 <pumpkin> sbahra: does bytestring-csv load the entire file into memory before parsing it?
04:59:38 <sbahra> doubtful
04:59:41 <sbahra> let me see
05:00:14 <pumpkin> I guess it just takes a strict bytestring
05:00:18 <pumpkin> which you needed to have loaded yourself
05:00:28 <pumpkin> doesn't that mean it does need to be in memory?
05:00:39 <Martijn> import Data.List
05:00:40 <Martijn> main=interact$show.(\x->g x`max`(g.transpose)x).map(map read.words).lines
05:00:40 <Martijn> g=maximum.map sum
05:00:45 <Martijn> mm_freak: That one will have to do.
05:01:17 <sbahra> pumpkin, yes
05:02:25 <mm_freak> Martijn: module Main where
05:02:41 <sbahra> pumpkin, why?
05:02:53 <pumpkin> sbahra: large CSV files :P
05:02:55 <mm_freak> i'm afraid, you can't beat the others
05:03:00 <Martijn> mm_freak: That doesn't seem to be necessary, at least not in GHC 6.10
05:03:26 <mm_freak> Martijn: indeed, sorry
05:03:31 <mm_freak> i always thought it's necessary
05:03:34 <Axman6> > read "123" :: Double
05:03:36 <lambdabot>   123.0
05:03:51 <icqnumber> how to find out the working directory in ghci? there is no :pwd
05:03:51 <sbahra> pumpkin, eh, it's time VM was used properly ;p
05:03:55 <Martijn> mm_freak: I'm so glad for defaulting now :-P
05:04:07 <pumpkin> sbahra: eww :P
05:04:10 <pumpkin> :!pwd
05:04:18 <icqnumber> pumpkin, thank you
05:04:49 <pumpkin> icqnumber: :! will just execute any shell command :)
05:05:30 <sbahra> pumpkin, how large is the CSV file you are generating?
05:05:31 <icqnumber> yep i figured that out after you told me about :!pwd :-P
05:05:45 <pumpkin> sbahra: it's 200 megs and still going :P not sure how big it'll be :)
05:05:49 <sbahra> wow
05:05:56 <sbahra> pumpkin, what kind of data?
05:06:02 <pumpkin> it's a 7500 x 3255 matrix
05:06:04 <pumpkin> of doubles
05:06:09 <sbahra> for?
05:06:28 <pumpkin> oh, machine learning
05:06:40 <pumpkin> learning activity patterns from sensor data
05:06:53 <sbahra> I see
05:07:03 <sbahra> pumpkin, if you're interested
05:07:27 <mm_freak> > repeat[]
05:07:28 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
05:07:30 <pumpkin> this is mostly because I need to exchange data back and forth between my haskell program and matlab
05:07:33 <sbahra> pumpkin, I've been looking for a person who isn't as noob as I am in Haskell to work with on MMX/SSE-optimized computational (with support for general vector computations) library
05:07:35 <mm_freak> > fix([]:)
05:07:37 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
05:07:46 <mm_freak> > fix$[]:
05:07:56 <sbahra> pumpkin, sort of like blas but heavily haskellified
05:07:56 <lambdabot>   <no location info>: parse error on input `;'
05:07:56 <pumpkin> sbahra: ooh :o
05:07:56 <sbahra> pumpkin, I can do all the MD stuff pretty well
05:07:59 <icqnumber> so :cd  bla and :!cd bla do the same thing, right?
05:08:09 <pumpkin> sbahra: MD?
05:08:10 <sbahra> pumpkin, but I don't have too much faith in my design skills with haskell (yet)
05:08:15 <sbahra> pumpkin, machine-dependent
05:08:19 <pumpkin> ah I see
05:08:23 <EvilTerran> icqnumber, the latter may well not do anything
05:08:41 <pumpkin> sbahra: I warn you that I've only been using haskell since the beginning of december
05:08:45 <EvilTerran> icqnumber, as the effect of the cd may be restricted to the shell subprocess that runs it
05:08:57 <sbahra> pumpkin, mmorrow would hopefully jump on board later to rescue us
05:08:58 <pumpkin> sbahra: so I wouldn't trust my haskell design skills that much either :P
05:09:04 <sbahra> pumpkin, so it'd be a good learning experience
05:09:17 <pumpkin> sbahra: it does sound interesting
05:09:24 <pumpkin> and would be helpful for my work too, hmm
05:09:28 <icqnumber> EvilTerran, thank you, good to know
05:09:34 <pumpkin> maybe when the upcoming paper deadline has passed
05:09:42 <pumpkin> (whether or not I submit something to it is another question)
05:09:46 <sbahra> cool
05:09:51 <pumpkin> that'd be near the end of this month
05:09:55 <pumpkin> but yeah, I'm interested :)
05:10:02 <mm_freak> > sequence [[1,2,3],[4,5,6],[7,8,9]]
05:10:04 <lambdabot>   [[1,4,7],[1,4,8],[1,4,9],[1,5,7],[1,5,8],[1,5,9],[1,6,7],[1,6,8],[1,6,9],[2...
05:10:08 <sbahra> as long as we can start working on it
05:10:17 <EvilTerran> icqnumber, :!cd doesn't do anything on my ghci install, anyway
05:11:06 <sbahra> EvilTerran, ghc probably calls system()/fork->exec
05:11:14 <icqnumber> EvilTerran, it does on mine
05:11:16 <sbahra> I would imagine ;p
05:11:20 <sbahra> icqnumber, what os?
05:11:25 <pumpkin> sbahra: how are you going to approach it? writing actual assembly, or calling some thin SIMD library?
05:11:32 <icqnumber> sbahra, ubuntu
05:11:33 <sbahra> pumpkin, writing assembly
05:11:47 <EvilTerran> sbahra, i figured, hence my guessing earlier that it wouldn't do anything
05:11:47 <sbahra> pumpkin, pipeline optimizations make a huge difference
05:11:51 <pumpkin> sbahra: yeah :)
05:11:58 <pumpkin> sbahra: I've used the veclib on mac os a fair amount
05:12:11 <pumpkin> if you wrote a similar API we could use veclib on os x and be ppc-compatible too :P
05:12:22 <pumpkin> but ppc is on its way out, I guess
05:12:27 <pumpkin> so it's not that exciting
05:12:29 <sbahra> do you own a ppc box?
05:12:32 <pumpkin> (on os x, anyway)
05:12:34 <mm_freak> ah, forget fix, you need Data.Function for that =/
05:12:35 <sbahra> i'd love to learn more about pcc personally
05:12:37 <pumpkin> sbahra: I have an old powerbook g4
05:12:40 <sbahra> i do own one
05:12:42 <icqnumber> sbahra, why was you asking?
05:12:45 <pumpkin> but I never use it anymore
05:13:00 <pumpkin> the computers I use are all intel
05:13:04 <pumpkin> unless you consider my iphone :P
05:13:12 <sbahra> i try to diversify
05:13:24 <pumpkin> (which actually has a few SIMD instructions too)
05:13:36 <sbahra> pumpkin, but our vector library would be a "thin library" anyways due to FFI stuff
05:13:41 <pumpkin> sbahra: yeah :)
05:13:48 <sbahra> pumpkin, mmorrow considered using harpy for this
05:13:48 <pumpkin> I'm all for it
05:14:00 <sbahra> pumpkin, but I'm not sure how runtime code gen works for it exactly
05:14:26 <pumpkin> does it support mmx/sse-*?
05:14:40 <sbahra> from the code i read at the time, no
05:15:23 <pumpkin> (my .csv is 300 megs now :P big data, and gives you an idea of how slow Text.CSV is)
05:15:46 <sbahra> my reasoning, anyways, is that the asm portion of this project should be valuable stand-alone, too
05:16:00 <sbahra> using harpy kind of, erm, limits the scope
05:16:20 <pumpkin> yeah
05:16:31 <pumpkin> I really like mac os's veclib but it isn't open source
05:16:37 <pumpkin> which limits me to mac os if I use it
05:16:46 <sbahra> pumpkin, http://carte.kerneled.org/benchmark_mmx.c http://carte.kerneled.org/mmx.h http://carte.kerneled.org/mmx.S
05:16:49 <pumpkin> libvdsp and so on
05:16:52 <sbahra> pumpkin, compile with -m32
05:17:13 <Gracenotes> hm... so I kind of get value-based dispatch and type-based dispatch, but how are they related? Could both exist at the same time?
05:17:37 <icqnumber> EvilTerran, well :!cd seems to work like :cd and i was abled to load a hs file, after setting the folder with :!cd...
05:18:41 <EvilTerran> icqnumber, interesting
05:19:09 <icqnumber> EvilTerran, can not you reproduce?
05:19:57 <EvilTerran> ghci> :!cd
05:19:58 <EvilTerran> C:\
05:19:58 <EvilTerran> ghci> :!cd windows
05:19:58 <EvilTerran> ghci> :!cd
05:19:58 <EvilTerran> C:\
05:20:04 <EvilTerran> ie, nope
05:20:25 <pumpkin> sbahra: sorry, my computer's rather strained right now (the app is using 800 megs of RAM :( ) I'll try it a bit later :)
05:20:32 <EvilTerran> but dropping the ! from the ":!cd windows" works
05:20:55 <mm_freak> Martijn: have you considered using squiggol?
05:21:07 <mm_freak> it could help making your program shorter
05:21:32 <icqnumber> EvilTerran, well it is because cd windows will not work in your windows terminal too, i guess
05:21:33 <sbahra> pumpkin, cool
05:21:43 <sbahra> pumpkin, wasnt expecting you to run it now ;p
05:21:50 <pumpkin> sbahra: where did you get all this asm experience? you don't find many people who can actually write significant things in it these days :P
05:22:08 <mm_freak> write the list functions from scratch, write your program, apply squiggol transformations, finally recognize predefined functions and replace them in your code
05:22:23 <icqnumber> EvilTerran, or cmd or what ever it is called
05:22:29 <Peaker> pumpkin: all of us who learned software back in the bad old DOS days ... :-)
05:23:06 <idnar> I learned almost all the ASM I know by reverse-engineering stuff with a debugger / disassembler
05:23:37 <mreh> does anyone know if there is a group discussing solutions to RWH exercises
05:23:39 <sbahra> pumpkin, a lot do
05:23:41 <pumpkin> idnar: same :)
05:23:46 <sbahra> pumpkin, just not in communities like these usually ;p
05:23:56 <mreh> or do you mind if i post some here
05:23:59 <sbahra> pumpkin, but im obsessed with all aspects of operating system design and implementation, basically
05:24:07 <pumpkin> ah I see :)
05:24:22 <pumpkin> yeah, most of my experience with asm is "reading" it :P
05:24:23 <sbahra> pumpkin, and before that, spent a good amount of time reverse-engineering/etc...
05:24:31 <idnar> at one point in time, I did write a simple RTS using Direct3D in ASM
05:24:45 <idnar> it was rather depressing how much easier it was than writing C/C++ code
05:24:49 <sbahra> haha
05:24:55 <rgr> a RTS using D3d? Huh?
05:25:20 <Peaker> sbahra: do you know EROS-OS and Coyotos' design?
05:25:20 <mreh> idnar : you're nuts
05:25:20 <sbahra> Peaker, no
05:25:31 <idnar> rgr: might have been DirectDraw, actually, I can't remember if DirectDraw was still around back then
05:25:32 <rgr> idnar: I dont believe you to be honest.
05:25:34 <Peaker> sbahra: more interesting OS designs than Unix-like
05:25:39 <icqnumber> EvilTerran, was i right?
05:25:51 <rgr> Unless your C compiler was from the Ark :-;
05:26:08 <rgr> What was RTS about it?
05:26:27 <idnar> rgr: RTS as in Real-Time Strategy game
05:26:53 <int-e> idnar: in these parts, RTS means 'run time system' :)
05:26:57 <rgr> ah, then I believe you. But I refuse to believe you found it easier in ASM than in C unless you are the worlds worst C programmer.
05:27:06 <EvilTerran> icqnumber, no, it would've worked fine in a command prompt window
05:27:12 <rgr> or Real Time System ...
05:27:31 <int-e> rgr: not so much on #haskell, I think.
05:27:34 <Axman6> or Run Time Stratergy
05:27:35 <Axman6> >_>
05:27:44 <idnar> rgr: well, this was x86 assembly, I'm not sure I'd still feel that way about other architectures
05:27:46 <pumpkin> or Real True Statement
05:27:50 <Axman6> -r
05:27:50 <EvilTerran> icqnumber, it's because the directory-changing happens to the subprocess the :! is running in, not the ghci process
05:27:57 <pumpkin> idnar: ARM is so much prettier :)
05:28:00 <sbahra> Peaker, seems interesting, but there's more interesting in industry or in research from industry
05:28:07 <rgr> I assumed x86. I did a lot of it back then. But dont tell me it was eaiser than in C.
05:28:12 <sbahra> Peaker, and yes, not claiming unix or unix-like to be the holy grail
05:28:24 <EvilTerran> icqnumber, the same happens in C, say, if you do system("cd ...")
05:28:33 <idnar> rgr: *shrug* maybe I'm just crazy
05:28:42 <rgr> About one in a million programmers can wrote better asm then a good C compiler can create these days too.
05:28:58 <idnar> rgr: nobody said anything about *better* asm
05:29:07 <sbahra> Peaker, but it would be really cool once they actually are making headway in formally verifying this
05:29:09 <rgr> idnar: or just fooled yourself :-; It is not easier to write an RTS in asm than in C. Ever. Period. EOS ....
05:29:10 <idnar> it was probably completely awful ASM
05:29:20 <idnar> I just find it a lot easier crafting x86 ASM than C code
05:29:45 <rgr> then you are an awful C programmer since in C you can write "asm like code" but also have the higher level.
05:29:46 <idnar> not that I'd want to write a significant amount of code in either
05:29:51 <pumpkin> Ever. Period. EOS
05:29:55 <pumpkin> that's pretty final
05:29:57 <idnar> rgr: you can't, though, the language gets in the way
05:30:17 <rgr> rubbish. YOu can insert asm sections if you want.
05:30:27 <idnar> that's not writing C code, then :P
05:30:29 <sbahra> No need to get so worked up rgr.
05:30:35 <sbahra> We're all nice people here ;-p
05:30:38 <rgr> (all said with a smile on my face)
05:30:42 <sbahra> haha
05:30:58 <rgr> no its C with asm sections. Still not "all in asm".
05:31:14 <idnar> admittedly, I had a large heap of macros in my ASM code
05:31:17 <pumpkin> granted, the gcc (only one I know) inline asm format is rather obscure :)
05:31:25 <rgr> idnar: I think you're taking the mickey here.
05:31:49 <sbahra> pumpkin, yeah
05:31:50 <pumpkin> rgr: you're pretty worked up about this :o
05:31:54 <idnar> rgr: I'm being deadly serious, although I don't necessarily expect anyone else to feel the same way about it
05:31:57 <sbahra> pumpkin, it's nice
05:31:58 <rgr> worked up`? Not al all.
05:32:04 <sbahra> pumpkin, erm, in some ways :/
05:32:23 <sbahra> oh
05:32:26 <rgr> I just simply do not believe its easier to write a RTS in asm than it is in C for anyone whatsoever that has a modicum of C.
05:32:33 <pumpkin> sbahra: I didn't like it when I tried :) I ended up writing a separate object in asm and linking to it
05:32:34 <sbahra> this is a really cool gcc extension i found out about today
05:32:43 <Axman6> http://abstrusegoose.com/98
05:33:20 <rgr> Especially one that has interfaces to D3D.
05:33:23 <pumpkin> bah, my csv is 600 megs
05:33:23 <idnar> rgr: the main thing is that everything is so long-winded in C
05:33:33 <Peaker> pumpkin: what is the data in there?
05:33:35 <rgr> idnar: ok, you are taking the mickey.
05:33:45 <Peaker> rgr: what is "taking the mickey"?
05:33:59 <rgr> taking the piss. having a laugh, Making a joke.
05:34:10 <pumpkin> Peaker: a bunch of computed features on an 8-sensor stream from a portable sensing device :)
05:34:11 <sbahra> pumpkin, http://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html
05:34:15 <idnar> rgr: for example, x86 assembly has all sorts of looping constructs; C basically has one
05:34:15 <rgr> I never in all my years heard of C as "long winded".
05:34:25 <pumpkin> sbahra: oh I remember coming across that
05:34:32 <sbahra> very cool
05:34:34 <Peaker> pumpkin: use a binary serialization then?
05:34:49 <JS`> can someone explain to me how to make a .tar.gz?
05:34:53 <rgr> idnar: what? C optimises your code down to the best asm equivalent.
05:35:02 <pumpkin> Peaker: the main reason I'm writing this out is to load it into matlab... I can't get the matlab on hackage to work, so have been using CSV
05:35:03 <koeien> JS`: tar zcf filename.tar.gz directory/
05:35:06 <pumpkin> but this is the biggest one so far
05:35:06 <idnar> rgr: I'm not talking about optimisation, I'm talking about writing code
05:35:15 <JS`> on windows
05:35:15 <sbahra> rgr, not to the "best"
05:35:25 <sbahra> rgr, believe it or not, C is very difficult to optimize.
05:35:46 <sbahra> rgr, restrict qualifier will help.
05:35:47 <koeien> JS`: no idea. 7-zip?
05:35:48 <idnar> rgr: I have absolutely no doubt that a modern C compiler will generate much nicer ASM than I could write by hand
05:35:53 <rgr> I have used many C systems and the optimizers have all been very, very good. Even the linux kernel only uses asm when it really needs to.
05:35:55 <icqnumber> EvilTerran, it seems not the case on my gnu/linux box ghci seems to do the same with :cd and :!cd
05:36:09 <sbahra> rgr, but still a lot of cases where it cannot (compared to say something pure, like Haskell).
05:36:17 <sbahra> rgr, what "C systems"?
05:36:17 <scook0> a C compiler will generate output that is *probably* better than the ASM you would have written, most of the time
05:36:20 <rgr> idnar: then yoiu must think of code in strange ways. Still, all to their own.
05:36:29 <rgr> scook0: of course.
05:36:34 <sbahra> rgr, the Linux kernel uses C rather gratuitously.
05:36:44 <rgr> Sure.
05:36:45 <sbahra> err
05:36:46 <sbahra> Assembly.
05:36:46 <rgr> ....
05:36:49 <sbahra> :)
05:36:49 <Peaker> I think the optimization considerations in modern CPU's have become so complicated that neither compilers nor humans optimize properly! :)
05:37:02 <Peaker> (And focus have shifted elsewhere over the years, too)
05:37:03 <sbahra> rgr, compare the level of MD in Linux to let's say, FreeBSD or NetBSD.
05:37:09 <rgr> Peaker: no. It means compilers can do a better job most of the times.
05:37:33 <sbahra> It depends on the kind of optimizations
05:37:37 <pumpkin> whee, my final csv is 618 megs :)
05:37:38 <Peaker> rgr: in theory, yes, but in practice they miss a lot of the nuances too
05:37:42 <sbahra> and the size of the code/problem, rgr
05:38:05 <rgr> But my point remains. By thinking of things like "while(i--)" in C this optimizes to things like carry or sign checks in asm. I dont agree with idnar one little bit here with regard to writing an RTS interfacing to D3D.
05:38:11 <sbahra> I'm pretty sure I can beat a 20 line C program with hand-written assembly.
05:38:15 <rgr> Peaker: did I say they were perfect?
05:38:27 <Axman6> is reduce in python like foldl/r?
05:38:34 <pumpkin> rgr: what's there to agree with? he stated he did it
05:38:35 <Peaker> rgr: for example, someone got a 20% boost in CPython's performance by separating the (JMP opcodetable[nextopcode]) into a separate JMP for each opcode handler
05:38:35 * Axman6 guesses foldl
05:38:38 <rgr> sbahra: I would bet you could not. And many people have tried and failed.
05:38:43 <sbahra> Peaker, yeah
05:38:46 <idnar> while (i--) is just LOOP
05:38:49 <rgr> sbahra: actually Itake that back since I dont know you.
05:38:54 <sbahra> Peaker, that's where I learned about that labels as values extension. Did you look at it?
05:39:08 <sbahra> rgr, I'll bet you $1000 I can. :-)
05:39:09 <rgr> idnar: for goodness sake I was using thatr as the enclosure to some functionality.
05:39:13 <sbahra> rgr, atleast on x86.
05:39:17 <pumpkin> rgr: I've written several things faster in asm than c (granted, for ARM, which my gcc didn't seem to deal with very well)
05:39:30 <Peaker> sbahra: nope, I didn't look at the patch..  my friend told me about the ugliness in there :)
05:39:34 <sbahra> Peaker, very cool extension
05:39:38 <sbahra> Peaker, nah, talking about the gcc extension
05:39:45 <rgr> yes, yes, yes. It *IS* possible. But lets not start encouraging people to think that most or even a small % can.
05:39:49 <sbahra> Peaker, http://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html
05:39:51 <pumpkin> Axman6: yes :)
05:39:57 <mux> it's hard to optimize well for x86, nearly each new cpu changes the relative cost of instructions
05:39:57 <Axman6> thweet :)
05:39:59 <idnar> anyhow, nowadays, I wouldn't consider writing a game in either language
05:40:05 <Peaker> sbahra: I know the extension from a few days ago, yeah. Weird that C didn't originally have it
05:40:07 <rgr> Hand written asm is really for strong ASM programmers.
05:40:16 <sbahra> mux, yes :/
05:40:24 <mux> back when I learnt asm, rep foo instructions were fast
05:40:28 <Axman6> i'm following this, and i'm going to try and convert it to haskell: http://lethain.com/entry/2009/jan/02/genetic-algorithms-cool-name-damn-simple/
05:40:34 <rgr> gah.
05:40:38 <sbahra> mux, they still are incredibly fast for string operations
05:40:56 <rgr> do you think these things get lost by the C optimizer?
05:40:56 <mux> but slower than just doing the job by "hand" with several instructions
05:41:27 <sbahra> no way, not for larger data
05:41:30 * Badger chuckles at the idea of writing a game in asm
05:41:32 <pumpkin> rgr: a lot of the vector stuff isn't very good in gcc, at least (and on ARM, doesn't exist :P)
05:41:38 <sbahra> assuming you take into account alignment
05:41:56 <rgr> idnar: C/C++ are still the main languages for games and game engines. There is no way anyone would write a RTS in asm interfacing to D3D unless they were clueless about C IMO.
05:42:06 <Axman6> Badger: you scoff now, but back in the day, it was the hip thing to do!
05:42:13 <mux> sbahra: for instances REPZ MOVSB is very suboptimal for string copies these days
05:42:16 <Axman6> that day being before i was 10 (9 years ago)
05:42:24 <rgr> Axman6: I wrote 68000 games and Z80 games. I had no C compiler!
05:42:27 <pumpkin> Axman6: back when you were a young'un
05:42:27 <idnar> rgr: I know they're the main languages, but I'd far rather use Python or Haskell or something
05:42:34 <rgr> idnar: What???????
05:42:40 <Axman6> pumpkin: what are you implying : O
05:43:06 * rgr wonders if its April 1st and I overslept.
05:43:06 <p_l> I'd use Haskell or Lisp....
05:43:06 <pumpkin> Axman6: that you were a young'un when yo uwere 10?
05:43:06 <sbahra> mux, I would not use movsb for large data.
05:43:06 <idnar> rgr: we're in #haskell, is this really that surprising? :P
05:43:09 * bremner keeps going 'foldr (++) [] (map f xs)'  Is there some some more idiomatic way to do it?
05:43:13 <rgr> I'd use eLisp ....
05:43:21 <Axman6> pumpkin: yeah... damn straight
05:43:24 <sbahra> mux, so i didn't take it into account when measuring performance (it was trivial)
05:43:30 <mux> sbahra: my point is that what's the fastest way inevitably changes with new CPUs
05:43:32 <sbahra> mux, similar loop structure to the bcopy implementation on FreeBSD
05:43:39 <pumpkin> @src concatMap
05:43:39 <lambdabot> concatMap f = foldr ((++) . f) []
05:43:40 <Axman6> bremner: concatMap
05:43:42 <sbahra> mux, it's pretty much rep, will be for a while
05:43:50 <mux> and that knowledge is best secured in a compiler
05:43:56 * Axman6 beelsebob'd pumpkin!
05:43:59 <idnar> rgr: I've written a bunch of OpenGL code in Python (haven't really touched DirectX since I moved away from Windows)
05:44:08 <pumpkin> Axman6: I haven't learnt that verb yet :o
05:44:14 <sbahra> mux, I've heard some people @FBSD claim MMX/SSE copies are faster. I haven't found a case where this has been it
05:44:22 <mux> sbahra: they are
05:44:24 <sbahra> mux, well, for the general case, I agree
05:44:26 <idnar> haven't done anything in that direction with Haskell yet, but give it time...
05:44:32 <sbahra> mux, give me a test case to verify this. :)
05:44:36 <mux> but this is just an example anyway
05:44:36 <Axman6> pumpkin: the number of times beelsebob will say something just before i say the exact same thing is more than a little scary
05:44:37 <bremner> Axman6: thanks
05:44:43 <sbahra> mux, I saw improvements when copying huge amounts of memory
05:44:43 <idnar> FRP seems like an attractive way to write a game
05:44:51 <mux> sbahra: these days, SSE-based memcpy() are the fastest
05:45:00 <sbahra> mux, otherwise, rep movsd severely out-performed it
05:45:01 <pumpkin> Axman6: oh, it showed up as you coming first on your side? on my client I said it first, but we're only a second apart
05:45:13 <sbahra> mux, maybe it was just the CPUs I tried this on
05:45:18 <Axman6> pumpkin: yeah mine was first here
05:45:22 <mux> if they are too old this won't be the case of course
05:45:27 <Axman6> knowing my luck, you did say it first too :\
05:45:28 <sbahra> mux, I took into account cache btw
05:45:33 <pumpkin> Axman6: epic lag between us and freenode
05:45:33 <sbahra> mux, these are recent CPUs
05:45:35 <pumpkin> :)
05:45:42 <Axman6> indeed
05:46:10 * mux wonders if someone is working on putting GHC's runtime in a separate shared library
05:46:10 <pumpkin> Axman6: not sure if my client responds to pings... is it working?
05:46:17 <Axman6> oh god, i don't know what the output of the ping command is saying!
05:46:21 <Axman6> yeah
05:46:26 <Axman6> 00:46 [freenode] CTCP PONG reply from pumpkin: 1231076759 394449
05:46:30 <pumpkin> Badger: you're badgering me!
05:46:46 <Badger> CTCP PONG reply from pumpkin: 1231076782 950843
05:46:48 <Axman6> first thing must be the time it was sent or something
05:46:48 <Badger> certainly not
05:46:56 <pumpkin> Axman6: yeah, looks like a unix time
05:46:59 <pumpkin> the other one must be the diff
05:47:03 <sbahra> mux, for smaller copies, too much overhead compared to rep mov. And on most machines sse copy performed well when memory being copied was massive (relative to L2 cache)
05:47:06 <pumpkin> probably means .4 of a second?
05:47:12 <Axman6> maybe
05:47:17 <pumpkin> Badger: that's almost a second I'd guess :o
05:47:25 <sbahra> mux, which memcpy implementation are you talking about? I would be interested in taking a look at it.
05:47:29 <sbahra> Maybe the one I wrote just sucked
05:47:31 <Badger> you are one internet second away :P
05:48:02 <int-e> oh. pumpkin's client is sending PONG replies instead of PING replies. That's silly.
05:48:02 <pumpkin> Badger: where are you? outside my door??
05:48:03 <mux> sbahra: I'm more talking about what I think is common knowledge - I am not that interested in the specifics and I've never researched that stuff myself :-)
05:48:16 <sbahra> mux, it is common misknowledge
05:48:23 <pumpkin> int-e: blame the developers of this POS :P
05:48:28 <pumpkin> I only use it cause I know one of them
05:48:35 <pumpkin> but he doesn't seem to care about it anymore
05:48:36 <int-e> pumpkin: I wasn't blaming anybody :)
05:48:36 <sbahra> mux, people just assume that wider copy = better performance
05:48:42 <mux> sbahra: I've read many people stating otherwise, which only proves my point further: optimization is complicated
05:48:49 <sbahra> mux, for general case, it really is bad. I would love to be proven otherwise.
05:48:58 <sbahra> mux, agreed ;p
05:49:07 <Badger> pumpkin: window, actually
05:49:11 <mux> sbahra: IIRC, the Linux kernel does runtime benchmarks on memcpy() implementations at init
05:49:14 <Phyx-> Hello, i dunno in which channel i should ask this, but, i'm getting some problems trying to compile dlls in 6.10 http://phyx.pastebin.com/d65b7998e
05:49:15 <pumpkin> Badger: ?
05:49:23 <Badger> < pumpkin> Badger: where are you? outside my door??
05:49:29 <mux> sbahra: and it'll likely select a SSE-based one on recent boxes
05:49:36 <pumpkin> Badger: oh, yeah :)
05:50:01 <pumpkin> mux: sounds like we need input from wli
05:50:02 <pumpkin> :P
05:51:11 <sbahra> mux, nah
05:52:38 <sbahra> mux, i'll give it a shot, I'll be using arch/x86/lib/mmx_32.c
05:53:05 <mux> don't just copy 8 bytes :-)
05:53:33 * sbahra didn't realize he was an idiot
05:53:50 <sbahra> http://mail-index.netbsd.org/tech-perform/2002/10/16/0000.html is interesting too
05:53:51 <mux> maybe that's because you're not one?
05:54:04 <pumpkin> sbahra: happens to the best of us
05:54:10 <sbahra> I didn't make use of prefetching in my implementation, which could've been the problem :)
05:54:18 <sbahra> pumpkin, I was being sarcastic in response to "don't just copy 8 bytes"
05:54:26 <pumpkin> yeah, I know :) I was joining in
05:56:28 <Axman6> http://www.apple.com/downloads/dashboard/developer/retroforth.html heh, awesomeness
05:56:49 <BrokenClockwork> Hey, any reasons why Hugs is so slow compared to ghci?
05:57:06 <BrokenClockwork> It's kind of annoying, because I miss the copy&paste function in GCHi
05:57:09 <koeien> ghci compiles to bytecode. no idea about hugs
05:57:19 <koeien> it's been a while since I used hugs
05:57:20 <pumpkin> BrokenClockwork: hugs is kinda inactive isn't it?
05:57:30 <BrokenClockwork> 2006 last development
05:57:34 <mux> people still use hugs?
05:57:57 <mux> I think too much toturials refer to hugs
05:58:06 <BrokenClockwork> hah okay I see, in fact I don't need copy&paste as there is the do construct
05:58:10 <EvilTerran> ghci supports copy-and-paste if your terminal does
05:58:17 <BrokenClockwork> then I will kick Hugs fro my HDD :)
05:58:37 <BrokenClockwork> then this is Windows fault
05:58:50 <EvilTerran> cmd.exe supports copy-and-paste...
05:58:52 <sbahra> ah, found a nice benchmark
05:58:54 <BrokenClockwork> also when the new windows terminal actually supports copy&paste, mh
05:58:57 * mux tempted to ask "people still use windows?" :-)
05:59:34 <EvilTerran> mux, some of us like to play games on our PCs
05:59:34 <scodil> what happened to completion in ghci with 6.10? Can libedit just not do it?
05:59:49 <Axman6> scodil: works fine for me
06:00:06 <mux> EvilTerran: yeah, you know I was just kidding
06:00:15 <scodil> Axman6: wtf. so you do like "zipWi<TAB>" and you get zipWith?
06:00:26 <mux> scodil: no problems here either
06:00:28 * EvilTerran refers to this as "the wintendo defense"
06:00:32 <scodil> this is crap
06:00:40 <Axman6> scodil: yep
06:00:41 <scodil> why isn't mine working
06:00:42 <BrokenClockwork> well it's okay, I will finally install ubuntu on my notebook as soon as I have it ^^
06:00:50 <Phyx-> so does anyone have any idea how i can solve my problem? since they seem to be coming from base
06:01:21 <sbahra> mux, yup, prefetching :-/
06:01:23 <scodil> Axman6. mux: do you have to put something special in your .inputrc or whatever libedit calls it?
06:01:26 <sbahra> mux, big difference
06:01:34 <Axman6> nope
06:01:43 <Axman6> well, not that i know of, i don't remember doing so
06:02:17 <Axman6> anyway, i'm off to bed. night all
06:02:22 <mux> the GHCi history is now even persistent across several runs, which is so handy
06:02:30 <Axman6> yeah
06:02:41 <sbahra> mux, for aligned memory rep is severely outperforming
06:02:42 <Axman6> i hated having to kill ghci, only to lose all my let'd code
06:02:47 <scodil> oh ok its cause i _do_ have an .editrc.  If I rename it, then completion works. So something in there is mucking it up
06:02:48 <sbahra> which was my only test case
06:02:59 <sbahra> I'll post the results in a sec
06:03:04 <dolio> EvilTerran: I use windows for games, but I don't use it for Haskell programming (or much of anything else, really). :)
06:04:14 <mux> sbahra: has someone been working on GHC 6.10.1 for FreeBSD btw?
06:04:43 <sbahra> I've been meaning to look at it after I'm back in the US.
06:05:23 <koeien> is there no more CTRL+R in GHC 6.10.1 interactive? or is this because 6.8.2 (distro provided) compiled against readline ?
06:05:32 <EvilTerran> dolio, i use windows for games, and prefer to not have to restart into fedora whenever i want to do anything else
06:05:35 <EvilTerran> (although i could)
06:05:51 <pumpkin> koeien: doesn't exist for me
06:05:52 <dolio> That is a pain, yes.
06:06:07 <koeien> pumpkin: ok :( it's very useful
06:06:10 <mux> to be perfectly honest, I do have windows, although in a VM only
06:06:14 <sbahra> mux, note over-all libc memcpy performance (using rep): http://carte.kerneled.org/speed.results
06:06:46 <Martijn> koeien: create ~/.editrc and write:
06:06:46 <Martijn> edit on
06:06:46 <Martijn> bind ^R em-inc-search-prev
06:06:59 <koeien> Martijn: thanks
06:07:05 <Martijn> koeien: geen probleem
06:07:21 <koeien> that worked
06:07:25 <Peaker> EvilTerran: VMWare, CoLinux?
06:07:26 <sbahra> This is a T7300, I'll give it a shot on an AMD box.
06:07:56 <mux> sbahra: seems like MMX is winning here?
06:08:00 <sbahra> mux, have you looked at it, BTW, by any chance (GHC 6.10.1 on FreeBSD)?
06:08:03 <sbahra> mux, keep scrolling :-)
06:08:05 <pumpkin> how does libc's memcpy work so much better on larger chunks?
06:08:25 <Phyx-> ok... has anyone here ever sucessfully compiled dll from ghc?
06:08:27 <mux> I don't even remember how the libc memcpy() is implemented
06:08:38 <sbahra> mux, this is an active box, so cache is pretty much fubared. This could be ruining prefetching. Going to retry on some other machines
06:08:41 <sbahra> mux, rep movs*
06:08:56 <EvilTerran> Peaker, i've got a nice little suite of windows programs that serve my purposes, i very rarely have to boot over to linux to do things
06:09:45 <Peaker> EvilTerran: why do you hate Richard Stallman? :-)
06:09:57 <mux> because he's a twit?
06:10:18 <pumpkin> he has a twitter account?
06:10:22 <pumpkin> ;)
06:10:28 <sbahra> mux, going to put down the results, I'll contact you once their up. Going to try on more recent AMD/Intel
06:10:39 <pejo> sbahra, the NetBSD people have made more recent fixes than the one from 2002 that you linked to iirc.
06:10:42 <mux> sbahra: if you want to try on a Core i7 tell me :)
06:10:57 <Peaker> libc's memcpy is a large function
06:11:03 <sbahra> mux, http://carte.kerneled.org/speed.c
06:11:19 <sbahra> pejo, ok, I'll take a look at their changes too.
06:15:05 <sbahra> mux, out of curiosity, do you have a 7.X box?
06:15:37 * sbahra only has 6.X and -CURRENT ;-p
06:15:51 <sbahra> Which is an issue for GHC builds.
06:18:31 <mux> sbahra: yes
06:18:40 <sbahra> cool
06:20:27 <Phyx-> @version
06:20:27 <lambdabot> lambdabot 4.2.2
06:20:27 <lambdabot> darcs get http://code.haskell.org/lambdabot
06:20:33 <Phyx-> @ghc version
06:20:33 <lambdabot> ghc says: panic! (the `impossible' happened, GHC version 6.4)
06:21:15 <EvilTerran> Peaker, that's a dangerous question to ask, i might never shut up :P
06:22:14 <Phyx-> does anyone know when 6.10.2 will be out, my problem is exactly this http://hackage.haskell.org/trac/ghc/ticket/2745. so -shared is broken. but i need it to continue
06:28:11 <bauchus> \quit
06:28:14 <pumpkin> Phyx-: you could just build the latest?
06:29:49 <scodil> whats up with the Data.Array.Parallel API? Kind of a mess, isn't it?
06:29:56 <Phyx-> pumpkin: compilation under windows requires alot of work doesn't it. and would require me to install among other cygwin/msys
06:30:20 <Phyx-> msys doesn't behave correctly here. infact it tries to spawn an unlimited number of windows
06:30:42 <mauke> I am the bone of my window
06:42:49 * EvilTerran discovers gratuitous use of System.Posix in the files provided for the practical he's doing
06:42:54 * EvilTerran wades in to remove them
06:48:44 <eu-prleu-peupeu> hello H4skleZ0rs
06:49:35 <shapr> y0
06:49:53 <eu-prleu-peupeu> whats up shapr ? :)
06:50:02 <shapr> Just coding, what's up with you?
06:50:39 <eu-prleu-peupeu> doing some max/msp patches to control some video animation
06:50:46 <eu-prleu-peupeu> no big deal also
07:01:16 <Phyx-> @hoogle startupHaskell
07:01:16 <lambdabot> No results found
07:05:19 <sbahra> For the people who were following the discussion, here are some partial results: http://kerneled.org/analysis/memcpy/ (http://carte.kerneled.org/speed.c)
07:09:23 <icqnumber> with :load modules can be loaded and how to unload them?
07:10:05 <roconnor> Is there a web programming framework that doesn't cater to ex rails and ex PHP users?
07:12:22 * ml- plunges into his freshly aquired RWH book
07:12:50 <ml-> oh joy so much to do ;)
07:14:59 <Philonous> icqnumber: Dunno if you can unload them, but you can remove them from the context with :module - <modname>
07:15:22 <Phyx-> @url FFI
07:15:22 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
07:17:05 <vixey> > let z = \n s z -> z ; s = \n s z -> s (n s z) ; q  = n (+1) 0 in q$  s (s (s (s z)))
07:17:07 <lambdabot>   Couldn't match expected type `(a -> a) -> t1 -> t'
07:17:40 <vixey> > let z = \s z -> z ; s = \n s z -> s (n s z) ; q  = n (+1) 0 in q$  s (s (s (s z)))
07:17:54 <lambdabot>   Couldn't match expected type `(a -> a) -> t1 -> t'
07:17:54 <vixey> :.
07:18:39 <vixey> that wasstupid
07:18:41 <vixey> > let z = \s z -> z ; s n = \s z -> s (n s z) ; q n = n (+1) 0 in q$ s (s (s (s z)))
07:18:42 <lambdabot>   4
07:21:14 <icqnumber> Philippa, thanks
07:26:21 <crashit> can someone tell me what exactly product [] function doing
07:27:03 <bremner> crashit: lambdabot can
07:27:21 <bremner> @hoogle product
07:27:22 <lambdabot> Prelude product :: Num a => [a] -> a
07:27:22 <lambdabot> Data.Foldable product :: (Foldable t, Num a) => t a -> a
07:27:22 <lambdabot> Data.List product :: Num a => [a] -> a
07:27:35 <Axman6> > product []
07:27:37 <lambdabot>   1
07:27:43 <Axman6> @src product
07:27:44 <lambdabot> product = foldl (*) 1
07:29:06 * bremner bows before Axman6's greater lambdabot-fu :-)
07:29:10 <crashit> if i have some string list and do this product [1 .. 4] what will i get it
07:29:25 <Axman6> > product [1..4]
07:29:26 <Axman6> >_>
07:29:26 <lambdabot>   24
07:29:29 <Gracenotes> @src product'
07:29:29 <lambdabot> Source not found. My pet ferret can type better than you!
07:29:36 <Gracenotes> > produce [1..10^7]
07:29:37 <lambdabot>   Not in scope: `produce'
07:29:39 <Gracenotes> > product [1..10^7]
07:29:41 <bremner> crashit: don't you have ghci?
07:29:42 <mm_freak> i found a way to simulate curried style in python
07:29:50 <mm_freak> http://rafb.net/p/6eAzrU20.html
07:29:53 <pumpkin> crashit: that's 4 factorial
07:29:57 <pumpkin> (btw)
07:30:26 <Gracenotes> ....hm
07:30:27 <crashit> thx pumpkin,i was not sure
07:30:44 <lambdabot>   mueval: Prelude.read: no parse
07:30:58 <Gracenotes> wut
07:31:14 <Axman6> ....hmm
07:31:14 <pumpkin> Gracenotes: 10^7 factorial? :o
07:31:20 <pumpkin> that's quite intense :P
07:31:33 <crashit> sorry gracenotes
07:31:35 <crashit> ?
07:31:37 <Gracenotes> pumpkin: that's true; it'd probably overflow in RAM before the stack overflows
07:31:37 <crashit> :D
07:31:50 <Axman6> > ler product' = foldl' (*) 1 in product' [1..10^7]
07:31:54 <lambdabot>   <no location info>: parse error on input `='
07:31:55 <Axman6> > let product' = foldl' (*) 1 in product' [1..10^7]
07:32:09 <pumpkin> Axman6: I doubt it's the list :P it's just a ****ing huge number
07:32:11 <lambdabot>   thread killed
07:32:14 <koeien> you can always use stirling's approximation
07:32:20 <Gracenotes> yeah
07:32:23 <Axman6> > let product' = foldl' (*) 1 in product' [1..10^5]
07:32:32 <pumpkin> > product [1..70]
07:32:33 <Gracenotes> very effective for large n :P
07:32:35 <lambdabot>   119785716699698917960727837216890987364589381425464258575553628646280095827...
07:32:38 <lambdabot>   thread killed
07:32:41 <pumpkin> Axman6: gives you an idea :P
07:32:43 <Axman6> > let product' = foldl' (*) 1 in product' [1..10^3]
07:32:46 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
07:32:50 <Axman6> > let product' = foldl' (*) 1 in product' [1..10^4]
07:32:53 <lambdabot>   284625968091705451890641321211986889014805140170279923079417999427441134000...
07:33:00 <Axman6> > let product' = foldl' (*) 1 in product' [1..2*10^4]
07:33:03 <lambdabot>   181920632023034513482764175686645876607160990147875264891806221863456946103...
07:33:07 <Axman6> > let product' = foldl' (*) 1 in product' [1..3*10^4]
07:33:07 <pumpkin> > let product' = foldl' (*) 1 in length . show $ product' [1..10^4]
07:33:10 <lambdabot>   35660
07:33:12 <lambdabot>   275953724621938459937994216642546278398076204452933098552963503680007586885...
07:33:13 <Gracenotes> wow
07:33:14 * Axman6 zeros in on the death number!
07:33:20 <Axman6> > let product' = foldl' (*) 1 in product' [1..4*10^4]
07:33:23 <koeien> @let stirling n = sqrt (2*pi*n) * (n/(exp 1))**n
07:33:26 <lambdabot>   209169242221213236332045525676432702648837354438753434183074196798211150575...
07:33:27 <lambdabot>  Defined.
07:33:34 <koeien> > stirling 10^7
07:33:35 <pumpkin> Axman6: it's only dying because of the timeout in lambdabot though
07:33:37 <lambdabot>   7.816562522305679e45
07:33:43 <Axman6> pumpkin: i know :)
07:33:46 <Gracenotes> hm, pretty big
07:33:49 <Axman6> > let product' = foldl' (*) 1 in product' [1..5*10^4]
07:33:54 <Gracenotes> that squared would be the number of atoms in the universe
07:33:56 <lambdabot>   334732050959714483691547609407148647791277322381045480773010032199016802214...
07:33:59 <Axman6> > let product' = foldl' (*) 1 in product' [1..6e4]
07:34:02 <lambdabot>   Infinity
07:34:16 <Axman6> > let product' = foldl' (*) 1 in product' [1..6*10^4]
07:34:24 <lambdabot>   156413770802606692246031989152790566229856284879604288615080480409202727769...
07:34:27 <Axman6> whoops, forgot that was for Doubles
07:34:31 <Axman6> > let product' = foldl' (*) 1 in product' [1..8*10^4]
07:34:40 <pumpkin> Axman6: might as well ask for the number of digits like I did :P
07:34:43 <lambdabot>   309772225166224928639821327991375426836758734458964387575212582921047851274...
07:34:56 <Axman6> > let product' = foldl' (*) 1 in product' [1..9*10^4]
07:35:10 <lambdabot>   158011915409779537149258669328421471402991577351041872363165596509918018169...
07:35:19 <Axman6> :\
07:35:31 * Axman6 gives up
07:41:32 <rwbarton> > stirling (10^7)
07:41:35 <lambdabot>   Infinity
07:42:08 <fco> hi everybody
07:42:25 <vixey> hello
07:43:09 <fco> I've just updated to 6.10 and now I am having an error with my exception handling code, like here http://hpaste.org/13606
07:43:27 <fco> "Ambiguous type variable `e' in the constraint:" is the error
07:43:59 <blackh1> fco: Control.Exception is a newer version in 6.10
07:44:00 <fco> is this a bug fixed in 6.10, or how do I solve that
07:44:14 <blackh1> fco: import Control.OldException if you want compatibility
07:45:01 <fco> blackhl: that is working! where do I find info regarding the new ControlException?
07:45:25 <fco> blackhl: and is there a way to make it backwards compatible?
07:45:51 <blackh1> fco: Just read the haddock docs for it. The new exceptions are much better because they're extensible.
07:46:32 <koeien> rwbarton: yes, i realized the precedence error as well
07:47:07 <blackh1> fco: One gotcha with them is that you have to say (\exc -> putStrLn $ show (exc::SomeException)) and so forth...
07:47:19 <blackh1> fco: The ::SomeException is necessary.
07:47:37 <mm_freak> why is 'fix f' the _least defined_ fixed point of f?
07:47:57 <idnar> mm_freak: well, for example, fix (+0) is undefined
07:48:15 <EvilTerran> mm_freak, because, in order to find a more-defined fixed-point, you'd have to work out part of the value that depended on itself
07:48:16 <idnar> mm_freak: 0 is also a fixed point of (+0)
07:48:24 <fco> blackh1: ah, that's why the error message, and for backwards compatibility, is it possible? or you have to have a version for 6.10 and another for 6.8
07:48:34 <EvilTerran> mm_freak, instead of only working out the parts that don't depend on themselves
07:48:39 <koeien> fco: you could always use the preprocessor... :(
07:48:55 <mm_freak> EvilTerran: could you illustrate this with the example fix (1:)?
07:48:57 <blackh1> fco: No - the interface is quite different. There's no way to write code that will work on both versions.
07:49:03 <mm_freak> i don't quite understand
07:49:05 <EvilTerran> mm_freak, well, that one only has one fixed-point
07:49:39 <blackh1> fco: The new version is so much better than the old one that it's worth it!
07:50:09 <mm_freak> indeed, but in idnar's example it's clear that it's the least-defined fixed point
07:50:26 <athos> hi
07:50:37 <fco> blackh1: ok, thank you very much! I will read the docs, also I rather prefer having the new version with the right name, that having Contro.NewException, and then Control.EvenNewerExceptions
07:50:39 <EvilRanter> mm_freak, in fix (1:), no part of the value depends on the same part to be worked out; it's clearly (1:_), but then the _ doesn't depend on the value of itself in order to work out its value, and so on
07:51:06 <mm_freak> ok, why is 'fix f' the least-defined fixed point of f = \r x -> x : r x?
07:51:33 <EvilRanter> mm_freak, in the case of, say, "fix id", we know nothing about its value, and can't work out any part of it without... working the same bit out first to pass to id
07:51:50 <athos> > fix id
07:51:52 <lambdabot>   * Exception: stack overflow
07:51:56 <athos> 8/
07:52:46 <EvilRanter> ?type fix (\r x -> x : r x)
07:52:48 <lambdabot> forall a. a -> [a]
07:52:56 <mm_freak> EvilRanter: these are special cases, though
07:53:03 <EvilRanter> are they?
07:53:32 <EvilTerran> other cases work the same way
07:53:32 <mm_freak> in some functions, the least-defined fixed point is not bottom (otherwise fix would be quite useless)
07:53:41 <athos> take 20 $ fix (\r x -> x : r x) $ 5
07:53:45 <EvilTerran> mm_freak, indeed; such as fix (1:)
07:53:48 <mm_freak> i don't get why those fixed points are least-defined
07:53:49 <idnar> mm_freak: the way fix f is implemented is by applying f over and over, never stopping
07:53:52 <athos> > take 20 $ fix (\r x -> x : r x) $ 5
07:53:54 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]
07:54:06 <EvilTerran> mm_freak, because 1:undefined is not undefined
07:54:21 <mm_freak> EvilTerran: ah, that's a better illustration =)
07:54:22 <EvilTerran> so undefined is not a fixedpoint
07:54:28 <idnar> mm_freak: this means that the fixed point it finds will always be the least-defined one, because to find a more-defined fixed point, you'd have to figure out when to stop applying f
07:54:34 <mm_freak> idnar: i know how fix works and how to use it, i just don't know why the fixed point is least-defined
07:54:56 <EvilTerran> "fix f = last (iterate f undefined)", kinda
07:55:23 <EvilTerran> [undefined, f undefined, (f . f) undefined, (f . f . f) undefined, ...]
07:57:21 <vixey> ?where catch
07:57:22 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
07:57:40 <EvilTerran> mm_freak, in general, the least fixed-point of a non-strict function won't be _|_
07:58:33 <bremner> is there any nicer way to embed multi-line strings in haskell than the \ \n \   way?
07:58:59 <vixey> bremner, I use unlines [ "foo" \n, "bar" , ... ]
07:59:01 <mm_freak> bremner: i use:  unlines [ "a", "b", "c" ]
07:59:06 <athos> :t unlines
07:59:07 <lambdabot> [String] -> String
07:59:29 <bremner> hmm. I was looking for something more perl like :-)
07:59:53 <Martijn> bremner: haskell doesn't have special multi-line string literals.
08:00:09 <EvilTerran> if you're willing to use -XOverloadedStrings, a clever instance of Data.String.IsString would let you write "foo" \n "bar"
08:00:15 <EvilTerran> i think
08:00:16 <rwbarton> bremner: In 6.10, you can use quasiquotation
08:00:36 <mm_freak> bremner: you could preprocess your source code with CPP, but that's ugly
08:00:46 <mnislaih> bytestring question: why should (replicateM n B.getLine) be any slower than ((take n . B.lines) `liftM` B.getContents)
08:00:52 <bremner> bah, its just a little test script. I'll use a file
08:01:44 <mm_freak> mnislaih: it shouldn't
08:02:12 <redditbot> Implementation of a dynamic dispatch on a type context without using unsafe operations by Oleg Kiselyov. [lhs]
08:02:33 <arjanb> mnislaih: maybe it reads the file in a different block size
08:02:39 <mnislaih> mm_freak: oh it is.
08:02:52 <mm_freak> mnislaih: lazy or strict ByteString?
08:03:17 <vixey> redditbot: link?
08:03:18 <mnislaih> mm_freak: strict Char8
08:03:46 <Axman6> vixey: http://reddit.com/r/haskell ;)
08:03:59 <Axman6> damn, i typed that, then saw it was in the topic -_-
08:04:11 <mm_freak> mnislaih: then it's likely related to buffering
08:05:01 <mnislaih> mm_freak: can you be more specific ? buffering is the same in both cases
08:05:01 <mm_freak> although you get lines with your B.getContents version, it uses block buffering
08:05:07 <Axman6> http://www.ptlsim.org/index.php <-- really cool
08:05:14 <mm_freak> with B.getLine, you might have line buffering
08:06:05 <mnislaih> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.4/doc/html/src/Data-ByteString.html#getLine
08:11:13 <mnislaih> in my box, reading the 200.000 lines in a 2.3M file takes more than 1.236s with replicate + B.getLine, and 0.029s with B.lines + B.getcontents
08:11:26 <mnislaih> that's a noticeable difference
08:11:29 <vixey> mm...
08:11:34 <vixey> I have syntax question
08:12:12 <mm_freak> mnislaih: while B.getLine does a lot of stuff, B.getContents just reads the entire file
08:12:17 <mm_freak> B.lines is a very fast function
08:12:32 <mnislaih> mm_freak I disagree: replicateM_ + B.getLine is fast
08:14:21 <rwbarton> mnislaih: ... are you actually demanding the result of that ((take n . B.lines) `liftM` B.getContents)?  It seems almost too fast
08:14:51 <mm_freak> rwbarton: i don't think explicit demanding is necessary in IO
08:15:17 <rwbarton> Well, not for the IO to happen, true
08:15:25 <mnislaih> rwbarton: I'm printing the number of lines so yes
08:15:41 <rwbarton> Hmm, that's pretty good then
08:16:14 <pejo> mnislaih, do you get the same result if you run the same test several times in a row, for both tests?
08:17:08 <mnislaih> rwbarton main = B.getContents >>= print . length . B.lines
08:17:29 <mnislaih> pejo let me see
08:18:17 <vixey> you know this technique where you represent syntax like:  VLam (\x -> VApp x x)  and then you can quote it back into  Lam (App (Var 0) (Var 0)) ?
08:19:11 <vixey> is this possible to do without having any quote constructor in the syntax? (the one that isn't Value)
08:19:26 <mnislaih> pejo absolutely
08:19:32 <vixey> and not having a quote in Value? I wonder about that tooo
08:19:51 <EvilTerran> vixey, are you referring to active abstract syntax?
08:19:56 <athos> i was wondering if there's some dummy operation in the state, or let's say IO monad. i have some type like type Foobar a = StateT FooState IO a, and i got want to fold (>>) over [Foobar]
08:20:01 <rwbarton> mnislaih: also do you have a user/sys time breakdown
08:20:01 <vixey> I never heard of that
08:20:14 <JS`> does some1 know how to make a .tgz?
08:20:30 <mnislaih> rwbarton: yes. all the time is user, mostly
08:20:46 <pejo> JS, tar czf
08:21:14 <EvilTerran> athos, and you want an action that doesn't do anything? well, "return :: Monad m => a -> m a" embeds a side-effect-less value in a monadic action that does nothing but yields that value
08:21:22 <rwbarton> mnislaih: OK, that's all consistent with the file being in cache.  I guess getLine is just a lot more expensive than scanning for "\n"
08:22:05 <mnislaih> test code is in http://hpaste.org/13607
08:22:05 <rwbarton> @src sequence_
08:22:05 <EvilTerran> athos, actually, i think the function you're looking for might be called "sequence" or "sequence_"
08:22:05 <EvilTerran> ?src sequence
08:22:05 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
08:22:05 <lambdabot> sequence []     = return []
08:22:05 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
08:22:05 <lambdabot> --OR
08:22:05 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
08:22:14 <athos> ah
08:22:25 <EvilTerran> ?type sequence
08:22:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:22:27 <EvilTerran> ?type sequence_
08:22:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
08:22:31 <athos> thanks
08:22:38 <athos> sequence_ is what i want :)
08:22:57 <EvilTerran> in that case, the answer to your original question would be "return ()" :)
08:23:00 <vixey> I guess it is not possible ... it doesn't really make sense
08:23:02 <athos> yep
08:23:03 <athos> :)
08:23:04 <athos> thanks
08:25:49 <tjb> I'm having an error where I need to add an System.Random.Random instance for the Data.Word.Word8 type -- does this already exist somewhere?
08:26:49 <mnislaih> rwbarton: looks rather like a performance bug
08:27:36 <mnislaih> rwbarton: if that's not the case, then there should be a warning in the API docs
08:27:59 <mnislaih> is there a bug tracker for the bytestring library anywhere ?
08:30:27 <EvilTerran> mnislaih, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring lists dons' and dcoutts' email addresses under "maintainer", you could send them a note
08:31:23 <mnislaih> @seen dcoutts_ dons
08:31:23 <lambdabot> dcoutts_ is in #gentoo-haskell, #ghc, #haskell, #haskell-overflow and #darcs. I don't know when dcoutts_ last spoke.
08:31:30 <mnislaih> @seen dons
08:31:30 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 13h 24m 32s ago.
08:32:31 <athos> main = do args <- getArgs if length args /= 1
08:32:42 <athos> 57:4: Parse error in pattern
08:32:55 <vixey> you actually expected that to work ?
08:33:02 <athos> where 57:4 is the one character before if
08:33:17 <athos> and of course a then and an else clause are following
08:33:19 <mnislaih> aye, the problem not in bytestring but in replicateM
08:33:24 <kpreid> main = do args <- getArgs; if length args /= 1 ...
08:33:29 <mm_freak> athos: still that code makes no sense
08:33:33 <athos> nope, there's a line breake
08:33:34 <mnislaih> for some reason it's wasting a lot of time
08:33:41 <athos> irssi fucked it up
08:33:51 <mm_freak> then there is nothing wrong
08:33:54 <EvilTerran> mnislaih, well, it's allocating and deallocating all that data
08:33:56 <athos> hm
08:33:59 <kpreid> athos: indentation, maybe. use hpaste and show us the actual formatting, including then/else
08:35:20 <mnislaih> EvilTerran: isn't (B.lines `liftM` B.getContents) allocating the same data ?
08:35:48 <EvilTerran> not necessarily, it may get fused out of existence by the optimiser
08:36:04 <athos> ah.
08:36:06 <athos> catched the rror
08:36:11 <athos> *error*
08:36:30 <vixey> I just have to put up with all these quotes
08:36:32 <vixey> I think I can go
08:36:37 <vixey> data N = A | B | ...
08:36:38 <mnislaih> EvilTerran: right, now I get what is going on, thanks. I should've looked at the core instead of complain here
08:36:45 <vixey> data NQ = Aq | Bq | ... | Q
08:37:00 <vixey> although I really neeed..
08:37:06 <vixey> data NQQ = Aqq | Bqq | ... | QQ
08:37:12 <vixey> ... and so on, for any number of Qs
08:37:21 <vixey> oops
08:37:25 <vixey> data NQQ = Aqq | Bqq | ... | Q | QQ
08:37:28 <EvilTerran> vixey, you could specify the number of Qs as a phantom type parameter
08:37:48 <athos> kpreid: i forgot to put an do (or at least use >>=) after the else clause
08:38:07 <EvilTerran> vixey, actually, those look isomorphic to N, Maybe N, and Maybe (Maybe N), respectively
08:38:16 <vixey> if N = ()
08:38:20 <crashit> one question :|  sum [product [1 .. 4], product [2 .. 4], 1]    does it this sum equal 48 or 49
08:38:25 <vixey> or N = Void
08:38:38 <vixey> > sum [product [1 .. 4], product [2 .. 4], 1]
08:38:39 <lambdabot>   49
08:38:44 <vixey> 49
08:38:50 <crashit> thx
08:38:57 <EvilTerran> it must be odd, as prod[1..4] == prod[2..4], by inspection
08:39:50 <vixey> If I used phantom parameters I wonder If I could still type my program
08:39:53 <EvilTerran> vixey, i'm pretty sure using (Maybe N) instead of NQ will work regardless of how many constructors N has
08:40:36 <EvilTerran> it'll give you one value for each you had already, and one more (Nothing, corresponding to Q)
08:41:03 <EvilTerran> then Maybe (Maybe N) would give you the two extra values of Nothing and Just Nothing (corresponding to QQ and Q, in some order)
08:41:08 <vixey> what's N
08:41:16 <EvilTerran> <vixey> data N = A | B | ...
08:41:26 <vixey> oh that wont work
08:41:31 <EvilTerran> ok
08:41:35 <vixey> well it will work
08:41:39 <EvilTerran> i clearly have no idea what you're talking about, carry on :)
08:41:51 <vixey> no it's fine it would work
08:42:05 <vixey> I just didn't say N was recursive but that's easily adapted to
08:42:23 <EvilTerran> ah, yeah, that'd require a little more fudging with types
08:43:48 <EvilTerran> Mu N, Mu (MaybeT N), ...
08:43:55 <EvilTerran> (or something)
08:44:05 <vixey> T Void, T (Maybe Void), .. could work
08:44:27 <EvilTerran> not MaybeT, (Maybe `O`)
08:45:09 <vixey> is it possible to write
08:45:49 <vixey> subst :: T (Maybe m) -> T m -> T m
08:45:57 <crashit> if i say that ( if (length (check (x ++ "p")) == (sum [product [1 .. 4], product [2 .. 4], 1]))  ) does that mean that i need to have array of 50 elements for equation?and can i use init insted of check
08:46:09 <vixey> I guess yeah it should be straightforward
08:46:11 <EvilTerran> you could use "newtype MaybeO t a = MaybeO { unMaybeO :: Maybe (t a) }" with Mu and "data N n = (replace N with n herein)" to get the right effect when using (Mu N), (Mu (MaybeO N)), i think
08:46:22 <EvilTerran> but that's getting really confusing
08:46:50 <vixey> what I really want is  eval :: T Void -> T Void
08:47:05 <vixey> but I have to introduce all this quote fluff
08:47:35 <vixey> I should do a test program...
08:47:49 * EvilTerran 's suggestions've got rather olegian, unfortunately
08:48:26 <vixey> I tried to program something like this in Omega before
08:48:37 <vixey> because you can write type level functions and so on..
08:48:38 <crashit> vixey: does this yeah it should.. was for me or EvilTerran
08:49:12 <vixey> crashit, there is no arrays in there
08:49:34 <vixey> well I don't know what check is
08:50:03 <pejo> vixey, is Omega usable?
08:50:21 <crashit> check  :: [a] -> [a]
08:50:21 <crashit> check b = init b
08:50:27 <EvilTerran> ...
08:50:34 <vixey> pejo, I guess so.. Sheard has lots of examples but when I did it's tricky because I don't know if it's me doing something wrong, or the system cannot narrow enough
08:50:52 <crashit> i mean list of 50 elements
08:51:10 <vixey> so I gave up with it
08:51:21 <EvilTerran> crashit, why are you appending "p" to the end of the list, then immediately removing it with "init"?
08:51:27 <vixey> crashit, the 'if' is odd though
08:52:13 <vixey> pejo, (but in the time I used I had to add editline support.. it was too annoying without)
08:52:26 <crashit> i am new in this language,i know c,c++,java,php... but this one i learning and i need to fix some code,but i have problems
08:52:50 <vixey> crashit: this: check b = init b, means you can use init instead of check
08:53:00 <crashit> now i trying to break it in lines to figure what exactly do
08:53:10 <vixey> crashit, and also:  init (x ++ "p") = x
08:53:19 <vixey> crashit, so you can use x instead of  init (x ++ "p")
08:53:55 <vixey> crashit, similarly, you can use  49 instead of  sum [product [1 .. 4], product [2 .. 4], 1]
08:54:25 <vixey> crashit, so you rewrite all those and get:   length x == 49
08:54:30 <crashit> now i figure that,thx
08:54:50 <crashit> can u look this code if u have time to tell me what is wrong??
08:54:52 <crashit> http://hpaste.org/13600
08:54:59 <vixey> no
08:55:33 <crashit> ok,thx anyway :(
08:55:40 <mmorrow> vixey: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=725
08:55:42 * vixey wonders, "C:\\codes.txt" vs "C:\\\\codes"
08:55:53 <EvilTerran> ?? ((?where RWH)) ((?where LYAH)) ((?where YAHT))
08:55:53 <lambdabot>  (http://book.realworldhaskell.org/read/) (www.learnyouahaskell.com) (PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT)
08:56:42 <EvilTerran> crashit, parsing tends to be kinda involved in any language; i'd suggest starting with some easier problems; project euler or something
08:57:06 <mmorrow> vixey: i was reading this which which gave me ideas on that: http://www.haskell.org/pipermail/haskell-cafe/2003-May/004343.html
08:58:02 <vixey> mmorrow, this is insane :p
08:58:31 <vixey> mmorrow, did you see this scheme interpreter which interprets itsself interpreting itsself...
08:59:23 <mmorrow> vixey: totally! that scheme one is so cool.
08:59:24 <rwbarton> what, does it read one command and then append itself to the result before interpreting?
08:59:37 <vixey> rwbarton, yes I think it works exactly that way
09:00:08 <mmorrow> rwbarton, vixey: i actually pasted the scheme on on moonpaste a while ago
09:00:21 <mmorrow> can't remember where i found it online though
09:00:48 <mmorrow> hpaste2 search++
09:00:49 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=508
09:00:59 <mmorrow> ^^ scheme metacircular interp
09:01:00 <EvilTerran> that's not even metacircular, that's just circular O.o
09:01:37 <mmorrow> well, it would be in the "comp" and "exec" function were implem in the same lang to the machine code level
09:01:42 <crashit> one more question :D i cant found meaning of this line    papply code2 x
09:01:58 <mmorrow> and since Exp has a (Exp -> Exp) as a placeholder, it can accomodate that i think
09:02:04 <vixey> @hoogle papply
09:02:05 <lambdabot> No results found
09:02:13 <redditbot> Real World Haskell update | The Changelog
09:02:14 <vixey> h.m..
09:02:22 <EvilTerran> crashit, papply isn't a standard function, so it should be defined in the files you're working with
09:02:25 <mmorrow> (end "exec" would corresponde to hardware)
09:02:32 <crashit> no
09:02:35 <crashit> its not
09:02:43 <crashit> i have only that file
09:02:44 <vixey> maybe it's in something you import
09:02:57 <crashit> because of that iam and asking
09:03:14 <EvilTerran> crashit, i guess it's in ParseLib
09:04:07 <IWannaLog> @src init
09:04:07 <lambdabot> init [x]    = []
09:04:07 <lambdabot> init (x:xs) = x : init xs
09:04:07 <lambdabot> init []     = undefined
09:04:27 <michaelcdever> simple question here, if i had a list say [1,2,3,4,5,6,7,8] and i wanted to remove elements that were divisible by 3, how would i write that? would i write it using takeWhile?
09:04:27 <IWannaLog> udefined it's error like in head [] ?
09:04:40 <EvilTerran> michaelcdever, i think "filter" would be more appropriate
09:04:44 <IWannaLog> michaelcdever: filter
09:04:45 <vixey> michaelcdever: filter (divisibleBy 3)
09:04:47 <IWannaLog> :t filter
09:04:49 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
09:04:55 <IWannaLog> :t divisibleBy
09:04:57 <lambdabot> Not in scope: `divisibleBy'
09:04:58 <vixey> michaelcdever: divisibleBy k n = n `mod` k == 0
09:05:02 <rwbarton> IWannaLog: I think the actual source uses error rather than undefined
09:05:05 <rwbarton> > init []
09:05:07 <lambdabot>   * Exception: Prelude.init: empty list
09:05:22 <vixey> michaelcdever: (oh well it should be, not . divisibleBy 3)
09:05:24 <IWannaLog> you're right
09:06:08 <IWannaLog> :t mod
09:06:09 <lambdabot> forall a. (Integral a) => a -> a -> a
09:06:24 <andreas__> Hi, I'm having trouble installing ghc 6.10.1 from the binary distribution for apple powerpc os x 10.5 (leopard). has anyone gotten this distribution to install correctly?
09:06:32 <michaelcdever> right, ok, so if i wanted to write a custom Bool for it, i have a function that returns a Bool, how would i do that filter, if my function takes [a] as a param?
09:06:44 <IWannaLog> andreas__: Yes i did it.
09:06:56 <vixey> michaelcdever: like how I just showed you ?
09:06:59 <pejo> andreas, what problem are you having?
09:07:01 <andreas__> I have the following problem after running ./configure
09:07:02 <IWannaLog> but i remove it after, because I need §.8.3
09:07:02 <andreas__> checking build system type... powerpc-apple-darwin9.5.0
09:07:02 <andreas__> checking host system type... powerpc-apple-darwin9.5.0
09:07:03 <andreas__> checking target system type... powerpc-apple-darwin9.5.0
09:07:03 <andreas__> Which we'll further canonicalise into: powerpc-apple-darwin
09:07:03 <andreas__> checking for path to top of build tree... dyld: Library not loaded: /usr/local/lib/libgmp.3.dylib
09:07:04 <andreas__>   Referenced from: /Users/andreas/Downloads/ghc-6.10.1/dist/utils/pwd/pwd
09:07:06 <andreas__>   Reason: image not found
09:07:08 <andreas__> configure: error: cannot determine current directory
09:07:14 <andreas__> sorry for the many lines!
09:07:20 <vixey> andreas__, well you could try installing gmp
09:07:35 <IWannaLog> sorry I'm on Intel
09:07:39 <pejo> andreas, do you have  /usr/local/lib/libgmp.3.dylib?
09:07:48 <michaelcdever> like filter ( myFunction ) list, right but how does it supply the parameter to myFunction, i'd normally call myFunction a, and get a bool
09:07:58 <rwbarton> @src filter
09:07:58 <lambdabot> filter _ []     = []
09:07:58 <lambdabot> filter p (x:xs)
09:07:58 <lambdabot>     | p x       = x : filter p xs
09:07:58 <lambdabot>     | otherwise = filter p xs
09:08:01 <andreas__> I actually have installed gmp; it's in /opt/local/lib/libgmp.3.dylib
09:08:15 <andreas__> but configure is looking at /usr/local/lib
09:08:17 <vixey> michaelcdever: it takes them out of the list and applies it
09:08:32 <rwbarton> michaelcdever: exactly like you wrote.  filter myFunction list will return those elements x of list for which myFunction x is True
09:08:49 <andreas__> can i get configure to look at /opt/local instead?
09:09:06 <michaelcdever> ah okok, so it takes a list, takes the head of the list, and calls the supplied function with that element, cool cool, that makes sense
09:09:11 <michaelcdever> cheers
09:09:20 <IWannaLog> :t filterM
09:09:21 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
09:09:37 <cjb> andreas__: export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/local/lib
09:09:39 <cjb> might do it
09:09:46 <IWannaLog> filterM (\_ -> [True, False]) [1, 2, 3, 4]
09:09:49 <andreas__> OK, thanks, I'll try that.
09:09:49 <pejo> andreas, export DYLD_LIBRARY_PATH=/opt/local/lib:$DYLD_LIBRARY_PATH
09:09:58 <IWannaLog> > filterM (\_ -> [True, False]) [1, 2, 3, 4]
09:09:59 <lambdabot>   [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4...
09:10:07 <cjb> oh, go with what pejo said; I don't know anything about OS X.
09:10:09 <IWannaLog> filterM (\_ -> [True, False]) [1, 2, 3]
09:10:21 <IWannaLog> > filterM (\_ -> [True, False]) [1, 2, 3, 4]
09:10:23 <lambdabot>   [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4...
09:10:28 <IWannaLog> > filterM (\_ -> [True, False]) [1, 2, 3]
09:10:30 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
09:10:33 <IWannaLog> SORRY everybody
09:10:59 <IWannaLog> filterM what a beautiful function
09:11:04 <opqdonut> it is
09:11:06 <IWannaLog> :t filterM_
09:11:07 <lambdabot> Not in scope: `filterM_'
09:11:42 <Arnar> @seen dcoutts_
09:11:42 <lambdabot> dcoutts_ is in #gentoo-haskell, #ghc, #haskell, #haskell-overflow and #darcs. I don't know when dcoutts_ last spoke.
09:12:02 <neun> Hi, I need some help with gtk2hs/cairo rasterisation to a pixbuf
09:12:06 <IWannaLog> @seen IWannaLog
09:12:07 <lambdabot> You are in #haskell. I last heard you speak just now.
09:12:14 <neun> http://hpaste.org/13608
09:12:34 <neun> can't get it to work
09:12:35 <IWannaLog> Is there a doc for lambdabot or I must say @list and @help for each command
09:12:46 <Arnar> @commands
09:12:46 <lambdabot> Unknown command, try @list
09:12:54 <Arnar> I guess it's just @list
09:12:54 <IWannaLog> :D
09:13:10 <Arnar> IWannaLog: I asked a similar q once and was directed to the source code :)
09:13:20 <IWannaLog> Ok
09:13:23 <Arnar> neun: I don't know gtk2hs or cairo.. is the problem specific to those?
09:13:34 <neun> Arnar: yes
09:14:14 <pejo> IWannaLog, lambdabot answers to private messages if you type out the full commands (so @google thing instead of @go thing), in case you don't want the channel to see.
09:14:52 <IWannaLog> pejo: I know that
09:14:54 <andreas__> OK, great - the configure script finished successfully. Unfortunately, now "sudo make install" fails.
09:15:39 <andreas__> with the following error: make -C ghc-pkg install
09:15:41 <andreas__>                            '/Users/andreas/Downloads/ghc-6.10.1/dist/utils/ghc-pkg/dist-install/build/ghc-pkg/ghc-pkg'                      \
09:15:41 <andreas__>                            '/usr/local/lib/ghc-6.10.1/package.conf'            \
09:15:41 <andreas__>                            '' '/usr/local'                       \
09:15:41 <andreas__>                            '/usr/local' '/usr/local/bin' '/usr/local/lib/ghc-6.10.1'            \
09:15:42 <andreas__>                            '/usr/local/lib/ghc-6.10.1' '' '/usr/local/lib/ghc-6.10.1'    \
09:15:43 <IWannaLog> but usually I open a chanel with it
09:15:43 <andreas__>                            '/usr/local/share/doc/ghc' '/usr/local/share/doc/ghc' ''       \
09:15:45 <andreas__>                            --distpref dist-install                        \
09:15:45 <michaelcdever> ok, right, ive a function that performs IO, and it returns type IO Bool, I can't use this with filter?
09:15:47 <andreas__>                            --enable-shell-wrappers
09:15:48 <koeien> ?hpaste
09:15:48 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:15:49 <andreas__> dyld: Library not loaded: /usr/local/lib/libgmp.3.dylib
09:15:51 <andreas__>   Referenced from: /Users/andreas/Downloads/ghc-6.10.1/dist/utils/installPackage/install-inplace/bin/installPackage
09:15:54 <andreas__>   Reason: image not found
09:15:56 <andreas__> make[2]: *** [install] Trace/BPT trap
09:15:58 <andreas__> make[1]: *** [install.ghc-pkg] Error 2
09:16:00 <andreas__> make: *** [install] Error 2
09:16:04 <andreas__> sorry again for multiple lines.
09:16:12 <koeien> andreas__: http://hpaste.org/new
09:16:37 <michaelcdever> ok, right, ive a function that performs IO, and it returns type IO Bool, I can't use this with filter?
09:16:46 <idnar> @type filterM
09:16:47 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
09:17:35 <koeien> @src filterM
09:17:36 <lambdabot> Source not found. Maybe if you used more than just two fingers...
09:17:42 <koeien> :(
09:18:23 <Arnar> @index filterM
09:18:23 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
09:18:38 <Arnar> @src Control.Monad.filterM
09:18:38 <lambdabot> Source not found. Wrong!  You cheating scum!
09:19:20 <sereven>  http://hackage.haskell.org/packages/archive/base/4.0.0.0/doc/html/src/Control-Monad.html#filterM
09:20:59 <michaelcdever> thanks idnar
09:22:07 <vixey> http://www.tcs.informatik.uni-muenchen.de/~abel/foetus/
09:22:11 <pejo> andreas, try to make a symlink from /usr/local/lib/libgmp.. to the libgmp in /opt/local/lib during the installation, the package assumes that it's there since the package builder probably had their machine configured that way. It might be easier to convince the installed ghc that it's really in /opt/local
09:22:12 <vixey> cool ^
09:24:41 <pejo> vixey, there's some other termination checker available somewhere online that implements  the work of Neil Jones et al., in case you're interested in that kind of stuff.
09:25:07 <vixey> yeah I am
09:25:21 <vixey> something other than catch?
09:26:03 <andreas__> pejo: thanks, I can try that; but I wonder - is there a flag I can give configure to tell it to look in /opt/local/lib?
09:26:44 <pejo> vixey, catch doesn't do termination analysis in that sense afaik. (But it's a very nice tool, I wish it was integrated with GHC)
09:26:58 <vixey> yeah
09:27:12 <crashit> thx,to all....guys ur great :D
09:29:34 <pejo> vixey, http://progtools.comlab.ox.ac.uk/projects/termination/termination
09:31:20 <pejo> andreas, probably not, it's hardwired into the binaries. (There's supposedly a tool that could change those paths in recent versions of Solaris, but I don't think there's anything equivalent for OSX).
09:33:38 <IWannaLog> @help define
09:33:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:33:47 <IWannaLog> @help def
09:33:47 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:33:55 <Peaker> Why is there no auto-derive of the new Control.Exception.Exception class?  fromException = cast . unSomeException ; toException = SomeException
09:34:39 <IWannaLog> > let genericFilter cond l = do {x <- l; guard (cond x); retun x}
09:34:41 <lambdabot>   <no location info>: parse error on input `;'
09:34:49 <IWannaLog> What ?
09:35:26 <IWannaLog> > let genericFilter cond l = do {x <- l; guard (cond x); return x}
09:35:28 <lambdabot>   <no location info>: parse error on input `;'
09:35:38 <IWannaLog> Could someone explain to me
09:35:48 <koeien> @let genericFilter cond l = do { x <- l; guard (cond x); return x }
09:35:49 <lambdabot>  Defined.
09:35:56 <IWannaLog> ok
09:35:59 <koeien> IWannaLog: you have "let ... " but no "in"
09:36:08 <IWannaLog> I don't use in
09:36:13 <IWannaLog> I just use let
09:36:14 <koeien> if you want lambdabot to learn, then you'll have to use @let
09:36:23 <IWannaLog> I'll try to remember
09:36:30 <Peaker> @type filterM
09:36:31 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
09:36:32 <Peaker> @type genericFilter
09:36:33 <lambdabot> forall t1 (t :: * -> *). (MonadPlus t) => (t1 -> Bool) -> t t1 -> t t1
09:36:45 <andreas__> pejo: I just added a symlink in /usr/local/lib and was able to make install and it seems to be installed correctly - I can run ghci and load modules,etc... thanks so much for the help!
09:37:00 * IWannaLog asks himself if genericFilterM can exist.
09:37:23 <vixey> thank you pejo
09:37:26 <Peaker> IWannaLog: genericFilter already operates on Monads..?
09:37:53 <Peaker> genericFilter and filterM are monadic on different arguments
09:38:02 <b_jonas> > let { allSplit [a] = [[[a]]]; allSplit (a : r) = allSplit r >>= (\(f : s) -> [(a : f) : s, [a] : f : s]); } in liftM unwords (allSplit "abcd")
09:38:04 <lambdabot>   ["abcd","a bcd","ab cd","a b cd","abc d","a bc d","ab c d","a b c d"]
09:38:10 <b_jonas> this looks crazy
09:40:22 <IWannaLog> I thought of genericFilterM :: Monad m, MonadPlus l => (a -> m a) -> l a -> l (m a)
09:40:27 <IWannaLog> @type filterM
09:40:29 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
09:40:39 <vixey> > map words ["abcd","a bcd","ab cd","a b cd","abc d","a bc d","ab c d","a b c d"]
09:40:40 <lambdabot>   [["abcd"],["a","bcd"],["ab","cd"],["a","b","cd"],["abc","d"],["a","bc","d"]...
09:40:42 <IWannaLog> genericFilterM :: Monad m, MonadPlus l => (a -> m a) -> l a -> m (l a)
09:40:47 <IWannaLog> it's better
09:41:00 <Peaker> IWannaLog: how do you combine the two monads?
09:41:15 <mreh> mean' [] a b            = a / b
09:41:15 <mreh> mean' (x:xs) a b        = mean' xs (a+x) (b+1)
09:41:15 <IWannaLog> That's why i was asking myself if it can exist.
09:41:17 <Peaker> IWannaLog: if its the IO and list monads, how do you expect them to combine?
09:41:23 <mreh> what do you make of my list mean function?
09:41:36 <Peaker> IWannaLog: I don't think it could meaningfully exist...
09:41:58 <mreh> mean a = mean' a 0 0
09:42:13 <Heffalump> mreh: looks ok if you don't mind mean [] falling over
09:42:31 <mreh> 0/0 heh :)
09:42:50 <mreh> mean' _ _ 0 = 0 maybe
09:42:51 <vixey> > let partitions [] = [[]] ; partitions (x:xs) = (x:xs) : concatMap (\partition -> [[x:partition],[[x],partition]) (partitions xs) in partitions "abcd"
09:42:52 <lambdabot>   <no location info>: parse error on input `)'
09:44:33 <Arnar> hi all..
09:44:41 <mreh> hello
09:44:57 <Arnar> I wonder..
09:45:25 <Stephan202> We all do, every now and then :)
09:45:29 <Arnar> is there a predefined (or commonly seen) op for this:   \x f -> x >>= (return f) ?
09:45:33 <Arnar> :)
09:45:40 <vixey> Arnar, yes
09:45:42 <Arnar> sorry
09:45:48 <Arnar> return f should be return . f
09:45:54 <vixey> :t \x f -> x >>= return . f
09:45:55 <lambdabot> forall a b (m :: * -> *). (Monad m) => m a -> (a -> b) -> m b
09:45:58 <Peaker> lack of existential quantifiers in ghc's type system (including extensions) make some stuff less composable (exists a. not allowed to escape..)
09:46:12 <vixey> Arnar, so it's a  flipped:  (a -> b) -> (m a -> m b)
09:46:26 <vixey> Arnar, you can also have:  (a -> b -> c) -> (m a -> m b -> m c)
09:46:28 <vixey> etc...
09:46:33 <vixey> it's liftM^n
09:46:37 <Peaker> or fmap
09:46:42 <Peaker> (for Functors)
09:46:47 <Arnar> vixey: ah, ok
09:47:01 <vixey> well fmap is (a -> b) -> (f a -> f b)
09:47:03 <mreh> does anyone here find the jedit syntax highlighting for haskell to be pretty bland?
09:47:10 <Arnar> :t liftM ((+) :: Int -> Int)
09:47:11 <Peaker> Haskell' can fix all the Functor/Applicative and Monad dichotomy
09:47:11 <lambdabot>     Couldn't match expected type `Int'
09:47:11 <lambdabot>            against inferred type `Int -> Int'
09:47:11 <lambdabot>     Probable cause: `+' is applied to too few arguments
09:47:21 <vixey> :t liftM ((+0) :: Int -> Int)
09:47:21 <Peaker> :t liftM (+)
09:47:23 <lambdabot> forall (m :: * -> *). (Monad m) => m Int -> m Int
09:47:23 <lambdabot> forall a1 (m :: * -> *). (Monad m, Num a1) => m a1 -> m (a1 -> a1)
09:47:24 <Arnar> :t liftM2 ((+) :: Int -> Int -> Int)
09:47:25 <lambdabot> forall (m :: * -> *). (Monad m) => m Int -> m Int -> m Int
09:47:33 <vixey> :t liftA2 (+)
09:47:34 <lambdabot> forall a (f :: * -> *). (Applicative f, Num a) => f a -> f a -> f a
09:47:59 <Arnar> ah, so liftM* is liftA* specialized for -> ?
09:48:37 <Saizan> no
09:48:49 <Saizan> for Monad m, instead of Applicative f
09:49:02 <Arnar> right..
09:49:10 <Arnar> the question was silly :)
09:49:17 <Arnar> hang on though..
09:49:31 <Arnar> what I want is to turn a -> b into a -> m b
09:49:32 <vixey> (->) e  is a functor, applicative and monad
09:49:34 <Arnar> not m a -> m b
09:49:47 <vixey> ?woogle (a -> b) -> (a -> m b)
09:49:47 <lambdabot> Maybe you meant: google hoogle
09:49:55 <roconnor> @type (return .)
09:49:57 <vixey> :t return . ?f
09:49:57 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
09:49:58 <lambdabot> forall b (m :: * -> *) a. (?f::a -> b, Monad m) => a -> m b
09:50:02 <opqdonut> :t liftM
09:50:03 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
09:50:47 <Arnar> so basically  v .>>>. f = v >>= (return . f)
09:50:50 <IWannaLog> @src filterM
09:50:51 <lambdabot> Source not found. I feel much better now.
09:50:54 <Arnar> where .>>>. is the thing I'm asking for
09:51:04 <Saizan> that's fmap
09:51:09 <Saizan> or liftM
09:51:25 <Saizan> ?ty \v f -> fmap f v
09:51:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
09:51:34 <vixey> :t (.) return
09:51:35 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
09:51:36 <beelsebob> or <$> if you want it infix
09:51:39 <Peaker> @type (.>>>.)
09:51:40 <lambdabot> Not in scope: `.>>>.'
09:51:56 <Arnar> :t <$>
09:51:57 <lambdabot> parse error on input `<$>'
09:52:03 <Arnar> :t (<$>)
09:52:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:52:20 <beelsebob> Arnar: of note, all Monads are Functors
09:52:39 <Peaker> I think maybe Haskell needs an "operator naming guidelines" document written, where any operator that uses ascii symmetry like <$> should be cummutative. And if its not, then reversing it, i.e: =<< should be flip
09:52:49 <vixey> lol Peaker
09:53:05 <opqdonut> :D
09:53:09 <vixey> I'n my code I have stuff like
09:53:12 <vixey> import ReadP
09:53:17 <Arnar> Peaker: reversing >>=  would be =>> -- right? :)
09:53:19 <vixey> (++>) = flip (<++)
09:53:24 <roconnor> too bad white space has ascii symmetry
09:53:32 <Peaker> Arnar: < is flipped to > :)
09:53:41 <Heffalump> roconnor: and -
09:53:53 <Peaker> you can't flip <$> reasonably :(
09:53:56 <roconnor> ya
09:54:03 <Peaker> or <*>
09:54:04 <roconnor> stupid math notation
09:54:24 <Peaker> @type (<^)
09:54:25 <lambdabot> Not in scope: `<^'
09:54:54 <Arnar> @src modify
09:54:54 <lambdabot> Source not found. I am sorry.
09:55:00 <Arnar> @src Control.Monad.State.modify
09:55:01 <lambdabot> Source not found.
09:55:16 <Peaker> we have the Applicative Infix fmap <^ and ^> for <*>    maybe <^ and ^> should be fmap and flip fmap, and <* and *> should be <*> and flip <*>
09:55:28 <Arnar> I was just thinking, I'd write: modify f = get >>= (return . f) >>= put
09:55:37 <Arnar> how would you guys write it?
09:55:41 <Peaker> Arnar: modify f = do { x <- get ; put (f x) }
09:56:23 <Badger> :t modify
09:56:25 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
09:56:29 <Peaker> modify f = put . f =<< get
09:56:30 <opqdonut> i'd write fmap f get >>= put
09:57:20 <Saizan> ?type \f -> put . f =<< get
09:57:22 <lambdabot> forall (m :: * -> *) a. (MonadState a m) => (a -> a) -> m ()
09:57:44 <Saizan> +1
09:58:05 <Saizan> i wan't sure the precedences worked out fine there
09:58:25 <Arnar> Peaker: looks good.. but why put the get *after* the put?
09:58:44 <Peaker> Arnar: because (.) is flipped, I use a flipped bind too
09:59:01 <Arnar> Peaker: ah, I see
09:59:17 <Peaker> I wish (.) and ($) were flipped
09:59:28 <vixey> ?
09:59:30 <Peaker> and (f a) meant (a f) (so normal application syntax flipped too)
09:59:36 <andyjgill> Does anyone know who is in charge of the haskell mailman mailing lists?
09:59:42 <vixey> that would make everything unreadable...
09:59:54 <Arnar> vixey: not if you read Hebrew
10:00:02 <Peaker> vixey: I think it would make everything readable, as you see the function applications being applied sequentially
10:00:09 <vixey> I tried to learn Hebrew once but I did not manage :(
10:00:33 <Peaker> vixey: do you think Unix pipes would be more usable/readable if they were reversed?
10:00:54 <Peaker> I see (.) as the unix pipe, basically :)
10:00:56 <vixey> Peaker, I don't consider sequential execution of haskell and I don't want to have to
10:01:14 <Peaker> vixey: not sequential execution, sequential application
10:01:25 <EvilTerran> vixey, i think (x f) instead of (f x) would probably be easier, if you didn't already expect the other way around
10:01:38 <roconnor> vixey: you don't find it strange that the inputs are on the right?
10:01:49 <roconnor> most diagrams puts inputs on the left
10:01:57 <roconnor> at least in english
10:02:07 <Arnar> Peaker: I've used more fun compositions (in math) than unix pipes, so I'm happy with it as is :)
10:02:07 <vixey> I think that our number system is the wrong way around
10:02:07 <vixey> like 001 should be one hundred
10:02:23 <EvilTerran> seeing as otherwise repeated function application ends up RTL
10:02:23 <Peaker> given some: bigData $ extractThis . thenAdd1 . thenCompress . andFinallySort
10:02:23 <vixey> roconnor, like how in category theory, some use ; instead of .  ?
10:02:36 <Arnar> vixey: you want a little-endian decimal system?
10:02:37 <roconnor> perhaps.  I didn't know that
10:02:45 <Peaker> Arnar: I want little-endian too
10:02:48 <Peaker> I hate big endian :P
10:02:48 <vixey> Arnar, yes
10:02:50 <EvilTerran> it'd also make the type syntax for functions more appropriate
10:02:50 <enticingjelly> is eta-reduction *always* safe, no matter wether strict or lazy, wether you have side effects or not?
10:02:59 <vixey> enticingjelly, no
10:03:07 <enticingjelly> vixey, can you give me an example?
10:03:48 <Arnar> Peaker, vixey: I'm not sure I agree.. the *first* thing you read is most significant
10:04:17 <Arnar> and for (f x) - the f is more important than the x
10:04:20 <vixey> enticingjelly, (\x :: B -> (\a :: A -> a) x) beta reduces to (\x :: B -> x), eta reduces to (\a :: A -> a)
10:04:22 <Peaker> Arnar: significance is subjective
10:04:28 <Arnar> Peaker: true.
10:04:39 <mreh> @src sortBy
10:04:39 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
10:04:41 <Peaker> Arnar: I like the indexing matching the coefficient
10:04:42 <vixey> Arnar, up is down
10:05:02 <Peaker> Arnar: digit * (base ^ index)    rather than: digit * (base ^ (length - 1 - index))
10:05:05 <Saizan> enticingjelly: you can affect sharing by eta-reduction, and there's always the monomorphism restriction
10:05:18 <Peaker> http://hpaste.org/13610 -- why is there no auto-derive for Control.Exception.Exception
10:05:19 <roconnor> vixey: does not type check
10:05:25 <enticingjelly> Saizan, vixey, so only with type systems?
10:05:41 <Arnar> Peaker: just index the stuff from right to left
10:05:53 <Peaker> Arnar: so I send the high indexes first?
10:06:12 <Peaker> Arnar: But index is basically the "number of things until this point"
10:06:14 <Arnar> Peaker: hehe.. well, I concede to your argument
10:06:58 <vixey> yeah don't eta reduce before type checking, and I think eta-reduction breaks confluence on well typed terms
10:07:18 <Peaker> Arnar: I think people hate little endian because we have a horrible mixture of big endian (hexadecimal representaiton, for example) with little endian (bytes in memory), and it confuses the hell out of people, who think little endian means changing your reading direction all the time or something
10:07:20 <enticingjelly> vixey, so, without a type system, is it safe?
10:07:28 <enticingjelly> vixey, http://www.lambda-bound.com/book/lambdacalc/node21.html
10:07:31 <roconnor> enticingjelly: I think you can turn vixey's example into something that prints as a side effect either once, or every time depending on if you eta reduce or not
10:07:32 <mreh> @type filter
10:07:33 <vixey> enticingjelly, not sure what safe means when you have no type system
10:07:34 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
10:07:49 <Arnar> Peaker: I found that many people think little-endian means reversing the whole string of bits
10:07:51 <enticingjelly> I don't quite understand under what circumstances eta-reduction would affect confluence
10:08:07 <mreh> @src not
10:08:07 <lambdabot> not True   =  False
10:08:07 <lambdabot> not False  =  True
10:08:18 <Peaker> Arnar: Well, above the CPU level, we really aren't exposed to bit indexing, so that may be true :)
10:09:14 <Arnar> Peaker: but if you think about it, the only "good" argument for little-endinanness comes from non-type-safety
10:09:21 <bremner> anybody got emacs inferior-haskell configured to do nice completion
10:10:05 <Peaker> Arnar: I think the simplicity of computing the coefficients is the argument for little endian, and the "knowing the order of magnitude of the number even if it is truncated" is the argument for big endian, other than that I think its all "market forces"
10:10:38 <Peaker> The latter is not a practical argument in real life, I don't think, so I prefer little endian :)
10:10:51 <roconnor> enticingjelly: eta-reduction can influence the inferred types if you are using Curry style typing.
10:10:58 <Arnar> Peaker: hmm, the argument I saw for little endianness is that if you interpret 1356 as a twodigit number, 56 makes more sense thatn 13
10:11:04 <vixey> enticingjelly, no I guess I'm making it up,  it's still confluent
10:11:06 <roconnor> enticingjelly: of course Church style typing will be safe.
10:11:25 <Peaker> Arnar: it makes more sense if the top digits are 0, which is often the case when you convert sizes
10:11:40 <enticingjelly> roconnor, vixey, ok, but let's suppose I don't have a type system. does it affect confluence and/or does it affect side effects?
10:11:56 <vixey> enticingjelly, the problem with eta reduction is when you introduce other eta rules, like   x :: ()  ~> () :: ()
10:12:08 <roconnor> enticingjelly: I'm pretty sure if evaluation has side-effects, then eta-reduction can change your semantics.
10:12:24 <roconnor> enticingjelly: although I can't quite figure out an example off the top of my head
10:12:28 <enticingjelly> i'm trying to construct an example, but I fail
10:13:00 <vixey> enticingjelly, with that,  you  get  \x :: () -> f x   eta-() reduces to \x :: () -> (),  eta-\ reduces to f
10:13:22 <mreh> @src sortBy
10:13:22 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
10:13:29 <enticingjelly> vixey, mhm
10:13:30 <mreh> is that an insertion sort anyone?
10:13:41 <vixey> enticingjelly, just eta reduction for functions in lambda calculus is ok, but when you add things like unit with their own eta rules it breaks... so the solution is to use eta expansion instead
10:13:56 <vixey> (which is necessarily type directed)
10:14:05 <roconnor> \x -> (\y -> print "hello") x  vs (\y -> print "hello")
10:14:05 <rwbarton> mreh: Yeah.  That's not the real source though.
10:14:15 <mreh> that confuses me
10:14:30 <EvilTerran> mreh, the one ghc uses is a clever implementation of mergesort
10:15:01 <mreh> ill show you my quicksort in a second, a generic quicksort
10:15:12 <mreh> the damn thing wont compile
10:15:21 <enticingjelly> roconnor, maybe... hmm... i think i have something
10:15:37 <EvilTerran> (in before comments to the effect of "it's not quicksort if it's not in-place")
10:16:16 <mreh> EvilTerran: what do you mean
10:16:31 <enticingjelly> let's suppose f and h have side effects. with strict evaluation: g ((\x.fx) a) (h b)
10:16:56 <enticingjelly> now without eta evaluation (h b) gets evaluated, so its side effect applies
10:17:38 <enticingjelly> but f's not yet because... uh. because you need some contrived evaluation scheme for my example to work ;)
10:18:01 <mreh> does anyone in here get paid alot of money to do all this hard work, i sure hope so, im busting my balls here
10:18:21 <EvilTerran> mreh, i've seen folk in here start arguments over the exact definition of quicksort whenever anyone mentions a haskell implementation
10:18:33 <mreh> haha
10:18:47 <roconnor> haskell's quicksort is tree sort! god damn it!
10:19:12 <EvilTerran> i think the point of them being that the complexity's really not that good on immutable cons-lists
10:19:23 <Osah_> what is a sample known software written in Haskell ?
10:19:26 <roconnor> enticingjelly: ya.  I think something like that works, but I can't quite get it.  I bet in #ocaml they know
10:19:26 <EvilTerran> with most algorithms that look like quicksort
10:19:33 <Peaker> Osah_: xmonad, darcs, ghc
10:19:38 <b_jonas> ghc
10:19:53 <IWannaLog> hoogle
10:19:55 <enticingjelly> what is the formal definition of strict evaluation?
10:19:56 <roconnor> quicksort is supposed to be in place
10:20:05 <Peaker> Does anyone here use the new existential Control.Exception?
10:20:08 <vixey> enticingjelly, you can find one in R5RS
10:20:19 <enticingjelly> vixey, R5RS?
10:20:27 <gweiqi> scheme
10:20:35 <vixey> roconnor: (foo (lambda (x) (f (p1) (p2) x))) vs  (foo (f (p1) (p2)))
10:20:39 <mreh> it's a recursive algorithm, i suppose in C you can pass a pointer all the way down the stack right?
10:20:48 <mreh> but in haskell, no sir
10:20:54 <vixey> roconnor, uh some kind of curried scheme dialect :L
10:21:03 <EvilTerran> mreh, er, what?
10:21:14 <rwbarton> mreh: it simply has to do with doing things in-place using arrays, vs. using linked lists.
10:21:15 * vixey &
10:21:17 <roconnor> vixey: ah
10:21:26 <rwbarton> mreh: of course you can write the algorithm with arrays in haskell also.
10:21:31 <mreh> i was just wondering how you apply a recursive function to a structure in place
10:21:38 <EvilTerran> mreh, with monads!
10:21:41 <enticingjelly> vixey, which side effect changes?
10:21:43 <mreh> but you need a mutable structure
10:21:46 <EvilTerran> exactly
10:21:48 <EvilTerran> hence, monads
10:21:55 <mreh> huzzah!
10:21:56 <EvilTerran> to encapsulate side-effects, such as mutating a structire
10:22:07 <enticingjelly> vixey, with strict evaluation (if it is what i think it is), it appears the same to me, but I might be wrong
10:22:12 <Osah_> no offense but i dont see any 'real' software made with Haskell -- in e.x an Adobe product
10:22:18 <IWannaLog> What is the alogrithm of sort used by Haskell ,
10:22:20 <EvilTerran> mreh, like this: http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-ST.html
10:22:38 <sclv> Osah_: by that logic there's no "real" software made with, e.g., python or ruby either.
10:22:40 <EvilTerran> Osah_, so, what, an optimising compiler isn't "real software"?
10:22:50 <IWannaLog> Osah_: but maybe the goals is not the same
10:22:53 <johnnowak> Osah_: i'm not sure adobe products being written in haskell would inspire any confidence...
10:22:54 <olsner> hmm, what'd be the best way to embed arbitrary data items in a large unboxed array? essentially, I want to implement a manually garbage-collected heap in haskell and put things like char arrays inside it
10:22:59 <EvilTerran> Osah_, or a window manager? or a version control system?
10:23:17 <sclv> (or if you stick to Adobe, I suppose in Java for that matter)
10:23:22 <mreh> mySortBy (x:xs) f = mySortBy (filter (f x) xs) f ++ [x] ++ mySortBy (filter not(f x) xs) f
10:23:31 <mreh> > let mySortBy (x:xs) f = mySortBy (filter (f x) xs) f ++ [x] ++ mySortBy (filter not(f x) xs) f
10:23:32 <lambdabot>   <no location info>: parse error on input `;'
10:23:34 <pejo> Osah, read the reports available on cufp.galois.com for examples of companies using functional programming.
10:24:33 <mreh> d'oh!
10:25:09 <mreh> is there such thing as a un-filter?
10:25:17 <roconnor> enticingjelly: (\f -> print "hello"; f ()) (print "world"; id)  vs  (\f -> print "hello"; f ()) (\x -> (print "world"; id) x)  ?
10:25:23 <roconnor> does that work?
10:25:39 <mreh> @src unfilter
10:25:39 <lambdabot> Source not found. The more you drive -- the dumber you get.
10:25:41 <olsner> @ty filter . (not .)
10:25:42 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
10:26:04 <roconnor> enticingjelly: I'm mixing up the ocaml and haskell syntax there
10:27:15 <enticingjelly> roconnor, yes. yes, I think that looks good.
10:27:24 <mreh> olsner : I wish i understood why that works
10:28:31 <mreh> > filter . (not .) [3, 2, 1] >2
10:28:33 <lambdabot>   Couldn't match expected type `a -> Bool'
10:28:40 <mreh> > filter . (not .) [3, 2, 1] (>2)
10:28:41 <lambdabot>   Couldn't match expected type `a -> a1 -> Bool'
10:28:45 <b_jonas> mreh: parenthesis
10:28:55 <mreh> (> filter . (not .)) [3, 2, 1] (>2)
10:29:01 <mreh> haha
10:29:05 <b_jonas> mreh: also, reverse the arguments
10:29:09 <olsner> > filter . (not .) $ (>2) $ [3,2,1]
10:29:10 <lambdabot>   Couldn't match expected type `a -> Bool'
10:29:11 <b_jonas> criterion first, list second
10:29:14 <mreh> > (filter . (not .)) [3, 2, 1] (>2)
10:29:16 <lambdabot>   Couldn't match expected type `a -> Bool'
10:29:20 <b_jonas> yeah, like that
10:29:25 <b_jonas> but reverse the two arguments
10:29:36 <mreh> > (filter . (not .)) (>2) [3, 2, 1]
10:29:37 <lambdabot>   [2,1]
10:29:41 <mreh> yey
10:29:58 <mreh> but i dont know why
10:30:08 <IWannaLog> mreh: It'a an obfuscated code contest ?
10:30:58 <olsner> IWannaLog: nah, it's merely compressed :)
10:30:59 <dmwit> > filter (<= 2) [3, 2, 1]
10:30:59 <b_jonas> mreh: well, do you know what (.) does?
10:31:00 <lambdabot>   [2,1]
10:31:05 <b_jonas> olsner: lol
10:31:41 <dmwit> > filter (not . (>2)) [3, 2, 1]
10:31:42 <lambdabot>   [2,1]
10:31:47 <roconnor> (filter . (not .)) (>2) [3, 2, 1] ==> (filter ((not .) (>2))) [3,2,1]  (definition of (.))
10:32:04 <b_jonas> > tail [3, 2, 1]
10:32:05 <mreh> . is the composition function
10:32:06 <lambdabot>   [2,1]
10:32:21 <b_jonas> > let { tail = filter (<= 2) } in tail [3, 2, 1]
10:32:23 <lambdabot>   [2,1]
10:32:24 <mreh> > tail [2, 3, 1]
10:32:25 <lambdabot>   [3,1]
10:32:29 <mreh> doy!
10:32:30 <roconnor> (filter ((not .) (>2))) [3,2,1] ==> filter (not . (>2)) [3,2,1]  (application)
10:32:43 <mreh> b_jonas
10:32:48 <mreh> . is composition
10:32:51 <dmwit> > let tail = filter (<= 2) in tail [3, 2, 1] -- what are all those brackets about, b_jonas? ;-)
10:32:52 <Peaker> mreh: a . b  -- apply a to the result of b.   (a.) . b    -- apply a to the result of the result of b.  ((a.).) . b -- apply a to the result of the result of the result of b, and so on :)
10:32:52 <lambdabot>   [2,1]
10:33:16 <mreh> a . b <=> (a (b )) ?
10:33:26 <dmwit> mreh: no
10:33:33 <Peaker> mreh: a . b x <=> (a (b x))
10:33:34 <roconnor> (a . b) x === a (b x)
10:33:36 <czShadoW> @src (.)
10:33:37 <lambdabot> (f . g) x = f (g x)
10:33:38 <dmwit> (a . b) x <=> a (b x)
10:33:40 <Peaker> parens missing in mine, yeah
10:33:41 <mreh> yeah that one
10:33:51 <johnnowak> mreh: it applies a to the *result* of b, not b
10:34:04 <dmwit> mreh: a $ b <=> (a (b)) -- this one is true, though
10:34:16 <roconnor> @src ($)
10:34:16 <dmwit> The parens are a little weird.
10:34:16 <lambdabot> f $ x = f x
10:36:35 <Peaker> > "a $ b" : map (++" b") iterate (("(" ++) . (++".)")) "a"
10:36:36 <lambdabot>   Couldn't match expected type `[[Char]]'
10:36:51 <Peaker> > "a $ b" : map (++" b") $ iterate (("(" ++) . (++".)")) "a"
10:36:52 <lambdabot>   Couldn't match expected type `[[Char]]'
10:37:03 <Peaker> > iterate (("(" ++) . (++".)")) "a"
10:37:05 <lambdabot>   ["a","(a.)","((a.).)","(((a.).).)","((((a.).).).)","(((((a.).).).).)","((((...
10:37:24 <Peaker> > map (++" b") $ iterate (("(" ++) . (++".)")) "a"
10:37:25 <lambdabot>   ["a b","(a.) b","((a.).) b","(((a.).).) b","((((a.).).).) b","(((((a.).).)....
10:37:48 <Peaker> > "a $ b" : (map (++" b") $ iterate (("(" ++) . (++".)")) "a")
10:37:50 <lambdabot>   ["a $ b","a b","(a.) b","((a.).) b","(((a.).).) b","((((a.).).).) b","(((((...
10:37:54 <mreh> right, i just wrote this beast, tell me what you think
10:37:56 <mreh> mySortBy :: [a] -> (a -> a -> Bool) -> [a]
10:37:56 <mreh> mySortBy [] _ = []
10:37:56 <mreh> mySortBy (x:xs) f = mySortBy (filter (not . (f x)) xs) f ++ [x] ++ mySortBy (filter (f x) xs) f
10:38:00 <roconnor> I like to think of it as [a, fmap a, fmap (fmap a), fmap (fmap (fmap a)) ...
10:38:22 <roconnor> that way you can see that each (.) or fmap is lifting by one more argument
10:38:36 <b_jonas> mreh: we have Data.List.partition too
10:38:42 <b_jonas> mreh: it's a bit late, yeah
10:38:47 <olsner> 'iterate' is almost like a logging 'fix'
10:39:06 <b_jonas> > partition (<2) [3,2,1]
10:39:07 <Peaker> mreh: flip your arg order and you become very much like sortBy. Also you can use -> Ordering instead of Bool, and then compare with LT or GT for more clarity about the comparison taking place
10:39:08 <lambdabot>   ([1],[3,2])
10:39:32 <Peaker> olsner: iterate has a "starting value"...
10:39:33 <b_jonas> mreh: also, you know how that variant goes crazy with an already sorted list
10:39:36 <mreh> @type LT
10:39:37 <lambdabot> Ordering
10:39:48 <Peaker> @src Ordering
10:39:48 <lambdabot> data Ordering = LT | EQ | GT
10:39:51 <IWannaLog> @type partition
10:39:53 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
10:40:03 <mreh> how do i compare an Ordering?
10:40:10 <Peaker> > partition (even . ord) "hello world!"
10:40:11 <dmwit> You shouldn't need to.
10:40:11 <IWannaLog> > partition (\x -> x == 0) [1, 2, 3, 4, 0]
10:40:11 <lambdabot>   ("hll rld","eowo!")
10:40:13 <lambdabot>   ([0],[1,2,3,4])
10:40:48 <mreh> true
10:40:48 <mreh> i compare them against the literals
10:40:48 <dmwit> mreh: You can use case to pattern match on Orderings.
10:40:54 <Peaker> dmwit: well, filter wants an (a -> Bool), and he has an a -> Ordering, so converting to Bool by comparing to LT or GT is ok, IMO
10:41:29 <mreh> are Orderings in the prelude?
10:41:31 <dmwit> I'm not sure why we're suggesting using an Ordering in the first place.
10:41:34 <dmwit> mreh: yes
10:42:09 <Peaker> dmwit: well, it makes the API clearer than a Bool-based API
10:42:21 * dmwit disagrees
10:42:38 <mreh> im torn between the two personally
10:42:42 <Peaker> dmwit: what kind of comparison does (a -> a -> Bool) represent? (<=) or (<) or (>) ?
10:42:50 <dmwit> Who cares?
10:42:56 <Peaker> dmwit: the guy who wants to use it to sort?
10:43:07 <dmwit> Let him pick his favorite.
10:43:11 <dmwit> It will still come out sorted.
10:43:29 <chrisdone> what was used to make the IRC-activity-over-time graphs?
10:43:31 <mreh> my API allows you to use inbuilt functions rather than having to define your own
10:43:40 <Peaker> he will have to use trial and error to see what the API does, or read more documentation, instead of the type making it clear
10:43:53 <dmwit> Peaker: The type you suggest doesn't make it clear, either.
10:44:00 <dmwit> (Surprise!)
10:44:07 <mapreduce> Other than when you implement an a -> a -> Bool as (>) etc., it's easy to get such a thing wrong.
10:44:10 <Peaker> dmwit: (a -> a -> Ordering) does, sorts are obviously ascending by default :)
10:44:21 <mapreduce> @src Ordering
10:44:21 <lambdabot> data Ordering = LT | EQ | GT
10:44:28 <dmwit> Peaker: 1. That's not obvious. 2. The type doesn't make that clear, like I said.
10:44:46 <mreh> it's a matter of opinion
10:44:46 <mapreduce> Ordering seems more verbose but harder to get wrong.  and more general.
10:44:48 <Peaker> dmwit: it doesn't make it clear the sort is ascending, but it makes it clear what the function you give is supposed to return
10:45:02 <dmwit> Peaker: (a -> a -> Bool) makes the same thing clear.
10:45:08 <dmwit> You should return a Bool.
10:45:21 <Peaker> dmwit: In the Ordering type, I know what to return when they are equal
10:45:32 <vixey> Peaker, I don't see why they are ascending if you use Ordering...
10:45:51 <mreh> Peaker: The bool function will define the ordering of the sort
10:45:57 <Peaker> vixey: Right, that part still needs documentation. Perhaps  ascendingSort or ascSort is a better name for that purpose
10:46:00 <mreh> that's it's power
10:46:06 <dmwit> Peaker: In the Bool type, it doesn't matter what you return when they are equal.
10:46:15 <Peaker> dmwit: it does for the sort's stability
10:46:29 <dmwit> Referential transparency should make stability a non-issue.
10:46:56 <Peaker> dmwit: No, because (a -> a -> Bool) is allowed to compare not-the-whole-a
10:47:16 * dmwit nods
10:47:23 <IWannaLog> Peaker: it's (<=)
10:47:27 <dmwit> That is perhaps the first good point you made.
10:47:41 <dmwit> But, again, I have to ask: is that worth the extra hassle of using Ordering?
10:47:44 <Peaker> dmwit: didn't mean for the tone to become hostile
10:48:00 * dmwit backs off
10:48:00 <olsner> Peaker: yeah, *almost* like :) you can use undefined as the starting value, use the last element of the infinite 'iterate' sequence, as well as disregard sharing and it's even more almost the same :P
10:48:08 <Peaker> dmwit: I think converting Ordering to Bool via: (==LT) or (/=GT) or such is easy enough
10:48:11 <dmwit> Peaker: Sorry.  I didn't either...
10:48:37 <mreh> with the boolean version you dont need to define a new function to order the elements
10:48:46 <mreh> if you're using numbers you can use the built in functions
10:48:54 <dmwit> :t compare -- mreh
10:48:55 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
10:50:05 <mreh> say i want to negate that?
10:50:05 <mreh> is there an ordering negator
10:50:05 <monochrom> Godawful. The impossible has happened! #haskell reaches 600 and surpasses #c and #c++!
10:50:05 <Peaker> > pred GT
10:50:05 <lambdabot>   EQ
10:50:05 <Peaker> > maxBound :: Ordering
10:50:05 <lambdabot>   GT
10:50:21 <IWannaLog> :t sort
10:50:22 <lambdabot> forall a. (Ord a) => [a] -> [a]
10:50:25 <Peaker> mreh: you can just convert Ordering to Bool trivially by comparing it to LT or GT
10:50:33 <roconnor> haskell has failed at fail
10:50:33 <IWannaLog> :t sortBy
10:50:35 <Peaker> mreh: then use not
10:50:35 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
10:50:49 <dmwit> mreh: flip compare
10:51:02 <dmwit> > flip compare 0 3
10:51:03 <IWannaLog> there is not a method of type (a -> a -> Bool) -> [a] -> [a] ?
10:51:04 <lambdabot>   GT
10:51:05 <mreh> but the input of my function is not a boolean function in that case
10:51:12 <dmwit> :t sortBy -- IWannaLog
10:51:14 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
10:51:16 <roconnor> > fail (fail "cannot reach this message")
10:51:17 <IWannaLog> @hoogle (a -> a -> Bool) -> [a] -> [a]
10:51:18 <lambdabot>       No instance for (Show (m a))
10:51:18 <lambdabot>        arising from a use of `show' at <in...
10:51:18 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
10:51:18 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
10:51:18 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
10:51:24 <dmwit> IWannaLog: Not quite. =)
10:51:30 <mreh> what is the general consensus?
10:51:32 <IWannaLog> @src nubBy
10:51:33 <roconnor> > fail (fail "cannot reach this message") :: Either String String
10:51:33 <lambdabot> nubBy eq []             =  []
10:51:33 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
10:51:34 <lambdabot>   Left ""
10:51:38 <mreh> a -> a -> Bool?
10:51:55 <vixey> ♪ 9
10:51:57 <IWannaLog> nubBy (==) [1, 2, 1, 2, 3, 4]
10:52:06 <IWannaLog> > nubBy (==) [1, 2, 1, 2, 3, 4]
10:52:08 <lambdabot>   [1,2,3,4]
10:52:09 <Peaker> roconnor: list monad's fail...
10:52:12 <roconnor> @src nub
10:52:13 <lambdabot> nub = nubBy (==)
10:52:20 <roconnor> Peaker: yep
10:52:35 <dmwit> IWannaLog: \f -> sortBy (comparing f) -- has type (a -> a -> Bool) -> [a] -> [a]
10:52:41 <Liskni_si> is there yet a way for TH to generate INLINE pragmas, or any way one can go around it?
10:52:49 <IWannaLog> There is no sort method with boolean
10:52:55 <Peaker> roconnor: debug mode could trace on fail or something :)
10:52:55 <IWannaLog> :(
10:53:03 <olsner> @ty fail (fail undefined)
10:53:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a
10:53:14 * IWannaLog wants a fast sort algorithm, and a -> a -> Bool is necessary for that.
10:53:20 <dmwit> > let sortBool = sortBy . comparing in sortBool (<=) [5,3,4,2,1] -- IWannaLog
10:53:21 <lambdabot>       No instance for (Ord (b -> Bool))
10:53:21 <lambdabot>        arising from a use of `compari...
10:53:24 <Peaker> IWannaLog: why is that "fast"?
10:53:30 <BONUS> @hoogle (Ord a) => (t -> a) -> t -> t -> t
10:53:30 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
10:53:31 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
10:53:31 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
10:53:33 <dmwit> oy
10:53:39 <vixey> :t \f -> sortBy (comparing f)
10:53:41 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> [a]
10:54:01 <Peaker> :t sortBy . comparing
10:54:02 <lambdabot> forall b a. (Ord a) => (b -> a) -> [b] -> [b]
10:54:19 <IWannaLog> <= or < or > or >= is the simplest to use because you don't care about equality when sorting
10:54:26 <dmwit> > let sortBool f = sortBy (\x y -> if f x y then LT else GT) in sortBool (<=) [5,3,4,2,1] -- hmmm, not really right
10:54:28 <lambdabot>   [1,2,3,4,5]
10:54:30 <vixey> :t sortBy . (comparing`on`)
10:54:32 <lambdabot>     Occurs check: cannot construct the infinite type: b = b -> a
10:54:32 <lambdabot>     Probable cause: `comparing' is applied to too few arguments
10:54:32 <lambdabot>     In the first argument of `on', namely `comparing'
10:54:51 <dmwit> IWannaLog: How about that one?
10:55:01 <dmwit> > let sortBool f = sortBy (\x y -> if f x y then LT else GT) in sortBool (<) [5,3,4,2,1]
10:55:01 <IWannaLog> Which one ?
10:55:03 <lambdabot>   [1,2,3,4,5]
10:55:08 <Peaker> dmwit: btw, you can actually get equality from a Bool func by seeing what you get when you call it flipped :)
10:55:11 <IWannaLog> no too slow
10:55:23 <dmwit> Too slow?
10:55:27 <dmwit> O(n log n)
10:55:32 <dmwit> You can't do better than that.
10:55:48 <IWannaLog> @src sortBy
10:55:48 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
10:55:57 <IWannaLog> @src insertBy
10:55:58 <lambdabot> insertBy _   x [] = [x]
10:55:58 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
10:55:58 <lambdabot>                                  GT -> y : insertBy cmp x ys'
10:55:58 <lambdabot>                                  _  -> x : ys
10:56:07 <dmwit> IWannaLog: That's a specification; the actual implementation is merge sort.
10:56:08 <Gracenotes> insertion sort
10:56:10 <IWannaLog> Did I dream ?
10:56:18 <IWannaLog> Ah okay.
10:56:30 <eyeris> Does anyone here use emacs over a remote X connect from a chroot environment?
10:56:38 <Gracenotes> well, you can't do better than O(n log n), but there's still constants :P
10:56:42 <roconnor> @pl (x -> compare x (not x))
10:56:43 <lambdabot> (line 1, column 4):
10:56:43 <lambdabot> unexpected ">"
10:56:43 <lambdabot> expecting variable, "(", operator or ")"
10:56:47 <IWannaLog> I was thinking of constant
10:56:54 <roconnor> @pl (\x -> compare x (not x))
10:56:55 <lambdabot> ap compare not
10:56:55 <IWannaLog> and merge sort is O (n ^2)
10:57:03 <dmwit> Gracenotes: You can do better, but you have to know more about the data you're sorting than just a mere comparison operator.
10:57:06 <Peaker> IWannaLog: merge sort is O(N log N)
10:57:07 <koeien> one of the few algorithms for which the best known lower bound is reached
10:57:08 <roconnor> (ap compare not) True
10:57:16 <roconnor> > (ap compare not) True
10:57:16 <koeien> IWannaLog: O(N log N)
10:57:17 <IWannaLog> merge sort which one is ?
10:57:18 <lambdabot>   GT
10:57:21 <roconnor> > (ap compare not) False
10:57:23 <lambdabot>   LT
10:57:27 <koeien> quicksort is O(N^2) worst case
10:57:29 <dmwit> Gracenotes: For example, if you're sorting a type with a finite range, you can do counting-sort (or similar) in O(n) time...
10:57:32 <roconnor> > (compare`ap`not) False
10:57:34 <lambdabot>   LT
10:57:38 <Gracenotes> the constant for quicksort is better compared to that of mergesort, assuming the data is reasonably random-ish
10:57:38 <Peaker> koeien: I think there are plenty of O(N) algorithms, which are at the lower bound
10:57:50 <roconnor> compare`ap`not is the aztec god of comparing using booleans
10:57:51 <koeien> Peaker: sure, but "few" is informal here
10:57:58 <dmwit> IWannaLog: merge sort is O(n log n)
10:58:13 <Peaker> koeien: sure, "most" problems are not even soluble at all, Godel-wise :)
10:58:16 <Gracenotes> dmwit: heh, implementing radix sort in Haskell, that'd be fun :)
10:58:29 <koeien> Peaker: :)
10:58:30 <dmwit> IWannaLog: Even better: in a lazy language, (take k . sort) is O(k log n).
10:58:34 <Peaker> koeien: the infinite number of problems has a higher ordinality than the infinite number of solutions, and all that
10:58:56 <roconnor> @type (\f -> f`on`compare`ap`not)
10:58:57 <dmwit> Gracenotes: It's actually pretty easy.
10:58:57 <Peaker> dmwit: I wondered if that was accurate, or just someone's intuition
10:58:58 <koeien> quantum algorithms are fun!
10:58:58 <lambdabot> forall c. (Ordering -> Ordering -> c) -> Bool -> Bool -> c
10:59:02 <dmwit> Gracenotes: accumArray is your friend
10:59:09 <Gracenotes> ah. hm
10:59:12 <roconnor> um
10:59:35 <roconnor> @type (\f -> compare`ap`not`on`f)
10:59:36 <lambdabot>     Couldn't match expected type `b -> c'
10:59:36 <lambdabot>            against inferred type `Ordering'
10:59:36 <lambdabot>     Probable cause: `compare' is applied to too many arguments
10:59:45 <roconnor> @type (\f -> (compare`ap`not)`on`f)
10:59:46 <lambdabot>     Couldn't match expected type `b -> c'
10:59:47 <lambdabot>            against inferred type `Ordering'
10:59:47 <lambdabot>     Probable cause: `compare' is applied to too many arguments
10:59:54 <roconnor> anyhow
10:59:58 <Gracenotes> also... does anyone recall the name/url describing the task of implementing a counting function in various languages?
11:00:09 <Gracenotes> that is, a function that returned a function that counted from a specific number onwards
11:00:24 <roconnor> how does a function count?
11:00:28 <Peaker> count i = [i..] ?
11:00:32 <monochrom> Something is wrong with (take 1 . sort) being O(k log n).  (take 1 . sort) would be O(log n). I would be damned.
11:00:41 <Gracenotes> each invocation of the function returns an integer one higher than the last
11:00:54 <IWannaLog> Gracenotes: impossible in clean Haskell
11:00:59 <Peaker> Gracenotes: referential transparency and all that?
11:00:59 <vixey> count = enumFrom
11:01:05 <roconnor> Gracenotes: my haskell ears doesn't understand what function invocation is. :D
11:01:15 <EvilTerran> monochrom, i was thinking O(n.log k) would be more plausible
11:01:25 <vixey> Gracenotes:  inc = modify (+1) >> get
11:01:29 <Gracenotes> yes, and there was a page about which languages could do it and which couldn't
11:01:36 <vixey> @let pg = modify (+1) >> get
11:01:37 <lambdabot>  Defined.
11:01:37 <Gracenotes> for example, JavaScript can easily do it
11:01:39 <vixey> :t pg
11:01:40 <lambdabot> forall (m :: * -> *) b. (MonadState b m, Num b) => m b
11:01:46 <vixey> > runState pg 0
11:01:47 <lambdabot>   (1,1)
11:01:49 <Gracenotes> I was wondering if anyone knew what the page was :)
11:01:52 <dmwit> Gracenotes: Paul Graham's stupid comparison essay?
11:01:53 <vixey> > runState (pg >> pg >> pg) 0
11:01:54 <lambdabot>   (3,3)
11:02:03 <Gracenotes> dmwit: hm, might have been
11:02:07 <vixey> @go unsafePerformPaulGraham
11:02:08 <dmwit> http://www.paulgraham.com/accgen.html
11:02:09 <lambdabot> No Result Found.
11:02:14 <roconnor> *L*
11:02:18 <EvilTerran> roconnor, you could do it in MonadCont, couldn't you?
11:02:20 <roconnor> sorry
11:02:38 <roconnor> I thought dmwit's response was the google reply to vixy
11:02:45 <dmwit> Gracenotes: It's not really a very good comparison, because he considers immutable numbers out of the question.
11:02:48 <roconnor> EvilTerran: probably
11:03:11 <roconnor> EvilTerran: I don't know why that would be prefered for MonadState
11:03:16 <dmwit> If you refuse immutability, *anything* will look bad in Haskell. =)
11:03:18 <EvilTerran> (that was silly question to ask, you can do anything in monadcont :P)
11:03:26 <EvilTerran> roconnor, i was thinking coroutines in general
11:03:35 <Gracenotes> dmwit: yeah, some of the examples seemed quite distinct from the others
11:03:35 <roconnor> right
11:03:54 <Gracenotes> I just wanted to take a look at the page again, because iirc it was linked from the Haskell wiki
11:04:16 <EvilTerran> or, as it's listed on that page, you can do it in the IO monad with IORefs
11:04:23 <monochrom> Someone should mock Paul Graham. Here is one way. "try to do the same thing as C's strcat in your language. note that x++y doesn't count. you must overwrite stuff. you must have the potential to buffer-overflow and stack-overflow and all that unsafety."
11:04:41 <EvilTerran> monochrom, i frequently mock paul graham
11:04:53 <EvilTerran> seeing as he's fallen straight into his own "blub paradox"
11:05:06 <monochrom> what is blub paradox?
11:05:17 <Gracenotes> I just read the blub paradox article today :)
11:05:27 <Gracenotes> @go blub paradox
11:05:27 <roconnor> dmwit: wow, that is a terrible description of the problem
11:05:29 <lambdabot> http://www.paulgraham.com/avg.html
11:05:29 <lambdabot> Title: Beating the Averages
11:05:29 <vixey> lol monochrom
11:05:46 <Gracenotes> wait, what?
11:05:56 <dmwit> roconnor: ugh, no kidding
11:06:18 <dublpaws> would  d(dx/dt)/dt  be a natural transformation from velocity to acceleration?
11:06:57 <koeien> dublpaws: yes, but this is not really the appropriate channel. (if you by x denote position, and dx/dt velocity)
11:07:07 <Gracenotes> though, anyone care to explain to reason for said mockery?
11:07:09 <Heffalump> do you mean natural transformation in the categorical sense?
11:07:11 <vixey> dublpaws, to be a natural transform means you distribute over (.) and have a right/left identity?
11:07:19 <Gracenotes> *the reason
11:08:14 <dublpaws> okay koeien, thanks, just trying to grok natural transformation
11:08:31 <roconnor> @remember monochrome "try to do the same thing as C's strcat in your language. note that x++y doesn't count. you must overwrite stuff. you must have the potential to buffer-overflow and stack-overflow and all that unsafety."
11:08:32 <lambdabot> Good to know.
11:08:36 <monochrom> Gracenotes: It is like requiring "you must use a GUI, no command line allowed" or "you must use Windows, MacOS not allowed" or "you must use RISC, CISC not allowed".
11:08:58 <EvilTerran> Gracenotes, he is so obsessed with lisp that he can't see that other things might be better; his "blub paradox" nonsense is his claim that anyone who prefers another language to lisp must've fallen into that trap themselves
11:08:58 <vixey> koeien, please see: http://conal.net/blog/posts/beautiful-differentiation/ and http://conway.rutgers.edu/~ccshan/wiki/blog/posts/Differentiation/
11:09:22 <monochrom> roconnor: I am monochrom, not monochrome
11:09:22 <EvilTerran> only being blinded by obsession with their $not_lisp instead of lisp
11:09:29 <roconnor> oops
11:09:38 <roconnor> @forget monochrome "try to do the same thing as C's strcat in your language. note that x++y doesn't count. you must overwrite stuff. you must have the potential to buffer-overflow and stack-overflow and all that unsafety."
11:09:39 <lambdabot> Done.
11:09:44 <roconnor> @remember monochrom "try to do the same thing as C's strcat in your language. note that x++y doesn't count. you must overwrite stuff. you must have the potential to buffer-overflow and stack-overflow and all that unsafety."
11:09:44 <lambdabot> Nice!
11:09:45 <koeien> again lol
11:09:50 <ddarius> For dublpaws' question to make sense he'd have to specify what category he's talking about.
11:09:53 <vixey> EvilTerran: makes a good point though
11:10:07 <Gracenotes> EvilTerran: I had assumed when reading the article that he was introducing the idea of the Blub language as a general idea, not just a way to worship Lisp
11:10:18 <ddarius> vixey: A natural transformation is like a polymorphic function F a -> G a.
11:10:27 <vixey> ddarius, oh ok
11:10:43 <vixey> ddarius, I don't know why I can't seem to remember that...
11:10:44 <EvilTerran> Gracenotes, yes, i see that; however, he doesn't seem to have realised that *his* "Blub" is lisp
11:10:44 <dmwit> Gracenotes: I think he was.  But basically all of his other articles worship Lisp.
11:10:45 <koeien> vixey: thanks
11:10:53 <Elly> EvilTerran: I agree with GraceNotes; Graham is just making a point that you can't see "up" the power heirarchy
11:11:10 <vixey> you got to admit lisp is pretty cool though :p
11:11:11 <EvilTerran> Elly, in that article, yes. i know that, that's not what i'm grumbling about
11:11:16 <Gracenotes> if such a hierarchy exists :)
11:11:17 <Elly> ahh, I see
11:11:35 <monochrom> If you read an article and it inspires you a more noble cause than the author has in mind, more power to you.
11:11:41 <sclv> its basically a strong thesis about paradigms and incommensurability, which in the sociology of science has been out of vogue for years now.
11:11:44 <EvilTerran> Elly, the problem is that many of his other articles make the very fallacy he was highlighting in other people in that one
11:11:49 <sclv> even kuhn disavowed that reading of his work.
11:12:20 <Gracenotes> Graham talked about Kuhn?
11:12:20 * Elly shrugs
11:12:32 <ddarius> Gracenotes: God I hope not.
11:12:38 <Gracenotes> heh
11:12:45 <sclv> whether or not he did, that's always the context i've understood the blub stuff to be in.
11:12:54 <monochrom> Kuhn talked about Graham? :)
11:13:07 <sclv> i.e. any arguments regarding that were better and more carefully thought through by the successors to kuhn.
11:13:30 <monochrom> Kuhn talked about Graham! :)
11:13:38 <koeien> *the* Kuhn?
11:14:00 <roconnor> @who Kuhn
11:14:00 <Gracenotes> back in my younger days (okay, not that long ago) I tried to write a essay applying Kuhn's paradigms to musical periods, e.g. neoclassicism. Lol, that fell apart quickly.
11:14:01 <lambdabot> Maybe you meant: echo ghc show thx what wn
11:14:15 <EvilTerran> *which* Kuhn?
11:14:23 <monochrom> The paradigm Kuhn.
11:14:38 <koeien> author of structure of revolutions in science
11:14:38 <roconnor> @where Kuhn
11:14:39 <lambdabot> I know nothing about kuhn.
11:14:46 * vixey either
11:15:02 <koeien> ehm, that should be 'structure of scientific revolutions'. at least, that's what i mean by "*the* Kuhn"
11:15:09 <Gracenotes> he's very appealing to those who study history
11:15:11 <roconnor> http://en.wikipedia.org/wiki/The_Structure_of_Scientific_Revolutions
11:15:22 <Gracenotes> for those who study science... eh....
11:15:42 <roconnor> @where+ Kuhn http://en.wikipedia.org/wiki/The_Structure_of_Scientific_Revolutions
11:15:43 <lambdabot> I will never forget.
11:15:45 <ddarius> Gracenotes: Revolution makes better history than evolution, damn the reality.
11:16:03 <philipp> is there a literal for infinity? or is 1/0 the only possibility?
11:16:10 <vixey> :t infinity
11:16:11 <lambdabot> Natural
11:16:15 <sclv> functional programming seems much more properly the land of popper :-)
11:16:25 <monochrom> Yes, either "revolution" should has its meaning dramatically broadened, or Kuhn, like Marx, was too obsessed with revolutions.
11:16:30 <Gracenotes> BEHOLD, THE COMING OF THE PARADIGM SHIFT. THE EPIPHENOMENON SHALL RISE UP AND SEIZE THE DAY!
11:16:36 <Gracenotes> erm :/
11:16:47 <philipp> vixey: in which module?
11:16:52 <roconnor> philipp: I think 1/0 is the cannonical way
11:17:00 <monochrom> Paradigm shifts I can agree, but not revolution.
11:17:00 <mreh> there never has been a truly marxist regeime
11:17:04 <vixey> idk
11:17:05 <koeien> @index infinity
11:17:06 <lambdabot> bzzt
11:17:23 <roconnor> @src readFloat
11:17:24 <lambdabot> Source not found. You untyped fool!
11:17:32 <philipp> roconnor: k, thanks
11:17:33 <mreh> nice, civil, revolutions
11:17:37 <Gracenotes> I do like the concept of epiphenomena, though
11:17:55 <mreh> is that to do with conciousness
11:18:08 <sclv> form is sedimented content, and syntax is too. :-)
11:18:18 <Gracenotes> it's phenomena that the current "model" can't explain
11:18:38 <EvilTerran> sclv, "sedimented"?
11:18:43 <mreh> are we talking Rupert Sheldrake
11:18:45 <Gracenotes> for instance, when people by and large thought everything rotated around the earth, planets made weird orbits
11:18:49 <mreh> and Terrenece Mckenna
11:19:10 <Gracenotes> people tried to explain it way by claiming that there were complicated epicycles
11:19:19 <sclv> EvilTerran: its from adorno.
11:19:42 <Gracenotes> the reality was that the other planets were orbiting around the sun, and the epicycles were just natural elliptical paths
11:19:57 <mreh> retrograde motion
11:20:06 <Gracenotes> yeah
11:20:51 <mreh> so epiphenomenalism is a denial of free will and conciousness etc
11:21:02 <mreh> absurdist, in my mind
11:21:12 <koeien> and then they say that haskell is complicated!! unbelievable
11:21:14 <monochrom> You can use Haskell to tell the story too. There was a time we did everything with Hindley-Milner plus single-parameter typeclasses. Then we found it awkward to write interfaces for collections. Then some time later we jumped on the bandwagon of multiple-parameter typeclasses. Etc.
11:21:25 <Gracenotes> mreh: I've never considered it philosophical... more scientific
11:21:39 <EvilTerran> mreh, that sounds like a bit of a jump from the concept of phenomena outside the model
11:21:44 <mreh> the two aren't indistint
11:21:51 <mreh> indistinct
11:21:57 <monochrom> Probably in two years we'll all jump on type families.
11:22:09 <vixey> blugh I don't have a clue about type families
11:22:21 <EvilTerran> i grok them, but i prefer fundeps at the moment
11:22:29 <Gracenotes> it's somewhat related to Weber's iron cages
11:22:46 <Gracenotes> except not as scary :3
11:23:23 <mreh> what context were we discussing epiphenomalism?
11:23:37 <monochrom> There is another thread. In the past we used monad for all abstractions. Now we do some abstractions with applicative or arrow.
11:23:39 <EvilTerran> Gracenotes mentioned it, then explained it
11:23:49 <not_much> is it possible to make a type deriving Show and then define some special cases of show?
11:23:58 <vixey> monochrom, someone uses Arrow ? :p
11:23:58 <EvilTerran> mreh, <Gracenotes> BEHOLD, THE COMING OF THE PARADIGM SHIFT. THE EPIPHENOMENON SHALL RISE UP AND SEIZE THE DAY!
11:24:07 <mreh> I know more about philosophy than that
11:24:07 <Gracenotes> erm yes :/
11:24:11 <monochrom> HXT uses Arrow. I use HXT. I like it.
11:24:21 <vixey> I saw your tutorial on HXT
11:24:23 * mreh joins #philosophy
11:24:47 <EvilTerran> mreh, there's people in ##philosophy
11:24:57 <vixey> oh that reminded me your parody with structured programming is hilarious
11:24:58 <mreh> why the double hash?
11:25:06 <monochrom> Hehe thanks.
11:25:14 <koeien> mreh: "unofficial" channel? i don't know. there is ##c as well.
11:25:16 <EvilTerran> mreh, because it's not associated with an open-source project, i think
11:25:30 <koeien> EvilTerran: there is "#math"
11:25:43 <Gracenotes> it's rather inconsistent
11:25:45 <not_much> is there ##c# for c sharp?
11:25:49 <vixey> koeien, you can tell it's a silly rule when nobody bothers to follow it
11:25:54 <Gracenotes> ##c-sharp, I think?
11:26:02 * koeien likes the idea of ##c#
11:26:18 <monochrom> I have a new parody of the "missing dollar". I learned javascript one night to do it. http://www.vex.net/~trebla/humour/missing_dollar.html  (to be off-topic :) )
11:27:15 <Gracenotes> monochrom: if (numregexp.test(field.value)) {} else {}
11:27:17 <Gracenotes> :P
11:27:20 <grul> wat and why?
11:27:30 <roconnor> monochrom: heh, that puzzle pissed me off.
11:27:37 * EvilTerran found it
11:27:56 <monochrom> Heh, I was too lazy to implement validation, but I wanted to leave the skeleton there so I could do it later.
11:28:04 <sclv> vat, obviously.
11:28:32 <mreh> what is logical solution to that missing dollar problem?
11:28:45 <roconnor> monochrom: this is nice
11:28:45 <monochrom> The logical solution is "wrong question".
11:28:58 <koeien> i don't see the problem really. it sums uncomparable values and gets a meaningless value of $29 ?
11:29:03 <Gracenotes> monochrom: took the words out of my mouth :)
11:29:03 <mreh> well, there must be faulty logic
11:29:13 <roconnor> Three guests went to a hotel and gave $5 to the bellhop to buy pizza. The pizza cost only $0. Of the $5 change, the bellhop kept $5 to himself and returned $0 to the guests.
11:29:19 <roconnor> So the guests spent $5, and the bellhop pocketed $5. Now $5+$5=$10, which was $5 more than the original $5. Where did the extra $5 come from!
11:29:46 <EvilTerran> mreh, of the money spent, the sum at the end counts the bellhop's money twice, and doesn't count the money returned to the guests.
11:29:49 <rwbarton> Where did the extra $0 come from!
11:30:23 <Gracenotes> or even better -- try it with 999, 1 and 1
11:30:23 <mreh> i heard a similar one with people paying for a meal and change being distributed
11:30:33 <Gracenotes> So the guests spent $2, and the bellhop pocketed $1. Now $2+$1=$3, which was $996 less than the original $999. Where did the missing $996 go!
11:30:44 <roconnor> :D
11:31:01 <monochrom> One annoying thing is it is hard to explain that the question itself is nonsense. (As you see, even mreh trusts the question.) When there is something you disagree with but it takes too long to refute, don't refute. Mock it! And that's what I did. In fact, a large, parameterized family of mocks.
11:31:16 <mreh> i haven't read it yet
11:31:22 <vixey> hehehehe
11:31:36 <Gracenotes> you trust it without reading it! o:
11:31:43 <EvilTerran> i approached it algebraically, and it almost immediately fell apart
11:31:57 <mreh> everyone does that all the time, have you ever read T&C for anything?
11:32:07 <vixey> yes
11:32:43 <vixey> I read T&C because I know you're not supposed to
11:32:51 <monochrom> What is T&C?
11:32:56 <Gracenotes> T&C?
11:32:57 <mreh> terms and coniditions
11:33:00 <vixey> terms and conditions ("the smallprint")
11:33:02 <eyeris> How can I search in emacs for *all* occurances of a string?
11:33:05 <mreh> my typing is awful today
11:33:11 <monochrom> Sometimes I do. Sometimes I don't.
11:33:13 <vixey> eyeris, M-% I guess ?
11:33:19 <EvilTerran> http://www.download.com/EULAlyzer/3000-2086_4-10464852.html ;)
11:33:21 <monochrom> I think I read 70% of GPLv2.
11:33:29 <vixey> eyeris, or C-s idk
11:33:34 <koeien> i read GPL v2 completely. GPL v3 partly
11:33:41 <Gracenotes> sometimes I pretend to read terms and conditions so I can pretend to feel better about accepting them ;)
11:33:43 <mreh> bedtime reading?
11:33:50 <eyeris> vixey that still seems to stop after the first match
11:33:51 <Peaker> eyeris: just repeat C-s.. Or you mean in elisp?
11:33:55 <monochrom> I do read food labels routinely. The ingredients.
11:34:00 <arw> reading is less important than understanding...
11:34:00 <Gracenotes> oh, me too
11:34:06 <eyeris> Peaker: I don't want to type the word every time
11:34:09 <mreh> arw: precisely
11:34:10 <vixey> eyeris, C-s wozzle C-s C-s C-s C-s C-s C-s C-s
11:34:12 <EvilTerran> monochrom, heh, i do that too; passes the time while i'm eating
11:34:16 <Peaker> eyeris: if you just repeat C-s multiple times it repeats the search
11:34:19 <mreh> get someone who knows to summarize it
11:34:24 <eyeris> Ahh, I see!
11:34:26 <mreh> the T&Cs are legal jargon
11:34:30 <monochrom> I take great joy in seeing "sodium banzoate" and say "I know what it's for!" :)
11:34:30 <vixey> or maybe there should be <return> in there
11:34:48 <eyeris> But there is still no way to make it open a new buffer with links to the locations of each occurance?
11:35:03 <vixey> eyeris,  dunno about that sounds cool though
11:35:21 <rwbarton> eyeris: M-x grep perhaps
11:35:43 <mreh> use a modern IDE, that will solve your problems
11:35:47 <rwbarton> eyeris: not exactly the same
11:36:37 <eyeris> mreh use a modern IDE that works remotely on linux and windows? Name it please.
11:36:42 <pejo> vixey, what did you want the termination checking for?
11:36:46 <mreh> jedit!
11:36:59 <koeien> eyeris: vim! :)
11:37:01 * koeien runs
11:37:03 <redocdam> just keep using emacs, ide's just sucks
11:37:15 <mreh> woah woah woah, just wait a minute there
11:37:21 <mreh> hold on...
11:37:28 <eyeris> Thanks rwbarton that is what I was looking for
11:37:29 <mreh> what are you talking about
11:37:35 * EvilTerran hex-hacks his source files; makes it easier to put in accented characters than a standard editor
11:37:36 <monochrom> You can ssh with X forwarding, then run Eclipse...
11:38:01 <EvilTerran> monochrom, "run eclipse"? in my experience, "walk" or "crawl" would be the appropriate verb there ;)
11:38:02 <eyeris> koeien Yeah, I like vim a lot, but it has crap Haskell support (e.g. ghci integration)
11:38:18 <mreh> im running GHCI in jedit
11:38:21 <mreh> it has a command line
11:38:26 <koeien> EvilTerran: unless you have 2^12 GB RAM
11:38:28 <mmorrow> i'm running ghci in bash :)
11:38:30 <monochrom> The "..." at the end means "then wait" :)
11:38:32 <eyeris> monochrom Eclipse has ghci integration?
11:38:49 <mreh> yeah, or run GHCI in a bash term
11:38:55 <monochrom> Actually I think yes. Not out of the box. Look for Eclipse plugin for haskell.
11:39:01 <eyeris> mreh: what do you press to get the type of the symbol under your cursor in jedit?
11:39:02 <vixey> pejo, nothing at the moment but I think it is interesting to have a language with termination ensured
11:39:10 <mpodwysocki> Just as an announcement that tomorrow 1/5/2009 2000 hours will be the first Real World Haskell book club meeting
11:39:21 <tjb> I'm trying to convert a Word96 to a Word128 ... anyone know how I should go about this?
11:39:21 <mpodwysocki> here for details: http://groups.google.com/group/real-world-haskell-book-club
11:39:30 <mreh> uhhh
11:39:34 <monochrom> w00t, real world meeting for real world haskell :)
11:39:39 <scodil> eyeris: there are vim scripts to get that... is that the only haskell support you're missing?
11:39:45 <vixey> :t fromIntegral :: Word96 -> Word128
11:39:46 <lambdabot>     Not in scope: type constructor or class `Word96'
11:39:46 <lambdabot>     Not in scope: type constructor or class `Word128'
11:39:52 <mreh> im sure there's a plugin for it
11:39:54 <EvilTerran> tjb, toEnum.fromEnum would do it
11:39:58 <EvilTerran> ?type fromIntegral
11:39:59 <lambdabot> forall a b. (Num b, Integral a) => a -> b
11:40:02 <EvilTerran> would do it too
11:40:10 <EvilTerran> ?src fromIntegral
11:40:10 <lambdabot> fromIntegral = fromInteger . toInteger
11:40:12 <tjb> EvilTerran, vixey: thanks, will try it out
11:40:14 <eyeris> scodil That is the biggest thing. I've used the haskell integration scripts for vim. They are error prone for me.
11:40:29 <scodil> eyeris: you're referring to Claus Reinkes?
11:40:29 <pejo> vixey, oh, in that case the stuff I linked is wrong. The work by Sereni and Jones is for untyped lambda calculus iirc.
11:40:41 <scodil> er, with an apostrophe in there somewhere
11:40:54 <athos> :t flip \x y z -> x y z
11:40:55 <lambdabot> parse error on input `\'
11:41:01 <eyeris> scodil I think the biggest hurdle is that they don't work for partial buffers (i.e. if the entire buffer doesn't parse, it fails to get the symbol type even if it is defined in another file)
11:41:05 <athos> :t flip (\x y z -> x y z)
11:41:06 <lambdabot> forall b t t1. b -> (b -> t -> t1) -> t -> t1
11:41:29 <eyeris> scodil Which is why hoogle integration is nice. AFAIK vim doesn't have a hoogle integration script
11:41:37 <scodil> eyeris: what other environment can do that? Don't they all rely on ghci? If it doesn't parse, then ghci can't tell you anything
11:41:45 <vixey> pejo, hm it was relevant.. the argument about lexicographic (mutual) recursion is similar to the foetus stuf though
11:41:54 <vixey> call graph closure and such ..
11:42:36 <eyeris> scodil from what I read, I thought emacs has a script to query a local instance of hoogle. I haven't gotten that far though -- just learning emacs basics still
11:43:32 <Peaker> I wondered how emacs shows me the types of Prelude stuff, before I even installed hoogle
11:43:37 <mreh> has anyone tried haskell in eclipse?
11:43:40 <scodil> oh, well I'm not going to try and sell you on the vim scripts, but Claus' latest can query haddock for the identifier under the cursor
11:43:40 <eyeris> scodil Perhaps I misspoke. It has a lambdabot script and lambdabot has hoogle support.
11:43:46 <mreh> i imagine when I work on large files it would be handy
11:43:53 <dmwit> mreh: There is an eclipse plugin.
11:43:57 <dmwit> I'm not sure how well it works.
11:43:59 <mreh> handy to have the refactoring menus
11:44:44 <scodil> eyeris: I'm doing it right now, just to make sure. Push "_?" with cursor over the identifier, it pops up a list of all modules containing that, and you select one and it opens the web browser to the doc page
11:44:45 <eyeris> bbiab
11:44:52 <scodil> even with parse errors in the file
11:44:55 <scodil> not sure if that's what you want
11:44:58 <eyeris> Ok. I will try that in a few minutes :)
11:46:05 <tjb> EvilTerran, vixey: fromIntegral is what I was looking for -- thanks again
11:47:08 <monochrom> @quote fromIntegral
11:47:08 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
11:47:12 <monochrom> hehehe
11:47:55 <monochrom> Oh, you were doing Word64 etc. Anyway.
11:48:26 <psamathos> I need some help with SDL on os x, I've googled and according to the readme the Test.hs in examples should work, but it doesn't. All I get is a link error for SDL_main, as somewhat expected i think ( http://pastebin.com/m61c54fae )
11:50:55 <icqnumber> ?users
11:50:55 <lambdabot> Maximum users seen in #haskell: 640, currently: 638 (99.7%), active: 25 (3.9%)
11:52:57 <Peaker> psamathos: Does "ghc-pkg describe SDL" show sdl in the library dependencies or -lsdl in the linker flags?
11:55:11 --- mode: irc.freenode.net set +o ChanServ
11:55:32 <Peaker> damn IRC networks suck
11:55:34 <xav_> freenode is famous for its netsplits
11:55:34 <Peaker> Someone needs to design a better server/daemon/protocol/client and just use bridges for a smooth transition
11:55:34 <psamathos> Peaker: without -main-is it never links, just compiles
11:55:34 <Peaker> psamathos: use -main-is, but also use -fforce-recomp
11:55:35 <Peaker> psamathos: or delete all the .o and .hi files
11:55:35 <Peaker> psamathos: and retry to compile with -main-is
11:55:35 <EvilTerran> xav_: -christel- [Global Notice] Good Evening Ladies and Gentlemen -- it's time for a somewhat late christmas pantomime.. I need to do a spot of rehubbing, it shouldn't take too long and you're welcome to point and laugh if it all breaks! Apologies for the inconvenience and have a nice day!
11:55:35 <monochrom> irc is deliberately a tree. this is begging for a problem.
11:55:50 <psamathos> peaker: same thing, it never links
11:55:51 <EvilTerran> i'd tell mreh too, but he seems to've disappeared...
11:55:56 <psamathos> or it links, but fails :)
11:55:57 <monochrom> the graph theory people can easily tell you "every point is a cut point".
11:56:39 <EvilTerran> monochrom, it follows almost directly from the definition of a tree, doesn't it?
11:56:45 <monochrom> Yes!
11:56:51 <EvilTerran> (with the requirement of acyclicity)
11:58:01 <monochrom> It made sense 40 years ago when no one heard of Leslie Lamport's and Nancy Lynch's and so on's research on distributed algorithms for broadcast, transaction, etc.
11:58:40 <Elly> which is approximately when it was designed!
11:58:40 <EvilTerran> unfortunately, nothing else has ever really caught on
11:58:53 <Elly> IRC is older than many of us, I suspect
11:59:05 <llayland> Please, someone help me interpret this type error: http://hpaste.org/13611 -  is the ambigous type variable 'b' the one from the second parameter of mkQ? If so why doesn't the type signature of dw' do the job?
11:59:32 <athos> @index state
11:59:33 <lambdabot> bzzt
11:59:55 <EvilTerran> Elly, http://www.irchelp.org/irchelp/rfc/index.html would suggest 1993, only
12:00:25 <Peaker> llayland: the type inference detects that mkQ's type-variable can be chosen to be anything at all, so it wants you to specify which type it is explicitly
12:00:37 <rwbarton> llayland: the 'a' in dw' is the 'b' in mkQ; it has nothing else to specify it.  Who knows what it's supposed to be?
12:00:39 <dmwit> llayland: dw' makes the same constraint on 'b' as mkQ does: that it be an instance of Typeable.
12:00:52 <Elly> EvilTerran: 1993 is not right; IRC was one of the first places to report the russian coup attempt in 1991, ISTR?
12:01:00 <Elly> and the original IRCd appeared early, like in the 1980s
12:01:00 <dmwit> llayland: Since it's possible for there to be more than one instance of Typeable, that means the type variable is ambiguous.
12:01:41 <EvilTerran> Elly, and "IRC was created by Jarkko Oikarinen in late August 1988", according to wikipedia
12:02:00 <Elly> aha
12:02:05 <Elly> IRC is older than me!
12:02:06 <Elly> w 8
12:02:08 <Elly> Damn!
12:02:15 <Elly> I keep missing / on this keyboard
12:03:30 <not_much> strange..  in ghci my program takes 150 seconds when named puzzle.hs, 5.7 seconds when named Main.hs
12:03:39 <vixey> not_much, lol
12:04:01 <EvilTerran> not_much, if there's a Main.o for it, it'll be using that when the file's called Main.hs
12:05:47 <llayland> thanks all, I think I'm fighting strong typing.  I'll have to rethink a bit
12:06:22 <not_much> Thanks EvilTerran, so is that a reasonable difference between ghci and unoptimized (without -O) ghc code?
12:07:13 <EvilTerran> not_much, quite possibly, yes
12:07:36 <EvilTerran> not_much, even with no -O, ghc does a lot more optimising than ghci does, i believe
12:07:46 <vegai> you can give -O to ghci, though
12:07:50 <rwbarton> llayland: It might clarify to try :t dw = mkQ (Relatable 0 0 Nothing [])  dw'
12:07:53 <not_much> so it would seem
12:08:02 <not_much> vegai: really?
12:08:51 <rwbarton> llayland: should be something like (Typeable a, Typeable b) => Relatable -> a -> Relatable -- which means the value might depend on the choice of the type b, but you have no way to specify the choice any more.
12:08:53 <not_much> just "ghci -O" from the command line?
12:08:55 <rwbarton> llayland: that's why it's an error.
12:09:36 <not_much> doesn't seem to make any difference in run times
12:09:55 <llayland> rwbarton ? that gives: parse error on input '=' in ghci
12:09:57 <vegai> ghci actually compiles your modules, you know
12:10:06 <rwbarton> llayland: oh sorry, delete the 'dw =' part
12:10:36 <not_much> that's what I thought, but why are the run times so different?
12:10:39 <vegai> but yeah, I'm not sure if -O affects ghci. I just know that it accepts that parameter :)
12:11:42 <vegai> your problem sounds like the bug that was revealed in ghc not too long ago
12:12:16 <not_much> ghci 150 sec, ghc 6 sec, ghc -O 3 sec
12:12:30 <vegai> oh, actually. Never mind.
12:12:34 <rwbarton> not_much: That seems totally typical to me, and not a bug
12:13:19 <vegai> might be interesting to know the reasons for that, though
12:13:39 <rwbarton> Doesn't ghci compile to some kind of bytecode?
12:14:23 <Saizan> yes, it does
12:14:37 <not_much> aha, ok good to know
12:14:42 <Saizan> it only uses compiled code for modules already compiled otherwise
12:14:48 <not_much> thanks all
12:16:07 <not_much> yep, I made puzzle.o and ghci screamed through it.
12:25:57 <Plouj> hi guys
12:26:41 <athos> @hoogle eval
12:26:42 <lambdabot> Control.Monad.RWS.Lazy evalRWS :: RWS r w s a -> r -> s -> (a, w)
12:26:42 <lambdabot> Control.Monad.RWS.Strict evalRWS :: RWS r w s a -> r -> s -> (a, w)
12:26:42 <lambdabot> Control.Monad.RWS.Lazy evalRWST :: Monad m => RWST r w s m a -> r -> s -> m (a, w)
12:26:44 <dmwit> Hey gals!
12:27:34 <Papillon> Si vous savez dupliquer un objet dans la ralite, contactez-moi en priv, j'ai besoin d'information.
12:28:11 <vixey> lol
12:28:28 <llayland> Please, someone help me interpret this type error: http://hpaste.org/13611 -  is the ambigous type variable 'b' the one from the second parameter of mkQ? If so why doesn't the type signature of dw' do the job?
12:28:30 <Botje> Papillon: wtf.
12:28:38 <llayland> oops, sorry.
12:28:40 <vixey> Botje, I'm guessing they watched "The Matrix"
12:28:54 <llayland> ignore that
12:31:31 <eyeris> Does anyone here know if Cabal builds on x86_64 with GHC 6.10?
12:32:02 <alatter> eyeris: I've done it
12:32:03 <eyeris> Currently GHC 6.8.2 panics while building Cabal 1.6.0.1.
12:32:03 <sereven> eyeris: sure, at least did for me.
12:32:22 <alatter> eyeris: what platform?
12:32:35 <pejo> eyeris, did you overclock?
12:32:44 <eyeris> Debian AMD64, no overclocking
12:33:15 <Plouj> how do I make instances of this: showable? data AnotherTree a = NodeB (Maybe a) (Maybe (AnotherTree a)) (Maybe (AnotherTree a)) deriving (Show)
12:33:26 <alatter> eyeris: I've done it on Core2, both Ubuntu and OS X
12:33:37 <alatter> Plouj: the (deriving Show) doesn't work?
12:33:55 <vixey> only if a has Show
12:34:14 <alatter> true
12:34:28 <eyeris> http://hpaste.org/13615
12:34:43 <eyeris> That is a dump of the build panic
12:35:39 <Plouj> for some reason (deriving Show) is not enough for this custom ADT
12:36:03 <Saizan> Plouj: which error are you getting?
12:36:07 <alatter> Plouj: do you have code you can put on hpaste, or what error messsage you're seing?
12:36:38 <Saizan> eyeris: did you try to runghc Setup.hs clean and then configure and build again?
12:36:41 <llayland> you need a class constraint on a for the class Show
12:36:51 <Papillon> donnez-moi ce que je demande
12:37:01 <eyeris> Saizan Yeah, it was to begin with on my first build attempt.
12:37:23 <dmwit> Papillon: #haskell.fr
12:37:31 <eyeris> was clean, that is :)
12:37:34 <vixey> dmwit, because what they're saying has something to do with haskell.......
12:37:35 <llayland> plouj: data Show a => AnotherTree a = NodeB (Maybe a) (Maybe (AnotherTree a)) (Maybe (AnotherTree a)) deriving (Show)
12:37:51 <dmwit> vixey: At least the ops there will understand that it's spam. ;-)
12:37:54 <Saizan> llayland: no, you don't need that
12:38:07 <sjanssen> llayland: shouldn't be necessary (and I don't think that ever helps, either)
12:38:14 <Asztal> class constraints on data types are bad. or so I'm told.
12:38:27 <sjanssen> Asztal: not really bad, just never useful
12:38:57 <llayland> interesting.  How could you derive show for that without the class constraint?
12:39:16 <djoseph> Is there a predefined function that I can use to measure the time it takes to run a function (in ghci)?
12:39:18 <sjanssen> llayland: the compiler includes the contraint in the instance defn.
12:39:34 <Asztal> sjanssen: as I was reading RWH it did mention an interesting reason
12:39:37 <twanvl> djoseph: use :set +s
12:39:41 <sjanssen> Plouj: data AnotherTree a = NodeB (Maybe a) (Maybe (AnotherTree a)) (Maybe (AnotherTree a)) deriving (Show) -- works for me, your error is somewhere else
12:40:06 <llayland> Oh, so it does.  I was assuming it failed to compile based on the question
12:40:09 <not_much> plouj: it seems to work for me
12:40:10 <djoseph> twanvl: Thanks.
12:40:11 <eyeris> Saizan http://hpaste.org/13615#a1 annotated with the clean first.
12:40:56 <sacko> hi all, could some help me with a little haskell problem please? http://hpaste.org/13616 I would like to test to see what constructor was used for a type, if thats at all possible. thanks
12:42:10 <rwbarton> sacko: It is much easier than that :)
12:42:13 <Saizan> eyeris: i see, i don't know what i might be then, building Cabal-1.6.0.1 works for me with ghc-6.8.2 on archlinux x86_64
12:42:17 <rwbarton> sacko: declToLang (VarDecl a (Record fls)) = ...
12:42:27 <rwbarton> sacko: ... (more equations follow)
12:42:45 <eyeris> sacko Something like this, perhaps: http://hpaste.org/13616#a1
12:43:47 <eyeris> Doh, typo fixed: http://hpaste.org/13616#a2
12:44:22 <eyeris> Saizan thanks
12:45:40 <sacko> eyeris, rwbarton: thanks peeps i'll give them a try.
12:47:13 <eyeris> sacko do you understand how that isRecord function works?
12:47:19 <eyeris> It's simple pattern matching
12:48:06 <ryanakca> I'm at page 42 of RWH, could somebody help me figure out what ``Malformed instance header'' means please? Source and full error at http://hpaste.org/13617
12:48:47 * Nafai looks
12:49:12 <bos> ryanakca: deriving (show) should be deriving (Show)
12:49:12 <Nafai> ryanakca: show needs to be capitalized, perhaps?
12:49:14 <ryanakca> ah. Could it be because I typed MyInfo instead of myInfo ?
12:49:33 <bos> that's also wrong, but it's not the error ghci is complaining about.
12:49:48 <bos> ryanakca: you know you can download a tarball of those source files?
12:50:06 <Raevel> (but typing is fun)
12:50:35 <Plouj> http://hpaste.org/13618
12:51:09 <ryanakca> bos: Oh? *googles*... It will be useful when I'm stuck... typing is fun, but running ``diff -u tarball_version my_version'' when things don't work will save everybody lots of time :)
12:51:11 * Nafai wishes he would have had RWH 2 years ago when he started to learn Haskell
12:51:27 <Heffalump> I blame those slowcoach authors
12:51:41 <sjanssen> Plouj: what is the type of "NodeB 1"?
12:51:43 <Plouj> I don't know what "data Show a =>" means, and I haven't gotten to the part in Real World Haskell that talks about => syntax.
12:51:58 <Plouj> NodeB :: a -> Maybe (AnotherTree a) -> Maybe (AnotherTree a) -> AnotherTree a
12:51:58 <Nafai> I think I would have been using Haskell by now if I would have had it then :)
12:52:14 <sjanssen> Plouj: since you haven't applied NodeB to all of it's arguments, it is a function type.  Function types can't be shown
12:52:20 <Plouj> oh
12:52:33 <Plouj> so I need NodeB 1 Nothing Nothing
12:52:34 <sjanssen> Plouj: you can show a full saturated NodeB, eg. NodeB 1 Nothing Nothing
12:52:40 <sjanssen> 'zactly
12:52:46 <sacko> thanks eyeris, yes i understand it, i've been using patterns to do the rest of my work, just didn't think of using one for it. thanks again
12:53:26 <Plouj> heh
12:53:37 <Plouj> so, for two nodes, I need this: NodeB 1 (Just (NodeB 2 Nothing Nothing)) Nothing, ouch :)
12:55:39 <sjanssen> Plouj: yeah, maybe you want to define a helper function for singleton trees
12:55:58 <sacko> thanks eyeris, yes i understand it, i've been using patterns to do the rest of my work, just didn't think of using one for it. thanks again
12:56:08 <Plouj> nah, it's just an excercise
12:56:09 <sjanssen> eg. single x = NodeB x Nothing Nothing; NodeB 1 (single 2) Nothing
12:58:16 <Plouj> thqnkw
12:58:19 <Plouj> thanks*
12:59:33 <vixey> @thqnkw
12:59:33 <lambdabot> you are welcome
13:04:42 <eyeris> How do I make emacs interpret delete opposite of backspace?
13:05:32 <mux> damn space leak
13:06:55 <mux> somehow running decodeFile from Data.Binary on a 1.2MB file containing a ByteString array and a ByteString trie causes a huge space leak
13:07:13 <mux> when I run the same code by hand in ghci, it works :-)
13:07:27 <mortenlysgaard> Miran Lipova?a, I don't know who you are, but you're a damn good tutorial-writer!
13:07:36 <dmwit> mux: Sounds like you're getting bitten by laziness!
13:08:17 * mux nods
13:08:29 <ski_> @hoogle Writer Tutorial
13:08:29 <lambdabot> Did you mean: :: Writer Tutorial a /count=20
13:08:30 <lambdabot> No results found
13:09:00 * ski_ wonders about `/count=20' ..
13:10:39 <fritz> @undo do (p1,r) <- comb1 x; (p2,r') <- comb (n-1) r; return (p2++p1, r')
13:10:39 <lambdabot> comb1 x >>= \ (p1, r) -> comb (n - 1) r >>= \ (p2, r') -> return (p2 ++ p1, r')
13:12:48 <eu-prleu-peupe1> :)
13:14:06 <Peaker> @. pl undo do (p1,r) <- comb1 x; (p2,r') <- comb (n-1) r; return (p2++p1, r')
13:14:07 <lambdabot> uncurry (flip ((>>=) . comb (n - 1)) . (`ap` snd) . (. fst) . (((return .) . (,)) .) . flip (++)) =<< comb1 x
13:15:36 <mmorrow> here's the hoogle ghc.txt for current HEAD http://moonpatio.com/docs/ghc/ghc.txt
13:16:27 <mmorrow> [m@ganon ghc]$ wc -l ghc.txt
13:16:27 <mmorrow> 19343 ghc.txt
13:33:06 <fritz> @pl map (rotatel x) (enumFromTo 0 (length x-1))
13:33:06 <lambdabot> map (rotatel x) [0..length x - 1]
13:33:19 <fritz> @pl f x = map (rotatel x) (enumFromTo 0 (length x-1))
13:33:19 <lambdabot> f = liftM2 map rotatel (enumFromTo 0 . subtract 1 . length)
13:36:11 <michaelcdever> hey, if i have a list of type a, and i want to create list of tuples from that list, along with one element of type b, ie. [(a1,b),(a2,b)] how would i go about it?
13:36:33 <koeien> michaelcdever: zip xs (repeat b)
13:36:47 <koeien> or, map (\x -> (x, b))
13:37:47 <michaelcdever> thanks koeien
13:37:58 <BONUS> yeah
13:38:10 <BONUS> or map (id &&& const b)
13:38:24 <Phyx-> :t (&&&)
13:38:26 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
13:39:01 <Phyx-> hmm
13:39:14 <Phyx-> :t (id &&& const 1)
13:39:15 <lambdabot> forall a t. (Num t) => a -> (a, t)
13:39:34 <Phyx-> that's one i gotta remember
13:39:44 <koeien> that is specialised to the (->) arrow
13:40:20 <BONUS> also useful is *** with const and id
13:40:35 <Phyx-> :t (***)
13:40:36 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
13:40:38 <BONUS> > (id *** (+3)) 3
13:40:39 <lambdabot>       No instance for (Num (a, b'))
13:40:39 <lambdabot>        arising from the literal `3' at <i...
13:40:49 <BONUS> uh
13:40:52 <koeien> for this small example, i find just using map or zip clearer. but in general, these functions are useful
13:40:53 <BONUS> let's see
13:41:10 <koeien> > (id *** (+3)) (1,2)
13:41:11 <lambdabot>   (1,5)
13:41:37 <BONUS> oh wait, i mixed up *** and &&& lol
13:41:43 <OceanSpray> > :k Int -> Int
13:41:44 <lambdabot>   <no location info>: parse error on input `:'
13:41:51 <OceanSpray> > @kind Int -> Int
13:41:52 <lambdabot>   <no location info>: parse error on input `@'
13:42:01 <OceanSpray> :k Int -> Int
13:42:02 <lambdabot> *
13:42:04 <OceanSpray> huh.
13:42:06 <vixey> :k *
13:42:07 <lambdabot> parse error on input `*'
13:42:16 <OceanSpray> :t Int -> Int
13:42:18 <lambdabot> parse error on input `->'
13:42:21 <Phyx-> @url &&&
13:42:21 <lambdabot> I know nothing about &&&.
13:42:24 <vixey> :k (&&&)
13:42:25 <Phyx-> lol
13:42:25 <lambdabot> Not in scope: type variable `&&&'
13:42:36 <OceanSpray> :t (\ x -> (+ x 1))
13:42:37 <lambdabot> forall a t. (Num a, Num t) => (t -> a) -> a -> a
13:42:41 <Phyx-> @haddock (&&&)
13:42:41 <lambdabot> Unknown command, try @list
13:42:46 <vixey> :k forall (&&&). (&&&)
13:42:47 <lambdabot> *
13:42:51 <Phyx-> @hoogle (&&&)
13:42:52 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
13:42:55 <vixey> :k forall (~>). a ~> b
13:42:56 <lambdabot> Not in scope: type variable `a'
13:42:56 <lambdabot> Not in scope: type variable `b'
13:42:59 <vixey> :k forall a b (~>). a ~> b
13:43:01 <lambdabot> *
13:43:03 <Phyx-> can't it spit out the url to the haddock?
13:43:23 <vixey> :k forall a b c (~>). (b ~> c) -> (a ~> b) -> (a ~> c)
13:43:24 <lambdabot> *
13:43:29 <vixey> cool
13:43:44 <vixey> you can really use these weird names as variables in types
13:43:46 <koeien> what is that ~> sign?
13:44:01 <Phyx-> i see that alot, is that an actual operator?
13:44:13 <funktio> @pl \(x,xs) = second (: xs) . (x `divMod`)
13:44:13 <lambdabot> (line 1, column 9):
13:44:13 <lambdabot> unexpected "="
13:44:13 <lambdabot> expecting operator, pattern or "->"
13:44:13 <vixey> :k forall a b c (<~&~>). (b <~&~> c) -> (a <~&~> b) -> (a <~&~> c)
13:44:15 <lambdabot> *
13:44:21 <funktio> @pl \(x,xs) -> second (: xs) . (x `divMod`)
13:44:21 <lambdabot> uncurry (flip ((.) . second . flip (:)) . divMod)
13:44:23 <koeien> this is like forall a b c d. (d b c) -> (d b a) -> (d a c)  ?
13:44:23 <vixey> aww...
13:44:58 <baaba> :k forall a (~>). (Arrow (~>)) => (a ~>)
13:44:59 <lambdabot> parse error on input `)'
13:45:12 <Phyx-> :t (~>)
13:45:13 <lambdabot> forall a b c1 c. (a -> b) -> (c1 -> c) -> (b -> c1) -> a -> c
13:45:16 <Phyx-> :O
13:45:19 <Phyx-> wow
13:45:28 <baaba> don't be fooled
13:45:29 <Phyx-> anywhere i can read up on that and *** and &&&?
13:45:36 <baaba> that ~> has nothing to do with these ~> :P
13:45:38 <pumpkin> Phyx-: it's in Control.ARrow
13:45:40 <koeien> Phyx-: Control.Arrow
13:45:42 <vixey> Phyx-, afaict there isn't much to it
13:45:55 <mriou> hi guys, I can't seem to find a way to map on the keys of a Map
13:45:59 <vixey> > (f &&& g) (x,y)
13:46:00 <lambdabot>   Add a type signature
13:46:05 <vixey> > (f &&& g) (x,y) :: (Expr,Expr)
13:46:06 <lambdabot>   (f (x,y),g (x,y))
13:46:14 <mriou> for values there's Traversable.mapM but that doesn't work for keys
13:46:26 <Phyx-> mkay, i'll look it up
13:46:27 <vixey> that's not right...
13:46:37 <vixey> > ((+1) &&& g) (3,2) :: (Expr,Expr)
13:46:38 <lambdabot>   Couldn't match expected type `Expr' against inferred type `(t, t1)'
13:46:42 <pumpkin> you meant *** ?
13:46:43 <vixey> > ((+1) &&& (+3)) (3,2)
13:46:44 <lambdabot>       No instance for (Num (t, t1))
13:46:45 <lambdabot>        arising from the literal `1' at <i...
13:46:48 <vixey> > ((+1) &&& (+3)) 3
13:46:50 <lambdabot>   (4,6)
13:46:52 <vixey> oh it is right
13:47:02 <pumpkin> you want *** to do first and second
13:47:09 <baaba> ((+1) &&& (+2) &&& (+3)) 3
13:47:11 <baaba> > ((+1) &&& (+2) &&& (+3)) 3
13:47:13 <lambdabot>   (4,(5,6))
13:47:18 <pumpkin> > ((+1) *** (+3)) (3,2)
13:47:19 <lambdabot>   (4,5)
13:48:28 <b_jonas> @type Data.Map.mapKeys -- --> mriou
13:48:30 <lambdabot> forall k1 k2 a. (Ord k2) => (k1 -> k2) -> M.Map k1 a -> M.Map k2 a
13:48:53 <mriou> b_jonas right but that doesn't work in a monad
13:49:16 <rwbarton> mriou: maybe you just want a list of keys?
13:49:43 <mriou> rwbarton: that forces me to "destroy" the map and rebuild a new one
13:49:56 <baaba> @pl \(x,(y,z)) -> (x,y,z)
13:49:56 <lambdabot> uncurry ((`ap` snd) . (. fst) . (,,))
13:50:00 <BiTTraffic> Need Hosting? www.BitTraffic.com has all you hosting needs. Everything you could possibly want. Tell your friends. Come visit us at irc.BitTraffic.com. We have 2x-3x what all other providers have, at a lower price! irc.BitTraffic.com <--- GO!
13:50:03 <BiTTraffic> Need Hosting? www.BitTraffic.com has all you hosting needs. Everything you could possibly want. Tell your friends. Come visit us at irc.BitTraffic.com. We have 2x-3x what all other providers have, at a lower price! irc.BitTraffic.com <--- GO!
13:50:04 <BiTTraffic> Need Hosting? www.BitTraffic.com has all you hosting needs. Everything you could possibly want. Tell your friends. Come visit us at irc.BitTraffic.com. We have 2x-3x what all other providers have, at a lower price! irc.BitTraffic.com <--- GO!
13:50:04 <BiTTraffic> Need Hosting? www.BitTraffic.com has all you hosting needs. Everything you could possibly want. Tell your friends. Come visit us at irc.BitTraffic.com. We have 2x-3x what all other providers have, at a lower price! irc.BitTraffic.com <--- GO!
13:50:07 <ml-> fu
13:50:08 <BiTTraffic> Need Hosting? www.BitTraffic.com has all you hosting needs. Everything you could possibly want. Tell your friends. Come visit us at irc.BitTraffic.com. We have 2x-3x what all other providers have, at a lower price! irc.BitTraffic.com <--- GO!
13:50:10 --- mode: ChanServ set +o sjanssen
13:50:12 <BiTTraffic> Need Hosting? www.BitTraffic.com has all you hosting needs. Everything you could possibly want. Tell your friends. Come visit us at irc.BitTraffic.com. We have 2x-3x what all other providers have, at a lower price! irc.BitTraffic.com <--- GO!
13:50:14 --- mode: sjanssen set +b *!*i=Beau@*.prsstn.dial.dynamic.tds.net
13:50:14 --- kick: BiTTraffic was kicked by sjanssen (sjanssen)
13:50:26 <vixey> that's a really great way to advertise ... :p
13:50:36 <koeien> i am really tempted to go there now
13:50:37 <mriou> I was hoping I could directly map on the keys in the monad
13:50:46 <mriou> mapMKeys of some sort :)
13:50:48 <b_jonas> mriou: in that case flatten it to a list
13:51:00 <pumpkin> wow, 2x-3x of what other provides have!
13:51:09 <Tobsan> that's not bad!
13:51:09 <pumpkin> they don't restrict that to positive things though
13:51:11 <b_jonas> mriou: Traversable won't work because it traverses the values only
13:51:14 <koeien> maybe they have HAppS....!!!
13:51:15 <pumpkin> downtime, prices!
13:51:15 <sjanssen> mriou: you can't map on the keys of a map efficiently, since their relative order might change
13:51:24 <pumpkin> 3x the downtime at 2x the price!
13:51:27 <pumpkin> a real bargain
13:51:28 <Tobsan> haha
13:51:35 <Phyx-> hmm. why can't i find (~>) on hoogle?
13:51:38 <mriou> b_jonas: yeah I've seen that, I was hoping for another solution but if that's the only one, so be it
13:51:41 --- mode: ChanServ set -o sjanssen
13:51:44 <b_jonas> mriou: but there's M.assocs and M.fromList
13:51:46 <vixey> Phyx-, because I just maide it up
13:51:56 <Phyx-> lol
13:51:59 <vixey> :P
13:52:06 <Phyx-> :t (~>)
13:52:08 <lambdabot> forall a b c1 c. (a -> b) -> (c1 -> c) -> (b -> c1) -> a -> c
13:52:08 <b_jonas> mriou: I don't think you could get a more efficent one anyway, because if the function on keys is not monotonic you have to build a new tree anyway
13:52:14 <Phyx-> hrm...
13:52:15 <baaba> it's not a standard thing
13:52:19 <Phyx-> i c
13:52:21 <Phyx-> lol
13:52:26 <mriou> sjanssen, b_jonas: correct, it was more for the convenience
13:52:30 <baaba> @src (~>)
13:52:30 <lambdabot> Source not found. Where did you learn to type?
13:52:33 <vixey> Phyx-, oh I know nothing about /that/, that wasn't me
13:52:37 <mriou> just like you have Map.mapKeys
13:53:00 <Phyx-> vixey: lol, a mystery then
13:53:04 <b_jonas> mriou: do you need arbitary monad or just state (fooAccum)?
13:53:33 <mriou> arbitrary monad (IO in my case)
13:54:18 <shapr> Any word on a ghc 6.10 package for debian?
13:54:32 <baaba> Phyx-, http://matt.immute.net/content/pointless-fun
13:54:43 <baaba> :t ($.)
13:54:44 <lambdabot> Not in scope: `$.'
13:54:57 <koeien> shapr: debian testing is frozen now. so don't expect it in unstable or testing. maybe in experimental
13:55:26 <dmwit> Geez, how many words can they come up with that mean unstable?
13:55:28 <mriou> thanks for the help b_jonas
13:55:44 <dmwit> And just how many levels of "no really, this will crash your machine" do they need?
13:55:44 <shapr> koeien: Ah, too bad
13:55:58 <baaba> > (id ~> id ~> id) (+) 2 3
13:55:59 <lambdabot>   5
13:56:05 <dmwit> :t (~>)
13:56:06 <lambdabot> forall a b c1 c. (a -> b) -> (c1 -> c) -> (b -> c1) -> a -> c
13:56:13 <Phyx-> baaba: ah, cool, thanks
13:56:29 <baaba> > ((+1) ~> (+1) ~> id) (*) 2 3
13:56:30 <lambdabot>   12
13:56:33 <dmwit> Did somebody ?let that, or is it in some module I didn't know about?
13:56:45 <baaba> somebody @let it
13:57:03 <baaba> > ((+1) ~> (+1) ~> show) (*) 2 3
13:57:04 <lambdabot>   "12"
13:57:26 <chessguy> shame we can't @src functions that have been @let'd
13:57:42 <baaba> yeah that would seem like a fairly simple thing to implement
13:57:47 <Raevel> surely
13:58:12 <vixey> hi shapr
13:58:26 <dmwit> That doesn't seem so simple to me.
13:58:47 <michaelcdever> right kinda half question here, i have a function: http://hpaste.org/13619 , and it does what I want, I was just wondering is there a better way of doing it? checkFile returns Bool
13:59:21 <Stephan202> @src (~>)
13:59:22 <lambdabot> Source not found. Do you think like you type?
13:59:49 <shapr> hey vixey!
13:59:51 <dmwit> michaelcdever: Have you ever caught getDirectoryContents in a lie?
13:59:53 <newsham> vixey: http://hpaste.org/13620
14:00:01 <dmwit> michaelcdever: (What's the point of line four?)
14:00:39 <michaelcdever> checkFile ::(FilePath, String) -> IO Bool, so zip puts the search term with the file name
14:01:01 <michaelcdever> in a lie? @ dmwit
14:01:16 <dmwit> michaelcdever: Yes.  Why do you "filterM doesFileExist" in line 4?
14:01:32 <roconnor> michaelcdever: I'd be inclinded to map (,"*") files, but whatever.
14:01:45 <dmwit> roconnor: (,) doesn't partially section =/
14:01:49 <dmwit> > (,) 3 4
14:01:51 <lambdabot>   (3,4)
14:01:52 <dmwit> > (,4) 3
14:01:53 <lambdabot>   <no location info>: parse error on input `4'
14:01:59 <roconnor> shit
14:02:08 <dmwit> But I agree, map ((,) "*") is nicer than zip/repeat.
14:02:16 <redditbot> [ANN] The Real World Haskell Book Club Starts 1/5/2009
14:02:17 <roconnor> well
14:02:18 <dmwit> or...
14:02:24 <roconnor> map (flip (,) "*) files
14:02:26 <dmwit> map (flip (,) "*") -- looking less and less nice
14:02:29 <roconnor> map (flip (,) "*") files
14:02:31 <roconnor> ya
14:02:33 <roconnor> not so nice
14:02:34 <EvilTerran> dmwit, it'd be map (flip (,) "*"); i'd go for the zip version, tbh
14:02:54 <baaba> > let (.,) = (,) in (.,4) 3
14:02:55 <lambdabot>   <no location info>: parse error on input `,'
14:02:55 <dmwit> On the other hand, the map version has the benefit of the free variable occurring last.
14:02:58 <roconnor> map (\x -> (x,"*")) files -- might be ok
14:03:11 <dmwit> So when you learn about (>>=), it desugars more nicely. =)
14:03:12 <roconnor> but maybe zip is just as good
14:03:40 <dmwit> getCurrentDirectory >>= getDirectoryContents >>= filterM doesFileExist >>= filterM checkFile . map (flip (,) "*")
14:04:16 <roconnor> (>>=) FTW!
14:04:20 <EvilTerran> dmwit, ... filterM checkFile . (`zip` repeat "*")
14:04:21 <EvilTerran> :P
14:04:26 <dmwit> yuck
14:04:33 <dmwit> As if it wasn't confusing enough already. =P
14:04:54 <Peaker> @type filterM
14:04:55 <dmwit> roconnor: Oh, (\x -> (x, "*")) looks nice.
14:04:56 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
14:04:58 * EvilTerran frequently uses zip infix; this is the next step :P
14:05:13 <opqdonut> ^_^
14:05:28 <bos> @seen dons
14:05:28 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 18h 58m 31s ago.
14:05:30 <roconnor> @src filterM
14:05:31 <lambdabot> Source not found. My brain just exploded
14:05:40 <michaelcdever> dmwit: the checkFile funtion searches with in a files, so im filtering the whole directory contets to isolate just the files
14:05:40 <roconnor> @type filterM
14:05:42 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
14:05:45 <roconnor> @type guard
14:05:47 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
14:06:01 <b_jonas> > (`(,)` 5) "foo"
14:06:02 <lambdabot>   <no location info>: parse error on input `('
14:06:07 <b_jonas> > (flip (,) 5) "foo"
14:06:09 <lambdabot>   ("foo",5)
14:06:09 <Peaker> @type \f xs -> sequence xs >>= filterM f
14:06:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m Bool) -> [m a] -> m [a]
14:06:15 <vixey> newsham, that's interesting: putInt :-> putString :-> putInt :-> END
14:06:28 <vixey> newsham, because it's much like:  ((+1) ~> (+1) ~> id) (*) 2 3
14:06:41 <rwbarton> dmwit: I think doesFileExist distinguishes between files and directories
14:06:44 <dmwit> michaelcdever: Oh, okay, so it filters out the subdirectories?
14:06:46 <dmwit> Got it.
14:07:03 <michaelcdever> yep, it filters out everything thats not a file
14:07:10 <vixey> unFoo ... foldFoo :)
14:07:28 <newsham> foldFoo == better name?
14:07:33 <Peaker> baaba, dmwit: I @let it before
14:07:33 <vixey> not really better
14:07:37 <michaelcdever> then it adds the search param to everything in the list as in (fileName, searchParam)
14:07:38 <vixey> I just think it is a fold
14:07:42 <EvilTerran> vixey, where's :-> and ~> coming from?
14:07:44 <roconnor> michaelcdever: what you have is fine.
14:08:04 <vixey> EvilTerran, well newshams hpaste but it's a mystery where ~> is from
14:08:07 <Peaker> baaba, dmwit: Its hellige's work, though
14:08:10 <roconnor> michaelcdever: we all would make different, mostly personal and minor style changes
14:08:18 <michaelcdever> roconnor: cheers, is adding the search param to everything not a bit sloppy though?
14:08:19 <newsham> now i have to figure out how to combine getFoo and putFoo into a single spec
14:08:24 <newsham> but first i gotta take care of RL stuff
14:08:25 <baaba> Peaker, yes, i gave the link to his site some minutes ago :P
14:08:37 <Peaker> baaba: awesome stuff :)
14:08:38 <rwbarton> michaelcdever: it might be better if checkFile took two arguments, rather than a pair.
14:08:41 <roconnor> michaelcdever: you mean your zip?
14:08:49 <baaba> Peaker, kind of a mindbender to be sure
14:08:50 <rwbarton> michaelcdever: Especially (in this case) if the pattern ("*") was the first argument
14:08:55 <Peaker> baaba: at first.. :)
14:08:58 <vixey> I think that is plausable
14:09:17 <rwbarton> michaelcdever: then you could just write  filterM (checkFile "*") files
14:09:27 <vixey> just change (o -> a) into (o -> a, a -> (a,o)) I guess
14:09:41 <roconnor> michaelcdever: ya, if checkFile too two arguments then you could filterM (flip checkFile "*") files
14:09:45 <roconnor> took two
14:10:00 <roconnor> or if you reorder the two arguments, then filterM (checkFile "*") files
14:10:08 <michaelcdever> ah ok yeah, rwbarton & roconnor, thats what i was wanting to dow thanks lads
14:10:18 <michaelcdever> :beer:
14:10:32 <roconnor> I suppose as it stands we have filterM (flip (uncurry checkFile) "*") files
14:10:50 <EvilTerran> roconnor, how unfortunate =/
14:11:07 <michaelcdever> *nods and smiles*
14:11:14 <roconnor> EvilTerran: ya, but I think checkFile is michaelcdever's own funciton, so it could be changed.
14:11:29 <EvilTerran> filterM (\f -> checkFile (f,"*")) files  would probably be the way to go if checkFile is set in stone
14:11:56 <michaelcdever> yeah, check files my own function, so its easy enough to change everything
14:12:03 <rwbarton> Why can't we write sections of (,) like (,a)?  Has someone proposed this before?
14:12:12 <michaelcdever> english > me tonight
14:12:21 <baaba> , is special syntax
14:12:28 <lunabot>  luna: Not in scope: `is'
14:12:36 <baaba> doh
14:12:52 <rwbarton> Right, I meant "wouldn't it be nice if".
14:13:47 <OceanSpray> In a dependently typed system, you can make functions that, say, take an integer, a type, and returns another type, right?
14:13:59 <b_jonas> rwbarton: I think that's because then people would also want [2,] and that would be dangerous when you wanted to just write a long normal list with a trailing comma
14:14:06 <OceanSpray> What would the type or kind of that function be?
14:14:11 <baaba> OceanSpray, what do you mean by "take a type and return a type"?
14:14:24 <baaba> do you mean type-level functions?
14:14:27 <OceanSpray> yes
14:14:28 <rwbarton> OceanSpray: I'm not sure it would be called a function, but "yes"
14:14:30 <vixey> Ocean:  (^) :: * -> Integer -> *
14:14:45 <vixey> Ocean:  S^0 = () ; S^(n+1) = (S, S^n)
14:14:56 <chessguy> vixey, what language is that?
14:15:00 <OceanSpray> so what's :t (^) ?
14:15:04 <baaba> an imaginary one
14:15:04 <baaba> :P
14:15:06 <OceanSpray> wait, no
14:15:06 <vixey> Ocean:  (^) :: * -> Integer -> *
14:15:09 <baaba> :t Maybe
14:15:10 <lambdabot> Not in scope: data constructor `Maybe'
14:15:17 <vixey> (5, (2, (8, ()))) :: Integer^3
14:15:19 <OceanSpray> so what's :k * -> Integer -> * ?
14:15:26 <baaba> huh?
14:15:27 <OceanSpray> or :t * -> Integer -> * ?
14:15:28 <vixey> OceanSpray, *[2]
14:15:39 <vixey> OceanSpray, * -> Integer -> *  is actually *[1] -> Integer -> *[1]
14:15:40 <roconnor> EvilTerran: ah right.  Sometimes I forget about lambdas
14:15:49 <vixey> and you have Integer :: *[1] :: *[2] :: ...
14:15:55 <vixey> but these indices can be implicit
14:16:15 <koeien> the index refer to the "order" of the type?
14:16:17 <baaba> the index means the uh..order of kind?
14:16:28 <koeien> kind is better, yeah
14:17:17 <OceanSpray> now hold on here.
14:17:26 <baaba> so * :: *[2], * -> * :: *[2], ?? -> * :: *[2]
14:17:27 <baaba> ?
14:17:40 <OceanSpray> the type of a function has kind *
14:17:44 <OceanSpray> ?
14:17:55 <baaba> of what we normally call functions, yes
14:17:59 <baaba> :k show
14:18:00 <lambdabot> Not in scope: type variable `show'
14:18:06 <koeien> :k Maybe
14:18:07 <lambdabot> * -> *
14:18:07 <OceanSpray> but
14:18:15 <baaba> :k Int -> Int
14:18:16 <lambdabot> *
14:18:34 <baaba> :k Int -> Int -> Int
14:18:35 <lambdabot> *
14:18:36 <baaba> etc
14:18:40 <OceanSpray> when you have types indexed by values, and values indexed by types, "what we normally call functions" is only a specific case.
14:19:16 <vixey> OceanSpray, yeah, in haskell the only functions you can write go from  (Type,Type) are are in Kind,  but with dependent types you get (Type,Kind) in Sort and etc...
14:19:23 <OceanSpray> yeah
14:19:37 <not_much_> easy way to find where (!!): index too large is occuring?
14:19:55 <b_jonas> but if you have functions getting and returning types, then do kinds still make sense?
14:19:57 <OceanSpray> so I was wondering how EXACTLY you figure out whether that function is supposed to have a type or have a kind.
14:20:43 <OceanSpray> Int -> Type :: ???
14:20:48 <OceanSpray> Type -> Int :: ???
14:20:54 <rwbarton> OceanSpray: I think you shouldn't distinguish types and kinds, but rather write 3 :: Integer, Maybe :: * -> *, etc.
14:21:47 <vixey> rwbarton, well it is very confusing actually, but once you get your footing sorted it is helpful to say    <values> :: <types> :: <sorts>
14:22:02 <rwbarton> OceanSpray: Now what you do with these indices I don't know at all
14:22:14 <vixey> but they are one thing
14:22:40 <vixey> OceanSpray, is Type a type or a kind/sort?
14:22:45 <OceanSpray> Type = *
14:23:03 <OceanSpray> so,
14:23:07 <vixey> Int -> * :: *,  * -> Int :: *
14:23:07 <OceanSpray> Int -> * :: ???
14:23:15 <vixey> but the * -> Int one.. it must return a constant value
14:23:23 <vixey> you can't pattern match on types or anything like that
14:23:48 <rwbarton> is it always true that if a :: b then b :: *?
14:24:01 <vixey> OceanSpray: (in this imaginary dependently typed language we're kind of making up as we go along :p)
14:24:02 <OceanSpray> you can't?
14:24:07 <Heffalump> rwbarton: I think so
14:24:28 <vixey> rwbarton, not if you have other kinds, like Coq has got Prop as well (for proofs)
14:24:31 <OceanSpray> I was imagining something like
14:24:34 <b_jonas> what on earth is this ?? and ???
14:24:42 <Heffalump> oh, wait, unboxed values
14:24:46 <Heffalump> so not in GHC Haskell
14:24:52 <baaba> shouldn't it be like
14:25:01 <rwbarton> 3# :: Int# :: # I see
14:25:06 <baaba> let's adopt a slightly distinct notation
14:25:12 <OceanSpray> f Int = 0; f Bool = 1; f Float = 3; etc.
14:25:15 <b_jonas> do they have something to do with the ? and ?? kinds in ghc?
14:25:30 <rwbarton> b_jonas: I think they just indicate a question :)
14:25:36 <OceanSpray> yeah, ^
14:25:45 <Peaker> I think ? and ?? and ??? are just different names for "kind variables"?
14:25:52 <Peaker> but its just a guess :)
14:25:58 <OceanSpray> Peaker, I was just asking a question.
14:26:10 <OceanSpray> "what is supposed to be put in place of this ???"
14:26:19 <b_jonas> I see
14:26:31 <OceanSpray> ?
14:26:47 <baaba> :k Int#
14:26:48 <lambdabot> Not in scope: type constructor or class `Int#'
14:27:40 <OceanSpray> vixey, so why can't you pattern match on types?
14:27:46 <OceanSpray> also, classes have kinds?
14:27:50 <baaba> but anyway, can dependent type languages really mix and match types and values?
14:27:53 <vixey> OceanSpray, because they are types
14:28:10 <vixey> baaba, not sure what 'mix and match' means
14:28:13 <Peaker> vixey: what can you do with types, except pass them along?
14:28:15 <baaba> or don't you have to have effectively a kind for say, type-level integers
14:28:31 <OceanSpray> then what about (pi x:* n:Int . x -> List x n -> List x (n + 1)) ?
14:28:41 <alisdair> is there a recommended intro to haskell for someone already comfortable with functional programming (erlang/ml)?
14:28:55 <OceanSpray> the above pattern matches against the List type constructor.
14:29:32 <vixey> OceanSpray, Vcons :: forall (X :: *) (n :: Int), X -> List X n -> List X (n + 1) ?
14:29:34 <baaba> like in ats you have sorts like: type, int, int -> type -> type
14:29:44 <OceanSpray> no, not forall
14:29:46 <OceanSpray> pi
14:29:50 <baaba> you might have List which has sort type -> int -> type
14:29:54 <vixey> OceanSpray, Vcons :: (X :: *) -> (n :: Int) -> X -> List X n -> List X (n + 1) ?
14:30:05 <baaba> so List foo 5 is a list of 5 foos
14:30:06 <OceanSpray> no, not that, either.
14:30:16 <OceanSpray> hold on
14:30:57 <Heffalump> alisdair: I think the "Gentle" Introduction would be reasonable there.
14:31:34 <alisdair> heffalump: thanks, i tried real world haskell, but it spends a lot of time on things i'm already comfortable with
14:31:39 <OceanSpray> nil : forall t. List t 0
14:31:40 <Saya> alisdair: i liked real world haskell
14:31:46 <Saya> woops :p
14:31:57 <vixey> OceanSpray: oh you have seen GADTs in haskell?
14:32:16 <OceanSpray> actually, I'm taking this out of "Types and Programming Languages"
14:32:23 <vixey> really ?
14:32:30 <OceanSpray> 30.5 Going Further: Dependent Types
14:32:36 <vixey> not ATTAPL ?
14:32:44 <Heffalump> the gentle introduction probably wastes some of your time too, but since it's quite short in general it can't be too bad there :-)
14:32:46 <OceanSpray> what's ATTAPL?
14:33:14 <Heffalump> Advanced Topics in TAPL
14:33:29 <Heffalump> a series of articles by other people edited by P[ie|ei]rce.
14:33:30 <OceanSpray> didn't buy that.
14:33:33 <wy> I think "gentle" is pretty good from my experience
14:33:54 <OceanSpray> if it covers dependent types more thoroughly, I probably should.
14:34:08 <wy> Just skip the part about monads and read Wadler's paper "The Essence of Functional Programming"
14:34:11 <vixey> OceanSpray, anyway.. A -> B is syntax for  forall x : A, B  or pi (x::A), B
14:34:44 <vixey> or (x:A)B
14:35:16 <OceanSpray> what?
14:35:44 <vixey> not sure what you are asking there
14:36:22 <OceanSpray> With "pi"-created "dependent function types",
14:36:32 <OceanSpray> you CAN pattern match against types and type constructors.
14:36:37 <vixey> no you can't
14:36:41 <vixey> :P
14:36:56 <OceanSpray> see, that's what I'm asking.
14:36:59 <vixey> pattern matching happens at runtime
14:37:08 <OceanSpray> how is something like what I wrote above not pattern matching?
14:37:11 <vixey> the matching of types and all that is something checked only at compile time
14:37:27 <OceanSpray> oh lord.
14:37:46 <vixey> it's not pattern matching though, it's checking they are equal
14:38:27 <vixey> well do you have an example of what you mean ?
14:38:40 <Heffalump> instance declarations are essentially pattern matching against types.
14:38:48 <OceanSpray> here's a paragraph
14:40:19 <OceanSpray> "Dependent function types of the form (pi x:T1. T2) are a more precise form of arrow types T1 -> T2, where we bind a variable x representing the function's argument so that we can mention it in the result type T2. In the degenerate case, when T2 does not mention x, we write (ou x:T1. T2) as T1 -> T2."
14:41:30 <OceanSpray> and then there's
14:41:37 <OceanSpray> nil : FloatList 0
14:41:57 <OceanSpray> cons : pi n:Nat. Float -> FloatList n -> FloatList (succ n)
14:42:20 <OceanSpray> head : pi n:Nat. Float List (succ n) -> Float
14:42:47 <OceanSpray> tail : pi n:Nat. FloatList (succ n) -> FloatList n
14:43:43 <OceanSpray> that FloatList (succ n) thing looks like pattern matching to me, and as far as I can tell, mathematical systems don't exactly distinguish between compile time and run time.
14:43:54 <vixey> OceanSpray, just in normal haskell for a moment consider:
14:43:57 <vixey> f :: A -> B
14:44:07 <vixey> and a b c :: A, x y z :: B
14:44:23 <OceanSpray> okay.
14:44:24 <vixey> if you try to go:  f a  it works, and   f x  doesn't  ... but is this pattern matching?
14:45:03 <OceanSpray> that's type-checking.
14:45:15 <vixey> it's the same with dependent types
14:45:40 <vixey> like  f :: A 3 -> A 4
14:49:06 <llayland> do I need to set any extensions to use type families?  I'm getting a parse error on the kind specification when I try to use the GMapKey example from http://www.haskell.org/haskellwiki/GHC/Indexed_types#What_do_I_need_to_use_type_families.3F
14:49:18 <Heffalump> llayland: yes, TypeFamilies
14:51:28 <llayland> heffalump, ty
14:51:59 <b_jonas> @hoogle (Monad m) => (a -> b) -> a -> m b
14:51:59 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
14:52:00 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
14:52:00 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
14:52:11 <b_jonas> hmm
14:52:15 <Heffalump> b_jonas: (return . ) ?
14:52:24 <b_jonas> yeah, (return .) works
14:52:30 <b_jonas> but isn't there a single name for that?
14:52:37 <Heffalump> doubt it
14:52:57 <b_jonas> strange
14:53:11 <sjanssen> doesn't seem like a common pattern to me
14:53:30 <b_jonas> it's not?
14:53:43 <Heffalump> I use it off and on
14:53:49 <Heffalump> but return . is pretty convenient
14:53:56 <b_jonas> @hoogle (a -> b) -> a -> m b
14:53:57 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
14:53:57 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
14:53:57 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
14:53:57 <Heffalump> so it'd have to be used a real load to justify a name of its own
14:54:17 <b_jonas> strange
14:54:19 <b_jonas> oh well
14:55:34 <rwbarton> b_jonas: perhaps you're not using liftM/fmap/(<$>) enough
14:55:56 <b_jonas> I'll show some context
14:57:11 <b_jonas> http://hpaste.org/13621
14:57:21 <b_jonas> in the value tsN
14:58:27 <Peaker> b_jonas: why the {} ?
14:58:37 <rwbarton> you could just move it into mapM (unwords . numDot) in this case right?
14:58:52 <Saya> cant you use do notation?
14:58:53 <Peaker> b_jonas: why don't you use String instead of [Char]?
14:58:59 <rwbarton> :t (mapM f >>= return . g, mapM (g . f))
14:59:00 <lambdabot>     No instance for (SimpleReflect.FromExpr (m b))
14:59:00 <lambdabot>       arising from a use of `f' at <interactive>:1:6
14:59:00 <lambdabot>     Possible fix:
14:59:07 <b_jonas> Peaker: the {} where?
14:59:09 <rwbarton> :t  (mapM ?f >>= return . ?g, mapM (?g . ?f))
14:59:10 <lambdabot> Top level:
14:59:10 <lambdabot>     Occurs check: cannot construct the infinite type: b = [b]
14:59:10 <lambdabot>       Expected type: a -> m b
14:59:19 <Peaker> b_jonas: the "where {"
14:59:44 <b_jonas> there? well, I don't like the indent syntax of haskell
14:59:49 <b_jonas> so I almost always use braces
14:59:59 <Peaker> b_jonas: why "return x >>= y ..."  instead of "y x ..." ?
15:00:34 <b_jonas> Peaker: well, it'll be a chain of multiple transforms, so I imagined it would make more sense to have return start >>= a >>= b >>= c
15:00:37 <Peaker> b_jonas: you can just delete the {} and not add indents, and it will work
15:00:41 <b_jonas> Peaker: I'll add one more transform in that chain
15:00:43 <b_jonas> Peaker: I know
15:00:53 <b_jonas> Peaker: except it won't exactly
15:00:59 <Peaker> b_jonas: why not?
15:01:17 <Peaker> b_jonas: if you remove all the semicolons and the {} it should work, that's how all my modules look like
15:01:25 <Peaker> (without indent for the module's where clause)
15:01:31 <b_jonas> Peaker: yeah, if you always use indent inside too
15:01:41 <Peaker> b_jonas: inside what?
15:01:45 <b_jonas> Peaker: but I think it causes problems if I use non-indent inside
15:01:51 <b_jonas> in clauses inside the module
15:01:53 <b_jonas> I'm not sure
15:01:58 <b_jonas> let me try
15:01:59 <Peaker> I don't think it has any effect
15:02:13 <Peaker> b_jonas: semicolons in layed-out/formatted Haskell code are weird
15:02:30 <b_jonas> Peaker: well, I really like this style more
15:02:36 <Saya> your code is only one liners it wouldnt change a thing
15:02:52 <b_jonas> Saya: this code is, I'm still writing it, it's just an example I pasted
15:02:54 <Peaker> b_jonas: you're weird :-)
15:02:54 <Saya> besides i think you would have to put braces inside each function to escape indenting
15:03:43 <Saya> i guess you dont use python either :)
15:04:16 <b_jonas> Saya: no. but actually python's indenting syntax is saner than haskell's indenting syntax, if only python had brace syntax too
15:04:33 <Peaker> b_jonas: "x >>= return . unwords" -> "liftM unwords x", and you can use =<< instead of >>= to make the ordering consistent
15:04:43 <Peaker> b_jonas: why have brace syntax too?
15:04:52 <Peaker> b_jonas: I never got the rationale behind that idea
15:04:56 <b_jonas> could we move away from this indent syntax thing now?
15:05:15 <b_jonas> as for >>=, I might change it to a do notation there
15:05:36 <Peaker> b_jonas: it will force you to give a lot of unnecessary names there, though
15:05:57 <b_jonas> oh yeah, that's true
15:06:02 <b_jonas> I guess let's keep >>= then
15:06:11 <b_jonas> or maybe just fmap without the return
15:06:23 <b_jonas> like fmap a (fmap b c)
15:06:25 <b_jonas> or something
15:06:30 <Peaker> "tsN = return yearStr >>= allSplit >>= mapM numDot >>= return . unwords" -> "tsN = liftM unwords $ mapM numDot =<< allSplit yearStr"
15:07:51 <b_jonas> Peaker: yeah, that makse sense
15:08:20 <b_jonas> Peaker: I'll use that one
15:08:23 <b_jonas> thanks
15:08:36 <Saya> there should be a >>= notation outside of monads too :( like in F# (|> i think)
15:08:46 * sjanssen <3 =<<
15:08:55 <sbahra> monads in pajamas
15:08:55 <Peaker> b_jonas: what about String?
15:09:07 <Peaker> F# has monads?
15:09:08 <b_jonas> Peaker: I can change to String
15:09:09 <sjanssen> Saya: it is not at all hard to make your own operator that flip ($)
15:09:11 <b_jonas> that's not a big issue
15:09:14 * b_jonas edits
15:09:29 <Saya> yeah i know but its there by default :p
15:09:30 <dobblego> Peaker, not in the general sense, no
15:10:01 <Peaker> Saya, dobblego: ">>= outside of monads too like in F#"??
15:10:05 <Saya> and F# has 'workflows' never tried using it though, its a microsoftey name
15:10:34 <dobblego> Peaker, f!@ks me
15:10:42 <Saya> i just mean feed your result to that function operator  , im afraid i wasnt very clear :p
15:10:56 <Peaker> > let numDot [c] = [[c]]; numDot (f : s) = (f : '.' : s) : map (f :) (numDot s) in numDot "hello"
15:10:57 <lambdabot>   ["h.ello","he.llo","hel.lo","hell.o","hello"]
15:11:23 <Peaker> b_jonas: is that the intention of numDot?
15:12:03 <b_jonas> Peaker: for that I have to tell the intention of the whole program (which I'm writing)
15:12:24 <Peaker> b_jonas: do you really want that last one without any dots?
15:12:28 <b_jonas> Peaker: yes
15:12:32 <Peaker> ah ok
15:13:08 <b_jonas> there's a golf puzzle I want to brute force, which is something like generate certain outputs from numbers and operators, where the digits in the expression are only 2009 in that order
15:13:32 <b_jonas> so I'm going to generate most of the viable expressions for it
15:13:45 <b_jonas> (I will miss out some unlikely to useful ones but that's no problem)
15:14:17 <Peaker> b_jonas: so you are building all the possible expressions and later you will evaluate them?
15:14:34 <b_jonas> Peaker: yes
15:14:43 <b_jonas> first I'm building the lists of lists of numbers
15:14:50 <b_jonas> or something like that
15:15:02 <vixey> b_jonas, of what language?
15:15:04 <b_jonas> and then add the operators
15:15:06 <b_jonas> vixey: J
15:15:09 <b_jonas> vixey: http://www.jsoftware.com/jwiki/Puzzles/POY%202009
15:15:22 <b_jonas> we've had that one for four years now
15:15:24 <Peaker> b_jonas: IMO, its better to build the functions or results "on the fly" than build a string and later parse it
15:15:34 <vixey> b_jonas, ahah!!!
15:15:50 <b_jonas> and I think in at least one year we've given solutions of at most 4 words to all but two of the 100 numbers
15:15:55 <vixey> b_jonas, is there some easy way to know when J expressions will terminate?
15:16:02 <b_jonas> Peaker: but the J interpreter will parse them
15:16:03 <rgr> in ghci if I do "let a = fromIntegral (length [1,2,3,4])", why is ":t a" not Num?
15:16:08 <b_jonas> Peaker: so I won't do that
15:16:15 <b_jonas> Peaker: I did build strings and expressions parallel once
15:16:24 <Peaker> b_jonas: why J?
15:16:35 <b_jonas> Peaker: because that's what the golf puzzle is about
15:16:43 <rwbarton> rgr: because of the monomorphism restriction I believe
15:16:56 <rwbarton> rgr: you can turn it off, or add a type signature
15:17:01 <b_jonas> and it's the fourth year it's done so now there's time to try to search automatically
15:17:24 <rgr> general comment : when answering anoob question then mentioning things like monomorphism is quite confusing for us :-;
15:17:44 <alisdair> why is ghc 6.10.1 nearly half a gig on my system?
15:17:58 <rwbarton> rgr: Sorry
15:18:00 <b_jonas> rgr: he said monomorphism restriction, not monomorphism
15:18:01 <rgr> its just that "learn you a haskell" uses it show how to convert to a nmore generl "Num" so why is the type not that?
15:18:11 <rwbarton> rgr: Try :set -XNoMonomorphismRestriction
15:18:19 <b_jonas> does the monomorphism restriction has anything to do with monomorphisms?
15:18:32 <rgr> b_jonas: are you joking?
15:18:38 <rwbarton> It has to do with things be monomorphic, i.e., not being polymorphic
15:18:43 <b_jonas> rwbarton: yep
15:18:49 <Peaker> rgr: IIRC: A type like   (Blah a => a)  has an implementation problem.  In GHC, named non-function values are memoized (e.g: x = 5) and functions are recomputed each time: (e.g x () = 5).  But values of type (Num a => a) look like they ought to be memoized but are implemented as sort of a function: Num a -> a
15:19:00 <mmorrow> , let numDot = fmap (uncurry (++) . fmap ('.':)) . takeWhile (not . null . snd) . zipWith splitAt [1..] . repeat in numDot "hello"
15:19:03 <lunabot>  ["h.ello","he.llo","hel.lo","hell.o"]
15:19:05 <b_jonas> rgr: I agree it must be confusing
15:19:17 <mmorrow> heh, "numDot" is an amusing name
15:19:31 <Peaker> rgr: so without the restriction, people would expect a value of type  Num a => a  to be memoized, but its not
15:19:39 <b_jonas> mmorrow: it's numDot because I'm using it only on numbers, and it will produce numbers
15:19:50 <b_jonas> mmorrow: and because this will be a short program
15:20:08 <Peaker> :t (5,5)
15:20:08 <rgr> ok, I think there needs to be a beginners group. memoized?!?!
15:20:09 <lambdabot> forall t t1. (Num t1, Num t) => (t, t1)
15:20:10 <mmorrow> the 'm' melts so nicely into the 'D'
15:20:20 <rgr> YOu guys know too much to help beginners :-)
15:20:24 <Peaker> rgr: memoized means that they are computed once and then the computed value is re-used
15:20:44 <rgr> even the concept of a function computed is alien.
15:20:44 <Peaker> rgr: so it takes more memory, but saves computation time later
15:20:51 * mmorrow can't stop saying "numDot"
15:21:12 <rwbarton> rgr: OK.  "It's because of a weird 'feature', which you can turn off using the magic words ':set -XNoMonomorphismRestriction'." :)
15:21:24 <Peaker> rgr: There is a trade-off between memory and CPU time - you can save more results in memory, so if you need them again, you will not have to recompute them, or you can throw them all away to save memory and just recompute as necessary
15:21:33 <b_jonas> I was thinking about the monomo restriction and I decided it _is_ a good feature
15:21:35 <vixey> someone should file a bug about monomorphism.
15:21:37 <b_jonas> the rule does make sense
15:21:50 <vixey> what rule b_jonas?
15:22:12 <b_jonas> vixey: the monomorphism restriction rule of haskell
15:22:19 <Peaker> let x = genericLength [1,2,3] in (x,x) -- you would think "x" is computed once, but if it used as different types later, it will be computed twice!
15:22:22 <rgr> Peaker: so what here was memoized? or "pre computed"?
15:22:24 <llayland> as a beginner, it makes no sense to me.  I'm not worried about performance or internals.  I just want to figure out how to make things work
15:22:28 <vixey> it does not make sense to me :S
15:22:56 <b_jonas> especially because you can override it with a type signature, unlike in standard ml where iirc you can't override it
15:22:57 <sbahra> llayland, what doesn't make sense?
15:23:00 <rwbarton> llayland: I agree that from a beginner's point of view, it would be more friendly if it were off by default, at least in ghci.
15:23:08 <sbahra> monomo
15:23:10 <Peaker> rgr: example:   let f x = (x*2) in (f 5, f 5) -- will multiply 5 by 2 twice.   let f = (5*2) in (f, f) -- will multiply 5 by 2 once.
15:23:19 <rwbarton> llayland: (In a real program it's less likely to come up)
15:23:46 <llayland> rwbarton: I'm still at the stage where none of my programs are real :)
15:23:47 <mmorrow> for i in `find / | grep "\.l?hs$"`;do cp -f $i a; echo '{-# LANGUAGE NoMonomorphismRestriction #-}' > $i; cat a >> $i; done
15:23:54 <Peaker> vixey: look at the (x,x) example
15:24:19 <mmorrow> hmm, prepending something to a file is a pain
15:24:26 <Peaker> @type let x = 5 in (x,x)
15:24:27 <lambdabot> forall t t1. (Num t, Num t1) => (t, t1)
15:25:32 <rgr> Peaker: has your example finished?
15:25:35 <vixey> MonomorphismRestriction is not here nor there for those that put type annotations down... so they should ask the people thath don't use type annotations whether or not it should be default
15:25:41 <Peaker> rgr: yeah, I can bring a better example though
15:25:48 <rwbarton> llayland: I just mean a program you compile and run, rather than an individual let binding in ghci (where there is no context to specify the type)
15:26:04 <rgr> I'm not sure which bit explained anytrhing. It just showed f 5 being computed once and twice.
15:26:57 <rgr> (sorry, 5x2 once and twice)
15:26:57 <Peaker> rgr: well, if you save the result to avoid recomputing it later, its called "memoization" (computed once), and if you throw it away and recompute it each time its not memoized (computed twice)
15:27:16 <Peaker> rgr: Named things in Haskell are generally memoized for their entire named scope
15:27:20 <Peaker> s/Haskell/ghc
15:27:28 <rgr> yell, yes. But whats that got to do with the type of fromIntegral being Integer and not Num?
15:27:44 <rgr> s/yell/well
15:27:55 <Peaker> rgr: but the implementation of type-classes is to convert values of type:  Blah a => a internally to a function like: Blah a -> a  -- and this makes the "a" value impossible to memoize.
15:28:16 <vixey> Peaker, does that matter?
15:28:35 <Peaker> rgr: so if ghc usually guarantees that     let x = ??? in ............... use x here multiple times ............    will only compute ??? once,   if the type of x is (Blah a => a) it cannot guarantee that anymore, and ???? will run many times
15:28:55 <Peaker> vixey: for real-world programs, probably, yeah
15:29:00 <rgr> ok, I'll admit defeat. I am totally lost. Especially when I see Haskell experts questioning each other. I'll go back to the beginning of the tutorial again.
15:29:01 <rwbarton> vixey: it does if (and only if) you expect to be able to reason about sharing from the lexical structure of your let expressions
15:29:52 <xav_> http://img247.imageshack.us/img247/2503/bsddevilettexf0.jpg
15:29:57 <vixey> I didn't think GHC gives you sharing guarantees ("haskell isn't lazy it's non strict"), but if you wanted the value shared you could just put a type annotation down
15:29:59 <Peaker> I forget why  f = \blah -> bleh  notation was different from f blah = bleh    in the context of the MR
15:29:59 <xav_> oops wrong channel
15:30:11 <Saya> don't worry rgr you get some of the stuff said here after some time :p
15:30:16 <rgr> Peaker: your last bit starting wiht "rgr: but" has gone right over my head. Thanks for tryin thtough.
15:30:32 <Peaker> rgr: do you know type-classes?
15:30:46 <rwbarton> rgr: "Num" is not a type
15:30:48 <eyeris> Is there a way to pass a IO () function as the first argument of the maybe function?
15:30:54 <Peaker> rgr: Num a => a -> a -> a -- what does this mean?
15:31:01 <chessguy> @type maybe
15:31:03 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:31:14 <xav_> monomorphism restriction first got me when i was doing some gui code with gtk2hs. when i added a type signature everything worked but i remember i really confused me
15:31:16 <rgr> it means a is a type which is a member of the general num class.
15:31:36 <chessguy> eyeris, sure
15:31:45 <michaelcdever> hey quick question, i'm getting problems with isPrefixOf, well the if/then/else block im using it in, would anyone be able to give me a pointer in the right direction please?
15:31:54 <eyeris> chessguy can you give me a simple example?
15:32:08 <paper_cc> eyeris: IO () is a value, not a function
15:32:17 <paper_cc> you can get a Maybe (IO ()) from it though
15:32:26 <michaelcdever> sorry, context - http://hpaste.org/13619#a1
15:32:36 <rwbarton> rgr: Right
15:32:46 <paper_cc> eyeris: yourMaybeValue >> yourIOValue
15:33:06 <chessguy> @type maybe (putStrLn "a") putStrLn "a"
15:33:07 <lambdabot>     Couldn't match expected type `Maybe String'
15:33:07 <lambdabot>            against inferred type `[Char]'
15:33:07 <lambdabot>     In the third argument of `maybe', namely `"a"'
15:33:10 <paper_cc> eyeris: s/yourIOValue/return yourIOValue/
15:33:10 <rwbarton> rgr: When you have a value of type Num a => a, then, it's really a kind of function that knows how to produce a value of type a for any type a that happens to be an instance of Num
15:33:30 <jeffwheeler> michaelcdever: It looks like the second line of the else isn't aligned with the first line.
15:33:41 <chessguy> @type maybe (putStrLn "a") putStrLn (Just "a")
15:33:42 <lambdabot> IO ()
15:33:46 <chessguy> eyeris,  there ya go
15:34:12 <rwbarton> michaelcdever: you need to put the else stuff in its own do block
15:34:25 <rwbarton> michaelcdever: Except you don't really, because  do x <- foo; return x  is the same as just  foo
15:34:37 <chessguy> eyeris, your second argument just has to be of type a -> IO (), and your third of type Maybe a
15:34:57 <jeffwheeler> michaelcdever: in other words, replace the entire else block with "else checkDirectoryFiles dir"
15:35:26 <Peaker> michaelcdever: the if does not need (), you can use  return $ ... if you want.
15:36:51 <rwbarton> michaelcdever: also I don't think that return () will typecheck, which will be more interesting to fix
15:37:26 <michaelcdever> changed it to return []
15:37:34 <chessguy> eyeris, does that make sense?
15:37:48 <michaelcdever> cheers lads, i seem to have broken my program now :\
15:37:50 <michaelcdever> lol
15:37:54 <michaelcdever> fun fun fun
15:38:12 <eyeris> Sort of
15:38:18 <jeffwheeler> michaelcdever: post the new version
15:38:20 <eyeris> I don't think I phrased my question properly
15:38:26 <eyeris> brb
15:39:22 <chrisdone> reading about oleg's perfect shuffle implementation. interesting
15:39:36 <dobblego> is there a standard library function e.g. f "cd" "abcdef" -> ("ab", "ef") ?
15:39:40 <michaelcdever> http://hpaste.org/13619#a3
15:39:51 <vixey> @wiki Data.List.Split
15:39:51 <lambdabot> http://www.haskell.org/haskellwiki/Data.List.Split
15:40:20 <jeffwheeler> michaelcdever: to start, you need a space after 'return' and before '[]'
15:40:29 <rwbarton> dobblego: It feels like there should be, given the existence of isInfixOf, doesn't it?
15:40:33 * chrisdone installed Data.List.Split today❤♥
15:40:46 <dobblego> rwbarton, yes, but it seems Data.List.Split has something
15:40:53 <michaelcdever> sorry must have pressed backspace
15:41:03 <jeffwheeler> michaelcdever: also, the 'do' right before the if is unnecessary, because there's only one statement within it
15:41:35 <jeffwheeler> michaelcdever: what errors, now?
15:41:44 <rwbarton> > return[] :: [[Int]]
15:41:45 <lambdabot>   [[]]
15:42:04 <michaelcdever> no compile errors, i meant it doesnt run as it should
15:42:25 <jeffwheeler> michaelcdever: what doesn't work right?
15:42:29 <rwbarton> michaelcdever: Well, you never actually construct any non-empty lists. :)
15:42:36 <michaelcdever> and i just realise what it is lol:D
15:42:44 <michaelcdever> <- Dumbass
15:42:45 <michaelcdever> lol
15:42:48 <jeffwheeler> :P
15:42:56 <rwbarton> Dumbass :: m a?
15:43:09 <michaelcdever> Dumass :: michaelcdever
15:43:16 <sbahra> chrisdone, what do you mean by perfect shuffle? The one I know of is trivial.
15:43:17 <jeffwheeler> I think that should be reversed. ;)
15:43:25 <michaelcdever> lol
15:44:06 <rwbarton> michaelcdever: otherwise your code is about 98% idiomatic haskell
15:44:32 * jeffwheeler can't stand managing memory. Grr.
15:47:50 <michaelcdever> hurrah, more errors :D
15:48:46 <michaelcdever> http://hpaste.org/13619#a3 all the infor is there..., dunno how to get around this one
15:49:24 <jeffwheeler> Without looking too hard, my guess is the need for a 'return'.
15:49:40 <jeffwheeler> The 'return' statement is used to wrap values in a monad, like () in IO ().
15:49:49 <jeffwheeler> Could it be the last line?
15:50:16 <rwbarton> michaelcdever: Well for one thing you're going to need (++), not (:)
15:50:19 <rwbarton> @type (++)
15:50:20 <lambdabot> forall a. [a] -> [a] -> [a]
15:50:21 <rwbarton> @type (:)
15:50:22 <lambdabot> forall a. a -> [a] -> [a]
15:50:24 <michaelcdever> yeah tried that, but if gives me errors with my checkFile function
15:50:45 <rwbarton> but what you really want is IO [a] -> IO [a] -> IO [a]
15:50:59 <paper_cc> :t filterM
15:51:00 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
15:51:07 <Tobsan> I came up with a funny joke the other day
15:51:10 <jeffwheeler> :hoogle IO [a] -> IO [a] -> IO [a]
15:51:18 <Tobsan> what do you call anything gordon freeman says?
15:51:20 <eyeris> Could someone explain how to better write this code using Data.Maybe? http://hpaste.org/13622
15:51:22 <rwbarton> Oh, I guess concat dirResults is already [FilePath]
15:51:25 <Botje> don't you want ++ instead of : ?
15:51:27 <jeffwheeler> @hoogle IO [a] -> IO [a] -> IO [a]
15:51:28 <lambdabot> Control.Concurrent mergeIO :: [a] -> [a] -> IO [a]
15:51:28 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
15:51:28 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
15:51:52 <Tobsan> a lambda expression.
15:51:59 <rwbarton> michaelcdever: filterM ( checkFile "*" ) directoryFiles is an IO action rather than a [FilePath], so you need to bind it to something with <-
15:52:31 <paper_cc> rwbarton, is that liftM2 (++) ?
15:52:39 <Peaker> @type filterM
15:52:40 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
15:52:41 <rwbarton> paper_cc: Yes
15:52:44 <Botje> eyeris: Just iter <- treeSelectionGetSelected ... ?
15:52:51 <rwbarton> paper_cc: However, it turns out not to be what michaelcdever wants here
15:53:00 <Peaker> michaelcdever: you want to take the value out of: "filterM ( checkFile "*" ) directoryFiles"
15:53:05 <Peaker> michaelcdever: blah <- filterM ...
15:53:07 <Peaker> michaelcdever: then use blah
15:53:09 <eyeris> Botje Won't that result in a failed pattern matching error at runtime?
15:53:22 <Botje> yes, so handle it? :)
15:53:59 <Botje> iter <- ...; case iter of Just it -> ...; Nothing -> Nothing
15:54:03 <eyeris> Botje The point of the Maybe monad is to propogate failure so that I don't have to clutter my code with error handling code when I don't need to do anything to handle it.
15:54:11 <Botje> yes.
15:54:19 <Botje> however, you're already in the IO monad
15:54:53 <rwbarton> eyeris: you could probably use Data.Traversable somehow, if you think it's worthwhile here
15:55:05 <b_jonas> good night now
15:56:41 <eyeris> So there isn't a way to wrap the treeModelGetValue call so that the Nothing case is propogated to the find call?
15:56:58 <rwbarton> eyeris: can you write out the version with case that you want to avoid?
15:57:13 <rwbarton> eyeris: it's a little hard since I don't know what any of the types of the gtk functions are
15:58:10 <eyeris> rwbarton Well treeModelGetValue can return Nothing if the location referred to by 'iter' and '0' doesn't exist.
15:58:19 <rwbarton> eyeris: OK
15:58:25 <eyeris> If that's the case, I just want to silently fail
15:58:28 <rwbarton> eyeris: And in that case you want to "skip" the last two lines and return Nothing?
15:58:34 <eyeris> Right
15:58:46 <eyeris> Return IO (Nothing)
15:59:44 <paper_cc> @hoogle MaybeT
15:59:44 <lambdabot> package MaybeT
15:59:44 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
15:59:46 <rwbarton> eyeris: So like this http://hpaste.org/13622#a1
16:00:00 <sclv> has anyone looked at the pure or q languages? they look interesting from a theoretical standpoint -- not sure what would/wouldn't make them more interesting than the ml family though.
16:00:14 <eyeris> rwbarton Exactly.
16:00:24 <eyeris> Is that really the proper way?
16:00:37 <rwbarton> eyeris: I'm thinking about whether there is a slick way to rewrite it
16:00:46 <rwbarton> eyeris: Also, that find probably needs to be in a return $
16:01:09 <eyeris> That's how I had it written first (along with a lot of other needless case statements)
16:01:10 <pejo> sclv, could you give an executive summary?
16:01:23 <eyeris> It just seems like I should be able to write it more Haskell-like
16:02:26 <sclv> pure is the successor to q. from what i can tell of q, it looks sort of like an ML crossed with prolog, but it actually evaluates through term rewriting.
16:02:51 <sclv> e.g.: http://q-lang.sourceforge.net/examples/symbolic.q
16:03:47 <sclv> on the other hand, it seems mainly untyped and eager by default
16:04:06 <eyeris> rwbarton So I have a similar problem with portStore.
16:04:30 <rwbarton> eyeris: oh?  It's also :: Maybe something?
16:04:49 <pejo> sclv, "much more dynamic language".
16:04:59 <eyeris> The call to treeModelGetValue also takes an instance of TreeModelClass, so it can't take a Maybe TreeModel, which is the type of portStore
16:05:03 <pejo> sclv, eager isn't necesarily bad though.
16:05:13 <eyeris> Is the case expression still the best way to handle that case?
16:06:03 <orthopteroid> noob here... I'm looking at some sample Monad code and see the word 'attempt' (without quotes). Is that a language keyword? An extension?
16:06:11 <sclv> the term rewriting seems to be what it offers above/beyond haskell -- not sure of the utility though.
16:06:13 <cads> do you guys know of a dynamic type system that ensures runtime type safety even in situations where the types couldn't be statically determined?
16:07:00 <eyeris> cads: C# on the .NET runtime does a bit of that
16:07:11 <pejo> cads, "dynamic type system"?
16:07:15 <sclv> native matrices as well, i guess
16:07:16 <rwbarton> eyeris: http://hpaste.org/13622#a2 is an untested and somewhat ugly solution
16:07:22 <sjanssen> cads: depends on what you mean by "type safety"
16:07:22 <jeffz`> cads, sure... there are strongly typed dynamic languages which allow the programmer to handle runtime type errors
16:07:44 <rwbarton> eyeris: it might be better to use MaybeT IO here as paper_cc suggested
16:07:54 <sjanssen> is throwing an exception on a runtime type error sufficiently safe?
16:09:21 <sclv> first class term rewriting seems like a really neat idea -- not sure how much it makes sense in actual practice though.
16:09:53 <eyeris> rwbarton The problem seems to me that the gtk2hs API is lacking -- it returns Maybe TreeModel values, the only purpose of which is to be passed back into gtk2hs functions, but those functions don't have Maybe TreeModel arguments. Perhaps I should just write treeModelGetValue' that accepts a Maybe TreeModel?
16:11:12 <cads> hrm, I guess it would have to do with creating types at runtime and yeah, what jeffz said about exceptions for type mismatches.. the idea though would be to have more useful type anotation available to your code than something like duck typing would give you
16:11:51 <michaelcdever> haha VICTORY!!!
16:12:16 <rwbarton> eyeris: I think MaybeT would lead to a more elegant solution
16:12:24 <eyeris> Okay
16:12:27 <eyeris> I will look into that
16:12:32 <eyeris> Right now my head is numb
16:12:40 <eyeris> So that will have to wait until tomorrow :)
16:13:00 <rwbarton> eyeris: the only drawback is it's not in the standard libraries
16:13:12 <cads> that way you might derive types that wouldn't be decidable at compile time
16:15:22 <xav_> has there been any research relating to JIT compilers for haskell-like languages?
16:15:23 * dixie_ is trying to use xmonad again (during the study of haskell)
16:15:41 <michaelcdever> brilliant i wrote it one way that would recursively scan the whole computer, including a kind backwards recursive using the ".." directory link
16:15:50 <michaelcdever> clever dever
16:17:01 <sclv> oooh... matrix comprehensions!
16:17:26 <sclv> i think clean has those too
16:18:40 <rwbarton> xav_: It would feel like an admission of defeat somehow :)
16:18:52 <sclv> the pure language: http://pure-lang.googlecode.com/svn/wiki/pure.html
16:19:15 <sclv> if I had to pick just one dynamic language, this would absolutely be it.
16:19:44 <michaelcdever> how do i map a string to the from of each element in a list of strings again? map "new" [list]?
16:19:48 <xav_> rwbarton: why is that?
16:20:07 <paper_cc> michaelcdever: s/from/front/?
16:20:10 <michaelcdever> *front
16:20:14 <paper_cc> =)
16:20:26 <paper_cc> map ("new"++) list
16:20:29 <BONUS> beaten
16:20:50 <rwbarton> xav_: Giving up on the idea of analyzing everything statically
16:21:19 <paper_cc> rwbarton: even The Static G++ has profile-driven optimization
16:25:03 <michaelcdever> doesn't seem to be working, i wonder am i doing it the right way?? http://hpaste.org/13619#a4
16:26:10 <Saizan> mapM is only if you use a monadic function
16:26:19 <Saizan> +appropriate
16:26:25 <Saizan> try: let pathCr <- mapM ( directoryPath ++ ) currentResults
16:26:27 <Saizan> ops
16:26:41 <Saizan> try: let pathCr = map ( directoryPath ++ ) currentResults
16:27:41 <paper_cc> michaelcdever: mapM thought you were referring to the [] monad, so the message
16:27:48 <michaelcdever> cool, yeah that worked, cheers
16:28:26 <mux> how would you go about debugging a space leak that seems to happen in the get method of the binary instance for an Array ?
16:28:29 <Saizan> btw, you don't need the parens around concat subResults
16:28:35 <paper_cc> michaelcdever: there should be a special function for joining paths
16:28:46 <rwbarton> @hoogle </>
16:28:46 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
16:28:46 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
16:28:54 <mux> this is as far as I could get iwth -prof -auto-all -caf-all
16:29:37 <rwbarton> mux: Well, it's hardly surprising that the Array is being allocated in get
16:29:44 <rwbarton> mux: The real question is why is it being held on to
16:29:51 <naturalethic> any macports + cabal users here?
16:30:11 <paper_cc> :t forM
16:30:12 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
16:30:12 <mux> that array itself doesn't even get close to explaining the memory usage that I've seen go up to 2GB before I ^C the code
16:30:48 <rwbarton> mux: how big is the array?
16:30:53 <Saizan> are you using decodeFile ?
16:30:58 <rwbarton> mux: or the file rather?
16:32:41 <mux> 465k
16:33:04 <mux> and it's an Array Int ByteString of only 6275 elements
16:33:27 <mux> if I just decodeFile the array and use it, it works just fine
16:33:42 <mux> if I just decodeFile my Trie [Int] and use it, it's fine
16:34:18 <mux> and if I use the Binary instance of my Index datatype which is just a record with both data structures, things explode
16:35:53 <Saizan> maybe the array can't tell where it ends?
16:36:51 <paper_cc> mux: maybe make things a bit more strict?
16:37:26 <Saizan> also, are you doing heap profiling? or just -p?
16:37:35 <mux> Saizan: no, it knows
16:37:42 <mux> Saizan: I've been doing both
16:38:13 <mux> I've tried to strictify things to death, but with no luck
16:38:19 <naturalethic> i'm trying to install readline via cabal on macports, is there a way to specify where my readline includes/libs, etc are via 'cabal install' ?
16:38:24 <mux> I've also tried to unstrictify things :-)
16:38:46 <mux> I also forgot to mention that I can use this same code in GHCi fine
16:39:02 <mux> like: decodeFile "foo" :: IO Index
16:39:07 <mux> let idx = it
16:39:13 <mux> and then running functions on it just fine
16:39:31 <Axman6> heh, i remember when i first played with strictness. decided a strict binary tree was a sweet idea... i can tell you that one that's 50+ levels deep is not a good idea
16:39:58 <Axman6> needless to say, i went off and bought another 2 GB RAM for my macbook pro so i could continue playing :P
16:39:58 <Saizan> naturalethic: see --extra-lib-dirs/--extra-include-dirs
16:40:01 <rwbarton> Maybe you should try to pin down this difference between ghci and ghc, by making main some function of decodeFile "foo"
16:40:18 <mux> Saizan: the Trie datatype was spine-strict in addition to elmeent-strict, and littered with strictness annotations and UNPACK pragmas
16:40:24 <mux> I thoght it could be responsible but nope
16:40:46 <mux> rwbarton: by making main some function of decodeFile "foo" ?
16:40:55 <Saizan> mux: so the exact same code works in ghci and gives a space leak when compiled?
16:40:59 <mux> yes
16:41:01 <naturalethic> saizan: i'm retarded thanks -- i overlooked trying 'cabal install --help'
16:41:31 <rwbarton> mux: well I don't know what you can do with an Index, but  main = do idx <- decodeFile "foo"; print (f idx)
16:41:52 <mux> rwbarton: that already what it does
16:42:13 <rwbarton> mux: ah ok.  So you can type "main" into ghci, and that works, and running the compiled executable fails
16:42:14 <mux> I've narrowed the space leak down to just a decodeFile, and anything that actually tries to go inside my Index data structure
16:42:17 <Saizan> mux: which compiler version/binary version?
16:42:22 <mux> 6.10.1
16:42:50 <mux> rwbarton: funnily enough, no
16:43:08 <mux> if I just type main in ghci, it goes berserk
16:43:08 <Saizan> binary?
16:43:19 <mux> if I decompose it into several commands as I've said, it works
16:43:33 <Saizan> ah, ok, that's less weird :)
16:43:40 <mux> if you say so :-)
16:43:48 <rwbarton> mux: what if you copy and paste the code of main into ghci :)
16:43:59 <Saizan> at least the same code does the same thing..
16:44:04 <mux> well I can try that too
16:44:09 <trygvis> hm, how come if I go ":l Pizza" in ghci it sais "Ok, modules loaded: Main"?
16:44:13 <xav_> let a_1,...,a_n be n pairwise distinct numbers
16:44:15 <xav_> what does this mean?
16:44:18 <trygvis> isn't it supposed to load the Pizza module?
16:44:36 <rwbarton> trygvis: because Pizza.hs doesn't begin  module Pizza where  I think
16:44:37 <paper_cc> xav_: forall i j. a_i /= a_j :)
16:44:44 <trygvis> oh
16:44:46 <Axman6> trygvis: does it say module Main where at the top of the file?
16:44:59 <mux> rwbarton: same leak this way
16:45:06 <rwbarton> mux: ok
16:45:14 <rwbarton> mux: so figure out the difference between that, and the thing you thought was the same :)
16:45:28 <xav_> paper_cc: so no two numbers are the same?
16:45:54 <paper_cc> xav_: yep
16:46:20 <mux> rwbarton: I have no idea what this "maps" to in ghci : "decodeFile "foo" :: IO (...)\nlet idx = it"
16:46:29 <xav_> paper_cc: ok thanks
16:46:44 <mux> the fact that I'm running the action and then binding a name to the result via the special "it" variable
16:47:32 <rwbarton> mux: I think it's more or less the same as idx <- decodeFile "foo"
16:48:05 <Saizan> that's nothing special, how you force the idx value is what matters i think
16:48:18 <Saizan> unless there's some sort of defaulting going on in ghci?
16:48:38 <mux> rwbarton: well it seems not since one leaks and the other doesn't
16:48:48 <rwbarton> you can also just enter 'idx <- decodeFile "foo" :: IO (...)' into ghci
16:49:30 <Saizan> mux: when you tested with main in ghci, did you touch the source file first?
16:49:51 <mux> wait a minute, a case that was leaking previously just started working o_O
16:49:52 <Saizan> because we don't want ghci to link the compiled .o
16:51:18 <mux> ok
16:51:32 <rwbarton> also, do you have :set -fno-print-bind-result or not
16:51:33 <mux> so now if I just type "main" in GHCi, I get the space leak
16:51:41 <mux> if I just copy-paste the one-line main, it works
16:51:50 <mux> rwbarton: nope
16:52:19 <rwbarton> try touching your source file to force ghci to reload and not use the compiled object file
16:52:40 <mux> same thing
16:52:43 <sbahra> mux, 6.10.1 on FreeBSD?
16:52:48 <Peaker> does putStr use lazy I/O?
16:53:02 <mux> sbahra: yes
16:53:09 <Saizan> write operations are never lazy, there's buffering though
16:53:23 <mux> rwbarton: I've touched all *.hs files to be extra sure, and I can reproduce this weirdness
16:53:42 <Peaker> Saizan: I have (temporary debug code): unsafePerformIO (putStr . unlines $ ["blah", lazyComputationHEre]) `seq` blah   <-- its not building a big string before putting it in there, its printing partial data and resuming computation
16:54:33 <rwbarton> Peaker: how about Debug.Trace? :)
16:54:49 <Peaker> rwbarton: I didn't want to use it for now-obseleted reasons
16:55:11 <rwbarton> also I think unsafePerformIO ((putStr . unlines $ ["blah", lazyComputationHEre]) >> return blah) is more likely to behave predictably
16:55:15 <Saizan> well the list printing and production are interleaved, sure
16:55:20 <mux> so what can be the difference between copy-pasting the body of main into GHCi, and just running main
16:56:04 <rwbarton> mux: I guess you could have some bindings in ghci, but that's probably not it
16:56:14 <Peaker> Saizan: I don't want them to be...
16:56:19 <Saizan> if you want otherwise you've to force the whole list before applying putStr to it
16:56:28 <Saizan> with length or rnf
16:56:35 <Cale> Peaker: output can't be lazy
16:56:46 <CakeProphet> mux:  ghci automatically calls print on the output of your stuff.
16:56:48 <Peaker> Saizan: ah, thanks
16:56:59 <Cale> Peaker: It must force its argument in order to actually, you know, print it ;)
16:57:10 <CakeProphet> main does not
16:57:15 <mux> CakeProphet: no, in this case this has nothing to do with this
16:57:19 <Cale> (but it does force the list in order)
16:57:24 <mux> what I copy-paste is precisely the body of main
16:57:24 <Peaker> Cale: it can force the beginning of the list before the rest, yeah
16:57:28 <mux> which is thus necessarily IO ()
16:57:29 <CakeProphet> oh
16:57:49 <Saizan> not necessarily :)
16:58:08 <mux> anyways that's not it
16:58:34 <Peaker> fullTrace x = length x `seq` trace x
16:58:40 <Saizan> are you using the latest version of binary?
16:59:07 <Peaker> ah, this works, whew
16:59:10 <mux> Saizan: yes, 0.4.4
16:59:44 <mux> basically I have: main = do idx <- decodeFile "foo"; f idx
17:00:00 <mux> typing "main" causes GHCi to enter space leak mode
17:00:11 <mux> copy-pasting everything starting at "do" works fine
17:00:18 <Saizan> f is monomorphic?
17:00:26 <mux> yes
17:00:59 <rwbarton> Try main = main' and main' = do idx <- decodeFile "foo"; f idx? :)
17:01:03 <mux> f is just some map B.putStrLn on keys extracted from the trie
17:01:26 <mux> rwbarton: err, ok
17:02:10 <mux> rwbarton: both main and main' cause the space leak
17:02:20 <rwbarton> also try let main :: IO () ; {- if you have a type signature in your source -} main = do idx <- ... in main
17:02:37 <mauke> heh
17:02:51 <mauke> are you building a hueg IO action?
17:03:05 <mux> hueg?
17:03:08 <sbahra> huge
17:03:33 * mux notes sbahra has a levenhstein distance algorithm built in his brain
17:03:47 <mux> mauke: I don't think so
17:04:10 <mux> rwbarton: in GHCi you mean?
17:04:26 <CakeProphet> loool
17:04:33 <rwbarton> mux: yes
17:05:21 <mux> rwbarton: still a space leak
17:07:44 * mux invokes dons
17:07:52 <mauke> preflex: seen dons
17:07:52 <preflex>  dons was last seen on #haskell 1 day, 4 hours, 54 minutes and 4 seconds ago, saying: seems so.
17:08:40 <Saizan> look at the core :)
17:08:59 <mux> done that, I'm still half-blind and recovering slowly
17:09:04 <mauke> and when you look into the core
17:09:11 <mux> and I have a nosebleed.
17:09:12 <rwbarton> that probably won't explain what's going on with the ghci weirdness
17:09:26 <rwbarton> can you paste your code?
17:09:51 <Saizan> well you can look at both the core generated by the module and the one generated at the ghci prompt
17:09:57 <mux> although it's a bit inconvenient because it lies in several source files, I could do it, but you'd still need the data as well
17:09:59 <Saizan> there has to be a difference..
17:10:08 <rwbarton> Saizan: How do you get core from ghci?
17:10:17 <mux> Saizan: compiled code leaks too, only when I copy paste the body of ain in GHCi it's working
17:10:18 <Saizan> :set -ddump-simpl
17:10:24 <rwbarton> oh, huh
17:11:14 <rwbarton> mux: Well, how about just the file containing main
17:11:17 <mux> reading diffs of core output
17:11:18 <mux> scary
17:11:37 <mux> rwbarton: sure, it's a one-line main and imports
17:11:57 <mux> but I feel like this won't help...
17:12:03 <rwbarton> mux: do you get blowing-up behavior even with a smaller file?
17:12:32 <mux> http://hpaste.org/13624
17:12:41 <mux> rwbarton: I didn't try that
17:13:29 <mux> there are quite a lot of useless imports due to various debugging tried
17:15:21 <stulli> Hi, i compiled a file with ghc -c and get an error: The function `main' is not defined in module `Main'
17:15:36 <rwbarton> mux: oh
17:15:39 <stulli> I thought there need not to be a main when using -c ?
17:15:41 <rwbarton> mux: oh never mind
17:16:22 <rwbarton> mux: well just in case, is indexPath an absolute path?
17:16:27 <mux> rwbarton: yes
17:16:35 <mux> I checked I was loading the expected filee
17:17:25 <stulli> Ah, nevermind. I forgot the module declaration...
17:20:34 <rwbarton> mux: the only thing I can think of is to make sure you have no .ghci, and no compiled files lying around, and a fresh ghci session
17:21:16 <mux> I've checked all that :-(
17:26:28 <sbahra> applicative.org - thumbs up/down?
17:27:09 <monochrom> thumbs horizontal
17:27:29 <cads> C make me a sad puppy :(
17:28:54 <monochrom> A sad puppy is still better off than a happy ant.
17:29:19 <monochrom> For makefiles still take less work than ant files. :)
17:30:00 <lucca> Hm, I was reading the haskell wiki page on maintaining laziness and noticed that break thing a fair amount by using Maybe a lot
17:30:16 <ClaudiusMaximus> @src getChanContents
17:30:17 <lambdabot> Source not found. The more you drive -- the dumber you get.
17:30:20 <lucca> Well, Either also
17:31:39 <lucca> It seems kinda awkward to do something like return a tuple with potentially partial results and success info
17:31:54 <lucca> and it seems more awkward yet to rely on something like undefined
17:34:18 <pumpkin_> Axman6: a puerly haskell database... does that mean childish? :o
17:34:37 <Axman6> ?
17:35:33 <pumpkin_> http://www.reddit.com/r/haskell_proposals/comments/7mko1/puerly_haskell_database_without_some_third_party/
17:36:04 <_dolio> There's a haskell proposals reddit?
17:36:24 <pumpkin_> _dolio: of course! please use it and love it :)
17:37:17 <rwbarton> It's more like proposals for Haskell projects
17:37:28 <rwbarton> as opposed to, proposals for the Haskell language
17:37:34 <djwonk> is there a GHCi init file? i'd like to do ":set prompt ..." automatically
17:38:06 <dolio> There is.
17:38:11 <mauke> ~/.ghci
17:38:19 <djwonk> makes sense, thanks :)
17:38:36 <pumpkin> rwbarton: it could be the latter too, if you wanted it to be :) just submit something
17:39:21 <dolio> That won't get it to most of the people who write the compilers, though, probably.
17:39:22 <djwonk> ok, now I found it! http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-dot-files.html
17:39:53 <lucca> http://hpaste.org/13625 is what I mean...
17:41:03 <lucca> I'd expect to only deal with short lists, and want to catch dotted-list type problems as errors anyway, but does it make sense to be able to handle infinite structures whenever possible?
17:41:58 <pumpkin> dolio: true that
17:42:37 <pejo> lucca, is this a philosophical question whether to use lazy or strict languages?
17:42:57 <dolio> lucca: lazyConsToList2 isn't recommendable.
17:43:16 <lucca> pejo: No.
17:43:58 <lucca> dolio: okay.
17:44:20 <lucca> pejo: the first function looks more idiomatic to me, but that wiki page suggested otherwise
17:44:36 <dolio> ([Sexp], Bool) feels bad to me, but it is more lazy, if that's what you're after.
17:44:46 <rwbarton> lucca: I only see the point of consToList and lazyConsToList2 (although the latter should use error rather than undefined)
17:45:10 <rwbarton> lucca: the first for when you don't know whether it will return Just _ or Nothing, and the second for when you know it will succeed.
17:45:11 <xav_> why is it called S expression?
17:45:26 <lucca> the middle one lets you pull results lazily, provided you don't look at the Bool
17:45:41 <rwbarton> Right, but that seems almost always useless, no?
17:45:51 <newsham> ?seen vixey
17:45:52 <lambdabot> I saw vixey leaving #scala, #haskell, #perl6 and ##logic 1h 46m 22s ago, and .
17:46:20 <lucca> xav_: The structure mirrors the result of a read s-expression
17:46:29 <lucca> (for some sample language)
17:46:38 <lucca> rwbarton: that's what I was thinking, yes
17:47:00 <lucca> http://www.haskell.org/haskellwiki/Maintaining_laziness seemed to suggest otherwise
17:47:27 <lucca> I'm guessing it really only matters if you're expecting it to be reused in a very general library
17:47:28 <rwbarton> Yeah, I read that.  But sometimes the function you want just isn't lazy. *shrug*
17:47:29 <xav_> lucca: what does the S stand for?
17:47:46 <lucca> xav_: S stands for Not-relevant-to-this-discussion
17:48:35 <dolio> S stands for symbolic.
17:48:39 <Tobsan> as in http://en.wikipedia.org/wiki/S-expression
17:48:53 <lucca> Right, that's a more clear definition
17:49:33 * Debolaz ponders trying leksah.
17:49:38 <bremner> S stands for special
17:50:22 <monochrom> @quote nth
17:50:23 <lambdabot> dons says: disable the type checker in ghc for 6 months and we'd have 5 debuggers at the end of it :)
17:50:50 <monochrom> godawful
17:51:00 <chessguy> haha
17:51:06 <monochrom> @quote [^a-z]nth[^a-z]
17:51:06 <lambdabot> No quotes match. My mind is going. I can feel it.
17:51:13 <monochrom> @quote monochrom nth
17:51:13 <lambdabot> No quotes match. My pet ferret can type better than you!
17:51:38 <lucca> well, thanks!
17:51:41 <monochrom> I had a recent quote saying: n is the nth letter.
17:52:07 <mauke> preflex: quote monochrom
17:52:07 <preflex>  <monochrom> Do not try to pronounce haskell code. You are not a modem.
17:52:11 <dolio> lucca: Anyhow, the second function does something somewhat different than the first. If you ever want to turn non-wellformed 'lists' into haskell lists, you'll have to write it anyway.
17:52:18 <Olathe> @quote n.is
17:52:18 <lambdabot> dons says: devils are angry, noisy mini-Russel Crowes. Who wouldn't want those roamin the bush?
17:52:22 <monochrom> Ah, preflex.
17:52:26 <Olathe> @quote n.is.the
17:52:27 <monochrom> preflex: quote nth
17:52:27 <preflex>  no quotes found for nth
17:52:31 <lambdabot> ksf says: Confusion is the first step to enlightenment
17:52:52 <Olathe> Clarity is the first step to xmonad ?
17:53:04 <monochrom> hehehe
17:53:59 <dolio> lucca: If you never want to do that, then the first function is more idiomatic (and no worse, since you'll always be checking the Bool anyway).
17:54:35 <sbahra> http://www.liftM.org/
17:55:07 <mauke> http://vimacs.com/
17:55:41 <sbahra> mauke, ?
17:56:56 <monochrom> the name vimacs reminds you of vim and emacs.
17:57:19 <sbahra> Ok
17:57:25 <sbahra> There is a project called vimacs, too.
17:58:37 <Saizan> are there tutorials on how to restate a problem as a constraint solving one?
17:58:58 <chessguy> wchogg, so we start next monday?
18:02:19 <redditbot> Sad about Import Cycles…
18:04:05 <monochrom> Is redditbot a bot? :)
18:04:26 <dolio> Seems likely.
18:04:52 <dolio> Otherwise it'd probably post the haskell-related stories that end up on the general programming reddit, too.
18:06:00 <chessguy> what is an import cycle?
18:06:12 <dolio> Two modules both depending on one another.
18:06:20 <chessguy> oh, that's not allowed?
18:06:32 <dolio> It is, by Haskell 98.
18:06:36 <monochrom> module X imports Y, Y imports X. Haskell98 allows it but hard to implement in GHC.
18:06:42 <dolio> Most implementations don't handle it well.
18:06:50 <chessguy> but it is implemented?
18:06:53 <dolio> You can do it in GHC if you write an hs-boot file or something.
18:11:34 <pumpkin> @docs Show
18:11:34 <lambdabot> Show not available
18:11:38 <pumpkin> :(
18:15:15 <roconnor> I swear that lambdabot seemed more useful 2 years ago
18:22:34 <oklopol> @quote oklopol
18:22:34 <lambdabot> oklopol says: you shouldn't code haskell just before going to sleep, i had this nightmare where i couldn't get this program to compile
18:22:42 <oklopol> :o
18:23:02 <oklopol> i wasn't sure whether it was just a dream there was a quote of me there
18:27:52 <jhujhiti> is there a standard method of byte-order flipping?
18:28:15 <jhujhiti> more to the point, i need to detect *if* i need to flip bytes in some values before i send them over the wire (networking application)
18:28:33 <jhujhiti> with something like C's htons(), ntohs()
18:28:39 <mauke> where are those values coming from?
18:28:53 <mauke> those C functions have the wrong type
18:28:55 <jhujhiti> Data.Word.Word16
18:29:07 <mauke> how are you converting them to bytes?
18:29:16 <jhujhiti> that's the question ;P
18:29:33 <mauke> no, the question is how to flip bytes in an already existing stream/array
18:29:41 <mauke> I'd use Data.Binary
18:29:45 <jhujhiti> ideally, i'd have a function of type Word16 -> ByteString
18:30:17 <jhujhiti> Data.Binary isn't listed under the ghc docs?
18:30:28 <mauke> it's not part of ghc
18:30:36 <mauke> http://hackage.haskell.org/packages/archive/binary/0.4.4/doc/html/Data-Binary-Put.html#4
18:31:06 <drdo> Guys, how can i solve circular dependencies?
18:31:19 <mauke> drdo: refactor or write a hs-boot file
18:31:31 <drdo> What's a hs-boot file?
18:31:45 <Olathe> > let f :: Word16 -> (Word8, Word8); f x = (fromIntegral (shiftR x 8), fromIntegral x) in f (256*5 + 6)
18:31:47 <lambdabot>   (5,6)
18:31:56 <thoughtpolice> drdo: it allows ghc to compile mutually recursive modules
18:32:10 <jhujhiti> mauke: all right, this looks like it will work, thanks
18:32:26 <rwbarton> jhujhiti: ... yeah, what Olathe said.  How can you even send something which depends on the byte order of your platform?
18:32:27 <drdo> Where can i read about it?
18:32:43 <jhujhiti> rwbarton: this is how network protocols work...
18:32:52 <jhujhiti> rwbarton: everything is defined in "network byte order" which is big-endian
18:32:53 <mauke> drdo: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
18:33:02 <rwbarton> jhujhiti: I understand how protocols work, what I don't understand is how using haskell you need to worry about it.
18:33:29 <sbahra> mauke, http://www.msn.com/
18:33:32 <jhujhiti> i'm going to be sending ByteStrings, which are just Word8s
18:33:33 <Pseudonym> jhujhiti: Not always, of course.  ASN.1 has its own feelings on the matter.
18:33:36 <mauke> sbahra: what?
18:33:37 <jhujhiti> they need to be in the correct order
18:33:52 <jhujhiti> Pseudonym: ASN.1 has its own feelings on a *lot* of matters
18:33:55 <mauke> jhujhiti: how can you generate platform-dependent bytestrings in haskell?
18:33:58 <Pseudonym> :-)
18:34:12 <rwbarton> jhujhiti: there is no way to convert a Word16 to two Word8s without being explicit about byte order anyways, unless you are doing special IO tricks
18:34:27 <jhujhiti> mauke: maybe i'm missing something.. all i need to do is convert a Word16 to a big-endian ByteString...
18:34:28 <Axman6> @hoogle arbitrary
18:34:29 <lambdabot> Test.QuickCheck arbitrary :: Arbitrary a => Gen a
18:34:29 <lambdabot> Test.QuickCheck class Arbitrary a
18:34:29 <lambdabot> Test.QuickCheck coarbitrary :: Arbitrary a => a -> Gen b -> Gen b
18:34:34 <sjanssen> mauke: Foreign.*
18:34:43 <mauke> sjanssen: I didn't ask you :-)
18:34:43 <rwbarton> jhujhiti: All that said, Binary is probably the answer to your problem :)
18:34:58 <ClaudiusMaximus> @type runProcess
18:35:00 <mauke> jhujhiti: the point is, you seem to have completely misdiagnosed your problem
18:35:00 <lambdabot> Not in scope: `runProcess'
18:37:13 <jhujhiti> mauke: i'm not sure i understand what you mean by that
18:37:25 <jhujhiti> the Word16 is clearly in host byte order
18:37:33 <mauke> jhujhiti: no, it isn't
18:37:42 * jhujhiti raises an eyebrow
18:37:54 <mauke> how did you come to that conclusion?
18:37:54 <rwbarton> jhujhiti: it's just a 16-bit word
18:38:19 * pumpkin makes mystical noises and says "it doesn't have a byte order"
18:38:28 <rwbarton> jhujhiti: you have no way of (accidentally or intentionally) treating it as two Word8s
18:38:34 <rwbarton> (barring Foreign.* etc.)
18:38:54 <jhujhiti> then how the hell am i going to get it into a ByteString
18:39:16 <pumpkin> Data.Binary.Put maybe?
18:39:18 <mauke> jhujhiti: how were you going to before?
18:39:32 <jhujhiti> mauke: that's what i came here to ask
18:39:33 <rwbarton> Using arithmetic
18:39:38 <mauke> sigh
18:39:52 <rwbarton> Or Data.Binary.Put, which probably uses arithmetic
18:41:33 <rwbarton> http://hackage.haskell.org/packages/archive/binary/0.4.4/doc/html/src/Data-Binary-Builder.html#putWord16be
18:41:38 <erikc> runGet (sequence [getWord8, getWord8]) . L.fromChunks . (: []) . runPut putWord16host
18:41:48 <erikc> or somesuch
18:41:56 <jhujhiti> rwbarton: that's where i am. just have to install it...
18:41:59 <pumpkin> erikc the binary master!
18:42:21 <mauke> 'cabal install binary'
18:42:30 <rwbarton> jhujhiti: Just saying that source shows you how you could do it manually.
18:43:35 <erikc> pumpkin: put up data.macho today, it parses adium, colloquy and safari ok as far as i can tell, and did a more detailed inspection of a hello world
18:43:51 <erikc> hopefully gonna get data.dwarf up today as well, just have call frame data parsing left
18:43:52 <pumpkin> erikc: wonderful!
18:44:04 <pumpkin> no love for PE and windows? :P
18:44:16 <pumpkin> that's awesome :)
18:44:21 <pumpkin> (all this binary work)
18:44:57 * pumpkin is tempted to write class-dump on top of erikc's mach-o code
18:45:02 <erikc> ill do PE next, im a bit annoyed about microsoft not publishing a spec for PDB though, only an API
18:45:31 <erikc> since i wanted them to be pure haskell
18:45:51 <saml> how can I define function f that will spit out unique integers on each call?
18:46:06 <saml> something like generator in python.
18:46:10 <kpreid> saml: by using something other than haskell
18:46:27 <saml> f = [1..] ! ...
18:46:28 <Saizan> or a monad
18:46:36 <saml> can i do it without monad?
18:46:40 <rwbarton> saml: doesn't sound like a function to me
18:46:46 <saml> ok
18:47:10 <Saizan> @hackage value-supply
18:47:10 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/value-supply
18:47:10 <dolio> Isn't there a supply monad for that?
18:49:06 <saml> can I do it with template  haskell?   $(f)
18:49:19 <saml> then somehow those are replaced with 1, 2, 3, ....
18:49:37 <saml> ok i'll read about template haskell
18:50:04 <kpreid> no, template haskell has nothing to do with that
18:50:12 * chessguy is looking forward to discussing RWH at novalang tomorrow!
18:50:14 <kpreid> what you're looking for just isn't a function
18:50:16 <dolio> You probably can, but then something like "let x = unique in g x x" will be different than "g unique unique".
18:53:22 <rwbarton> dolio: I was assuming that was the desired behavior, which is why this is kind of impossible.
18:54:10 <Olathe> Weird.
18:54:13 <Olathe> @type let g f x y = f x/f y in g toRational
18:54:14 <lambdabot> forall t. (Real t) => t -> t -> Rational
18:54:18 <dolio> If that's the desired behavior, then it's probably easier to use unsafePerformIO.
18:54:24 <Olathe> @type let g x y = let f = toRational f x/f y in g
18:54:25 <lambdabot> <no location info>:
18:54:25 <lambdabot>     not an expression: `let g x y = let f = toRational f x/f y in g'
18:54:30 <Olathe> @type let g x y = let f = toRational in f x/f y in g
18:54:31 <lambdabot> forall a a1. (Real a, Real a1) => a -> a1 -> Rational
18:54:46 <Olathe> Why does f have two different types in the second one ?
18:55:00 <rwbarton> Well, what about  let f () = unique in g (f ()) (f ())
18:55:38 <rwbarton> Olathe: Because @type doesn't have the MR, apparently
18:56:14 <ddarius> Olathe: let-polymorphism
18:56:15 <rwbarton> and let-bound variables are polymorphic
18:56:38 <Olathe> Ahh.
18:56:52 <Olathe> > let g x y = let f = toRational in f x/f y in g (5::Int) (6::Float)
18:56:53 <lambdabot>   Couldn't match expected type `Int' against inferred type `Float'
18:56:58 <Olathe> Ahh, yes.
18:57:12 <Olathe> @type lies !
18:57:13 <lambdabot> parse error (possibly incorrect indentation)
18:57:29 <rwbarton> Olathe: Yes, yes it does.
18:57:39 <dolio> rwbarton: I expect that'd be the same as 'g unique unique'. But I'm not certain.
18:57:41 <Olathe> I wonder if :t in ghci does that.
18:57:49 <ddarius> > let g x y = let f :: a -> Rational; f = toRational in f x / f y in g (5 :: Int) (6 :: Float)
18:57:51 <lambdabot>       Could not deduce (Real a) from the context ()
18:57:51 <lambdabot>        arising from a use...
18:58:02 <ddarius> > let g x y = let f :: (Real a) => a -> Rational; f = toRational in f x / f y in g (5 :: Int) (6 :: Float)
18:58:04 <lambdabot>   5%6
18:58:15 <rwbarton> Olathe: the problem is > has MR and @type does not have MR.
18:58:17 <ddarius> Olathe: -That- "error" was the MR.
18:58:21 <Olathe> g :: (Real a) => a -> a -> Rational
18:58:26 <Olathe> Nope, ghci gets it.
18:58:28 <Olathe> Ahh.
18:59:04 <dolio> rwbarton: That is. In the unsafePerformIO version it'd be the same. In the template haskell I'd expect you'd get the same answer as 'let x = unique in g x x'.
18:59:30 <dolio> rwbarton: Since in the latter you'd be rewriting the syntax tree.
19:00:28 <rwbarton> dolio: Right.  On the other hand is TH guaranteed not to share identical splices?  (Probably...)
19:11:14 <BMeph> Weird. GHCi unifies the types to g for me. :)
19:11:51 <Axman6> hmm, i'm going through chapter 11 of RWH, the one bout QuickCheck and stuff, and one of the examples apears to work in the book, but it's falsifiable after 1 test here :\
19:12:05 <ddarius> BMeph: Why wouldn't they unify?
19:12:24 <Pseudonym> Axman: Want to paste your code on hpaste?
19:13:00 <BMeph> ddarius: They didn't when Olathe did it:
19:13:02 <BMeph> [18:54] <Olathe> @type let g x y = let f = toRational in f x/f y in g
19:13:02 <BMeph> [18:54] <lambdabot> forall a a1. (Real a, Real a1) => a -> a1 -> Rational
19:13:31 <mauke> no MR
19:14:21 <BMeph> mauke:
19:14:22 <BMeph> Prelude> :show languages
19:14:22 <BMeph> active language flags:
19:14:22 <BMeph>   -XImplicitPrelude
19:14:22 <BMeph>   -XMonomorphismRestriction
19:14:22 <BMeph>   -XMonoPatBinds
19:14:49 <BMeph> ...D'Oh! never mind, there's no "No" there. ;p
19:15:16 <ddarius> BMeph: I don't think "unify" was the word you wanted to use.
19:15:20 <Axman6> Pseudonym: http://hpaste.org/13626 (sorry, got a phone call)
19:17:17 <BMeph> ddarius: Right. I think I'll sit in the corner and STFU for a few minutes, while I figure out what I /did/ mean... :\
19:17:42 <rwbarton> Axman6: looks like the fourth line should be combine [x] = [x]
19:18:03 <Axman6> ah yes, that'll be it
19:18:18 <Axman6> thanks rwbarton, that fixed it :)
19:25:28 <Axman6> ah, now i have found one that should fail, and does: prop_text s = text s == Text s, with text "" = Empty; text s = Text s
19:26:04 <Axman6> ah, heh, except i write the test incorrectly -_-
19:30:09 <aluink> @src id
19:30:10 <lambdabot> id x = x
19:30:39 <rwbarton> #haskell, for when you just can't remember how to define id?
19:31:04 <Axman6> o.O
19:31:49 <ddarius> @djinn a -> a
19:31:50 <lambdabot> f a = a
19:32:00 <mauke> @. pl djinn a -> a
19:32:00 <lambdabot> f = id
19:32:46 <ddarius> @unpl id
19:32:47 <lambdabot> (\ a -> a)
19:33:01 <Axman6> hmm, ok this HPC stuff isn't working as it should :(
19:34:01 <Axman6> i'm running ghc -fhpc Run.hs --make, then ./Run then hpc report Run --exclude=Main --exclude=QC like the book says, and it's telling me things like "100% expressions used (0/0)"
19:34:19 <Axman6> "100% top-level declarations used (0/0)", but the tests are running
19:36:24 <Axman6> ah ha, needed to delete all the other .hi and .o files, which the book didn't say
19:39:36 <aluink> http://pastebin.com/d3de8e6fa
19:39:57 <aluink> i've been trying to figure that out for a while, it's from ch04 from RWH, anyone care to help explain it, i'm not getting it
19:40:22 <mauke> what's the problem?
19:40:41 <aluink> understanding how that is a foldl in forms of a foldr
19:41:15 <aluink> @type foldr
19:41:16 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
19:42:32 <Axman6> > let myFoldl f z xs = foldr step id xs z where step x g a = g (f a x) in myFoldl f x [a,b,c]
19:42:34 <lambdabot>   f (f (f x a) b) c
19:42:47 <pumpkin> omg magick
19:42:50 <Axman6> > let myFoldl f z xs = foldr step id xs z where step x g a = g (f a x) in myFoldl f x [a,b,c,d] -- for funzies
19:42:51 <lambdabot>   f (f (f (f x a) b) c) d
19:43:01 <mauke> > foldl f x [a,b,c]
19:43:02 <lambdabot>   f (f (f x a) b) c
19:43:57 <Axman6> > let myFoldl f z xs = foldr step h xs z where step x g a = g (f a x) in myFoldl f x [a,b,c,d] -- for funzies
19:43:59 <lambdabot>   Add a type signature
19:44:11 <Axman6> > let myFoldl f z xs = foldr step h xs z where step x g a = g (f a x) in myFoldl f x [a,b,c,d] :: Expr
19:44:13 <lambdabot>   h (f (f (f (f x a) b) c) d)
19:44:24 <Axman6> how handeh
19:44:39 <aluink> i don't understand what lambda bot is doing
19:44:50 <mauke> aluink: evaluating expressions
19:44:51 <Axman6> though how that definition of foldl works is still beyond me
19:44:52 <aluink> ahh
19:44:54 <lambdabot> The feeling is mutual.
19:45:05 <saml> @pl f [x] = f x
19:45:06 <Axman6> o.O
19:45:06 <lambdabot> (line 1, column 7):
19:45:06 <lambdabot> unexpected "="
19:45:06 <lambdabot> expecting variable, "(", operator or end of input
19:45:09 <sjanssen> aluink: do you see how step has three arguments?  the function passed to foldr usually takes only two -- this is an important insight
19:45:18 <Pseudonym> @pl \[x] -> f x
19:45:18 <lambdabot> (line 1, column 2):
19:45:18 <lambdabot> unexpected "["
19:45:18 <lambdabot> expecting pattern
19:45:22 <aluink> yeah, part of why i'm so confused
19:45:26 <Pseudonym> @pl \x -> f (head x)
19:45:26 <lambdabot> f . head
19:45:56 * Axman6 gets back to RWH
19:45:56 <mauke> aluink: meditate on 'flip id'
19:45:57 <aluink> @help pl
19:45:58 <lambdabot> pointless <expr>. Play with pointfree code.
19:46:09 <saml> there's no peeling function?  single element list to single element
19:46:17 <dibblego> saml, head
19:47:01 <saml> hrm i guess i won't define this pointfree way
19:47:08 <aluink> mauke: mediate on 'flip id'?
19:47:18 <Axman6> :t flip id
19:47:19 <lambdabot> forall b c. b -> (b -> c) -> c
19:47:34 <aluink> @src flip id
19:47:35 <lambdabot> Source not found. The more you drive -- the dumber you get.
19:47:44 <aluink> @src flip
19:47:44 <lambdabot> flip f x y = f y x
19:49:04 <aluink> wow,  i know a lot of this might have been helpful to get me to understand this...but i'm as confused as before, if not more
19:49:29 <mauke> 'flip id' is concentrated confusion
19:49:36 <aluink> haha
19:49:45 <BMeph> aluink: I'm confused about where you're confused. :)
19:50:01 <aluink> well, for starters why does step take 3 args, and not two
19:50:15 <mauke> because this foldr builds a function
19:50:26 <Asztal> "flip flip" from @pl was confusing.
19:50:48 <mauke> each intermediate result is a funclet, and they're all combined into a single big function
19:50:50 <Asztal> of course it's obvious once you think about it
19:50:54 <aluink> ok, i know it builds a function, that i got...so how does step takging 3 args have anything to do with that?
19:50:54 <mauke> which is applied to z in the end
19:50:58 <ddarius> @unpl flip flip
19:50:58 <lambdabot> (\ b c f -> c f b)
19:51:14 <mauke> aluink: foldr calls step with two arguments
19:51:15 <aluink> hmmm, ok let me see that
19:51:35 <mauke> what happens when you call a function of 1 argument with 0 arguments?
19:51:43 <aluink> where the initial accumulator is id
19:51:53 <aluink> you get the function back
19:51:54 <mauke> answer: you get that function back because that wasn't a "call" at all
19:52:05 <mauke> what happens when you call a function of 2 arguments with 1 argument?
19:52:09 <chrisdone> you achieve satori
19:52:14 <Pseudonym> > id
19:52:14 <aluink> yeah, i read that in partial function, the suggested read ahead material
19:52:15 <lambdabot>       Overlapping instances for Show (a -> a)
19:52:15 <lambdabot>        arising from a use of `s...
19:52:26 <Pseudonym> > id :: Expr
19:52:27 <lambdabot>   Couldn't match expected type `Expr' against inferred type `a -> a'
19:52:30 <mauke> > (+) 2 2
19:52:32 <lambdabot>   4
19:52:33 <sereven> hehe " you may want... some headache pills and a glass of water... and a pencil and paper [to work out understanding myFoldl]" -- OR -- #haskell
19:52:38 <BMeph> chrisdone: I'd rather achieve tandoori, it's much tastier! ;p
19:52:44 <aluink> :type +2
19:52:46 <Pseudonym> Mmmm... sartori...
19:52:49 <mauke> > let zomg = (+) 2 in (zomg 1, zomg 5)
19:52:50 <lambdabot>   (3,7)
19:52:53 <aluink> @type (+) 2
19:52:55 <lambdabot> forall t. (Num t) => t -> t
19:52:56 <chrisdone> BMeph: mmm
19:53:01 <aluink> yeah, i get that
19:53:04 <Pseudonym> I had some sartori for lunch, with chinotto.
19:53:17 <aluink> #haskell, extra brain power
19:53:28 <mauke> aluink: step x g = \a -> g (f a x)
19:53:31 <juhp_> > (+) 2
19:53:31 <pumpkin> Pseudonym: chinotto :o
19:53:32 <lambdabot>       Overlapping instances for Show (t -> t)
19:53:32 <lambdabot>        arising from a use of `s...
19:53:49 <chessguy> @pl s x g a = g (f a x)
19:53:50 <lambdabot> s = flip (.) . flip f
19:53:56 <BMeph> aluink: "#haskell: What happens when you don't take 'the Blue Pill'" ;P
19:54:06 <aluink> BMeph: haha
19:56:25 <bhurt> Haskell does not have the Buddha nature.  Buddha has the Haskell nature.
19:57:09 <aluink> would it have been the same to write step as
19:57:43 <aluink> step x g = \a -> g (f a x)
19:57:44 <aluink> ?
19:57:58 <desp> Does anyone know if there's an IRC channel devoted to the Pure language?
19:58:01 <mauke> aluink: yes
19:58:05 <aluink> NICE!
19:58:15 <aluink> ok, i'm getting this, the syntax threw me off
19:58:17 <mauke> aluink: f x y = ... is just syntactic sugar for f = \x -> \y -> ...
19:58:28 <aluink> ok
19:58:50 <aluink> so we're building a f . f  . f . f ...
19:58:53 <aluink> sorta
19:59:00 <aluink> which will get applied to z
19:59:02 <mxc> seen? dons
19:59:09 <Pseudonym> ?seen dons
19:59:09 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 1d 52m 11s ago.
19:59:21 <mxc> ?seen bos
19:59:22 <lambdabot> I saw bos leaving #ghc and #haskell 5h 7m 3s ago, and .
19:59:38 <mxc> oh, oops
19:59:58 <desp> http://code.google.com/p/pure-lang/
20:00:11 <desp> Anyone into it?
20:00:17 <mxc> anyway, dons, bos, since you've been so helpful here and written a great book, i've done what I could:  http://www.amazon.com/review/product/0596514980/ref=cm_cr_dp_all_helpful?_encoding=UTF8&coliid=&showViewpoints=1&colid=&sortBy=bySubmissionDateDescending
20:01:02 <sjanssen> #concatenative, eh?  Is somebody defecting to forth? :)
20:01:16 <Pseudonym> Pure looks interesting.
20:01:29 <jeffz`> #concatenative is more about factor than anything else
20:01:36 <aluink> so since foldr is always calling step with two args and not three, it's constantly returning a function a -> b
20:01:37 <Pseudonym> Unfortunately, it also looks like ML.
20:01:53 <aluink> of type*
20:01:57 <desp> Pseudonym: I'm hoping to ask someone knowledgeable why does Pure enforce pattern linearity.
20:02:27 <Pseudonym> desp: You mean no repeated variables in patterns?
20:02:30 <desp> Yes.
20:02:43 <Pseudonym> Well I know why Haskell doesn't do it.
20:03:04 <Pseudonym> First off, it brings Eq into the desugaring phase.
20:03:12 <Pseudonym> Which seems like bad coupling.
20:03:27 <Pseudonym> Second, it's usually an inintended bug in complex patterns.
20:03:31 <desp> Well, Pure has a separate notion of syntactic equality, and they provide special operators (===, ~==)
20:03:37 <Pseudonym> Third, it raises all sorts of laziness issues.
20:03:52 <Pseudonym> In Haskell, patterns are matched top-to-bottom, left-to-right.
20:03:59 <desp> Look at 4.3.4 in http://pure-lang.googlecode.com/svn/docs/pure-intro/pure-intro.pdf
20:04:04 <aluink> ?seen mightybyte
20:04:04 <lambdabot> mightybyte is in #haskell. I don't know when mightybyte last spoke.
20:04:05 <Pseudonym> And then guards are checked.
20:04:19 <Pseudonym> It's not obvious where to put the call to (==).
20:04:19 <mauke> preflex: seen mightybyte
20:04:19 <preflex>  mightybyte was last seen on #haskell 4 days, 14 hours, 36 minutes and 26 seconds ago, saying: ivanm: It appears so.  (mauke just told me about it)
20:04:23 <alatter> Pseudonym: Eq is already in the de-sugaring phase.  Do a pattern match on a literal string with -XOverloadedStrings
20:04:38 <Pseudonym> alatter: Oh, interesting.
20:04:43 <Pseudonym> But that's an optimisation, surely?
20:04:56 <sjanssen> alatter: or just a Num pattern literal in Haskell '98
20:05:05 <desp> Pseudonym: I think the interesting thing about Pure is that it's based on term rewriting, so you can do nice things directly in the language.
20:05:11 <Pseudonym> Right.
20:05:17 <Pseudonym> So like Clean in that respect?
20:05:22 <alatter> sjanssen: yeah, but Num encompasses Eq, so that's a more confusing example :-)
20:05:52 <alatter> Pseudonym: Eq becomes a class constraint on the argument
20:06:22 <Pseudonym> Looking at Pure, the thing I like about it the most is that it shows just how small a useful compiler can be, when you use LLVM.
20:06:46 <desp> Clean apparently uses graph rewriting, which seems to be slightly different.
20:07:33 <desp> http://code.google.com/p/pure-lang/source/browse/trunk/pure/examples/symbolic.pure -- not very ML-like, I would think. :)
20:08:46 <Pseudonym> Anyway, the problem in Haskell is where to put the (==).
20:09:00 <Pseudonym> I can imagine that in Pure, linearity plays semantic havoc with rewriting rules.
20:09:22 <sjanssen> Pseudonym: why not use the same rules as Num pattern literals (which also use Eq)?
20:09:25 <Pseudonym> Because a repeated variable is a side-condition.
20:12:37 <benl23> preflex: seen dcoutts_
20:12:37 <preflex>  dcoutts_ was last seen on #haskell 13 days, 11 hours, 32 minutes and 45 seconds ago, saying: gwern: I've not been hacking on gtk2hs for a while now, pgavin took over as release manager
20:16:18 <luite_> I have a list with some values, and want to replace each value by the 'order' of the first encounters of each value, for example: [3,1,1,4,3] should result in [1,2,2,3,1]. any ideas how to do this (efficiently, preferably)
20:18:45 <kpreid> hm
20:18:52 <ddarius> If someone is bored, an implementation of Barry Jay's pattern calculus would be a fun exercise.
20:19:07 <Axman6> preflex: seen dcoutts
20:19:08 <preflex>  dcoutts was last seen on #ghc 1 day, 11 hours, 47 minutes and 8 seconds ago, saying: all the stuff from 'sunrise'
20:21:37 <kpreid> > let order' [] _ _ = []; order' (x:xs) m i = case lookup x of {Nothing -> i : order' xs (insert x i m) (i+1)}; order xs = order' xs Map.empty 1 in order [3,1,1,4,3]
20:21:39 <lambdabot>   Couldn't match expected type `[(t, b)] -> Maybe b'
20:22:20 <altmattr> can anyone tell me why polymorphic recursion is included in haskell98 but rank0n types need a type system extension?
20:22:23 <kpreid> > let order' [] _ _ = []; order' (x:xs) m i = case Map.lookup x of {Nothing -> i : order' xs (Map.insert x i m) (i+1); Just i' -> i' : order' xs m i}; order xs = order' xs Map.empty 1 in order [3,1,1,4,3]
20:22:25 <lambdabot>   Couldn't match expected type `M.Map t a -> m a'
20:22:27 <altmattr> they seem very similar
20:22:56 <altmattr> s/rank0n/rank-n
20:23:01 <kpreid> > let order' [] _ _ = []; order' (x:xs) m i = case Map.lookup x m of {Nothing -> i : order' xs (Map.insert x i m) (i+1); Just i' -> i' : order' xs m i}; order xs = order' xs Map.empty 1 in order [3,1,1,4,3]
20:23:03 <lambdabot>   [1,2,2,3,1]
20:23:12 <kpreid> luite_: how's that?
20:23:25 <ddarius> desp: You may find this interesting http://www-staff.it.uts.edu.au/~cbj/Publications/purepattern.pdf
20:23:55 <kpreid> luite_: (actually it ought to use IntMap, perhaps)
20:23:58 <altmattr> desp: what did I miss?  pattern calculus is something I spend all day thinking about
20:24:09 <kpreid> wait, no, map from xs, never mind
20:25:23 <desp> ddarius: thanks.
20:25:57 <desp> altmattr: well, I was asking why Pure requires patterns to be linear, while it allows explicit testing of syntactic equality.
20:26:33 <altmattr> desp: "Pure"?
20:26:41 <luite_> kpreid: ah, looks good. was hoping for some clever way to do it without a map, but I don't see one either
20:26:50 <desp> altmattr: http://pure-lang.googlecode.com/svn/docs/pure-intro/pure-intro.pdf 4.3.4
20:27:02 <altmattr> It is so that the set of binding variables don't change
20:27:15 <altmattr> desp: that last one is for you :)
20:27:16 <ddarius> desp: http://www-staff.it.uts.edu.au/~cbj/bondi/
20:27:31 <rwbarton> luite_: if efficiency was not a concern, you could write something like...
20:27:37 <kpreid> luite_: hmm, cleverness...I think I see an inefficient way...
20:27:45 <ddarius> Jay apparently doesn't keep his homepage updated, so a lot of his newer papers (and stuff) can only be found by looking at the bibtex file.
20:28:28 <altmattr> desp: otherwise you can read in a var and not spit it back out.  Since this is happening in patterns, you are then changing the set of binding vars and thus making major unpleasant changes to the semantics of the term.
20:28:31 <kpreid> oh, nope...
20:28:46 <desp> altmattr: I don't understand why a non-linear pattern couldn't simply be a syntactic shortcut to a linear pattern and an explicit test...
20:28:54 <altmattr> ddarius: how much do you know about Jay's work?
20:28:56 <dolio> altmattr: It may not have been well known that you could add rank-n polymorphism to Haskell's type system with similar ease to the way they allowed for polymorphic recursion at the time H98 was defined.
20:28:59 <desp> altmattr: I'm not sure if we're on the same page here.
20:29:03 <rwbarton> > let order xs = let y = nub xs in map ((+1) . fromJust . flip elemIndex y) xs in order [3,1,1,4,3]
20:29:04 <lambdabot>   [1,2,2,3,1]
20:29:07 <desp> :)
20:29:11 <kpreid> > let order' [] _ = 0; order' (x:xs) i = i : order' (delete x xs) (i+1);  order xs = order' xs 0 in order [3,1,1,4,3]
20:29:13 <lambdabot>       No instance for (Num [t])
20:29:13 <lambdabot>        arising from a use of `order' at <inte...
20:29:26 <altmattr> dolio: thanks :)
20:29:36 <kpreid> this doesn't work, even if I didn't make some mistake, because it forgets where the further elements are
20:29:39 <ddarius> altmattr: I've read most of the papers listed on his site, but not most of the newer ones in his bibtex file.  I just now discovered bondi.
20:30:04 <kpreid> rwbarton: nice
20:30:11 <altmattr> desp: we are probably not on the same page, since I am not quite sure what you mean by syntactic shortcut
20:30:29 <desp> altmattr: can you take a look at section 4.3.4 of http://pure-lang.googlecode.com/svn/docs/pure-intro/pure-intro.pdf ? :)
20:30:42 <altmattr> ddarius: what are your thoughts on the pattern calculus?  I am trying to write a compiler using some of it's ideas
20:31:01 <altmattr> desp: will do
20:31:27 <luite_> rwbarton: ah nice
20:32:17 <ddarius> altmattr: It seems interesting.  I'm not sure how easy it would be to make an efficient implementation.  It may be able to provide a nice solution to the expression problem.  Mostly I don't know much about it other than what I've read.
20:32:31 <kpreid> luite_: note in that version that elemIndex is O(n) and nub is O(n^2)
20:33:27 <altmattr> ddarius: my approach is to see if the extra genericity buys you things in the compiler that you can expose to the programmer
20:33:54 <altmattr> ddarius: I think I can squeeze most standard functional programming optimistations through
20:34:29 <altmattr> ddarius: anyway, good to know it has some mindshare somewhere - there are not many people who even know what it is!
20:34:42 <altmattr> desp: seems like you and I have quite a bit to chat about :)
20:34:54 <luite_> kpreid: yes I see. I'm not going to actually use it :)
20:35:17 <ddarius> "The pattern calculus is a new foundation for computation, in which the expressive power of functions and of data structures are fruitfully combined within pattern-matching functions.  The best of existing foundations focus either on functions (in the λ-calculus) or on the data structures (Turing machines) or compromise on both (as in object-orientation.)  By constrast, a small typed pattern calculus supports all the main programming styles, including fu
20:35:17 <ddarius> nctional, imperative, object-oriented and query-based styles.  Indeed, it supports web-services, to the extent that these are generic functions applied to partially specified data structures."
20:35:54 <altmattr> desp: I am doing a very similar thing from the pure pattern side.  One difference is that I am very interested in types.
20:36:23 <desp> altmattr: I must say that I'm not really doing anything in this area; just curious. ;)
20:36:28 <altmattr> desp: I have at various times spent quite a lot of energy thinking about the relation to term-rewriting systems
20:36:34 <altmattr> desp: ah - ok
20:38:36 <altmattr> desp: that is a lot of stuff to read....
20:38:52 <altmattr> desp: sorry, missed the 4.4.3 ref
20:38:58 <desp> 4.3.4
20:39:14 <altmattr> desp: indeed
20:39:18 <desp> It's just a small, simple definition.  All you need to know is that the language is call-by-value by default.
20:40:59 <altmattr> desp: so the linearity here is just the same as haskell enforces right?
20:42:24 <desp> Well, it's not obvious to me why Haskell does that, but I assume there are issues with laziness.
20:42:32 <altmattr> desp: the reference seems to turn itself in circles
20:42:59 <altmattr> desp: in haskell, same x x =1 would be written same x y = if x == y then 1
20:43:28 <altmattr> desp: but why he needs this extra equality I am not sure of
20:43:39 <desp> Take a look at uniq
20:44:18 <desp> This extra "syntactic" equality is always defined, since it's (as I understand) based on the term representation.
20:44:31 <altmattr> desp: the example he gives (0 == 0.1) but not (0 === 0.0) only makes sense since the language is untyped an only applies where automatic coercions would allow it - surely
20:44:46 <altmattr> s/(0 == 0.1)/(0 == 0.0)
20:45:41 <desp> What I don't understand is, if you can specify the test explicitly (line 3 of uniq), then why not just transfor a non-linear pattern into a linear one, and add the tests automatically?
20:46:09 <desp> transform*
20:46:18 <altmattr> desp: in haskell the reason is that the semantics of such an automatic conversion are not obvious
20:46:28 <altmattr> desp: let me find a reference
20:47:12 <Pseudonym> desp: Basically, the issue is this.
20:47:24 <Pseudonym> We'll ignore lazy patterns for the moment, which muck things up even further.
20:47:34 <Pseudonym> f P Q R
20:47:40 <Pseudonym> where P, Q and R are some patterns.
20:47:47 <ztirf_> @src logBase
20:47:48 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
20:47:48 <Pseudonym> This is, essentially, desugarred into:
20:48:09 <Pseudonym> f p q r = case p of { P -> case q of { Q -> case r of { R -> ...} } }
20:48:30 <Pseudonym> Now, suppose you have nonlinear patterns.
20:48:32 <Pseudonym> Say, this:
20:48:37 <Pseudonym> f x x True = foo
20:48:43 <Pseudonym> Where would you put the equality test?
20:49:21 <Pseudonym> Do you try to match the True first or not?
20:50:14 <altmattr> desp: section 4.2.7 of "Implementing Functional Languages" by Simon Peyton Jones discusses it.
20:50:17 <desp> Well, if you were defining a new language, why not decide one way or another?
20:50:32 <desp> altmattr: thanks, I'll look it up.
20:50:33 <Pseudonym> desp: Miranda, which was Haskell's successor, had this feature.
20:50:45 <mauke> successor?
20:50:48 <dolio> Predecessor.
20:50:52 <Pseudonym> predecessor, yes
20:51:08 <Pseudonym> It was dropped precisely because the "one way or other" decision was arbitrary.
20:51:22 <monochrom> Perhaps f x True x = foo shows the dilemma better.
20:51:34 <Pseudonym> monochrom: No, because I was going to follow it up with:
20:51:41 <Pseudonym> f x x True = expr_1
20:51:44 <Pseudonym> f x y False = expr_2
20:51:53 <desp> Hmm.
20:51:55 <Pseudonym> So consider: f bottom bottom False
20:52:06 <Pseudonym> Does it match or not?
20:52:13 <mauke> Pseudonym: no
20:52:16 <Pseudonym> Or, rather, does f return bottom or not.
20:52:19 <mauke> yes
20:52:36 <Pseudonym> Yes, it returns bottom or not.  I agree with you there.
20:52:52 <mauke> the test is attached to the second x
20:53:04 <monochrom> We ignore laziness for the moment. Do we have a strict language now?
20:53:32 <Pseudonym> monochrom: Miranda-like languages have always applied the rule that conformality checks in pattern matching are completed.
20:53:35 <Pseudonym> So this:
20:53:54 <Pseudonym> let f _ 1 = in f undefined   -- This returns 1
20:54:01 <alatter> Pseudonym: why not just re-write f x x True = ... into f x {new-name} True | x == {new-name} = ... ?
20:54:03 <Pseudonym> let f (_,_) 1 = in f undefined   -- This returns bottom
20:54:16 <ddarius> Pseudonym is a bit dyslexic today.
20:54:25 * Pseudonym is indeed
20:54:28 <Pseudonym> First day back at work.
20:54:31 <JoshTriplett> @hoogle Tag -> String
20:54:31 <lambdabot> Warning: Unknown type Tag
20:54:32 <lambdabot> Distribution.Text display :: Text a => a -> String
20:54:32 <lambdabot> Prelude show :: Show a => a -> String
20:54:38 <JoshTriplett> Hmmm.
20:54:42 <mauke> alatter: I'd prefer f x x' {x == x'} True
20:54:46 <Pseudonym> alatter: So you mean delaying the equality tests until the pattern matching is done.
20:54:58 <dolio> alatter: Why not rewrite it into: f x {new-name} {new-name2} | x == {new-name} = case {new-name2} of True -> ...?
20:55:00 <Pseudonym> You can do that, yes, but then pattern matching isn't strictly left-to-right.
20:55:46 <alatter> Psuedonym: I have no idea how guards are desugared.  But I can imagine someone wanting the duplicate symbols to act the same as the equivalent langugage feature
20:56:08 <Pseudonym> alatter: By moving the equality test to guards, you make it explicit when the equality test happens.
20:56:27 <JoshTriplett> Anyone know of a function to convert TagSoup's Tag objects back to HTML, safely?  Its Show instance just uses the normal derived show.
20:56:35 <Pseudonym> Lazy pattern matching is yet another complication.
20:56:38 <Pseudonym> f ~(x,x) = ...
20:56:53 <Pseudonym> How do you desugar that?
20:56:57 <JoshTriplett> By "safely" I mean correctly handling characters that need entities.
20:57:24 <desp> Pseudonym: if we intend to keep left-to-right matching, then why not test after each match?  That seems intuitive.
20:57:29 <mauke> f y = let (x,x) = y in ...
20:57:47 <Pseudonym> desp: Things get more complicated when you have complex pattern matches.
20:58:04 <desp> I'm not sure how to read ~(x,x)
20:58:09 <alatter> f ~(x,x) = ...  ==> f ~(x,y) = if not (x==y) then undefined else ...
20:58:11 <alatter> :-)
20:58:29 <mauke> f (x,y) (y,x)
20:58:34 <Pseudonym> desp: f ~(x,y) = foo roughly means f p = let { x = fst p; y = snd p } in foo
20:58:37 <JoshTriplett> desp: ~ forces the pattern match to succeed, and then fails later if it doesn't match.
20:58:48 <desp> Ouch.
20:59:15 <dolio> alatter: f ~(x,x) = 3 desugars to f ~(x,y) = if not (x == y) then undefined else 3?
21:00:17 <JoshTriplett> desp: For instance (bad example, but...): listToMaybe l@~(x:_) = if null l then Nothing else Just x
21:00:19 <rwbarton> Doesn't seem very lazy.
21:00:44 <JoshTriplett> desp: That wouldn't work with a non-lazy pattern match.
21:00:48 <desp> JoshTriplett: yes, thank you.
21:00:59 <Pseudonym> The thing is, we're only dealing with the case of one rule here.
21:01:10 <Pseudonym> When you have multiple rules, pattern matches are turned into cascades of case statements.
21:01:18 <alatter> dolio: I think my idea would fail for other reasons.  Such as nested patterns in patterns
21:01:25 <dolio> :)
21:01:52 <JoshTriplett> Hmmm.
21:02:03 <dolio> alatter: You might get closer with replacing every use of 'x' with "if not (x == y) then undefined else x", but I'm not sure that'd be acceptable either.
21:02:25 <dolio> Of course, you could let that to be less verbose.
21:02:37 <Pseudonym> Oh, that's another thing.
21:02:44 <Pseudonym> _which_ x is it that's returned?
21:03:21 <Pseudonym> You can, again, disambiguate by saying "the leftmost one".
21:03:29 <Pseudonym> Or something like thatr.
21:03:43 <alatter> Pseudonym: if the match fails it's an exception, so it doesn't matter.  If it passes, they're equal, so it doesn't matter much
21:04:05 <rwbarton> alatter: They're only ==
21:04:09 <Pseudonym> Right.
21:04:13 <Pseudonym> Consider:
21:04:21 <desp> Pseudonym: we were originally talking about syntactic equality in Pure, so which x wouldn't matter.
21:04:26 <Pseudonym> data Rational a = Rational a a
21:04:47 <alatter> rwbarton:  right.  Hence "much"
21:04:57 <Pseudonym> instance (Num a) => Eq (Rational a) where { (Rational n1 d1) == (Rational n2 d2) = n1*d2 == n2*d1 }
21:05:19 <jsgf> hi all
21:05:27 <alatter> Pseudonym:  It's the same for maps.  or any opaque type, I suppose.
21:05:31 <alatter> hi!
21:05:34 <Pseudonym> Right.
21:05:43 <ztirf> does int2Double in GHC.Float have reasonable performance, or do I have to use int2Double# ?
21:05:45 <jsgf> i have a combinator which seems like it should be something that's either in the standard library, or easily assembled
21:05:57 <jsgf> but i'm having a bit of a block
21:06:08 <jsgf> its: chain f1 f2 a b = f1 (f2 a b) b
21:06:13 <rwbarton> what is  let f ~(x, x) = (x, x) in f (2, 3)?  _|_, or (_|_, _|_)?
21:06:22 <desp> alatter: did you mean 4.2.7 in "Implementing Functional Languages (a tutorial)", or the "Functional Language Implementation (a book)"?
21:06:37 <desp> Blah.
21:06:41 <desp> Still different title. ;)
21:06:47 <rwbarton> Oh, I guess it's definitely the latter.
21:06:49 <desp> "The Implementation..."
21:07:18 <desp> alatter: right, got it now, thanks. ;)
21:07:24 <jsgf> any thoughts?
21:07:33 <alatter> desp:  good ting you got it, because I have no idea what you're talking about ^_^
21:07:46 <rwbarton> @pl \f1 f2 a b -> f1 (f2 a b) b
21:07:47 <lambdabot> flip flip id . ((flip . (ap .)) .) . (.) . (.)
21:07:55 <alatter> eeek
21:08:01 <jsgf> rwbarton: yeah, tried that, but hardly an improvement
21:08:06 <Pseudonym> @pl \f1 f2 a b c = f1 (f2 a b) c
21:08:06 <lambdabot> (line 1, column 14):
21:08:06 <lambdabot> unexpected "="
21:08:06 <lambdabot> expecting pattern or "->"
21:08:07 <rwbarton> Indeed
21:08:11 <Pseudonym> @pl \f1 f2 a b c -> f1 (f2 a b) c
21:08:11 <lambdabot> (.) . (.)
21:08:29 <desp> alatter: SPJ wrote two things with similar titles; one is http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/ ; other is http://research.microsoft.com/en-us/um/people/simonpj/papers/pj-lester-book/
21:08:38 <ray> that's not pointless, it's got 3 "points"
21:09:07 <rwbarton> jsgf: Well, we might as well eliminate 'a'
21:09:14 <rwbarton> @pl \f1 f2 b -> f1 (f2 b) b
21:09:14 <lambdabot> flip flip id . liftM2
21:09:17 <alatter> desp:  right.  But I think it was someone else that directed you to a chapter in them.
21:09:21 <rwbarton> Should be related to the Reader monad
21:09:33 <desp> alatter: whoops
21:09:38 <altmattr> desp: "The Implementation of Functional Programming Languages" (book)
21:09:49 * desp rubs eyes
21:10:23 <ddarius> desp: altmattr
21:10:35 <desp> Indeed.
21:11:01 <rwbarton> @pl \f1 f2 b -> f1 b (f2 b)
21:11:01 <lambdabot> ap
21:11:21 <rwbarton> jsgf: the problem is your arguments are not in the conventional order
21:11:28 <altmattr> desp: its a jolly good read as well
21:11:50 * ddarius hasn't read the book
21:12:19 <jsgf> rwbarton: hm, ok.  in this case 'a' is a state, and 'b' is the update; so rather than State a -> a -> State a, I should have a -> State a -> State a?
21:13:35 <rwbarton> jsgf: Oh.  Yes, stuff -> state -> state is good, so that you can compose  f2 stuff2 . f1 stuff1
21:13:58 <altmattr> ddarius: I would recommend it, but I think you might already know everything in it!
21:14:17 <altmattr> ddarius: It was the thing that took me from haskell-able to haskell-addicted
21:17:18 <kniu> Is it wrong to think of the type of a function as another function, albeit a type-level one that takes as arguments the types of the first function's arguments?
21:17:44 <chessguy_work> say what?
21:18:07 <chessguy_work> what is this, an abbott and costello routine?
21:18:21 <rwbarton> kniu: Its arguments should be whatever types the original function was polymorphic in
21:18:25 <Pseudonym> Yes, it's wrong, because Haskell has real type functions.
21:18:43 <kniu> well, dang.
21:18:47 <Pseudonym> Type-level computations are available using fundeps and type families.
21:19:14 <Pseudonym> I should say fundeps and/or type families.
21:20:05 <rwbarton> kniu: Actually, what I said is mostly wrong, too.
21:22:27 <Gracenotes> is category theory necessary for understanding type theory?
21:22:36 <dolio> No.
21:22:44 <Gracenotes> what is, then? :)
21:22:48 <dolio> Type theory.
21:22:52 <Gracenotes> ...oic
21:22:56 <Gracenotes> >_>
21:23:02 <rwbarton> Nor is it sufficient :)
21:23:05 <monochrom> beautiful mind
21:23:36 <Gracenotes> any good places to start?
21:23:42 <dmwit__> Get a good book.
21:23:45 <dolio> I'm no expert, but I think type theory on the mathematical end was originally made to be a foundation for mathematics.
21:23:48 <dmwit__> Types and Programming Languages is pretty good.
21:23:50 <chessguy_work> TAPC
21:23:53 <chessguy_work> err, yeah
21:24:10 <dolio> (Specifically, constructive mathematics.)
21:24:35 <Pseudonym> It was originally made to try to eliminate Russell's paradox.
21:24:43 <dolio> Of course, if you go way back, types were for avoiding Russel's paradox.
21:24:47 <dolio> Yeah.
21:24:53 <Pseudonym> You owe me a coke.
21:24:55 <monochrom> @quote fugue
21:24:55 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
21:24:56 <dolio> :)
21:25:14 <Gracenotes> oh, I love contrapunctal fugues
21:25:39 <Gracenotes> heh, the first result in my university's library website searching for Types and Programming Languages is "Data abstraction and problem solving with Java : walls and mirrors"
21:25:53 <monochrom> That is miserable.
21:26:06 <Pseudonym> s/walls/smoke/
21:26:35 <Gracenotes> then there's "Computer science : an overview" and "Java : a framework for program design and data structures" and "Modular programming languages : Joint Modular Languages Conference"
21:26:36 <monochrom> Let's hope if you search for category theory you will not get "Enterprise Visual BASIC"
21:26:59 <dmwit> Gracenotes: It sounds like you need to search in a better library.
21:27:20 <Gracenotes> the first result for category theory is "Memory and mind : a festschrift for Gordon H. Bower"
21:27:27 <Gracenotes> then there's something about Hopf algebras
21:27:38 <Pseudonym> Hopf algebras are good.
21:27:40 <ddarius> Go for the Hopf algebras book (out of those two)
21:27:46 <Gracenotes> and then there's "The disabilities studies reader"... >_>
21:27:56 <Pseudonym> Though if you are interested in the philosophy of mind, the first one might be interesting.
21:27:57 <Gracenotes> which is about what it sounds like it's about
21:29:04 <Gracenotes> given that I don't completely understand commutative diagrams yet, Hopf algebras may be of limited use to me
21:29:20 <ddarius> Gracenotes: Commutative diagrams are just a notation for equations.
21:29:44 <monochrom> f . g = h . k
21:30:08 <Pseudonym> I didn't understand commutative diagrams until I noticed (since no book that I'm aware of makes it explicit) that the same object can appear as distinct nodes.
21:30:09 <ddarius> Gracenotes: The only rule is two (directed) paths with the same start and same end are the same.
21:30:24 <Gracenotes> just tell that to this little dude: http://en.wikipedia.org/wiki/File:HopfAlgebra.png
21:30:27 <monochrom> In fact Fokkinga abandons diagrams and just does equations and algebra.
21:30:42 <ddarius> I'm not too keen on commutative diagrams.
21:31:03 <Pseudonym> They can be overused.
21:31:05 <ddarius> They are good for some mnemonic value for certain situations, but they are hard to manipulate and sparse.
21:31:19 <Pseudonym> It's nice to be able to give one picture as a proof.
21:31:46 <Pseudonym> But that's not always useful if what you're trying to do is instill understanding in the reader.
21:31:49 <rwbarton> Commutative diagrams are seriously indispensible in topology, at least.
21:32:06 <rwbarton> Although one well-known topologist has been known to leave off the arrowheads :)
21:32:12 <monochrom> http://wwwhome.cs.utwente.nl/~fokkinga/#detail_0000003536  is Fokkinga's category theory tutorial
21:32:19 <Pseudonym> Given that commutative diagrams are isomorphic to systems of equations, I doubt they're "indispensible".
21:32:25 <ddarius> Gracenotes: All that means is Δ;S⊗id;∇ = ε;η = Δ;id⊗S;∇ where ; is reverse composition (i.e. flip (.)
21:32:26 <ddarius> )
21:32:42 <Pseudonym> i.e. (>>>)
21:33:10 <rwbarton> Pseudonym: That's like saying that graphs are dispensible, because they can be described by a set of vertices and edges.
21:33:22 <Pseudonym> Your point?
21:33:30 <rwbarton> Pseudonym: But have you ever seen a graph theory book without graphs drawn as diagrams?
21:33:48 <rwbarton> Pseudonym: I don't mean to some abstract theory, but rather to the practice of working in the area.
21:33:58 <ddarius> Gracenotes: They even give a pointful definition immediately below it on the wikipedia page.
21:34:01 <Pseudonym> Of course, not, because Big Graph Theory is conspiring to keep algebraic notations out of your hands.
21:34:27 <rwbarton> You cannot be a topologist and not understand commutative diagrams, because you will not be able to read any papers, etc.
21:34:42 <monochrom> I am most impressed with its appendix on proving several properties of adjunction. Just doing equations is short and sweet. I tried doing my own diagram proof, it became too intractible and I aborted. He remarked there is a famous diagram proof in a famous book taking three pages.
21:35:29 <ddarius> I don't recall having any trouble at all understanding what commutative diagrams represent (though some can be hard to follow, especially when you get to higher category theory, blech)
21:35:29 <Pseudonym> delta >>> s *** id >>> nabla = nabla >>> id *** s >>> delta
21:35:54 <monochrom> It is nice to have a simple picture as a proof. But it is also impossible in advanced cases.
21:36:00 <Gracenotes> has anyone here read TAPL in its entirety?
21:36:05 <Pseudonym> Yes.
21:36:12 <ddarius> Diagrams are mostly useless for proofs, especially when you are developing one.
21:36:14 <Pseudonym> Haven't read ATTaPL, though.
21:37:00 <dmwit> It's likely there are several people here who have read all of TaPL.
21:37:18 <Gracenotes> Types and Programming Languages (Hardcover). What Do Customers Ultimately Buy After Viewing This Item? 4% buy Real World Haskell
21:37:26 <dmwit> heh
21:37:27 <dmwit> nice
21:37:37 <Gracenotes> (and 5% buy The Haskell Road to Logic, Maths and Programming (Texts in Computing))
21:37:39 <jsgf> rwbarton: thanks for that; much cleaner
21:39:12 <altmattr> Gracenotes: yep
21:39:47 <Gracenotes> right now I'm reading through Lecture Notes on the Lambda Calculus, anyway :)
21:39:49 <altmattr> Gracenotes: and I think it inspired Audrey Tang to pugs-related greatness!
21:40:04 <Gracenotes> oh, nice
21:40:49 * altmattr recommends TAPL as well :)
21:41:05 <monochrom> (Does the other 91% buy Data Structure for Java? :) )
21:41:35 <Gracenotes> just what is extensional polymorphism, by the way? (if it exists)
21:41:42 <Saizan_> does TAPL talk about CoC?
21:41:43 <altmattr> Gracenotes: it is one of those books that feels quite challenging first time around (and indeed it is), but when you revisit it later, it all feels very familiar
21:41:59 <altmattr> Gracenotes: by which I mean, one reading is enough to get most of the meat from the book
21:42:01 <Gracenotes> or does only 'intensional polymorphism' really make sense?
21:42:17 <dmwit> Saizan_: It has a paragraph on dependent types. =)
21:42:18 <altmattr> Saizan_: no, don't think so
21:42:38 * dmwit laughed aloud when he read that paragraph and realized that was all the book was going to say about it
21:42:42 <altmattr> Gracenotes: I don't have it in front of me to check what you mean I am afraid
21:42:52 <ozy`> what paragraph is this?
21:42:57 <ozy`> in RWH?
21:42:59 * altmattr chuckled at least
21:43:00 <dmwit> TaPL
21:43:10 <Gracenotes> the whole extensional-vs-intensional thing seems very interesting to me
21:43:28 * altmattr has been thinking about pulling apart his precious copy of TAPL to scan it
21:43:46 * altmattr does not have the back to carry it everywhere :)
21:43:58 <scsibug> advanced topics in TAPL has much more on dependent types
21:44:17 <dmwit> altmattr: What, you don't consider TaPL to be light reading?
21:44:21 <Saizan_> i guess you can find on already scanned version online
21:45:27 <altmattr> Saizan_: I am a little uncomfortable with such a prospect and a quick check I did a while ago showed up nothing that did not require me getting an account at some pron filled torrent site
21:46:00 <dmwit> oh... that kind of scanning
21:46:59 <ozy`> altmattr: did that include googling sentences from the book?
21:47:32 <altmattr> ozy: I think so, I found it in google books
21:47:41 <altmattr> ozy: then again, maybe not
21:48:24 <scsibug> Saizan_: for CoC, 'Interactive Theorem Proving and Program Development' is excellent
21:48:45 <alsonk> @seen dons
21:48:45 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 1d 2h 41m 47s ago.
21:48:50 <Saizan_> scsibug: noted, thanks :)
21:49:14 <jberryma1> been reading about different tree data structures and can't really figure out why they all are described as storing ordered keys to values. Why not just talk about trees of ordered data as opposed to lists of data?
21:49:34 <alsonk> Anyone in the house familiar with HINT?
21:49:58 <alsonk> Trying to figure out if I can get the same functionality as with hs-plugins.
21:50:23 <alsonk> specifically, can I load code and keep a reference to the loaded code?
21:50:24 <dmwit> jberryma1: I'm not sure I understood your question, let me rephrase and see if I've got your question right.
21:50:44 <altmattr> dmwit: it is *now* :)
21:51:28 <dmwit> jberryma1: Trees generally store a (key, value) pair in each leaf, and require that the keys have some ordering.  Then, your question is, why bother with the value part?
21:52:18 <jberryma1> dimwit: yeah, sorry I wasn't clear.
21:52:37 <jberryma1> ummm... "dmwit"... sorry
21:53:10 <dmwit> jberryma1: Well, you can use a tree with no value part; it then represents a set.  The only query you can do is whether a particular key is in the tree or not.
21:53:13 <dmwit> That can be useful.
21:53:27 <dmwit> But it can also be useful to have a mapping from keys to values.
21:53:41 <dmwit> Think of programming; you have an (implicit) mapping from variable names to their values.
21:53:59 <Saizan_> alsonk: well, given that you can evaluate an expression in a context with specified modules loaded i'd say yes
21:54:01 <dmwit> Such a thing could be represented in the background using a tree, assuming you have an ordering on variable names (which is easy to cook up).
21:54:39 <alsonk> Saizan_: I guess i'm hoping to avoid the parse/compile overhead and just run obj code.
21:54:39 <rwbarton> Can I find out from cabal what things I've manually cabal installed?  (As opposed to things that were installed as dependencies?)
21:54:58 <alsonk> Saizan_: as plugins does.
21:55:48 <dmwit> rwbarton: cabal is not so much a package manager as a dependency satisfier...
21:55:50 <monochrom> When I learned binary search trees from CLR and other books, they all began with one single number in each node. Perhaps you want a book written in the 90s.
21:57:51 <Saizan_> alsonk: mmh, good point, in principle hint uses the same machinery as ghci which indeed loads obj code if it's available
21:58:58 <alsonk> Saizan_: yeah, if I know that I want SomeModule:someFunction, I just want to run that code;  I don't want to have to "interpret 'someFunction' " in a context which includes "SomeModule".
21:59:43 <jberryma1> dmwit: thanks. I can see how if you start from wanting to use (key,value) pairs that you would want to have efficient lookups which would lead you naturally to trees. I think I was trying to make the logic go the other way around.
22:00:01 <Saizan_> hs-plugins does that? it jumps directly to the function?
22:01:42 <alsonk> Saizan_: yes.
22:03:01 <alsonk> Saizan_: in http://github.com/alsonkemp/turbinado/tree/master/Turbinado/View.hs, the 'v' in 'CodeLoadView       v _ _ -> v ' is the object code loaded by plugins.
22:03:16 <alsonk> Saizan_: line 71
22:06:40 <alsonk> Saizan_: also, it looks as though I'd have to rebuild the Context fresh on each load, which seems really costly.
22:06:41 <Saizan_> what's the type? a 'v' doesn't tell much
22:06:50 <alsonk> it's a View XML
22:07:22 <alsonk> Saizan_: the code is loaded/stored in Turbinado/Environment/CodeStore.hs
22:07:36 <alsonk> Saizan_: http://github.com/alsonkemp/turbinado/tree/master/Turbinado/Environment/CodeStore.hs
22:08:11 <Saizan_> well you can just "interpret" someFunction, to get a reference to it
22:08:19 <Saizan_> and then use that subsequently
22:08:30 <alsonk> Saizan_: what do you mean use it subsequently?
22:08:52 <Saizan_> if you're going to use someFunction more than once
22:09:01 <alsonk> Saizan_: that's probably exactly what to do, I just don't see how to get a reference from Hint.
22:11:01 <Saizan_> someFunction <- withSession s (do loadModules ["SomeModule"]; interpret "someFunction" (undefined :: <type here>)); ....
22:12:08 <Saizan_> looking at the 0.2.4.1 haddock
22:13:11 <alsonk> my imperative background is getting in my way.  Would the reference be to the function or to the return value of the function?
22:13:21 <Saizan_> to the function
22:14:29 <alsonk> of course.  the function is partially applied (or not at all applied).  That should work perfectly.
22:14:39 <alsonk> You just saved me a ton of time.
22:14:42 <alsonk> Thanks!
22:14:48 <Saizan_> i'm not sure how that works with polymorphism though
22:14:54 <Saizan_> np :)
22:15:09 <alsonk> I'll come back and yell at you if/when I get bit by polymorphism.  ;)
22:15:40 <Saizan_> ah, another problem might be that i don't think loadModules will compile SomeModule if it isn't already
22:16:48 <Saizan_> and you also need setTopLevelModules ["SomeModule"]
22:17:15 <alsonk> true.  details.  The theory seems sound, though
22:17:57 <mxc> ?seen dons
22:17:57 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 1d 3h 10m 59s ago.
22:23:34 <lepassive> hi main = interact wordCount
22:23:34 <lepassive>     where wordCount input = show (length (lines input)) ++ "\n"  ===> what is the value of input ?
22:23:57 <lepassive> and what is interact ?
22:24:03 <dmwit> heh
22:24:07 <dmwit> Welcome to #haskell!
22:24:25 <dmwit> interact is a function that takes (String -> String) functions and turns them into full-fledged programs.
22:24:40 <ddarius> @src interact
22:24:40 <lambdabot> interact f = do s <- getContents; putStr (f s)
22:24:41 <dmwit> interact f -- this will run "f" on the entire input to the program, printing the output of "f" as it goes
22:25:35 <rwbarton> "wordCount input = ..." defines a function, whose argument is called input.  So input will end up being the input to your program.
22:25:46 <lepassive> okay interact means run... why not to use do instead ? and what is the value of input or it's defaulted to command line arg ?
22:26:25 <witi77> hey
22:26:30 <mauke> input as in stdin
22:26:54 <witi77> i just downloaded python can u guys give me somethin
22:26:57 <witi77> fun to do
22:27:09 <lepassive> mauke, and input is defaulted to stdin when interacting with main
22:27:09 <mauke> how is that a haskell question?
22:27:15 <mauke> lepassive: what?
22:27:18 <dmwit> witi77: Maybe you should ask in #python.
22:27:28 <polveroj> mauke: 'input' is a variable in the code snippet lepassive pasted
22:27:29 <lepassive> witi77, #python and i guess u may start by solving some algorithms
22:27:32 <witi77> whos he?
22:28:09 <mauke> witi77: what?
22:28:20 <witi77> any1 wanna take me under their wing lol?
22:28:22 <lepassive> haskell needs a champ and I won't quit
22:28:47 <dmwit> This has to be some epic trolling somehow.
22:28:54 <dmwit> tag-team style
22:28:58 <mauke> hardly epic
22:29:02 --- mode: ChanServ set +o Pseudonym
22:29:28 <rwbarton> I've seen people new to IRC not understand channels and somehow end up in #haskell asking random questions before.
22:29:37 <dmwit> Okay.
22:29:46 <witi77> lol thats me
22:29:47 <dmwit> witi77: To ask in a more appropriate place, try typing "/join #python".
22:29:52 <dmwit> witi77: Then ask your question there.
22:29:53 <rwbarton> witi77: However you got here, change "haskell" to "python" and then try asking again :)
22:30:03 <sbahra> witi77, Haskell is better than Python.
22:30:05 <mauke> epic trolling (NSFW): http://encyclopediadramatica.com/Dorian_Thorn
22:30:10 <sbahra> witi77, you should learn Haskell instead of Python.
22:30:58 <Tordek> I'm trying to use State, but import Control.Monad.State says it can't find the module; thoughts?
22:30:58 <witi77> really? is it free?
22:31:02 <alsonk> Saizan_: worked perfectly.  Thanks again.
22:31:31 <sbahra> witi77, yes. http://www.haskell.org/
22:31:33 <mauke> whoa
22:31:47 <lepassive> I'm sorry what is the head points of haskell compared to python except for the type system ?
22:31:50 <Cthulhon> Tordek: How did you install ghc?
22:31:58 <witi77> oo and by the way i know i sound dumb but what u guys workin on now?
22:31:59 <Tordek> Cthulhon: debian packages
22:32:00 <Cthulhon> And are you by any chance on Gentoo?
22:32:06 <sbahra> lepassive, purely functional, performance
22:32:07 <Pseudonym> Man that sucks.
22:32:21 <Cthulhon> Hm, Debian might have a separate mtl package like Gentoo has.
22:32:30 <Cthulhon> Search for it in apt.
22:32:32 <mauke> Pseudonym: what happened?
22:32:38 <rwbarton> Yeah, it does, libghc6-mtl-dev probably
22:32:51 <lepassive> sbahra, python is hybrid (some times it's nice to write imperative code) and performance hummm is there a benchmarks for that ?
22:32:58 <Pseudonym> Oh, network glitch, making me lag out.
22:33:13 <rwbarton> Hey, at least it's not like Ubuntu where libghc6-parallel-dev is just missing completely for some reason. :)
22:33:13 <Tordek> ah, found it. thanks a lot, Cthulhon
22:33:28 <sbahra> lepassive, http://shootout.alioth.debian.org/
22:33:32 <sbahra> lepassive, not the best, but something. :)
22:33:34 <jeffz`> mauke: mind if I pm?
22:33:36 <mauke> lepassive: sane scoping rules
22:33:44 <mauke> jeffz`: for what?
22:33:55 <jeffz`> mauke: irc related stuff
22:34:10 <mauke> jeffz`: go ahead
22:34:47 <lepassive> wow haskell knocked python of !
22:35:07 <sbahra> hmm
22:35:10 <lepassive> I've to ask, u guyz sure have done alot of large projects.. does haskell fits in ?
22:35:19 <sbahra> I think I am suffering from minor food poisoning.
22:35:45 <lepassive> sbahra, are you sure? not a VB code you wrote ?
22:39:20 <Axman6> "17:34 < lepassive> wow haskell knocked python of !" of what?
22:39:32 <rwbarton> shootout
22:39:44 <rwbarton> I think s/of/off .../
22:39:51 <Axman6> hasn't haskell been smashing python for ages?
22:40:43 <Axman6> wow, java beating C
22:41:03 <rwbarton> I'm not sure, honestly.  I imagine before ByteString that reading lots of input would be a problem.
22:41:06 <cjb> rwbarton: more likely the IRC people-in-channel order
22:41:11 <lepassive> rwbarton, I applied unique on the sentence
22:41:25 <rwbarton> @users
22:41:25 <lambdabot> Maximum users seen in #haskell: 642, currently: 581 (90.5%), active: 15 (2.6%)
22:43:18 <Axman6> http://shootout.alioth.debian.org/u64q/benchmark.php?test=regexdna&lang=ghc urgh. the code clearly says you need the PCRE library, and they obviously don't have it installed -_-
22:43:34 <rwbarton> We need a graph of #haskell users vs. time with the release of RWH marked on it
22:43:39 <arw> one can always create your own evil benchmark criteria :)
22:43:41 <arw> http://shootout.alioth.debian.org/u32/benchmark.php?test=all&lang=all&xfullcpu=1&xmem=0&xloc=0&binarytrees=0&chameneosredux=0&fannkuch=0&fasta=0&knucleotide=0&mandelbrot=0&meteor=0&nbody=0&pidigits=0&regexdna=0&revcomp=0&spectralnorm=0&threadring=1&calc=calculate
22:44:27 <Axman6> erlang still beats haskell...
22:45:09 <rwbarton> Wait, what happened to the parallel fannkuch I wrote?
22:45:10 <arw> hmyeah, still needs a little tuning :)
22:45:14 <int80_h> wb lemmih
22:46:03 <arw> http://shootout.alioth.debian.org/u32/benchmark.php?test=all&lang=all&xfullcpu=1&xmem=0&xloc=0&binarytrees=0&chameneosredux=0&fannkuch=0&fasta=0&knucleotide=0&mandelbrot=0&meteor=0&nbody=0&pidigits=0&regexdna=0&revcomp=1&spectralnorm=0&threadring=1&calc=calculate
22:46:20 <rwbarton> Oh duh, this isn't the parallel benchmark.
22:47:46 <rwbarton> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all&xfullcpu=1&xmem=0&xloc=0&binarytrees=0&chameneosredux=0&fannkuch=1&fasta=0&knucleotide=0&mandelbrot=0&meteor=0&nbody=0&pidigits=0&regexdna=0&revcomp=0&spectralnorm=0&threadring=1&calc=calculate
22:47:57 <Axman6> http://shootout.alioth.debian.org/u64q/benchmark.php?test=knucleotide&lang=all hmm, why's that so slow?
22:49:44 <rwbarton> also why is it using almost 3G of memory
23:05:09 <witi77> hey guys im back got sick of tryin to get in a python chat room
23:05:23 <witi77> so im downloadin haskell
23:05:52 <mauke> what do you mean by "trying"?
23:05:54 <dibblego> well that's one reason
23:05:56 <ozy`> Axman6, rwbarton, it seems to be using a weird hashtable implementation....
23:06:06 <mauke> just join #python or ##python or whatever it's called
23:06:25 <ozy`> looks like a direct (ie. probably careless) port of the C version
23:06:30 <Axman6> mauke: you're a terrible haskell supporter :P
23:06:32 <dmwit> witi77: How did you get here?
23:06:34 <witi77> its not workin idk y it says i have to be identified
23:06:35 <int80_h> yeah how hard is it to get to the #pthon channel?
23:06:47 <dmwit> witi77: ah
23:06:48 <mauke> Axman6: it's possible to learn more than one language
23:06:55 <Axman6> witi77: haskell's more fun than python anyway ;)
23:07:02 <witi77> lol
23:07:05 <int80_h> it helps to master the basics of the english language.
23:07:11 <dmwit> witi77: You may have to register.  "/msg nickserv help" for more information.
23:07:15 <Axman6> mauke: but ot advisable to learn more than one at the same time ;)
23:07:21 <dmwit> witi77: But yeah, learn Haskell instead of Python and thank us later. ;-)
23:07:22 <int80_h> that way, you'll not annooy some and confuse others.
23:07:57 <witi77> thanks ill try no to
23:08:21 <witi77> i wanna learn but this was the first night i went thru with it
23:09:21 <int80_h> I tried to do mny current project in python. I got bored to death
23:09:42 <witi77> hahaha yea i was feelin that way earlier
23:09:46 <SubStack> int80_h: I've been there
23:09:48 <int80_h> So I'm using it as a way to learn haskell instead. I should be getting RWH tommorow.
23:10:37 <int80_h> SubStack, well the big problem I see is rendering a map in a web page
23:10:49 <witi77> what are some easy projects to do, i know about some of the basics
23:10:55 <int80_h> I'm not even going to worry about that until my corrdinate generating functions are completed.
23:11:07 <dmwit> project euler
23:11:13 <SubStack> dmwit: agreed
23:11:25 <rwbarton> Someone named "quiksilver" is asking basic questions in #python.  That threw me for a minute :)
23:11:42 <witi77> euler?
23:11:47 <int80_h> google it
23:12:01 <int80_h> does lambabot know about it?
23:12:11 <int80_h> lambdabot: google project euler
23:12:24 <int80_h> hmmm
23:12:30 <witi77> haskell up and runnin
23:12:32 <int80_h> okay what did I screw up?
23:12:36 <dmwit> ?google project euler
23:12:41 <dmwit> ?where euler
23:12:47 <lambdabot> http://projecteuler.net/
23:12:47 <lambdabot> Title: Project Euler
23:12:47 <lambdabot> http://projecteuler.net
23:14:20 <rwbarton> witi77: also:
23:14:22 <rwbarton> ?where lyah
23:14:23 <lambdabot> www.learnyouahaskell.com
23:14:49 <dmwit> ?where gentle
23:14:49 <lambdabot> http://www.haskell.org/tutorial/
23:14:53 <witi77> ooo its like a training site
23:16:05 <int80_h> project euler is the place I've been looking for to do daily warm-up exercieses.
23:16:09 <int80_h> nice
23:16:17 <witi77> darn how do u say range in haskell
23:16:29 <rwbarton> > [1..5]
23:16:31 <lambdabot>   [1,2,3,4,5]
23:16:40 <int80_h> [foo....bar]
23:16:48 <int80_h> > [foo...bar]
23:16:50 <lambdabot>   Not in scope: `foo'Not in scope: `...'Not in scope: `bar'
23:16:53 <int80_h> fine
23:16:59 <int80_h> be that way
23:17:45 <geezusfreeek> > reverse [1..] :: [Word8]
23:17:46 <lambdabot>   [255,254,253,252,251,250,249,248,247,246,245,244,243,242,241,240,239,238,23...
23:17:46 <lambdabot> geezusfreeek: You have 1 new message. '/msg lambdabot @messages' to read it.
23:18:11 <BMeph> Where do the shootout folks get the build script from? :)
23:19:03 <arw> from the comments?
23:19:40 <arw> usually its just one file and a short compiler invocation, no need for any skript i think.
23:22:03 <BMeph> arw: Well, someone should tell them that the '-package regex-posix' part should be regex-pcre. :)
23:22:31 <CakeProphet> I have the language design that boasts the largest number of comment styles in any language.
23:22:43 <CakeProphet> the problem, of course, will be implementing such a complex language.
23:22:58 <BMeph> Frankly, though, I'm impressed that they're using 6.10.1 - that's rather daring for a debian build. ;p
23:23:19 <quylui> i'm having a little trouble. i'm trying to write a short piece of code which will find the whole factors of any number, and i'm trying to run something which will check  to see if n `mod` x for a series of numbers [1..n] is 0, and return the ones that are to an output list. unfortunately i can't seem to get this working. :(
23:23:31 <quylui> i'm also kind of a newb
23:23:36 <dmwit> CakeProphet: Comment syntax is rarely the hard part of language implementation.
23:23:48 <CakeProphet> dmwit:  ...
23:23:57 <CakeProphet> no no, I disagree. There's an art to doing nothing.
23:24:10 <BMeph> quylui: Do you have something on hpaste that we can rewrite for your own good? ;p
23:24:22 <dmwit> > filter (\n -> n `mod` 3 == 0) [1..10]
23:24:23 <lambdabot>   [3,6,9]
23:24:23 <witi77> these problems are over my head lol
23:24:58 <quylui> dmwit: i mean for *any* n. so i can just input "getFacs n" and have it return a list
23:25:01 <SubStack> CakeProphet: there's already a language for comments: TeX
23:25:18 <dmwit> quylui: Feel free to make any part of that expression into a variable bound in a function.
23:26:00 <quylui> BMeph: i would but i can clearly tell what's wrong with my own code. i just need to know how to turn [1..n] into a usable list so i can apply the `mod` function to each of its units
23:26:13 <quylui> BMeph: alright, i'll do it anyway, but it won't be very useful.
23:26:35 <BMeph> quylui: Have you considered enumFromTo 1? :)
23:26:46 <BMeph> quylui: Or to be sloppy:
23:26:58 <BMeph> > (\n -> [1..n]) 10
23:27:00 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
23:27:50 <quylui> http://hpaste.org/13627 <-- this isn't going to help at all though. it's just scratch
23:27:54 <BMeph> > (\x ->filter (\n -> n `mod` 3 == 0) [1..x]) 10
23:27:56 <lambdabot>   [3,6,9]
23:28:03 <BMeph> > (\x ->filter (\n -> n `mod` 3 == 0) [1..x]) 100
23:28:04 <lambdabot>   [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78...
23:28:18 <BMeph> quylui: Etc... ;)
23:28:22 <schme> Hey guys and gals.
23:28:37 <CakeProphet> quylui:  I think filter would be much cleaner.
23:28:46 <BMeph> schme: Hey
23:28:52 <CakeProphet> so you know how it works?
23:29:01 <quylui> i think you misunderstood me. i mean to take the factors of 12 i'd type getFactors 12 and it would return 1,2,3,4,6,12
23:29:22 <quylui> i see how the above function works, but it's not what i'm looking to accomplish.
23:29:40 <BMeph> > (\x ->filter (\n -> x `mod` n == 0) [1..x]) 100
23:29:42 <lambdabot>   [1,2,4,5,10,20,25,50,100]
23:29:49 <quylui> very nice. thank you
23:29:54 <quylui> <3
23:29:54 <BMeph> quylui: ...
23:30:01 <quylui> sorry, i'm really new.
23:30:08 <CakeProphet> quylui:  that's exactly what we were showing you.
23:30:16 <CakeProphet> to make the function you want, you can use the function we just showed you
23:30:21 <quylui> oh shoot.
23:30:27 <BMeph> quylui: Don't worry, I'm (almost) as new as you. I'm just noisier. ;)
23:30:31 <rwbarton> CakeProphet: It is?
23:30:39 <quylui> this will be my second facepalm in channel haskell.
23:30:47 <rwbarton> I thought dmwit was being cleverly not quite answering the question.
23:31:00 * dmwit meant to be
23:31:23 <schme> Is there some way to make sure that a piece of haskell is RT good?
23:31:35 <dmwit> What does RT mean?
23:31:38 <schme> real time
23:31:48 <Zao> How hard?
23:31:50 <dmwit> You mean, won't throw an exception?
23:31:53 <dmwit> oh
23:32:15 <dmwit> Laziness makes realtime guarantees tricky.
23:32:23 <schme> I mean.. no calling of malloc, free, pthreadin', sleep, wait, poll, select..
23:32:27 <schme> ah ok.
23:32:31 <schme> So is there?
23:32:51 <rwbarton> what about nontermination?
23:33:17 <schme> Zao: the harder the better ;)
23:33:33 <CakeProphet> > let fac n = filter ((==0).(`mod` n)) [1..n] in fac 3000
23:33:34 <lambdabot>   [3000]
23:33:40 <arw> if you do strict evaluation for everything perhaps?
23:33:42 <CakeProphet> ...
23:33:43 <CakeProphet> oh
23:33:45 <CakeProphet> rofl.
23:34:33 <Zao> dmwit: How would one tame the GC?
23:34:38 <CakeProphet> > let fac n = filter ((==0).(mod n)) [1..n] in fac 3000
23:34:40 <lambdabot>   [1,2,3,4,5,6,8,10,12,15,20,24,25,30,40,50,60,75,100,120,125,150,200,250,300...
23:34:42 <dmwit> schme: I think there's little enough expertise in real-time systems in here that you should take this question to an asynchronous medium.
23:34:45 <CakeProphet> much better
23:34:52 <dmwit> schme: Like haskell-cafe or so.
23:35:04 <Zao> There's probably relevant threads in the archive too.
23:35:06 <schme> hmmm . ok.
23:35:07 <dmwit> Zao: I have no idea.  I have zero experience with realtime stuff.
23:35:12 <schme> Well thanks.
23:35:43 <CakeProphet> @let factors n = filter ((==0).(mod n)) [1..n]
23:35:44 <lambdabot>  Defined.
23:35:44 <ddarius> There's enough "experience" to say that attempting to do hard real-time computation in Haskell is foolish.
23:35:50 <CakeProphet> quylui:  see how that works?
23:35:52 <geezusfreeek> schme, i believe most current uses of haskell in RT systems is generating C code
23:35:59 <schme> dmwit: #haskell-cafe was kinda empty :P
23:36:06 <CakeProphet> > map factors [1..10]
23:36:07 <dmwit> schme: haskell-cafe@haskell.org
23:36:07 <lambdabot>   [[1],[1,2],[1,3],[1,2,4],[1,5],[1,2,3,6],[1,7],[1,2,4,8],[1,3,9],[1,2,5,10]]
23:36:16 <schme> oh it's something else. k k
23:36:20 <dmwit> schme: IRC is not asynchronous. =P
23:36:25 <ddarius> dmwit: Yes it is.
23:36:29 * dmwit ponders
23:36:40 <ddarius> It's not reliable, but it is asynchronous.
23:36:48 <Gracenotes> one must consider the asynchronity of IRC when writing a client
23:36:54 <dmwit> ?wn asynchronous
23:36:54 <schme> geezusfreeek: I see.  I just read that Haskore has some RT bits. I'll look into that and see what goes on there.
23:36:59 <lambdabot> *** "asynchronous" wn "WordNet (r) 2.0"
23:36:59 <lambdabot> asynchronous
23:36:59 <lambdabot>      adj 1: (digital communication) pertaining to a transmission
23:36:59 <lambdabot>             technique that does not require a common clock between
23:36:59 <lambdabot>             the communicating devices; timing signals are derived
23:37:01 <lambdabot> [4 @more lines]
23:37:07 <Gracenotes> if you request the /who of a channel, it might not come in the right order
23:37:13 <dmwit> Maybe asynchronous is the wrong word.
23:37:16 <Gracenotes> in fact, there may be non-/who message mixed in with it
23:37:19 <CakeProphet> hmmm
23:37:19 <Gracenotes> *messages
23:37:23 <ddarius> dmwit: Something like "off-line"
23:37:27 <CakeProphet> @pl factors n = filter ((==0).(mod n)) [1..n]
23:37:28 <lambdabot> factors = ap (filter . ((0 ==) .) . mod) (enumFromTo 1)
23:37:28 <ddarius> or persistent
23:37:37 <rwbarton> "real-time"? :)
23:37:45 <dmwit> I meant asynchronous on the human timescale rather than the machine timescale, I guess.
23:37:47 <CakeProphet> pointless always impresses me
23:37:59 <ddarius> dmwit: IRC is asynchronous on the human time-scale.
23:38:05 <dmwit> Hm.
23:38:18 <ddarius> dmwit: How often have you replied to a comment left hours earlier?
23:38:22 <dmwit> ddarius: You think you could notice the difference in time between when I say something and when it arrives at your computer?
23:38:30 <vegai> @tell ddarius Well, sometimes it might work
23:38:30 <dmwit> ddarius: Not often.
23:38:31 <lambdabot> Consider it noted.
23:38:52 <ddarius> dmwit: But not never, and you've probably fairly often responded minutes - 1/2 hour later.
23:38:52 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
23:39:06 <dmwit> ddarius: But the response isn't the measure of synchronicity.
23:39:12 <dmwit> ddarius: The receipt is the measure.
23:39:34 <BMeph> tunes.org is asynchronous on the Internet time-scale. :)
23:39:36 <dmwit> ddarius: Unless I'm totally misusing [a]synchronous.
23:39:37 <ddarius> The receipt is when you read it.
23:40:04 <dmwit> Anyway, I'm perfectly happy admitting I'm wrong, so long as everybody involved understood what I meant.
23:40:17 <Gracenotes> for different people, interestingly, messages arrive in different orders (if they arrive at all)
23:40:42 <Gracenotes> albeit on the scale of seconds, not hours
23:41:10 <dmwit> Maybe what I meant is that he should try a medium with a higher latency.
23:41:41 <rwbarton> dmwit: You meant that often when asking a question on IRC, you wait for an answer before going back to whatever you were doing.
23:41:52 <rwbarton> dmwit: Whereas the same is not often true over email.
23:41:58 <BMeph> Gracenotes: Aye - every now and then, I see conversations where someone is obviously responding to a statement that looks to me to come after the response. It's kind of like GR-by-fiber. :)
23:41:59 <dmwit> Right!
23:42:21 <dmwit> [a]synchronous in the [non]blocking sense =)
23:42:33 <Gracenotes> BMeph: the problem comes up all the time in first-answerer-wins IRC bots :)
23:42:59 <Gracenotes> if your server is closer to the bot's server than someone else's, you have a better chance
23:44:48 <int80_h> what does the "..." notation mean? or is context required?
23:45:24 <dmwit> int80_h: In Haskell, ".." is an enumeration operation; dunno of any "..." notation.
23:45:34 <BMeph> int80_h: Definitely needs context. :)
23:45:35 <dmwit> Or isn't this a Haskell question?
23:45:54 <witi77> these questions ware on u
23:46:04 <int80_h> hold on, I have context...two lines from "all about MOnads"
23:46:22 <BMeph> int80_h: There's a '...' that does Lagrangian interps (I thing that's how it works, anyway). :)
23:46:29 <int80_h> type Sheep = ...
23:46:39 <dmwit> int80_h: Oh, it's just used to omit code.
23:46:49 <dmwit> type Sheep = {- we've done this a million times before -}
23:46:49 <int80_h> oooh
23:46:53 <dmwit> or maybe,
23:47:03 <dmwit> type Sheep = {- this part doesn't matter -}
23:47:07 <int80_h> rats I was thinking I could type this in verbatim and get results
23:47:13 <BMeph> int80_h: Oh, that's just conventional writing - as in I have something to tell you...
23:47:16 <dmwit> Nope. =)
23:47:17 <BMeph> .
23:47:19 <BMeph> .
23:47:20 <BMeph> .
23:47:29 <Gracenotes> int80_h: you can define your own sheep to test it
23:48:24 <Gracenotes> something like, uh, type Sheep = UnknownSheep | Sheep String Sheep Sheep
23:48:35 <int80_h> oh no worries. It references the actual working code
23:48:42 <int80_h> they fill in the blanks. all is well
23:48:43 <Gracenotes> Sheep String Sheep Sheep = name, mother, father
23:48:48 <Gracenotes> ah, okay :)
23:48:49 <BMeph> int80_h: Just to clue you in, Haskell is powerful, but it isn't actually Magical. Although we're pretty sure oleg is a Wizard of some sort. ;)
23:49:22 * int80_h is off to see the Wizard.
23:49:55 * BMeph pays no attention to the type-fu behind the Curtain...
23:50:01 <polveroj> What do you have to do to make instances of an infix typeclass? I keep getting "malformed instance header".
23:50:12 <polveroj> (I'm playing with the data types a-la-carte stuff)
23:50:20 <Gracenotes> BMeph: or the Wicked unsafePerformIO of the West
23:50:39 <Gracenotes> [ listening to the Wicked soundtrack at the moment, by the way ;) ]
23:51:07 <baaba> no good deed goes unpunished
23:51:39 <jberryma1> when defining a function over a type like list, will it ever be more efficient to use _ in the second pattern rather than, e.g. [] ?
23:51:44 <int80_h> so where did the "loler" go. I forget his name.
23:52:49 <Workybob> @oleg
23:52:51 <lambdabot>  Defined.
23:52:54 <Workybob> o.O
23:53:01 * Workybob wonders what oleg defined this time
23:56:32 <witi77> hey can any of u walk me thru a euler problem?
23:56:44 <BMeph> Gracenotes: I prefer unsafeDodgeHousesDroppedByTornadoes ;)
23:58:05 <BMeph> witi77: I think many of us could, but I don't think any of us could... ;p
23:58:27 <Gracenotes> does anyone recall the online essay that claims that there aren't really strong or weak systems, merely stronger or weaker systems?
23:58:56 <Gracenotes> type systems, that is
23:59:20 <Gracenotes> (and, at that, gives them a somewhat arbitrary definition)
23:59:28 <lepassive> http://learnyouahaskell.com/ is really awesome
23:59:42 <semarie> hi somebody could help me in lazy + monad comprehension ?
23:59:47 <BMeph> Gracenotes: "the online essay" suggests that there's only one of them. :)
