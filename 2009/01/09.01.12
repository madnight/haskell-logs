00:00:13 <dmwit> hydo: It looks like a mere type synonym thing.
00:00:18 <dmwit> Because you're in ghci, you can drop the "IO" prefix once you've grabbed something with "<-".
00:00:36 <dmwit> Other than that, "type Response = HTTPResponse String" should tell you what you need to know.
00:01:09 <dmwit> pumpkin: Well, I have only a vision (and no actual code).  So pick your favorite OS, since it will likely never see the light of day anyway... =P
00:01:24 <dmwit> The font thing was just idle speculation.
00:01:26 <pumpkin> I say it should be for house! :)
00:01:32 <dmwit> =)
00:01:55 <hydo> dmwit: thanks!  i'll keep poking at it.
00:02:03 <vegai> Network.HTTP is supposed to support https, is it not?
00:02:27 <mmorrow> i don't think it does
00:02:39 <dmwit> hydo: IO (Result Response) = IO (Result (HTTPResponse String))
00:02:49 <dons> vegai: http 4 might, but use the curl lib otherrwise
00:03:07 <mmorrow> vegai: err, i read that as support for digest auth which it doesn't do, but it doesn't do https either
00:03:21 <dmwit> hydo: So "fg <- (foo :: IO (Result Response))" means "fg :: Result Response", or, equivalently, "fg :: Result (HTTPResponse String)".
00:03:25 <dons> galois uses the curl lib for ssl stuff
00:03:45 <vegai> ah, ok
00:06:59 <vegai> any nifty examples of using Network.Curl anywhere?
00:12:34 <Saizan> 4getToFile url filename = withBinaryFile filename WriteMode $ \h -> curlGet url [CurlWriteFunction $ callbackWriter (hPutStr h), CurlFollowLocation True]
00:12:41 <Saizan> s/4//
00:17:36 <ski_> @ghc
00:17:36 <lambdabot> ghc says: Urk! Inventing strangely-kinded void TyCon: ZCt{tc a2AN} (* -> *) -> * -> *
00:18:08 <ski_> GADT pattern match in non-rigid context for `Refl'
00:19:42 <vegai> Saizan: heh, thank you.
00:20:18 <vegai> I'm in a bit of a rush. Looking-up skills suffer massive failure
00:33:01 <dmwit> ?ghc
00:33:02 <lambdabot> ghc says: Exception: kevind stub
00:33:34 <hydo> dmwit: I think my confusion lies in that I don't understand how the case statement on line 47 is working.  My not-haskell-trained brain wants to say "if resp is of type Left or Right"...
00:33:51 <hydo> hrm... Maybe I just answered my own question.  assuming the above is correct.
00:35:29 <pumpkin> dons: submitted the bug along with some code and (reduced) data
00:35:34 <Saizan> hydo: Left and Right are not types
00:35:46 <Saizan> hydo: they are different constructors of the Either type
00:36:22 * pumpkin makes a hydomorphism in hydo's honor
00:37:58 <vegai> I suppose curl doesn't have support sychronous calls
00:38:20 <vegai> support for*
00:38:47 <hydo> Saizan: Ok, here's my question asked more succinctly: if "fg" is of type "Network.Stream.Result (HTTPResponse String)"  then how can a case statement match Left or Right on it?  (lines 33-37 and 47-49 in http://www.friendpaste.com/5gc5XgxJfRJrGZtOec7BcH )
00:38:55 <hydo> pumpkin: aw, thanks
00:39:04 <vegai> oh, there are. Some things return a CurlResponse
00:39:07 <hydo> oh
00:39:26 <hydo> Left is HTTPResponse and Right is String?
00:39:31 <Saizan> no
00:39:39 <Saizan> Network.Stream.Result a = Either Network.Stream.ConnError a
00:39:41 <Saizan> so
00:40:07 <vegai> there's a curlGetResponse... but I'd need a curlPostResponse
00:40:13 <Saizan> Network.Stream.Result (HTTPResponse String)  = Either Network.Stream.ConnError (HTTPResponse String)
00:41:06 <Saizan> which means that the Left will contain a ConnError, and the right will contain an (HTTPResponse String)
00:41:39 <vegai> ah, gatherOutput
00:45:40 * ski_ wonders why ghc won't propagate down the rigid context to the lambda ..
00:46:04 <hydo> Saizan: Thank you.  I think I understand it now.  Hrm... i bet coffee would help.
00:48:32 <vegai> hmm, curl is a bit weird. I can do a GET request that is defined by CurlOption as a POST request
00:56:37 <hydo> I think I'll see if I can find some smart student near me who needs some extra cash for haskell tutoring.
00:56:53 <hydo> wrong window, but still applicable... amazingly.
00:57:34 <luqui> hydo, good luck.  oh, btw, where are you ;-)
00:57:46 <hydo> Seattle-ish.
00:57:58 <luqui> good luck :-)
00:58:20 <hydo> thanks!
00:59:38 * ski_ wonders how long to wait after `REBOOT: System is going down NOW!' ..
00:59:50 <pumpkin> ski_: 42
01:00:02 <ski_> 42 years ?
01:00:07 <ski_> 42 days ?
01:00:07 <pumpkin> 42 units of time!
01:00:14 <pumpkin> you pick
01:00:47 <ski_> i don't want to pick
01:01:22 <pumpkin> oh :/
01:01:27 <dmwit> ski_: Switch to a different virtual terminal and watch the messages...
01:01:46 <dmwit> Anything more than about 30-45s sounds like either a badly configured system or a big problem.
01:02:12 <ski_> dmwit : i'm accessing the system via ssh ..
01:03:07 <dmwit> ski_: erm
01:03:17 <dmwit> And it still hasn't rebooted?
01:03:33 <ski_> if it had, i wouldn't still be here
01:05:35 <hydo> I've never hired a tutor before.  Does $25 an hour USD sound like too much / too little?
01:06:09 <Ralith> for what?
01:06:25 <hydo> Haskell tutoring.
01:06:48 <vixey> why don't you teach yourselfl haskell for free?
01:06:56 * jonaskoelker :: Noise -> Not Sleep
01:07:04 <hydo> Good question... the answer will take a sec.
01:07:05 <jonaskoelker> good $TIMEZONE everyone
01:07:06 * ivanm doesn't know the going rate for tutoring in the USA...
01:07:16 <ivanm> jonaskoelker: heh
01:07:41 <ski_> phi jonaskoelker :: Sleep -> Not Noise
01:08:59 <dmwit> hydo: The school paid me $15/hour to tutor, but off-campus tutoring netted me $50-$100/hour!
01:09:02 <hydo> The last time I _really_ learned a language was about eight years ago and I was learning Perl.  I had the good fortune to be living down the street from two very smart guys who were on, at one time or another, the perl core team.  They rammed Perl into my head quite fast and learning one on one got to be really addicting.
01:09:34 <pumpkin> dmwit: slightly better deal :P
01:09:48 * dmwit nods
01:10:00 <ivanm> dmwit: how did you get $100/hr? multiple people at once being conned out of money?
01:10:08 <cjs> Going rate depends on what the teacher's time is worth. I charge $100-$150/hour, but that's basically because that's what I charge for anything.
01:10:32 <hydo> dmwit: hrm... I think I'll start the haggling at 35 or 40... heh
01:10:36 <ivanm> well, UQ at least pays $30/hr for tutoring...
01:10:39 <dmwit> ivanm: No, single people.  Conning... well, that's up to you, I guess.  I certainly rendered them the services they were paying for.
01:10:45 <pumpkin> ivanm: is that AUD?
01:10:51 <ivanm> pumpkin: yup
01:11:08 <ivanm> dmwit: didn't quite mean "conned" in that sense.... just me being cynical :p
01:11:21 <ivanm> but $100/hr sounds a bit much for tutoring...
01:11:27 <dmwit> oh, $50-$100 USA, dunno the exchange rate to $AUD
01:11:29 <hydo> The point is that I learn quickly... if I come away with a head full of new stuff then that's definitely worth more than $100 an hour to me.
01:11:30 <ivanm> pumpkin: note that I mainly do math tutoring
01:11:33 <pumpkin> ah
01:11:35 <ivanm> dmwit: yeah, I guessed that ;-)
01:11:43 <dmwit> ivanm: I agree.  I always felt a bit uncomfortable...
01:11:54 <ivanm> pumpkin: but I'm pretty sure the IT school pays the same
01:12:15 <pumpkin> hydo: there are LOTS of good tutorials and LOTS of willing people in here to help you :P if you're interested in less traditional ways of learning :)
01:12:23 <ivanm> pumpkin: and that I've tutored matlab and python for math/science subjects
01:12:30 <pumpkin> ah
01:12:31 <ivanm> @go teach you a haskell
01:12:33 <lambdabot> http://www.defmacro.org/ramblings/haskell-productivity.html
01:12:33 <lambdabot> Title: defmacro - On Haskell, Intuition And Expressive Power
01:12:40 <ivanm> that's not what I meant...
01:12:44 <ivanm> @go "teach you a haskell"
01:12:46 <lambdabot> No Result Found.
01:12:52 <pumpkin> ivanm: your grammar is too good
01:12:56 <ivanm> pumpkin: heh
01:13:01 <pumpkin> @go "learn you a haskell"
01:13:04 <lambdabot> http://learnyouahaskell.com/
01:13:04 <lambdabot> Title: Learn You a Haskell for Great Good!
01:13:13 <ivanm> ahhh, that's right
01:13:16 <ivanm> I knew it was something stupid ;-)
01:13:59 <opqdonut> 100AUD is 51EUR, that's only two times what I get for teaching groups
01:14:42 <hydo> pumpkin: I am, definitely.  My problem is that I'm not all that smart, to be honest.  I have to make up for it in blind bull-headed stubbornness... so some things take a bit to sink in and I'm a little afraid of being that one guy on the channel who asks a thousand questions who is obviously not getting it.
01:15:04 <mm_freak> in category theory, can there be a difference between id X and id Y, if X = Y?
01:15:28 <vixey> @tell EvilTerran http://www.iis.sinica.edu.tw/~scm/2007/proving-some-equalities-in-propositional-logic/
01:15:28 <lambdabot> Consider it noted.
01:15:42 <ski_> mm_freak : surely, if `X = Y', then `id X = id Y' if `id' is a function
01:15:46 <hydo> Though from the looks of the responses to my previous questions, maybe what I need to do is go back and read LYAH and RWH again.
01:16:11 <vixey> hydo, and also choose some program to write
01:16:52 <pumpkin> bah, this UArr bug is really making me question my program's output :/
01:16:55 <mm_freak> ski_: id A is a morphism A â†’ A
01:17:07 <dmwit> hydo: Don't worry.  We've had some people who are guaranteed to be more brain-dead than you.
01:17:15 <dmwit> And people were mostly polite to them.
01:17:19 <dmwit> ?palomer
01:17:19 <lambdabot> Blargh!
01:17:24 <pumpkin> @quote wango
01:17:24 <lambdabot> wango says: do you like turing complete?
01:17:26 <mm_freak> and my question is essentially, whether it's _the_ morphism or _a_ morphism?
01:17:26 <hydo> vixey: I think I've got that.  I have a web based twitter/identi.ca client that I wrote in erlang that I'm planning to rewrite.
01:17:27 <hydo> hahah
01:17:30 <dmwit> ?keal
01:17:30 <lambdabot> haskell always said undefined
01:17:43 <hydo> dmwit: thanks for that. :)
01:17:45 <ski_> mm_freak : yes, but if `id' is supposed to be a function (from `X' in `Obj' to `Hom (X,X)'), then surely that must hold ?
01:18:03 * pumpkin runs the output of his program through openssl sha1 a couple of times to make sure it stays the same
01:18:04 <dmwit> ?keal
01:18:04 <lambdabot> what are epsilons?
01:18:07 <mm_freak> seems like it's _a_ morphism, as no law seems to prevent multiple identities
01:18:14 <ski_> (hydo : vixey left)
01:18:31 <hydo> well ppt.  Missed that.
01:18:49 <ski_> mm_freak : then `id' is not a function .. which brings to question why you're using functional syntax ..
01:19:21 <dmwit> paraphrased from memory: <keal> nsa trying to kill me. they even make lights green both ways once
01:19:27 <dmwit> What a guy.
01:19:36 <pumpkin> :o
01:20:12 <dmwit> i show how spell triangle in five irrationals using dark manifolds!
01:21:52 <ski_> (mm_freak : btw, using the identity laws, you can prove there's at most one identity per hom-set ..)
01:21:53 <hydo> Anyone know if BONUS is planning on finishing or at least adding to LYAH?  I really enjoyed it.
01:22:08 <hydo> enjoy, I guess is more correct.
01:22:21 <dmwit> Well, he hangs out here.  Why not ?ask him?
01:22:48 <hydo> I have... on here and on twitter... I'm think he's getting a little annoyed with me.
01:24:07 * Trafalgard wondered what you were talking about and tried to google lyah bonus
01:24:11 <Trafalgard> It did not work
01:24:13 <Trafalgard> at all.
01:24:42 <hydo> Learn You A Haskell  -- Google is quite familiar with it. :)
01:24:43 <seafood> I need a bit of a refresher. THis type here: type AnyEv a = forall t. (Monad (t STM), MonadTrans t) => Ev (t STM) a
01:24:46 <seafood> Is it existential?
01:25:36 <mmorrow> preflex: seen augustss
01:25:36 <preflex>  augustss was last seen on #haskell 14 hours, 43 minutes and 39 seconds ago, saying: I can't even remember the syntax.  It's too bizarre.
01:26:09 <dmwit> Trafalgard: try ?where lyah bonus
01:26:16 <Trafalgard> Google said: More "Tales from Lyah" - iWorkWithFools.com, World of Warcraft Forums (post search for a post by Lyah), some thread on octopusoverlords.com forums which says "I have Nod assassinate R'lyah. That Military Genius 2 on a Corrupter is just a ...... He would need bonus AP's from an Intel Center, Heroes, or Prisoners in ..."
01:26:17 <mmorrow> @tell augustss this is my goto idea more of less http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=759
01:26:18 <lambdabot> Consider it noted.
01:26:27 <Trafalgard> and that's just the first three matches
01:27:08 <Trafalgard> uh, '?where lyah bonus' shows exactly the same results as 'lyah bonus'
01:27:13 <Trafalgard> What was that supposed to do?
01:27:14 <Saizan> seafood: no
01:27:19 <pumpkin> mmorrow: that's pretty funky, does it work?
01:27:25 <seafood> Saizan: I didn't think so. So what is it?
01:27:25 <Saizan> seafood: it's quite the opposite
01:27:26 <hydo> ?where lyah bonus
01:27:26 <lambdabot> www.learnyouahaskell.com
01:27:29 <Trafalgard> well, anyways. 4:27 AM, good night.
01:27:32 <hydo> like that. :)
01:27:42 <mmorrow> pumpkin: oh yuhuh
01:27:57 <Trafalgard> ah.
01:27:59 <seafood> Saizan: It's not the same as: type AnyEv a t =   (Monad (t STM), MonadTrans t) => Ev (t STM) a?
01:28:04 <Trafalgard> lambdabot is magic.
01:28:05 <Saizan> seafood: if it were package in a datatype it'd be called a polymorphic component
01:28:08 <mmorrow> run that module's main
01:28:16 <pumpkin> mmorrow: I'm scared to :P
01:28:23 <mmorrow> heh
01:28:29 <pumpkin> okay :P
01:28:40 <Saizan> seafood: no, it's not, something of type AnyEv a _must_ be polymorphic in t
01:28:48 <mmorrow> i only used unsafeIOToST to illustrate what it's doing
01:28:54 <seafood> Saizan: Funky.
01:28:58 <pumpkin> mmorrow: scary :P
01:29:09 <mmorrow> 42 99 42 99 42 99 ... :)
01:29:21 <pumpkin> mmorrow: what if the two bits are stateful?
01:29:29 <pumpkin> or have shared state?
01:29:36 <mmorrow> that's ok
01:30:17 <mmorrow> hmm, but you'd have to make sure the other labelled block can see the var.. still some things to work out..
01:30:20 <pumpkin> oh I can sort of see how it's working
01:30:49 <pumpkin> so it's just maintaining a mutable map and that .: inserts the code for that label into the map?
01:30:49 <mmorrow> it just uses and IntMap (ST s ()) essentially, and "jump" looks up a Lbl in the env and runs it
01:30:53 <mmorrow> exactly
01:30:59 <pumpkin> ah :)
01:31:46 <pumpkin> pretty neat
01:33:17 <hydo> Is there a way to flush out all of the let'ed vars  that you've used in ghci?
01:34:00 <hydo> Oh, nevermind.
01:34:33 <dmwit> :reload
01:34:40 <dmwit> or just :r
01:34:43 <dmwit> See also :help
01:36:19 <hydo> dmwit: Yea, that reloads the loaded modules.  I'm talking about the vars that you've used in the interpreter.  It's not an issue I guess, as I can "let x =" and then later " x <- ..."
01:37:15 <Saizan> hydo: reloading the loaded modules resets the variables in scope
01:37:53 <hydo> Saizan: Ah, ok, that makes sense then.  :help for me doesn't mention that.  Thanks!
01:39:13 <ski_> mmorrow : what happens if you elide the `jump _foo' ?
01:39:36 <mmorrow> ski_: i was just thinking about that. so as-is it won't "fall through"
01:40:10 <mmorrow> i'm trying to think of some way to do that, but i'm not quite sure how atm
01:40:21 <ski_> continuation monad, i would think
01:41:06 <mmorrow> hmm, i was trying to not use that
01:41:59 <ski_> why not ?
01:42:18 <mmorrow> for fun :)
01:42:42 <mmorrow> another thing (unrelated) that one could do is to make CEnv instead be:
01:43:05 <mmorrow> newtype CEnv s r = CE {symtab :: IntMap (STRef s (C s r r))}
01:43:12 <mmorrow> then you could have self-modifying code
01:43:46 <ski_> imo, it would be nice if you could pass parameters to the labels
01:43:56 <mmorrow> yeah, that's true
01:44:19 <mmorrow> i did something similar to this in IO, with the self-modifying thing, but it was slightly different..
01:44:40 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=693
01:45:26 <ski_> (pumpkin : not 42 minutes, in any case ..)
01:46:11 <ski_> (also i want the labels to be local ..)
01:46:20 <mmorrow> ST is kinda a pain in the ass with having to propogate the `s' through everything
01:46:49 <mmorrow> ski_: hmm, yeah that'd be cool to have nested scopes and stuff
01:47:25 <seafood> Saizan: If I wrote a function of type "a -> AnyEv a" then it would be rank-2 right?
01:47:41 <ski_> mmorrow : you could try implement "comefrom" ..
01:47:59 <Saizan> seafood: no
01:48:04 <mmorrow> like reverse jump?
01:48:13 <ski_> seafood : how is `AnyEv' defined ?
01:48:13 <seafood> Really? Hmm, now I'm confused. Why not?
01:48:17 <Saizan> seafood: AnyEv a -> B would be
01:48:56 <Saizan> you can higher ranks only when the foralls are nested on the left of (->)
01:50:07 <Saizan> since a -> AnyEv a can be rewritten as forall a t. (Monad (t STM), MonadTrans t) => a -> Ev (t STM) a
01:51:01 <seafood> Saizan: So if you write the type out as a tree then the rank comes from depth of the deepest forall?
01:51:02 <ski_> Saizan : so `[AnyEv a]' is not a higher-ranked type ?
01:52:07 <Saizan> ski_: uhm, i haven't considered that, what do you think?
01:52:36 <ski_> by the definition of rank i can imagine, it would be rank 1
01:52:43 <ski_> but ghc might disagree
01:53:10 <quicksilver> it's impredicative
01:53:16 <Saizan> seafood: following left branches, yes, afaiu
01:53:28 <seafood> Hmm, more reading to be done.
01:53:33 <quicksilver> (instantiating a polymorphic type at a polymorphic type)
01:53:35 <seafood> Thanks for your help Saizan
01:53:51 <Saizan> np
01:53:54 <ski_> (quicksilver : is that a ghc language ?)
01:54:14 <pumpkin> wasn't that the issue with runST $ ?
01:54:22 <quicksilver> impredicative instantiation is a GHC extension, yes.
01:54:46 <mmorrow> pumpkin: i think so yes
01:55:08 <quicksilver> things like Maybe (forall a . a)
01:56:18 <ski_> > (\id -> (id 'a',id ())) (id id)
01:56:19 <lambdabot>   Couldn't match expected type `()' against inferred type `Char'
01:56:29 <mmorrow> , (\id -> (id 'a',id ())) (id id)
01:56:31 <lunabot>  luna: Couldn't match expected type `()'
01:56:35 <ski_> > (\(id :: forall a. a -> a) -> (id 'a',id ())) (id id)
01:56:37 <lambdabot>   ('a',())
01:56:46 <ski_> hrm
01:56:50 <mmorrow> , (\(id :: forall a. a -> a) -> (id 'a',id ())) (id id)
01:56:51 <lunabot>  luna: Illegal signature in pattern: forall a. a -> a
01:56:55 <mmorrow> heh
01:57:19 <mmorrow> i wonder if i don't have some flag set, or that became disallowed in 6.10
01:57:26 <ski_> i wonder if that does generalization anyway
01:57:52 <ski_> > (\(id :: forall a. a -> a) -> (id 'a',id ())) ((id :: (forall a. a -> a) -> (forall a. a -> a)) id)
01:57:53 <lambdabot>   ('a',())
01:58:02 <mmorrow> it works in my ghci 6.10.1
01:58:06 <mmorrow> it must be a flag
01:58:31 <mmorrow> lunabot's on 6.10.0.something though
01:59:56 <Saizan> probably RankNTypes?
02:00:18 <mmorrow> i have RankNTypes + ImpredicativePolymorphism both on in lunabot
02:00:24 <Saizan> and PatternSignatures
02:00:31 <mmorrow> yeah, that's the one
02:00:48 <Saizan> so with ImpredicativePolymorphism runST $ (..) works, right?
02:01:06 <ski_> i imagine so
02:01:31 <quicksilver> Saizan: it works, yes.
02:01:40 <quicksilver> the question remains "will it work without an annotation"
02:01:55 <quicksilver> you can't have a complete inference framework for impredicative polymorphism
02:01:58 <mmorrow> hmm, there is no Opt_PatternSignatures..
02:02:17 <mmorrow> Saizan: i think even with that flag, runST $ ... still doesn't work
02:02:27 <quicksilver> GHC's original impredicative implementation wouldn't infer that precise example.
02:02:32 <Saizan> if it implements what's described in FPH then you are required to put annotations only on lambdas
02:02:40 <quicksilver> SPJ had a proposed tweak in which it would work
02:02:42 <mmorrow> ah, this is the flag i'm refering to
02:02:43 <mmorrow> Opt_ImpredicativeTypes
02:02:47 <quicksilver> btu I don't know if it got put in.
02:02:53 <mmorrow> so i'm not sure if that means what we think
02:03:01 <quicksilver> Saizan: FPH?
02:03:26 <pozic> data Aa = Aa {showf:: forall a. Show a => a};f Aa{..} = show showf -- Ambiguous type variable `a' in the constraint: `Show a' arising from a use of `showf' at
02:03:55 <pozic> Why do I get this error?
02:04:06 <Saizan> quicksilver: https://research.microsoft.com/en-us/um/people/simonpj/papers/boxy/
02:04:31 <mmorrow> bah, i can't find a flag for pattern sigs
02:05:00 <quicksilver> Saizan: Hmm. RIght. I haven't read that one.
02:05:08 <quicksilver> Saizan: I've read "Boxy Types".
02:05:16 <quicksilver> but I know that Boxy Types is not, in fact, what they implemented.
02:06:04 <mmorrow> heh, apparently there's a Opt_WarnTabs
02:06:55 <Saizan> pozic: showf is of type forall a. Show a => a there, you've to pick a specific type for that 'a'
02:07:16 <Saizan> pozic: but maybe you wanted an existential instead?
02:07:19 <ski_> pozic : maybe what you really wanted was an "existential data type" ?
02:07:47 <Saizan> like data Aa = forall a. Show a => Aa {showf :: a}
02:08:28 * ski_ isn't sure mixing record syntax with existential data type works
02:08:36 <pozic> Ok, thanks.
02:08:44 <ski_> (maybe it partly works for GADT records ..)
02:09:06 <Saizan> ah, right, you can't type showf
02:09:25 <ski_> maybe you can still use it in `Aa{..}', though
02:10:07 <pumpkin> :t groupBy
02:10:08 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
02:25:08 <hugo___> hello
02:34:05 <vegai> Hmm, doesn't seem to work very well. Network.Curl for what I need
02:34:13 <vegai> interestengly, curl from the command line works just fine
02:34:51 <vegai> what I need = making a POST call with a body of xml to https and returning the resulting body
02:35:12 <vegai> unfortunately, the receiving end is so dumb, it only hands me a "500" ticket
02:35:27 <hugo___> hmm
02:35:31 <hugo___> try happs
02:35:49 <vegai> that'd be a rather large dep for a program that doesn't live in the web
02:36:05 <hugo___> happs works really well for that kind of foo
02:36:13 * vegai tries once more with Network.Curl.Easy
02:36:16 <vegai> that should be easy, right?
02:36:22 <hugo___> hehehe
02:36:34 <hugo___> well... easy is basically what you get with command line curl
02:36:48 <hugo___> if you can manage your objective with command line curl, then it should be enough
02:37:52 <hugo___> but it seems to me that you might need some heavy artillery there... so happs should be the prefered solution
02:38:07 <hugo___> in both cases you can look into the body of the http answer
02:40:35 <vegai> nah, still 500.
02:41:03 <vegai> Yes, I think I'll stop trying to use Network.Curl for now and just use the curl binary
02:42:19 <cads> vixey, the problem of finding a form Canon(F) for a graph F such that Canon(F) = Canon(G) iff F is isomorphic to G, that is called the graph canonization problem. Something that you said  in response to my questions of tree representation gave me a hint to finding out about that. It's funny just how a problem becomes much more tractable when you can express it in mathematical terms such as isomorphisms :D
02:46:41 <hugo___> vegai: it is the same...
02:46:48 <hugo___> vegai: what do you want to fetch ?
02:47:07 <hugo___> vegai: i have done some webcrawlers in haskell with very good results, using curl
02:47:24 <hugo___> i find it much more flexible than using bash script + curl
02:48:09 <Saizan> hugo___: any code to show?
02:49:38 <hugo___> well, i can put the code online, but its not finished yet
02:51:56 <hugo___> but im doing the server (in happs) also :/
02:52:20 <Saizan> and that makes you sad?:)
02:52:57 <hugo___> well, im not sure if vegai is working out the server, and he is using https which is a bad solution
02:53:16 <vegai> hugo___: I'm trying to POST to an xmlrpc server that's running on https
02:53:31 <vegai> well, not strictly xmlrpc I suppose, but sorta.
02:54:18 <vegai> and I don't have access to the logs or anything of the receiving end
02:54:26 <vegai> just "HTTP 500" or "HTTP 200" :-/
02:54:49 <vegai> Real World BS
02:55:03 <hugo___> BS = bullsh*t ?
02:55:08 <vegai> yes
02:55:13 <hugo___> ah ok
02:55:14 <hugo___> eheh
02:55:15 <vegai> or Business Solutions, take your pick
02:55:52 <vegai> well, readProcess "curl" etc. works rather fine
02:56:05 <vegai> except that now it's a bit harder to get the return code
02:57:07 <hugo___> hmm
02:57:07 <hugo___> you could try not to use the easy module
02:57:19 <hugo___> wait, ill try to paste some code...
02:57:38 <vegai> that's what I first tried... using curlMultiPost
02:58:05 <vegai> thanks, perhaps I'll notice if there's something obvious
02:58:16 <vegai> (though don't count on it :P)
02:58:38 <hugo___> http://hpaste.org/13856  but im not using https :/
02:58:49 <hugo___> this is the bot communication module
02:58:53 <vegai> I don't think that's the part that's going wrong for me
02:58:54 <hugo___> all the crawlers use it
02:59:09 <vegai> I just mention https because that rules out Network.HTTP
02:59:22 <vegai> which I had it on before, which worked perfectly well :-/
02:59:36 <vegai> wish I had time to implement SSL there, that'd be a rather great solution
03:00:12 <vegai> hmm, one obvious thing might be that I'm not supplying a user client string
03:00:56 <hugo___> well, its not necessary...
03:01:09 <vegai> who knows what the mystery server requires
03:01:44 <hugo___> for https youll have to pass around the CurlSSL opts
03:01:57 <hugo___> here: http://hackage.haskell.org/packages/archive/curl/1.3.3/doc/html/Network-Curl-Opts.html
03:02:19 <vegai> CurlSSLVerifyPeer False -- I have this
03:02:51 <hugo___> https is quite a nice false sense of security, and allows for a great deal of procrastination on the side of whoever is implementing the server :/
03:03:02 <vegai> ok, wasn't the user agent.
03:03:38 <hugo___> have you checked the curl response type ?
03:03:54 <Saizan> why false?
03:03:59 <hugo___> are you printing out all of its fields ? in my case i only need the body... but you never know where the heck the server is answering
03:04:16 <vegai> Saizan: because I don't care about that yet
03:04:32 <vegai> hugo___: Curl is answering OK, server is answering 500
03:04:40 <hugo___> vegai: check my "getStringURLWithCookie" function there: see im only fetching the body
03:04:48 <hugo___> yes, but that is not the body of the answer
03:04:51 <hugo___> that is the answer code
03:05:01 <hugo___> if its answering 500 you should have output on the body
03:05:42 <vegai> well, in my code where I use curlMultiPost, I have CurlWriteFunction $ callbackWriter (putStrLn)
03:07:00 <Saizan> no, i meant why false sense of security, i.e. what's so wrong with ssl
03:07:18 <vegai> oh, right.
03:08:03 <quicksilver> Saizan: some certificate authorities still use MD5
03:08:11 <quicksilver> Saizan: (that's what so wrong with ssl)
03:09:57 <hugo___> its not the fact that you're using SSL that gives you a reason to trust the server incoming input,... all input should be considered dangerous, except in some very specific applications
03:10:44 <vegai> and afaik this server would be on either lan or vpn anyway. Why they'd want https ...
03:11:18 <hugo___> vegai: so they dont have to do proper validation :)
03:11:45 <hugo___> and i bet that they're using self signed https :P
03:13:06 <hugo___> oh well, enough https bashing
03:13:50 <PeakerWork> quicksilver: is md5 totally broken, or just broken in relatively harmless ways?
03:13:59 <hugo___> PeakerWork: totally broken
03:14:10 <PeakerWork> hugo___: you can make a new blob to match any existing md5 sum?
03:14:17 <hugo___> just checkout last month CCC conferences ;)
03:14:30 <hugo___> yes, actually you kind of have it online
03:14:33 <pumpkin> someone made an invalid CA cert
03:14:35 <hugo___> and for md5+salt also
03:14:37 <PeakerWork> or worse: prepend/append to any existing block so it matches an md5 sum?
03:15:04 <pumpkin> PeakerWork: people have "subverted SSL" using broken md5 :P it's quite practical
03:15:20 <PeakerWork> pumpkin: ah, thanks for the update..
03:15:23 <pumpkin> lots of noise about it in past couple of weeks
03:15:31 <hugo___> the biggest problem with sll is not md5 at all (and md5 is QUITE a huge problem), but the use of self signed certificates
03:15:39 <hugo___> s/sll/ssl
03:17:27 <quicksilver> I don't think self signed certs are a problem, as long as you understand what they are.
03:18:12 <pumpkin> @index on
03:18:13 <lambdabot> bzzt
03:18:24 <pumpkin> where does that `on` people use come from?
03:18:27 <pumpkin> @hoogle on
03:18:27 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
03:18:27 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
03:18:27 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
03:18:30 <pumpkin> aha :)
03:22:45 <timebomb> why would self signed certificates be a problem. theres 2 uses for
03:22:53 <timebomb> ah geez
03:23:36 <timebomb> anyway, when you just use them for encrypting the data flow theres nothing wrong with them. which is the only reason you would use a self signed cert to begin with
03:23:46 <ski_> (isn't "root certificates" self-signed ?)
03:52:38 <chrisdone> pandoc-1.1 failed during the building phase. The exception was:
03:52:38 <chrisdone> exit: ExitFailure 8
03:52:38 <chrisdone> which exit failure is this?
03:53:45 <Saizan> the log might have a more informative message
03:54:19 <chrisdone> where is that?
03:55:10 <Saizan> i meant the one in your terminal buffer
03:56:04 <chrisdone> [ 3 of 28] Compiling Text.Pandoc.Definition ( Text/Pandoc/Definition.hs, dist/build/Text/Pandoc/Definition.o )
03:56:04 <chrisdone> cabal: Error: some packages failed to install:
03:56:04 <chrisdone> pandoc-1.1 failed during the building phase. The exception was:
03:56:04 <chrisdone> exit: ExitFailure 8
03:56:07 <chrisdone>  
03:56:09 <chrisdone> it just crashed mid-compliation
03:56:30 <chrisdone> ._.
03:56:44 <Saizan> weird
03:57:41 <chrisdone> hm, it got to 11 this time. I think GHC is segfaulting, it did this before randomly
03:58:02 <sbahra> :(
03:58:11 <pumpkin> I got segfaults from my app today using all pure code! :P
03:58:28 <chrisdone> I recently installed a fresh Ubuntu and added some RAM
03:58:46 <chrisdone> I'm guessing the latest ubuntu isn't going to cause random crashes... ~_~
03:59:49 <hugo___> pumpkin: wow! kudos for that :D
04:00:03 <hugo___> you must using quite some haskell foo there
04:00:07 <pumpkin> yeah, it was awesome... got it crashing on two different machines too!
04:00:24 <hugo___> sweet stuff :D
04:00:45 <chrisdone> would iffy RAM cause just GHC to segfault but none of my other software (that I'm aware of)?
04:02:04 <earthy> chrisdone: that is not unheard of
04:02:07 <quicksilver> chrisdone: well, GHC might stress your memory harder than many other apps
04:02:17 <quicksilver> but it would be surprising if nothing else ever broke.
04:02:21 <earthy> chrisdone: what OS are you on? you might try compiling a linux kernel with gcc
04:02:30 <earthy> (that tends to stress memory as well)
04:02:42 <chrisdone> earthy: ubuntu linux
04:02:50 <JaffaCake> chrisdone: it's not unheard of, yes
04:02:57 <earthy> well then, try compiling a linux kernel
04:02:58 <chrisdone> the memory usage is at about 20% when compiling
04:03:07 <chrisdone> hm, ok
04:03:14 <earthy> if that segfaults somewhere reboot into memtest86
04:03:39 <earthy> there should be a package for ubuntu to put that in your boot menu, iirc
04:03:42 <timebomb> ah
04:03:44 <mmorrow> does anyone know where some code that gives a good overview/example of programming with pthreads in C?
04:03:51 <timebomb> haskell is good for crypto right?
04:04:09 <Adamant> timebomb: sort of
04:04:14 <mmorrow> timebomb: doing what with crypto?
04:04:17 <chrisdone> earthy: what if it doesn't?
04:04:20 <pumpkin> timebomb: what does being good for crypto entail?
04:04:20 <Adamant> timebomb: look at Cryptol
04:04:42 <kaol> serious crypto and GC don't really work well along
04:04:48 <earthy> chrisdone: then there's something weird happening
04:04:57 <timebomb> why not?
04:04:59 <pumpkin> kaol: true
04:05:05 <Adamant> kaol: depends if you can get certain constructs
04:05:06 <timebomb> ah gc
04:05:08 <timebomb> nevermind
04:05:10 <mmorrow> yeah, you'd want to manually manage your mem
04:05:20 <earthy> but you could try running memtest86 from within the OS
04:05:23 <mmorrow> mallocBytes :: Int -> IO (Ptr a)
04:05:31 <timebomb> i kinda thought smp and the way it handles high numbers would make it ideal
04:05:33 <pumpkin> even apple clears out its keys from memory the moment they're done with them on iphone :)
04:05:38 <timebomb> but i didnt think of gc
04:05:54 <pumpkin> wow, I managed to make apple plural and singular in one sentence
04:06:26 <timebomb> most ppl wouldn't have noticed till you said it :p
04:08:08 <sbahra> mmorrow, are you looking for a pthreads tutorial?
04:08:10 <mmorrow> ok, anyone know of any good (online) references for pthreads
04:08:12 <mmorrow> yes!
04:08:15 <pumpkin> lol
04:08:27 <pumpkin> sbahra's using his evil mindreading technique again
04:08:31 <mmorrow> hehe
04:08:52 <PeakerWork> lispy: ping
04:08:55 <sbahra> mmorrow, really, the manual pages are enough for pthreads, for most use cases. I suggest the FreeBSD manual pages. There are several books on the subject.
04:09:05 <sbahra> mmorrow, I saw a decent tutorial some time ago on IBM DeveloperWork's. Let me pull it up for you.
04:09:05 <PeakerWork> lispy: any idea if the Reactive bug with snapshot was fixed?
04:09:21 <mmorrow> sbahra: cool, yeah i've got the manual pages open.
04:09:29 <chrisdone> earthy: I ran the bootup memtest86+ and saw errors, but it was hard to tell if that was my existing RAM because that's had errors for ages and I've never had problems. hard to tell if the additional RAM is causing this or OS update, considering nothing else is having problems. I'll try compiling linux and then if that fails take out the RAM
04:09:42 <sbahra> Well, that one sucks, hehe
04:10:05 <earthy> the *existing* ram has errors?
04:10:12 <mmorrow> heh, it's cool. i should be able to work it out... thx
04:10:17 <sbahra> mm_freak, hey, I found a good one
04:10:18 <earthy> you were not bychance running with the badmem patch?
04:10:19 <sbahra> err
04:10:22 <sbahra> mmorrow, to you :)
04:10:23 <mmorrow> oh?
04:10:26 <sbahra> mmorrow, https://computing.llnl.gov/tutorials/pthreads/
04:10:32 <mmorrow> sweetness
04:10:38 <sbahra> That one is pretty cool
04:10:44 <earthy> (where the kernel simply keeps a list of known-bad ram blocks and does not use them)
04:10:56 <mmorrow> beautiful, that looks helpful
04:11:10 <chrisdone> earthy: nope. I heard about that but IIRC you have to manually specify the memory addresses which kind of went over my head
04:11:33 <earthy> if you were running with badmem, then adding memory might have affected the location of the bad memory blocks so that the original bad mem block list got out of sync with the actual locations of the bad mem
04:12:02 <earthy> if you were not running with badmem adding memory might still have shifted the bad memory bits to a place where they're slightly more likely to get used...
04:12:33 <pao> :t map (uncurry xor . (ord *** ord))
04:12:34 <lambdabot> [(Char, Char)] -> [Int]
04:12:35 <chrisdone> man what a pain in the nads
04:12:45 <sbahra> Can't Linux handle faulty RAM?
04:12:49 <pao> how do I "compose" that function with zip?
04:12:51 * sbahra notes Solaris can
04:13:03 <sbahra> Very, very cool imho ;p
04:21:13 <pk> @hoogle glwrap
04:21:14 <lambdabot> No results found
04:25:42 <chrisdone> can't figure out how to compile linux so I'll do GHC instead
04:28:38 <Saizan> :t zipWith (uncurry xor . (ord *** ord))
04:28:40 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `Int'
04:28:40 <lambdabot>     Probable cause: `.' is applied to too many arguments
04:28:40 <lambdabot>     In the first argument of `zipWith', namely
04:29:16 <Saizan> :t zipWith (curry $ uncurry xor . (ord *** ord))
04:29:18 <lambdabot> [Char] -> [Char] -> [Int]
04:29:50 <sbahra> chrisdone, it is not the OS. By the way...
04:30:01 <sbahra> chrisdone, it is a hardware issue as memtest86+ indicates.
04:32:44 <chrisdone> ni'o mi tirna co jai selgi'e be fa la tul la'oi H
04:32:44 <|jedai|> @pl (\x y -> xor (ord x) (ord y))
04:32:45 <lambdabot> (. ord) . xor . ord
04:32:49 <chrisdone> agh wrong channel
04:33:05 <chrisdone> sbahra: yeah, that makes me sad :(
04:33:10 <|jedai|> :t on
04:33:11 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
04:33:35 <|jedai|> :t zipWith (xor `on` ord)
04:33:36 <lambdabot> [Char] -> [Char] -> [Int]
04:34:07 <portnov> does anybody know a link to comprasion - darcs vs other distributed vcs's ?
04:34:44 <chrisdone> sbahra: ah, yeah. compiling GHC just segfaulted. guess I'll remove the RAM ;_;
04:34:47 <chrisdone> brb
04:37:08 <luqui> is -funbox-strict-fields on by default (or in -O) these days?
04:38:11 <Sam^^> join firefox
04:38:24 <pumpkin> I refuse to!
04:38:25 <luqui> :t join ?firefox
04:38:26 <lambdabot> forall (m :: * -> *) a. (Monad m, ?firefox::m (m a)) => m a
04:39:23 <pumpkin> > join (darkSide) "luke"
04:39:24 <lambdabot>   okay dad
04:39:43 <luqui> :t darkSide
04:39:44 <lambdabot> forall t t1. t -> t1 -> Doc
04:40:01 <pumpkin> :P
04:40:10 * pumpkin whistles innocently
04:41:00 <luqui> using Doc you can output a string without quotes... could that be used to create a botquine?
04:41:29 <pumpkin> luqui: unfortunately not :/
04:41:34 <pumpkin> it prefixes everything with a space
04:41:41 <luqui> aww, clever
04:42:15 <pumpkin> > text "preflex: zdec filepathzm1zi1zi0zi1_SystemziFilePathziPosix_lvl1_closure"
04:42:16 <lambdabot>   preflex: zdec filepathzm1zi1zi0zi1_SystemziFilePathziPosix_lvl1_closure
04:42:19 <luqui> preflex, @bot
04:42:26 <pumpkin> boo
04:43:52 <chrisdone> yeah, it was the RAM
04:44:03 <chrisdone> everything compiles now ~_~
04:44:39 <chrisdone> back to 1GB ;_;
04:44:50 <pumpkin> aw
04:47:33 <Saizan> which was the blog post where they defined argument/result and (~>)?
04:48:09 <quicksilver> Saizan: http://conal.net/blog/posts/prettier-functions-for-wrapping-and-wrapping/
04:48:11 <pumpkin> http://matt.immute.net/content/pointless-fun
04:48:40 <Saizan> thanks :)
04:48:48 <quicksilver> hmm that's the first one
04:48:50 <quicksilver> not the ~> one
04:49:23 <quicksilver> maybe ~> wasn't conal?
04:49:35 <pumpkin> quicksilver: it was the one I linked to I think
04:49:49 <sbahra> infix infix infix
04:50:03 <quicksilver> oh.
04:50:08 <pumpkin> sbahra: such a fixation on fixity!
04:50:09 * quicksilver didn't spot that.
04:50:14 <chessguy_work> 'mornin
04:51:08 <duryodhan> noob here - I  can't seem to be able to call Data.List.sortBy from inside my .hs file ...it says not in scope
04:51:19 <wjt> did you import Data.List ?
04:51:28 <duryodhan> wjt: ohh ok
04:51:53 <duryodhan> sorry .. I am doing the Real World Haskell book and the thing didn't tell me about imports .. just told me use that functions
04:52:18 <chessguy_work> duryodhan, you can also just call it Data.List.sortBy if you really want
04:52:45 <chessguy_work> > Data.List.sortBy compare [5..1]
04:52:47 <lambdabot>   []
04:52:48 <duryodhan> chessguy_work: I did that .. said not in scope
04:52:51 <chessguy_work> eh?
04:52:59 <duryodhan> yeah
04:53:05 <Saizan> chessguy_work: that works only in ghci
04:53:12 <chessguy_work> weird
04:53:14 <Saizan> in a file you've to import the module
04:53:34 <chessguy_work> why doesn't it work on LB then?
04:53:41 <chessguy_work> @src sortBy
04:53:41 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
04:53:53 <chessguy_work> @src sort
04:53:53 <lambdabot> sort = sortBy compare
04:54:08 <duryodhan> Saizan: I am in ghci
04:54:10 <chessguy_work> > sort [5..1]
04:54:11 <lambdabot>   []
04:54:16 <chessguy_work> ...
04:54:31 <duryodhan> Saizan: I did first :m Data.List , then tried to :l my .hs file
04:54:50 <chessguy_work> duryodhan, put the line "import Data.List" in your actual file
04:54:54 <quicksilver> duryodhan: your hs file must import Data.List if it wants to use it.
04:54:57 <Saizan> duryodhan: you've to put the line "import Data.List" at the top of your file
04:55:05 <duryodhan> it said that Data.List.sortBy not in scope
04:55:34 <duryodhan> yeah I got that .. about imports .. I am talking about what chessguy_work was saying .. that it should work directly with import if I give full name ..
04:55:54 <chessguy_work> duryodhan, apparently i'm wrong and you should ignore me
04:55:56 <quicksilver> not in a .hs file it won't.
04:56:03 <duryodhan> k
04:56:07 <duryodhan> just curious ...
04:56:08 <Saizan> it works only for the expressions you type at the ghci prompt
04:56:11 <quicksilver> ghci has magic auto-import-by-full-name
04:56:12 <chessguy_work> (not a bad general rule of thumb)
04:56:14 <quicksilver> .hs files don't.
04:58:39 <duryodhan> quicksilver: ok
05:07:04 <chessguy_work> ok, i've got an actual plan for building a little automated inference engine in haskell. should be fun!
05:09:00 <Holle_> how can i create my own documentation?
05:13:57 <C-Keen> Holle_: you mean api docs? That would be haddock
05:14:02 <C-Keen> haddok
05:14:07 <C-Keen> (spelling?)
05:14:11 <pumpkin> the former :)
05:15:16 <C-Keen> thanks pumpkin
05:15:36 <C-Keen> Holle_: for general code documentation a lot of people use so called literate code
05:15:53 <duryodhan> lol ... Thanks pumpkin seems so ....
05:15:58 <duryodhan> domestic ?
05:16:36 <Holle_> so it's better to add some comments to a code than building a documentation?
05:17:37 <C-Keen> Holle_: with literate code the idea is to just run your sources through latex to generate the docs
05:18:05 <Holle_> how does it works?
05:18:06 <C-Keen> Holle_: see http://www.haskell.org/haskellwiki/Literate_programming
05:19:01 <C-Keen> Holle_: it is based on the assumption that everything is documentation unless marked otherwise
05:19:01 <Holle_> nice
05:19:10 <C-Keen> Holle_: which is the opposite of the usual waz
05:19:10 <C-Keen> way
05:19:43 <pejo> I'm not convinced that "a lot" of people use literate programming.
05:19:45 <C-Keen> Knuth has had the first idea to do it that way. His book gives some nice annecdotes
05:20:00 <C-Keen> pejo: yeah maybe not that many
05:22:42 <duryodhan> when I say "data Tree a = Node a (Tree a) (Tree a)
05:22:48 <duryodhan> what is Node ? is it a constructor ?
05:24:55 <int-e> duryodhan: a data constructor. yes
05:26:20 <duryodhan> hmm and the next line with a | I do empty .. then Empty is a type of tree .. or is it a constructor that returns a Tree but takes no args
05:26:33 <quicksilver> it is another constructor.
05:26:50 <quicksilver> then Tree is a two-constructor type: Node and Empty
05:27:25 <duryodhan> yeah I thought it would be a constructor ... but then :type Empty gives Empty::Tree
05:27:29 <duryodhan> like for a variable
05:27:32 <pumpkin> you should make an infinite tree!
05:28:18 <duryodhan> pumpkin : define infinite tree ?
05:28:37 <pumpkin> one with no Empty constructor :P
05:28:57 <duryodhan> but then it is just a= Node "qw" a a .. cos you are sticking to binary tree :P
05:29:01 <duryodhan> (forget haskell for a minute)
05:29:15 <duryodhan> wouldn't you want an infinite tree to be a little more fun ?
05:29:30 <mmorrow> , fix (\me -> Node () [me,me])
05:29:37 <lunabot>  Node {rootLabel = (), subForest = [Node {rootLabel = (), subForest = [Nod...
05:29:45 <duryodhan> quicksilver: so is Empty a constuctor or a variabel  ?
05:29:45 <mmorrow> infinite binary tree
05:29:58 <mmorrow> , levels (fix (\me -> Node () [me,me]))
05:30:00 <lunabot>  [[()],[(),()],[(),(),(),()],[(),(),(),(),(),(),(),()],[(),(),(),(),(),(),...
05:30:15 <quicksilver> duryodhan: a constructor.
05:30:18 <mmorrow> , fmap length $ levels (fix (\me -> Node () [me,me]))
05:30:22 <lunabot>  luna: out of memory (requested 1048576 bytes)
05:30:24 <mmorrow> , fmap length $ levels (fix (\me -> Node () [me,me]))
05:30:28 * duryodhan is dumstruck with mmorrow's haskell
05:30:28 <lunabot>  luna: out of memory (requested 1048576 bytes)
05:30:29 <scook0> it's a nullary (0-argument) constructor
05:30:40 <scook0> so you don't need to apply it to anything
05:30:51 <scook0> but you can still pattern match on it like any other constructor
05:30:53 <quicksilver> duryodhan: Empty is a constructor, but it's also an expression.
05:31:00 <chessguy_work> duryodhan, if you define something like "data Tree a = Node (Tree a) (Tree a) | Empty" then Empty is a constructor, it just doesn't take any arguments
05:31:01 <quicksilver> duryodhan: since it's an expression, it has a type.
05:31:02 <duryodhan> scook0: yeah .. but then shouldn't there be a difference between an expression and a function ..
05:31:04 <mmorrow> , let tree = Node () [tree,tree] in tree
05:31:04 <quicksilver> and it's type is Tree a.
05:31:06 <lunabot>  Node {rootLabel = (), subForest = [Node {rootLabel = (), subForest = [Nod...
05:31:32 <mmorrow> , let me = 0 : me in me
05:31:34 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
05:31:36 <scook0> in Haskell, every expression can be thought of as a nullary function
05:31:39 <scook0> due to laziness
05:31:53 <duryodhan> so is this like lambda calculus then .. with no expression per se .. just lambdas ?
05:32:39 <mmorrow> well, you can have 0-arity lambdas..
05:32:42 <scook0> hmm, I think I've misled you
05:32:45 <mmorrow> , 4
05:32:47 <lunabot>  4
05:32:50 <mmorrow> , ()
05:32:52 <lunabot>  ()
05:33:04 <duryodhan> arity being the number of args ?
05:33:11 <mmorrow> yes
05:33:21 <pejo> mmorrow, could you explain how 0-arity lambdas are supposed to work?
05:33:22 <scook0> to put it another way: what's the difference between an ordinary expression and a function of no arguments?
05:33:24 <mmorrow> but i wouldn't think of those as lambdas, but i guess you could..
05:33:39 <duryodhan> that's my question .. is haskell totally like lambda calculus or does it have a different formulation for x=12
05:33:44 <duryodhan> (other than the let)
05:33:46 <mmorrow> pejo: no args!! :)
05:33:58 <quicksilver> duryodhan: a function is different from an expression
05:34:06 <duryodhan> scook0: in lambda calculus , it isn't different
05:34:09 <quicksilver> duryodhan: but a function on its own is one sort of expression.
05:34:21 <quicksilver> "sin" is a function
05:34:27 <quicksilver> in another sense "sin" is also an expression.
05:34:28 <mmorrow> it has let, case, you can bind stuff to names, data declarations, type classes, ..
05:34:29 * duryodhan sez all opinions imho btw
05:34:37 <pejo> mmorrow, and then evaluation of that expression is finished?
05:34:40 <mmorrow> (lambdas too ;)
05:34:52 <quicksilver> "'a'" is an expression which is not a function.
05:34:58 <duryodhan> isn't let also in lambda calculus ?
05:34:59 <mmorrow> pejo: i guess. i was just going along with the lambda theme
05:35:19 <scook0> there's more than one "lambda calculus"
05:35:26 <quicksilver> the standard - simplest - lambda calculus does not have let.
05:35:31 <scook0> but the simple untyped lambda calculus doesn't have let
05:35:37 <quicksilver> but I'm not sure what your question was really asking.
05:35:39 <duryodhan> quicksilver: ofcourse any thing you write down is an expression ... btu my point is a little different
05:35:42 <quicksilver> perhaps you can reformulate it.
05:35:48 <quicksilver> duryodhan: then what is your point?
05:36:05 <pozic> I have a bunch of classes, and they all have the same context, but do not share a method. Is there any way to remove that boilerplating?
05:36:36 <mmorrow> pozic: you can make a methodless class that has all of those as constraints, then just use that class as the constraint
05:36:40 <duryodhan> quicksilver: I am saying .. does haskell expression only have functions and their application?
05:36:48 <duryodhan> quicksilver: or is there anything else at all ..
05:36:53 <mmorrow> class (A a, B a, C a, D a, E a) => Foo a
05:37:06 <mmorrow> class (Foo a) => Bar a where bar :: ...
05:37:13 <quicksilver> duryodhan: there are also: "if", "let", "case" and "\" (lambda)
05:37:25 <duryodhan> cos in that sense ... let a = 12 , where a :: Int .. then a is also a function .. just a 0arity one
05:37:34 <scook0> not to mention literals and variables
05:37:38 <quicksilver> plus literals (numbers, strings, chars)
05:38:05 <mmorrow> duryodhan: i guess it depends on your definition of function
05:38:13 <duryodhan> yeah .. lets say a little advanced version of the calculus .. as usually taught in cs courses ..
05:38:16 <scook0> syntactically, a is a variable
05:38:29 <duryodhan> mmorrow: what's yours ?
05:38:30 <quicksilver> yes, haskell is very like an advanced, typed, lambda calculus.
05:38:57 <mmorrow> duryodhan: i'd probably define a function to be something of type (a -> b) for some `a' and `b'
05:39:08 <quicksilver> haskell is very much STLC with recursion and some base types, and type classes.
05:39:28 <mmorrow> but you could just as well define a function to be something of type `a' for any `a' i guess
05:40:00 <duryodhan> quicksilver: exactly .. it is not advanced that much it is just STLC right ?
05:40:20 <pozic> mmorrow: if I use it as a class constraint, it will need MPTCs.
05:40:35 <mmorrow> pozic: ok, i think that should still work
05:40:37 <duryodhan> mmorrow: thats the lamda calculus definition .. I don't think without that you would get turing computability in functional languages ...
05:40:44 <pozic> mmorrow: The only way around that is to use it as a method context.
05:40:52 * duryodhan is not really sure of his terminology
05:41:17 <mmorrow> pozic: hmm
05:41:54 <duryodhan> forget let for a moment. . thats just syntactic sugar .. say haskell actually just replaces every let expression with the actual stuff and only then runs it ..
05:42:04 <duryodhan> so haskell is just STLC right ?
05:42:20 <mmorrow> duryodhan: i think what you define a "function" to be is separate from what the constructs of a language can do (independent of labels)
05:42:42 <mmorrow> all you need to do for turing completeness is to interpret brainfuck ;)
05:42:53 <duryodhan> mmorrow: I am talking about lambda calculus .. without 0-arity functions it can't be turing computable
05:43:00 <duryodhan> mmorrow: brainfuck is not functional :P
05:43:06 <mmorrow> but it's turing complete
05:43:06 <duryodhan> mmorrow: its practically a turing machine
05:43:29 <fasta> mmorrow: You wrote some Template Haskell to derive folds, right? It seems that you messed up the AST. I improved it somewhat, but it still fails for a simple list isomorphic type because it defines a function twice (no idea where that error comes from). It does work for a more complicated type, though. If you have any interest in getting it to work completely, I can send you the code.
05:43:39 <mmorrow> i'm not really sure about lambda calc partics, i studied math :P
05:43:46 <pejo> duryodhan, what is your definition of a function?
05:44:09 <duryodhan> http://en.wikipedia.org/wiki/Lambda_Calculus
05:44:19 <duryodhan> pejo: ^^
05:44:43 <mmorrow> fasta: awesome! yeah, i used VarE where i shoulda used ConE among other things. newsham actually just recently fixed it up and i think submitted a patch ot Data.Derive. i'd love to see your code though :)
05:44:58 <mmorrow> (i'm interested fo sho)
05:44:59 <sbahra> mmorrow, what are those for? VarE/ConE?
05:45:09 <mmorrow> , [|\x -> x|]
05:45:12 <lunabot>  LamE [VarP x_0] (VarE x_0)
05:45:14 <mmorrow> , [|\x -> Just x|]
05:45:16 <lunabot>  LamE [VarP x_0] (AppE (ConE Just) (VarE x_0))
05:45:19 <fasta> mmorrow: (i'm interested fo sho)?
05:45:31 <sbahra> fasta, "yes send me the code"
05:45:34 <mmorrow> fasta: heh, i'm definitely interested
05:46:28 <sbahra> mmorrow, I see, cool
05:46:44 <mmorrow> fasta: hmm, that's weird that it defines a function twice, ohhhhhh
05:47:06 <mmorrow> yeah, that was a prob too, i should had /one/ FunD with a bunch of Clauses
05:47:17 <mmorrow> rather than a bunch of FunD's with a single clause
05:47:19 <sbahra> fasta, you were involved with gIFT, no?
05:47:27 <fasta> mmorrow: probably in the AST there is something that says it's a collection of functions.
05:47:44 <mmorrow> , src 'FunD
05:47:45 <pejo> duryodhan, are you refering to the first sentence of the informal description?
05:47:46 <fasta> mmorrow: right, probably that. I am not very familiar with TH.
05:47:54 <lunabot>  data Dec = ... | FunD Name ([Clause]) | ...
05:47:54 <lunabot>  infixl 9
05:47:59 <fasta> sbahra: no, but I know someone who is.
05:48:07 <duryodhan> pejo: yeah
05:48:15 <fasta> sbahra: or was, I mean.
05:48:22 <sbahra> fasta, yes, ok.
05:48:37 * sbahra recalls talking to a fasta in ##C many many years ago
05:48:42 <mmorrow> fasta: i was using it to prettyprint the code out, then use that, and i never actually tried to splice it in directly at the top-level
05:48:54 <mmorrow> so didn't realize the bugs until newsham tried it
05:49:14 <pejo> duryodhan, but the grammar for expressions in your (untyped) LC is  E ::= x | \x.E | E E'?
05:49:44 <mmorrow> fasta: do you have a darcs repo or something somewhere?
05:50:00 <duryodhan> so ?
05:51:44 <pejo> duryodhan, so an expression could be an application or a variable just as well
06:02:31 <duryodhan> yeah
06:03:18 <duryodhan> ok
06:06:34 <C-Keen> :t Doc
06:06:35 <lambdabot> Not in scope: data constructor `Doc'
06:06:44 <C-Keen> @src Doc
06:06:45 <lambdabot> Source not found. I've seen penguins that can type better than that.
06:06:51 <C-Keen> @hoogle Doc
06:06:51 <lambdabot> Text.PrettyPrint.HughesPJ data Doc
06:06:51 <lambdabot> Language.Haskell.TH.PprLib type Doc = PprM Doc
06:06:51 <lambdabot> Distribution.Simple.InstallDirs docdir :: InstallDirs dir -> dir
06:48:22 <fasta> What's the most documented matrix library that works on *nix and Windows?
06:53:55 <lupsyn> Hi all... maybe you can help me.... for exercise i must do a program like this... I have a list for example [1,2,3,4,5,6,7...] and i must return a list of couple that for each x give me the sum of predecessor ... so [(1,0),(2,1),(3,3),(4,6)....] etc... i must write with fold and i can't to use the reverse of annotate = fst.foldr(\x (xs,sum)-> ((x,sum):xs,sum+x ) ) ([],0) ; could you help me ?
06:55:49 <quicksilver> lupsyn: http://www.haskell.org/haskellwiki/Homework_help
06:59:44 <ziman> lupsyn, you might want to take a look at scanl
07:00:09 <ziman> (or foldl)
07:01:36 <lupsyn> <lupsyn> yep
07:01:36 <lupsyn>  <lupsyn> but i don't know how to express whit lambda expression
07:01:36 <lupsyn>  <lupsyn> i tought foldl (\xs (xs,acc)-> (xs,acc+x) ) ([],0)
07:01:58 <lupsyn> but obiusvly it don't work
07:04:53 <Holle_> how can i build a sleep function? is it possible to get the sytem time in ms?
07:05:15 <quicksilver> @hoogle threadDelay
07:05:16 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
07:05:39 <chrisdone> quicksilver: turned out it was dodgy RAM
07:06:15 <ziman> lupsyn, i'd zip the original list with the list of partial sums
07:06:25 <ziman> (using scanl)
07:06:39 <lupsyn> i must use foldl
07:06:57 <quicksilver> chrisdone: *nod*
07:07:23 <fasta> lupsyn: why are you asking here?
07:07:55 <dublpaws> :l (^)
07:08:18 <dublpaws> :t (^)
07:08:19 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
07:08:55 <dublpaws> so, how to typeclass header for that in ghci? for all the marbles.
07:09:38 <quicksilver> dublpaws: erm, what?
07:11:16 <dublpaws> actually mlocate GHC | grep Real results in Real.hs, where ghci says the definiton of the typeclass (^) is, though the file seems like a stub. I'm looking for the typeclass header for (^)
07:12:58 <dublpaws> preferably through ghci, however it politely informs that the source isn't availble, using compiled module apparently. Tried :load'ing aforementioned Real.hs with full path to no avail.
07:13:24 <doserj> @src (^)
07:13:25 <lambdabot> x ^ 0            =  1
07:13:25 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
07:13:25 <lambdabot>   where f _ 0 y = y
07:13:25 <lambdabot>         f x n y = g x n
07:13:25 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
07:13:27 <lambdabot>                       | otherwise = f x (n-1) (x*y)
07:13:29 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
07:13:47 <dublpaws> aha thanks, that's doable in private chat with lambdabot?
07:13:56 <doserj> sure
07:14:42 <quicksilver> dublpaws: in ghci, ":i (^)"
07:14:57 <quicksilver> dublpaws: tells you it is a normal function, not a method, defined in GHC.Real
07:14:58 <dublpaws> that give the type
07:15:11 <quicksilver> not only the type.
07:15:56 <dublpaws> (^) :: (Num a, Integral b) => a -> b -> a       -- Defined in GHC.Real, was looking for the header
07:16:19 <quicksilver> dublpaws: I don't know what you mean by "header" ?
07:16:56 <dublpaws> class BasicEq2 a where
07:17:09 <quicksilver> dublpaws: as I said "this tells you it is a normal function, not a method"
07:17:36 <quicksilver> dublpaws: compare ":i (*)", where * is indeed a method.
07:18:21 <dublpaws> I get it, thank quicksilver
07:19:54 <Kvasir> what is "infixr 8 ^"?
07:20:08 <BONUS> infixr means right-associative
07:20:17 <Kvasir> and 8 the priority?
07:20:27 <BONUS> that 2 ^ 4 ^ 5 ^ 6 is 2 ^ (4 ^ (5 ^ 6))
07:20:30 <BONUS> yeah
07:20:37 <BONUS> higher binds tighter
07:20:47 <Kvasir> yep, * is 7
07:21:47 <Holle_> where do i find a good example on how to print text with cairo?
07:27:08 <dcoutts_> Holle_: have you looked at the gtk2hs demos?
07:27:56 <Holle_> this looks nice: http://cairographics.org/tutorial/#L3showtext but i don't know how to translate into haskell
07:29:45 <C-Keen> can I install gtk2hs with cabal?
07:29:55 <dcoutts_> C-Keen: not yet
07:30:01 <dcoutts_> Holle_: look at the gtk2hs demos
07:30:24 <C-Keen> dcoutts_: ok
07:31:57 <dcoutts_> Holle_: they're included in the gtk2hs tarball you installed from, there's a cairo section, demos/cairo/Text.hs
07:32:17 <Holle_> yes i found it
07:33:29 <Holle_> thanks
07:38:59 <fasta> Is there even a library that has rotation and translation for homogeneous matrices implemented that works under 6.10, which is either BSD or LGPL licensed?
07:40:39 <quicksilver> fasta: 4x4? well, there's opengl :P
07:41:47 <saml> > 4x4
07:41:48 <lambdabot>   Not in scope: `x4'
07:42:04 <saml> > 4x4 where x4 = (+4)
07:42:05 <lambdabot>       No instance for (Num ((a -> a) -> a1))
07:42:05 <lambdabot>        arising from the literal ...
07:42:27 <saml> > let x4 = (+4) in 4x4
07:42:28 <lambdabot>       No instance for (Num ((a -> a) -> a1))
07:42:28 <lambdabot>        arising from the literal ...
07:42:34 <fasta> quicksilver: getting the matrix to the GPU probably takes longer than computing it, no?
07:43:12 <quicksilver> fasta: opengl doesn't do the matrix multiplication on the GPU anyway.
07:43:21 <quicksilver> the matrix stack is just a software library.
07:43:46 <quicksilver> (the matrix x vector final part is done on the GPU, though)
07:43:51 <portnov> > let x4 = (+4) in x4 4
07:43:52 <lambdabot>   8
07:43:54 <portnov> :)
07:46:12 <fasta> quicksilver: I don't see anything to rotate matrices here: http://hackage.haskell.org/packages/archive/OpenGL/2.2.1.1/doc/html/Graphics-Rendering-OpenGL-GLU-Matrix.html
07:46:33 <quicksilver> fasta: you call 'rotate'.
07:46:45 <znutar> it'll be in gl, not glu
07:46:46 <quicksilver> fasta: it implicitly multiplies the current matrix by a rotation matrix.
07:46:57 <quicksilver> it's a stateful API.
07:47:22 <fasta> quicksilver: I will just download the source, so I can at least search in it.
07:47:39 <quicksilver> I don't think it is very useful.
07:47:57 <quicksilver> (the actual multiplication is done by the opengl library so you can't see that code)
07:48:04 <quicksilver> the vectorspace package might be more useful.
07:48:53 <hugo___> how can i convert from a char8 bytestring to a lazy one ?
07:50:19 <quicksilver> hugo___: it's unusual to want to convert from strict to lazy, what are you trying to do?
07:50:22 <hugo___> i could use the lazy pack instead of the char8, but i dont know if a [Char] equals [Word8] :/
07:50:24 <fasta> quicksilver: vector space doesn't do rotations.
07:50:31 <hugo___> i want to use the lazy bytestring on strings
07:50:57 <hugo___> i have some haskell strings, that i want to use as lazy bytestrings
07:51:16 <hugo___> so i used the bytestring char8 pack function
07:51:23 <quicksilver> fasta: it's trivial to form a rotation matrix.
07:51:28 <quicksilver> hugo___: use the lazy pack function instead.
07:51:34 <hugo___> okey
07:51:50 <fasta> quicksilver: you mean in the vector spaces library? Or in general?
07:52:27 <quicksilver> fasta: in general.
07:53:05 <fasta> quicksilver: yes, in general it is (at least I can understand the derivation).
08:02:33 <zloog> is there anyway to make the =~ operator for regexes act case insensitive?
08:06:22 <quicksilver> zloog: yes.
08:06:54 <quicksilver> zloog: that's what the whole RegexOptions shenanigans is about
08:08:01 <quicksilver> e.g., in the posix backend, http://www.haskell.org/ghc/dist/current/docs/libraries/regex-posix/Text-Regex-Posix-String.html#t%3ACompOption
08:23:57 <fasta> Is there a way to see on Hackage what the exact command was to build the library? Somehow Hackage compiled something which doesn't compile here.
08:26:56 <quicksilver> fasta: as far as I know, hackage always simply compiles with cabal.
08:26:59 <quicksilver> no special options.
08:27:07 <quicksilver> The difference is likely to be library or compiler versions.
08:27:22 <dcoutts_> right
08:27:30 <Baughn> fasta: It'd probably be more convenient to solve the compilation issue. What error messages do you get?
08:27:42 <athos> hi
08:28:30 <fasta> quicksilver: right, that's what I thought too.
08:28:30 <Baughn> Welcome to the channel, young one
08:28:40 <fasta> Baughn: try cabal install blas and see how easy it is :)
08:29:06 <Baughn> fasta: Sure. Let's see..
08:29:20 <fasta> Baughn: on 6.10.1, btw
08:29:43 <Baughn> fasta: I'm still on 6.8.2, so you'll get to see that. :/
08:29:52 * Baughn hasn't done any haskell development since last OS install
08:29:59 <fasta> It probably has to do with fglasgow-exts changing meaning.
08:30:22 <fasta> That is, some flags now need the -X<foo> specified.
08:30:23 * jkff also tries to build blas and also fails
08:30:32 * Baughn succeeds
08:30:41 * fasta is not surprised
08:30:49 <chrisdone> how are the haddock documentation pages on Hackage created? is it some kind of cron job that happens once a day or w/e?
08:31:05 <quicksilver> a cabal project which uses -fglasgow-exts is broken.
08:31:06 <jkff> For me, cabal built the 'permutation' library, but then failed building blas with a message 'Couldn't find module Data.Permutation'
08:31:09 <quicksilver> IMO.
08:31:30 <jkff> Ahh, no wonder, the module is called Data.Permute now.
08:31:35 <fasta> jkff: I already solved that, by removing permutation-0.3 and installing permutation 0. 1
08:31:45 <fasta> 0.1*
08:31:46 <Baughn> jkff: Yeah, incorrect version restrictions
08:31:53 <jkff> Yep
08:32:06 <fasta> It is so easy to depend on a future library.
08:32:19 <opqdonut> :)
08:32:41 <chrisdone> I just uploaded this mysql version that works with the latest cabal and GHC 6.10, but when will the documentation be generated? http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsql
08:32:42 <Baughn> My cabal-install of blas didn't pull in permutation, though..
08:32:57 <chrisdone> uh, s/mysql/hsql
08:33:07 <fasta> Baughn: are you sure you don't already have it?
08:33:15 <quicksilver> chrisdone: there is some kind of cron job, yes, I don't know the details.
08:33:22 <Baughn> fasta: Positive
08:33:33 <chrisdone> quicksilver: ah
08:33:34 <jkff> Ehhhh, does cabal *not* have 'cabal remove'?
08:33:34 <fasta> Baughn: then maybe there is some ifdef somewhere.
08:33:36 <Baughn> fasta: Maybe the 6.8 version of blas doesn't use it..?
08:33:48 <toki> can someone give me erlang vs haskell pros and cons :-)
08:33:49 <Baughn> jkff: Yes
08:33:52 <toki> i'd be gratefull to hear them :p
08:33:52 <fasta> jkff: no, patches welcome says dcoutts.
08:33:55 <quicksilver> jkff: ghc-pkg unregister
08:34:09 <jkff> quicksilver: Thanks
08:35:17 * jkff now failed building blas with a bunch of compiler errors
08:35:25 <chrisdone> also exported the whole SqlBind class so that one can implement fromSqlValue for their own types, which is nice
08:35:31 <jkff> Some stuff about fundeps
08:36:13 <dcoutts_> chrisdone: I expect it will not since the build box probably does not have mysql installed
08:36:46 <dcoutts_> jkff: seriously, patches for tracking installed files most welcome :-)
08:36:47 <harovali> what is the <- operator ?
08:37:03 <vixey> that's not an operator
08:37:19 <rwbarton> harovali: It's not an operator, it's part of do syntax
08:37:22 <vixey> secretly <- turns into >>=
08:37:33 <rbe> hi folks
08:37:34 <vixey> like   x <- m ; foo  turns into  m >>= \x -> foo
08:37:44 <harovali> vixey: rwbarton: ah thanks
08:37:50 <vixey> hi rbe
08:37:55 <rbe> got a question...
08:37:59 <rbe> how to turn a list of int [1,2,3] into "123" efficiently?
08:38:11 <quicksilver> rbe: concatMap show
08:38:31 <vixey> :t toDigit
08:38:32 <chrisdone> dcoutts_: wait. what will not what because it doesn't have mysql installed?
08:38:32 <lambdabot> Not in scope: `toDigit'
08:38:57 <vixey> > map (chr . (ord '0' +)) [1..3]
08:38:58 <BONUS> :t intToDigit
08:38:59 <chrisdone> dcoutts_: oh, I see. it doesn't have libmysqclient?
08:38:59 <lambdabot>   "123"
08:38:59 <lambdabot> Int -> Char
08:39:03 <dcoutts_> chrisdone: I thought your package was a binding to mysql
08:39:06 <rbe> quicksilver: thx
08:39:08 <vixey> @src intToDigit
08:39:08 <lambdabot> Source not found. My brain just exploded
08:39:09 <fasta> jkff: that's what I see here too.
08:39:10 <BONUS> > map intToDigit [1,2,3]
08:39:11 <lambdabot>   "123"
08:39:24 <dcoutts_> chrisdone: right, the current build box has very few C libs
08:39:26 <BONUS> intToDigit works only on the range of 0 to F
08:39:26 <chrisdone> dcoutts_: yes, sorry, it is. you mean it will fail to build there for haddock?
08:39:35 <paper_cc> > map intToDigit [1,16]
08:39:36 <lambdabot>   "1* Exception: Char.intToDigit: not a digit 16
08:39:37 <chrisdone> let me view the old version package entry
08:39:40 <dcoutts_> chrisdone: I think it only builds the docs if the build worked
08:39:44 <rbe> bonus: i read about intToDigit just being used for int = 0..15? or am i wrong?
08:39:52 <BONUS> yeah it is
08:39:56 <paper_cc> > concatMap show [1,16]
08:39:56 <BONUS> so it depends on your needs i guess
08:39:58 <lambdabot>   "116"
08:39:59 <rampkitten> If I have regex-posix installed from cabal, how can I get its profiling libraries?
08:40:10 <chrisdone> dcoutts_: the old version of hsql has documentation, from ghc6.6, heh
08:40:14 <dcoutts_> rampkitten: cabal install --reinstall regex-posix -p
08:40:23 <dcoutts_> chrisdone: ok, well maybe it'll work then
08:40:26 <rampkitten> dcoutts: thx
08:40:39 <chrisdone> =)
08:40:46 <dcoutts_> rampkitten: though you may need to do that for the deps of regex-posix too, like regex-base etc
08:41:17 <chrisdone> the ghc6.8 and 6.10 failures are actually cabal failures with missing old-time (a common old-package error)
08:41:25 <rampkitten> dcoutts: Yea, just needed to know the general form of things thanks
08:41:27 <dcoutts_> chrisdone: yet another reason for not using a single dedicated build box, but having users report results via cabal-install
08:42:44 <chrisdone> dcoutts_: interesting idea, seems fair enough, too. upload build log along with the package?
08:42:46 <rbe> is there a function to "map every 2 elemtents of a list against a function"... like map \x y [1,2,2,3,4,5]?
08:43:20 <vixey> rbe, doesn't parse
08:43:20 <rwbarton> rbe: Probably, what do you mean by "every 2 elemtents"?
08:43:22 <quicksilver> rbe: no, you have to group it into every 2 elements first.
08:43:28 <quicksilver> and there are at least two ways to interpret that ;)
08:43:30 <rbe> yes
08:44:01 <rbe> problem is: remove every element, that is equal to its previous element...
08:44:17 <vixey> rbe, you should use foldr instead of map
08:44:24 <rbe> so [1,2,2,3,4,5,2] should become [1,2,3,4,5,2]
08:44:38 <rwbarton> > map head . group $ [1,2,2,3,4,5,2]
08:44:39 <lambdabot>   [1,2,3,4,5,2]
08:44:45 <dcoutts_> chrisdone: yes, we've implemented it for the new hackage server
08:44:54 <rbe> can i call foldr with 2 parameters?
08:45:02 <rbe> rwbarton: looks good
08:45:03 <vixey> rbe, yes
08:45:13 <chrisdone> dcoutts_: yay!
08:45:32 <vixey> rbe, it will be like:   foldr (\x ys -> _) []
08:45:40 <vixey> but I will let you figure out the _ if you want
08:45:58 <rbe> vixey, thx
08:47:21 <chrisdone> > let l = [1,2,2,3,4,5,2] in map fst . filter (liftM2 (/=) fst snd) $ zip l $ tail l
08:47:23 <lambdabot>   [1,2,3,4,5]
08:47:32 <chrisdone> I hate that this was the solution I thought of :p
08:48:19 <rwbarton> @pl liftM2 f fst snd
08:48:20 <lambdabot> liftM2 f fst snd
08:48:27 <rwbarton> :t liftM2 ?f fst snd
08:48:28 <lambdabot> forall r a b. (?f::a -> b -> r) => (a, b) -> r
08:48:34 <rwbarton> :t uncurry ?f
08:48:35 <lambdabot> forall a b c. (?f::a -> b -> c) => (a, b) -> c
08:48:43 <chrisdone> oh, duh
08:49:00 <rwbarton> Well, @pl can't figure it out
08:49:10 <chrisdone> I always forget about uncurry
08:49:27 <rwbarton> @pl \x -> f (fst x) (snd x)
08:49:27 <lambdabot> uncurry f
08:50:19 <chrisdone> > (==) <$> fst <*> snd $ (1,2)
08:50:20 <lambdabot>   False
08:50:24 <chrisdone> oh man I can't believe that worked
08:50:29 <chrisdone> Applicative<33
08:50:41 <saml> > (+) <$> 1 2
08:50:42 <lambdabot>       No instance for (Show (f (a -> a)))
08:50:42 <lambdabot>        arising from a use of `show'...
08:50:53 <saml> > (+) <$> 1 <$> 2
08:50:54 <lambdabot>       No instance for (Show (f (a -> a)))
08:50:54 <lambdabot>        arising from a use of `show'...
08:51:04 <chrisdone> (,) isn't a a functor on both parts of the tuple
08:51:28 <BONUS> > (+) <$> Just 3 <*> Just 4
08:51:29 <chrisdone> (,) a' is a functor, right?
08:51:29 <lambdabot>   Just 7
08:51:33 <chrisdone> s/'//
08:51:34 <BONUS> yeah
08:51:37 <roconnor> > (+1) . ("Hello", 2)
08:51:38 <lambdabot>   Couldn't match expected type `a -> b'
08:51:46 <roconnor> > (+1) . (2,"Hello")
08:51:47 <lambdabot>   Couldn't match expected type `a -> b'
08:51:55 <roconnor> > (+1) `fmap` ("Hello", 2)
08:51:55 <beelsebob> > Just 3 <^(+)^> Just 4
08:51:57 <lambdabot>   Not in scope: `<^'Not in scope: `^>'
08:51:57 <lambdabot>   ("Hello",3)
08:51:58 <beelsebob> :(
08:51:59 <chrisdone> :t (.)
08:52:00 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:52:04 <chrisdone> yay caleskell? aw
08:52:10 <chrisdone> ;_;
08:52:15 <roconnor> rejoice!!
08:52:24 <beelsebob> @def (<^) x f = fmap f x
08:52:24 <lambdabot> Maybe you meant: bf let
08:52:31 <beelsebob> @let (<^) x f = fmap f x
08:52:31 <chrisdone> v_v
08:52:33 <lambdabot>  Defined.
08:52:42 <beelsebob> @let (^>) a x = a <*> x
08:52:43 <lambdabot>  Defined.
08:52:45 <beelsebob> better :)
08:52:49 <beelsebob> > Just 3 <^(+)^> Just 4
08:52:50 <lambdabot>   Just 7
08:53:14 <asgaroth> Is there any version of the ghc docs available that includes the "|source" links like the docs for 6.8.2 did?
08:53:29 <chrisdone> it should've been fst <*> snd from day one, never uncurry! it breaks the abstraction, like State's `gets'
08:53:35 <chrisdone> don't you agree, quicksilver? :P
08:53:49 <asgaroth> (for downloading)
08:53:52 <harovali> is the letter a something special ?
08:57:35 <byorgey> harovali: no.  lowercase letters are often used as type variables, and  a  is used a lot since it's the first letter
08:57:41 <byorgey> assuming that's what you're referring to.
08:57:43 <pascal___> i always get the " Class `Exception' used as a type
08:57:50 <pascal___> error while installing quickcheck
08:58:04 <byorgey> but the type   a -> a   is the same as   b -> b   or  k -> k  or    flerg -> flerg
08:58:48 <quicksilver> pascal___: that's a symptom of trying to install something which is not 6.10 compatible against 6.10
08:58:52 <quicksilver> (or occasionally the reverse)
08:58:53 <rwbarton> pascal___: Sounds like a ghc 6.8 vs 6.10 issue.  What version of quickcheck are you installing, and how?
08:59:20 <pascal___> ive tried to install every 2.x version with ghc6.10
08:59:49 <vixey> hi byorgey
08:59:55 <byorgey> hi vixey
09:00:04 <chessguy_work> @seen wchogg
09:00:05 <lambdabot> Last time I saw wchogg was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #ghc, #
09:00:05 <lambdabot> haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #
09:00:05 <lambdabot> haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosxdev, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 12d 20h 6m 48s ago, and .
09:00:05 <vixey> how is it going?
09:00:20 <saml> i'm good
09:00:56 <byorgey> vixey: pretty good, I'm excited for the semester to start =)
09:01:03 <byorgey> how about you?
09:01:20 <vincenz> byorgey: grad?
09:01:26 <byorgey> yeah
09:01:34 <chessguy_work> hey byorgey : it would be cool to hear about the new PCI porting effort in HWN
09:01:46 <byorgey> PCI porting effort?
09:02:06 <chessguy_work> http://groups.google.com/group/pci-in-haskell
09:02:31 <chessguy_work> there's been a mention or two on -cafe i think
09:02:42 <rwbarton> pascal___: I just installed quickcheck 2.1.0.1 on a recent ghc without any problems, so I'm not sure what's going wrong for you
09:03:02 <byorgey> chessguy_work: send me an email so I won't forget
09:03:09 <chessguy_work> k
09:03:33 <byorgey> oh, PCI = Programming Collective Intelligence
09:03:41 <byorgey> I did put that in the HWN when it was announced
09:03:57 <byorgey> but if there are more interesting things to say about what is happening currently, send me a blurb and I'll put it in
09:04:23 <rbe> vixie: like foldr (\x ys -> if length ys > 0 && x == head ys then ys else x:ys) [] [1,2,2,3,4,5,2] ???
09:04:30 <chessguy_work> oh, maybe i missed it
09:05:04 <chessguy_work> well, if you metioned it, that's probably sufficient for right now . it's still a little slow yet
09:05:09 <rbe> sorry, meant vixey
09:05:25 <chessguy_work> @vixen like foldr (\x ys -> if length ys > 0 && x == head ys then ys else x:ys) [] [1,2,2,3,4,5,2] ???
09:05:25 <lambdabot> whoa whoa whoa, one question at a time!
09:05:39 <rwbarton> pascal___: are you using cabal-install?  You may need a newer version of cabal-install
09:05:53 <pascal___> yes, i use cabal
09:05:55 <chessguy_work> like foldr (\x ys -> if length ys > 0 && x == head ys then ys else x:ys) [] [1,2,2,3,4,5,2] ?
09:05:57 <vixey> rbe, I think that is pretty good yeah
09:05:59 <chessguy_work> @vixen like foldr (\x ys -> if length ys > 0 && x == head ys then ys else x:ys) [] [1,2,2,3,4,5,2] ?
09:06:00 <lambdabot> who's to say?
09:06:05 <vixey> rbe, does it work?
09:06:05 <pascal___> ok, will try to update my cabal-install
09:06:44 <rbe> yes... but map head . group $ [1,2,2,3,4,5,2] is shorter ;)
09:06:57 <vixey> right and shorter = better
09:07:19 <rbe> nope... would be the next question: what is faster?
09:07:28 <Raevel> less is more better
09:07:37 <vixey> rbe, rather than worry about speed. I was going to suggest something else
09:07:52 <rbe> i know... and thx a lot
09:07:54 <BONUS> yeah, dont worry about speed yet :]
09:07:54 <vixey> you could write it like:
09:08:03 <BONUS> just write what's more elegant
09:08:11 <chessguy_work> > map head . group $ [1,2,2,3,4,5,2]
09:08:12 <vixey> removeAdjacents = foldr (\x ys -> ... what you wrote above ...) []
09:08:12 <lambdabot>   [1,2,3,4,5,2]
09:08:25 <chessguy_work> > nub [1,2,2,3,4,5,2]
09:08:29 <vixey> rbe, but my suggestion to improve it is:
09:08:33 <vixey> removeAdjacents = foldr cons []
09:08:36 <lambdabot>   [1,2,3,4,5]
09:08:40 <vixey>  where cons x ys = ... what you wrote above ...
09:08:45 <BONUS> chessguy_work: nub isnt good here
09:08:53 <BONUS> > nub [1,2,2,3,2]
09:08:54 <lambdabot>   [1,2,3]
09:08:55 <chessguy_work> oh, you want the last 2
09:09:03 <BONUS> > map head . group $ [1,2,2,3,2]
09:09:03 <vixey> rbe, and once you have done that, you can actually remove the use of 'length' by pattern matching
09:09:04 <chessguy_work> BONUS, i didn't see the original qustion
09:09:04 <lambdabot>   [1,2,3,2]
09:09:18 <BONUS> yeah he basically wants to remove adjecent elements that are the same
09:09:46 <chessguy_work> coom, i like "map head . group" then
09:09:57 <chessguy_work> s/om/ol/
09:10:07 <pk> hey
09:10:21 <pk> how is recursive do implemented ?
09:10:31 <PeakerWork> I think:
09:10:32 <vixey> pk, you mean mdo?
09:10:33 <PeakerWork> @src MonadFix
09:10:33 <lambdabot> class (Monad m) => MonadFix m where
09:10:33 <lambdabot>     mfix :: (a -> m a) -> m a
09:10:39 <pk> vixey, yes
09:10:47 <pk> I've read the MonadFix doc
09:11:11 <rwbarton> pk: in terms of mfix and tuples (possibly massive :)
09:12:00 <rbe> vixey sounds good.. and now i am interested in performance... is there a "time" in haskell?
09:12:19 <rbe> as i am implementing a string distance metric
09:12:30 <vixey> rbe, it is clear just by thinking about it that the version using foldr and not length is the most efficient out of everything suggested
09:12:46 <pk> Can you please give me a simple example ?
09:12:54 <vixey> pk, of?
09:13:14 * rwbarton will try
09:13:24 <rbe> vixey, so using group is inefficient?
09:13:27 <pascal___> ive updated my cabal and im getting the same error message
09:13:39 <dcoutts_> pascal___: cabal --version ?
09:13:53 <pk> vixey, mdo translation
09:14:09 <rwbarton> mdo { x <- f y; y <- g x; return (x+y) } --> fmap (\(x, y) -> x+y) $ mfix (\(x, y) -> do { x' <- f y; y' <- g x; return (x', y') })
09:14:11 <pascal___> 1.6.0.1
09:14:27 <pascal___> cabal-install 0.6.0
09:14:32 <chessguy_work> rbe, check this out: http://haskell.org/haskellwiki/Timing_computations
09:14:41 <chessguy_work> (i think that's what you're asking for)
09:14:52 <rwbarton> rbe: using group should be only a constant factor slower
09:14:54 <Raynes> > reverse [1, 2, 3, 4, 5] !! 1
09:14:55 <lambdabot>   4
09:14:56 <rbe> thx chessguy
09:14:56 <dcoutts_> pascal___: ok, and you were installing quickcheck-1.x and it's building it against base-4 ?
09:15:05 <pk> rwbarton, thx
09:15:31 <tibbetts> How do I run ghci such that it has access to all the cabal libraries installed in ~/.cabal? is there a shortcut, or should I  build a shell launcher?
09:16:26 <quicksilver> tibbetts: you don't need to do anything.
09:16:36 <dcoutts_> tibbetts: it does automatically
09:16:47 <pascal___> i didnt install any version... i got another error at version 1.x. at least i want to install 2.x
09:16:49 <dcoutts_> tibbetts: ghc-pkg list shows all the installed packages, global and user
09:17:05 <dcoutts_> pascal___: ok, cabal install 'quickcheck >= 2'
09:18:13 <rwbarton> tibbetts: You'll have to :m +Module.Name.Here for each module you want to import
09:18:33 <tibbetts> Ah, it works much better when I spell the package name right.
09:18:34 <rwbarton> tibbetts: (or use qualified names)
09:18:55 <tibbetts> Yes, it does work automatically. My bad.
09:22:26 <pascal___> now hes trying to download quickcheck-2.1.0.1 but it seems to take forever
09:22:30 <rbe> hm... all my computations give a time of "0.000 msec" ... :-D
09:22:47 <vixey> rbe, well that is wonderful
09:22:55 <rbe> need to go into more "timing detail" ;)
09:22:57 <vixey> rbe, I don't think that an algorithm can be faster than 0
09:23:03 <rbe> yes sure
09:23:31 <rbe> in the code from the url given by chessguy, time will be computed / (10^12)
09:23:46 <rbe> and formatted %0.3f
09:23:57 <flux> but when your infinite loops go in 0.000 msec, you may want to consider if laziness is doing something there :)
09:24:20 <mmorrow> re mdo: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.6.5172
09:24:32 <rbe> Computation time: 0.000000000000 sec
09:24:33 <mmorrow> i've started to like mdo
09:24:47 <roconnor> mdo++
09:24:49 <mmorrow> i wish it was the default
09:24:54 <mmorrow> do := mdo
09:25:01 <rbe> how fine grained is getCPUTime?
09:25:07 <roconnor> mmorrow: I don't think I'd go that far :)
09:25:12 <flux> rhox, soo, you are not spending not even one cycle in the calcluation?
09:25:22 <flux> s/not//2
09:25:30 <roconnor> with mdo you can't shadow names IIRC
09:25:45 <rwbarton> I found a really interesting example where mdo subtly failed to solve a problem I had
09:26:28 <rbe> i am computing Jaro-Winkler string distance metric; and a thing named "KÃ¶lner Verfahren" for computing codes for german language strings
09:26:46 * loadquo finally made a foldr based eratosthenes sieve, now to do some benchmarking
09:26:48 <Saizan> is there a script or something to apply hlint suggestions automatically?
09:27:02 <PeakerWork> roconnor, mmorrow: When do you use mdo?  I haven't seen example useful cases yet
09:27:09 <PeakerWork> (Not saying there aren't any, just wondering...)
09:27:27 <rhox> flux: did i miss something or why did you highlight me?
09:27:28 <vixey> you have done tieing the knot in pure code?
09:27:32 <mmorrow> PeakerWork: when do you use a recursive let?
09:27:36 <rwbarton> mmorrow: (See, now aren't you glad mdo isn't the default so you can answer this question)
09:27:41 <PeakerWork> mmorrow: Rarely, I think
09:27:49 <vixey> tying
09:27:57 <mmorrow> PeakerWork: do you wish letrec wasn't the default for let?
09:28:09 <flux> rhox, oh, that was for rbe :)
09:28:15 <PeakerWork> mmorrow: nope, letrec is great :)
09:28:16 <rbe> ah ;)
09:28:22 <PeakerWork> mmorrow: I am not saying mdo is bad, I am just wondering about example uses
09:28:26 <rbe> thats what i am trying to find out ;)
09:28:41 <rbe> so, how fine grained is getCPUTimeÃŸ
09:28:42 <rbe> ?
09:28:50 <rhox> flux: ahh ok, and i thought propably somebody is flaming me because i am only ideling around :P
09:29:16 <BMeph> loadquo: Are you gonna put it on hpaste if it works? Or if it doesn't work? :)
09:29:25 <Martijn> @pl \(ts, f) (ts', v) -> (ts ++ ts', f v))
09:29:26 <lambdabot> (line 1, column 38):
09:29:26 <lambdabot> unexpected ")"
09:29:26 <lambdabot> expecting variable, "(", operator or end of input
09:29:31 <Martijn> @pl \(ts, f) (ts', v) -> (ts ++ ts', f v)
09:29:32 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .) . (++))
09:30:04 <roconnor> I wonder if there are any Z80 emulators in  hackage
09:30:45 <chessguy_work> Z80?
09:31:02 <PeakerWork> Martijn: are you the C++ guy?
09:31:39 <Martijn> PeakerWork: I've never programmed any C++ yet in my life.
09:31:47 <PeakerWork> Martijn: ah, okay :)
09:31:58 <mib_58553hml> hi
09:33:15 <rbe> I found that getCPUTime measures in picoseconds
09:33:33 <mmorrow> PeakerWork: you'd use it when you want to tie the know in monadic code
09:33:37 <rbe> so when i remove the / (10^12) from
09:33:43 <loadquo> Bmeph It works, although it doesn't like you passing in certain numbers or other things. Checking for the bad numbers would reduce the beauty of the code....
09:33:43 <rbe> arg...sorry
09:34:36 <rbe> hm... i can't get any useful result from getCPUTime
09:35:09 <mib_58553hml> which mp module should i call to get 744.000... instead of 256.000... with exp (sqrt (163) * pi) ?
09:35:22 <rbe> ah ok... getCPUTime always returns 0... any idea on that??
09:35:27 <rbe> vixey?
09:35:45 <rbe> i am on windows vista
09:35:49 <roconnor> @type getCPUTime
09:35:51 <lambdabot> Not in scope: `getCPUTime'
09:35:57 <roconnor> @hoogle getCPUTime
09:35:57 <lambdabot> System.CPUTime getCPUTime :: IO Integer
09:36:10 <roconnor> I guess vista is just that fast :P
09:36:20 <mmorrow> , [$ty| let untilST p f x = mdo k <- newSTRef (readSTRef ref >>= \x -> if p x then writeSTRef k (return()) else writeSTRef ref (f x) >> join (readSTRef k)); ref <- newSTRef x; join (readSTRef k) >> readSTRef ref in untilST |]
09:36:22 <loadquo> Foldr sieve -> http://hpaste.org/13859
09:36:25 <lunabot>  forall a b . (b -> Bool) -> (b -> b) -> b -> ST a b
09:36:41 <mmorrow> that uses k in it's own definition
09:37:02 <Martijn> mdo is cool
09:37:40 <rbe> roconnor: sure, but it always returns 0
09:37:42 <roconnor> PeakerWork: see my article on recursive do
09:37:47 <mmorrow> without mdo there, you'd have to define k as k <- newSTRef undefined, (or newSTRef (return())), then writeSTRef k (the real def)
09:37:47 <roconnor> @go assembly recursive do
09:37:48 <vixey> rbe, I already suggested not timing these things
09:37:50 <lambdabot> No Result Found.
09:38:02 <mib_58553hml> which mp module should i call to get 744.000... instead of 256.000... with exp (sqrt (163) * pi) - 640320^3 (sorry)?
09:38:04 <mmorrow> > runST
09:38:05 <lambdabot>       Overlapping instances for Show ((forall s. ST s a) -> a)
09:38:05 <lambdabot>        arising...
09:38:15 <mmorrow> @let untilST p f x = mdo k <- newSTRef (readSTRef ref >>= \x -> if p x then writeSTRef k (return()) else writeSTRef ref (f x) >> join (readSTRef k)); ref <- newSTRef x; join (readSTRef k) >> readSTRef ref
09:38:15 <lambdabot>  <local>:9:22: parse error on input `<-'
09:38:17 <roconnor> @go monad reader recursive do
09:38:19 <mmorrow> ah
09:38:21 <lambdabot> http://www.haskell.org/sitewiki/images/1/14/TMR-Issue6.pdf
09:38:21 <lambdabot> Title: The Monad.Reader Issue 6
09:38:23 <rwbarton> > (exp (sqrt (163) * pi) - 640320^3) :: CReal
09:38:24 <lambdabot>   743.9999999999992500725971981856888793538563
09:38:27 <roconnor> PeakerWork: in there
09:38:35 <mib_58553hml> thanks
09:38:41 <rbe> vixey: sorry missed that.. but btw do you know why getCPUTime always returns 0?
09:38:48 <rwbarton> mib_58553hml: in the 'numbers' package on hackage
09:39:24 <mmorrow> @let untilST p f x = do ref <- newSTRef x; k <- newSTRef undefined; k <- writeSTRef k (readSTRef ref >>= \x -> if p x then writeSTRef k (return()) else writeSTRef ref (f x) >> join (readSTRef k)); join (readSTRef k) >> readSTRef ref
09:39:25 <lambdabot>  Couldn't match expected type `STRef s a' against inferred type `()'
09:39:29 <mmorrow> grr
09:39:32 <PeakerWork> roconnor: ok, thanks
09:39:53 * mmorrow quits
09:41:37 <mib_58553hml> rwbarton : thanks
09:42:01 <mmorrow> @let untilST p f x = do ref <- newSTRef x; k <- newSTRef undefined; writeSTRef k (readSTRef ref >>= \x -> if p x then writeSTRef k (return()) else writeSTRef ref (f x) >> join (readSTRef k)); join (readSTRef k) >> readSTRef ref
09:42:03 <lambdabot>  Defined.
09:42:26 <rbe> vixey: how to replace length by pattern matching?
09:42:52 <mmorrow> @let newton f f' t x = snd (runST (untilST (\(x,y)->abs(x-y) < t) (\(_,x)->(x,x-(f x/f' x))) (x+t,x)))
09:42:54 <lambdabot>  Defined.
09:42:57 <rwbarton> mmorrow: here is the weird thing with mdo I was talking about: http://hpaste.org/13860
09:42:58 <vixey> rbe, well why don't you paste the foldr version with the where clause first of all
09:43:07 <mmorrow> @type newton
09:43:08 <lambdabot> forall a. (Fractional a, Ord a) => (a -> a) -> (a -> a) -> a -> a -> a
09:43:11 * mmorrow looks
09:43:12 <rwbarton> mmorrow: solve2 = _|_
09:44:08 <rwbarton> mmorrow: I think it can be fixed by using a different monad for nondeterminism
09:44:45 <mmorrow> , fix (\l -> 0 : [ filter (<= 2) [l !! i, l !! i + 1] | i <- [0..3]])
09:44:47 <lunabot>  luna: Occurs check: cannot construct the infinite type: a = [a]
09:45:06 <rwbarton> , mfix (\l -> 0 : [ filter (<= 2) [l !! i, l !! i + 1] | i <- [0..3]])
09:45:08 <lunabot>  luna: No instance for (GHC.Num.Num [a])
09:45:13 <rwbarton> ah
09:45:26 <mmorrow> i think solve1 and solve2 aren't equibv
09:45:29 <mmorrow> *equiv
09:45:37 <roconnor> @where TTFP
09:45:38 <lambdabot> I know nothing about ttfp.
09:45:50 <mmorrow> oh, oop
09:46:05 <mmorrow> @type fix (\l -> [0] : [ filter (<= 2) [l !! i, l !! i + 1] | i <- [0..3]])
09:46:06 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
09:46:06 <lambdabot>       Expected type: [a]
09:46:06 <lambdabot>       Inferred type: [[a]]
09:46:16 <roconnor> @where+ TTFP http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
09:46:17 <lambdabot> Good to know.
09:46:20 <roconnor> @where TTFP
09:46:21 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
09:48:12 <mmorrow> @type fix (\l -> concatMap (\l -> sequence ([0] : [ filter (<= 2) [l !! i, l !! i + 1] | i <- [0..3]])) l)
09:48:13 <lambdabot> forall a. (Ord a, Num a) => [[a]]
09:48:18 <mmorrow> > fix (\l -> concatMap (\l -> sequence ([0] : [ filter (<= 2) [l !! i, l !! i + 1] | i <- [0..3]])) l)
09:48:34 <lambdabot>   thread killed
09:49:39 <mmorrow> > newton cos (negate . sin) 0.001 (pi/4)
09:49:41 <lambdabot>   1.5707963267948966
09:50:46 <dpratt71> newbie question: lunabot and lambdabot seem to serve a similar purpose. What's the difference?
09:51:08 <mmorrow> lunabot has template-haskell stuff and some different imports
09:51:18 <mmorrow> and a nested `eval' function
09:51:26 <mmorrow> , eval "eval \"42\""
09:51:31 <lunabot>  <<Dynamic>>
09:51:34 <pao> hi, how do I input a Word8 literal in my program?
09:51:40 <mmorrow> , [|\x -> x|]
09:51:42 <lunabot>  LamE [VarP x_0] (VarE x_0)
09:51:55 <mmorrow> , [d|data A a = A a | B a a deriving (Show)|]
09:51:57 <lunabot>  DataD [] A [a_0] [NormalC A [(NotStrict,VarT a_0)],NormalC B [(NotStrict,...
09:52:10 <dons> pao: do x <- getChar ; let w = fromIntegral (ord x)
09:52:11 <dpratt71> ok, thanks
09:52:17 <mmorrow> :)
09:53:06 <pao> dons: thanks!
09:53:29 <gbacon> how should I install ghc-6.10 so as to stay out of the way of future apt updates?
09:53:41 <gbacon> or is that not a worthwhile consideration?
09:55:53 <mmorrow> rwbarton: i think mdo is equivalent to do if no var is used in the rhs of its definition
09:56:18 <dons> gbacon: use standard libraries?
09:56:27 <dons> use only haskell98 libraries?
09:56:41 <pao> @src fromIntegral
09:56:42 <lambdabot> fromIntegral = fromInteger . toInteger
09:57:10 <rwbarton> gbacon: by default it will install into /usr/local and I've found it's easy to choose which I want by manipulating my PATH
09:58:00 <gbacon> rwbarton: do you install both, or would it be better to detach completely from apt with regard to ghc?
10:00:05 <rwbarton> gbacon: I just left the old one installed, in case it comes in handy
10:00:18 <BMeph> luqui: ping
10:00:38 <gbacon> rwbarton: ok, thanks
10:01:16 <pao> > ( fromIntegral . ord $ 'a' ) :: Word8
10:01:17 <lambdabot>   97
10:02:11 <BMeph> Has anyone on looked at Escardo's "searching infinite sets" stuff? :)
10:02:41 <mmorrow> BMeph: i printed that out and looked over it briefly. looks cool
10:02:59 <dolio> I've skimmed it.
10:04:32 <Baughn> I've.. gotten head-butted by it
10:04:43 <rwbarton> I tried out the some of the algorithms in that blog post, they really do work :)
10:04:58 <Baughn> It's doing a lot of things I have no background in; I think it'd take a while to figure out. :/
10:07:05 <rwbarton> there's something magical about writing f (False:False:True:False:True:True:True:_) = True; f _ = False and getting that string of Falses and Trues back out in quadratic time or so
10:07:22 <mmorrow> heh
10:17:06 <Voltaplein> Hi -- Newbie question.  I start an interactive session, type a:: (Num a) => a -> Num and get the error <interactive>:1:0: Not in scope: `a'
10:17:19 <Voltaplein> What am I missing and how do I correct it?
10:17:57 <byorgey> Voltaplein: what are you trying to do?
10:18:05 <chessguy_work> Voltaplein, you need to actually define a -- you only declared its type
10:18:06 <dons> gwern: you like games, right? http://www24.brinkster.com/srineet/para/para.html
10:18:28 <Baughn> Voltaplein: The "let". The ghci prompt is effectively in the IO monad; let-less binding only works at the top level of actual files
10:18:29 <chessguy_work> Voltaplein, try a = 4 :: (Num a) => a -> Num
10:18:46 <chessguy_work> err, yeah, with a 'let'
10:18:51 <Baughn> Voltaplein: Also, you can't define the type and later the value; you have to do both at once
10:19:05 <Voltaplein> byorgey: I'm trying out some examples from a tutorial.
10:19:10 <Baughn> Really, it's easier to use :r(eload). ;)
10:19:25 <Baughn> Voltaplein: Those were almost certainly meant to be used in a .hs file
10:19:56 <Baughn> Voltaplein: So you can stick them there with an editor, :l(oad) the file in ghci, and then :r(eload) it when you've made changes..
10:20:13 <Voltaplein> The examples are in http://learnyouahaskell.com/higher-order-functions#maps-and-filters
10:20:39 <Voltaplein> There is one called multhree near the top of the page
10:21:17 <byorgey> Voltaplein: yeah, I would put the examples in a .hs file  and then :load them in ghci
10:21:33 <byorgey> you can't do everything in ghci that you can do in a file
10:21:42 <byorgey> and the syntax is diferent anyway
10:21:50 <Voltaplein> Baughn let a:: (Num a) => a -> Num throws the same error
10:22:00 <byorgey> you can put declarations in a file, but only expressions at the ghci prompt.
10:22:08 <trullaPew> is it possible to let ghci show the number of operations needed, instead of the time consumed by a function (when i use ":s +s")
10:22:09 <Voltaplein> byorgey: oic  Thanks!
10:22:17 <trullaPew> +?
10:22:46 <byorgey> trullaPew: no.  the number of operations is not very well-defined anyway, not after the optimizer is done with your code =)
10:22:56 <trullaPew> mhmm
10:23:11 <Baughn> Voltaplein: For ghci, you'd have to say "let a :: (Num a) => a -> a; a = (+2)" or something
10:23:18 <Baughn> Voltaplein: Both type and value in one
10:23:30 <byorgey> trullaPew: why do you want to see the number of reduction steps?  just for educational purposes?
10:23:34 <dons> what's new, lambda fiends?
10:24:00 <trullaPew> yes, for education
10:24:50 <trullaPew> ï»¿well i try to test two implementations of the same algorithm, and hugs tells me, one of them is "much" faster (in 'steps'), but in ghci this one seems to consume more time :-/
10:24:59 <byorgey> trullaPew: hmm, I seem to recall someone recently posting a link to an applet that showed reduction steps in various lambda calculi
10:25:31 <Baughn> trullaPew: Run ghci with -fobject-code -O2 (eg. ghci -fobject-code -O2); that'll produce more meaningful results than the interpreter
10:25:57 <byorgey> trullaPew: well, the 'number of steps' is not a very meaningful metric for measuring run time -- it would be only if no optimizations were applied.
10:25:58 <Saizan> ooh, there's a -fobject-code :O
10:26:00 <maltem> The last time that someone asked about how to get the number or reductions used, it was proposed to just ask Cale to do the reductions by hand
10:26:28 <byorgey> trullaPew: note that compiling your code with ghc -O2 and running the generated executable is also likely to have very different results than running something in ghci
10:26:28 <trullaPew> Baughn: thx. ill try
10:26:33 <Saizan> that usually works for folds :)
10:26:49 <trullaPew> mhmm, i see
10:28:18 <trullaPew> thx guys :)
10:31:30 <dons> dcoutts_: re. specialised map: ghc turns it into build/foldd
10:31:36 <chessguy_work> dons, heh. i just beat that author's high score in my first game
10:31:57 <dcoutts_> dons: but if it does not fuse it turns it back into map
10:32:35 <dons> dcoutts_: it turns it into something that can be inlined, by the looks.
10:32:53 <chessguy_work> still, fun game
10:33:07 <dons> see the example i just posted. map is definitely inlined. (or is it fusing with the list constant?)
10:33:15 <dcoutts_> dons: hmm, then either the conversion back into map is not working or I don't understand what it going on
10:33:45 <dons> 3 RuleFired 1 fold/build 1 map 1 unpack
10:33:47 <dons> huh
10:33:57 <dons> foo = map toUpper "haskell"
10:33:58 <dons> in that.
10:34:07 <dons> so "haskell" turns into a generator ?
10:34:35 <dons> -ddump-simpl-iterations
10:34:51 <dons> so first it turns map into build (foldr )
10:35:03 <dons>  unpackFoldrCString# @ b_amw "haskell"))
10:35:18 <dons> the list constant turns into a build :)
10:35:26 <dcoutts_> ah ok
10:35:58 <cognominal> where are the code source files for RHS?
10:36:09 <dcoutts_> dons: with foo cs = map toUpper cs
10:36:18 <dcoutts_> dons: I get 1 map, 1 mapList
10:36:32 <dons> yeah
10:36:33 <dons> same
10:36:36 <dons> A.foo =
10:36:36 <dons>   \ (xs_ala :: [Char]) ->
10:36:36 <dons>     map
10:36:36 <dons>       @ Char @ Char toUpper xs_ala
10:36:41 <dcoutts_> right
10:36:47 <dons> so is that a remote call to GHC.Base.map ?
10:36:55 <cognominal> dons, I added a short review of RHS on amazon.com, probably will do the same on amazon.fr
10:37:00 <dons> RHS?
10:37:03 <dons> RWH ? :)
10:37:07 <cognominal> oops
10:37:34 <dons> cool. i noticed we got a not so hot review on amazon.co.uk sadly. first non-5 star review. ah well.
10:37:37 <dcoutts_> dons: yes, you're running it through ghc-core I expect which strips off these fully qualified names
10:37:42 <dons> yeah
10:37:49 <dcoutts_> dons: so I get GHC.Base.map
10:37:58 <dcoutts_> which is what we expect
10:38:08 <dcoutts_> given the rule:
10:38:09 <dcoutts_> "mapList"   [1]  forall f.      foldr (mapFB (:) f) []  = map f
10:38:10 <dons> yep
10:38:30 <dcoutts_> the answer is to change the definition of map, as we've done for the folds
10:39:01 <dons> yep
10:39:03 <cognominal> dons, where is the source for the code in RWH?
10:39:25 <BONUS> dons: did any errors in the book come to your attention after it went to print? i haven't noticed any so far
10:39:42 <dons> BONUS: there's a few. maybe 2 dozen so far.
10:40:02 <dons> dcoutts_: it feels icky to have to do manual worker/wrapper
10:40:25 <BMeph> Has anyone thought about how a declaration of commutativity of a function would work in Haskell? :)
10:40:30 <dcoutts_> dons: it's the static arg transform
10:40:41 <dons> what's the status of that in ghc ?
10:40:45 <dons> it was disabled, iirc?
10:40:49 <dcoutts_> dons: stalled last I heard
10:40:56 <dons> yeah
10:41:04 <dcoutts_> I think it's tricky to work out when it is beneficial
10:41:07 <dons> mm. maybe we should make a ticket to rewrite map, and see if that encourages someone :)
10:41:13 <dcoutts_> aye
10:41:13 <vixey> BMeph, just f * g = g * f?
10:41:35 <vixey> oh with RULES or something? I have no idea
10:41:36 <dons> i note we didn't do that transform in the list-fusion lib
10:41:46 <dcoutts_> dons: on the other hand, is there actually any performance improvement from an inlined map?
10:42:07 <dons> it should be able to specialise it
10:42:16 <dons> but not sure if that helps any..
10:42:22 <dons> let's see..
10:42:44 <dcoutts_> the fact that it's a known function rather than an unknown one might help a little bit
10:42:58 <dcoutts_> but I expect the effect is pretty minor
10:46:00 <chrisdone> ah, brilliant. the documentation for the pckage has been built
10:46:14 <chrisdone> t'was only a couple of hours ago
10:48:06 <pejo> dons/dcoutts, known function call + no need to pass a function around (less gc?) should help for microbenchmarks.
10:48:07 <BMeph> vixey: Well, AFAIK, there is no official way to do it in such a way that it's enforced.
10:48:12 <BMeph> vixey: I was just wondering if one of the many language creators here had a form for it that would work with Haskell.
10:49:09 <dcoutts_> pejo: passing a function is pretty cheap, there's no gc difference I think. It's just the difference in code to set up a call to a known address (and possibly to be able to call the fast rather than the generic entry point)
10:49:21 <BMeph> vixey: Syntactically work, I guess.
10:50:04 <dcoutts_> pejo: and the branch prediction is better, jumping through a function pointer is a tad slower, but yes this is probably really only noticable in microbenchmarks.
10:52:53 <BMeph> vixey: Now if any of ghc, lhc, yhc, hbc, et al., could be made to do it already, and we just come up with some sugar to make it look more "idiomatic" that'd be great, maybe even better than the "add it to Haskell''''"" option. :)
10:52:55 <pejo> dcoutts, specialisation might improve the results of other analyses too
10:54:10 <matthewp> Argh, GHCi doesn't fire up nicely after upgrading to Win7.  Need to figure out why
10:57:21 <chrisdone> Win7?
10:58:45 <matthewp> Windows 7
10:59:15 <dolio> BMeph: I don't see how you could prove such a thing without something like ESC/Haskell.
10:59:42 <dolio> Or Catch, if ndm ever extends it to wider varieties of static checking like he wants to.
10:59:58 * sw17ch thinks he needs to stop writing things in haskell so that his C becomes more bearable
11:01:02 * byorgey thinks he needs to stop eating gourmet food so he doesn't grimace while eating stale, moldy bread
11:01:36 <sw17ch> byorgey: that was the sort of comparison i was shooting for :P
11:07:57 <sw17ch> are there any Open Source examples of Haskell being used to make a DSL?
11:08:39 <ziman> Parsec, for example?
11:09:15 <sw17ch> ziman: i guess that does work. i'm trying to get a better understanding of what qualifies as a DSL
11:09:42 <byorgey> sw17ch: you can think of xmonad as a DSL for constructing window managers
11:10:04 <sw17ch> what about a DSL for generating C code on a microcontroller? :)
11:10:34 <byorgey> that sort of thing must exist.  I've seen DSLs for generating assembly
11:10:43 <byorgey> like harpy, or the LLVM package(s)
11:10:46 <dcoutts_> sw17ch: there's the Language.C lib but it's got no nice dsl yet
11:10:47 <sw17ch> well, there's the LLVM stuff
11:11:11 <sw17ch> dcoutts_: of course! i wonder what a DSL for that would look like...
11:11:25 <dcoutts_> sw17ch: much like C I expect ;-)
11:11:27 * sw17ch wants to try and make a project that generates C for an ARM cpu
11:12:09 <dcoutts_> sw17ch: have you read augustss's blog posts on these kind of two-level languages / EDSLs?
11:12:21 <dcoutts_> I imagine one of those would be easy to adapt to generate C
11:12:25 <sw17ch> i don't think so--link?
11:13:01 <dcoutts_> sw17ch: see his blog, there was also a paper presented at one of the FITA sessions
11:14:17 * sw17ch wonders about a DSL for thread...
11:14:21 <sw17ch> ing
11:22:16 <olsner> sw17ch: generate portable C and you get C for ARM for free :)
11:23:03 <sw17ch> olsner: of course :)
11:23:05 <dons> harpy and the llvm are kinda dsls for generating assembly.
11:23:33 <sw17ch> dons: yeah, i'd been considering them, but i think i want something above that yet
11:23:42 <dons> so some layer over Language.C maybe
11:24:09 * vixey has allergic reaction to hip stuff like "DSLs" but I still don't see what is gets the status DSL and what is only "data"
11:24:17 <BMeph> dons: Maybe augustss can look at it, when he's not gallivanting across the globe... ;)
11:24:23 <dons> if the api defines control structures?
11:24:27 <dons> or a custom monad ?
11:24:41 <dons> if it has domain specific variables, and so it looks like a small language.
11:25:09 <dons> the term is overused, but sometimes you really are programming in DS language
11:25:19 <sw17ch> hypothetically, lets write a DSL on top of language.c that will run on an m68k cpu. the application is to control christmas lights
11:25:44 <dons> ok. so you generate custom C from a Haskell program.
11:26:03 <dons> it would be a good idea to work out what you're abstracting out?
11:26:09 <dons> memory management? data types?
11:26:29 <sw17ch> my initial thought would be to boil down the fewest operations i'd need to make things "go"
11:26:34 <sw17ch> so, IO, state, and timing
11:27:26 <sw17ch> generalize a state machine that jumps based on the board's GPIO pins
11:27:41 <sw17ch> but avoid having to write any C my self outside of the basic operations :)
11:29:15 <dons> 2009 haskell goals: add your ideas: http://www.reddit.com/r/haskell_proposals/comments/7p720/haskell_library_and_community_goals_for_2009_add/
11:31:00 <Eelis> don't let Haskell be beaten by C++ in terms of standard publication frequency!
11:32:08 <sw17ch> heh, what is the chance of a Haskell 2009 standard
11:32:11 <dons> well, i think the academics can handle their side of things, but more in terms of the open source and industrial community
11:32:12 <sw17ch> (or, perhaps Haskell 2010)
11:32:21 <davidL> dons: do you use Z3 at galois?
11:32:55 <dons> mm. I don't think so. we tend to write our own.
11:41:43 <pejo> sw17ch, have you seen the work by Geoffrey Mainland?
11:42:04 <BMeph> 2010: A Haskell Odyssey
11:42:06 <BMeph> :)
11:42:08 <dons> oh, is that the cell processor DSL?
11:42:32 <dons> http://www.cas.mcmaster.ca/~kahl/Publications/TR/Anand-Kahl-2007a_DSL/
11:43:37 <Botje> yaaaaaaaaaaaaaaaaaaaaaaay
11:43:41 <Botje> i'm done with papers !
11:45:54 <BMeph> Botje: Great! So, what did you write? ;)
11:46:10 <Botje> crap, crap and reheated crap :p
11:47:09 <olsner> faeces or thesis? :P
11:47:25 <newsham> do you have a feces advisor?
11:49:06 <olsner> hmm, this is where I consider writing a redirector service with search-replace to be able to construct funny links at will
11:49:35 <newsham> botje: were you able to Pile it Higher and Deeper than those before you?
11:50:14 * loadquo thinks his foldr sieve was a false sieve
11:50:44 <harovali1> what is meant by "a becoming monadic" or "a loosing one layer of monadic nature" ?
11:50:52 <harovali1> losing
11:50:57 * roconnor is almost done his thesis
11:51:08 <newsham> congrats
11:51:20 <roconnor> I'm hesitant to give it to people to look at, because if they tell me problems, then I have to correct them.
11:51:23 <dons> harovali1: mm. a computation is lifted into a monadic environment
11:51:36 <roconnor> ... I had a similar problem when writing programs for my concurrency class.
11:51:42 * BMeph thinks loadquo should put it on hpaste... ;)
11:51:47 <newsham> roconnor: thing there's higher odds that someone outside your review board will find em?
11:51:47 <roconnor> I didn't want to test my code for fear of finding bugs
11:51:58 <roconnor> ya, I know
11:51:59 <roconnor> :)
11:52:00 <newsham> s/thing/think/
11:52:15 <mattam> roconnor: come on, it'll be fun !
11:52:31 <roconnor> mattam: heh.  I fully intend to give you a copy
11:52:36 <newsham> what's your subject?
11:52:51 <Eelis> roconnor: serves you right for choosing an exact science! should've gone with something like psychology, where basically everybody's guess about how stuff works is as good as anybody else's
11:53:06 <roconnor> newsham: I prove the incompleteness theorem in Coq and develop an efficient theory of complete metric spaces.
11:53:09 <loadquo> Bmeph, I did previously. I have a better variant now as well, using a modified variant of foldr that takes a function  [a]->[a] and applies that to the list instead of always taking the tail.
11:53:09 <BMeph> roconnor: I'm pretty sure that if anyone's going to find a problem with it, the review board is the least productive for you. ;p
11:53:18 <newsham> eelis: or operating systems ;-)
11:53:33 <chrisdone> 19:49:36 <newsham> botje: were you able to Pile it Higher and Deeper than
11:53:33 <chrisdone> those before you?
11:53:33 <chrisdone> 19:50:14 * loadquo thinks his foldr sieve was a false sieve
11:53:33 <chrisdone> 19:50:42 *** Saizan
11:53:36 <chrisdone>     (n=saizan@host70-196-dynamic.17-87-r.retail.telecomitalia.it) has
11:53:40 <chrisdone>     quit: Read error: 110 (Connection timed out)
11:53:43 <chrisdone> 19:50:44 <harovali1> what is meant by "a becoming monadic" or "a loosing one
11:53:46 <chrisdone> layer of monadic nature" ?
11:53:49 <chrisdone> 19:50:52 <harovali1> losing
11:53:52 <Botje> newsham: not really :)
11:53:52 <chrisdone> 19:50:57 * roconnor is almost done his thesis
11:53:55 <chrisdone> 19:51:09 <newsham> congrats
11:53:57 <Botje> happy to be rid of them, really
11:53:58 <harovali1> Eelis: the fact that psychology deals with very complex object definitions, doesn't imply that everyone must be right
11:53:58 <chrisdone> 19:51:21 <roconnor> I'm hesitant to give it to people to look at, because if
11:54:01 <chrisdone> they tell me problems, then I have to correct them.
11:54:03 <chrisdone> 19:51:23 <dons> harovali1: mm. a computation is lifted into a monadic
11:54:06 <chrisdone> environment
11:54:09 <chrisdone> 19:51:37 <roconnor> ... I had a similar problem when writing programs for my
11:54:13 <chrisdone> concurrency class.
11:54:16 <Eelis> harovali1: joke spoiler.
11:54:16 <chrisdone> 19:51:42 * BMeph thinks loadquo should put it on hpaste... ;)
11:54:17 <profmakx> 2wtf?
11:54:19 <chrisdone> 19:51:47 <newsham> roconnor: thing there's higher odds that someone outside
11:54:22 <chrisdone> your review board will find em?
11:54:24 * roconnor hopes chrisdone has made a cut and paste error
11:54:25 <chrisdone> <roconnor> I didn't want to test my code for fear of finding bugs
11:54:26 <olsner> oh noes, chrisdone has put his clipboard on loopback
11:54:29 <chrisdone> 19:51:58 <roconnor> ya, I know
11:54:29 <chrisdone> 19:52:00 <roconnor> :)
11:54:32 <chrisdone> 19:52:01 <newsham> s/thing/think/
11:55:10 <loadquo> Bmeph -> Both variants http://hpaste.org/13861
11:55:44 <chrisdone> sorry guys :\
11:56:02 <newsham> happens to the best of us, chris.
11:56:13 <vixey> ski_, GADT pattern match in non-rigid context for `Refl'?
11:56:17 <chrisdone> ERC's "insert log on open" uh, inserted my log >_>
11:56:23 * BMeph delves...
11:56:42 <olsner> chrisdone: sounds like a very useful command :)
11:57:22 <vixey> roconnor, more good stuff from Hancock http://www.cs.nott.ac.uk/~pgh/thesis.html
11:57:44 <ski_> vixey : heh, yes
11:58:06 <vixey> I wonder how that happened did you fix it?
11:58:22 <BMeph> loadquo: Just curious, but were you going to use that 'n' argument for something? :)
11:58:25 <vixey> I had no problems with monadic notation and matching on equality proofs
11:58:28 <roconnor> vixey: ya, I've read that
11:58:29 <roconnor> :)
11:58:42 <olsner> @src mfix IO
11:58:42 <vixey> roconnor, is it accurate?
11:58:42 <lambdabot> Source not found. I am sorry.
11:59:12 <ski_> vixey : `decide (a0 :->: a1) (b0 :->: b1) = liftM2 (\Refl Refl -> Refl) (decide a0 b0) (decide a1 b1)'
11:59:17 <loadquo> Bmeph, oops left over from when it was a recursive function itself
11:59:27 <ski_> vixey : tried writing up something rwbarton said
11:59:28 <vixey> ohh
11:59:31 <harovali1> does a mean "any type" or something like that?
11:59:51 <ski_> vixey : no, i didn't fix it .. forgot about it after server rebooted this morning
11:59:52 <vixey> I just went with  do REFL <- decide a0 b0; REFL <- decide a1 b1; return REFL
12:00:06 <ski_> vixey : and that worked ?
12:00:12 <vixey> I don't understand why your liftM2 version wouldn't work though
12:00:14 <vixey> yes this way is ok
12:00:14 <roconnor> woot, found a refrence on the logarithm/containors issue:
12:00:18 <vixey> at least GHC allows it
12:00:23 <roconnor> http://sneezy.cs.nott.ac.uk/containers/blog/?p=19
12:00:31 <ski_> (vixey : obviously i had an explicit typing on `decide' ..)
12:01:02 <roconnor> Thm. Every logarithmic functor F is a Naperian container.
12:01:22 <ski_> harovali1 : in the context of a type signature, yes
12:01:30 * loadquo annotates
12:01:36 <harovali1> ski_: thanks
12:01:48 <gbacon> ?ty canonicalizePath
12:01:49 <lambdabot> Not in scope: `canonicalizePath'
12:02:12 <roconnor> Thm. Every Naperian container is logarithmic
12:02:23 <ski_> harovali1 : the idea being that, e.g. `length :: [a] -> Int' means `length :: forall a. [a] -> Int', meaning it works for any type `a' you like
12:03:34 <loadquo> BMeph, does the foldchanger function look useful?
12:04:15 <sw17ch> pejo: no, i hadn't
12:04:34 <sw17ch> DSL for Generation of Optimized SIMD Parallel Assembly Code...
12:04:38 <sw17ch> that looks *Awesome*
12:04:43 <vixey> @undo do REFL <- decide u p; REFL <- decide v q; return REFL
12:04:44 <lambdabot> decide u p >>= \ a -> case a of { REFL -> decide v q >>= \ a -> case a of { REFL -> return REFL; _ -> fail ""}; _ -> fail ""}
12:04:52 <thoughtpolice> sw17ch: is that about the coconut project?
12:04:53 <gwern> dons: http://johnmacfarlane.net/repos/filestore <-- yeah, it's a typeclass over DVCSs, look in Types.hs
12:05:12 <sw17ch> thoughtpolice: it might be, but i'm not sure what the coconut project is
12:05:18 <roconnor> http://sneezy.cs.nott.ac.uk/containers/blog/?p=14
12:05:51 <vixey> @src liftM2
12:05:51 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
12:05:53 <thoughtpolice> sw17ch: it uses haskell to generate highly optimized code for e.g. the cell. the code generated is supposedly 4x better than hand-written C/asm code!
12:06:04 <sw17ch> thoughtpolice: wow
12:06:27 <PeakerWork> @src liftA2
12:06:27 <lambdabot> liftA2 f a b = f <$> a <*> b
12:06:53 <sw17ch> thoughtpolice: i'm hoping to use DSL's in haskell as a justification for writing Haskell @/for work
12:07:39 <vixey> :t liftM2
12:07:40 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:08:47 <thoughtpolice> sw17ch: mmm, delicious. :)
12:08:59 <gwern> @tell dons I have seen that paratropper game, but I couldn't contact the author to get license clearance
12:08:59 <lambdabot> Consider it noted.
12:09:06 <vixey> well I can't get it to work at all
12:09:18 <vixey> still clueless why it doesn't work either
12:11:04 <vixey> actually it works if you annotate the lambda
12:11:23 <vixey> I guess it just can't figure out to pick (->) from the context
12:15:16 <pumpkin> sbahra: did you see that paper that dons linked to earlier? http://www.cas.mcmaster.ca/~kahl/Publications/TR/Anand-Kahl-2007a_DSL/
12:16:26 <Holle_> supports cairo different layers?
12:16:59 <sbahra> pumpkin, no, thanks for telling me about it
12:17:06 <dcoutts> Holle_: it supports compositing which is more general
12:17:07 <sbahra> I've downloaded, I'll take a look soon.
12:17:16 <pumpkin> not quite hand-coded SIMD assembly, but looks handy :)
12:17:44 <pumpkin> nothing will ever be able to keep up with SSE17
12:17:50 <pumpkin> that intel will introduce this year, I'm sure
12:18:09 <Holle_> dcoutts: how does it work?
12:22:25 <dcoutts> Holle_: it involves setting a source colour, or pattern and using it to paint onto your target surface. See the cairo site for some examples.
12:22:37 <Holle_> thanks
12:24:27 <PeakerWork> conal defines a bunch of inDataType, inDataType2, etc functions on his data types, that unpack the argument, apply the function, then repack the argument. I am wondering,  Functor/Applicative be used instead? couldn't inDepth2 in his latest blog entry just be liftA2?
12:24:52 <vixey> ?where conal
12:24:52 <lambdabot> http://conal.net
12:25:33 <sw17ch> ?where sw17ch
12:25:34 <lambdabot> I know nothing about sw17ch.
12:25:47 <sw17ch> Phwew. I was hoping it woudln't spit out GPS coordinates.
12:27:57 <ski_> vixey : still irritating, since it feels like it should be able to get the types of the lambda from the context, if it only considered things in the right order
12:31:19 <centrinia> SSE is an abomination. :(
12:31:38 <sbahra> centrinia, why?
12:31:53 <centrinia> It is the opposite of orthogonal.
12:32:00 <ski_> @whatis SSE
12:32:00 <lambdabot> I know nothing about sse.
12:32:33 <centrinia> @google SSE2
12:32:36 <lambdabot> http://en.wikipedia.org/wiki/SSE2
12:32:36 <lambdabot> Title: SSE2 - Wikipedia, the free encyclopedia
12:36:32 <oshyshko> How to convert "\\123\\234" :: String    to   "\123\234" :: String ?
12:37:14 <vixey> > read "\\123\\234" :: String
12:37:16 <lambdabot>   "* Exception: Prelude.read: no parse
12:37:27 <vixey> > read ("\""++"\\123\\234"++"\"") :: String
12:37:27 <dolio> > read "\"\\123\\234\""
12:37:28 <lambdabot>   "{\234"
12:37:29 <lambdabot>   * Exception: Prelude.read: no parse
12:37:30 <sw17ch> > show "\123\234"
12:37:32 <lambdabot>   "\"{\\234\""
12:38:08 <vixey> > read ("\""++"\\123\\234"++"\"") == "\123\234"
12:38:09 <lambdabot>   True
12:38:38 <oshyshko> read $ show $ Maybe "\\123\\234"
12:38:48 <oshyshko> > read $ show $ Maybe "\\123\\234"
12:38:49 <lambdabot>   Not in scope: data constructor `Maybe'
12:38:59 <pumpkin> centrinia: most of x86/IA-32 is an abomination
12:39:05 <oshyshko> > read $ show "\\123\\234"
12:39:05 <pumpkin> doesn't stop it from being handy :P
12:39:06 <lambdabot>   * Exception: Prelude.read: no parse
12:39:20 <pumpkin> centrinia: welcome back btw :P
12:39:51 <oshyshko> > $ show "\\123\\234"
12:39:52 <lambdabot>   <no location info>: parse error on input `$'
12:40:15 <ski_> (didn't we answer this same question a few days ago ?)
12:43:36 <BMeph> centrinia: As bad as SSEn is, I blame backwards compatibility for being worse. :\
12:44:52 <centrinia> Thanks pumpkin. :P
12:45:03 <centrinia> BMeph, I agree.
12:45:03 <pumpkin> yeah I agree
12:45:30 <oshyshko> nope. I am still trying to make GHCi print complex structures with Cyrillic (just for debugging). Like: trace :: Show a => a -> IO ()
12:46:31 * BMeph thinks that as bad as they are, backwards-compatible emulator software is better than backwards-compatible hardware.
12:47:13 <centrinia> Is there a Data.List function that generates all n-tuples (as Lists) of elements of a List?
12:48:03 <pumpkin> centrinia: I really doubt it, as there are no general n-tuple techniques out there?
12:48:07 <pumpkin> unless you want to delve into TH
12:48:30 <thoughtpolice> TH is basically your only option since the size of all tuples is known statically at compile time
12:48:34 <centrinia> pumpkin, I meant that they are Lists instead of actual tuples.
12:48:47 <BONUS_> centrinia: give us an example
12:48:49 <dolio> > replicateM 4 [1..4]
12:48:50 <lambdabot>   [[1,1,1,1],[1,1,1,2],[1,1,1,3],[1,1,1,4],[1,1,2,1],[1,1,2,2],[1,1,2,3],[1,1...
12:48:53 <dolio> Like that?
12:48:56 <centrinia> Oh.
12:48:58 <centrinia> Thanks. :)
12:48:59 <pumpkin> , subsequences [1..4]
12:49:00 <pumpkin> oh
12:49:00 <pumpkin> ok
12:49:01 <lunabot>  [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[...
12:49:50 <icqn> ?users
12:49:50 <lambdabot> Maximum users seen in #haskell: 649, currently: 632 (97.4%), active: 25 (4.0%)
12:56:34 <adamvo> hi, is there any way to wrap up say a Writer [a] a in a newtype, and still be able to get a derived monad instance?
12:59:52 <arjanb> just add to the newtype  deriving Monad
13:03:16 * sw17ch loves newtype's
13:04:24 <thoughtpolice> adamvo: yes, you can just have your newtype and write "deriving Monad"
13:04:34 <thoughtpolice> adamvo: you will need the GeneralizedNewtypeDeriving extension, however
13:04:52 <thoughtpolice> (it is an incredibly useful extension, to tell the truth)
13:05:14 <oshyshko> > (read $ "\"" ++ "\"\\123 raw string" ++ "\"") :: String
13:05:16 <lambdabot>   "* Exception: Prelude.read: no parse
13:05:32 <adamvo> newtype P a = P { unP :: Writer [a] a } deriving (Monad)
13:05:35 <adamvo> > newtype P a = P { unP :: Writer [a] a } deriving (Monad)
13:05:37 <lambdabot>   <no location info>: parse error on input `newtype'
13:05:41 <adamvo> aww
13:05:47 <thoughtpolice> adamvo: unfortunately lambdabot cannot do such things :(
13:05:50 <dolio> That's not a monad, though, I think.
13:06:45 <adamvo> what I want is to parameterize the type of what's being logged
13:06:45 <dolio> At least, not a simple lifting.
13:06:49 <roconnor> that's no monad
13:07:11 <dolio> Because (>>=) :: P a -> (a -> P b) -> P b = Writer [a] a -> (a -> Writer [b] b) -> Writer [b] b
13:07:20 <dolio> Which is not the type of (>>=) for Writer.
13:07:28 <BONUS_> and the monoids have to have the same type in them
13:07:59 <adamvo> could we get around this with existentials?
13:08:04 <ski_> (dolio : .. i had a related problem with a more complex monad, awhile ago)
13:08:25 <oshyshko> unfortunetaly "read" can't convert entries like "\\124" to "\124" if the string is malformed
13:08:34 <TuringTest> This is for a haskell module.  I have string search (regular expression in this case) policy question, for when one is computing many matches to the same string.  Overlapping matches are forbidden.  Should zero-length matches be allowed?  Should be be allowed to exist immediately after a non-zero-length match?  Note that "sed" seems to have a very complicated policy.
13:09:06 <TuringTest> Should the first zero-length match terminal the answer?  Hmmm...
13:09:10 <chrisdone> `f <$> fst <*> snd' is better than `uncurry f', amirite?
13:09:54 <BONUS_> seems more difficult to read to me
13:09:59 <roconnor> > read "\\124"
13:10:01 <chrisdone> `f <$> get' vs `gets f'
13:10:01 <lambdabot>   * Exception: Prelude.read: no parse
13:10:11 <ski_> > read "()"
13:10:12 <lambdabot>   ()
13:10:14 <roconnor> > read "\\124" :: String
13:10:15 <lambdabot>   "* Exception: Prelude.read: no parse
13:10:26 <BONUS_> > read "\"\\124\"" :: String
13:10:27 <lambdabot>   "|"
13:10:31 <BONUS_> wtf
13:10:32 <chrisdone> BONUS_: but consider `f <$> head <*> tail'
13:10:37 <roconnor> ah
13:10:40 <dolio> @src gets
13:10:40 <lambdabot> Source not found.
13:10:42 <oshyshko> read "\" 123"
13:10:45 <oshyshko> > read "\" 123"
13:10:46 <lambdabot>   * Exception: Prelude.read: no parse
13:10:53 <BONUS_> well for that, yeah
13:10:54 <oshyshko> > read "\" \\123"
13:10:55 <newsham> ?type \f -> f <$> head <*> tail
13:10:55 <lambdabot>   * Exception: Prelude.read: no parse
13:10:56 <lambdabot> forall b a. (a -> [a] -> b) -> [a] -> b
13:11:03 <chrisdone> BONUS_: it's a general abstraction!
13:11:09 <ski_>   gets f = get >>= f  -- iirc
13:11:18 <BONUS_> but everyone knows what uncurry does, wheres it takes more mental effort to parse f <$> fst <*> snd
13:11:18 <BONUS_> imho
13:11:19 <roconnor> @src gets
13:11:19 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
13:11:33 <ski_> @type Control.Monad.Reader.gets
13:11:34 <lambdabot> Not in scope: `Control.Monad.Reader.gets'
13:11:36 <chrisdone> ski_: gets f = liftM f get, IRRC
13:11:39 <ski_> @type Control.Monad.State.gets
13:11:40 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
13:11:42 <dolio> Well, it's 'fmap f get', but I wanted to see if that was the strict definition.
13:11:49 <ski_> chrisdone : yes
13:12:13 <chrisdone> BONUS_: is it mental effort once you know applicative?
13:12:37 <BONUS_> idk, i'd say yeah. i mean if you don't know applicative you wouldn't know what that does at all
13:12:49 <adamvo> data Log = forall a. Log a; newtype P a = { unP :: Writer [Log] a }
13:12:54 <BONUS_> especially cause you have to think about how ((->) r) is an applicative
13:13:17 <chrisdone> BONUS_: but if you do, is it better because it's more general?
13:13:27 <ski_> adamvo : `data Log' is simpler
13:13:35 <chrisdone> BONUS_: comparing to monads..
13:14:07 <dolio> I don't see how it's better than uncurry.
13:14:10 <BONUS_> my opinion would be that it's not, because uncurry f and f <$> fst <*> snd are equivalent
13:14:27 <BONUS_> if two expressions are equivalent, one can't be more general than the other
13:14:30 <dolio> f <$> head <*> tail is terribly unsafe, too. :)
13:14:31 <ski_> adamvo : though possibly you want to actually use the `Log' elements ?
13:14:38 <dolio> @src uncurry
13:14:38 <lambdabot> uncurry f p = f (fst p) (snd p)
13:15:00 <eu-prleu-peupeu> hello Hasklez0rs
13:15:02 <chrisdone> dolio: for the same reason `f <$> get' is better than `gets f', because it's an abstraction on a general kind of computation in pretty much the same amount of code (considering that you have to *define* gets)
13:15:03 <ski_> adamvo : iiuc, simplest would be to have `type Log = String' or something like that
13:15:36 <adamvo> ski_: I want to keep track of some elements that are the same as what the monad is parameterized over
13:15:36 <defun> Does haskell have a facility/library that allows for lisp-like-macros and language modification?
13:15:55 <adamvo> ski_: in my case, its some number type
13:15:56 <chrisdone> there is liskell and there is template-haskell
13:16:01 <ski_> defun : not really
13:16:23 <chrisdone> dolio: don't you agree?
13:16:28 <dolio> <$> fst <*> snd is way noiser than uncurry.
13:16:49 <dolio> Also, uncurry is the pair catamorphism, so there's no excuse for it not to be around.
13:17:33 <chrisdone> suppose later on in my code I want f <$> a <*> b <*> c
13:17:49 <chrisdone> is the noise worth it to consistently identify the same kind of construct?
13:19:01 <ertai> gwern: I've seen your report about 'as' in Yi
13:19:18 <BONUS_> i just know that if i were reading code, i'd much rather see uncurry f than f <$> fst <*> snd
13:19:38 <ertai> gwern: seeing the screenshot, may I ask what font and terminal do you use?
13:19:42 <vixey> haskell doesn't generally give catamorphisms for everything
13:21:13 <dons> interesting, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ghci-haskeline-0.1
13:21:13 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
13:21:38 <dons> so this is how we revive hbi..
13:21:42 <thoughtpolice> dons: i've been using ghci-haskeline for a while now, since it's not possible to tell the default ghc 6.10.1 build process where the editline libraries exist.
13:21:54 <dolio> I just don't see what it gains you.
13:22:12 <thoughtpolice> because mine exist in $HOME and the build process can't find it.
13:22:28 <dolio> All monads and comonads are arrows, so you could use arrow syntax for everything you write, since it subsumes all sorts of stuff, but I wouldn't recommend it.
13:23:26 <thoughtpolice> dons: I say it's made of win. :) i do hope that haskeline is integrated into the mainline distribution of ghc, because that would be so much less hassle and would also be better for windows users too. having a ghci without backspace/history completion is pretty much non-tolerable.
13:24:09 <dolio> Just because you can write something as a (->) r computation doesn't mean it's recommendable, or that doing so is more general.
13:24:18 <dons> well, haskeline uses a few interesting extensions
13:24:45 <dons>     Extensions: CPP, MagicHash, UnboxedTuples, PatternGuards,
13:24:45 <dons>                 ForeignFunctionInterface, EmptyDataDecls,
13:24:45 <dons>                 TypeSynonymInstances, MultiParamTypeClasses,
13:24:45 <dons>                 FlexibleInstances, Rank2Types, ScopedTypeVariables,
13:24:45 <dons>                 DeriveDataTypeab
13:25:02 <dons> i'm not entirely comfortable having all those for a readline impl.
13:25:09 <rwbarton> can I tell cabal to ignore the 'ghc < 6.11' constraint for ghci-haskeline?
13:25:13 <chrisdone> dolio: good point
13:25:14 <dons> those aren't too bad though, i suppose. seems overkill
13:25:42 <TuringTest> dons:  UnboxedTuples ?  Something needed wrapping?  Or unwrapping....hmmm.
13:25:51 <vixey> dons why not?
13:26:05 <dolio> FlexibleInstances and EmptyDataDecls are simply common sense. :)
13:26:20 <vixey> yeah I wish NoMonomorphism and EmptyDataDecls were default
13:26:21 <Holle_> could this code written easier?
13:26:23 <Holle_> http://hpaste.org/13862
13:26:30 <thoughtpolice> can't forget MultiParameterTypeClasses!
13:26:33 <JimCrayne> i never heard of haskeline... sounds like a great idea
13:26:37 <thoughtpolice> and ScopedTypeVariables
13:26:39 <Holle_> the last two lines are always the same...
13:26:40 * sw17ch notes that EmptyDataDecls breaks htags
13:26:45 <bos> Wow, that's quite the Christmas tree of language extensions. Who'da thunk you'd need rank-N types for command line editing?
13:26:46 <vixey> Holle_, *yes*
13:26:53 <dolio> He even went with the tame Rank2Types instead of RankN.
13:26:56 <JimCrayne> i'd also like to see ghc without gmp
13:26:58 <Holle_> vixey: how?
13:27:08 <vixey> Holle_, not using I
13:27:09 <dcoutts> rwbarton: no, you'll have to fetch the package and edit it
13:27:11 <vixey> Holle_, not using IO
13:27:16 <rwbarton> dcoutts: thatnks
13:27:38 <Holle_> how should it work?
13:27:39 <thoughtpolice> JimCrayne: there's work being made on that front!
13:27:48 <JimCrayne> not that i have something against the gpl... but it is a complication when using haskell in proprietary settings..
13:28:10 <TuringTest> "  case addrToHValue# addr of (# hval #) -> return (unsafeCoerce# hval)"
13:28:14 <JimCrayne> or lgpl i should say in this case
13:28:14 <JimCrayne> recent work?
13:28:21 <olsner> will the ghc docs source links ever be fixed? :S
13:28:22 <TuringTest> above in ghci-haskeline
13:28:23 <chrisdone> let (state,areas) = ... in writeIORef curState 2
13:28:26 <chrisdone> uh
13:28:41 <chrisdone> let (state,areas) = ... in do writeIORef curState state; writeIORef curAreas areas
13:28:41 <chrisdone> ?
13:29:14 <Holle_> does let... in do ... work?
13:29:16 <olsner> @ty unJust
13:29:17 <lambdabot> Not in scope: `unJust'
13:29:18 <chrisdone> that way all your case code is pure and you do one IO operation at the end
13:29:26 <olsner> is that an old name for fromJust?
13:29:27 <thoughtpolice> olsner: that was mentioned on the mailing list just a while ago, I believe the answer is "yes"
13:29:50 <chrisdone> well, the syntax was just an example
13:29:51 <thoughtpolice> JimCrayne: seems so. i believe most people would like to see GMP gone, even if it means Integer code has to take a performance hit.
13:29:53 <olsner> thoughtpolice: ah, that's comforting at least
13:30:22 <JimCrayne> yeah... gone or more easily optional
13:30:37 <thoughtpolice> JimCrayne: it also means that getting ghc code on the bare metal with no OS is easier. i believe people at galois are working on that.
13:30:51 <JimCrayne> awesome
13:31:07 <JimCrayne> galois makes me wonder if i should relocate to oregon
13:31:07 <Baughn> thoughtpolice: From a user perspective, I certainly wouldn't. What's wrong with GMP?
13:31:19 <Holle_> is it possible to do a case on two arguments? (state/area)
13:31:36 <Baughn> Holle_: case (a,b) of (foo,bar) -> ...
13:31:37 <thoughtpolice> Baughn: licensing issues.
13:31:42 <byorgey> JimCrayne: not a bad place to relocate to
13:31:44 <leimy> a tuple
13:31:57 <dons> JimCrayne: hehe. portland is haskell central, imo.
13:31:58 <chrisdone> case (state,area) of (foo,bar) | foo == 1 = ...; bar /= z = ...; etc.
13:32:01 <Holle_> right!
13:32:22 <JimCrayne> It's tough, i have a lot of connections here
13:32:29 <thoughtpolice> Baughn: http://hackage.haskell.org/trac/ghc/wiki/ReplacingGMPNotes
13:32:39 <Baughn> thoughtpolice: Hmm. I see.
13:33:25 <Holle_> is the version of baughn not ok?
13:33:44 <vixey> I think Baughns sleeping problems are solved in HEAD
13:33:53 <rwbarton> dcoutts: What do you know, it actually doesn't build against my ghc-6.11 :P
13:34:03 <dcoutts> rwbarton: heh
13:34:04 <dolio> Isn't GHC getting dynamic linking some time soon?
13:34:05 <Baughn> vixey: I had sleeping problems?
13:34:11 <leimy> vixey: HEAD cures insomnia!?
13:34:17 <dcoutts> dolio: yes
13:34:21 <thoughtpolice> dolio: there's some stuff there but it's currently marked unstable I believe
13:34:24 <wjt> how exactly will cross-module inlining work in the presence of dynamic linking?
13:34:25 <Baughn> Geez, I've really been away from here for too long. :/
13:34:32 <vixey> Baughn sorry :p
13:34:38 <Baughn> wjt: Complicatedly. :P
13:34:42 <wjt> or rather: presumably it *won't*, and ghc's optimizations will suddenly become less awesome
13:34:44 <thoughtpolice> dolio: simon marlow highlighted a few issues why it's taking so long and why he isn't exactly 'rushing' for it
13:34:54 <dolio> thoughtpolice: Well, 6.12 isn't coming out any time soon, either.
13:34:55 <JimCrayne> thoughtpolice, I look at the history of that page, and me and some guy who corrected a typo are t he only ones who edited it in 2008
13:35:05 <thoughtpolice> wjt: I believe that most of the cross-module optimization stuff is in fact exposed through .hi files
13:35:18 <vixey> Baughn, I wonder if you were away doing something interesting ?
13:35:33 <dolio> So "some time soon" may be an overstatement.
13:35:35 <wjt> thoughtpolice: it's just not clear to me how you inline a function from a library you only dynamically link to
13:35:37 <Baughn> vixey: Depends. Is optimizing c++ code for a game interesting? ^_^;
13:35:45 <vixey> it can be
13:35:52 <Baughn> vixey: Ah well. I've got something interesting and haskelly lined up now.
13:35:52 <vixey> not my thing but..
13:36:05 <vixey> still with serializable closures or..?
13:36:19 <thoughtpolice> wjt: i mean things like functions which are small enough to be inlined are actually *in* the .hi files, that are built with every library and used/checked every time you build an app against that library
13:37:21 <cknapp> I'm confused about RWH's definition of foldl in terms of foldr... It gives 4 arguments to foldr.
13:37:28 <thoughtpolice> wjt: but then again, I could be totally wrong; .hi files do have a lot of the necessary information for things like cross-module optimizations from what I understand, however. if you're really curious you'd be better off asking in #ghc or on glasgow-haskell-users
13:37:28 <Baughn> vixey: No, more of a coda-replacement
13:37:33 <pumpkin> cknapp: what is it?
13:38:04 <cknapp> myFoldl f z xs = foldr step id xs z where step x g a = g (f a x)
13:38:11 <wjt> thoughtpolice: right, but if I inline a function f in library A which I dynamically link to, then upgrade A to a new release which has an f that behaves differently, then the wrong thing happens
13:38:14 <JimCrayne> is there a web browser written in haskell?
13:38:33 <wjt> thoughtpolice: unless the answer is "you have to rebuild everything which dynamically links against A whenever you upgrade A", which would make me sad
13:38:36 * sw17ch contemplates a hackage wrapper aroudn webkit
13:38:43 <dons> there's ones written using gtk, yeah. but i wouldn't say anything other than the thinest layer is in haskell
13:38:55 <chrisdone> sw17ch: I also contemplated that but I'll let someone else try to do it ;-)
13:38:57 <leimy> Baughn: the filesystem?
13:39:02 <eu-prleu-peupeu> hey dons, 'sup ?
13:39:11 <dons> hi eu-prleu-peupeu. how's the coding coming along?
13:39:12 <Baughn> leimy: Yep
13:39:13 <chrisdone> sw17ch: interfacing with C++ or objc code..
13:39:14 <sw17ch> chrisdone: i have plans to do libgcrypt first :P
13:39:15 <eu-prleu-peupeu> im going to write my own gui in haskell
13:39:15 <dons> made any progress?
13:39:18 <leimy> Baughn: interesting.
13:39:30 <dons> oh right. i'm looking forward to seeing it.
13:39:36 <leimy> HOpenGL web browser.
13:39:37 <pumpkin> eu-prleu-peupeu: a GUI for what?
13:39:40 <eu-prleu-peupeu> not much, moving slowing... ill write one or two posts shortly...
13:39:44 <dons> vaporware.
13:39:51 <eu-prleu-peupeu> ahah
13:39:55 <Baughn> leimy: I hope so. :)
13:40:03 <eu-prleu-peupeu> i have a degree in vaporware :D
13:40:08 <thoughtpolice> wjt: yes. from what I understand though it shouldn't cause any optimizations to die (at the very least you may experience a hit because libs have to be loaded into shared memory but that should be negligable,) like I said you're best off asking g-h-u for the exact specifics
13:40:12 <eu-prleu-peupeu> pumpkin: an openGL gui
13:40:15 <leimy> Baughn: have anything to do with that Zipper FS stuff I think Oleg was involved in?
13:40:21 <Baughn> leimy: Well, it's not really a replacement; the targets are very different
13:40:24 <Baughn> leimy: No
13:40:28 <leimy> hrm
13:40:28 <thoughtpolice> wjt: because simon marlow can in fact answer your questions with accuracy :P
13:40:55 <eu-prleu-peupeu> and then im going to work with conal eliott, and write lots of funny papers about haskell
13:41:02 <Baughn> leimy: I only got started on it.. two days ago, really, but you can look at http://brage.info/~svein/proposal.pdf I guess
13:41:03 <pumpkin> o.O
13:41:21 <pumpkin> eu-prleu-peupeu: does conal know about this?
13:41:21 <wjt> thoughtpolice: right. I'm pretty interested, but I think I would be wasting Lord Marlow's time if I were to go ask for more details: in practice it's likely it'd be meaningless to me :)
13:41:27 <eu-prleu-peupeu> pumpkin: not yet
13:41:31 <pumpkin> lol
13:41:56 <dons> eu-prleu-peupeu: is this how you imagined you'd spend your life?
13:42:16 <pumpkin> eu-prleu-peupeu: you'll have an erdos number of 1 in no time at this rate!
13:42:35 <eu-prleu-peupeu> dons: well, its either this, or fishing in africa
13:42:39 <dons> :)
13:42:45 <dons> of course. of course.
13:42:50 <thoughtpolice> wjt: hehe. i'm pretty sure most of this stuff has been thought about, i mean, I would rather just replace GMP and take the hit for that then have shared library support and kill *all* cross-module optimizations immediately. that seems like a loss, imo.
13:43:04 <olsner> "Haskell: It's not fishing in Africa!"
13:43:09 <eu-prleu-peupeu> :D
13:43:22 <pumpkin> what's wrong with fishing in africa? I'm a fisherman in africa :(
13:43:37 <olsner> pumpkin: well, it's not Haskell
13:43:40 <pumpkin> oh
13:43:43 <thoughtpolice> wjt: shared lib support has been in the works for a long time though. simon had some reasons why it's taking so long, I believe one of them was a GMP issue in fact, i might look it up...
13:43:44 <pumpkin> but it can be!
13:43:51 <vixey> weird
13:43:53 <thoughtpolice> (since like, the google SoC 2006)
13:44:15 <eu-prleu-peupeu> oh yes, and im going to participate in the google summer of code this year with a project in haskell
13:44:34 <eu-prleu-peupeu> so i can have the money to buy the ticket to go to africa
13:44:45 <pumpkin> eu-prleu-peupeu: does google know abou this yet?
13:44:49 <wjt> thoughtpolice: of course, i know it can't be as simple as "no more optimizations for you!"
13:45:08 <wjt> thoughtpolice: but yeah. i guess when it's all solved there'll be lots of nice papers to read :D
13:45:11 <eu-prleu-peupeu> pumpkin: not yet, when they open the call for projects, ill think of something
13:45:21 <pumpkin> eu-prleu-peupeu: ah okay
13:46:30 <pumpkin> eu-prleu-peupeu: and when will you write papers with dons? you should write a new and improved stream fusion paper with magick! meanwhile I'll get myself an erdos number of 2 so we can write a BS paper together and give you a 3
13:46:48 <vixey> weirdweirdweird
13:46:52 <thoughtpolice> wjt: :)
13:47:05 <eu-prleu-peupeu> what is erdos ?
13:47:16 <pumpkin> eu-prleu-peupeu: a very prolific mathematician
13:47:25 <eu-prleu-peupeu> ahah
13:48:02 * thoughtpolice has an erdos number of "last [1..]"
13:48:06 <pumpkin> lol
13:48:13 <pumpkin> thoughtpolice: are you sure of that?
13:48:18 <vixey> Lim (\n::Nat -> n)
13:48:23 <cknapp> pumpkin: Sounds like a plan. I'm in...
13:48:35 <thoughtpolice> pumpkin: pretty sure. :P
13:48:36 <vixey> hm..
13:48:39 <vixey> Lim (\n::Nat -> toOrd n)
13:48:39 <pumpkin> aw
13:48:48 * pumpkin wonders if he has a number :o
13:48:50 <cknapp> I don't think he's written a paper is what he's trying to say
13:48:56 <pumpkin> y'all can have a pumpkin number if you want
13:49:10 <cknapp> pumpkin: If you've written a paper with anyone else, you probably have a number...
13:49:12 <vixey> :t (\x::() -> x)
13:49:13 <lambdabot> Ignoring (deprecated) result type signature ()
13:49:18 <vixey> :t (\(x::()) -> x)
13:49:20 <lambdabot> () -> ()
13:49:20 <pumpkin> cknapp: I have :P
13:49:33 <vixey> :t (\(x::()->()) -> x)(\(x::()) -> x)
13:49:35 <lambdabot> () -> ()
13:49:36 <pumpkin> cknapp: there needs to be an erdos calculator on one of the online citation tracking cites
13:49:38 <pumpkin> sites, even
13:49:54 <cknapp> Indeed...
13:50:01 <Holle_> i tried to optimize my code but it will not work: http://hpaste.org/13864 and the original: http://hpaste.org/13862
13:50:01 <vixey> :t (\(x::((()->())->())->()) -> x)(\(x::()->()) -> x)(\(x::()) -> x)
13:50:05 <lambdabot>     Couldn't match expected type `() -> ()' against inferred type `()'
13:50:05 <lambdabot>       Expected type: (() -> ()) -> ()
13:50:05 <lambdabot>       Inferred type: () -> ()
13:50:11 <cknapp> I need to pump out a paper with any of my math professors to get an Erdos number of 3...
13:50:48 <cknapp> The problem is I'm a lowly undergrad with no background...
13:50:55 * thoughtpolice has never written a paper and he is an undergrad
13:51:07 <pumpkin> thoughtpolice: oh no! better get working on one!
13:51:24 <eu-prleu-peupeu> thoughtpolice: go for it: http://pdos.csail.mit.edu/scigen/
13:51:25 <thoughtpolice> probably. :)
13:51:37 <thoughtpolice> hehe, I love scigen
13:51:39 <pumpkin> eu-prleu-peupeu: ah, is that what you're going to co-author with conal? :P
13:51:42 <dons> thoughtpolice: you better hand back your haskell license then. you know you must have authored at least 2 conference papers on category theory to use the type checker.
13:51:44 <vixey> why insist that everyone has a PhD and writes lots of papers about nonsense
13:51:56 <thoughtpolice> dons: i would rather have death!
13:51:57 <pumpkin> vixey: it's the haskell way
13:52:06 <eu-prleu-peupeu> pumpkin: that would be our last resort
13:52:26 <dons> vixey: its very important to be a category theory phd, didn't you know? lambdas don't apply otherwise
13:52:27 <eu-prleu-peupeu> if the deadline was too deadly
13:52:31 <cknapp> vixey: to avoid success at all costs!
13:52:32 * thoughtpolice loves his haskell, very much
13:52:37 <vixey> I'd ask where you got that impression but I doubt I'll get any straight answer
13:52:41 <thoughtpolice> next to all of your thoughts
13:52:46 <thoughtpolice> that i'm stealing right now.
13:52:47 * pumpkin hands back his haskell apprentice license :(
13:53:07 <pumpkin> thoughtpolice: which haskell do you love? the one BONUS learned you for great good?
13:53:19 <thoughtpolice> the one i learned me for great awesome!
13:53:28 <pumpkin> oh cool
13:54:04 <chrisdone> Yet Another Gentle Guide to Real Great Haskell
13:54:15 <pumpkin> lol
13:54:18 <cknapp> haha
13:54:28 <pumpkin> the joy of haskell?
13:54:36 <pumpkin> or does that one already exist
13:54:39 <cknapp> I see you're writing a new tutorial... Did you "just figure out monads"?
13:54:45 <Holle_> it says: parse error in pattern
13:54:57 <pumpkin> Holle_: what's your pattern?
13:55:20 <Holle_> http://hpaste.org/13862 the line of case
13:55:53 <pumpkin> huh?
13:56:12 <Holle_> ?
13:56:25 <pumpkin> which line? :P
13:56:43 <rwbarton> Holle_: I'm not sure whether that indentation is OK
13:56:45 <Holle_> sorry ^^ i mean http://hpaste.org/new
13:57:07 <Holle_> this http://hpaste.org/13864
13:57:23 <pumpkin> you're doing as = ?
13:57:54 <dolio> The problem is you have a case expression in the middle of a set of declarations in a let.
13:57:55 <rwbarton> Holle_: that indentation is definitely wrong :)
13:58:18 <pumpkin> oh it's a letcase!
13:58:19 <rwbarton> Holle_: You want   as = case ... of ...
13:58:31 <Holle_> yes
13:59:41 <Holle_> now it says the last statement must be an expression :/ in't let in an expression?
13:59:59 <leimy> Baugh lookin.
14:00:03 <leimy> er looking at that paper.
14:00:22 <pao> hmmm... I'm get much lower than expected from a naive read -> write to stdout program...
14:00:26 <eu-prleu-peupeu> when is someone going to write the book "alien world haskell" ?
14:00:45 <rwbarton> Holle_: hpaste again
14:00:47 <pao> http://hpaste.org/13866
14:00:51 <byorgey> Holle_: you don't need the 'in' in a do-block
14:01:11 <byorgey> Holle_: just remove the 'in' and move the writeIORefs to the same column as the  s <-  and a <- ...
14:01:23 <pao> my program takes around 1 minute to read a 500.000 lines file
14:01:36 <pao> wc -l is almost istantaneous
14:01:46 <dolio> pao: What if you use forM_?
14:02:02 <pao> dolio: let me try
14:02:17 <Botje> pao: uh, your program doesn't do the same as wc -l :)
14:02:27 <leimy> Baughn: Have you ever looked at some of the stuff in 9p or Inferno's Styx?
14:02:33 <byorgey> pao: you are compiling it with -O2 ?
14:02:40 <pao> byorgey: yep
14:02:47 <leimy> I believe they use a "revision" number of sorts internally to help with consistency across nodes accessing remote systems.
14:02:54 <pumpkin> pao: wasn't there a post by dons about an Ã¼berfast wc -l in haskell?
14:03:02 <leimy> kind of like a Version Control System.
14:03:14 <pao> leimy: I've done exactly the same in Python ... less then 1 sec
14:03:21 <pumpkin> my browser is being stupid right now so I can't find it
14:03:25 <leimy> pao: ??
14:03:41 <pao> byorgey: yep ... -O2
14:03:48 <byorgey> ok
14:03:50 * sw17ch uses Haskell without a license... suggests some one try to stop him
14:03:59 * sw17ch cackles
14:04:18 <pumpkin> sw17ch: I won't try to stop you, I'll just force you to get a PhD
14:04:31 <pumpkin> sw17ch: now write a paper! *whipcrack*
14:04:35 * byorgey ensnares sw17ch with a zygohistomorphic prepromorphism
14:04:44 <pao> leimy: you said it's not exactly like wc -l... yep... I've implemented exactly the same semantics in python ... it was > 50 faster
14:04:56 * sw17ch unsafePerformIO's byorgey
14:04:57 <dolio> It's cat.
14:05:05 <pumpkin> mrrowl
14:05:07 <olsner> byorgey: hey, watch where you point those morphisms
14:05:14 <leimy> pao:  I didn't say anything of the sort... check the history :-)
14:05:40 <sw17ch> actually, if any one is aware of PhD programs looking for minoins in the next few years...
14:05:42 * byorgey is cloned due to sw17ch's failure to inline the call to unsafePerformIO
14:05:44 <leimy> pao: In fact I wasn't sure what you were talking about...I was on another thread :-)
14:05:46 <jeffz`> a strange cat.
14:05:46 <pao> dolio: WOW.... forM did the trick... from 60 seconds to 0 .125 sec
14:05:54 <leimy> but now I have your hpaste open
14:06:02 * sw17ch shells out and kill -9's byorgey's process
14:06:02 <dolio> Yeah. I figured it was a problem.
14:06:15 <pao> leimy: sorry
14:06:25 <pumpkin> pao: forM_?
14:06:28 <pao> dolio: is that reasonable?
14:06:29 * sw17ch appologizes and runs byorgey out of init
14:06:39 <pao> pumpkin: yes: s/forM/forM_/
14:07:03 <dolio> pao: forM shuffles around a list of ()s. forM_ doesn't. That makes forM_ potentially a lot faster.
14:07:21 <olsner> hey, is main really of the type IO a rather than IO ()?
14:07:27 <vixey> olsner, yes
14:07:48 <sw17ch> i wonder what the origin of /me fighting is
14:07:55 <olsner> hmm, okay
14:08:20 <pao> pumpkin: I'll give a look to dons post on wc -l ... thanks
14:08:30 <pumpkin> pao: I _think_ it was him
14:08:32 <pumpkin> but it might not have been
14:08:55 <olsner> also, why can't the result generation of forM be eliminated when the result isn't used?
14:08:58 <leimy> forM_ is only appropriate if you don't use the value forM returns for anything.
14:09:17 <vixey> byorgey, are you still working on a dependent type thing?
14:09:31 <leimy> olsner: is that not a bit like asking the compiler to rewrte forM to forM_
14:09:32 <leimy> ?
14:09:42 <leimy> er rewrite
14:10:08 <leimy> or do you mean to automatically transform forM to forM_?
14:10:11 <pumpkin> leimy: it seems reasonable though
14:10:12 <leimy> internally
14:10:20 <leimy> hmmm it does seem reasonable.
14:10:22 <pumpkin> it can tell if the result is used or not
14:10:23 <olsner> well, more like asking it to rewrite forM to something *like* forM_
14:10:32 <leimy> if that's the case, then you don't need to have forM_ in the library at all :-)
14:10:36 <pumpkin> it might as well not bother doing stuff if it won't be used
14:10:36 <leimy> once successful.
14:10:39 <dolio> pao: In hand-wavey terms, you can think of it like: forM_ is tail recursive, forM isn't.
14:10:46 * Toxaris is fighting with cabal-install :(
14:10:52 <pumpkin> Toxaris: I hope you win!
14:10:54 <dolio> So the former makes a much better tight loop.
14:10:55 <vixey> @src forM
14:10:55 <lambdabot> forM = flip mapM
14:11:02 <vixey> @src mapM
14:11:02 <lambdabot> mapM f as = sequence (map f as)
14:11:05 <leimy> yep :-)
14:11:12 <leimy> @src forM_
14:11:13 <lambdabot> forM_ = flip mapM_
14:11:27 <Toxaris> 'cabal install haskeline' tells me "cabal: Couldn't read cabal file './ghci-haskeline/0.1/ghci-haskeline.cabal'
14:11:46 <olsner> @src sequence_
14:11:46 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
14:11:58 <Toxaris> pumpkin: thanks :)
14:12:14 <pumpkin> @src sequence
14:12:14 <lambdabot> sequence []     = return []
14:12:14 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:12:14 <lambdabot> --OR
14:12:14 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
14:12:32 <pao> in fact in the loop the return value is IO (), so lazy evaluation/compiler optimization should give the same performances...
14:12:37 <leimy> all that "consing"
14:13:05 <pao> it's clear now
14:13:09 <dcoutts> Toxaris: cabal install cabal-install to get the latest version
14:13:22 <pao> a huge [(), (), ()... is being built
14:13:31 <leimy> Yeah for a 500,000 line file :-)
14:13:37 <leimy> 500,000 ()'s
14:13:48 <dolio> And then thrown away. :)
14:13:51 <leimy> yep
14:13:55 <leimy> brilliant catch.
14:13:59 <Toxaris> dcoutts: already tried, cabal-install tries to install my cached network-2.1.0.0, even if it is already installed, and fails with some c header problems
14:14:02 <pao> thanks everyone :-)
14:14:10 <leimy> pao:  Now could HLint have told you that?
14:14:12 <leimy> I'm not sure :-
14:14:16 <leimy> :-/
14:14:30 <leimy> http://www-users.cs.york.ac.uk/~ndm/hlint/
14:14:38 <pumpkin> probably could if you worked hard enough
14:14:55 <pao> It's the first time I get > 100 performance improvement by adding a single "_" ;-)
14:15:02 <leimy> heh
14:15:31 <leimy> Actually, in some functional languages, a "for" ignores results all the time, and you use "map" otherwise
14:15:51 <vixey> SCHEME
14:15:51 <leimy> but that's just a matter of taste I suppose.
14:16:00 <leimy> Erlang
14:16:04 <pao> pumpkin: there even a haskell wiki page dedicated to wc -l :-)
14:16:16 <pumpkin> awesome
14:16:38 <pao> for the record http://www.haskell.org/haskellwiki/Wc
14:16:39 <pao> :-)
14:21:06 <chrisdone> @pl \x y z -> x y $ z y
14:21:06 <lambdabot> (`ap` flip id) . ((.) .)
14:21:10 <chrisdone> @_@
14:21:25 <chrisdone> :t flip id
14:21:26 <lambdabot> forall b c. b -> (b -> c) -> c
14:21:57 <olsner> @ty \x y z -> x y $ z y
14:21:58 <lambdabot> forall t a b. (t -> a -> b) -> t -> (t -> a) -> b
14:23:14 <BONUS_> whats the @pl to put lambdabot in a big loop
14:23:20 <BONUS_> (i wont run it)
14:23:20 <pao> wow .... It's the first time I'm "benchmarking" haskell on a quite big data set ... the performance is great
14:23:25 <chrisdone> reminds me of the S combinator
14:23:44 <chrisdone> Sxyz â†’ xz(yz)
14:23:45 <pumpkin> @pl q w e r t y u i o p = t y p e w r i t e r
14:23:45 <leimy> ByteString is pretty awesome
14:23:48 <lambdabot> q = (((((const . (const .)) .) .) .) .) . flip flip id . ((ap . (flip .) . ((flip .) .)) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . join . (flip .) . ((flip .) .) . (((flip .) .) .) . (((
14:23:48 <lambdabot> (flip .) .) .) .) . (((((flip .) .) .) .) .) . flip flip id . (flip .) . ((ap .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((flip .) .) .) .) . (flip .) . ((flip .)
14:23:48 <lambdabot> .) . (((flip .) .) .) . flip (flip . (flip .) . ((flip .) .) . flip (flip . (flip .)))
14:23:48 <lambdabot> optimization suspended, use @pl-resume to continue.
14:23:57 * thoughtpolice stands by his statement that it is now easier than ever to get high-performance haskell code.
14:23:58 <chrisdone> how can I get the S combinator in haskell? :-)
14:24:01 <thoughtpolice> :)
14:24:32 * chrisdone also can't believe he recognised the S combinator from a type
14:24:34 <leimy> S=\xya -> xa(ya)
14:24:40 <tromp__> :t ap
14:24:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:24:48 <leimy> er something like that :-)
14:24:51 <tromp__> :t ap Reader
14:24:52 <lambdabot>     Couldn't match expected type `a -> b'
14:24:52 <lambdabot>            against inferred type `Reader r a1'
14:24:52 <lambdabot>     Probable cause: `Reader' is applied to too many arguments
14:24:53 <olsner> @ty flip . (flip flip id . liftM2 . flip)
14:24:54 <vixey> \xy a -> x a(y a)
14:24:54 <lambdabot> forall a b c. (a -> b -> c) -> a -> (a -> b) -> c
14:25:01 <vixey> \ xy a -> x a(y a)
14:25:41 <olsner> chrisdone: you'll learn eventually :)
14:25:47 <tromp__> > ap x y z
14:25:49 <lambdabot>   Couldn't match expected type `m (a -> b)'
14:25:53 <chrisdone> olsner: what?
14:26:03 <vixey> > ap f x y :: Expr
14:26:04 <lambdabot>   Couldn't match expected type `t -> a' against inferred type `Expr'
14:26:06 <Holle_> if i want to give a gtk2hs programm to someone else he needs some libraries of gtk2hs. could i include the libraries in the exe-file?
14:26:18 <olsner> chrisdone: recognising the S combinator from a type
14:26:34 <tromp__> S is ap on the Reader monad
14:26:34 <chrisdone> olsner: I said that I did
14:26:40 <chrisdone> ohn/m
14:27:06 <chrisdone> :t ap zip tail
14:27:08 <lambdabot> forall b. [b] -> [(b, b)]
14:27:13 <olsner> chrisdone: oh! I see... reference resolution failed there
14:27:14 <dcoutts> Holle_: no, the gtk .dll files are all separate. However it's easy to build an installer that installs all the .dll files. For example see: http://haskell.org/~duncan/gtk2hs/LSystemSetup.exe
14:27:15 <chrisdone> > ap zip tail [1..5]
14:27:16 <lambdabot>   [(1,2),(2,3),(3,4),(4,5)]
14:27:29 <BONUS_> zip`ap`tail
14:27:30 <BONUS_> w00t
14:27:30 * chrisdone screams
14:27:37 <dcoutts> Holle_: that installer installs a demo program and the target machine does not need gtk or ghc installed first. It's completely standalone.
14:27:47 <BONUS_> its cool cause i pronounce it like: zip up tail
14:28:07 <chrisdone> hur
14:28:18 <olsner> neat trick, that
14:28:37 <tromp__> :t ap const const
14:28:39 <lambdabot> forall a. a -> a
14:28:48 <tromp__> SKK=I
14:28:55 <BONUS_> haha
14:28:57 <ddarius> SKx=I
14:28:57 <BONUS_> interesting
14:29:03 <mauke> fmap fix return, bitches
14:29:06 <Holle_> do i need an installer? couldn't i pack the files in my directory?
14:29:34 <olsner> > ap const undefined 3
14:29:35 <lambdabot>   3
14:29:48 <tromp__> SK*=I
14:30:03 <BONUS_> > ap const undefined $ 4
14:30:05 <lambdabot>   4
14:30:08 <olsner> @ty fmap fix return
14:30:10 <lambdabot> forall a. a -> a
14:30:29 <ddarius> SK(fmap fix return) = I
14:30:37 <olsner> eh, (fix . const)?
14:32:32 <Holle_> the problem is, that i can't install programs at school :/
14:32:38 <Holle_> so it must be portable
14:33:01 <ddarius> Compile your code to javascript and run it in a web browser.
14:33:04 <chrisdone> > zip <*> tail $ [1,2,3,4,5]
14:33:06 <lambdabot>   [(1,2),(2,3),(3,4),(4,5)]
14:33:27 <pumpkin> fancy
14:33:33 <Holle_> ddarius: how to convert haskell to js?
14:33:54 <Raevel> (-:
14:34:08 <pumpkin> omg an anchor!
14:34:14 <baaba> > flip zip =<< tail $ [1, 2, 3, 4, 5]
14:34:15 <lambdabot>   [(1,2),(2,3),(3,4),(4,5)]
14:34:17 <pumpkin> |-) is geordi
14:34:29 <dons> Holle_: via json?
14:34:51 <vixey> didn't JHC do it?
14:34:55 <baaba> @src (->) =<<
14:34:55 <lambdabot> Source not found. Just try something else.
14:35:00 <baaba> @src (->) >>=
14:35:00 <lambdabot> Source not found. You speak an infinite deal of nothing
14:35:03 <baaba> :(
14:35:08 <BONUS_> @src ((->) a) (>>=)
14:35:09 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
14:35:38 <rwbarton> vixey: YHC does it
14:35:45 <Toxaris> why would cabal-install install an already installed package -- and fail?
14:35:49 <pumpkin> @src (->) return
14:35:49 <lambdabot> return = const
14:35:58 <Holle_> json includes the needed libraries?
14:35:59 <pumpkin> @src (->) fail
14:35:59 <lambdabot> Source not found. My mind is going. I can feel it.
14:38:04 <dons> Holle_: for generating java script object notation from haskell, yes.
14:38:07 <SexyCammy> hey baby, 27/f/sexycammy. com         ......u like to c me get freaky? cum watch me at sexycammy. com. im there.. my cam here isnt working. c ya
14:38:11 --- mode: ChanServ set +o dons
14:38:13 --- mode: dons set +b *!*=SexyCamm@*.dynamic.caiway.nl
14:38:13 --- kick: SexyCammy was kicked by dons (dons)
14:38:15 <chrisdone> @vixen baby
14:38:15 <lambdabot> I Think you're fake
14:38:17 --- mode: ChanServ set -o dons
14:38:45 * pumpkin imagines the +o as being like a katana
14:39:06 <pumpkin> you gracefully and quickly unsheathe it, do the deed, and then quickly put it back
14:39:29 <thoughtpolice> i prefer to think of it as a BFG9000
14:39:32 <pumpkin> lol
14:39:36 <thoughtpolice> because that's *awesome*
14:39:46 <pumpkin> OVER 9000!
14:39:51 <baaba> "my cam here on irc isn't working"
14:40:10 <baaba> @src (->) (>>=)
14:40:10 <lambdabot> f >>= k = \ r -> k (f r) r
14:40:30 <pumpkin> that's it
14:40:37 <pumpkin> @src join
14:40:37 <lambdabot> join x =  x >>= id
14:41:02 <pumpkin> > join (+) 6
14:41:03 <lambdabot>   12
14:43:29 <olsner> @ty flip . (=<<) -- chrisdone, this seems to be your function above in an easier pointless form
14:43:30 <lambdabot> forall b a b1. (a -> b -> b1) -> b -> (b -> a) -> b1
14:44:34 <jeffwheeler> I'm trying to catch an exception, but I'm not quite sure why it's not happening "monadically."
14:44:35 <jeffwheeler> http://hpaste.org/13869
14:45:09 <jeffwheeler> If I feed it a URI that doesn't exist, e.g. http://google.example.org/random.fake.xml, it crashes: getHostByName: does not exist (no such host entry).
14:45:43 <jeffwheeler> I would expect, though, for makeRequest to return IO (Nothing) . . . although that syntax is wrong, I think
14:46:14 <Cale> jeffwheeler: IO is something at the type level, so perhaps you mean IO (Maybe SomethingOrOther) ?
14:46:24 <chrisdone> anyone written an IRC library yet?
14:46:36 <pumpkin> chrisdone: I thought I saw one on hackage
14:46:36 <jeffwheeler> Cale: yeah; it's a Maybe Request, but I mean, if the request fails it should return Nothing
14:46:41 <Cale> ah, yeah
14:46:51 <chrisdone> pumpkin: that's probably the parser. I'm talking about a connection managing one
14:46:54 <Cale> Well, perhaps it's throwing an exception instead for some reason.
14:46:58 <pumpkin> ah
14:47:03 <jeffwheeler> Cale: it would seem that way. :-/
14:47:09 <SyntaxNinja> Igloo: heya, you around?
14:47:23 <jeffwheeler> Cale: but that seems very odd, since it already returns a Result (which is just an Either)
14:47:33 <Cale> okay, let me try it
14:47:46 <Cale> er...
14:47:52 * centrinia needs a fully-automatic six-barrel BFG-9000.
14:47:56 <Cale> Can I sensibly run this code?
14:48:27 <jeffwheeler> Cale: I can make a tar of the entire folder, if you like. It's a cabal package, but all the Aggregate.* imports can be removed, instead.
14:48:39 <Cale> ah, okay, I'll just do the latter
14:48:59 <jeffwheeler> Simply run driver' with the URI I gave (http://google.example.org/random.fake.xml) as a String.
14:49:07 <Cale> What package is Text.Feed.Query in?
14:49:20 <jeffwheeler> Oh, you can delete that, but it's from feed.
14:49:43 <Igloo> SyntaxNinja: Yup
14:49:49 <Cale> okay
14:50:32 <SyntaxNinja> Igloo: just wondering if you guys are counting on me to renew our tektonic account, or if anything was going on relating to that.
14:51:11 <Igloo> SyntaxNinja: Do you know when the current deal ends?
14:51:31 <BMeph> @ty ap zip . map
14:51:32 <lambdabot> forall a b. (a -> b) -> [a] -> [(a, b)]
14:51:39 <SyntaxNinja> Igloo: I can figure it out, I don't know offhand... I wasn't sure if it was something you were counting on me to watrch or if someone else was watching that.
14:52:09 <matthewp> :t (length . filter ((== 0) . flip mod 3) . map (flip (^) 2))
14:52:11 <lambdabot> forall a. (Integral a) => [a] -> Int
14:52:20 <Cale> jeffwheeler: I get "Just HTTP/1.1 404 Not Found ..."
14:52:22 <Igloo> SyntaxNinja: I'm counting on you, because I'm pretty sure I don't have that info  :-)
14:52:41 <SyntaxNinja> you have the tektonic password, though, I thought.
14:52:49 <jeffwheeler> Cale: Hmm, I'll try simplifying it and see if I can replicate it in a simpler example
14:52:55 <jeffwheeler> Cale: thanks
14:53:31 <Cale> jeffwheeler: Hmm...
14:53:48 <Igloo> SyntaxNinja: Hmm, can I find out from that?
14:53:51 <matthewp> > (length . filter ((== 0) . flip mod 3) . map (flip (^) 2)) [1..30]
14:53:52 <lambdabot>   10
14:53:52 <Cale> jeffwheeler: The error message you're getting would seem to indicate the problem is in DNS resolution?
14:54:29 <SyntaxNinja> Igloo: from the billing interface I'm guessing, but not sure.
14:54:32 <jeffwheeler> Cale: exactly; DNS generally works fine on my machine (it can make a request to another valid site immediately before that), so I'll keep playing
14:55:01 <Cale> I think the difference in behaviour might be something sketchy that my ISP does.
14:55:49 <centrinia> Cale, would exceptions be appropriate here?
14:56:17 <Igloo> SyntaxNinja: Hmm, if I go to https://72.249.126.23:4643/vz/cp then I'm told "The certificate is only valid for ares.sw.ru", which sounds a little scary
14:56:41 <jeffwheeler> http://hpaste.org/13869#a1 ; this version (without any other dependencies that the other version had) causes the same error for me
14:56:43 <Cale> centrinia: hm?
14:56:48 <SyntaxNinja> yow
14:56:50 <jeffwheeler> Anybody else able to try it, too?
14:57:31 <rwbarton> jeffwheeler: I get the error you got
14:57:40 <jeffwheeler> rwbarton: thanks
14:57:48 <Cale> ah, okay, now I've got the same behaviour (after removing my ISP's sketchy DNS server from my resolv.conf)
14:58:03 <Cale> Yes, it's throwing an exception when it doesn't find the host.
14:58:23 <jeffwheeler> Is that a bug, or just something I didn't expect?
14:58:33 <Cale> Little bit of both.
14:58:37 <centrinia> Jeff, it works if I changed the URI. :>
14:58:45 <jeffwheeler> centrinia: :D
14:59:41 <Toxaris> jeffwheeler: Network.TCP.openTCPConnection calls Network.BSD.getHostByName without caring for its possible exception
15:03:33 <Cale> jeffwheeler: okay, do this:
15:03:37 <Cale> ioToConnError :: IOException -> IO (Either ConnError a)
15:03:37 <Cale> ioToConnError e = return (Left (ErrorMisc (show e)))
15:03:42 <Cale> makeRequest r = do response <- simpleHTTP r `catch` ioToConnError
15:03:50 <Cale> (and the rest the same)
15:05:48 <Cale> Note the type signature on ioToConnError is required due to the annoying new exception library. ;)
15:06:38 <jeffwheeler> One second; trying it. Had to find the imports.
15:06:46 * rwbarton would like to take the opportunity to plug the download-curl package
15:06:50 <jeffwheeler> (And fix conflicting `catch`s
15:07:01 <Cale> oh, needs Control.Exception, and import Prelude hiding (catch)
15:07:04 <jeffwheeler> yep
15:07:27 <jeffwheeler> Cale: works perfectly; thanks!
15:08:07 <Cale> It's rather stupid that simpleHTTP doesn't catch the exception thrown by DNS failure.
15:08:28 <jeffwheeler> Cale: I'll email bjorn@, unless you have a better place to report it.
15:09:28 <centrinia> Why should simpleHTTP catch the exception?
15:09:28 <Cale> If he's the maintainer, that should do it.
15:09:49 <Cale> centrinia: Because the Result type reflects exceptions like that already.
15:10:00 <centrinia> Ah.
15:10:06 <Cale> type Result a = Either ConnError a 	-- Defined in Network.Stream
15:10:18 <Cale> I would expect a DNS failure to be a ConnError
15:10:50 <gwern> ertai: gnome-terminal, and the system default font, whatever that is for ubuntu. probably one of the bitstreams
15:10:51 <Cale> data ConnError = ErrorReset | ErrorClosed | ErrorParse String | ErrorMisc String -- Defined in Network.Stream
15:11:43 <jeffwheeler> Cale: thanks for the help, again.
15:11:46 <pao> Cale: could you elaborate your view on new exceptions in 6.10? :-)
15:12:13 <Cale> pao: Theoretically, they're great, but they make the usual style of catching exceptions impossible.
15:12:57 <pao> Cale: could you make a quick/naive example for a newbie?
15:12:59 <Cale> pao: Basically, you are forced to supply explicit type signatures in order to avoid ambiguous types
15:13:02 <Cale> Sure.
15:13:27 <Cale> Suppose I have  xs <- readFile "foo"
15:13:48 <Cale> but the file might not exist, and in that case, I'd like to catch the exception and make xs be the empty string
15:14:35 <Cale> er, actually, let's go with xs being the error string
15:15:09 <Cale> well, it doesn't matter
15:15:25 <Cale> It used to be that we could write:  xs <- readFile "foo" `catch` \e -> return ""
15:15:34 <pao> Cale: xs :: Maybe String?
15:15:44 <Cale> Or sure, that'll work:
15:15:51 <pao> ok
15:15:54 <pao> that's clear
15:15:56 <Cale> xs <- fmap Just (readFile "foo") `catch` \e -> return Nothing
15:16:21 <pao> xs <- Just . readFile $ "foo" `catch` \e -> return Nothing
15:16:28 <Cale> But with the new Control.Exception, that no longer works.
15:16:39 <Cale> No, that isn't what you mean :)
15:17:03 <Cale> $ binds more weakly than `catch` ;)
15:17:03 <pao> liftM Just
15:17:05 <pao> :t liftM Just . readFile
15:17:08 <lambdabot> FilePath -> IO (Maybe String)
15:17:13 <pao> ah, ok :-)
15:17:25 <pao> nevermind... please continue
15:17:25 <Cale> But in any event
15:17:40 <Cale> The new Control.Exception has  catch :: Exception e => IO a -> (e -> IO a) -> IO a
15:18:01 <Cale> But \e -> return Nothing  doesn't tell us the type of e
15:18:19 <Cale> and so that type variable is ambiguous, and the instance of Exception to use can't be determined
15:18:24 <Cale> So we get a type error.
15:18:50 <Cale> So you *always* need to explicitly type your exception handlers, which is annoying.
15:18:58 <Toxaris> Cale: so define catchIO :: IO a -> (IOException -> IO a) -> IO a; catchIO = catch
15:19:07 <Toxaris> or do I miss something?
15:19:38 <Cale> Toxaris: that would pretty much do it, but neither of these is really satisfactory
15:19:55 <Toxaris> of course that is still "explicit typing", but with less typing
15:20:00 <byorgey> @seen vixey
15:20:00 <lambdabot> I saw vixey leaving #scala, #perl6, ##logic and #haskell 19m 52s ago, and .
15:20:01 <Cale> yeah
15:20:25 <Toxaris> would be cool if you could still say "all exceptions"
15:21:15 <Toxaris> `catch` (/\E -> \ (e :: E) -> Nothing)
15:21:32 <Toxaris> instance Exception (forall (Exception e) => e) where ...
15:21:41 <rwbarton> I thought you could, using SomeException
15:21:44 <rwbarton> , src ''SomeException
15:21:45 <lunabot>  luna: Not in scope: type constructor or class `SomeException'
15:21:52 <Cale> data SomeException = forall e . Exception e => SomeException e
15:22:00 <Toxaris> oh hehe :)
15:22:26 <pao> Cale: would not SomeException be satisfatory?
15:22:29 <Cale> But it still doesn't avoid the need of supplying an explicit type signature. It's not a first class existential.
15:23:05 <Toxaris> as I understand things, there cannot be infered first-class existentials
15:23:15 <Cale> yeah
15:23:18 <Toxaris> and explicit first-class existentials would be still explicit
15:23:27 <Toxaris> (but so much cooler imho)
15:23:27 <Cale> A first-class variant would work though.
15:23:59 <Cale> catch :: IO a -> (Variant (r :: Row)) -> IO a) -> IO a
15:24:18 <pao> Cale: so, to conclude, you would have left things at 6.8 status quo?
15:25:10 <Cale> pao: Well, I've found the new library more annoying. Even though it's closer to the ideal, it's like it's moved into some valley which is closer to the real goal, but worse than what we had before.
15:25:51 <pao> Cale: nice metaphor :-)
15:26:26 <jeffwheeler> I was particularly impressed. It could have used some more colorful imagery, though.
15:27:02 <pao> Cale: it seems a difficult journey
15:27:05 <pao> :.-)
15:27:20 <Cale> We really need polymorphic records and variants.
15:27:25 <Toxaris> Maybe it is a valley in a rainforest, full of tigers and dangerous snakes?
15:27:47 <Cale> It seems like the people knowledgeable enough about the GHC codebase to implement them are working on other things though.
15:28:03 <pao> Cale: is that any work on the topics? SPJ is working on it, right?
15:28:16 <Cale> Not as far as I'm aware.
15:28:33 <acidjnk> hello
15:28:58 <acidjnk> What's the infered type of _ in "length=foldr(\_ n -> 1+n) 0"?
15:29:00 <Cale> There is work on it. In fact, there's enough work that I'm fairly sure there's an acceptable solution available with minimal piecing together of proposals.
15:29:13 <Cale> :t let length=foldr(\_ n -> 1+n) 0 in length
15:29:14 <lambdabot> forall a b. (Num b) => [a] -> b
15:29:32 <BONUS_> @pl \a n -> 1 + n
15:29:33 <lambdabot> const (1 +)
15:30:08 <acidjnk> So what is it?
15:30:08 <jeffwheeler> That could, I'm sure, be 'fix'ed, but I have no idea how.
15:30:29 <rwbarton> :t foldr (\a n -> (a `asTypeOf` ?f) `seq` (1+n)) 0
15:30:30 <lambdabot> forall a b. (Num b, ?f::a) => [a] -> b
15:30:32 <Cale> I think we should steal Daan Leijen's formalism for polymorphic records/variants with first class labels, and use a slightly different syntax which is suggestive of lenses.
15:31:09 <rwbarton> :t foldr (\a n -> let b = a `asTypeOf` ?f in 1+n) 0
15:31:10 <lambdabot> forall a b. (Num b) => [a] -> b
15:31:27 <Cale> Well, we might have to think a bit about what operations we'd like to support.
15:31:34 <rwbarton> acidjnk: it's the type of an element of the list argument
15:31:37 <Toxaris> after my troubles with cabal install, I decided to try ghc 6.10. Now cabal install runs into out of memory.
15:31:47 <acidjnk> thanks rwbarton
15:32:05 * Toxaris gives up for today
15:32:06 <dcoutts> Toxaris: upgrade to 0.6, that version works with ghc-6.10
15:32:24 <dcoutts> Toxaris: 0.5.x has the bug you describe, when used with ghc-6.10
15:32:33 <acidjnk> So the inner function has two arguments: a list element and a number. And the result is a number.
15:32:46 <Cale> acidjnk: yeah
15:33:09 <Cale> acidjnk: You can think of foldr f z as replacing each (:) in the list with f and the [] at the end with z
15:33:41 <Cale> acidjnk: So [] is replaced with 0, and (:) is replaced with the function which ignores its first parameter, and adds 1 to its second.
15:33:53 <pao> Cale: thanks ... I really think you deserve a statue :-) .... or, at least, a portraint in ascii art on haskell.org homepage :-)
15:34:05 <Cale> :)
15:34:07 <Toxaris> dcoutts: update as in "download and install Cabal and cabal-install by hand"?
15:34:36 <sacko> hi all, could someone please help me with a small type checking problem in my parser please? http://hpaste.org/13870, i've been trying to sort it for while now, but can't think of a way around it.
15:34:57 <Cale> acidjnk: The result of doing this, of course, will be the number of (:)'s in the list, that is, the number of elements.
15:35:06 <rwbarton> sacko: you shadowed the name "return" :)
15:35:12 <rwbarton> sacko: Don't do that :)
15:35:48 <dcoutts> Toxaris: not Cabal as ghc-6.10 comes with the necessary version
15:36:01 <BMeph> Cale: Do you know of any more introductory text to lenses besides the Boomerang one? It isn't too tough for me, I'm just hoping there's something out there that's shorter. :)
15:36:07 <Toxaris> dcoutts: ah I see.
15:36:11 <dcoutts> Toxaris: if you've still got ghc-6.8 or older installed then you can still use that, eg cabal install cabal-install -w ghc-6.8.2
15:36:11 <Cale> BMeph: Not that kind of lenses.
15:36:27 <acidjnk> thanks
15:36:33 <Toxaris> dcoutts: well, I could not cabal-install cabal install for ghc-6.8.2 with ghc-6.8.2
15:36:43 <Cale> BMeph: I'm referring to the kind of lenses which are relevant to records.
15:36:52 <Toxaris> dcoutts: when ghc-6.10 was not install, so why should it work now
15:36:53 <sacko> rwbarton> thanks mate, i didn't think of that.
15:36:56 <dpratt71_> another newbie question (how many do I get?)...
15:37:06 <dcoutts> Toxaris: are you sure? that infinite loop bug is only when it's used with 6.10
15:37:13 <Cale> dpratt71_: You have infinite lives.
15:37:19 <dcoutts> Toxaris: it works fine for me, building it with 6.8
15:37:21 <dpratt71_> ...I'm trying to get my head around Monad...
15:37:24 <dpratt71_> ...looking at the definition of ">>=", which is
15:37:25 <Toxaris> dcoutts: had a different bug
15:37:25 <dpratt71_>    x >>= f = join (fmap f x)
15:37:40 <dcoutts> Toxaris: please send me the details tomorrow
15:37:44 <acidjnk> But the content shouldn't matter, and isn't n content? For example in length [1,2,3] wouldn't the foldr "grab" the 3 at some point, thinking it is the n?
15:37:46 <Toxaris> dcoutts: cabal installed insisted on reinstalling my installed network-2.1.0.0, but failed with same c stuff
15:37:48 <Cale> dpratt71_: That's a definition in terms of join and fmap... but sometimes join and fmap are defined in terms of >>=
15:37:48 <dpratt71_> first: can I say that "f" is a -> a ?
15:37:55 <Cale> no...
15:37:59 <Cale> f :: a -> m b
15:38:06 <Cale> x :: m a
15:38:10 <dpratt71_> off to a good start then ;)
15:38:11 <Cale> x >>= f :: m b
15:38:13 <Toxaris> dcoutts: ok will send you email.
15:38:25 <dcoutts> Toxaris: ah, that's most likely due to having a package with the exact same version number installed in the global and user package db. That confuses cabal-install no end.
15:38:26 <BONUS_> join :: m (m a) -> m a
15:38:34 <BMeph> Cale: Oh? Do you have a text for that, because I thought the Boomerang text does use records. :)
15:38:40 <dmwit> All three of Cale's type annotations are contained in the type of (>>=) if you look carefully:
15:38:41 <dmwit> :t (>>=)
15:38:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:38:52 <dcoutts> Toxaris: check ghc-pkg list for any exact version duplicates between the global and user
15:39:01 <dmwit> :t ?x >>= ?f
15:39:02 <lambdabot> forall (m :: * -> *) a b. (Monad m, ?f::a -> m b, ?x::m a) => m b
15:39:04 <pao> what is the precedence of function in backticks?
15:39:05 <Cale> BMeph: Er, maybe I'm not sure about what you mean by Boomerang.
15:39:12 <BMeph> @go Boomerang lenses
15:39:14 <dpratt71_> then apply fmap to f, which returns something that goes from Monad a -> Monad b ?
15:39:16 <lambdabot> http://www.cis.upenn.edu/~bcpierce/papers/boomerang.pdf
15:39:16 <lambdabot> Title: Boomerang: Resourceful Lenses for String Data
15:39:24 <BMeph> Cale: That one. :)
15:40:01 <Cale> Okay, I'm pretty sure I haven't seen that.
15:40:16 <Cale> It does look somewhat relevant.
15:40:16 <dmwit> The paper on quotient lenses is pretty readable.
15:40:52 <Cale> The basic idea is that each field label comes with projections onto each of the record operations.
15:40:53 <BMeph> Cale: Oh, what paper(s) have you read on it? Maybe there's something short in that list...? :)
15:41:06 <Cale> I've read mostly mailing list and blog entries.
15:41:41 <Cale> I'll sketch out what things would look like in the system I'd like to see in Haskell.
15:42:00 <dpratt71_> assuming what I just said was right, then apply (fmap f) to x ?
15:42:18 <BMeph> Cale: Hmm, okay, I guess I should just move Daan's paper and the two Pierce ones to the top of my stack, then. :)
15:42:21 <Cale> dpratt71_: One moment and I'll be with you :)
15:42:24 <ski_> Lens a b = a -> (b,b -> a)
15:42:29 <acidjnk> Ok, I didn't consider that foldr works from the right, and at the right there is the 0, so it never grabs an element from the list as n.
15:42:38 <Cale> BMeph: Well, Daan's paper uses a more awkward syntax.
15:42:39 <dmwit> dpratt71_: One problem you might have is that Monad is not a type.
15:42:44 <dmwit> dpratt71_: Monad is a class of types.
15:43:01 <dmwit> dpratt71_: So, we choose a specific instance of Monad.
15:43:13 <dpratt71_> I *think* I get that...
15:43:25 <Toxaris> dcoutts: how do I make ghc-pkg report results from my old ghc-6.8.2?
15:43:42 <dmwit> dpratt71_: In other words, "Monad a -> Monad b" isn't a real type; you'd have to choose a particular monad (we usually call it 'm' when we don't need to be specific).  Then the type would be "m a -> m b".
15:43:54 <dpratt71_> ok
15:44:06 <dmwit> dpratt71_: Also, "fmap f :: m a -> m b" is not quite right.
15:44:15 <pao> Toxaris: ghc-pkg-6.8.3
15:44:16 <dpratt71_> please clarify
15:44:17 <BMeph> For some f :: a -> b, ap (return f) == (>>= (return . f))
15:44:24 <dmwit> dpratt71_: In fact, it's "fmap f :: m a -> m (m b)", that is, fmap nests things "too deeply".
15:44:34 <pao> Toxaris: you should use old ghc-pkg binary
15:44:36 <dmwit> dpratt71_: The "join" takes care of the extra nesting.
15:44:50 <dpratt71_> oh, I was wondering what the "join" was doing
15:45:43 <dmwit> dpratt71_: However, unless you've already grokked Functor, this approach to learning Monad seems tricky.
15:45:50 <Cale> BMeph: We'd have operations like  get :: l -> (l : t | r) -> t, extend :: l -> t -> r -> (l : t | r), delete :: l -> (l : t | r) -> r
15:45:52 <dmwit> dpratt71_: Since it might seem like turtles all the way down.
15:46:06 <Cale> Where l :: Label, r :: Row, t :: Type in each case
15:46:07 <dpratt71_> turtles?
15:46:26 <digitalexander> Hi guys, newbie here... I just started learning Haskell, is there broad consensus in the community that RWH is the best Haskell book around? Or would you recommend others?
15:46:29 <dmwit> dpratt71_: Each instance of Monad typically has a different implementation of (>>=).
15:46:32 <angelixd> category theory = set theory on crack
15:46:32 <ski_> Cale : what are the values in `l' ?
15:46:55 <Philippa_> dpratt71_: "The world is carried by an elephant, and the elephant is carried by a turtle" "What does the turtle stand on?" "It's turtles all the way down!"
15:46:58 <Cale> ski_: Each label type is inhabited with a single value derived from its name.
15:47:01 <Toxaris> pao, dcoutts: thanks. ghc-pkg-6.8.2 does not work for my poor windows box, but using the old binary does. However, it does not report different results for --user and --global :(
15:47:21 <Philippa_> (see also, "what was the first cause, and what caused it?")
15:47:21 <Cale> ski_: I'd steal names starting with a single quote (which are not character literals)
15:47:29 <ski_> Cale : so `Label' is a kind ?
15:47:38 <Cale> ski_: 'fieldLabel :: ('fieldLabel :: Label)
15:47:38 <Cale> yes
15:47:41 <BONUS_> digitalexander: RWH is pretty much awesome
15:47:41 <dpratt71_> is it necessary to implement >>== to have a monad...I mean can you define "join" instead?
15:47:48 <BONUS_> and there are a lot of kewl online resources
15:47:56 <dmwit> dpratt71_: Practically, or theoretically?
15:48:00 <rwbarton> Cale: TH has already stolen them
15:48:00 <ski_> dpratt71_ : yes you can
15:48:04 <rwbarton> , src 'id
15:48:09 <lunabot>  id :: forall a . a -> a
15:48:09 <dpratt71_> ah, thanks for that Philippa
15:48:10 <Toxaris> dpratt71_: you can define >>= in terms of join
15:48:11 <Cale> rwbarton: I know, that's problematic.
15:48:18 <dmwit> dpratt71_: Practically, you have to implement (>>=) because Haskell's Monad/Functor hierarchy is broken.
15:48:25 <pao> Toxaris: what options did you use exactly?
15:48:32 <dpratt71_> supposing you define join instead, will fmap be used in that case?
15:48:39 <digitalexander> BONUS_: Yeah, I noticed every single paragraph has comments, that's a pretty new approach to a book.
15:48:39 <dmwit> dpratt71_: But if you fixed the hierarchy, you could define join, fmap, and return.
15:48:45 <Saya> normally you can build >>= out of join and fmap
15:49:01 <rwbarton> @src Monad
15:49:02 <lambdabot> class  Monad m  where
15:49:02 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
15:49:02 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
15:49:02 <lambdabot>     return      :: a -> m a
15:49:02 <lambdabot>     fail        :: String -> m a
15:49:05 <dmwit> (instead)
15:49:20 <pao> :t join . fmap
15:49:21 <lambdabot>     Occurs check: cannot construct the infinite type: f = (->) (f a)
15:49:21 <lambdabot>     Probable cause: `fmap' is applied to too many arguments
15:49:21 <lambdabot>     In the second argument of `(.)', namely `fmap'
15:49:22 <Toxaris> pao: I am in ghc-6.8.2\bin directory, and use "ghc-pkg list --user", and "ghc-pkg list --global"
15:49:25 <dmwit> (Fixing the hierarchy would include removing fail, in my opinion. ;-)
15:49:26 <Cale> ski_: Does that make sense to you? I haven't completely fleshed it out in my head, so it might need some tweaking.
15:49:31 <dmwit> :t (join .) . fmap
15:49:32 <lambdabot> forall a a1 (f :: * -> *). (Functor f, Monad f) => (a1 -> f a) -> f a1 -> f a
15:49:38 <dmwit> pao: That?
15:49:39 <Toxaris> pao: and they return the exact same results, both starting with the path of the global package.conf
15:49:40 <ski_> Cale : what happens if i `extend' with the same `l' two times ?
15:49:51 <Cale> ski_: You get stack-like behaviour.
15:49:53 <pao> Toxaris: I think ghc-pkg list doesn't support --user --system flags
15:49:59 <dpratt71_> "Haskell's Monad/Functor hierarchy is broken." is there a simple (-ish) explanation?
15:50:02 <BONUS_> digitalexander: this is a pretty good writeup on the different tutorials: http://haskell.org/haskellwiki/Tutorials
15:50:20 <Cale> ski_: That is, there's no problem with records having the same label multiple times.
15:50:27 <Philippa_> dpratt71_: one of the components of a monad is a functor. But not all Monads are Functors
15:50:38 <Philippa_> (the reliable name for fmap on Monads is liftM)
15:50:40 <ski_> Cale : so `(l0 : t0 | (l1 : t1 | r)) = (l1 : t1 | (l0 : t0 | r))' only if `l0' is not `l1' ?
15:50:46 <Toxaris> pao: oh you are right, --user just means "show global *and* user packages"
15:50:57 <Toxaris> pao: and since I dont have user packages (I think), its the same thing
15:51:05 <Cale> ski_: Right.
15:51:07 <ski_> Cale : or are you required to only directly access the top field ?
15:51:25 <dmwit> dpratt71_: All monads are functors, but not all instances of Monad are required to be instances of Functor.  It's a shame.
15:51:34 <Cale> ski_: Only fields with distinct labels commute.
15:51:38 <pao> Toxaris: yep... but it should specify a line with user dir path
15:51:39 <dpratt71_> when you say "one of the components of a monad is a functor", are you referring to the concept or Haskell's definition of a monad?
15:51:49 <ski_> Cale : so you need some kind of evidence of label inequality, for polymorphism, then, aye ?
15:51:51 <Philippa_> dpratt71_: the mathematical structure
15:51:57 <dmwit> dpratt71_: A correct hierarchy would involve "class Functor m => Monad m where" instead of just "class Monad m where".
15:52:02 <Cale> I'm not sure that you do...
15:52:05 <dpratt71_> but Haskell doesn't enforce the math?
15:52:13 <dmwit> correct
15:52:18 <Cale> ski_: What operation would require that?
15:52:27 <Philippa_> dmwit: that's a mildly religious value of 'correct' (as opposed to 'more aesthetically pleasing')
15:52:28 <BONUS_> dmwit: wouldnt it be better to do "class Applicative m => Monad m where ..."
15:52:29 <dpratt71_> oh
15:52:38 <Toxaris> pao: but that has changed to ghc-6.10.1, which accepts --global and --user to mean only global, or only user.
15:52:50 <ski_> Cale : say i want `l0' and `l1' to be polymorphic in some type .. then we don't know at that point whether `l0' is apart from `l1'
15:52:51 <dpratt71_> is Functor a "monoid" ?
15:52:56 <dmwit> Philippa_, BONUS_: Yes. =)
15:52:57 <pao> Toxaris: yep
15:53:02 <Philippa_> dpratt71_: nope. Two separate concepts
15:53:07 <dpratt71_> dang
15:53:22 <dmwit> dpratt71_: Monoids don't even have the same kind. =)
15:53:22 <Toxaris> pao: so how can I check for a package registered both as user and global, as dcoutts suggested, for my old ghc?
15:53:24 <digitalexander> BONUS_: Thanks for the link and the reassurance on the quality of RWH
15:53:32 <Philippa_> though there's a monoid (mathematically) that can be constructed from any monad - and that's part of how monads got their name
15:53:34 <BONUS_> haha np
15:53:38 <Cale> ski_: okay.
15:53:40 <pao> Toxaris: you find it reported twice
15:53:45 <Philippa_> IIRC it's a contraction of "monoidal triad" or something similar
15:53:53 <digitalexander> BONUS_++
15:53:56 <BONUS_> :]
15:54:03 <dmwit> dpratt71_: If you have a Monad m, you talk about monad values "m a"; but if you have a Monoid m, m is already a type without applying it to any other type variables.
15:54:07 <BONUS> ugh
15:54:07 <ski_> (possibly `triple', in that case)
15:54:13 <Cale> Monads are monoid objects in a particular category.
15:54:14 <BONUS> hsould have changed before >_>;;
15:54:19 <pao> @paste
15:54:20 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:54:31 <dpratt71_> so monoids are more general?
15:54:34 <bmh> hey -- I'm having difficulty converting Ratio's to Floats. I think I'm overflowing something because I get NaN as a result. If I pull out the numberator and denominator and run 'em through scheme I get a reasonable answer.
15:54:35 <Cale> (Where a monoid object is the categorical generalisation of a monoid)
15:54:47 <pao> Toxaris: that's my output... http://hpaste.org/13871... hope it helps
15:54:49 <Philippa_> dpratt71_: yeah. Monoids pretty much sum up what we mean by a 'sequence'
15:54:57 <Cale> bmh: realToFrac?
15:54:59 <Philippa_> for example, strings and lists are monoids
15:55:00 <dcoutts> Toxaris: ghc-pkg-x.y list
15:55:06 <dpratt71_> "Where a monoid object is the categorical generalisation of a monoid" stack overflow?
15:55:09 <ski_> (dpratt71_ : depends whether you're talking about plain set monoids .. or a category theoretic generalization thereof)
15:55:18 <acidjnk> Why is "foldr (\x xs -> xs ++ [x]) []" not the identity function for lists? Isn't it: foldr (\x xs -> xs ++ [x]) [] [1,2,3,4] -> 1o2o3o4o[] -> 1o2o3o[]++[4] -> ...?
15:55:18 <Philippa_> there's a monoid on numbers based around addition and another on multiplication...
15:55:24 <Cale> dpratt71_: It's not required to understand that. ;)
15:55:25 <bmh> Cale: (fromIntegral $ numerator n) / (fromIntegral $ denominator n)
15:55:38 <Cale> bmh: ah, use realToFrac
15:55:41 <BONUS> acidjnk: that should fold from the left
15:55:43 <BONUS> to be the identity
15:55:58 <Cale> bmh: Most likely, the numerator and denominator are too large for Float.
15:55:58 <Philippa_> ski_: I think it's fair enough to stay in a categorical setting here though :-)
15:55:59 <ski_> > foldr (\x xs -> xs ++ [x]) [] [1,2,3,4]
15:55:59 <BONUS> > foldl (\x xs -> xs ++ [x]) [] "w00t"
15:56:04 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
15:56:04 <lambdabot>        Expect...
15:56:04 <lambdabot>   [4,3,2,1]
15:56:05 <rwbarton> bmh: you're not using Ratio Int are you?
15:56:12 <BONUS> ugh i mean
15:56:14 * dpratt71_ wonders if this will work...
15:56:17 <BONUS> > foldl (\xs x -> xs ++ [x]) [] "w00t"
15:56:18 <bmh> rwbarton: Ratio Integer
15:56:19 <lambdabot>   "w00t"
15:56:21 <dpratt71_> @src Functor
15:56:21 <lambdabot> class  Functor f  where
15:56:21 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
15:56:24 <Toxaris> pao: hmm, no user package database for me: http://hpaste.org/13871#a1
15:56:25 <acidjnk> I don't want the identity, and it isn't the identity.
15:56:26 <dmwit> acidjnk: "foldr f z xs" replaces : with `f` and [] with z in xs.
15:56:33 <rwbarton> > realToFrac ((2 * 10^100) / (10^100))
15:56:34 <lambdabot>   2.0
15:56:45 <ski_> (Philippa_ : well, i wasn't suggesting generalizing out of CT, here :)
15:56:46 <acidjnk> I want to find out why it is the reverse function
15:57:12 <BONUS> basically you have a list like [1,2,3,4] and the starting accumulator is []
15:57:14 <pao> Toxaris: try without using any flag (remove --user)
15:57:30 <Cale> > realToFrac (10000000000000000000000000000000000000000000000 % 10000000000000000000000000000000000000000000001) :: Float
15:57:31 <Saya> because [x] appends x at the end of the list?
15:57:31 <lambdabot>   1.0
15:57:38 <Cale> > fromIntegral (10000000000000000000000000000000000000000000000) / fromIntegral (10000000000000000000000000000000000000000000001) :: Float
15:57:39 <dmwit> acidjnk: So "foldr (\x xs -> xs ++ [x]) [] (1:2:3:4:[])" becomes "[] ++ [4] ++ [3] ++ [2] ++ [1]".
15:57:39 <lambdabot>   NaN
15:57:43 <rwbarton> > 10^100 :: Double
15:57:44 <lambdabot>   1.0000000000000002e100
15:57:45 <Cale> ^^ there is your problem
15:57:48 <BONUS> then you start from the left of the list and add it to the beginning of the accumulator
15:57:51 <rwbarton> > realToFrac ((2 * 10^1000) / (10^1000))
15:57:52 <lambdabot>   -Infinity
15:57:55 <bmh> Cale: my numbers are larger :)  I'm doing computation on the E. coli genome
15:57:57 <Philippa_> dpratt71_: a monoid consists of a type (or a set, or...), a binary operation on that type which I'll call * and an 'identity' element id. x * id = x, id * x = id. For strings, * = ++ and id = "", for example. For addition it's + and 0, for multiplication it's * and 1
15:58:01 <BONUS> then you go to the next element from the left and add that to the beginning of the accumulator
15:58:03 <BONUS> and so on
15:58:05 <acidjnk> But it starts with the 4, right?
15:58:07 <Cale> bmh: Use realToFrac for conversion.
15:58:13 <acidjnk> The first step is my problem.
15:58:19 <rwbarton> Cale: it doesn't seem to help much
15:58:25 <Cale> rwbarton: what?
15:58:26 <Philippa_> dpratt71_: can you see how that's "sequence"?
15:58:29 <rwbarton> > realToFrac ((2 * 10^1000) / (10^1000))
15:58:29 <pao> Toxaris: just for paranoia... check if you have GHC_PACKAGE_PATH env var set
15:58:29 <BONUS> acidjnk: a foldl starts with the 1
15:58:30 <lambdabot>   -Infinity
15:58:36 <bmh> Cale: running now. I should know if it works in a minute or two.
15:58:45 <rwbarton> Cale: That's more than a little bit wrong :)
15:58:49 <Philippa_> (though for some monoids, like the two number ones, the order doesn't really matter)
15:58:50 <acidjnk> Ok, but I have a foldr.
15:58:53 <rwbarton> Cale: Oops never mind
15:58:56 <rwbarton> > realToFrac ((2 * 10^1000) % (10^1000))
15:58:58 <Cale> rwbarton: I don't know what you're talking about.
15:58:58 <lambdabot>   2.0
15:59:02 <BONUS> reverse is foldl (\xs x -> x:xs) []
15:59:07 <BONUS> but yeah
15:59:07 <BONUS> aha
15:59:11 <BONUS> your example is foldr
15:59:11 <BONUS> i get it
15:59:13 <BONUS> anyway
15:59:14 <ski_> > foldr (\x xs -> f xs x) z [1,2,3,4]
15:59:15 <Toxaris> pao: ghc-pkg list  gives the very same output as  ghc-okg list --user
15:59:15 <lambdabot>   f (f (f (f z 4) 3) 2) 1
15:59:17 <BONUS> yeah it starts from the right then
15:59:21 <dmwit> > realToFrac ((2 * 10^1000 + 1) % (10^1000))
15:59:22 <lambdabot>   2.0
15:59:23 <Cale> rwbarton: Of course, that simplifies immediately anyway
15:59:30 <BONUS> [1,2,3,4] and it starts from the right and the accumulator is []
15:59:32 <Cale> dmwit's example is a better one :)
15:59:33 <acidjnk> Now it gets crazy.
15:59:36 <Philippa_> ski_: I don't believe your away message :-)
15:59:36 <BONUS> then it adds 4 to the end of the accumulator
15:59:36 <rwbarton> Cale: Right.
15:59:41 <pao> Toxaris: check for that env var... GHC_PACKAGE_PATH
15:59:44 <acidjnk> foldr ... is the reverse.
15:59:47 <BONUS> then it goes to the next element from the right, which is 3
15:59:50 <Toxaris> pao: no GHC_PACKAGE_PATH set
15:59:51 <bmh> > :t realToFrac ((2 * 10^1000 + 1) % (10^1000))
15:59:52 <lambdabot>   <no location info>: parse error on input `:'
15:59:53 <rwbarton> :t realToFrac
15:59:54 <BONUS> and adds that to the end of the accumulator
15:59:55 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
15:59:55 <BONUS> and so on
16:00:12 * Cale wishes he could keep up with all the threads of conversation here.
16:00:33 <acidjnk> But that would result in [1,2,3,4] which is the identity.
16:00:36 <ski_> (Philippa_ : well, it's supposedly true ..)
16:00:38 <dpratt71_> Philippa: yes, I think I see what you're saying...
16:00:48 <Cale> dpratt71_: Do you have much of a mathematical background? I could explain some category theory if that's the case.
16:00:50 <pao> Toxaris: I don't even know if user package db is supported on windows and, if yes, when and how
16:00:53 <ski_> (Philippa_ : forgot associativity, up there, btw)
16:00:55 <pao> Toxaris: sorry :-(
16:00:55 <Cale> dpratt71_: If not, then it's mostly distracting.
16:01:04 <rwbarton> , typeOf (let id' :: Real a => a -> a; id' = id in id' 3)
16:01:04 <dpratt71_> ...I'm going to try to grok Monads before Monoids, though...
16:01:05 <lunabot>  Integer
16:01:07 <Philippa_> ski_: d'oh, good catch. Thought I might've done
16:01:17 <dpratt71_> ...I touched that bees nest by accident
16:01:19 <rwbarton> , typeOf (let id' :: (Real a, Fractional a) => a -> a; id' = id in id' 3)
16:01:19 <Toxaris> pao: no problem, I don't *want* a user package db anyway, that's windows, good old boring single-user-per-computer philosophy
16:01:21 <lunabot>  Double
16:01:22 <BONUS> acidjnk: if you approach [1,2,3,4] from the right and keep adding to the end of the accumulator, then it ends up being the reverse
16:01:25 <pao> Toxaris: I'm pretty sure that if you installation had it, I would find as output for "ghc-pkg list"
16:01:28 <Philippa_> dpratt71_: I missed out that (x * y) * z = x * (y * z)
16:01:33 <Cale> dpratt71_: Monoids are simpler, but if your goal is to understand monads, you might as well ignore them.
16:01:37 <BONUS> dpratt71_: there's nothing to grok about Monoids really, they're quite simple
16:01:43 <Toxaris> pao: duncan just hinted that the user package db could be a problem for cabal install
16:01:47 <pao> Toxaris: *you
16:01:55 <BONUS> its nice to know Monoids cause the Writer monad is cool to learn by when learning monads
16:02:04 <pao> Toxaris: Duncan knew that you was on windows?
16:02:06 <Cale> BONUS: Well, that's true.
16:02:17 <Toxaris> pao: maybe not, not sure.
16:02:23 <acidjnk> My first step is this: foldr (\x xs -> xs ++ [x]) [] [1,2,3,4] -> 1o2o3o4o[] -> 1o2o3o[]++[4]
16:02:24 <Philippa_> dpratt71_: which you might think of as 'obvious', 'swhy I missed it :-) But that's an important part of what we think of as sequencing...
16:02:28 <acidjnk> So the 4 is at the end still.
16:02:37 <dcoutts> Toxaris: oh, were you using cabal-install-0.5.x to upgrade cabal-install?
16:02:38 <dpratt71_> so fmap takes a function that goes from a to b along with a "specialized" a and returns a "specialized" b?
16:02:44 <pao> Toxaris: the quick fix would that to migrate to a "serious" os ;-)
16:02:50 <dcoutts> Toxaris: does it fail at the final installing part?
16:02:55 <rwbarton> acidjnk: then what next?
16:02:57 <bmh> Cale: 211.79522688568588 =D Thanks
16:03:01 <dmwit> acidjnk: Sorry, but that's wrong, as I said a long time ago.
16:03:01 <Philippa_> BONUS: plus there're some useful rules about monad transformers commuting that stem from monoidal properties
16:03:04 <Guenni> hi any happs users here?
16:03:05 <Toxaris> dcoutts: files when compiling network
16:03:15 <Cale> dpratt71_: Yeah, you might think of (f a) as being an a-valued structure. For example, f = Tree perhaps.
16:03:15 <Toxaris> dcoutts: aehn, "fails", of course
16:03:27 <Toxaris> dcoutts: with something about header files and c code and whatever
16:03:27 <dmwit> acidjnk: The first step is foldr blah 1:2:3:4:[] -> [] ++ [4] ++ foldr blah 1:2:3:[]
16:03:28 <acidjnk> rwbarton, next would be -> 1o2o[]++[3]++[4]
16:03:30 <Cale> dpratt71_: Then f a would be a Tree of values of type a
16:03:40 <dcoutts> Toxaris: ah ok. So the question is why it's trying to install that package at all when it's already installed.
16:03:42 <dpratt71_> ok
16:03:46 <rwbarton> acidjnk: nope.  You need to keep track of parentheses
16:03:47 <Toxaris> dcoutts: indeed
16:03:51 <BONUS> Philippa: you mean mappending transformers being like mappending the underlying monads in one transformer?
16:03:54 <dmwit> acidjnk: As you'll see if you look at the order of arguments to your function: \x xs -> xs ++ [x]
16:03:57 <Cale> Or f could be [], in which case, [a] would be lists of values of type a
16:04:16 <dcoutts> Toxaris: did you check if there was any overlap in the global and user package dbs? That's often the cause of this kind of confusion where it decides it needs to reinstall core packages.
16:04:24 <Cale> Or f could even be (->) e in which case, f a = e -> a, functions whose result is of type a
16:04:34 <Cale> and then  fmap :: (a -> b) -> (e -> a) -> (e -> b)
16:04:36 <dpratt71_> so a Functor might take a Tree of int along with something that goes from int to string and returns a Tree of string?
16:04:39 <acidjnk> ok, so the first step is not "1o2o3o[]++[4]", rather "1o2o3o([]++[4])"?
16:04:53 <Cale> fmap :: (Int -> String) -> Tree Int -> Tree String
16:04:54 * dpratt71_ is not sure if those types make sense for Haskell
16:04:59 <Cale> Like that
16:05:00 <acidjnk> And that was my only mistake?
16:05:04 <Toxaris> dcoutts: cabal install --version is 0.5.1 with Cabal 1.4.0.1, I'm on Windows Vista, I don't seem to have a user package db
16:05:05 <leimy> dang
16:05:09 <Cale> Tree would be the functor
16:05:12 <leimy> I just thought I was being all clever, and inventing a new monad
16:05:17 <leimy> then I realized I reimplemented Maybe
16:05:22 <Cale> (along with the definition of fmap)
16:05:36 <dpratt71_> Cale: oh right
16:05:50 <Philippa_> BONUS: honestly? I've forgotten the actual rule, I just remember it as "state-like things commute" with a footnote that the relevant facet is the monoidal aspect
16:05:59 <Philippa_> so yeah, probably by the time I bash it all out
16:06:09 <acidjnk> I think I got it, thanks @all. I only forgot that one pair of parenthesis, that was all. I hope.
16:06:11 <Toxaris> dcoutts: and that's what happens: http://hpaste.org/13871#a2
16:06:13 <Cale> dpratt71_: So you can think of a functor, roughly, as a type of data structure to which you can apply a function to all of its "elements", whatever those are.
16:06:30 <dpratt71_> Cale: gotcha
16:06:35 <Cale> dpratt71_: and it must be the sort of data structure whose elements can be any type at all.
16:06:37 <dcoutts> Toxaris: what does it report when you add --dry-run ?
16:06:47 <eu-prleu-peupeu> bye bye, sleeppyy time
16:07:07 <Philippa_> BONUS: thinking about it - I mean that they may as well be one transformer where the monoid's a sum of the monoids used by the transformers being combined
16:07:08 <dpratt71_> Cale: interesting
16:07:09 <Cale> Of course, these "elements" might not all exist in memory at any point, like in the case of functions, where the "elements" are the possible results of the function.
16:07:18 <dmwit> acidjnk: foldr (\x xs -> xs ++ [x]) [] [1,2,3,4] -> foldr f [] (1:2:3:4:[]) -> 1 `f` (2 `f` (3 `f` (4 `f` []))) -> 1 `f` (2 `f` (3 `f` ([] ++ [4]))) -> 1 `f` (2 `f` (([] ++ [4]) ++ [3])) -> 1 `f` ((([] ++ [4]) ++ [3]) ++ [2]) -> (((([] ++ [4]) ++ [3]) ++ [2]) ++ [1])
16:07:19 <Saya> yeah (if i understood right) the functor takes your types from one category to another (it would be a kind here?) so like you have your base category with the type a and it goes from a to  Tree a or from a to [a] or from [a] to Maybe a
16:07:21 <dcoutts> Toxaris: and is that version of network already installed or not? ghc-pkg list network
16:07:31 <Cale> > fmap (+1) (*2) 5
16:07:32 <lambdabot>   11
16:07:36 <Cale> > (*2) 5
16:07:38 <lambdabot>   10
16:07:39 <rwbarton> dmwit: bless you
16:07:42 <BONUS> Philippa: ah yeah, thats kind of what i had in mind
16:07:43 * gwern bollocks pandoc for not giving me syntax highlighting
16:07:45 <Toxaris> dcoutts: that version of network is installed (see same hpaste, above)
16:07:50 <dmwit> rwbarton: =)
16:07:50 <acidjnk> thanks dmwit, yes, only my parenthesis were wrong.
16:08:08 <dpratt71_> I was just reading a paper about what things could be inferred given the fact that some function operates on "generic" types...
16:08:17 <Cale> You might look at the function (*2) as being a structure indexed by numbers, which has the double of each number at any given index.
16:08:21 <dpratt71_> ...needless to say, most of it went over my head
16:08:27 <dmwit> acidjnk: Okay, sorry if I was too late.  I lost track of the conversation while I was typing that. =P
16:08:29 <Cale> and then fmap (+1) will add 1 to the number which is at each index
16:08:41 <Cale> But what is that? It's just function composition of course.
16:08:42 <acidjnk> dmwit, it's still nice to see it all properly noted.
16:08:47 <Toxaris> dcoutts: --dry-run produces http://hpaste.org/13871#a3
16:09:11 <Cale> dpratt71_: Make sense?
16:09:27 <dpratt71_> still absorbing what you said about (*2)
16:09:32 <dcoutts> Toxaris: hmm, I'm not sure. I'm not sure it's worth investigating either. We should just get you upgraded to version 0.6.0
16:09:34 <int80_h> hey is there a web site where logs are kept of this channel?
16:09:39 <Cale> > map (*2) [-10..10]
16:09:40 <lambdabot>   [-20,-18,-16,-14,-12,-10,-8,-6,-4,-2,0,2,4,6,8,10,12,14,16,18,20]
16:09:52 <gwern> int80_h: yes
16:09:55 <rwbarton> int80_h: Yes, see the topic
16:09:56 <dmwit> int80_h: tunes.org/~nef/logs/haskell
16:09:56 <gwern> may god help us all!
16:10:16 <gwern> alternative response: Big Tunes is watching you!
16:10:19 <Cale> You can think of it as a sort of infinite data structure, indexed by integers, which holds the result of applying the function (*2) to each integer.
16:10:25 <int80_h> oooh good.
16:10:30 <Toxaris> dcoutts: sounds great. why is it not included with the ghc-6.10 windows binary? /me waits for the Haskell Platform
16:10:41 <dpratt71_> Cale: does this relate to the fact that "functions can be thought of as table look-ups"...or so I've been told
16:10:42 <chessguy> oh no, not more "functions are containers" stuff
16:10:43 <dmwit> > fmap (*2) [-10..10] -- quick, confuse the newbie!
16:10:44 <lambdabot>   [-20,-18,-16,-14,-12,-10,-8,-6,-4,-2,0,2,4,6,8,10,12,14,16,18,20]
16:10:46 <Cale> dpratt71_: yes.
16:10:52 <dcoutts> Toxaris: http://haskell.org/~duncan/cabal/cabal.exe may be a later version, I can't quite remember. Otherwise you just need to build cabal-install the old fashioned way, you've already got zlib and HTTP
16:10:55 <dpratt71_> very good
16:10:56 <Cale> dpratt71_: Exactly. In a possibly infinite table.
16:10:58 <BONUS> whats the best procedure to upgrade GHC on windoze
16:11:07 <BONUS> 6.8 to 6.10.1
16:11:18 <erikc> bonus: i recommend: scorched earth
16:11:19 <Cale> dpratt71_: So then fmap is supposed to apply a function to each of the values stored in that table.
16:11:20 <dpratt71_> my brain is close to critical pressure
16:11:26 <BONUS> haha
16:11:27 <chessguy> @quote explode
16:11:27 <lambdabot> EvilTerran says: you've got bottoms everywhere that'll explode if you look at them
16:11:57 <RayNbow> I LOVE THE LIST MONAD <3
16:12:02 <Cale> dpratt71_: But how do we actually accomplish that?
16:12:07 <chessguy> @quote record
16:12:07 <lambdabot> ghc says: Empty record update
16:12:39 <dmwit> ?quote tessier
16:12:39 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
16:12:42 <dpratt71_> Cole: accomplish applying fmap to (*2) ?
16:13:10 <dmwit> > fmap (*2) (+1) 37
16:13:11 <lambdabot>   76
16:13:15 <Cale> dpratt71_: We want (fmap f g) applied at x, that is, (fmap f g) x to be equal to the result of applying f to the result of looking up g at x, that is f (g x)
16:13:29 <Cale> But that's a good definition right there :)
16:13:34 <Cale> fmap f g x = f (g x)
16:13:43 <dmwit> Actually, I guess what you're talking about would be
16:13:46 <BONUS> i think of a funciton as a box that contains its result
16:13:48 <dmwit> > fmap (+1) (*2) 37
16:13:49 * dpratt71_ is absorbing...
16:13:49 <Cale> and it's exactly the same definition as function composition
16:13:49 <lambdabot>   75
16:13:59 <Cale> (f . g) x = f (g x)
16:14:00 <BONUS> fmapping to a function is like mapping over its eventual result
16:14:14 <BONUS> of course it produces a function that will then apply f over its result
16:14:44 <dmwit> :t fmap (+1) (*2) (^3) -- bwahaha
16:14:46 <lambdabot> forall a. (Num a, Num (a -> a)) => a -> a
16:15:07 * Toxaris found his old "install cabal packages the old-fashioned way" script
16:15:16 <Cale> dmwit: err...
16:15:20 <dpratt71_> the problem is not understanding all this...
16:15:29 <dmwit> Cale: needs an instance Num a -> a where ... =P
16:15:33 <Cale> dmwit: yes
16:15:35 <Philippa_> dpratt71_: it's using it?
16:15:36 <dcoutts> Toxaris: so what version is the one on my page? too old? I should update it.
16:15:47 <dpratt71_> ...the problem is comprehending it for more than 5 minutes before it evaporates
16:15:56 <Cale> dpratt71_: of course, this is just one example of a functor... The list functor is an easier example perhaps.
16:16:09 <BONUS> i always kind of explain monads by using box analogies but quicksilver doesn't like me doing that :(
16:16:09 <Cale> You have a list of values, and fmap's job is just to apply a function to them all.
16:16:12 <int80_h> tell me about it. I thought I understood how haskell handles scope...but I don't
16:16:20 <Cale> > fmap (+1) [0,2,4,6,8]
16:16:22 <lambdabot>   [1,3,5,7,9]
16:16:30 <dmwit> dpratt71_: My approach was to comprehend it for 5 minutes the first time, then 10 minutes the second time...
16:16:43 <dpratt71_> dmwit: heh
16:16:46 <Cale> > fmap (+1) (Just 10)
16:16:47 <lambdabot>   Just 11
16:16:57 <Philippa_> dpratt71_: any bits at all that stick are good for next time. Then you go use some of it in some code and that bit sticks and makes the rest easier...
16:16:58 <Cale> So that's fmap.
16:17:09 <rgr> in chap03 of RWH, discussing new data types, it shows BookInfo and "deriving(Show)". But in ghci it doesnt know about Show. Do I need to import something? It says "    No instance for (Show BookInfo)".
16:17:10 <kmeyer> does the main "function" have to be in the Main module? or can the module be some option passed to ghc?
16:17:28 <Cale> The next natural things you need to understand if you want to proceed to monads, is what return and join are.
16:17:36 <dmwit> rgr: Sounds like user error; can we see the source you're using?
16:17:38 <dmwit> ?hpaste
16:17:38 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:17:45 <Toxaris> dcoutts: its up-to-date, I didn't check because I remembered that I had this old script somewhere
16:17:54 <Cale> To be honest though, return and >>= are closer to the actual use of monads so far as functional programming is concerned.
16:17:55 <dpratt71_> I have a very tenuous, abstract grasp of such concepts
16:18:12 <Cale> Let's look at the (->) e monad.
16:18:25 <Cale> (that's a partial application of the function type constructor)
16:18:33 * rgr pasted "no Show" at http://paste2.org/p/128960
16:18:37 <dmwit> kmeyer: There might be a way using -main-is.
16:18:39 <Cale> That is, ((->) e) a = e -> a
16:18:56 <rgr> dmwit: http://paste2.org/p/128960
16:19:05 <Cale> We've already just looked at fmap for this one
16:19:06 <kmeyer> dmwit: looks like the option I'm looking for. Thanks!
16:19:06 <Philippa_> dpratt71_: that's fine, they're abstract concepts. The rest comes with experience
16:19:06 <rwbarton> Whoa!
16:19:17 <rwbarton> Oh, paste2 /= hpaste
16:19:17 <Cale> fmap :: (a -> b) -> (e -> a) -> (e -> b)
16:19:22 <Cale> fmap f g = f . g
16:19:25 <dcoutts> Toxaris: ah ok
16:19:27 <leimy> guard and when are my new friends .... :-)
16:19:32 <dmwit> rgr: That works for me.
16:19:37 <Cale> Now let's look at join
16:19:47 <Cale> join :: (Monad m) => m (m a) -> m a
16:19:48 <Cale> So in this case,
16:19:51 <Toxaris> dcoutts: seems to work now, at least a lot of stuff is happening :)
16:19:55 <kmeyer> dmwit: hm, then I get a linking error
16:20:00 <Cale> join :: (e -> (e -> a)) -> e -> a
16:20:13 * rgr pasted "ghci output" at http://paste2.org/p/128961
16:20:23 <Cale> dpratt71_: So what might such a function do?
16:20:27 <dcoutts> Toxaris: heh, ok. cabal install --dry-run -v is your friend for these issues and in the latest version it gives more useful details.
16:20:33 <Cale> dpratt71_: We don't have many choices.
16:20:38 <dpratt71_> Cale: I hope your not asking me
16:20:42 <RayNbow> > let replaceIL = mapM (\c -> if c `elem` "Il" then "Il" else [c])      in   replaceIL "Illiteration"ã€€-- gotta love the list monad :)
16:20:44 <lambdabot>   ["IIIiteration","IIliteration","IlIiteration","Illiteration","lIIiteration"...
16:20:49 <dmwit> rgr: Maybe you should try :reload'ing that module.
16:20:53 <dcoutts> Toxaris: and if you do run into weirdness in future look out for overlap between the global and user package dbs
16:20:58 <Cale> dpratt71_: All I'm asking is for you to write a function of type (e -> e -> a) -> e -> a
16:21:07 <dmwit> rgr: All I can say is, typing "myInfo" works for me.
16:21:21 <dpratt71_> oh, very well then, I'll get right on it ;)
16:21:25 <dmwit> rgr: I'm not sure what the bit about "print" is, since I don't see "print" anywhere in your source.
16:21:32 <Cale> dpratt71_: That is, given a function of two parameters, both of type e, which gives an a as its result, and a value of type e
16:21:38 <Cale> dpratt71_: Give me a value of type a
16:21:52 <Toxaris> dcoutts: thank you for your help (and for cabal in the first place, of course)!
16:21:53 * lispy hands Cale an a
16:21:55 <Cale> dpratt71_: What can we possibly try?
16:21:55 <rwbarton> dmwit: "print" is inside ghci
16:21:59 <rgr> dmwit: thanks. Ignore.
16:21:59 <dcoutts> Toxaris: np
16:22:08 <Cale> join f x = ...
16:22:08 <dmwit> rwbarton: Oh, duh.
16:22:18 <Cale> f :: e -> e -> a
16:22:20 <Cale> x :: e
16:22:26 <Cale> we want an a
16:22:29 <rgr> user error .....
16:22:40 <BONUS> f takes two e's
16:22:43 <BONUS> and x is of type e
16:22:58 <dpratt71_> BONUS: right
16:23:15 <Cale> This is perhaps deceptively simple ;)
16:23:20 <BONUS> yeah haha
16:23:22 <dpratt71_> f x x
16:23:24 <Cale> right
16:23:26 <Cale> exactly
16:23:27 <BONUS> w00t!
16:23:31 <Cale> join f x = f x x
16:24:03 <Cale> Going back to our "table" analogy, our f is like a table of tables, indexed by the same type e
16:24:06 <dpratt71_> in the Monad of "partial type constructors" ?
16:24:29 <Cale> dpratt71_: This is what I would call the function monad.
16:24:34 <dpratt71_> wait, I didn't say that right...
16:24:37 <Cale> Some people like to call it reader.
16:24:48 <Cale> > join (*) 5
16:24:49 <lambdabot>   25
16:24:53 <lispy> > (2^2+1)^2+1
16:24:54 <lambdabot>   26
16:25:07 <dpratt71_> what did you say about "partial blah blah blah..."
16:25:31 <Cale> dpratt71_: (->) is a type constructor, but it takes two parameters. A monad is supposed to be a type constructor with *one* type parameter.
16:25:44 <Cale> So we partially apply (->) to some arbitrary type e
16:25:51 <dmwit> > join (\x -> x^2+1) 2
16:25:52 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a1
16:25:52 <lambdabot>      Prob...
16:25:52 <Cale> ((->) e) becomes our monad.
16:26:01 <dmwit> ah
16:26:03 <dpratt71_> *boom*
16:26:05 <BONUS> also, ((->) e) is like (e ->)
16:26:14 <Cale> Yeah, it reads nicer as (e ->)
16:26:17 <BONUS> when oyu have something like join :: m (m a) -> m a
16:26:17 <leimy> hey that is a bonus
16:26:20 <leimy> :-)
16:26:20 <lispy> Yeah, too bad our syntax doesn't support (e ->)
16:26:21 <Cale> (e ->) a = (e -> a)
16:26:27 <BONUS> just replace the m with (e ->)
16:26:29 <dmwit> > join (.) (\x -> x^2 + 1) 2
16:26:31 <BONUS> hello :]
16:26:31 <lambdabot>   26
16:26:39 <kerlo> Yay, Hugs is installed on this machine. I'm sure Hugs is as good as GHC, now. :-P
16:26:52 <kerlo> Despite, um, not being able to compile, if I remember correctly.
16:26:55 <leimy> lolz
16:27:00 <mm_freak> ski_: because i see no semantical difference between subscripts (id_A) and mapping (id A)
16:27:01 <lispy> kerlo: it really depends on what you want to do with Haskell
16:27:03 <leimy> Hugs even works on Plan 9 :-)
16:27:04 <dpratt71_> not certain I'm grokking this: ((->) e)
16:27:15 <dpratt71_> is "->" an operator?
16:27:20 <Cale> dpratt71_: Okay, you're familiar with partial application of functions, yeah?
16:27:25 <lispy> dpratt71_: -> is the type constructor for functions
16:27:25 <Toxaris> dcoutts: next problem, after installing executables using my new cabal-install (as administrator under vista with all fancy rights enabled), I cannot run them without these fancy rights
16:27:28 <mm_freak> ski_: just that mapping difference is much more convenient both to write and to read in IRC =)
16:27:29 <dpratt71_> sorta
16:27:31 <dpratt71_> currying
16:27:37 <Cale> right, okay
16:27:41 <dcoutts> Toxaris: what fancy rights?
16:27:47 <lispy> dpratt71_: a -> b, is the same as (->) a b
16:27:48 <dpratt71_> I tend to think of "->" as just syntax
16:28:03 <dpratt71_> but you're using it like an operator
16:28:03 <dcoutts> Toxaris: cabal does nothing special with permissions
16:28:13 <kerlo> lispy: well, for one, I want to use it. GHC doesn't work on this machine; I think that's because it's a Xen machine.
16:28:13 <Cale> dpratt71_: (->) is a function on types
16:28:16 <lispy> > (+) :: (->) Int Int
16:28:17 <lambdabot>   Couldn't match expected type `Int'
16:28:18 <ski_> mm_freak : sorry, i forgot exactly what you're responding to
16:28:21 <Cale> dpratt71_: It takes two types, and gives us another
16:28:22 <lispy> :t (+) :: (->) Int Int
16:28:23 <lambdabot>     Couldn't match expected type `Int'
16:28:23 <lambdabot>            against inferred type `Int -> Int'
16:28:23 <lambdabot>     Probable cause: `+' is applied to too few arguments
16:28:29 <Cale> dpratt71_: Right?
16:28:32 <ski_> (mm_freak : the context was something with identity in CT)
16:28:39 <dpratt71_> ok, I see that
16:28:43 <mm_freak> ski_: about the uniqueness of the identity morphism
16:28:48 <lispy> kerlo: ah
16:28:48 <dpratt71_> never thought of it that way
16:28:48 <dmwit> > (+) :: (->) Int ((->) Int Int) -- lispy
16:28:49 <lambdabot>       Overlapping instances for Show (Int -> Int -> Int)
16:28:49 <lambdabot>        arising from ...
16:28:53 <Cale> :t (+1) :: (->) Int Int
16:28:55 <lambdabot> Int -> Int
16:29:00 <Toxaris> dcoutts: "user account control", programs under vista have to ask for specific administrator rights to be enabled, I did that for the cabal install process, and now the executables ended up unusable without these rights -- some user / directory issue maybe?
16:29:02 <mm_freak> i.e. whether there can be multiple identity morphisms for an object
16:29:03 <lispy> oh right, sorry
16:29:05 <Cale> :t show :: (->) Int String
16:29:06 <lambdabot> Int -> String
16:29:16 <dpratt71_> by the way, in case it isn't extremely obvious, I'm a Haskell newbie
16:29:20 <mm_freak> in fact, my question is still open
16:29:24 <Cale> dpratt71_: I figured, yeah :)
16:29:30 <lispy> dpratt71_: By the way, [a] can be written as [] a
16:29:34 <BONUS> we're all noobs compared to Cale
16:29:37 <Cale> dpratt71_: So if we give it *one* type, we get a function from types to types.
16:29:38 <lispy> > [1] :: [] Int
16:29:38 <BONUS> :]
16:29:39 <lambdabot>   [1]
16:30:01 <Cale> dpratt71_: And that's exactly the right kind of thing to be a functor/monad.
16:30:09 <dcoutts> Toxaris: I expect it's a feature of windows vista. Can you check the file permissions of those files or directories?
16:30:12 <Cale> Functors and Monads are functions from types to types.
16:30:14 <dpratt71_> I gotta run...but I'll be back
16:30:17 <Cale> okay
16:30:18 <lispy> But writing "[] a" in a haskell program is like writing 1[foo] (or however it works) in C
16:30:18 <dcoutts> Toxaris: cabal literally just copies the .exe file
16:30:20 <dpratt71_> thanks for all the info
16:30:28 <Cale> dpratt71_: No problem.
16:30:38 <ski_> mm_freak : right .. so i'm not sure what notational difference between `id_A' and `id A' has to do with this ?
16:30:45 <BONUS> do you think we scared him haha
16:30:55 <Cale> BONUS: not too much, I hope
16:31:10 <leimy> lispy:  [a]1  and a[1] in C and C++ are the same
16:31:15 <leimy> er
16:31:18 <mm_freak> ski_: nothing, but you got confused by my preference to write 'id A' for a/the identity morphism A â†’ A
16:31:22 <leimy> mabye it's 1[a]
16:31:25 <pumpkin> Cale: I tried to find your awodey book in my library but someone stole/lost it :( it was supposed to be there but it wasn't :(
16:31:26 * pumpkin is sad
16:31:31 <lispy> leimy: yeah, that's what I couldn't remember :)
16:31:34 <Cale> pumpkin: Did you get the copy from me?
16:31:41 <leimy> basically [] is commutative
16:31:47 <pumpkin> Cale: well, I have your pdf, but I wanted to read dead tree
16:31:51 <Cale> ah
16:31:54 <leimy> because *(1 + a) is the same as *(a + 1)
16:31:58 <pumpkin> I guess someone else wanted it really badly too and stole it :P
16:32:00 <Cale> I actually sort of prefer reading on screen.
16:32:02 <BONUS> there's a pdf of the awodey book?
16:32:08 <pumpkin> BONUS: shhh
16:32:16 <pumpkin> it's a secret!
16:32:18 <lispy> leimy: right, just like [a] == [] a, in Haskell
16:32:18 <ski_> mm_freak : not that i recall :) .. possibly there was general miscommunication
16:32:22 <BONUS> ah :]
16:32:28 <BONUS> i've been meaning to rent/buy that as well
16:32:35 <mm_freak> ski_: probably =)
16:32:44 <pumpkin> Cale: it strains my eyes after a while... maybe I should buy an e-ink reader :)
16:32:57 <BONUS> i'm used to learning via online tutorials and such
16:33:05 <leimy> lispy: in terms of typing a list, not constructing right?
16:33:07 <leimy> > [] 1
16:33:08 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
16:33:14 <Cale> I bought the entire series of Frank Herbert's Dune novels the other day, and while the content is great, I find it difficult to find a good place to sit and read them.
16:33:18 <BONUS> so learning over the screen is kind of easier for me cause i tend to play with the examples a lot
16:33:19 <leimy> > [] ::Int 1
16:33:19 <lispy> pumpkin: you might have the screen too close if it strains your eyes
16:33:20 <lambdabot>       Kind error: `Int' is applied to too many type arguments
16:33:20 <lambdabot>      In the typ...
16:33:24 <leimy> hmmm
16:33:31 <lispy> > [1] :: [] Int
16:33:32 <leimy> > ([] ::Int) 1
16:33:32 <lambdabot>   [1]
16:33:32 <Cale> I'd prefer sitting in front of my nice LCD monitor ;)
16:33:33 <lambdabot>   Couldn't match expected type `Int' against inferred type `[a]'
16:33:35 <pumpkin> lispy: nah, I just don't like reading large bodies of text on screen :)
16:33:37 <ski_> mm_freak : were you satisfied with the uniqueness ?
16:33:38 <Toxaris> dcoutts: http://hpaste.org/9864#a5  (the files with "-rwx------ " are installed by the new cabal-install and do not work, while the others were installed with the old and do still work)
16:33:46 <pumpkin> lispy: maybe I'm old-fashioned
16:33:47 <leimy> Oh right! :-)
16:33:50 <leimy> that's what I thought you meant
16:33:54 <Toxaris> dcoutts: so theres a difference, but I have no clue what it means :)
16:33:56 <lispy> pumpkin: I like the tangible paper with the ability to make notes on it
16:33:56 <erikc> pumpkin: the e-ink readers are great, bought and returned one
16:34:11 <leimy> I've friends who love the Amazon thingy
16:34:13 <erikc> im waiting for an A4-sized one since the current sizes dont zoom that well
16:34:14 <Cale> I end up lying awkwardly in my bed, and crushing one or the other of my arms.
16:34:16 <erikc> but it is gorgeous
16:34:40 <pumpkin> erikc: yeah, I want an A4 one too, but the only one is from irex and doesn't look very attractive :/
16:34:45 <leimy> I can't be in bed reading anything... I fall asleep
16:35:08 <int80_h> test
16:35:13 <int80_h> huh, my hpaste didn't get announced
16:35:21 <pumpkin> int80_h: it's broken
16:35:23 <int80_h> http://hpaste.org/13873
16:35:54 <dcoutts> Toxaris: ah, we're copying the permissions when we copy the file, that's what it is. So whatever permissions the files had when ghc created them, we copy to the files when we install them.
16:36:00 <lispy> Yeah, t'would be nice if that checkbox were removed
16:36:32 <dcoutts> Toxaris: could you file a ticket with the details please?
16:36:40 <lispy> dcoutts: you don't use the install command?
16:36:51 <dcoutts> lispy: hmm?
16:37:00 <kmeyer> anyone know if ghci has an enable/disable readline option?
16:37:05 <Toxaris> dcoutts: checked with the GUI, the newer files have a more modern properties dialog (e.g. more properties, more detailed access rights) and less rights (e.g. no execution right for normal users) -- maybe because of ghc-6.10?
16:37:07 <lispy> dcoutts: man install
16:37:09 <dcoutts> Toxaris: http://hackage.haskell.org/trac/hackage/
16:37:20 <dcoutts> lispy: oh, no. It does not exist on windows.
16:37:21 <int80_h> could someone take a peak at my hpaste?
16:37:49 <lispy> dcoutts: I thought one of the reasons to use install is that it gets permissions right...Windows is less likely to suffer from permission errors :)
16:37:50 <dcoutts> lispy: on unix all it does is set permissions. We've currently got no api for doing that properly in Haskell.
16:38:14 <p_l> lispy: You sure?
16:38:32 <Toxaris> dcoutts: yeah look at some more property dialogs, and then fill a bug report
16:38:48 <lispy> p_l: of course I could be wrong.  This isn't an area of expertise for me
16:39:48 <timbau> is this an appropriate forum to ask about building ghc?
16:39:48 <p_l> lispy: On typical "home" setup permissions are not a problem, cause to maintain backwards compatibility the default user has administrative rights
16:40:20 <dmwit> timbau: You might want to check out #ghc.
16:40:27 <p_l> lispy: But if someone actually decides that he wants to use NT with all features, then it can get weird
16:40:33 <dmwit> timbau: But the question won't be too far afield here.
16:41:13 <timbau> I am trying to build ghc6.10.1 on linux
16:41:14 <Toxaris> p_l: on a out-of-the box vista (like mine), the default user is admin (like I am), but still has no admin rights until specifically enabled on a case-per-case base.
16:41:31 <p_l> Toxaris: That's what was added in NT6
16:41:56 <blackh> int80_h: Try ++ [i] ++
16:41:56 <timbau> I got it installed, but I think I didn't have editline, so it works, but the ghci does not handle backspace etc
16:42:40 <timbau> and configure cannot find editline. Is there a way to specify where the library is?
16:42:41 <Toxaris> int80_h: you have (i :: Char), so you cannot use ++ with it, which operates on lists
16:43:13 <int80_h> blackh: now I get a new error, shall I post to hpaste?
16:43:30 <blackh> int80_h: Yeah!
16:43:54 <int80_h> blackh: I think Toxaris just explained why...but I also get a similar error when I use :
16:43:59 <Toxaris> int80_h: why do you never use y?
16:44:50 <int80_h> Toxaris: good question. It looks like my logic is flawed
16:44:56 <rgr> Anyone here got ghci command completion working in emacs like it does in a normal terminal e.g :t<tab> completing to ":type or :trace" ?
16:45:43 <int80_h> Toxaris : but if I figured out my current problem, I should just be getting wrong output right?
16:46:15 <int80_h> Toxaris: in other words, I can fix this problem first, and then deal with my incorrect output right? the two problems aren't related, are they?
16:46:55 <pumpkin> what the hell? I could've sworn my gnuplot had a pdf terminal a couple of weeks ago, but now it doesn't :o
16:47:16 <TML> Am I reading this correctly, that building GHC requires an existing GHC?
16:47:16 <Toxaris> int80_h: I think that should be possible, yes
16:47:32 <mm_freak> ski_: my question is still open
16:47:32 <blackh> TML: Yes. It's written in Haskell.
16:47:39 <int80_h> cons is an operator right? I can't seem to get a type for it in ghci
16:47:50 <ivanm> @hoogle cons
16:47:50 <lambdabot> Data.ByteString cons :: Word8 -> ByteString -> ByteString
16:47:50 <lambdabot> Data.ByteString.Char8 cons :: Char -> ByteString -> ByteString
16:47:50 <lambdabot> Data.ByteString.Lazy cons :: Word8 -> ByteString -> ByteString
16:48:19 <TML> blackh: That's fair - I was just expecting a simpler bootstrap - like gcc
16:48:22 <int80_h> and : is a synonym for cons right?
16:48:25 <ski_> mm_freak : so you didn't like my (iirc suggestion of a) proof of unicity, by using the unit laws ?
16:48:31 <int80_h> @hoogle :
16:48:31 <lambdabot> Parse error:
16:48:32 <lambdabot>   --count=20 :
16:48:32 <lambdabot>              ^
16:48:33 <Toxaris> TML: http://en.wikipedia.org/wiki/Bootstrapping_(compilers)
16:49:05 <dmwit> rgr: Most of the common commands have one-letter versions.
16:49:05 <ivanm> int80_h: no
16:49:09 <ivanm> @hoogle (:)
16:49:10 <lambdabot> Parse error:
16:49:10 <lambdabot>   --count=20 (:)
16:49:10 <lambdabot>               ^
16:49:20 <ivanm>  (:) is the list constructor (along with [])
16:49:29 <ivanm> this isn't lisp where you cons everything ;-)
16:49:32 <dmwit> rgr: :t is :type, :i is :info, :r is :reload, :b is :break (unfortunately, not :browse)
16:49:32 <rgr> dmwit: I know. But that is not to do with completion.
16:49:34 <TML> Toxaris: Yes, I'm referring here to the 3rd bullet-point, for example.
16:49:43 * dmwit nods
16:49:58 <ski_> (mm_freak : or, at i was about to mention that .. don't recall now if i actually did)
16:50:03 <dmwit> rgr: Well, ghci does completion of commands here.
16:50:04 <rgr> Was just curious. It works if I run multi-term in emacs and then ghci.
16:50:14 <rgr> dmwit: in emacs?
16:50:19 <rgr> using what?
16:50:20 <TML> "Porting GHC" it is, then :)
16:50:21 <Toxaris> TML: oh didn't see your "simpler bootstrap" line
16:50:22 * dmwit uses vim
16:50:37 * rgr wonders why "works here" is applicable with a totally different editor :-;
16:50:38 <dmwit> rgr: Oh, I misread your question, sorry.
16:50:44 <rgr> No probs :-)
16:51:04 <Toxaris> TML: I think GHC was third-bullet-bootstrapped by HBC, in former times
16:51:09 <int80_h> okay I'm changing to ':' and posting my new (but similar) error
16:51:28 <TML> Toxaris: I'll entirely take your word for that :)
16:51:40 <Toxaris> you shouldn't I have no clue about these times :)
16:51:56 <dmwit> :t (:)
16:51:57 <lambdabot> forall a. a -> [a] -> [a]
16:54:54 <TML> Agh - http://hackage.haskell.org/trac/ghc/wiki/Building/Porting says "Versions supported: between 6.0.1 and 6.6.2. We are working on getting bootstrapping working again in the 6.8 series" - haskell.org points me at 6.10.
16:55:52 <int80_h> http://hpaste.org/13873#a1
16:55:57 <int80_h> there we go
16:56:15 <pumpkin> int80_h: got it?
16:56:49 <int80_h> pumpkin: not at all. I just have a new error
16:57:09 <dpratt71> Cale, are you willing to take a few more whacks at my brain?
16:57:20 <Cale> dpratt71: sure
16:57:20 <dolio> You've got the arguments backward.
16:57:49 <dolio> Wait, no you don't. Sorry.
16:57:51 <dpratt71> so "->" is a function from type to type...
16:58:01 <Cale> dpratt71: So I was talking about how functors and monads are essentially functions from types to types (along with some additional functionality)
16:58:16 <dpratt71> and if I partially apply "->" to some type...
16:58:18 <Cale> (->) is a function of two types which gives another type
16:58:30 <dpratt71> wait, what?
16:58:34 <dpratt71> two types?
16:58:36 <BONUS> like Maybe ... takes one type, like, say, Int and returns a type that a value can have, like Maybe Int
16:58:40 <Cale> Well,  (a -> b) is a type
16:58:51 <Cale> Or, written another way, that's (->) a b
16:58:55 <dpratt71> Cale: oh
16:58:57 <Cale> So it needs two parameters
16:59:09 <Cale> If we only give it one, then we get a function from types to types.
16:59:24 <Cale> (It's curried)
16:59:28 <dpratt71> right
16:59:32 <wli> Well, you need to distinguish typeclass from the type itself. So the monad typeclass is one thing, and an instance of a monad is another.
16:59:38 <dpratt71> lemme think on that a minute
16:59:52 <int80_h> dang, I was going to ask pumpkin for help
17:00:29 <Cale> So, for example, ((->) Integer) is a type function (type constructor), which takes a type t, and gives the type Integer -> t
17:00:58 <wli> data NonEmptyList t = NELUnit t | NELCons t (NonEmptyList t) <-- instance of Functor and Monad (at least ignoring the H98 fail BS).
17:01:00 <dpratt71> Is this valid: f = (->) String
17:01:18 <Cale> For a functor? Yes
17:01:44 <Cale> That isn't a valid piece of Haskell code on its own, but it's a valid equation to write down.
17:01:56 <dpratt71> and does that mean a function that takes some type "a" and returns something of type "a -> String" (or is it String -> a) ?
17:02:04 <Cale> String -> a
17:02:09 <Cale> f a = String -> a
17:02:36 <Cale> This is why we sometimes like to write (->) String as (String ->), even though the Haskell compiler won't accept that.
17:02:38 <dpratt71> absorbing...
17:03:16 <dpratt71> so...how does this get us to a Monad?
17:03:24 <int80_h> would someone like to peek at my hpaste?
17:03:26 <BONUS> so if you make ((->) r) an instance of monad, we just replace the m's in join :: m (m a) with (r ->)
17:03:38 <dpratt71> or how is it used to construct a Monad...or what should I be asking
17:03:45 <BONUS> so that gives us join :: r -> (r -> a)
17:03:49 <Cale> Okay... so a Monad is a type constructor with one parameter, together with a definition of (fmap, return, join) or (return, >>=)
17:04:02 <dolio> (r -> (r -> a)) -> (r -> a)
17:04:10 <Cale> (we could take either of the approaches to the definition)
17:04:26 <Cale> We've already said earlier what fmap and join should look like
17:04:35 <Cale> So that basically just leaves return
17:04:49 <Cale> return :: a -> m a
17:04:55 <Cale> and in this case, m = (->) e
17:05:00 <BONUS> if you replace the m iwth ((->) e), that gets us ...
17:05:06 <Cale> So,  return :: a -> (e -> a)
17:05:43 <Cale> So this is a function which takes a value of type 'a', and a value of type 'e' and gives us a value of type 'a'
17:05:46 <dpratt71> ok, really basic question: join is: m(m a)? what is m in this context
17:05:55 <Cale> m is again (->) e
17:06:10 <Cale> join :: m (m a) -> m a
17:06:15 <Cale> so in this case:
17:06:17 <dpratt71> but only for this monad, right...I meant in general
17:06:21 <Cale> join :: (e -> (e -> a)) -> (e -> a)
17:06:23 <dancor> dpratt71: m is an arbitrary Monad
17:06:28 <BONUS> if you have a Maybe, that's Maybe (Maybe a) -> Maybe a
17:06:34 <Cale> right, in general, it's an arbitrary monad
17:06:44 <BONUS> if you think of the monad as a sort of a box, it takes a box in a box and flattens it out
17:06:44 <Cale> In the list monad, join :: [[a]] -> [a]
17:07:07 <wli> instance Functor NonEmptyList where fmap f (NELUnit x) = NELUnit (f x) ; fmap f (NELCons x xs) = NELCons (f x) (fmap f xs) ; appendNEL (NELUnit x) ys = NELCons x ys ; appendNEL (NELCons x xs) ys = NELCons x (appendNEL xs ys) ; foldNEL _ (NELUnit x) = x ; foldNEL f (NELCons x xs) = f x (foldNEL f xs) ; joinNEL = foldNEL append ; instance Monad NonEmptyList where return = NELUnit ; xs >>= f = joinNEL (fmap f xs)
17:07:07 <Cale> In the IO monad,  join :: IO (IO a) -> IO a
17:07:07 <Cale> and so on
17:07:07 <dpratt71> ok, absorbing...
17:07:21 <Cale> BONUS: or a box of boxes
17:07:27 <BONUS> yeah or that.
17:07:40 <m3ga> int80_h: insert [] _ = [x] ??????
17:07:52 <pumpkin> orly?
17:08:02 <BONUS> or if you think of a type constructor of kind * -> * as a box, its just one box :]
17:08:06 <Cale> Of course, the notion of "box" here must be *very* general in order to really work, but it's not bad.
17:08:10 <Guenni> a question to ByteString: is it more memory efficient compared to String?
17:08:17 <pumpkin> Guenni: yeah
17:08:25 <wli> (I'd recommed using something slightly off the beaten path, like the nonempty lists, so that some idea of how things get changed around for different monad instances is more apparent.
17:08:38 <BONUS> yeah. box can be a bit misleading cause it ends up very hard to do the box analogy for some monads, but it helps people get acquainted with them
17:08:48 <Guenni> pumpkin: big time so?
17:08:56 <Cale> BONUS: I was the one who wrote Monads as Containers after all ;)
17:09:04 <int80_h> m3ga: hmm, yeah that's not doing what I want. I'll fix that. I'll still have the type problem though
17:09:11 <pumpkin> Guenni: don't think it's a huge saving
17:09:11 <BONUS> haha really? i didnt read that. gimme a link
17:09:13 <dpratt71> my Haskell-weak brain is having trouble parsing (r -> (r -> a)) -> (r -> a)
17:09:18 * ski_ boxes continuations and offers them for sale
17:09:26 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Containers
17:09:29 * wli likes springschool95.ps / springschool95.pdf
17:09:34 <BONUS> r -> (r -> a) is just like r -> r -> a
17:09:40 <BONUS> think of it as
17:09:45 <lispy> Life is like a box of continuations, you never know where you're going to continue.
17:09:46 <BONUS> (r -> r -> a) -> r -> a
17:09:55 <Cale> dpratt71: Might help to remove some extra parens as BONUS did.
17:10:03 <dons> ?seen luqui
17:10:03 <lambdabot> I saw luqui leaving #haskell 12h 26m 46s ago, and .
17:10:25 <Cale> dpratt71: So it takes a function of two parameters of type r (producing an a), and a value of type r, and produces an a.
17:10:44 <dons> ?tell luqui why are you calling your frp thing frag? is it related to frag the yampa game?
17:10:45 <lambdabot> Consider it noted.
17:10:49 <Cale> dpratt71: another way to look at it, is as (r -> r -> a) -> (r -> a)
17:10:59 <BONUS> yeah i prefer that way
17:11:02 <timbau> When building ghc on Linux, how does one get configure to find a library (specifically libedit) installed in a location other than /usr/lib?
17:11:04 <Cale> so it turns a function of two parameters of type r, into a function of one parameter of type r
17:11:10 <dpratt71> absorbing...
17:11:26 <blackh> int80_h: Hi there. Just had to do some work. x is a [Char] and i is a Char, so you can't do x : i... you have to say x ++ [i] ++ ...
17:11:30 <dolio> @free join :: (r -> r -> a) -> (r -> a)
17:11:31 <lambdabot> (forall x. g . h x = k (f x) . f) => g . join h = join k . f
17:12:05 <dpratt71> BONUS: you said: r -> (r -> a) is just like r -> r -> a ...
17:12:15 <BONUS> yeah
17:12:19 <Cale> dpratt71: yes, it is.
17:12:20 <dpratt71> does operator association matter at all?
17:12:28 <int80_h> blackh: I'm getting a similar error
17:12:29 <blackh> int80_h: ghc is assuming you're trying to create a [[Char]] with : when it sees "x : ..." because x is [Char]
17:12:31 <Cale> dpratt71: yes, -> always associates to the right
17:12:33 <int80_h> blackh: shall I post it?
17:12:39 <blackh> int80_h: Yes.
17:12:41 <dpratt71> ok
17:12:49 <Cale> a -> b -> c -> d = a -> (b -> (c -> d))
17:12:56 <kmeyer> I feel like ghci invoked from a Makefile doesn't use readline, whereas from a commandline it does; how can I get the command line behavior from a makefile? (any ideas of an env var or something?)
17:13:09 <Cale> meanwhile, function application always associates to the left:
17:13:11 <blackh> int80_h: I'm trying to track down a bug in a C++ program on an embedded system.  I need something pleasant to think about. :)
17:13:15 <pumpkin> kmeyer: why are you invoking ghci from a makefile?
17:13:17 <Cale> f x y z = ((f x) y) z
17:13:22 <pumpkin> kmeyer: maybe you want runghc or runhaskell?
17:13:22 <BONUS> its like this. when you have addTwo a b = a + b and you call addTwo 2 3, firs addTwo is called with 2 and produces a function that will take the remaining 3 as a parameter
17:13:28 <kmeyer> pumpkin: shortcut
17:13:36 <pumpkin> hmm
17:13:39 <kmeyer> pumpkin: I want the interpreter
17:13:40 <BONUS> so it's a -> a -> a
17:13:42 <pumpkin> ah
17:13:48 <BONUS> or a -> (a -> a)
17:13:51 <lispy> kmeyer: the darcs makefile has a target like that
17:13:52 <Cale> dpratt71: Every function in Haskell *really* has exactly one parameter.
17:13:52 <dpratt71> ok
17:14:02 <wli> springschool95.ps I'm telling you.
17:14:05 <lispy> kmeyer: http://darcs.net/GNUmakefile
17:14:07 <Cale> dpratt71: Those which appear to have more parameters just produce other functions.
17:14:08 <dpratt71> right...the theory of currying
17:14:09 <kmeyer> probably some sort of "interactive" env var
17:14:12 <rwbarton> kmeyer: I really cannot endorse this but try  screen -c ghci
17:14:13 <kmeyer> lispy: looking...
17:14:17 <Cale> dpratt71: right.
17:14:28 <lispy> kmeyer: hmm...nothing special at all
17:14:31 <lispy> kmeyer: ghci $(filter-out -Wall,$(GHCFLAGS)) $(OPTLLDFLAGS) src/darcs.hs $(C_OBJS) $(OPTLLIBS)
17:14:32 <kmeyer> rwbarton: surely -c isn't what you mean
17:14:32 <rwbarton> kmeyer: argh, I mean   script -c ghci
17:14:40 <kmeyer> ok
17:15:10 <kmeyer> lispy: hm, weird
17:15:14 <Guenni> pumpkin: thx
17:15:18 <int80_h> blackh: http://hpaste.org/13873#a2
17:15:22 <lispy> kmeyer: what version of ghci?
17:15:24 <Cale> So if we have f :: a -> b -> c -> d, say, and x :: a, y :: b, z :: c
17:15:26 <kmeyer> 6.10
17:15:26 <Cale> Then:
17:15:32 <Cale> f x :: b -> c -> d
17:15:39 <dpratt71> ok, so if I try to apply this: (r -> r -> a) -> (r -> a) to something concrete...
17:15:40 <Cale> (f x) y :: c -> d
17:15:49 <Cale> ((f x) y) z :: d
17:16:03 <kmeyer> rwbarton: that does the opposite of what I want :D
17:16:05 <lispy> kmeyer: I've never tried that make target with ghc 6.10 and they did change the library that provides the readline interface.  It's possible that your problem is caused by the new editline
17:16:11 <Cale> So, you'll need to start with a function of two parameters of the same type...
17:16:20 <Cale> So, let's say (+)
17:16:24 <rwbarton> kmeyer: Oh
17:16:25 <dpratt71> like String -> String
17:16:32 <dpratt71> ok, + then
17:16:33 <Cale> String -> String -> String would do
17:16:37 <blackh> int80_h: You need to change "insert [] _ = [x]" to "...x" because you want insert to return a [Char].  [x] will give you a [[Char]]
17:16:42 <BONUS> (++) for example
17:17:00 <kmeyer> lispy: ah, that appears to be it!
17:17:03 <blackh> int80_h: (x:xs) applied to a [[Char]] will make 'x' be [Char]
17:17:03 <dpratt71> + is the r -> r part, right
17:17:07 <BONUS> (r -> r -> a) -> (r -> a) means that it takes a function that takes two r's and returns a function that takes only one r
17:17:09 <BONUS> yes!
17:17:15 <dpratt71> no, it's all of it isn't it
17:17:20 * kmeyer needs to revert back to 6.8 I guess
17:17:26 <Cale> dpratt71: It's the (r -> r -> a) part
17:17:33 <dpratt71> because (r -> r) is the a
17:17:34 <Cale> :t (+)
17:17:35 <lambdabot> forall a. (Num a) => a -> a -> a
17:17:40 <Cale> There is no (r -> r)
17:17:50 <lispy> kmeyer: maybe not, there have been some threads on the haskell-cafe mailing list about making editline behave
17:17:56 <Cale> Remember that r -> r -> a means r -> (r -> a)
17:18:01 <Cale> not (r -> r) -> a
17:18:11 <kmeyer> lispy: er, it worked in 6.8 (thought I didn't try it from a makefile)
17:18:13 <int80_h> blackh: it compiles!~
17:18:29 <int80_h> okay let's see how it breaks now
17:18:30 <dpratt71> ok, but -> takes two types and returns a type...
17:18:32 <blackh> int80_h: Type inference doesn't necessarily happen in the order you expect, so the errors can appear in places other than where the actual error is.
17:18:39 <Cale> @let plus :: Integer -> Integer -> Integer; plus x y = x + y
17:18:40 <lambdabot>  Defined.
17:18:44 <blackh> int80_h: Great!
17:18:47 <Cale> :t plus
17:18:48 <lambdabot> Integer -> Integer -> Integer
17:18:51 <Cale> :t join
17:18:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:18:55 <int80_h> I expect faulty output
17:18:58 <Cale> :t join plus
17:18:59 <lambdabot> Integer -> Integer
17:19:08 <BONUS> if you have r -> (r -> a) the first -> takes a r type and a (r -> a) type
17:19:08 <Cale> :t join plus 5
17:19:09 <lambdabot> Integer
17:19:14 <lispy> > let (+) 1 2 = 7 in 1 `L.plus` 2
17:19:15 <lambdabot>   3
17:19:30 <Cale> Follow that?
17:19:46 <dpratt71> let me ask it this way: how does (+) map to (r -> r -> a)
17:19:48 <blackh> int80_h: I find it helpful to stick types in, e.g. if you had added insert :: [Char] -> Char -> [Char], then the error message would have made more sense.
17:19:48 <bbs_> > log(10^(1/6))
17:19:48 <int80_h> blackh: heh, it's close
17:19:49 <lambdabot>   Add a type signature
17:19:52 <lispy> > let (+) 1 2 = 7 in (1 `L.plus` 2, 1 + 2)
17:19:54 <lambdabot>   (3,7)
17:19:58 <Cale> dpratt71: With r = Integer, a = Integer
17:20:03 <bbs_> > log(10^(1/6))
17:20:04 <lambdabot>   Add a type signature
17:20:07 <bbs_> bleh
17:20:15 <Cale> dpratt71: Or if you prefer, r = a, and Num a
17:20:18 <blackh> int80_h: I just keep adding type signatures until the errors start making sense.
17:20:23 <BONUS> an (a -> a -> a) function can act like a (r -> r -> a) function without a problem. all that (r -> r -> a) says is that the first two types have to be the same
17:20:29 <int80_h> blackh: how do I put types into a function inside another function?
17:20:41 <dpratt71> ok
17:21:03 <Cale> Different type variables are allowed to take on equal types
17:21:10 <blackh> int80_h: where insert :: [Char] -> Char -> [Char]
17:21:10 <kmeyer> lispy: it appears to be a problem with the package in Fedora -- 6.10 isn't linked with editline *or* readline
17:21:10 <blackh> int80_h:            insert [] _ = ...
17:21:16 <dpratt71> so if you "join" (+)
17:21:18 <Cale> > join (+) 5
17:21:19 <lambdabot>   10
17:21:37 <lispy> kmeyer: ah, that's unfortunate
17:21:48 <Cale> It becomes the function which adds its parameter to itself.
17:21:56 <int80_h> hahaha
17:22:02 <Cale> That is,  join (+) = (\x -> x + x)
17:22:04 <dpratt71> join will give you something that is a -> a, where Num a ?
17:22:06 <int80_h> intersperse ["one","two","three"] ','
17:22:07 <Cale> yeah
17:22:09 <kmeyer> lispy: means I don't have to do anything with my makefile :D
17:22:13 <int80_h> "two,three,one"
17:22:29 <blackh> int80_h: Brilliant!!
17:22:40 <Cale> (the Num class here is a little distraction, but I suppose it's not so bad to deal with it :)
17:22:48 <dolio> > intercalate ',' ["one","two","three"]
17:22:52 <chessguy> @op
17:22:56 <blackh> int80_h: You can also do things like this:
17:22:57 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
17:22:59 <lambdabot> Maybe you meant: . ? @ bf ft id map pl rc v wn yow
17:23:01 <dpratt71> so join just uses the a twice
17:23:03 <stevan> timbau: make sure you got the editline hackage package installed on the version of ghc you are using to build the new version. then export LD_RUN_PATH=$LIBEDIT/lib and LD_LIBRARY_PATH=$LIBEDIT/lib. ./configure LDFLAGS=-L$LIBEDIT/lib CPPFLAGS=-I$LIBEDIT/include LIBS="-ledit -lcurses" . then before making create the file libraries/editline/editline.buildinfo and put these lines there: buildable: True, cc-options: -I$LIBEDIT/include, ...
17:23:03 <Cale> > join (++) "hello"
17:23:09 <lambdabot>   "hellohello"
17:23:09 <stevan> ... ld-options: -L$LIBEDIT/lib, extra-libraries: edit ncurses, then make. hope it helps.
17:23:13 <dolio> > intercalate "," ["one","two","three"]
17:23:19 <lambdabot>   "one,two,three"
17:23:20 <blackh> int80_h: insert [] _ = x :: [Char]    <-- Tell it that you expect x to be a [Char]
17:23:20 <chessguy> hey Cale  can you @join LB to #novalang please?
17:23:27 <BONUS> like i said, you can think of a function being a box that contains what it will eventually return. so r -> (r -> a) is a box that contains a (r -> a). so join will flatten that box in a box (function in a function) to just one function
17:23:29 <chessguy> thanks
17:23:31 <Cale> lambdabot: @join #novalang
17:23:39 <dmwit> > intersperse ',' ["one", "two", "three"]
17:23:47 <int80_h> blackh: thanks
17:23:47 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
17:23:56 <Cale> A box which is indexed by values of type r
17:23:58 <dmwit> eh?
17:24:03 <dmwit> :t intersperse
17:24:09 <lambdabot> forall a. a -> [a] -> [a]
17:24:18 <blackh> int80_h: :: binds really loosely so you often have to put ( _something_ :: Type )
17:24:20 <dmwit> oh
17:24:42 <dmwit> > intersperse ',' "tee-hee"
17:24:51 <lambdabot>   "t,e,e,-,h,e,e"
17:25:09 <Cale> But perhaps it really is easier to just imagine it taking the function f, and producing the function (\x -> f x x)
17:25:10 <pumpkin> > intersperse ',' "RESPECT"
17:25:21 <lambdabot>   "R,E,S,P,E,C,T"
17:25:29 <dmwit> > expr (intersperse '\n' "RESPECT") :: Expr
17:25:30 <dpratt71> should I be amazed that someone was able to make the connection between m (m a) and partial function application?
17:25:35 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[Char]'
17:25:47 <dmwit> > fun (intersperse '\n' "RESPECT") :: Expr
17:25:50 <Cale> dpratt71: Which connection in particular?
17:25:55 <lambdabot>   R
17:25:59 <pumpkin> aw
17:26:01 <lambdabot>  E
17:26:18 <pumpkin> > greet "mr_jude"
17:26:19 <lambdabot>   a banana
17:26:24 <pumpkin> o.O
17:26:26 <dmwit> \bot must be overwhelmed, she's going slow as molasses
17:26:35 <dpratt71> well, I guess I mean turning partial function application into a Monad
17:26:36 <Cale> dpratt71: m = (->) e is perhaps a little surprising, but it's an idea which goes back maybe 50 years.
17:26:48 <dpratt71> 50 years ?!
17:26:50 <pumpkin> :t join
17:26:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:26:53 <Cale> Uh, it's not really partial function application which we're turning into a monad....
17:27:07 <Cale> It's the functions from a fixed type.
17:27:08 <dmwit> dpratt71: You'd be surprised how old most of computer science's coolest ideas are...
17:27:17 <Cale> Category theory is from the 1950's.
17:27:20 <dpratt71> right...forgot about the type
17:27:22 <pumpkin> I remember back when I was a young'un
17:27:30 <p_l> sometimes it feels like nothing got invented in last decade or two
17:27:33 <pumpkin> we had all these cool ideas and no computers to run them on
17:27:42 <pumpkin> forced us to think harder, those were the days
17:28:01 <Cale> pumpkin: What do you mean? We've always had rather nice computers to run them on! :)
17:28:01 <dmwit> uphill both ways, in the snow, no job, etc etc
17:28:07 <int80_h> it takes about 50 years for those cool ideas to trickle down
17:28:20 <int80_h> and you could buy a house for a nickel
17:28:21 <p_l> and some stuff that was done in old times are still faaar from being really used
17:28:22 <pumpkin> Cale: our minds! not like these lazy youngsters today
17:28:29 <Cale> My favourite computer is part of me.
17:28:34 <dpratt71> so...is join all we need to make this Monad...what's the name of this Monad, btw?
17:28:38 <pumpkin> dmwit: how did you know? I didn't think you were that old
17:28:40 <Cale> dpratt71: we also need return
17:28:45 <Cale> dpratt71: and fmap
17:28:48 <dpratt71> of course
17:28:57 <dpratt71> fmap?
17:29:08 <pumpkin> I like pronouncing fmap
17:29:10 <Cale> dpratt71: I call this the function monad, or the (->) e monad, or the Reader e monad.
17:29:10 <p_l> Cale: Now that's retrocomputing. I haven't seen a worse link-layer than human nervous system :P
17:29:21 <dmwit> dpratt71: fmap/join/return and bind/return are typically the two ways of specifying a monad.
17:29:25 <Cale> dpratt71: Every monad is also a functor.
17:29:30 <matthewp> starting Real World Haskell book club on Chapter 3 at #novalang
17:29:42 <dpratt71> ok...are you the only one who calls it thus? what do other people call it?
17:29:52 <BONUS> lot of people call it reader monad
17:29:54 <Cale> dpratt71: Well, the same things :)
17:29:55 <BONUS> i prefer function monad
17:30:07 <pumpkin> I call it a fad
17:30:11 * pumpkin grumbles
17:30:23 <dpratt71> "Reader" is not obvious to me...why "Reader"
17:30:42 <Cale> dpratt71: Because it expresses computations which "read" from an "environment" of type e
17:31:04 <dpratt71> ah, why didn't I think of that?
17:31:07 <diltsman> Is there a way to alias an integer?  Like I would like to have a line like func int1 = ...   where int1 is an alias for a constant?
17:31:17 <pumpkin> int1 = constant?
17:31:24 <BONUS> that'll become apparent once you see it in action :)
17:31:36 <dpratt71> maybe I should ask: why do we want a Reader e monad?
17:31:36 <pumpkin> @let int1 = 4
17:31:36 <dmwit> diltsman: You can write "foo = 3", but that won't let you pattern match on foo, unfortunately.
17:31:37 <lambdabot>  Defined.
17:31:40 <Cale> Once we invent do-notation, we'll be able to do things like:
17:31:56 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
17:31:57 <lambdabot>   ("hello","olleh","HELLO")
17:32:04 <dmwit> diltsman: However, you can get something similar by doing:
17:32:07 * Toxaris prefers environment-monad or context-monad
17:32:09 <sjanssen> diltsman: func x | x == int1 = ...
17:32:11 <Cale> That's a computation in this (->) e monad.
17:32:18 <dmwit> diltsman: func x | x == foo = bar | x == baz = quux
17:32:19 <dpratt71> that hurts my head
17:32:20 <Cale> (In this case, (->) String)
17:32:38 * wli wonders if his examples were helpful at all.
17:32:46 <diltsman> dmwit, sjanssen: thanks!  I completely missed that (rather obvious) answer.
17:32:49 <BONUS> dpratt: basically id receives "hello" and calls the result x. then reverse receives "hello" and calls the result y. etc. and then we return (x,y,z)
17:32:52 <Cale> So in that notation,  v <- f  means to apply f to the value which the whole computation gets applied to, in order to produce the result v
17:32:56 <dmwit> > liftM3 (,,) id reverse (map toUpper) "hello"
17:32:58 <lambdabot>   ("hello","olleh","HELLO")
17:33:27 <dpratt71> aren't there other ways to accomplish that?
17:33:29 <Cale> Or, thought of another way, it means to use f as a sort of projection of the "environment" of type e
17:33:32 <pumpkin> @docs Data.Function
17:33:32 <lambdabot> Data.Function not available
17:34:00 <pumpkin> aw, there's not much interesting stuff in there
17:34:01 <BONUS> dpratt: yeah there are but this is also one of them :)
17:34:04 <dmwit> dpratt71: Of course.
17:34:05 <Cale> > (do x <- fst; y <- snd; return (x^2 + y^2)) (3,4)
17:34:06 <lambdabot>   25
17:34:09 <dmwit> dpratt71: There are always manual ways of accomplishing things.
17:34:47 <pumpkin> Cale: that's pretty fancy :o
17:34:52 <dpratt71> ok, accepting that there is a good reason to have this...
17:34:57 <Cale> well...
17:35:10 <pumpkin> > join (==) 5 -- this is the most useful use of the -> a monad
17:35:10 <Cale> The only *real* reason for any abstraction is to save code, right?
17:35:12 <lambdabot>   True
17:35:13 <dpratt71> ...what do fmap and...uh...return look like?
17:35:19 <dmwit> dpratt71: It's a bit like asking whether "malloc" is the only way to allocate memory in C.  The answer is no, of course, but it's a very nice abstraction...
17:35:19 <Cale> fmap is composition
17:35:27 <Cale> (we discussed that earlier)
17:35:34 <Cale> fmap :: (a -> b) -> f a -> f b
17:35:41 <Cale> so, with f = (->) e
17:35:43 <Cale> that's
17:35:52 <Cale> fmap :: (a -> b) -> (e -> a) -> (e -> b)
17:35:57 <BONUS> return :: a -> f a. so a -> (e -> a)
17:35:57 <Cale> But what has that type?
17:36:02 <S3TH> omgomg
17:36:03 <S3TH> hai
17:36:10 <Cale> hello S3TH
17:36:12 <pumpkin> S3TH: hai
17:36:16 <dmwit> > curry (\x y -> x^2 + y^2) (3, 4)
17:36:17 <lambdabot>       Overlapping instances for Show (b -> ((t, t1), b) -> ((t, t1), b))
17:36:17 <lambdabot>     ...
17:36:19 <dmwit> S3TH: Hiya!
17:36:27 <wli> fmap and return are not enough; you need join, too.
17:36:28 <dmwit> > uncurry (\x y -> x^2 + y^2) (3, 4)
17:36:30 <lambdabot>   25
17:36:38 <Cale> wli: We've finished with join ;)
17:36:46 <dpratt71> may I interject that I appreciate all the patient guidance, Cale, BONUS, et al
17:36:47 <pumpkin> but join is the most fun one!
17:36:52 <BONUS> :)
17:36:53 <Cale> dpratt71: No problem :)
17:37:02 <BONUS> we have nothing better to do, really
17:37:03 <pumpkin> join (==) is my favorite function of all
17:37:04 <Cale> dpratt71: I actually rather like explaining this stuff :)
17:37:12 <Cale> pumpkin: heh
17:37:19 <Cale> > join (==) (0/0)
17:37:20 <lambdabot>   False
17:37:21 <dpratt71> so the question is, what has type (a -> b) -> (e -> a) -> (e -> b) ?
17:37:23 <pumpkin> :)
17:37:30 <pumpkin> it's ~const True
17:37:41 <Cale> dpratt71: yeah
17:37:55 <Cale> dpratt71: removing the last pair of parens might help you to define it
17:38:02 <Cale> (a -> b) -> (e -> a) -> e -> b
17:38:10 <Cale> fmap f g x = ...
17:38:13 <Cale> f :: a -> b
17:38:13 <BONUS> it takes two functions and an e
17:38:18 <Cale> g :: e -> a
17:38:19 <Cale> x :: e
17:38:22 <BONUS> you need to end up with a b
17:38:26 <Cale> yeah
17:38:29 <dpratt71> sorry...getting distracted by the freaky dancer on the TV
17:38:38 <Cale> So, what can we do?
17:38:42 <Cale> We can apply g to x
17:38:46 <Cale> g x :: a
17:38:53 <Cale> and then we can apply f to that
17:38:58 <Cale> f (g x) :: b
17:39:04 <Cale> and that's all we can really do
17:39:12 <Cale> So:
17:39:17 <Cale> fmap f g x = f (g x)
17:39:25 <Cale> There's no real choice in the matter.
17:39:43 <BONUS> goin to bed. good night, see ya y'all!
17:40:04 <Cale> So looked at another way, (fmap f g) is what we'd call the composite of f and g
17:40:15 <Cale> You see it written in mathematics with a little circle
17:40:24 <Cale> and in Haskell, we usually use a dot:  f . g
17:40:32 <Cale> (f . g) x = f (g x)
17:40:39 <dpratt71> right...I've seen a lot of those little circles lately
17:40:43 <wli> What's the TeX symbol? \circ?
17:40:47 <Cale> wli: yeah
17:40:47 <Toxaris> can there be more then one lawful fmap for a Haskell data type?
17:41:15 <wli> f . g = f `fmap` g
17:41:23 <dmwit> Toxaris: yes
17:41:28 <Cale> dmwit: are you sure?
17:41:36 <dmwit> er, no?
17:42:00 <dmwit> What are the laws for fmap?
17:42:00 <Cale> I think the answer might actually be no, but only for the reason that Haskell types are restrictive in terms of how they can be constructed.
17:42:13 <Cale> fmap (f . g) = fmap f . fmap g
17:42:17 <Cale> and  fmap id = id
17:42:28 <Cale> are the laws that fmap is supposed to satisfy
17:42:54 <Toxaris> I would guess that the first law rules out swapping components, and the second law rules out messing with strictness
17:43:08 <Cale> Maybe with the new type-families stuff, you can create more interesting functors.
17:43:17 <dolio> The second rules out some obvious choices.
17:43:19 <Toxaris> but I'm not sure how that intuition applies to data types containing function types
17:43:21 <dmwit> data Foo a = Left a | Right a
17:43:25 <dolio> Like 'fmap _ _ = []'
17:43:33 <dmwit> fmap can act on Lefts only, or Rights only.
17:43:37 <dolio> For lists.
17:43:49 <dmwit> (Or both!)
17:44:06 <dmwit> (Or neither, for that matter.)
17:44:09 <Cale> Toxaris: basically, the second means you can't mess with the structure, and the polymorphism of fmap means that you can't really mess with the elements apart from applying the function
17:44:26 <byorgey> dmwit: no, you have to turn a Foo a into a Foo b
17:44:33 <dmwit> Oh, I'm wrong.
17:44:35 <dmwit> yeah
17:44:35 <Toxaris> dmwit: kind error
17:44:36 <byorgey> dmwit: if your fmap doesn't act on Lefts, how do you get a b ?
17:44:50 <dmwit> byorgey: right
17:45:02 <dmwit> byorgey: I got there mere seconds after you did. =P
17:45:06 <byorgey> hehe
17:45:08 <Toxaris> a Functor instance for Either can only act on Rights, a Left-acting instance would be of (Flip Either)
17:45:20 <byorgey> don't worry, I say silly things like that all the time
17:45:45 <Cale> See, you're not allowed to actually *look* at the elements, because of the polymorphism of fmap, and you can't really observe the function you're supplied, for the same reason, but then fmap id = id means that you can't alter the structure of the thing you're given.
17:46:08 <dolio> Foo ~~ (,) Bool
17:46:10 <Toxaris> Cale: what is the meaning of "structure of the thing" in the presence of function types?
17:46:24 <Cale> Toxaris: Well, you can think of a function as a set of pairs.
17:46:38 <byorgey> IRC doesn't fit well with my temperament.  I think at a very intuitive level and it takes me a while to work out implications of things, but on IRC you have to say something within 15 seconds or not at all. =P
17:46:40 <ski_> fmap f (Left a) = Right (f a)  -- not a valid `fmap'
17:46:44 <Cale> Toxaris: The "structure" is everything except for the second element of each of those pairs.
17:47:45 <ski_> fmap f (b,a) = (not b,f a)  -- not valid either
17:47:51 <Cale> dpratt71: okay, is that enough diversion? :)
17:48:08 <dpratt71> is there an example of using fmap directly with this Monad?
17:48:09 <Cale> dpratt71: So fmap in the case of functions is just function composition
17:48:17 <Cale> > fmap (+1) (*2) 5
17:48:19 <lambdabot>   11
17:48:28 <Cale> > (+1) ((*2) 5)
17:48:29 <Toxaris> dpratt71: oh sorry for stealing your teachers for a moment :)
17:48:29 <lambdabot>   11
17:48:31 <int80_h> @src intersperse
17:48:31 <lambdabot> intersperse _   []     = []
17:48:31 <lambdabot> intersperse _   [x]    = [x]
17:48:31 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
17:48:45 <dpratt71> Toxaris: I needed the break
17:48:48 <Cale> > (+1) (5*2)
17:48:50 <lambdabot>   11
17:48:51 <dpratt71> thanks
17:48:53 <Cale> > (5*2) + 1
17:48:54 <lambdabot>   11
17:49:43 <Cale> dpratt71: Of course, whenever we would use fmap for the function Functor, we could always just have used the (.) operator instead.
17:50:02 <dmwit> ?instances Applicative
17:50:03 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
17:50:19 <dmwit> ?instances-importing Control.Applicative Applicative
17:50:20 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
17:50:27 <dmwit> ?src ZipList
17:50:27 <lambdabot> Source not found. I feel much better now.
17:50:27 <Cale> dpratt71: But, see, the real reason we recognise things as monads is so that code which works for any monad will work for these things.
17:50:37 <dmwit> Isn't ZipList a newtype for []?
17:50:47 <Toxaris> dmwit: indeed.
17:50:47 <Cale> dmwit: yes
17:50:59 <dmwit> In which case, there are two fmap's for [].
17:51:00 <Cale> dpratt71: There are lots of interesting things which one can write that work in any monad at all.
17:51:05 <Cale> :t sequence
17:51:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:51:07 <dpratt71> so, considering fmap (+1) (*2) 5...
17:51:15 <Cale> sequence is my favourite beginner example
17:51:18 <Toxaris> dmwit: they are the same module ZipList / getZipList
17:51:20 <dpratt71> 5 is e...
17:51:26 <Toxaris> s/module/modulo
17:51:32 <Cale> dpratt71: 5 :: e
17:51:33 <Toxaris> dmwit: only the <*> is different
17:51:41 <dmwit> ah
17:51:41 <gwern> by the six teats of barabel! is Cale going to blow another beignner's mind? YOU MONSTER
17:51:52 <dmwit> ?go barabel
17:51:53 <dpratt71> (*2) :: e -> a ...
17:51:55 <lambdabot> http://starwars.wikia.com/wiki/Barabel
17:52:08 <dolio> The pure is different, too.
17:52:16 <dolio> pure a = [a] vs pure a = repeat a
17:52:21 <dpratt71> (+1) :: a -> b
17:52:30 <Cale> dpratt71: Of course, (*2), (+1) :: (Num a) => a -> a
17:52:38 <Cale> Or if you prefer, Integer -> Integer
17:52:39 <dpratt71> of course
17:52:48 <Cale> So e and a and b are the same type
17:52:56 <Cale> (in this example)
17:53:04 <dpratt71> but that's coincidence in this case?
17:53:05 * gwern shakes fist at lambdabot. very clever lb, very clever. I'll thwart you yet tho!
17:53:07 <Cale> > fmap length show 15
17:53:09 <lambdabot>   2
17:53:10 <dpratt71> right
17:53:10 <Cale> yeah
17:53:37 <dpratt71> it seems to reverse the normal expected order of operations
17:53:54 <Cale> mmm... depends on what's usual for you
17:54:06 <Cale> fmap length show 15 = length (show 15)
17:54:22 <Cale> They textually stay in the same order.
17:54:40 <dpratt71> good point
17:55:06 <Cale> Okay, so, return...
17:55:14 <Cale> return :: a -> m a
17:55:16 <dpratt71> is it a coincidence that -> is right associative also ?
17:55:16 <Cale> and in our case,
17:55:30 <Cale> uh... not *such* a coincidence
17:55:42 <Cale> It's part of the conspiracy which makes currying convenient
17:56:01 <harblcat> is there a suitable workaround for the 'hSetBuffering stdin NoBuffering' problem on Win32?
17:56:07 <Cale> Hehe, the Currying Convenience Conspiracy, or CCC ;)
17:56:10 <dpratt71> so...return
17:56:11 <Peaker> could be nice if it was:  15 show     15 show length     and    15 show (length fmap) :-)     left-to-right piping ftw :)
17:56:36 <Cale> (c'mon *someone* here has to be nerdy enough to be laughing out loud at that last line :)
17:56:40 <gwern> Cale: now add a P
17:56:59 <ski_> (Cale : too tired to laugh, atm)
17:57:03 <pumpkin> I almost went to the CCC
17:57:14 <gwern> LETS ALL CURRY IN ACCORDANCE WITH THE SOCIALIST LIFESTYLE
17:57:17 <Cale> gwern: (to ruin the joke, CCC also stands for Cartesian Closed Category, which is the sort of category in which currying makes sense)
17:57:19 <dmwit> harblcat: Compile instead of interpreting, maybe?
17:57:40 <Cale> dpratt71: right...
17:57:44 <Cale> return :: a -> m a
17:57:50 * wli thinks of it as a structure F where any morphism g : X -> Y provides a corresponding morphism g' : F X -> F Y with a sort of canonical injection and projection pair, where the injection is X -> F X and the projection from F (F X) -> F X. IOW, fmap, return, join.
17:57:50 <gwern> Cale: oh. so... it wasn't a soviet union joke?
17:57:51 <Cale> return :: a -> (e -> a) -- in our case
17:57:53 <harblcat> dmwit: I'll try that.
17:58:06 <dpratt71> right
17:58:10 <Cale> Or, return :: a -> e -> a
17:58:12 <dpratt71> a -> e -> a
17:58:16 <Cale> removing unnecessary parens, yeah
17:58:16 <dpratt71> right
17:58:22 <Cale> So:
17:58:22 <wli> Uncurried combinators are counterrevolutionary. ;)
17:58:34 <Cale> return v x = ...
17:58:43 * ski_ wants cocurrying ..
17:58:45 <dpratt71> thinking...
17:58:54 <Cale> v :: a
17:58:56 <Cale> x :: e
17:59:05 <Cale> return v x :: a
17:59:07 <mmorrow> wli: why the asymmetry with F (F X) -> F X ?
17:59:15 <mmorrow> instead of F X -> X
17:59:17 <harblcat> nope, didn't work...
17:59:19 <ski_> (wli : would that be corevolutionary, then ?)
17:59:41 <ski_> mmorrow : `F X -> X' is for comonads
17:59:59 <Cale> mmorrow: F X -> X doesn't allow for enough interesting things to happen...
18:00:03 * mmorrow scrolls back
18:00:33 <mmorrow> but by that same token does X -> F X ?
18:00:34 <Cale> Personally, I like the description of monads by string diagrams, but that's rather abstract.
18:00:35 <ski_> (but possibly `F X -> X' allows for enough interesting thing to have *happened* ?)
18:00:56 <wli> mmorrow: Well, F (F X) -> F X describes it in terms of the original X, and also, it says the structure has a way of flattening it out to un-nested analogues vs. projecting back.
18:00:56 <Cale> mmorrow: Well, if you put them together...
18:01:39 <dpratt71> so with return, can we discard the x?
18:01:43 <mmorrow> wli: ah, ok. so F is it's own "inverse"
18:01:56 <Cale> mmorrow: If we had just return :: X -> F X, and extract :: F X -> X, the only interesting law you could write would be extract . return = id
18:02:03 <Cale> dpratt71: yep :)
18:02:10 <Cale> dpratt71: We already have what we want :)
18:02:17 <Cale> return v x = v
18:02:22 <dpratt71> ah
18:02:29 <dpratt71> very good
18:02:37 <mmorrow> Cale: i'm just putting a good word in for symmetry, that's all ;)
18:02:54 <Cale> mmorrow: You might care to look at *algebras* of a monad.
18:03:27 <Cale> mmorrow: That is, given a monad M, an M-algebra is a *specific* object X, together with a map F X -> X, satisfying some obvious-enough laws.
18:03:36 * mmorrow notes that his scrollback only goes about 20 lines, and he probably has no idea what this conversation is really about
18:03:54 <Cale> mmorrow: wli just gave a description of his favourite definition of a monad.
18:04:24 <Cale> mmorrow: Meanwhile, I've been explaining the basics of the function monad to dpratt71.
18:04:30 <mmorrow> ahh, hmm. ok, well in this case the asymmetry is justified, since we're looking from the point of view of a monad
18:05:19 <wli> You can flip the directions of the morphisms and require a canonical projection F X -> X and canonical injection F X -> F (F X) but the ability to nest arbitrarily once already given a value is a wee bit painful. I guess the X -> Y morphisms inducing F X -> F Y morphisms probably don't need to change, though maybe you could flip them in some way that makes constructive affairs painful.
18:05:20 <dpratt71> so...there are several interesting instances of the Monad pattern...
18:05:37 <Cale> dpratt71: yes
18:05:39 <dpratt71> ...at this point the differences seem coincidental
18:05:56 <mmorrow> wli: i understand now why you chose (a -> m a -> m (m a) -> m a) :)
18:06:02 <Peaker> Cale: have you compared the approaches of teaching Functor, Applicative, then Monad,  to directly teaching Monads?  Intuitively, I'd guess the former teaching method might have advantages?
18:06:11 <dpratt71> in other words, I'm not sure if I could look at something and say "aha, Monad"
18:06:14 <Cale> dpratt71: and the *only* reason that any abstraction in programming is useful is that it saves us from writing the same code over and over.
18:06:17 <kmeyer> hey, how do I use qualified operators imported from another module?
18:06:21 <Cale> dpratt71: That's okay.
18:06:33 <Cale> dpratt71: For now, just try to understand the particular examples.
18:06:34 <dpratt71> Cale tried that
18:06:37 <Peaker> Abstraction also allows us to be agnostic to various changes and our code continues to be correct
18:06:54 <dpratt71> I jumped right in with Monads
18:06:55 <mmorrow> @type (join .) . flip fmap
18:06:56 <lambdabot> forall a a1 (f :: * -> *). (Functor f, Monad f) => f a1 -> (a1 -> f a) -> f a
18:07:10 <Peaker> dpratt71: Its useful to know Functor and Applicative anyway, and they are easier to understand, IMO
18:07:18 <mmorrow> @type flip ((join .) . fmap)
18:07:19 <lambdabot> forall a a1 (f :: * -> *). (Functor f, Monad f) => f a1 -> (a1 -> f a) -> f a
18:07:19 <Cale> dpratt71: So, well, we really should introduce >>= properly
18:07:25 <Cale> dpratt71: and do-notation
18:07:30 <mmorrow> interestingly, @pl can only identify one of those
18:07:33 <dpratt71> please proceed
18:07:33 <kerlo> Can I easily make Linux binaries using GHC on my Windows machine?
18:07:37 <mmorrow> @pl (join .) . flip fmap
18:07:38 <lambdabot> (join .) . flip fmap
18:07:43 <mmorrow> @pl flip ((join .) . fmap)
18:07:43 <lambdabot> (>>=)
18:07:44 <Cale> dpratt71: But let me skip ahead just a little, and look at a function which is not primitive, called sequence
18:07:47 <dpratt71> but should we talk about Applicative?
18:07:53 <kerlo> If not, can I easily make Linux binaries for one machine using GHC on another Linux machine?
18:07:58 <Cale> Applicative we can leave until later.
18:07:58 <wli> mmorrow: x >>= f = join $ fmap f x here, though reputedly some monads more naturally write join in terms of (>>=) instead of vice-versa.
18:08:04 <dpratt71> very well
18:08:09 <Cale> :t sequence
18:08:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
18:08:22 <Cale> So, for any monad m, it takes a list of values of type m a
18:08:25 <Peaker> @type result
18:08:26 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
18:08:28 <Cale> and gives an m of lists of a
18:08:39 <mmorrow> (=<<) = (join .) . fmap
18:08:41 <Peaker> @type \f -> (result.result) f
18:08:42 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
18:08:59 <mmorrow> i like that equivalence myself
18:08:59 <Cale> We've been mostly thinking of values of type m a as "containers of values of type a"
18:09:03 <Peaker> @type \f g -> ((result.result) f g, (f.) . g)
18:09:04 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> (a -> a1 -> c, a -> a1 -> c)
18:09:08 <mmorrow> just because it's purdy
18:09:10 <gwern> kerlo: you can fairly easily heavily staticly link binaries if that's what you mean
18:09:15 <mmorrow> (syntactically)
18:09:18 <Cale> But another way, which is equally valid, is to think of them as "computations whose result is of type a"
18:09:24 <dpratt71> before you get too far ahead of me...
18:09:32 <dpratt71> ...where did sequence come from?
18:09:52 <Cale> sequence is something which can be defined in terms of the functions we've already discussed
18:09:56 <Cale> (and recursion on lists)
18:10:16 <Cale> But its definition in terms of fmap, join and return, is perhaps a little awkward
18:10:24 <kerlo> gwern: well, ghc --make on a Windows machine will generally make a Windows executable, won't it?
18:10:29 <dpratt71> ok...
18:10:35 <Cale> Hmm... maybe I really should introduce the rest of the stuff needed to define it first.
18:10:39 <Cale> Let's do that.
18:10:48 <Cale> Okay, so we'll start with >>=
18:10:53 <dpratt71> bind?
18:10:55 <Cale> yes
18:11:00 <gwern> kerlo: I was looking at your 'linux binaries for one from another linux machine' question
18:11:05 * kerlo nods
18:11:06 <Cale> x >>= f = join (fmap f x)
18:11:06 <gwern> don't see what windows has to do with it
18:11:41 <Cale> this is something which is always true, so if we have definitions of join and fmap, we can get a definition for >>=
18:11:45 <kerlo> Well, I did also ask a' Linux binaries from a Windows machine' question.
18:11:51 <Cale> But we can also go the other way:
18:12:01 <Cale> join x = x >>= id
18:12:09 <kerlo> Anyway, is the output of ghc --make on one machine likely to depend on libraries that the other machine doesn't have?
18:12:23 <dpratt71> some would call that circular reasoning
18:12:23 <Cale> fmap f x = x >>= (return . f)
18:12:36 <wli> (for lists, (>>=) = flip concatMap and join = concat)
18:12:47 <Cale> dpratt71: Well, it's only circular if we don't provide a proper definition of one or the other to get us started.
18:12:50 <gwern> kerlo: currently on linux ghc links in binaries. unless you're using the GHC API or something like that, binaries are generally pretty standalone
18:12:54 <dpratt71> right
18:13:03 <gwern> *staticly links libraries into binaries
18:13:13 <Cale> dpratt71: The point is that we can choose to either define fmap, return and join, or to define return and >>=
18:13:14 <dpratt71> it makes it hard for me to reason, though
18:13:28 <harblcat> are there any alternatives that I could use, seeing as NoBuffering is apparently broken in Win32 currently?
18:13:31 <Cale> Let's take a look at >>= and what it means.
18:13:43 <Cale> We've been looking at the function monad a lot...
18:13:57 <Cale> but let's use the list monad to start
18:14:10 <Peaker> @type let ap ff aa = join (fmap (\f -> fmap f aa)) in ap
18:14:14 <lambdabot>     Occurs check: cannot construct the infinite type:
18:14:14 <lambdabot>       f = (->) (f (a -> b))
18:14:14 <lambdabot>     Probable cause: `fmap' is applied to too many arguments
18:14:20 <kerlo> gwern: okay, sounds like it should work fine if everything goes well.
18:14:23 <Cale> Well, for the list monad, fmap f x = map f x
18:14:25 <Peaker> @type let ap ff aa = join (fmap (\f -> fmap f aa) ff) in ap
18:14:27 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => m (a -> a1) -> m a -> m a1
18:14:36 <wli> The circular bits are not too big a deal; one can just view them as relations between the class methods.
18:14:37 <Cale> hey, actually, want to come to #haskell-overflow?
18:14:41 <dpratt71> do I remember correctly that >>== takes an M a and an a -> b and returns M b ?
18:14:49 <Peaker> cool, never thought about using join,fmap  to build  ap :-)
18:14:56 <chessguy> dpratt71:  the second parameter is a -> m b
18:14:59 <Cale> (>>=) :: M a -> (a -> M b) -> M b
18:15:21 <Peaker> @pl \ff aa -> join (fmap (\f -> fmap f aa) ff)
18:15:21 <lambdabot> (join .) . flip (fmap . flip fmap)
18:15:38 <Peaker> it should say: ap :-)
18:15:45 <dpratt71> Cale: assuming you meant me, I'm in overflow
18:15:48 <Cale> okay
18:16:11 <Cale> er...
18:16:13 <rwbarton> @type (join .) . flip (fmap . flip fmap)
18:16:14 <Cale> You are?
18:16:15 <lambdabot> forall a b (f :: * -> *). (Functor f, Monad f) => f (a -> b) -> f a -> f b
18:16:19 <Cale> @haskell-overflow
18:16:19 <lambdabot> Unknown command, try @list
18:16:21 <Cale> er
18:16:24 <Cale> #haskell-overflow rather
18:16:33 <dpratt71> LOL
18:16:50 <PHO_> hmm, www.haskell.org is down?
18:16:52 <gwern> I wonder how the HAppS people live with themselves for picking a name like that
18:16:55 <dpratt71> actually, I'm in "#haskell-overflow?"
18:17:11 <Cale> oh!
18:17:12 <Cale> hehe
18:17:12 <byorgey> hehe
18:17:21 <gwern> the fools! damn them! damn them to hell! I told them to use Integer and not Int!
18:19:37 <dancor> overflol
18:22:23 <Peaker> rwbarton: Cale above said you could define sequence (Which is basically equivalent in expressiveness to Applicative) with just return, join, and fmap. So I wondered how, and found that (just join and fmap)
18:22:36 <dino-> I don't mind the name HAppS. It's the capitalization that's bleh.
18:22:59 <roconnor> @type (join .) . liftM
18:23:13 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m a) -> m a1 -> m a
18:23:26 * wli got ap = flip $ (join .) . fmap . flip fmap
18:23:40 <roconnor> @type flip $ (join .) . liftM
18:23:41 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => m a1 -> (a1 -> m a) -> m a
18:23:55 * wli supposes flip commutes with (join .) under composition.
18:24:15 <byorgey> how is sequence equivalent in expressiveness to Applicative?
18:24:29 <byorgey> if you need join to implement it, then it is strictly more expressive than Applicative
18:24:46 <Peaker> byorgey: you don't "need" join to implement it
18:24:47 <dolio> You need liftA2.
18:24:50 <dolio> And pure.
18:24:57 <Peaker> byorgey: if you only have fmap, join,  you can implement it
18:25:09 <Peaker> byorgey: but you can also implement it using only pure, <*>
18:27:09 <byorgey> ok, I see what you're saying
18:27:31 <byorgey> but if you can implement it with only pure and <*>, then you should be able to also implement it using only fmap and return (and not join).
18:27:52 <Peaker> byorgey: fmap and pure/return are less expressive than Applicative
18:28:03 <byorgey> oh, right, sorry
18:28:06 <Peaker> byorgey: because you cannot "combine" computations into a single computational result
18:28:23 <byorgey> indeed, brain fart =)
18:28:51 <Peaker> The Monad/(Functor,Applicative) dichotomy in the library is misleading and confusing.. class aliases to the rescue?
18:29:14 <byorgey> Functor -> Pointed -> Applicative -> Monad
18:29:29 <byorgey> yes, class aliases would be nice =)
18:29:30 <dolio> Don't need class aliases. Just fix the hierarchy.
18:29:37 <dolio> And ignore the people who complain about it. :)
18:30:14 <PHO_> aha, we did it all the time, dolio :)
18:30:19 <byorgey> or just whack them with the You're Wrong Stick
18:31:09 <byorgey> @type sequence
18:31:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
18:32:00 <mmorrow> rwbarton: (looking at the logs) `ty' also does expressions (not sure if you were doing `typeOf' for another reason...):
18:32:02 <mmorrow> , [$ty| let id' :: (Real a, Fractional a) => a -> a; id' = id in id' 3 |]
18:32:08 <lunabot>  forall a . (Real a, Fractional a) => a
18:32:19 <mmorrow> , typeOf (let id' :: (Real a, Fractional a) => a -> a; id' = id in id' 3)
18:32:21 <lunabot>  Double
18:33:29 <rwbarton> mmorrow: In this case I wanted to know about defaulting
18:33:44 <mmorrow> heh, i figured that coulda been it..
18:34:16 <m3ga> trying to install ghc-6.10.1 on Ubuntu 8.10 machine. Have ghc-6.8.2. Compile fails with http://hpaste.org/13876
18:34:21 <m3ga> any ideas why
18:34:45 <mmorrow> that's only the docs that failed
18:35:03 <mmorrow> (did this cause th ecompilation proper to fail?)
18:35:20 <mmorrow> if so i'd call that a bug
18:35:25 <byorgey> m3ga: also, is there a particular reason you're trying to compile from source rather than use a binary distribution?
18:36:00 <m3ga> i will either install a .deb or from source. i really don't like mixing debs and other random binary packages
18:36:13 <m3ga> i prefer not to install from source
18:36:27 <m3ga> but there is no deb
18:36:48 <byorgey> I fail to see the difference between installing from source and using a pre-packaged .tgz which already has a compiled binary.
18:36:53 <gwern> m3ga: you know the binaries ghc hq provides of ghc work well enough on ubuntu
18:36:58 <gwern> wut byorgey sez
18:37:30 <byorgey> although I understand preferring to stay with your OS's native packaging system whenever possible.
18:37:55 <gwern> not gonna happen with ubuntu/debian tho
18:38:06 <m3ga> byorgey is right. .debs work really, really well.
18:38:13 <m3ga> gwern: why?
18:38:45 <byorgey> m3ga: anyway, does that error stop the entire compile/build process?
18:38:56 <m3ga> yes, I updated the hpaste
18:39:50 <byorgey> m3ga: hmm... the documentation should not be necessary.  is there an option to disable the documentation?
18:39:59 <m3ga> gwern : why is the "not gonna happen with ubuntu/debian tho"
18:40:48 <gwern> m3ga: don't believe in yourself! believe in the me who believes in you!
18:41:14 <gwern> m3ga: er, I mean, ubuntu always gets its haskell packages from debian, and the debian devs might as well have retired, the ones who do ghc are so slow
18:41:30 <gwern> I mean, they haven't even packaged up 6.8.3, and that's been out like, a year
18:41:43 <m3ga> so its a problem of not enough work rather than licensing issues
18:41:49 <gwern> yes
18:42:41 <m3ga> pity. i've been coding in ocaml for 4 years and the debian-ocaml-maintainers group do an outstandingly brilliant job
18:43:13 <gwern> well, it's not a huge deal
18:43:28 <gwern> since cabal-install means you're going to spend most of your haskell time outside apt anyway
18:44:23 <m3ga> cabal is *far* more painful than apt-get. I have at least 6 machines I develop on. installing from source on all four machines is just plain broken.
18:45:34 * gwern shrugs. I was going to suggest you go to arch then for better haskell support, but if source-based is out on principle...
18:46:15 <gwern> > head $ take 1 [1..10]
18:46:16 <m3ga> four machine are for work, all ubuntu based.
18:46:17 <lambdabot>   1
18:46:22 <gwern> > head 1 [1..10]
18:46:23 <lambdabot>       No instance for (Num [[t] -> a])
18:46:23 <lambdabot>        arising from the literal `1' at...
18:46:26 <gwern> > head [1..10]
18:46:28 <lambdabot>   1
18:46:38 <gwern> (thought as much)
18:50:20 <CakeProphet> gwern:  it would be simple enough to have a Haskell repos hosted somewhere, instead of usng cabal.
18:50:25 * CakeProphet also has trouble using cabal.
18:50:54 <CakeProphet> mostly lambdabot.
18:51:07 <gwern> CakeProphet: sure. but no one has bothered to set up an apt repo for haskell packages
18:51:12 <gwern> (recently, anyway)
18:51:24 <pumpkin> lambdabot is a real pain to compile on 6.10, but 6.8 is pretty easy
18:51:24 <gwern> as for lambdabot, well, blame ghc for that? :)
18:51:46 <pumpkin> or blame haskell-src-exts for changing its API significantly :P
18:51:58 <gwern> what's a pain about 6.10 other than mueval?
18:52:27 <Guenni> hi, I'd need some help with deriving Data,Typeable: http://hpaste.org/13878
18:52:32 <pumpkin> well you need to explicitly request the earlier src-exts
18:52:35 <pumpkin> :P
18:52:55 <gwern> oh, that
18:53:21 <CakeProphet> gwern:  no, I choose to blame the package manager, since it's supposed to be responsible for maintaining dependencies.
18:53:21 <gwern> I knew I meant to push my patch to do that
18:53:40 * wli has been having some headaches with arrays recently.
18:53:41 <pumpkin> gwern: to require an earlier src-exts or to be compatible with the new one?
18:53:45 <gwern> former
18:53:47 <pumpkin> wli: like what?
18:53:49 <gwern> I mean, yes
18:53:50 <gwern> dammit
18:55:01 <wli> Grinding out an SVD routine has tripped over some awkwardnesses surrounding evaluating, pretty-printing, forming, slicing, etc. arrays.
18:55:11 <CakeProphet> gueenni huh. What does deriving Data do?
18:55:28 <chessguy> wli: long time no see
18:55:35 <wli> Of course, I'm using the most naive possible SVD algorithm.
18:56:15 <wli> (You can't fart around with Haskell-implemented multi-precision floating point numbers very easily with LAPACK FFI stuff.)
18:56:23 <gwern> ok, lb now requires a old src-exts
18:56:33 <gwern> cabal installs for me on 6.10
18:58:11 <wli> I'm basically kinda-sorta doing Gram-Schmidt from both the left and right with the goal of annihilating the off-diagonal portion of a border.
18:58:51 <CakeProphet> :t TypeRep
18:58:52 <lambdabot> Not in scope: data constructor `TypeRep'
18:58:58 <CakeProphet> :k TypeRep
18:58:59 <lambdabot> *
18:59:10 <CakeProphet> :t Data.Typeable.TypeRep
18:59:11 <lambdabot>     Not in scope: data constructor `Data.Typeable.TypeRep'
19:00:25 <CakeProphet> > typeOf 2
19:00:26 <lambdabot>   Integer
19:00:42 <CakeProphet> > (typeOf 2) == (typeOf 4)
19:00:43 <lambdabot>   True
19:00:50 <CakeProphet> huh, didn't know Haskell could reason about types at runtime.
19:02:41 <CakeProphet> > cast 5 :: Maybe Double
19:02:42 <lambdabot>   Nothing
19:03:08 <CakeProphet> > cast 1 :: Maybe Bool
19:03:09 <lambdabot>   Nothing
19:03:09 <Guenni> CakeProphet: sry, didn't see it right away, I need it for use in HAppS.IxSet
19:03:20 <pumpkin> what would be the easiest way to get a Float/Double's IEEE representation into a ByteString without excesssive overhead? an unsafeCoerce (assuming platform uses native IEEE floats)
19:03:23 <pumpkin> ?
19:03:28 <wli> I guess what I'm really doing is trying to solve these systems of quadratic equations where variables are segregated into two distinct sets so you have vectors u, v and matrices A_k so u^T A_k v = 0 is how they shake out. There's even more structure, though.
19:03:38 <CakeProphet> Guenni:  oh. I'm just not sure what deriving Data does, since I've never seen it. (is learning Haskell still)
19:03:49 <wli> s/solve/numerically solve/
19:03:57 <Guenni> CakeProphet: me too :)
19:04:31 <CakeProphet> > typeOf (typeOf 3)
19:04:33 <lambdabot>   TypeRep
19:04:38 <CakeProphet> ha.
19:05:15 <CakeProphet> cast 'a' :: Maybe String
19:05:20 <CakeProphet> > cast 'a' :: Maybe String
19:05:21 <lambdabot>   Nothing
19:05:26 <CakeProphet> ..I can't figure out cast.
19:06:06 <pumpkin> :t cast
19:06:07 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
19:06:12 <ahunter> > cast "a" :: Maybe String
19:06:14 <lambdabot>   Just "a"
19:06:20 <rwbarton> It's not so much "cast" as "is this a value of type foo?"
19:06:32 <CakeProphet> ...ooooh.
19:06:58 <CakeProphet> rwbarton:  can it do actual casting as well?
19:06:58 <ahunter> :)
19:06:58 <ahunter> hey, that type error is less fun in C
19:06:58 <pumpkin> so a bit like a java cast, where it'll throw an exception if you fail
19:06:58 <pumpkin> ?
19:06:58 <pumpkin> except here it gives you Nothing?
19:06:58 <ahunter> and twice as easy
19:06:59 <rwbarton> CakeProphet: No
19:07:13 <rwbarton> CakeProphet: Well, I don't know what you mean by "actual casting"
19:07:20 <pumpkin> :t unsafeCoerce
19:07:21 <lambdabot> Not in scope: `unsafeCoerce'
19:07:24 <rwbarton> CakeProphet: It can perform the identity cast, which is the only one that exists in Haskell
19:07:25 <CakeProphet> get one type  from another.
19:07:34 <CakeProphet> alright.
19:10:15 <m3ga> does cabal not compile with 6.10.1?
19:10:36 <CakeProphet> > let lol x | isTypeOf "" = "lol" | isTypeOf 0 = 1  where isTypeOf = (==(typeOfx)) in lol "lol"
19:10:37 <lambdabot>   Not in scope: `typeOfx'
19:10:44 <CakeProphet> > let lol x | isTypeOf "" = "lol" | isTypeOf 0 = 1  where isTypeOf = (==(typeOf x)) in lol "lol"
19:10:46 <lambdabot>   Couldn't match expected type `TypeRep'
19:10:46 <pumpkin> m3ga: cabal comes with 6.10.1
19:11:25 <CakeProphet> > let lol x | isTypeOf "" = "lol" | isTypeOf 0 = 1  where isTypeOf = ((typeOf x)==).typeOf in lol "lol"
19:11:26 <lambdabot>       No instance for (Num [Char])
19:11:26 <lambdabot>        arising from the literal `0' at <in...
19:11:52 <CakeProphet> can't do that, I take it.
19:11:57 <m3ga> pumpkin: didn't get installed, possibly because the docs failed to build
19:12:05 <CakeProphet> since the return type depends on the value.
19:12:48 <Olathe> > ((typeOf 0)==).typeOf $ "lol"
19:12:49 <lambdabot>   False
19:13:46 <Olathe> CakeProphet: Well, what's the result.
19:14:03 <CakeProphet> of...?
19:14:10 <Olathe> CakeProphet: The lol function.
19:14:14 <CakeProphet> (I'm not sure what you're asking)
19:14:20 <Olathe> CakeProphet: It has two different types.
19:14:23 <CakeProphet> right.
19:14:42 <CakeProphet> > let lol x | isTypeOf "" = Right "lol" | isTypeOf 0 = Left 1  where isTypeOf = ((typeOf x)==).typeOf in lol "lol"
19:14:43 <lambdabot>       No instance for (Num [Char])
19:14:43 <lambdabot>        arising from the literal `0' at <in...
19:15:14 <Olathe> @type Left
19:15:15 <lambdabot> forall a b. a -> Either a b
19:15:24 <Olathe> > Left 1
19:15:25 <lambdabot>   Left 1
19:17:33 <Olathe> Ahh.
19:18:03 <Olathe> isTypeOf is one function there, so it has to have a consistent type.
19:18:16 <Olathe> Let's see.
19:18:25 <Olathe> > show.typeOf $ ""
19:18:26 <lambdabot>   "[Char]"
19:18:27 <CakeProphet> a->Bool?
19:18:46 <Olathe> CakeProphet: Right, but it decides what a is when you use lol.
19:19:03 <Olathe> Since isTypeOf is the same variable in both.
19:19:09 <CakeProphet> oh./
19:19:13 <Olathe> Both case branches, I mean.
19:19:47 <Olathe> I'd recommend isTypeOf = ((show (typeOf x))==).show.typeOf
19:20:00 <CakeProphet> so basically.
19:20:26 <CakeProphet> messing around with dynamic typing in Haskell is a doomed path.
19:20:32 <Olathe> Oh, no.
19:20:45 <Olathe> If you want to take x and turn it Dynamic, I think you could get something working.
19:20:51 <Olathe> And return a Dynamic as well.
19:21:08 <Olathe> I think, if you use show.typeOf, you just have to return a Dynamic.
19:21:53 <CakeProphet> how does Dynamic work.
19:22:00 <Olathe> > toDyn 1
19:22:01 <lambdabot>   <<Integer>>
19:22:04 <Olathe> @type toDyn 1
19:22:05 <lambdabot> Dynamic
19:22:22 <Olathe> Let's see.
19:22:29 <Olathe> @hoogle Dynamic
19:22:30 <lambdabot> module Data.Dynamic
19:22:30 <lambdabot> Data.Dynamic data Dynamic
19:22:30 <lambdabot> Data.Dynamic fromDynamic :: Typeable a => Dynamic -> Maybe a
19:23:55 <Olathe> > dynApp (toDyn (+1)) (toDyn 1)
19:23:57 <lambdabot>   <<Integer>>
19:24:05 <Olathe> > fromDyn (dynApp (toDyn (+1)) (toDyn 1)) :: Maybe Integer
19:24:06 <lambdabot>   Couldn't match expected type `Maybe Integer'
19:24:38 <Olathe> > fromDynamic (dynApp (toDyn (+1)) (toDyn 1)) :: Maybe Integer
19:24:39 <lambdabot>   Just 2
19:24:48 <Olathe> > fromDynamic (dynApp (toDyn (+1)) (toDyn "zomg")) :: Maybe Integer
19:24:49 <lambdabot>   * Exception: Type error in dynamic application.
19:24:49 <lambdabot>  Can't apply function <<Int...
19:24:54 <CakeProphet> why do you apply toDyn to (+1)?
19:24:58 <Olathe> Yeah, don't return Nothing or anything like that.
19:25:03 <Olathe> @type fromDynamic
19:25:04 <lambdabot> forall a. (Typeable a) => Dynamic -> Maybe a
19:25:15 <Olathe> The function has to be Dynamic.
19:25:24 <Nafai> woo
19:25:28 <CakeProphet> > toDyn (+1)
19:25:29 <lambdabot>   <<Integer -> Integer>>
19:25:29 * Nafai joins the Haskell Platform list
19:25:30 <pumpkin> is Data.Dynamic pure haskell 98?
19:25:32 <Olathe> Why in the world it didn't return Nothing is beyond me.
19:25:35 <pumpkin> it seems sketchy
19:25:56 <CakeProphet> Olathe:  ...why does it even bother with a Maybe if it doesn't return Nothing.
19:25:57 <Olathe> Well, if it's going to give an error instead of returning Nothing, as the docs say it should, I'd say it's sketchy.
19:26:03 <CakeProphet> ...
19:26:04 <Olathe> CakeProphet: No idea.
19:26:10 <Olathe> > fromDynamic (dynApp (toDyn (+1)) (toDyn "zomg")) :: Maybe Integer
19:26:11 <lambdabot>   * Exception: Type error in dynamic application.
19:26:11 <lambdabot>  Can't apply function <<Int...
19:26:19 <Olathe> > fromDynamic (dynApp (toDyn (+1) :: (Integer -> Integer)) (toDyn "zomg")) :: Maybe Integer
19:26:20 <lambdabot>   Couldn't match expected type `Integer -> Integer'
19:26:27 <CakeProphet> so Dynamic is mostly magic?
19:26:27 <Olathe> > fromDynamic (dynApp (toDyn ((+1) :: Integer -> Integer)) (toDyn "zomg")) :: Maybe Integer
19:26:29 <lambdabot>   * Exception: Type error in dynamic application.
19:26:29 <lambdabot>  Can't apply function <<Int...
19:26:37 <Olathe> Yeah. Broken magic, apparently.
19:26:55 <CakeProphet> alright, was just wondering if there was some conrete Haskell semantics behind it
19:26:56 <Olathe> Let's try fromDyn
19:26:58 <rwbarton> , [$ty| dynApp |]
19:27:03 <lunabot>  Dynamic -> Dynamic -> Dynamic
19:27:21 <Olathe> > fromDyn (dynApp (toDyn (+1)) (toDyn "zomg")) 26342 :: Maybe Integer
19:27:23 <lambdabot>       No instance for (Num (Maybe Integer))
19:27:23 <lambdabot>        arising from the literal `...
19:27:29 <Olathe> > fromDyn (dynApp (toDyn (+1)) (toDyn "zomg")) (Just 26342) :: Maybe Integer
19:27:30 <lambdabot>   * Exception: Type error in dynamic application.
19:27:31 <lambdabot>  Can't apply function <<Int...
19:27:37 * Olathe sighs.
19:28:04 <rwbarton> I don't know why dynApp exists
19:28:05 <CakeProphet> well, I can't really say I expected dynamic typing magic in Haskell to not be broken.
19:28:15 <Olathe> rwbarton: To give something in place of Nothing.
19:28:25 <Olathe> Oh, never mind.
19:28:30 <rwbarton> Olathe: Where by "something" we mean "an exception"
19:28:35 <Olathe> Hahaha
19:28:40 <rwbarton> CakeProphet: What makes you think it is broken?
19:29:07 <Olathe> Ahh !
19:29:10 <Olathe> dynApply
19:29:12 <CakeProphet> it wraps the value in a Maybe but doesn't ever use Nothing?
19:29:17 <Olathe> > dynApp (toDyn (+1)) (toDyn "zomg")
19:29:18 <lambdabot>   * Exception: Type error in dynamic application.
19:29:19 <lambdabot>  Can't apply function <<Int...
19:29:20 <rwbarton> It doesn't though.
19:29:22 <Olathe> > dynApply (toDyn (+1)) (toDyn "zomg")
19:29:23 <lambdabot>   Nothing
19:29:29 <Olathe> Well, that helps a bit.
19:29:35 <CakeProphet> oh ho!
19:29:46 <Olathe> > dynApply (toDyn (+1)) (toDyn 1)
19:29:48 <lambdabot>   Just <<Integer>>
19:29:51 <CakeProphet> what happens if you take out dynApply?
19:29:59 <Olathe> > dynApply (toDyn (+1)) (toDyn 1) >>= fromDyn
19:30:00 <lambdabot>   Couldn't match expected type `Maybe b'
19:30:09 <Olathe> > dynApply (toDyn (+1)) (toDyn 1) >>= fromDynamic
19:30:10 <lambdabot>   Nothing
19:30:16 <Olathe> > dynApply (toDyn (+1)) (toDyn 1)
19:30:17 <lambdabot>   Just <<Integer>>
19:30:24 <Olathe> > dynApply (toDyn (+1)) (toDyn 1) >>= fromDynamic
19:30:25 <lambdabot>   Nothing
19:30:28 <Olathe> Nothing ?
19:30:32 <Olathe> > dynApply (toDyn (+1)) (toDyn 1) >>= fromDynamic :: Maybe Integer
19:30:33 <lambdabot>   Just 2
19:30:40 <Olathe> @type dynApply (toDyn (+1)) (toDyn 1) >>= fromDynamic
19:30:41 <lambdabot> forall b. (Typeable b) => Maybe b
19:30:55 <Olathe> > dynApply (toDyn (+1)) (toDyn "zomg") >>= fromDynamic :: Maybe Integer
19:30:57 <lambdabot>   Nothing
19:31:00 <kerlo> Gotta love those default instances.
19:31:06 <Olathe> There we go :)
19:31:12 <Olathe> It's not broken after all.
19:31:21 <CakeProphet> hmmm, sweet.
19:31:30 <CakeProphet> if I ever need dynamic typing in Haskell for some reason, I now know what to use.
19:32:45 <CakeProphet> > let id :: Dynamic -> Dynamic; id x = x in id
19:32:46 <lambdabot>       Overlapping instances for Show (Dynamic -> Dynamic)
19:32:46 <lambdabot>        arising from...
19:32:54 <CakeProphet> hmmm
19:33:21 <rwbarton> lambdabot can't show functions
19:33:26 <CakeProphet> > let id :: Dynamic -> Dynamic; id x = x in id  (toDyn 1)
19:33:27 <lambdabot>   <<Integer>>
19:33:27 <rwbarton> unusually, this is because it has *two* instances
19:33:27 <CakeProphet> right
19:33:46 <CakeProphet> was just seeing if it would return like (toDyn (+1)) did.
19:34:39 <CakeProphet> but I guess there's a difference in being a dynamically typed function and a Dynamic -> Dynamic function.
19:34:46 <CakeProphet> or something.
19:35:29 <Olathe> I wonder why it doesn't show the value.
19:35:34 <Olathe> Like <<Integer:1>>
19:36:02 <rwbarton> > let id :: Dynamic -> Dynamic; id x = x in toDyn id
19:36:04 <lambdabot>   <<Dynamic -> Dynamic>>
19:36:19 <rwbarton> > toDyn show
19:36:20 <lambdabot>   <<() -> [Char]>>
19:36:23 <Olathe> @type id :: Dynamic -> Dynamic
19:36:24 <lambdabot> Dynamic -> Dynamic
19:36:25 <kerlo> @type k
19:36:26 <lambdabot> Expr
19:36:29 <kerlo> Lovely.
19:36:35 <Olathe> @type toDyn (+1)
19:36:36 <lambdabot> Dynamic
19:36:39 <CakeProphet> oh ho
19:36:44 <CakeProphet> > toDyn x
19:36:45 <lambdabot>   <<SimpleReflect.Expr>>
19:36:51 <CakeProphet> aw.
19:36:56 <rwbarton> Olathe: It can't because the type might not be an instance of Show
19:36:57 <Olathe> Hmm...
19:37:03 <Olathe> rwbarton: Ahh.
19:37:09 <kerlo> So what is Expr?
19:37:15 <Olathe> Can't it determine that dynamically ? ;)
19:37:18 <CakeProphet> awesome.
19:37:25 <CakeProphet> kerlo:  that is what Expr is.
19:37:30 <kerlo> > a * (b + c)
19:37:32 <lambdabot>   a * (b + c)
19:37:40 <CakeProphet> > map (+x) [1..100]
19:37:41 <kerlo> I understand that it does *that*...
19:37:41 <lambdabot>   [1 + x,2 + x,3 + x,4 + x,5 + x,6 + x,7 + x,8 + x,9 + x,10 + x,11 + x,12 + x...
19:37:41 <pumpkin> > 5^7 :: Expr
19:37:42 <lambdabot>   5 * 5 * (5 * 5) * (5 * 5 * 5)
19:37:52 <rwbarton> @hackage numbers
19:37:53 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
19:37:54 <rwbarton> it's from there
19:37:57 <CakeProphet> oh... you mean
19:38:00 <CakeProphet> how does it work.
19:38:03 <pumpkin> kerlo: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/simple-reflect
19:38:13 <Olathe> > let showable x = dynApply (toDyn show) (toDyn x) == Nothing in showable 1
19:38:14 <lambdabot>       No instance for (Eq Dynamic)
19:38:14 <lambdabot>        arising from a use of `==' at <inte...
19:38:17 <rwbarton> Yeah I probably lied there.
19:38:27 <Olathe> > let showable x = dynApply (toDyn show) (toDyn x) in showable 1
19:38:28 <lambdabot>   Nothing
19:38:32 <kerlo> 5 * 5 * (5 * 5) * (5 * 5 * 5)? Why not 5 * (5 * 5 * 5) * (5 * 5 * 5), I wonder. :-P
19:38:35 <Olathe> > let showable x = Nothing == dynApply (toDyn show) (toDyn x) in showable 1
19:38:36 <rwbarton> Olathe: Nice try
19:38:37 <lambdabot>       No instance for (Eq Dynamic)
19:38:37 <lambdabot>        arising from a use of `==' at <inte...
19:38:44 <Olathe> Bah.
19:38:46 <kerlo> > 5 * 5 :: Expr == 25
19:38:47 <lambdabot>   Only unit numeric type pattern is valid
19:38:58 <Olathe> > dynApply (toDyn show) (toDyn 1)
19:38:59 <lambdabot>   Nothing
19:39:00 <kerlo> > (5 * 5 :: Expr) == 25
19:39:01 <lambdabot>   True
19:39:06 * kerlo blinks
19:39:12 <Olathe> That's weird.
19:39:14 <kerlo> Well, that was exciting.
19:39:14 <pumpkin> kerlo: there's an explanation http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
19:39:28 <rwbarton> > 5 * 5 :: Expr
19:39:29 <Olathe> > dynApply (toDyn (+1)) (toDyn 1)
19:39:30 <lambdabot>   5 * 5
19:39:31 <lambdabot>   Just <<Integer>>
19:39:37 <Olathe> > dynApply (toDyn show) (toDyn 1)
19:39:39 <lambdabot>   Nothing
19:39:46 <Olathe> O...K
19:39:55 <rwbarton> Olathe: The value passed to toDyn can't be polymorphic, so it's getting defaulted
19:40:11 <Olathe> > (toDyn show)
19:40:12 <lambdabot>   <<() -> [Char]>>
19:40:16 <Olathe> Hahaha
19:40:24 <Olathe> I see.
19:40:35 <Olathe> It's dynamic...but it's not THAT dynamic.
19:40:53 <chessguy> @seen wchogg
19:40:53 <lambdabot> Last time I saw wchogg was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #ghc, #
19:40:53 <lambdabot> haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #
19:40:53 <lambdabot> haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosxdev, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 13d 6h 47m 36s ago, and .
19:40:57 <rwbarton> , eval "show"
19:41:02 <lunabot>  <<() -> [Char]>>
19:41:13 <sjanssen> extended defaulting ftw
19:41:20 <kerlo> > f x
19:41:21 <lambdabot>   Add a type signature
19:41:23 <repnop> haha #haskell.jp is just the bot
19:41:26 <kerlo> > f x :: Expr
19:41:28 <lambdabot>   f x
19:41:56 <Olathe> Why is there #haskell_ru and #haskell.ru ?
19:42:07 <Olathe> With, of course, only lambdabot in them.
19:42:27 <repnop> maybe for when haskell.ru overflows in the future? ;)
19:42:38 <Olathe> Haha
19:42:53 <BMeph> For Russian-speaking Heskelliers who aren't in Russia? ;)
19:43:18 <BMeph> *Haskelliers
19:45:12 <chessguy> > f x
19:45:14 <lambdabot>   Add a type signature
19:45:30 <pumpkin> > join (*) x
19:45:31 <lambdabot>   x * x
19:47:06 <pumpkin> > join ((join (*) .) . (+)) 5
19:47:08 <lambdabot>   100
19:47:15 <Olathe> > join ((join (*) .) . (+)) x
19:47:16 <lambdabot>   (x + x) * (x + x)
19:47:23 <Olathe> Hmm...
19:47:37 <Olathe> @pl \x -> (x + x) * (x + x)
19:47:37 <lambdabot> ap ((*) . join (+)) (join (+))
19:48:05 <Olathe> @pl \p -> ap ((*).p) p
19:48:05 <lambdabot> ap =<< ((*) .)
19:49:12 <Olathe> @pl (ap =<< ((*).)) (join (+))
19:49:13 <lambdabot> (ap =<< ((*) .)) (join (+))
19:49:26 <Olathe> > (ap =<< ((*).)) (join (+)) $ x
19:49:27 <lambdabot>   (x + x) * (x + x)
19:49:43 <pumpkin> mine was prettier
19:49:44 <CakeProphet> > gcd x y
19:49:47 <Olathe> Yes.
19:49:49 <pumpkin> but your is more obscure
19:49:52 <pumpkin> which is a big plus
19:49:53 <Olathe> Hahaha
19:50:00 <lambdabot>   thread killed
19:50:06 <Olathe> I'm wondering why it didn't give yours.
19:50:26 <pumpkin> Olathe: I assume it just picks one of the thousands of possible @pl possibilities :P
19:50:31 <pumpkin> and it happened to grab a rather ugly one
19:50:40 <pumpkin> although it should've been satisfied with mine
19:50:46 <Olathe> Ahh.
19:50:46 <pumpkin> and not done anything to it in the first place
19:51:19 <Olathe> > join (*).join (+) $ x
19:51:21 <lambdabot>   (x + x) * (x + x)
19:51:28 <pumpkin> aha
19:51:37 <pumpkin> that would explain it :)
19:51:51 <pumpkin> sort of
19:51:58 <dolio> > (^2) . (*2) $ x
19:51:59 <pumpkin> there should be an even prettier one in that case
19:51:59 <pumpkin> hm
19:52:00 <lambdabot>   x * 2 * (x * 2)
19:52:13 <pumpkin> dolio: I don't expect it to be able to figure that out :P
19:52:32 <Olathe> @pl \f -> f (*).f (+)
19:52:32 <lambdabot> liftM2 (.) ($ (*)) ($ (+))
19:52:35 <Olathe> Eww.
19:52:58 <gwern> hm. I need some understandable documentation for regex-posix
19:53:21 * gwern really just wants to parse stuff like "bar:1:bing BONG",
19:53:24 <pumpkin> @pl \f x y -> f x . f y
19:53:24 <lambdabot> flip =<< (((.) . (.)) .)
19:53:26 <gwern> maybe I should look into split
19:53:33 <Olathe> gwern: What do you want from that ?
19:53:38 <pumpkin> gwern: byorgey's one? it's pretty nice
19:54:42 <gwern> Olathe: the idea is to parse it into a SearchMatch { matchResourceName = "bar", matchlineNumber = 1, matchLine = "bing BONG" }
19:55:04 <gwern> pumpkin: yes, I made a split package of my own once, and byorgey's is better
19:55:54 <Olathe> Hmm...
19:56:41 <gwern> http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/ looks like it might help me
19:56:51 <CakeProphet> > x == 2
19:56:53 <lambdabot>   False
19:57:11 <CakeProphet> ...I thought == wanted a -> a -> Bool?
19:57:14 <CakeProphet> :t ==
19:57:16 <lambdabot> parse error on input `=='
19:57:24 <CakeProphet> :t (==)
19:57:26 <lambdabot> forall a. (Eq a) => a -> a -> Bool
20:00:27 <gwern> now why does '"bar:1:bing BONG" =~ ".*:.*:.*" :: (String,String,String)' yield  '("","bar:1:bing BONG","")'?
20:02:19 <Olathe> @hoogle a -> [a] -> ([a], [a])
20:02:20 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
20:02:20 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
20:02:20 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
20:03:02 <Olathe> "bar:1:bing BONG" =~ "\\A.*:.*:.*\\Z" :: (String,String,String)
20:03:06 <Olathe> > "bar:1:bing BONG" =~ "\\A.*:.*:.*\\Z" :: (String,String,String)
20:03:08 <lambdabot>   ("bar:1:bing BONG","","")
20:03:10 <CakeProphet> :t (->)
20:03:12 <lambdabot> parse error on input `->'
20:03:22 <CakeProphet> :t (-<)
20:03:24 <lambdabot> Not in scope: `-<'
20:03:34 <rwbarton> gwern: the (String, String, String) is (text before the match, text of the match, text after the match)
20:03:38 <Olathe> > "bar:1:bing BONG" =~ "\\A[^:]*:[^:]*:[^:]*\\Z" :: (String,String,String)
20:03:39 <lambdabot>   ("bar:1:bing BONG","","")
20:03:46 <Olathe> O...K.
20:03:56 <Olathe> I think [chars] doesn't work in Haskell.
20:04:02 <Olathe> It's quite nice.
20:04:08 <gwern> rwbarton: hm. I guess I misunderstood what the expected-type does then
20:04:14 <kerlo> Can Hugs run lambdabot?
20:04:20 <Olathe> > "bar:1:bing BONG" =~ "\\A.*?:.*?:.*?\\Z" :: (String,String,String)
20:04:21 <lambdabot>   ("bar:1:bing BONG","","")
20:04:29 <Olathe> > "bar:1:bing BONG" =~ "\\A.*?\\:.*?\\:.*?\\Z" :: (String,String,String)
20:04:31 <lambdabot>   ("bar:1:bing BONG","","")
20:04:34 <Olathe> Weird.
20:04:38 <Olathe> > "bar:1:bing BONG" =~ ":" :: (String,String,String)
20:04:40 <lambdabot>   ("bar",":","1:bing BONG")
20:04:53 <Olathe> Ahh.
20:05:02 <Olathe> (String, String, String) is before, during, after.
20:05:09 <CakeProphet> :t (=~)
20:05:10 <lambdabot> forall source1 source target. (Text.Regex.Base.RegexLike.RegexContext Regex source1 target, Text.Regex.Base.RegexLike.RegexMaker Regex CompOption ExecOption source) => source1 -> source -> target
20:05:15 <Olathe> > "bar:1:bing BONG" =~ "[^:]*" :: [String]
20:05:16 <lambdabot>   ["bar",""]
20:05:17 <gwern> Olathe: as rwbarton said
20:05:20 <CakeProphet> ...wow.
20:05:23 <Olathe> Ahh.
20:05:28 <CakeProphet> that's a terrible, terrible, type signature.
20:05:43 <Olathe> > "bar:1:bing BONG" =~ "[^:]*" :: [[String]]
20:05:44 <lambdabot>   [["bar"],[""]]
20:05:50 <wli> Linear-bounded automata might be an interesting alternative model for pattern matching.
20:05:52 <Olathe> > "bar:1:bing BONG" =~ "[^:]*" :: [[[String]]]
20:05:53 <lambdabot>       No instance for (Text.Regex.Base.RegexLike.RegexContext
20:05:53 <lambdabot>                ...
20:05:58 <kerlo> @type (=~)
20:06:00 <lambdabot> forall source1 source target. (Text.Regex.Base.RegexLike.RegexContext Regex source1 target, Text.Regex.Base.RegexLike.RegexMaker Regex CompOption ExecOption source) => source1 -> source -> target
20:06:00 <wli> (or so I've always thought)
20:06:08 <Olathe> Let's see.
20:06:20 <kerlo> Oh, CakeProphet just grabbed it up there.
20:06:31 <kerlo> It's even worse than lojban. :-P
20:07:02 <Olathe> @type splitBy
20:07:03 <lambdabot> Not in scope: `splitBy'
20:07:35 <CakeProphet> :t splitAt
20:07:36 <lambdabot> forall a. Int -> [a] -> ([a], [a])
20:07:46 <CakeProphet> :t split
20:07:47 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
20:07:59 <CakeProphet> :t splitWith
20:08:01 <lambdabot> Not in scope: `splitWith'
20:08:24 <CakeProphet> there's no higher-order version of splitAt?
20:08:42 <Olathe> > let splitBy x ys = f' [] x ys where f' cs _ [] = [cs]; f' cs x (y:ys) = if x == y then cs:f' [] x ys else f' (y:cs) x ys in splitBy ':' "zomg:1:kthx"
20:08:43 <lambdabot>   ["gmoz","1","xhtk"]
20:08:48 <Olathe> Hmm...almost :D
20:09:19 * gwern tries out my homegrown split solution
20:09:24 <gwern> CakeProphet: no one can agree on it
20:09:39 <gwern> byorgey's split package has like 10 or 15 splits in it
20:09:46 <gwern> the design space is surprisingly larger
20:10:12 <gwern> than one might think
20:14:24 <wli> gwern: Any online docs about that?
20:14:32 <gwern> about split?
20:14:45 <gwern> the lengthy discussions on -cafe and the bug reports are generally felt to suffice
20:14:46 <wli> gwern: The split package in particular?
20:15:16 <gwern> byorgey's blog iirc
20:15:39 <wli> gwern: URL?
20:16:23 <Olathe> @where split
20:16:23 <lambdabot> I know nothing about split.
20:16:32 <Saizan_> @hackage split
20:16:33 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split
20:17:08 <Olathe> Ahh, yes.
20:17:13 <Saizan_> http://byorgey.wordpress.com/2008/12/21/datalistsplit/
20:17:26 <Olathe> Here's the blog entry: http://byorgey.wordpress.com/2008/12/21/datalistsplit/
20:17:59 <scook0> unfortunately the docs haven't built on hackage
20:18:12 <scook0> but you can still compile them yourself locally
20:18:35 <kerlo> What'
20:18:42 <kerlo> What's the newest GHC that apt-get can get?
20:18:54 <pumpkin> kerlo: what's your distribution?
20:18:56 <gwern> 6.8.2
20:18:59 <gwern> at best
20:19:12 <pumpkin> what determines whether docs/source are available on hackage?
20:19:34 <gwern> whether mars is in the house of jupiter or opiuchus
20:19:46 <kerlo> So getting ghc-6.11.20081120 would be more difficult.
20:20:00 <pumpkin> kerlo: yeah, it's not released
20:20:06 <scook0> the docs aren't up on hackage because hackage's haddock run failed
20:20:30 <pumpkin> scook0: how about the cases in which haddock gives source links or doesn't?
20:20:57 <kerlo> I guess apt-get generally doesn't give unreleased versions of things.
20:20:58 <scook0> sorry, can't help you with that
20:21:53 <CakeProphet> :t id
20:21:54 <lambdabot> forall a. a -> a
20:21:56 <CakeProphet> :t const
20:21:57 <lambdabot> forall a b. a -> b -> a
20:22:20 <kerlo> Let's see if I can install it without root access. That does tend to not be possible these days.
20:22:59 <CakeProphet> > (typeOf $ const 0) == (TypeOf $ const "lol")
20:23:00 <lambdabot>   Not in scope: data constructor `TypeOf'
20:23:07 <CakeProphet> > (typeOf $ const 0) == (typeOf $ const "lol")
20:23:08 <lambdabot>   Add a type signature
20:23:20 <CakeProphet> wat
20:23:32 <kerlo> :t typeOf
20:23:33 <lambdabot> forall a. (Typeable a) => a -> TypeRep
20:23:35 <CakeProphet> > (typeOf $ const 0) == (typeOf $ const "lol") :: LolOkay?
20:23:36 <lambdabot>   <no location info>: parse error on input `;'
20:23:53 <kerlo> > typeOf (const 0)
20:23:55 <lambdabot>   Add a type signature
20:24:08 <kerlo> > typeOf (const 0 :: String -> Integer)
20:24:09 <lambdabot>   [Char] -> Integer
20:24:23 <CakeProphet> oh right, typeRef requires monomorphic types
20:30:30 * sbahra whoises newsham 
20:30:41 <sbahra> He's my source of UTF-8 symbols for logic. :-P
20:31:03 <cknapp> Hello, all
20:34:39 <davidL> > permutations [1..4]
20:34:40 <lambdabot>   Not in scope: `permutations'
20:34:47 <pumpkin> , permutations [1..4]
20:34:48 <lunabot>  [[1,2,3,4],[2,1,3,4],[3,2,1,4],[2,3,1,4],[3,1,2,4],[1,3,2,4],[4,3,2,1],[3...
20:34:59 <davidL> @version
20:35:00 <lambdabot> lambdabot 4.2.2
20:35:00 <lambdabot> darcs get http://code.haskell.org/lambdabot
20:35:04 <blackdog_> ... what does ',' do?
20:35:11 <pumpkin> blackdog_: calls lunabot
20:35:16 <jeffz`> why can't we inspect the type signature of functions in a where clause using ghci?
20:35:19 <davidL> ,version
20:35:21 <lunabot>  luna: Not in scope: `version'
20:35:22 <blackdog_> oh, duh :)
20:35:24 <blackdog_> thanks
20:35:40 <davidL> how do you do normal commands with luna bot?
20:35:47 <pumpkin> if I were to describe the advantages of UArrs to someone, it would be that if you call them from "generating" code, it doesn't even bother allocating the underlying array, and if it does need to allocate the underlying array it's unboxed/packed and memory efficient?
20:36:43 <rwbarton> jeffz`: how would that be useful?
20:37:17 <pumpkin> @let slowMap f = zipWith (\x y -> f $ y !! x) [0..]
20:37:18 <lambdabot>  Defined.
20:37:28 <pumpkin> > slowMap (^2) [1..5]
20:37:29 <lambdabot>       No instance for (Enum [a])
20:37:29 <lambdabot>        arising from the arithmetic sequence ...
20:37:31 <pumpkin> :(
20:37:40 <pumpkin> oh duh
20:37:48 <pumpkin> boo
20:37:51 <pumpkin> @undef
20:37:59 <jeffz`> rwbarton: sometimes I don't have a type signature for a function defined in a where clause and I'd like to find it quickly using ghci, then write the type signature
20:38:14 <rwbarton> jeffz`: oh, I see what you mean
20:38:18 <jeffz`> rwbarton: no more or less useful than asking for the type signature of anything else I presume
20:38:25 <pumpkin> I've needed that too sometimes
20:38:39 <rwbarton> jeffz`: I thought you meant your code would somehow inspect a type
20:38:44 <jeffz`> no :)
20:45:47 <blackh> I've just finished a day of chasing a C++ memory problem.  I need a dose of Haskell to cheer me up!
20:46:57 <cknapp> blackh: welcome home! :)
20:47:15 <blackh> I'll put my feet up in front of the fire!
20:47:52 <cknapp> I think I'm frying my brain too much for one sitting... I just got XMonad/Gnome up and running with a new theme, I'm learning to use vimperator and I'm reading RWH...
20:50:10 <blackh> cknapp: That vimperator looks really retro.
20:50:22 <cknapp> Yeah...
20:50:54 <cknapp> It really feels a lot like the little bit of lynx (sp?) I've used... But I like vim a lot, and it is basically the same keys, layout, etc
20:51:21 <cknapp> I figured, what the hell? If I'm going to go mouseless, I might as well go as mouseless as I can.
20:52:48 <blackh> cknapp: That's good thinking. I'm a bit extreme. I like using Eclipse (I hope the Haskell project gets finished!) and I also have a WYSE terminal.
20:53:13 <blackh> cknapp: Obviously I don't run Eclipse on the WYSE terminal.
20:53:34 <cknapp> Wyse?
20:54:14 <blackh> cknapp: It looks like this: http://www.terminalrepair.net/eshop/products/wyse55a.jpg
20:54:17 <blackh> Now that's retro!
20:55:10 <cknapp> I got into the habit of eclipse when I had a professor who had a remote server with all of our assignments. I could scp it and edit it, or I could just get used to vim and ssh
20:55:14 <blackh> cknapp: When I was a little nipper, I *actually* used a Teletype: http://www.columbia.edu/acis/history/teletype.jpg
20:55:23 <cknapp> Wow...
20:55:27 <cknapp> I feel so young...
20:56:07 <ozy`> here's a haskell proposal for you: clone GLTerminal
20:56:18 <cknapp> The really nice thing about vimperator is it doesn't override any of the firefox default key bindings.
20:56:19 <blackh> cknapp: They were cool. They hum loudly and when you push a key, they go KER-CHUNK!  And you can flick a switch and everything you print out gets punched out as a tape!
20:56:28 * ozy` would have done it already but doesn't know OpenGL :\
20:56:30 <cknapp> Nice!
20:57:13 <ozy`> http://ldopa.net/2006/01/14/glterminal/
20:57:17 <cknapp> Yeah, I've been thinking about learning OpenGL... I better actually try to know what I'm doing with Haskell first, though; seeing as I don't think I'll willingly use any other language right now...
20:58:04 * blackh MUST try GLTerminal!
20:58:32 <cknapp> Try GLTerminal? Try using it or haskellizing it?
20:58:48 <cknapp> Oh.
20:58:50 <cknapp> Right.
20:58:54 <cknapp> I forgot what it was.
21:00:51 <blackh> Hmm... No Linux version of GLTerminal readily available. Right - we must Haskell it.
21:06:27 <lamdaThis> hey guys, searched all over the web, but did not find an answer
21:06:38 <lamdaThis> how would you define fst for a 3-tuple
21:07:09 <kerlo> Ello.
21:07:19 <int80_h> hi
21:07:19 <kerlo> :t fst
21:07:20 <lambdabot> forall a b. (a, b) -> a
21:07:29 <blackh> Err... fst3 (a,_,_) = a  ?   Ello kerlo!
21:07:55 <cknapp> Ello
21:08:19 <int80_h> So I found out a buddy of mine is reading RWH.
21:08:24 <int80_h> it's spreading!
21:08:44 <lamdaThis> Im reading it too
21:08:54 <lamdaThis> (big biginner)
21:09:26 <int80_h> lambdaThis : I'm a newbie as well.
21:09:36 <cknapp> I'm reading it... So far I haven't gotten to anything I haven't learned... but it's solidifying things...
21:09:43 <cknapp> I'm a newbie as well... mostly...
21:10:15 <int80_h> I'm doing the first tree walk exercise (I imagine it won't be the only one), in chapter 3.
21:10:46 <int80_h> the one where you have to find the height of a given tree
21:11:26 <blackh> I've been on a 4-month all-nighter Haskell crash course.  I found RWH plugged a few very significant gaps in my knowledge.
21:11:36 <cknapp> Ah. It should be 2 or 3 lines.
21:12:16 <lamdaThis> ok so Im trying to use mmapFile
21:12:16 <blackh> That is, I've only been using Haskell for 4 months, but I've been very busy.
21:12:16 <lamdaThis> third (y, z, x) = return x  main =  do         file <- mmapFilePtr "an.txt" WriteCopy Nothing         print $ third (1, "two", 22)
21:12:19 <cknapp> blackh: that's where I'm starting to get to... unfortunately, I spent 3 weeks in the mountains, and forgot a lot of the specifics... so I had to stare at haskell for an hour or two to get back to it
21:12:23 <lamdaThis> compiler complains about ny third func
21:12:54 <cknapp> lamda: y ou can drop teh "return"
21:12:54 <int80_h> lamdaThis: please use hpaste to post code
21:13:01 <cknapp> it's done automatically
21:13:06 <cknapp> @where hpaste
21:13:06 <lambdabot> http://hpaste.org/
21:13:16 <int80_h> there you go
21:13:42 <lamdaThis> http://www.mibbit.com/pb/gUp14N
21:14:16 <dmwit> lamdaThis: "return" is a function, not a keyword; it does something very different in Haskell than in other languages.
21:14:45 <dmwit> lamdaThis: "return" in Haskell is essentially a special kind of cast.
21:14:55 <lamdaThis> I see
21:15:15 <dmwit> In particular: it is not required to return something from a function, and it does not terminate evaluation of a function.
21:15:23 <lamdaThis> so once i mmap a file how do I read write something at offset x?
21:15:25 <ddarius> "special kind of cast" is a really horrible description
21:15:35 <int80_h> I was thinking that too
21:15:36 <dmwit> errr... that wording was ambiguous
21:15:56 <int80_h> just because I just got done reading that haskell doesn't do type casting
21:16:08 <kerlo> third (y, z, x) = return x; main = do {file <- mmapFilePtr "an.txt" WriteCopy Nothing; print $ third (1, "two", 22)}
21:16:11 <dmwit> All casting is explicit. =)
21:16:14 <kerlo> Er
21:16:15 <cknapp> lamdaThis: your third should be third (x,y,z) = z
21:16:21 <ddarius> dmwit: There is no casting.
21:16:24 <cknapp> int80_h: It doesn't do *implicit*
21:16:26 <dmwit> third (y, z, x) = x
21:16:28 <cknapp> type casting*
21:16:29 <kerlo> What cknapp said.
21:16:45 <cknapp> You can cast; for example fromIntegral
21:16:48 <dmwit> ddarius: conversion, then
21:17:11 <dmwit> cknapp: I think ddarius' beef is that it isn't casting in the sense other languages use casting.
21:17:11 <ddarius> cknapp: Nothing is being "cast" there unless you're going to call -every- function a cast.
21:17:22 <dmwit> cknapp: i.e. it doesn't just treat the same bits as a new type of value
21:17:35 <cknapp> Fair enough...
21:18:08 <cknapp> I'll yield to the more experienced on this point.
21:18:16 <chipdude> shirley, that's the same as   third (_, _, x) = x
21:18:26 <dmwit> Still, I would claim that some functions are more "cast-like" than others.
21:19:12 <lamdaThis> ok so my problem is this: mmapFilePtr returns a truple (Ptr a, IO (), Int)
21:19:13 <ddarius> dmwit: "conversion" is a better word, but I'd have some criteria to call something a conversion.  Namely it should be the embedding in an embed-project pair.
21:19:15 <blackh> lambdaThis: This is the forum where you ask a question, and you get 20 different answers. I'm going to look at this mmap thing.
21:19:23 <lamdaThis> how do I extract the Int?
21:19:34 <lamdaThis> and how do I access the Ptr a
21:19:45 <lamdaThis> (dont know too much about Ptrs)
21:20:04 <dmwit> lamdaThis: That type doesn't look sensical, are you sure you got it right?
21:20:11 <dmwit> ?hoogle mmapFilePtr
21:20:12 <lambdabot> No results found
21:20:26 <lamdaThis> http://hackage.haskell.org/packages/archive/mmap/0.2/doc/html/System-IO-MMap.html
21:20:28 <Stinger> > (\(x,y,z) -> z) (1,2,3)
21:20:30 <lambdabot>   3
21:20:50 <dmwit> Yikes, that *is* the type.
21:21:05 <dmwit> Ah, the action is a finalizer.
21:21:08 <dmwit> yuck
21:21:24 <lamdaThis> yea Im trying to figure out how the heck to access the mmap'ed file
21:21:26 <dmwit> lamdaThis: Did you know you can use patterns on the LHS of (<-) binders?
21:21:58 <sjanssen> lamdaThis: you should probably use mmapFileForeignPtr instead
21:21:58 <dmwit> do { (ptr, finalizer, size) <- mmapFilePtr ...; ... }
21:21:58 <lamdaThis> er  .. no
21:22:06 <sjanssen> lamdaThis: or, more likely, mmapFileByteString
21:22:19 <sjanssen> lamdaThis: what exactly are you trying to do?
21:22:23 <blackh> lambaThis: I found the docs now. ForeignPtr would be safer than Ptr.
21:22:39 <dmwit> But yeah, one of the wrapper functions would probably be easier to use.
21:24:10 <blackh> lambaThis: OK, now I think I understand it.  This is pretty low-level.  ForeignPtr would be best, because it'll deallocate automatically. ByteString will break referential transparency if any other process writes to the mmap, otherwise it would be the best.
21:25:10 <blackh> lambdaThis: That is, if you know no other process will write to your mmap, ByteString would be good, but it's also read-only!
21:26:59 <blackh> lambdaThis: The best way to access a ForeignPtr is to do this:  withForeignPtr fp $ \p -> do   ...
21:27:03 <lamdaThis> yea, i want to write, so bytestring is out
21:27:12 <blackh> lambdaThis: It just turns it into a Ptr, but it does it safely.
21:27:21 <kmeyer> juhp: apparently for binlib stuff cabal2spec's -prof subpackage has a dependency on ghc-%pkgname
21:27:29 <kmeyer> juhp: but the main package doesn't provide this
21:28:33 <blackh> lambdaThis: Let's say you're using Ptr... to extract it, do this:   let (p, _, _) = file
21:28:53 <cknapp> Well, good night, everyone.
21:30:07 <int80_h> goode night
21:30:19 <kmeyer> er, wrong channel, oops
21:30:32 <lamdaThis> crap! wife calling me to bed
21:30:40 <lamdaThis> ok, next time thx all!!
21:30:42 <lamdaThis> bye
21:30:46 <blackh> lambdaThis: See ya!
21:30:59 <blackh> lambdaThis: buzz me when you come back because I have found out how to do it!
21:43:47 <int80_h> I'm coming to the conclusion that when it comes to haskell, I should go with linux over netbsd
21:44:41 <int80_h> I can't even install the latest stable without porting it, but on lemmih's linux server everything just works.
21:45:25 <dmwit> Yes, Linux is probably best.
21:45:37 <dmwit> I've heard of success on some BSDs -- FreeBSD, I think?
21:45:48 <dmwit> I don't know how closely related FreeBSD and NetBSD are, of course.
21:46:46 <int80_h> dmwit: well, once I've stableized my own project, I might take a stab at porting over the latest stable. netbsd has 8.x in pkgsrc
21:46:46 <blackh> int80_h: It is possible to build ghc-6.10.1. I did it on an ancient RedHat and it wasn't all that painful. But Linux is much easier - I am just using the pre-built binary off haskell.org on my amd64 Ubuntu.
21:47:58 <juhp> kmeyer: right the lib subpackage should though
21:48:14 <juhp> or did I break something?
21:48:14 <kmeyer> juhp: what lib subpackage?
21:48:46 <kmeyer> hrm
21:48:47 <juhp> binlib packages should have a main package and a lib subpackage
21:49:01 <juhp> + -prof
21:49:07 <kmeyer> I see %package -n ghc-%{name}
21:49:16 <juhp> eg, haddock, ghc-haddock, ghc-haddock-prof
21:49:19 <kmeyer> but I guess it never got generated
21:49:29 <juhp> hmm
21:49:38 <juhp> no files?
21:49:44 <kmeyer> yeah, no %files section.
21:49:53 <kmeyer> so, incorrectly detected as binlib I guess?
21:50:05 <sbahra> Do any of you recall where on haskell.org I could find that hammer lambda graphic?
21:50:35 <juhp> kmeyer: cpphs?
21:50:59 <juhp> let me try
21:50:59 <sbahra> int80_h, FreeBSD works fine.
21:51:19 <kmeyer> juhp: see bug 479793
21:51:19 <sbahra> int80_h, in fact, the FreeBSD haskell was recently revived. Find out more at #haskell-FreeBSD if you're interested.
21:51:32 <juhp> kmeyer: ok
21:51:35 <mmorrow> sbahra: i think you mean the monad reader logo http://www.haskell.org/haskellwiki/The_Monad.Reader
21:52:11 <sbahra> mmorrow, yes, exactly. :)
21:52:12 <sbahra> thanks
21:52:16 <mmorrow> np
21:52:17 <kmeyer> juhp: um, the summary/description for ghc-%{name} is fixed in my current version, thought not on that spec
21:53:34 <dancor> if p is a parsec parser ending with state st, how do i make p' ending with state (st, [])
21:54:35 <dmwit> Sounds like a case for runParser!
21:54:35 <mmorrow> p' p = do x <- p; st <- getState; putState (st, []); return x
21:54:52 <dmwit> mmorrow: I doubt that type-checks.
21:55:01 <juhp> kmeyer: ah hm dunno you might right about not binlib not sure
21:55:01 <juhp> will check
21:55:04 <mmorrow> i don't use parsec much, no i'm guessing
21:55:09 <mmorrow> on the types
21:55:13 <mmorrow> ohhhh
21:55:16 <mmorrow> yes
21:55:19 <mmorrow> you're right
21:55:20 <dmwit> mmorrow: It certainly wouldn't check for the State monad.
21:55:23 <mmorrow> yeah
21:55:36 <dmwit> :t runParser
21:55:37 <lambdabot> Not in scope: `runParser'
21:55:39 * pumpkin wants to play with arrows
21:56:10 * sbahra too
21:56:12 <dmwit> runParser isn't it
21:56:20 <juhp> kmeyer: err, happy is already in fedora
21:56:27 <kmeyer> is it?
21:56:31 <kmeyer> yum didn't find it
21:56:46 <kmeyer> you want to close it then?
21:56:49 <dmwit> Oh, yeah, runParser is what you need, but it's going to be annoying.
21:57:06 <dancor> dmwit: it's going to be hard to rethrow parse errors right?
21:57:20 <dmwit> dancor: exactly
21:57:43 <dancor> hm
21:59:12 <dmwit> dancor: You might be able to do something using getParserState and setParserState...
22:05:55 <int80_h> sbhara: hey I will . :) It's easier for me to run freebsd in an hvm than it would be for some linux fork
22:08:43 <hellige> anybody know of a linear system solver in pure haskell?
22:08:59 <hellige> i.e., no lapack or gsl or any such nonsense...
22:09:16 <dmwit> no
22:09:19 <pumpkin> nonsense? :P
22:09:37 <dmwit> Any particular reason for the prejudice against other languages? =)
22:09:39 <pumpkin> hellige: I think wli might be working on something that'll help you, but it's not done yet as far as I know
22:09:39 <wli> hellige: I hammer out Gauss-Jordan elimination as-needed.
22:10:19 <hellige> haha, i'm in cygwin and don't know windows well... dont' have time to figure out how to do c bindings in cygwin...
22:10:31 <hellige> and this is quick and dirty thing, so i was hoping for a drop-in...
22:10:39 <hellige> i can maybe wait and do it tomorrow on my linux machine.
22:11:21 <wli> dmwit: Polymorphism, esp. when something tricky like Q(2^(1/2), t) is involved, or Q(2^(1/2))[x]
22:11:44 <hellige> thanks anyway!
22:12:15 <dmwit> hellige: ...but if somebody else has already done the bindings, is that okay?
22:12:28 <wli> dmwit: cf. my point
22:13:02 <dmwit> wli: I was asking hellige, thank you very much.  He hasn't yet complained about polymorphism, only about the amount of work needed.
22:13:35 <hellige> dmwit: the trouble for me is building it.
22:13:45 <int80_h> the url to the ghc building guide is broken
22:13:58 <hellige> i tried building hmatrix against my cygwin gsl/lapack, but no luck.
22:14:08 <int80_h> http://www.haskell.org/ghc/docs/latest/html/building/index.html
22:14:09 <dmwit> hellige: *nod*
22:14:10 <hellige> i guess ghc on windows uses mingw, and doesn't deal with cygwin libs?
22:14:27 <hellige> and i am *so* not a windows guy, this pretty much exhausts my ability to do anything.
22:14:30 <hellige> haha
22:14:49 <hellige> so the problem isn't the bindings, it's windows.
22:14:52 <wli> I'm feeling that pain as well.
22:15:18 <wli> I'm not trying quite that hard with hmatrix/gsl/LAPACK, I only did mingw.
22:15:43 <pumpkin> there's a LAPACK binding? I thought we only had BLAS
22:17:13 <wli> I'm not entirely sure what was in the stuff I installed or what all I ended up installing on account of not really knowing what I was doing and not remembering what the Hell I did.
22:17:16 <hellige> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmatrix-0.5.0.1
22:17:26 <hellige> says it has lapack bindings, but i haven't actually used it...
22:17:43 <hellige> wli: yeah, that's exactly what i don't have time for, tonight... ;)
22:17:57 <hellige> wli: i'm sure on my linux machine i cant just apt-get a afew libs and cabal the rest.
22:19:23 <kmeyer> anyone know what "Warning: Eta reduce" from HLint means?
22:19:52 <pumpkin> isn't that when it transforms f x = g x into f = g?
22:20:00 <pumpkin> or maybe I'm confused
22:20:05 <pumpkin> (probably the latter :))
22:20:11 <wli> They're probably suggesting that you should carry out an eta reduction by hand.
22:20:15 <sjanssen> pumpkin: yes, you're right
22:20:20 <dolio> Eta is (\x -> f x) = f.
22:20:31 <sjanssen> kmeyer: the "warning" bit is probably because eta reduction isn't strictly sound in Haskell
22:20:41 <wli> Not exactly. Eta reduction carries \x -> f x to f
22:21:17 <sjanssen> > (\x -> undefined x) `seq` ()
22:21:18 <lambdabot>   ()
22:21:21 <sjanssen> > undefined `seq` ()
22:21:23 <lambdabot>   * Exception: Prelude.undefined
22:21:44 <wli> HLint probably sees that you have \x -> (function expr) x written and is suggesting getting rid of the lambda.
22:21:48 <pumpkin> ah
22:21:53 <kmeyer> o
22:21:57 <kmeyer> ok
22:22:07 <wli> ttfn
22:22:21 <sjanssen> ttfn?
22:22:22 <int80_h> wow TMPHaXml has been linking for quite some time
22:22:31 <int80_h> ta ta for now - ttfn
22:22:47 <blackh> buy
22:24:21 <juhp> sell
22:24:27 <juhp> {sorry}
22:24:41 <dmwit> {It's okay.}
22:26:46 <mjrosenb> sjanssen: it is if you limit yourself to values whose type is naturally a function
22:28:24 <sjanssen> mjrosenb: "naturally a function"?
22:29:00 <dolio> Eta reduction is broken by seq.
22:29:09 <dolio> As sjannsen demonstrated.
22:29:22 * kmeyer doesn't know what seq is
22:29:30 <pumpkin> does anyone know whether the RMonad technique is applicable to Arrow? would it be possible without GHC hackery to make an RArrow?
22:30:26 <dmwit> kmeyer: seq reduces its first argument to weak-head normal form before returning its second argument.
22:30:27 <luqui> i know ghc does more magic for arrow notation than it does for monad
22:30:37 <luqui> and that no-implicit-prelude does not work so well on arrows
22:30:41 <dmwit> kmeyer: It is "magic" in that it can't be implemented otherwise in pure Haskell.
22:30:41 <pumpkin> luqui: yeah, that's what I was afraid of
22:31:12 <kmeyer> way over my head unfortunately
22:31:16 <pumpkin> kmeyer: it forces the first argument to evaluate and then returns the second argument, if evaluated
22:31:32 <luqui> kmeyer, it's ok.  a fair number of people think it shouldn't be used anyway :-)
22:32:28 <mjrosenb> sjanssen: an expression that the type inference engine will resolve to a lambda without it being applied, and without it being explicitly typed
22:32:35 <dolio> There are eta laws for other types, too, but they definitely don't work in haskell.
22:32:44 <dolio> Like p = (fst p, snd p)
22:32:47 <kmeyer> ok, thanks
22:33:07 <kmeyer> (for explaining it to me :D)
22:33:15 <pumpkin> :)
22:33:17 <sjanssen> mjrosenb: is this just a roundabout way to say "not bottom"?
22:33:36 <sjanssen> mjrosenb: also, I bet we can figure out some sort of counter example
22:33:44 <mjrosenb> sjanssen: :p;  perhaps
22:33:54 <mjrosenb> this could be interesting
22:34:06 <dolio> @type undefined `seq` id
22:34:07 <lambdabot> forall a. a -> a
22:34:15 <sjanssen> (undefined `asTypeOf` id) -- the expression doesn't use type type annotations directly
22:34:25 <pumpkin> :t asTypeOf
22:34:26 <lambdabot> forall a. a -> a -> a
22:34:28 <luqui> in the absense of seq, undefined = const undefined
22:35:05 <sjanssen> @type let _ = x (); x = undefined in x
22:35:06 <lambdabot> forall a. a
22:35:28 <sjanssen> hmm
22:35:38 <luqui> let polymorphism! :-
22:35:47 <dolio> Hah. Now you want your monomorphism restriction! :)
22:36:02 <sjanssen> dolio: yes, please!
22:36:27 <dolio> Although that actually doesn't apply.
22:36:31 <dmwit> luqui: Nuh-uh, const undefined has a different type than undefined!
22:36:33 <rwbarton> wouldn't you have to introduce a type class somehow?
22:36:57 <dolio> Yeah.
22:38:46 <luqui> dmwit, for instantiations that typecheck, of course  =p
22:48:49 <mmorrow> > (id (undefined :: a -> b)) `seq` ()
22:48:50 <lambdabot>   * Exception: Prelude.undefined
22:48:55 <mmorrow> > (`id` (undefined :: a -> b)) `seq` ()
22:48:56 <lambdabot>   ()
22:49:59 <mmorrow> > (id undefined) `seq` ()
22:50:00 <lambdabot>   * Exception: Prelude.undefined
22:50:03 <mmorrow> > (`id` undefined) `seq` ()
22:50:05 <lambdabot>   ()
22:50:21 <pumpkin> @type (`id` ?undefined) `seq` ()
22:50:22 <lambdabot> forall t. (?undefined::t) => ()
22:51:31 <devilx0> hi! everybody
22:53:14 <mmorrow> @let thunk = (\x->(\()->x))
22:53:16 <lambdabot>  Defined.
22:53:30 <mmorrow> > thunk undefined `seq` ()
22:53:31 <lambdabot>   ()
22:55:07 <BMeph> luqui: Hey, are you still maintaining infinite-search? :)
22:55:22 <luqui> BMeph, yeah
22:56:37 <BMeph> I have a suggestion for an addition to the module: make them Foldable. :)
22:57:33 <luqui> BMeph, you're joking, right?
22:58:09 <BMeph> luqui: No, I'm not. The types fit, so why not? :)
22:58:17 <vegai> is there a version of unwords with the separator character parametrized?
22:58:32 <BMeph> vegai: There is if you write it... ;)
22:58:38 <vegai> aww, that should be in there
22:58:44 <mmorrow> @type let _ = ?f x (); x = undefined in x
22:58:45 <lambdabot> forall t a a1. (?f::a -> () -> t) => a1
22:58:53 <luqui> you keep smiling...  anyway, because it's not computable.
22:58:57 <Saizan__> @hackage split
22:58:57 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split
22:59:02 <vegai> haskell's string manipulation functions are embarassing
22:59:02 <Saizan__> vegai: ^^^^
22:59:12 <luqui> there is no way to fold over the cantor space; it is computably uncountable
22:59:45 <luqui> although, any type with decidable equality can be folded.
22:59:56 <luqui> hmm, might not get to all of them though
23:00:03 <luqui> (eg. consider ordinals)
23:00:15 <vegai> Saizan__: that seems to do the inverse
23:00:18 <BMeph> luqui: So, the fold would just run forever on the wrong predicate; don't use that one. ;)
23:00:34 <sjanssen> vegai: Data.List.intercalate
23:00:35 <luqui> BMeph, I don't understand...
23:00:45 <Saizan__> yeah, intercalate then
23:00:49 <sjanssen> (yes, intercalate is a strange name)
23:00:56 <vegai> ah, ok
23:01:17 <vegai> heh, and Data.List provides 'unintercalate'
23:01:26 <vegai> I mean the split lib
23:01:42 <BMeph> luqui: I've been arguing that forsome and forevery fit the definition for foldMap, if you flip the arguments. And wrap the Bools. :)
23:02:23 <luqui> oh!
23:02:33 <luqui> I think bool is quite essential though
23:02:39 <luqui> it doesn't generalize to all monoids
23:02:50 <luqui> I'm not totally sure though
23:03:43 <luqui> wait, of course I'm sure :-)
23:03:58 <BMeph> luqui: Hmm, I didn't consider that it had to work for all monoids, that might be trickier. :\
23:04:36 <BMeph> Er, s/trickier/impossible/ rather. :\
23:05:08 <luqui> well it can be generalized to work for any finite type.
23:05:41 <luqui> I'm trying to come up with precisely the type of topological space it works on, because I'm practicing my topology
23:06:13 <BMeph> luqui: To quote lambdabot, 'I know nothing about topology.' :)
23:06:34 <luqui> discrete & hausdorff maybe
23:06:48 <luqui> I'm working on topology-extras :-)
23:07:00 <luqui> but it needs a good unamb, which we are waiting on
23:07:50 <luqui> Data.Searchable was just a teaser :-)   (Data.Searchable.Set = Compact & Overt)
23:09:10 <BMeph> luqui: Just take a (counter-)pointer from Mr. Kmett - split up the package if you wind up with too many modules, maybe a -basics and an -extras.
23:09:29 <luqui> yeah, I don't think it'll be that big.
23:09:42 <BMeph> luqui: A package with 50 interesting modules, is still a little intimidating. :)
23:09:53 <luqui> category-extras frightens me
23:10:17 <BMeph> luqui: I rest my case. :)
23:10:20 <luqui> :-)
23:12:10 <BMeph> luqui: It just feels like it's teasing me, seeing forevery and forsome with that type just saying, "You want me (in a Foldable). You KNOW you want me." :)
23:13:53 <luqui> yeah, I know what you mean.  Bool itself teases me that way, saying "you want me to be Sigma (semidecidable)"
23:14:32 <luqui> among other things.
23:14:45 <luqui> I really don't like Bool...  can't quite put my finger on why
23:14:57 <luqui> just always feels like there could be more information
23:17:21 <ztirf_> @pl \x -> flip (flip f . g) x
23:17:21 <lambdabot> (. g) . f
23:18:09 <dolio> Clearly any p : a -> Bool should instead be P : a -> Set and dec : (x : a) -> P x \/ Not (P x).
23:18:49 <dolio> Except when it shouldn't.
23:20:54 <dolio> Then you can prove stuff like: All P (filter dec l)
23:26:50 <mmorrow> i've got the interp i'm working on verrrry precariously in a (very) minimally usable (for amusement) state: http://moonpatio.com/repos/voom/  (name is pending)
23:26:52 <ddarius> type Sigma = ()
23:26:58 <mmorrow> http://moonpatio.com/repos/voom/EXAMPLE
23:27:08 <mmorrow> the code'
23:27:18 <BMeph> luqui: I also get the nagging suspicion that S a should be a comonad, especially since I don't see how you could represent an empty set other than by spoofing the predicate, but that might not even work...
23:27:22 <mmorrow> s a mess, but you can eval basic stuff
23:29:09 <dons> ?userrrrs
23:29:09 <lambdabot> Unknown command, try @list
23:29:12 <dons> ?users
23:29:12 <lambdabot> Maximum users seen in #haskell: 606, currently: 572 (94.4%), active: 10 (1.7%)
23:29:14 <dons> heh
23:29:23 <luqui> BMeph, yeah S is by definition nonempty
23:29:42 <mmorrow> @yarrr
23:29:43 <lambdabot> Ahoy mateys
23:29:55 <luqui> BMeph, so extract = fromJust (search (const True))
23:30:01 <luqui> BMeph, duplicate = ...?
23:30:54 <SubStack> @pl maximumBy (\a b -> length a `compare` length b)
23:30:54 <lambdabot> maximumBy ((. length) . compare . length)
23:31:13 <luqui> maximumBy (compare `on` length)
23:31:19 <SubStack> :o
23:31:49 <SubStack> which module is on in?
23:31:53 <luqui> Data.Function
23:32:04 <SubStack> cool beans
23:32:36 <SubStack> luqui++
23:32:49 <BMeph> luqui: I remember just seeing someone do a comonad rework...oh, Snap! Let me check out EdwardK's blogart on Pointed Sets, that sounds applicable (no pun intended). ;)
23:33:42 <luqui> BMeph, bedtime for me.  let me know about developments :-)
23:34:02 <luqui> BMeph, infinite-search is on github, if you feel like forking, too :-)
23:34:20 <luqui> (fork in the git sense, i.e. for the purpose of pushing)
23:34:36 <BMeph> luqui: You modder-forker, you! ;p
23:34:43 <luqui> lol
23:35:20 <BMeph> luqui: I'm looking at it now (well, not _Now_ now, but when I'm not in the IRC window). ;)
23:36:45 <dons> ok guys. here's a tough one. i'm doing a 60 second podcast interview tomorrow for a "general technical audience" and need to impart a "tech tip"
23:36:48 <dons> suggestions....
23:37:08 <ddarius> dons: Purity
23:37:19 <dons> yeah, i reckon so.
23:37:31 <ddarius> 'not sure how to reduce that to a compelling 60 seconds.
23:37:43 <dons> purity. hard problems are solved by it. your code will be easier to maintain, easier to parallelise, easier.
23:37:49 <int80_h> dons: I find that most initial errors come from not being able to "peel the onion", that is treating "the computer" or "the network" as a single monolithic entity.
23:37:53 <jeffz`> dons, no heap corruption
23:38:01 <int80_h> dons: so tell them to peel the onion.
23:38:04 <mmorrow> whatever way you think the usb is gonna go into the computer, it'll always be the other way. so just don't think about it and let it happen.
23:38:11 <dons> int80_h: mm. yes. understand the machine at all levels
23:38:13 <dons> from source to cycles
23:38:25 <dons> mmorrow: :)
23:38:29 <ddarius> Screw cycles.  Solid state physics.
23:38:31 <dons> mmorrow: THAT IS SO TRUE. you win.
23:38:37 <mmorrow> heh
23:38:50 <mmorrow> i try to do that and fail daily
23:39:06 <dons> ok. i'll try to think up "dons 60 seconds of pure thoughts"
23:39:22 <int80_h> peel the onion!
23:39:24 <int80_h> hee hee
23:39:37 <dons> they'll be a few podcast interviews with RWH authors this  week. I think there's 3 lined up.
23:39:41 <ddarius> dons: I'd hit composability, parallelizability.
23:39:52 <dons> ddarius: oh, compositionality. good  thinking.
23:40:06 <ddarius> dons: I.e. something like, "Purity lets you take two pieces of correct code and put them together to make a bigger piece of correct code."
23:40:15 <ddarius> (this applies to maintainability and parallelizability)
23:40:31 <dons> by default safe for parallelism
23:40:48 <ddarius> testability is another idea
23:40:50 * dons needs to channel his inner SPJ.
23:40:58 <ddarius> You'll clearly need to filter this dramatically.
23:41:10 <int80_h> do it with puppets
23:41:18 <int80_h> puppets are always a crowd pleaser
23:41:30 <Raevel> or puppies
23:41:36 <dons> puppets rock
23:41:36 * int80_h cites Potter Puppet Pals.
23:41:42 <dons> except the scary ones
23:41:42 <pumpkin> puppets sock
23:47:58 <ddarius> Okay here's my 60 second spiel: "Avoid side-effects.  Purity makes functions easy to test and understand.  Purity also makes combining correct code in a way that maintains correctness easy.  Finally, the result is just as easy to test as the pieces, leading to higher confidence with less brain sweat."
23:48:18 <int80_h> sweating brains are just gross
23:48:52 <SubStack> stewing in their own juices
23:49:29 <SubStack> the program I'm working on now has a Brain type, perhaps I can work juices in their someplace
23:50:48 <pumpkin> maybe a typeclass called Juicable?
23:50:57 <pumpkin> and a function in it called juice
23:50:59 <SubStack> could be
23:51:01 <pumpkin> or squeeze
23:51:12 <SubStack> *there* even
23:51:20 <Cale> Juicy?
23:51:24 <SubStack> odd, I hardly ever make those sorts of grammatical errors >_<
23:51:27 <ddarius> It was so much more interesting with "their"
23:51:38 <pumpkin> lol
23:51:48 <Cale> squeeze :: (Juicy t) => t -> Juice
23:52:53 <sbahra> Cale, bored by any chance? :-P
23:53:42 <Cale> sbahra: What is it?
23:53:50 <Olathe> data Juice a = HighPulp a | MediumPulp a | NoPulp a
23:54:30 <sbahra> Cale, Haskell `intersect` FreeBSD logo
23:54:37 <rbe> hi
23:54:43 <Olathe> Hello.
23:54:47 <ddarius> Jormungandr
23:54:55 <sbahra> Cale, it seems you enjoy graphics work, if you have the time that is something we could use.
23:55:27 <Cale> I'll think about it. If an idea comes to me, I'll see what I can do.
23:55:32 <sbahra> Cool.
23:55:40 <rbe> i am trying to pattern match an empty list... but it fails: i use a guard | x [] = [x] (type sig ist Int->[Int]->[Int]) hskell expects [a]->Bool ... can anybody help?
23:55:41 <BMeph> dons: It's just my opinion, but I like "isolate side-effects" instead of avoiding. It keeps some of the avoiding sense, but sounds more "in charge" ;)
23:55:50 <dons> ddarius: awesome. thanks.
23:55:54 <dons> BMeph: good idea.
23:56:03 <dons> yes, i keep meaning to blog about the joy of local effects
23:56:15 <dons> and how encapsulating them makes life easy
23:56:32 <vixey> rbe, just pattern match don't use a guard
23:56:33 <lambdabot> vixey: You have 2 new messages. '/msg lambdabot @messages' to read them.
23:56:37 <vixey> @messages
23:56:37 <lambdabot> mmorrow said 2d 10h 48m 7s ago: i've got abssyn, free/bound vars, and a parser + pprinter for pisigma at http://moonpatio.com/repos/pisigma/. i've decided to use this as the interp frontend "core
23:56:37 <lambdabot> lang" for my lvm implem, so if everything goes as planned, anything you can manage to translate into this you can interpret
23:56:37 <lambdabot> mmorrow said 2h 17m 31s ago: zomg it's so hacky/messy/needs-to-be-cleaned and barely strung into a minimally working-at-all unit... but it actually works!!@ http://moonpatio.com/repos/voom/ http://
23:56:37 <lambdabot> moonpatio.com/repos/voom/EXAMPLE
23:57:11 <BMeph> That's what I like about a pure language. You can't always avoid side-effects, but at least you get more warning besides:
23:57:11 <vixey> lambdabot tells me the same message 3 times
23:57:20 <BMeph> Segmentation fault (core dumped).
23:57:54 <pumpkin> BMeph: ORLY? I got one of those yesterday
23:58:07 <rbe> thx, vixey
23:58:11 <vixey> I think that's more about type safety than purity
23:58:19 <rbe> vixey, but can't i combine that?
23:58:32 <vixey> rbe, look at:
23:58:35 <vixey> @src null
23:58:36 <lambdabot> null []     = True
23:58:36 <lambdabot> null (_:_)  = False
23:58:43 <vixey> you can use null in a guard
23:59:29 <Cale> guards are boolean-valued expressions which determine if the clause should be used or not
23:59:39 <Cale> and they're evaluated after pattern matching
23:59:57 <rbe> vixey ah ok
