00:00:05 <Saizan> foldl' solves this by evaluation the accumulator at each step of the recursion
00:00:38 <Saizan> (funny typo, evaluating -> evaluation)
00:01:42 <kmeyer> cool
00:07:18 <jeffwheeler> Thanks, Saizan and intoverflow; I got GHC 6.10 working now. :)
00:08:12 * kmeyer has a class with homework that is in haskell, so beware and do not answer my questions if they sound like homework
00:08:36 <pumpkin> lol
00:09:36 <Saizan> heh, this channel is quite good at that :)
00:09:45 <jeffwheeler> I'm good with answering homework questions, as long as you hide it well.
00:09:59 <psygnisfive> guys
00:10:03 <psygnisfive> how does - work?
00:10:04 <psygnisfive> lol
00:10:12 <psygnisfive> it seems circular
00:10:21 <jeffwheeler> You're trying something like (-5)? Try `subtract`.
00:10:25 <psygnisfive> no no
00:10:26 <psygnisfive> i mean look:
00:10:28 <psygnisfive> @src -
00:10:29 <lambdabot> x - y = x + negate y
00:10:32 <psygnisfive> @src negate
00:10:33 <lambdabot> negate x = 0 - x
00:10:36 <Saizan> "that" being helpfully answer questions without solving homeworks
00:10:38 <vixey> heh
00:10:41 <vixey> @src Num
00:10:41 <lambdabot> class  (Eq a, Show a) => Num a  where
00:10:41 <lambdabot>     (+), (-), (*)           :: a -> a -> a
00:10:41 <lambdabot>     negate, abs, signum     :: a -> a
00:10:41 <lambdabot>     fromInteger             :: Integer -> a
00:10:41 <bd_> lambdabot lies :)
00:10:43 <pumpkin> psygnisfive: haskell doesn't care about circular definitions!
00:10:44 <Riastradh> They are methods in the Num class, psygnisfive, of which at least one must be defined.
00:10:45 <bd_> or rather
00:10:49 <bd_> those are default implementations
00:11:00 <bd_> a specific instance of Num will provide at least one of those
00:11:08 <psygnisfive> but its not just circular i dont think
00:11:36 <jeffwheeler> psygnisfive: the default implementations _are_ circular, which means only one has to be defined . . . really neat, I think
00:11:38 <Saizan> yeah, if they were defined like that they would loop
00:11:54 <psygnisfive> 5 - 4 == 5 + (negate 4) = 5 + (0 - 4) = 5 + (0 + (negate 4)) = 5 + (0 + (0 - 4)) ...
00:12:11 <psygnisfive> i guess maybe theres a basecase for 0?
00:12:13 <jeffwheeler> Fortunately, in Int or whatever, it is defined.
00:12:26 <jeffwheeler> No, the specific instances of Num probably define it.
00:12:45 <psygnisfive> ok. heh. i just thought this was humorous to see. :p
00:13:09 <pumpkin> hmm, I'm guessing my unsafeness is confusing GHC, but I thought what I was doing was safe!
00:13:12 <jeffwheeler> Yeah; I think a lot of typeclasses do it, because it's so convenient for the instances to implement only a fraction of the functions.
00:13:58 <jeffwheeler> @src (-) :: Int -> Int
00:13:59 <lambdabot> Source not found. Do you think like you type?
00:14:02 <jeffwheeler> I didn't think that'd work.
00:14:04 <pumpkin> anyone here used unsafeFreezeAllMU ? :)
00:14:04 <kmeyer> so my present homework question is, how can I define multiplication between elements of a given type?
00:14:12 <kmeyer> or is multiplication explicitly only defined for t where t is a Num?
00:14:30 <jeffwheeler> kmeyer: that's exactly right; so make your t a Num
00:14:33 <kmeyer> (do I have to use a new infix operator (*** or something) or can I use (*))?
00:14:45 <kmeyer> ah, but my t is a tuple
00:14:53 <jeffwheeler> So?
00:14:57 <kmeyer> @src Num
00:14:58 <lambdabot> class  (Eq a, Show a) => Num a  where
00:14:58 <lambdabot>     (+), (-), (*)           :: a -> a -> a
00:14:58 <lambdabot>     negate, abs, signum     :: a -> a
00:14:58 <lambdabot>     fromInteger             :: Integer -> a
00:15:14 <pumpkin> kmeyer: don't take ***, that belongs to arrow! it'll take out its bow and shoot you
00:15:19 <kmeyer> heh
00:15:54 <pumpkin> the prelude numeric classes weren't written by mathematicians, or if they were, they weren't trying to be very mathematical at the time :P
00:15:56 <kmeyer> jeffwheeler: how do I define negate, abs, etc for my type?
00:16:07 <psygnisfive> *sigh* i wish i understood haskell :(
00:16:13 <jeffwheeler> kmeyer: with error? :D
00:16:15 <pumpkin> psygnisfive: any particular questions?
00:16:20 <kmeyer> jeffwheeler: ahh
00:16:22 <psygnisfive> no pumpkin love
00:16:24 <pumpkin> psygnisfive: there are a bajillion tutorials/books/etc.
00:16:25 <pumpkin> :)
00:16:28 <kmeyer> I think the default will be too general
00:16:30 <psygnisfive> yeah i know i know
00:16:35 <psygnisfive> that doesnt me i get it :)
00:16:37 <pumpkin> psygnisfive: and a bunch of very helpful and willing people in here :P
00:16:39 <kmeyer> but if I specify a type for (*) that shadows the Prelude's (*), no?
00:16:52 <psygnisfive> actually its not really necessary for me
00:16:57 * jeffwheeler loves #haskell. So much warmer and fuzzier than other #s.
00:17:08 <psygnisfive> im just interested in it for purely recreational reasnos
00:17:09 <kmeyer> ##c is particularly mean :D
00:17:10 <psygnisfive> reasons*
00:17:10 <pumpkin> jeffwheeler: yeah :) I feel the same way
00:17:14 <pumpkin> psygnisfive: that's why I'm doing it :)
00:17:16 <psygnisfive> so its not high on my list of needs right now ;P
00:17:21 <pumpkin> never taken a course that requires it
00:17:27 <psygnisfive> yeah well
00:17:28 <jeffwheeler> kmeyer: Prelude's (*) is polymorphic, so it works with the operands provided to it.
00:17:30 <psygnisfive> what i mean is like
00:17:35 <psygnisfive> i wouldnt even use it.
00:17:40 <Saizan> kmeyer: you can do two different things, one is defining your own (*) and hiding the Prelude one, the other is declaring an instance of Num for your type
00:17:49 <kmeyer> Saizan: and the latter looks like?
00:18:06 <jeffwheeler> kmeyer: the latter is what I've been pushing you towards. :)
00:18:09 <Saizan> kmeyer: the latter is done by instance Num YourTYpe where negate x = ...; x * y = ...; ...
00:18:17 <kmeyer> yeah, I've been floundering in that direction (or I try)
00:18:26 <kmeyer> ah, cool.
00:19:09 <Saizan> you normally put that on multiple lines by indenting the declarations after "where"
00:19:24 <kmeyer> are the semi-colons necessary if it's indented properly on multiple lines?
00:19:32 <Saizan> no
00:19:33 <jsn> kmeyer: no
00:19:40 <kmeyer> after where, or is (say) two spaces ok?
00:19:47 <Saizan> two spaces ok
00:20:13 <jeffwheeler> kmeyer: this chapter has a great example (that is a ton of fun to play with, actually) of creating a Num instance: http://book.realworldhaskell.org/read/data-structures.html
00:20:23 <kmeyer> thanks!
00:20:25 <jeffwheeler> kmeyer: it starts at "Extended example: Numeric Types"
00:20:40 <jeffwheeler> (That was one of my favorite sections in RWH; it was awesome!)
00:27:55 <augustss> jeffwheeler: did you try using the new numbers with, e.g., Data.Complex?  It should just work.
00:28:19 <jeffwheeler> augustss: no, I don't know about them. :-/
00:28:38 <jeffwheeler> But worth looking at, certainly.
00:28:51 <pumpkin> augustss: know much about unsafeFreezeAllMU? :)
00:29:12 <augustss> pumpkin: I don't even know if it exists :)
00:29:19 <pumpkin> the fact that I'm getting different behavior from -O2 and nothing probably means I'm doing something wrong :P
00:29:23 <pumpkin> lol ok
00:29:33 <pumpkin> http://hpaste.org/13820 yay
00:30:00 <augustss> Are you sure you've really finished all operations when you do the freeze?
00:30:29 <pumpkin> I was pretty sure I had
00:30:53 <augustss> pumpkin: Does it work with the safe freeze?
00:30:54 <jeffwheeler> Woo, didn't think a smiley theme could crash Pidgin.
00:30:57 <pumpkin> it just seems to stop calling my function on the frozen one after two tries
00:31:04 <pumpkin> augustss: I couldn't even find a safe freeze :P
00:31:09 <augustss> oh
00:31:12 <augustss> :(
00:31:44 <pumpkin> I assumed the freeze was only unsafe because I could have a UArr with the same "backing" as a MUArr, which would allow me to modify the UArr
00:31:59 <kmeyer> I guess I'm still not clear as to the syntax for defining Num operations on my type -- I'm getting "Illegal instance declaration for `Num (Double, Integer)'" (with some more lines)
00:32:05 <pumpkin> but all I do is freeze the MUArr, perform a computation on the resulting UArr, and then go do other stuff
00:32:21 <mauke> kmeyer: what is your type?
00:32:23 <pumpkin> in such a way that I never look at the resulting UArr in a place the MUArr could be changing it
00:32:28 <pumpkin> (or so I thought)
00:32:29 <kmeyer> mauke: (Double, Int)
00:32:42 <mauke> that's not exactly yours :-)
00:32:47 <kmeyer> well yeah :)
00:33:01 <mauke> and I'm pretty sure Haskell98 doesn't allow that in instance declaratiors
00:33:07 <mauke> s/rs$/ns
00:33:07 <kmeyer> ah, darn
00:33:08 <pumpkin> augustss: I think my issue is that ghc can't tell that the output of unsafeFreezeAllMU will differ between iterations
00:33:16 <pumpkin> is there some way I can tell it that?
00:33:41 <augustss> How can the output differ between iterations?
00:33:51 <augustss> Then the input must differ.
00:33:59 <pumpkin> well I'm in an ST
00:34:08 <pumpkin> and the M stands for mutable
00:34:19 <augustss> But then you're using it wrong.
00:34:29 <pumpkin> hmm
00:34:38 <augustss> Once you freeze you must never change the data again.
00:34:53 <pumpkin> :(
00:35:30 <pumpkin> I guess I don't need to freeze it, it just made things easier for me, because MUArr has almost no functionality
00:36:43 <bos> view patterns for the win: http://www.serpentine.com/blog/2009/01/11/fun-with-haskell-view-patterns/
00:36:59 <pumpkin> I still feel like what I'm doing is safe, I just need to convince ghc of that :/
00:37:13 <augustss> I see that the documentation is spectacularly bad about freeze.  It should clearly state why it's unsafe, and what the contract is that you need to obey to make it safe.
00:38:12 <augustss> What is it you need to do to the MUArr that you can't?
00:38:37 <kmeyer> @src signum
00:38:38 <lambdabot> Source not found. Where did you learn to type?
00:38:46 <kmeyer> ?type signum
00:38:48 <pumpkin> augustss: my use case is basically, iterate a bunch of times in a forM_, making changes to the MUArr, then freeze it to "temporarily" get a UArr "view" of it that is easy to operate on (i.e. mapU, sumU, and all the other useful functions), then save the output from that, and iterate again
00:38:48 <lambdabot> forall a. (Num a) => a -> a
00:39:08 <pumpkin> augustss: basically MUArr only has readMU, writeMU, copyMU, lengthMU and a couple of other functions defined for it
00:39:27 <pumpkin> so I was freezing it just so I could use mapU easily :)
00:39:34 <augustss> pumpkin: try copyMU and freeze that.
00:39:49 * pumpkin hides, overhead
00:39:50 <ikegami__> I found that the latest hmake-3.14 (http://www.haskell.org/hmake/) cannot be built by the current released ghc 6.10.1
00:39:52 <pumpkin> but I'll try it :)
00:40:09 <ikegami__> However, ghc 6.8.3 can built hmake-3.14.
00:40:19 <augustss> hmmmm
00:40:36 <pumpkin> not even sure how copyMU is supposed to work
00:40:54 <ikegami__> The reason why hmake-3.14 cannot be built ghc 6.10.1 because the package system is changed, I guess
00:41:02 <pumpkin> I think it might be making a MUArr out of a UArr?
00:41:43 <augustss> pumpkin: I don't understand it either
00:42:11 <augustss> pumpkin: Oh, I see.  It goes the wrong way.
00:42:42 <ikegami__> If I can fix it, then I'll report the result to developers of hmake
00:42:51 <augustss> pumpkin: can you use newU?
00:43:10 <augustss> pumpkin: hmmm, probably not
00:43:21 <pumpkin> it actually looks like I might be able to
00:43:34 <nissassA> test
00:43:58 <pumpkin> oh
00:43:59 <augustss> pumpkin: I don't understand how they can provide unsafe freeze, but not safe ones.
00:44:16 <pumpkin> yeah :/
00:44:31 <vixey> http://www.cs.ru.nl/A.vanWeelden/files/BiArrow.icl
00:44:38 <zerosoul> test2
00:44:54 <vixey> test3
00:45:16 <augustss> test4
00:45:35 <pumpkin> augustss: I guess I can just write a mapMU or something by readMU for each index in it, but it's not fun :)
00:45:52 <pumpkin> feels very imperative :P
00:46:12 <zerosoul> test1 is my friend,haha
00:46:28 <nissassA> :p
00:46:28 <zerosoul> he is the first time use IRC
00:46:51 <zerosoul> I'm the sencond time :p
00:47:44 <augustss> pumpkin: Do you need the MU stuff?  Have you tried MArray?
00:47:55 <yakov> hey
00:48:15 <pumpkin> augustss: I have a working list implementation of this algorithm, was just trying to see how blisteringly fast I could make it using uvector :P
00:48:20 <pumpkin> but nope, I haven't :)
00:48:31 <augustss> pumpkin: ok
00:48:58 <augustss> It properly has freeze and unsafeFreeze
00:49:21 <pumpkin> augustss: if I wanted to be very bad, is there some annotation I can use to tell GHC that "function y might not be referentially transparent so please call it every time I tell you to"? *hides*
00:49:39 <augustss> pumpkin: Not that I know.
00:49:43 <pumpkin> alright :)
00:49:57 <pumpkin> I probably should't even be thinking those thoughts
00:50:01 <pumpkin> thoughtpolice might come after me
00:50:03 <augustss> pumpkin: If there were people would misuse :)
00:50:18 <bd_> pumpkin: problem is the compiler assumes everywhere that everything is referentially transparent
00:50:20 <mauke> tee hee
00:50:30 <pumpkin> yeah :)
00:50:37 <bd_> and it is very easy for your non-referentially transparent function to get into a context (after some optimization passes) where this ceases to be obvious
00:50:48 <mauke> list fusion doesn't apply cleanly to perl :-)
00:50:57 <mauke>  map lc, map split /([0-9]+)/, @_
00:50:59 <bd_> heck, whatever's calling it is a function too, right? Who says that'll be called more than once?
00:51:12 <pumpkin> yeah :/
00:51:19 <pumpkin> I'll just emulate mapU then :)
00:51:34 * pumpkin was just trying to take the easy way out as usual
00:51:45 <bd_> write a mapMU :)
00:51:50 <augustss> mauke: list fusion is not valid when the function can have effects
00:51:59 <pumpkin> bd_: maybe I will!
00:52:00 <mauke> augustss: in this case, they don't
00:52:48 <mauke> the problem is that perl's map is actually something like concatMap :-)
00:52:49 <augustss> pumpkin: You could write a function that just copies the array.  Then you can unsafe freeze the copy.
00:53:18 <pumpkin> ah yeah
00:53:20 <augustss> mauke: ah yes.  I'd forgotten that.  there are many reason I dislike perl.  I can't remember all of them
00:53:42 <mauke> b-but perl loves you! ;_;
00:54:10 <augustss> I like Larry Wall, that's as far as I'll go. :)
00:55:14 <Lanjiao> did someone use hStringTemplate? does in support unicode and how is its performace? I want to use in to produce html doc about 30KB.
00:56:25 <pumpkin> oh no, my s is leaking :(
00:58:23 <pumpkin> http://hpaste.org/13821 any suggestions?
00:58:28 <vixey> is there some annotation I can use to tell GHC that "function y might not be referentially transparent so please call it every time I tell you to"? *hides* -- sound like a job for:  Monad m => ... -> m a
00:59:43 <pumpkin> :)
01:01:22 <mauke> runST and $ don't mix
01:01:32 <pumpkin> :o
01:01:45 <atom> hey. I want to define two types: data A = A Int [B] B; data B = B "a function from A to list of A".
01:01:50 <pumpkin> why not? it was working earlier
01:01:55 <mauke> really? hmm
01:02:05 <mauke> maybe I'm not up to date
01:02:09 <pumpkin> I thought so... at least without -O2 :P
01:02:16 <pumpkin> no optimization = all works fine :)
01:02:38 <mauke> anyway, I like to write forM_ ... $ \i -> do <newline>
01:02:47 <vixey> atom, type B = A -> [A]
01:03:18 <pumpkin> mauke: that looks nice :)
01:03:19 <atom> vixey: oh, so the arrow type I used was wrong...
01:03:28 <augustss> atom: or data B = B (A -> [A])
01:03:30 <atom> vixey: thanks.
01:03:44 <atom> vixey: it compiles now.
01:03:54 <vixey> and it is right?  I hope
01:04:33 <vixey> we really need a -XFPH
01:04:47 <atom> vixey: that was a minimal case. I just changed => to -> (don't know how I managed to think the function arrow is ->, but I am pretty new to haskell)
01:05:00 <vixey> ok
01:06:00 <atom> another thing - is it common to define a few functions to extract members of a type out of it so you don't have to deconstruct it in every function?
01:06:06 <pumpkin> my s keeps escaping the ST box :(
01:06:26 <mauke> atom: yes
01:06:30 <vixey> atom, with the A you wrote, I would probably do it
01:06:47 <mauke> atom: you could let the compiler write them for you, using record syntax
01:07:02 <atom> mauke: hm... I'll have to look that up.
01:07:06 <augustss> pumpkin: runST and $ will mix when impredicative types work right
01:07:11 <atom> mauke: thanks for the suggestion.
01:07:18 <pumpkin> augustss: O.O
01:07:21 <mauke> data Foo = C{ field1 :: Int, field2 :: [Char] }
01:07:22 <vixey> what does impredicative polymorphism mean? :/
01:07:54 <augustss> that polymorphic types belong to *
01:08:04 <pumpkin> do they involve imprecations?
01:08:07 <mauke> *> runST $ return 42
01:08:07 <mauke> 42
01:08:10 * pumpkin imprecates
01:08:40 <atom> mauke: google haskell record syntax turns up a couple of blog entries and a haskell syntactic extensions page... Which docs would you recommend for this?
01:08:50 <augustss> > runST $ return 42
01:08:51 <lambdabot>   /tmp/4770371446533972370:70:40: Not in scope: `runST'
01:08:59 <pumpkin> , runST $ return 42
01:09:01 <lunabot>  42
01:09:21 <augustss> , (flip ($)) (return 42) runST
01:09:22 <lunabot>  luna: Couldn't match expected type `m t'
01:09:29 <pumpkin> :o
01:10:21 <augustss> , let x # f = f x in return 42 # runST
01:10:23 <pumpkin> , (flip ($)) 5 (+4)
01:10:23 <lunabot>  luna: Couldn't match expected type `m t'
01:10:25 <lunabot>  9
01:10:44 <augustss> ghc has a horrible hack that makes runST $ work.
01:10:51 <pumpkin> o.O
01:10:55 <pumpkin> wow
01:11:05 <mauke> atom: http://haskell.org/onlinereport/exps.html#field-ops
01:11:07 <pumpkin> is it because ST itself is so fancy?
01:11:16 <atom> mauke: thanks very much.
01:11:23 <vixey> euuugh
01:11:42 <augustss> The problem is that runST has an argument which has a forall type
01:11:59 <pumpkin> ah, so it'll happily gobble up the $ itself?
01:12:07 <mauke> atom: http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#deftypes.record
01:12:46 <augustss> The type of $ would have to be instantiated when the argument being of forall type.  And that is not allowed in the current type system.  It needs impredicative types.
01:12:53 <pumpkin> ah
01:13:09 <pumpkin> I'll just accept my half understanding of that :)
01:13:41 <augustss> pumpkin: It's pretty subtle, and doesn't hit you often.
01:14:27 <kmeyer> hm, how do I install HUnit on my system?
01:14:45 <pumpkin> http://hpaste.org/13822 my s type is escaping in here :(
01:14:55 <kmeyer> is there a way of installing packages in the user's $HOME or must they be installed system-wide?
01:15:14 <kmeyer> (or is Hunit part of GHC?)
01:15:14 <jeffwheeler> kmeyer: most usually install in $HOME; are you using cabal-install?
01:15:27 <kmeyer> don't know if I am, should I?
01:15:30 <jeffwheeler> kmeyer: oh, I didn't read your earlier messages.
01:15:36 <Saizan> i think HUnit is shipped with ghc
01:15:59 <jeffwheeler> HUnit is on Hackage; try `cabal install hunit`
01:16:00 <augustss> kmeyer: I think it's installed.  try 'ghc-pkg list'
01:16:10 <jeffwheeler> Try theirs first.
01:16:16 <kmeyer> it's listed
01:16:36 <augustss> kmeyer: then just use it, and compile with --make
01:16:43 <kmeyer> ok, cool
01:16:53 * jeffwheeler is very giddy about darcs being on hackage
01:17:13 <Saizan> http://haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package if you need to install a non-standard packge
01:17:43 <kmeyer> Saizan: thanks :)
01:19:19 * jeffwheeler _was_ giddy about darsc being cabal-installable, until it died near the end, because cURL wasn't installed.
01:20:51 <pumpkin> :t foldM
01:20:52 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
01:22:00 <jeffwheeler> Is there any reason not to create a cabal2arch-equivalent for Debian/Ubuntu?
01:25:07 <kmeyer> augustss: what if I want it to be loading in the interpreter?
01:26:51 <augustss> kmeyer: that works, just do :m +ModuleName to bring some module into scope
01:27:16 <kmeyer> Prelude> :m +Hunit
01:27:16 <kmeyer> Could not find module `Hunit':
01:27:30 <kmeyer> er, does that when I spell it correctly too
01:27:59 <jeffwheeler> With the capital U?
01:28:41 <jeffwheeler> Looks like it should be Test.HUnit.
01:28:48 <psygnisfive> guise
01:28:53 <psygnisfive> ghci wont let me define functions :(
01:28:55 <jeffwheeler> kmeyer: :m +Test.HUnit
01:29:02 <kmeyer> ah
01:29:06 <psygnisfive> do i need to do magics?
01:29:08 <augustss> psygnisfive: let f x = x+1
01:29:17 <psygnisfive> ok. :D
01:29:27 <jeffwheeler> kmeyer: I figured it out by looking at Hackage, finding the package, looking at the description, and then observing the 'Modules' list
01:29:44 <psygnisfive> interesting
01:29:48 <psygnisfive> im disappointed!
01:30:08 <kmeyer> jeffwheeler: mhm
01:30:20 <kmeyer> the HUnit docs must be out of date
01:30:24 <kmeyer> (or the ones I'm looking at anyways)
01:30:28 <psygnisfive> this disappoints me about haskell patternmatching:
01:30:35 <jeffwheeler> kmeyer: yeah, that always frustrates me about Parsec
01:30:44 <psygnisfive> eq x x = True
01:30:47 <psygnisfive> is unacceptable
01:30:48 <pumpkin> augustss: got it working, with no copying :D
01:30:48 <psygnisfive> :(
01:30:56 <vixey> psygnisfive, of course
01:31:01 <pumpkin> augustss: and no unsafeness :)
01:31:01 <mauke> psygnisfive: meh
01:31:02 <augustss> psygnisfive: no repeated variables
01:31:02 <vixey> psygnisfive, That is absolutely impossible to implement
01:31:09 <kmeyer> heh
01:31:23 <psygnisfive> not with full fledged pattern matching!
01:31:31 <augustss> vixey: it would be possible the Eq on x
01:31:47 <vixey> psygnisfive, eq (\x -> x) (\x -> if there is an odd perfect number x else undefined)
01:31:58 <augustss> psygnisfive: it was a design choice when Haskell was made
01:32:04 <psygnisfive> i know :p
01:32:06 <psygnisfive> im just saying
01:32:16 <psygnisfive> itd be very sexy if it were possible
01:32:26 <mauke> psygnisfive: how often do you need that?
01:32:29 <psygnisfive> also deep pattern matching. but thats just me.
01:32:33 <augustss> psygnisfive: I prefer it this way
01:32:34 <psygnisfive> oh hush mauke
01:32:38 <psygnisfive> this isnt about need!
01:32:39 <vixey> psygnisfive, not sure what "full fledged pattern matching" is, but with functions it's not possible
01:32:43 <psygnisfive> noone NEEDS haskell :P
01:32:59 <jeffwheeler> I need it, so that I don't have to use Objective-C exclusively.
01:33:02 <jeffwheeler> ;)
01:33:12 * araujo points with the finger to psygnisfive "Haskell Needs You"
01:33:12 <mauke> I mean, I can count the number of times I've used an (==) constraint on parts of the same data structure on one hand
01:33:14 <psygnisfive> vixey: i suppose it depends on how you perceive functions to work i guess
01:33:33 <vixey> augustss, well there could also be a FirstOrder or Regular typeclass
01:33:41 <vixey> augustss, would be nice for generic programming..
01:33:52 <augustss> vixey: yes
01:33:56 <vixey> instance Regular typ => Eq typ where ...
01:33:56 <psygnisfive> mauke: sure i suppose but that was just a simple example
01:34:27 <augustss> psygnisfive: you'll just have to write eq x x' | x==x' = ...
01:34:52 <psygnisfive> i know dude i know
01:35:06 <jeffwheeler> The problem is that repeating the variables would require the vars to be Eq instances, which is absurd.
01:35:12 <psygnisfive> but itd still be cool.
01:35:14 <psygnisfive> like..
01:35:29 <mauke> jeffwheeler: not that absurd
01:35:32 <vixey> jeffwheeler, I agree kinda, but is matching on 0 absurd, because it requires a Num instanc?
01:35:57 <vixey> psygnisfive, regardless how cool it is.. did you understand why it's impossible?
01:36:12 <jeffwheeler> Both of you are correct, actually. I've changed my mind, already. :P
01:36:19 <psygnisfive> palindrome [x] ++ xs ++ [x] = palindrome xs
01:36:19 <psygnisfive> palindrome [x] = True
01:36:21 <psygnisfive> palindrome [] = True
01:36:23 <psygnisfive> palindrome _ = False
01:36:27 <psygnisfive> vixey: impossible in haskell, yes. i do.
01:36:38 <vixey> psygnisfive, no not saying that
01:36:51 <vixey> psygnisfive, like theoretically impossible.. not just hasn't been implemented
01:37:02 <psygnisfive> vixey its most certainly not theoretically impossible
01:37:17 <mauke> psygnisfive: write your own pattern matching
01:37:20 <vixey> psygnisfive, so what about my example:   eq (\x -> x) (\x -> if there is an odd perfect number x else undefined)
01:37:30 <augustss> vixey: but you could imagine intentional equality on functions.  It's just that in Haskell it would be a disaster.
01:37:48 <psygnisfive> im not even sure what thats supposed to mean, vixey
01:38:14 <jsn> psygnisfive: there is no such thing as equality on functions
01:38:32 <psygnisfive> jsn: says who?
01:38:33 <augustss> extensional equality
01:38:36 <psygnisfive> not mathematicians!
01:38:43 <jsn> psygnisfive: turing, goedel
01:38:49 <psygnisfive> i dont think so sir
01:38:50 <jsn> church
01:38:52 <jsn> curry
01:38:54 <jsn> kleene
01:38:56 <augustss> psygnisfive: we like it to be decidable
01:39:04 <vixey> psygnisfive, haskell would have to figure out if "there is an odd perfect number" is true or not to run my program there.....
01:39:12 <psygnisfive> decidability is overrated ;)
01:39:16 <psygnisfive> and also not turing complete.
01:39:18 <vixey> jsn, no need to appeal to authority, the proof is simple
01:39:20 <AirCastle> how do you know when an algorithm is isomorphic to another function? (just out of curiosity) .. or are we not talking algorithms here because haskell isn't procedural?
01:39:38 <jsn> vixey: aye -- he wanted to know who, though :)
01:39:42 <psygnisfive> anyway, haskell wouuldnt have to igure anything out vixey
01:39:46 <augustss> AirCastle: you have to prove it my some means
01:40:00 <psygnisfive> \x -> x is not identical to \x -> ...
01:40:07 <vixey> psygnisfive, still not following what I said then?
01:40:07 <psygnisfive> so they're not equal, in form.
01:40:13 <psygnisfive> perhaps not
01:40:23 <mauke> psygnisfive: is (\x -> x) identical to (\y -> y)?
01:40:26 <psygnisfive> but i think you're overthinking what im saying.
01:40:34 <augustss> psygnisfive: but if you take that point of view Haskell is no longer referentially transparent
01:40:47 <vixey> psygnisfive, oh do excuse me, I'll make sure not to give any thought to anything you say in future
01:40:53 <augustss> psygnisfive: And that certainly was a design goal
01:40:56 <psygnisfive> ahh well im not sure if i'd say that mauke. it depends on what you mean by identical i suppose.
01:40:58 <psygnisfive> i mean
01:41:17 <jsn> psygnisfive: they are equal over all inputs, though
01:41:18 <jeffwheeler> psygnisfive: you're the one defining it for us. :)
01:41:21 <ziman> that's quite useless equivalence :)
01:41:24 <psygnisfive> yes, they're equal functions
01:41:24 <AirCastle> what does it mean that decidability is not turing complete?  if it means a turing machine can't decide, then that's kind of the point isnt it.. or am i missing it
01:41:32 <psygnisfive> but im not talking about equal functions, jsn
01:41:42 <jsn> you're talking about equal values
01:41:45 <psygnisfive> no
01:41:50 <psygnisfive> im talking about equal patterns :P
01:41:52 <jeffwheeler> He's talking about Eq instances, right?
01:42:02 <mauke> jeffwheeler: I doubt that
01:42:11 <augustss> jeffwheeler: I don't think he knows what he's talking about :)
01:42:15 <pumpkin> AirCastle: " what does it mean that decidability is not turing complete?" not much, as far as I can see?
01:42:19 <vixey> AirCastle, not sure what you mean exactly
01:42:22 <jeffwheeler> augustss: I gathered that. :P
01:42:27 <vixey> lol
01:42:29 <jsn> psygnisfive: well, consider a function    foo a b
01:42:34 <psygnisfive> pumpkin, deciders are not TC
01:42:47 <jsn> and we want to have a pattern    foo x x = 7
01:43:10 <vixey> psygnisfive, back to reality for a moment:  It's perfectly reasonable and straightforward to embed a first order logic language in Haskell to do that sort of pattern matching
01:43:39 <jsn> this could only actually work if the signature is    foo :: (Eq a) => a -> a -> Int
01:43:39 <pumpkin> psygnisfive: in the sense that you don't need the full power of a turing machine to decide certain problems? that's true
01:43:50 <psygnisfive> no no pumpkin
01:43:56 <psygnisfive> a decider is a TM that always halts
01:43:57 <vixey> jsn, earlier I suggested alternatives to Eq
01:44:05 <jsn> vixey: like?
01:44:11 <pumpkin> psygnisfive: I know...
01:44:17 <psygnisfive> so its not turing complete
01:44:29 <psygnisfive> there are some machines that cannot be simulated by a decider
01:44:30 <vixey> but it's a bit weird for Eq instances (and Num instances) to pop out from a pattern match.. not sure if I like it or not
01:44:31 <jsn> vixey: num?
01:44:38 <AirCastle> maybe yoeu mean turning is not deciding- complete
01:44:40 <AirCastle> turing
01:44:49 <psygnisfive> .. what? lol
01:44:51 <vixey> AirCastle: I don't understand
01:44:53 <pumpkin> lol
01:45:01 <psygnisfive> anyway
01:45:02 <vixey> AirCastle: decidability of what? and so on..
01:45:20 <vixey> psygnisfive: did you catch my comment on embedding?
01:45:27 <psygnisfive> no sir
01:45:34 <vixey> please don't cal me sir
01:45:46 <psygnisfive> mam?
01:45:49 <psygnisfive> ma'am?*
01:46:08 <mauke> bot
01:46:20 <augustss> psygnisfive: In your hypothetical function equality, would these be equal? (\x -> x * x) vs (\x -> let y=x in y*x)
01:46:57 <psygnisfive> augustss: it depends on whether or not you want pattern matching to treat functions as data structures or not.
01:47:04 <mauke> (let f = (*) in \x -> f x x)
01:47:15 <jeffwheeler> I'm rather curious about the plausibility of allowing it while adding Eq instances. I don't see the problem with that . . .
01:47:28 <psygnisfive> i mean, by fiat just say pattern matching of that sort only works on non-lambdas and hey presto
01:47:31 <vixey> jeffwheeler, there's no problem with it, other than it's kind of ugly
01:47:32 <augustss> jeffwheeler: that would work fine.
01:47:33 <mauke> jeffwheeler: the problem becomes then where in the match you insert the (==) check
01:47:47 <oklopol> you talking about being able to check function equality in patterns of form (x, x)?
01:47:52 <psygnisfive> i mean, you cant check equality of function definitions like that anyway
01:47:54 <psygnisfive> oklo! :D
01:47:56 <vixey> oklopol, yes
01:48:02 <psygnisfive> okokoko?
01:48:20 <pumpkin> why not just define function equality in terms of being equal mappings from inputs to outputs?
01:48:22 <psygnisfive> anyway, like i said, it depends on what you mean to pattern match.
01:48:27 <augustss> mauke: I'd imagine you insert the == at the second occurrence
01:48:41 <vixey> psygnisfive: (repeat) "It's perfectly reasonable and straightforward to embed a first order logic language in Haskell to do that sort of pattern matching"
01:48:42 <psygnisfive> pumpkin: fine, YOU do the test on \x->x and \y->y then :)
01:48:51 <oklopol> well, you'd need to have quite an extensive proving lib, i would say things should change dramatically elsewhere too.
01:48:53 <AirCastle> decidability's problem is that it doesn't always halt, therefore a turing program that always halts isn't a decider, therefore the fact that it always halts does not make decidabilitiy not turing-complete... (maybe i don't understand, i'm not a math wizz)
01:49:02 <augustss> pumpkin: that is how function equality is defined.  but it's undecidable in general
01:49:05 <pumpkin> psygnisfive: I'm not saying it's decidable :P it just seems like the most useful definition, without getting into language-specific nuances
01:49:12 <pumpkin> ;)
01:49:19 <psygnisfive> sure and thats what the mathematicians do :P
01:49:26 <vixey> AirCastle, all makes sense until "decidabilitiy not turing-complete."
01:49:46 <psygnisfive> i think vixey is getting all hot and bothered over something that can be safely ignored
01:49:47 <augustss> pumpkin: yes, it's the right definition for function equality.
01:50:02 <pumpkin> :)
01:50:10 <psygnisfive> since you cant do \x->x == \y->y theres nothing new in doing what i suggested
01:50:11 <oklopol> i mean if you could check equality of functions, naturally you should be able to do it for infinite data structures too
01:50:13 <Lanjiao> hstringtemple failed:Text/StringTemplate/GenericStandard.hs:12:7:
01:50:15 <Lanjiao>     Could not find module `Data.Generics.Aliases':
01:50:16 <Lanjiao>       it is a member of package base-3.0.3.0, which is hidden
01:50:17 <psygnisfive> oklopol
01:50:21 <psygnisfive> to bring you slightly up to speed
01:50:23 <Lanjiao> some one know to resolve?
01:50:27 <augustss> pumpkin: And it's the one that Haskell has, sematically.  Which is why functions are not in Eq
01:50:28 <psygnisfive> i said it would be cool to have general patter matching
01:50:34 <psygnisfive> like foo x x = True
01:50:36 <psygnisfive> or something
01:50:37 <vixey> psygnisfive: I don't think you should make remarks like that
01:50:45 <oklopol> and stuff like sum(list)/length(list) should start working for infinite lists, the language should simply be made more math altogether.
01:50:51 <psygnisfive> vixey let me put it another way right
01:50:58 <psygnisfive> i can do what i mean in prolog.
01:51:10 <augustss> psygnisfive: It would be incredibly cool!  I agree.  It's just not possible in general without ruining Haskell. :)
01:51:12 <psygnisfive> foo(X,X) :- t.
01:51:17 <psygnisfive> this is valid prolog
01:51:23 <mauke> does prolog have functions?
01:51:32 <oklopol> it has procedures and unification
01:51:33 <vixey> psygnisfive: remember when I said: "It's perfectly reasonable and straightforward to embed a first order logic language in Haskell to do that sort of pattern matching"
01:51:36 <psygnisfive> no, but then, i did say we can define pattern matching over everything BUT functions
01:51:40 <oklopol> so essentially yes
01:51:50 <oklopol> just not the syntax for them
01:51:50 <vixey> psygnisfive: Do you think Prolog is a first order logic language?
01:52:04 <mauke> foo(foo,foo)?
01:52:22 <psygnisfive> well its an implementation of horn clauses
01:52:29 <vixey> I give up!
01:52:36 <vixey> You just aren't listening to me on purpose
01:52:38 <psygnisfive> and if im not mistaken prolog is a particular formulation of at least some of FOL
01:52:40 * oklopol leaves
01:53:07 <oklopol> also psygnisfive!
01:53:11 <psygnisfive> oko?
01:53:17 <oklopol> just returned yours
01:53:19 <oklopol> :)
01:53:19 <oklopol> ->
01:53:38 <psygnisfive> but vixey, i understand we could embed an FOL language
01:53:58 <psygnisfive> im not denying that or considering it trivial or anything
01:54:05 <pumpkin> well crap :P I've spent all this time trying to optimize my function using UArr and it's a lot slower :(
01:54:32 <psygnisfive> im just saying that it would be interesting to have some ability to do deeper pattern matching with functions
01:54:58 <mauke> http://www.itu.dk/people/mir/typesafepatterns.pdf
01:55:01 <psygnisfive> even if we cant pattern match lambdas
01:55:37 <augustss> psygnisfive: yeah, there are all kinds of interesting ways to extend pattern matching.  Haskell takes a rather simple view.
01:55:49 <kmeyer> thank you all for being so helpful and patient with me
01:55:54 <psygnisfive> augustss: i know.
01:56:07 <psygnisfive> i wasnt trying to start some big anything like i did
01:57:03 <augustss> psygnisfive: And things like 'foo x x' what considered when Haskell was designed.  It was a concious choice to keep pattern matching simple.
01:57:13 <augustss> s/what/was/
01:57:13 <psygnisfive> i know this :P
01:57:17 <augustss> :)
01:57:19 <psygnisfive> i was musing
01:57:20 <psygnisfive> out loud
01:57:35 <psygnisfive> i think im using that wrong..
01:57:37 <augustss> a dangerous thing :)
01:57:41 <psygnisfive> it seemed write when i typed that..
01:57:42 <psygnisfive> anyway
01:58:00 <psygnisfive> i was merely indulging in a flight of fancy
01:58:43 <kmeyer> what's haskell for "doesn't equal"?
01:58:47 <kmeyer>  /=, !=?
01:58:51 <psygnisfive>  /=
01:59:04 <kmeyer> thanks
01:59:10 <augustss> psygnisfive: I was involved in a language design where you could write patterns like [..x,y..].  It would iterate x,y over all adjecent elements of the list
01:59:10 <psygnisfive> my scanner seems to be alive
01:59:20 <pumpkin> I wonder why this UArr entropy is so much slower than my list-based one
01:59:22 <psygnisfive> a who wha?
01:59:45 <psygnisfive> i dont know what you mean iterate x,y over all adjacent elements of the list
02:00:03 <pumpkin> that looks neat
02:00:19 <pumpkin> sliding window of size 2?
02:00:37 <psygnisfive> do you mean like.. you could, say, map like that? like say, map f [...x...] = [...(f x)...]
02:00:37 <psygnisfive> ?
02:00:38 <augustss> psygnisfive: case foo of [..x,y..] -> rhs, would give you a list of results, evaluating rhs for all possible x,y
02:01:20 <augustss> And you could write case foo of [..x..y..] -> ... for even more variations
02:01:22 <psygnisfive> sounds interesting. thats bit more than i was thinking of. thats more mathemagical
02:01:25 <mauke> ooh, implicit multiworlds
02:01:50 <psygnisfive> and while i do so love me some mathemagic, i cant even begin to think of how i'd implement that
02:02:02 <psygnisfive> do you have any research on this? implementation stuff, etc?
02:02:13 <augustss> And you could write ~p for a pattern that matches when p doesn't match
02:02:23 <mauke> heh
02:02:30 <mauke> what if p binds variables?
02:02:39 <augustss> mauke: not allowed
02:02:44 <psygnisfive> augustss!
02:02:52 <psygnisfive> papers?
02:02:55 <psygnisfive> give?
02:02:58 <kmeyer> anyone familiar with how to assert that an error should occur when a given input is passed to a function with HUnit?
02:03:09 <augustss> psygnisfive: no, this was a proprietary language for a company
02:03:13 <psygnisfive> oh :(
02:03:21 <psygnisfive> was it successful?
02:03:54 <augustss> psygnisfive: No, the project got killed before it really took off, for political reasons.  But we had it all running.
02:04:20 <augustss> psygnisfive: The politics of the project was crazy. :)
02:04:35 <psygnisfive> also, you sound like you might know. any good refs on unification theory? i can build silly little binding systems, but true proper unification is.. beyond me, i'll say
02:05:00 <psygnisfive> tho ive heard that its a simple extension on binding
02:05:15 <augustss> psygnisfive: you mean regular unification?
02:05:19 <psygnisfive> yeah
02:05:46 <augustss> psygnisfive: Hmm, I learnt if from Alan Robinson's paper from the 60s.  But that's not a good way.
02:06:13 <augustss> I'm sure there must be some easy references
02:07:05 <augustss> It can be implemented in a few lines of Haskell after all
02:07:17 <pumpkin> I get the impression that it's not able to optimize/fuse anything with all this imperative-style code I'm doing on those MUArrs
02:07:24 <psygnisfive> oh? a few lines of haskell?
02:08:08 <intoverflow> *everything* can be implemented in a few lines of haskell
02:08:25 <AirCastle> or a few characters of J
02:08:31 <psygnisfive> is this true, intoverflow?!
02:08:35 <psygnisfive> maybe.. if there was a both
02:08:37 <psygnisfive> bot*
02:08:45 <psygnisfive> some sort of irc bot we could ask...
02:08:49 <augustss> psygnisfive: yes, for instance, take a look at Mark Jones type checker for Haskell in Haskell
02:08:53 <AirCastle> and by everything, did you mean everything all at once, or one at a time?
02:09:06 <pumpkin> @faq can haskell express everything in just a few lines?
02:09:06 <lambdabot> The answer is: Yes! Haskell can do that.
02:09:14 <augustss> intoverflow: or just one line
02:09:24 <psygnisfive> pumpkin: :)
02:09:28 <augustss> since Haskell allows long lines...
02:09:30 <pumpkin> :)
02:09:32 <psygnisfive> <3pumpkin
02:09:40 <psygnisfive> you're the only one who gets me *sniffle*
02:09:44 <pumpkin> lol
02:14:04 <kmeyer> I wish haskell list syntax allowed [a, b, c,]
02:14:18 <mauke> a: b: c: []
02:14:30 <vixey> why would you want to write [a, b, c,]?
02:14:44 <mauke> vixey: so every line ends with ,
02:14:51 <vixey> it's only 1 char different than [a, b, c] though
02:15:01 <Deewiant> just start every line with ,
02:15:03 <Deewiant> much easier
02:15:10 <kmeyer> Deewiant: what about the first line?
02:15:12 <mauke> Deewiant: [,a ,b ,c] is also a syntax error
02:15:14 <vixey> [ a
02:15:15 <vixey> , b
02:15:17 <vixey> , c
02:15:18 <vixey> ]
02:15:19 <lunabot>  b
02:15:21 <Deewiant> what vixey said
02:15:21 <kmeyer> I guess
02:15:23 <lunabot>  c
02:15:23 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
02:15:29 <psygnisfive> mauke: what does THAT matter?
02:15:38 <psygnisfive> thats.. weird
02:15:47 <mauke> huh?
02:15:52 <psygnisfive> and seems pointless
02:16:22 <pumpkin> @pl list
02:16:23 <lambdabot> list
02:16:29 <pumpkin> yeah, it's definitely pointless
02:16:50 <elbar> proof ;)
02:17:08 <psygnisfive> besides, just use lisp if you want your lines to end with the same characters
02:17:12 <psygnisfive> or something
02:19:31 <icqn> > 'a': ('b': ('c': []))
02:19:32 <lambdabot>   "abc"
02:22:07 <psygnisfive> lalala
02:22:13 <psygnisfive> *crickets*
02:22:31 * AirCastle never heard lalalal crickets
02:22:51 <sinelaw_> > 10+10
02:22:52 <lambdabot>   20
02:23:19 <sinelaw> > 10^100
02:23:20 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
02:23:23 <sinelaw> Google :)
02:23:33 <AirCastle> > googol
02:23:34 <lambdabot>   Not in scope: `googol'
02:23:42 <vixey> @@ www.(@run 10^100).com
02:23:44 <lambdabot>  www.  100000000000000000000000000000000000000000000000000000000000000000000000000....com
02:23:46 <sinelaw> > 10^(10^100)
02:23:53 <AirCastle> you broke it
02:23:59 <lambdabot>   mueval: Prelude.read: no parse
02:23:59 <lambdabot>  mueval: out of memory (requested 152043520 ...
02:24:01 <sinelaw> googolplex
02:24:06 <Deewiant> > googolplex
02:24:29 <AirCastle> > 1/0
02:24:36 <sinelaw> > 0/0
02:24:47 <sinelaw> someone please call 911
02:24:53 <pumpkin> oh no, you killed lambdabot
02:24:56 <psygnisfive> who runs lambdabot?
02:24:59 <pumpkin> Cale
02:25:06 <mauke> @bot
02:25:06 <lunabot>  :)
02:25:06 <pumpkin> I run pumpkinbot though
02:25:12 <psygnisfive> hm
02:25:14 <lambdabot> :)
02:25:14 <AirCastle> > 0/0
02:25:17 <jeltsch> Hi all, I switched to GNOME on one of my computers recently.  Now I’m looking for a Haskell-aware editor which integrates nicely into GNOME. gedit has too few features (missing space removal at end of line and automatic line breaks). GVim doesn’t support usual key bindings like marking text with Shift + cursor keys (at least I didn’t see how it could).  Any suggestions?
02:25:24 <lambdabot>   NaN
02:25:24 <psygnisfive> im not sure i like kale. its a funny looking vegetable.
02:25:31 <pumpkin> sounds like lambdabot is tired
02:25:36 <sinelaw> emacs.
02:25:39 <pumpkin> > scanl1 (+) [1,3..]
02:25:45 <mauke> jeltsch: usual keybindings are overrated
02:25:46 <vixey> jeltsch, not sure what haskell-aware means
02:25:48 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
02:25:55 <AirCastle> > 0^0
02:25:55 <lambdabot> vixey: You have 1 new message. '/msg lambdabot @messages' to read it.
02:25:58 <pumpkin> lambdabot is tired :(
02:26:00 <lambdabot>   1
02:26:04 <mauke> jeltsch: but you can make gvim do that, because that's how it works on windows by default
02:26:05 <jeltsch> vixey: Mostly syntax highlighting.
02:26:05 <Deewiant> jeltsch: GVim isn't supposed to support usual key bindings :-)
02:26:06 <pumpkin> did it lose an expensive mueval in the background?
02:26:26 <vixey> @messages
02:26:33 <jeltsch> mauke: I’m used to these keybindings and don’t want to change my habbits.
02:26:34 <lambdabot> mmorrow said 13h 17m 58s ago: i've got abssyn, free/bound vars, and a parser + pprinter for pisigma at http://moonpatio.com/repos/pisigma/. i've decided to use this as the interp frontend "core lang"
02:26:40 <vixey> lambdabot you already told me that
02:26:46 <lambdabot> Plugin `tell' failed with: thread killed
02:26:47 <pumpkin> it crashed, so it forgot :(
02:26:51 <vixey> lambdabot-- # broken POS as usual
02:27:05 <pumpkin> pumpkinbot to the rescue! ;)
02:27:08 <AirCastle> > x =1
02:27:16 <lambdabot>   <no location info>: parse error on input `='
02:27:28 <EvilTerran> AirCastle, lambdabot only does expressions, not bindings
02:27:41 <EvilTerran> although you can bind things locally with let...in...
02:28:42 <jeltsch> sinelaw: There is a lot of Haskell support for Emacs but it seems to conflict with my coding style. I like to insert blank lines in certain places, for example after a "class ... where" line. TAB is not working after the blank line, however I’d like it to just indent.
02:29:14 <AirCastle> > (2^.5)*(2^.5)
02:29:15 <lambdabot>   Not in scope: `^.'Not in scope: `^.'
02:29:30 <psygnisfive> wee haskell has order free binding in lets :D
02:29:30 <AirCastle> > (2^0.5)*(2^0.5)
02:29:31 <lambdabot>   Add a type signature
02:29:35 <czShadoW> jeltsch: I can reccomend you Open Komodo: http://www.openkomodo.com/
02:29:41 <EvilTerran> ?type (^)
02:29:43 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
02:29:50 <czShadoW> It's universal IDE.
02:29:59 <EvilTerran> > (2**0.5)*(2**0.5)
02:30:01 <lambdabot>   2.0000000000000004
02:30:02 <psygnisfive> czShadoW: just dont boil the ocean there ok
02:30:05 <EvilTerran> > (2**0.5)*(2**0.5) :: CReal
02:30:06 <lambdabot>   2.0
02:30:39 * AirCastle was hoping for something like 1.99999999999 :p
02:30:50 <EvilTerran> > (2**0.5)*(2**0.5) :: Float
02:30:52 <lambdabot>   1.9999999
02:30:55 <EvilTerran> there you go! :)
02:30:57 <pumpkin> :)
02:30:59 <AirCastle> ah:)
02:31:04 <pumpkin> not enough 9s though
02:31:08 <psygnisfive> czShadoW: its good to open the kimono and bit, monetize the paradigm across the enterprise, and all that stuff
02:31:12 <psygnisfive> net net, you know
02:31:13 <pumpkin> besides, we all know that 1.999999999... = 2
02:31:18 <psygnisfive> but really, dont try to boil the oceans
02:31:34 <EvilTerran> > (sqrt 2)^2 :: Double
02:31:36 <lambdabot>   2.0000000000000004
02:31:52 <pumpkin> > 6 / (pi^2) :: CReal
02:31:53 <lambdabot>   0.6079271018540266286632767792583658334262
02:32:21 <jeltsch> czShadoW: Open Komodo hasn’t Haskell support, does it?
02:32:25 <pumpkin> > sum . map (\x -> 1 / (x**2)) [1..]
02:32:26 <lambdabot>   Couldn't match expected type `a -> [a1]'
02:32:38 <pumpkin> > sum . map (\x -> 1 / (x**2)) $ take 100 [1..]
02:32:39 <lambdabot>   1.6349839001848923
02:32:43 <pumpkin> > sum . map (\x -> 1 / (x**2)) $ take 1000 [1..]
02:32:44 <lambdabot>   1.6439345666815615
02:32:51 <czShadoW> jeltsch: It has Haskell syntax highlight by default.
02:33:11 <pumpkin> > (pi^2) / 6 - (sum . map (\x -> 1 / (x**2)) $ take 1000 [1..]) :: CReal
02:33:11 <Deewiant> > sum . map (\x -> 1/(2^^x)) . enumFromTo 0 $ 100 :: CReal
02:33:14 <lambdabot>   1.9999999999999999999999999999992111390948
02:33:15 <jeltsch> czShadoW: Hmm, the website didn’t tell me that. Do you mean Komodo Edit or Komodo IDE?
02:33:26 <lambdabot>   thread killed
02:33:32 <pumpkin> whose was killed?
02:33:40 <Deewiant> yours
02:33:49 <pumpkin> :(
02:33:55 <Deewiant> > sum . map (\x -> 1/(2^^x)) . enumFromTo 0 $ 200 :: CReal
02:33:59 <lambdabot>   2.0
02:34:06 <pumpkin> > (pi^2) / 6 - (sum . map (\x -> 1 / (x**2)) $ take 100 [1..]) :: CReal
02:34:11 <lambdabot>   0.0099501666633335713952456684657014225356
02:34:12 <czShadoW> jeltsch: Komodo Edit is enough, I think.
02:34:20 <pumpkin> > (pi^2) / 6 - (sum . map (\x -> 1 / (x**2)) $ take 200 [1..]) :: CReal
02:34:24 <jeltsch> czShadoW: But it’s not Open Source, is it?
02:34:25 <vixey> @let run = ($())
02:34:25 <lambdabot>   Parse error
02:34:26 <AirCastle> is there anything on what 1.999... == 2 means for mathematical theory, or does it remain just a quirk?
02:34:35 <EvilTerran> > length . takeWhile (<2) . scanl (+) 0 $ [1/(2^x) | x <- [1..]]
02:34:35 <lambdabot>   thread killed
02:34:36 <jeltsch> czShadoW: Is Komodo KDE-based?
02:34:37 <vixey> @let run = flip ($) ()
02:34:38 <lambdabot>  Defined.
02:34:38 <pumpkin> boo
02:34:50 <vixey> > run ((+1) . (*2) . const 4)
02:34:50 <lambdabot>   thread killed
02:34:52 <EvilTerran> , length . takeWhile (<2) . scanl (+) 0 $ [1/(2^x) | x <- [1..]]
02:34:52 <vixey> > run ((+1) . (*2) . const 4)
02:34:52 <lambdabot>   9
02:34:55 <lambdabot>   9
02:34:59 <lunabot>  Killed.
02:35:07 <czShadoW> jeltsch: It's open source.
02:35:10 <augustss> AirCastle: it's just the way positional systems work.  some numbers have multiple representations
02:35:14 <EvilTerran> , scanl (+) 0 $ [1/(2^x) | x <- [1..]]
02:35:16 <lunabot>  [0.0,0.5,0.75,0.875,0.9375,0.96875,0.984375,0.9921875,0.99609375,0.998046...
02:35:17 <vixey> @let k = const
02:35:19 <lambdabot>  Defined.
02:35:20 <vixey> > run ((+1) . (*2) . k 4)
02:35:22 <lambdabot>       Ambiguous occurrence `k'
02:35:22 <lambdabot>      It could refer to either `L.k', defined a...
02:35:26 <vixey> ugh.....
02:35:35 <vixey> just pick one that typechecks at random.
02:35:37 <czShadoW> jeltsch: And it's written in Python with XUL.
02:35:46 <vixey> needs more AI
02:35:57 <pumpkin> , scanl (+) $ [1/(x**2) | x <- [1..]]
02:35:59 <lunabot>  luna: No instance for (GHC.Num.Num [t])
02:36:01 <pumpkin> , scanl1 (+) $ [1/(x**2) | x <- [1..]]
02:36:05 <lunabot>  [1.0,1.25,1.3611111111111112,1.4236111111111112,1.4636111111111112,1.4913...
02:36:09 <jeltsch> czShadoW: Does this mean, it works in a Firefox window or similar?
02:36:27 <pumpkin> > (pi^2) / 6 :: CReal
02:36:29 <lambdabot>   1.6449340668482264364724151666460251892189
02:36:43 <pumpkin> , drop 10 $ scanl1 (+) $ [1/(x**2) | x <- [1..]]
02:36:44 <lunabot>  [1.558032193976458,1.5649766384209025,1.5708937981842162,1.57599583900054...
02:36:55 <vixey> I need something to read
02:36:57 <EvilTerran> , length . takeWhile (<2) . scanl (+) 0 $ [1/(2^x) | x <- [0..]]
02:36:59 <lunabot>  54
02:37:06 <vixey> there aren't any new fp papers thougha
02:37:12 <czShadoW> jeltsch: No, it's just universal, not integrated.
02:37:15 <pumpkin> , drop 100 $ scanl1 (+) $ [1/(x**2) | x <- [1..]]
02:37:18 <lunabot>  [1.635081929789833,1.6351780466679566,1.63527230625887,1.6353647618801719...
02:37:29 <pumpkin> , drop 1000 $ scanl1 (+) $ [1/(x**2) | x <- [1..]]
02:37:31 <EvilTerran> ?type run
02:37:31 <lunabot>  [1.6439355646845573,1.6439365606965253,1.6439375547234176,1.6439385467711...
02:37:33 <lambdabot> forall b. (() -> b) -> b
02:37:40 <EvilTerran> er
02:37:49 <vixey> > run ((+1) . (*2) . k 4)
02:37:50 <lambdabot>       Ambiguous occurrence `k'
02:37:51 <lambdabot>      It could refer to either `L.k', defined a...
02:38:38 <mauke> @define
02:39:05 <AirCastle> if w is the first infinite ordinal, can you define a positional system with the number .99999... until the wth digit which is 8?
02:39:54 <vixey> AirCastle, I think of digits as a function N -> Digit
02:40:07 <vixey> AirCastle, but you defined a number by Ord -> Digit, why not?
02:40:23 <vixey> (w isn't in N)
02:40:51 <AirCastle> i don't know those terms but i guess the problem is that my number can't be translated to a real anyway?
02:40:55 <vixey> AirCastle, kind of reminds me of that silly hyperreals stuff (which they defined derivatives with)
02:41:07 <vixey> AirCastle, yeah seems more like a hyperreal than a real
02:41:10 <EvilTerran> ... wouldn't that allow for an uncountably long digit sequence?
02:42:35 <jeltsch> czShadoW: From the Komodo Edit install instructions: "Note, however, that the user who executes the license file will be the user who is licensed to use the software." I thought, this is Open Source?
02:42:45 <AirCastle> EvilTerran: hmm, is that another way of saying it's not really positional
02:43:10 <EvilTerran> AirCastle, well... i guess...
02:43:19 <vixey> AirCastle, not sure what positional means.. something other than N -> Digit?
02:43:19 <jeltsch> czShadoW: In addition, it seems quite complicated to set it up and it looks as if it would bring with it its own Python and Perl versions. Hmm, no Ubuntu packages?
02:43:36 <czShadoW> jeltsch: Yeah, Open Komodo (= Komodo Edit) is an open source, but Komodo IDE is proprietary.
02:43:45 * EvilTerran 's brain refuses to deal with uncountable infinities
02:43:52 <EvilTerran> so i'm getting a bit lost now =/
02:43:56 <vixey> w is countable
02:43:56 <pumpkin> mm_freak: you around?
02:44:01 <mm_freak> pumpkin
02:44:04 <AirCastle> well if the value of a digit is base^position*numeral, i assumed taht's what positional means.  but if it's uncountable you odn't know position
02:44:07 <jeltsch> czShadoW: But I read the Komodo Edit install instructions.
02:44:14 <pumpkin> in your email you referenced  lengthyComputation :: Monad m => (Progress -> m ()) -> m Result... how does that work? seems interesting
02:44:26 <pumpkin> email to cafe, that is
02:44:33 <mm_freak> pumpkin: i'll write an example
02:44:39 <pumpkin> thanks :)
02:45:15 <jeltsch> Hello all, are there no other common editors with Haskell support except Vim and Emacs?
02:45:33 <pumpkin> yi is common in certain circles!
02:45:38 <pumpkin> i.e., this one
02:45:46 <grul> if you're on os x; textmate
02:46:00 <jeltsch> grul: I’m on Linux.
02:46:05 <vixey> AirCastle, I don't see any problem with not being able to write down the number, exponentiation is defined for ordinals too
02:46:35 <jeltsch> pumpkin: yi can behave only Emacs- and Vim-like, can’t it?
02:46:52 <czShadoW> jeltsch: It's one installation script that does everything.
02:47:05 <jeltsch> czShadoW: But many dependencies.
02:47:45 <pumpkin> grul: textmate is nice, but its indentation on the haskell module is terrible
02:47:53 <jeltsch> czShadoW: So I have to keep track of all the scim* lib32* and whatever packages I have to uninstall in case I want to uninstall Komodo and all now unnecessary dependencies. :-(
02:47:56 <AirCastle> if it's uncountable then you can only get the digit by the axiom of choice, so what power do you rase the base to
02:48:45 <AirCastle> but if you said you can write it i guess you meant it's not uncountable..
02:48:49 <jeltsch> pumpkin: Emacs-like behaviour might be okay. Does it support normal indenting with TAB or does it try to be clever like Emacs’ Haskell mode (which is not clever enough for me :-) ).
02:49:01 <czShadoW> jeltsch: I'm sorry for this.
02:49:19 <jeltsch> pumpkin: With "it" I mean yi, of course.
02:49:37 <ulfdoz> *rofl* I'm smarter than my tool, so I must screw with a hammer!
02:49:41 <pumpkin> jeltsch: I've never even downloaded yi, let alone run it :)
02:49:52 <jeltsch> czShadoW: Any reason why there isn’t a Ubuntu package? Lack of Debian/Ubuntu developer interest? Komodo not being known enough?
02:50:52 <czShadoW> jeltsch: I don't know, I've just found this: http://community.activestate.com/forum/could-i-publish-komodo-edit-packages-ppa-repositoris-ubuntu
02:52:38 <kmeyer> anyone know if there's a better haskell editing plugin for vim?
02:52:50 <kmeyer> by default it doesn't do indentation (here, anyways)
02:53:14 <Deewiant> kmeyer: http://www.vim.org/scripts/script.php?script_id=2062
02:53:15 <n0nsense> hm...
02:53:21 <n0nsense> is import Gtk wrong?
02:53:39 <EvilTerran> yes
02:53:45 <n0nsense> ah... great
02:53:53 <n0nsense> and what do I need to use instead?
02:54:06 <n0nsense> (then I finally found the error)
02:54:09 <timebomb>  
02:54:11 <EvilTerran> the haddock page will give the module names that the package uses
02:54:49 <kmeyer> Deewiant: thanks
02:55:45 <EvilTerran> n0nsense, http://haskell.org/gtk2hs/docs/current/ suggests you may want Graphics.UI.Gtk, Graphics.SOE.Gtk, or Graphics.Rendering.Cairo, say
02:55:49 <EvilTerran> depending on what exactly you're doing
02:57:57 <n0nsense> EvilTerran: I think Graphics.UI.Gtk is the correct one
02:58:21 <n0nsense> (I try to compile hircules, it always tries to import Gtk)
02:58:28 <n0nsense> i did not change the code (yet)
02:59:29 <jeltsch> Building Yi failes with "Module `Graphics.UI.Gtk' does not export `Event'" when using a current development Gtk2Hs with GTK+ 2.14. Anyone knowing why?
03:04:58 <vixey> this is interesting, say something like (\(f :: t -> t) -> f) is in beta normal form, but if you abstract around it and apply it like (\f x -> f x) (\(f :: t -> t) -> f) it reduces back down to (\f x -> f x)
03:07:44 <mm_freak> pumpkin: http://hpaste.org/13823
03:07:53 <mm_freak> a bad example, but nevertheless an example =)
03:08:05 <pumpkin> mm_freak: thanks :)
03:10:05 <BrokenClockwork> Hey, I am trying to learn what interact is and how to use it, is there sth. in BONUS Tutorial?
03:10:47 <BONUS> yeah interact is explained there :]
03:10:48 <ziman> :t interact
03:10:49 <lambdabot> (String -> String) -> IO ()
03:11:16 <BrokenClockwork> ok then I will go for it
03:11:32 <BONUS> it's really simple, it's just a function that takes a String -> String function and makes an IO action that will take all the input, apply that function to it and print the result back out
03:11:50 <vixey> interact doesn't work for me
03:12:06 <BONUS> like if you do main = interact (map toUpper)
03:12:13 <vixey> (in ghci)
03:12:32 <BONUS> really? works for me.
03:12:32 <BONUS> hm
03:12:41 <BrokenClockwork> ok, I am supposed to write a palinedrome function (already done) and use it with interact
03:12:55 <BONUS> what's the type of your palindrome function
03:13:03 <BrokenClockwork> String -> Bool
03:13:19 <BONUS> you gotta make it to String -> String first
03:13:27 <BONUS> maybe call show on that boolean
03:13:56 <BONUS> or do something like foo xs = if isPalindrome xs then "YES ITS A PALINDROM" else "NO ITS NOT A PALINDROME"
03:14:04 <BrokenClockwork> ah yes
03:14:04 <BONUS> that nets you a String -> String function
03:14:19 <BONUS> and then you can just pass it to interact
03:15:03 <mauke> unlines . map foo . lines
03:15:38 <Badger> :t isPalindrome
03:15:39 <lambdabot> Not in scope: `isPalindrome'
03:16:24 <mm_freak> vixey: stdin shouldn't be exhausted
03:16:34 <mm_freak> if it is, you need to restart GHCi
03:16:54 <PeakerWork> When compiling glut, configure says "Checking for glut library... no" even though I have glut headers and libraries installed - any idea what configure is testing there?
03:16:59 <PeakerWork> (cabal install glut, that is)
03:20:17 <PeakerWork> ah, config.log is pretty detailed
03:28:16 <BrokenClockwork> Okay this is fun, our tutor wants us to use interact, which leads to compile Haskell truly, we never done this before and this isn't working on Windows without extra programmes, is it? :D
03:29:10 <PeakerWork> there's a bug then -- that if libglut fails to be found by configure, then it still builds libglut, but fails to put the right -l flags for it in the package
03:29:54 <PeakerWork> what trac should I report it to?
03:30:33 <mauke> BrokenClockwork: what extra programs?
03:31:19 <BrokenClockwork> Cygwin
03:31:30 <mauke> huh? why?
03:31:38 <BrokenClockwork> at least it was written in BONUS tutorial, however it seems to work without it
03:32:20 <mauke> "Hey! For the purposes of this chapter, I'm going to assume you're using a unix-y environment for learning Haskell. If you're in Windows, I'd suggest you download Cygwin, which is a Linux-like environment for Windows
03:32:55 <BONUS> yeah, if you're in windows, i suggest getting cygwin
03:32:56 <BrokenClockwork> this was what I meant
03:33:29 <maltem> surely you don't *need* cygwin to *run* ghc?
03:33:35 <BONUS> you don't need it
03:33:44 <BONUS> you can compile it in the windows commandline if you want
03:33:58 <jsn> maltem: well, without Bash, how do you run a program?
03:34:07 <BONUS> only you can't use unix pipes in windows, but they are used in the tutorial
03:34:10 <maltem> (of course, it's a different thing what you *want*)
03:34:12 <jsn> maltem: your prompt will be all messed up
03:34:24 <maltem> jsn: messed up?
03:34:32 <BONUS> jsn: what do you mean? you can use GHC and GHCI nicely in windows without any bash-like terminal
03:34:37 <BONUS> just the normal windows command-line
03:34:44 * PeakerWork wants a "cabal report <package> [bug description] -f<bug files to attach>"
03:35:01 <PeakerWork> I don't want to spend half an hour looking for where to report a bug that took me 5 minutes to find and fix :(
03:35:17 <Raevel> maybe you can fix it slower
03:36:13 <maltem> PeakerWork: The world should really have a universal bug tracker :)
03:37:18 <BrokenClockwork> anyway, when I run ghc as "$ ghc --make helloworld" it says: Could not find module 'hellworld'
03:37:33 <maltem> (or there should be a bug tracker on a textfile basis, so it could be integrated into a project's repository)
03:37:45 <PeakerWork> BrokenClockwork: hell's world
03:37:55 <BrokenClockwork> ^^
03:39:37 <paper_cc> BrokenClockwork: rename helloworld.hs Helloworld.hs && ghc --make Helloworld
03:39:40 <paper_cc> ?
03:39:42 <maltem> BrokenClockwork: That just means that it could not find the module. That shouldn't be related to using cygwin or not
03:39:53 <paper_cc> and "module Helloworld where"?
03:39:57 <mauke> meh
03:40:03 <mauke> ghc --make helloworld.hs
03:41:50 * paper_cc "man ghc"s away in frustration
03:42:49 <BrokenClockwork> okay, it still says's can't find file: Helloworld.hs , however all my .hs files are @ ../bin/
03:43:34 <maltem> BrokenClockwork: oh man, how shall the compiler know they are *there*?
03:43:55 <muc> hello
03:43:57 <BrokenClockwork> I don't know, tell me
03:44:02 <muc> salam
03:44:04 <muc> what
03:45:05 <maltem> BrokenClockwork: Are you familiar with the concepts of "file system hierarchy" and "working directory"?
03:45:18 <BrokenClockwork> I hope
03:46:22 <BrokenClockwork> ok, it's done
03:46:26 <BrokenClockwork> I used \ instead of /
03:46:51 <maltem> uh ok
03:47:36 <BrokenClockwork> :)
03:48:34 <kmeyer> is there a factorial function defined in Haskell?
03:49:10 <BONUS> no haha
03:49:19 <kmeyer> bummer :(
03:49:20 <BONUS> but there are lots of online resources about making a factorial function in haskell :]
03:49:25 <kmeyer> :D
03:49:26 <vixey> that would just take all the fun out of programming in haskell
03:49:30 <BONUS> you can do
03:49:35 <kmeyer> I know it's trivial to implement
03:49:37 <kmeyer> but still...
03:49:41 <Badger> http://en.wikipedia.org/wiki/Haskell
03:49:42 <vixey> by no means is it trivail
03:49:44 <Badger> right there :P
03:49:50 <mauke> fac n = product [1 .. n]
03:49:51 <arjanb> kmeyer: take one from here: http://www.willamette.edu/~fruehr/haskell/evolution.html
03:49:57 <BONUS> i can't imagine a world where factorial is already defined in haskell
03:50:10 <vixey> there are PhD thesis which work up pages and pages of theory just to define factorial...
03:50:47 <kmeyer> I mean it's pretty easy to write a simple tail-recursive factorial
03:50:47 <BrokenClockwork> oh christ, I really made exe-file with ghc
03:51:30 <Badger> BONUS: madness! :P
03:52:39 <vixey> @go evoluation haskell porgrammeng
03:52:48 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
03:52:48 <lambdabot> Title: The Evolution of a Haskell Programmer
03:53:42 <BONUS> haha
03:54:04 <Deewiant> fac n = product [2..n] -- performance-sensitive haskell programmer
03:54:34 <Choko> but it fails for fac 0 :)
03:54:44 <Deewiant> > product [2..0]
03:54:46 <lambdabot>   1
03:54:47 <mauke> no, it doesn't
03:54:48 <Deewiant> works fine
03:54:52 <Choko> \o/
03:55:24 <Choko> > product []
03:55:25 <lambdabot>   1
03:56:42 <Badger> > let fac n = product [2..n] in fac 10
03:56:43 <lambdabot>   3628800
03:58:30 <Badger> > let fac n = product [2..n] in fac 256
03:58:31 <lambdabot>   857817775342842654119082271681232625157781520279485619859655650377269452553...
03:59:04 <Badger> heh
03:59:06 <Badger> > let fac n = product [2..n] in fac pi
03:59:07 <lambdabot>   6.0
03:59:18 <czShadoW> > let fac n = product [2..n] in fac 1
03:59:19 <lambdabot>   1
03:59:26 <czShadoW> Hm, interesting.
04:00:03 <mm_freak> > let fac n = product [2..n] in fac 1/0
04:00:04 <lambdabot>   Infinity
04:01:53 <mm_freak> > 1 * (1/0) * undefined
04:01:55 <lambdabot>   * Exception: Prelude.undefined
04:02:02 <mm_freak> > (1/0) * 1 * undefined
04:02:04 <lambdabot>   * Exception: Prelude.undefined
04:02:12 <vixey> > 0 * undefined
04:02:13 <lambdabot>   * Exception: Prelude.undefined
04:02:18 <mm_freak> [0 .. 1/0]
04:02:27 <mm_freak> > [0 .. 1/0]
04:02:28 <lambdabot>   [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0...
04:02:37 <vixey> @src enumFromTo
04:02:38 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
04:02:52 <mm_freak> > (1/0) * (1/0) * undefined
04:02:54 <lambdabot>   * Exception: Prelude.undefined
04:03:04 <mauke> excuse me wtf r u doin
04:03:07 <mm_freak> how come it gives infinity?!
04:03:17 <mauke> > product [1..1] / 0
04:03:19 <lambdabot>   Infinity
04:03:25 <AirCastle> > 1/0
04:03:26 <mm_freak> d'oh!
04:03:26 <lambdabot>   Infinity
04:03:28 <mm_freak> lol
04:03:33 <mm_freak> operator precedence
04:03:42 <AirCastle> i thought 1/0 was supposed to be undefined and only n00bs called it infinity
04:03:44 <mm_freak> > let fac n = product [2..n] in fac (1/0)
04:03:47 <mm_freak> there you go
04:03:51 <mm_freak> and never end
04:03:56 <lambdabot>   mueval: Prelude.read: no parse
04:03:58 <mauke> AirCastle: no, it really is infinity
04:03:59 <mm_freak> and fall to the bottom with killed thread
04:04:02 <maltem> AirCastle: floating-point arithmetic is special
04:04:24 <mm_freak> well
04:04:32 <mm_freak> > 2 ** 10000000000
04:04:41 <kmeyer> Prelude> take 5 [(c, p) | p <- [0..], c <- [0..]]
04:04:41 <kmeyer> [(0,0),(1,0),(2,0),(3,0),(4,0)]
04:04:42 <BONUS> hmm
04:04:43 <kmeyer> what am I doing wrong here?
04:04:46 <maltem> AirCastle: (1 `div` 0 :: Integer) *is* undefined
04:04:46 <lambdabot>   Infinity
04:04:56 <BONUS> i dont get it, why is 1 / 0 infinity as opposed to minus infinity
04:04:58 <mauke> kmeyer: nothing
04:05:00 <mm_freak> kmeyer: nothing
04:05:05 <kmeyer> heh
04:05:06 <mm_freak> kmeyer: just a flaw in your thinking =)
04:05:09 <BONUS> it could equally be both of those
04:05:14 <mauke> > 1 / (-0)
04:05:15 <lambdabot>   -Infinity
04:05:24 <kmeyer> sorry, what am I doing wrong if I intend to get (0,0), (1,1)...?
04:05:24 <Badger> hah
04:05:28 <mauke> > (-1) / (-0)
04:05:29 <lambdabot>   Infinity
04:05:31 <BONUS> ah, its like that then
04:05:38 <BONUS> approaching from minus and from plus
04:05:39 <BONUS> kewl
04:05:42 <mm_freak> > [ (x,x) | x <- [0..] ]
04:05:44 <lambdabot>   [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11...
04:05:44 <maltem> > [ (x,x) | x <- [0..] ]
04:05:46 <lambdabot>   [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11...
04:05:47 <maltem> gnah
04:05:54 <kmeyer> ah.
04:05:56 <kmeyer> sorry :)
04:06:12 <BrokenClockwork> :t Char.toUpper
04:06:14 <lambdabot> Char -> Char
04:06:27 <mm_freak> @pl \x -> (x,x)
04:06:27 <lambdabot> join (,)
04:06:42 <mm_freak> > liftM (join (,)) [0..]
04:06:43 <lambdabot>   [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11...
04:07:12 <AirCastle> so the special case isn't floating points per se, but reals -- 1/0 in R is infinity?
04:08:05 <maltem> AirCastle: no, the special case really is floating points. Infinity is not an element of R
04:08:20 <arw> lim (1/x) with x->0 is infty.
04:08:28 <arw> 1/0 is just undefined :)
04:08:50 <maltem> AirCastle: The point with floating-points is this:
04:08:59 <timebomb> anyone here compiled the objc bindings with ghc 6.10.1?
04:08:59 <kmeyer> how do I extract a value out of a data type in ghci?
04:09:02 <BONUS> (haha the point)
04:09:09 <kmeyer> let foo = Blah bar baz
04:09:12 <timebomb> the history says there were compile fixes
04:09:16 <kmeyer> how do I get bar from foo?
04:09:24 <mauke> kmeyer: case foo of Blah bar baz -> bar
04:09:36 <kmeyer> thanks
04:09:37 <BONUS> let (Just x) = bar in x
04:09:42 <BONUS> where bar is some Maybe value
04:09:46 <mm_freak> i'd generalize the answer to "pattern matching"
04:10:00 <mm_freak> 'case' does pattern matching, but there are other ways to do it
04:10:06 <maltem> Due to rounding and data errors, when you see a 0, it may really have been 1e-20. So it wouldn't be handy to generally fail on 1/0
04:13:20 <AirCastle> maltem: hmm, interesting, although it's still arbitrary whether the failure case is defined as infinite or nan right?
04:13:43 <BrokenClockwork> http://hpaste.org/13825 so there is a type error, they want String -> IO instead of IO()
04:13:51 <BrokenClockwork> but I don't get the idea how to modify it
04:14:03 <mauke> BrokenClockwork: remove the s
04:14:10 <Deewiant> and the getLine
04:15:16 <BrokenClockwork> well, it compiles but it doesn't work
04:15:28 <mauke> how does it not work?
04:15:30 <maltem> AirCastle: you get plus/minus Infinity from (x/0) if (x /= 0), and you get NaN from other bad calculations
04:15:31 <BrokenClockwork> I run my programme, and on every input nothing happens
04:15:39 <mauke> because the input isn't done yet
04:15:47 <mauke> how can it check the input without seeing the end?
04:15:52 <maltem> AirCastle: that is, 0/0, Inf/Inf, and the like
04:16:03 <BrokenClockwork> that will be the point
04:16:16 <BrokenClockwork> still don't get it how to realize
04:17:06 <AirCastle> maltem: ok. i guess it's definietly useful to distinguish.  i guess the point is that Inf is actually a symbol for 'something unknown but relaly really big'
04:17:09 <Deewiant> BrokenClockwork: interact applies the function to the whole input, not on each line which is probably what you want
04:17:21 <BrokenClockwork> right
04:17:31 <maltem> BrokenClockwork: if you're bitten by buffering, on unix the end-of-input key is Ctrl-d; not sure about the Windows equivalent
04:17:32 <BrokenClockwork> however we are supposed to use interac
04:17:33 <AirCastle> maltem: unless Inf can be worked with and has some properties like inf+1=inf or something.
04:17:38 <Deewiant> maltem: Ctrl-z
04:17:59 <maltem> Deewiant: good to know :)
04:18:35 <maltem> AirCastle: it does have that property, because it's consistent with the interpretation "something unknown but really big" :)
04:19:14 <AirCastle> haha, true, it is consistent
04:19:45 <AirCastle> > 1/Inf
04:19:46 <lambdabot>   Not in scope: data constructor `Inf'
04:19:53 <AirCastle> > 1/Infinity
04:19:54 <lambdabot>   Not in scope: data constructor `Infinity'
04:20:09 <Deewiant> > 1/ (1/0)
04:20:11 <lambdabot>   0.0
04:20:42 <BrokenClockwork> :t interact
04:20:43 <lambdabot> (String -> String) -> IO ()
04:20:44 <AirCastle> was that a result of doing 1/inf or was it an algebraic solving?
04:20:53 <Deewiant> result
04:22:39 <PeakerWork> dcoutts: ping
04:23:01 <maltem> AirCastle: You see, a floating-point +0 just means, "something really small, possibly 0, but there's a good chance of it being positive too"
04:23:06 <AirCastle> i thnik it still must be significant though, somehow, that 'bigger than 10e308 but unknown' is not the same as 'bigger than any integer'
04:24:20 * AirCastle forgets whether integers can be infinite
04:26:43 <AirCastle> wiki says it's a countably infinite set, but i dno't know if that means a member can be infinite
04:28:03 <AirCastle> hmm. suffice it to say, 'bigger than 10e308 but unknown' is not the same as 'bigger than 10egoogolplex'
04:31:04 <cnwdup> http://hpaste.org/13826 How can I use (.) the way I defined (<.>) on Modifiers using standard classes like Functor? I think it's possible, but I can't figure out how.
04:31:41 <AirCastle> but since floating point arithmetic itself has no use for its own size limit, i guess within its arithmetic there is no meaningful distinction between bigger than 10e308 and actual infinity
04:32:01 <AirCastle> it's just an artifact of precision limitation which is metaphysical to it
04:32:05 * AirCastle ok shuts up :)
04:34:43 <rdst> hello
04:34:56 <rdst> can anybody help me with lambdabot?
04:38:09 <vixey> rdst, well maybe...
04:38:22 <vixey> rdst, what aspect? I don't know much but I have looked at it before
04:38:41 <rdst> vixey: is says "Terminated" on any "> ..." expression
04:38:45 <rdst> *it says
04:39:03 <vixey> hm....... sorry that's one thing I have no idea about
04:44:56 <CakeProphet> > terminate verily
04:44:58 <lambdabot>   Not in scope: `terminate'Not in scope: `verily'
04:46:00 <vixey> @w80 verily
04:46:01 <lambdabot> *** "verily" wn "WordNet (r) 2.0"
04:46:01 <lambdabot> verily
04:46:01 <lambdabot>      adv 1: truly or confidentially; "I verily think so"
04:46:01 <lambdabot>      2: in truth; beyond doubt or question; "trust in the Lord...and
04:46:01 <lambdabot>         verily thou shalt be fed"- Ps 37:3
04:50:16 <CakeProphet> ...so why is there already Windows 7
04:51:05 <CakeProphet> Microsoft is having a very hard time keeping a steady development cycle /and/ a sensible naming convention.
04:51:38 <kmeyer> lazy eval is magic
04:52:00 <vixey> something like
04:52:17 <mauke> @src fix
04:52:18 <lambdabot> fix f = let x = f x in x
04:52:30 <vixey> [[ f ]] = [[ (\x -> f [[ x ]]) ]]
04:52:31 <AirCastle> finding prime numbers in haskell looks like sql to me.  therefore haskell == magic. (no, i don't know haskell at all)
04:52:31 <vixey> is the same as
04:52:33 <EvilTerran> CakeProphet, clearly, 7 > 98
04:52:43 <vixey> [[ f ]] = f $ (\f x -> [[ f [[ x ]] ]])
04:52:44 <vixey> ?
04:55:37 <EvilTerran> ?type flip (id >=>)
04:55:38 <lambdabot> forall (m :: * -> *) b c. (Monad m) => m b -> (b -> m c) -> m c
04:55:42 <EvilTerran> ?type id >=> id
04:55:43 <lambdabot> forall (m :: * -> *) c. (Monad m) => m (m c) -> m c
04:55:46 <vixey> If you have a closed lambda term (but you're not allowed to look at it, like it's given as a variable 'f' or whatever), and its type
04:56:08 * EvilTerran ponders trying to dis/prove that those're >>= and join respectively
04:56:29 <EvilTerran> (or are the types enough?)
04:56:43 <vixey> EvilTerran, *handwave*  by parametricity and that they're both composed from functions
04:56:46 <EvilTerran> > (id >=> id) [[1,2],[3,4]]
04:56:47 <vixey> from total*
04:56:48 <lambdabot>   [1,2,3,4]
04:56:58 <EvilTerran> vixey, that's what i was thinking :P
04:57:20 <EvilTerran> shouldn't be too hard to prove algebraically from the definition of >=>, though
04:57:23 <vixey> EvilTerran would be really cool to make it formal
04:57:36 <vixey> yeah unfolding would be easy but I bet parametricty works in general
04:57:43 <vixey> just .. don't really know how
04:58:04 <vixey> @free m (m c) -> m c
04:58:04 <lambdabot> Extra stuff at end of line
04:58:07 <vixey> @free join :: m (m c) -> m c
04:58:07 <lambdabot> Extra stuff at end of line
04:58:08 <EvilTerran> (f >=> g) x = f x >>= g
04:58:23 <vixey> @free join :: (e -> (e -> c)) -> (e -> c)
04:58:23 <lambdabot> (forall x. g . h x = k (f x) . f) => g . join h = join k . f
04:58:52 <EvilTerran> (id >=> id) x = id x >>= id = x >>= id; .'. id >=> id = (>>= id) = join
04:59:32 <vixey> oh
04:59:49 <vixey> the formulation from Wadler doesn't handle quantifying over stuff like * -> * does it?
04:59:58 <vixey> I wonder if adding that is nontrivial
05:00:33 <EvilTerran> flip (id >=>) = flip (\f -> id >=> f) = flip (\f x -> (id >=> f) x) = \x f -> (id >=> f) x = \x f -> id x >>= f = \x f -> x >>= f = (>>=)
05:00:35 <EvilTerran> QED :)
05:01:08 <itewsh> hello
05:01:54 <CakeProphet> > let primes = 2:(filter (\n   -> all (not . (\p n `mod` p == 0)) (takeWhile (\p -> p*p <= n) primes) [3,5..]) in primes
05:01:54 <lambdabot>   <no location info>: parse error on input ``'
05:01:56 <EvilTerran> so (return,(>=>)) is *another* way of defining monads
05:02:07 <EvilTerran> CakeProphet, you forgot a -> on a lambda there
05:02:23 <CakeProphet> > let primes = 2:(filter (\n   -> all (not . (\p -> n `mod` p == 0)) (takeWhile (\p -> p*p <= n) primes) [3,5..]) in primes
05:02:24 <lambdabot>   <no location info>: parse error on input `in'
05:02:24 <CakeProphet> ah, thanks.
05:02:32 <CakeProphet> paren error?
05:02:41 <EvilTerran> probably :P
05:02:56 <CakeProphet> > let primes = 2:(filter (\n   -> all (not . (\p -> n `mod` p == 0)) (takeWhile (\p -> p*p <= n) primes) [3,5..])) in primes
05:02:57 <lambdabot>   Couldn't match expected type `[t] -> Bool'
05:02:59 <CakeProphet> ...
05:03:02 <CakeProphet> ffffffff
05:03:07 <Raevel> -_-
05:03:20 <vixey> :t (>=>)
05:03:21 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
05:03:23 <vixey> :t (>)
05:03:24 <lambdabot> forall a. (Ord a) => a -> a -> Bool
05:03:25 <vixey> :t (.)
05:03:26 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
05:03:37 <vixey> (id,(.)) is a monad I guess
05:03:51 <vixey> or flip (.)
05:05:01 <CakeProphet> > let primes = 2:(filter (\n   -> all (not . (\p -> n `mod` p == 0)) (takeWhile (\p -> p*p <= n) primes)) [3,5..]) in primes
05:05:03 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
05:05:10 <Raevel> i think lambdabot has amnesia
05:05:11 <EvilTerran> > nubBy(((==0).).flip mod)[2..]
05:05:13 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
05:05:15 <Raevel> @users #haskell
05:05:15 <lambdabot> Maximum users seen in #haskell: 610, currently: 610 (100.0%), active: 12 (2.0%)
05:05:16 <CakeProphet> pesky parenthesis.
05:05:33 <CakeProphet> EvilTerran:  pah, you were just waiting to use that one.
05:05:36 <EvilTerran> Raevel, she does tend to forget things when she crashes, yeah =/
05:05:48 <EvilTerran> CakeProphet, eh, it's a classic :)
05:06:00 <CakeProphet> odd numbers would be more efficient.
05:06:06 <LeoD> :t nubBy
05:06:06 <EvilTerran> only by a constant factor
05:06:07 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
05:06:26 <CakeProphet> > 2:nubBy(((==0).).flip mod) [3,5..]
05:06:28 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
05:06:59 <EvilTerran> odd, non-divisible-by-three numbers would be more efficient too
05:07:12 <EvilTerran> you've got to draw the line somewhere, and i choose to do so as soon as possible :P
05:07:19 <CakeProphet> rofl. yeah.
05:07:30 <CakeProphet> I'm not entirely sure what nubBy does though.
05:07:30 <AirCastle> you don't have to draw the line somewhere, you'd just end up with the seive method :)
05:07:33 <CakeProphet> I know what nub does
05:07:36 <CakeProphet> but not... nubBy
05:07:41 <EvilTerran> ?src nubBy
05:07:41 <lambdabot> nubBy eq []             =  []
05:07:41 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
05:07:59 <EvilTerran> the use of it in that primes method is abusing it slightly
05:08:14 <AirCastle> http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes <- not drawing the line
05:08:20 <EvilTerran> as its "eq" parameter is intended to be an equivalence relation
05:08:22 <CakeProphet> I think any use of nubBy is probably abuse of nubBy
05:08:23 * AirCastle wonders what that looks like in haskell
05:08:39 <EvilTerran> CakeProphet, not something like "nubBy ((==) `on` snd)", say
05:08:54 <CakeProphet> bah, I always forget what on does
05:08:56 <CakeProphet> @src on
05:08:56 <lambdabot> (*) `on` f = \x y -> f x * f y
05:09:06 <CakeProphet> right
05:09:45 <CakeProphet> anything that doesn't use some form of equality is going to give you weird results.
05:09:58 <EvilTerran> exactly; it's expecting an equivalence relation
05:10:40 <EvilTerran> (transitive, reflexive, and symmetric)
05:11:29 <CakeProphet> EvilTerran:  I'm still trying to understand the FunctorOf thing.
05:11:43 <CakeProphet> so that I too can do crazy typeclass magic.
05:20:54 <tibbe> is it at all possible to write a function :: MonadTrans t => t m a -> t IO a? i.e. which additional constrains are needed?
05:21:14 <tibbe> It looks like some kind of liftIO on the inner monad
05:22:14 <devilx0> what's your mean?
05:22:31 <vixey> what's m?
05:22:56 <paolino> a monad from the contsxt
05:22:57 <tibbe> vixey: a monad
05:23:05 <vixey> but what does m mean?
05:23:25 <tibbe> vixey: so it can be any monad so I guess it's not possible to write such a function
05:23:41 <vixey> I think so because there is no  m a -> a  function
05:23:44 <tibbe> vixey: because we need a run function
05:23:49 <maltem> tibbe: liftIO would be the other direction
05:24:08 <tibbe> maltem: right, that's why I asked, it looked so similar to liftIO
05:24:14 <devilx0> This is your understanding of it
05:24:18 <maltem> ah ok
05:24:31 <tibbe> perhaps I can define a new type class for all monads which can be run i.e. have f :: m a -> a
05:25:04 <vixey> tibbe, but then m = IO?
05:25:23 <vixey> so why not a class for m a -> IO a
05:25:26 <tibbe> vixey: what do you mean: I can get it into IO with return (run m) no?
05:25:29 <maltem> tibbe: you won't find many monads such that f takes no extra parameter I think
05:25:40 <vixey> there's no way to write IO a -> a, but you can write IO a -> IO a
05:25:45 <tibbe> maltem: right, it has an extra parameter in my case
05:26:01 <AirCastle> is it just me or is http://www.cse.unsw.edu.au/~dons/code/lambdabot/State/quote just a bunch of characters that aren't even in a language
05:26:02 <tibbe> in my case m is a parser monad (e.g. a state monad)
05:26:42 <vixey> AirCastle, maybe it's a gzip or something idk
05:26:57 <tibbe> so my function is something like (String -> m a) -> IO a
05:27:20 <tibbe> :t lift
05:27:22 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
05:27:38 <vixey> :t lift . lift
05:27:40 <lambdabot> forall (t :: (* -> *) -> * -> *) (m :: * -> *) a (t1 :: (* -> *) -> * -> *). (Monad m, MonadTrans t1, Monad (t1 m), MonadTrans t) => m a -> t (t1 m) a
05:27:55 <Axman6> AirCastle: file quote
05:27:56 <Axman6> quote: gzip compressed data, from Unix
05:28:07 <Axman6> good call vixey
05:31:13 <vixey> @hylo
05:31:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:34:06 <paolino> @where incoherentinstances
05:34:06 <lambdabot> I know nothing about incoherentinstances.
05:35:25 <paolino> lambdabot: so do I :)
05:51:49 <dcoutts> PeakerWork: pong
05:56:26 <PeakerWork> dcoutts: are the bugs I opened in cabal-install's trac appropriate there?
05:56:49 * dcoutts checks
05:57:54 <dcoutts> PeakerWork: the one about GLUT is not, you need to report that to the HOpenGL maintainer, who I assume also maintains GLUT
05:58:09 <dcoutts> PeakerWork: as for reporting bugs via cabal-install, I think that'll never happen
05:58:26 <dcoutts> PeakerWork: however packages can now and should use a bug-reports: $URL in their ~/.cabal files
05:58:38 <dcoutts> and cabal list should tell you the bug report url
05:59:13 <PeakerWork> dcoutts: thanks
05:59:35 <PeakerWork> having report-bug could be real nice though, encouraging people to not be lazy about it :)
06:00:17 <dcoutts> PeakerWork: the GLUT package lists a maintainer, I suggest you email him and cc it to the libraries list
06:00:37 <PeakerWork> what's the lib list?
06:01:58 <dcoutts> PeakerWork: libraries@haskell.org, perhaps use haskell-cafe instead
06:02:03 * vixey hopes they use TeXmacs instead of xemacs for Epigram 2s editor
06:02:17 <SamB_XP> vixey: what the ???
06:02:17 <lambdabot> SamB_XP: You have 1 new message. '/msg lambdabot @messages' to read it.
06:02:26 <SamB_XP> @messages
06:02:26 <lambdabot> gwern said 15h 38m 48s ago: re long filenames in errors - with ghc 6.10 hint, the temp files aren't used at all (it was just a hack around a 6.8 bug) so I regard it as a moot issue not worth
06:02:26 <lambdabot> fixing
06:02:34 <vixey> lol SamB you are always freaking out
06:02:45 <SamB_XP> vixey: texmacs?
06:14:30 <mm_freak> @src tail
06:14:31 <lambdabot> tail (_:xs) = xs
06:14:31 <lambdabot> tail []     = undefined
06:15:01 <grul> @src (.)
06:15:01 <lambdabot> (f . g) x = f (g x)
06:27:47 <vixey> it is terribly painful trying to think of the right primitives for a language
06:28:41 <EvilTerran> vixey, amen to that
06:28:54 <esap> Adjunctions are a good primitive
06:29:09 * vixey has to look up adjunctions
06:29:32 * EvilTerran too
06:30:07 <vixey> there is a catsters video on it
06:30:27 * EvilTerran tries to not get distracted by this fact
06:31:28 <esap> The reason adjunctions are good for language primitives is because it's possible to represent almost any category theory construction using adjunctions
06:32:07 <esap> for example, limits can be represented with adjunctions
06:35:25 <jpcooper> what is an adjunction in the context of programming languages?
06:36:13 <EvilTerran> jpcooper, EVERYTHING! 8D
06:36:18 <EvilTerran> just like everything else in category theory :P
06:36:22 <dublpaws> could someone suggest a good read regarding the wonders of partial application?
06:37:21 <vixey> lol
06:37:52 <PHO_> Yay. I've got to managed to update pkgsrc-wip/ghc to GHC 6.10.1
06:38:05 <PHO_> powerpc-apple-darwin is supported as well as *-*-i386
06:38:29 <esap> jpcooper: It's a bit difficult to explain, but one way to connect it to a concrete programming language terminology would be to say that it's a very general way of describing an interface between two pieces of code. Basically every adjunction represents a way to pass some (piece of data) across that interface.
06:39:42 <dublpaws> sounds like a monad for architecture
06:39:51 <jpcooper> okauy
06:40:16 <esap> jpcooper: for example, there is an adjunction  (A x -) -| (A=> -), which can be thought of as the primitive that introduces functions.
06:41:31 <jpcooper> esap, I don't understand the notation. I think I'll look at some papers on this
06:42:44 <esap> jpcooper: So the interface in that example is the data 'A', which represents the type of the input of the function. A=>-  is partially applied function arrow (at type level). Basically   if you have f :: Integer -> Integer, it's the part  "Integer ->"
06:42:59 <jpcooper> okay
06:43:34 <vixey> and A x B is the product like (A,B)?
06:43:48 <esap> jpcooper: And "A x -" is product (pairs)
06:45:50 <dublpaws> :t (-|)
06:45:51 <lambdabot> forall a b c. (a -> b) -> Strategy b -> (b -> c) -> a -> c
06:46:39 <esap> So what the adjunction does, it represents a _bijection_    A x B -> C  =~=  A -> (B => C). This bijection is in category theory usually written as Hom(AxB,C) =~= Hom(A, B=>C). The bijection has 'curry :: ((a,b) -> c) -> a -> (b -> c)' as one direction.
06:46:44 <timebomb> how do i enable autoindentation in yi?
06:47:08 <esap> jpcooper: and 'uncurry' as the other direction.
06:47:24 <jpcooper> yes
06:48:07 * EvilTerran wonders where to find a good set of axioms for equational reasoning in propositional logic
06:49:26 <EvilTerran> seeing as i've gone and left the book on equational reasoning back at uni
06:50:39 <jpcooper> EvilTerran, are you in Glasgow?
06:51:20 <EvilTerran> geographically, yes
06:51:53 <jpcooper> ahah
06:52:03 * jpcooper is back to Glasgow University tomorrow
06:52:17 <jpcooper> do you go to Edinburgh or something?
06:53:20 <atom> @src filter
06:53:21 <lambdabot> filter _ []     = []
06:53:21 <lambdabot> filter p (x:xs)
06:53:21 <lambdabot>     | p x       = x : filter p xs
06:53:21 <lambdabot>     | otherwise = filter p xs
06:53:32 <EvilTerran> jpcooper, of those two options... something :P
06:53:40 <jpcooper> alright
06:53:42 <EvilTerran> (oxford, in particular)
06:53:50 <jpcooper> hah
06:54:05 <jpcooper> wait a minute. Are you the person I met at the Go club a couple of years ago?
06:54:10 <EvilTerran> erm
06:54:39 <EvilTerran> i've been to the glasgow uni go club, so quite possibly
06:55:00 <jpcooper> yes, I remember now. I believe that you had long hair and were just about to leave for Oxford
06:55:15 <EvilTerran> that's me :)
06:55:32 <EvilTerran> man, the internet is WEIRD
06:55:33 <jpcooper> haha
06:55:35 <jpcooper> what a coincidence
06:56:22 <jpcooper> I think you were learning Perl at the time. tsk
06:57:02 <vixey> EvilTerran, prop degeneracy is usually enough:forall P, P = True \/ P = False
06:57:56 <EvilTerran> jpcooper, don't worry, i've learnt the errors of my ways ;)
06:58:25 <PeakerWork> Did anyone write a GUI library around hscurses?
06:58:26 <EvilTerran> i abandoned perl when i tried to write a webpage scraper in it, wrote something long and confusing that didn't work, then wrote something in haskell that was shorter, clearer, and worked first time
06:58:52 <EvilTerran> even tho i was less familiar with haskell, and perl's meant to be good at text processing
06:59:02 <PeakerWork> That's because Perl is *#*$@ :-)
06:59:36 <PeakerWork> Learning Haskell is harder than learning other stuff...
06:59:36 <mauke> what modules did you use?
07:00:30 <asgaroth> PeakerWork: That last few characters in your statement are probably valid perl code though :)
07:00:44 <asgaroth> (the *#*$@)
07:00:48 <mauke> they are
07:00:49 <PeakerWork> Yeah :-)
07:00:56 <mauke> they're probably also valid haskell code
07:01:37 <asgaroth> s/valid perl code/common perl code/
07:01:40 <mauke> > let  _ *#*$@ _ = 42 in  a *#*$@ b
07:01:41 <lambdabot>   42
07:01:50 <mauke> definitely not common
07:01:57 <mauke> you'd never multiply a symbol by something
07:02:21 <asgaroth> Maybe not that exact expression, but something similarly cryptic and unreadable
07:02:29 <mauke> no
07:02:54 <mauke> perl code isn't unreadable
07:03:11 <PeakerWork> mauke: Perl's standard library is unreadable
07:03:17 <mauke> how so?
07:03:26 <PeakerWork> mauke: I tried to read it, and that's my opinion :-)
07:03:43 <PeakerWork> Python's standard library is also unreadable and crappily written, in Pythonic standards, but its far more readable than that of Perl, IMO
07:03:49 <mauke> by "standard library", do you mean the set of modules that ships with perl?
07:03:52 <PeakerWork> mauke: Yeah
07:03:55 <mauke> meh
07:04:07 <mauke> I'm not surprised
07:04:27 <mauke> parts of it came from perl4
07:04:40 <mauke> some of it is still compatible with 5.004 or 5.005
07:05:47 <PeakerWork> mauke: http://blog.slickedit.com/?p=162
07:06:26 <vixey> Python to Perl and Ruby
07:06:33 <vixey> ... it's almost possible to tell the difference
07:06:59 <mauke> PeakerWork: you called "C/C++" a language. your opinion is invalid.
07:07:18 <chrisdone> preflex: be PoppaVic
07:07:19 <preflex>  I said what I meant: you expect others to save you and ridicule me, (which is fine), but now pick yer GOD.
07:07:20 <vixey> why people say "C/C++"?
07:07:25 <PeakerWork> mauke: Where?
07:07:33 <atom> mauke: by the same logic, English is not a language because it isn't well-defined.
07:07:34 <Medea> Hello, I have a question. Given http://hpaste.org/13828 is it possible to have GHCi evaluate "StateOf (State s)", yielding s?
07:07:34 <chrisdone> how is C/C++ formed?
07:07:41 <mauke> "Heck, I rank on C/C++ and it’s the language I use most "
07:07:42 <PeakerWork> vixey: because there are some similarities between C and C++
07:07:58 <Botje> because C++ is C with classes :]
07:07:58 <mauke> atom: what?
07:08:00 <PeakerWork> mauke: Where/when is that from?
07:08:10 <mauke> PeakerWork: from the link you gave me
07:08:16 <PeakerWork> mauke: I didn't write that
07:08:20 <vixey> Medea, no
07:08:22 <PeakerWork> mauke: I just quickly found that in google
07:08:24 <Botje> Medea: don't think so, StateOf is a type
07:08:27 <mauke> PeakerWork: sorry
07:08:28 <atom> mauke: the "you called "C/C++" a language"
07:08:33 <atom> it is a language.
07:08:41 <mauke> atom: but it's not the language you think it is
07:08:47 <Medea> Botje: StateOf is really a type-indexed function
07:08:50 <vixey> C/C++ is a made up language just to confuse people that write C/C++
07:08:57 <EvilTerran> vixey, er... maybe "axiom" was the wrong word, if (forall p. p || !p) is the only strictly necessary axiom
07:09:02 <atom> oh.
07:09:04 * EvilTerran intends to have more connectives than that
07:09:08 <Botje> oeps
07:09:11 <mauke> atom: you're talking to the first and only implementor of C/C++
07:09:12 <Botje> don't know about those yet
07:09:30 <Botje> will read a bit first, then
07:09:32 <Medea> vixey: sadness. is there no workaround, for example defining a dummy function?
07:09:38 <vixey> EvilTerran, I said P = True \/ P = False though
07:09:52 <atom> mauke: what does it look like?
07:09:53 <vixey> Medea, you can't call a function StateOf
07:10:02 <vixey> Medea, but you could call one stateOf
07:10:09 <EvilTerran> vixey, ok, well, throwing in "p = (p = True)" and "!p = (p = False)", then :P
07:10:32 <Medea> vixey: this isn't an ordinary function, it's a function on types, and type families require those to be named with a capital
07:10:43 <mauke> atom: http://www.cpax.org.uk/prg/portable/c/c++/rfe00000.html  http://www.cpax.org.uk/prg/portable/c/c++/rfe00001.html  http://www.cpax.org.uk/prg/portable/c/c++/rfe00002.html  http://www.cpax.org.uk/prg/portable/c/c++/rfe00003.html
07:11:30 <vixey> Medea, oh, s is convertable with StateOf (State s) but it's printed out long
07:11:58 <vixey> starting to think GHCs design decision about printing things un-normalized is bad
07:12:18 <Medea> :t undefined :: StateOf (State s)
07:12:18 <Medea> undefined :: StateOf (State s) :: StateOf (State s)
07:12:19 <lambdabot>     Not in scope: type constructor or class `StateOf'
07:12:32 <vixey> Medea: try  (undefined :: StateOf (State s)) :: s
07:12:45 <vixey> oh once you get it working
07:13:29 <Medea> vixey: ":t (undefined :: StateOf (State s)) :: s" works but it defeats the purpose
07:14:00 <vixey> what purpose?
07:14:00 <mauke> PeakerWork: are you kidding me?
07:14:00 <mauke> PeakerWork: this is a guy who writes return(1);
07:14:13 <vixey> Medea, the thing is that  StateOf (State s)  is the same thing as  s  but they are just printed differently
07:14:32 <Medea> vixey: of finding out what StateOf (State s) evaluates to. I give GHC the answer myself in that last example and have it check it. But I want GHC to come up with the answer.
07:14:56 <EvilTerran> vixey, i guess, having given that axiom, you'd define other connectives in terms of \/ and = ?
07:15:05 <PeakerWork> mauke: Find a better comparison then :-)
07:15:19 <vixey> EvilTerran, this is a theorem in classical logic regardless of other connectives
07:15:30 <PeakerWork> mauke: I think _every_ comparison between Perl and <other language> will favor <other language> :-)
07:15:36 <vixey> when you add in negation conjunction etc it still holds
07:15:40 <mauke> # By default, all variables are global in Perl.
07:15:46 <Badger> PeakerWork: even comparing regex? :P
07:15:55 <atom> mauke: heh :). I assume the implementation is done in haskell
07:15:55 <mauke> guess what, that's how it works in C and Haskell and whatever, too
07:15:57 <vixey> (defined in the usual way,  by writing them twice, second time in a different typeface)
07:16:06 <PeakerWork> Badger: yeah, as it will be clearer that regexps are used when using a library, rather than syntax :)
07:16:27 <PeakerWork> mauke: in C, variables inside functions are local to that function unless declared static, so local by default
07:16:32 <mauke> PeakerWork: wrong
07:16:45 <EvilTerran> vixey, it looks like the law of excluded middle to me...
07:16:46 <mauke> PeakerWork: void f(void) { i = 2; }  // not a local variable
07:17:07 <PeakerWork> mauke: well, in a language where all variables are explicitly declared, there is no implicit scoping at all
07:17:14 <mauke> PeakerWork: bingo
07:17:19 <PeakerWork> mauke: but Perl is not such :)
07:17:27 <mauke> implicit scoping is one of my pet hates
07:17:27 <vixey> EvilTerran,it is provable in terms of LEM, and LEM in terms of it
07:17:34 <mauke> especially in python
07:17:36 <EvilTerran> PeakerWork, it is with use strict;
07:17:42 <EvilTerran> (iirc)
07:17:43 <wjt> so if I wrap a C struct with a ForeignPtr, how can I tell the RTS that values of that type are not just one word, but in fact the size of the C struct (from a GC perspective)?
07:17:57 <PeakerWork> EvilTerran: Perl (strict) is indeed far closer to sanity than Perl
07:18:06 <PeakerWork> but still not quite sane :-)
07:18:19 <EvilTerran> true
07:18:24 <mauke> PeakerWork: I assume 'strict' unless specified otherwise
07:18:29 <wjt> My housemate is complaining that in Python and Ruby you can't, so it's easy to use all the RAM in the world without the GC ever thinking it needs to kick in.
07:18:32 <vixey> EvilTerran, oh that was a lie, you need "propositional extensionality" as well as LEM
07:18:43 <PeakerWork> mauke: can we agree that Perl without "use strict" is an awful language? :)
07:18:44 <EvilTerran> vixey, ok, now i'm confused
07:18:51 <EvilTerran> never mind
07:18:56 <EvilTerran> i'll go back to reading wikipedia now :P
07:19:01 <PeakerWork> mauke: about Perl with "use strict" - I am unsure, I just don't know it very well. I do know there are no argspecs and hate that :P
07:19:02 <mauke> PeakerWork: yes, with strict 'subs' being the weirdest thing
07:19:25 <wjt> I'd like to think that the situation in this Non-Strict Nirvana is better... :)
07:19:34 <mauke> PeakerWork: but some of the other things in that code ... it looks like he deliberately chose the ugliest possible way to write them
07:19:59 <mauke> PeakerWork: like using ${$arrayRef}[0]=4; instead of $array->[0] = 4;
07:20:38 <mauke> PeakerWork: or print $array[0]," ",$array[1],"\n"; instead of print "$array[0] $array[1]\n";
07:21:05 <PeakerWork> mauke: Okay, I wish there was a readability shootout focusing on the most readable rather than highest performing program
07:21:11 <PeakerWork> mauke: then we could compare Python, Perl, etc
07:21:22 <mauke> I bet Haskell would lose that big time
07:21:36 <atom> I think haskell would win both of those
07:21:45 <mauke> hah
07:21:47 <PeakerWork> mauke: Readability does not necessarily mean readability to newbies
07:22:17 <mauke> then most of perl's weaknesses disappear
07:22:55 <PeakerWork> mauke: I disagree. Lack of argspec is a horrible weakness to experts too
07:23:06 <vixey> I think you guys have something non-technical and non-objective against perl
07:23:09 <PeakerWork> mauke: things like "shift"
07:23:32 <mauke> PeakerWork: it's ugly, but you do get used to it, and it doesn't hurt readability
07:23:38 <atom> don't know about that, but in my experience reading most perl scripts is coparable to reading code in the obfuscated c contest.
07:23:41 <PeakerWork> vixey: I personally really hate the syntax (sigils), lack of argspec, and the fact ints, strings, etc are all "scalars" and are the same type
07:23:51 <mauke> whether you write fun foo($x, $y, $z) or sub foo { my ($x, $y, $z) = @_; ...
07:24:06 <PeakerWork> mauke: what about optional/default args?
07:24:25 <mauke> I don't use them much
07:24:54 <PeakerWork> mauke: Maybe that's because Haskell/Perl don't have them? :P
07:24:58 <mauke> optional args turn into something like $z ||= "default";
07:25:03 <mauke> maybe
07:25:24 <idnar> Haskell's syntax is more dense than Python's, I think; but it didn't take very long to get to the point where I could read most Haskell
07:25:29 <gnuvince> Does anyone know a good intro article/blog post to QuickCheck that I could link to friends who ask me what it's about?  These people usually know nothing or very little about Haskell and are usually more C or C++ programmers, so something that doesn't delve too deep into Haskell black magic would be needed.
07:26:05 <mauke> PeakerWork: as for perl vs. <other language>, see http://tnx.nl/php.html
07:26:29 <idnar> my objection to Perl is mostly the same as my objection to JavaScript; the syntax is not pleasant on the eyes (which I never "got used to"), and it keeps ambushing me with unexpected weirdness
07:27:04 <mauke> javascript is another language with fucked up scoping, like python and php :-)
07:27:05 <jkff> PeakerWork: I recently saw a readability shootout somewhere
07:27:06 <idnar> on some level, I can understand that Perl has a coherent semantic framework (probably more so than JavaScript), but it's just that it's too far removed from the level where I actually do coding
07:28:20 <idnar> having to do things like (%{$foo{$bar}}){$baz} just makes my teeth hurt
07:28:43 <gnuvince> mauke: I think if you use "var", it's pretty decent and "expectable"; not using it however leads to pain.  They should've not allowed it in.
07:28:54 <mauke> idnar: good, because that's a syntax error :-)
07:29:01 <mauke> gnuvince: no, it isn't
07:29:03 <vixey> but you guys will never come to a conclusion about this...
07:29:04 <idnar> mauke: oh, great, so I *still* got it wrong
07:29:09 <idnar> mauke: what's the correct syntax for that, then?
07:29:15 <mauke> idnar: what is that supposed to do?
07:29:28 <mauke> gnuvince: 'var' isn't scoped to the current block
07:29:59 <pejo> atom, you can write cobol code in any language
07:30:02 <idnar> mauke: my %foo = (bar => { blah => 5 });
07:30:05 <EvilTerran> vixey, when i said i was looking for a set of axioms, i was thinking of something analogous to http://en.wikipedia.org/wiki/List_of_rules_of_inference
07:30:11 <mauke> idnar: $foo{bar}{blah}
07:30:21 <EvilTerran> vixey, so maybe "inference rules" would've been a better term than "axioms"
07:30:23 <vixey> EvilTerran, but they aren't equations
07:30:31 <vixey> or I just misread you?
07:30:34 <idnar> mauke: that doesn't work, unless something changed since I last used perl
07:30:39 <EvilTerran> vixey, that's why i said "analogous"
07:30:44 <atom> pejo: no doubt. It's whether it's done frequently that's the real problem.
07:30:47 <mauke> idnar: ... when was the last time you used perl?
07:31:09 <idnar> mauke: well, the code I'm looking at right now is about 3 years old
07:31:13 <vixey> EvilTerran, oh I took it literally.. anyway the extensionality is   (P <-> Q) -> (P = Q)
07:31:37 <mauke> idnar: I'm pretty sure this style is older than 10 years
07:31:41 <vixey> this is the sort of thing which makes truth tables work
07:31:55 <vixey> (which you don't get in e.g. constructive logic)
07:32:08 <mauke> there's nothing about it in 5005delta, and 5.005 was released in 1998
07:32:24 <shepheb> it could also have been written $foo{bar}->{blah}, which is equivalent to mauke's
07:32:36 <idnar> mauke: I guess I may have mixed it up with something ellse
07:32:53 <idnar> although now I can't remember why there's () around the outside there instead of {} in the definition of %foo
07:33:15 <EvilTerran> idnar, because {...} makes a hashtable reference
07:33:28 <EvilTerran> it's analogous to [...] for lists
07:33:33 <idnar> EvilTerran: which, on the surface, is exactly what I want
07:33:34 <mauke> s/lists/arrays/
07:33:45 <EvilTerran> er, yes, arrays
07:33:54 <EvilTerran> idnar, but %foo is a hashtable, not a reference to one :P
07:33:57 <mauke> you can always use references, but then all your variables should start with $
07:34:04 <idnar> oh, right
07:34:08 <mauke> I guess that gives you some kind of consistency
07:34:23 <idnar> well, I could never wrap my head around all that
07:34:37 <idnar> it's not as bad as JavaScript, where every time you blink you trip over a basket of special cases
07:34:54 <idnar> but every time I write a line of code, I have to look up half of the language again to make any sense of what I'm doing
07:34:58 <mauke> ok, you're familiar with values vs. boxes, right?
07:35:17 <mauke> a box is something mutable where you can store and retrieve values
07:35:24 <idnar> yes
07:35:58 <mauke> well, perl has three types of boxes: scalars, arrays and hashes
07:36:17 <mauke> also, perl makes boxes not be values, so no recursion
07:36:38 <idnar> okay, so I can't actually have a hash of hashes
07:36:44 <mauke> right
07:36:45 <mapreduce> Another term is lvalue.
07:36:49 <BrokenClockwork> @src $
07:36:49 <lambdabot> f $ x = f x
07:36:57 <idnar> but I can have a hash of references to hashes
07:36:59 <mauke> the workaround introduced by perl5 is references
07:37:08 <mauke> a "reference" is a value that refers to a box
07:37:09 <BrokenClockwork> :t $
07:37:10 <lambdabot> parse error on input `$'
07:37:14 <idnar> :t ($)
07:37:15 <lambdabot> forall a b. (a -> b) -> a -> b
07:37:21 <BrokenClockwork> :)
07:37:30 <vixey> , ) $ (
07:37:35 <lunabot>  luna: Couldn't match expected type `a -> b'
07:37:41 <jeltsch> @fixity >>>
07:37:42 <lambdabot> Unknown command, try @list
07:37:46 <jeltsch> @list
07:37:46 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:37:58 <Badger> > head $ tail [1..]
07:37:58 <jeltsch> @info >>>
07:37:59 <lambdabot> (>>>)
07:37:59 <lambdabot>   2
07:38:15 <jeltsch> lambdabot: Huh?
07:38:16 <mauke> idnar: [...] and {...} are syntactic sugar for allocating boxes and returning references to them
07:38:26 <Badger> huzzah for laziness.
07:38:30 <jeltsch> @help
07:38:31 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:38:37 <jeltsch> @help info
07:38:38 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:38:46 <rwbarton> , src '(>>>)
07:38:47 <lunabot>  luna: Not in scope: `>>>'
07:38:49 <mauke> idnar: on the other hand, %foo = ... is an operation on %foo itself. no references.
07:38:54 <idnar> I guess @info is being spell-corrected to something
07:38:57 <rwbarton> , src '(Control.Category.>>>)
07:38:59 <lunabot>  luna: Not in scope: `Control.Category.>>>'
07:39:03 <rwbarton> info --> undo
07:39:07 <mauke> idnar: @info is undo
07:39:11 <idnar> heh
07:39:49 <jeltsch> info is not listed on http://code.haskell.org/lambdabot/COMMANDS
07:40:07 <athos_> hi all
07:40:18 <mapreduce> What does an uptime of 12 actually mean in Linux?
07:40:19 <jeltsch> How can I make lambdabot telling me operator fixities?
07:40:39 <BrokenClockwork> okay, I am looking for a nice example of ($) which explains me how it works
07:40:42 <idnar> mapreduce: an /uptime/? nothing, without some more context or units
07:40:45 <rwbarton> jeltsch: I don't believe it knows them
07:40:52 <rwbarton> , src '(+)
07:40:56 <EvilTerran> jeltsch, i don't think you can
07:40:59 <jeltsch> Okay, I’ll ask GHCi.
07:41:01 <mauke> > sqrt $ 2
07:41:02 <lambdabot>   1.4142135623730951
07:41:03 <lunabot>  Class op from Num: (+) :: forall a . Num a => a -> a -> a
07:41:03 <lunabot>                     infixl 6 (+)
07:41:08 <Olathe> jeltsch: Try @ in private.
07:41:16 <mapreduce> idnar: Gah, sorry.
07:41:16 <rwbarton> jeltsch: lunabot knows, but (>>>) isn't imported for some reason
07:41:25 <mapreduce> idnar: I meant the load.
07:41:37 <BrokenClockwork> but sqrt 2 works also, I don't need the $
07:41:51 <idnar> mapreduce: informally, it means something like "on average, in <period> 12 processes were active simultaneously"
07:41:55 * EvilTerran gets that hideous sinking feeling that he has no idea how to even start designing the thing he's trying to do
07:41:55 <mauke> > sqrt $ 1 + 1
07:41:57 <lambdabot>   1.4142135623730951
07:42:02 <Olathe> @info do { x <- a; return x }
07:42:03 <BrokenClockwork> ah ok
07:42:03 <lambdabot> a >>= \ x -> return x
07:42:06 <Olathe> @undo do { x <- a; return x }
07:42:07 <lambdabot> a >>= \ x -> return x
07:42:32 <BrokenClockwork> so $ comes handy, when I want to apply a bracket expression to my function for some reason? To make it more readable?
07:42:46 <pejo> mapreduce, it's the number of processes waiting in the run-queue, in a sliding time window.
07:42:50 <idnar> mapreduce: the man page says "System load averages is the average number of processes that are either in a runnable or uninterruptable state. A process in a runnable state is either using the CPU or waiting to use the CPU."
07:43:27 <mauke> BrokenClockwork: yes, every call to $ can be replaced by using ( )
07:43:59 <idnar> so on an N-CPU system, a load average below N means your CPUs are idling some of the time, load average of exactly N is something like a "perfect load", and anything over N means you're starting to get "overloaded"
07:44:21 <mapreduce> idnar: Ah, thanks.
07:44:38 <mapreduce> I must have read that a few years ago and failed to grok it.
07:44:57 <arw> but take it with a grain of salt. especially some IO-patterns can produce some very fishy loads...
07:45:31 <EvilTerran> > exp 1 ** (sqrt (-1) * pi) :: Complex CReal
07:45:36 <lambdabot>   (-1.0) :+ 0.0
07:45:37 <Botje> if you disk has to seek a lot your load rises very quickly
07:45:38 <EvilTerran> :O
07:45:42 <mapreduce> idnar: Do you expect that processes there includes threads as separate processes?  I killed firefox and the load dropped frrom 12 to 0.14
07:45:47 * EvilTerran must read up on how CReal works sometime
07:46:06 <pejo> mapreduce, that depends on your thread implementation. What OS?
07:46:19 <mapreduce> Linux.
07:46:19 <Botje> mapreduce: threads are implemented as processes that share another process' memory in linux
07:46:43 <EvilTerran> that seems heavyweight
07:46:54 <idnar> mapreduce: well, there are lots of factors that might be in play there
07:47:04 <EvilTerran> no wonder ghc's green threads are faster :P
07:47:08 <Botje> EvilTerran: that's what they are :p
07:47:16 <idnar> mapreduce: for example, if Firefox was maxing out I/O on your system, then any other process trying to do I/O would get bogged down, resulting in rising load averages
07:47:24 <mapreduce> I see.
07:47:26 <Botje> but green threads can't work on more than one core, right?
07:47:37 <Botje> so GHC probably does some normal thread voodoo too
07:47:40 <pejo> idnar, aren't processes waiting for (slow) IO exempted from the load average?
07:48:06 <pejo> Botje, just schedule your green threads over a pool of OS-threads.
07:48:08 <idnar> pejo: nope
07:48:20 <Botje> indeed
07:48:25 <idnar> pejo: "...average number of processes that are either in a runnable or uninterruptable state... A process in uninterruptable state is waiting for some I/O access, eg waiting for disk."
07:48:33 <jeltsch> What’s the difference between lamdabot and lunabot?
07:48:36 <EvilTerran> one os-thread per core seems appropriate to me
07:48:48 <jeltsch> Is lunabot a new competition?
07:48:49 <EvilTerran> jeltsch, the codebases?
07:49:03 <jeltsch> Is lunabot a fork or a completely new project?
07:49:06 <Botje> some languages don't have the luxury of green threads :)
07:49:10 <EvilTerran> complete rewrite, i think
07:49:15 <jeltsch> I thought lambdabot is *the* Haskell bot.
07:49:27 <Botje> jeltsch: now it's *a* Haskell bot :)
07:49:31 <EvilTerran> why must there only be one?
07:49:36 <jeltsch> Is lunabot more feature-rich?
07:49:43 <jeltsch> Or are both bots incomparable?
07:49:44 <EvilTerran> lunabot has different features
07:49:45 <mapreduce> There needs to be a "Yes! #haskell can answer that" faq in lambdabot. :)
07:49:49 <mauke> preflex: quote
07:49:51 <preflex>  <sungo> I do not need a reason to crap my pants on a daily basis
07:49:52 <mapreduce> idnar: Thanks for that.
07:49:54 <Olathe> mapreduce: Heheh
07:50:24 <jeltsch> And lunabot is called by starting with a comma? Or are there other ways?
07:50:40 <mauke> ] 42
07:50:42 <lunabot>  42
07:50:53 <EvilTerran> @bot
07:50:53 <lambdabot> :)
07:50:53 <lunabot>  :)
07:51:10 <jeltsch> @bot
07:51:10 <lunabot>  :)
07:51:10 <lambdabot> :)
07:51:23 <mauke> preflex: are you a bot?
07:51:23 <preflex>  yes.
07:51:24 <jeltsch> Nice, there also listening to me. :-)
07:51:38 <jeltsch> jeltsch: are you a bot?
07:51:40 <jeltsch> yes.
07:51:46 <jeltsch> So this proves nothing. :-)
07:51:54 <mauke> preflex: version
07:51:54 <preflex>  4.610
07:51:58 <vixey> ♬ ) `const` (
07:52:06 <mauke> jeltsch: version
07:52:10 <jeltsch> 1.0
07:52:10 <EvilTerran> vixey, whaaa?
07:52:13 <athos_> , [$ty|foldl]
07:52:15 <lunabot>  luna: lexical error in string/character literal at end of input
07:52:18 <vixey> ♪ ) `const` (
07:52:18 <athos_> :o
07:52:24 <EvilTerran> , [$ty|foldl|]
07:52:29 <lunabot>  forall a b . (b -> a -> b) -> b -> ([] a) -> b
07:52:30 <athos_> ah.
07:52:53 <jeltsch> ,help
07:52:55 <lunabot>  luna: Not in scope: `help'
07:52:58 <EvilTerran> athos_, TH quotes all have the form [...| ... |] to distinguish them from list comprehensions
07:53:01 <jeltsch> , why
07:53:03 <lunabot>  luna: Not in scope: `why'
07:53:09 <jeltsch> , mist
07:53:11 <lunabot>  luna: Not in scope: `mist'
07:53:17 <jeltsch> , list
07:53:19 <lunabot>  luna: No instance for (GHC.Show.Show
07:53:30 <EvilTerran> @where lunabot
07:53:31 <lambdabot> I know nothing about lunabot.
07:53:34 <athos_> EvilTerran: okay
07:53:35 <EvilTerran> heh
08:05:48 <cognominal> Prelude Text.ParserCombinators.Parsec> :t GenParser
08:05:48 <cognominal> <interactive>:1:0: Not in scope: data constructor `GenParser'
08:05:48 <cognominal> Prelude Text.ParserCombinators.Parsec> :t many
08:05:48 <cognominal> many :: GenParser tok st a -> GenParser tok st [a]
08:06:02 <cognominal> how come the error in the first line?
08:06:28 <EvilTerran> cognominal, because GenParser is a type, not a value
08:06:32 <athos_> , src ''GenParser
08:06:34 <lunabot>  luna: Not in scope: type constructor or class `GenParser'
08:06:35 <EvilTerran> types don't have types
08:06:40 <athos_> kinds!
08:09:57 <Olathe> @type (::)
08:09:58 <lambdabot> parse error on input `::'
08:10:08 <Olathe> Hmm...
08:12:04 <Olathe> Is it possible to make a typeclass for iterable things that allows pattern matching and construction like (:) allows for lists ?
08:12:06 <byorgey> cognominal: you can type ':k GenParser' to print out GenParser's kind, or ':info GenParser' to see its definition
08:12:31 <BrokenClockwork> interact is somehow when used, I need an input from, let's say text file?
08:12:51 <byorgey> Olathe: IIRC CosmicRay made a ListLike type class, is that the sort of thing you mean?  I think it's on Hackage.
08:13:45 <Olathe> I'll check it out, but the main problem is pattern matching using a regular function instead of a constructor.
08:14:25 <Olathe> @where listlike
08:14:26 <lambdabot> http://software.complete.org/software/projects/show/listlike
08:14:36 <byorgey> Olathe: yeah, for that, ghc 6.10's view patterns can be useful
08:15:00 <byorgey> foo (decons -> (hd,tl)) = ...
08:16:18 <Olathe> Ahh, that looks interesting.
08:21:46 <Heffalump> is ghc allowed to stack overflow type-checking module Y if you use UndecidableInstances in module X which Y depends on, but not in Y itself?
08:22:06 <Heffalump> (where "allowed" = "should I blame myself or report a GHC bug")
08:22:19 <Olathe> It looks like, with that, you could have instance ListConst (a, Listish a) and instance ListConst Listish a to do it both ways.
08:23:52 <pejo> Heffalump, did what you just said mean that UndecidableInstances are transitive in reality?
08:23:53 <Olathe> cons (a, b) = prepend a b ... cons a = decons a
08:24:23 <Olathe> Then, define decons and prepend for each Listish type.
08:24:29 <Heffalump> pejo: I'm not sure.
08:24:57 * Trafalgard wonders which is better in a data, foo :: [(bar, zort)], or foo :: [bar], zort :: [narf]
08:24:57 <Olathe> @src lc
08:24:58 <lambdabot> Source not found. Where did you learn to type?
08:25:13 <vixey> Trafalgard, [(bar, zort)] is stronger
08:25:15 <Heffalump> Trafalgard: the former, because it enforces the equal lengths invariant
08:30:45 <vixey> mm..
08:31:09 <vixey> how to write a theorem prover for a haskell like language?
08:32:01 <blueonyx> how to get rich?
08:32:48 <vixey> Twelf is a language used to specify, implement, and prove properties of deductive systems such as programming languages and logics.
08:33:06 <Trafalgard> vixey, heffalump, thanks
08:33:36 <vixey> Twelf is by no means the only program you can use to do this sort of thing. ACL2, AUTOMATH, Coq, HOL, HOL Light, LEGO, Isabelle, MetaPRL, NuPRL PVS, and TPS are just a few
08:34:00 <vixey> but how are these kind of programs implemented?
08:34:45 <dublpaws>  what about prolog? isn't that what it's built for?
08:34:48 <gwern> > let (^_^) = (+) in 5 ^_^ 5
08:34:49 <lambdabot>   <no location info>: parse error on input `)'
08:34:54 <gwern> darn
08:35:16 <vixey> I already know how to implement prolog
08:35:28 <vixey> these guys are different
08:35:36 <EvilTerran> gwern, _ isn't an operator character
08:40:07 <EvilTerran> > let infixl \\, //; (\\) = flip (<$>); (//) = (<*>); (^.^) = (,) in [1,2,3] \\(^.^)// "abc"
08:40:09 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
08:40:18 <BrokenClockwork> okay I tried to learn how interact and IO actually works, but it still gives me disappointing results: http://hpaste.org/13830
08:40:42 <BrokenClockwork> again, it's the palindrome programme which should reac ton every input just True or False
08:41:10 <mauke> "every input"? there's only one
08:41:34 <BrokenClockwork> okay one
08:41:38 <BrokenClockwork> right
08:41:42 * EvilTerran would expect the compiler to say "no thanks" when given the command "interact palin" :P
08:42:02 <EvilTerran> BrokenClockwork, "interact" gives the entirity of stdin to the function as a single string
08:42:05 <BrokenClockwork> it compiles fine
08:42:19 <EvilTerran> BrokenClockwork, i was making a politics joke, never mind
08:42:35 <BrokenClockwork> oh, lol
08:42:45 <BrokenClockwork> that's evil *eg*
08:42:46 <EvilTerran> BrokenClockwork, if you want to act on each line in turn, you could use "lines"
08:43:05 <BrokenClockwork> mh well, right!
08:43:12 <Olathe> @type interact
08:43:13 <lambdabot> (String -> String) -> IO ()
08:43:19 <BrokenClockwork> damn it BONUS did it too when he was programming with interact
08:43:57 <Olathe> @hoogle (String -> String) -> IO ()
08:43:58 <lambdabot> Prelude interact :: (String -> String) -> IO ()
08:43:58 <lambdabot> System.IO interact :: (String -> String) -> IO ()
08:44:14 <Olathe> @src interact
08:44:14 <lambdabot> interact f = do s <- getContents; putStr (f s)
08:45:44 <Olathe> @type getContents >>= lines
08:45:45 <lambdabot>     Couldn't match expected type `IO b'
08:45:45 <lambdabot>            against inferred type `[String]'
08:45:45 <lambdabot>       Expected type: String -> IO b
08:45:54 <Olathe> @type getContents >>= return.lines
08:45:55 <lambdabot> IO [String]
08:46:35 <mauke> interact' f = interact $ unlines . map f . lines
08:46:36 <BONUS> yeah, the thing in there is if you do  main = interact id  , and if you just manually put stuff into stdin, it will seem like it gets every line and echoes it out
08:46:57 <BONUS> actually it gets all the contents and echoes them out as one string but it seems to look like its done line by line because of line-buffering
08:47:05 <BONUS> maybe i should point that out a bit more explicitly in the tutorial
08:47:22 <Olathe> @type getContents >>= map (putStrLn.f).lines
08:47:24 <lambdabot>     Couldn't match expected type `IO b' against inferred type `[IO ()]'
08:47:24 <lambdabot>       Expected type: String -> IO b
08:47:24 <lambdabot>       Inferred type: String -> [IO ()]
08:47:47 <EvilTerran> @type mapM_ (putStrLn.f) . lines =<< getContents
08:47:48 <Olathe> @type getContents >>= return.const ().map (putStrLn.f).lines
08:47:48 <lambdabot>     No instance for (SimpleReflect.FromExpr [Char])
08:47:48 <lambdabot>       arising from a use of `f' at <interactive>:1:16
08:47:48 <lambdabot>     Possible fix:
08:47:49 <lambdabot>     No instance for (SimpleReflect.FromExpr [Char])
08:47:49 <lambdabot>       arising from a use of `f' at <interactive>:1:46
08:47:50 <lambdabot>     Possible fix:
08:47:57 <EvilTerran> @type mapM_ (putStrLn . ?f) . lines =<< getContents
08:47:58 <lambdabot> (?f::String -> String) => IO ()
08:48:10 <BONUS> anyway, for telling if each line is a palindrome, you can use interact, but you can also do it by just getting one line at a time
08:48:19 <Olathe> @type getContents >>= return.map (putStrLn.f).lines
08:48:22 <EvilTerran> Olathe, i doubt "return . const ()" will do what you want
08:48:34 <lambdabot>     No instance for (SimpleReflect.FromExpr [Char])
08:48:34 <lambdabot>       arising from a use of `f' at <interactive>:1:37
08:48:34 <lambdabot>     Possible fix:
08:48:41 <Olathe> Hmm...
08:48:45 <EvilTerran> ?type f
08:48:46 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
08:49:06 <BrokenClockwork> ok so here's the new code: http://hpaste.org/13830#a1
08:49:20 <Olathe> @type putStrLn
08:49:21 <lambdabot> String -> IO ()
08:49:24 <BrokenClockwork> I thought I put it in the right direction, however the results are the same
08:49:34 <EvilTerran> BrokenClockwork, er, you're not *doing* anything with "allLines"
08:49:44 <BrokenClockwork> woopsie
08:49:54 <Olathe> @type sequence [putStrLn "Hello", putStrLn "zomg"]
08:49:55 <lambdabot> IO [()]
08:50:17 <Olathe> @type foldr mplus mzero [putStrLn "Hello", putStrLn "zomg"]
08:50:18 <lambdabot> IO ()
08:50:33 <Olathe> @type getContents >>= foldr mplus mzero (putStrLn.f).lines
08:50:35 <lambdabot>     Couldn't match expected type `[m a]'
08:50:35 <lambdabot>            against inferred type `a1 -> IO ()'
08:50:35 <lambdabot>     In the third argument of `foldr', namely `(putStrLn . f)'
08:50:43 <Sensay> Hi.hi.hi
08:50:46 <Olathe> @type getContents >>= foldr mplus mzero.map (putStrLn.f).lines
08:50:47 <lambdabot>     No instance for (SimpleReflect.FromExpr [Char])
08:50:47 <lambdabot>       arising from a use of `f' at <interactive>:1:48
08:50:47 <lambdabot>     Possible fix:
08:50:51 <Sensay> Hello
08:51:00 <Olathe> Thank you, SimpleReflect, for screwing up the error message.
08:51:02 <BrokenClockwork> http://hpaste.org/13830#a2 mhh
08:51:21 <Olathe> @type \f -> getContents >>= foldr mplus mzero.map (putStrLn.f).lines
08:51:22 <lambdabot> (String -> String) -> IO ()
08:51:25 <BrokenClockwork> actually I want just the single line?
08:51:28 <Sensay> who wants chat?
08:51:47 <Olathe> @src msum
08:51:47 <lambdabot> msum =  foldr mplus mzero
08:51:58 <Olathe> @type \f -> getContents >>= msum.map (putStrLn.f).lines
08:51:59 <lambdabot> (String -> String) -> IO ()
08:52:27 <Olathe> let interacts f = getContents >>= msum.map (putStrLn.f).lines
08:52:39 <BONUS> BrokenClockwork: how aobut this http://hpaste.org/13831
08:52:55 <Olathe> @redo getContents >>= msum.map (putStrLn.f).lines
08:52:56 <lambdabot> do { a <- getContents; (msum . map (putStrLn . f) . lines) a}
08:53:20 <Sensay> HEEEEEEEEEY
08:53:21 <BONUS> what you're actually doing is transforming something like "aint a palindrome\nabcba" into "no it aint a palindrom\nyes it is a palindrome"
08:53:21 <EvilTerran> BrokenClockwork, think about what "allLines == reverse allLines
08:53:21 <EvilTerran> " means
08:54:11 <BrokenClockwork> mh, that's neat, it's short as the second code of your interact example from yourtutorial
08:54:17 <EvilTerran> > reverse ["a line", "another line", "and another"]
08:54:18 <lambdabot>   ["and another","another line","a line"]
08:54:30 <BrokenClockwork> yeah this is kinda stuipid
08:54:35 <EvilTerran> > reverse (lines "a line\nanother line\nand another")
08:54:37 <lambdabot>   ["and another","another line","a line"]
08:54:48 <BONUS> BrokenClockwork: yeah i'll actually add this example in there too :)
08:54:59 <BONUS> to demonstrate how you can also make programs that appear to work line by line with interact
08:54:59 <BrokenClockwork> heh
08:55:03 <Olathe> Hmm...
08:55:46 <Olathe> @type \f -> getContents >>= return.unlines.map f.lines
08:55:48 <lambdabot> (String -> String) -> IO String
08:56:07 <Olathe> @type \f -> getContents >>= putStrLn.unlines.map f.lines
08:56:09 <lambdabot> (String -> String) -> IO ()
08:56:17 <Olathe> @undo getContents >>= putStrLn.unlines.map f.lines
08:56:18 <lambdabot> getContents >>= putStrLn . unlines . map f . lines
08:56:23 <Olathe> @redo getContents >>= putStrLn.unlines.map f.lines
08:56:24 <lambdabot> do { a <- getContents; (putStrLn . unlines . map f . lines) a}
08:56:26 <EvilTerran> ?type \f -> interact (unlines.f.lines)
08:56:27 <lambdabot> ([String] -> [String]) -> IO ()
08:56:34 <Olathe> @src interact
08:56:34 <lambdabot> interact f = do s <- getContents; putStr (f s)
08:56:35 <EvilTerran> ?type \f -> interact (unlines.map f.lines)
08:56:36 <lambdabot> (String -> String) -> IO ()
08:56:54 <eu-prleu-peupeu> hello Haskl3z0rs
08:57:05 <Olathe> EvilTerran: Ahh, nice.
08:58:32 <Olathe> @pl \f -> interact (unlines.f.lines)
08:58:33 <lambdabot> interact . (unlines .) . (. lines)
08:59:16 <Olathe> ah.
08:59:19 <Olathe> Bah.
08:59:25 <Olathe> @pl \f -> interact (unlines.map f.lines)
08:59:26 <lambdabot> interact . (unlines .) . (. lines) . map
08:59:59 <BrokenClockwork> :t (.)
09:00:00 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
09:00:02 <BrokenClockwork> @src (.)
09:00:02 <lambdabot> (f . g) x = f (g x)
09:02:26 <Badger> weird.
09:02:35 <Badger> initSDL :: [SubSystem] -> IO ()
09:02:44 <Badger> and yet
09:02:46 <Badger> oh, wait.
09:03:24 <Badger> yeah
09:03:27 <Badger>  Not in scope: `initSDL'
09:05:42 <mm_freak> gtk2hs still fails to build =/
09:06:07 <mm_freak> configure: error:
09:06:07 <mm_freak> Another gtk2hs package that glade depends on is not being built.
09:06:35 <dcoutts> mm_freak: what configuration? gtk2hs version, ghc version?
09:06:58 <mm_freak> dcoutts: GHC 6.10.1, gtk2hs-darcs
09:08:20 <cnwdup> @hoogle Int -> Char
09:08:21 <lambdabot> Data.Char chr :: Int -> Char
09:08:21 <lambdabot> Data.Char intToDigit :: Int -> Char
09:08:21 <lambdabot> Data.ByteString.Char8 index :: ByteString -> Int -> Char
09:08:36 <yakov_> hey
09:09:28 <yakov_> I have functional type, say type T = Int -> a, where always (Ord a, Num a) holds, is it possible to give this context info to GHC once?
09:09:40 <dcoutts> mm_freak: so are you enabling the gtk and glib packages?
09:10:03 <yakov_> i mean i don't want to type this context for every function from F to something..
09:10:06 <dcoutts> mm_freak: what ./configure command line are you using?
09:10:43 <yakov_> err, from T (Int -> a) to something..
09:10:45 <yakov_> sorry.
09:11:30 <rwbarton> type T = Int -> a  is not a valid type synonym, is it?
09:11:38 <rwbarton> Anyways, the answer is probably no
09:12:46 <mm_freak> dcoutts: ./configure --prefix=/usr --host=i686-pc-linux-gnu --mandir=/usr/share/man --infodir=/usr/share/info --datadir=/usr/share --sysconfdir=/etc --localstatedir=/var/lib --enable-packager-mode --enable-cairo --enable-libglade --disable-gconf --disable-sourceview --disable-svg --enable-opengl --disable-seamonkey --disable-firefox --disable-xulrunner --enable-docs ...
09:12:52 <mm_freak> ... --disable-profiling --build=i686-pc-linux-gnu
09:13:01 <mm_freak> side note:  i'm installing it through gentoo's portage
09:13:57 <Olathe> type T a = Int -> a
09:14:12 <pejo> What (existing) languages, other than Haskell, uses type classes?
09:14:36 <dcoutts> mm_freak: since you're using --enable-packager-mode you need to enable explicitly each package that you want to use. That includes gtk.
09:14:52 <dcoutts> mm_freak: with that, it works for me.
09:15:07 <dcoutts> mm_freak: without it fails as you described.
09:15:46 <yakov_> Olathe, sure it is
09:16:56 <BrokenClockwork> :t (\)
09:16:57 <lambdabot> parse error on input `)'
09:17:04 <BrokenClockwork> :t \
09:17:05 <lambdabot> parse error (possibly incorrect indentation)
09:17:36 <centrinia> :t (/)
09:17:37 <lambdabot> forall a. (Fractional a) => a -> a -> a
09:18:13 <centrinia> @let a /\ b = a && b
09:18:15 <lambdabot>  Defined.
09:20:02 <mauke> @let a \/ b = a || b
09:20:03 <lambdabot>  Defined.
09:20:35 <vixey> :t (/\) *** (\/)
09:20:36 <lambdabot> (Bool, Bool) -> (Bool -> Bool, Bool -> Bool)
09:20:59 <mauke> looks like line noise
09:21:03 <mauke> haskell is a write-only language
09:22:24 <vixey> mauke, you must be thinking of pearl
09:22:48 <mm_freak> dcoutts: the gentoo package enables that flag unconditionally
09:22:49 <mauke> http://www.irt.uni-hannover.de/pearl/pearl-gb.html ?
09:23:15 <dcoutts> mm_freak: it was not in the list you pasted, with it added it works
09:23:21 <dcoutts> mm_freak: --enable-gtk I mean
09:23:26 <mm_freak> ah
09:24:12 <mm_freak> it doesn't even mention the --enable-gtk flag
09:24:12 <mm_freak> odd
09:28:38 <Holle_> which event do i have to use in gtk2hs to get the mouse position after clicking?
09:30:48 <dcoutts> Holle_: the mouse click event contains the coordinates
09:31:17 <Holle_> do i find it somewhere in the documentation?
09:31:53 <drdozer> evening
09:32:17 <dcoutts> Holle_: you're using onButtonPress right? look at it's documentation. The type says the handler takes a 'Event'. Follow the link and look at the docs for that. Look at the Button constructor for Event
09:32:25 <dons> yayaa, i'm glad someone's written about view patterns, http://www.reddit.com/r/programming/comments/7oyax/fun_with_view_patterns_new_ghc_feature_for/
09:32:48 <dcoutts> Holle_: and note the eventX,eventY :: Double
09:40:26 <Holle_> i'm clicking on a canvas-object. but i can't find the documentation you mean.
09:50:34 <jeltsch> Can Cabal deal with mutually recursive modules (if GHC is used and .hs-boot files are present)?
09:50:46 <dcoutts> jeltsch: should be able to
09:51:35 <jeltsch> dcoutts: Thanks.
09:51:55 <ztirf> @hoogle fzip
09:51:55 <lambdabot> No results found
09:55:01 <Holle_> if found onMotionNotify but onMouseClicked i can't find
09:57:01 <drdozer> ouch - I seem to have made ghc infinite-loop
09:57:08 <drdozer> and make my hard-disk spin
09:57:57 <Holle_> ah it
09:58:12 <Holle_> ah it's called onMouseClick
09:58:31 <Holle_> onMouseClick :: MozEmbed -> (Ptr a -> IO Int) -> IO (ConnectId MozEmbed)
09:59:45 <jeltsch> dcoutts: Will Cabal’s sdist also include the .hs-boot files?
10:00:18 <dons> src/Data/Fits/FitsIO.lhs:8:9:
10:00:18 <dons>     Could not find module `C2HS':
10:00:18 <dons>       Use -v to see a list of the files searched for.
10:00:28 <dons> dcoutts: is that a 'c2hs is not installed error' or a packaging error?
10:00:57 <vixey> :t (map,fmap)
10:00:58 <lambdabot> forall a b a1 b1 (f :: * -> *). (Functor f) => ((a -> b) -> [a] -> [b], (a1 -> b1) -> f a1 -> f b1)
10:01:03 <vixey> :h zip
10:01:13 <vixey> :t zip
10:01:14 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
10:01:27 <dcoutts> jeltsch: should do
10:01:42 <vixey> :t fmap (,)
10:01:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> f (b -> (a, b))
10:02:07 <cnwdup> @hoogle IO a -> a
10:02:07 <vixey> ?hoogle f (a -> b) -> f a -> f b
10:02:08 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
10:02:08 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
10:02:08 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
10:02:08 <lambdabot> Foreign unsafePerformIO :: IO a -> a
10:02:08 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
10:02:08 <dcoutts> dons: no, c2hs does not install a package, packages that want to use C2HS.hs have to copy it into their sources, c2hs --copy-library will do it for them.
10:02:10 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
10:02:27 <dcoutts> dons: I mean it does not install a library
10:02:42 <Heffalump> dcoutts: couldn't it have a separate library package?
10:02:48 <Heffalump> or is it a backwards compatibility issue?
10:03:03 <dcoutts> Heffalump: there's really no point, we should be phasing out the use of that module, it's hardly needed.
10:03:36 <dcoutts> Heffalump: it's really a lot nicer if just using a ffi tool does not add a runtime dependency.
10:03:42 <Heffalump> yeah
10:03:58 <Heffalump> but if there is a support library then copying it in seems rather ugly
10:04:03 <dcoutts> and that's possible, gtk2hs uses c2hs and does not use the C2HS module
10:04:10 <Heffalump> but getting rid of it completely sounds even better
10:05:25 <dons> dcoutts: i'm trying to determine if that error is c2hs' fault, or the package authors?
10:05:30 <bigorilla> @src maybe
10:05:31 <lambdabot> maybe n _ Nothing  = n
10:05:31 <lambdabot> maybe _ f (Just x) = f x
10:05:35 <mib_mnl88jo1> beginners question: how do I read a textfile into a string. So far I can only return an IO String...
10:05:49 <dcoutts> dons: package author
10:06:04 <rwbarton> mib_mnl88jo1: That's right, you can only get an IO String.
10:06:07 <dons> ok
10:06:17 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fitsio-0.2
10:06:20 <rwbarton> mib_mnl88jo1: Inside a do block in the IO monad, you can "extract" the String and perform operations on it
10:06:22 <vixey> mib_mnl88jol, read it into an IO String, then you can plug that into some String -> whatever
10:06:41 <vixey> mib_mnl88jol, but the result you'll get will be an IO whatever
10:08:23 <dcoutts> dons: that package does not even use c2hs
10:08:50 <dcoutts> no .chs files
10:09:02 <dons> weird
10:09:05 <dons> i've mailed the author
10:09:11 <mib_mnl88jo1> so there is no way to read a textfile into a 'normal' lis and return this list from a function ?
10:09:42 <dons> mib_mnl88jo1: readFile ?
10:09:49 <dcoutts> dons: very old versions of c2hs did install a c2hs lib that provided the C2HS module.
10:09:53 <dons> :t readFile
10:09:54 <lambdabot> FilePath -> IO String
10:10:00 <dons> :src String
10:10:03 <dcoutts> dons: so the author probably had that old version installed
10:10:03 <dons> ?src String
10:10:04 <lambdabot> type String = [Char]
10:10:57 <dcoutts> dons: hmm, but that would not work with -hide-all-packages. I guess the author just has a C2HS.hs in their build tree but not mentioned in the package
10:11:54 <ztirf> what does the "as" keyword do in something like: fzipWith f as bs = fmap (uncurry f) (fzip as bs)
10:12:07 <Botje> it's not a keyword
10:12:09 <Botje> it's a variable :)
10:12:10 <rwbarton> ztirf: as is not a keyword except in import synta
10:12:12 <rwbarton> *syntax
10:12:21 <Botje> "fzipWith f as bs = ..."
10:12:34 <ztirf> ah thanks - I was thrown because HsColour makes it blue
10:12:40 <vixey> :t as
10:12:41 <lambdabot> Not in scope: `as'
10:12:44 <mib_mnl88jo1> readFile still gives an IO String - e.g. I would like to do something like: lines readmyFile
10:13:16 <Botje> lines `liftM` readFile
10:13:17 <dons> mib_mnl88jo1: have you learned about 'do' notation?
10:13:24 <dons> main = do x <- readFile "foo"
10:13:27 <rwbarton> mib_mnl88jo1: I suggest you look at a haskell IO tutorial (I don't have any specific recommendations)
10:13:30 <dons>           print (lines x)
10:13:58 <Holle_> ghc couldn't find onMouseClick. i imported Graphics.UI.Gtk. what's wron?
10:14:12 <int-e> Holle_: it's onButtonPress
10:14:38 <Holle_> but i need onMouseClick for the object canvas
10:16:11 <Holle_> here it is listed http://www.haskell.org/gtk2hs/docs/devel/Graphics-UI-Gtk-MozEmbed.html#v%3AonMouseClick but i don't know how to use?
10:16:46 <mib_mnl88jo1> rwbarton: I 'm currently reading the real world haskel book , seems as if my problem isn't part of the real world...
10:17:03 <dcoutts> Holle_: oh, no, those are not very helpful. For normal widgets you can get the mouse location from the click event.
10:17:15 <rwbarton> mib_mnl88jo1: Of course it is, see chapter 7
10:17:24 <Holle_> but i don't habe any buttons?
10:17:36 <int-e> The mouse does.
10:17:43 <dcoutts> Holle_: it means mouse buttons
10:17:53 <Holle_> oh ^^
10:17:54 <dcoutts> Holle_: are you actually using the MozEmbed widget?
10:18:03 <rwbarton> I guess it would be nice if that chapter mentioned fmap/liftM/<$>
10:18:07 <Holle_> i don't know
10:18:16 <int-e> Holle_: then you probably aren't.
10:18:31 <mib_mnl88jo1> Holle_: but the didn't help me - keep getting - The last statement in a 'do' construct must be an expression
10:19:09 <dcoutts> Holle_: right, you just want the ordinary onButtonPress
10:19:13 <byorgey> mib_mnl88jo1: if you paste your code on hpaste.org, we could take a look
10:19:38 <dcoutts> Holle_: what widget are you using? what one are you trying to get the mouse click location for?
10:20:05 <byorgey> mib_mnl88jo1: one things that can frequently cause that error is wrong indentation.  be sure you are using spaces and not tabs, and line up the beginnings of all the lines in a do block.
10:20:11 <Holle_> of a drawingArea
10:20:39 <dfan> Is there a standard library 'return whether a list has at least n elements' function or should I roll my own?
10:20:53 <EvilTerran> def__, nothing standard
10:20:56 <EvilTerran> er, dfan
10:21:14 <dfan> Okey doke, easy enough to write it myself but I didn't want to be unidiomatic
10:21:33 <EvilTerran> "\n -> not . null . drop (n-1)" would do it :)
10:21:38 <byorgey> dfan: as you probably know, saying 'length l > n' is bad, since length will traverse the entire list
10:21:39 <ziman> dfan, null . drop (n-1) ;)
10:21:43 <byorgey> but that's probably why you were asking =)
10:21:44 <dfan> byorgey: Exactly
10:22:10 <mib_mnl88jo1> byorgey: thanks I'll  check this right now
10:23:13 <dfan> EvilTerran, good point, saves me from writing a recursive definition
10:24:07 <Holle_> so i take onButtonPress drawingArea ... and where do i get the coordinates?
10:24:10 <vixey> > infinity > length [1..100]
10:24:11 <lambdabot>   Couldn't match expected type `Natural' against inferred type `Int'
10:24:15 <vixey> aw.
10:24:19 <vixey> > infinity > genericLength [1..100]
10:24:21 <lambdabot>   True
10:24:28 <vixey> > 30 > genericLength [1..]
10:24:29 <lambdabot>   * Exception: stack overflow
10:24:31 <vixey> > 30::Natural > genericLength [1..]
10:24:32 <lambdabot>   <no location info>: parse error on input `..'
10:24:37 <vixey> > (\30::Natural) > genericLength [1..]
10:24:38 <lambdabot>   <no location info>: parse error on input `)'
10:24:39 <vixey> > (30::Natural) > genericLength [1..]
10:24:40 <lambdabot>   False
10:24:55 <athos> oO
10:24:59 <athos> , src ''Natural
10:25:05 <lunabot>  type Natural f g = (:~>) f g
10:25:13 <athos> Okay.
10:25:13 <EvilTerran> not that one
10:25:15 <rwbarton> That's different, from category-extras
10:25:17 <EvilTerran> ?src Natural
10:25:18 <lambdabot> Source not found. :(
10:25:26 <EvilTerran> > 3 :: Natural
10:25:27 <lambdabot>   3
10:25:29 <EvilTerran> hm
10:25:39 <athos> > (-1)::Natural
10:25:41 <lambdabot>   * Exception: Natural: (-)
10:25:48 <Holle_> onMotionNotify drawingArea True $ \Motion {eventX = x, eventY = y} -> do.. works
10:25:49 <athos> :-)
10:25:57 <Holle_> but not onButtonPress ./
10:26:37 <vixey> Zero | Succ Natural = Natural
10:28:07 <Holle_> what do i have to write?
10:28:14 <Badger> :t (;~>)
10:28:16 <lambdabot> parse error on input `;'
10:28:21 <Badger> :t (:~>)
10:28:22 <lambdabot> Not in scope: data constructor `:~>'
10:29:01 <rwbarton> , src '':~>
10:29:03 <lunabot>  luna: parse error on input `:~>'
10:29:06 <rwbarton> , src ''(:~>)
10:29:12 <lunabot>  type (:~>) f g = forall a . (f a) -> g a
10:30:03 <vixey> , listToMaybe :: ([] :~> Maybe)
10:30:05 <lunabot>  luna: Illegal operator `:~>' in type `[] :~> Maybe'
10:30:39 <rwbarton> , listToMaybe :: ((:~>) [] Maybe)
10:30:41 <lunabot>  luna: No instance for (GHC.Show.Show ([a] -> Data.Maybe.Maybe a))
10:31:00 <rwbarton> @tell mmorrow turn on -XTypeOperators in lunabot
10:31:01 <lambdabot> Consider it noted.
10:34:17 * loadquo has been reading about arrows
10:34:47 <loadquo> Are they used to implement 'par'? Or am I completely off in the wrong direction?
10:35:42 <Heffalump> completely the wrong direction :-)
10:35:55 <Heffalump> par is a low-level runtime system thing
10:36:16 <Heffalump> arrows are a high level abstraction that are independent of the compiler, apart from the arrow syntax that's implemented in the frontend
10:38:11 <loadquo> But arrows can be used to model parallel processes, right?  I had just wondered how the system kept its model correct...
10:38:34 <Heffalump> there's not much work to keep the model correct, because of purity
10:38:48 <Heffalump> I guess arrows might be of some use in modelling parallel processes with state, I don't really know.
10:39:06 <int-e> Holle_: http://hpaste.org/13833
10:39:43 <enticingjelly> i love continuations
10:40:06 <dons> Heffalump: arrows are used of course to model hardware
10:40:19 <enticingjelly> about the same as i want to stab them. or fear them stabbing me.
10:40:25 <dons> things with lots of parallel strands, obviously. just not processes afaik
10:40:45 <dons> it would be interesting: arrows + reactive/yampa .. stateful parallel process models with good assurance
10:41:10 * augustss cannot get enthusiastic about arrows.
10:41:29 <Heffalump> I keep getting enthusiastic and then disillusioned
10:41:37 <dons> hehe. they're not making much headway
10:41:46 <Heffalump> they never solve the problems I think they will, and the syntax is incomprehensible
10:41:57 <augustss> I can't even remember the syntax.  It's too bizarre.
10:42:07 <Holle_> int-e: that i'am was looking for! thanks!
10:42:13 <dons> i don't believe the syntax is used on any hackage package.
10:42:25 <dons> i have seen a project   that used it once though, at university
10:42:36 <dons> for circuit description
10:43:44 <rwbarton> A haskell interpreter that accepts data declarations, class instances, qualified imports, etc.: http://hpaste.org/13834#a1
10:44:01 <dons> heh.
10:44:12 <dons> you could layer that over ghc-api/hint and we'd have something :)
10:44:34 <dons> this is actually the approach simonmar was advocating a while ago, iirc. just wrapping things
10:44:44 <Heffalump> replacing ghci?
10:44:44 <rwbarton> dons: It's just a small wrapper over ghci :)
10:44:56 <dons> wrapping
10:45:00 <dons> to add decls
10:45:15 <dons> i'm not sure how serious he  was
10:45:31 <rwbarton> dons: Yeah, with an actual api I could fix a lot of the shortcomings of this method
10:45:48 <BrokenClockwork> I want to build filter, which extracts from a String, everything but [a..z], I am trieing to do this with filter filter (\x -> sth. [a..z] sth.) "That's my @€§ String"
10:46:22 <BrokenClockwork> however I don't know yet how to apply the [a..z] list on the filter arguments
10:46:46 <dons> `elem` ?
10:46:58 <dons> > 'x' `elem` ['a'..'z']
10:47:00 <lambdabot>   True
10:47:10 <BrokenClockwork> oh yes
10:47:17 <byorgey> @type elem
10:47:19 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
10:47:19 <dons> > map (flip elem ['a'..'z']) "Haskell!!"
10:47:21 <lambdabot>   [False,True,True,True,True,True,True,False,False]
10:47:32 <BrokenClockwork> sure, sometimes I forget the easiest things :D
10:48:00 <Heffalump> anyone know when type families will support equality constraints in superclass contexts?
10:48:30 <dons> ChilliX knows.
10:48:41 <Heffalump> are you sure he knows? :-)
10:48:46 <baaba> @pl \x -> f (g x) x
10:48:47 <lambdabot> f =<< g
10:51:43 <BrokenClockwork> is the syntax \x -> or \xs -> and so on, only for filter?
10:51:48 <BrokenClockwork> or what does \.. mean?
10:51:57 <BrokenClockwork> never saw it before I've used filter
10:52:02 <Heffalump> BrokenClockwork: it's for anything where you want a function
10:52:07 <Heffalump> it just makes an anonymous function
10:52:13 <portnov> lambda-function
10:52:55 <BrokenClockwork> ah lambda function? now I remember, our prof used for our haskell lambda interpreter also the \ instead of Lambda
10:53:08 <rwbarton> > (\x -> x + 1) 17
10:53:10 <lambdabot>   18
10:54:10 <portnov> \ is notation for Lambda - there is no Lambda letter on keyboard :)
10:54:20 <mauke> > (\x -> [x,x,x]) 'λ'
10:54:22 <lambdabot>   "\955\955\955"
10:54:34 <hydrapheetz> Wait, \whatever is a lambda?
10:55:06 <hydrapheetz> I'm confused
10:55:09 <byorgey> hydrapheetz: the short answer is, it introduces an anonymous function.
10:55:10 <mauke> > (\λ -> λ) "lambda"
10:55:12 <portnov> > (\whatever -> whatever + 2) 15
10:55:12 <lambdabot>   "lambda"
10:55:14 <lambdabot>   17
10:55:18 <hydrapheetz> Ah
10:55:41 <hydrapheetz> I need to find myself a good tutorial
10:55:44 <byorgey> hydrapheetz: historically, the greek letter lambda was used by Alonzo Church in his calculus which came to be known as the 'lambda calculus'
10:56:07 <byorgey> and it stuck =)
10:56:11 <hydrapheetz> Oh, neat.
10:56:39 <byorgey> although there is some question over whether he meant to use lambda or if it was a typographical accident.
10:57:25 <hydrapheetz> > (\cake -> mod cake 50) 49
10:57:27 <lambdabot>   49
10:57:45 <aliell> does haskell have a vm?
10:58:18 <dons> kinda.
10:58:36 <aliell> can it do something like this: http://wiki.brianweb.net/NestedVM/NestedVM
10:58:37 <hydrapheetz> Oh, that makes sense.
10:58:40 <dfan> I have a PokerHand datatype with 10 constructors (HighCard, OnePair, TwoPair, etc.)
10:58:57 <dfan> and I'd like to express their relative rank without writing out n^2/2 cases
10:59:10 <dfan> I can't derive from Eq because the constructors take arguments
10:59:14 <dons> aliell: interesitng. probably not without difficulty, as haskell's runtime relies on a lot of low level native details
10:59:21 <dons> (i.e. it runs on bare metal with minor mods)
10:59:37 <dfan> Right now I just have 10 lines of the form pokerRank HighCard _ _ _ _ _ = 0, pokerRank OnePair _ _ _ _ = 1
10:59:46 <rwbarton> dfan: you mean you can't derive from Enum?
10:59:52 <dfan> Is there anything more concise?
10:59:55 <dfan> Sorry, yes, Enum
11:00:07 <rwbarton> dfan: If you just want to compare ranks, you can derive Ord
11:00:12 <dfan> Oho
11:00:14 <Lemmih> As the maintainer of an atypical Haskell implementation, I object to the notion of a "Haskell vm".
11:00:20 <rwbarton> dfan: although that might not work depending on what the arguments to the constructors are
11:00:43 <dfan> Well, it compiled :)
11:00:44 <rwbarton> dfan: the derived Ord order is by constructor, then lexicographically on the arguments
11:01:01 <aliell> dons: so, there is no way of wrapping existing huge c++ code to haskell without loads of manual job?
11:01:03 <dons> Lemmih: say we ran librts on top of xen, and then ran haskell programs on top of that. wouldn't ghc's rts be a vm of sorts?
11:01:11 <dons> aliell: there are tools to automate it
11:01:14 <dfan> Hmm, that might do everything automatically for me, then
11:01:18 <dons> perhaps look at haskell-qt for examples
11:01:27 <dons> not easy though, C++.
11:01:57 <jberryman> rwbarton: which is probably eactly what he wants if the constructors hold cards
11:02:02 <Lemmih> dons: Sure, but GHC isn't Haskell.
11:02:20 <dfan> Awesome, this does a complete poker-hand evaluation for me for free
11:02:21 <rwbarton> jberryman: As long as the cards don't have suits, or have an appropriate Ord instance for the purpose
11:02:27 <dfan> as jberryman noted
11:02:37 <dfan> I'm just storing ranks
11:02:39 <aliell> dons: ffi is just semi-automated, why there is no swig wrapper for haskell?
11:02:43 <rwbarton> then you're all set
11:02:48 <dfan> Yep :) Thanks!
11:03:07 <dons> aliell: that's a very good question.
11:03:16 <dons> we've written many of our own tools. but swig hasn't been on the radar
11:03:17 <Lemmih> dons: So you can run GHC on the bare metal, and GHC includes (among other things) a Haskell compiler.
11:03:32 <dons> Lemmih: yes, point taken. :)
11:03:47 <dons> lemmih joins the 'haskell is not ghc' support group :)
11:04:35 <aliell> dons: why not? haskell people are not into using existing c++ code as the others are or what?
11:04:45 <pejo> Lemmih, what are your short term plans for said Haskell compiler?
11:05:23 <Lemmih> pejo: Fix its bugs by any means necessary.
11:06:16 <Lemmih> pejo: After that, support GCing and possibly exceptions. After that, world domination.
11:06:31 <aliell> what about adobe alchemy (compiling c++ to actionscript binary)? undoable for haskell or easier for haskell?
11:10:27 <jberryman> I'm trying to define a comonad instance for a binary search tree, and I think it all looks good, except that 'coreturn' doesn't make sense for my empty End constructor
11:10:30 <jberryman> that okay?
11:10:36 <erikc> aliell: ffi is tricky because most 'real' apps that use ffi are going to have custom requirements on binding (e.g. how much is skewed toward the host lang, how much toward the embedded lang, what are the policies on gc interaction, who owns what memory, can aggregates be passed by value)
11:11:43 <aliell> erikc: is there a better alternative?
11:13:13 <byorgey> jberryman: not really. =)
11:13:24 <byorgey> jberryman: why not define non-empty binary search trees instead?
11:13:35 <byorgey> it would probably work out better that way
11:14:06 <rwbarton> jberryman: maybe it would be better to define a comonad instance for the zipper on a binary search tree?
11:14:56 <erikc> aliell: not really :), best thing that can be done imo is to have a rich library of parsers so its easy for ppl to write their own binding generators
11:16:11 <aliell> erikc: what happened to all these binding projects: http://hackage.haskell.org/trac/summer-of-code/query?status=new&status=assigned&status=reopened&group=topic&type=proposed-project&order=priority
11:16:29 <dancor> how do i parse a .cabal file?  i'm poking around Distribution.PackageDescription but can't really tell
11:16:36 <jberryman> byorgey: uh... because I already wrote the module... damn.
11:16:47 <dcoutts> dancor: yep, that's right. And the Distribution.PackageDescription.Parse
11:17:08 <jberryman> rwbarton: yeah, I have a lot of linksopen about comonadic zippers but haven't really dove into them yet
11:17:22 <erikc> aliell: dunno
11:18:05 <byorgey> jberryman: if coreturn can't be defined, then it's not a valid comonad instance.  but that doesn't mean the coreturn and cobind/extend functions might not be useful in and of themselves, but just don't put them in a comonad instance.
11:21:47 <jberryman> byorgey: thanks, it does seem to satisfy the comonad laws though. at least as laid out here: http://tinyurl.com/99hw9s
11:22:10 <ztirf> @pl \x -> g n x / h n x
11:22:11 <lambdabot> ap ((/) . g n) (h n)
11:22:23 <ztirf> @pl \x -> (g n x) / (h n x)
11:22:23 <lambdabot> ap ((/) . g n) (h n)
11:24:03 <loadquo> The Yampa tutorial (http://www.haskell.org/yampa/AFPLectureNotes.pdf) is very good for explaining arrows.
11:27:08 <BrokenClockwork> actually my palindrome function is working now, however, I wanted to add sth. and now it doesn't http://hpaste.org/13835
11:27:19 <BrokenClockwork> any idea where the mistake is?
11:27:39 <pumpkin> BrokenClockwork: if you told us what the error was, it might help
11:28:34 <BrokenClockwork> ok, when I use the upper one, every input is correctly answered with true or false
11:28:41 <BrokenClockwork> on the lower one: nothing happens
11:28:51 <pumpkin> why are you outputting "True" and "False" and not Bools?
11:28:55 <BrokenClockwork> the programe let just jump down the cursor
11:29:06 <rwbarton> BrokenClockwork: because your filter is removing all the newlines
11:29:14 <rwbarton> BrokenClockwork: you probably want to do these steps in a different order :)
11:29:33 <rwbarton> interact $ unlines . map f . lines  is a good idiom
11:30:01 <BrokenClockwork> yeah that would make it much shorter, but first I wanted to know how the whole IO/interact thing works :)
11:30:42 <rwbarton> Well, it's the same, just grouping things in a way that makes it a lot clearer what's going on
11:30:52 <BrokenClockwork> true
11:31:18 <mm_freak> the problem with interact is that you effectively cannot do more than simulating some coreutils command
11:31:20 <ddarius> aliell: There are matlab bindings, llvm bindings, a parser/pretty printer for C, python ffi stuff, dbus bindings, partial gsl bindings
11:32:01 <mm_freak> oh well, you could write another ELIZA =)
11:32:22 <aliell> ddarius: where are these bindings? is there a repo?
11:32:52 <pumpkin> aliell: hackage.haskell.org
11:33:00 <pumpkin> I couldn't get the matlab bindings to compile for me though
11:33:11 <pumpkin> http://hackage.haskell.org/packages/archive/pkg-list.html
11:33:22 <pumpkin> aliell: cabal-install also helps
11:35:44 <BrokenClockwork> rwbarton: Okay, I jsut switched makeLow and my filter, same result, I guess you mean still another order?
11:35:55 <aliell> pumpkin: are they linked to these projects? http://hackage.haskell.org/trac/summer-of-code/query?status=new&status=assigned&status=reopened&group=topic&type=proposed-project&order=priority
11:36:22 <jberryman> byorgey: btw, I can't think of how to define "non-empty binary search tree" without a bunch of constructors
11:36:54 * tibbe is lost in a continuation
11:36:56 <pumpkin> aliell: those are summer of code project ideas... not sure if the ones on hackage arose out of some of the ideas on that list, but they should be there
11:37:19 <rwbarton> BrokenClockwork: you have to split into lines before the filter (which throws away all the newlines)
11:37:31 <rwbarton> BrokenClockwork: or, don't filter out newlines
11:37:35 <BrokenClockwork> you mean \n ?
11:37:42 <rwbarton> BrokenClockwork: this is why the interact $ unlines . map f . lines idiom is good :)
11:37:46 <rwbarton> yes
11:37:52 <BrokenClockwork> yeah true
11:38:20 <BrokenClockwork> I never used $ and . correctly before, but when my programme works, I will rewrite in in the cool idiom syntax
11:38:51 <mauke> interact (\x -> unlines (map f (lines x)))
11:39:45 <ztirf> can one make a version of find that works on functors instead of lists?
11:40:04 <sjanssen> ztirf: not Functors
11:40:17 <Tom_Welling> fucking nerds
11:40:18 <sjanssen> it could be done with Foldable
11:40:22 <Tom_Welling> i bet none of you have a girlfriend
11:40:28 <Tom_Welling> go fondle your laptops
11:40:28 --- mode: ChanServ set +o sjanssen
11:40:31 --- mode: sjanssen set +b *!*=4b3d5d86@gateway/web/ajax/mibbit.com/x-d6c9de57f90bcdc0
11:40:31 --- kick: Tom_Welling was kicked by sjanssen (sjanssen)
11:40:35 <mauke> Tom_Welling: I bet you're on IRC
11:40:46 <sjanssen> hmm, mibbit
11:40:51 <Olathe> The proper response to that is "Aren't you our girlfriend ?"
11:40:53 <oklopol> i have a laptop!
11:40:59 <czShadoW> :-)
11:41:00 <mauke> oklopol: I don't :(
11:41:01 <oklopol> ...oh, wait, never mind
11:41:04 <ikonia> sjanssen: prepare to get spammed
11:41:04 <BrokenClockwork> how do I write "\n" as String?
11:41:05 <pumpkin> I'm tempted to ban all of mibbit sometimes
11:41:11 <mauke> BrokenClockwork: "\n"
11:41:14 <BrokenClockwork> ok
11:41:15 <ikonia> sjanssen: I've just removed him from #ubuntu and I'm getting spammed by him
11:41:15 <sjanssen> ikonia: yeah
11:41:16 <aliell> maybe someone could get rid of thos 'Numeric (1), Numerical (1)' tags in hackage, it's embarrassing for a math friendly language :)
11:41:18 <Milenko> mibbit is evil..
11:41:19 <Milenko> lol
11:41:29 <Milenko> stupid frogs
11:41:29 <ikonia> 9:38 -Tom_Welling(i=4b3d5d86@gateway/web/ajax/mibbit.com/x-d6c9de57f90bcdc0)-  homo
11:41:33 <ikonia> etc etc etc
11:41:47 <sjanssen> ikonia: I'm not getting any messages.  Is Tom_Welling registered?
11:41:53 --- mode: ChanServ set -o sjanssen
11:41:54 <ikonia> nah, doesn't look like it
11:41:59 <ikonia> sjanssen: you may have got lucky
11:42:36 <Olathe> Well, he's not logged in at any rate.
11:42:47 <ztirf> sjanssen: why is foldable required? Surely you can find something even if there's no order?
11:42:56 <BrokenClockwork> lexical error in string character literal at '\'
11:43:06 <BrokenClockwork> well it seems I cannot just write "\n" or '\n'
11:43:09 <rwbarton> > "\n"
11:43:10 <lambdabot>   "\n"
11:43:13 <sjanssen> ztirf: the problem is that Functor doesn't allow you to get items out of the structure
11:43:21 <BrokenClockwork> also my syntax highlightening is thrown up... mhh :(
11:43:36 <ddarius> Saying that something is a functor is a pretty weak statement.
11:44:49 <BrokenClockwork> > elem "\" "\n"
11:44:50 <lambdabot>   <no location info>: parse error on input `\'
11:44:57 <BrokenClockwork> this is what I mean
11:45:19 <rwbarton> You can't write "\"
11:45:23 <RayNbow> > elem '\' "\n"
11:45:25 <lambdabot>   <no location info>:
11:45:25 <lambdabot>      lexical error in string/character literal at chara...
11:45:28 <RayNbow> > elem '\\' "\n"
11:45:30 <lambdabot>   False
11:45:34 <ztirf> sjanssen: hmm, I see.  And lo and behold, Data.Foldable has a find.  Thanks!
11:45:36 <BrokenClockwork> ok :)
11:46:07 <Milenko> this is gonna sound dumb
11:46:12 <Milenko> but what the hell is haskell..
11:46:23 <sjanssen> @where haskell
11:46:24 <lambdabot> http://haskell.org/
11:46:32 <pumpkin> Milenko: http://tinyurl.com/6qmfcu
11:46:33 <oklopol> he was this logician
11:46:35 <sjanssen> Milenko: a programming language, see link above
11:46:41 <sjanssen> @googleit haskell programming language
11:46:43 <Milenko> is it related to any other languages?
11:46:44 <lambdabot> http://en.wikipedia.org/wiki/Haskell_(programming_language)
11:46:44 <lambdabot> Title: Haskell (programming language) - Wikipedia, the free encyclopedia
11:46:47 <oklopol> we're the fans of his
11:46:56 <Olathe> @where oxen
11:46:57 <lambdabot> I know nothing about oxen.
11:47:01 <sjanssen> Milenko: the ML family
11:47:07 <BrokenClockwork> So how do I check for a newline in a string then?
11:47:08 <loadquo> Haskell =  h ++ ask ++ ell
11:47:23 <jeffwheeler> > "H" ++ "ask" ++ "ell"
11:47:24 <byorgey> > '\n' `elem` "foo\nbar"
11:47:26 <lambdabot>   True
11:47:26 <lambdabot>   "Haskell"
11:47:35 <jeffwheeler> Yours came out first . . . ?
11:47:42 <Milenko> ...my brain is burning..
11:47:46 <roconnor> from glancing at [Haskell-cafe] Re: [Haskell] HaskellWiki Upgrade Aborted, I get the impression that haskell needs to switch to using Nix.
11:47:47 <Olathe> > 'z' : 'o' : "mg"
11:47:48 <lambdabot>   "zomg"
11:47:53 <Milenko> ok i stumbled into the wrong channel lol
11:47:59 <roconnor> ...haskell.org needs to switch...
11:47:59 <Milenko> nice meeting you all
11:48:01 <Milenko> bye now
11:48:03 <pumpkin> roconnor: what does it use?
11:48:13 <pumpkin> people are weird
11:48:14 <BrokenClockwork> > elem "\n" "yes\nhere"
11:48:15 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
11:48:15 <rwbarton> BrokenClockwork: ... of course you don't need to, because the lines function does what you want already...
11:48:16 <roconnor> pumpkin: The machine is running RHEL AS 3 update 9 with Linux 2.4.21.
11:48:19 <jeffwheeler> pumpkin: RHEL, right?
11:48:20 <sjanssen> @girl19
11:48:20 <pumpkin> ah :/
11:48:21 <lambdabot> am I supposed to be frantic with terror and anxiety?
11:48:27 <sjanssen> @girl19
11:48:28 <lambdabot> LOL
11:48:29 <Olathe> @type elem
11:48:30 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
11:48:32 <BrokenClockwork> okay, then I will do it the other way around
11:48:35 <roconnor> pumpkin: which is not incompatible with Nix as I understand
11:48:50 <byorgey> BrokenClockwork: "\n" is not the same as '\n'
11:49:03 <roconnor> @type "\n"
11:49:04 <lambdabot> [Char]
11:49:10 <roconnor> @type '\n'
11:49:15 <byorgey> BrokenClockwork: the first is a String (list of Chars) with one element; the second is a Char
11:49:15 <lambdabot> Char
11:49:39 <roconnor> > "\n" == ['\n']
11:49:41 <lambdabot>   True
11:49:47 <roconnor> > "\n" == '\n':[]
11:49:49 <lambdabot>   True
11:49:54 <byorgey> > '\n' `elem` "\n"
11:49:56 <lambdabot>   True
11:50:03 <roconnor> > head "\n" ==
11:50:05 <lambdabot>   <no location info>: parse error on input `;'
11:50:07 <roconnor> > head "\n" == '\n'
11:50:09 <lambdabot>   True
11:52:49 <Olathe> @hoogle [a] -> [a] -> Bool
11:52:50 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
11:52:50 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
11:52:50 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
11:53:06 <Olathe> > isInfixOf "test" "omg test"
11:53:08 <lambdabot>   True
11:53:11 <Olathe> > isInfixOf "test" "omg tes"
11:53:13 <lambdabot>   False
11:53:24 <Olathe> @src isInfixOf
11:53:25 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
11:53:32 <Olathe> Ah hah !
11:54:22 <rwbarton> needle `isInfixOf` haystack = (needle `isPrefixOf`) any (tails haystack) -- practically english
11:54:25 <rwbarton> oops, `any`
11:54:36 <Holle_> i'm using gtk2hs. typing something in ghci returns always an exception: C:/Program Files/Gtk2Hs/HSglib.o: unknown symbol `___stginit_glibzm0zi9zi13_SystemziGlibziUTFString_': unable to load package `array-0.1.0.0'
11:54:39 <Gracenotes> oh my, don't longer variable names mean huge performance overhead? :O
11:54:50 <Olathe> `thingy` is evil !
11:55:06 <roconnor> Gracenotes: only for records
11:55:29 <pumpkin> really?
11:55:36 <dcoutts> Holle_: does it work with ghc --make ?
11:55:39 <Gracenotes> but, using "haystack" instead of "h" slows your program down by orders of magnitude!
11:55:40 <roconnor> pumpkin: depends on your version of GHC
11:55:42 <Holle_> yes
11:55:56 <pumpkin> roconnor: o.O so that's why haskellers always use short variable names! :P
11:56:18 <roconnor> :P
11:56:21 <pumpkin> roconnor: oh I remember reading about that... is it related to error messages containing names and the names throwing inlining quotas over the threshold?
11:56:30 <roconnor> pumpkin: yes
11:56:40 <pumpkin> ah yeah
11:56:53 <mauke> preflex: zdec ___stginit_glibzm0zi9zi13_SystemziGlibziUTFString_
11:56:53 <preflex>  ___stginit_glib-0.9.13_System.Glib.UTFString_
11:56:55 <Holle_> but i want to use the live input of ghci for testing
11:56:55 <dons> Gracenotes: tiny perf. overhead in a particular optimisation case, with records :)
11:57:28 <Gracenotes> :)
11:58:07 <bigorilla> @src String
11:58:07 <lambdabot> type String = [Char]
11:58:34 <Olathe> > let pos needle haystack = map fst.filter snd.zip [0..].map (isPrefixOf needle).tails $ haystack in pos "oo" "ooooo"
11:58:36 <lambdabot>   [0,1,2,3]
11:58:38 <Holle_> what should i do?
11:58:53 <jeffwheeler> @let f = foldr (.) id
11:58:56 <lambdabot>  Defined.
11:59:04 <Olathe> > f
11:59:06 <lambdabot>       Ambiguous occurrence `f'
11:59:06 <lambdabot>      It could refer to either `L.f', defined a...
11:59:16 <jeffwheeler> @let compose = foldr (.) id
11:59:19 <lambdabot>  Defined.
11:59:26 <jeffwheeler> Any better name for that?
11:59:52 <jeffwheeler> > f [head, (:[1, 2])] $ 3
11:59:54 <lambdabot>       Ambiguous occurrence `f'
11:59:54 <lambdabot>      It could refer to either `L.f', defined a...
12:00:01 <jeffwheeler> > compose [head, (:[1, 2])] $ 3
12:00:02 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
12:00:03 <lambdabot>        Expect...
12:00:08 <baaba> > compose $ take 10 $ fix ((+1):) 10
12:00:08 <jeffwheeler> > compose [head, (:[1, 2])] $ [3, 4]
12:00:08 <lambdabot>   Couldn't match expected type `t -> [a]'
12:00:10 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
12:00:10 <lambdabot>        Expect...
12:00:21 <Trafalgard> hrm
12:00:26 <jeffwheeler> Or perhaps compose is the best name.
12:00:46 <baaba> > (compose $ take 10 $ fix ((+1):)) 10
12:00:47 <lambdabot>   20
12:01:24 <portnov> :t fix
12:01:25 <lambdabot> forall a. (a -> a) -> a
12:01:57 <dons> dcoutts: is http 4 support for cabal-install on the horizon?
12:02:15 <dcoutts> dons: yes, we've had patches contributed
12:02:41 <Olathe> jeffwheeler: You can't have that list.
12:02:42 <dcoutts> dons: I'd like a http-4 release that solves our proxy problems, by making rfc compliant http requests
12:02:45 <Holle_> isn't it possible to use ghci together with gtk2hs?
12:02:54 <dons> ok. a bump would be good. i'm pinning HTTP 3 in Arch for now.
12:02:58 <dcoutts> Holle_: in some gtk2hs versions it's broken
12:03:00 <dons> but there's   bound to be people wanting HTTP 4 soon
12:03:18 <Holle_> do you know a version that works?
12:03:18 <jeffwheeler> Olathe: it would seem that way. :-/
12:03:26 <Olathe> @type head
12:03:28 <lambdabot> forall a. [a] -> a
12:03:31 <Olathe> @type (:[1, 2])
12:03:33 <lambdabot> forall a. (Num a) => a -> [a]
12:03:34 <dcoutts> Holle_: I think 0.9.12 with ghc-6.8.2 worked
12:03:36 <Olathe> Different types.
12:03:47 <Olathe> It's like you can't have [1, "test"]
12:04:08 <jeffwheeler> Oh, yeah, of course. You're right.
12:04:38 <Holle_> i'll try it.
12:04:46 <dcoutts> dons: see http://hackage.haskell.org/trac/hackage/ticket/352
12:04:53 <Olathe> > foldr (.) id [(+2), (+3)] $ 4
12:04:55 <lambdabot>   9
12:05:19 <dons> yup
12:05:22 <dcoutts> dons: we should see if the problem persists with http-4, or if that got fixed. I think someone sent a patch to fix it to bjorn, hopefully the patch got forwarded with the rest of them.
12:06:14 <dons> yeah, sof's done a lot of work on http now.
12:06:28 <dcoutts> dons: note the way it's making requests "GET http://hackage.haskell.org/packages/archive/00-index.tar.gz HTTP/1.1" rather than the correct: "GET /packages/archive/00-index.tar.gz HTTP/1.1\nHost: hackage.haskell.org"
12:06:33 <dons> yeah
12:06:57 <dcoutts> it does not matter for direct http connections (it's a deprecated HTTP-1.0 style)
12:07:06 <dcoutts> but it does matter for proxies, especially transparent proxies
12:10:32 <EvilTerran> jeffwheeler / Olathe, incidentally, your "compose" function is mconcat for (Endo a), iirc
12:10:34 <EvilTerran> ?src Endo
12:10:34 <lambdabot> Source not found. My pet ferret can type better than you!
12:10:38 <EvilTerran> ,src ''Endo
12:10:43 <lunabot>  newtype Endo a = Endo {appEndo :: (a -> a)}
12:11:44 <jeffwheeler> EvilTerran: I found it in the Yi source; it was called 'list' in Yi.Syntax.Latex
12:18:23 <koeien> in Template Haskell, how do I abort the current compilation in the Q monad?
12:18:28 <koeien> there is no 'giveUp' anymore, it seems
12:19:27 <sjanssen> koeien: use fail?
12:19:32 <koeien> monadic fail?
12:19:35 <sjanssen> yeah
12:19:38 <sjanssen> just a guess
12:19:38 <koeien> ok, i'll try
12:20:10 <koeien> hmm. nice suggestion: it worked :) thanks
12:22:13 <drdozer> are there cases where you should use a struct of functions vs a class to pass around a bundle of operations?
12:22:42 <koeien> drdozer: yes, if you would like more than one possible implementation for each type
12:23:11 <koeien> however, it may be easier to define another type for each behavior. depends on your use case
12:26:51 <drdozer> well, I have a graph-traversal algorithm that needs parameterising with 5 functions
12:27:30 <drdozer> I think all 5 can be chosen independently of each other
12:28:41 <drdozer> koeien: I guess I could do both? Have a struct that implements the class?
12:29:57 <koeien> if you want to use this function with different parameters for the same type, you'll need to pass it a record
12:30:03 <koeien> you can always try to define some defaults
12:30:13 <koeien> or, like sort and sortBy in the prelude
12:30:17 <koeien> @src sort
12:30:17 <lambdabot> sort = sortBy compare
12:30:21 <koeien> :t sortBy
12:30:23 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
12:35:30 <drdozer> looks like it's a record then
12:35:38 <crutcher> whee!
12:35:40 <JuanDaugherty> anyone know of a UML to Haskell tool/path/bridge?
12:36:26 <crutcher> ow? UML is OO taken to its most absurd extent, how would you map it?
12:36:42 <crutcher> I know of UML<->SQL mappings
12:37:08 <JuanDaugherty> crutcher, "ow?"?
12:37:34 <crutcher> ow - an expression of pain
12:37:46 <crutcher> as in: ow, that makes my head hurt
12:37:55 <JuanDaugherty> Acknowledged.
12:38:04 <crutcher> No, I'm interested. What do you want to map?
12:38:46 <crutcher> I think you _could_ build a graphical language for working with haskell types and compositions, and that might be cool
12:39:02 <JuanDaugherty> Obviously, UML designs. I'm looking to use not build.
12:39:07 <crutcher> Or you could build a DSL for some app, and then bind a subset of UML to/from your DSL
12:39:18 <dons> JuanDaugherty: there's some uml tools, i think
12:39:21 <dons> google will find them
12:39:53 <JuanDaugherty> dons, I wouldn't be asking here if stfw'ing had yielded anything readily.
12:40:31 <JuanDaugherty> (or scanning my h package lists)
12:40:58 <crutcher> JuanDaugherty: http://scesi.fcyt.umss.edu.bo/benjo/summerHaskell/DetailHaskell.html
12:41:14 <crutcher> though the thesis is not at the listed URL
12:42:35 <JuanDaugherty> crutcher, Acknowledged.
12:44:55 <crutcher> I have a much less sexy question - what Exception instance can I use to make this return anything useful: try (return $ seq undefined ())
12:45:12 <crutcher> As is, I can't get it to compile
12:45:58 <ddarius> crutcher: try won't catch anything there.
12:46:35 <crutcher> I'm trying to write a test for threaded MVar code, and I've got some code which returns 'undefined'. I want to assert that it did in fact return 'undefined' by forcing the evaluation and catching the exception.
12:47:22 <ddarius> try (return $ seq undefined ()) <=> return undefined
12:47:28 <crutcher> so assume I've got a value 'x' of any type. I want a test (lets say in the IO monad) that forces its evaluation, and then returns True if it threw an exception, and False otherwise
12:48:04 <crutcher> hoogle doesn't seem to know what (<=>) means
12:48:24 <mauke> catch (x `seq` return False) (\_ -> return True)
12:48:26 <ddarius> <=> is metanotation.  Those expressions are observationally equivalent.
12:49:12 <crutcher> ddarius: are they? shouldn't try catch and handle the exception?
12:49:25 <rwbarton> crutcher: what exception?
12:49:26 <ddarius> crutcher: The exception doesn't get thrown until after try returns (if ever)
12:49:50 <dons> ?users
12:49:51 <lambdabot> Maximum users seen in #haskell: 649, currently: 642 (98.9%), active: 16 (2.5%)
12:50:14 <crutcher> should I be using Control.Exception.evaluate instead of return?
12:51:00 <crutcher> mauke: that blows up with an Ambiguous type error on the Exception instance, which is my original problem.
12:51:13 <crutcher> using GHC 6.10.1 on a mac
12:52:07 <mauke> catch (x `seq` return False) (\(_ :: SomeException) -> return True)
12:52:26 <ddarius> crutcher: In that case, yes.
12:53:58 <crutcher> So what's a reasonable instance of Exception?
12:54:37 <mauke> SomeException
12:55:49 <crutcher> oh, I thought that was a standin. Seriously?
12:56:42 <blackh> I got caught out by this SomeException business too - a note added to the haddocks would help.
12:56:44 <crutcher> catch (evaluate $ seq undefined False) ((\_ -> return True) :: SomeException -> IO Bool)
12:56:59 <crutcher> that seems to work fine :)
12:57:53 <jeffwheeler> 'feed' on Hackage is surprisingly nice.
12:58:19 * jeffwheeler wants to write an rss aggregator in Haskell.
12:59:36 <mauke> seq undefined False is the same as undefined
12:59:39 <vixey> foo
13:02:07 <dons> jeffwheeler: 'feed' is used commercially.
13:02:22 <dons> it should be pretty nice :) it had a bit of work on it .
13:02:34 <dons> an rss aggregator is all of 5 linnes
13:03:26 <jeffwheeler> dons: yeah, so a vty interface should be easy :)
13:03:35 <crutcher> Cool, that works. Now I just need to turn this into HUnit code
13:03:48 <jeffwheeler> dons: but desperately needed --- I'm tired of NNW on OS X
13:04:04 <pumpkin> use newsfire
13:04:12 <jeffwheeler> pumpkin: eh, no; I like that even less
13:04:22 <pumpkin> I want a good haskellish cocoa binding
13:04:25 <jeffwheeler> The keyboard interface is better on NNW.
13:04:36 <pumpkin> jeffwheeler: but it has a lamer name :P
13:04:39 <jeffwheeler> Yeah, HOC frustrates the heck out of me. I've got it to compile once . . .
13:04:40 <dons> llvm packaging, http://archhaskell.wordpress.com/2009/01/11/llvm-haskell-bindings/
13:04:46 <jeffwheeler> pumpkin: True. :P
13:05:27 <pumpkin> I really want to write cocoa apps in haskell
13:05:47 <pumpkin> someone needs to find a good way to overlay haskellism onto (ugh) cocoaism
13:05:51 <jeffwheeler> pumpkin: I really want the Cocoa interface for Yi to work.
13:06:04 <jeffwheeler> pumpkin: HOC seems to have good design, if it wasn't broken.
13:06:15 <jeffwheeler> I could even see it cabal-installable from Hackage.
13:06:19 <erikc> pumpkin: just write a binding to the obj-c runtime and pass messages around
13:06:28 <pumpkin> erikc: but that's not haskellish!
13:06:31 <pumpkin> no fun :)
13:06:47 <erikc> objc is smalltalk in c clothing though, i dont think you can make that haskellish :)
13:06:59 <drdozer> :i sortBy
13:07:05 <pumpkin> objcMsgSend arr "objectAtIndex:" [1]
13:07:05 <jeffwheeler> I want to know about those bridges to Python and Ruby. It seems like something could use that.
13:07:07 <drdozer> sorry, wrong window
13:07:29 <crutcher> erikc: you could probably do an FRP binding that would work rather nicely
13:07:31 <jeffwheeler> IIRC, they now provide the interfaces in XML form, so the bridges can be created programmatically, or something of that sort.
13:08:14 <pumpkin> jeffwheeler: rubycocoa is kinda ugly, needing to translate from ruby objects to cocoa ones... macruby is ruby 1.9 with the objc runtime as its backing, so all basic ruby objects are actually their objc counterparts in memory... no marshalling/unmarshalling
13:08:45 <jeffwheeler> pumpkin: hmm, and I assume PyObjC is like the latter?
13:08:56 <erikc> macruby and nu (lisp on objc runtime) work well cause they are dynamic languages
13:08:58 <pumpkin> not sure, haven't looked at python options much
13:09:05 <pumpkin> erikc: yeah :/
13:09:26 <jeffwheeler> I remember PyObjC and one of the Ruby bindings was added for Leopard, but I never saw how they worked.
13:10:24 <Holle_> if have a polygone given as poly = [(70,200),(90,140),(120,140)]  :: [(Double,Double)] and want to draw this with cairo. writing moveTo 70 200 lineTo 90 140 ... works. but writing movtTo ((fst.head) x) 200 lineTo 90 140 ... turns the first point into three, as it seems :/ the result looks like three polygones. whats my failure?
13:11:11 <erikc> pumpkin: what im toying with is using quasiquoting to support [objc| arr objectAtIndex: 1]
13:11:21 <erikc> and then using quasiquoting patterns to be able to write message handlers
13:11:23 <pumpkin> erikc: ooh!
13:11:31 <jeffwheeler> erikc: _that_ would be hot.
13:11:35 <pumpkin> that would be very neat :)
13:14:44 <crutcher> What's the style with haskell unittests? Are the usually put in the same file? In a different file?
13:15:27 <dons> different file, usually
13:15:53 <dons> check the testing chapter in RWH
13:15:59 <Holle_> 70 == ((fst.head) x) returns True. why prints cairo different versions?
13:16:20 <rwbarton> Holle_: your question makes about as much sense as "why does print (1+1) display 3?"
13:16:36 <dons> hmm.
13:16:52 <Holle_> rwbarton: sorry i don't understand?
13:17:00 <mux> dons: do you have any more time for helping me with that space leak? I'm really stuck and out of ideas
13:17:01 <rwbarton> Holle_: obviously you're not doing what you think you're doing
13:17:09 <jeffwheeler> > 70 == [(70, 14)]
13:17:11 <lambdabot>       No instance for (Num [(t, t1)])
13:17:11 <lambdabot>        arising from the literal `70' at...
13:17:12 <jeffwheeler> err
13:17:20 <jeffwheeler> forgot part of that :P
13:17:33 <jeffwheeler> > 70 == ((fst.head) [(70, 14)])
13:17:35 <lambdabot>   True
13:17:50 <crutcher> Holle_: you mean "70 == ((fst . head) x)" is equal to True?
13:17:56 <dons> mux. hmm. how about trying -cafe@
13:18:11 <dons> i have to admit i'm kinda treading water with open source these days. a lot going on
13:18:22 <Holle_> i mean 70 is the same as ((fst . head) poly)
13:18:37 <crutcher> yeah, okay. And?
13:18:52 <mux> dons: I understand - I'll try -cafe@ then
13:19:13 <dons> friendly, crutcher :)
13:19:28 <Holle_> why prints cairo different lines for 70 and for ((fst . head) poly)?
13:19:42 <crutcher> oh, hmm.
13:19:54 * mux thinks Holle_'s sentence doesn't typecheck somehow
13:20:18 <rwbarton> Holle_: is poly a global variable?
13:20:20 <mux> Holle_: trying to help you but I really don't understand what you're saying
13:20:28 <crutcher> So looking back at your first post, and without access to cairo myself, I have to say my suggestion is: it doesn't. I think you've given us a testcase that you beleive is minimal
13:20:46 <crutcher> but I think that somewhere it may actually be making more calls
13:21:09 <crutcher> because you are right, there should be no difference, which means there probably isn't.
13:21:10 <Holle_> poly is defined: poly = [(70,200),(90,140),(120,140)]
13:21:37 <ddarius> Holle_: Why don't you post all of your code to hpaste?
13:21:43 <rwbarton> Holle_: yeah, so something you are telling us must be false, and we have no idea what it is
13:21:55 <Holle_> where should i post it?
13:22:05 <crutcher> Got to http://hpaste.org
13:22:05 * mux wishes he could understand Core
13:22:16 <mux> I'd probably be able to spot where the space leak occurs if I did
13:22:19 <crutcher> mux: no, it was a Terrible Movie
13:22:28 <crutcher> ;)
13:22:36 <mux> heh
13:23:02 <crutcher> Holle_: and after you've pasted to it, put the url of your new past here
13:23:08 <crutcher> and we can read it.
13:23:23 <Holle_> http://hpaste.org/13836
13:23:36 <Holle_> its line 26/27
13:24:09 <rwbarton> OK, so x is not the same as poly
13:24:37 <Holle_> x ist poly !?
13:25:22 <jeffwheeler> Holle_: it seems to only be poly when called from drawGame, not drawAreas
13:25:28 <crutcher> its a border.
13:26:07 <Holle_> poly is of the same type as border
13:26:13 <Holle_> [TPoint]
13:26:23 <crutcher> border #4 has the same path as your original polygon, plus some more. So when you translate your polygon and print it, you still get border #4
13:27:00 <rwbarton> Holle_: you realize drawPolygon is being called 6 times right?
13:27:18 <Holle_> 6 times? why?
13:27:21 <rwbarton> once directly by drawGame, and five times by drawAreas, all with different arguments
13:27:22 <crutcher> turn off drawAreas in drawGame to test
13:27:29 <Holle_> ok :)
13:27:53 <Holle_> now it's right! stupid misktake :)
13:27:55 <crutcher> I think you can 'fix' this bug by just removing the Area #4 line, but lets test first
13:28:11 <crutcher> so add drawAreas back, but comment out Area #4
13:29:03 <Holle_> crutcher: then i have to change drawPolygon
13:29:21 <crutcher> what? why?
13:29:40 <crutcher> I'm just suggesting you remove one of your borders.
13:29:42 <Holle_> because drawPolygone isn't finished
13:30:13 <crutcher> Okay, well, have fun with that :)
13:30:25 <Holle_> thank you very much! :)
13:30:55 <atom> @srt foldr
13:30:55 <lambdabot> foldr f z []     = z
13:30:56 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:32:28 <knapr> how much of Haskell's static-inference typesystem is tied to its semantics? like could you even make such a system for Java or C++?
13:33:32 <vixey> knapr, haskells type system only really interacts with semantics when you have typeclasses in the mix
13:33:33 <pejo> knapr, you can design a strict language with a similar type system.
13:34:28 <CakeProphet> I don't think you'd need a purely functional language either to use Haskell's type system.
13:35:02 <crutcher> knapr: C# has the beginnings of an inference system, and so does PyPy
13:35:05 <pumpkin> @faq can haskell in ghc 6.12 have dependent types please?
13:35:05 <lambdabot> The answer is: Yes! Haskell can do that.
13:35:09 <vixey> CakeProphet, see: Ocaml
13:35:10 <pumpkin> thank you lambdabot
13:35:14 <pejo> CakeProphet, (caught it in the log a couple of days ago, replying now) Salmon isn't meant to be a general purpose language.
13:35:53 <CakeProphet> pejo:  Salmon isn't the name of it
13:35:59 <CakeProphet> I can't remember what it's called
13:36:44 <CakeProphet> something with spring in the name
13:37:02 <CakeProphet> it's one of my favorite programming languages ever.
13:37:21 <pejo> CakeProphet, ok, then disregard my reply. :-)
13:37:27 <CakeProphet> HOMESPRING
13:37:30 <CakeProphet> that's it.
13:38:18 <CakeProphet> http://xeny.net/HOtMEfSPRIbNG
13:38:35 <atom> is there a function in haskell that would tel me whether any of items in list1 are in list2, or do I have to write it myself?
13:38:40 <atom> tell*
13:38:51 <CakeProphet> intersect
13:38:53 <CakeProphet> I believe
13:38:55 <Heffalump> you have to write it yourself, but it's quite short
13:38:55 <CakeProphet> :t intersect
13:38:57 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
13:39:02 <dons> or use a Set
13:39:19 <dons> > intersect "haskell" "pascal"
13:39:20 <lambdabot>   "asll"
13:39:24 <BONUS> @pl \x y -> not . null $ intersect x y
13:39:24 <lambdabot> ((not . null) .) . intersect
13:39:24 <CakeProphet> > intersect [1,2,3] [3]
13:39:26 <lambdabot>   [3]
13:39:30 <crutcher> atom: do you want a Bool?
13:39:36 <crutcher> or do you want the intersection?
13:39:37 <atom> crutcher: yes.
13:39:38 <Olathe> > let anyInBoth xs ys = any (flip elem ys) xs in anyInBoth "zomg" "what"
13:39:40 <lambdabot>   False
13:39:43 <atom> crutcher: a Bool
13:39:47 <Olathe> > let anyInBoth xs ys = any (flip elem ys) xs in anyInBoth "zomg" "omg"
13:39:49 <lambdabot>   True
13:39:57 <atom> but you can get that from the intersection by comparing it to []
13:40:07 <pejo> knapr, there was someone asking about OO and Haskell on haskell-cafe the other week. (http://www.nabble.com/Thoughts-on-Haskell-and-OOP-td21246517.html)
13:40:47 <crutcher> atom: yes, but it is much cheaper.
13:40:54 <atom> crutcher: true.
13:40:58 <crutcher> atom: potentially infinately cheaper
13:41:04 <Olathe> (==[]) changed to not.null
13:41:23 <Olathe> Hmm, I think ==[] should be fast, though.
13:41:31 <crutcher> wait, I lie. Olathe is right
13:41:33 <atom> Olathe: intersetion isn't
13:41:36 <Heffalump> yes, but it requires an Eq constraint, which doesn't matter in this case, but does in general
13:41:39 <dons> adds an Eq constraint you don't need
13:41:47 <Heffalump> dons: except here where intersect requires it already
13:41:56 <dons> ah well, still, bad style
13:41:57 <Olathe> atom: Yeah, but it should only have to get the first element to do the check.
13:42:06 <Olathe> atom: So, the intersect will quit early.
13:42:22 <atom> damn haskell and its ubiquitous short-circuiting
13:42:22 <Olathe> @src intersect
13:42:22 <lambdabot> intersect = intersectBy (==)
13:42:32 <Olathe> @src intersectBy
13:42:33 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
13:43:17 <Olathe> @src anyBy
13:43:17 <lambdabot> Source not found. It can only be attributed to human error.
13:43:23 <Olathe> Heh
13:43:30 <Olathe> @src elemBy
13:43:30 <CakeProphet> rofl. anyBy is just any right?
13:43:31 <lambdabot> Source not found. Sorry.
13:43:35 <Olathe> Yes :)
13:45:49 <CakeProphet> atom, using sets would be cheaper, but unless you're comparing citizens of China to citizens of India I don't think you should care.
13:46:51 <atom> it's 5 symbolic constants of which one or two of each can be present in the list... sets are out, but in this particular case I only care about whether one of those is present.
13:47:59 <CakeProphet> oh. not.null.intersect constants1 constants2 should be fine
13:48:51 <Heffalump> apart from not type checking :-)
13:49:05 <atom> ?
13:49:21 <Heffalump> @type \constants1 constants2 -> not.null.intersect constants1 constants2
13:49:23 <lambdabot>     Couldn't match expected type `a -> [a1]'
13:49:23 <lambdabot>            against inferred type `[a2]'
13:49:23 <lambdabot>     In the second argument of `(.)', namely
13:49:28 <Heffalump> (it needs more brackets)
13:49:56 <knapr> in your experience would it be true to say: "OO is good for modeling unchanging systems, functional programming for chnaging ones?"
13:49:58 <atom> um... ghci isn't happy about the .intersect part - says "not in scope"
13:50:13 <atom> knapr: definitely not.
13:50:15 <Heffalump> @type Data.List.intersect
13:50:16 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
13:50:22 <Heffalump> you probably just need to import it
13:50:38 <Heffalump> (in ghci, :m +)#
13:51:11 <knapr> atom: why not?
13:51:35 <CakeProphet> atom:  yeah. import Data.List will get you intersect
13:51:38 <atom> knapr: take this with a grain of salt - I'm pretty new to functional programming
13:52:39 <atom> knapr: but in my opinion OO is pretty good at modelling systems that change... however, I just realised that this depends on your definition of change.
13:53:00 <dons> Building vty-3.1.8...
13:53:00 <dons> Graphics/Vty.hs:34:7:
13:53:00 <dons>     Could not find module `System.Console.Terminfo':
13:53:00 <dons>       Use -v to see a list of the files searched for.
13:53:11 <dons> anyone know why all my vty stuff is failing? hmm
13:53:12 <atom> knapr: OO is not good at modelling systems in which entity definitions are in constant flux
13:53:46 <atom> knapr: and entity relationships as well. I can see functional programming filling that niche better.
13:54:12 <atom> knapr: however, if your entity properties are the thing that's changing the most, I think OO is easier to understand.
13:54:25 <atom> knapr: and therefore better at modeling that environment.
13:54:33 <pejo> atom, would those "entity definitions" normally be an object?
13:54:58 <koeien> dons: works for me
13:54:58 <atom> pejo: that's what I meant. You can't (at least without major hacking) generate entity definitions on the fly.
13:55:13 <seveninchbread> knapr:  you're contriving an unnecessary argument here.
13:55:23 <koeien> dons: ghc 6.10.1, debian linux x86_64
13:55:31 <dons> koeien: yeah, looks like compat vty / terminfo 0.3
13:55:31 <atom> pejo: and instead of "object" I'd rather say "class"
13:56:12 <atom> python's pretty good at that though.
13:56:58 <knapr> atom: thats what i meant, i dont mean state, i mean where the specifications of behaviour changes
13:57:06 <pham> how do I find the pkg-id of a package I see in "ghc-pkg list"?
13:57:37 <atom> knapr: well, python's your anti-example there.
13:57:41 <jeffwheeler> dons: for what it's worth, it's working for me too, ghc 6.10, ubuntu 8.10, i386/x86
13:58:38 <atom> knapr: however, since functional languages are all behaviour and passing around functions I'd say I'd have to agree on grounds of pure logic... but I couldn't say I agreed with that statement on the gut feeling level.
13:59:00 <knapr> is something better at modeling something because it is easier to udnerstand?
13:59:02 <atom> but, as I said, my brain still hurts when writing haskell, so I'm not representative as far as that goes.
13:59:16 <atom> knapr: well, you can model everything with everything right?
13:59:36 <atom> knapr: turing-completeness is the only measure of "can it be done"
13:59:46 <dons> jeffwheeler: yeah, just versioning issuess on my side.
14:00:01 <atom> knapr: you wouldn't write an operating system with perl regular expressions, even though they're turing-complete
14:00:03 <tibbe> @src sequence
14:00:04 <lambdabot> sequence []     = return []
14:00:04 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:00:04 <lambdabot> --OR
14:00:04 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
14:00:11 <tibbe> @src msum
14:00:11 <lambdabot> msum =  foldr mplus mzero
14:00:15 <pham> I'm trying to unregister a package, but running "ghc-pkg unregister name-version" results in "cannot find package name-version"
14:00:41 <knapr> atom: k thanks
14:00:51 <rwbarton> pham: possibly you need --user?
14:01:13 <koeien> rwbarton: normally that is not necessary. at least not with my ghc
14:01:23 <Olathe> @src mone
14:01:24 <lambdabot> Source not found. Take a stress pill and think things over.
14:01:44 <vixey> @src Monoid
14:01:45 <lambdabot> class Monoid a where
14:01:45 <lambdabot>     mempty  :: a
14:01:45 <lambdabot>     mappend :: a -> a -> a
14:01:45 <lambdabot>     mconcat :: [a] -> a
14:01:49 <newsham> ?seen mmorrow
14:01:49 <lambdabot> Last time I saw mmorrow was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #ghc, #
14:01:50 <lambdabot> haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #
14:01:50 <lambdabot> haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosxdev, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 12d 1h 8m 34s ago, and .
14:01:53 <vixey> @src mzero
14:01:53 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:01:56 <Olathe> @src MonadPlus
14:01:57 <vixey> :t mzero
14:01:57 <lambdabot> Source not found. Where did you learn to type?
14:01:58 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
14:02:00 <atom> knapr: and so, IMHO it boils down to "what's the best tool for the job", and "best tool for the job" often means "least boilerplate, easiest to understand, easiest to maintain, fastest to write in, fastest to execute", assign weights and compute result. Now I'm done.
14:02:01 <Badger> heh, mooncat
14:02:09 <rwbarton> koeien: just a shot in the dark :)  I remember having some trouble last time I tried to unregister something, but I don't remember what it was
14:02:10 <vixey> mone = return -- then?
14:02:13 <pham> rwbarton: ah, thanks :)
14:02:27 <koeien> pham, rwbarton: well. my ghc is different then
14:03:12 <Olathe> @src [] mzero
14:03:12 <lambdabot> mzero = []
14:03:26 <Olathe> @src Maybe mzero
14:03:26 <lambdabot> mzero = Nothing
14:03:45 <mux> @src Ord mappend
14:03:46 <lambdabot> Source not found. Do you think like you type?
14:03:57 <mux> @src Ord mconcat
14:03:57 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
14:04:01 <Olathe> Ord isn't a type.
14:04:03 <mux> @src Ordering mconcat
14:04:03 <lambdabot> Source not found. Where did you learn to type?
14:04:08 <CakeProphet> @src YourMom mzero
14:04:08 <lambdabot> Source not found. My brain just exploded
14:04:10 <mux> @src Ordering mappend
14:04:10 <lambdabot> Source not found. My pet ferret can type better than you!
14:04:13 <mux> bleh.
14:04:23 <Olathe> @type mappend
14:04:25 <lambdabot> forall a. (Monoid a) => a -> a -> a
14:04:32 <Olathe> @instances Monoid
14:04:32 <mux> @instances Ord
14:04:33 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
14:04:33 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
14:04:41 <ddarius> vixey: There's a reason why 'return' is also called 'unit'
14:04:43 <Olathe> @instances Monoid
14:04:44 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
14:04:54 <Olathe> @src (a, b) mappend
14:04:54 <lambdabot> Source not found. stty: unknown mode: doofus
14:05:00 <Olathe> @src mappend
14:05:01 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:05:04 <Olathe> Hmm...
14:05:10 <Olathe> @src (,) mappend
14:05:10 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
14:05:23 <CakeProphet> @src Dual
14:05:24 <lambdabot> Source not found. The more you drive -- the dumber you get.
14:05:34 <Olathe> @src--
14:05:34 <mux> anyways, the Monoid instance for Ordering is nice in that it allows you to express compare this, and if it's equal, then compare this
14:05:34 <lambdabot> src <id>. Display the implementation of a standard function
14:05:37 <ddarius> CakeProphet: It's just a newtype wrapper.
14:05:41 <Olathe> Ehh
14:05:42 <Olathe> @src
14:05:43 <lambdabot> src <id>. Display the implementation of a standard function
14:05:58 <CakeProphet> ddarius:  oh what.
14:06:00 <CakeProphet> *of
14:06:05 <ddarius> Nothing.
14:06:11 <ddarius> newtype Dual a = Dual a
14:07:23 <ddarius> The point is the Monoid instance.  instance Monoid m => Monoid (Dual m) where mempty = Dual mempty; Dual a `mappend` Dual b = Dual (b `mappend` a)
14:09:05 <pham> Anybody know how to fix the "cannot find module `Data.Data': it is a member of package base, which is hidden" problem?
14:11:00 <Raevel> cabal? base needs to be added to the Build-Depends list
14:11:33 <dons> Data.Data is in base 4 isn't it?
14:11:43 <pham> yeah. I tried running "ghc-pkg expose base-4.0.0.0", but it did not fix it
14:13:21 <Heffalump> something else in your program depends on base 3?
14:13:39 <Heffalump> or is Data.Data in base 3, and in syb when working with base 4?
14:14:01 * Piglet sets a tramp for the heffalump!
14:14:15 <pham> Heffalump: I'm just trying to run "cabal install containers"
14:14:20 * Heffalump wonders what the tramp will do to him
14:14:33 <Heffalump> pham: no idea then
14:14:48 <Piglet> lol
14:14:53 <Piglet> wow, how did I typo that
14:15:16 * BMeph hopes it's a hobo-like tramp, and not a strumpet-like tramp, otherwise Mrs. Heffalump may have a word or two with the Piglet...
14:15:19 <dcoutts> pham: you should use build-depends: base >= 4 in your .cabal file
14:15:24 <dcoutts> pham: Data.Data is not in base-3
14:15:39 <Heffalump> she'd probably object to me being in a trap, too
14:16:00 <pham> dcoutts: so should I download containers from hackage and edit the .cabal file?
14:16:23 <dcoutts> pham: you do not need to install containers, it's already installed
14:16:33 <pumpkin> I found a photo of heffalump! http://upload.wikimedia.org/wikipedia/en/7/7c/Heffalump_movie_book.jpg he's a movie star!
14:17:06 <Heffalump> of course!
14:17:56 <pham> dcoutts: but many packages depend on containers-0.2.0.0, and it fails to install
14:18:29 <dcoutts> pham: containers-0.2.0.0 comes with ghc-6.10
14:18:44 <pham> dcoutts: oh no, what have I done now?
14:18:46 <dcoutts> pham: so if you've got packages that really need that version then they probably need ghc-6.10 too
14:19:01 <dcoutts> pham: what ghc version are you using?
14:19:34 <pham> I'm trying to use 6.10.1, but now I'm thinking cabal is using 6.8, which is also installed
14:20:05 <vixey> Does anyone know how to implement a prover ?
14:20:19 <dcoutts> pham: by default cabal uses the 'ghc' on the $PATH. You can select using -w
14:20:23 <rwbarton> Does anyone know whether LLVM JIT'ed code can make calls back into Haskell?
14:20:26 <sioraiocht> vixey: there are many different kinds
14:20:31 <pumpkin> wow, hlint is looking really nice
14:20:31 <vixey> like twelf/Coq/Agda/PVS type stuff
14:20:39 <dcoutts> sioraiocht!!
14:20:44 <sioraiocht> dcoutts: hiya
14:20:54 <dcoutts> sioraiocht: good holiday?
14:21:09 <Heffalump> rwbarton: I'm fairly sure there's no infrastructure for it to do so.
14:21:14 <Heffalump> But on a technical level it wouldn't be hard.
14:21:17 <sioraiocht> dcoutts: indeed ;) am ready for some haskell work tomorrow! you
14:21:36 <dcoutts> sioraiocht: great, see you in the office tomorrow perhaps
14:21:40 <dcoutts> sioraiocht: yeah, was nice
14:21:42 <sioraiocht> yes
14:21:49 <sioraiocht> althogh i'm on the fourth floor, now :)
14:21:57 <dcoutts> pham: cabal install --dry-run -v gives some useful insights
14:22:01 <Heffalump> well, I don't quite know how to do it. But I'm sure it would be possible.
14:22:14 <dcoutts> sioraiocht: it's not that far to visit :-)
14:22:19 <sioraiocht> heheh
14:22:23 <Heffalump> sioraiocht: as opposed to the attic?
14:22:27 <vixey> so is there any texts about it online or something?
14:22:36 <sioraiocht> Heffalump: dcoutts is in the basement
14:23:42 <pham> dcoutts: hm yeah, it says "selecting base-3.0.3.0 (installed) and 4.0.0.0 (installed) and discarding" at one point. That looks like a problem
14:24:44 <dcoutts> pham: that's standard. It has to select both because base-3 depends on base-4
14:25:03 <CakeProphet> :t $!
14:25:04 <lambdabot> parse error on input `$!'
14:25:06 <vixey> I guess not.....
14:25:07 <CakeProphet> :t ($!)
14:25:09 <lambdabot> forall a b. (a -> b) -> a -> b
14:25:22 <CakeProphet> hmmm?
14:25:25 <dcoutts> pham: so does it say that installing containers is a new package or a re-install?
14:25:26 <CakeProphet> what is $!
14:25:31 <rwbarton> Heffalump: OK, thanks.
14:25:31 <mux> CakeProphet: strict application
14:25:44 <mux> @src ($!)
14:25:44 <lambdabot> f $! x = x `seq` f x
14:26:14 <Holle_> i want to save a global state of my progame: state :: Int how du i change the state by an event (onMotionNotify). using simple functions i would an parameter state.
14:26:36 <dcoutts> Holle_: using an IORef
14:26:42 <pham> dcoutts: "selecting containers-0.2.0.0 (installed or hackage) and discarding
14:26:45 <pham> containers-0.1.0.0 and 0.1.0.1"
14:26:50 <jeffwheeler> I'm confused; I've got a do block with x <- (some function that returns a Maybe), and then I try to print that value.
14:27:05 <pham> and it says at the bottom that it's reinstalling containers-0.2.0.0
14:27:07 <jeffwheeler> Obviously, it doesn't work because I'm working with Maybe, and then IO ().
14:27:13 <dcoutts> pham: ok, does it say why?
14:27:14 <jeffwheeler> But I can't seem to figure out what I should be doing, instead.
14:27:28 <mux> jeffwheeler: yes, you want "print yourfunc"
14:27:28 <dcoutts> pham: eg changing versions of dependencies?
14:27:30 <Beelsebob> jeffwheeler: how about using maybe to get the value out of the Maybe monad?
14:27:36 <Botje> jeffwheeler: do let x = ... \n print ...
14:27:37 <mux> not yourfunc >>= print, since yourfunc would have to be in the IO monad
14:27:46 <Botje> or let x = ... in print
14:27:51 <Botje> or let x = ... in print x
14:27:58 <Beelsebob> I think the point is he wants to use both binds – one to get it out of a Maybe
14:28:03 <Beelsebob> but also one to use print
14:28:08 <jeffwheeler> > do { x <- (Just 5); print x }
14:28:09 <lambdabot>   Couldn't match expected type `Maybe' against inferred type `IO'
14:28:12 <mux> oh, well fromMaybe or maybe is best then
14:28:14 <Beelsebob> so instead of using bind to get it out the Maybe, he should use maybe
14:28:42 <Beelsebob> jeffwheeler: print . maybe 0 id (Just 5)
14:28:43 <mux> > maybe "Nothing" show (Just 5)
14:28:44 <lambdabot>   "5"
14:28:47 <pham> dcoutts: "containers-0.2.0.0 (reinstall) changes: base-4.0.0.0 -> 3.0.3.0"... does that mean anything?
14:28:57 <Beelsebob> or what mux did to get a better error
14:29:16 <pham> dcoutts: maybe I should uninstall ghc-6.8?
14:29:16 <dcoutts> pham: ok, run ghc-pkg list, are there any packages where the exact same version is installed both globally and per-user ?
14:29:22 <dcoutts> pham: no, that's not relevant
14:29:24 <jeffwheeler> Thanks for all the help; I haven't gotten through it all, yet.
14:29:42 <pham> dcoutts: yeah Cabal-1.6.0.1
14:29:49 <rwbarton> Heffalump: It seems I can call external functions using newNamedFunction ExternalLinkage; can I combine with foreign export somehow?
14:29:50 <jeffwheeler> Simpling printing the variable worked great; thanks!
14:29:54 <pham> should I unregister the user version of that package?
14:29:56 <dcoutts> pham: ok, unregister it and any others in that state
14:30:08 <dcoutts> pham: yes, the per-user one, leave the global one
14:30:19 <dcoutts> pham: so ghc-pkg --user unregister Cabal-1.6.0.1
14:30:40 <Heffalump> rwbarton: oh, perhaps, yeah
14:31:10 <rwbarton> Heffalump: cool, as long as it's not obviously impossible, I'll give it a shot :)
14:31:48 <pumpkin> so what's coming in GHC 6.12?
14:31:53 <dons> hey all, how do we deal with perception issues like this: http://www.reddit.com/r/programming/comments/7oxgv/proggit_what_is_your_favorite_programming/c06ywut
14:31:58 <Heffalump> pumpkin: working type families, I hope
14:32:00 <dons> (or is that precisely how we deal with it?)
14:32:05 <dons> pumpkin: faster parallelism
14:32:07 <Heffalump> dons: a machine gun
14:32:14 <dons> Heffalump: also useful
14:32:46 <dons> Heffalump: http://www.biggerbetterbeards.org/img/badass.jpg
14:32:57 <kmeyer> hey, what does . do?
14:33:04 <Heffalump> dons: anyway, I think the poster is right
14:33:16 <dons> too many unstable things?
14:33:18 <dons> sure.
14:33:22 <kmeyer> (is it by any chance function composition?)
14:33:24 <mux> kmeyer: . composes functions; that is (f . g) x == f (g x)
14:33:27 <kmeyer> whoo!
14:33:28 <dons> but gee crypto and dbs are actually fairly well supported!
14:33:28 <atom> are there any negative sides to deriving from show on every dataitem?
14:33:32 <dons> and he didn't know that.
14:33:40 <dons> atom: makes code a big bigger
14:33:43 <pumpkin> I think people pay too much attention to version numbers :P
14:33:50 <dons> i'm going to graph version numbers
14:33:51 <pumpkin> a lot of stuff is permanently in beta because it's scary to leave it
14:33:53 <dons> let's see where we are.
14:33:56 <Heffalump> get the stuff into the Haskell Platform
14:33:57 <vixey> (f . g) x = f (g x)
14:34:10 <atom> dons: but performance and execution-wise it's still the same code?
14:34:25 <pham> dcoutts: thanks! I just had to unregister array and cabal :)
14:34:26 <crutcher> I think that putting lots of time into haddock may actually be more important at this point than making haskell faster.
14:34:36 <dons> crutcher: that would be *very* welcome.
14:34:42 <vixey> Not the often praised Haskell, Erlang, Scala or Lisp, but regular "get work done" languages. This is a great thing, and shows a resurgence of actual developers to Reddit, and not head-in-the-clouds academics.
14:34:44 <dons> a lot of people work on making haskell fast -- and its pretty fast, right?
14:34:45 <Heffalump> the toolchain in general needs lots of work :-/
14:34:48 <dons> but some really nice haddocks would be good
14:34:59 <newsham> speaking of haddock, is it possible to use lhs2tex and haddock together?  seems lhs2tex treats "|" as a special character
14:35:04 <dons> crutcher: what do you need  to get started?
14:35:08 <pumpkin> having some sort of wiki / comment system on hackage would be nice, to allow non-maintainers to document/comment on packages on there
14:35:19 <dcoutts> pham: ok, now run ghc-pkg check to see if there are any broken packages
14:35:25 <dcoutts> pham: then you're all done
14:35:37 <crutcher> dons: time, I think. I'm not comfortable enough yet, but I'm willing to do some work when I am.
14:35:47 <pumpkin> it might also be nice to show how many other packages depend on a given package, to see how commonly used thigs are
14:36:05 <pham> dcoutts: yeah looks good. I think I might have a knack for screwing up package systems
14:36:07 <dons> arch haskell status, http://archhaskell.wordpress.com/2009/01/11/arch-haskell-news-jan-11-2009/
14:36:08 <pumpkin> or just download count
14:36:11 <crutcher> dons: I would really like to teach ghci how to read haddock files, so we could get a :help or :doc command
14:36:16 <dons> mm. yes.
14:36:21 <crutcher> but I'm not near to that yet.
14:36:21 <dons> that would be a great extension
14:36:22 <Heffalump> <aol>
14:36:38 <dons> just redoing haddocks stuff would be good
14:36:38 <pham> I agree. It would be super cool to have documentation integrated into ghci
14:36:56 * atom sends a thumbs-up as well
14:37:27 <crutcher> but I want to head back to school in 2010, doing a haskell phd, so I'm doing what I can to ramp up, so I can find a program and apply in the winter of 09
14:37:43 <pham> what would also be cool is to have a basic API for getting documentation text so you could write an IDE that could search and index the documentation along with the type signatures
14:38:26 <pham> basically something like Hoogle that searched docs too
14:38:28 <Botje> hmm
14:38:28 <crutcher> pham: well, once you start playing with that, you start to maybe want some form of annotations
14:38:38 <pham> crutcher: annotations?
14:38:46 <crutcher> so you can start building stranger things
14:38:51 <Botje> perldoc-like synopses would be neat too
14:39:05 <newsham> so i guess nobody uses lhs2tex and haddock together?
14:39:09 <crutcher> Well, seen with one lens, docs are just string annotations on names
14:39:40 <crutcher> but what if we could decorate them with other annotations? You could argue that some of the pragma rules are logically annotations
14:39:53 <pham> crutcher: on function arguments, function names, and module names mostly, right?
14:40:17 <crutcher> pham: well, no. haddock lets you attach them to constructors as well
14:40:31 <Boney> dons: regarding the parception issues.  I think your comments there are really good.  You've pointed out clearly, without insulting anybody that the user's parception was false.
14:40:43 <crutcher> but annotations are not often encountered outside dynamic languages
14:40:50 <pham> crutcher: I agree that a system to arbitrarily annotate source code would be good
14:41:17 <Boney> IMHO, all Haskell needs to be used more in the Real World (tm) is to just be used more in the Real World (tm).
14:41:33 <Boney> no-one ever got fired for choosing Java over something seemingly-risky like Haskell.
14:41:36 <crutcher> pham: I'm not really saying it would be good. I'm saying that the more you look at doc APIs, the more likely you are to want to do this.
14:41:39 <vixey> someone should write a book called Real World Haskell
14:41:47 <Boney> but if more people picked Haskell.  then more people would pick Haskell.
14:41:53 <newsham> vixey: you're it.
14:41:54 <Boney> vixey: heh.
14:42:12 <Heffalump> .NET and Java both have attributes
14:42:22 <dons> Boney: ok. thanks.
14:42:47 <crutcher> Heffalump: yeah, and they are both (arguably) dynamic languages (even if they have static types).
14:42:53 <Heffalump> in what way?
14:42:53 <Boney> It's a bit different for Mercury.  We've got a number of things (IMHO) that need to be done before it's a good decision for random IT ferm to pick as an implementation language.
14:42:59 <Heffalump> dynamic loading?
14:43:01 <Boney> dons: np.
14:43:01 <newsham> attributes are nice, but I wonder if they're an indication that the language itself isnt powerful enough to capture everything the programmer wants to represent.
14:43:10 <crutcher> Heffalump: they keep lots of info about the nature of the program arround, not just the code.
14:43:21 <dino-> I don't know a lot about it, but I think annotations in Java are what's used to achieve aspect-oriented.
14:43:30 <Heffalump> crutcher: fair enough
14:43:43 <pham> crutcher: well, I think it would be useful to have more Haskell tools for dealing with source code, like for annotating it, retrieving type signatures from it, compiling it, running it, etc
14:43:58 <Heffalump> dino-: AspectJ is a language built on top of Java by stealing keywords
14:44:01 <dino-> Is it fair to say what they call annotations in Java is kinda sorta like TH?
14:44:13 <Heffalump> no, they're just metadata
14:44:42 <crutcher> pham: agreed. What I'm interested in is having tools to annotate functions and types at run time so that we could swap in different memoization strategies
14:45:08 <pham> crutcher: you'd neet to extend the RTS to do that, I imagine?
14:45:19 <crutcher> think a meta-haskell like template haskell, but rather than being syntax driven, sitting under the execution
14:45:25 <crutcher> pham: probably.
14:45:41 * Heffalump goes to bed
14:45:43 <newsham> if you implemented the memoization strategy directly in haskell then you wouldnt need the annotations, no?
14:45:47 <crutcher> anyway, I'm still having problems with HUnit and MVar, so I've blown enough smoke today :)
14:45:59 <loadquo> To be honest, I wouldn't pitch haskell as a mainstream programming language to start with. Make it something research is done it.
14:46:04 <pham> crutcher: not sure I'm picturing this clearly, but it sounds interesting
14:46:07 <crutcher> newsham: that depends on what strategy you want. Is it backed by a file?
14:47:02 <atom> ok, now I'm pretty surprised. if I do data Enum = A | B | C and then try doing intersect [A,B] [C,B] GHCi complains that I need an instance declaration for (Eq Main.Enum)... So I actually need to tell haskell that A == A?
14:47:04 <loadquo> Done in* Then you will be taught it at university, then you will get enough people knowing it for general IT shop to use it.
14:47:20 <vixey> atom, you can add  deriving Eq  to the end of that declaration
14:47:29 <crutcher> Okay, in a nutshell, here's what I want: I want to be able to run a computation to completion, even if it takes several machines and does not run continuously, and I want to be able to do that in pure code with no discussion of parallelism or IO sequencing.
14:47:32 <atom> vixey: oh, and it'll be done automatically? Great.
14:47:57 <dons> crutcher: cool. so some kind of distributed haskell runtime, eh?
14:48:05 <dons> `par` threads inferred, then distributed seamlessly?
14:48:09 <mux> note that sometimes, telling haskell that A == A, or rather that A /= A, can be useful
14:48:14 <crutcher> I want to be able to describe a computation, and then run it, even if it takes a lot of memory, even if it takes many (potentially faulty) machines.
14:48:24 <atom> um... deriving from multiple classes is done by...
14:48:31 <newsham> deriving(Show,Eq)
14:48:38 <atom> oh, it's a tuple.
14:48:41 <pham> atom: yeah, AFAIU some built-in classes (Show, Eq, and others?) can be implemented automatically with "deriving". There are libraries (like SYB) that will let you do that with your own classes
14:48:55 <crutcher> dons: yeah. That would be sweet. You should be able to schedule simple algorithms on big data on a supercomputer without having to tell your algorithms about all the messy bits.
14:49:04 <atom> pham: cool
14:49:08 <mux> Ord can be derived automatically too
14:49:15 <mux> Ix as well
14:49:21 <Holle_> if i try to read a state in function f :: Point -> IORef State -> Render () i get an error, because readIORef return IO (). what can i do?
14:49:22 <crutcher> anyway, I have a hell of a lot more to learn before I could even do file-backed memoization.
14:49:22 <dons> hehe "The Real World Haskell book is only a pixel thick on the web. In paper it's like 2 inches. Amazing."
14:49:23 <pumpkin> crutcher: will it do magic too? :)
14:49:27 <mux> I don't think there are many others
14:49:31 <pumpkin> crutcher: but yeah, that would be awesome
14:49:33 <atom> mux: Ord as in "ordered"? How the hell can you derive ordering?
14:49:43 <vixey> crutcher, file based memo would be in IO
14:49:48 <roconnor> from the order you list your constructors in
14:49:52 <mux> atom: in your case it would create the A < B < C ordering
14:49:57 <vixey> crutcher, unless you make a new language to program your stuff in
14:49:59 <crutcher> vixey: well, there are two ways to think about that.
14:49:59 <atom> oh, I see.
14:50:05 <pumpkin> crutcher: it might take a little bit of annotation though to make it effective... automatically distributing computation is pretty hard
14:50:06 <crutcher> 1) unsafePerformIO
14:50:15 <vixey> (1) is not a solution
14:50:33 <newsham> dons: the 2" edition doesnt go away during power outages or trips out of civilization
14:51:05 <crutcher> 2) treat Haskell as the contract, and implement a layer that is providing that contract, but maybe does some more stuff to make it faster/more robust.
14:51:57 <crutcher> pumpkin: true, it is. but lets forget about fast. what about "will it run to completion"? Lets take a very simple case: memory.
14:51:57 <Holle_> crutcher: do you mean my problem?
14:52:10 <vixey> I bet that it's a million times easier to write something like that with explicit concurrency
14:52:11 <crutcher> I don't think so?
14:52:31 <pham> So does Rohan Drape ever appear in this channel?
14:52:32 <Axman6> crutcher: you're after file based memoisation right? thought about using something like SQLite instead?
14:53:01 <crutcher> Suppose there was a way to compile your Haskell program so that you could give it a flag that specified a) an upper memory limit, and b) a memory backing file, to be used when more memory than #a was needed.
14:53:18 <pumpkin> the issue is that file-based memoization can't be pure
14:53:25 <vixey> doesn't that happen anyway.. because of the operating system?
14:53:29 <crutcher> pumpkin: no program is pure.
14:53:32 <vixey> it uses bits of the harddrive for extra memory
14:53:38 <newsham> suppose you had a system where you used backing store to provide the illusion that you had more memory than the physical memory available in your machine?
14:53:40 <crutcher> pumpkin: but they can emulate a pure environment.
14:53:50 <crutcher> newsham: yes.
14:53:59 <vixey> I thought every modern OS did that..
14:54:04 <crutcher> newsham: but not just the virtual memory.
14:54:09 <crutcher> yes, they do.
14:54:14 <pumpkin> crutcher: I'm just saying someone could change the file behind your back
14:54:31 <crutcher> pumpkin: someone could change your memory behind your back, what's your point?
14:54:32 <Holle_> could a function that returns IO () also return Render (), like this IO (Render())?
14:55:02 <loadquo> crutcher: True, all the haskell programs I run have the side effect of reducing my battery life :(
14:55:02 <pumpkin> crutcher: it's a lot more practical for someone to change your file behind your back ;)
14:55:03 <newsham> Holle: it wouldnt be IO ()
14:55:04 <vixey> Hole_, it can only do one or the other
14:55:07 <dolio> vixey: They don't typically set an upper bound for each program before said particular program starts swapping.
14:55:09 <Axman6> vixey: i guess it does, but that doesn't mean that anything's being memoised
14:55:11 <dolio> Not by default, anyhow.
14:55:12 <crutcher> I'm talking about putting a rich scheduler _under_ the haskell execution, not inside the type system.
14:55:39 <Holle_> but how can i use IORef in a function that returns Render()?
14:55:40 <crutcher> pumpkin: which is why you dont give them the rights to?
14:56:10 <newsham> crutcher: perhaps what you're after is an OS?
14:56:47 <Axman6> crutcher: this sounds like something i've been proposing for a while, a memoisation anotation for functions that would automatically memoise complex functions at the cost of memory (with a default memory usage, and controlable via RTS flags)
14:57:16 <crutcher> newsham: yes, I know all about virtual memory. I've got a little bit of code in the Linux kernel (Magic SysRq). This is different. The memory thing is just an example.
14:57:26 <crutcher> okay, let me describe this differently.
14:57:40 <atom> um... if I have a number of functions that have the same signature - A -> B -> Bool and I want to have other functions that use those, can I name the signature? If so, how can I use the functions one I get them as an argument?
14:57:51 <pumpkin> gotta run :)
14:57:54 <atom> s/one/once/g
14:58:07 <pham> Holle_: when I found myself wanting that, I just added an argument to the Render function that was the contents of the IORef
14:58:24 <newsham> type CommonFunc = A -> B -> Bool
14:58:30 <pham> Holle_: so one option is to just restructure the program so that the IORef is modified outside that function
14:58:37 <atom> I tried like data TransFunc = TransFunc (A->B->Bool)
14:58:42 <vixey> type ConfusingSynonym = CommonFunc
14:58:47 <atom> oh, type...
14:58:54 <newsham> data makes a new type.  "type" gives a name to an existing type
14:58:58 <crutcher> I would like to describe a _reliable_ computation, that is defined inside a reliable execution environment, on potentially large data. Then, I would like to simulate that environment, possibly in fits and starts, on an unreliable machine (or machines), and silently recover from errors and/or provide enough resources (even if some are disk instead of memory).
14:59:06 <atom> vixey: you do not aprove of this?
14:59:13 <crutcher> I believe that Haskell could be made to do that
14:59:15 <vixey> atom, no I think it's fine
14:59:29 <newsham> crutcher: sounds like a job for a reliable OS.
14:59:41 <crutcher> newsham: there are no reliable OSs.
14:59:43 <atom> vixey: the ConfusingSynonym part kind of left that impression
14:59:44 <Holle_> pham: so i use two functions: one thats changes the state and one thats paints the grahpics and gets the state
14:59:48 <vixey> crutcher, actually it sounds like what that guy was saying on the radio about erlang
15:00:00 <vixey> crutcher, although I don't really know anything about erlang so it may not be..
15:00:06 <harblcat> is it possible to do hSetBuffering NoBuffering on Win32?
15:00:07 <crutcher> large-scale computations frequently fail (MapReduces and the like).
15:00:17 <atom> yay, it compiles, it compiles!
15:00:19 <crutcher> vixey: and yes, Erlang gives you some of this.
15:00:28 <vixey> but Erlang is still explicit
15:00:30 <newsham> crutcher: there are fault tolerante OSs
15:00:31 <loadquo> Sounds like what google did with map reduce. They are running on so many computers they have a high chance that one will fall over at any given time.
15:00:36 <pham> Holle_: you mean one that changes the state, and another that takes the state as an argument and paints graphics?
15:00:45 <Holle_> yes
15:01:08 <newsham> btw, systems such as google's map/reduce deal with unrealiable computers and restarting (although not for the case of memory exhaustion)
15:01:12 <pham> Holle_: yeah, that's basically what I did. Though the function that changed the state wasn't a function, just a loop in main, if I remember correctly
15:01:27 <newsham> since they distribute work across such a large number of machines that machine failures happen frequently enough to warrant it
15:01:45 <dino-> Oh man, I didn't realize when Amazon told me my pre-ordered RWH was going to be delayed, I needed to *acknowledge* that email or it would be cancelled.
15:01:48 <dino-> :o
15:02:00 <crutcher> newsham: none that survive having the machine turned off
15:02:13 <newsham> you can turn off google map/reduce machiens at will
15:02:25 <dino-> Luckily I also bought it from O'R in ebook form. But bah could have gotten the dead-tree edition at the same time if I was paying attention.
15:02:44 <newsham> crutcher: there are also persistent OS's that let you turn off the machine
15:02:46 <crutcher> loadquo: Yes, but many mapreduce jobs die because of resource utilization on a give machine: you can't restart them enough to fix them, because they grab to much memory every time.
15:03:32 <dons> well done guys, http://www.reddit.com/r/programming/comments/7oxgv/proggit_what_is_your_favorite_programming/c06z322
15:03:40 <crutcher> newsham: provided that the hardware doesn't fail.
15:04:00 <newsham> fault tolerant + persistent.
15:04:02 <Holle_> pham: the function that chages the state have to return the state (Int), but that's the same problem ?!
15:04:10 <mapreduce> My mapreduce job seems ok.
15:04:27 <rwbarton> crutcher: Sounds similar in spirit to http://supertech.csail.mit.edu/porch/
15:04:51 <pham> Holle_: it can return "IO State"
15:05:05 <crutcher> newsham: besides if your OS solution exposes normal network IO, you've lost the 'reliable' aspect, because you can't replay the world.
15:05:18 <Holle_> you mean IO (State)?
15:05:19 <rwbarton> Holle_: are you still having the problem with reading an IORef from Render?
15:05:30 <rwbarton> Holle_: I think Render is an instance of MonadIO so you can use  liftIO (readIORef ref)
15:05:38 <crutcher> rwbarton: that's deffinately a step in the right direction.
15:05:52 <pham> Holle_: then you can say in your main loop: state <- updateState; renderWithDrawable drawable (updateDisplay state)
15:05:53 <Holle_> liftIO instead of readIO?
15:05:59 <atom> care to take care at some code and give comments: http://hpaste.org/13838
15:06:05 <crutcher> but it doesn't provide a causally consistent execution environment, just program state.
15:06:09 <atom> I'm a noob at haskell and I'd appreciate any criticism
15:06:19 <atom> (as long as it's constructive)
15:06:25 <rwbarton> crutcher: of course it's a lot more sensible to do this to a program that's guaranteed to be a pure computation
15:06:31 <crutcher> atom: always store beer in a cold place?
15:06:44 <newsham> atom: you seem to retype a lot of the same things in canDoAction
15:06:46 <atom> crutcher: not related to haskell, but duly noted :)
15:06:51 <newsham> indicating that you can factor common code out
15:06:56 <vixey> atom, in general, change p1 to player1 , dex to dexterity, etc..
15:06:57 <crutcher> rwbarton: which pretty much rules out the IO monad
15:07:10 <rwbarton> crutcher: and the entire C programming language :)
15:07:17 <crutcher> rwbarton: but I'm okay with that. there are large batch jobs in the world, and someone needs to run them
15:07:26 <atom> newsham: I'll factor that code out, that won't be a prob.
15:07:29 <pham> Holle_: I assume you're using gtk and Cairo? I have some example programs and a program on hackage that use those
15:07:35 <newsham> namely:  \as p -> not . null $ intersect as (action $ p game)
15:07:54 <crutcher> wow, I spent much more time on this than I thought. Sorry for getting all ranty. I needs the foods.
15:08:05 <Holle_> pham: yes
15:08:15 <atom> vixey: noted.
15:08:37 <CakeProphet> can record functions be overloaded?
15:08:40 <Holle_> pham: where do i find the code?
15:08:53 <atom> vixey: took me a while because of an internal struggle between typing more and reading less
15:09:00 <CakeProphet> for example.  data Foo = {lol ::Int}  and then data Bar = {lol ::Bool}
15:09:06 <chessguy> CakeProphet:  no
15:09:12 <newsham> not in the same module.
15:09:13 <chessguy> CakeProphet:  they're top-level functions
15:09:20 <Stinger> haskell doesnt have adhoc overloading, which kinda sucks for records
15:09:32 <vixey> haskell doesnt have adhoc overloading?
15:09:33 <kmeyer> anyone know if HUnit has asserts for Floats/Doubles?
15:09:37 <dons> vixey: um?
15:09:43 <kmeyer> like assertSimilar 5.00001 5.0
15:09:48 <rwbarton> Holle_: I don't know what readIO is, but I certainly mean liftIO
15:09:50 <CakeProphet> -shrug- I haven't really encountered a situation where I need two datatypes with a matching record name.
15:09:50 <atom> otherwise, the code is fine? I followed all unwritten but commonly known guidelines?
15:09:54 <dons> Stinger: type classes are the definition of ad hoc overloading with language support
15:10:00 * sjanssen just managed to crash his X server while playing with xhb
15:10:03 <sjanssen> whoops!
15:10:05 <Stinger> damn
15:10:10 <Stinger> well one sort of overloading
15:10:22 <dons> yeah, the ad hoc sort.
15:10:30 <dons> as opposed to the parametrically polymorphic sort.
15:10:31 <vixey> yeah why is there not a class Projection from to
15:10:38 <Stinger> yes that one :)
15:10:46 <dons> there's been NatTrans classes in the past
15:10:55 <Holle_> rwbarton: i have a global state: state <- newIORef 1 and wan't to read it. so i have to use liftIO state?
15:10:56 <vixey> oh because the names would not be reused
15:10:56 <dons> f a -> g b
15:11:02 <ski_> (dons : and thankfully they're removed ..)
15:11:05 <dons> yeah
15:11:09 <dons> too ad hoc :)
15:11:11 <rwbarton> Holle_: no, you have to lift the IO action.    state <- liftIO (newIORef 1)
15:11:18 <dons> :src Functor
15:11:22 <dons> ?src Functor
15:11:22 <lambdabot> class  Functor f  where
15:11:22 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
15:11:24 <chessguy> CakeProphet:  as RWH puts it, "data Foo = Foo { lol :: Int }" is sugar for "data Foo = Foo Int; lol :: Foo -> Int; lol (Foo x) = x; "
15:11:24 <loadquo> atom, a suggestion from another newbie, perhaps use guards on doAction?
15:11:54 <ski_> atom : i would factor out the map `Action -> [Action]' in `canDoAction'
15:12:03 <pham> Holle_: what kind of example do you want? I've got one that opens a window with one gtk widget, a program that daws a rectangle with cairo, a program that draws static with gtk, and a chess clock program on hackage (hsclock)
15:12:31 <chessguy> draws static?
15:12:42 <gsan> Hey guys, does anyone know if there exists a pure(r) version of the Typeable library? I mean, one which doesn't do ugly unsafePerformIO tricks behind the curtains?
15:12:50 <atom> loadquo: I thought about using that, but it made the code less readable - I'd need to compare anyway...
15:13:00 <Holle_> pham: where do you used a state to control the program?
15:13:01 <atom> ski_: I don't understand what you mean.
15:13:07 <pham> Holle_: with the clock program? Yeah
15:13:15 <vixey> gsan, are you sure it's possible? I thought that it was essential
15:13:26 <Pseudonym> gsan: Typeable unavoidably needs either compiler help or unsafeFunctions.
15:13:29 <Holle_> pham: then would like to take a look in this program
15:13:53 <pham> Holle_: the state is in the record State :-P
15:13:55 <loadquo> atom: It is a corner case. It is not too bad as it is really
15:14:12 <gsan> Yes of course, but it doesn't have to keep a record of ALL types in a hash table and update it every time. I does this for speed.
15:14:20 <pham> Holle_: and it's stored in the stateRef IORef. Download it from hackage
15:14:33 <ski_> atom : i'll make an annotation .. wait a moment
15:14:37 <vixey> maybe it is possible to not use unsafeCoerce
15:14:52 <Holle_> pham: what ist hackage?
15:14:57 <pham> @go hackage
15:15:07 <Pseudonym> gsan: I'm a bit unhappy about that too, for reasons of dynamic libraries.
15:15:15 <lambdabot> Plugin `search' failed with: thread killed
15:15:18 <pham> Holle_: hackage.haskell.org
15:15:40 <gsan> vixey: unsafeCoerce is not a problem for me actually. I can imagine that it's converting the value to an intermediate type and then reading it.
15:16:04 <Pseudonym> Nope.
15:16:10 <Pseudonym> unsafeCoerce is, essentially, a C-style cast.
15:16:15 <pham> Holle_: it's not the best of code, but I can explain how it works if you have any questions
15:16:26 <gsan> Pseudonym: Well, in the current state of my library, Typeable consumes ~1GB of RAM when I leave the program running overnight.
15:16:36 <Holle_> do you mean this: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gameclock-1.0.1
15:16:43 <Pseudonym> I'd submit that as a bug to haskell-libraries.
15:16:43 <pham> Holle_: ah yeah
15:16:44 <dons> gsan: huh
15:16:52 <dons> gsan: what Typeable thing exactly?
15:17:07 <Pseudonym> If it really is a cache, then it should be periodically cleared.
15:17:09 <dolio> gsan: You can use GADTs, but that only works if you're willing to have a closed universe of types available for Typeable.
15:17:41 <ahunter> Why might cabal-install, after an update, decide it can't read cabal files when doing "cabal list"?
15:17:52 <gsan> dons:Well, I'm using it to generate types for my program generation functions, random types actually. And the permutations are a LOT. Typeable uses a hashtable to store them.
15:18:02 <dons> yeah, the runtime hash of type names
15:18:05 <dons> you think its 1G?
15:18:17 <dons> i'm not sure it would show up in profiling
15:18:21 <dcoutts> ahunter: upgrade cabal-install
15:18:40 <gsan> Yes, I'm sure, i didn't expect it either though...
15:18:44 <dons> mm
15:18:49 <ahunter> dcoutts: ok.  Is it just a case of new cabal file formats?
15:18:50 <dons> profile, then maybe make a bug report
15:19:01 <dcoutts> ahunter: it's because people have started using features from the latest Cabal version without properly labelling their .cabal files with cabal-version: >=1.6
15:19:20 <ahunter> dcoutts: ah. btw, should "cabal upgrade" work?  ATM, it doesn't, claiming it can't find base >= 4.0 which is necessary
15:19:28 <gsan> dolio: Ah, yes, but my library is dynamic, i.e. library user is able to define type constructors without altering the library.
15:19:40 <dolio> Yes, that wouldn't work, then.
15:19:46 <ski_> atom : abstraction out `Action' map <http://hpaste.org/13838#a1>
15:19:48 <dcoutts> ahunter: in ideal conditions it should work :-)
15:20:07 <rwbarton> dolio: associated data types are a lot like open GADTs... although I'm not sure exactly what you're planning on doing with the GADTs
15:20:19 <dons> gsan: wow. interesting
15:20:25 <ahunter> dcoutts: ...charming.  Any ideas short of just grabbing a .6 tarball and installing by hand?
15:20:32 <dcoutts> ahunter: the reason it does not for you is because you're using ghc-6.8.x and some of the latest versions of packages need base 4 from ghc-6.10 and currently cabal-install is not smart enough to ignore the new versions that need a later ghc than the one you've got.
15:20:37 <dolio> rwbarton: I've thought of that, but they don't enable type refinement based on pattern matching, so they don't let you implement typeable.
15:20:50 <dcoutts> ahunter: you can still install individual packages and get dep tracking
15:20:54 <Holle_> pham: first i try the liftIO
15:21:00 <ahunter> dcoutts: ah.  Yeah,debian hasn't gotten 6.10 yet afaik
15:21:16 <ahunter> dcoutts: except the packages I need won't install, hence the desire to upgrade.
15:21:20 <gsan> dons: Ah sorry, I'm using -hr to profile
15:21:21 <atom> ski_: thanks! Exactly what I wanted in the 1st place but didn't know how to write
15:21:26 <Saizan_> dolio: they do in HEAD
15:21:29 <dcoutts> ahunter: if trying to install an individual package also says it needs base 4 then use $ cabal install --dry-run 'foobar < 1.2.3.4' or whatever to select an older version.
15:21:31 <pham> Holle_: that code also has some useful bits like double buffering
15:21:38 <dolio> They do?
15:21:38 <atom> Now I only need to figure out what everything means...
15:21:54 <Saizan_> dolio: yeah, rwbarton has an example
15:21:59 <rwbarton> Saizan_: I do? :)
15:21:59 <ahunter> dcoutts: aaaaah.  as for upgrading cabal-install, am I sunk trying that until I procure 6.10?
15:22:06 <dolio> Man, now I'm going to have to build HEAD.
15:22:08 <ski_> atom : note that i didn't notice you used `p2' in the last case initially .. so i needed to plug that into `blah' too, to make it be equivalent
15:22:11 <dcoutts> ahunter: no it works with 6.6+
15:22:26 <dcoutts> ahunter: just cabal install cabal-install
15:22:26 <ski_> atom : also, possibly you can figure out a better name for `blah'
15:22:26 <atom> ski_: yes, I noticed, but wrote it off as a typo
15:22:27 <Saizan_> rwbarton: i recall one on hpaste :)
15:22:27 <rwbarton> dolio: What's involved in this theoretical implementation of Typeable?
15:22:48 <dcoutts> ahunter: it's on my TODO list to have the dependency solver automatically discard packages that cannot be installed due to needing a later base or ghc version.
15:22:52 <rwbarton> Saizan_: I certainly did hpaste some stuff with associated data types, but I don't know how it's related
15:23:00 <ahunter> dcoutts: aaaah.  upgrade is trying and failing for a global upgrade?
15:23:01 <atom> ski_: obviously :)
15:23:14 <ski_> atom : argh .. yes, i meant to write `p2' in the last case .. obviously my fingers meant otherwise
15:23:26 <dcoutts> ahunter: yes, on it's own upgrade means install the latest version of every package I've got installed currently
15:23:48 <Saizan_> rwbarton: it was some code involving gadts that only typechecks in 6.11, right?
15:23:50 <rwbarton> Saizan_: this one? http://hpaste.org/13738
15:23:54 <atom> ski_: think nothing of it. typos happen.
15:24:12 <Holle_> can't i break lines of an if condition in a "do... " statement?
15:24:13 <rwbarton> Saizan_: It panics in 6.10.1 because GADTs as data families aren't implemented there
15:24:50 <vixey> you can write Dynamic/Typeable with only GADTs
15:25:16 <Holle_> i always get an error "possibly incorrect indentation"
15:25:22 <atom> ski_: just to check if I'm reading this correctly: blah is a function that returns the appropriate tuple of player selection function and action list, and that tuple is then substituted back into the previous expression?
15:25:26 <rwbarton> dolio: Can you elaborate on "they [associated data families] don't enable type refinement based on pattern matching"?
15:25:32 <vixey> data DYN t where BOOL :: DYN Bool ; INT :: DYN Integer ; (:->:) :: DYN a -> DYN b -> DYN (a -> b)
15:25:34 <Saizan_> rwbarton: yeah, that, the typechecking of project uses type refinement
15:25:36 <atom> 'previous expression' being the part before the where
15:25:39 <gsan> rwbarton: Sorry, this might sound stupid, but can't you implement something like Typeable class with existential types?
15:25:39 <vixey> data DYNAMIC where UnDYNAMIC :: DYN t -> t -> DYNAMIC
15:25:40 <vixey> data Equal a b where REFL :: Equal x x
15:25:40 <dolio> rwbarton: I'm typing up a small example.
15:25:44 <pham> Holle_: AFAIU, newlines only matter in blocks, such as with do, case, let, etc
15:25:51 <vixey> with those 3 GADTs it's pretty obvious what to do
15:25:55 <rwbarton> Saizan_: Oh, OK
15:26:05 <vixey> decide :: DYN t -> DYN u -> Maybe (Equal t u)
15:26:14 <vixey> given that you can write unbox (UnDYNAMIC t e) u = case decide t u of ; Nothing -> Nothing ; Just REFL -> Just e
15:26:14 <idnar> WHY SO LOUD?
15:26:20 <pham> Holle_: hpaste it?
15:26:22 <pumpkin> Holle_: you need to make relevant bits line up... can you paste the code that doesn't work?
15:26:27 <rwbarton> dolio: Thanks.  Also take a look at http://hpaste.org/13738#a4 which compiles in HEAD
15:26:28 <ski_> atom : obviously i must be more tired than i think .. since i see yet another typo there
15:26:38 <dons> bos: do the llvm team know about the haskell llvm bindings?
15:26:44 <dons> seems like something they should mention on their site.
15:27:07 <vixey> yes and exactly like in rwbartons paste, you can extend this method for an open universe of codes of types
15:27:15 <pumpkin> the llvm site is really ugly
15:27:16 <atom> ski_: do tell. that one I probably didn't spot.
15:27:26 <ski_> atom : hold on .. i'll repaste the annotation instead .. simpler that way
15:27:28 <dons> ugly site, pretty assembly
15:27:32 <pumpkin> dons: yeah :)
15:28:19 <Holle_> http://hpaste.org/13839 in the function drawPolygonClick
15:28:26 <atom> ski_: thanks. I'd also need some commentary on the monad-rewrite of the doAction function. is that implementation functionally equivalent? Because I don't see any empty lists there.
15:28:35 <atom> @src guard
15:28:35 <lambdabot> guard True  =  return ()
15:28:35 <lambdabot> guard False =  mzero
15:28:41 <bogner> hmm, can hlint be used with ghc 6.8 at all?
15:28:52 <idnar> Holle_: "else" needs to be indented further than "if"
15:29:05 <idnar> actually, hmm
15:29:15 <EvilTerran> ?src [] mzero
15:29:15 <lambdabot> mzero = []
15:29:25 <Lemmih> ?ask SamB Can you do a write-up about the problems with type-classes?
15:29:25 <lambdabot> Consider it noted.
15:29:26 <atom> I see.
15:29:27 <idnar> bleh, I don't know my layout rules well enough
15:29:48 <pumpkin> Holle_: it would help if you said which part fails :)
15:29:55 <pumpkin> or included the error message
15:30:06 <pumpkin> if only to save idnar from being the human parser
15:30:16 <vixey> rwbarton, did you catch my attempt at typeable without classes?
15:30:40 <Holle_> drawPolygonClick "possibly incorrect indentation" the problem was the else case
15:30:43 <rwbarton> vixey: so for each type 'a' that I make an instance of Typeable I have an instance data DYN a where A :: DYN a; decide (DYN a) (DYN a) = Just REFL; decide (DYN a) _ = Nothing
15:30:48 <Holle_> as idnar said
15:30:59 <pumpkin> ah ok
15:31:04 <rwbarton> vixey: or rather, that's the class version
15:31:12 <rwbarton> vixey: if I understand what you wrote above correctly
15:31:14 <ski_> atom : there
15:31:23 <vixey> not sure about the type class version
15:31:32 <Holle_> but now it says parse error on input '<-' line 70
15:31:33 <atom> ski_: reading...
15:31:34 <vixey> the main thing in my one is pattern matching on an equality proof
15:31:43 <rwbarton> right
15:31:54 <vixey> thanks to this system Fc stuff, that works fine
15:32:02 <rwbarton> oh s/(DYN a)/A/g above
15:32:06 <idnar> liftIO(state <- writeIORef (0,-1))
15:32:12 <idnar> is not valid haskell syntax
15:32:20 <pumpkin> how does IORef differ from STRef?
15:32:34 <atom> ski_: very interesting.
15:32:49 <idnar> I don't know exactly what that code is doing, but maybe you mean "state <- liftIO (writeIORef (0,-1))"
15:33:12 <atom> ski_: I see exactly why this is so much better than what I did. Now can you explain why the monadic version of the doAction function is better?
15:33:20 <newsham> ?src IORef
15:33:21 <lambdabot> newtype IORef a = IORef (STRef RealWorld a)
15:33:22 <ski_> atom : so, initially i didn't notice you already had a variable `actions' (which you used in that piece of code) .. so it was an error of my to try to use that name for another thing
15:33:30 <vixey> with GADTs, everything is possible :)
15:33:39 <ski_> atom : no need to mention the `[]' ?
15:33:48 <idnar> Holle_: ^^^
15:33:53 <Holle_> idnar: yes thats what i mean
15:33:54 <rwbarton> vixey: so decide is like  decide BOOL BOOL = Just REFL; decide INT INT = Just REFL; decide (a :->: b) (a' :->: b') = case decide a a' of Nothing -> Nothing; Just _ -> case decide b b' of Nothing -> Nothing; Just _ -> REFL
15:34:04 <vixey> rwbarton, yes
15:34:06 <atom> ski_: I noticed that was regarded as some kind of crime... any particular reason?
15:34:12 <rwbarton> (I wonder whether it is possible to write that last bit with do notation)
15:34:13 <vixey> rwbarton, oops, no
15:34:18 <ski_> atom : maybe not a very big difference here .. but if you start writing more list-monad-like code, it will fit in nicer
15:34:23 <vixey> rwbarton, you have to match  Just REFL -> ...
15:34:28 <vixey> (I assume, ..)
15:34:35 <vixey> the _ just looks dangerous
15:34:41 <rwbarton> vixey: I can believe that
15:34:47 <vixey> bc. in Fc I guess it's like
15:34:48 <nolrai_East> Is there a version of read that returns an error (such as Left errmsg or Nothing) instead of calling error?
15:34:55 <nolrai_East> :t read
15:34:56 <lambdabot> forall a. (Read a) => String -> a
15:34:58 <idnar> :t reads
15:34:59 <lambdabot> forall a. (Read a) => String -> [(a, String)]
15:35:03 <atom> ski_: So... that's something you start to understand when you've written a bit more haskell than I have.
15:35:07 <vixey> REFL :: forall (gamma :: t ~ u), Eq t u
15:35:08 <idnar> :t listToMaybe . reads
15:35:09 <lambdabot> forall a. (Read a) => String -> Maybe (a, String)
15:35:24 <vixey> so if you don't match on REFL, the equality proof will not coerce the resulting type
15:35:26 <loadquo> ?src ($)
15:35:26 <lambdabot> f $ x = f x
15:35:34 <pham> @hoogle liftIO
15:35:35 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
15:35:56 <idnar> hmm, not exactly
15:35:59 <vixey> but yeah extending to an open universe of codes would be a neat thing
15:36:12 <dolio> rwbarton: http://hpaste.org/13840
15:36:19 <ski_> atom : depending on what the rest of your code will look like, it might (or might not) be a good idea to use the list monad .. for this simple case it doesn't really matter .. so use whichever version you prefer
15:36:35 <dolio> rwbarton: You can fancy it up some, but that's the gist.
15:36:55 <vixey> dolio, why not drop the t ->,  typeOf :: TypeRep t
15:37:03 <Holle_> line 64: liftIO (newIORef state) returns IORef (IORef State) but i need State
15:37:27 <atom> ski_: I really don't know how it will look - I still have to think much about it, but I think I'll just produce more lists of game states from past lists of game states with map used in strange and perverse ways
15:37:38 <luqui> Holle_, you mean IO (IORef state) ?
15:37:45 <dolio> vixey: I think it makes typeOf hard/impossible to implement for stuff like lists.
15:37:50 <ski_> atom : why do you have lists of game states, btw ?
15:37:52 <luqui> er...
15:38:01 <atom> ski_: to model n-ary trees.
15:38:08 <vixey> I'd have expected just:  typeOf = L typeOf  to work
15:38:08 <Holle_>  Couldn't match expected type `(a, b)' against inferred type `IORef (IORef State)'
15:38:09 <ski_> atom : i.e. what do the list elements signify ?
15:38:21 <vixey> because of typeclass dispatch
15:38:26 <pham> @hoogle UGen -> [Word8]
15:38:27 <lambdabot> Warning: Unknown type UGen
15:38:27 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
15:38:27 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:38:31 <ski_> atom : is the tree meant as a search tree .. for alternate possible scenarios ?
15:38:31 <atom> ski_: list elements are possible results of dice-throws and player decisions.
15:38:55 <atom> ski_: there are probability members missing from the game state record set
15:39:14 <ski_> ok
15:39:22 <luqui> I love how hoogle returns unsafeCoerce
15:39:32 <dolio> vixey: Hmm, yeah. I'm not sure why, then.
15:39:39 <atom> ski_: The goal is to calculate the probability that one player will win versus the other
15:39:39 <ski_> atom : it might be that you could use some list (or probability) monad for some of that code then .. (not sure)
15:39:40 <dolio> vixey: I thought there was a reason, though. :)
15:39:47 <vixey> I wonder if we could have open GADTs
15:40:16 <Holle_> why is s <- liftIO (newIORef state) where state is from the Type State  not the same type as State?
15:40:18 <vixey> It's possible to sort of tie a knot with them but that's not very nice
15:40:30 <atom> ski_: I'll be posting intermediate code frequently in the coming weeks because a) people here are smart and have good comments and b) I'm still very much learning haskell and have no idea how the list monad works.
15:40:30 <ski_> vixey : how would we back-patch `case's when we add new constructors ?
15:40:35 <ski_> (or maybe we wouldn't ..)
15:40:49 <rwbarton> Holle_: s <- liftIO (newIORef state)  isn't an expression at all
15:41:15 <atom> ski_: so thanks a lot for the help - it will no doubt improve my future code. The rest of it will come along the way (or so I hope)
15:41:19 <Holle_> what's wrong?
15:41:33 <atom> in the meantime I'm haveeing rall trouble renaming the blah function :)
15:41:38 <delta214> Could someone help me? Whats a simple code to find each a specific fib number by calculating each fib in sequence and adding the two previous to get the final answer?
15:41:43 <vixey> dolio, btw I implemented this in Coq once to get coherency or whatever it's called without axiom K once :)
15:41:49 <vixey> (Data.Dynamic that is)
15:41:52 <ski_> (rwbarton : btw, that `decide' looks tempting to try and cast in the `Maybe' monad)
15:42:08 <rwbarton> ski_: Yes, I wonder about that too, whether it could be done
15:42:18 <vixey> REFL <- decide a
15:42:20 <vixey> REFL <- decide b
15:42:22 <vixey> return REFL
15:42:27 <pumpkin> "Every valid expression e in Gallina is associated with a specification, itself a valid expression, called its type τ(E). We write e:τ(E) for the judgment that e is of type E. You may request Coq  to return to you the type of a valid expression by using the command Check:"
15:42:36 <dolio> rwbarton: Basically, I need a type "TypeRep t" where matching on a constructor tells me what t is.
15:42:38 <pumpkin> someone has a fascination with poultry
15:42:41 <rwbarton> Holle_: It's valid Haskell code, it's just not an *expression*.  It's like asking for the type of "import Data.List"
15:42:46 <atom> ?where guard
15:42:47 <lambdabot> I know nothing about guard.
15:42:58 <atom> ok, what do I need to import to get guard?
15:43:03 <mux> atom: Control.Monad.Guard
15:43:06 <dolio> rwbarton: But if you do "class Typeable t where data TypeRep t :: *", you need to know what t is before you know what constructors you're allowed to match against.
15:43:10 <dolio> rwbarton: I think, at least.
15:43:11 <Holle_> and how do i get the value of state?
15:43:12 <ski_> rwbarton : is that for a GADT ? or for associated data types ? (oh, no .. yet another term whose abbreviation is "ADT" !)
15:43:29 <rwbarton> dolio: Yeah, I'm trying what I expected to be the obvious translation of the code to use associated data families, and it doesn't seem to be working
15:43:36 <psygnisfive> hmm
15:43:37 <atom> mux: thanks
15:43:52 <luqui> delta214, sure, what do you have so far?
15:44:05 <atom> compiles and runs. Now I'm hitting the sack. pronto.
15:44:10 <atom> thanks for everything.
15:44:15 <vixey> I think lambda and GADT are great.. but the other stuff like associated types and type classes.. they don't seem quite right I'm not sure why
15:44:32 <ski_> (atom : it might be simpler to invent a name if we knew what that action list stood for ..)
15:44:48 <vixey> (very useful though)
15:44:54 <atom> ski_: I just named it playerActionTuple :)
15:45:00 <delta214_> Could someone help me? Whats a simple code to find a specific fib number by calculating each fib in sequence and adding the two previous to get the final answer?
15:45:05 <luqui> vixey, well associated types (er, type families) seem fine to me, those are just functions
15:45:13 <ski_> (maybe `playerAndActions' ..)
15:45:16 <luqui> typeclasses, though, do rub me the wrong way
15:45:19 <psygnisfive> data constructors in haskell are used for pattern matching right? foo (Thing x) = ... right?
15:45:19 <luqui> but they are indeed useful
15:45:31 <vixey> luqui, ugly functions:  http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=751#a753
15:45:33 <ztirf_> @pl \k -> x!k <= x'
15:45:33 <lambdabot> (<= x') . (x !)
15:45:34 <luqui> delta214_, I said: sure, what do you have so far?
15:45:49 <dolio> rwbarton: Although with associated data, you could possibly make something like "class TypeableUniverse u where data TypeRep u :: * -> * ...", and allow people to declare additional universes (possibly extending the old ones somehow) and still use the same machinery.
15:45:52 <atom> ski_: on your turn, you can do one standard, one move and one minor action, and substitute a longer action for a shorter one (standard > move > minor)
15:46:01 <atom> free actions are, well, free on your turn
15:46:03 <luqui> vixey, touche
15:46:09 <vixey> luqui, I read the Fc paper but I still don't really understand why it must be this horrible equation language instead of say, simple typed lambda calculus with lexi-structural recursion
15:46:15 <atom> immediate actions can only be done when it's not your turn.
15:46:33 <pham> Holle_: hm, liftIO seems to complexify things. Why not modify the IORef outside the Render function?
15:46:37 <dolio> rwbarton: I don't know how useful that is in practice, though.
15:46:44 <dolio> Probably not very.
15:46:47 <atom> when you perform them ghey'll get erased from the available actions list, but that's not written yet.
15:46:47 <Holle_> now it works :)
15:46:48 <ski_> ok
15:46:56 <atom> ski_: and that's the whole story.
15:47:22 <luqui> vixey, the openness requirement perhaps...
15:47:45 <vixey> luqui, oh geez.. that is it.. and it's so simple
15:48:00 <ski_> we need datakinds
15:48:03 <vixey> luqui. well why didn't the implement both :p
15:48:12 <rwbarton> dolio: I guess this has to do with the fact that we want to dispatch on a pair of types, not just one
15:48:12 <luqui> lack of tuits probably :-)
15:48:31 <vixey> round tuits?
15:48:42 <luqui> yes, those.
15:49:16 <ski_> ("tuits" meaning "intuits" ?)
15:49:56 * loadquo googled and found that tuits is short for "to it" as in "get around to it" 
15:50:40 <luqui> they give out round tuits at perl conferences.  that's why CPAN is so big.
15:54:24 <dolio> rwbarton: Well, I think it's due to typeable needing values providing information about types, whereas data families are about type providing information about values.
15:54:33 <ski_> <ski_> rwbarton : is that for a GADT ? or for associated data types ? (oh, no .. yet another term whose abbreviation is "ADT" !)
15:55:25 <pumpkin> abstract/algebraic/associated/awesome
15:55:38 <pumpkin> whoa, this can't be good
15:55:46 <rwbarton> ski_: I lost the context, sorry
15:55:47 <pumpkin> I'm getting a segfault in my ghc-compiled program
15:56:00 <pumpkin> and I'm not even doing anything unsafe this time!
15:56:02 <ski_> rwbarton : the `decide' you mentioned
15:56:30 <dons> pumpkin: scary
15:56:33 <dons> can you hpaste it?
15:56:38 <pumpkin> the program?
15:56:45 <pumpkin> it's kinda large
15:56:53 <pumpkin> let me see if it still occurs with no optimization
15:57:01 <JuanDaugherty> ski_, "round tuit": "when I can get around to it".
15:57:11 <rwbarton> ski_: The one I wrote out didn't involve any associated data types, just ordinary GADTs
15:58:09 <CakeProphet> does _|_ look like something vulgar to anyone else?
15:58:22 <pumpkin> CakeProphet: only if I'm dirty mind mode
15:58:25 <Axman6> how efficient are the parallel arrays in ghc at the moment?
15:58:37 <CakeProphet> I suppose it's appropriate as a error/non-termination value.
15:58:53 * dolio leaves for a while.
15:58:56 <ski_> rwbarton : ty
15:59:17 <Holle_> is it possible to fix the window size using gtk2hs? the user shouldn't be able to resize the window.
15:59:19 <ski_> (M-x dirty-mind-mode)
16:00:08 <Axman6> dons: i was taking a look at your n-bodies solution for the shootout... there's some evil wizardry going on there :|
16:01:11 <BMeph>  (_|_)
16:01:17 <BMeph>    \/
16:02:41 <Saizan_> what's that?
16:02:52 <mxc> ?seen dons
16:02:52 <lambdabot> dons is in #concatenative, #arch-haskell, #novalang, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 6m 18s ago.
16:02:58 <mxc> ?seen bos
16:02:59 <lambdabot> bos is in #haskell and #ghc. I don't know when bos last spoke.
16:03:30 <ztirf_> :type searchFromTo
16:03:34 <mxc> just got my copy of RWH, tried my best to give a good review on amazon, hope it helps
16:03:35 <mxc> thanks guys
16:03:37 <ztirf_> @type searchFromTo
16:03:39 <lambdabot> Not in scope: `searchFromTo'
16:04:01 <Holle_> nobody nows an attribute to stop resizing?
16:04:24 <CakeProphet> > lol 0 = ""; lol (n+1) = "n+k patterns are dumb " ++ (lol n) in lol 100
16:04:25 <lambdabot>   <no location info>: parse error on input `='
16:04:45 <CakeProphet> ...
16:04:47 <EvilTerran> n+k patterns also aren't supported by lambdabot :P
16:04:48 <dons> Axman6: hmm
16:04:55 <CakeProphet> excellent.
16:04:56 <EvilTerran> i think
16:05:01 <dons> Axman6: i think almost all of them can be re-done in ST only now
16:05:03 <EvilTerran> although you do need a "let" for that, regardless
16:05:11 <EvilTerran> > let lol 0 = ""; lol (n+1) = "n+k patterns are dumb " ++ (lol n) in lol 100
16:05:13 <lambdabot>   "n+k patterns are dumb n+k patterns are dumb n+k patterns are dumb n+k patt...
16:05:15 <rwbarton> > let (n+1) = 3 in n
16:05:16 <lambdabot>   2
16:05:27 <EvilTerran> ok, i stand corrected on the lambdabot's support thing.
16:05:48 <Ralith> rwbarton: hey that's pretty neat
16:06:03 <Axman6> dons: yeah i'm trying to write a clearer version. doing it with lists first, then thinking of using either a mutable IO array, ST array, DiffArray or DPH
16:06:09 <ski_> > let (f (n+1) + 1) = n in f 3
16:06:10 <lambdabot>   <no location info>: Parse error in pattern
16:06:23 <dons> ok. well, you'll have to keep  it in a double array, packed, for good cache effects
16:06:27 <dons> otherwise performance suffers.
16:06:32 <dons> but try to parallelise it!
16:07:09 <ski_> > let (m+2,n+3) = (4,4) in (m,n)
16:07:10 <lambdabot>   (2,1)
16:09:07 <athos> good night everyone
16:10:00 <CakeProphet> EvilTerran:  oh... I forgot to put let. wow.
16:11:12 <EvilTerran> must be too early in the morning :P
16:11:20 <dcoutts> Holle_: yes, see the documentation for the Window type
16:11:34 <CakeProphet> you know... for a long time it's felt like Haskell has been missing some key feature that would integrate all of its existing features into a cohesive structure. I now know what that feature is: embedded assembly
16:11:43 <CakeProphet> EvilTerran:  it's 7:11 PM here.
16:11:53 <rwbarton> CakeProphet: Harpy? LLVM?
16:12:06 <ski_> (CakeProphet : too early, then)
16:12:30 <Holle_> docutts: it exists an attribte windowResizeable, but if i use it the size of the window reduces to 0x0
16:13:41 <Axman6> CakeProphet: can you guarantee purity with that?
16:13:57 <CakeProphet> Axman6: I'd say no.
16:14:02 <rwbarton> CakeProphet: see near the bottom of this: http://moonpatio.com/repos/brain/src/Brain/Compile.hs
16:14:09 <CakeProphet> I don't think you could guarantee much of anything.
16:14:11 <CakeProphet> really.
16:15:57 <Axman6> CakeProphet: couldn't you use the FFI to do that?
16:16:00 <Holle_> why windowResizebale takes effect on the size of the window?
16:19:06 <CakeProphet> @web1913 facetious
16:19:17 <lambdabot> *** "Facetious" web1913 "Webster's Revised Unabridged Dictionary (1913)"
16:19:17 <lambdabot> Facetious \Fa*ce"tious\, a. [Cf. F. fac['e]tieux. See
16:19:17 <lambdabot>    {Faceti[ae]}.]
16:19:17 <lambdabot>    1. Given to wit and good humor; merry; sportive; jocular; as,
16:19:17 <lambdabot>       a facetious companion.
16:19:19 <lambdabot> [4 @more lines]
16:19:32 <CakeProphet> Axman6:  ^^
16:19:39 <CakeProphet> :3
16:19:43 <Axman6> bah
16:19:50 <Axman6> it's still possible :)
16:20:00 <Axman6> i'm also not used to being awake this early :P
16:21:06 <EvilTerran> CakeProphet, ah, yes; your CTCP time started 07:..., so i assumed 24-hour time and so 7am, even though it said PM at the end :P
16:21:22 <EvilTerran> CakeProphet, it's too early in the morning for me, anyway :P
16:21:25 <CakeProphet> dunno. I've never used FFI
16:21:40 <CakeProphet> EvilTerran: I make dumb typos at all hours.
16:22:16 <Trafalgard> The haskell wiki has this example, and I went wow, this is just what I've been trying to do!, but... it doesn't actually compile X_x:
16:22:16 <Trafalgard> newtype Color = Color Int deriving (Eq,Ord,Enum)
16:22:16 <Trafalgard> (red:blue:black:_) = [Color 1 ..]
16:22:40 <Trafalgard> The error is:
16:22:57 <Trafalgard> Can't make a derived instance of `Enum Color' (`Color' has non-nullary constructors)
16:22:57 <Trafalgard> In the newtype declaration for `Color'
16:23:19 <Trafalgard> except Color doesn't have any parameters for its constructor, so I don't get it
16:23:32 <Saizan_> Int is the parameter
16:23:35 <CakeProphet> for Enum to be derived it'd have to be something like data Color = Red | Blue | Green
16:23:38 <EvilTerran> Trafalgard, yes it does, its constructor is Color :: Int -> Color
16:23:43 <Axman6> you need more than one data constructor to derive Enum: data Foo = A | B Int | C String deriving Enum -- for example
16:23:45 <ski_> Trafalgard : newtype deriving
16:23:45 <CakeProphet> which wouldn't be helpful
16:23:56 <Trafalgard> Can't do that, defeats the point of what I'm trying to do --> <CakeProphet> for Enum to be derived it'd have to be something like data Color = Red | Blue | Green
16:24:02 <Saizan_> Axman6: that won't compile for the same exact reason
16:24:04 <CakeProphet> right.
16:24:15 <EvilTerran> CakeProphet, i thought the report also allowed for single constructors where the parameter was of an Enum type
16:24:20 <Axman6> really? mm
16:24:22 <CakeProphet> Trafalgard:  what exactly is [Color 1..] supposed to do?
16:24:42 <rwbarton> Trafalgard: listen to ski_ :)
16:24:47 <Trafalgard> it makes red 1, blue 2, green 3, and I presume we get some strange magic after it
16:24:57 <Trafalgard> newtype deriving?
16:25:06 <Trafalgard> imanewbie so I don't know what you mean
16:25:07 <ski_> it's a ghc extension
16:25:14 <ski_> look up the language options
16:25:17 <Trafalgard> okay
16:25:18 <Saizan_> Trafalgard: add {-# LANGUAGE GeneralizedNewtypeDeriving #-}
16:25:23 <Saizan_> at the top of your file
16:25:23 <ski_> (i can't recall the actual option name, atm)
16:25:34 <Trafalgard> thanks, I'll try that
16:25:43 <abuiles> HI guys, maybe can someone see an indentation problem  here :http://hpaste.org/13841
16:25:49 <ski_> (s/option/language/)
16:25:55 <abuiles> For me it looks ok
16:26:08 <CakeProphet> Trafalgard:  I don't think [Color 1..] would give you what you want.
16:26:12 <abuiles> any clue?
16:26:14 <Trafalgard> that made it compile indeed
16:26:15 <Trafalgard> yeah
16:26:19 <Trafalgard> that's just the wiki example
16:26:42 <rwbarton> Trafalgard: Anyways, there are probably better ways to do this, like (red:blue:black:_) = map Color [1..], or data Color = Red | Blue | Black
16:26:43 <CakeProphet> if you want the R G and B values of a color you'd just want (Color r g b) = color  or even just (r,g,b) = color
16:26:47 <CakeProphet> if color is (Int, Int, Int)
16:26:54 <Trafalgard> heh, that was red blue and black even
16:27:03 <Trafalgard> they picked random arbitrary colors
16:27:15 <Trafalgard> I said green by habit
16:28:08 <ski_> abuiles : possibly there's a problem in code before or after that snippet ?
16:29:32 <abuiles> ski_ : It looks like the problem is in  CommentsModel.insert.... Because I delete that part and It works,
16:30:55 <ski_> and the error message is ?
16:30:59 <abuiles> ski_ : I got this error , "Error specification: Error in server: Maybe.fromJust "
16:31:21 <ski_> that's a run-time error
16:31:30 <ski_> not a syntax error
16:31:37 <nolrai_East> @unmlt StateT s (Error e) a
16:31:38 <lambdabot> Maybe you meant: unmtl unpl
16:31:51 <nolrai_East> @unmtl StateT s (Error e) a
16:31:52 <lambdabot> s -> Error e (a, s)
16:32:18 <ski_> abuiles : so, somewhere in the code, you're calling `fromJust' on `Nothing')
16:32:32 <nolrai_East> @unmlt ErrorT e (State s) a
16:32:33 <lambdabot> Maybe you meant: unmtl unpl
16:32:37 <ahunter> So, trying to install a built ghc head via "make install", I'm getting errored out with " ghc-pkg: /usr/local/lib/ghc-6.11.20090109/package.conf: openFile: does not exist (No such file or directory)"--any ideas?
16:32:44 <nolrai_East> @unmtl ErrorT e (State s) a
16:32:45 <lambdabot> s -> (Either e a, s)
16:35:15 <loadquo> Is this a semi-decent sieve of  Eratosthenes thttp://hpaste.org/13842#a1 ?
16:35:23 <pumpkin> dons: damn, I get a segfault even with no -O :P
16:36:03 <pumpkin> it just takes 20 minutes before it segfaults
16:36:03 <loadquo> Oops, link is http://hpaste.org/13842#a1
16:36:10 <abuiles> ski_: this is the full code, less than 10 lines http://hpaste.org/13843
16:36:35 * wli put up a good Eratosthenes at some point.
16:36:41 <pumpkin> wli: yay :)
16:37:16 <ahunter> loadquo: noooooooooo.
16:37:27 <wli> Here's one:
16:37:32 <wli> http://hpaste.org/2399
16:38:08 <ahunter> loadquo: www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
16:38:10 <loadquo> I've read the paper going on about the True sieve, but I didn't care about laziness and infinite lists in my quick and dirty implementation.
16:38:37 <loadquo> I was wondering whether I could have used a fold of some variety.
16:38:45 * wli put a more efficient one up recently.
16:38:47 <ahunter> loadquo: ...that isn't about laziness and infinite lists. you're implementing a completely different algorithm.  It's /not/ the sieve.  Trust me, I work for that Prof.
16:39:15 <BMeph> loadquo: That's a Naive sieve, not an Eratosthenes sieve. :)
16:39:21 <pumpkin> ugh, not used to gdb on haskell :P
16:39:24 <ahunter> wli: yeah, I saw...looks vaguely like Melissa's, though I'd have to pull up the code to comprae
16:39:52 <timebomb> whats meant with strong typing?
16:40:08 <pumpkin> timebomb: a pianist on a computer keyboard
16:40:33 <timebomb> heh
16:41:01 <BMeph> pumpkin: What about a garlic picker on a computer keyboard? ;p
16:41:21 <loadquo> Hmm, possibly. A problem for another day. Night #haskell
16:41:22 <Ralith> BMeph: that's smelly typing.
16:41:43 <BMeph> Ralith: Ah, but it's STRONG smelly typing! ;)
16:42:29 <roconnor> why are people not being helpful for timebomb?  Seems like a legit question?
16:42:32 <ski_> (abuiles : annotate the original paste next time, ok ?)
16:42:53 <abuiles> ok
16:43:00 <abuiles> sorry about it
16:43:06 <dons> ?users
16:43:06 <lambdabot> Maximum users seen in #haskell: 649, currently: 606 (93.4%), active: 26 (4.3%)
16:43:07 <timebomb> roconnor: id probably answer the same way ... :p
16:43:50 <dons> timebomb: hmm. its an interesting definitional question
16:43:51 <ski_> abuiles : so it might be that one of those imported modules has a bug .. or it might be that a pre-condition was violated, somewhere
16:44:20 <roconnor> timebomb: strong typing typically means that you cannot change the types of expressions willy nilly by casting and such.
16:44:31 <roconnor> timebomb: not to be confused with static typing
16:44:32 <kmeyer> hm, if I do foo <- readLn, and foo is some custom data type with an array 'bar', how do I define foo2 to be foo but with bar reversed?
16:44:34 <dons> as bjp says, ""I spent a few weeks... trying to sort out the terminology of "strongly typed," "statically typed," "safe," etc., and found it amazingly difficult.... The usage of these terms is so various as to render them almost useless.""
16:44:37 <abuiles> ski_: Thanks
16:44:55 <dons> strongly typed programs never reach undefined states wrt. the type system?
16:44:59 <ski_> abuiles : not much more one can say, given this snippet, i think
16:45:27 <roconnor> dons: I understand strength to be about how easy it is to cast types.
16:45:41 <roconnor> or rather how hard it is to cast types
16:45:56 <dons> mmm. i'd have related it to progress and preservation.
16:45:58 <roconnor> but I could be wrong
16:46:10 <dons> but i'll defer to Pierce here.
16:46:16 <ddarius> dons: It's an easy problem.  People just don't use the words consistently at all.  There is no way to make a choice that everyone will agree with.
16:46:22 <roconnor> what does Pierce say?
16:46:25 <dons> yep
16:46:31 <dons> roconnor: see above.
16:46:38 <dons> "usage of these terms is so various as to render them almost useless"
16:46:55 <roconnor> bah, that is a cop out response
16:46:55 <ddarius> So you just need to define what you mean before you use such terms.
16:47:16 <timebomb> hm well in the why haskell doc it uses strong typing as reference to why it can just use the qucksort for any type, but considering roconnors definition i usually consider it kinda powerful to cast types the way you want them as long as you know what youre doing
16:47:17 <roconnor> although it is probably true
16:47:48 <dons> strong typing ensures you don't have to know what you're doing, perhaps
16:48:12 <roconnor> timebomb: powerful a.k.a. dangerous :)
16:48:13 <ddarius> roconnor: It is the truth.  But it isn't a cop out.  You can give a meaning to each that's useful.  It's just others mix what meanings they give to what (or just use totally different/broken meanings elsewhere)
16:48:28 <timebomb> yes true
16:49:48 <timebomb> another question i noticed that haskell seems to be rather fast. but if you use recurson everywhere. the mem usage should be insane no? but probably i just misunderstand functional programming
16:50:02 <roconnor> timebomb: do you have a link to the useage in question?
16:50:04 <ddarius> timebomb: You misunderstand recursion.
16:50:31 <pumpkin> dons: still getting that segfault... is there any way I can compile with the -g equivalent?
16:50:49 <timebomb> nah, that's a bit the problem i guess. learning a language without goal is a bit pointless
16:51:02 <pumpkin> timebomb: haskell people like pointless
16:51:08 <pumpkin> @pl haskell
16:51:08 <lambdabot> haskell
16:51:09 <timebomb> hehe
16:51:11 <Ralith> pointfree, too
16:51:14 <pumpkin> haskell's definitely pointless
16:51:18 <roconnor> timebomb: in haskell, mem usage is somewhat difficult to predict.
16:51:20 <dons> pumpkin: sure. pass through usual -optc-g et al
16:51:25 <dons> then use gdb to get a stack trace
16:51:29 <pumpkin> okay :)
16:51:39 <roconnor> timebomb: but mem usage is manageable, especially due to lazy evaluation.
16:51:42 <pumpkin> do I need via-C for that optc?
16:51:47 <wli> This doesn't look right, but: http://hpaste.org/13040
16:51:55 <dons> timebomb: loops are just a special form of recursion.
16:52:04 <Ralith> timebomb: I've always found a use for a language *after* learning it
16:52:16 <timebomb> Ralith: was always the other way round for me
16:52:30 <timebomb> i found a purpose and then learned the language. yi might be that
16:52:32 <timebomb> but im not sure
16:53:09 <roconnor> timebomb: lazy evaluation allows the garbage collector to clean up unused data before continuing recursion in many cases.
16:53:13 <dons> you could skill up and learn to program multicore boxes
16:53:20 <timebomb> roconnor: actually i read this http://cgi.cse.unsw.edu.au/~dons/blog/2008/05/16
16:53:44 <roconnor> timebomb: strict evaluation allows the garbage collector to clean up unused data for tail recursive function.
16:55:01 <timebomb> haskell is the one language that makes me feel like im listening to computer science lecture the whole time
16:55:04 <Ralith> timebomb: here's a reason, then: Learn to think in a new way.
16:55:22 <ahunter> dons: skill up?  programming is hardly an RPG, thank god, I like to separate business and pleasure :P
16:55:26 <pumpkin> dons: my stack trace says I'm crashing in s5sr_info () :P and there's no info beyond that
16:55:35 * roconnor needs to restart firefox
16:55:46 <dons> ahunter: you don't find programming a joyful activity? :)
16:55:47 <timebomb> Ralith: that's probably the only reason im curious about it
16:56:06 <ahunter> dons: I do, but I don't consider myself to be a 4th level programmer.  :P
16:56:11 <dons> pumpkin: any segfault in pure code is a compiler or runtime bug, pumpkin
16:56:11 <amaron_> ahunter: why should you seprate business and pleasure?
16:56:15 <Ralith> timebomb: also you can tell people "I know functional programming!" and they'll be all "wow he's hax" :D
16:56:23 <pumpkin> dons: yeah, I realize that :P
16:56:35 <Ralith> ahunter: imo unifying business and pleasure is the ideal world
16:56:41 <dons> you could paste the code and we could try to reproduce it
16:56:57 <timebomb> usually ppl say that when you say you know multiple asm
16:56:59 <timebomb> hehe
16:57:01 <ahunter> jeez, admit you do different things during the day and night and suddenly everyone's a critic :P
16:57:06 * wli suspects that may be all the easily-recoverable Eratosthenes code he's got on hpaste.org
16:57:09 <kmeyer> how do I go about manipulating an IO Maybe?
16:57:25 <pumpkin> dons: alright
16:57:33 <ahunter> Can't a guy make a joke about distinctions between RPGs and programming in peace?
16:57:59 <Valodim> (2) No!
16:58:21 <ahunter> Ralith: for that matter, what about those of us who like stressful jobs?  worthwhile, good, first choice, but not always pleasurable per se
16:58:23 <Ralith> timebomb: ASM is mundane
16:58:39 <seafood> Lemmih: are you there? If you are, are you the current maintainer of HAppS?
16:58:39 <Saizan_> kmeyer: do you know how to manipulate an IO Foo in general?
16:58:42 <Ralith> ahunter: sure, and that can be a good situation, but not the ideal one.
16:58:50 <amaron_> ahunter: what do you do on your job?
16:58:53 <timebomb> Ralith: it should be, but it most definitely isn't
16:58:54 <Ralith> ideal is you get paid to be happy
16:58:54 <timebomb> anyway
16:59:00 <kmeyer> Saizan_: nope :(
16:59:00 <ahunter> amaron_: 20 credit hours :P
16:59:04 <Ralith> timebomb: but it is!
16:59:11 <Ralith> timebomb: it's arcane but still mundane
16:59:18 <timebomb> depends what you mean when you mean knowing
16:59:24 <timebomb> when you say*
16:59:25 <timebomb> wow
16:59:27 <timebomb> its late
16:59:32 <rwbarton> Couldn't match expected type `Ptr Word8' against inferred type `GHC.Ptr.Ptr Word8' -- why is this happening?
16:59:35 <ahunter> ralith: different strokes, different folks.  I like doing things I enjoy but have several friends who have chosen jobs solely on basis of challenge and reward, because they're adrenaline junkies.
16:59:39 <rwbarton> I think one is coming from LLVM and the other from ByteString
16:59:50 <dons> anyone played the opengl haskell tetris?
16:59:58 <dons> rwbarton: oh, weird...
17:00:01 <Ralith> ahunter: sounds like they enjoy them to me.
17:00:06 <dons> rwbarton: two different versions of base?
17:00:32 <Lemmih> seafood: I may be the maintainer. Depends on the severity of your problem.
17:00:36 <dons> heh
17:00:37 <timebomb> ahunter: so do i, doesn't mean i always get paid for them :P
17:00:39 <ahunter> ralith: not really, but w/e...not worth arguing :P
17:00:56 <Saizan_> kmeyer: it looks like you need to learn about monads :) http://www.haskell.org/haskellwiki/Monads_as_computation
17:00:57 <amaron_> ahunter: I choose a job only if I can learn something there. When it becomes boring, I leave.
17:00:58 <rwbarton> dons: I don't know if that's the problem.  If I import both Foreign.Ptr and LLVM.Core, then Ptr is an ambiguous reference
17:01:04 <kmeyer> Saizan_: I do :) thanks for the link
17:01:18 <rwbarton> dons: I will look through the source
17:01:25 <timebomb> amaron_: where you from?
17:01:44 <amaron_> timebomb: serbia
17:02:01 <amaron_> but all my companies I worked in are world wide
17:02:03 <rwbarton> dons: ah, it may be a version problem indeed
17:02:07 <timebomb> i had a coworker whos name was your nick
17:02:10 <timebomb> hehe
17:02:29 <pumpkin> dons: like the other time, I need to include a data file: http://pumpkinpat.ch/minimal_test.zip
17:02:45 <rwbarton> Yeah, problem solved by more cabal install-ing
17:03:18 <Eiler> dons: "For heavy optimisation, the C backend to GHC is still the way to go. Later this year a new bleeding edge native code generator will be added to GHC, but until then, the C backend is still an awesome weapon. " have that new coder generator been added yet?
17:03:41 <dons> yeah.
17:03:49 <dons> i'm not sure its finished yet though
17:04:04 <Eiler> any performance improvement?
17:04:54 <pumpkin> dons: I compiled with ghc -O2 --make -o minimal minimal.hs but I get segfault even without the -O2 (it takes about 45 seconds to segfault on O2, 20 minutes with no optimization)
17:05:53 <dolio> Eiler: If it's in, it's not in any released version.
17:06:39 <dons> pumpkin: mm.
17:06:39 <Eiler> ok
17:07:04 <pumpkin> dons: segfault for you too?
17:07:16 <dons> testing
17:07:21 <pumpkin> okay, thanks a lot :)
17:07:48 <timebomb> amaron_: germany
17:08:39 <amaron_> do you want to replace shell, perl and python scripts with haskell code?
17:09:07 <timebomb> well perl and python scripts.
17:09:19 <Saizan_> i'd like an haskell shell, given how much i dislike bash
17:09:30 <timebomb> zsh is nice
17:09:36 <timebomb> but similar syntax
17:09:46 <amaron_> they are both good for the job, but if you can write with same amount of code
17:10:00 <dons> i like haskell programs rather than shell scripts
17:10:06 <roconnor> me too
17:10:21 <roconnor> runhaskell++
17:10:22 <amaron_> it would be cool to have unix/linux based on haskell code
17:10:23 <Ralith> Saizan_: how would a haskell shell work?
17:10:39 <dolio> Linspire uses some Haskell, reportedly.
17:10:57 <Saizan_> Ralith: something on top of ghci/ghc-api
17:11:11 <Saizan_> Ralith: with additional syntactic sugar, probably
17:11:14 <amaron_> dolio: but imagine all /etc/rc.d scripts written in haskell
17:11:32 <amaron_> haskell based linux
17:11:33 <Ralith> Saizan_: that would need a lot of syntatic sugar to be usable, I think
17:11:37 <Ralith> then again, maybe not
17:11:49 <repnop> amaron_: aiming for job security? ;p
17:11:49 <Ralith> haskell function call syntax is a lot like calling a program w/ argument
17:11:50 <Saizan_> i don't think so
17:11:50 <Ralith> s
17:11:52 <ztirf_> @type maybeToList
17:11:54 <lambdabot> forall a. Maybe a -> [a]
17:12:05 <ztirf_> @src maybeToList
17:12:05 <lambdabot> maybeToList  Nothing   = []
17:12:05 <lambdabot> maybeToList  (Just x)  = [x]
17:12:28 <Ralith> Saizan_: that actually sounds like a fun project
17:12:34 <amaron_> repnop: i think would be most secure os
17:12:50 <repnop> why?
17:12:51 <Ralith> amaron_: and a most secure job!
17:12:59 <dons> you want fast, safe boot up code, right?
17:13:01 <repnop> all the services are still going to be written in c ;)
17:13:06 <dons> the boot sequence is the last thing you want  to go wrong
17:13:17 <dons> well, maybe the kernel is also something we should do
17:13:22 <Ralith> dons: see House
17:13:29 <amaron_> i think there are some os projects
17:13:34 <amaron_> yes, House
17:13:36 <Ralith> there's at least one
17:13:40 <roconnor> Ralith: I saw a PhD on a type file system in Clean
17:13:53 <roconnor> typed file system
17:13:53 <Ralith> a type file system?
17:13:53 <Ralith> O.o
17:13:53 <dons> Ralith: my job involves haskell kernel hacking this year :)
17:13:57 <roconnor> programs were functions
17:14:07 <dons> there's several haskell 'kernels' (or runtimes on bare metal)
17:14:09 <Ralith> dons: cool!
17:14:11 <timebomb> ah a little question maybe that helps me getting the whole functional programming stuff
17:14:25 <Ralith> dons: hey, what do you think of putting haskell on a microcontroller?
17:14:26 <pumpkin> roconnor: that sounds interesting
17:14:30 <ddarius> Ralith: There's at least two.
17:14:37 <Ralith> ddarius: cool.
17:14:51 <timebomb> when you change yi config the next yi startup will be slower saying recompiling custom yi
17:14:54 <timebomb> why is that?
17:15:02 <dons> it has to recompile it?
17:15:06 <Ralith> timebomb: compiling in your config changes.
17:16:04 <timebomb> ok not related then
17:16:12 <timebomb> hehe
17:17:37 <Saizan_> Ralith: one cool thing this shell could provide is typed wrappers around common programs
17:18:26 <Ralith> Saizan_: I'd be reluctant to implement something like that if it can't be generalized across all programs.
17:18:45 <amaron_> dons: you use haskell on your work?
17:18:48 <Saizan_> Ralith: yeah, the users could add more of those for other ones
17:18:56 <Ralith> besides
17:19:05 <Ralith> it's a neat concept but you'd have to take too many liberties implementing it
17:19:12 <Ralith> programs only ever actually *return* integers
17:19:21 <Ralith> so you'd have to parse stdout, read files, or something
17:19:25 <roconnor> ints
17:19:27 <Ralith> and that violates expected behavior for the program
17:19:44 <Saizan_> yeah, CPUs kind of only use ins and floats, but we still have types
17:19:46 <Ralith> roconnor: I didn't capitalize; it's pretty clear I wasn't referring to Integers :P
17:20:05 <roconnor> :)
17:20:08 <Ralith> Saizan_: I'm pretty sure most programs don't encode data in their return values.
17:20:14 <Ralith> beyond success/faliure
17:20:16 <Ralith> failure
17:20:28 <Saizan_> i was talking about stdin and stdout, really
17:20:56 <Saizan_> and arguments of course
17:21:04 <Ralith> Saizan_: if you make it transparent, perhaps
17:21:06 <Ralith> i.e.
17:21:13 <dons> amaron_: yeah, i work at galois.com, we use haskell for pretty much everything.
17:21:21 <Ralith> run stdout to the term as well as to the type you're constructing
17:21:39 <Ralith> dons: don't you have trouble finding new employees?
17:22:15 <dons> nope.
17:22:24 <dons> there's more haskellers than jobs for haskellers
17:22:26 <dons> ?users
17:22:26 <lambdabot> Maximum users seen in #haskell: 649, currently: 600 (92.4%), active: 20 (3.3%)
17:22:32 <ray> ?jobs
17:22:32 <lambdabot> Maybe you meant: docs join
17:22:47 <dons> and we just train up people anyway.
17:23:04 <dons> if you can learn the intricacies of C++, you can probably handle haskell :)
17:23:07 <Ralith> channel popularity is not a good measure of language popularity.
17:23:20 <dons> its a good measure of available talent
17:23:21 <amaron_> dons: its so cool working in such place
17:23:27 <Ralith> good point.
17:23:43 <Ralith> I suppose there would be a fairly high correlation between skilled developers and IRC users
17:23:59 <dons> so, just go and right effective, efficient code in haskell, and we'll see more and more jobs around it
17:24:00 <amaron_> dons: two of us tried to introduce haskell in our company, and without success
17:24:07 <pumpkin> dons: managed to reproduce it on my VPS, which is running 6.8 on linux (I'm 6.10.1 on mac os)
17:24:10 <dons> mm. well, you have to be careful to manage risk
17:24:12 <Ralith> dons: working on it ^^
17:24:24 <dons> pumpkin: still downloading your bundle..
17:24:27 <repnop> amaron_: small non-critical projects right?
17:24:30 <pumpkin> ack, sorry it's so big :/
17:24:33 <amaron_> there is so much resistance, specialy with formed programmers
17:24:36 <repnop> otherwise it'll be a hard sell i bet.
17:24:51 <dons> amaron_: yeah, you don't want to force them. though that sometimes happens (i guess they did that at credit suisse)
17:24:56 <pumpkin> dons: I could try and see if I still get the issue on a smaller dataset if the download is a pain
17:25:02 <dons> but just demonstrating value time and again is good
17:25:12 <dons> prototype faster, produce bug free versions of things, etc
17:25:14 <amaron_> repnop: very critical and big from my point of view, i do server part
17:25:29 <dons> and hey, you want to exploit multicore, right?
17:25:36 <dons> now's the time for multicore ready stuff
17:25:43 <dons> and a good chance to introduce new approaches
17:25:49 <newsham> amaron: there's a much larger semantic gap between haskell and the languages most people are used to than there is for most other programming languages
17:26:08 <amaron_> i work for aikeo.com
17:26:12 <newsham> when everyone speaks a romance language, chinese seems difficult and foreign
17:26:15 <kmeyer> hm, how do I force strict evaluation for a function?
17:26:37 <timebomb> i for one like how c looks :s
17:26:38 <newsham> kmeyer: you can impose an evaluation strategy
17:26:40 <repnop> but chinese grammar isn't too difficult to english speakers :)
17:26:43 <dons> kmeyer: strict in which way?
17:26:43 <ddarius> newsham: Actually I think there is evidence that Chinese -is- more difficult.
17:26:49 <kmeyer> dons: non-lazy
17:26:51 <dons> let !x = a + b in x
17:26:55 <amaron_> newsham: i know... i'm into process of hacking my brain cells to think in haskell way
17:27:03 <dons> kmeyer: but in a particular variable, in a result, in an argument? in all arguments?
17:27:04 <newsham> kmeyer: http://www.haskell.org/ghc/docs/latest/html/libraries/parallel/Control-Parallel-Strategies.html
17:27:12 <kmeyer> dons: I'm not quite sure :D
17:27:14 <blackh> My boss:
17:27:16 <blackh> (12:05:15) Ben Martel: The dependency is a real problem and certainly not a smart commercial one :)
17:27:16 <blackh> (12:05:50) Ben Martel: Trying to find Steves replacement when hes hit by a bus - and it requires Haskell will be an impossible task :(
17:27:18 <dons> in a recursive call?
17:27:24 <dons> f x = .. f $! x + 1
17:27:28 <dons> f !x = f (x+1)
17:27:28 <dons> etc
17:27:34 <newsham> ddarius: billions of children speak it every day :)
17:27:54 <blackh> (This is my boss's comment on the suggestion of using Haskell.)
17:28:04 <ddarius> newsham: "more" difficult doesn't mean impossibly difficult or even very much more difficult
17:28:19 <dons> hmm. blackh, mention that people will move continents to program haskell
17:28:20 <timebomb> that is actually one of the reasons why im interested in haskell, the concurrency thing
17:28:25 <timebomb> but anyway
17:28:35 <dons> and actually, a lot of people have some familiarity with haskell now, since it is taught so widely
17:28:40 <ddarius> blackh: Does he actually have any proof that finding people would be hard?
17:28:51 <dons> yeah, i think that's a myth. we get far too many job applications
17:28:57 <dublpaws> :t Infinity
17:28:58 <lambdabot> Not in scope: data constructor `Infinity'
17:29:00 <newsham> ddarius: I'm just trying to place an upper bound.  easy enough for billions of kids
17:29:02 <timebomb> i wouldn't call it myth
17:29:03 <dons> and the universities and open source are still turning out hundreds of trained haskellers
17:29:21 <timebomb> take ruby for example, from what i saw theyre more expensive than php ppl just because theyre less
17:29:22 <blackh> ddarius: We live in New Zealand. :)
17:29:25 <timebomb> haskell would be even less
17:29:30 <dons> timebomb: advertise an open haskell position on haskell-cafe@ -- see if its a myth then.
17:29:33 <timebomb> that's just my observation
17:29:35 <ddarius> blackh: Sounds like it will be easier.
17:29:37 <blackh> dons: I'll work on him. :)
17:29:38 <timebomb> subjective maybe
17:29:43 <amaron_> blackh: reaction from my boss when i did latest project: wtf is this?? no classes, lambdas everywhere, all arguments are functions???
17:29:45 <timebomb> but that's how the market looks in this city
17:30:15 <amaron_> 'look what that haskell did to your brain'
17:30:33 <dons> "your code is fast, uses all the cores on the server, its shorter than this java, and you wrote it in 4 hours!"
17:30:45 <timebomb> and uses twice the memory
17:30:46 <blackh> One issue with advocacy is, I think, that Haskell's benefits are only abundantly obvious when you have some experience in using it.
17:30:47 <timebomb> hehe
17:30:56 <dons> as java? i doubt it.
17:31:00 <ddarius> newsham: I think the studies are actually based on Chinese children taking more time/having more difficulty to reach comparable levels of reading comprehension, but I only vaguely remember this so I could easily be misremembering or completely talking out of my ass.
17:31:01 <timebomb> nah not java
17:31:06 <dons> as C maybe.
17:31:06 <timebomb> i hate java
17:31:19 <Ralith> we all do
17:31:21 <pumpkin> timebomb: don't be hatin!
17:31:23 <importantshock> it seems to me like there's a huge opportunity for some clever startup to do something really slick with haskell
17:31:25 <blackh> dons: I'm thinking of re-implementing a part of our application in Haskell as a demonstration.
17:31:27 <importantshock> people need an example
17:31:33 <importantshock> as 37signals was for ruby/rails
17:31:42 <dons> blackh: yeah, 'demonstration' and 'prototypes' that are better than the  real thing are good
17:31:44 <timebomb> yi gets stack overflows on comparably "small" files
17:31:48 <newsham> ddarius: do the studies compare children from similar caliber schools and socioeconomic backgrounds?
17:31:54 <dons> well, galois is a startup (ok, 10 years old now) that uses haskell for everything
17:31:57 <newsham> (perhaps geting off topic)
17:32:01 <timebomb> rails was a joke that time but well it helped hype ruby
17:32:05 <Ralith> dons: but nothing high visibility
17:32:15 <dons> yeah. cryptography is a bit of a niche
17:32:28 <dons> but most of haskell's web libs were written by galois. so go do something good with those
17:32:28 <ddarius> newsham: As I said, I only vaguely remember this stuff.  I'd imagine some effort would have gone into "normalizing" the results somehow.
17:32:30 <pumpkin> how big is galois btw?
17:32:32 <timebomb> galois?
17:32:40 <dons> 40 or so people now
17:32:41 <amaron_> dons: do you use it for gui, and databases?
17:32:41 <pumpkin> timebomb: he died when he was 20
17:32:45 <dons> amaron_: yeah
17:32:47 <dons> everything.
17:32:49 <pumpkin> timebomb: in a duel!
17:32:53 <pumpkin> very honorable of him
17:32:59 <timebomb> ah thats your company
17:33:25 <amaron_> dons: what did you choose: gtk? hdbc?
17:33:42 <dons> we've used hmm. gtk2hs, definitely. hdbc, takusen, sqlite3 (galois' lib)
17:33:52 <dons> prob. others.
17:34:03 <dons> takusen is popular
17:34:17 <kmeyer> dons: http://hpaste.org/13844
17:35:05 <dublpaws> when intel releases an 80 core chip and haskellers are building apps that execute across the entire CPU, they will come.  When they built it, they will come. >:]
17:35:22 <dons> kmeyer: looking
17:35:29 <kmeyer> thanks :)
17:35:41 <timebomb> i bet erlang advocates say the same
17:35:45 <Ralith> timebomb: there's a reason, then: an investment to later get a cool job.
17:35:54 <ddarius> timebomb: Erlang isn't really geared toward SMP.
17:36:02 <timebomb> i thought it was
17:36:06 <timebomb> guess im wrong
17:36:12 <pumpkin> distributed computation more
17:36:13 <ddarius> timebomb: It's geared toward distributed computation.
17:36:23 <timebomb> okay
17:36:50 <timebomb> well the smp support is all nice and stuff. but isnt the memory usage still a bit of a problem?
17:37:13 <kmeyer> dons: I feel like I'm doing something that duplicates some sort of standard function
17:37:20 <dons> memory usage of what, timebomb ?
17:37:27 <bremner> timebomb: you are complaining about the memory usage of a programming language you have not written programs in?
17:37:28 <timebomb> memory usage in general
17:37:30 <CakeProphet> Stackless Python has some cool process serialization stuff. That would be hard to do without making a Haskell interpreter.
17:37:31 <dons> of haskell?
17:37:36 <timebomb> yes
17:37:43 <amaron_> dons: what do you suggest for database?
17:37:48 <dons> no?
17:37:51 <dons> amaron_: hdbc or taksuen
17:38:05 <timebomb> bremner: i think so yes
17:38:15 <dons> timebomb: look at  the memory stats wrt to http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=java
17:38:28 <timebomb> yeah i know that
17:38:29 <dons> order of magnitdue better memory in many cases
17:38:31 <bremner> timebomb: doesn't that sound silly? Look up "tail recursion" for starters
17:38:33 <amaron_> dons: do you know python and pygtk?
17:38:41 <timebomb> bremner: did already
17:38:46 <dons> and that doesn't stop people using java. so .. no. i don't think good memory use is a problem.
17:38:48 <timebomb> check above :p
17:39:42 <dons> i'd love to know why you think haskell's memory use is even an issue?
17:39:56 <newsham> haskell's memory usage can be hard to reason about.
17:40:01 <newsham> i think thats a valid complaint
17:40:10 <dons> kmeyer: looks good to me.
17:40:15 <kmeyer> stack overflows
17:40:36 <amaron_> dons: when i do freelance jobs i choose pygtk, i wonder is it faster to do it with gtk2hs
17:40:53 <dons> kmeyer: how i'd write it: http://hpaste.org/13845
17:40:58 <dons> amaron_: prob. similar
17:41:02 <dons> they're all just bindings to gtk
17:41:06 <newsham> amaron: the pygtk bindings and the gtk2hs bindings are similar.  it will be faster to use the language you are most comfortable with.
17:41:11 <dons> so depends on what you know
17:41:19 <dons> kmeyer: are you compiling the code with ghc?
17:41:23 <dons> i.e. ghc -O2 M.hs  ?
17:41:24 <kmeyer> ghci right now
17:41:29 <dons> try compiling it.
17:41:42 <kmeyer> alright
17:41:44 <dons> looks fine to me
17:42:13 <timebomb> come to think of it anyone here familiar with the obj-c bindings?
17:42:21 <newsham> amaron: if you're not used to static typing, it might be faster to prototype up in pygtk and python, but the strong typing in haskell can catch a lot of bugs that you'd have to discover at runtime in python
17:42:24 <dons> hoc, yeah. i used to sit next  to the guy who wrote them
17:42:28 <timebomb> heh
17:42:49 <dublpaws> nvidia is releasing a 480 core monster later this year, interesting to see how haskell could fit into their general purpose bridge language
17:43:08 <pumpkin> I can't wait to try gpugen :)
17:43:14 <Ralith> pumpkin: gpugen?
17:43:15 <amaron_> newsham: i used to like dynamic advantage in python, but bugs are very messy
17:43:19 <CakeProphet> newsham:  coming from Python I find the static typing in Haskell to be a great benefit. But compared to C's type system I prefer Python's duck typing.
17:43:32 <pumpkin> Ralith: dons posted a link on the haskell reddit a few days ago iirc
17:43:42 <pumpkin> Ralith: let me find it
17:44:03 <CakeProphet> Haskell's type system doesn't restrict semantics in most cases.
17:44:13 <pumpkin> Ralith: http://www.galois.com/blog/2008/08/29/gpugen-bringing-the-power-of-gpus-into-the-haskell-world/ is the beginning of it
17:44:20 <timebomb> theres  a couple of issues im wondering about. the build will fail with c_sources in the cabal sayingWarning: the following files would be used as linker inputs, but linking is not being
17:44:23 <newsham> there are the occasional types when forming a proof of the types can be hard.
17:44:24 <Ralith> pumpkin: neat!
17:44:32 <pumpkin> and http://www.cse.unsw.edu.au/~chak/papers/gpugen.pdf
17:44:34 <BMeph> CakeProphet: C doesn't have a type system, just "suggested use cases". ;p
17:44:41 <Ralith> sounds like something dons would know about it
17:44:43 <Ralith> about*
17:44:56 <timebomb> removing the line will make it install just fine but the bindings will say hoc not found
17:45:32 <CakeProphet> BMeph:  I suppose. The only real type in C is bytes and their various combinations.
17:45:56 <dons> pumpkin: so how do i reproduce?
17:46:15 <pumpkin> dons: just compile with -O2 (takes a long time otherwise), --make, and run the program with no arguments
17:46:24 <amaron_> only sad thing regarding haskell job is there are more and more programmers interested in haskell, but company who use it its very hard to find
17:46:27 <pumpkin> just make sure you're in the unzipped directory as it relies on the current dir
17:46:49 <dons> ok
17:46:54 <newsham> amaron: you could find a job where you work on projects independantly in the language of your choice
17:46:56 <pumpkin> amaron_: that's why everyone wants to work for for galois!
17:47:05 <amaron_> so dons is very lucky one
17:47:14 <pumpkin> amaron_: or just stay in academia and have freedom :P
17:47:25 <kmeyer> dons: Foo.hs:18:0: Unexpected strictness annotation: !!Double
17:47:27 <pumpkin> (comparative freedom anyway)
17:47:48 <kmeyer> (Must Term be a non-alias type for that to work?)
17:48:10 <dons> kmeyer: yeah, use 'data'
17:48:20 <dons> declare a custom type for the pair.
17:48:52 <amaron_> heh, my university is heavy sponsored by m$ and sun, so you can guess what languages do they use
17:48:58 <kmeyer> heh
17:49:03 <pumpkin> amaron_: most of the haskell research is at MS :)
17:49:05 <newsham> visual j++?
17:49:12 <pumpkin> well, a lot of it anyway
17:49:16 <dons> hmm. Sun and MS eh? So Haskell on Sparc and Haskell on x86? :)
17:49:26 <dons> your university is sponsored?
17:49:28 <amaron_> :)
17:49:45 <newsham> btw, is there a project that is going to target a haskell compiler to the jvm?
17:49:50 <dons> not atm
17:49:53 <amaron_> they call it 'donations'
17:49:58 <dons> ah
17:50:12 <dons> yes, MS tried to donate software to my uni, but everyone used linux
17:50:30 <dons> pumpkin: so when do i expect a crash?
17:50:33 <CakeProphet> dons:  what university is this?
17:50:38 <newsham> linux at unsw?
17:50:46 <dons> yeah
17:50:49 <pumpkin> dons: took about 45 seconds on my macbook air, with -O2... about 20 minutes with no optimization
17:50:56 <newsham> bummer for such a school with such a great unix history
17:50:58 <pumpkin> (macbook air = slow)
17:51:07 <dons> newsham: didn't matter, everyone used linux.
17:51:07 <timebomb> ms has msdnaa for many cs institutes actually
17:51:17 <newsham> no, i mean bummer that everyone's using linux :)
17:51:18 <dons> it was a very unixy school
17:51:32 <newsham> rather than unix/plan9/inferno/etc..
17:51:33 <dons> oh, well, we replaced solaris and the alphas with linux boxes in the late 90s
17:51:53 <dons> but there was a good mix of alphas, mips and sparcs when i started
17:52:15 <dons> pumpkin: all good here (x86_64/ghc 6.10)
17:52:15 <dons> runs to completion
17:52:18 <repnop> there was always one nice thing about my ultra 60
17:52:25 <repnop> heavy enough no one would want to steal it ;p
17:52:25 <pumpkin> dons: o.O weird
17:52:52 <dons> well, it narrows things down at least
17:53:04 <pumpkin> I have it crashing on the only two machines I can test on easily
17:53:08 <pumpkin> maybe a 32-bit thing?
17:53:22 <pumpkin> oh no, my other machine is 64 bit
17:53:29 <pumpkin> hrm
17:53:58 <CakeProphet> I bet it will run on a 128-bit machine.
17:54:02 <pumpkin> lol
17:54:20 <CakeProphet> but if it doesn't I've got a 1024 you could try.
17:54:34 <pumpkin> dons: I'll try cutting bits and pieces of it out until it starts working for me again, I guess
17:54:58 <Saizan_> check if your OS is 32 bit on the 64bit machine
17:55:19 <pumpkin> nah, 64 bit version
17:55:44 <pumpkin> my mac is also 64 bit, but the ghc on there only produces 32-bit executables it seems
17:56:40 <CakeProphet> I bet there was a lot of hype when they switched from 2-bit to 4-bit. Imagine all the extra addressing capabilities.
17:56:46 <timebomb> macports by default compiles everything as 32 bit
17:56:55 <pumpkin> timebomb: I'm using the .pkg from haskell.org
17:57:21 <pumpkin> wow, the dons on twitter (not donsbot) is a real bigot :)
17:57:30 <timebomb> hm
17:57:35 <timebomb> the 10.4 pkg?
17:57:43 <dons> pumpkin: :/
17:57:58 <luqui> > 2^1024
17:57:59 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
17:58:02 <pumpkin> dons: I didn't mean you!
17:58:07 <luqui> pff, I've got more memory than that
17:58:27 <newsham> cake: most people still run a two-bit operating system
18:00:05 <luqui> > reverse $ concat [ d:c | (d,c) <- zip (reverse $ show (2^1024)) (cycle ["","",","]) ]
18:00:06 <lambdabot>   ",179,769,313,486,231,590,772,930,519,078,902,473,361,797,697,894,230,657,2...
18:00:44 <pumpkin> dons: interesting, if I take out the sort before I print, it seems to crash lazily :P it prints out a bunch of the results then dies
18:00:57 <pumpkin> in haskell, even segfaults are lazy!
18:01:44 <luqui> Segmentation fault (core will be dumped on demand)
18:01:47 <rwbarton> Anyone know why the LLVM example program Fibonacci prints "Fibonacci: LLVMziExecutionEngineziEngine_duCR: interrupted" after finishing?
18:01:55 <timebomb> gnite
18:02:07 <rwbarton> preflex: zdec LLVMziExecutionEngineziEngine_duCR
18:02:07 <preflex>  LLVM.ExecutionEngine.Engine_duCR
18:02:19 <kmeyer> dons: still seems to be overflowing
18:03:46 <thoughtpolice> rwbarton: seems to run fine here on OS X?
18:04:04 <CakeProphet> I remember back in the day when I was learning C and figuring out segfaults before I realized that debuggers gave you more information.
18:04:08 <dons> kmeyer: hmm? http://hpaste.org/13845#a1
18:04:13 <rwbarton> I mean the example program in the Haskell bindings, by the way, not the one that comes with the LLVM library
18:04:14 <CakeProphet> fun times.
18:04:38 <thoughtpolice> rwbarton: which is what I'm talking about
18:04:44 <kmeyer> dons: what does $ do?
18:04:54 <pumpkin> that needs to be a FAQ :P
18:05:00 <pumpkin> @faq can haskell tell me what $ does?
18:05:00 <lambdabot> The answer is: Yes! Haskell can do that.
18:05:02 <dons> ?src ($)
18:05:03 <lambdabot> f $ x = f x
18:05:09 <thoughtpolice> rwbarton: http://hpaste.org/13846
18:05:09 <rwbarton> thoughtpolice: Hmm, OK
18:05:10 <dons> its application with good precendence
18:06:38 <CakeProphet> @freshname
18:06:38 <lambdabot> Haj
18:06:52 <CakeProphet> that's a cool name.
18:06:58 <roconnor> @freshname
18:06:58 <lambdabot> Hak
18:07:00 <luqui> that's how we should name modules
18:07:08 <luqui> no don't do it again!
18:07:13 <roconnor> ok
18:07:13 <luqui> it will be priceless next time
18:07:18 <jonaskoelker> :)
18:07:36 <jonaskoelker> I think we've also just missed a good one
18:07:42 <jonaskoelker> ... Hai
18:07:58 <jonaskoelker> desu ne?   [desu desu desu desu ...]
18:08:17 <pumpkin> iie!
18:08:21 <kmeyer> dons: I guess I'm not sure where to put $ in my code such that that happens
18:08:29 <luqui> I want to make a language called Hai, then a derivative will spawn: Objective Hai
18:08:51 <CakeProphet> @learn underwater chess
18:08:51 <lambdabot> http://www.haskell.org/learning.html
18:08:52 <pumpkin> dons: I'll try to reduce it more to find the bug later... got it working by making a minor change (I had a bug in my code where it was computing the wrong thing, but that shouldn't explain the segfault)
18:08:58 <mxc> how about Objective-Lolcode?
18:09:10 * CakeProphet would love to design a serious language.
18:09:15 <luqui> well, okay, but I'd still have to call it O'Hai
18:09:28 <pumpkin> おはい！
18:09:47 <jonaskoelker> O'Hai great rangrage desu!
18:09:48 <jonaskoelker> :)
18:09:49 <pumpkin> 御はい, the polite form of hai :P
18:09:54 <thoughtpolice> might as well just call it Rly
18:10:02 <BMeph> luqui: Even better, call it O'Hai-yo! ;)
18:10:09 <pumpkin> lol
18:10:12 <jonaskoelker> ... gozaimasu :)
18:10:14 <thoughtpolice> "O'Rly? yes, O'Rly."
18:10:26 <pumpkin> b'll o'r'ly
18:10:47 <jonaskoelker> ... You are O'Rly men?
18:10:47 <BMeph> no wai! ;p
18:10:47 <skorpan`> тхере ис онлы оне ригхт ваы то саы хелло
18:10:47 <Olathe> zomg gozaimasu !
18:10:50 <thoughtpolice> WE'LL DO IT LIVE
18:11:00 * thoughtpolice wonders how many people have seen that bill o'reilly clip
18:11:06 * pumpkin loves #haskell's occasional bouts of mass hysteria
18:11:21 <jonaskoelker> which "that BoR clip"?
18:11:26 <CakeProphet> thoughtpolice:  I'm one
18:11:29 * BMeph suddenly realizes that he /in't/ in #haskell-blah...
18:11:31 <thoughtpolice> :)
18:11:39 <BMeph> *isn't
18:11:41 <thoughtpolice> jonaskoelker: http://www.youtube.com/watch?v=2tJjNVVwRCY
18:11:53 <thoughtpolice> if you google 'bill o'reilly' it's actually like the 3rd result or something
18:13:38 <newsham> ohio gozaimasu
18:14:01 <mxc> nande minna san ga nihongode hanasu?
18:14:19 <mxc> #haskell-jp desuka?
18:14:24 <pumpkin>  mochiron
18:14:33 <pumpkin> motiron?
18:14:34 <ddarius> @seen lambdabot
18:14:34 <lambdabot> Yes, I'm here. I'm in ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosxdev, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it, #
18:14:34 <lambdabot> haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, #haskell-freebsd, ##freebsd, #gentoo-uy, #gentoo-haskell, #
18:14:34 <lambdabot> friendly-coders, #dreamlinux-es, #concatenative, #arch-haskell, #functionaljava, #novalang, #darcs, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
18:14:40 <ddarius> #haskell.jp
18:14:43 <mxc> #haasukeeru ?
18:14:49 <jonaskoelker> :)
18:15:07 <mxc> why is lambdabot in #scala?
18:15:13 <pumpkin> dare mo inai
18:15:22 <mxc> boku ga iruno!
18:15:28 <pumpkin> #haskell.jp ?
18:15:33 <mxc> oh
18:15:34 <mxc> no
18:15:35 <mxc> i'm just here
18:15:36 <pumpkin> :P
18:15:59 <ddarius> mxc: It's in a channel called "functionaljava"
18:16:07 <ddarius> and #concatenative
18:16:08 <mxc> missed that one...
18:16:22 <mxc> actually, there are a lot of questionables i guess
18:16:23 <ddarius> lambdabot is promiscuous
18:16:27 <newsham> she's friendly
18:16:38 <newsham> ?vixen hi
18:16:38 <mxc> what is functional java anywy?
18:16:39 <lambdabot> how're you?
18:16:54 <newsham> http://functionaljava.org/
18:17:05 <pumpkin> isn't that an oxymoron?
18:17:09 <jonaskoelker> why can't google translate handle romaji japanese :(
18:17:13 <newsham> why would it be an oxymoron?
18:17:23 <pumpkin> jonaskoelker: too much information lost :(
18:17:37 <mxc> jonaskoelker -  as hard as jp translation is, w/out kanji its inanse
18:17:39 <mxc> insane
18:17:55 <jonaskoelker> pumpkin: not really, You can write interface Function { Object call(Object); } and subclass it all over the place, with no typechecks at all
18:17:58 <jonaskoelker> pumpkin: great fun
18:18:10 <jonaskoelker> pumpkin: that's only every gotten me fired twice
18:18:15 <newsham> public interface F<A,B> { public B call(A arg); }
18:18:16 <pumpkin> :o
18:18:32 <skorpan`> subclass an interface?
18:18:48 <jonaskoelker> yeah, I live in multiple-inheritance world where there's no interfaces
18:18:50 <jonaskoelker> ;)
18:18:56 <jonaskoelker> s/subclass/implement/
18:19:26 <jonaskoelker> (and the firing thing was a joke, in case _that_'s what pumpkin's :o'ing)
18:19:29 <newsham> new F<String,Int>() { public String call(Int arg) { return arg.toString(); } }
18:19:50 <jonaskoelker> or just `show'
18:19:52 <jonaskoelker> ;)
18:20:00 <newsham> sure, that may be less verbose...
18:20:06 <newsham> but..  well, I dont have a "but"
18:20:10 <ddarius> newsham: And here I've been using 'show' like a sucker.
18:20:21 <pumpkin> jonaskoelker: :)
18:20:35 <jonaskoelker> actually, it's Integer, not Int
18:21:05 <ray> ///2
18:21:44 <seafood> Has anyone noticed that hsx doesn't build with ghc 6.10.1?
18:22:03 <jonaskoelker> new F<F<Integer,String>,List<String> > { public List<Integer> call(F<Integer,String> f) { List<String> l = new ArrayList<String>(); for (Integer i: mylist) l.add(f.call(i)); return l; } }
18:22:30 <jonaskoelker> or `flip map mylist'
18:22:32 <jonaskoelker> :)
18:22:55 <patperry> Does anyone here know much about touchForeignPtr?
18:23:08 <patperry> Specifically, can anyone help with this: http://www.haskell.org/pipermail/haskell-cafe/2009-January/053234.html
18:23:55 <newsham> jonas: you'd probably have defined .map in List<>
18:24:10 <Saizan_> seafood: yeah, it's more that it requires an older haskell-src-exts
18:24:12 <newsham> ie. http://www.thenewsh.com/~newsham/x/j/List.java
18:24:39 <Saizan_> seafood: it builds for me against haskell-src-exts-0.4.3.1
18:25:12 <newsham> you seem to be using the Java List<>.  I chose a more functional one
18:25:21 <kmeyer> dons: ok, very weird...
18:25:25 <Saizan_> seafood: i.e. the maintainer should fix the .cabal file
18:25:36 <kmeyer> when I compiled Foo.hs and run it, the stack overflows
18:25:51 <kmeyer> when I compile Foo.hs, and instead :l Foo in ghci, then run main, it doesn't overflow
18:25:53 <jonaskoelker> newsham: pro'lly
18:25:56 * pumpkin eats seafood
18:26:07 <jonaskoelker> newsham: LinkedList? ;)
18:26:32 * seafood is confused that he was eaten by a vegetable. GM?
18:26:38 <newsham> I defined my list as  List = Either (a, List a) ()
18:26:54 <newsham> or in my java definitions:  E<P<A, List<A>>, Unit> _lst;
18:27:02 <jonaskoelker> yeah, I see it :)
18:27:45 <newsham> (E.java and P.java are there as well)
18:27:56 <Lemmih> patperry: No seqs are needed. You're safe.
18:28:02 <jonaskoelker> I think that's more than enough java for one day
18:28:03 <jonaskoelker> ;)
18:28:07 <patperry> Lemmih: whey is that, exactly?
18:28:16 <patperry> is the seq on e necessary?
18:28:27 <jonaskoelker> Java is probably the only thing that makes xml look terse
18:29:04 <newsham> if i was in a Java union, i'd demand to be paid by the character.
18:29:44 <Lemmih> patperry: peekElemOff is strict. Once it returns, no further deferencing of the pointer will take place.
18:29:48 <seafood> Can you build a particular version of a package using "cabal install" ?
18:29:49 * BMeph resists the urge to make a crack about "safe seqs"...and least not until paging over to -blah. ;)
18:30:10 <newsham> seafood: i believe you scan specify package-vers
18:30:10 <Saizan_> seafood: yes, cabal install foo-x.y.z
18:30:33 <jonaskoelker> BMeph: I think it goes wrong with... ahem, Unsafe IO
18:30:36 <Saizan_> seafood: you can even use predicates, like cabal install "foo < x"
18:30:43 <CakeProphet> @src seq
18:30:43 <lambdabot> Source not found. There are some things that I just don't know.
18:30:47 <patperry> Lemmih: awesome!  thanks for the help!
18:30:55 <seafood> Saizan_: That's very nice. Is that in "--help" though?
18:31:04 <patperry> Lemmih: is pokeElemOff strict, too?
18:31:11 <Lemmih> patperry: yes.
18:31:51 <Saizan_> seafood: it doesn't look like so, maybe you should file a ticket about it, if there isn't one
18:32:13 <seafood> Saizan_: How do I file a ticket. Dumb question but just looking for a quick link.
18:32:31 <harovali> a couple of friends of mine were haskell programmers up to 1998, and then left it, just because they changed their place of work I think. They never again were in touch of haskell. What do you think can be a good reason that I can tell them to get them back to haskell?
18:33:06 <Saizan_> seafood: see "Report a Bug" here http://www.haskell.org/cabal/
18:33:16 <jonaskoelker> why did they learn it in the first place?  Why did they stick with it?  Why did they like it?
18:33:18 <baaba> if they just took and left because the job no longer required it then i don't think you can convince them to come back :)
18:33:24 <seafood> mae: Filing a report now :)
18:33:54 <harovali> they used to work in a university, there haskell was customary
18:34:11 <CakeProphet> @let cruisecontrol = map toUpper
18:34:13 <lambdabot>  Defined.
18:34:28 <CakeProphet> > cruisecontrol "it'll never work, you fool."
18:34:29 <lambdabot>   "IT'LL NEVER WORK, YOU FOOL."
18:34:41 <baaba> shouldn't that be cRUISECONTROL
18:34:55 <jonaskoelker> ~_~
18:35:24 <CakeProphet> ...no it's cruisecontrol because I forgot that I had caps lock on.
18:35:24 <Olathe> @type cruisecontrol
18:35:26 <lambdabot> Not in scope: `cruisecontrol'
18:35:27 <CakeProphet> when I used shift.
18:35:28 <newsham> ?let _CRUISECONTROL = cruisecontrol
18:35:29 <lambdabot>  <local>:1:17: Not in scope: `cruisecontrol'
18:35:53 <Olathe> Evil undeffers !
18:36:12 <Stinger> @type L.cruisecontrol
18:36:14 <lambdabot> Not in scope: `L.cruisecontrol'
18:36:32 <CakeProphet> > cruisecontrol
18:36:38 <lambdabot>   Not in scope: `cruisecontrol'
18:36:42 <Olathe> @let cruisecontrol = say.map toUpper
18:36:44 <CakeProphet> ...
18:36:46 <lambdabot>  Defined.
18:36:57 <Olathe> > cruisecontrol "zomg !"
18:37:04 <lambdabot>   Not in scope: `cruisecontrol'
18:37:05 <Olathe> Lies !
18:37:08 <Olathe> Heheh
18:37:21 <CakeProphet> why is it doing that you wonder?
18:37:34 <Olathe> Someone is doing @undef.
18:37:35 <newsham> > _CRUISECONTROL "fire missiles"
18:37:37 <lambdabot>   FIRE MISSILES
18:37:52 <Olathe> @type _CRUISECONTROL
18:37:54 <lambdabot> forall a. [Char] -> Sym a
18:37:57 <Olathe> Sym ?
18:38:01 <Olathe> @hoogle Sym
18:38:02 <lambdabot> Text.Read Symbol :: String -> Lexeme
18:38:02 <lambdabot> Text.Read.Lex Symbol :: String -> Lexeme
18:38:02 <lambdabot> Text.Parsec.Token symbol :: GenTokenParser s u m -> String -> ParsecT s u m String
18:38:03 <seafood> mae, Saizan_: Ticket has been filed.
18:38:05 <baaba> :t say
18:38:07 <lambdabot> String -> Expr
18:38:11 <Olathe> What the heck is Sym ?
18:38:11 <newsham> > Data.Number.Symbolic.var "test"
18:38:16 <lambdabot>   test
18:38:21 <newsham> ?type 3 + x
18:38:23 <lambdabot> Expr
18:38:27 <Olathe> > _CRUISECONTROL "zomg" :: Sym Int
18:38:29 <lambdabot>   ZOMG
18:38:33 <Olathe> @type _CRUISECONTROL "zomg" :: Sym Int
18:38:35 <lambdabot> Sym Int
18:38:47 <pumpkin> @src tails
18:38:47 <lambdabot> tails []         = [[]]
18:38:47 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
18:38:53 <baaba> > _CRUISECONTROL $ fix ("lo" ++)
18:38:54 <lambdabot>   Not in scope: `_CRUISECONTROL'
18:39:19 <baaba> :(
18:39:53 <Olathe> > let _CRUISECONTROL xs = fun (map toUpper xs) :: Expr in _CRUISECONTROL $ fix ("lo" ++)
18:39:55 <lambdabot>   LOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOL...
18:40:11 <dolio> Why are we doing this?
18:41:51 <dons> mm
18:44:52 <ahunter> Olathe: I can top that, I think
18:46:14 <ahunter> > let alt [] = []; alt (x:y:xs) = (toUpper x):y:alt xs;_CrUiSeCoNtRoL xs = fun (alt xs) :: Expr in _CrUiSeCoNtRoL $ fix ("lo" ++)
18:46:15 <lambdabot>   LoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoLoL...
18:46:24 <ahunter> behold the studlycaps
18:47:08 <newsham> > zipWith id (cycle [id, toUpper]) "testing"
18:47:10 <lambdabot>   "tEsTiNg"
18:47:28 <kmeyer> haha
18:47:46 <Stinger> how the hell
18:47:56 <newsham> > zipWith ($) (cycle [id, toUpper]) "testing"
18:47:57 <lambdabot>   "tEsTiNg"
18:47:58 <pumpkin> that is awesome
18:48:02 <newsham> does that make it clearer?
18:48:06 <pumpkin> won't ap do it too?
18:48:09 <pumpkin> oh no
18:48:17 <pumpkin> that'll do all combinations, right?
18:48:28 <pumpkin> > ap [id, toUpper] "testing"
18:48:30 <lambdabot>   "testingTESTING"
18:48:43 <pumpkin> guess not :)
18:48:57 <rwbarton> > getZipList $ ZipList [id, toUpper] <*> ZipList "testing"
18:48:58 <lambdabot>   "tE"
18:49:10 <rwbarton> > getZipList $ ZipList (cycle [id, toUpper]) <*> ZipList "testing"
18:49:11 <lambdabot>   "tEsTiNg"
18:49:27 <ski_> (rwbarton : ty)
18:49:54 <newsham> > (+1) 5
18:49:55 <lambdabot>   6
18:49:58 <newsham> > id (+1) 5
18:50:00 <lambdabot>   6
18:50:21 <newsham> > ($) (+1) 5
18:50:22 <lambdabot>   6
18:50:25 <ski_> > id (id id (+1)) 5
18:50:27 <lambdabot>   6
18:53:49 <BMeph> Did anyone on ever implement an extended Euclidean function?:)
18:53:51 <Taejo> :t ($) $ ($)
18:53:52 <lambdabot> forall a b. (a -> b) -> a -> b
18:54:28 <Taejo> @unpl ($) $ ($)
18:54:28 <lambdabot> (\ b d -> b d)
18:54:40 <pumpkin> that's a pretty awesome function
18:54:59 <newsham> bmeph: for computing gcds?
18:55:01 <Pseudonym> @free f :: (a -> b) -> (a -> b)
18:55:02 <lambdabot> h . k = p . g => h . f k = f p . g
18:55:05 <Taejo> pumpkin: an awesome name for a very ordinary function?
18:55:10 <pumpkin> Taejo: yeah!
18:55:21 <Taejo> :t ($) . ($)
18:55:22 <lambdabot> forall a b. (a -> b) -> a -> b
18:55:42 <BMeph> newsh: For computing /extended/ gcds. ;)
18:55:50 <Taejo> I guess it's obvious when you think of ($) as a synonym for id
18:56:17 <newsham> bmeph: once or twice
18:56:26 <pumpkin> > join (==) 5
18:56:27 <lambdabot>   True
18:56:27 <Pseudonym> :t id $ id
18:56:28 <lambdabot> forall a. a -> a
18:56:31 <pumpkin> > join (==) 4
18:56:32 <lambdabot>   True
18:56:36 <pumpkin> > join (==) (0/0)
18:56:37 <lambdabot>   False
18:56:40 <pumpkin> !
18:56:42 <pumpkin> almost const True
18:56:43 <BMeph> pumpkin: I looks possibly useful. I'm trying to imagine what the binary extended algorithm looks like, since I can't find a reference that has it. :)
18:56:47 <seafood> I can't get --cabal-lib-version to work with cabal install
18:57:11 <seafood> I was trying to build the plugins package but it complains that this must be built with Cabal 1.4.*
18:57:29 <newsham> you solving linear diophantine eqns?
18:57:51 <BMeph> newsh: Did you ever make one that gives the gcd along with the extended results, and if so, how so? :)
18:58:19 <Saizan_> seafood: you'd have to install Cabal-1.4.x separately, but i'm not sure if that works with ghc-6.10.1
18:58:24 <BMeph> newsham: No, I just like semi-exotic math problems. :)
18:58:25 <newsham> bmeph: i dont recall if I did (or if so, how).
18:59:18 <newsham> doesnt the code on http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm return both?
18:59:34 <Stinger> I was gonna say wiki should have it
18:59:59 <sclv> how does one set up a cabal preference to favor base3 over base4?
19:00:23 <Saizan_> it already like that, no?
19:00:25 <jonaskoelker> sclv: compile it with --ternary?
19:00:32 <sclv> rimshot
19:00:48 <Saizan_> seafood: a better alternative might be hint, for dynamic loading of haskell code
19:01:26 <newsham> hmm i guess it doesnt.
19:01:46 * thoughtpolice wishes someone would just put some simple hs-plugins style functionality in the GHC API
19:01:47 <newsham> but if you return (0,1,b) for the base case, and propogate the 3rd return value for the inductive case, wont that do what you want?
19:01:54 <seafood> Saizan_: A better alternative than installing plugins?
19:02:03 <sclv> any help? its not immediately evident in the docs, and since i'm on 6.8.3 still it doesn't affect me, but i'm trying to support somebody on a newer system...
19:02:11 <Saizan_> seafood: yeah
19:02:19 <thoughtpolice> sclv: build-depends: base >= 4 ?
19:02:20 <seafood> Saizan_: It's probably overdue.
19:02:52 <thoughtpolice> sclv: you can always set up a flag to have it go back to base 3
19:02:56 <sclv> thoughtpolice: that would be for a package -- the point is to fix their cabal preferences to globally prefer the lower base -- ah well, maybe i'll just give them a workaround and they can go dig up the documentation themselves.
19:03:35 <Saizan_> sclv: after a cabal update, cabal will pick the preferences shipped with hackage, which include base < 4
19:03:48 <sclv> ah cool, thanks!
19:04:10 <BMeph> newsham: I think it would, but I apparently think backwards. I return ((1,0),a), 'cause I like the iterative properties. :)
19:04:13 <newsham> > let egcd a b = if a `mod` b == 0 then (0,1,b) else let (x,y,b) = egcd(b, a `mod` b) in (y, x-y*(a `div` b), b) in egcd 120 23
19:04:14 <lambdabot>       Occurs check: cannot construct the infinite type: a = (a, a)
19:04:14 <lambdabot>      Proba...
19:04:23 <pumpkin> is there an easy way to get a CArray out of a UArr without copying? :P
19:04:43 <newsham> > let egcd a b = if a `mod` b == 0 then (0,1,b) else let (x,y,b) = egcd b (a `mod` b) in (y, x-y*(a `div` b), b) in egcd 120 23
19:04:59 <lambdabot>   thread killed
19:05:18 <sclv> just reread their email -- they're not using cabal at all! no wonder they're having problems...
19:05:43 <cartivuv> hi everyone
19:06:03 <Saizan_> sclv: there's also: runghc Setup configure --constraint="base < 4"
19:06:03 <user317> how do you marshall null terminated strings from haskell to C?
19:06:08 <newsham> bmeph: at any rate, gcd(a,b) can computed once you know (x,y) given the original (a,b)
19:06:20 <sclv> Saizan_: sweet. thanks much!
19:06:52 <kerlo> I have a sudden urge to run something really nifty on lambdabot.
19:07:24 <jonaskoelker> cartivuv: hello :)
19:07:32 <user317> nm, i found it
19:07:32 <jonaskoelker> kerlo: have a go at it!
19:07:44 <kerlo> I just have to come up with a really nifty thing to run.
19:07:59 <BMeph> newsham: Well, the gcd /is/ computer {when, as} you computer the x and y. I just decided to add it along, in case anyone wants to use it. :)
19:08:01 <jonaskoelker> :)
19:08:14 <kerlo> Ooh, I know the perfect thing.
19:08:17 <BMeph> newsham: Also, I use quotRem, vice divMod. :)
19:08:29 <tromp__> > quoteRem 5 3
19:08:30 <lambdabot>   Not in scope: `quoteRem'
19:08:35 <tromp__> > quotRem 5 3
19:08:36 <lambdabot>   (1,2)
19:09:04 <tromp__> > quotRem -5 3
19:09:05 <lambdabot>       No instance for (Num (a -> a -> (a, a)))
19:09:05 <lambdabot>        arising from a use of `...
19:09:12 <tromp__> > quotRem (-5) 3
19:09:14 <lambdabot>   (-1,-2)
19:09:24 <tromp__> > divMod (-5) 3
19:09:25 <lambdabot>   (-2,1)
19:10:49 <kerlo> > let digraphs x:xs = digraphs' x (x:xs); digraphs' x (y:z:zs) = (y,z) : digraphs' x (z:zs); digraphs' x [y] = [(y,z)] in digraphs "hello"
19:10:50 <lambdabot>   <no location info>: Parse error in pattern
19:10:59 <kerlo> > let digraphs (x:xs) = digraphs' x (x:xs); digraphs' x (y:z:zs) = (y,z) : digraphs' x (z:zs); digraphs' x [y] = [(y,z)] in digraphs "hello"
19:11:00 <lambdabot>   Couldn't match expected type `Expr' against inferred type `Char'
19:11:31 <kerlo> Huh. Is Expr some new type I'm not familiar with?
19:11:52 <newsham> > foldr (+) z [a,b,c]
19:11:53 <lambdabot>   a + (b + (c + z))
19:11:57 <newsham> ?type foldr (+) z [a,b,c]
19:11:58 <lambdabot> Expr
19:11:59 <BMeph> kerlo: Yes. :)
19:12:29 <kerlo> ?type z
19:12:31 <lambdabot> Expr
19:12:36 <kerlo> ?type kerlononce
19:12:36 <newsham> you used "z" without defining it
19:12:37 <lambdabot> Not in scope: `kerlononce'
19:12:47 <kerlo> Oh, I see.
19:12:55 <kerlo> > let digraphs (x:xs) = digraphs' x (x:xs); digraphs' x (y:z:zs) = (y,z) : digraphs' x (z:zs); digraphs' x [y] = [(y,x)] in digraphs "hello"
19:12:57 <lambdabot>   [('h','e'),('e','l'),('l','l'),('l','o'),('o','h')]
19:13:05 <kerlo> Success.
19:13:14 <newsham> you want the wrapping?
19:13:14 <pumpkin> I'm trying to write a mapTailsU for UArrs, to get a slideMapU eventually... I want to map a function to a sliding window over a UArr, but this is made difficult by the lack of tailsU... is it difficult to fuse such a function?
19:13:19 <kerlo> I do want the wrapping, yes.
19:14:02 <kerlo> ?pf let digraphs (x:xs) = digraphs' x (x:xs); digraphs' x (y:z:zs) = (y,z) : digraphs' x (z:zs); digraphs' x [y] = [(y,x)] in digraphs
19:14:03 <lambdabot> Maybe you meant: bf pl
19:14:08 <kerlo> ?pl let digraphs (x:xs) = digraphs' x (x:xs); digraphs' x (y:z:zs) = (y,z) : digraphs' x (z:zs); digraphs' x [y] = [(y,x)] in digraphs
19:14:08 <lambdabot> (line 1, column 106):
19:14:08 <lambdabot> unexpected "["
19:14:08 <lambdabot> expecting pattern or "="
19:14:16 <newsham> > let wrap xs = take (length xs + 1) xs ++ xs in zip xs (drop 1 $ wrap xs) "hello"
19:14:17 <lambdabot>   Not in scope: `xs'Not in scope: `xs'
19:14:18 <rwbarton> > let digraphs = ap zip tail . ap (++) (take 1) in digraphs "hello"
19:14:19 <lambdabot>   [('h','e'),('e','l'),('l','l'),('l','o'),('o','h')]
19:14:23 <dolio> > ap zip (tail . cycle) "hello"
19:14:24 <lambdabot>   [('h','e'),('e','l'),('l','l'),('l','o'),('o','h')]
19:14:38 <kerlo> I think dolio wins this round.
19:15:38 <kerlo> > let digraphs = concat . map (ap zip (tail . cycle) "hello") in digraphs ["I","don't","know","why","you","say","good","bye"]
19:15:40 <lambdabot>   Couldn't match expected type `a -> b'
19:16:02 <kerlo> > let digraphs = concat . map (ap zip (tail . cycle)) in digraphs ["I","don't","know","why","you","say","good","bye"]
19:16:04 <lambdabot>   [('I','I'),('d','o'),('o','n'),('n','\''),('\'','t'),('t','d'),('k','n'),('...
19:16:17 <kerlo> Now for the fun part.
19:16:41 <kerlo> I want to group those by fst.
19:16:58 <BMeph> kerlo: Who's stopping you? ;p
19:17:03 <jonaskoelker> > groupBy (comparing fst) [(1, 2), (2, 3), (1, 3)]
19:17:04 <lambdabot>   Couldn't match expected type `Bool'
19:17:05 <kerlo> :-P
19:17:15 <jonaskoelker> > groupBy ((==) `on` fst) [(1, 2), (2, 3), (1, 3)]
19:17:17 <lambdabot>   [[(1,2)],[(2,3)],[(1,3)]]
19:17:24 <jonaskoelker> > groupBy ((==) `on` fst) $ sort [(1, 2), (2, 3), (1, 3)]
19:17:25 <lambdabot>   [[(1,2),(1,3)],[(2,3)]]
19:17:43 <kerlo> Now can you pull that into [(1,[2,3]),(2,[3])]?
19:17:52 <BMeph> jonaskoelker: Yeah, you'd want 'equating', not 'comparing' - which has that defn you used. :)
19:18:52 <jonaskoelker> > map (\list -> (fst (head list), map snd list)) $ groupBy ((==) `on` fst) $ sort [(1, 2), (2, 3), (1, 3)]
19:18:53 <lambdabot>   [(1,[2,3]),(2,[3])]
19:18:57 <BMeph> 2src comparing
19:19:03 <BMeph> @src comparing
19:19:03 <lambdabot> Source not found. Maybe if you used more than just two fingers...
19:19:13 <BMeph> o.O
19:19:23 <kerlo> Now we're getting a little long.
19:19:29 <kerlo> Oh, I'll do without it.
19:19:35 <luqui> > Map.toList . Map.fromListWith (++) . second (:[]) . ap zip (tail . cycle) $ "hello world"
19:19:36 <lambdabot>   Couldn't match expected type `(d, b)'
19:19:44 <jonaskoelker> @free f :: (a -> a -> Ordering) -> (a -> b) -> (b -> b -> Ordering)
19:19:44 <lambdabot> (forall x. k x = p (g x) . g) => h . q = f1 . g => f k q y = f p f1 (h y) . h
19:20:09 <jonaskoelker> > let f = (compare `on`)
19:20:10 <lambdabot>   <no location info>: parse error on input `;'
19:20:17 <kerlo> > let encode n = groupBy (equating fst) . concat . map (ap zip (tail . cycle)) in encode 1 ["I","don't","know","why","you","say","good","bye"]
19:20:18 <lambdabot>   Not in scope: `equating'
19:20:34 <jonaskoelker> > let f = (compare `on`) in f snd (1, 2), (2, 1)
19:20:36 <lambdabot>   <no location info>: parse error on input `,'
19:20:37 <jonaskoelker> > let f = (compare `on`) in f snd (1, 2) (2, 1)
19:20:39 <lambdabot>   GT
19:20:51 <kerlo> > let encode n = groupBy ((==) `on` fst) . sort . concat . map (ap zip (tail . cycle)) in encode 1 ["I","don't","know","why","you","say","good","bye"]
19:20:52 <lambdabot>   [[('\'','t')],[('I','I')],[('a','y')],[('b','y')],[('d','g'),('d','o')],[('...
19:20:54 <luqui> > Map.toList . Map.fromListWith (++) . (map.second) (:[]) . ap zip (tail . cycle) $ "hello world"
19:20:55 <lambdabot>   [(' ',"w"),('d',"h"),('e',"l"),('h',"e"),('l',"dol"),('o',"r "),('r',"l"),(...
19:21:11 <kerlo> I'll just trust that that works.
19:22:03 <jonaskoelker> :t map.second
19:22:04 <lambdabot> forall b c d. (b -> c) -> [(d, b)] -> [(d, c)]
19:22:15 <jonaskoelker> ?src second
19:22:16 <lambdabot> Source not found.
19:22:17 <kerlo> You know, how about I just tell you what I want to do...
19:22:31 <user317> how do you marshall c structures to and from haskell?
19:23:00 <kerlo> Take a string like "hello world". Turn it into luqui's list there. Take every string and rotate it by n (e.g. "dol" -> "old", if n = 1). Reverse the whole process.
19:23:21 <newsham> user317: in what context?  FFI?  network comms?
19:23:22 <kerlo> I'm pretty sure, anyway, that the process is reversible...
19:23:28 <user317> newsham, ffi
19:23:42 <newsham> there are examples on the wiki.  you implement the storable class
19:24:16 <user317> newsham, cool thanks
19:24:44 <seafood> Do any of you have two versions of GHC installed on a Mac? If so, how do you manage it?
19:24:45 <newsham> section 1.4 has an example: http://www.haskell.org/haskellwiki/FFI_cook_book
19:25:16 <newsham> err.. it uses a tool in that example..
19:25:19 <user317> yea, i just found that, thanks a lot
19:25:20 <SamB_XP> seafood: step one: be able to afford a mac
19:25:30 <seafood> Hehe :)
19:25:32 * SamB_XP can't
19:26:32 <jonaskoelker> kerlo: ... so that the string would have "ld", "ll", "lo" as `isInfixOf`'s in that order?
19:26:42 * kmeyer is slowly getting used to the IO monad
19:26:48 <kerlo> jonaskoelker: precisely.
19:27:09 <newsham> *sigh* i swear there used to be a better storable example.. wonder what happened to it
19:28:04 <pumpkin> dons: are handwritten recursive functions "fusible"?
19:29:04 <BMeph> pumpkin: If you write the rewrite rule, they are. ;)
19:29:11 <pumpkin> :o
19:29:20 <BMeph> pumpkin: 8D
19:30:30 <newsham> user317: anyway, the idea is you implement storable for your data type.  you can do it manually without using a tool if you want.
19:30:43 <Saizan_> seafood: on linux ghc installs versioned binaries, i.e. i've both ghc-6.8.2 and ghc-6.10.2 in /usr/local/bin
19:31:08 <Saizan_> seafood: given that you can pass the -w option to cabal to select which one you want
19:31:09 <user317> newsham, is there a tool for derving it?
19:31:30 <BMeph> Saizan_: 6.10.2 is out? Awesome!
19:31:31 <newsham> the wiki article above mentions one.
19:31:35 * BMeph goes to d/l it
19:31:37 <newsham> i've never used it
19:31:40 <Saizan_> BMeph: no, that's a typo.
19:32:07 <BMeph> Saizan_: Party pooper. ;p
19:34:02 <jonaskoelker> kerlo: can't f 1 "acbcab" be both babcac and cabacb?
19:37:25 * jonaskoelker >>= bed >>= return . toWork
19:37:36 <pumpkin> not fmap?
19:37:48 <jonaskoelker> fmap toWork bed?
19:37:50 <kerlo> I guess I should define it better.
19:38:12 <jonaskoelker> put my bed to work?  Only when the misses' around :)
19:38:15 <Taejo> :t (return .)
19:38:16 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
19:38:38 <SamB_XP> @pl jonaskoelker >>= bed >>= return . toWork
19:38:39 <lambdabot> toWork `fmap` (bed =<< jonaskoelker)
19:39:02 * jonaskoelker :: sleep -> better code
19:39:18 <SamB_XP> no constraints ?
19:39:24 <newsham> at least work isnt evaluated unless its used
19:39:29 <jonaskoelker> :)
19:39:31 <ddarius> jonaskoelker = undefined
19:39:34 * jonaskoelker sleep -> Maybe better code
19:39:42 <SamB_XP> Kind error!
19:39:49 <SamB_XP> Maybe applied to to many type arguments
19:39:50 <Taejo> FiniteTime t => sleep t -> better work
19:40:02 <Taejo> InfiniteTime t => sleep t -> worse work
19:40:06 <newsham> you picked a finite time to leave me lucille
19:41:25 <SamB_XP> Taejo: er, I'd say *no* work
19:41:26 <SamB_XP> at all
19:41:34 <Taejo> indeed
19:41:40 <SamB_XP> unless you've got a way to work while sleeping
19:41:48 <psygnisfive> haskelliers!
19:41:50 <Taejo> well, some of us talk in our sleep
19:42:09 <psygnisfive> especially any of you who knows plenty about theory of computation and logic and so fort
19:42:10 <psygnisfive> h
19:42:22 <user317> newsham, the ffi section in the real world haskell book is pretty good too
19:42:34 <psygnisfive> i have a burning question that noone seems to know the answer to
19:42:46 <Taejo> psygnisfive: try us
19:42:59 <psygnisfive> first-order logic: turing complete?
19:43:33 <Taejo> psygnisfive: are you asking if first-order logic is Turing complete?
19:43:37 <psygnisfive> yes
19:43:48 <Taejo> how is FOL a model of computation?
19:44:10 <psygnisfive> i dont know, how is prolog a model of computation
19:44:16 <psygnisfive> its a set of algorithms for answering questions :P
19:44:36 <psygnisfive> wiki says its "semidecidable"
19:45:07 <psygnisfive> so that theres a turing machine such that that machine will halt on all true theorems in FoL
19:45:09 <Saizan_> if you use it like prolog does than it's turing complete
19:45:20 <psygnisfive> but i dont know if that means that its TC
19:46:10 <Taejo> psygnisfive: no. turing-completeness is a property of computation models (which are like programming languages). semidecidability is a property of sets of strings
19:46:55 <psygnisfive> yes well. all theorems of FoL are strings
19:47:07 <psygnisfive> FoL is the grammar, i suppose, and all theorems of FoL are its language
19:49:43 <Saizan_> psygnisfive: the point is, how do you encode a turing machine in FoL such that you can "run" it?
19:49:57 <psygnisfive> good question!
19:49:59 <kerlo> Saizan_: "turing machine X halts" would be the sentence, I believe.
19:50:00 <psygnisfive> dont know.
19:50:04 <kerlo> But formalized, obviously.
19:50:18 <psygnisfive> if i had to /guess/
19:50:26 <psygnisfive> you'd write out the maths
19:50:55 <psygnisfive> the state transition laws and so forth for your UTM
19:51:24 <kerlo> there-is N such-that run-turing-machine(machine=X,steps=N) = halt
19:51:34 <psygnisfive> assuming you have strings in your FoL you could run proofs on input strings i guess
19:52:00 <Saizan_> my point is that FOL per se doesn't have a computational aspect, but you can get one if you look at a theorem prover for it
19:52:30 <Saizan_> which is what a prolog interpreter is, in its purest form
19:52:35 <psygnisfive> well.. i think UTMs can use FoL
19:52:47 <psygnisfive> or can run FoL like a language.
19:52:47 <pumpkin> anyone have any idea what's wrong here? http://hpaste.org/13849 is it because I'm trying to pattern match on a function? I thought it was okay as long as it was constant
19:52:59 <psygnisfive> so i dont think FoL is /more/ powerful
19:53:11 <psygnisfive> but i always figured it was /as/ powerful
19:53:16 <Saizan_> psygnisfive: what "running FoL" means?
19:53:36 <pumpkin> Saizan_: what kerlo said above?
19:53:43 <Axman6> anyone here familliar with physics? (momentum, energy etc, for a planetary n-body program)
19:53:49 <psygnisfive> meaning it can prove theorems of FoL
19:53:55 <pumpkin> Axman6: GTFO!
19:54:00 <pumpkin> Axman6: *flame* etc.
19:54:05 <Axman6> :(
19:54:16 <pumpkin> just trying to make this channel more like the rest of IRC :)
19:54:21 <pumpkin> Axman6: try us
19:54:48 <Ralith> Axman6: isn't orbital mechanics fairly simple?
19:54:53 <Ralith> so long as you ignore relativity
19:55:04 <Saizan_> pumpkin: it's not ok, emptyU is a fresh variable there
19:55:07 <Ralith> newtonian physics is generally pretty straightforward
19:55:18 <pumpkin> Saizan_: ah, of course
19:55:22 <Axman6> well, i'm trying to use parallel arrays to model this stuff, and i need to find the energy in the system. i'm just struggling to figure out what steps need to be taken
19:55:32 <Ralith> parallel arrays?
19:55:36 <pumpkin> in DPH?
19:55:43 <pumpkin> the colon-loving arrays?
19:55:48 <Axman6> indeed
19:56:25 <Axman6> i have a version that works with lists, and i need to turn it into one that i can get working with the DPH arrays
19:57:53 <Axman6> since they don't have foldl/r, only foldP, which needs a function (a -> a -> a) and is associative
19:58:26 <sjanssen> Axman6: hmm, there's a case study in one of the DPH papers about an n-body algorithm
19:58:31 <Axman6> but i guess it's more figuring out what the actual steps for find the elergy of the system i need to figure out
19:59:01 <dons> does the shootout spec let us implement it in arbitrary ways?
19:59:08 <dons> or is it highly constrained?
19:59:20 <Axman6> it seems fairly arbitary
19:59:27 <CakeProphet> hmm... you can pattern match in record syntax?
19:59:30 <Axman6> but they all seem to follow the same steps
19:59:36 <Axman6> CakeProphet: yep
19:59:37 <sjanssen> pumpkin: pattern matching on "emptyU" doesn't do what you think it does
19:59:43 <CakeProphet> so like
19:59:45 <pumpkin> sjanssen: yeah, I realized :)
19:59:48 <koninkje> pumpkin: binding a function argument to a variable is fine. The error says that the emptyU should be type UArr e, but your type signature (rigidly) states that it should be UArr e'
19:59:50 <pumpkin> it bound a nice name for me
19:59:53 <CakeProphet> data Foo { (a,b) :: (Int, Int)}
19:59:59 <pumpkin> I ended up just using a guard nullU
20:00:04 <sjanssen> pumpkin: the first clause means the same as "f _ x = x"
20:00:04 <Axman6> CakeProphet: i'm using data Body = B { pos :: !Vec3, vel :: !Vec3, mass :: !Double } deriving (Show, Eq), and i can match on B p v m
20:00:04 <koninkje> pumpkin: try removing the type signature and see what ghci infers the type as
20:00:25 <pumpkin> sjanssen: yeah :)
20:01:35 <CakeProphet> Axman6:  oh, that kind of pattern matching. I meant pattern matching the record function names.
20:01:52 <kmeyer> dons: ah, I guess the function I was writing earlier was basically a "merge" function
20:01:55 <CakeProphet> like in my example a would refer to the first element of the tuple and b would refer to the second.
20:01:55 <kmeyer> merge two sorted lists
20:02:16 <Saizan_> CakeProphet: match on Foo {x=a,y=b}
20:03:02 <Saizan_> with data Foo = Foo { x,y :: Int }
20:03:03 <CakeProphet> right.
20:03:11 <CakeProphet> hmmm?
20:03:24 <CakeProphet> I've never seen that syntax before. is x an int as well?
20:03:34 <Saizan_> yes
20:03:39 <CakeProphet> ah okay.
20:04:49 <Saizan_> you can use an arbitrary subset of the fields
20:04:51 * Axman6 joins #physics and sees if they can shed some light
20:10:23 <CakeProphet> Axman6:  #string-theory will likely result in a lot of untested formalization.
20:10:46 <CakeProphet> if #physics proves unsuccessful.
20:12:11 <p_l> #quantum-physics will leave you a madmen
20:14:03 * CakeProphet has never found any text on quantum physics that he can approach and understand.
20:14:26 <gwern> CakeProphet: why not read some of the quantum programming in haskell papers?
20:14:27 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
20:14:36 <gwern> @messages
20:14:36 <lambdabot> lispy said 3h 54m 8s ago: Dear Gwern, My appologies for confusing you with the example code. I meant it only to illustrate a point. I didn't get that example from the source of lambdabot. Thanks,
20:14:37 <lambdabot> Lispy
20:16:39 <pumpkin> alright, I get the impression my manually recursing UArr function isn't working well :P
20:16:50 <CakeProphet> gwern:  I doubt combining quantum physics with Haskell programming will lessen the esoteric factor.
20:16:53 * pumpkin sighs
20:17:09 <ddarius> @google "Quantum mechanics" Haskell
20:17:12 <psygnisfive> cakeprophet: why.. i think you're on to something there :)
20:17:14 <lambdabot> http://portal.acm.org/citation.cfm?id=871900
20:17:14 <lambdabot> Title: Modeling quantum computing in Haskell
20:18:08 <kmeyer> is there any function that returns IO () and does nothing?
20:18:26 <gwern> CakeProphet: well if you can follow the programming presumably you'll be able to shut up and do the math
20:18:29 <pumpkin> kmeyer: return () ?
20:18:30 <kpreid> kmeyer: return ()
20:18:34 <kpreid> :t return ()
20:18:36 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
20:18:36 <kmeyer> heh
20:18:37 <gwern> return () :: IO ()
20:18:51 <kmeyer> thanks
20:19:08 <gwern> good luck proving return () does nothing though
20:19:54 <ddarius> gwern: The monad laws pretty much imply it.
20:20:05 <CakeProphet> hmmm, I wonder if you could implement the amb function from SICP in Haskell with monads
20:20:32 <pumpkin> http://hpaste.org/13850 anyone wanna take a look at my not-so-fancy code?
20:20:38 <gwern> ddarius: here's where I say something like 'and who says IO follows the laws'
20:20:44 <rwbarton> CakeProphet: Yes, it's called 'id'
20:20:58 <CakeProphet> rwbarton:  ...wat
20:21:14 <rwbarton> > do x <- id [1,2,3]; y <- [40,50,60]; return (x+y)
20:21:17 <lambdabot>   [41,51,61,42,52,62,43,53,63]
20:21:22 <rwbarton> Oops, I forgot an 'id' there :)
20:21:47 <gwern> don't worry, it doesn't make a difference
20:22:03 <lispy> it doesn't?
20:22:05 <lispy> phew
20:22:06 <roconnor> id x = x
20:22:13 <roconnor> @src id
20:22:14 <lambdabot> id x = x
20:23:10 <cknapp> I'm finally working my way through RWH, and I had an FP Zen moment: the program at the beginning of chapter 4 (functional programming) is brilliant in its simplicity and applicability.
20:23:18 <juhp> : id [1,2,3]
20:23:31 <roconnor> @go haskell zen moment
20:23:33 <CakeProphet> rwbarton:  I don't think lists implement all of the semantics. I think in the book the first successful result was kept.
20:23:35 <lambdabot> http://r6.ca/blog/20081116T213644Z.html
20:23:35 <lambdabot> Title: Haskell Lesson
20:24:05 <Taejo> CakeProphet: in the list monad, all the successful results are kept, but due to laziness, if you only want the first one, that's all you get
20:24:24 <rwbarton> > head $ do x <- id [1..10]; y <- id [1..10]; z <- id [1..10]; guard (x^2 + y^2 == z^2); return (x, y, z)
20:24:27 <lambdabot>   (3,4,5)
20:24:47 <roconnor> > listToMaybe $ do x <- id [1..10]; y <- id [1..10]; z <- id [1..10]; guard (x^2 + y^2 == z^2); return (x, y, z)
20:24:50 <lambdabot>   Just (3,4,5)
20:25:14 <CakeProphet> hmmm... yeah, I guess it is equivalent.
20:25:25 <rwbarton> If I recall correctly 'head' is more faithful to the behavior of 'amb' :)
20:25:41 <juhp> > listToMaybe $ do x <- [1..10]; y <- [1..10]; z <- [1..10]; guard (x^2 + y^2 == z^2); return (x, y, z)
20:25:44 <lambdabot>   Just (3,4,5)
20:25:51 <Taejo> rwbarton: as in, amb dies if there is no solution?
20:25:53 <CakeProphet> it always looked like a cool way to program -- didn't realize I've had it all along.
20:26:03 <rwbarton> Taejo: I think it does
20:26:44 <cknapp> roconnor: that one is siginficantly more profound than mine... But every path to enlightenment begins with a single step. :)
20:26:56 <roconnor> :)
20:27:00 <Taejo> is there a listlike monad where do {x <- [1..]; y <- [1..]; guard (x^2 + y^2 == z^2); return (x, y, z)} ?
20:27:07 <roconnor> cknapp: everyone here is walking that path
20:27:10 <Taejo> oops, I mean, where that works
20:27:12 <roconnor> @users
20:27:14 <lambdabot> Maximum users seen in #haskell: 649, currently: 596 (91.8%), active: 22 (3.7%)
20:27:31 <roconnor> cknapp: well, except for 574 of us
20:27:35 <gnut> hi all
20:27:42 <cknapp> haha
20:27:49 <cknapp> Hi, gnut
20:27:56 <CakeProphet> and then require exp ls = if exp then ls else []
20:28:01 <dolio> Taejo: It's not technically a monad, but yes.
20:28:04 <gnut> hi cknapp
20:28:28 <Taejo> dolio: what does it look like? how does it fail to be a monad?
20:28:40 * gwern is actually walking the path of blood, not enlightenment
20:28:41 <dolio> It fails the associativity law.
20:28:52 <dolio> Look at the control-monad-omega package on hackage.
20:28:55 <rwbarton> , head $ [1..] >>- \x -> [1..] >>- \y -> [1..] >>- \z -> guard (x^2 + y^2 == z^2) >> return (x, y, z)
20:28:56 <cknapp> gwern, you don't count!
20:28:57 <lunabot>  luna: The arrow command
20:29:02 <gwern> cknapp: sure I do!
20:29:06 <gwern> @vixen do I count?
20:29:07 <lambdabot> i'll hafta plead the fifth on that one.
20:29:12 <rwbarton> "The arrow command"??
20:29:13 <gwern> traitoress!
20:29:14 <newsham> > let x = [1,2,3] in (guard True >> x, guard False >> x)
20:29:19 <lambdabot>   ([1,2,3],[])
20:29:26 <cknapp> hahaha
20:29:26 <gnut> anyone tried to get xmonad running with gnome?
20:29:32 <newsham> reqiure exp ls = guard exp >> ls
20:29:33 <Taejo> gnut: yes
20:29:36 <cknapp> That's brilliant.
20:29:42 <gwern> gnut: I'm doing it now, fwiw
20:29:46 <gnut> Taejo: ooohhhh... did you succeed?
20:30:00 <gnut> gwern: any luck?
20:30:00 <Taejo> gnut: like gwern, I'm doing it now (and at work too)
20:30:21 <newsham> gwern: did lambdabot stop summarizing url titles?
20:30:22 <gnut> wow. like both of you. I'm doing it now, too...
20:30:28 <Taejo> gnut: you should try #xmonad
20:30:41 <gnut> ok
20:30:50 <harovali> why I get "Not in scope:" when tryint to define a function?
20:30:56 <CakeProphet> :t guard
20:30:57 <gwern> gnut: no luck. it doesn't work at all. I am miserably stuck at the console. in the time freed up by not being able to use my computer I am constructing a scale model of the Executor Super Star Destroyer with toothpicks
20:30:57 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
20:31:05 <gwern> newsham: dunno
20:31:06 <CakeProphet> oh ho... already exists.
20:31:06 <pumpkin> harovali: something you called isn't in scope? a typo maybe?
20:31:22 <gwern> let's http://google.com/ in accordance with the socialist lifestyle!
20:31:30 <SamB_XP> gwern: what scale ?
20:31:35 <harovali> pumpkin: I'm just typing     powerset :: [Int] -> [[Int]]
20:31:39 <newsham> ?src [] guard
20:31:40 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
20:31:43 <SamB_XP> gwern: ooh, do Knight Hammer next
20:31:46 <gwern> SamB_XP: er... 1:5000
20:31:55 <SamB_XP> gwern: so big ?
20:32:15 <harovali> isn't something being defined supposed to be "in scope" ?
20:32:20 <gnut> gwern: mmm... star destroyer...
20:32:27 <gwern> well SSDs are iirc about 5km long, so 1/5000 would be a nice roomful
20:32:28 <pumpkin> harovali: where's the rest of it?
20:32:29 <SamB_XP> SUPER star destroyer
20:32:34 <gwern> I think. I'm not so good at the maths
20:32:45 <harovali> pumpkin: it goes next ...
20:32:46 <gwern> SamB_XP: dude even the imperial IIs weren't *that* big
20:33:04 <pumpkin> harovali: can you paste the error message?
20:33:12 <rwbarton> harovali: probably a type in the name of the function either in the type signature or in its definition
20:33:15 <harovali> yes, <interactive>:1:0: Not in scope: `powerset'
20:33:16 <rwbarton> *typo
20:33:22 <SamB_XP> gwern: I'm pretty sure a SSD is a bit bigger than an Impstar Duece ...
20:33:30 <rwbarton> interactive?  that's not going to work
20:33:32 <pumpkin> harovali: oh, you're in ghci
20:33:42 <newsham> are you guys arguing the size of fictional spacecraft?
20:33:42 <gwern> http://starwars.wikia.com/wiki/Imperial_I-class_Star_Destroyer says 1.6 km
20:33:49 <harovali> pumpkin: in hugs there I got  a similar error
20:33:52 <SamB_XP> gwern: you can do Lusankya next
20:33:56 <gwern> a SSD is multiple times that, so 5x isn't too bad a modifier
20:33:58 <pumpkin> harovali: the issue is the interactive prompt
20:33:59 <Ralith> harovali: try putting it in a file
20:34:00 <CakeProphet> harovali:  can you give us the whole source?
20:34:04 <gwern> SamB_XP: all the buildings would be a bitch to model
20:34:07 <harovali> yes
20:34:08 <pumpkin> Cost	
20:34:08 <pumpkin> 3.88 billion Imperial credits
20:34:10 <pumpkin> what the hell?
20:34:23 <SamB_XP> gwern: what, you're going to do coruscant too ?
20:34:27 * Axman6 is finding ##physics very helpful with his problem
20:34:31 <gwern> but let's just say doing a model of the Eclipse is just madness
20:34:51 <harovali> or better, in general, in an interactive prompt, I0m not supposed to be able to make a multiline definition, right? it always goes in a file, right=
20:34:52 <harovali> ?
20:35:03 <gwern> 'length: 3,800[6]-19,000 meters[4]' <-- gee thanks wookieepedia. a range like 3.8 km to 19 km is *real* helpful
20:35:16 <rwbarton> harovali: Yes.  All declarations have to go in files.
20:35:22 <SamB_XP> gwern: sources are remarkably inconsistant with one another
20:35:27 <SamB_XP> look at a better site
20:35:39 <harovali> rwbarton: so, what is the interactive prompt supposed to be useful for? (not sarcasm meant)
20:35:46 <rwbarton> harovali: Evaluating expressions
20:35:58 <gwern> SamB_XP: I suspect the 19km figure is for eclipse and the 3.8 is for the midget SSDs used by Grand Admiral... Declann? (i've forgotten)
20:36:04 <harovali> rwbarton: thanks
20:36:08 <mriou> hi, I'm trying to install zlib from Hackage, the final goal being installing cabal-install
20:36:08 <rwbarton> harovali: And, of course, you can load a file with :l filename
20:36:11 <pumpkin> #starwars
20:36:14 <mriou> I'm getting: Could not find module `Data.ByteString.Lazy'
20:36:22 <SamB_XP> gwern: some might be from messed up trading-card games or something
20:36:23 <mriou> although I can :m from ghci
20:36:32 <harovali> rwbarton: so that restriction applies to hugs and to ghci right ?
20:36:33 <mriou> any idea?
20:36:49 <rwbarton> harovali: Right.  There are more exotic interpreters to which it doesn't apply
20:37:03 <harovali> rwbarton: fine, good to know
20:37:09 <SamB_XP> http://www.theforce.net/SWTC/ssd.html
20:37:19 <SamB_XP> gwern: try THAT
20:37:29 <rwbarton> such as this horrible hack: http://hpaste.org/13834 :)
20:37:36 <gwern> SamB_XP: although honestly, it's ridiculous that wookieepedia can list tens of SSDs. I mean, you would've thought The Bacta War would've demonstrated the folly of SSDs
20:37:51 <pumpkin> any fusion experts around here? :)
20:38:17 <gwern> I mean, ok, I can accept SSDs being constructed *before* the bacta war, but if you're going to place an SSD after it, you need to explain the military stupidity first and then the resource consumption...
20:38:20 <SamB_XP> gwern: they aren't as stupid if you paint 'em black
20:38:33 <pumpkin> SamB_XP: racist!
20:38:38 <SamB_XP> pumpkin: no, no
20:38:41 <pumpkin> !!!
20:38:46 <SamB_XP> I mean it's harder to spot black ones
20:38:48 <pumpkin> ;)
20:38:53 <gwern> SamB_XP: oh sure. knight hammer was one of the stupidest ones
20:39:07 <CakeProphet> rwbarton:  are there any other cool monads that make all sorts of fun semantics possible?
20:39:08 <gwern> a few jedi can chuck it around an entire solar system? lolwut
20:39:10 <CakeProphet> like amb.
20:39:32 <SamB_XP> gwern: how was daala supposed to know that ?
20:40:17 <rwbarton> CakeProphet: here's something crazy: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/CC-delcont-0.2
20:40:21 <SamB_XP> what I can't get over is that nobody really saw a problem with two places both having built Executor
20:40:32 <SamB_XP> I mean, come on, it's huge
20:40:38 <pumpkin> :(
20:40:58 <mriou> ok found it, I needed ghc6-prof for some reason
20:41:14 <gwern> SamB_XP: iirc, didn't they? I recall the x-wing series mentioned that the intelligence branches were long befuddled by how both kuat and fondor claimed executor
20:41:19 <CakeProphet> @let askHaskell = const (text "42")
20:41:21 <lambdabot>  Defined.
20:41:37 <SamB_XP> gwern: you'd think they'd have long since decided there were TWO
20:41:59 <gwern> well executor was supposed to have been ruinously expensive
20:42:10 <SamB_XP> since both places had actually taken in the resources to build one ...
20:42:18 <SamB_XP> I mean, metal, components ...
20:42:28 <gwern> given the immense secrecy of construction and the rebel sabotage, it's not hard to conclude 'huh, another bot of imperial intelligence trickery'
20:42:45 * pumpkin gives up on his UArr :(
20:43:09 <SamB_XP> gwern: but they knew about all those loading cells or whatever that lusankya was buried with
20:43:33 <gwern> explicable as landing vehicles. need to get the army from orbit to ground you know
20:43:53 <gwern> but you really can't blame them for not suspecting lusankya was buried on coruscant
20:43:56 <CakeProphet> rwbarton:  ...dynamically scoped variables?
20:44:12 <SamB_XP> gwern: well no
20:44:14 <gwern> intelligence serives aren't in the business of taking the Dark side into account :)
20:44:17 <Axman6> dons: do you remember much about when you wrote http://shootout.alioth.debian.org/u64q/benchmark.php?test=nbody&lang=ghc&id=1 ?
20:44:21 <SamB_XP> gwern: indeed
20:44:38 <SamB_XP> but you'd think they'd have expected another SSD out there somewhere
20:45:01 <gwern> given how many eventually turend up, I'm sure they did
20:45:17 <gwern> they didn't seem all that shocked by Black Sword Command's SSD for example
20:45:49 <SamB_XP> I meant based on that information ...
20:46:14 <gwern> your page even mentions that
20:46:16 <gwern> 'iloting a stolen shuttle to Endor, Han Solo was unsurprised to see the Executor in orbit, acting as the command station for processing security clearances for passage through the deflector shield protecting the new Death Star. When Luke Skywalker announced that Vader was present, Solo responded “Now don't get jittery Luke; there are a lot of command ships.” Clearly the Executor's siblings were relatively abundant by that time, or ...
20:46:21 <Taejo> roconnor: I never knew you had a Windows 98 theme named after you: http://www.topdownloads.net/themes/roconnor_2_36957.html?hl=$hl&ia=1
20:46:22 <gwern> ... at least no longer rare. Most were probably put to use as flagships for Grand Admirals, Grand Moffs and important Moffs. For instance, the Black Sword Fleet near Farlax sector was led by three Executor-class command ships. '
20:47:28 <SamB_XP> yeah.
20:48:09 <gwern> (personally, I find one of the larger inconsistences in the EU how the empire can afford *anything* but the new republic can't seem to buy anything)
20:48:19 <SamB_XP> in an executor-class buried under coruscant *is* just about the last place anyone'd look for a secret prison ...
20:48:39 <SamB_XP> gwern: the dark side counterfitting powerz!
20:48:47 <SamB_XP> SLAVE LABOUR!
20:49:16 <roconnor> ah right
20:49:30 <gwern> well, the first death star *was* constructed by slave labor...
20:49:49 <pumpkin> I'm pretty sure the artists who made it were paid
20:50:14 <jeffwheeler> My question is about gravity. How did they land?
20:50:17 <SamB_XP> pumpkin: we are talking in-universe
20:50:19 <SamB_XP> jeffwheeler: who ?
20:50:19 <gwern> they also didn't get executed
20:50:31 <jeffwheeler> SamB_XP: anybody that landed on the Death Star?
20:50:31 <pumpkin> SamB_XP: oh, my bad ;)
20:50:51 <pumpkin> so did Voldemort really kill James Potter?
20:50:52 <SamB_XP> jeffwheeler: artificial gravity
20:50:54 <jeffwheeler> The floors were always parallel with gravity, not perpendicular as is necessary to stand.
20:50:58 <pumpkin> or was it a ministry of magic coverup?
20:51:04 <jeffwheeler> SamB_XP: ah, damn! I should've known.
20:51:07 <SamB_XP> pumpkin: what the ?
20:51:19 <Pseudonym> Midichlorians explain everything.
20:51:26 <pumpkin> SamB_XP: you know, voldemort
20:51:34 <pumpkin> omg it's mmorrow!
20:51:37 <SamB_XP> pumpkin: coverup of ???
20:51:37 <jeffwheeler> Back to the Death Star . . .
20:51:40 <gwern> jeffwheeler: gravity generators.
20:51:48 <mmorrow> pumpkin: zomg pumpkin!
20:51:48 <gwern> how did people stand on the millenium falcon? :)
20:51:49 <lambdabot> mmorrow: You have 3 new messages. '/msg lambdabot @messages' to read them.
20:51:49 <pumpkin> SamB_XP: yeah, I heard there was a massive ministry of magic coverup
20:52:15 <jeffwheeler> gwern: and those offset the gravity from the mass of the Death Start itself?
20:52:16 <SamB_XP> jeffwheeler: how do you think they have a floor in the Falcon ?
20:52:24 <gwern> SamB_XP: jinx
20:52:31 <jeffwheeler> SamB_XP: a very heavy floor, of course.
20:52:34 <mmorrow> rwbarton: hehe, nice on the ghci hackery
20:52:36 <SamB_XP> jeffwheeler: lol
20:52:41 <rwbarton> mmorrow: :)
20:52:52 <gwern> jeffwheeler: well, I doubt the death star massed as much as a small moon, and a small moon doesn't generate much gravity
20:52:55 <pumpkin> mmorrow: are you a fusion-fu master? ;)
20:53:06 <SamB_XP> gwern: of course it didn't
20:53:15 <SamB_XP> it was the SIZE of a small moon, but with a lot more air in it
20:53:27 <pumpkin> the most profound star wars quote is in lambdabot, thankfully
20:53:30 <pumpkin> @quote ackbar
20:53:30 <lambdabot> ackbar says: it's a trap!
20:53:34 <jeffwheeler> gwern: it could fucking blow up planets. Sure it did!
20:53:37 * gwern snorkles
20:53:39 <SamB_XP> wait a minute
20:53:49 <SamB_XP> I don't remember him being in that scene
20:54:05 <gwern> it was the one where he was kissing leia
20:54:15 <SamB_XP> gwern: ackbar ?
20:54:16 <gwern> and ackbar told her that he wasn't her brother
20:54:20 <gwern> because he was a different species
20:54:21 <mmorrow> pumpkin: probably not, although i'm not sure what you're refering to.
20:54:32 <SamB_XP> gwern: lol
20:54:39 <mmorrow> , head $ [1..] >>- \x -> return x
20:54:41 <lunabot>  1
20:54:58 <gwern> ackbar was one cold fish
20:55:00 <mmorrow> rwbarton: i disabled arrow syn and added -XTypeOperator
20:55:10 <pumpkin> mmorrow: I'm trying to make a manually recursing function on a UArr, and I get the impression that the magic fusion isn't happening :(
20:55:16 <rwbarton> mmorrow: cool
20:55:55 <sjanssen> pumpkin: most of the fusion systems in Haskell require that you use special combinators to get fusion, usually explicit recusion won't work
20:56:00 <mmorrow> pumpkin: hmm, the uvector code is using 'stream' functions in the src, maybe these are necessary for that?
20:56:19 <mmorrow> yeah, what sjanssen said
20:56:21 <pumpkin> sjanssen: yeah, I figured, but none of the official UArr functions provide me with what I need :/
20:56:34 <mmorrow> yes, also true it looks like
20:56:52 <CakeProphet> rwbarton:  I want to make a monad that simulates dynamic typing...
20:57:22 <pumpkin> sjanssen: the closest I can come to it is an unfoldU, but that would mean decomposing the UArr within the unfold
20:57:22 <SamB_XP> CakeProphet: what's that got to do with a monad ?
20:57:33 <mmorrow> CakeProphet: on haskell expressions or on your own embedded language?
20:57:50 <pumpkin> mmorrow: couldn't find any Stream functions that did what I wanted either :( ah well
20:57:58 <mmorrow> :(
20:57:58 <CakeProphet> probably neither
20:58:02 <mmorrow> pumpkin: ask dons
20:58:09 <mmorrow> CakeProphet: heh, well on what then?
20:58:13 <CakeProphet> since I doubt it's possible to do it on haskell expressions and I don't really feel like embedding a language in haskell.
20:58:21 <pumpkin> mmorrow: he doesn't seem to be around, I guess I'll wait until he comes back
20:59:05 <sjanssen> pumpkin: otherwise you need to work directly with Stream
20:59:22 <CakeProphet> can anyone walk me through CPS?
20:59:26 <sjanssen> pumpkin: what sort of function are you trying to write?
20:59:29 <kmeyer> characters per second?
20:59:32 <pumpkin> sjanssen: I'm fine with that, but I can't find any stream functions that get me closer to it
20:59:38 <koninkje> CakeProphet: what sort of walkthrough are you looking for?
20:59:39 <CakeProphet> continuation passing style
20:59:54 <CakeProphet> one that gives me an understand of it, as currently I know nothing.
20:59:58 <CakeProphet> +ing
21:00:08 <mmorrow> @type let cps f = \k -> k f in cps
21:00:10 <lambdabot> forall t t1. t -> (t -> t1) -> t1
21:00:14 <pumpkin> sjanssen: trying to write a slideMapU (http://hpaste.org/13850) that slides a window over the UArr and applies a function to each window, accumulating the result in another UArr
21:00:17 <mmorrow> @src Cont
21:00:18 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
21:00:21 <Pseudonym> @go site:haskell.org cps
21:00:23 <lambdabot> http://www.haskell.org/haskellwiki/Continuation
21:00:23 <lambdabot> Title: Continuation - HaskellWiki
21:00:24 <mmorrow> @src Cont (>>=)
21:00:24 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
21:01:08 <mmorrow> @unmtl Cont r a
21:01:08 <lambdabot> (a -> r) -> r
21:01:30 <pumpkin> sjanssen: I implemented that with tails on a list, but there's no tailsU probably because there's no UA UArr, so I can't make a UArr of UArrs
21:01:54 <pumpkin> so I figured I'd skip the tails part and just make a tailsMap which did something similar
21:02:07 <pumpkin> without ever keeping the windows
21:02:36 <koninkje> CakeProphet: In general it's a transformation from "direct" code like f(g(h x)) into code like h x (f . g) where you pass the context (what you will do with the (h x) value) as an argument to h
21:02:39 <mmorrow> pumpkin: it looks like you'll have to get the uvector src and start messing with the internals to either expose the functions you'd need, or to write what you want with the internal functions, then export your new functions along with the existing interface
21:02:51 <pumpkin> ah
21:02:55 <CakeProphet> koninkje:  isn't that similar to >>=?
21:03:04 <pumpkin> most of the functions in there are just streaming and unstreaming
21:03:19 <pumpkin> and applying the associated stream function in between of course
21:03:32 <mmorrow> CakeProphet: exactly. monad (>>=) is really just cps
21:03:41 <koninkje> CakeProphet: it's fairly similar (the Cont monad does the CPS transformation for you, while still looking like normal code)
21:04:13 <koninkje> CakeProphet: But, CPS is a *style* and you can use that style without using Cont
21:04:39 <sjanssen> pumpkin: does uvector expose the actual defn. of Stream?
21:04:49 <pumpkin> sjanssen: nope, don't think so
21:04:54 <CakeProphet> hmmm... should I learn arrows first or continuations? Do either require the other to understand?
21:04:56 <sjanssen> that's a bit broken
21:05:10 <koninkje> CakeProphet: Are you familiar with difference lists, DList, or the shows function?
21:05:16 <pumpkin> I'm not opposed to editing the source, but maybe I'll leave that to when I feel more ambitious
21:05:26 <pumpkin> the Stream type is neat
21:05:30 <pumpkin> I read the paper on it
21:05:32 <Pseudonym> CakeProphet: Continuations, I think, are a more commonly applied concept at the moment.
21:06:09 <CakeProphet> koninkje:  I think I remember what shows does. It does multiple shows on a single input
21:06:12 <CakeProphet> or whatever.
21:06:14 <CakeProphet> never used it though
21:06:51 <koninkje> CakeProphet: diff.lists, DList, and shows are all doing the same thing, so I'll explain...
21:06:56 <sjanssen> pumpkin: I don't think this function is reasonably fusible
21:07:05 <pumpkin> oh :(
21:07:19 <sjanssen> pumpkin: you want to take slices of the array, which means the actual array must be constructed, right?
21:07:59 <pumpkin> well, it feels like I could just use the slices without constructing the array, but maybe I'm misunderstanding
21:08:08 <pumpkin> the issue is that each element is accessed several times
21:08:13 <pumpkin> it seems
21:08:28 <koninkje> The normal way you'd build a sting is by using (++) to glue smaller strings together. In some cases this can lead to very bad performance because you end up concatenating the same list over and over (e.g. (a++b)++c will traverse a twice)
21:08:49 <sjanssen> pumpkin: yes, the issue is using each element several times
21:08:56 <kmeyer> a ++ (b ++ c) is faster
21:09:05 <pumpkin> kmeyer: it's right associative anyway
21:09:06 <CakeProphet> koninkje:  right
21:09:10 <sjanssen> also, you need a place to store those elements (unless the function argument is itself fusible)
21:09:18 <kmeyer> pumpkin: ah, thought so
21:10:12 <sjanssen> pumpkin: oh, isn't consU going to ridiculously expensive?
21:10:13 <pumpkin> sjanssen: it seems like it should only require as much memory as the window size though, if I had all the options
21:10:14 <koninkje> The difference list transformation is a CPS transform of (++) which, instead of taking two strings and returning a new string, takes one string and returns a function from a string (which replaces the [] in the first string) to a string (the concatenated string). With this style you can use (.) to concatenate these functions, and then pass [] once at the very end
21:10:18 <pumpkin> sjanssen: I'm sure :)
21:10:28 <pumpkin> sjanssen: I was thinking of rewriting it with a unfoldU
21:10:35 <pumpkin> but that's still only fixing half the problem
21:10:37 <sjanssen> pumpkin: that is probably the real issue here -- you're using consU repeatedly, making the function O(n^2)
21:10:44 <sjanssen> consU is O(n), I'm sure
21:10:48 <pumpkin> ah okay
21:10:56 <pumpkin> I assumed it was O(1) like lists but O(n) makes sense
21:11:01 <koninkje> kmeyer: Yes, it is. But you don't always have the option of building strings that way, hence difference lists
21:11:24 <kmeyer> right
21:11:37 <koninkje> CakeProphet: does that make sense?
21:12:31 <CakeProphet> koninkje:  sort of, can I see an example?
21:13:03 <koninkje> The DList package wraps it all up in a newtype, but here: http://hackage.haskell.org/packages/archive/dlist/0.4.1/doc/html/src/Data-DList.html
21:13:05 <pumpkin> sjanssen: (if I were able to do anything) it seems like I could do this sliding window thing with a nice circular buffer in O(windowsize) memory
21:13:22 <pumpkin> and pretty much no time overhead
21:13:38 <koninkje> The Prelude should also have the code for @shows@
21:13:39 <pumpkin> without actually building the underlying array
21:14:46 <sjanssen> pumpkin: hmm, yes, you could probably do that
21:14:59 <sjanssen> but it will be rather slower in cases where the underlying array already exists
21:15:05 <pumpkin> yeah, true :/
21:15:06 <pumpkin> hmm
21:15:12 <pumpkin> I guess there's no easy way out :P
21:15:17 <sjanssen> I'd suggest not trying to get fancy
21:15:25 <pumpkin> yeah :)
21:15:28 <koninkje> CakeProphet: The CPS idea in difference lists is to replace the second list argument by a continuation. After building up this big function and applying it to [], the evaluation will walk through the first list returning each element until running out, and then it will _continue_ as the second argument, etc
21:15:29 <sjanssen> just start with using unfoldl, that will probably help quite a bit
21:15:43 <pumpkin> unfoldU :: UA a => Int -> (b -> MaybeS (a :*: b)) -> b -> UArr a
21:15:54 <pumpkin> any idea what that Int parameter does? there's no documentation for that function :)
21:16:06 <sjanssen> pumpkin: final size of the array?
21:16:17 <pumpkin> that would make sense :)
21:16:23 <sjanssen> pumpkin: also, poke dons to write docs :)
21:16:24 <thoughtpolice> pumpkin: size
21:16:33 <mmorrow> , [$ty| unfoldU |]
21:16:40 <lunabot>  forall a b . UA a => Int -> (b -> MaybeS (:*: a b)) -> b -> UArr a
21:16:40 <pumpkin> sjanssen: I feel bad bugging people to do stuff :P
21:16:40 <thoughtpolice> pumpkin: i initially poked at dons to code that up into uvector a while back because I was doing some tests
21:16:40 <devilx0>  :o
21:16:59 <koninkje> CakeProphet: Here's another CPS example, which is different from DList: http://hpaste.org/13818
21:17:02 <pumpkin> thoughtpolice: ah, coo
21:17:03 <pumpkin> ll
21:17:14 <mmorrow> , src ''MaybeS
21:17:20 <lunabot>  data MaybeS a = NothingS | JustS !a
21:17:25 <mmorrow> ah
21:17:28 <thoughtpolice> strict maybe :)
21:17:38 <mmorrow> heh
21:17:44 <mmorrow> , src ''(:*:)
21:17:46 <lunabot>  luna: Ambiguous occurrence `:*:'
21:17:50 <thoughtpolice> that's a strict pair
21:17:50 <mmorrow> grr
21:17:52 <thoughtpolice> :>
21:17:58 <mmorrow> i shoulda known..
21:18:14 <koninkje> The idea here is that we have a recursive function @cyc@. But instead of writing it in the normal way, we write it in "open recursion" form, where it takes a continuation @k@ for what to do in order to recurse
21:18:24 <CakeProphet> :t when
21:18:25 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
21:19:03 <CakeProphet> ah, right.
21:19:19 <koninkje> If we used @Control.Monad.Fix.fix cyc@ that will tie the loop in order to get the normal recursive definition. But in this program, we inject the @memo@ function in between each recursive call to @cyc@
21:20:53 <pumpkin> thoughtpolice: will unfoldU make a list of that size no matter how many JustS you return in your function?
21:21:06 <pumpkin> what if your function's behavior and the array size you provide don't match?
21:21:08 <koninkje> Note that memo :: ... (A -> A) -> A  has the same sort of type as fix :: (a -> a) -> a. If we wanted a different memoizer, or wanted to inject something else between each recursion of cyc, we'd just replace the fixed-point function we use as the continuation
21:22:05 <mmorrow> , let foldC f !z [] = z; foldC f !z (x:xs) = f z x (\z' -> foldC f z' xs); prod = foldC (\a b k -> if b==0 then 0 else k (a*b)) 1 in prod ([1..10]++[0]++[1..100000000000])
21:22:07 <lunabot>  0
21:22:23 <Axman6> bleh, ghc bug, seemingly when using paralel arrays and +RTS -kN
21:22:49 <CakeProphet> koninkje:  would it be CPS to write a conditional function that takes a condition, a true function, and a false function?
21:24:03 <koninkje> CakeProphet: you mean like the Church encoding for booleans? Yes, that's CPS
21:24:06 <koninkje> http://en.wikipedia.org/wiki/Church_encoding
21:24:06 <mmorrow> CakeProphet: that `foldC is a variant of foldl' that takes a function which takes a continuation in addition to the usual two args, and foldC passes itself as the continuation to `f' thus giving `f' a way to bail i fit wants
21:24:20 <pumpkin> sjanssen: you're right, it's a lot faster with an unfold, but still not very fast :/
21:24:48 <mmorrow> (in that case, bailing == not calling the continuation)
21:25:00 <Taejo> is there a name for the ([a], [a]) implementation of queues?
21:25:28 <pumpkin> a queue of two stacks?
21:25:29 <pumpkin> :P
21:26:44 <sjanssen> Taejo: I think it might be called a banker's queue
21:27:21 <pumpkin> those sly bankers
21:27:26 <pumpkin> always doing things different
21:27:37 <pumpkin> bbiab :)
21:31:07 <koninkje> CakeProphet: The Maybe monad is often used to express falible functions, but there's a hidden performance cost since once you get Nothing you still have to walk through the remaining (or continuing) code. But we can use a CPS version of Maybe where "Nothing" means we escape the entire continuing call stack and return immediately:
21:31:12 <koninkje> http://community.haskell.org/~wren/wren-extras/Control/Monad/MaybeCPS.hs
21:33:38 <koninkje> CakeProphet: If you're up for some academic reading, another example that I found helpful was Oleg's paper on LogicT: http://okmij.org/ftp/Computation/monads.html#LogicT . There, the Logic monad is like a list except it uses two continuations (one for success as in DList, and one for failure as in MaybeCPS)
21:34:01 <koninkje> It's one of Oleg's more readable papers, though it has some hefty concepts in it
21:36:38 <newsham> mmorrow: i bit the bullet and added fold derivation to Data.Derive.
21:37:13 * BMeph has scary C flashbacks whenever people start talking about "stack frames"...
21:37:50 <BMeph> newsham: Why not use Data.Foldable? :)
21:38:28 <newsham> because i'm not folding over some type (X a)
21:40:40 <pumpkin> this uvector package really turns me on AND it has a long todo file... maybe I'll try to implement some of the todo items on it
21:40:53 <CakeProphet> :t readArray
21:40:54 <lambdabot> Not in scope: `readArray'
21:41:46 <CakeProphet> I'm guessing IOUArray is some sort of IO wrapper over Arrays.
21:42:00 <pumpkin> it's probably an unboxed mutable array in IO?
21:43:00 <mmorrow> newsham: sweet!
21:43:02 <dolio> pumpkin is correct.
21:43:16 <pumpkin> yay
21:43:18 <pumpkin> I love being correct
21:43:28 <pumpkin> (it's rare enough that it's yayworthy)
21:43:42 <CakeProphet> how can it be mutable in Haskell?
21:43:48 <mmorrow> easy
21:43:51 <pumpkin> by living in IO
21:43:56 <mmorrow> (or ST)
21:44:06 <pumpkin> or ST :)
21:45:10 <CakeProphet> oh lawd, what's ST.
21:45:29 <newsham> ST's like a mini-IO
21:45:33 <skorpan> we could tell you... but we'd have to kill -9 you
21:45:40 <mmorrow> , runST (x <- newSTRef 42; writeSTRef x 99; readSTRef x)
21:45:42 <lunabot>  luna: parse error on input `<-'
21:45:46 <mmorrow> , runST (do x <- newSTRef 42; writeSTRef x 99; readSTRef x)
21:45:48 <lunabot>  99
21:46:10 <mmorrow> hehe, kill -9ing
21:46:27 <CakeProphet> oh... that's... cool.
21:46:39 <newsham> ?type runST
21:46:40 <lambdabot> forall a. (forall s. ST s a) -> a
21:46:53 <CakeProphet> how did x "become" 99
21:46:55 <newsham> unlike IO, you get a pure value out of it
21:47:06 <pumpkin> it's like a portable prison!
21:47:17 <mmorrow> you can runST into a pure value because the (forall s. ...) ensures that no effects can "escape"
21:47:20 <mauke> a pocket dimension
21:47:48 <mmorrow> , runST (do x <- newSTRef 42; writeSTRef x 99; return x)
21:47:50 <lunabot>  luna: Inferred type is less polymorphic than expected
21:48:20 <mmorrow> that attempted to return the STRef itself
21:48:34 <cknapp> Wait... what is lunabot?
21:48:34 <newsham> trapped!
21:48:45 <newsham> , 1 + 2
21:48:47 <lunabot>  3
21:48:52 <CakeProphet> oh... x returns a STRef... and writeSTRef x 99 changes the value held in it to x
21:49:10 <pumpkin> CakeProphet: yeah, there are other STable things too
21:49:17 <pumpkin> like the MUArr I was struggling with yesterday
21:49:18 <mmorrow> cknapp: it's another bot that has some features lambdabot doesn't support. namely template-haskell and an embedded `eval' function
21:49:28 <cknapp> Ah.
21:49:29 <mmorrow> , eval "eval \"42\""
21:49:34 <lunabot>  <<Dynamic>>
21:49:52 <Saizan_> , ord
21:49:53 <mmorrow> and lunabot is actually using that exact same `eval' function to eval Strings coming in over the network
21:49:55 <lunabot>  luna: No instance for (GHC.Show.Show (GHC.Types.Char -> GHC.Types.Int))
21:50:16 <rwbarton> mmorrow: you could add lambdabot's Show (a -> b) instance
21:50:30 <mmorrow> i could. what is it?
21:50:34 <Saizan_> without also the overlapping one
21:50:38 <mmorrow> heh
21:50:51 <newsham> , [| 2 + 3 |] >>= lift . show
21:50:54 <lunabot>  ListE [LitE (CharL 'I'),LitE (CharL 'n'),LitE (CharL 'f'),LitE (CharL 'i'...
21:50:57 <mmorrow> woot
21:51:13 <rwbarton> mmorrow: something like  instance (Typeable a, Typeable b) => Show (a -> b) where show _ = "(" ++ show (typeOf (undefined :: a)) ++ " -> " ++ show (typeOf (undefined :: b)) ++ ")"
21:51:26 <CakeProphet> I want to put my BF interpreter on lambdabot.
21:51:37 <CakeProphet> since the one it has is broken apparently.
21:51:40 <mmorrow> newsham: aren't the Lift instances for Exp/Dec/Info/etc just the best things evar? :)
21:51:58 <mmorrow> rwbarton: ahhh. cool, i'll do that.
21:51:59 <newsham> isnt that printing an error message? "Infi..."
21:52:04 <Saizan_> instance (Typeable a, Typeable b) => Show (a -> b) where show e = '<' : (show . typeOf) e ++ ">"
21:52:14 <rwbarton> It's printing out:
21:52:16 <rwbarton> , [| 2 + 3 |]
21:52:17 <Saizan_> that's from \bot code
21:52:19 <lunabot>  InfixE (Just (LitE (IntegerL 2))) (VarE +) (Just (LitE (IntegerL 3)))
21:52:22 <Axman6> what's the difference between par and pseq?
21:52:22 <newsham> oh
21:52:47 <sjanssen> Axman6: pseq is like seq, par is entirely different
21:53:07 <Axman6> could you explain the usage of each?
21:53:14 <newsham> , [| data X = X | Y |]
21:53:16 <lunabot>  luna: parse error on input `data'
21:53:19 <newsham> , [d| data X = X | Y |]
21:53:22 <lunabot>  DataD [] X [] [NormalC X [],NormalC Y []] []
21:53:40 <mmorrow> newsham: i added instance of Show ExpQ/DecQ/etc since lunabot can't runQ
21:53:49 <mmorrow> (which use necessarily unsafePerformIO
21:53:50 <mmorrow> )
21:54:04 <mmorrow> (and that also clean up the qualified names)
21:54:07 <sjanssen> x `par` y -- Hey compiler, if you have some free time, evaluate x to WHNF.  Meanwhile, return y immediately
21:54:45 <sjanssen> x `pseq` y -- Mr. Compiler, please evaluate x to WHNF before evaluating y
21:55:05 <Axman6> so how's that differ from seq?
21:55:29 <sjanssen> Axman6: the difference to seq is very subtle (such that I can't really explain it)
21:55:43 <Axman6> heh, fair enough
21:55:50 <Saizan_> pseq lies to the optimizer about its strictness on y
21:55:52 <mmorrow> lunabot also has:
21:56:03 <Saizan_> so that the computations can't be reordered
21:56:12 <mmorrow> , let x = 1 + 1 in [closureType x, x `seq` closureType x]
21:56:16 <lunabot>  [AP,Constr]
21:56:18 <Axman6> ah ok
21:56:32 <mmorrow> , let x = 1 + 1 in [isFullyEvaluated x, x `seq` isFullyEvaluated x]
21:56:37 <lunabot>  [False,True]
21:56:38 <rwbarton> Why isn't that necessary also for the common uses of seq to control space use?
21:57:07 <mmorrow> , let x = 42 in x .==. 42
21:57:11 <lunabot>  False
21:57:12 <mmorrow> , let x = 42 in x .==. x
21:57:16 <lunabot>  True
21:57:28 <mmorrow> hehe, (.==.) = reallyUnsafePtrEquality
21:57:40 <mmorrow> , reallyUnsafePtrEquality
21:57:42 <lunabot>  luna: No instance for (GHC.Show.Show (a -> a -> GHC.Bool.Bool))
21:58:00 <Axman6> heh
21:58:26 <dolio> , let x = 42 in x == (42 :: Float) && x == (42 :: Int)
21:58:27 <lunabot>  luna: Couldn't match expected type `GHC.Types.Float'
21:58:47 <mmorrow> , (.==.)
21:58:49 <lunabot>  luna: No instance for (GHC.Show.Show (a -> a -> GHC.Bool.Bool))
21:58:58 <CakeProphet> , 3 .==. 3
21:59:03 <lunabot>  False
21:59:04 <CakeProphet> :3
21:59:25 <mmorrow> it's not called reallyUnsafe for nothing :)
21:59:25 <Saizan_> rwbarton: afaiu, let e = .. x`seq` y, when considering space usage you only want x to be forced when looking at e, while for parallelism you want the intermediate computations to be sparked before evaluating the end result
21:59:52 <CakeProphet> , let x = 3 in x .==. x
21:59:57 <lunabot>  True
22:00:01 <CakeProphet> oh ho.
22:00:06 <mmorrow> , (3::Int) .==. (3::Int)
22:00:12 <CakeProphet> is that implemented in Haskell or is it compiler/C magic.
22:00:13 <lunabot>  False
22:00:16 <rwbarton> , 3#
22:00:18 <lunabot>  luna: Not in scope: `#'
22:00:21 <mmorrow> it's ghc magic
22:00:33 <mmorrow> compiler + representation specific
22:00:42 <sjanssen> , 'a' .==. 'a'
22:00:47 <lunabot>  False
22:00:48 <mmorrow> as are closureType and isFullyEvaluated
22:00:55 <rwbarton> , Nothing .==. Nothing
22:01:00 <lunabot>  True
22:01:04 <CakeProphet> mmorrow:  ...isFullyEvaluated?
22:01:06 <sjanssen> hmm, weird.  Doesn't GHC statically allocate the ASCII range?
22:01:10 <CakeProphet> does it do what it sounds like it does?
22:01:10 <mmorrow> , let x = 1 + 1 in [isFullyEvaluated x, x `seq` isFullyEvaluated x]
22:01:16 <lunabot>  [False,True]
22:01:17 <mmorrow> , let x = 1 + 1 in [closureType x, x `seq` closureType x]
22:01:22 <lunabot>  [AP,Constr]
22:01:27 <rwbarton> , src 'closureType
22:01:28 <dolio> @src Char
22:01:28 <lambdabot> data Char = C# Char#
22:01:33 <lunabot>  Killed.
22:01:37 <mmorrow> heh
22:01:38 <mmorrow> um
22:01:40 <CakeProphet> mmorrow:  wow. a strictness test?
22:01:40 <rwbarton> , src 'closureType
22:01:46 <lunabot>  Killed.
22:01:48 <mmorrow> , [$ty| closureType |]
22:01:54 <lunabot>  Killed.
22:01:56 <mmorrow> gah
22:01:58 <rwbarton> Just like runIO...
22:02:04 * mmorrow checks lunabot's machine
22:02:12 <ddarius> @hoogle isBottom
22:02:12 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
22:02:18 <dolio> sjanssen: That might be the bytecode being poorly optimized.
22:02:37 <sjanssen> dolio: good point
22:02:39 * sjanssen tests
22:02:42 <dolio> sjanssen: GHC typically lifts literals out of code and names them.
22:02:43 <mmorrow> i need to upgrade my friggin package on this hosted server
22:02:47 <CakeProphet> hmmm
22:02:55 <mmorrow> lunabot's machine blows
22:03:01 <CakeProphet> , id .==. id
22:03:02 <dolio> When you compile with optimization.
22:03:03 <mmorrow> (virtual machine i should say)
22:03:06 <lunabot>  True
22:03:14 <CakeProphet> ...sweet. function equality. :3
22:03:24 <mmorrow> , id .==. (\x -> x)
22:03:28 <lunabot>  False
22:03:44 <BMeph> mmorrow: Sup dawg, i herd u liek servers... ;p
22:03:55 <mmorrow> LOl
22:04:15 <mmorrow> , [$ty| closureType |]
22:04:17 <CakeProphet> , _|_ .==. _|_
22:04:21 <lunabot>  forall a . a -> ClosureType
22:04:22 <lunabot>  luna: parse error on input `|'
22:04:29 <rwbarton> , src ''ClosureType
22:04:30 <mmorrow> , ''ClosureType
22:04:34 <lunabot>  data ClosureType = Constr
22:04:34 <lunabot>                   | Fun
22:04:34 <lunabot>                   | Thunk Int
22:04:36 <lunabot>  RtClosureInspect.ClosureType
22:04:40 <CakeProphet> aw. Unfortunately .==. isn't magic enough to solve the halting problem.
22:04:42 <BMeph> , (_|_) .==. (_|_)
22:04:45 <lunabot>  luna: parse error on input `|'
22:04:48 <mmorrow> rwbarton: there're a bunch more constructors..
22:05:02 <BMeph> Looks like the same butt to me... ;)
22:05:03 <mauke> BMeph: http://macrochan.org/get.py?sha1=JV2NGTROMW54LCLAIHTNM4CA6P5PPHUU
22:05:11 <Axman6> mmorrow: what's the int in Thunk for?
22:05:16 <rwbarton> mmorrow: so there are
22:05:26 <mmorrow> Axman6: i think it's a unique id or something
22:05:30 <Axman6> ah
22:05:47 <mmorrow> (this is the closure type of the closure in the actual heap)
22:06:19 <BMeph> mmorrow: ...it's now my background pic. :)
22:06:19 <rwbarton> , let x () = 3 in isFullyEvaluated x
22:06:24 <lunabot>  False
22:06:27 <seveninchbread> rofl, it kicked me
22:06:29 <mmorrow> BMeph: heh
22:06:57 <CakeProphet> , let x = id in x .==. id
22:06:59 <CakeProphet> I typed that in just a second ago
22:07:01 <lunabot>  True
22:07:07 <CakeProphet> and I disconnected
22:07:09 <CakeProphet> it really /is/ really unsafe.
22:07:15 <mmorrow> rwbarton: i've tried before to get closureType to spit out "BlackHole" and been unsuccessful
22:07:35 <rwbarton> Probably it can only happen when optimizing
22:07:37 <mmorrow> i can't figure out how to get it to
22:07:45 <Axman6> , closureType RealWorld
22:07:47 <lunabot>  luna: Not in scope: data constructor `RealWorld'
22:07:49 <mmorrow> yeah, i think it may be impossible with a single expression
22:07:50 <Axman6> dang
22:08:02 <CakeProphet> > isFullyEvaluated ($!)
22:08:03 <sjanssen> , isFullyEvaluated isFullyEvaluated
22:08:03 <lambdabot>   Not in scope: `isFullyEvaluated'
22:08:07 <CakeProphet> what is RealWorld? I've seen it before.
22:08:08 <lunabot>  False
22:08:16 <Axman6> @src IO
22:08:16 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
22:08:26 <rwbarton> , src ''RealWorld
22:08:30 <mmorrow> sjanssen: for some reason, all functions are defined to never be fully evaluated
22:08:31 <lunabot>  luna: Can't find interface-file declaration for data constructor GHC.Base...
22:08:38 <mmorrow> heh
22:08:49 <mmorrow> , src ''IO
22:08:54 <lunabot>  newtype IO a = IO ((State# RealWorld) ->
22:08:54 <lunabot>                     (#,#) (State# RealWorld) a)
22:09:01 <CakeProphet> ....what on earth
22:09:07 <CakeProphet> State#?
22:09:13 <CakeProphet> (#,#)?
22:09:17 <ddarius> , src ''ST
22:09:22 <sjanssen> CakeProphet: RealWorld is a magic type that has no run time representation.  GHC uses it to ensure sequence of IO operations
22:09:22 <lunabot>  newtype ST s a = ST (STRep s a)
22:09:25 <idnar> (#,#) is an unboxed tuple, I believe
22:09:36 <ddarius> ,src ''STRep
22:09:36 <lunabot>  luna: Not in scope: type constructor or class `STRep'
22:09:42 <mmorrow> awww
22:09:52 <dons> if  you see a (# #) you can know that the arguments are returned on the stack (or in registers)
22:09:56 <dons> not heap allocated
22:09:59 <idnar> if I'm not mistaken, that's the same as (# State# RealWorld, a #)
22:10:01 <sjanssen> @src unsafePerformIO
22:10:01 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
22:10:04 <dons> so you can pass around structures without allocating
22:10:28 <Axman6> :t fmap (+1)
22:10:29 <lambdabot> forall a (f :: * -> *). (Functor f, Num a) => f a -> f a
22:10:30 <mmorrow> idnar: yes, lunabot's using the TH prettyprinter which isn't exactly a beautifulprinter ;)
22:11:02 <idnar> oh yeah, someone did the lambdabot version up there, but then I ended up looking at the lunabot one
22:11:11 <ddarius> ,src ''(,)
22:11:17 <lunabot>  data (,) a b = (,) a b
22:11:23 <CakeProphet> @src (.==.)
22:11:24 <lambdabot> Source not found. Just try something else.
22:11:24 <mmorrow> , src ''(,,,,,,,,,,,,,,,,,,,)
22:11:29 <lunabot>  data (,,,,,,,,,,,,,,,,,,,) a b c d e f g h i j k l m n o p q r s t = (,,,...
22:11:29 <lunabot>                                                                           ...
22:11:29 <lunabot>                                                                           ...
22:11:30 <CakeProphet> ,src (.==.)
22:11:33 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
22:11:40 <mmorrow> , src '(.==.)
22:11:46 <lunabot>  ) :: forall a . a -> a -> Bool
22:11:51 <mmorrow> type names are prefixed with ''
22:11:52 <idnar> haha
22:11:58 <Axman6> heh
22:11:58 <mmorrow> non-type names with '
22:12:07 <mmorrow> weird
22:12:14 <mmorrow> , src '(.==.)
22:12:19 <lunabot>  ) :: forall a . a -> a -> Bool
22:12:20 <mmorrow> prettyprinter FAIL
22:12:22 <rwbarton> mmorrow: where is closureType from?
22:12:28 <mmorrow> RtClosureInspect
22:12:30 <mmorrow> in ghc
22:12:37 <mmorrow> you have to do
22:12:39 <mmorrow> ghci -p ghc
22:12:49 <mmorrow> if you haven't sudo ghc-pkg expose ghc
22:12:49 <rwbarton> oh is it unsafePerformIO . getClosureData ?
22:12:54 <mmorrow> yes
22:12:58 <mmorrow> well, it's
22:13:14 <mmorrow> closureType a = unsafePerformIO (tipe `fmap` getClosureData a)
22:13:43 <CakeProphet> I'm going to do a search-and-replace on all of my .hs files from == to .==.
22:13:49 <CakeProphet> for maximum lulz
22:13:52 <mmorrow> and isFullyEvaluated is unsafePerformIO RtClosureInspect.isFullyEvaluated
22:14:00 <Axman6> CakeProphet: heh
22:14:18 <mmorrow> CakeProphet: i defined (.==.) in lunabot, it doesn't exist
22:14:27 <mmorrow> (anywhere else)
22:14:45 <mmorrow> but it's just (.==.) = GHC.Prim.reallyUnsafePtrEquality
22:15:16 <dolio> Except that doesn't exist either.
22:15:22 <mmorrow> heh
22:15:31 <Saizan_> i wonder what they use it for
22:15:45 <dolio> What there really is is: reallyUnsafePtrEquality# :: a -> a -> Int#
22:15:52 <mmorrow> oh yeah, oops
22:15:58 <mmorrow> oh yeah, so i did
22:16:14 <moonpatio> reallyUnsafePtrEquality :: a -> a -> Bool
22:16:14 <moonpatio> reallyUnsafePtrEquality x y = 1 == I# (reallyUnsafePtrEquality# x y)
22:16:29 <moonpatio> (.==.) = reallyUnsafePtrEquality
22:16:41 <Axman6> reallyUnsafePtrEquality# = ?
22:16:48 <dolio> Magic.
22:16:55 <Axman6> ah yes
22:17:25 <dolio> GHC.Prim is all magic, I think.
22:17:33 <mmorrow> yeah, i think it is
22:17:42 <dons> Axman6: how'd the nbody ideas come along?
22:17:46 <dons> get an implementation going?
22:17:47 <dolio> I'm not sure such a .hs file even exists.
22:17:56 <mmorrow> pretty much everything in there is actually implemented in Cmm
22:18:01 <dolio> Yeah.
22:18:04 <pumpkin> dons: got a moment for a UArr question?
22:18:07 <mmorrow> yeah, it doesn't actually exist
22:18:07 <Axman6> dons: not one that actually works yet :\ havig issues with the advance function
22:18:22 <Axman6> i'm trying the ST monad now.
22:18:26 <dons> pumpkin: sure
22:18:32 <dons> Axman6: ok. good work.
22:18:38 <dons> nbody looks not too magic to me.
22:19:49 <CakeProphet> > let makeRelevant = const "lol" in makeRelevant "I wonder if I  can wash my white socks with the rest of my clothing."
22:19:51 <lambdabot>   "lol"
22:20:09 <dons> heh
22:20:09 <pumpkin> dons: I'm trying to implement a sliding window map on top of a UArr, but it doesn't look like it's too easy to do efficiently... I originally implemented a pseudo tailsU + mapU and did a lot of consU, but that was unbearably slow so moved to unfoldU... can you think of a way of making it more efficient? this is my code so far http://hpaste.org/13850#a1
22:20:28 <dons> consU not so good.
22:20:34 <Axman6> dons: this one? http://shootout.alioth.debian.org/u64q/benchmark.php?test=nbody&lang=ghc&id=1 it's full of (IMO) nasty C like pointer nonsense :P
22:20:36 <dons> maybe just do it mutably and freeze the result?
22:20:50 <dons> yeah, that's the one , Axman6 :D
22:21:04 <pumpkin> dons: I thought of that, but last time I tried to do something mutably and freeze it, it was awesomely slow, so I was scared away
22:21:28 <pumpkin> dons: mostly because I was forced to just readMU repeatedly on that MUArr, I think
22:21:28 <dons> i think the only tweaks i had were to use
22:21:29 <dons> pLANET_SCALE n = (scale *# 7#) *# n where I# scale = sizeOf (undefined :: Double)
22:21:47 <dons> hmm. i have some interesting nbody stubs lying around. should finish those.
22:22:03 <dons> pumpkin: well. its just raw memory
22:22:42 <dons> ah yes, Axman6 i was writing an instance MArray Planet ST
22:22:57 <pumpkin> dons: hmm, weird then... not sure why my MUArr-based one was so much slower than the list-based one... I'm pretty sure they had equal time complexity
22:23:07 <dons> interesting.
22:23:16 <dons> Axman6: i wanted bodies <- listUArrayST (0,nbodies-1) planets :: ST s (SolarSystem s)
22:23:22 <ddarius> pumpkin: You were probably doing something horribly, horribly wrong
22:23:27 <pumpkin> ddarius: probably :)
22:23:31 <dons> i'll post my code so you can poke around
22:23:36 <pumpkin> I can paste the code for that, but it's rather ugly
22:23:39 <pumpkin> and imperative-looking
22:23:57 <dons> Axman6: my stubbed out ST version  http://hpaste.org/13852
22:24:08 <Axman6> dons: knowing your code, it'll be far beyond my capabilities to understand it sadly, but i'll take a look anyway
22:24:25 <dons> well umm hmm really? :}
22:24:51 <dons> {-# LANGUAGE BangPatterns          #-}
22:24:51 <dons> {-# LANGUAGE MultiParamTypeClasses #-}
22:24:51 <dons> {-# LANGUAGE MagicHash             #-}
22:24:51 <dons> {-# LANGUAGE UnboxedTuples         #-}
22:24:54 <dons> can't hurt anyone :)
22:24:55 <Axman6> ah maybe not, that looks understandable :)
22:25:03 <dons> i was trying to write a 'clean' version
22:25:33 <pumpkin> http://hpaste.org/13853 is my slow MUArr sliding entropy function that I just gave up on... I ended up using toU . slidingEntropyList . fromU for it
22:25:50 <dons> mm
22:26:01 <dons> i need to finish the uvector lib. too many people are using it :)
22:26:16 <pumpkin> hah, I've been bugging you a lot about it in the past couple of days, sorry :/
22:26:16 <CakeProphet> Data.Map.fromListWith is a neat function.
22:26:25 <dons> pumpkin: no, its good.
22:26:39 <pumpkin> dons: I really really like it, and that big TODO file is quite attractive to my "noob wants interesting stuff to work on" sense
22:27:10 <Axman6> dons: i've been using a Vec3 type (V !Double !Double !Double) for my position and velocity to make the vector ops like momentum and potential energy easier. is there any disadvantage to having a type Body = B Vec3 Vec3 Double instead of B Double Double Double Double Double Double Double?
22:27:15 <dolio> dons: That reminds me, did my patches actually get to you?
22:27:34 <dons> dolio: yep. i'll push them.
22:27:38 <dolio> Okay.
22:28:02 <pumpkin> Axman6: an extra level of indirection maybe? unless they're unboxable somehow?
22:28:07 <dons> Axman6: hmm. unpack the Vec3 and they'll be the same
22:28:14 <CakeProphet> I think I might write a simple MUD server in Haskell.
22:28:16 <dons> {-# UNPACK #-} !Vec3,
22:28:24 <Axman6> ah, excellent
22:28:36 <erikc> wear Gauntlets of Purity
22:28:55 <CakeProphet> the only problem is I don't really know how to make it easy to extend.
22:29:18 <gwern> CakeProphet: you wouldn't be the first
22:29:20 <dons> CakeProphet: just take a list of functions, and add to them later
22:29:22 <dons> ?
22:29:24 <gwern> to write a MUD server, I mean
22:29:44 <pumpkin> ddarius/dons: see anything obviously slow in that ugly sliding entropy function? it seems to be correct, but runs about 60 times slower than my list/IntMap based one (the IntMap doesn't look like it affects the complexity of the basic algorithm in my list one)
22:29:57 <erikc> a good mud server in haskell would require some hs-plugin fun
22:30:13 <gwern> nah, I think a mud could use the xmonad model
22:30:16 <gwern> it's all text
22:30:35 <erikc> gwern: i was thinking you can do online area creation + scripting in haskell :)
22:30:42 <CakeProphet> ugh, my connection is awful right now.
22:31:13 <pumpkin> CakeProphet: seven inch bread? :o
22:31:20 <CakeProphet> dons:  how do you add functions to a list later on?
22:31:22 <dons> pumpkin: a quick look didn't reveal anything
22:31:23 <CakeProphet> pumpkin:  yes.
22:31:27 <gwern> most men make do with 5 or 6 inches!
22:31:28 <dons> CakeProphet: edit the list?
22:31:47 <dolio> pumpkin: runST $ do m <- newMU n ; ... ; unsafeFreezeAllMU m = newU n $ \m -> ...
22:31:48 <pumpkin> dons: alright, thanks for looking :) I'll take another look at it when I get better at this
22:31:48 * BMeph wants to see an Inform DSL in Haskell, but not so badly as to write it himself...
22:31:52 <CakeProphet> dons:  ...by hand?
22:32:06 <dons> CakeProphet: well, you could put the functions in a config file, like xmonad does
22:32:08 <pumpkin> dolio: hmm
22:32:20 <gwern> BMeph: hmm no we don't have that; would a z-machine emulator suffice?
22:32:25 <dolio> I think newU is the name, that is.
22:32:51 <pumpkin> dolio: I thought the newU made a MUArr from a UArr?
22:33:02 <pumpkin> oh it doesn't
22:33:20 <CakeProphet> dons:  a map would be better suited, in any case. Map String Command
22:33:20 <pumpkin> dolio: you think that would affect my performance much?
22:33:37 <dolio> No. I think the above is almost a verbatim definition in reverse.
22:33:42 <dons> CakeProphet: oh, a symbol table
22:33:42 <dolio> It's just convenient.
22:33:44 <dons> perhaps.
22:33:51 <pumpkin> dolio: yeah, I'll change that
22:35:03 <CakeProphet> dons:  what's the type name for a mutable list of some sort?
22:35:15 <CakeProphet> and Map, etc.
22:35:16 <dons> heh :)
22:35:21 <dons> they're not mutable. :)
22:35:30 <rwbarton> "State"
22:35:33 <mmorrow> , run
22:35:35 <lunabot>  luna: Not in scope: `run'
22:35:35 <mmorrow> oop
22:35:43 <pumpkin> you could build up a bunch of STRefs to hand-built cons cells
22:35:51 <pumpkin> couldn't you?
22:36:09 <pumpkin> STList :D
22:36:11 <dons> sure
22:36:14 <CakeProphet> well the problem I was thinking of was how to maintain a list of connected users.
22:36:14 <mmorrow> , runST (xs <- newMU 1024; forM_ [0..1023] (\i -> writeMU xs i i); unsafeFreezeMU xs (lengthMU xs))
22:36:17 <lunabot>  luna: parse error on input `<-'
22:36:21 <mmorrow> , runST (do xs <- newMU 1024; forM_ [0..1023] (\i -> writeMU xs i i); unsafeFreezeMU xs (lengthMU xs))
22:36:23 <lunabot>  toU [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,...
22:36:37 <pumpkin> mmorrow: unsafeFreezeAllMU!
22:36:39 <Saizan> pumpkin: the lambda gods forbid that, beware!
22:36:42 <dolio> lunabot has uvector?
22:36:51 <mmorrow> dolio: oh yesh :)
22:36:57 * pumpkin sacrifices his future firstborn to the lambda gods
22:37:01 <dons> dolio: progress, man.
22:37:05 <dolio> :)
22:37:09 <dons> its a new era
22:37:17 <dons> ok. now i gotta apply some patches
22:37:25 <dolio> Does it have uvector-algorithms, though?
22:37:38 <mmorrow> it doesn't, but gimme 7 minutes
22:37:47 <dons> lunabot++
22:37:50 <pumpkin> does it have statistics-fusion? :D
22:38:52 <mmorrow> dolio: is there anything in uvector-algos that i need to hide that'd give unsafePerformIO indirectly?
22:39:17 <mmorrow> pumpkin: no, i can add that too. any other requests while i'm at it?
22:39:28 <dolio> There shouldn't be. I don't think I re-export ST or anything.
22:39:36 <mmorrow> cool
22:40:12 <dolio> Can you do qualified imports? Otherwise you're going to have to pick a single module.
22:40:29 <gwern> man, this business of copying the git backend and modifying it to use darcs is getting tedious >.<
22:41:59 <dons> go gwern!!
22:42:03 <dons> darcs-it?
22:42:22 <ddarius> git was originally a front-end of sorts for darcs, no?
22:42:39 <gwern> dons: not darcs-it, this is for the filestore backend
22:42:42 <mauke> o_O
22:42:44 <dons> ddarius: backend.
22:42:48 <dons> file system component of some sort
22:42:57 <gwern> I convinced sebastian and macfarlane that orchid and gitit should split out DVCS handlign into a lib
22:43:01 <dolio> Also, names clash with Data.List.
22:43:08 <Axman6> huh, how do i use record syntax to change a variable in a datatype again?
22:43:08 <gwern> @pl darcsIdsMatch _ r1 r2 = r1 == r2
22:43:09 <lambdabot> darcsIdsMatch = const (==)
22:43:19 <dons> gwern: isn't orchid already a lib?
22:43:26 <dons> but i was thinking the same. good work
22:43:27 <mauke> Axman6: v{ f = x }
22:43:34 <gwern> dons: its darcs backend isn't abstract
22:43:37 <dons> ah
22:44:02 <mmorrow> dolio: yeah, i was just noticing that. lunabot's using an older version of luna also. i need to hack it to use the current version so i can do qualified imports...
22:44:24 <mmorrow> which one should i pick for now?
22:44:39 <mmorrow> (i'll hide Data.List.sort)
22:44:46 <dolio> TriHeap has the most stuff in it.
22:44:49 <mmorrow> ok
22:45:27 <gwern> the abstract backend is kind of cool; macfarlane discovered he could auto-write the merge function if an implementation provides commit and mv iirc for the typeclass
22:47:04 <gwern> (ok... all the other functions involve either xml processing or gnarliness I haven't figured out yet so that's a night)
22:48:32 <dons> gwern: mm a   type class over dvcs backends?
22:51:06 <mmorrow> , runST (do xs <- newMU 1024; forM_ (reverse [0..1023]) (\i -> writeMU xs i i); sort xs; unsafeFreezeMU xs (lengthMU xs))
22:51:08 <lunabot>  toU [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,...
22:51:14 <mmorrow> , [$ty| sort |]
22:51:19 <lunabot>  forall a b . (Ord b, UA b) => (MUArr b a) -> ST a ()
22:51:19 <mmorrow> , [$ty| mean |]
22:51:24 <lunabot>  (UArr Double) -> Double
22:51:35 <dolio> , apply heapify $ toU [10,9,..1]
22:51:37 <lunabot>  luna: parse error on input `..'
22:51:41 <dolio> , apply heapify $ toU [10,9..1]
22:51:43 <lunabot>  luna: Not in scope: `apply'
22:51:56 <mmorrow> hmm, what is apply?
22:52:06 <dolio> It's from Immutable.
22:52:15 <dolio> Wrapper for applying things to UArrs.
22:53:08 <mmorrow> linking now..
22:53:16 <mmorrow> , apply heapify $ toU [10,9..1]
22:53:18 <lunabot>  luna: Couldn't match expected type `Data.Array.Vector.UArr.MUArr e s'
22:53:49 <dolio> Oh, right.
22:54:11 <dolio> , apply (\m -> heapify m 0 9) $ toU [10,9..1]
22:54:13 <lunabot>  luna: Couldn't match expected type `Data.Array.Vector.Algorithms.Common.C...
22:54:22 <mmorrow> did i import the wrong one?
22:54:25 <dolio> , apply (\m -> heapify compare m 0 9) $ toU [10,9..1]
22:54:27 <lunabot>  toU [10.0,9.0,8.0,7.0,6.0,5.0,4.0,3.0,2.0,1.0]
22:54:30 <mmorrow> ah
22:54:37 <dolio> , apply (\m -> heapify compare m 0 9) $ toU [1..10]
22:54:39 <lunabot>  toU [9.0,7.0,8.0,4.0,5.0,6.0,2.0,1.0,3.0,10.0]
22:54:47 <mmorrow> nice
22:54:53 <kniu> :t floor
22:54:54 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
22:54:56 <dolio> , apply (\m -> heapify compare m 0 10) $ toU [1..10]
22:54:58 <lunabot>  toU [10.0,7.0,9.0,4.0,5.0,6.0,2.0,8.0,1.0,3.0]
22:55:02 <dolio> There we go.
22:55:46 <dolio> , apply (flip partialSort 5) $ toU [10,9..1]
22:55:48 <lunabot>  toU [-1.2546783066051148e-39,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0]
22:55:59 <dolio> Hmm, also not good.
22:55:59 <pumpkin> so is newU on MUArrs the safe counterpart to unsafeFreezeMU?
22:56:04 <mmorrow> , mean (toU (fmap fromIntegral [0..1024]))
22:56:06 <lunabot>  512.0
22:56:29 <pumpkin> , var (toU (fmap fromIntegral [0..1024]))
22:56:31 <lunabot>  87637.5
22:56:32 <kmeyer> what is 'U'?
22:56:35 <kmeyer> unsafe?
22:56:40 <pumpkin> unboxed
22:56:43 <kmeyer> ah
22:56:53 <kmeyer> which means?
22:56:54 <mmorrow> , let xs = toU (fmap fromIntegral [0..1024]) in fmap ($ xs) [mean, var, stddev, harmonic, geometric]
22:56:56 <lunabot>  [512.0,87637.5,296.0363153398583,0.0,0.0]
22:57:21 <mmorrow> @src Int
22:57:21 <lambdabot> data Int = I# Int#
22:57:23 <dolio> Oh, wait, that might actually not be that bad.
22:57:38 <pumpkin> kmeyer: the type is represented directly in the datastructure, rather than having a small descriptive struct around it, I think
22:57:48 <dolio> , apply (\_ -> return ()) $ toU [1..10]
22:57:51 <lunabot>  toU [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
22:57:54 <kmeyer> ah
22:57:55 <dolio> Wait, yes it is, what am I saying?
22:57:59 <mmorrow> heh
22:58:11 <pumpkin> , let xs = toU (fmap fromIntegral [1..1024]) in fmap ($ xs) [mean, var, stddev, harmonic, geometric]
22:58:13 <lunabot>  [512.5,87466.66666666667,295.7476401709178,136.3664994255407,Infinity]
22:58:18 <mmorrow> -1.2546783066051148e-39 is less than epsilon
22:58:20 <dons> hey uvectors
22:58:21 <dons> cool
22:58:24 <pumpkin> an inifinite geometric mean!
23:00:06 <dolio> , apply (\m -> selectByBounds compare m 5 0 10) $ toU [10,9..1]
23:00:08 <lunabot>  toU [4.0,3.0,1.0,2.0,-1.1428738285028291e-39,5.0,6.0,7.0,8.0,9.0]
23:00:14 <dolio> , apply (\m -> selectByBounds compare m 5 0 9) $ toU [10,9..1]
23:00:16 <lunabot>  toU [5.0,4.0,2.0,3.0,1.0,6.0,7.0,8.0,9.0,10.0]
23:00:25 <dolio> Well, bug discovered.
23:00:30 <pumpkin> dolio: what does apply do again?
23:00:57 <dolio> pumpkin: All the algorithms work on MUArrs. apply lets you use them on UArrs.
23:00:57 <mmorrow> heh, teh bot are second to none for bug discovery
23:01:08 <pumpkin> dolio: oh I see
23:01:20 <dolio> It's a thin wrapper around newU, more or less.
23:01:36 <pumpkin> dolio: that's interesting, as MUArrs have very few functions defined for them, and UArrs have a lot more useful ones :)
23:01:41 <pumpkin> but I guess you have no writeU
23:02:16 <mmorrow> there's no unsafeThaw is there?
23:02:49 <pumpkin> copyMU?
23:03:02 <pumpkin> not really :P
23:03:03 <mmorrow> , [$ty| copyMU |]
23:03:08 <lunabot>  forall a b . UA b => (MUArr b a) -> Int -> (UArr b) -> ST a ()
23:03:17 <mmorrow> i'm thinking something like
23:03:21 <pumpkin> sounds O(n)
23:03:39 <mmorrow> unsafeThawU :: UArr a -> ST s (MUArr a s)
23:03:42 <ski_> (why `MUArr b a' ?)
23:04:01 <pumpkin> ski_: I think it copies the third parameter into the first, up to index of the second
23:04:04 <mmorrow> the second type is the s in ST s
23:04:14 <ski_> why not in the other order ?
23:04:26 <mmorrow> yeah, that confused me at first too
23:04:32 <ski_> that would abstract easier, i think
23:04:44 <pumpkin> assembly-style :P
23:04:47 <pumpkin> one of them, at least
23:04:49 <ski_> @index MUArr
23:04:49 <lambdabot> bzzt
23:04:56 <mmorrow> , src ''MUArr
23:04:59 <ski_> , 'MuArr
23:05:02 <lunabot>  data MUArr e a =
23:05:04 <lunabot>  luna: Not in scope: data constructor `MuArr'
23:05:06 <mmorrow> heh
23:05:08 <ski_> , 'MUArr
23:05:10 <lunabot>  luna: Not in scope: data constructor `MUArr'
23:05:14 <ski_> bah
23:05:19 <pumpkin> the double quote is for type
23:05:27 <mmorrow> i winder why the prettyprinter botched that one
23:05:40 <mmorrow> , $(lift =<< reify ''MUArr)
23:05:43 <lunabot>  TyConI (DataD [] Data.Array.Vector.UArr.MUArr [e_1627418673,a_1627418674]...
23:05:45 <pumpkin> mmorrow: maybe because it has an odd type?
23:05:48 <pumpkin> *kind?
23:05:53 <mmorrow> , ppDoc $(lift =<< reify ''MUArr)
23:05:56 <lunabot>  data MUArr e_0 a_1 =
23:06:16 <ski_> , ''MUArr
23:06:18 <lunabot>  Data.Array.Vector.UArr.MUArr
23:06:21 <ski_> i see
23:06:22 <mmorrow> , text $ (\(TyConI dec -> pretty dec) $(lift =<< reify ''MUArr)
23:06:23 <lunabot>  luna: Parse error in pattern
23:06:29 <mmorrow> , text $ (\(TyConI dec) -> pretty dec) $(lift =<< reify ''MUArr)
23:06:31 <lunabot>  DataD [] Data.Array.Vector.UArr.MUArr [e_1627418854, a_1627418855]
23:06:31 <lunabot>    []
23:06:31 <lunabot>    []
23:06:41 <mmorrow> heh, the reified Info is empty
23:06:49 <mmorrow> epic fail
23:06:54 <ski_> what's the `e_1627418854',`a_1627418855' stuff ?
23:07:03 <ski_> uninstantiated type variables
23:07:04 <mmorrow> those are just tyvars with uniqs
23:07:06 <ski_> ?
23:07:09 <pumpkin>   data MUArr e :: * -> *
23:07:20 <mmorrow> , [t|forall a. a|]
23:07:22 <lunabot>  ForallT [a_0] [] (VarT a_0)
23:07:49 <pumpkin>   newtype MUArr Bool s = MUABool (MBUArr s Bool)
23:07:49 <pumpkin> etc.
23:08:15 <mmorrow> wuhh
23:08:22 <pumpkin> ?
23:08:24 <mmorrow> is it using type families?
23:08:33 <pumpkin> I think so
23:08:37 <mmorrow> oh, i gotcha
23:08:43 <ski_> bah, again
23:09:17 * pumpkin soaks up more of the uvector source in the hope that he'll be able to contribute to it soon
23:09:32 <Taejo> @pl \x -> x*x< n
23:09:33 <lambdabot> (< n) . join (*)
23:10:02 <ski_> one should be able to abstract over arrays for `ST s',`IO',(`STM' ?), at least
23:10:32 <Taejo> why is Haskell telling me No instance for (Monad ((->) a)) ?
23:10:35 <Taejo> I mean GHCI
23:10:44 <pumpkin> Taejo: I think that's in Instances?
23:10:57 <pumpkin> Control.Monad.Instances, that is
23:11:02 <mmorrow> Control.Monad.Instances
23:11:03 <ski_> @instances-importing Control.Monad.Reader Monad
23:11:04 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
23:11:10 <ski_> @instances-importing Control.Monad.Instances Monad
23:11:10 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
23:11:19 <ski_> @instances Monad
23:11:20 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
23:11:23 <Taejo> I thought that was in the prelude
23:11:28 <ski_> hrm
23:11:41 <mmorrow> Taejo: no
23:11:50 <mmorrow> it just usually gets imported indirectly
23:12:03 <mmorrow> (i think via Control.Monad maybe)
23:13:06 <pumpkin> not in my Control.Monad
23:13:11 <pumpkin> I need to explicitly ask for instances
23:13:18 <BMeph> mmorrow, Taejo: You'll likely have to import Monad.Reader, or Instances; I don't think just Control.Monad will cut it.
23:13:21 <luqui> maybe you are using transformers?
23:13:28 <pumpkin> Control.Arrow gives it to me too
23:13:47 <mmorrow> BMeph: ah right, that's it. Monad.Reader ...
23:14:01 <mmorrow> yeah, a bunch of modules bring that instance into scope
23:16:27 <BMeph> I really hate that Control.Monad.Instances thing; it feels like such a kludge.
23:16:57 <ski_> possibly the real problem is that instances are always exported
23:18:23 <luqui> ski_, how so?
23:18:38 <luqui> there can only be one for each type anyway
23:18:45 <luqui> how could exporting hurt?
23:21:45 <BMeph> The Highlander Monad: There can be only One. ;)
23:22:10 <pumpkin> lol
23:22:50 <ski_> luqui : sometimes instances can be an implementation detail
23:22:52 <dolio> , apply (\m -> partialSortByBounds compare m 5 0 9) $ toU [1..10]
23:22:54 <lunabot>  toU [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
23:23:05 <dolio> , apply (\m -> partialSortByBounds compare m 5 0 9) $ toU [10,9..1]
23:23:07 <lunabot>  toU [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
23:24:44 <dolio> , apply (\m -> partialSortByBounds compare m 5 0 9) $ toU [10,1,9,2,8,3,7,4,6,5]
23:24:45 <lunabot>  toU [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
23:25:11 <luqui> ski_, but that implies that somebody else could come along and add a different instance for the same type, right?
23:25:37 <luqui> ski_, which can break invariants for eg. Data.Map and Data.Binary
23:25:43 <pumpkin> dolio: you made the uvector algorithms?
23:25:45 <ski_> luqui : not if the type is not exported
23:25:54 <luqui> ski_, well then the instance isn't exported either
23:26:00 <luqui> because the type isn't visible
23:26:00 <dolio> Yes.
23:26:05 <pumpkin> nice :)
23:26:06 <ski_> hm, you may be right, there
23:26:09 <pumpkin> it's handy
23:26:18 <luqui> if it were, nobody would know :-)
23:26:41 <dolio> Good to hear. :)
23:29:53 <ski_> luqui : could you elaborate on what you mean by "break invariants", there ?
23:30:38 <luqui> Map.insert :: (Ord k) => k -> a -> Map k a -> Map k a
23:31:00 <luqui> this assumes that the Ord dictionary is going to be the same between calls
23:31:29 <luqui> if Ord means two different things on two different inserts in the same Map, hell breaks loose
23:31:50 <pumpkin> at least you can ask Map to make sure things work!
23:31:56 <pumpkin> isn't there a method where you can ask it to check itself?
23:32:12 <luqui> pumpkin, well, yeah, but it needs an Ord dictionary to do that! :-)
23:32:16 <pumpkin> true :P
23:33:46 <pumpkin> alright, there is definitely something smelly
23:34:05 <pumpkin> dolio/dons: my pure-as-an-angel program using UArrs is outputting different things on different runs :P
23:34:22 <mmorrow> luqui: but the instance would be the same in any one compiled program, no?
23:34:34 <dolio> pumpkin: You're probably indexing beyond the end of the array.
23:35:02 <mmorrow> just like, the Typeable key for a type is never the same value across even different runs of a program
23:35:05 <luqui> mmorrow, that's what we're discussing
23:35:22 <pumpkin> dolio: I'm barely even using the array facilities though... I'm just fromU-ing, doing something to the list, and toUing back
23:35:49 <dolio> Huh.
23:35:50 <luqui> the ramifications of allowing multiple instances (eg. choosing not to export instances)
23:36:04 <pumpkin> this _is_ reading a datafile from disk, but that file isn't changing between iterations
23:36:08 <dolio> Thinking about it, I don't think indexing beyond the end of a UArr makes sense as an explanation, either.
23:36:12 <dolio> Since it's all turned into stream code.
23:36:39 <pumpkin> dolio: earlier today I was getting a segfault in similar code :P
23:36:48 <dolio> Well, maybe it does, then.
23:37:06 <mmorrow> luqui: i don't think Ord could mean two different things on insert to the same map though
23:37:14 <dolio> I'm a bit hazy on what all operations get rewritten.
23:37:23 <pumpkin> dons: still around? :)
23:37:45 <mmorrow> other than in cases where it already can mean two different things (e.g. you show a Map to a file, then a program compiled with a different instance of Ord for a type reads that Map in)
23:38:17 <Saizan__> mmorrow: yeah, but imagine if we could hide instances, like we hide functions
23:38:35 <luqui> mmorrow, how so?
23:38:35 <mmorrow> ok, i'm imagining it
23:38:43 <mmorrow> how so what?
23:38:46 <pumpkin> dolio: it still seems strange that they could get rewritten to read uninitialized memory (which I'm guessing is what's happening here?)
23:38:53 <luqui> mmorrow, how couldn't it?
23:39:04 <mmorrow> luqui: i don't see how it could :)
23:39:13 <luqui> mmorrow, just pass a Map of T between two different modules that have different instances for T
23:39:15 <mmorrow> ah, i see what you mean
23:39:20 <hydo> "simpleHTTP :: Request -> IO (Result Response)"  means, literally, "simpleHTTP takes a Request and sends back an "Either", the Left of which is the result, and the Right of which is the Response.  correct?
23:39:21 <dolio> pumpkin: Well, it's possible it gets turned back into a chunk of memory for reads.
23:39:40 <dolio> pumpkin: I just know that reads are slow, so if that's what it's doing, it's dumping a stream to a new piece of memory each time.
23:39:46 <dmwit> hydo: No, I don't think so.
23:39:48 <Saizan> hydo: no
23:39:48 <mmorrow> hmm, yeah. i think this is just a limitation of the class mechanism
23:39:52 <hydo> ugh
23:39:58 <dmwit> hydo: Unless "Result" is a type-synonym for an Either.
23:40:20 <dmwit> ?hoogle Result
23:40:20 <hydo> I'll make a paste...
23:40:20 <lambdabot> Test.QuickCheck data Result
23:40:20 <lambdabot> Test.QuickCheck Result :: Maybe Bool -> [String] -> [String] -> Result
23:40:20 <lambdabot> Data.Typeable funResultTy :: TypeRep -> TypeRep -> Maybe TypeRep
23:40:28 <pumpkin> dolio: boo :) I was rather surprised to see NaNs and e308s in my sliding mean on a bunch of relatively small non-NaN numbers :P
23:40:33 <pumpkin> ooh dmwit's back!
23:40:43 <dmwit> Hiya, pumpkin!
23:40:56 <pumpkin> welcome back :)
23:41:07 <dmwit> It feels like I never left. ;-)
23:41:09 <pumpkin> lol
23:41:31 <pumpkin> > greet "pumpkin"
23:41:32 <lambdabot>   hi pumpkin!
23:41:44 <mmorrow> i mean, we don't fret about sortBy.
23:42:19 <pumpkin> dolio: know if there's a trac for uvector?
23:42:20 <mmorrow> what if ever Data.Map function didn't rely on an Ord instance, but rather explicitly took a (a -> a -> Ordering)?
23:42:24 <mmorrow> *every
23:42:34 <dolio> I don't think so. You just bug dons about it.
23:42:44 <pumpkin> mmorrow: that would be even easier to mess up wouldn't it?
23:42:44 <mmorrow> then it would certainly be possible to use two diff orderings in the same map
23:42:50 <dmwit> mmorrow: What guarantees that later calls to the functions are sent the same comparison function? =/
23:42:58 <mmorrow> nothing! that's the point
23:43:06 <Saizan> no guarantees is bad :)
23:43:08 <dmwit> But then... the algorithms can be incorrect.
23:43:10 <pumpkin> you should rename it to UselessMap
23:43:13 <dmwit> That seems not so good.
23:43:20 <pumpkin> or MapThatSometimesLosesYourStuff
23:43:24 <mmorrow> we would see it for what it is. namely, something the programmer needs to take into account
23:43:25 <luqui> or every operation is O(n)
23:43:36 <mmorrow> well, we don't say this about sortBy
23:43:37 <Saizan> mmorrow: if you apply that to Storable instances you get segfaults, or random values in memory..
23:43:43 <opqdonut> well the comparison function could by passed in to a constructor
23:43:45 <opqdonut> or something
23:43:57 <luqui> opqdonut, can't do union that way though
23:43:59 <opqdonut> but making sure the function is the same for a union
23:44:01 <opqdonut> yeah
23:44:03 <pumpkin> mmorrow: you can't change the function in the middle of the sortBy though... but you could pass it a messed-up function if you wanted
23:44:09 <mmorrow> Saizan: sure
23:44:14 <pumpkin> but then you just get a list in a funky order
23:44:15 <Saizan> sortBy hasn't any internal consistency to ensure
23:44:25 <dmwit> Here's a question that isn't technically Haskell-specific.  What is the role of font size in scalable graphics (say, Cairo)?  Is there a difference between drawing a really small character and scaling it to really big and drawing a really big character?
23:44:29 <dons> we could set up a trac for it
23:44:29 <mmorrow> pumpkin: but you can sortBy a list, then pass that list to another function which judges sortedness differently
23:44:37 <dons> there's free tracs on code.haskell.org
23:44:37 <Saizan> you can always check if your list is sorted the way you want
23:44:44 <pumpkin> dons: got another bug-looking thing using it :/
23:44:53 <mmorrow> well, perhaps we should expose Map internals then :)
23:44:53 <dmwit> mmorrow: That's true.
23:44:54 <dons> mm
23:44:54 <pumpkin> UArr that is
23:45:00 <dons> you think its a bug in UArr?
23:45:01 <dmwit> mmorrow: But it doesn't seem as relevant.
23:45:13 <dmwit> mmorrow: Since at any given time, the entire list is sorted by some particular order.
23:45:26 <pumpkin> dons: two different runs of the same very pure program are giving me very different results (that look like it's interpreting uninitialized memory as floating-point values) :/
23:45:29 <mmorrow> but couldn't you say the same thing about a Map?
23:45:31 <Saizan> mmorrow: giving the programmer all the power to shoot himself is not exactly the spirit of haskell :)
23:45:35 <dmwit> mmorrow: Whereas if you allow passing in an ordering to a Map, different parts of the map could be constructed with different orderings! =/
23:45:41 <dons> pumpkin: ok
23:45:43 <luqui> see perl :-)
23:45:45 <mmorrow> Saizan: just playing devil's advocate :)
23:45:46 <pumpkin> dons: granted, the program does rely on an external data file, but I'm 99.999% sure it's not changing between runs
23:45:51 <dons> pumpkin: could be a bug though
23:46:01 <dons> let me set up traac..
23:46:21 <pumpkin> dons: even more puzzling is that the code that exhibits the bug is the simplest possible code... it just uses fromU, operates on the list, and then toU's it back
23:46:29 <luqui> A better way, if there were language support, would be to parameterize Map on the sorting function
23:46:38 <mmorrow> dmwit: ok, consider  MyList = [[a]], and mySortOneOfThem :: (a -> a -> Ordering) -> MyList a -> MyList a
23:46:40 <luqui> but we haven't sufficiently dependent types to do that
23:46:43 <pumpkin> luqui: function equality?
23:46:45 <dons> pumpkin: mm
23:46:48 <dons> well that's good
23:46:55 <luqui> pumpkin, yeah, at compile time
23:46:57 <dmwit> mmorrow: When's the last time you did something like that? ;-)
23:47:14 <luqui> pumpkin, presumably you would not have to go farther than reflexivity (same name -> same function)
23:47:17 <pumpkin> luqui: so you'd just parametrize it on the actual function used?
23:47:21 <pumpkin> ah ok
23:47:29 <dmwit> Any takers on scaling fonts vs. changing font size?
23:47:44 <pumpkin> dmwit: takers for what?
23:47:48 <mmorrow> dmwit: hehe
23:47:55 <pumpkin> oh
23:47:59 <pumpkin> inside joke? :o
23:48:03 <Saizan> well, "emptyMap :: (a -> a -> Ordering) -> Map a b" doesn't seem that bad
23:48:09 <Workybob> dmwit: there is no difference
23:48:16 <Saizan> the problem is if ghc is smart enough to compile that efficiently
23:48:16 <dmwit> Workybob: thanks
23:48:25 <Saizan> when the sorting function is known statically
23:48:27 <luqui> Saizan, except for there's no way to correctly union
23:48:30 <dmwit> pumpkin: No, no inside joke.
23:48:42 <dmwit> pumpkin: Just a slow reply by mmorrow. =)
23:48:49 <Saizan> luqui: right.
23:49:17 <mmorrow> hmm
23:49:28 <luqui> functors with region types!
23:49:31 <pumpkin> dmwit: ah :) there is a difference if you mean actually scaling the glyph shapes vs. asking a (sophisticated) font system for a larger point size
23:49:37 <Saizan> named instances?:)
23:49:37 <luqui> (o'caml, not haskell, functors)
23:49:49 <dmwit> pumpkin: Really?  That's what I was afraid of.
23:49:51 <Workybob> dmwit: the point size of a font unfortunately though doesn't bear any relation to the actual size of the text – i.e. you can't say "it's the distance from the bottom of the descendors to the top of the ascendors
23:49:54 <mmorrow> mlfunctors++
23:50:02 <Workybob> it's merely the height of the space in which the artist designing the font could work
23:50:06 <Workybob> so :(
23:50:07 <dmwit> pumpkin: Do you know off-hand what the difference is?
23:50:12 <dmwit> Right.
23:50:25 <pumpkin> dmwit: well, if the font designer wants to, he can provide special versions of his font for smaller/larger point sizes, with different geometries
23:50:28 <luqui> I guess first-class modules is pretty much it, then
23:50:42 <pumpkin> dmwit: which the font system will pick if they're available
23:50:44 <luqui> GMap myCompare (\Map -> -- rest of module)
23:50:53 <dmwit> pumpkin: oh, man
23:50:57 <mmorrow> luqui: first-class modules would be sweeeeet
23:51:02 <dons> pumpkin: http://trac.haskell.org/uvector/newticket
23:51:12 <pumpkin> you see things like that in garamond premier pro, which has variants for title sizes, captions, normal text, and so on
23:51:13 <dmwit> pumpkin: So for a sufficiently evil font-designer, different font sizes could actually *say different things*?
23:51:13 <luqui> oh no, you can do it without them
23:51:24 <luqui> add a region parameter to Map
23:51:28 <AxleLonghorn> quick newbie question: I have a function whose type I want to be: 'same3 :: Eq a => a -> a -> a -> Bool'. However using 'same3 a b c = ((a == b) == c)' gives me the error 'Inferred type is not general enough'. What am I doing wrong?
23:51:29 <mmorrow> hmm
23:51:36 <pumpkin> dmwit: the system doesn't prevent it :P all it knows about is glyphs, which don't have any meaning to it other than drawing instructions :)
23:51:41 <pumpkin> dons: thanks :)
23:51:47 <hydo> If anyone has a spare minute: http://www.friendpaste.com/5gc5XgxJfRJrGZtOec7BcH
23:51:50 <dmwit> AxleLonghorn: What's the type of (\a b -> a == b)?
23:52:00 <dmwit> AxleLonghorn: Given that, what type must your variable 'c' have in the above?
23:52:11 <luqui> runMap :: (k -> k -> Ordering) -> (forall s. MapDict s k -> b) -> b
23:52:49 <luqui> where data MapDict s k = MapDict { empty :: Map s k a, insert :: k -> a -> Map s k a -> Map s k a, ... }
23:53:00 <mmorrow> innnteresting
23:53:04 <pumpkin> dons: is there a filesize limit for attachments to bugs?
23:53:12 <Saizan> a pain to use, i think
23:53:13 <dons> no idea.
23:53:18 <luqui> Saizan, no doubt
23:53:25 <luqui> but maybe sugarable :-)
23:53:35 <dmwit> hydo: Could you tell us the output of ":i Response" and ":i Result" (in ghci)?
23:53:35 <mmorrow> definitely sugarable
23:53:41 <dolio> That's just a crude approximation of first-class modules.
23:53:45 * dolio waves his hands.
23:53:51 <luqui> dolio, I see what you're saying :-)
23:53:52 <pumpkin> dmwit: similarly, italics/bold/smallcaps/etc. can all be specified with completely different geometries if the font designer wants to...
23:53:53 <mmorrow> exactly!
23:54:02 <mmorrow> firstclassmodule++
23:54:06 <dmwit> pumpkin: nasty
23:54:09 <dmwit> pumpkin: But good to know.
23:54:10 <dmwit> Thanks.
23:54:21 <pumpkin> dmwit: makes the designers and typography geeks happy :)
23:54:33 <pumpkin> and the implementers very unhappy
23:54:35 <dmwit> yeah
23:54:38 <dmwit> double yeah
23:54:48 <Saizan> is there work on the interaction between first class modules, typeclasses, and extensible records?
23:55:21 <luqui> typeclasses--, firstclassmodules ftw  (if all can be sufficiently smudged)
23:55:24 <hydo> dmwit: reload the paste, it should show up.  I'm looking for Result stil.
23:55:46 <dolio> Coq has type classes that desugar to dependent records somehow.
23:56:22 <luqui> I remember the implementor of Coq typeclasses advocating against them
23:56:25 <dons> Saizan: and records? hmm.
23:56:34 <dons> yes, i imagine there was
23:56:34 <ski_> luqui : what does the `s' parameter to `MapDict s k' signify ?
23:56:41 <hydo> dmwit: ok, both are there now if you reload.
23:56:43 <dmwit> pumpkin: I envision a text-editor in which you can zoom in and out smoothly on the text.  I was hoping this would replace a font-size chooser... =/
23:56:43 <luqui> ski_, it's a region variable, like in ST
23:56:45 <AxleLonghorn> dmwit: thanks a lot, that was a dumb mistake
23:56:55 <luqui> ski_, keeps the Map from escaping that scope
23:57:06 <ski_> luqui : which map ?
23:57:08 <dmwit> hydo: Without the definition of fg, it's hard to tell what the discrepancy between your type and Hoogle's type are. ;-)
23:57:17 <luqui> ski_, any maps created using the MapDisct
23:57:20 <luqui> *MapDict
23:57:22 <ski_> oh
23:57:23 <ski_> ok
23:57:31 <hydo> dmwit: ah, yea, no kidding.  I'll fix that.
23:57:58 <pumpkin> dmwit: it would be nice :) you could just assume (correctly in all cases I've ever seen) that the size variations aren't significant and linearly interpolate between them as you move up and down the sizes, maybe?
23:57:58 <ski_> (here would be a good place for real existentials ..)
23:57:58 <luqui> region variables are pretty useful, I'm finding :-)
23:57:58 <luqui> unique names at compile time
23:58:13 <luqui> ski_, yeah, so you could get rid of that pesky CPS
23:58:43 * ski_ str some case where the CPS version wasn't expressibly for some reason
23:58:59 <hydo> dmwit: ok, much more info now.
23:59:10 <dmwit> pumpkin: I'm thinking now that it will just have to support font size and zoom factor orthogonally.
23:59:16 * dmwit subtracts one from the complexity budget
23:59:21 <pumpkin> :)
23:59:43 <pumpkin> dmwit: is this for a particular OS?
23:59:54 <hydo> oh...
23:59:55 <dmwit> hydo: Okay!
