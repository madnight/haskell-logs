00:00:21 <scook0> curry's not as useful as uncurry
00:00:30 <scook0> since most functions are curried by default
00:01:37 <Olathe> @src zipWith
00:01:37 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
00:01:38 <lambdabot> zipWith _ _      _      = []
00:02:53 <Olathe> @unpl curry
00:02:53 <lambdabot> curry
00:03:15 <quicksilver> :t (State.).curry
00:03:16 <lambdabot> forall a a1 b. ((a1, b) -> (a, b)) -> a1 -> State b a
00:03:24 <anthonymiller> no the langauge curry
00:03:37 <anthonymiller> ever hear of it?
00:04:07 <ski_> yes
00:04:37 <ski_> @type (curry ~> uncurry) flip id
00:04:38 <lambdabot> forall a b. (a, b) -> (b, a)
00:05:36 <nikn> no one has used curry?
00:05:51 <sjanssen> @type (~>)
00:05:52 <lambdabot> forall a b c1 c. (a -> b) -> (c1 -> c) -> (b -> c1) -> a -> c
00:13:38 <Adamant> nikn: someone here was talking about it a while ago
00:13:51 <Adamant> I want to say wli but not sure about that
00:23:46 <osfameron> any suggestions on http://rafb.net/p/q9Dv9m29.html ?
00:24:24 <osfameron> I'm still getting a type error on the last clause, but I'm sure those parameters should be the right type for Data.Map.insert
00:24:41 <osfameron> I say "sure".  Obviously I'm also *wrong* about that, or it would compile...
00:26:55 <sjanssen> osfameron: what is the type error?
00:27:42 <osfameron> sjanssen: Couldn't match expected type `Node'  against inferred type `Map String Node'
00:28:05 <sjanssen> ah
00:28:16 <sjanssen> it's complaining about your final result: M.insert s (dive n' ss) (unNode n)
00:28:19 <osfameron> it quotes the whole function 'dive', and the location of the error is signalled as the last "in" clause
00:28:22 <osfameron> yeah
00:28:35 <quicksilver> osfameron: missing Node constructor
00:28:37 <sjanssen> the inferred type is a Map (since insert operates on maps)
00:28:38 <osfameron> ah!
00:28:42 <osfameron> the dive call itself is OK
00:28:43 <quicksilver> osfameron: Node (M.insert blah blah...)
00:28:44 <osfameron> but not the result
00:28:45 <sjanssen> dive :: Node -> [String] -> Node
00:28:49 <osfameron> gah!
00:28:52 <osfameron> thanks
00:30:15 <osfameron> how do I read the type error to know exactly what it's complaining about?
00:30:45 <osfameron> Is the fact that it spat out *everything* what should alert me to the fact that it's the return value ?
00:32:36 <sjanssen> osfameron: yes
00:33:15 <osfameron> cool
00:33:30 <osfameron> what actually happened is that I saw a big type error, panicked, then flailed about wildly ;-)
00:33:40 <osfameron> I'm sure a more detached debugging attitude will come to me with time
00:34:08 <ski_> type error slicing would be cool
00:36:31 <sjanssen> I wonder if GHC could have special support for newtype type errors
00:36:55 <thom_> when defining a monad, is the "return :: a -> m a" just boilerplate? would you ever have a case where you would say something different?
00:37:23 <sjanssen> thom_: you generally don't include the type signature in the instance
00:37:24 <ski_> thom_ : `[]' vs. `ZipList'
00:37:39 <ski_> (sjanssen : though i wish one could do that)
00:38:11 <thom_> i was just looking at an example in a monad article... trying to understand
00:40:22 <ski_> thom_ : but yes, often, there's an "obvious" candidate ..
00:41:17 <quicksilver> sjanssen: I think that's a good idea
00:41:26 <quicksilver> (newtype type errors)
00:41:38 <sjanssen> quicksilver: yeah, and it shouldn't be hard at all
00:41:41 <thom_> so you don't HAVE to write one (there is a default I assume) but you MIGHT want to define a different one in some cases?
00:41:56 <sjanssen> (I assume that determining whether a type is a newtype of another is easy in GHC)
00:41:56 <unsafeForeignPtr> quicksilver: "Support your local newtype type errors"? ;)
00:41:57 <ski_> thom_ : there is no default
00:41:58 <quicksilver> sjanssen: at least one level deep. Nested newtypes are probably less common anyway.
00:42:15 <ski_> thom_ : how to write it depends on the type in question
00:42:20 <Axman6> thom_: how could there be a default?
00:42:27 <thom_> but you might want to write something other than return :: a -> m a?
00:42:49 <sjanssen> quicksilver: hmm, yes.  What about something like Endo (Sum Int) vs. Int
00:42:59 <sjanssen> erm Int -> Int
00:43:09 <Axman6> thom_: what do you mean?
00:43:23 <Axman6> return and >>= are the only things you need to define for monads
00:43:43 * ski_ would like restricted type synonyms in ghc ..
00:43:52 <quicksilver> sjanssen: sure, I just don't think nested newtypes are that cmmon. A heuristic type error for the one level case would be useful.
00:44:13 <sjanssen> quicksilver: agreed
00:44:14 <thom_> yes, my question specifically is are there cases where you would define something other than "return :: a -> m a" for return?
00:44:21 <sjanssen> ski_: restricted tyep synonyms?
00:44:43 <Axman6> thom_: well no, that is the type of return, it has to match that type. is that what you mean?
00:44:45 <quicksilver> thom_: "return :: a -> m a" isn't a defintion. It's just a signature (a declaration)
00:44:52 <sm> thom_: well, that's always the type signature - but that wouldn't be your definition
00:44:56 <quicksilver> thom_: you still need to provide a definition for it.
00:45:05 <BMeph> quicksilver: I'd appreciate it if most type errors weren't flagged as "No instance for Num <Insert your type of choice here>". :)
00:45:06 <quicksilver> thom_: e.g. (for lists) "return x = [x]"
00:45:14 <Axman6> @src [] return
00:45:14 <lambdabot> return x    = [x]
00:45:18 <Axman6> @src MAybe return
00:45:19 <lambdabot> Source not found. My mind is going. I can feel it.
00:45:21 <Axman6> @src Maybe return
00:45:22 <lambdabot> return              = Just
00:45:30 <Axman6> @src Either return
00:45:30 <lambdabot> return        = Right
00:45:39 <Axman6> @src State return
00:45:39 <lambdabot> Source not found. I feel much better now.
00:45:42 <Axman6> lame
00:45:47 <ski_> sjanssen : <http://cvs.haskell.org/Hugs/pages/users_guide/restricted-synonyms.html>
00:46:59 <BMeph> @hackage rmonad
00:47:00 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/rmonad
00:47:00 <thom_> ah, okay. thanks
00:47:12 <quicksilver> ski_: hmm interesting.
00:47:24 <quicksilver> that feels more like newtype than type
00:47:34 <ski_> yes
00:47:41 <sjanssen> it is
00:47:57 <ski_> even just allowing the type definition to be visible in the whole of a module would be useful
00:48:13 <sjanssen> it is newtype, but with the necessary unsafeCoerce#s in a certain block of code
00:48:18 * quicksilver nods
00:48:30 <quicksilver> in retrospect, 'type' was a really bad name for that keyword anyway.
00:49:05 <ski_> it is `type Foo = Bar' where the equality is known in a restricted scope, and `Foo' is abstract outside of that scope
00:49:17 <osfameron> rarr!  So now I have haskell version to compare with perl: http://rafb.net/p/hnauD263.html
00:49:20 <sjanssen> ski_: I'm amazed I've never heard about this before.  A useful extension in Hugs that isn't in GHC!
00:49:35 <ski_> (this is easily done in the ML module systems, btw, exporting a type synonym abstractly)
00:49:48 <osfameron> The haskell version is rather inelegant (which I didn't expect in this case) compared to the Perl.  Any suggestions for tightening it up?
00:50:32 <ski_> sjanssen : i've been mentioning it here, whenever i've been reminded of it :)
00:51:15 <ski_> quicksilver : why is `type' a bad name ?
00:51:43 <sjanssen> osfameron: firstly, mk_hash is the wrong name for that function in Haskell
00:52:20 <osfameron> sjanssen: yeah I guess... that's because I was translating from the Perl.  I'll rename, ta
00:53:10 <sjanssen> osfameron: hmm, I suspect this may be a useful application of Monoid!
00:53:30 <quicksilver> ski_: because it doesn't define new types.
00:53:51 <quicksilver> ski_: I think 'alias' or 'synonym' or 'typealias' would all be better keywords.
00:54:13 <ski_> quicksilver : so ? .. `foo x y = x*y - 10' doesn't define a "new" value `f', either
00:54:22 * quicksilver shrugs
00:54:32 <quicksilver> 100% agree
00:54:35 <quicksilver> but still don't agree
00:54:38 <quicksilver> if you see what I mean ;)
00:54:54 <ski_> i read `type Foo a = ..a..' as "we're defining a type (not a value) here, the definition is `Foo a = ..a..'"
00:54:55 <quicksilver> I see a lot of newbies trying to use 'type' instead of newtype or data because it has the most obvious name.
00:55:03 <osfameron> sjanssen: Monoid where?  Do you mean in the case that you add a node to a key that already exists (that's the kind of concatenation that I understand as being monoidal)
00:55:03 <quicksilver> yes. agreed.
00:55:20 <quicksilver> and 99% of the time when you define a type you want data or newtype.
00:55:26 <osfameron> quicksilver: 'type' is also taught earlier in many tutorials.  Meh, maybe not, probly at same time as 'data'.
00:55:31 <quicksilver> 'type' just defines a new name for an old type.
00:55:42 <osfameron> Though 'newtype' isn't (and in fact I still don't understand how to use it)
00:56:54 <ski_> if we ever get a way to specify module signatures, then i'd think it ok to use `type Foo a' as a specification that `Foo' is an exported type .. regardless of whether `Foo' is implemented as a synonym, or through `data' or `newtype'
00:57:27 <ski_> (and `type Foo a' is of course a lazier way to write `type Foo :: * -> *')
00:58:10 <agentzh> hi, folks, what's the smartest way of expanding [[1,2],[3,4]] to [1,2,3,4] ?
00:58:21 <sjanssen> @where hpaste2
00:58:21 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
00:58:37 <quicksilver> ski_: absolutely, that would be great.
00:58:40 <osfameron> ah!  I looked for hpaste this morning but it was broken
00:58:44 <osfameron> agentzh: Control.Monad.join maybe?
00:58:46 <ski_> osfameron : syntactically, `newtype' is used like `data', except you only get exactly one constructor, with exactly one argument
00:58:55 <agentzh> osfameron: thanks :)
00:58:56 <quicksilver> ski_: and, in my mind, a much better use of the keywork 'type' than the current one.
00:59:18 <ski_> quicksilver : i don't see any conflict between the uses ..
00:59:21 <quicksilver> agentzh: also 'concat', which is the same thing.
00:59:32 <sjanssen> osfameron: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1054#a1054
00:59:38 <agentzh> quicksilver: cool! many thanks :)
00:59:39 <quicksilver> ski_: the current use of type in haskell98 defines a synonym with no strength in the type system.
00:59:44 <ski_> (i forget whether one can use a strictness annotation in a `newtype' ..)
00:59:44 <osfameron> ah, "concat" sounds much better
01:00:03 <ski_> quicksilver : what does "no strength in the type system" mean ?
01:00:22 <quicksilver> ski_: "type Foo = Int; f :: Foo -> Foo;" I can still pass Ints to f.
01:00:44 <ski_> because the equality is in scope
01:00:54 <quicksilver> sure.
01:00:57 <ski_> so the type-system can use it, when checking types
01:01:13 <quicksilver> if that was an interesting statement about haskell98, then that would be fine.
01:01:21 <ski_> so, what we want is to be able to explicitly restrict the scope of the equality
01:01:22 <quicksilver> but it isnt', because we have no way to hide the equality
01:01:25 <quicksilver> agree.
01:01:30 <quicksilver> then it becomes a more useful thing.
01:01:33 <ski_> (i.e. to be able to abstractly export type synonyms)
01:01:44 <ski_> *nod*
01:01:48 <sjanssen> osfameron: the key observation here is that defining a 'merge' operation on directory trees is a bit more convenient that an 'insert' operation
01:01:54 <sjanssen> s/that an/than an
01:01:58 <osfameron> sjanssen: aha, I see that M.unionWith and M.singleton are useful (I still don't know the API very well)
01:02:18 <quicksilver> osfameron: the Data.Map api has a lot of useful stuff and some of it is slightly obscure.
01:02:26 <quicksilver> 'intersectionWith' is great, for example.
01:02:29 <sjanssen> osfameron: but you could also improve your code less invasively by use M.insertWith instead of lookup followed by insert
01:02:30 <ski_> (osfameron : semantically, there's a few differences between `newtype' and `data', though ..)
01:02:51 <osfameron> sjanssen: yeah, I had originally wanted to do something with merging, but I didn't know which functions to use, and was stuggling to get anything to compile at all first :-)
01:04:33 <osfameron> @src mconcat
01:04:33 <lambdabot> Source not found.
01:04:40 <osfameron> @src Data.Monoid.mconcat
01:04:40 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
01:04:43 <osfameron> meh
01:04:52 <ski_> @index mconcat
01:04:53 <lambdabot> Data.Monoid, Control.Monad.Writer, Control.Monad.RWS
01:05:03 <osfameron> presumably mconcat is defined in terms on mappend?
01:05:10 <sjanssen> yep
01:05:20 <sjanssen> foldr mappend mempty -- is the default defn.
01:05:22 <ski_>   mconcat = foldr mappend mempty  -- mayhaps ?
01:05:36 <osfameron> ah!  so you create bunch of single multilevel map paths
01:05:51 <osfameron> and then merge them all together with nodeFromPaths
01:06:08 <agentzh> hmm...i'm looking for a unique function, but hoogle does not return meaningful results :( is there such a builtin function?
01:06:18 <sjanssen> agentzh: Data.List.nub
01:06:25 <agentzh> sjanssen: great, thanks!
01:06:33 <osfameron> "mempty" always reminds me of "numpty" :-)
01:06:57 * sjanssen declares 2009 "Year of the Monoid"
01:07:34 <sjanssen> after that appendable debacle, I think Monoid will experience newfound respect and admiration
01:07:39 <osfameron> hmmm, that example is rather more work than my Perl version though :-)
01:07:58 <osfameron> (admittedly that relies on a filthy hack.  But based on very simple building blocks.)
01:07:58 <sjanssen> osfameron: in what way?  Computationally?
01:08:06 <osfameron> sjanssen: concepts required to understand
01:08:24 <osfameron> and number of APIs
01:08:45 <sjanssen> I don't think that is necessarily true.  The Perl looks utterly incomprehensible to me (I don't know Perl)
01:09:40 <osfameron> that's possible
01:09:45 <osfameron> quicksilver: any thoughts?
01:09:52 <sjanssen> osfameron: and we don't really have to use the Monoid class, we could simply rename 'mappend' to 'nodeUnion'
01:10:28 <agentzh> funny, Data.List.nub is much slower than my own implementation of unique :P
01:10:56 <osfameron> agentzh: if your version relies on Ord, it may well be much much faster
01:11:00 <sjanssen> agentzh: yeah, nub is O(n^2)
01:11:02 <Axman6> agentzh: what's your version look like?
01:11:44 * agentzh looks for hpaste
01:11:50 <ski_> @where hpaste2
01:11:51 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
01:11:52 <Axman6> @where hpaste2
01:11:53 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
01:11:56 <Axman6> bah
01:12:05 <ski_> :P
01:13:08 <agentzh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1055#a1055
01:13:57 <Axman6> you can remove a case there
01:14:13 <agentzh> Axman6: oh?
01:14:18 <Axman6> rmDup (x:y:ys) | ...; rmDup l = l
01:14:29 <agentzh> see :)
01:15:15 <agentzh> thanks
01:15:28 <Axman6> anything that doesn't match x:y:ys gets passed through right?
01:15:29 <sjanssen> rmDup (x:xs) = x : rmDup (dropWhile (== x) xs); rmDup [] = []
01:15:36 <agentzh> *nod*
01:15:46 <ski_>   rmDup (x:xs@(y:_)) = ..(rmDup xs)..
01:15:59 <agentzh> ah, much shorter :) i like it :)
01:16:01 <Axman6> also, your unique functions doesn't do the same as nab
01:16:18 <agentzh> not generic enough?
01:16:25 <agentzh> or just terribly wrong?
01:16:35 <Axman6> well, it sorts the data, which is not something you'll alwys want
01:17:03 <agentzh> aye
01:17:18 <Axman6> though you could fix that by adding a zipWith [0..] in there, and sorting on fst after the removal
01:17:24 <osfameron> uniqBy' eq = map last . groupBy eq   -- works well for sorted lists
01:17:41 * BMeph prefers 'toList . fromList' for his uniq function...
01:17:57 <Axman6> :t fromList
01:17:58 <lambdabot> Not in scope: `fromList'
01:18:03 <Axman6> Data.Map?
01:18:20 <BMeph> Axman6: Data.Set, of course. ;)
01:18:25 <Axman6> ah yes
01:18:39 <agentzh> so many ways to do it :D
01:19:07 <Axman6> > Data.Set.toList . Data.Set.fromList $ [1,2,3,2,3,5,1,3,1,3,5,7,9,7,5]
01:19:08 <lambdabot>   /tmp/742052031216598000:70:92: Not in scope: `Data.Set.toList'/tmp/74205203...
01:19:11 <Axman6> bah
01:19:19 <Axman6> :t S.toList
01:19:20 <lambdabot> forall a. S.Set a -> [a]
01:19:23 * BMeph reiterates: 'Data.Foldable.toList . Data.Set.fromList' for his uniq function...
01:19:36 <Axman6> > S.toList . S.fromList $ [1,2,3,2,3,5,1,3,1,3,5,7,9,7,5]
01:19:37 <lambdabot>   /tmp/5346260970581749958:70:92: Not in scope: `S.toList'/tmp/53462609705817...
01:19:46 <Axman6> ...
01:20:42 <sjanssen> osfameron: so is this going to be a blog post? :)
01:20:56 <BMeph> Oh, there's a Data.Set.toList now, even better. :)
01:20:58 <agentzh> toList . fromList is equally fast as my own version :)
01:21:03 * Axman6 needs to write something new on his blog...
01:21:14 <agentzh> 3 sec
01:21:19 * BMeph needs to write something old on his...
01:21:22 <agentzh> while nub takes nearly forever...
01:21:23 <impomatic> Axman6: link?
01:21:26 <osfameron> sjanssen: yeah, it's the sequel to the longest-path problem earlier this week :-)
01:21:34 <Axman6> http://axman6.homeip.net/blog/
01:21:45 * Axman6 also needs to stop writing hopeip instead of homeip
01:23:55 <sjanssen> osfameron: so do hashes with lists as the key automatically nest in Perl?
01:24:36 <osfameron> sjanssen: nope... in fact you can only have string keys in Perl :-(
01:24:39 <osfameron> (though there are hacks around that)
01:26:13 <sjanssen> so the Haskell code is doing more work also
01:26:41 <sjanssen> or am I missing something?
01:26:43 <osfameron> sjanssen: I just descend into the key to add a new node
01:27:25 <sjanssen> the code doesn't look recursive
01:27:28 <osfameron> sjanssen: I think they end up with the same structure, no?  The Perl one ends up with something like: { foo => { bar => {}, baz=> {} } (after /foo/bar/, /foo/baz)
01:27:46 <impomatic> Axman6: like the post about the pen! :-)
01:27:53 <Axman6> heh :)
01:27:54 <sjanssen> osfameron: ah, okay, I just don't understand the Perl code
01:27:56 <Axman6> it's an awesome pen!
01:28:03 <Axman6> so beautiful
01:28:06 <osfameron> sjanssen: it's using a reduce (a foldl1 effectively) to do the diving, and a for to loop through the paths
01:28:17 <BMeph> Axman6: Maybe it's "hope-notism"... ;)
01:28:42 * Axman6 writes about his STUArray issues
01:29:43 * BMeph should write about his STFUArray "issues"...
01:31:11 <impomatic> Hmmm... need to sign in to comment :-(
01:31:34 <sjanssen> osfameron: "for @_;" is like a postfix for loop?
01:31:57 <osfameron> sjanssen: yeah
01:32:09 <sjanssen> ah, I understand now
01:32:35 <osfameron> cool... to be fair that code was deliberately, er, "compact"
01:33:12 <BMeph> Someday, I'll have enough skill to post something about Haskell. For now, I just try now to abandon it. :)
01:33:20 <Workybob> where does InputT come from?
01:33:22 <sjanssen> in comparison, beautiful Haskell code has the same line count :)
01:34:34 <osfameron> denser lines :-)
01:34:50 <osfameron> (I could have put the reduce on one line, but chose to put more whitespace around it to show intent)
02:05:22 <augustss> Why isn't gtk2hs on hackage?
02:05:34 <dcoutts> augustss: it's not cabalised yet
02:05:46 <augustss> that's sad
02:05:50 <dcoutts> yes
02:05:58 <dcoutts> because it uses too many tricky pre-processors
02:06:07 <dcoutts> and Cabal is not very good at pre-processors yet
02:06:22 <dcoutts> especially those where there are inter-module dependencies
02:06:27 <dcoutts> like with .chs file
02:06:29 <augustss> I guess I'll have to use wx then
02:06:44 <dcoutts> augustss: it's not really cabalised either
02:06:47 <dcoutts> well, half
02:07:15 <dcoutts> it uses makefiles which do not fully support the cabal package spec
02:07:16 <augustss> I spotted it on hackage
02:07:39 <augustss> and things that are not on hackage do not exist ;)
02:07:48 <dcoutts> heh, I know
02:08:12 <augustss> How good does gtk2hs work on Windows?
02:08:21 <dcoutts> augustss: pretty well I think
02:08:33 <dcoutts> augustss: I think even ndm recommends it
02:08:46 <augustss> Does it have the Windows look&feel?
02:08:49 <dcoutts> though he complains slightly about how the occasional widget does not look perfect
02:08:53 <Axman6> ?users
02:08:53 <lambdabot> Maximum users seen in #haskell: 658, currently: 587 (89.2%), active: 9 (1.5%)
02:09:10 <augustss> I'll ask ndm then.
02:09:16 <dcoutts> augustss: try this: http://haskell.org/~duncan/gtk2hs/LSystemSetup.exe
02:09:25 <dcoutts> augustss: self-contained installer for a gtk2hs program
02:09:34 <dcoutts> no dependencies on ghc or gtk
02:09:42 <augustss> Oh, cool.
02:10:36 <augustss> dcoutts: what's the difference between that and the .exe on the download page?
02:11:07 <dcoutts> augustss: the download page has gtk2hs, this is an installer for a demo program that uses gtk2hs
02:11:18 <dcoutts> it's an L-System viewer
02:11:23 <augustss> Oh, ok
02:11:25 <dcoutts> using gtk and open gl
02:11:43 <dcoutts> to show what it looks like, you can see if you think it looks native enough
02:13:15 <augustss> Neat!
02:13:31 <dcoutts> I used that program for first year FP classes
02:13:44 <dcoutts> the students had to write the lsystem and drawing code
02:13:49 <dcoutts> we provided the gui module
02:14:10 <dcoutts> was much fun :-)
02:14:12 <augustss> I might give gtk2hs a try after all
02:14:32 <dcoutts> :-)
02:15:09 <augustss> I like the 3D display of the L-system
02:15:23 <dcoutts> augustss: try an > or < operator
02:15:35 <dcoutts> add a > to the beginning of one of the production rules
02:15:43 <Peaker> Did anyone here use HList and the rest of the crazy dependent type stuff from Oleg&pals?
02:16:10 <quicksilver> Peaker: I have always viewed HList as more of a proof-of-concept than a reusable library.
02:16:16 <augustss> dcoutts: the default has < and >
02:16:19 <quicksilver> (like much of oleg's papers)
02:16:23 <dcoutts> ah ok good
02:16:31 <dcoutts> augustss: my favourite is using three similar but slightly different rules in which case each production gets picked randomly each time
02:16:42 <quicksilver> Peaker: HAppS contains some HList-like-trickery
02:16:47 <augustss> quicksilver: there's no useable HList library
02:17:04 <Peaker> quicksilver: ah. I have a Grid widget that currently takes existential types for widgets - but then I can't get the information in the widget anymore
02:17:29 <augustss> dcoutts: but the display is very monochromatic.  can you have the L-system affect the colour?
02:17:33 <Peaker> quicksilver: I was thinking of taking an HList, but maybe there's another way
02:17:42 <quicksilver> Peaker: I think the intention is you read oleg's stuff and learn from the techniques rather than using the stuff outright.
02:17:51 <quicksilver> augustss: depends what 'useable' is supposed to me. http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HList
02:18:30 <dcoutts> augustss: yes, I think that version doesn't have the code for that. That was the first extension most of the students did, r/R for less more red etc.
02:18:30 <augustss> quicksilver: OK, last time I looked it wasn't very useable.
02:19:19 <Axman6> anyone know where i could find out about unboxed tuples?
02:19:26 <dcoutts> Axman6: ghc manual
02:19:53 <quicksilver> augustss: well, like I say, I don't really think it's designed to be useable ;) That's why I was advising Peaker not to use it.
02:20:36 <quicksilver> Peaker: that's what existentials do, after all! You can either not use an existential, or make sure the existential is packed with everything you need to extract from it.
02:20:45 <Axman6> dcoutts: yeah taking a look, trying to find the relevent docs
02:21:04 <dcoutts> Axman6: the main thing is the restrictions on their use
02:21:22 <dcoutts> Axman6: which is more or less the same for all unboxed types
02:21:26 <quicksilver> data Widget s = { wState :: s; wDraw :: s -> IO (); wClick :: s -> IO s; }
02:21:32 <augustss> quicksilver: I wish there were more reusable type level programming stuff on hackage
02:21:42 <Axman6> dcoutts: well i'd be planning on using Doubles, and that's about it
02:21:46 <quicksilver> data AnyWidget = forall s . AnyWidget (Widget s)
02:22:23 <sauf> hi, what does ".." mean in the line "tag (Leaf  ..)       = 1 " ? that can be read in
02:22:25 <sauf> http://apfelmus.nfshost.com/monoid-fingertree.html
02:22:28 <quicksilver> augustss: Yes.
02:22:36 <dcoutts> Axman6: often it's unnecessary to use unboxed types directly, if your functions are strict then ghc can often do the unboxing transform automatically
02:22:58 <dcoutts> Axman6: but it does mean checking the optimised core code
02:23:06 <quicksilver> sauf: it's meta-level stuff. It means 'I haven't filled this bit in'
02:23:07 <augustss> quicksilver: I also need a library for type level arithmetic, which I know Oleg has done too.
02:23:20 <Axman6> dcoutts: well, this is for the n-bodies shootout thing, so i'd rather just tell it what to do, and try and get the best speed i can
02:23:33 <quicksilver> augustss: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/type-level
02:23:33 <sauf> quicksilver: ok so I can try "_" ?
02:23:45 <quicksilver> sauf: No.
02:23:47 <fasta> augustss: Don't you think type level programming in Haskell is a hack?
02:23:47 <quicksilver> sauf: that isn't code.
02:23:48 <sauf> quicksilver: or "_ _" ?
02:23:51 <quicksilver> sauf: it's an explanation.
02:23:53 <augustss> Axman6: It's much nicer if you can do it in idiomatic Haskell with a few strictness annotations.
02:23:57 <quicksilver> sauf: it's not inteded that you type it in.
02:24:00 <dcoutts> Axman6: mm, but shootout code is also an advert to the world of how nice our code can be
02:24:11 <quicksilver> sauf: "we want the annotations to fulfill"
02:24:14 <augustss> fasta: very much a hack.  But I need it. :)
02:24:26 <Axman6> dcoutts: well, my STUArray version would be very nice, if it didn't segfault :\
02:24:29 <dcoutts> Axman6: sure, go for speed first but then check if you can make any of the functions use normal types and have ghc still convert
02:24:30 <quicksilver> sauf: he's trying to describe properties that he wants his program to fulfill. Not write code about them.
02:24:49 <fasta> augustss: wouldn't it be easier to compile to Haskell from a language more suitable for the task with your compiler fu?
02:25:43 <augustss> fasta: This is for my llvm package on hackage, I don't think using another language is appropriate.
02:25:44 <sauf> quicksilver: ok but it seems that only a few things are missing so the code works, no ?
02:26:05 <quicksilver> sauf: yes, that artciel contains lots of code
02:26:06 <augustss> fasta: besides, designing such a language is non-trivial
02:26:18 <quicksilver> sauf: it's just that particular line you are talking abotu is not code.
02:26:18 <fasta> augustss: Qi has already been designed
02:26:24 <quicksilver> sauf: (he probably should have used a different typeface)
02:26:24 <sauf> quicksilver: artciel ?
02:26:29 <quicksilver> article.
02:26:32 <Axman6> dcoutts: if you're interested, take a look at http://axman6.homeip.net/blog/2009/01/stuarray-woes.html and see if you can see anything really strange
02:26:36 <fasta> augustss: it seems to be the only language in which type-level programming is easy
02:26:38 <augustss> fasta: I don't like Qi
02:26:38 <sauf> quicksilver:ok !
02:26:59 <Peaker> quicksilver: one of my goals in this widget set is to not have (s -> IO ()) stuff in there
02:27:12 <fasta> augustss: what's wrong with Qi other than the tools and the bad error messages?
02:27:16 <Peaker> quicksilver: a widget's action handlers just return the new widget's state -- and that state may recursively contain other widgets' states
02:27:18 <augustss> fasta: it looks like dynamic type checking to me
02:27:28 <fasta> augustss: uh, what?
02:27:30 <Peaker> quicksilver: I really like this model - but it makes a hetero-widget-container difficult to implement
02:27:56 <Peaker> quicksilver: I think I might be the first to try this purely functional widget model (Rather than adapting an imperative widget model to a functional one via FRP or such)
02:28:20 <augustss> fasta: first, what is the semantic foundations that Qi is built on?  I've never seen an explanation of this/
02:28:27 <sauf> quicksilver: thanks!
02:28:34 <fasta> augustss: did you read the book?
02:28:38 <augustss> fasta: nope
02:28:43 <Peaker> @where hpaste2
02:28:43 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
02:28:55 <fasta> augustss: that might help. It comes more from the ATP corner.
02:28:58 <ski_> (Peaker : have you looked at Fudgets ?)
02:29:04 <Peaker> ski_: yeah
02:29:10 <augustss> fasta: does it prove the type system to be sound?
02:29:16 <quicksilver> Peaker: good, but that shouldn't change the general principle. Just get rid of the IO bits.
02:29:16 <Peaker> ski_: and Phooey
02:29:18 <fasta> augustss: it does.
02:29:29 <fasta> Qi is not a hack.
02:30:02 <augustss> fasta: perhaps I should take a second look.
02:30:04 <Peaker> quicksilver: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1056#a1057
02:30:33 <quicksilver> Peaker: it's like a red rag to a bull
02:30:41 <Peaker> quicksilver: heh why?
02:30:43 <augustss> fasta: I have designed a language with the right kind of type system too, but it needed more work.
02:30:47 <quicksilver> Peaker: why do people always wave typeclasses in my face before I'd had my first coffee of the day?
02:31:02 <Peaker> quicksilver: hehe, consider it a record of functions :-)
02:31:10 <fasta> Qi doesn't have type inference built-in, but that was done by design. I can understand why one wouldn't do it.
02:31:20 <Peaker> quicksilver: why would I want the same type to have multiple records of functions of how it is a widget? :-)
02:31:32 <fasta> But you can build a type-inferencer on top, if you want.
02:31:53 <Peaker> quicksilver: I haven't tried using records of functions much, I don't know how well it would work out
02:32:08 <quicksilver> Peaker: well it may not be relevant to this problem, anyway.
02:32:20 <quicksilver> Peaker: so, where do you hit the problem with composing widgets?
02:32:27 <augustss> fasta: Qi is powerful enough that type inference is impossible in general
02:32:35 <quicksilver> @users
02:32:35 <lambdabot> Maximum users seen in #haskell: 658, currently: 595 (90.4%), active: 16 (2.7%)
02:33:03 <fasta> augustss: right, but you can have something like Typed Scheme if you want.
02:33:07 <Peaker> quicksilver: My grid widget's state (The "s" part in Widget) contains a value of type  Map.Map (Int,Int) Item
02:33:20 <quicksilver> Peaker: OK.
02:33:21 <Peaker> quicksilver: and Item currently has an existential widget in there
02:33:24 <fasta> augustss: for most parts of the program type inference is possible.
02:33:34 <quicksilver> Peaker: so far, so good
02:33:38 <augustss> fasta: yeah, but that's not what I want.
02:33:52 <quicksilver> augustss: what do you want?
02:33:59 <quicksilver> I ask in the spirit of serious enquiry.
02:34:07 <augustss> World domination!
02:34:14 <fasta> A pony perhaps? (this is not a serious comment ;) )
02:34:19 <quicksilver> hmm. And you think type-level programming is going to give you that?
02:34:19 <Peaker> quicksilver: so my widget set can happily draw/handle events in the nested widgets. But if I want to create a grid and then extract stuff out of the state of the nested widgets in there -- for example, if I put a text edit in the grid and I want its cursor - I no longer have it because I have "casted up" the text edit to a general widget
02:34:26 <augustss> quicksilver: it's a start
02:34:42 <Peaker> quicksilver: maybe "extracting" stuff out of the nested widget state is the wrong approach anyhow, though, and I should put the model updating function itself inside the nested widgets
02:34:44 <quicksilver> fasta: http://www.chiark.greenend.org.uk/~sgtatham/putty/wishlist/moon-on-stick.html
02:35:05 <quicksilver> Peaker: well just because you put the text edit in the grid
02:35:11 <quicksilver> Peaker: doesn't mean you can't retain a reference to the text edit.
02:35:18 <fasta> quicksilver: :D
02:35:31 <quicksilver> Peaker: surely a sensible program keeps a reference to the widgets it needs to address directly?
02:35:31 <Peaker> quicksilver: but its purely functional - I can retain a reference to the immutable old state of the text edit - but the grid is the one returning the new text edit
02:36:10 <quicksilver> Peaker: well if you wish to pursue this path, of changing state in an immutable framework
02:36:17 <quicksilver> Peaker: you have two choices
02:36:26 <quicksilver> Peaker: (1) use zippers (2) reinvent zippers yourself, badly.
02:36:53 <Peaker> quicksilver: why?
02:37:02 <quicksilver> because that's what they are for.
02:37:19 <quicksilver> they are the solution to the problem "what is the way to model change of a value buried deep in an immutable structure"
02:37:21 <augustss> dcoutts: the gtk2hs .exe file is for ghc 6.8.3?
02:37:43 <quicksilver> the answer is "by formalising the notion of 'context around a value' - a zipper"
02:38:04 <quicksilver> Peaker: I don't *think* the existential is relevant to this problem.
02:38:15 <dcoutts> augustss: yes though there is a new pre-release for 6.10
02:38:15 <Peaker> quicksilver: well, perhaps they improve the performance of this operation?  I mean, my grid already creates a new grid for each contained-widget-change -- and that works (except it doesn't allow the grid user to get the "down-casted" new state change inside)
02:38:28 <quicksilver> even if you had "data Item = Button Button | EditField EditField"
02:38:33 <quicksilver> I belive you'd see the same issue
02:38:42 <quicksilver> so I think the existential is a red herring.
02:38:43 <augustss> dcoutts: 6.8.3 is fine since we're stuck with it :)
02:39:00 <Peaker> quicksilver: Yeah, runtime rather than compile-time differentiation between the widget types
02:39:05 <Peaker> quicksilver: is my problem there
02:39:07 <quicksilver> data Fish = forall c . Fish (Herring c)
02:39:16 <augustss> dcoutts: the documentation looks a bit unmaintained...
02:39:21 <dcoutts> augustss: :-) by the time 6.10.2 is out gtk2hs-0.10.0 will be out too
02:39:35 <dcoutts> augustss: which are you looking at? it should be current
02:39:50 <ski_> (/me wonders what "runtime rather than compile-time differentiation" means)
02:39:53 <Peaker> quicksilver: I thought zippers were meant to allow high-performance change of deeply-nested values -- and if you just "copy" the whole world down to that level that works too (if somewhat inefficiently)?
02:40:09 <augustss> dcoutts: build instructions: make sure ghc 6.6.1 is installed...
02:40:26 <augustss> dcoutts: sorry, install instructions
02:40:34 <quicksilver> Peaker: zippers do copy everything too, in a sense.
02:40:43 <dcoutts> augustss: oh, right, mm
02:40:48 <quicksilver> Peaker: it's just that well designed immutable structures manage to share even when you think you're copying them.
02:40:56 <quicksilver> Peaker: denotationally, they copy, you might say.
02:41:07 <quicksilver> Peaker: operationally they manage to share, if the structures support it.
02:41:20 <hackage> Uploaded to hackage: incremental-sat-solver 0.1.3
02:41:46 <Peaker> quicksilver: Yeah - and that's great, it'd be great to use zippers to increase sharing - but I am not sure that solves my problem (which is not about performance) - unless I misunderstand the utility of zippers here
02:41:46 <quicksilver> Peaker: I don't think of zippers as primarily a performance hack. (Although they are useful). Primarily they're an abstraction for the notions of "context in a complex structure" and "path to a value in a complex structure".
02:44:10 <quicksilver> Peaker: so, the problem is the following: I have "big structure S", which varies over time. Deep withi S somewhere is my text field. But how do I find the text field in 'later versions of S'
02:44:15 <quicksilver> Peaker: right?
02:45:03 <Peaker> quicksilver: Yeah, except its not "finding it" per se that is problematic, but the fact that when I "find it" in there, it has the type (forall w. Widget w => w) rather than TextEdit
02:46:28 <ski_> (rather `exists w. Widget *> w' ..)
02:47:38 <Peaker> yeah, sorry :)
02:47:55 <Peaker> I am a little confused about the positioning of forall/exists :)
02:47:58 <quicksilver> OK, so the way I see it, the problem is you have the wrong structure.
02:48:14 <quicksilver> you have the structure "Map (Int,Int) Item" as your primary means of access.
02:48:25 <quicksilver> that's discarded the type information of the Items.
02:48:29 <Peaker> quicksilver: right
02:48:37 <Peaker> quicksilver: that's why I thought about using an HList or such instead
02:48:49 <quicksilver> your primary structure should be data MyApplication = { myTextEdit :: TextEdit, .... }
02:48:58 <quicksilver> that is, the *primary* structure should be fully typed.
02:49:05 <quicksilver> so your app can always find the fields with the right type.
02:49:05 <Peaker> quicksilver: right
02:49:21 <quicksilver> then your combinators should apply the layout to this structure.
02:49:44 * ski_ wonders if there is problems where `HList' is the solution
02:49:50 <Peaker> quicksilver: I guess I ought to give this generic grid something to update the MyApplication type with the existential widgets
02:50:04 <quicksilver> Peaker: I would invert the control somewhat.
02:50:04 <Peaker> quicksilver: something that returns a new MyApplication somehow
02:50:14 <quicksilver> I'd associate the layout managers with the MyApplication
02:50:18 <quicksilver> but, yes
02:50:25 <quicksilver> your update/layout combinators should be polymorphic
02:50:32 <quicksilver> so they can work on the user's custom type
02:50:32 <Peaker> quicksilver: not sure how to revert the control if widgets are the ones that handle events and return new widget state
02:50:36 <quicksilver> (MyApplication)
02:50:52 <quicksilver> you give them the tools they need to get widget states out and put them back in
02:50:52 <Peaker> quicksilver: Yeah, all my homogenous widgets are now polymorphic to retain the contained widgets types
02:51:00 <augustss> fasta: so the web information about Qi just makes me think it's a hack.  The book might convince me otherwise, but since it looks like a hack I won't buy the book. :)
02:51:04 <quicksilver> (MyApplication -> EditText) -- get the widget out.
02:51:19 <quicksilver> (MyApplication -> EditText -> MyApplication) -- put the (new version) back in
02:51:33 <quicksilver> Or, as those two things are sometimes spelt, "Lens MyApplication EditText"
02:51:45 <ski_>   FRef MyApplication EditText  -- ?
02:51:48 <quicksilver> right.
02:51:50 <Peaker> quicksilver: Why Lens and not.. "Accessor" or such?
02:51:58 <quicksilver> whatever. I like the word Lens. ;)
02:51:58 <Peaker> FRef = Lens?
02:52:00 <quicksilver> yes.
02:52:01 <ski_> yes
02:52:02 <Peaker> Functional Reference?
02:52:05 <ski_> yes
02:52:06 <quicksilver> FRef = Lens = Data.Accessor
02:52:07 <Peaker> cool
02:52:17 <Peaker> quicksilver: thanks for the tips, you're better formulating my vague thoughts :)
02:52:22 <quicksilver> then your text event handler, simplified, might look like
02:52:36 <quicksilver> handleTextEvents :: Lens s TextEdit -> s -> s
02:52:43 <quicksilver> totally polymorphic in "s"
02:52:52 <quicksilver> as long as it knows how to "find" and "change" a TextEdit inside s
02:53:08 <quicksilver> so I can use instantiate 'MyApplication and you can use 'YourApplication'
02:54:21 <quicksilver> Make the user's own data structures the primary model (because they are fully typed by nature) and then hang your layout model/containment hierarchy/drawing model/event handlers around the edge
02:54:38 <quicksilver> rather than forcing the user into a UI-centric hiearchy.
02:54:39 <quicksilver> IMO.
02:55:24 <Peaker> yeah, I'm thinking about how to restructure that that way
02:55:58 <Peaker> one property I liked that seems to be lost is that the widget updates stuff by returning the whole new widget state and the user of a widget can "reject" that -- and it is very "transactional" -- the cursor and text of a textedit are updated or rejected together
02:56:40 <quicksilver> I think that's probably still possible
02:56:59 <quicksilver> you can return a TextEdit for them to consider and maybe reject, together with a MyApplication for them to use if they decide to accept.
02:57:12 <quicksilver> thanks to laziness, that MyApplication won't waste work if they choose not to use it.
02:57:31 * Peaker has to retire for a few minutes of thought :)
02:57:49 <quicksilver> at some point it would be good if you collected your ideas into a mailing list posting or a blog.
02:57:55 <quicksilver> I would be interested to see where you take this :)
02:58:23 <Peaker> sure, thanks for the help :)
02:59:13 <quicksilver> always a pleasure to think about interesting questions.
02:59:21 <fasta> augustss: you can read the book online.
02:59:24 <fasta> augustss: for the first version there is even a PDF
03:00:11 <elverkilde> Hi all, I'm trying to install the chp package, but it fails, saying package base is hidden? - base is in chp.cabal...
03:00:39 <Peaker> cabal list lens/fref finds nothing.. Well, it is trivial enough
03:01:09 <augustss> fasta: where?
03:01:52 <quicksilver> Peaker: Data.Accessor is on hackage.
03:02:16 <Peaker> hehe, funny that after you called it lens and fref and I asked why not "accessor" it ends up being "Data.Accessor" on hackage :-)
03:03:06 * quicksilver nods
03:03:11 <quicksilver> my version was on the old hpaste :(
03:03:12 <quicksilver> http://74.125.77.132/search?q=cache:He96Lw3Kf_8J:hpaste.org/7630+deus.lens+hpaste&hl=en&ct=clnk&cd=1&client=safari
03:03:17 <quicksilver> google cache
03:04:33 <Peaker> Hmm.. Data.Accessor seems to be hard-wired to use State.Lazy instead of MonadState instances?
03:04:47 <quicksilver> I would ignore the State stuff to start with
03:04:48 <Peaker> State.Lazy.StateT, that is
03:04:53 <Peaker> yeah, probably
03:04:53 <quicksilver> that's just a trivial convenience
03:05:00 <quicksilver> (and yes, I think that's a bad choice)
03:05:09 <quicksilver> I had a generic notion of 'MonadLens'
03:05:37 <Peaker> is that different from MonadState?
03:05:37 <quicksilver> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1058#a1058
03:05:41 <quicksilver> Yeah.
03:05:48 <quicksilver> you can be "lensed" into any monad
03:05:56 <quicksilver> e.g., an IORef is a lens into IO
03:06:02 <quicksilver> (because it has a getter and a setter)
03:06:29 <quicksilver> but if your code is parametric over 'MonadLens' then it will work just as well in IO over an IORef as it will work in a totally pure context with a pure lens.
03:06:41 <fasta> augustss: http://www.maht0x0r.net/library/computing/lisp/FPQi.pdf <- this is the first book, AFAIK.
03:06:56 <fasta> augustss: the same file name should be somewhere on this website
03:06:58 <augustss> fasta: thanks!
03:07:07 <Peaker> quicksilver: (Monad m, Functor m) => MonadLens m s -> Lens s v -> MonadLens m v     -- a bit weird to mix type classes with func records?
03:07:23 <augustss> fasta: it might be, but not on the obvious Documentation page
03:07:27 <fasta> augustss: this is the first book, I think QiII is more interesting.
03:07:37 <Peaker> quicksilver: though I guess I ought to understand that fully before I say stuff :)
03:10:44 <ski_>   newtype LensM m s v = LensM {unLensM :: s -> m (v,v -> s)}
03:10:51 <ski_> might be another dimension
03:11:15 <ski_> `m' could be e.g. `Maybe' .. but one can consider other alternatives, as well
03:11:37 * quicksilver nods
03:11:59 <Saizan_> how is that useful?
03:12:10 <ski_> Saizan_ : `head',`last', et.c.
03:12:20 <Peaker> composition of data accessors seems very much like composition of semantic editor combinators -- but probably allows extraction as well as modificaiton
03:12:32 <ski_> the selected slot might not exist in all values of the required type
03:12:33 <quicksilver> Peaker: it si very clsoely related, yes.
03:12:56 <quicksilver> and, working through peaker's questions backwards, no, it's not strange to mix type classes and higher-order functions.
03:12:59 <quicksilver> not at all.
03:13:11 <ski_> you could chain partial paths down a tree into longer partial paths
03:13:24 <quicksilver> it's vital that Lens is not a class. It's very common indeed to have two values of the same type in the same structure.
03:13:37 <ski_> (which seems to naturallt use that `Maybe' is a monad)
03:13:42 <quicksilver> similarly very common to have two IORefs of the same type.
03:14:05 <ski_> indeed
03:14:07 <Peaker> quicksilver: would you prefer if Functor, Applicative, Monad were all function records?  Would the type of <*> become: Applicative f -> f (a->b) -> f a -> f b   or something else?
03:14:22 <quicksilver> Peaker: no, I wouldn't.
03:14:30 <quicksilver> Peaker: the purpose of type classes is overloading.
03:14:40 <quicksilver> <*> is a good example of a useful overloaded function.
03:14:52 <quicksilver> (yes, you're right, that is what the type would become)
03:15:03 <ski_> (but a bad example of operator naming)
03:15:09 <quicksilver> yes ;)
03:15:12 <Peaker> quicksilver: But there are often multiple interesting Applicative instances
03:15:22 <quicksilver> Peaker: rarely, in my experience.
03:15:33 <Peaker> I think I'd prefer liftA2 to be the fundumental operation of applicatives, rather than <*>
03:15:39 <quicksilver> but certainly that's a disadvantage when it happens.
03:15:42 <ski_> in some cases, it could be nice to "mark" several slots in a structure .. i'm wondering how this would fit in
03:15:49 <Peaker> and then call them combinative or something :-)
03:16:12 <Peaker> SequentialFunctor or so :)
03:16:21 * ski_ would prefer `ap' to be the fundamental operation of applicative functors (aka idioms)
03:16:32 <Peaker> @type (liftA2 ($), (<*>))
03:16:33 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *) a1 b1. (Applicative f1, Applicative f) => (f (a -> b) -> f a -> f b, f1 (a1 -> b1) -> f1 a1 -> f1 b1)
03:16:54 <quicksilver> @type [liftA2 ($),(<*>)]
03:16:55 <lambdabot> forall a b (f :: * -> *). (Applicative f) => [f (a -> b) -> f a -> f b]
03:17:12 <Peaker> I don't think "Applicative functors" are really about application.. Application is just one of many ways to combine values, and Applicative Functors are about combining/sequencing values
03:17:24 <Peaker> quicksilver: ah, nice trick :-)
03:17:30 <ski_> "idioms" ftw !
03:17:40 <Peaker> ski_: "idiom" is too generic a word
03:17:54 <ski_> maybe
03:18:17 <Saizan_> what's the rationale behind idiom?
03:18:29 <ski_> Saizan_ : not sure .. ask McBride
03:18:59 <Saizan_> heh
03:19:15 * Saizan_ is tempted to introduce lenses in Cabal
03:19:22 <dcoutts_> mm?
03:19:48 <Saizan_> we've a lot of records floating around afterall
03:20:15 <Saizan_> and pinpointing which function uses which parts of those looks valuable
03:20:33 <ski_> (Peaker : at least, i think they're in some sense about distributing a functor over the implication)
03:21:06 <Saizan_> and it'd make easier to do things like inclusion, or transformation between one and the other i think
03:21:11 <Peaker> ski_: implication?
03:21:24 <ski_> function arrow
03:21:28 <ski_> it's the same thing
03:21:32 <Saizan_> but you'd have to pass those lenses around
03:21:44 <ski_> f (a -> b)  ->  (f a -> f b)
03:21:49 <quicksilver> Saizan_: lenses start to shine if you have to compose them
03:21:56 <quicksilver> Saizan_: do you have records-in-records?
03:21:57 <Saizan_> (which we kind of do for FieldDescr)
03:22:13 <augustss> fasta: it must be the second book that has the soundness proof
03:22:15 <Saizan_> quicksilver: semantically i think so
03:22:18 * ski_ imagines `everyLeaf :: FooLens (Tree a) a'
03:22:30 <Saizan_> quicksilver: but they are flattened right now for ease of use
03:22:42 * quicksilver nods
03:22:51 <fasta> augustss: I am fairly sure it was somewhere at the end of the book.
03:24:11 <ski_> ( .. of course that fits better with `modify' than with `get' .. cf. <http://www.haskell.org/haskellwiki/TV#IO>)
03:24:16 <augustss> fasta: ah, i've not read the appendicies
03:24:32 <Peaker> Data.Accessor seems pretty cool.. like a nicer way to do semantic editor combinators
03:24:47 <fasta> augustss: you bad boy!
03:27:29 <augustss> fasta: does Qi have assignment?
03:27:40 <fasta> augustss: yes
03:38:24 <ski_>   ask :: R.MonadReader r m => FR.FRef r a -> m a
03:38:31 <ski_>   local :: R.MonadReader r m => FR.FRef r a -> (a -> a) -> m b -> m b
03:47:11 <Peaker> quicksilver: I think its going on the right track, but its forcing me to have all of the mutable widget data be stored by the model and the model has to provide a Data.Accessor to it (which is great for accessibility, but bad for convenience, I need to actually put a widget's mutable data structure in the model for each widget I create)
03:47:30 <Peaker> quicksilver: btw, I made Widget a record :-)
03:51:08 <blueonyx> hi, is a lib like hgal out there for inductive graphs?
03:52:13 <Saizan_> fgl, maybe?
03:52:20 <Saizan_> ?hackage fgl
03:52:20 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fgl
03:52:34 <SamB_XP> what is hgal ?
03:53:15 <Eridius> does gtk2hs not work with GHC 6.10.1?
03:53:19 <blueonyx> a library for practical graph isomorphism check
03:53:30 <dcoutts_> Eridius: you need the latest pre-release version
03:53:50 <Eridius> ok, because the last news on the gtk2hs page is from 7 months ago
03:53:57 <blueonyx> 'Haskell Graph Automorphism Library'
03:54:09 <Eridius> unfortunately the OS X installation instructions are "use MacPorts" but that doesn't have the pre-release version
03:54:27 <dcoutts_> Eridius: yes, which is before the ghc-6.10 release. You can build it from source on mac.
03:54:35 <Eridius> yeah, just trying to find said pre-release version
03:55:06 <SamB_XP> dcoutts_: maybe you should update the news more often ?
03:55:20 <blueonyx> or is there any other lib for a practical graph isomorphism check on inductice graphs (those from fgl)?
03:55:35 <dcoutts_> SamB_XP: I'm sure the release manager will update it when he makes the release.
03:55:57 <SamB_XP> you could announce problems and prereleases, too!
03:56:04 <Eridius> dcoutts_: I can't even find a link to the source
03:56:17 <Eridius> ah, development tab
03:56:20 <Eridius> silly me looking at the SF project page
03:56:31 <SamB_XP> the what now ?
03:56:39 <Eridius> there's an SF project page where the official downloads are hosted
03:56:47 <SamB_XP> oh.
03:56:50 <SamB_XP> I forgot
03:56:52 <Eridius> do I just  grab the latest from the darcs repo or is there some tagged pre-release version?
03:57:13 <dcoutts_> Eridius: I think the pre-release is at http://code.haskell.org/~pgavin/gtk2hs-0.10.0/
03:57:21 <Eridius> ok
03:57:25 <dcoutts_> it's only been announced to the gtk2hs-users mailing list so far
03:57:43 * Eridius is trying to build the GTK UI For Yi to see how it differs from the neglected Cocoa UI
03:59:29 <Eridius> uh oh, autoreconf isn't working
03:59:33 <Eridius> configure.ac:102: error: possibly undefined macro: AC_MSG_ERROR
03:59:55 <Eridius> oh hey, it's using /usr/bin/autoreconf. I should probably use /opt/local/bin/autoreconf, it's much newer
04:00:03 <SamB_XP> which versions of autoconf do you have ?
04:00:24 <Eridius> well.. apparently it's not *that* much newer
04:00:36 <Eridius> 2.61 is the /usr/bin version, 2.62 is the /opt/local/bin
04:00:41 * SamB_XP has maybe a half dozen of them
04:00:55 <SamB_XP> or was that automake ?
04:00:57 <Eridius> hrm, 2.63 is available on MacPorts, I should upgrade
04:02:17 <Eridius> hrm, I think the /usr/bin version is still conflicting when I try and run /opt/local/bin/autoreconf
04:02:48 <Eridius> actually, what am I doing? this tarball already has the configure script generated. I'm following the from-darcs instructions blindly...
04:06:05 <SamB_XP> hehehe
04:07:50 <augustss> @seen dcoutts
04:07:50 <lambdabot> dcoutts is in #haskell-soc, #gentoo-haskell, #darcs, #ghc, #haskell-overflow and #haskell. I last heard dcoutts speak 1h 13m 30s ago.
04:07:58 <dcoutts_> augustss: hia
04:08:09 <ivanm> you hiding or something dcoutts_? :p
04:08:24 <dcoutts_> heh
04:08:35 <augustss> dcoutts_: if i run noughty.exe from a cygwin prompt nothing happens.  from cmd it works.  does that ring a bell?
04:09:05 <dcoutts_> augustss: no, sorry. Same with msys? I've never used cygwin.
04:09:34 <augustss> dcoutts_: i've not tried msys, i don't have it on my laptop
04:09:57 <dcoutts_> augustss: you mean it exists immediately?
04:10:00 <dcoutts_> exits
04:10:03 <augustss> dcoutts_: yes
04:10:43 <augustss> dcoutts_: the annoying thing is that programs seem to exit at once in cygwin if there's a missing dll
04:11:01 <alexeevg> dcoutts_: I've just submitted a patch with your suggestions about iterative foreign dependencies testing (as I understood them, of course) implemented. I did not touch error messages yet.
04:11:12 <dcoutts_> augustss: ah, could be not finding the gtk dlls, perhaps a different $PATH
04:11:29 <dcoutts_> alexeevg: great!
04:11:29 <augustss> dcoutts_: does the install change that PATH?
04:12:01 <dcoutts_> alexeevg: would you mind attaching the patch to the ticket? I can't actually get the attachments from the mailing list here.
04:12:17 <augustss> dcoutts_: it was the PATH.  sorry to bother you
04:12:29 <dcoutts_> augustss: sadly yes. On windows the dlls need to be in the same directory as the .exe or on the $PATH
04:12:48 <augustss> dcoutts_: another question, does gtk2hs work from ghci?
04:13:09 <dcoutts_> augustss: it has done in the past and will do again in future, but it's broken in that release on windows for some reason
04:13:24 <augustss> dcoutts_: :(
04:13:43 <dcoutts_> augustss: if you want to use ghc-6.8.2 then the older release works :-)
04:13:50 <alexeevg> dcoutts_: ok
04:14:01 <SamB_XP> dcoutts_: does it still shut down ghci after each run ?
04:14:01 <dcoutts_> augustss: I think there was some problem with mingw and ghci's linker
04:14:10 <augustss> dcoutts_: it's bad enough with 6.8.3
04:14:30 <dcoutts_> SamB_XP: I'm not sure what you mean
04:14:44 <Peaker> Data.Accessor depends on transformers, which seems to duplicate the mtl and also have Monad.Trans -- which should I use?
04:14:52 <SamB_XP> dcoutts: didn't it used to do that ?
04:15:02 <augustss> dcoutts_: any plans for the release that works with 6.10?
04:15:04 <Peaker> everyone depends on mtl, but Data.Accessor on transformers, weird
04:15:47 <SamB_XP> augustss: what do you mean, plans ?
04:15:49 <Peaker> ok, screw Data.Accessor I'll write the little subset I use myself :)
04:15:51 <dcoutts_> augustss: I'm not actually the maintainer anymore, the current release manager seems to be making good progress, I'd expect it within a week or so
04:16:22 <SamB_XP> dcoutts_: oh, why didn't you say that when I said "you" before?
04:16:24 <dcoutts_> well, I'm not an active maintainer anyway :-)
04:16:35 <alexeevg> dcoutts_: please see http://hackage.haskell.org/trac/hackage/attachment/ticket/262/_262-iterative-tests-for-foreign-dependencies.dpatch
04:16:41 <dcoutts_> alexeevg: thanks
04:17:29 <dcoutts_> SamB_XP: as far as I know exiting from mainGUI has never caused ghci to exit. It's also been possible to re-init and re-run gtk UIs in ghci (unlike with wx).
04:17:38 <Peaker> I'm experimenting with using descriptive, rather than one-letter type-variable names, and it seems pretty pleasant so far
04:17:50 <Peaker> I wonder why one-letter-names came to be
04:17:56 <SamB_XP> dcoutts: hmm. I could be getting confused with wx, perhaps ...
04:18:11 <SamB_XP> but I don't remember having used that much
04:18:21 <dcoutts_> SamB_XP: certainly wx does not allow re-initialisation, so is problematic with ghci
04:23:53 <Peaker> oh, implicit forall can be a good reason to use one-letter type-varnames :)
04:26:09 <Saizan_> ?hackage transformers
04:26:10 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/transformers
04:28:19 <Peaker> quicksilver: disadvantage of using records -- can't define functions nicely when creating the record
04:28:30 <Peaker> quicksilver: blah = Blah { blahField x y z = ... -- disallowed :-(
04:29:55 <SamB_XP> Peaker: well ... maybe that's related to the fact that the fields are seperated by commas ?
04:30:24 <Peaker> SamB_XP: well, why does that disallow args prior to the =?
04:30:52 <SamB_XP> well, it means the syntax isn't very similar to the syntax in let ...
04:31:04 <SamB_XP> or where, or instance
04:34:03 <pozic> I do or (replicate maxBound listIoActions), but I want or to begin evaluating while listIoActions is sstill in progress. I read something about the use of unsafeInterleaveIO, but doing map unsafeInterleaveIO over the list doesn't help.
04:34:20 <pozic> *still
04:37:13 <SamB_XP> you probably don't want to map it, anyway
04:37:16 <quicksilver> Peaker: yes, that's annoying
04:37:46 <SamB_XP> Peaker: I make no apology, mind. I guess I'd find that annoying too...
04:38:01 <quicksilver> Peaker: re your earlier point, yes the machinery takes a while to build up
04:38:13 <quicksilver> I believe that with good combinators you can reduce the machinery to something usable
04:38:25 <quicksilver> but I haven't followed this path all the way to see where you get.
04:38:28 <Peaker> yeah, I have to use:  blahField = blahFunc, ... }  blahFunc x y z = ...  ; and -Wall forces me to give type to blahFunc :-(
04:38:48 <quicksilver> I use blahField = \x y x ->
04:39:22 <Saizan_> pozic: do you use sequence on that list?
04:40:29 <pozic> Saizan_: because I have a list of actions and want to process them? I want to avoid writing sequenceButStopWhenTrue.
04:41:19 <Saizan_> lazySequence [] = return []; lazySequence (x:xs) = do v <- x; vs <- unsafeInterleaveIO (lazySequence xs); return (v:vs)
04:41:50 <pozic> Is there no way to make an existing function more lazy?
04:42:08 <Saizan_> pozic: i think you've misunderstood my question, (replicate maxBound listIoActions) :: [IO Something], how do you get to IO [Something] ?
04:42:32 <Saizan_> actually, that's [[IO Something]]
04:42:54 <pozic> Saizan_: oh, sorry, it's actually ioAction.
04:43:23 <Saizan_> ok, that's [IO Something] then, unless you also meant replicateM
04:43:51 <noteventime> I'm playing around a little with multidimensional arrays (for matrices). And I wonder if you think it would be feasible to write some kind of library for zipping/mapping over/folding these kinds of structures. Something like mult = (traverseRow <&> traverseCol) innerProduct.
04:43:53 <SamB_XP> why replicate maxBound ?
04:44:53 <noteventime> That's supposed to zip two arrays, my going over the rows of the first and the columns of the second, using the dot product
04:44:58 <pozic> Saizan_: it amounts to lazyReplicateM in total.
04:45:07 <noteventime> Not saying that approach in specific would work
04:45:16 <noteventime> But the idea of doing something like that
04:45:56 <Saizan_> pozic: lazyReplicateM n a = lazySequance (replicate n a)
04:47:03 <Saizan_> noteventime: what problems do you see?
04:47:34 <noteventime> Saizan_: You mean why I'd be interested in something like that?
04:48:00 <Saizan_> noteventime: no, what problems do you see in writing something like that
04:48:36 <noteventime> Saizan_: I don't see anything yet, but I'm not even sure that it's a reasonable thing to even see a problem in :)
04:50:10 <Saizan_> well, zip/map/etc.. make sense for lists, they can make sense for arrays too, either mutable or immutable
04:50:28 <noteventime> Saizan_: But what about multidimensional ones
04:50:39 <noteventime> Since I may, for example, be interested in mapping over columns
04:51:03 <noteventime> Or zipping two, two-dimensional arrays, one over rows and one over columns
04:52:53 <noteventime> Or summing each column of a grid
04:53:07 <Peaker> backslash lambda syntax doesn't get to use "where" clauses?
04:53:28 <Saizan_> no
04:53:30 <opqdonut> no
04:53:50 <Peaker> bummer
04:53:53 <Peaker> records suck :)
04:54:40 <Saizan_> noteventime: i't looks like you want some projection functions to extract the elements in particular ways, and specular ones to put them back
04:55:06 <noteventime> Saizan_: Yes, I guess that'd be it
04:55:13 <noteventime> Though I want it behind a nice interface
04:56:51 <noteventime> Allowing me to do something like what I wrote earlier
04:56:51 <Saizan_> that takes a bit of experimenting
04:56:51 <noteventime> Indeed
04:56:51 <noteventime> Just wanted to make sure I wasn't trying something insane
04:57:05 <Saizan_> Data.Array.IArray is quite lacking compared to the many HOFs present in Data.List
04:57:48 <byorgey> specular?
04:57:52 <Saizan_> not saying that the operations should be the same ones
04:58:15 <byorgey> @wn specular
04:58:27 <lambdabot> *** "specular" wn "WordNet (r) 2.0"
04:58:27 <lambdabot> specular
04:58:27 <lambdabot>      adj : capable of reflecting light like a mirror; "mirrorlike
04:58:27 <lambdabot>            surface of the lake"; "a specular metal" [syn: {mirrorlike}]
04:58:42 <Saizan_> byorgey: dual? e.g. construct a matrix from the columns, like you've a projection that enumerates the elements in columns
04:59:09 <byorgey> cool, I learned a new word =)
05:02:22 <noteventime> I find the question interesting for something like:  "zip (alternate (+) (*))", as well
05:02:22 <sioraiocht> bos, dcoutts: ping?
05:03:13 <noteventime> I realise that sentence didn't make any sense
05:04:18 <noteventime> I think the problem could be generalised. I wonder if it could be possible to write a library for doing both what I said earlier, and what I said in that last sentence
05:05:03 <vegai> mm. Statically typed database queries would be nice
05:05:15 <noteventime> Anyway, I have to go
05:05:20 <noteventime> I'll dwell on it for a while
05:05:21 <byorgey> noteventime: I think if you had a reasonable way to enumerate various pieces of a structure (rows/colums/lower-dimensional slices/what-have-you), then doing what you said in that last sentence wouldn't be any harder than anything else
05:05:55 <byorgey> noteventime: I think it's a neat idea
05:07:12 <Axman6> ok, i have a proposal. Something like a DPH, but with mutable arrays
05:08:03 <alexeevg> that doesn't sound like a proposal :)
05:08:17 <Axman6> ok, a want then :P
05:14:50 <dcoutts_> sioraiocht: pong
05:15:53 <sioraiocht> dcoutts_: I have been playing with the QC tests that bos hooked up for compilation
05:15:55 <sioraiocht> and so far they all pass
05:16:04 <sioraiocht> I dunno if I'm running it wrong or what...
05:16:04 <sioraiocht> heh
05:16:35 <dcoutts_> sioraiocht: ok, is that with the latest darcs version?
05:17:51 <Axman6> dons: you around? i've been playing a bit more with that n-bodies thing, and i have a version using STUArray s Int Double arrays, and it works fine. about as fast as my STArray version, and it doesn't segfault
05:20:25 <Peaker> quicksilver: I'm beginning to see why you prefer function records :-)
05:21:00 <Axman6> @seen dons
05:21:01 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 1d 9h 4m 3s ago.
05:21:11 <Axman6> ah, probably not around
05:22:46 <Peaker> #concatenative?
05:23:01 <ivanm> Axman6: dons is on a work trip this week IIRC
05:23:12 <Axman6> ah dng
05:24:15 <Peaker> quicksilver: I'm not sure yet, as I'm refactoring/rewriting everything to the new model (widget is a record parameterized on a model) but it seems it eliminated the need for existentials altogether :-)
05:24:53 <Axman6> dang too
05:25:13 <Axman6> seems dons is the only one who seems to know anything about this stuff :(
05:25:43 <Raynes> Dons must be a factorbitch
05:29:27 <Workybob> @where hpastetwo
05:29:28 <lambdabot> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/new
05:29:39 <ertai> Is there a way to retain a 'class instance' to be exported from a module ?
05:29:53 <Saizan_> no
05:29:57 <Axman6> has anyone else done any work with unboxed arrays?
05:30:31 <lilac> ertai: put it in a different module
05:31:02 <lilac> ertai: but why would you want to?
05:32:06 <sioraiocht> dcoutts_: yep!
05:33:24 <ertai> lilac: it's just a matter of checking some properties of the type checker
05:33:51 <ertai> I want to export a function that sees this instance without exporting the instance
05:35:45 <Thunder> ertai: Use a submodule with the class and instance declarations
05:36:49 <alexeevg> smth like Control.Monad.Instances
05:37:20 <dcoutts_> sioraiocht: ok, so I should try it too
05:38:10 <sioraiocht> dcoutts_: i noticed that under "tests" only one test was set to run, so I added the others
05:40:52 <dcoutts_> sioraiocht: ok good
05:41:20 <hackage> Uploaded to hackage: emgm 0.2
05:41:20 <hackage> Uploaded to hackage: explicit-exception 0.1.2
05:41:20 <hackage> Uploaded to hackage: leksah 0.4.0.3
05:43:19 <quicksilver> Peaker: good.
05:43:34 <quicksilver> Peaker: existentials are a great feature but they should only be needed when necessary.
05:43:46 <quicksilver> Peaker: polymorphic functions are to be preferred.
05:48:24 <Axman6> so, anyone worked with mutable arrays?
05:49:53 <sioraiocht> Axman6: yes
05:53:55 <Axman6> sioraiocht: unboxed ones?
05:54:33 <sioraiocht> Axman6: yep
05:56:24 <Axman6> ah, excellent. because i have a rather annoying problem, i'm getting a segfault with a program i've been writing (an ST version of the shootout n-bodies)
05:56:33 <Axman6> http://axman6.homeip.net/blog/2009/01/stuarray-woes.html has the code
05:57:42 <Saizan_> 3could it be related to the alignment bugs augustss was working on recently?
05:58:05 <Axman6> possibly, i don't know what they are :)
05:58:18 <augustss> The alignment only matters if you use SSE instructions
05:58:58 <lilac> Axman6: I got as far as 'search for "unsafe"' :-D
05:58:58 <sioraiocht> hrm, i've never used STRefs with unboxed arrays
05:59:25 <augustss> Axman6: have you reported the bug?
05:59:27 <Saizan_> (and why do i see grey lines at random places in your code?)
05:59:43 <Workybob> it's not random – it's in comments
05:59:47 <Axman6> no, i was hoping to track it down first. i'll write some tests
05:59:49 <Workybob> or rather – after comments
06:00:03 <Workybob> but it renders rather funnily – at least in safari
06:00:05 <sioraiocht> Axman6: I would also try and not inline your unsafe functions
06:00:07 <sioraiocht> and see if that changes anything
06:00:21 <sioraiocht> because GHC will inline things like that without seeing if it changes the semantics of the code at all
06:00:28 <Axman6> sioraiocht: yeah, that code is all dons'. i'll see what happens
06:00:32 <sioraiocht> kk
06:00:44 <augustss> Axman6: does it work with STArray instead of STUArray?
06:00:49 <Axman6> yep
06:01:04 <quicksilver> it looks like it's supposed to be a grey underline or gray strikethru on the comments
06:01:05 <augustss> sounds like a real bug then
06:01:10 <quicksilver> but it's dropped down a row.
06:01:25 <quicksilver> augustss: note that Axman6 has defined his own MArray instance
06:01:36 <quicksilver> (using the underlying primitives)
06:01:39 <Axman6> quicksilver: well, dons did
06:01:43 <quicksilver> a bug in that instance could be a segfault.
06:01:44 <quicksilver> yeah.
06:02:00 <augustss> quicksilver: oi vey!
06:02:18 <Axman6> ok, taking out all the INLINE pragmas doesn't seem to help
06:02:43 <Axman6> well, i assume deleting the # i {-# should be enough for ghc to not treat them as pragmas?
06:03:11 <chessguy_work> 'morning
06:03:16 <quicksilver> I think what you're doing relies on the precise way GHC respects UNPACK pragmas
06:03:41 <Axman6> could be, i'll try getting rid of the unpack pragms
06:03:42 <augustss> Axman6: does the instance have to be so ugly to be efficient?
06:04:20 <Axman6> i don't know, like i said, dons wrote it, and ii'm assuming he know what he's doing
06:04:47 <quicksilver> actually, maybe not.
06:04:58 <quicksilver> you're not storing a 'Body' in the array, it's not like a storable instance.
06:05:07 <augustss> dons knows what to write to make it efficient
06:05:26 <Axman6> quicksilver: yeah.
06:05:34 * quicksilver isn't really sure.
06:05:48 <Axman6> i worked with that idea, and tried rewriting the whole thing using a Double STUArray, and that works fine
06:06:00 <Axman6> and realised there's some optimisations to be made there too
06:06:52 <augustss> btw, that web page triggers some Safari bug
06:07:23 <alexeevg> hehe, unsafe means unsafe
06:07:48 <alexeevg> there should be a warning like "the code below may damage your browser"
06:07:59 <Axman6> augustss: the comment underlines?
06:08:30 <lilac> Warning, reading code containing unsafePerformIO may poke sticks into your eyes.
06:08:35 <Axman6> that's not a bug, it's HsColour's classes conflicting with Movable Type's
06:09:36 <augustss> Axman6: the underlines is one sign of it.  if I search in the page the highlighting of the found text is also off
06:10:11 <Axman6> yeah i've noticed that a lot lately. probably worth reporting i guess
06:10:45 <Axman6> hmm, seems you're right
06:11:45 <dormoose> What's the usual style of function type sigs? Are they usually written or not?
06:12:13 <dormoose> Up to now, I've used them absolutely everywhere. But they bloat the code.
06:12:19 <MarcWeber> dormoose: This depends.
06:12:37 <Raevel> dormoose: i always use them at the top level, and sometimes for helpers
06:12:49 <MarcWeber> It matters when you expose the function. Then you can restrict the type of the function and I guess it will be optimized better (not very sure about this)
06:13:13 <Twey> I don't write them initially
06:13:21 <Raevel> i start by writing them :-)
06:13:27 <Twey> And never for helper functions unless the compiler needs a hand
06:13:50 <Twey> But they are useful documentation...
06:13:59 <daf> I do both
06:14:20 <daf> (start without, add as necessary, and start with, and remove later)
06:14:28 <MarcWeber> dormoose: Its a good style to write them for exposed function for reference to to give hints to the compiler. And add them to the other functions if you feel they help you finding type check errors
06:14:33 <daf> the former when the compiler has problems, the latter when I have problems
06:15:05 <augustss> dormoose: I too typically use them on top level functions, but not otherwise
06:15:57 <dormoose> OK, thanks for the input. Being a dumbn00b, I think I'll continue writing them for every function. It also helps me design stuff (a recent example was [String] -> [[String]] and back, which caused some confusion).
06:17:50 <Raevel> dormoose: i also use -Wall when compiling so i see if i missed any
06:18:09 <augustss> dormoose: but also beware that writing a type signature might restrict a function when it doesn't have to.  Maybe it has a more general type than you thing.  So it might be a good idea to check the deduce type before adding a signature
06:19:15 <dormoose> Raevel: Hmm! Didn't know about that one.
06:19:38 <dormoose> augustss: How? With ghci?
06:19:53 <Raevel> for example, yes
06:19:59 <augustss> dormoose: leave out the signature and compile with -Wall
06:20:08 <augustss> dormoose: or leave it out and ask in ghci
06:20:10 <Raevel> you can load your module into ghci and do :browse
06:20:28 <Saizan_> i usually write them without and then use C-u C-c C-t in emacs to add the ones inferred by ghci
06:20:46 <Axman6> augustss, quicksilver, sioraiocht, i'm slowly tracking down exactly where the bug occurs (using lots of unsafeIOToST (putStrLn ...))
06:20:50 <Raevel> oh right, i was wondering what that command was the other day
06:21:03 <Raevel> *creates a to-memorize.txt*
06:21:03 <sm> dormoose: writing them will often get you far better error messages
06:21:56 <quicksilver> but on the down side, writing them makes code refactorisation harder.
06:22:06 <quicksilver> If you change your types you have lots of sigs to edit.
06:22:15 <sm> yup
06:22:22 <augustss> quicksilver: type synonyms can help
06:22:28 <quicksilver> yes.
06:22:35 <quicksilver> (about the only thing they're good for, IMO)
06:22:36 <augustss> but I wish there were context synonyms
06:22:45 <quicksilver> agreed.
06:23:00 <quicksilver> this is related to contexts not being a 'firstclass' part of the haskell type system.
06:23:02 <augustss> or context wildcards
06:23:04 <Axman6> urgh... putting in these debug messages made it stop segfaulting
06:23:06 <quicksilver> of course there are good reasons for it.
06:23:35 <Axman6> but i'm getting incorrect results (NaNs)
06:23:36 <augustss> foo :: (_) => a -> [a] -> a
06:23:55 <augustss> meaning, I know there's some context, but I can't be bothered to write it out
06:24:19 <augustss> Axman6: that's typical
06:24:32 <quicksilver> augustss: did you look at matthew sackman's session types at all?
06:24:34 <Axman6> augustss: of the segfault error?
06:24:40 <augustss> quicksilver: I did
06:25:19 <augustss> quicksilver: It needed context abstraction like nothing I've seen before
06:25:27 <quicksilver> augustss: yes, that's the point I was going to make :)
06:25:39 <augustss> Axman6: typical of debugging.  the bug goes away
06:25:46 <Axman6> heh, yes
06:26:01 <Axman6> well, i can pinpoint where it does away :)
06:26:21 <augustss> quicksilver: I don't see why we counlt have context synonyms.  Pure syntactic expansion
06:26:28 <Axman6> in the second forM_ in advance
06:26:29 <dormoose> Gahh. I've broken something with my cabal packages )=
06:26:29 <dormoose>     Could not find module `Control.Monad.Trans':
06:26:30 <dormoose>       it was found in multiple packages: transformers-0.1.1.0 mtl-1.1.0.2
06:26:35 <augustss> context Foo a = (Eq a, Show a)
06:26:50 <dormoose> -- How do I uninstall things with cabal?
06:27:03 <dcoutts_> dormoose: ghc-pkg unregister --user transformers-0.1.1.0
06:27:37 <dcoutts_> dormoose: the problem is that both packages provide that module, because transformers is a candidate replacement for mtl
06:27:50 <dcoutts_> dormoose: alternatively you can hide one of them
06:27:50 <dormoose> dcoutts_: Great, thanks
06:27:59 <dcoutts_> dormoose: ghc-pkg hide --user transformers-0.1.1.0
06:28:06 <dormoose> Nah, I just removed it.
06:28:23 <Axman6> augustss: so, do you have any thoughts on this problem? seem like a bug in ghc or the code?
06:29:00 <augustss> augustss: I have no opinion without debugging it myself
06:29:14 <Axman6> fair enough
06:29:45 <augustss> Axman6: can you cut down the code and get the segfault?
06:30:43 <Axman6> i'll see
06:30:52 <quicksilver> augustss: they would do unexpected things in contravariant positions.
06:31:02 <quicksilver> augustss: or not unexpected, depending on your expectation ;)
06:31:09 <quicksilver> augustss: at least, it might be confusing sometimes.
06:32:02 <augustss> quicksilver: what would do unexpected things in contravariant positions?
06:33:13 <quicksilver> augustss: if "type Foo = (Blah x) => Bar x"
06:33:23 <quicksilver> then 'Foo' doesn't quite behave like a type
06:33:34 <quicksilver> considering "Foo -> Int" and "Int -> Foo"
06:33:43 <augustss> quicksilver: But I was suggesting no such thing :)
06:33:45 <quicksilver> and who gets to supply the context in each case.
06:33:58 <quicksilver> oh you just wanted a synonym inside the context?
06:34:03 <Axman6> wouldn't you normally use data Blah x => Foo x = Bar x?
06:34:08 <augustss> quicksilver: I want 'context Foo a = (Eq a, Show a)'
06:34:14 <quicksilver> Axman6: that's something different.
06:34:26 <quicksilver> augustss: right. Yes, that would just be handy.
06:34:30 <augustss> quicksilver: and then 'blah :: (Foo a) => ...'
06:34:34 <quicksilver> you can abuse superclasses for this.
06:34:38 <quicksilver> but it's not entirely convenient
06:34:42 <lilac> quicksilver: you can have contexts in a 'type'?
06:34:42 * Axman6 senses territory he won't understand and swims back to safety
06:34:47 <augustss> quicksilver: not convenient at all
06:34:48 <quicksilver> lilac: no, you can't.
06:35:00 <quicksilver> lilac: and that example show's why not. Sort of.
06:35:08 <Axman6> augustss: the fact these arrays aren't nice sized wouldn't effect anything would they?
06:35:25 <Axman6> s/they/it
06:35:46 <augustss> Axman6: as long as they are big enough.
06:36:01 <Axman6> 23ll, they're 35 Doubles long
06:36:05 <Axman6> well*
06:36:22 <Axman6> that's a first, never had a typo like that
06:36:26 <augustss> Axman6: so you dont index off the end, I mean
06:36:58 <Axman6> well i shouldn't
06:36:59 <lilac> quicksilver: i would thing 'type Foo = (Blah x) => Bar x' would mean 'type Foo = Bar (exists x. Blah x => x)'. That seems OK to me.
06:37:04 <lilac> *think
06:37:25 <quicksilver> lilac: yes, it can be consistent with higher-rank types.
06:37:29 <quicksilver> lilac: but those aren't haskell98
06:37:37 <quicksilver> which "type" is.
06:38:08 <lilac> ah, your point is that it gives you more expressive power than haskell'98 allows?
06:38:22 <lilac> (or would if it were permitted)
06:39:12 <quicksilver> and it wouldn't mix very well with type inference.
06:39:49 <chrisdone> if I have: format = printf "%02d", will the format string to printf be read each time format is used, or will the function created by printf "%02d" be cached?
06:40:18 <augustss> chrisdone: formatting is done on every call
06:40:31 <chrisdone> dang!
06:40:50 <augustss> chrisdone: doing what you want is tricky
06:41:09 <povman> Has anyone used ChucK?
06:42:12 <chrisdone> augustss: I think matchRegex from Text.Regex could possibly cache the matcher created by the regex string i.e. if the regex string was used to generate a parser, but.. I don't know about printf
06:43:01 <Twey> printf isn't that expensive, though, surely
06:43:07 <augustss> chrisdone: it's more difficult with printf, I think
06:43:24 <quicksilver> is it?
06:43:29 <chrisdone> I don't know how it's done "under the hood"
06:43:34 <quicksilver> surely format strings can be scanned upfront
06:43:49 <augustss> chrisdone: have you tracked down a performance problem to that printf?
06:44:14 <chrisdone> augustss: no, not at all. this just a musing
06:44:15 <augustss> quicksilver: and then what?
06:45:09 <quicksilver> augustss: and then you have some nice data structure which lists the parameter types you are expecting, and a nice string-with-holes to put them in.
06:45:13 <Axman6> augustss: interesting development, the current shootout code has a segfault too, though not sure if it's related
06:45:28 <quicksilver> Axman6: begins to sound like a bug in one version or compilation of GHC.
06:45:32 <quicksilver> Axman6: (only a guess)
06:45:41 <Axman6> it apparently worked fine with 6.8.3, but not with 6.10.1
06:47:41 <Axman6> is there much difference between ST and IO operations, on say arrays?
06:48:11 <alexeevg> I believe IOArrays are STArrays under the hood
06:48:23 <rwbarton> chrisdone: in my experiments, it will only parse the format string once *provided* you give format a type signature, say, Integer -> IO ()
06:48:51 <Axman6> yeah, i thought it was something like that. reading the ST papers seems to imply that IO is implemented using ST, and then has some stuff added
06:50:57 <chrisdone> rwbarton: why does giving an explicit type signature help?
06:53:16 <rwbarton> chrisdone: without it you are asking ghc to evaluate "under" a lambda (for the PrintfType dictionary) which isn't done because it could lead to space leaks in general
06:53:31 <rwbarton> chrisdone: I guess my tests don't really prove much about what happens with the type signature though.
06:54:06 <rwbarton> I just checked let format :: Integer -> IO (); format = trace "foo" $ printf "%02d" which only printed "foo" the first time.
06:54:18 <rwbarton> But that doesn't really say anything much.
06:54:38 <alexeevg> it really doesn't
06:55:02 <rwbarton> I mean, it says it *could* be parsing the format string once, if it were implemented to do so.  The version without the type signature cannot be.
06:55:02 <alexeevg> it depends on the printf body if it does prescan format string or not
06:56:06 <chrisdone> without a type signature it would be inferred or an ambiguous type compile error would occur
06:56:22 <chrisdone> so I don't see how it helps the runtime behaviour?
06:56:43 <alexeevg> you don't have to pass a class dictionary to monomorphic function
06:57:24 <rwbarton> chrisdone: If you have the monomorphism restriction on, that counts as writing a type signature in this case.
06:57:42 <rwbarton> (for your example  let format = printf "%02d")
06:58:15 <chrisdone> I haven't disabled the monomorphism restriction. what happens without the monomorphism on?
06:58:59 <rwbarton> Then format gets the general type (PrintfType a) => a, rather than a monomorphic type inferred from context
07:00:15 <chrisdone> rwbarton: but isn't the `a' unified with String when compiled?
07:00:29 <chrisdone> rwbarton: (in the place where I'm using it)
07:01:56 <rwbarton> chrisdone: hopefully Integer -> String
07:02:04 <chrisdone> er, yeah
07:02:11 <chrisdone> a unified with Integer
07:03:14 <chrisdone> I always assumed that using a polymorphic function would compile separate functions for every instance I used
07:03:43 <chrisdone> like show 'c' :: Char -> String, does this compile to a kind of show_Char function underneath?
07:03:52 <chrisdone> or is the the type looked up at runtime?
07:04:01 <augustss_> Depends
07:04:01 <Cale> I wonder how possible/effective it would be to have a facility to explicitly request evaluation under a lambda.
07:04:21 <Cale> chrisdone: The typical implementation is by dictionary passing.
07:04:25 <chrisdone> what does "under a lambda" mean?
07:04:37 <augustss_> Cale: certainly possible
07:04:49 <Cale> chrisdone: like (\x -> 3 + 4) ~~~> (\x -> 7)
07:05:09 <Cale> chrisdone: At least, for typeclass-polymorphism
07:05:11 <chrisdone> what is the ~~~> called?
07:05:18 <chrisdone> right
07:05:20 <Cale> chrisdone: Reduction?
07:05:56 <Cale> chrisdone: For pure parametric polymorphism, there only needs to be one implementation because it does the same thing regardless of the instantiation of the type variable.
07:06:02 <rwbarton> > printf ('%':'2':'d':undefined) (19:undefined)
07:06:03 <lambdabot>   Add a type signature
07:06:08 <rwbarton> > printf ('%':'2':'d':undefined) (19:undefined) :: String
07:06:09 <lambdabot>   Add a type signature
07:06:09 <Axman6> anyone know a nice way of running sat an IO () action n times?
07:06:14 <rwbarton> > printf ('%':'2':'d':undefined) (19:undefined :: [Integer]) :: String
07:06:15 <lambdabot>       No instance for (IsChar Integer)
07:06:15 <lambdabot>        arising from a use of `printf' ...
07:06:29 <Cale> chrisdone: But show 'c' is compiled into something like  show instanceShowChar 'c'
07:06:41 <chrisdone> (well let's say there is (\x -> 3 + 4) ~> (\x -> 7), and (\x -> 3 + 4) ~~> (\x -> 7). I assumed ~~> would have a different name to ~>..)
07:06:44 <Cale> Where instanceShowChar is a record consisting of the methods of the Show class.
07:06:44 <Axman6> for some reason i can't get forM_ [1..n] (\_ -> action) to work
07:07:07 <Cale> chrisdone: oh, I wasn't counting the ~'s
07:07:07 <augustss_> Cale: you're assuming all values have a uniform representation
07:07:12 <Cale> augustss_: yes.
07:07:14 <chrisdone> Cale: oh
07:07:35 <rwbarton> > printf ('%':'2':'d':undefined) 19 :: String
07:07:36 <lambdabot>   "19* Exception: Prelude.undefined
07:08:13 <Axman6> anyone?
07:08:18 <chrisdone> rwbarton: what does that prove?
07:08:24 <Cale> augustss_: (I'm talking about the "typical" implementation, whatever that is :)
07:08:26 <rwbarton> chrisdone: Nothing really
07:08:32 <Gracenotes> rwbarton: it reached the end of the token quite recognizably
07:08:41 <Gracenotes> hurrah, printf.
07:08:57 <vixey> Cale, untyped lazy lambda calculus as the target
07:09:12 <alexeevg> Axman6: sequence_ . replicate n ?
07:09:18 <vixey> id i = i compiles into id = \i -> i
07:09:32 <Axman6> alexeevg: yeah that'll work
07:10:16 <Cale> vixey: In fact, my mental model isn't usually even that low-level :)
07:10:32 <Cale> vixey: My basic language has case in it too ;)
07:10:42 <chrisdone> isn't passing a dictionary around instead of compiling separate functions a bit slow?
07:10:46 <chrisdone> slow-er
07:11:03 <Cale> chrisdone: Well... separate compilation gets tricky otherwise.
07:11:21 <alexeevg> chrisdone: I'm no expert, but with inlining you sometimes get effects similar to what you'd expect from C++ templates
07:11:22 <augustss_> If you optimize with ghc most dictionaries disappear
07:11:26 <Cale> chrisdone: But yeah, you can't optimise things quite as far. You can ask GHC to specialise particular instances for you if you want though.
07:11:50 <chrisdone> oh, that's good
07:11:51 <Cale> (oh, and possibly it chooses to do so anyway)
07:14:20 <lilac> Axman6: you could go all smalltalky and say "let times = flip (sequence_ . replicate) in n `times` action"
07:14:44 <rwbarton> chrisdone: for a simple case like show 'c' --> show instanceShowChar 'c', since show is just a record selector now, it can evaluate show instanceShowChar at compile time
07:14:47 <lilac> s/flip//
07:14:53 <Axman6> lilac: yeah, i was thinking about something along the lines of ruby's n.times do stuff
07:15:20 <JuanDaugherty> rwbarton's was "smalltalky", the other wasn't
07:15:39 <JuanDaugherty> <- ruby denier.
07:15:52 <rwbarton> my what?
07:16:00 <lilac> Axman6: ah, well then. you /clearly/ want 'instance Num (IO () -> IO ())' ...
07:16:11 <Axman6> alexeevg: i ended up with just replicateM_ n action :)
07:16:13 <JuanDaugherty> blurb, fragment, pseudo snippet, whatever
07:16:27 <Workybob> @src replicateM
07:16:27 <lambdabot> replicateM n x = sequence (replicate n x)
07:16:46 <chessguy_work> @pl r n x = s (r' n x)
07:16:46 <lambdabot> r = (s .) . r'
07:16:46 <alexeevg> Acman6: yeah, that's better, silly me
07:16:47 <Workybob> cool, that's another Monadic function that should be Applicative
07:16:48 <maltem> > let (.) = flip ($) in [1,2,3].map(^2)
07:16:50 <lambdabot>   [1,4,9]
07:16:50 <Axman6> @src replicateM_
07:16:50 <lambdabot> replicateM_ n x = sequence_ (replicate n x)
07:16:53 <quicksilver> Cale: GHC specialises instances eagerly within modules, and not at all cross-module, AFAIK.
07:17:02 <Axman6> @src sequence_
07:17:03 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
07:17:10 <lilac> Axman6: although you'd just end up writing 'do 10 $ print "Hello"; 20 $ print "World"' and confusing all the BASIC lovers
07:17:26 <quicksilver> Cale: the {- SPECIALIZE -} pragma chooses to export a specialised version so you can get cross-module specialisation.
07:17:31 <lilac> @hoogle replicateA_
07:17:31 <lambdabot> No results found
07:17:34 <quicksilver> lilac: HAH
07:17:42 <quicksilver> lilac: that's brilliant. It must be done.
07:17:50 <Workybob> lilac: the _ variantes I think *are* monadic
07:17:58 <Workybob> because they require the >> return ()
07:18:02 <Axman6> lilac: lol
07:18:18 <rwbarton> >> return () === fmap (const ())
07:18:21 <quicksilver> Workybob: >> return (), also known as () <$
07:18:22 <lilac> Workybob: (>> return ()) = (const () <$>), no?
07:18:34 <Workybob> lilac: oh, so it is
07:18:35 <Workybob> so yeh
07:18:36 <quicksilver> triphonic functorisation!
07:18:41 <lilac> what's stereo when it's three?
07:18:51 <chessguy_work> @quote stereo
07:18:52 <lambdabot> greeting says: Welcome to #haskell where your questions are answered in glorious stereo!
07:18:55 <Workybob> sequence, mapM, replicateM and all their _ variants should all be in applicative
07:18:58 <Workybob> not monad
07:19:02 <Workybob> forM too
07:19:05 <Axman6> yeah
07:19:10 <Cale> Well, there's for
07:19:11 <lilac> Workybob: Monad should have Applicative as a superclass.
07:19:14 <byorgey> lilac: it's still stereo.
07:19:16 <Workybob> lilac: very true
07:19:20 <Cale> :t Data.Traversable.for
07:19:20 <lambdabot> forall (t :: * -> *) a (f :: * -> *) b. (Applicative f, Data.Traversable.Traversable t) => t a -> (a -> f b) -> f (t b)
07:19:21 <Axman6> i;m sensing a Monad -> Applicative revolution!
07:19:32 <Workybob> Cale: yep, Data.Traversable getting it right is win
07:19:39 <Axman6> Vive La'pplicative!
07:19:39 <vixey> @instances-importing Data.Traversable.Traversable Traversable
07:19:40 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
07:19:43 <byorgey> lilac: etymologically, the 'stereo' part indicates the space-fillingness, not the two-ness
07:19:45 <Workybob> but really they should be moved from Data.Monad to Data.Applicative
07:19:48 <vixey> @instances-importing Traversable Data.Traversable.Traversable
07:19:49 <lambdabot> Maybe, []
07:19:59 <Workybob> Control. even
07:20:00 <fasta> augustss: have you found a reason to dislike Qi II already?
07:20:15 * maltem wonders if rewriting the Prelude due to someone's paper about more general useful structures will only happen every few years
07:20:44 <quicksilver> lilac: stereo isn't really about 2, it's about 'space-filling' sound or 'three-dimensional' sound. 6-channel sound is still stereo. However it is widely misused.
07:20:44 <Cale> maltem: I would be happy if it occurred at least that often!
07:20:48 <augustss__> Fasta: it's based on lisp :)
07:20:59 <Cale> maltem: It's been a decade already!
07:21:15 <fasta> augustss__: that's one of reasons I think it's actually good ;)
07:21:28 <quicksilver> Workybob: the only time you need a monad is when you want to "wire" results from one part of your effect to another.
07:21:35 <maltem> Cale: yeah, stable APIs can be annoying
07:21:43 <augustss__> Fasta: I need to try it.
07:21:50 <quicksilver> Workybob: any independent reduction of effects, be it listlike, tree like, or any like, with independent collection of results, is applicative.
07:22:00 <Workybob> indeed
07:22:05 <maltem> Cale: at least if they're tired into the implementations
07:22:07 <quicksilver> Workybob: the monad part comes in when you use the result of one part to actually influence the input to another part.
07:22:36 <Workybob> quicksilver: yep – I had intended to post a suggestion to the haskell-prime list to move half of Control.Monad into Control.Applicative
07:22:36 <Cale> I wouldn't mind to see less stable APIs in the name of improving elegance. There are plenty of people who would disagree with me though...
07:22:41 <Workybob> but for some reason I'm banned from it
07:22:43 <Workybob> no idea why
07:22:43 <Cale> I think dons is one of those ;)
07:22:44 <Workybob> :/
07:22:55 <Cale> (perhaps)
07:23:02 <rwbarton> Cale: I was about to suggest dons :)
07:23:03 <quicksilver> Workybob: I imagine you tried to post from a different email addy to the one you signed up from.
07:23:19 <Workybob> quicksilver: that's believable actually
07:23:20 <quicksilver> Workybob: the difference between 'gmail.com' and 'googlemail.com' catches some people out ;)
07:23:29 * Workybob ponders if he signed up from tatd2@kent...
07:24:07 * byorgey agrees with Cale
07:24:30 <byorgey> the two of us can take dons ;)
07:24:42 <Cale> I have an opinion biased by the fact that I don't have any Haskell code which I wouldn't mind having to rewrite a bit if I wanted it to compile again.
07:24:46 <chrisdone> (the difference between gmail.com and googlemail.com caught me out...)
07:25:15 <maltem> Cale: I would like, perhaps, to see people agreeing on improved APIs to be published on hackage, but not be made *really* official
07:25:49 <rwbarton> Cale: You could just fork hackage
07:25:54 <Cale> rwbarton: yes.
07:26:01 <Cale> rwbarton: and GHC?
07:26:18 <Cale> Well, it probably wouldn't come to that :)
07:26:19 <rwbarton> Cale: Why GHC?
07:26:34 <Cale> rwbarton: There are some things I'd like to change in the Prelude which affect desugaring.
07:26:35 <rwbarton> Cale: so that it builds against your new Prelude?
07:26:53 <Cale> Though, perhaps that's somewhat avoidable.
07:27:08 <Cale> I wonder if GHC would complain if fail was off in its own class?
07:28:21 <fasta> Is there a website that shows all the websites Y linking to the same website X?
07:28:54 <byorgey> Cale: probably. Isn't fail built into do-notation desugaring?
07:29:01 <Cale> byorgey: yes.
07:29:15 <mapreduce> fasta: Google Alerts can give you that as it happens as emails and probably RSS.
07:29:16 <cnwdup> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1063#a1063 Is this stupid? It seems to be a little cumbersome to write a Monad instance for that.
07:29:18 <Cale> byorgey: But hopefully only when there's a refutable pattern.
07:29:22 <mapreduce> fsvo 'as it happens'.
07:29:41 <byorgey> Cale: right.
07:29:41 <maltem> fasta: also, google advanced search seems to include something similar
07:29:42 <Cale> byorgey: Well... Haskell 98 says something a little different from what GHC does, I think.
07:29:47 <vixey> cnwdup, I would use type instead of newtype..
07:30:07 <vixey> (shouldn't that be WriterT btw?)
07:30:27 <Cale> I want do-blocks to have a slightly different type when they use refutable patterns.
07:30:49 <lilac> vixey: it's the base monad, no need to be a transformer
07:30:50 <vixey> cnwdup, other habit I have is ending monad transformer stacks with Identity
07:31:29 <cnwdup> vixey, that would mean I have to write runParser :: StateT ParserState (WriterT [ParserError] Maybe), right? That's not what I want.
07:31:30 <maltem> cnwdup: Generalized newtype deriving should save you from writing the monad instance out
07:31:31 <chrisdone> vixey: for easy swapping?
07:31:55 <cnwdup> maltem, its not working when having a = Maybe a. Which gives trouble anyways. Thats why I'm asking.
07:32:10 <maltem> oh
07:32:32 <quicksilver> Cale: it would be nice if it was easier to write custom front-end plugins for GHC
07:32:50 <Cale> Somewhat off on a tangent, I wonder if it would be cool to have a way, within a do-block, to capture everything up to that point, and apply a function to it before continuing.
07:32:55 <quicksilver> Cale: that could do your improved desugaring, as well as allow other mostly syntactical experiments.
07:33:08 <vixey> Cale, that sounds like Cont though, isn't it?
07:33:10 <quicksilver> but this is different from just an improved prelude.
07:33:11 <lilac> cnwdup: i think you want MaybeT (StateT ParseState (Writer [ParseError]))?
07:33:19 <Cale> vixey: backwards though...
07:33:24 <Cale> vixey: or maybe not.
07:33:32 <cnwdup> lilac, wouldn't hat discard parse errors if something wents wrong?
07:33:33 <quicksilver> IMO haskell's import needs to grow up and get version control, in some way.
07:33:37 <Cale> I'm thinking something like this funny generalised list comprehensions thing.
07:34:08 <cnwdup> lilac, oh. It doesn't. (-: Thanks. Thats exactly what I want.
07:34:11 <lilac> @unmtl MaybeT (StateT ParseState (Writer [ParseError]))
07:34:12 <lambdabot> err: `MaybeT (StateT ParseState (Writer [ParseError]))' is not applied to enough arguments, giving `/\A. ParseState -> (Maybe A, ParseState, [ParseError])'
07:34:16 <lilac> @unmtl MaybeT (StateT ParseState (Writer [ParseError])) a
07:34:16 <lambdabot> ParseState -> (Maybe a, ParseState, [ParseError])
07:34:49 <quicksilver> that's weird? unmtl knows about MaybeT which doesn't actually exist in the mtl? ;)
07:34:51 <lilac> cnwdup: monad transformers are written inside-out
07:35:15 <lilac> quicksilver: unmtl lives in an idealized world :)
07:35:22 <quicksilver> lucky mtl
07:35:30 <Cale> It would make the desugaring a bit stranger to describe...
07:35:32 <quicksilver> does it sell tickets?
07:36:00 <cnwdup> lilac, I need ghc 6.10 for MaybeT, right?
07:36:02 <maltem> quicksilver: you don't buy tickets in an ideal world
07:36:15 * Axman6 loves the number of people in here that have hostnames coming from a uni
07:41:21 <hackage> Uploaded to hackage: incremental-sat-solver 0.1.4
07:42:33 <Cale> It seems somewhat impossible to do without insisting that all existing bindings are lost.
07:43:38 <Cale> (so it's probably not all that sensible a complication to introduce)
07:43:54 <lilac> @wiki MaybeT
07:43:54 <lambdabot> http://www.haskell.org/haskellwiki/MaybeT
07:44:24 <lilac> @wiki New monads/MaybeT
07:44:24 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MaybeT
07:44:36 <lilac> cnwdup: ^^ there you go
07:44:59 <Axman6> oh awesome, NICTA arw actually doing cool stuff, like writing kernels in haskell :D
07:45:29 <cnwdup> lilac, thanks. Already found it. I didn't know it was an individual package.
07:45:57 <Axman6> hmm, maybe they're not writing it in haskell, but someone is
07:46:27 <jeremy-wrk> hey guys what year did haskell get anonymous functionality?
07:46:39 <jeffz`> Axman6: I read they only use Haskell for prototyping stuff
07:46:40 <Cale> jeremy-wrk: what do you mean?
07:46:42 <augustss_> Huh?
07:46:51 <Cale> "anonymous functionality"?
07:46:54 <byorgey> jeremy-wrk: you mean anonymous lambda expressions like \x -> x + 1 ?
07:46:57 <lilac> jeremy-wrk: "anonymous functionality"? unnaed lambdas?
07:47:04 <Cale> Haskell has always had lambda.
07:47:07 <Axman6> jeffz`: well,there's a proposal to get it up and wokring as something useful
07:47:49 <Cale> What do you guys think of this potential syntax/desugaring:
07:47:52 <Cale> do u <- x; v <- y; (u',v') <- f -< (u,v); g u' v'
07:47:55 <Cale> f (do u <- x; v <- y; return (u,v)) >>= \(u',v') -> g u' v'
07:48:30 <Axman6> Cale: what's -< supposed to do?
07:49:09 <Axman6> makes for some cool looking functions :)
07:49:10 <byorgey> Cale: what does that buy you?
07:49:20 <byorgey> Cale: also, -< is already used for arrow notation
07:49:25 <Cale> byorgey: Not a whole lot unfortunately.
07:49:26 <Axman6> Cale: reckon you could paste a version with new lines to make it clearer?
07:49:28 <lilac> byorgey: i think that's the point.
07:49:34 <byorgey> lilac: ?
07:49:44 <lilac> byorgey: this -< and Arrow's -< are remarkably similar
07:50:12 <Cale> Axman6: I could...
07:50:18 <Axman6> cheers :)
07:50:27 <Cale> do u <- x
07:50:27 <Cale>    v <- y
07:50:27 <Cale>    (u',v') <- f -< (u,v)
07:50:27 <Cale>    g u' v'
07:50:36 <byorgey> hmm... ok, I guess I can see a similarity, but if they are only 'similar' and not 'instances of the same thing' then I don't think overloading syntax is a good idea.
07:50:52 <quicksilver> no one uses arrow notation though
07:51:03 <Twey> Hardly anyone uses arrows :-\
07:51:05 <quicksilver> so there would be little harm in stealing its notation ;)
07:51:13 <vixey> arrows are useless
07:51:14 <Cale> The main problem with this is that u and v are out of scope below the -< line.
07:51:29 <lilac> if Arrow didn't contain 'pure' it might get more use...
07:51:33 <Cale> If there was a way to preserve them, then that would be really cool.
07:51:38 <Cale> oh... perhaps there is.
07:51:53 <Cale> er, no, nevermind :)
07:51:54 <quicksilver> I use arrows quite often.
07:51:59 <quicksilver> I use the typeclass rarely
07:51:59 <Twey> quicksilver: Oh really?
07:52:04 <Twey> Heh
07:52:04 <byorgey> quicksilver: the arrow notation is quite nice, it's just that arrows themselves don't get used much for non-trivial things.
07:52:07 <quicksilver> because the typeclass doesn't buy you much.
07:52:22 <lilac> quicksilver: you use arrows other than (->) ?
07:52:23 <Twey> first, second?
07:52:24 <quicksilver> but I use arrows, in the sense that I use kleisli composition
07:52:37 <quicksilver> stuff like a -> [b] and a -> IO [b] for example
07:52:47 <quicksilver> very useful for transformations
07:52:51 <quicksilver> (q.v. haxml)
07:53:06 <Saizan_> Cale: it's a bit confusing that x and y are not actually sequenced before f there
07:53:25 <Saizan_> it makes the syntax non-local
07:53:29 <quicksilver> Saizan_: Yes. "f" get the choice to run them multiple times, or never.
07:53:56 <Cale> yes
07:53:57 <lilac> do (u', v') <- f $ do {u <- x; v <- y; return (u, v)}; g u' v'
07:54:06 <vixey> Are you sure this is not expressible using Cont?
07:54:06 <lilac> is clearer in terms of sequencing side-effects
07:54:07 <vixey> ContT
07:56:33 <quicksilver> :t ContT
07:56:34 <lambdabot> forall a (m :: * -> *) r. ((a -> m r) -> m r) -> ContT r m a
07:57:54 <Peaker> I wish "Occurs check" was a bit more specific about where the problem was
07:58:11 <Cale> Peaker: Isn't it usually very specific?
07:58:30 <Peaker> Cale: Its complaining about my function that generates a record of functions -- the error can be anywhere within the record
07:58:44 <Peaker> Cale: and the record creation has the definition of all the functions, so its rather large
07:58:58 <Cale> Peaker: Is the type recursive or parametric?
07:59:08 <Peaker> Cale: parametric
07:59:19 <Cale> Okay, and where do you use the type parameter?
07:59:35 <noZone> Any ideas on why numCapabilities would report 1 on a 2 core machine?
07:59:44 <Cale> It's probably complaining that you've given something of type Foo a where you meant to give something of type a
07:59:51 <Peaker> Cale: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1064#a1064
08:00:01 <Peaker> Cale: the occurs check is somewhere "in there" :)
08:00:21 <Peaker> Cale: Yeah, I know what stuff causes Occurs problems -- just have no idea where the error is at
08:00:46 <Peaker> just commenting out some of the fields can let me binary search where it is, heh
08:01:13 <lilac> do uncurry g =<< f (liftM2 (,) x y)
08:01:20 <lilac> s/do//
08:01:38 * lilac proudly misses the point
08:02:28 <Cale> lilac: One of the main applications would be, say, f = sort in the list monad.
08:02:29 <quicksilver> noZone: you didn't launch the RTS with +RTS -N2
08:02:41 <Cale> (or nub)
08:03:30 <noZone> quicksilver: Thanks... duh me.
08:03:43 <Cale> Peaker: It might help me if you pasted the error as well ;)
08:04:10 <Peaker> Cale: thanks, I've got it now by commenting out the code to find where it is :)
08:04:24 <Peaker> Cale: sorry to send you looking for the error, didn't mean that
08:04:44 <Peaker> (just wanted to make a point about "occurs check" being not specific enough)
08:05:04 <Cale> It would be nice if record syntax supported a notation like  draw drawInfo model = do ...
08:05:17 <quicksilver> Cale: we were just saying that a few hours ago, yes :)
08:05:32 <quicksilver> Cale: I persuaded Peaker to switch form typeclasses to a record-of-functions.
08:05:37 <Axman6> anyone know much about microkernels?
08:05:44 <quicksilver> no doubt he'll be back to punish me for it in a few days.
08:05:47 <Cale> hehe
08:05:54 <Peaker> quicksilver: heh why?
08:06:04 <quicksilver> ;)
08:06:07 <quicksilver> native pessimism.
08:06:32 <Cale> Records of functions really are often the right thing... we sometimes are blinded by the availability of typeclasses and forget about the older functional programming idioms.
08:06:36 <quicksilver> http://despair.com/pessimistsmug.html
08:06:55 <Axman6> i was wondering, could it be said that microkernels allow for easy(ier) parallelism?
08:07:36 <flux> I would say on some level that is true
08:07:50 <Cale> Axman6: I'm not all that knowledgable about it, but it seems to me that microkernels would allow for easier almost everything.
08:08:12 <flux> cale, well, judging from the lack of rise of microkernels, they don't allow for easier and faster development :)
08:08:19 <Axman6> i mean, if you're just passing messages between between userland processes to perform most system tasks, then those could run in parallel with other things
08:08:48 <Cale> flux: I wonder though, how much of that is really essential, and how much is chance.
08:09:09 <Cale> flux: It seems that which operating systems become popular has little to do with their actual kernel design.
08:09:21 <quicksilver> isn't OSX microkernel based at one level?
08:09:33 <quicksilver> although as cale says, I'm not sure kernel design ends up being a key factor.
08:09:36 <flux> well, in practicality I can see how tracing requests from the begin to the end can be difficult
08:09:52 <lilac> quicksilver: i was hoping that mug would have a hollow handle connected to the base, making it impossible to make it more than half full :)
08:10:34 <Axman6> quicksilver: yeah, OS X uses a microkernel, and still allows the sort of behaviour that one gives, unlike freebsd. (paraphrasing wikipedia)
08:11:00 <flux> I wonder how OSX microkernel approach differs from, say, l4linux
08:11:30 <Axman6> the reason i ws asking was because i was learning about L4, and the work that's bee done on it (including implementations in haskell)
08:12:13 <Peaker> oh, semantic editor combinators are more general than accessors/lens, because they can result in a different type
08:12:29 <Peaker> gaining a bit more understanding about semantic editors/accessors as I use both :)
08:12:57 <Cale> It would be really cool to see an operating system written in Haskell + LLVM, using the Haskell program to generate the actual kernel :)
08:13:20 <Axman6> http://www.reddit.com/r/haskell_proposals/comments/7rcgl/open_source_and_build_a_community_around_the/
08:13:46 <quicksilver> Peaker: that's the best way to learn :)
08:14:14 <Peaker> quicksilver: I'm really happy with the direction this is taking, but its taking me a while to refactor everything :)
08:14:40 <Axman6> Cale: indeed. i'd love to see how well that works
08:15:36 <Cale> You would have a high level description EDSL which would execute to produce the actual code :)
08:15:52 <Peaker> quicksilver: its insanely amazing how I changed sooo much, and had the compiler direct me about a bazillion fixes -- and when it compiles, it *always* works. Lovely :_)
08:16:12 * Axman6 doesn't know what an EDSL is...
08:16:30 <Axman6> this topic should become a lot more interesting to me after this year
08:16:32 <Cale> Axman6: embedded domain specific language
08:16:42 <Axman6> lots of low level machine stuff
08:16:53 <Axman6> and kernel talk i hope
08:17:18 <Cale> Axman6: Basically a fancy name for a library which pretends to be a programming language by defining primitive computations together with sufficiently interesting ways to combine them.
08:17:41 <Axman6> fair enough
08:17:42 <chessguy_work> Peaker, nothing like the ability to completely and safely re-write your entire project in an hour :)
08:17:53 <Peaker> chessguy_work: a few hours in my case, but yeah :-)
08:19:55 <Axman6> Cale: i just did that in about 20 mins for one thing i'm working on :)
08:19:59 <sbahra> Peaker, what is this project?
08:20:33 <Axman6> uh, chessguy_work, not Cale
08:21:17 <chessguy_work> definitely a big difference. i'm not nearly as brainy :)
08:21:32 <Axman6> heh :P
08:22:01 <Peaker> sbahra: a purely functional widget set
08:22:11 <Peaker> sbahra: well, as purely functional as I think it can be :)
08:22:14 <camio> How do I convert a String to a ByteString? fromString doesn't seem to work (ghc 6.10.1).
08:22:23 <Cale> camio: pack
08:22:34 <Cale> :t Data.ByteString.Char8.pack
08:22:35 <lambdabot> String -> BSC.ByteString
08:22:42 <Cale> :t Data.ByteString.Lazy.Char8.pack
08:22:43 <lambdabot> [Char] -> BSLC.ByteString
08:23:01 <chrisdone> I have 43 lines of imports in my web site Main.hs
08:23:07 <camio> Cale: thanks.
08:23:16 <Cale> If you need Unicode or any other encoding, you'll have to use one of the text encoding libraries.
08:24:16 <chrisdone> what discussion has there been with respect to having imports on one line?
08:24:18 <camio> Cale: Yeah, this question came up while testing Codec.Text.IConv
08:24:53 <Cale> chrisdone: On one line?
08:25:06 <Cale> chrisdone: You can separate them with semicolons.
08:25:28 <chrisdone> Cale: oh! let me try that
08:25:48 <quicksilver> or you can have ChrisDonesCoolStuff.hs
08:25:53 <quicksilver> which imports it all and re-exports it.
08:26:12 <chrisdone> Cale: but I have to write `import' every time. I think that defeats the object in some ways
08:27:17 <chrisdone> quicksilver: I think I'll have to do that, yes. arrows/applicative/monad/lists/maybe/data.function etc are a given
08:28:51 <chrisdone> I have 17 lines of `import Store.<foo>' it'd be great to do `import Store.*'
08:29:15 <chrisdone> @where hpaste2
08:29:15 <lambdabot> http://moonpatio.com/fastcgi/hpaste.fcgi/new
08:29:35 <Axman6> hmm, that's an idea, have a microkernel that has a file server process for each disk etc
08:30:09 <chrisdone> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1065#a1065
08:30:28 <chrisdone> er, the semicolon line was just me testing
08:30:33 <Baughn> Axman6: Just so long as you don't start serializing data to pass between processes. Pointers are fine.
08:31:42 <Axman6> Baughn: not sure i follow (this isn;t something i'm very knowledgable about [yet])
08:32:13 <chrisdone> quicksilver: don't you think `import' is verbose? especially in that example?
08:32:36 <Baughn> Axman6: There are two advantages to microkernels. First, it enforces a good architecture (theoretically...); second, by requiring isolation and ideally not having one kernel process trust the others' input, it makes the system more robust.
08:33:12 <Baughn> Axman6: Unfortunately, the traditional way to do the second is to have separate memory mappings and pass data via serialization. Needless to say, this is too slow, and causes all sorts of hacks.
08:33:28 <Baughn> Axman6: This being #haskell, it should be obvious that there are ways to make passing pointers between threads quite safe. ;)
08:33:41 <Axman6> heh, yeah :)
08:37:30 <Axman6> that's something the world needs, more magnetic board games. (thanks seinfeld)
08:38:10 <chrisdone> needs more magnetic things in general
08:38:57 <Raynes> Needs moar magnetic.
08:39:45 <jeremy-wrk> sorry guys I had to run off.
08:39:47 <Axman6> indeed
08:40:20 <jeremy-wrk> an anonymous function is a function that doesn't have to be bound to a name.
08:40:34 <jeremy-wrk> when did haskell start supporting this?
08:40:38 <vixey> jeremy-wrk, hi
08:40:48 <niklas175> cabal question: how do you tell ghc which version of a library to use? I accidentally installed two versions of quickcheck but can only "reach" the old one.
08:40:49 <skorpan> uh... lambdas are anonymous functions, aren't they?
08:40:51 <chrisdone> when did haskell stop supporting this?
08:40:54 <jeremy-wrk> vixey: hi
08:41:08 <jeremy-wrk> what exactly are lambda's?
08:41:09 <skorpan> as soon as you write \x -> .. you have an anonymous function
08:41:19 <vixey> jeremy-wrk, The /real/ name is lambda and we write it like  \v -> t
08:41:29 <skorpan> it comes from lambda calculus
08:41:47 <mstr> it's a crocodile that eats eggs
08:41:57 <vixey> jeremy-wrk, lambda is actually something completely fundamental, not only to haskell
08:42:14 <quicksilver> chrisdone: well, I think the main problem with your example is Store.*
08:42:17 <jeremy-wrk> lambda expression right?
08:42:36 <quicksilver> chrisdone: and in that particular case I would just make a 'Store.Everything' module. Or just call it 'Store'
08:42:40 <mstr> http://worrydream.com/AlligatorEggs/ ;D
08:42:43 <skorpan> yes, anonymous functions in haskell are basically lambda expressions
08:42:45 <quicksilver> and have it re-export all the stuff.
08:42:55 <vixey> skorpan, huh ??
08:43:08 <idnar> skorpan: that statement doesn't make any sense
08:43:18 <idnar> skorpan: lambda expressions are the only kind of anonymous function in Haskell, afaict
08:44:09 <skorpan> idnar: what did not make sense about my statement?
08:44:40 <chrisdone> quicksilver: but that doesn't seem like it solves the problem that import syntax treats modules which is a hierarchical data structure as some kind of flat file, we're just moving the big-ass list to another file. it's still a big-ass list...
08:44:44 <idnar> skorpan: your statement implies that anonymous functions in Haskell are a separate concept to lambda expressions, because they're not quite the same thing
08:44:57 <quicksilver> chrisdone: ah well, there you're making a crucial mistake.
08:45:00 <lilac> idnar: "f . g" is an anonymous function, but it's not a lambda expression
08:45:14 <idnar> lilac: ah
08:45:19 <idnar> okay, fair enough
08:45:29 <quicksilver> chrisdone: modules in haskell are not a hierarchical structure.
08:45:33 <vixey> wtf is "lambda expression"
08:45:37 <jeremy-wrk> where's some documentation to lambda expressions
08:45:42 <quicksilver> chrisdone: haskell modules are entirely flat. The namespacing trick is just convenience.
08:45:55 <quicksilver> vixey: A lambda expression is an expression of the form "\x ..."
08:45:57 <vixey> jeremy-wrk: Only lambda
08:45:57 <skorpan> vixey: an abstraction, an application or a variable iirc
08:45:59 <Axman6> jeremy-wrk: they're things like (\x -> x*x), and all functions can be written using them, like f x = x * sqrt x --> \x -> x * sqrt x
08:46:29 <chrisdone> quicksilver: but it's written as a hierarchy...
08:46:42 <quicksilver> chrisdone: Yes, but that's just a notational convenience.
08:46:50 <vixey> jeremy-wrk: learning lisp
08:46:54 <quicksilver> chrisdone: the apparent hierarchy is not designed to have any semantic meaning.
08:46:57 <chrisdone> quicksilver: well, it seems like a limited convenience
08:47:19 <skorpan> vixey: what do you mean "only lambda"?
08:47:20 <chrisdone> quicksilver: why not: import Control.Monad.State,Reader
08:47:31 <chrisdone> quicksilver: instead of writing it out twice for no reason?
08:47:31 <skorpan> "lambda expression" is perfectly valid afaik
08:47:38 <vixey> skorpan: lambda is important, lambda expression is nonsense
08:47:47 <idnar> lambda expression is an expression that is a lambda
08:47:50 <mauke> lambda expression is fine
08:48:05 <chrisdone> I prefer "lambda abstraction"
08:48:05 <Philippa_> it's fine. Vixey, you're trying to be too prescriptivist
08:48:08 <idnar> admittedly it's a bit redundant
08:48:15 <skorpan> chrisdone: that would be more descriptive, yes
08:48:20 <vixey> @w80 prescriptivist
08:48:21 <lambdabot> No match for "prescriptivist".
08:48:22 <Philippa_> well, "lambda" could refer to just the token
08:48:31 <lilac> also lambda could refer just to the greek letter
08:48:34 <mauke> \λ -> lambda
08:48:35 <Philippa_> vixey: linguistic One True Wayness
08:48:56 <lilac> prescriptivist lambdology?
08:49:05 <chrisdone> quicksilver: do you seriously think writing the whole namespace out every time isn't a pain in the ass or redundant?
08:49:38 <Cale> chrisdone: hm?
08:49:58 <quicksilver> chrisdone: yes. It's a very mild pain in the ass.
08:50:00 <Cale> One thing which I wish modules did have the ability to do is re-export things qualified.
08:50:11 <chrisdone> Control.Concurrent.STM.TArray
08:50:11 <chrisdone> Control.Concurrent.STM.TChan
08:50:11 <chrisdone> Control.Concurrent.STM.TMVar
08:50:15 <chrisdone> ^ what a pain in the nads
08:50:19 <quicksilver> chrisdone: a proper module system would be nice, but no one seems to know what a proper module system would be.
08:50:31 <jrockway> chrisdone: let me guess, you edit your haskell in Notepad?
08:50:33 <chrisdone> Control.Concurrent.STM.TArray,TChan,TMVar
08:50:50 <chrisdone> quicksilver: I'm only really talking about the syntax
08:51:06 <quicksilver> chrisdone: *nods* there could certainly be some simple syntactic conveniences.
08:51:10 <skorpan> i really don't mind the syntax really...
08:51:21 <Philippa_> quicksilver: it's not that nobody knows, it's that it's hard to find one that's even clearly a 'local best'
08:51:21 <Cale> skorpan: really? ;)
08:51:26 <skorpan> really! :)
08:51:46 <quicksilver> Philippa_: yes, that's a better way of articulating what I meant :)
08:51:50 <mauke> chrisdone: doesn't Control.Concurrent.STM reexport all of them?
08:52:12 <jrockway> incidentally, since someone said "Control.Concurrent.STM.TArray" in IRC, I can just dabbrev-expand it in a Haskell buffer ;)
08:52:13 <chrisdone> mauke: I don't think that matters because my example doesn't address that
08:52:16 <jrockway> so the typing is not a big issue
08:58:24 <Saizan_> Philippa_: do you have some papers/articles to suggest to have a good overview of the design space?
08:58:34 <lilac> jrockway: suddenly the irc-in-emacs thing makes sense to me :)
08:59:28 <Philippa_> Saizan_: the literature on ML modules is good, there's a chapter in ATTaPL. Then take a look at the work people like ChilliX've done on the similarity between MLish modules and typeclasses
09:00:35 <Olathe> Is there something that simplifies reading byte fields from a binary file ?
09:01:03 <Saizan_> Philippa_: ah, right, attapl, thanks :)
09:01:27 <quicksilver> Olathe: Data.Binary ?
09:01:46 <Philippa_> Saizan_: you can work backwards from the module/typeclass crossover work instead if you'd rather, but the ATTaPL chapter's a good overview
09:02:55 * chrisdone always complaining about haskell
09:03:55 <athos> @doc Data.Set
09:03:55 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
09:03:59 <quicksilver> chrisdone: that's what we're here for.
09:04:44 <athos> oh.
09:05:48 <chrisdone> quicksilver: hehe =)
09:07:44 <true\false> http://pastebin.com/d76231f53 Probably something stupid I'm missing?
09:08:02 <true\false> Compiler error is about the last part of the main not being an expression.
09:08:15 <beelsebob> true\false: you need to return something
09:08:15 <mauke> broken indentation
09:08:18 <beelsebob> something of type ()
09:08:20 <mauke> beelsebob: no
09:08:29 <beelsebob> @type hclose
09:08:30 <lambdabot> Not in scope: `hclose'
09:08:36 <beelsebob> oh, that's it
09:08:37 <beelsebob> hClose
09:08:40 <beelsebob> @type hClose
09:08:41 <lambdabot> Not in scope: `hClose'
09:08:42 <mauke> true\false: the token after 'do' determines the base indentation of the following block
09:08:54 <true\false> Just noticed that beelsebob.. Still not it
09:09:09 <mauke> which is why I recommend starting a new line after every 'do', 'where' and 'of'
09:09:10 <beelsebob> @type System.IO.hClose
09:09:11 <lambdabot> GHC.IOBase.Handle -> IO ()
09:09:17 <true\false> Ah, let me see then
09:09:26 <quicksilver> true\false: alternatively, indent all the other lines by 3 spaces more
09:09:33 <quicksilver> so that, for example, outh lines up with inh
09:09:39 <quicksilver> (on its left edge)
09:09:53 <quicksilver> but mauke's advice is probably better :)
09:10:28 <true\false> Yes I'm trying to follow that at the moment, main works, just fixing the indentation of the helper method
09:11:25 <true\false> Heh, this indentation thing is really getting awkward :) Thanks, compiles
09:12:00 <beelsebob> true\false: incidentally, this could be neatly written as hPutContents out . map toUpper =<< hGetContents in
09:12:59 <true\false> Well so far I've only learnt the fairly imperative style way of doing IO
09:13:26 <quicksilver> I think that's very reasonable as a learning experience.
09:13:33 <beelsebob> it is indeed
09:13:35 <quicksilver> it's good to know what different styles are possible.
09:13:41 <beelsebob> or better yet... main = writeFile "C:\\outit.txt" . map toUpper =<< readFile "C:\\init.txt"
09:13:58 <athos>  @hoogle ker
09:14:00 <blueonyx> hi, is there a some group fun so that group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
09:14:02 <true\false> Heh yeah, it's just that I expected to be a tad better at haskell by this point.. But oh well
09:14:07 <mauke> "C:/init.txt" plz
09:14:08 <athos> @hoogle ker
09:14:09 <lambdabot> package datapacker
09:14:09 <lambdabot> System.FilePath.Posix makeRelative :: FilePath -> FilePath -> FilePath
09:14:09 <lambdabot> System.FilePath.Windows makeRelative :: FilePath -> FilePath -> FilePath
09:14:17 <quicksilver> > group "Mississippi"
09:14:18 <lambdabot>   ["M","i","ss","i","ss","i","pp","i"]
09:14:25 <quicksilver> blueonyx: apparently so :)
09:14:26 <mauke> blueonyx: ...
09:14:28 <dancor> @pl \ x -> f x >> g x
09:14:29 <lambdabot> liftM2 (>>) f g
09:14:46 <beelsebob> f <^(>>)^> g -- :P
09:14:47 <blueonyx> sry, would like group "Mississippi" = ["M","iiii","ssss","ss","pp"]
09:14:59 <dancor> so that liftM2 is over the function monad?
09:15:04 <beelsebob> > group . sort $ "Mississippi"
09:15:05 <mauke> blueonyx: sort first
09:15:06 <lambdabot>   ["M","iiii","pp","ssss"]
09:15:11 <dancor> or the monad that the >> is over
09:15:18 <mauke> function
09:15:20 <dancor> ok
09:15:21 <beelsebob> dancor: it's liftA2 over functions
09:15:46 <blueonyx> mauke: but what to do with just Eq but not Ord elements?
09:16:23 <beelsebob> blueonyx: then you get into slower algorithms with counting occurances, and nub
09:16:46 <blueonyx> i did a foldr myself, but apperently it reacts like group :/
09:17:52 <Olathe> quicksilver: Thanks :)
09:17:57 <skorpan> so... does anyone have a mnemonic to make it easier remembering the order of the arguments to foldr?
09:18:33 <dancor> just remember it's backwards ;)
09:18:33 <blueonyx> hoogle foldr :>
09:18:59 <beelsebob> skorpan: it doesn't really need a mnemonic – the list is obviously the last element to make it a list transformer, and the function is almost always first
09:19:13 <dancor> like a lot of things that act on lists/big-objects tha big thing is last i guess
09:19:14 <quicksilver> skorpan: the function comes first because haskell is a functional language.
09:19:55 <SamB_irssi> also that lends itself better to composing foldrs
09:20:10 <SamB_irssi> wait, wait, no.
09:20:39 * SamB_irssi realizes you can't compose on the 2nd argument but give the last arg ...
09:20:59 <dancor> i guess it's considered more likely to want to fold the same function over many lists than to want to fold many functions over the same list
09:21:13 <skorpan> beelsebob: a list transformer... what constitutes a list transformer?
09:21:36 <SamB_irssi> so, but, why does the thing to put in for [] come 2nd ?
09:21:43 <Olathe> skorpan: A function [a] -> [b]
09:21:54 <Olathe> Like map or foldr (+) 0
09:21:57 <beelsebob> skorpan: something that transforms a list into another list
09:22:09 <Olathe> map f, I mean
09:22:18 <beelsebob> or a list into a something else in the case of foldr
09:22:19 <SamB_irssi> Olathe: foldr (+) 0 doesn't return [b] ...
09:22:28 <SamB_irssi> :t foldr (+) 0
09:22:29 <lambdabot> forall a. (Num a) => [a] -> a
09:23:02 <dancor> it's typical of haskell to use some big word like that really loosely like that ;)
09:23:37 <Axman6> > scanr (+) 100 [1..10]
09:23:38 <lambdabot>   [155,154,152,149,145,140,134,127,119,110,100]
09:23:43 <skorpan> :t scanr
09:23:44 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
09:23:52 <Philippa_> skorpan: "fold cons nil"
09:23:56 <skorpan> so what the heck does scanr do
09:24:07 <beelsebob> skorpan: same as foldr
09:24:09 <skorpan> Philippa_: say what?
09:24:11 <beelsebob> but keeps all the intermediates
09:24:12 <Axman6> > scanr f x [a,b,c,d]
09:24:13 <lambdabot>   [f a (f b (f c (f d x))),f b (f c (f d x)),f c (f d x),f d x,x]
09:24:31 <skorpan> oh... right.
09:24:40 <beelsebob> skorpan: what Philippa_ was trying to say was that the first argument 'replaces' all the conses in the list, and the second one replaces all the nils in the list
09:24:47 <beelsebob> > foldr (:) [] [1,2,3,4,5]
09:24:49 <lambdabot>   [1,2,3,4,5]
09:25:03 <skorpan> > scanr (:) [] [1..5]
09:25:04 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
09:25:11 <Philippa_> beelsebob: right, it's just that "foldr cons nil" is the mnemonic :-)
09:25:11 <pumpkin> my consesssss
09:25:18 <beelsebob> Philippa_: indeed
09:25:25 <Philippa_> as in, "foldr : [] = id"
09:25:45 <mauke> > foldr : []
09:25:46 <lambdabot>       Overlapping instances for Show ((a -> b -> b) -> b -> [a] -> b)
09:25:46 <lambdabot>        ...
09:25:51 <mauke> clearly not id
09:26:00 <pumpkin> lol
09:26:08 <Axman6> pumpkin!
09:26:14 <pumpkin> hai
09:26:21 <SamB_irssi> Philippa_: forgot you some parens ?
09:26:22 <Axman6> i wanted you for something, and now i can't really remember what
09:26:36 <pumpkin> everybody wants me
09:26:45 <pumpkin> is it cause somebody set up us the bomb?
09:26:51 <Axman6> i asked you about the uvector stuff right?
09:26:56 <pumpkin> yup
09:27:01 <Axman6> uvector/prime generator
09:27:02 <Philippa_> SamB: yep. Actually, at the moment I'm doing most of my list manipulation in a language that doesn't have operators yet...
09:27:16 <Philippa_> anyway, YKWIM
09:27:21 <vixey> LISP
09:27:39 <Philippa_> (and I wish more tutorials taught people that : is pronounced cons and [] is pronounced nil)
09:27:59 <SamB_irssi> Philippa_: I guess it used to be obvious ...
09:28:06 <Axman6> i've always proounced : cons
09:28:12 <Axman6> -o
09:28:15 <paper_cc> [] should be pronounced mappend =)
09:28:16 <pumpkin> Axman6: yup
09:28:21 <Philippa_> (because they're still useful as monosyllabic names even if you then have to explain that nil is the empty list!)
09:28:29 <paper_cc> s/mappend/mzero/
09:28:30 <quicksilver> parens needed not are postfix notation in
09:28:40 <Axman6> pumpkin: oh one interesting thing, you know my n-bodies segfault thing?
09:28:44 <pumpkin> yuup
09:28:47 <Philippa_> paper_cc: no, it shouldn't. They're distinct.
09:28:52 <beelsebob> s/mzero/mempty/
09:29:07 <Axman6> well, not sure if it's related, but dons' shootout submitted one segfaults under 6.10.1 as well
09:29:08 <Philippa_> and foldr's parameters don't necessarily form a monoid
09:29:17 <pumpkin> :o
09:29:22 <dancor> everything's distinct, even "empty list" and "nil" have different connatations
09:29:25 <Axman6> i know :O
09:29:42 <pumpkin> Axman6: maybe it has subtle memory access issues like UArr does
09:29:45 <dancor> spelling--
09:29:58 <pumpkin> it's STUArray?
09:30:04 <Axman6> nope
09:30:14 <Axman6> his stuff is all IO magic
09:30:17 <pumpkin> :o
09:30:20 <Axman6> http://shootout.alioth.debian.org/u64q/benchmark.php?test=nbody&lang=ghc&id=1
09:30:37 <Philippa_> dancor: they have the same denotation in haskell (though not lisp) though
09:31:35 <vixey> what's the difference with "empty list" and "nil" ?
09:31:49 <Philippa_> in lisp, nil has other uses
09:32:06 <vixey> oh right
09:32:16 <vixey> nil = () in lisp
09:32:20 <vixey> but yeah I know what you mean
09:32:21 <Philippa_> it can also connote "not a value (in the embedded language)", for example
09:32:33 <dancor> so when you say nil for haskell you might also be talking about ()
09:32:34 * Axman6 has always called [] 'the empty list'. since that's what his lecturer calls it
09:32:49 * quicksilver generally calls [] 'fred' and () 'sue'
09:32:51 <Axman6> and because in a way, there's only one empty list
09:32:53 * dancor doesn't use lisp nor say nil
09:32:54 <quicksilver> makes the language feel more homely.
09:33:01 <Philippa_> dancor: that's extremely unusual in haskell though, () is "unit"
09:33:07 <dancor> unit?!
09:33:09 <Saizan_> square and circle, obviously
09:33:10 <vixey> dancor, nobody would call () nil :p
09:33:10 <quicksilver> or sometimes "coin"
09:33:11 <dancor> god i really don't know what's up
09:33:14 <Philippa_> which is actually a pretty different idea
09:33:19 <Axman6> quicksilver: how is sue cons fred friendly huh?
09:33:26 <pumpkin> Axman6: I suspect it's somehow accessing a little past the end of an array and getting into space that doesn't belong to the program? given all the pointers he uses, it wouldn't be hard to make a mistake like that
09:33:28 <Philippa_> dancor: because it's the sole (non-bottom) value of the (default) unit type
09:33:29 <vixey> dancor, actually I guess I have done this sort of, when using lists made up like (a, (b, (c, ())))
09:33:39 <vixey> () takes the role of nil, in that context
09:34:17 <Olathe> @type (!!!)
09:34:17 * Axman6 felt very uneasy when watching SICP and realising that lists were constructed like that
09:34:17 <Philippa_> yeah, that's the usual "talking in terms of the embedded language" thing though
09:34:18 <lambdabot> Not in scope: `!!!'
09:34:27 <SamB_irssi> vixey: sure, at the type level ;-P
09:34:34 <Philippa_> (,) could be pronounced cons too, in that situation
09:34:41 <SamB_irssi> I guess at the data level too...
09:34:50 <Axman6> :t let x `cons` xs = (x,xs) in cons
09:34:51 <lambdabot> forall t t1. t -> t1 -> (t, t1)
09:35:03 <Philippa_> anyway, gtg
09:35:15 <Axman6> :t let x `cons` xs = (x,xs) in a `cons` b `cons` c
09:35:16 <lambdabot> ((Expr, Expr), Expr)
09:35:35 <vixey> bye
09:35:39 <dancor> that's not very typesafe
09:35:49 <SamB_irssi> Axman6: "the empty list" is just a long word for nil
09:35:50 <Axman6> dancor: that's what scared me!
09:36:19 <skorpan> dons: how's hmp3 coming?
09:36:46 <Axman6> skorpan: he's away this week apparently
09:37:00 <Axman6> which is a pita, since i wanted to talk to him :(
09:37:02 <dancor> and will hmp3 really be kwlr than cplay
09:37:16 <dancor> i guess it will be like 2 lines so that will be kwl
09:37:46 <skorpan> would someone please implement a last.fm scrobbler for hmp3?
09:37:58 <vixey> scrobbler is such a great word
09:38:15 <Axman6> agreed
09:38:43 <vixey> does it mean something?
09:38:50 <pumpkin> hmp3?
09:38:51 <dancor> Using a music recommendation system called "Audioscrobbler", Last.fm builds a detailed profile of each user's musical taste
09:39:21 <skorpan> last.fm was itself called audioscrobbler back in the days
09:40:36 <paulvisschers> This may be an out of place question here, but does anyone know if there is a way of doing abstraction inside CSS (cascading style sheets)?
09:40:55 <skorpan> abstraction how?
09:41:23 <vixey> abstraction? lol
09:41:26 <paulvisschers> Like using variables and then let other parts refer to it
09:41:29 <dancor> the abstraction they offer is the "cascading" part
09:41:31 <skorpan> ah, no
09:41:37 <vixey> paulvisschers, I thought you meant like lambda
09:41:48 <skorpan> vixey: you mean lambda expressions? ;)
09:41:52 <vixey> paulvisschers, but it sounds like inheritence there
09:42:00 <vixey> skorpan, _only lambda_
09:42:02 <redditbot> Is your keyboard jammed, or are you just writing Haskell?
09:42:08 <Axman6> pumpkin: there's a haskell project that'll do that for you
09:42:14 <Cthulhon|> If only JSSS had won over CSS.
09:42:15 <Axman6> uh, paulvisschers, not pumpkin
09:42:15 <pumpkin> ?
09:42:22 <blueonyx> paulvisschers: try sass :>
09:42:57 <quicksilver> it really annoys me you can't abstract colours
09:42:59 <quicksilver> (in CSS)
09:43:07 <blueonyx> sass can
09:43:11 <paulvisschers> I have a few html tags that have a certain class in it, but this is purely a visual thing and not a logical one
09:43:14 <vixey> paulvisschers, btw maybe you can just write a perl script to print out CSS
09:43:33 <dancor> ..or a haskell script
09:43:33 <quicksilver> or use jQuery to set things up after page load
09:43:40 <quicksilver> which is a terrible hack but quite convenient.
09:43:42 <vixey> (by 'perl script' I don't actually mean perl the language, just that style of script)
09:43:44 <paulvisschers> So instead I want to remove the class attributes and use css only
09:44:06 <dancor> vixey: that's a very perl way to overload language ;2
09:44:12 <vixey> thank you :)
09:44:27 <paulvisschers> I'll just list all the sections the style needs to apply to
09:44:34 <SamB_irssi> vixey: in any old language ?
09:44:46 <paulvisschers> only half a dozen, so not so bad
09:46:45 <psnively> Howdy!
09:46:57 <paulvisschers> anyway thanks for all the responses
09:48:15 <pumpkin> the haskell reddit feels somewhat bare when dons is away
09:48:16 <chessguy_work> hmm, i miss haskell's higher-orderedness in prolog. it looks like it's going to be significantly harder there
09:48:26 <Axman6> pumpkin: yeah :(
09:49:52 <pumpkin> I've been holding up my patch spree on uvector in case I'm doing something horribly wrong
09:51:16 <Olathe> Is there a way to make instance Whatever [Word8] work without extensions ?
09:51:39 <quicksilver> no.
09:51:46 <quicksilver> it is forbidden by haskell98.
09:51:58 <Olathe> Alright, thanks.
09:52:01 <quicksilver> most people fine FlexibleInstances to be a harmless extension though.
09:52:16 <quicksilver> (the haskell98 approach would wrap it in a newtype)
09:55:53 <Olathe> How do I do import qualified A.B.C as C in ghci, so that I can do C.whatever ?
09:56:02 <quicksilver> you can't.
09:56:05 <Olathe> Ahh.
09:56:05 <mauke> use a temp file
09:56:07 <quicksilver> you have to load D.hs
09:56:16 <quicksilver> where D.hs contains "import qualified A.B.C as C"
09:56:19 <quicksilver> annoying? yes.
09:56:35 <Olathe> Alright, thanks.
10:01:57 <hasMeta> hey folks
10:02:04 <hasMeta> http://rafb.net/p/PZeZaB14.html
10:02:41 <lupsyn> excuse me what is the funcion of ` in haskell ?
10:02:46 <hasMeta> is there a way to "transport" the IO invocation of line 3 "into" the writeHtmlPageCss?
10:02:55 <lupsyn> like ... num (Q x1 x2 x3 x4)= 4* (num x1 `max` num x2 `max` num x3 `max` num x4)
10:03:01 <Twey> lupsyn: It converts a function to an operator
10:03:06 <Twey> a `b` c means b a c
10:03:06 <gnuvince> lupsyn: to make a function of two arguments into an infix operator
10:03:24 <lupsyn> thx so much
10:03:52 <pumpkin> hasMeta: if you make that function into IO
10:03:59 <Axman6> gnuvince: s/two/at least two/
10:04:34 <gnuvince> > let f a b c = a + b + c in 1 `f` 2 3
10:04:35 <lambdabot>       Overlapping instances for Show (t -> t)
10:04:35 <lambdabot>        arising from a use of `s...
10:04:47 <gnuvince> > let f a b c = a + b + c in 1 `f 2` 3
10:04:48 <lambdabot>   <no location info>: parse error on input `2'
10:04:52 <Axman6> oh, nice, just cut another 10 seconds of my nbodies runtime by using -fvia-C
10:05:08 <hasMeta> pumpkin: huh?
10:05:11 <pumpkin> Axman6: did you ask for O3 in cc?
10:05:36 <Axman6> > let f a b c = a + b + c in 1 `f` 2 4
10:05:37 <lambdabot>       Overlapping instances for Show (t -> t)
10:05:37 <lambdabot>        arising from a use of `s...
10:05:43 <Gracenotes> :X
10:05:45 <pumpkin> hasMeta: if you wanted to call readFile in your writeHtmlPageCss function, your writeHtmlPageCss function would need to be sitting in the IO monad
10:05:52 <Axman6> > let f a b c = a + b + c in (1 `f` 2) 4
10:05:54 <lambdabot>   7
10:05:56 <Axman6> hmm
10:06:08 <pumpkin> that is, return IO x
10:06:55 <Axman6> pumpkin: only O2, i'll try O3
10:07:16 <quicksilver> -O11 ftw
10:07:30 <hasMeta> pumpkin: http://rafb.net/p/WBwX0e78.html
10:08:26 <pumpkin> @hoogle liftIO
10:08:26 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
10:08:31 <pumpkin> interesting
10:08:47 <hasMeta> pumpkin: writeHtmlPageCss has it's own monad, currently it's like IO read ( IO write ... )
10:09:00 <pumpkin> hmm
10:09:14 <pumpkin> why lift it?
10:09:14 <hasMeta> pumpkin: I'm looking for delegate readFile -> (IO read + write)
10:09:24 <leimy> liftIO is scary looking typewise :-)
10:09:29 <pumpkin> if you have nested IOs, you can join them
10:09:35 <pumpkin> but you could just avoid lifting it again
10:10:07 <hasMeta> sorry, this lifting part is not my code, but I can modify it ...
10:10:19 <leimy> I use liftIO
10:10:29 <leimy> inside Monad Transformer wrapper bits like StateT
10:10:53 <leimy> Usually doing some kind of Chan communication with another thread.
10:11:18 * shapr boings excitedly
10:11:34 <pumpkin> shapr: my dirty mind makes me think you're having sex every time you say that
10:11:38 --- mode: ChanServ set +o glguy
10:11:38 <shapr> um
10:11:42 <shapr> oboy!
10:11:46 --- mode: glguy set -bbbb *!*@ip-106-111.zb.lv *!*=48cf1683@gateway/web/ajax/mibbit.com/session *!*n=niukas@62.212.200.* *!*=c0a801fe@gateway/web/cgi-irc/ufmg/x-e868966772015131
10:11:49 --- mode: glguy set -bbbb *!*@gateway/web/cgi-irc/ufmg/x-26cd6ba3873b6917 *!*@88.231.174.221 *!*=zamboneg@*.sd.sd.cox.net *!*=SexyCamm@*.dynamic.caiway.nl
10:11:52 --- mode: glguy set -bbbb *!*@24.115.7.239.res-cmts.flt.ptd.net *!*=adsfstas@*.160.162.72.cable.dyn.cableonline.com.mx *!*=hiyousuc@*.buffalo.res.rr.com *!*n=ask@*.lf.br.cox.net
10:11:56 --- mode: glguy set -bbbb *!*=JesseVen@*.160.160.201.cable.dyn.cableonline.com.mx *!*i=sss@*.190-136-203.telecom.net.ar *!*=smeegal1@*.ispone.net.au FreenoseJew!*@*
10:11:59 --- mode: glguy set -bbbb DavidDavid!*@*!#haskell-ops *!*@ip-86-110-185-217.spark-rostov.ru *!*n=jdh30@*.bb.sky.com *!*=davidowh@59.42.197.*
10:12:03 --- mode: glguy set -bbbb lemming*!*@* *!n=palomer@* *!*n=anekos@*.nas923.p-osaka.nttpc.ne.jp climdan!*@*
10:12:06 --- mode: glguy set -bbbb *!*@cs181102007.pp.htv.fi *!*@*.hsi.ish.de *!*@pool-71-255-157-239.cncdnh.east.verizon.net *!*n=oxy@81.193.54.*
10:12:06 <vixey> hiya shapr
10:12:08 * shapr cheers for glguy
10:12:10 --- mode: glguy set -bbbb *!*n=WP-Gast@91.135.163.* *!*@76.226.217.251 *!*=tadazane@76.226.217.* palomer!*@*
10:12:11 * shapr hugs vixey 
10:12:13 --- mode: glguy set -bbbb *!*@*.splius.lt *!*@64.81.136.196 *!*=love___m@116.71.174.* *!*=amishdud@*.pitbpa.fios.verizon.net
10:12:17 --- mode: glguy set -bbbb *!*n=cmeme@*.b9.com *!*=javachat@*.twcny.res.rr.com *!*=traveler@*.twcny.res.rr.com *!n=lehka*@*.pppoe.eltel.net
10:12:20 --- mode: glguy set -bbbb *!*n=Beyaz@88.238.98.* *!*n=ledohm@84.76.133.* *!*@adsl-157-130-204.cae.bellsouth.net *!*@*irseek/log-bot/IRSeekBot
10:12:21 <shapr> pumpkin: You have a dirty mind, Sir!
10:12:23 <pumpkin> oh no, we'll be getting back lots of those weird trolls
10:12:23 --- mode: glguy set -bbbb *!*n=fsk141@*.dsl.lsan03.sbcglobal.net *!*n=asefg@207.138.47.* *!*n=Drum@*.balticom.lv *!*n=ircap8@*.Red-79-145-91.staticIP.rima-tde.net
10:12:24 * vixey hugs shapr :P
10:12:26 --- mode: glguy set -bbbb *!*n=Voz@*.dynamic.dsl.as9105.com *!*n=dDerf@*.hsd1.md.comcast.net *!n=kma@78-61-233-147.static.zebra.lt patco444!*@*
10:12:28 <shapr> whee!
10:12:30 --- mode: glguy set -bbbb *!*n=eduardo@190.13.230.* *!*@ip70-161-29-120.hr.hr.cox.net *!*tuomov@jolt.modeemi.cs.tut.fi *!*@ip72-207-20-159.sd.sd.cox.net
10:12:33 --- mode: glguy set -bbbb *!*=Administ@*.160.160.13.cable.dyn.cableonline.com.mx *!*@70.44.52.171 *!*=JackpotM@*.187-66-87.adsl-dyn.isp.belgacom.be *!*@70.44.75.40.res-cmts.brd2.ptd.net
10:12:37 --- mode: glguy set -bbbb Smerdyakov!*@* *!*=yannikru@*.dip0.t-ipconnect.de *!i=d8cde040@gateway/web/ajax/mibbit.com/x-36b68e8ac39f368e *!*=48cf149f@67.159.35.*
10:12:40 <leimy> lol
10:12:41 --- mode: glguy set -bbbb *!*n=sadmasd@41.233.46.* *!n=xpl0ziv@33.84-48-116.nextgentel.com *!*n=EnQLey@*.dyn.versateladsl.be *!*=Krzysiek@*.multimo.gtsenergis.pl
10:12:41 <Gracenotes> the condemned rise from the dead!
10:12:44 <pumpkin> http://www.urbandictionary.com/define.php?term=boing
10:12:44 --- mode: glguy set -bbbb *!*=Gooddamn@78.84.156.* *!*n=teis@*.virnxx10.dynamic.dsl.tele.dk *!*n=pok4@77.125.125.* BeelsebobWork!*@*
10:12:47 <Olathe> That's a lot of bans.
10:12:48 --- mode: glguy set -bbbb *!*@host207.190-224-241.telecom.net.ar *!*n=xxx@*.190-30-166.telecom.net.ar *!*i=kukucis@78.84.113.* *!*=idanKING@77.126.71.*
10:12:48 <chessguy_work> somebody ban glguy for spamming
10:12:51 --- mode: glguy set -bbbb *!*n=Crazy-T@*.cable.ubr04.king.blueyonder.co.uk *!*i=Beau@*.prsstn.dial.dynamic.tds.net *!*=DIGGTHIS@124.189.113.* *!*n=g@*.socal.res.rr.com
10:12:55 --- mode: glguy set -bbbb *!*@65.31.222.144 *!*=4b3d5d86@gateway/web/ajax/mibbit.com/x-d6c9de57f90bcdc0 xah_lee!*@* *!*@95.66.74.232
10:12:57 <shapr> chessguy_work: :-P
10:12:58 --- mode: glguy set -bbbb *!*n=orel@*.karneval.cz %*!*@syru153-183.syr.edu %*!*@syru217-183.syr.edu %maxote!*@*
10:13:01 --- mode: glguy set -b *!n=Jon@bie.dhcp.studentenwerk-bielefeld.de
10:13:04 <glguy> Prelude Data.List> readFile "+bans" >>= \ xs -> let bans = lines xs in let f [] = []; f xs = take 4 xs : f (drop 4 xs) in mapM_ (\ys -> putStrLn $ "/mode -bbbb " ++ intercalate " " ys) (f bans)
10:13:06 <vixey> q: Are you also removing chanserv bans?
10:13:08 --- mode: glguy set -bbbb *!*@ip-106-111.zb.lv *!*=48cf1683@gateway/web/ajax/mibbit.com/session *!*n=niukas@62.212.200.* *!*=c0a801fe@gateway/web/cgi-irc/ufmg/x-e868966772015131
10:13:12 --- mode: glguy set -bbbb *!*@gateway/web/cgi-irc/ufmg/x-26cd6ba3873b6917 *!*@88.231.174.221 *!*=zamboneg@*.sd.sd.cox.net *!*=SexyCamm@*.dynamic.caiway.nl
10:13:15 --- mode: glguy set -bbbb *!*@24.115.7.239.res-cmts.flt.ptd.net *!*=adsfstas@*.160.162.72.cable.dyn.cableonline.com.mx *!*=hiyousuc@*.buffalo.res.rr.com *!*n=ask@*.lf.br.cox.net
10:13:18 <pumpkin> http://www.urbandictionary.com/define.php?term=boink http://www.urbandictionary.com/define.php?term=bonk (shapr, not just me :P)
10:13:19 --- mode: glguy set -bbbb *!*=JesseVen@*.160.160.201.cable.dyn.cableonline.com.mx *!*i=sss@*.190-136-203.telecom.net.ar *!*=smeegal1@*.ispone.net.au FreenoseJew!*@*
10:13:22 --- mode: glguy set -bbbb DavidDavid!*@* *!*@ip-86-110-185-217.spark-rostov.ru *!*n=jdh30@*.bb.sky.com *!*=davidowh@59.42.197.*
10:13:26 --- mode: glguy set -bbbb lemming*!*@* *!n=palomer@* *!*n=anekos@*.nas923.p-osaka.nttpc.ne.jp climdan!*@*
10:13:30 --- mode: glguy set -bbbb *!*@cs181102007.pp.htv.fi *!*@*.hsi.ish.de *!*@pool-71-255-157-239.cncdnh.east.verizon.net *!*n=oxy@81.193.54.*
10:13:31 <vixey> boink and boing are different.....
10:13:33 <lilac> in years to come i'll be able to tell people that i witnessed the Great Unbanning of '09
10:13:33 --- mode: glguy set -bbbb *!*n=WP-Gast@91.135.163.* *!*@76.226.217.251 *!*=tadazane@76.226.217.* palomer!*@*
10:13:36 --- mode: glguy set -bbbb *!*@*.splius.lt *!*@64.81.136.196 *!*=love___m@116.71.174.* *!*=amishdud@*.pitbpa.fios.verizon.net
10:13:37 <Olathe> Haha
10:13:40 --- mode: glguy set -bbbb *!*n=cmeme@*.b9.com *!*=javachat@*.twcny.res.rr.com *!*=traveler@*.twcny.res.rr.com *!n=lehka*@*.pppoe.eltel.net
10:13:43 * beelsebob wonders what the hell is going on with glguy
10:13:43 <pumpkin> vixey: I posted the link to boing in the middle of the other bans
10:13:44 --- mode: glguy set -bbbb *!*n=Beyaz@88.238.98.* *!*n=ledohm@84.76.133.* *!*@adsl-157-130-204.cae.bellsouth.net *!*@*irseek/log-bot/IRSeekBot
10:13:47 --- mode: glguy set -bbbb *!*n=fsk141@*.dsl.lsan03.sbcglobal.net *!*n=asefg@207.138.47.* *!*n=Drum@*.balticom.lv *!*n=ircap8@*.Red-79-145-91.staticIP.rima-tde.net
10:13:48 <leimy> our grandchildren will have one heck of a story
10:13:48 <idnar> whoa
10:13:50 --- mode: glguy set -bbbb *!*n=Voz@*.dynamic.dsl.as9105.com *!*n=dDerf@*.hsd1.md.comcast.net *!n=kma@78-61-233-147.static.zebra.lt patco444!*@*
10:13:54 --- mode: glguy set -bbbb *!*n=eduardo@190.13.230.* *!*@ip70-161-29-120.hr.hr.cox.net *!*tuomov@jolt.modeemi.cs.tut.fi *!*@ip72-207-20-159.sd.sd.cox.net
10:13:57 --- mode: glguy set -bbbb *!*=Administ@*.160.160.13.cable.dyn.cableonline.com.mx *!*@70.44.52.171 *!*=JackpotM@*.187-66-87.adsl-dyn.isp.belgacom.be *!*@70.44.75.40.res-cmts.brd2.ptd.net
10:13:58 <Axman6> glguy: ok there?
10:14:01 --- mode: glguy set -bbbb Smerdyakov!*@* *!*=yannikru@*.dip0.t-ipconnect.de *!i=d8cde040@gateway/web/ajax/mibbit.com/x-36b68e8ac39f368e *!*=48cf149f@67.159.35.*
10:14:01 <quicksilver> beelsebob: the ban list was a bit long.
10:14:04 --- mode: glguy set -bbbb *!*n=sadmasd@41.233.46.* *!n=xpl0ziv@33.84-48-116.nextgentel.com *!*n=EnQLey@*.dyn.versateladsl.be *!*=Krzysiek@*.multimo.gtsenergis.pl
10:14:05 <Olathe> All the bans are already gone on this server.
10:14:07 <chessguy_work> geez
10:14:08 --- mode: glguy set -bbbb *!*=Gooddamn@78.84.156.* *!*n=teis@*.virnxx10.dynamic.dsl.tele.dk *!*n=pok4@77.125.125.* BeelsebobWork!*@*
10:14:11 --- mode: glguy set -bbbb *!*@host207.190-224-241.telecom.net.ar *!*n=xxx@*.190-30-166.telecom.net.ar *!*i=kukucis@78.84.113.* *!*=idanKING@77.126.71.*
10:14:12 <Saizan_> "a bit"
10:14:13 <Olathe> Not sure how he's still unbanning.
10:14:15 --- mode: glguy set -bbbb *!*n=Crazy-T@*.cable.ubr04.king.blueyonder.co.uk *!*i=Beau@*.prsstn.dial.dynamic.tds.net *!*=DIGGTHIS@124.189.113.* *!*n=g@*.socal.res.rr.com
10:14:16 <ddarius> quicksilver: These are duplicates now.
10:14:18 --- mode: glguy set -bbbb *!*@65.31.222.144 *!*=4b3d5d86@gateway/web/ajax/mibbit.com/x-d6c9de57f90bcdc0 xah_lee!*@* *!*@95.66.74.232
10:14:22 --- mode: glguy set -bbbb *!*n=orel@*.karneval.cz %*!*@syru153-183.syr.edu %*!*@syru217-183.syr.edu %maxote!*@*
10:14:23 <Gracenotes> Olathe: cycle? :/
10:14:27 <leimy> lol
10:14:28 <Olathe> Bah.
10:14:29 <leimy> cycle
10:14:30 <chessguy_work> haha
10:14:30 <tromp__> byebye
10:14:39 <pumpkin> he had a silly irc client I guess
10:14:46 <Gracenotes> yes, we are getting into repeat mode
10:14:48 <czShadoW> -!- Irssi: No bans in channel #haskell
10:14:51 <hasMeta> pumpkin: do you know how to fix my code?
10:14:51 <czShadoW> It's clear now.
10:14:52 <czShadoW> :-)
10:14:54 <Olathe> Welcome back :)
10:14:56 <glguy> I hear it was duplicating
10:14:57 <Gracenotes> *golf clap for glguy*
10:14:59 <glguy> so I /exit
10:15:01 <vixey> (repeat) Are you also removing the chanserv bans?
10:15:02 <glguy> :)
10:15:04 <lilac> 180 bans? wow 0_0
10:15:09 <pumpkin> hasMeta: if you're getting an IO (IO the quickest fix is join on the result
10:15:11 * shapr cheers for glguy 
10:15:24 <Gracenotes> few channels support 180 bans
10:15:25 <Axman6> pumpkin: lame, llvm-gcc-4.2 doesn't support some of the code output by ghc :(
10:15:28 <pumpkin> hasMeta: but it isn't elegant
10:15:35 <pumpkin> Axman6: fail! what doesn't it like?
10:15:36 <glguy> we had about 90
10:15:40 <glguy> I think I double pasted :)
10:16:24 <Gracenotes> there's also autoremove
10:16:46 <shapr> yup
10:16:49 <lilac> glguy: yep, you pasted ban list, then "Prelude Data.List> readFile ...", then ban list again
10:17:32 * leimy wonders who did all that banning to begin with.
10:17:57 <lilac> > readFile "+bans" >>= \ xs -> let bans = cycle $ lines xs in let f [] = []; f xs = take 4 xs : f (drop 4 xs) in mapM_ (\ys -> putStrLn $ "/mode -bbbb " ++ intercalate " " ys) (f bans)
10:17:59 <lambdabot>   * Exception: "<IO ()>"
10:18:05 <ddarius> leimy: This channel is eight years old.
10:18:18 <hasMeta> pumpkin: is there no way to pass "html" as function which is executed within the writeHtmlPageCss IO (if writeHtmlPageCss wants to access body)
10:18:18 <hasMeta> ?
10:18:34 <pumpkin> hasMeta: sure you can
10:18:49 <glguy> lilac, my secret is out, I'm a haskell programmer!
10:18:52 <pumpkin> you can pass functions around and call them
10:19:09 <hasMeta> pumpkin: how would that look like? sorry, I'm just starting with haskell ...
10:19:27 <quicksilver> @users
10:19:27 <lambdabot> Maximum users seen in #haskell: 658, currently: 639 (97.1%), active: 31 (4.9%)
10:20:19 <mstr> > rng = getStdRandom; let (a,b) = randomR (1,10) rng in print a
10:20:20 <lambdabot>   <no location info>: parse error on input `='
10:20:34 <mstr> hmm?
10:20:47 <glguy> vixey, the akick list is being reviewed too
10:20:50 <Axman6> i've heard dons sayog before that using case statements doesn't allocate like lets do, is this correct?
10:20:55 <vixey> ok
10:21:06 <glguy> vixey, if you want to discuss bans, you can join #haskell-ops
10:21:17 <glguy> (or anyone else, for that matter)
10:21:17 <pumpkin> that sounds like a scary place
10:21:48 <mstr> is that example even close to print a random number from 1 to 10 ?
10:21:48 <quicksilver> Axman6: it's a bit complicated to answer that one properly.
10:22:04 <quicksilver> Axman6: but there are certainly circumstances wehre that is true.
10:22:09 <dancor> @pl \ x -> f x >> g x >> h x
10:22:09 <lambdabot> ap ((>>) . liftM2 (>>) f g) h
10:22:24 <quicksilver> Axman6: however, let desugars to case in the end. Everything desugars to case in the end.
10:22:32 <quicksilver> Axman6: there is no spoon, there is only case ;)
10:22:37 <Axman6> quicksilver: well, would say case vec of (V x y z) ->... not allocate?
10:22:37 <dancor> :t sequence . map ($ x)
10:22:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => [Expr -> m a] -> m [a]
10:23:03 <maltem> mstr: it's reasonable close, but rng doesn't have the type you think it had
10:23:59 <pumpkin>  hasMeta: I don't really get what you're trying to do
10:24:10 <mstr> > rng = getStdGen; let (a,b) = randomR (1,10) rng in print a
10:24:11 <lambdabot>   <no location info>: parse error on input `='
10:24:18 <alexeevg> quicksilver: everything desugars to case in the end? hmm. how about type inference supporting only let-polymorphism?
10:24:31 <lilac> glguy: you missed the joke i think. look more closely :)
10:24:54 <mstr> :t getStdGen
10:24:55 <lambdabot> IO StdGen
10:25:25 <maltem> mstr: lambdabot doesn't allow IO anyway, so no luck there
10:25:30 <lilac> quicksilver: i thought everything desugared to lambda, let and case?
10:25:55 <lilac> quicksilver: lambda for abstraction (plus application for removing it), let for laziness, and case for evaluation (in core at least)
10:25:57 <mstr> maltem: lambdabot can't give random numbers?
10:26:15 <lilac> mstr: lambdabot is pure as the driven snow. mostly.
10:26:19 <leimy> it can give pseudo random ones :-)
10:26:23 <lilac> > 4
10:26:24 <lambdabot>   4
10:26:33 <lilac> ^^ chosen by fair dice roll
10:26:37 <pumpkin> lunabot can give randomish numbers
10:26:43 <mstr> lilac: I guessed that :D
10:26:49 <Axman6> wth? my battery went from 23% to 33% :S
10:27:17 <hasMeta> pumpkin: IO ( body = read IO ( write body )) -> function body = read; IO ( write body )
10:28:02 <pumpkin> , fromU . dropU 1 $ replicateEachU 1 (toU [10]) (toU [1])
10:28:05 <lunabot>  [3.8268823663e-313,3.8268823663e-313,3.8268823663e-313,3.8268823663e-313,...
10:28:09 <pumpkin> there, randomish numbers!
10:28:21 <Cale> hasMeta: hm?
10:28:23 <pumpkin> ;)
10:28:36 <Cale> hasMeta: What language is that? :)
10:29:26 <hasMeta> Cale: http://rafb.net/p/hAjFNK98.html
10:30:00 <Cale> hasMeta: mm... okay
10:30:17 <pumpkin> hasMeta: btw, you probably want one of those (x)html combinator libraries
10:30:44 <pumpkin> oh you are using one
10:30:49 <Cale> It almost looks like he already has one, yeah
10:31:27 <hasMeta> what I want is to fix this IO shit
10:31:28 <hasMeta> ;)
10:31:40 <pumpkin> you haven't really made it clear what's wrong :)
10:31:42 <Cale> hasMeta: What is confusing you?
10:31:44 <pumpkin> I didn't get what you said above
10:32:21 <hasMeta> currently readFile is executed in line 5, right?
10:32:32 <Cale> hasMeta: sure
10:32:35 <hasMeta> that's why I need this additional do -> IO
10:32:44 <hasMeta> line 21 has another DO
10:32:53 <hasMeta> so I get IO( IO ( ...
10:33:00 <pumpkin> you can join them, as I said :)
10:33:03 <pumpkin> :t join
10:33:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
10:33:10 <hasMeta> I want to move the execution of line 5 into line > 21
10:33:15 <Cale> But chances are you don't really want join
10:33:20 <pumpkin> yeah :)
10:33:38 <Cale> hasMeta: you've defined an IO action called htmlbody
10:33:50 <Cale> do you mean that you want to run that action?
10:34:23 <hasMeta> nope
10:34:30 <hasMeta> I want to get rid of it ;)
10:34:36 <pumpkin> omg dons just submitted something to reddit!
10:34:39 <Cale> You mean delete the code for it?
10:34:53 <Cale> pumpkin: He submits a *lot* of stuff to reddit :)
10:34:58 <hasMeta> nope, but I don't want to use two IOs
10:35:02 <pumpkin> I know, but he hasn't been around on IRC for a while :)
10:35:11 <leimy> reddit is the new IRC
10:35:20 <idnar> YOU DAWG WE HERD YOU LIKE JOIN SO WE PUT AN IO IN YOUR IO
10:35:24 <idnar> er
10:35:24 <pumpkin> lol
10:35:27 <idnar> *YO
10:35:36 <pumpkin> I think it's supposed to be SUP
10:35:46 <pumpkin> and you need a "SO YOU CAN X WHILE YOU X"
10:35:50 <lilac> idnar: PUT AN IO IN YOUR IO IN YOUR IO SO YOU CAN JOIN WHILE YOU JOIN?
10:35:50 <Cale> hasMeta: actually, uh, this doesn't look like the IO monad...
10:35:57 <Cale> hasMeta: What is FileProducer?
10:36:03 <idnar> what lilac said
10:36:28 <Cale> hasMeta: It's important to understand that a value of type (IO t) is not at all like a value of type t.
10:36:52 <Cale> hasMeta: That is, an IO String is nothing like a String. It's much more like a program which if you were to run it, would give you a String.
10:36:53 <hasMeta> type FileProducer a = WriterT [FilePath] ( 	ReaderT WikiInfo ( 				IO 		) 	) a
10:37:21 <hasMeta> yes
10:37:35 <Cale> That's... strangely spaced ;)
10:37:44 <Cale> but okay
10:37:55 <Cale> So you need to run the monad transformers somewhere if you want some IO to run.
10:38:11 <hasMeta> It don't want to run it
10:38:30 <Cale> If you want to take an IO t and get a value of type t from it, you must run it.
10:38:46 <Cale> and you can only do so from inside another value of type IO t
10:38:52 <Cale> (or IO s)
10:39:04 <mercury^> But but what about unsafePerformIO?
10:39:06 <mercury^> :P
10:39:11 <leimy> shhhhh
10:39:14 <Cale> mercury^: It doesn't exist.
10:39:17 <hasMeta> ok, sounds good (IO t .> t)
10:39:39 <Cale> hasMeta: A value of type (IO t) is a description of some stuff to do in order to get a value of type t.
10:39:40 <BMeph> I CAN hasMeta? kthxbai!
10:40:01 <Cale> hasMeta: Normal haskell evaluation doesn't cause that stuff to happen.
10:40:21 <pumpkin> lol
10:40:25 <Cale> hasMeta: Running a Haskell program can be seen as the interleaving of two processes:
10:40:34 <Cale> 1) Evaluation, which reduces expressions into values.
10:40:47 <Cale> 2) Execution, which carries out IO actions and makes them actually happen.
10:41:21 <hackage> Uploaded to hackage: incremental-sat-solver 0.1.5
10:41:30 <hasMeta> So I need something like runReaderT?
10:41:48 <Cale> A Haskell program eventually defines an IO action called main, which is executed, and execution demands evaluation in order to figure out what actually needs to happen.
10:41:58 <mstr> what does this mean? "getStdGen :: IO StdGen"
10:42:03 <redditbot> Learning to Reason in Haskell, Part 3
10:42:03 <redditbot> The Universe of Discourse : A simple trigonometric identity
10:42:03 <redditbot> Extensible and Modular Generics for the Masses
10:42:03 <redditbot> Sebastian Fischer : Using SmallCheck to Shatter an Audacious Claim
10:42:03 <redditbot> koweycode: haskell-ji
10:42:13 <mstr> it returns two values or what?
10:42:15 <mercury^> I'm a bit confused here. hasMeta wrote monad transformer code but has never performed IO before?
10:42:23 <lilac> mstr: it returns one value which is an IO action
10:42:32 <lilac> mstr: executing that IO action produces a value of type StdGen
10:42:33 <Cale> mstr: It returns an action which when run, will produce a StdGen
10:42:37 <mstr> ouch
10:42:44 <Axman6> pumpkin: dons reddit flood!
10:42:49 <mstr> so this IO action is some monad stuff?
10:42:56 <Cale> mstr: One particular monad.
10:42:59 <pumpkin> Axman6: yeah, I know! I bet he's hiding from us because we're too enthusiastic
10:43:05 <Cale> mstr: But that's somewhat irrelevant.
10:43:05 <lilac> the monad stuff is what allows you to glue IO actions together
10:43:06 <Axman6> yeah!
10:43:13 <mercury^> IO is the magical monad.
10:43:13 <alexeevg> mstr: In a sense, IO a is no different from [a] or Maybe a
10:43:29 <Cale> It doesn't matter to you as a beginner that IO is a monad.
10:43:30 <alexeevg> it is just another parameterised datatype
10:43:34 <mstr> I mean, can I just call that from normal code without doing any "do" loops or whatnot?
10:43:36 <hasMeta> mercury: This is not my code, Im trying to extend and understand existing code to learn some haskell
10:43:42 <mercury^> Ah, k.
10:43:55 <shapr> @users
10:43:55 <lambdabot> Maximum users seen in #haskell: 658, currently: 638 (97.0%), active: 32 (5.0%)
10:44:04 <Cale> hasMeta: Haskell is sufficiently different from most other languages that this is going to be a challenge ;)
10:44:16 <Cale> hasMeta: But I'll do my best to help you out :)
10:44:26 <mauke> mstr: "do" is not a loop. "do" is also not magical
10:44:40 <mauke> mstr: also, getStdGen is not a function, so it can't be called
10:44:44 <mauke> it's a constant
10:44:54 <Cale> hasMeta: Okay, so a value of type FileProducer a can be seen as another sort of action, but it's not directly an IO action.
10:45:05 * alexeevg gonna stop now, the stereo is too loud without him
10:45:13 <hasMeta> Cale: thanks!
10:45:16 <Cale> hasMeta: It has more structure than IO actions normally have, as described by that type definition above.
10:45:28 <Cale> type FileProducer a = WriterT [FilePath] (ReaderT WikiInfo IO) a
10:45:57 <Cale> This means that in addition to carrying out IO, it logs a list of FilePaths as it goes, and reads from a value of type WikiInfo.
10:46:53 <Cale> runWriterT and runReaderT are functions which you use to collapse this extra structure and turn such an action into a normal IO action, but I suspect the library which you're using will provide its own runFileProducer, or some such.
10:47:22 <mstr> > do r <- getStdGen; print randomR (1,10) r
10:47:23 <lambdabot>   Couldn't match expected type `(t1, t2) -> StdGen -> IO t'
10:47:34 <mauke> mstr: print only takes one argument, not three
10:47:36 <hasMeta> Cale: yes it does
10:47:47 <mstr> > do r <- getStdGen; print (randomR (1,10) r)
10:47:48 <lambdabot>   * Exception: "<IO ()>"
10:47:48 <Cale> hasMeta: What's the type of runFileProducer?
10:47:58 <sw17ch> @seen dons
10:47:58 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 1d 14h 31m ago.
10:48:31 <Axman6> :t genStdGen
10:48:32 <lambdabot> Not in scope: `genStdGen'
10:48:37 <Axman6> :t getStdGen
10:48:38 <lambdabot> IO StdGen
10:48:47 <Axman6> mstr: can't do IO in lambdabot
10:48:54 <hasMeta> runFileProducer :: WikiInfo -> FileProducer () -> IO [FilePath]
10:49:22 <Axman6> ?users
10:49:23 <lambdabot> Maximum users seen in #haskell: 658, currently: 638 (97.0%), active: 28 (4.4%)
10:49:23 <Cale> hasMeta: Okay, that's... sort of boring really.
10:49:59 <Cale> (and somewhat unfortunate if you need access to the result of the FileProducer action...)
10:50:03 <Cale> But anyway
10:50:38 <Cale> supposing that you don't, we can use that function to turn your FileProducer action into an IO action, which is something that can be run from main
10:51:04 <mstr> Axman6: ah, ok
10:51:13 <mstr> that syntax works in ghci
10:51:24 <mstr> now I just need to understand why :P
10:51:47 <alexeevg> msyt: it does, but lambdabot is more restricted for good reasons
10:51:51 <hasMeta> actually I don't really need access to the result of the FileProducer action, all I need is to execute "html <- readFile $ name ++ "/" ++ name ++ ".html"" and get a String insteaf of IO String (afaik)
10:51:56 <alexeevg> err, mstr
10:52:07 <Cale> hasMeta: html will be a String
10:52:16 <Cale> hasMeta: In that case.
10:52:20 <mstr> hmm, if I just repeat "do r <- getStdGen; print (randomR (1,10) r)" a few times, it returns the same number every time
10:52:31 <mauke> yes
10:52:41 <mauke> because you're not modifying the generator
10:52:44 <Cale> hasMeta: But the entire do-block in which that line occurs will have type IO t, for some t
10:53:11 <hasMeta> yes
10:53:21 <alexeevg> mstr: try randomRIO
10:53:39 <mstr> mauke: so I'm supposed to grab the value from randomR call and use that the next time?
10:53:46 <hasMeta> by the way here the compiler output: http://rafb.net/p/YuiJGt34.html
10:53:48 <Cale> hasMeta: Does that help/make sense?
10:54:04 <Cale> aha!
10:54:04 <Cale> yes
10:54:25 <Cale> hasMeta: Okay, so that's actually complaining that FileProducer t is not the same thing as IO t
10:54:33 <mstr> :t randomRIO
10:54:34 <lambdabot> forall a. (Random a) => (a, a) -> IO a
10:54:53 <Cale> hasMeta: Since you've used readFile in that do-block, it knows that you must be describing an IO action
10:55:05 <Cale> hasMeta: But writeHtmlPageCss is not an IO action.
10:55:08 <Axman6> :t newStdGen
10:55:09 <lambdabot> IO StdGen
10:55:22 <Cale> hasMeta: It produces a FileProducer action, which you need to run with runFileProducer
10:55:29 <hasMeta> *reading*
10:55:49 <Cale> So you'll want to replace that  writeHtmlPageCss target info title body css with something along the lines of:
10:55:51 <Axman6> mstr: you want newStdGen, not getStdGen. getStdGen gets the current random number seed, newStdGen makes a new one based on the old one
10:56:20 <Cale> runFileProducer myWikiInfo (writeHtmlPageCss target info title body css)
10:56:38 <Axman6> anyway, it;s 6am, sleep time. night all
10:56:44 <mauke> mstr: yeah, randomRIO does that for you
10:56:53 * Axman6 tries to sleep through the hottest part of the day when it's 38 outside
10:56:58 <Cale> hasMeta: All the statements in a do-block must be actions of the same type.
10:57:06 <mstr> randomRIO seemed to give the same number all the time?
10:57:17 <Axman6> :t randomRIO
10:57:17 <hasMeta> Cale: I see, that's tricky
10:57:18 <lambdabot> forall a. (Random a) => (a, a) -> IO a
10:57:29 <Axman6> :t randomR
10:57:30 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
10:57:30 <hasMeta> I cannot touch the method definition
10:57:33 <mstr> nah, now it works :D
10:58:00 <Cale> hasMeta: Which method definition?
10:58:00 <hasMeta> oh
10:58:02 <hasMeta> sorry
10:58:24 <hasMeta> yes, that makes sense, I'll give it a try :)
10:59:30 <Cale> hasMeta: It's somewhat unfortunate that the library's author used 'type' rather than 'newtype' to define FileProducer. Your error message would have been easier to read.
11:00:18 <mercury^> Hmm, the rules for the programming language shootout have become pretty boring since I last checked.
11:01:02 <Cale> mercury^: In the sense that they are overly restrictive?
11:01:41 <mercury^> Almost every problem specifies an algorithm to use and often they also require certain artificial things with no effect to be done.
11:01:55 <Cale> yes
11:01:59 <hasMeta> Cale: I don't have access to the WikiInfo argument ... what a mess
11:02:15 <Cale> hasMeta: Does the library have Haddock documentation?
11:02:22 <mercury^> It should just be a function from stdin to stdout, implemented in an arbitrary way.
11:02:26 <pumpkin> it seems like a huge waste to not be able to use multiple cores on the shootout
11:02:30 <Cale> hasMeta: You can look for functions which produce values of type WikiInfo
11:02:33 <mercury^> pumpkin: you can do that now.
11:02:45 <Cale> mercury^: I agree.
11:02:47 <pumpkin> mercury^: but apparently they refuse to pass +RTS -N4 to our programs
11:02:51 <pumpkin> someone told me that
11:03:03 <pumpkin> so the programs need to be adapted to set that internally I guess?
11:03:09 <Cale> If they want to force the programs to compute something, they ought to force that something to be part of the output.
11:03:35 <pumpkin> they should also upgrade to 6.10
11:04:14 <Cale> pumpkin: There's no way to set RTS flags internally, except by linking against an additional .c file.
11:04:34 <pumpkin> which means I guess that we're effectively not allowed to use multiple cores?
11:04:50 <pumpkin> or will forkOS still work?
11:04:55 <Cale> Isn't there a separate multicore version of the shootout?
11:05:50 <pumpkin> I dunno, I just look at the http://shootout.alioth.debian.org/u32q/benchmark.php?test=nbody&lang=all (which says quad core) and our program is using 100 of one core
11:05:54 <monochrom> forkOS is not better than forkIO in exploiting more cores.
11:05:54 <pumpkin> and 0 of the others
11:05:58 <mercury^> Umm, it seems like you can specify command line options to be passed.
11:06:00 <mercury^> COMMAND LINE:
11:06:00 <mercury^> ./mandelbrot.ghc-2.ghc_run +RTS -N6 -RTS 6400
11:06:17 <hasMeta> Cale: yes, the main method instantiates WikiInfo objects, but I don't want to create such an object just to read a stupid file
11:06:28 <hasMeta> Cale: need to think about this, thanks for your time, this was helpful ;)
11:06:30 <Cale> hasMeta: Who said you had to?
11:06:32 <mercury^> And many haskell programs also show CPU usage on all cores.
11:06:49 <Cale> hasMeta: You only need WikiInfo to do that writeHtmlPageCss
11:06:58 <monochrom> You do need +RTS -N4 to use 4 cores. There is no way around it now.
11:07:08 <Cale> hasMeta: If you only want to do the readFile, there's no need for a value of type WikiInfo
11:07:34 <pumpkin> I guess that's true, I can see http://shootout.alioth.debian.org/u32q/benchmark.php?test=fannkuch&lang=all uses all of them
11:07:49 <Cale> hasMeta: Does that make sense?
11:08:08 <hasMeta> Cale: yes, my mistake
11:08:35 <mercury^> Having proper rules would also stop ridiculous things like this: http://shootout.alioth.debian.org/u64q/benchmark.php?test=threadring&lang=all
11:08:35 <mstr> http://pastebin.com/m44b7d80a
11:09:05 <mstr> is there a syntax error or something fundamentally wrong?
11:09:09 <pumpkin> mercury^: at least it increases interest in GHC, even if it doesn't make sense
11:09:10 <pumpkin> ;
11:09:11 <pumpkin> ;)
11:09:38 <Cale> mercury^: What is ridiculous?
11:09:59 <Cale> mstr: It doesn't know what type of random number you want.
11:10:23 <Cale> mstr: and the monomorphism restriction is on, which means that non-functions can't be polymorphic without an explicit type signature
11:10:47 <mauke> randomNum = randomRIO (1,10)
11:10:59 <Cale> and yeah, you can simplify it as mauke explains
11:11:05 <Cale> There are two things you can do...
11:11:10 <Cale> add a type signature:
11:11:16 <Cale> randomNum :: IO Integer
11:11:22 <Gast_688_> http://www.mein-nacktes-spiel.net/?id=2194312
11:11:23 <Gast_688_> http://www.mein-nacktes-spiel.net/?id=2194312
11:11:23 <Cale> or perhaps  randomNum :: IO Double
11:11:23 <Gast_688_> http://www.mein-nacktes-spiel.net/?id=2194312
11:11:24 <Gast_688_> http://www.mein-nacktes-spiel.net/?id=2194312
11:11:25 <Gast_688_> http://www.mein-nacktes-spiel.net/?id=2194312
11:11:27 <Gast_688_> http://www.mein-nacktes-spiel.net/?id=2194312
11:11:28 --- mode: ChanServ set +o Cale
11:11:29 --- mode: ChanServ set +o mauke
11:11:32 --- mode: Cale set +b Gast_688_!*@*
11:11:36 <Cale> er
11:11:42 --- mode: Cale set -b Gast_688_!*@*
11:11:46 <Cale> whoa...
11:11:55 <Apocalisp> dude
11:11:56 <Cale> What happened to our banlist?!
11:12:01 <pumpkin> glguy cleared it
11:12:06 <mstr> Cale: why is that IO Integer there?
11:12:09 <Cale> sigh, why?
11:12:09 <monochrom> hahaha
11:12:15 <Gast_688_> http://www.mein-nacktes-spiel.net/?id=2194312
11:12:15 <Gast_688_> http://www.mein-nacktes-spiel.net/?id=2194312
11:12:16 --- mode: mauke set +b *!*=Gast_688@*.dip.t-dialin.net
11:12:19 --- mode: ChanServ set +o Saizan
11:12:23 <mstr> I just want a number, not IO :)
11:12:24 <Cale> no, there's a better ban
11:12:27 <pumpkin> apparently #haskell-ops is the place to ask about that :P
11:12:36 <mercury^> Cale: it's obvious that the thread-ring benchmark is a joke. The different threading implementations were made for differing uses and measuring how fast a program that does yet again nothing is... well...
11:12:42 <mauke> mstr: so you want to generate a random number at compile time?
11:12:46 --- mode: Saizan set -o saccade
11:12:55 --- mode: Saizan set -o Saizan
11:13:01 --- mode: Cale set +b #haskell!*@*
11:13:03 <Cale> er
11:13:07 <idnar> heh
11:13:08 --- mode: Cale set -b #haskell!*@*
11:13:08 <pumpkin> lol
11:13:10 <mauke> :facepalm:
11:13:15 --- mode: Cale set +b *!*Gast*@*
11:13:15 <mstr> mauke: no, I want to get random numbers at runtime
11:13:16 <idnar> that dastardly #haskell guy will bother us no more!
11:13:20 <vixey> lol
11:13:20 <Cale> wrong argument order ;0
11:13:25 <mauke> mstr: then you need that IO
11:13:29 --- mode: Cale set -b *!*=Gast_688@*.dip.t-dialin.net
11:13:40 <mstr> umm
11:13:41 <mauke> mstr: if it was just a number, it would be a constant
11:13:54 <mauke> foo :: Integer  <- doesn't change
11:13:58 <Cale> That user would have been banned already if he hadn't stupidly cleared the banlist.
11:13:58 <monochrom> There are a couple of random number tutorials.
11:14:20 <Saizan> Cale: if it's a permanent ban it should go in the akick list, i think
11:14:21 <mercury^> "he"?
11:14:23 <vixey> Cale, do you think they are a robot?
11:14:24 --- mode: mauke set -o mauke
11:14:29 <Cale> vixey: always
11:14:37 <Cale> vixey: Often WP-Gast
11:14:44 <monochrom> Also RandomRIO is overloaded so it doesn't know whether you want Int, Double, Complex, ...
11:14:47 <Cale> which is a bot that works somewhat differently
11:14:51 <erikc> mercury: yea, threadrings should just be an implementation approach to solving a real benchmark, not a benchmark in itself
11:15:13 <Cale> (it's effectively a trollish version of eliza)
11:15:19 <vixey> maybe they should like
11:15:25 <vixey> I mean freenode staff..
11:15:30 <vixey> ban it off the server
11:16:27 <mercury^> I think they have a tool that monitors for spammers, so they should know about its existence at least.
11:16:58 <ztirF> is there any way to tell Haskell that my infix operator is commutative
11:17:08 <ztirF> like *+-?
11:17:17 <mercury^> What good would that do?
11:17:29 <monochrom> No.
11:17:30 <ztirF> so I can mix user-defined infix operators without parens
11:17:31 -ChanServ(ChanServ@services.)- Cale added *!*Gast*@* to the AKICK list.
11:17:52 <mercury^> Err, you can do that.
11:17:54 <ztirF> that seems like an oversight to me
11:18:01 <ztirF> mercury^: try iy
11:18:06 <ztirF> *try it
11:18:12 <mercury^> That has nothing to do with commutativity, unless I misunderstand you.
11:18:21 <ztirF> if they are the same precedence, it doesn't work
11:18:29 <monochrom> - is not commutative
11:18:38 <ztirF> ah, right
11:18:47 <ztirF> but I can still write 2+3-4
11:19:00 <monochrom> @info + -
11:19:01 <lambdabot>  Parse error at end of input
11:19:01 --- mode: ChanServ set +o mauke
11:19:01 --- mode: mauke set +d *Pennerg*
11:19:10 <Cale> +d?
11:19:16 <ztirF> > let (!+) = (+) in 2!+3!+4
11:19:17 <lambdabot>   9
11:19:21 <ztirF> hmmph
11:19:25 <ztirF> why does that work
11:19:33 <monochrom> + and - are both infixl 6, that's why they can mix.
11:19:34 <pumpkin> what is +d ?
11:19:35 <Cale> ztirF: Why wouldn't it?
11:19:38 <mercury^> Why wouldn't it? :P
11:19:40 <mauke> realname ban
11:19:51 <pumpkin> ah :)
11:19:52 * SamB_irssi wonders what serv you send what help msg to to find out about modes of that type
11:19:57 <monochrom> infixr 6 and infixl 6 wouldn't mix.
11:20:03 <glguy> SamB_XP, freenode.net
11:20:10 <ztirF> monochrom: ahh, now I get it
11:20:17 <ztirF> thanks
11:20:25 <SamB_irssi> glguy: I meant, like, /msg chanserv help yadayada
11:20:32 <monochrom> @info (+)
11:20:33 <lambdabot> (+)
11:20:34 <glguy> SamB_irssi, nope
11:20:46 <SamB_irssi> oh, you mean the website ?
11:20:46 <glguy> http://freenode.net/using_the_network.shtml
11:20:58 <monochrom> I need a haskell IRC plugin
11:21:01 --- mode: mauke set -o mauke
11:26:52 <charlieville> hmmm, a lazy module that would ask #haskell to implement the module and import the resulting code back in
11:30:48 <lilac> charlieville: doWhatIMean :: String -> a -> b ? :)
11:32:31 <mercury^> readProperly :: String -> a
11:33:50 <MyCatVerbs> lilac: doWhatIMean s arg = unsafePerformIO $ System.Process.runInteractiveCommand "/usr/bin/perl" >>= \(\i,o,e) -> hPutStrLn (unsafeGnarlySerialize arg) i >> hGetContents o >>= \output -> return (unsafeGnarlyDeSerialize output)
11:33:58 <quicksilver> ;)
11:34:11 <charlieville> >>=D
11:34:14 <quicksilver> MyCatVerbs: http://xkcd.com/224/
11:38:11 <mercury^> Are the many Perl people here btw?
11:38:28 <mle> define "perl people"
11:38:39 <mercury^> People who are here because of Pugs.
11:38:43 <monochrom> doWhatIMean :: a -> b
11:38:51 <monochrom> Hell
11:38:51 <quicksilver> there are quite a few perl people here
11:38:54 <monochrom> doWhatIMean :: a
11:38:57 <quicksilver> I don't know how many of them are here because of pugs
11:39:12 <monochrom> Oh I haven't read xkcd today!
11:39:51 <lilac> monochrom: fix (\duck -> (duck:))
11:40:08 <monochrom> heh
11:40:11 * MyCatVerbs duckloops monochrom.
11:40:20 <FunctorSalad> the newest one is hilarious...
11:40:21 <monochrom> what is duckloop?
11:40:31 <pumpkin> the latest xkcd :P
11:40:32 <MyCatVerbs> monochrom: read xkcd. :)
11:40:42 * lilac is happy with his infinite type. it's ducks all the way across and down
11:41:18 <monochrom> I have just read xkcd. What is duckloop?
11:41:22 <hackage> Uploaded to hackage: clustertools 0.1.2
11:41:22 <hackage> Uploaded to hackage: bio 0.3.5
11:41:45 <pumpkin> monochrom: you don't read the tooltips? that's half the fun of xkcd
11:42:01 <monochrom> I have read the tooltips too. What is duckloop?
11:42:02 <quicksilver> @remember lilac is happpy with his infinite type. it's ducks all the way across and down.
11:42:02 <lambdabot> I will remember.
11:42:08 <pumpkin> o.O
11:42:19 <monochrom> You are not being helpful.
11:42:21 <mauke> monochrom: the thing depicted in the comic
11:42:27 <mauke> you are asking weird questions
11:42:42 <mercury^> I bet he read the ancient one posted before.
11:42:47 <mercury^> And thought it was the current one.
11:42:55 <monochrom> It does not refer to anything else? It is not a reference to something else?
11:43:08 <lilac> monochrom: just a neat idea :)
11:43:09 <mauke> well, to rickroll, indirectly
11:43:36 <monochrom> I guess I need to look up "rickroll" too. I never know what it means.
11:43:40 <mauke> (the original version was "duckroll")
11:43:57 <FunctorSalad> why is runPut (put (1.0 :: Double)) twenty-five frigging bytes long :o
11:44:02 <mauke> monochrom: http://encyclopediadramatica.com/Rickroll
11:44:08 <mercury^> Hmm, what was the largest rickroll pulled of to date?
11:44:14 <mercury^> off*
11:44:14 <FunctorSalad> (or apparently any double, for that matter)
11:44:36 <pumpkin> FunctorSalad: because they like to be IEEE-agnostic
11:44:40 <pumpkin> FunctorSalad: I was shocked too
11:44:46 <FunctorSalad> pumpkin: ah :)
11:44:51 <MyCatVerbs> mercury^: probably the Macy's day parade.
11:45:17 <FunctorSalad> pumpkin: it seems to sort-of defeat the purpose of Binary though
11:45:22 <lilac> mercury^: did you not see the US presidential inauguration? turns out that obama is rick astley in disguise
11:45:25 <MyCatVerbs> mercury^: http://www.youtube.com/watch?v=xWw46X-83xs
11:45:25 <pumpkin> FunctorSalad: I agree
11:45:37 <pumpkin> > encodeFloat (1.0)
11:45:38 <lambdabot>       Overlapping instances for Show (Int -> a)
11:45:38 <lambdabot>        arising from a use of ...
11:45:51 <quicksilver> FunctorSalad: how does that defeat the purpose of binary?
11:45:56 <pumpkin> > decodeFloat (1.0)
11:45:57 <lambdabot>   (4503599627370496,-52)
11:46:03 <FunctorSalad> quicksilver: I thought that was fast IO :)
11:46:04 <pumpkin> it's that, encoded into binary
11:46:07 <quicksilver> the purpose of the Data.Binary class is to give a platform-independent serialisation.
11:46:16 <FunctorSalad> (assuming that the length necessarily makes it slower too)
11:46:26 <FunctorSalad> hmm
11:46:34 <quicksilver> the purpose of Data.Binary.Put and Data.Binary.Get is for you to write your own binary input output that does what you want
11:46:37 <quicksilver> instead of that.
11:46:46 <quicksilver> so write your own Put/Get pair if that's what you want ;)
11:46:54 <pumpkin> FunctorSalad: an unsafeCoerce with a wrapper type is probably your best bet
11:47:03 <pumpkin> :P
11:47:03 <monochrom> I guess you guys are playing a recursion prank on me.  A. I read xkcd and see "duckloop"  B. I ask you what is duckloop.  C. You suggest me to goto A.
11:47:13 <lilac> DUCKLOOP'd
11:47:28 <quicksilver> monochrom: duckloop is a reference to duckroll. duckroll is a reference to rickroll.
11:47:36 <quicksilver> monochrom: like me, you're just not sufficiently up on the memes.
11:47:42 <MyCatVerbs> monochrom: we're not. Randall Munroe made the term up on the spot.
11:47:48 * pumpkin cakerolls everyone
11:47:58 <FunctorSalad> quicksilver: *nod*, should have done that instead of complaining ;)
11:48:13 <quicksilver> FunctorSalad: it is confusing that binary has two parts.
11:48:27 <quicksilver> one part (the class) is about an architecture neutral simple auto-serialisation.
11:48:33 <mauke> monochrom: no, the duck loop is in the comic
11:48:52 <quicksilver> the other part (the Get/Put monads) is about a way to build fast binary readers and writers.
11:48:53 <mauke> quicksilver: and no, duckroll can't be a reference to rickroll because duckroll is older
11:48:59 <mauke> no tying the knot here!
11:49:02 <quicksilver> mauke: oh, mea culpa.
11:49:08 <monochrom> Yeah yeah yeah, next time a Haskell newbie asks "what is typeclass" you don't explain it helpfully, you suggest him "have you looked at Haskell?"
11:49:53 <mauke> monochrom: if I linked you to the badger mushroom snake thing, would you ask "what's a badger badger badger?"
11:50:18 <monochrom> I would.
11:50:37 <monochrom> And what is the badger mushroom snake thing?
11:50:47 <MyCatVerbs> monochrom: it's locally defined.
11:51:13 <lilac> Q: What is general recursion? A: It's the simplest thing which is exactly like general recursion.
11:51:18 <mauke> monochrom: http://www.albinoblacksheep.com/flash/badgers
11:51:31 <monochrom> See, if you state "it's locally defined" or "it's coined by the author" that's ok.
11:51:32 <BONUS_> aaagh
11:51:33 <kerlo> So general recursion is the empty set? Hmm.
11:51:36 <Cale> If it loops like a duck...?
11:51:36 <BONUS_> nfs doesn't have screen installed
11:51:41 <BONUS_> whoops wrong channel lol
11:52:01 <mauke> the end is hilarious
11:52:17 <lilac> mauke: that's mean
11:52:28 <mauke> welcome2internets
11:52:45 <lilac> kerlo: no, the empty set isn't exactly like general recursion :)
11:52:52 <kerlo> True.
11:53:15 <monochrom> general recursion is general
11:53:24 <kerlo> I'm not sure I'm familiar with the term "general recursion". Is the halting problem generally recursive?
11:54:14 <lilac> kerlo: GR is a turing-complete model of computation
11:54:14 <drigz> threadDelay seems to be causing far too short a delay...
11:54:22 * kerlo nods
11:54:31 <quicksilver> drigz: it's denominated in microseconds
11:54:34 <MyCatVerbs> drigz: it's microseconds, IIRC. Just to check.
11:54:50 <drigz> quicksilver: wow, that was embarrassing
11:54:57 <drigz> i re-read the docs to check that it was in milliseconds
11:55:03 <drigz> and still read them wrong...
11:55:13 <lilac> kerlo: basically, it's the transitive closure under composition of some fairly simple functions plus a function that effectively finds the least integer where a property holds
11:55:13 <drigz> thank you!
11:56:14 <quicksilver> drigz: they both begin with 'm' and end in 'seconds' ;)
11:56:27 <quicksilver> and lots of other APIs use milliseconds
11:56:35 <quicksilver> sometimes we just see what we want to see :)
11:56:56 <Cale> General Recursion and Admiral Induction? :)
11:57:10 <pumpkin> lol
11:57:20 <dublpaws> :t flip map [map, filter] (\f xs -> map f xs)
11:57:21 <lambdabot> [[Bool -> Bool] -> [[Bool] -> [Bool]]]
11:57:37 <dublpaws> is there an easy way to generate an argument for things like that?
11:57:45 <Imagist_> I have a feeling that when I finally crack monads, they will have a soft creamy interior, but currently, I don't understand them, and in xenophobic fashion, I loath them
11:58:10 <kerlo> Written on a piece of math homework: "Admiral Induction! 5/5" Returned to the teacher with "Atroshis Spelling! 0/5"
11:58:12 <monochrom> Command & Conquer: General Recursion and Admiral Induction, expansion kit Zero Ordinal
11:58:40 <dublpaws> Imagist_: chapter 14 of real world haskell explains them extensively
11:59:20 <lilac> Imagist_: don't look to hard at the interior, though, because if you fall in you won't be able to get out again
11:59:42 <FunctorSalad> if you gaze into the monad for too long, the monad also gazes into you
11:59:43 <Cale> Imagist_: Do you know roughly what an embedded domain specific language is?
11:59:55 <Cale> Imagist_: Or a combinator library?
12:00:02 <Imagist_> dublepaws, I am typing on a brand new laptop that has left me broke, so if I want to eat, I cannot spend my money on books, no matter how much I want them
12:00:11 <Imagist_> Cale, yes to the first, no to the second
12:00:16 <kerlo> Now, I remember a type theory or a set of operations on sets or something. One operator was tagged union (or possibly ordinary union), one operator was Cartesian product, and the mu and nu operators were greatest and least fixed point, though I don't remember which was which.
12:00:33 <Saizan> Imagist_: real world haskell is available online from the website, fyi
12:00:41 <Cale> Imagist_: Okay, so a monad is just a particular kind of EDSL which implements a particular means of combining computations.
12:00:54 <Imagist_> saizan: !!!
12:01:02 <Imagist_> why did I not know this!!!
12:01:08 <Cale> Imagist_: The point is so that we can write various bits of code then which will work in all of these EDSLs.
12:01:44 <Saizan> kerlo: nu is usually greatest
12:02:04 <lilac> > (map.map) ($[True,False]) $ map ($[id,not]) (flip map [map, filter] (\f xs -> map f xs)) -- dublpaws
12:02:06 <lambdabot>   [[[True,False],[False,True]],[[True],[False]]]
12:02:41 <Cale> Imagist_: They range from extremely simple (lists form a monad, functions from a fixed type form another), to more complex (parsers, I/O actions, transactions in a system for concurrent memory access)
12:03:16 <Cale> Imagist_: and there's a bunch of functions which will work in all those contexts, and do related, but ultimately context-dependent things.
12:03:25 <dublpaws> > flip map [map, filter] (\f xs -> map f xs) [[[True,False],[False,True]],[[True],[False]]]
12:03:26 <lambdabot>   Couldn't match expected type `[[[Bool]]] -> t'
12:03:38 <drigz> why is this complaining? http://pastebin.ca/1323049
12:03:59 <grahamhutton> Imagist_: I'm teaching an advanced FP course about monads at the moment --- some notes available from http://www.cs.nott.ac.uk/~gmh/monads which may be helpful.
12:04:18 <dublpaws> sorry for the pollution, thanks lilac, I'll try to see what you did there.
12:04:24 <lilac> dublpaws: (flip map [map, filter] (\f xs -> map f xs)) is not a function, it's a list of functions, each of which is from a list of functions from Bool to Bool to a list of functions from lists of Bool to lists of Bool :)
12:05:16 <dublpaws> lilac: that explains it, wunderbar!
12:05:37 <Cale> Imagist_: That gives a general sense of why we'd be interested in them perhaps, but to understand what a monad is, you just have to know what the common operations are, and then look at a bunch of examples of them to get a sense for how they can be implemented.
12:06:03 <Imagist_> Sorry for the delay in posting, I'm looking at the links you guys posted
12:06:07 <Imagist_> Thanks for your help
12:06:54 <monochrom> It will take a while to learn monads (or anything new).
12:06:56 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]] -- example of using sequence in the list monad
12:06:58 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
12:07:17 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5 -- in the function monad
12:07:18 <lambdabot>   [5,7,10,25,32]
12:07:32 <Cale> and in, say, a parsing monad, it would be the concatenation of the list of parsers
12:07:49 <FunctorSalad> Cale: just curious... did you use the EDSL picture of monads because it has proved best for teaching?
12:07:54 <Cale> In the IO monad, it gives the IO action which runs each of the actions in the list in turn and collects a list of the results.
12:08:04 <Imagist_> Cale, is the monad sort of like a first-class function, then?
12:08:21 <Cale> Imagist_: A monad is a particular type constructor, together with some operations that go along with it.
12:08:51 <Cale> Imagist_: and those operations are required to interact nicely in a few simple ways
12:09:06 <Cale> Imagist_: They're specific operations, so just saying that doesn't really define what a monad is.
12:09:21 <Cale> Specifically, for a monad M, we have:
12:09:22 <Imagist_> Okay
12:09:25 <Cale> return :: a -> M a
12:09:45 <Cale> and (>>=) :: M a -> (a -> M b) -> M b -- pronounced 'bind'
12:09:53 <monochrom> Perhaps Functors should be learned before Monads. Not because of their relation. Because you have to nail the idea of one-parameter typeclass first.
12:10:02 <Cale> monochrom: yes
12:10:12 <monochrom> Err not one-parameter typeclass. Something.
12:10:20 <Cale> monochrom: Type constructor?
12:10:26 <Cale> and after all, every monad is also a functor
12:10:58 <Imagist_> I know what functors are in other languages, are they the same in Haskell?
12:10:58 <Cale> Imagist_: A functor is a type constructor f together with an operation  fmap :: (a -> b) -> f a -> f b
12:11:03 <monochrom> A typeclass that wants its instances to be one-parameter type constructors.
12:11:21 <Cale> For example, lists are a functor with the standard map function as fmap.
12:11:32 <Cale> > fmap (+10) [1,2,3,4,5]
12:11:33 <lambdabot>   [11,12,13,14,15]
12:11:35 <dons> ?users
12:11:35 <lambdabot> Maximum users seen in #haskell: 658, currently: 652 (99.1%), active: 25 (3.8%)
12:11:38 <Cale> Maybe is also a functor
12:11:45 <Cale> > fmap (+10) (Just 7)
12:11:46 <grahamhutton> hi dons!
12:11:47 <lambdabot>   Just 17
12:11:57 <monochrom> "typeclass FunnyTypeClass c where funnyop :: .... c a ..."
12:12:08 <Cale> monochrom: Constructor classes, then.
12:12:35 <SamB_irssi> Imagist_: which other languages? also, probably not.
12:12:42 <Imagist_> graham, what's the main page for your class?
12:12:49 <Cale> Imagist_: So one way to picture a functor is that it's a data structure for which we have a way to apply a function to all the "elements" of the data structure.
12:12:51 <Imagist_> SamB, python, C
12:12:55 <Imagist_> C++
12:12:56 <sioraiocht> dcoutts: did you get a change to look at those quickcheck tests?
12:13:12 <Gracenotes> I am also a functor. If you tell me to run a function of type (a -> b), I will do so with an a and hold a result. You can retrieve the result by asking me what it is.
12:13:13 <SamB_irssi> C doesn't have anything called a functor
12:13:14 <ray> functors in those other languages are weird and incomprehensible and
12:13:28 <Cale> Imagist_: Do functors in those languages refer to a sort of strange workaround for not having first class functions?
12:13:32 <ray> gracenotes: be careful, someone will take you up on that
12:13:33 <SamB_irssi> I don't think they call anything that in Python either ?
12:13:42 * Gracenotes is also a monad, but doesn't plan to write a tutorial on that just yet
12:13:48 <Cale> Imagist_: If that's what you mean, then no, it's not the same ;)
12:13:51 <grahamhutton> Imagist_: http://www.cs.nott.ac.uk/~gmh/afp.html
12:13:51 <Imagist_> Cale, basically
12:13:52 <SamB_irssi> Cale: well, I think the python thing he's talking about is objects with __call__ methods
12:13:59 <ray> an illustrated children's book
12:14:01 <SamB_irssi> but I'm fairly certain those are just called callable
12:14:03 <monochrom> c++ functors are unrelated
12:14:04 <ray> "I am a a monad"
12:14:18 <Cale> There's also the ML-module-system sort of functor.
12:14:26 * SubStack waves at the monad
12:14:34 <gnuvince> "Hello, my name is Maybe, and I am a monad"
12:14:36 <Gracenotes> will the real monad please stand up?
12:14:36 <ray> you write it, i'll illustrate it, we'll make millions
12:14:37 <gnuvince> "Hello Maybe"
12:14:59 <Gracenotes> ray: I also get royalties for the idea
12:15:00 <Cale> Imagist_: I should really check: you're clear on what a type constructor is?
12:15:09 <ray> maybe do a series.. "I am a functor", "I am an arrow"
12:15:34 <Gracenotes> we can also have some GED-type psuedo-educational dialogues
12:15:39 <SubStack> it could be a page about mathematical diversity
12:15:44 <Cale> Imagist_: (if you're not, I'll explain :)
12:15:46 <Gracenotes> "What do you do, Mr. Monad?"
12:15:57 <Olathe> Hmm...apparently when you make instances for all tuples up to 62-tuples, compiling takes a while.
12:16:12 <SubStack> o_O
12:16:14 <sioraiocht> Olathe: why? =p
12:16:30 <gnuvince> "Hi, I'm a Monad"
12:16:32 <Imagist_> I'm not, but perhaps I shouldn't bother you with that; now I know I need some prerequisite knowledge, and I have a decent idea of what it is
12:16:34 <gnuvince> "And I'm a PC"
12:16:37 <monochrom> "I'm a monad and so can you!"
12:16:43 * ray would stop at 3-tuples
12:16:57 <Imagist_> I'll look it up myself, and then come back if I have any questions
12:16:59 <Cale> Imagist_: okay... well, it won't trouble me to explain, anyway :)
12:17:17 <Gracenotes> "As for me, I'm a function that takes an unwrapped value and wraps it up in a monad!"
12:17:30 <Raevel> good for you
12:17:30 <Gracenotes> "That's interesting. You see, I'm a function that takes an unwrapped value and wraps it up in a monad, but a monad of a different type."
12:17:35 <monochrom> "I differentiate functors."
12:17:37 <Cale> Imagist_: In Haskell, we can define data types which are parametrised by other data types -- they act a bit like functions which send types to other types.
12:17:37 * CosmicRay starts prepping HDBC 2.0 for upload.  https://software.complete.org/software/wiki/hdbc/NewIn20
12:17:40 <RedBolt> if i have a function type: func::(Ord b)=>[(a,b)]->[(a,b)] can someone tell me how to order that function by comparing the value b in that list?
12:17:48 <Olathe> sioraiocht: Not sure :)
12:17:49 <Gracenotes> "Suppose we bound together? What do you think would happen then?"
12:17:57 <Cale> Imagist_: For example, for any type t, there's a type [t] of lists of elements of type t
12:18:04 <Gracenotes> and that's how "return a >>= f" was born.
12:18:12 <int-e> 'return' would be more aptly named 'noreturn' ;-)
12:18:20 <Cale> Imagist_: For any types a and b, there's a type a -> b of functions which take a parameter of type a, and give a result of type b
12:18:42 <Cale> Imagist_: Or you might have a binary tree datatype like Tree a, whose nodes are labelled with elements of type a
12:19:08 <monochrom> do { putStrLn "begin"; noreturn 0; putStrLn "hey I got past the point of no return!" }
12:19:14 <Cale> The syntax for defining a type like that looks like:  data Tree a = Tip | Branch a (Tree a) (Tree a)
12:19:25 <int-e> return :: Monad m => m a -> a -- "give it back!"
12:19:48 <Cale> And then, for example, a value of type Tree Integer, might look like  Branch 5 (Branch 3 Tip Tip) (Branch 7 (Branch 6 Tip Tip) Tip)
12:20:28 <Gracenotes> > runWriter $ do { tell "Bridge"; fail "YOU.. SHALL.. NOT.. PASS!"; tell "Other side" }
12:20:29 <lambdabot>   ((),"Bridge* Exception: YOU.. SHALL.. NOT.. PASS!
12:20:32 <monochrom> Gracenotes: So where do baby monads come from?  <duck>
12:20:51 <Cale> Imagist_: So, they're datatypes whose structure depends on another datatype.
12:20:58 <ray> not duck, stork
12:20:58 <Imagist_> Yeah
12:21:26 <Cale> Imagist_: Knowing this, we can take another look at the type of fmap :: (Functor f) => (a -> b) -> f a -> f b
12:21:47 <Cale> Imagist_: It says that if the type constructor f is a Functor, then it takes a function from a's to b's
12:21:52 <Gracenotes> monochrom: from the return machine
12:21:55 <Cale> and an f-structure filled with a's
12:22:05 <Cale> and gives an f-structure filled with b's.
12:22:19 <Cale> So, it's going to be applying the function to all the 'elements' of that structure somehow.
12:22:21 <Gracenotes> monochrom: you insert a value. Then it gestates and gives you a monad
12:22:43 <Imagist_> Cale, question
12:22:45 <Cale> sure
12:23:11 <Imagist_> if we have a function x that takes something type a and returns something type b
12:23:17 <Cale> okay
12:23:23 <Imagist_> then map x would return a functor?
12:23:33 <Cale> map x would return another function
12:23:36 <trofi> :k (map x)
12:23:37 <lambdabot> Not in scope: type variable `map'
12:23:37 <lambdabot> Not in scope: type variable `x'
12:23:53 <Cale> map :: (a -> b) -> [a] -> [b]
12:23:57 <Cale> We can read that as:
12:24:02 <trofi> :k (a b c d e)
12:24:03 <lambdabot> Not in scope: type variable `a'
12:24:03 <lambdabot> Not in scope: type variable `b'
12:24:03 <lambdabot> Not in scope: type variable `c'
12:24:04 <Cale> map :: (a -> b) -> ([a] -> [b])
12:24:10 <benmachine> :t (map id)
12:24:11 <lambdabot> forall a. [a] -> [a]
12:24:24 <trofi> :t (map map)
12:24:25 <lambdabot> forall a b. [a -> b] -> [[a] -> [b]]
12:24:31 <Cale> so it takes a function from a's to b's, and gives a function from lists of a's to lists of b's.
12:24:48 <Cale> The functor here is "lists" though.
12:25:04 <Imagist_> okay
12:25:08 <leimy> Is it safe to think of functor as "container"?
12:25:12 <Cale> "Functor" always refers to the kind of datastructure.
12:25:16 <Gracenotes> :k Functor
12:25:17 <lambdabot> Class `Functor' used as a type
12:25:21 <Gracenotes> oh. duh
12:25:23 <Cale> leimy: basically, if you don't read too much into it
12:25:35 <Cale> Some of these "containers" can be very abstract.
12:25:47 <Gracenotes> a functor can probably also be thought of as a computation, then? :P
12:25:51 <Cale> Gracenotes: yes
12:25:54 <leimy> right but if you have a Type that is itself parameterized by types
12:25:56 <monochrom> "container" is broad. it's always safe.
12:26:00 <leimy> like Tree a
12:26:05 <leimy> then
12:26:11 <leimy> Tree Int and Tree String are distinct
12:26:23 <leimy> If Tree a is of functor
12:26:28 <Olathe> @hoogle (a -> Bool) -> String -> a -> a
12:26:28 <lambdabot> Foreign.C.Error throwErrnoIfRetry :: (a -> Bool) -> String -> IO a -> IO a
12:26:28 <lambdabot> Foreign.C.Error throwErrnoPathIf :: (a -> Bool) -> String -> FilePath -> IO a -> IO a
12:26:28 <lambdabot> Foreign.C.Error throwErrnoIf_ :: (a -> Bool) -> String -> IO a -> IO ()
12:26:32 <leimy> you have a way to go from Tree Int to Tree String
12:26:34 <Gracenotes> it would probably be possible to mirror the Monads as computations/containers pages for Functors
12:26:36 <leimy> fmap (show)
12:26:42 <Gracenotes> not mirror exactly, but the general principle
12:27:05 <Gracenotes> you could even say... there's a functor between the two
12:27:31 <leimy> I think of functor, when in Haskell, as "being able to apply fmap" :-)
12:27:32 <Cale> From the computations perspective, a functor is a kind of computation for which you have a way to apply an arbitrary function to the result, getting another computation.
12:28:15 <leimy> and I think that canonical fmap is typically "get at the inner type of a parameterized type, apply a function, and re-wrap it"
12:28:23 <leimy> however in the case of things like Maybe that gets more complicated
12:28:32 <Gracenotes> Cale: by "the result" you mean a Functor f -> f a, right?
12:28:34 <leimy> because Maybe represents non-values as well as values :-)
12:28:48 <Gracenotes> where the arbitrary function is (a -> b)
12:28:52 <Cale> If you pick a type e, then functions from e to other types are a functor. You can either think of such a function as a container which is indexed by elements of type e, or as a computation which reads from a value of type e.
12:29:18 <Cale> > fmap (*2) (+5) 0
12:29:19 <lambdabot>   10
12:29:26 <asgaroth> Is there some way to get a more intuitive understanding of functions written with fix? (Currently I need to `expand' them a few times, in my head or on paper, to get it)
12:29:36 <dublpaws> so the function monad detects different stages of partial application and makes sure the next argument is absorbed correctly..?
12:29:46 <Cale> fmap then applies the function to all the results of the function, but what is that? It's function composition of course!
12:29:47 <sioraiocht> asgaroth: are you familiar with the concept of a fixpoint function in general?
12:29:58 <asgaroth> sioraiocht: yes
12:30:06 <Cale> Er, that is, fmap f g applies f to all the results of g
12:30:19 <Cale> giving a new function
12:30:26 <sioraiocht> asgaroth: so all fix does allow implemenataiton of fixpoint functions by giving a local name to the function being applied
12:30:27 <sioraiocht> :t fix
12:30:28 <lambdabot> forall a. (a -> a) -> a
12:30:38 <Gracenotes> Cale: I'm still not positive what you mean by "the results"
12:30:45 <Cale> Gracenotes: the codomain?
12:31:03 <Imagist_> Cale, thanks for your help, I really need to go
12:31:05 <sioraiocht> > fix (\f n -> if 0 then 1 else n * f (n-1)) 5
12:31:06 <lambdabot>       No instance for (Num Bool)
12:31:06 <lambdabot>        arising from the literal `0' at <inte...
12:31:08 <Gracenotes> don't apply f to the domain, which yields the codomain?
12:31:12 <Gracenotes> *don't you
12:31:17 <sioraiocht> > fix (\f n -> if n == 0 then 1 else n * f (n-1)) 5
12:31:18 <lambdabot>   120
12:31:26 <int80_h> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1066#a1066
12:31:29 <Cale> Gracenotes: You can think of a function e -> a as a giant box which is split up into compartments. Each compartment is labelled with a value of type e, and inside the compartment is a value of type a.
12:31:34 <int80_h> this is an euler project problem
12:31:40 <benmachine> :t fix
12:31:41 <lambdabot> forall a. (a -> a) -> a
12:31:48 <int80_h> sum up all the primes less than 2 million
12:31:52 <sioraiocht> asgaroth: in that example, the first argument, f, is just the fixpoint function, and the rest of the arguments are the arguments that will be passed to the fixpoint function at each iteration
12:32:00 <Cale> Gracenotes: fmap f then applies the function f to each of the things inside the compartments.
12:32:03 <asgaroth> sioraiocht: Things like writing the list of fibonacci numbers with fix and scanl is particularly confusing
12:32:05 <int80_h> but it's cumputing, several minutes later
12:32:13 <int80_h> could someone take a peek?
12:32:18 <benmachine> int80_h: there are a lot of ways to speed up calculating primes
12:32:22 <asgaroth> I think I understand how it works, but I always have to expand them manually
12:32:32 <sioraiocht> asgaroth: example/
12:32:33 <Cale> Gracenotes: is that clearer?
12:32:38 <benmachine> I can help you algorithmically but not haskelly unfortunately
12:32:44 <asgaroth> sioraiocht: `fix ((0:) . scanl (+) 1)'
12:32:51 <sioraiocht> okay
12:33:02 <Cale> Gracenotes: When you evaluate the function at a particular value of type e, you just look up the box which is labelled with that value, and get what's stored in that compartment. :)
12:33:03 <sioraiocht> :t ((0:)
12:33:04 <int80_h> benmachine : I'm not sure my prime number generator is at fault here
12:33:04 <lambdabot> parse error (possibly incorrect indentation)
12:33:08 <sioraiocht> :t (0:)
12:33:09 <lambdabot> forall t. (Num t) => [t] -> [t]
12:33:17 <Gracenotes> Cale: that makes perfect sense, but I still don't see how you "apply f to the results of g"
12:33:18 <sioraiocht> :t scanl (+) 1
12:33:19 <int80_h> I've used it for a few problems before, seems fine
12:33:20 <lambdabot> forall a. (Num a) => [a] -> [a]
12:33:31 <Gracenotes> by results, do you mean "unwrapped value of" (so to say)?
12:33:32 <Cale> Gracenotes: the results of g are the things stored in the compartments
12:33:39 <Gracenotes> ah, okay
12:33:54 <Gracenotes> is that a CT term?
12:33:57 <Cale> no
12:33:59 <kerlo> Cute how lambdabot says "possibly incorrect indentation".
12:34:03 <benmachine> int80_h: it's easy to make an accurate prime generator, not so much a fast one :P
12:34:05 <asgaroth> As I said, I figured out how the evaluation takes place, but that was kinda hard work. So I'm looking for a more "idiomatic" way to understand this sort of functions.
12:34:18 <sioraiocht> :T fix ((0:) . scanl (+) 1)
12:34:22 <sioraiocht> :t fix ((0:) . scanl (+) 1)
12:34:23 <lambdabot> forall a. (Num a) => [a]
12:34:24 <benmachine> int80_h: well, I'll help as much as I can (which will probably not be very much)
12:34:40 <Gracenotes> Cale: okay... thanks for the explanation :)
12:34:41 <int80_h> benmachine: as I said before, my prime generator seems fine. I think it make be my summing function
12:34:46 <Cale> Gracenotes: I'm trying to get you to picture something like the mailboxes in an apartment building ;)
12:34:55 <pumpkin> or pigeonholes!
12:35:04 <Cale> Gracenotes: Of course, we just end up writing  fmap f g x = f (g x)
12:35:12 <Cale> Or fmap f g = \x -> f (g x)
12:35:26 <dublpaws> > fmap (*2) (+5) (*11) 1
12:35:26 <Cale> But there are a bunch of ways to look at that :)
12:35:28 <lambdabot>       No instance for (Num (a -> a))
12:35:28 <lambdabot>        arising from the literal `2' at <...
12:35:37 <benmachine> int80_h: k, I'll trust you on that
12:35:45 <Cale> dublpaws: You'll need another fmap for that.
12:35:50 <int80_h> I really don't know though
12:35:50 <Gracenotes> yes, that's already clear. When you say the "results of" something, it sounds like there's an unwrapped operation -- which there isn't always..
12:35:56 <pumpkin> > map (($1) . flip uncurry ((+1), (*2))) [(>>), (<<<), (>>>), (.)]
12:35:58 <Gracenotes> *unwrapping operation
12:35:59 <lambdabot>   [2,3,4,3]
12:36:05 <pumpkin> that's kinda fishy
12:36:06 <pumpkin> :)
12:36:11 <sioraiocht> asgaroth: that function is particularly idiomatic, if you understand it, i would be satisfied.  not all of those fnctions are meant to be super clear, just oneliners =)
12:36:16 <Cale> Gracenotes: well... there is, sort of
12:36:21 <Cale> Gracenotes: it's function application
12:36:22 <sioraiocht> asgaroth: the best way is probaly to write a few similar functions yoruself
12:36:32 <int80_h> have we been having alot of spam bots lately?
12:36:58 <asgaroth> sioraiocht: Okay, I'll try to transform some of the standard recursive functions with fix.
12:37:02 <Cale> Gracenotes: We construct the function which, given an x, applies g to x (unwrapping the element of g, in a sense), and then applies f to that
12:37:39 <Cale> It's just a little odd to think of functions in this way.
12:38:01 <dublpaws> is that unthunking?
12:38:09 <Cale> We're perhaps more used to functions as *doing* rather than *being*
12:38:22 <Gracenotes> Cale: that's true enough. Although, you can't unwrap a list, per se, then apply f to the unwrapped value, then wrap it up again and make it a [b]
12:38:39 <Cale> And of course, the 'elements' of a function usually never exist in memory all at once.
12:38:50 <sereven> hmm, nicer way to http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1067 ?
12:38:53 <Cale> Gracenotes: well, you can pattern match it...
12:39:28 <Gracenotes> yeah... there's no guarantee of how many times f will be needed in the internals of an fmap implementation
12:39:35 <Cale> right
12:39:54 <Cale> pattern matching is to lists what function application is to functions ;)
12:40:31 <vixey> huh
12:40:33 <dublpaws> Cale: because they're both monadic?
12:41:16 <Cale> dublpaws: well... I'm relating their implementations of fmap, so it's not even the monadic structure, but the fact that they're functors.
12:41:22 <hackage> Uploaded to hackage: vector-space 0.5.3
12:41:22 <hackage> Uploaded to hackage: xml2x 0.4
12:41:22 <hackage> Uploaded to hackage: korfu 0.1
12:41:22 <hackage> Uploaded to hackage: flower 0.1
12:41:22 <hackage> Uploaded to hackage: estreps 0.3
12:42:01 <Cale> A more meaningful comparison is that map is to lists what composition is to functions
12:42:03 <redditbot> Elegant Functional Programming: Adding it Up
12:42:03 <redditbot> F# and Haskell, Estranged Cousins
12:42:20 <Cale> map :: (a -> b) -> [a] -> [b]
12:42:28 <dublpaws> so where are the composers?
12:42:28 <Cale> (.) :: (a -> b) -> (e -> a) -> (e -> b)
12:43:13 <Cale> The difference in the types is that [...] has been replaced with (e -> ...)
12:43:25 <Gracenotes> oh, nice. So e could be the robot monkey, or something :P
12:43:46 <Cale> Could be Integer, or Bool, or whatever...
12:44:29 <Cale> oh, if by the robot monkey, you mean (:[])
12:44:36 <Cale> then the corresponding function is const
12:44:39 <Gracenotes> yeah :X
12:44:45 <Cale> const :: a -> (e -> a)
12:44:52 <Cale> (:[]) :: a -> [a]
12:45:03 <Cale> Of course, they're both implementations of return
12:45:15 <Gracenotes> yeah.
12:45:44 <dublpaws> the lists (,) is  short for the :(, and thats a  List -> List
12:46:03 <Cale> (:) :: a -> [a] -> [a]
12:46:03 <athos> :t (:()
12:46:05 <lambdabot> parse error (possibly incorrect indentation)
12:46:12 <athos> :>
12:46:43 <Cale> :t (:)
12:46:44 <lambdabot> forall a. a -> [a] -> [a]
12:46:56 <Cale> > 1 : 2 : 3 : 4 : 5 : []
12:46:58 <lambdabot>   [1,2,3,4,5]
12:47:05 <Cale> > (:[]) 1
12:47:08 <lambdabot>   [1]
12:47:18 <benmachine> > :--)
12:47:20 <lambdabot>   <no location info>: parse error on input `:--'
12:47:59 <Cale> :-- is a valid name for a data constructor though :)
12:48:11 <Cale> So you could have (:--)
12:48:25 <athos> > foldr f z [a,b,c]
12:48:28 <lambdabot>   f a (f b (f c z))
12:49:00 <vixey> I used :- for a prolog thing
12:49:04 <opqdonut> hehe
12:49:07 <Cale> > foldr (:) [] [1,2,3]
12:49:10 <lambdabot>   [1,2,3]
12:49:13 <Cale> > foldr (:) [4,5] [1,2,3]
12:49:24 <lambdabot>   [1,2,3,4,5]
12:49:30 <benmachine> Cale: I was aiming for a comment marker, did I miss?
12:49:58 <Cale> benmachine: oh, -- won't start a comment if it's preceded by other symbol characters
12:50:20 <Cale> benmachine: because it's a valid part of an infix operator
12:50:27 <benmachine> oh ok
12:50:33 <athos> :t foldM
12:50:34 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
12:50:34 <benmachine> does the same apply to {-
12:50:51 <Cale> { isn't allowed in infix operators, so I don't think so.
12:51:35 <Cale> Too bad, really, { and } would make good bits of arrow-like operator names ;)
12:51:50 <pumpkin> {- is a comment
12:51:52 <pumpkin> so I doubt it
12:52:04 <Cale> pumpkin: Well, the thing is that *-- is not a comment.
12:52:16 <vixey> I would like outfix
12:52:19 <pumpkin> ah, interesting
12:52:20 <Cale> > let x *-- y = x + y in 5 *-- 6
12:52:23 <lambdabot>   11
12:52:55 <athos> > filterM (const [True, False]) [1,2,3]
12:52:58 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
12:53:17 <athos> that's weird 8)
12:53:19 <dublpaws> > foldl (:) [1,2] [3,4,5]
12:53:22 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
12:53:22 <lambdabot>        Expect...
12:53:28 <pumpkin> > filterM f [1,2,3]
12:53:30 <lambdabot>       No instance for (Show (m [a]))
12:53:30 <lambdabot>        arising from a use of `show' at <...
12:53:36 <Cale> athos: Actually, I think it's the clearest implementation of that function I've ever seen.
12:53:39 <pumpkin> > filterM f [1,2,3] :: [Expr]
12:53:41 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[a]'
12:53:45 <pumpkin> > filterM f [1,2,3] :: [[Expr]]
12:53:46 <athos> > filmterM f [a,b,c]
12:53:48 <lambdabot>       No instance for (SimpleReflect.FromExpr [Bool])
12:53:48 <lambdabot>        arising from a u...
12:53:48 <lambdabot>   Not in scope: `filmterM'
12:53:50 <baaba> :t filterM
12:53:51 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
12:53:52 <athos> > filterM f [a,b,c]
12:53:54 <lambdabot>       No instance for (Show (m [Expr]))
12:53:54 <lambdabot>        arising from a use of `show' a...
12:53:59 <Cale> athos: It says "for each element of the list, regardless of its value, keep it or throw it away"
12:54:00 <athos> whoops.
12:54:15 <pumpkin> simplereflect fail
12:54:26 <athos> @src filterM
12:54:26 <lambdabot> Source not found.
12:54:45 <Cale> pumpkin: I don't think you can really blame simplereflect there...
12:54:49 <drigz> has anyone here used yampa?
12:54:55 <pumpkin> Cale: :(
12:55:24 <athos> hmpf
12:55:25 <athos> :t filterM
12:55:27 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
12:55:37 <Cale> athos: It's like  filterM f [] = return []; filterM f (x:xs) = do b <- f x; ys <- filterM f xs; return (if b then x:ys else ys)
12:55:48 <Cale> So:
12:56:05 <Cale> filterM (const [True, False]) [] = return [] = [[]]
12:56:38 <Cale> filterM (const [True, False]) (x:xs) = do b <- (const [True, False]) x; ys <- filterM (const [True, False]) xs; return (if b then x:ys else ys)
12:56:56 <Cale> = do b <- [True, False]; ys <- filterM (const [True, False]) xs; return (if b then x:ys else ys)
12:57:20 <pumpkin> I see :)
12:57:59 <athos> now *that* is cool
12:58:02 <Cale> So literally: for each element of the list, regardless of its value, either keep it or drop it.
12:58:29 <Cale> (The choice of b is the decision about whether to keep or drop the element)
12:59:01 <Cale> and the list monad ensures that this decision is made in all possible ways
12:59:28 <Cale> > filterM (\x -> if even x then [False] else [True, False]) [1,2,3,4]
12:59:31 <lambdabot>   [[1,3],[1],[3],[]]
12:59:36 <Cale> > filterM (\x -> if even x then [True] else [True, False]) [1,2,3,4]
12:59:39 <lambdabot>   [[1,2,3,4],[1,2,4],[2,3,4],[2,4]]
13:00:41 <pumpkin> pretty neat :)
13:00:43 <Cale> > filterM (\x -> [isUpper x, x `elem` "aeiou"]) "Hello, there!"
13:00:45 <lambdabot>   ["H","H","He","He","H","H","He","He","He","He","Hee","Hee","He","He","Hee",...
13:01:02 <Cale> > filterM (\x -> [isUpper x, x `elem` "aeiou"]) "Hey"
13:01:05 <lambdabot>   ["H","H","He","He","","","e","e"]
13:01:41 <Cale> > filterM (\x -> nub [isUpper x, x `elem` "aeiou"]) "Hey"
13:01:43 <lambdabot>   ["H","He","","e"]
13:01:55 <opqdonut> > filterM (const [True,False]) [1,2,3]
13:01:58 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
13:02:20 <Cale> > replicateM 5 "01"
13:02:23 <lambdabot>   ["00000","00001","00010","00011","00100","00101","00110","00111","01000","0...
13:02:38 <elly> wait, replicateM?
13:02:38 <athos> hehe
13:02:41 <elly> :t replicateM
13:02:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
13:02:44 <hydrapheetz> ... Neat.
13:02:46 <elly> :t replicate
13:02:47 <lambdabot> forall a. Int -> a -> [a]
13:02:48 <athos> > length $ replicateM 5 "01"
13:02:49 <elly> aha!
13:02:51 <lambdabot>   32
13:02:51 <elly> I have often wanted that
13:03:13 <hydrapheetz> > replicateM 2 "01"
13:03:15 <lambdabot>   ["00","01","10","11"]
13:03:27 <elly> @where replicateM
13:03:27 <lambdabot> I know nothing about replicatem.
13:03:31 <elly> hm
13:03:32 <athos> :>
13:03:36 <elly> @hoogle replicateM
13:03:37 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
13:03:37 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
13:03:37 <Cale> > [1..] >>= \k -> replicateM k "01"
13:03:40 <lambdabot>   ["0","1","00","01","10","11","000","001","010","011","100","101","110","111...
13:04:02 <pumpkin> can you make it count in order?
13:04:16 <pumpkin> I guess not, because of the duplicated 00s
13:04:30 <Cale> well... in that case yeah, there's not a lot you can do about it.
13:04:34 <kerlo> > map ('1':) ([1..] >>= \k -> replicateM k "01")
13:04:35 <lambdabot>   ["10","11","100","101","110","111","1000","1001","1010","1011","1100","1101...
13:04:40 <Cale> It's handy for identifiers.
13:04:42 <kerlo> Voila.
13:04:52 <Cale> > [1..] >>= \k -> replicateM k ['a'..'z']
13:04:53 <lambdabot>   ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s...
13:04:54 <pumpkin> :)
13:05:07 <Cale> > drop 25 $ [1..] >>= \k -> replicateM k ['a'..'z']
13:05:08 <lambdabot>   ["z","aa","ab","ac","ad","ae","af","ag","ah","ai","aj","ak","al","am","an",...
13:05:25 <Cale> > drop (26^2 - 1) $ [1..] >>= \k -> replicateM k ['a'..'z']
13:05:26 <lambdabot>   ["yz","za","zb","zc","zd","ze","zf","zg","zh","zi","zj","zk","zl","zm","zn"...
13:05:37 <hiredman> nice
13:05:46 <ksf> > [1..] >>= \k -> replicateM k "10"
13:05:47 <lambdabot>   ["1","0","11","10","01","00","111","110","101","100","011","010","001","000...
13:05:58 <pumpkin> > elemIndex "aardvark" $ [1..] >>= \k -> replicateM k ['a'..'z']
13:06:02 <pumpkin> ;)
13:06:12 <pumpkin> something tells me it'll die
13:06:44 <Cale> > drop (27*26 - 3) $ [1..] >>= \k -> replicateM k ['a'..'z']
13:06:50 <Cale> oh.
13:07:07 <pumpkin> did it die?
13:07:10 <pumpkin> :(
13:07:14 <ksf> @bot
13:07:14 <lunabot>  :)
13:07:15 <lambdabot>   mueval: Prelude.read: no parse
13:07:15 <lambdabot> :)
13:07:19 <lambdabot>   ["zx","zy","zz","aaa","aab","aac","aad","aae","aaf","aag","aah","aai","aaj"...
13:07:23 <roconnor> :)
13:07:24 <pumpkin> > elemIndex "sky" $ [1..] >>= flip replicateM ['a'..'z']
13:07:25 <lambdabot>   Just 13154
13:07:30 <dublpaws> dropWhile all "0"?
13:07:38 <Cale> There's a better way to compute the index
13:07:44 <pumpkin> > elemIndex "cale" $ [1..] >>= flip replicateM ['a'..'z']
13:07:45 <lambdabot>   Just 53720
13:07:46 <pumpkin> Cale: I know :)
13:09:02 <pumpkin> > foldl (\x y -> x * 26 + y) 0 $ map (\x -> (ord x) - (ord 'a')) "aardvark"
13:09:03 <lambdabot>   203723868
13:09:24 <pumpkin> > foldl (\x y -> x * 26 + y) 0 $ map ((-) `on` ord) "aardvark"
13:09:24 <lambdabot>       No instance for (Num (Char -> Int))
13:09:25 <lambdabot>        arising from the literal `26...
13:09:37 <pumpkin> hmmoh duh
13:09:42 <pumpkin> :)
13:09:48 <pumpkin> I'll kiss
13:10:08 <pumpkin> > ([1..] >>= flip replicateM ['a'..'z']) !! 1000000
13:10:10 <lambdabot>   "bdwgo"
13:10:12 <pumpkin> > ([1..] >>= flip replicateM ['a'..'z']) !! 10000000
13:10:17 <lambdabot>   "uvxwk"
13:10:35 <pumpkin> > ([1..] >>= flip replicateM ['a'..'z']) !! 203723868
13:10:45 <pumpkin> hmm, I probably did something wrong
13:10:52 <pumpkin> that number looks too small
13:11:06 <pumpkin> aw
13:11:09 <Cale> whoa...
13:11:14 <Cale> It quit and restarted.
13:11:17 <pumpkin> it doesn't like aardvarks
13:11:31 <pumpkin> assuming that number does represent an aardvark
13:11:55 <dublpaws> maybe it's "\quit"
13:13:02 <pumpkin> why is that allocating memory?
13:13:18 <pumpkin> I killed ghci after it took up 800 megs
13:13:37 <kerlo> > map xor (sequence [[True,False],[True,False]])
13:13:46 <lambdabot>       Overlapping instances for Show ([Bool] -> [Bool])
13:13:50 <lambdabot>        arising from a...
13:14:04 <kerlo> > map (\[x,y] -> xor x y) (sequence [[True,False],[True,False]])
13:14:04 <int80_h>  where primeList' = [x | x <- (takeWhile (< 200000) primes)]
13:14:04 <lambdabot>       No instance for (Bits Bool)
13:14:04 <lambdabot>        arising from a use of `xor' at <inte...
13:14:22 <int80_h> whats a better way to find those primes?
13:14:43 <kerlo> No me gusta esta xor. What's one that actually takes Bools?
13:14:50 <roconnor> what is SDL?
13:14:58 <kerlo> @type not
13:15:00 <lambdabot> Bool -> Bool
13:15:02 <int80_h> I want 2 million of them, but as soon as I try 200000, it just takes way too long
13:15:04 <kerlo> Actually, that'll do.
13:15:09 <Cale> int80_h: improve your implementation of primes
13:15:27 <int80_h> sieve (p : xs) = p : sieve [x | x <- xs, x `mod` p > 0]
13:15:35 <int80_h> primes = sieve [2..]
13:15:44 <int80_h> so I shouldn't use the sieve?
13:16:33 <pstickne> that's not the sieve ...
13:16:39 <drdozer> did anyone here enter the icfp08?
13:16:52 <kerlo> > let foo 0 = False; foo x | odd x = not (foo (x `div` 2)); foo x | otherwise = foo (x `div` 2) in zip (map foo [0..]) ['a'..'z'] >>= (\(x,y) -> if x then [y] else [])
13:16:54 <lambdabot>   "bcehilnoqtvwz"
13:17:23 <Cale> > let primes = 2:[p | p <- [3,5..], isPrime p]; isPrime n = not $ any (\p -> n `mod` p == 0) (takeWhile (\p -> p*p <= n) primes) in primes
13:17:24 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
13:18:15 <Cale> > let primes = 2:[p | p <- [3,5..], isPrime p]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
13:18:16 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
13:18:22 <kerlo> > let foo 0 = False; foo x | odd x = not (foo (x `div` 2)); foo x | otherwise = foo (x `div` 2); takeSome xs = zip (map foo [0..]) xs >>= (\(x,y) -> if x then [y] else []) in foldr1 (.) (replicate 5 takeSome) [0..]
13:18:23 <lambdabot>   [16,32,64,112,128,176,208,224,256,304,336,352,400,416,448,496,512,560,592,6...
13:18:26 <roconnor> > nubBy(((>1).).gcd)[2..]
13:18:27 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
13:18:38 <kerlo> Name that sequence!
13:18:44 <Cale> roconnor: But that's probably even slower than what he's got.
13:18:53 <pstickne> The Genuine Sieve of Eratosthenes: http://lambda-the-ultimate.org/node/3127
13:19:00 <roconnor> @oesis 16,32,64,112,128,176
13:19:05 <lambdabot>  Sequence not found.
13:19:12 <roconnor> Cale: oh, are we helping someone?
13:19:18 <kerlo> > let foo 0 = False; foo x | odd x = not (foo (x `div` 2)); foo x | otherwise = foo (x `div` 2); takeSome xs = zip (map foo [0..]) xs >>= (\(x,y) -> if x then [y] else []) in foldr1 (.) (replicate 2 takeSome) [0..]
13:19:19 <lambdabot>   [2,4,8,14,16,22,26,28,32,38,42,44,50,52,56,62,64,70,74,76,82,84,88,94,98,10...
13:19:30 <kerlo> @oeis 2,4,8,14,16,22,26
13:19:30 <lambdabot>  Numbers n such that the number of 1's in the binary expansion of n divides 2...
13:19:30 <lambdabot>  [1,2,4,8,14,16,22,26,28,32,38,42,44,50,52,56,64,70,74,76,82,84,88,98,100,104...
13:19:37 <benmachine> I thought the idea of the prime sieve was you got a list of integers and removed the multiples of 2, the multoples of 3 &c
13:20:14 <Gracenotes> hm. that's not quite the same sequence
13:20:25 <pstickne> benmachine:  see above link :)
13:20:27 <kerlo> Indeed, this has a 1 in front of it.
13:20:44 <Gracenotes> well, you could have just made an off-by-one in that case -- it has 94 missing, etc.
13:20:49 <kerlo> Anyway, as you can see, foldr 1 (.) (replicate 5 takeSome) returns a relatively arbitrary sample of the elements of its argument.
13:21:03 <kerlo> Oh, 94 is missing as well.
13:21:11 <CosmicRay> woot http://hackage.haskell.org/packages/archive/recent.html
13:21:17 <kerlo> So this sequence is almost identical but has some differences.
13:22:50 <Cale> int80_h: That sieve is actually not the sieve of Eratosthenes, because it's doing trial division.
13:23:08 <Cale> (nor is the mutual recursion version which I gave you)
13:23:09 <Gracenotes> > let f a b = filter (not . (`elem` b)) a in f [2,4,8,14,16,22,26,28,32,38,42,44,50,52,56,62,64,70,74,76,82,84,88,94,98] [1,2,4,8,14,16,22,26,28,32,38,42,44,50,52,56,64,70,74,76,82,84,88,98]
13:23:10 <lambdabot>   [62,94]
13:23:41 <Gracenotes> > let f b a = filter (not . (`elem` b)) a in f [2,4,8,14,16,22,26,28,32,38,42,44,50,52,56,62,64,70,74,76,82,84,88,94,98] [1,2,4,8,14,16,22,26,28,32,38,42,44,50,52,56,64,70,74,76,82,84,88,98]
13:23:42 <lambdabot>   [1]
13:24:32 <kerlo> > let foo 0 = False; foo x | odd x = not (foo (x `div` 2)); foo x | otherwise = foo (x `div` 2); takeSome xs = zip (map foo [0..]) xs >>= (\(x,y) -> if x then [y] else []) in foldr1 (.) (replicate 3 takeSome) [0..]
13:24:33 <lambdabot>   [4,8,16,28,32,44,52,56,64,76,84,88,100,104,112,124,128,140,148,152,164,168,...
13:24:42 <kerlo> @oeis 4,8,16,28
13:24:42 <Gracenotes> ah, \\
13:24:42 <lambdabot>  Solution to the non-squashing boxes problem (version 2).
13:24:43 <lambdabot>  [2,4,8,16,28,46,72,108,156,218,298,398,524,678,868,1096,1372,1698,2086,2538,...
13:24:52 <kerlo> @oeis 4,8,16,28,32
13:24:52 <lambdabot>  Pseudoprimes to base 65.
13:24:52 <lambdabot>  [4,8,16,28,32,33,64,112,133,232,289,448,511,561,703,1111,1247,1387,1856,1891...
13:24:56 <benmachine> :t replicate
13:24:56 <lambdabot> forall a. Int -> a -> [a]
13:25:02 <kerlo> @oeis 4,8,16,28,32,44
13:25:02 <lambdabot>  Sequence not found.
13:25:06 <kerlo> Mm.
13:25:17 <Gracenotes> @oeis 76,84,88,100,104,112,124
13:25:17 <lambdabot>  Sequence not found.
13:25:25 <Cale> The cool thing about the real Sieve of Eratosthenes is that when removing the multiples of p, it doesn't calculate n `mod` p for each n, it just deletes p + n*p for each n.
13:25:40 <kerlo> Anyway, I definitely made no error in my implementation of this function, as I wasn't really trying to implement anything in particular.
13:26:04 <gwern> I see Cale finally updated lb's state/
13:26:07 <gwern> cale++
13:26:48 <Gracenotes> kerlo: unbeknownst to all present today, your sequence provided the basis of the proof that the Riemann hypothesis was true/false!
13:27:06 <Gracenotes> unfortunately, being from the future, I cannot tell you whether it was true or false >_>
13:27:12 <Cale> Prelude Control.Monad> let primes = 2:[p | p <- [3,5..], isPrime p]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in length (takeWhile (<200000) primes)
13:27:12 <Cale> 17984
13:27:12 <Cale> (6.47 secs, 265137248 bytes)
13:27:20 <Cale> ^^ int80_h
13:27:42 <Cale> int80_h: So that should be fast enough for you :)
13:28:00 <monochrom> Gracenotes: You can certainly tell us "it's true or false!" unless people in the future will abandon the law of excluded middle. :)
13:28:20 <Gracenotes> "whether" seems to imply xor, though
13:28:22 <Cale> monochrom: It seems an unfortunate number of the people in this channel have ;)
13:28:37 <monochrom> They do it just for Haskell's type logic. :)
13:28:41 --- mode: Cale set -ooo Cale Heffalump Igloo
13:28:43 <Gracenotes> but I am mum :X
13:29:19 <monochrom> "it's true xor false!" is still quite right.
13:29:37 <ray> that genuine sieve paper is cool
13:29:38 <roconnor> > let isTrue = id in isTrue undefined
13:29:39 <Heffalump> Cale: ta, I forgot after the last spammer
13:29:43 <lambdabot>   * Exception: Prelude.undefined
13:29:44 <Gracenotes> monochrom: unless it's unprovable
13:29:53 <SamB_irssi> monochrom: how so ?
13:29:59 <Cale> "It's true or false", is right, but "It's true xor false" isn't ;)
13:30:00 <roconnor> > let isTrueOrFalse x = x || (not x) in isTrueOrFalse undefined
13:30:01 <lambdabot>   * Exception: Prelude.undefined
13:30:01 <Gracenotes> well, in which case it might still be true xor false, but not provably so :P
13:30:14 <Cale> (at least, in *Haskell's* type logic ;)
13:30:25 <Cale> :t undefined
13:30:25 <SamB_irssi> that's the same as excluded middle for useful values of true and false ...
13:30:26 <lambdabot> forall a. a
13:30:29 <Cale> whee!
13:30:44 <Cale> Inconsistent logics FTW!
13:31:05 <SamB_irssi> well, okay, for consistant logics then
13:31:22 <vixey> Cale, I heard some LEM argument
13:31:26 <monochrom> classical propositional logic is consistent.
13:31:29 <kerlo> Well, my fancy little Portfolio definitions of primes and isPrime can't possibly be the real Sieve of Eratosthenes.
13:31:44 <Gracenotes> I have written a function forall a. a -> Bool!
13:31:51 <Gracenotes> > let trueOrFalse :: a -> Bool; trueOrFalse a = error "dunno" in trueOrFalse (Just [Left 4, Right 2])
13:31:52 <lambdabot>   * Exception: dunno
13:31:54 <Cale> Of course, in the total subset of Haskell, we don't quite have any kind of LEM
13:32:18 <SamB_irssi> monochrom: what I'm saying is that the xor thing isn't any easier to get then the usual LEM
13:32:20 <roconnor> @djinn Either () (Not ())
13:32:20 <lambdabot> f = Left ()
13:32:25 <Cale> It's some sort of intuitionist logic, depending on how you choose to restrict yourself.
13:32:27 <kerlo> Wow, it's not even the fake Sieve.
13:32:39 <roconnor> @djinn Either a (Not a)
13:32:39 <lambdabot> -- f cannot be realized.
13:32:48 <monochrom> I embrace the LEM.
13:32:55 <Cale> @djinn Either (Not a) (Not (Not a))
13:32:55 <lambdabot> -- f cannot be realized.
13:33:00 <vixey> you know the halting problem is undecidable... some people were saying, well that's true but if you gave me any fixed program either it halts or it doesn't halt
13:33:01 <Gracenotes> @djinn a -> Either a (Not a)
13:33:02 <lambdabot> f = Left
13:33:13 <Cale> @djinn Not (Not (Either a (Not a)))
13:33:13 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
13:33:16 <roconnor> @faq can monochrome realize Either a (Not a) ?
13:33:16 <lambdabot> The answer is: Yes! Haskell can do that.
13:33:21 <SamB_irssi> vixey: you can't say that to me
13:33:32 <SamB_irssi> er, at least, and expect me to care
13:33:37 <vixey> so everybody actually still believes in LEM, whether they think they do or not
13:33:45 <Cale> So it's not not true that a or not a.
13:33:48 <Gracenotes> @djinn Maybe (a -> b) -> a -> Either a b
13:33:48 <lambdabot> f a b =
13:33:48 <lambdabot>     case a of
13:33:48 <lambdabot>     Nothing -> Left b
13:33:48 <lambdabot>     Just c -> Right (c b)
13:34:06 <Gracenotes> hm. impressive :X
13:34:24 <roconnor> vixey: can I really give you any fixed program and you will tell me if it halts or not?
13:34:48 <vixey> roconnor, absolutely not.. (my 'no' here seems to be atypical though)
13:34:56 <SamB_irssi> roconnor: hey, I want to give vixey a broken program
13:35:01 <SamB_irssi> fixed programs are too easy
13:35:32 <monochrom> Everyone uses different logics for different purposes or at different levels. An intuitionist would still accept "each person uses intuitionistic logic or not" at a meta-meta level.
13:35:56 <Cale> hehe
13:35:57 <roconnor> anyhow, classical or and constructive or are simply two different connectives with different properties
13:36:04 <roconnor> there really is no argument here.
13:36:24 <vixey> also I found it very interesting that the main applications  of finitist mathematics are... proving transfinite ordinals are well founded
13:36:29 <roconnor> only perferences to how people inteperent the unqualitifed term "or"
13:36:44 <Gracenotes> hm. In what way is x or Not x undecided in Haskell?
13:36:47 <monochrom> The whole matter is like saying "do you use rational numbers? do you use real numbers? do you use complex numbers?"
13:36:52 <kerlo> @djinn Not (Not (Not (Not a))) -> Not a
13:36:53 <lambdabot> -- f cannot be realized.
13:36:55 <Gracenotes> is this by Curry-Howard?
13:36:58 <kerlo> @djinn Not (Not (Not (Not a))) -> Not (Not a)
13:36:58 <lambdabot> f a b = void (a (\ c -> void (c b)))
13:37:13 <kerlo> @djinn ((a -> b) -> a) -> a
13:37:13 <lambdabot> -- f cannot be realized.
13:37:20 <kerlo> @djinn Not (Not (((a -> b) -> a) -> a))
13:37:21 <lambdabot> f a =
13:37:21 <lambdabot>     void (a (\ b -> void (a (\ _ -> b (\ c -> void (a (\ _ -> c)))))))
13:37:37 <Cale> @djinn Not (Not (Not (Not a) -> a))
13:37:40 <lambdabot> f a = void (a (\ b -> void (b (\ c -> a (\ _ -> c)))))
13:37:59 <kerlo> newtype NotNot a = Not (Not a) is a monad, isn't it.
13:38:08 <Cale> yes, it ought to be
13:38:08 <ac> @src unwords
13:38:08 <lambdabot> unwords [] = ""
13:38:09 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
13:38:11 <Gracenotes> wait... is lambdabot sending notices now? How inconvenient :(
13:38:15 <baaba> @src Not
13:38:15 <lambdabot> Source not found. Maybe if you used more than just two fingers...
13:38:26 <roconnor> @djinn-env
13:38:26 <lambdabot> data () = ()
13:38:26 <lambdabot> data Either a b = Left a | Right b
13:38:26 <lambdabot> data Maybe a = Nothing | Just a
13:38:26 <lambdabot> data Bool = False | True
13:38:26 <lambdabot> data Void
13:38:26 <monochrom> > "notices?"
13:38:28 <lambdabot> type Not x = x -> Void
13:38:30 <lambdabot>   "notices?"
13:38:32 <lambdabot> class Eq a where (==) :: a -> a -> Bool
13:38:34 <ac> couldn't unwords be: unwords = intercalate " " -- ?
13:38:37 <Cale> @djinn-add type NotNot a = Not (Not a)
13:38:44 <monochrom> lazy lambdabot is lazy.
13:38:48 <Gracenotes> /msg lambdabot > "test"
13:38:52 <Cale> @djinn a -> NotNot a
13:38:52 <lambdabot> f a b = b a
13:38:52 <Gracenotes> why :/
13:39:01 <Gracenotes> WHY DID IT ALL GO WRONG :X
13:39:03 <roconnor> @djinn-add type ClassicOr a b = Not (Not a, Not b)
13:39:07 <kerlo> @djinn (a -> NotNot b) -> NotNot a -> NotNot b
13:39:07 <lambdabot> f a b c = void (b (\ d -> void (a d c)))
13:39:08 <Cale> @djinn NotNot a -> (a -> NotNot b) -> NotNot b
13:39:08 <lambdabot> f a b c = void (a (\ d -> void (b d c)))
13:39:18 <roconnor> @djinn ClassicOr a (Not a)
13:39:18 <lambdabot> f (a, b) = void (b a)
13:39:36 * Gracenotes demands that lambdabot sends him a PM, now!
13:39:42 <Gracenotes> apologizing for not sending PMs!
13:39:58 <Cale> @djinn NotNot (NotNot a) -> NotNot a
13:39:58 <lambdabot> f a b = void (a (\ c -> void (c b)))
13:39:58 <kerlo> @pl \a b c -> void (a (\ d -> void (b d c)))
13:39:58 <lambdabot> ((void .) .) . (. (((void .) .) . flip)) . (.)
13:40:01 <FunctorSalad> @tell Gracenotes :-)
13:40:01 <lambdabot> Consider it noted.
13:40:10 <Gracenotes> WHAT DO YOU WANT NOW LAMBDABOT
13:40:10 <lambdabot> Gracenotes: You have 1 new message. '/msg lambdabot @messages' to read it.
13:40:14 <Cale> @djinn (a -> b) -> NotNot a -> NotNot b
13:40:14 <lambdabot> f a b c = void (b (\ d -> c (a d)))
13:40:26 <roconnor> @djinn-add type Stable a = Not (Not a) -> a
13:40:28 <kerlo> unsafeBreakStuff :: NotNot a -> a
13:40:31 <Gracenotes> Even now you mock me, sending your message as a notice!
13:40:39 <vixey> roconnor, but if you are taking \/ as a primitive... to define the classical \/
13:40:47 <FunctorSalad> :(
13:40:49 <roconnor> @djinn (Stable b) -> ((a -> b) -> a) -> a
13:40:50 <lambdabot> -- f cannot be realized.
13:41:01 <roconnor> vixey: no I'm taking /\ as primative to define the clasical \/
13:41:07 <Gracenotes> I'll get you back, one day, lambdabot! When you least expect it -- the Omega combinator! mwahahahaha!
13:41:08 <kerlo> What is a Stable b?
13:41:21 <roconnor> type Stable a = Not (Not a) -> a
13:41:24 <hackage> Uploaded to hackage: HDBC-odbc 2.0.0.0
13:41:24 <hackage> Uploaded to hackage: HDBC-postgresql 2.0.0.0
13:41:24 <hackage> Uploaded to hackage: HDBC-sqlite3 2.0.0.0
13:41:24 <hackage> Uploaded to hackage: HDBC 2.0.0
13:41:28 <kerlo> Mm.
13:41:48 <roconnor> kerlo: specifically it means that b is double-negation stable
13:41:48 <kerlo> Tell djinn that.
13:42:04 <redditbot> Some libgd changes
13:42:09 <kerlo> @djinn-add type Stable a = NotNot a -> a
13:42:09 <lambdabot> Error: Undefined type NotNot
13:42:09 <roconnor> kerlo: ie b <-> (Not (Not b))
13:42:13 <Gracenotes> but, really, is there an opt-out for notices from lambdabot? Or, preferably, an opt-in? My client sucks at handling notices.
13:42:18 <Cale> @djinn Stable a -> NotNot a -> a
13:42:18 <lambdabot> f a = a
13:42:25 <roconnor> kerlo: meaning that the variable b behaves classically
13:42:28 <kerlo> @djinn-add type Stable a = Not (Not a) -> a
13:42:33 <Cale> @djinn Stable a -> Either a (Not a)
13:42:33 <lambdabot> -- f cannot be realized.
13:42:39 <kerlo> @djinn Stable b -> ((a -> b) -> a) -> a
13:42:39 <lambdabot> -- f cannot be realized.
13:42:57 <kerlo> @djinn Stable (((a -> b) -> a) -> a) -> ((a -> b) -> a) -> a
13:42:57 <lambdabot> f a b =
13:42:57 <lambdabot>     a (\ c ->
13:42:57 <lambdabot>        void (c (\ d ->
13:42:57 <lambdabot>                 void (c (\ _ -> d (\ e -> void (c (\ _ -> e)))))))) (\ f -> b f)
13:43:07 <Cale> Gracenotes: notices?
13:43:19 <Cale> Gracenotes: lambdabot never sends NOTICEs
13:43:33 <roconnor> @djinn (Stable a) -> ((a -> b) -> a) -> a
13:43:33 <lambdabot> f a b = a (\ c -> void (c (b (\ d -> void (c d)))))
13:43:38 <Gracenotes> /msg lambdabot > "test"
13:43:41 <Cale> Gracenotes: At one point it did, but too many clients handled them in idiotic ways.
13:43:43 <Gracenotes> lambdabot sends me a notice
13:43:47 <elly> :t void
13:43:48 <lambdabot> Not in scope: `void'
13:43:51 <elly> hrm
13:43:54 <Cale> Gracenotes: No, it sends you a PRIVMSG
13:44:14 <baaba> void _ = undefined :: Void?
13:44:20 <Gracenotes> Cale: have you tried that? :)
13:44:24 <Cale> I have.
13:44:33 <roconnor> void x = case x of {}
13:44:37 <Gracenotes> . :/
13:45:09 <Cale> What client are you using?
13:45:10 <baaba> what type does that have?
13:45:23 <kerlo> @type \x -> case x of {}
13:45:24 <lambdabot> parse error on input `}'
13:45:28 <kerlo> Aww.
13:45:32 <roconnor> kerlo: it isn't haskell 98
13:45:43 <kerlo> Can I feed non-98 to lambdabot?
13:45:44 <vixey> I saw somewhere
13:45:53 <baaba> > case 1 of 2 -> 3
13:45:54 <lambdabot>   * Exception: /tmp/1963713666749508242:71:44-59: Non-exhaustive patterns in ...
13:45:56 <Gracenotes> Cale: that's extremely odd... I closed the private message tab and then opened it again, and everything seemed to function normally again
13:45:59 <vixey> computer programming : functional programming :: classical logic : intuitionistic logic
13:46:12 <Gracenotes> I blame lambdabot suddenly disappearing and confusing my client :/
13:46:16 <baaba> so case x of {} is always an exception?
13:46:18 <opqdonut> vixey: interesting pov
13:46:26 <Cale> Gracenotes: X-Chat works rather well for me :)
13:46:28 <elly> vixey: Oo
13:46:34 <kerlo> baaba: what else would it be?
13:46:38 <baaba> is it any different from undefined then?
13:46:44 <opqdonut> vixey: would you mind elaborating
13:46:55 <kerlo> baaba: only in the type signature.
13:46:58 <vixey> I can't remember what paper it was in .....
13:47:10 <Gracenotes> PM worked before, but then when lambdabot suddenly exited then resurrected, my client got screwy
13:47:18 <kerlo> void :: Void -> a is total if Void is empty.
13:47:20 <ksf> vixey, there's a difference between computer programming and functional programming ?!
13:47:23 <Cale> baaba: void :: a -> Void, where Void is a type with no constructors anyway
13:47:28 <Cale> er
13:47:36 <baaba> which way is it then? :P
13:47:36 <Cale> yes
13:47:44 <vixey> void :: Void -> a?
13:47:55 <baaba> http://en.wikibooks.org/wiki/Haskell/The_Curry-Howard_isomorphism
13:48:04 <baaba> void == empty?
13:48:09 <Gracenotes> > let passionatePleaForForgiveness = const "It's okay, I still love you" in passionatePleaForForgiveness "sorry for blaming you, lambdabot"
13:48:10 <lambdabot>   "It's okay, I still love you"
13:48:13 <Gracenotes> :D
13:48:27 <opqdonut> :D
13:48:42 <Cale> oh, I think vixey is right here.
13:49:10 <Cale> Void is an initial object, and void is the universal arrow.
13:49:18 <kerlo> Functional programming : imperative programming :: mathematics : some insane version of mathematics where the number of possible statements is finite and proofs are written using something only vaguely resembling logic.
13:49:23 <Cale> @djinn Void -> a
13:49:23 <lambdabot> f = void
13:49:32 <kerlo> Where :: is the Curry-Howard isomorphism.
13:50:07 <Cale> Functional programming : imperative programming :: mathematics : mathematics for engineers ;)
13:50:10 <FunctorSalad> now what does finity have to do with imperative prog?
13:50:14 <vixey> lol
13:50:19 <vixey> harsh
13:50:57 <Cale> *jab*
13:50:58 <Cale> hehe
13:51:12 <Gracenotes> unfortunately, I have heard... Math : functional programming languages :: Math : math for wannabe mathematicians :/
13:51:13 <kerlo> I was thinking C had a finite number of types.
13:51:42 <kerlo> Now I suppose that functions can take arbitrary numbers of arguments.
13:51:47 <kerlo> But they can't take or return other functions.
13:51:50 <Cale> kerlo: It doesn't... but it's a sort of boring landscape
13:51:52 <FunctorSalad> struct?
13:51:54 <Gracenotes> which I suppose is somewhat true in my case. But at least I'm studying math alongside.
13:51:58 <Cale> kerlo: You can return a pointer to a function though
13:52:17 <kerlo> Better analogy: Functional programming : imperative programming :: mathematics : really complicated mathematics.
13:52:23 <Cale> heh
13:52:27 <FunctorSalad> can't argue with that :)
13:52:28 <elly> kerlo: <3
13:52:54 <Gracenotes> or :: Abstract nonsense :: Not-so-abstract nonsense
13:52:57 <FunctorSalad> funct. : imp. :: mathematics : mathematics where the meaning of symbol changes every line
13:53:00 <kerlo> "Does 2 + 2 = 4?" "Well, that depends on whether the literals 2 and 4 have ever been dereferenced and overwritten. Then again, I guess there's some undefined behavior if you dereference any variable and then add to the resulting pointer."
13:53:00 * Gracenotes probably isn't helping here >_>
13:53:14 <vixey> Gracenotes, I thought this was very insightful "We do a crappy job of teaching undergraduate PL. We don't have a standard textbook. We don't have a unified view of what is important. Creates a challenge both for teaching students and for informing others in computer science about PL."
13:53:26 <Gracenotes> s/second ::/:/
13:53:39 <Cale> Does 0 = 2? Depends on the choice of ring.
13:53:53 <FunctorSalad> implicit arguments and lexical scoping don't count ;)
13:53:59 * vixey grits her teeth waiting for someone to say "small values of 2"
13:54:08 <lament> large values of 0.
13:54:10 <Gracenotes> FunctorSalad: /me uses an IORef
13:54:15 <kerlo> "Oh, and it depends on the choice of ring, too."
13:54:23 <FunctorSalad> I admit my analogy sucks since state is more about things changing *at runtime*
13:54:26 <Gracenotes> vixey: who would say that?
13:54:44 <vixey> which ?
13:54:46 <FunctorSalad> what is runtime with math?
13:55:30 <lament> functional programming : imperative programming :: photograph : movie
13:55:40 <Gracenotes> vixey: who said the 'insightful' quote?
13:55:41 <cads> hey, do you guys know of a feed reader that uses preference mining algorithms prioritize the articles it feels the user is most likely to enjoy/need?
13:55:49 <kerlo> Yes, but it's a photograph of the Mandelbrot set.
13:56:02 <lament> a photograph has to be really damn complex to convey the same information as a movie
13:56:10 <vixey> Gracenotes, Greg Morrisett
13:56:19 <ray> an infinite-resolution photograph of the mandelbrot set
13:56:27 <Gracenotes> vixey: in what context, though?
13:56:28 <roconnor> <kerlo> Yes, but it's a photograph of the Mandelbrot set.
13:56:30 <roconnor> where?
13:56:41 <kerlo> I think the Hubble took one.
13:56:43 <benmachine> what colour is the mandelbrot set
13:56:52 <ray> i think it's growing in a petri dish
13:56:54 <Gracenotes> vixey: is there some article I can read about it? It seems interestingish enough :)
13:56:55 <lament> roconnor: http://farm1.static.flickr.com/1/222846_196c05547a.jpg
13:56:57 <vixey> since mandelbrot set is not computable you've got something pretty special
13:57:02 <kerlo> But it was destroyed by the Soviets so Hitler wouldn't get his hands on it.
13:57:09 <Cale> The mandelbrot set itself is obviously black, and the points not in it are white.
13:57:13 <vixey> Gracenotes, http://plgrand.blogspot.com/
13:57:23 <kerlo> vixey: are you sure the Mandelbrot set is not computable?
13:57:26 <roconnor> vixey: not known to be computable
13:57:38 <Cale> roconnor: Really?
13:57:41 <Gracenotes> okay... thanks... :.:
13:57:42 <roconnor> really
13:57:51 <lament> it would be strange if it were computable...
13:57:55 <vixey> kerlo, I was sure until 2 second ago (when roconnor said that)
13:58:02 <Cale> roconnor: Er, its complement is what's computable then?
13:58:04 <roconnor> monochrome thinks it is either computable or it isn't computable :P
13:58:25 <roconnor> Cale: well, the complement isn't even (locally) compact, so I don't know what that means.
13:59:20 <Cale> Well, we have a program we can use to test if a point lies outside the M-set, don't we?
13:59:23 <cads> Can the mandelbrot set be considered dense in information? Algorithmically it's very simple to describe.
13:59:24 <roconnor> lament: it is conjectured to be computable
13:59:28 <kerlo> If I'm not mistaken, the Mandelbrot set is the closure of its intersection with the rational numbers.
14:00:06 <SamB_irssi> is mandelbrot membership even decidable ?
14:00:07 <roconnor> Cale: yes, I think that is the case.
14:00:15 <mightybyte> Is there a way to construct a function with the signature IO (a,b) -> (IO a, IO b)?
14:00:22 <roconnor> Cale: but that isn't usually what we mean by a set being computable.
14:00:31 <vixey> mightybyte, yes I think so
14:00:32 <kerlo> mightybyte: yes, though it may not do what you want.
14:00:37 <FunctorSalad> kerlo: isn't any closed set? ;) (disclaimer:drunk))
14:00:40 <Heffalump> depends if you mind repeating the computation or not
14:00:41 <lament> how do you verify that a point is outside M?
14:00:57 <kerlo> \x -> (liftM fst x, liftM snd x), or something like that.
14:00:59 <Vq^> mightybyte: you can easily construct the function
14:01:01 <vixey> :t \x -> (do (u,v) <- x; return u, do (u,v) <- x; return v)
14:01:01 <roconnor> lament: run the standard algorithm.
14:01:02 <lambdabot> forall (t :: * -> *) t1 t2. (Monad t) => t (t1, t2) -> (t t1, t t2)
14:01:04 <Cale> lament: Iterate
14:01:06 <mightybyte> vixey: Hmmm, how would that function be implemented?  I'm not seeing it.
14:01:14 <Vq^> mightybyte: but the effects from the original computation will exists in both resulting actions
14:01:23 <roconnor> lament: wait for the point to escape abs value of 2
14:01:29 <Cale> lament: iterate \z -> z^2 + c, and if |z| > 2, then z is not in M.
14:01:51 <mightybyte> Vq^: That's ok.
14:01:55 <asgaroth> Is there a spread-sheet application that lets you enter and evaluate haskell expressions for the cell contents?
14:01:57 <kerlo> I wonder how one could write IO (a,b) -> (IO a, IO b) that only runs the computation the first time either of those is called.
14:02:10 <opqdonut> so membership in coM is semidecideable?
14:02:14 <Cale> and (I believe) if z is not in M, then eventually one of the iterates will have magnitude larger than 2
14:02:30 <lament> Cale: but what if it is?
14:02:32 <mightybyte> vixey: Heh, wouldn't have thought of doing that.
14:02:34 <FunctorSalad> first restrict R^2 to something you can even feed to an algo ;)
14:02:36 <BONUS> (fmap fst &&& fmap snd) (Just (2,3))
14:02:38 <BONUS> >. (fmap fst &&& fmap snd) (Just (2,3))
14:02:40 <BONUS> whoops
14:02:44 <lament> Cale: do you just fail to halt and call it a success?
14:02:47 <BONUS> > (fmap fst &&& fmap snd) (Just (2,3))
14:02:48 <lambdabot>   (Just 2,Just 3)
14:02:49 <Cale> lament: right.
14:03:02 <cads> I think the definition is only that the sequence of iterates is bound
14:03:04 <lament> that's pretty lame
14:03:06 <Cale> lament: To draw an approximation of the set, you just cut it off at some point.
14:03:17 <lament> yes but that's an approximation
14:03:23 <Heffalump> kerlo: with unsafePerformIO
14:03:24 <roconnor> for some definition of approximation
14:03:28 <FunctorSalad> cads: once it's large enough, it diverges to infinity
14:03:32 * kerlo nods
14:03:36 <roconnor> cutting off doesn't tell you the error of your approximation.
14:03:41 <Heffalump> you could probably just copy the definition of unsafeInterleaveIO and complicate it a bit
14:03:48 <idnar> @type fmap (&&&)
14:03:49 <lambdabot> forall (a :: * -> * -> *) b c c' (f :: * -> *). (Functor f, Arrow a) => f (a b c) -> f (a b c' -> a b (c, c'))
14:04:08 <cads> so for a point in the mandelbrot set there exist some number c such that c > |iter(n)| for all n
14:04:24 <mightybyte> vixey: I was trying do "\x -> do  {(u,v) <- x; return (u,v)}
14:04:24 <FunctorSalad> |z^2 + c | >= | |z|^2 - |c| |
14:04:55 <Cale> There's no simple way to measure error anyway. A point is either in or out. This gives you a superset of M. I suppose you could show that the Lebesgue measure of the difference tends to 0 as the number of iterations goes to infinity.
14:05:02 <cads> could easily be impossible to decided in general whether a certain point diverges, no?
14:05:41 <ski_> mightybyte : that's the same as `id'
14:06:08 <mightybyte> ski_: It gives me an occurs check error.
14:06:11 <opqdonut> ski_: the pattern match could fail
14:06:17 <roconnor> Cale: the definition of a computable compact set is that it can be unformly approximated by a finite set with hausdorff error arbitrairly small.
14:06:31 <roconnor> Cale: that is how you measure error for compact sets
14:06:34 <Cale> There is another method for determining points which certainly lie inside M, but I don't know if it always terminates.
14:06:55 <mightybyte> Vq^: So in vixey's implementation, do the effects from the top computation happen twice?
14:07:19 <Cale> roconnor: That it's totally bounded?
14:07:20 <ski_> @type \x -> do  {(u,v) <- x; return (u,v)}
14:07:21 <lambdabot> forall (t :: * -> *) t1 t2. (Monad t) => t (t1, t2) -> t (t1, t2)
14:07:44 <Cale> (I don't know what Hausdorff error is)
14:07:47 <ski_> opqdonut : how so ?
14:07:52 <roconnor> Cale: er right.  I'm talking about compact in a metric space
14:07:59 <kerlo> @index Dynamic
14:07:59 <lambdabot> Data.Dynamic
14:08:03 <kerlo> @docs Data.Dynamic
14:08:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Dynamic.html
14:08:03 <roconnor> Cale: which is equiavlent to complete and totally bounded
14:08:38 <roconnor> Cale: measuring error becomes harder without a metric.
14:08:43 <Vq^> mightybyte: only if you use both of the resulting computations
14:08:46 <vixey> Ithought hausdorrf was a synonym for separated
14:09:02 <roconnor> vixey: Hausdorff gets lots of things named after him.
14:09:05 <opqdonut> ski_: i mean that forces the result of x into rhnf
14:09:11 <mightybyte> :t \x -> (liftM fst x, liftM snd x)
14:09:12 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a, b) -> (m a, m b)
14:09:29 <ski_> opqdonut : yes .. but *when* does it do that ?
14:09:30 <mightybyte> Vq^: Ok, interesting.
14:09:50 <vixey> :t unsafeInterleaveIO
14:09:51 <lambdabot> Not in scope: `unsafeInterleaveIO'
14:09:51 <mightybyte> Vq^: I'll have to check and see if it does what I need.
14:10:08 <vixey> can you write this IO (x,y) -> (IO x, IO y) with unsafeInterleaveIO?
14:10:14 <opqdonut> ski_: ah, good point
14:10:32 <mightybyte> vixey: Hmm, not sure.  I don't think I'd want to.
14:10:36 <kerlo> @hoogle IORef
14:10:37 <lambdabot> module Data.IORef
14:10:37 <lambdabot> Data.IORef data IORef a
14:10:37 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
14:10:51 <vixey> mightybyte, I meant like,.. write it and then immediately delete it :)
14:10:55 <sw17ch> I want to write a dialect of C with type inference and const-by-default variables.
14:11:02 <sw17ch> or at least type inference
14:11:08 <mightybyte> vixey: Oh, heh.
14:11:26 <vixey> sw17ch: .. or just not use C ..?
14:11:39 <dublpaws> sw17ch: while your at it, a python too please :)
14:11:41 <ski_> opqdonut : actually .. you're right, there can be a difference between inspecting the action and forcing the result of the action
14:11:54 <ski_> > case (\x -> do  {(u,v) <- x; return (u,v)}) (Just undefined) of Just _ -> True ; Nothing -> False
14:11:55 <lambdabot>   * Exception: Prelude.undefined
14:11:57 <ski_> > case (Just undefined) of Just _ -> True ; Nothing -> False
14:11:58 <lambdabot>   True
14:12:01 * sw17ch shows his Embedded Programmer For A Living badge to vixey
14:12:07 <vixey> sw17ch: (btw it's pretty easy to implement type inference and it's easy to print out C code)
14:12:12 <FunctorSalad> :o
14:12:25 <Vq^> sw17ch: it should support inline fortran as well! :o)
14:12:27 <sw17ch> vixey: i was thinking i'd just add something silly like an "infer" keyword
14:12:31 * ski_ wonders if that makes it equivalent to a `evaluate'
14:12:43 * sw17ch backs away from Vq^
14:12:49 <vixey> I can't imagine typing  'infer'  is easier than typing  'char'  or whatever
14:13:38 <kerlo> Hmm. An evaluate-once IO (x,y) -> (IO x, IO y) wouldn't be safe, would it.
14:13:59 <sw17ch> vixey: yes, but i don't think i'd want it to make the code more succinct
14:14:01 <vixey> kerlo, just wonding what kind of unsafe it would end up being
14:14:06 <FunctorSalad> sw17ch: just a random idea... a haskell DSL that outputs C?
14:14:19 <kerlo> You'd pass something in once and get two different things back.
14:14:30 <vixey> FunctorSalad, what's wrong with good old L's
14:14:31 <sw17ch> FunctorSalad: my implementation idea involves hacking Language.C into something like Language.InferrableC
14:14:37 <FunctorSalad> 'DSL' being the wrong word for C I guess
14:14:39 <sw17ch> and then translating that to normal C
14:14:44 <kerlo> evalOnce :: IO a -> IO a; do {evalOnce (putStr "one"), evalOnce (putStr "one")}
14:14:46 <kerlo> What happens?
14:14:50 <vixey> DSL actually describes C perfectly..
14:15:33 <FunctorSalad> sw17ch: oh I didn't know there was Language.C :)
14:15:43 <sw17ch> FunctorSalad: oh my! it's a wonderful project!
14:15:52 <sw17ch> Benedikt Huber did a very nice job :)
14:16:02 <Heffalump> kerlo: I don't see why it'd be any less safe than unsafeInterleaveIO
14:16:04 <sw17ch> i believe Duncan helped him a lot too
14:16:16 <kerlo> Anyway, it'd be nice if there were a function global :: Integer -> IORef Dynamic.
14:16:25 <kerlo> Heffalump: I don't believe I claimed that it was.
14:16:26 <ski_> (vixey : how about inferring `const char * (* (**foo [(sizeof (int * [5]))]) (int *restrict [5])) (int, ...);' ? ..)
14:16:36 <roconnor> kerlo: it wouldn't be referentially transparent
14:16:41 <dcoutts> sw17ch: aye, I wrote the first version
14:16:47 <SamB_irssi> roconnor: wouldn't it be ?
14:16:49 <kerlo> And a function wrap :: (a -> b) -> (b -> a) -> IORef a -> IORed b.
14:16:55 <sw17ch> dcoutts: i thought so, for c2hs right?
14:16:56 <roconnor> SamB_irssi: I don't think so
14:17:00 <kerlo> SamB_irssi: no, because of the example I gave.
14:17:00 <roconnor> I could be wrong
14:17:13 <vixey> ski_, :S
14:17:16 <dcoutts> sw17ch: right as part of c2hs, now finally Benedikt sent us patches to have c2hs use Language.C
14:17:21 <vixey> ski_, if you use POSIX I wil infer void*
14:17:26 <dcoutts> sw17ch: so it's come full circle :-)
14:17:38 <SamB_irssi> would you get the same IORef for the same Integer every time ?
14:17:46 <kerlo> SamB_irssi: yes.
14:17:49 <roconnor> I eventually learned that an IO a parameter is effectively a call-back function
14:17:54 <kerlo> And different IORefs for different Integers every time.
14:17:59 <SamB_irssi> that sounds referentially transparent to me
14:18:34 <kerlo> Oh, we're not agreeing on what roconnor meant by "it" in "it wouldn't be referentially transparent".
14:18:41 <roconnor> oh
14:18:41 <SamB_irssi> oh!
14:18:48 <roconnor> sorry
14:19:40 <SamB_irssi> the wrap thing could be, if you passed in a bijection proof
14:19:54 <kerlo> (Lojban is also susceptible to this problem, if you don't use ko'a and company like everyone does.)
14:20:11 <dons> ?yow
14:20:12 <lambdabot> Are we on STRIKE yet?
14:20:14 <dons> ?users
14:20:14 <lambdabot> Maximum users seen in #haskell: 658, currently: 642 (97.6%), active: 35 (5.5%)
14:20:18 <kerlo> How do you pass in a bijection proof?
14:20:24 <sw17ch> dcoutts: it's nice when that happens. has there been work with c2hs lately? does it wrap #define's for me yet? :D
14:20:33 <SamB_irssi> kerlo: you use a language where you can ;-P
14:20:39 <sw17ch> hi dons
14:20:45 <dons> hey sw17ch !
14:20:47 <dons> how's things
14:20:59 <sw17ch> it's friday @ 5:20PM and i'm still at work :\
14:20:59 <dcoutts> dons: good trip? :-)
14:21:04 * dons is finally back in the office after a week on the road
14:21:11 <dons> dcoutts: yeah, got lots of things done.
14:21:19 <dcoutts> sw17ch: yes there will be a 0.16.0 release soon
14:21:27 <dcoutts> dons: oh I've got some Qs for you...
14:21:30 <sw17ch> dcoutts: what's new with it?
14:21:33 <dons> sure.
14:21:37 <SamB_irssi> sw17ch: oh! someone who knows what time it is!
14:22:02 <sw17ch> SamB_irssi: i'm sorry. am i the only one? :)
14:22:20 <dcoutts> sw17ch: using Language.C and some bug fixes
14:22:26 <SamB_irssi> sw17ch: well, lotsa people think it's some other time!
14:22:47 <sw17ch> SamB_irssi: Eastern Daily Time?
14:23:07 <sw17ch> (or is it Daylight Time)
14:23:17 <SamB_irssi> I think Daylight is more likely
14:23:26 <sw17ch> i'm assuming
14:23:48 <FunctorSalad> sw17ch: would it be possible to map C types to haskell types directly (rather than with the indirection layer as in Language.C) and co-opt haskell's type inference?
14:24:27 <SamB_irssi> FunctorSalad: co-opting Haskell type inference is probably a lot more trouble than it's worth
14:24:35 <sw17ch> FunctorSalad: hmm... i have no idea. i think my concept was much simpler than that
14:24:39 <SamB_irssi> especially considering how badly it works for unlifted types ...
14:24:48 <sw17ch> basically keep a record of the first time "infer" types are used, and staple the contextual type to them
14:24:55 <FunctorSalad> I never wrote a type inferer myself, Iwouldn't know how hard it is...
14:25:18 <sw17ch> FunctorSalad: int foo() { infer x; x = 9; return x; }
14:25:32 <sw17ch> we'd set x to type "int"
14:25:44 <sw17ch> as bound by the return
14:25:48 <SamB_irssi> well, writing simple type inference for a monomorphic language has got to be easier than somehow shoehorning the program into a Haskell typechecker ...
14:25:54 <SamB_irssi> ... and out again
14:25:58 <FunctorSalad> :)
14:26:41 <mathijs> Hi all, I'm mainly a ruby programmer, and learning haskell. One thing I liked about ruby is the heavy (though a bit dirty) metaprogramming stuff like proxy-objects (posing as something else). I'm trying to build a sql-query thingy on haskell, so the sql query is a Data structure which has predicates and ordering options and stuff. Now, I'm using HDBC, and I like the lazy fetchAllRows approach, but I'm looking at a way to transparently abstract t
14:27:04 <vixey> FunctorSalad, it's trivial
14:27:08 <vixey> for HM
14:27:27 <athos> mathijs: your message seems to be incomplete
14:27:33 <SamB_irssi> vixey: so for C is it easier or harder ?
14:27:36 <athos> mathijs: there's a cut at "transparently abstract t
14:27:51 <mathijs> transparently abstract the  query/fetch stuff even further.
14:27:56 <vixey> C isn't type safe, you can easily deal with some restriction of C
14:28:00 <mathijs>  What I would like is a lazy list (like fetchAllRows) which just 'poses' as a list, but keeps an internal sql-query data
14:28:08 <mathijs> structure around. It should only execute when real data is needed.
14:28:16 <SamB_irssi> vixey: what does that have to do with anything ?
14:28:21 <SamB_irssi> just because it isn't SAFE ...
14:28:21 <mathijs> When applying functions to it, it should just try to adjust its query.
14:28:49 <SamB_irssi> obviously, you can't just take out all indication of types from your program
14:29:21 <mathijs> Example: the  lazy list resembles 'select * from users'. Now if I say filter (\x -> (lookup "age" x) > 21) userslist, it should not execute and filter stuff in haskell, but rather adjust its query to 'select * from users where age > 21', since in this case if knows how to handle filtering.
14:29:37 <kerlo> mathijs: well, Haskell doesn't have that exact functionality; if you have, say, a String, then evaluating that String is always going to perform an IO-less computation to produce the same string, unless you're using unsafePerformIO or something.
14:30:27 <SamB_irssi> mathijs: you could look into using RULES somehow ...
14:30:37 <SamB_irssi> not sure how practical that is in this case!
14:31:19 <mathijs> can't I just make my LazyHaskellFlexibleQueryResult an intance of [] ?
14:31:20 <kerlo> With Haskell, you're probably better off just doing it manually, though I can imagine implementing a typeclass for things that behave in certain list-like ways.
14:31:32 <vixey> SamB_irssi: in practice..... what you would implement
14:31:40 <kerlo> [] is a type; it doesn't have instances.
14:32:03 <monochrom> filter doesn't do that. filter is specific for lazy list, and lazy list doesn't work like that.  However, if you don't use filter, if you write your own filter, and write it for SQL rather than lazy list, you can make it do that.
14:32:04 <vixey> maybe types /should/ have instances
14:32:13 <vixey> we could replace this   Foo => ...  crap
14:32:31 <Gracenotes> there are sequence typeclasses, though
14:32:37 <Gracenotes> Traversable, Foldable
14:32:53 <sw17ch> I also want to write an analysis package that looks for assignment operators that aren't initializers, and counts the number of different scopes variables are referenced from
14:33:16 <sw17ch> Something to point out the scarier pieces of code.
14:33:18 <mathijs> monochrom: well that's what I mean... I will have to implement stuff like mapping and folding (for database count(*)) myself ofcourse, so my type mimics a list.
14:33:57 <kerlo> abstractdata Extensible = One | Two; datainstance Extensible Three; list = [One, Two, Three]
14:34:00 <kerlo> ...would be nice.
14:34:03 <Gracenotes> the list type is pretty simple: data List a = Nil | Cons a, basically. Easy to emulate
14:34:20 <Gracenotes> (really [] | (:) a
14:34:32 <monochrom> One of the Haskell SQL libraries does that.
14:34:32 <mathijs> monochrom: but in the end, I want my list-like, database-backed list to be swappable with a real (in memory) list, without any code changes.
14:34:34 <dobblego> Gracenotes, try again :)
14:34:44 <Gracenotes> dobblego: bzzzzzzzzt? :P
14:34:55 <roconnor> Cons a (List a)
14:34:58 <Cale> kerlo: open data Extensible = One | Two; open data Extensible = Three
14:34:58 <Gracenotes> oh, yeah
14:34:59 <mathijs> monochrom: which one?
14:35:03 <Gracenotes> of course.
14:35:06 <kerlo> Cale: yeah, that.
14:35:09 <Gracenotes> I meant that! :D
14:35:09 <roconnor> (  (:) a ([] a)  )
14:35:17 <Gracenotes> indeed
14:35:17 <monochrom> I mean one of the Haskell SQL libraries does its own filter that modifies queries. I forgot which one.
14:35:17 <kerlo> Does that already exist?
14:35:23 <Cale> kerlo: It's been discussed
14:35:35 <Cale> kerlo: But no, I don't think any current implementation has it.
14:35:38 * kerlo nods
14:35:50 <SamB_irssi> Cale: what good would it do ?
14:35:53 <Cale> You also need to implement all the functions whenever you extend a datatype.
14:35:56 <Cale> Well...
14:36:00 <mathijs> monochrom: well that's the one I need then :)  I'll have a look. Saves me from implementing it myself :)
14:36:21 <Cale> Typically you'd write functions on open datatypes in such a way that they always have fall through cases.
14:37:21 <Cale> SamB_irssi: Think things like exceptions.
14:37:26 <kerlo> @type null
14:37:26 <lambdabot> forall a. [a] -> Bool
14:37:47 <kerlo> All Haskell needs now is dependent typing and choose :: forall x :: [a] => if null x then () else a
14:37:48 <Cale> SamB_irssi: Or events in a gui system, perhaps.
14:37:52 <drdozer> Cale: extensible records would be another useful thing
14:37:55 <Cale> drdozer: yes
14:37:58 <kerlo> s/[a]/Set a/
14:38:01 <Cale> This is dual to that.
14:38:09 <Cale> Well...
14:38:18 <drdozer> Cale: well, you may as well do both at the same time
14:38:23 <kerlo> And, of course, everything :: forall a :: * => a
14:38:26 <Cale> Extensible variants probably could be handled without the need to predeclare them
14:38:31 <Cale> yes
14:38:35 <kerlo> s/=> a/=> Set a/
14:38:44 <kerlo> I'll say something correct one of these days.
14:38:55 <kerlo> s/correct/correctly/
14:39:16 <drdozer> Cale: I tend to fudge extensible records by having a hierarchy of classes defining the accessors
14:39:16 <ski_> (don't forget positional variants)
14:39:16 * SamB_irssi goes home
14:39:18 <monochrom> How do you prove a program correct when it uses some of those "open" things? That is the real challenge.
14:39:37 <kerlo> Simple!
14:40:35 <ski_> (kerlo : what, defining "correct" to mean "whatever the program is doing" ?)
14:41:24 <hackage> Uploaded to hackage: roman-numerals 0.1
14:41:24 <hackage> Uploaded to hackage: debian 3.23
14:42:10 <vixey> roman-numerals? heh
14:42:19 <vixey> @hackage roman-numerals
14:42:19 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/roman-numerals
14:42:51 <Cale> monochrom: Well, how do you prove a program correct when it handles all otherwise-unhandled cases in a uniform way?
14:42:53 <kerlo> open data Real; lub :: forall x :: Set Real => if empty x || not (bounded x) then () else Real; lubC :: forall x :: Set Real => forall _ :: not (empty x || not (bounded x)) => isLub (lub x) x
14:43:19 <ray> aww, no haddock
14:43:25 <vixey> kerlo, what language is that ??
14:44:00 <kerlo> vixey, Haskell on <insert substance here>.
14:44:07 <ray> haskellll
14:44:09 <drdozer> another nice thing would be the ability to use _ in type expressions - each _ would match a unique type
14:44:18 <vixey> Haskell on Hydrogen
14:44:24 <drdozer> _ -> _
14:44:27 <ray> HHaskell
14:44:36 <vixey> drdozer, yeah would be good
14:44:39 <kerlo> I think Haskellll is the best name for it.
14:45:13 <vixey> kerlo, (I've seen a proper spec. for open data.. before though,)
14:46:06 <kerlo> Actually, I like the idea of calling it xaursamban.
14:46:25 <ski_> drdozer : "unique type" ?
14:46:38 <ski_> drdozer : so `_ -> _' wouldn't match `Bool -> Bool' ?
14:47:12 <trygvis> anyone know of a good intro to using packages from hackage/cabal? I've never used it before
14:47:29 <vixey> ski_, things like   (:[]) :: a -> [_],   would typecheck
14:47:40 <vixey> ski_, whereas   (:[]) :: a -> [b] is a type error
14:47:53 <jpcooper> trygvis, I believe that Real World Haskell has such information
14:48:14 <dcoutts> trygvis: http://www.haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package
14:48:17 <trygvis> ah, ok
14:48:41 <ski_> vixey : yes, that's what i think would be useful .. but i wondered what the "unique" of drdozer's meant
14:48:44 <drdozer> ski_: _ -> _ would be the same as a -> b, for example
14:49:12 <drdozer> (_, _) -> _ is (a, b) -> c
14:49:17 <ski_> drdozer : so `(:[]) :: a -> [_]' wouldn't type-check, then ?
14:49:43 <drdozer> ski_ no, since it would be equivalent to a -> [b]
14:50:31 <ski_> so you want `_' to act like a type variable, except no name is used (and so you can't indicate sharing)
14:50:35 <ski_> ?
14:50:48 <drdozer> ski_: exactly
14:51:11 <ski_> vixey seemed to want something different
14:51:26 <drdozer> ah - hum what's that then?
14:52:02 <kerlo> It'd be nice if type constructors could be polymorphic.
14:52:14 <ski_> yes
14:52:15 <loadquo> @instances Num
14:52:16 <lambdabot> Double, Float, Int, Integer
14:52:33 <vixey> drdozer, that seems sort of useless
14:52:50 <vixey> drdozer, I would prefer _ -> _ to have different meaning to  a -> a, a -> b, Int -> Bool etc
14:52:55 <ski_> kerlo : but it's not entirely clear how to type their data constructors, in the case of data types ..
14:53:25 <drdozer> vixey: I'd use it mainly in instance declarations where you have lots of 'extra' types floating about in the superclass expression
14:53:31 <vixey> drdozer, I don't see why you can't just write a b c rather than _ _ _
14:53:53 <drdozer> vixey: you can, but then you're making up names for things you don't care about
14:54:23 <ski_> kerlo : consider e.g. `Flip :: forall k0 k1 k2. (k1 -> k0 -> k2) -> (k0 -> k1 -> k2)' .. how would you type a data constructor for that `newtype' ?
14:54:35 <drdozer> so vixey - what would you like it to mean?
14:55:42 <Cale> It would be nice if _ in type signatures meant "please infer this portion of the type for me"
14:55:48 <pumpkin> yeah
14:56:24 <Cale> So you could provide some information about the type without having to provide a complete signature.
14:56:33 <conal> i like that idea.
14:56:45 <conal> also in code, via something like djinn.
14:57:02 <pumpkin> you can approximate that in an ugly way by sticking type annotations inline
14:57:03 <drdozer> so sort of an intermediate between providing and not providing a full signature?
14:57:05 <pumpkin> but it feels dirty
14:57:15 <conal> term inference is especially useful with dependent types.
14:57:16 <Cale> drdozer: yes
14:57:21 <ddarius> @google oleg partial type annotations
14:57:34 <lambdabot> http://okmij.org/ftp/Haskell/types.html
14:57:34 <lambdabot> Title: Haskell Programming: Types
14:57:43 <Cale> I believe this was originally Philippa's idea, btw.
14:57:52 <drdozer> Cale: I quite like that idea - and it would cover my use-case as a happy side effect
14:59:35 <drdozer> I guess that providing no type would be equivalent to foo :: _
14:59:40 <ski_> yes
14:59:42 <Cale> drdozer: right
14:59:56 <drdozer> you can almost hear my brain clunking :D
15:00:31 <ski_> ocaml allows the equivalent of `yum :: forall a. w @ (a -> w)', btw
15:00:52 <Cale> ski_: What does that mean?
15:01:03 <ddarius> With rectypes
15:01:07 <ski_> *nod*
15:01:09 <Cale> oh
15:01:18 <ddarius> yum : w where w = (a -> w)
15:01:22 <Cale> yeah
15:01:25 <ski_> yes
15:01:26 <Cale> okay
15:02:34 * ski_ .oO( so .. could there be a use of having or-patterns in types ? )
15:03:47 <Cale> Maybe.
15:04:25 <Cale> Sort of strange though. It would be rather like existentials, in that only operations which could be applied to any of the possible types would be permitted.
15:04:41 <ddarius> Union types ?
15:04:49 <Cale> yes
15:05:19 <ski_> could you elaborate ?
15:06:17 * ski_ would like a coherent theory of patterns
15:07:24 <Cale> You could have something like  foo :: (Int | Char) -> (Int | Char) -> String; foo x y = show x ++ show y
15:07:48 <Cale> of course, that already has a more general type
15:08:14 <Cale> But any function which uses methods of typeclasses for which there are instances of both Int and Char would be fine.
15:08:17 <chrisdone> dons: "Haskell has -XUnicodeSyntax" is a true statement and I don't see people inside the haskell community disputing that you're generally talking about GHC when you're saying what awesome things you can do with Haskell. "LordVoldemort" is clearly butthurt to the point of pedantry :-P
15:08:17 <Philippa_> Cale: re _ in types, I'm pretty sure others've proposed it before. I made a more detailed proposal for something a bit more powerful where users can use explicit metavariables though
15:09:06 <ski_> (Cale : hm .. i'm not sure that's the same as what i had in mind ..)
15:09:06 <ddarius> The simplest thing to use to get union types is to simply have the "union" be the join in the subtyping lattice.
15:09:10 <Cale> s/instances of/instances for/
15:10:21 <ddarius> Explicit meta-variables would be useful, though you can already get that today with Oleg's trick (albeit not as prettily)
15:10:34 <drdozer> I do miss the OO ability to put things of different types with the same interface into a single data-structure
15:10:48 <ski_> drdozer : existentials
15:11:19 <drdozer> ski_ but it's pathalogically painful to do anything with e.g. a list of existentials
15:11:30 <Cale> drdozer: alternately, take the interface itself and put it in the datastructure.
15:11:38 <ski_> yes, real existential would be nicer
15:11:44 <Philippa_> the boxing and unboxing is tedious
15:12:02 <drdozer> not only tedious, but by construction, closed-world
15:12:14 <Cale> drdozer: hm?
15:12:17 <ski_> [exists x. (Show x,Ops x) *> x]
15:12:18 <ddarius> drdozer: What are you talking about?
15:12:23 <Philippa_> ...huh? Not in any sense I understand
15:12:27 <Cale> drdozer: Isn't the point of existentials to keep the world open?
15:12:35 <psykotic> a lot of things OO-style done with existentials can also be done with plain old record types.
15:12:47 <drdozer> well, say I have a list of showables?
15:12:51 <ski_> psykotic : yes
15:12:52 <Cale> drdozer: okay
15:13:10 <Cale> drdozer: you might as well have a list of Strings of course.
15:13:18 <drdozer> so ... unless I know the possible range of concrete types of these showables, how do I call show on them?
15:13:36 <Philippa_> you just unbox and call
15:13:39 <Cale> drdozer: You know that you can call Show because that's stated by your existential.
15:13:39 <ddarius> drdozer: The prettiest way is to make Showable an instance of show.
15:13:40 <ski_> drdozer : unpack and call `show'
15:13:44 <Philippa_> you know there's a show instance
15:13:48 <Philippa_> that's all you needed to know
15:13:50 <Cale> show (Showable x) = show x
15:14:07 <Cale> data Showable where Showable :: (Show a) => a -> Showable
15:15:29 <Cale> Of course, that's a pretty boring existential. Unless you really care about, say, showsPrec, it's pretty much equivalent to String.
15:15:57 <drdozer> Yeah, but typically you are not using Show - you're using something with multiple operations
15:16:02 <Cale> right
15:16:11 <Philippa_> and that's fine, they all still work
15:16:18 <psykotic> btw, though TAPL is considered a theory book, it has a really good running discussion of different ways to deal with OO-style abstraction in functional languages with HM-style type systems
15:16:35 <psykotic> starting with tuples/records and going through existentials
15:16:57 <ddarius> psykotic: Unfortunately most of the fuller examples you wouldn't really want to use.
15:17:06 <psykotic> that's true
15:17:20 <Cale> In most cases, you can get around using existentials just by using records of the methods which have been pre-applied to your data.
15:17:26 <psykotic> nevertheless i don't know any other locus classicus for this sort of discussion... maybe some sort cardelli paper? dunno
15:17:32 <leimy> so this multithreaded haskell via forkIO with Chan stuff sure is cake.
15:17:43 <Philippa_> Cale: yeah, that's not at all like dictionary transforming the code yourself :-)
15:17:46 <ddarius> psykotic: There is indeed a Abadi and Cardelli precisely on it.
15:18:03 <drdozer> Cale: yes, with some of the functions partly applied
15:18:03 <ddarius> @google "Comparing object encodings"
15:18:06 <trygvis> how do I tell ghci to use the packages I've just build with cabal?
15:18:09 <lambdabot> http://citeseer.ist.psu.edu/312942.html
15:18:09 <lambdabot> Title: Comparing object encodings - CiteSeerX
15:18:16 <drdozer> it's probably just my OO roots showing through
15:18:32 <ddarius> Ah, Bruce, Cardelli and Pierce
15:18:53 <Cale> Philippa_: But in some cases, it's actually easier to manage, and in even more, you discover that you don't really need to carry the whole dictionary around everywhere, and the thing specialises into a cleaner functional solution :)
15:18:58 <psykotic> pierce, right, that explains that prominent treatment in tapl then
15:19:01 <ddarius> Philippa: It isn't.  It's like closure conversion in reverse.
15:19:45 <ddarius> Philippa: If you are using existentials, you are also "passing the dictionary" around yourself.
15:19:47 <Philippa_> ddarius: that too. Depends what you reckon's the original and what's the encoding
15:20:11 <Philippa_> almost, yeah
15:24:10 <ddarius> leimy: Read http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.44.2355
15:24:32 <leimy> ddarius: seen it :-)
15:24:41 <ddarius> Good.
15:24:56 <leimy> In fact I had a brief email discussion with Rob regarding wanting typed channels for C++ that worked like plan 9's libthread stuff.
15:25:17 <leimy> Also, I program in Limbo sometimes too, which is all about this typed data channel stuff :-)
15:27:43 <ddarius> leimy: So going to be making some cool libraries based around concurrent processes communicating via channels?
15:28:07 <leimy> ddarius: nah, I've not got a lot of time since becoming a dad for free time stuff, mainly just work stuff.
15:28:38 <leimy> the plan9port stuff that Russ Cox did was pretty cool though.
15:29:08 <leimy> and, while not C++, can get the job done.
15:29:10 <pumpkin> ooh can I call you daddy?
15:29:18 <leimy> You could, but that'd be weird.
15:29:46 <pumpkin> fair enough
15:35:45 <pao_> Hi all, I'm trying to link a .o (compile from C++) with ghci
15:35:50 <pao_> I get unknown symbol `__Znam'
15:35:52 <pao_> any idea?
15:36:37 <athos> hmm, i don't get why there's so much "different" development going on in the plan9 community. i mean you've got plan9, octopus (maybe i forgot the correct name), inferno.. i know of course that they all have different goals, but they share much details. so why isn't the community focusing on one item? do plan9 fanboys hate limbo because of the pascal-ish syntax?
15:37:18 <ketil> pao_, isn't that a typical C++ name mangling thing?
15:37:18 <lambdabot> ketil: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:37:45 <Peaker> is there an ask aliased to id for the (->) reader?
15:38:11 <ddarius> Peaker: ? ask
15:38:17 <ddarius> > ask 3
15:38:19 <pao_> ketil: I guess so... but I can usually link with that object file with standard C code...
15:38:19 <lambdabot>   3
15:38:24 <Peaker> ddarius: ah, thanks
15:40:24 <Gracenotes> @src unzip
15:40:24 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
15:40:57 <pao_> .... libstdc++ seems to be what is missing...
15:41:24 <hackage> Uploaded to hackage: flow2dot 0.4
15:47:53 <pao_> ghci -lstdc++.6 -L/Developer/SDKs/MacOSX10.5.sdk/usr/lib/
15:47:58 <pao_> this did the trick
15:48:08 <Gracenotes> hrm. It's pretty hard to duplicate data in Haskell, even when design requires it...
15:48:42 <pumpkin> duplicate data?
15:48:49 <Gracenotes> e.g., I need both a 2D array of monsters, and a list of monsters corresponding to coordinates where they are
15:49:08 <Gracenotes> 2D array of squares, that is, which may include monsters
15:49:17 <pumpkin> why do you need duplicate monsters?
15:49:49 <pumpkin> if you really need a list of monsters, can't you just replicate n Monster
15:49:56 <pumpkin> assuming Monster is your constructor
15:50:01 <Gracenotes> having only a list would be inconvenient, as one would have to loop through it to check if a monster is at so-and-so square.
15:50:28 <Gracenotes> having only a matrix would be inconvenient, as one would have to check every square for monsters when processing a turn
15:50:39 <Gracenotes> monsters may be created and destroyed at any time, not to mention
15:50:57 <pumpkin> so maintain two structures? you still shouldn't need to duplicate a monster though
15:50:58 * roconnor listens carefully to Gracenotes
15:51:30 <Gracenotes> pumpkin: how do propose keeping a monster "m" both in the list, and in the 2D array?
15:51:41 <Gracenotes> or a reference to one, anyway?
15:52:00 <pumpkin> the only thing defining a monster is its location, it seems, so why do you need to identify it otherwise?
15:52:16 <Gracenotes> there are different types of monsters, each with its own state
15:52:40 <Gracenotes> hm. I could make the list merely one of coordinates
15:52:40 <BMeph> Gracenotes: Maybe you're just using the wrong data structure. :)
15:52:46 * roconnor is having a similar "identity" crisis with his game
15:53:07 <pumpkin> Gracenotes: so you just need to insert the same monster into two datastructures?
15:53:13 <BMeph> Gracenotes: What about a Map of Monster -> Locale, which you can extract as a list? :)
15:54:18 <Gracenotes> BMeph: hm. I'm not sure what use it would be as a map... lemme think
15:54:19 <BMeph> ...or I could be totally lost - it's my normal state, anyway. :)
15:54:45 <Gracenotes> well, the also-confusing part is that there are type datatypes: Square and Coord (type Coord = (Int, Int))
15:54:50 <Gracenotes> *two datatypes
15:55:02 <Gracenotes> myarray ! coord -> square
15:55:15 <BMeph> Gracenotes: E.g., keys == list of Monsters, values == list of Monster-occupied spaces. :)
15:55:20 <pumpkin> Gracenotes: it seems like you want a GameState type or something, containing a Grid/Map pair, and then have addMonster take a GameState, a Monster, and return a new GameState with that Monster added to both structures?
15:55:29 <Gracenotes> my solution so far, actually, is to have the monster contain the coord itself
15:55:57 <Gracenotes> data Monster = Monster Coord MonsterType
15:56:08 <BMeph> Gracenotes: Turn it inside-out; have the Coord contain the
15:56:08 <Gracenotes> (MonsterType holding a bunch of other data)
15:56:12 <roconnor> Gracenotes: that's what I'm thinking, but I can have more than one piece at any location.
15:56:20 <BMeph> Gracenotes: Turn it inside-out; have the Coord contain the Monster! ;)
15:56:20 <Gracenotes> roconnor: in my game too :)
15:56:36 <Gracenotes> BMeph: well, a Coord is just an (Int, Int), literally. type Coord
15:57:14 <Gracenotes> roconnor: i.e., a Serpent in mine. I might have a SerpentPiece monster, I think.
15:57:30 <BMeph> Gracenotes: Oh, okay. Don't mind me, I'm just brain-storming here. Maybe it's the sunny weather, but my brain-storms always seem like light drizzle. ;)
15:57:39 <pumpkin> Gracenotes: I think what I'm saying would work okay, though
15:57:49 <Gracenotes> BMeph: your ideas would make sense. I just need to think how to implement them...
15:57:55 <roconnor> Gracenotes: I try to think to myself: what would conal do.
15:58:24 <Gracenotes> and the rays of light shine upon your computer screen?
15:58:33 <roconnor> not yet
15:58:39 <mathijs> Hi all, I'm compiling ghc-6.10.1. Do CFLAGS matter in this case? I mean, the RTS is compiled now too right? since it's statically linked to all binaries ghc creates. So will CFLAGS during ghc's compilation produce a better/faster RTS?
15:58:46 <Gracenotes> plus, rays of lights are overrated. Too much glare.
15:58:54 <pumpkin> especially on glossy screns
15:58:57 <pumpkin> screens
15:59:08 <Gracenotes> The glare being convoluted design, perhaps :P
15:59:30 <roconnor> I think conal would make the piece a function of "time" where time is the history of intraction.
15:59:33 <Gracenotes> "I have six embedded domain-specific languages to make a 'monster dying' sound..."
15:59:40 <roconnor> but i'm not conal
15:59:44 <roconnor> unfortunately
15:59:59 <Gracenotes> yeah, I would like to have an undo feature
15:59:59 <roconnor> I haven't gone very far with this idea yet
16:00:25 <Gracenotes> for that, though, I could just keep Rooms
16:00:32 <roconnor> certainly undoing would be a simple operation in with this in mind, also scripting games would be easy
16:00:34 <Raynes> @src show
16:00:34 <Gracenotes> or maybe have deltas..?
16:00:34 <lambdabot> show x = shows x ""
16:00:47 <roconnor> making my game scriptable is an essential property I'm looking for
16:00:58 * BMeph makes a bracelet with "WWMcBD?" on it, then passes it to roconnor.
16:01:01 <roconnor> not only is it  a nice feature, I think it will also drive a clean design
16:01:12 <Gracenotes> what kinds of scripts?
16:01:29 <roconnor> BMeph: McBride?
16:01:51 <BMeph> roconnor: Oops, NM, I thought you said "Conor", not "Conal". :)
16:01:55 <roconnor> Gracenotes: a script would contain a "list" of choices made during the game.
16:01:57 <Gracenotes> also, since many many rooms can yield another certain room, the undo operation couldn't just be a copy of the action; it would have to be the reverse action, for all players on the screen
16:02:12 <roconnor> BMeph: Conor may also have good ideas
16:02:28 <roconnor> Gracenotes: or replay from the beginning
16:02:28 <Peaker> Nafai: you there?
16:02:37 <Peaker> quicksilver: you there?
16:02:46 <Gracenotes> roconnor: that's a necessary feature for me, since the room restarts upon getting killed
16:03:20 <Gracenotes> (also, there are not only monsters for me, but also walls, doors, etc.)
16:03:24 <roconnor> ya.  In general I'm trying to stop looking at the game imperatively.
16:03:35 <roconnor> Haskell is about data dependency, not time dependency.
16:03:52 <roconnor> choices drive a game forward
16:04:05 <roconnor> or so my thinking goes
16:04:18 <roconnor> but it's hard
16:04:23 <roconnor> to think this way
16:04:39 <roconnor> I hope I get to use a big mfix somewhere
16:05:15 <Gracenotes> mfix, you say?
16:05:21 <Gracenotes> whasthat
16:05:57 <pumpkin> I really want to hack on uvector but I don't want to spend time on it if I'm doing it all wrong
16:05:59 <loadquo> @type fix
16:06:00 <lambdabot> forall a. (a -> a) -> a
16:06:06 <loadquo> @type mfix
16:06:07 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
16:06:37 <roconnor> Gracenotes: if you don't know mfix, don't worry about it
16:06:38 <dons> hey pumpkin
16:06:42 <roconnor> I probably won't use it
16:06:46 <dons> i'm back home now, so will process your mails tomorrow
16:06:47 <roconnor> but if I do, I'll let you know
16:06:49 <Nafai> Peaker: Yeah
16:06:53 <pumpkin> dons: ooh!
16:06:58 <Peaker> Nafai: I've got a new interesting version to pull
16:06:59 <pumpkin> dons: sorry agian for flooding you so much :)
16:07:03 <dons> no, it's fine.
16:07:07 <pumpkin> I got rather excited
16:07:16 <Nafai> Peaker: Sure!
16:07:17 <Peaker> Nafai: mucho new functionality :-)  It has a "reflective keymap widget" showing you available keys
16:07:24 <BMeph> pumpkin: UR (maybe not) DOIN IT RONG! ;p
16:07:29 <Gracenotes> how efficient is //, by chance? The arrow replace operation.
16:07:35 <pumpkin> BMeph: onoes, what I was afraid of!
16:07:35 <Gracenotes> array replace, I mean
16:07:36 <pumpkin> maybe http://is.gd/Gf7 ?
16:07:46 <ddarius> Gracenotes: It makes a copy.
16:07:46 <pumpkin> Gracenotes: on DiffArrays, very efficient :P
16:07:55 <pumpkin> or maybe that's \\
16:07:58 <Gracenotes> perhaps I should use a DiffArray :3
16:08:02 <Nafai> Peaker: Oh, nice!  Pulling and building
16:08:04 <pumpkin> but those are encased in IO
16:08:13 <Gracenotes> after all, I am making repeated small changes to an array
16:08:20 <Gracenotes> a rather large array
16:08:28 <pumpkin> it makes older elements progressively slower though
16:08:29 <Peaker> Nafai: you can re-pull in a sec, I made the reflection widget look nicer now
16:08:33 <pumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-Diff.html
16:08:35 <Peaker> Nafai: pushed
16:08:43 <Gracenotes> pumpkin: I don't care terribly much about old elements
16:08:51 <pumpkin> then just use a mutable array?
16:08:53 <Gracenotes> if by old elements you mean old versions
16:08:54 <pumpkin> or a Map
16:08:58 <pumpkin> yeah
16:09:14 <Gracenotes> well, a grid-as-aMap might not be the easiest to render :)
16:10:17 <pumpkin> maybe you should just go with an ST-encased mutable array for your board state?
16:10:42 <Nafai> Peaker: Looking cool!
16:10:47 <Peaker> Nafai: :-)
16:11:10 <Gracenotes> pumpkin: then... everything would have to be in ST?
16:11:32 <pumpkin> Gracenotes: well, depends on how you structure it, but possibly not
16:11:48 <Gracenotes> the problem is, also, that distinct calls of a keypress callback need the array
16:12:06 <Gracenotes> not to mention distinct calls of the rendering function
16:12:17 <Gracenotes> so I've used an IORef Board
16:12:28 <Peaker> Nafai: The widget model has completely changed, I think its pretty elegant/cool
16:12:30 <loadquo> IOUArray?
16:12:48 <pumpkin> not sure he wants U if it contains arbitrary state
16:13:30 <Badger> I.O.U - 1 Array
16:13:31 <loadquo> Hmm, true, I forget the name of the boxed array.
16:13:54 <SamB> is it IOMEArray ?
16:14:20 <Peaker> Nafai: Widget is now a function from a model to a record of functions { draw, size, getKeymap }  where "getKeymap" specifically can return new models for keys. The user of the widget can of course reject models it doesn't like so you get "Transactional" model changes
16:14:24 <Gracenotes> it already is a UArray.. (IArray, anyway)
16:15:07 <Gracenotes> okay, so shove everything in the IO monad and use an IOUArray, then? :P
16:16:07 <Gracenotes> hrm.
16:20:34 <pumpkin> Gracenotes: I'd use the ST versions over the IO versions
16:20:37 <loadquo> Is the IOArray just undocumented?
16:20:54 <Peaker> Nafai: in other words, its a purely functional widget set (only the main loop has IO)
16:20:55 <pumpkin> they give you a bit more flexibility to segregate things without pushing IO all over the place
16:21:58 <Gracenotes> hm. So, I could shove a series of minor modifications of an array in an ST, then execute them all at once.. without invoking IO. Is this so :?
16:22:19 <SamB> no, you have to execute them in series
16:22:29 <loadquo> You can also make the code polymorphic between Array type. They are both instances of MArry, so the decision doesn't have to be made straight away.
16:22:35 <SamB> (but you don't need to reallocate the array, which is probably what you meant ;-)
16:22:38 <Nafai> Peaker: That is way nice
16:22:39 <pumpkin> ST allows you to mutate stuff, as long as the mutability doesn't leak
16:22:39 <loadquo> MArray
16:23:03 <Nafai> I had a little bit of trouble separating the pure from impure when doing gtk2hs programming
16:23:09 <kerlo> This prime number program made it to 33,654,253 before kind of stalling.
16:23:13 <SamB> what you can't do is have it polymorphic in value type but fixed at STUArray
16:23:16 <Peaker> Nafai: I hope the code is somewhat readable, though I am not sure :)
16:23:26 <kerlo> I think the lesson here is that Integer is really, really slow when it's not acting as an Int.
16:23:29 <Peaker> Nafai: Did I tell you about how focus management works?
16:23:33 <Gracenotes> even copying a UArray to an STUArray, modifying it, and then copying it back would be nice
16:23:36 <Nafai> Peaker: If you did, I've forgotten :)
16:23:55 <SamB> kerlo: compiled ? what optimization level ?
16:23:58 <Gracenotes> obviously, not copying it per se, but getting a reference to a new UArra
16:24:00 <Gracenotes> y
16:24:32 <SamB> @hoogle freeze
16:24:32 <lambdabot> Data.Array.Base freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
16:24:33 <lambdabot> Data.Array.MArray freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
16:24:33 <lambdabot> Data.Array.Base freezeSTUArray :: Ix i => STUArray s i e -> ST s (UArray i e)
16:24:39 <SamB> @hoogle thaw
16:24:39 <lambdabot> Data.Array.Base thaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
16:24:40 <lambdabot> Data.Array.MArray thaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
16:24:40 <lambdabot> Data.Array.Base thawSTUArray :: Ix i => UArray i e -> ST s (STUArray s i e)
16:24:57 <billybob> so i'm trying to learn haskell a bit, but i need a place to muck around. i learn best playing with graphics, and libraries or suggestions to try out?
16:24:59 <SamB> @hoogle runSTUArray
16:24:59 <lambdabot> Data.Array.ST runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
16:25:11 <SamB> Gracenotes: use runSTUArray and thaw
16:25:12 <Gracenotes> so it's built-in... not hack-hack-hack-hack-hack
16:25:16 <SamB> just one copy
16:25:27 <SamB> well, it is kinda hack-hack
16:25:31 <Peaker> Nafai: Instead of a global "focus" thing -- widgets generally don't know about focus.. Only the draw/size functions take an "isFocused" input to potentially draw themselves differently, but otherwise, widgets think they are always getting events ("in focus").  Only a couple of widgets are focus-aware. Grid, which delegates focus to the "Current" child widget, and "FocusDelegator" which can take focus to itself, or delegate it to its only child (FocusDeleg
16:25:31 <Peaker> ator is the one taking the enter/escape keys).  The inner widgets key bindings override the outer ones, and only for keys that actually have meaning, so when you press "right" it will go to the inner-most box until it has no more right, at which point the parent box will take it
16:25:34 <SamB> but the hacking is already done ;-P
16:25:36 <SamB> and in base
16:25:50 <kerlo> billybob: well, there are certainly graphics libraries for Haskell.
16:26:10 <kerlo> SamB: no, GHCi.
16:26:13 <Nafai> Peaker: Cool
16:26:15 <Gracenotes> SamB: which doesn't require IO, right?
16:26:18 <Peaker> Nafai: The Text Edits, for example, are "always editing", but the reason you press enter to edit is because they're surrounded with a "FocusDelegator"
16:26:24 <SamB> Gracenotes: indeed
16:26:25 <billybob> kerlo, any more popular than the next?
16:26:29 <dons> billybob: maybe look at gtk2hs
16:26:31 <SamB> kerlo: try compiling ?
16:26:33 <dons> that's the most popular
16:26:39 <kerlo> SamB: will do.
16:26:46 <dons> but also, visit hackage.haskell.org , and pick one you like under the 'graphics' category
16:26:51 <Gracenotes> hm, seems good. Yet another monad invades my code! :)
16:27:28 <kerlo> I wonder if the NotNot monad is completely useless.
16:27:49 <billybob> ah thanks will look. i'm guessing haskell to flash bytecode would not be in the cards :/
16:27:55 <SamB> personally, I'd often end up using IO because of that damn forall not being handled well
16:28:01 <dons> there's some old DSL for generating swfs
16:28:06 <SamB> kerlo: it's probably not a monad
16:28:06 <dons> but not sure how active it is.
16:28:08 <kerlo> What is DSL?
16:28:16 <SamB> kerlo: Domain Specific Language
16:28:21 <dons> embedded language inside haskell
16:28:25 <kerlo> SamB: well, NotNot (NotNot a) -> NotNot a seems to be plenty possible.
16:28:29 <dons> (Domain Specific Language)
16:28:32 <SamB> short for EDSL, or Embedded Domain Specific Language
16:28:41 <lament> short for Meaningless Buzzword
16:29:05 <SamB> basically means "library with lots of combinators"
16:29:10 <SamB> whatever THOSE are
16:29:30 <dons> not really.
16:29:32 <lament> i thought it was short for "something that looks like it could be a separate small language"
16:29:38 <SamB> okay, whatever
16:29:42 <dons> yes.
16:29:53 <dons> i.e. has variables, control structures, could have its own code gen
16:29:54 <SamB> but those always have plenty of combinators, yes ?
16:30:18 <SamB> dons: I thought they usually hijacked Haskell variables
16:30:25 * kerlo frowns at the fact that ghc --make primes.hs didn't actually make an .exe
16:30:37 <billybob> i've heard it called "meta-programming" - another silly term to add
16:30:47 <lament> meta-programming is more meaningful
16:30:48 <pumpkin> kerlo: what did it make?
16:30:53 <SamB> billybob: nay, that's stuff like Derive
16:30:57 <kerlo> pumpkin: one .hi and one .o.
16:31:09 <lament> metaprogramming is just writing programs that write programs
16:31:24 <SamB> kerlo: what module is it ?
16:31:30 <SamB> does it have a main function ?
16:32:15 <kerlo> Not to be confused with Matrioshka programming, writing programs in programming languages written in programming language description languages.
16:32:35 * lament writes a program that writes kerlo 
16:32:36 <SamB> shouldn't there be more layers?
16:32:45 <kerlo> SamB: module Primes where . . . main = print primes
16:32:58 <kerlo> lament: send me a copy, will you? There are some improvements I'd like to make to myself.
16:33:01 <SamB> kerlo: that's your problem, then
16:33:05 <thoughtpolice> kerlo: either pass -main-is Primes.main or change 'Primes' to 'Main'
16:33:06 <SamB> s/Primes/Main/
16:33:12 <kerlo> Okay.
16:33:12 <pumpkin> SUP DAWG I HEARD YOU LIKE PROGRAMMING SO I PUT A PROGRAMMING LANGUAGE INSIDE YOUR PROGRAMMING LANGUAGE SO YOU CAN PROGRAM WHILE YOU PROGRAM
16:33:52 <lament> @quote dawg
16:33:52 <lambdabot> mauke says: YO DAWG I HEARD YOU LIKE METACIRCULARITY SO WE PUT AN INTERPRETER IN YOUR INTERPRETER SO YOU CAN RUN CODE WHILE YOU RUN CODE
16:34:01 <pumpkin> :(
16:34:07 <Badger> :D
16:34:21 <Badger> @quote pumpkin
16:34:21 <lambdabot> pumpkin says: OMG I <3 RECORD SYNTAX
16:34:32 * SamB likes it so much he decides to take the fixpoint of the interpreter
16:34:41 <kerlo> Yo dawg I heard you like this joke so I put this joke in this joke so you can recurse while you recurse.
16:34:51 <kerlo> (Alternatively: . . . so you can laugh while you laugh.)
16:34:59 <SamB> @quote
16:35:00 <lambdabot> sieni says: scheme adheres to the TIMTOBFTTWTDI principle instead of TIMTOWTDI
16:35:00 * Badger thought the latter
16:35:16 <Badger> @quote SamB
16:35:17 <lambdabot> SamB says: C is a good language. If what you want is an assembly language where you can't be sure what anything does
16:35:28 <Badger> I do!
16:35:32 <lament> @quote dons
16:35:32 <lambdabot> dons says: ?users
16:35:39 <Badger> o_O
16:35:42 <lament> har har
16:35:46 <ksf> rotfl
16:36:02 <kerlo> Everyone knows Subleq is the best programming language, though. It's a machine language with no opcodes.
16:36:11 <kerlo> It doesn't need any opcodes, because there's only one instruction.
16:36:28 <pumpkin> just triples of parameters
16:36:36 <pumpkin> you implement your own instructions :P
16:36:51 <kerlo> Also, self-modification is required for Turing-completeness. C'est la Subleq.
16:36:59 <SamB> dons DOES say that a lot, doesn't he ?
16:37:14 <Badger> ?users
16:37:14 <lambdabot> Maximum users seen in #haskell: 658, currently: 633 (96.2%), active: 22 (3.5%)
16:37:31 * kerlo presses Ctrl+C, futilely.
16:37:32 <ray> make a push for a new record, invite all your friends
16:37:41 <lament> @quote records
16:37:41 <lambdabot> No quotes match. Just what do you think you're doing Dave?
16:37:44 <lament> @quote record
16:37:44 <lambdabot> pumpkin says: OMG I <3 RECORD SYNTAX
16:37:48 <Badger> hm
16:37:50 <lament> @quote prelude
16:37:50 <lambdabot> weitzman says: The Prelude needs verse numbers to use when quoting it.
16:38:01 <Badger> I thought #haskell had had 666 already. :)
16:38:13 <ddarius> Badger: Haskell has had at least 674
16:38:21 <ddarius> s/Haskell/#haskell
16:38:24 <Badger> lambdabot: liar!
16:38:30 <billybob> does haskell seem to be getting more popular in recent months?
16:38:33 <SamB> @quote sieni C
16:38:33 <lambdabot> sieni says: C provides people with the expressiveness of fortran combined with the portability of assembler
16:38:41 <dons> users rock
16:38:51 <MarcWeber> ray You don't have to bother your friends. You could just start many irc clients..
16:39:09 <kerlo> What's the highest optimization level?
16:39:18 <ray> dons gets a bonus based on the number of users in #haskell at the time his paycheck is written
16:39:21 <Zao> -OMG :P
16:39:27 <dons> -O2 -funbox-strict-fields -optc-O3 -fvia-C
16:39:34 <dons> -march=sse3 i guess
16:39:35 <kerlo> I can handle that.
16:39:39 <dons> -optc-march=sse3
16:39:48 <Debugger> -OMAX_INT
16:39:48 <pumpkin> omg that sounds blisteringly fast
16:39:57 <pumpkin> can you make ghc use icc as the back-end c compiler?
16:39:57 <dons> maybe i should submit a patch to ghc for -fO11 that does all those things
16:39:59 * Badger writes a horrible perversion of dons' irc bot using forever and forkIO
16:40:06 <dons> pumpkin: i've not tried it. would like to try
16:40:17 <kerlo> ghci -O2 -funbox-strict-fields -optc-O3 -fvia-C -march=sse3 -optc-march=sse3 --make primes.hs
16:40:19 <roconnor> I wonder if I should toss out my GRE scores
16:40:20 <kerlo> s/ghci/ghc/
16:40:24 <kerlo> Unless that's in the wrong order.
16:40:29 <dons> kerlo: without the first -march one
16:40:33 <dons> since that's a flag to gcc
16:40:37 <pumpkin> kerlo: you'll probably get better primes performance with no optimization and a better prime sieve :P
16:40:38 <dons> no, the order is right
16:40:40 <kerlo> Okay.
16:40:47 <dons> use a better sieve though (like a bit sieve?)
16:40:49 <gio123> @seen Cale
16:40:50 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I don't know when Cale last spoke.
16:41:04 <MarcWeber> pumpkin -OMAX_INT yes and incredible unstable :-)
16:41:06 <pumpkin> I can always tell when gio123 arrives
16:41:16 <gio123> @seen ski_
16:41:16 <lambdabot> ski_ is in #haskell.hr, ##logic and #haskell. I last heard ski_ speak 1h 27m 36s ago.
16:41:20 <SamB> so ... what does TIMTOBFTTWTDI mean ?
16:41:24 <hackage> Uploaded to hackage: flow2dot 0.5.1
16:41:24 <hackage> Uploaded to hackage: flow2dot 0.5
16:41:43 <ray> there is more than one billion, five thousand two ways to do it
16:41:51 <ray> not grammatically correct but neither is scheme
16:42:06 <redditbot> More longest paths, and sick folds
16:42:28 <pumpkin> sick folds!
16:42:33 <ray> siiiiick
16:44:22 <billybob> bodacious zips!
16:44:49 <ray> gnarly filters
16:46:22 <billybob> righteous maps?
16:46:36 <SamB> tubular ...
16:47:15 <roconnor> bells?
16:47:20 <SamB> no!
16:47:27 <SamB> that's not an FP thing!
16:48:29 <SamB> @yow
16:48:29 <lambdabot> Sometime in 1993 NANCY SINATRA will lead a BLOODLESS COUP on GUAM!!
16:48:35 <SamB> @proton
16:48:35 <lambdabot> is haskell able to outdo perl or python for web?
16:48:45 <SamB> BORING!
16:48:46 <SamB> @proton
16:48:46 <lambdabot> is haskell more powerful than perl? or scheme?
16:48:50 <SamB> @proton
16:48:50 <lambdabot> and haskell is general purpose?
16:48:53 <SamB> @proton
16:48:53 <lambdabot> check otu squeak seems dope
16:49:00 <SamB> @proton
16:49:00 <lambdabot> is functional ebtter than oo?
16:49:21 <SamB> orbitz can type better than that!
16:52:35 <ray> @faq is haskell able to outdo perl or python for web?
16:52:35 <lambdabot> The answer is: Yes! Haskell can do that.
16:53:17 <skorpan> @faq can haskell become completely useless once you learn python?
16:53:17 <lambdabot> The answer is: Yes! Haskell can do that.
16:53:29 <billybob> here's a FP question, I see there are opengl bindings for haskell. if i create a sphere and move it - am i creating a new sphere for every frame?
16:53:56 <ray> @faq Can Haskell help me crush my enemies, see them driven before me, and hear the lamentations of their women?
16:53:56 <lambdabot> The answer is: Yes! Haskell can do that.
16:54:00 * ray is sold
16:54:00 <MarcWeber> ray Strange question.. and strange answer.. What does outdo mean here? Amount of users? Max concurrent connections? Count of CMS systems written in that language?
16:54:19 <Zao> billybob: If you have the number 3 in a thunk and print it, will it be the same 3 the next time you print it?
16:54:44 <MarcWeber> @faq Can't lambdabot shut up ? :-))
16:54:44 <lambdabot> The answer is: Yes! Haskell can do that.
16:55:03 <billybob> no?
16:55:13 <MarcWeber> @faq
16:55:13 <lambdabot> The answer is: Yes! Haskell can do that.
16:55:26 <SamB> billybob: don't you do that with GL in imperative languages anyway?
16:55:31 <orbitz> i'm ane xceelnt typer!
16:55:35 <Adamant> @faq can Haskell increase global warming through massive multicore parallelization?
16:55:36 <lambdabot> The answer is: Yes! Haskell can do that.
16:56:04 <ray> @faq Is GHC really just a bunch of #defines for C?
16:56:04 <lambdabot> The answer is: Yes! Haskell can do that.
16:56:31 <Gracenotes> I have to say that the Data.Array documentation is confusing, but...
16:56:35 <billybob> i guess i'm thinking about the work that goes into first instantiating and object up front, then just changing postion values
16:56:44 <Gracenotes> *points gun at head*
16:56:49 <pumpkin> Gracenotes: yeah, it is :)
16:56:50 <SamB> Gracenotes: yes! the source is easier to read
16:56:51 <Gracenotes> (figuratively)
16:59:59 <Zao> billybob: Like GL in imperative languages, you have your transformation matrices and your immediate mode glVertex-like actions.
17:00:09 <Zao> billybob: You also have vertex buffer objects and such.
17:01:21 <Olathe> Haskell is amazing :D
17:09:35 <Gracenotes> I'm aware unsafePerformIO can do dangerous things, but I'd imagine most naive, "well-intended" uses of it (no matter how misguided) would at least not be /dangerous/, i.e. only damaging purity + possibly referential transparency
17:10:22 <Gracenotes> does this seem about right? I'm trying to think of instances where using it to "get around" IO would be dangerous, cause crashes, etc.
17:10:53 <pumpkin> I think the issue is not about it crashing
17:11:04 <pumpkin> but if the compiler makes assumptions about something being pure
17:11:08 <pumpkin> it might not compute it more than once
17:11:12 <pumpkin> when you want it to
17:11:22 <int-e> Gracenotes: you can destroy type safety - you can implement  unsafeCoerce  using unsafePerformIO
17:11:23 <pumpkin> things like unsafeCoerce can cause crashes easily
17:11:32 <int-e> Gracenotes: and that leads to crashes.
17:11:32 <pumpkin> oh then :)
17:11:51 <Gracenotes> int-e: yes, you *can* do that. But you wouldn't come up with it you were naively trying to get out of a RandomIO, for instance
17:11:54 <pumpkin> :t unsafePerformIO
17:11:55 <lambdabot> Not in scope: `unsafePerformIO'
17:12:00 <Gracenotes> IO a -> a
17:12:01 <pumpkin> @hoogle unsafePerformIO
17:12:01 <lambdabot> Foreign unsafePerformIO :: IO a -> a
17:12:01 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
17:12:03 <pumpkin> ok :)
17:12:13 <ddarius> Gracenotes: You can implement unsafeCoerce easily with unsafePerformIO and IORefs.
17:12:36 <ddarius> You can easily accidentally do something along those lines just using unsafePerformIO and IORefs.
17:12:44 <Gracenotes> yes, it can be used for all sorts of nasties. If you want to get ghci to crash, you can. But if you want a program to work and don't want to bother with IO, I don't think it would that terrible
17:12:48 <Gracenotes> in terms of crashes, anyway
17:12:53 <djsiegel1> Hello, Haskellers. I am interested in creating a FOSS Wordle clone in Haskell. Check out http://wordle.net -- I was wondering if anyone knows of a good SVG package, or if any of the existing Haskell XML packages would be good for generating SVG output.
17:12:54 <int-e> Gracenotes: 'naive' is hard to define. and you shouldn't use unsafePerformIO if you don't know (or have a good idea) where the line that you aren't allowed to cross is.
17:13:15 <pumpkin> only time I've used it is to get a quickcheck test to do file stuff
17:13:33 <Gracenotes> I know a friend who wants to use unsafePerformIO... :P No, really, I was just wondrin'.
17:13:35 <int-e> Gracenotes: feel free to experiment however
17:13:52 <pumpkin> just NEVER use unsafeLaunchICBM
17:13:56 <mathijs> Hi all, I'm building ghc-6.10.1 from source on ubuntu 8.10 64bit. I've used configure with --shared, I heard it should work on x86_64, right?  Anyway, stage1-inplace compiled fine, but stage 2 errors out because the ghc version can't be detected. Investigating some more, I found:
17:14:10 <SamB_XP> ddarius: thoughtpolice just tried that in LHC
17:14:21 <mathijs> tmp/ghc-6.10.1/ghc/stage2-inplace/libexec/ghc: Unable to start /home/mathijs/tmp/ghc-6.10.1/ghc/stage2-inplace/libexec/ghc_real: No such file or directory
17:14:26 <SamB_XP> he got a "head []" error ;-P
17:14:41 <ray> unsafeLaunchICBM can be easily written with unsafePerformIO
17:14:45 <billybob> if you install a cabal package from hackage, are there steps you need to take for an uninstall? or just delete from filesystem?
17:15:07 <Gracenotes> djsiegel1: Cairo is one possibly solution (albeit, maybe not the best way, but here it is): http://www.haskell.org/gtk2hs/docs/gtk2hs-docs-0.9.11/Graphics-Rendering-Cairo-SVG.html
17:15:10 <SamB_XP> billybob: you probably want to unregister it from the installed package database  ...
17:15:12 <Cale> billybob: you should ghc-pkg unregister it.
17:15:21 <djsiegel1> Gracenotes: eeek! Cairo...
17:15:26 <Gracenotes> heh
17:15:31 <billybob> thanks
17:15:39 <Gracenotes> actually, come to think of it, I'm not sure if Cairo outputs SVG, or merely reads them
17:15:42 <djsiegel1> I am the creator of GNOME Do... I get enough Cairo on that project.
17:16:03 <Gracenotes> okay :)
17:16:09 <djsiegel1> I do not think it outputs SVG.
17:16:28 <djsiegel1> But you did link me to an interesting SVG extension... Will read.
17:16:55 <djsiegel1> Yeah, these just render svgs to cairo contexts.
17:16:55 <Gracenotes> well, here are the Graphics packages listed with hackage, Haskell's package handling utility -- http://hackage.haskell.org/packages/archive/pkg-list.html#cat:graphics
17:17:13 <Gracenotes> no Ctrl+F for SVG, though
17:17:21 <djsiegel1> Yeah, did that.
17:17:33 <djsiegel1> Might have to hack HaXml(?)
17:18:20 <roconnor> Gracenotes: Cairo can output svg
17:18:26 <roconnor> svgcairo can input svg
17:18:33 <ksf> @djinn (a -> (b,c)) -> (a -> b -> c)
17:18:33 <lambdabot> f a b _ =
17:18:33 <lambdabot>     case a b of
17:18:33 <lambdabot>     (_, c) -> c
17:18:49 <SamB_XP> http://www.google.co.uk/search?hl=en&as_sitesearch=hackage.haskell.org/cgi-bin/hackage-scripts/package&as_q=svg
17:18:50 <Gracenotes> roconnor: which function outputs?
17:19:00 <roconnor> I need to look it up
17:19:09 <ksf> @djinn (a -> b -> c) -> (a -> (b, c))
17:19:09 <lambdabot> -- f cannot be realized.
17:19:10 <roconnor> maybe checking my sources is easier
17:19:14 <ksf> bastard.
17:19:27 <djsiegel1> roconnor: I'd love to know the function(s) name(s)
17:19:35 <SamB_XP> ksf: it can't!
17:19:43 <roconnor> withSVGSurface
17:19:46 <roconnor> for example
17:19:58 <SamB_XP> in the argument, b is in a negative position, but in the result, b is in a positive position
17:20:01 <SamB_XP> that doesn't work out
17:20:02 <roconnor> probably others in that same module
17:20:32 <roconnor> @djinn (a -> (b, c)) -> (a -> b -> c)
17:20:32 <lambdabot> f a b _ =
17:20:32 <lambdabot>     case a b of
17:20:32 <lambdabot>     (_, c) -> c
17:20:37 <roconnor> oh
17:20:40 <roconnor> that was done already
17:21:00 <ksf> somehow, I doubt that the first element of the tuple will ever be returned.
17:21:01 <roconnor> djsiegel1, Gracenotes: withSVGSurface
17:21:06 <djsiegel1> roconnor: by output SVG, I mean create an SVG file.
17:21:09 <Gracenotes> hm. withSVGSurface "myDraw.svg" pgw pgh (flip renderWith $ myDraw pgw pgh >> showPage)
17:21:10 <Gracenotes> says http://darcs.haskell.org/gtk2hs/docs/tutorial/Tutorial_Port/app1.xhtml
17:21:24 <roconnor> djsiegel1: yes I know
17:21:25 <Gracenotes> (the operative line, it seems)
17:21:27 <djsiegel1> ah, ok
17:21:28 <djsiegel1> I see it
17:21:45 <roconnor> that's probably not the only way
17:21:54 <djsiegel1> roconnor, Gracenotes you are my heros
17:22:01 <djsiegel1> I have some fun hacking ahead of me
17:22:10 <djsiegel1> heroes*
17:22:16 <Gracenotes> roconnor: none else came immediately to mind :) But there may be, indeed
17:22:16 * roconnor added the SVG output for haskell charts
17:22:19 <Gracenotes> *nothing
17:22:41 <roconnor> it was really a cut and paste of the ps and other outputs :)
17:22:59 <roconnor> oh wait
17:23:06 <roconnor> it was more
17:23:12 <roconnor> I abstracted the common code :)
17:24:15 <djsiegel1> Hmm, is there a nice combinator or set of datatypes for expressing 2d shapes, like in Hudak?
17:24:35 <djsiegel1> I guess I could borrow that and render them to cairo primitives
17:24:57 <SamB_XP> roconnor: I guess it COULD have been a cut and paste, but you didn't think that was the best way to maintain it all ?
17:25:01 * ksf fails both terminology and googling for negative and positive position
17:25:25 <ksf> I guess it's a thing everybody knows, so it wasn't in any lambda calculus description I read.
17:26:27 <SamB_XP> ksf: it's actually a logic thing
17:26:38 <ksf> what I am actually trying to do is to construct a value that contains a function that influences one of it's values.
17:26:39 * ddarius would more say type theory.
17:26:43 <SamB_XP> I'm sure I learned it when I was playing with Coq
17:26:50 <SamB_XP> ddarius: same difference
17:26:58 <SamB_XP> that's what I use for logic
17:26:59 <ksf> that is, the value isn't defined until you apply the function.
17:27:37 <ksf> I guess my main failure is formulating the original idea in terms of reactive and then trying to implement it in pure lambdas.
17:28:01 <seanmcl> whoami
17:28:05 <seanmcl> quit
17:28:06 <seanmcl> exit
17:28:11 <SamB_XP> try /quit
17:28:15 <seanmcl> sorry :)
17:28:18 <adekoba> looking for structure advice: media codecs often differ by little changes with each version. Would it be best to write separate functions for each version of the codec, or one function which tests for version and parses based on that?
17:28:50 <SamB_XP> adekoba: it depends!
17:29:11 <SamB_XP> ... also, won't you need more than one function ?
17:29:11 <ksf> make the parser parametrisable by version.
17:29:26 <SamB_XP> if they really are tiny changes, sure
17:29:29 <ksf> ...not by version, that is, but with different parsers.
17:29:37 <adekoba> SamB_XP: yes, but usually one function calls another, which calls another, etc.
17:29:47 <SamB_XP> adekoba: well, yeah.
17:30:01 <SamB_XP> how many differences are there, here ?
17:30:13 <adekoba> only one, very small change.
17:30:17 <billybob> you guys ever have problems going back to oop after spending a lot of time doing fp stuff?
17:30:39 <SamB_XP> in that case you could just do one set of functions and see if it performs well enough
17:30:48 <adekoba> SamB_XP: what would be the best way to test the version? Send each function the version?
17:31:06 <Olathe> > Just 5 >>= return.([]!!)
17:31:06 <SamB_XP> adekoba: you could use MonadReader
17:31:07 <lambdabot>   Just * Exception: Prelude.(!!): index too large
17:31:33 <adekoba> SamB_XP: neat, I'll look into that.
17:31:42 <dons> billybob: mmm. probably. you end up writing stateless, interfaced components, instead of using lots of inheretence and stateful objects, i guess
17:31:50 <SamB_XP> billybob: I could never figure out what oop was ...
17:31:52 <dons> and you probably cry a little inside every time you write a loop.
17:32:05 <SamB_XP> dons: what is this "loop" thing
17:32:31 * SamB_XP pretends to have been a SmallTalk user before Haskell ;-P
17:32:59 <ksf> @djinn (a -> a, a)
17:32:59 <lambdabot> -- f cannot be realized.
17:33:00 <ddarius> billybob: It's not OOP, it's mutable state that's problematic (or at least, I already didn't like stuff about OOP that would bother me long before I used FP).
17:33:37 <ddarius> SamB_XP: I've "used" Smalltalk before Haskell, but wouldn't call myself a "user" and didn't like it.
17:33:44 <wildbill`> is there a way to use :i of ghci to get the type info of an imported function, rather than one that is defined in the particular file?
17:33:48 <SamB_XP> referential transparency is considered good Python style
17:33:48 <ksf> Is there a page somewhere on how to abuse haskell syntax?
17:33:52 <ray> "going back to oop" implies you came from there and plan to go back!
17:34:05 <ddarius> ksf: There are papers on it, in some respects.
17:34:13 <billybob> i do graphics stuff, so i always thought about it as "here i have a circle, now i make it move". rather then thinking of a point in time at a given position.. there is no spoon!
17:34:15 <SamB_XP> ksf: how do you want to abuse it ?
17:34:19 <ddarius> ray: It implies more than "planning" to go back.
17:34:27 <wildbill`> similar to :m *similar to :browse *
17:34:58 * ddarius considers applying anti-OO to graphics...
17:35:24 <ksf> I want a value of type (a -> b, b), where the second b is only defined if the function has been asigned to something.
17:35:30 <ray> here i have a circle, now i apply a transformation
17:35:30 <SamB_XP> ddarius: what's that ?
17:35:36 <ksf> I know that that's a knot, but it's exactly the point.
17:35:39 <ddarius> @google "Anti-Objects"
17:35:41 <lambdabot> No Result Found.
17:35:46 <SamB_XP> ksf: "assigned"?
17:35:47 <ksf> I guess I'm gonna end up using TH.
17:35:53 <ksf> well, defined.
17:36:04 <ksf> That's why it won't work
17:36:06 <billybob> ray, but your not really applying it though, you creat a whole new circle correct?
17:36:06 <ddarius> http://www.cs.colorado.edu/~ralex/papers/PDF/OOPSLA06antiobjects.pdf
17:36:13 <Peaker> @tell quicksilver The widget design we discussed seems to have turned out pretty nice!  Check it out: git clone git://github.com/Peaker/lui.git
17:36:13 <lambdabot> Consider it noted.
17:36:26 <ray> well, if you don't like the old circle anymore, don't use it
17:36:41 <ksf> it's the syntax I care about, as having syntactical input parameters would make things unmanageable.
17:36:50 <ksf> ...too many symbols.
17:36:50 <billybob> i like it fine, i'd just like it better at a different point
17:38:38 <Olathe> ksf: Maybe (a -> b, b)
17:39:00 <ray> well, without getting too metaphysical, the result's the same
17:39:06 <ray> if you get metaphysical maybe it's not
17:39:49 <ksf> ...other possibilities include cooking noodles and nagging conal about merge.
17:40:38 * ksf decides on noodles.
17:41:20 <ray> other possibilities include cooking conal and nagging noodles about merge
17:41:22 <ray> you cannibal
17:44:24 <Olathe> Is there a kind of array that makes a single UArray look like a two-dimensional array ?
17:45:01 <Cale> Olathe: Simply index the UArray with pairs
17:45:30 <Cale> UArrays are only restricted in terms of their content, not the indices you use.
17:45:37 <Cale> (relative to Arrays)
17:46:07 <Cale> So for instance, you can use ((0,0),(100,100)) for bounds.
17:46:15 <Cale> and you'll get a square 100 by 100 array
17:46:16 <Olathe> It'll know that (1, 5000) is out ?
17:46:20 <Cale> yes
17:46:25 <Olathe> Ahh, thanks :)
17:47:30 <Cale> It's one of the things which makes Haskell arrays a little more complicated than the arrays in most other languages, but it's also one of the nicest things about them.
17:47:57 <Cale> (that they can be indexed with arbitrary types, so long as there's a suitable instance of Ix)
17:48:05 * ksf snarfs Peaker's code
17:48:41 <Peaker> ksf: is it readable?  I focused on getting it to work first
17:48:52 <Peaker> I'd like to get as much feedback as possible
17:49:21 <ksf> well, seeing what it's about has been reason enough to snarf it.
17:49:30 <dons> well, that one haskell array library
17:49:40 <dons> we should have nicer ones, if someone wants to play with the idea.
17:49:41 <Peaker> ksf: did you run it?
17:49:54 <dons> the immutability / mutability barrier is a fun one
17:49:59 <ksf> i didn't even git clone yet. but consider it snarfed.
17:50:12 <Peaker> heh..
17:50:17 <ksf> there's a race condition with my noodles, you see.
17:50:21 <Olathe> Heheh
17:50:44 <Olathe> cale: Yes, Haskell has some very nice tricks.
17:51:36 <Peaker> Cale: what is the exact restriction on UArrays' contexts? Is there a type-class for unboxed things?
17:52:10 <SamB_XP> @instances-importing Data.Array.Base IArray
17:52:10 <lambdabot> UArray Bool, UArray Char, UArray Double, UArray Float, UArray Int
17:52:13 <pumpkin> things that have # counterparts?
17:52:21 <pumpkin> not sure
17:52:26 <SamB_XP> @instances-importing Data.Array.Base Data.Word Data.Int IArray
17:52:27 <lambdabot> UArray Bool, UArray Char, UArray Double, UArray Float, UArray Int, UArray Int16, UArray Int32, UArray Int64, UArray Int8, UArray Word, UArray Word16, UArray Word32, UArray Word64, UArray Word8
17:52:28 <pumpkin> or maybe things with fixed sizes
17:58:49 <Gracenotes> I'm probably missing something -- but how do you get an unboxed ST array from an IArray?
17:59:03 <Gracenotes> (an unboxed IArray, at that)
17:59:07 <SamB_XP> thaw
17:59:15 <SamB_XP> @hoogle thaw
17:59:15 <lambdabot> Data.Array.Base thaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
17:59:15 <lambdabot> Data.Array.MArray thaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
17:59:15 <lambdabot> Data.Array.Base thawSTUArray :: Ix i => UArray i e -> ST s (STUArray s i e)
17:59:33 <Gracenotes> the arguments aren't fitting :/
17:59:46 <SamB_XP> Gracenotes: eh ?
18:00:39 <SamB_XP>  stuarr :: STUArray I El; stuarr <- thaw uarr
18:02:23 <Gracenotes> trying something like do {f <- M.thaw (listArray (0,5) [' '..]); return ()} `seq` 3..
18:02:33 <Gracenotes> No instance for (M.MArray b Char t)
18:03:01 <Gracenotes> even let o = M.thaw (listArray blah blah)... ghci doesn't like it
18:03:51 <ksf> peaker, it works.
18:04:03 <Peaker> ksf: cool
18:04:29 <Peaker> ksf: toyed around with it?
18:05:26 <ksf> I'm about to.
18:07:07 <Gracenotes> SamB_XP: okay... if I had to assign a specific type signature to (thaw (listArray (0,5) [' '..])), with no foralls, what would an example one be?
18:07:25 <SamB_XP> Gracenotes: oh, I forgot the forall thing ...
18:07:42 <SamB_XP> eh, just make sure you constrain the type SOMEWHERE
18:08:04 <SamB_XP> like in the type signature of the function that does the array modification
18:08:07 <Gracenotes> SamB_XP: an example of such...?
18:08:36 <SamB_XP> well, or just pass your do block to runSTUArray
18:08:54 <Gracenotes> ST's s is extremely weird.
18:09:01 <SamB_XP> yeah
18:09:09 <Gracenotes> it should be banned :X
18:09:17 <pumpkin> why??
18:09:34 * loadquo considers ST s voodoo still
18:09:36 <SamB_XP> I believe I've several times said that I'd rather just use unsafePerformIO ;-P
18:10:30 <Gracenotes> hackity hack hack
18:11:52 <Gracenotes> or does it become elegant once you learn it, not because it's actually elegant but because you can't make yourself accept that it's not elegant after the twisted hell you put yourself through trying to learn how it works...? :)
18:12:20 <SamB_XP> Gracenotes: it still doesn't fit
18:12:29 <SamB_XP> the type system needs work
18:12:39 <SamB_XP> it could be better than it used to be ...
18:12:56 <SamB_XP> I haven't used it in a while, really
18:13:30 <ddarius> The idea behind ST is pretty simple and elegant.
18:13:56 <ddarius> Whether it's joyful to use is something else, but it is a pretty simple solution to a relatively complex problem.
18:14:21 <loadquo> One thing I don't understand is newArray, I only pass it three parameters and it works somehow
18:14:22 <Gracenotes> hm, this seems to work as expected: runSTUArray $ do thaw (listArray (0,5) [' '..])
18:14:33 <loadquo> @hoogle newArray
18:14:33 <lambdabot> Data.Array.Base newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
18:14:33 <lambdabot> Data.Array.MArray newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
18:14:33 <lambdabot> Data.Array.MArray newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
18:14:45 <SamB_XP> yes, the idea, but the way it's type interacts with the types of the things around it ?
18:15:12 <ddarius> SamB_XP: You mean the stuff that comes from the lack of impredicativity?  E.g. the $ thing?
18:15:23 <loadquo> Actually I only pass it two and it needs three.
18:15:46 <SamB_XP> also the thing where I can't really use runSTUArray without picking a specific element type, unless they fixed that ...
18:16:01 <loadquo> Or I was being silly and confused.
18:16:06 <Gracenotes> ah, them. Always fixing things, as they do.
18:16:17 <ddarius> SamB_XP: I don't recall having any problem like that.
18:16:52 <SamB_XP> it only applied to the STUArray, not STArray
18:18:16 <ddarius> Oh, STUArray is something else, it doesn't have anything to do with the s parameter of ST or how ST works.
18:18:27 <ddarius> The "problem" there is the U part.
18:18:32 <SamB_XP> no, no.
18:18:36 <SamB_XP> it interacts with the s.
18:19:47 <Gracenotes> runSTUArray $ do f <- M.thaw (listArray (0,5) [' '..]); f // [(0,'b')]; (return f)
18:19:54 <Gracenotes> notdoingitright, I guess?
18:20:06 <Gracenotes> expected GHC.ST.ST s t, found Array t1 Char
18:20:11 <ddarius> I don't see why it would.  I would need to see an example of what you are talking about.  Either way, the problem should still be due to the U part not the ST part.
18:20:39 <Gracenotes> what went wrong?
18:20:52 <ddarius> :t (//)
18:20:53 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
18:21:17 <ddarius> You are trying to use a pure function as an impure ST action on an impure array.
18:21:21 <SamB_XP> Gracenotes: use the MArray interface for your mutations
18:21:35 <SamB_XP> IArray is for immutable arrays
18:21:38 <Gracenotes> well, I still have readArray and writeArray. There goes mah elegant syntax :/
18:22:10 <SamB_XP> Gracenotes: unless you wanted to do something imperative, why are you even bothering ?
18:22:38 <Gracenotes> okay, that works. And.. trying whaht?
18:22:40 <Gracenotes> *what
18:22:59 <SamB_XP> hmm ?
18:23:00 <Gracenotes> bothering with what, rather? *sorry, a bit tired*
18:23:11 <SamB_XP> with imperative arrays!
18:23:37 <Gracenotes> because, I'm making a series of minor changes to a huge array, and I'd like to do so without copying copying copying an immutable one.
18:23:55 <Gracenotes> so, put it in the ST monad, make the changes, get out
18:24:05 <SamB_XP> and you can't just squeze it into one // ?
18:24:17 <Gracenotes> no. The changes are sequential, and depend on each other
18:24:29 <SamB_XP> ah. so you DO want to do something imperative!
18:24:35 <Gracenotes> that is, future ones depend on past ones
18:24:49 <Gracenotes> not the other way around... I don't think even imperative models can handle that easily
18:24:54 <Gracenotes> unfortunately, all of the changes in the ST monad will *also* take place in a State monad
18:25:11 <Gracenotes> I sense I may need monad transformers, but am not terribly familiar with them
18:25:14 <Saizan_> i think the biggest gotcha is that type variables are not "scoped" by default, so when you want to give a type signature to your STUArray you get wierd errors
18:25:28 <SamB_XP> really only Array can handle values depending on other values in the same version of the array ;-)
18:25:49 <rwbarton> Array is pretty awesome that way
18:25:58 <Gracenotes> or throw in the towel and just use IOArray. I can do so without screwing up my program design, but still, it is introducing IO.
18:26:34 <Gracenotes> the whole thing won't become IO, but the sinister IO umbrella shall expand ever so steadily..
18:26:53 <Gracenotes> it if can be said that umbrellas slowly expanded, which hasn't been my experience. anyway.
18:27:16 <SamB_XP> veil ?
18:27:23 <SamB_XP> (of DARKNESS!)
18:28:24 <Twey> Hahaha
18:29:04 <Gracenotes> hm. So I'll fork my project and refactor, see if anything comes of it, otherwise wait until the first performance bottleneck...
18:30:51 <Gracenotes> what, by chance, is the type of a StateT where the other monad is an ST?
18:31:21 <Gracenotes> or does it have the s-which-shall-not-be-named in it?
18:31:33 <SamB_XP> StateT st (ST s)
18:31:38 <SamB_XP> and sorry, it has to be named
18:31:50 <SamB_XP> oh, and you'll need an "a" at some point ;-P
18:32:41 <Gracenotes> actually, I might want the ST to go in the State. Would that be STT?
18:33:34 <pumpkin> STTT
18:34:21 <Gracenotes> stat!
18:37:21 <Axman6> ?users
18:37:21 <lambdabot> Maximum users seen in #haskell: 658, currently: 605 (91.9%), active: 9 (1.5%)
18:37:31 <Gracenotes> really, though... :/
18:38:57 <Gracenotes> I'm so fond of delineating the types of functions. Using ST would certainly not help in that respect.
18:40:00 <pumpkin> why not?
18:40:33 <pumpkin> make sure you runST before you return and you get pretty types
18:40:34 <pumpkin> :P
18:40:58 <Gracenotes> so put everything in one monolithic function, without composition, and runST the whole thing, then :)
18:41:20 <Saizan> you just need to be polymorèhic in "s"
18:41:25 <hackage> Uploaded to hackage: Control-Engine 0.0.2
18:41:55 <Gracenotes> how is this polymorphism notated in a function type signature? /me is missing something
18:42:11 <Saizan> forall s. ...
18:42:45 <Saizan> and it can be omitted
18:43:14 <Saizan> there are some case where you need it though
18:43:41 <Gracenotes> eh. DiffArray probably isn't so bad.
18:43:48 <Saizan> essentially in wrappers around runST
18:44:04 <Gracenotes> (not to say ST is either, but it might be more than I need..)
18:46:34 <Saizan> the problem with DiffArrays is that they are rarely more efficient than IArrays
18:46:55 <Gracenotes> okay.. IOArray, then? :)
18:47:29 <Saizan> if you don't mind IO :)
18:48:04 <Saizan> ST is not that hard to use, really, once you understand higher-rank polymorphism
18:48:14 <tibbetts> I'm trying to understand the definition of MonadError. In ``class (Monad m) => MonadError e m | m -> e where'', what is the m -> e after the vertical bar called? I'm having a hard time finding examples of it anywhere, and I don't know what to google.
18:48:47 <Gracenotes> it's not so much understanding the polymorphism as having it be an 'element in the room' of sorts.
18:48:53 <Saizan> tibbetts: functional dependency
18:48:54 <Gracenotes> *elephant, even
18:49:09 <Gracenotes> my fingers are not doing what my brain says :/
18:49:24 <Saizan> tibbetts: it means that 'm' uniquely determines 'e'
18:49:52 <tibbetts> Ah, thanks, that got me to the right place to learn more (http://en.wikibooks.org/wiki/Haskell/Advanced_type_classes)
18:50:26 <Gracenotes> it's like explicitly passing around data, in this case the s, when it seems a more implicit solution would do (in the analogy, a State monad)
18:50:29 <Saizan> eh, yeah, the 's' parameter is a bit viral, if you store arrays/vars in some structure you've to parametrize it over 's'
18:52:20 <Gracenotes> do I need -XTypeOperators, then?
18:52:27 <Saizan> a State monad is a quite different beast
18:52:29 <gio123> is here somebody whose mother language is english
18:52:30 <gio123> ?
18:53:05 <ddarius> Saizan: You should be able to universally quantify it if you really don't want it showing up in (some) types.
18:53:08 <Axman6> gio123: me
18:53:22 <Saizan> no TypeOperators is a syntactical extension to allow type variables like (~>), iirc
18:53:27 <ddarius> Except for Axman6, we're all from India.
18:53:43 <Axman6> the spawn of haskell curry!
18:54:07 <Axman6> hmm, he was indian wasn't he?
18:54:32 <ddarius> If by "Indian" you mean "American" then Yes!
18:54:32 <pumpkin> Born	September 12, 1900
18:54:32 <pumpkin> Millis, Massachusetts
18:54:34 <SamB_XP> Axman6: you're getting confused with the food, I think
18:54:41 <pumpkin> oh you mean american indian?
18:54:51 <pumpkin>  / native american
18:55:05 <Gracenotes> Illegal operator `.' in type `forall s . (String -> ST s String)' (Use -XTypeOperators to allow operators in types)
18:55:09 <Axman6> heh, ok then. i just got the idea that haskell was an indian name
18:55:10 <gwern> 'Handtalk has been one of the strongest Go programs in recent years and is written by Zhixing Chen, a Chinese professor from the University of Guangzhou. Although Handtalk becomes stronger each year and was awarded a 4 kyu diploma by the Nihon Kiin in 1996, Prof. Chen does not believe that Go programs will reach shodan by 2000 if shodan is taken at its international level (2 - 3 dan Japanese). '
18:55:16 <gwern> 'Handtalk is written completely in IBM-PC assembly language and is very small (around 250k) and very fast. Only a very small number (around 4) candidate moves are evaluated using a static evaluation function which seems to be accurate and stable. Handtalk also uses an influence function whose influence decreases as 1/2^distance. '
18:55:24 <Saizan> Gracenotes: RankNTypes
18:55:27 <SamB_XP> Gracenotes: wrong error message
18:55:37 <gwern> oh, they were crazy back in the '80s and '90s! (quoted from http://www.itee.uq.edu.au/~janetw/Computer Go/CS-TR-339.html )
18:55:41 <pumpkin> Axman6: maybe this influenced your impression http://en.wikipedia.org/wiki/Haskell_Indian_Nations_University
18:55:42 <SamB_XP> there OUGHT to be a warning for using forall as a type variable name
18:55:50 <Gracenotes> hm... if it involves a GHC extension... :\
18:55:50 <Saizan> ?hoogle newSTRef
18:55:50 <lambdabot> Data.STRef newSTRef :: a -> ST s (STRef s a)
18:55:50 <lambdabot> Data.STRef.Lazy newSTRef :: a -> ST s (STRef s a)
18:56:50 <Gracenotes> ah, you don't need the forall. forgot about implicit polymorphism of things-ghc-doesn't-recognize
18:56:52 <ddarius> Gracenotes: You don't need to write the forall in that type as Saizan said earlier.
18:57:12 <ddarius> runST, though does need extensions.
18:57:28 <Saizan> ddarius: newSTRef connects the type of the Ref with the type of the monad, so i don't think i can contruct e.g. trees which are polymorphic in 's' if they contain STRefs
18:57:30 <SamB_XP> Gracenotes: what version of GHC is it ?
18:57:40 <Gracenotes> even runSTUArray?
18:57:59 <Saizan> yeah, the forall is implicit by default
18:58:24 <Gracenotes> SamB_XP: 6.8.2. Latest one uploaded to the Debian packaging system.
18:58:47 <Gracenotes> (however many centuries ago it was uploaded)
18:58:58 <SamB_XP> Gracenotes: apparantly they fixed THAT one
18:59:20 <SamB_XP> http://hackage.haskell.org/trac/ghc/ticket/2588 shows such a suggestion as what happens now
18:59:22 <ddarius> Saizan: Well if the -tree- is mutable, then no, you can't but you wouldn't "want" to.  If the tree is just holding references, you could have Tree (forall s. STRef s Int) or some such and it should work, more or less.
18:59:44 <Rudel> Enter text here...hello all
18:59:56 <Gracenotes> hello back
19:00:03 <SamB_XP> ddarius: no way would that work
19:00:09 <SamB_XP> when you got them out, you couldn't use them
19:00:16 <SamB_XP> because they would have the wrong s
19:00:28 <Gracenotes> Rudel: hi :)
19:00:49 <Rudel> Hey Gracenotes! newbe here...oh nooo!
19:01:08 <Gracenotes> where :O
19:01:11 <Gracenotes> >_>
19:01:13 <Gracenotes> <_<
19:01:18 <Rudel> lol
19:01:26 <Gracenotes> there's no newbie in sight. You're safe!
19:01:26 <Rudel> <
19:01:30 <ddarius> SamB_XP: It's a universal, not an existential.
19:01:46 <Rudel> no im a newb,e your not safe!
19:01:51 <SamB_XP> ddarius: eh ?
19:01:59 <SamB_XP> oh, right
19:02:09 <SamB_XP> in that case, how would you put anything into it ?
19:02:13 <Gracenotes> Rudel: attaboy... don't bite...
19:02:21 <Rudel> Grrrr
19:02:30 <Saizan> the problem is that i don't see a way to usefully construct a (forall s. STRef s A)
19:02:35 <Rudel> not hard
19:02:52 <Gracenotes> Rudel: anyway, greetings
19:03:13 <Rudel> Thanks, is this a place to ask a really stupid newbe question or not really?
19:03:17 <ddarius> That's true, you'd have to run newSTRef in a computation.  Originally, I was thinking of ST computations in general, not STRefs.
19:03:31 <ddarius> forall s. ST s A would be fine.
19:03:39 <Gracenotes> Rudel: sure, what is it?
19:03:42 * Saizan nods
19:03:52 <Axman6> @quote everettz
19:03:52 <lambdabot> everettz says: APOLOGIZE FOR THE CAPS, I'M HAVING A KEYBOARD PROBLEM.
19:03:55 <glguy> What is this Tree datatype based question?
19:04:26 <glguy> or rather what constraint are we discussing?
19:04:44 <Axman6> Rudel: ask whatever you want, this is a friendly channel
19:05:02 <chessguy_work> Rudel, this channel is one of the best features of haskell :)
19:05:10 <BMeph> I can has question, plz? ;)
19:05:13 <SamB_XP> Rudel: just TRY to ask a stupid question
19:05:28 <glguy> maybe that *was* his question
19:05:33 <SamB_XP> hahaha
19:05:53 <Axman6> heh
19:06:05 <Rudel> I am trying to ban all trafic to my site from a particular site that is linked to me. I need a basic code to put in ht access and where!
19:06:08 <Gracenotes> the typical IRC bait-and-switch trick. "May I ask a question?" "Yes, and you just used up your one question! Next!"
19:06:23 <Rudel> I am really computer dumb!
19:06:34 <glguy> Rudel, this channel is for questions about the Haskell programming language
19:06:45 <Rudel> ooooooooo
19:06:51 <Rudel> sorry everyone!
19:06:51 <SamB_XP> Rudel: I don't know that you can do that
19:07:04 <Axman6> Rudel: which server?
19:07:13 <Rudel> on mine
19:07:13 <SamB_XP> have you been slashdotted ?
19:07:27 <Axman6> -_-
19:07:38 <Rudel> No, just a jackass has a link to my site, and I dont want his people there
19:07:42 <Gracenotes> Rudel: I, for one, don't send Referer headers. So you wouldn't be able to ban me, and many sites can also use Referer-get-around-sites
19:07:43 <Axman6> Rudel: apache? IIS? lighttpd? AOL-server?
19:07:52 <Olathe> Rudel: http://www.javascriptkit.com/howto/htaccess14.shtml
19:07:58 <Gracenotes> however, I suspect most be do use Referers, anyway
19:08:03 <Gracenotes> *most people do use
19:08:20 <SamB_XP> Gracenotes: well, even for those of us with them turned on, we could always copy/paste the URL
19:08:35 <Rudel> I thought there would be a way, as I have read snippits on, how to block all traffic from a given site to yours.
19:08:55 <Gracenotes> Rudel: however, freenode does have many channels related to various servers. #apache is a very popular channel about Apache, for instance...
19:09:22 <Rudel> ok thanks! sorry for the unrelated question!
19:09:32 <Gracenotes> but also see Olathe's link... seems it has the answer
19:09:33 <Axman6> Rudel: you'd need to block based on the referrer
19:10:22 <Axman6> yeah that link has the answer
19:10:35 <Axman6> won't stop al traffic from there, but it'll stop a bit
19:11:07 <Rudel> <stumbles back out, embarrassed and appreciative!
19:11:13 <ddarius> This channel really is too helpful
19:11:18 <SamB_XP> we told you it was a friendly channel ...
19:11:23 <SamB_XP> ddarius: yes, a bit
19:11:32 <SamB_XP> but better that than the OTHER way
19:12:00 <ddarius> I'd have to agree.  c.l.l annoyed me far more often the here ever has.
19:14:30 <Gracenotes> hm. It doesn't seem Haskell likes data STRoom = STRoom ((STArray s) Square (ST s Square)) [Actor] Actor
19:15:03 <Gracenotes> I know I'm doing something wrong, of course, but fixing it doesn't seem so obvious
19:15:13 <ddarius> Assuming that's kind correct, which I don't think it is, that type seems insane.
19:15:20 <ddarius> :k STArray
19:15:21 <lambdabot>     Not in scope: type constructor or class `STArray'
19:15:26 <ddarius> @hoogle STArra
19:15:27 <lambdabot> Data.Array.Base listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
19:15:27 <lambdabot> Data.Array.IArray listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
19:15:27 <lambdabot> Data.Array.Base listArrayST :: Ix i => (i, i) -> [e] -> ST s (STArray s i e)
19:16:01 <ddarius> I guess it is kind correct.
19:16:24 <ddarius> Gracenotes: You need to have the s as a parameter to STRoom.
19:16:35 <ddarius> You are probably getting a error like "type variable 's' not in scope"
19:17:42 <Gracenotes> eek... another type bites the s, to paraphrase the Queen song...
19:17:48 <Axman6> Gracenotes: maybe you want STArray Square (ST s Square)?
19:18:01 <Axman6> hmm, maybe not
19:18:22 <ddarius> Gracenotes: Nothing special is happening here.  If you wrote data Pair = Pair a b you'd get the same error.  What are 'a' and 'b'?
19:18:23 <Gracenotes> I'm using.. STArray s Square (ST s Square)
19:18:33 <Gracenotes> STArray :: * -> * -> * -> *
19:18:37 <ddarius> Gracenotes: That's correct if unusual.
19:19:35 <Gracenotes> is this phantom polymorphic type the only mechanism of not confusing STRef instances?
19:19:38 <ztirF> has anyone successfully compiled the fitsio package?  It's complaining to me about not finding the C2HS module
19:20:01 <ddarius> Gracenotes: It's how STRef works.
19:20:24 <Gracenotes> quite so. Is it the only way it could possibly work?
19:20:24 <Axman6> do you have c2hs installed ztirF?
19:20:27 <ddarius> There are probably other ways of doing it, but they'd require more type machinery.
19:20:32 <Gracenotes> ah.
19:20:39 <ztirF> Axman6: I do, and cabal finds it
19:20:45 <Axman6> :\
19:20:58 <ztirF> Using c2hs version 0.15.1 found on system at: /Users/fritz/.cabal/bin/c2hs
19:21:03 <ddarius> Certainly, one way or another, to get the guarantees ST provides while using the type system you are going to have to decorate the types in some way.
19:21:53 <Gracenotes> if I only used one STRef in an ST block, would the phantom type be necessary?
19:22:16 <Gracenotes> (I don't think there's any way to guarantee only using one, but hypothetically)
19:22:17 <ddarius> ST needs the "phantom" type
19:22:29 <Axman6> i',m not sure what your problem is, STRefs are pretty easy to use :\
19:22:31 <ddarius> The problem isn't confusing STRefs amongst themselves.
19:22:41 <Gracenotes> hm.. go on
19:23:02 <SamB_XP> it's allowing them to escape runST
19:23:14 <SamB_XP> or runSTArray, or runSTUArray ...
19:23:21 <Gracenotes> what would happen then?
19:23:27 <ddarius> :t runST
19:23:28 <lambdabot> forall a. (forall s. ST s a) -> a
19:23:35 <SamB_XP> ddarius: not type-wise
19:23:49 <SamB_XP> why would it be bad to allow, he means
19:23:52 <ddarius> SamB_XP: I know what you meant.
19:23:55 <ddarius> and what he meant.
19:23:59 <SamB_XP> oh, okay
19:24:02 <SamB_XP> then why the :t ?
19:24:27 <ddarius> Because it can be useful to explain what goes wrong, the point being that the 'a' on the RHS is a pure value.
19:24:42 <SamB_XP> hmm, point
19:27:09 <ddarius> But basically, inc stref = \() -> runST (modifySTRef stref (1+) >> readSTRef stref);  inc :: STRef Int -> () -> Int
19:28:08 * Axman6 needs to make his ST code faster
19:28:14 <ddarius> main = let incrementer = runST (newSTRef 0) in print (inc () + int () + inc ())
19:28:18 <ddarius> s/int/inc
19:28:24 <ddarius> s/inc/incrementer
19:30:15 * BMeph enjoys the inside joke of 'f()'
19:30:38 <ddarius> BMeph is easily amused.
19:30:59 <SamB_XP> that's an inside joke ?
19:31:00 <BMeph> ddarius: ...what's your point? :)
19:31:12 <ddarius> BMeph: None really.  It's better than the alternative.
19:31:47 <BMeph> SamB_XP: A C/C++/Java person will think they know exactly what's going on...
19:32:50 * Axman6 doesn't get it and feels left out. which hurts in such a friendly chan. :(
19:32:55 <SamB_XP> > let inc = runST (newSTRef 0) in inc () + inc () + inc ()
19:32:56 <lambdabot>       Inferred type is less polymorphic than expected
19:32:56 <lambdabot>        Quantified type ...
19:33:39 <ddarius> s/incrementer =/incrementer = inc $/
19:34:11 <ddarius> This is why I used a statically typed language.
19:34:11 <SamB_XP> ddarius: you >
19:34:16 <Axman6> that won't work, you need a readSTRef no?
19:34:28 <Axman6> :t runST (newSTRef 0)
19:34:29 <lambdabot>     Inferred type is less polymorphic than expected
19:34:29 <lambdabot>       Quantified type variable `s' escapes
19:34:29 <lambdabot>     In the first argument of `runST', namely `(newSTRef 0)'
19:34:41 <Axman6> :t runST (newSTRef (0:: Int))
19:34:42 <lambdabot>     Inferred type is less polymorphic than expected
19:34:42 <lambdabot>       Quantified type variable `s' escapes
19:34:42 <lambdabot>     In the first argument of `runST', namely `(newSTRef (0 :: Int))'
19:34:45 <Axman6> bah
19:34:47 <lunabot>  luna: lexical error in string/character literal at end of input
19:35:00 <SamB_XP> what ?
19:35:00 <pumpkin> failuna
19:35:01 <roconnor> Gracenotes: What are you going to do when more than one piece is at the same location in your array?
19:35:02 <Axman6> o.O
19:35:11 <ddarius> Axman6: The fact that it won't work is the point and why I gave inc the type STRef Int not the actual STRef s Int.
19:35:14 <SamB_XP> what did luna try to run ?
19:35:54 <Axman6> attention
19:39:50 <Gracenotes> roconnor: that won't happen in my game. However, in the game it's based on, that does happen. Lemme dig through the source code and see how that program deals with it
19:40:12 <roconnor> oh ok
19:40:46 * BMeph is pretty sure what Raqynes' solution would be...
19:41:07 * BMeph meant *Raynes'
19:41:24 <ray> as long as you didn't mean ray
19:41:32 <Raynes> Buttsecks?
19:41:59 * BMeph sighs and nods
19:45:57 <Gracenotes> C++ is such fun to drudge through
19:46:39 <roconnor> if I only had one piece per location, I'd be inclined to identify pieces by location.
19:46:50 <roconnor> unfortunately that is not the case.
19:47:14 <Gracenotes> for one, each CMonster has a list of CMonsterPieces
19:47:20 <Gracenotes> although it's empty for most of them
19:47:26 <gwern> Gracenotes: I was thinking of a CS minor, but I wasn't sure I could bear so much Java/C/C++, and I don't think the professors would accept homework in haskell...
19:48:05 <roconnor> Gracenotes: would you identifiy a monster by position in the list?
19:48:11 <roconnor> that seems lame :)
19:48:12 <ddarius> gwern: Write Haskell that generates Java or whatever.
19:48:32 <gwern> ddarius: man, you're crazy. that'd be enough work for a master's, much less a minor
19:48:41 <pumpkin> ugh, I wouldn't have majored in CS had it required much java
19:48:52 <Gracenotes> thankfully, I just have two courses
19:49:00 <gwern> (also, if I used lhc to generate C, I'd lose major points for style :)
19:49:14 <hsnoob> is HDBC 2.0.0 broken for anyone else ?
19:49:19 <Spark> good programmers should be able to program in any language
19:49:25 <SamB_XP> gwern: lets not forget the time wasted debugging the compiler!
19:49:27 <pumpkin> Spark: malbolge
19:49:53 <pumpkin> Spark: good programmers should be able to program in any mainstream language, but they don't have to like it
19:50:06 <Gracenotes> Spark: if a programmer didn't have a language he/she didn't like, whatever said language is, I'd doubt the "good" tag :)
19:50:12 <Spark> if you pay me enough i'll write as much malbolge as you like :)
19:50:39 <SamB_XP> Spark: how about intercal?
19:51:01 <pumpkin> Spark: I highly doubt it :) you might try, though
19:51:13 <Spark> it would just be a bad use of your money
19:51:22 <Gracenotes> now, I would be very fun to program in Befunge
19:51:22 <Spark> as you would have to spend a lot of money to get very little code
19:51:29 <Gracenotes> *it
19:51:42 <Gracenotes> it's like Brainfuck, but stack-based and 2D
19:52:05 <gwern> Spark: I'm sure after a few jobs the programmer would have used the ai search routines to come up with enough primitives to compile to
19:52:25 <Spark> gwern: heh well this is kinda what programmers do in all languages
19:52:39 <Spark> as you get more experienced you build up a set of tools / hacks / scripts whatever that make life easier
19:52:47 <Gracenotes> but, really. I like Java enough to use it if I need to. Programming in it has its own rules, and although said rules are more-or-less completely dry of language theory, it doesn't make the programming-to-make-computer-do-X aspect less fun.
19:53:24 <gwern> indeed. although I suppose most of the time you don't need to spend a few cpu weeks searching all possible programs for the particular item you need
19:53:28 <Spark> i find programming in java to be pretty pain-free, as long as i don't get RSI typing out all that shit
19:53:35 <Spark> it's not very interesting though
19:53:52 <ksf> Good programmers also expect to be able to code Haskell, untill they discover the opposite is true.
19:54:08 <Spark> the opposite of what?
19:54:12 <Gracenotes> well, maybe not /fun/. But point is that it's a computer, and it does stuff. and that's why many people become interested in CS in the first place. Bad idea to stop there, though.
19:54:20 <gwern> ksf: opposite? that... that haskell codes good programmers?
19:54:22 <ksf> ...being able to code Haskell
19:54:37 <Spark> Gracenotes: yeah i think there is something fun about the activity of programming that transcends all the languages
19:54:47 <Spark> imaginining something and then seeing it take form in front of oyu
19:54:49 <Spark> *you
19:54:52 <ksf> ...and that, too, gwern.
19:54:58 <pumpkin> in soviet russia, haskell codes you!
19:55:06 <gwern> in America, good programmers code Haskell. in Soviet Curry, haskell codes you!
19:55:16 <SamB_XP> hmm. that works better if the language is such that it actually takes shape.
19:55:50 <Spark> i mean the program takes shape
19:55:53 <Spark> in terms of functionality
19:55:55 <Spark> not the code
19:55:57 <gwern> SamB_XP: oh, so something like this?
19:55:58 <gwern> in America, geneticists synthesize genes. in Soviet Russia, genes synthesize geneticists!
19:56:11 <SamB_XP> hehehe
19:56:42 <ddarius> Soviet Russia is such a crazy place.
19:56:46 <Gracenotes> In America, you use a phantom type to keep track of STRef. In Soviet Russia, STRef uses phantom type to keep track of you!
19:57:00 <pumpkin> is it normal for my ghc-compiled apps to be 6 megabytes?
19:57:10 <SamB_XP> pumpkin: that small ?
19:57:18 <ksf> strip?
19:57:18 <gwern> pumpkin: not really, unless you're linking in a ton of libs
19:57:29 <gwern> for example, gitit is 13m
19:57:47 <gwern> if your ghc compiled app isn't linking in at least 20 libraries or so, 6megs i too large
19:57:50 <pumpkin> wow, 3 megabytes of symbols?
19:57:57 <gwern> (and if it's using ghc api, too small :)
19:57:57 <pumpkin> I just stripped it and it halved the size
19:58:08 <gwern> ah. cabal strips by default iirc
20:08:43 <Gracenotes> roconnor: still looking...
20:09:42 <ksf> @seen conal
20:09:42 <lambdabot> conal is in #ghc and #haskell. I last heard conal speak 5h 12m 26s ago.
20:09:51 <ksf> @nag conal about merge
20:09:51 <lambdabot> Maybe you meant: bug faq map msg
20:10:01 <Ikkebr> @seen ikkebr
20:10:01 <lambdabot> You are in #haskell. I last heard you speak just now.
20:10:05 <Ikkebr> damn :|
20:10:14 <Gracenotes> @seen Gracenotes_
20:10:15 <lambdabot> Gracenotes_ has changed nick to gracenotes.
20:10:15 <lambdabot> You are in #concatenative and #haskell. I last heard you speak just now.
20:10:22 <Gracenotes> discovered!
20:10:35 <Ikkebr> @seen dons
20:10:35 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 2h 20m 42s ago.
20:10:40 <|jedai|> @seen osfameron
20:10:40 <lambdabot> osfameron is in #haskell. I don't know when osfameron last spoke.
20:10:52 <Ikkebr> osfameron is mute
20:10:52 <Gracenotes> while we're at it
20:10:55 <Gracenotes> @seen chanserv
20:10:56 <lambdabot> chanserv is in #macosxdev, #jtiger, #haskell.fi, #haskell.cz, #haskell-books, #macosx, #gentoo-uy, #gentoo-haskell, #friendly-coders, ##logic and #haskell. I don't know when chanserv last spoke.
20:11:09 <Ikkebr> @seen bill gates
20:11:10 <lambdabot> I haven't seen bill.
20:11:52 <|jedai|> How do you post code in your comments on Wordpress ? I have been trying miscellaneous combination but have yet to find the magic words...
20:12:29 <Ikkebr> <code>here goes code</code> ?
20:13:30 <|jedai|> Ikkebr: Nope, it put the code in monospace but the formatting is lost
20:13:52 <BMeph> @seen an_honest_politician
20:13:52 <lambdabot> I haven't seen an_honest_politician.
20:14:06 <BMeph> You said it, l-bot. ;)
20:14:10 <|jedai|> I tried adding <pre> </pre> but it doesn't seem to allow it
20:16:00 <Gracenotes> roconnor: you there? It seems that there's one monster per space in the grid, but when a monster can climb on top of another monster's piece, it's because the piece isn't *in* the grid
20:16:34 <Gracenotes> it's just attached to the monster-with-a-piece's piece list
20:16:59 <Gracenotes> and.. it's always rendered beneath the other monster
20:18:18 <tromp> > ()
20:18:19 <lambdabot>   ()
20:21:50 <Gracenotes> hm. This type signature makes sense, right? stprocessEvents :: STRoom s -> Char -> StateT Queue (ST s) (STRoom s)
20:22:06 <Gracenotes> it compiles, at least
20:23:53 <ksf> does conal have a public repository?
20:24:10 <ksf> besides the one at darcs.haskell.org, that is, that one's quite old.
20:26:04 <ddarius> The current source of conal is a highly guarded secret.
20:27:22 <Olathe> How can you make the accumulator strict with foldr ?
20:27:38 <roconnor> Gracenotes: ok
20:27:44 <Olathe> @src foldr
20:27:45 <lambdabot> foldr f z []     = z
20:27:45 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:27:57 * roconnor wonders if sortBy is guarenteed to be stable.
20:28:11 <Olathe> > sortBy abs [-10..10]
20:28:12 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> Ordering
20:28:12 <lambdabot>    ...
20:28:21 <Olathe> > sortBy (comparing abs) [-10..10]
20:28:23 <lambdabot>   [0,-1,1,-2,2,-3,3,-4,4,-5,5,-6,6,-7,7,-8,8,-9,9,-10,10]
20:29:33 <ksf> what use is a public repo if it only contains releases?
20:29:40 <Olathe> > sortBy (comparing abs) [-6, 4, -10, 3, 5, -7, -1, -8, 9, 8, 0, 6, -9, 10, 1, 2, -3, 7, -5, -4, -2]
20:29:41 <lambdabot>   [0,-1,1,2,-2,3,-3,4,-4,5,-5,-6,6,-7,7,-8,8,9,-9,-10,10]
20:30:14 <Olathe> Looks stable.
20:31:26 <roconnor> , sortBy (comparing abs) [-6, 4, -10, 3, 5, -7, -1, -8, 9, 8, 0, 6, -9, 10, 1, 2, -3, 7, -5, -4, -2]
20:31:27 <lunabot>  luna: Not in scope: `comparing'
20:32:03 <Olathe> , sortBy (\a b -> compare (abs a) (abs b)) [-6, 4, -10, 3, 5, -7, -1, -8, 9, 8, 0, 6, -9, 10, 1, 2, -3, 7, -5, -4, -2]
20:32:04 <lunabot>  luna: Couldn't match expected type `Data.Array.Vector.UArr.MUArr e s'
20:32:10 <Olathe> O..K
20:33:03 <Axman6> o.O
20:33:53 <Olathe> @src foldr1
20:33:53 <lambdabot> foldr1 _ [x]    = x
20:33:53 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
20:33:53 <lambdabot> foldr1 _ []     = undefined
20:34:36 <Olathe> > foldr1 undefined []
20:34:37 <lambdabot>   * Exception: Prelude.foldr1: empty list
20:34:49 * ksf renames every occurence of "merge" in his copy of reactive's source to "delay", to calm him down.
20:41:25 <hackage> Uploaded to hackage: mathlink 1.1.0.1
20:41:25 <hackage> Uploaded to hackage: mathlink 1.1.0.0
20:41:25 <hackage> Uploaded to hackage: fez-conf 1.0.0
20:41:54 <Gracenotes> okay, I'm encountering this very weird error with ST. Could anyone locate the problem? http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1071
20:42:03 <Axman6> mathlink... wonder if that's the mathematica thing
20:42:03 <ozy`> instance forall a. Num [a] where (+) = (++) -- I fully expect the Ministry of Safety and Happiness to break down my door
20:42:10 <redditbot> A parallel producer/consumer engine (thread pool) for Haskell
20:43:28 <Gracenotes> the problem is entirely in stroom -- removing it makes it compile just fine
20:45:18 <Axman6> ozy`: i think a polynomial instance would be more useful in many cases
20:45:40 <ozy`> Axman6: yeah it's better to have (+) and (++) do different things
20:46:10 * ksf quickly renames every "delay" back to "merge" and looks innocent and sweet
20:46:17 <Axman6> like instance Num a => Num [a] = zipWith (+)
20:46:25 <ozy`> (+) = zipWith (+) -- you beat me to it :p
20:46:28 <Axman6> like instance Num a => Num [a] (+) = zipWith (+) even
20:46:51 <Axman6> saw an article about it the other day.
20:46:56 <Axman6> oh it was on the haskell wiki, sec
20:47:26 <Axman6> http://haskell.org/haskellwiki/Blow_your_mind#Polynomials
20:51:04 <Gracenotes> >_<
20:51:57 <Gracenotes> is there a transformer monad for ST that can be used with STUArray?
20:52:00 <Axman6> ozy`: ah, that instance wouldn't wuite work for polynomials though
20:52:35 <ozy`> Axman6: yeah, the end-of-list behavior is different
20:52:40 <Axman6> yeah
20:52:49 <Gracenotes> hm, wait... :/
20:53:51 <Gracenotes> Is ST an abbreviation of straitjacket, by any chance?
20:55:49 <Axman6> State Transformer, and it's very flexible, so i'm not sure what you're on about :\
20:57:19 <Gracenotes> the error in http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1071 isn't that clear -- and I'm not sure how I'd even use stprocessEvents to make a function Room -> Char -> (Room, Queue)
20:57:50 <Gracenotes> the normal processEvents makes this very easy, since it's of type Room -> Char -> State Queue Room
20:57:58 <Gracenotes> then one just has to do a runState on the results
21:00:32 <Gracenotes> Based on the docs, it doesn't seem fixing this is possible.
21:03:50 * Gracenotes isn't overreacting. It's just not that flexible.
21:07:42 <rwbarton> :t thaw
21:07:43 <lambdabot> Not in scope: `thaw'
21:08:39 <ztirF> anyone know why it takes 25 bytes to "encode" a double precision value in Data.Binary?
21:08:41 <rwbarton> Gracenotes: "thaw" is like "newArray", it's an action in an ST s monad that makes a new array copied from an existing pure array
21:09:15 <rwbarton> Gracenotes: so stroom :: Room -> ST s (STRoom s)
21:09:25 <rwbarton> (and you need to fix the definition)
21:09:30 <rwbarton> ztirF: Sadly, yes
21:09:56 <ztirF> rwbarton: can I override that by making a custom instance of a newtype?
21:10:02 <rwbarton> ztirF: It just stores the output of decodeFloat
21:10:15 <Gracenotes> rwbarton: you have to nest ST's in that way?
21:10:58 <ztirF> I really just want to dump some doubles to disk here
21:11:15 <rwbarton> ztirF: Sure, although you might find it tricky to get a "raw" encoding of a Double... you'll need stuff from Foreign (and it won't be portable, but it sounds like you don't care)
21:11:52 <ztirF> hmmm
21:11:57 <Gracenotes> rwbarton: when I change it to stroom (Room arr ms s) = return (STRoom (thaw arr) ms s), the exact same error message shows up. I'm not sure if the monad is the problem.
21:12:15 <rwbarton> Gracenotes: it needs to be like  do arr' <- thaw arr; return $ STRoom arr' ms s
21:13:09 <rwbarton> Gracenotes: I agree it's confusing when it's unfamiliar.  Just mentally replace "ST s" everywhere by "IO", and "STRef s" everywhere by "IORef", etc, and maybe it will be clearer
21:13:57 <rwbarton> Gracenotes: also, type STGrid s = STArray s Square (ST s Square)
21:13:59 <ztirF> I guess what I want is something like XDR
21:14:13 <ztirF> are there bindings to that written already?
21:14:13 <rwbarton> Gracenotes: that's a pretty weird definition, you have an array of ST actions indexed by Squares?
21:14:53 <Gracenotes> rwbarton: I've tried substituting Coord in there, to no avail
21:16:04 <rwbarton> Gracenotes: how about just  type STGrid s = STArray s Coord Square ?
21:16:29 <rwbarton> that's the naive ST equivalent of your Grid type
21:17:30 <Gracenotes> rwbarton: okay, it compiled. That doesn't mean too much, but it's a good sign :)
21:18:19 <Gracenotes> thanks... I may need your assistance again, though. :/
21:20:42 <Gracenotes> rwbarton: actually... it kind of fails when I use STUArray instead of STArray. But I'll fix that when I come to it.
21:21:46 <rwbarton> That's probably because you can't have an unboxed array of Squares
21:22:23 <rwbarton> unboxed arrays only exist for simple fixed-size numeric types, pretty much
21:22:29 <Gracenotes> huh... I think I've confused unboxed and boxed
21:22:56 <Gracenotes> unboxed makes it seem like there is no memory size limit to each of the elements
21:23:13 <Gracenotes> boxed probably implies that there are explicit memory delimiters for each of the elements
21:23:20 <rwbarton> unboxed means the elements (say, integers) are physically sitting there in the array next to each other
21:23:23 <Gracenotes> and unboxed is just boxed with an 'un' on it, oddly
21:23:27 <Axman6> it's possible to create instances of Unboxed arrays for your own types though
21:24:06 <Axman6> though it's not fun
21:24:22 <sjanssen> Gracenotes: "boxed" means an array of pointers to elements, "unboxed" means an array of unpacked elements
21:24:30 <Gracenotes> you know, I think it might have type-checked sooner if I hadn't confused boxed and unboxed...
21:24:33 <Gracenotes> ;)
21:24:43 <Axman6> rwbarton: you could thing about boxed arrays as an array of pointers to the values stored in the 'array' right?
21:24:48 <Axman6> yes...
21:25:02 <rwbarton> yeah, I was going to say that next, but couldn't find a wording I was happy with
21:25:04 <Axman6> thanks for answering my questions before i asked it sjanssen
21:25:47 <rwbarton> In particular, note that a "pointer to an element" might be a pointer to a thunk that will evaluate to _|_
21:26:46 <rwbarton> whereas you can't put _|_ in an unboxed array
21:27:05 <Axman6> undefined = _|_?
21:27:10 <rwbarton> right
21:27:19 <Axman6> because newArray_ fills the elements with undefined
21:27:33 <Axman6> i think
21:27:40 <Axman6> hmm, something did, maybe not newArray_
21:27:50 <Gracenotes> are there any good example applications written with STArrays?
21:28:10 <Axman6> want to see my n-bodies program?
21:28:13 <Gracenotes> guessing what fits where is not an efficient way of coding.
21:28:24 <Gracenotes> Axman6: sure :)
21:29:09 <Axman6> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=1072#a1072
21:30:24 <Axman6> it'll take a while to understnad how it works, but things like advance are probably the best things to look at
21:30:49 <Gracenotes> what's its type signature?
21:31:05 <ozy`> Axman6: hey, how's that syntax file working out for you? >_>
21:31:37 <Axman6> pretty well. reckon things on the left of <- could be coloured differently?
21:31:57 <diltsman> How do you force a value to be evaluated immediately?
21:32:03 <Axman6> seq
21:32:08 <pumpkin> that's not quite immediate though
21:32:21 <lament> define immediately
21:32:23 <pumpkin> when the result of seq is evaluated, its first argument is evaluated
21:32:27 <lament> immediately when?
21:33:40 <diltsman> I have a function that parse a file (not using Parsec).  I need to force the parsing to have completed so that any errors are thrown before main continues.
21:34:10 <pumpkin> you could use rnf
21:34:12 <rwbarton> so you mean at a particular time in the IO monad
21:34:23 <rwbarton> you can use "evaluate"
21:34:28 <rwbarton> possibly in conjunction with rnf
21:34:32 <rwbarton> :t evaluate
21:34:33 <lambdabot> Not in scope: `evaluate'
21:35:00 <rwbarton> evaluate :: a -> IO a -- Forces its argument to be evaluated when the resultant IO action is executed.
21:35:44 <diltsman> What module is evaluate it?
21:35:53 <rwbarton> @hoogle evaluate
21:35:54 <lambdabot> Control.Exception evaluate :: a -> IO a
21:35:54 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
21:36:17 <rwbarton> you're looking to raise exceptions right?
21:37:14 <diltsman> Yes.
21:38:56 <diltsman> evaluate works perfectly.  Thank you.
21:39:04 <rwbarton> That will only evaluate the outermost constructor, depending on where your exceptions are, you might need to do more
21:41:25 <hackage> Uploaded to hackage: mathlink 1.1.0.2
21:58:10 <Gracenotes> Inferred type is less polymorphic than expected. Do I need to enable some extension for this...?
21:58:51 <Gracenotes> runST, that is. What was it called? Is it command line, or can you include it in the source? :)
21:59:34 <joeatwork> @source $
21:59:34 <lambdabot> $ not available
21:59:35 <lunabot>  luna: Not in scope: `available'
22:00:03 <Axman6> heh
22:00:06 <sclv> ?src ($)
22:00:06 <lambdabot> f $ x = f x
22:00:21 <sclv> oh no, a bot-quine injection vector!
22:00:30 <Gracenotes> I thought that's why bots indented :)
22:00:36 <Gracenotes> (or were suppsed to)
22:00:38 <sclv> @source ,
22:00:38 <lambdabot> , not available
22:00:39 <lunabot>  luna: Not in scope: `available'
22:01:09 <sclv> @source , print "hi"
22:01:09 <lambdabot> , print "hi" not available
22:01:10 <lunabot>  luna: Not in scope: `available'
22:01:17 <Gracenotes> @source , 2+2 --
22:01:17 <lambdabot> , 2+2 -- not available
22:01:18 <lunabot>  luna: parse error (possibly incorrect indentation)
22:01:23 <Gracenotes> aww
22:01:38 <Gracenotes> luna doesn't like comments
22:01:42 <Axman6> Gracenotes: the less polymorphic thing shouldn't need any new flags
22:02:32 <sclv> @source , let available = False in
22:02:32 <lambdabot> , let available = False in not available
22:02:35 <lunabot>  True
22:02:42 <sclv> and bingo.
22:02:43 <Gracenotes> success!
22:02:59 * BMeph air-fives sclv
22:03:03 <Axman6> i ran into it in that n-bodies thing, but can't remember how i fixed it
22:03:24 <Axman6> if you guys can get an infinite echo, i'll be very impressed
22:03:28 * sclv freeze-frames and waits for the credits to roll
22:03:47 <Gracenotes> I don't think lunabot has a similar vulnerability with first-characters
22:03:55 <Gracenotes> , src concat
22:03:58 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
22:03:58 <sm> where's dons ?
22:04:04 <Gracenotes> ah
22:04:13 <Gracenotes> , src 'notfound
22:04:17 <lunabot>  luna: Not in scope: `notfound'
22:04:19 <sm> it's too quiet.. I'm having dons withdrawal
22:04:22 <Axman6> sm: away for the week i think
22:04:29 <Axman6> it's awful :(
22:04:43 <Axman6> he needs to answer my questions!
22:04:45 <sclv> i don't think luna can do anything but eval
22:04:53 <BMeph> He's back in town...probably catching up on his email and reddit-posts. ;)
22:04:59 <Gracenotes> lunabot, you limited fool!
22:05:08 <sm> yeah, I haven't seen a haskell reddit post in *days*
22:05:30 <pumpkin> BMeph: should take him several hours just to read all the emails I sent him:P
22:06:46 <Gracenotes> so... any tips on going from ST to not-ST'd form?
22:06:48 <Gracenotes> ST s (STRoom (STArray s Coord Square) [Actor] Actor, Queue) -> (Room (Array Coord Square) [Actor] Actor, Queue)
22:07:05 <Gracenotes> STRoom is just Room with an STArray instead of an Array
22:07:20 <sclv> Gracenotes: can't you use unsafeFreeze ?
22:07:23 <sclv> ?hoogle freeze
22:07:23 <lambdabot> Data.Array.Base freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
22:07:23 <lambdabot> Data.Array.MArray freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
22:07:23 <lambdabot> Data.Array.Base freezeSTUArray :: Ix i => STUArray s i e -> ST s (UArray i e)
22:07:40 <sclv> or safe freeze for that matter, better yet.
22:07:42 <diltsman> Ok, another question.  When I run something like main = error "Message" it outputs "P2Main: Message".  Is there some way to get rid of the package name it tacks on at the beginning?
22:08:17 <Gracenotes> sclv: hm... I'll see what I can do :) The problem is that it's not STArray that has the ST, but rather the whole expression
22:08:28 <Axman6> > error "Message"
22:08:29 <lambdabot>   * Exception: Message
22:08:32 <sclv> you need to runst over the whole expression.
22:08:55 <sclv> the trick is that anything with an st-qualified existential can only exist inside the scope of a single runst.
22:09:44 <rwbarton> i.e. you need to freeze the array to an Array Coord Square, then build the rest of the Room and return it from the do block you pass to runST
22:09:50 <Axman6> Gracenotes: did you take a look at the n-bodies thing? it looks complicated, but mainly it's just the physics that bloats the code
22:10:28 <Gracenotes> Axman6: yes, I saw. It's just that monad transformers are murking up my code a bit :)
22:10:58 * Axman6 still doesn't know what monad transformers are, and doesn't care to learn, after seeing all the trouble they cause people
22:11:29 <Gracenotes> I can't even run it. I'm just compiling it to see if it typechecks, and really I hope I picked the right type.
22:11:41 <mmorrow> sclv: haha, nice
22:12:02 * sclv recommends that you don't use arrays unless you *really really* need the performance over lists. and don't use mutable arrays unless you *really really* need the performance over immutable ones.
22:12:14 <mmorrow> @source , let available = False in
22:12:14 <lambdabot> , let available = False in not available
22:12:17 <lunabot>  True
22:12:19 * Axman6 needs both
22:12:52 <sclv> mmorrow: lunabot should obviously recognize comments, if only to make more interesting bot-bot interactions possible more easily :-)
22:12:53 <Axman6> and my code is still too damn slow :(
22:13:19 <Gracenotes> sclv: I'm pretty sure I really really
22:13:38 <Gracenotes> running regular Arrays in a room with 400 monsters slowed it down excruciatingly
22:14:19 <Gracenotes> I doubt anyone but a sadist would include that many monsters to hack-and-slash though. But still, it's obvious there are scaling issues, and other monsters I plan on introducing have more complex moving algorithms than a simple beeline
22:14:54 <Gracenotes> but... we'll see if I'm dead wrong or not :)
22:15:04 <sclv> Gracenotes: what about storing things in the room with a Map (Int,Int) Thing ?
22:15:04 <mmorrow> sclv: this is why "--" comments don't work http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=808
22:15:16 <mmorrow> (it'd be easy to fix of course)
22:15:51 <mmorrow> @source @source , let available = False in
22:15:51 <lambdabot>  @source , let available = False in not available
22:16:34 <mmorrow> @source , let not = id; available = text "@src map" in
22:16:35 <lambdabot> , let not = id; available = text "@src map" in not available
22:16:37 <lunabot>  @src map
22:16:41 <mmorrow> heh
22:16:59 <Gracenotes> sclv: but I've learned so much about monad transformers and ST! :P But, really, I think I'd run into the same problem there
22:17:22 <Gracenotes> the problem isn't that each of the modifications to the Array take so long, it's that there are so many modifications
22:17:26 <sclv> regular arrays are waaaay slow, because they copy on every modification.
22:17:42 <sclv> maps are much faster
22:17:56 <sclv> since they use sharing and preserve everything possible.
22:18:02 <Gracenotes> how so?
22:18:23 <mmorrow> @source ?source , let available = False in
22:18:23 <lambdabot> ?source , let available = False in not available
22:18:25 <mmorrow> omg
22:18:31 <mmorrow> ?src
22:18:31 <lambdabot> src <id>. Display the implementation of a standard function
22:18:48 <mmorrow> @source ?src , let available = False in
22:18:49 <lambdabot> ?src , let available = False in not available
22:18:57 <mmorrow> aww
22:18:57 <sclv> a map is a balanced binary tree, right
22:19:20 <mmorrow> i believe so
22:19:33 <Gracenotes> yes. But you might frequently have an unlucky input where the copying takes quite a long time
22:19:46 <sclv> but all operations are log (n) on a map
22:19:49 <Axman6> having profiling compiled into a program doesn't carry any overhead when you don't use -p right?
22:20:06 <Gracenotes> all operations are (somewhat) O(1) on a mutable array, too :)
22:20:07 <sclv> you're not copying everything, just the changed nodes -- which are only along one path.
22:20:21 <Gracenotes> sclv: ultimately, though, every node will get changed
22:20:31 <Gracenotes> potentially. In many rooms
22:20:32 <sclv> Gracenotes: sure, eventually :-)
22:20:56 <Gracenotes> In one turn, the calculation of which shouldn't be obvious to the use via lag
22:20:58 <sclv> Data.Map is really good though.
22:21:10 <mmorrow> if there ever are two lambdabots in here, we've got a bot quine exploit just waiting
22:21:25 <Gracenotes> except, usually, when one of them is dead :/
22:21:38 <mmorrow> (someone should fix @src (or not ;))
22:22:16 <sclv> the general recommend Haskell approach is to try maps before moving on to mutable structures, since mutability so massively impacts the structure of your code
22:22:22 <sclv> and adds so many restrictions
22:22:48 <ddarius> sclv: You need to change your perspective.  Mutations sets you free.
22:23:13 <sclv> if i mutate something then i don't have what it used to be anymore! that's a restriction!
22:23:20 <Axman6> sclv: what if you're after pure speed?
22:23:31 <sclv> and i can't have lots of threads all touching it at once! that's a restriction too!
22:23:35 <Gracenotes> it's the fact that it so clearly models mutation, though
22:24:11 <Gracenotes> you start with a room. It is changed by the user moving. It is changed by processing monster 1's response. It is changed by processing monster 2's response. ... It is changed by processing monster n's response. End.
22:24:25 <warren_> I have a question about the foreign function interface in haskell
22:24:31 <sclv> but then you only can operate on the room as it stands.
22:24:39 <ddarius> sclv: Sure you can and sure you can.
22:24:54 <Gracenotes> looks a lot like mutation to me. I use a foldl in the Array version
22:25:03 <Gracenotes> (actually a foldl')
22:25:05 <warren_> I'm wondering how much optimization ghc does when peeking and poking at data structures
22:25:19 <sclv> so say that you want something that follows behind the user, e.g. a pet like in nethack. if you don't have mutation, then you can keep the "world" for the last four states to make the pet directly reactive on the user's path.
22:25:21 <Gracenotes> sclv: yes, which is fine. I think (?)
22:25:32 <warren_> i.e. does it compile down to direct memory access?
22:25:34 <sclv> if you have mutation you've decided to throw all that away for no good reason.
22:25:59 <sclv> mutation is a hack to make programs more closely resemble our limited perceptions of space-time.
22:26:00 <Gracenotes> sclv: what do you mean by 'four'?
22:26:03 <mmorrow> warren_: yes (although i wouldn't call that an optimization, just what peek/poke /are/)
22:26:12 <sclv> four was just an arbitrary number there.
22:26:22 <mmorrow> peek nullPtr
22:26:27 <mmorrow> segfault
22:26:39 <the_unmaker> does haskell have no variable assignment?
22:26:44 <sclv> segfault is a feature, not a bug!
22:26:47 <Gracenotes> sclv: that seems to describe a situation more tending towards FRP
22:26:54 <mmorrow> segfault++
22:26:56 <warren_> ok - good to know
22:26:57 <Axman6> the_unmaker: not normally
22:26:59 <cjs> Haskell binds values to names, so it has single-assignment.
22:27:25 <sclv> Gracenotes: well, a functional style gives rise to some elements of frp naturally, I think. not the whole thing, of course...
22:27:35 <warren_> I was having a discussion with someone today about the efficiency of haskell relative to C... and I guess I didn't really know what it was capable of
22:27:55 <Gracenotes> sclv: I'm pretty sure the game I'm working on is itself modeled on our limited perceptions of space-time :) It's turn-based, and has no real-time movements
22:28:09 <Axman6> huh, i hate it when i do something that i feel should make code a lot faster, and it makes it a lot slower :(
22:28:32 <Gracenotes> movements occur when and only when the user strikes a key, and all follow in order
22:28:53 <sclv> i'm being a bit bullheaded here. and working with arrays and st is well and good -- i'm just pretty sure that Data.Map will surprise you with its efficiency.
22:29:27 <Gracenotes> I might be treading a little too closely to the original C++ implementation of the game, though. It's somewhat more naturalish there.
22:30:11 <sclv> its much more interesting to reimagine things functionally than it is to translate the imperative versions of them.
22:31:38 <Gracenotes> eh. I can't help think that the game *is* imperative in its style, though.
22:32:14 <Gracenotes> and if mutation is a hack for programs, is it also a hack for something like Von Neumann architecture? :)
22:33:44 <sclv> Gracenotes: a single "interact" loop isn't that imperative though -- its just a state transition. imperative is in how you write that loop.
22:33:57 <sclv> or indeed whether you think of it as a loop or a recursion :-)
22:35:28 <sclv> i.e. do you think "i have an algorithm that first takes the keystroke and then checks positions and then etc" or do you think "I have a function go :: Keystroke -> World -> World, and I am writing it composed out of smaller functions"
22:35:44 <ddarius> neither
22:35:52 <sclv> ok, what then :-)
22:36:50 <Gracenotes> sclv: as I said, I'm using foldl with arrays, and I'll probably use a foldM with STArray if that works out (if it doesn't, I'll try the Map)
22:38:56 <ddarius> sclv: For this particular application (or what I can tell of it), I'd probably take a rather Actors-like view.  I probably wouldn't implement it that way, but I would think of it as independent concurrent entities.
22:39:05 <the_unmaker> http://en.wikipedia.org/wiki/Function-level_programming
22:40:44 <sclv> ddarius: for something continuous-time-based i'd agree actually. as far as i can tell, however, this is a nethack-style game, so i think a discrete step transition actually makes more sense.
22:45:35 <sclv> actually, if you want creatures where when you are deciding what they do, what matters is what they can see and what's in their immediate locality, something fancier and maybe better would be quadtree
22:45:52 <sclv> erm, a quadtree representation, that is.
22:45:57 <ddarius> sclv: It makes more sense implementationally, but I don't -think- of the program as a world transition function labelled by letters.
22:47:05 <ddarius> In fact, the only reason I -wouldn't- implement it in an independent concurrent entities way is because I'm an old C++ programmer and (not too relatedly) I can see how to model that more efficiently.
22:47:13 <Gracenotes> sclv: coming later is a brain that, instead of having monsters run in a beeline, calculates the shortest paths to the player including obstacles
22:47:49 <Gracenotes> I haven't yet looked at the C++ source code for the implementation. But locality is not entirely in the question
22:48:19 <sclv> Gracenotes: quadtrees are really cool. you may want to take a look, although they could be overkill for this.
22:48:32 <Gracenotes> well. So may be STArrays :)
22:48:43 <sclv> they're very functional, and only store the data that's needed.
22:48:53 <sclv> and there are sophisticated pathfinding algorithms on them.
22:49:32 * Gracenotes has not used them before
22:49:51 <Gracenotes> or know what they are, really :) Another time, though
22:50:02 <Gracenotes> heard of them, though.
22:51:04 <sclv> ok i'm gonna turn in and stop causing trouble for the night. good luck :-)
22:51:16 <Gracenotes> thanks :)
22:55:12 <thom_logn> I've downloaded and installed ghc (mac os x) but I can't find the "getting started" docs to explain how to get a shell up and running in emacs. does someone know where I should be looking?
22:57:12 <mmorrow> not sure about emacs, but you can always just run $ ghci
22:57:32 <thom_logn> ah, that would explain why ghc was complaining :P
22:57:36 <mmorrow> heh
22:58:31 <thom_logn> nice, okay, it's limping along... a emacs/slime shell would be nice but this is enough for now I guess
22:59:15 <mmorrow> i know you can get it all nice and running from emacs, but i use vim.. :)
23:02:06 <thom_logn> *gasp* Evil!
23:02:10 <thom_logn> :P
23:02:20 <mmorrow> :)
23:24:05 <the_unmaker> how does one develop programs that run nicely on 16 core machine?
23:24:47 <Axman6> depends on what you're doing
23:25:02 <Axman6> lots of forkIO or par or both
23:27:11 <NameAlreadyInUse> what does it mean when people talk about "boxed" or "unboxed" data types?
23:27:17 <NameAlreadyInUse> i have googled but can't find anything
23:29:05 <Axman6> boxed types are basically pointers to the data inside them, boxed types are just the raw values
23:29:36 <NameAlreadyInUse> ah right
23:29:50 <Axman6> if you have an array of boxed values, then it basically has an array of pointers to the values. if you have an unboxed array of say Doubles, then the Doubles are directly next to each other in memory
23:29:52 <beelsebob> I believe Axman6 meant unboxed in the latter case
23:30:04 <Axman6> uh yes
23:30:08 <NameAlreadyInUse> yeah i gathered
23:30:10 <Axman6> dinner time, brb
23:30:52 <NameAlreadyInUse> does that mean the actual data in a boxed type is on the heap?
23:32:00 <beelsebob> yes
23:39:00 <Gracenotes> hurray! The main function compiles, ST monad and StateT and all :D
23:39:23 <Gracenotes> the only problem is that I haven't actually ported the internals to use ST. But the hard part's done.
23:40:27 <mmorrow> , let transposeU us@(u:_) = runST (do mus <- replicateM (lengthU u) (newMU (length us)); foldM (\i u -> zipWithM_ (flip writeMU i) mus (fromU u) >> return (i+1)) 0 us; mapM unsafeFreezeAllMU mus); xs = fmap toU [[0..3],[4..7]] in transposeU xs
23:40:29 <lunabot>  [toU [0.0,4.0],toU [1.0,5.0],toU [2.0,6.0],toU [3.0,7.0]]
23:41:12 <mmorrow> , runST (x <- newSTRef 42; writeSTRef x 99; readSTRef x)
23:41:13 <lunabot>  luna: parse error on input `<-'
23:41:18 <mmorrow> , runST (do x <- newSTRef 42; writeSTRef x 99; readSTRef x)
23:41:19 <lunabot>  99
23:41:26 <hackage> Uploaded to hackage: bamse 0.9.3
23:41:54 <Gracenotes> the actual function has a nice type, Room -> Char -> (Room, Queue)
23:42:04 <Gracenotes> the other function doesn't :/ STRoom s -> Char -> StateT Queue (ST s) (STRoom s)
23:42:27 <mmorrow> yeah, ST is a slight pita with having to propogate the `s' everywhere
23:44:58 <Gracenotes> if by pita you mean impossible
23:45:16 <mmorrow> possible, but a pain in the ass ;)
23:45:32 <Axman6> mixing ST ad State sounds kinda silly to me
23:45:50 <Gracenotes> the ST is only used for the array
23:45:52 <mmorrow> yeah, might as well go all-out
23:46:11 <cognominal> is CGI broken in 6.10.1? I get Network/CGI/Compat.hs:104:19:
23:46:11 <cognominal>     Class `Exception' used as a type
23:46:16 <Gracenotes> the Queue is a list of events, and doesn't need to be mutable
23:46:26 <cognominal> when I try to install it using cabal
23:46:32 <Gracenotes> unless you could suggest a type signature that would work in place of the StateT
23:46:37 <mmorrow> cognominal: it's not been updated for base-4
23:46:47 <mmorrow> cognominal: are you using cabal install? or manually?
23:46:50 <cognominal> what's base-4?
23:46:54 <mmorrow> (if manually, you can make it work)
23:47:00 <mmorrow> the base package
23:47:01 <cognominal> I use cabal install
23:47:02 <Axman6> cognominal: base in 6.10
23:47:22 <cognominal> so what should I do to install it?
23:47:24 <mmorrow> cognominal: ah, i dunno then. i guess somehow force it to use base-s
23:47:30 <mmorrow> *base-3
23:47:51 <mmorrow> well, once you install one thing without cabal-install, it seems that it will never work again
23:47:58 <Gracenotes> yeah... how just would I pass around two STRefs, one of them an STArray?
23:48:00 <mmorrow> (or at least this is my experience)
23:48:25 <Gracenotes> which isn't really an STRef so much as a black box filled with STRefs
23:48:28 <cognominal> I don't really get  the stuff with base versionning
23:49:06 <mmorrow> cognominal: i'm not super familiar with using cabal-install, but someone should be
23:49:38 <cognominal> base is synonym wih prelude?
23:49:58 <mmorrow> prelude + a ton of other stuff
23:49:59 <Axman6> it's more tha the prelude
23:50:02 <Axman6> n8
23:50:03 <Axman6> **
23:50:06 <Axman6> >_<
23:50:07 <mmorrow> pretty much all basic functionality
23:50:27 <cognominal> is it tied with a haskell version?
23:50:55 <Axman6> it;s tied to the compiler version
23:51:05 <mmorrow> no. 6.10.1 is in the middle of a base version transition which makes breaking changes to Control.Exception
23:51:34 <cognominal> ok, so I guess I have more chance with an older version of haskell
23:51:45 <Axman6> ghc, not haskell
23:52:01 <cognominal> yes
23:52:18 <mmorrow> cognominal: if you want to build it manually, this is a hack i use the get cabal pkgs (w/ the exception problem) working with base-4 (run this in the top-level dir of the package):
23:52:19 <mmorrow> for i in `find . | grep -vE "_darcs" | grep -E "\.hs"`;do cat $i | sed -r 's/Control.Exception/Control.OldException/g' > a; mv -f a $i; done
23:52:39 <cognominal> I have 6.8.2 on my disk
23:52:42 <mmorrow> but that'll almost surely cause you problems in the future
23:52:58 <mmorrow> (refering to that hack, not 6.8.2)
23:53:05 <cognominal> thx
23:53:18 <mmorrow> otoh, i use it all the time :)
23:53:59 <cognominal> I am learning haskell so I don't want to mess to much with my configurations
23:54:16 <mmorrow> yeah, i would suggest not :)
23:54:40 <mmorrow> but you _should_ be able to use cabal-install to specify the base version somehow to get cgi to build on 6.10
23:54:50 <mmorrow> i just don't know off the top of my head how
23:55:08 <cognominal> ok, will check that...
23:55:17 <mmorrow> and you probably also want to try to use 6.10 over 6.8 if possible
23:55:17 <cognominal> RWH++  # btw
23:55:21 <mmorrow> :)
23:55:47 <ixdy> bob harper is an interesting person, it's true
23:55:49 <ixdy> oh wait, wrong RWH
23:56:28 <Gracenotes> hm. Maybe I need to refactor less of my code than I think...
23:56:42 <cognominal> ixdy??
23:56:46 <Axman6> @karma RWH
23:56:46 <lambdabot> RWH has a karma of 2
23:56:48 <Gracenotes> the performance-intensive ST-requiring part is the monster moves, not the player move
23:56:55 <ixdy> cognominal: http://www.cs.cmu.edu/~rwh/
23:57:24 <cognominal> I was talking of the book
23:57:32 <ixdy> I know
23:57:32 <Gracenotes> hm... :/
23:57:33 <ixdy> :)
23:58:10 <cognominal> @karma rwh
23:58:10 <lambdabot> rwh has a karma of 2
23:58:18 <cognominal> case insensitive
23:58:54 <ixdy> yeah.
23:58:56 <mmorrow> Gracenotes: it'd probably be easier in the long run to either use ST for everything or nothing
