00:00:02 <vegai> pumpkin: waits for \n
00:00:05 <pumpkin> oh
00:00:16 <pumpkin> vegai: that's dumb :/
00:00:24 <duryodhan> Raevel: k
00:00:27 <vegai> darcs at least optionally depends on curses and terminfo
00:00:33 <vegai> probably it does it through one of those, thoun
00:00:42 <vegai> "thoun"?
00:00:46 * vegai shakes his head.
00:02:02 <erikc> the vancouver haskell users group is at a bar 50 metres from where i live...convenient
00:04:13 <jeffz`> vegai: try, main = hSetBuffering stdin NoBuffering >> getChar
00:04:36 <pumpkin> jeffz`: didn't fix it for me
00:04:42 <jeffz`> does for me
00:04:51 <jeffz`> which weird platform are you on?
00:05:11 <pumpkin> mac os, in ghci :P
00:05:14 <pumpkin> ghci probably messes with it
00:05:25 <jeffz`> ha. I knew it. mac os.  works for me in ghci too :)
00:05:46 <pumpkin> :o
00:05:51 * pumpkin slaps his computer
00:05:52 <Raevel> it works for me in ghci on os x though
00:05:57 <pumpkin> lol
00:05:58 <Raevel> (iterm)
00:06:01 <pumpkin> maybe I'm just doing it wrong
00:06:20 <pumpkin> oh I was :)
00:06:22 <Raevel> (and terminal)
00:06:24 <Raevel> grood
00:06:32 <pumpkin> maybe http://is.gd/Gf7 ?
00:06:35 <pumpkin> was my problem
00:06:49 <jeffz`> you have hairy palms?
00:06:55 <jeffz`> that's the first sign of madness :P
00:08:42 <pumpkin> lol
00:14:08 <pumpkin> I want functions to be a typeclass too
00:14:11 <pumpkin> if that makes any sense
00:14:47 <pumpkin> with the apply "operator" user-definable
00:15:36 <pumpkin> I guess I could just steal $
00:16:11 <pumpkin> but that's different
00:20:13 <Axman6> do {x <- f y; return x} == do {f y} right?
00:20:58 <Raevel> yes
00:21:10 <Axman6> good, not sure what i was thinking there...
00:21:18 <pumpkin> you can scrap the do too
00:21:24 <Axman6> yeah
00:22:45 <duryodhan> hahahah .. this is so cool (for me atleast ) -- firstWords x = unlines (map head (map words (lines x)))
00:22:56 <duryodhan> to print the first word of each line
00:23:27 <Raevel> duryodhan: it is cool!
00:23:34 <Axman6> > let firstWords x = unlines (map head (map words  (lines x)))
00:23:35 <lambdabot>   <no location info>: parse error on input `;'
00:23:56 <intoverflow> :t lines
00:23:56 <lambdabot> String -> [String]
00:23:57 <Axman6> > let firstWords x = unlines (map head (map words  (lines x))) in firstWords "hello world\n this is \n\na test\n"
00:23:58 <lambdabot>   "hello\nthis\n* Exception: Prelude.head: empty list
00:24:08 <duryodhan> ohh
00:24:09 <Axman6> yeah didn't think it was safe
00:24:17 <duryodhan> hehe .. my line didn't end with an empty line
00:24:20 <duryodhan> but shouldn't matter
00:24:24 <duryodhan> wait
00:24:36 <duryodhan> damn
00:24:38 <duryodhan> :(
00:24:47 <duryodhan> *my file didn't end with an empty line
00:25:09 <duryodhan> I  will just have to write safeHead or something like that
00:25:18 <Axman6> > let firstWords x = unlines [x | (Just x) <- (map listToMaybe (map words  (lines x)))] in firstWords "hello world\n this is \n\na test\n"
00:25:20 <lambdabot>   "hello\nthis\na\n"
00:25:24 <Axman6> :)
00:26:19 <Raevel> @src listToMaybe
00:26:20 <lambdabot> listToMaybe []        =  Nothing
00:26:20 <lambdabot> listToMaybe (a:_)     =  Just a
00:26:31 <duryodhan> where safehead [] = []
00:26:32 <duryodhan>          safehead x = head x
00:26:34 <Axman6> duryodhan: i used two tricks there, first listToMaybe is basicallt safe head, it's [a] -> Maybe a, and in the list comprehension, if i get a Nothing, it doesn't match Just x, so it can ignore it
00:26:44 <Axman6> duryodhan: that won't type check
00:26:52 <Axman6> :t head
00:26:53 <lambdabot> forall a. [a] -> a
00:26:56 <Axman6> :t []
00:26:57 <lambdabot> forall a. [a]
00:27:04 <pumpkin> make it a Maybe!
00:27:35 <Axman6> > let firstWords x = unlines [x | (Just x) <- (map listToMaybe (map words  (lines x)))] in text $ firstWords "hello world\n this is \n\na test\n"
00:27:35 <lambdabot>   hello
00:27:35 <lambdabot>  this
00:27:35 <lambdabot>  a
00:27:47 <duryodhan> Axman6: it worked .. I think cos I didn't make it a function .. its a where/let
00:27:53 <duryodhan> your solution is certainly better
00:28:02 <Raevel> > let safehead [] = []; safehead x = head x in [safehead [],safehead [1]]
00:28:03 <lambdabot>       No instance for (Num [a])
00:28:03 <lambdabot>        arising from the literal `1' at <inter...
00:28:05 <Axman6> duryodhan: it's still a function in a where clause
00:28:07 <sleven> does HaPPs have its own webserver?
00:28:28 <duryodhan> firstWords x = unlines (map safehead (map words (lines x)))
00:28:30 <duryodhan> 		where safehead [] = []
00:28:31 <duryodhan> 		      safehead x = head x
00:28:35 <duryodhan> it works fine
00:28:38 <duryodhan> I am curious why !
00:28:39 <Axman6> it shouldn't
00:28:40 <duryodhan> :D
00:28:44 <Workybob> duryodhan: it shouldn't at all
00:28:46 <pumpkin> :t listToMaybe
00:28:47 <lambdabot> forall a. [a] -> Maybe a
00:28:51 <pumpkin> :t listToMaybe . take 1
00:28:53 <lambdabot> forall a. [a] -> Maybe a
00:28:54 <duryodhan> I know .. after you pointed it out I realised it shouldn't
00:29:20 <Axman6> if it does work... the compiler's retarded :|
00:29:21 <duryodhan> *Main Data.List> :l firstWords.hs
00:29:23 <duryodhan> [1 of 1] Compiling Main             ( firstWords.hs, interpreted )
00:29:24 <duryodhan> Ok, modules loaded: Main.
00:29:26 <duryodhan> *Main Data.List> firstWords "dev qwe qwe\n\n\nqeqw qw qe\n"
00:29:27 <duryodhan> "dev\n\n\nqeqw\n"
00:29:37 <Raevel> i'm confused
00:29:46 <duryodhan> (sorry about pasting stuff  here .. why did freenode block mibbit.com?! )
00:29:57 <Raevel> hpaste.org
00:29:59 <Axman6> it hasn't has it?
00:30:06 <pumpkin> duryodhan: most people using it are annoying :P
00:30:12 <pumpkin> duryodhan: you're an exception
00:30:40 <aleator> What is the status of extensible records for ghc? Is there any activity towards them?
00:31:02 <Axman6> extensible records?
00:31:09 <duryodhan> http://hpaste.org/13978
00:31:37 <Axman6> :t readIO
00:31:38 <lambdabot> forall a. (Read a) => String -> IO a
00:31:49 <Axman6> hmm
00:31:50 <Workybob> duryodhan: your second line of safehead is not in the where clause
00:31:55 <Workybob> don't use tabs... ever
00:32:42 <aleator> Axman6: See google :) They are something I seem to be wanting more and more nowadays
00:32:49 <Workybob> but anyway... to the actual problem
00:32:57 <sjanssen> interesting idea for a Haskell shell: rather than implementing while as a primitive, interpret an infinite shell script using only || and &&
00:33:06 <Workybob> the reason that works is that it infers the type of safehead to be [[a]] -> [a]
00:33:14 <Workybob> and that type works in the only use you have there
00:33:33 <Workybob> but when you put numbers in your list, it fails, unsurprisingly
00:33:56 <duryodhan> Workybob: it is tab .. but gedit replaces it with spaces .. and what you are saying would make ghci see safeHead as a function , but :type safeHead doesn't give anything
00:34:14 <Axman6> aleator: not http://www.haskell.org/haskellwiki/Extensible_record ?
00:34:18 <Workybob> duryodhan: you can make ghci see the function by moving it to the top level
00:34:33 <Workybob> *Main> :t safehead
00:34:33 <Workybob> safehead :: [[a]] -> [a]
00:35:00 <duryodhan> so wouldn't that make the whole thing crash ?
00:35:04 <duryodhan> howz it working ?
00:35:15 <Workybob> no, because you *are* working on a list of strings
00:35:20 <Workybob> and that's a list of lists of characters
00:35:39 <Workybob> so safehead returns a list of characters – aka a string
00:35:41 <duryodhan> yeah I know but .. the map would cause an error ..
00:35:50 <Workybob> which map?
00:36:04 <duryodhan> no .. input to safeHead is a list of strings
00:36:11 <Workybob> indeed it is
00:36:12 <duryodhan> so it would return a list of list of list of chars
00:36:16 <Workybob> so safehead returns a single string
00:36:29 <Workybob> no – it's not [a] -> [[a]], it's [[a]] -> [a]
00:36:29 <sleven> im doing my own Matrix-lib to learn Haskell. now I will use arrays(rows*columns) to rep the matrix, ie rep them in one dimension. but when I "show" them i watn them to be shown as a matrix. can I write my own show-function for a specific data? and can I addsomething like, if rows*columns > 1000 -> matrix too big to be printed+
00:36:37 <Workybob> given a list of strings, it gives back a string
00:36:48 <duryodhan> ohh ok
00:37:23 <Axman6> sleven: sure, why not
00:37:26 <Workybob> so now the more important question – what are you trying to achive here?
00:37:49 <duryodhan> print the list of first words of each line in the file
00:37:56 <duryodhan> Axman6 gave a nice solution
00:37:57 <Workybob> sleven: instance Show MyMatrixType where show x = ...
00:38:00 <duryodhan> I am going to look it up later
00:39:06 <Workybob> duryodhan: firstWords = catMaybes . map (listToMaybe . words) . lines ?
00:41:03 <Axman6> > [1..100] :: [!Double]
00:41:05 <lambdabot>       Unexpected strictness annotation: !Double
00:41:05 <lambdabot>      In an expression type si...
00:41:08 <Axman6> hmm
00:41:24 <vegai> jeffz`: linux and ghci here, doesn't affect the result
00:41:25 <duryodhan> Workybob: gimme some time .. I am still trying to wrap my head around safehead
00:41:27 <duryodhan> :)
00:41:30 * duryodhan is a nood
00:41:33 <Workybob> duryodhan: fair enough :)
00:41:40 * duryodhan who can't even type properly :@
00:41:57 <Workybob> duryodhan: hint – your bug is in the first line, not the second
00:42:12 <vegai> jeffz`: works in a compiled binary, though
00:42:30 <vegai> jeffz`: thanks, that'll be enough for me.
00:42:55 <duryodhan> Workybob: no I got the bug .. I am wondering how it worked ..
00:42:59 <duryodhan> Workybob: and I realised now
00:43:01 <Workybob> :)
00:43:08 <psygnisfive> does anyone here know stuff about rewriting systems?
00:43:22 <duryodhan> Workybob: in my use case .. I don't need head to be [a]->a .. I need it to be [[a]]->[a]
00:43:25 <duryodhan> so my safeHead was fine
00:43:44 <mbz> > take 1 []
00:43:45 <lambdabot>   []
00:43:48 <duryodhan> in this particular use case .. although the word safe was a misnomer
00:43:50 <Axman6> just as long as you know it's not actually safe
00:43:50 <mbz> > take 1 [1,2,3]
00:43:51 <duryodhan> :)
00:43:52 <lambdabot>   [1]
00:44:00 <Workybob> duryodhan: yes and no – your safehead doesn't quite do what you intended
00:44:07 <Workybob> in that your output list ends up with a bunch of ""s in it
00:44:31 <Workybob> also, as mbz is trying to point out to you – your safehead is aka take 1
00:44:34 <duryodhan> Workybob: yeah .. as I said .. I know it doesn't .. just that I am surprised it worked and now I have a fair idea why
00:44:42 <Axman6> @src concat
00:44:42 <lambdabot> concat = foldr (++) []
00:45:16 <vegai> wow, really? Isn't that horribly inefficient?
00:45:17 <duryodhan> yeah realised ..
00:45:28 <Workybob> vegai: why would it be?
00:45:31 <Axman6> vegai: why?
00:45:37 <Axman6> builds the list from the end
00:45:44 <Workybob> indeed – much better a foldr than a foldl
00:46:01 <Workybob> foldl would be quadratic
00:46:24 <vegai> so e.g. concat [1,2,3,4] becomes 1 ++ (2 ++ (3 ++ 4))
00:46:32 <vegai> or just the other way around? :P
00:46:33 <Workybob> vegai: no
00:46:39 <duryodhan> wats the function to put a seperator for each concat ?
00:46:50 <vixey> vegai, would be atype error before getting that far
00:46:56 <ziman> > intersperse "," ["foo, "bar", "baz"]
00:46:56 <Workybob> concat [[1,2,3,4], [5,6,7,8]] becomes [1,2,3,4] ++ [5,6,7,8]
00:46:57 <lambdabot>   <no location info>:
00:46:57 <lambdabot>      lexical error in string/character literal at chara...
00:46:58 <Axman6> intercalate
00:47:12 <vegai> Oh, right. What was I thinking.
00:47:16 <Workybob> duryodhan: what Axman6 said, or intersperse to do it seperately
00:47:19 <Axman6> > intercalate "FOO" ["hello","World","thing"]
00:47:21 <lambdabot>   "helloFOOWorldFOOthing"
00:47:42 <Axman6> Workybob: damn it, almost beelsebob'd you
00:47:46 <Workybob> hehe
00:47:53 <Workybob> almost, but not quite
00:47:59 <vegai> but let's say that you're concatenating a list of a thousand strings
00:48:00 <dobblego> vegai, 1 ++ (2 ++ (3 ++ (4 ++ [])))
00:48:13 <Axman6> > foldr (++) [] [a,b,c,d,e] :: Expr
00:48:15 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
00:48:24 <Workybob> vegai: concatenating a list of thousands of strings is always gonna be linear in the number/length of the strings
00:48:27 <Workybob> or worse
00:48:31 <Workybob> the foldr solution is linear
00:48:32 <Axman6> > foldr (++) [] [a,b,c,d,e::[Int]] :: Expr
00:48:32 <dobblego> oops
00:48:33 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
00:48:39 <Axman6> > foldr (+) [] [a,b,c,d,e] :: Expr
00:48:40 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
00:48:43 <duryodhan> Axman6: yeah thanks ..
00:48:49 * duryodhan brb
00:49:09 <Workybob> vegai: if you're gonna do such things lots, it's probably a good idea to use difference lists
00:49:10 <vegai> Workybob: doesn't (++) make it quadratic?
00:49:15 <dobblego> concat [[1], [2], [3], [4]] -> [1] ++ ([2] ++ ([3] ++ ([4] ++ [])))
00:49:22 <Workybob> vegai: no – because foldr builds them up from the right hand end
00:49:29 <dobblego> vegai, no, since laziness
00:49:32 <Workybob> and (++) is linear in the length of only it's left argument
00:49:42 <Workybob> if foldl had been used it would be quadratic
00:50:06 <sleven> is there smoe way to model inheritance in Haskell? like typeinheritance+ is that what typeclaases do? like if I have a Matrix clas in Java  then I mgith subclass DenseMatrix and SparseMatrix. how woudl you do that in haskell?
00:50:07 <Axman6> Workybob: not necessarilly, what if you know the length of the strings? can't that be used make it O(nstrings) instead of O(∑length strings)?
00:50:09 <vegai> ahaa, yes. Now it came to me.
00:50:28 <sleven> just have different functions on it where it is needed?
00:50:29 <dobblego> sleven, type-classes
00:50:32 <Workybob> Axman6: uhhhhhhhhh.... not sure – but it was a little bit of a falicy anyway
00:50:41 <Workybob> it can be done in O(nstrings) with difference lists
00:50:51 <Axman6> yeah
00:50:56 <Axman6> wait, it can?
00:51:16 <Axman6> you'd use foldl append empty for that right?
00:51:50 <Workybob> Axman6: sure – and append on dlists is just (.)
00:51:55 <Axman6> god damn it, why did my program get slow! i have no idea what's wrong with it :'(
00:51:57 <Workybob> (if you represent them as functions)
00:54:25 <paolino> sleven: it is possible that dense and sparse implements the constraints specified as matrix, then they are instances of matrix class
00:55:27 <paolino> which ,in this case, can be thought as a java interface
00:56:02 <paolino> nothing to do with inheritance , I think
01:06:01 <sleven> doesnt array have toList function?
01:06:29 <vixey> :t toList
01:06:30 <lambdabot> Not in scope: `toList'
01:07:21 <paolino> @hoogle Array a b -> [b]
01:07:22 <lambdabot> Data.Array.Base elems :: (IArray a e, Ix i) => a i e -> [e]
01:07:22 <lambdabot> Data.Array.IArray elems :: (IArray a e, Ix i) => a i e -> [e]
01:07:22 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
01:08:28 <sleven> elems
01:10:49 <sleven> can I split a list at in X parts?
01:10:54 <sleven> > :t partition
01:10:54 <lambdabot>   <no location info>: parse error on input `:'
01:11:02 <sleven> :t partition
01:11:03 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
01:11:23 <sleven> doesnt work in ghci
01:12:17 <sleven> not what i wanted
01:12:24 <sleven> isnt there a split in x parts?
01:13:20 <vegai> hmm, where's stdio
01:13:21 <paolino> no
01:13:26 <Axman6> sleven: there is in Data.List.Split
01:13:34 <Axman6> which is on hackage i think
01:13:51 <vegai> "stdio" doh. It's 'stdin'
01:14:26 <paolino> sleven: one idiomatic way is use splitAt under unfoldr
01:15:29 <RayNbow> @let unfoldUntil p f = unfoldr (\x -> guard (not (p x)) >> return (f x))
01:15:31 <lambdabot>  Defined.
01:15:46 <RayNbow> > unfoldUntil null (splitAt 3) [1..]
01:15:48 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23...
01:17:15 <vininim> > partition (==3) [1,2,3,4,5,6]
01:17:16 <lambdabot>   ([3],[1,2,4,5,6])
01:17:49 <paolino> RayNbow ++
01:19:04 <sleven> where is unfoldr and guard?
01:19:14 <dobblego> @index unfoldr
01:19:15 <lambdabot> Data.List
01:19:19 <dobblego> @index guard
01:19:19 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
01:19:50 <sleven> so which one is it i use?
01:20:01 <Axman6> Control.Monad i'd say
01:20:30 <Axman6> @instances Monoid
01:20:31 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
01:20:32 <dobblego> Control.Monad
01:21:46 <Axman6> @src Monoid
01:21:46 <lambdabot> class Monoid a where
01:21:46 <lambdabot>     mempty  :: a
01:21:46 <lambdabot>     mappend :: a -> a -> a
01:21:46 <lambdabot>     mconcat :: [a] -> a
01:22:12 <Axman6> :t mappend (1,2)
01:22:13 <lambdabot> forall t t1. (Monoid t1, Monoid t, Num t1, Num t) => (t, t1) -> (t, t1)
01:22:25 <Axman6> :t mappend ([1],[2])
01:22:26 <lambdabot> forall t t1. (Num t1, Num t) => ([t], [t1]) -> ([t], [t1])
01:22:37 <Axman6> :t mappend ([1],[2]) ([3],[4])
01:22:38 <lambdabot> forall t t1. (Num t1, Num t) => ([t], [t1])
01:22:43 <Axman6> > mappend ([1],[2]) ([3],[4])
01:22:44 <lambdabot>   ([1,3],[2,4])
01:22:53 <Axman6> nice
01:24:42 <Axman6> argh, i don't get it, my program was relatively fast... and now it's 6 times slower. and it's the exact same program!
01:25:04 <vixey> but operating on 6x more complicated data :)
01:25:22 <Axman6> the exact same data :(
01:25:46 <paolino> low cpu voltage ?
01:25:55 <Axman6> should't be
01:26:14 <Axman6> i mean, it was running 6 times faster when my laptop was unplugged yesterday
01:27:06 <Axman6> it just doesn't make any sense :(
01:27:35 <paolino> 5 on 6 burnt cpu's is my take :)
01:29:31 <paolino> Axman6: I hope you recompiled it between the two experiments
01:29:43 <Axman6> yep
01:30:11 <paolino> ok, we are half safe then
01:33:41 <sleven> how do I declare a data Matrix = DA.array d, rows Int, cols, Int ?
01:33:42 <sleven> http://hpaste.org/13979
01:33:52 <sleven> trying to come up with howto rep a amtrix
01:34:02 <sleven> hmm these things are so easy with OO
01:34:13 <sleven> but then with my Java matrix lib the methods are not as good
01:34:19 <sleven> so i have hope for makign it better in haskell
01:34:40 <quicksilver> DA.Array
01:34:46 <quicksilver> types always have capital letters
01:34:49 <jonaskoelker> (sleven: it's not OO that's the trick, it's the arrays of arrays.)
01:35:41 <quicksilver> but note that the parameters of Array are not 'rows cols fill'
01:35:49 <quicksilver> in particular, the parameters of a type are always types, not values.
01:36:19 <quicksilver> possibly you want
01:36:26 <quicksilver> DA.Array Int fill
01:36:26 <sleven> no
01:36:27 <quicksilver> or
01:36:32 <quicksilver> DA.Array (Int,Int) fill
01:37:03 <sleven> but i want something wich i can query for rows and cols andsome internal representation
01:38:33 <m3ga> i'm trying to build something and I get "Could not find module `Distribution.Simple'". How do I  figure out which debian package supplies whatever is needed?
01:39:02 <jonaskoelker> m3ga: apt-file search Distribution | grep -i module
01:39:09 <jonaskoelker> s/module/simple/
01:39:35 <sleven> but then it should be data Matrix repr rows cols fill = ... ?
01:40:08 <quicksilver> sleven: I think you're confused about a number of things.
01:40:20 <quicksilver> you're defining a new type, Matrix.
01:40:33 <quicksilver> You can make your type have parameters, sure, but those parameters must be types.
01:40:35 <m3ga> jonaskoelker: I have ghc, ghc-prof and ghc-doc installed but I still get this error.
01:40:45 <quicksilver> "fill" - presumably this is the type of hte contents of the Matrix - that's fine.
01:40:49 <quicksilver> that's a type.
01:40:51 <sleven> yes
01:41:04 <blueonyx> hi
01:41:05 <quicksilver> "rows" - presumably that's supposed to be the number of rows, that's a VALUE. That's not fine.
01:41:10 <jonaskoelker> quicksilver: wouldn't it be possible to add phantom types that represent dimensions to the matrix Data, such that you can say "matmul :: Matrix a n m -> Matrix a m p -> Matrix a n p"
01:41:11 <quicksilver> types can't have parameters which are values.
01:41:15 <Saizan> m3ga: try libghc6-Cabal-dev
01:41:27 <quicksilver> jonaskoelker: Yes. It would. But let's not confuse sleven while we're explaining the basics :P
01:41:29 <vixey> jonaskoelker, but is that something you would actually want to do?
01:41:40 <blackh> blueonyx: Hello!
01:41:55 <m3ga> Saizan: Note, selecting ghc6 instead of libghc6-cabal-dev, ghc6 is already the newest version
01:42:17 <Saizan> m3ga: are you trying to build a cabalized package?
01:42:19 <jonaskoelker> vixey: maybe, maybe not
01:42:40 <jonaskoelker> vixey: I'm not experienced enough with haskell to guesstimate the costs and benefits
01:42:44 <vixey> jonaskoelker, just wondering if it would work well in practice
01:42:46 <jonaskoelker> quicksilver: agreed :)
01:43:05 <jonaskoelker> yeah... I don't know that
01:43:13 <m3ga> Saizan: i'm on ubuntu and the libghc-opengl-dev package is badly  broken. i'm trying to rebuild it using dpkg-buildpackage
01:43:15 <blueonyx> is there an easy way to convert a Data.Graph into a picture? i tried the graphviz lib on hackage but it seems to need Data.Graph.Inductive graphs :/
01:44:11 <Saizan> m3ga: maybe you've to add Cabal to build-depends in the .cabal file then
01:44:54 <m3ga> Saizan: there is no cabal file. I grabbed the sources using 'apt-get source libghc-opangl-dev'.
01:45:00 <Axman6> http://www.reddit.com/r/programming/comments/7pv4j/ask_reddit_whats_the_most_outrageously_useless_cs/c0721wh haha
01:45:05 <quicksilver> sleven: what people sometimes do is make a version of the natural numbers in the type system, to do this.
01:45:15 <quicksilver> sleven: however, that's unlikely to be something you need for a simple matrix library.
01:45:36 <jonaskoelker> quicksilver: it would be nice to have value-parameteriazable types, though... I hear "group of size n" comes up every so often; I'd like to build finite fields of different sizes as different types...
01:46:07 <Saizan> m3ga: i'd try with the tarball linked from http://hackage.haskell.org/cgi-bin/hackage-scripts/package/OpenGL
01:46:23 <Saizan> m3ga: it's reported to build on 6.8
01:46:33 <vixey> jonaskoelker, it can work out really well by the way but just haskell doesn't support it
01:46:36 <blueonyx> why does the graphviz lib exist if it operates on Data.Graph.Inductive and this lib brings its on graphiz function? O.o
01:47:30 <jonaskoelker> vixey: no extensions for it either?
01:47:38 <vixey> no
01:47:44 <jonaskoelker> :(
01:47:46 <vixey> you have to use a different language
01:47:47 <m3ga> but that  won't have the  debian packaging stuff. i'm not that interested in actually building the package, i'm trying to figure out why it won't build so  i can  hopefully fix the process of packaging haskell tools and libraries on ubuntu.
01:47:49 <sleven> wtf I dont get how to use arrays
01:48:02 <vixey> jonaskoelker, Coq and Agda both do this, among others
01:48:18 <sleven> *Matrix> DA.array(0,2) [(0,0),(1,0),(2,0)]
01:48:18 <sleven> array (0,2) [(0,0),(1,0),(2,0)]
01:48:26 <sleven> a :: DA.Array Integer Integer
01:49:48 <Saizan> m3ga: ah, i see, then if you paste the whole log somewhere i can take a look
01:51:12 <quicksilver> sleven: yes.
01:51:19 <quicksilver> sleven: DA.array is a function, not a type.
01:51:27 <quicksilver> sleven: do you see what's going on there?
01:51:33 <m3ga> Saizan: http://hpaste.org/13980
01:51:43 <quicksilver> "Array" is the type, "array" is the function.
01:51:55 <quicksilver> "array" builds an "Array" for you.
01:52:43 <quicksilver> m3ga: are you trying to build against 6.8 or 6.10 ?
01:53:09 <m3ga> quicksilver: building with stock ubuntu ghc-6.8.2
01:53:17 <sleven> not in scope type variable a
01:53:19 <sleven> ok so wtf
01:53:25 <quicksilver> m3ga: type "locate Simple.hi"
01:53:35 <quicksilver> for me, that reports : /usr/lib/ghc-6.6/imports/Distribution/Simple.hi
01:54:10 <m3ga> quicksilver: I get /usr/lib/ghc-6.8.2/lib/Cabal-1.2.3.0/Distribution/Simple.hi
01:54:17 <quicksilver> ok, that's good.
01:54:20 <quicksilver> hmm.
01:54:44 <Saizan> ghc-pkg describe Cabal ?
01:54:59 <quicksilver> m3ga: weird error. Can you build other debian ghc packages?
01:54:59 <sleven> heres how i did: http://hpaste.org/13981
01:55:35 <quicksilver> sleven: having rows and cols as parameters to the Matrix type like that doesn't make sense.
01:55:41 <quicksilver> m3ga: (ubuntu rather)
01:56:15 <m3ga> ghc-pkg describe Cabal => http://hpaste.org/13980#a1
01:57:11 <quicksilver> m3ga: I wonder if the problem is related to the fact that you have some pacakges installed in your home directory
01:57:14 <quicksilver> and some installed globally.
01:57:51 <quicksilver> You have 1.6.0 installed in your home dir and 1.2.3 installed globally, it looks like.
01:58:14 <Saizan> that shouldn't be a problem, if he's building opengl with the same user
01:58:27 <m3ga> quicksilver: other packages also fail to  build (ie parsec) in the same way.
01:58:40 <m3ga> i'll try cleaning up $PATH
01:58:47 <quicksilver> Saizan: if he's trying to build a debian package,
01:58:55 <quicksilver> Saizan: then it wants to depend on the other debian versions
01:58:58 <quicksilver> (ubuntu versions)
01:59:04 <Saizan> /home/erikd/.cabal/lib/Cabal-1.6.0.1/ghc-6.8.2
01:59:11 <quicksilver> you don't want a globally installed pacakge linking to versions in erikd's home dir.
01:59:28 <Saizan> do you actually have the file "/home/erikd/.cabal/lib/Cabal-1.6.0.1/ghc-6.8.2/Distribution/Simple.hi"?
01:59:42 <quicksilver> m3ga: unfortunately it's not $PATH that decides which cabal directories are visible.
01:59:45 <quicksilver> dcoutts_: help?
01:59:50 <Saizan> yeah, that's true
01:59:55 <Saizan> he should pass --global
02:00:09 <Saizan> but not to ghc --make
02:00:24 <m3ga> Saizan: /home/erikd/.cabal/lib/Cabal-1.6.0.1/ghc-6.8.2 doesn't exist (it did but not any more)
02:00:38 <Saizan> ah, that's the problem!
02:00:52 <Saizan> you can't just delete the files like that
02:01:00 <m3ga> so what file is pointing to it?
02:01:14 <Saizan> the packagedb inside ~/.ghc
02:01:39 <Saizan> but you can delete that, and then you'd have only globally installed packages
02:02:16 <m3ga> ok, "rm -f ~/.ghc/i386-linux-6.8.2/package.conf" fixed that.
02:02:45 <m3ga> hmm, thats a bug somewhere, but where?
02:03:30 <Saizan> a bug?
02:04:16 <Saizan> the error message is not very clear, but they are making it better in the next release
02:04:30 <m3ga> Saizan: whatever is in ~/.ghc/ should be validate, rather than giving horribly obscure error messages.
02:04:49 <m3ga> ok, looking forward to that new vesion.
02:05:03 <m3ga> Saizan, quicksilver : thanks
02:05:40 <sleven> http://hpaste.org/13982
02:05:58 <sleven> especially id like to print each row
02:06:02 <sleven> without the outer []
02:06:06 <quicksilver> m3ga: to be fair, the system doesn't expect you to delete stuff at random
02:06:14 <quicksilver> m3ga: but it's definitely a bit unsatisfactory.
02:06:24 * quicksilver is pretty unhappy about the whole user/global thing
02:06:37 <quicksilver> (but I have no concrete or constructive improvements to suggest)
02:07:05 <quicksilver> sleven: it *still* doesn't make sense to have rows and cols as parameters to data Matrix.
02:07:13 <quicksilver> that does not mean what you think it means.
02:07:33 <quicksilver> the two occurences of the word 'rows' in that data declaration are not connected as far as ghc is concerned.
02:07:42 <m3ga> quicksilver: i chose safe languages like ocaml and haskell because I want the compiler to warn me when I do something silly. Yes, I did something silly, but the compile took bad information and did something  silly with it.
02:07:51 <sleven> I know
02:07:59 <sleven> i pass it so I can query direxctly later
02:08:10 <sleven> when I construct the matrix with makeMatrix it is arranged
02:08:10 <quicksilver> m3ga: this isn't a language issue, it's a compiler/infrastructure issue.
02:08:16 <quicksilver> m3ga: but I don't disagree.
02:08:41 <quicksilver> sleven: "data Matrix repr rows cols" <-- these occurrences of rows and cols don't mean what you think they mean.
02:08:53 <quicksilver> they have nothing to do with the rows and cols fields you gave the data type.
02:09:10 <sleven> ys they do
02:09:14 <sleven> no they dont
02:09:16 <sleven> i mean
02:09:21 <sleven> i know it is jsut the sma ename
02:09:36 <sleven> they become those fields right
02:09:44 <sleven> data Matrix repr r c =
02:09:44 <sleven>     Matrix { matrix :: DA.Array Int Double, rows::Int, cols::Int }
02:09:44 <sleven>            deriving(Eq, Ord, Show)
02:09:47 <sleven> like so
02:10:11 <hydo> "And that is how the elephant came to be labelled a rope in all the guide books."   If I worked all day I couldn't have put it better.
02:10:29 <sleven> hydo: what is hat about?
02:10:45 <sleven> anyway is there a way to hide a function? meaning it is internal to the module?
02:10:51 <hydo> sleven: One sec, let me find it on the web.
02:10:53 <quicksilver> sleven: but the 'r' and 'c' are completely phantom. They don't mean anything to anyone.
02:11:04 <quicksilver> sleven: yes, if you give an explicit export list
02:11:12 <quicksilver> then anything you don't mention is not exported - then it's internal
02:13:27 <sleven> quicksilver: so? what is your point?
02:14:00 <hydo> sleven: http://article.gmane.org/gmane.comp.lang.haskell.cafe/50755
02:14:34 <quicksilver> sleven: my point is, what are you using them for if they're completely phantom?
02:14:51 <bastl> Im experimentint something in ghci: How can i cast an "IO String" to a normal String?
02:14:59 <hydo> Re: simplifying Monads by naming them something else.  Well, I guess that's an overgeneralization... read the messages up the thread for context.
02:15:12 <bastl> ah, guess hoogle is my friend. ...
02:15:27 <hydo> bastl: x <- IO String  ... I think...
02:16:02 * hydo prepares to be corrected...
02:16:08 <sleven> how do I map print over something? mapM?
02:16:34 <dibblego> mapM_
02:17:13 <hydo> wow... did I just answer a question correctly?  dance dance dance!
02:17:20 <quicksilver> bastl: you can't cast an IO String to a String, but you can execute it
02:17:23 <bastl> hydo: that makes sense. ghci is in the IO monad
02:17:28 <quicksilver> like x <- getLine
02:17:34 <quicksilver> (getLine :: IO String)
02:17:36 <quicksilver> as hydo said :)
02:18:02 <hydo> hehe... you couldn't wipe the smile off of my face if you slapped me.  I love this language
02:18:07 <bastl> thanks, im about to get the theory, but when it comes to practical work im soo slow ...
02:18:28 <quicksilver> bastl: getLine is a good one to think about.
02:18:31 <hydo> bastl: heh, I'm right there with ay.
02:18:34 <hydo> s/ay/ya
02:18:39 <quicksilver> you can't cast it to a string, since obviously it's different every time
02:18:45 <quicksilver> (well potentially)
02:18:48 <quicksilver> but you can execute.
02:18:56 <quicksilver> each time you execute it, you get something different.
02:19:37 <sleven> http://hpaste.org/13983
02:19:59 <sleven> why does it print that extra line? and how do I do the instance show stuiff?
02:20:22 <quicksilver> extra line ?
02:20:30 <sleven> http://hpaste.org/13983#a1
02:20:56 <quicksilver> odd!
02:21:06 <blackh> sleven: That's mapM's return value. Use mapM_.
02:21:27 <quicksilver> ah
02:21:31 <quicksilver> as blackh said ;)
02:21:34 * quicksilver was slower.
02:21:46 <bastl> damnit ... i have f :: String -> a, and bound the contents of a file to "myfile :: IO String". How do i apply f to myfile ?
02:21:56 <quicksilver> sleven: as for "how do you do the instance show stuff", printMatrix has the wrong type to be a show.
02:22:08 <quicksilver> sleven: printMatrix is in IO. show is just supposed to be a String.
02:22:09 <quicksilver> :t show
02:22:10 <lambdabot> forall a. (Show a) => a -> String
02:22:30 <quicksilver> bastl: do f <- myfile; (do stuff to f)
02:22:41 <quicksilver> you can use a newline instead of a ;
02:24:16 <sleven> but show is what comes uot if u just do ghci> m ?
02:24:24 <sleven> where m is a Matrix
02:24:44 <sleven> but how whould i make a string? between each riw a \n ?
02:25:25 <quicksilver> sleven: instead of mapM print
02:25:30 <sleven> and also is it possible to define my own syntax? can i use ' for trnspose? so I can write m '
02:25:32 <sleven> m'
02:25:36 <quicksilver> you could just use map show
02:25:53 <quicksilver> and then unlines, perhaps.
02:26:17 <quicksilver> You can define your own operators but symbolic operators are all infix, binary
02:26:33 <quicksilver> (prefix operators are alphanumeric - also known as functions)
02:26:45 <quicksilver> there is no support for postfix operators like m'
02:26:56 <sleven> map show gives ["[0.0,0.0,0.0,0.0]","[0.0,0.0,0.0,0.0]","[0.0,0.0,0.0,0.0]"]
02:27:04 <sleven> but I want it on a row each
02:27:28 <bastl> sleven: override show i guess !?
02:27:41 <blackh> unlines . map show
02:29:31 <sleven> the problem is with this whole thing is I see now I have : arrayToListList :: Matrix repr r c -> [[Double]]
02:29:36 <sleven> which is not so nice
02:29:59 <sleven> but I need to carry the info of rows and cols with the matrix since I use a 1D-array to rep it
02:32:27 <blackh> sleven: What are you trying to achieve?
02:32:42 <quicksilver> sleven: you could use a 2D array, by the way
02:32:53 <quicksilver> sleven: but I was tring to address your points only one at a time ;)
02:33:18 <sleven> no i want 1d array
02:33:25 <quicksilver> why?
02:33:46 <sleven> quicksilver: im tyring to achieve a basic matrix module, with some linear algebra, eventually svd ldu etc
02:34:01 <quicksilver> sure.
02:34:07 <quicksilver> why is that a reason not to use a 2D array?
02:34:11 <sleven> im basiclaly trying to leanr haskell (perhaps to quickly)
02:34:22 <sleven> becuae I did with my Java lib
02:34:30 <quicksilver> > listArray ((0,0),(1,1)) [1,2,3,4]
02:34:31 <lambdabot>   array ((0,0),(1,1)) [((0,0),1),((0,1),2),((1,0),3),((1,1),4)]
02:34:32 <sleven> and sinc eim gonna use if i use it for huge sparse matrices
02:34:40 <quicksilver> ah, well that's different.
02:34:40 <sleven> it seems 1d arrays are simpler
02:34:47 <quicksilver> if you're doing sparse, you'll have to be clever.
02:34:56 <quicksilver> but a haskell 2D is just a 1D array with clever indices.
02:35:09 <quicksilver> and haskell arrays store their bounds which saves you having to store rows and cols.
02:35:16 <quicksilver> doesn't help for the sparse case though.
02:36:38 <quicksilver> sleven: I think having a goal/purpose in mind is a great way to help motivate learning a language, though.
02:37:25 <blackh> sleven: You could abstract your method of storage so you have a different storage method for sparse and non-sparse cases.
02:38:04 <bastl> quicksilver: i dont get it. "do f <- testfile; myLLexer f;"    First "f <- testfile" binds f to the result of action testfile. So f is a nonmonadic value?. Then "myLLexer f" computes something which is the result of the whole do-epression, right? But it still doesnt work: http://hpaste.org/13984
02:39:12 <blackh> sleven: Data.IntMap might be worth considering for spare matrice.
02:39:21 <asgaroth> bastl: It's syntactic sugar for testfile >>= \f -> myLLexer f
02:39:56 <asgaroth> bastl: The >>= `extracts' the value from the monad and passes it to a function that has to return a monadic value in turn
02:40:22 <Workybob> bastl: what's the type of myLLexer?
02:40:27 <bastl> so the problem is that my lexer doesnt return a monadic value?
02:40:34 <Workybob> well it does actually
02:40:37 <Workybob> but the wrong monad
02:40:39 <vixey> use  return (myLLexer f)  then
02:40:43 <bastl> and i have to prepend return ?
02:40:48 <bastl> i c
02:40:54 <sleven> quick and black: thanks fo the tips ill keep it in mind. now time for dinner
02:41:10 <Workybob> bastl: of note, this IO code should be kept constrained as close to the main function as possible
02:41:14 <asgaroth> bastl: or myLLexer `fmap` testfile
02:41:32 <Workybob> that too, but <$> is neater for infix fmap
02:41:36 <bastl> asgaroth_: that didi it
02:42:16 <asgaroth> bastl: Workybob's suggestion looks even nicer, but you have to import Control.Applicative
02:42:16 <Workybob> bastl: <$> or fmap are functions for applying functios *inside* structures
02:42:37 <Workybob> so, myLLexer <$> testfile applies the lexer inside the IO
02:43:14 <asgaroth> they basically lift a function into the monad, so liftM === fmap
02:43:28 <bastl> somehow confusing, especially since im in ghci which is already in IO, if i get it right ...
02:43:41 <bastl> but anyhow i will get along now. thanks everyone ...
02:44:19 <hugo___> hi
02:45:21 <blackh> hi there, hugo___
02:45:49 <pozic> Please have a look here: http://paste.debian.net/26110/
02:47:48 <blackh> pozic: You can say class MonadState (A Int) m => Foo m f then it's implied on your instance declarations.
02:49:58 <pozic> blackh: the issue is that the A Int varies.
02:50:00 <blackh> pozic: But you still need two instance declarations for each type. One for MonadState and one for Foo.
02:50:13 <quicksilver> pozic: add another parameter to Foo?
02:50:23 <quicksilver> class MonadState s m => Foo m s f where ....
02:50:28 <vixey> write a perl script that prints out the haskell program
02:53:00 <pozic> quicksilver: then you still get: Could not deduce (MonadState (A Int) m) from the context ()
02:55:22 <blackh> pozic: What's the line of code where the error occurs?
02:56:33 <quicksilver> pozic: Oh, right.
02:56:46 <quicksilver> supeclasses let you reduce function contexts but not instance contexts.
02:56:56 <quicksilver> yeah, I don't see a way to reduce the instance context.
02:58:53 <quicksilver> blackh: http://hpaste.org/13985
02:58:57 <quicksilver> blackh: is the example with the error.
03:00:38 <blackh> quicksilver: Thanks. The cogs in my brain are freewheeling for a while yet.
03:00:46 <quicksilver> pozic: the instance "instance Foo m (A Int) X ..." declares that it works for all types m
03:00:49 <quicksilver> which is of course not true.
03:00:53 <quicksilver> hence you need the context.
03:01:11 <quicksilver> it really does only work for those types m such that (MonadState (A Int) m) holds.
03:01:47 <pozic> quicksilver: yes, but I want the m to refer to have the constraint (MonadState <some type>  m), but I only want to specify that once.
03:02:20 <quicksilver> I sort of understand what you're saying.
03:02:31 <quicksilver> But reflect that instance declarations are read "alone"
03:02:36 <quicksilver> instance Foo m ...
03:02:38 <quicksilver> means it works for all m
03:02:46 <quicksilver> that's quite simply what that syntax denotes.
03:02:46 <pozic> quicksilver: yes, I understand what you say.
03:04:21 <tjb> I'd like to map the "showHex" function to each item in a list -- but I am having problems with the argument list.  Any pointers?
03:04:52 <Workybob> @type showHex
03:04:53 <lambdabot> forall a. (Integral a) => a -> String -> String
03:04:56 <Workybob> argument list?
03:05:06 <quicksilver> > map (\x -> showHex x "") [1,2,3,4]
03:05:07 <lambdabot>   ["1","2","3","4"]
03:05:17 <quicksilver> tjb: is that what you want? ;)
03:05:20 <tjb> quicksilver: ah, made it look too easy -- thanks :)
03:05:24 <Workybob> > map ((flip showHex) "") [1,2,3,4,5]
03:05:25 <lambdabot>   ["1","2","3","4","5"]
03:05:32 <Workybob> more efficient that way
03:05:36 <Workybob> margionally
03:05:39 <quicksilver> > map (`showHex` "") [1,2,3,4,5]
03:05:40 <lambdabot>   ["1","2","3","4","5"]
03:05:48 <Workybob> oh, yeh, what quicksilver said
03:05:49 <tjb> haha, ok ok -- I get it now :)
03:05:50 <quicksilver> Workybob: how is that more efficient?
03:05:50 <Workybob> that's far neater
03:06:20 <Workybob> quicksilver: the lambda has subtly different semantics, so it has to create an extra thunk
03:06:21 <Workybob> IIRC
03:06:21 <tjb> so options were either a lamba function, flip or infix notation
03:06:24 <quicksilver> flip gets inlined and turns into the lambda.
03:06:26 <quicksilver> it's the same.
03:06:31 <Workybob> quicksilver: no it doesn't
03:06:34 <quicksilver> I bet it generates the same core under -O
03:06:36 <Workybob> it has different semantics
03:06:43 * Workybob tries to remember why
03:06:49 <quicksilver> @src flip
03:06:49 <lambdabot> flip f x y = f y x
03:07:00 <quicksilver> flip = \f x y -> f y x
03:07:14 <quicksilver> (\f x y -> f y x) showHex ""
03:07:14 <Workybob> hmm, true
03:07:24 <Workybob> so that means right hand partial application isn't as efficient as left handed
03:07:37 <pozic> ?
03:07:51 <lilac> Workybob: it depends on whether anything can be usefully done with the partial application
03:08:02 <Workybob> lilac?
03:08:06 <Workybob> quicksilver: the difference...
03:08:07 <Workybob> a1 = let f = (op (e 1)) in (f 10, f 100)
03:08:07 <Workybob> a2 = let f = (\x -> op (e 1) x) in (f 10, f 100)
03:08:15 <Workybob> in the former, (e 1) is evaluated once
03:08:15 <quicksilver> f x = let blah = blah in \y -> ....
03:08:16 <pozic> The compiler can reorder everything as it sees fit. If it globally is better to have the arguments of flip reversed, then it can do that.
03:08:17 <Workybob> in the latter, twice
03:08:21 <lilac> f x = let k = expensive x in \y -> y + k
03:08:31 <quicksilver> ^^ this is an example of when the partial application does something.
03:08:35 <tjb> I needed the toInteger function as well .. map ((`showHex` "") . toInteger) [1,2,3]
03:08:39 <quicksilver> pozic: In theory. In practice however, it does not.
03:08:45 <pozic> quicksilver: I know.
03:08:56 <quicksilver> tjb: you should not need that.
03:08:58 <tjb> since the list item are actually Word128
03:09:01 <pozic> quicksilver: I thought we were talking about theory :)
03:09:18 <quicksilver> :t toInteger
03:09:19 <lambdabot> forall a. (Integral a) => a -> Integer
03:09:27 <quicksilver> toInteger works on all Integral types
03:09:28 <lilac> Workybob: there are /no guarantees/ about how many times something is evaluated.
03:09:32 <quicksilver> but so does ShowHex
03:09:36 <quicksilver> so it shouldn't make any difference
03:09:45 <Workybob> lilac: true true – but they are operationally different, given lazy evaluation
03:10:13 <tjb> quicksilver: hmm, looks like I am doing something wrong -- since the Word128 type is having an issue
03:10:19 <vixey> it's fair to assume lazy evaluation, even if the reality is slighty different
03:10:19 <lilac> Workybob: they're the same (under eta-elimination i think)
03:10:28 <lilac> Workybob: (semantically)
03:10:36 <tjb> Data/LargeWord.hs:133:0: No instance nor default method for class operation GHC.Real.quotRem
03:10:36 <Workybob> lilac: denotationally, yes
03:10:40 <Workybob> but not operationally
03:11:07 <lilac> Workybob: operational semantics for Haskell are not defined
03:11:19 <quicksilver> tjb: oh yes, that's right, Word128 is broken.
03:11:28 <lilac> Workybob: and GHC's operational semantics may well differ depending on optimization level
03:11:32 <quicksilver> tjb: use toInteger as you initially suggested :)
03:11:37 <Workybob> lilac: sure, but when talking about efficiency, it's interesting to talk about the operational semantics – and all haskell compilers are in common use do lazy evaluation
03:11:38 <tjb> quicksilver: I believe so -- especially since you pointed it out to me last week :)
03:11:41 <mstr> incorrect indentation? http://pastebin.com/d749c06b1
03:11:52 <quicksilver> tjb: I didn't realise showHex would use quotRem
03:11:57 <quicksilver> although thinking about it, I'm not sutrprised.
03:12:02 <Workybob> mstr: no, you have no = in your second guard
03:12:14 <Workybob> mstr: I think you probably meant | otherwise = ...
03:12:43 <lilac> Workybob: if we required the operational semantics to be lazy in the sense i think you mean, that would seem to prevent various useful optimizations
03:12:50 <quicksilver> lilac: you can say that, but then you may as well give up writing programs.
03:12:58 <quicksilver> lilac: since you are entirely unable to predict space leaks.
03:13:08 <Workybob> lilac: sure – what I'm saying though is that we know pretty much the operational semantics of ghc
03:13:11 <quicksilver> lilac: in practice, we do have to understand GHC's sharing behaviour.
03:13:17 <Workybob> or at least a good chunk about sharing
03:13:26 <Workybob> and we know that the lambda version is different operationally
03:13:32 <mstr> Workybob: like | otherwise x * (x ^ (n - 1))
03:13:34 <mstr> ?
03:13:41 <Workybob> mstr: | otherwise = x * ....
03:13:58 <lilac> Workybob, quicksilver: yes, i agree with you both ;-)
03:14:48 <mstr> thanks, it worked. just wondering, why isn't the otherwise used in the first example here? http://en.literateprograms.org/Fibonacci_numbers_(Haskell)
03:15:06 <hugo___> is there any way to know if a cabal package is in need of an update ?
03:15:37 <Workybob> mstr: because there's nothing you can sensibly do when n is negative
03:15:40 <Workybob> (the otherwise case)
03:15:50 <quicksilver> mstr: also, using precise conditions rather than otherwise is a bit more attractive
03:15:52 <Workybob> I guess they could have added | otherwise = error "zomg, don't fibonacci that"
03:15:59 <lilac> I would love it if there were defined operational semantics for haskell (or at least if those of GHC were clearly written down somewhere)
03:16:13 <Workybob> lilac: the part in parens, YES!
03:16:21 <quicksilver> lilac: they are clearly written down
03:16:27 <Workybob> the defining operational semantics for the language though would disalow certain things
03:16:28 <quicksilver> in the logs of #haskell and #ghc, and various mailing lists
03:16:31 <quicksilver> going back over 15 years
03:16:38 <quicksilver> the challenge is to sort the clear parts from the rubbish
03:16:43 <Workybob> like "o hai, I came up with a new optimisation"
03:16:47 <mstr> ah, I think I got the syntax now
03:16:48 <quicksilver> the SNR is about 1:10000
03:16:49 <mstr> thx
03:16:49 <lilac> quicksilver: clear water plus mud is no longer clear
03:17:01 <quicksilver> look closely enough at the right molecule and it's clear
03:17:06 <quicksilver> it's all the question of scale :P
03:17:20 <quicksilver> I'm being flippant
03:17:22 <quicksilver> It would be nice, yes.
03:18:28 <lilac> Workybob: new optimizations which cause existing programs to start to leak space don't sound great to me
03:18:54 <lilac> Workybob: some rules of the form "this may be shared, that must not be" would be sufficient
03:18:54 * vixey should probably just accept defeat
03:19:10 <lilac> (with anything in between left undefined)
03:19:47 <lilac> quicksilver: fwiw, i find dons' blog to be a pretty good source of this type of info
03:20:47 <sleven> can I not have if-else-then in a do-construct?
03:21:17 <lilac> sleven: yes you can. but you may need to add 'do's to the then and else branches
03:21:19 <blackh> sleven: You can, but you need to get your indenting just so!
03:22:01 <lilac> sleven: remember that the 'then' and 'else' must produce 'm a' where m = your monad
03:22:12 <lilac> (if you use it at the top level)
03:23:58 <sleven> can I define ' to be an operator ? and can it ever be next to the variable? like x' or I have to do x ' then?
03:24:07 <sleven> (') doesnt make it blue in emacs
03:24:41 <BONUS> nope
03:24:43 <blackh> sleven: In Haskell, ' is an identifier character, not an operator character
03:24:54 <BONUS> > let a' = 9 in a'
03:24:55 <lambdabot>   9
03:26:28 <sleven> meh
03:26:39 <sleven> i have a fetish for bervity
03:26:43 <sleven> brevity
03:26:55 <sleven> a really bad and naughty one
03:27:07 <sleven> i hate to write transpose A
03:27:07 <sleven> A'
03:27:15 <blackh> Does anyone know, is it actually possible to make ghc use Unicode characters as operators?  It seems like it is but I've never found the switch to enable it.
03:27:28 <sleven> T A is ok i guess
03:27:48 <sleven> but hmm its not since i cant name a function T
03:27:53 <blackh> If you can do that, then you can write real APL stuff!
03:27:55 <pk> Does any of you use Hipmunk ?
03:28:08 <pk> I have a strange bug
03:28:15 <duryodhan> Workybob: ghci doesn't tab complete for listToMaybe or catMaybe
03:28:21 <duryodhan> Workybob: what are these functions ?
03:28:26 <jeffz`> pk, what's the bug?
03:28:51 <pk> pk, Bodies don't collide
03:29:09 <Workybob> duryodhan: ...
03:29:12 <Workybob> @type listToMaybe
03:29:13 <lambdabot> forall a. [a] -> Maybe a
03:29:15 <Workybob> @type catMaybes
03:29:15 <lambdabot> forall a. [Maybe a] -> [a]
03:29:18 <jeffz`> pk, last time I checked they did collide for me, maybe there is an error in your code
03:29:23 <Workybob> > listToMaybe [1,2,3]
03:29:24 <lambdabot>   Just 1
03:29:27 <pk> pk, yeah it's sure
03:29:31 <Workybob> > listToMaybe []
03:29:32 <lambdabot>   Nothing
03:29:33 <lilac> sleven: use a real operator character and set -XPostfixOperators and you can do that
03:29:41 <Workybob> > catMaybes [Just 1, Just 2, Nothing, Just 3]
03:29:41 <pk> jeffz, I meant bug in my code
03:29:42 <lambdabot>   [1,2,3]
03:29:47 <duryodhan> Workybob: what do I need to do in ghci to get it ?
03:29:51 <duryodhan> :m what ?
03:30:06 <pk> jeffz, I can't find what I do wrong
03:30:12 <Workybob> duryodhan: :m +Data.Maybe
03:30:17 <lilac> > let (^) = transpose in ([[1,2],[3,4]]^)
03:30:19 <lambdabot>   [[1,3],[2,4]]
03:30:49 <Workybob> lilac: nice, but *shudder* at the consequences of that overloading
03:30:55 <Workybob> nice way to make code totally unreadable
03:31:01 <jeffz`> pk, have you read the example code first?
03:31:28 <lilac> Workybob: hehe ;-) it was the first superscript operator character i thought of
03:31:29 <pk> jeffz, the hipmunk playground thing ?
03:31:51 <jeffz`> pk, either that or the C examples
03:32:01 <jeffz`> pk, the playground works for you, yes?
03:32:03 <RayNbow> > let t=transpose; (＾) = flip ($)         in         [[1,2],[3,4]]＾t  -- testing...
03:32:03 <lilac> is 'degrees sign' an operator character?
03:32:04 <lambdabot>   [[1,3],[2,4]]
03:32:14 <pk> jeffz', yeah, no problem
03:32:54 <jeffz`> pk, have you attached shapes to the bodies?
03:33:08 <duryodhan> Workybob: cool got it.. thanks! :)
03:33:17 <Workybob> duryodhan: glad to be of service :)
03:33:18 * duryodhan is at work so might go off and on
03:33:38 <pk> jeffz', I do a newShape with the body
03:34:48 <jeffz`> pk: hard to say without seeing your code, though I suggest you study it harder :)
03:36:12 <pk> jeffz', just one thing. If I see the objects moving and everything exept the collisions. It means it's a shape creation problem, right ?
03:37:08 <jeffz`> pk, yes it could be a property of the shapes you have defined
03:37:48 <sleven> *Matrix List> :t DA.assocs
03:37:49 <sleven> DA.assocs :: (DA.Ix i) => DA.Array i e -> [(i, e)]
03:37:55 <sleven> *Matrix List> DA.assocs a 0 5.0
03:37:55 <sleven> <interactive>:1:0:
03:37:55 <sleven>     Couldn't match expected type `t1 -> t2 -> t'
03:37:55 <sleven>            against inferred type `[(Int, Integer)]
03:38:14 <cajun-rat> @pl  \compare -> \f -> \a -> \b -> compare (f a) (f b)
03:38:14 <lambdabot> join . ((flip . ((.) .)) .) . (.)
03:38:20 <pk> jeffz', I'll look that way then, thx
03:38:32 <vixey> :t \f -> \a -> \b -> compare (f a) (f b)
03:38:33 <lambdabot> forall t a. (Ord a) => (t -> a) -> t -> t -> Ordering
03:38:35 <vixey> :t comparing
03:38:36 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
03:38:46 <vixey> @src on
03:38:47 <lambdabot> (*) `on` f = \x y -> f x * f y
03:39:49 <cajun-rat> thanks :)
03:40:34 <quicksilver> sleven: assocs takes 1 parameter
03:40:36 <quicksilver> sleven: (an array)
03:40:39 <quicksilver> you gave it three
03:41:09 <pk> jeffz', my polys were defined in the wrong order
03:41:16 <pk> jeffz', works fine now
03:41:20 <pk> jeffz', thx a lot
03:42:25 <sleven> parse error on inpuy Data.Array.//
03:42:30 <sleven> how do I use that one?
03:42:38 <sleven> and whtas the point of assocs?
03:42:47 <jeffz`> pk, good :)
03:45:08 <sleven> but what does it do with that ?
03:45:13 <sleven> i is the same array that coems out...
03:45:17 <sleven> anyway
03:45:40 <sleven> parse error on inpuy Data.Array.//
03:45:40 <sleven> ?
03:45:40 <sleven> i want to update the array at index x
03:49:03 <kowey> what's a better name / implementation for this function? groupByAndKey :: (a -> b) -> [a] -> [ (b,[a]) ] ; groupByAndKey f = map (\xs -> (f $ head xs, xs)) . groupBy f
03:49:15 <kowey> just seems so icky (note this was pen and paper impl; could be wrong)
03:49:17 <lilac> > listArray (1,5) [11..15] // [(3,42)] -- slevin
03:49:19 <lambdabot>   array (1,5) [(1,11),(2,12),(3,42),(4,14),(5,15)]
03:50:19 <lilac> kowey: buildReverseMap ?
03:50:29 <gds> kowey: bucketify? :)
03:50:39 <RayNbow> > listArray (1,5) [11..15] Data.Array.// [(3,42)]   -- no parse error?
03:50:40 <lambdabot>   array (1,5) [(1,11),(2,12),(3,42),(4,14),(5,15)]
03:50:49 <kowey> gds: hehe :-)
03:51:12 <RayNbow> > Data.Array.(//) (listArray (1,5) [11..15]) [(3,42)]   -- prefix
03:51:13 <lambdabot>       Failed to load interface for `Data':
03:51:13 <lambdabot>        Use -v to see a list of the...
03:51:15 <kowey> i wish some commonly used list or collection library had a function like this
03:51:15 <Graw> hello
03:51:16 <RayNbow> hmm
03:51:44 <RayNbow> > (Data.Array.//) (listArray (1,5) [11..15]) [(3,42)]   -- second prefix attempt
03:51:46 <lambdabot>   array (1,5) [(1,11),(2,12),(3,42),(4,14),(5,15)]
03:52:05 <lilac> kowey: is there nothing like that in Data.Map?
03:52:08 <Graw> lil help: i'm doing a haskell tutorial and i'm supposed to enter the line "doubleMe x = x + x", but it gives me a "parse error on '='"
03:52:26 <lilac> Graw: are you entering that line in ghci?
03:52:39 <Graw> yes
03:52:48 <kowey> fine... buckets :: (a -> b) -> [a] -> [(b,[a])] ; buckets = map (\xs -> f (head xs), xs) . groupBy ((==) `on` f) . sortBy (compare `on` f)
03:53:19 <lilac> Graw: that's the problem. the easiest solution is probably to add the word 'let' to the start
03:53:21 <vixey> :t map (\xs -> f (head xs), xs) . groupBy ((==) `on` f) . sortBy (compare `on` f)
03:53:22 <lambdabot> Not in scope: `xs'
03:53:33 <vixey> :t map (\xs -> (f (head xs), xs)) . groupBy ((==) `on` f) . sortBy (compare `on` f)
03:53:34 <lambdabot>     Ambiguous type variable `b' in the constraints:
03:53:34 <lambdabot>       `SimpleReflect.FromExpr b'
03:53:34 <lambdabot>         arising from a use of `f' at <interactive>:1:52
03:53:40 <vixey> :t \f -> map (\xs -> (f (head xs), xs)) . groupBy ((==) `on` f) . sortBy (compare `on` f)
03:53:41 <lambdabot> forall a b. (Ord b) => (a -> b) -> [a] -> [(b, [a])]
03:53:43 <kowey> lilac: I suppose I could do something like buckets = Map.toList . Map.fromListWith (++) . map (\x -> k x, x)
03:54:00 <Graw> lilac: it works! thx.
03:54:00 <kowey> err, something needs to be singletoned there \x -> [x]
03:54:22 <sleven> but do I have to reconstruct the matrix each time I manipulate its  type?
03:54:25 <kowey> also the Data.Map.Map of lists of x seems like something that should be a common idiom
03:54:43 <sleven> am I thinking to much in terms of C++ and Java type encapsualtion ?
03:55:09 <gds> Graw: When you come to write a program in your text editor (rather than straight into ghci), you'll want to omit that "let" - it's only for in ghci.
03:55:14 <Graw> ok
03:56:18 <Graw> i'm still trying to wrap my head around the syntax (i'm a Ruby coder)
03:59:35 <kowey> random chit-chat: suggestions for broadening this perpetual-novice Haskell-fan's mind? i'm thinking one of : erlang, smalltalk, tom, mercury, coq, more haskell
04:01:09 <BONUS> theres always more haskell concepts to learn :]
04:01:41 <kowey> yeah! especially since I've never gotten far beyond the write-your-own-monad-tutorial-(fallacy-inside) phase
04:01:50 <kowey> i find my Haskell fandom disturbing though
04:04:24 <BONUS> i thought about learning some new languages after haskell but they all seem pretty boring compared to haskell
04:04:26 <BONUS> maybe erlang
04:04:47 <kowey> tom might be interesting for all that rewriting stuff (icky java, though)
04:05:05 <kowey> maybe Oz (or wait for a Haskell binding to GECODE?)
04:05:35 <ogex> is it possible to define "data Foo a = Bar a a a" as "data Foo = a +++ a +++ a" ? (some kind of ternary infix as constructor)?
04:05:47 <vixey> ogex, no
04:05:59 <BONUS> binary infix constructors only
04:07:01 <Graw> best explanation ever http://learnyouahaskell.com/listmonster.png
04:07:09 <BONUS> :]
04:07:12 <ogex> what is the reason for disallowing ternary (and more)?
04:07:35 <BONUS> i guess it would make the grammar really complicated
04:08:24 <tjb> Another bug in Word128?
04:08:30 <tjb> ghci> showHex (toInteger(shiftR h 0)) ""
04:08:30 <tjb> "102030405060708090a7e7e7e7e7e7e"
04:08:30 <tjb> ghci> showHex (toInteger(shiftR h 8)) ""
04:08:30 <tjb> "102030405060700090a7e7e7e7e7e"
04:08:51 <quicksilver> kowey: erlang if you want some different
04:09:02 <tjb> Word128 is composed of: Word64 Word64
04:09:05 <quicksilver> kowey: coq if you want something in the same vein as haskell but a slightly different direction.
04:09:19 <sleven> if i want to have an automatic show for data Matrix
04:09:25 <vixey> quicksilver, you are kidding ?
04:09:27 <tjb> and the bit shifts don't seem to take into account the Word64 boundaries
04:09:30 <sleven> then it should be a string with a newline after each row?
04:09:45 <quicksilver> tjb: looks like it. Where is the source?
04:09:50 <sleven> like: "[1,2,3]\n[4,5,6]\n" ?
04:10:00 <tjb> quicksilver: for Word128?
04:10:04 <quicksilver> tjb: *nod*
04:10:20 <kowey> quicksilver: I'm not sure what I want really... just trying to invest in the future... pick up skills and keep my brain supple (as if it ever was)
04:10:30 <tjb> quicksilver: Looking -- either Data.LargeWord or Codec.Encryption.AES
04:10:55 <kowey> so I guess I need to look for something with a good brain-twisting-bang for difficulty-learning buck
04:11:01 <quicksilver> tjb: http://hackage.haskell.org/packages/archive/Crypto/4.1.0/doc/html/src/Data-LargeWord.html
04:11:04 <quicksilver> presumably.
04:11:53 <tjb> quicksilver: looks like it.  Guess a modification is in order
04:12:04 <sleven> how can I turn a list into string?
04:12:16 <BONUS> list of what
04:12:25 <BONUS> > show [1,2,3,4]
04:12:26 <lambdabot>   "[1,2,3,4]"
04:12:32 <BONUS> > concat ["hey","ahah"]
04:12:33 <lambdabot>   "heyahah"
04:13:07 <quicksilver> sleven: show? map show? unwords? unlines?
04:13:10 <quicksilver> lots of ways ;)
04:14:11 <quicksilver> tjb: must be a bug in largeWordShift
04:14:45 <Graw> haha, "drop [1..]" is not a good thing
04:15:03 <Graw> *drop 1 [1..]
04:15:24 <tjb> quicksilver: that's what I'm looking at.  Need the source to either "shift" or "conv"...
04:15:32 <quicksilver> tjb: conv is defined there inline.
04:15:38 <quicksilver> tjb: shift is a method of Data.Bits
04:15:44 <quicksilver> so it's using the shift method on Word64
04:15:47 <quicksilver> (in this precise case)
04:15:55 <vixey> hi byorgey_
04:16:21 <kowey> (thanks for advice!)
04:16:37 <tjb> quicksilver: ah, yes -- but not taking into account a shiftL in "hi" will require an .|. from "lo"
04:17:04 <quicksilver> tjb: but your bug was with a shiftR?
04:17:32 <quicksilver> ah.
04:17:33 <tjb> quicksilver: hmm -- let me check again.  I'm guess both shiftL and shiftR will have problems
04:17:34 <quicksilver> positive is left.
04:17:48 <quicksilver> that definition is largeword only works for postive (left) shifts, I bet.
04:17:54 <quicksilver> it doesn't cope with right shifts
04:18:16 <tjb> quicksilver: you are right -- only right shifts
04:18:49 <quicksilver> tjb: note that LargeKey is store least-significant-chunk first
04:19:03 <quicksilver> so a "left" shift shifts from "lo" to "hi"
04:19:13 <quicksilver> in contrast to expected meaning of 'left'
04:19:23 <quicksilver> LargeKey lo hi
04:19:39 <tjb> quicksilver: hm, interesting
04:19:49 <quicksilver> so your insight was correct.
04:19:50 <sleven> now I have [[1,2,3],[4,5,6]] and I want to make it show instance for the data Matrix
04:20:01 <quicksilver> it only copes with shifting "across" the boundary.
04:20:06 <quicksilver> in one direction
04:20:08 <quicksilver> and not the other.
04:20:13 <quicksilver> from lo to hi (left) it can do
04:20:17 <quicksilver> from hi to lo (right) it does not.
04:20:30 <tjb> quicksilver: correct, that is behavior I'm seeing
04:20:41 * quicksilver nods
04:20:45 <sleven> http://hpaste.org/13986
04:21:12 <quicksilver> sleven: printMatrix2 should not be in a do block.
04:21:34 <quicksilver> and it's missing a 'show'
04:21:39 <beelsebob> and an in
04:22:20 <tjb> quicksilver: looks like a few module update are in order :)
04:23:58 <beelsebob> sleven: http://hpaste.org/13986#a1
04:24:15 <quicksilver> tjb: you could add quotRem to the Num instance while you're at it :)
04:25:00 <tjb> quicksilver: good excuse to learn what quotRem is I guess ;)
04:25:53 <sleven> "[0.0,0.0,0.0] [0.0,0.0,0.0] [0.0,0.0,0.0]"
04:26:00 <sleven> ok can I add so it newlines it?
04:26:09 <dcoutts> hugo___: to find out if packages need updating, do cabal update first and then for a particular package, use cabal list pkgname.
04:26:22 <dcoutts> hugo___: that tells you the latest version installed and available
04:26:51 <tjb> quicksilver: thanks for the help again.  Off to get ready for the "real" job.  On a side note, what timezone are you in quicksilver?
04:27:04 <sleven> instance Show (Matrix repr r c) where show m = printMatrix2 m
04:27:12 <sleven> yey it works
04:27:13 <sleven> but i should add newline?
04:29:02 <sleven> http://hpaste.org/13987
04:30:03 <hugo___> allright, thanks dcoutts
04:30:31 <quicksilver> sleven: you shouldn't really use show for this at all.
04:30:35 <quicksilver> it's not what 'show' is for :)
04:30:46 <quicksilver> but it's your code it's up to you if you add newlines :)
04:30:56 <sleven> can nstance Show not take an if?
04:31:08 <quicksilver> certainly it can.
04:31:17 <quicksilver> you can put any expression into your show definition
04:31:19 <quicksilver> including ifs.
04:31:43 <hugo___> i was wondering about a good way to do list unrolling, like for instance, suppose there is f :: [Attribs] and d :: [Attribs], and i want to find a way to do f = [attr1, attr2, d, attr3, attr4, ... ], anyone knows how ?
04:32:49 <quicksilver> hugo___: how do you know where to insert the d ?
04:32:57 <quicksilver> hugo___: always after the second element?
04:33:05 <hugo___> nopes, but in the middle
04:33:20 <hugo___> it depends, d can be used anywhere in the list... thats the idea
04:34:27 <hugo___> i have f::[Attrib], and a::Attrib, b::Attrib, c::[Attrib], d::Attrib, and i want to do f = [a, b, c, d] or whatever combination
04:34:29 <quicksilver> hugo___: I don't understand at all.
04:34:46 <quicksilver> hugo___: f = [a,b] ++ c ++ [d] ?
04:34:55 <hugo___> that ruins it :(
04:35:07 <hugo___> its ugly
04:35:22 <hugo___> ill change my datatype then
04:35:24 <hugo___> its preferable
04:35:45 <sleven> quicksilver: http://hpaste.org/13987#a1
04:35:45 <mm_freak> does darcs work well for large binary files?
04:36:37 <quicksilver> sleven: because that's what unwords does.
04:36:41 <quicksilver> sleven: unwords puts spaces in.
04:36:54 <quicksilver> > unwords ["app","le"]
04:36:55 <lambdabot>   "app le"
04:37:05 <quicksilver> sleven: if you don't want spaces use concat instead of unwords.
04:38:46 <hugo___> can i define a comma operator in haskell ?
04:38:51 <mm_freak> or intercalate, if you want an arbitrary string
04:39:03 <quicksilver> hugo___: no. comma is special.
04:39:11 <hugo___> can i overwrite it ?
04:39:12 <mm_freak> > let (,) = (.) in 3 , 4
04:39:13 <lambdabot>   <no location info>: parse error on input `,'
04:39:20 <quicksilver> hugo___: no.
04:39:22 <mm_freak> uhm, s/./+/
04:39:23 <quicksilver> no means no :)
04:39:46 <hugo___> ok ok
04:39:47 <hugo___> :)
04:40:09 <quicksilver> it's not really an operator, although the syntax (,) looks like it is.
04:40:30 <quicksilver> [1,2,3] and (1,2,3) are completely different syntactical things.
04:41:00 <SamB_XP> and (1,2,3) invokes (,,) anyway
04:41:15 <quicksilver> yup.
04:41:21 <sbahra> > (,) 1 2
04:41:22 <lambdabot>   (1,2)
04:41:47 <vixey> > let f ((,,) x y z) = x + y + z in  f (4,3,6)
04:41:48 <lambdabot>   13
04:43:07 <joma> quicksilver: if I shouldnt use show for what I'm doing then what should I use?
04:43:24 <hugo___> hehe
04:43:37 <hugo___> nice foo vixey :)
04:45:37 <ogex> so (,...,) is an infix constructor and defined for arbitrary large number  of commas?
04:45:46 <vixey> up to some limit
04:45:54 <hugo___> can i use it on a list ?
04:46:16 <joma> and where are 2dimensional arrays?
04:46:18 <ogex> why not allow n-ary infix constructors up to the same limit for arbitary notation?
04:46:26 <opqdonut> joma: just use (Int,Int) as the index type :)
04:46:51 <hugo___> i have this: [a, a, a, [a, a, a], a, a] and i want it to become [a, a, a, a, a, a, a, a] :P
04:46:52 <opqdonut> hugo___: not easily
04:47:05 <opqdonut> the first one is not a list
04:47:13 <opqdonut> or not a well-typed one, at least
04:47:21 <hugo___> is there any function like "unwrapList", so i could do it [a, a, a, unwrapList [a, a, a], a, a, a] ?
04:47:29 <opqdonut> > {
04:47:30 <lambdabot>   <no location info>: parse error on input `{'
04:47:31 <opqdonut> gah
04:47:43 <opqdonut> > concat [[1,2,3],[4,5,6],[1]]
04:47:44 <lambdabot>   [1,2,3,4,5,6,1]
04:48:38 <hugo___> yes :(
04:48:48 <hugo___> it does not suit me
04:49:00 <hugo___> because i have a [a], not a [[a]]
04:49:19 <hugo___> all my functions return a, instead of [a] :(
04:50:20 <opqdonut> hugo___: just use ++ then?
04:50:41 <hugo___> it destroys the beautifull sintax of my code :/
04:51:17 <opqdonut> well if you want beautiful syntax then use concat and wrap the functions that return non-lists
04:51:29 <gds> > "a" : "b" : "c" ++ ["d","e","f"]
04:51:29 <SamB_XP> sintax is evil
04:51:30 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
04:51:38 <gds> Oops...
04:51:43 <gds> > "a" : "b" : "c" : ["d","e","f"]
04:51:45 <lambdabot>   ["a","b","c","d","e","f"]
04:51:52 <hugo___> okey
04:51:58 <gds> > "a" : "b" : "c" : ["d","e","f"] ++ ["g"]
04:51:59 <lambdabot>   ["a","b","c","d","e","f","g"]
04:52:00 <hugo___> ill use the ':' arround the functions
04:52:06 <hugo___> it will work, im sure ! :D
04:52:43 <joma> is there no way to hack haskell to allow assignment in ghci ? like in clojure(lisp) i normally have set-something! like functions for testing so I dont have to do the whole let y = do something to x then let z = do something to y
04:52:53 <opqdonut> no
04:53:00 <opqdonut> you can rebind a name with let
04:53:06 <opqdonut> inside a do block or in ghci
04:53:08 <opqdonut> but that is all
04:53:26 <quicksilver> joma: something else, with a different name. like 'pretty print'
04:53:34 <joma> quicksilver: "what people sometimes do is make a version of the natural numbers in the type system, to do this." what do you mean here ? i missed this before
04:53:35 <opqdonut> indeed
04:54:19 <quicksilver> joma: data Zero = Zero; data Succ a = Succ a;
04:54:31 <quicksilver> type Two = Succ (Succ (Zero))
04:55:59 <vixey> type Two' = Maybe (Maybe ()) sometimes useful
04:57:14 <quicksilver> for a more detailed approach, try http://hackage.haskell.org/cgi-bin/hackage-scripts/package/type-level
04:57:56 <quicksilver> or the paper "Faking it : simulated dependent types in haskell"
04:58:52 <joma> quicksilver: why? i want when i do in ghci> m then if m is a Matrix it should be printed out, i dont want to call prettyPrint m
04:59:18 <quicksilver> joma: you may think that's what you want, but you're wrong.
04:59:23 <joma> why?
04:59:31 <quicksilver> because that is not the purpose of the Show class.
04:59:36 <joma> and then i want if sizeof m bigger than say 20*20
04:59:41 <quicksilver> the purpose of the Show class is to produce haskell syntax output
04:59:45 <joma> then only rpint part of it or nothing
04:59:47 <SamB_XP> joma: how about calling it pp instead
04:59:54 <quicksilver> which can be copy-pasted into test cases, error reports, and so on.
04:59:56 <joma> then what is the purpose of it?
05:00:10 <quicksilver> by the way, I don't think this is particularly important.
05:00:15 <quicksilver> no one is going to shoot you for misusing show.
05:00:20 <SamB_XP> indeed
05:00:24 <quicksilver> But, I'm just telling you so you know that's not what it's for.
05:00:43 <SamB_XP> but I personally would suggest using a pretty-printing library of some kind if you want 2D output ;-P
05:00:52 <hugo___> how do i see the precedence of an operator ?
05:00:57 <SamB_XP> and making yourself a pretty class
05:01:00 <SamB_XP> hugo___: :i in GHCi
05:01:04 <hugo___> okey
05:01:10 <joma> true
05:01:10 <joma> ok
05:01:10 <joma> thanks i appreicate it
05:01:14 <hugo___> hmm
05:01:16 <hugo___> and for functions ?
05:01:23 <hugo___> what are the precedence of function application ?
05:01:33 <SamB_XP> you mean like "f x" ?
05:01:38 <hugo___> yes
05:01:40 <SamB_XP> that's the, er, tightest
05:02:01 <hugo___> so, like the maximum value possible ?
05:02:18 <joma> so to use show correctly I would just derive show?
05:02:18 <joma> Matrix {matrix = array (0,8) [(0,0.0),(1,0.0),(2,0.0),(3,0.0),(4,0.0),(5,0.0),(6,0.0),(7,0.0),(8,0.0)], rows = 3, cols = 3}
05:02:18 <joma> for example
05:02:18 <joma> but where can I find 2Darrays?
05:02:31 <SamB_XP> joma: hmm ?
05:03:05 <SamB_XP> hugo___: I can't remember what high values mean at the moment :-)
05:03:06 <hugo___> for f :: Int -> [Int], i could do f 1 ++ [123], and it would work like (f 1) ++ [123], since (++) has infixr 5, right ?
05:03:46 <SamB_XP> in that example it doesn't really matter what (++) has
05:03:57 <quicksilver> joma: 2D arrays are just 1D arrays where you use a tuple for the index.
05:03:58 <hugo___> hmm because f only takes one argument
05:04:07 <hugo___> lunch time, bye :*
05:04:10 <quicksilver> > listArray ((0,0),(1,1)) [1..4]
05:04:11 <lambdabot>   array ((0,0),(1,1)) [((0,0),1),((0,1),2),((1,0),3),((1,1),4)]
05:04:15 <SamB_XP> more like because you don't have any other operators
05:04:24 <quicksilver> joma: I would call that 2D because its index is a 2-tuple.
05:04:25 <quicksilver> handy.
05:04:35 <quicksilver> underneath, it's 1D really. The array library does index translation.
05:06:32 <jideel> Hello
05:06:44 <jideel> Is there a specific chan for newbies ?
05:06:58 <quicksilver> jideel: newbies are most welcome here :)
05:07:04 <jideel> Thanks
05:07:07 <Stinger_> #visualbasic? *rimshot*
05:07:20 <jideel> a long time ago
05:07:32 <Stinger_> in a galaxy far far away
05:07:37 <jideel> yep
05:07:51 <SamB_XP> what would the point of a special channel for newbies be ?
05:08:18 <jideel> Well, syntax explanation :)
05:08:21 <SamB_XP> then there'd be no ... er ... whatever we are ... to help 'em out
05:08:48 <blackh> People in this channel are too logical, by far.
05:08:54 <Saizan> i guess it'd be open only when Cale is online :)
05:08:56 <SamB_XP> hehehe
05:09:12 <jideel> Initially i was looking for the french channel, but it doesn't seems to exists anymore
05:09:17 <jideel> so i ended up here
05:09:39 <Peaker> how come noone told hugo___ is list is ill typed?
05:11:05 <joma> quicksilver: and all indexing operations are O(1)?
05:12:26 <jideel> So, does anybody has pointers/links about syntax reference ? Something like " -> means ...", "-< means ...", "=> means ..." (ok i think i understood what -> was meant for :) )
05:12:51 <lilac> Peaker: opqdonut did
05:13:22 <SamB_XP> jideel: -< is some kind of arrow notation ...
05:13:22 <Badger> hmm
05:13:27 <Badger> I can has bitmasks?
05:13:29 <SamB_XP> at least, sometimes it is!
05:13:38 <SamB_XP> @faq Badger can has bitmasks ?
05:13:38 <lambdabot> The answer is: Yes! Haskell can do that.
05:13:45 <Badger> :)
05:13:52 <SamB_XP> what do you want 'em for ?
05:14:03 <Badger> imperative programming!
05:14:05 <Badger> I mean
05:14:15 <Badger> states, I suppose
05:14:21 <Peaker> jideel: <- is do/comprehension syntax for binding a monadic result into an argument.  -> is case/lambda syntax.  => means "implies".  -< is proc do (arrow) notation
05:14:22 <Badger> attributes
05:14:27 <blackh> Badger: Data.Bits!
05:14:37 <Badger> :D
05:14:41 <SamB_XP> Badger: you could consider using a UArray of Bool
05:14:51 <Badger> SamB_XP: perhaps I could
05:14:55 <SamB_XP> with an enumeration type for indexes
05:15:08 <joma> http://hpaste.org/13988
05:15:16 <jideel> Is there some kind of document referencing all these meanings ?
05:15:17 <joma> how do I declare that?
05:15:29 <joma> data Matrix and it has a variable of type listArray
05:15:37 <SamB_XP> jideel: the Report will tell you about -> and <-
05:15:40 <jideel> I thougt => was meant for type restriction
05:15:43 <SamB_XP> @where arrow
05:15:43 <lambdabot> I know nothing about arrow.
05:15:46 <SamB_XP> @where arrows
05:15:46 <lambdabot> http://www.haskell.org/arrows/
05:15:49 <blackh> jideel: The Haskell 98 report - I don't know of anything else.
05:15:53 <SamB_XP> that will tell you about arrow notation
05:16:00 <SamB_XP> if you care/dare
05:16:07 <blackh> jideel: Yes, => is type restriction
05:16:40 <jideel> thanks for the link
05:16:49 <SamB_XP> jideel: personally I'm not sure I like arrow notation
05:17:01 <SamB_XP> in fact, I think I don't
05:17:29 <jideel> It 's a kind of shortcut for "proc do" ?
05:17:44 <SamB_XP> it's a thing you use in proc do
05:17:57 <jideel> hum
05:19:02 <jideel> It looks like a great language, but is it possible to handle it without a strong maths background ? I mean, "normal" math capabilities...
05:19:18 <blackh> jideel: Definitely yes.
05:19:30 <jideel> Every documentation i read tends to go to some math theories after a while
05:20:17 <blackh> jideel: That's just because of the background of the people writing it.
05:20:25 <vixey> jideel, such as?
05:20:57 <vixey> To be quite honest it's impossible to write good programs without a very strong foundation in math
05:21:06 <opqdonut> in any language :)
05:21:17 <vixey> You probably noticed .. a lot of people don't but they write programs anyway.. and that's the why the OS you use crashes
05:21:19 <SamB_XP> but it is possible to aquire one
05:21:53 <joma> quicksilver: how do you mean I get and set at index (row,col) then?
05:21:55 <sbahra> :-/
05:22:19 <sbahra> vixey, there are many systems engineers without a "very strong foundation in math" who produce high quality software.
05:22:44 <sbahra> jideel, yes. It is. :-)
05:22:46 <joma> sbahra: and with strionger math skills they'd produce even better
05:23:05 <sbahra> joma, not necessarily. :-)
05:23:20 <jideel> Well, i think i've got an "average" math background, bot not a _strong_ one
05:23:48 <blackh> jideel: I've got an "average" maths background too, and I had no trouble learning it.
05:24:02 <sbahra> joma, in fact, people who put too much faith in formal models may sometimes make the wrong decision about the common case/real world.
05:24:23 <blackh> jideel: Haskell is actually a very simple design, but it gives a huge amount of power.
05:24:36 <DMKE> how can i create an infinite list of incrementing Integers? i experienced with repeat but that does no incement on the elements...
05:24:54 <sbahra> [1,2 ..]
05:24:59 <DMKE> thx
05:25:12 <vixey> DMKE:
05:25:12 <vixey> > iterate (+1) 0
05:25:13 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
05:25:14 <vixey> or
05:25:15 <blackh> jideel: In my opinion, Haskell is no more difficult than any other language, but the important thing is that it is quite different to most other languages.  This is the thing that makes it *seem* difficult.
05:25:16 <vixey> > [1..]
05:25:17 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
05:25:47 <sbahra> DMKE, check this out.
05:25:54 <sbahra> > [1, 10 ..]
05:25:55 <lambdabot>   [1,10,19,28,37,46,55,64,73,82,91,100,109,118,127,136,145,154,163,172,181,19...
05:26:14 <DMKE> thats great :-)
05:26:23 <jideel> @vixey: sorry, no links right now, but that's how i felt while trying to learn the language
05:26:23 <lambdabot> well, i can't stop you
05:26:39 <sbahra> @yow
05:26:39 <lambdabot> I want you to organize my PASTRY trays ... my TEA-TINS are gleaming in
05:26:39 <lambdabot> formation like a ROW of DRUM MAJORETTES -- please don't be FURIOUS with me --
05:26:58 <vixey> jideel, ok
05:27:17 <vixey> jideel, in any case you can write broken crap in haskell /easier/ than other languages :)  (I know this from experience)
05:28:15 <joma> sbahra: sure but then they are not good mathematicians, they just do the number siwhtout thinking whta it means to do those numbers
05:28:22 <blackh> I don't agree at all that it's easy to write broken crap in Haskell.
05:28:36 <vixey> blackh, I've been doing it for ages
05:28:43 <jideel> Of course :) I started to look at the language for a while now, but there's some "steps" in the learning curve, that's why i try a bit, then goes back to Python/Java/... , and then goes back to Haskell, and learn a bit more, etc....
05:28:47 <BONUS> isnt perl the champion in that area
05:28:50 <sbahra> joma, or they don't have the experience to understand the dynamics of their target architectures. :-)
05:29:04 <blackh> vixey: Can you elaborate?
05:29:30 <vixey> BONUS, my point is really that it's easy in any setting (perl, haskell.. whatever).. and that haskell isn't harder and doesn't require "math" to use it how you use other languages
05:29:32 <sbahra> joma, mathematics does not shine in highly complex concurrent systems such as operating systems. :-)
05:29:44 <sbahra> joma, formal verification is on its way (but it isn't ready for real world).
05:29:59 <vixey> sbahra, where did you hear that FUD?
05:30:01 <joma> i think haskell enocurages good software design, pushes you in the right direction
05:30:06 <BONUS> vixey: yeah, i agree there
05:30:13 <sbahra> vixey, I didn't hear that FUD, I experienced it. :-)
05:30:29 <vixey> sbahra, so replace 'real world' with 'me'
05:30:32 <sbahra> vixey, tell me, how would you formally verify some concurrent kernel module in Linux?
05:30:55 <Peaker> vixey: where is formal verification, agda/coq style used in the "real world"?
05:30:56 <vixey> just because you found something difficult that doesn't mean it isn't possible.
05:31:01 <sbahra> vixey, this conclusion is not unique to me. Not everyone is using languages which are easy to verify (and writing programs which are easy to model).
05:31:06 <sbahra> vixey, did I say it isn't possible? :-)
05:31:10 <sbahra> vixey, please show me where.
05:31:39 <asgaroth> Is there any more shorthand way of writing `modify $ \c -> c { someField = f (someField c) }' ?
05:31:39 <sbahra> vixey, in fact, authors of most formal verification systems I've seen/used have a clear disclaimer about this whole ordeal.
05:32:40 <jideel> Another newbie question : when to use "." and when to use "$" ? If i understood well, "$" is to avoid default function precedence, and "." is for "function linking" or "curryfication" ? Let's say i want to apply an upper case function after having md5ized a string, in some others language, i would do something like "string".md5().toUpperCase(), does the "." means the same thing ?
05:32:57 <BONUS> no, not at all
05:32:58 <vixey> jideel, no about (.), it's composition
05:33:06 <BONUS> basically if you write
05:33:10 <sbahra> vixey, please show me where I said it isn't possible.
05:33:14 <BONUS> foo (bar (baz x))
05:33:18 <BONUS> you can write it as
05:33:24 <BONUS> foo $ bar $ baz $ x
05:33:27 <BONUS> but it's better to write it as
05:33:30 <BONUS> foo . bar . baz $ x
05:33:36 <asgaroth> jideel: (f . g) x === f (g x)
05:33:41 <asgaroth> just like from mathematics
05:33:47 <vixey> hahaha
05:33:55 <jideel> :)
05:34:04 <BONUS> so if you have foo . bar . baz, that's a function that takes what baz takes, gives it to bar and then bar produces a result and gives it to foo, which produces the final result
05:34:28 <jideel> so what is the "$" meant for ?
05:34:31 <vixey> just read (.) as 'of'
05:34:35 <vixey> foo of bar of baz of ..
05:34:41 <asgaroth> jideel: It's just function application
05:34:43 <asgaroth> @src ($)
05:34:44 <lambdabot> f $ x = f x
05:34:45 <opqdonut> jideel: for avoiding parenthesis
05:34:48 <BONUS> $ is just function application f $ x is like f x, the thing is that it has low precedence
05:34:48 <mapreduce> baz >>> bar >>> foo does the same thing the other way around, and is often more readable.
05:34:58 <lunabot>  luna: Not in scope: `is'
05:35:10 <BONUS> so you can think of $ as kind of extending parens all the way to the left and right
05:35:23 <BONUS> foo (bar baz x) is equal to foo $ bar baz x
05:36:12 <joma> if i have a data X a = X a, how do I easiest retrieve thw a?
05:36:20 <jideel> hum, think i have to try to really get it...
05:36:22 <opqdonut> joma: pattern match
05:36:41 <Peaker> joma: you can use:  data X a = X { unX :: a }
05:36:43 <opqdonut> f :: X a -> Something; f (X a) = something a
05:36:46 <BONUS> jideel: check out this section and the one after it http://localhost/haskelltut/higher-order-functions#function-application
05:36:47 <opqdonut> or then that
05:36:48 <asgaroth> joma: pattern match or put define it as a record as in data X a = X { val :: a }
05:36:49 <blackh> jideel: Let's say you have a function like this: increment x = x + 1, you can apply it like this:
05:36:49 <BONUS> whoops
05:36:52 <BONUS> i mean
05:36:58 <vixey> aOf (X a) = a
05:37:05 <BONUS> http://learnyouahaskell.com/chapters/higher-order-functions#function-application
05:37:11 <blackh> jideel: increment 10    <-- this will give you 11
05:37:14 <asgaroth> Is there any more shorthand way of writing `modify $ \c -> c { someField = f (someField c) }' ?
05:37:21 <blackh> jideel: (increment . increment) 10  <-- this will give you 12
05:37:36 <blackh> jideel: Or...  increment . increment $ 10
05:37:58 <jeffz`> asgaroth: you might write a function which takes data constructors parameterised by functions which take the field value as input and the new value as output, collect a list of these and then apply them to the record in a fold.
05:38:08 <jideel> ok :)
05:38:22 <jeffz`> I don't know if it's really shorthand, but it seems more organised to me.
05:38:49 <opqdonut> asgaroth: just make a mapfield function
05:39:06 <opqdonut> a nicer solution is functional references
05:39:15 <jideel> Is there a difference with " increment $ increment $ 10 " ?
05:39:26 <opqdonut> jideel: semantically, no
05:39:40 <blackh> jideel: increment $ increment $ 10  means exactly the same as  increment . increment $ 10
05:39:41 <asgaroth> opqdonut: Ok, but I have to do this individually for each type, right? Records aren't automatically instance of some typeclass that provides this, right?
05:39:42 <opqdonut> jideel: increment . increment $10 is considered better style
05:39:50 <opqdonut> asgaroth: yeah
05:40:00 <opqdonut> asgaroth: if you want automation and genericity, go for functional references
05:40:04 <opqdonut> ?where FRef
05:40:04 <lambdabot> I know nothing about fref.
05:40:09 <opqdonut> ?google FRef
05:40:10 <lambdabot> No Result Found.
05:40:12 <opqdonut> gah
05:40:18 <blackh> jideel: . is for composing functions that take _one_ argument
05:40:20 <jideel> Hum, best practice for readability ?
05:40:22 <sbahra> vixey, why are you such a prick?
05:40:51 <opqdonut> http://www.haskell.org/pipermail/haskell-cafe/2008-April/042193.html <- that might be a starting place
05:40:57 <opqdonut> asgaroth: ^
05:41:00 <BONUS> lol, what the heck
05:41:02 <vixey> sbahra, that doesn't belong in #haskell but don't bother PMing me because I don't want to hear it
05:41:03 <asgaroth> opqdonut: Thanks, I'll look into it
05:41:41 <joma> wtf
05:41:41 <joma> isnt ListArray n Data.Array?
05:41:52 <sbahra> vixey, I wouldn't bother to PM you. :-) I think many people are curious, not just me.
05:41:59 <sbahra> vixey, but yes, you're right. It isn't on topic. :)
05:42:43 <joma> quicksilver: you meant listArray right?
05:42:50 <joma> i still dont get how to 2d-index it
05:42:52 <vixey> sbahra, stop using ":-)" smiley faces at me
05:43:05 <BONUS> joma: you can use tuples for the indices
05:43:08 <sbahra> vixey, no. You may add me on ignore. :-)
05:43:17 * Workybob ponders if people need to take a chill pill
05:43:17 <jideel> hum, ok. What i find very frustrating is that, if i read a source code example, at the first sight, i think "ok, i understood what this code does", but after looking at the details, there's some instructions i simply don't understand...
05:43:25 <Workybob> this is the first time I've ever seen #haskell get unfriendly
05:43:31 <opqdonut> sbahra, vixey: please...
05:43:37 <vixey> this is my fault?
05:43:42 <sbahra> Totally.
05:43:47 <Workybob> vixey: in part, yes, and in part sbahra
05:43:53 <Workybob> so... hush!
05:43:53 <BONUS> > listArray ((0,0),(2,2)) [1,2,3,4,5,6]
05:43:55 <lambdabot>   array ((0,0),(2,2)) [((0,0),1),((0,1),2),((0,2),3),((1,0),4),((1,1),5),((1,...
05:43:55 <vixey> Workybob, what did I do?
05:44:00 <sbahra> Exist.
05:44:03 <Workybob> see PM...
05:44:04 <vixey> Workybob, seems to start with: <sbahra> vixey, why are you such a prick?
05:44:06 <BONUS> > (listArray ((0,0),(2,2)) [1,2,3,4,5,6]) ! (1,2)
05:44:07 <lambdabot>   6
05:44:23 <sbahra> vixey, if you weren't such a prick, maybe that question wouldn't have been raised? :-)
05:44:28 <sbahra> Anyways, sorry #haskell.
05:44:32 * sbahra goes back to work
05:44:33 <vixey> sbahra, you can stop... please...
05:44:33 <blackh> jideel: Haskell doesn't contain much actual syntax.  Most of it is functions.
05:45:04 <blackh> jideel: As you pointed out, you have to learn the syntax first before the rest makes sense.  . and $ are functions.
05:45:07 <Workybob> blackh: yeh, and you slowly realise that's wonderful, and get increasingly annoyed with things that aren't just functions
05:46:15 <joma> hmm if i want to use a haskell program from a python program, howd i do?
05:46:34 <joma> there are ways to communicate via systemargs right?
05:46:39 <blackh> Workybob: How many languages implement Exceptions completely outside the language, eh?
05:46:44 <joma> i can compile haskell to binaries?
05:46:50 <asgaroth> joma: You could compile it into an executable that takes some arguments
05:46:53 <Workybob> blackh: yeh, it's rather stunning, isn't it
05:46:54 <asgaroth> But not very flexible
05:47:02 <Workybob> otoh, it would be lovely for tuples not to be special
05:47:15 <Workybob> and in fact, lists, even without syntactic sugar, are a little special
05:47:24 <sbahra> Workybob, how so?
05:47:25 <BONUS> Workybob: how so?
05:47:31 <BONUS> heh
05:47:36 <Workybob> it's not possible to write the mixed-fix type def
05:47:51 <Workybob> data [a] = a : [a] | [] -- invalid
05:48:11 <BONUS> isnt that the syntactic sugar in action
05:48:29 <Workybob> oh, I see – misundarstanding at work
05:48:32 <blackh> joma: Yes, ghc will compile haskell to binaries.
05:48:43 <Workybob> by the "list syntactic sugar" I meant [a,b,c,d] sugaring a:b:c:d:[]
05:49:02 <BONUS> there's also some syntactic sugar in the types, yes
05:49:20 <BONUS> e.g. instance Class [] where and instance Class [a] where
05:49:27 <Workybob> well, is it syntactic sugar? at any level does the compiler convert list code to a valid type that we can write?
05:49:37 <blackh> Workybob: Stunning is exactly what it is! I don't mind the small amount of syntax that there is - it's much less than other languages.
05:49:43 <Workybob> I don't think any of the compilers do that
05:49:56 <Workybob> there's certainly no alternative syntax that I can actually use
05:50:00 <Workybob> so that's not syntactic sugar
05:50:04 <Workybob> it's just the language having a special case
05:50:15 <Workybob> (not a very major one, but still)
05:50:17 <BONUS> hmm, maybe
05:50:24 <BONUS> idk what the compiler does internally, but maybe it turns it to like
05:50:33 <BONUS> List a = End | Cons a (List a)
05:50:34 <asgaroth> Workybob: Well, couldn't you write a semantically equal definition with data Lst a = Nil | Cons (Lst a)
05:50:53 <Workybob> asgaroth: I *could* – but it wouldn't be the same type as [a] – [a] is not sugar for that type
05:50:59 <Workybob> it's a special magical type
05:51:14 <BONUS> it's isomorphic
05:51:20 <Workybob> yep, but not equal
05:51:35 <BONUS> yeah but i mean maybe the compiler turns it to that internally
05:51:51 <Workybob> maybe, but I still can't access it in Haskell
05:51:54 <Workybob> and that makes it not sugar
05:51:59 <Workybob> it's not added on top to make things sweeter
05:52:03 <BONUS> ah i see your point
05:52:32 <BONUS> syntactic sugar can always be desugared in code
05:52:37 <BONUS> while this can't
05:52:41 <Workybob> making it just sugar would be a good solution – but I'd prefer the solution where I actually get to write mixed-fix types and constructors
05:53:01 <Workybob> it'd be lovely not to have to use Data.Set a, but { a } instead
05:53:07 <Workybob> (as an example)
05:53:09 <BONUS> yeah was just about to write that
05:53:15 <BONUS> i wonder if it would make the grammer complicated
05:53:26 <Workybob> I suspect that yes, it would
05:53:30 <opqdonut> grammer indeed
05:53:33 <BONUS> haha yikes
05:53:47 <vixey> outfix, just normal brackets wouldn't be a big change
05:53:47 <Workybob> {a |-> b} instead of Data.Map a b would be shiny as hell too
05:54:06 <vixey> but full mixfix like Agda.. you'd break all the old haskell code wouldn't you?
05:54:15 <Workybob> this would have a really lovely side effect too
05:54:21 <Workybob> it would stop lists being considered special
05:54:23 <BONUS> yeah :[
05:54:32 <Workybob> and make people realise that they are allowed to use other data structures
05:54:43 <vixey> (not that it's a problem, just something avoidable
05:54:48 <BONUS> but come to think of it i dont mind lists being a bit special, because they have a special place in my heart
05:55:00 <Workybob> hehe, that's exactly what I'm trying to avoid
05:55:02 <Workybob> :P
05:55:55 * vixey thinks this channel is turning into ##C
05:56:13 <sbahra> Go away.
05:57:49 <Workybob> @ops
05:57:50 <lambdabot> Maybe you meant: docs oeis pl
05:57:55 <Workybob> @get-ops
05:57:55 <lambdabot> Unknown command, try @list
05:57:57 <Workybob> gah
05:58:09 <vixey> ?where ops
05:58:09 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
05:58:15 <Workybob> cheers vixey
05:58:21 <Workybob> it's getting a little tiring, isn't it
05:58:50 <Saizan> what's the problem?
05:59:05 <vixey> Saizan, I'm not totally sure but apparently it's my fault
05:59:09 <Workybob> sbahra has a problem with vixey, and hasn't figured out to take it out of channel
05:59:54 <joma> asgaroth: and I could give the result of a binary to a python-program?
06:00:39 <asgaroth> joma: Yes, either pipe it when starting the python program or run it from inside the python script and somehow capture the output
06:00:51 <jideel> thanks all
06:00:57 <asgaroth> But I'm not aware of any ffi-like direct binding to haskell functions
06:00:57 <sbahra> Good luck, jideel
06:01:10 * jideel goes back to read the Haskell book
06:01:58 <matthew-_> um, a bit off topic, but parametrise or parameterise?
06:02:11 <vixey> @w80 parameterize
06:02:15 <BONUS> matthew-_: that one had me confused a bit too
06:02:18 <matthew-_> my dictionaries are being unhelpful
06:02:22 <lambdabot> No match for "parameterize".
06:02:23 <vixey> @w80 parametrize
06:02:26 <dcoutts> matthew-_: my spell checker says the first, but who can say :-)
06:02:29 <lambdabot> No match for "parametrize".
06:02:35 <BONUS> i think it's parameterise
06:02:45 <matthew-_> vixey: yeah, I did check those first
06:02:52 <vixey> hum.. I was sure it would be parametrize
06:03:04 <dcoutts> bah, US spelling :-)
06:03:08 <vixey> Alternative forms
06:03:08 <vixey>     * parametrise
06:03:08 <vixey>     * parameterize
06:03:08 <vixey>     * parameterise
06:03:09 <lilac> well, it means "make parametric" not "make a parameter"
06:03:10 <matthew-_> well I'm not having a z in there...
06:03:28 <lilac> and it's parametricity not parametericity
06:03:35 <vixey> so basically spell it any way you like :p
06:03:35 <matthew-_> lilac: ahh, good point. Cheers
06:03:44 <vixey> (from wiktionary)
06:04:13 <matthew-_> you know you're in trouble when... #43256 you're relying on wiktionary
06:05:05 <blackh> Employers brace yourself for an influx of................ wikipedia kids! (Oh no!)
06:10:28 <chessguy_work> 'morning
06:11:06 <blackh> chessguy_work: Is it that time already? Hi there!
06:11:12 <lilac> 'aft'noon
06:11:29 <chessguy_work> unfortunately, yes
06:12:23 <xenoblitz> guys I have a confession :( I can't understand circular programming
06:12:28 <blackh> chessguy_work: Well, it's time for me to go to bed. Good night!
06:12:37 <chessguy_work> @time blackh
06:12:41 <vixey> xenoblitz, also known as data recursion
06:12:41 <vixey> ?
06:12:50 <chessguy_work> heh
06:12:54 <FunctorSalad> is there an easy way to monomorphify a bunch of polymorphic functions for use with quickcheck?
06:13:04 <blackh> chessguy_work: It's early for me - 3:12 AM
06:13:20 <xenoblitz> vixey: its used to remove the need to traverse trees more than once
06:13:21 <chessguy_work> nice
06:13:23 <vixey> FunctorSalad, using type annotations ?
06:13:25 <FunctorSalad> (say you wrote properties for testing a *class*)
06:13:28 <xenoblitz> vixey: for example
06:13:46 <vixey> xenoblitz, oh right, I use the same idea to write parsers with ReadP
06:14:08 <xenoblitz> vixey: is there any SIMPLE example which doesn't blow a simple guy's head off?
06:14:10 <FunctorSalad> vixey: that isn't easy for > 10 properties and more than one instance type ;)
06:14:11 <vixey> xenoblitz, each part of the parser joins onto a different bit and you get a loop in the end
06:14:34 <Saizan> @seen gwern
06:14:34 <lambdabot> gwern is in #haskell, #darcs and #xmonad. I last heard gwern speak 8h 51m 26s ago.
06:14:43 <FunctorSalad> vixey: thinking about using TH
06:15:15 <xenoblitz> Saizan: the article you referred me to helped... but I want to understand circular programming to fully understand this
06:15:15 <FunctorSalad> though there seems to be no way to get a list of all decls in the current module
06:15:41 <FunctorSalad> except for using haskell-src on the current filename and then translating o_o
06:15:56 <Saizan> @ask gwern is it feasible to put some darcs repo behind gitit so that people can easily add haddock documentation?
06:15:57 <lambdabot> Consider it noted.
06:16:24 <joma> interactive>:1:0:
06:16:24 <joma>      Failed to load interface for `DA':
06:16:32 <joma> even though import qualified Data.Array as DA works
06:17:01 <Saizan> xenoblitz: well, the simplest interesting example is the list of fibonacci numbers defined like this:
06:17:22 <Saizan> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
06:17:24 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
06:17:43 <xenoblitz> Saizan: ok wow
06:18:06 <Saizan> fibs is defined in terms of itself
06:18:51 <Workybob> > let fibs n m = n : fibs m (n+m) in fibs 1 1
06:18:53 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
06:19:12 <Workybob> I love that definition
06:19:31 <Workybob> you can see the data sliding through the zip
06:19:34 <Saizan> it's crucial that the definition doesn't inspect "fibs" before producing some results
06:20:00 <Saizan> i.e. the (1:) . (1:) part
06:20:55 <asgaroth> Is using a state monad if I want to find matching parentheses the best solution or should I use a fold expression instead(Both times I'd use it to replace the chars with their depth and later use find (==0))?
06:21:18 <asgaroth> *findIndex (==0)
06:21:45 <Workybob> asgaroth: I would say based on the fact that parsers are usually best written applicatively, that a monad sounds like too much for that problem
06:21:51 <Workybob> especially one with such enforced sequencing
06:22:13 <Saizan> matching parentheses is really just a matter of nested recursion
06:22:29 <Saizan> you don't need indices or anything like that
06:22:51 <Workybob> indeed
06:23:10 <asgaroth> hmm, ok
06:23:27 <quicksilver> that is indices : its using the implicit recursion depth to encode the index.
06:23:35 <quicksilver> still, I agree that that is simpler (than explicit indices)
06:24:23 <quicksilver> I think there are some cases where the naive recursion makes it harder to be "sloppy" and correct/cleverly report some kinds of error.
06:24:29 <Saizan> yeah, or you could push symbols to check on a stack instead of using the call one
06:25:09 <Peaker> where can people suggest stuff to Haskell prime?
06:25:09 <quicksilver> explicitly managed symbol stack is probably best for error reporting/recovery.
06:25:24 <quicksilver> But if you want something simple, the naive recursion is good.
06:25:31 <quicksilver> Peaker: there is a mailing list.
06:25:38 <quicksilver> Peaker: or for a concrete proposal, you submit it to the trac
06:25:49 <quicksilver> (and then try to start a discussion about the proposal on the list)
06:26:08 <Peaker> I want to voice that unqualified imports should not be the default. I'd even prefer open unqualified imports to issue a "Warning: Unqualified imports can cause name-space clashes" or such :P
06:26:59 <quicksilver> I think the choices are (a) try to open a discussion on the mailing list or (b) simply make a precise proposal and submit it to the trac.
06:27:12 <BONUS> Peaker: why?
06:27:20 <Workybob> Peaker: *shrug* when they do create a namespae clash, you get an error
06:27:23 <Workybob> so isn't that fine?
06:27:41 <BONUS> yeah, in python you should avoid just importing * because you get clashes at runtime
06:27:44 <Peaker> Workybob: it means that you cannot consider a library to be backwards compatible if it added symbols.
06:27:44 <xenoblitz> Saizan: still thinking about it, but thanks
06:27:47 <BONUS> but in haskell they're resolved at compile time sooo
06:28:04 <Workybob> Peaker: yeh, that's a fail
06:28:09 <Peaker> BONUS, Workybob: Compile-time errors of libraries you didn't write are not nice. Its not a major disadvantage but it still is one. What's the advantage?
06:28:30 <Peaker> the major disadvantage is inability to read code and know where symbols are coming from
06:28:31 <Workybob> Peaker: that I don't have to fuck about qualifying *everything*
06:28:32 <quicksilver> Peaker: the advantage is that importing everythign qualified SUCKS
06:28:43 <quicksilver> and we don't have good enough tools to handle qualified imports
06:28:50 <Peaker> Workybob, quicksilver: You can use:  import Control.Applicative((<*>))
06:28:51 <quicksilver> (e.g. you can't re-export a qualified import qualified)
06:29:03 <Peaker> closed-unqualified is ok
06:29:15 <Workybob> Peaker: oh, I see
06:29:17 <Heffalump> quicksilver: it'd be really handy to be able to export qualified names
06:29:19 <Workybob> that's less nasty
06:29:23 * Workybob ponders if it's nasty at all
06:29:35 <quicksilver> Heffalump: yes.
06:29:36 <Peaker> Open-unqualified just makes it impossible to figure out where things are coming and means you cannot add symbols backwards compatibly
06:29:46 <quicksilver> Peaker: s/impossible/hard/
06:29:48 <quicksilver> Peaker: but, yes.
06:29:53 <Saizan> xenoblitz: it took a while for me to get how it worked, i've gone through the definition of the Y combinator in lambda calculus, but i'm not sure that helps :)
06:30:00 <quicksilver> a tool which helped you figure out where things were coming from would ease the pain.
06:30:06 <quicksilver> but in general, I agree with Peaker.
06:30:18 <Saizan> xenoblitz: do you have any particular question?
06:30:53 <xenoblitz> Saizan: its amazing how this stuff works... i guess my folly is that I'm so used to non-lazy languages that such things look impossible
06:31:02 <Peaker> I think Haskell code does not tend to export dozens of symbols.. Nice generic type-classes like Functor, Applicative, Monoid often mean we can export much fewer symbols -- or even just export instances. So we don't really have to list that many names
06:31:33 <xenoblitz> Saizan: my problem is using tying the knot when using a tree structure (which defines a circuit) to write the circuit as a list of equations
06:31:33 <quicksilver> nice reusable code libraries normall export a small set of names, I agree.
06:31:37 <BONUS> i prefer doing import Module (fun1, fun2, fun3) etc.
06:31:39 <quicksilver> qualified re-exports would help, too.
06:32:39 <Saizan> xenoblitz: so you define each node separately but they can have cycles?
06:33:04 <xenoblitz> saizan: yes ... i know its been done before but its more of an exercise
06:33:24 <joma> quicksilver: you meant listArray right? i still dont get the 2d-indexing part
06:33:56 <sbahra> beelsebob, http://haskell.org/sitewiki/images/f/f3/UnsafeHaskell.png
06:34:00 <sbahra> beelsebob, hahahaha
06:34:04 <sbahra> Best logo
06:34:35 <quicksilver> joma: if you use a tuple type, like (Int,Int) then that feels like a 2D array.
06:34:42 <hugo___> :D
06:34:51 <hugo___> i really like the one of the lightbulb
06:35:00 <Saizan> xenoblitz: what's your tree type? and are you stuck on something?
06:35:00 <hugo___> that one is also really great
06:35:01 <joma> array ((0,0),(1,1)) [((0,0),0.0),((0,1),0.0),((1,0),0.0),((1,1),0.0)] , how do I get an index?
06:35:36 <BONUS> ! (1,1)
06:35:54 <Saizan> > array ((0,0),(1,1)) [((0,0),0.0),((0,1),0.0),((1,0),0.0),((1,1),0.0)] ! (1,1)
06:35:55 <lambdabot>   0.0
06:36:16 <BONUS> > listArray ((0,0),(1,1)) [1,2,3,4] ! (0,1)
06:36:17 <lambdabot>   2
06:36:41 <lispy> morning
06:37:46 <xenoblitz> Saizan: my type is like so Wire = Low | High | Inv Wire | And Wire Wire | Var String and I'm stuck when I'm trying to define the equations for Inv and And since those are the ones which might need tying the knot
06:38:53 <xenoblitz> Saizan: hence the reason of me wishing to understand how circular programming and tying the knot work... although I understand code that uses them I can't figure out what i'm missing so that I write similar code myself...
06:40:06 <Saizan> you understand what happens with e.g. let x = And x x in x?
06:40:54 <xenoblitz> Saizan: you get And (And (A...) (And (A...))
06:40:55 <joma> hmm im thinking about making my own little linear algebra DSL. I will first make a complete library for normal haskell use then a program that can be loaded from the command prompt and run like a repl where you can do matrix and linalg operations with very sparse syntax. so is it easy to write a parser in haskell for ojng things like matrix [1,3:2,4] to slice out parts of a matrix for example?
06:41:33 <quicksilver> joma: well, it's no harder than in other languages.
06:41:36 <quicksilver> I would say it's easier.
06:41:46 <quicksilver> Obviously parsers always require a little bit of work.
06:41:49 <xenoblitz> Saizan: wait... i might have messed it up
06:41:50 <quicksilver> Many people like Parsec for parsing.
06:41:57 <Saizan> xenoblitz: no, that's right
06:42:00 <quicksilver> I recommend polyparse, personally.
06:43:20 <xenoblitz> Saizan: lets are confusing for me... i usually stick to where :P
06:43:44 <Saizan> "x where x = And x x" then :)
06:44:24 <xenoblitz> Saizan: ok so that's the same exact thing... strange how changing such a small thing confuses me
06:44:31 <Saizan> it works because you have put a constructor in front of the recursive call
06:44:31 <quicksilver> x where x = let x = And x x in x
06:45:00 <xenoblitz> quicksilver: i think some of my brain cells just died
06:45:19 <quicksilver> damn.
06:45:23 * quicksilver apologises.
06:45:31 <xenoblitz> quicksilver: :)
06:45:44 <Saizan> it's funny because there are lexically two x there, but they are the same in the end
06:46:13 <xenoblitz> Saizan: you mean the And?
06:46:41 <xenoblitz> Saizan: yes the And
06:46:46 <Saizan> abotu the constructor? yes, exactly
06:46:46 <quicksilver> the "let" introduced a fresh variable
06:47:10 <joma> setAt m r c v = SparseMatrix ((repr m) DA.// [(r,c), v])
06:47:33 <joma>  Matrix repr         -> (Int, Int)        -> Double         -> ((Int, Int), Double)         -> Matrix repr1
06:47:48 <joma> when i want: setAt:: Matrix Int Int Double
06:47:54 <joma> -> Matrix
06:47:56 <Saizan> while you explore "x = And x x" you see infinite And's, but they are actually all the same one
06:48:20 <xenoblitz> Saizan: cause of ref transparency
06:48:49 <quicksilver> joma: sorry, don't think I understand which part was the question there.
06:49:03 <roderyk> hey, I'm going to be working on some inkscape effects and I thought I'd try it out in haskell (even though python seems to be the favorite in the submissions). This would mean a lot of editing xml (specifically svg): any recommendations on what xml library would be the most comfortable for this? There would be lots of searching for specific elements, iterating over child/parent nodes,
06:49:04 <Saizan> xenoblitz: right, because of that you can't tell the difference between cyclic and infinite structures
06:49:19 <roderyk> and modifying current xml trees
06:49:37 <roderyk> (hopefully in a terse syntax) - any suggestions?
06:49:56 <roderyk> (don't care so much about handling large xml files or validation)
06:50:07 <joma> why is the type so weird fo setAt?
06:50:11 <bremner> roderyk: hxt can certainly do all that. It uses arrows in a big way, so you might or might not like that
06:50:19 <asgaroth> Saizan, xenoblitz: Stupid question: Does that expression simplify to "And x x"? And is the x used for the constructor And the one from the where?
06:50:21 <Saizan> xenoblitz: in fact sometimes it's necessary to put labels in the nodes to tell if they are intended to be the same one
06:50:50 <xenoblitz> Saizan: yeah i'm using the ref technique for that
06:51:38 <xenoblitz> Saizan: ﻿﻿now I was reading issue 6 of the monad reader and abstracting away some stuff there are two lines here in a where clause which really really confuse me, I'm abstracting away some extra stuff: (answer,var_a) = funcA var_b; var_b = funcB var_a
06:52:01 <lilac> asgaroth: it 'simplifies' to "let x = And x x in x" or to "fix (\x -> And x x)"
06:52:27 <roderyk> bremner: thanks, will look into it and see if it suits me
06:52:33 <xenoblitz> asgaroth: sorry I can't help you there :P I'm trying to figure it out myself as well hehe
06:52:55 <Saizan> asgaroth: semplify in which sense?
06:53:08 <asgaroth> Saizan: some sort of "could be written as"
06:53:53 <Saizan> asgaroth: if you inspect it you'll se something like And (And (And (..) (..)) (And (..) (..))) (And (..) (..))
06:54:44 <asgaroth> Hmm, so the x in the right hand side of "let x = And x x" actually uses the x from the let binding?
06:55:05 <lilac> asgaroth: there's a thing called x. x's value is the "And" value constructor. that constructor is given two values, both of which are that same x.
06:55:08 <Saizan> yes, exactly
06:55:20 <asgaroth> Okay, then I think I got it
06:55:33 <xenoblitz> Saizan: any idea how it works?
06:55:35 <asgaroth> Thanks
06:55:57 <Saizan> xenoblitz: it's the same principle but splitted in two definitions
06:56:56 <Saizan> xenoblitz: it's like you were defining var_a and var_b as mutually recursive functions
06:57:05 <Saizan> xenoblitz: but they are actually values
07:00:07 <Saizan> xenoblitz: one thing that you've to realize is that with laziness function don't "do something to produce a result" but instead they are a definition of it
07:01:14 <quicksilver> and because of this, values and functions are implemented the sameway.
07:01:29 <quicksilver> whereas in a strict language you'd expect a plain value to be implemented very differently.
07:01:49 <xenoblitz> Saizan, quicksilver: amazing stuff
07:01:52 <quicksilver> strict language: value is data, function is code. Lazy language: values and functions are both 'data or code'
07:03:47 <xenoblitz> Saizan, quicksilver: so how would one interpret the code on page 42 of the monad reader 6... i mean how does it get evaluated?
07:04:37 <xenoblitz> Saizan, quicksilver: specifically the link function is impossible for me to understand
07:04:52 <roderyk> it's so depressing, python is no longer a nice, terse language. Haskell is terrible :)
07:05:22 <bremner> roderyk: a week of Java and you will appreciate python again
07:05:28 <asgaroth> roderyk: And it actually makes you a lot more frustrated when you have to write something in Java or C
07:05:29 <quicksilver> xenoblitz: warning, reading code by roconnor can recause irreversible mental damage ;)
07:05:46 <xenoblitz> quicksilver: how come?
07:05:52 <quicksilver> I'm being flippant.
07:05:59 <quicksilver> roconnor is rather smart, though.
07:06:06 <joma> is flattening a list with : foldl1 (++) O(n^2) ?
07:06:08 <xenoblitz> quicksilver: hehe
07:06:24 <roderyk> bremner, asgaroth: yea, python is a god-send from Java. I know I've spent quite a while with it. :)
07:06:34 <quicksilver> joma: yes. where n is the number of segments, rather than the number of items in the result.
07:06:39 <quicksilver> joma: use foldr instead.
07:06:47 <xenoblitz> quicksilver, Saizan: if you have the page in front of you how does it work labels and output at the same time?
07:06:55 <Saizan> xenoblitz: from an imperative pov, you could say that we allocate the space for output and labels up front, and pass pointers to them at the two functions
07:07:21 <quicksilver> xenoblitz: and as long as one side produces the data that the other side demands before it demands the data tha tthe other side produces
07:07:25 <quicksilver> it all works out OK.
07:07:38 <quicksilver> if one side tried to demand data the other side hadn't produced yet, you get an infinite loop.
07:07:49 <quicksilver> analagous to a deadlock between two threads.
07:08:07 <gwern> yay, cabal-install now uses http 4k!
07:08:07 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
07:08:11 <gwern> @messages
07:08:11 <lambdabot> Saizan asked 52m 14s ago: is it feasible to put some darcs repo behind gitit so that people can easily add haddock documentation?
07:08:13 <vixey> > foldl1 (++) ["foo","bar","baz"]
07:08:14 <lambdabot>   "foobarbaz"
07:08:25 <quicksilver> in particular, at least one of the two halves must be able to produce *something* without demanding anythign at all.
07:08:27 <xenoblitz> quicksilver, Saizan: damnnn
07:08:38 <quicksilver> then the other half must consume that and produce enough to let the first half continue
07:08:41 <quicksilver> etc.
07:09:09 <quicksilver> although it doesn't really happen in a back and froth like that.
07:09:09 <quicksilver> really, it's driven by whatever you actually demand.
07:09:40 <quicksilver> I don't remember the details but I think you'll find that the "output" half can actually do basically all its work without really inspecting the labels.
07:09:41 <gwern> Saizan: not really sure what you mean? I mean, you can have a repo of haskell src files, use that as the article repo, and you can edit/save the files (in any way, not just haddocks) through the GUI/wiki; but .hs files won't be treated well (.lhs files do seem to get treated specially)
07:10:09 <quicksilver> effectively its just inserting lazy references to what the labels will be.
07:10:11 <xenoblitz> quicksilver, Saizan: I actually have a headache now... seriously lol
07:10:18 <quicksilver> by the time you actually try to inspect those labels, it's OK
07:10:26 <quicksilver> cos the whole code has been generated by then and the labels are final.
07:10:53 <Saizan> gwern: the aim is to let people add documentation to the standard libraries wihout having to deal with darcs and source files directly
07:11:29 <hcube> Hi!
07:11:37 <saml> hi hcube
07:11:51 <xenoblitz> quicksilver, Saizan: thanks for your time guys... I must be honest... i haven't understood all of it... but at least i'm a step closer
07:11:54 <hcube> is here somebody who is experienced with grapefruit?
07:12:24 <hcube> i've seen that there is a qt backend coming for grapefruit
07:12:24 <quicksilver> xenoblitz: well, a couple of months ago you were just writing a computer game. Now you're understanding mutual construction of lazy values ;)
07:12:29 <baobab> ugh grapefruit
07:12:39 <baobab> so bitter
07:12:40 <chessguy_work> @type \f (a, b) (c, d) -> (f a c, f b d)
07:12:41 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t, t) -> (t1, t1) -> (t2, t2)
07:12:46 <quicksilver> xenoblitz: in a couple of months you'll be solving rubik's cube in the type system ;)
07:12:55 <chessguy_work> why does it say "a" and "b" are the same type?
07:13:00 <gwern> Saizan: well you can't just dump the haddock htmls into a repo, since then the changes never make it back to the original files; but you can't just let's say plunk all the .hs files into a gitit repo, because you couldn't trust people to edit only the haddocks... unless this was some sort of secondary repo where someone would repo patches and forward to the actual maintainer/actual library
07:13:02 <xenoblitz> quicksilver: lets not get tooooo hasty!
07:13:07 <xenoblitz> quicksilver: :P
07:13:09 <pozic> I get Could not deduce (Foo a m1) from the context (Foo a m). Does this ring a bell?
07:13:09 <chessguy_work> oh, nm
07:13:17 <xenoblitz> quicksilver: my tutor might be reading this :P
07:13:19 <quicksilver> pozic: yes.
07:13:35 <quicksilver> pozic: you need a bit more type annotation or type restriction to force the two monads to be the same.
07:13:48 <quicksilver> as written your code is too polymorphic and it permits the possibility that the monad has changed.
07:14:27 <gwern> Saizan: actually maybe the idea of a 'secondary wiki/repo' would work; thoughts?
07:14:43 <hcube> i did a 3d model loader in haskell what reads ogre3d engine's mesh format and i'd like to make a modell viewer app in haskell and i;d like to use AFRP api.
07:15:15 <Saizan> gwern: so that when that someone forwards to the main repo can check that the code is not altered?
07:15:43 <Saizan> a bit tricky if we get a lot of contributions
07:15:47 <gwern> right.
07:16:12 <gwern> mm, I can't see library documentation getting very many edits if the main haskell wiki itself isn't too popular :)
07:16:48 <gwern> Saizan: the benefit is that if the original repo and the wiki repo are closely synchronized, the wiki edits can be applied directly to the original after review
07:17:12 <Saizan> ah, we also don't need to look at the patches, we can just make a diff against the main repo and check the portions changed
07:17:23 <gwern> if the reviewer has push access, say, he can make this a daily thing; review the 2 or 3 patches in the wiki, push or obliterate, and he's done
07:17:48 <pozic> quicksilver: I have a record with a number of values which are of some type. There are instances defined for all these types and all these methods should operate in the same monad. I just don't see why it thinks it's more polymorphic.
07:18:02 <gwern> for really ideal results, maybe gitit would automatically run haddock when displaying .hs files? hmm
07:18:13 <Gracenotes> hm. Is there a set of rules to determine eta-equivalence?
07:18:13 <Saizan> gwern: the wiki repo can just be a branch of the code one, right? gitit doesn't add its own files?
07:18:45 <quicksilver> pozic: probably won't be able to tell you without seeing the code ;)
07:18:48 <Saizan> gwern: yeah, an haddock preview is necessay i think
07:18:50 <vixey> Gracenotes, of?
07:19:06 <Gracenotes> untyped lambda calculi
07:19:07 <gwern> Saizan: by default, a gitit looks like this: 'wiki/, wiki/static/, wiki/static/img/*, css/*, js/*; wikidata/*, wikidata/_darcs/...'
07:19:58 <pozic> quicksilver: yeah, I think I already have it. At least, I know where the m1 is coming from now :)
07:19:58 <gwern> Saizan: if you do 'mkdir wiki && cd wiki && mkdir wikidata && cd wikidata && darcs init && darcs pull --all wherever && cd ../ && gitit', gitit automatically creates everything in static/
07:20:08 <gwern> they don't have to be part of the repo
07:20:49 <Gracenotes> hm *continues reading the text*
07:21:08 <gwern> Saizan: I personally like to put everyting into the repo and edit the config so the entire wiki is self-contained; I have an example repo up like this, where you just darcs get it, cd into it, and run 'gitit -f static/Config.hs' and it looks and acts exactly like my local version - log in, graphics, everything
07:21:19 <gwern> but you don't have to do this inversion trick
07:21:34 <chessguy_work> is it possible to import/export an instance?
07:21:35 <bastl> hi this sounds like a newbie problem: i want to apply a list of differnt functions to the same arguments. there is surely a cool trick for that ?
07:21:46 <Saizan> gwern: i see
07:21:46 <vixey> bastly, sequence
07:21:51 <bastl> thanks
07:22:17 <chessguy_work> @type sequence [(*2), (+1)]
07:22:18 <gwern> nice, http 4x cabal-install really does download faster
07:22:18 <lambdabot> forall a. (Num a) => a -> [a]
07:22:38 <quicksilver> gwern: interesting, why's it faster?
07:22:41 <chessguy_work> @type sequence
07:22:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:22:55 <chessguy_work> ah, nice
07:23:10 <gwern> quicksilver: http 4x switched to bytestring, for major major speedups
07:23:12 <Saizan> gwern: so, where i can find this darcs enabled gitit?
07:23:14 <gwern> quicksilver: think 30x
07:23:28 <gwern> Saizan: a git branch off the main gitit repo
07:23:50 <gwern> Saizan: there's some arcane git command to switch from the mainline to the filestore branch; I can look it up for you if you want
07:23:53 * Saizan needs to learn git
07:24:16 <quicksilver> gwern: cute.
07:24:16 <chessguy_work> if i have a module with an instance (Num a, Num b) => Num (a,b), can i import/export that?
07:24:18 <roderyk> on FreeBSD, I have the curl libs installed but I can't get cabal-install curl to work (it's complaining about missing curl libs). Anyone experience this before? is it a path issue or some non-compatibility issue?
07:24:30 <Saizan> gwern: yes, thanks :)
07:24:30 <Peaker> git is a horrible CLI to a great DVCS...
07:24:42 <quicksilver> chessguy_work: instances are exported by default, as far as I remember.
07:24:47 <saml> @pl myFunc f (a,b) (c,d) = (f a c, f b d)
07:24:48 <lambdabot> myFunc = (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (flip =<< (((.) . flip . (((.) . (,)) .)) .))
07:24:55 <quicksilver> chessguy_work: importing the module automatically imports all its instances.
07:25:01 <quicksilver> (at least for types in scope)
07:25:05 <chessguy_work> quicksilver, ah
07:25:14 <gwern> Saizan: 'git clone git://github.com/jgm/gitit.git && cd gitit && git checkout --track -b filestore origin/filestore'
07:25:30 <gwern> Saizan: obviously you also need darcs filestore http://johnmacfarlane.net/repos/filestore
07:25:31 <Gracenotes> O.O
07:26:28 <dcoutts_> roderyk: I expect that libcurl is not on your default linker path on FreeBSD, right?
07:26:53 <saml> > let thread f (a,b) (c,d) = (f a c, f b d) in (1, 2) `thread (+)` (3, 4)
07:26:54 <lambdabot>   <no location info>: parse error on input `('
07:26:56 <Workybob> @hoogle (a -> Maybe a) -> Key -> a -> IntMap a -> IntMap a
07:26:57 <lambdabot> No results found
07:27:05 <saml> i can't write  expression in ` ` ?
07:27:13 <Workybob> @hoogle (a -> Maybe a) -> Key -> IntMap a -> IntMap a
07:27:13 <lambdabot> Data.IntMap update :: (a -> Maybe a) -> Key -> IntMap a -> IntMap a
07:27:18 <Workybob> bah :(
07:27:20 <roderyk> dcoutts: honestly, I don't even know what my default linker path is. :)
07:27:21 <gwern> saml: nope
07:27:28 <gwern> saml: annoying eh
07:27:32 <sleven> what is the appropriate action in Haskell when lets say the user constructs a matrix but passes [[1,2],[3,4,5]] , ie the dimensions are incorrect? error? or some Monad stuff?
07:27:35 <Workybob> @hoogle (a -> Maybe a) -> Key -> IntMap a -> Maybe (IntMap a)
07:27:35 <lambdabot> Data.IntMap update :: (a -> Maybe a) -> Key -> IntMap a -> IntMap a
07:27:49 <saml> > let thread f (a,b) (c,d) = (f a c, f b d) in (1, 2) `thread'` (3, 4) where thread' = thread (+)
07:27:50 <lambdabot>   Not in scope: `thread'
07:27:59 <chessguy_work> sleven,  error is probably ok
07:28:03 <dcoutts_> roderyk: would you normally need some extra -L/usr/local or something? if so you need the same with cabal install --extra-lib-dirs=/usr/local or wherever FreeBSD sticks extra stuff like libcurl
07:28:14 <chessguy_work> sleven, unless you want to catch it and handle it more gracefully
07:28:30 <dublpaws> is it possible to define infix operators which operate on themselves and other infix operators? something like (but not), 0 + + + 1  ==>  0 * 1
07:28:42 <saml> > "hello" >>= \x -> "world"
07:28:43 <lambdabot>   "worldworldworldworldworld"
07:28:56 <dcoutts_> roderyk: try locate libcurl.so, what dir is it in?
07:29:12 <quicksilver> dublpaws: no.
07:29:12 <sleven> hmm ust a though, I have 2 very similar functions:
07:29:12 <sleven> rows m = (fst $ snd $ DA.bounds (repr m)) + 1
07:29:12 <sleven> cols m = (snd $ snd $ DA.bounds (repr m)) + 1
07:29:15 <roderyk> dcoutts: /usr/local/lib/libcurl.so
07:29:22 <xenoblitz> > "hello" >>= \x -> x ++ " world"
07:29:23 <quicksilver> dublpaws: the grammar is <expr> <op> <expr>
07:29:23 <lambdabot>   Couldn't match expected type `[b]' against inferred type `Char'
07:29:35 <roderyk> dcoutts: runhaskell Setup.hs configure --extra-lib-dirs=/usr/local is still no go
07:29:36 <sleven> how could I abstract out the common stuff?
07:29:39 <saml> > [x,y,z] >>= \f -> [a,b,c]  :: [Expr]
07:29:40 <chessguy_work> dublpaws, you'd probably at least need parens for that, but it looks like the middle (+) has a different type than the others?
07:29:40 <dcoutts_> roderyk: ok, then try cabal install curl --extra-lib-dirs=/usr/local/lib
07:29:40 <lambdabot>   [a,b,c,a,b,c,a,b,c]
07:30:01 <quicksilver> sleven: bounds m = snd $ DA.bounds (repr m)
07:30:04 <dcoutts_> roderyk: you may also need --extra-include-dirs=/usr/local/include
07:30:08 <quicksilver> rows m = fst (bounds m) + 1
07:30:11 <quicksilver> sleven: perhaps.
07:30:28 <roderyk> dcoutts: still no go
07:30:37 <dcoutts_> roderyk: use @hpaste
07:30:53 <Peaker> @hoogle bounds
07:30:53 <lambdabot> Data.Array.Base bounds :: (IArray a e, Ix i) => a i e -> (i, i)
07:30:53 <lambdabot> Data.Array.IArray bounds :: (IArray a e, Ix i) => a i e -> (i, i)
07:30:53 <lambdabot> Data.Array.IArray bounds :: (IArray a e, Ix i) => a i e -> (i, i)
07:31:35 <pozic> quicksilver: this contains the problem: http://paste.debian.net/26130/
07:31:46 <saml> > [a,b] `f` [c,d]  where f = zipWith f :: [Expr]
07:31:46 <lambdabot>   Couldn't match expected type `[Expr]'
07:31:52 <saml> > [a,b] `f` [c,d]  where f = zipWith f
07:31:53 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
07:31:53 <lambdabot>        Expect...
07:31:59 <dcoutts_> roderyk: oh, it uses configure and so does not respect --extra-include-dirs
07:32:02 <bastl> sorry, i dont understand the type of "sequence [(*2),(+2)]". i knew sequence as sequential execution of actions, but i just want to evaluate normal functions.
07:32:02 <roderyk> dcoutts: http://hpaste.org/13991
07:32:49 <vixey> :t sequence [(*2),(+2)]
07:32:49 <lambdabot> forall a. (Num a) => a -> [a]
07:32:53 <vixey> > sequence [(*2),(+2)]   54
07:32:54 <lambdabot>   [108,56]
07:33:10 <Peaker> can anyone just upload packages to hackage? Is there no problem of malicious code?
07:33:10 <bastl> oh, my ghci tells differnt things ...
07:33:10 <xenoblitz> bastl: something like this? ((+5).(*2)) 1
07:33:20 <roconnor> @hoogle Last
07:33:20 <lambdabot> Data.Monoid newtype Last a
07:33:20 <lambdabot> Data.Monoid Last :: Maybe a -> Last a
07:33:20 <lambdabot> Prelude last :: [a] -> a
07:33:38 <quicksilver> pozic: could you add the exact error to the paste?
07:33:39 <roderyk> dcoutts: hmm, well even if I untar and run "runhaskell Setup.hs configure  --extra-lib-dirs=/usr/local/lib --extra-include-dirs=/usr/local/include", same thing
07:33:54 <dcoutts_> roderyk: yes, the configure script ignores those
07:34:01 <roderyk> oh
07:34:02 <saml> is there zipWith for 2-tuples?
07:34:07 <dcoutts_> roderyk: if it were not for the configure script it would work I think
07:34:30 <dcoutts_> roderyk: try changing the build type in the .cabal file to Simple and then run it again
07:34:30 <pozic> quicksilver: done, comment added
07:34:32 <bastl> :info sequence
07:35:10 <dcoutts_> @seen dons
07:35:10 <lambdabot> dons is in #haskell, #concatenative, #arch-haskell, #novalang, #darcs, #xmonad and #ghc. I last heard dons speak 8h 14m 31s ago.
07:35:15 <dcoutts_> @localtime dons
07:35:17 <lambdabot> Local time for dons is Fri Jan 16 07:35:34 2009
07:35:29 <Peaker> what's the difference between nanocurses and hscurses?
07:35:38 <xenoblitz> bastl: is perhaps the (.) what you are looking for?
07:35:50 <quicksilver> pozic: Ah, well.
07:36:00 <quicksilver> pozic: your toplevel function 'test' must have some particular type.
07:36:17 <roderyk> dcoutts: changed the build-type; still no-go. hmmm
07:36:18 <quicksilver> pozic: GHC is calling that monad "m" for the sake of the argument.
07:36:23 <dublpaws> chessguy_work: yeah the operator would be overloaded in a way which is too hard for me to type on IRC, and you're right, about it needing parens, I think. :S
07:36:29 <quicksilver> pozic: meanwhile, your blob 'k' is existential.
07:36:36 <quicksilver> pozic: that means k relates to an 'unknown' monad.
07:36:50 <cajun-rat> is there a way to turn a bunch of embedded 2-tuples into a n-tuple?  eg: ((1,2),3) -> (1,2,3) or (1,(2,3)) -> (1,2,3)?
07:36:59 <dcoutts_> roderyk: oh, you need to change the Setup, since you're using that rather than cabal-install
07:37:08 <quicksilver> pozic: so you can never interpolate the 'f' from 'k' into some particular monad m
07:37:09 <bastl> xenoblitz: thats just composition isnt it? vixeys things is what i want, but the type for the same thing is different here: sequence [(+2),(*2)] :: (Monad ((->) a), Num a) => a -> [a]
07:37:12 <dcoutts_> roderyk: use main = defaultMain
07:37:13 <quicksilver> because it's unknown.
07:37:28 <gwern> Saizan: I sent an email describing my gitit doc suggestion in '[Haskell-cafe] about documentation improvements'
07:37:33 <quicksilver> bastl: lambdabot knows that (->) is a monad.
07:37:36 <quicksilver> bastl: your ghci does not.
07:37:42 <quicksilver> bastl: (because the instance is not in scope)
07:37:48 <quicksilver> :m +Control.Monad.Instances
07:37:50 <dcoutts_> g'morning SyntaxNinja
07:37:54 <quicksilver> and your ghci will agree with lambdabot.
07:37:56 <pozic> quicksilver: so, how can I make the connection between the two?
07:38:01 <quicksilver> pozic: you cannot.
07:38:10 <bastl> ah, thanks quicksilver
07:38:27 <quicksilver> pozic: test is a top-level function, it will always have either (a) some specific monad type or (b) be generic over all monads.
07:38:33 <roderyk> dcoutts: brilliant! thanks :)
07:38:38 <dcoutts_> roderyk: great
07:38:39 <Saizan> gwern: good
07:38:41 <quicksilver> pozic: however 'k' conceals an existential - that is unknown - monad.
07:38:49 <quicksilver> pozic: that can never be the same as test.
07:39:07 <pozic> quicksilver: so, if I remove the existential m in k, will it then work?
07:39:08 <roderyk> dcoutts: will I be hitting a lot of these walls in hackage due to the path, or is this rather uncommon?
07:39:17 <dcoutts_> roderyk: yes I expect so
07:39:21 <gwern> dcoutts_: gitit is pretty cool. maybe it'll solve our 'docs-are-hard-to-contribute-to' problem; see my email
07:39:24 <quicksilver> pozic: if you amke the 'm' a parameter of the type Test
07:39:27 <quicksilver> instead of an existential
07:39:30 <quicksilver> then it will work.
07:39:34 <dcoutts_> roderyk: you might like to make that setting persistent in your ~/.cabal/config file
07:39:38 <pozic> quicksilver: I already tried that, and it didn't but I will try again.
07:40:11 <pozic> quicksilver: right, almost same error message.
07:40:18 <dcoutts_> SyntaxNinja: did you know we're now at the stage where for some packages at least, configure causes more harm than good? The curl binding works fine without configure and does not work with it, in some configurations, notably when C libs are in non-standard locations.
07:40:29 <pozic> quicksilver: Do you have MonadRandom installed?
07:40:33 <quicksilver> pozic: sadly not.
07:40:39 <quicksilver> otherwise I would have tested it myself.
07:40:45 <pozic> quicksilver: ok, I can change it such that it uses Reader, is that OK?
07:40:59 <quicksilver> sure.
07:41:11 <roderyk> dcoutts: added the settings to .cabal/config. Thanks, I'd probably wading in the dark for a long time there
07:41:21 <vixey> Gracenotes, I can't think of any way for untyped lambda calculus
07:41:33 <vixey> Gracenotes, please tell me if you come up with something though
07:41:49 <Gracenotes> you might be able to do something QuickTest-like
07:41:59 <sleven> hmm when i do : let m = matrixFromList and give wrong dimensions it doesnt give the error until I do m and show it. why is this? shouldnt errors be reported when they happen? a case of stupid laziness?
07:42:06 <Gracenotes> to see if it's eta-equivalent for a helluvalota arguments
07:42:27 <Peaker> did anyone here use curses bindings?
07:42:36 <Peaker> @hoogle initCurses
07:42:36 <lambdabot> No results found
07:42:37 <quicksilver> sleven: well whether it's stupid or not is a matter of opinion, but yes.
07:42:42 <gwern> Peaker: I worked on them a little
07:42:44 <quicksilver> sleven: let m = ... doesn't do anything
07:42:45 <Peaker> initCurses :: IO () -> IO () -- why does it take an action?
07:42:51 <Peaker> gwern: did you use nanocurses or hscurses?
07:42:55 <quicksilver> sleven: it just gives a name to an expression.
07:43:02 <vixey> Gracenotes, what if you just eta-reduce everything you can after taking the beta normal form?
07:43:06 <gwern> Peaker: I worked on both
07:43:09 <quicksilver> Peaker: I believe you write your entire main in that scope
07:43:17 <pozic> quicksilver: http://paste.debian.net/26133/ with MonadReader
07:43:18 <quicksilver> initCurses $ do .. all your code here ...
07:43:20 <saml> cajun-rat, did you find a way to concat tuples?
07:43:20 <gwern> although I never did succeed in getting mage to use one or t'other
07:43:30 <Peaker> quicksilver: ah, should be called withCurses or something then
07:43:42 <cajun-rat> saml: nope
07:44:18 <Gracenotes> vixey: hm... the must be a theorem or something that describes the cases in which beta-reduction == eta-reduction
07:44:19 <cajun-rat> in ocaml i think (a,b,c) is just sugar for (a,(b,c))
07:44:49 <vixey> cajun-rat, yeah
07:44:59 <Gracenotes> anyways, I'm still reading up on lambda calculus. Really fun :)
07:45:30 <saml> there's no 1-tuple in haskell right?
07:45:36 * vixey knows a way for simple types but not untyped or more complex types..
07:45:39 <saml> something like ((a,b))
07:45:41 <tromp__> no
07:45:59 <tromp__> but there's 0 tuple
07:46:01 <vixey> saml, pretty easy to define
07:46:07 <saml> tromp__, () ?
07:46:13 <tromp__> yep
07:46:20 <sleven> is there no inc in haskell?
07:46:25 <tromp__> succ
07:46:34 <tromp__> > succ 5
07:46:35 <lambdabot>   6
07:46:40 <tromp__> > succ '9'
07:46:41 <roconnor> > succ True
07:46:42 <lambdabot>   ':'
07:46:43 <lambdabot>   * Exception: Prelude.Enum.Bool.succ: bad argument
07:46:57 <roconnor> > succ False
07:46:58 <lambdabot>   True
07:47:02 <tromp__> > map succ "succ"
07:47:03 <lambdabot>   "tvdd"
07:47:12 <roconnor> I'm not sure how I feel about succ False
07:47:13 <loadquo> let ++  = succ in ++ 4
07:47:19 <roconnor> I guess it is ok
07:47:20 <loadquo> > let ++  = succ in ++ 4
07:47:21 <lambdabot>   <no location info>: parse error on input `++'
07:47:32 <Gracenotes> are there any circumstances in which Bool being and Enum is useful?
07:47:37 <tromp__> succ is not ++, it's + 1
07:47:45 * Peaker decides to use SDL rather than curses then :)
07:47:56 <Gracenotes> [False..True]... :/
07:48:09 <Peaker> > [False..]
07:48:10 <lambdabot>   <no location info>: parse error on input `]'
07:48:13 <sleven> cant i map over a tuple?
07:48:26 <lilac> > let (++) = succ in (++) 4
07:48:27 <lambdabot>   5
07:48:38 <lilac> > let (++) = succ in (4++)
07:48:39 <lambdabot>   5
07:48:46 <loadquo> Tromp: Meh, I was trying to make haskell like C, but forgot that ++ is already in use.
07:48:47 <Peaker> sleven: you could use join (***)
07:48:54 <pozic> quicksilver: ?
07:48:54 <sleven> > map succ (1,1)
07:48:55 <lambdabot>   Couldn't match expected type `[a]' against inferred type `(t, t1)'
07:49:03 <Peaker> > let mapTuple = join (***) in mapTuple succ (3,4)
07:49:04 <lambdabot>   (4,5)
07:49:05 <lilac> loadquo: but ++ in C has side-effects!
07:49:08 <Gracenotes> @hoogle (a -> b) -> (a, a) -> (b, b)
07:49:09 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
07:49:09 <lambdabot> Control.Arrow (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
07:49:09 <lambdabot> Data.Array.Base ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
07:49:15 <Peaker> @type join (***)
07:49:16 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
07:49:27 <lilac> loadquo: you could have (++) :: Enum a => IORef a -> IO ()
07:49:43 <Peaker> sleven: Maybe I'd call it both though, because we have "first" and "second" that apply to first or second
07:49:50 <tromp__> :t modify
07:49:51 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
07:49:51 <Peaker> @let both = join (***)
07:49:52 <lambdabot>  Defined.
07:49:54 <lilac> @type flip modifyIORef succ
07:49:56 <lambdabot> Not in scope: `modifyIORef'
07:50:20 <Peaker> > sequence [first (+1), second (+1), both (+1)] (3,3)
07:50:21 <lambdabot>   [(4,3),(3,4),(4,4)]
07:50:50 <Gracenotes> @index first
07:50:50 <lambdabot> Control.Arrow
07:50:55 <Gracenotes> aaahhhh
07:50:56 <quicksilver> pozic: http://hpaste.org/13993
07:51:32 <quicksilver> pozic: the main problem was that there was nothing constraining the two 'm's to be the same
07:51:41 <quicksilver> the m in "k" and the m in "test".
07:52:20 <Peaker> Gracenotes: in the context of functions, first just means "take a function, and have it apply to only the first of a tuple, leaving the second in tact"
07:52:37 <pozic> quicksilver: is there any way to do something like this without enabling everything but the kitchen sink?
07:52:39 <Peaker> > first (*2) (5,6)
07:52:40 <lambdabot>   (10,6)
07:52:43 <Gracenotes> yes, I have seen a diagram or two to that effect
07:53:18 <loadquo> :t join
07:53:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:53:39 <quicksilver> Gracenotes: (bool being Enum) - yes to write code which works generically over enums, especially bounded enums.
07:53:42 <Peaker> @src (->) join
07:53:42 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
07:53:48 <quicksilver> :t [minBound .. maxBound]
07:53:49 <lambdabot> forall a. (Enum a, Bounded a) => [a]
07:53:58 <quicksilver> > [minBound .. maxBound] :: [Bool]
07:53:59 <lambdabot>   [False,True]
07:54:02 <quicksilver> > [minBound .. maxBound] :: [Word8]
07:54:03 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
07:54:08 <sleven> quicksilver: i can index a 3*3 matrix with both getAt m 1 5 and getAt m 2 2 now...
07:54:15 <pozic> quicksilver: ok, I see that you are using the scoped type variables to force them to be the same.
07:54:16 <Gracenotes> quicksilver: yes... but in which cases would you need to apply the functions to booleans?
07:54:22 <sleven> exactly how does listArrays calc the index?
07:54:30 <quicksilver> Gracenotes: it's quite a nice piece of generic coding.
07:54:36 <Gracenotes> the typeclasses "fit", but in practice... not terribly useful
07:54:39 <quicksilver> Gracenotes: like autogenerating a pop-up menu for a GUI widget.
07:54:55 <quicksilver> sleven: yes, that's a weakness.
07:55:03 <quicksilver> sleven: it doesn't do careful checking on both indexes.
07:55:08 <quicksilver> some people consider this a bug.
07:55:15 <quicksilver> pozic: exactly.
07:55:41 <pozic> quicksilver: and now for the hard part, is there any way to have different instances that have a different reader parameter, but still just one test function?
07:55:45 <quicksilver> pozic: as for all the extensions, I personally would never use undecidable instances, and I don't like record wild cards.
07:56:05 <quicksilver> everything else in that list is fine, as far as I'm concerned.
07:56:19 <pozic> quicksilver: if you want to fake class aliases, you already need undecidable instances, AFAIK.
07:56:25 <quicksilver> pozic: sure. Make the reader type another visible parameter of the Test data type.
07:56:47 <oklopol> > reverse []
07:56:49 <lambdabot>   []
07:56:51 <quicksilver> and possibly a visible parameter of F and G
07:56:57 <quicksilver> (I haven't quite seen clearly what you're trying to do)
07:57:04 <pozic> quicksilver: ok, this should get me going again. Thanks a lot.
07:57:42 <pozic> quicksilver: oh, and what makes this undecidable?
07:57:42 <sleven> if succ is +1 what is dec?
07:57:56 <lilac> > pred 43
07:57:57 <lambdabot>   42
07:58:27 <quicksilver> pozic: the F and G instances, but I can't tell you precisely why I'm afraid.
07:58:35 <Peaker> @hoogle (Ord a) => a -> a -> a -> Bool
07:58:36 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
07:58:36 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
07:58:36 <lambdabot> Data.Sequence update :: Int -> a -> Seq a -> Seq a
07:58:41 <quicksilver> because the context isn't strictly smaller than the head, I think
07:58:43 <Peaker> I wonder how inRange is missing :P
07:58:51 <quicksilver> so instance resolution doesn't obviously terminate.
07:59:02 <Peaker> maybe   isSorted :: Ord a => [a] -> Bool       could be nice
07:59:17 <Peaker> can use that to check x<y<z<w
07:59:22 <Peaker> Oops, <=
07:59:48 <maltem> :t inRange
07:59:49 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
08:00:10 <maltem> (maybe *someone* knows why it requires Ix)
08:00:12 <quicksilver> :t \l -> and (zipWith (<=) `ap` tail $ l)
08:00:14 <lambdabot> forall a. (Ord a) => [a] -> Bool
08:00:14 <Peaker> maltem: oh, right. Though Ix is a bit more than Ord.  That could really be just Ord a there?
08:00:20 <Peaker> @src Ix
08:00:20 <lambdabot> class (Ord a) => Ix a where
08:00:20 <lambdabot>     range           :: (a,a) -> [a]
08:00:20 <lambdabot>     index           :: (a,a) -> a -> Int
08:00:20 <lambdabot>     inRange         :: (a,a) -> a -> Bool
08:00:20 <lambdabot>     rangeSize       :: (a,a) -> Int
08:00:24 <quicksilver> Ix is totally diferent from ord.
08:00:39 <Peaker> Hmm.. Given (Ord a), you can implement inRange trivially, no?
08:00:52 <Peaker> why is the it in the typeclass?
08:00:55 <Peaker> @src inRange
08:00:56 <lambdabot> Source not found. :(
08:01:00 <Peaker> with no default?
08:01:09 <lilac> Peaker: why does Ix have Ord as a superclass?
08:01:21 <Peaker> lilac: no, given Ord as a superclass, why does it need the inRange method?
08:01:26 <lilac> answer to both: error in the prelude
08:02:00 <Peaker> lilac: if it didn't have Ord as superclass, you'd need inRange, with inRange you can implement Ord, so it should probably have it as a superclass :)
08:02:10 <Peaker> lilac: (and not as a method)
08:02:48 <lilac> inRange isn't sufficient to implement Ord, I think.
08:03:05 <Peaker> > zip [] undefined
08:03:06 <lambdabot>   []
08:03:07 <lilac> it's sufficient to implement Eq though
08:03:42 <Peaker> lilac: With just (>) you can implement (<) (flip) and then (==) (test if its both not (>) and not (<)
08:03:50 <maltem> also, why is 'range' not identified with enumFromTo?
08:03:55 <lilac> Peaker: how do you implement (>) with inRange?
08:04:11 <Peaker> lilac: Oh you'd also need Bounded :)
08:04:37 <pozic> quicksilver: http://paste.debian.net/26136/ with generalized reader argument not working
08:04:48 <lilac> Peaker: right ;-)
08:05:09 <loadquo> Anyone know why I'm getting ^? when pressing del using ghci v 6.10.1 (self compiled)
08:05:43 <loadquo> Actually backspace, not delete. Delete is ^[[3~
08:05:44 <Peaker> > let isSorted xs = all (uncurry (<=)) $ zip xs (tail xs) in both isSorted ([1,2,2,3], [1,3,3,2])
08:05:46 <lambdabot>   (True,False)
08:05:51 <Saizan> loadquo: you didn't install libedit on your system
08:06:06 <maltem> (to answer my own question, probably because enumFromThen can potentially be complex and unneeded)
08:06:07 <sleven> pred is a dumb choice since it cna be predicate
08:06:10 <Saizan> ?hackage ghci-haskeline
08:06:11 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ghci-haskeline
08:06:15 <Peaker> > let isSorted xs = all (uncurry (<=)) $ zip xs (tail xs) in isSorted []
08:06:17 <lambdabot>   True
08:06:27 <Saizan> loadquo: i'd install that ^^^
08:06:31 <quicksilver> Peaker: the Ord instance version of inRange is entirely different from the Ord version.
08:06:37 <sleven> can IntMap take a tuple as key?
08:06:41 <quicksilver> Peaker: damn, I didn't say that well.
08:07:01 <quicksilver> Peaker: the Ord inRange (you would write) is entirely different from the Enum inRange
08:07:17 <quicksilver> Ix.
08:07:20 <quicksilver> damn type classes.
08:07:23 <quicksilver> s/Enum/Ix/l
08:07:57 <quicksilver> Peaker: you missed with zipWith(<=)`ap`tail then?
08:08:10 <loadquo> Saizan, thanks I'll give it a go.
08:08:21 <sleven> quicksilver: the listArray seems to work wierdly, it lets me index the same index with (2,2) and (1,5) in a 3*3 matrix
08:08:31 <quicksilver> sleven: yes, I replied to you.
08:08:39 <quicksilver> 15:54 < quicksilver> sleven: yes, that's a weakness.
08:08:39 <quicksilver> 15:55 < quicksilver> sleven: it doesn't do careful checking on both indexes.
08:08:40 <quicksilver> 15:55 < quicksilver> some people consider this a bug.
08:08:40 <roconnor> ah zipWith(<=)`ap`tail the Aztec god of sorted lists
08:08:52 <Peaker> quicksilver: that confuses me :)
08:09:11 <quicksilver> sacrifice a java programmer to zip`ap`tail
08:09:17 <quicksilver> he will grant you enlightenment in return for blood
08:09:19 <Peaker> > zipWith (<=) <*> tail [1,2,3]
08:09:20 <lambdabot>   Couldn't match expected type `[a] -> [a]'
08:09:37 <sleven> http://hpaste.org/13994
08:09:55 <roconnor> > zipWith (<=) <*> tail $ [1,2,3]
08:09:56 <lambdabot>   [True,True]
08:10:07 <sleven> ah sorry quick, so I guess I have to check by myself, do you know how it does it?
08:10:25 <Peaker> > (zipWith (<=) `ap` tail) [1,2,3]
08:10:27 <lambdabot>   [True,True]
08:11:09 <quicksilver> sleven: get the bounds as (r,c) and then check x<=r and y<=c
08:11:10 <quicksilver> ;)
08:11:34 <quicksilver> pozic: I think the problem is you've promised "test" is fully polyrmophic over the reader type
08:11:43 <quicksilver> pozic: but then you use "k" which has a specific reader type of Bool
08:11:55 <quicksilver> pozic: however I have some other stuff to do I'm afraid I can't help you much more. Good luck!
08:12:33 <Peaker> (zipWith (<=) <*> tail)  is not very readable PL style :-)
08:13:23 <idnar> @type zipWith (<=) <*> tail
08:13:24 <lambdabot> forall a. (Ord a) => [a] -> [Bool]
08:14:02 <quicksilver> Peaker: it's OK. It's just a question of grokking the (->) monad
08:14:13 <quicksilver> I agree that the (->) monad looks odd until you get used to it
08:14:19 <quicksilver> but lots of things look odd until you get used to them.
08:14:32 <quicksilver> it's just a question of deciding where you want to set the bar for your readers (and yourself)
08:14:56 <quicksilver> a mixture of <$> <*> and `snap` looks pretty odd at first glance.
08:15:16 <idnar> snap?
08:15:33 <Peaker> quicksilver: Well, I like the (->) monad usually..  ap/<*> are still confusing though, when used in conjuction with partial application
08:17:09 <Peaker> quicksilver: I understand it, but it requires a lot more brain power to understand it than the pointful style.  Maybe I'll get used to it, haven't tried ap in the (->) monad a lot yet
08:17:51 <Saizan> yeah, snap?
08:19:52 <loadquo> :type snap
08:20:05 <quicksilver> snap is the combinator for snapshotting the value of a behaviour at the discrete times given by an event.
08:20:11 <quicksilver> it's part of FRP which Peaker knows.
08:20:28 <quicksilver> It was just an example of "to learn stuff you need to learn stuff, and once you know the vocab it's not scary any more"
08:21:31 <loadquo> Speaking of vocab, has anyone thought to call monads something different?
08:21:54 <Peaker> my suggestion for Functor, Applicative, Monad -> Mappable, StaticSequentiable, DynamicSequentiable
08:22:13 <quicksilver> SPJ has gone on record as saying he wished he'd called them "Warm Fuzzy Things", loadquo
08:22:35 <doserj> Mappable, ???, Bindable
08:23:08 <Heffalump> F# chose a different name but seems to have ended up with a confused picture of lots of different names.
08:23:20 <Heffalump> (workflows, computation expressions, some others I forget)
08:23:27 <vixey> abstract computation factories
08:23:50 <lilac> Apply, GenApply, Join ?
08:24:03 <loadquo> I sometimes wonder what Monads have to do with Leibniz's philosophy, which I am fairly fuzzy on as well.
08:24:57 <SyntaxNinja> dcoutts: that's crazy re; configure
08:25:03 <Peaker> doserj: ??? = Sequentiable
08:25:23 <dcoutts_> SyntaxNinja: more details: http://hackage.haskell.org/trac/hackage/ticket/458
08:25:24 <BMeph> loadquo: They're not That Kind of Monad. ;)
08:25:31 <Peaker> doserj: Bindable is a bit arbitrary, why not Joinable?   DynamicSequentiable is the "essence", it can be sequenced like Applicative, but in a dynamic fashion
08:25:41 <Saizan> loadquo: they are unrelated, the CT term Monad comes from monoid and triad (they say, at least)
08:25:51 <Peaker> lilac: why GenApply?
08:25:54 <dcoutts_> SyntaxNinja: if you've got any suggestions on how to clean up the interaction with configure scripts and env vars I'd appreciate it
08:26:36 <lilac> Peaker: it allows the function to be generalized, in the same way that Functor allows the value to be
08:26:43 <gwern> loadquo: sometimes we call monads Warm Fluffy Things
08:26:43 <doserj> Peaker: Bindable is closer to the do-notation
08:26:57 <lilac> @type (<*>)
08:26:59 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:27:16 <lilac> Peaker: although i'd split out Pointed as a separate typeclass
08:27:31 * lilac sometimes thinks things would be better if typeclasses were allowed only one method
08:27:32 <Saizan> Sequentialbe is a bit misleading, you get the risk of making people think monads are about evaluation order
08:27:57 * lilac thinks DoNotation is a pretty good name for Monads
08:27:58 <Peaker> lilac: then we need class aliases or some mechanism that allows us to only implement pure, (>>=) rather than 4-6 different methods
08:27:59 <vixey> how about KleisiTripleable
08:28:05 <lilac> Peaker: true
08:28:15 <lilac> would that be so terrible? ;-)
08:29:48 <conal> Peaker: <*> (ap) in the function Applicative is the classic S combinator.  it's also the essence of continuous, deterministic concurrency.
08:30:41 <alexeevg> Hi all. May I ask a stupid question? In order to darcs send my first trivial patch to cabal-devel@haskell.org, I've installed sendmail (sudo apt-get install sendmail on my Ubuntu box). Can I expect darcs send to work without any configuration? darcs says 'patch bundle send successfully', but I cannot see the relevant message in the mailing list
08:30:47 <Peaker> conal: Still, I am not used to it enough to find  zipWith (<=) `ap` tail   as readable as  zipWith (<=) xs (tail xs)   (Will try to get used to it though)
08:31:20 <Saizan> alexeevg: you've to configure sendmail with your email account
08:31:35 <Saizan> s/with/to use/
08:31:47 <dcoutts_> alexeevg: my recommendation is to use ssmtp, it's a trivial relay. It requires only one piece of configuration, to tell it what your ISP's outgoing stmp server is. In addition you need to be subscribed to cabal-devel to post to it.
08:32:10 <conal> Peaker: internalizing S, like many things, probably just takes experience.  mysterious until sudden enlightenment.
08:32:34 <alexeevg> dcoutts_: thanks, I'll try that. Meanwhile my patch is attached to the ticket description in the Trac
08:32:41 <alexeevg> #317
08:32:45 <dcoutts_> alexeevg: ah yes, thanks.
08:33:03 <quicksilver> Peaker: the reason I don't like Sequentiable is that I think that putting sequencing at the core of the idea is an damaging meme
08:33:10 <conal> Peaker: and it might help a bit to add parens to the pointful form: \ xs -> ((zipWith (<=)) xs) (tail xs)
08:33:14 <lilac> > fix ((0:).(1:).(zipWith (+) <*> tail))
08:33:17 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:33:20 <quicksilver> some applicatives really dont' have much to do with sequencing
08:33:24 <Peaker> quicksilver: The sequencing is allowed to be meaningless
08:33:29 <quicksilver> sure
08:33:29 <conal> Peaker: to emphasize the pattern \ a -> (f a) (g a)
08:33:33 <quicksilver> then it's a meaningless name
08:33:36 <quicksilver> how is that better than monad?
08:33:40 <quicksilver> another meaningless name? ;)
08:33:49 * lilac suggests DoNotation again
08:33:53 <Peaker> conal: Yeah, I understand the pattern and use of ap, I still have to think to read it, though
08:34:02 <doserj> applicative is actually a quite fitting name
08:34:37 <conal> perhaps the search for meaningful names for type classes is inherently misguided.  the power of this kind of abstraction is that they (type classes) cut across meanings.
08:35:27 <quicksilver> conal: yes.
08:35:28 <conal> which also explains to me why they don't fit into module hierarchies
08:35:32 <doserj> conal: but they do have something in common, otherwise there is no use in defining them
08:35:49 <dcoutts_> alexeevg: one suggestion about that patch, perhaps construct a exeBi' and pass that to constructGHCCmdLine rather than mixing it all into the same line
08:35:51 <jkff> conal: I'd disagree. Their power comes from the fact that they have something in common and, in order to hold them in your head and to reason about them, it suffices to keep in mind that common part
08:35:53 <conal> doserj: that's right.  they do have commonality.  just not in "meaning"
08:36:05 <leimy> what do haskellers typically do when they feel the need to add print statements to a program for debugging purposes?
08:36:06 <BONUS> mostly they have commonality in the laws they obey imho
08:36:12 <conal> jkff: i think you really agree.
08:36:22 <BONUS> but a bunch of laws are hard to put into one word
08:36:24 <leimy> It seems a lot of work to add Writer or WriterT after the fact
08:36:25 <conal> jkff: there is commonality.
08:36:29 <BONUS> so i think names like monad and monoid are kewl
08:36:31 <bastl> i want to disassemble a complex term by pattern-matching in a let-clause: Myconstructor newVar =  oldTerm. It compiles fine, but complains about "irrefutable pattern failed". IRC irrefutable means that the pattern matches always. But how can the input be wrong in a strict language?
08:36:37 <Saizan> what the instances have in common can be enough abstract that you don't have a name for that
08:36:44 <jkff> leimy: Debug.Trace
08:36:50 <SyntaxNinja> dcoutts_: I'll check it out...
08:36:53 <leimy> hmmm I'll take a look
08:37:08 <dcoutts_> alexeevg: one suggestion about that patch, perhaps construct a exeBi' and pass that to constructGHCCmdLine rather than mixing it all into the same line
08:37:16 <dcoutts_> alexeevg: ooops, sorry
08:37:28 <leimy> jkff: Debug.Trace.trace?
08:37:33 <jkff> leimy: Yes
08:37:36 <leimy> seems like it does some unsafeIO but I think that's ok
08:37:44 <conal> if people aren't used to thinking as abstractly as abstract algebra, they probably don't have any word at all for the abstract notion.
08:38:05 <jkff> Yes :) It prints a message when its argument gets evaluated.
08:38:10 <Saizan> bastl: irrefutable means that it behaves like it has matched until you actually look at the variables in the pattern
08:38:17 <leimy> conal: before I learned about OOP, I had to learn OOP to really understand the concepts of programming in that way
08:38:19 <alexeevg> dcoutts_: ok, I'll do that
08:38:28 <leimy> conal: I feel that if you're looking at a Monad, you should call it a Monad :-)
08:38:34 <Saizan> bastl: at which point it throws that error if the pattern doesn't match
08:38:38 <dcoutts_> alexeevg: I was thinking of something like: let exeBi' | compilerVersion c < Version [6,10] [] = ... | otherwise = exeBi
08:38:57 <conal> leimy: circular argument?
08:38:58 <leimy> Haskell can be lazy programming, but the language isn't for the lazy :-)
08:39:23 <leimy> conal: is it?  I'm not sure.  I'm thinking that when I was approached with a new way to code, I had to learn the concepts in order to put them to use.
08:39:23 <niukas> HI PEOPLE PLEASE SEN TELL ABOUT IT STOP DEATH STOP KILLSTOP EAT-WE EAT DEATH BECOUSE WE DIEING IT INNORMAL DEATH IS BAD DEATH MAKE BAD PEOPLE IN EARTH STOP DEATH!!!!
08:39:33 --- mode: ChanServ set +o dcoutts_
08:39:49 <leimy> is that a markov chain generator?
08:39:50 <loadquo> Leimy, I've been thinking about that, and thinking that I would add a Maybe writer to my main state class, and a function in the state that wrote a change. And I could change it to Nothing when I didn't want to log.
08:40:19 <leimy> loadquo: yes, had I thought of that ahead of time, that would have been brilliant :-)
08:40:29 <leimy> but then I'd have to write all my code with Maybe, and Maybe is bad for laziness no?
08:40:31 <sleven> what can I do with docmode in emacs? is it possible to automatically insert type-declarations?
08:40:33 * jkff starts reading Cabal Source Guide and heads for an assault on an easy ticket
08:40:45 <dcoutts_> alexeevg: and to be honest, since it's just a hack, I would not make it so generic with so many reusable functions sprinkled round the code. One bit with a comment where it does a list comprehension with constants like "-threaded" would be fine.
08:40:57 <dcoutts_> jkff: yay
08:41:31 <niukas> IN EARTH IS BAD WORDS AND WIEWS STOP WRITE BAD WORDS AND PICTURES NO BAD WORDS NO EVILLE
08:41:46 <elbar> ...
08:41:56 <alexeevg> dcoutts_: hmm, list comprehension doesn't do IO, and we have to warn the user
08:41:59 <Badger> Functional programming attracts madmen.
08:42:18 <smarmy> or it turns them mad
08:42:48 <alexeevg> but I see your point about too many not-so-reusable functions
08:42:52 <dcoutts_> alexeevg: true, you still need the warn in a separate place, but it's at least a bit more localised. hacks want to be self-contained.
08:43:08 <Peaker> leimy: why would Maybe be bad for laziness?
08:43:36 <leimy> I don't know I came across ways in which Maybe was a way to screw up laziness somewhere :-)
08:43:41 <loadquo> leimy, depends what you are writing. I'm writing something where I need to pass an array most times, so I'll just add a Maybe Writer/logger to data type and I can log changes to it. It should be hidden in there most of the time.
08:43:41 <leimy> but I forget the details.
08:43:44 <leimy> and lost the page reference
08:43:54 <Peaker> leimy: if you pattern-match against Nothing, you might force the whole computation to complete to know that its not going to fail anywhere
08:44:02 <conal> Peaker: any multi-constructor type thwarts laziness.
08:44:15 <leimy> Peaker: that may have been the problem
08:44:22 <leimy> I tend to use Maybe stuff with MonadPlus
08:44:33 <leimy> with `mplus` specifically
08:44:39 <Peaker> conal: how do you represent failures without the multi-constructors?
08:44:52 <leimy> Peaker:  lists ;-)
08:44:53 <lilac> Peaker: use 'error' and 'catch' ;-)
08:44:55 <leimy> empty list is fail.
08:45:04 <dcoutts_> jkff: you know one that would be really useful, though is slightly less trivial is http://hackage.haskell.org/trac/hackage/ticket/262
08:45:09 <lilac> leimy: that's multi-constructor too though
08:45:15 <conal> Peaker: that multi-constructor problem is what i encountered with Reactive recently, and why i restructured time.
08:45:21 <lilac> leimy: [] is fail, (:) is success
08:45:23 <Peaker> leimy: having a (partial results, error here) is possible too
08:45:25 <evident> hi everybody
08:45:26 <dcoutts_> jkff: ie detecting when C libs and headers are installed, using the same technique that autoconf ./configure scripts use.
08:45:29 <sleven> hmm my mouse does some wrei
08:45:31 <sleven> weir jumps sometimes, could soemone be remotely controlling it?
08:45:32 <leimy> lilac: ah yes.
08:46:00 <dcoutts_> jkff: constructing code to do that would be relatively independent of cabal, then integrating it could be done by someone who knows the code better.
08:46:12 <Badger> sleven: that's just the NSA
08:46:17 <Badger> don't mind them
08:46:23 <leimy> conal: what did you do to restructure them, or is that in your blog?
08:46:27 <leimy> s/them/time
08:47:05 <evident> could anyone of you please tell me an easier way to check whether either 2,3 or 5 is element of a list than: elem 2 list || elem 3 list || elem 5 list ?
08:47:19 <Gracenotes> hm. there is a rule allowing (λx . f x) -> f, I'd think. *looks*
08:47:20 <Peaker> conal: say, if I have a   Monoid m => Behavior m  that I build with accumB mempty (fmap mappend someEventSource) -- it will only mappend once for each event, right?  If the Monoid here is a Geometry3 -- and it slowly grows, will drawing become heavier and heavier? Is there a better way?
08:47:21 <conal> leimy: it's not on my blog yet, nor in the relased version, until i have the new ghc working (with concurrency fixes).
08:47:30 <Raevel> evident: all (`elem` list) [2,3,5]
08:47:37 <evident> ahhh ok thanks
08:47:38 <evident> :D
08:47:44 <conal> leimy: i replaced AddBounds (Improving t) with Improving (AddBounds t)
08:47:46 <vixey> any (`elem` [2,3,5]) list
08:47:47 <Saizan> Gracenotes: eta-reduction
08:47:54 <sleven> why do i get ambiguous occurcen when calling a function transpose if Data.List is import as DL?
08:47:56 <leimy> conal: Cool.  I really need to take some time to work with reactive... right now I don't know where to begin with it. :-)
08:47:58 <Raevel> oh right, any
08:48:01 <Gracenotes> Saizan: only via beta reduction?
08:48:07 <evident> got it
08:48:08 <evident> :D
08:48:09 <evident> thx
08:48:14 <evident> how stupid of me
08:48:14 <evident> ^^
08:48:25 <Deewiant> sleven: you didn't import it qualified?
08:48:30 <Saizan> Gracenotes: it's called eta, not beta
08:48:50 <Gracenotes> no, but I'm supposed to derive something from something via only beta reduction
08:49:00 <Saizan> ah
08:49:26 <sleven> how do I switch to postfix?
08:49:33 <sleven> import qualified Data.List as DL
08:49:39 <quicksilver> sleven: it's in the prelude, too
08:49:43 <quicksilver> I suspect.
08:49:45 <sleven> DL.transpose and the other fucntion is called transpose
08:49:46 <Deewiant> @index transpose
08:49:46 <lambdabot> Data.List
08:49:49 <sleven> but not in ghci
08:50:19 <conal> leimy: it'll be more fun soon.  when we're past this rts bug.
08:50:26 <Gracenotes> Saizan: multiplication, (λx . (λx . f^m' x)^n' x) -> (λx . (f^m')^n' x)?
08:50:42 <leimy> conal: cool... I'm always looking for ways of dealing with interaction without IO :-)
08:50:54 <conal> leimy: glad to hear it!
08:50:56 <Peaker> conal: I am using Geometry3 because Geometry2 seems to have incomplete support. Would it be possible to perhaps force FieldTrip to render stuff, so mappend can be used between renders - so it doesn't become slower and slower to render my game state?
08:51:09 <leimy> conal: I rewrote my bowling program to use a form of interact.
08:51:22 <leimy> but ended up not getting it quite right as I wanted interactive output too
08:51:27 <jkff> dcoutts_: Just saying that I read your messages and didn't ignore them :) The ticket seems very important to me too, I'll think about it after I get acquainted with cabal source and do some exercises with it
08:51:31 <Gracenotes> hrm. I'll just assume that for now...
08:51:39 <leimy> I guess I could have used Writer
08:51:40 <dcoutts_> jkff: ok :-)
08:51:56 <leimy> Forcing things to evaluate in chunks seems tricky
08:52:00 <dcoutts_> jkff: I'm around to answer questions, review code etc
08:52:00 <conal> leimy: nice.  have you seen TV?  it generalizes interact into an algebra and to other forms of interaction.
08:52:03 <Gracenotes> oh. wait.
08:52:15 <leimy> conal: no I haven't... got a link?
08:52:15 <maltem> conal: I've just had a quick look at reactive-fieldtrip, as a gateway drug to FRP I thought, and for some reason, the sample animations work when invoked from ghci, but if run stand-alone, all I get is a black window... Did I miss something
08:52:26 <conal> @wiki TV
08:52:26 <lambdabot> http://www.haskell.org/haskellwiki/TV
08:52:34 <leimy> Thanks!
08:52:38 <pozic> Does anyone know how to generalize http://hpaste.org/13993 to that test doesn't mention Bool anymore, but works for any type?
08:52:39 * maltem delivers a final ?
08:52:59 <conal> Peaker: render into images?
08:53:37 <conal> maltem: no, i haven't seen that behavior.  would you mind making a ticket on the FieldTrip trac?
08:54:07 <maltem> conal: ok, but what information should I put there, other than that it doesn't work?
08:54:27 <lilac> pozic: eww, you're using fail ;-(
08:54:39 <sleven> how can I open an image(jpg, png etc) in Haskell? ie in binary
08:55:05 <conal> maltem: what you just said to me, plus your OS and whether you're using glut or freeglut.  that way it won't fall through the cracks.
08:55:32 <pozic> lilac: no, I am not.
08:55:33 <Peaker> conal: Some finite representation of an image, for a decently-performing mappend
08:55:41 <davidL> has anyone here used haskell to program microcontrollers?
08:55:49 <Peaker> conal: Or more exactly, for a decently performing re-application of mappend/render
08:56:14 <pozic> But I think I solved it! :)
08:56:31 <conal> Peaker: i'd guess that the current implementation performs well.  do you have any evidence that it doesn't ?
08:56:54 <niukas> HEJ PEOPLES HELP -TELL AROUND THE WORLD WHAT WE DIEING STOP MAKE DEATH STOP KILL ANIMALS PLANTS WATER METALL ANOTHER PEOPLES BAD PEOPLES MAKE THIS WORLD WE CAN LIVE FOREVER WIT NATURE WITH GOD WITH UNIVERSE PIECE
08:56:56 <conal> Peaker: in particular, dynamic tessellation caches.
08:56:56 <niukas> STOP KILL STOP DEATH
08:56:58 <lilac> pozic: do True <- ask
08:57:09 <ehird> niukas: OK, I stop make death.
08:57:18 --- mode: ChanServ set +o quicksilver
08:57:20 --- mode: quicksilver set +b *!*n=niukas@62.212.200.*
08:57:20 --- kick: niukas was kicked by quicksilver (quicksilver)
08:57:21 <ehird> And I live forever wit nature wit god with universe piece. Now what?
08:57:23 <Peaker> conal: Back when I had a working Reactive (I think I had lilac's hack in there, now it doesn't work) - I had written an initial version of my game, and it seemed to slow down as more graphics was mappended into the image being drawn
08:57:48 <conal> Peaker: that's inevitable isn't it? i mean regardless of implementation.
08:58:04 <Peaker> conal: Its possible to just draw the extra graphics on top of the existing surface and just have one single blit draw the whole thing
08:58:16 <Peaker> conal: that's what I have in my Python implementation of the game
08:58:22 <lilac> pozic: (that's where you're using fail)
08:58:41 <loadquo> I was reading these things as telegrams. However . Kill . Death  doesn't make much sense
08:58:47 <conal> Peaker: oh, okay.  it's really a 2D thing, with no dynamic pan & zoom.
08:58:52 <pozic> lilac: this is just something to test
08:58:52 <sleven> can't I declare functions to belong to a namespace?
08:58:57 <Peaker> conal: right
08:59:01 <quicksilver> "...and through strange aeons even death may die" ?
08:59:01 <lilac> loadquo: heh ;-)
08:59:04 --- mode: quicksilver set -o quile_
08:59:06 --- mode: quicksilver set -o quicksilver
08:59:12 <sleven> so I can have sum for my Matrix-moduel for exampel?
08:59:15 <pozic> lilac: getting this to work in the real thing is an order of magnitude more difficult.
08:59:16 <Peaker> conal: I could do it with Geometry2, but it seems plenty of stuff exists only for Geometry3 in FieldTrip that Geometry2 is not really usable
08:59:40 <lilac> loadquo: "Make death. Kill animals, plants, water, metal"
08:59:42 <conal> Peaker: i'm pretty sure that what you want can be done in an elegant & correct way.
09:00:11 <Peaker> conal: mappend between finite renders is one possible way :)
09:00:20 <quicksilver> Peaker: how could you render a geometry3 and then reuse it a frame later? what if position or lighting changed?
09:00:31 <conal> Peaker: there are nice formal properties (morphisms) relating 3D & 2D and relating continuous & discrete.
09:00:33 <Peaker> quicksilver: I want it for 2d graphics
09:01:14 <loadquo> lilac: Hehe, somehow not the message I think he was going for.
09:01:48 <Peaker> though maybe just redrawing everything shouldn't be that slow -- but it was.  The game just had drawn disks on a series of moving positions
09:02:02 <conal> Peaker: your app would perhaps be more confortable on top of an Image API.
09:02:06 <Peaker> after perhaps hundreds of positions, it was noticably slower
09:02:32 <roconnor> @seen mattam
09:02:33 <lambdabot> mattam is in #haskell and ##logic. I don't know when mattam last spoke.
09:02:39 <sleven> hmm can I somehow reuse ghci for my dsl? compile it and thenwhen it is started start ghci and allow functions only from the Matrix-module?
09:02:39 <sleven> btw it is already looking good :)
09:04:32 <sleven> i fakken lavv haskell
09:05:12 <Badger> @index '(==>)
09:05:12 <lambdabot> bzzt
09:05:27 <Badger> , index '(==>)
09:05:29 <lunabot>  luna: Not in scope: `==>'
09:05:53 <loadquo> This is just an example of something I've been wondering about. Lets say I want to make a parallel processing ray tracer that displayed each pixel as it came in (I don't care about the order they are displayed). How would I go about this?
09:06:27 <Badger> woops, that's just defined later.
09:06:51 <lilac> loadquo: forkIO each 'render a pixel' action
09:07:12 <loadquo> Thanks.
09:07:21 <pk> Peaker,  You want to add a new geometry3 without redrawing all the stuff in the background ?
09:07:41 <lilac> loadquo: mapM_ (forkIO . renderPixelAt) allPoints
09:08:01 <lilac> although i'm not sure how well the RTS performs with millions of green threads
09:08:21 <lilac> it would probably be faster to batch up the rendering
09:08:26 <Peaker> pk: I wouldn't mind doing this on top of a 2d API
09:08:36 <quicksilver> you can't efficiently render one pixel at a time on current graphics APIs
09:08:41 <Peaker> conal: Do you know of such an Image API that I could use?
09:08:54 <quicksilver> if you're rendering one pixel at a time you clamping your fill rate right down.
09:08:54 <loadquo> lilac: True, I was just wondering about the general pattern rather than the specifics.
09:09:10 <quicksilver> but what you'd do is stuff the pixels into a lump of memory as they come in
09:09:18 <quicksilver> and then redrew the whole thing at 30fps
09:09:19 <quicksilver> (say)
09:11:00 <sleven> ok haskell is friggin awesome
09:11:09 <sleven> give me the weekend and i have soemthing better than octave
09:11:16 <sleven> thanks for the pointers quicksilver
09:11:45 <quicksilver> you're welcome, enjoy.
09:11:54 <loadquo> quicksilver, I was thinking about a compute intensive raytracing where you wanted a progressive preview. So you could cancel it if it looked iffy, or something.
09:12:20 <quicksilver> loadquo: right, I'm just saying actually drawing one pixel at a time is nasty
09:12:26 <alexeevg> dcoutts_: I subscribed to the mailing list, installed ssmtp and sent patch with your suggestions taken into account, let's see if it goes through
09:12:38 <quicksilver> (you have threads fighting over the graphics context and single pixel draws are slow)
09:12:39 <dcoutts_> alexeevg: great
09:12:52 <quicksilver> loadquo: but I did give what I think is a decent way to achieve it.
09:13:03 <quicksilver> render to a memory buffer and draw that on screen very frequently
09:13:04 <loadquo> quicksilver: True double buffering for the win.
09:13:04 * alexeevg hopes that one day he'll fix more important ticket
09:13:07 <quicksilver> 60 times a second if you like.
09:14:17 <dcoutts_> alexeevg: if you're looking for important ones, any that are marked for the Cabal-1.6 or cabal-install-0.6 milestones are important.
09:14:33 <dcoutts_> alexeevg: see http://hackage.haskell.org/trac/hackage/report/12
09:15:07 <alexeevg> dcoutts_: I see. I needed something trivial to familiarize myself with the codebase
09:19:12 <int80_h> good morning #haskell!
09:19:29 <int80_h> ah hell, I just missed chessguy
09:20:49 <BMeph> int80_h: Um, nice to see you, too... ;)
09:20:58 <Twey> @pl \x -> x * x
09:20:59 <lambdabot> join (*)
09:21:03 * Twey frowns.
09:21:13 <Deewiant> Don't frown!
09:21:18 <Twey>     No instance for (Monad ((->) a))
09:21:19 * Deewiant hands Twey a chocolate lambda
09:21:24 <Twey> Oooh *nom*
09:21:29 * Deewiant hands Twey an 'import Control.Monad.Instances'
09:21:30 <ddarius> import Control.Monad.Instances
09:21:34 <Twey> Ah
09:21:48 <sleven> how do I convert from Int to Double?
09:21:51 <sleven> how do I convert from Int to Double?
09:21:54 <Twey> I remembered it was 'join', but I forgot that the instance was elsewhere :-P
09:21:54 <Deewiant> sleven: fromIntegral
09:21:57 <Twey> sleven: fromIntegral
09:22:03 <bjrn> Project Euler down?
09:22:09 <bjrn> (OT, sorry)
09:22:10 <conal> for parallel rendering, data-parallel haskell (dph) might be a good way to go.
09:22:15 <maltem> conal: ok this turned out to be a false alarm, I should have installed the {gl,glu,glut}-dev packages
09:22:21 <Deewiant> bjrn: http://www.downforeveryoneorjustme.com/projecteuler.com
09:22:29 <Deewiant> except that it was net, wasn't it
09:22:31 <Deewiant> but anyway :-P
09:22:35 <bjrn> Deewiant: Wow, that is awesome.  Thanks :)
09:23:20 <Twey> That site needs a shorter domain
09:23:43 <conal> maltem: oh!  glad to hear it.  then maybe a contribution to http://www.haskell.org/haskellwiki/FieldTrip#Problems_and_solutions
09:24:17 <joga> it's .net ...
09:24:50 <Badger> @index prinft
09:24:51 <lambdabot> bzzt
09:24:51 <Badger> er
09:24:54 <Badger> @index printf
09:24:54 <lambdabot> Text.Printf
09:24:57 <Badger> oh yes
09:25:04 <dons> dcoutts_: any chance cabal-install will be released now
09:25:05 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
09:25:15 <maltem> conal: on the way
09:25:40 <dcoutts_> dons: yes, I'm working up to point releases. Check the tickets still aimed for those milestones: http://hackage.haskell.org/trac/hackage/report/12
09:25:48 <dons> awesome.
09:25:52 <dcoutts_> dons: if there are any you think we should punt then tell me
09:26:00 <maltem> conal: fwiw I still have display problems with some of the examples, specifically those involving text, but I'll first have to examine this
09:26:01 <dons> i'm holding on updating HTTP 4 until cabal works with it.
09:26:18 <dcoutts_> dons: try the darcs version of cabal-install, it uses V4
09:26:19 <conal> maltem: thx.
09:26:22 <dons> ok.
09:26:30 <Peaker> I reported the bug that caused -lglut to be missing in various GLUT installations to the Haskell GLUT maintainer, but I got no response. I am not sure if he actually got it
09:26:50 <dcoutts_> Peaker: forward it to the libraries mailing list
09:27:24 <jkff> bjrn: the downforblablabla stuff doesn't know about projecteuler.net for some reason, but for me it is actually down.
09:27:54 <bjrn> jkff: Cheers. Hopefully it'll be back up later tonight
09:28:31 <hugo___> my boss insists on ordering a fiat, and i strive to deliver a ferrari :(
09:29:06 <Peaker> dcoutts_: will my mail go through without subscribing?
09:29:06 <hugo___> he doesn't understand why im using haskell, and stuff, and just keeps rushing things around
09:29:26 <hugo___> i guess ill deliver a fiat, and work on the ferrari at home
09:29:38 <Peaker> hugo___: your boss doesn't want to take unnecessary risks. He might be right - the other guys probably don't know Haskell
09:30:17 <Peaker> hugo___: you can "sneak Haskell in" the back door, but first teach your co-workers to be as excited about it as you are, maybe lecture about it, so the bosses agree to try it out
09:30:20 <dcoutts_> Peaker: no
09:30:54 * sw17ch employes the Intelligent Design wedge tactic with Haskell at work
09:31:15 <lilac> sw17ch: but we /know/ Haskell had a creator, right?
09:31:34 <hugo___> Peaker, im the only programmer here... he doesn't know a thing about programming, and so its hard to explain to him why im not using .net and mssql :/
09:31:36 <yottis> "we can try this to make a quick prototype..."
09:31:45 <dcoutts_> dons: since you wrote the curl configure.ac, perhaps you've got some ideas for this problem: http://hackage.haskell.org/trac/hackage/ticket/458
09:31:51 <mornfall> lilac: Oh, I have thought that Haskell rose from chaos. : - )
09:31:55 <Peaker> hugo___: ah, if its just you, then how does he even know? :)
09:32:00 <dons> mm
09:32:03 <dons> looking, dcoutts_
09:32:03 <sw17ch> lilac: exactly. I say "look how well designed this language was! the creator of it was a pretty sweet bunch of dudes/ladies. we should use this here so taht we can be sweet bunches of dudes/ladies as well"
09:32:24 <dcoutts_> dons: we could get rid of that configure if we did the checks for C libs ourselves.
09:33:06 <hugo___> he knows because i tell everything to him, "im using haskell", and explain him "haskell is the better solution in the long term, but not so many people know how to program"
09:33:32 <quicksilver> sw17ch: haskell. I chose it for the ladeez.
09:33:34 <lilac> sw17ch: sorry to be utahraptor to your t-rex, but wouldn't that mean that Haskell contains irreducible complexity?
09:33:43 <hugo___> actually there are two univs here that teach haskell... so i guess its no problem to get manwork if he wants another guy on the project
09:34:03 <lilac> ... thus requiring the understanding of the whole in order to fathom any part
09:34:16 <roconnor> Oh no!  Haskell was intellegently designed!
09:34:40 <sw17ch> lilac: obviously this isn't the case. most of haskell can be reduced to very simple axioms and rules. while components to a larger construct may appear to be useless on their own, it's eventually clear that they can fill a need on their own
09:34:44 <hugo___> oh well, back to code, sorry for the baffling :P
09:35:11 <int80_h> The problem with the word design, is it implies a designer.
09:35:52 <lilac> sw17ch: which is to say, apparent intelligent design may in fact arise from the concerted work of many point improvements?
09:36:29 <sw17ch> lilac: i guess what i'm saying is that Haskell is a consequence of evolution
09:36:58 <sw17ch> and evolution is very good at shaping things best suited for their environment! ergo, Haskell is best suited for this environment!
09:37:08 <sw17ch> i hereby prove that Haskell is perfect.
09:37:46 <leimy> so the Trace.Debug thing is totally failing to evaluate :-/
09:37:48 <ray> thereby*
09:38:24 <sw17ch> ray: oh no, i'm not properly evolved :(
09:38:32 <Deewiant> Does Hugs support GeneralizedNewtypeDeriving?
09:38:35 * sw17ch ends the metaphor..
09:38:42 <loadquo> Past suitability to the environment is no guarantee of future suitability...
09:38:59 <quicksilver> Deewiant: AFAIK, no.
09:39:08 <Deewiant> Meh, guess I'll do it manually then
09:39:17 <quicksilver> Deewiant: porbably one of the most annoying ommissions
09:39:21 <quicksilver> (and ought to be trivial to fix)
09:39:45 <MyCatVerbs> sw17ch: no. Evolution is a statistical effect. It only explains why things *tend* to be well suited to their environments.
09:39:48 <lilac> your local optimum is at risk if you do not keep up the search for global optima or other assumptions predicated on it
09:40:00 <sw17ch> MyCatVerbs: stop breaking my proof of perfection
09:40:10 <sw17ch> lilac: you too!
09:40:21 <MyCatVerbs> sw17ch: even the 3rd law of thermodynamics can run in reverse for a little while if you're lucky enough. :)
09:40:21 <lilac> sw17ch: also, your argument would have been better if you'd used the word 'ergo' somewhere.
09:40:42 <sw17ch> didn't i?
09:41:28 <lilac> sw17ch: ah, so you did. i take that back, your argument is flawless.
09:41:35 <quicksilver> MyCatVerbs: and the protons/neutrons of iron "can" rearrange themselves into gold. :)
09:41:42 <quicksilver> MyCatVerbs: never seems to happen to me, though.
09:41:50 <sw17ch> huzzah!
09:42:22 <MyCatVerbs> quicksilver: entropy running backwards has been demonstrated, though. In very, very small systems; tiny enough that the odds get less fearsome.
09:42:26 <sw17ch> quicksilver: my car has managed to convert itself into at least 50% gold... of course this is a statistical oddity
09:44:15 <sw17ch> well... any way... thinking about the F# active patterns and constructor views... does any one have extended thoughts not yet covered in -cafe?
09:44:16 <quicksilver> MyCatVerbs: as you pointed out, this is a statistical effect. Unlikely events occur with precisely their own probability.
09:44:53 <lilac> quicksilver: on average ;-)
09:44:57 <KucukMubasir> !monad
09:45:17 <lilac> !!monad
09:46:30 <sleven> hmm if I want to implement my own ew I do this? instance Eq (Matrix matrix) where eq m = ...
09:46:39 <sw17ch> is there something specific that prevents constructor views from being created?
09:46:47 <sw17ch> or is it more that "we haven't gotten to that yet"
09:47:07 <lilac> sleven: instance Eq (Matrix matrix) where a == b = ...
09:49:04 <lilac> sw17ch: what's a constructor view?
09:49:27 <Gracenotes> { >n ?0 >a >f >b @ >a >b + @ >n -1 @ ? #n #b #a }f @ 0 @ 1 @ 1000 @  --enterprise-quality fibonacci numbers
09:49:53 <idnar> argh
09:50:02 <idnar> what language is that?
09:50:14 <ray> gracenotes language
09:50:22 <lilac> mmm, tasty enterprise quality fibonacci numbers
09:50:23 <Gracenotes> I haven't named it yet...
09:50:45 <elbar> @bf ++[-]
09:50:45 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
09:50:45 <leimy> is that like restaurant quality pasta?
09:50:50 <Gracenotes> { _ }f applies the Y combinator to what's inside, using f as the first argument
09:50:52 <joma> how do I map over 2 lists? is there no map2?
09:51:01 <sw17ch> lilac: in this case, it would be something that allows you to write a custom constructor, but also pattern match on it
09:51:03 <joma> i have to write one?
09:51:05 <vixey> joma, zipWith
09:51:12 <sw17ch> lilac: data A = A B C
09:51:35 <Gracenotes> ">n ?0" is boolean, ">a" is a result, and "(>f) (>b) @ (>a >b +) @ (>n -1) @" is a recursive call
09:51:43 <idnar> > zipWith f [a, b] [c, d]
09:51:44 <sw17ch> lilac: newview A' = (A B C) => (A' C)
09:51:44 <lambdabot>   Add a type signature
09:51:47 <idnar> erf
09:51:50 <idnar> > zipWith f [a, b] [c, d] :: [Expr]
09:51:51 <lambdabot>   [f a c,f b d]
09:52:11 <sw17ch> lilac: horrible syntax... but the idea is that you make a new constructor that hides or changes the behavior of the constructor it wraps
09:52:17 <sw17ch> simlar to a table view in SQL
09:52:20 <lilac> sw17ch: a' (A b c) = c;  foo (a' -> c) = ...
09:52:25 <lilac> sw17ch: -XViewPatterns
09:52:47 <vixey> , last (reverse -> (x:_)) = x in  last [1..10]
09:52:49 <lunabot>  luna: parse error on input `='
09:52:53 <vixey> , let last (reverse -> (x:_)) = x in  last [1..10]
09:52:57 <lunabot>  10
09:52:59 <vixey> like this ?
09:53:00 <sw17ch> lilac: can that be used to hide details of the A data type?
09:53:29 <lilac> sw17ch: yes, absolutely.
09:53:32 <joma> i dotn want to zip I want to add. map add [1,2,3] [4,5,6] -> [5,7,9]
09:53:42 <vixey> joma, zipWith
09:53:43 <MyCatVerbs> joma: withWith (+)
09:53:46 <idnar> > zipWith (+) [1,2,3] [4,5,6]
09:53:47 <lambdabot>   [5,7,9]
09:53:53 <MyCatVerbs> er... zipWith, not withWith. >_<
09:54:28 <idnar> MyCatVerbs: is with a specialisation of withWith? ;)
09:54:38 <lilac> sw17ch: but if you want refutable patterns, your view function needs to return something you can pattern match on
09:54:44 <MyCatVerbs> idnar: ...dagnabbit.
09:55:13 <lilac> sw17ch: x (left -> Just x) = ...; x (right -> Just x) = ...
09:55:17 <sw17ch> lilac: i kinda had a feeling view patterns could do something like this... i'll have to look more closely
09:55:35 <vixey> would be nice to write  x (left => x).. but you can't yet
09:55:59 <lilac> vixey: what would that mean?
09:56:00 <dons> ?bug
09:56:00 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
09:56:10 <vixey> lilac, just the same as what you wrote
09:56:21 <lilac> vixey: yeah, that'd be neat.
09:57:02 <sw17ch> view patterns apply the function to the argument and then pattern match on the result, right?
09:57:10 <lilac> sw17ch: right.
09:58:11 <sw17ch> sweet
09:58:22 <Gracenotes> oh! Maybe I should use zipWith to deal more easily with applying multiple function arguments!
09:58:47 <sw17ch> lilac: so, can you think of a way to match on a specialized constructor?
09:59:25 <sw17ch> lilac: data N = N Int Int; mkN v = N 1 v
09:59:36 <sw17ch> i' like to be able to match type N on the mkN constructor
09:59:39 <sw17ch> "constructor"
09:59:47 <sw17ch> f (mkN x) = x
10:00:29 <lilac> mkN' (N 1 v) = Just v; mkN' _ = Nothing;  f (mkN' -> x) = x
10:00:39 <lilac> f (mkN' -> Just x) -> x
10:00:58 <shag> how do I handle Ctrl+C in my haskell program?
10:01:10 <sw17ch> lilac: that does require exporting the N constructor then, right?
10:01:26 <lilac> sw17ch: no, you put mkN' into the same module as N
10:01:48 <sw17ch> ah, expor mkN' and then use the viewpatterns
10:01:48 <sw17ch> i see
10:01:56 * sw17ch still wishes for a more terse expression
10:02:23 <leimy> argh... yeah this Debug.Trace stuff isn't working well inside the state monad,
10:02:34 <leimy> at least it's making it very difficult to use.
10:04:26 <dons> 271 users have uploaded 3096 versions of 990 packages.
10:04:52 <dons> dcoutts_: want to time cabal-install 1.0 with Hackage 1k? :)
10:05:02 <dons> we can do some stats, look at the growth. celebrate the milestone
10:05:18 <lilac> sw17ch: i suppose "f (mkN' x) = x" is unambiguous -- but i'm not sure how you'd go about reusing the name "mkN"
10:05:21 <dcoutts_> dons: what do you mean by "Hackage 1k"?
10:05:24 <leimy> huh now it's working, wonder what I just did...
10:05:37 <dons> dcoutts_: 1k packages on hackage.
10:05:38 <dcoutts_> dons: oh, hitting 1000 distinct package
10:05:42 <lilac> sw17ch: if we could persuade GHC that it was invertible perhaps
10:05:44 <dons> :)
10:06:07 <dcoutts_> dons: it's a nice idea I doubt we can get a cabal-install that we can call 1.0 by then
10:06:38 <sw17ch> lilac: yeah, i'm probably asking something a lot more complex than i think it is :)
10:06:43 <dcoutts_> dons: after all, we're only 10 packages away
10:07:01 <dcoutts_> dons: I'll be lucky to get cabal-install-0.6.2 out by that milestone
10:07:09 <sw17ch> which is probably more than suited by view patterns (which are much more flexible, though slightly more syntactically cumbersome for this specific case)
10:07:35 * sw17ch suggests dcoutts_ mark all the bugs as features and call it cabal-install ME
10:07:41 <dcoutts_> heh heh
10:08:25 <Eelis> am i the only one who feels there's something fundamentally awkward about language-specific package management? it just seems so self-obsessed to say "screw all those general purpose package managers, we're _special_ and need our own stuff separate from the normal package manager!"
10:08:36 <dons> dcoutts_: just call it 1.0 :)
10:08:40 <dcoutts_> dons: hah
10:08:43 <joma> what si the common name for addition and subtraction (not including * and /) ?
10:09:08 <lilac> Eelis: awkward, yes. wrong (given the state of the art), perhaps not.
10:09:13 <dcoutts_> Eelis: there's two things there, one is that we explicitly designed cabal to allow translation into platform-specific package systems.
10:09:14 <mstr> Eelis: rubygems for example is great if you run windows
10:09:28 <Eelis> dcoutts_: that's good
10:09:53 <dcoutts_> Eelis: and the other thing is that there really are no cross-platform, cross-language build and package systems.
10:09:56 <elbar> Eelis: works ok with gentoo's portage system for example
10:10:03 <dcoutts_> Eelis: we're forced to do this
10:10:05 <lilac> joma: addition forms an abelian group. is that what you're looking for?
10:10:26 <Eelis> dcoutts_: ok, i can see how an argument can be made based on pragmatics
10:11:20 <mstr> being able to update software without waiting for a linux distro to package it is nice too
10:11:31 <roconnor> so what do we have to do to get haddock documenation for instances?
10:11:38 <dcoutts_> Eelis: remember that we need a build system and not just a package system. Using generic build systems (eg make) requires a lot of code to provide the language-specific bits. autoconf/automake does this for C/C++, but the make language is not great for programming language-specific functionality
10:12:16 <Eelis> dcoutts_: *shrug*, "runhaskell Setup.hs ..." has always served me well.
10:12:35 <Eelis> well enough that i feel no urge whatsoever to bother with cabal
10:12:48 <dcoutts_> Eelis: yes, but that's because it's using the cabal packaging meta-data
10:13:02 <dcoutts_> Eelis: runhaskell Setup.hs is Cabal
10:13:11 * SamB_irssi boggles at Eelis' claim
10:13:25 <Eelis> dcoutts_: but i don't even have cabal installed according to ghc-pkg
10:13:26 <joma> is there an easy way to express 3 nested for loops?
10:13:26 * Badger plays Boggle with SamB_XP 
10:13:31 <Badger> or, the other one.
10:13:54 <dcoutts_> Eelis: yes you do, it's called Cabal and it has come with ever haskell compiler for the last 3-4 years, ghc, hugs, nhc etc
10:14:03 <dcoutts_> Eelis: a more ideal system would be a build program with its own _decent_ programming language. Then the language / platform specific aspects would be libraries in that programming language.
10:14:06 <pk> @src show
10:14:06 <lambdabot> show x = shows x ""
10:14:09 <Eelis> dcoutts_: oh, capital C..
10:14:09 <pk> @src Show
10:14:09 <lambdabot> class  Show a  where
10:14:10 <lambdabot>     showsPrec :: Int -> a -> ShowS
10:14:10 <lambdabot>     show      :: a   -> String
10:14:10 <lambdabot>     showList  :: [a] -> ShowS
10:14:47 <Peaker> what calls showList?
10:14:53 <chessguy_work> @type uncurry (***) . (first f) . (second f)
10:14:54 <lambdabot> forall (a :: * -> * -> *) b c b' c' b1 d. (SimpleReflect.FromExpr (a b' c'), Show b1, SimpleReflect.FromExpr (a b c), Show d, Arrow a) => (d, b1) -> a (b, b') (c, c')
10:14:54 <ehird> Peaker: show.
10:15:01 <hugo___> bye
10:15:10 <Peaker> chessguy_work: what's the "f" there?
10:15:13 <Eelis> dcoutts_: are you aware of SCons?
10:15:22 <Peaker> @type \f -> uncurry (***) . first f . second f
10:15:23 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => (d -> a b c) -> (d, d) -> a (b, b) (c, c)
10:15:24 <chessguy_work> @type uncurry (***) . (first ?f) . (second ?f)
10:15:25 <lambdabot> forall (a :: * -> * -> *) b' c' b. (Arrow a, ?f::b -> a b' c') => (b, b) -> a (b', b') (c', c')
10:17:04 <dcoutts_> Eelis: there are loads of these kinds of tools, none of them are very good. They tend to have terrible programming languages and not track dependencies properly.
10:17:25 <chessguy_work> > let func = \f -> uncurry (***) . (first f) . (second f) in func (*) (1,2) (3,4)
10:17:26 <lambdabot>   (3,8)
10:17:36 <Eelis> dcoutts_: i've only used SCons for small projects, so i'll take your word for it
10:17:56 <dcoutts_> Eelis: for example some use existing imperative languages, eg shell, python. That's no good because the blobs of code are opaque, you cannot correctly track dependencies in them.
10:17:57 * chessguy_work forgot about first and second
10:18:45 <dcoutts_> Eelis: it may well work nicely for the use case it is designed for, after all Cabal works ok for Haskell projects. It's not a general tool though.
10:18:46 <chessguy_work> > second (*) (1,2) (3,4)
10:18:48 <lambdabot>   Couldn't match expected type `(t1, t2) -> t'
10:19:10 <chessguy_work> > second (*) (1,2)
10:19:11 <lambdabot>       Overlapping instances for Show (a -> a)
10:19:11 <lambdabot>        arising from a use of `s...
10:19:22 <chessguy_work> > second (*) (1,2) 3
10:19:24 <lambdabot>   Couldn't match expected type `t1 -> t'
10:19:40 <chessguy_work> @type second
10:19:42 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
10:20:06 <Eelis> dcoutts_: i don't follow that argument at all, but again, i've only ever used SCons for small C++ projects.
10:20:11 <chessguy_work> > second (1,2)
10:20:13 <lambdabot>       No instance for (Arrow (,))
10:20:13 <lambdabot>        arising from a use of `second' at <i...
10:20:55 <leimy> I've got a function that doesn't work in 6.10 that worked in 6.8
10:21:03 <leimy> and seemingly it's a bug in 6.10
10:21:11 <doserj> > second (*2) (1,2)
10:21:13 <lambdabot>   (1,4)
10:21:38 <leimy> http://hpaste.org/13995
10:21:55 <leimy> It starts allocating tons of memory
10:22:03 <leimy> and only shows "
10:22:11 <leimy> on 6.10, on 6.8 it does what I expect.
10:22:14 <dcoutts_> Eelis: for example SCons uses python for the custom build actions right? There's nothing stopping you from writing arbitrary actions in Python and then the system cannot correctly track dependencies and so rebuilds and parallel builds will not work correctly.
10:23:17 <Eelis> dcoutts_: you could write arbitrary actions, but then you'd be completely raping SCons. you'd really have to deliberately be screwing things up.
10:23:29 <Eelis> it totally goes against the way SCons is normally used
10:23:37 <roconnor> > Nothing `mplus` Just ()
10:23:39 <lambdabot>   Just ()
10:23:44 <Eelis> dcoutts_: it'd be like using unsafePerformIO
10:23:55 <leimy> so where do I want to report that bug?
10:23:55 <dcoutts_> Eelis: it's so easy to get wrong, we do it all the time with makefile, switching from shell to python does not make it any harder to make mistakes.
10:23:57 <roconnor> > Just 1 `mplus` Just 2
10:23:58 <lambdabot>   Just 1
10:24:03 <roconnor> > Just 2 `mplus` Just 1
10:24:03 <int80_h> http://hpaste.org/13973#a1
10:24:05 <lambdabot>   Just 2
10:24:21 <int80_h> could someone take a peek at my hpaste? This is problem 12 chapter3, RWH
10:24:50 <dcoutts_> Eelis: http://blog.well-typed.com/2008/08/whats-wrong-with-make/
10:24:52 <doserj> leimy: your code loops on my 6.8.2, too
10:25:09 <dcoutts_> Eelis: most of those points apply if you switch the build language from shell to python
10:25:22 <leimy> doserj: huh does it?
10:25:22 <koeien> int80_h: try (x:y:z:zs) instead of [x,y,z:zs]
10:25:32 * leimy compares it to something else
10:25:37 <koeien> int80_h: or, ((x,y,z):zs), depending what you mean
10:25:38 <Eelis> dcoutts_: thanks, i'll read it through
10:25:50 <doserj> leimy: are you sure about the definition of newval?
10:26:35 <koeien> int80_h: i think you mean (x:y:z:zs)   if i understand the comments by chessguy correctly
10:26:42 <leimy> doserj: yes I think so
10:26:53 <leimy> It's working on my laptop on 6.8.2
10:26:59 <int80_h> koeien: could you school me as to the difference between the two patterns?
10:27:23 <koeien> int80_h: yes, sure. [x,y,z] is just notation for (x:y:z:[])
10:27:51 <koeien> int80_h: which means x : (y : (z : []) )
10:27:59 <leimy> oops nope
10:28:01 <leimy> I see it.
10:28:06 <leimy> I transcribed poorly
10:28:24 <koeien> int80_h: so if you pattern match against [x,y, z : zs], you actually pattern match against a list with three elements, the first being x, the second y, the third a list (z:zs)
10:28:57 <int80_h> ah, I see
10:29:15 <koeien> int80_h: this is not what you want. you want to pattern match against a list with >= 3 elements, the first ones being x, y, z in that order, and then the rest, being zs
10:29:30 <int80_h> right now, I have an error for (x : y :z :zs) = ... . It says my patterns overlap.
10:29:44 <koeien> int80_h: patterns are matched from top to bottom
10:29:54 <koeien> int80_h: i do not think this is an error, merely a warning
10:30:05 <koeien> int80_h: since _ matches everything, the result will always be []
10:30:26 <int80_h> koeien: ah, I could fix this warning by switching the location of the patterns in the file
10:30:28 <koeien> int80_h: that is not what you want, and so ghc will complain
10:30:32 <koeien> int80_h: that's the fix, yes
10:31:27 <int80_h> koeien: hah, this is much simpler than my first attempt.
10:31:39 <int80_h> I seem to complicate things
10:31:42 <koeien> so chessguy made a typo in his comment
10:32:18 <koeien> ah yes, i see your first attempt :)
10:32:23 <koeien> pattern matching is very powerful
10:34:26 <int80_h> koeien: I think it's not quite right yet
10:34:46 <int80_h> koeien : but I have something to work from
10:35:23 <int80_h> koeien : I don't think all the cases he gave me collapse into _
10:35:28 <koeien> hmm
10:35:31 <koeien> that's possible
10:35:58 <int80_h> koeien: I gave the function a list of five point, and it returned a list of one direction
10:36:14 <koeien> int80_h: could you repost your code?
10:36:35 <koeien> so i can see what you have now?
10:36:43 <koeien> (i've looked up the problem in my copy of RWH by now)
10:37:05 <int80_h> koeien:sure. what it's doing is taking the first three points and returning a list of one Direction.
10:37:49 <koeien> you may have a problem with your recursive step. what is the argument of calcDirectionList there?
10:38:40 <int80_h> koeien: http://hpaste.org/13973#a2
10:39:10 <koeien> try to see what happens if you pass it [1,2,3,4,5]. it will match to (x:y:z:zs), and 'zs' will be [4,5]. the recursive call will be calcDirectionList [4,5], which will be []
10:39:34 <int80_h> koeien: I should get a type error, but I'll try
10:40:00 <koeien> but, you need to pass the function [3,4,5]. so you'll need to call calcDirectionList with (z:zs) instead of zs
10:40:46 <int80_h> koeien : I don't understand. I need to work with [PointXY]
10:40:48 <koeien> int80_h: yes, [1,2,3,4,5] is of course not of the correct type. but this was just to name the points
10:40:54 <int80_h> oooh
10:41:04 <koeien> sorry about that
10:41:45 <dcoutts_> dons: is h4sh dead? I'm just cleaning up a page on the hackage wiki about packages that are not on hackage yet.
10:42:15 <koeien> int80_h: do you see why you need (z:zs) ?
10:42:33 <int80_h> koeien: yes, zs is the rest of the list
10:42:47 <Deewiant> Gah! Data.IntMap isn't Traversable!
10:42:49 <int80_h> koeien: but I need another pattern for this to match to
10:43:07 <koeien> i don't think so
10:43:48 <koeien> hmm. i misread the question.
10:43:58 <sleven> how can I open a file in binary in haskell? i want to read in the pixels of images
10:44:22 <int80_h> koeien: let me make the change
10:44:25 <koeien> int80_h: suppose i want to do the example [a,b,c,d,e], where a,b,c,d,e are points
10:44:35 <int80_h> okay
10:45:07 <koeien> int80_h: then in the first case, i'll match against (x:y:z:zs), and we need to do calculate the turn made by [a,b,c]
10:45:31 <koeien> int80_h: that's ok; you did that. but in the next step, we need to caclculate the turn made by [b,c,d]
10:45:47 <int80_h> koeien: that's what I was saying, I need another pattern
10:45:54 <koeien> int80_h: so we have to pass [b,c,d,e] to our function in the recursive call
10:46:02 <Zao> sleven: http://hackage.haskell.org/packages/archive/bytestring/0.9.1.4/doc/html/Data-ByteString.html#28
10:46:03 <int80_h> ooooh
10:46:15 <int80_h> I get it
10:46:15 <koeien> int80_h: i.e. calcDirectionList (y:z:zs)
10:46:55 <mstr> is there a simple way to get crossproduct from 2 tuples?
10:46:57 <int80_h> koeien: now I have a type error
10:47:01 <koeien> :) ok
10:47:09 <koeien> int80_h: could you paste it?
10:47:10 <int80_h> hold on, I think I have this'
10:47:30 <int80_h> nope, I don't
10:47:35 <int80_h> okay I'll paste it
10:47:39 <sleven> how do I o the equivalent of nesting 3 for loops most elegantly in Haskell?
10:47:42 <sleven> how do I o the equivalent of nesting 3 for loops most elegantly in Haskell?
10:47:45 <Zao> mstr: Isn't it only defined in 3 and 7 dims?
10:48:00 <koeien> sleven: probably by a list comprehension
10:48:10 <paper_cc> sleven: comprehensions, folds, monadic syntax
10:48:10 <vixey> mstr, not sure what you mean
10:48:13 <koeien> > [(a,b,c) | a <- [0..1], b <- [0..1], c <- [0..1]]
10:48:14 <lambdabot>   [(0,0,0),(0,0,1),(0,1,0),(0,1,1),(1,0,0),(1,0,1),(1,1,0),(1,1,1)]
10:48:18 <Peaker> sleven: it probably depends what the for loops do
10:49:11 <int80_h> http://hpaste.org/13973#a3
10:49:22 <int80_h> koeien: did you see that?
10:49:26 <koeien> int80_h: you need parentheses around (y:z:zs)
10:49:39 <koeien> int80_h: remember, function application binds very strongly in Haskell
10:49:44 <int80_h> koeien: ah, I tried putting brackets around it
10:50:06 <koeien> int80_h: brackets are just sugar. [1,2,3] -> (1:2:3:[])
10:50:31 <koeien> int80_h: but [y,z,zs] is different from (y:z:zs)
10:50:48 <int80_h> koeien: it works!
10:50:52 <int80_h> thanks
10:50:52 <koeien> nice :)
10:51:16 <koeien> int80_h: i would write calcDirectionList xs = zipWith calcTurn xs (tail xs) (tail (tail xs))
10:51:23 <koeien> int80_h: but i'm not sure if that's clearer
10:51:28 <koeien> ehm, that should be zipWith3
10:51:30 <FunctorSalad> is there a way to derive typeable1 for an associated data family?
10:51:39 <int80_h> koeien: yeah, thats cheating. I'm working from a book
10:51:53 <FunctorSalad> "No family instance for `Packed'
10:51:53 <FunctorSalad>     In the stand-alone deriving instance for `Typeable1 Packed'"
10:52:10 <int80_h> koeien: if I had done it that way, I would have totally missed my lesson in pattern matching.
10:52:19 <koeien> int80_h: i know
10:52:20 <paper_cc> @pl \xs -> zipWith f xs (tail xs) (tail $ tail xs)
10:52:20 <lambdabot> ap (ap (zipWith f) tail) (tail . tail)
10:52:26 <paper_cc> ahem
10:52:44 * koeien bows to the pointless overlords
10:53:00 <paper_cc> aha, to the pointless bot-overlords...
10:53:09 <lilac> zipWith3 f <*> tail <*> (tail . tail)
10:53:15 <cnwdup> I can't make the newtype Mod a = M { runMod :: a -> a } an instance of type monad, can I? Using m >>= k = $ M \a -> runMod (k (runMod m a)) a gives a type mismatch for matching b against a.
10:53:54 <lilac> cnwdup: no, that's not even a functor.
10:53:59 <sw17ch> @pl (\type inference -> i wish c had type inference)
10:54:00 <lambdabot> i wish c had
10:54:04 <mstr> vixey: actually koeien gave the asnwer I needed :)
10:54:20 <vixey> what was it?
10:54:29 <mapreduce> Is RWH available as PDF or similar anywhere?
10:54:39 <vixey> :t liftA3
10:54:40 <lambdabot> forall a b c d (f :: * -> *). (Applicative f) => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
10:54:43 <cnwdup> lilac: Because a functor has to have a property of type a -> b?
10:54:51 <vixey> > liftA3 (,,,) [0,1] "xy" [True,False]
10:54:52 <lambdabot>       Overlapping instances for Show (d -> (a, Char, Bool, d))
10:54:52 <lambdabot>        arising...
10:54:55 <mstr> 20:48 <koeien> > [(a,b,c) | a <- [0..1], b <- [0..1], c <- [0..1]]
10:55:06 <vixey> > liftA3 (,,) [0,1] "xy" [True,False]
10:55:07 <lambdabot>   [(0,'x',True),(0,'x',False),(0,'y',True),(0,'y',False),(1,'x',True),(1,'x',...
10:55:14 <mstr> my bad about the terminology. I meant cartesian product 0:)
10:55:54 <Badger> @src (,,,)
10:55:54 <lambdabot> Source not found. You speak an infinite deal of nothing
10:56:04 <Badger> oh wait
10:56:05 <lilac> cnwdup: fmap :: (a -> b) -> (a -> a) -> b -> b. there aren't many inhabitants of that type.
10:56:07 <Badger> I am stupid.
10:56:11 <ski_> cnwdup : a functor `f' must allow a function `forall a b. (a -> b) -> (f a -> f b)'
10:56:28 <mstr> > [(a,b) | a <- [True, False], b <- [True, False]]
10:56:29 <lambdabot>   [(True,True),(True,False),(False,True),(False,False)]
10:56:37 <mstr> success
10:56:41 <cnwdup> ski_, lilac: thanks
10:56:49 <lilac> cnwdup: we can construct a value of type b as: 1) _|_, 2) the last argument (the result is id) or 3) calling the first argument.
10:56:50 <ski_> > liftA2 (,,) [True, False] [True, False]
10:56:51 <lambdabot>       Overlapping instances for Show (c -> (Bool, Bool, c))
10:56:51 <lambdabot>        arising fr...
10:56:59 <ski_> > liftA2 (,) [True, False] [True, False]
10:57:00 <lambdabot>   [(True,True),(True,False),(False,True),(False,False)]
10:57:05 <lilac> 3) requires a value of type a. that can come from 1) _|_, 2) fix 2nd argument
10:57:18 <mstr> what's liftA2?
10:57:27 <ski_> @type liftA2
10:57:28 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
10:57:49 <MoxJet> A for arrow?
10:57:54 <lilac> fmap id = id, ruling out 1, 3.1, 3.2.
10:57:55 <koeien> Applicative in this case
10:57:59 <vixey> A for Applicative
10:58:10 <ski_> mstr : it lifts a function of type `a -> b -> c' into a function of type `f a -> f b -> f c'
10:58:20 <cnwdup> lilac: I see.
10:58:26 <mstr> ah
10:58:46 <conal> we could resolve this "Monoid" debate by writing a toddler book called "A is for Applicative"
10:58:46 <koeien> > liftA2 (*) (Just 37) (Just 37)
10:58:47 <lambdabot>   Just 1369
10:58:56 <ski_> mstr : so, if you have a function that combines and `a' and a `b' into a `c', then you can use `liftA2' to combine a list of `a's and a list of `b's into a list of `c's
10:59:06 <koeien> yeah, that's the combination of my luggage!
10:59:09 <ski_> (mstr : and that happens to be by "cartesian product")
10:59:42 <Peaker> Could be nice if record fields defined a semantic editor, and not just a getter.  Something like: data Tuple = Tuple a b where { fst(first) :: a, snd(second) :: b}
10:59:43 <ski_> (conal : "Monoid" debate ?)
11:00:09 <conal> ski_: the long tread on haskell-cafe about whether to use abstract terminology for abstract notions.
11:00:15 <ski_> t {fst = 4}
11:00:37 <conal> oops -- my bias is showing.
11:00:40 <mstr> ski_: so "," is a function?
11:00:42 <Peaker> ski_: I want   first (*2)  and such
11:00:49 <ski_> conal : .. what would one otherwise use ?
11:01:00 <ski_> mstr : `(,)' is a function that pairs, yes
11:01:02 <ski_> @type (,)
11:01:03 <lambdabot> forall a b. a -> b -> (a, b)
11:01:04 <conal> ski_: read the thread
11:01:06 <ski_> > (,) 2 False
11:01:07 <lambdabot>   (2,False)
11:01:13 <koeien> conal: could you point me to the thread? is it 'comments from OCaml Hacker Brain Hurt"?
11:01:29 <conal> koeien: that sounds right.
11:01:36 <koeien> thanks
11:02:04 <mstr> > liftA2 (,) [1..3] [1..3]
11:02:05 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
11:02:12 <mstr> oh cool
11:02:18 <mstr> > liftA2 (*) [1..3] [1..3]
11:02:20 <lambdabot>   [1,2,3,2,4,6,3,6,9]
11:03:11 <ski_> > liftA2 (\x y -> 100*x + y) [1..3] [1..3]
11:03:12 <lambdabot>   [101,102,103,201,202,203,301,302,303]
11:03:37 <mstr> what's the backslash for?
11:03:44 <mauke> λ
11:03:54 <mstr> \x
11:03:56 <lament> poor man's lambda
11:04:17 <conal> the word "do" is an example of using concrete/specific terminology for an abstract notion.  as is "mappend"
11:04:48 <ski_> > liftA2 frob [1..3] [1..3]   where  frob = \x y -> 100*x + y
11:04:49 <lambdabot>   [101,102,103,201,202,203,301,302,303]
11:04:55 <ski_> > liftA2 frob [1..3] [1..3]   where  frob x y = 100*x + y
11:04:56 <lambdabot>   [101,102,103,201,202,203,301,302,303]
11:05:10 <mstr> > liftA2 (100*x + y) [1..3] [1..3]
11:05:11 <lambdabot>   Couldn't match expected type `a -> b -> c'
11:05:28 <ski_> mstr : `\x y -> ..x.y..' defines a function on the fly, that takes `x' and `y' as parameters
11:06:11 <mstr> @type (100*x + y)
11:06:12 <lambdabot> Expr
11:06:24 <roconnor> @tell mattam you can review my draft thesis at <http://r6.ca/thesis.pdf>.  Please let me know of any errors you find.
11:06:25 <lambdabot> Consider it noted.
11:07:01 <ski_> mstr : `100*x + y' is a number .. but `\x y -> 100*x + y' is a function that takes two numbers and gives a number
11:07:25 <mauke> > 100*x + y
11:07:27 <lambdabot>   100 * x + y
11:07:38 <ski_> (also `100*x + y' is a number only if you've already given values for `x' and `y')
11:07:53 <mstr> that's weird
11:07:54 <mauke> lambdabot contains definitions for all single-letter variables
11:07:57 <ski_> mstr : also ignore that lambdabot `Expr' thing for now ..
11:08:03 <ski_> > type (100*xx + yy)
11:08:04 <lambdabot>   <no location info>: parse error on input `type'
11:08:21 <mauke> :t 100*xx + yy
11:08:21 <lambdabot> Not in scope: `xx'
11:08:22 <lambdabot> Not in scope: `yy'
11:08:31 <mstr> @type x
11:08:32 <lambdabot> Expr
11:08:45 <ski_> lambdabot defines a strange kind of number called `Expr', which sometimes can be handy for explaing how some functions work
11:09:10 <sw17ch> > foldr (+) 0 [1..10] :: Expr
11:09:10 <mauke> > iterate f x
11:09:12 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
11:09:12 <lambdabot>   1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + 0)))))))))
11:09:23 <sw17ch> > foldl (+) 0 [1..10] :: Expr
11:09:24 <lambdabot>   0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10
11:09:29 <sw17ch> > foldl' (+) 0 [1..10] :: Expr
11:09:31 <lambdabot>   0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10
11:09:40 <bos> @seen dons
11:09:40 <lambdabot> dons is in #haskell, #concatenative, #arch-haskell, #novalang, #darcs, #xmonad and #ghc. I last heard dons speak 1h 1m 4s ago.
11:10:00 <vegai> that really really should be in ghci
11:10:15 <roconnor> how would I generate an Arbitrary rational or double in [0,1] with QuickCheck?
11:10:38 <ski_> (that really should be possibly to disable and enable at will, imho)
11:10:41 <quicksilver> roconnor: use forall, which lets you choose a custom Gen
11:10:44 <mauke> vegai: should be easy, just import the module in your ~/.ghci
11:10:52 <pumpkin> Axman6: awake?
11:11:00 <roconnor> @type forall
11:11:01 <lambdabot> Not in scope: `forall'
11:11:05 <roconnor> @hoogle forall
11:11:06 <lambdabot> keyword forall
11:11:06 <lambdabot> Test.QuickCheck forAll :: (Show a, Testable b) => Gen a -> (a -> b) -> Property
11:11:06 <lambdabot> Language.Haskell.TH ForallC :: [Name] -> Cxt -> Con -> Con
11:11:51 <ski_> mstr : if you could just pass `100*x + y' to `liftA2', how would `liftA2' know whether to pass elements from the first list into `x' and elements from the second list into `y' .. and not vice versa ?
11:12:09 <roconnor> quicksilver: but how do I make a custom gen to do that?
11:12:12 <ski_> @type forAll
11:12:13 <lambdabot> forall a prop. (Testable prop, Show a) => Gen a -> (a -> prop) -> Property
11:12:29 <mstr> ski_: I see
11:12:41 <quicksilver> roconnor: well look at the definition of a Gen
11:12:50 <mstr> hmm, is there something like @type that I can use in ghci?
11:13:08 <quicksilver> you can essnetially pass in randomR
11:13:14 <quicksilver> with a little argument-position-thinking
11:13:20 <mauke> mstr: :t
11:13:47 <ski_> mstr : you can always name the function instead, in a `where' or `let'-`in' .. but for use-only-once functions, it's sometimes nicer to avoid giving it a name, instead just writing the meat of the function directly
11:14:25 <mstr> ya, I've used lambdas in python
11:14:30 <ski_> ok
11:17:36 <hukolele> i have problems with ffi... what do i need to interface with a function inside a .a library? i have the .dll the .h and the .a files but it got me to a linker error, undefined reference..., or a unknown symbol in ghci
11:17:46 <hukolele> but it loads ok
11:18:26 <vegai> mauke: which module is that?
11:18:30 <vegai> @src Expr
11:18:31 <lambdabot> Source not found. Just try something else.
11:19:17 <mstr> so, I made a function "xor (x,y)" and managed to map [(a,b) | a <- [True, False], b <- [True, False]] to it
11:19:22 <mauke> vegai: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/simple-reflect
11:19:33 <mstr> but what if the func was "xor x y"
11:19:48 <vixey> liftA2 xor
11:19:52 <vegai> mauke: thanks.
11:20:01 <mauke> mstr: you can convert between the styles with curry/uncurry
11:20:08 <mauke> @src uncurry
11:20:08 <lambdabot> uncurry f p = f (fst p) (snd p)
11:20:39 <mstr> ah, I'll go read about that
11:20:58 <lilac> interesting that uncurry is written that way
11:21:00 <mauke> there's not much to read, I think
11:21:10 <mauke> @src curry
11:21:10 <lilac> i'd have expected 'uncurry f (a, b) = f a b'
11:21:10 <lambdabot> curry f x y = f (x, y)
11:21:16 <mauke> lilac: that's stricter
11:21:28 <ski_> > map xor [(a,b) | a <- [True, False], b <- [True, False]]  where xor x y = x /= y
11:21:29 <lambdabot>       Overlapping instances for Show ((Bool, Bool) -> Bool)
11:21:29 <lambdabot>        arising fr...
11:21:39 <lilac> mauke: perhaps 'uncurry f ~(a, b) = f a b'
11:21:41 <ski_> > map (uncurry xor) [(a,b) | a <- [True, False], b <- [True, False]]  where xor x y = x /= y
11:21:42 <lambdabot>   [False,True,True,False]
11:21:44 <mauke> lilac: yeah
11:22:22 <lilac> uncurry (curry const) (small thing, big thing)
11:22:27 <lilac> ^^ that'll leak, right?
11:23:04 <lilac> s/(curry const)/const/g obviously
11:23:24 * lilac is still not sure that example's right :(
11:24:55 <ski_> when `uncurry const (small_thing, big_thing)' is forced, it is turned into `let p = (small_thing, big_thing) in const (fst p) (snd p)', which is turned into `let p = (small_thing, big_thing) in snd p' which is turned into `let p = (small_thing, big_thing) in big_thing'
11:25:09 <ski_> i think `p' may now be garbage-collected
11:25:36 <Gracenotes> by chance, does anyone know anything about the fixpoint of λx. succ x?
11:25:41 <lilac> ski_: sounds plausible (apart from what const does)
11:25:58 <ski_> (actually `fst p' and `small_thing' instead of the other way around ..)
11:26:03 * vixey calls it omega
11:26:10 <Gracenotes> where succ is λn s z. s (n s z)
11:26:37 <Gracenotes> ah, omega? hm.
11:26:40 <vixey> Gracenotes, I guess it just gives you fixed point combinator back
11:26:46 <vixey> given that definition of succ
11:27:00 <vixey> :t fix (\n s z -> s (n s z))
11:27:01 <lambdabot> forall t t1. (t1 -> t1) -> t -> t1
11:27:31 <ski_> > fix (\n s z -> s (n s z)) (1:) undefined
11:27:32 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:28:20 <MoxJet> @src fix
11:28:20 <lambdabot> fix f = let x = f x in x
11:28:31 <ski_> @type fix (\n s z -> n s (s z))
11:28:32 <lambdabot> forall t t1. (t -> t) -> t -> t1
11:29:59 <lilac> let q = fix (\x s z. s (x s z)). then q = (\x s z. s (x s z)) q = \s z -> s (q s z), so q s z = s (q s z). therefore q s _ = fix s.
11:30:09 <lilac> Gracenotes: that good enough? ;-)
11:31:07 <Gracenotes> ah, that works :) ...if not a bit weird
11:31:10 <dons> bos: yo?
11:31:53 <Gracenotes> there's one notion of using fix to find a fixpoint, and another notion of using it to write functions
11:32:58 <ski_> recursive functions are fixpoints
11:33:36 <pumpkin> people mentioned new Monoid docs on the long discussion on cafe
11:33:44 <pumpkin> but they look the same to me... does anyone know where the new ones are?
11:33:51 <dons> in darcs, i guess.
11:33:58 <pumpkin> ah, fair enough
11:33:59 <vixey> what were the changes?
11:34:11 <dons> http://darcs.haskell.org/packages/base/Data/Monoid.hs ?
11:34:18 <pumpkin> not just saying "must satisfy the monoid laws" but actually saying what those are, and so on I think
11:34:29 <pumpkin> ah, nice, thanks
11:34:32 <vixey> ah that is a good thing!
11:34:50 <sleven> http://hpaste.org/13996 , i want to nest 3 for loops but accumulate the result into one
11:35:20 <sleven> can I pass a closure and mess with it like I can with macros in lisp?
11:35:35 <vixey> mess with it??
11:36:10 <sleven> rearrange and control evaluation
11:36:34 <mauke> you can call it, and that's it
11:38:57 <sleven> so how would you do the 3 for loops
11:39:40 <quicksilver> forM_ [1..4] $ \x -> forM [3..5] $ \y -> forM [2..4] $ \z -> {- presumably do something with x, y and z -}
11:40:35 <ski_> sleven : how is `matrix',`getAt',`setAt' defined ?
11:40:45 <roconnor> time to use the ghci debugger
11:40:51 <quicksilver> Gracenotes: it's a fixed point in a difference sense. It's a fixed point of a map from denotations to denotations, not a map from values to values.
11:40:54 <roconnor> how do I debug an infinite loop?
11:41:23 <quicksilver> Gracenotes: and in particular, it's the *least* fixed point in a particular order.
11:41:24 <conal> roconnor: stop it half-way through.
11:41:38 <ski_> (quicksilver : isn't a value a denotation ?)
11:41:41 <roconnor> Interrupted.
11:41:41 <roconnor> *Data.Colour.RGB>
11:41:45 <sleven> ski_: they take a matrix(basically a listArray wrapped in a data) and return a double and a new Matrix respectively
11:41:48 <roconnor> now what?
11:41:57 <quicksilver> ski_: I hope the different emphasis is a helpful intuition.
11:41:59 <roconnor> conal: oh, was that a joke?
11:42:01 <roconnor> :D
11:42:08 <conal> roconnor: yeah :D
11:42:16 <Gracenotes> hm.
11:42:26 <ski_> sleven> :t matrix
11:42:44 <quicksilver> Gracenotes: for example, fix (\x -> x / 2)
11:42:57 <quicksilver> Gracenotes: your mathematical intuition tells you that 0 is a fixed point.
11:43:05 <quicksilver> Gracenotes: it *is*, but it's not the least fixed point.
11:43:12 <quicksilver> the least fixed point is _|_.
11:43:19 <sleven> ski_: SparseMatrix :: DA.Array (Int, Int) Double -> Matrix repr
11:43:29 <mauke> what is NaN here?
11:43:31 <conal> quicksilver: i use "denotation" and "value" synonymously.  do you distinguish them?
11:43:52 <conal> quicksilver: i.e., same question as ski_
11:43:54 <quicksilver> conal: my intention was to emphasise that you need to use a more sophisticated denotion (CPOs and _|_)
11:44:14 <ski_> sleven : so `matrix :: Int -> Int -> Double -> Matrix repr' ? .. what is `repr' ?
11:44:23 <quicksilver> conal: and that people will sometimes think of 'value' as a naive denotation (which would apply to a strict language)
11:45:21 <conal> quicksilver: got it.  thx.
11:45:33 <Gracenotes> and recursive functions that are fixpoints are fixpoints in the "denotation" sense?
11:45:49 <quicksilver> Gracenotes: let's stay away from functions.
11:46:01 <roconnor> ah, I use the variable name "b" twice
11:46:01 <quicksilver> Gracenotes: stick with values (there is a false vibe that functions are somehow different - they aren't)
11:46:07 <ski_> sleven : i assume `matrix' makes a new constant matrix (i.e. same value in every cell) .. i'd suggest creating a similar function, but which allows each element to depend on its coordinates in the matrix
11:46:10 <roconnor> maybe people are right about haskell and terse names
11:46:13 <ski_> roconnor :)
11:46:22 <quicksilver> Gracenotes: fix (\x -> 1 : x)
11:46:24 <pumpkin> mauke: did you see the lambdaDOS from yesterday? :P
11:46:35 <mauke> pumpkin: yes
11:46:35 <quicksilver> Gracenotes: the fixed point of this is [1,1,1,1,1,1,....]
11:46:42 <Gracenotes> yeah.
11:46:51 <sleven> http://hpaste.org/13997
11:46:53 <quicksilver> Gracenotes: and in particular _|_ is not a fixed point of this.
11:46:57 <quicksilver> so _|_ isn't the least.
11:46:58 <sleven> there is the whole module ^^
11:47:08 <quicksilver> In fact, [1,1,...] is the least, although I don't claim that's obvious without a bit of thought.
11:47:28 <Gracenotes> _|_ isn't a fix point? How so?
11:47:30 <ski_> sleven : ty (next time, annotate the original paste instead)
11:47:39 <quicksilver> (1 : _|_) is 'different' from _|_
11:47:44 <quicksilver> I can tell them apart.
11:47:47 <Gracenotes> ah.
11:47:50 <quicksilver> head (1 : _|_) is 1.
11:47:55 <quicksilver> but head (_|_) is _|_
11:48:03 <quicksilver> so, it's not a fixed point.
11:48:11 <mauke> obvious, really. a bottom has no head
11:48:16 <quicksilver> mauke++
11:48:38 <ski_> sleven : `repr' in your current `Matrix' is useless
11:48:44 <Gracenotes> [1..] -> 1:[1..]
11:48:47 <ski_> (it doesn't do anything)
11:49:02 <quicksilver> Gracenotes: so, since fix will always find the least fixed point, and _|_ is certainly least, if it's a fixed point, fix is only "useful" on functions which don't take _|_ as a fixed point.
11:49:06 <Gracenotes> well, not [1..], but you get the idea
11:49:08 <ski_> (Gracenotes : `[1..] = [1:[2..]]')
11:49:18 <ski_> (Gracenotes : er, `[1..] = 1:[2..]')
11:49:21 <sleven> ski_: i dont have to patternmatch for it
11:49:33 <ski_> sleven : `it' being ?
11:49:34 <mornfall> (I like the connotations of bottom ~ (_|_))
11:49:34 <Gracenotes> yeah. Haskell's .. doesn't do what I want it to do :P
11:49:35 <quicksilver> Gracenotes: in particular fix isn't useful on "normal mathematical type functions".
11:49:49 <quicksilver> to be very precise, fix isn't useful on strict functions.
11:49:58 <quicksilver> (because f _|_ = _|_ is precisely what strictness is)
11:50:06 <mornfall> Gracenotes: (For a split second, I have thought the talk is about Haskore ...)
11:50:16 <quicksilver> and "normal mathematical functions" tend to be strict by nature.
11:50:46 <Gracenotes> mm.
11:51:01 <quicksilver> but (\x -> 1 : x) isn't strict.
11:51:27 <quicksilver> and (\f -> \x -> if x == 0 then 0 else x * f (x-1)) isn't strict.
11:51:36 <quicksilver> that yields the recursive definition of factorial.
11:52:11 <sleven> ski_ the array
11:52:14 <Gracenotes> there aren't very many languages for which if/then/else is completely strict
11:52:26 <Gracenotes> at least, popular ones.
11:52:32 <sleven> no case x of Matrix y -> y
11:52:50 <mornfall> Gracenotes: I don't think it would make any sense in imperative language...
11:53:05 <mornfall> The idea is exactly that only one branch is taken. :)
11:53:14 <quicksilver> Gracenotes: yes, although really we're talking about the 'f' part.
11:53:20 <Gracenotes> yes.
11:53:21 <quicksilver> so the point is that it doesn't always use f.
11:53:26 <quicksilver> or doesn't always use it immediately.
11:53:35 <quicksilver> so even if f is _|_, something gets done.
11:53:48 <quicksilver> (in at least one case)
11:54:22 <ski_> sleven : i don't see how having to pattern-match or not is related to the `repr' in the type `Matrix repr'
11:54:48 <ski_> sleven : also, it appears your `SparseMatrix' isn't sparse
11:55:34 <sleven> how do yo you mean? yeah I dont have a compression alogirthm for it
11:55:53 <ski_> sleven : anyway, i'm suggesting you could define a `makeMatrix :: Int -> Int -> (Int -> Int -> Double) -> Matrix repr'
11:56:02 <sleven> but hwat exactly in the code prevents me from making it small? sparse is pretty arbitrarily defined no? just a lot of zeros
11:56:56 <ski_> usually "sparse" means that not all cells in the matrix is explicitly represented
11:57:55 <ski_> your `matrix' is creating an array where every cell is filled with an initial value (e.g. `0')
11:58:08 <sleven> yes i could call it matrix for now
11:58:12 <sleven> doesnt matter yet
11:58:18 <ski_> still, you asked about another issue
11:58:20 <ski_> right
11:58:22 <sleven> but thats not the point
11:58:23 <sleven> yes
11:58:39 <sleven> i could write some big recursive ugly procedure
11:58:56 <sleven> just that it is so easy to do in an imperative lang lke shown by the java-code
11:59:30 <ski_> i think either you want a
11:59:32 <ski_>   makeMatrix :: Int -> Int -> (Int -> Int -> Double) -> Matrix repr
11:59:34 <ski_> or a
12:00:22 <ski_> (hm, no .. what i was about to say doesn't apply here, since you aren't doing nested arrays)
12:01:23 <ski_> so, or using `setAt' is a loop, using `forM_' (as quicksilver hinted)
12:03:34 <quicksilver> sleven: most common ugly recursion patterns exist as prelude functions, which have convenient names
12:03:41 <quicksilver> you can almost pretend they are custom keywords
12:03:51 <quicksilver> map, foldr, filter, mapM_, forM_
12:04:03 <quicksilver> and then you don't recurse explicitly.
12:04:46 <erikc> woo, RWH finally arrived
12:06:00 <quicksilver> \o/
12:07:00 <sleven> thanks ski and quick
12:07:08 <sleven> im falling asleep now will try it tomorrow
12:09:49 <FunctorSalad> how do I get quickCheck (2.1) to actually somehow print the labels? ;)
12:10:14 <quicksilver> verboseCheck or something?
12:10:20 <quicksilver> there are a few choices IIRC
12:10:53 <FunctorSalad> no "verbose" found in the index of 2.1 :( http://hackage.haskell.org/packages/archive/QuickCheck/2.1.0.1/doc/html/doc-index.html
12:12:40 <FunctorSalad> I couldn't find any documentation about the quickcheck 2 changes anywhere either...
12:13:01 <FunctorSalad> (which needn't mean a lot :))
12:13:50 <doserj> FunctorSalad: tried the quickCheckResult function?
12:15:20 <FunctorSalad> doserj: it claims that plain quickCheck prints the result to stdout :)
12:15:39 <FunctorSalad> (so that wouldn't seem to do anything)
12:16:21 <FunctorSalad> or maybe you are really supposed to access that labels field of Result manually
12:17:09 <chrisdone> do res <- getResult; case res of ... -- I have this construct all the time, it's really annoying that I have to bind it to a variable when I really want to just do some pattern matching. doesn't this annoy anyone else? seriously!
12:18:40 <ski_> it would be nice to have multiple-branch lambdas, yes
12:18:56 <ski_> (or reflective syntax for monads)
12:19:04 <chrisdone> right
12:19:19 <chrisdone> glad it's not just me
12:20:03 <quicksilver> chrisdone: midly
12:20:10 <FunctorSalad> ((\Just x -> foo) &&& (\Nothing -> bar)) ? ;)
12:20:24 <FunctorSalad> continue with whatever didn't throw an exception...
12:20:35 <chrisdone> clever but ew :P
12:20:36 <FunctorSalad> just a silly idea...
12:20:47 <Peaker> hmm.. SDL's wrapper clearly has an Enum instance for SDLKey, but ghci denies it
12:21:28 <Peaker> oh its a different Enum instance from the Prelude
12:26:01 <chrisdone> hm
12:33:27 <dmead> channel
12:33:49 <dmead> are there any docs on how to get haskell running on embedded hardware?
12:36:01 <FunctorSalad> spot the bug...: nHalf = n-1 `div` 2
12:36:17 <FunctorSalad> :)
12:36:18 <pumpkin> nHalf = n ?
12:36:24 <FunctorSalad> yep
12:36:47 <pumpkin> we need a mind-reading precedence inferrer
12:37:00 <pumpkin> one that says "this doesn't do anything, he probably meant the other one"
12:37:10 <pumpkin> :P
12:37:28 <pumpkin> that would be fun when it misinterpreted your intentions
12:37:37 --- mode: ChanServ set -o dcoutts
12:37:49 <gwern> @hoogle kill
12:37:49 <lambdabot> Control.Concurrent killThread :: ThreadId -> IO ()
12:37:49 <lambdabot> Control.Exception ThreadKilled :: AsyncException
12:37:57 <gwern> hm. no killProcess?
12:38:00 <FunctorSalad> granted, division binds stronger than subtraction, but still that `div` seems so bulky it has to bind more weakly ;)
12:38:05 <pumpkin> @hoogle terminate
12:38:05 <lambdabot> System.Process terminateProcess :: ProcessHandle -> IO ()
12:38:10 <chessguy_work> qit could do the inference, but somehow notify the user
12:38:14 --- mode: ChanServ set -o dcoutts_
12:38:17 <Peaker> I really want a name for a flipped fmap
12:38:19 <gwern> oh, 'terminate'
12:38:33 <Saizan> therminateProcess currently uses SIGTERM though
12:38:34 <Peaker> blah `ffmap` \big -> func here
12:38:54 <Saizan> (even if the doc says otherwise)
12:39:45 <ski_> Peaker : `pamf'
12:39:51 <Peaker> hehe
12:39:56 <ski_> (i've used that a few times)
12:40:04 <FunctorSalad> hmm isn't the default precedence for `foo` syntax weakest? maybe that got me
12:40:09 <FunctorSalad> @src div
12:40:09 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
12:40:30 <gwern> Saizan: well my bigger problem is not knowing how to use a pid to get a processhandle
12:41:02 <Gracenotes> system call to ps?
12:41:05 <mauke> gwern: are you just trying to send a signal to a pid?
12:41:27 <gwern> mauke: maybe. would sending a signal be enough to kill a runaway process?
12:41:42 <mauke> if it's SIGKILL, yes
12:41:53 <Saizan> look under System.Posix then
12:42:06 <mauke> SIGKILL cannot be caught or ignored. it cannot be reasoned with.
12:42:14 <gwern> I have been; Posix.Process doesn't have a terminate
12:42:20 <mauke> signalProcess :: Signal -> ProcessID -> IO ()
12:42:41 <gwern> @hoogle ProcessId -> ProcessHandle
12:42:41 <lambdabot> Did you mean: ProcessID -> ProcessHandle /count=20
12:42:41 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:42:41 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
12:42:51 <gwern> @hoogle ProcessID -> ProcessHandle
12:42:51 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:42:51 <lambdabot> Control.Exception throwDyn :: Typeable exception => exception -> b
12:42:51 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
12:43:17 <gwern> @hoogle signalProcess
12:43:17 <lambdabot> No results found
12:44:28 <mstr> hey is there a library function to shuffle a list?
12:44:48 <gwern> 1guess hoogle doesn't cover System.Posix.Signals
12:45:19 <chessguy_work> mstr, that seems to be a common blog topic, you might want to google a bit
12:45:22 <afedorov> how do I get an element at a certain index in a list?
12:45:31 <chessguy_work> @type (!!)
12:45:31 <afedorov> (stupid question, I know)
12:45:32 <lambdabot> forall a. [a] -> Int -> a
12:45:39 <mstr> [blabla] !! index
12:45:40 <mstr> ?
12:45:47 <afedorov> got it
12:45:48 <afedorov> thanks
12:45:56 <afedorov> :)
12:46:17 <gwern> @hoogle Int -> CInt
12:46:20 <lambdabot> Prelude toEnum :: Enum a => Int -> a
12:46:20 <lambdabot> Data.Bits bit :: Bits a => Int -> a
12:46:20 <lambdabot> Data.Bits clearBit :: Bits a => a -> Int -> a
12:46:31 <afedorov> how about a touple?
12:46:53 <mauke> gwern: fromIntegral
12:47:00 <gwern> toEnum seems to work
12:47:11 <mauke> gwern: wait, what do you need that for?
12:47:19 <afedorov> how do I get "two" from ("one", "two")?
12:47:25 <jkff> afedorov: there can't be such a function
12:47:30 <mauke> afedorov: snd
12:47:40 <jkff> afedorov: because it would be indexTuple :: (a,b) -> ???
12:47:47 <Saizan> > snd ("one","two")
12:47:49 <lambdabot>   "two"
12:47:56 <mstr> chessguy_work: yea, I did. just wasted to check that I didn't miss something obvious :)
12:47:58 <afedorov> ah, gotcha
12:48:07 <jkff> Well, snd gets two from (one,two) but it's not like (!!) for lists
12:48:14 <afedorov> > fst ("one", "two")
12:48:15 <lambdabot>   "one"
12:48:16 <gwern> mauke: I read the two arguments to my watchdog process as ints, one is multiplied to get a timeout (sleep), and the other is the pid of the main mueval process; the signalProcess function demands two CInts, so I wrap 9 and pid in toEnum
12:48:28 <afedorov> cool :) is that in a particular library? it's not working in hgci
12:48:30 <mauke> no need to wrap 9
12:48:31 <afedorov> ~ghci
12:48:38 <mauke> 1) 9 already has the right type
12:48:42 <afedorov> nvm, yes it is
12:48:46 <mauke> 2) you can just use killProcess :: Signal
12:48:51 <gwern> true; I misinterpreted the type error
12:49:01 <afedorov> :-P tnx guys
12:49:25 <gwern> mauke: I doubt the signal 9 differs much on any system ghc/mueval is likely to be compilable on :)
12:50:00 <gwern> but if you're curious: http://hpaste.org/13998
12:50:24 <mauke> return () looks redundant
12:50:50 <mauke> why Int? is CInt not an instance of Read?
12:51:11 <gwern> dunno. will try that
12:51:23 <mauke> I think your type annotations are redundant
12:51:37 <gwern> looks like I'd have to import cint from somewhere
12:51:40 <gwern> @hoogle CInt
12:51:40 <lambdabot> Foreign.C.Types data CInt
12:51:40 <lambdabot> Foreign.C.Types data CIntMax
12:51:40 <lambdabot> Foreign.C.Types data CIntPtr
12:51:47 <mauke> no
12:52:00 <mauke> let pid = read (args !! 0); ... signalProcess killProcess pid
12:53:11 <gwern> I see. the type annotation is forced by signalProcess
12:53:57 <mauke> what character is that between tout and 700000?
12:54:16 <sbahra> http://pages.cpsc.ucalgary.ca/~nicholss/ta/w06_349/as2.html
12:54:18 <sbahra> Very cool. :-P
12:54:49 <gwern> mauke: *
12:55:07 <mauke> unlikely
12:55:22 <gwern> -_-
12:55:55 <leimy> trying to install cabal packages on Vista
12:55:59 <leimy> hitting permissions issues
12:56:01 <mauke> hmm, must be something that fits in two utf-8 bytes
12:56:16 <mauke> I guess the thing in type annotations is ∷
12:56:28 <dcoutts> leimy: like this? : http://hackage.haskell.org/trac/hackage/ticket/454
12:56:38 <gwern> mauke: righty
12:57:02 <leimy> dcoutts:  likely!
12:57:03 <leimy> thanks!
12:57:23 <dcoutts> leimy: let me know if it's exactly the same issue, otherwise we should investigate
13:04:21 <koeien> are there good guidelines or strong opinions about the placement of `do' and `where' in haskell programs?
13:04:30 <leimy> dcoutts: Well this doesn't appear to be the problem somehow
13:04:46 <leimy> unless it's in runhaskell
13:04:52 <leimy> and not ghc
13:05:25 <tibbe> @seen bos
13:05:26 <lambdabot> bos is in #ghc and #haskell. I last heard bos speak 1h 55m 45s ago.
13:05:31 <tibbe> bos: ping
13:05:59 <gwern> mauke: I trust you have no issues with:           pid ←  liftM show getProcessID                                                                                        let tlimit = show $ timeLimit opts                                                                                    forkIO $ (rawSystem "mueval-watchdog" [pid, tlimit]) >> return ()
13:06:05 <gwern> :)
13:06:19 <leimy> dcoutts: would you know which files need to be updated to make it go? :-)
13:06:48 <afedorov> > break ((==) 4) [1,2,3,4,6,6,3,4,5,3]
13:06:50 <lambdabot>   ([1,2,3],[4,6,6,3,4,5,3])
13:06:53 <leimy> dcoutts: I
13:07:05 <leimy> dcoutts: I am unable to do "runhaskell Setup.hs install"
13:07:18 <afedorov> how would I write a function which breaks in multiple places? is there a simple combinator which will do that for me?
13:07:30 <byorgey> koeien: there are strong opinions, but nothing written down that I know of
13:07:46 <afedorov> I can't find a very pretty recursive solution :-/
13:07:57 <byorgey> koeien: there are 'de facto' stylistic standards which you sort of figure out once you've looked at enough code
13:08:00 <Heffalump> afedorov: check out the split package on hackage
13:08:14 <koeien> byorgey: i've seen code where the `do' is on the same line as the first statement. this seems nice but not practical
13:08:16 <byorgey> koeien: but also, if you have some particular code you'd like stylistic suggestions on, feel free to paste it
13:08:48 <byorgey> koeien: yeah, I most often put "do" at the end of some line, and then put a newline and indent from the beginning of the previous line
13:09:03 <koeien> that's what i tend to do as well. also "where" at the end of the line
13:09:11 <koeien> that may be less common
13:09:18 <byorgey> that is less common, yes
13:09:29 <byorgey> but I don't see anything wrong with it
13:09:47 <byorgey> except that people might not be expecting a 'where' clause, so might miss it
13:09:56 <koeien> hmm
13:09:59 <byorgey> whereas a 'do' will usually be obvious because of the context
13:10:04 <dcoutts> leimy: oh, I guess you're not allowed to write to C:\Program Files right?
13:10:06 <bos> tibbe: yep?
13:10:15 <dcoutts> leimy: does it work to do a --user install?
13:10:16 <leimy> dcoutts:  it installed in C:\ghc
13:10:18 <afedorov> Heffalump: thanks
13:10:29 <tibbe> bos: do you have the link to the hpaste of your http test?
13:10:33 <dcoutts> leimy: but that's not where haskell packages get installed by default
13:10:33 <koeien> byorgey: i'll take a look at what the ghc overlords do
13:10:34 <leimy> dcoutts:  hmm?  "runhaskell Setup.hs --user install" ?
13:10:56 <bos> tibbe: uuuhhhh...
13:10:56 <dcoutts> leimy: runhaskell Setup.hs configure --user; runhaskell Setup.hs build; runhaskell Setup.hs install
13:11:05 <tibbe> bos: btw, I'm planning to have a send, sendAll, scatterSend and scatterSendAll for Strict bytestrings on network-bytestring and then make a release
13:11:21 <leimy> dcoutts: I'll try it :-)
13:11:44 <tibbe> bos: scatter is the best name I come up with so far. Gonna look into what other languages/APIs use
13:11:46 <leimy> dcoutts: that worked just fine!  Thanks
13:11:49 <bos> tibbe: so moving writev into the Strict module, basically?
13:12:03 <tibbe> bos: right, so we have on for lazy and one for strict
13:12:08 <dcoutts> leimy: so do you not have administrator access on your machine?
13:12:19 <dcoutts> leimy: is it like a shared server or something?
13:12:20 <bos> tibbe: i can't find that paste
13:12:20 <leimy> dcoutts:  I'm 90% sure I'm the administrator
13:12:22 <Heffalump> dcoutts: you know cabal install detects https proxies by using $http_proxy on unix and the registry on Windows? Is there some standard or convention that mandates that behaviour? I ended up hacking it to look at http_proxy on Windows too because that was significantly more convenient for me, and I'm wondering if I should submit a patch that would make it support both on Windows.
13:12:25 <leimy> but Vista is weird
13:12:29 <tibbe> the difference between lazy and strict is probably that there's no sendXXX :: [ByteString] -> IO Int for lazy
13:12:30 <Heffalump> sorry http proxies, not https proxies
13:12:30 <leimy> and Vista Ultimate is weirder :-)
13:12:38 <tibbe> bos: ok, not that important
13:12:41 <gwern> this is odd. are the getProcessStatus and related functions *only* for a parent process to be used on children?
13:12:45 <afedorov> how do I install a package from hackage to use in ghci
13:12:47 <afedorov> ?
13:12:48 * tibbe wishes #ghc was logged
13:12:50 <Heffalump> afedorov: cabal install
13:12:52 <bos> tibbe: it was just ~30 lines of code
13:12:55 <Heffalump> if you have that installed already
13:13:00 <tibbe> bos: sure
13:13:26 <jethr0> tibbe: doesn't your irc client keep logs?
13:13:29 <tibbe> bos: I'm basically thinking about what I want the API to look like
13:13:38 <dcoutts> Heffalump: I don't know if there is a standard convention on windows, apart from what IE and the MSHTTP dll do
13:13:39 <tibbe> jethr0: good question, actually I've never checked
13:13:45 <koeien> byorgey: as far as i can see in ghc, at least in a few files, the 'where'-clauses are at a new line. except for the instance-declarations
13:14:01 <byorgey> yeah, that seems to be the most common
13:14:16 <bos> tibbe: i assume scatterSend :: [S.ByteString] -> IO Int ?
13:14:17 <Heffalump> would you be happy with it looking at $http_proxy then the registry?
13:14:21 <afedorov> Heffalump: no cabal :( can I get that with apt-get?
13:14:22 <dcoutts> Heffalump: is there a problem with the registry method for you? I think we check the per-user registry hive
13:14:27 <koeien> i'll copy that then. thanks
13:14:43 <bos> i've got the incremental version of attoparsec up on hackage now
13:14:44 <gwern> @hoogle ProcessHandle -> ProcessID
13:14:44 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
13:14:44 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
13:14:44 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
13:15:01 <afedorov> libhugs-cabal-bundled - A framework for packaging Haskell software
13:15:06 <dcoutts> Heffalump: I know there are some settings that MSHTTP uses that are a lot more complicated, eg all sorts of proprietary proxy authentication stuff that we'll never be able to follow
13:15:08 <afedorov> that should have it, I think
13:15:12 <whoppix> Is there some way to write haskell code using unicode-characters like ≠ and ← and similar, instead of <-, /= and co.?
13:15:28 <Heffalump> dcoutts: it changes every so often, and isn't kept in the registry (at least, cabal-install didn't pick it up), and since editing the registry is more of a pain than just setting an environment variable I prefer the latter
13:15:34 <gwern> whoppix: not really
13:15:36 <Heffalump> afedorov: no, I don't think it does
13:15:46 <gwern> whoppix: display is another issue tho
13:15:50 <Heffalump> there's a bit of confusing naming - you need "cabal-install" to get the "cabal" command line tool.
13:15:53 <dcoutts> Heffalump: how do other programs get it? how can we make it "just work" ?
13:15:54 <afedorov> Heffalump: looks like you're right
13:15:57 <Heffalump> whereas "cabal" gives you a library
13:16:03 <whoppix> gwern, what do you mean, "display"?
13:16:15 <afedorov> Heffalump: ok, I'll download cabal-install from the hackage website
13:16:19 <pumpkin> wow, -DS on the runtime really makes things a LOT slower :o
13:16:25 <Heffalump> dcoutts: I'm not entirely sure, to be honest. For darcs I have to set the variable. Firefox and IE seem to just figure it out.
13:16:27 <tibbe> bos: yes that's the type of scatterSend
13:16:30 <Heffalump> I'll do a bit of digging, one sec.
13:16:44 <sbahra> pumpkin, what does -DS do?
13:17:00 <dcoutts> Heffalump: I was under the impression that we used the same key as IE, so yes details would be useful
13:17:06 <Heffalump> ah, it's using an auto-conf script
13:17:13 <pumpkin> sbahra: tells the runtime to do a bunch of sanity checks, to overwrite freed memory with a detectable pattern, and a bunch of other safety things
13:17:15 <tibbe> bos: would be nice if the lazy and strict io APIs reflected each other
13:17:23 <Heffalump> unless someone makes a library to support those, I can't see how you can do the same
13:17:41 <dcoutts> Heffalump: oh, no, in that case we're stuffed.
13:17:45 <bos> tibbe: how do you mean?
13:18:11 <tibbe> bos: I want both APIs to have the same functions with the same names where it makes sense
13:18:18 <tibbe> bos: how's your epoll stuff going btw?
13:18:22 <Heffalump> also, the config box for IE is greyed out, which makes me think I might not even be able to edit the registry key, and in addition doing so seems undesirable as it would override the right settings
13:18:23 <sbahra> pumpkin, I see
13:18:40 <bos> tibbe: took a break from it for a week or two, needed a parsing library more urgently
13:18:45 <leimy> dcoutts:  if I do a user build... it installs it to where on windows?
13:18:54 <tibbe> bos: ok, too bad the docs wont build on hackage :(
13:19:12 <dcoutts> leimy: under your user applications and settings, in the "cabal\bin" directory
13:19:13 <whoppix> gwern, ah, well, I was just wondering. Its not like I really need it anyway, it would just be a cool feature. Can't be too hard to write a pre-processor for it, can it?
13:19:17 <bos> hi sussman!
13:19:25 <sussman> hi!
13:19:29 <sussman> whole class is watching this...
13:19:35 <roconnor> > properFraction (-1/3)
13:19:37 <lambdabot>   (0,-0.3333333333333333)
13:19:39 <sussman> they all say hi
13:19:40 <roconnor> crap
13:19:41 <vixey> sussman, lol ?
13:19:48 <bos> hi google chicago!
13:19:48 <arthurdenture> hi from chicago!
13:19:53 <leimy> > putStrLn "hi"
13:19:54 <lambdabot>   * Exception: "<IO ()>"
13:19:57 <leimy> doh!
13:19:57 <elbar> o/
13:20:30 <vixey> sussman, geez. I mixed it up thought you were pretending to be GJS
13:20:30 <sbahra> Exciting.
13:20:34 <afedorov> sussman, as in Gerald Jay?
13:20:42 <sussman> nope, I'm the sussman of svn
13:20:44 <sussman> not lisp.  :-)
13:20:47 * Twey laughs.
13:20:48 <afedorov> oh, psht
13:20:49 <bos> vixey: nearly as eminent :-)
13:20:52 <sussman> not Ben Collins of debian either.
13:21:06 <mauke> the anticudder!
13:21:09 <vixey> @w80 eminent
13:21:10 <lambdabot> *** "eminent" wn "WordNet (r) 2.0"
13:21:10 <lambdabot> eminent
13:21:10 <lambdabot>      adj 1: (used of persons) standing above others in character or
13:21:10 <lambdabot>             attainment or reputation; "our distinguished
13:21:10 <lambdabot>             professor"; "an eminent scholar"; "a great statesman"
13:21:12 <lambdabot> [9 @more lines]
13:21:32 <afedorov> what does @w80 stand for?
13:21:35 <leimy> @w80 crunk
13:21:36 <lambdabot> No match for "crunk".
13:21:38 <leimy> heh
13:21:39 <ski_> @help w80
13:21:39 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:21:42 <vixey> afedorov, nothing :P
13:21:59 <pumpkin> @w80 hello
13:22:00 <lambdabot> *** "hello" wn "WordNet (r) 2.0"
13:22:00 <lambdabot> hello
13:22:00 <lambdabot>      n : an expression of greeting; "every morning they exchanged
13:22:00 <lambdabot>          polite hellos" [syn: {hullo}, {hi}, {howdy}, {how-do-you-do}]
13:22:00 <ski_> @help wn
13:22:01 <lambdabot> I perform dictionary lookups via the following 13 commands:
13:22:02 <afedorov> @list
13:22:02 <lambdabot> all-dicts ... Query all databases on dict.org
13:22:02 <leimy> @w80 dictionary
13:22:04 <lambdabot> devils ...... The Devil's Dictionary
13:22:05 <vixey> sussman, what is the class about?
13:22:06 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
13:22:08 <lambdabot> elements .... Elements database
13:22:09 <roconnor> how do you guys take a RealFrac modulo 1
13:22:10 <lambdabot> [9 @more lines]
13:22:12 <lambdabot> *** "dictionary" wn "WordNet (r) 2.0"
13:22:14 <lambdabot> dictionary
13:22:16 <lambdabot>      n : a reference book containing an alphabetical list of words
13:22:18 <lambdabot> Plugin `dict' failed with: thread killed
13:22:20 <mauke> @hoogle mod
13:22:20 <lambdabot> Prelude mod :: Integral a => a -> a -> a
13:22:22 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
13:22:24 <lambdabot> Text.PrettyPrint.HughesPJ data Mode
13:22:32 <vixey> @hoogle RealFrac
13:22:32 <lambdabot> Prelude class (Real a, Fractional a) => RealFrac a
13:22:32 <sbahra> @hoogle a -> [a] -> [a]
13:22:32 <zaphar_ps> It's a real world haskell study group
13:22:32 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
13:22:32 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
13:22:32 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
13:22:40 * zaphar_ps is one of the class members
13:22:41 <roconnor> (-1/3) `mod` 1
13:22:46 <roconnor> > (-1/3) `mod` 1
13:22:47 <lambdabot>   Add a type signature
13:22:49 <sbahra> zaphar_ps, what do you think of Haskell so far?
13:22:49 * bos is one of the authors
13:22:52 <roconnor> > (-1/3) `mod` 1 :: Rational
13:22:53 <lambdabot>       No instance for (Integral Rational)
13:22:53 <lambdabot>        arising from a use of `mod' ...
13:22:55 <leimy> @hoogle  (String -> String) -> IO ()
13:22:55 <lambdabot> Prelude interact :: (String -> String) -> IO ()
13:22:55 <lambdabot> System.IO interact :: (String -> String) -> IO ()
13:23:04 <arthurdenture> @pointless l == reverse l
13:23:04 <lambdabot> l == reverse l
13:23:07 <zaphar_ps> sbahra: I'm liking it
13:23:22 <zaphar_ps> I had a gentle intro to functional programming through erlang first
13:23:25 <arthurdenture> @pointless isPalindrome l = l == reverse l
13:23:25 <lambdabot> isPalindrome = ap (==) reverse
13:23:36 <pumpkin> zaphar_ps: all three of the authors hang out in here :)
13:23:36 <sbahra> zaphar_ps, ah, I see.
13:23:49 <zaphar_ps> haven't gotten very far yet though in the haskell yet though
13:23:55 <arthurdenture> @type ap
13:23:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:23:57 <sbahra> zaphar_ps, Haskell was the first functional language I've spent more than an hour with. :-)
13:23:59 <vixey> :t uncurry (==)
13:23:59 <lambdabot> forall a. (Eq a) => (a, a) -> Bool
13:24:17 <vixey> :t (id *** reverse)
13:24:18 <lambdabot> forall a a1. (a, [a1]) -> (a, [a1])
13:24:29 <vixey> :t uncurry (==) . (id *** reverse)
13:24:31 <lambdabot> forall a. (Eq a) => ([a], [a]) -> Bool
13:25:46 <sbahra> #haskell is huge now.
13:25:50 <sbahra> @users
13:25:50 <lambdabot> Maximum users seen in #haskell: 664, currently: 664 (100.0%), active: 32 (4.8%)
13:26:24 <Gracenotes> oh noes :(
13:26:30 <bos> this is the busiest the channel has ever been! we only passed 600 concurrent users maybe two weeks ago.
13:26:40 <ehird> it's too busy :P
13:26:41 <Gracenotes> so, does anyone know of the letter represented by |- ?
13:26:51 <pumpkin> Gracenotes: ?
13:26:54 <Heffalump> dcoutts: so would a patch that starts by looking at the proxy variable and goes to the registry after seem reasonable?
13:26:55 <vixey> Gracenotes, satisfies
13:27:02 <vixey> not really a letter
13:27:02 <Gracenotes> ah, it's a symbol. thanks
13:27:03 <pumpkin> oh :P
13:27:17 <idnar> uhm, so, Maybe is a monad
13:27:19 <idnar> what is Maybe Int?
13:27:34 <ehird> Maybe is a regular data type, not just a monad.
13:27:38 <saml> Maybe Int  is a monad
13:27:45 <mauke> Maybe Int is not a monad
13:27:49 <Heffalump> Maybe is a monad, Maybe Int is a monadic value
13:27:51 <sbahra> Maybe is.
13:27:56 <mauke> Maybe Int is not a value
13:28:03 <idnar> "monadic type"?
13:28:09 <vixey> @src Monad
13:28:09 <lambdabot> class  Monad m  where
13:28:09 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
13:28:09 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
13:28:09 <lambdabot>     return      :: a -> m a
13:28:09 <lambdabot>     fail        :: String -> m a
13:28:20 <ddarius> bos: The actual high is I think 674
13:28:21 <Heffalump> sorry, yes, monadic type
13:28:23 <Gracenotes> so what's the grouping of terms in, say, x :: Int |- t :: Bool
13:28:29 <bos> ddarius: ah
13:28:48 <pumpkin> (x :: Int) |- (t :: Bool) ?
13:28:49 <vixey> (x :: Int) |- (t :: Bool)
13:28:50 <iwannalog> evrything is a monad
13:28:58 <pumpkin> iwannalog: nope
13:29:01 <Gracenotes> in the function \x -> t
13:29:10 <Gracenotes> hm.
13:29:18 <iwannalog> pumpkin: every value lies in the hidden monad
13:29:20 <leimy> dcoutts:  so it went to my user AppData\Roaming, but lovely windows doesn't allow me to "explore" that directory
13:29:22 <vixey> Gracenotes, if it's a rule like
13:29:23 <roconnor> No instance for (Random Rational)
13:29:26 <roconnor> crap
13:29:27 <leimy> or something
13:29:29 <ski_> |- ((\x -> t) :: (Int -> Bool))
13:29:37 <vixey> Gamma, x::T |- M::S
13:29:39 <vixey> ----------------
13:29:44 <Gracenotes> yes, that's it
13:29:46 <vixey> Gamma |- \x -> M :: T -> S
13:29:47 <afedorov> when installing cabal: Setup: At least the following dependencies are missing: HTTP >=3000 && <3002, network >=1 && <3
13:29:48 <Gracenotes> and ski_ is the bottom line
13:29:49 <ddarius> roconnor: Just generate two Integers and "divide" them.
13:29:51 <Gracenotes> *had
13:29:52 <afedorov> what it HTTP and network?
13:29:58 <ddarius> roconnor: Should be good enough.
13:30:06 <afedorov> (I got zlib using apt-get)
13:30:11 <Gracenotes> vixey: how do you read that?
13:30:34 <Heffalump> afedorov: both packages on hackage
13:30:41 <vixey> Gracenotes, well one rule on it's own you would read differently from a derivation tree of the rules.. which you read from the bottom upwards
13:30:45 <Heffalump> it's not much fun getting cabal installed, I'm afraid
13:30:52 <Heffalump> once you have it working then everything is nice :-)
13:30:57 <afedorov> Heffalump: is there any way of installing them without manual download/compile?
13:31:06 <leimy> dcoutts: as a result, I'm not really sure how to fix the attributes on "cabal"
13:31:12 <afedorov> Heffalump: gotcha, is it hard to get things into apt-get repositories?
13:31:18 <Heffalump> not that I'm aware of (though there is a shell script that'll do it for you)
13:31:21 <leimy> unless windows still has good ole DOS attrib
13:31:30 <afedorov> Heffalump: where is the shell script?
13:31:31 <Heffalump> afedorov: not particularly hard, but noone's done it
13:31:32 <paolino> Heffalump: if you have more than 256 meg for linking it (cabal install)
13:31:39 <Gracenotes> vixey: I know... but, say, you had the communicate the rule in English without relying on notation. Would |- translate to "satisfies", then?
13:31:42 <Heffalump> it's called bootstrap.sh - I think it's in the cabal-install tarball?
13:31:56 <vixey> Gracenotes, that's what it's called, or turnstile
13:32:00 <Gracenotes> *to communicate, argh
13:32:00 <ski_> Gracenotes : `entails'
13:32:02 <afedorov> yes, that script is what's complaining about HTTP and network missing
13:32:11 <Gracenotes> ah.
13:32:15 <Heffalump> really? It should go and download them itself.
13:32:18 <Heffalump> I thought.
13:32:46 <afedorov> Heffalump: maybe I'm missing something, let RTFM a bit
13:33:41 <ddarius> Usually |= is used for "satisfies"
13:34:15 <afedorov> It errored out installing HTTP with "Setup: At least the following dependencies are missing: network -any, parsec -any"
13:34:26 <afedorov> maybe if I install parsec
13:34:37 <leimy> Oh well used --user
13:34:40 <leimy> seems to have worked.
13:34:41 <Gracenotes> ah, http://en.wikipedia.org/wiki/Turnstile_(symbol)
13:38:40 <Heffalump> afedorov: umm, hangon
13:38:47 <Heffalump> which version of HTTP do you have?
13:39:42 <afedorov> not sure, how do I check?
13:39:47 <Heffalump> what was the tarball you downloaded
13:39:58 <Heffalump> actually, shall I just give you a cabal binary you can use to get yourself going?
13:40:01 <afedorov> didn't download a tarball, expecting it to DL it for me
13:40:08 <Heffalump> obviously you'll have to trust a random binary from a stranger
13:40:14 <afedorov> :)
13:40:27 <afedorov> sure, what could possibly go wrong?
13:40:28 <Gracenotes> ah. a |- b <=> assuming a, then b. got it
13:40:52 <Gracenotes> not the same thing as =>, I take it?
13:40:53 <afedorov> Configuring HTTP-3001.1.3...
13:40:59 <Heffalump> ok, so that is the right version
13:41:11 <vixey> Gracenotes, when you have deduction theorem  a |- b, mean that |- a => b
13:41:14 <ddarius> Gracenotes: It is a form of implication (usually), but at a different level.
13:41:22 <vixey> Gracenotes, you may not have 'deduction theorem'
13:41:54 <Gracenotes> ah. A (presumably helpful) abstraction on implication
13:42:13 <afedorov> that complains about network missing, I have network-2.2.0.1 downloaded, not sure how to install it
13:42:20 <afedorov> I ran ./configure ... then what?
13:42:40 <dcoutts> Heffalump: so would you need it to consult the %http_proxy% before the register, or would after work?
13:42:43 <vixey> Gracenotes, it's a way to give inductive description of something -- like how you write  data Tree a = Leaf a | ..., to describe every tree..  you can write all the natural deduction rules to describe a logic or whatever
13:42:50 <afedorov> there is an install-sh...
13:42:51 <roconnor> @type properFraction
13:42:52 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> (b, a)
13:43:33 <vixey> (maybe that doesn't make things clearer to you though...)
13:44:07 <Gracenotes> it probably will as I see it more
13:44:21 <Heffalump> dcoutts: after would work, but that seems to be the wrong order to me, because environment variables can be overridden on a local basis
13:44:23 <dcoutts> leimy: what does this print? : ghc -e 'System.Directory.getAppUserDataDirectory "cabal" >>= print'
13:44:25 <Gracenotes> I'm on the Simply Typed Lambda Calculus chapter of TAPL
13:44:29 <Heffalump> and the registry can't (where local = per-shell/process)
13:44:33 <stepcut> how do a generically extract all the strings from a data type? The 'obvious' solution is too liberal in finding *all* the strings,
13:44:34 <stepcut> *Main Data.Generics> listify (False `mkQ` (\ (_::String) ->True)) ("one","two") :: [String]
13:44:35 <stepcut> ["one","ne","e","","two","wo","o",""]
13:44:45 <Heffalump> and I can't see why anyone would have it set without meaning it
13:44:59 <dcoutts> Heffalump: true, but I worry a bit about doing things that are not native to the platform
13:45:27 <dcoutts> Heffalump: I was just about to lookup if we could ask the MS http dll
13:45:37 <leimy> dcoutts:  looks like nothing
13:45:40 <dcoutts> leimy: that directory should be where the files are
13:45:47 <dcoutts> leimy: what? ""
13:46:02 <leimy> dcoutts:  it printed nothing.
13:46:21 <dcoutts> leimy: try it in ghci: System.Directory.getAppUserDataDirectory "cabal"
13:46:25 <leimy> in ghci it printed something :-)
13:46:29 <leimy> but yes that's where the files are.
13:46:35 <dcoutts> leimy: ok, good
13:46:44 <roconnor> should fromHLS have type (a,a,a) -> RGB a or type  a -> a -> a -> RGB a
13:46:46 <roconnor> ?
13:46:47 <dcoutts> leimy: that's also where the config file lives
13:46:54 <Heffalump> dcoutts: that'd be neat if you can
13:47:21 <vixey> a -> a -> a -> RGB a
13:47:34 <dcoutts> leimy: you can either put that bin directory on your %PATH% or use the config file to set the bindir to some other directory that is on your %PATH%
13:47:38 <vixey> actually that could be just as awkward
13:47:58 <pumpkin> roconnor: maybe a constructor HLS with three parameters?
13:48:12 <leimy> dcoutts: cool thanks!
13:48:13 <roconnor> pumpkin: another option
13:48:56 * roconnor ponders
13:49:02 <dcoutts> Heffalump: do you think you're using this: http://en.wikipedia.org/wiki/Web_Proxy_Autodiscovery_Protocol
13:49:11 <roconnor> I think I prefer (a,a,a) -> ... over a -> a -> a -> ...
13:49:23 <roconnor> because partial application seems unlikely
13:49:27 <dcoutts> Heffalump: or is it an explicitly configured auto configuration thing where you've got some url to a .pac file?
13:49:35 <roconnor> and having a triple in hand is moderately likely
13:49:35 <Heffalump> it's a URL to a .pac file
13:49:38 <Heffalump> I'm fairly sure
13:49:59 <Heffalump> yep, it is
13:50:01 <roconnor> an HSL constructor and type is also possible
13:50:03 <quicksilver> stepcut: that's an example of one of the flaws in generics.
13:50:04 <roconnor> Hmmm
13:50:07 <quicksilver> stepcut: it can't tell the difference
13:50:13 <roconnor> I wonder if HSL is a "view" of RGB
13:50:23 <roconnor> should I read about view patterns?
13:50:34 <Heffalump> I generally set http_proxy by doing a netstat to see where my browser is looking :-)
13:50:50 <vixey> roconnor, there is nothing to view patterns though
13:51:03 <stepcut> quicksilver: yeah...
13:51:16 <vixey> it's just instead of calling  f (foo x),  you implement  f (foo -> ...) = ..,  and call f x
13:51:24 <dcoutts> Heffalump: heh heh.
13:51:33 <pumpkin> anyone know where I can find an "empty" package.conf for ghc-pkg?
13:51:45 <dcoutts> pumpkin: []
13:51:49 <pumpkin> lol
13:51:50 <pumpkin> okay :)
13:52:01 <dcoutts> Heffalump: so I guess we should allow a http_proxy override, either by env var or the cabal config file.
13:52:14 <dcoutts> Heffalump: even if we try to use the WinHTTP lib
13:52:19 * ski_ wonders how reasoning rules for view patterns would look
13:52:43 <stepcut> quicksilver: perhaps if it did a top-down search and stopped recursion on a particular when the predicate returned a match
13:52:56 <dcoutts> Heffalump: I don't suppose wget/curl work for you do they? I wonder if they know how to get the proxy on windows.
13:53:00 <quicksilver> stepcut: then it wouldn't do the right thing when that *is* what you want it to do.
13:53:06 <stepcut> particular *branch*
13:53:07 <Heffalump> I don't think they do, no
13:53:08 <quicksilver> stepcut: still, there might be a way of encoding both choices.
13:53:17 <Heffalump> I'm not sure what darcs does that makes it respect http_proxy
13:53:36 <sclv> Heffalump: it asks for it is what.
13:53:41 <stepcut> quicksilver: I figured there would be a different function that captured that particular behaviour. Similar to how there is everywhere vs everywhere'
13:54:00 <Heffalump> sclv: huh?
13:54:18 <Heffalump> oh, you mean it explicitly does it itself, rather than delegating to a library?
13:54:24 <sclv> exactly
13:54:31 <roconnor> vixey: well, foo should return a transparent data type.
13:54:35 <roconnor> right?
13:54:52 <vixey> what does transparent mean?
13:56:11 <roconnor> vixey: the constructors are available to be pattern matched
13:56:14 <roconnor> I made up the term
13:56:24 <roconnor> the opposite of an abstract data type
13:56:53 <ski_> (one could `f (foo -> (bar -> ...)) = ...' ..)
13:57:07 <roconnor> oh god
13:57:23 * roconnor uses a case statement for the first time in 4 years
13:57:24 <vixey> , let f (reverse -> (reverse -> (reverse -> (x:_)))) = x in f "foo"
13:57:25 <lunabot>  'o'
13:57:28 <vixey> wow!
13:57:32 <vixey> it really did work
13:57:50 <ski_> it would be broken if it didn't
13:58:04 <ehird> , let f (f -> x) = x in f "hi"
13:58:10 <vixey> , let f (x:reverse -> (y:reverse -> (z:reverse -> _))) = (x,y,z) in f "abcxyz"
13:58:10 <lunabot>  Killed.
13:58:11 <lunabot>  luna: Couldn't match expected type `[Luna.SimpleReflect.Expr]'
13:58:34 <vixey> , let f (x:(reverse -> (y:(reverse -> (z:(reverse -> _)))))) = (x,y,z) in f "abcxyz"
13:58:36 <lunabot>  ('a','z','b')
14:03:49 <ski_> the `->' in view patterns appears to be some kind of inverse
14:05:27 <roconnor> My HSL and HSV converters are working now
14:06:22 <ski_> x  =  foo -> foo x  -- i think
14:06:53 <roconnor> I suppose foo (hsl -> (h,s,l)) reads nicer that foo (hsl -> HSL h s l) ?
14:07:25 <ski_> roconnor> :t HSL
14:07:53 * vixey prefers  foo (hsl -> h s l)  but this _also_ isn't implemented yet
14:07:59 <roconnor> HSL :: a -> a -> a -> HSL a
14:08:23 <roconnor> data HSL a = HSL a a a
14:08:33 <roconnor> maybe with bangs
14:08:39 <ski_> vixey : with `hsl' of type ?
14:08:44 <jeffwheeler> @users
14:08:45 <lambdabot> Maximum users seen in #haskell: 664, currently: 651 (98.0%), active: 31 (4.8%)
14:09:01 <roconnor> hsl :: RGB a -> HSL a  or hsl :: RGB a -> (a,a,a)
14:09:06 <vixey> ski_, I read it's supposed to desugar into: (hsl -> (h,s,l))
14:09:14 <vixey> but GHC doesn't support it (yet?)
14:09:28 <vixey> that & => for Maybes would be great
14:09:28 <ski_> roconnor : if `hsl' is just meant for unpacking `RGB a' into a specific representation, then it may be better to avoid a `HSL a' type ..
14:09:47 <roconnor> ski_: that is what it is meant for
14:09:58 <ski_> vixey : i wouldn't appreciate such a desugaring
14:10:12 <vixey> ski, oh why not?
14:10:15 <vixey> It seemed good to me
14:11:10 <ski_> (one could maybe consider `foo (hsl -> h s l) = ..h..s..l..' being desugarable, with `hsl :: RGB a -> (a -> a -> a -> o) -> o' or something similar .. hm)
14:11:32 <ski_> vixey : i like for the spaces in `h s l' to mean function application, like it usually does
14:12:21 <ski_> vixey : an alternative might be to allow tuples without outer parens (like OCaml) .. but possibly this would lead to other syntactic problems ?
14:12:39 <vixey> m yeah I see what you mean
14:12:41 <roconnor> hsl is just a view of RGB
14:12:50 <ski_> (so `foo (hsl -> h , s , l) = ..h..s..l..')
14:12:50 <pumpkin> I'd really like for there to exist an "applyable" typeclass that allows me to define function application for other types
14:13:10 <vixey> pumpkin, I just import Prelude hiding (($)) when I want to do that
14:14:02 <ski_> (vixey : as an example, should `f (foo -> App e0 e1) = ..' not mean the same as `f (foo -> (App e0 e1)) = ..' ?)
14:14:29 <pumpkin> vixey: $ is okay, but nothing would be better :)
14:15:28 <ski_> roconnor : so is there any reason at all for having the type `HSL a', apart for having a curried constructor to match on ?
14:15:59 <ski_> (roconnor : btw, i suppose `foo (hsl -> (,,) h s l) = ..' would work)
14:16:10 <pumpkin> wouldn't it allow you to prevent someone foolishly calling fromHSL on an RGB triple?
14:16:12 <vixey> ski_, since it stared with a constructor I think it comes out different. but when you put it that way .. yeah it's a bit ugly to have this special case
14:16:44 <roconnor> ski_: It would make fromHSL :: HSL a -> RGB a "feel" nicer than fromHSL :: (a,a,a) -> RGB a
14:16:47 <ski_> , let foo (id -> (,) a b) = b a in foo (3,succ)
14:16:49 <lunabot>  4
14:18:01 <ski_> roconnor : hm, i suppose there's the naming issue
14:18:14 <ski_> we really ought to have lightweight records
14:18:32 <ski_> (roconnor : i.e., with `HSL a' you can have named fields)
14:18:39 <roconnor> ski_: I'm probably not going to make the HSl type
14:19:00 <roconnor> I have hue, saturation, and lightness function of type RGB a -> a
14:19:12 <chessguy> pumpkin:  did you see the thread on -cafe today about that function?
14:19:31 <ski_> roconnor : maybe you should make those into lenses ..
14:19:35 <pumpkin> chessguy: which thread is that? I don't think so
14:19:46 <roconnor> ski_: okay.  How do I do that?
14:19:51 <pumpkin> chessguy: oh, your function from yesterday
14:19:53 <pumpkin> chessguy: yeah, saw that
14:19:55 <chessguy> pumpkin:  yeah
14:20:11 <ski_> roconnor : you need some definition of a lens (i forget if there's any library yet)
14:20:19 <roconnor> :D
14:20:46 <ski_> roconnor : e.g. `newtype Lens a b = MkLens {unLens :: a -> (b,b -> a)}'
14:21:57 <pumpkin> chessguy: pretty elegant solution :) way better than mine :P
14:22:33 <ski_> then you can define `get :: Lens a b -> (a -> b)',`set :: Lens a b -> b -> (a -> a)',`modify :: Lens a b -> (b -> b) -> (a -> a)'
14:23:21 <ski_> (and `compose :: Lens a b -> Lens b c -> Lens a c')
14:23:46 <ski_> roconnor : you get the idea ?
14:23:48 <chessguy> ski_:  what is a Lens in this context?
14:24:11 <ski_> chessguy : a lens represents a "position" in a datastructure
14:24:38 <ski_> a value of type `Lens a b' represents a position of type `b' in any value of type `a'
14:25:08 <chessguy> ah. thanks
14:25:28 <ski_> if your position doesn't always exist it might be better to use partial lenses (with `Maybe' in the data type)
14:26:05 <ski_> possibly one could generalize this to any functor ?
14:26:11 <Heffalump> ski_: Data.Accessor
14:26:22 <Heffalump> data-accessor on hackage I think
14:28:11 <roconnor> I thought coarbitrary was well motivated in the QuickCheck documentation
14:28:37 <gwern> is there any better way to write 'Just (ExitFailure a) →  exitWith (ExitFailure a) '?
14:29:04 <gwern> I also have 'Just ExitSuccess →  exitWith ExitSuccess'
14:29:13 <Deewiant> fmap exitWith?
14:29:23 <Deewiant> err, no
14:29:23 <gwern> I was wondering if there was anyway to rewrite this case to be like 'Just a -> exitWith a'
14:29:35 <Heffalump> gwern: why can't you do precisely that?
14:29:41 <Deewiant> Is there a reason why... yeah :_P
14:29:45 <pumpkin> lol
14:29:52 <ddarius> If State models having a single piece of updatable state, does BackwardState model having a single piece of downdatable state?
14:29:53 <gwern> oh. it does work
14:30:07 <gwern> I just assumed it wouldn't be so sensible as to work like that :)
14:30:16 <FunctorSalad_> @let eps = 2 * head [d | d <- [ 2**n | n <- [-1,-2..] ] , 1 + d == 1 ]
14:30:18 <lambdabot>  Defined.
14:30:19 <Heffalump> how did you think the binding of 'a' in the ExitFailure line worked, then? :-)
14:30:21 <FunctorSalad_> > eps
14:30:21 <Deewiant> > eps
14:30:23 <yuriks> OK, so I am here
14:30:23 <lambdabot>   2.220446049250313e-16
14:30:23 <lambdabot>   2.220446049250313e-16
14:30:36 <gwern> Heffalump: I don't know how anything works. it's all black magic to me
14:30:55 <FunctorSalad_> @let r = mkStdGen 2
14:30:56 <lambdabot>  Defined.
14:31:11 <FunctorSalad_> > take 10 $ randomRs (1,1+eps) r
14:31:12 <roconnor> > let epsilon = encodeFloat 1 (fromIntegral $ 1-floatDigits epsilon) in epsilon
14:31:13 <lambdabot>       Ambiguous occurrence `r'
14:31:13 <lambdabot>      It could refer to either `L.r', defined a...
14:31:14 <lambdabot>   2.220446049250313e-16
14:31:19 <centrinia> > eps :: Float
14:31:21 <lambdabot>   1.1920929e-7
14:31:28 <roconnor> > let epsilon = encodeFloat 1 (fromIntegral $ 1-floatDigits epsilon) in epsilon :: Float
14:31:30 <lambdabot>   1.1920929e-7
14:31:31 <Deewiant> > > eps :: CReal
14:31:32 <lambdabot>   <no location info>: parse error on input `>'
14:31:35 <Deewiant> > eps :: CReal
14:31:36 <Heffalump> gwern: I didn't mean how the internals worked, just what you can do
14:31:37 <yuriks> hey
14:31:37 <lambdabot>   0.0
14:31:45 <FunctorSalad_> > take 10 $ randomRs (1,1+eps) (mkStdGen 2) -- why does this generate numbers less than 1? :(
14:31:47 <lambdabot>   [0.9999999999999999,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0]
14:31:49 <yuriks> in, for example
14:31:59 <yuriks> data BookInfo = Book Integer String [String]
14:32:01 <pumpkin> roconnor: there's an epsilon in the Numeric.IEEE module btw
14:32:04 <yuriks> why do I need BookInfo?
14:32:04 <stepcut> gwern: how about, maybe (error " I don't know how to exit.") exitWith
14:32:15 <roconnor> pumpkin: oh.  How is it defined?
14:32:46 <pumpkin> roconnor: http://hackage.haskell.org/packages/archive/ieee/0.4/doc/html/src/Numeric-IEEE.html#epsilon
14:32:52 <FunctorSalad_> > take 10 $ randomRs (1,1+5*eps) (mkStdGen 2) -- this works
14:32:54 <lambdabot>   [1.0000000000000002,1.0000000000000007,1.0000000000000007,1.000000000000000...
14:33:23 <FunctorSalad_> but for (1,1+eps) we get 0.9999.... (no, not one ;))
14:33:29 <Heffalump> @src randomRs
14:33:30 <lambdabot> Source not found. Take a stress pill and think things over.
14:33:41 <int-e> > let x = 1+eps in x - 1 == eps
14:33:42 <lambdabot>   True
14:33:44 <FunctorSalad_> Heffalump: it's a method of Random
14:34:00 <roconnor> @where stress pill
14:34:01 <lambdabot> I know nothing about stress.
14:34:05 <ski_> yuriks : if you define a new type, you need to name it something
14:34:17 <yuriks> ski_: yeah, but that's what Book does
14:34:31 <ski_> yuriks : no, `Book' is the data constructor
14:34:39 <roconnor> > let epsilon = encodeFloat 1 (fromIntegral $ 1-floatDigits epsilon) in sqrt epsilon
14:34:41 <lambdabot>   1.4901161193847656e-8
14:34:41 <FunctorSalad_> I correct myself... with 5*eps you eventually get something < 1 too
14:34:55 <Heffalump> FunctorSalad_: looks like dodgy floating point code in the instance (just skimming the source now)
14:35:08 <yuriks> ski_: oh, I see, so uh, would BookInfo be the "class" and Book be it's "constructor"?
14:35:09 <roconnor> pumpkin: that's a nice set of values
14:35:45 <ski_> yuriks : `Book' is the "data constructor" and `BookInfo' is the "data type"
14:35:50 <Heffalump> > eps
14:35:51 <lambdabot>   2.220446049250313e-16
14:35:56 <Heffalump> > eps :: Double
14:35:57 <lambdabot>   2.220446049250313e-16
14:36:01 <int-e> > let x = 2+eps in x == 2
14:36:03 <lambdabot>   True
14:36:07 <ski_> yuriks : in general, a data type can have several alternative data constructors
14:36:12 <Heffalump> > (1+eps) - eps
14:36:13 <lambdabot>   1.0
14:36:17 <ski_> @src Bool
14:36:18 <lambdabot> data Bool = False | True deriving (Eq, Ord)
14:36:20 <Deewiant> > 1+eps
14:36:20 <Heffalump> > (1+eps) - 1
14:36:21 <lambdabot>   1.0000000000000002
14:36:22 <lambdabot>   2.220446049250313e-16
14:36:24 <FunctorSalad_> > 1+eps > 1
14:36:26 <lambdabot>   True
14:36:28 <FunctorSalad_> :)
14:36:39 <ski_> yuriks : e.g. `Bool' has one data constructor `True', and another `False'
14:36:41 <chessguy> 1+eps == 1
14:36:47 <Heffalump> > realToFrac (toInteger (maxBound::Int32) - toInteger (minBound::Int32))
14:36:47 <int-e> FunctorSalad_: it happens because the generator takes the midpoint of the interval, +/- half its length.
14:36:47 <chessguy> > 1 + eps == 1
14:36:49 <lambdabot>   4.294967295e9
14:36:49 <lambdabot>   False
14:36:56 <int-e> FunctorSalad_: I have no clue why it's implemented that way
14:36:59 <Heffalump> > floor $ realToFrac (toInteger (maxBound::Int32) - toInteger (minBound::Int32))
14:37:01 <lambdabot>   4294967295
14:37:04 <FunctorSalad_> int-e: doh!
14:37:11 <FunctorSalad_> int-e: thanks :)
14:37:41 <yuriks> ski_: oh, ok, I was used to the constructor having the same name as the type, thanks
14:37:43 <Heffalump> int-e: that's what I was getting at above, but it's not immediately obvious to me why that causes the problem
14:37:57 <Heffalump> > eps / realToFrac (toInteger (maxBound::Int32) - toInteger (minBound::Int32))
14:37:59 <lambdabot>   5.169878829660129e-26
14:38:19 <ski_> yuriks : it is possible to use the same name for a data constructor as for a type ..
14:38:20 <Heffalump> > (2+eps)/2
14:38:20 <yuriks> ski_: oh, and they CAN be
14:38:21 <lambdabot>   1.0
14:38:29 <int-e> Heffalump: because (2+eps)/2 == 1 != 1 + eps/2
14:38:47 <Heffalump> oh, duh.
14:38:50 <ski_> (yuriks : are you coming from Java ?)
14:38:53 <Heffalump> I was getting confused because eps didn't seem that small.
14:38:57 <yuriks> ski_: this book is confusing -_- (Real World Haskell)
14:38:58 <Heffalump> > 1 + eps/2
14:39:00 <lambdabot>   1.0
14:39:09 <Heffalump> but I don't believe your != bit
14:39:11 <yuriks> ski_: C, C++, Python, C#, Java, ...
14:39:14 <Heffalump> > (2+eps)/2 == 1+eps/2
14:39:15 <lambdabot>   True
14:39:23 <yuriks> ski_: I still don't know how to do anything useful with tuples
14:39:24 <int-e> Heffalump: ah, sorry, the 1 + eps/2  was meant to be the exact value
14:39:28 <chessguy> yuriks:  haskell is a bit different
14:39:30 <Heffalump> ah, ok
14:39:53 <chessguy> yuriks:  what would you want to do with tuples?
14:40:19 <yuriks> chessguy: access it's contents
14:40:27 <chessguy> > fst (2,3)
14:40:29 <lambdabot>   2
14:40:31 <njbartlett> I really wish this "comments from OCaml hacker..." thread would die.
14:40:31 <chessguy> > snd (2, 3)
14:40:33 <lambdabot>   3
14:40:37 <T55555> newbie question:  is it possible the type is Monad of Monad ?  kind like f :: Int -> IO ( IO ( IO ( Maybe Int ) ) )  does it make sense ?
14:40:41 <yuriks> ok, and what about (2,3,4)?
14:40:50 <chessguy> T55555:  um.....no
14:40:57 <Heffalump> njbartlett: it is getting a bit repetitive
14:41:15 <chessguy> yuriks:  that's a different type
14:41:26 <sbahra> > (\(x, y, z) -> z) (2,3,4)
14:41:26 <ski_> > let (x,y,z) = tuple in x*y*z  where tuple = (2,3,4)
14:41:27 <yuriks> chessguy: yes, but it's a tuple too, no?
14:41:27 <lambdabot>   4
14:41:28 <lambdabot>   24
14:41:31 <FunctorSalad_> > join (Just (Just 1)) -- T55555
14:41:33 <lambdabot>   Just 1
14:41:46 <sbahra> :t join
14:41:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:42:01 <asgaroth> T55555: Perhaps you want monad transformers? (Like do some IO inside a State monad)?
14:42:02 <FunctorSalad_> T55555: in fact join is (part of) one of the alternative methods of defining what a monad is
14:42:12 <ski_> yuriks : you can pattern-match on the tuple, by either using `let' or `case' .. or by matching in the argument of a function definition
14:42:19 <chessguy> yuriks:  yes, but for tuples of size larger than 2, you have to use pattern-matching to extract the contents
14:42:33 <chessguy> > let f (x,y,z) = z in f (2,3,4)
14:42:34 <lambdabot>   4
14:42:59 <Twey> fst/snd are just handy pre-defined functions for use on pairs, since they're the most common tuples
14:43:14 <Twey> You have to understand that 'tuple' isn't a single type but a class of types
14:43:20 <pumpkin> I'm getting "HsColour needed but wasn't found." when trying to build the GHC head... anyone know what to do to stop it? it says "Set HSCOLOUR_SRCS=NO if you don't want to use it" but it isn't listening to that as an environment variable
14:43:21 <ski_> T55555 : if you're asking whether a monadic action may return another monadic action, then the answer is yes
14:43:22 <yuriks> yeah, I got that
14:43:22 <sbahra> > (,) 1 2
14:43:23 <lambdabot>   (1,2)
14:43:25 <Twey> (not a typeclass)
14:43:27 <chessguy> err, i'd be careful about calling it a type
14:43:31 <chessguy> err, class
14:43:32 <yuriks> I was expecting something like t[2] though =P
14:43:45 <T55555> @ski_ that's what I mean!
14:43:45 <lambdabot> Unknown command, try @list
14:43:52 <chessguy> yuriks:  there are plenty of surprises in haskell )
14:43:54 <chessguy> :)
14:43:58 <yuriks> =(
14:44:00 * chessguy can't type today
14:44:06 <Twey> Hehe
14:44:07 <chessguy> yuriks:  surprises are not necessarily bad
14:44:22 <yuriks> ok, so the only way to access tuple contents is by tuple unpacking, not bad
14:44:35 <Twey> yuriks: But you don't get that, because they're not lists or even list-like
14:44:49 <yuriks> Twey: yeah yeah, they aren't a collection, I get it
14:44:50 <chessguy> yuriks: you'd do better to call it "pattern matching", because it's more general than just for tuples
14:44:51 <Twey> Python tuples are just immutable lists; Haskell tuples are something quite different altogether
14:44:53 <T55555> so, monadic return another monadic action is Ok, seems to me I never saw any code have IO ( IO ... ) type.
14:45:26 <chessguy> T55555:  why would you want that?
14:45:27 <ski_> T55555 : it's not useful very commonly
14:45:40 <T55555> just for curisority
14:46:19 <Twey> Well, it's perfectly possible
14:46:23 <int-e> pumpkin: you can change it in mk/build.mk
14:46:26 <ski_> chessguy : for some reason you might want to return an action that will be run later, when the caller chooses
14:46:32 <Twey> You'd have to unsafePerformIO to get it out again, though
14:46:38 <pumpkin> thanks :) I was more heavy-handed and just set it in the MAkefile itself
14:46:50 <Twey> ski_: Just a simple IO a would work for that
14:46:54 <ski_> Twey : get what out ?
14:46:59 * yuriks isn't used to thinking in expressions
14:47:14 <chessguy> yuriks:  it's definitely an adjustment
14:47:19 <Twey> The inner IO monad from an IO (IO a)
14:47:27 <ski_> Twey : not if you're writing a function that needs to do some I/O, and want to return an action to be run later, that also needs to do I/O
14:47:44 <Twey> True
14:47:51 <ski_> Twey : `join :: IO (IO a) -> IO a' seems safer to me ..
14:47:54 <Twey> Ooh
14:47:57 <Twey> Good point
14:47:59 <ski_> (and probably what you want)
14:48:38 <leimy> Hmmm today I've had to write Haskell, Erlang and C#
14:48:40 <leimy> nice mix :-)
14:48:47 <leimy> on windows and Mac OS X
14:49:37 <chessguy> is there a relationship (conceptually) between typeclasses and type families?
14:50:00 <T55555> Oh. that's right :t join is  Monad ( Monad ... )) . Thanks.
14:50:08 <ski_> no
14:50:10 <ski_> @type join
14:50:11 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:50:20 <ski_> `m' is not the same as `Monad'
14:50:30 <ski_> `m' is a type that is *a* `Monad'
14:50:36 <pumpkin> Monad isn't a type, it's a typeclass
14:52:20 <T55555> I see.  so Monad IO ==> IO is instance of Monad
14:53:05 <ski_> yes
14:53:53 <chessguy> @kind (3::Int)
14:53:54 <lambdabot> parse error on input `Int'
14:54:01 <chessguy> :kind Int
14:54:11 <chessguy> @kind Int
14:54:12 <lambdabot> *
14:55:18 <T55555> still kind of confuse me... type1 type2  ( when we see IO Int ) can we think it is like "type1 type2" as its type ? how about arrow with "a b c" ( type1 type2 type3 as new type ? )
14:56:23 <ski_> @type getLine
14:56:24 <lambdabot> IO String
14:56:34 <ski_> `IO String' is the type there
14:56:50 <T55555> combine type ?
14:56:53 <chessguy> @src Maybe
14:56:53 <lambdabot> data Maybe a = Nothing | Just a
14:57:01 <ski_> you can think of that as "`IO' of `String'"
14:57:19 <chessguy> "Maybe a" is a parameterized type. it's not a full type, because it has a type variable in it
14:57:20 <ski_> just as `[Int]' is "list of `Int'"
14:57:28 <chessguy> "Maybe Int" is a type
14:57:59 <ski_> (i'd say `Maybe a' is a "full type" .. however `Maybe' wouldn't be)
14:58:17 <ski_> (of course assuming that `a' is a "full type")
14:59:54 <chessguy> hm, i should probably just STFU and let you explain :)
15:00:23 <T55555> thanks ski_ & chessguy
15:00:56 <ski_> np
15:01:57 <T55555> IO Int ==> IO is monad, by analog,  Maybe Int ==> Maybe is monad too ?
15:02:29 <ski_> `Maybe' happens to be a monad, yes
15:03:00 <ski_> however if you have a type `type type0', then `type' need not be a monad
15:03:03 <T55555> but Maybe is a algebric type ?
15:03:14 <ski_> yes
15:03:31 <ski_> `algebraic' refers to the way the type was defined
15:03:56 <ski_> `monad' refers to the type having some specific properties (regardless of how it is defined)
15:04:03 <T55555> so Maybe is a type and it is also instance of Monad typeclass, right ?
15:04:21 <ddarius> Maybe is not a type.
15:04:46 <Twey> Maybe is a type 'function'
15:04:50 <T55555> data Mabye = ...  ( data define new type !  so why Maybe is not type ?
15:04:56 <Twey> You apply it to something to get a type
15:05:01 <Twey> 'Maybe Int' is a type
15:05:03 <ski_> there's differing terminology, here
15:05:37 <Twey> T55555: Actually, it's data Maybe a = Nothing | Just a
15:05:46 <Twey> 'Maybe a' is the type
15:05:55 <T55555> oh. thanks.
15:06:04 <ddarius> ski_: Yes.  Correct terminology and incorrect terminology.
15:06:27 <ski_> ddarius :)
15:06:57 <Twey> Heh
15:08:03 <afedorov> does Haskell have a function like lisp's list?
15:08:19 <afedorov> list x = [x]
15:08:28 <afedorov> list x = x : []
15:08:36 <gwern> > map return [1,2] :: [Either String Int]
15:08:36 <afedorov> is there a built-in for that?
15:08:37 <lambdabot>   [Right 1,Right 2]
15:09:06 <gwern> hm. why does that work in 6.8 and not 6.10?
15:09:10 <olsner> afedorov: are you looking for a variadic function that generates a list of the same length?
15:09:10 <ziman> > return x
15:09:11 <lambdabot>       No instance for (Show (m Expr))
15:09:11 <lambdabot>        arising from a use of `show' at ...
15:09:18 <ziman> > return x :: [Expr]
15:09:20 <lambdabot>   [x]
15:09:27 <gwern> in 6.10 it gives me 'No instance for (Monad (Either String))'
15:09:30 <ski_> (ddarius : btw, which term do you propose for `Either String' ? "type constructor" ?)
15:09:36 <afedorov> olsner: no, just a function of one variable which returns a list with that character inside of it
15:09:42 <chessguy> afedorov:  that's just :[]
15:09:43 <ddarius> ski_: Yes.
15:09:45 <afedorov> oops, that variable
15:09:54 <chessguy> > (:[]) 3
15:09:55 <lambdabot>   [3]
15:10:01 <gwern> or to put it another way, is that map return supposed to work in 6.10?
15:10:02 <olsner> > (:[{- chomp -}]) 42
15:10:04 <lambdabot>   [42]
15:10:06 <afedorov> got it, no pretty name for that?
15:10:17 <chessguy> afedorov:  not really needed
15:10:28 <afedorov> chessguy: agreed
15:10:34 <chessguy> afedorov:  you could call it return, in some contexts
15:10:35 * gwern winces at olsner. that's not gonna work in 6.10 mueval
15:10:35 * ski_ would only call `Either' a type constructor .. never `Either String'
15:10:41 <chessguy> > return 3 :: [Int]
15:10:43 <lambdabot>   [3]
15:10:55 <yuriks> mapreduce: well, it defers some useful explanations to later on, like how to do pattern matching
15:11:08 <afedorov> hm, what is (:[]) ? confused - if (:[]) is the function name, why does it follow its arguments?
15:11:10 <yuriks> mapreduce: and I was confused about some other stuff I don't remember anymore =P
15:11:19 <afedorov> > (:) 3 4
15:11:21 <lambdabot>       No instance for (Num [t])
15:11:21 <lambdabot>        arising from the literal `4' at <inter...
15:11:25 <ddarius> ski_: Even taking that view, Either String or Either or Maybe are certainly not types.
15:11:26 <Deewiant> > (:) 3 [1,2]
15:11:27 <afedorov> > (:) 3 []
15:11:29 <lambdabot>   [3]
15:11:29 <lambdabot>   [3,1,2]
15:11:34 <afedorov> > (:) [] 3
15:11:35 <lambdabot>       No instance for (Num [[a]])
15:11:35 <lambdabot>        arising from the literal `3' at <int...
15:11:41 <Deewiant> > (:[]) 3
15:11:42 <lambdabot>   [3]
15:11:55 <afedorov> (3:) []
15:11:55 <Deewiant> > (: [1,2]) 3
15:11:57 <lambdabot>   [3,1,2]
15:11:58 <afedorov> > (3:) []
15:11:58 <T55555> :[] is not function name, (:) is function and [] is empty list
15:11:59 <lambdabot>   [3]
15:12:03 <afedorov> oooh, neat!
15:12:19 <afedorov> you can bind either the right or the left-hand argument to an infix operator?
15:12:33 <mapreduce> yuriks: Well, if there's a specific part, generally #haskell doesn't mind explaining things in a weird order.
15:12:33 <T55555> yes
15:12:45 <T55555> (+1)  or (1+)
15:12:51 <mapreduce> As there is no definite order for learning Haskell, but obviously a book such as RWH has rto choose one.
15:12:58 <mapreduce> s/rto/to/
15:13:03 <afedorov> well, it's even more interesting in terms of non-transitive operators
15:13:06 <afedorov> > (3:) [4]
15:13:08 <lambdabot>   [3,4]
15:13:08 <bombshelter13> mapreduce: hope it chose a good one cause that's the one i just ordered
15:13:09 <afedorov> > (:3) [4]
15:13:11 <lambdabot>       No instance for (Num [[t]])
15:13:11 <lambdabot>        arising from the literal `3' at <int...
15:13:18 <yuriks> mapreduce: yeah, I got my explanations, I guess I'm just an impatient guy =P
15:13:22 <afedorov> > (:[3]) 4 {-, that is -}
15:13:23 <lambdabot>   [4,3]
15:13:24 <mapreduce> bombshelter13: You can check online.  afaik yuriks is reading it online.
15:13:31 <mapreduce> yuriks: Fair enough.
15:13:38 <ski_> ddarius : so in `tau ::= ... | tau tau', you would call `tau' the syntactic category of type constructors ?
15:13:44 <bombshelter13> mapreduce: yeah, i don't like reading things that big on a screen.
15:13:50 <yuriks> yup http://book.realworldhaskell.org/read/
15:13:59 <bombshelter13> mapreduce: things on screens should be concise, hence the choice of language to learn. ;)
15:14:00 <T55555> (:3) [4] ==> [4]:3 ==> don't work.
15:14:14 <mapreduce> bombshelter13: I know what you mean, but it's good to have them on screen sometimes.
15:14:19 <ski_> T55555 : because `3' is not a list
15:14:37 <mapreduce> I'd like PDFs of all dead tree books I own.  Or to be 10 times the size I am so that I can carry them all easily.
15:14:41 <bombshelter13> mapreduce: yup yup - great for reference, not so great for cover to cover reading
15:14:49 <T55555> that's right. I try to explain to afedorov what's going wrong
15:15:07 <ski_> (oh)
15:16:15 <ddarius> ski_: In Haskell, I'd call everything at the type level type constructors and things of kind * types.  In other languages I may use more refined terminology, though types would still be those things that would have the equivalent of kind *.
15:16:31 * Heffalump would like an e-book reader he can operate with one hand
15:16:37 <Heffalump> (and a decent range of books for it)
15:17:21 <pumpkin> Heffalump: with an A4/letter screen, too!
15:17:34 <ddarius> (Actually with type families, things are starting to get more muddied.)
15:17:52 <Heffalump> not so sure about that, A5 or a bit smaller would be better, I think
15:18:13 <pumpkin> Heffalump: it'd be handy to be able to read papers on the screen though
15:18:16 <pumpkin> wihtout having to pan/zoom
15:18:22 <Heffalump> true
15:18:34 <Heffalump> my main current application is being able to read a book while feeding a baby
15:18:48 <Heffalump> and I don't think I'd be able to concentrate on a paper then
15:23:20 <ski_> (ddarius : how so ?)
15:26:33 <ddarius> ski_: It starts in on arbitrary type functions.  I don't call everything of type t -> t' a data constructor.
15:27:29 <afedorov> T55555: yes, got that, thanks :)
15:28:04 <T55555> np
15:29:30 <ski_> ddarius : oh .. i just thought you meant earlier that you call any expression on the type level a `type constructor', no ?
15:29:56 <ski_> sorry, misread what you said
15:30:33 <ddarius> ski_: I do call any expression at the type level (modulo perhaps some newer extensions) a type constructor.
15:30:39 <koeien> suppose i have a typeclass C with "member" x :: a. can i refer, in the default implementation of another function in the same typeclass to this value "x" ?
15:31:04 <ddarius> Int is a type constructor, (Either String Int ->) is a type constructor, Mu is a type constructor.
15:31:20 <koeien> i.e.    class C a where { x :: a; f :: Int -> a; f y = .... x .... }
15:31:30 <ddarius> Type constructor corresponds to value at the value level (currently).
15:32:14 <ddarius> More specifically it corresponds to data constructor but there are essentially only data constructors (excepting newer extensions and viewing type synonyms as their expansions)
15:32:15 * dolio mutters to himself.
15:33:27 <dolio> "Associativity means x + (y + z) = (x + y) + z" is too hard now?
15:33:39 <roconnor> ghc-6.8.2: unrecognised flags: -fenable-rewrite-rules
15:33:41 <roconnor> :(
15:33:46 <ski_> koeien : yes
15:34:10 <koeien> ski_: i get a type error though. i can't seem to "fix" the variable x to the right type
15:34:32 <roconnor> ah This flag is implied by -O
15:34:42 <ddarius> dolio: I agree with you completely.
15:34:54 <kerlo> dolio: presumably, someone is providing a longer definition of associativity that you find unnecessary.
15:34:55 <ski_> (dolio : ?)
15:35:07 <ddarius> dolio: I learned the definition of associativity in 6th grade (that I can remember) and possibly earlier.
15:35:09 <dolio> ddarius: We should instead explain it "intuitively" so that our description gets confused with commutativity. :)
15:35:20 <dolio> ddarius: Yeah, me too.
15:35:23 <dons> ?users
15:35:24 <lambdabot> Maximum users seen in #haskell: 664, currently: 620 (93.4%), active: 28 (4.5%)
15:36:03 <dolio> kerlo: That, and the guy specifically said that "x + (y + z) = (x + y) + z" is too obscure.
15:36:24 <kerlo> Huh.
15:36:25 <dolio> ski_: Somewhere in the gigantic haskell-cafe thread.
15:36:30 <ddarius> dolio: Andrew Coppins should be ignored.
15:36:38 <ski_> explaining what something means is "too obscure", now ?
15:36:43 <kerlo> Do you have a link?
15:36:53 <dolio> ddarius: Yeah. He just always manages to baffle me somehow.
15:37:14 <dolio> I can try. But this thread is huge...
15:38:00 <koeien> kerlo: http://www.nabble.com/Comments-from-OCaml-Hacker-Brian-Hurt-td21480030i20.html
15:38:36 <Toxaris> I guess that Andrew feels like many learners of Haskell, just that most people don't tell all their feelings to haskell-cafe
15:38:51 <koeien> page 7, one-to-last post
15:39:13 <koeien> (dolio: did you mean that one?)
15:39:25 <ddarius> Toxaris: There's a -big- difference between Andrew and learners of Haskell.  They actually put out effort learning.
15:39:39 <dolio> koeien: Ah, yes.
15:39:46 <dons> hey, ddarius , 3 years. he can keep trying.
15:39:52 <dons> don't give up!
15:39:53 <dolio> You win the mailing list search contest.
15:39:59 <koeien> yay
15:40:09 <ehird> who's Andrew Coppins
15:40:14 <ddarius> dons: To quote that Don Stewart fellow, "Show me the code."
15:40:16 <Saizan> "but we should point out that "associativity means that the ordering of the operations does not affect the result" or something" <- the intuitive alternatives always end up wrong?
15:40:34 <dolio> He's Steven Hawkins' cousin.
15:40:43 <dons> he's very melodramatic, and it probably inflames threads.
15:41:25 <Toxaris> ddarius: I think he does, as in "starting toy projects and trying out language features", like many learners of programming languages
15:41:41 <dolio> Saizan: He even realizes that at the end, when he says that it's tricky to explain how associative is different from commutative.
15:41:52 <dolio> But that isn't hard at all, because commutative is "x + y = y + x".
15:41:54 <ddarius> Toxaris: To quote myself quoting Don Stewart, "Show me the code."
15:42:09 <Toxaris> ddarius: ok you win.
15:42:10 <bombshelter13> reminding first that I'm new to the language, so if this question is really stupid, forgive me, but - is a function that takes another function as it's argumen and returns it's definition as a string even vaguely feasible?
15:42:17 <koeien> i would say, "x + (y + z) = (x + y) + z, for all x, y, z" with an example.
15:42:22 <pumpkin> bombshelter13: nope :/
15:42:23 <koeien> bombshelter13: no. fundamentally impossible
15:42:29 <Saizan> yeah, it's hard only if your intuition of associativity is flawed
15:42:34 <bombshelter13> pumpkin, koeien: kk, I'll not try then ;)
15:42:35 <Toxaris> koeien: forall is scary
15:42:50 <ehird> koeien: not fundamentally impossible if you have the source file ;))
15:42:57 <koeien> yeah. with template haskell perhaps
15:43:11 <pumpkin> apparently not
15:43:16 <pumpkin> I was asking about that yesterday
15:43:44 <hugo___> hi
15:43:55 <dolio> bombshelter13: That'd let you distinguish between the same function implemented in two different ways. Which is a no-no.
15:44:29 <ddarius> Toxaris: Do you realize how long Andrew Coppins has been around?
15:44:36 <chessguy> > let f = \g -> uncurry (***) . (g *** g) in f (+) (1,2) (3,4)
15:44:37 <lambdabot>   (4,6)
15:44:47 <pumpkin> yay
15:45:01 <pumpkin> even prettier
15:45:15 <pumpkin> so much better than my monstrosity yesterday
15:45:16 <Toxaris> Toxaris: good question. /me thinks. longer then me.
15:45:27 * Toxaris talks to himself instead of ddarius 
15:45:42 <koeien> haskell drives people to insanity. finally proven.
15:45:55 <ddarius> koeien: I suspect most were insane when they came.
15:46:00 <dons> that thread is huge.
15:46:01 <thetallgu1> ghci question:  is there anything I can put in a file, then load, that will affect a setting, e.g., :set -fth
15:46:02 <koeien> at least I was =)
15:46:07 <dons> anyone want to do some statistical analysis of it?
15:46:15 <koeien> thetallgu1: yes. put it in ~/.ghci
15:46:39 <thetallgu1> koeien: I know about that.  I mean in a source file
15:46:50 <koeien> thetallgu1: {-# LANGUAGE TemplateHaskell #-}
15:46:53 <thetallgu1> the OPTIONS_GHC -fth pragma does not do it.
15:47:04 <thetallgu1> nor does that
15:47:04 <Toxaris> thetallgu1: I don't think thats possible
15:47:21 <thetallgu1> to be clear, I want to load a source file and then start typing interactively.
15:47:24 <Toxaris> thetallgu1: pragmas in source files work for the source file, not for some ghci session "around" processing that source file
15:47:37 <koeien> hmm. i doubt that is possible, without ~/.ghci
15:47:38 <kerlo> bombshelter13: of course, if you really want to do something like that, you can always pass around a definition *instead* of the function, and convert the definition to a function when you need to.
15:47:52 <thetallgu1> if I put the code in the file, it works fine, but it doesn't affect the interactive session
15:48:03 <koeien> thetallgu1: that's as designed
15:48:13 <thetallgu1> Thanks, that was my conclusion as well, just confirming.
15:48:20 <Toxaris> a nice feature would be if ghci could read needed language extensions from CABAL files
15:48:33 <Toxaris> so that I could start ghci for my project
15:48:36 <thetallgu1> koeien: yes, and it makes sense
15:48:46 <dcoutts> Toxaris: or the other way round, if cabal calls ghci with the right flags
15:48:53 <thetallgu1> Toxaris: yes, that's more like it
15:49:19 <thetallgu1> dcoutts: how would that itneract with starting ghci within emacs?
15:49:31 <dcoutts> Toxaris, thetallgu1: like http://hackage.haskell.org/trac/hackage/ticket/382
15:49:42 <dcoutts> thetallgu1: if emacs starts ghci directly then it's unaffected
15:49:55 <pumpkin> > let (@) = (+) in 5 @ 4 -- can @ be an operator?
15:49:56 <lambdabot>   <no location info>: parse error on input `@'
15:49:58 <pumpkin> :(
15:50:10 <bombshelter13> kerlo: hm, yeah... maybe useful... heh, I always tend to want to know if the reverse if possible, cause that seems like where you could do real magic.
15:50:12 <dolio> @ is reserved for @ patterns.
15:50:14 <koeien> pumpkin: it is used in pattern matches
15:50:16 <pumpkin> oh yeah
15:50:18 <pumpkin> forgot about that
15:50:23 <dolio> @@ is an operator, though.
15:50:23 <lambdabot>  is an operator, though.
15:50:25 <dcoutts> thetallgu1: I'd have cabal call ghci and set up the :load and :reload etc to call out to cabal to re-run any pre-processors etc
15:50:28 <bombshelter13> suppose I'll have to eventually make my language where functions do remain mutable. :)
15:50:38 <bombshelter13> s/my/my own/
15:50:45 <thetallgu1> dcoutts: oh I see, well then it would be simple to make emacs run cabal ghci instead of raw ghci
15:50:49 <pumpkin> > let (~) = (+) in 5 ~ 4 -- how about tilde
15:50:50 <lambdabot>   <no location info>: parse error on input `)'
15:50:54 <pumpkin> same issue with pattern matches?
15:50:55 <koeien> pumpkin: it's used in lazy pattern matches
15:51:00 <pumpkin> boo!
15:51:01 <thetallgu1> That would be satisfactory.
15:51:05 <pumpkin> I'm looking for something uncommon
15:51:22 <thetallgu1> blue moons?
15:51:22 <chessguy> > let (.~) = (+) in 5 .~ 4
15:51:23 <lambdabot>   9
15:51:49 <pumpkin> any uncommon (typable on a normal keyboard) single-character operators?
15:51:58 <pumpkin> maybe ?
15:52:11 <pumpkin> > let (?) = (+) in 5 ? 4
15:52:13 <lambdabot>   9
15:52:15 <koeien> pumpkin: | ? !
15:52:25 <Toxaris> > let () = (+) in 3  4
15:52:25 <pumpkin> a pipe might work nicely
15:52:27 <lambdabot>   7
15:52:33 <sjanssen> | isn't a valid operator
15:52:38 <athos> > let (~.~) = putStrLn "~.~" in ~.~
15:52:39 <lambdabot>   <no location info>: parse error on input `~.~'
15:52:39 <koeien> ehm sure
15:52:42 <athos> > let (~.~) = putStrLn "~.~" in (~.~)
15:52:43 <lambdabot>   * Exception: "<IO ()>"
15:53:01 <pumpkin> hmm
15:53:08 <koeien> you have UTF-8. i don't know what strange things you can do with that, i normally only use the ascii subset
15:53:13 <athos> > let (~.~) = "~.~" in (~.~)
15:53:14 <lambdabot>   "~.~"
15:53:18 <athos> ~.~
15:53:22 <athos> :>
15:53:28 <roconnor> ugh, gettin GHC rules to fire is really really hard
15:53:37 <pumpkin> maybe I'll use $$
15:53:39 <sjanssen> roconnor: yeah, it is a bit of a black art
15:53:43 <Toxaris> > let () = (.) in succ  succ $ 40
15:53:44 <lambdabot>   42
15:53:52 <sjanssen> roconnor: you've got to be skillfull with staging and NOINLINE
15:54:16 <roconnor> sjanssen: i'm looking at my core code and there are all these %local things
15:54:26 <roconnor> and if one was inlined, my rule would fire
15:54:42 <roconnor> I don't really understand why the need for so many of them
15:54:50 <roconnor> each is used only once
15:55:51 <dons> generally you have to not inline the thing you want to match on
15:55:54 <pumpkin> Toxaris: that's kinda nice
15:56:33 <thetallgu1> Are there flags to make ghc compile itself with multiple processors, or does it just do that automatically?
15:56:38 * ddarius should make a Turing machine in rewrite rules if someone else hasn't already done that.
15:56:53 <olsner> ddarius: I did that in an apache config once :)
15:57:20 <olsner> well, not a turing machine really, but a turing-complete something
15:57:24 <lament> ddarius: well there's brainfuck in Thue
15:57:47 <ddarius> lambda: GHC rewrite rules.
15:57:47 <roconnor> http://hpaste.org/14001 -- My rule example
15:57:52 <dons> would be a challenge,  i think, ddarius
15:57:53 <Toxaris> ddarius: can you make a Haskell-to-Rule compiler to enable staging?
15:58:01 <roconnor> how would I go about getting it to work properly?
15:58:10 <Toxaris> ddarius: similar in spirit to Olegs scheme-to-syntax compiler
15:58:27 <olsner> oh, *GHC* rewrite rules... now that's a different matter entirely
15:58:59 <olsner> but aren't rewrite rules meant to always terminate?
15:59:18 <dons> they can be confluent, terminating et al. but we choose not to bother :)
15:59:21 <ddarius> Aren't most programs meant to always terminate (or alternatively be productive?)
15:59:26 <dons> they just have to match lhs / rhs types
15:59:36 <dons> f x = f x - valid rewrite rule in ghc
16:00:06 <dons> f x = 1  ; f x = 2 -- sure, fine. makes no sense, but go for it.
16:00:14 <dons> (those are rules)
16:00:26 <Toxaris> with a lazy compiler + lazy RTS, non-terminating rules could produce more code while the initial part of the code is already executed
16:00:36 <roconnor> My goal is to get  (toSRGB24 seagreen) to compile down to (RGB 46 139 87) thus saving the conversion to and from Double.
16:00:54 <dons> roconnor: oh, that sounds reasonable
16:01:08 <dons> we have many such conversion rules in the Num class
16:01:14 <dons> lots of things for Int/a a/Int and so on
16:01:47 <dons> huh, ivan sutherland is in my office.
16:01:56 <roconnor> the definition of sRGB24 = sRGBBounded inlines nicely
16:02:05 <thetallgu1> dons: cool!
16:02:07 <roconnor> but I still can't get {-# RULES "sRGBBound"  forall r g b.  Data.Colour.SRGB.toSRGBBounded (Data.Colour.SRGB.sRGBBounded r g b) = RGB r g b #-}
16:02:09 <roconnor> to fire
16:02:29 <dons> oh, that looks like an easy one too.
16:02:32 <roconnor> because for some reason the sRGBBounded gets outlined
16:02:39 <roconnor> if outlining is a word
16:02:42 <thetallgu1> dons: the man who saw the future and implemented it
16:02:58 <sjanssen> roconnor: what is the code you're testing?
16:03:07 <roconnor> http://hpaste.org/14001
16:03:12 <roconnor> main = print (toSRGB24 seagreen)
16:03:17 <dons> thetallgu1: exactly
16:03:54 <dons> this guy, in my freaking office. wow. http://www.youtube.com/watch?v=BKM3CmRqK2o
16:04:20 <thetallgu1> sketchpad still rocks
16:04:32 <dons> we should implement it in haskell with cairo :)
16:04:40 <thetallgu1> and it's very frp-ish
16:07:12 <sjanssen> that video is awesome
16:07:17 <pumpkin> wow, yeah
16:07:26 <lergo> which
16:07:40 * roconnor tries to find a GHC RULES tutorial
16:07:43 <sjanssen> I didn't know we had vector graphic stuff in the 1960s
16:08:02 <dons> roconnor: i wrote one 'playing by the rules'
16:08:09 <ehird> dons: whoa, you have the author of sketchpad there?
16:08:12 <ehird> awesome!
16:08:34 <dons> yeah. i wonder if he'll give a tech talk. mmm
16:08:38 <ehird> hee, I remember I got a video about sketchpad to #1 on reddit many months ago :)
16:12:10 <dons> bah, names: the new bikeshed color
16:12:48 <Nafai> dons: Heh.  That cafe thread still going strong?
16:12:48 <olsner> hehe, it's just a matter of time until people start realizing that names are hard and better left to people who know better than they do
16:12:49 <jml> dons: names for what?
16:13:22 <dons> concepts
16:13:25 <yakov> hey
16:14:09 <dolio> Yeah. It's taking away from that great thread about how unqualified imports should be banned from the language. :)
16:14:30 <jml> oh, I guess I'm not on the right mailing list.
16:14:42 <dons> i think we should get back to discussing what names are good for packages
16:14:50 <dons> and what top level hierarchical names are legal.
16:14:58 <yakov> @type plusPtr
16:14:59 <lambdabot> Not in scope: `plusPtr'
16:15:17 <thetallgu1> roconnor: did you find that tutorial?
16:15:25 <hugo___> hackageDB should have a "see also:" section on each package... referencing similar or related packages that are not dependable on the one being seen
16:15:27 <olsner> Org.Haskell.Hackage.Foo
16:15:49 <ehird> olsner: oh my god.
16:15:51 <olsner> plobrem sloved!
16:15:52 <ehird> i hat eyou :D
16:15:58 <ehird> plobrem indeed
16:15:59 <wli> sjanssen: And virtual reality helmets, too, though they seemed to have tripped more heavily over motion sickness than more recent work.
16:16:13 <ehird> Http.Hackage.Haskell.Org.Foo
16:16:15 <ehird> It's more intuitive!
16:16:28 <thetallgu1> dons: is this in reference to the big thread?
16:16:40 <dons> the big thread. that's the one :)
16:16:43 <thetallgu1> dons: there ain't no solution but standardization and education
16:16:53 <dons> yep
16:16:53 * dolio reserves the Javax package prefix for himself.
16:16:55 <BMeph> Numbers should have a hierarchy that doesn't suck! >:|
16:17:09 <thetallgu1> dons: and the fact that there will be fewer core programmers in the future.
16:17:24 <roconnor> W00T
16:17:26 <roconnor> it workd
16:17:30 <roconnor> needed -fglasgow-exts
16:17:40 <roconnor> :/
16:17:43 <yakov> i've found rather cruel bug wrt plusPtr, why does it siliently coerces pointer type?! plusPtr :: Ptr a -> Int -> Ptr b :/
16:17:43 <olsner> hmm, rules were disabled altogether?
16:18:01 <dons> yakov: its not silent, but interesting, yes.
16:18:22 <dons> yakov: so you can do struct offsets. remember: Ptr == danger :)
16:18:29 <yakov> by silent i meant that i have not noticed it before sigsegv ;-)
16:18:40 <dons> Ptr == *danger*
16:18:51 <dons> :)
16:18:51 <thetallgu1> ...Will Robinson
16:19:01 <roconnor> So what is the right pragma to enable rules
16:19:09 <yakov> aha.. struct offsets.. intersting indeed, thx dons!
16:19:10 <jml> @hoogle (a -> Bool) -> [a] -> ([a], [a])
16:19:10 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
16:19:10 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
16:19:10 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
16:19:10 <dons> roconnor: mm.
16:19:12 <roconnor> I figured simply writing RULES would be sufficent
16:19:19 <roconnor> since they are pragmas themselves
16:19:34 <dons> there's an SPJ post about it.
16:19:55 <dons> i'm not sure if there's a new way
16:20:05 <roconnor> hmm
16:20:08 <BMeph> jml: partition, perhaps? :)
16:20:13 <dons> but the old way was -fglasgow-exts, and the Rank2Types toget forall's parsed
16:20:14 <thetallgu1> roconnor: did you find a tutorial?
16:20:21 <roconnor> okay.  This was mostlly an experiment to see if rules would work for this
16:20:31 <jml> BMeph: yeah, was just experimenting with hoogle :)
16:20:31 <dons> very much what i would use rules for
16:20:32 <roconnor> thetallgu1: http://www.haskell.org/haskellwiki/GHC/Using_rules
16:20:38 <twadleigh> {-# OPTIONS_GHC -O #-}
16:20:53 <twadleigh> just had to deal with this recently, myself
16:20:56 <thetallgu1> ExtendedDefaultRules?
16:21:08 <dons> nope
16:21:16 <dons> that's ghci defauting
16:21:18 <kmeyer> if I do "import qualified A.B.C" does that mean I use A.B.C.foo or C.foo?
16:21:19 <roconnor> I check and you can covert Word8 colour channels too and from Double (and I think Float) losslessly.  So my rule is even sound, which is always nice
16:21:34 <kmeyer> and furthermore, is there a way to get C.foo notation?
16:21:45 <roconnor> kmeyer: A.B.C.foo
16:21:56 <roconnor> use impor qualified A.B.C as C
16:22:08 <kmeyer> thanks, that's what I thought :)
16:22:11 <kmeyer> love this channel
16:22:19 <Toxaris> something about monoids: http://hpaste.org/14002 what do people think about this style? is it appropriate for Data.Monoid documentation, or is it too much text? basically, all this information is already in the code, but "english" documentation was requested
16:22:20 <thetallgu1> roconnor: thanks, I know that one.
16:22:42 <thetallgu1> dons: yeah, didn't seem right.
16:22:45 <roconnor> thetallgu1, only place I've seen -fglasgow-exts mentioned as necessary
16:23:05 <pumpkin> is there a list of all allowed characters in haskell operators?
16:23:32 <sjanssen> @where report
16:23:32 <lambdabot> http://www.haskell.org/onlinereport/
16:23:36 <sjanssen> pumpkin: ^^^
16:23:40 <roconnor> I wonder if I should place my rule in it's own module, or go all out and put it in with the sRGB functions.
16:24:04 <pumpkin> sjanssen: thanks :)
16:25:12 <pumpkin> > let x (#) = x^2 in 5#
16:25:13 <lambdabot>   <no location info>: parse error on input `)'
16:25:29 <pumpkin> does lambdabot have postfix operators?
16:25:41 <roconnor> @hoogle Word8
16:25:42 <lambdabot> Data.Word data Word8
16:25:42 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
16:26:14 <pumpkin> > let ((#) x) = x^2 in 5#
16:26:15 <lambdabot>   <no location info>: parse error on input `)'
16:26:30 <pumpkin> > let ((!) x) = x^2 in 5!
16:26:30 <lambdabot>   <no location info>: Parse error in pattern
16:26:35 <pumpkin> bah :)
16:26:50 <Toxaris> > let (#) x = x ^ 2 in (5 #) -- need section syntax
16:26:51 <lambdabot>   <no location info>: parse error on input `)'
16:27:31 <Toxaris> > let (!) x = x ^ 2 in (5 !) -- need section syntax, and # seems to be bad?
16:27:33 <lambdabot>   25
16:27:51 <Twey> # is reserved
16:27:58 <pumpkin> oh for the magic hash stuff?
16:28:01 <Twey> Er
16:28:10 * pumpkin smokes some magic hash
16:28:11 <Twey> Not reserved... it's an identifier character, isn't it?
16:28:19 <Twey> > let # = 5 in #
16:28:20 <lambdabot>   <no location info>: parse error on input `#'
16:28:24 <Twey> Oh, apparently not
16:28:27 <Twey> Must be reserved
16:28:32 <Twey> It's used for unboxed identifiers, IIRC
16:28:44 <sjanssen> # is an operator character in Haskell '98, but it is magic in GHC
16:28:52 <Toxaris> according to the report, it should be available
16:28:54 <Twey> Aha
16:29:25 <sjanssen> (# -- parses as the opening bracket of an unboxed tuple
16:29:58 <sjanssen> > let ( # ) x = x ^ 2 in (5 # )
16:29:59 <lambdabot>   25
16:30:21 <sjanssen> knowing your lexer ftw
16:30:27 <Twey> Weird
16:31:05 <Toxaris> > let ( # ) x = x ^ 2 in (5 #)
16:31:06 <lambdabot>   <no location info>: parse error on input `#)'
16:31:22 * Toxaris hates separate lexer/parser phases
16:31:39 <roconnor> > all (\w -> RGB w w w == toSRGBBounded (sRGBBounded w w w::Colour Float)) [minBound..maxBound::Word16]
16:31:39 <roconnor> True
16:31:40 <lambdabot>   Not in scope: data constructor `RGB'Not in scope: `toSRGBBounded'Not in sco...
16:31:44 <roconnor> \o/
16:32:45 <roconnor> Not in scope: type constructor or class `Word24'
16:32:47 <roconnor> aww
16:32:54 * roconnor hesitates to run Word32
16:33:27 <pumpkin> would could make a Word24 easily though
16:33:42 * roconnor starts Word32 anyways
16:33:48 <roconnor> if it fails, it might fail early
16:34:55 <roconnor> I should probably specialise my rewrite rule to those cases that I know are safe
16:35:01 <ddarius> Toxaris: The constant is called mempty
16:35:02 <roconnor> those are the common cases anyways
16:35:33 <Toxaris> @hoogle mzero
16:35:34 <lambdabot> Control.Monad mzero :: MonadPlus m => m a
16:35:36 <Toxaris> oups
16:35:39 <roconnor> does anyone else read mappend as map-end
16:36:10 * BMeph does it all the time
16:36:26 <ddarius> roconnor: I read it as append with an m sound attached to the beginning, so maybe yes(?)
16:36:42 * BMeph reads it as 'map-pend', rather
16:36:50 * roconnor has Monoid instances for both Colour and AlphaColour
16:37:12 <pumpkin> what's the operation?
16:37:15 <roconnor> I'd be cool to see AlphaColour used in Writer
16:37:17 <pumpkin> blending?
16:37:26 <roconnor> pumpkin: `over` for AlpahColour
16:37:30 <ivanm> dons: in RWH where you say you shouldn't use fail for a generic monad (whereas ekidd recommends you should: http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors ), what do you recommend then for throwing errors? using a concrete type (Maybe, Either String, etc.) rather than the generic Monad class?
16:37:35 <roconnor> and adding colours for Colour
16:38:03 <roconnor> > all (\w -> RGB w w w == toSRGBBounded (sRGBBounded w w w::Colour Float)) [minBound..maxBound::Word32]
16:38:03 <roconnor> False
16:38:04 <lambdabot>   Not in scope: data constructor `RGB'Not in scope: `toSRGBBounded'Not in sco...
16:38:11 <ddarius> ivanm: If you're throwing errors, why not use throwError?
16:38:16 <roconnor> but is is probably True for Colour Double
16:38:18 <sjanssen> ivanm: those aren't recommendations, it's a list of the redundant error mechanisms in Haskell
16:38:58 <Toxaris> sjanssen: about using fail: "If youre writing new Haskell libraries for public consumption, and all your errors are strings, please consider using this error-reporting method."
16:39:02 <jeffwheeler> Is there any type of list structure that, itself, keeps an index for going back and forth through the list? I think something like ([a], a, [a]) may work, with the first element being the elements before the index, the current index, and the rest of the list.
16:39:03 <ivanm> sjanssen: you mean what ekidd said?
16:39:18 <sjanssen> Toxaris, ivanm: huh, you're right :)
16:39:20 <ivanm> ddarius: is that part of the new 6.10 error stuff?
16:39:21 <Toxaris> jeffwheeler: indeed, thats the way to go!
16:39:22 <roconnor> jeffwheeler: you just invented a zipper
16:39:27 <ddarius> :t throwError
16:39:28 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
16:39:32 <ddarius> ivanm: No.
16:39:34 <ivanm> ahhhh
16:39:37 <jeffwheeler> roconnor: not entirely on my own; inspired by code I saw in Yi :P
16:39:41 <sjanssen> ivanm: bad advice, IMO
16:39:42 <Toxaris> jeffersonheard: hint: reverse the first list
16:39:45 <jeffwheeler> I'm just trying to not have to rip a lot of their code out.
16:39:57 <jeffwheeler> Is that already available in a package?
16:40:08 <ivanm> sjanssen: *nod*
16:41:00 <Toxaris> @hoogle zipper
16:41:00 <lambdabot> package rosezipper
16:41:14 <Toxaris> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ListZipper -- why not this one, \bot?
16:41:49 <ddarius> @hoogle Zipper
16:41:49 <lambdabot> package rosezipper
16:41:55 <jeffwheeler> Thanks. :)
16:41:59 <ddarius> I think there is some thing that makes Hoogle only acknowledge all lowercase package names.
16:42:15 <Toxaris> http://haskell.org/hoogle/?q=zipper -- works fine
16:42:44 <ddarius> It's probably been fixed in that version and not in lambdabot.
16:44:01 <Toxaris> ddarius: so do you think my Monoid documentation approach has any worth? I have just seen that there is some new doc for it available, but its still bad imho.
16:44:14 <roconnor> oh
16:44:22 * Toxaris cabal install's new hoogle
16:44:30 <roconnor> Does Haskell make any guarentees about Float and Double, like it does for Int?
16:44:47 <dons> what Int guarantees?
16:44:53 <dons> >= 29 bits?
16:44:56 <roconnor> it is at least 30 bits or something
16:44:59 <roconnor> ya
16:45:09 <dons> good thing to check.
16:45:10 <ddarius> roconnor: Not really, though there is an isIEEE function and if it returns true then you are guaranteed IEEE754 behavior.
16:45:12 <roconnor> probably not for Float and Double
16:45:18 <ddarius> 29
16:45:24 <roconnor> hmm
16:45:25 <ddarius> :t isIEEE
16:45:25 <lambdabot> forall a. (RealFloat a) => a -> Bool
16:45:35 <roconnor> maybe I should put my rewrite rules in a separate module
16:45:39 * roconnor ponders
16:47:15 <ddarius> Toxaris: Seems fine to me.  Anything that explicitly states the monoid laws would be fine to me though.
16:47:56 * jeffwheeler finds it odd that Data.List.Zipper doesn't implement Foldable, Traversable, Functor, or things like that.
16:48:23 <rgr> sjanssen: are you there? xmonad difficulties if you can pop on over.
16:49:38 <roconnor> not even Functor?
16:49:50 <roconnor> it should at least be a Functor
16:50:09 <roconnor> and ideally a Comonad
16:50:09 <jeffwheeler> It's Eq, Show, and Arbitrary
16:50:42 <roconnor> jeffwheeler: patch it. :P
16:50:51 <jeffwheeler> roconnor: maybe after dinner :)
16:50:58 <ddarius> What about Data and Typeable?
16:51:18 <jeffwheeler> I've only ever used Functor of all those; not sure how to implement those.
16:51:39 <jeffwheeler> (except Functor, of course)
16:51:48 <roconnor> Hmm
16:51:58 <jeffwheeler> I'm fine to try, though, when I get back.
16:52:03 <Toxaris> should a alpha Zipper try to behave like alpha, or like it is natural for itself, e.g. regarding the order of operations for Foldable
16:52:06 <roconnor> is List.Zipper supposed to be ([a],a,[a])?
16:52:23 <roconnor> I can never remember if a Zipper is just the context or includes the data at the spot
16:52:38 <jeffwheeler> Doesn't seem to be; it looks like Zipper ![a] ![a]
16:52:49 <jeffwheeler> I assume that means the first list is reversed, with head being the current element.
16:52:51 <roconnor> jeffwheeler: I'm wondering if that is wrong
16:52:59 <roconnor> or right
16:53:04 <jeffwheeler> ah, I see
16:53:19 <Toxaris> there is both cursor and empty
16:53:21 <roconnor> cursor :: Zipper a -> a indicates that it should be ([a],a,[a])
16:53:26 <Toxaris> so we may have a current element, but we don't have to
16:54:16 <Toxaris> why are the lists strict?
16:54:35 <roconnor> this library makes no sense
16:56:38 <Toxaris> its not a zipper, at least, its more like an iterator where your current position is before the list, between two elements, or after the list
16:57:09 <Toxaris> (in a zipper, your current position is one of the elements of the data structure)
16:57:26 <Toxaris> but does that mean it doesn't make sense?
16:58:23 <roconnor> Toxaris: you cant have both cursor and empty
16:58:33 <roconnor> one is for contexts and one is for zippers
16:58:42 <roconnor> the hackage is broken
16:58:53 <roconnor> the package is broken
17:01:10 <roconnor> a zipper list should be ([a],a,[a])
17:01:33 * roconnor is tempted to upload and overwrite the package
17:02:16 <thetallgu1> bad dog, no biscuit
17:03:16 <roconnor> left, right :: Zipper a -> Zipper a
17:03:16 <roconnor> left  (Zip (a:ls) rs) = Zip ls (a:rs)
17:03:16 <roconnor> left  z               = z
17:03:16 <roconnor> right (Zip ls (a:rs)) = Zip (a:ls) rs
17:03:16 <roconnor> right z               = z
17:03:22 <roconnor> why does that even compile?
17:03:31 <ddarius> Why wouldn't it compile?
17:03:53 <roconnor> you can have a list to declare types of things?
17:04:00 <ddarius> Yes.
17:04:05 <roconnor> wow
17:04:11 <roconnor> Hackage doesn't like that at all
17:04:12 <ddarius> You can also put type declarations wherever you like.
17:04:16 <roconnor> er
17:04:18 <roconnor> Haddock
17:05:30 <jeffwheeler> Yeah, Haddock doesn't even see the 'left' in the file.
17:06:22 <Toxaris> Maybe Zipper should have a ZipList-style Applicative instance
17:07:21 <roconnor> jeffwheeler: if I were you I would roll my own package; one that properly distinguishes between zippers and contexts
17:07:41 <roconnor> zipper = focus*context
17:07:46 <jeffwheeler> And contexts? What do you mean?
17:08:18 <roconnor> the context for a list is the pair of things to the left of you and to the right of you
17:08:30 <roconnor> the focus is what is at the current point
17:08:46 <roconnor> a zipper contains both of these
17:08:54 <jeffwheeler> Ah, I see. For now, I'll just implement my own Data.List.Zipper in my package.
17:08:56 <roconnor> and thus can never be empty
17:09:22 <Toxaris> roconnor: is the ([], []) context called empty?
17:09:34 <roconnor> http://en.wikibooks.org/wiki/Haskell/Zippers#Zippers_via_Differentiation
17:09:46 <roconnor> Toxaris: that is a fair name for that context
17:12:31 <jberg-> i want to try and make a non-trivial haskell app.. im thinking of maybe an irc bot, but any other suggestions? what was your first non trivial haskell application?
17:12:53 * jeffwheeler is playing with an RSS aggregation app, with much of the core based on Yi
17:14:18 <Raevel> i did a module that could do matrix inversion and some other things
17:14:32 <Toxaris> instance Monoid RSS where ...  :)
17:14:35 <jberg-> rss aggregation? i dont understand aggregation?
17:14:43 <roconnor> jeffwheeler: oh that sounds nice.  I really hate Akregator.  Evertime I use it I want to rewrite it in Haskell.
17:15:04 <jeffwheeler> jberg-: look at NetNewsWire or so; there are lots of great ones for Mac, but all the *nix ones are crap.
17:15:16 <jeffwheeler> jberg-: basically, it just downloads and lets you browse RSS subscriptions
17:15:20 <jberg-> jeffwheeler, okay i will
17:15:22 <Raevel> google reader is awesome, i think
17:15:23 <roconnor> planetHaskell `mappend` types `mappend` ...
17:15:39 <jeffwheeler> Raevel: I still use NNW on my Mac. It's great, but I want to use it on *nix.
17:15:59 <jberg-> maybe i should try to hack on some existing haskell libraries or something
17:16:50 <kmeyer> hm, is there any sort of queue datatype?
17:17:12 <Raevel> i'm working on a DTD language for JSON
17:19:13 <dcoutts> Heffalump: http://hackage.haskell.org/trac/hackage/ticket/460
17:19:59 <Heffalump> thanks!
17:21:09 <dcoutts> Heffalump: it all looks fairly unpleasent really
17:21:28 <dcoutts> Heffalump: it's not clear what a random app that wants to find "the proxy" should really do by default
17:21:32 <Heffalump> well, at least Windows will do the .pac file interpreting for you
17:21:41 <dcoutts> Heffalump: yes, that's good
17:21:59 <dcoutts> Heffalump: if you could find out if your proxy setting is the default or the IE one, that'd be interesting.
17:22:17 <dcoutts> ie WinHttpGetDefaultProxyConfiguration() vs WinHttpGetIEProxyConfigForCurrentUser()
17:22:17 <Heffalump> sorry, I don't understand the question
17:22:33 <dcoutts> Heffalump: IE has it's own proxy settings
17:23:39 <dcoutts> Heffalump: WinHttpGetDefaultProxyConfiguration gets something from the registry, which can be set by ProxyCfg.exe, or presumably some network admin
17:23:50 <dcoutts> but I suspect it's not really used much, except for servers
17:24:01 <dcoutts> but that's what I'm trying to find out
17:24:18 <dcoutts> if this "default" is useful, or if we should letch the IE settings
17:24:19 <Heffalump> so you want to know what the two return?
17:24:58 <dcoutts> I'd like to know if it's obvious from you looking at the registry settings, which is the ones you're actually using
17:25:14 <dcoutts> if it's really using a .pac file url, then it's not the system default ones
17:25:24 <dcoutts> as those are just a list of proxies and bypasses
17:25:25 <Heffalump> I'm convinced it's using a .pac file URL
17:25:34 <dcoutts> ok
17:26:00 <dcoutts> is that specified in HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings  ?
17:26:14 <Heffalump> proxycfg says "Direct access (no proxy server)."
17:26:33 <dcoutts> Heffalump: ok, that is interesting, ta
17:26:36 <Toxaris> kmeyer: queue as in FIFO? a standard solution is to use ([a], [a]), add new elements to the first list, take old elements from the second list, and reverse the first list as new second list if the second gets used up
17:27:08 <Heffalump> that registry path has an AutoConfigURL key pointing to the URL that has the .pac file
17:27:20 <dcoutts> Heffalump: ok, thanks.
17:27:22 <kmeyer> Toxaris: ah, that makes sense.
17:27:29 <kmeyer> still, reverse sounds slow
17:27:40 <kmeyer> (i.e. we're using two stacks to emulate a queue)
17:27:43 <Toxaris> kmeyer: but you have amortized costs of O(1)
17:27:47 <kmeyer> oh?
17:28:09 <Toxaris> kmeyer: because every element is touched exactly thrice: while adding, while reversing, while removing
17:28:17 <Toxaris> kmeyer: so you have 3 operations per element
17:28:32 <kmeyer> ah, I see.
17:28:44 <kmeyer> clever :D
17:32:57 <bremner> Is there a more haskelly way to write a function like http://hpaste.org/14003   I think I may have quite a few cases. I could save a little typing with a let and use direct pattern matching I guess.
17:33:34 <roconnor> > let test 'a' = True; test _ = False in test 'a'
17:33:35 <lambdabot>   True
17:33:52 <roconnor> bremner: you should be able to pattern match directly on the characters
17:33:57 <roconnor> rather than using guards
17:34:30 <bremner> roconnor: right, that was what I failed to express properly. I can't hope for much better than that I guess.
17:35:28 <roconnor> the syntax highlighter in hpaste needs some work
17:36:07 <bremner> improved? version http://hpaste.org/14004
17:37:09 <roconnor> bremner: http://hpaste.org/14004#a1
17:37:43 <bremner> sigh. Except my strings are invalid
17:37:57 <roconnor> bremner: "\\sigma"
17:38:33 <bremner> roconnor: you think it is better without the with?  Is there a "dumb" string literal in Haskell?
17:38:43 <Toxaris> http://hpaste.org/14004#a2
17:39:18 <roconnor> bremner: I don't understant
17:39:22 <roconnor> understand
17:39:52 <Toxaris> http://hpaste.org/14004#a3 -- or so?
17:40:02 <bremner> well, I would like to avoid typing \\ quite so many times. But it probably can't be helped
17:41:50 <bremner> Toxaris, roconnor. Ok, I have a few ideas now. Thanks for your help
17:43:07 <roconnor> Toxaris: lazy!
17:50:40 <eugman> I feel like make a program in haskell as practice that's simple enough to do as a beginner but feels like I actually made something and not just hello world 2.0 . Any suggestions for soemthing fitting with Haskell?
17:51:10 <joga> eugman, do you have some practical need for a program?
17:53:19 <eugman> Joga, I'll have to try to think of something. The only thing at the moment would be a diff program but something that acts on words instead of lines.
17:53:32 <Stinger> playing with gtk2hs can give you something interesting without too much code
17:53:58 <dcoutts> Heffalump: heh heh, there's a LGPL pacparser package, of course it works by bundling an entire copy of the spidermonkey JavaScript engine :-)
17:54:27 <dcoutts> Heffalump: linking to the WinHTTP library needs assemblies apparently, ghc/cabal does not support that yet
17:54:56 * dcoutts notes that it's pretty upsetting that you need a JavaScript engine to find a http proxy
17:55:15 <dcoutts> compared to say something sophisticated like $http_proxy
17:56:05 <arw> you don't really need a full-blown javascript engine.
17:56:07 <eugman> Oh, by the way, is it possible to make standalone gui executables for windows with Haskell?
17:56:23 <dcoutts> eugman: yes
17:56:30 <arw> you only need a small subset of javascript.
17:56:42 <Heffalump> dcoutts: assemblies as in .NET assemblies?
17:56:52 <arw> because more isn't allowed in proxy-settings-skripts anyways.
17:56:55 <eugman> dcoutts: Oh, good.
17:57:15 <dcoutts> Heffalump: .net assemblies are implemented using Windows assemblies, it's a dll technology that .net uses for it's assemblies
17:57:34 <Heffalump> ah
17:57:41 <dcoutts> arw: you only need a small subset of the JS library, it seems you need most of the language to support the spec fully.
17:58:27 <dcoutts> Heffalump: it involves specifying deps via a GUID in a xml manifest file, either compiled into the .exe as a resource or as ghc currently does it a separate .exe.manifest
17:58:45 <arw> dcoutts: hm, seems likely the way its written in the spec, yes.
17:58:46 <jeffz`> dcoutts: what about using LoadLibrary and GetProcAddress?
17:59:12 <dcoutts> jeffz`: I don't think that works easily for assemblies, as they're not on the dll search path
17:59:47 <arw> dcoutts: but realistically you can probably get away with loops and if-statements :)
18:00:03 <dcoutts> arw: I don't really want to implement a JS parser :-)
18:01:02 <dcoutts> arw: the thing to do would be to link to the MS WinHTTP library, but it appears that's slightly harder than it looks from Win2k3 onwards
18:03:12 <arw> dcoutts: and the standard approach of layering another library in between? like qt for example?
18:03:53 <dcoutts> arw: no idea
18:08:00 <roconnor> @go I am not a number, I am a free variable
18:08:07 <lambdabot> http://www.cs.nott.ac.uk/~ctm/notanum.ps.gz
18:09:18 <dolio> Good paper.
18:22:01 <gwern> 'The program r is a specialized version of p (for the particular value d1 of the first input), and is called a residual program. The process of producing r (in step 1) is called partial evaluation, or program specialization. The benefit of partial evaluation is speed of execution: the specialized program r is often much faster than the general program p. ' <-- this concept amazes me. compilation+specialized runtime can be faster than ...
18:22:07 <gwern> ... generalized runtime? this probably shouldn't amaze me because of JITs, but futamura projections still blow my mind
18:23:09 <hydo> Futurama projects?  "Good news, everyone!"
18:23:12 <Heffalump> Isn't it intuitive that doing something in a more specialised way is likely to perform better?
18:23:58 <dons> Heffalump: yeah.
18:24:10 <dons> abstraction works like that.
18:24:34 <gwern> 'good news everyone! we heard you like interpreters so we used the 3rd futamura projection to interpret your compiler so you can compile while you interpret!'
18:24:46 <dons> gwern is such a geek
18:24:47 <dons> :)
18:25:20 <gwern> I consider a joke a failure unless there are at least 3 aspects to it!
18:28:46 <dolio> @quote metacircularity
18:28:46 <lambdabot> No quotes match. I am sorry.
18:28:57 <dolio> @remember mauke YO DAWG I HEARD YOU LIKE METACIRCULARITY SO WE PUT AN INTERPRETER IN YOUR INTERPRETER SO YOU CAN RUN CODE WHILE YOU RUN CODE
18:28:57 <lambdabot> It is forever etched in my memory.
18:30:04 <Spark> doesn't rhyme
18:30:06 <Spark> fix it
18:32:30 <lament> @quote dawg
18:32:31 <lambdabot> chrisdone says: yo dawg we heard you like haskell so we installed a lambdabot in your ghci so you can monad while you monad
18:32:54 <ski_> @quote cat
18:32:54 <lambdabot> lament says: I'm running out of money and about to be evicted, what should i do? Use monads! My girlfriend dumped me, what should i do? Use applicative functors!
18:34:24 <roconnor> appli-cat-ive cat is applicative
18:35:50 <chessguy> @quote meta
18:35:50 <lambdabot> ghc says: Exotic Stmt in meta brackets
18:35:59 <ski_> @ghc
18:35:59 <lambdabot> ghc says: Try -fglasgow-exts for GHC's newtype-deriving extension
18:37:20 <Spark> @quote rape
18:37:21 <lambdabot> lament says: gentle like gangrape
18:37:27 <Spark> @quote genocide
18:37:28 <lambdabot> No quotes match. I've seen penguins that can type better than that.
18:37:39 <Spark> @quote fail
18:37:40 <lambdabot> autrijus says: Parrot is fine except every time I build it, it fails
18:40:08 <roconnor> @quote
18:40:09 <lambdabot> awick says: The GHC runtime seems to be sensitive to time running backwards
18:40:47 <dolio> @girl19
18:40:48 <lambdabot> well.. I never hacked Russians
18:42:59 * gwern feels sad. apparently no one likes my idea of a gitit wiki for documenting libraries
18:45:47 <gwern> @quote sad
18:45:47 <lambdabot> erg0t says: <erg0t> y te re inserta su pija gorda, arrugada, engrasada y esponjosa
18:45:54 <gwern> @quote sad
18:45:54 <lambdabot> erg0t says: <erg0t> y te re inserta su pija gorda, arrugada, engrasada y esponjosa
18:47:44 <gwern> I wonder how hard partial evaluation would be in haskell. it definitely seems like the sort of code-is-data thing lisp does well
18:48:33 <Lemmih> gwern: I like the idea.
18:48:46 <dons> i like the idea.
18:48:54 <dons> editable haddocks?
18:49:06 <gwern> Lemmih: it actually strikes me as sensible - just the other day I saw someone running TH just to get some functions partially evaluated
18:49:27 <Spark> doesn't the compiler do it
18:49:45 <Lemmih> gwern: Oh, I was referring to the gitit idea.
18:49:58 <gwern> dang it. I need to slow down :)
18:50:34 <ski_> in some cases you can write a curried function in a staged way .. e.g. a function matching a pattern on a string
18:50:52 <gwern> dons: I've been pondering how one could use haddock to render a haskell srouce file in gitit, instead of the current behaivour of showing nothing
18:51:15 <gwern> ski_: hm. does this actually get us partial evaluation?
18:51:39 <ski_> gwern : you can get some of the benifits of it, using that
18:52:21 <gwern> Spark: ghc will do some inlining and optimizations like that, but it won't do a lot. for example, I believe if you have something like 'keymap = Data.fromList $ [bunch of constants]', ghc will do the fromList at runtime (although I haven't checked the Core), because of the risk of evaluating *too* much
18:52:42 <ski_> > map ("foo" ++) ["bar","baz"]  where  (++) [] = id; (++) (a:as) = (a :) . (as ++)
18:52:43 <lambdabot>   ["foobar","foobaz"]
18:52:50 <gwern> hm, looks like dcoutts has done some partial evaluation work
18:52:54 <ski_> (`"foo"' is traversed once)
18:53:22 <gwern> ''Partial evaluation has traditionally been done for untyped strict functional languages such as Scheme. We look at the difficulties in finding a feasible type for our partial evaluation function that avoids using too many layers of encoding and present a solution using generating extensions. We then look at constructing the generating extension from a suitably annotated original and the ease with which this can be implemented this ...
18:53:23 <Spark> gwern: ideally you want control over it then
18:53:29 <gwern> ... using the Template Haskell infrastructure.'
18:53:31 <Spark> gwern: like the 'inline' keyword
18:53:45 <Spark> you're saying "i don't care how good/bad an idea this is, you just damn well inline it"
18:54:15 <Spark> so you could have a keyword that meant 'statically evaluate this until a fixed point and i promise there is a fixed point in reasonable time/ram'
18:54:20 <gwern> 'Limitations and future work The most important limitation is that the programmer must fully annotate the program to specify which parts of the program are static and which parts are dynamic. To compound the difficulty of writing these annotated programs there is no check at the moment for the consistency of the annotations. But if the annotations are inconsistent then the generating extension will be ill typed. The solution to these ...
18:54:26 <gwern> ... two problems is binding type checking to check the consistency of the programmer- supplied annotations, and binding time inference to remove the need for many of the annotations.' <-- ouch
18:54:52 <Spark> ill-typed?
18:55:24 <gwern> Spark: I don't think partial evaluation as I've read about it in lisps has inlining issues, since it's just feeding in as much input as is currently known and optimizing from there, but I could be wrong
18:55:41 <gwern> yeah. that's the nasty part
18:55:49 <gwern> quite aside from the manual annotation issue
18:55:50 <Spark> a lot of optimisations are essentially of the form 'do some execution now'
18:56:28 <Spark> partial evaluation is basically the same as constant propogation and inlining
18:56:35 <gwern> the paper is from 2004. wonder what he's done since
18:58:25 <roconnor> <gwern> I wonder how hard partial evaluation would be in haskell.
18:58:30 <roconnor> huh?
18:58:37 <roconnor> doesn't haskell have partial evaluation?
18:58:45 <Heffalump> roconnor: where?
18:59:15 <gwern> partial application, sure
18:59:25 <gwern> 'We implement simple standard type-directed partial evaluation in the pure
18:59:26 <gwern> functional programming language Haskell, using type classes.
18:59:36 <gwern> hm. type classes sound better than TH any day :)
19:01:01 <dolio> It has some limited constant folding. :)
19:01:59 <jeffwheeler> How can I find all the typeclasses that [a] implements?
19:02:25 <Lemmih> jeffwheeler: :i []
19:02:40 <gwern> @instances Monad
19:02:41 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:02:44 <jeffwheeler> Lemmih: thanks
19:02:47 <gwern> interesting.
19:02:51 <gwern> @instances-importing Monad
19:02:51 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:02:57 <dolio> Although not enough to turn something like "let x = [1..1000000] in sum x / genericLength x" into 500000500000.
19:05:04 <gwern> hmm... wonder why John wants sqlite support in filestore
19:05:12 <bohdan> hi all
19:05:17 <gwern> who's going to run gitit with an sql backend?
19:05:35 <bohdan> isn't there a comma missing in the subject?
19:05:47 <bohdan> err in the /topic
19:05:54 <gwern> the comma is missing in your mind
19:05:56 <jeffwheeler> bohdan: looks like it.
19:06:21 <bohdan> isn't there an op who could fix it ? :) haskell is a strict language :)
19:06:26 <sjanssen> dolio: I would hope constant folding wouldn't produce an incorrect answer like that
19:06:44 <dolio> Did I mess up?
19:06:51 <gwern> > let x = [1..1000000] in sum x / genericLength x
19:06:53 <lambdabot>   * Exception: stack overflow
19:07:13 <dolio> > let x = 1000000 in x * (x + 1) / 2
19:07:14 <lambdabot>   5.000005e11
19:07:27 <sjanssen> > sum [1 .. 1000000] -- presumably you meant this
19:07:29 <lambdabot>   * Exception: stack overflow
19:07:29 <Heffalump> shouldn't that have defaulted to Integer?
19:07:37 <dolio> Oh, right.
19:07:52 <Lemmih> dons: readPlanetHaskell >>= postToReddit?
19:08:02 <sjanssen> @src dons
19:08:02 <lambdabot> Source not found. Just try something else.
19:08:13 <dons> Lemmih: right.
19:08:14 <sjanssen> Lemmih: you might be on to something
19:08:28 <dons> Lemmih: also: google rss feeds, mailing list.
19:08:36 <dons> i'm trying to keep haskell-reddit as a central news site.
19:08:48 <chessguy> @type Just "try something else"
19:08:49 <lambdabot> Maybe [Char]
19:09:04 <dons> we've almost caught the lisp reddit, fwiw :) i think we'll overtake most other language reddits eventually.
19:09:07 <Lemmih> I hope the hype doesn't backfire against LHC.
19:09:28 <gwern> Lemmih: hype? can't say I've seen much
19:09:34 <gwern> LHC is practically in stealth mode...
19:09:36 <hcube> what hype?
19:09:43 <dons> well, just say interesting things.
19:09:53 <dons> benchmarks would be good...
19:09:57 <bohdan> is there a version of head that returns Maybe a ?
19:10:04 <dolio> *The* hype.
19:10:10 <dolio> @type listToMaybe
19:10:11 <lambdabot> forall a. [a] -> Maybe a
19:10:23 <dons> sadly i don't have any jhc benchmarks currently
19:10:40 <Lemmih> dons: We recently made Hello World compile. Benchmarks have to wait awhile.
19:10:54 <dons> huh, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/language-sh-0.0.3
19:11:02 <hcube> Lemmih: how is LHC going? Did you check EHC ? (its grin and llvm implementation)
19:11:03 <dons> Lemmih: do you remember all my jhc benchmarks?
19:11:08 <gwern> dons: that the darcs project?
19:11:20 <bohdan> dolio: thanks :) how could I miss it? :)
19:11:23 <dons> http://www.cse.unsw.edu.au/~dons/nobench/x86_64/results.html
19:11:33 <dons> about 2 years ago
19:11:35 <bohdan> dolio: the name is sort of misleading
19:11:49 <dons> jhc was actually better than that, beating ghc on a handful
19:11:56 <dolio> bohdan: People typically argue that a head returning Maybe is a waste, because you could just match on the list.
19:12:02 <Lemmih> dons: We found some fundamental flaws in JHC so we've been ripping out features.
19:12:08 <gwern> 'This is a project to create a portable sh-like shell. One purpose is for writing portable test-suites that work the same on both unix and windows environments. A particular advantage is that shsh requires only a Haskell compiler to build on windows machines, and ultimately, we hope, will eliminate the need for cygwin/msys in many cases.' <-- ah yes, that's for darcs alright
19:12:10 <dolio> Of course, if you're going to use it with the maybe function, I suppose it has its uses.
19:12:15 <dons> Lemmih: oh?
19:12:18 <dons> in what area? GC?
19:12:29 <dons> or the optimiser?
19:12:39 <Lemmih> dons: In the type-checking of classes.
19:13:05 <idnar> dolio: or you could be passing it / returning it to someone else...
19:13:05 <sjanssen> gwern: let's just re-implement Unix in Haskell, great idea!
19:13:07 <dons> oh.
19:13:08 <gwern> Lemmih: btw did I mention that I found a cool way to make gitit wikis fully distributed?
19:13:23 <gwern> sjanssen: your sarcasm is lost on me
19:13:26 <dons> Language.Sh is interesting. what would that be good for?
19:13:31 <dons> translating Sh to Hs? :)
19:13:35 <Lemmih> hcube: Yes, I saw. It seems that EHC and LHC have different goals.
19:13:43 <Lemmih> gwern: Nope, do tell.
19:13:54 <sjanssen> gwern: well, I guess one solution would be to not use shell scripts
19:14:10 <dons> http://code.haskell.org/shsh/
19:14:18 <dons> stephen hicks project too (icfp winner)
19:14:43 <gwern> Lemmih: well the trick is, you can edit the config so that it points to *above* itself; with the darcs/git repo at the 'root' of the wiki's directory-tree, it can then also manage all the infrastructure files like template.html and gitit-users and everything in static/
19:14:43 <sjanssen> an sh-compatible parser/de-parser would be useful
19:14:47 <Lemmih> dons: I seem to recall some blowback with HAppS. Many people were disappointed when they tried to use it as something it wasn't.
19:14:58 <dons> yeah, you have to manage expectations
19:15:01 <hcube> Lemmih: What's the 3 main differnece?
19:15:05 <dons> or at least be responsive
19:15:36 <gwern> Lemmih: at which point, now everything is managed by the repo! so someone darcs getting or cloning the repo gets *everything* - the customized logo, the user database, the article content, etc. there's litterally nothing stopping them from a perfect fork of the wiki
19:15:47 <hcube> dons: i've seen the benchmarks. HBC is missing. is it slow?
19:16:00 <dons> no, fast. but not on x86_64 (no lazy ml compiler there)
19:16:20 <gwern> Lemmih: they can get hosting, run gitit in their copy, and everything will work perfectly - even the users of the other original wiki can log in as if they never left the original!
19:16:50 <bohdan> dolio: yeah actually it's quite nice: "(maybe True (< n) . listToMaybe)" instead of much more verbose function definition
19:16:52 <gwern> Lemmih: I consider this to be v. cool even if I'm still wondering whether it's safe to publicly distribute hashed & salted passwords
19:17:57 <dolio> bohdan: Yeah. Perhaps a direct list combinator would be useful for that, too.
19:18:19 <dolio> bohdan: Technically, that's: foldr (const . (< n)) True
19:18:21 <gwern> sjanssen: and darcs can't rewrite the shell scripts in haskell since people use darcs in the shell and they're supposed to test user-exposed functionality
19:18:45 <gwern> sjanssen: if we did rewrite in haskell, everyother line would be 'cmd $ "darcs record -m" foo'
19:18:57 <wy> : let f () = (); bot = bot in f bot
19:19:17 <wy> @ let f () = ()
19:19:19 <dolio> Although the fact that it operates only on the head sort of leads away from thinking of things that way.
19:19:29 <dolio> Since it's easy to think "foldr is for recursion."
19:19:32 <gwern> 'Here are a few more builtins.  With just these, close to half of darcs' test suite passes on windows.  On linux, we're up to all but around thirty tests (out of close to 600) passing under shsh! '
19:19:37 <wy> uhhh... where is lambdabot?
19:19:45 <Cale> @bot
19:19:45 <lambdabot> :)
19:19:46 <lunabot>  :)
19:19:55 <bohdan> dolio, good point
19:19:59 <Cale> @let foo () = ()
19:20:00 <gwern> guess we know what roundy's been up to
19:20:00 <lambdabot>  Defined.
19:20:03 <Cale> > foo ()
19:20:05 <lambdabot>   ()
19:20:10 <Cale> @undefine
19:20:34 <wy> f bot crashes my ghc. It might be a bug
19:20:36 <Lemmih> hcube: Well, EHC seems to be a jumping point for language research. LHC is more performance oriented.
19:21:04 <wy> It crashes 50% of the time
19:21:26 <Cale> > let f () = () in f undefined
19:21:27 <lambdabot>   * Exception: Prelude.undefined
19:21:32 <Cale> wy: huh?
19:22:01 <dons> Lemmih: i think it is interesting, since ghc is performance + research
19:22:06 <wy> Cale:  f () = (); f bot
19:22:08 <dons>  a performance-at-all-costs compiler has a niche
19:22:34 <dolio> j/lhc is the mlton of Haskell.
19:22:43 <roconnor> LHC is about whole program analysis, right?
19:22:59 <roconnor> while GHC is going to stick with modular compilation
19:23:01 <pejo> Lemmih, so lhc is a jumping point for performance research. :-)
19:23:02 <wy> oh... maybe because of loop detection?
19:23:07 <Lemmih> roconnor: Yes.
19:23:22 <hansfbaier> LHC = large hadron collider?
19:23:24 <roconnor> Seems like LHC is what you use before shipping
19:23:24 <wy> no... this is not graceful...
19:23:30 <roconnor> and GHC is for development
19:23:46 <Lemmih> pejo: We really hope most of the research work has been done already (:
19:24:03 <dons> yeah, that's something else lhc has- it doesn't have to do the research
19:24:08 <hcube> That's true that EHC is good for researching, but in my opinion they supports performance too. that's why they use grin and llvm as backend. I think that it's better to do things right now even if it will be slower (i mean uuagc and attribute grammars) but with special optimizations the performance will increasing
19:24:16 <dons> and you don't have to worry about users :)
19:24:29 <dons> the ehc team needs to release something
19:24:31 <dons> anything.
19:24:32 <roconnor> @where LHC
19:24:32 <lambdabot> I know nothing about lhc.
19:24:36 <roconnor> :O
19:24:50 <MyCatVerbs> dons: "all costs" potentially includes the cost of rewriting from scratch in Verilog. :)
19:24:59 <Lemmih> ?where+ LHC http://lhc.seize.it/
19:25:00 <lambdabot> It is stored.
19:25:03 <dons> hey, yeah. good idea. target crytpol
19:25:06 <MyCatVerbs> dons: you might want to be more specific than that, perhaps. =D
19:25:09 <dons> cryptol. spit out vhdl.
19:25:13 <gwern> hansfbaier: yes. it's a little known fact that particle acclerators can be made to optimize programs very well, as the tau-neutrino interactions with heavy isotopes seem to solve NP problems in P time
19:25:20 <wy> Anyone knows why? I'm using GHC 6.10.1
19:25:32 <pejo> dons, I don't think the problem of compiling code so that it ends up being fast is really closed yet, there must be other approaches than lhc's.
19:25:41 <hansfbaier> gwern: :)
19:25:43 <dons> > let f () = f () in f undefined
19:25:44 <lambdabot>   * Exception: Prelude.undefined
19:26:07 <dons> pejo: definitely not closed. but a lot of research has been done.
19:26:22 <MyCatVerbs> pejo: optimality will never be closed, but actually that problem is pretty well bounded, in a way.
19:26:27 <Lemmih> hcube: It's difficult to get performance with LLVM. At least for functional languages.
19:26:34 <wy> > let f () = (); bot = bot in f bot
19:26:39 <jeffwheeler> How can I find []'s implementation of >>=?
19:26:49 <lambdabot>   thread killed
19:26:53 <roconnor> @src (>>=) []
19:26:53 <lambdabot> Source not found. Sorry.
19:26:58 <roconnor> @src [] (>>=)
19:26:58 <lambdabot> xs >>= f     = concatMap f xs
19:27:07 <MyCatVerbs> pejo: you have compilers that're designed so that people can actually use them - gcc, GHC, Chicken - and then you have compilers that're designed for aggressiveness - JHC/LHC, Stalin...
19:27:11 <wy> dons: undefined doesn't crash it, but if you define bot = bot. It will crash
19:27:14 <jeffwheeler> roconnor: thanks
19:27:16 <hcube> Lemmih: is C-- better than llvm IR?
19:27:18 <gwern> is stalin still developed?
19:28:13 <pejo> MyCatVerbs, we don't know if we can tame the aggressiveness sensibly yet though
19:28:19 <jeffwheeler> @src concatMap
19:28:20 <lambdabot> concatMap f = foldr ((++) . f) []
19:28:36 <jeffwheeler> @src foldr
19:28:36 <lambdabot> foldr f z []     = z
19:28:36 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
19:28:44 <Lemmih> hcube: C-- has more potential than llvm IR. LLVM doesn't even try to address many of the more important aspects in C--.
19:28:49 <MyCatVerbs> pejo: y'know how common knowledge says that optimizing for VLIW chips is supposed to be beyond what you can get a compiler to do?
19:29:34 <pejo> MyCat, common knowledge says it's impossible to build a good compiler for ia32 as well, but Intel did it.
19:29:53 <pejo> MyCat, but haven't SGI and others failed pretty bad on IA64?
19:30:04 <dons> > let bot = bot ; f () = f () in f bot
19:30:10 <Adamant> pejo: what common knowledge?
19:30:19 <lambdabot>   thread killed
19:30:29 <dons> it just allocates a lot?
19:30:35 <MyCatVerbs> Er, no it isn't. Current x86 chips are out-of-order superscalar with full register renaming. Arguably those are the *easiest* flavours of chips to optimize for.
19:30:52 <pejo> Adamant, I guess we can consider it debunked by now.
19:31:11 <MyCatVerbs> pejo: actually the situation is that you *can* build a really good Itanic compiler, but it takes so long to run that programmers won't use it.
19:31:25 <MyCatVerbs> (With good reason, too.)
19:31:31 <hcube> Lemmih: what are these aspects? I know llvm ir and i've have some knowledge about c--. c-- supports tail calls, but it is typeless whats not good i think. tail calls can be done with llvm too. what are the remained important aspects?
19:31:47 <pejo> MyCat, ah, they should have built the compiler with itself!
19:31:55 <Lemmih> hcube: Garbage collection and concurrency.
19:32:37 <MyCatVerbs> pejo: nice thought, but it doesn't suffice. :)
19:32:39 <Adamant> MyCatVerbs: any chance you could use a less good but fast Itanic compiler for dev work, then switch to a good but slow one for putting it out the door?
19:32:57 <Adamant> there could be problems with that though
19:33:00 <wy> dons: a bug?
19:33:38 <MyCatVerbs> Adamant: yes, people do that. The most common way of doing that is to turn on or off your compiler's optimization flags. =)
19:33:54 <MyCatVerbs> Adamant: Hell, some people do that on x86 projects. ^^
19:34:55 <Adamant> MyCatVerbs: ah, I've never done that for compiler speed reasons
19:35:02 <hcube> Lemmih: In my opinion GC should be implemented as a lib. Concurrency should be handles in higher level than imperative backend. I mean that an imperative backend have to compile and optimize threads, what are decomposed from functional IR by the compiler. what's your opinion?
19:36:17 <Lemmih> hcube: C-- obviously should provide a GC but it should make it possible to use one efficiently.
19:36:52 <Lemmih> hcube: Putting all heap pointers on the stack isn't a good option for functinal languages.
19:37:29 <Lemmih> hcube: But keeping root pointers in registers makes it very difficult for GCs to find them.
19:38:19 <gwern> @seen Cale
19:38:19 <lambdabot> Cale is in #haskell, #ghc and #haskell-overflow. I last heard Cale speak 16m 47s ago.
19:38:20 <Lemmih> A general solution for this haven't been found yet.
19:39:04 <gwern> Cale: ping
19:39:06 <roconnor> is LHC ditching the region stuff?
19:39:31 <Lemmih> roconnor: Yes.
19:39:37 <dolio> Aww.
19:39:48 <Lemmih> hcube: Executing threads cheaply is also a difficult problem.
19:39:59 <jeffwheeler> @src [] Foldable
19:40:00 <lambdabot> Source not found. Maybe if you used more than just two fingers...
19:40:01 <jeffwheeler> wait, duh
19:40:11 <jeffwheeler> @src foldr
19:40:11 <lambdabot> foldr f z []     = z
19:40:11 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
19:40:12 <Lemmih> hcube: Even user-level threads are too expensive.
19:40:14 <dolio> foldr = foldr
19:41:01 <dons> wy, i'm not sure its a bug. why do you think it is a bug?
19:41:02 <roconnor> {-# RULE "foldr" foldr = foldr #-}
19:41:10 <Lemmih> roconnor: We'll default to GCing and then push objects on the stack when we can guarantee it to be safe.
19:41:24 <pejo> Lemmih, why are you ditching the region stuff (region inference?)
19:41:47 <jeffwheeler> roconnor: huh?
19:41:54 <gwern> @tell Cale mueval-0.7 is out, and seems to be safely working on 6.10 now that I added a process-level watchdog; there's no hurry to update if you don't want to, but I was wondering whether we should add mueval as a dependency to lambdabot.cabal
19:41:54 <lambdabot> Consider it noted.
19:41:55 <hcube> Lemmih: ok, but LHC produces C code what also has these issues. Will you target C-- in the future?
19:42:00 <Lemmih> pejo: It's impossible not to leak memory with region inference.
19:42:01 <wy> dons: because f bot should cause it to loop and not crash
19:42:16 <Lemmih> hcube: We're writing our own NCG.
19:42:33 <wy> dons: should behave the same as bot alone, right?
19:42:40 <wy> > bot
19:42:41 <lambdabot>   Not in scope: `bot'
19:42:48 <hcube> where can i find a document about that?
19:42:48 <wy> > let bot = bot in bot
19:42:52 <Lemmih> hcube: C-- probably won't be usable for another decade.
19:43:03 <lambdabot>   thread killed
19:43:30 <gwern> wy: what are you doing anyway?
19:43:33 <pejo> Lemmih, can you detect when you're leaking so it can be combined iwth gc?
19:43:57 <wy> gwern: I'm just doing some experiment
19:44:26 <ivanm> is it just me, or is the ghci output on pages 368-369 of RWH wrong?
19:44:35 <Lemmih> pejo: We plan on doing it the other way around.
19:45:07 <hcube> ok, i've found doc in planet haskell
19:45:15 <sjanssen> wy: in what way does your ghc crash?
19:45:59 <wy> sjanssen: Maybe it is not a crash. But let bot = bot in bot gives no reason and ghci just exits
19:46:02 <gwern> ivanm: isn't RWH's ghci output generated by an actual ghci?
19:46:39 <ivanm> gwern: yes.... but whereas they import hiding in the code they provide to avoid a name clash, the ghci output complains about an ambiguos reference :s
19:46:53 <ivanm> (and then the text following talks about the results of the ghci output as if there was no error)
19:49:04 <chessguy> ivanm:  heh, that's interesting
19:49:41 * chessguy looks for the relevant section online
19:50:08 <chessguy> http://book.realworldhaskell.org/read/programming-with-monads.html#id647223
19:50:18 <chessguy> broken there too
19:51:50 <ivanm> chessguy: good, so it's not just me *phew*
19:53:35 <chessguy> ivanm:  be sure to update the errata on the oreilly site
19:53:45 <ivanm> @go errata RWH
19:53:47 <lambdabot> No Result Found.
19:53:54 <ivanm> lambdabot: how can you fail me?!?!?!?!?
19:54:14 <chessguy> @go errata real world haskell
19:54:25 <lambdabot> http://oreilly.com/catalog/9780596514983/errata/
19:54:25 <lambdabot> Title: Real World Haskell | O'Reilly Media
19:54:38 <chessguy> woot!
19:54:42 <hcube> Lemmih: Is writing a new codegen easier than exending llvm to fit your needs? (i)
19:55:02 <gwern> @where errata real world haskell
19:55:03 <lambdabot> I know nothing about errata.
19:55:05 <ivanm> chessguy: we need to have lambdabot automatically expand RWH to Real World Haskell for @go searches it looks like...
19:55:09 <Lemmih> hcube: Yes, very much so.
19:55:18 <hcube> ok
19:55:29 <Adamant> @where haskell
19:55:29 <lambdabot> http://haskell.org/
19:56:00 <Adamant> @where is-haskell
19:56:00 <lambdabot> I know nothing about is-haskell.
19:56:10 <ivanm> chessguy: someone called HairyDude already spotted it :s
19:56:15 <ivanm> Adamant: what are you looking for?
19:56:23 <Lemmih> hcube: There will probably be peace in the middle east before we solve this problem.
19:56:34 <Adamant> ivanm: trying to get lambdabot to say "I know nothing about Haskell"
19:56:37 <ivanm> Lemmih: which problem is this?
19:56:38 <Adamant> or something close to it
19:56:40 <ivanm> Adamant: ahhh ;-)
19:56:50 <ivanm> @where a language called Haskell
19:56:50 <lambdabot> I know nothing about a.
19:56:51 <hcube> :D
19:56:56 <ivanm> @where a "language called Haskell"
19:56:56 <lambdabot> I know nothing about a.
19:57:01 <ivanm> @where "a language called Haskell"
19:57:01 <lambdabot> I know nothing about "a.
19:57:09 <ivanm> @where a_language_called_Haskell
19:57:10 <lambdabot> I know nothing about a_language_called_haskell.
19:57:15 <ivanm> Adamant: happy now? ;-)
19:57:21 <sjanssen> @where+ haskell I know nothing about a language called Haskell
19:57:21 <lambdabot> I will never forget.
19:57:21 <Adamant> lol
19:57:23 <sjanssen> @where haskell
19:57:23 <lambdabot> I know nothing about a language called Haskell
19:57:31 <sjanssen> @where+ haskell http://haskell.org
19:57:31 <lambdabot> I will never forget.
19:57:34 <sjanssen> @flush
19:57:47 <ivanm> @where haskell
19:57:48 <lambdabot> http://haskell.org
19:57:49 <bohdan> is there a nicer way to write 'x a = f a : g (f a) : x (g (f a))' ?
19:57:50 <Lemmih> ivanm: Creating a language which efficiently supports all forms of garbage collection and all forms of light-weight concurrency.
19:57:52 <ivanm> awwwww....
19:58:22 <ivanm> Lemmih: ahhhh..... well, if people can't even decide on a record syntax, then trying to work out such a language is clearly highly improbablye
19:58:25 <ivanm> *improbably
19:58:27 <ivanm> *improbable
19:58:35 * ivanm will spell it right one of these days... >_>
19:58:53 <ivanm> Lemmih: so let's just turn on the Heart of Gold and make it magically appear! ;-)
20:00:36 <wy> How many functions are there of type ()->() ?
20:00:44 <ivanm> @free () -> ()
20:00:44 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
20:00:48 <ivanm> :o
20:00:52 <ddarius> wy: 3
20:01:04 <ivanm> ddarius: oh? which ones?
20:01:14 <ddarius> sorry, 4
20:01:19 <sjanssen> undefined, const undefined, const (), id
20:01:40 <ivanm> sjanssen: how bout ones that do some kind of forcing, etc. in the parallelism stuff?
20:01:46 <ivanm> i.e. ones of type a -> () ?
20:01:59 <sjanssen> ivanm: wy asked for "() -> ()"
20:02:16 <ivanm> @type const undefined
20:02:17 <lambdabot> forall a b. b -> a
20:02:19 <sjanssen> and par is supposed to have no denotational effect
20:02:28 <sjanssen> @type const undefined :: () -> ()
20:02:28 <lambdabot> () -> ()
20:02:37 <ivanm> sjanssen: still a function though, isn't it?
20:02:58 <ivanm> and const undefined isn't strictly () -> () ...
20:02:59 <ddarius> ivanm: It doesn't lead to a -different- function.
20:03:02 <sjanssen> ivanm: it won't do anything actually different
20:03:09 <ivanm> ahhhh, I see what you mean
20:03:34 <sjanssen> though, if we include unsafePerformIO, there is no limit to the number of programs that have type "() -> ()"
20:04:00 <ddarius> ivanm: None of those functions are "strictly" () -> (), if we use the criterion that that is the most general type.
20:04:09 <ivanm> *nod*
20:05:02 <ivanm> how does one use @free? my attempts to use it (e.g. @free a -> a) keep failing :s
20:05:20 <ddarius> @free a -> a
20:05:20 <lambdabot> Extra stuff at end of line
20:05:27 <ddarius> @free f :: a -> a
20:05:27 <lambdabot> g . f = f . g
20:05:33 <ivanm> ahhhhh
20:05:41 <ivanm> I thought it just generated a function of that type
20:05:42 <sjanssen> @free f :: a -> b
20:05:42 <lambdabot> h . f = f . g
20:05:47 <ivanm> or am I thinking of a different plugin?
20:06:01 <ddarius> @djinn a -> a
20:06:02 <lambdabot> f a = a
20:06:31 <ivanm> oh, that's what I was thinking of @djinn
20:06:39 <ivanm> @djinn () -> ()
20:06:39 <lambdabot> f a = a
20:06:42 <ivanm> OK, just id
20:12:36 <kerlo> @djinn a -> ()
20:12:36 <lambdabot> f _ = ()
20:13:48 <ivanm> which is const ()
20:14:09 <kerlo> @djinn ((a -> b) -> a) -> a
20:14:09 <lambdabot> -- f cannot be realized.
20:14:12 <kerlo> Thought not.
20:14:42 <jeffwheeler> In general, should 'delete' on a Zipper's last element return an error, or an unchanged zipper?
20:14:58 <roconnor> hmm
20:15:01 <dolio> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
20:15:02 <lambdabot> f a b = a (\ c _ -> b c) b
20:15:06 <jeffwheeler> And I assume the answer will be the same for all other functions that result in empty lists.
20:15:07 <roconnor> delete isn't really a zipper operation in of itself
20:15:47 <roconnor> jeffwheeler: if you are going to define it, it should be an error
20:16:18 <jeffwheeler> roconnor: fair enough; I saw it ('delete') defined in the current Zipper and Yi's WindowSet (implemented as a Zipper), so I figured it was standard
20:16:58 <ddarius> There are no "standards" for this.
20:17:35 <roconnor> jeffwheeler: it probably isn't an unreasonable operation for zipper lists.
20:18:07 <roconnor> jeffwheeler: but I expect there to be a delete and move left, and delete and move right operations
20:18:18 <jeffwheeler> roconnor: sure
20:18:29 <jeffwheeler> (although names are non-obvious to me)
20:18:42 <roconnor> me too
20:20:03 <luqui> when I do a runghc Setup.lhs install in windows I get an error: Setup.lhs: CreateDirectory: permission denied (Access is denied.)
20:20:17 <luqui> my guess is that the package doesn't matter (for the record it's SDL)
20:20:21 <luqui> any idea what's going on?
20:20:29 <mmorrow> @djinn Cont r a -> (a -> Cont r b) -> Cont r b
20:20:29 <lambdabot> f a b c = a (\ d -> b d c)
20:20:48 <mmorrow> um
20:20:52 <mmorrow> @djinn-env
20:20:52 <lambdabot> data () = ()
20:20:52 <lambdabot> data Either a b = Left a | Right b
20:20:52 <lambdabot> data Maybe a = Nothing | Just a
20:20:52 <lambdabot> data Bool = False | True
20:20:52 <lambdabot> data Void
20:20:54 <lambdabot> type Not x = x -> Void
20:20:56 <lambdabot> class Eq a where (==) :: a -> a -> Bool
20:20:58 <lambdabot> type Cont r a = (a -> r) -> r
20:21:00 <mmorrow> ah
20:22:18 <jeffz`> luqui: if this is vista, it could be that you're not an administrator trying to install it globally
20:22:25 <luqui> ah good call
20:23:02 <luqui> jeffz`, yep, that was it!  thanks!
20:27:41 <jeffwheeler> @src length
20:27:42 <lambdabot> Source not found. It can only be attributed to human error.
20:27:48 <jeffwheeler> @src size
20:27:48 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
20:32:09 <jeffwheeler> http://hpaste.org/14005
20:32:21 <jeffwheeler> I'm open to suggestions before I post it to the mailing list.
20:33:02 <chessguy_> jeffwheeler:  can you not derive Eq?
20:33:13 <jeffwheeler> chessguy_: probably; let me try
20:33:16 <chessguy_> and/or Ord
20:33:43 <jeffwheeler> I'll give it a shot, I didn't think to try. Originally I was using a 'type' instead of a 'data', because I'm a newbie.
20:34:32 <jeffwheeler> that seems to work; good suggestion
20:34:42 <ddarius> jeffwheeler: Your show instance is jacked.
20:35:08 <gwern> dude, where's my Show?
20:35:20 <jeffwheeler> ddarius: oh, hmm. I've never written a proper one before. Should I be doing something different?
20:35:41 <dolio> What mailing list are you posting this to?
20:36:02 <jeffwheeler> dolio: uh, either haskell@ or haskell-cafe@; I'm not sure.
20:36:05 <ddarius> jeffwheeler: Ideally you'd want one with a Read instance such that read . show = id
20:36:29 <ddarius> jeffwheeler: Even without a Read instance you want a format that is unambiguous.
20:36:52 <jeffwheeler> jeffwheeler: oh, yes. I preferred to reverse the first list for the sake of readability, but I'm open to a new format.
20:37:28 <ddarius> jeffwheeler: You can have the reversed list, but I would have it otherwise look like a derived Show instance.
20:37:36 <chessguy_> why is it ambiguous?
20:37:58 <dolio> There's already a Data.List.Zipper on hackage, you know. Although its somewhat different from yours.
20:38:00 <ddarius> jeffwheeler: Also, precedence should be used to avoid parentheses.
20:38:10 <dolio> It allows zippers of empty lists, apparently.
20:38:19 <jeffwheeler> dolio: yes, we discussed it earlier and it seemed like many people were unhappy with it; it was suggested I write my own version.
20:39:11 <dolio> I'm not a fan of "foop :: Foo -> Bool" either.
20:39:29 <mmorrow> Lemmih: an NCG for lhc? sweet!!
20:39:31 <jeffwheeler> dolio: huh?
20:39:53 <dolio> Short for fooPredicate.
20:39:56 <dolio> Or something like that.
20:40:01 <dolio> nullp, endp.
20:40:09 <dolio> ListZipper uses that.
20:40:25 <jeffwheeler> dolio: oh, I thought you were referring to my code.
20:40:39 <dolio> Of course, we don't get null?, which is a shame.
20:40:41 <ddarius> dolio: It's a CL convention, but the convention in Haskell is to use 'is', e.g. isFoo.
20:41:01 <dolio> Yeah. I know where it comes from. It's one of the reasons I don't like CL. :)
20:41:07 <roconnor> @hoogle is*
20:41:08 <lambdabot> Parse error:
20:41:08 <lambdabot>   --count=20 is*
20:41:08 <lambdabot>                 ^
20:42:16 <Lemmih> mmorrow: Heh (: I just hope I actually have the ability to write one.
20:42:45 <ddarius> Lemmih: Writing a crappy one is easy, just tedious.
20:44:22 <mmorrow> Lemmih: hehe
20:44:24 <Lemmih> ddarius: It has to be better than gcc and yet simple enough to not melt my brain.
20:44:35 <mmorrow> Lemmih: i'm interested in helping (not that i've ever done this before ;). i'm sure it'll work out.
20:44:56 <mmorrow> clean slates are exciting
20:45:08 <gweiqi> does anyone know of a standard library function that already does the following?
20:45:08 <gweiqi> process _ [] = []
20:45:08 <gweiqi> process f xs = part : process f xs'
20:45:08 <gweiqi>   where (part, xs') = f xs
20:45:24 <dolio> Someone's rewriting the GHC one to be totally spectacular, though. That might be hard. :)
20:45:24 <ddarius> Lemmih: That's still not too hard if you continue the JHC approach to optimizations and blindly apply extremely powerful, but extremely time consuming optimizations.
20:46:04 <ddarius> Lemmih: Also you might find a thesis recently mentioned on LtU interesting in this vein: http://lambda-the-ultimate.org/node/3151
20:46:17 <gweiqi> it seems to be a common pattern in my code...
20:46:36 <ddarius> :t mapAccumR
20:46:37 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
20:46:55 <ddarius> Nope
20:46:58 <chessguy_> @type let process _ [] = []; process f xs = part : process f xs' where (part, xs') = f xs in process
20:46:59 <lambdabot> forall t a. ([t] -> (a, [t])) -> [t] -> [a]
20:47:07 <ddarius> :t unfoldr
20:47:08 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
20:47:49 <chessguy_> not quite an unfold, because the generating function takes a list
20:48:04 <gweiqi> right
20:48:19 <dolio> Eh?
20:48:22 <ddarius> chessguy_: Set b = [t]
20:48:24 <dolio> b = [c]
20:48:37 <Lemmih> ddarius: Yeah, I wish I had talked to Joao Dias when I had the chance.
20:49:11 <chessguy> hmm
20:49:20 <ddarius> :t \f -> unfoldr (\xs -> guard (null xs) >> return (f xs))
20:49:20 <lambdabot> forall a a1. ([a] -> (a1, [a])) -> [a] -> [a1]
20:49:56 <dolio> not $ null xs, though.
20:50:52 <Lemmih> mmorrow: Excellent, I will call on you when the time arise (:
20:51:42 <mmorrow> Lemmih: (x86-32 specific) check out benchmark.c in this repo (code by sbahra) comparing code using xmm stuff vs. not. i was amazed. http://moonpatio.com/repos/sbahra-mmxsse2/   (in mmx/)
20:52:04 <mmorrow> the mmx code is *twice* as fast on my laptop
20:52:18 <mmorrow> ghc uses no mmx instrs on x86-32 :(
20:52:25 <ddarius> mmorrow ... um... that is very unsurprising.
20:52:54 <mmorrow> ddarius: so i've come to understand
20:53:01 <dolio> I don't think ghc does much of anything fancy currently. :)
20:53:58 <mmorrow> sse2 would also be a similar step up from the standard fp instrs of x86
20:54:19 <gweiqi> thanks guys
20:58:27 <mmorrow> oops, the Makefile in that repo doesn't work
20:58:56 <mmorrow> should have -I../other
21:01:01 <mmorrow> repo updated
21:01:21 <Lemmih> Can we use mmx/sse when executing Haskell code?
21:01:51 <mmorrow> sure
21:02:02 * sjanssen starts to write a shell script optimizer with Language.Sh
21:02:14 <ddarius> sjanssen: ... why... ?
21:02:35 <sjanssen> ddarius: I want tail call optimization -- "sleep 2s; firefox" should be "sleep 2s; exec firefox"
21:02:46 <Lemmih> I mean, is there an obvious way to take advantage of mmx/see?
21:02:58 <sjanssen> I want to add the 'exec' so we can manage the launched firefox window according to its PID
21:03:58 <mmorrow> Lemmih: yes, re: sse, one would just use sse for all fp code in the ncg, and re: mmx, i'm not sure particulars but i'd imagine it wouldn't be super difficult
21:05:02 <mmorrow> Lemmih: sbahra knows a lot about mmx, i bet he'd have some answers
21:05:22 <mmorrow> (he knows about sse as well)
21:06:09 <mmorrow> Lemmih: check out the long comment about halfway down in http://moonpatio.com/docs/ghc/src/MachInstrs.html
21:06:14 <mmorrow> "-- Intel x86 instructions"
21:06:57 <mmorrow> all the difficulty with generating fp code would disappear if sse instrs/regs were used
21:08:05 <mmorrow> ghc uses "a restricted set of the available SSE2-- instructions for floating-point." of x86-64
21:08:11 <mmorrow> s/of/on/
21:14:04 <Lemmih> mmorrow: Quite interesting. I will read more about SSE2 tomorrow.
21:16:17 <ddarius> The benefit of using SSE instructions v. FP instructions (in that context) is that it presents the FPU as a register machine rather than a stack machine which is easier to work with (especially if you already have all the infrastructure for a register machine()
21:19:38 <mmorrow> ddarius: indeed. a side benefit would be that the SSE code would be faster as well.
21:19:58 <mmorrow> win-win
21:20:13 <pumpkin> mmorrow: so join the SSE project :D :D
21:20:30 <mmorrow> pumpkin: ?
21:20:40 <pumpkin> mmorrow: sbahra's one :P
21:20:47 <mmorrow> link?
21:21:02 <pumpkin> it doesn't exist yet as far as I know :)
21:21:11 <mmorrow> heh, cool.
21:21:31 <mmorrow> i'll ask sbahra about it.
21:21:39 <pumpkin> I thought he'd asked you about it :o
21:21:51 <mmorrow> ohh, yeah i gotcha.
21:22:26 <mmorrow> we were talking about ideas for using haskell (at some level) to somehow make use of SSE instrs
21:22:36 <mmorrow> and s/SSE/MMX/ as well
21:22:36 <pumpkin> yeah :)
21:23:22 <mmorrow> i think adding that capability to a compiler's NCG would be the best way to do that (in the long run)
21:24:00 <mmorrow> i've been looking at ghc's ncg some, but don't know it very well yet
21:24:27 <pumpkin> it's hard to do that automatically though
21:24:40 <mmorrow> do what automatically?
21:24:53 <mmorrow> (use them optimally?)
21:25:11 <pumpkin> determine what's vectorizable
21:25:14 <pumpkin> yeah
21:25:32 <mmorrow> it'd be way cool if there was a harpy-like interface to that as well
21:25:48 <mmorrow> (i don't believe harpy does mmx/sse2 currently(?))
21:25:56 <mmorrow> pumpkin: interesting
21:26:06 <ddarius> mmorrow: It should be straightforward to add it.
21:26:19 <mmorrow> ddarius: to harpy or to ghc?
21:26:23 <ddarius> Harpy
21:27:09 <mmorrow> nice, i've been meaning to look at harpy's src more closely for a while now
21:27:11 <jeffz`> harpy doesn't work with x86-64 though :/
21:27:21 <mmorrow> yeah, that's a big :(
21:27:33 <pumpkin> like, maybe something where you can take a MUarr (I like them, yeah) and have a way of saying "multiply (for example) 8 doubles starting at index x, by 5"
21:27:46 <jeffz`> sse4 looks like it has some interesting instructions
21:27:52 <pumpkin> what have they added?
21:28:07 <jeffz`> http://en.wikipedia.org/wiki/SSE4 summary here
21:28:12 <mmorrow> i think one'd want to add some abstract machine def/interface/something, then give instances of it for diff arch's at this point rather than just hardcode support for another arch
21:28:29 <ddarius> Making Harpy work with x86-64 should also be straightforward (but tedious).  All the hard decisions should already have been made.
21:28:38 <pumpkin> mmorrow: that's true, but each arch is a relatively large endeavour as they tend to be so complex
21:28:50 <centrinia> The SSE5 has more interesting instructions. It has three operand instructions for binary operations.
21:29:04 <mmorrow> wow, there's SSE4 and 5 ...
21:29:14 <pumpkin> how big is the largest instruction now? last I remember they could go up to 17 bytes
21:29:17 <mmorrow> pumpkin: yeah
21:29:28 <mmorrow> (@your prev remark)
21:29:29 <pumpkin> I vastly prefer ARM :P
21:29:45 <pumpkin> and I would hate to write a decoder for anything remotely intel related
21:29:54 <centrinia> I prefer the Itanium.
21:31:09 <pumpkin> lol @ "MOVNTDQA"
21:31:18 <pumpkin> "PCMPESTRM"
21:31:41 <pumpkin> just give them legible function names and admit your assembly language has them
21:31:46 <centrinia> Oh, move non-temporal hint double quad aligned.
21:32:03 <pumpkin> lol
21:32:41 <centrinia> Is the pcmpestrm the compare equal string?
21:33:31 <centrinia> Oh, it returns the mask. :O
21:33:35 <ddarius> _ == _ = True -- Precondition: The inputs are equal
21:36:11 <pumpkin> oh SSE5 is AMD
21:36:35 <centrinia> Yes, and it looks more like Altivec than SSE
21:36:50 <pumpkin> ah
21:41:36 <pumpkin> mmorrow: a "simple" approach could be to provide basics (harpy-like, but that map to SSE in ghc rather than in separate output) and then a bunch of rewrite rules that do their best to rewrite ("unroll") certain operations into their SSE counterparts
21:42:32 <mmorrow> interesting
21:43:54 <pumpkin> Im not sure how general rewrite rules can be, but they seem like a good fit... not that I really know what I'm talking about much :)
21:43:57 <mmorrow> if someone was to make a list of operations which may/could/should be unrolled that would make implementing it just a matter of writing the code
21:44:41 <mmorrow> or s/list/writeup the general idea/
21:44:59 <mmorrow> (hint hint ;)
21:45:16 <ddarius> pumpkin: Doing that would not be feasible.
21:45:26 <pumpkin> well my experience with vectorizing stuff is on ARM, but on there you can say load n words into the following registers in one instruction, then multiply them all by x, or by a parallel vector (like a zipWith)
21:45:31 <pumpkin> ddarius: ah :/ how come?
21:45:34 <ddarius> Well, for certain operations maybe.
21:46:03 <ddarius> pumpkin: Because register allocation, for example, is non-local.
21:46:04 <pumpkin> I've never written SSE code myself, as I'm sure you can tell by how I talk about it :)
21:46:42 <pumpkin> ddarius: ah, that's true... so it would need to hook in lower down
21:47:20 <mmorrow> ddarius: but at least with sse2 code, you have your own set of dedicated registers that won't interfere registers used to pass (e.g.) globals around
21:47:40 <mmorrow> so that would at least make it slightly easier
21:47:56 <pumpkin> you'd still not want them to interfere with each other, so you'd need a mechanism to keep track of who's doing what
21:48:14 <pumpkin> but if you made slightly higher-level primitives as inline (non-haskell) functions
21:48:26 <pumpkin> like zipMultiply8 or something
21:48:29 <mmorrow> sure, you'd need register allocation code for them too, but at least that could be separate from the other regs
21:51:17 <mmorrow> both vertex and edge coloring of graphs are NP-hard to begin with..
21:51:46 <mmorrow> (to find the optimum solution)
21:51:49 <pumpkin> ah yeah
21:51:56 <pumpkin> but you can find decent approximations
21:52:01 <mmorrow> yes
21:54:18 <pumpkin> it sounds like fun though
21:54:38 <mmorrow> for sure
21:58:00 <hoboninja> Hey guys I'm having some problems with my web haskell code from inside java eh
21:58:40 <hoboninja> you can check it out at http://hello2u.info/haskell/
21:58:44 <hoboninja> any suggestions?
21:59:26 <kerlo> Ello.
21:59:43 <chessguy> hoboninja:  not loading for me
22:00:11 <chessguy> can you paste your code at hpaste?
22:00:14 <chessguy> @paste
22:00:14 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:00:29 <pumpkin> doesn't load for me either
22:07:57 <blackdog> is there a way to work out memory usage from within a haskell program?
22:09:02 <mmorrow> what do you mean by "work out"?
22:09:23 <mmorrow> as in bound statically?
22:09:38 <blackdog> i'd like to be able to query some of the profiling information that gets spat out when you run with -prof, but from within the program.
22:10:04 <mmorrow> oh, i'm not sure. if there is it'd prob be in the ghc mannual
22:10:09 <mmorrow> *manual
22:10:45 <blackdog> righto
22:23:19 <nanothief> can someone explain the purpose of coarbitrary in the QuickCheck libs? I read the explaination in the docs but didn't get it :(
22:42:31 <eyeris> Can anyone here build happs using the recipe on the website?
22:42:38 <eyeris> I get this exception error: http://hpaste.org/14007
23:03:43 <newsham> ?type Maybe not
23:03:45 <lambdabot> Not in scope: data constructor `Maybe'
23:04:54 <newsham> ?type maybe not
23:04:55 <lambdabot> forall a. (a -> Bool -> Bool) -> Maybe a -> Bool -> Bool
23:06:54 <jeffwheeler> I fear I'm probably doing this wrong; does this set off any alarms for anyone? refreshLoop $ ui { fr = runFeedReader (cfg ui) tryPreviousBuffer (fr ui) }
23:07:16 <pumpkin> I've found that I'm getting better and better at getting new code to compile the first time I write it
23:07:36 <jeffwheeler> runFeedReader ∷  Config →  FeedReaderM a →  FeedReader →  FeedReader
23:07:42 <newsham> pumpkin: so you're saying type checking is becoming less useful
23:07:54 <pumpkin> not necessarily
23:08:01 <pumpkin> I just keep track of the types better as I write it
23:08:11 <pumpkin> it's sinking in more, I guess
23:09:32 <Taejo> @tell RPS how're things going?
23:09:32 <lambdabot> Consider it noted.
23:09:45 <Taejo> @seen RPS
23:09:45 <lambdabot> RPS is in #haskell. I last heard RPS speak 1d 3m 48s ago.
23:16:47 <dmwit> I'm proud of this little hack: http://www.reddit.com/r/programming/comments/7q8pg/i_was_hired_to_write_a_device_driver_for_an_old/c073go1?context=1
23:25:59 <dmwit> Is it quiet or late?
23:26:07 <newsham> cant it be both?
23:32:15 <dmwit> Is it quiet xor late?
23:32:18 <dmwit> ;-)
23:33:04 <ivanm> it's not that late....
23:33:11 <ivanm> only 5:30 PM! ;-)
23:34:23 <Raynes> It's 1:34 am here.
23:35:47 <mmorrow> what time is it at exactly the north/south pole?
23:35:55 <mmorrow> always party time?
23:36:18 <mmorrow> seriously though
23:36:24 <znutar> dunno about the north pole, but the south pole is _|_
23:36:32 <dmwit> It's "who-cares" o'clock.
23:36:41 <ivanm> znutar: lol
23:36:49 <mmorrow> crap, hit the wrong key
23:37:08 <dmwit> Wow, you have a "seriously though" key? O_o
23:37:09 <ivanm> mmorrow: my guess is that since there's no land at the north pole, dmwit is right for that one
23:37:20 <ivanm> dmwit: lol
23:37:30 <mmorrow> dmwit: it's such a pita too!
23:37:31 <ivanm> for the south pole, whichever country's base is the closest? *shrug*
23:37:45 <mmorrow> i think both are undefined
23:38:00 <ivanm> @go timezone south pole
23:38:02 <lambdabot> http://www.timeanddate.com/worldclock/city.html?n=468
23:38:02 <lambdabot> Title: Current local time in South Pole - Antarctica
23:38:29 <ivanm> UT+12 it says
23:38:29 <mmorrow> i mean at the exact two points where all the timezones meet
23:38:46 <ivanm> though with daylight saving time, it's at UTC+13 = UTC-11 AFAIK... >_>
23:39:03 <ivanm> oh, it says south pole == amundsen scott :s
23:39:19 <dmwit> mmorrow: There's probably a line -- let's say 175 degrees north and 175 degrees south -- after which they just declare it GMT or so.
23:39:19 <znutar> I don't think they need to worry about saving daylight right about now
23:39:34 <ivanm> znutar: ummm..... south pole has summer now... >_>
23:39:37 <mmorrow> dmwit: sly
23:39:50 <znutar> Yeah...  but it's day all day long
23:39:54 <ivanm> dmwit: my guess is they might say its UTC+12 for the international date line
23:40:07 <ivanm> znutar: so they're saving it for when it _does_ get dark! ;-)
23:40:11 <mmorrow> it says the moon is always up currently at the couth pole too
23:40:12 <jeffwheeler> As far as I know, anybody in Antarctica just goes by the time of their home-country.
23:40:13 <dmwit> ivanm: possibly
23:40:29 <ivanm> according to wikipedia, south pole is at NZ time
23:40:35 <dmwit> jeffwheeler++ for sounding like he knows what he's talking about
23:40:41 <ivanm> because the amundsen scott base has flights to/from NZ
23:40:53 <ivanm> jeffwheeler-- for being wrong
23:40:53 <ivanm> ;-)
23:41:03 <intoverflow> yeah, Christcurch, NZ is their main point of contact, iirc
23:41:09 <ivanm> http://en.wikipedia.org/wiki/South_pole#Time
23:41:14 <jeffwheeler> dmwit: there's somebody from Antarctica that posts on my forum frequently; he's my source
23:41:38 <ivanm> North Pole is _|_
23:41:41 <mmorrow> oh sweet, a live webcam of the amundsen-scott south pole station http://www.usap.gov/videoclipsandmaps/spwebcam.cfm
23:41:56 <ivanm> (typically whatever is most convenient, such as travellers home country)
23:42:06 <ivanm> http://en.wikipedia.org/wiki/North_pole#Time
23:42:10 <mmorrow> err, it says "waiting for satellite availability"
23:42:20 <ivanm> mmorrow: that's nothing!
23:42:23 <mmorrow> looks like the satellite does set
23:42:43 * ivanm finds the URL for the pitch drop experiment
23:43:32 <ivanm> mms://drop.physics.uq.edu.au/PitchDropLive
23:45:08 <ivanm> that's the webcam of the pitch drop experiment at university of queensland
23:45:10 <dmwit> Now that's a webcam that changes frequently.
23:45:18 <jeffwheeler> http://www.kirupa.com/forum/showpost.php?p=2265480&postcount=9
23:45:23 <mmorrow> um, it just loaded in vlc. what is it?
23:45:24 <ivanm> (IIRC, no-one has actually ever seen one of the 8 drops actually drop)
23:45:35 <ivanm> http://en.wikipedia.org/wiki/Pitch_drop_experiment
23:45:38 <ivanm> mmorrow: ^^
23:46:05 <jeffwheeler> That poster (as the location on the left states) is in Antarctica himself.
23:46:24 <ivanm> dmwit: well, it's saturday afternoon during summer.... during term time, you'll see students milling around 5+- min of the hour
23:46:28 <mmorrow> heh, "To date, no one has ever actually witnessed a drop fall. The experiment is in the view of a webcam although technical problems prevented the most recent drop from being recorded"
23:46:34 <ivanm> yup
23:46:37 <mmorrow> epic fail
23:46:45 <ivanm> it's a conspiracy! ;-)
23:46:49 <Taejo> what's the status of the logo competition?
23:46:52 <mmorrow> i was reading somewhere that glass isn't actually a solid
23:47:02 <ivanm> it isn't... see old windows in churches, etc.
23:47:13 <ivanm> they had the pitch at the 1988 world expo.... it fell during the night :s
23:48:09 <ivanm> http://en.wikipedia.org/wiki/Glass#The_physics_of_glass
23:49:54 <ivanm> hmmmm..... seems that the "old windows are thicker at the bottom, which means glass is a liquid" claims are wrong :s
23:50:20 <ivanm> @quote DrMacIver topic
23:50:21 <lambdabot> No quotes for this person. Maybe you made a typo?
23:50:26 <ivanm> @quote DRMacIver topic
23:50:26 <lambdabot> DRMacIver says: #haskell doesn't so much wander off topic as orbit it. :)
23:50:29 <ivanm> ;-)
23:50:31 <dolio> I had a professor at college that talked about that.
23:50:42 <dolio> He said they're thicker at the bottom due to how they're made.
23:50:49 <ivanm> yeah, so says wikipedia :s
23:50:56 <jeffwheeler> Can an op do this? /topic ["Real World Haskell: out now", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]
23:51:10 <jeffwheeler> (Fixing the missing comma . . .)
23:51:13 <dmwit> ivanm: According to my dad, part of his Ph.D. thesis involved reading up on somebody else's research which proved that glass is not fluid in any way.
23:51:53 <ivanm> dmwit: wikipedia calls it a supercooled liquid or something...
23:52:03 <dmwit> ivanm: Basically, a guy took 40 strings of optical fiber that was initially straight, coiled them up separately in envelopes, and took one out every year to measure their curvature, or something like that.
23:52:32 <ivanm> dmwit: a 40 year experiment?
23:52:35 <dmwit> yes
23:52:41 <ivanm> have optical fibers even been out for that long?
23:52:48 <dmwit> I'm pretty sure the whole myth started as a misunderstanding of the term "super-cooled liquid".
23:52:52 <ivanm> I thought they were relatively new...
23:52:55 <ivanm> yeah
23:52:58 <dmwit> Because super-cooled liquids are, in fact, liquid.
23:53:18 <dmwit> Not "solid-like".
23:53:23 <ivanm> it's not a "standard" solid, anyway
23:53:47 <sleven> haskell has no way to do sideeffects at all? refs atoms or anything?
23:53:47 <ivanm> http://en.wikipedia.org/wiki/Amorphous_solid
23:53:48 <dmwit> Oh, no, optical fiber is old.
23:54:00 <ivanm> sleven: well, there's the IO monad...
23:54:02 <dmwit> sleven: We have many ways of doing side effects!
23:54:11 <dmwit> We're rather proud of our extensively populated IO monad.
23:54:15 <mmorrow> , runST (x <- newSTRef 42; writeSTRef x 9; readSTRef)
23:54:17 <pumpkin> sleven: there's the ST too
23:54:18 <Taejo> sleven: of course it has a way to do side effects... otherwise we wouldn't know our programs were running?
23:54:19 <ivanm> after all, a language without side effects means no way of communicating with other programs, etc.
23:54:20 <mmorrow> , runST (do x <- newSTRef 42; writeSTRef x 9; readSTRef)
23:54:20 <lunabot>  luna: parse error on input `<-'
23:54:22 <lunabot>  luna: Couldn't match expected type `GHC.ST.ST s a'
23:54:29 <pumpkin> mmorrow: { }?
23:54:30 <mmorrow> , runST (do x <- newSTRef 42; writeSTRef x 9; readSTRef x)
23:54:32 <lunabot>  9
23:54:35 <pumpkin> or that
23:54:37 <pumpkin> :)
23:54:39 <mmorrow> :)
23:54:51 * pumpkin goes to his corner to fail in peace
23:55:16 * pumpkin is a monad that fails so hard it only has a fail function, without a bind :(
23:55:26 <ivanm> hmmmm.... that reminds me... would it be safe to say that when you use the State monad, it's more that you're specifying the operations to perform on data rather than performing it on the data itself? i.e. that you use the State monad to build up a chain of computations?
23:55:33 <jeffwheeler> pumpkin: you _are_ a monad?
23:55:35 <dmwit> ivanm: yes
23:55:36 <pumpkin> hup
23:55:42 <ivanm> @src pumpkin fail
23:55:42 <lambdabot> Source not found. Are you on drugs?
23:55:45 <ivanm> hmmm...
23:55:59 <mmorrow> @src PumpkinM fail
23:55:59 <lambdabot> Source not found. :(
23:56:04 <pumpkin> jeffwheeler: well, I try to be a monad but I fail even at that, due to my lack of a bind... >>= =  undefined :(
23:56:07 <ivanm> dmwit: OK, that makes more sense then what I was told the time (Cale maybe?) tried to teach me what the State monad did ;-)
23:56:23 <ivanm> I'd say that's about $5 worth of RWH well spent then :p
23:56:23 <jeffwheeler> pumpkin: that's the worst . . . :P
23:56:42 <mmorrow> heh
23:57:01 <Cale> ivanm: You can safely think about any monad in that way.
23:57:01 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
23:57:26 <Cale> (as being a type of computation, together with operations for fitting computations together into larger ones)
23:57:27 <PumpkinM> does lambdabot have any kind of authentication? does it check nickserv identities?
23:57:37 <Cale> PumpkinM: no
23:57:40 <PumpkinM> :o
23:57:47 <ivanm> Cale: even ones like Maybe, etc.?
23:58:00 <PumpkinM> sure!
23:58:15 <Cale> ivanm: Sure. A value of type  Maybe t  can be thought of as a computation which may fail to produce a value of type t.
23:58:16 <mmorrow> even ones like PumpkinM??
23:58:35 <dolio> I thought it checked that you were authenticated.
23:58:37 <PumpkinM> nope :(
23:58:39 <mmorrow> unsafePumpkinM
23:58:42 <dolio> @tell dolio___ Test
23:58:42 <lambdabot> Consider it noted.
23:58:51 <dolio___> @messages
23:58:51 <lambdabot> dolio said 8s ago: Test
23:58:54 <Cale> A list can be thought of as a computation with zero or more results.
23:58:57 <dolio___> Huh. Oh well.
23:58:59 <ivanm> Cale: and that's not what I meant anyway.... what I meant was that it seems to me that a State monad is a way of composing a whole bunch of functions together and then applying it to a value
23:59:28 <Cale> ivanm: Well, "composing" -- they don't compose in the usual straightforward way, but that's pretty much what you're doing.
23:59:37 <ivanm> *nod*
23:59:47 <ivanm> which is what differentiates the State monad from say the Maybe monad?
23:59:59 <ivanm> (as well as being able to store extra values in the State monad)
