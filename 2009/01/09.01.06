00:00:10 <Saizan> /\x just has a different type from \x
00:00:19 <vixey> but you can't really write something like
00:00:28 <vixey> /\T:*, /\V:T, (V,T)
00:00:45 <vixey> or can you ?
00:01:53 <vixey> It's confusing to have two different abstractions, why not have \ and \\ and \\\ .. ?
00:02:24 <dolio> How's that different other than the characters used?
00:02:54 <vixey> dolio, but I mean why stop at \ and /\, instead of having more abstractors?
00:03:06 <dolio> Because that's not System F anymore.
00:03:12 <Saizan> it has two abstraction because one gives you a forall and the other a ->, but if you use \Pi you can see them as the same thing
00:03:16 <dolio> It's something with an infinite hierarchy of universes.
00:03:27 <vixey> ahha
00:03:39 <vixey> merging forall and ->, means /\ = \
00:04:02 <vixey> but does it change anything else in the process?
00:04:40 <Saizan> no, if you restrict the types of what you can use in \Pi
00:04:51 <Saizan> seen the paper on Henk?
00:05:17 <vixey> yes
00:06:44 <Saizan> about /\T:*, /\V:T, (V,T), i think System F allows it, since you can have functions from types to values
00:07:01 <Saizan> or not..
00:07:38 <sbahra> Why is html distributed with GHC?
00:07:43 <sbahra> seems sort of out of place
00:07:47 <vixey> I meant this as a function from types to types
00:07:54 <vixey> you can't really have that in System F can you?
00:08:21 <Saizan> ah, you meant having a value in a type?
00:08:28 <vixey> oh!
00:08:29 <vixey> oops
00:08:36 <vixey> /\T:*, /\V:*, (V,T)
00:08:40 <vixey> that's what I meant to write
00:08:52 <vixey> I am used to typing the polymorphic id function :S
00:09:00 <Saizan> :D
00:09:11 <Saizan> you can have that in F2, yeah
00:10:37 <Saizan> like Pair = \a:* b:*. forall r. (a -> b -> r) -> r
00:11:19 <Saizan> so that Pair Int Bool beta-reduces to forall r. (Int -> Bool -> r) -> r
00:11:40 <vixey> no I'm confused again
00:12:23 <dolio> I think I am, too.
00:12:27 <dolio> Which lambda is that?
00:12:39 <vixey> it must be a _new_ lambda
00:12:45 <dolio> Because presumably Pair :: * -> * -> *.
00:12:47 <Saizan> Pair :: * -> * -> *
00:13:04 <Saizan> yeah it's not a lambda at the value level
00:13:14 <dolio> But for big lambdas, the typing rule says you get a forall.
00:13:23 <dolio> Or are there two typing rules for big lambda?
00:13:34 <vixey> \\a:*, \\b:*, forall r, (a -> b -> r) -> r
00:13:37 <dolio> One for if your result is a type, and the other for a value.
00:14:28 <dolio> The System F article doesn't talk about little lambdas at the type level, though.
00:14:30 <vixey> well you have got the kind system, it's just  *, and * -> *
00:14:33 <vixey> oops
00:14:37 <vixey> * and k -> k'
00:14:42 <mae> supposing I have a List Arrow of type (LA XmlTree String) -- how can I retrieve this String output value and print it?
00:14:44 <dolio> (The wikipedia one, that is.)
00:14:50 <Saizan> dolio: true
00:15:03 <vixey> but the type level, it has got   /\, forall, ->, and why doesn't it get it's own lambda _also_?
00:15:12 <vixey> oh it doesn't have /\
00:15:18 <vixey> that's on the value level
00:15:22 <Saizan> i was mostly going from the "Simpler Easier" post from augustss and the Henk paper
00:15:47 <dolio> Saizan: This all seems much easier in the lambda cube/pure type systems. :)
00:15:56 <Saizan> yeah :)
00:16:18 <naturalethic> Can someone tell me why this only works on an odd number of delimited string? http://hpaste.org/13669
00:16:41 <Saizan> we should look at Girard's paper to see what really System F allows
00:16:43 <naturalethic> Or suggest a smarter way
00:16:55 <vixey> naturalethic: have a go using unfoldr
00:17:03 <vixey> Saizan, Proofs and types?
00:17:09 <Saizan> yes
00:17:12 <naturalethic> oh yeah you said that before
00:17:30 <Saizan> mae: there should be a runLA somewhere
00:17:49 <mmorrow> @tell newsham yes. the code for Fold: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=541  || examples:  http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=541#a543  || a module with instances of Lift for all the TH syn (this makes TH useable:)  http://moonpatio.com/repos/luna/src/Luna/TH/Instances.hs
00:17:49 <lambdabot> Consider it noted.
00:17:58 <dolio> > span (/=1) [1,1,1,2,2,2]
00:18:00 <lambdabot>   ([],[1,1,1,2,2,2])
00:18:15 <vixey> ?where+ moonpaste http://moonpatio.com:8080/
00:18:15 <lambdabot> Done.
00:18:19 <vixey> ?where moonpaste
00:18:20 <lambdabot> http://moonpatio.com:8080/
00:18:29 <dolio> > span (==1) [1,1,1,2,2,2]
00:18:30 <lambdabot>   ([1,1,1],[2,2,2])
00:18:44 <mmorrow> ahh, i've been trying to remember howtf to store an addr with where for weeks now
00:18:44 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
00:18:54 <vixey> heh
00:21:08 <SubStack> hooray, editline fixed it
00:21:32 <SubStack> ghc certainly does take a long time to compile though
00:21:36 <AkhIL> Hi! Is there a way to read OpenEXR images in haskell?
00:21:45 <vixey> I just thought of something, to do with lazyness
00:21:50 <vixey> instead of writing, sameShape :: Tree a -> Tree b -> Bool
00:22:04 <vixey> why not write: sameShape :: Tree a -> Tree b -> Maybe (Tree (a,b))
00:22:06 <Saizan> dolio: ah, the wikipedia article mentions "mappings from types to types" at the end
00:22:10 <mmorrow> SubStack: heh, that it does
00:22:31 <vixey> it should be roughly the same in terms of allocation, if you only /use/ it as a bool, right?
00:22:33 <dolio> naturalethic: One of your cases has the potential to take the tail of an empty list. The other doesn't.
00:22:44 <vixey> like   maybe False (const True)
00:22:58 <vixey> but the type gives you evidence
00:22:58 <dolio> naturalethic: One of them also leaves the delimiter in place on the recursive call.
00:23:09 <mmorrow> vixey: totally. then grab all the leaves into a [(a,b)] and unify away
00:23:18 <SubStack> good thing I have two cores so the compilation doesn't interrupt my other activities so much
00:23:23 <SubStack> mmorrow++
00:23:36 <vixey> hmm
00:23:51 <dolio> So, it alternates between having the unsafe one on a null string (which fails), and having the safe one, depending on how many delimiters there are.
00:23:54 <vixey> unify is an interesting generic program
00:24:01 <vixey> (to abstract over datatypes)
00:24:41 <grigorij> :m Data.Function
00:24:53 <dolio> Saizan: Yeah, it doesn't talk about constructing them. I think that's why it was muddling me up about type functions and quantification.
00:25:13 <dolio> Since the only type-lambda it talks about is the one for quantification.
00:25:36 <naturalethic> geez the splitOn implementation on that page is exactly what I need
00:25:37 <mmorrow> vixey: i tried to use this exact method of unification in http://code.haskell.org/~morrow/code/haskell/hm/HM.html
00:26:07 <dolio> Isn't there something on hackage for list splitting now?
00:26:28 <dolio> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split
00:28:54 <naturalethic> dolio: in python i'd debug that by printing out a bunch of intermediate states -- my mind isn't used to trying to understand stuff :)
00:29:16 <vixey> mmorrow, that stuff with  dfT  confuses the hell outo fme
00:29:37 <mmorrow> vixey: it just flattens the tree depth-dirst
00:29:44 <vixey> I mean your use of dfT
00:30:00 * mmorrow looks to remember
00:30:18 <vixey> right next to the comment -- TODO: clean me! rename me!  :p
00:30:26 <dolio> I think the best way to write a split function functionally (for a first pass, at least; optimal performance no object) is to use unfoldr as vixey said.
00:31:03 <vixey> I should make an example of unfold for naturalethic
00:31:05 <dolio> Think about what you'd do to split one word off, and let the universal recursive function extend it to the entire list.
00:31:05 <vixey> :t unfold
00:31:07 <lambdabot> Not in scope: `unfold'
00:31:07 <mmorrow> oh, in go_ you mean
00:31:07 <vixey> :t unfoldr
00:31:08 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
00:31:29 <vixey> > let foo 0 = Nothing ; foo n = Just (n,n-1) in  unfoldr foo 15
00:31:31 <lambdabot>   [15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]
00:31:34 <mmorrow> so first it does
00:31:37 <mmorrow> match (id&&&ftvs) (id&&&ftvs) (rename t) (rename t')
00:31:47 <dolio> It's almost trivial, except span doesn't return a Maybe and keeps the delimiters.
00:31:55 <mmorrow> to rename everything and extract freevars of each
00:31:56 <vixey> morrow, you only unify them if they are the same shape?
00:32:24 <mmorrow> ahh, that's the cool part
00:32:32 <mmorrow> so you get in the very end:
00:33:12 <mmorrow> or, starting from the middle
00:33:32 <mmorrow> Either (a, T b) (T a, b)
00:34:14 <mmorrow> so when you hit a leaf, either the corresponding point in the other tree is a leaf or a tree
00:34:35 <mmorrow> and, since   T Type and Type are interconvertible
00:34:58 <mmorrow> (Type, T Type) === (Type, Type)
00:35:26 <mmorrow> and the T just guides us along as a temporary structuring thing
00:36:05 <mmorrow> well, the structure of the Type is turned into the structure of (T Type), and the leaves are either tyvars or primtypes
00:36:15 <vixey> oh
00:36:18 <vixey> I think I sort of get it
00:36:55 <mmorrow> so the func zipT enumerates the actual cases of the unification
00:37:14 <mmorrow> (but in a generic way at that point)
00:37:18 <vixey> that's pretty cool
00:37:32 <vixey> yeah Tree is all you need
00:37:37 <dolio> > let f _ "" = Nothing ; f d xs = let (w, r) = span (/= d xs) in Just (w, drop 1 r) in unfoldr (f '.') "foo.bar.baz"
00:37:37 <mmorrow> yes!
00:37:38 <lambdabot>   Couldn't match expected type `(t, t1)'
00:37:51 <mmorrow> Tree is Type is Exp is Tree
00:37:53 <dolio> > let f _ "" = Nothing ; f d xs = let (w, r) = span (/= d) xs in Just (w, drop 1 r) in unfoldr (f '.') "foo.bar.baz"
00:37:54 <lambdabot>   ["foo","bar","baz"]
00:37:58 <dolio> > let f _ "" = Nothing ; f d xs = let (w, r) = span (/= d) xs in Just (w, drop 1 r) in unfoldr (f '.') "foo.bar.baz.quux"
00:38:00 <lambdabot>   ["foo","bar","baz","quux"]
00:38:05 <dolio> > let f _ "" = Nothing ; f d xs = let (w, r) = span (/= d) xs in Just (w, drop 1 r) in unfoldr (f '.') "foo.bar.baz.quux.quuuux"
00:38:06 <lambdabot>   ["foo","bar","baz","quux","quuuux"]
00:38:09 <vixey> so you can reduce unification for arbirtary data to writing coercion to tree and back
00:38:16 <mmorrow> exactly
00:38:52 <mmorrow> and handle it all uniformly, assuming you have (a -> T a, T a -> a)
00:39:19 <mmorrow> so the type `a' actually has the structure of a tree internally
00:39:54 <mmorrow> hmm, i guess most everything does, but there's not one way that each do...or something
00:42:15 <Saizan> that's very similar to "pure patterns", not surprisingly
00:43:20 <vixey> I guess:  F a <-> T a
00:43:26 <vixey> or not..
01:03:46 <vixey> LANGUAGE is so stupid
01:03:50 <vixey> why I have to write
01:03:54 <vixey> {-# LANGUAGE GADTs, KindSignatures #-}
01:03:56 <vixey> instead of
01:03:57 <vixey> {-# LANGUAGE GADTs KindSignatures #-}
01:04:17 <vixey> because ... it's not like any of these extensions can have a space in them so there's no need for a comma
01:05:55 <erikc> maybe extensions will be functions one day :)
01:17:35 <azathoth99> wow haskell really getting popular
01:17:37 <azathoth99> holy crap
01:24:39 <mmorrow> oh oops, i said this earlier
01:24:42 <mmorrow> <mmorrow> you can't generate arbitrary haskell code at compile-time
01:25:03 <mmorrow> well, of course i thought i said you CAN ;)
01:25:32 <mmorrow> (and you can)
01:25:44 <Saizan> we were quite puzzled :)
01:26:05 <mmorrow> heh, i was totally confused by everyone's comments as well
01:26:52 * mmorrow goes to sleep
01:26:57 <mmorrow> night
01:38:32 <vixey> > concatMap (\c -> concatMap (\c -> concatMap (\c -> map c "abc") map c "uv") (map c "xyz")) [(,,)]
01:38:33 <lambdabot>   Couldn't match expected type `[Char -> b]'
01:38:52 <vixey> > concatMap (\c -> concatMap (\c -> concatMap (\c -> map c "abc") (map c "uv")) (map c "xyz")) [(,,)]
01:38:53 <lambdabot>   [('x','u','a'),('x','u','b'),('x','u','c'),('x','v','a'),('x','v','b'),('x'...
01:44:19 <walski> Hi
01:45:03 <walski> I would like to build a set ADT which starts like this:
01:45:03 <walski> http://hpaste.org/13670
01:45:34 <walski> But this fails on line 16
01:45:56 <walski> GHCI says: "No instance for (Eq a)"
01:46:21 <walski> :/ is there any way to compare a and b, anyway? Maybe something which falls back to false if Eq is not derived from a and b?
01:46:36 <quicksilver> walski: No.
01:46:39 <walski> Or do I have to solve the whole issue in another way?
01:46:43 <quicksilver> walski: you should require Eq for that method.
01:46:57 <walski> Ah just (Eq a) ?!
01:46:57 <quicksilver> contains :: Eq a => Set a -> a -> Bool
01:47:01 <walski> cool
01:47:15 <quicksilver> 'function' not 'method' (sorry)
01:47:34 <quicksilver> you're going to then need it for add, of course
01:47:42 <quicksilver> because your add function calls contains
01:47:46 <walski> yes
01:47:47 <quicksilver> but htat's not really very surprising.
01:47:53 <walski> can I add it to the data definition, as well?
01:47:58 <quicksilver> it can't add something to the set unless it can check if it's already there.
01:48:06 <walski> so that I only need to declare this once?
01:48:07 <quicksilver> adding it to the data definition doesn't work very well.
01:48:16 <vixey> walski ,for what purpose?
01:48:29 <quicksilver> in particular, it doesn't stop you needing to annotate each function
01:48:33 <walski> To omit it anywhere else
01:48:39 <walski> ok ;)
01:48:42 <vixey> walski, that's not what it would achieve
01:48:54 <vixey> walski, if you just leave out type annotations everywhere that works though
01:49:19 <walski> What does this => exactly mean?
01:49:28 <quicksilver> it just separates the context from the type
01:49:46 <quicksilver> it doesn't really mean much, merely punctuation
01:49:59 <walski> ok thank you both! now it's working ;) nice
01:52:46 <cjs> Hm. What causes a thread to exit with the error, "thread blocked indefinitely."
01:54:10 <quicksilver> a detectable MVar deadlock
01:54:14 <cjs> This is when I'm using STM.
01:54:22 <cjs> MVar? So not STM-related? Hmmm.
01:54:27 <quicksilver> could be STM
01:54:34 <quicksilver> waiting on a TVar which no other thread will ever change
01:54:53 <quicksilver> (because no other thread has a reference to it)
01:55:00 <cjs> Ah! How the heck does it know that?
01:55:43 <cjs> And it's intentionally blocking indefinitely, for the moment. We've got the bit that eats stuff from a TChan, but have yet to write the corresponding bit that writes to it.
01:56:18 <quicksilver> the GC knows.
01:56:24 <quicksilver> the GC knows what is reachable from which threads
01:56:42 <quicksilver> if it can see a thread is blocked on an MVar resp. TVar which is not reachable from any runnable thread
01:56:47 <quicksilver> then it can see the deadlock
01:56:52 <quicksilver> (obviously it can't see all deadlocks)
01:57:06 <Saizan> you have to keep the TChan in scope somewhere else
01:58:47 <enticingjelly> for some reason, the continuation monad fried my brain.
01:59:23 <enticingjelly> i tried to reimplement it myself but my attemps to implement the bind operator were pathetic and desperate
01:59:44 <vixey> you tried to code it by looking at the types of things?
01:59:49 <enticingjelly> yes
01:59:57 <vixey> well that should not have gone wrong
02:00:15 <enticingjelly> well, I also had no problem with coming up with the types by myself
02:01:02 <Saizan> bind is ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
02:01:15 <idnar> aargh
02:01:57 <cjs> Hm. You'd think the compiler could do that through static analysis, but perhaps that's just this case.
02:02:07 <enticingjelly> vixey, thanks ;)
02:03:11 <enticingjelly> (Cont c) >>= f = Cont $ \k -> c (\a -> runCont (f a) k)
02:03:44 <Saizan> that's it
02:03:56 <enticingjelly> \k -> c (\a -> (f a) k)
02:03:58 <enticingjelly> that's the essence
02:04:07 <enticingjelly> I couldn't come up with it, don't know why
02:04:16 <Saizan> ?djinn (Not (Not a)) -> (a -> (Not (Not b)) -> Not (Not b)
02:04:17 <lambdabot> Cannot parse command
02:04:17 <vixey> :t \k -> c (\a -> (f a) k)
02:04:18 <lambdabot>     Couldn't match expected type `(t1 -> t2) -> t'
02:04:18 <lambdabot>            against inferred type `Expr'
02:04:18 <lambdabot>     In the expression: c (\ a -> (f a) k)
02:04:35 <Saizan> ?djinn (Not (Not a)) -> (a -> (Not (Not b))) -> Not (Not b)
02:04:35 <lambdabot> f a b c = void (a (\ d -> void (b d c)))
02:05:04 <enticingjelly> :t \c f -> \k -> c (\a -> (f a) k)
02:05:06 <lambdabot> forall t t1 t2 t3. ((t -> t2) -> t3) -> (t -> t1 -> t2) -> t1 -> t3
02:09:06 <walski> If I have: add :: Eq a => Set a -> a -> Set a
02:09:15 <walski> how do I expand this to Eq a AND Ord a?
02:09:39 <Saizan> the syntax is add :: (Eq a, Ord a) => ...
02:09:49 <walski> thanks!
02:09:51 <Saizan> but Eq is a superclass of Ord
02:09:57 <Saizan> so you only need Ord a
02:09:59 <walski> ok so just ord is enough?
02:10:08 <Saizan> yeah
02:10:16 <walski> cool!
02:18:06 <Peaker> I think in most cases sub-classes methods contain all the expressiveness of the super-class methods.  I think maybe in all these cases, you should define how the sub-class defines the super-class, and allow only the sub-class to be instantiated for both?
02:24:27 <Saizan> Peaker: not "only", i.e. you should still allow for optimized implementation of the superclasses
02:25:07 <Peaker> Allow for "only" as in: the instantiator chooses whether to only do the sub-class or both
02:26:06 <Saizan> that seems sensible
02:26:24 <Saizan> i think that it's almost implementable with TH too
02:30:08 <vixey> ?djinn ([a -> b1] -> [b1]) -> ([a -> b] -> [b]) -> [a -> a -> (a,a)] -> [(a,a)]
02:30:08 <lambdabot> Error: Undefined type []
02:30:37 <vixey> ?djinn (Maybe (a -> b1) -> Maybe (b1)) -> (Maybe (a -> b) -> Maybe (b)) -> Maybe (a -> a -> (a,a)) -> Maybe ((a,a))
02:30:38 <lambdabot> f _ _ _ = Nothing
02:31:14 <vixey> ?djinn (Maybe (a -> a -> (a,a)) -> Maybe (a -> (a,a))) -> (Maybe (a -> (a,a)) -> Maybe ((a,a))) -> Maybe (a -> a -> (a,a)) -> Maybe ((a,a))
02:31:15 <lambdabot> f a b c = Nothing
02:33:11 <saz> anyone can help me with a quick questio? "Occurs check: cannot construct the infinite type: t = IO t"
02:33:55 <arw> well, that datatype is infinite, as it says.
02:34:16 <saz> but I did not define a new data type
02:34:25 <saz> it's a simple function
02:34:47 <arw> yeah, but there seems to be a type error when compiling that function.
02:35:10 <IvdSangen> unification diverges, i.e. does not terminate
02:35:22 <IvdSangen> so, GHC complains
02:35:32 <saz> ((-b)+d) can't see how thats infinite =x
02:35:40 <Saizan> saz: that means you've used something of type IO a where something of type a is expected for some a
02:35:55 <vixey> I need to find a new way to find cartesian products
02:36:09 <Saizan> saz: that's too little code
02:36:10 <saz> ok thanks
02:36:14 <Saizan> @paste
02:36:14 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:36:17 <vixey> k (concatMap (flip map as)) is too awkward
02:36:17 <saz> I'll try to tweak it
02:36:21 <dolio> saz: If t = IO t, then t = IO (IO (IO (IO (IO ...))))
02:36:26 <Saizan> paste the whole function there and we can have a look
02:38:36 <vixey> has anyone seen this sequence (\f x -> f x), (\f g x -> g (f x)), ...?
02:39:21 <dolio> Function composition?
02:39:37 <vixey> ok
02:39:40 <vixey> ($), (.), ...
02:40:25 <vixey> @pl (\f g h x -> h (g (f x)))
02:40:25 <lambdabot> (flip (.) .) . flip (.)
02:43:29 <elbar> @pl (\f x -> f x)
02:43:29 <lambdabot> id
02:43:52 <elbar> @pl (\f g x -> g (f x))
02:43:53 <lambdabot> flip (.)
02:44:51 <IvdSangen> @pl (\f g h i x -> i (h (g ( f x ) ) ) )
02:44:51 <lambdabot> (((flip (.) .) . flip (.)) .) . flip (.)
02:45:07 <IvdSangen> now, for extracting the pattern...
02:45:15 <elbar> plenty of flipping going around =)
02:45:26 <vixey> I kind of doubt looking at pl versions will help though
02:46:12 <dolio> ($), (.), (.) . (.), (.) . (.) . (.), ...
02:46:25 <dolio> With some reordering of the arguments.
02:46:28 <idnar> badger badger badger badger
02:46:59 <dolio> @type (>>>) >>> (>>>)
02:47:00 <lambdabot> forall (a :: * -> * -> *) b c d d1. (Arrow a) => a b c -> (a b d -> d1) -> a c d -> d1
02:47:19 <dolio> @type (>>>) <<< (>>>)
02:47:20 <lambdabot> forall d (a :: * -> * -> *) b c d1. (Arrow a) => a b c -> (a b d1 -> d) -> a c d1 -> d
02:47:26 <dolio> @type (>>>) . (>>>)
02:47:28 <lambdabot> forall d (a :: * -> * -> *) b c d1. (Arrow a) => a b c -> (a b d1 -> d) -> a c d1 -> d
02:48:01 <Saizan> :t (.) . (.)
02:48:02 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
02:48:15 <Saizan> :t (\f g h x -> h (g (f x)))
02:48:16 <lambdabot> forall t t1 t2 t3. (t -> t1) -> (t1 -> t2) -> (t2 -> t3) -> t -> t3
02:48:35 <dolio> Oh, right, I'm doing the wrong thing.
02:50:39 <Peaker> could be nice if you could use:  @. canonize type ...         -- to get a canonized a/b/c/d form
02:50:54 <xenoblitz> guys what are the characters allowed in the "string" which defines a constructor in a data type apart from a-zA-z
02:51:02 <mm_freak_> cabal: dependencies conflict: ghc-6.10.1 requires process ==1.0.1.0 however
02:51:02 <mm_freak_> process-1.0.1.0 was excluded because ghc-6.10.1 requires process ==1.0.1.1
02:51:04 <mm_freak_> huh?!
02:51:19 <dolio> Heh.
02:51:31 <walski> How do I implement the same think as deriving Eq for a data type on my own?
02:51:43 <walski> "Overriding" the == operator
02:51:48 <mm_freak_> what's going wrong here?!
02:51:48 <dolio> xenoblitz: Same as any identifier, just beginning with a capital.
02:52:09 <xenoblitz> walski: create an instance of the Eq class ... check out type classes
02:52:13 <dolio> So, _, ' and any alphanumeric character.
02:52:17 <walski> thanks
02:53:02 <dolio> xenoblitz: Plus a bunch of unicode, if you're into that.
02:53:03 <xenoblitz> dolio: thanks... are symbols allowed? and if yes which are legal?
02:53:22 <xenoblitz> dolio: I have seen code somewhere which for example uses data E = E + E
02:53:40 <dolio> You can use symbols for infix constructors, but they have to begin with a colon.
02:53:41 <xenoblitz> dolio: but i am not sure about the "+" as it where
02:53:52 <Gracenotes> let O=  0;  O_O  =  0.0  :O in O_O
02:53:52 <xenoblitz> dolio: ah ok
02:53:58 <Gracenotes> for instance. a lovely expression
02:54:07 <xenoblitz> Gracenotes: hehe :)
02:54:21 <xenoblitz> dolio: thanks
02:54:29 <Gracenotes> well, except the uppercase. hm.
02:55:01 <Peaker> > let O=0;O_O=0.0:O in O_O
02:55:02 <lambdabot>   Not in scope: data constructor `O'Not in scope: data constructor `O_O'Not i...
02:55:13 <dolio> Colons are the only uppercase symbol, apparently. :)
02:55:30 <Saizan> mm_freak_: yeah, that's pretty confusing
02:55:32 <Gracenotes> > (.) <
02:55:33 <lambdabot>   <no location info>: parse error on input `;'
02:55:44 <Peaker> mm_freak_: I had that problem
02:55:46 <xenoblitz> btw is there a place in the haskell report where I can find info about this?
02:55:49 <Gracenotes> known more broadly as >.<
02:55:54 <mm_freak_> Peaker: could you solve it?
02:56:13 <Peaker> mm_freak_: Yeah, I removed all mentions of process 1.0.1.1, and had everything compiled against 1.0.1.0
02:56:29 <Peaker> mm_freak_: I think there were also issues of duplicate packages of same version installed in global and user dirs (see ghc-pkg --list)
02:56:40 <mm_freak_> do you think it won't work with 1.0.1.1?
02:56:43 <Peaker> oops, ghc-pkg list
02:56:47 <Saizan> xenoblitz: http://www.haskell.org/onlinereport/lexemes.html
02:57:05 <xenoblitz> Saizan: thanks saizan :)
02:57:21 <Peaker> mm_freak_: ghc-6.10.1 itself is compiled against process-1.0.1.0, and a lot of dependencies also are. You can't change that, so if you have some stuff compiled with 1.0.1.1, you can't compile those things together because of their conflicting versions
02:57:34 <Peaker> mm_freak_: at least, that's what I gathered
02:57:54 <mm_freak_> k, thanks
02:58:21 <Saizan> the problem is that cabal thinks ghc depends both from process-1.0.1.1 and 1.0.1.0
02:58:24 <Peaker> mm_freak_: ghc-pkg unregister on any package you have in your user installation that is the exact same name/version as a global one
02:59:46 <xenoblitz> I am trying to write something like E ? E : E ... a ternary operator... so I replaced the reserved : with / and wrote it as E :?: E :/: E but ghc doesn't accept it
03:00:16 <quicksilver> xenoblitz: ops beginning with : are constructors.
03:00:30 <mib_3y34x6a6> I need help what is same as facts = [1,1,2,6,24,120,: : :], facts = 1 : zipWith (*) [1..] (tail facts) or  facts = 1 : zipWith (*) [1..] facts
03:00:42 <xenoblitz> quicksilver: yeah I'm integrating the operator in a data type I am using
03:00:53 <xenoblitz> quicksilver: as a constructor
03:01:06 <EvilTerran> mib_3y34x6a6, have you tried them?
03:01:09 <quicksilver> :?: and :/: should both be legal construtors.
03:01:29 <EvilTerran> mib_3y34x6a6, you should be able to work this out for yourself
03:01:45 <vixey> hehe
03:01:51 <xenoblitz> quicksilver: it seems to be accepting the :?: but not the :/:
03:02:05 <vixey> I wrote a function which enumerates every object of a arbitrary functor
03:02:11 <quicksilver> xenoblitz: you're going to need to give us more to work on.
03:02:14 <vixey> without using typeclasses
03:02:23 <quicksilver> xenoblitz: 'doesn't accept' 'seems to be accepting' don't help me none.
03:02:23 <xenoblitz> the error I am getting is "parse error on input ':/:'
03:02:25 <EvilTerran> vixey, orly?
03:02:30 <quicksilver> xenoblitz: paste the code.
03:02:46 <vixey> -- > take 10 $ everything both "!?"
03:02:46 <vixey> -- ['!' :&: '!','!' :&: '?','?' :&: '!','?' :&: '?']
03:02:56 <vixey> -- ['!' :&: '!','!' :&: '?','?' :&: '!','?' :&: '?']
03:02:56 <vixey> -- > take 10 $ everything tree "!?"
03:02:56 <vixey> -- [Leaf '!',Leaf '?',Branch (Leaf '!') (Leaf '!'),Branch (Leaf '!') (Leaf '?'),...
03:03:13 <EvilTerran> er
03:03:21 <vixey> that's an example of it running
03:03:24 <xenoblitz> quicksilver: http://hpaste.org/13672
03:03:36 <quicksilver> xenoblitz: that is nonsense.
03:03:43 <quicksilver> xenoblitz: operators are binary by definition.
03:03:52 <vixey> xenoblitz, you should use GADTs like me :p
03:03:53 <quicksilver> xenoblitz: you can't have two constructors in one case
03:04:14 <xenoblitz> quicksilver: ok ok :/
03:04:51 <vixey> xenoblitz, are you planning on writing an eval on that data?
03:05:02 <xenoblitz> vixey: no i am experimenting with phantom types
03:05:09 <vixey> ?? no you aren't
03:05:10 <lambdabot>  no you aren't
03:05:31 <vixey> this is a normal ADT ...
03:06:16 <xenoblitz> vixey: am working on it
03:06:45 <xenoblitz> quicksilver: oh and I didn't know operators are binary by definition
03:06:45 <namin> An odd question: is it possible to evaluate a untypeable expression? Say a simple lambda-calculus term that's a valid untyped term but has an occur check type error?
03:06:54 <quicksilver> xenoblitz: yes, I assumed you didn't ;)
03:07:08 <Saizan> xenoblitz: you could use a prefix constructor and then define operators to get the nice syntax
03:07:16 <quicksilver> xenoblitz: there are tricks to fake trinary syntax
03:07:19 <vixey> xenoblitz, but if you want to write functions (as opposed to methods) that operate on it you should use GADT instead of phantom types
03:07:20 <quicksilver> FSOV 'fake'
03:07:27 <vixey> namin, yes it's just that it might not terminate
03:07:48 <vixey> namin, for example, (\u -> u u) (\v -> v v) ~> (\v -> v v) (\v -> v v) ~~> (\v -> v v) (\v -> v v)
03:07:48 <xenoblitz> quicksilver, Saizan: i see :)
03:08:13 <vixey> namin, did you mean _in haskell_ ? :p
03:08:21 <vixey> namin, I think I maybe misunderstood you
03:08:23 <namin> vixey: yup, in Haskell :)
03:08:34 <xenoblitz> vixey: I need phantom types but I'll check out GADT :)
03:08:49 <vixey> namin, then with: data Lam = Lam (Lam -> Lam)
03:08:57 <EvilTerran> Mu Endo!
03:08:59 <vixey> xenoblitz, kinda doubt it..
03:09:11 <namin> vixey: I guess I am looking for an evaluator for a subset of Haskell which doesn't do typechecking.
03:09:40 <vixey> or
03:09:44 <vixey> data Lam = App Lam Lam | Lam (Lam -> Lam)
03:09:52 <EvilTerran> namin, unfortunately, with typeclasses, we have values dependent on types
03:10:17 <vixey> namin: then you can write  eval (Lam f) = Lam f ; eval (App m n) = app (eval m) n where app (Lam f) x = f x ; app m n = App m n
03:10:19 <xenoblitz> vixey: you're not the first person who tried to convert me away from phantom types... are they that spookey?
03:10:21 <EvilTerran> namin, so an untypable program may be unevaluatable for that reason too
03:10:35 <vixey> namin, which gives you untyped lambda calculus
03:10:52 <vixey> xenoblitz, I don't know what it is you would do with phantom types that wouldnt' be done better with a GADT
03:11:15 <EvilTerran> vixey, aren't phantom types still involved in the GADT method?
03:11:18 <namin> vixey: makes sense :) but i'd like to be able to experiment with untyped lambda calculus using Haskell syntax.
03:11:27 <vixey> namin,  too bad
03:11:31 <xenoblitz> vixey: ok I'll check them out... might convert the "higher-powers" as it where
03:11:35 <vixey> namin, unless you like writing unsafeCoerce
03:11:48 <namin> ok, I imagined this much.
03:11:54 <vixey> xenoblitz, what?
03:12:33 <vixey> namin, btw  it's   App (Lam (\u -> App u u)) (Lam (\u -> App u u))  for the example before
03:12:58 <vixey> namin, and you could add primitive types and stuff easily
03:13:11 <Saizan> phantom types are orthogonal from gadts
03:13:44 <Saizan> i.e. you can or not use gadt syntax when using phantom types and it doesn't change anything
03:14:36 <namin> vixey: got it. hmm.
03:14:58 <xenoblitz> Saizan: so powerwise they are the same but the syntax is different? or did i just misunderstand?
03:15:17 <Saizan> xenoblitz: gadts give you extra power
03:15:23 <lilac> xenoblitz: FWIW, "data Q = E :?: E; data E = ... | Q :/: E | ..."
03:15:24 <namin> I guess I'll just implement an untyped lambda calculus with Haskell syntax. Unless someone knows of one already?
03:15:37 <namin> Sometimes, I like to experiment with untypeable ideas.
03:15:51 <namin> While, I am already all deep in Haskell.
03:16:06 <xenoblitz> lilac: thanks :)
03:16:12 <vixey> data E ty where
03:16:21 <vixey>   IF :: E Bool -> E a -> E a -> E a
03:16:25 <namin> Is there a library to parse Haskell in Haskell?
03:16:30 <vixey>   (:+:) :: E Int -> E Int -> E Int
03:16:32 <quicksilver> haskell-src-exts
03:17:01 <vixey> xenoblitz, ^ that, is exactly what you could already do with phantom types
03:17:09 <namin> quicksilver: thanks :)
03:17:17 <hugo___> hello
03:17:22 <vixey> xenoblitz, the difference is that when you pattern match on a GADT constructor, you get extra type info from the match
03:17:26 <vixey> (specialization)
03:17:34 <xenoblitz> i c
03:17:44 <lilac> vixey: you can't do the ST trick with GADTs (right?)
03:17:46 <xenoblitz> instead I guess I would define a function to do so myself
03:18:07 <quicksilver> I find these concepts hard to compare.
03:18:08 <vixey> with phantom types you'd program using methods and typeclass dispatch
03:18:11 <quicksilver> they're completely orthogonal.
03:18:15 <lilac> vixey: re: things you would do with phantom types which wouldn't be done better with a GADT
03:18:18 <vixey> whereas with GADTs you can use functions and pattern matching
03:18:25 <quicksilver> phantom types are an obvious consequence of the h98 type system
03:18:31 <quicksilver> they're not "anything special"
03:18:36 <vixey> lilac, I'm saying that GADTs subsume everything phantom types did
03:18:48 <lilac> vixey: and i'm saying, how would you do ST with GADTs?
03:19:02 <lilac> that is, /without/ a phantom type
03:19:12 <vixey> btw
03:19:19 <vixey> my example E abov
03:19:32 <vixey> I don't consider that a phantom type, because it's defined using a GADT
03:19:51 <quicksilver> well that's daft.
03:19:56 <vixey> so maybe my meaning of phantom type is more specific than yours
03:20:03 <quicksilver> phantom types are still phantom, using the GADT syntax doesn't change that
03:20:13 <quicksilver> a phantom type is one which doesn't occur in the data constructor
03:20:15 <vixey> quicksilver, it does have different semantics
03:20:22 <vixey> quicksilver, regarding pattern match specialization
03:20:26 <quicksilver> they're orthogonal!
03:20:33 <vixey> what's orthogonal?
03:20:37 <quicksilver> GADTs have semantics w.r.t pattern matches, sure
03:20:40 <quicksilver> that's the point of GADTS
03:20:46 <quicksilver> this is totally irrelevant to phantoms though
03:20:50 <vixey> no it's relevant
03:20:54 <lilac> vixey: suppose we accept your more specific notion of phantom types. how do you do ST with GADTs, without your notion of phantom types?
03:20:59 <vixey> it opens up a new class of functions you can write
03:21:04 <quicksilver> yes.
03:21:04 <xenoblitz> ok i just started an argument :S
03:21:06 <quicksilver> GADTs are clever.
03:21:07 <quicksilver> I agree.
03:21:14 <quicksilver> GADTs ahev NOTHING AT ALL to do with phantom types.
03:21:15 <quicksilver> Nothing.
03:21:18 <quicksilver> Diddly squat.
03:21:23 <quicksilver> They are two orthogonal things.
03:21:23 <vixey> quicksilver, agreed
03:21:27 <quicksilver> It's common to use them together.
03:21:31 <quicksilver> It's also common to use them apart.
03:22:07 <quicksilver> the 'typed interpreter' GADT stuff tends not to be 'entirely' phantom
03:22:17 <quicksilver> because there tends to be a concrete base constructor
03:22:26 <quicksilver> which actually does use the type in a concrete way.
03:22:30 <vixey> quicksilver, right, so I think it's a worthewhile distinction to make
03:23:01 <vixey> esp. with different semantics and idioms
03:23:19 <Saizan> there's a worthwile distinction between phantom and non-phantom types/parameters
03:23:45 <Saizan> the fact that you're using them in a GADT doesn't change that distinction
03:23:57 <xenoblitz> any references to GADTs? Papers I mean.
03:23:57 <gour> @tell CosmicRay are forums/trackers at http://software.complete.org/ right place for asking questions/reporting problems?
03:23:57 <lambdabot> Consider it noted.
03:24:20 <vixey> Saizan, it does change the meaning of the types though
03:25:19 <Saizan> if you're using the refinement part of gadts, sure
03:26:18 <Saizan> xenoblitz: http://en.wikibooks.org/wiki/Haskell/GADT
03:27:03 <xenoblitz> Saizan: already there... thanks though
03:29:12 <xenoblitz> Saizan: would like a paper on the matter though
03:29:43 <Gracenotes> an interesting observation in TAPL: there are no unsafe dynamically checked type systems. Oooh, this is gonna be fun.
03:30:08 <Saizan> xenoblitz: http://citeseerx.ist.psu.edu/showciting;jsessionid=51209716C810B62598567022CB423835?cid=229818
03:30:28 <xenoblitz> Saizan: you the man :)
03:33:09 <Saizan> xenoblitz: this also looks relevant to what you're writing http://augustss.blogspot.com/2007/06/representing-dsl-expressions-in-haskell.html
03:35:00 <vixey> "the evaluator now needs a typed environment" -- that would be interesting to see
03:35:58 <vixey> how would you relate the name/index of the variable to a type ?
03:39:04 <Saizan> something with Dynamic? or ST?
03:41:33 <zoq> ouss:
03:41:50 <zoq> oops
03:42:12 <loscar> can someone please tell me why: "type Name = String" gives me an error when entered in the prelude REPL?
03:42:54 <quicksilver> loscar: because the repl doesn't support definitions
03:43:04 <quicksilver> it's an expression evaluator primarily
03:46:56 <loscar> quicksilver: so i need to go through a compile phase to try out new definitions? (which I find a bit long)
03:47:18 <quicksilver> No.
03:47:21 <vixey> for bidirectional typechecking,  is it sensible use a Prolog/Mercury/Curry style?
03:47:30 <quicksilver> the interpreter can load a .hs file directly.
03:47:42 <quicksilver> and your editor should have a keybinding to do that.
03:48:18 <Saizan> or you can just use :r
03:55:06 <vixey> @w80 subsumption
03:55:07 <lambdabot> *** "subsumption" wn "WordNet (r) 2.0"
03:55:07 <lambdabot> subsumption
03:55:07 <lambdabot>      n 1: the premise of a syllogism that contains the minor term
03:55:07 <lambdabot>           (which is the subject of the conclusion) [syn: {minor
03:55:07 <lambdabot>           premise}, {minor premiss}]
03:55:09 <lambdabot>      2: incorporating something under a more general category
04:06:23 <cads> I am the eggman
04:06:28 <cads> they are the eggmen
04:06:34 <cads> I am the walrus!
04:06:40 <cads> can I has mah bucket?
04:07:13 * cads braces himself to be pelted with sharp things
04:07:24 * mornfall splashes water at cads.
04:07:26 <swin> \quit
04:07:28 <mornfall> (From a bucket.)
04:07:49 <mornfall> Here, your bucket.
04:07:54 <cads> MaH buckit! :D
04:08:03 <cads> the saga has end.
04:09:32 <quicksilver> your bukkit has been recycled
04:09:36 <quicksilver> it is now lambdas.
04:10:16 <osfameron> o/ there's a hole in my lambda, dear Liza dear Liza o/
04:19:01 <loscar_> Is there a key binding in emacs that will automatically compile, run my haskell file and print the output in a buffer?
04:26:55 <namin> how do I use lambdabot over IRC?
04:27:27 <dolio> > 12345
04:27:28 <lambdabot>   12345
04:27:44 <namin> ok, that easy
04:27:49 <namin> > 1 + 1
04:27:50 <lambdabot>   2
04:28:17 <elbar> > print "Hello world!"
04:28:19 <lambdabot>   * Exception: "<IO ()>"
04:28:22 <elbar> gah
04:28:36 <elbar> hax..cheats...buhhh =)
04:28:57 <arw> > show "Hello World!"
04:28:59 <lambdabot>   "\"Hello World!\""
04:29:13 <elbar> > putStrLn "hi"
04:29:14 <lambdabot>   * Exception: "<IO ()>"
04:29:15 <arw> lambdabot doesn't do IO, but evaluates strings.
04:29:37 <arw> so you can do 'show', but 'print' and stuff won't work.
04:29:45 <elbar> aye
04:32:12 <namin> cool, thanks all, i'll play a little in private :)
04:34:40 <namin> any thoughts on pointless refactoring?
04:34:41 <namin> @pointless k f g x y z = f (g x y z)
04:34:41 <lambdabot> k = (.) . (.) . (.)
04:35:46 <dolio> Sometimes it's good, sometimes it's bad.
04:37:16 <lchaplin> i don't wanna say anything, but k looks like tits from total recall.
04:38:20 <namin> does @free only work with already defined functions?
04:38:36 <dolio> @free foo :: (a -> b) -> b -> a
04:38:37 <lambdabot> g . h = k . f => f . foo h = foo k . g
04:38:38 <vixey> namin, it works on types
04:38:50 <namin> ah! thanks
04:43:54 * mnislaih is looking for any pointers on computing the width of a poset (minimal number of elements in its chain decomposition)
04:44:53 <namin> @pointfull (.(.(.(.f))))
04:44:54 <lambdabot> (\ d h -> d (\ k -> h (\ n -> k (\ q -> n (f q)))))
04:48:48 <Stephan202> @pl (\ d h -> d (\ k -> h (\ n -> k (\ q -> n (f q)))))
04:48:49 <lambdabot> (. (. (. (. f))))
04:52:57 <namin> I was puzzled by composing compositions yesterday. Matt Hellige gave a really insightful answer in terms of argument and result.
04:53:09 <namin> See http://lambda-the-ultimate.org/node/3150
05:14:10 <dcoutts> @seen benl23
05:14:10 <lambdabot> benl23 is in #haskell. I don't know when benl23 last spoke.
05:15:13 <Saya> @help
05:15:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:15:20 <Saya> @list
05:15:20 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
05:21:21 <PHO_> @seen PHO_
05:21:22 <lambdabot> You are in #haskell. I last heard you speak just now.
05:25:23 <EvilTerran> @seen
05:25:37 <PHO_> @seen lambdabot
05:25:38 <lambdabot> Yes, I'm here. I'm in #novalang, ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosxdev, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #
05:25:38 <lambdabot> haskell.it, #haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, #haskell-freebsd, ##freebsd, #gentoo-uy, #gentoo-
05:25:38 <lambdabot> haskell, #friendly-coders, #dreamlinux-es, #concatenative, #arch-haskell, #functionaljava, #darcs, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
05:25:49 <EvilTerran> huh... lambdabot pm'd me when i did that
05:25:52 <EvilTerran> "<lambdabot> Lately, I have seen adiabatty, arnaldocapo, bartden, br1, elgrande, elpolilla, evilterran, idnar, johnnowak, mornfall, olsner_, pho_, prunedtree, saya and tizoc."
05:26:10 <PHO_> heh
05:26:12 <johnnowak> lambdabot is a menace to society
05:26:17 <EvilTerran> it's stalking us!
05:26:21 <EvilTerran> <.<  >.>
05:26:47 <Saizan__> @seen
05:27:10 * EvilTerran notes, on reflection, that that was probably a pm so it wouldn't beep everyone it mentioned. oops.
05:27:42 <olsner_> EvilTerran: oops :)
05:27:54 <Saya> now it did
05:28:06 <MyCatVerbs> EvilTerran: meh, that rule's only ever really enforced in Werewolf games anyway.
05:28:21 <Saya> lambdabot is spreading over irc and soon it will control the whole interwebs
05:28:33 <idnar> what rule?
05:33:18 <PHO_> I just peeped at #haskell.jp, and found that the channel had been ruined.
05:33:33 <chessguy_work> ruined?
05:33:44 <PHO_> no one expect lambdabot was there.
05:33:47 <PHO_> except
05:33:57 <osfameron> nobody expects the lambdabot inquisition!
05:34:13 <PHO_> :)
05:35:16 <PHO_> too bad. I know there're very little haskell believers who speak japanese
05:38:41 <earthy> it's main weapon is @pl. @type and @pl. It's two main weapons are @type, @pl and @djinn. It's three main weapons are @type, @pl, @djinn and @hoogle. Amongst it's weapons are such diverse elements as...
05:39:21 <osfameron> a lazy approach would work very well here :-)
05:39:24 <earthy> and a fanatical devotion to the simons... :)
05:40:23 * PHO_ thinks about how "functional devotion" would be.
05:41:12 * EvilTerran is reminded of http://www.haskell.org/pipermail/haskell-cafe/2003-May/004343.html
05:45:09 <ciscbrain> I'm trying to convert a byte string to an array of Word64
05:45:19 <ciscbrain> this is the best I could come up with: http://hpaste.org/13676?lines=true
05:46:14 <ciscbrain> can anyone offer some advice :( ?
05:46:25 <quicksilver> ciscbrain: my first attempt would certainly not be the array version
05:46:50 <earthy> ciscbrain: there's a nice bit of code by oleg
05:46:58 <quicksilver> oh I see, you want an array.
05:47:29 <quicksilver> well I still wouldn't use the ST version most naturally
05:47:33 <quicksilver> although possibly it's faster
05:47:48 <earthy> http://okmij.org/ftp/Streams.html#random-bin-IO
05:47:50 <EvilTerran> should be able to express it with an immutable array
05:47:57 <roconnor> Are modules in Ocaml first-class, and what does that mean?
05:47:57 <ciscbrain> quicksilver: you mean use fromList?
05:48:06 <quicksilver> ciscbrain: yes, or arrayList or array
05:48:38 <ciscbrain> earthy: thanks
05:49:32 <earthy> ciscbrain: prepare to be brain-warped though
05:51:26 <ciscbrain> earthy: yeah, I've gotten used to that when reading stuff there :P
05:51:42 <blackh> I am having trouble catching new style exceptions (Control.Exception) in a CGI app.  CGI uses OldException which apparently will not catch new-style exceptions.  There just doesn't seem to be any way to catch new exceptions without lifting into an IO-only context.  Has anyone encountered this?
05:55:17 <Saizan__> does it have something like catchDyn?
05:56:03 <blackh> Saizan__: I thought about that but unfortunately no.  I'll hack this into the cgi package and see if it works.
05:56:09 <quicksilver> blackh: I think that's probably only fixable if you wrap your own stuff
05:56:21 <quicksilver> (with a catch which catches all newstype exceptions and rethrows it as an oldstyle)
05:56:37 <quicksilver> the better fix is for CGI to be fixed to support newstyle.
05:56:45 <quicksilver> and lets hope the exceptions api doesn't change again :)
05:56:52 <Saizan__> btw, which exceptions aren't catchable with Control.OldException.catch?
05:57:07 <blackh> Saizan__: My own ones.
05:57:34 <blackh> quicksilver: If I am hacking cgi, I might as well fix it properly.
05:57:54 <quicksilver> Control.OldException only catches things of type "Control.OldException.Exception"
05:58:04 <quicksilver> so it won't catch anything from the new hierarchy AFAIK?
05:58:17 <quicksilver> blackh: my suggestion did not involve hacking cgi.
05:58:26 <quicksilver> blackh: it involved invoking it via a wrapper.
05:58:29 <Saizan__> i thought they'd get wrapped in DynException Dynamic
05:58:45 <quicksilver> Saizan__: I thought not. But I don't know. Perhaps someone should test it ;)
05:59:52 <blackh> quicksilver: Your wrapping idea might just work for me, but it'd be a bit nasty since CGI doesn't support catchDyn.
06:00:17 <PHO_> ooooh, I didn't know that catchDyn has gone. I'm thrilled!
06:01:37 <blackh> quicksilver: Do you know whether the new Control.Exception catches the old style exceptions?
06:02:09 * PHO_ is adding a task for him to rewrite his old code which uses DynException
06:02:49 <quicksilver> blackh: I would imagine not, because they don't implement Exception e =>
06:04:09 <blackh> Saizan__: I don't know whether my new exceptions are turning into catchDyn ones, because CGI doesn't give access to catchDyn.
06:04:22 <blackh> quicksilver: I'd love to fix cgi properly, but I am a little afraid to open a can of worms.
06:04:26 * quicksilver nods
06:04:53 <DIGGTHIS> FELLOW INTERNET USERS, THOSE WHO HAVE DIGG ACCOUNTS. I BEG OF YOU TO DIGG THIS ARTICLE, WE HAVE UNCOVERED INJUSTICE ON THE INTERNET http://digg.com/people/Spread_the_word_to_UCLA_student_about_cheating_girlfriend
06:04:53 <DIGGTHIS> FELLOW INTERNET USERS, THOSE WHO HAVE DIGG ACCOUNTS. I BEG OF YOU TO DIGG THIS ARTICLE, WE HAVE UNCOVERED INJUSTICE ON THE INTERNET http://digg.com/people/Spread_the_word_to_UCLA_student_about_cheating_girlfriend
06:04:54 <DIGGTHIS> FELLOW INTERNET USERS, THOSE WHO HAVE DIGG ACCOUNTS. I BEG OF YOU TO DIGG THIS ARTICLE, WE HAVE UNCOVERED INJUSTICE ON THE INTERNET http://digg.com/people/Spread_the_word_to_UCLA_student_about_cheating_girlfriend
06:04:55 <DIGGTHIS> FELLOW INTERNET USERS, THOSE WHO HAVE DIGG ACCOUNTS. I BEG OF YOU TO DIGG THIS ARTICLE, WE HAVE UNCOVERED INJUSTICE ON THE INTERNET http://digg.com/people/Spread_the_word_to_UCLA_student_about_cheating_girlfriend
06:05:22 <blackh> DIGGTHIS: Try a forum with a lower average IQ
06:05:32 <DIGGTHIS> FELLOW INTERNET USERS, THOSE WHO HAVE DIGG ACCOUNTS. I BEG OF YOU TO DIGG THIS ARTICLE, WE HAVE UNCOVERED INJUSTICE ON THE INTERNET http://digg.com/people/Spread_the_word_to_UCLA_student_about_cheating_girlfriend
06:05:33 <DIGGTHIS> FELLOW INTERNET USERS, THOSE WHO HAVE DIGG ACCOUNTS. I BEG OF YOU TO DIGG THIS ARTICLE, WE HAVE UNCOVERED INJUSTICE ON THE INTERNET http://digg.com/people/Spread_the_word_to_UCLA_student_about_cheating_girlfriend
06:05:35 <DIGGTHIS> FELLOW INTERNET USERS, THOSE WHO HAVE DIGG ACCOUNTS. I BEG OF YOU TO DIGG THIS ARTICLE, WE HAVE UNCOVERED INJUSTICE ON THE INTERNET http://digg.com/people/Spread_the_word_to_UCLA_student_about_cheating_girlfriendFELLOW INTERNET USERS, THOSE WHO HAVE DIGG ACCOUNTS. I BEG OF YOU TO DIGG THIS ARTICLE, WE HAVE UNCOVERED INJUSTICE ON THE INTERNET http://digg.com/people/Spread_the_word_to_UCLA_student_about_cheating_girlfriend
06:05:36 <DIGGTHIS> FELLOW INTERNET USERS, THOSE WHO HAVE DIGG ACCOUNTS. I BEG OF YOU TO DIGG THIS ARTICLE, WE HAVE UNCOVERED INJUSTICE ON THE INTERNET http://digg.com/people/Spread_the_word_to_UCLA_student_about_cheating_girlfriend
06:05:37 <DIGGTHIS> FELLOW INTERNET USERS, THOSE WHO HAVE DIGG ACCOUNTS. I BEG OF YOU TO DIGG THIS ARTICLE, WE HAVE UNCOVERED INJUSTICE ON THE INTERNET http://digg.com/people/Spread_the_word_to_UCLA_student_about_cheating_girlfriend
06:05:39 <Lemmih> ?where ops
06:05:39 --- mode: ChanServ set +o quicksilver
06:05:40 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
06:05:40 <DIGGTHIS> FELLOW INTERNET USERS, THOSE WHO HAVE DIGG ACCOUNTS. I BEG OF YOU TO DIGG THIS ARTICLE, WE HAVE UNCOVERED INJUSTICE ON THE INTERNET http://digg.com/people/Spread_the_word_to_UCLA_student_about_cheating_girlfriend
06:05:42 <PHO_> DIGGTHIS is the first spammer I've ever seen in this channel.
06:05:43 <DIGGTHIS> FELLOW INTERNET USERS, THOSE WHO HAVE DIGG ACCOUNTS. I BEG OF YOU TO DIGG THIS ARTICLE, WE HAVE UNCOVERED INJUSTICE ON THE INTERNET http://digg.com/people/Spread_the_word_to_UCLA_student_about_cheating_girlfriend
06:05:43 --- mode: quicksilver set +b *!*=DIGGTHIS@124.189.113.*
06:05:43 --- kick: DIGGTHIS was kicked by quicksilver (quicksilver)
06:05:50 <cizra> Whew
06:05:51 <cizra> thanks
06:06:01 <cizra> PHO_: Not the first I've seenâ€¦
06:06:04 <quicksilver> how the hell did he not get flooded and K-lined?
06:06:31 <lilac> FELLOW INTERNET USERS, THERE IS INJUSTICE IN THE INTERWEBS! THERE'S NOT ENOUGH SHOUTING ON #haskell! WE MUST REDRESS THE BALANCE!
06:06:40 <quicksilver> blackh: I'm told by JaffaCake that the 'OldException' compatibility layer takes the effort to convert back and forth the 'standard' set of exceptions.
06:06:49 <quicksilver> blackh: but will completely ignore any custom-defined ones.
06:07:21 <PHO_> lilac: BUT LAMBDABOT WILL ARREST YOU IF YOU SHOUT LIKE THAT
06:07:46 * EvilTerran buries
06:08:02 <EvilTerran> (take that, spammers! :P)
06:08:43 <lilac> PHO_: Not in scope: data constructor `BUT'
06:09:34 <blackh> quicksilver: Aha! Thanks for that info. I'll try fixing cgi properly - you never know - it might even work.
06:09:53 <quicksilver> blackh: it looks like there might be a bug.
06:10:15 <quicksilver> blackh: Igloo is going to put together a bug report, I'll let you know. You can add your comments if you like when I have it.
06:11:18 <blackh> quicksilver: OK. What is the nature of this bug?
06:13:25 <fasta> Has everyone seen http://www.reddit.com/r/haskell/comments/7nhih/bridging_python_and_haskell_sharing_recursive/ already?
06:13:41 <quicksilver> blackh: http://hackage.haskell.org/trac/ghc/ticket/2913
06:14:13 <enticingjelly> the world will end with continuations. mark my words.
06:15:10 <allbery_b> as it began with continuations
06:16:28 <jeltsch> Hello, does anyone know when Gtk2Hs will be released? If it is within the next few hours, I might wait with an installation.
06:17:31 <blackh> quicksilver:  My experience was that catchCGI (which uses 'try') wasn't catching them.  I haven't tried catchDyn.  The other thing I'm not clear about is whether a dynamic exception is supposed to be caught by catchCGI.
06:17:33 <quicksilver> enticingjelly: does ending matter as long as we still havea  continuation.
06:17:49 <quicksilver> @hoogle try
06:17:49 <lambdabot> Control.Exception try :: IO a -> IO (Either Exception a)
06:17:49 <lambdabot> System.IO.Error try :: IO a -> IO (Either IOError a)
06:17:49 <lambdabot> Text.Parsec.Prim try :: Stream s m t => ParsecT s u m a -> ParsecT s u m a
06:18:02 <blackh> quicksilver: ...I meant to say ... is supposed to be caught by 'try'/
06:18:09 <enticingjelly> quicksilver, but therein lies the problem. what do you do with a continuation if nobody calls it.
06:18:14 <quicksilver> blackh: yes, try is supposed to catch everything.
06:18:24 <quicksilver> blackh: so that falls under this bug.
06:18:40 <quicksilver> it's deprecated for general use
06:18:44 <quicksilver> (catching everything isn't safe)
06:18:51 <quicksilver> but it's handy for things like CGI
06:18:54 <quicksilver> (application servers etc)
06:19:10 <jeltsch> More precisely: When GHC 0.10.0 will be released. Someone on the user list said a release should happen at the beginning of the week.
06:19:26 <jeltsch> No, Gtk2Hs 0.10.0.:-/
06:19:39 <blackh> quicksilver: In that case, having this bug fixed would solve my problem.  My code is only catching one exception type, but it just whizzes straight past.
06:19:43 <gnuvince_> GHC 0.10.0?  Did they have type classes then?
06:20:05 <jeltsch> gnuvince_: Gtk2Hs 0.10.0.
06:20:56 <jeltsch> gnuvince_: Donâ€™t know whether there was a GHC 0.10.0 at all or whether they started with 1.0. Was it already typical at that time to have 0.x version numbers?
06:21:23 <gnuvince_> Too green and wet behind the ears with Haskell to know
06:21:57 <blackh> Thank you very much for your kind assistance, Mr. quicksilver sir!
06:22:08 <quicksilver> blackh: that's Dr. quicksilver to you. :P
06:27:13 <cjs> Thank you, Herr Doktor Mister Quicksilver Esq., Sir!
06:28:26 <chessguy_work> jeltsch, you might ping dcoutts_ about that one
06:28:51 <chessguy_work> though if they're about to release, he's probably pretty busy :)
06:30:27 <dcoutts_> @yarr!
06:30:28 <lambdabot> I want me grog!
06:31:03 <dcoutts_> jeltsch: ask pgavin about the gtk2hs release, he's the release manager these days
06:31:03 <lambdabot> dcoutts_: You have 1 new message. '/msg lambdabot @messages' to read it.
06:31:46 <sampointon> is anyone using existential constructors, MPTCs and overlapping instances together successfully? I'm getting some unexpected results -- http://hpaste.org/13677 has a demonstration of exactly what I mean
06:33:18 <quicksilver> overlapping instances are broken, don't use them.
06:35:25 <Cale> They're not as bad as incoherent instances :)
06:35:26 <lambdabot> Cale: You have 3 new messages. '/msg lambdabot @messages' to read them.
06:36:00 <quicksilver> sampointon: it cannot correctly select the instance for the thing buried inside the existential.
06:36:09 <quicksilver> becase instance selection happens at compile time.
06:36:22 <quicksilver> and the exact type of the existential is not known
06:36:32 <quicksilver> well, not at compile time or run time, really.
06:36:40 <Cale> Uh, also, instance selection is based only on the instance head and *not* the class context.
06:36:53 <dcoutts_> @localtime benl23
06:36:54 <lambdabot> Local time for benl23 is Wed Jan  7 01:36:53 2009
06:36:59 <quicksilver> the above is the long version of "overlapping instances are broken"
06:37:08 <quicksilver> for a rule of thumb check the following:
06:37:27 <dolio> Cale: Is that true with overlapping instances?
06:37:44 <Cale> dolio: Yes, I believe so.
06:37:47 <dolio> I thought that switched on some kind of more fancy constraint solver.
06:37:53 <dolio> Maybe I'm making things up, though.
06:38:23 <quicksilver> Are you Oleg? If YES -> You may use overlapping instances. If NO -> Overlapping instances are not the solution to the problem at hand. Please try again.
06:38:53 <sampointon> okay, so I guess I'll have to use a different method of simulating multimethods, most likely just using pattern matching. I wanted to do it this way because it's easy to split up definitions across files
06:39:14 <quicksilver> dolio: I think overlapping instances turns on "most specific match" on the concrete type.
06:39:18 <Cale> The trouble is that you can always have a future instance of a class.
06:39:21 <quicksilver> dolio: so [Char] matches ahead of [a].
06:39:24 <Cale> (classes are open)
06:39:26 <dolio> Yeah.
06:39:34 <quicksilver> dolio: but makes no change to the use (or otherwise) of contexts.
06:39:50 <Cale> So there's no way to tell definitively that a type is *not* an instance of any given class.
06:39:51 --- mode: quicksilver set -o quicksilver
06:39:54 <dolio> Yeah, I'm not sure what I was thinking. Just wild fantasies, I guess. :)
06:40:12 <sampointon> or else find some different way of keeping a list of arbitrary GameObjects
06:40:22 <quicksilver> dolio: there are ways to tease GHC into doing more involved instance search, but they're more complicated than this.
06:40:36 <quicksilver> they involve HTrue/HFalse and stuff like that.
06:41:05 <quicksilver> sampointon: you may consider putting the receiver instance into GameObject
06:41:26 <quicksilver> or making your existential box (Receiver a,GameObject a) => B a
06:41:32 <Cale> sampointon: Currently, your "Boxed" type is isomorphic to String
06:41:36 <Guenni> how can I fire off an "attach database" with HDBC.Sqlite3?
06:41:38 <quicksilver> so that the 'correct' receiver instance is boxed up along with the object.
06:41:52 <quicksilver> (I know yours is two-parameter, I was simplifying slightly)
06:42:02 <blackh> quicksilver: Does this test case seem reasonable? http://hpaste.org/13678
06:42:06 <Cale> Because it forgets the type 'a', and only remembers that it's an instance of GameObject, which only has the name method.
06:42:34 <vixey> hi
06:42:39 <Cale> and so when you pattern match against (B x), the only thing you can do with x is get its name, which is a String
06:43:04 <quicksilver> blackh: I think so.
06:46:16 <chessguy_work> dcoutts_, sorry about that
06:46:28 <dcoutts_> chessguy_work: np
06:50:30 <vixey> what polytypic programs are mostly useful in haskell?
06:51:04 <chessguy_work> polytypic programs?
06:55:26 <quicksilver> vixey: "show" is pretty useful.
06:55:43 <quicksilver> so is (==)
06:56:01 <chessguy_work> woul you call those "programs" though?
06:56:08 <Cale> I would :)
06:56:09 <quicksilver> no, it's the program that generates them
06:56:15 <quicksilver> (ghc's deriving mechanism)
06:56:18 <vixey> btw
06:56:18 <quicksilver> which is the polytype
06:56:43 <vixey> Is it easy to wrwite (==) using primRec (like fold + pred)
06:56:50 <quicksilver> or hmm. No. show and (==) are polytypic themselves.
06:56:57 <quicksilver> at least, idealised versions of them are.
06:57:09 <vixey> it seems straightforward, ish..
06:58:45 <cads> chessguy, I challenge you in a game of chess!!!
06:59:01 <cads> when you are free
06:59:12 <cads> forget not this challenge
06:59:49 <chessguy_work> that's so tempting. it would be so hard for me to find a game of chess on the internet if i wanted one....oh wait, never mind
07:00:39 <cads> hey, i was serious
07:01:08 <cads> one thing is a completely anonymous game, and another is an anonymous game with someone from an irc channel you idle on
07:01:33 <cads> ahem, are a semi-regular on
07:01:53 <chessguy_work> heh
07:01:57 <EvilTerran> ... where's that graph of irc channels and users again?
07:01:59 <vixey> primRecList nil cons [] = nil ; primRecList nil cons (x:xs)  =cons x xs (primRecList nil cons xs)
07:02:20 <chessguy_work> i was serious too - if i wanted a game there are far better ways to get them than accepting random challenges from an irc person
07:03:12 <vixey> tod == top = primRecList (primRecList True (\_ _ _ -> False)) (\x xs ys -> primRecList False (\u us vs -> x == u && ???))
07:03:18 <vixey> the recursion doesn't make sense
07:03:36 <vixey> maybe it is just not the right tool (primRec)
07:03:49 <EvilTerran> vixey, are you trying to do something zip-like?
07:04:03 <vixey> trying to write (==) using primRec
07:04:16 * cads doesn't know where he went wrong in shouting out a challenge to a stranger :D
07:04:29 <cads> but maybe some other time
07:04:49 <blackh> cads
07:05:13 <EvilTerran> vixey, well, that strikes me as related to "zipWith (==)" in a way; someone may already have worked out how to do zip with fold
07:05:22 <blackh> : chessguy is just afraid, that's all.
07:05:26 <EvilTerran> *zip with primRec
07:05:50 <vixey> ok
07:06:00 <cads> blackh, oh i know
07:06:01 <EvilTerran> just thinking out loud :P
07:06:15 <vixey> what tool is better than primRec or folds for writing zip/(==) style programs?
07:06:18 <fasta> What's the ghci option which you can use to disable the printing of all the foralls when you ask for the type of a function?
07:06:44 <chessguy_work> cads, blackh : if it makes you feel better to think that, i could frankly care less
07:07:20 <vixey> actually I guess that just  list nil cons [] = nil ; list nil cons (x:xs) = list x xs + fix  is the perfect combination
07:07:31 <vixey> you can write anything in that way
07:07:34 <cads> chessguy_work, I jest, c'mon.. don't be so serious
07:07:49 <chessguy_work> here's an idea, how about we get back on-topic
07:08:09 <chessguy_work> what a novel concept
07:08:39 <vixey> chessguy_work: was I being off topic?
07:08:47 <chessguy_work> vixey, no, not you
07:08:50 <wchogg> chessguy_work : are you sure we can't ease ourselves back into talking about Haskell?  Like, could we start by complaining about the records system?
07:09:02 <chessguy_work> wchogg, haha, that souns good to me :)
07:09:04 <maltem> Nice, the GPU/DPH draft is out
07:09:23 <wchogg> I know!  I just I had the paper to show people 3 years ago.
07:09:26 <chessguy_work> wchogg, PCI would be a nice on-topic discussion too :)
07:09:28 <wchogg> *I just -wish-
07:09:56 <chessguy_work> have you been able to get a spot on code.haskell yet?
07:10:24 <wchogg> chessguy_work : They haven't e-mailed me back confirming that its approved.  I might badger someone about it later today.
07:10:31 <chessguy_work> ok
07:10:47 <chessguy_work> i'm hoping to have time to pick up my book over lunch today
07:10:47 <maltem> I just wonder when the code is supposed to get real
07:11:04 <wchogg> maltem : ?
07:11:15 <blueonyx> is this gpu/dph paper public somewhere?
07:11:26 <maltem> wchogg: I mean all there is to taste is the paper draft, until now
07:11:40 <maltem> blueonyx: http://www.cse.unsw.edu.au/~chak/papers/LCGK09.html
07:11:44 <wchogg> http://www.cse.unsw.edu.au/~chak/papers/LCGK09.html
07:11:49 <blueonyx> ah nice thanks
07:11:53 <wchogg> ouch, I lose
07:12:04 <maltem> wchogg: as far as I see anyways
07:12:06 <wchogg> maltem : ah, right.
07:12:20 <maltem> er, that last sentence was related to the paper, not to you losing :)
07:12:33 <wchogg> Hah, that didn't even occur to me.
07:12:44 <wchogg> It's a funny reading of the log though
07:14:50 <blueonyx> oh chakravarty
07:15:12 <chessguy_work> @users
07:15:12 <lambdabot> Maximum users seen in #haskell: 674, currently: 644 (95.5%), active: 19 (3.0%)
07:15:28 <blueonyx> @losers
07:15:28 <lambdabot> Maximum users seen in #haskell: 674, currently: 644 (95.5%), active: 19 (3.0%)
07:15:33 <blueonyx> O.o
07:15:52 <Axman6> whoot!
07:16:25 <Axman6> i finally saw the chan when it was 600+
07:16:38 <ksf> people have seen #haskell hitting 600 on slashdot and now wanna be part of the cool guys.
07:16:56 <blueonyx> hehe
07:16:58 <Axman6> yeah well, i was here before it was publically cool
07:17:07 <Axman6> emm, -al
07:17:22 <ksf> a month or two after I arrived, it became cool ;)
07:17:24 <wchogg> So you liked Haskell back when it was underground?
07:17:55 <EvilTerran> ksf, it must be your influence!
07:17:57 <Axman6> i was here just under a year ago i think
07:17:58 <vixey> Haskell -- The Java of 2009
07:18:18 <Axman6> no, i was using haskell just under a year ago, it was another 2 months or so until i discovered #haskell
07:18:19 * gour was here when the number was ~100
07:18:37 * EvilTerran has been using haskell, and lurking in #haskell, for a bit over 2yr
07:19:30 <dolio> Yes, it's just like Java.
07:19:34 <EvilTerran> strangely, i don't think it's got *that* much noisier, most of the time. the busy periods have become busier, but it's still usually nice and quiet
07:19:48 <Axman6> indeed
07:19:52 <blueonyx> since java guys dont get it?
07:19:57 <EvilTerran> we're accumulating lurkers, i guess
07:20:02 <vixey> @let rec = fix
07:20:03 <lambdabot>  Defined.
07:20:16 <EvilTerran> s/lurkers/disciples/?
07:20:19 <ksf> we could train lambdabot to keep track of and stalk the lurkers.
07:20:28 <vixey> @let listCase nil cons [] = nil ; listCase nil cons (x:xs) = list x xs
07:20:28 <lambdabot>  <local>:23:56: Not in scope: `list'
07:20:34 <vixey> @let listCase nil cons [] = nil ; listCase nil cons (x:xs) = cons x xs
07:20:35 <lambdabot>  Defined.
07:21:04 * EvilTerran usually just calls that "list", to go with "maybe" and "either"
07:21:49 <vixey> :t fix (\fold nil cons xs -> listCase (nil) (\x xs -> cons x (fold nil cons xs) xs)
07:21:50 <lambdabot> parse error (possibly incorrect indentation)
07:22:05 <EvilTerran> moar parentheses!
07:22:23 <vixey> :t fix (\fold nil cons xs -> listCase (nil) (\x xs -> cons x (fold nil cons xs) xs))
07:22:24 <lambdabot> forall t t1. t -> (t1 -> ([t1] -> t) -> [t1] -> t) -> [t1] -> [t1] -> t
07:22:27 <EvilTerran> :t fix$ \fold nil cons xs -> listCase nil$ \x xs -> cons x (fold nil cons xs) xs
07:22:29 <lambdabot> forall t t1. t -> (t1 -> ([t1] -> t) -> [t1] -> t) -> [t1] -> [t1] -> t
07:22:50 <vixey> :t fix (\fold xs -> listCase (?nil) (\x xs -> ?cons x (fold xs) xs))
07:22:51 <lambdabot> forall t t1. (?cons::t1 -> ([t1] -> t) -> [t1] -> t, ?nil::t) => [t1] -> [t1] -> t
07:23:03 <vixey> :t fix (\fold xs -> listCase (?nil) (\x xs -> ?cons x (fold xs)) xs)
07:23:05 <lambdabot> forall t t1. (?cons::t1 -> t -> t, ?nil::t) => [t1] -> t
07:23:06 <vixey> that's it
07:23:11 <vixey> :t foldr
07:23:12 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
07:23:41 <CodeWar> if there was one seminal paper on lambda calculus every beginner should read what woudl that be
07:23:51 <EvilTerran> CodeWar, TaPL?
07:24:32 <vixey> CodeWar, 2 things
07:24:33 <cads> I was reading a logical statement and in it were universal and existential quantifier where I'm assuming variables were quantified over the set of functions of a certain type. So it went like  "if forall f in (A->B) there exists f* in (A'->B') such that (.....) then you have one funky morphism".
07:24:40 <EvilTerran> CodeWar, it's a bit more than a paper, but i'd say it's one of the few textbooks that earns its cover price
07:24:44 <EvilTerran> ?go tapl
07:24:57 <lambdabot> http://www.tapl.org/
07:24:57 <lambdabot> Title: TAPL- Tulsa Association of Petroleum Landmen
07:24:58 <vixey> CodeWar: LAMBDA CALCULI WITH TYPES -- Henk Barendregt, and Lectures on Curry Howard Isomorphism
07:25:01 <EvilTerran> ... not that one
07:25:04 <EvilTerran> ?where tapl
07:25:04 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
07:25:10 <CodeWar> so TAPL will introduce to me lamdba calculus and everything else that sets fp apart from imperative programming I ve been doing?
07:25:18 <vixey> TAPL isn't about lambda calculus
07:25:25 <EvilTerran> it discusses lambda calculus
07:25:26 <cads> I was wondering if this quantifying over typed function spaces is higher order logic.
07:25:48 <EvilTerran> and is a really good read for people interested in things like lambda calc, imo :)
07:26:43 <CodeWar> EvilTerran, thats an entire book which is good but isnt there a seminal paper something that throws the idea then has the reader think about it
07:27:20 <vixey> CodeWar, guess you can't heard me or what I say isn't worth hearing or something
07:28:04 <CodeWar> vixey,  thanks I ll look up those two papers
07:28:30 <mortenlysgaard> I think I'm a bit lost in Monads, what am i doing wrong? http://hpaste.org/13679
07:28:51 <vixey> hm TAPL doesn't talk about bidirectional typechecking does it?
07:29:35 <EvilTerran> mortenlysgaard, what type is "database"?
07:29:52 <mortenlysgaard> IO [String]
07:29:59 <EvilTerran> and what type is "filter (key `elem`)"?
07:30:13 <wchogg> -bi-directional typechecking?
07:30:19 <wchogg> What are the two directions?
07:30:30 <vixey> wchogg, up and down
07:30:32 <EvilTerran> wchogg, inferring a function's return type from its parameter types, and vice-versa
07:30:38 <EvilTerran> i think
07:30:39 <wchogg> Oh!  Derr.
07:30:47 <vixey> nah, it's inference and checking
07:31:18 <vixey> (but they usually use up or down arrows as shorthand in papers)
07:31:20 <mortenlysgaard> EvilTerran; It's [[a]]
07:31:34 <wchogg> vixey : yeah, I know what you mean now.  Hadn't seen that term before.
07:31:44 <EvilTerran> ?type \key -> filter (key `elem`)
07:31:45 <lambdabot> forall a. (Eq a) => a -> [[a]] -> [[a]]
07:32:36 <sampointon> okay, so I'm giving up on multimethods purely via typeclasses. Is there a Right Way of splitting a 'data' statement over several files?
07:32:37 <EvilTerran> mortenlysgaard, you've solved the problem of trying to pass an "IO (something)" to a function that expects just a "something" in the definition of "database"
07:32:44 <EvilTerran> mortenlysgaard, you have to do the same trick again
07:33:04 <EvilTerran> ?go data types a la carte
07:33:23 <lambdabot> Plugin `search' failed with: thread killed
07:33:26 <EvilTerran> grr
07:33:36 <mortenlysgaard> EvilTerran; Do i have to use "do" syntax?
07:34:00 <EvilTerran> mortenlysgaard, well, that's the simplest way, yes
07:34:22 <mortenlysgaard> EvilTerran; Is there a more elaborate way?
07:34:31 <EvilTerran> mortenlysgaard, note that (readFile "namelist.txt"
07:34:31 <EvilTerran>  :: IO String), and the parameter of "lines" is of type String
07:34:42 <halberd> Suppose you have an application consisting of several windows, some of which contain buttons that spawn new windows when pressed, with the feature that the user can right-click and add a new button to any window
07:34:43 <EvilTerran> (excuse the random newline, copy-paste error)
07:35:24 <halberd> the key feature being that you want the buttons that the user adds, to still be there in the "same" window when he runs the program the next time
07:35:35 <EvilTerran> mortenlysgaard, well, you could have written "database = liftM lines (readFile "namelist.txt")", for instance
07:35:58 <EvilTerran> mortenlysgaard, but i found it easier to get used to do-notation first before taking short-cuts
07:36:22 <halberd> is there any application you can think of that has that feature?
07:36:25 <mortenlysgaard> EvilTerran; I think so, I need to practice on these monads
07:36:45 <EvilTerran> sampointon, the closest i've seen is http://lambda-the-ultimate.org/node/2700 - it's not The Right Way, but it's someone's relatively good idea
07:36:50 <halberd> it's a bit non-trivial once  you think about it, because two windows might be considered the "same" with respect to buttons without being exactly the same
07:36:58 <Cale> mortenlysgaard: a value of type  (IO t)  is like a program which when run will give you a value of type t
07:37:35 <mortenlysgaard> Ah, so haskell is complaining about that it cant be lazy?
07:37:37 <Cale> mortenlysgaard: To run it as part of another IO action, you can use the do-notation:  a line of the form  v <- x  in a do-block means to run x and call its result v.
07:37:47 <Cale> This has nothing to do with laziness.
07:38:11 <twanvl> halberd: what does the application do besides this? i.e. what's the point?
07:38:46 <halberd> "something" twanvl, its actual purpose could be anything
07:39:08 <EvilTerran> halberd, it sounds to me to be reminiscent of a file browser looking at a tree of folders
07:39:16 <halberd> it's just this particular feature of user-extensibility-by-adding-buttons that I'm wondering has been done before
07:39:42 <Cale> mortenlysgaard: There are two processes involved in running a Haskell program. One is evaluation, which is the reduction of expressions into values (and this is where lazy evaluation comes in), the other is something I like to call execution, and it's where values of type (IO t), which can be viewed as sets of instructions to be carried out, are actually carried out and their effects occur.
07:40:47 <Cale> Evaluation of an expression never causes execution of an action.
07:40:57 <EvilTerran> halberd, also, i think MS Office 97 may've beaten you to the punch
07:41:09 <IvdSangen> and these are two distinct "worlds", because the executions can not change evaluations
07:41:33 <maltem> wait, so we can perfectly confuse people by saying that pure computations are a side effect of execution :)
07:41:35 <halberd> I don't have access to that program, could you briefly tell me what it does?
07:41:41 <Cale> In the end, the 'main' value in your program is an action which will be executed, and in turn, it will be built up from simpler actions.
07:41:44 <EvilTerran> IvdSangen, er, the only way evaluation happens is because execution can't proceed without it
07:41:45 <mortenlysgaard> Hm.. I think I'm getting more of the picture
07:42:09 <IvdSangen> EvilTerran: but evaluation is in a pure context
07:42:16 <IvdSangen> that's what I meant to say
07:42:18 <Cale> It's also important to note that the fact that IO is a monad is not that important.
07:42:28 <EvilTerran> maltem, that sounds profound at first glance, meaningless after a few seconds, then profound again. i like that. :P
07:42:43 <maltem> heh
07:42:59 <Cale> (it's just one monad, and not a really great motivating example for monads in general)
07:43:00 <asgaroth> Is there any replace function(replace a certain token in a String) in the standard libraries except using Text.Regex?
07:43:01 <EvilTerran> ?remember maltem wait, so we can perfectly confuse people by saying that pure computations are a side effect of execution :)
07:43:02 <lambdabot> Done.
07:43:21 <Cale> But the fact that execution of IO actions is separate from evaluation -- that's the important bit.
07:43:44 <maltem> I'm knighted!
07:43:48 <Cale> (The monadic bit is just related to what primitives are available for combining IO actions)
07:44:01 <TuringTest> asgaroth: There are too many different ways to do it.  Each replace function is only half a screen of code, but the different options are legion.
07:44:11 <EvilTerran> asgaroth, there's nothing specifically for that, but Text.Regex would work for the "parsing" aspect, as would any of the parser combinator libraries
07:44:22 <vixey> what important functions are there which go  B u v -> B q p, or -> (u,v) or similar  ?
07:44:39 <EvilTerran> vixey, what's B?
07:44:42 <vixey> I guess Either is a common one
07:44:54 <vixey> (various functions on either)
07:44:56 <asgaroth> Well Text.Regex also provides a subRegex function that I could use, but I guess I'll stick with a more lightweight custom function
07:45:04 <vixey> B is any * -> * -> *
07:45:24 <asgaroth> Perhaps there should be a module with the various variants for that like the recently created Data.List.Split
07:45:47 <TuringTest> asgaroth: the code for subRegex is half a screen at http://hackage.haskell.org/packages/archive/regex-compat/0.92/doc/html/src/Text-Regex.html#subRegex
07:45:48 <EvilTerran> vixey, there's not really anything that'll work on any B of that kind; maybe with some class constraints, or something
07:46:23 <TuringTest> asgaroth: Much like Data.List.Split times the complexity of "put back together with X"
07:46:34 <sampointon> EvilTerran: skimming the Data Types a la Carte paper, it all seems to be built on typeclasses, which are the source of the current batch of problems
07:46:39 <twanvl> vixey: some arrow stuff perhaps?
07:46:49 <vixey> yeah arrows I guess also
07:46:54 <vixey> :t first
07:46:56 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
07:46:58 * lilac wonders whether Monads would confuse people less if the typeclass were called DoNotation
07:47:07 <vixey> ok
07:47:21 <EvilTerran> lilac, shurely "WarmFuzzyThing"?
07:47:24 <asgaroth> TuringTest: Hmm, right so splitting it with the right function from that and then using intercalate should do it then, so I might get it done in 1 line.
07:47:25 <vixey> so lots of higher order functions actually fit this, because of (->) :: * -> * -> *
07:47:36 <TuringTest> Heh.. the haddock comment for subRegex says @\"\\\\\\\\\"@ will insert a literal backslash.
07:47:51 <TuringTest> It is rare to see more escaping than that...
07:48:34 <EvilTerran> literal \ -> regex \\ -> string "\\\\" -> haddock \"\\\\\\\\\", i guess
07:48:35 <lilac> EvilTerran: that has no semantics (like Monad to haskell newbies).
07:48:50 <EvilTerran> lilac, sorry, i forgot this bit: :P
07:48:51 <lilac> EvilTerran: whereas "DoNotation" means "here's something with which you can use do-notation"
07:49:16 <lilac> EvilTerran: ah, well, in that case d: back at you, sir
07:49:30 <EvilTerran> :O!
07:49:53 <lilac> (:
07:52:51 <fasta> > \:t id
07:52:52 <lambdabot>   <no location info>: parse error on input `\:'
07:52:54 <fasta> > :t id
07:52:55 <lambdabot>   <no location info>: parse error on input `:'
07:53:06 <fasta> > @type id
07:53:07 <lambdabot>   <no location info>: parse error on input `@'
07:53:21 <fasta> :t id
07:53:22 <IvdSangen> id :: a -> a?
07:53:23 <lambdabot> forall a. a -> a
07:54:37 <fasta> I would like the type in ghci to be displayed as id :: a -> a, that is without the forall. There used to be an option called something like no-print-explicit-foralls, but I cannot find it in 6.10.1
07:55:03 <IvdSangen> can't help you with that one
07:55:17 <SamB_XP> fasta: have you checked the manpage ?
07:55:33 <fasta> SamB_XP: I did
07:55:37 <SamB_XP> look at all the -f options
07:56:07 <maltem> fasta: it's -fprint-explicit-foralls (it's enabled rather than disabled)
07:56:31 <maltem> (but chiming in a no should work actually)
07:56:50 <fasta> maltem: but it is not in the 6.10.1 manual
07:57:01 <SamB_XP> fasta: and it also doesn't work ?
07:57:06 <maltem> fasta: hm manual bug
07:57:21 <fasta> SamB_XP: didn't try that yet :) Working on it.
07:57:30 <dons> http://www.reddit.com/r/programming/comments/7nrnp/program_your_gpu_with_haskell/  gpu / dph
07:58:50 <EvilTerran> fasta, i seem to recall that, if a setting is enabled with -fsomething, -fno-something should disable it
07:58:59 <wchogg> dons : your old school certainly puts out fun research
07:59:05 <dons> yup
07:59:06 <dmead> does ghci have a built in memory limit?
07:59:10 <dmead> like the jvm?
07:59:14 <dmead> or ghc rather
07:59:27 <dons> dmead: only what your machine can handle
07:59:36 <maltem> dmead: there's a limit for the stack size, but not the heap afaik
07:59:40 <dmead> hmm
07:59:47 <dolio> You can set a heap overflow limit somehow.
07:59:48 <vixey> I thought there is a heap limit too
07:59:56 <dmead> so what does that really mean for code?
07:59:58 <vixey> btw I found that it makes no difference setting them though
07:59:59 <wchogg> dons : a few years ago I had actually been trying to argue that something like Haskell on gpu's was what we need in particle physics, but had nothing to back me up.  Now I just need a time machine :p
08:00:08 <gnuvince_> What is coarbitrary in QuickCheck?
08:00:09 <vixey> (or it's set too low and no programs run)
08:00:22 <maltem> dmead: ah it's -M for the maximum heap size
08:00:25 <dmead> wchogg, unless you can translate haskell to vector math then i don't think thats going to work too well
08:00:37 <maltem> dmead: +RTS -M<size>, that is
08:00:42 <dmead> ah
08:00:43 <BMeph> Is there a special name in CT for the smallest domain of a function? E.g., for a function from non-negative reals to reals.
08:01:01 <wchogg> BMeph : well any given arrow only has one domain
08:01:18 <dmead> because i'm looking at taking an app that usually reads data through standard IO and using an ODBC connection instead
08:01:21 <halberd> that's just the domain of the function BMeph
08:01:25 <halberd> unless it's a partial function
08:01:27 <dmead> the memory might baloon out
08:02:15 * maltem now considers setting -M for ghci adventures
08:02:37 <dolio> Partial functions as arrows still have only one domain.
08:02:45 <redditbot> GPU programming via Data Parallel Haskell
08:02:45 <redditbot> Bridging Python and Haskell - Sharing recursive data structures (Part3)
08:03:35 <dolio> But the same partial function might induce multiple arrows, one for each allowable domain.
08:03:58 <BMeph> wchogg, halberd: Well, you could just call the reals its domain, couldn't you?
08:04:09 <halberd> only if it's a partial function BMeph
08:04:32 <halberd> if it's a total function then you can't say that all the reals are its domain if it is only defined on the non-negative ones
08:04:40 <dolio> Similar to how there are potentially multiple arrows for a single total function, but with different codomains.
08:06:22 <halberd> if it's a partial function I don't know what you call the set of values over which it is defined
08:06:44 <fasta> EvilTerran: yes, that's correct (and that is documented).
08:06:49 <halberd> oh, you could call it the "domain of definition"
08:07:50 <BMeph> Bmeph: The I guess it'd be the term for the set that makes a partial function into a total one.
08:08:25 * BMeph thanks himself for that comment, but feels...confused. ;)
08:08:48 <BMeph> Er, s/term/name/ :)
08:10:22 <lilac> gnuvince_: "coarbitrary a" returns a generator transformer which is used to generate arbitrary functions from a's type
08:10:56 <Olathe> test
08:11:03 <BMeph> So where does that name, ("domain of definition") originate? Maybe I can get more info there. :)
08:11:35 <halberd> http://en.wikipedia.org/wiki/Total_function
08:12:00 <vixey> http://en.wikipedia.org/wiki/Total_awesome
08:12:19 <lilac> gnuvince_: Gen (a -> b)'s arbitrary is something like: arbitrary = return (\a -> coarbitrary a arbitrary)
08:13:12 <thoughtp1lice> dons: cool link on reddit about the GPU stuff - I saw sean lee's galois presentation about gpugen too
08:25:58 <vixey> I wish people will stop calling functional languages turing-complete
08:26:11 <SamB_XP> well they are
08:26:20 <SamB_XP> (many of them)
08:26:20 <roconnor> SamB_XP: most of them are
08:26:21 <vixey> it still sounds stupid
08:26:31 <ibid> might call them church-complete
08:26:35 <vixey> say general-recusive or mu-recursive
08:26:39 <ibid> or recursive
08:26:43 <vixey> 'turing complete' is dumb
08:26:45 <SamB_XP> yeah, church complete sounds good ;-P
08:26:47 <ibid> recursively complete
08:26:55 <vixey> you have to go through this hassle of making a turing machine and all this arbitrary nonsense
08:26:57 <roconnor> I suppose it might be needed to be pointed out because without an obvious way to write loops, people might think functional programming isn't turing complete
08:27:11 <asgaroth> How do I add a .hoo database to the databases hoogle searches by default?
08:27:20 <roconnor> ibid: computably complete.  "recursive" is out of vogue
08:27:37 <lilac> vixey: why? there are various provably equivalent other structures you can show the language equivalent to
08:27:44 <roconnor> computationally complete?
08:27:45 <vixey> lilac, it's indirect
08:28:02 <vixey> lilac: just said: "you have to go through this hassle of ..."
08:28:13 <lilac> vixey: sure, but it's the most common term (as far as I'm aware) amongst computer scientists for the concept
08:28:22 <vixey> lilac, I know...
08:28:31 <lilac> vixey: you/i don't have to go through hassle. someone else already has.
08:28:32 <vixey> it's still a stupid term
08:28:37 <roconnor> @faq can Haskell solve the halting problem?
08:28:38 <SamB_XP> you *don't* have to go through the hassle, do you ?
08:28:38 <lambdabot> The answer is: Yes! Haskell can do that.
08:28:39 <vixey> regardless of commonness
08:28:47 <halberd> what's wrong with Turing, he was a smart guy
08:28:57 <vixey> halberd, ???????
08:29:11 <lilac> it's nice to give turing some posthumous respect
08:29:26 <sampointon> talking about *-completeness is pretty pointless to begin with unless you're doing formal mathematics or some waaay out there research
08:29:45 <SamB_XP> sampointon: is it now ?
08:29:45 <roconnor> @pl \x -> x x
08:29:46 <lambdabot> join id
08:30:03 <sampointon> SamB_XP: well, at least as a measure of value of a language
08:30:06 <roconnor> isn't writing programs formal mathematics?
08:30:10 <EvilTerran> that's not well-typed!
08:30:22 <SamB_XP> :t join id
08:30:24 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
08:30:24 <lambdabot>     Probable cause: `id' is applied to too many arguments
08:30:24 <lambdabot>     In the first argument of `join', namely `id'
08:30:27 <sampointon> SamB_X: which is just about the only place I see it used amongst programmers, as opposed to mathematicians
08:30:27 <vixey> halberd, got nohing against Turing, I'm saying to describe a functional language, mu-recursive is a better term than turing complte
08:30:29 <lilac> why is there no instance Monad Expr?
08:30:35 <SamB_XP> :t \x -> x x
08:30:37 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
08:30:37 <lambdabot>     Probable cause: `x' is applied to too many arguments
08:30:37 <lambdabot>     In the expression: x x
08:30:40 * lilac realises why and slaps his head
08:30:42 <roconnor> @pl (\x -> x x) (\x -> x x)
08:30:44 <Axman6> :t \x -> x x
08:30:46 <lambdabot> ap id id (ap id id)
08:30:46 <lambdabot> optimization suspended, use @pl-resume to continue.
08:30:46 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
08:30:46 <lambdabot>     Probable cause: `x' is applied to too many arguments
08:30:46 <lambdabot>     In the expression: x x
08:30:53 <roconnor> ha
08:30:57 <roconnor> now it's ap id
08:30:59 <roconnor> :)
08:31:00 <vixey> roconnor, no :p
08:31:01 <halberd> vixey but it is irrelevant since mu-recursive is the same as turing complete
08:31:05 <vixey> roconnor, it should be though
08:31:15 <vixey> halberd, .....wrong
08:31:26 <vixey> halberd, they are different things
08:31:31 <vixey> that's why they have different names
08:31:34 <lilac> they are provably equivalent
08:31:37 <SamB_XP> vixey: I don't follow
08:31:54 <lilac> as predicates on languages they are the same
08:32:01 <SamB_XP> Bowser and Koopa are different names, too ...
08:32:08 <quicksilver> I don't think this channel is the right place for vixey to air distaste for the phrase 'Turing complete'
08:32:10 <roconnor> "same thing as" ... ah equality
08:32:14 <SamB_XP> but both refer to the same character in SSB: Melee
08:32:19 <roconnor> @quote equality
08:32:26 <quicksilver> It's widely used, and not a very interesting debate.
08:32:26 <lambdabot> JamesMckinna says: We are once again left with the miserable prospect that it is equality that divides us.
08:32:27 <fasta> vixey: yeah, we should just burn all books containing Turing-Complete and replace it with Haskell-Complete.
08:32:43 <halberd> well technically vixey both turing complete and mu-recursive apply strictly to particular formalisms, which haskell (for example) is not technically one of
08:32:45 <SamB_XP> (depending on whether you have the UIlanguage set to english or japanese)
08:32:58 <roconnor> equality divides halberd and vixey
08:33:15 <wchogg> fasta : how about 'awesome-complete'?
08:33:48 * roconnor hates turing complete langauges
08:33:49 <fasta> wchogg: or just very-complete (cf. extremely very large telescope)
08:33:57 <roconnor> they allow all sorts of crazy things
08:34:14 <lilac> roconnor: total languages all the way! :)
08:34:16 <dolio> With their contradiction proving.
08:34:19 <vixey> Turing complete is fine and descriptive, I call BF, C, ALGOL etc Turing Complete
08:34:38 <lilac> wchogg: i like awesome-complete :)
08:34:46 <halberd> turing complete doesn't say that the machine has to be like a turing machine, algol isn't much like a turing machine
08:34:58 <roconnor> lilac: the nice thing about total languages is that people won't be whining about optimisations that don't preserve bottoms.
08:34:59 <fasta> Turing-Complete is a CS name. Haskell is just another language from that perspective.
08:35:01 <sclv> @quote turing complete
08:35:06 <lambdabot> No quotes for this person. My brain just exploded
08:35:18 <roconnor> @quote turing
08:35:18 <sclv> @quote turing
08:35:19 <lambdabot> pjd says: was Turing complete?
08:35:19 <lambdabot> AlanPerlis says: Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
08:35:40 <dons> ?users
08:35:40 <lambdabot> Maximum users seen in #haskell: 639, currently: 638 (99.8%), active: 13 (2.0%)
08:35:58 <SamB_XP> I thought that was the whole point of the turing tar-pit ...
08:36:15 <roconnor> SamB_XP: yes, but still beware
08:36:18 <SamB_XP> (recreation by puzzling!)
08:36:23 <sampointon> @faq Can Haskell create a problem so incorrigible even Haskell cannot solve it?
08:36:23 <lambdabot> The answer is: Yes! Haskell can do that.
08:36:32 <SamB_XP> nobody actually want to USE a tar-pit language ;-P
08:36:41 <SamB_XP> +'d
08:36:44 <Olathe> Stop tricking the @faq module into saying Haskell can't do it !
08:36:48 <roconnor> SamB_XP: like x86 assembly?
08:36:57 <roconnor> maybe that isn't a tar-pit yet
08:37:02 <quicksilver> like TeX ;)
08:37:07 <roconnor> :D
08:37:07 <quicksilver> my favourite tar-pit by far.
08:37:13 <roconnor> good one
08:37:25 <SamB_XP> roconnor: I was thinking more like, oh, fungeoids ...?
08:37:36 <quicksilver> gotta love a language with observably two phase parsing, and the ability to modify both phases.
08:37:37 <Deewiant> Hey, Befunge is very fun to program in
08:37:45 <roconnor> quicksilver: I always compile my haskell to airline fair pricing.
08:37:58 <roconnor> quicksilver: then I call to book a fare, and let them do the compuation for me
08:38:07 <roconnor> fare pricing
08:38:12 <quicksilver> Hmm. Clever. I like that.
08:38:14 <lilac> @faq Can Haskell tell me that I forgot to explain how lists are really numbers when I mess up my code?
08:38:14 <lambdabot> The answer is: Yes! Haskell can do that.
08:38:32 <quicksilver> roconnor: I transform mine to EU bus scheduling. Then I just wait for a bus.
08:38:35 <halberd> common lisp also has 2 phase parsing
08:38:40 <quicksilver> roconnor: unfortunately, I normally get three answers.
08:38:47 <roconnor> quicksilver: is EU bus scheduling turing complete?
08:38:52 <halberd> with the ability to modify both phases
08:38:54 <roconnor> I thought it was only NP complete
08:38:59 <quicksilver> not sure, but I read an article about it being NP-hard ;)
08:39:06 <roconnor> (which is pretty good for a lot of compuation)
08:39:39 <lilac> don't you need to take your compiler's output and then persuade lots of drivers to take their breaks at the exact right times?
08:39:49 <roconnor> I saw an article saying that air fare pricing was in general turing complete
08:39:58 <SamB_XP> wow
08:39:58 <roconnor> or whatever vixey would call it
08:39:59 <Saya> @faq is EU bus scheduling turing complete
08:39:59 <lambdabot> The answer is: Yes! Haskell can do that.
08:40:02 <lilac> and also for some seventeen-year-olds to drive outside of their coutnry but within 200 miles of home?
08:40:11 <Saya> i see the trick here
08:40:15 <vixey> roconnor, no that's fine, it's not a declarative functional language
08:40:38 <SamB_XP> so ... how exactly do you get these scheduling-based programs enacted
08:40:39 <vixey> I was only objecting with reference to declarative functional languages like haskell earlier
08:40:42 <roconnor> SamB_XP: the question of, can I take this route for this price, is undecidable in general.
08:40:59 <halberd> a turing machine is specified declaratively, by its state machine and alphabets
08:41:01 <lilac> counting sheep is in general turing complete, if you generalize it into, say, Haskell
08:41:16 <SamB_XP> lilac: counting sheep ?
08:41:17 <vixey> lilac, I don't follow
08:41:39 <lilac> anything can be generalized to turing completeness
08:41:42 <vixey> halberd, I think thy call it operational semantics...?
08:41:44 * SamB_XP doesn't get how you turn sheep into lambda calculus
08:42:00 <roconnor> lilac: I don't think "counting" as we understand it counts as general computation
08:42:02 <halberd> do robots dream of electric lambda calculus?
08:42:05 <lilac> but that doesn't mean that finding a particular bus timetable or airfare is hard
08:42:11 <jeffersonheard> I'm nearly done with my first template haskell module, but one thing I thoguht would work didn't...  http://hpaste.org/13681
08:42:45 <lilac> roconnor: what if you have infinitely many sheep and sheep pens, and you're given an arbitrary way of counting them involving moving them between pens?
08:43:17 <SamB_XP> lilac: hmm, that might make you fall asleep from confusion, then again it might just keep you awake
08:43:20 <jeffersonheard> Trying to derive an instance using functions whose names I know, but it complains that nothing's in scope
08:43:26 <halberd> an infinite number of sheep on an infinite number of typewriters
08:43:42 <sampointon> halberd: They'll produce Mutton-let eventually
08:44:05 <halberd> I don't know sampointon they might be too ham-handed to come up with anything
08:44:48 * SamB_XP was at first thinking mutton-let was a variant of let ...
08:45:00 <vixey> I guess there is just some kind of obsession with turing completeness
08:45:07 <vixey> but nobody cares about mu-recursion
08:45:11 <lilac> vixey: as a concept, not as a term
08:45:13 <opqdonut> well it's a buzzword
08:45:14 <opqdonut> ;)
08:45:27 <halberd> vixey it's just because the turing machine was the first formalism to be turing-complete
08:45:36 <vixey> it's a shame when a term is used so much that its meaning is dried out
08:45:37 <halberd> so it got famous so people used the term
08:45:45 <opqdonut> halberd: lambda calculus is older than turing machines
08:45:46 <lilac> halberd: that's not true, but it was the first one to be (trivially) proved turing-complete
08:45:52 <opqdonut> so in a sense, that's not true
08:45:57 <opqdonut> but yeah, what lilac said
08:45:58 <jeffersonheard> can anyone tell me on that hpaste what to use intstead of [| functionName |] ?
08:46:00 <halberd> hmm
08:46:51 <halberd> well, whatever the history, which term you use is just convention
08:47:07 <opqdonut> of course
08:47:10 * afabian prefers lambda-calculus complete.
08:47:38 <vixey> that doesn't even mean anything...
08:47:58 <dolio> Some (most) lambda calculi aren't Turing complete.
08:48:54 <halberd> actually according to this history I'm reading here, combinatory logic predated lambda calculus
08:49:29 <Spark> it's so long ago it doesn't matter
08:49:43 <Spark> oh, combinatory logic is very old isn't it
08:49:47 <Spark> like, 1700s or something
08:49:49 <Spark> or even earlier
08:49:55 <lilac> very old, yes
08:50:01 <wchogg> Hrmm...I can't believe I actually had a use for a function flip . (flip .)
08:50:07 <halberd> no, 1920
08:50:09 <vixey> 1700s -- I remember it like it was yesterday
08:50:10 <Deewiant> :t flip . (flip .)
08:50:12 <lambdabot> forall a b c a1. (a1 -> a -> b -> c) -> b -> a1 -> a -> c
08:50:14 <Spark> the ideas i imagine go back to ancient greece perhaps, the formalism would be quite recent
08:50:33 <vixey> yeah beacuse the greeks know about catamorphims and stuff :P
08:50:41 <vixey> so they must have known combinatory logic
08:50:44 <wchogg> vixey : why else do we use their words?
08:51:26 <dolio> They sound cool.
08:52:10 * EvilTerran wishes his prof would use the Monad class so he could use do-notation
08:52:19 <Spark> ah no i'm thinking about predicate logic
08:52:38 <EvilTerran> instead of insisting on using things called "@>" and "result"
08:52:43 <opqdonut> EvilTerran: can't you just define it in the beginning of your answer?
08:53:21 <lilac> EvilTerran: intro to Haskell class?
08:53:46 <EvilTerran> i guess he thinks we'll get confused if we had to understand *ghasp* typeclasses and desugaring on top of him teaching us monads
08:53:52 <EvilTerran> lilac, principles of programming languages
08:54:13 <Spark> what does haskell have to do with principles of programming languages
08:54:36 <vixey> Spark, good question...
08:54:37 <EvilTerran> it's a teaching aid
08:54:52 <vixey> Spark, you'd think they'd use python or something
08:55:20 <lilac> python's no good if you want to teach about strong type systems, though :)
08:55:23 <EvilTerran> i'm currently trying to hack on an interpreter for our basic functional language that we've been using for the course
08:55:51 <EvilTerran> which'd be a lot easier if he'd used a State monad instead of "type M a = ..." and his own names for return and >>=
08:56:02 <Spark> i would give the syntax of a basic programming language with some examples to show how to write code in it, then give the operational semantics, and a type system
08:56:19 <Spark> and show the value of the operational semantics when reasoning about the behaviour of programs, and the value of hte type systems to exclude certain behaviours
08:56:19 <SamB_XP> EvilTerran: why don't you just fix his code for him ?
08:56:37 <vixey> Spark, sounds like a pantomime
08:56:39 <EvilTerran> vixey, they use haskell because they taught us haskell in the first year of the course
08:56:42 <kosmikus> Spark: and what's wrong with having an implementation as well?
08:56:53 <SamB_XP> it always bothers me when papers talking about monads use "type Foo a = ", too ...
08:57:01 <Spark> kosmikus: that would be found in the course called "implementing programming languages" :)
08:57:17 <EvilTerran> SamB_XP, that would involve changing most of his code, instead of just the few bits we're meant to change
08:57:24 <SamB_XP> EvilTerran: and ???
08:57:26 <EvilTerran> SamB_XP, and would probably annoy him when it came to marking
08:57:31 <vixey> do it!
08:57:32 <SamB_XP> you sure ?
08:57:36 <fasta> Are all bells and whistles enabled by -fglasgox-exts?
08:57:39 <EvilTerran> ... and i'm lazy :P
08:57:44 <kosmikus> Spark: ah, but that's different. "implementing" should be about how to get an efficient implementation. in "principles" it's for understanding the language better by being able to run simple programs
08:57:53 <Spark> implementations can be used for courseworks, and other courses teach the skill of programming so that is a prerequisite
08:57:54 <SamB_XP> It seems to me that the lazy thing to do is to do that
08:57:58 <fasta> (In particular the record puns feature)
08:58:04 <EvilTerran> SamB_XP, well, that's the yak shaving thing to do
08:58:14 <Spark> i may even allow them to write the implementation in any language so long as it produced the correct output when given a program as input
08:58:47 <kosmikus> Spark: it's much easier to understand the semantics of a language when you can run a few corner cases
08:58:59 <vixey> Spark, so you decided against operational semantics in the end
08:59:01 <Spark> kosmikus: fair enough but still no reason to be teaching haskell
08:59:14 <Spark> vixey: nope, that can be for the exam
08:59:23 <vixey> this is so silly
08:59:38 <Spark> the coursework can be to "implement these semantics"
08:59:46 <Spark> so there are still semantics there to be understood, just not formulated by the students
08:59:56 <kosmikus> Spark: what? if students already know Haskell, then it's a good implementation language, because you can write interpreters with very little overhead
08:59:58 <Spark> and plus then they understand the value of a clear description of a language
09:00:21 <Spark> kosmikus: if students already know haskell then you don't have to teach it
09:01:17 <gio123> is it decidable to show semanticaly equivalent of regular expressions?
09:01:20 * SamB_XP covets EvilTerran's homework
09:01:22 <kosmikus> yes. that's how I understood it. they use Haskell because they already know it.
09:02:45 <redditbot> Staged Functional Programming for Sensor Networks :: PDF
09:02:45 <redditbot> GPU Kernels as Data-Parallel Array Computations in Haskell
09:02:45 <redditbot> Armada on Hackage: real-time strategy game in Haskell
09:03:07 <EvilTerran> SamB_XP, you've got me tempted to rejig it into idiomatic haskell, now :P
09:03:21 <Spark> gio123: i think so
09:03:35 <Spark> gio123: you can convert them to normalised dfas and compare the dfas
09:04:15 <Spark> is normalised the right term?
09:04:17 <olsner> EvilTerran: go go go!
09:04:35 <vixey> Spark, don't reduce it to graph isomorphism..
09:05:00 <Spark> vixey: you have a different approach?
09:05:22 <halberd> spark's method works, graph isomorphism is decidable
09:05:41 <halberd> it doesn't have to be efficient
09:05:43 <SamB_XP> halberd: but is it the right thing ?
09:05:56 <Spark> it's not that inefficient is it
09:05:56 <SamB_XP> does it always come True when it should ?
09:06:01 <halberd> yes
09:06:28 <Spark> you can just check the set of nodes and the set of edges are the same
09:06:33 <halberd> actually isomorphism of dfas might be easier than general graph isomorphism
09:06:49 <halberd> because you are given the start node, and the edges have labels which can help
09:06:59 <Spark> yeah you can label them from the start node, in other words
09:07:02 <halberd> yes in fact it would have to be
09:07:04 <Spark> label the nodes that is
09:07:18 <Spark> then checking is trivial
09:07:18 <halberd> the only problem is that regexes translate to nfas which you have to translate to dfas which is inefficient
09:07:23 <halberd> then you have to minimize the dfas
09:07:32 <Spark> minimisation, that's what i was looking for (not normalisation)
09:07:48 <SamB_XP> but it better also be a normalization
09:08:15 <Spark> i think two dfas that accept the same language are structurally equivalent too though, right?
09:08:26 <Spark> that's probably a nice proof waiting to be written
09:08:29 <SamB_XP> also, you have to use a representation where the cyclic graph structure is observable
09:08:32 <halberd> hmm I'm not sure, maybe there exists a minimal dfa that accepts the same language of another minimal dfa with the same # of states
09:08:51 <Spark> halberd: but then you can just rename the states
09:09:04 <Spark> you can define the dfa from the language itself
09:09:05 <halberd> the edges could be different
09:09:06 <Spark> can't you?
09:09:24 <Spark> although you'd need a good definition for the language and it's a bit circular
09:09:26 <Raevel> there is only one minimal dfa for a given language
09:09:32 <Spark> excellent
09:09:35 <Spark> now i can go to the pub
09:09:37 <halberd> well then
09:09:38 <SamB_XP> Raevel: ah, good
09:09:43 <vixey> Raevel, why?
09:10:13 <Raevel> heh. i forgot the details, but i've got the book somewhere nearby, i'll check
09:10:22 <Spark> i think i cited that book in my thesis
09:11:16 <halberd> ohh i remember, you can derive the states of the minimal dfa directly from the language
09:11:39 <Spark> hopcroft?
09:12:04 <Spark> 17:09 < Spark> you can define the dfa from the language itself
09:12:04 <Spark> :)
09:12:09 <Raevel> mine is kozen
09:12:17 <Spark> but that's only for finite languages isn't it
09:12:31 <Spark> although if you have some representation of an infinite language i have no doubt it would be possible to compile it to a dfa
09:12:35 <halberd> "x is a state of the dfa" is the same as "the set of strings associated with the state x have the same status for being in the language or out of it, when you append some other string to them"
09:12:41 <Spark> basically what lexer generators do
09:12:43 <sbahra> McKulskey's methods (sp?)
09:12:47 <sbahra> s/methods/method/
09:12:52 <Raevel> an infinite language: a*, pretty easy to contsructo a dfa, no?
09:13:02 <EvilTerran> hm
09:13:16 <EvilTerran> the modified code typechecks, but i'm not confident of its correctness
09:13:16 <halberd> that is, if x = {x_i}, then x_i y is in the language iff x_j y is in the language, for all i, j
09:13:18 <EvilTerran> =/
09:13:36 <Raevel> oh where is that theorem
09:14:06 <int80_h> "where or where has my comp theorem gone. oh where oh where can it be?"
09:14:21 <Spark> Raevel: that's a regex which we already discussed :)
09:14:33 <halberd> the minimal states are the equivalence classes of the relation a R b defined by a R b iff ax is in the language iff bx is in the language, for all x
09:15:18 <Spark> Raevel: what about the language which contains all words that are not in the language :)
09:15:19 <halberd> er, defined by a R b iff ((ax is in the language iff bx is in the language) for all x)
09:15:33 <Spark> maybe you could represent that with a dfa that never terminates
09:15:34 <sbahra> <Spark> i think two dfas that accept the same language are structurally equivalent too though, right?
09:15:46 <Spark> sbahra: minimal dfas that was
09:15:49 <sbahra> Spark, what do you mean structurally equivalent? The answer is no.
09:15:51 <Raevel> Spark: just switch accept and non-accept states
09:15:52 <sbahra> ye, ok
09:16:19 <Spark> Raevel: i was setting up russels paradox
09:16:22 <SamB_XP> Spark: that's NOT a language ...
09:16:26 <Raevel> :*/
09:16:50 <Spark> SamB_XP: what defines valid languages then
09:17:04 <Spark> i thought a language was just a set of valid terms
09:17:13 <SamB_XP> Spark: that's not a set either
09:17:14 <Spark> or do you just say it's not a valid set move on
09:17:15 <Spark> ok fine
09:17:19 <sbahra> SamB_XP, complement of a language is regular
09:17:29 <sbahra> SamB_XP, that is, complement of a regular language
09:17:37 <Raevel> a language is a set of terms
09:17:38 <SamB_XP> yes but a language can't be it's OWN self-complement ....
09:17:39 <sbahra> Why is it not a language?
09:18:09 <sbahra> Sure.
09:18:25 <Spark> i think the rule of thumb is that sets that fuck up the entirety of mathematics are not considered to be valid sets
09:18:53 <SamB_XP> that sounds like a dangerous rule of thumb
09:19:00 <byorgey_> @remember Spark i think the rule of thumb is that sets that fuck up the entirety of mathematics are not considered to be valid sets
09:19:01 <lambdabot> I will remember.
09:19:02 <afabian> Spark: sometimes we fix mathematics instead.
09:19:04 <byorgey_> hehe
09:19:15 <Spark> afabian: i didn't think anyone had come up with a decent way of doing that
09:19:34 <vixey> hey byorgey
09:19:35 <SamB_XP> afabian: I thought the fix usually involved deciding that the "sets" weren't
09:19:39 <byorgey> hi vixey
09:19:51 <Spark> that is the fix
09:20:02 <Spark> but just disallowing recursive definitions is too strong
09:20:25 <Spark> and anything beyond that needs termination functions and whatever
09:20:26 <Spark> right?
09:20:32 <halberd> a set can't contain itself
09:20:39 <halberd> usually
09:20:45 <Spark> heh
09:20:51 <Spark> no set of everything then?
09:21:06 <SamB_XP> Spark: those sets have a tendency to get out of hand ...
09:21:12 <idnar> Mu Set
09:21:15 <mm_freak_> i'm using cabal-install for quite some time now and have often tried 'cabal update && cabal upgrade'
09:21:16 <Spark> heh
09:21:17 <chrisdone> anyone know how many bytes per second you can send to freenode before you get excess flood?
09:21:22 <mm_freak_> until now it has never updated a single package
09:21:31 <SamB_XP> chrisdone: I thought it was lines
09:21:34 <mm_freak_> is there some subtle detail i'm overlooking?
09:21:40 <halberd> chrisdone: rule of thumb is 1 line per 2 seconds
09:21:51 <Spark> it is bytes
09:21:59 <Spark> but you ahve to simulate the server pulling stuff out of the buffer
09:22:02 <chrisdone> well, my bot just sent three lines in under a second, no problem
09:22:04 <chrisdone> so it is bytes
09:22:04 <Spark> which it does one line at a time
09:22:09 <halberd> no chrisdone it's averaged
09:22:14 <dcoutts_> mm_freak_: do you think there is anything installed which is not the latest version?
09:22:15 <lambdabot> dcoutts_: You have 1 new message. '/msg lambdabot @messages' to read it.
09:22:18 <Spark> you have to simulate the behaviour of the server
09:22:20 <chrisdone> halberd: what's averaged?
09:22:27 <Spark> but you don't know how loaded the server is so it's generally not possible
09:22:27 <halberd> if you exceed a certain rate over a certain amount of time, that's the problem
09:22:42 <halberd> it's not literally 1 line per 2 seconds, it's more like 5 lines per 10 seconds
09:23:10 <chrisdone> how do you know this?
09:23:22 <Spark> there is a buffer which is usually not changed from the default value
09:23:25 <Spark> but i can't remember what that is
09:23:26 <halberd> I read that that was the usual behavior for an IRC server, somewhere, some time ago
09:23:30 <Spark> you can easily find it by experiment though :)
09:23:57 <Spark> yeah just look at the source code for an ircd
09:24:02 <Spark> or don't because it's usually awful
09:24:19 <Spark> the protocol and implementations are really simplistic so it's usually pretty easy to work out what's going on
09:24:39 <maltem> mm_freak_: are you running cabal upgrade from the same user account as the relevant package db belongs to?
09:24:42 <Raevel> okay this is the closest i've come to finding the theorem so far
09:25:04 <Raevel> oh wait, mayyybe
09:25:58 <chrisdone> ja
09:26:55 <chrisdone> Spark: I set my bot to no more than 512 bytes per five seconds, which actually seems to be sufficient
09:27:11 <halberd> it may have both restrictions
09:27:12 <halberd> bytes and lines
09:27:21 <Raevel> vixey: okay, the proof was 4 pages so i'm not typing it onto irc :-P but: my Myhill-Nerode relations is the key
09:27:34 <Spark> chrisdone: yeah but someone could make it say lots of short lines
09:27:34 <halberd> if you had your bot send a a a a a a a a a a a on separate lines in a short period of time, it might get banned
09:27:37 <vixey> ty
09:27:48 <Spark> chrisdone: it's not bytes per second its lines per second
09:27:56 <Spark> chrisdone: but the maximum amount is in bytes, get it?
09:28:06 <chrisdone> Spark: no
09:28:26 <halberd> most chat clients have built in automatic flood prevention
09:28:37 <halberd> so that if you try to send lines faster than a given rate, it will slow you down
09:28:39 <Spark> lines get sent around, they get peeled off buffers and appended to buffers
09:28:44 <halberd> on the client end
09:28:47 <halberd> so that you don't get banned
09:28:50 <Spark> you choose the rate of appending (in lines per second) the server chooses the rate of stripping
09:28:56 <Raevel> informally, minimize two dfas for the same language and the results will be isomorphic up to the renaming of states
09:29:17 <Spark> but the size of the buffer is measured in bytes, not lines
09:29:38 <Spark> you get penalised for sending short lines, basically
09:29:43 <Spark> as the server will be slower at processing them
09:29:57 <Spark> well it will take the same amount of time per line but there will be more lines to get through to clear a whole buffer
09:30:06 <mm_freak_> dcoutts_: i don't know, really, i just want to make sure i'm doing things right
09:30:06 <Spark> this is why ctcp ping flooding worked so well
09:30:08 <mm_freak_> maltem: sure
09:30:55 <dcoutts_> mm_freak_: assuming you're running a recent cabal-install then I don't know of any particular problems with it
09:31:35 <dcoutts_> mm_freak_: I know that 'cabal upgrade' can often fail to find a consistent install plan for upgrading everything, but that's a different issue
09:31:44 <chrisdone> @all-dicts love
09:31:46 <lambdabot> *** "Love" gcide "The Collaborative International Dictionary of English v.0.48"
09:31:46 <lambdabot> Love \Love\ (l[u^]v), n. [OE. love, luve, AS. lufe, lufu; akin
09:31:46 <lambdabot>    to E. lief, believe, L. lubet, libet, it pleases, Skr. lubh
09:31:46 <lambdabot>    to be lustful. See {Lief}.]
09:31:46 <lambdabot>    1. A feeling of strong attachment induced by that which
09:31:48 <lambdabot> [394 @more lines]
09:31:56 <mm_freak_> does it leave any waste from earlier versions?  i.e. are the updates clean?
09:31:58 <chrisdone> that was a quite a few short lines
09:32:38 <dcoutts_> mm_freak_: what do you mean exactly? it does not uninstall other versions if that's what you mean.
09:34:00 <mm_freak_> yes, that's what i meanâ€¦  if a file from an old version isn't present in a newer version
09:34:04 <mm_freak_> so that file stays?
09:36:50 <pao_> dcoutts_: what do you think about making the cabal-install config file path  configurabile via env var?
09:37:17 <dcoutts_> pao_: which ones? and why? is a config file not good enough?
09:39:18 <pao_> dcoutts_: the default path is .cabal/config. now is overridable only with a command line option. I'm trying to "sand box" a package environment in order to have many of them in parallel, each one not interfering with the others
09:39:57 <pao_> dcoutts_: the rationale is simple to have a "throw away" environment
09:40:03 <pao_> *simply
09:40:08 <dcoutts_> pao_: having an env var to specify the config file seems reasonable, people have asked for that before
09:40:52 <pao_> dcoutts_: would you like to review a patch for that... consider that I'm a newbie
09:41:33 <dcoutts_> pao_: please file a ticket and if possible attach a patch to the ticket
09:41:45 <dcoutts_> pao_: describe the use case / rationale
09:41:50 <pao_> dcoutts_: I'll do it. thanks
09:41:54 <dcoutts_> ta
09:47:54 <pumpkin> yay gpugen is done!
09:49:09 <opqdonut> hmm?
09:49:37 <pumpkin> dons just posted it on hiw twitter: http://www.cse.unsw.edu.au/~chak/papers/gpugen.pdf
09:50:31 <bos> @users
09:50:31 <lambdabot> Maximum users seen in #haskell: 648, currently: 648 (100.0%), active: 19 (2.9%)
09:50:43 <bos> wow, we're way above our recent all-time highs!
09:51:28 <pumpkin> wait, the maximum yesterday said around 670
09:51:32 <pumpkin> did lambdabot forget?
09:51:35 <elbar> twice as many as in #kde ;)
09:52:13 <wchogg> Yeah, I know I've seen more than 648 in the past day or two.
09:53:37 <vixey> I don't think I can write the type I need :(
09:54:00 <vixey> it always comes out as  c -> b -> a -> z  but I need  a -> b -> c -> z
09:54:09 <maltem> pumpkin: the *paper draft* is done :)
09:54:18 <pumpkin> maltem: yeah :) but it's exciting
09:54:26 <maltem> pumpkin: definitely
09:54:26 <int-e> @seen conal
09:54:27 <lambdabot> Last time I saw conal was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #ghc, #haskell,
09:54:27 <lambdabot>  #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.
09:54:27 <lambdabot> jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosxdev, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 6d 21h 1m 16s ago, and .
09:54:45 <int-e> oh. that's a lot of channels
09:56:58 <proq> hrm, real world haskell seems to have missed christmas :(
09:57:50 <Raevel> but why
09:59:09 <mib_81mm1l> i want to create a spell checker in haskell, do you think using a btree is the best way to search thorugh the words?
09:59:32 <int80_h> what about a bloom filter?
09:59:38 <mux> a patricia trie or a DAWG sounds more appropriate
09:59:58 <int80_h> I seem to have read last night in RWH that spell checkers were one application of bloom filters
10:00:10 <int80_h> but it was very very late.
10:00:18 <mux> that sounds right, it rings a bell here, but I have no idea what a bloom filter is
10:00:22 * mux goes to wikipedia
10:00:26 <pumpkin> a DAWG sounds best
10:00:36 <pumpkin> or just a regular trie :)
10:01:00 <pumpkin> space efficient, handy for looking up prefixes and suffixes, AND it's not going to have false positives :P
10:01:28 <int80_h> oh yeah, with a bloom filter you can expect about 1% false positives.
10:01:36 <pumpkin> you can tune them, really
10:01:52 <mux> you can't lookup suffixes with a trie IIRC
10:01:57 <pumpkin> to get an expected number, by adjusting the number of bits, hash functions, and entries you expect to stick in
10:02:01 <mux> only prefixes
10:02:19 <pumpkin> oh yeah, I was talking about a DAWG
10:02:28 <mux> now maybe a bloom filter can help with finding similar words to offer spelling suggestions? a trie wouldn't help much with that
10:02:31 <mux> pumpkin: oh ok
10:02:43 <pumpkin> nah, it wouldn't help with that
10:02:45 <pumpkin> it's completely opaque
10:02:46 <redditbot> xhb: Haskell bindings to the XCB low level X11 layer
10:02:46 <redditbot> Xauth: A binding to the X11 authentication library
10:02:46 <redditbot> Haskell in Iceland: Reykjavik Haskell User Group
10:03:19 <int80_h> what set the redditbot off?
10:03:21 * mux wonders if someone founded the paris haskell user group yet
10:03:24 <pumpkin> it checks rss periodically
10:09:58 <mm_freak_> building gtk2hs fails with:  package.conf.inplace: openBinaryFile: does not exist (No such file or directory)
10:10:04 <mm_freak_> does anyone know that error?
10:10:27 <dcoutts_> mm_freak_: what version of gtk2hs and ghc ?
10:11:14 <mm_freak_> gtk2hs 0.9.12.1 with GHC 6.10.1
10:11:28 <gnuvince_> Is there something in QuickCheck that keeps the value of Ints relatively close to 0?
10:11:35 <dcoutts_> mm_freak_: if you're using ghc 6.10 then you need the darcs version of gtk2hs
10:11:45 <mm_freak_> ok, thanks
10:12:25 * TuringTest notes that the new macbook pro 17" is getting announced
10:12:36 <mux> gnuvince_: there is a size parameter that can be passed to generators, for integers, if you give size n it'll generate a number between -n and n
10:13:19 <gnuvince_> mux: and what is the default value?
10:14:44 <vixey> you can't use where clauses for GADTs.........
10:14:52 <vixey> the types don't work out it all has to be toplevel
10:15:04 <mux> hrmmm, the default is something `div` 2 + 3 :-)
10:16:02 <dons> Cale: interesting, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mathlink-0.1.0.0
10:16:12 <mux> oh
10:16:23 <mux> gnuvince_: number of tests `div` 2 + 3 seems to be the default size
10:17:14 <vixey> does anyone have an idea how to write
10:17:26 <vixey> reverse (a -> b -> c -> z) ~~> c -> b -> a -> z ?
10:18:50 <gnuvince_> mux: ah, I see it.  Thanks for the help.  Trying to get a little something working in Clojure.
10:19:26 <Olathe> @type let reverse f c b a z = f a b c z in reverse
10:19:27 <lambdabot> forall t t1 t2 t3 t4. (t -> t1 -> t2 -> t3 -> t4) -> t2 -> t1 -> t -> t3 -> t4
10:19:55 <vixey> yes but for any length (a -> ... -> z)
10:20:04 <pumpkin> in template haskell?
10:20:08 <Olathe> You'd have to use some weird printf style thing.
10:20:10 <vixey> no
10:20:16 <vixey> no I don't want to use typeclasses
10:21:24 <dons> ?users
10:21:24 <lambdabot> Maximum users seen in #haskell: 651, currently: 648 (99.5%), active: 22 (3.4%)
10:22:25 <chessguy_work> wchogg, got it!
10:22:39 <mux> gnuvince_: you're welcome
10:22:41 <dcoutts_> dons: 600 was only recently passed and now 650
10:22:46 <dons> yep.
10:22:54 <dons> we did 600 on jan 2, 675 yesterday.
10:23:03 <pumpkin> yeah, why doesn't lambdabot remember the 675 yesterday?
10:23:04 * dcoutts_ wonders what is going on
10:23:04 <opqdonut> exponential growth anyone?
10:23:12 <dons> dcoutts_: books/new years resolutions.
10:23:20 <dcoutts_> maybe so
10:23:39 <dcoutts_> dons: more noobs who need the platform...
10:23:50 <dons> yes. #1 priority.
10:23:54 <dons> i'll send you my plan for this todayyy.
10:24:00 <dcoutts_> dons: ok, great
10:24:00 <opqdonut> :)
10:24:10 <dcoutts_> dons: I got my windows account back btw
10:24:21 <dons> we've hit the other targets: 600 users by jan. RWH released. that's the last thing
10:26:05 <vixey> how does GADT pattern matching work?
10:26:16 <vixey> is this all the System Fc stuff going on behind the scenes?
10:26:31 <opqdonut> don't think so
10:26:40 <opqdonut> aiui the type just gets collapsed
10:26:43 <vixey> I'm guessing each match pops out a unification problem in terms of ~
10:26:52 <vixey> and that gets solved, no?
10:27:53 <opqdonut> have you read http://research.microsoft.com/en-us/um/people/simonpj/papers/gadt/
10:28:38 <opqdonut> ah, not refinement was what I meant instead of collapsing
10:28:42 <mux> dons: are you up for helping me understand a huge space leak using Data.Binary and decodeFile?
10:28:50 <dons> mm. sure.
10:29:03 <vixey> if refinement is a unification problem in terms of
10:29:05 <dons> first, you using the latest versions of everything?
10:29:05 <vixey> ~
10:29:17 <vixey> equality constraints... then you can mix type families in with it to?
10:29:26 <mux> this is a bit weird, I've been talking about it in here - basically I have this custom record type containing an Array Int ByteString and a Trie Int
10:29:27 <newsham> vixey: it works!
10:29:34 <mux> (yes, using GHC 6.10.1 and binary 0.4.4)
10:29:39 <dons> ok.
10:29:41 <vixey> hey newsham
10:29:50 <vixey> newsham, just playing with your idea
10:30:04 <mux> dons: Binary instance is the obvious put = put >> put and get = liftM2 Foo get get
10:30:05 <gour> do takusen devs visit this place?
10:30:17 <dons> gour: alistair doesn't, no.
10:30:32 <vixey> newsham, you can really internalize metaprogramming this way it's quite amazing
10:30:51 <mux> dons: my test program just decodes the file and tries to use either the Array or the Trie, and ends up leaking memory like hell (I have to kill it at some point it uses more than 2GB of RAM..)
10:31:08 <newsham> vixey: yes, i'm quite pleased.
10:31:10 <vixey> I got polytypic size, leaves and list all inhabitants
10:31:14 <mux> dons: what's uber-weird (to me), is that if I run "main" in GHCi, I also have the space leak, but if I copy paste the main body, it works!
10:31:22 <dons> mux: does it convert it to a list?
10:31:30 <mux> dons: the array?
10:31:32 <dons> yeah
10:31:43 <dons> i.e. reads it to a giant list, then tries to convert that to an array
10:31:49 <mux> well the Binary instance for Array does basically just that, it puts the bounds and length and then the elements as a list
10:31:55 <newsham> I think dons might find this interesting, since he wrote the Data.Binary stuff
10:31:56 <gour> dons: what about oleg? i got info on cafe that patch is sent to make takusen support 6.10, but it's not applied yet :-/
10:32:12 <mux> which is also a bit weird btw, since you can recover the length from rangeSize bounds
10:32:18 <dons> gour: doesn't use irc
10:32:30 <dons> gour: galois also has a 6.10 patch for takusen
10:32:38 <dons> basically we just throw away support for allt he funky stuff in the Setup.hs
10:33:04 <dons> dcoutts_: cabal hackage server is the other task
10:33:12 <vixey> newsham, oh btw, I think the primitive eliminator should be:  listCase nil cons Nil = nil ; listCase nil cons (Cons x xs) = cons x xs
10:33:12 <dcoutts_> dons: yep
10:33:12 <newsham> dons:  http://www.thenewsh.com/~newsham/x/machine/MarshGADT.hs   see the definition of "mFoo"
10:33:22 <mux> dons: so I have "main = do idx <- decodeFile indexPath; mapM_ (B.putStrLn . snd) (assocs (entries idx))"
10:33:26 <gour> dons: how do you like takusen?
10:33:33 <vixey> newsham, because this + fix, you get primitive recursion, and that means you can write i.e. O(1) pred
10:33:35 <dcoutts_> dons: did you see the cabal2doap announce? it looks like a nice app of the cabal meta-data
10:33:43 <mux> dons: if I run "main" in GHCi, it leaks, if I copy-paste just that very line, it works
10:33:53 <newsham> vixey: hmm.. I dont quite follow, can you be more verbose?
10:34:12 <vixey> newsham, but you can also write size :: f a -> Integer, dfs :: f a -> [a], .. but you're not limited to catamorphic definitions either
10:34:36 <chessguy_work> hey dons you're not doing anything right now are you? :)
10:34:48 <mux> yes he is! he's helping me out :-)
10:35:01 <chessguy_work> haha, he's got like 8 people trying to talk to him at once
10:35:08 * mux nods
10:35:12 <vixey> newsham, going to try and write  f a -> f b -> Maybe (f (a,b)) I think, just tinkering. There is what I have so far: http://muaddibspace.blogspot.com/2009/01/more-gadt-nonsense.html
10:35:15 <roconnor> @go "Church Thesis without tears
10:35:15 <dons> dcoutts_: yes.
10:35:17 <dons> chessguy_work: busy.
10:35:18 <lambdabot> No Result Found.
10:35:22 <dons> mux, it converts to a list though.
10:35:23 <dons> 'assocs'
10:35:34 <chessguy_work> dons, yeah, just kidding
10:35:41 <roconnor> @go "Church's Thesis without tears
10:35:43 <lambdabot> No Result Found.
10:35:53 <mux> dons: right, this is just for testing though, another version that just lookups something in the Trie leaks similarly
10:37:17 <newsham> vixey: its going to take me a while to digest that, will have to look it over later (at work now)
10:37:25 <vixey> ok
10:37:45 <thoughtpolice> gour: yeah I sent in a patch for it
10:37:53 <thoughtpolice> but I guess oleg hasn't applied it yet :(
10:37:55 <vixey> it seems promising method though, like I think you could define the class of functors and write a generic fmap
10:38:14 <vixey> (among other things)
10:38:18 <roconnor> ugh, 1983.  Where am I going to get a pdf?
10:38:46 <mux> dons: according to profiling, the memory is burned up while in the "replicateM length get" call from the Binary instance of Array
10:39:10 <gour> thoughtpolice: nice to see it's alive. it looks like the best database lib for haskell
10:39:35 <opqdonut> which lib?
10:39:42 <gour> takusen
10:39:51 <thoughtpolice> it's very interesting to say the least :)
10:39:58 <thoughtpolice> maybe I should have sent it to alistair instead of oleg...
10:40:09 <gour> :-)
10:40:10 <newsham> vixey: how much of coq can you get w/ the gadts and what are things you cant do?
10:40:14 * mux always mixes takusen up with tasuken
10:40:30 <gour> what is with haskelldb?
10:40:44 <abedra> i think it's pretty much dead
10:41:00 <newsham> actually i should get back to work and not start a major discussion right now :)
10:41:04 <vixey> newsham, well I had no idea getting this generic was possible without typeclasses.. as usual it's tremendously hard in comparison
10:41:11 <gour> ahh, then takusen does not have strong competition
10:41:13 <vixey> (typeclasses or dependent types)
10:41:15 <abedra> i don't think it even compiles on ghc 6.10
10:41:19 <newsham> bbl..  will take this up some more later.
10:41:24 <vixey> cool
10:41:27 <vixey> see you
10:41:43 <thoughtpolice> enumerators are a great idea. i hope to see more of their usage :)
10:41:56 <abedra> reall?
10:41:58 <abedra> really?
10:42:03 <dons> gour: i think hdbc and takusen are the main players.
10:42:07 <vixey> thoughtpolice, do a tutorial about them
10:42:21 <abedra> dons: yeah i think you are correct there
10:42:51 <gour> dons: right, although takusen smells more haskellish
10:42:53 <thoughtpolice> vixey: probably a good idea.
10:42:53 <vixey> newsham, (I think the limit is polymorphic recursive data definitions btw)
10:43:05 <vixey> thoughtpolice: and link me once you did :p
10:43:08 <chessguy_work> thoughtpolice, and send the link to -cafe
10:43:24 <vixey> no idea how to deal with polymorphic recursions
10:43:27 <int80_h> is there a library that would allow me to create a map, like in google maps? Where you can click and drag, and move around the map?
10:43:30 <gour> thoughtpolice: plain takusen tutorial would be nice as well in the RWH style ;)
10:43:53 <mux> int80_h: the google maps API? :-)
10:44:06 <mux> you can use custom maps with it, and custom overlays and stuff
10:44:13 <mux> it's quite nice
10:44:20 <int80_h> well, that was just an example. I want to map the celestial sphere.
10:44:25 <dublpaws> anyone know of a visualization tool for haskell source that outputs .dot files for import, functions call.. etc graphs?
10:44:37 <chessguy_work> you could build a haskell combinator library that outputs the appropriate JS :)
10:44:42 <mux> heh
10:44:53 <int80_h> I just wanted to get across the idea that I wanted a map that you could move around, like the google map.
10:44:54 <amaron> what about HDBC?
10:45:00 <thoughtpolice> dublpaws: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/graphmod
10:45:05 <dublpaws> thanks thoughtpolice
10:45:16 <int80_h> chessguy: nice. that's what I wanted to know
10:45:17 <thoughtpolice> dublpaws: also this might interest you - http://hackage.haskell.org/cgi-bin/hackage-scripts/package/SourceGraph
10:45:38 <dublpaws> ooo, more eye candy, :D...
10:46:07 <gour> amaron: it's nice lib, although not so type-safe as takusen, afaik
10:46:51 <amaron> gour, I see... except that, do you find takusen most complete?
10:47:20 <amaron> I allways thought haskell isn't db ready yet
10:48:36 <gour> amaron: did not try it (yet), just read about it...otoh, i believe time is ready to make haskell db-ready, isn't it?
10:48:36 <amaron> other day I wrote some small util which manipulate access db via odbc, using hdbc
10:48:46 <dons> ?bug
10:48:46 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
10:48:47 <amaron> i had problems with parameters
10:49:50 <gour> amaron: i wonder how one can insert blob into sqlite with hdbc...
10:50:14 <amaron> gour, sure. I also think haskell can use databases in more efficient way than imperative langs, with some better aproach
10:50:56 <amaron> gour, hdbc have cast functions for every type
10:50:59 <gour> amaron: right, let's hope that instead of half-dozen half-finished libs, something stable/useful will emerge
10:51:03 <amaron> let me check...
10:51:26 <amaron> gour, i realy need that. I have many project I can do with dbs and haskell
10:51:32 <gour> i've asked on hdbc forum, but it's not very populated place
10:51:40 <gour> me too
10:51:51 <gour> need database back-end for gui app...
10:51:56 <amaron> bad thing is that someone makes a lib then leave it
10:52:02 <gour> yep
10:52:38 <gour> that's why 'haskell platform' is important to have real-world libs ready, i.e. "batteries included"
10:52:49 <gour> amaron: do you have need for i18n?
10:53:21 <amaron> gour, yes i need that for european languages
10:54:12 <gour> amaron: how do you plan to do it? afaik, eg. there is no proper gettext support (in e.g. gtk2hs)
10:54:18 <amaron> i even recondsider using f# and .net for my projects, but i dislike ms
10:54:40 <gour> i do not even consider m$, running linux-only
10:54:42 <amaron> gour, i dont know yet
10:55:07 <gour> amaron: ask dons how to do it or you will move to f# and .net :-D
10:55:09 <amaron> great, I prefer that too, but this was job for win, and access database, so i had no choice
10:55:30 <gour> i might also release app for win, gtk2hs is capable of that
10:55:52 <gour> but won't develop under win...
10:55:57 <mux> dons: so, any idea what I could try to understand what's going on?
10:56:44 <pumpkin> to get variance out of the hstats package, is the only way to call covariance of my data with itself?
10:56:48 <pumpkin> that seems a little odd
10:57:11 <vixey> amaron, regardless of ms, there is nothing original (i.e. it's recycled ideas only) in f# or .net
10:57:17 <pumpkin> I guess I could also square the standard deviation
10:57:26 <amaron> gour, unfortunately many contracts i make require win as platform
10:57:51 <amaron> vixey, I saw something they call pipeline
10:58:02 <pumpkin> oh, they just didn't document the variance call for some reason
10:58:11 <amaron> vixey, looks something similar to >>=
10:58:25 <amaron> but without monads
10:59:24 <amaron> vixey, and orginality is not what I need, its useability and fast development
10:59:35 <amaron> but as I said I prefer not to use it
11:00:47 <gour> amaron: i understand. np. still, if haskell-linux would be i18n and/or db-ready, it would equally apply to ms platform, ie. win/win ;)
11:01:28 <amaron> gour, sure thing I prefer linux too, but if client requests win app, then you have no choice
11:02:08 <gour> yep
11:02:50 <redditbot> Haskell FFI to Mathematica: call Haskell functions from Mathematica
11:03:28 <oklofok> amaron: |> looks to me like just a notation for function composition
11:04:23 <vixey> oklofok, I imagine it's to accomodate the OO folk that write  object.field.method()
11:04:43 <vixey> the functional version is: object |> field |> method
11:05:11 <oklofok> looks more like A |> B = B A
11:05:29 <oklofok> err or did you mean usage?
11:05:31 <oklofok> hmm
11:05:39 <vixey> I was making fun of F#
11:05:44 <vixey> or trying at least..
11:06:07 <oklofok> oh, right, i usually just laugh at my own jokes.
11:06:16 <oklofok> ohhh
11:06:20 <oklofok> now i get it lol :Ds
11:06:31 * oklofok is slow
11:06:52 <vixey> (I think that people have problems with (c <- b) -> (b <- a) -> (c <- a), and flipping the arrows makes it 'easier'. But this is "easier" because it's gives you a procedural way to look at something)
11:07:02 <vixey> so in the long run I think stuff like |> is harmful
11:07:40 <pumpkin> what does |> do?
11:07:47 <vixey> a chain of |>'s is a sequential execution
11:07:51 <pumpkin> ah
11:07:57 <pumpkin> like >> ?
11:08:11 <amaron> pumpkin, it pipes ouput of one function to input of another
11:08:14 <pumpkin> ah
11:08:15 <vixey> a chain of (.) is composition which is supposed to be declarative
11:08:45 <oklofok> amaron: i don't think that's all that close to monads.
11:09:03 <vixey> what I meant is: f . g . h  is declarative whereas  h |> g |> f  is viewed procedurally
11:09:33 <oklofok> vixey: yes you get functional without the headache!
11:09:42 <vixey> (and procedural functional programming should die)
11:10:07 <pumpkin> what falls into that category?
11:10:13 <pumpkin> (what languages)
11:10:16 <oklofok> scheme?
11:10:22 <vixey> but a lot of people are used to C or Java or whatever and only want to learn a small number of thigs
11:10:42 * oklofok goes
11:11:13 <olsner> meh, learning a completely different way to think is much more fun!
11:11:24 * vixey agreed
11:11:34 <monochrom> people don't want fun. they just want to get their job done.
11:11:39 <pumpkin> I want fun
11:11:57 <amaron> i want fun, but often i have to have job done fast
11:12:18 <oklofok> i want fun, but i consider learning a greater goal, getting something done isn't really even on the list :P
11:12:24 <monochrom> and "job" means they don't care, just want to get paid. their idea of fun is vacation.
11:12:35 <amaron> I prefer haskell over anything else, although im still a noob
11:13:33 <amaron> monochrom, if you dont have fun on your job, and only do it for money it becomes very very boring
11:13:46 <wchogg> amaron : or maddening
11:13:53 <monochrom> you are preaching to the theologian.
11:14:20 <amaron> amen
11:14:26 <monochrom> I know, but most people do it and they just live with it.
11:14:47 <wchogg> monochrom : I find this conversation oddly comforting.  Sometimes I thought it was just me.
11:14:50 <amaron> monochrom, yes if you accept to live like a zombie
11:15:02 <monochrom> That is still not true.
11:15:19 <monochrom> Look at them during Christmas break. They're alive again.
11:15:55 <monochrom> Their day job is a drag. They do it just for the money. Their aspiration is "so I have money for vacation and retirement"
11:15:57 <amaron> well I'm allways talking from my own point of view, and my own experience
11:16:16 <amaron> doesn't means its same for everyone
11:16:44 <monochrom> Their greatest joy is in having grandchildren.
11:16:59 <wchogg> amaron : right.  I don't think it's _wrong_ for people to just do work they don't like in order to have money.  I just can't do it myself.
11:17:03 <amaron> monochrom, in this world you need money to survive
11:18:06 <monochrom> Programming is just the day job. The day job is a drag. It is done just for the money. They need the money because they want to live long enough to see their grandchildren. That is all. Their fun is in their grandchildren. They don't want fun in programming.
11:18:42 <monochrom> (It even makes evolution sense.)
11:19:31 <amaron> monochrom, you are right, but it isn't same for every programmer, i worked in many firms and there are many different ppl with different approach to life, job and programming
11:20:00 <int80_h> In RWH, Pg. 60 exercise one, could someone give me an example of the output should look like?
11:20:32 <monochrom> I indulge in this off-topic-ness because it explains why I am against evangelizing Haskell. Do promote Haskell, but don't argue with people who aren't interested. Promote, just focus on those who are interested.
11:20:41 <int80_h> I'm confused because I thought [a] = List a
11:20:54 <vixey> int80_h, List doesn't exist
11:21:07 <vixey> oh
11:21:10 <int80_h> It's a type in RWH
11:21:13 <vixey> if it's some book maybe they have defined it
11:21:37 <kosmikus> it's a type isomorphic to []
11:21:37 <amaron> monochrom, its very hard not to talk about it, I even talk about it to my gf, who is psychologist
11:22:20 <monochrom> Talk, but don't argue.
11:22:21 <kosmikus> so you're supposed to write a function that takes, say, Cons 3 (Cons 4 Nil) to [3,4] ...
11:22:46 <SamB_XP> if you just want to get the next small job done, I guess Haskell isn't for you
11:23:05 <int80_h> kosmikus: thanks
11:23:18 <SamB_XP> (unless you already know it ;-)
11:23:50 <int80_h> I want to write libraries that help people get the next small job done faster than the competition.
11:24:20 <int80_h> this looks like a job for ... haskell!
11:24:35 <amaron> SamB_XP, it's not what I 'just' want, I love haskell and enjoy learning it. But sometimes I have to small jobs in order to live, and I would like to do it with haskell
11:24:53 <amaron> *to do
11:25:00 <SamB_XP> amaron: I wasn't actually talking about you
11:26:29 <amaron> :)
11:35:14 <mux> wow, QuickCheck shipped with GHC 6.10.1 is old, 1.2.0.0
11:35:26 <mux> it doesn't seem to have vectorOf
11:35:48 <Deewiant> many things depend on quickcheck<2
11:35:53 <dons> mux: that's not old. just stable.
11:36:07 <mux> alright
11:37:22 <roconnor> not just old, stable -- fixed that for you. :)
11:37:44 * roconnor remembers stable debian
11:38:31 <dons> its the latest stable release. only a few weeks old.
11:42:30 <roconnor> dons: oh
11:42:33 <roconnor> my bad
11:45:26 <mux> dons: any idea about that space leak problem?
11:46:04 <p_l> some code is stable, full featured, supported etc. for years, then a GNU freak comes and decides it needs autotools...
11:46:38 <dons> mux, no, sorry, at work == too busy.
11:46:41 <dons> avoid lists.
11:46:46 <mux> okay :-)
11:48:55 <monochrom> If you use Haskell, the GNU freak will not touch it. :)
11:50:59 <p_l> monochrom: Unfortunately Haskell is not yet as portable as C. Though it beats C hands down when it comes to language itself :)
11:57:26 <pumpkin> .com
12:00:52 <paper_cc> er?
12:01:03 <pumpkin> whoa, not sure where that came from
12:01:17 <paper_cc> cat typing =)
12:01:22 <pumpkin> mrrowl
12:01:23 <pumpkin> meow
12:01:25 <pumpkin> prrr
12:01:35 <pumpkin> it'd be funny if a cat really typed that
12:02:51 <redditbot> cabal2doap: Cabal interface to the semantic web
12:02:51 <redditbot> Speeding up instances: hoist recursion out of class dictionaries
12:09:53 <int80_h> My code for ex. 1 on page 60 of RWH is broken. This is the code
12:09:56 <int80_h> toList []      = Nil
12:09:59 <int80_h> toList (x:xs)  = x + (toList xs)
12:10:05 <int80_h> and this is how it breaks
12:10:07 <vixey> (+) ??
12:10:52 <int80_h> Couldn't match expected type `[List a]' against inferred type `List Ch
12:11:03 <vixey> what's (+)?
12:11:30 <oshyshko> I am looking for a way to store/load objects on disk. Something like BerkleyDB or db4o. Something with seamless/easy intergration with Haskell. Where should I dig?
12:11:43 <int80_h> mmm...okay + wants a type Num
12:11:55 <vixey> what are you doing with +?
12:11:58 <int80_h> I thought ++ was the right operator, but that didn't work either
12:12:00 <mux> didn't you mean `Cons` ?
12:12:12 <int80_h> no, I need to take a cons, and construct a list
12:12:13 <gour> oshyshko: have you thought about sqlite3?
12:12:22 <vixey> int80_h, so where is Nil from?
12:12:32 <paper_cc> int80_h: List a = Nil | Cons a (List a)?
12:12:35 <paper_cc> That list?
12:13:11 <int80_h> paper_cc yeah, that list
12:13:13 <gour> oshyshko: or maybe http://hackage.haskell.org/cgi-bin/hackage-scripts/package/anydbm
12:13:26 <paper_cc> then you want to construct it with its constructors
12:13:35 <paper_cc> either Nil or Const
12:13:39 <paper_cc> s/Const/Cons/
12:13:48 * paper_cc hates C99 keywords
12:13:52 <int80_h> Const? I didn't see any reference to Const
12:13:58 <int80_h> ooh Cons
12:13:59 <paper_cc> sorry, Cons
12:14:20 * vixey could write... foldr Cons Nil
12:14:35 <int80_h> Don't think we can use foldr yet
12:14:44 * vixey can though :p
12:14:52 <paper_cc> so you write a foldr yourself =)
12:15:22 <int80_h> paper_cc, hmm I think I may be able to do that with what's given so far.
12:16:05 <paper_cc> int80_h: in fact, you're now writing a specialized version of foldr =) you're all right though
12:16:12 <paper_cc> then toList :: [a] -> List a
12:16:23 <paper_cc> so the RHS of toList (x:xs) should be a List
12:16:36 <int80_h> RHS?
12:16:42 <paper_cc> right-hand side
12:16:49 <luite_> > let p = (<2) in (\x -> if p x then 0 else 1) <$> [1,2,5] -- is there a nicer way (points free?) to write the if/then/else in this kind of situation?
12:16:50 <lambdabot>   [0,1,1]
12:17:17 <int80_h> paper_cc, nice. Okay thanks for the direction.
12:17:18 <saml> luite_, filter?
12:17:25 <saml> > filter (<2) [1,2,5]
12:17:27 <lambdabot>   [1]
12:17:35 <luite_> saml: that's quite different :)
12:17:51 <oshyshko> gour: sqlite3 needs to be aware of tables/rows etc. if I understand it right. I am looking for something like Java Serialization - where you save/load objects - and the library takes care about everything (structure, object graphs, references etc). So entire API is about 2 functions: save(graph,stream), load(stream):graph
12:17:54 <int80_h> @src foldr
12:17:55 <lambdabot> foldr f z []     = z
12:17:55 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:17:56 <saml> > map (\x -> if x < 2 then 0 else 1) [1,2,5]
12:17:57 <luite_> I really need the if/then/else
12:17:58 <lambdabot>   [0,1,1]
12:17:59 <rwbarton> > map fromEnum [False, True] -- but I think this can only lead to more obscure code
12:18:01 <lambdabot>   [0,1]
12:18:15 <asgaroth> @pl \x -> if x < 2 then 0 else 1
12:18:16 <lambdabot> flip (flip if' 0 . (< 2)) 1
12:18:21 <saml> if then else point free?
12:18:29 <asgaroth> not very readable
12:18:37 * int80_h cackles
12:18:42 <rwbarton> > map (fromEnum . not . (< 2)) [1,2,5]
12:18:44 <lambdabot>   [0,1,1]
12:18:58 <paper_cc> grr
12:19:10 <int80_h> what, did I cheat?
12:19:16 <luite_> rwbarton: hehe, I should have used a better example, that has less shortcuts to exploit ;)
12:19:43 <luite_> @src if'
12:19:44 <lambdabot> Source not found. Sorry.
12:19:48 <paper_cc> int80_h: no. that point-less stuff is pretty unreadable for me =(
12:19:57 <Olathe> > 5
12:19:59 <lambdabot>   5
12:20:35 <saml> > map f [x, y, z]
12:20:36 <lambdabot>       Ambiguous occurrence `x'
12:20:36 <lambdabot>      It could refer to either `L.x', defined a...
12:20:47 <rwbarton> > map ((["foo", "bar"] !!) . fromEnum . not . (< 2)) [1,2,5]   -- you can write arbitrarily ugly code
12:20:49 <lambdabot>   ["foo","bar","bar"]
12:21:29 <rwbarton> I guess a  Map Bool a  could be reasonable
12:21:34 <paper_cc> @ty fromEnum
12:21:35 <lambdabot> forall a. (Enum a) => a -> Int
12:21:42 <saml> > fromEnum 'a'
12:21:43 <lambdabot>   97
12:22:07 <paper_cc> > let factorial n = product [1..n] in fromEnum $ factorial 100
12:22:09 <lambdabot>   0
12:22:15 <paper_cc> it clamps?
12:22:16 <vixey> lol
12:22:19 <vixey> at 0
12:22:23 <rwbarton> defaulting to Int
12:22:25 <mux> http://hpaste.org/13685 -- quickCheck tests for Data.Trie
12:22:26 <oshyshko> gour: I found what I was looking for: http://en.wikipedia.org/wiki/Serialization#Haskell
12:22:31 <saml> > fromEnum 34573985734895759564932652386489623894689589135417892346238956239
12:22:32 <vixey> > let factorial _ = 0 in factorial 332
12:22:32 <lambdabot>   208510743812338383
12:22:33 <lambdabot>   0
12:22:42 <mux> I had to use quite some newtype's to generate strings like I wanted, I'm curious to know if I've done this right
12:22:46 <saml> > maxBound :: Int
12:22:48 <lambdabot>   9223372036854775807
12:22:54 <vixey> > let factorial n = product [1..n] in fromEnum $ factorial 99
12:22:55 <lambdabot>   0
12:22:59 <vixey> > let factorial n = product [1..n] in fromEnum $ factorial 80
12:23:01 <lambdabot>   0
12:23:02 <vixey> > let factorial n = product [1..n] in fromEnum $ factorial 20
12:23:03 <lambdabot>   2432902008176640000
12:23:06 <vixey> > let factorial n = product [1..n] in fromEnum $ factorial 30
12:23:07 <lambdabot>   -8764578968847253504
12:23:17 <vixey> > let factorial n = product [1..n] in fromEnum $ factorial 60
12:23:19 <lambdabot>   -8718968878589280256
12:23:22 <paper_cc> unhandled overflows =(
12:23:23 <gour> oshyshko: have you looked at anydbm?
12:23:23 <vixey> > let factorial n = product [1..n] in fromEnum $ factorial 75
12:23:25 <augustss> fromEnum is a little dodgy
12:23:25 <lambdabot>   0
12:23:50 <augustss> It makes no sense for Integer
12:23:52 <rwbarton> paper_cc: No, it's type defaulting to Int
12:23:55 <rwbarton> I think?
12:24:02 <rwbarton> Oh, I'm wrong
12:24:11 <rwbarton> It should be type defaulting to Int, and giving the same answer :)
12:24:12 <vixey> > let factorial n = product [1..n] in fromEnum $ factorial 65
12:24:14 <lambdabot>   -9223372036854775808
12:24:16 <vixey> > let factorial n = product [1..n] in fromEnum $ factorial 70
12:24:18 <lambdabot>   0
12:24:20 <vixey> > let factorial n = product [1..n] in fromEnum $ factorial 66
12:24:21 <lambdabot>   0
12:24:24 <vixey> > let factorial n = product [1..n] in fromEnum $ factorial 63
12:24:26 <lambdabot>   1585267068834414592
12:24:59 <paper_cc> > fromEnum 100 :: Integer
12:25:00 <lambdabot>   Couldn't match expected type `Integer' against inferred type `Int'
12:25:06 <vixey> > let factorial n = product [1..n] in fromEnum $ factorial 64
12:25:08 <lambdabot>   -9223372036854775808
12:25:08 <paper_cc> :t fromEnum
12:25:09 <vixey> > let factorial n = product [1..n] in fromEnum $ factorial 65
12:25:09 <lambdabot> forall a. (Enum a) => a -> Int
12:25:10 <lambdabot>   -9223372036854775808
12:25:14 <vixey> > let factorial n = product [1..n] in fromEnum $ factorial 66
12:25:16 <lambdabot>   0
12:25:19 <paper_cc> rwbarton: It's hardwired to Int =(
12:25:20 <vixey> :t let factorial n = product [1..n] in fromEnum $ factorial 66
12:25:21 <lambdabot> Int
12:25:28 <vixey> ^ why you should not use Int?
12:25:40 <vixey> > product [1..66::Int]
12:25:41 <lambdabot>   0
12:26:03 <drdozer> > product [1..66::Integer]
12:26:04 <lambdabot>   544344939077443064003729240247842752644293064388798874532860126869671081148...
12:26:06 <rwbarton> paper_cc: for efficiency reasons I guess... seems lame to me :P
12:26:10 <vixey> > product [1..66::CReal]
12:26:12 <lambdabot>   544344939077443064003729240247842752644293064388798874532860126869671081148...
12:26:31 <drdozer> it defaults because you've asked for an actual value but the operations here are defined only in classes
12:26:43 <oshyshko> gour: anydb page says it stores String->String maps only (is this correct?), but I need Id->Object
12:26:43 <drdozer> so it either would have to say 'provide an instance please' or it has to guess one
12:26:58 <drdozer> in interpreted mode, guessing is usually the right thing to do
12:27:09 <drdozer> in compiled code, complaining is the right thing IMHO
12:27:15 <rwbarton> drdozer: agreed
12:27:27 <gour> oshyshko: no idea. never tried it
12:27:47 <paper_cc> oshyshko: do you need DBs or serialization?
12:27:49 <rwbarton> drdozer: although here, the argument to fromEnum is defaulting to Integer.  It's the Enum Integer instance that's the problem, truncating Integer -> Int
12:27:50 <drdozer> it would perhaps  be polite of the interpreter to note that it did make an arbitrary choice
12:28:17 <pumpkin> is there some way I can request an insertion sort, to get lazy behavior? :P
12:28:23 <Philonous> > let select (x,_) True = x; select (_,y) False = y in select (0,1) <$> (<3) <$> [1..5] -- not exactly point free, but the select function is like the church encoding for true and false, so mabye it could be included in some standard header ;)
12:28:24 <lambdabot>   [0,0,1,1,1]
12:28:59 <paper_cc> Philonous: err, select = uncurry if'
12:29:13 <paper_cc> oh, sorry
12:29:13 <Philonous> @src if'
12:29:13 <lambdabot> Source not found.
12:29:17 <paper_cc> :t if'
12:29:19 <lambdabot> Not in scope: `if''
12:29:26 <pumpkin> only in @pl's imagination
12:29:29 <paper_cc> , if' True 1 2
12:29:35 <lunabot>  luna: Not in scope: `if''
12:29:40 <augustss> Philonous: it should be called bool, like 'maybe' and 'either'.
12:30:11 <pumpkin> > let bool True x _ = x; bool False _ y = y in bool True 1 2
12:30:12 <lambdabot>   1
12:30:29 <Philonous> @src maybe
12:30:30 <lambdabot> maybe n _ Nothing  = n
12:30:30 <lambdabot> maybe _ f (Just x) = f x
12:30:44 <Philonous> Fair enough,
12:30:45 <rwbarton> > let bool false _ False = false; bool _ true True = true in bool 1 2 True -- should be like this I think
12:30:46 <lambdabot>   2
12:30:58 <oshyshko> paper_cc: I need a simple and fast approach save/fetch object graphs by an ID (just 2 operations). I think I don't need SQL or ORM stuff.
12:31:06 <pumpkin> rwbarton: true :)
12:32:06 <oshyshko> paper_cc: Kind of Java Map<Long, Object> with put/get functions that save stuff to disk.
12:32:14 <Philonous> rwbarton: Church encoding is the other way around iirc.
12:32:35 <rwbarton> Philonous: I'm just matching the order of the constructors
12:32:37 <rwbarton> @src Bool
12:32:37 <lambdabot> data Bool = False | True deriving (Eq, Ord)
12:32:39 <rwbarton> @src Maybe
12:32:40 <lambdabot> data Maybe a = Nothing | Just a
12:32:42 <rwbarton> @src maybe
12:32:42 <lambdabot> maybe n _ Nothing  = n
12:32:42 <lambdabot> maybe _ f (Just x) = f x
12:32:44 <rwbarton> etc.
12:32:49 <Philonous> ok
12:32:55 <paper_cc> oshyshko: Data.Map and Data.Binary?
12:33:16 <drdozer> Data.Map is a datatype, rather than a class, right?
12:33:23 <rwbarton> drdozer: Yes
12:33:37 <sjanssen> Data.Map is a module
12:33:43 <sjanssen> Data.Map.Map is a data type
12:33:44 <rwbarton> drdozer: Well, Data.Map is a module.  Data.Map.Map is a type constructor
12:34:06 <drdozer> that's kind of annoying - I often have code where I need a map-ish entity, but don't want to specify the concrete implementation
12:34:09 <mux> @check \m -> maybe Nothing Just m == m
12:34:11 <lambdabot>   "OK, passed 500 tests."
12:34:22 <sjanssen> drdozer: see edison on hackage
12:35:00 <pumpkin> if I have a dataset with unit variance, subsets of that dataset can still have greater than unit variance, right?
12:35:08 <pumpkin> (just making sure I'm not crazy)
12:35:18 <rwbarton> pumpkin: Sure
12:35:22 <pumpkin> ok :P
12:35:23 <pumpkin> thanks :)
12:36:18 <SamB> thoughtpolice: what's the story on how to build LHC at the moment ?
12:36:34 <pumpkin> it's offline for another several months
12:36:45 <pumpkin> no black holes this quarter :(
12:36:53 <paper_cc> @seen thoughtpolice
12:36:53 <lambdabot> thoughtpolice is in #haskell-blah, #ghc and #haskell. I last heard thoughtpolice speak 1h 51m 36s ago.
12:37:28 <SamB> pumpkin: not THAT one
12:37:30 <SamB> the compiler
12:38:21 <pumpkin> ah :)
12:38:35 <pumpkin> looks like mr L just arrived!
12:38:46 <SamB> Lemmih: okay, you can tell me the story on building LHC, then
12:39:09 <SamB> since, you know, cabal-install isn't compatible with Cabal 1.7 anymore
12:39:19 <dcoutts_> yet
12:39:27 <SamB> both!
12:39:29 <drdozer> thx sjanssen
12:39:32 <dcoutts_> not anymore, since it never has been updated for Cabal-1.7
12:39:45 <dolio> Change the .cabal file to allow 1.7.
12:39:50 <dolio> It worked for me. :)
12:39:53 <SamB> dolio: it's not that simple anymore
12:39:55 <dcoutts_> dolio: and fix the compile errors
12:40:17 <dolio> Download cabal 1.7 from 3 weeks ago, then. :)
12:40:26 <oshyshko> paper_cc: I believe I don't need Map. Because its immutable. I don't need a class/structure, I need 2 functions: "save::Storage->Int->?->IO" + "load::Stoeage->Int->IO ?" where Storage is some kind of handle (bound to a file, some kind of blackboxed DB - whatever).
12:41:01 <Lemmih> SamB: I'd wait until the next Cabal is out.
12:41:12 <drdozer> mm - looks like Data.Tree.AVL isn't indexed by hoogle or Hayoo
12:42:02 <geezusfreeek> haskell has made my C more awesome to me and less awesome to my coworkers
12:42:02 * paper_cc searches for a Haskell BSDDB binding
12:42:22 * Botje read that as BOOBS
12:42:31 * Botje is not on the ball today.
12:42:38 <drdozer> so this save/load thing reminds me of something I couldn't figure out how to do with haskell
12:43:24 <pumpkin> anyone remember what that "generalized disk-based b-tree" project related to postgres was called?
12:43:55 <SamB> Lemmih: so are you using TH ?
12:43:58 * geezusfreeek just did something like "((n ? f : f')(var) ? foo : ((n ? g : g')(var) ? bar : baz))(var1, var2, var3);"
12:44:31 <paper_cc> @hoogle berkleydb
12:44:32 <lambdabot> No results found
12:44:45 <paper_cc> @Hoogle berkeleydb
12:44:45 <lambdabot> Maybe you meant: google hoogle
12:44:51 <paper_cc> @hoogle berkeleydb
12:44:51 <lambdabot> package BerkeleyDB
12:45:03 <paper_cc> oshyshko: ^ that one?
12:45:12 * Lemmih wonders if his message got through.
12:45:21 <int80_h> no, don't think so
12:45:23 <mmmurf> hello, not sure if anyone feels like addressing a beginner question, but i seem to have run into a case where haskell is not automatically coercing numeric types:  the following expression is causing an error b/c I can't divide it by 2 due to a type error:  abs( (fst x) - (snd x))
12:45:29 <Lemmih> SamB: Only for deriving stuff, I think.
12:45:33 <int80_h> lemmih, I just got RWH :)
12:45:49 <Nafai> int80_h: Yay!  I got mine a week ago.  Loving it so far.
12:45:52 <geezusfreeek> :t abs( (fst x) - (snd x))
12:45:53 <lambdabot>     Ambiguous occurrence `x'
12:45:53 <lambdabot>     It could refer to either `L.x', defined at <local>:11:0
12:45:53 <lambdabot>                           or `SimpleReflect.x', imported from SimpleReflect at /home/cale/.lambdabot/State/L.hs:73:0-32
12:45:55 <rwbarton> mmmurf: that's right, haskell does not automatically coerce numeric types
12:46:00 <geezusfreeek> :t \x -> abs( (fst x) - (snd x))
12:46:01 <lambdabot> forall b. (Num b) => (b, b) -> b
12:46:03 <int80_h> Nafai: me too. :)
12:46:19 <rwbarton> mmmurf: You probably want to wrap that expression in fromInteger or fromIntegral
12:46:22 <paper_cc> mmmurf: well, Haskell is never coercing numeric types
12:46:38 <pumpkin> aha, GiST
12:46:42 <Lemmih> int80_h: Good for you. Let me configure that account for you.
12:46:44 <mmmurf> ahh ok fromInteger or fromIntegral ... I'll try that...
12:46:55 <int80_h> from what I read, Haskell doesn't do coercion on any data types
12:47:03 <augustss> That's right
12:47:08 <geezusfreeek> :t unsafeCoerce
12:47:09 <lambdabot> Not in scope: `unsafeCoerce'
12:47:15 <int80_h> RWH recommends that coersion happens at the function level.
12:47:16 <paper_cc> @hoogle Typeable
12:47:17 <lambdabot> module Data.Typeable
12:47:17 <lambdabot> Data.Typeable class Typeable a
12:47:17 <lambdabot> Data.Typeable class Typeable1 t
12:47:18 <paper_cc> =)
12:47:18 <pumpkin> defaulting seems closest
12:47:18 <geezusfreeek> ^ exists, i promise. just don't use it!
12:47:23 <pumpkin> but not coercion
12:47:52 <rwbarton> Overloaded numeric literals can give the illusion of coercion
12:48:04 <pumpkin> :t 5
12:48:05 <lambdabot> forall t. (Num t) => t
12:48:15 <geezusfreeek> :t 5 :: Int
12:48:16 <lambdabot> Int
12:48:18 <mmmurf> hmm fromInteger and from Integral both result in an error message
12:48:20 <geezusfreeek> :t 5 :: Word8
12:48:20 <int80_h> Lemmih: thanks man. I really appreciate it.
12:48:21 <lambdabot> Word8
12:48:32 <paper_cc> mmmurf: what's the type of 'x'?
12:49:25 <Saizan> mmmurf: better to paste the code on hpaste.org, with the error message
12:49:37 <int80_h> happs_tutorial wants ghc 10x to run and I'd rather do that on your server than port ghc 10 to netbsd right now. Don't want to get distracted from my goals.
12:50:08 <oshyshko> paper_cc: this is it! thank you
12:50:11 * int80_h is easily distracted.
12:50:36 <mmmurf> paper_cc: Integer
12:50:40 * geezusfreeek just recommend rwh to a coworker, yay
12:50:40 <mux> the quickcheck + HPC combo is totally marvelous
12:50:56 <mmmurf> trying hpaste.org
12:51:00 <paper_cc> mmmurf: maybe (Integer, Integer)?
12:52:13 <paper_cc> BTW is there an easy^H^H^H^Hreasonable way to build Yampa on ghc 6.8.2?
12:53:24 <RayNbow> luite_
12:53:31 <RayNbow> @let churchBool b | b = const | not b = const id
12:53:32 <lambdabot>  Defined.
12:53:39 <RayNbow> > (($ (10,20)) . uncurry . churchBool . (<2)) <$> [1,2,3]
12:53:40 <lambdabot>   [10,20,20]
12:54:19 <mmmurf> here is the hpaste: http://hpaste.org/13686
12:54:22 <RayNbow> so churchBool basically turns True into \x y -> x and False into \x y -> y :p
12:54:42 <wchogg> paper_cc cabal install didn't work?
12:54:47 <luite_> RayNbow: sounds nifty, but in practice, less so?
12:54:55 <SamB> Lemmih: arg, why do I still get this error
12:54:57 <Lemmih> int80_h: My box is quite slow. I doubt compiling HAppS applications on it will be pleasant.
12:55:01 <SamB> Setup: /usr/lib/lhc-0.6/package.conf: openFile: does not exist (No such file or directory)
12:55:11 <RayNbow> luite_: why's that?
12:55:14 <augustss> mmmurf: missing parens
12:55:38 <mmmurf> augustss: that would be nice, let me try...
12:55:53 <luite_> RayNbow: I mean that the example code doesn't actually look more readable than te if/then/else, and isn't shorter either
12:55:56 <mmmurf> augustss: you seem to be right
12:55:56 <augustss> mmmurf: around the abs call
12:55:57 <mmmurf> :)
12:56:19 <mmmurf> augustss: i thought there was no ambiguity in the expression, oh well
12:56:24 <monochrom> geezusfreeek: Your conditional choice of functions to call is awesome!
12:56:33 <augustss> mmmurf: also, since you are using fst and snd, I think you should be using pattern matching somewhere to take x apart
12:56:35 <geezusfreeek> monochrom, thanks!
12:57:06 <paper_cc> wchogg: in fact, I didn't try Cabal. I just got disappointed when I tried to build the ZIP from the paper
12:57:18 <Lemmih> SamB: The package handling code is quite naive.
12:57:28 <saml> > let diff (a,b) = abs (a - b) in diff (34,235)
12:57:29 <lambdabot>   201
12:57:37 <mmmurf> augustss: ahh ok, i know (x:xs) to take apart a list but i'm currently not aware of how to do pattern matching to take apart the tuple too... I probably need to re-read that section of the book
12:57:47 <wchogg> paper_cc the one on hackage should work with cabal install
12:57:55 <augustss> mmmurf: (a,b)
12:58:07 <wchogg> paper_cc At least it should...I helped make sure it worked on 6.8 & 6.10
12:58:21 <mmmurf> augustss: ahh... do you know if it can be nested? as in ((a,b):(xs)
12:58:23 <paper_cc> wchogg: hmm, it did build. The question now is where I'm going to get the robot soccer examples from the paper =(
12:58:28 <augustss> mmmurf: yes
12:58:33 <mmmurf> augustss: ahh awesome
12:58:39 <rwbarton> mmmurf: There is never any ambiguity.  It's just the parse isn't the one you want :)
12:58:45 <rwbarton> mmmurf: f g x always means (f g) x
12:59:03 <wchogg> paper_cc : Not sure, sorry.
12:59:21 <paper_cc> wchogg: still, thanks =)
12:59:35 * RayNbow notices churchBool is just if'...
12:59:39 <paper_cc> mmmurf: but both f $ g x and f . g $ x mean f (g x)
12:59:52 <mmmurf> rwbarton: ahh i see, i was thinking of abs(...) as g(x), forgetting that fromIntegral would see g only
12:59:57 <Nafai> http://stackoverflow.com/questions/417977/best-book-of-2008#418132 <- I just voted for RWH as book of 2008 :)
13:00:20 <rwbarton> mmmurf: Yeah, it can be tricky for a while to figure out where you do and don't need parentheses.
13:01:21 <mmmurf> thanks so much for all the helpful advice, guys...
13:02:11 <erikc> is the HIDE project still orphaned?
13:02:14 <Peaker> @type flip const
13:02:15 <lambdabot> forall a b. b -> a -> a
13:02:18 <Peaker> @type const id
13:02:20 <lambdabot> forall a b. b -> a -> a
13:02:20 <psnively> Hi guys.
13:02:30 <saml> hello psnively
13:02:48 <psnively> :-)
13:02:59 <Lemmih> erikc: Yep.
13:05:37 <SamB> Lemmih: how do I get LHC to tell me it's library directory ?
13:05:50 <Peaker> @seen ehird
13:05:50 <lambdabot> I haven't seen ehird.
13:06:16 <Lemmih> SamB: lhc --list-libraries -v
13:06:41 <SamB> that's a lot of directories!
13:07:09 <SamB> ... none of which are the same as cabal expects ?
13:07:32 <Lemmih> SamB: Cabal doesn't really care where the libraries are put.
13:07:52 <SamB> it does care where the configuration file is!
13:08:25 <Lemmih> SamB: Right. LHC doesn't know anything about the configuration file, though.
13:08:38 <SamB> ... okay
13:08:52 <mux> http://hpaste.org/13687
13:08:53 <SamB> that sounds awfully useful!
13:08:55 <mux> any comments on that ?
13:09:00 <thoughtpolice> Lemmih: we should probably get around to getting lhc-pkg up and running
13:09:11 <thoughtpolice> Lemmih: I can probably hack something together relatively fast
13:09:18 <Lemmih> thoughtpolice: Please do (:
13:09:25 <BrokenClockwork> Hey, I want to generate a random number between x and y, how so?
13:09:28 <dcoutts_> Lemmih, SamB: by configuration file do you mean the registered package db that ghc-pkg can interpret?
13:09:42 <Lemmih> dcoutts_: Yes.
13:09:43 <SamB> dcoutts_: yeah, that
13:09:56 <dcoutts_> thoughtpolice: it's not clear if it's actually necessary, if lhc does not need it
13:09:56 <thoughtpolice> Lemmih: oh and btw, I totally, *finally* removed just about every built-in reference to Integer (since john was treating it specially) so I can try to get the pure-haskell integer code working
13:10:08 <SamB> cabal keeps trying to use /usr/lib/lhc-0.6/package.conf
13:10:10 <thoughtpolice> I finally got the compiler built
13:10:24 <thoughtpolice> but uh, it seems to throw the type checker for a loop
13:10:25 <thoughtpolice> :(
13:10:29 <SamB> dcoutts_: well, cabal needs to be able to find info somewhere
13:10:32 <dcoutts_> thoughtpolice: Cabal just needs a way of finding what packages are available
13:10:35 <Lemmih> thoughtpolice: You fixed the segfault?
13:10:50 <thoughtpolice> Lemmih: no, I have a branch that I was testing out where I was trying to get that Integer code in lib/base
13:10:51 <dcoutts_> SamB: yes, nhc and hugs use the InstalledPackageInfo files
13:10:55 <thoughtpolice> instead of having it all built in and crufty
13:11:02 <SamB> dcoutts_: the what now ?
13:11:04 <thoughtpolice> Lemmih: I'm still trying to figure out the segfault issue :/
13:11:11 <Lemmih> dcoutts_: Well, lhc does need it. What we have now is a cheap hack that only works for simple packages.
13:11:33 <dcoutts_> SamB: ghc's package db contains a list of InstalledPackageInfo in Read/Show format
13:11:39 <thoughtpolice> SamB: i believe we fixed that issue - you will need the latest cabal from darcs and lhc from darcs tho
13:11:39 <SamB> how do I make an empty ghc-pkg conf file ?
13:11:52 <dcoutts_> SamB: the input format to ghc-pkg is the displayed format of InstalledPackageInfo
13:12:08 <SamB> thoughtpolice: hmm ?
13:12:12 <Lemmih> thoughtpolice: The LHC code leaks abstractions like cracy. It's almost impossible to work on one component without affecting the others ):
13:12:13 <dcoutts_> SamB: using files with that info in is a completely reasonable package db format
13:12:22 <Lemmih> *crazy
13:12:38 <dcoutts_> SamB: ie the dir containing package foo contains the foo.pkg file
13:12:38 <thoughtpolice> SamB: there were mismatch issues between the places cabal would put stuff and where lhc would look
13:13:05 <dcoutts_> Lemmih: what will lhc need from the package db later?
13:13:28 <SamB> thoughtpolice: how do I tell what versions I've got actually failing ?
13:13:53 <dcoutts_> Lemmih: if you want to keep it simple it would be possible for Cabal to pass all the flags by looking at the package db, rathar than lhc doing it, it's totally up to you where that code goes
13:14:19 <dcoutts_> Lemmih: eg we already do that when invoking hsc2hs
13:14:50 <Lemmih> dcoutts_: Ah, right. Then I guess we could do without lhc-pkg.
13:14:59 <dcoutts_> Lemmih: right
13:15:22 <SamB> thoughtpolice: it ... doesn't seem too fixed ...
13:15:27 <dcoutts_> Lemmih: on the other hand it means you cannot do lhc -package foo from the command line, things would only be conveniently buildable via cabal
13:15:37 <thoughtpolice> SamB: what is the main problem? lhc cannot pick up it's base package?
13:15:46 <thoughtpolice> (sorry had to go do something)
13:15:54 <SamB> thoughtpolice: actually, it's not building at all :-(
13:15:59 <SamB> since I installed lhc --user
13:16:47 <Lemmih> SamB, thoughtpolice: Cabal invokes 'ghc-pkg --global-conf={lhc_global_conf} --package-conf={lhc_local_conf}'. This unfortunately requires the global conf to exist.
13:17:57 <Lemmih> It's slightly awkward to use ghc-pkg for handling non-ghc packages (:
13:18:28 <Saizan> "slightly"
13:18:40 <thoughtpolice> who'd thunk it? :)
13:18:49 <dcoutts_> Lemmih: it's not actually necessary to use ghc-pkg in Cabal, Cabal can read the files directly
13:19:01 <dcoutts_> Lemmih: that's what it does with ghc prior to 6.10 anyway
13:19:10 <Lemmih> dcoutts_: Great, we should do that then.
13:19:34 <dcoutts_> Lemmih: though then registration needs more code, since for ghc we always register via ghc-pkg
13:20:01 <dcoutts_> Lemmih: the package db format ghc-okg uses it horribly slow anyway, you don't especially want to copy it, except for convenience
13:21:02 <SamB> and, really, cabal shouldn't be guessing at lhc's installation directory like it is now ...
13:22:59 <wchogg> Question!  Can I use ErrorT IOError to catch an IO error that came from someone (ab)using fail or can it only catch the error if throwError was used?
13:23:22 <tibbe> either I'm unlucky or lots of package fail to build on GHC 6.10.1 because of haddock failures
13:23:23 <Heffalump> you have to use the IO monad's catch to catch that kind of error
13:23:36 <SamB> > fail "hi!" :: ErrorT IOError ()
13:23:38 <lambdabot>       Kind mis-match
13:23:38 <lambdabot>      Expected kind `* -> *', but `()' has kind `*'
13:23:38 <lambdabot>      ...
13:23:48 <thoughtpolice> tibbe: yeah, lots of them do fail on haddock
13:23:52 <SamB> > fail "hi!" :: ErrorT IOError [] ()
13:23:53 <lambdabot>       No instance for (Show (ErrorT IOError [] ()))
13:23:53 <lambdabot>        arising from a use...
13:23:59 <SamB> > fail "hi!" :: Error IOError ()
13:24:00 <lambdabot>       Class `Error' used as a type
13:24:00 <lambdabot>      In the type `Error IOError ()'
13:24:00 <lambdabot>      I...
13:24:07 <SamB> > runErorr (fail "hi!" :: Error IOError ())
13:24:08 <lambdabot>   Not in scope: `runErorr'
13:24:12 <SamB> > runError (fail "hi!" :: Error IOError ())
13:24:13 <lambdabot>   Not in scope: `runError'
13:24:19 <wchogg> Heffalump : Huh...I was a bit worried about that.
13:24:26 <rwbarton> > fail "hi!" :: Either IOError ()
13:24:27 <lambdabot>   Left user error (hi!)
13:24:48 <SamB> Heffalump: you don't ACTUALLY
13:24:54 <Heffalump> yeah, sorry, I'm wrong
13:24:56 <SamB> but ... I don't see the point of
13:25:00 <SamB> it
13:25:06 <Heffalump> if the fail is being run in the ErrorT monad, it's fine, you can catch it there too
13:25:07 <mux> ouch
13:25:12 <SamB> this way -- who is going to be throwing those ?
13:25:17 * mux thinks he found more bugs in Data.Trie, thanks to quickcheck
13:25:18 <Heffalump> oh, wait, no.
13:25:21 <Heffalump> yes.
13:25:35 <rwbarton> wchogg: Only if the code you have has type MonadIO m => m (), or something
13:25:39 <Heffalump> what does the Error instance for IOError say?
13:26:01 <SamB> @src IOError
13:26:01 <lambdabot> Source not found. There are some things that I just don't know.
13:26:10 <noZone> Is it possible to gracefully exit the "forever" function in Control.Monad, and if so, how?
13:26:21 <rwbarton> wchogg: (and is using the fail method of m, not of IO)
13:26:51 <rwbarton> noZone: Depends on the monad I guess
13:26:58 <mux> this is most definitely a bug
13:27:22 <mux> *Tests> let t = singleton (B.pack "dc") ()
13:27:27 <mux> *Tests> let t' = insert (B.pack "d") () t
13:27:37 <mux> *Tests> toList t'
13:27:37 <mux> [("d",()),("dc",())]
13:27:42 <mux> *Tests> T.lookup (B.pack "d") t'
13:27:42 <mux> Nothing
13:27:47 <wchogg> rwbarton : the monad I'm having to work with actually isn't an instance of MonadIO, but it's using the default fail.  Rather than having to wait until the very end of the computation to do any handling I was hoping I could use ErrorT IOError m to handle it locally.
13:27:53 <mux> quickcheck++
13:27:58 <noZone> let's assume its IO.
13:29:00 <mux> @karma quickcheck
13:29:00 <lambdabot> quickcheck has a karma of 1
13:29:12 <thoughtpolice> quickcheck deserves more than that!
13:29:15 <thoughtpolice> quickcheck++
13:29:15 <thoughtpolice> quickcheck++
13:29:16 <Saizan> noZone: you can throw an exception, and surround it with a catch
13:29:23 <wchogg> noZone : I don't think there's a graceful way to end a forever'ed computation in IO.  I've just used error handlers for that.
13:29:40 <mauke> preflex: karma quickcheck
13:29:41 <preflex>  karma for quickcheck: 7
13:29:58 <noZone> Thanks.
13:31:05 <rwbarton> wchogg: What I was trying to say was, if the type of the computation specifies the monad, there's not much you can do; if it's polymorphic in the monad, then you can try running it in an ErrorT monad
13:31:28 <rwbarton> wchogg: Oh, you mean the default fail as defined in the Monad class
13:31:37 <rwbarton> @src fail
13:31:37 <lambdabot> fail s      = error s
13:31:40 <wchogg> rwbarton : right, the one that calls error
13:31:45 <eu-prleu-peupeu> hi
13:31:47 <eu-prleu-peupeu> haskell freaks
13:32:01 <Raevel> HELLO
13:32:05 <wchogg> eu-prieu-peupeu : Already slinging the insults?
13:32:35 <eu-prleu-peupeu> :D
13:32:36 <eu-prleu-peupeu> sorry
13:32:48 <eu-prleu-peupeu> i was just hoping to see how ppl would react to that
13:32:55 <eu-prleu-peupeu> im planning on a name for a haskell comunity
13:32:58 <eu-prleu-peupeu> but i can't think of one
13:33:08 <wchogg> The same way I react to everything:  with irrational anger.
13:33:14 <eu-prleu-peupeu> oh
13:33:15 <eu-prleu-peupeu> :D
13:33:53 <eu-prleu-peupeu> what about hasklers ?
13:35:16 <halberd> is there a way to automatically track down and install hackage dependencies?
13:35:25 <wchogg> halberd : cabal install?
13:35:34 <halberd> ok ty
13:35:35 <dons> halberd: cabal-install is the tool that does all this.
13:35:36 <pumpkin> eu-prleu-peupeu: has_kill ;)
13:35:40 <dons> it is on hackage.haskell.org
13:35:46 <dons> or in your distro
13:36:08 <eu-prleu-peupeu> pumpkin: it has an underscore... it does not play well with the domain name rfc :/
13:36:16 <pumpkin> has-kill
13:36:18 <pumpkin> .orb
13:36:26 <pumpkin> :)
13:36:26 <Raevel> hasklr is a very web 2.0 type of word
13:37:06 <Saizan> btw, are names with a leading dash allowed?
13:37:13 <Saizan> like -foo.bar.org
13:37:29 <proq> eu-prleu-peupeu: make an acronym.  haskell is too long already
13:37:51 <eu-prleu-peupeu> Saizan: nope
13:38:04 <eu-prleu-peupeu> the dash is only to be used as a separator, like in coca-cola
13:38:39 <eu-prleu-peupeu> i like the "perl mongers"
13:38:41 <Saizan> ok, then i can't complain if on linux i can't access those sites :)
13:38:47 <wchogg> Raevel : you're right.  It's got that classic "I want to look like a foreign word but I only speak American English" look.
13:38:50 <eu-prleu-peupeu> i think it fits nicely into the perl thingy...
13:38:54 <Raevel> h***sk<!! because haskell has some crazy operators!
13:39:19 <eu-prleu-peupeu> ahah
13:39:30 <eu-prleu-peupeu> haskell.me :P
13:40:01 <eu-prleu-peupeu> "haskel.me is available according to WHOIS. "
13:40:20 <eu-prleu-peupeu> and haskell.me also
13:40:56 <milton13> is there a monad tutorial with cool pictures
13:41:10 <saml> @google monad picture
13:41:13 <lambdabot> http://www.bolour.com/papers/monads-through-pictures.html
13:41:13 <lambdabot> Title: Monads through Pictures
13:41:13 <opqdonut> :D
13:41:17 <eu-prleu-peupeu> now i know
13:41:23 <eu-prleu-peupeu> crazy-monads.com :P
13:41:59 <milton13> oh thanks guys :)
13:42:14 <eu-prleu-peupeu> is there any monad tutorial that uses sandwiches as a metaphor ?
13:42:17 <mux> mm, how does one integrate a quickcheck module to cabal, is that even possible actually?
13:42:48 <dcoutts_> mux: at the moment only by writing code for the test hook
13:42:54 <mux> oh, it definitely seems to be since the default setup has a test command
13:43:02 <milton13> where's bonus500
13:43:13 <mux> ah, no fancy QuickCheck-Modules: Foo stuff? :-)
13:43:14 <mux> okay
13:43:18 <dcoutts_> mux: we're planning to add test sections to the .cabal file, like executable sections
13:43:27 <mux> great
13:44:02 <halberd> cabal: cannot configure vty-3.1.6. It requires base ==4.* \\ There is no available version of base that satisfies ==4.* -- what is base, is that a package or something special?
13:44:12 <pejo> halberd, comes with GHC 6.10
13:44:18 <halberd> ok
13:44:21 <dcoutts_> halberd: try an older version of vty
13:44:47 <dcoutts_> halberd: cabal install 'vty < 3.1.6'  and keep dropping the version number 'til you find one that works with your ghc version
13:44:48 <eu-prleu-peupeu> "funkers"
13:44:57 <dons> anyone want to guess what percent of hackage uses template haskell?
13:45:10 <wchogg> 4%?
13:45:10 <pumpkin> 4
13:45:11 <dons> or: how common is TH.
13:45:11 <eu-prleu-peupeu> 0% ?
13:45:18 <dons> higher..
13:45:20 <rwbarton> milton13: http://koweycode.blogspot.com/2007/01/think-of-monad.html :)
13:45:21 <pumpkin> 7
13:45:24 <dons> higher...
13:45:27 <pumpkin> o.O
13:45:31 <dons> i got 9%
13:45:33 <pumpkin> is it just people using derive?
13:45:35 <dcoutts_> dons: though of course the extensions is not fully accurate since it's not enforced
13:45:35 <dons> or ~70 packages
13:45:39 <dons> dcoutts_: right.
13:45:49 <dons> dcoutts_: oh, interesting question: i'm cabalising oleg kiselyov's code
13:45:57 <dons> many separate modules, each with their own extensions
13:46:08 <dons> putting the union of oleg's extensions in a single .cabal seems like a bad idea
13:46:15 <dons> so i'm planning on keeping them per-module
13:46:33 <dons> ok. so it wasn't a question.
13:47:12 <dcoutts_> dons: right, so you'd like to tackle the issue of extensions in cabal, how do we transition to a state where it means the union used not applied
13:47:32 <dons> right.
13:47:42 <dcoutts_> dons: I can't see any other way than adding a new field with the other semantics
13:47:42 <dons> it seems generally useful to list the set of used extens.
13:47:47 <dons> but not to apply them.
13:47:52 <dcoutts_> indeed
13:47:53 <vixey> dons, how to get a list of these TH using things?
13:47:53 <dons> oleg's of a similar view
13:47:59 <dcoutts_> as am I
13:48:03 <dons> vixey: i manually extracted them from the hackage db
13:48:06 <vixey> I wonder how many I could do without TH...
13:48:09 <dcoutts_> dons: the only question is how we get there
13:48:13 <dons> right
13:48:47 <dcoutts_> I'd appreciate suggestions and public support so it doesn't look like I'm randomly imposing it if I make the changes to Cabal :-)
13:48:51 <dons> right
13:48:59 <dons> ok. i'll make a proposal for discussion
13:49:18 <dcoutts_> dons: also it'll be best if we can enforce it
13:49:24 <dcoutts_> and then deprecate the old mechanism
13:49:31 <dcoutts_> or perhaps keep both
13:49:36 <dons> right. start having hackage suggest the chance
13:49:38 <dons> change.
13:50:19 <dcoutts_> some people probably like the convenience of not having to specify in both places
13:50:21 <geezusfreeek> dons, are you bychance cabalising left fold enumerators?
13:50:55 <mux> @src nub
13:50:56 <lambdabot> nub = nubBy (==)
13:50:58 <mux> @src nubBy
13:50:59 <lambdabot> nubBy eq []             =  []
13:50:59 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
13:51:24 <olsner> can't you just put the flags in language pragmas in the relevant modules?
13:51:36 <dons> geezusfreeek: possibly
13:51:39 <olsner> and skip the cabal support all together
13:51:41 <dons> its mostly demo code though, i must say
13:51:47 <dons> so suitable for further extraction later
13:51:58 <dons> i just don't want it 'frozen' by not being on hackage
13:52:18 <Saizan> olsner: they are not easily available for stats then
13:52:24 <geezusfreeek> dons, yes, that is most of what i've seen as well. i was just wondering if you had anything in mind for it. i'm playing with it a bit myself, but also in a very domain specific setting just as the demos are
13:52:26 <Saizan> olsner: especially if you use preprocessors
13:52:45 <elbar> @hoogle nub
13:52:46 <lambdabot> Data.List nub :: Eq a => [a] -> [a]
13:52:46 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
13:52:55 <Saizan> olsner: or to decide if cabal can compile a package on a given compiler
13:53:17 <olsner> hmm, I see
13:53:25 <dons> geezusfreeek: tibbe has looked a lot (as have i) at generalising it to a System.IO alternative
13:53:30 <dons> but we're not there yet by a long way
13:53:48 <dcoutts_> olsner: we currently do not enforce that all extensions listed in the LANGUAGE pragmas are also listed in the .cabal file, but eventually we will.
13:54:42 <dons> ?remember awick The GHC runtime seems to be sensitive to time running backwards
13:54:42 <lambdabot> Okay.
13:54:44 <SamB> Lemmih: thoughtpolice: even after installing lhc globally, I still get Setup: /usr/lib/lhc-0.6/package.conf: openFile: does not exist (No such file or directory)
13:55:36 <eu-prleu-peupeu> ahhh!!
13:55:41 <eu-prleu-peupeu> i've found it!
13:55:45 <eu-prleu-peupeu> the parallel to perl mongers
13:55:48 <eu-prleu-peupeu> but in haskell
13:55:49 <eu-prleu-peupeu> will be called
13:55:51 <tibbe> any good papers on writing and combining stream processors?
13:56:01 <geezusfreeek> dons, i would love for it to be more accessible and if there is ever a serious effort to package it up i would probably contribute a bit to it
13:56:06 <Lemmih> SamB: Right, you may have to touch the directory.
13:56:15 <eu-prleu-peupeu> "haskell alchemists - versed in highly effective pure distillation"
13:56:18 <Lemmih> SamB: Or perhaps put '[]' in the file.
13:56:26 <dons> tibbe: mmm
13:56:39 <halberd> I can't seem to find a version of vty and terminfo that work together without requiring base
13:56:41 <SamB> and it's not ghc-pkg that's complaining afaict ...
13:57:04 <geezusfreeek> well speak of the devil
13:57:08 <olsner> hmm, "alchemist"... I might consider calling myself that if it catches on
13:57:31 <tibbe> dons: still struggling to get the right semantics and performance for iteratee style i/o
13:57:48 <tibbe> dons: thinking of different ways to represent iteratees
13:58:05 <halberd> nvm
13:59:41 <mux> brr, -10°C in Paris
13:59:44 <halberd> cabal: alex version >=2.0.1 && <3 is required but it could not be found. --what? I just updated fifteen minutes ago
14:00:09 <mopped> Can somebody give an example of when scanl/r is useful? it seems a bit of a wierd functiomn
14:00:14 <pejo> halberd, is the alex binary in your path?
14:00:18 <dcoutts_> halberd: is it on your $PATH?
14:00:26 <mux> > fix ((1:) . scanl (+) 1)
14:00:28 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
14:00:29 <Saizan> halberd: btw, vty-3.1.4 and terminfo-0.2.2.1 work here on 6.8.2
14:00:45 <mux> granted, that's far fetched
14:01:12 <halberd> ok Saizan I got something that worked for that, 3.1.2 and 0.2.1
14:01:32 <halberd> I don't know pejo/ dcoutts_ , I didn't manually install it
14:01:46 <halberd> if it's on my system I don't know where
14:01:50 <rwbarton> halberd: That error message doesn't mean "not found on hackage".
14:02:05 <rwbarton> halberd: cabal install doesn't automatically install binary (executable) dependencies
14:02:08 <mopped> What does fix do mux? :E
14:02:22 <int80_h> lemmih, you there?
14:02:26 <mux> @. oeis eval fix ((1:) . scanl (+) 1)
14:02:26 <lambdabot> Plugin `compose' failed with: Math/OEIS.hs:316:10-40: Irrefutable pattern failed for pattern ('%' : c : _, rest)
14:02:28 <Stinger_> @src fix
14:02:29 <lambdabot> fix f = let x = f x in x
14:02:40 <dcoutts_> halberd: if you used cabal to install it, by default it puts it in ~/.cabal/bin which is not on the default path
14:02:45 <Stinger_> yeah now you're brains broken
14:02:48 <Stinger_> er your
14:02:51 <halberd> I added that to my path dcoutts_
14:02:51 <mopped> lol
14:02:52 <redditbot> Updating a node in a double linked list
14:02:52 <redditbot> Learning Haskell
14:02:52 <redditbot> chaource: Haskell seems to be "it"
14:02:56 <mux> mopped: fix is the fixpoint combinator, it allows you to write anonymous recursive functions
14:03:04 <mux> mopped: in some sense, fix is the essence of recursion
14:03:05 <Lemmih> int80_h: Yes.
14:03:06 <dcoutts_> halberd: ok, then cabal install alex
14:03:14 <halberd> already doing
14:03:49 <halberd> but why should this work, when it didn't work as part of installing yi?
14:04:21 <dcoutts_> halberd: it does not yet automatically track build tools as dependencies
14:04:22 <int80_h> Lemmih: I just logged into seize.it :)
14:04:30 <halberd> ok
14:04:33 <int80_h> you're using xen! I love xen
14:04:55 <SamB> Lemmih: any particular reason you don't honor LHC_OPTIONS ?
14:05:01 <SamB> er. JHC_
14:05:01 <SamB> sorry
14:05:10 <opqdonut> large haskell collider
14:05:31 <jae686> soooo recursive it NEVER colides!
14:05:32 <Stinger_> LHC_BLACKHOLE = 0
14:05:54 <mux> lhc -fno-higgs-restriction
14:07:12 <mux> you don't want lhc to print <<loop>> on you
14:07:20 <int80_h> @src folr
14:07:21 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:07:28 <int80_h> @foldr
14:07:32 <int80_h> @src foldr
14:07:33 <lambdabot> foldr f z []     = z
14:07:33 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:07:34 <int80_h> oops
14:09:15 <mopped> I'm trying to understand that function but its making my brain hurt! scanl (+) 1 creates a function that sums two adjoined 'values'(?) in a list, but keeps the intermittent. fix allows you to recursively call anonymous functions, but what's (1:) . doing there? ;S
14:09:20 <mopped> mux: ^
14:09:22 <halberd> it seems to be stuck getting alex, strange because it seems to be a small tarball
14:09:40 <halberd> stuck after "Downloading alex-2.3.1..."
14:10:17 <mux> mopped: let's pick a simpler scanl example, because if you try to understand fix and scanl at the same time, your brain main indeed explode
14:10:19 <halberd> nvm working now
14:10:29 <mux> > scanl (+) 0 [1..10]
14:10:31 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55]
14:10:32 <Lemmih> int80_h: michael.seize.it points to port 8080.
14:10:46 <mopped> > foldl (+) 0 [1..10]
14:10:47 <lambdabot>   55
14:10:53 <mux> scanl/r is just like foldl/r but with all the "intermediate" values kept
14:10:57 <mopped> so it's like fold, but it builds a list of its stages?
14:10:57 <mopped> ok
14:11:13 <mux> > scanl f x [y,z]
14:11:14 <lambdabot>       Ambiguous occurrence `x'
14:11:15 <lambdabot>      It could refer to either `L.x', defined a...
14:11:26 <mux> @undefine x
14:11:31 <mux> > scanl f x [y,z]
14:11:32 <lambdabot>   [x,f x y,f (f x y) z]
14:11:38 <int80_h> Lemmih: thanks
14:11:46 <mux> > scanl f x [a,b,c,d]
14:11:48 <lambdabot>   [x,f x a,f (f x a) b,f (f (f x a) b) c,f (f (f (f x a) b) c) d]
14:11:57 <killerstorm> hi. i'm trying HaXml for xml processing, and it outputs documents with absolutely exorbitant amount of spaces in them (i think it is supposed to be pretty printing). if there a way to turn it off or configure in some way?
14:12:17 <mopped> thats a nice way to illustrate functions
14:12:20 <mopped> didnt know you could do that :p
14:12:30 <mux> that's courtesy of the SimpleExpr module
14:12:36 <mux> or, SimpleReflect
14:12:38 <mux> or something :-)
14:12:52 <dons> killerstorm: isn't there a non-pretty printing function?
14:12:55 <halberd> [ 59 of 101] Compiling Yi.Buffer.Misc   ( Yi/Buffer/Misc.hs, dist/build/Yi/Buffer/Misc.o ) // Yi/Buffer/Misc.hs:352:0: No instance for (Typeable4 RWS)
14:13:20 <dons> halberd: new version of mtl required?
14:14:14 <mopped> Right, so whats with prefixing the list and fix?
14:14:30 <rwbarton> mopped: (Part of the trick with fix ((1:) . scanl (+) 1) is that it isn't using the usual definition of Fibonacci numbers)
14:14:39 <halberd> ty dons
14:15:03 <rwbarton> mopped: Consider these first
14:15:07 <rwbarton> > fix ((1:))
14:15:08 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:15:13 <rwbarton> > fix ((1:) . map (+1))
14:15:14 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:15:50 <halberd> no wait that didn't make a difference
14:16:08 <halberd> just change the output before the error
14:16:15 <halberd> changed
14:19:47 <dmead> ?src fix
14:19:48 <lambdabot> fix f = let x = f x in x
14:21:57 <SamB> Lemmih: have you looked at untangling the SCC involving Prelude ?
14:21:59 <mux> > fix f
14:22:00 <lambdabot>   Add a type signature
14:22:11 <Peaker> @seen ivan
14:22:11 <lambdabot> Last time I saw ivan was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #funtoo, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #
14:22:11 <lambdabot> haskell-blah, #haskell-books, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #
14:22:11 <lambdabot> haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosxdev, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 1m 4d 3m 37s ago, and .
14:22:12 <Deewiant> > fix f :: Expr
14:22:13 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
14:22:34 <Lemmih> SamB: SCC?
14:22:51 <leimy> THUNK!
14:22:54 <SamB> Strongly Connected Component
14:24:11 <Lemmih> SamB: I have not. Didn't even know it was a problem.
14:24:30 * SamB borrows some of Lemmih's RAM
14:25:10 <SamB> [35 of 85] Data.Char
14:25:10 <SamB> [36 of 85] Numeric
14:25:10 <SamB> [37 of 85] Data.Ratio
14:25:10 <SamB> [38 of 85] Prelude
14:25:10 <SamB> [39 of 85] Lhc.Inst.Read
14:25:11 <SamB> [40 of 85] Prelude.Float
14:25:13 <SamB> [41 of 85] Prelude.Text
14:25:21 <mauke> SamB: ?
14:25:23 <SamB> these are compiled as one
14:26:25 <mopped> I don't understand the second one rwbarton
14:26:56 <rwbarton> Well, after substituing the source of fix it becomes  let x = 1 : (map (+1) x) in x
14:27:19 <rwbarton> We can substitute this definition for the second occurrence of x:  let x = 1 : (map (+1) (1 : map (+1) x)) in x
14:27:41 <Lemmih> SamB: Fixing the space leaks would be better than untangling the modules.
14:27:53 <dons> haha burn "I donâ€™t expect there to be a â€œFlickr Haskell Libraryâ€, for instance. But I do expect a Java one"
14:27:54 <SamB> Lemmih: I guess you're right
14:28:04 <ac> how can you specify a base condition using fix, so that the expression isn't infinitely recursive?
14:28:10 * dons loves confronting expectations like that.
14:28:25 <thoughtpolice> dons: link?
14:28:32 <dons> http://www.callingshotgun.net/geekery/making-your-webservice-more-developer-friendly/
14:28:35 <Olathe> ac: const
14:28:50 <Olathe> > fix (const 5)
14:28:52 <lambdabot>   5
14:29:07 <Saizan> > fix (\f n -> if n <= 1 then 1 else n * f (n-1)) 5
14:29:09 <lambdabot>   120
14:30:28 <Lemmih> SamB: We should to do for the memory usage what we did for the CPU usage.
14:32:31 <elbar> @hoogle fix
14:32:32 <lambdabot> Data.Function fix :: (a -> a) -> a
14:32:32 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
14:32:32 <lambdabot> module Control.Monad.Fix
14:34:22 <pumpkin> dons: awesome :P
14:34:35 <dons> hehe
14:34:36 <milton13> > 3 + 3
14:34:37 <lambdabot>   6
14:34:52 <milton13> > let a = [3,5,3,4]
14:34:53 <lambdabot>   <no location info>: parse error on input `;'
14:35:09 <pumpkin> you can use @let or let ... in
14:35:24 <milton13> @let a = [3,4,35,3]
14:35:25 <lambdabot>  Defined.
14:35:28 <milton13> > a
14:35:30 <lambdabot>       Ambiguous occurrence `a'
14:35:30 <lambdabot>      It could refer to either `L.a', defined a...
14:35:42 <milton13> hehe
14:35:50 <pumpkin> all one-letter variables are already defined by the expr stuff
14:35:54 <pumpkin> SimpleExpression I think?
14:36:10 <milton13> @let aaa = [3,4,3]
14:36:11 <lambdabot>  Defined.
14:36:15 <milton13> > aaa
14:36:16 <lambdabot>   [3,4,3]
14:36:17 <mauke> @undefine
14:36:26 <milton13> > aaa
14:36:27 <lambdabot>   Not in scope: `aaa'
14:36:36 <milton13> haha
14:39:00 <bos> yummy. my memcached client can issue 50,000 sets per second, with 100-byte keys and 400-byte values.
14:40:21 <ertai> @users
14:40:21 <lambdabot> Maximum users seen in #haskell: 668, currently: 654 (97.9%), active: 32 (4.9%)
14:41:51 <milton13> @hoogle monad-sandwich
14:41:51 <lambdabot> module Control.Monad
14:41:51 <lambdabot> Prelude class Monad m
14:41:51 <lambdabot> Control.Monad class Monad m
14:43:07 <bos> eek, ghc internal error.
14:43:53 <thoughtpolice> my brains esploded!
14:44:51 * bos wonders how to report a bug for something that went wrong once in 200 runs
14:45:29 <pumpkin> milton13: I made a function called sandwich the other day!
14:45:30 <dons> bos. mm
14:45:54 <thoughtpolice> bos: what happened in particular?
14:45:54 <dons> bos, does it have an 'evacuated / strange closure' number?
14:45:56 <dons> or some other number?
14:46:10 <bos> dons: it's an invalid what_next field
14:46:14 <dons> huh.
14:46:17 <eu-prleu-peupeu> hey dons, do you have a blog ?
14:46:18 <dons> yes, just report that
14:46:21 <dons> eu-prleu-peupeu: yeah
14:46:26 <eu-prleu-peupeu> whats the url ?
14:46:29 <dons> though i'm going to be reviving it this weekend with some new stuff
14:46:33 <dons> eu-prleu-peupeu: google will find it
14:46:37 <eu-prleu-peupeu> olraite
14:46:55 <eu-prleu-peupeu> haskell hacking :) sweet stuff
14:46:57 * thoughtpolice loves it when dons pulls out his flamethrower
14:47:09 <dons> thoughtpolice: hehe. did i flame someone? i try not to be too mean.
14:47:24 <thoughtpolice> dons: no, but your articles more often than not are all the rage on reddit :)
14:47:33 <dons> ah
14:48:11 <SamB> is that good or bad ?
14:48:51 * SamB attempts to build LHC for profiling
14:49:59 <leimy> Large Hadron Collider?
14:50:19 <SamB> why do people keep saying that?
14:50:26 <SamB> it's obviously a Haskell compiler
14:51:10 <roconnor> Large Haskell Compiler
14:51:21 <roconnor> Large Haskell Collider?
14:51:58 * SamB waits to see if his attempt to build LHC for profiling succeeeds
14:52:26 <Boney> roconnor: ahah,  I imagined a number of Haskell Currys being accelerated (in a circular partical accelerator) and then being collided into one another.
14:53:24 <thoughtpolice> SamB: I have some graphs on lhc mem usage etc. here - http://thoughtpolice.stringsandints.com/code/lhc-tests/hello-world/
14:53:43 <thoughtpolice> heh wow, didn't even notice lhc.prof was ~2MB
14:54:06 <pejo> SamB, do you find it surprising that the collider is more well known than a compiler that many have missed the announcement for?
14:54:44 <dons> bos, btw, is your memcached client a haskell one?
14:54:51 <dons> (using haskell memcached bindigns?)
14:54:54 <stulli_> Are the code snippets from RWH somewhere available for download?
14:54:55 <__Ali__> can haskell interface with cint? http://en.wikipedia.org/wiki/CINT
14:55:01 <Lemmih> thoughtpolice: Profiling the frontend compiler might give more interesting figures.
14:55:40 <dons> stulli_: if it is a normal  C implementation
14:56:25 <stulli_> dons, what do you mean?
14:57:35 <dons> well, Haskell has a C FFI.
14:57:45 <dons> so if CINT is a compliant C implementation, then the FFI might well work.
14:57:54 <roconnor> SamB: I think your LHC build is leaking Helium!!!
14:58:02 <roconnor> @where Helium
14:58:03 <lambdabot> http://www.cs.uu.nl/research/projects/helium/
14:58:09 <SamB> roconnor: but I don't even have that installed
14:58:13 <SamB> how can it be?
14:58:58 <stulli_> dons, err, i dont think we talk about the same topic. I search for the examples from Real World Haskell so i dont need to type everything or copypaste from the online version
14:59:02 <__Ali__> dons i'm thinking of using cint instead of ffi to *directly* access already cimpiled libs without wrapping
14:59:15 <dons> __Ali__: why?
14:59:33 <dons> stulli_: oh, hmm. didn't we do a blog post about all the code examples?
14:59:36 <dons> or mention it on the rwh list?
14:59:59 <__Ali__> dons: because wrapping is a pain and because very few libs are already wrapped to haskell
15:01:08 <int80_h> dons: on pg 60 ex. 1 of RWH, am I aloowed to change the data type List to handle more operators?
15:02:14 <stulli_> dons, I might have missed this. Theres no hint in the printed version, so im asking. Anyway, copypaste isnt too much effort either, i was just wondering
15:02:15 <int80_h> s/operators/functions
15:02:34 <int80_h> because I want something like head
15:02:39 <mopped> Is there much difference between ML and Haskell? It seems that my uni teaches ML instead and I'm wondering if it's worth fiddling about with that instead of ploughing ahead in haskell
15:02:46 <int80_h> or maybe I'm thinking about this problem wrongly
15:02:56 <mauke> int80_h: what's the definition of List?
15:03:04 <sjanssen> mopped: after learning Haskell, it should be very easy for you to learn ML
15:03:17 <rwbarton> mopped: ML and Haskell have many similarities and many differences
15:03:33 <int80_h> data List a = Cons a (List a)
15:03:38 <Olathe> They share the letter L, for instance.
15:03:39 <int80_h>                   | Nil
15:03:46 <harblcat2> is there any sort of standard windows graphics library in haskell?
15:03:54 <int80_h>                         | deriving (Show)
15:04:01 <mauke> int80_h: that already supports head (that is, you can write head without changing the type)
15:04:06 <pejo> mopped, the EE people around here that took an intro class on FP (in Standard ML) seems to understand Haskell notation fairly well when written on a whiteboard atleast.
15:04:15 <int80_h> mauke: thanks :)
15:04:32 <mauke> I don't even see how you'd change it to make head easier
15:04:58 <int80_h> mauke: I hadn't gotten that far yet. I just wanted to find out if that was thr right path first before going in that direction.
15:05:35 <therp> is anyone using darcs over ftp here?
15:06:06 <sjanssen> therp: you can do that?
15:06:34 * loadquo is getting stuck on problem 2 of chapter 4 of RWH
15:06:37 <therp> sjanssen: sort of. I'm trying to trick darcs into syncing to an FTP "repo" using curlftpfs (FUSE powered)
15:06:51 <pumpkin> loadquo: I don't have my copy with me, can you remind us what it is?
15:07:02 <therp> sjanssen: however, curlftpfs can not implement "link" properly. there is no such FTP command. so darcs can't do locking as it uses link.
15:07:44 <therp> sjanssen: on the other hand ftp seems to support failing rename commands (although probably not atomic) but the POSIX interface for rename(..) can't fail with -EEXISTS..
15:07:59 <loadquo> It is making a splitWith function type splitWith :: (a -> Bool) -> [a] -> [[a]]
15:08:05 <therp> so I probably have to run darcs without locking..
15:08:29 <int80_h> I'm stuck on ex. 1 on chapter 3
15:09:12 <loadquo> int80_h have you looked at the on-line version comments?
15:10:16 <int80_h> loadquo: doh, no I haven't. But I have isolated the source of my confusion
15:10:24 <int80_h> I'll look up those comments
15:12:41 <ddarius> @users
15:12:42 <lambdabot> Maximum users seen in #haskell: 668, currently: 652 (97.6%), active: 28 (4.3%)
15:13:58 <Lemmih> I wonder how the number of average active users has changed over time.
15:14:16 <loadquo> Is there a standard error I am making if I am always getting infinite type errors?
15:15:20 <chessguy> loadquo:  using a list instead of an element of that list or vice versa can do that
15:15:29 <chessguy> loadquo:  i've seen that a number of times lately
15:16:02 <loadquo> I thought it might be that. I just have to figure out where that is now.
15:16:23 <chessguy> loadquo:  got code?
15:16:25 <chessguy> @paste
15:16:26 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:17:37 <ztirF_> if I have a constructor that takes 6 arguments and I have the values in a list, how can I "unlist" them into function args?
15:17:39 <loadquo> splitWith :: (a -> Bool) -> [a] -> [[a]]
15:17:47 <loadquo> splitWith _ _ = []
15:17:54 <chessguy> please paste on the pastebin
15:18:22 <loadquo> Ah sorry.
15:18:31 <EvilTerran> ztirF_, with difficulty, seeing as the length of lists isn't set at compile-time, and the number of parameters a constructor expects *is*
15:18:33 <augustss> ztirF_: not without some work, e.g., a pattern match on the list
15:18:36 <chessguy> hm, that's it? that should typecheck
15:19:10 <ztirF_> bah: so I have to do (a:b:c:d ...) or something
15:19:11 <chessguy> @type let splitWith :: (a -> Bool) -> [a] -> [[]]; splitWith _ _ = [] in splitWith
15:19:12 <lambdabot>     `[]' is not applied to enough type arguments
15:19:13 <lambdabot>     Expected kind `*', but `[]' has kind `* -> *'
15:19:13 <lambdabot>     In the type `[[]]'
15:19:16 <loadquo> There is a bit more
15:19:22 <chessguy> oh ok
15:19:33 <EvilTerran> ztirF_, simple solution would be "case yourList of [a,b,c,d,e,f] -> YourConstructor a b c d e f; _ -> {- whatever happens if there's the wrong number of elements -}
15:19:49 <ztirF_> EvilTerran++
15:19:50 <chessguy> @type let splitWith :: (a -> Bool) -> [a] -> [[a]]; splitWith _ _ = [] in splitWith
15:19:52 <lambdabot> forall a. (a -> Bool) -> [a] -> [[a]]
15:19:55 <ztirF_> thanks
15:20:00 <EvilTerran> ztirF_, may i ask where the list is coming from?
15:20:24 <ztirF_> I'm reading it from a file
15:20:26 <Peaker> ztirF_: what is that constructor? Why does it have so many?
15:20:28 <EvilTerran> ah, i see
15:20:36 * loadquo is figuring out pastebin at the moment
15:20:40 <Peaker> ztirF_: why doesn't it simply hold a list of values?
15:21:41 <ztirF_> Peaker: because it's a type: data Model = Model { modelname :: [Char],norm, temp, emissivity, lambda_0, ...}
15:22:00 <SamB> Lemmih: so ... how would one profile LHC's compilation of base ?
15:22:23 <Peaker> ztirF_: if they are differing types, how do you have them in a list?
15:23:16 <ztirF_> Peaker: I split it up:  let wlist = words s (name,vals) = (head wlist, map read (tail wlist))
15:23:27 <ztirF_> s comes from the file
15:23:36 <loadquo> http://hpaste.org/13693
15:23:50 <ztirF_> oops forgot a ;
15:24:10 <EvilTerran> loadquo, "splitWith f (x:xs) | otherwise = x:(splitWith f xs)"
15:24:22 <Peaker> ztirF_: ah, so the 6 are the same type, but you have more constructor args with different types
15:24:29 <asgaroth> How do I add a .hoo database to the databases hoogle searches by default?
15:24:32 <EvilTerran> loadquo, note the type of the second parameter (that starts with (x:)) and the type of the return value (also starting with (x:))
15:24:37 <ztirF_> Peaker: that's right
15:24:56 <Lemmih> SamB: Install lhc with --enable-executable-profiling. Then install base with --lhc-options="+RTS -p -RTS"
15:24:59 <EvilTerran> loadquo, they're both (x : something), so, if (x :: a), they're both (:: [a])
15:25:24 <SamB> Lemmih: I got the first bit, thanks
15:25:27 <Peaker> ztirF_: so why not have:   data Model = Model { modelName :: String, params :: [Double] } or such?
15:25:44 <SamB> hopefully it has good default SCC options ...
15:26:33 <rwbarton> Peaker: because he wants to refer to them by name later?  Seems totally reasonable to me
15:26:34 <loadquo> EvilTerran should something like x:[splitWith f  xs] work if not why not?
15:26:39 <augustss> ztirF_: you could also consider a different parser, like parsec or readp
15:26:58 <EvilTerran> loadquo, if (x :: a), then ((x : anything) :: [a])
15:27:00 <Olathe> @type (:)
15:27:02 <lambdabot> forall a. a -> [a] -> [a]
15:27:06 <EvilTerran> loadquo, you can tell by the type of (:)
15:27:17 <Peaker> rwbarton: Didn't say it wasn't :)
15:27:19 <ztirF_> Peaker: because I want to have named records
15:27:35 <ztirF_> ahh, beaten
15:27:37 <rwbarton> Peaker: Fair enough, I guess... :)
15:28:25 <SamB> Lemmih: so ... when are you planning on adding TH support to LHC ?
15:28:31 <loadquo> Okay, thanks EvilTerran
15:28:48 <chessguy> loadquo:  get it fixed?
15:28:57 <rwbarton> ztirF_: If you can choose the file format you're reading/writing, then you can use derived Read/Show instances which would be more convenient
15:29:01 <Lemmih> SamB: It isn't on my immediate TODO list.
15:29:24 <loadquo> Fixed the type bug. Whether the code does what I want is another matter.
15:29:27 <SamB> I mean, you'll obviously have to do at some point ;-P
15:29:35 <SamB> there ought to be a tracker ...
15:29:46 <chessguy> loadquo:  it typechecks - ship it!
15:29:57 <Lemmih> SamB: We have one. Can't remember where, though.
15:29:58 <Olathe> > read "a" :: Expr
15:30:00 <lambdabot>       No instance for (Read Expr)
15:30:00 <lambdabot>        arising from a use of `read' at <int...
15:30:14 <chessguy> loadquo:  actually....don't :)
15:30:14 <ztirF_> rwbarton: unfortunately the data files are "god-given," otherwise I would have just written "deriving (Read,Show)" because I am lazy
15:30:28 <int80_h> hmmm
15:30:44 <int80_h> I don't see any comments concerning this exercise I'm stuck on
15:30:59 <chessguy> int80_h:  what exercise is that?
15:31:12 <int80_h> exercise 1, page 60
15:31:22 <int80_h> someone suggested looking at the online comments
15:31:33 <mauke> well, looks like you have to do it yourself then :-)
15:31:34 <int80_h> I *have* isolated the source of my confusion
15:31:47 <int80_h> it has to do with types, hold on
15:31:50 <mauke> ok, what is it?
15:31:59 <chessguy> crap. i don't have RWH handy - how embarrassing
15:32:13 <Olathe> They have it on the intarweb.
15:32:21 <int80_h> *Main> :t (fromList "durian")
15:32:22 <int80_h> (fromList "durian") :: List Char
15:32:25 <chessguy> Olathe:  not by page number :)
15:32:38 <int80_h> okay so fromList returns type "List Char" right?
15:32:43 <mauke> int80_h: yes
15:32:50 <int80_h> right...now here's where I get confused
15:32:54 <mauke> int80_h: well, in this case it does
15:33:03 <mauke> I hope it's more general
15:33:19 <Olathe> It's on http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html
15:33:19 <int80_h>     Couldn't match expected type `[a]'
15:33:22 <int80_h>            against inferred type `List Char'
15:33:24 <Olathe> Search for durian
15:33:36 <mauke> int80_h: for what code?
15:33:54 <int80_h> okay hold on I'll paste that again
15:34:07 <int80_h> (head (fromList "durian"))
15:34:07 <int80_h> <interactive>:1:7:
15:34:07 <int80_h>     Couldn't match expected type `[a]'
15:34:08 <int80_h>            against inferred type `List Char'
15:34:20 <chessguy> int80_h:  please use hpaste
15:34:29 <int80_h> alright
15:34:36 <rwbarton> int80_h: head is the Prelude head, which expects []-lists
15:34:51 <rwbarton> int80_h: You have to name your List-list head something else
15:34:54 <mauke> int80_h: 'head' is not your function
15:35:31 <Olathe> int80_h: What is the type of fromList ?
15:35:40 <int80_h> okay, I'll take a look at what Olathe mentioned
15:35:45 <int80_h> brb, I'll check
15:35:47 <mauke> wtf
15:36:11 <int80_h> fromList :: [t] -> List t
15:36:23 <SamB> oh great
15:36:26 <SamB> out of disk space
15:36:31 <Olathe> int80_h: And, as rwbarton mentioned, what is the type of head ?
15:36:38 <chessguy> yeah, so you're supposed to be writing toList :: List t -> [t] right?
15:36:42 <chessguy> int80_h:  ^^
15:36:46 <mauke> chessguy: not in this exercise
15:36:53 <Philonous> I find it rather sarcastic that O'rlly chose a bug for the cover of RWH
15:36:59 <rwbarton> SamB: hard drive manufacturers should be supporting haskell compiler research!
15:37:10 <Olathe> Philonous: I think the authors liked it.
15:37:12 <chessguy> mauke:  it says to write the converse of fromList
15:37:16 <rwbarton> SamB: I've run out of disk space during a ghc install too
15:37:19 <mauke> chessguy: where?
15:37:42 <chessguy> in exercise 1
15:38:01 <chessguy> http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#id585938
15:38:09 <mauke> "Write a function that computes the number of elements in a list. To test it, ensure that it gives the same answers as the standard length  function."
15:38:11 <Olathe> Philonous: http://book.realworldhaskell.org/ has a section on it.
15:38:27 <int80_h> mauke: this exercise is on page 60
15:38:27 <chessguy> oh
15:38:31 <chessguy> different exercise 1
15:38:38 <mauke> oh hey, multiple exercise sections per chapter
15:38:43 <mauke> RWH--
15:38:58 <mauke> int80_h: ... that doesn't help me
15:39:33 <chessguy> int80_h:  are you writing the converse of fromList or the function that computes the number of elements in the list?
15:39:42 <mauke> neither
15:39:46 <int80_h> mauke: Write the converse of fromList for the List type: a function that takes a List a and generates a [a]
15:40:02 <mauke> what, then why are you messing with 'head'?
15:40:07 <int80_h> chessguy: the first one, converse of fromList
15:40:15 <chessguy> int80_h:  ok, so what is the type?
15:40:16 <Philonous> Olathe: True, but it still appears to be tongue-in-cheek to me
15:40:33 <int80_h> mauke: well, I was messing around with the type in ghci to get an idea of what I should be doing
15:40:37 <Olathe> Philonous: I think you're probably right.
15:40:40 <drdozer> If I want to introduce naive parallelism, is par/seq and compiling with -threaded (and the run-time switch) sufficient?
15:40:41 <ddarius> "converse" wtf?  "inverse"
15:40:55 <vixey> @w80 converse
15:40:56 <lambdabot> *** "converse" wn "WordNet (r) 2.0"
15:40:56 <lambdabot> converse
15:40:56 <lambdabot>      adj 1: of words so related that one reverses the relation denoted
15:40:56 <lambdabot>             by the other; "`parental' and `filial' are converse
15:40:56 <lambdabot>             terms"
15:40:58 <lambdabot> [4 @more lines]
15:41:13 <rwbarton> drdozer: It might be.  Only one way to find out! :)
15:41:15 <chessguy> ddarius:  covered in the comments
15:41:26 <rwbarton> drdozer: Seriously, par can be a little unpredictable
15:41:50 <int80_h> @type head
15:41:52 <lambdabot> forall a. [a] -> a
15:41:57 <chessguy> rwbarton:  why is that?
15:42:48 <chessguy> @w80 inverse
15:42:50 <lambdabot> *** "inverse" wn "WordNet (r) 2.0"
15:42:50 <lambdabot> inverse
15:42:50 <lambdabot>      adj 1: reversed (turned backward) in order or nature or effect
15:42:50 <lambdabot>             [syn: {reverse}]
15:42:50 <lambdabot>      2: opposite in nature or effect or relation to another quantity
15:42:51 <rwbarton> chessguy: It might decide that your computation is too small to bother doing in parallel, and sometimes it's wrong
15:42:52 <lambdabot> [5 @more lines]
15:42:56 <int80_h> okay, so I have only Cons and Nil to work with, right?
15:43:02 <chessguy> rwbarton:  heh, nice
15:43:07 <Olathe> int80_h: Right.
15:43:16 <chessguy> int80_h:  correct. and you should work out the type first
15:43:40 <rwbarton> chessguy: the idea is that you can put lots more `par`s into your program than you have cores, and it will figure out something reasonable to do
15:43:44 <loadquo> int80_h : I think most of the power comes from pattern matching in this example
15:43:49 <int80_h> chessguy: the type of what? List?
15:44:04 <chessguy> int80_h:  the type of the converse of fromList
15:44:07 <pejo> drdozer, there's lecture notes from AFP'08 on Simon Peyton Jones homepage, they're well worth a read on how to do parallel stuff.
15:44:08 <Olathe> int80_h: The type of the function you're writing.
15:44:12 <chessguy> (i.e., the function you're writing)
15:44:12 <EvilTerran> int80_h, the type of any function you're writing, in general
15:44:44 <chessguy> and if you name it "theInverseOfFromList" i'm going to have to @slap you
15:44:46 <EvilTerran> often, the implementation is just a case of filling in the gaps to make something with the right type
15:44:47 <drdozer> thanks pejo
15:45:09 <int80_h> ooh I've got that..it's toList :: List a -> [a]
15:45:14 <chessguy> nice
15:45:31 <chessguy> then the base case
15:45:36 <Olathe> let theInverseOf "from" = "to"
15:45:42 <EvilTerran> if you're taking a Foo and not returning a Foo, say, you've probably got to deconstruct the Foo somehow
15:46:19 <EvilTerran> Olathe, let theInverseOf s = (to++) <$> stripPrefix "from" :P
15:46:25 * chessguy hands int80_h  some TNT
15:46:25 <EvilTerran> er, ("to"++)
15:46:43 <EvilTerran> and, if you're returning a Foo and not getting one as a parameter, you're gonna need to get one from somewhere
15:46:52 <EvilTerran> (a constructor of Foo)
15:47:54 <int80_h> gotta go to the store, let's pick this up later. :)
15:48:34 <chessguy> aww. it pains me to see such a simple function left unwritten
15:48:45 <int80_h> I'll brb
15:51:18 <therp> seems like my darcs over ftp hacks work
15:51:49 <therp> but repushing the whole thing is most likely faster than running it over curlftpfs
15:52:33 <loadquo> If something is returning [[a]] how do I get [a] out of it?
15:52:43 <SamB> join
15:52:46 <mauke> @hoogle [[a]] -> [a]
15:52:46 <lambdabot> Prelude concat :: [[a]] -> [a]
15:52:46 <lambdabot> Data.List concat :: [[a]] -> [a]
15:52:46 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
15:52:58 <dmhouse> loadquo: how do you want to combine the list of lists into a single list?
15:53:00 <SamB> oh, yeah, it's also called concat isn't it ;-P
15:53:25 <chessguy> concatMap id
15:53:35 <dmhouse> loadquo: if you want to concatenate all the sublists together into one big list, the above functions will do. Otherwise, something else is in order.
15:53:54 <loadquo> Good question, actually I probably only want to join something to the head of it.
15:54:30 <Olathe> @type concat.map (:[])
15:54:31 <lambdabot> forall a. [a] -> [a]
15:54:35 <dino-> hm, can you give an example of input / desired output?
15:54:51 <chessguy> hm, i'm trying to come up with a good name for this type: data (Num c) => Foo a b c = Foo (Map a (Map b c))
15:55:04 <mauke> ew, class constraint
15:55:06 <chessguy> i'm thinking like WeightedAssociation or something
15:55:09 <dino-> MapOfMap
15:55:33 <drdozer> ah I think i'd misunderstood what haskell parallelism means
15:55:38 <chessguy> dino-:  too implementation-specific
15:56:07 <dino-> yes, MapOfMap, yuk
15:56:10 <rwbarton> chessguy: You've only told us the implementation.  What do you expect? :)
15:56:18 <drdozer> so par and seq and things alter the usual lazy semantics to mean that certain expressions are reduced by particular points and say that this reduction can be done 'to the side'?
15:56:29 <dons> yeah
15:56:30 <dino-> Hey, how is that 6.10 doing? I'm on the brink of installing.
15:56:48 <dons> `par` says "you might want to do this on the side"
15:57:03 <rwbarton> drdozer: My informal understanding is that only the operational semantics are altered.
15:57:28 <drdozer> and `seq` says "before you start this, I need what's on the left?
15:57:40 <Olathe> > let f 0 = "concat.map (:[])"; f n = "concat.map (" ++ f (n - 1) ++ ").map (:[])" in say $ f 3
15:57:42 <lambdabot>   concat.map (concat.map (concat.map (concat.map (:[])).map (:[])).map (:[]))...
15:57:54 <Olathe> @type concat.map (concat.map (concat.map (concat.map (:[])).map (:[])).map (:[])).map (:[])
15:57:55 <lambdabot> forall a. [a] -> [a]
15:58:09 <rwbarton> drdozer: Right.  Well, "before you start this, reduce what's on the left to WHNF".  seq does change the semantics.
15:59:33 <drdozer> so par is like a future, and seq is like a wait?
15:59:53 <drdozer> not exactly an exact analogy
16:00:54 <dons> `par` is like a lazy future
16:01:13 <dons> it tells the runtime that a computation might be useful to run in another thread, or another core
16:01:35 <dons> seq (actually `pseq`) says, "i need this first"
16:01:50 <drdozer> ok, and there's no requirement for me to refer to what's on the left of par, and it could be part of something I need later rather than all of it
16:01:59 <dons> yeah
16:02:10 <Olathe> @type par
16:02:11 <lambdabot> forall a b. a -> b -> b
16:02:18 <dons> expensive `par` expensive2 `pseq` (expensive + expensive2)
16:02:28 <dons> there's a 'map and reduce' sort of.
16:02:44 <dons> distributes two computations to two threads, and then combines the result
16:02:54 <redditbot> Creating a minimal HTTP server in Haskell | Colin Ross
16:03:52 <drdozer> so that queues up expensive to be run *at some point* and returns ... ensure that expensive2 has been computed and then return the sum of expensive and expensive2
16:04:04 <drdozer> that sum will block if expensive hasn't been computet yet?
16:04:37 <dons> no, it might start computing it in the second thread too
16:04:40 <dons> if it isn't already.
16:04:47 <dons> whichever thread gets it done first will get it done.
16:05:17 <drdozer> ah ok, so the cost of this is that we could potentially have lots of threads trampling each-other's hard work?
16:05:55 <dons> yeah. you could end up duplicating work
16:06:31 <drdozer> I guess that's down to the compiler to get smarter about in the future
16:06:39 <drdozer> but thanks for letting me know
16:07:27 <rwbarton> Why don't the concerns that lead to using pseq instead of seq also apply to more mundane uses of seq to control space complexity?
16:07:33 <pejo> drdozer, from an amateur pov: it seems really hard to get fast programs with par. (Of course dons can do it however..)
16:07:53 <dons> it is hard to reason about how expensive a computation is
16:07:58 <dons> to work out if it is worth to spark
16:08:06 <dons> so strategies are useful here
16:08:10 <dons> e.g. parMap
16:08:14 <dons> and other high level schemes
16:08:20 <int80_h> okay back
16:08:27 * int80_h thinks about the base case
16:09:17 <Saizan> btw, do you want (x `par` y) `pseq` x + y   or  x `par` (y `pseq` x + y) ?
16:09:18 <SamB> is there anything besides hp2ps with which to view heap profiles ?
16:09:36 <dons> the latter
16:09:44 <int80_h> chessguy: you there?
16:09:50 <chessguy> ya
16:09:55 <dons> i.e. x in thread 1, and y in thread2 , then add them in thread 2
16:09:56 <drdozer> so say I currently have something like: 'sort $ map expensiveFunc xs' and want each element of xs to be processed in parallel?
16:10:07 <dons> sort (parMap f xs)
16:10:26 <dons> parMap is great if f is very expensive
16:10:34 <chessguy> int80_h:  not for long though
16:10:36 <drdozer> :t parMap
16:10:36 <dons> so that traversing the list is much cheaper than computing each element
16:10:38 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
16:10:43 <rwbarton> parMap needs a first argument, like rwhnf
16:10:43 <int80_h> the base case would be " toList Nil = []"
16:10:51 <dons> yeah, parMap rnf ...
16:11:14 * loadquo has some horrible code that needs some improvement at http://hpaste.org/13695
16:11:16 <ozy`> @src parMap
16:11:16 <lambdabot> Source not found. You type like i drive.
16:11:47 <int80_h> chessguy: is that right?
16:11:58 <chessguy> int80_h:  yep
16:12:12 <rwbarton> I wonder whether you could make an Applicative that inserts all the `par`s for you
16:12:17 <drdozer> OK dons - I will give it a spin
16:12:42 <rwbarton> (Par f) <*> (Par x) = x `par` Par (f x) -- or something
16:13:02 <dons> drdozer: you'll want to use -threaded -O2 probably, and +RTS -N2 or more depending on the number of cores you have
16:13:04 <int80_h> chessguy: okay then :)
16:13:19 <dino-> loadquo: hm, I so want to get takeWhile involved in that somehow.
16:13:32 <chessguy> int80_h:  one more line and you're done
16:15:23 <EvilTerran> rwbarton, i don't think that'd satisfy the applicative laws when dealing with exceptions
16:16:21 <rwbarton> EvilTerran: I know nothing about the interaction between exceptions and par, but "a par b is exactly equivalent semantically to b" according to Control.Parallel
16:16:32 <rwbarton> EvilTerran: that's good enough for me :P
16:16:55 <EvilTerran> oh right
16:17:07 <loadquo> dino- good idea. I'll see what I can do.
16:17:08 * EvilTerran was thinking a `par` b was semantically equivalent to a `seq` b
16:17:54 <rwbarton> I'd guess exceptions in a just disappear
16:19:05 <chessguy> int80_h:  i'm out. good luck
16:19:16 <dino-> loadquo: If you're talking about always splitting into two, maybe evaluating to a tuple makes more sense? Just idly thinking, you may have good reasons to -> [[a]]
16:20:28 <loadquo> Unfortunately, it is supposed to be an equivalent to words
16:20:42 <rwbarton> loadquo: You could just add a pass afterwards that removes empty lists from the output
16:20:59 <int80_h> @src head
16:20:59 <lambdabot> head (x:_) = x
16:20:59 <lambdabot> head []    = undefined
16:22:44 <rwbarton> loadquo: Also, your implementation is exponential time because you call splitWith recursively twice. :)
16:22:48 <drdozer> mm, parMap seems to have slowed my app down by about 40%
16:23:10 <drdozer> I am confident that I am parallelising over the map application that is where my program spends all its cpu
16:23:12 <drdozer> weird
16:23:43 <rwbarton> loadquo: I would suggest ... | otherwise = [[x] ++ firstPiece] ++ otherPieces where (firstPiece : otherPieces) = splitWith f xs
16:24:06 <rwbarton> drdozer: Try running with the RTS flag -sstderr to see whether it's using multiple cores
16:24:49 <rwbarton> loadquo: (actually I would write (x : firstPiece) : otherPieces)
16:25:54 <loadquo> rwbarton, thanks I wasn't really happy about the code.
16:26:35 <drdozer> should -stderr make it print stuff out? (-sstderr didn't work at all)
16:26:35 <rwbarton> loadquo: The source of words is a little complicated too.
16:26:49 <rwbarton> +RTS -sstderr
16:27:53 <drdozer> with +RTS -sstderr, it prints out "unknown RTS option: --stderr"
16:28:19 <rwbarton> Did you type +RTS --sstderr?
16:28:58 <rwbarton> Should be one -, two s
16:29:32 <bob234> hello
16:29:36 <dons> hello bob234
16:29:38 <dons> welcome.
16:29:59 <bob234> i am trying to configure eclipse for haskell programming but I am having trouble locating the haddock executable
16:30:20 <int80_h> chessguy: I almost have it. Can I paste my one-liner here?
16:30:50 <dino-> loadquo: ah, words
16:30:51 <dons> bob234: haddock can be built from source from the .tar.gz on hackage.haskell.org
16:31:15 <bob234> dons: i am using arch linux and have downloaded ghc from the repositories
16:31:24 <bob234> my path to ghc is /usr/lib/ghc-6.8.2
16:31:35 <dons> yes. ok.
16:31:37 <loadquo> int80_h chessguy went...
16:31:40 <dons> haddock is in pacman too
16:31:45 <int80_h> rats
16:31:52 <int80_h> hmm
16:31:54 <dino-> But yes, paste
16:31:54 <bob234> ahh it is packaged separately?
16:32:16 <int80_h> okay, here's my inductive case
16:32:20 <int80_h> toList Cons x = (toList xs)
16:32:22 <dino-> loadquo: Also, I want to say this should be a funny kind of fold.
16:32:25 <int80_h> and of course this is wrong
16:32:31 <dino-> Or _could_ be
16:32:33 <drdozer> rwbarton: ok - it may have been my bad typing - but it's not printing stuff out
16:32:38 <mauke> int80_h: you can't just write Cons in a pattern. Cons takes two arguments
16:32:44 <drdozer> if I run the program and ^c it, it prints stuff out
16:33:56 <loadquo> dino- Beyond my level at the moment. Although I have heard of it. How would I check out the source of the words function?
16:33:58 <dons> bob234: oh, it is in AUR actually
16:34:00 <bob234> i see it is in the Aur repositories. It really should be in the standard ones
16:34:06 <dons> yes, we're going to move it in.
16:34:26 <drdozer> rwbarton: it may be user-error, but this doesn't seem to be working as expected - it's not printing anything out
16:34:32 <bob234> that's great. thanks for your help
16:34:32 <loadquo> Actually I should go.
16:35:07 <SamB> Lemmih: hmm, the leak seems to be "OTHER"
16:35:21 <tehgeekmeister> http://hpaste.org/13696 <== fetchAllRows in hdbc is returning no rows for a statement that returns rows in the database's own interface.
16:35:26 <dino-> The API docs online have a link to source: http://www.haskell.org/ghc/dist/current/docs/libraries/base/Prelude.html#v%3Awords
16:35:38 <dino-> On the right, there's a link next to the functions
16:35:50 <dino-> Also if you have the API docs installed locally, IIRC
16:35:59 <dino-> bah, he left
16:36:43 <mm_freak_> now cabal-install is starting to suck
16:36:45 <mm_freak_> cabal: cannot configure category-extras-0.53.5. It requires ghc >=6.9
16:36:46 <mm_freak_> There is no available version of ghc that satisfies >=6.9
16:36:52 <mm_freak_> i have GHC 6.10.1
16:37:55 <drdozer> ok, that's better - what part of the -sstdout output should I be looking at?
16:37:58 <drdozer> tasks?
16:39:51 <int80_h> mauke: here's another attempt. It says xs is not in scope
16:39:55 <int80_h> toList x =  (toList xs)
16:40:33 <mauke> yeah
16:40:36 <mauke> what is xs supposed to be?
16:41:17 <int80_h> it's supposed to be the rest of a list. As in x:xs
16:41:22 <mauke> what list?
16:41:38 <int80_h> doh!
16:41:47 <int80_h> there is no list
16:42:41 <int80_h> wait. Okay. there is a list
16:42:50 <mauke> there is a List, and you called it 'x'
16:42:51 <int80_h> this is the list
16:42:59 <mauke> or maybe a list
16:44:09 <int80_h> I thoughx would be the first element in the list
16:45:03 <mauke> why?
16:47:32 <int80_h> mauke: hmm, okay I have to admit I do not know how to build a recursive case based on this data type
16:47:46 <rwbarton> drdozer: you should get a couple lines of output that start like "Task  0 (worker) :  MUT time:   1.15s" for each thread, and you want to see how many of the MUT times are nonzero
16:48:25 <mauke> int80_h: you handle each data constructor
16:48:28 <int80_h> mauve: since Cons is used to build. But what I'm trying to do is reduce a List until there is only Nil left.
16:48:34 <mauke> toList Nil = ...
16:48:39 <mauke> toList (Cons a b) = ...
16:48:43 <csaba> hi
16:48:46 <int80_h> mauke: yeah I have the base case
16:48:51 <csaba> could you tell me what JHC stands for?
16:49:00 <dons> John's Haskell Compiler
16:49:04 <Olathe> Jesus H Christ.
16:49:16 <csaba> Olathe: acronymfinder.com :)
16:49:19 <int80_h> mauke: oooh...see I thought I couldn't use COns in the pattern. I was just using it incorrectly
16:49:22 <csaba> dons: really?
16:49:30 <dons> well, in this context, it means John's Haskell Compielr, yes.
16:49:36 <drdozer> rwbarton: ah, ok - I see those - the bigger -Nx I put, the more tasks I see, and they are all non-zero
16:49:38 <csaba> thx then
16:49:50 <Pseudonym> @vera jhc
16:49:52 <csaba> bye
16:49:53 <lambdabot> No match for "jhc".
16:49:59 <dons> csaba: why do you ask?
16:50:04 <tehgeekmeister> anyone know why fetchAllRows in HDBC would return an empty list when the statement should result in many rows?
16:50:05 <drdozer> rwbarton: so I'm guessing that my app goes slower because the work in the parMap is too small, so it's being done multiple times
16:50:06 <Pseudonym> @vera ghc
16:50:07 <lambdabot> No match for "ghc".
16:50:22 <dons> drdozer: parMap works best at the top level of your program
16:50:25 <csaba> dons: i make an essey on the topic of haskell compilers
16:50:27 <dons> so you get N threads only.
16:50:32 <dons> csaba: oh? sounds  interesting
16:50:47 <dons> csaba: have you  read the section in "The History of Haskell" on the different compilers?
16:50:58 <rwbarton> drdozer: there is some overhead for the threaded runtime
16:51:16 <erikc> what were throwDyn/catchDyn replaced with? trying to get HOC compiling on ghc 6.10
16:51:17 <dons> and do you include: GHC, NHC, Hugs, YHC, JHC, LHC, EHC, HBC, HBI, Yale Haskell, Gofer, ?
16:51:31 <dons> erikc: just use Control.OldException
16:51:31 <csaba> dons: not yet, where is it? haskell.org?
16:51:40 <erikc> ah, booya
16:51:42 <dons> csaba: yes, it is linked from the 'History' link on haskell.org
16:52:07 * Pseudonym doesn't include Gofer
16:52:15 <dons> well, I used to use Gofer in a Haskell course.
16:52:18 <Pseudonym> Me too.
16:52:23 <csaba> csaba: i'm interested only in compilers, so Hugs are not playing here, and i didn't hear about HBC HBI
16:52:28 <ddarius> What about Helium?
16:52:28 <Pseudonym> Actually, we hacked up Gofer to work more like Miranda.
16:52:32 <dons> heh
16:52:41 <dons> csaba: HBC you should definitely include
16:52:55 <Pseudonym> Having Miranda misfeatures backported to Gofer seemed odd at the time.
16:52:58 <dons> the first, and for a long time, fastest, implementation
16:53:11 <dons> hmm, any other compilers?
16:53:12 <Pseudonym> e.g. the discriminated union of Double and Integer
16:53:30 <dons> NHC -> YHC, JHC -> LHC, GHC, HBC, EHC.
16:53:31 <Peaker> its weird that GvR (Python fame) and SPJ (Haskell fame) don't know each other's languages very well.. so many Haskellers know Python, and a few vice versa...
16:53:51 <Pseudonym> But strictly speaking, Gofer was never a Haskell implementation.  When it was, it was Hugs.
16:54:11 <drdozer> cale gave me a hand optimizing my code the other day which was great
16:54:13 <ddarius> Strictly speaking, GHC and NHC were never Haskell implementations.
16:54:28 <drdozer> but my code in MonadRandom is still slowing down as the program runs
16:54:33 <drdozer> we couldn't track down what it could be
16:54:34 <dons> I'm sure GHC has been a compliant Haskell implementation, many times.
16:54:41 <Pseudonym> Kinda.
16:54:47 <Pseudonym> If you ignore .hi-boot files, then yes.
16:54:53 <Pseudonym> And, of course, turn on -98.
16:55:14 <dons> I wonder if "module mutual recursion with no additional meta data" is the standard
16:55:31 <Pseudonym> Additional meta data is not mentioned in the standard, if that's what you mean.
16:55:47 <Pseudonym> But you have a point, given that the semantics of modules aren't specified in the standard either.
16:55:49 <dons> no, but does the requirement for meta data make it not compliant
16:55:55 <dons> right
16:56:10 <dons> the requirement for {-# SOURCE #-} might be too much though
16:56:54 <Pseudonym> I should point out that in fairness, compliant C and C++ compilers still require a lot of compiler-specific #ifdefs in Real Code.
16:59:06 <sbahra> repnop, :-p
16:59:12 <sbahra> repnop, I recently registered repnop.org
16:59:19 <newsham> vixey around?
16:59:23 <repnop> haha why
16:59:30 <sbahra> repnop, cool name i figured
16:59:40 <sbahra> i've been using it lately
17:00:08 <ozy`> wasn't someone saying at some point that fmap should be called map, and then we should have "instance [a] => Functor a where {map = foldr (:) []}"?
17:00:19 <repnop> have fun :)
17:00:37 <Cale> ozy`: Lots of people have said that, including me
17:00:41 <ddarius> foldr (:) [] is id
17:00:51 <Cale> map f = foldr ((:) . f) []
17:00:59 <ddarius> That's the way it used to be.
17:01:02 <ozy`> whoops
17:01:06 <ddarius> And originally was
17:01:06 <ozy`> ddarius: is it?
17:01:12 <ozy`> why'd they change it?
17:01:22 <BONUS_> you mean instance Functor [] where map f = foldr ((:) . f) []
17:01:22 <BONUS_> yeah
17:01:29 <Cale> ozy`: People on the H98 committee were afraid of polymorphism
17:01:45 <ozy`> well.... people on the H98 committee were buttheads.
17:01:56 <BONUS_> well they're nice people
17:02:07 <BONUS_> also imho sequence should be sequenceA
17:02:19 <Cale> I think it's just that they didn't want to teach their students about the Functor typeclass.
17:02:20 <drdozer> what does the A suffix mean?
17:02:36 <ddarius> BONUS_: Applicative didn't exist when H98 was written.
17:02:37 <Cale> drdozer: Applicative
17:02:42 <pejo> Cale, were you around at the time so you know that for a fact?
17:02:45 <BONUS_> map not being fmap makes it rly handy to explain map to noobs
17:02:52 <BONUS_> like (a -> b) -> [a] -> [b]
17:02:55 <redditbot> Language and Program Design for Functional Dependencies
17:02:58 <Cale> pejo: I read all the mailing list postings.
17:03:11 <BONUS_> whereas Functor f => (a -> b) -> f a -> f b looks kinda scary
17:03:13 <BONUS_> ddarius: true.dat
17:03:14 <Cale> I wonder if they're still available somewhere.
17:03:21 <cjb> BONUS_: Hey, if you're the learnmeahaskell guy, thanks!  It's a wonderful tutorial.
17:03:28 <BONUS_> haha thanks :]
17:03:35 <BONUS> glad people are enjoying it
17:03:38 <cjb> s/me/you/ :)
17:03:40 <Poee> Hi, I'm using hugs, is there any way of getting something more specific than "Program error: Prelude.!!: index too large"? like the line number for example
17:04:02 <cjb> BONUS: I'd be really interested in a PDF, but I understand if that would stop you from being able to publish it later
17:04:09 <dons> Poee: you can use an assert
17:04:14 <Cale> You might get more information if you compile with profiling and use +RTS -xc
17:04:16 <cjb> (although I guess the license allows it?)
17:04:18 <mauke> Poee: AFAIK no
17:04:28 <dons> Poee: yes, and switch to GHC
17:04:30 <BONUS> yeah, it would be a bit hard to update, but i'll definitely release a pdf once it's all written and finalized enough
17:04:34 <dons> it just has better error messages in general
17:04:45 <int80_h> mauke: now I'm getting "different number of arguments" error for the base case and recursive case. But it looks the same to me.
17:04:52 <Cale> Oh, hugs, I totally ignored that piece of information ;)
17:05:00 <dons> don't use hugs.
17:05:02 <BONUS> lol hugs
17:05:06 <dons> :)
17:05:08 <int80_h> base case is toList Nil = []
17:05:25 <int80_h> and my recursive case is toList Cons a b = (toList b)
17:05:31 <mauke> int80_h: you fail at copy/paste
17:05:37 <mauke> <mauke> toList (Cons a b) = ...
17:05:39 <Cale> int80_h: toList (Cons a b) = ...
17:05:46 <Cale> yeah
17:07:02 * int80_h learns him copy/paste for good skill.
17:07:07 <newsham> ?seen mmorrow
17:07:08 <lambdabot> mmorrow is in #ghc and #haskell. I don't know when mmorrow last spoke.
17:07:16 <BONUS> haha
17:07:31 <Olathe> @seen lambdabot
17:07:31 <lambdabot> Yes, I'm here. I'm in ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosxdev, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it, #
17:07:31 <lambdabot> haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, #haskell-freebsd, ##freebsd, #gentoo-uy, #gentoo-haskell, #
17:07:31 <lambdabot> friendly-coders, #dreamlinux-es, #concatenative, #arch-haskell, #functionaljava, #darcs, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
17:08:01 * drdozer needs the kind *->* in Java :(
17:08:04 <int80_h> wow, there's a logic channel
17:08:05 <Poee> I'll try ghc, I guess the same code should work in both hugs and ghc?
17:08:11 <dons> Poee: yeah
17:08:17 <dons> it'll just be 100x faster in ghc
17:08:18 <Olathe> int80_h: It's only an unofficial channel.
17:08:33 * dons wonders what an official logic channel would be
17:08:38 <EvilTerran> drdozer, you get that with generics
17:08:46 <int80_h> Microsoft Logic (tm)?
17:08:48 <BONUS> Blah<T>
17:08:48 <Cale> heh
17:08:56 <Pseudonym> dons: It couldn't be the true logic channel, but it could be the provable one.
17:08:59 <Pseudonym> In some system.
17:09:06 <EvilTerran> drdozer, i don't think you can have (* -> *) -> *, though
17:09:10 <Cale> That ## convention is stupid for things which couldn't possibly be open source projects.
17:09:18 <dons> ##math
17:09:35 <dons> no rogue math allowed
17:09:39 * Pseudonym invents a programming language called # just to see what happens.
17:09:50 <Olathe> Well, you'd have ## and ###.
17:10:00 <int80_h> people would just make a channel called sharp.
17:10:04 <dolio> And Microsoft would release ##?
17:10:11 <Pseudonym> dolio: which would result in ####
17:10:13 <Cale> ##freenode
17:10:30 <mauke> heh, #perl just ignored that "convention"
17:10:34 <BONUS> although java generics are to haskell's type system what a binoculars is to the hubble telescope
17:11:21 <Pseudonym> C++ templates are like an enormous gound-based telescope cobbled together with bits from the junkyard.
17:11:25 <ddarius> BONUS: Due to subtyping and bounded quantification, Java's type system isn't that simple.
17:11:31 <repnop> java generics are just type erasure
17:11:51 <shapr> @users
17:11:52 <lambdabot> Maximum users seen in #haskell: 668, currently: 627 (93.9%), active: 29 (4.6%)
17:11:53 <dons> i'm not sure that sentence makes sense.
17:12:01 <ddarius> It doesn't.
17:12:32 <shapr> Yow, nigh unto 670
17:12:34 <BONUS> ddarius yeah, i meant more in the sense that it can do more :]
17:12:45 <Peaker> a->a doesn't have a Monoid instance, right?
17:12:52 <dons> shapr: we hit 674 in fact.
17:13:01 <shapr> dons: Awesome!
17:13:10 <dons> yeah, pretty amazing
17:13:14 <shapr> Waleee: hej, god morgon!
17:13:31 <BONUS> peaker: .only newtypes
17:13:37 <BONUS> @info Endo
17:13:37 <lambdabot> Endo
17:13:42 <BONUS> thanks lambdabot
17:13:46 <Cale> Peaker: It has two possible ones. The lifting instance is the default.
17:14:03 <Cale> That is, (f `mappend` g) x = f x `mappend` g x
17:14:10 <shapr> Waleee: How's code?
17:14:11 <Peaker> Cale: two possible ones as in  mappend vs flip mappend ?
17:14:13 <mauke> BONUS: there is no @info
17:14:18 <Peaker> Cale: or (.) vs flip (.) ?
17:14:18 <Olathe> > 5
17:14:19 <lambdabot>   5
17:14:24 <Olathe> That was weird.
17:14:33 <Cale> Peaker: (.) vs the one which I just wrote
17:14:40 <Peaker> Cale: oh
17:15:20 <Peaker> Cale: cool
17:15:39 <Peaker> Cale: by "default", you mean its in Data.Monoid?
17:16:39 <Olathe> > length "#######################"
17:16:41 <lambdabot>   23
17:16:44 <ddarius> BONUS: It can't do more.  They're not comparable.  Java can do things Haskell can't and vice versa.
17:17:28 <rwbarton> > (const "foo" `mappend` const "bar") ()
17:17:30 <lambdabot>   "foobar"
17:17:44 <Olathe> Apparently, map (flip replicate '#') [1..22] are all taken.
17:18:34 <EvilTerran> ,src ''Endo
17:18:51 <lunabot>  newtype Endo a = Endo {appEndo :: (a -> a)}
17:18:52 <ddarius> dons: Did you change the scale on the unique nicks chart or did it do that automatically?
17:19:01 <EvilTerran> > (Endo f `mappend` Endo g) `appEndo` x :: Expr
17:19:03 <lambdabot>   f (g x)
17:19:20 <dons> ddarius: oh, it might not have ticked over to the new year
17:19:23 <SamB> darnit, I wish GHC were prescient :-(
17:19:48 <SamB> having to wait for the program to terminate before getting anything out of the biographical profiling is kind of a pain ...
17:19:55 <int80_h> finally!
17:20:29 <ddarius> dons: The vertical scale has changed.
17:20:57 <newsham> anyone know of a library that auto-derives folding functions for arbitrary data types?
17:21:28 <Olathe> @type \f a b -> concat [[a], f b]
17:21:30 <lambdabot> forall t a. (t -> [a]) -> a -> t -> [a]
17:21:42 <newsham> vixey mentioned that mmorrow has one but he's not around atm.
17:21:51 <ddarius> There's an insane projected(?) count that I think is intended for 2009 but is over 2008
17:22:04 <dons> ddarius: yes, i think there's a bug in the year calculation of that script
17:22:06 <dons> i'll tweeeak it.
17:22:47 <newsham> ie: data Foo = Foo Int String Int;  foldFoo f (Foo a b c) = f a b c
17:24:00 <wabash> What editor do people use for Haskell?
17:24:17 <loop> emacs
17:24:18 <SamRH_> emacs
17:24:22 <Olathe> I hire one from the Washington Post.
17:24:24 <scsibug> emacs, here. same for IRC, which is handy :)
17:24:36 <ray> yes, people use editors for haskell
17:24:40 <newsham> olathe: dont you find them a bit strict about sources?
17:25:20 <Cale> I use vim
17:25:23 <ddarius> Haskellers tend to use whatever editor/environment they were using before.
17:26:37 <dons> vim
17:26:45 <Cale> Anything which can convert tabs to spaces will do.
17:26:52 <Cale> Syntax colouring is also nice
17:27:27 <wabash> cool, thanks.
17:27:32 <dons> identifier completion is useful
17:27:39 <dons> as is a 'jump to definition' ability
17:33:18 * SamB wonders how markers could be placed in the heap profile ...
17:36:10 <BMeph|away> I swap between emacs and notepad++, depending on how much of a PITA it is to get emacs to do what I want. :)
17:36:40 <wabash> PITA?
17:36:49 <wabash> Oh, I get it.
17:36:56 <wabash> unfold PITA
17:37:09 <yip> pain in the ass
17:38:58 * BMeph thinks that if notepad++ had a "run a subprocess in a (tabbed) window, he'd ditch emacs...
17:39:34 * BMeph should have a ' " ' aafter 'window.'
17:39:45 <tehgeekmeister> http://hpaste.org/13697 <== figured out that at no point is the query i'm trying to run making it to postgresql, so i figure the problem must be somewhere in my haskell.  any idea why the statement never gets run, but i get an empty list from fetchAllRows anyway?
17:40:03 * BMeph sighs, and puts his 'Typing: FAIL' shirt back on.
17:40:14 <ddarius> :t fail
17:40:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
17:40:57 <ddarius> > tail $ inits ":type"
17:40:58 <lambdabot>   [":",":t",":ty",":typ",":type"]
17:42:14 <wabash> does Haskell have symbols, a la Ruby?
17:42:15 <diltsman> I'm building a cabal package, and it is telling me that one of the dependencies (which I already built and installed) is missing.  The dependency is in ~/lib.
17:43:27 <mofmog> If the greeks had invented computers, would we program computers using programming languages with case endings?
17:43:59 <wabash> No, but the frats would all use a different alphabet.
17:44:14 <mofmog> hey guys i'm in aleph alpegh gimmel
17:44:22 <Saizan> can i get an auto-adjusting table layout with Text.PrettyPrint.HughesPJ ?
17:44:57 <wabash> goodnight. Dinner time.
17:45:07 <BMeph> wabash: Strings in Haskell are immutable, and compared by substance, not memory location. Thus, symbols are superfluous, IMO.
17:45:21 <BMeph> wabash: Have a good dinner. :)
17:45:30 <wabash> oh, caught me at the last second, Pointer hovering over the close window button!
17:45:34 <Saizan> diltsman: is that package listed in ghc-pkg list ? also you need to configure with --user if you've installed those dependencies in the user packagedb
17:45:54 <wabash> BMeph: Well, in Ruby they are very fast. Immutable strings in Haskell very fast?
17:46:03 <mofmog> real question: how would one go around sending say... a 20 hz sine wave to audio output?
17:46:20 <mofmog> the closest i've seen is a hack where you output raw audio data and then pipe it to a media player
17:46:23 <BMeph> wabash: At what - a 40-meter dash? ;)
17:46:28 <mofmog> i think dons commented on it but i can't find it anymore
17:46:45 <wabash> BMeph: Dunno..... Uh, fast for Ruby, that is.
17:46:50 <wabash> I'll look into it later. GTG.
17:46:59 <ozy`> wabash: haskell lets you define nullary constructors, which are a bit like anonymous constants if you're--damn
17:47:03 <pejo> diltsman, is the dependency installed as user but you're building your package for --global?
17:47:10 <SamB> Lemmih: I'm not too good with this heap profiling :-(
17:47:48 <pejo> diltsman, apparently Saizan beat me to it. :-)
17:48:31 <BMeph> ozy': Do you think he meant "fast to (pattern) match on?" Modulo, blah-blah, "Ruby", yadda-yadda "matching"? ;)
17:48:32 * SamB wonders why LHC doesn't think Read is derivable
17:49:49 <newsham> mofmog: open up the audio device, set up the sampling rate and sample format with device controls, then write out a series of samples that represent a 20hz sine wave in the sampling frequency and samling format you've selected.
17:50:27 <ozy`> BMeph: yes. that's more or less what symbols are for in ruby
17:50:28 <mofmog> newsham: like pipe to /dev/audio?
17:50:36 <newsham> ie. set sampling freq to 8000, set samples to single-byte signed samples, and write out a sine wave with period 400 and magnitude 120
17:50:42 <mofmog> i've tried that but the device is busy, leading me to believe i have to turn off also or something first
17:50:49 <newsham> mofmog: not a pipe, but /dev/audio, yes.
17:50:59 <mofmog> well  > or something similar right?
17:51:07 <ozy`> BMeph: I came to haskell from ruby, for what it's worth
17:51:09 <mofmog> *alsa
17:51:10 <newsham> if the device is busy you may have a sound daemon that mediates access to the device
17:51:15 <mofmog> yeah exactly
17:51:29 <newsham> in which case you'd have to either turn off the sound daemon and use the deivce directly, or learn how to send audio data to the sound daemon
17:51:29 <mofmog> i'm on ubuntu btw
17:51:42 <mofmog> oh god isn't that a terrible proposition on linux?
17:51:48 <ddarius> mofmog: If you intend to do a lot of this sort of thing in Haskell, you may want to look at the Haskell SuperCollider stuff.
17:52:26 <bd_> mofmog: pasuspender <app> will shut off the sound daemon (pulseaudio) until <app> exits :)
17:52:37 <newsham> i've never done audio with ubuntu.
17:54:08 <mofmog> now shouldn't there be less janky way then pasuspender?
17:54:11 <BMeph> ozy': Ah, useful - thanks for the response. Anyhow, I think there's overlap, but the answer is "no". Pity. :|
17:54:25 <repnop> if you're using pulse...you should have alsa/oss plugins :)
17:55:06 <Peaker> s/you're using/you have a
17:55:16 <mofmog> ugh i was hoping this could be the slightest bit cross platform
17:55:17 <newsham> on ubuntu 6.10 I can "echo test >/dev/audio" and it doesnt complain of the device being busy
17:55:55 <mofmog> newsham: where you the guy who wrote the program that outputted a mozart tune?
17:56:05 <newsham> nope.
17:56:30 <mofmog> i guess ill look at supercollider than
17:56:31 <mofmog> then
17:56:31 <ozy`> BMeph: the only thing I can think of that you can do with symbols in ruby that's not possible with constructors is converting them to/from strings
17:56:35 <newsham> but i've done a bit of audio programming for kicks in the past
17:56:49 <Olathe> deriving Show is nice for Strings.
17:56:58 <Olathe> Maybe even Read !
17:57:43 <diltsman> Saizan: I configured it using the --user option.  It shows up for ghc-pkg list.
17:57:46 <ozy`> BMeph: ruby symbols are basically named ints, rather than strings per se
17:58:27 <Saizan> diltsman: so you configured both the dependency and the package you're currently compiling with --user?
17:58:40 <diltsman> Saizan: Yes.
17:58:52 <Saizan> diltsman: can you paste the error message?
17:58:54 <Saizan> @paste
17:58:54 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:58:57 <ddarius> mofmog: There's a whole bunch of sound related libraries on Hackage.
17:59:06 <ddarius> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Sound
17:59:16 <Zao> Cat sound? Meow.
17:59:33 <Saizan> diltsman: and the relevant portion of ghc-pkg list
17:59:43 <shapr> mofmog: I think there's a SuperCollider binding for Haskell.
18:00:27 <BMeph> ozy': Also, it looks as if using the same symbol in multiple hashes saves memory by "pointing" to the same symbol, versus making a new copy of a string.
18:00:47 <diltsman> Saizan: http://hpaste.org/13698
18:01:44 <Saizan> diltsman: see, you've installed HTTP-4000.0.1 but cabal-install wants HTTP >=3000 && <3002
18:01:44 <ozy`> BMeph: yep. and any time an identifier is used in a program, for any purpose, an associated symbol is generated and internalized
18:02:06 <Saizan> diltsman: you need an older version of HTTP
18:02:32 <Saizan> diltsman: btw, have you tried running the bootstrap.sh script that comes with cabal-install?
18:03:12 <Saizan> it should install the needed packages for you
18:04:38 <diltsman> Saizan: That would have been nice to know about before I use Lynx to get all of the packages that I thought I needed.
18:04:43 <eu-prleu-peupeu> bye guys
18:05:01 <eu-prleu-peupeu> i love you all very nice good
18:05:30 <Saizan> diltsman: heh, i guess :)
18:05:48 <SamB> Lemmih: someone seems to have messed up E printing :-(
18:07:16 <Saizan> @source System.Console.GetOpt
18:07:16 <lambdabot> http://darcs.haskell.org/packages/base/System/Console/GetOpt.hs
18:07:27 <SamB> W@.fInstance@.iLhc.Num.-.Data.Complex.Complex = Î›a.
18:07:27 <SamB>                                                 Î»X@.fId 212@1âˆ·a.Î»X@.fId 212@2âˆ·a.
18:07:27 <SamB>                                                 Î»X@.fId 214@1âˆ·a.Î»X@.fId 214@2âˆ·a.
18:07:27 <SamB>     let
18:07:40 <SamB> thesee "Id 212" things don't look right
18:10:32 <SamB> Lemmih: or it could just be an issue with the generation of these identifiers in the first place ...
18:11:15 <SamB> yeah, that has to be it
18:13:03 <SamB> okay ... a kind issue ...
18:13:43 <SamB> Lemmih: what have you done with kind inference ?
18:19:22 <pumpkin> dons: I brought this up before, but about the lazy Bytestring CSV parsing... are there any particular challenges you can foresee?
18:19:49 <pumpkin> my issue is that I have some pretty big csv files and don't necessarily want to load it all into memory at once
18:21:08 <wchogg> how big is big?
18:22:38 <hoelzro> what's the best way to find an element matching a predicate in a Set? findSet pred set = find pred $ toList set?
18:23:26 <pumpkin> wchogg: 600 megs :P
18:23:40 <rwbarton> hoelzro: Yes (for a generic pred)
18:23:47 <pumpkin> wchogg: I should probably use a better format, but I'm just using csvs to exchange data between matlab and my haskell program
18:23:54 <pumpkin> and don't have an easy binary/efficient format for that
18:24:04 <hoelzro> rwbarton: is there a more optimal version for certain predicates?
18:24:39 <rwbarton> hoelzro: Well, if your predicate is "is in the range [lo..hi]", for instance
18:24:45 <pumpkin> if the predicate happens to be "is equal to Ord item x" then yeah :P
18:24:49 <rwbarton> hoelzro: since the Set is implemented as a balanced binary tree
18:24:57 <rwbarton> pumpkin: right :)
18:25:31 <hoelzro> I'm using (==), so I think there'd be an O(log n) function for searching a set
18:25:46 <pumpkin> member?
18:26:20 <hoelzro> member just tells me if it's there
18:26:44 <hoelzro> I need a function findSet :: Set a -> a -> Maybe a
18:26:49 <rwbarton> ... but you need the actual element, because your (==) makes things equal that aren't the same?
18:26:57 <hoelzro> for normal elements, yes =P
18:26:59 <hoelzro> however
18:27:07 <pumpkin> o.O
18:27:17 <hoelzro> my elements are arranged in such a way that (==) doesn't mean structural equality
18:27:19 * hoelzro ducks
18:27:25 <pumpkin> I think the assumption is if you ask if it's a member and it says True, then you already have it :P
18:27:25 <pumpkin> ah
18:27:33 <pumpkin> lol
18:27:39 <rwbarton> hoelzro: I think you can cook something up using split.
18:27:40 <hoelzro> basically, the set is a set of command line options
18:27:47 <diltsman> How do you get a different version of the base package?
18:27:48 <pumpkin> using a Map might be easier too
18:27:57 <hoelzro> hmm
18:28:19 <rwbarton> Oh, it specifically doesn't return the information you're interested in
18:28:29 <hoelzro> I think split may work
18:28:39 <hoelzro> like findMin . split or something like that
18:28:39 <pumpkin> just do a Map a [b] and add your "== but not equal" objects to the list
18:28:44 <pumpkin> but that looks prettier :P
18:29:36 <rwbarton> hoelzro: but split doesn't return any elements that are ==
18:29:42 <hoelzro> haha, split includes everything *but* my element =D
18:29:48 <pumpkin> subtract now! :P
18:29:49 <hoelzro> yeah, I just tried it
18:29:53 <pumpkin> ;)
18:30:07 <hoelzro> no succ operation on these =(
18:30:16 <rwbarton> I think you might be getting what you deserve here :P
18:30:20 <hoelzro> oh, I am
18:30:25 <rwbarton> but I'm not sure, there might be a way.
18:30:26 <hoelzro> I have no illusions about that
18:30:29 <pumpkin> maybe try the Map thing I said before?
18:30:35 <hoelzro> yeah, I think pumpkin's right
18:31:14 <SamB> hoelzro: it always bothered me the way they used that in Smalltalk ...
18:31:28 <hoelzro> SamB: which?
18:31:29 <hoelzro> Set?
18:31:57 <SamB> pairs with non-structural equality to turn Set into Map (only they called them other names)
18:32:04 <hoelzro> ah
18:32:17 <hoelzro> yeah, I'm not really happy with that
18:32:22 <hoelzro> but it seemed the best solution
18:33:03 <SamB> Lemmih: I've sent you a patch that almsot adds Control.Arrow and Control.Applicative to base ...
18:33:38 <pumpkin> how hard do you guys think it would be to make an RArrow like RMonad? (http://hackage.haskell.org/cgi-bin/hackage-scripts/package/rmonad)
18:33:45 <pumpkin> could one apply the same ideas?
18:33:52 <SamB> it doesn't, though, because Control.Arrow doesn't build
18:37:28 <mauke> luite_: whoa, are you looking at every single image there?
18:39:49 <ddarius> wget -r -l infinity
18:40:02 <mauke> that's the weird thing, he's using firefox
18:40:58 <mauke> more specifically, firefox 3.0.5 running in X11 on ubuntu 8.10 (x86_64)
18:45:42 <SamB> mauke: there ARE extensions for that
19:07:50 <int80_h> I'm having trouble with  the syntax of nested parameterized types
19:08:07 <int80_h> data SimpleTree a = Node a (Just (SimpleTree a)) (Just (SimpleTree a))
19:08:20 <luite_> mauke: it's a bookmarklet that shows all images in a folder
19:08:30 <mauke> I see :-)
19:08:34 <int80_h> I get a complaint of Just not being in scope
19:08:50 <int80_h> This is exercise 2 pg 60, RWH
19:08:53 <mauke> int80_h: did you mean Maybe?
19:08:57 <scsibug> int80_h: Just is a constructor, you want to use a type
19:09:28 <int80_h> oh, I misread the instructions. Thanks
19:09:31 <rwbarton> int80_h: Just is a data constructor, you want to use a type constructor :)
19:10:31 <int80_h> Okay the code compiles. Now I want to figure out a way to verify it does what I think it does.
19:11:10 <Olathe> > fix (:[])
19:11:11 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
19:11:11 <lambdabot>        Expect...
19:14:31 <ztirF> is it possible to stop "show" from escaping something?
19:15:14 <Olathe> Write your own function.
19:16:44 <yip> a function that converts a string into the same string with no changes? id?
19:17:33 <ztirF> > id "abcd"
19:17:34 <lambdabot>   "abcd"
19:17:49 <mauke> :facepalm:
19:18:24 <Olathe> > say $ id "zomg"
19:18:25 <lambdabot>   zomg
19:18:29 <Olathe> > say $ show "zomg"
19:18:30 <lambdabot>   "zomg"
19:21:21 <ztirF> @type say
19:21:23 <lambdabot> String -> Expr
19:21:28 <ztirF> @src say
19:21:29 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
19:21:30 <jonaskoelker> Hello all.  I'm trying to write some code that evaluates an expression tree n times, each time with a different random number generator.  Should (in the error monad, using Either String) "sequence [roll' g env r | g <- take (toInt n) gens]" (r is the expression) work, and why not? ;) -- I suspect it of being broken.
19:21:56 <jonaskoelker> the complete file is at http://hpaste.org/13700
19:23:09 <Olathe> > let f n t = map (take n.randoms.mkStdGen) [1..t] in f 3 5
19:23:10 <lambdabot>   [[7917908265643496962,-1017158127812413512,-1196564839808993555],[-24937218...
19:28:20 <Saizan> jonaskoelker: nothing obviously wrong, what's the problem with it?
19:29:33 <jonaskoelker> Saizan: if I run "let a=3#d6 in let b=3#d6 in sum(a, b)", I get the wrong distribution, whereas "sum 5#d6" gives the right one
19:30:02 <jonaskoelker> Saizan: if I special-case "(integer constant)#...", both work
19:30:13 <jonaskoelker> oops, s/b=3#/b=2#/
19:32:57 <lucca> whoa, a dice combinator?
19:33:10 <jonaskoelker> yep
19:35:04 <lucca> Heh, cool.  Recently did something similar for new world of darkness dice
19:35:09 <jonaskoelker> it's a fairly simple one; I'm seeing 1250 lines, 280 of which are the optimizer :)
19:35:26 <lucca> Though that was for odds rather than actually rolling anything
19:35:28 <yip> lucca: what is new world of darkness?
19:35:44 <jonaskoelker> Vampire: TM etc, right?
19:35:52 <lucca> yip: a pencil-and-paper role playing game
19:36:06 <lucca> jonaskoelker: yes
19:36:34 <yip> lucca: what does the official package include? just a book?
19:37:05 <lucca> jonaskoelker: only the new one is the Requiem instead, and I'm more interested in the werewolves and changelings
19:37:14 <lucca> yip: yes
19:37:46 <lucca> potentially a bunch of books.  Quite a racket, but enjoyable.
19:39:05 <lucca> jonaskoelker: for D&D style dice, I found it better to have fudging operators as well, so you can roll things like "best 3 of 4d6" and the like
19:39:11 <adamjones> I have a kind of lengthy design question.
19:39:38 <jonaskoelker> the language supports that as well :) "sum high 3 of 4#d6"
19:39:53 <lucca> jonaskoelker: nice
19:40:09 <adamjones> I'm writing a game and would like the set of objects in the game to be "open", with common operations expressed as a typeclass.
19:40:26 <lucca> what do you mean by open?
19:40:35 <jonaskoelker> I've even written a program in it which fights a Risk battle, given the number of attacking/defending pieces at the beginning :D
19:41:01 <adamjones> not all of the objects in the game are defined in one place, (e.g. they can be extended later with a module)
19:41:11 <jonaskoelker> it turns out the attackers need to outnumber the defenders about {2,2.5,3}'ish-to-1 to have even odds
19:41:14 <bos> @seen dons
19:41:14 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 2h 13m 34s ago.
19:41:30 <adamjones> so I can't use an ADT to represent the objects in the game.
19:41:57 <ddarius> adamjones: You could use an existential.
19:42:05 <adamjones> ok
19:42:18 <jonaskoelker> you could use OOHaskell :)
19:43:02 <lucca> adamjones: another approach might be to use haskell to implement your more dynamic domain specific language
19:43:03 <adamjones> The big question I have is how do I handle having one unit in the game target another unit in a general enough way that they could target anything.
19:43:37 <lucca> does target mean reference?
19:43:51 <adamjones> yes.
19:43:59 <Olathe> (Shooter a, Shootable b) => a -> b -> b
19:44:25 <adamjones> Olathe: something like that.
19:44:30 <yip> adamjones: i would look either at existentials or at yampa
19:45:12 <adamjones> yip: thanks
19:46:08 <yip> i tried doing a simple RTS with yampa a while ago but didn't get much past the planning stage :)
19:46:39 <adamjones> I'd rather do all of this in one langauge for now. The previous attempt at this game was in Java/Clojure and bridging between the two wasn't worth the advantages of either.
19:47:10 <geezusfreeek> adamjones, in case there is confusion, yampa is a haskell library
19:47:12 <yip> yampa is a haskell library
19:48:21 <yip> but yampa has still yet to be proven for implementing anything beyond "toys". quite a bit more research is needed so that it can be used for even simple things
19:48:26 <geezusfreeek> adamjones, it is one of several functional reactive programming libraries. FRP is still a heavily researched topic, but that doesn't mean you can play with what's out there already ;)
19:48:54 <geezusfreeek> adamjones, there is also the excellent Reactive library, which many may suggest would be nicer to try than yampa
19:49:14 <geezusfreeek> adamjones, or, of course, you could stick with "plain haskell" if you would rather
19:49:51 <wchogg> I think Reactive is much easier to understand than Yampa at the moment, but there's a couple of showstopper bugs that are currently being worked on.  You might want to wait a few weeks before making a game in it.
19:49:54 <adamjones> thanks all.
19:50:08 <jonaskoelker> k
19:50:15 <jonaskoelker> oops
19:50:22 <yip> adamjones: if you want your mind blown then look into yampa or another FRP library. but if you want to be practical then a mix of classical imperative/funtional style might be best
19:50:45 <geezusfreeek> yeah, what yip said
19:50:55 <geezusfreeek> (had a thing typed up, but that sums it up)
19:51:04 <igowen> is "combinator" roughly synonymous with "higher-order function"?
19:52:59 <ztirF> it's like the terminator, only it combinates?
19:53:09 <ztirF> hasta la vista, baby
19:53:56 <geezusfreeek> igowen, that _sounds_ about right to me, but you made me realize i have never really formalized the meaning in my head, so i could be just generalizing from my observations
19:53:58 <yip> FRP is to game programming what parsec is to parsers :)
19:54:12 <geezusfreeek> FRP is not just for game programming
19:54:19 <yip> right it's for any interactive system
19:54:38 <geezusfreeek> which is really any _useful_ system :)
19:55:01 <yip> only problem is there are still huge holes that need to be filled by research
19:55:21 <pumpkin> that's not a problem, it's a feature!
19:55:34 <pumpkin> lots of people have trouble coming up with good research topics :P
19:55:35 <geezusfreeek> s/a feature/fun/
19:55:36 <pumpkin> and research BS stuff
19:55:43 <yip> like take the space invaders yampa demo. now think about adding multiplayer networking to it. one does not even know how to begin to think about implementing this
19:56:00 * geezusfreeek has never really used yampa
19:56:45 <Saizan> i think combinator as in "combinator library" is more of a qualitative term than a formal one
19:57:03 <yip> or even simpler, add a save/load game feature. now you somehow need full access to the state that was so elegantly hidden away
19:57:45 <Saizan> and e.g. i'd call (<*>) a combinator and it's not exactly higher-order
19:58:02 <yip> plus there are major performance obstacles
19:58:56 <yip> nevertheless yampa is still as cool as hell though :)
19:59:14 <igowen> hmm, according to RWH combinators are "functions that take other functions as arguments and return new functions"
19:59:23 <igowen> so I guess they're a subset of higher-order functions
19:59:40 <yip> and it's a great example of how functional programming is awesome and totally different from anything imperative land has to offer
19:59:52 <Saizan> yip: in fact some of the FRP aficionados also wish for orthogonal persistence :)
20:00:12 <ksf> http://lambda-the-ultimate.org/node/3151
20:00:28 <ksf> ...and I thought my toread-file was empty.
20:00:36 <yip> Saizan: yeah, persistence can be implemented directly in the FRP layer so that all applications get save/load for free
20:00:55 <yip> Saizan: but sometimes you want more fine grained control
20:01:50 <Saizan> my toread-file never gets shorter..
20:02:32 <ksf> well, the tounderstand-file gets longer and longer...
20:03:09 <ksf> slurping stuff so you know where to look when you see a similar problem is somewhat different.
20:05:04 <igowen> heh
20:07:26 <ddarius> ksf: How do you ever empty a toread file?
20:07:48 <yip> cat toread > /dev/brain
20:07:54 <igowen> seems like every time something gets removed from the tounderstand file, several more things get added
20:07:58 <yip> echo "" > toread
20:07:59 <mauke> by becoming a toreador
20:08:10 <dlurf> rm -rf toread
20:08:53 <ksf> it's easy.
20:09:03 <roconnor> finding proofs that the image of a compact set under a continuous function is compact is easy to find.
20:09:35 <ksf> just be interested in stuff that noone's writing intelligble papers about and you can empty it quite quickly.
20:09:36 <roconnor> Finding papers that show that you cannot prove that the image of a compact set under a continuous function is compact are more difficult to find
20:10:15 <ddarius> ksf: Such as?
20:10:29 <ddarius> and that's somewhat limiting.
20:10:29 <ksf> uhmmm... reactive. but don't tell conal.
20:10:49 <ksf> psychology, otoh.
20:11:19 <ddarius> If you are interested in Reactive, you should learn, among other things, some signal processing and once you go down that path, you can never return.
20:11:30 <igowen> heh
20:11:31 <ksf> where there's the great gap between people who a) know psychology but know nothing about hacking and b) people who can hack but know nothing about psychology.
20:12:06 <ksf> i've approached it from a dataflow perspective.
20:12:50 <ksf> which _can_ denote the same stuff as signal processing, up to terminology and babel, that is.
20:14:39 <igowen> god, I love abstraction
20:15:09 <ddarius> > (\x -> x) 3 -- another one bites the dust
20:15:11 <lambdabot>   3
20:16:28 <ksf> what I really want to see is a paper called "reactive programming, or: why you don't get it", that actually spells out all those beautiful program design techniques frp is supposed to have been invented for..
20:16:53 <yip> ksf: the space invaders paper is pretty good
20:17:01 <yip> ksf: the fruit paper is also good
20:17:41 <Saizan> those are arrow based?
20:17:47 <ksf> I'm not sure about the fruit one, but I read the space invaders one.
20:18:16 <ksf> the closest thing to such a thing for reactive i've seen is the tetris implementation.
20:18:31 <ksf> space invaders is yampa afair.
20:18:47 <yip> they are both arrow based
20:19:09 <yip> i don't really understand what downside arrows have that reactive is supposed to address
20:19:39 <dlurf> I bet the research council is happy to see "wrote a paper about space invaders" in an activity report... :-)
20:19:46 <ddarius> Fruit is based on Yampa
20:20:13 <ddarius> dlurf: "Wrote a thesis on Quake."
20:20:15 <SamB_XP> dlurf: in functional programming, that's actually quite prestigious
20:21:01 <Olathe> "Overreactive programming: You've ignored it...and now you're gonna pay !"
20:21:25 <ksf> regarding arrows, see http://conal.net/blog/posts/functional-reactive-chatter-bots/
20:24:08 <ksf> in short: making the plumbing stick out makes it harder to optimise water flow.
20:24:59 <yip> ksf: are you convinced by that argument?
20:29:09 <ksf> well, arrows aren't really declarative.
20:29:54 <mmorrow> what is your definition of "declarative"?
20:30:44 <ksf> so that you can grab it with code and mangle easily... blame me for having intuitive heuristics.
20:31:14 <mmorrow> i don't understand what you mean by "grab it with code and mangle easily"
20:31:14 <ksf> it's the what vs. how-topic.
20:32:14 <mmorrow> (literally i don't understand what that's supposed to mean, it's not a rhetorical question :)
20:32:47 <mmorrow> arrows are a "what"
20:33:01 <mmorrow> functions are data
20:33:22 <ksf> take algebra as an analogy, symbolic vs. numeric calculation. arrows appear to me to be closer related to numerical than symbolic stuff.
20:33:41 <ksf> ...or easier to implement _on top of_ stuff like reactive.
20:34:07 <ksf> they don't feel like the right thing to use as primitives.
20:34:10 <mmorrow> i don't see the numerical aspect of it.
20:34:42 <ksf> don't take it literally.
20:34:52 <mmorrow> yeah, that's another issue entirely (whether Arrow (:= as defined by the Arrow class) is a good primitive)
20:36:18 <ksf> but i see how my usage of "declarative" can confuse the hell out of people, I would use it without hesitating to describe assembly... in the right context, that is.
20:36:21 <mmorrow> my understanding is that reactive is about defining the "what" that will happen should a certain event occur
20:37:30 <mmorrow> or maybe better said, a mapping from events to output
20:37:39 <mmorrow> "output"
20:38:22 <mmorrow> but i'm not entirely familiar right now with the whole reactive matra..
20:38:27 <mmorrow> *mantra
20:38:30 <ksf> there isn't even a need for stuff to happen...
20:38:52 <mmorrow> well, it does in real life, and reactive abstracts that away
20:39:11 <mmorrow> an arrow is the same concept as a function
20:39:15 <ksf> it's just a framework for calculating with time, including loops and a lot of bells+whistles that returns stuff.
20:39:26 <Olathe> @src Arrow
20:39:26 <lambdabot> class Arrow a where
20:39:26 <lambdabot>     arr, pure   :: (b -> c) -> a b c
20:39:26 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
20:39:26 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
20:39:26 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
20:39:28 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
20:39:30 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
20:39:33 <jonaskoelker> :( stdGen sucks
20:39:35 <Olathe> arr, pure ?
20:39:42 <Olathe> Is that a function name ?
20:39:48 <mmorrow> jonaskoelker: indeed
20:39:53 <ksf> it's two.
20:39:53 <Saizan> two functions
20:40:05 <Olathe> You can do that to type two functions ?
20:40:10 <Saizan> yes
20:40:15 <ksf> even to define them.
20:40:18 <Olathe> Ahh.
20:40:30 <Olathe> > let omg, zomg = 5 in (omg, zomg)
20:40:32 <lambdabot>   <no location info>: parse error on input `='
20:40:40 <ksf> you can also say (foo, main) = (undefined, putStrLn "Hey, works!")
20:40:42 <Saizan> define i don't think
20:40:49 <Olathe> > let (omg, zomg) = 5 in (omg, zomg)
20:40:51 <lambdabot>       No instance for (Num (t, t1))
20:40:51 <lambdabot>        arising from the literal `5' at <i...
20:40:51 <Saizan> ah, ok, that's different
20:40:54 <mmorrow> , [d|data A = A {foo, bar :: Int}|]
20:41:00 <lunabot>  DataD [] A [] [RecC A [(foo,NotStrict,ConT Int),(bar,NotStrict,ConT Int)]...
20:41:16 <Olathe> @type let omg, zomg :: Int; omg = 5; zomg = 6 in (omg, zomg)
20:41:17 <lambdabot> (Int, Int)
20:41:43 <mmorrow> i was surprised when i by accident disvcovered that
20:41:51 <mmorrow> [foo,bar] = [1,2]
20:42:00 <mmorrow> is valid _at the top level of a module_
20:42:09 <seafood> Wow, I didn't realise HAppS was such a visionary project.
20:42:10 <ksf> [infile] <- getArgs...
20:42:24 <ksf> can't be bothered to write more before writing the rest.
20:42:26 <mmorrow> [a,b,c,d,e,f,g,h,i,j.k] = "abcdefghijk"
20:42:33 <seafood> Who's working on HAppS these days? Do people use all its features?
20:42:37 <Olathe> What does a b c in a b c -> mean ?
20:42:58 <mmorrow> (->) a b
20:43:04 <rwbarton> b `a` c
20:43:07 <mmorrow> Either a b
20:43:16 <Saizan> seafood: i'm not sure if anyone is using multimaster yet :)
20:43:19 <mmorrow> a :: * -> * -> *
20:43:20 <rwbarton> Just like [m a] -> m [a]
20:43:37 <Olathe> So, a and b are types ?
20:43:41 <seafood> Is Alex Jacobson the guy who started HAppS?
20:43:43 <ksf> multimaster is done?
20:43:53 <mmorrow> a :: * -> * -> *, b :: *, c ::*
20:43:55 <shapr> seafood: yes
20:44:02 <seafood> shapr: Is he still working on it?
20:44:06 <shapr> I don't know.
20:44:20 <shapr> Saizan will probably know.
20:44:20 <seafood> shapr: Do you make websites in Haskell?
20:44:35 <Saizan> ksf: yes, since some time ago
20:44:38 <shapr> seafood: I've been looking at Turbinado, does that count?
20:44:45 <shapr> Saizan: oh really?
20:44:51 <seafood> I don't know, I haven't looked at it.
20:45:03 <Olathe> @djinn a b c -> a c d -> a b d
20:45:04 <lambdabot> -- f cannot be realized.
20:45:06 <shapr> That's funny, I have the perfect computer for multimaster HAppS.
20:45:30 <Saizan> shapr: there's a chat example with multimaster in the HAppS-Server or HAppS-State repo
20:45:35 <mmorrow> @djinn (b -> c) -> (a -> b) -> (a -> c)
20:45:35 <lambdabot> f a b c = a (b c)
20:45:37 <shapr> Nifty
20:46:01 <mmorrow> @src (->) Arrow
20:46:01 <lambdabot> Source not found. Just try something else.
20:46:08 <mmorrow> @src Arrow (->)
20:46:08 <lambdabot> Source not found.
20:46:11 <shapr> I could see having lots of fun with multimaster on a seventeen slot blade server where each blade has its own ram & drive.
20:46:16 <Olathe> @src (->) (>>=)
20:46:16 <lambdabot> f >>= k = \ r -> k (f r) r
20:46:21 <shapr> er, fourteen, oops
20:46:37 <mmorrow> @src (->) arr
20:46:38 <lambdabot> arr f = f
20:46:42 <Saizan> the whole state is replicated on each node
20:46:44 <mmorrow> @src (->) (>>>)
20:46:45 <lambdabot> f >>> g = g . f
20:46:46 <shapr> oh
20:46:52 * ksf engages in extreme-dd-programming
20:46:52 <Olathe> @instances Arrow
20:46:53 <lambdabot> (->), Kleisli m
20:47:03 <shapr> I thought the early design discussions had the state being split.. foo.
20:47:19 <Saizan> that's to be implemented, afaiu
20:47:30 <shapr> I'd like that, it would make perfect sense for a bladeserver.
20:48:44 <Saizan> eh, yeah
20:48:48 <shapr> All the blades (in mine) have gigabit access to each other with a really fast backbone. No way I can afford anything lower latency than gbit from several inches away.
20:49:24 <mae> I get this whenever I press "up" or "down" in ghci -- its driving me nuts! -- Prelude> ^[[A^[[B .. what can I do to troubleshoot this?
20:49:36 <mae> I want my command history!
20:49:43 <shapr> mae: It means your terminal is confused.
20:49:50 <Saizan> mae: you miss editline
20:49:53 <mae> ah wrong key mapping?
20:50:03 <shapr> Oh
20:50:06 <shapr> That then :-)
20:50:27 <mae> i was thinking it had to do with readline
20:50:50 <mae> Do I have to rebuild ghci?
20:50:50 * Saizan recommends http://code.haskell.org/~judah/ghci-haskeline
20:51:02 <shapr> @index IOExts
20:51:03 <lambdabot> bzzt
20:51:05 <mmorrow> mae: install libedit(-dev) and rebuild
20:51:17 <mae> arg
20:51:17 <mae> ok
20:51:21 <mmorrow> (rebuild all of ghc :((
20:51:29 <mmorrow> (if you built it yourself)
20:51:33 <mae> I removed the cache
20:51:37 <mae> i have to rebuild the whole thing
20:51:38 <mae> damn
20:51:38 <Saizan> mae: try that ghci-haskeline, shorter to rebuild
20:51:38 <mae> hehe
20:51:42 <Saizan> and works better
20:51:47 <mae> o?
20:51:53 <mmorrow> it'd be safest to do make distclean, but maybe you can get away with it
20:51:56 <Saizan> not as good as the old readline though
20:52:14 <mmorrow> Saizan: oh snap! ghci-haskeline??
20:52:16 <mae> old readline? what do you mean
20:52:33 <Saizan> mae: before 6.10.1 ghci used readline
20:52:36 <mmorrow> readline was so far superior to editline with ghci
20:52:42 <bos> Oh, sweet. My Haskell memcache client is now faster than the blazing-fast C client.
20:52:55 <mmorrow> bos: woot
20:53:03 <Saizan> mmorrow: yeah, see above for the link :)
20:53:03 <shapr> bos: Awesome, how'd you do that?
20:53:06 <mae> cool :)
20:53:14 <bos> shapr: nothing special, to be honest.
20:53:20 <mmorrow> Saizan: oh nice, missed that
20:53:39 <bos> shapr: I'm using the binary and attoparsec packages in pretty obvious ways.
20:53:40 <mae> what i s the difference between editline and readline?
20:53:55 <mmorrow> editline sucks, readline doesn't?
20:53:59 * mmorrow is feeling beligerent
20:54:02 <mae> . . .
20:54:17 <bos> The one thing I do is merge multiple client requests into single TCP segments, which required almost no effort thanks to the awesomeness of monads.
20:54:20 <shapr> ooh, when did attoparsec arrive?
20:54:24 <adimit> erhm. Not to sound stupid. But, to lowercase a ByteString, I'll have de- and reencode it, eh?
20:54:25 <mmorrow> editline is bsd, readline is gpl
20:54:25 <Saizan> editline doesn't properly support utf8, or any multibyte encoding, for once
20:54:39 <bos> shapr: I've been working on it on and off for a while.
20:54:47 <shapr> That's purty!
20:54:54 <rwbarton> @type Data.ByteString.map
20:54:56 <lambdabot> (Word8 -> Word8) -> BSC.ByteString -> BSC.ByteString
20:55:03 <bos> editline is sort of abandonware from a decade ago.
20:55:10 <shapr> What's the best binary-oriented parsec-style lazy bytestring parser?
20:55:13 <Saizan> @type Data.ByteString.Char8.map
20:55:15 <lambdabot> (Char -> Char) -> BSC.ByteString -> BSC.ByteString
20:55:18 <jonaskoelker> how big are Ints promised to be by the standard? 28 bits?
20:55:19 <rwbarton> adimit: You could use Data.ByteString.Char8.map toLower
20:55:21 <mmorrow> bos: i saw you mail on haskell-cafe about adding epoll/etc as an option over select for ghc's io manager. is this true?
20:55:26 <bos> shapr: Data.Binary
20:55:28 <bos> mmorrow: yes
20:55:31 <rwbarton> adimit: (provided you don't care about unicode-correctness)
20:55:34 <adimit> rwbarton: OK, thanks, I'll try that.
20:55:35 <mmorrow> bos: i'm so happy!
20:55:37 <shapr> ok then!
20:55:43 <adimit> rwbarton: hum. I do a bit.
20:55:45 <mmorrow> bos: how's it coming?
20:55:49 <bos> shapr: but Data.Binary is really unsuitable for parses that might fail.
20:55:52 <shapr> oh
20:55:56 <adimit> (no pun intended)
20:56:07 <mae> hmm..
20:56:07 <shapr> What do most people use to make parsers for binary file formats?
20:56:09 <bos> mmorrow: It probably needs a week of focused work.
20:56:34 <adimit> although. I'll change the specs to ASCII. That'll do it.
20:56:36 <bos> shapr: depends on your needs. attoparsec might do the trick. it's got both Word8 and Char interfaces.
20:56:37 <shapr> Is there a trend in Haskell binary parsers?
20:56:42 <mmorrow> bos: nice. how will you package it (until it gets merged)?
20:56:47 <bos> mmorrow: i won't.
20:56:51 <mmorrow> heh
20:57:05 <rwbarton> "darcs push"
20:57:07 <mae> yeah packaging is a pain ....... :)
20:57:11 <Saizan> adimit: roughly speaking, bytestrings use latin-1 encoding
20:57:37 <bos> shapr: Ideally, the future holds a refactoring of Data.Binary that uses a continuation monad and that can handle backtracking and failure.
20:57:45 <mmorrow> rwbarton, mae: i meant in the sense of "what will be your strategy for overriding ghc's select-based IO manager"
20:58:10 <adimit> Saizan: well, yeah. Except when they got converted over from UTF-8. Then they still do, but it looks like garbage. :-)
20:58:11 <mmorrow> since anything to do with Handle uses it
20:58:49 <mae> hoorah for hidden namespaces :)
20:58:59 <mae> -fbosisawesome ?
20:59:05 <shapr> bos++
20:59:08 <shapr> @karma bos
20:59:08 <lambdabot> bos has a karma of 3
20:59:21 <shapr> @karma dons
20:59:21 <lambdabot> dons has a karma of 7
20:59:23 <mmorrow> bos++
20:59:27 <shapr> Huh, karma got zapped again?
20:59:29 <mae> bos++
20:59:39 <Saizan> bos: wasn't there a package that already does that? (i'm asking because i couldn't find it recently)
21:00:00 <bos> Saizan: adam langley wrote one based on Data.Binary
21:00:16 <shapr> Adam Langley is a cool guy.
21:00:22 <bos> Saizan: http://darcs.imperialviolet.org/binary-strict/
21:00:33 <shapr> I like his ObsTCP stuff.
21:00:35 <mmorrow> i've got an ffi binding to libev that's working at a basic level, but having this functionality for Handles would be verrrry prefereable
21:00:46 <mmorrow> (instead of only being able to use Fd)
21:01:15 <bos> In principle, libev shouldn't be necessary.
21:01:31 * mae agrees
21:01:33 <bos> In practice, GHC's IO manager has some scaling problems that need attention once the basic epoll support is wired in.
21:01:39 <mmorrow> totally, but i didn't want to write the code to interface with epoll/et al myself..
21:01:47 <zloog> Is there a (Show a)=> String -> Maybe a function that does the obvious?
21:01:57 <mmorrow> bos: snap. like what in particular?
21:02:05 <mae> yes bos, do tell.
21:02:28 <bos> mmorrow: Nothing serious, just some linked lists that should really be balanced search trees.
21:03:03 <Saizan> zloog: you mean Read a? there's reads
21:03:07 <bos> Basically, the threaded runtime has an IO manager thread. When another thread wants to do IO, it queues a request, and sleeps on an MVar.
21:03:12 <mmorrow> bos: ah nice. i've been reading the code for the io manager over quite a bit lately, it's interesting
21:03:26 <zloog> Saizan: Yeah, but that fails with a runtime error
21:03:26 <bos> The IO manager looks through its list, and wakes any threads that have IO pending.
21:03:36 <Saizan> ?type reads
21:03:37 <lambdabot> forall a. (Read a) => String -> [(a, String)]
21:03:42 <zloog> Saizan: Where nothing would be good
21:04:01 <Saizan> zloog: you're talking about "read", note the "s"
21:04:16 <zloog> Saizan: Ahh, thanks
21:04:41 <Saizan> ?type let readM s = case reads s of [(a,rest)] | all isSpace rest -> Just a; _ -> Nothing in readM
21:04:42 <lambdabot> forall a. (Read a) => String -> Maybe a
21:06:37 <diltsman> I need to implement a state machine.  Would I want to write a bunch of functions and use the State monad?
21:06:42 <mmorrow> bos: another thing that's (imo) sucky is the forkProcess/io manager death thing.
21:06:50 <zloog> Saizan: Works great, thanks
21:06:59 <bos> That list needs to be a balanced tree or something similar, so that the IO manager will only pluck specific leaves from the tree instead of searching the entire thing.
21:07:03 <mmorrow> bos: and judging from the ticket of tibbe's, it doesn't look like this will change
21:08:03 <bos> mmorrow: yeah.
21:08:05 <mae> bos: this sounds like a future problem (future of apps that pound IO manager this hard?)
21:08:34 <mae> premature optimization . . . <finished the sentence>
21:08:46 <bos> mae: any process that wants to handle a moderate number of network connections will run into this problem approximately immediately.
21:08:57 <bos> where moderate == > 1000
21:09:09 <mae> ah I see.
21:09:47 <mae> well, apache chokes at 1000, (without the event worker).
21:10:09 <mae> but then again, apache is ancient compared to what is available now.
21:10:17 <bos> 1000 is nothing much.
21:10:44 <bos> A well-engineered process should be able to handle hundreds of thousands of concurrent connections.
21:11:38 <mae> Indeed.
21:11:41 <seafood> shapr: See, it makes sense to me that using Turbinado might be better for me (in the short term) since the underlying techniques are more well established. How do you feel?
21:12:31 <mae> seafood: HAppS is kind of out there compared to turbinado's approach, if thats what you mean. (Not that you were asking me). What exactly are you building?
21:12:53 <seafood> mae: Nothing in particular.
21:13:22 <seafood> Certainly not something that needs to be high availability.
21:13:29 <mae> HAppS is more of a bundle of useful libraries than a framework.
21:13:43 <ddarius> Down with frameworks.
21:13:44 <seafood> Sure. How much have you used it?
21:13:53 <seafood> What makes you say that ddarius?
21:14:10 <mae> HAppS ? off and on in the last year
21:14:13 <mae> nothing too serious with it
21:14:35 <mae> turbinado seems to be leveraging more traditional (established) methodologies.
21:15:04 <ddarius> seafood: My experience with frameworks is that they are nice only insofar as you are doing exactly what they are designed for exactly how they do it.  If you want to do something different(ly), they become a huge pain.
21:15:40 <mae> HAppS is compelling to me because maintaining a database is so very practical / flexible / boring / error prone. HAppS lets you tie the persistance and code tightly together.
21:16:04 <seafood_> Yeah, I found that compelling too.
21:16:16 <ddarius> Personally, I think frameworks would work well at a project/application-specific level, but less so at more general levels.
21:16:48 <seafood_> ddarius: What do you classify as a framework? Ruby on Rails or, say, something like Drupal, Django, etc.
21:16:53 <mae> ddarius: amen to that brother, back in my RoR days I remember wanting to gouge my eyeballs out with pencils when I discovered strange behaviors and seemingly leaky abstractions. Reading the source code for Rails was very illuminating (and depressing).
21:17:22 <seafood_> mae: What was something that really annoyed you about RoR?
21:17:25 <ddarius> seafood: I haven't used any of those.  I have used various Java, C#, C++ frameworks.
21:18:03 <mae> seafood_: activedirectory, restful controllers, validations -- basically everything.
21:18:04 <seafood_> ddarius: Well Drupal is a content management system. It's probably not a framework. I'd regard RoR as a framework.
21:19:34 <jonaskoelker> does haskell have an interface to the OS random number generator?
21:19:53 <ddarius> For GUI frameworks, I would say things like Java's AWT and Swing, C++'s MFC and wxWindows, C#'s Forms and ASP.NET.
21:20:23 <mae> seafood_: particularly active directory -- it lulls you in to making nice object oriented classes to represent the data and then when you have to do something outside of active directory's powers you end up writing Hellish Join queries anyways. I am now of the opinion that ORM's of any kind are evil and that functional interfaces to data (rather than object oriented) are vastly superior. I'd rather write an SQL query than use anything that re
21:20:23 <mae> sembles smalltalk/ruby/python/<fill in trendy oo language here>
21:20:27 <ddarius> As contrast, Gtk and Qt (v. wxWindows) are not (or less so) frameworks.
21:20:35 <Saizan> for web developement i'd like some "widgets" though, since i'm sort of lazy
21:21:09 <mae> Saizan: web development and lazy don't mix, for one -- cross-browser testing is a monumental pain in the ass.
21:21:46 <seafood_> mae: I've done a bit of RoR and I'd concur with you about ActiveDirectory
21:22:14 <scsibug> jonaskoelker: I'd assume that GHC's Random class uses random data from the OS
21:22:30 <mae> scsibug: wrong ! you need to seed it :)
21:22:31 <jonaskoelker> scsibug: You mean RandomGen?
21:22:56 <scsibug> right
21:23:13 <Saizan> ?google site:hackage.haskell.org mersenne
21:23:26 <Saizan> ?bot
21:23:32 <lambdabot> Plugin `search' failed with: thread killed
21:23:32 <lambdabot> :)
21:23:50 <seafood_> mae: So, do I understand you correctly? You think HAppS is very useful and you'd prefer it most times?
21:24:02 <mae> random # generation is an IO action -- the same arguments will yield different rvals -- pure functions always return the same rval with a given argument, no matter how many times they are called
21:24:03 <scsibug> eww, nevermind.  It appears to just use the clock.
21:24:05 <gio123> ?Saizan
21:24:05 <lambdabot> Unknown command, try @list
21:24:30 <jonaskoelker> :O
21:24:42 <scsibug> jonaskoelker: do you need this for crypto purposes?
21:24:49 <Saizan> jonaskoelker: if you want a good RNG http://hackage.haskell.org/packages/archive/mersenne-random/0.1.3/doc/html/System-Random-Mersenne.html
21:24:49 <jonaskoelker> no
21:24:53 <Saizan> ops
21:24:55 <mae> seafood_: I thinks HAppS is compelling -- I have done anything useful with it yet because I am still in the haskell newbie stage to where I spend more time deciphering types than banging out code ..
21:25:01 <Saizan> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mersenne-random
21:25:10 <Saizan> the interface is in IO though
21:25:38 <mmorrow> oh crap, my laptop charger just destroyed itself (frayed wire, short circuit).
21:25:46 <mae> niice!
21:25:53 <mae> lithium ion battery?
21:25:57 * mmorrow tries to find somewhere to buy a charger at 23:30
21:25:57 <mae> is it under warranty?
21:25:59 <mae> did you take a picture?
21:26:02 <mmorrow> just the cord
21:26:05 <mmorrow> severed
21:26:17 <mae> ah ok, not nearly as exciting as exploding batteries / transformers
21:26:20 <mmorrow> right at the plug too
21:26:33 <mmorrow> so i can't really splice in a new one
21:26:37 <mae> don't you hate it when worldly side effects interrupt your hacking sessions?
21:26:38 <mmorrow> hmm, actually i can
21:26:46 * ksf just got that he doesn't grok funktors.
21:26:47 <mmorrow> mae: more than anything!!
21:26:58 <bd_> scsibug: http://darcs.haskell.org/packages/random/System/Random.hs the source; it's just based on time by default
21:27:02 <ksf> which sucks, 'cos I understand them.
21:27:06 <bd_> see mkStdRNG
21:27:15 <Saizan> funktors?
21:27:22 <ddarius> ksf: What don't you grok about them?
21:27:32 <mae> mmorrow: no pc?
21:28:35 <ksf> well, I don't have any transformations ready to mangle them in my imagination.
21:29:56 <scsibug> bd_: as I read that, I don't see where else it would get randomness besides the clock, am I missing something?
21:30:43 <mae> scsibug: i believe the clock is just used as a seed for the random "pure" function
21:30:59 <bd_> scsibug: sure. most OSes maintan an entropy pool for 'secure' random numbers - drawing data from things like HDD seek latency, keystroke timings, network events, etc.
21:31:19 <bd_> scsibug: some machines even have a hardware generator that produces truly unpredictable data by exploiting thermal noise
21:31:34 <bd_> haskell's System.Random makes use of none of this :)
21:31:38 <scsibug> right...but System.Random only uses the system clock for its seed
21:31:47 <scsibug> ok, I think we're on the same page then
21:32:08 <mae> scsibug: are you defending the secret which cannot be found out by anyone?
21:32:18 <mae> porn?
21:32:50 <scsibug> didn't linux remove the network device as an entropy source a while back, because it was vulnerable to too much outside influence?
21:33:18 <mmorrow> mae: nope :)
21:33:34 <mmorrow> ok, i just salvaged another cord off another charger. question:
21:34:16 <mmorrow> (this is only the /cord/.) my original one was rated 3A, the new one is rated to 7A
21:34:23 <mmorrow> this should make no diff, right?
21:34:56 <mmorrow> i can't think why it would
21:34:59 * mmorrow goes for it
21:35:01 <mae> nah
21:35:12 <mae> its probably not even drawing the full amount it is rated for
21:35:25 <mae> standard house plugs are only rated for 15A
21:35:30 <mmorrow> beautiful, no splosion
21:35:36 <mmorrow> disaster averted
21:35:38 <mmorrow> phew
21:36:34 <mae> unplug it before bed :)
21:36:35 <mae> just in case
21:36:42 <mmorrow> heh, good idea
21:36:47 <mae> wrap it in IO
21:37:34 <mae> holy mother of god GHC takes a long time to build
21:37:38 <mmorrow> unsafeGoToSleepAndForgetAboutHowYourChargerIsGonnaSplode
21:37:41 <mae> I feel like I'm having flashbacks to my gentoo days
21:38:22 <mae> http://funroll-loops.info/
21:38:38 <scsibug> I think building mozilla on a 68k machine was the longest compile i've endured
21:40:58 <mae> oh i dont know, I actually did a stage 1 bootstrap install of gentoo on a 266mhz / 256mb ram dell
21:41:02 <mae> pentium 2 i believe
21:41:05 <mae> It took days
21:41:13 <mae> I think xorg took a day by itself
21:42:50 <ddarius> It took me about a day to build GHC 5.4.3 (I think it was), but that was on a Pentium 200 w/ 64MB of RAM.
21:43:32 <mae> holy **** ghc was going on back then? I only stumbled upon haskell in the last 3 years
21:43:38 <ddarius> From what I hear (at least on some platforms), GHC builds much faster than it did; people with moderate hardware doing so in like 30 minutes.
21:43:50 <mae> I ... feel ... so .. weak..
21:43:55 <ddarius> mae: GHC dates back to before 1989
21:44:00 <mmorrow> my sister got her arm below the elbow bitten off by a jaguar, and it took use 2 weex to build her a new one. on a pentium5!
21:44:07 <mae> well, at least i'm older than ghc (1983)
21:44:41 <pumpkin> o.O
21:44:42 <scsibug> mae: read 'the history of haskell' paper sometime, it's fascinating.
21:45:02 <mmorrow> yeah, it's a good read
21:45:09 <lepassive> Okay what is the trick? Haskell is high level and super fast and elegant
21:46:11 <scsibug> A lot of different pieces of haskell came together in my mind after that.  It's a good tutorial for some language concepts, as far as giving you a framework for fitting them together (at least chronologically)
21:47:51 <mmorrow> lepassive: of adding 2 cups of sugar, they added 4 cups of non-suck, then added the sugar anyways!
21:47:58 <mmorrow> *instead of
21:49:14 <lepassive> mmorrow, Should be added to Humor page in the wiki :)
21:50:01 <mmorrow> :)
21:50:06 <lepassive> okay one more, is the recursion in haskell limited to some how LARGETS_RECS ?
21:51:02 <Saizan> you'll get a Stack Overflow if you end up using too much of stack
21:51:13 <mmorrow> lepassive: the fundamental execution model is completely different than (e.g.) C, so the only limit to recursion (assuming you're not recursing tail-recursively) is the amount of mem allocated for the stack
21:51:20 <mae> ouch, my vm crashed and burned
21:51:23 <Saizan> but since GHC performs TCO optimization good code will avoid that
21:51:28 <mae> maybe with 2gb instead of 1gb ghc will build now
21:51:31 <mmorrow> crash and burn!
21:51:41 * mmorrow cues the Top Gun soundtrack
21:52:22 <mmorrow> but if you do something like
21:52:29 <mmorrow> go !n = go (n+1)
21:52:34 <mmorrow> it'll run forever in constant mem
21:52:42 <mae> hmm
21:52:42 <Saizan> @wiki Stack overflow
21:52:43 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
21:53:15 <mae> tail recursive
21:54:30 <ddarius> I love Gentoo-user bashing pages.
21:55:00 <mmorrow> heh, i was laughing when i read that too
21:55:07 <jonaskoelker> ddarius: can I quote you in #gentoo? ;)
21:55:31 <mmorrow> WHAT R UR CFLAGS??!?
21:55:32 <ddarius> jonaskoelker: I can't stop you.
21:55:37 <mmorrow> ZOMG SO FAST
21:55:54 <jonaskoelker> -fOPTIMIZE-INSANELY!!!
21:56:00 <jonaskoelker> j/k wrt quoting
21:56:14 <mae> hey now
21:56:16 <mae> gentoo was the jam
21:56:26 <mae> : - )
21:56:33 <ddarius> "What is far more important is that you have the CODE, or rather more importantly, the HEADERS!"
21:56:55 <lepassive> how can I use lambdabot here ??
21:57:28 <mmorrow> > 42
21:57:29 <lambdabot>   42
21:57:44 <lepassive> prepend GT sign?
21:57:47 <mmorrow> > let f x = x : f (x+1) in f 0
21:57:48 <lepassive> > 1 + 2
21:57:49 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
21:57:50 <lambdabot>   3
21:57:53 <pumpkin> lepassive: and a space!
21:58:16 <lepassive> very nice this channel is awesome
21:58:34 <mmorrow> @pl \a b c d -> g (f a b c d)
21:58:35 <lambdabot> (((g .) .) .) . f
21:58:45 <mmorrow> @unpl (((g .) .) .) . f
21:58:45 <lambdabot> (\ h k n q -> g (f h k n q))
21:58:48 <Spewns> hi folks
21:58:56 <mmorrow> hei
21:59:17 <lepassive> hi
21:59:52 <ksf> % grep CFLAGS /etc/make.conf
21:59:52 <ksf> CFLAGS="-march=k8 -pipe -O2"
22:00:00 <ksf> zomg! a running system!
22:00:08 <pumpkin> > let 5 = 6 in 5
22:00:10 <lambdabot>   5
22:00:12 <pumpkin> lol
22:00:24 <pumpkin> fail
22:00:55 <lepassive> I really want to ask how does Haskell fits in large projects ?
22:01:08 <pumpkin> it can't work! I can't redfine 5
22:01:41 <ksf> obviously, quite well. both ghc and happs should be large enough to be examples.
22:02:40 <lepassive> what is happs ?
22:02:57 <lepassive> ksf is ghc written in Haskell ??
22:02:57 <ksf> http://happs.org/
22:03:09 <ksf> yes it is.
22:03:19 <lepassive> ksf, how come?
22:03:20 <mae> large projects
22:03:31 <mae> site:hackage.haskell.org
22:03:45 <ksf> spj got tired of being told he couldn't do it? dunno.
22:04:17 <mae> lol
22:04:17 <lepassive> how is ghc written in haskell?
22:04:26 <mae> its called bootstrapping
22:04:28 <pumpkin> same way gcc is written in c?
22:04:31 <ddarius> lepassive: The same way GCC is written in C
22:04:35 <BMeph> lepassive: Skillfully. ;)
22:04:39 <lepassive> self hosted compiler you mean ?
22:04:53 <mae> kind of like, machines with metal bequeath other machines made with metal, because originally a machine made the machine that makes metal machines
22:04:54 <lepassive> Okay the first version of GHC was written in what ?
22:05:13 <pumpkin> english
22:05:19 <rwbarton> There were haskell compilers before GHC :)
22:05:22 <Lemmih> SamB: Do you have an account on code.haskell.org?
22:05:26 <BMeph> pumpkin: Doubtful. :)
22:05:38 <ddarius> rwbarton: Yes, but it was written in Haskell too.
22:05:48 <jonaskoelker> pumpkin: do you have a compiler for that? ;)
22:05:53 <pumpkin> BMeph: gaelic? :P
22:05:56 <mae> wait, if haskell like compiled itself, won't it get mad programming libs disease?
22:05:57 <ddarius> GHC was originally bootstrapped by HBC which was bootstrapped by LML.
22:06:11 <BMeph> pumpkin: Swedish! ;p
22:06:21 <pumpkin> BMeph: aha!
22:06:28 <rwbarton> ddarius: And LML was written in ML I guess?
22:06:47 <mae> LML was hand coded in Bell Labs assembly code
22:06:52 <Lemmih> ?ask SamB Do you have an account on code.haskell.org?
22:06:53 <lambdabot> Consider it noted.
22:06:53 <mae> for a pdp-11
22:06:55 <lepassive> I wish I've never started that recursive question
22:07:14 <ksf> it was single-handedly entered into the eniac switchboard by chuck norris.
22:07:34 <mae> yeah -- chuck norris is badass
22:08:20 <mae> ksf: how long did HBC take to compile on the eniac LML implementation?
22:08:39 <ksf> about three gigabugs.
22:09:05 <mae> and -- I must ask the question -- what was used to bootstrap the solid state logic on the eniac architecture?
22:09:27 <ksf> they had to offshore it, flyswatting became to expensive.
22:09:47 <mae> I see.
22:09:51 <mae> you are wise.
22:10:08 <ddarius> ENIAC shouldn't have had any solid state logic.
22:10:19 <mae> oh?
22:10:21 <ksf> vodka lemon, three pencils, one of them broken, and the backsides of the waterloo investigation reports.
22:10:31 <mae> was it lazy?
22:11:24 <mae> oh how I love OT
22:11:37 <ksf> nope, it was quite clear after the first discussion that they wouldn't wait for a college block but strictly work on currently available paper.
22:11:53 <mae> hmm
22:12:00 <lepassive> How to declare a function in GHCI ?
22:12:11 <ksf> you don't, you do a let-binding.
22:12:12 <mae> < -- you've lost me oh curator of computer lore
22:12:25 <mmorrow> let foo = (*2)
22:12:34 <ksf> all ghci input is inside a do-block.
22:12:44 <mmorrow> let foo x y = (x + y, [x])
22:12:52 <mmorrow> a <- readFile "/etc/passwd"
22:12:54 <mmorrow> a
22:13:20 <ddarius> ENIAC was made before the transistor (barely).  It did use crystal diodes (according to wikipedia), but I'm not sure if I'd consider those "solid state"
22:13:22 <mmorrow> oh, you may want to turn off autoprinting of (a <- .... )
22:13:33 <mmorrow> i almost forgot that was the default
22:14:33 <mmorrow> :set :set -fglasgow-exts -O2 -
22:14:43 <mmorrow> oops didn't mean to print the -O2
22:14:53 <ksf> i thought it used tubes?
22:14:55 <mmorrow> actually, i pasted completely the wrong thing
22:14:57 <mmorrow> all together
22:15:04 <mmorrow> :set -fno-print-bind-result
22:15:09 <mae> hoorah editline now works in ghci!
22:15:52 <mae> am I the only one who avoids using -fglasglow-exts and handcrafts LANGUAGE pragmas thoughtfully at the top of my source files
22:16:05 <olahol> nope
22:16:31 <mae> I try to use as little as possibly needed
22:16:31 <mmorrow> i only LANGUAGE when -fglasgow-exts doesn't cover it because i'm lazy
22:16:36 <ksf> I'm using -flet-my-program-run
22:16:49 <mae> although I really like the new {...} pattern matching for records
22:16:53 <mmorrow> -f-yes-evarything-ooh-that-too
22:17:23 <mae> -ffuckoffmonomorphismmasochisticrestriction
22:17:32 <mmorrow> oh yes, that one too
22:17:41 <mae> I avoid that one too
22:17:43 <mae> maybe I'm anal.
22:18:08 <mmorrow> haskell' is dropping the monomorphism restriction
22:18:10 <lepassive> What IDE are you using ?
22:18:15 <mae> oh yeah?
22:18:15 <lucca> -O255 too?
22:18:23 <mmorrow> -O256
22:18:27 <mmorrow> come on now
22:18:32 <lucca> hehh
22:18:52 <lucca> nothing sounds more sinister than -malign-functions though
22:18:58 <mae> heh
22:19:23 <mae> son of a bitch
22:19:31 <mae> i recompiled with editline and it still does not work
22:19:31 <mmorrow> -its-not-a-tumah
22:19:49 <mmorrow> mae: do you actually have the editline libs installed?
22:19:52 <mae> yes
22:19:56 <mae> and the dev ones..
22:19:57 <mmorrow> the -dev one too
22:19:58 <mmorrow> heh
22:20:07 <mmorrow> did you make distclean??
22:21:22 <mae> it was from scratch :\\\\\\
22:21:28 <mae> libedit or libeditline
22:22:03 <mmorrow> odd. did you notice if ghc picked up the libs in the ./configure output?
22:22:11 <mae> let me check
22:22:31 <mmorrow> maybe you installed in /usr/local and it only looked in /usr or some nonsense
22:22:53 <mmorrow> or maybe set LD_LIBRARY_PATH?
22:22:57 <mae> configure:2853: checking whether ghc has editline package
22:22:58 <mae> configure:2864: result: no
22:23:04 <mmorrow> oh noes!
22:23:22 <mae> running distclean configure again
22:23:33 <mmorrow> oh noes!
22:23:35 <mae> let me shee here
22:23:36 <mmorrow> :)
22:23:39 <mae> damn another hour
22:23:53 <mmorrow> make -j10
22:24:03 <mmorrow> (or at least -j2)
22:24:11 <mmorrow> speeds it up noticeably
22:24:13 <mae> i have a dual core
22:24:15 <mae> hm
22:24:20 <mmorrow> so do i :)
22:24:23 <mmorrow> -j10!!
22:24:27 <mae> -j10
22:24:44 <mmorrow> heh
22:24:51 <mae> same thing
22:24:52 <mae> weird
22:24:58 <mae> maybe i have to tell configure to use it
22:25:00 <mmorrow> where did you put libedit?
22:25:04 <Saizan> mae: this is much simpler with ghci-haskeline
22:25:09 <mae> wherever ubuntu puts it
22:25:15 <mmorrow> oh, that is odd
22:25:33 <mmorrow> what does  ls /usr/lib/*edit* say?
22:25:33 <mae> Saizan: doesn't that produce a second binary?
22:26:02 <Saizan> mae: it produces a ghci-haskeline, with which you can just overwrite the standard one
22:26:09 <mmorrow> i have
22:26:11 <mmorrow> [m@ganon ~]$ ls /usr/lib/libedit*
22:26:11 <mmorrow> /usr/lib/libedit.so  /usr/lib/libedit.so.0  /usr/lib/libedit.so.0.0.26
22:26:31 <mae> http://hpaste.org/13701
22:27:07 <mae> hmm libedit not libeditline?
22:27:12 <mmorrow> yes
22:27:19 <mae> son of a bastard
22:27:20 <mmorrow> i don't know what /usr/lib/libedit.so.2.9 is either
22:27:48 <mmorrow> maybe a libeditline compatibility package or something for libedit
22:27:55 <mae> why did they move from readline
22:27:57 <mae> so dumb
22:28:02 <mae> i can't do my cool vi mode now
22:28:15 <mmorrow> because certain corporate users wanted a non-gpl ghci
22:28:15 <Saizan> because of GPL
22:28:33 <mmorrow> god forbid they hire someone to hack their own version of it
22:28:45 <Saizan> libedit has .editrc, i think
22:28:52 <mmorrow> rather than bring this editline scourge on the entire community
22:29:04 <mmorrow> :)
22:30:30 <mae> which corp users
22:30:38 <mae> nm
22:30:40 <mae> microsoft
22:30:45 <mmorrow> i'm not sure which ones
22:31:00 <rwbarton> has the libeditline/emacs interaction been fixed yet?
22:31:57 * mmorrow wants to answer "probably not" so badly, but refrains from ranting.
22:33:00 <mae> weird
22:33:05 <mae> i still get same message from configure script
22:33:11 <mae> but doesn't refer to readline
22:34:10 <mauke> http://mauke.ath.cx/stuff/haskell/ghc-6.10.1-readline.diff
22:35:11 <mmorrow> mauke++
22:35:21 <mmorrow> Saizan++ -- he also did a similar thing
22:36:01 <mmorrow> i mean, wtf. that diff is probably 40 lines. that's all whoever wanted a non-readline ghci had to do to get one.
22:36:46 <rwbarton> Actually, the diff is 6 lines :)
22:37:04 <mmorrow> grrrr!!!!!!!
22:37:15 <mae> see you all later
22:37:23 <mmorrow> see ya
22:38:40 <mae> j10 hell yeah
22:38:41 <mae> rice!
22:38:48 <mae> -funrollmydualcore
22:39:28 <mmorrow> heh, both cores'll be pegged at 100% for the next 20-25 minutes :)
22:39:55 <mae> yeah i'm hurting my puter good
22:40:16 <Saizan> rwbarton: there's a workaround in the thread
22:44:20 <mae> i miss my, i miss my, i miss my lib readline (lyrics sung to "i want my mtv")
22:45:29 <mae> wb
22:45:38 <mae> how goes the multimaster partitioning / replication
22:51:33 * Lemmih wonders if mae is talking to him.
22:52:11 <Saizan> i think so
22:52:28 <mae> No, I was talking to the other HAppS developer.
22:52:32 <mae> *snicker*
22:52:33 <mae> : )
22:53:58 <cadabra> I don't know how to use Text.Regex.PCRE. I can't makeRegex, it claims that there's no instance of (RegexMaker ... [Char]) and (RegexLike ... [Char]). But I've imported Text.Regex.PCRE.String.
22:54:11 <Lemmih> mae: Things have stalled. I'm not employed to work on HAppS anymore and my free time goes to LHC.
22:54:29 <Olathe> @src PCRE
22:54:30 <lambdabot> Source not found. Do you think like you type?
22:55:41 <cadabra> @src regex-pcre
22:55:41 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
22:56:09 <mae> Lemmih: I see, did you keep notes anywhere for a would-be uptaker
22:56:11 <Lemmih> mae: Perhaps development will start again if commercial interest picks up.
22:56:13 <cadabra> Well, I have the source for 0.94.1, and I can see that the instances are there.
22:57:13 <Olathe> cadabra: See if 'compile compBlank execBlank "zomg"' does anything.
22:57:16 <cadabra> And in ghci, :i RegexMaker shows the instance for String.
22:57:53 <mae> Lemmih: I see, well, it just might happen, you never know! :)
22:58:07 <cadabra> Olathe: no result, but it doesn't fail
22:58:22 <Olathe> What is its type ?
22:58:40 <Olathe> > show.getType $ (5::Int)
22:58:41 <lambdabot>   Not in scope: `getType'
22:58:51 <cadabra> IO (Either (MatchOffset, String) Regex)
22:59:09 <cadabra> a <- compile ...
22:59:22 <Lemmih> mae: All the specs are private to HAppS LLC, unfortunately. But I'd love to discuss the problem if you're interested.
22:59:27 <Olathe> cadabra: Alright.
22:59:48 <cadabra> a seems to be a Regex
23:00:35 <Olathe> let (Right regex) = compile compBlank execBlank "zomg"
23:00:49 <Olathe> Then, you should be able to use regex in execute.
23:01:23 <cadabra> Couldn't match expected type `Either t t1' -- against inferred type `IO (Either (MatchOffset, String) Regex)'
23:01:32 <Olathe> Ahh, either.
23:01:36 <Olathe> I mean, IO.
23:01:47 <mae> Lemmih: I would love to discuss the problem.
23:02:09 <Olathe> compile compBlank execBlank "zomg" >>= \(Right regex) -> regex
23:02:18 <Olathe> That should give you IO Regex as a type.
23:02:41 <jesusabdullah> HOLY CHRIST there are a lot of you!
23:02:52 <Zao> Yes, my child.
23:03:00 <Olathe> Too many holy christs, if you ask me.
23:03:03 <jesusabdullah> Whoa
23:03:05 <cadabra> Couldn't match expected type `IO b' against inferred type `Regex' ;x
23:03:10 <jesusabdullah> xen.
23:03:12 <jesusabdullah> er, zen.
23:03:14 <jesusabdullah> <_>
23:03:25 <Olathe> cadabra: Hmmm...
23:03:36 <int-e> @users
23:03:37 <lambdabot> Maximum users seen in #haskell: 668, currently: 587 (87.9%), active: 13 (2.2%)
23:03:47 <jesusabdullah> damn son
23:03:56 <mmorrow> > let f x = x+1 in f (print 42)
23:03:58 <lambdabot>       No instance for (Num (IO ()))
23:03:58 <lambdabot>        arising from a use of `f' at <inte...
23:04:07 <cadabra> Why does makeRegex fail?
23:04:16 <mmorrow> > let f x = [x, Just ()] in f (print 42)
23:04:17 <lambdabot>   Couldn't match expected type `Maybe ()'
23:04:24 <mmorrow> grr
23:04:33 <anu> i would like to understand recursion in C++ , they suggest that haskell is easier to understand it . what is haskell then ?
23:04:33 <mmorrow> > let f x = x >> print 42 in f 42
23:04:34 <lambdabot>       No instance for (Num (IO a))
23:04:34 <lambdabot>        arising from the literal `42' at <i...
23:04:47 <mmorrow> > let f x = x >> print () in f []
23:04:48 <lambdabot>   Couldn't match expected type `IO a' against inferred type `[a1]'
23:04:51 <mmorrow> yes!
23:05:00 <jesusabdullah> Whoa, that's kinda cool
23:05:02 <int-e> cadabra: show code. but it appears that you're mixing IO actions and values
23:05:04 * jesusabdullah is easily impressed
23:05:09 <int-e> @paste
23:05:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:05:16 <Olathe> cadabra: I don't think makeRegex is part of TextRegex.PCRE.
23:05:17 <jesusabdullah> > 1+1
23:05:18 <lambdabot>   2
23:05:21 <jesusabdullah> Sweet.
23:05:29 <jesusabdullah> Now I just have to, umm
23:05:29 <mmorrow> > [0..]
23:05:31 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
23:05:32 <jesusabdullah> ...learn haskell.
23:05:41 <SubStack> for great good
23:05:45 <jesusabdullah> Right!
23:05:47 <cadabra> int-e: there isn't really any code, I'm just trying to get a simple Text.Regex.PCRE example going.
23:05:48 <Olathe> > ("Learn "++) "Haskell !"
23:05:50 <lambdabot>   "Learn Haskell !"
23:05:51 <mmorrow> > let fib m n = m : fib n (m+n) in fix 0 1
23:05:52 <lambdabot>       No instance for (Num ((t -> a) -> t -> a))
23:05:52 <lambdabot>        arising from the lite...
23:05:59 <mmorrow> > let fib m n = m : fib n (m+n) in fib 0 1
23:06:01 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:06:02 <jesusabdullah> Super Four Bar Explorer won't know what hit it!
23:06:04 <Saizan> @where LYAH
23:06:04 <lambdabot> www.learnyouahaskell.com
23:06:12 <anu> :)
23:06:14 <cadabra> Olathe: there's an instance of RegexMaker in Text/Regex/PCRE/String.hs that defines makeRegex
23:06:14 <jesusabdullah> I've had lyah open for a month XD
23:06:30 <jesusabdullah> I was gonna use it for a project, but, y'know, deadlines
23:06:35 <jesusabdullah> I ended up using python :(
23:06:43 <mmorrow> main = putStr . unlines . map youFunc . lines =<< getContents
23:06:48 <jesusabdullah> and it was sad too, because the whole thing was really math-ish
23:06:50 <mmorrow> yourFunc :: String -> String
23:07:12 <cadabra> How do you guys use regex? Do you?
23:07:14 <mmorrow> main = print . length . lines =<< getContents
23:07:14 <Olathe> Ahh.
23:07:22 <Olathe> @index (=~)
23:07:23 <lambdabot> bzzt
23:07:30 <BMeph> Haskell is like what C++ could have been...if they stopped trying to build up the prototype into a production product. ;)
23:07:32 <Olathe> We apparently use the bzzt library.
23:07:41 <SubStack> > "doom" =~ "om$" :: Bool
23:07:43 <lambdabot>   True
23:07:54 <Olathe> > "zomg !" =~ "zomg" :: Bool
23:07:56 <lambdabot>   True
23:07:58 <jesusabdullah> I think I could learn to like this place. XD
23:08:00 <Olathe> > "zomg !" =~ "zomg" :: String
23:08:02 <lambdabot>   "zomg"
23:08:08 <Olathe> > "zomg !" =~ "z.mg" :: String
23:08:09 <lambdabot>   "zomg"
23:08:10 <mmorrow> > "doom" =~ "om$" :: String
23:08:11 <lambdabot>   "om"
23:08:17 <Olathe> > "zomg !" =~ "z.mg" :: [String]
23:08:19 <lambdabot>   ["zomg"]
23:08:24 <Olathe> > "zomg zamg !" =~ "z.mg" :: [String]
23:08:25 <lambdabot>   ["zomg","zamg"]
23:08:27 <cadabra> What's the import for =~?
23:08:30 <mmorrow> > "42" =~ "4om$" :: Int
23:08:31 <lambdabot>   0
23:08:35 <Olathe> @type (=~)
23:08:37 <lambdabot> forall source1 source target. (Text.Regex.Base.RegexLike.RegexContext Regex source1 target, Text.Regex.Base.RegexLike.RegexMaker Regex CompOption ExecOption source) => source1 -> source -> target
23:08:37 <mmorrow> > "42" =~ "42om$" :: Int
23:08:39 <lambdabot>   0
23:08:45 <mmorrow> > "42" =~ "42" :: Int
23:08:46 <lambdabot>   1
23:08:49 <Olathe> Text.Regex.Base.
23:09:08 <rwbarton> > "4242424" =~ "42" :: Int
23:09:08 <jesusabdullah> What is =~, anyway?
23:09:10 <lambdabot>   3
23:09:17 <jesusabdullah> Oho
23:09:19 <SubStack> like in perl
23:09:22 <Olathe> jesusabdullah: It's something to find patterns in text using regexes.
23:09:26 <jesusabdullah> Right
23:09:30 <jesusabdullah> Yeah, I kinda see it now
23:09:31 <mmorrow> > return 42 :: [Int]
23:09:33 <lambdabot>   [42]
23:09:35 <jesusabdullah> I never did get too deep into regexps
23:09:35 <mmorrow> > return 42 :: Maybe Double
23:09:37 <lambdabot>   Just 42.0
23:09:40 <cadabra> Olathe: import Text.Regex.Base in ghci and =~ doesn't work.
23:09:40 <mmorrow> > return 42 :: IO Float
23:09:42 <lambdabot>   * Exception: "<IO Float>"
23:09:50 <jesusabdullah> I played with them in octave, of all places :6
23:09:51 <Olathe> > return 42 :: [Maybe (Maybe Int)]
23:09:52 <lambdabot>       No instance for (Num (Maybe (Maybe Int)))
23:09:52 <lambdabot>        arising from the liter...
23:09:54 <rwbarton> @hoogle (=~)
23:09:55 <lambdabot> No results found
23:09:58 <jesusabdullah> (they're terrible in octave, btw)
23:10:01 <Olathe> > return.return.return $ 42 :: [Maybe (Maybe Int)]
23:10:03 <lambdabot>   [Just (Just 42)]
23:10:33 <SubStack> cadabra: try Text.Regex.Posix
23:10:35 <cadabra> "123" =~ "1\\d3" :: Bool
23:10:43 <SubStack> or a fancier engine if you like
23:10:44 <cadabra> > "123" =~ "1\\d3" :: Bool
23:10:44 <mmorrow> > map join . (return . return . return) $ 42 :: [Maybe (Maybe Int)]
23:10:46 <lambdabot>       No instance for (Num (Maybe Int))
23:10:46 <lambdabot>        arising from the literal `42' ...
23:10:46 <lambdabot>   False
23:11:01 <mmorrow> > map join ((return . return . return) 42 :: [Maybe (Maybe Int)])
23:11:02 <lambdabot>   [Just 42]
23:11:12 <cadabra> > "123" =~ "1[[:digit:]]3" :: Bool
23:11:14 <lambdabot>   True
23:11:25 <cadabra> Posix regexp, sigh
23:11:32 <Olathe> > "123" =~ "\\d" :: Bool
23:11:34 <lambdabot>   False
23:11:37 <Olathe> Lies.
23:11:47 <Olathe> > say "\\"
23:11:49 <lambdabot>   \
23:12:05 <jesusabdullah> > say "douglas."
23:12:07 <lambdabot>   douglas.
23:12:09 <Olathe> > "123" =~ "\\\\d" :: Bool
23:12:10 <lambdabot>   False
23:12:10 * jesusabdullah claps
23:12:18 * jesusabdullah is still easily amused.
23:12:19 <cadabra> Posix doesn't match \\d
23:12:46 <jesusabdullah> What else can lambdabot do?
23:12:50 <SubStack> \\d is pretty cringe-worthy >_<
23:12:54 <jesusabdullah> There's a web page on this isn't there?
23:12:57 <rwbarton> @slap jesusabdullah
23:12:58 * lambdabot would never hurt jesusabdullah!
23:13:04 <jesusabdullah> YEAH rwbarton!
23:13:09 <jesusabdullah> Me n' lambdabot go WAY back
23:13:21 <Olathe> @where rwh
23:13:22 <lambdabot> is http://www.realworldhaskell.org/blog/
23:13:26 <Olathe> Bah.
23:13:31 <Olathe> jesusabdullah: http://book.realworldhaskell.org/read/
23:13:31 * SubStack googles that for jesusabdullah: http://www.haskell.org/haskellwiki/Lambdabot
23:13:43 <Olathe> Ahh, yes.
23:13:46 <jesusabdullah> THANKS SUBSTACK
23:13:57 <SubStack> I actually have the source on my disk for some reason
23:14:11 <SubStack> I was going to look at the sandboxing or some such
23:14:26 <jesusabdullah> Clearly, lambdabot and serfy are gonna make babies.
23:14:40 <rwbarton> Is there sandboxing?  I thought it just didn't have anything exported that would let you do IO
23:14:52 <lepassive> is there a simple Monads tutorial ?
23:15:04 <SubStack> I never got around to looking.
23:15:11 <jesusabdullah> I looked around once
23:15:24 <jesusabdullah> My impression is that there's a pretty big schism on how to present them
23:15:37 <Olathe> lepassive: http://book.realworldhaskell.org/read/monads.html
23:15:41 <rwbarton> I don't think so because every so often someone discovers a new hole like unsafeSTToIO :)
23:15:52 <Raynes> lepassive: I've heard good things about http://ertes.de/articles/monads.html
23:15:53 <jmendel> Anyone here into proofs by induction?
23:15:55 <jesusabdullah> as in, do you go with rigour, or understanding?
23:15:59 <rwbarton> Or whatever it's called
23:16:07 <jesusabdullah> inductive proofs?
23:16:10 <lepassive> Okay thanks alot guys
23:16:11 <cadabra> All the different engines are supposed to provide the same API.
23:16:47 <jesusabdullah> Where you start with a base case and prove that if case k is true then so's case k+1 and so all cases from the base case on up are true, proving something?
23:16:55 <jesusabdullah> <_>
23:17:04 <jesusabdullah> ...I saw a few of them in math class.
23:17:07 <jesusabdullah> Sorcery, I tell you
23:17:10 <cadabra> Apparently, =~ works from PCRE.
23:17:12 <jesusabdullah> but slick
23:17:21 <cadabra> But not any of the other stuff.
23:17:30 <harblcat_> so xmonad is interesting
23:17:38 <int80_h> jmendel: yeah they're the basis for recursion
23:17:41 <jesusabdullah> I agree.
23:17:44 <cadabra> Then how can I pass =~ options? Is it multiline?
23:17:44 <jesusabdullah> Installed it this morning
23:17:45 <jmendel> jesusabdullah: yep
23:18:04 <jesusabdullah> I need more layouts and tweaks, but I'm really enjoying it so far (xmonad, I mean)
23:18:09 <int80_h> I didn't really understand recursion until we covered induction in math class
23:18:24 <jmendel> i was wondering, working on some hw, you can use induction to prove n^3 - n = 0 mod 6
23:18:27 <jesusabdullah> huh
23:18:31 <jesusabdullah> For me it was kind of the other way
23:18:50 <jesusabdullah> I saw induction and I was like, hey, this is kinda like proofs by recursion
23:18:52 <jmendel> not haskell at all, but i figured there might be a math guy up in here
23:18:56 <int-e> hml: try #math
23:19:13 <jmendel> i should.
23:19:16 <milton13> can haskell be compiled for microcontrollers?
23:19:29 <milton13> lol
23:19:44 <jesusabdullah> There's only one way to find out...
23:19:49 <jesusabdullah> ...that might be a lie.
23:20:00 <mmorrow> , fmap (\x->x^3-x) [0..]
23:20:04 <lunabot>  [0,0,6,24,60,120,210,336,504,720,990,1320,1716,2184,2730,3360,4080,4896,5...
23:20:15 <Olathe> > map (\n -> mod (n^3 - n) 6) [0..5]
23:20:16 <lambdabot>   [0,0,0,0,0,0]
23:20:17 <mmorrow> , fmap (\x->(x^3-x)`mod`6) [0..]
23:20:18 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
23:20:35 <Olathe> > and $ map (\n -> mod (n^3 - n) 6 == 0) [0..5]
23:20:36 <lambdabot>   True
23:21:20 <jesusabdullah> What's lunabot?
23:21:30 <jesusabdullah> I tried google this time, shut up :'(
23:21:38 <Olathe> It lets us control the moon remotely.
23:21:40 <mmorrow> a bot like lambdabot, but with some different things it can do
23:21:52 <jesusabdullah> lunabot: Do you have a website too?
23:21:53 <mmorrow> yes, mooncontrol is of crucial importance to lunabot
23:22:07 <mmorrow> does lambdabot have a website?
23:22:09 <int80_h> can we chat with the mooninites?
23:22:15 <jesusabdullah> http://www.haskell.org/haskellwiki/Lambdabot
23:22:18 <jesusabdullah> ^__^
23:22:30 <jesusabdullah> I actually stumbled across it before
23:22:31 <int80_h> because that would be cool
23:22:36 <mmorrow> int80_h: heh, great book (if i think that is a ref to what i think it's a ref to)
23:22:55 <mmorrow> jesusabdullah: it has a code repo, but the bot part isn't even in that
23:22:56 <int80_h> mmorrow: It's a reference to Aqua Teen Hunger Force
23:22:58 <jesusabdullah> "I'm flipping you off AS HARD AS I CAN"
23:23:09 <mmorrow> int80_h: heh, i'm way off
23:23:18 <jesusabdullah> Huh
23:23:20 <mmorrow> (i can't even remember the book that's from actually)
23:23:42 <int80_h> Aqua Teen Hunger Force, the novelization?
23:23:49 <mmorrow> perchance
23:24:57 <int80_h> okay seriously, I'm having yet another type problem. But this time I'm not sure how to chase it down. I'm using where.
23:25:08 <int80_h> I'll post it to hpaste
23:25:09 <Olathe> Where are you using where ?
23:25:23 <int80_h> exercise 3, page 69
23:25:33 <Olathe> What's that exercise about ?
23:25:45 <int80_h> I tried breaking things down in ghci, but it wasn't straightforward
23:26:05 <mmorrow> @. elite nixon
23:26:05 <lambdabot> 4MerICANs aD/\/\Ir3 4 peoP13 w|-|O cAn ScR4+(H 4 d3Sert AND pR0dUCE A GaRd3N. THe isRAelIs HAV3 sho\/\/n qUalI+IEs thaT a/\/\3ric4N5 idENTIFy \/\/i+H: 9Ut5, P4TRIO7ism, IdeALI$M, A pAsSI0N 4
23:26:05 <lambdabot> phR3eDoM. I ha\/E zeeN it. I xnOW. I 8eLIe\/3 T|-|At.
23:26:21 <rwbarton> I'm about to install ghc 6.10.1, any suggestions?  I applied mauke's readline patch
23:26:23 <int80_h> Write a function that computes the mean of a list. fromIntegral is what's giving me the type problem
23:26:28 <mmorrow> @remember nixon I ha\/E zeeN it. I xnOW. I 8eLIe\/3 T|-|At.
23:26:29 <lambdabot> I will never forget.
23:26:35 <Olathe> rwbarton: Ahh.
23:26:40 <Olathe> Bah.
23:26:45 <Olathe> This is confusing.
23:26:54 <Olathe> int80_h: Ahh.
23:27:00 <mmorrow> @vixen This is confusing.
23:27:01 <lambdabot> i confuse myself sometimes
23:27:19 <rwbarton> @. vixen vixen This is confusing.
23:27:19 <lambdabot> i hope i don't confuse you
23:27:36 <int80_h> Olathe: I'll post my code. What I really want is debugging techniques
23:28:10 <mmorrow> @. vixen . vixen vixen
23:28:10 <lambdabot> bad is better than nice ;)
23:28:26 <Olathe> @@ @vixen @nixon
23:28:27 <lambdabot>  I define fun
23:28:29 <mmorrow> vixen is crazy. what's it using internally?
23:28:42 <Olathe> @vixen What do you use internally ?
23:28:42 <lambdabot> i do occassionally, i guess
23:29:01 <rwbarton> @vixen @src vixen
23:29:02 <lambdabot> we all have a little vixen in us
23:29:21 <Olathe> @@ @vixen @src omg
23:29:21 <lambdabot>  you're turning me on :)
23:29:22 <mmorrow> @vixen one time i completely the database, and no one even noticed!
23:29:22 <lambdabot> oh, i'm not either
23:29:45 <mmorrow> @src omg
23:29:45 <lambdabot> Source not found. Maybe you made a typo?
23:30:06 <Olathe> > ("@@ "++) $ cycle "@vixen "
23:30:07 <lambdabot>   "@@ @vixen @vixen @vixen @vixen @vixen @vixen @vixen @vixen @vixen @vixen @...
23:30:09 * mmorrow will just have to look at teh codez
23:30:16 <Olathe> > @@ @vixen @vixen @vixen @vixen @vixen @vixen @vixen @vixen @vixen @vixen
23:30:17 <lambdabot>   <no location info>: parse error on input `@@'
23:30:21 <Olathe> @@ @vixen @vixen @vixen @vixen @vixen @vixen @vixen @vixen @vixen @vixen
23:30:22 <lambdabot>  really!?
23:30:28 <Olathe> Yes.
23:31:03 <rwbarton> @oleg
23:31:03 <Saizan> @help vixen
23:31:05 <lambdabot>  Defined.
23:31:05 <lambdabot> vixen <phrase>. Sergeant Curry's lonely hearts club
23:31:29 <Olathe> @@ @show (@run 1 + 2) (@run 3 + 4)
23:31:31 <lambdabot>  "  3\n   7\n"
23:31:54 <Olathe> @@ is the best
23:31:54 <lambdabot>  is the best
23:32:34 <Olathe> @@ (@run say "@run 1 + 1")
23:32:35 <lambdabot>   @run 1 + 1
23:33:44 <mmorrow> @vixen do you fear robots?
23:33:44 <lambdabot> why does everyone ask i'f on a bot?
23:33:47 <mmorrow> @vixen do you fear robots?
23:33:47 <lambdabot> why does everyone ask i'f on a bot?
23:34:18 <lucca> > chr 1114111
23:34:19 <mmorrow> @vixen how sexy?
23:34:20 <lambdabot>   '\1114111'
23:34:20 <lambdabot> i dunno how so, it's just so
23:34:26 <mmorrow> hmm
23:34:58 <mmorrow> it's just a Tree or regexes and responses
23:35:02 <mmorrow> s/or/of/
23:35:24 <Olathe> @vixen how zgronhou?
23:35:25 <lambdabot> however you want
23:35:29 <Olathe> @vixen how zgronhou?
23:35:29 <lambdabot> however you want
23:35:32 <Olathe> @vixen how zgronhou?
23:35:32 <lambdabot> however you want
23:35:33 <rwbarton>  @. vixen ghc never produces any interesting output
23:35:34 <Olathe> Hmm...
23:35:36 <lepassive> Raynes, That Mondas tutorial is GREAT!
23:35:52 <Olathe> @vixen how zgronhov?
23:35:52 <lambdabot> how? it depends...
23:36:01 <Raynes> I saw people talking about it on the Mailing list.
23:36:12 <Raynes> I happen to bookmark it, thought it would come in handy.
23:36:17 <mmorrow> that'd be cool if someone hacked her to be a <arnold>learning computer</arnold>
23:36:22 <Raynes> I guess it did :p
23:36:29 <Saizan> which one?
23:36:40 <rwbarton> oh no, not megahal
23:36:44 <lepassive> Raynes, yes, very. Thanks
23:36:53 <Raynes> No problem.
23:37:02 <mmorrow> rwbarton: preferably a liquid metal megahal
23:38:11 <rwbarton> hmm mauke's patch isn't working for me
23:38:21 <rwbarton> there's no readline directory in libraries/
23:38:48 <Saizan> i think you can just untar the readline package there
23:38:52 <Saizan> ?hackage readline
23:38:52 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/readline
23:38:55 <rwbarton> yeah
23:39:53 <rwbarton> Well, it's crunching away again :)
23:41:00 <rwbarton> I suppose not distributing the readline bindings was kind of the point.
23:42:05 <Saizan> do we have a script that takes hlint suggestions and applies them?
23:43:47 <cjs> @seen dons
23:43:47 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 6h 16m 7s ago.
23:43:51 <rwbarton> mmorrow: where are your ghc haddocks?  I want to find out about this function I just saw a warning about "notHappyAtAll"
23:43:52 <cjs> @seen bos
23:43:53 <lambdabot> I saw bos leaving #haskell and #ghc 38m 54s ago, and .
23:44:01 <cjs> Darn. I'm just in the wrong time zone.
23:44:55 <Olathe> Oh, return.
23:45:45 <Saizan> "Composable transformers are composable because we can compose them into new composable transformers." <-- is that a pun?:D
23:46:31 <Olathe> It's a tautology, I think.
23:46:53 <int80_h> hmm, I think I may have figured things out...I'll post if I'm wrong
23:46:55 <Saizan> composable cat is composable.
23:47:43 <baaba> it specifies that composition is "a -> a -> a" and not "a -> a -> b" where a = "composable transformer"
23:47:43 <Olathe> Reactive cat
23:47:46 <Olathe> REACTS !
23:50:39 <Saizan> i was mostly amused by the so many repetitions of "composable" in the same sentence
23:51:37 <mmorrow> rwbarton: ooh, i just built freshy-fresh ones, complete with src links and all. also, there a ghc.txt hoogle file :)
23:51:53 <mmorrow> http://moonpatio.com/docs/ghc/
23:52:05 <mmorrow> http://moonpatio.com/docs/ghc/ghc.txt
23:53:04 <rwbarton> Hmm, I guess maybe this value isn't exported
23:53:19 <mmorrow> you can view source.. :)
23:53:33 <mmorrow> ohh, is that from Parser?
23:53:45 <mmorrow> so the generated-by-happy code?
23:53:47 <rwbarton> Yeah
23:53:54 <rwbarton> notHappyAtAll = error "Internal Happy error\n"
23:53:56 <mmorrow> hmm, i wonder if that's there..
23:54:30 <mmorrow> nice
23:54:32 <mmorrow> ooh, sucky
23:54:43 <mmorrow> haha, "notHappyAtAll"
23:54:53 <mmorrow> i just actually read that
23:56:13 <mmorrow> the ghc.txt hoogle file is 19,000+ lines
23:59:00 <rwbarton> So, now I have to cabal install everything again, right?
