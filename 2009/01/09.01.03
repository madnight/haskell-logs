00:00:08 <ddarius> rwbarton: You are close enough to correct.  Given two adjunctions over the same category a natural transformation F_1 -> F_2 uniquely determines a natural transformation G_2 -> G_1 that is conjugate.
00:00:38 <rwbarton> ddarius: Right, that's what I said. :)
00:00:38 <mm_freak_> @pl \(f,x) -> f x
00:00:39 <lambdabot> ap fst snd
00:00:47 <Peaker> http://haskell.org/haskellwiki/Image:Nick-activity.png  can probably be updated to reflect 2008 in full
00:00:57 <rwbarton> ddarius: BTW it seems there should be very few monads which are right adjoints
00:01:55 <dmwit> Even better: http://paste2.org/p/123902
00:01:57 <mm_freak_> > uncurry ($) $ (sin, 3)
00:01:59 <lambdabot>   0.1411200080598672
00:02:08 <ManateeLazyCat> dmwit: Thanks you, your code is more simple.
00:02:29 <ManateeLazyCat> dmwit: Can use *unless* in Haskell?
00:02:34 <dmwit> Yes.
00:02:35 <ddarius> rwbarton: And that gives a nicer proof than I had.  Given an adjunction F -| U where F is a comonad, we have adjunctions Id -| Id and F^2 -| U^2 and the counit and comultiplication of the comonad F should induces conjugate transformations for U giving rise to a monad (just need to check the equations and spell out the details)
00:02:36 <rwbarton> ddarius: because we have "liftM2 (,)" : TX x TY -> T(XxY) but also the natural map T(XxY) -> TX x TY is an isomorphism...
00:02:42 <dmwit> ?index unless
00:02:43 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
00:02:47 <dmwit> ?index when
00:02:47 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
00:02:51 <rwbarton> ddarius: Right
00:03:31 <rwbarton> ddarius: Do you have any examples besides the identity?
00:03:57 <rwbarton> ddarius: Ah, Reader a
00:04:00 <ddarius> Of course.
00:04:11 <ManateeLazyCat> dmwit: Why this "unless (uri =~ "^https?")" is correct? I use "=~" in ghci need ":: Bool", hasekll know need "Boo" type when use in *unless* sentence?
00:04:21 <ddarius> Yes, that one.  The adjunction underlying state has a comonad as a left adjoint and a monad for a right adjoint.
00:04:27 <rwbarton> Right
00:04:27 <dmwit> ManateeLazyCat: Yes, type inference helps here.
00:04:42 <dmwit> ManateeLazyCat: The more you use a value, the more its type is known.
00:04:43 <ManateeLazyCat> dmwit: Wow, wonderful.
00:04:45 <dmwit> ManateeLazyCat: Because:
00:04:49 <dmwit> :t unless
00:04:51 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
00:04:55 <ddarius> In the case the "state" is a monoid, the left adjoint is also a monad and the right a comonad.
00:05:01 <dmwit> ManateeLazyCat: The first argument to "unless" *must* be Bool.
00:05:15 <dmwit> ManateeLazyCat: So it infers that (uri =~ "^https?") has type Bool.
00:05:26 <dmwit> ManateeLazyCat: In ghci, you don't have the "unless" clue.
00:05:34 <dmwit> ManateeLazyCat: So you have to give a clue yourself. =)
00:06:09 <ManateeLazyCat> dmwit: So if unspecified type in "unless" sentence, ghci will inference it as "Bool"?
00:06:26 <dmwit> yes
00:06:39 <ManateeLazyCat> dmwit: So smart.
00:06:53 <rwbarton> ddarius: Right, I guess the argument I gave didn't care which was the left and right adjoint.
00:07:12 <dmwit> ManateeLazyCat: It does this inference everywhere it can.
00:07:26 <dmwit> ManateeLazyCat: (Not just with "unless", but with other things, too.)
00:07:27 <rwbarton> ddarius: I'm less surprised that there are interesting monads that are left adjoints than right adjoints.
00:08:08 <ddarius> rwbarton: Of course not.  The free ones are algebraic and thus monadic.
00:10:12 <ManateeLazyCat> dmwit: So we don't need write ":: *Type*" in source code if ghci can inference it, and we need type ":: *Type*" if have many *Type* possible.
00:10:24 <dmwit> ManateeLazyCat: exactly
00:10:47 <ManateeLazyCat> dmwit: Thank you very much, i study many. I'm very happy ;)
00:11:51 * ManateeLazyCat pasted "paste2.el" at http://paste2.org/p/123903
00:12:20 <ManateeLazyCat> dmwit: I paste my extension paste2.el at http://paste2.org/p/123903 , if you use emacs, you can paste thing to paste2.org on the fly in Emacs.
00:12:31 * ddarius just stumbled upon a very new CT intro.
00:12:40 <ManateeLazyCat> dmwit: paste2.el is a interface for paste2.org in Emacs.
00:12:41 <rwbarton> Oh?
00:12:51 <earthy> ddarius: is it any good?
00:12:57 <ddarius> http://www.pps.jussieu.fr/~curien/categories-pl.ps
00:13:05 <ddarius> earthy: I just saw the link now.  I have no idea.
00:13:10 <dmwit> ManateeLazyCat: DIE, INFIDEL!  VIM FOREVER! ;-)
00:13:20 <ddarius> The title: "Category theory: a programming-language oriented introduction"
00:13:28 * earthy laughs
00:13:32 <ManateeLazyCat> dmwit: Nevermind, just share. ;)
00:13:34 <ddarius> It's a 2.5MB ps.
00:13:34 <bohdan> in ghci, can I see the stack trace of an exception?
00:13:37 * earthy actually prefers the word editor for some tasks. ;)
00:14:09 <ManateeLazyCat> dmwit: paste2.el will have someone paste thing to paste2.org on the fly in Emacs.
00:14:11 <ddarius> The date is 19 Oct 2008
00:14:19 <dmwit> earthy: Sounds like the start of a good troll.  Work on it a few more years and you might get there. =)
00:14:47 <earthy> yah, well, vim forever
00:15:14 <earthy> but that also has something to do with Bram Moolenaar being a much more likeable guy than Richard M. Stallman
00:16:05 <earthy> ddarius: looks interesting
00:16:37 <ManateeLazyCat> Guys, i don't want drop into "editor war", just paste my code, explan my point -- I like Emacs. Choose youself like. :)
00:16:46 <bohdan> earthy, what about Bill Joy? :)
00:16:47 <DOKKA> Thanks for helping me yall, I'll be back tomorrow. G'nite!
00:16:55 <earthy> bohdan: haven't met him in person yet
00:17:20 <bohdan> and Bill Gates (re: word) :)
00:18:12 <altmattr> polymorphic recursion and rank-n types seem awfully similar
00:18:30 <altmattr> do we know why one is officially blessed (haskell98) and the other is a language extension?
00:18:37 <earthy> couldn't tell, haven't met him in person either. :)
00:18:43 <ManateeLazyCat> dmwit: Can you describe "[uri']" in "case args of" ?
00:18:57 <dmwit> ManateeLazyCat: You can match lists:
00:19:02 <earthy> but Word does have good spelling and grammar control for Dutch
00:19:17 <earthy> and is the only program on the face of the earth to have that...
00:19:27 <dmwit> > let foo [] = 'a'; foo [x] = 'b'; foo [x, y] = 'c'; foo _ = 'z' in foo [2]
00:19:29 <lambdabot>   'b'
00:19:41 <earthy> s/control/check
00:19:46 <earthy> (it's early morning)
00:19:48 <dmwit> ManateeLazyCat: Same thing in "case," any pattern is okay.
00:20:20 <dmwit> ManateeLazyCat: You could also write (uri' : []), which looks more like the usual pattern.
00:20:42 <ManateeLazyCat> dmwit: Even "uri" at behind "[uri']?
00:21:01 <dmwit> ManateeLazyCat: That one didn't translate well.
00:21:12 <ddarius> earthy: It has an entire chapter on Kan extensions which is unusual.  It significantly uses string diagrams which is also unusual.  As far as I could tell from skimming, it doesn't seem to go much into applications until the end.  It does seem like it has a lot of good Haskell relevant info, but I don't think the presentation is ideal (for that audience.)
00:21:30 <ddarius> It is author by Curien of CAM fame (the last chapter covering some CAM stuff)
00:22:32 <earthy> ddarius: it did seem rather formal and 'l'art pour l'art'
00:23:41 <ddarius> earthy: Indeed.
00:24:33 <bohdan> @pl \a b c x -> x // f a b c
00:24:33 <lambdabot> ((flip (//) .) .) . f
00:24:46 <bohdan> @pl \x a b c -> x // f a b c
00:24:46 <lambdabot> (. f) . (.) . (.) . (//)
00:26:39 <ManateeLazyCat> dmwit: What's the essences of "[SYMBOL]"? It's only use in "case foo of"?
00:27:21 <dmwit> ManateeLazyCat: Patterns can be used in "case" and in function definitions.
00:27:50 <bohdan> > let [a,b] = [1..2] in a + b
00:27:52 <lambdabot>   3
00:28:29 <dmwit> Also in do-block binding.
00:28:46 <dmwit> Almost anywhere you can bind variable names, you can use pattern matching.
00:28:48 <ManateeLazyCat> dmwit: I see, [symbol] is a list
00:28:53 <dmwit> ManateeLazyCat: right
00:29:11 <bohdan> > (\[a,b] -> a + b) $ [1..2]  -- use in functions
00:29:13 <lambdabot>   3
00:29:52 <ManateeLazyCat> dmwit: If i use list [symbol] in "case", it can use as "pattern match" for condition.
00:29:58 <ManateeLazyCat> dmwit: Exactly?
00:30:24 <dmwit> I... I think so.
00:30:41 <ManateeLazyCat> dmwit: Thanks again!
00:30:52 <ManateeLazyCat> dmwit: Many times....
00:30:56 <Gracenotes> it seems [a] is used in pattern matches a fair amount
00:31:27 <Gracenotes> superficially equivalent to a:[]
00:31:50 <dmwit> ?wn superficial
00:31:51 <lambdabot> *** "superficial" wn "WordNet (r) 2.0"
00:31:51 <lambdabot> superficial
00:31:51 <lambdabot>      adj 1: being or affecting or concerned with a surface; not deep or
00:31:51 <lambdabot>             penetrating emotionally or intellectually;
00:31:51 <lambdabot>             "superficial similarities"; "a superficial mind"; "his
00:31:53 <lambdabot> [10 @more lines]
00:32:04 <dmwit> I guess that word applies.
00:33:40 <rwbarton> I'm normally a fan of string diagrams, but I'm not impressed that this category theory introduction takes 12 pages to prove that right adjoints commute with limits (normally a ~4-line computation).
00:34:24 <ManateeLazyCat> Haskell is very different programming language, i need study it more and more....
00:35:05 <dmwit> "Implementing STM in Java/C#/C++ is so hard that basically no one has successfully done it yet, but implementing STM in Haskell was done over a long weekend by SPJ"
00:35:07 <dmwit> SPJ++
00:38:39 <Gracenotes> @hackage irc
00:38:40 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/irc
00:38:59 <ManateeLazyCat> dmwit: Sometimes, indent for Haskell need type more and more, can use "{}" enclose Haskell in it? So i can indent code automatically.
00:39:24 <Gracenotes> ooh, interesting... seems a bit rudimentary though.
00:39:51 <dmwit> Gracenotes: Yeah, it's pretty incomplete.  It didn't seem very useful when I was playing with writing an IRC bot.
00:40:17 <Gracenotes> I've written an IRC bot framework more than once, so writing an ircbot framework might be useful
00:40:20 <dmwit> ManateeLazyCat: {;}-style is not used very much.  If you are indenting a lot, you may be using a bad style.
00:40:28 <Gracenotes> in addition to having a plain 'irc' package
00:40:48 <Gracenotes> is there a policy about functionality duplication on Hackage?
00:40:54 <dmwit> no
00:41:48 * ksf can't think of a situation where indenting uses more typing than using {}, at least while using tabs, and disregarding pathetic cases.
00:42:18 * ksf can't come up with pathetic cases right now, either.
00:43:05 <arw> is the syntax of 'let' different when using layout?
00:43:21 <mauke> arw: huh?
00:43:32 <ManateeLazyCat> dmwit: How to code Haskell, in emacs i need type three times "TAB" for three possible situation for indent.
00:43:41 <ksf> afaik layout and {} are completely isomorph.
00:43:44 <dmwit> I know nothing about emacs.
00:44:07 <bd_> It's best to use spaces for indentation in haskell, to make ure haskell doesn't disagree with your editor about your tab stop
00:44:13 <arw> when doing something like do { bla <- stuff; let blubb = whatever; more <- things;} then i get an error at 'more'.
00:44:28 <dmwit> arw: Yes, let introduces a block.
00:44:29 <ManateeLazyCat> dmwit: How to code in Vim if have three indent situation?
00:44:30 <mauke> arw: no, you don't
00:44:46 <dmwit> do { bla <- stuff; let { blubb = whatever }; more <- things }
00:44:57 <ManateeLazyCat> dmwit: Is hit TAB TAB TAB....?
00:44:58 <mauke> arw: oh, wait; yes, you do
00:45:03 <arw> ah, okay.
00:45:14 <mauke> arw: also, "<-" can't be the last thing in a do block :-)
00:45:17 <dmwit> ManateeLazyCat: I ":set autoindent", which keeps the same indentation as the previous line.
00:45:47 <dmwit> ManateeLazyCat: So I need to hit TAB at most once, and BACKSPACE at most as many levels of indentation there are.
00:45:50 <ksf> I use some vim mode that I've downloaded ages ago.
00:46:26 <dmwit> ManateeLazyCat: But mostly I have no more than two levels of indentation, anyway.  Any more, and I start factoring out a function. =)
00:46:40 <arw> dmwit: works, thanks.
00:46:52 <ManateeLazyCat> dmwit: I use emacs, i can use TAB jump between all situation possible indent.
00:47:19 <ManateeLazyCat> dmwit: So it's painful if you need jump out a *deep level* and indent.
00:48:01 * ksf hits Esc->I in such cases
00:48:06 <ManateeLazyCat> dmwit: And me too, i need type "TAB" switch in all indent situation
00:48:22 <ksf> wait, no, that won't work.
00:48:24 <ksf> ^ does.
00:48:44 <mauke> ^W does
00:49:00 <bohdan> alt-f4 is the super indentation key :)
00:49:10 <sjanssen> ManateeLazyCat: when editing Haskell, you generally shouldn't have very deep indentation levels
00:49:26 <dmwit> bohdan: Doesn't seem to do anything here.
00:49:47 <bohdan> dmwit, you need a proper os :)
00:49:50 <dmwit> Linux: the system so heterogeneous that you can't use anybody else's system.
00:50:03 * bohdan uses ion3
00:50:33 <dmwit> Au contraire, it is *you* who needs a proper window manager.
00:50:40 <arw> dmwit: you can also make windows unusable by the appropriate configuration.
00:50:43 <ManateeLazyCat> sjanssen: But it's painful if i need format someone's code, i have to indent code manually
00:50:57 <dmwit> arw: Yeah, but it's not the default. ;-)
00:51:10 <ksf> using alt as window manager meta key is failitude.
00:51:43 <dmwit> Bah, you people and your WMs that can only handle one possible meta key.
00:52:16 <ManateeLazyCat> I think XMonad is wonderful WM, i use it all the time.
00:52:18 <arw> and those poor guys with keyboards lacking a proper meta key :)
00:52:24 <dmwit> Sometimes, to confuse people, I bind keys to actions with no modifier at all!
00:52:27 <mauke> :t maximumBy
00:52:29 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
00:53:09 <ClaudiusMaximus> for the posterity of the logs -- my problem with GTK + HSH being incompatible *seems* to be "getChanContents is wrong and must be stopped" instead of anything intrinisically wrong in my code...
00:54:20 <ksf> I decided upon capslock as proper meta key.
00:55:44 <pumpkin> I use e as my meta key
00:56:41 <mauke> μεταξα
01:01:52 <redditbot> Rewriting Monadic Expressions with Template Haskell
01:02:20 <Peaker> The assignment (=) operator is only allowed in let, where, and global-scope.  Why not have assignment imply "let" instead of explicitly specifying let?
01:03:09 <Peaker> so   a = b ; c = d ; e     would be equivalent to:  let a = b ; c = d in e
01:03:13 <mauke> it's not assignment, and it's not an operator
01:03:28 <Peaker> Just a name :)
01:04:03 <mauke> that's also syntactically ambiguous
01:05:08 <mauke> do { x = 1; print x; y = x; x = 2; print y }
01:09:35 <dmwit> nice
01:09:46 <dmwit> The key here being that it could be one or two let blocks, I guess.
01:10:01 <dmwit> let { y = x; x = 2 } or let { y = x }; let { x = 2 }
01:10:41 <ksf> ah the wonders of mutual recursion and lexical scoping.
01:11:14 <ManateeLazyCat> dmwit: "args <- getArgs" also in *do* block, why it not need "let" ?
01:11:39 <dmwit> ManateeLazyCat: Do you know how "do" works?
01:12:09 <dmwit> do { command; ... } ---> command >> ...
01:12:23 <dmwit> do { x <- command; ... } ---> command >>= \x -> ...
01:13:08 <dmwit> do { let { x = value }; ... } ---> let x = value in ...
01:13:24 <dmwit> (This is not every possibility, but it should give you a feeling for how the transformation works.)
01:14:00 <ManateeLazyCat> dmwit: I know have need "do" with "code block", like "progn" in elisp
01:14:26 <hoyret> \quit
01:14:54 <dmwit> ManateeLazyCat: You never have to use "do" if you don't want to.
01:15:08 <dmwit> You can manually expand it like I did above.
01:15:21 <ksf> you can also dodge your way around progn
01:15:23 <dmwit> But "do" blocks can be much more readable than the explicit binding.
01:16:10 <ksf> not using do/progn makes more sense in haskell, though.
01:16:28 <ksf> (than in lisp that is, not in general)
01:17:29 <bohdan> > let a=1; b=2 in (listArray (a, b) (replicate (b - a + 2) True)) :: DiffUArray Int Bool
01:17:30 <lambdabot>       Not in scope: type constructor or class `DiffUArray'
01:17:43 <bohdan> anyway
01:17:49 <bohdan> > let a=1; b=2 in (listArray (a, b) (replicate (b - a + 2) True)) :: DiffArray Int Bool -- this works
01:17:50 <lambdabot>       Not in scope: type constructor or class `DiffArray'
01:18:13 <bohdan> > import Data.Array.Diff
01:18:14 <lambdabot>   <no location info>: parse error on input `import'
01:18:14 <ksf> still, the main difference is that progn does'nt know >>=, which is why lispy things tend to indent so fast.
01:21:29 <bohdan> so what's wrong with my DiffUArray?
01:22:46 <bohdan> let a=1; b=2 in (listArray (a, b) (replicate (b - a + 2) 0)) :: DiffUArray Int Int -- this works
01:24:39 <bohdan> array (1,1) [(1,False)] :: DiffUArray Int Bool -- doesn't work either
01:26:46 <mauke> preflex: ? dontwork
01:26:46 <preflex>  Look buddy, doesn't work is a strong statement. Does it sit on the couch all day? Is it making faces at you? Does it want more money? Is it sleeping with your girlfriend? Please be specific!
01:27:03 <bohdan> I get -- No instance for (IArray
01:27:03 <bohdan>                        (IOToDiffArray array-0.1.0.0:Data.Array.IO.Internals.IOUArray)
01:27:03 <bohdan>                        Bool)
01:28:04 <ManateeLazyCat> dmwit: I can't understand how *do* work clearly, i will study it deeply, simple is, if i use "<-" in *do* block, i don't need "let" anymore for "bar <- foo"?
01:28:23 <twb> In cabal Setup.lhs, I want to add a postClean hook that just rm -rf's some intermediary directories.
01:28:30 <twb> Is there an existing example that I can steal?
01:28:40 <ksf> <- and let are two very different things.
01:28:57 <dmwit> ManateeLazyCat: The main difference is, for Monad m, "x :: a <- foo :: m a" versus "let x :: a = foo :: a".
01:29:33 <mauke> bohdan: works here
01:30:15 <ksf> you _can_, of course, replace most let's with "x <- return y", but that's tying a knot where a straight rope works, too.
01:31:56 <ManateeLazyCat> Thanks dmwit ksf.
01:32:40 <twb> ksf: does that mean that <- is basically liftM?
01:33:19 <mauke> twb: no, it's liftM + join
01:33:19 <ksf> it's ">>= (\x ->"
01:33:54 * ksf could never get the hang of join.
01:34:14 <mauke> m (m a) -> m a
01:34:55 <ksf> yeah I know, but I'm to cozily accustomed to thinking in terms of bind.
01:35:18 <ManateeLazyCat> ksf: "<-" and "let" all give *right* to *left*, so seen from this angle, "<-" and "let" do similar thing.
01:35:26 <ManateeLazyCat> ksf: Right?
01:35:40 <ksf> in terms of data flow, yes.
01:36:17 <ksf> I tend to think in the different directions, reading "x <- y" as "x depends of y"
01:36:22 <ksf> s/of/on
01:36:42 <mmorrow> ksf: one nice way to see it is imagine you have an (Mvar (IO ())). so then if "putMVar mvar (print 42)", then "join (takeMVar mvar)" prints 42.
01:37:05 <mmorrow> takeMVar mvar :: IO (IO ())
01:37:08 <ManateeLazyCat> ksf: Thanks, although i don't know "<-" clearness, but i know different between "<-" and "let"
01:37:15 <bohdan> mauke, versions?
01:37:43 <bohdan> I have 6.8.2
01:37:55 <idnar> ksf: I read it more like "x from y"
01:38:00 <ksf> ManateeLazyCat, don't worry, monads take a while to get accustomed to.
01:38:01 <mmorrow> ksf: i'm not sure if that is very clear or not, but i was like "oh neat" about that particular use of join
01:38:18 <ksf> idnar, another way to read it is "y implies x", which is nice, too.
01:38:28 <mauke> bohdan: 6.10.1
01:38:39 <idnar> ksf: hmm, don't think that one helps me much
01:38:54 <idnar> ksf: bind doesn't seem to have much to do with mathematical implication
01:39:06 <ManateeLazyCat> ksf: Thanks for your detail describe, i can't understand "monad" clearness, but i will study again and again till i understand it complete.
01:39:12 <ksf> mmorrow, seeing that it seems to work like flattening a list into another list, just in the function monad.
01:39:31 <twb> How do I tell cabal that "cabal test" depends on "cabal build"?
01:39:37 <ksf> idnar, nope, but data flow has.
01:40:04 <idnar> ksf: I suppose
01:40:07 <mmorrow> sure, but lists aren't as cool as joining the taking and the doing from an mvar!! ;)
01:40:27 <dmwit> ManateeLazyCat: I like http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
01:40:34 <idnar> mmorrow: the mvar example seems more like a good demonstration of how IO actions are "just" values
01:40:54 <mmorrow> hmm, i don't follow :)
01:41:11 <mmorrow> ohh, you mean in the sense that you can stick em in an mvar?
01:41:13 <ManateeLazyCat> dmwit: Thanks, i will read it. ;)
01:41:23 <ksf> I had to grind my nose on the list monad to get it.
01:42:01 <dmwit> ksf: Yeah, me too.
01:42:05 <idnar> mmorrow: yeah
01:42:07 <dmwit> But I was slow.
01:42:15 <idnar> mmorrow: you're sticking the actual print action into the var, not just 42
01:42:15 <dmwit> I had to grind on State and IO, too, before I got it. =)
01:42:29 <mmorrow> idnar: ah, i gotcha. totally
01:42:30 <dmwit> I'm not sure whether Parsec was before or after I figured out what was going on...
01:43:23 <ksf> ...grokking that the key to understanding a specific monad is understanding its bind function... and concatMap is quite a beast if it's composed with itself and given non-trivial arguments.
01:43:48 <Gracenotes> You Could Have Invented Monads might be a little clearer with drawn diagrams :P
01:44:08 <ksf> the approach rwh takes is very good, too.
01:44:09 <Gracenotes> only marginally though ;)
01:44:48 <ksf> ...providing a couple of different examples of bind functions and then abstracting from it.
01:44:56 <ksf> @where rwh
01:44:57 <lambdabot> is http://www.realworldhaskell.org/blog/
01:45:04 <mmorrow> or if you have a parser that returns a parser,runP (join fooP) "asdfasdf!!!" 'll get you the "composition" of that parser with the one it produces
01:45:23 <ksf> @users
01:45:23 <lambdabot> Maximum users seen in #haskell: 623, currently: 562 (90.2%), active: 11 (2.0%)
01:45:52 <ksf> it would be cool if lambdabot listed lurkers, too.
01:46:32 <ManateeLazyCat> lambdabot is very cool
01:46:46 <ksf> @vixen are you cool?
01:46:47 <lambdabot> yup, i'm cool :)
01:47:13 <leadnose> haha
01:47:40 <ManateeLazyCat> vixen VS lambdabot ? funny?
01:47:44 <ManateeLazyCat> ;)
01:48:08 <ksf> @vixen say, what do you like in a guy?
01:48:09 <lambdabot> yah, i like
01:48:16 <ksf> ...darn.
01:48:27 <dmwit> ?vixen a/s/l
01:48:27 <lambdabot> 19/f/California
01:48:33 <ksf> turing test fail.
01:48:36 <dmwit> ?vixen Let's get dirty!
01:48:36 <lambdabot> I have a boyfriend, but he likes to watch.
01:48:43 <dmwit> ?vixen That's so hot.
01:48:44 <lambdabot> :)
01:49:26 <dmwit> ?vixen Are you a bot?
01:49:26 <lambdabot> no, how dare you ask if i'm a bot!
01:49:36 <dmwit> ?vixen No, seriously, are you a bot?
01:49:37 <lambdabot> no, how dare you ask if i'm a bot!
01:49:43 <mauke> preflex: are you a bot?
01:49:43 <preflex>  yes.
01:49:50 <pumpkin> preflex: who made you
01:49:51 <dmwit> Oh, snap!
01:49:55 <pumpkin> preflex: who made you?
01:50:13 <pumpkin> :(
01:51:18 <mmorrow> @. vixen . elite nixon
01:51:18 <lambdabot> Sex is the mysticism of materialism and the only possible religion in a materialistic society.
01:51:26 <mmorrow> hmm
01:51:28 <dmwit> preflex: zdec zrzszrzszbzmzbYz20UzbZR0z20UY0zbzuzbz20UT0zbzmzszrzszr3zbzrzbTz20Uzszrzszr3z3fU
01:51:28 <preflex>  \/\/|-|Y |)0 Y0|_| T0|-/\/\3|\|T /\/\3?
01:51:44 <pumpkin> lol
01:52:03 <mmorrow> elite nixon always gets the random ones out of vixen
01:52:22 <dmwit> ?vixen 123432 totally random garbage 32452
01:52:22 <lambdabot> i just turned 19
01:52:40 <mmorrow> hmm, maybe just plain nixon
01:52:48 <mmorrow> @. vixen nixon
01:52:48 <lambdabot> you seem upset...
01:52:51 <mmorrow> haha
01:53:07 <mmorrow> @. vixen vixen
01:53:07 <lambdabot> yeah, all alone. you?
01:53:11 <mmorrow> @. vixen vixen
01:53:11 <lambdabot> do i seem to have a deep voice? nope, all woman here
01:53:40 <ksf> @. quote vixen
01:53:41 <lambdabot> No quotes for this person. I am sorry.
01:53:45 <dmwit> ?vixen checkmate
01:53:45 <lambdabot> I hear ya!
01:53:54 <dmwit> ?vixen aoidietnsh
01:53:54 <lambdabot> how
01:53:59 <dmwit> how indeed
01:58:40 <ksf> there should be a paper about the asdf-aoeu isomorphism.
01:59:14 <pumpkin> is that related to that guy whose name has lots of "eu"s in it?
02:01:52 <redditbot> Hacking with HAppS
02:06:06 <idnar> ksf: eueueueuler?
02:06:51 <idnar> asonetuhid
02:07:06 <ksf> I seriously doubt euler used dvorak.
02:07:13 <ksf> ...or knew of it.
02:07:40 <ksf> otoh, he could have read nostradamus.
02:07:59 <idnar> ksf: in some circles, it's a well-known fact that Euler was quite fond of the Dvorak layout after HG Wells showed it to him
02:10:12 <ksf> so wells dind'nt do all the development himself, but had help from euler?
02:10:52 <idnar> ksf: Wells just provided the time-travel technology
02:12:12 <Heffalump> @src unsafeInterleaveIO
02:12:13 <lambdabot> unsafeInterleaveIO (IO m) = IO ( \ s -> let r = case m s of (# _, res #) -> res in (# s, r #))
02:12:16 <birkenfeld> is any of the RWH guys here?
02:12:29 <Heffalump> @src unsafePerformIO
02:12:30 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
02:12:34 <ivanm> @seen dons
02:12:35 <lambdabot> dons is in #concatenative, #arch-haskell, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 11h 19m 47s ago.
02:15:14 <ac> has anybody used the hsc3 library?
02:16:48 <Lemmih> birkenfeld: You're looking for dons, bos and CosmicRay.
02:18:32 <birkenfeld> Lemmih: ok, thanks
02:21:29 <Heffalump> @seen mmorrow
02:21:30 <lambdabot> mmorrow is in #ghc and #haskell. I last heard mmorrow speak 27m 35s ago.
02:21:47 <Heffalump> mmorrow: still around?
02:21:48 <lambdabot> Heffalump: You have 1 new message. '/msg lambdabot @messages' to read it.
02:23:28 <Gracenotes> is there a simple and short way to do something like this: "abcd" -> ["bcd", "acd", "abd", "bcd"]?
02:24:15 <pumpkin> , filter ((==3) . length) . subsequences $ "abcd"
02:24:16 <Lemmih> Gracenotes: Yes.
02:24:17 <lunabot>  ["abc","abd","acd","bcd"]
02:24:22 <idnar> @type subsequences
02:24:23 <lambdabot> Not in scope: `subsequences'
02:24:29 <pumpkin> not exactly the most efficient way ;)
02:24:32 <idnar> aww
02:24:32 <pumpkin> but simple and short
02:24:35 <dmwit> Gracenotes: Yes!
02:24:42 <ryant50002> does anyone in here know much about Hypergraphs?
02:24:53 <Gracenotes> pumpkin: is there something even simpler and shorter than that? :)
02:24:55 <ryant50002> (or incidence structures in general)
02:24:59 <pumpkin> ryant50002: the ones where edges aren't necessarily joining two nodes?
02:25:05 <ryant50002> pumpkin: yes
02:25:11 <pumpkin> ryant50002: nope :P
02:25:14 <ryant50002> lol
02:25:16 <pumpkin> other than their basic definition
02:25:35 <ryant50002> particularly, i'm trying to figure out whether there's an isomorphism between graphs and hypergraphs
02:25:47 <ryant50002> the fact that wikipedia doesn't say there is leads me to believe that there probably isn't
02:25:51 <ryant50002> but it doesn't say so explicitly
02:26:04 <dmwit> Gracenotes: Check out "each" in http://hpaste.org/13425
02:26:10 <idnar> > zipWith (++) <$> inits <*> tail . tails $ "abcd"
02:26:11 <lambdabot>   ["bcd","acd","abd","abc"]
02:26:15 <Heffalump> can the graph have distinguished nodes?
02:26:28 <ryant50002> Heffalump: that was my answer :P
02:26:33 <pumpkin> I've "converted" a hypergraph to a graph using them :P
02:26:34 <Gracenotes> dmwit: yeah
02:26:39 <idnar> Gracenotes: I assume your original question had an error in it?
02:26:49 <idnar> (last "bcd" should be "abc")
02:27:00 <ryant50002> Heffalump: but i have no idea whether that's right
02:27:00 <dmwit> map snd . each -- after importing Dmwit.hs =)
02:27:01 <Gracenotes> er, yeah, that's correct
02:27:03 <Gracenotes> sorry :)
02:27:10 <Lemmih> > let f xs = [ delete x xs | x <- xs ] in f "abcd"
02:27:11 <lambdabot>   ["bcd","acd","abd","abc"]
02:27:15 <Gracenotes> the permutations can be in any order as well
02:27:37 <ryant50002> Heffalump: i mean, i'm pretty sure that with distinguished nodes we can do it, just by making a node V and a node E, and then making their subnodes be the appropriate sets
02:27:39 <alc> > let f xs = [ delete x xs | x <- reverse xs ] in f "abcd"
02:27:41 <lambdabot>   ["abc","abd","acd","bcd"]
02:27:49 <ryant50002> Heffalump: but can we do it without distinguished nodes?
02:28:31 <Heffalump> no idea :-)
02:28:31 <pumpkin> ryant50002: I doubt it... how would you "convert back"?
02:28:31 <pumpkin> since every graph is already a hypergraph
02:28:31 <dmwit> > let f xs = [delete x xs | x <- xs] in f "abac" -- not as awesome
02:28:31 <lambdabot>   ["bac","aac","bac","aba"]
02:28:31 <pumpkin> aac :o
02:28:34 <ryant50002> so then the question becomes, can we create distinguished nodes out of whole cloth?
02:28:40 <Heffalump> I'd guess not.
02:28:51 <Heffalump> oh, actually, yes.
02:28:54 <ryant50002> well, what if we make a kind of alphabet of graph structures
02:28:59 <ryant50002> and then "escape" the entire graph
02:29:03 <Heffalump> yeah, precisely
02:29:21 <Heffalump> I can't be bothered to figure out the details though. Seems like it should be possible :-)
02:29:26 <ryant50002> yeah
02:29:52 <pumpkin> so it seems like that wouldn't really be a graph-hypergraph isomorphism
02:30:00 <Heffalump> oh, yeah
02:30:01 <pumpkin> but a (special-structure "escaped" graph)-hypergraph isomorphism :P
02:30:10 <ryant50002> oh, right
02:30:11 <Heffalump> you need every graph to become a hypergraph by the same mapping
02:30:27 <pumpkin> but in general, I don't think you can
02:30:35 <Heffalump> well, if you can ensure that the escaping covers all graphs, then you can do it
02:30:41 <ryant50002> yeah
02:31:01 <pumpkin> graph codings :o
02:33:09 <ac> or more generally, has anybody experimented with any sort of sound synthesis in Haskell?
02:33:27 <pumpkin> there's that music thing
02:33:34 <pumpkin> on hackage
02:33:50 <ac> pumpkin: there are quite a few music related packages
02:33:52 <Heffalump> ok, so a directed graph with n nodes can be represented in n(n-1) bits.
02:34:12 <Heffalump> So you can enumerate all graphs by just enumerating all the bit strings of the right lengths.
02:34:20 <ryant50002> Heffalump: is that an isomorphism?
02:34:22 <Heffalump> And I guess the same is true of hypergraphs with a slightly more complicated encoding.
02:34:45 <Heffalump> oh, wait.
02:34:55 <Heffalump> You need to define what operations you want them to be isomorphic under.
02:35:05 <pumpkin> "graphness"
02:35:07 <ryant50002> haha
02:35:08 <pumpkin> ;)
02:35:11 <Heffalump> Any two countable sets are isomorphic if there's no operation.
02:35:16 <ryant50002> yeah
02:35:33 <ryant50002> and i guess if we're talking about finite graphs and hypergraphs, then they're trivially isomorphic
02:37:14 <Sorethumb> This probably isn't the best channel to ask, so apologies in advance, but what would be the best way to start learning Haskell?
02:37:27 <Heffalump> sounds like the perfect channel to ask
02:37:28 <ac> Sorethumb: this is absolutely the best channel to ask
02:37:40 <ryant50002> Sorethumb: the wikibook is pretty good; i know a guy who's using it to learn Haskell as a first programming language
02:37:49 <pumpkin> @where rwh
02:37:49 <lambdabot> is http://www.realworldhaskell.org/blog/
02:37:52 <pumpkin> @where lyah
02:37:52 <lambdabot> www.learnyouahaskell.com
02:37:52 <Heffalump> sorethumb: what's your background?
02:38:19 <Gracenotes> @unpl (flip -)
02:38:19 <lambdabot> (\ d -> (\ a b c -> a c b) - d)
02:38:24 <Sorethumb> Heffalump: Some Java, C++, Python... Mostly school classes.
02:38:27 <Gracenotes> ah, that's the problem.
02:38:50 <dmwit> ?unpl (flip (-))
02:38:51 <lambdabot> (\ b c -> c - b)
02:38:56 <dmwit> ?unpl subtract
02:38:57 <lambdabot> subtract
02:39:00 <dmwit> ah, well
02:39:01 <Gracenotes> oh, of course
02:39:03 <dmwit> ?src subtract
02:39:03 <lambdabot> subtract x y = y - x
02:39:11 <Heffalump> Sorethumb: well, if you want to buy a book, the current hot favourites are Graham Hutton's "Programming in Haskell" for an academic sort of introduction, and Real World Haskell for a more practical one.
02:39:20 <Heffalump> Or lots of web resources as have been suggested.
02:39:26 <Gracenotes> flip(-) is shorter than subtract, though :)
02:39:57 <Sorethumb> Heffalump: I downloaded the .pdf of the wikibook, but, was just checking to see if there was anything else I might have missed.
02:40:01 <Gracenotes> although the whole expression requires parentheses
02:40:08 <Heffalump> well, there are loads and loads of tutorials out there
02:40:09 <Gracenotes> code golf in haskell is quite fun ;)
02:40:12 <Gracenotes> if not an abuse of notation
02:40:15 <Heffalump> just browse haskell.org until you find one you like
02:40:28 <Sorethumb> Thanks a lot!
02:40:40 <ac> Sorethumb: and feel free to ask questions in here
02:40:41 <sereven> Sorethumb: if you can get School of Expression through interlibrary loan or the like, otherwise cheaply, the first half of it is imho a more interesting way into the basics than lots of the others, helps get into the haskell mindset.
02:41:14 <ac> Sorethumb: I pretty much learned Haskell (to the extent that I know it) by asking dumb questions here
02:41:20 <Sorethumb> ac: haha okay
02:41:59 <Sorethumb> I'm just acting a little timid because other programming language channels I've been on seem kinda hostile to newbies.
02:42:25 <dmwit> Haskell is different.  Its community is different, too.
02:42:42 <Heffalump> more desperate to be liked, perhaps ;-)
02:42:50 <ac> Sorethumb: and reading YAHT
02:42:56 <dmwit> Heffalump: ;-)
02:43:01 <Sorethumb> ac: YAHT?
02:43:13 <ac> Sorethumb: Yet Another Haskell Tutorial (see tutorial section on haskell.org)
02:43:16 <dmwit> ?where YAHT
02:43:16 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
02:43:27 <Sorethumb> Oh, handy bot.
02:43:37 <dmwit> I liked the Gentle Intro; others like LYAH or RWH.
02:43:37 <pumpkin> way handier than that
02:43:40 <dmwit> ?where gentle
02:43:40 <lambdabot> http://www.haskell.org/tutorial/
02:44:06 <Sorethumb> Thanks for the resources.
02:44:14 <Sorethumb> So, what kind of stuff have you guys made?
02:44:33 <ac> check out hackage.haskell.org
02:44:37 <Sorethumb> Doing so right now.
02:44:42 <pumpkin> Sorethumb: we've made a big IRC channel :)
02:44:50 <ac> and a fancy IRC bot
02:45:00 <pumpkin> it knows all of haskell by heart
02:45:02 <pumpkin> or almost all of it
02:45:04 <pumpkin> (!)
02:45:15 <Sorethumb> Hahaha, that's rad!
02:45:55 * pumpkin uses some rad-X
02:46:27 <pumpkin> (rad skorpan left :o)
02:46:28 <dmwit> Is that like GasX?
02:46:44 <pumpkin> it's a dumb fallout reference :P
02:46:54 <pumpkin> sorry, been up too long
02:47:00 <Adamant> pumpkin: #haskell isn't radioactive
02:47:06 <Adamant> too friendly to be so
02:48:19 <Sorethumb> Are there Haskell developer jobs out there?
02:48:30 <dmwit> ?wiki haskell in industry
02:48:30 <lambdabot> http://www.haskell.org/haskellwiki/haskell_in_industry
02:48:38 <Sorethumb> BAM!
02:48:50 <Heffalump> BAM?
02:49:14 <Heffalump> Sorethumb: there are some, but not a huge number. Quite a lot of companies employing a few Haskellers, and one (Galois) employing several tens.
02:49:52 <pumpkin> so decimal of you
02:50:03 <Sorethumb> Ah, this is more hobby than anything. I'm planning on going to art school :P
02:50:18 <pumpkin> it's gotta be duodecimal until 100, everyone knows that!
02:50:32 <Heffalump> several sixes, then
02:50:35 <pumpkin> lol
02:50:42 <pumpkin> :)
02:50:45 <Adamant> Sorethumb: if art school doesn't work out, there are worse gigs than programming
02:50:51 <sereven> @vixen I think Sorethumb is impressed with your web skills.
02:50:51 <lambdabot> hey, who did we fight in WWII besides Germany and Russia?
02:51:06 <Sorethumb> Adament: This is very true.
02:51:19 <cizra> lambdabot: japan
02:51:29 <Sorethumb> lambdabot: trick question
02:54:00 <ac> did we really _fight_ Japan?
02:54:12 <dmwit> Not for long.
02:54:29 <ac> more like just indiscriminately killing a large number of them
02:54:46 <mm_freak_> i was trying to make a list type without resorting to haskell's type system
02:54:57 <mm_freak_> type List a b = (a -> b -> b) -> b -> b
02:55:08 <mm_freak_> this is my result…  does anyone know a better way?
02:56:17 <sereven> I wonder what nationality vixen has... They were not allies of Russia, but they were enemies of Germany... aiii! lamdabot has defeated me again.
02:56:23 <dmwit> mm_freak_: I think that's basically the standard Church encoding.
02:56:36 <dmwit> :t buildr
02:56:37 <mm_freak_> dmwit: what's church encoding?
02:56:37 <lambdabot> Not in scope: `buildr'
02:56:45 <dmwit> ?go church encoding list pair number
02:56:48 <lambdabot> http://en.wikipedia.org/wiki/Church_encoding
02:56:48 <lambdabot> Title: Church encoding - Wikipedia, the free encyclopedia
02:56:54 <mm_freak_> ah, thanks
02:57:25 <dmwit> Some of the examples are even written in Haskell notation. =)
02:57:53 <dmwit> :t foldr
02:57:55 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
02:58:19 <dmwit> You're basically storing a list as its fold.
02:58:37 <dmwit> You can do a similar thing for any data type, by simply replacing each constructor with a function.
02:58:38 <dmwit> :t either
02:58:40 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
02:59:02 <dmwit> So, the Church-encoded Either is type Either a b = (a -> c) -> (b -> c) -> c
02:59:13 <mm_freak_> indeed
02:59:32 <mm_freak_> i've seen that being done for pairs, so i wondered whether i could do it for lists
02:59:49 <dmwit> Seems like you did just fine. \o/
03:00:01 <mm_freak_> but somehow i'm not happy with the result, because it's hard to work with
03:00:30 <mm_freak_> btw, i've done this in (non-standard) C once =)
03:00:36 <dmwit> Well, you can write cons in a pretty straightforward way.
03:00:45 <mm_freak_> i've already written cons and nil
03:00:47 <ac> mm_freak_: isn't being hard to work with the point of Church Encoding?
03:00:53 <mm_freak_> nil = \f z -> z
03:00:56 <dmwit> "head" isn't too bad, either; it must be ($ const) or something equally easy.
03:00:56 <mm_freak_> cons x xs = \f z -> x `f` xs f z
03:01:07 <idnar> ac: hahaha
03:01:08 <dmwit> From there you just build your way on up.
03:01:24 <mm_freak_> ac: uhm, for some people, particularly unlambda programmers =)
03:02:24 <Sorethumb> My head is exploding.
03:02:29 <dmwit> BAM!
03:02:37 <Sorethumb> Pretty much.
03:02:38 <pumpkin> POW!
03:02:38 * ac wipes bits of brain off face
03:02:42 <mm_freak_> KABOOM!
03:02:44 <dmwit> Sorethumb: Ain't it beautiful?
03:02:46 <dmwit> ?quote brains
03:02:47 <lambdabot> HarriKiiskinen says: banging my head against Haskell, but liking the feeling of hurting brains
03:02:53 <pumpkin> ?quote ackbar
03:02:53 <lambdabot> No quotes match.
03:02:55 <pumpkin> :(
03:02:59 <dmwit> ?quote quote
03:02:59 <lambdabot> mauke says: @quote vim
03:03:03 <dmwit> ?quote vim
03:03:03 <lambdabot> lament says: "go, the vim of games"
03:03:05 <mauke> what
03:03:05 <pumpkin> ?quote ackbar
03:03:06 <lambdabot> ackbar says: it's a trap!
03:03:12 <mauke> @quote mauke
03:03:13 <lambdabot> mauke says: trees are hierarchical
03:03:13 <mm_freak_> ?quote church
03:03:14 <lambdabot> lennart says: alonzo is our church
03:03:19 <mm_freak_> ?quote list
03:03:20 <lambdabot> urxvt-transparency says: http://lists.schmorp.de/pipermail/rxvt-unicode/2008q1/000552.html
03:03:28 <mm_freak_> lol
03:03:31 <mm_freak_> ?quote list
03:03:32 <lambdabot> byorgey says: if math, haskell :: [Knowledge], the problem with learn $ math ++ haskell (or vice-versa) is that both lists are infinite, so you'll never get to the second one.  Better to do something
03:03:32 <lambdabot> like learn $ zip math haskell.
03:03:35 <dmwit> Ugh, what an abuse of ?quote.
03:04:00 <dmwit> learn must have some wicked polymorphism
03:04:00 <mm_freak_> hehe
03:05:06 <mm_freak_> it's interesting to see how (length . showL . fromList $ [1..1000000000]) does not stack-overflow
03:05:12 <ac> dmwit: I don't understand that Church encoding of Either
03:05:21 <mm_freak_> fromList = foldr cons nil
03:05:25 <mm_freak_> showL list = list (\x str -> show x : str) []
03:05:26 <ddarius> mm_freak_: To pass around your List type you'd want to universally quantify the b type variable, but other than that it is the standard Church encoding.  Elements of the type correspond to partially applied foldrs.
03:05:27 <idnar> dmwit: learn :: (Knowledge a) => a -> IO a
03:05:32 <dmwit> ac: I might have it wrong.
03:05:37 <dmwit> ac: What's bothering you about it?
03:05:52 <Sorethumb> Are all of you guys math majors or something? Haha
03:05:53 <ac> dmwit: what's c? How do you get a or b out of it?
03:05:54 <mm_freak_> ddarius: good idea, i was going to write a castResult function instead
03:06:08 <dmwit> ac: You don't get an a or b out of it.
03:06:32 <mm_freak_> Sorethumb: it took me some time to get all that stuff =)
03:06:35 <dmwit> ac: Eventually, you have to consume an Either and produce an IO ().
03:06:51 <dmwit> ac: So "c" here is "IO ()".
03:06:56 <idnar> ac: well, for example, you can turn ((a -> c) -> (b -> c) -> c) into Either a b
03:07:15 <idnar> ac: churchEither Left Right
03:07:16 <dmwit> ac: Of course, it could be some intermediary thing that's more convenient to deal with than IO ().
03:07:21 <IWannaLog> @type showL
03:07:23 <lambdabot> Not in scope: `showL'
03:07:32 <Gracenotes> > foldl1' subtract $ map (4/) [1,3..10^7]
03:07:34 <lambdabot>   3.1415928535897395
03:07:38 <Gracenotes> :D
03:08:09 <mm_freak_> > pi
03:08:09 <dmwit> ac: So, when you would write in Haskell, "f (Left x) = g x; f (Right x) = h x", you would write in Church "someEitherValue g h".
03:08:11 <lambdabot>   3.141592653589793
03:08:13 <mm_freak_> =)
03:08:29 <int-e> @type \e -> e Left Right
03:08:30 <lambdabot> forall a b b1 a1 t. ((a -> Either a b) -> (b1 -> Either a1 b1) -> t) -> t
03:09:07 <idnar> @type ?e Left Right
03:09:08 <lambdabot> forall t a b b1 a1. (?e::(a -> Either a b) -> (b1 -> Either a1 b1) -> t) => t
03:09:27 <ac> dmwit: ok, I see what you're saying... you just have to restructure your code
03:09:29 <mm_freak_> @let nil = \f z -> z
03:09:30 <lambdabot>  Defined.
03:09:43 <mm_freak_> @let cons = \f z -> x `f` xs f z
03:09:44 <lambdabot>  <local>:13:21: Not in scope: `xs'
03:09:47 <ac> dmwit: it's not _exactly_ equivalent to Either
03:09:52 <dmwit> ac: Sure it is.
03:09:54 <idnar> mm_freak_: cons needs some params
03:09:58 <dmwit> ac: We can make the equivalence very explicit.
03:09:59 <mm_freak_> @let cons x xs = \f z -> x `f` xs f z
03:10:00 <lambdabot>  Defined.
03:10:03 <idnar> ac: you can translate between the two representations trivially
03:10:09 <dmwit> churchToHaskell e = e Left Right
03:10:21 <pumpkin> omg westbaer
03:10:23 <int-e> @type let x :: (a -> c) -> (b -> c) -> c; x = undefined in \e -> (e `asTypeOf` x) Left Right
03:10:24 <lambdabot> forall a b. ((a -> Either a b) -> (b -> Either a b) -> Either a b) -> Either a b
03:10:25 <dmwit> haskellToChurch (Left x) = \f g -> f x
03:10:31 <dmwit> haskellToChurch (Right x) = \f g -> g x
03:10:34 <mm_freak_> @let fromList = foldr cons nil
03:10:35 <lambdabot>  Defined.
03:10:45 <dmwit> ac: That's the whole equivalence, in three meager lines.
03:10:48 <westbaer> pumpkin :o
03:10:53 <ddarius> haskellToChurch e f g = either f g e
03:10:54 <mm_freak_> @let toList list = list (:) []
03:10:55 <lambdabot>  Defined.
03:11:00 <idnar> dmwit: haskellToChurch e = \f g -> either f g e
03:11:06 <mm_freak_> > toList . fromList $ [1..5]
03:11:08 <lambdabot>   [1,2,3,4,5]
03:11:09 <idnar> :)
03:11:18 <idnar> damnit, ddarius beat me to it
03:11:18 <dmwit> ddarius, idnar: Sure, I was just being totally explicit.
03:11:22 <IWannaLog> @type fromList
03:11:24 <lambdabot> forall a t. [a] -> (a -> t -> t) -> t -> t
03:11:32 <dmwit> I pointed out the similarity to the type of "either" some pages back, in fact.
03:11:39 <idnar> anyhow, the same is true for any data structure
03:11:52 <Gracenotes> [1,3..10^7] just creates a lazy list, right?
03:11:58 <dmwit> Gracenotes: right
03:12:04 <Gracenotes> ah, good
03:12:17 <dmwit> Gracenotes: It actually desugars to "enumFromThenTo 1 3 (10^7)".
03:12:34 <pumpkin> someone should write some "Enum laws"
03:12:50 <Gracenotes> oh, that's what it's called. there's also enumFrom and enumFromTo, iirc :)
03:12:50 <pumpkin> oh no
03:12:51 <dmwit> pred . succ = succ . pred = id
03:13:11 <ddarius> > succ maxBound
03:13:13 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
03:13:13 <dmwit> Gracenotes: Right.  They also correspond to forms of the list syntax. =)
03:13:13 <pumpkin> dmwit: that's not true around the edges
03:13:17 <idnar> dmwit: that doesn't... right
03:13:20 <idnar> heh
03:13:25 <idnar> @quote majestic
03:13:25 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
03:13:33 <dmwit> Bah.  True enums *have* no edges. ;-)
03:13:39 <idnar> what?
03:13:45 <pumpkin> but also, it seems like toEnum . fromEnum and vice versa should be relatively id-ish
03:13:53 <idnar> where did that quote go?
03:13:59 <ddarius> succ . pred . succ = succ should hold.
03:14:11 <IWannaLog> ddarius: no
03:14:20 <IWannaLog> there is zero problem
03:14:24 <idnar> > succ . pred . succ $ maxBound
03:14:25 <lambdabot>   * Exception: Prelude.Enum.().succ: bad argument
03:14:27 <dmwit> Okay, how about "pred (succ x) = succ (pred x) = x when all three are defined"?
03:14:27 <ac> ddarius: yeah, breaks on the edge cases
03:14:36 <pumpkin> dmwit: sounds good :P
03:14:39 <mmorrow> Heffalump: hey
03:14:39 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
03:14:54 <pumpkin> but should fromEnum and toEnum obey laws too?
03:15:10 <IWannaLog> @type fromEnum
03:15:12 <lambdabot> forall a. (Enum a) => a -> Int
03:15:17 <mm_freak_> @let head list = list (\x y -> case y of Nothing -> Just x; o -> o) Nothing
03:15:18 <lambdabot>  Defined.
03:15:18 <IWannaLog> @type toEnum
03:15:20 <lambdabot> forall a. (Enum a) => Int -> a
03:15:25 <IWannaLog> It's for serialization
03:15:32 <pumpkin> IWannaLog: should they obey laws?
03:15:33 <mm_freak_> > head . fromList $ [1..5]
03:15:34 <lambdabot>       Ambiguous occurrence `head'
03:15:34 <lambdabot>      It could refer to either `Data.List.he...
03:15:40 <ddarius> If succ succeeds then pred should succeed.  If succ fails, then so will succ . pred . succ unless they are somehow non-strict.
03:15:41 <IWannaLog> no who cares
03:15:43 <mm_freak_> > Main.head . fromList $ [1..5]
03:15:44 <lambdabot>       Failed to load interface for `Main':
03:15:45 <lambdabot>        Use -v to see a list of the...
03:15:55 <mm_freak_> @let headL list = list (\x y -> case y of Nothing -> Just x; o -> o) Nothing
03:15:56 <lambdabot>  Defined.
03:16:01 <mm_freak_> > headL . fromList $ [1..5]
03:16:01 <dmwit> pumpkin: Ugh, I do *not* want to specify laws for fromEnum and toEnum.
03:16:01 <IWannaLog> oh enum could be a subset of N
03:16:02 <lambdabot>   Just 5
03:16:07 <pumpkin> IWannaLog: it feels dirty if they don't, though
03:16:11 <mm_freak_> d'oh
03:16:27 <mm_freak_> @let headL = ($ const)
03:16:28 <lambdabot>  <local>:17:0:
03:16:28 <lambdabot>      Equations for `headL' have different numbers of arguments...
03:16:29 <IWannaLog> I don't use enum like number so I never care
03:16:29 <pumpkin> dmwit: not asking you to write them :) just asking if they should behave "reasonably" :P
03:16:35 <mm_freak_> @let headL2 = ($ const)
03:16:37 <lambdabot>  Defined.
03:16:42 <mm_freak_> > headL2 . fromList $ [1..5]
03:16:43 <lambdabot>       Overlapping instances for Show (b1 -> b1)
03:16:43 <lambdabot>        arising from a use of ...
03:17:02 <mm_freak_> @undef
03:17:06 <IWannaLog> toEnum . fromEnum = Id
03:17:17 <dmwit> > list const undefined (fromList [1..5])
03:17:18 <lambdabot>   Not in scope: `list'Not in scope: `fromList'
03:17:18 <IWannaLog> if it exists
03:17:24 <pumpkin> IWannaLog: aha, /me gets ready to pillor a certain instance of Enum
03:17:27 <dmwit> whoops
03:17:29 <dmwit> What happened?
03:17:29 <pumpkin> pillory
03:17:34 <mm_freak_> dmwit: oh sorry, i just undeffed them
03:17:50 <mm_freak_> @let nil = \f z -> z
03:17:50 <dmwit> Oh man, I was only gone a second, and you TOTALLY effed things up. ;-)
03:17:51 <lambdabot>  Defined.
03:17:58 <mm_freak_> @let cons x xs = \f z -> x `f` xs f z
03:18:00 <lambdabot>  Defined.
03:18:07 <rdst> hello
03:18:07 <mm_freak_> @let fromList = foldr cons nil
03:18:08 <lambdabot>  Defined.
03:18:10 <mm_freak_> there you go =)
03:18:11 <dmwit> rdst: Heya!
03:18:20 <mm_freak_> hi there rdst
03:18:30 <mmorrow> , newVars 10 "x"
03:18:31 <dmwit> > fromList [1..5] const undefined
03:18:33 <lambdabot>   1
03:18:41 <lunabot>  ["x_0","x_1","x_2","x_3","x_4","x_5","x_6","x_7","x_8","x_9"]
03:18:44 <mmorrow> , newVars 10 "x"
03:18:48 <lunabot>  ["x_0","x_1","x_2","x_3","x_4","x_5","x_6","x_7","x_8","x_9"]
03:19:05 <mmorrow> , replicate 10 (newVar "x")
03:19:09 <pumpkin> IWannaLog: toEnum . fromEnum $ 5.2 == toEnum . fromEnum $ 5.7 => 5.2 == 5.7!
03:19:09 <lunabot>  ["x_0","x_0","x_0","x_0","x_0","x_0","x_0","x_0","x_0","x_0"]
03:19:14 <dmwit> > fromList [1..5] (flip const) undefined
03:19:15 <lambdabot>   * Exception: Prelude.undefined
03:19:30 <IWannaLog> what is 5.2 ?
03:19:36 <rdst> please help me install fastcgi module
03:19:39 <dmwit> Tail is probably harder.
03:19:41 <mm_freak_> IWannaLog: a number
03:19:47 <mm_freak_> dmwit: i wrote tail above
03:19:56 <ac> :t 5.2
03:19:56 <lambdabot> forall t. (Fractional t) => t
03:19:56 <rdst> it says Could not find module `Data.Function' on build
03:19:56 <dmwit> > 5.2 :: Rational
03:19:58 <lambdabot>   26%5
03:19:59 <mm_freak_> as an attempt to write head =)
03:20:04 <dmwit> rdst: Upgrade GHC to something modern.
03:20:05 <ac> IWannaLog: does that answer your question? ;)
03:20:19 <IWannaLog> @type fromEnum
03:20:20 <pumpkin> > 5 . 2 == 5.2
03:20:21 <lambdabot> forall a. (Enum a) => a -> Int
03:20:21 <lambdabot>       No instance for (Num (b -> c))
03:20:21 <lambdabot>        arising from the literal `5' at <...
03:20:24 <dmwit> mm_freak_: I think you wrote "last" as an attempt to write head.
03:20:28 <rdst> dmwit: how to upgrade ghc in debian etch?
03:20:30 <mm_freak_> oh, yes
03:20:35 * IWannaLog the rational are enum for haskell
03:20:37 <IWannaLog> strange
03:20:40 <mm_freak_> of course…  i'm mixing things up today
03:20:43 <pumpkin> IWannaLog: they are?
03:20:45 <pumpkin> oh yeah, they are
03:20:51 <pumpkin> they just enumerate the integral ones though
03:20:54 <dmwit> rdst: Hm, etch?  What version do you have currently?
03:21:04 <pumpkin> > succ $ 4%1
03:21:06 <lambdabot>   5%1
03:21:10 <IWannaLog> I don't know but one writed fromEnum 5.2, so I'm asking myself
03:21:15 <dmwit> > succ $ 4%3
03:21:15 <ac> IWannaLog: it's just convenience
03:21:16 <lambdabot>   7%3
03:21:17 <rdst> dmwit: The Glorious Glasgow Haskell Compilation System, version 6.6
03:21:20 <dmwit> pumpkin: LIES
03:21:23 <pumpkin> dmwit: :(
03:21:26 <pumpkin> you're right!
03:21:41 <dmwit> pumpkin: I think it's succ = (+1) -- lame
03:21:43 <mm_freak_> > [1, 3%2 .. 10]
03:21:44 <lambdabot>   [1%1,3%2,2%1,5%2,3%1,7%2,4%1,9%2,5%1,11%2,6%1,13%2,7%1,15%2,8%1,17%2,9%1,19...
03:21:44 <pumpkin> but my basic point is that Enum instances on non-integral Nums are inherently fail
03:21:53 <pumpkin> but you have them on Float, Double, Rational, and so on
03:22:01 <mm_freak_> pumpkin: why?
03:22:02 <pumpkin> check out my awesome english there
03:22:03 <dmwit> rdst: Okay, just grab the binary distribution from haskell.org/ghc, I guess.
03:22:07 <pumpkin> " inherently fail"
03:22:09 <IWannaLog>  how can we ask lambdabot to show all functions from a class ?
03:22:20 <ivanm> @src Enum
03:22:21 <dmwit> ?instances Eq
03:22:21 <lambdabot> class  Enum a   where
03:22:21 <lambdabot>     succ                     :: a -> a
03:22:21 <lambdabot>     pred                     :: a -> a
03:22:21 <lambdabot>     toEnum                   :: Int -> a
03:22:21 <lambdabot>     fromEnum                 :: a -> Int
03:22:23 <lambdabot> [3 @more lines]
03:22:25 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
03:22:27 <ivanm> IWannaLog: ^^
03:22:29 <IWannaLog> tanks
03:22:30 <pumpkin> mm_freak_: they're inelegant... I know they allow you to avoid fromIntegral'ing [1..] but still
03:22:30 <dmwit> Oops, I misread the question.
03:22:34 <ivanm> that's the ones that an instantiation has to implement
03:22:35 <rdst> dmwit: thx, I'll try
03:22:49 <mm_freak_> pumpkin: inelegant?  why?  or for what purpose?
03:22:50 <IWannaLog> so Enum is for Int, not for something else
03:22:55 <ivanm> but realistically, there's an infinitely large number of possible functions using elements from a class
03:22:58 <ac> pumpkin: so what? You used fail as an adjective
03:23:01 <mm_freak_> remember, it's not the purpose of Enum to count sets =)
03:23:05 <IWannaLog> a Enum type must be a subset of Int (and encoded in an Int)
03:23:20 <ivanm> I wouldn't say that
03:23:26 <ivanm> Integral isn't a subset of Int ;-)
03:23:31 <ddarius> When your categorical diagrams need a fold-out, you're doing it wrong.
03:23:37 <ivanm> s/Integral/Integer/
03:23:37 <pumpkin> mm_freak_: still, you'd think it would have some basic laws, and be able to do more interesting stuff than anything that is smaller than maxBound :: Int
03:24:17 <pumpkin> mm_freak_: I dunno, it just feels a little dirty :)
03:24:26 <mm_freak_> pumpkin: i don't think so =)
03:24:30 <IWannaLog> Integran is not an enum, it can't answer fromEnum safely
03:24:34 <dmwit> ivanm: They have to be, merely because fromEnum says they must be.
03:24:52 <ivanm> dmwit: so how come Integer is an instance of Enum?
03:25:04 <pumpkin> > fromEnum 53236237327237
03:25:06 <lambdabot>   53236237327237
03:25:14 <dmwit> > fromEnum (2^65)
03:25:16 <lambdabot>   0
03:25:18 <pumpkin> lol
03:25:27 <pumpkin> this thing running on a 64-bit machine?
03:25:31 <mm_freak_> > [fromIntegral (maxBound :: Int) ..] :: [Integer]
03:25:33 <lambdabot>   [9223372036854775807,9223372036854775808,9223372036854775809,92233720368547...
03:25:33 <dmwit> ivanm: Ain't it great?
03:25:44 <ivanm> > fromEnum (succ (toEnum (maxBound :: Int) :: Integer))
03:25:46 <lambdabot>   -9223372036854775808
03:25:58 <ivanm> heh, I was doing that in the wrong channel :s
03:26:03 <pumpkin> so succ is defined separately from fromEnum
03:26:05 <dmwit> > map fromEnum [maxBound :: Int ..]
03:26:07 <lambdabot>   [9223372036854775807]
03:26:09 <IWannaLog> Why Integer is an enum, it's a too big type
03:26:25 <IWannaLog> @type succ
03:26:27 <lambdabot> forall a. (Enum a) => a -> a
03:26:27 <mm_freak_> IWannaLog: because it would be highly inconvenient if it wouldn't be =)
03:26:28 <dmwit> > map fromEnum [fromIntegral (maxBound :: Int)..]
03:26:30 <lambdabot>   [9223372036854775807,-9223372036854775808,-9223372036854775807,-92233720368...
03:26:32 <ivanm> IWannaLog: because it makes sense for it to be an enum?
03:26:43 <ivanm> IWannaLog: a better question: why _shouldn't_ it be an enum?
03:26:43 <pumpkin> dmwit: beautiful that
03:26:49 <ivanm> > fromEnum (succ (toEnum (maxBound :: Int) :: Double))
03:26:50 <ivanm> ;-)
03:26:51 <lambdabot>   -9223372036854775808
03:26:53 <IWannaLog> because of fromEnum which could fail
03:27:02 <pumpkin> IWannaLog: it fails so many other places
03:27:07 <pumpkin> I guess it's not required to not fail
03:27:09 <mm_freak_> it's not the instance that is flawed
03:27:09 <IWannaLog> >fromEnum (123647864587538675397854786375498647856494 :: Integer)
03:27:13 <mm_freak_> it's the class itself
03:27:18 <ivanm> IWannaLog: so? the from/to enum stuff isn't the definition of Enum
03:27:25 <dmwit> ivanm: In principle, I agree with you; it is fromEnum/toEnum that is broken, not the instances.
03:27:31 <pumpkin> mm_freak_: it seems like both, it should be to/from Integral
03:27:33 <dmwit> s/is/are/
03:27:40 <pumpkin> but the instances are complicit aren't they?
03:27:52 <pumpkin> making succ/fromEnum behave differently?
03:28:21 <mm_freak_> but even if you changed fromEnum to Integer, the same question would pop up again for sets larger than Integer
03:28:22 <dmwit> > fromEnum (123647864587538675397854786375498647856494 :: Int) :: Integer
03:28:24 <lambdabot>   Couldn't match expected type `Integer' against inferred type `Int'
03:28:29 <mm_freak_> so who cares?
03:28:31 <pumpkin> mm_freak_: make it Integral
03:28:31 <dmwit> :t fromEnum
03:28:33 <lambdabot> forall a. (Enum a) => a -> Int
03:28:40 <dmwit> > fromEnum (123647864587538675397854786375498647856494 :: Integer)
03:28:42 <lambdabot>   234729119490893166
03:28:47 <IWannaLog> Integer is big as my computer's memory
03:28:49 <pumpkin> mm_freak_: but yeah, think of Enum as "Countable set" maybe? :P
03:28:56 <pumpkin> just as you said not to a few minutes ago
03:28:58 <pumpkin> :D
03:29:01 <dmwit> mm_freak_: Sets larger than Integer are not enumerable.
03:29:16 <mm_freak_> they are enumerable in the sense of Enum
03:29:28 <dmwit> "Enum" stands for enumerable. ;-)
03:29:30 <pumpkin> what's the sense of Enum?
03:29:43 <mm_freak_> > [1.5, 2 .. 10]
03:29:45 <lambdabot>   [1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0,5.5,6.0,6.5,7.0,7.5,8.0,8.5,9.0,9.5,10.0]
03:29:46 <mm_freak_> that ;)
03:29:49 <pumpkin> lol
03:30:11 <pumpkin> omg we just enumerated the reals!
03:30:15 <dmwit> Yes, there should really be two different classes.
03:30:27 <mm_freak_> Range and Enum
03:30:30 <mm_freak_> but then nobody would use Enum
03:30:31 <dmwit> We are conflating things that have regular intervals with things that can be enumerated.
03:30:38 <pumpkin> I mean, I'm all for having something like Monad.Omega be the enumerator on Rationals
03:30:47 <IWannaLog> Enum should be just a finite set like in OCaml
03:31:04 <pumpkin> and have succ 1 be -1 :P
03:31:07 <mm_freak_> IWannaLog: that's not comparable, because Enum is a class in haskell, not a type
03:31:41 <mm_freak_> and i'm open for abstractions, if they're done properly
03:31:42 <IWannaLog> Yes but a very dangerous one
03:32:01 <IWannaLog> Enum is very badly defined
03:32:12 <mm_freak_> there are still a few things to fix in haskell regarding this, particularly Applicative/Monad-related stuff
03:32:26 <IWannaLog> If it means Enumerable it means we have a subset of N which is not Int but Integer
03:32:54 <mm_freak_> IWannaLog: you're missing the purpose of Enum
03:32:57 <Gracenotes> the rationals are somewhat hard to enumerate, although not as hard as the reals :)
03:33:05 <IWannaLog> Two notions were mixed when creating class Enum
03:33:06 <mmorrow> if a type is an instance of Enum, that means that a mapping between that type and N
03:33:07 <pumpkin> Gracenotes: not with Control.Monad.Omega!
03:33:19 <mm_freak_> IWannaLog: yeah, indeed
03:33:42 <ddarius> Freakin' Gray uses backwards terminology for Kan extensions.
03:33:47 <mm_freak_> pumpkin: it's not straightforward with Omega, since you would need to rule out doubles
03:33:54 <ivanm> @seen matthew-_
03:33:54 <lambdabot> matthew-_ is in #ghc, #haskell-blah and #haskell. I don't know when matthew-_ last spoke.
03:33:58 <IWannaLog> They shoud have separate enum for Enumerable and something like Range (good idea)
03:34:14 <ivanm> @ask matthew-_ is it OK if I take some of my wrapper functions from graphalyze and put them into graphviz?
03:34:14 <lambdabot> Consider it noted.
03:34:14 <matthew-_> I'm here!
03:34:15 <lambdabot> matthew-_: You have 1 new message. '/msg lambdabot @messages' to read it.
03:34:16 <ac> @seen humasect
03:34:16 <lambdabot> I saw humasect leaving #haskell-overflow 2m 22d 5h 40m 56s ago, and .
03:34:17 <Gracenotes> indeed, Them, always making silly standards
03:34:19 <pumpkin> mm_freak_: true that
03:34:21 <ivanm> matthew-_: heh
03:34:25 <matthew-_> yes, that's fine
03:34:28 <ivanm> should have responded faster ;-)
03:34:37 <matthew-_> sorry, I've been off the planet a bit lately
03:34:40 <Gracenotes> pumpkin: enumerating in order is a bit harder
03:34:44 <ivanm> OK, I'll try and send you a patch in the next week or so
03:34:48 <pumpkin> Gracenotes: "a bit" :P
03:34:50 <mm_freak_> however, i think, haskell is about the first language to even try to use generalization as an everyday concept
03:34:54 * ivanm should get off his lazy behind and start coding again
03:34:54 <matthew-_> ok, I'll try not to sit on it
03:34:58 <mm_freak_> so a few mistakes are ok for now =)
03:34:58 <ivanm> heh
03:35:00 <Gracenotes> i.e. a bijection between rationals and ints. one exists, though
03:35:12 <matthew-_> yeah, I keep staring at code and just failing to do anything to it
03:35:13 <pumpkin> Gracenotes: an in-order one? :o
03:35:14 <Gracenotes> you have to do a zig-zag thing in the fractional components a and b in a/b
03:35:22 <pumpkin> Gracenotes: yeah, I know that's what I was suggesting with monad-omega
03:35:26 <pumpkin> however that generates duplicates
03:35:43 <Gracenotes> I cringe at the thought of enumerating rationals in order without duplicates
03:35:53 <pumpkin> Gracenotes: I was joking about the in-order one :P
03:36:03 <IWannaLog> @type gcd
03:36:04 <lambdabot> forall a. (Integral a) => a -> a -> a
03:36:06 <Gracenotes> in-order meaning in some kind of order ;)
03:36:08 <pumpkin> 0, 1/inf, 1/(inf - 1), 1/(inf - 2)
03:36:09 <pumpkin> :P
03:36:23 <pumpkin> (yes, I know infinity is not a number!)
03:36:27 <Gracenotes> what is this omega :?
03:36:29 <ClaudiusMaximus> is there a fast implementation of something like this in the libraries?  copyArrayToByteString :: (Ix i, MArray a Word8 m) => a i Word8 -> m ByteString
03:36:30 <Gracenotes> > 1/0
03:36:32 <lambdabot>   Infinity
03:36:43 <Gracenotes> > 1/0 - 1
03:36:44 <pumpkin> Gracenotes: it's my favorite hackage package for solving euler problems!
03:36:45 <lambdabot>   Infinity
03:36:47 <pumpkin> saves me from having to think
03:36:47 <ac> :t Infinity
03:36:48 <lambdabot> Not in scope: data constructor `Infinity'
03:36:59 <pumpkin> Gracenotes: http://hackage.haskell.org/packages/archive/control-monad-omega/0.3/doc/html/Control-Monad-Omega.html
03:37:00 <mm_freak_> @let fgcd r x 0 = x
03:37:01 <lambdabot>  Defined.
03:37:11 <mm_freak_> @let fgcd r x y = r y (x `mod` y)
03:37:12 <lambdabot>  Defined.
03:37:19 <mm_freak_> > fix fgcd 12 15
03:37:20 <mmorrow> ClaudiusMaximus: if you meant s/Array/Ptr Word8/ and s/libraries/ByteString.Internal/, then yes!
03:37:21 <lambdabot>   3
03:37:39 <mm_freak_> i love fixing things
03:37:43 <Gracenotes> oh, its purpose seems to be diagonalization ;)
03:37:45 <Gracenotes> nice
03:37:46 <pumpkin> > fix mm_freak_
03:37:47 <lambdabot>   Not in scope: `mm_freak_'
03:37:51 <mm_freak_> hehe
03:37:57 <Gracenotes> how is it useful with Euler?
03:38:10 <pumpkin> Gracenotes: I've solved so many problems with it!
03:38:12 <Sorethumb> Time for bed guys. Thanks for the help.
03:38:13 <ClaudiusMaximus> mmorrow: i don't.  but i'll see if there's a way to extract a Ptr from a MArray...
03:38:21 <Gracenotes> pumpkin: hm, example?
03:38:23 <dmwit> ?let mod x y = mod x y
03:38:24 <lambdabot>  <local>:5:20:
03:38:24 <lambdabot>      Ambiguous occurrence `mod'
03:38:24 <lambdabot>      It could refer to either ...
03:38:31 <pumpkin> Gracenotes: can't remember, haven't worked on euler in a while now
03:38:32 <dmwit> ?let mod x y = L.mod x y
03:38:33 <lambdabot>  <local>:5:20:
03:38:33 <lambdabot>      Ambiguous occurrence `mod'
03:38:33 <lambdabot>      It could refer to either ...
03:38:35 <mm_freak_> g'night Sorethumb
03:38:38 <pumpkin> let me think
03:38:39 <dmwit> shucks
03:38:45 * jkff fixes a couple of stupid performance bugs in zip-archive, speeds it up by a factor of 5 and complains that GHC runs out of memory when compiling the CRC32 module with -ddump-simpl
03:39:00 <Gracenotes> pumpkin: any examples of it naturally coming up! :P
03:39:07 <jkff> Is there a compiler option for setting the maximal compiler memory?
03:39:16 <ddarius> Gracenotes: There's a very nice, small piece of code to enumerate the rationals in order.
03:39:18 <mm_freak_> pumpkin: my favorite toy for solving PE problems was UArray
03:39:27 <mm_freak_> and sometimes even Array
03:39:34 <paper_cc> jkff: A RTS one probably
03:39:38 <dmwit> I was always partial to recursion.
03:39:38 <Gracenotes> ddarius: yeah, this is how the discussion came up in the first place, a bijection between integers and rationals
03:39:39 <ddarius> jkff: GHC is a program written in GHC.  It takes RTS options.
03:39:49 <jkff> Oh, that makes sense :) Thanks, I'll try it!
03:39:55 <pumpkin> Gracenotes: none of them were terribly obvious, but I do remember using it several times, mostly to search over two infinite lists in a way that covered both
03:40:05 <pumpkin> mm_freak_: I've never used an Array in haskell :o
03:40:12 <pumpkin> except for talking to fftw
03:40:19 <Gracenotes> oh, brute-forcing
03:40:23 <mm_freak_> lists are a last resort for me
03:40:26 <pumpkin> Gracenotes: not really :)
03:40:31 <mm_freak_> i use Array, Map, etc.
03:40:37 <pumpkin> most of mine run in under a minute
03:40:44 <pumpkin> so it's "educated brute forcing" :P
03:40:52 <Gracenotes> still brute forcing
03:40:57 <pumpkin> :(
03:41:03 * pumpkin shows off his scrawny muscles
03:41:19 <Gracenotes> brute forcing with both brains and brawn
03:41:23 <jkff> Hmm, GHC is compiling the essentially-10-line module with -ddump-inlinings for several minutes already..
03:41:46 <pumpkin> :)
03:42:25 <EvilTerran> > let rs = 1 : [y | x <- rs, y <- [x+1, 1/(x+1)]] in rs :: [Rational]
03:42:39 <lambdabot>   [1%1,2%1,1%2,3%1,1%3,3%2,2%3,4%1,1%4,4%3,3%4,5%2,2%5,5%3,3%5,5%1,1%5,5%4,4%...
03:42:49 <pumpkin> I hate how matlab wants one file per function
03:42:52 <Gracenotes> ya don't say
03:43:01 <EvilTerran> there's all the (positive) rationals :)
03:43:14 <dmwit> pumpkin: You can have local functions in the same file.
03:43:21 <pumpkin> yeah
03:43:34 <pumpkin> but I want "public ones", bah :)
03:43:49 <dmwit> You're not doing enough in your functions. ;-)
03:44:01 * dmwit hates Matlab so hard for that reason and many others
03:44:18 <pumpkin> yeah, it's really ugly but pretty handy for "playing around with data" and "getting a feel for it"
03:44:32 <pumpkin> I really dislike it, if not for all the stuff it has built-in
03:44:47 <pumpkin> wow, such bad english tonight
03:44:53 <Gracenotes> any system that separates things into files can be somewhat annoying. e.g. Haskell modules, Java classes
03:45:13 <EvilTerran> > foldr (ap.(:[id]).(:)) [[]] "abcd"
03:45:15 <lambdabot>   ["abcd","abc","abd","ab","acd","ac","ad","a","bcd","bc","bd","b","cd","c","...
03:45:28 <pumpkin> but this is just an automatic disincentive to reuse :(
03:46:22 <mmorrow> ClaudiusMaximus: see ByteString.Internal.create (or createAndTrim) + Foreign.Marshal.Utils.copyBytes
03:46:27 <dmwit> I have a reliable source that says J is a nice Matlab replacement.
03:46:43 <PhilRod> EvilTerran: is that all the subsequences of "abcd"?
03:47:03 <pumpkin> dmwit: J of APL/J/K?
03:47:17 <EvilTerran> PhilRod, er, it seems to be, yeah; i saw it in my dumping-ground of weird snippets of haskell, and couldn't remember exactly what it did
03:47:21 <Gracenotes> dmwit: that's interesting... I have tons of reliable sources I call upon to give me information
03:47:28 <EvilTerran> ?unpl (ap.(:[id]).(:))
03:47:28 <lambdabot> (\ e -> (\ h i j -> i >>= \ g -> j >>= \ h -> return (h g h)) (\ k -> k) ((((:)) e) : [(\ a -> a)]))
03:47:29 <olsner> the J gui can't type ~ (something wrong with dead-key handling), so I pretty much stalled after step 2 of the J tutorial
03:47:32 <EvilTerran> yikes
03:47:41 * PhilRod sets to work trying to understand it
03:48:19 <olsner> @. pl unpl (ap.(:[id]).(:))
03:48:19 <lambdabot> (. flip (fmap . join . flip id)) . (>>=) . (: [id]) . (:)
03:48:20 <Gracenotes> heh, I have a weird-snippets-of-Haskell file as well...
03:48:21 <Myrth> @src (:)
03:48:21 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
03:48:28 <ddarius> > let next x = recip (fromIntegral n + 1 - y) where (n,y) = properFraction x in iterate next 1 :: [Rational]
03:48:29 <lambdabot>   [1%1,1%2,2%1,1%3,3%2,2%3,3%1,1%4,4%3,3%5,5%2,2%5,5%3,3%4,4%1,1%5,5%4,4%7,7%...
03:48:36 <mmorrow> , src '(:)
03:48:46 <lunabot>  data [a] = ... | (:) a ([a]) | ...
03:48:46 <lunabot>  infixr 5
03:49:09 <mmorrow> unuglyprinting that..
03:49:18 <EvilTerran> ah, got it
03:49:26 <mmorrow> data [a] = [] | a : [a]
03:49:29 <EvilTerran> (ap.(:[id]).(:)) = (\x -> ap [(x:),id])
03:49:38 <dmwit> > foo [] = [[]]; foo (x:xs) = map (x:) (foo xs) ++ foo xs in foo "abcd"
03:49:39 <lambdabot>   <no location info>: parse error on input `='
03:49:40 <pumpkin> EvilTerran: almost as pretty as APL
03:49:45 <dmwit> > let foo [] = [[]]; foo (x:xs) = map (x:) (foo xs) ++ foo xs in foo "abcd"
03:49:46 <lambdabot>   ["abcd","abc","abd","ab","acd","ac","ad","a","bcd","bc","bd","b","cd","c","...
03:50:02 <EvilTerran> > [(x:),id] `ap` [[],[1],[2,3]]
03:50:03 <lambdabot>   [[x],[x,1],[x,2,3],[],[1],[2,3]]
03:50:12 <EvilTerran> makes perfect sense :)
03:50:15 <dmwit> yep
03:50:16 <pumpkin> lol
03:50:45 <Myrth> do you guy can just look at haskell expression and understand it right away? because my head hurts every time i try
03:51:00 <Heffalump> depends on the complexity
03:51:01 <lambdabot> Heffalump: You have 1 new message. '/msg lambdabot @messages' to read it.
03:51:10 <EvilTerran> Myrth, i just spent about 5min puzzling out a particularly weird one
03:51:21 <Heffalump> oh, hi mmorrow
03:51:34 <EvilTerran> although most are easier to follow than foldr(ap.(:[id]).(:))[[]] ;)
03:51:53 <Heffalump> and yes, I did use replicate (or rather a list comprehension) to test
03:52:10 <ClaudiusMaximus> mmorrow: ah, thanks ; i still need some way to get the base address of the array, though
03:52:19 <Gracenotes> EvilTerran: could I take a look at this weird dumping ground? :)
03:53:23 <ClaudiusMaximus> unless there's an easier way to get a cairo surface into a bytestring than what i've been puzzling over...
03:54:11 <Myrth> is it special syntax for lambdabot to accept semicolon as command separator?
03:54:24 <Gracenotes> @pl (\i -> (-1)**i / (2*i+1))
03:54:24 <lambdabot> liftM2 (/) (-1 **) ((1 +) . (2 *))
03:54:37 <Gracenotes> o-o
03:55:08 <Gracenotes> yay, application monad...
03:55:17 <EvilTerran> > var . ((++) <*> show) $ "> var . ((++) <*> show) $ "
03:55:18 <lambdabot>       Ambiguous occurrence `var'
03:55:18 <lambdabot>      It could refer to either `Data.Number.S...
03:55:22 <EvilTerran> gah
03:55:54 <EvilTerran> > SimpleReflect.var . ((++) <*> show) $ "> SimpleReflect.var . ((++) <*> show) $ "
03:55:55 <lambdabot>   > SimpleReflect.var . ((++) <*> show) $ "> SimpleReflect.var . ((++) <*> sh...
03:56:13 <EvilTerran> Gracenotes, there's another from the vault :)
03:56:20 <Gracenotes> nice, a quine
03:56:25 <Gracenotes> (apparently)
03:56:45 <EvilTerran> main = putStr s >> print s where s = "main = putStr s >> print s where s = " -- likewise
03:57:10 <EvilTerran> most of the stuff's pretty obscure and pointless, tho
03:57:37 <Gracenotes> @type putStr
03:57:38 <lambdabot> String -> IO ()
03:57:39 <Gracenotes> @type print
03:57:40 <lambdabot> forall a. (Show a) => a -> IO ()
03:57:45 <EvilTerran> ?src print
03:57:45 <lambdabot> print x = putStrLn (show x)
03:57:48 <EvilTerran> ?src putStrLn
03:57:49 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
04:00:10 <mbz_> ?src putStr
04:00:11 <lambdabot> putStr s  = hPutStr stdout s
04:00:19 <mbz_> ?src hPutStr
04:00:19 <lambdabot> Source not found. The more you drive -- the dumber you get.
04:00:41 <Gracenotes> you could also substitute print with its source
04:00:55 <Gracenotes> although arguably at the cost of magicalness
04:01:12 <mattam> \]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]
04:01:29 <EvilTerran> main = putStrLn (s ++ show s) where s = "main = putStrLn (s ++ show s) where s = " -- same trick, slightly different formulation
04:01:32 <dmwit> mattam: Somehow, the end of your lisp program got dumped here... and translated into Haskell syntax.
04:01:39 <pumpkin> lol
04:02:01 <EvilTerran> mattam, http://icanhascheezburger.files.wordpress.com/2007/05/catliketyping.jpg ?
04:02:14 <pumpkin> mrrowl
04:03:20 <ac> EvilTerran: presumably you'd have to speak cat in order to answer that question
04:04:25 <EvilTerran> we have many people here fluent in cat theory, will that do?
04:04:29 <dmwit> The funny part is that there's actually a program to lock your screen that flashes that message...
04:04:39 <dmwit> http://www.bitboost.com/pawsense/
04:04:50 <Gracenotes> EvilTerran: I'm a bit curious -- could you, perhaps, send me your collection of weird code? :) I have a collection myself, although most of it is just regular stuff elegant-ish-ly phrased
04:05:45 <EvilTerran> Gracenotes, ah, if you're determined... i'll go hpaste it
04:06:12 <Gracenotes> thanks very much!
04:08:20 <EvilTerran> Gracenotes, http://hpaste.org/13566 - i'm not sure if all those imports are still relevant, or if i still need the LANGAUGE pragma, but there it ids
04:08:25 <EvilTerran> not that interesting really :P
04:09:47 <Gracenotes> seems interesting to me!
04:10:30 <Gracenotes> elegant albeit confusing ways of doing something are always fun
04:17:50 <mattam> EvilTerran: hmm, exactly :)
04:20:13 <Gracenotes> "PawSense normally recognizes a cat on the keyboard within one or two pawsteps. "
04:20:46 <Gracenotes> apparently "Most cats dislike the harmonica. "
04:21:59 <Gracenotes> I wonder if I should test this on my cat :/
04:22:19 <idnar> haha
04:22:21 <mattam> EvilTerran: here's the criminal: http://mattam.org/res/maïko.jpg
04:22:22 <ac> I wonder how PawSense would interpret regular emacs usage
04:23:22 <Gracenotes> it would be quite fun to try to set it off intentionally
04:24:37 <ac> http://hpaste.org/13567 ... any ideas?
04:29:40 <ac> oh, I think I may have detected the problem: the same code in sclang doesn't work either (used to)
04:30:23 <ac> oh, nm it does
04:45:10 <ac> this is probably more of a SuperCollider question than a Haskell one. I think I need to send a "/g_new" command somehow
04:50:19 <ClaudiusMaximus> mmorrow: i found the solution in "Graphics.Rendering.Cairo.Internal.Surfaces.Image" (and a small C function that copies BGRA pixels to RGB pixels)
05:17:01 <eu-prleu-peupeu> hi
05:19:09 <Gracenotes> greetings, eu-prleu-peupeu
05:20:04 <eu-prleu-peupeu> i can't seem to compile hopengl on windows with ghc 6.10.1 :(
05:20:05 <eu-prleu-peupeu> http://hpaste.org/13570
05:20:08 <eu-prleu-peupeu> here is the dump
05:20:31 <pumpkin> eu-prleu-peupeu: how does one pronounce your nick?
05:20:41 <eu-prleu-peupeu> this is a pentium4, with an ati radeon card, i mean... checking Haskell type for GLint... not supported  ?
05:20:41 <ac> I was wondering the same thing
05:21:03 <eu-prleu-peupeu> eu = I in english
05:21:31 <pumpkin> pronounced like eye?
05:21:39 <pumpkin> or ih-ish
05:21:57 <eu-prleu-peupeu> in portuguese its pronunced like eu = "eh-uh"
05:22:28 <ac> what does it mean in portuguese? (I speaking of Portuguese, I should be learning Portuguese songs)
05:22:43 <ac> s/I //
05:23:20 <eu-prleu-peupeu> well, it doesn't mean anything, its a riddle... with the common sentence "pim prlim pim pim" and the first person "eu" (I)
05:23:47 <eu-prleu-peupeu> the short form is "prleu" :P
05:24:07 <eu-prleu-peupeu> as prlim
05:25:44 * mux adds a Binary a => Binary (Trie a) instance to bytestring-trie
05:25:59 <iago_> hi, if I want to add a new method to the MonadReader class that does the same that withReader, how I should do?
05:28:27 <ac> eu-prleu-peupeu: hum, I've only used Haskell in Linux, but the opengl package I installed had its own configure script
05:30:19 <eu-prleu-peupeu> oh i see
05:30:25 <eu-prleu-peupeu> let me try it like sh ./configure
05:30:31 <ac> eu-prleu-peupeu: anyway, it should definitely find Haskell types for those. They should be Word8, Int8, Int16, Int32, etc
05:30:39 <eu-prleu-peupeu> yes :/
05:31:26 <ac> (though I just tried "runhaskell Setup.hs configure", and it seems to do exactly the same thing as ./configure)
05:41:01 <IWannaLog> aéé@
05:44:15 <ridley> Question to anyone awake: What makes a value "monadic"?
05:44:30 <Heffalump> if it's of type Monad m => m a
05:45:09 <ridley> thanks
05:45:29 <IsoPallo> If it feels fluffy and cute.
05:45:45 <Gracenotes> RWH has a good definition of monadic
05:45:49 <cognominal> why haskell is targetting arch linux? http://cgi.cse.unsw.edu.au/~dons/blog
05:45:57 <pumpkin> Gracenotes: "having to do with monads"? :P
05:45:59 <cognominal> I have never heard of that distro...
05:46:16 <Heffalump> cognominal: because dons uses it, mainl
05:46:16 <Heffalump> y
05:46:17 <BONUS> a function can be said to be monadic if it operates on monads
05:46:26 <Gracenotes> indeed
05:46:27 <BONUS> but is not itself of a type m (a -> b)
05:46:27 <Gracenotes> “Monadic” simply means “pertaining to monads”. A monadic type is an instance of the Monad typeclass; a monadic value has a monadic type.
05:46:30 <Gracenotes> ~quote~
05:46:44 <Heffalump> I'd generally call a function monadic if its return type is monadic
05:46:47 <cognominal> thx Heffalump
05:46:59 <BONUS> yeah i agree
05:47:09 <ridley> I use Arch.
05:47:11 <ridley> i like it a lot.
05:47:13 <Gracenotes> hurray agreement.
05:47:25 <cognominal> what is stark?
05:47:52 <Gracenotes> the hero from Ironman
05:47:53 * mux notes it takes slightly more time to decode a bytestring-trie from a Binary serialization than to recompute the trie from the original data
05:49:22 <Gracenotes> @wn stark
05:49:23 <lambdabot> *** "stark" wn "WordNet (r) 2.0"
05:49:23 <lambdabot> stark
05:49:23 <lambdabot>      adj 1: devoid of any qualifications or disguise or adornment; "the
05:49:23 <lambdabot>             blunt truth"; "the crude facts"; "facing the stark
05:49:23 <lambdabot>             reality of the deadline" [syn: {blunt}, {crude(a)}, {stark(a)}]
05:49:25 <lambdabot> [16 @more lines]
06:08:20 <mortenlysgaard> Hi, i have this problem running multiple system commands. Can anyone explain to me what to do to make it work? http://hpaste.org/13571
06:10:35 <cognominal> :t nubBy
06:10:36 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
06:11:04 <cnwdup> mortenlysgaard: You could use mapM instead of map. (Or mapM_)
06:11:14 <cognominal> how can I find where it is defined?
06:11:24 <cnwdup> @src nubBy
06:11:25 <lambdabot> nubBy eq []             =  []
06:11:25 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
06:12:04 <mortenlysgaard> cnwdup; What's the difference of the two?
06:12:05 <cognominal> cnwdup, this gives the définition not what package I need to laod
06:12:23 <cnwdup> cognominal: Use haskell.org/hoogle.
06:12:27 <cnwdup> @hoogle nubBy
06:12:27 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
06:12:34 <cognominal> thx
06:12:40 <neun> mortenlysgaard: try sequence_ $ map system ["ls","id"]
06:13:09 <cnwdup> mortenlysgaard: mapM_ discards the returned values.
06:13:42 <cognominal> @src filter
06:13:43 <lambdabot> filter _ []     = []
06:13:43 <lambdabot> filter p (x:xs)
06:13:43 <lambdabot>     | p x       = x : filter p xs
06:13:43 <lambdabot>     | otherwise = filter p xs
06:14:23 <mortenlysgaard> cnwdup; Ah
06:15:14 <cognominal> @src .
06:15:15 <lambdabot> (f . g) x = f (g x)
06:15:45 <mortenlysgaard> neun; That worked well. What does the sequence_ do then, that makes this work?
06:16:02 <neun> @type sequence_
06:16:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
06:16:30 <neun> mortenlysgaard: but I think mapM is better
06:16:43 <Plouj> hi
06:16:55 <mortenlysgaard> neun; Ok
06:17:11 <Plouj> is http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html talking about abstract data types right from the first paragraph or are things like BookInfo not ADT?
06:17:26 <mortenlysgaard> does the m in mapm stand for monad?
06:17:27 <Plouj> erm
06:17:33 <Plouj> I mean *algebraic data types
06:17:34 <cnwdup> mortenlysgaard: yup
06:17:35 <Axman6> how lazy would something like do xs' <- map (\x -> print x >> return (f x)) xs be?
06:18:20 <vixey> @seen mmorrow
06:18:21 <lambdabot> mmorrow is in #ghc and #haskell. I last heard mmorrow speak 2h 28m 54s ago.
06:18:38 <mortenlysgaard> Ah! I'm all new to haskell, and i'm finding it extremely exiting but equally strange to write code in :D
06:23:17 <mortenlysgaard> neun; It worked, thanks alot! =)
06:23:25 <medfly> how do I go about returning nothing from a function? just write "null"?
06:24:01 <Axman6> heh, you're new to functional programming aren't you :)
06:24:15 <medfly> noo...
06:24:16 <jeffz`> depends on the type of the function medfly
06:24:25 <Axman6> functions have to 'return' something.
06:24:34 <Axman6> look at the Maybe type
06:25:02 <Axman6> or just say f x = ()
06:25:10 <Axman6> (which is const ())
06:25:34 <medfly> I suppose I'm really bad at this
06:25:38 <medfly> in a lot of different levels
06:26:13 <pumpkin> medfly: typical way is to return Maybe (Original type)
06:26:27 <pumpkin> and that'll allow either the original type or nothing
06:26:36 <Axman6> @src Maybe
06:26:37 <lambdabot> data Maybe a = Nothing | Just a
06:27:05 <maltem> wait, if medfly's function is really an IO action, Maybe would not be what he wants in this case
06:27:34 <medfly> I can't even write proper Haskell, let alone guess what an IO action might mean
06:27:44 * medfly is waiting for a friend to show up and correct all the awful mistakes... awful, awful...
06:28:06 <Axman6> eh
06:28:07 <maltem> medfly: well my points is, the answer to your question varies depending on what exactly you want to do, "returning nothing from a function"
06:28:08 <Axman6> heh*
06:28:30 <Axman6> @where hpaste
06:28:31 <lambdabot> http://hpaste.org/
06:28:31 <Axman6> maltem: go ^^ and paste your code, we'll give you a hand
06:28:34 <medfly> I think what I'm doing is wrong on several levels
06:28:48 <maltem> Axman6: tab error :P
06:29:01 <Axman6> uh yeah
06:29:22 <Axman6> starts with the same letter and it's the same length == the same nick afaic
06:29:41 <Axman6> :P
06:29:51 <maltem> heh
06:29:56 <Axman6> medfly: paste the code on hpaste
06:30:06 <medfly> but... you'll die of horror
06:30:28 <barkmadley> horror is good
06:30:43 <medfly> :)
06:31:30 <medfly> behold!
06:31:37 <Axman6> ?
06:31:47 <medfly> ... well, its not announcing it :) okay
06:31:55 <medfly> http://hpaste.org/13574
06:32:21 <medfly> I know its bad haskell in a lot of different levels.
06:32:23 <Axman6> yeah announcing stopped working months ago, no idea why
06:32:27 <medfly> I'm sorry, I have sinned!
06:33:29 <barkmadley> what is spreadList supposed to do?
06:33:31 <medfly> the... spread thingie, so I could use it at the bottom bit
06:33:32 <Axman6> @src otherwise
06:33:32 <pumpkin> lcm is defined in prelude btw :)
06:33:32 <lambdabot> otherwise = True
06:34:13 <medfly> well, I imagined if I just used the list, it'd come out as some kind of list within a list
06:34:16 <medfly> and I don't want that >.<
06:34:52 <Axman6> medfly: what should spreadList actually do?
06:35:03 <medfly> help me avoid the list within a list situation
06:35:17 <Axman6> huh?
06:35:25 <medfly> at the bottom :)
06:35:26 <Axman6> basically it's the id function atm
06:35:34 <medfly> id?
06:35:35 <Axman6> but, with some strangeness in the middle
06:35:38 <barkmadley> is all this to get the lcm of a list?
06:35:38 <Axman6> :t id
06:35:40 <medfly> :)
06:35:40 <lambdabot> forall a. a -> a
06:35:49 <Badger> @src id
06:35:50 <lambdabot> id x = x
06:36:08 <medfly> barkmadley, well, like I said, I'm not very good at this
06:36:51 <Axman6> medfly: take a look at this for starters, just to get some of the syntax working correctly: http://hpaste.org/13574#a1
06:37:09 <pumpkin> > foldl1 lcm [1..10]
06:37:12 <lambdabot>   2520
06:37:24 <barkmadley> you need to learn the art of folding my friend
06:37:25 <medfly> oh, I did have | before, but it said it doesn't like my syntax
06:37:36 <Axman6> > foldl lcm 1 []
06:37:38 <lambdabot>   1
06:37:44 <Axman6> > foldl lcm 1 [1..100]
06:37:46 <lambdabot>   69720375229712477164533808935312303556800
06:37:49 <Axman6> heh
06:37:59 <vixey> > foldl lcm 1 [1..10]
06:38:00 <lambdabot>   2520
06:38:42 <Axman6> medfly: just fyi, if you would like us to help, you need to be able to tell us what you want the code to do. inferance is for the compiler to do ;)
06:38:54 <medfly> also my friend mentioned that (x:xs) doesn't include the [a] and [] case >.<
06:38:54 <medfly> or maybe he said something else
06:39:12 <barkmadley> (x:xs) doesn't include the [] case, but it does include the [x] case
06:39:14 <vixey> medfly, this is not true
06:39:38 <Raevel> in the [a] case (x:xs) binds x = a and xs = []
06:39:41 <vixey> medfly, the notation for lists [x,y,z] or [e] is shorthand for x:(y:(z:[])) or e:[]
06:39:41 <Badger> :t const
06:39:43 <lambdabot> forall a b. a -> b -> a
06:40:03 <medfly> I don't know... anyway, I probably shouldn't bother you guys with my horrible mess :d
06:40:11 <vixey> medfly, so the pattern (x:xs) does match [e] binding  x := e, and xs := []
06:40:12 <pumpkin> medfly: don't be so self-deprecating! :P
06:40:21 <pumpkin> medfly: we like helping :)
06:40:25 <pumpkin> I do, at least
06:40:40 <Axman6> yeah, this is the most helpful chan i've ever been on, it's awesome
06:41:04 <barkmadley> medfly, learning happens with help sometimes
06:41:18 <Axman6> teaching is the best way to learn
06:41:20 <Axman6> by far
06:41:35 <pumpkin> omg that's why professors are so smart!
06:41:56 <pumpkin> wow, I've been up way too long
06:42:27 <Axman6> heh
06:43:46 <maltem> hm... so medfly hasn't told us what the code is supposed to do?
06:43:52 <medfly> I want to ... add something to my list, after it going through another function. only problem, this another function outputs lists, and I end up with a list within a list
06:44:09 <Stephan202> @src concatMap
06:44:09 <lambdabot> concatMap f = foldr ((++) . f) []
06:44:10 <medfly> (I dunno if I do, I haven't got to the point I can actually write working Haskell)
06:44:23 <Stephan202> medfly: maybe that's what you want? ^
06:44:35 <medfly> I have no idea what that does :D
06:44:40 <medfly> sorry, I'm not very good at this
06:44:57 <maltem> medfly: I mean, people here are smashing functions against your head, but noone has any clue what you want :)
06:45:08 <Stephan202> medfly: it maps all elements in a list to a list, and instead of returning a list of lists, it concatenates them
06:45:24 * medfly tries
06:46:05 <Stephan202> > concatMap (\x -> [x, x]) [1.3]
06:46:07 <lambdabot>   [1.3,1.3]
06:46:08 <Choko> @hoogle Int -> a -> [a]
06:46:09 <lambdabot> Prelude replicate :: Int -> a -> [a]
06:46:09 <lambdabot> Data.List replicate :: Int -> a -> [a]
06:46:09 <lambdabot> Prelude drop :: Int -> [a] -> [a]
06:46:12 <Stephan202> > concatMap (\x -> [x, x]) [1..3]
06:46:14 <lambdabot>   [1,1,2,2,3,3]
06:46:18 <Stephan202> medfly: ^
06:46:37 <Axman6> > concatMap ((:[]).(2^)) [1..10]
06:46:39 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024]
06:47:00 <Axman6> > map ((:[]).(2^)) [1..10]
06:47:02 <lambdabot>   [[2],[4],[8],[16],[32],[64],[128],[256],[512],[1024]]
06:47:11 <mauke> > map (2^) [1..10]
06:47:12 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024]
06:47:17 <Axman6> > concat [[2],[4],[8],[16],[32],[64],[128],[256],[512],[1024]]
06:47:19 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024]
06:47:25 <medfly> oh
06:47:26 <medfly> :)
06:47:28 <Stephan202> :)
06:47:41 <jeltsch> Hi, where can I get help on Lambdabot?
06:47:59 <medfly> thanks.
06:48:03 <Stephan202> jeltsch: http://code.haskell.org/lambdabot/COMMANDS
06:49:10 <jeltsch> Stephan202: But this doesn’t document the commands, it only lists them. And it doesn’t document those things like @ etc.
06:49:16 <dcoutts> @yarr!
06:49:16 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
06:49:32 <pumpkin> the best one is yhjulwwiefzojcbxybbruweejw
06:49:38 <dcoutts> @vixen happy new year to you too!
06:49:39 <lambdabot> Would you dress in women's clothes for me?  That really turns me on ;)
06:49:55 <Stephan202> jeltsch: you're right. I hope somebody else here has a better link.
06:50:07 <Stephan202> jeltsch: maybe one directory up you can find it. Not sure
06:50:25 <jeltsch> Is the @ the prefix to access lambdabot?
06:50:35 <pumpkin> jeltsch: individual commands can be @help ed
06:50:36 <Axman6> @yhjulwwiefzojcbxybbruweejw
06:50:37 <lambdabot> "\"#$%&'()*+,\""
06:50:43 <pumpkin> @help @pl
06:50:43 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:50:46 <pumpkin> @help pl
06:50:47 <lambdabot> pointless <expr>. Play with pointfree code.
06:50:54 <jeltsch> @help
06:50:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:51:06 <Axman6> pumpkin: did you remember that, or look it up on the list?
06:51:09 <jeltsch> @help index
06:51:09 <lambdabot> index <ident>. Returns the Haskell modules in which <ident> is defined
06:51:12 <Axman6> @help yhjulwwiefzojcbxybbruweejw
06:51:13 <lambdabot> V RETURNS!
06:51:24 <jeltsch> @index fix
06:51:24 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
06:51:30 <pumpkin> Axman6: I spent the past two days memorizing it to impress the ladies
06:51:41 <pumpkin> ;)
06:51:54 <Axman6> oh very nice, that will definitely work
06:52:07 <pumpkin> yeah, already has!
06:52:09 <Axman6> they're always very impressed when i tell them i can remember π to 1000 places
06:52:17 <Axman6> they're less impressed when it show them i can though
06:52:24 <pumpkin> :P
06:52:34 <mux> isn't fix in Data.Function too now?
06:52:37 <jeltsch> Hmm, lambdabots haddock module doesn’t use the up-to-date hierachical libraries, does it?
06:52:46 <mux> I find this module more idiomatic
06:53:04 <jeltsch> fix is in Data.Function and that module is the right place for it.
06:53:10 * Axman6 lied about the π thing :(
06:54:00 <lorne> Axman6: they really are impressed?
06:54:07 <Axman6> yeah!
06:54:09 <Stephan202> Axman6: we're disappointed!
06:54:15 <Axman6> heh, my girlfriend would be impressed though
06:54:21 <Axman6> she loves my geekiness
06:54:26 <Stephan202> :>
06:54:27 <medfly> :)
06:55:31 <mauke> have I got a song for you
06:55:55 <Axman6> she loves it when i tell her how computers work
06:56:04 <mauke> http://www.youtube.com/watch?v=Mfr7xG6smhU
06:56:05 <medfly> but shes not geeky?
06:56:14 <Axman6> well... not so much loves it, as pretends to listen and gets turned on >_>
06:56:51 <Axman6> not really no, she's a rather hot arts/law student, who i've known for 7 years now. she's also really intelligent
06:57:00 <Axman6> </bragging>
06:59:46 <pumpkin> lol
06:59:57 <pumpkin> *awkward silence*
06:59:59 <pumpkin> :)
07:00:10 <pumpkin> j/k :P
07:00:12 <barkmadley> way to break it
07:00:21 * neun watches maukes weird video
07:01:19 <Axman6> oh heh, i was still waiting for mauke to reply, missed the link
07:03:22 <Axman6> "i'm Amy-Suzan" ew
07:03:39 <medfly> ?
07:03:53 <cognominal> > gcd 10
07:03:54 <lambdabot>       Overlapping instances for Show (t -> t)
07:03:54 <lambdabot>        arising from a use of `s...
07:04:09 <cognominal> hum
07:04:16 <opqdonut> cognominal: it takes two arguments
07:04:38 <barkmadley> @t gcd 10
07:04:39 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
07:04:47 <pumpkin> @type gcd 10
07:04:47 <barkmadley> @type gcd 10
07:04:48 <lambdabot> forall t. (Integral t) => t -> t
07:04:49 <lambdabot> forall t. (Integral t) => t -> t
07:04:54 * pumpkin whistles
07:05:06 <cognominal> ho
07:05:12 <medfly> > gcd 2 10
07:05:13 <cognominal> > gcd 10 5
07:05:13 <lambdabot>   2
07:05:15 <lambdabot>   5
07:05:31 <Axman6> > gcd 10 7
07:05:32 <lambdabot>   1
07:05:42 <Axman6> > gcd 10 9999
07:05:44 <lambdabot>   1
07:06:07 <pumpkin> ORLY
07:06:29 <pumpkin> R DEY RLUHTIVLY PRYM?
07:06:42 <idnar> wut
07:06:49 <opqdonut> :)
07:07:14 <Axman6> > lcm 10 9999
07:07:16 <lambdabot>   99990
07:07:23 <Axman6> > lcm 10 9
07:07:25 <lambdabot>   90
07:07:28 <Axman6> > lcm 7 9
07:07:29 <chessguy> @vixen are 10 and 9999 relatively prime?
07:07:30 <lambdabot> no
07:07:30 <lambdabot>   63
07:08:00 <Choko> how would I represent bit string with length 512 in haskell?
07:08:09 <Choko> +s
07:08:20 <pumpkin> bit string?
07:08:22 <pumpkin> [Bool]?
07:08:24 <pumpkin> :P
07:08:35 <opqdonut> :info Word512
07:08:43 <opqdonut> ?info Word512
07:08:44 <lambdabot> Word512
07:08:46 <opqdonut> ^_^
07:08:48 <pumpkin> ooh
07:08:53 <pumpkin> how convenient
07:09:01 <pumpkin> ?info Word561
07:09:01 <lambdabot> Word561
07:09:05 <pumpkin> o.O
07:09:18 <pumpkin> ?info Word72461
07:09:19 <lambdabot> Word72461
07:09:22 <pumpkin> O.o
07:09:32 <opqdonut> heh, info is broken
07:09:36 <pumpkin> that's an awfully misleading name for echo
07:09:49 <opqdonut> well there is Word64
07:09:56 <pumpkin> yeah :)
07:10:03 <pumpkin>  I figured 512 might actually exist
07:10:12 <pumpkin> but wanted to be stupid
07:10:14 <EvilTerran> i vaguely recall hearing that the original ?info was taken out of action because people were overusing it or something
07:10:27 <pumpkin> EvilTerran: but everything on lambdabot gets overused
07:10:29 <pumpkin> !
07:10:38 <opqdonut> yeah I should've used ?hoogle
07:10:46 <opqdonut> guess the problem was info being so verbose
07:11:04 <EvilTerran> i know, i didn't really follow either, but that's what i heard
07:11:04 <EvilTerran> ?hoogle Word
07:11:04 <lambdabot> module Data.Word
07:11:04 <lambdabot> Data.Word data Word
07:11:04 <lambdabot> Data.Word data Word16
07:11:49 <opqdonut> they go up to 64
07:11:56 <mauke> @info do a; b; c
07:11:56 <lambdabot> a >> b >> c
07:12:01 <mauke> there is no info
07:12:17 <GremlinH`> Is there a haskell library for making animated gifs?
07:12:19 <mauke> it's autocorrected to @undo
07:12:26 <EvilTerran> aha
07:12:26 <opqdonut> Choko: anyways, to answer your question: if you're just playing around, use [Bool] or an array of Bool
07:12:44 <opqdonut> Choko: if you want performance, use a bunch of Word64's I guess
07:12:59 <Choko> okay
07:13:01 <maltem> Isn't UArray Bool optimized?
07:13:02 <pumpkin> what if he's on a 128-bit machine?
07:13:35 <Choko> I will use a bunch of word32
07:13:41 <opqdonut> UArray Bool might be optimized, yes
07:14:55 <maltem> Choko: So my vote is for UArray Int Bool :)
07:16:06 <opqdonut> maltem: there's no Bits instance for UArray Int Bool
07:16:06 <opqdonut> :/
07:16:18 <opqdonut> should be easy to write though
07:17:03 <opqdonut> Choko: http://www.cse.unsw.edu.au/~dons/code/lambdabot/scripts/LargeWord.hs <- this has word512
07:17:17 <maltem> ah right
07:17:42 <Choko> nice I'll take a look at it
07:17:47 <opqdonut> which is internally just a bunch of Word64's
07:17:53 <opqdonut> but has a Bits instance and all
07:19:06 <maltem> eh, it even has Word192
07:19:30 <maltem> 192 looks so odd
07:20:01 <maltem> not at all familiar
07:20:09 <Choko> 128+64
07:20:22 <opqdonut> well it's one of those 3*2^k numbers
07:20:33 <opqdonut> a quite common one too
07:20:41 <maltem> ok ok :)
07:20:53 <vixey> > map (\k ->  3*2^k  ) [1..]
07:20:55 <lambdabot>   [6,12,24,48,96,192,384,768,1536,3072,6144,12288,24576,49152,98304,196608,39...
07:24:35 <pumpkin> is that a typo in LargeWord for 4096?
07:25:09 <medfly> looks like it
07:26:24 <cytzol> @pl \f (x,y) -> f (-y,x)
07:26:24 <lambdabot> (line 1, column 16):
07:26:25 <lambdabot> unexpected "-"
07:26:25 <lambdabot> expecting lambda abstraction or expression
07:26:51 <Axman6> @pl \f (x,y) -> f (negate y,x)
07:26:52 <lambdabot> (`ap` snd) . (. fst) . (. flip ((,) . negate)) . (.)
07:26:59 <cytzol> ta
07:27:21 <vixey> @pl \(x,y) f -> f (negate y,x)
07:27:21 <cnwdup> > (\x -> first negate x) (1,2)
07:27:21 <lambdabot> uncurry ((flip id .) . flip ((,) . negate))
07:27:23 <lambdabot>   (-1,2)
07:27:31 <vixey> :t \f (x,y) -> f (negate y,x)
07:27:32 <lambdabot> forall t t1 t2. (Num t1) => ((t1, t) -> t2) -> (t, t1) -> t2
07:28:01 <int-e> @hoogle ThreadId -> IO a
07:28:02 <lambdabot> Control.Exception evaluate :: a -> IO a
07:28:02 <lambdabot> Control.Concurrent killThread :: ThreadId -> IO ()
07:28:02 <lambdabot> Control.Concurrent.MVar swapMVar :: MVar a -> a -> IO a
07:28:17 <vixey> :t let x f g (p,q) = (f p, g q) in ((negate`x`id) .)
07:28:18 <int-e> Hmm, given a ThreadId, can I find out whether the corresponding thread is still running?
07:28:18 <lambdabot> forall t t1 a. (Num t) => (a -> (t, t1)) -> a -> (t, t1)
07:30:57 <int-e> ah. GHC.Conc.threadStatus looks good.
07:35:20 <int-e> perfect, in fact. it told me everything I wanted to know :)
07:36:17 <icqnumber> is gtk2hs an official gnome binding?
07:38:01 <EvilTerran> "official"?
07:38:50 <pumpkin> blessed by Lord Stallman
07:38:54 <icqnumber> i have found , it is not http://www.gtk.org/language-bindings.html
07:39:01 <pumpkin> and Lord Torvalds
07:39:05 <pumpkin> at the climax of their union
07:39:14 <cytzol> ew
07:39:18 <medfly> haha
07:39:18 <rdeshpande> hello world
07:39:19 <int-e> it's blessed by dcoutts ;-)
07:40:59 <SamB_XP> No court of law could conclude that it is not a GTK binding ...
07:42:23 <mnislaih> hi all, I'm killing some time solving SPOJ problems. anyone mind to take a look at my code and suggest efficiency improvements, or perhaps a better algorithm ?
07:42:34 <mnislaih> code is here: http://hpaste.org/13576
07:42:44 <mnislaih> and the problem being solved is http://www.spoj.pl/problems/NICEDAY
07:44:38 <timetrap> I need some advice. I currently work with and understand python. And I want to learn haskell (and functional programming in general).
07:44:48 <pumpkin> if you say SPOJ out loud, it sounds rude
07:44:53 <timetrap> What was the tutorial or book that helped you the most
07:44:55 <timetrap> ???
07:45:32 <athos> TAHCH
07:45:32 <pumpkin> what helped me the most was idling in this channel
07:45:35 <athos> 8]
07:45:48 <timetrap> pumpkin: haha
07:45:52 <pejo> timetrap, it probably depends some on your background
07:45:59 <pumpkin> and when someone does something funky, saying "WTF?", followed by a :t <something funky> and a @src <some part of something funky>
07:46:07 <pumpkin> and then followed by an "aha"
07:46:39 <pumpkin> timetrap: it's a pretty epic learning experience
07:48:42 <timetrap> I was looking at the scheme class that sussman has online. I figured it would give me a better understanding of functional programming.
07:49:06 <mauke> http://dis.4chan.org/read/prog/1230981511/1-40
07:50:43 <timetrap> mauke: lol
07:52:01 <pumpkin> I like the japanese, very profound ending
07:52:27 <Gracenotes> are there any well coded haskell network apps anyone would recommend?
07:53:18 <opqdonut> Gracenotes: gitit is nice
07:53:21 <Gracenotes> not including http/https, I mean. for instance, implementations of client protocols
07:53:22 <Olathe> timetrap: Several days thinking about some intro to Scheme exercises helped me to get a much quicker start in Haskell.
07:53:26 <opqdonut> ah, not http
07:53:43 <Gracenotes> I'll look into it that, though
07:53:47 <Gracenotes> @hackage gitit
07:53:47 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gitit
07:54:35 <timetrap> Hmm . . . What do you guys do for libraries/modules ? Python has a ton (of varying quality). . . what about haskell?
07:54:50 <mauke> see hackage
07:54:51 * timetrap swears he's not a troll
07:55:09 <mauke> it's our central library repository
07:55:24 <SamB_XP> well, a troll probably wouldn't have said (of varying quality) ;-P
07:55:34 <timetrap> Thanks!
07:55:47 * timetrap off to discover a new, more functional world.
07:57:07 <Gracenotes> hm, I see we don't have an ftp package, as far as I can tell. that might be a simpler place to start
07:57:56 <RayNbow> > foldM (sequence . sequence [(+),(-)]) 0 [1..3]
07:57:57 <lambdabot>   [6,0,2,-4,4,-2,0,-6]
07:57:57 <opqdonut> Gracenotes: happs is a great architecture for network stuff
07:57:57 <sclv> gracenotes: the curl bindings do fine for downloading.
07:58:17 <EvilTerran> Gracenotes, i believe there's an IRC package
07:58:26 <Gracenotes> yep, I downloaded the IRC package
07:58:30 <EvilTerran> dunno how well-written it is
07:58:49 <Gracenotes> its functionality is relatively minimalistic
07:59:38 <Gracenotes> curl bindings are fine for downloading, but Unix philosophy, do one thing and do it well, etc. Implementing an FTP client library is a good programming exercise as well
08:00:29 <sclv> of course.
08:00:35 <thoughtpolice> the irc library works terrific, imo :)
08:01:00 <thoughtpolice> a bytestring-based parsec3 version might be nice, however.
08:01:04 <BrokenClockwork> Hey, I want to part a number with 4 digits into two with 2
08:01:13 <BrokenClockwork> for isntance 2344 into 23 and 44
08:01:18 <Gracenotes> terrific in a good way, right? ;)
08:01:29 <Olathe> > divMod 2344 100
08:01:30 <lambdabot>   (23,44)
08:01:42 <BrokenClockwork> hah, that's nice muhaha
08:01:45 <BrokenClockwork> thanks
08:01:48 <Olathe> You're welcome.
08:02:58 <alc> @users
08:02:58 <lambdabot> Maximum users seen in #haskell: 623, currently: 608 (97.6%), active: 24 (3.9%)
08:03:41 <Gracenotes> sclv: I mean, we could use curl bindings instead of the HTTP library ;)
08:07:33 <BrokenClockwork> has Haskell any economical use in industrie?
08:19:20 <BrokenClockwork> how can I cogagtinate two chars?
08:19:25 <BrokenClockwork> like 'a' ++ 'b' ?
08:19:42 <baaba> cogagtinate?
08:19:56 <baaba> > 'a':'b':[]
08:19:57 <lambdabot>   "ab"
08:19:58 <pumpkin> BrokenClockwork: nope, you can cons them together
08:20:15 <BrokenClockwork> concatenate
08:20:16 <pumpkin> @src (++)
08:20:16 <lambdabot> []     ++ ys = ys
08:20:17 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
08:20:17 <lambdabot> -- OR
08:20:17 <lambdabot> xs ++ ys = foldr (:) ys xs
08:20:19 <pejo> BrokenClockwork, go to cufp.galois.com - there's a bunch of reports there about fp use in industry.
08:20:52 <BrokenClockwork> ah nice, ok
08:27:31 <EvilTerran> > ['a', 'b']
08:27:32 <lambdabot>   "ab"
08:30:58 <Gracenotes> ah. Reverse Polish notation never fails to confuse me.
08:31:40 <mauke> preflex: calc 2 3 4 * +
08:31:41 <preflex>  10
08:32:34 <EvilTerran> er
08:32:42 <vixey> mauke that calc thing is so evil
08:32:51 <EvilTerran> preflex: help calc
08:32:52 <preflex>  calc EXPR - evaluate an arithmetic expression
08:32:55 <not_much_> huh, 14
08:33:01 <vixey> preflex: calc 2 (3 4) * +
08:33:01 <preflex>  10
08:33:08 <vixey> preflex: calc 2 ((3 4) *) +
08:33:08 <preflex>  10
08:33:17 <EvilTerran> umm
08:33:18 <vixey> preflex: calc (2 ((3* 4)) +
08:33:18 <preflex>  10
08:33:25 <mauke> preflex: calc 2 3 4 * (+
08:33:26 <preflex>  14
08:33:27 <roconnor> calc just always returns 10
08:33:32 <roconnor> easier that way
08:33:37 <EvilTerran> preflex: calc 2 + 3 * 4
08:33:37 <preflex>  14
08:33:42 <vixey> preflex: calc 2 3 4 *
08:33:42 <preflex>  Too many operands
08:33:49 <EvilTerran> what the heck
08:33:58 <vixey> mauke yuo use shunting yard algorithm?
08:34:04 <mauke> vixey: what's that?
08:34:25 <vixey> pushing stuff on a stack and popping when you seee ) and + and so on
08:34:28 <Gracenotes> for some reason, as well, postfix is much harder to read than the basically flipped infix
08:34:32 <mauke> vixey: no
08:34:39 <Gracenotes> er, prefix
08:34:56 <EvilTerran> Gracenotes, eh, you get used to postfix after playing with it for a while
08:35:02 <mauke> preflex: calc + * 4 3 2
08:35:02 <preflex>  10
08:35:18 <vixey> preflex calc + 1 2
08:35:18 <preflex>  3
08:35:20 <vixey> preflex calc + 1 1+2
08:35:20 <preflex>  4
08:35:21 <vixey> preflex calc + 1 1+1
08:35:22 <preflex>  3
08:35:26 <Gracenotes> you can cheat and read it backwards ;)
08:35:27 * EvilTerran tends to write postscript by hand for small diagrams, so is used to RPN
08:35:29 <vixey> preflex calc + 1 3*4
08:35:29 <preflex>  13
08:35:31 <idnar> Gracenotes: haha
08:35:38 <vixey> preflex calc 2 + 1 3*4 *
08:35:38 <preflex>  14
08:35:43 <vixey> preflex calc 2 (+ 1 3*4) *
08:35:43 <preflex>  20
08:36:12 <EvilTerran> i think preflex's calc may be trying a little too hard to make sense of the input
08:36:53 <mauke> I think the algorithm might be similar to the one used by yacc, actually
08:37:30 <roconnor> @vote
08:37:31 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
08:38:22 <mauke> the basic idea for this parser is: go through the input from left to right. insert each token into the expression tree as you go.
08:38:45 <mauke> i.e. at each step there's an (almost) complete tree
08:38:48 <EvilTerran> sounds inspired by shift-reduce and/or shunting-yard, at least
08:39:05 <mauke> that's also the only dynamic state needed
08:39:15 <mauke> no recursion, no stacks, just the tree itself
08:39:21 <Gracenotes> it's nice how haskell offers both prefix and infix
08:39:35 <EvilTerran> > (4 `negate`) -- and postfix!
08:39:36 <lambdabot>   -4
08:39:55 <roconnor> @vote logoVotingMethod Schulze
08:39:56 <lambdabot> voted on "Schulze"
08:40:02 <Gracenotes> EvilTerran: well, sorta :P
08:40:08 <mauke> the two evil extensions used in preflex are separate paren parsing and separate operand parsing
08:40:25 <Gracenotes> 3 subtract4 in postfix might get a bit tricky
08:40:29 <roconnor> @poll-result logoVotingMethod
08:40:29 <lambdabot> Poll results for logoVotingMethod (Open): Schulze=1
08:40:30 <EvilTerran> Gracenotes, well, that one's a GHC extension of sorts
08:40:59 <roconnor> w00t!
08:41:03 <EvilTerran> the report's official desugaring for (x `f`) wouldn't work for single-parameter f
08:41:11 <EvilTerran> iirc
08:42:02 <roconnor> > let minutes = (*60) in (5 `minutes`)
08:42:04 <lambdabot>   300
08:42:25 <Gracenotes> yeah, I was just making something like that :)
08:42:34 <Gracenotes> > let minust = (3 `subtract`) in (4 `minust`)
08:42:35 <lambdabot>   1
08:42:43 * EvilTerran feels that "(?) = readIORef" goes well with "($=) = writeIORef"
08:42:45 <Gracenotes> it's like postfix, two times!
08:42:49 <Gracenotes> except it's not!
08:43:31 <EvilTerran> so you can have "do ... x $= 4; ...; y <- (x?); ... "
08:44:11 <ozy`> @src (:=)
08:44:11 <lambdabot> Source not found. My pet ferret can type better than you!
08:44:48 <coco> is there a way in haskell to express an anonymous function defined with multiple patterns?
08:44:51 <EvilTerran> that would be a constructor, 'cos of the leading (:)
08:44:58 <mauke> coco: no
08:45:04 <EvilTerran> coco, only "\x -> case x of ..."
08:45:05 <ozy`> coco: gotta use a case statement
08:45:18 <coco> thanks
08:45:21 <coco> why is this?
08:45:32 <EvilTerran> coco, although there's a proposal to add "case of ..." as syntactic sugar for "\x -> case x of ...", it hasn't been implemented yet
08:45:32 <ozy`> coco: case statements are used under the hood anyway, even with multiple-definition functions
08:45:47 <ozy`> EvilTerran: that'd be nice
08:45:58 <coco> yes, that would be nice :)
08:46:04 <EvilTerran> ?source ghc
08:46:04 <lambdabot> ghc not available
08:46:24 <ozy`> could they add "cond" as sugar for "case () of ()" while they're at it?
08:46:33 <coco> EvilTerran: is the proposal documented somewhere?
08:46:43 <EvilTerran> coco, it was on the haskell' trac at one point
08:46:47 <vixey> ozy`, use a function
08:46:59 <vixey> @let (-->) = (,)
08:47:01 <lambdabot>  Defined.
08:47:12 <Tururu> Hello guys
08:47:12 <EvilTerran> ozy`, there was a suggestion to re-use case for that, too; "case | ... -> ... | ..."
08:47:20 <vixey> @let cond ((True, e):_) = e ; cond (_:cs) = cond cs
08:47:21 <lambdabot>  Defined.
08:48:00 <vixey> > let rev list = cond [ null list --> [], otherwise --> rev (tail list) ++ [ head list ] ] in rev "foo"
08:48:02 <lambdabot>   Couldn't match expected type `[a]'
08:48:08 <vixey> huh.....
08:48:21 <vixey> > let rev list = cond [ null list --> [], otherwise --> (rev (tail list) ++ [ head list ]) ] in rev "foo"
08:48:23 <lambdabot>   "oof"
08:48:26 <mriou> hi guys, is there a strict version of map somewhere?
08:48:46 <mauke> I hope not
08:49:08 <vixey> mriou, there's mapM
08:49:18 <vixey> which isn't a strict version of map, but it might be usable as such
08:49:23 <ozy`> vixey: well-played
08:49:27 <mriou> mauke: mmmh ok, why?
08:49:38 <mauke> depends on how much strictness you want
08:49:45 <pumpkin> need leather
08:49:48 <pumpkin> and ballgag
08:49:51 <Tururu> anybody knows if there is  a simple way to this: [(x,y) | x <- [1..2], y <- [1..4]] with an undefined number of lists?
08:49:59 <mriou> basically I do last . map foo
08:50:10 <rwbarton> > (,) <$> [1..2] <*> [1..4]
08:50:11 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4)]
08:50:28 <mauke> > transpose [[1..2],[1..4]]
08:50:29 <lambdabot>   [[1,1],[2,2],[3],[4]]
08:50:30 <mriou> but I want to have foo executed for all elements
08:50:30 <twanvl> > sequence [[1..2],[1..4]]
08:50:32 <lambdabot>   [[1,1],[1,2],[1,3],[1,4],[2,1],[2,2],[2,3],[2,4]]
08:50:35 <ozy`> mriou: couldn't you do... y'know.... foo . last?
08:50:39 <mriou> as it's  *meant* to have side effects
08:50:40 <pumpkin> Tururu: where you don't know the number of lists beforehand, nope, it isn't unless you can live with a list as output
08:50:48 <ozy`> mriou: if you're just throwing the values away..... what?
08:50:48 <rwbarton> mriou: there are no side effects
08:50:50 <rwbarton> mriou: only effects
08:50:53 <vixey> mriou, sounds like you could use mapM
08:51:12 <mriou> vixey: yeah, I think so too, thanks
08:51:13 <EvilTerran> coco, ozy`: here's the two proposals i mentioned: http://hackage.haskell.org/trac/haskell-prime/wiki/LambdaCase http://hackage.haskell.org/trac/haskell-prime/wiki/MultiWayIf
08:51:23 <rwbarton> mriou: strictness has nothing to do with executing effects at all.
08:51:25 <ozy`> mriou: the only place you'd get side effects is in a monad, and you wouldn't use plain map there anyway
08:51:30 <mriou> rwbarton: ok, effects then
08:51:34 <vixey> why is Haskell' taking proposals?
08:51:43 <koeien> because it isn't done =)
08:51:46 <mriou> yeah, I'm in IO and using IORef here and there
08:52:12 <pumpkin> omg epic mutability
08:52:15 * pumpkin hides
08:52:23 <Tururu> i could use a list of lists as the input but i don't know how to combine the elements then
08:52:45 <rwbarton> Tururu: sequence, like twanvl said
08:52:46 <mriou> pumpkin: oh yes but I don't think I have much choice, I'm implementing a small mutable language
08:52:56 <pumpkin> mriou: there's always choice!
08:52:58 <vixey> mriou, it's fine
08:53:37 <mriou> pumpkin: he he true enough, I've tried ST as well but it was much more verbose as I find myself a lot in IO anyway
08:53:59 <mriou> (think of print, readFile, write, ...)
08:54:02 <pumpkin> :)
08:54:23 <mriou> anyway, thanks everyone :)
08:54:26 <pejo> vixey, to avoid people from burning out during the standardization process.
08:54:54 <Tururu> oh, that was easy :), thank you guys
08:55:32 <EvilTerran> vixey, i interpret the haskell' trac and wiki as a place to discuss features that'd go well in any language inspired by haskell, regardless of whether it's meant to be a successor or not
08:55:37 <coco> when writing a function that updates a field in a record is there a shorter form than "\r -> r { a = x }"?
08:55:43 <EvilTerran> coco, no :(
08:55:46 <koeien> coco: no
08:56:08 <coco> in any other programming language? (just wondering if this could be expressed nicely)
08:56:09 <ozy`> mriou: IO actions never have any effect unless they actually get sequenced into the IO monad. so you can do "foo = putStrLn undefined" all over your file, and if foo is never actually put into a do block (whether directly or via a function that takes monad actions as arguments) it'll never get run
08:56:14 <EvilTerran> coco, although you could write one to do it
08:56:35 <EvilTerran> coco, and you could use functional references to achieve a similar result
08:56:38 <EvilTerran> ?where fref
08:56:38 <lambdabot> I know nothing about fref.
08:56:49 <EvilTerran> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
08:56:49 <ozy`> coco: that's one of the complaints we all have about haskell....
08:56:50 <coco> me either ;)
08:56:53 <vixey> coco, updateA r x
08:57:47 <vixey> or updateA x if you flip the arguments
08:57:50 <coco> vixey: what is updateA ?
08:58:01 <vixey> a function you can write
08:58:11 <vixey> which does \r -> r { a = x }
08:58:22 <mriou> ozy`: yes I understand that, sorry, my wording wasn't too accurate
08:58:43 <ozy`> mriou: no worries :p
09:01:24 <mriou> one question with IO btw, can running extensively in IO have negative performance impacts?
09:01:50 <mriou> say if I were to use ST instead for example
09:02:11 <mriou> or there are no real performance impacts to be expected?
09:03:05 <arw> if you can use pure code you should use it.
09:03:23 <vixey> mriou, no
09:03:49 <mriou> vixey: ok thanks
09:04:21 <mriou> arw: if in my code there are no benefit, then why?
09:04:34 <arw> there are some cases where you could parallelize your code for example.
09:04:54 <arw> or where the compiler can perform certain transformations.
09:05:06 * Heffalump concludes that unsafePerformIO'd name supplies are a dead loss
09:05:28 <vixey> And we all live happily ever after!
09:05:38 <mm_freak_> mriou: view "pure code" as non-IO code
09:05:53 <mriou> mm_freak_: understood
09:05:54 <mm_freak_> it doesn't mean you can't use all the advantages of monads =)
09:06:17 <arw> mriou: google for stream-fusion for example.
09:06:34 <mriou> arw: but if there are state changes, not being in IO won't really help
09:06:52 <Gracenotes> hm. so factor/forth is similar to reading reverse polish notation
09:06:55 <mm_freak_> mriou: there are better monads for pure state (i.e. non-world state)
09:07:10 <thoughtpolice> mriou: pure code is easier to factor and change - it also naturally has less external dependencies (inputs being *it*) and is more amenable to testing
09:07:15 <arw> mriou: pure code means that there won't be any state changes.
09:07:40 <arw> mriou: or at least no state changes which aren't explicitly encapsulated in some monad.
09:07:44 <thoughtpolice> I, like a lot of people, started writing haskell like I wrote C - everything was in the IO monad or something like it.
09:07:51 <thoughtpolice> however, the benefits of pure code have become apparent
09:07:56 <mm_freak_> mriou: IO is for world state, things like files, network, terminal, etc.
09:07:58 <thoughtpolice> what arw mentioned - stream fusion - is another good point.
09:08:14 <thoughtpolice> having pure functions allows the compiler to optimize things it otherwise couldn't
09:08:15 <mm_freak_> if your state is of pure nature (like a value), don't use IO, but rather something like State
09:08:54 <mriou> ok, I see, I may have to get back to ST then
09:09:04 <thoughtpolice> mriou: consider, for example - map f (map g xs)
09:09:05 <SamB_XP> ST is unneccessary
09:09:11 <SamB_XP> it's also a pain in the neck
09:09:16 * sw17ch struggles to get xmonad working
09:09:17 <EvilTerran> > runState (let loop = do { (i,is) <- get; when (i > 0) $ do { put (i-1,i:is); loop } } in loop) (10,0)
09:09:17 <mm_freak_> ST is one of the monads you'd rather like to avoid =)
09:09:18 <lambdabot>       No instance for (Num [t])
09:09:18 <lambdabot>        arising from the literal `0' at <inter...
09:09:22 <thoughtpolice> if f and g are both functions that say, read from a database, the order in which those functions are executed is important
09:09:23 <EvilTerran> > runState (let loop = do { (i,is) <- get; when (i > 0) $ do { put (i-1,i:is); loop } } in loop) (10,[])
09:09:24 <lambdabot>   ((),(0,[1,2,3,4,5,6,7,8,9,10]))
09:09:24 <mriou> SamB_XP: I've seen that
09:09:35 <mm_freak_> mriou: have a look at State
09:09:45 <mm_freak_> for most purposes it's completely sufficient
09:09:46 <thoughtpolice> the compiler cannot rewrite that expression without potentially changing program meaning
09:09:59 <EvilTerran> State is entirely pure haskell, too
09:10:02 <EvilTerran> ?src State
09:10:02 <lambdabot> Source not found. :(
09:10:04 <thoughtpolice> if otoh, f and g are pure, the compiler is free to do a rewrite of that expression - map (f . g) xs - this avoids building an intermediate list
09:10:06 <mriou> mm_freak_ I did but my state has many points of change
09:10:06 <EvilTerran> ...
09:10:11 <EvilTerran> , src 'State
09:10:24 <mm_freak_> mriou: there is nothing wrong with that
09:10:28 <lunabot>  newtype State s a = ... | State (s -> (a, s)) | ...
09:10:28 <lunabot>  infixl 9
09:10:29 <mriou> type WyEnv = IORef (S.Seq Frame)
09:10:36 <thoughtpolice> generally speaking it's just a good idea to keep as much code as possible out of a side-effectful world
09:10:38 <mriou> data Frame = Frame {
09:10:38 <mriou>     frameVars :: M.Map String (IORef WyType),
09:10:38 <mriou>     macroVars :: M.Map String (IORef WyType)
09:10:38 <mriou>   }
09:10:42 <EvilTerran> hm... of course, there's only one constructor, seeing as it's a newtype
09:10:46 <vixey> mriou, dos your language you implement actually do IO?
09:10:54 <SamB_XP> EvilTerran: I don't see how f and g being pure or not alters the validity of that transformation
09:10:58 <vixey> mriou, if not I go for ST instead of IO..
09:10:59 <SamB_XP> in a lazy language
09:11:02 <mm_freak_> data MyState = MyState { x :: Double, y :: Double, z :: Double }
09:11:15 <EvilTerran> SamB_XP, er, what?
09:11:17 <mriou> vixey: sure, read and write files, print stuff, read stuff from std in/out
09:11:22 <thoughtpolice> i think he meant me?
09:11:22 <vixey> ,ok
09:11:24 <lunabot>  luna: Not in scope: `ok'
09:11:25 <mm_freak_> and a compuatation may have the type State MyState () =)
09:11:25 <arw> SamB_XP: ordering of side-effects is important.
09:11:33 <SamB_XP> oh, oop
09:11:35 <SamB_XP> s
09:11:37 <EvilTerran> mm_freak_, btw, you can write that "data MyState = MyState { x, y, z :: Double }"
09:11:47 <SamB_XP> I can't tell you yellow folks apart it seems :-(
09:11:53 * EvilTerran is yellow?!
09:11:58 <EvilTerran> i look blue here
09:12:00 <Saya> Just wondering, is there an actors library in haskell?
09:12:10 <mm_freak_> EvilTerran: oh, thanks, good to know
09:12:15 <mm_freak_> (makes sense actually)
09:13:10 <mm_freak_> Saya: if you mean reactive programming, there is functional reactive programming, see the 'reactive' package
09:13:21 <Saizan_> ?hackage actor
09:13:22 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/actor
09:13:49 <Saya> i mean message passing concurrency abstractions but i guess reactive programming works the same way behind the scenes
09:14:02 <mm_freak_> see Saizan_ then
09:14:26 <mriou> so can one use State when you're going to store that state in, say, a list or map ?
09:14:38 <Saya> yup thx i should learn to use lambdabot
09:14:49 <Saya> (or google for that matter :))
09:14:58 <mm_freak_> Saya: or hackage ;)
09:15:16 <EvilTerran> mriou, yeah, the "s" in "State s a" can be any haskell type
09:15:19 <mm_freak_> mriou: you can use State for any kind of state
09:15:48 <mriou> EvilTerran, mm_freak_ ok thanks
09:15:55 <BrokenClockwork> hey, I have the following problem: I want to calculate something like (1234567^1234567) `mod` 9788111 whichs works in prelude fine, but when I implement it as a function in haskell: expo c d n = (c^d) `mod`  n it results in 0 !!
09:16:01 <mm_freak_> mriou: and if you have pure state to combine with some other monad (like IO), there is my favorite monad transformer StateT
09:16:13 <koeien> BrokenClockwork: check the types. is it 'Int' or 'Integer' ?
09:16:14 <mriou> any code example out there of State used to model some complex data structure?
09:16:15 <EvilTerran> mriou, if your state has different parts of different types, a tuple or record ADT would be more useful
09:16:38 <EvilTerran> "State (Int,String) a", say
09:16:41 <BrokenClockwork> it's Int
09:16:47 <koeien> BrokenClockwork: Int is finite precision
09:16:47 <BrokenClockwork> it's to weak I guess
09:16:55 <koeien> 'Integer' is what you want here
09:16:57 <EvilTerran> > maxBound :: Int
09:16:59 <lambdabot>   9223372036854775807
09:17:09 <BrokenClockwork> yeah, that's sure to little
09:17:11 <koeien> (also, you can do it way more efficient)
09:17:22 <BrokenClockwork> and, true...
09:17:24 <mm_freak_> for most people maxBound :: Int will be 2^31 - 1
09:17:34 <koeien> EvilTerran: depends on architecture
09:17:37 <BrokenClockwork> when I implement it more efficient Int should do it, too?
09:18:00 <mriou> EvilTerrean: I would have something like State(List(Map(String, State myType)))
09:18:07 <koeien> BrokenClockwork: if you can somehow guarantee that all your values are within the range, then Int is more efficient
09:18:38 <EvilTerran> mriou, you're storing monadic computations in your state?
09:18:42 <koeien> Integer frees you from thinking
09:18:58 <BrokenClockwork> :)
09:19:07 <mm_freak_> BrokenClockwork: really, just use Integer
09:19:09 <arw> BrokenClockwork: http://en.wikipedia.org/wiki/Modular_exponentiation there are some ways to do it in limited space.
09:19:18 <mriou> EvilTerran: yes, which is part of my pb
09:19:24 <koeien> BrokenClockwork: but (c `mod` n) * (d `mod` n) == (c*d) `mod` n, so you can optimize
09:19:25 <mm_freak_> the difference is totally neglible, and since GHC is optimized for Integer, in some cases, it's even faster than Int
09:19:41 <Heffalump> mm_freak_: huh? That sounds unlikely
09:19:45 <koeien> BrokenClockwork: (well, at least for c, d >= 0; don't know about negative c, d)
09:19:49 <mm_freak_> btw, if the Integer is suitably small, it's represented as a machine word anyway
09:19:58 <mm_freak_> Heffalump: it's my real world experience
09:19:59 <EvilTerran> mriou, ah, i see; you're going to need a data (or newtype) to express that recursion in the type, then
09:20:00 <Heffalump> it still needs a tag that has to be checked
09:20:02 <koeien> yes. you have a small CPU overhead, but it's probably not a problem
09:20:14 <mauke> :t fix . flip fmap (flip id) . flip fmap
09:20:15 <lambdabot> forall c (f :: * -> *). (Functor f) => f (f c -> c) -> f c
09:20:40 <mriou> EvilTerran: yes but then it becomes unwieldy
09:20:52 <koeien> the link by arw explains how to do PowerMod efficiently
09:21:13 <mriou> EvilTerran: I have an unbounded number of states in a map, what will be their type variables?
09:21:14 <mm_freak_> Heffalump: yeah, but the performance penalty from that check is neglible for most computations
09:21:33 <EvilTerran> "newtype MyState a = MyState (State [Map String (MyState (???))] a)"
09:21:51 <Heffalump> mm_freak_: sure, it's the suggestion that it could be *faster* that I find hard to believe
09:22:12 <EvilTerran> with -XNewtypeDeriving, you could stick a "deriving (Functor, Monad)" on that, too
09:22:26 <mm_freak_> Heffalump: i have observed just that…  probably GHC uses something better than Int internally for Integer
09:22:26 <mriou> the second MyState needs a type variable as well
09:22:30 <mm_freak_> @src Integer
09:22:31 <lambdabot> data Integer = S# Int#
09:22:31 <lambdabot>              | J# Int# ByteArray#
09:22:33 <jeltsch> -XGeneralizedNewtypeDeriving, it think.
09:22:42 <Heffalump> mm_freak_: hmm...what's better than Int?
09:22:48 <mm_freak_> Int# =P
09:22:53 <mauke> @src Int
09:22:53 <lambdabot> data Int = I# Int#
09:22:57 * vixey Integer is better than Int
09:23:04 <Heffalump> ...
09:23:16 <koeien> i don't see why, do you have an example?
09:23:29 <mm_freak_> still a data, not a newtype, so the internal representations may be different
09:23:45 <EvilTerran> mriou, yeah, that's what the (???) was for - i don't know what goes there
09:23:55 <Heffalump> I'd expect a single constructor data type to be better than the same datatype with an extra constructor added.
09:24:01 <mriou> EvilTerran: Frame a = Map String (State MyType a)
09:24:05 <EvilTerran> mriou, that'd be the return type of the actions you were storing in the map; the "a" in "IO a"
09:24:18 <Heffalump> and also for the Int to be much more susceptible to unboxing
09:24:22 <koeien> Heffalump: well. at least not slower
09:24:28 <Heffalump> koeien: yes, sure.
09:24:41 <Heffalump> I still can't see a single thing that could make Integer better than Int, weird cache effects and the like aside.
09:24:50 <mm_freak_> mriou: what are you trying to do actually?
09:24:51 <pumpkin> it's bigger
09:24:52 <mriou> EvilTerran: then Env a b = State (List Frame a) b
09:24:58 <Heffalump> s/better/faster/
09:25:01 <mriou> or sthing like that
09:25:02 <dnul__> how do i get more digits in ghc?
09:25:20 <koeien> dnul__: in floating point numbers?
09:25:24 <mm_freak_> Heffalump: i don't know, but i have observed many times Integer being faster than Int for small values
09:25:25 <mriou> mm_freak_ model a mutable programming language environment
09:25:33 <koeien> dnul__: you could take a look at Rational if you're using rational numbers
09:25:40 <dnul__> koeien: no , i get 4.2044754001e10
09:25:42 <BrokenClockwork> now I tried to go the easy way with Integer instead of Int, but now he complains about chr need Int as input, is there a work around?
09:25:42 <Heffalump> dnul__: cut and paste: 0123456789
09:25:47 <mriou> which is a mutable stack of frames
09:25:55 <mriou> a frame is a map of mutable values
09:25:57 <dnul__> Heffalump: hahah n1
09:26:01 <icqnumber> ?users
09:26:01 <lambdabot> Maximum users seen in #haskell: 623, currently: 615 (98.7%), active: 26 (4.2%)
09:26:12 <mm_freak_> BrokenClockwork: fromInteger
09:26:13 <mauke> BrokenClockwork: fromInteger
09:26:15 <koeien> BrokenClockwork: fromIntegeger
09:26:23 <koeien> s/gege/ge
09:27:04 <BrokenClockwork> heh thx :)
09:27:06 <mriou> mm_freak_: what I have now is http://haskell.pastebin.com/d37a3eb6e
09:27:11 <rwbarton> @type fromEnum
09:27:12 <lambdabot> forall a. (Enum a) => a -> Int
09:27:17 <koeien> BrokenClockwork: or, fromIntegral, if you watn to go the other way around
09:27:20 <maltem> dnul__: well if you get that number, you get it
09:27:31 <BrokenClockwork> ah that's it
09:28:04 <Tordek> in my main I want to do something like (map putStrLn strings), but I get an error about that being [IO a]; how can I do that?
09:28:12 <koeien> Tordek: mapM_
09:28:21 <koeien> it's the "monadic map"
09:28:23 <Tordek> thanks
09:28:34 <mauke> putStr (unlines strings)
09:28:34 <Botje> @hoogle sequence
09:28:35 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
09:28:35 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
09:28:35 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
09:28:47 <dnul__> maltem: you are right ... im sorry , that was a stupid question
09:28:49 <Tordek> awesome, thanks a lot
09:29:18 <mm_freak_> mriou: 'Frame' is a map of variables the program has access to?
09:30:31 <mriou> yeah
09:30:43 <mm_freak_> mriou: what do you need IORefs for?
09:30:52 <mriou> you can change the value of these variables
09:31:01 <mriou> m = 3; m = 4;
09:31:05 <mm_freak_> you can do that with State and Map just as well =)
09:31:37 <mriou> understood, my pb is having an inifinite number of states, like an infinite number of vars
09:32:14 <mm_freak_> theoretically, you mean?
09:32:18 <mm_freak_> like in a turing machine?
09:32:31 <mriou> mm_freak_: precisely
09:32:43 <koeien> dnul__: if you are using Float now, you can try using Double. that's more precise. but judging by the number of digits you already have that
09:32:55 <mm_freak_> there is nothing wrong with that…  as long as you don't add infinitely many variables to the map, it works well
09:33:18 <rwbarton> And you can't have infinitely many IORefs anyways.
09:33:26 <mriou> mm_freak_ yeah but you'll need a type variable for each State, right?
09:33:33 <koeien> you mean 'arbitrarily many'
09:33:38 <mm_freak_> no, why?
09:33:54 <mriou> koeien: yes, there's no practical infinite on a computer
09:34:23 <koeien> but, you can have a map of say Map Int String, and then have arbitrarily many elements in it
09:34:36 <mriou> State s a
09:34:47 <koeien> or, Map Int s. you have the requirement that eacch element of the map is of the same type though
09:34:48 <mriou> koeien yes
09:35:02 <mriou> mm_freak_ like State s String
09:35:16 <mm_freak_> mriou: say you want to write a function to change the value of a variable…  the type of that function should make things clear
09:35:20 <koeien> so if you have a lot of elements of the same type, that's not a problem: you can encode it by one type var
09:35:31 <mm_freak_> modifyWyVar :: String -> WyType -> State (Map String WyType) ()
09:35:34 <rwbarton> dnul__: in the numbers package on hackage, there is a CReal type for arbitrary-precision real numbers
09:35:48 <koeien> does that use gmp?
09:35:58 <rwbarton> CReal?  I think it's pure haskell
09:36:04 <opqdonut> it is
09:36:18 <koeien> ?hackage numbers
09:36:18 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
09:36:26 <rwbarton> So yes to the extent that it uses Integer :)
09:36:47 <EvilTerran> Integer's in the report, it's pure haskell :P
09:36:59 <rwbarton> Yes it uses gmp, I mean.
09:37:13 <koeien> :) that's not what i meant :)
09:37:28 <EvilTerran> it's got no dependencies beyond haskell, then
09:37:35 <mriou> mm_freak_ ok I'll give it a try and see what I get, thanks
09:37:36 <koeien> it seems pure haskell. that GHC uses gmp is an implementation detail of GHC
09:38:48 <mm_freak_> mriou: btw, it sounds like you're trying to write a language with dynamic typing, which is baaaaaaaad ;)
09:39:17 <koeien> @hoogle Dynamic
09:39:18 <lambdabot> module Data.Dynamic
09:39:18 <lambdabot> Data.Dynamic data Dynamic
09:39:18 <lambdabot> Data.Dynamic fromDynamic :: Typeable a => Dynamic -> Maybe a
09:39:43 <koeien> yes, haskell can do that too :) but i won't recommend it except for specific cases
09:40:04 <mm_freak_> i've never found a use for that
09:40:16 <EvilTerran> implementing a dynamically-typed language would be a use
09:40:52 <mm_freak_> you've got a type system expressive enough, so what's the advantage of Dynamic?
09:41:07 <koeien> that you can get it to compile
09:41:14 <koeien> and you can ship it, and fix the bugs later
09:41:16 <mauke> http://mauke.ath.cx/stuff/haskell/posi.hs
09:41:20 <dons> ?yow
09:41:20 <lambdabot> Xerox your lunch and file it under "sex offenders"!
09:41:29 <rwbarton> couldn't you just use data Value = MaybeItsAnInt Int | OrMaybeAString String | ... ?
09:41:41 <pumpkin> lol
09:41:46 <mm_freak_> rwbarton: that's my point
09:41:52 <gbacon> can Cabal instruct ghci how to load an executable (that uses FFI, the hangup I'm finding)?
09:42:19 <pumpkin> | OrMaybeAUserDefinedTypeWithEqualityTest (String -> String -> Bool)
09:42:38 <EvilTerran> mauke, positronic = back-in-time ST?
09:42:45 <pumpkin> maybe I should provide more than just an equality test
09:42:45 <dons> gbacon: there's no cabal ghci mode yet, no
09:42:59 <mm_freak_> | OrBottom (forall a. a)
09:43:07 <mauke> EvilTerran: yep
09:43:12 <EvilTerran> whee
09:43:33 <mauke> incidentally, Positronic.hs shows a way to implement differently typed state variables
09:43:42 <mauke> (disclaimer: slightly insane)
09:43:48 <EvilTerran> ah, it's pure code?
09:44:23 <gbacon> dons: when I use -L... and -l... to satisfy the linker, ghci complains about being unable to load hxt because of missing linkage to the network library
09:44:27 <mauke> EvilTerran: no unsafe*, no IO
09:45:09 <gbacon> dons: but I notice that it's pulling a different version of hxt than specified in my cabal file, so is it possible to instruct ghci as to which version of a package to load?
09:45:12 <mriou> mm_freak_: tell that to the ruby / python people :)
09:45:54 <mm_freak_> mriou: or almost any other non-haskell people
09:46:23 <mriou> right :)
09:46:41 <EvilTerran> mauke, ah, using Typeable for the differently-typed state vars
09:47:14 <mm_freak_> well, my main problem with other languages is the lack of curried style
09:47:22 <bremner> http://googlefight.com/index.php?lang=en_GB&word1=static+typing+is+annoying&word2=dynamic+typing+is+dangerous
09:47:57 <Provenzano> hi, I have a problem in ghci. I have made a haskell game, and on ghci in linux mint/ubuntu it works correctly, but when I try to open it on ghci @ windows I can't use it :| main menu appears, but I can't advance
09:48:05 <Provenzano> can someone help me?
09:48:18 <mm_freak_> if i could write 'fix' in python, it would make the language much more useful (although no average python programmer would be able to understand my code anymore) =)
09:48:19 <EvilTerran> Provenzano, does it work with runghc?
09:48:36 <Provenzano> I don't try. I will search
09:49:42 <Provenzano> runghc [runghc flags] [GHC flags] module [program args]
09:49:43 <mauke> def fix(f): return lambda x: f(fix(f), x)
09:49:56 <gbacon> mm_freak_: feature :-)
09:50:01 <Provenzano> can you help me EvilTerran?
09:50:03 <mm_freak_> mauke: what if f takes more parameters?
09:50:19 <FunctorSalad> then haskell fix doesn't work either :[
09:50:24 <mm_freak_> mauke: you need separate versions fix1, fix2, … fixn
09:50:27 <FunctorSalad> err, I meant :p not :[
09:50:39 <mm_freak_> FunctorSalad: it does =)
09:50:58 <FunctorSalad> hmm?
09:51:02 <FunctorSalad> @src fix
09:51:03 <lambdabot> fix f = let x = f x in x
09:51:03 <mm_freak_> > fix (\r x y -> x : r y (x+y)) 0 1
09:51:05 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
09:51:12 <mauke> how do I vararg'd in python
09:51:16 <mm_freak_> thanks to currying =)
09:51:25 <mm_freak_> mauke: you don't with lambdas
09:51:31 <mauke> suk
09:51:48 <vixey> use a list of parameters
09:51:55 <rwbarton> fix(lambda r: lambda (x, y): ...)(0, 1)
09:52:11 <mm_freak_> vixey: the non-list variant of fix is ugly enough in python ;)
09:52:19 <FunctorSalad> mm_freak_: I was thinking you wanted the x to be (r,x,y)
09:52:31 <mauke> sub fix (&) { my ($f) = @_; sub { $f->(&fix($f), @_) } }
09:53:01 <rwbarton> mauke: you seem to have accidentally gotten some letters in that perl code :P
09:53:13 <vixey> ol
09:53:15 <FunctorSalad> mm_freak_: hmm wait
09:53:34 <mm_freak_> FunctorSalad: i could use some sort of list/tuple, but that makes it quite inconvenient in python
09:54:02 <mauke> rwbarton: meh
09:54:16 <mauke> at least it works (for any number of arguments)
09:55:01 <nj32> Is Yi editor available as .deb binary?
09:55:24 <koeien> no, not that i know of
09:56:08 <nj32> koeien: i tried from source, ran into some dependency errors: regex-base, regex-compat, regex-posix
09:56:47 <maltem> nj32: what's the nature of those errors?
09:56:54 <koeien> nj32: you can install them from the repos (debian testing at least)
09:57:00 <FunctorSalad> mm_freak_: I mean, fix (f :: a -> b) disregards any "->" in b. you could define the partially applied f in python too, no?
09:57:40 <ttt--_> nj32, have you tried to caball install it?
09:57:41 <nj32> koeien: ubuntu 8.10 here. Which debian repo?
09:57:42 <mm_freak_> FunctorSalad: no, you can return a lambda, but you must encode all arguments in it
09:57:49 <thoughtpolice> rwbarton: readable to me :)
09:57:55 <koeien> nj32: official debian
09:58:06 <nj32> koeien: ok, i'll try it
09:58:08 <opqdonut> well one can emulate curried functions in python
09:58:09 <koeien> nj32: libghc6-regex-base-dev for example
09:58:16 <FunctorSalad> def f'(r) = return lambda x y: f(r,x,y)
09:58:19 <opqdonut> by making them objects with a __call__ that fills the params one by one
09:58:21 <koeien> nj32: i would recommend strongly against enabling official debian repos in ubuntu
09:58:23 <nj32> koeien: i installed that, but did not help
09:58:26 <mm_freak_> lambda x: … is a function of exactly one argument…  it can return a lambda again, but since you have no curried syntax you need extra parenthesis
09:58:27 <FunctorSalad> (that probably isn't actual python syntax)
09:58:45 <mm_freak_> that's the main problem
09:59:07 <koeien> nj32: 'cabal install yi' does not work for you?
09:59:12 <FunctorSalad> hmm yeah sounds a bit verbose
09:59:12 <maltem> nj32: again, what are the errors?
09:59:18 <skorpan> @users
09:59:18 <lambdabot> Maximum users seen in #haskell: 624, currently: 624 (100.0%), active: 23 (3.7%)
09:59:20 <nj32> maltem: http://hpaste.org/13578
09:59:21 <koeien> nj32: if so, what are the errors?
09:59:25 <mm_freak_> it's not verbose, but limiting
09:59:25 <skorpan> it just keeps growing...
09:59:42 <nj32> koeien: did not try
09:59:43 <mm_freak_> it forces you to write a version of fix for each number of arguments
09:59:47 <koeien> nj32: this is from 'runghc Setup.hs configure' ?
09:59:56 <nj32> koeien: yes
09:59:59 <koeien> ?hackage regex
09:59:59 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regex
10:00:11 <nj32> ttt--_: no
10:00:25 <FunctorSalad> mm_freak_: or of "curry"...
10:00:29 <maltem> nj32: looks to me like you have some very old version of yi
10:00:38 <coco> are wildcards not allowed in type signatures?
10:00:41 <coco> (+) 1 :: Int -> _
10:00:42 <nj32> maltem: 0.3
10:00:44 <mm_freak_> FunctorSalad: that's nothing special, since you need to do that in haskell, too =)
10:00:48 <Saizan_> coco: no
10:00:49 <koeien> coco: no
10:01:05 <mm_freak_> > curry3 (\x y z -> x + y + z) (1,2,3)
10:01:07 <lambdabot>   Not in scope: `curry3'
10:01:07 <maltem> nj32: Yeah they have 0.5.2 now
10:01:08 <coco> Saizan_, koeien: isn't this bad? :)
10:01:11 <nj32> used steps from here: http://www.nobugs.org/developer/yi/
10:01:15 <mm_freak_> uhm
10:01:20 <mm_freak_> > uncurry3 (\x y z -> x + y + z) (1,2,3)
10:01:21 <lambdabot>   Not in scope: `uncurry3'
10:01:22 <nj32> maltem: ok, i'll try that
10:01:29 <pumpkin> coco: and in that case (+) is a -> a -> a, so if you forced one side to be Int, the other would be too (it's normall Num =>)
10:01:50 <mm_freak_> :t uncurry
10:01:51 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
10:02:04 <mm_freak_> where's uncurry3?!
10:02:10 <koeien> coco: no, this is not bad
10:02:18 <vixey> @let uncurry3 f (x,y,z) = f x y z
10:02:19 <lambdabot>  Defined.
10:02:22 <koeien> coco: you cannot give partial type sigs
10:02:23 <coco> pumpkin: that's precisely why I want to write it only once
10:02:29 <mm_freak_> > uncurry3 (\x y z -> x + y + z) (1,2,3)
10:02:30 <lambdabot>   6
10:02:47 <coco> koeien: in ML you can, if the wildcards are inferable in the way pumpkin pointed out
10:02:47 <Saizan_> coco: (+) (1::Int)
10:02:52 <maltem> nj32: actually, 'cabal install yi' should work
10:02:54 <koeien> > (+) (1:: Int)
10:02:56 <lambdabot>       Overlapping instances for Show (Int -> Int)
10:02:56 <lambdabot>        arising from a use o...
10:02:59 <pumpkin> coco: oh, you want it to infer the other one? you can just write (+) (1::Int)
10:03:04 <pumpkin> oh wow, I was third
10:03:04 <nj32> maltem: where can i get that package?
10:03:08 <FunctorSalad> mm_freak_: I meant, if you have curry then you have the fix for function of multiple args
10:03:10 <coco> Saizan_: thanks, but it was just an example
10:03:29 <pumpkin> coco: you can do that in general though
10:03:29 <maltem> nj32: <maltem> nj32: actually, 'cabal install yi' should work
10:03:41 <koeien> but this is the general idea. you cannot give partial type sigs. (i'm only vaguely familiar with ML)
10:03:53 <coco> Saizan_, pumkin: new example: (+) :: Int -> _ -> _
10:03:56 <mm_freak_> FunctorSalad: let's say arbitrarily many args =)
10:04:00 <koeien> you can always specialize the arguments of the types
10:04:03 <maltem> nj32: given you do have cabal-install, of course :)
10:04:12 <koeien> s/the types/the function
10:04:29 <Saizan_> coco: yeah, wildcards in types seems useful, but probably not so much since noone has spent time implementing them
10:04:36 <koeien> nj32: in case you do not, it's worth the time to install it
10:04:50 <pumpkin> coco: so you'd do that to save yourself the effort of typing?
10:04:51 <nj32> maltem: i am installing cabal now
10:04:56 <nj32> koeien: ^
10:05:01 <pumpkin> or because you want it more general than Int?
10:05:02 <Saizan_> coco: the point of my example was that you can often achieve the same effect without them
10:05:21 <coco> pumpkin: to save the effort
10:05:33 <coco> pumpkin: what do you mean by "more general than Int"?
10:05:48 <pumpkin> coco: like, somehow retain the Num a => a -> a for the other two
10:05:49 <koeien> coco: (Num a) => a
10:06:10 <coco> Saizan_: thanks, but with "(+) :: Int -> _ -> _" you can't, can you?
10:06:25 <pumpkin> coco: nope
10:06:27 <rwbarton> coco: If you're going to bother to write a type signature, you might as well spare your reader some trouble and do it properly :)
10:06:28 <koeien> coco: no. this is impossible.
10:06:39 <pumpkin> I remember someone saying there was a proposal somewhere for that, I think
10:06:48 <coco> pumkin: no, that was not my intention (and it seems much fancier)
10:07:02 <rwbarton> Yeah, I have seen a proposal for wildcards in type signatures somewhere
10:07:12 <vixey> it would be very useful to allow partial signatures
10:07:17 <koeien> i think it only obscures, but that's just me
10:07:42 <pumpkin> for big complex ones, I agree it can be painful to figure it out yourself
10:07:52 <pumpkin> when you only want to make sure that a certain thing is a certain type
10:08:12 <koeien> yes, but then it's clearer just to put the type near the part you want to specialize
10:08:14 <pumpkin> but you can generally just make the function more pointful and add a :: inside the definition
10:08:23 <koeien> i.e. (undefined :: Int)
10:08:25 <pumpkin> koeien: that's fine unless you do point-free
10:08:39 <koeien> ok. true
10:08:46 <ttt--_> http://hackage.haskell.org/trac/haskell-prime/wiki/PartialTypeAnnotations
10:08:58 <pumpkin> I guess one of your composed functions could say what types it wanted (completely)
10:09:06 <pumpkin> and the others would be appropriately constrained
10:09:12 <rwbarton> you can always write some junk like (+) `asTypeOf` (\(x::Int) -> undefined)  (with the extension for type signatures in patterns)
10:09:14 <koeien> pumpkin: yes, but that's more obscure than this proposal
10:09:18 <pumpkin> :) yup
10:09:42 <vixey> rwbarton, oh nice ideaaa
10:09:43 <koeien> you can probably get away with letting ghci infer the type
10:09:58 <ridley> unrelated to current discussion: Can anyone tell me what "$=" is?
10:10:24 <Saizan_> it's an operator from HOpenGl
10:10:29 <Saizan_> probably
10:10:32 <ridley> ok. Figures.
10:10:33 <rwbarton> vixey: Really?  I think it's terrible :) but I guess it could get you out of certain kinds of jams.
10:10:33 <ridley> Thank you
10:10:52 <vixey> anything to avoid those horrible jams
10:11:52 <Saya> Hey, maybe i'm blind but i can't seem to find a function to wait for a thread to end inside the IO monad :s
10:12:05 <Saizan_> Saya: there isn't one
10:12:21 <rwbarton> Saya: You could use an MVar
10:12:24 <koeien> Saizan_: you can pass the thread an MVar, and then wait for it to be filled
10:12:31 <Saizan_> koeien: true
10:12:34 <koeien> ehm to Saya
10:13:32 <Saya> thanks :) why not make a function for it? is it something i should avoid?
10:14:09 * Provenzano is now away, auto away after 15mins idle (log\on pager\on)
10:14:15 <koeien> i don't see any reason to avoid it, and i don't know why there isn't a function for it
10:14:38 <SamB_XP> Provenzano: please, turn that thing off!
10:14:48 <Provenzano> oh. sorry :|
10:15:02 <SamB_XP> what do you suppose would happen if a tenth of the channel had that on ?
10:15:22 * Provenzano has returned from auto away after 15mins idle, was gone for 1min 13secs
10:15:34 <vixey> Provenzano: ok ??
10:15:37 <Provenzano> it has been disabled SamB_XP ;)
10:15:41 <SamB_XP> it's okay, it's just that I think it'd get annoying after a while ;-P
10:19:54 <icqnumber> ?users
10:20:11 <lambdabot> Maximum users seen in #haskell: 628, currently: 628 (100.0%), active: 23 (3.7%)
10:20:12 <Botje> woah
10:20:34 <Botje> will we get 1000 people by 2010?
10:20:40 <int80_h> you betcha
10:20:41 * shapr boings
10:20:46 <shapr> 628! wow!
10:20:57 <int80_h> lemmih: you awake?
10:21:04 <Olathe> With the new book, probably.
10:21:09 <shapr> Yay!
10:22:25 <Olathe> @faq Will we get 1000 people by 2010 ?
10:22:25 <lambdabot> The answer is: Yes! Haskell can do that.
10:22:43 <Olathe> There we go !
10:23:16 <int80_h> @faq Can Haskell chew bubblegum and walk, at the same time?
10:23:16 <lambdabot> The answer is: Yes! Haskell can do that.
10:23:22 <FunctorSalad> if I run ghci from the terminal, it has nice auto-completion... how do I get that in haskell-mode inferior-haskell?
10:23:23 <int80_h> wow...I'm impressed.
10:23:30 <Olathe> It has multithreading to deal with that.
10:23:44 <koeien> @faq Can a haskell program solve the halting problem?
10:23:44 <lambdabot> The answer is: Yes! Haskell can do that.
10:23:50 <koeien> hmmmm
10:23:53 <Botje> FunctorSalad: slime mode has C-c tab for that
10:24:06 <Botje> perhaps it works for haskell too
10:24:28 <vixey> koeien, halting problem is semi-decideable :P
10:24:48 <vixey> hm I think that is a lie
10:25:45 <int-e> sure, you can enumerate all halting programs.
10:26:20 <wabash> Happy new year, everyone.
10:26:27 <wabash> I have a silly newbie question again3.
10:26:33 <FunctorSalad> someone rewrite @faq to recognize "halting problem" and so on
10:26:34 <int80_h> happy new year!
10:26:34 <wabash> Does Haskell have a GC?
10:26:39 <koeien> wabash: yes!
10:26:39 <Botje> ye
10:26:52 <int80_h> what's a GC?
10:26:56 <koeien> int80_h: garbage collector
10:26:59 <Olathe> @faq Can Haskell collect garbage ?
10:27:00 <lambdabot> The answer is: Yes! Haskell can do that.
10:27:04 <int80_h> oooh
10:27:11 <Botje> @vixen clean up my room!
10:27:17 <int80_h> @faq Can Haskell take out my garbage?
10:27:21 <lambdabot> hey, what's in a jack and coke anyhow?
10:27:21 <FunctorSalad> Botje: C-C tab is undefined in inferior-haskell :(
10:27:24 <wabash> Ok. I'm a bit confused, though. With Pure code, do you even need a GC?
10:27:25 <lambdabot> The answer is: Yes! Haskell can do that.
10:27:28 <FunctorSalad> thanks for the suggestion thougjh
10:27:32 <Olathe> wabash: Sure.
10:27:33 <koeien> wabash: yes
10:27:42 <koeien> wabash: suppose i write down product [1..37]
10:27:45 <wabash> ok,
10:27:53 <koeien> wabash: then the list, after the result is computed, will need to be GC'd
10:28:09 <wabash> Because you are passing as parameter and it's not assigned to anything?
10:28:31 <koeien> right, there is no reference to the list node anymore after it's evaluated
10:28:36 <wabash> ok.
10:29:00 <wabash> Why would you need a separate GC?
10:29:00 <wabash> Would n't cases like this just be part of the language, i.e. "just throw it away because you know you're done"
10:29:08 <koeien> but there is also a GC for non-pure code (i.e. IO code)
10:29:26 <wabash> koeien: Yes, that's what I expected to be more the use of GC.
10:29:30 <wabash> Monads and stuff.
10:29:31 <koeien> wabash: you can get more subtle problems, let f x = (x, (+1) x)
10:29:37 <Olathe> wabash: There might be a lot of intermediate stuff before you're done.
10:29:48 <koeien> wabash: things might be referenced more than once
10:29:52 <Olathe> wabash: So, if you don't clear it out every once in a while, your memory can be filled.
10:29:55 <wabash> koeien: I expected that CG would be a separate entity for assignment and monads.
10:30:03 <sjanssen> wabash: "just throw it away because you know you're done" is almost the definition of garbage collection :)
10:30:10 <koeien> monads are just sugar for pure code
10:30:12 <wabash> But for pure code, wouldn't it behave just like a stack, and be popped off anyway?
10:30:21 <mauke> wabash: no
10:30:22 <koeien> wabash: no
10:30:28 <mauke> why would it be a stack?
10:30:46 <wabash> sjanssen: Yes! Well, I was drawing a distinction between GC as it's own thread like in Java, and automatic memory management like in a stack.
10:30:54 <sjanssen> wabash: nah, lots of stuff is allocated on the heap, because the object's size and lifetime isn't known statically
10:31:08 <wabash> mauke: not "be a stack". "behave just like a stack"
10:31:16 <wabash> sjanssen: I see.
10:31:27 <mauke> wabash: yeah, why would it behave like a stack?
10:31:28 <wabash> But is the GC still a separate thing that runs periodically?
10:31:31 <koeien> you really need a full blown GC
10:31:38 <koeien> wabash: yes, it's even multithreaded now :)
10:31:42 <wabash> ok, I'll take your word for it.
10:31:54 <wabash> So in Haskell, does the GC run every once in a while?
10:31:57 <sjanssen> wabash: basically all the same challenges of garbage collection in Java exist for garbage collection in Haskell
10:32:07 <Olathe> wabash: It does.
10:32:23 <wabash> Does performance take a hit when it runs?
10:32:24 <sjanssen> wabash: that's sort of an implementation detail, but yes the GC runs periodically
10:32:37 <koeien> wabash: you can give some RTS-options to your program and see some statistics re GC
10:32:42 <wabash> ok.
10:32:44 * vixey doesn't think haskell actually has a GC
10:32:46 <sjanssen> wabash: naturally it takes some time to collect the garbage, yes
10:32:56 <sjanssen> but GHC is pretty good about this
10:33:00 <wabash> can you call the GC, rather, suggest the GC, as in Java?
10:33:05 <koeien> the performance hit is there and it's real, but mostly negilible
10:33:33 <sjanssen> wabash: not part of the Haskell standard, but yes: System.Mem.performGc
10:33:39 <koeien> wabash: it would be in a GHC API
10:34:00 <SamB_XP> and it apparantly can take less time than calling free()
10:34:23 <koeien> SamB_XP: there are some cases where that is actually true, yes. but in practice, no
10:34:39 <SamB_XP> koeien: what makes you say that ?
10:34:48 <koeien> what part? :)
10:34:51 <SamB_XP> free() has to be called on every piece of garbage ...
10:34:51 <sjanssen> koeien: there are plenty of real cases where garbage collection wins
10:35:03 <koeien> okay. then my impression is wrong
10:35:06 <SamB_XP> GC only has to collect the live memory ;-P
10:35:16 <mauke> I think the important part is that it's faster than malloc()
10:35:19 <SamB_XP> (it's kind of a misnomer, I guess ;-P)
10:35:28 <Olathe> It can reuse the memory without freeing if it wants.
10:35:34 <wabash> mauke: in regards to why I compared it to a stack: I was thinking that calling pure functions, maybe in a tree-like way or in a recursive way, might generate objects and use space, but since it's pure, you would know at return time that all the stuff in the middle is not needed any more, and could just be cleared then without an extra call to GC. This is just like static allocation in C, for example, where nothing needs to be "Fr
10:35:51 <mauke> wabash: ah, but you don't know that
10:35:59 <wabash> don't know what?
10:36:02 <mauke> wabash: functions can return values that include references to other stuff
10:36:05 <Poophole> 	how long should i wait for anal here?
10:36:10 <Olathe> wabash: There are some functions a compiler could figure that out for and make that happen.
10:36:12 --- mode: ChanServ set +o mauke
10:36:15 --- kick: Poophole was kicked by mauke (mauke)
10:36:15 --- mode: mauke set +b *!*i=opera@*.access.telenet.be
10:36:29 --- mode: mauke set -o mauke
10:36:32 <Olathe> wabash: I'm not sure if ghc does that or not.
10:36:45 <wabash> Olathe: Yes, that's exactly what I'm thinking. mauke: good point. I didn't consider that.
10:36:57 <wabash> So it could be an optomization for certain cases.
10:37:02 <Olathe> Sure.
10:37:04 <wabash> But only fore certain cases.
10:37:08 <koeien> yes, but in general: no
10:37:09 <mauke> wabash: even better, values can reference themselves :-)
10:37:11 <wabash> Thanks, guys ad gals.
10:37:26 <rwbarton> Because of lazy evaluation, every function returns a value which includes references to other stuff, in some sense.
10:37:26 <Olathe> You're welcome.
10:37:36 <mauke> > let a = 1:b; b = 2:a in a
10:37:38 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
10:37:45 <mauke> > let a = 1:b; b = 2:a in b
10:37:47 <lambdabot>   [2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,...
10:38:18 <wabash> Just to say out loud, I really like the Haskell community so far. I'm able to ask pretty abstract high level questions, and you people and bots do a great job of answering, and I can build my understanding.
10:38:42 <wabash> mauke: How do you get lambdabot to evaluate stuff for you?
10:38:47 <mauke> wabash: "> "
10:38:48 <asgaroth> wabash: > code
10:38:49 <koeien> wabash: with '> '
10:38:51 <Botje> > "say hi"
10:38:53 <lambdabot>   "say hi"
10:38:56 <koeien> > print 37
10:38:57 <lambdabot>   * Exception: "<IO ()>"
10:38:58 <wabash> ok, thanks.
10:38:59 <Olathe> > say "hi"
10:39:00 <lambdabot>   Not in scope: `say'
10:39:03 <Olathe> Bah.
10:39:05 <lucca> > fix cycle
10:39:06 <not_much> how do you look up source?
10:39:07 <lambdabot>   * Exception: stack overflow
10:39:11 <koeien> @src print
10:39:11 <lambdabot> print x = putStrLn (show x)
10:39:22 <not_much> @source permutations
10:39:22 <lambdabot> permutations not available
10:39:23 <Olathe> > say "hi"
10:39:25 <lambdabot>   mueval: Prelude.read: no parse
10:39:25 <lambdabot>  mueval: GhcException mkTopLevEnv: not a hom...
10:39:29 <Olathe> No parse ?
10:39:40 <koeien> :t say
10:39:42 <lambdabot> String -> Expr
10:39:47 <Olathe> > say "parse"
10:39:47 <Gilly> not_much: :D i was just looking for the same source :P
10:39:48 <lambdabot>   parse
10:39:54 <not_much> @source Data.List.permutations
10:39:54 <lambdabot> Data.List.permutations not available
10:39:54 <koeien> > say "\"hi\""
10:39:55 <lambdabot>   "hi"
10:39:58 <Olathe> > say "Hello !"
10:39:59 <lambdabot>   Hello !
10:40:02 <Gilly> appareantly lambdabot doesn't have it yet (I think it was a recent addition to Data.List)
10:40:34 <Olathe> > quietIf even 2
10:40:38 <Olathe> > quietIf even 1
10:40:40 <lambdabot>   1
10:41:08 <ttt--_> > say $ "Hello" ++ fail "world"
10:41:10 <lambdabot>   Hello
10:41:11 <not_much> ok, I actually need to generalize permutations to lists containing identical elements
10:41:20 <not_much> does anyone have an idea?
10:41:29 <Olathe> You mean like [1,1..] ?
10:41:33 <not_much> yes
10:41:49 <not_much> [1,1,1,2] should just give 4 arrangements
10:41:53 <Olathe> I suppose you could use nub.
10:42:00 <Olathe> As a quick fix.
10:42:12 <SamB_XP> > [1.1..]
10:42:12 <lambdabot>   [1.1,2.1,3.1,4.1,5.1,6.1,7.1,8.1,9.1,10.1,11.1,12.1,13.1,14.1,15.1,16.1,17....
10:42:12 <Olathe> Or group and some magic.
10:42:17 <Raevel> not_much: can't you just remove dupes first?
10:42:30 <SamB_XP> > [1,1..]
10:42:34 <Olathe> > group [1,1,1,4]
10:42:34 <koeien> nub . permutations should work
10:42:37 <lambdabot>   [[1,1,1],[4]]
10:42:37 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
10:42:39 <SamB_XP> lambdabot: don't you know that IEEE can't represent most decimal fractions exactly?
10:42:45 <not_much> I'll just try nub and see how long it takes
10:43:03 <Gilly> well, nubbing isn't very efficient
10:43:14 <Olathe> No, it isn't.
10:44:23 <koeien> if you remove dupes first, you will lose some information
10:44:33 <Olathe> I suppose you could check if you're swapping something with itself and drop the rest of the computation.
10:44:33 <koeien> but premature optimization is the root of all evil
10:45:27 <not_much> no, the dupes are important. I'm solving a puzzle and some of the pieces are identical, but all are required..
10:45:53 <not_much> is there a way to time a command in ghci?
10:45:56 <koeien> you could look up the source of permutations, and redo it yourself
10:46:10 <koeien> not_much: :set +s
10:46:45 <not_much> thanks koeien!
10:47:02 <Olathe> > liftM2 (,) length head.group.sort $ [1,1,4,1]
10:47:04 <lambdabot>   (2,[1,1,1])
10:47:06 <bremner> I have a string "---0\n   |\n   +---1\n"   (representing a tree). How do I convince ghci to print it "nicely"?
10:47:10 <Olathe> Hmm...
10:47:14 <mauke> putStr
10:47:14 <koeien> bremner: putStrLn
10:47:16 <Olathe> > map (liftM2 (,) length head).group.sort $ [1,1,4,1]
10:47:16 <icqn> > tail "list"
10:47:17 <lambdabot>   [(3,1),(1,4)]
10:47:17 <lambdabot>   "ist"
10:47:47 <not_much> I found a compact list comprehension for permutations, and I understand it, but I'm kind of new to haskell and it isn't obvious to me how to "redo" it to handle duplicates efficiently
10:47:52 <icqn> > head "list"
10:47:53 <lambdabot>   'l'
10:47:57 <bremner> koeien: thanks!  I guess I need to read chapter 7 of RWH :-)
10:48:12 <Olathe> Let's see.
10:48:18 <mauke> > (head &&& tail) "list"
10:48:19 <not_much> perms [] = [[]]
10:48:19 <not_much> perms xs = [ x : ps | x <- xs, ps <- perms (xs\\[x]) ]
10:48:19 <lambdabot>   ('l',"ist")
10:48:41 <Olathe> > perms xs = map (liftM2 (,) length head).group.sort $ xs in perms [1,1,4,1]
10:48:42 <lambdabot>   <no location info>: parse error on input `='
10:48:45 <Olathe> > let perms xs = map (liftM2 (,) length head).group.sort $ xs in perms [1,1,4,1]
10:48:47 <lambdabot>   [(3,1),(1,4)]
10:49:42 <rwbarton> > let perms xs = [ x : ps | x <- nub xs, ps <- perms (xs\\[x]) ] in perms [1,1,4,1]
10:49:45 <lambdabot>   []
10:49:52 <rwbarton> > let perms [] = [[]]; perms xs = [ x : ps | x <- nub xs, ps <- perms (xs\\[x]) ] in perms [1,1,4,1]
10:49:53 <lambdabot>   [[1,1,4,1],[1,1,1,4],[1,4,1,1],[4,1,1,1]]
10:51:37 <not_much> > let perms [] = [[]]; perms xs = [ x : ps | x <- nub xs, ps <- perms (xs\\[x]) ] in perms [1,1,2,2,4]
10:51:38 <lambdabot>   [[1,1,2,2,4],[1,1,2,4,2],[1,1,4,2,2],[1,2,1,2,4],[1,2,1,4,2],[1,2,2,1,4],[1...
10:52:10 <not_much> > let perms [] = [[]]; perms xs = [ x : ps | x <- nub xs, ps <- perms (xs\\[x]) ] in length (perms [1,1,2,2,4])
10:52:11 <lambdabot>   30
10:52:29 <twanvl> > let perms [] = [[]]; perms xs = [ x:zs | ((n,x),ys) <- pick xs, zs <- perms (if n == 1 then ys else (n-1,x):ys) ]; pick [] = []; pick (x:xs) = (x,xs) : map (second (x:)) (pick xs) in perms [(3,1),(1,4)]
10:52:31 <lambdabot>   [[1,1,1,4],[1,1,4,1],[1,4,1,1],[4,1,1,1]]
10:52:46 <Olathe> > let perms xs = perms'.map (liftM2 (,) length head).group.sort $ xs where perms' nxs = concatMap (\(n, x) -> x:perms' (dec x nxs)) nxs; dec x' ((n,x):qs) = if x == x' then if n == 1 then qs else (n - 1,x) else (n,x):dec x' qs in perms [1,1,4,1]
10:52:46 <koeien> what's wrong with rwbarton's version? :)
10:52:47 <lambdabot>   Couldn't match expected type `[(t, t1)]'
10:53:01 <Olathe> > let perms xs = perms'.map (liftM2 (,) length head).group.sort $ xs where perms' nxs = concatMap (\(n, x) -> x:perms' (dec x nxs)) nxs; dec x' ((n,x):qs) = if x == x' then if n == 1 then qs else (n-1,x):qs else (n,x):dec x' qs in perms [1,1,4,1]
10:53:02 <not_much> thanks! Now I'll have to think about why that works for awhile  :)
10:53:03 <lambdabot>   [1,1,1,4,4,1,4,1,1,4,1,1,1]
10:53:24 <Olathe> Bah.
10:53:41 <not_much> ... and stop my ongoing nub calculation.. :)
10:54:21 <not_much> rwbarton: thanks!
10:54:22 <Gilly> perms [] = [[]]
10:54:22 <Gilly> perms xs = concat [map (x:) (perms (xs \\ [x]))| x <- xs]
10:54:53 <Gilly> oh, seems i'm late anyways :P
10:55:01 <Olathe> > let perms xs = perms' [].map (liftM2 (,) length head).group.sort $ xs where perms' xs nxs = concatMap (\(n, x) -> perms' (x:xs) (dec x nxs)) nxs; dec x' ((n,x):qs) = if x == x' then if n == 1 then qs else (n-1,x):qs else (n,x):dec x' qs in perms [1,1,4,1]
10:55:02 <lambdabot>   []
10:55:21 <Olathe> > let perms xs = perms' [].map (liftM2 (,) length head).group.sort $ xs where perms' xs [] = xs; perms' xs nxs = concatMap (\(n, x) -> perms' (x:xs) (dec x nxs)) nxs; dec x' ((n,x):qs) = if x == x' then if n == 1 then qs else (n-1,x):qs else (n,x):dec x' qs in perms [1,1,4,1]
10:55:23 <lambdabot>   [4,1,1,1,1,4,1,1,1,1,4,1,1,1,1,4]
10:55:31 <Gilly> (mine was for ordinary permutations)
10:55:34 <Olathe> Now to separate that.
10:55:46 <FunctorSalad_> @type formListWith
10:55:47 <sheyll> hi
10:55:48 <lambdabot> Not in scope: `formListWith'
10:55:51 <FunctorSalad_> @type fromListWith
10:55:52 <Olathe> > let perms xs = perms' [].map (liftM2 (,) length head).group.sort $ xs where perms' xs [] = xs; perms' xs nxs = map (\(n, x) -> perms' (x:xs) (dec x nxs)) nxs; dec x' ((n,x):qs) = if x == x' then if n == 1 then qs else (n-1,x):qs else (n,x):dec x' qs in perms [1,1,4,1]
10:55:53 <lambdabot> Not in scope: `fromListWith'
10:55:55 <lambdabot>       Occurs check: cannot construct the infinite type: t = [t]
10:55:55 <lambdabot>        Expect...
10:56:00 <sheyll> what the heck is a type class homomorphism?
10:56:18 <Olathe> > let perms xs = perms' [].map (liftM2 (,) length head).group.sort $ xs where perms' xs [] = [xs]; perms' xs nxs = concatMap (\(n, x) -> perms' (x:xs) (dec x nxs)) nxs; dec x' ((n,x):qs) = if x == x' then if n == 1 then qs else (n-1,x):qs else (n,x):dec x' qs in perms [1,1,4,1]
10:56:20 <lambdabot>   [[4,1,1,1],[1,4,1,1],[1,1,4,1],[1,1,1,4]]
10:56:23 <Olathe> There we go.
10:56:24 <sheyll> sorry not homo- just morphism
10:56:27 <Olathe> > let perms xs = perms' [].map (liftM2 (,) length head).group.sort $ xs where perms' xs [] = [xs]; perms' xs nxs = concatMap (\(n, x) -> perms' (x:xs) (dec x nxs)) nxs; dec x' ((n,x):qs) = if x == x' then if n == 1 then qs else (n-1,x):qs else (n,x):dec x' qs in perms [1,1,4,2,1]
10:56:29 <lambdabot>   [[4,2,1,1,1],[2,4,1,1,1],[4,1,2,1,1],[1,4,2,1,1],[2,1,4,1,1],[1,2,4,1,1],[4...
10:56:56 <Olathe> > let perms xs = perms' [].map (liftM2 (,) length head).group.sort $ xs where perms' xs [] = [xs]; perms' xs nxs = concatMap (\(n, x) -> perms' (x:xs) (dec x nxs)) nxs; dec x' ((n,x):qs) = if x == x' then if n == 1 then qs else (n-1,x):qs else (n,x):dec x' qs in perms [1,1,4,2,1] == nub $ perms [1,1,4,2,1]
10:56:57 <lambdabot>   Couldn't match expected type `[[t]]'
10:57:08 <Olathe> > let perms xs = perms' [].map (liftM2 (,) length head).group.sort $ xs where perms' xs [] = [xs]; perms' xs nxs = concatMap (\(n, x) -> perms' (x:xs) (dec x nxs)) nxs; dec x' ((n,x):qs) = if x == x' then if n == 1 then qs else (n-1,x):qs else (n,x):dec x' qs in perms [1,1,4,2,1] == (nub $ perms [1,1,4,2,1])
10:57:10 <lambdabot>   True
10:57:27 <Olathe> There we go.
10:58:11 <FunctorSalad_> > fromListWith (+) $ map ((,) 1) [1,1,4,1]
10:58:13 <lambdabot>   Not in scope: `fromListWith'
10:58:16 <rwbarton> sheyll: it's pretty much the same as a morphism in category theory
10:58:28 <rwbarton> sheyll: preserves whatever the structure in question is
10:58:30 <FunctorSalad_> I think counting the dupes first would be the efficient way...
10:59:03 <FunctorSalad_> then for every position, you just need to choose one from the list of distinct elements and decrement the count
10:59:16 <not_much> Oh wow! rwbarton's solution makes perfect sense! I'm happy as long as I'm only taking nub's of the first list and not the list of permutations.
11:00:18 <koeien> @hoogle [a] -> Int -> [a]
11:00:18 <lambdabot> Prelude drop :: Int -> [a] -> [a]
11:00:18 <lambdabot> Prelude take :: Int -> [a] -> [a]
11:00:18 <lambdabot> Data.List drop :: Int -> [a] -> [a]
11:01:16 <Gilly> not_much: my solution is here http://hpaste.org/13580
11:02:01 <Gilly> doesn't use nub at all :P
11:02:29 <koeien> :P
11:02:36 <not_much> Gilly: thanks!
11:03:07 <Gilly> some weird (?) character got pasted along in the code, sorry for that :P shouldn't be there
11:03:23 <not_much> Gilly: Are the funny characters just white space
11:03:26 <not_much> ok
11:05:28 <Gilly> rwbarton's solution is pretty neat, though :)
11:08:53 <ozy`> how is Data.Map implemented under the hood? anyone know offhand?
11:09:01 <opqdonut> balanced binary trees
11:10:31 <opqdonut> it actually says that in the api docs...
11:13:56 <ozy`> > [1..undefined]
11:13:58 <lambdabot>   * Exception: Prelude.undefined
11:14:23 <ozy`> > [1..] ++ [undefined]
11:14:24 <koeien> > [False..]
11:14:24 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:14:25 <lambdabot>   <no location info>: parse error on input `]'
11:15:00 <koeien> > [False ..]
11:15:00 <lambdabot>   [False,True]
11:18:13 --- mode: ChanServ set +o mauke
11:18:20 --- mode: mauke set -b *!*i=opera@*.access.telenet.be
11:19:02 <rgr> How in ghci do I query which functions support a certain type class? e.g what functions are part of the Eq typeclass?
11:19:15 <sjanssen> rgr: :info Eq
11:19:17 <koeien> :info Eq
11:19:18 <opqdonut> :i Eq
11:19:19 <opqdonut> yes
11:19:27 <rgr> thanks
11:19:31 <naturalethic> chapter 6 of real world haskell is incomprehensible
11:19:33 <koeien> that gives you the datatypes though, not the functions
11:19:44 --- mode: mauke set -o mauke
11:19:44 <koeien> naturalethic: what do you not understand? where is your difficulty?
11:20:57 <naturalethic> koeien: I think I'm just griping -- I wonder if there is a better primer on typeclasses --
11:21:30 <rgr> I wonder what the views here on RWH versus learnyouahaskell?
11:21:35 <naturalethic> RWH seems to go into a lot of detail really quickly without much explanation -- learn you a haskell doesn't get nearly is deep
11:21:35 <koeien> naturalethic: maybe "a gentle introduction to haskell"?
11:21:44 <Botje> I refuse to look at RWH until i'm holding it in my hands :)
11:21:52 <naturalethic> learnyouahaskell is wonderful
11:22:05 <rgr> I just came back to it - it's well paced IMO.
11:22:46 <mm_freak_> 603 202228 -!- Irssi: New peak in #haskell@fn : 629
11:22:54 <crathman> so I'm crusing along in SICP, and just when I think I understand the IO monad, I come to another problem...  and all that self confidence is shattered...   http://hpaste.org/13581
11:23:10 <opqdonut> SICP?
11:23:10 <naturalethic> last night i dreamed all night about programming haskell -- in 15 years of programming i've never dreamed about it
11:23:17 <crathman> My question is why the type change occurred when uncommenting the line
11:23:28 <crathman> and if there is a way around it.
11:23:38 <naturalethic> i'll poke around the gentle book
11:23:46 <koeien> crathman: i'll take a look
11:23:55 <Botje> crathman: the road to understanding monads is paved with skull fragments :)
11:24:03 <mauke> crathman: what's the type of wrapPassword?
11:24:12 <Botje> the error suggests you left out an argument somewhere
11:24:25 <opqdonut> yeah, you're doing things funnily
11:24:53 <opqdonut> wrapPassword must have a return type of IO something
11:25:00 <naturalethic> i wonder if FP activates the right brain
11:25:00 <opqdonut> but then you do  return (wrapPassword withdraw)
11:25:06 <opqdonut> so you have IO (IO something)
11:25:13 <opqdonut> which is probably not quite right
11:25:21 <koeien> wrapPassowrd seems a monadisch function of two parameters?
11:25:48 <rwbarton> actually wrapPassword :: a -> String -> a at the moment
11:25:49 <Botje> crathman: wrapPassword needs two arguments; you only give it one in "return (wrapPassword withdraw)"
11:25:50 <koeien> if you'd specify the exact type of wrapPassword you'd get a more precise error message, i think
11:26:00 <roconnor> crathman: you don't want a return a wrapPassword
11:26:19 <rwbarton> and withdraw :: Integer -> IO Integer is a function, that's probably not what you intend to pass to wrapPassword.
11:26:20 <koeien> rwbarton: ok, but the intention is let it be a monadic function
11:26:40 <roconnor> crathman: return is only for wrapping up values into a monad, but wrapPassword already returns a monadic action
11:26:40 <crathman> Botje: trying to use currying to my favor
11:26:51 <rwbarton> I think that inner do block is in the ((->) something) monad
11:26:52 <EvilTerran> return is for wrapping up *pure* values in a monadic action
11:27:02 <EvilTerran> if you've already got a monadic action, you don't need return
11:27:05 <Botje> crathman: oh
11:27:18 <roconnor> crathman: oh wait, forget what I said
11:27:36 <roconnor> crathman: you are trying to return a monadic action
11:27:45 <roconnor> crathman: clever :D
11:27:48 <rwbarton> crathman: If you get confusing type error messages, add more type signatures that express your intent to the compiler (and to #haskell :)
11:27:59 <opqdonut> yes, a good guideline
11:28:10 <crathman> ok..  perhaps instead of return...  I need to lift the function into the IO monad?
11:28:23 <koeien> crathman: no, it's already a monadic function
11:28:26 <roconnor> crathman: I see your problem now.
11:28:55 <BrokenClockwork> I am looking for an efficient way to exponentiate. Is „Square-&-Multiply“ the best approach or should I look for another way?
11:29:04 <rwbarton> crathman: You want, like, return $ \x -> wrapPassword (withdraw x), or something.
11:29:06 <vixey> @src (^)
11:29:06 <lambdabot> x ^ 0            =  1
11:29:06 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
11:29:06 <lambdabot>   where f _ 0 y = y
11:29:06 <lambdabot>         f x n y = g x n
11:29:06 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
11:29:08 <lambdabot>                       | otherwise = f x (n-1) (x*y)
11:29:09 <koeien> BrokenClockwork: (^) is not good enough?
11:29:10 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
11:29:30 <BrokenClockwork> not when I do something like 1234567^1234567
11:29:41 <koeien> BrokenClockwork: you are talking about your powermod function?
11:29:51 <eu-prleu-peupeu> heya H4sklez0r's
11:29:51 <BrokenClockwork> yes right!
11:29:59 <BrokenClockwork> expo c d n = (c^d) `mod` n
11:30:08 <koeien> BrokenClockwork: (^) also does 'square & multiply'
11:30:13 <BrokenClockwork> oh
11:30:14 <koeien> so doing that yourself won't help
11:30:22 <BrokenClockwork> jeez
11:30:34 <roconnor> crathman: you want return (\password arg-> wrapPassword (withdraw arg) password)
11:30:35 <rwbarton> BrokenClockwork: What it doesn't do is take `mod` n every time
11:30:40 <koeien> BrokenClockwork: but: if you work out the (^) example, and take `mod` n
11:30:41 <EvilTerran> however, doing the (`mod` n) every time may speed things up a *lot*
11:30:50 <opqdonut> BrokenClockwork: square and multiply (i.e. russian peasant's algorithm) isn't optimal
11:30:55 <roconnor> @pl (\password arg-> wrapPassword (withdraw arg) password)
11:30:56 <lambdabot> flip (wrapPassword . withdraw)
11:31:05 <opqdonut> BrokenClockwork: by doing analysis on the exponent one can do it in less multiplications
11:31:13 <opqdonut> BrokenClockwork: but yes, do mod in between
11:31:18 <rwbarton> BrokenClockwork: You can do this automatically by creating a Num instance for arithmetic modulo n
11:31:24 <koeien> opqdonut: also not asymptotically optimal?
11:31:30 <opqdonut> yes
11:31:32 <EvilTerran> rwbarton, ah, but only if he knows n at compile-time, surely?
11:31:32 <BrokenClockwork> so you advice me to take the (^) source and paste mod n ?
11:31:32 <roconnor> crathman: your argument passing isn't as automagic as you wanted
11:31:41 <rwbarton> EvilTerran: Well... :)
11:31:48 <koeien> BrokenClockwork: yes. that is the fastest way
11:32:00 <BrokenClockwork> okay, well thanks :)
11:32:12 <rwbarton> EvilTerran: That depends on how much Oleg you want
11:32:21 <koeien> there is never enough Oleg in the world
11:32:38 <opqdonut> BrokenClockwork: define your own Num instance
11:32:42 <opqdonut> that's easiest
11:32:54 <koeien> only if n is known at compile time
11:33:02 <mauke> you can create types at runtime
11:33:08 <rwbarton> n doesn't have to be known at compile time
11:33:09 <EvilTerran> you wouln't need to necessarily know at compile-time, actually
11:33:14 <opqdonut> yeah
11:33:22 <opqdonut> a pair (n,modulus) is pretty good
11:33:31 <koeien> okay. but then, the question about "easier" re-appears ...
11:33:38 <opqdonut> just throw an exception if moduluses differ in a computation
11:33:38 <koeien> opqdonut: ah, that's clever. i wouldn't think of that
11:33:40 <mm_freak_> somehow saying that monads are easy is much easier than writing a tutorial about them
11:33:51 <koeien> Monads are easy!
11:34:10 <mm_freak_> sure they are =)
11:34:24 <koeien> i haven't yet wrapped my head around arrows, though
11:34:34 <EvilTerran> ?arr
11:34:35 <lambdabot> I'll keel haul ya fer that!
11:34:35 <rwbarton> opqdonut: You don't need to store a pair either
11:34:36 <mm_freak_> arrows are even easier, in fact
11:34:41 <ziman> well, taking into account how many monad tutorials there are... :)
11:34:46 <rwbarton> opqdonut: and the pair doesn't handle fromInteger very well
11:34:54 <opqdonut> oh, that's true
11:35:01 <EvilTerran> mm_freak_, well, aside from the desugaring, which borders on confusing
11:35:08 <mm_freak_> it's just that there are far less uses for arrows
11:35:22 <EvilTerran> (fewer)
11:36:07 <mm_freak_> ziman: i found Cale's tutorials most useful, but i have written one myself =)
11:37:44 <ziman> :)
11:38:07 <alexey_r> Hi everyone!
11:38:27 <mm_freak_> hi there alexey_r
11:38:39 <BrokenClockwork> that's odd, ghci made 7321434^8003291  `mod ` 9788111 in nearly no time and Hugs is still calculating :(
11:38:49 <alexey_r> Apparently I am missing something completely obvious again.
11:38:51 <EvilTerran> ghci compiles to bytecode
11:38:59 <BrokenClockwork> that means?
11:39:02 <alexey_r> I am looking at http://hackage.haskell.org/packages/archive/fingertree/0.0/doc/html/src/Data-FingerTree.html#FingerTree
11:39:02 <EvilTerran> dunno what hugs does
11:39:05 <koeien> it's faster =P
11:39:06 <crathman> kids are big time distraction to learning Haskell...  roconnor thanks for the input, I'll try some things out based on the help
11:39:17 <EvilTerran> compiling it to an optimised binary with ghc would be faster still
11:39:18 <Peaker> Damnit, xchat has no "undo". I accidentally delete a long line, and can't undo it. Bah!
11:39:23 <BrokenClockwork> maybe a Heap size of 7Mb is a bit to little
11:39:24 <dmwit> BrokenClockwork: Check that you're comparing apples to apples by specifying the types.
11:39:29 <EvilTerran> Peaker, yeah, i get that sometimes too =/
11:39:34 <alexey_r> and I don't understand how there is any lazyness there.
11:39:36 <eu-prleu-peupeu> im having some major stresses with the base library of ghc 6.10.1, is this normal ?
11:39:46 <Peaker> EvilTerran: xchat is a disgrace, but I can't find any usable GUI IRC client :(
11:39:50 <eu-prleu-peupeu> HOpenGL doesn't compile because of the base types :(
11:40:27 <Peaker> A) I think arrows are "less useful" than monads because they lend themselves less to our archaic modes of text editing.  B) Many data structures have very meaningful arrow semantics, but cannot have "arr". If instead of "arr" we had "swap" "fst" and "snd" I think arrows would be more useful
11:40:27 <roconnor> #haskell is getting too sophisticated for me.  Every time I claim that someone's use of IO (IO a) is likely an error, I turn out to be wrong.
11:40:33 <alexey_r> Here are the definitions I am concerned with:
11:40:33 <alexey_r>  
11:40:33 <alexey_r> -- | Finger trees with element type @a@, annotated with measures of type @v@.
11:40:33 <alexey_r> -- The operations enforce the constraint @'Measured' v a@.
11:40:33 <alexey_r> data FingerTree v a
11:40:34 <alexey_r> 	= Empty
11:40:36 <alexey_r> 	| Single a
11:40:37 <EvilTerran> Peaker, i wouldn't go as far as to call it a disgrace; everything else is worse, though, yeah
11:40:38 <alexey_r> 	| Deep !v !(Digit a) (FingerTree v (Node v a)) !(Digit a)
11:40:40 <alexey_r>  
11:40:42 <alexey_r> deep ::  (Measured v a) =>
11:40:44 <alexey_r> 	 Digit a -> FingerTree v (Node v a) -> Digit a -> FingerTree v a
11:40:46 <alexey_r> deep pr m sf = Deep ((measure pr `mappendVal` m) `mappend` measure sf) pr m sf
11:40:46 <dmhouse> hpaste.org
11:40:47 <koeien> alexey_r: please paste tehm at hpaste.org
11:41:02 <EvilTerran> ?hpaste
11:41:02 <koeien> and provide us with the link
11:41:02 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:41:14 <rwbarton> BrokenClockwork: ghci can't compute 7321434^8003291  `mod ` 9788111 in "nearly no time" unless you are defaulting to Int somehow
11:41:25 <mm_freak_> roconnor: i'm having IO (IO a) quite often
11:41:27 <Peaker> EvilTerran: its search dialog is the worst UI I've seen since Internet Explorer 4.  Its channel widget is buggy (has drawing errors).  Its startup dialog has a "skip me at startup" checkbox that doesn't even work,  and its written in C!
11:41:31 <mm_freak_> particularly in concurrent code
11:42:08 <Asztal> Peaker: what about chatzilla?
11:42:14 <Peaker> Asztal: Is it a standalone GUI?
11:42:16 <alexey_r> Here: http://hpaste.org/13582 Just need to remember next time.
11:42:18 <Asztal> It can be
11:42:29 <EvilTerran> i never use the search dialog; i see drawing errors regardless of which program i'm using, so ignore them; its startup dialog works for me
11:42:32 <EvilTerran> eh, YMMV, i guess
11:42:44 <BrokenClockwork> "nearly no time" I meant 11seconds
11:42:49 <juturnas> is there a way to create descending lists instead of ascending with list comprehensions? like [100..1]
11:42:57 <EvilTerran> juturnas, [100,99..1]
11:43:08 <BrokenClockwork> sure it's not comparable to my sentence, but nevertheless hugs is still working -.-
11:43:17 <Peaker> Asztal: how?
11:43:18 <juturnas> Wow, thanks
11:43:27 <alexey_r> The important part is "Deep !v !(Digit a) (FingerTree v (Node v a)) !(Digit a)"
11:43:32 <byorgey_> juturnas: in general,  [a,b..c] creates a list starting at a which goes by steps of (b-a)
11:43:32 <quylui> Peaker, i'm using chatzilla now. it rocks.
11:43:40 <Peaker> EvilTerran: Well, I have it set up to just auto-connect to freenode and auto-join a bunch of channels, but it still pops up the startup dialog
11:43:46 <mux> > enumFromThenTo 100 99 1
11:43:47 <lambdabot>   [100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,7...
11:43:53 <Peaker> quylui: how do I use it without firing up the whole seamonkey?
11:44:00 <mux> this is what it desugars into
11:44:08 <EvilTerran> Peaker, well, the "skip network list at startup" box works for me
11:44:13 <juturnas> thanks mux
11:44:34 <alexey_r> As I understand !, it means that whenever a deep tree is constructed, its measure and digits are always calculated, right?
11:44:37 <quylui> well, i just use it an extension of firefox
11:44:47 <quylui> i can always close firefox and leave it running
11:44:50 <Asztal> Peaker: http://chatzilla.rdmsoft.com/xulrunner/
11:45:18 <mm_freak_> > take 100 . iterate (-1) $ 100
11:45:20 <lambdabot>       No instance for (Num (a -> a))
11:45:20 <lambdabot>        arising from a use of `negate' at...
11:45:33 <EvilTerran> yaaay
11:45:33 <mm_freak_> > take 100 . iterate (subtract 1) $ 100
11:45:35 <lambdabot>   [100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,7...
11:46:14 <BrokenClockwork> is it possible to get the numbers of digits of a number?
11:46:23 <mm_freak_> length . show
11:46:42 <dmwit> logBase 10 -- approximately right, and way faster
11:47:00 <alexey_r> But then the smart constructor has to force the middle of the tree to find its measure, and if middle is Deep itself, it will need to be forced too, et cetera.
11:47:01 <Gracenotes> length . show would work best for integers
11:47:02 <koeien> :t length . takeWhile (/=0) . iterate (`div` 10)
11:47:04 <lambdabot> forall a. (Integral a) => a -> Int
11:47:24 <Gracenotes> and, at that. positive integers
11:47:40 <EvilTerran> alexey_r, the cells can be lazy, though, even if the internal structure isn't
11:47:41 <mm_freak_> > ceiling (log 12345 / log 10)
11:47:43 <lambdabot>   5
11:47:45 <koeien> (wrong for <= 0)
11:47:48 <Peaker> Asztal: thanks
11:47:51 <mm_freak_> > ceiling (logBase 10 12345)
11:47:52 <alexey_r> So as far as I can see, the structure always ends up fully forced.
11:47:53 <lambdabot>   5
11:48:07 <dmwit> > ceiling (logBase 10 10000) -- mm_freak_
11:48:09 <lambdabot>   4
11:48:09 <BrokenClockwork> > length . show 123
11:48:10 <lambdabot>   Couldn't match expected type `a -> [a1]'
11:48:13 <koeien> > ceiling (logBase 10 99999999999999999999999999999999999999)
11:48:14 <lambdabot>   38
11:48:16 <Gracenotes> > ceiling (logBase 10 (-12345)) -- asplosion
11:48:18 <lambdabot>   269653970229347386159395778618353710042696546841345985910145121736599013708...
11:48:25 <dmwit> eh?
11:48:30 <dmwit> > logBase 10 (-12345)
11:48:32 <lambdabot>   NaN
11:48:36 <mm_freak_> i'll stick with length . show ;)
11:48:47 <mm_freak_> > length . show $ 12345
11:48:49 <lambdabot>   5
11:48:49 <BrokenClockwork> length . show doesnt work in prelude
11:48:50 <dmwit> > ceiling (read "NaN" :: Double)
11:48:52 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
11:48:58 <stu8ball> length (show x)
11:48:59 <dmwit> yipe!
11:49:00 <stu8ball> no dot
11:49:01 <mm_freak_> BrokenClockwork: beware of polymorphic types
11:49:07 <dmwit> BrokenClockwork: What?
11:49:23 <BrokenClockwork> oh it does I forgot the $
11:49:43 <alexey_r> If only the cells are supposed to be fully forced, why not write Deep !v !(Digit a) !(FingerTree v (Node v a)) !(Digit a) with the middle strict too? Just to give the compiler something to do?
11:50:03 <dmwit> > round (read "NaN" :: Float) -- yet another reason to hate IEEE754 floats
11:50:04 <lambdabot>   -510423550381407695195061911147652317184
11:50:18 <alexey_r> And the implementation in Edison does the same.
11:50:24 <juturnas> is reverse not lazy?
11:50:33 <dmwit> juturnas: It can't be lazy!
11:50:38 <dmwit> juturnas: Well, it can't be spine-lazy.
11:50:44 <koeien> juturnas: it's strict, it inspects its argument
11:50:44 <dmwit> juturnas: It is certainly element-lazy, though.
11:50:58 <juturnas> k
11:51:01 <juturnas> thanks
11:51:11 <koeien> > length . reverse $ replicate 10 undefined
11:51:31 <lambdabot>   10
11:53:30 <Raevel> @hoogle (a -> a) -> a -> [a]
11:53:31 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
11:53:31 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
11:53:31 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
11:53:59 <alexey_r> And finally, the original paper suggests making the middle lazy even in a strict language.
11:54:22 <EvilTerran> alexey_r, does it explain why?
11:55:03 <crathman> ok.  my kids are fed...  back to learning haskell.
11:56:10 <alexey_r> Here are the mentions of strictness:
11:56:19 <alexey_r> Although the structure makes essential use of laziness, it is also suitable for strict languages that provide a lazy evaluation primitive.
11:57:06 <alexey_r> "In a strict language, it might be more useful to provide the three separate functions as primitives." (Not really relevant to this point)
11:57:38 <alexey_r> In a strict language that provides a lazy evaluation primitive, we need only suspend the middle subtree of each Deep node, so only  (log n) suspensions are required in a tree of size n.
11:58:18 <Olathe> > ceiling (0.0/0.0)
11:58:19 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
11:58:21 <Olathe> O-o
11:58:29 <opqdonut> indeed :)
11:58:31 <dmwit> I hate floating point.
11:58:32 <Olathe> > floor (0.0/0.0)
11:58:33 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
11:58:36 <opqdonut> haskell doesn't handle fp exceptional conditions
11:58:40 <Olathe> > ceiling (1.0/0.0)
11:58:42 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
11:58:45 <Olathe> Hahah
11:58:51 <Olathe> Now we know the largest number !
11:59:01 <dmwit> 24's all I'm saying
11:59:20 <Olathe> > length.show $ ceiling (1.0/0.0)
11:59:21 <lambdabot>   309
11:59:28 <dmwit> http://www.youtube.com/watch?v=f3ek85X2uOE
12:00:06 <alexey_r> The non-strict split of xs yields a third finger pointing to the position where x must be inserted or deleted. (The only place which suggests an actual reason)
12:00:24 <kaol> > length.show (0.0/0.0)
12:00:26 <lambdabot>   Couldn't match expected type `a -> [a1]'
12:00:46 <kaol> > length $ show (0.0/0.0)
12:00:48 <lambdabot>   3
12:00:56 <Gracenotes> NaN :)
12:01:21 <Olathe> > length.show $ round (0.0/0.0)
12:01:22 <lambdabot>   310
12:01:23 <alexey_r> Lazyness is only used for proving the amortized bounds, as far as I can see.
12:02:48 <alexey_r> Also, I remember there were source links on GHC's libraries documentation, but they aren't there now :(
12:03:26 <alexey_r> I wanted to check if Data.Sequence does it the same way.
12:03:53 <Olathe> > toRational (1.0/0.0)
12:03:55 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
12:04:23 <icqn> >1.0/0.0
12:04:29 <mercury^> :t ceiling
12:04:31 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
12:04:45 <Olathe> > 1.0/0.0 --Needs a space.
12:04:46 <lambdabot>   Infinity
12:04:50 <Sorethumb> dmwit: It's 18 :P
12:04:55 <mercury^> :t ceiling (0.0/0.0)
12:04:57 <lambdabot> forall b. (Integral b) => b
12:05:14 <dmwit> Yeah, 18... fuhgeddaboudit
12:05:45 <alexey_r> Ah, here it is: "The same bounds hold in a persistent setting if subtrees are suspended using lazy evaluation. This ensures that transformations deep in the spine do not take place until a subsequent operation needs to go down that far. Because of the above properties of safe and dangerous digits, by that time enough cheap shallow operations will have been performed to pay for this expensive evaluation."
12:05:58 <Igloo> There's no Data.List.stripPrefix for ByteString, right?
12:07:07 <BrokenClockwork> okay, I have a list of ints [1,8,5,0,5] and I want to create a whole number: 18505
12:07:23 <BrokenClockwork> but this is more difficult, as it's no string :(
12:07:26 <dmwit> > read ([1, 8, 5, 0, 5] >>= show) :: Int
12:07:28 <lambdabot>   18505
12:07:32 <BrokenClockwork> oh
12:07:41 <Olathe> > foldr ((+).(*10)) [1,8,5,0,5]
12:07:42 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
12:07:42 <lambdabot>        arising from a use...
12:07:46 <dmwit> > read . map intToDigit $ [1, 8, 5, 0, 5] :: Int
12:07:47 <Olathe> > foldr ((+).(*10)) 0 [1,8,5,0,5]
12:07:48 <lambdabot>   18505
12:07:49 <lambdabot>   190
12:07:57 <Olathe> > foldr ((+).(*10)) 0 [1,8,5,0,5,6]
12:07:58 <dmwit> Olathe: I'm winning...
12:07:59 <lambdabot>   250
12:08:02 <Olathe> :(
12:08:17 <dmwit> > foldr (\x y -> y + 10 * x) 0 [1, 8, 5, 0, 5]
12:08:18 <EvilTerran> > foldl ((+).(*10)) 0 [1,8,5,0,5,6]
12:08:19 <lambdabot>   190
12:08:20 <lambdabot>   185056
12:08:29 <ziman> dmwit, interesting :)
12:08:29 <Olathe> > foldr (\a b -> 10*a + b) 0 [1,8,5,0,5,6]
12:08:31 <lambdabot>   250
12:08:38 <Olathe> > foldr (\a b -> 10*b + a) 0 [1,8,5,0,5,6]
12:08:38 <EvilTerran> it's a foldl!
12:08:39 <lambdabot>   650581
12:08:46 <Olathe> Lies !
12:08:51 <dmwit> EvilTerran: So true!
12:08:52 <Olathe> > foldl (\a b -> 10*a + b) 0 [1,8,5,0,5,6]
12:08:59 <lambdabot>   185056
12:09:02 <EvilTerran> when you think about it, it kinda has to be with that trick
12:09:03 <Olathe> Faster !
12:09:04 <BrokenClockwork> oi
12:09:07 <dmwit> > foldr (\x y -> x + 10 * y) 0 [1, 8]
12:09:09 <lambdabot>   81
12:09:13 <dmwit> haha
12:09:14 <dmwit> yeah
12:09:26 <Olathe> > foldl' ((+).(*10)) 0 [1,8,5,0,5,6]
12:09:27 <lambdabot>   185056
12:09:28 <EvilTerran> you're accumulating left-to-right
12:09:35 <dmwit> right
12:09:37 * dmwit feels silly
12:09:47 <Olathe> > let fromDigits = foldl' ((+).(*10)) 0 in fromDigits [1,8,5,0,5,6]
12:09:48 <lambdabot>   185056
12:10:20 <alexey_r> Yes, Data.Sequence does do the same thing: Deep {-# UNPACK #-} !Int !(Digit a) (FingerTree (Node a)) !(Digit a)
12:10:41 <EvilTerran> that does suggest it may be better to store your digits in the other order
12:10:55 <EvilTerran> that also makes digit-by-digit maths easier
12:11:55 <Olathe> > let toDigits 0 = [0]; toDigits n = f' [] n where f' ds [] = rs; f' ds n = f' (d:ds) n' where (n',d) = divMod n 10 in toDigits 185056
12:11:56 <lambdabot>   Not in scope: `rs'
12:12:02 <Olathe> > let toDigits 0 = [0]; toDigits n = f' [] n where f' ds [] = ds; f' ds n = f' (d:ds) n' where (n',d) = divMod n 10 in toDigits 185056
12:12:03 <lambdabot>       No instance for (Integral [t])
12:12:03 <lambdabot>        arising from a use of `toDigits' ...
12:12:06 <Olathe> Lies.
12:12:12 <Japsu> @unpl ((.).)
12:12:12 <lambdabot> (\ d g b c -> d g (b c))
12:12:38 <dmwit> Japsu: Isn't that so much more readable? ;-)
12:12:44 <Olathe> > let toDigits 0 = [0]; toDigits n = f' [] n where f' ds 0 = ds; f' ds n = f' (d:ds) n' where (n',d) = divMod n 10 in toDigits 185056
12:12:46 <lambdabot>   [1,8,5,0,5,6]
12:12:49 <Olathe> There we go.
12:12:58 <Japsu> dmwit: what's frightening is that I've actually seen some people use ((.).)
12:13:09 <dons> huh, is #haskell bigger than #python today?
12:13:14 <mm_freak_> why do you encode the highest digit as the first element?
12:13:15 <dmwit> > let toDigits = map digitToInt . show in toDigits 185056
12:13:17 <lambdabot>   [1,8,5,0,5,6]
12:13:19 <dons> http://searchirc.com/search.php?SCHANS=1&SSORT=SIZE&N=freenode
12:13:28 <dons> shapr: kinda amazing!
12:13:35 <Olathe> mm_freak_: That's how I write it.
12:13:37 <dmwit> dons: Wow!
12:13:40 <dmwit> It is!
12:13:40 <roconnor> dons: everyone's new year's resolution is to learn Haskell
12:13:48 <dons> seems so.
12:14:18 <Olathe> We should beat PHP pretty soon.
12:14:22 <mm_freak_> > map (`rem` 10) . takeWhile (>0) . iterate (`div` 10) $ 5284709
12:14:24 <lambdabot>   [9,0,7,4,8,2,5]
12:14:32 <Olathe> Eeeeewwww
12:15:00 <EvilTerran> "... rem ... div ..." is an interesting choice
12:15:11 <roconnor> > map readDigit (show 5284709)
12:15:13 <lambdabot>   Not in scope: `readDigit'
12:15:24 <EvilTerran> > map digitToInt (show 5284709)
12:15:26 <lambdabot>   [5,2,8,4,7,0,9]
12:15:32 <naturalethic> does anyone have the complete working source for the JSON example in RWH?
12:15:37 <Olathe> Can ghc eliminate the conversion to Char ?
12:15:58 <EvilTerran> > read (map intToDigit [5,2,8,4,7,0,9])
12:16:00 <lambdabot>   * Exception: Prelude.read: no parse
12:16:03 <EvilTerran> > read (map intToDigit [5,2,8,4,7,0,9]) :: Int
12:16:04 <lambdabot>   5284709
12:16:04 <mm_freak_> unlikely, but that's probably not a problem
12:16:06 <dmwit> EvilTerran: Waaay ahead of you. ;-)
12:16:20 <EvilTerran> yeah, just trying to put it up next to the other one for comparison
12:16:40 <EvilTerran> Olathe, no, that'll be going the long way round
12:23:33 <Peaker> conal: how are Reactive things progressing?
12:25:39 <not_much_> What's a good way to apply a function to apply a function to each element of a list one at a time like so: mapSeparate (+2) [1..4] produces [[3,2,3,4],[1,4,3,4],[1,2,5,4],[1,2,3,6]] ?
12:26:01 <not_much_> I have a solution but it's ugly  :P
12:27:05 <opqdonut> using the list monad there might be a semielegant solution
12:27:36 <opqdonut> hmm
12:27:40 <mahogny> I don't think ordinary recursion would look too bad
12:27:41 <vixey> not_much_, it is liek you have  [1,2,3,4] ---> [(1,[2,3,4],[]), ..., (3,[1,2],[4]), ...]
12:27:42 <Heffalump> I think you just have to do it recursively.
12:27:50 <Gilly> would mapSeparate f (x:xs) = f x : xs ++ map (x:) mapSeparate f xs
12:27:51 <dmwit> not_much_: Check out tails and inits.
12:27:51 <Gilly> do?
12:28:10 <Heffalump> Gilly: yeah
12:28:16 <vixey> @let mapSeparate f (x:xs) = f x : xs ++ map (x:) mapSeparate f xs
12:28:16 <opqdonut> just define a function that generates the list [[f,id,id...],[id,f,id,id...],...]
12:28:16 <lambdabot>  Couldn't match expected type `[[a]]'
12:28:19 <opqdonut> and the nzip
12:28:24 <Heffalump> well, something like that
12:28:30 <vixey> @let mapSeparate f (x:xs) = f x : xs ++ map (x:) (mapSeparate f xs)
12:28:31 <lambdabot>  <local>:24:39:
12:28:31 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a...
12:28:32 <dmwit> Gilly: Needs more parens.
12:28:35 <Gilly> dmwit: i know
12:28:38 <opqdonut> Gillys solution is pretty good too
12:28:40 <dmwit> Gilly: And more base cases. ;-)
12:28:41 <vixey> @let mapSeparate f (x:xs) = (f x : xs) ++ map (x:) (mapSeparate f xs)
12:28:42 <lambdabot>  <local>:24:41:
12:28:42 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a...
12:28:47 <Gilly> yup :P
12:28:50 * vixey I think it's not a solution.........
12:29:17 <Heffalump> it should be :, not ++
12:29:25 <BrokenClockwork> I want to prepare a whole fucntion call in my main do = ... how should that work?
12:29:30 <dmwit> > let onHead f (x:xs) = f x : xs; mapSeparate f xs = zipWith (\xs ys -> xs ++ onHead f ys) (inits xs) (tail (tails xs)) in mapSeparate (+2) [1..4]
12:29:31 <lambdabot>   [[4,3,4],[1,5,4],[1,2,6],[1,2,3* Exception: /tmp/6117193990586887131:71:48-...
12:29:39 <dmwit> whoops
12:29:50 <Heffalump> @let mapSeparate f xs = case xs of { x:xs -> (f x:xs) : map (x:) (mapSeparate f xs) ; [] -> [] }
12:29:52 <dmwit> > let onHead f (x:xs) = f x : xs; mapSeparate f xs = zipWith (\xs ys -> xs ++ onHead f ys) (tail (inits xs)) (tails xs) in mapSeparate (+2) [1..4]
12:29:54 <lambdabot>   [[1,3,2,3,4],[1,2,4,3,4],[1,2,3,5,4],[1,2,3,4,6]]
12:29:54 <lambdabot>  Defined.
12:29:58 <dmwit> I win!
12:30:02 <dmwit> I fail.
12:30:09 <not_much> hmm
12:30:10 * dmwit leaves
12:30:16 <Gilly> mapSeparate f []= []
12:30:17 <Gilly> mapSeparate f (x:xs) = [f x : xs] ++ map (x:) (mapSeparate f xs)
12:30:21 <Heffalump> ewww
12:30:26 <Heffalump> [x]++... = x:...
12:30:33 <Heffalump> apart from that, very nice.
12:30:38 <Gilly> well, what ever :P
12:30:39 <Gracenotes> oh, I was just working out something with zipWith :P
12:30:40 <dmwit> > inits [1..4]
12:30:40 <dmwit> > tails [1..4]
12:30:45 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4]]
12:30:45 <lambdabot>   [[1,2,3,4],[2,3,4],[3,4],[4],[]]
12:30:45 <dmwit> oooh
12:30:55 <conal> Peaker: about Reactive, some progress but i've been somewhat stuck with what seems to be a ghc rts bug interfering with unamb working correctly.
12:31:02 <dmwit> > let onHead f (x:xs) = f x : xs; mapSeparate f xs = zipWith (\xs ys -> onHead f xs ++ ys) (tail (inits xs)) (tails xs) in mapSeparate (+2) [1..4]
12:31:07 <lambdabot>   [[3,1,2,3,4],[3,2,2,3,4],[3,2,3,3,4],[3,2,3,4,4]]
12:31:15 <Gracenotes> darn off by one errors!
12:31:17 <mahogny> inits and tails look extraordinarily slow though
12:31:19 <dmwit> uh, what?
12:31:24 <roconnor> @check \l -> inits l = reverse (tails l)
12:31:25 <lambdabot>   Parse error at "=" (column 15)
12:31:30 <roconnor> @check \l -> inits l == reverse (tails l)
12:31:32 <lambdabot>   "OK, passed 500 tests."
12:31:32 <vixey> > let select' [] = [] ; select' (x:xs) = (x,[],xs) : map (\(m,n,o)->(m,x:n,o)) (select' xs) in select' "foo"
12:31:34 <lambdabot>   [('f',"","oo"),('o',"f","o"),('o',"fo","")]
12:31:35 <opqdonut> mahogny: tails is pretty fast
12:31:36 <dmwit> > let onHead f (x:xs) = f x : xs; mapSeparate f xs = zipWith (\ys zs -> onHead f ys ++ zs) (tail (inits xs)) (tails xs) in mapSeparate (+2) [1..4]
12:31:37 <opqdonut> actually
12:31:38 <lambdabot>   [[3,1,2,3,4],[3,2,2,3,4],[3,2,3,3,4],[3,2,3,4,4]]
12:31:40 <opqdonut> only O(n)
12:31:43 <opqdonut> because it can reuase
12:31:47 <opqdonut> *reuse
12:31:58 <mahogny> opqdonut, looking at the constant factor
12:31:59 <roconnor> the tails are shared in tails
12:31:59 <vixey> > let select' [] = [] ; select' (x:xs) = ([],x,xs) : map (\(n,m,o)->(x:n,m,o)) (select' xs) in select' "better"
12:32:01 <lambdabot>   [("",'b',"etter"),("b",'e',"tter"),("be",'t',"ter"),("bet",'t',"er"),("bett...
12:32:12 <opqdonut> mahogny: even with the constant factor
12:32:18 <mahogny> hm
12:32:25 <dmwit> Yeah, vixey's approach is probably the most general.
12:32:25 <opqdonut> it only traverses the list once and creates n cons cells
12:33:01 <dmwit> mahogny: "tails" just constructs a list of pointers into each position in the old list.
12:33:12 <Heffalump> how does vixey's approach differ from Gilly's?
12:33:23 <dmwit> You can reuse select. =)
12:33:26 <Asztal> @check \(l::[Int]) -> inits l == reverse (tails l)
12:33:26 <lambdabot>   Parse error in pattern at "->" (column 13)
12:33:26 <vixey> I guess mine actually typechkeces..
12:33:33 <dmwit> For other things.
12:34:05 <Heffalump> vixey: so did Gilly's...
12:34:13 <dmwit> ?check \l -> liftM2 (==) inits (reverse . tails)
12:34:13 <lambdabot>   "OK, passed 500 tests."
12:34:16 <vixey> Heffalump, not when I tried it in lambdabot
12:34:28 <dmwit> ?check \l -> liftM2 (==) (inits :: [Int] -> [[Int]]) (reverse . tails)
12:34:29 <lambdabot>   "Falsifiable, after 3 tests:\n()\n[-2,-2,-3]\n"
12:34:35 <Gilly> vixey: that was the first version i just typed in in rush, i pasted a working one later
12:34:38 <Heffalump> the version 4 minutes ago did
12:34:44 <Jedai> @let mapSeparate f [] = []; mapSeparate f (x:xs) = (f x : xs) : map (x :) (mapSeparate f xs)
12:34:45 <lambdabot>  <local>:24:0:
12:34:45 <lambdabot>      Warning: Pattern match(es) are overlapped
12:34:45 <lambdabot>               I...
12:34:46 <vixey> > let select' [] = [] ; select' (x:xs) = (id,x,xs) : map (\(n,m,o)->((:n) . x ,m,o)) (select' xs) in map (\(f,x,y)->f(x:y)) (select' "better")
12:34:48 <lambdabot>   Couldn't match expected type `[b]'
12:34:52 <dmwit> oh
12:34:57 <dmwit> ?check liftM2 (==) (inits :: [Int] -> [[Int]]) (reverse . tails)
12:34:58 <lambdabot>   "Falsifiable, after 2 tests:\n[-1,1]\n"
12:35:02 <not_much> thanks!
12:35:06 <Asztal> I find it a bit worrying that Arbitrary seems to default to () :(
12:35:22 <vixey> > let select' [] = [] ; select' (x:xs) = (id,x,xs) : map (\(n,m,o)->(n . (x:) ,m,o)) (select' xs) in map (\(f,x,y)->f(x:y)) (select' "better")
12:35:23 <lambdabot>   ["better","better","ebtter","tebter","tteber","ettebr"]
12:35:29 <Jedai> > mapSeparate (+2) [1..4]
12:35:30 <vixey> > let select' [] = [] ; select' (x:xs) = (id,x,xs) : map (\(n,m,o)->(n . (:x) ,m,o)) (select' xs) in map (\(f,x,y)->f(x:y)) (select' "better")
12:35:31 <lambdabot>   [[3,2,3,4],[1,4,3,4],[1,2,5,4],[1,2,3,6]]
12:35:31 <lambdabot>       Occurs check: cannot construct the infinite type: c = [c]
12:35:31 <lambdabot>        Expect...
12:35:40 <vixey> > let select' [] = [] ; select' (x:xs) = (id,x,xs) : map (\(n,m,o)->((x:) . n ,m,o)) (select' xs) in map (\(f,x,y)->f(x:y)) (select' "better")
12:35:42 <lambdabot>   ["better","better","better","better","better","better"]
12:35:46 <Gracenotes> this seems like a good intermediate-level problem ;)
12:35:56 <vixey> > let select' [] = [] ; select' (x:xs) = (id,x,xs) : map (\(n,m,o)->((x:) . n ,m,o)) (select' xs) in map (\(f,x,y)->f(x+1:y)) (select' [33,22,99])
12:35:57 <lambdabot>   [[34,22,99],[33,23,99],[33,22,100]]
12:36:02 <Jedai> vixey: Seems to work correctly to me
12:38:06 <vixey> :t cons x xs ys = x:xs ys
12:38:08 <lambdabot> parse error on input `='
12:38:14 <gbacon> ?hoogle merge
12:38:15 <lambdabot> Distribution.Simple.PackageIndex merge :: Package pkg => PackageIndex pkg -> PackageIndex pkg -> PackageIndex pkg
12:38:15 <lambdabot> Text.Parsec.Error mergeError :: ParseError -> ParseError -> ParseError
12:38:15 <lambdabot> Text.ParserCombinators.Parsec.Error mergeError :: ParseError -> ParseError -> ParseError
12:38:26 <gbacon> ?hoogle Ord a => [a] -> [a] -> [a]
12:38:27 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
12:38:27 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
12:38:27 <lambdabot> Data.List insert :: Ord a => a -> [a] -> [a]
12:38:46 <dmwit> :t let cons x xs ys = x : xs ++ ys in cons
12:38:48 <lambdabot> forall a. a -> [a] -> [a] -> [a]
12:38:52 <Gracenotes> okay, a bit late, but I think I just won the least elegant award
12:38:53 <Gracenotes> > let mr f xs = zipWith (\a b -> zipWith (\c d -> if d==b then f c else c) a [0..]) (replicate (length xs) xs) [0..] in mr (+2) [1,2,3,4]
12:38:55 <lambdabot>   [[3,2,3,4],[1,4,3,4],[1,2,5,4],[1,2,3,6]]
12:39:27 <vixey> @pl (\c d -> if d==b then f c else c)
12:39:27 <lambdabot> flip =<< flip (if' . (b ==)) . f
12:39:36 <gbacon> why doesn't Data.List have merge and mergeBy?
12:39:39 <vixey> @pl (\c d -> (if d==b then f else id) c)
12:39:39 <lambdabot> flip (flip (flip if' f . (b ==)) id)
12:39:47 <vixey> Gracenotes: flip (flip (flip if' f . (b ==)) id)
12:40:03 <Gracenotes> ah yes, so much more elegant :P
12:40:29 <Gracenotes> I *wish* if' was provided in the standard library somewhere
12:40:36 <Gracenotes> @hoogle if'
12:40:36 <lambdabot> No results found
12:40:56 <Ravesky> PORN, AMATEUR GIRL http://www.sheisawhore.com/index.php?ident=e871d78a720af96eb5060f930fe53e54
12:41:02 <vixey> I don't like if'
12:41:14 <vixey> bool true false True = true ; bool true false False = false -- is better imo
12:41:23 <vixey> because the argument order of if' doesn't make sense
12:41:45 <Gracenotes> anything that, given a Bool, returns one of two a's will be fine
12:42:00 <cjay> can anyone tell me if installing multiple ghc versions is ok and doesn't confuse cabal?
12:42:21 <Gracenotes> although perhaps Either would work for that purpose... sort of.
12:42:27 <Heffalump> cjay: I do it and it's fine
12:42:37 <cjay> ok :D
12:42:38 <Heffalump> cabal picks up the GHC on the path at the time and works with that
12:42:55 <Heffalump> I've had less success with the --with-ghc flag or whatever it's called
12:43:04 <cjay> hm
12:46:05 <Gracenotes> vixey: oh, I see what you mean
12:47:00 <Gracenotes> @hoogle a -> a -> Bool
12:47:01 <lambdabot> Distribution.Simple.Utils equating :: Eq a => (b -> a) -> b -> b -> Bool
12:47:01 <lambdabot> Prelude (<) :: Ord a => a -> a -> Bool
12:47:01 <lambdabot> Prelude (<=) :: Ord a => a -> a -> Bool
12:47:15 <maltem> vixey: if' True, if' False act like Church Booleans
12:47:41 <vixey> o k
12:47:48 <vixey> ok*
12:47:49 <Gracenotes> but it would be nice if if' existed somewhere outside of lambdabot's imagination before it used it :)
12:47:54 <maltem> not sure if that makes if' make more sense :)
12:48:00 <vixey> not really no
12:49:08 <vixey> I never found it much a problem since you can just put your own definitions into a .hs file
12:50:46 <BrokenClockwork> http://hpaste.org/13584 any ideas why my main function doesn't work?
12:51:09 <BrokenClockwork> it says the last statement of a 'do' construct must be an expression
12:51:36 <Guenni> exactly, it doesn't *do* anything
12:51:40 <Zao> BrokenClockwork: Well, the last one of yours, isn't.
12:51:48 <maltem> BrokenClockwork: indeed, let key = (11,978111) isn't an expression
12:51:55 <BrokenClockwork> mh
12:52:00 <BrokenClockwork> what would be an expression?
12:52:03 <Cale> BrokenClockwork: Let me see... (hpaste is slow)
12:52:05 <Zao> You need at least one action.
12:52:07 <Zao> return () for example.
12:52:12 <Guenni> putStrLn "hello"
12:52:14 <Cale> BrokenClockwork: Basically, it can't end in v <- x
12:52:22 <Zao> Anything that has type   IO a
12:52:25 <BrokenClockwork> ah that's stuipid :D
12:52:25 <Cale> BrokenClockwork: oh
12:52:35 <Cale> BrokenClockwork: You have a do-block ending with a let
12:52:55 <Cale> BrokenClockwork: which is pointless, since the things bound inside the let only scope over the remainder of the do-block
12:53:06 <beso> Cale: Hi
12:53:06 <michaelcdever> evening all
12:53:08 <Cale> BrokenClockwork: That is, code and key aren't used anywhere
12:53:09 <Zao> Your application seems a bit pointless, I must say.
12:53:11 <Cale> beso: hi
12:53:27 <BrokenClockwork> yeah I would like to runt rsaDecString code key
12:53:44 <BrokenClockwork> http://hpaste.org/13584#a1
12:53:48 <Cale> BrokenClockwork: Yeah, but that's not even an IO computation.
12:53:48 <Guenni> and do what with the result?
12:53:49 <beso> Cale: could you plase see pm
12:54:05 <maltem> BrokenClockwork: you'll want to print the result I guess?
12:54:06 <Cale> BrokenClockwork: You want to *print* the result of that, perhaps
12:54:25 <BrokenClockwork> yeah!
12:54:38 <maltem> BrokenClockwork: so, print (rsaDecString code key)
12:54:39 <Cale> BrokenClockwork: use  print (rsaDecString code key)
12:54:41 <Cale> heh
12:54:44 <Cale> stereo
12:55:00 <maltem> Cale: but I've been faster!
12:55:13 <BrokenClockwork> ah now it's working, thank, I totally missunderstand the do construct :)
12:55:31 <Cale> BrokenClockwork: In fact, you still don't need a do-construct here.
12:55:45 <Cale> BrokenClockwork: You only really need do when there's more than one action you're chaining together
12:55:46 <BrokenClockwork> not?
12:55:55 <Cale> BrokenClockwork: You could write this as:
12:55:59 <Cale> let code = ...
12:56:04 <Cale>     key = ...
12:56:10 <Cale> in print (rsa ...)
12:56:56 <Cale> You only have the one action: printing, so there's no need for a do-expression.
12:57:16 <Guenni> guys anybody here who used HDBC with MS-Access?
12:57:17 <BrokenClockwork> oh ok
12:57:21 <maltem> Heh, good ol' type system, prevents you from forgetting to print the result
12:58:28 <Guenni> BrokenClockwork:  btw if you just want to test ("run") that particular function you might want to do this in ghci
12:59:24 <BrokenClockwork> oh, I will take a look on that :)
12:59:48 <Guenni> guys anybody here who used HDBC with MS-Access? please?
13:00:36 <EvilTerran> Guenni, you asked that two minutes ago; we heard you
13:00:45 <Cale> Guenni: I haven't, but I suspect you'd use the odbc driver.
13:01:14 <Cale> Does MS Access expose its databases via ODBC?
13:01:25 <Guenni> cale: yes
13:01:47 <Guenni> Cale: and I did try that and keep getting error messages
13:02:01 <redditbot> The beginnings of a real-time strategy game in Haskell
13:02:01 <redditbot> Haskell Weekly News: January 3, 2009 | The Haskell Sequence
13:02:27 <Guenni> HDBC works fine with sqlite but when I use Access at a backend it blows up
13:02:55 <Cale> How am I not surprised? ;)
13:03:03 <michaelcdever> I have an error Couldn't mathc expected type 'GHC.Word.Word8' against inferred type 'Char' anyone know how i get around this?
13:03:04 <Guenni> So I keep wondering if anybody used HDBC with Access successfully
13:04:14 <Guenni> since most haskellers here are on linux it's quite possible nobody actually tried to use it with access before
13:04:45 <Cale> michaelcdever: Context? If you're using Data.ByteString, just switch to using the .Char8 version of the module.
13:04:49 <Heffalump> Guenni: seems quite likely.
13:05:09 <Cale> michaelcdever: Otherwise, you'll have to convert, likely using fromEnum and possibly fromIntegral
13:05:23 <Guenni> damn I've gotten so far and now I'll have to start over again
13:05:38 <ozy`> BrokenClockwork: for future reference... http://paste.pocoo.org/show/97819/
13:05:41 <Heffalump> you could fix it :-)
13:05:53 <Guenni> doubt it :)
13:05:54 <Cale> Someone has to be the first :)
13:06:02 <not_much> you're actually closer now, you just thought you were before :)
13:06:15 <Guenni> I am soooo clueless when it comes to low level stuff
13:06:24 <Cale> Guenni: What's the error?
13:06:56 <Guenni> when it tries to bind the parameters it throws an "invalid precision value" error
13:07:04 <ozy`> http://paste.pocoo.org/show/97819/ <== everyone feel free to improve on this, by the way, to make it clearer what's going on
13:07:22 <Guenni> but only with Access, hdbc-odbc mysql works fine
13:07:27 <Peaker> it seems a lot of people were asking about counting the number of digits.  I wrote a logBase that should have O(log(result)) time complexity, and is accurate (unlike the usual logBase): http://hpaste.org/13585
13:07:38 <Heffalump> might just be a question of tweaking the way it gets called
13:07:49 <Peaker> (instead of the either O(1) FPU inaccurate result, or O(result) "slow" logBase computation)
13:09:47 <Peaker> it seems to be correct
13:11:06 <Peaker> I wonder if I can get rid of the error there, and have senseful semantics
13:11:28 <Olathe> > concatMap (\x -> [10^x, 10^(x+1) - 1]) [0..5]
13:11:30 <lambdabot>   [1,9,10,99,100,999,1000,9999,10000,99999,100000,999999]
13:11:38 <EvilTerran> log_0 is only defined at 0, i believe
13:11:48 <Olathe> > map f.concatMap (\x -> [10^x, 10^(x+1) - 1]) [0..5]
13:11:49 <lambdabot>   Couldn't match expected type `a -> [a1]'
13:11:50 <EvilTerran> actually, it's not defined anywhere, is it?
13:12:31 <Olathe> > (==[2]).nub.map length.group.map (logBase 10).concatMap (\x -> [10^x, 10^(x+1) - 1]) [0..5]
13:12:32 <lambdabot>   Couldn't match expected type `a -> [t]'
13:12:40 <Olathe> > (==[2]).nub.map length.group.map (floor.logBase 10).concatMap (\x -> [10^x, 10^(x+1) - 1]) [0..5]
13:12:41 <lambdabot>   Couldn't match expected type `a -> [b]' against inferred type `[t]'
13:12:54 <maltem> EvilTerran: at least I have never seen anyone define it, just for the sake of the 0
13:13:38 <EvilTerran> Peaker, how does that one react to negative inputs / bases?
13:13:41 <michaelcdever> Cale: http://hpaste.org/13586
13:14:02 <Olathe> > (==[2]).nub.map length.group.map (floor.logBase 10).concatMap (\x -> [10^x, 10^(x+1) - 1]) $ [0..5]
13:14:03 <lambdabot>   False
13:14:06 <vixey> :t L.readFile
13:14:07 <Peaker> EvilTerran: not very well :-)
13:14:07 <lambdabot> Not in scope: `L.readFile'
13:14:17 <vixey> :t Data.ByteString.Lazy.readFile
13:14:17 <Peaker> EvilTerran: I think its easier to just put that part outside
13:14:18 <lambdabot> FilePath -> IO BSLC.ByteString
13:14:24 <EvilTerran> michaelcdever, make that import "import qualified Data.ByteString.Lazy.Char8 as L" instead
13:14:26 <Olathe> > all (==2).map length.group.map (floor.logBase 10).concatMap (\x -> [10^x, 10^(x+1) - 1]) $ [0..5]
13:14:29 <lambdabot>   False
13:14:29 <Olathe> > all (==2).map length.group.map (floor.logBase 10).concatMap (\x -> [10^x, 10^(x+1) - 1]) $ [0..]
13:14:31 <lambdabot>   False
13:14:42 <vixey> michaelcdever, but you didn't put in a FilePath?
13:14:42 <Olathe> Peaker: all (==2).map length.group.map (floor.logBase 10).concatMap (\x -> [10^x, 10^(x+1) - 1]) $ [0..]
13:14:42 <Peaker> EvilTerran: I think this is the dual of (^) (fast O(logN) algorithm instead of naive O(N) one)
13:15:03 <Olathe> Peaker: If it gives False, it fails. If it doesn't stop for a few hours, it probably works.
13:15:20 <Peaker> Olathe: using the floating point logBase?
13:15:24 <Olathe> Using yours.
13:15:43 <Olathe> Replace logBase with iLogBase.
13:16:08 <Peaker> Olathe: trying to decipher that :)
13:16:23 <Olathe> > concatMap (\x -> [10^x, 10^(x+1) - 1]) $ [0..] -- the core
13:16:23 <EvilTerran> Peaker, well, if it's undefined for base<0 or n<0, it may as well be the same for the (==0) cases
13:16:24 <lambdabot>   [1,9,10,99,100,999,1000,9999,10000,99999,100000,999999,1000000,9999999,1000...
13:16:35 <Olathe> It gives the min and max for each number of digits.
13:17:24 <Olathe> You should get [1, 1, 2, 2, 3, 3..] which groups to [[1, 1], [2, 2], [3, 3]..]
13:17:39 <Olathe> So, if all the lengths of those groups are two, great !
13:18:05 <Olathe> Hmm...
13:18:17 <EvilTerran> > all (==2).map length.group.map (round.logBase 10).concatMap (\x -> [10^x, 10^(x+1) - 1]) $ [0..]
13:18:18 <lambdabot>   False
13:18:22 <Olathe> all (==2).map length.group.map digitCount.concatMap (\x -> [10^x, 10^(x+1) - 1]) $ [0..]
13:18:24 <Olathe> There.
13:18:46 <Peaker> Olathe: ah, I see. Well, its integral-based, so if it works for the first 3-4 it will probably work forever
13:18:49 <Olathe> > let digitCount = length.show in all (==2).map length.group.map digitCount.concatMap (\x -> [10^x, 10^(x+1) - 1]) $ [0..]
13:18:51 <Peaker> Olathe: No FP monsters in there
13:19:02 <Cale> michaelcdever: Yeah, just use Data.ByteString.Lazy.Char8 instead.
13:19:05 <lambdabot>   thread killed
13:19:11 <Olathe> > let digitCount = length.show in map length.group.map digitCount.concatMap (\x -> [10^x, 10^(x+1) - 1]) $ [0..]
13:19:13 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
13:19:37 <Cale> michaelcdever: Or if you need UTF8 support, use one of the UTF8 packages which provide ByteString translation.
13:19:40 <Olathe> Peaker: Yeah, it should, but letting it run for a few minutes gives a huge margin of error.
13:19:56 <mmorrow> Heffalump: ping
13:20:23 <Cale> Guenni: hmm...
13:20:34 <michaelcdever> lads yes are geniuses! im reading using Data.ByteString.Lazy as L, Data.ByteString.Lazy.Char8 as C, then do
13:20:34 <michaelcdever> content <- L.readFile pat
13:20:34 <michaelcdever> let tokens = ( C.split ' ' content
13:20:35 * RayNbow notices a few new Haskell logos have been submitted after the deadline
13:20:35 <michaelcdever> )
13:21:40 <EvilTerran> michaelcdever, do you particularly need the Word8 version?
13:21:57 <EvilTerran> i've ever only needed one or the other
13:22:03 <Cale> Guenni: So there's no problem connecting to the data source?
13:22:18 <michaelcdever> nope, terran, just needed to suss out how to get it to read properly, ive not done file io with haskell before, and its a bit confusing
13:22:23 <Peaker> Olathe: its running for a while now
13:22:33 <Heffalump> mmorrow: hiya
13:22:46 <Heffalump> shame about your sidesLinear rewrite, it looked like it ought to have helped.
13:22:47 <Cale> Guenni: Could it just have something to do with the column types?
13:23:00 <michaelcdever> :t C.ByteString
13:23:02 <lambdabot> Couldn't find qualified module.
13:23:13 <Heffalump> Though I've concluded that unsafe name supplies and optimisation just don't go together, so I'm not using -O until I can replace it with something a bit less hacky.
13:23:26 <Peaker> Olathe: there's the special case of iLogBase 10 0 -- I return (0, 0) in that case (the result is (floorOfLog, remainingFactors)
13:23:26 <Olathe> Peaker: Ahh, cool :)
13:23:42 <Peaker> Olathe: still running...
13:23:58 <Olathe> I'd do digitCount 0 = 1 myself, but it's not that big a deal.
13:24:30 <Peaker> Olathe: its what I did: http://hpaste.org/13585
13:24:37 <michaelcdever> how do i get the information for bytestring, i tried using :t Data.ByteString
13:24:49 <michaelcdever> but it gives an error
13:25:21 <Peaker> Now the question is how to add support for negatives in the prettiest way, and it may be a useful addition to the stdlib?
13:25:27 <mmorrow> Heffalump: hey, bummer about the cps thing.
13:25:42 <Heffalump> I'll just work on optimising it to get called less instead.
13:25:51 <mmorrow> Heffalump: it should work in a list comp something like
13:25:57 <mmorrow> take 10 [ n | n <- iterate uniq (uniq()) ]
13:26:11 <vixey> , take 10 [ n | n <- iterate uniq (uniq()) ]
13:26:17 <mmorrow> that wont work in lunabot
13:26:22 <Heffalump> mmorrow: that's fine if you actually want 10 at the same time, but not if you want the 10 in completely different places
13:26:23 <mmorrow> for some reason
13:26:23 <lunabot>  [0,0,0,0,0,0,0,0,0,0]
13:26:29 * vixey doesn't know what uniq is
13:26:49 <mmorrow> oh, the take 10 was irrelevant
13:26:50 <rwbarton> , src 'uniq
13:26:57 <lunabot>  uniq :: forall a . a -> Int
13:26:58 <Heffalump> also, even once I fixed it so that they didn't all return 0, by disabling optimisations on a separate Supply module, I found other computations getting lifted when I didn't want them to be.
13:27:09 <Peaker> > logBase (-2) 1
13:27:11 <lambdabot>   NaN
13:27:13 <mmorrow> just the fact that you need to somehow force a uniq/newName before you call it again
13:27:14 <Peaker> > logBase (-2) 2
13:27:16 <lambdabot>   NaN
13:27:17 <Peaker> > logBase (-2) 4
13:27:19 <lambdabot>   NaN
13:27:36 <Heffalump> well, the main point was that your code didn't work any better (or worse) than mine :-)
13:27:39 <Peaker> > logBase 2 (-1)
13:27:39 <mmorrow> Heffalump: yeah, it's a pain
13:27:41 <lambdabot>   NaN
13:27:53 <Peaker> EvilTerran, Olathe: It seems the existing logBase can't handle negatives either
13:28:02 <roconnor> huh?  is uniq a function that returns 0?
13:28:32 <mmorrow> Heffalump: i'm interested though in the use case you have in mind/were trying though, because it'd be nice if there was a solution.
13:28:36 <ski_> @free uniq :: a -> Int
13:28:37 <lambdabot> uniq = uniq . f
13:28:59 <Heffalump> mmorrow: yes, a robust solution would be nice, but really it serves me/us right for breaking referential transparency :-)
13:29:31 <mmorrow> ski_: uniq forces it's first arg, then unsafePerformIO readMVars to give you a fresh var
13:29:41 <mmorrow> Heffalump: haha
13:30:04 <Heffalump> I tried going back to ghc 6.6 btw (I forget whether with my code or yours) and it didn't work with optimisations in any of 6.10, 6.8 or 6.6
13:30:16 <roconnor> mmorrow: is that safe?
13:30:26 <Heffalump> roconnor: of course not
13:30:31 <Heffalump> it's an *unsafe* name supply :-)
13:30:33 <Olathe> Peaker: Oh, no, it can't.
13:30:37 <vixey> mmorrow, btw, http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=681#a716 :/
13:30:39 <roconnor> why no unsafe in it's name?
13:30:41 <mmorrow> roconnor: you have to use it "correctly"
13:30:51 * roconnor isn't exactly sure what is safe and unsafe.
13:31:10 <opqdonut> why are you messing around with uniq?
13:31:25 <mmorrow> roconnor: it's not that using it incorrectly is unsafe per se, it's that you'll just get the same number twice
13:31:40 <opqdonut> safe name supplies are easy enough to use
13:31:57 <roconnor> I guess unsafe is reserved for code that could segfault.
13:32:00 <Peaker> Olathe: I think my function is fast and useful. I wonder what I can do with it. Putting in on HaskellWiki, to start..
13:32:02 <mmorrow> opqdonut: i use that function in various code i have to gen uniq names hackishly
13:32:10 <gchin> hello, question: is it possible to define (+) for type (Double, Double) and use seamlessly w/o getting conflicts with prelude's (+)?
13:32:34 <Guenni> cale: sry the window was hidden
13:32:41 <rwbarton> gchin: What do you mean "(+) for type (Double, Double)"?
13:32:41 <Heffalump> Guenni: use the Num type class
13:32:52 <Guenni> Cale: I really don't know
13:32:59 <Heffalump> opqdonut: I disagree.
13:33:01 <roconnor> gchin: theoretically you can make a Num instance for (Num a) => (a,a)
13:33:01 <opqdonut> gchin: yes
13:33:06 <vixey> http://comonad.com/haskell/category-extras/src/Control/Comonad/Supply.hs
13:33:07 <roconnor> but it isn't recommended
13:33:10 <Heffalump> safe name supplies are a pain to use unless you already have a monad
13:33:19 <vixey> Heffalump, or Comonad ^
13:33:24 <Guenni> Cale: I'll try that
13:33:30 <EvilTerran> or Arrow, Applicative, etcetc
13:33:34 <gchin> roconnor: is it preferable to just define a "vectorAdd" function then?
13:33:43 <roconnor> gchin: making a new type would be better
13:33:44 <Heffalump> I still haven't found a real use for Comonads, so I'm highly unlikely to have one lying around.
13:33:45 <EvilTerran> some existing model of side-effects, i guess
13:33:50 <Heffalump> I don't even understand them.
13:33:52 <roconnor> gchin: I'd write a new operator <+>
13:33:59 <opqdonut> or a newtype
13:34:06 * vixey wants Heffalump to use this comonad :P
13:34:16 <Peaker> > logBase 1 1
13:34:18 <lambdabot>   NaN
13:34:19 <roconnor> gchin: in fact I'd write a new operator and a new type
13:34:19 <Peaker> > logBase 1 10
13:34:20 <Heffalump> point me at a URL summarising how to do it and I'll take a quick look :-p
13:34:21 <lambdabot>   Infinity
13:34:25 <mmorrow> vixey: heh, " " as an operator :)
13:34:25 <Heffalump> but don't hold your breath
13:34:34 <gchin> hmm, okay sounds good. thanks roconnor , opqdonut
13:35:12 <vixey> mmorrow, so I got a "working" parser now (which I guess means that I haven't found any more bugs yet)
13:35:23 <mmorrow> vixey: nice.
13:35:23 <vixey> I prove +++ is fair for ReadP in Coq though
13:35:41 <vixey> (which everyone already knew)
13:35:52 <mmorrow> ooh, interesting. i'd love to see that code (i've never used Coq)
13:36:35 <vixey> mmorrow, it's not actually readable :p http://github.com/odge/k/tree/master/ReadP.v
13:36:43 <michaelcdever> halp lol
13:36:49 <vixey> add is +++ and bind is >>=
13:37:43 <vixey> mmorrow, I tried to do the whole theory of PEG parsers but I got tired of it quickly..
13:37:54 <mmorrow> Heffalump: it seems to me that you should be able to use the "unsafe" name supply so that it works regardless of optims
13:38:05 <mmorrow> vixey: heh, /me looks
13:38:19 <vixey> Heffalump, have you seen stuff ike freshML though?
13:38:32 <Heffalump> vixey: I'm aware of it, yes.
13:38:39 <michaelcdever> right, i have Datta.ByteString.Lazy.Char8 as C, when I do :t C.split I get Data.ByteString.Lazy.Char8.split :: Char -> C.ByteString -> [C.ByteString] but if I try to do :t C.ByteString i get an error, same if I do Data.ByteString.Lazy.Char8.ByteString
13:38:43 <vixey> Heffalump, what do you think?
13:38:53 <Heffalump> neat stuff, but I don't know how you could embed it into Haskell
13:38:57 <EvilTerran> michaelcdever, that's because C.ByteString is a type
13:39:00 <EvilTerran> types don't have types
13:39:03 <Heffalump> though I haven't thought about it very hard either
13:39:06 <vixey> Heffalump, yeah other than monadically
13:39:12 <michaelcdever> i want to return the list from my function, but I dont know what the declaration should b
13:39:17 <michaelcdever> C.ByteString gives errors
13:39:26 <mmorrow> vixey: very cool
13:40:01 <michaelcdever> IO is so finicky in haskell. it could be hella simpler
13:40:12 <EvilTerran> it's very logical once you get used to the rules
13:40:15 <vixey> mmorrow, some time I might give a proper specification of operator parsing and unparsing but atm I am just using this haskell code (from the moonpaste)
13:40:18 <EvilTerran> and the restrictions are worthwhile, honest
13:40:27 <vixey> michaelcdever, how it could be simpler?
13:40:39 <michaelcdever> there doesnt seem to be a declaration of rules that i can see
13:40:42 <EvilTerran> ?go io monad don't care
13:40:45 <lambdabot> http://sigfpe.blogspot.com/2007/11/io-monad-for-people-who-simply-dont.html
13:40:46 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care
13:40:58 <EvilTerran> michaelcdever, have a look at that, it might help
13:41:01 <vixey> michaelcdever, well they are derived rules from the type system and the types of the primitives
13:41:22 <vixey> michaelcdever, so... I guess it is sort of tricky becaues you are building up intuition about _that_ at the same time as trying to figure out IO
13:43:33 <michaelcdever> lol, yes its trying to learn everything at once lol, theres only so much my brain can take
13:43:51 <michaelcdever> and im on a tight timeline lol, self inflicted woes i know, but still
13:44:05 <vixey> mmorrow, (because I bet there are _still_ bugs though..... I just have to come across them)
13:44:30 <mmorrow> Heffalump: did you see this Id module from Helium? http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=715
13:44:43 * vixey guilty until proven innocent
13:45:01 <mmorrow> vixey: off with their heads!
13:45:10 <Heffalump> mmorrow: yeah, but it didn't look particularly different from what we were doing
13:45:32 <Heffalump> I suspect it has the same problems if you're not careful with the unsafe stuff
13:46:45 <mmorrow> Heffalump: yeah totally. i think it's just unavoidable that you have to use an (unsafe) name supply in a certain way (which ensures the last name gets forced before you use the next)
13:47:02 <BMeph> s/guilty/_presumed_ guilty/
13:47:14 <Heffalump> mmorrow: I don't think that's necessary at all
13:47:19 <Heffalump> I don't care about the order they appear in.
13:47:36 <Heffalump> I just need things that I think logically are separate names to actually be separate thunks.
13:48:09 <mmorrow> Heffalump: exactly
13:48:10 <mmorrow> hmm
13:48:46 <Raevel> what program can i use to locate bottlenecks?
13:50:45 * maltem resists some stupid pun on bottlenecks
13:50:52 <Raevel> thank you
13:51:18 <michaelcdever> right have it kinda worked out in my head a bit more, thanks terran
13:51:23 <maltem> Raevel: heh. anyways, ghc provides a lot of profiling flags
13:51:25 <Guenni> Heffalump: Hi, I just tried inserts with numbers only, it also blows up
13:51:31 <Raevel> maltem: oh okay
13:51:42 <Heffalump> mmorrow: the problem I had afterwards was that I have a utility function that makes a variable with a constant name prefix.
13:51:47 <mmorrow> Heffalump: it'd be interesting to see what using an IORef/MVar (() -> Int) gets us
13:51:51 <Heffalump> And that was getting lifted so that the name was only created once.
13:51:58 <Heffalump> what would you do with that?
13:52:14 <eu-prleu-peupeu> the haskell logo competition has some really ugly logos :)
13:52:19 <BMeph> Raevel: Just use the one to find turtlenecks, and put a 'bot in it... ;p
13:52:34 <mmorrow> Heffalump: i'm not sure exactly yet. i'm gonna play around with it.
13:53:01 <Raevel> oh there was a rwh chapter about it, yay
13:53:52 <michaelcdever> when I return the results of Data.ByteString.Lazy.Char8.words content, it has to be returned as IO [C.ByteString] ???
13:53:59 <vixey> @go On generating unique names
13:54:03 <lambdabot> http://journals.cambridge.org/production/action/cjoGetFulltext?fulltextid=2581816
13:54:03 <lambdabot> Title: CJO - Abstract - Functional Pearl: On generating unique names
13:54:46 <vixey> @go citeceer On generating unique names
13:54:48 <lambdabot> No Result Found.
13:54:52 <vixey> :.
13:55:28 <Heffalump> vixey: that's a more principled way to do it, but you have to split name supplies which is a pain
13:55:36 <michaelcdever> and that IO [C.ByteString] has Chunk "string" Empty in it, where string is words in the file.... strangeness... how do i get just the ByteString out of it?
13:55:40 <vixey> aww it was not published :(
13:55:46 <michaelcdever> like just the words
13:55:52 <Heffalump> vixey: what wasn't?
13:56:03 <vixey> On generating unique names
13:56:13 <Heffalump> Isn't that Lennart's paper? I'm sure it was.
13:56:21 <vixey> I mean, not published to the interenet
13:56:32 <Heffalump> I'm sure there are copies around.
13:56:39 <mmorrow> i can't seem to find one
13:56:47 <michaelcdever> sooo frustrating
13:56:55 <Heffalump> hmm, perhaps not then. Try emailing Lennart for one.
13:57:01 <rwbarton> michaelcdever: what are you trying to do?
13:57:09 <vixey> hmmmmm.........  where gen _ r = Node { supplyValue  = unsafePerformIO (genSym r),
13:57:10 <Heffalump> I've got a hard copy somewhere around.
13:57:44 <vixey> that seems needless
13:58:08 <rwbarton> michaelcdever: Chunk is internal to ByteString, you shouldn't be messing with it
13:58:54 <rwbarton> Oh I see, it has the default Show instance.
14:00:00 <michaelcdever> trying to get the words out of the file and return them either as [String] or [ByteString], i dont mind which, but when i read teh words, it returns a list with Chunk in it
14:00:11 <maltem> eu-prleu-peupeu: still I'm just astounded by how many logo proposals there are
14:00:30 <rwbarton> michaelcdever: That *is* a ByteString
14:00:33 <rwbarton> michaelcdever: Just follow the types
14:01:00 <vixey> does anyone know why this Supply Comonad uses unsafePerformIO?
14:01:10 <rwbarton> do contents <- C.readFile filename; let ws = C.words contents; ... should do it
14:01:48 <vixey> oh I see ..
14:02:20 <eu-prleu-peupeu> maltem: yes :) amazing
14:02:49 <michaelcdever> http://hpaste.org/13588 thats what i'm trying to do there
14:05:34 <michaelcdever> ahh, should i unpack it then?
14:06:11 <michaelcdever> nope... that just converts the whole ByteString to a String
14:07:05 <dmwit> :t Data.ByteString.Lazy.Char8.words
14:07:07 <lambdabot> BSLC.ByteString -> [BSLC.ByteString]
14:07:29 <mux> you should only use the Char8 modules in your case
14:07:37 <dmwit> michaelcdever: Try just using the C.readFile rather than L.readFile.
14:07:38 <dmwit> yeah
14:08:21 <dmwit> Also, that whole thing can be boiled down to "splitFile = liftM C.words . C.readFile"
14:08:52 <dmwit> Some prefer to use fmap instead of liftM there.
14:09:43 <mux> heh, I just annotated your code on hpaste to basically do the same thing dmwit was saying
14:10:00 <mux> seems like bot announces aren't working?
14:10:12 <dmwit> Yeah, and they haven't been for several months. =/
14:10:34 <mux> oh
14:10:55 <michaelcdever> hmmm, fmap just gives more errors, I have it done as fmap C.words . (C.readFile pat)
14:10:56 <chrisdone> @hoogle [a] -> (a,a)
14:10:56 <lambdabot> Test.QuickCheck two :: Monad m => m a -> m (a, a)
14:10:57 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
14:10:57 <lambdabot> Prelude divMod :: Integral a => a -> a -> (a, a)
14:11:07 <mux> michaelcdever: see my annotation
14:11:11 <chrisdone> > two [1,2]
14:11:13 <lambdabot>   Not in scope: `two'
14:11:17 <mux> michaelcdever: http://hpaste.org/13588#a1
14:11:18 <chrisdone> > Test.QuickCheck.two [1,2]
14:11:20 <lambdabot>   Not in scope: `Test.QuickCheck.two'
14:11:22 <chrisdone> k
14:11:30 * BMeph runs unsafeCoerseMaintainersIntoRestoringHPasteAnnouncements...and fails.
14:11:47 <mux> @users
14:11:48 <lambdabot> Maximum users seen in #haskell: 637, currently: 634 (99.5%), active: 17 (2.7%)
14:11:54 <mux> this channel is really getting crowded :)
14:12:29 <michaelcdever> as it needs to be done based on a fileim still getting the chunks and empty
14:12:29 <dmwit> michaelcdever: That is very different from what I wrote. =)
14:12:56 <michaelcdever> lol... sorry dmwit
14:13:01 <rwbarton> michaelcdever: "chunks and empty" *is* a ByteString
14:13:04 <chrisdone> :t (head &&& head . tail)
14:13:06 <lambdabot> forall a. [a] -> (a, a)
14:13:06 <chrisdone> delicious
14:13:10 <rwbarton> michaelcdever: that's how it's displayed
14:13:15 <chessguy> mux:  agreed, personally i think it should be split up somehow
14:13:26 <michaelcdever> right theres something here im obviously missing
14:13:33 <michaelcdever> back to google to try and solve it
14:13:38 <mux> chessguy: how would you split it though?
14:13:40 <Peaker> Olathe, EvilTerran: Wrote http://www.haskell.org/haskellwiki/ILogBase
14:13:52 <rwbarton> michaelcdever: What's not working about it?  It compiles, apparently?
14:14:10 <chessguy> mux:  not sure. maybe a beginners' channel would be appropriate, like the beginner mailing list
14:14:16 <BMeph> michaelcdever: Try writing it as: fmap (C.words . C.readFile) pat
14:14:32 <mux> based on skills? #haskell-myheadhurts #haskell-icandoIO #haskell-iwroteamonadtransformerstutorial #haskell-oleg
14:14:37 <BMeph> I.e., 'C.readfile pat' is not a function. :)
14:14:42 <chessguy> haha
14:14:46 <chessguy> i wouldn't go that far :)
14:14:51 <dmwit> BMeph: what?
14:14:53 <chessguy> just -beginner and this one
14:15:03 <chrisdone> nickAndMsg :: String -> Maybe (String,String)
14:15:03 <chrisdone> nickAndMsg = ((head &&& head . tail) <$>) . matchRegex lineRegex
14:15:03 <chrisdone> :D
14:15:10 <dmwit> BMeph: fmap C.words . C.readFile $ pat -- much more like it
14:15:13 <vixey> :t (head &&& (head &&& const ()) . tail)
14:15:15 <lambdabot> forall a. [a] -> (a, (a, ()))
14:15:20 <vixey> :t (head &&& (head &&& (head &&& const ()) . tail) . tail)
14:15:21 <lambdabot> forall a. [a] -> (a, (a, (a, ())))
14:15:24 <vixey> :t (head &&& (head &&& (head &&& (head &&& const ()) . tail) . tail) . tail)
14:15:25 <lambdabot> forall a. [a] -> (a, (a, (a, (a, ()))))
14:15:28 <mux> chessguy: I guess it makes sense to separate people talking about category theory and olegisms from people that have problems with haskell's syntax or operator precedence
14:15:41 <mux> that sounds somehow elitist though
14:15:58 <mux> it's also by reading about stuff I didn't understand that it made me want to learn more
14:15:59 <chessguy> mux: we're not banning anyone from either channel
14:16:07 <mux> right
14:16:41 <baaba> @let loeb fs = fmap (\f -> f (loeb fs)) fs
14:16:44 <lambdabot>  Defined.
14:16:46 <baaba> @let loeb fs = fmap (\f -> f (loeb fs)) fs
14:16:47 <lambdabot>  <local>:25:0:
14:16:47 <lambdabot>      Warning: Pattern match(es) are overlapped
14:16:47 <lambdabot>               I...
14:16:49 <EvilTerran> Peaker, some of the code lines there are showing up as standard text to me
14:17:12 <chrisdone> @let loeb x = fmap (\a -> a (loeb x)) x
14:17:13 <lambdabot>  <local>:25:0:
14:17:13 <lambdabot>      Warning: Pattern match(es) are overlapped
14:17:13 <lambdabot>               I...
14:17:18 <baaba> > loeb [head, length]
14:17:21 <rwbarton> @let foo 1 = 1
14:17:22 <rwbarton> @let foo 2 = 2
14:17:25 <lambdabot>  Defined.
14:17:25 <rwbarton> > foo 1
14:17:28 <lambdabot>  Defined.
14:17:30 <lambdabot>   1
14:17:30 <baaba> er, was it the other way around
14:17:33 <lambdabot>   thread killed
14:17:39 <baaba> > loeb [length, head]
14:17:41 <lambdabot>   [2,2]
14:17:42 <baaba> right
14:17:47 <EvilTerran> here we go with loeb again
14:17:52 <vixey> baaba, and??
14:18:07 <baaba> just wondering what lambdabot does with multiple definitions :P
14:18:20 <dmwit> Same thing GHC does, I guess.
14:18:22 <mux> lambdabot basically puts all those definitions in a L.hs file
14:18:31 <mux> and lods it dynamically
14:18:46 <rwbarton> how hard would it be to allow @let data Foo = Foo?
14:18:55 <vixey> rwbarton, well someone would have to implement it..
14:19:18 <mux> I'd rather have someone implement this for ghci first :-)
14:19:18 <rwbarton> vixey: I see your point :)
14:19:25 <mux> not to pick on lambdabot which is very useful
14:19:37 <rwbarton> I guess we don't want to allow @let import System.IO.Unsafe
14:19:43 <vixey> mux, you can use lambdabot locally like ghci
14:19:49 <vixey> instead of
14:19:55 <mux> yes I know, but I'd rather use ghci was my point
14:20:05 <michaelcdever> rwbarton: it compiles alright, but the function still has to be an IO function, IO [C.ByteString] all I want is the strings contained in the file
14:20:05 <vixey> even if lambdabot supported @let data?
14:20:12 <michaelcdever> which would be the words in the file
14:20:20 <mux> well that would become a problem, which is why I'd rather see it in ghci first :-P
14:20:25 <rwbarton> michaelcdever: Oh.  You can't do that, because your function does IO.
14:20:33 <michaelcdever> ah lol
14:20:34 <ac> hurm, I just upgraded to ghc 6.10.1, and now a lot of hackage packages are failing with errors about various conflicts in Data.
14:20:44 <rwbarton> michaelcdever: You have to use its result inside another do block in the IO monad
14:20:48 <vixey> I don't know what you mean. Is it important that it's called 'ghci' regardless of whether it's the best tool?
14:21:08 <rwbarton> michaelcdever: Otherwise, you would have no control over when or how many times the IO actually happens.
14:21:12 <mux> many of the ghc 6.10 build failures can be fixed with s/Control.Exception/Control.OldException/
14:21:42 <mux> I actually haven't had any other myself
14:21:55 <michaelcdever> ahh, ok hang on i think its clicking now, right, so if i had a bool in there, my function would be FilePath -> Bool, if I wanted to return a bool
14:22:18 <michaelcdever> and i can still have it like that, and complete the IO inside it
14:22:28 <michaelcdever> and then return the bool
14:22:31 <ac> Like: Data/IntMap.hs:182:7: Could not find module `Data.Data': it is a member of package base, which is hidden
14:22:32 <rwbarton> If you have a function that just needs the FilePath (= String) to produce a Bool, like "is the first character A", then that function can be :: FilePath -> Bool
14:22:43 <ac> mux: would that be related to Control.Exception?
14:22:47 <rwbarton> If you have a function that wants to determine whether the file exists, say, it must be FilePath -> IO Bool
14:23:03 <michaelcdever> ahhh right, the first one
14:23:03 <michaelcdever> :D
14:23:03 <michaelcdever> thanks rw
14:23:08 <rwbarton> No problem.
14:23:08 <mux> ac: nope, unfortunately that looks like a deeper problem
14:23:17 <ac> and: Data/Array/IO/Internals.hs:46:60: Duplicate instance declarations: instance Typeable2 IOArray
14:23:21 <mux> also, check if the packgae doesn't have a specific flag
14:23:26 <mux> some have one for base4
14:23:41 <ac> 6.8 is base3, and 6.10 is base4?
14:23:49 <mux> yes
14:23:57 <michaelcdever> this is probably going be a silly question, but how would i access the head of the list of words then?
14:24:10 <michaelcdever> like is the first word 'a'
14:24:42 <ac> perhaps I should downgrade back to ghci 6.8
14:24:43 <rwbarton> by binding it to a variable in a do block, and then using that variable
14:24:47 <rwbarton> or by binding it to a pattern
14:24:50 <mux> ac: what is that package?
14:25:09 <michaelcdever> right ill come back later, after trying
14:25:18 <rwbarton> do firstWord : otherWords <- wordsFromFile "filename"; if unpack firstword == "a" then ... else ...
14:25:40 <ac> mux: what package am I trying to install? Many fail, like cabal-install for example
14:25:52 <mux> ac: what was that particular one, to begin with?
14:26:58 <Jimi__Hendrix> whats the recommended haskell tutorial?
14:27:20 <ac> I originally wanted to install synthesizer and YampaSynth, but it seems all packages that depend on containers, for example, fail
14:27:27 <vixey> ?where LYAH
14:27:27 <lambdabot> www.learnyouahaskell.com
14:27:37 <pejo> ac, cabal-install works just fine for me with 6.10
14:27:38 <cjb> Jimi__Hendrix: there's the online copy of _Real World Haskell, Learn You A Haskell, and Yet Another Haskell Tutorial
14:27:38 <mux> Jimi__Hendrix: there are many, but I'd particularly recommend reading the RWH book (available online), as well as "haskell for C programmers" if you come from an imperative background
14:27:42 <mux> @where RWH
14:27:42 <lambdabot> is http://www.realworldhaskell.org/blog/
14:27:50 <sjanssen> @users
14:27:50 <lambdabot> Maximum users seen in #haskell: 637, currently: 631 (99.1%), active: 22 (3.5%)
14:27:50 <opqdonut> haskell for C programmers isn't that good
14:27:53 <sjanssen> @flush
14:27:57 * cjb wants a learnyouahaskell PDF
14:28:00 <opqdonut> yet another haskell tutorial is pretty good
14:28:03 <Jimi__Hendrix> ya ill take the C book please mister bot...
14:28:14 <EvilTerran> sjanssen, :)
14:28:15 <mux> opqdonut: at that time, it made some things "click" that other tutorials failed to explain me properly
14:28:24 <opqdonut> might be
14:28:24 <mux> I like YAHT too
14:28:38 <opqdonut> it's the only one I've properly read
14:28:44 <mux> and so, http://book.realworldhaskell.org/read/
14:28:55 <Jimi__Hendrix> ok
14:29:00 <Jimi__Hendrix> ill try this and the C one
14:29:03 <opqdonut> school of expression was pretty good too
14:29:05 <stu8ball> OpenOffice is evil, but you  have to keep it installed just incase you do come across that kind of situation. Open LYAH in OO.o and re-save it as PDF, cjb.
14:29:07 <opqdonut> but I read it too late, mostly
14:29:10 <ac> yeah, I liked YAHT too
14:29:18 * neun has ordered RWH tonight
14:29:51 <mux> although, I'd like to add that the key to mastering more advanced type hackery in haskell was reading TAPL
14:29:56 <sbahra> Hi mux
14:30:01 <mux> hello samy, how are you?
14:30:07 <EvilTerran> TaPL is excellent
14:30:17 <sbahra> :) Not bad. Yourself?
14:30:20 <EvilTerran> ?where tapl
14:30:21 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
14:30:23 <mux> EvilTerran: I think it's the best CS book I ever read
14:30:24 <sbahra> Seem to have been really busy with something lately.
14:30:30 <sbahra> LYAH?
14:30:45 <sbahra> TaPL
14:30:45 <sbahra> heh
14:30:51 <EvilTerran> mux, yeah, it's one of the few that actually earns its cover price
14:30:55 <maltem> @where gentle
14:30:56 <lambdabot> http://www.haskell.org/tutorial/
14:31:02 <sbahra> cool
14:31:15 <maltem> (since anyone is saying what their favourite intro is...)
14:31:51 * mux is quite happy with the code he whipped to perform searches using a Trie [Int] as an inverted index from words to indices
14:32:13 <michaelcdever> rwBarton you are a genius
14:32:42 <michaelcdever> its always the simplest things that are the most compicated
14:32:43 <michaelcdever> !
14:33:03 <vixey> it is?
14:33:17 <michaelcdever> for me anyway :D
14:33:19 <ajhannan> @where Trie
14:33:20 <lambdabot> I know nothing about trie.
14:33:26 <michaelcdever> because i get in my own way :D
14:33:27 <mux> bytestring-trie package on hackage
14:33:35 <ajhannan> thanks
14:33:45 <mux> I need to send the author these Binary instances I'm using
14:34:10 <mux> since the datatype isn't exposed, I've had to add them to the package itself
14:34:23 <Jimi__Hendrix> also is it imperative that i understand that fancy x + y -> v :q thing when defining a function?
14:34:52 <mux> not sure what you're referring to
14:35:54 <blackdog_> mux: have been using bytestring-trie too. it's pretty nippy :)
14:36:29 <mux> the monad instance is very funny
14:38:36 <sbahra> mux, are you still using FreeBSD?
14:38:49 <BMeph> stu8ball: "OpenOffice is evil"? :)
14:39:03 <mux> sbahra: sure I am, just not coding for it anymore
14:39:16 <pejo> mux, why did you stop?
14:39:19 <sbahra> mux, yes, I saw your commit bit fly away :(
14:39:23 <mux> although I failed to make that official for now
14:39:32 <mux> pejo: lack of free time
14:39:51 <sbahra> mux, you might be interested (well, we are interested) in helping us out, #haskell-FreeBSD. I'm busy until ~11th, but I'm back to it afterwards.
14:40:13 <sbahra> mux, working on ghc update (and infrastructure to allow others involved to do this easily) and porting a lot of hackage. I'm working on a cabal2port.
14:40:25 <sbahra> Some FFIs too.
14:40:27 <mux> I've seen some new activity on this side indeed, been pleased to see new haskell related packages added to the ports tree
14:40:35 <sbahra> Mostly boring, but useful to anyone using Haskell on FreeBSD.
14:44:24 <Gracenotes> it's interesting that many esoteric languages are stack-based :)
14:45:28 <gbacon> can strictness analysis make passing _|_ to a function that matches it with _ error anyway?
14:45:52 <gbacon> > let f _ n = n + 1 in f undefined 3
14:45:54 <lambdabot>   4
14:46:01 <opqdonut> strictness analysis doesn't change semantics
14:46:08 <koeien> gbacon: no
14:46:27 <Heffalump> gbacon: what about let g _ = 1 ; f x n = n + g x in f undefined 3 ?
14:46:53 <gbacon> > let { g _ = 1; f x n = n + g x } in f undefined 3
14:46:55 <lambdabot>   4
14:47:20 <Heffalump> I know what it does, but what do you want it to do in your hypothetical strictness question?
14:47:31 <Heffalump> s/question/scenario/
14:47:35 <gbacon> I want it to be ignored!
14:47:49 <opqdonut> what to be ignored
14:47:51 <Heffalump> you want what to be ignored?
14:48:02 <gbacon> the _|_
14:48:09 <opqdonut> well it is, right?
14:48:20 <gbacon> no, that's why I'm asking.. I have a case where it's failing
14:48:27 <Heffalump> oh, right
14:48:35 <Heffalump> hpaste the code?
14:48:45 <BMeph> gbacon: Think about what you're saying. You're trying to tell the computer to ignore what your argument is, and analyze it at the same time. Sorry, but the artificial schizophrenia project hasn't finished yet... ;p
14:49:25 <vixey> gbacon, is it like
14:49:28 <vixey> f FOO = ....
14:49:31 <vixey> f _ = ....
14:49:44 <vixey> because it's still got to check the _|_ against FOO, which might cause _|_
14:49:52 <BMeph> gbacon: But Heffalump has the more useful advice: MOAR HPASTE plz kthxbai! ;P
14:50:20 <gbacon> BMeph: no.. I have (notionally) f _ x = g x in f undefined 42
14:50:23 <Heffalump> BMeph: I think the question was "can strictness analysis break my program". And the answer is "it shouldn't" :-)
14:50:53 <gbacon> but I'm getting Prelude.undefined exception
14:51:04 <koeien> ?hpaste
14:51:05 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:51:14 <Heffalump> gbacon: well, first, replace the undefined by an error call to verify that it really is that one
14:51:25 <Heffalump> secondly, check that your code isn't really like vixey suggested
14:51:27 <gbacon> I want the undefined to be ignored (or do I misunderstand the semantics of a _ match?)
14:51:41 <Heffalump> and thirdly, hpaste it, preferably enough for us to reproduce it
14:51:58 <vixey> gbacon, well consider what I asked you
14:52:28 <koeien> f ~(Con x)    is a lazy match right?
14:52:52 <Heffalump> koeien: yes.
14:53:10 <Heffalump> i.e. it always succeeds, and only is actually checked when x is forced.
14:53:14 <gbacon> vixey: ah, I see
14:54:29 <Peaker> I keep wanting a little vector thingie with fake Num instance for convenience... :P
14:54:51 <gbacon> passing a dummy value feels so C-ish
14:54:59 <gbacon> is there a better way?
14:55:05 <vixey> gbacon, of?
14:55:15 <michaelcdever> http://hpaste.org/13588#a3 ive got a search funtion done now, searchFIle, but i've problems with line 2 of it, searchFile [] pattern = False, could ye have a look for me please?
14:55:35 <opqdonut> gbacon: well () is a good dummy value
14:55:42 <vixey> Nothing
14:55:45 <michaelcdever> I know I'm probably doing something stupid again
14:55:46 <opqdonut> if you're free to choose the type
14:56:19 <gbacon> the type of the parameter in this case is (Double,Double,Double)
14:56:47 <rwbarton> michaelcdever: Just get rid of the "IO" in the type of searchFile
14:57:08 <gbacon> should I make the matches that do use that parameter lazy?
14:57:12 <vixey> gbacon, dunno what you are programming so.....
14:57:23 <michaelcdever> lol, amater mistake rwbaron :D
14:57:46 <koeien> gbacon: either you ignore it, or you don't. you could pass (undefined,undefined,undefined) instead of undefined
14:57:56 <koeien> gbacon: or, you could use a lazy match
14:58:01 <Peaker> I am toying with a simple SDL example. I want to use an exception to break my mainloop.  Exceptions just got a bit complicated, with ghc 6.10... What is the simplest way to do that?
14:58:15 <vixey> or something completely different....... it depends on what you're programming
14:58:19 <dmwit> michaelcdever: It's likely going to be a lot faster to pack the pattern once, then compare it to all the elements in your list.
14:58:22 <gbacon> thanks for your help all
14:58:24 <koeien> yes, it is not clear to me
14:58:40 <koeien> what you are trying to accomplish
14:58:46 <gbacon> vixey: I'm simulating multiple orthogonal sensors
14:58:48 <dmwit> searchFile bss pattern = any (== C.pack pattern) bss -- something like this, dunno if BS has an Eq instance, but I assume it does
14:58:54 <BMeph> Peaker: You could always wuss out and just use the (Control.)OldExceptions... ;)
14:59:12 <gbacon> some can "see" particular phenomenology, and others don't care
14:59:16 <michaelcdever> dmwit: i'll actually be searching for regex patterns, so i think i need to do it this way, and use my regex functions
14:59:17 <Plouj> yo
14:59:27 <Peaker> BMeph: what's the "right" way to raise something and catch it above?
14:59:36 <dmwit> michaelcdever: There's ByteString regex matching in the libraries already.
15:00:00 <Plouj> where did the circle brackets come from in "third (a, b, c) = c" on http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html ?
15:00:08 <dmwit> searchFile bss pattern = any (=~ pattern) bss -- with the appropriate imports ;-)
15:00:20 <michaelcdever> ok cool, thanks dmwit, will have a look :)
15:00:32 <Peaker> How do I create a value of type IOError?
15:00:52 <dmwit> Plouj: What are circle brackets?
15:00:56 <dmwit> Plouj: Parentheses?
15:00:57 <BMeph> @hoogle IOError
15:00:57 <lambdabot> Prelude type IOError = IOException
15:00:57 <lambdabot> System.IO.Error type IOError = IOException
15:00:57 <lambdabot> Prelude ioError :: IOError -> IO a
15:01:17 <dmwit> Plouj: (a, b, c, d, e) -- is just the syntax for a tuple; this one is a tuple of length 5
15:01:18 <rwbarton> Plouj: (a, b, c) is built-in syntax for a triple
15:01:20 <Peaker> @hoogle -> IOError
15:01:20 <lambdabot> Parse error:
15:01:20 <lambdabot>   --count=20 "-> IOError"
15:01:20 <lambdabot>              ^
15:01:24 <Peaker> @hoogle a -> IOError
15:01:25 <lambdabot> Prelude id :: a -> a
15:01:25 <lambdabot> Data.Function id :: a -> a
15:01:25 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:01:37 <gbacon> vixey, koeien, opqdonut, Heffalump: thank you for your help
15:01:46 <rwbarton> , src ''IOError
15:01:51 <lunabot>  type IOError = IOException
15:01:59 <rwbarton> , src ''IOException
15:02:01 <lunabot>  luna: Not in scope: type constructor or class `IOException'
15:02:11 <BMeph> @ho IOException
15:02:11 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
15:02:18 <BMeph> @hoogle IOException
15:02:18 <lambdabot> Control.Exception IOException :: IOException -> Exception
15:02:18 <lambdabot> Control.Exception data IOException
15:02:25 <ac> ok, Haskell SuperCollider is totally awesome!. There are Fractional instances for UGens, so you can use standard math functions to manipulate signals
15:02:44 <rwbarton> lunabot and hoogle might have different versions of Control.Exception
15:04:18 <rwbarton> Peaker: I thought the 6.10 way was to define your own exception type as an instance of Exception
15:04:20 <Peaker> ok, in IO I can only throw IOExceptions, which I cannot create?
15:04:27 * BMeph looks at Peaker as if he's lost, and holds his hands level at shoulder-height. "You're on your own, kid." :)
15:04:41 <Peaker> rwbarton: How do I throw any Exception instance in IO?
15:04:49 <rwbarton> Peaker: throwIO
15:05:03 * BMeph facepalms
15:05:12 <Plouj> ok, right, third (... was a tuple, but what about bookID      (Book id title authors) = id
15:05:26 <Plouj> Book isn't a tuple, it's a Book datatype, or is it?
15:05:45 <rwbarton> Book is a data constructor for some data type (possibly also called Book)
15:05:46 <mux> you can use both syntax interchangeably
15:05:49 <vixey> Plouj, so you write  authors (Book _ _ a) = a
15:06:00 <Peaker> @src Control.Exception.Exception
15:06:01 <lambdabot> Source not found. Do you think like you type?
15:06:03 <mux> for records and plain ADTs
15:06:32 <Plouj> to me, it looks like Alegbraic Data Type pattern pattching uses the tuple syntax for some reason
15:06:46 <rwbarton> Plouj: No.  There are no commas, for instance
15:06:55 <Plouj> rwbarton: ok, I didn't notice that
15:07:05 <rwbarton> Plouj: But, you can think of third (a,b,c) as syntactic sugar for third ((,,) a b c) if you like
15:07:08 <koeien> Plouj: no, no commas. Also, the parentheses aren't necessary in constructing one
15:07:11 <Plouj> rwbarton: so, do (...) belong to pattern matching? ADTs? Something else?
15:07:36 <rwbarton> Plouj: () have many uses :)  Among them are part of the (a,b,c) syntax, and grouping.
15:07:41 <koeien> Plouj: no, precedence
15:07:54 <Peaker> yucky typeable/dynamic stuff there
15:08:04 <koeien> you could have a datatype defined as 'data Book = Book', and then match like f Book = ...
15:08:08 <koeien> without parentheses
15:08:27 <Plouj> I see,t hanks
15:08:48 <scodil> does anyone know of any examples where someone has used par to get good speedup when mapping over a tree-like data structure? Or associatively folding, like divide-and-conquer?
15:09:59 <BMeph> @google dons par
15:09:59 <lambdabot> http://www.unchildren.org/french/relief.htm
15:09:59 <lambdabot> Title: UCF
15:10:11 <BMeph> ...WTF?!?
15:11:35 <naturalethic> is there a way to write:  any (`elem` "x")    -- without using infix notation?
15:11:50 <ddarius> any (flip elem "x")
15:11:51 <koeien> naturalethic: yes, using flip
15:11:51 <ski_> any (flip elem "x")
15:11:52 <opqdonut> any (flip elem "x")
15:12:00 <naturalethic> haha thanks -- ddarius wins
15:12:01 <opqdonut> glorious surround indeed
15:12:02 <rwbarton> any ((==) "x")  -- :)
15:12:14 <ddarius> Or what rwbarton said
15:12:14 <vixey> any (flip elem "x")
15:12:21 <ddarius> Er except 'x'
15:12:26 <rwbarton> Yeah, that.
15:12:50 <rwbarton> So in turn, elem 'x'
15:13:15 <michaelcdever> once again ive another, I'm sure silly error, im getting an inferred type error at http://hpaste.org/13588#a4 in function checkFile
15:14:05 <rwbarton> michaelcdever: Just a precedence issue, you need parentheses: return (searchFile (x:y) pattern)
15:14:05 <Botje> return $ searchFile ...
15:14:11 <rwbarton> michaelcdever: Alternatively, use $
15:14:13 <Peaker> mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
15:14:19 <Peaker> Is this about pure exceptions?
15:14:21 <dmwit> michaelcdever: return is not a keyword; it's a function
15:14:37 <dmwit> michaelcdever: So in that line, you're trying to call return with three arguments, when it only takes one. =)
15:14:50 <dmwit> > return 3 4 -- well, most of the time it only takes 1
15:14:53 <rwbarton> michaelcdever: BTW, you don't need to write 'x:y' unless you want to assert that there is at least one word.  Just replace it by 'x'
15:14:53 <lambdabot>   3
15:15:33 <dmwit> michaelcdever: Also, it will probably have to be IO Bool as your return type.
15:15:57 <michaelcdever> thanks lads, still the same error though, couldn;t match expecter type Bool against infered type 'a b'
15:16:19 <dmwit> michaelcdever: Check my last comment; the return type is IO Bool, not Bool.
15:16:28 <jonaskoelker> question: in "class ConsLub h t l | h t -> l where ...", what does "| h t -> l" mean?
15:17:00 <ski_> jonaskoelker : `h' and `t' uniquely determines `l'
15:17:08 <opqdonut> fophillips: that's a functional dependency
15:17:15 <fophillips> Ta
15:17:15 <vixey> jonaskoelker, what's con slub
15:17:16 <opqdonut> and the semantics are what ski_ said
15:17:27 <vixey> jonaskoelker, what code is it?
15:17:29 <michaelcdever> brilliant
15:17:29 <jonaskoelker> vixey: cons LUB (LUB = least upper bound)
15:17:31 <michaelcdever> :D:D
15:17:44 <jonaskoelker> vixey: http://homepages.cwi.nl/~ralf/OOHaskell/paper.pdf page 47
15:17:47 <ski_> jonaskoelker : or more formally, "for all `h',`t', there is at most one `l' such that `ConsLub h t l' holds"
15:17:48 <opqdonut> h(ead) t(ail) l(ist)
15:18:17 <opqdonut> jonaskoelker: fundeps are required for example when one class parameter only appears in return types
15:18:17 <rwbarton> michaelcdever: Also, you don't need any of the third parentheses on the third line, and there's no need for the let at all, you can just replace fileContents (on the next line) with its definition
15:18:18 <vixey> ugh it's really long...
15:18:42 <ozy`> google results for "haskell sucks": 286
15:18:52 <ozy`> google results for "c++ sucks": 7,430
15:18:53 <opqdonut> or well, not always
15:18:57 <jonaskoelker> ozy`: :)
15:18:58 <ski_> jonaskoelker : concretely it means that you can't have two instances `instance ConsLub H T L0',`instance ConsLub H T L1', where `L0' and `L1' are different
15:19:05 <Adamant> how many for "Haskell rocks"?
15:19:11 <jonaskoelker> ski_: got it :)
15:19:41 <jonaskoelker> at least for the instance I'm looking at.  I think I got it general too, but we'll see if there exists a witness that disproves that
15:19:53 <SamB_XP> ozy`: how about "C sucks"?
15:20:02 <rwbarton> google results for "php sucks": 10,600
15:20:09 <ozy`> SamB_XP: whoops, 11,700
15:20:14 <koeien> rwbarton: that is not surprising
15:20:14 <shapr> Is there either a pop3 or imap server written in Haskell?
15:20:15 <jonaskoelker> is there a document :: syntactic_element -> description?
15:20:19 <shapr> @users
15:20:19 <lambdabot> Maximum users seen in #haskell: 637, currently: 615 (96.5%), active: 28 (4.6%)
15:20:20 <ski_> jonaskoelker : also, it means that in type inference, if the system has inferred constraints `ConsLub h t l0',`ConsLub h t l1', it now also knows that `l0' and `l1' must be equal .. this means the code is less ambiguous, and so you don't need to add as much typing-annotations to resolve the ambiguity
15:20:22 <ozy`> which is funny 'cause C is nicer than C++
15:20:40 <ozy`> 16,000 for java
15:20:42 <SamB_XP> ozy`: well, google doesn't give results based on truthity of statement
15:20:46 <shapr> @seen CosmicRay
15:20:47 <lambdabot> Last time I saw CosmicRay was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #funtoo, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #
15:20:47 <lambdabot> haskell-blah, #haskell-books, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #
15:20:47 <lambdabot> haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosxdev, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 1m 1d 1h 2m 15s ago, and .
15:20:49 <shapr> yow
15:20:57 <shapr> ok then
15:21:02 <opqdonut> :D
15:21:29 <opqdonut> ?yow
15:21:31 <shapr> So, no one has heard of a pop3 or imap4 *server* written in Haskell?
15:21:31 <shapr> I have an idea...
15:21:35 <lambdabot> People humiliating a salami!
15:21:56 <opqdonut> shapr: a happs module perhaps?
15:21:58 <shapr> Well foozle
15:22:07 <shapr> opqdonut: Oh good point, that would be the best way to implement it.
15:22:14 <ski_> night, shapr
15:22:21 <shapr> tja ski_
15:22:24 <shapr> gonatt!
15:22:30 <shapr> Are you going to sleep? :-)
15:22:36 <ski_> not yet
15:22:42 <ski_> (just greeting :)
15:22:47 <shapr> Ah, I see, hej!
15:23:05 <opqdonut> swedes everywhere!
15:23:12 <shapr> opqdonut: I'm a good old boy from Alabama!
15:23:26 <Adamant> never meanin' no harm
15:23:28 <shapr> opqdonut: The Swedish speaking part of Alabama, mind you.
15:23:34 <opqdonut> heh
15:23:41 <Adamant> ya, ya
15:23:42 <naturalethic> i'd almost recommend skipping chapter 6 for anyone learning through the RWH book -- and going back to it much later
15:23:42 <shapr> i alla fall...
15:24:02 <shapr> Oh I should check RWH for nifty server code, good idea.
15:24:13 <shapr> Is HAppS cabalized yet?
15:24:29 <shapr> When do I get cabal dist-upgrade? :-)
15:24:58 <Saizan> shapr: cabal install HAppS-Server
15:26:56 <shapr> whee!
15:26:58 <shapr> Saizan: spiffy!
15:27:07 * shapr tries turbinado
15:27:27 <Nafai> Hey shapr!
15:27:40 <shapr> hiya Nafai! How's life?
15:28:33 <Nafai> Pretty good
15:36:07 <Nafai> shapr: Really gettin=g into my paper version of RWH.  Just finished chapter 6 this morning!
15:36:19 * BMeph wants to refactor Turbinado to use more "modern" Haskell libs, but doesn't have the time. Or the brains... ;p
15:37:04 <djoseph> Are there any specific advantages to using two constructors in a binary tree type instead of one constructor with Maybe?
15:37:06 <Saizan> so young and already using old libs?
15:37:20 <koeien> djoseph: clarity
15:37:21 <ddarius> Venerable libs
15:37:36 <koeien> BMeph: ah, i've looked into turbinado
15:37:40 <koeien> couldn't get it to compile :(
15:37:46 <sbahra> koeien, clarity? Which would you find clearer?
15:38:08 <koeien> sbahra: i would prefer    data Tree = Branch Tree Tree | Leaf
15:38:12 <BMeph> Whoo-HOO! My copy of RWH is IN TOWN!
15:38:19 * BMeph does his "happy dance"
15:38:21 <Nafai> BMeph: Woot
15:38:52 <koeien> sbahra: otherwise, you would need,   data Branch = Branch Tree Tree, type Tree = Maybe Branch
15:39:26 <vixey> try adding some data into the trees
15:39:28 <sbahra> data Tree = Branch (Maybe Tree) (Maybe Tree).
15:39:46 <koeien> vixey: sure. i left that out for brevity
15:39:51 <sbahra> I agree that another constructor makes more sense though, it is clearer.
15:39:57 <vixey> koeien, ah but it is important here
15:40:01 <koeien> sbahra: you cannot represent the "empty tree" now
15:40:08 <sbahra> koeien, yes.
15:40:15 <vixey> koeien, there is some (maybe subtle) difference
15:40:26 <rwbarton> data Tree = Tree (Maybe (Tree, Tree))
15:40:35 <sbahra> :)
15:40:35 <dibblego> has anyone successfully built lambdabot on a vmware image yet?
15:40:57 <sbahra> rwbarton, (Nothing, Tree ...)
15:41:10 <koeien> rwbarton: i prefer my version, with data of course
15:41:15 <sbahra> data Tree = Tree (Maybe (Maybe Tree, Maybe Tree))
15:41:17 <sbahra> :-p
15:41:43 <Heffalump> dibblego: why is the vmware image bit relevant?
15:42:00 <rwbarton> Sure, another option is data Tree a = Tree (Either a (Tree, Tree))
15:42:02 <dibblego> Heffalump, so that I can download it since building lambdabot is incredibly painful
15:42:07 <koeien> you have some choices where to include the data: at every branch, or at the leafs only
15:42:10 <rwbarton> Either way you have roughly twice as many constructors to wade through
15:42:30 <Heffalump> dibblego: ok, but what does vmware have to do with it?
15:42:36 <Heffalump> oh, you want the image?
15:42:43 <dibblego> Heffalump, yes I want the image
15:43:16 * BMeph wants it, too
15:43:28 <dibblego> Heffalump, I don't want to waste more time trying to get lambdabot to build
15:43:28 <Heffalump> I don't have one, I was just confused about why it would help.
15:43:37 <dibblego> Heffalump, ok cheers
15:43:56 * BMeph would also like to run lambdabot in its own separate, re-bootable virtual server
15:44:11 <jonaskoelker> is it possible to write a polymorphic function f :: a -> Sometype, where the instance a=Type0 calls the instance a=Type1?
15:44:30 <ddarius> Sure.
15:44:51 <BMeph> jonaskoelker: Possible, yes. Fun? Not-so-much... ;p
15:44:52 <Heffalump> it's on hackage, right? Why didn't whoever uploaded it to that make sure it built there?
15:45:27 <ddarius> You'd have to have something to distinguish the type or it would need to be in a uniform way.
15:47:43 <vixey>  data Tree o = Branch (Tree o) o (Tree o) | Leaf
15:48:03 <sbahra> ,,,
15:48:06 <lunabot>  luna: No instance for (GHC.Show.Show (a -> b -> c -> (a, b, c)))
15:48:21 <rwbarton> Wow
15:48:24 <rwbarton> > ,,
15:48:25 <lambdabot>   <no location info>: parse error on input `,'
15:48:36 <vixey> luna puts () around everything
15:48:38 <ski_> @type let f :: a -> (Integer -> Integer); f x 0 = 1; f x n = n * f (Just x) (n - 1) in f
15:48:38 <rwbarton> I guess lunabot puts parens around its...
15:48:39 <vixey> > )(
15:48:40 <lambdabot> forall a. a -> Integer -> Integer
15:48:41 <lambdabot>   <no location info>: parse error on input `)'
15:48:43 <vixey> , )(
15:48:45 <lunabot>  luna: Couldn't match expected type `() -> a'
15:48:50 <vixey> , )`const`(
15:48:52 <lunabot>  ()
15:48:56 <koeien> whahaha
15:49:03 <sbahra> :t const
15:49:05 <lambdabot> forall a b. a -> b -> a
15:49:08 <ziman> a cool way to confuse newbies :)
15:49:19 <imphasing> Anyone have any times for how to get Haskell sytanx highlighting on VS2008?
15:50:09 <vixey> imphasing, not sure how VS2008 works but maybe easiest route is to port from eclipse or vim or something?
15:50:28 <imphasing> Hmm.. what's the editor of choice for Haskell? Vim? Emacs?
15:50:38 <imphasing> Or is that an editor war issue? ;)
15:50:42 <sbahra> Editor war
15:50:45 <vixey> imphasing, I think that people use either
15:50:51 <imphasing> Okay, cool
15:50:53 <vixey> imphasing, i.e. they're both fine
15:50:57 <imphasing> Sweet.
15:51:02 <sbahra> What vixey means to say is, use vim
15:51:04 <sbahra> ;p
15:51:08 <vixey> which isn't the case for all languages
15:51:09 <imphasing> I know a lot of people prefer Emacs for Lisp, so I was just wondering. :)
15:51:19 <imphasing> sbahra, I intend to ;)
15:51:34 <vixey> is there any language which vim has got aeons better setup for than emacs?
15:51:41 <vixey> just curious about it now.....
15:52:05 <imphasing> vixey, Lisp?
15:52:14 <imphasing> It's already got the interpreter built in
15:52:15 <vixey> what
15:52:29 <vixey> imphasing, I meant the opposite question
15:52:30 <imphasing> Oh wait, you asked that the other way around.
15:52:37 <imphasing> Right, I'm stupid :P
15:53:02 <rgr_> Any emacs users here, is there any form of type/function name completion available in ghci inside emacs haskell shell?
15:53:38 <Heffalump> ghci in 6.10 seems to have started having tab completion of its own accord
15:53:40 <lelf> M-/
15:53:44 <imphasing> vixey, I'd use emacs, but I grew up using Vim so I can't bring myself to change :P
15:53:59 <rwbarton> rgr_: or M-. to some extent
15:54:08 <michaelcdever> right, time for sleep, thanks everyone for the help earlier!
15:54:16 <michaelcdever> slán
15:54:20 <vixey> imphasing: I can use both badly instead of one well...
15:54:20 <rwbarton> rgr_: Wait, no, I meant M-/
15:54:40 <imphasing> vixey, I can use emacs badly, and Vim with some excusable ignorance
15:57:51 <rgr_> isnt M-/ merely dabbrev-expand which is a subpart of hippie-expand?
15:59:18 <mreh> is anyone looking at RWH?
15:59:19 <rwbarton> rgr_: Yes.  I don't know of a way to get ghci's completion
15:59:46 <mreh> @type case
15:59:47 <lambdabot> parse error (possibly incorrect indentation)
15:59:52 <Raevel> mreh: yes, why?
16:00:04 <mreh> page 73 has confused me somewhat
16:00:26 <mreh> the function split lines uses a case *in* an expression... i think
16:00:27 <rgr_> rwbarton: not that thats bad, but completion seems to be a bit of a mess in emacs at times.
16:00:30 <mreh> as far as i can see
16:00:41 <Heffalump> mreh: that's correct
16:00:47 <Heffalump> case is just an expression, like if then else is
16:00:53 <mreh> what is the precedence of a case then?
16:01:00 <koeien> YA! bol.com has RWH!!
16:01:08 <mreh> does that mean i can play a case in brackets?
16:01:15 <mreh> place*
16:01:17 <Heffalump> mreh: dunno :-)
16:01:24 <rwbarton> rgr_: yeah, it's kind of a "best effort" thing for me, M-/ works a lot of the time, and that's sufficient for me not to investigate further...
16:01:33 <Heffalump> you can certainly put the entire case expression in brackets
16:01:34 <ski__> > 1 + case () of () -> 0
16:01:36 <lambdabot>   1
16:01:38 <koeien> ordering now!
16:01:41 <Raevel> > (case True of True -> True)
16:01:43 <lambdabot>   True
16:02:12 <mreh> so what it is doing on that page is concatonating the result of the function "case" with pre
16:02:19 <ziman> , foo); foo = 3
16:02:21 <lunabot>  luna: parse error on input `;'
16:02:34 <ziman> , foo); foo = 93
16:02:35 <lunabot>  luna: parse error on input `;'
16:02:38 <Heffalump> well, consing pre onto the result
16:02:39 <mreh> well, doing a cons, a :
16:02:39 <ziman> gah
16:02:42 <Heffalump> yep
16:02:43 <ziman> , foo); foo = (3
16:02:43 <mreh> ;)
16:02:45 <lunabot>  luna: parse error on input `;'
16:03:06 <mreh> case must be some kind of function then
16:03:16 <ski__> no
16:03:18 <mreh> are there any haskell gurus here to say?
16:03:21 <rwbarton> it's syntax
16:03:25 <rwbarton> like if
16:03:32 <mreh> if, isn't syntax
16:03:33 <koeien> it's not a function, it's "built-in" syntax
16:03:35 <ski__> `case' is a language construct
16:03:40 <rwbarton> if is syntax.
16:03:47 <koeien> if is not a function
16:03:50 <chessguy> mreh:  yes, they're both built in
16:03:54 <mreh> it depends how you use if
16:03:59 <ski__> no
16:04:15 <chessguy> 'if' itself is a keyword
16:04:19 <mreh> >let if True a b = a
16:04:25 <koeien> in my editor "if" becomes yellow, so it's syntax :)
16:04:27 <mreh> >let if False a b = b
16:04:32 <rwbarton> > let if True a b = a
16:04:33 <lambdabot>   <no location info>: parse error on input `='
16:04:41 <rwbarton> See: if is a keyword.
16:04:52 <mreh> > let myIf True a b = a
16:04:54 <rwbarton> > let if True a b = a in if True 3 4
16:04:54 <lambdabot>   <no location info>: parse error on input `;'
16:04:55 <lambdabot>   <no location info>: parse error on input `='
16:05:16 <rwbarton> Sorry, only that second one demonstrates that if is a keyword.
16:05:25 <rwbarton> > let myIf True a b = a in myIf True 3 4
16:05:27 <lambdabot>   3
16:05:57 <mreh> see, if is a function
16:06:08 <rwbarton> No, I don't see.
16:06:10 <rwbarton> What do you mean?
16:06:19 <mreh> you just made a function called if, that works like if
16:06:22 <rwbarton> You can write a function which is kind of like if, but you can't call it if
16:06:30 <mreh> if it quacks like a duck and it walks like a duck...
16:06:41 <ski__> mreh : no, rwbarton made a function called `myIf'
16:06:53 <rwbarton> Also, your function which is kind of like if doesn't have the "then" and "else" syntax.
16:06:55 <koeien> where are the "then" and "else" ?
16:07:08 <mreh> well, that's the next sensible question
16:07:20 <rwbarton> Is "then" a function?
16:07:32 <mreh> my question is, can i use them like functions?
16:07:38 <koeien> no, you can't
16:07:46 <koeien> you can't pass "if" to another function
16:08:16 <chessguy> @type if
16:08:17 <koeien> of course, you can pass stuff like "\x -> if x == 37 then True else False"
16:08:17 <mreh> so how do you explain the code on p73? I can't work out how it parses that
16:08:18 <lambdabot> parse error (possibly incorrect indentation)
16:08:26 <chessguy> mreh:  how about that?
16:09:04 <FunctorSalad_> any news on how to make the inferior-haskell in emacs work properly with 6.10? (particularly, fix the misinterpreted newlines ^J)
16:09:11 <crutcher> So, I understand that 'if' is a keyword, but I find myself wondering if it needs to be?
16:09:22 <koeien> crutcher: not really
16:09:31 <Raevel> crutcher: no it doesn't need to be
16:09:32 <rwbarton> crutcher: Only to make the syntax slightly nicer
16:09:35 <koeien> crutcher: well, if you want 'then' and 'else' you do, but you could easily make your own
16:09:51 <Raevel> in most other languages it needs to be a keyword, though
16:09:52 <dibblego> crutcher, http://www.haskell.org/haskellwiki/If-then-else
16:09:53 <koeien> like rwbarton's half-example
16:10:19 <rwbarton> You can also play games like  if :: Bool -> Then -> a -> Else -> a, then :: Then, else :: Else, but I'm not sure you can get the precedence right
16:10:19 <mreh> it needs to be more than that, it needs to be a contruct
16:10:53 <chessguy> @type let if' b t f | b = t; | otherwise = f; in if'
16:10:54 <lambdabot> parse error on input `|'
16:11:00 <Raevel> well, "special form" is the term i usually go with for describing these
16:11:57 <crutcher> dibblego: thanks
16:11:57 <chessguy> @type let if' b t f | b = t; f' b t f | otherwise = f; in if'
16:11:58 <lambdabot> forall t t1. Bool -> t -> t1 -> t
16:12:22 <chessguy> hrm, that type doesn't look right
16:12:27 <rwbarton> crutcher: BTW I wouldn't assume that the author of that wiki page speaks for all Haskell programmers
16:13:07 <chessguy> @type let if' b t f | b = t; if' b t f | otherwise = f; in if'
16:13:08 <lambdabot> forall t. Bool -> t -> t -> t
16:13:14 <chessguy> that's more like it
16:13:29 <koeien> Helium would catch that!
16:13:33 <dmwit> chessguy: Your second one was an f' not an if'... oh you got it.
16:13:49 <dmwit> chessguy: You could also fix that problem by leaving the name off the second one:
16:13:51 <crutcher> rwbarton: yeah, I get that. and I read the Con section. I'd forgotten for a sec that haskell used 'then' and 'else' as keywords, or else I wouldn't have asked.
16:13:58 <dmwit> :t let if' bt f | b = t | otherwise = f in if'
16:13:59 <lambdabot>     Couldn't match expected type `Bool' against inferred type `Expr'
16:14:00 <lambdabot>     In a stmt of a pattern guard for
16:14:00 <lambdabot>                  the definition of `if'':
16:14:07 <dmwit> :t let if' b t f | b = t | otherwise = f in if'
16:14:09 <lambdabot> forall t. Bool -> t -> t -> t
16:14:14 <chessguy> oh, nice
16:14:32 <Peaker> assuming name shadowing in nested "let" is not allowed, does removing the "let" and "in" from Haskell syntax create any ambiguity? (The '=' implies the let..)
16:15:05 <koeien> Peaker: yes, "let x = 3 in x" ==> "x = 3 x" ??
16:15:26 <rwbarton> how about x = a b c could be let x = a b in c or let x = a in b c
16:15:37 <Peaker> koeien: well, lets replace "in" with ; (or layout newline)
16:15:56 <Peaker> rwbarton: ^^ "in" becomes ; or newline
16:16:27 <koeien> Peaker: ok. i think you can, but would it be clearer? (i am definitely not sure though)
16:17:05 * koeien prefers 'where' to 'let' in a lot of cases
16:17:15 <rwbarton> Peaker: Seems pretty weird--normally you don't have ; or newline inside an expression
16:17:30 <BMeph> FunctorSalad_: What does it do now? I hadn't noticed anything.
16:18:07 <Peaker> koeien: I find it a bit painful to add "let" and "in" when I just want to quickly give some sub-expression a name
16:18:35 <Peaker> koeien: and "where" does not have access to various lexical scopes inside
16:18:58 * ski_ thinks one could maybe allow `foo @' in expressions ..
16:19:00 <Peaker> rwbarton: its un-weird in the sense of being more superficially similar to other languages
16:19:06 <koeien> perhaps. i don't think it's that clearer though
16:19:12 <rwbarton> I feel like the "let" in do-syntax is unneeded, but I could be wrong
16:19:27 <koeien> (\x -> let f = x^2 in f * f)
16:19:39 <koeien> (\x -> f = x^2; f * f)
16:19:40 <geezusfreeek> i tend to use "where" when i'm using a fully-named function or constant that simply has no relevance in other scopes and "let" when i'm just making a temporary variable with a typically short name
16:19:41 <BMeph> So, "Haskell: Where every form is 'special'?" ;)
16:19:53 <Peaker> koeien: I like the latter better
16:20:02 <naturalethic> in this statement in ghci ":m +System.Directory" -- what is the meaning of the +
16:20:15 <koeien> naturalethic: "add"
16:20:41 <koeien> Peaker: i don't know. it seems weird but that' sprobably because i'm used to the first one
16:20:41 <Peaker> naturalethic: You can use "import"
16:20:55 <mpwd> geezusfreeek: I try to stick to the same convention
16:21:11 <koeien> naturalethic: with ':m -Module' you can remove Module from the namespace
16:21:11 <Peaker> koeien: note that in the global/top-level scope, we already use the latter...
16:21:18 <baaba> @pl \f -> curry (flip (uncurry (flip f x)) y)
16:21:18 <lambdabot> curry . flip flip y . uncurry . flip flip x
16:21:20 <naturalethic> oh i gotcha, i was using import --- ok interesting
16:21:27 <koeien> Peaker: no, we have a toplevel "where"
16:21:43 <Peaker> koeien: what's the difference?
16:21:43 <geezusfreeek> :t \f -> curry (flip (uncurry (flip f x)) y)
16:21:45 <lambdabot> forall a b c. (a -> Expr -> b -> Expr -> c) -> a -> b -> c
16:21:47 <rwbarton> module ... where
16:21:53 <Peaker> oh
16:22:06 <koeien> Peaker: we are not talking about let-syntax then
16:25:30 <ski_> rwbarton : how about `do x <- frob; let {f y = ..f.y.g..; g z = ..f.z.g..}; ..f..g..'
16:26:08 <ski_> (koeien : i first thought you were talking about Scheme, there ..)
16:26:41 <rwbarton> ski_: ah, interesting
16:27:05 <imphasing> I tell you, after reading the first 4 chapters of Real World Haskell about 6 times, I'm finally starting to get this thing.
16:27:06 <imphasing> Holler.
16:27:12 <imphasing> I can see why you guys like it ;)
16:27:18 <koeien> nice!
16:27:23 <ski_> (rwbarton : sorry, throw in `x' inside the bodies of `f' and `g' .. forgot that)
16:27:23 <koeien> i've just ordered my copy
16:27:51 <koeien> probably not going to learn too much, but we will see
16:28:08 <koeien> i have to know where the fuss is about :) and e-books, meh
16:28:17 <koeien> dead trees are a precondition for a good book
16:28:22 <imphasing> koeien, Do you have any haskell background?
16:28:25 <FunctorSalad_> BMeph: for me, it echoes every input followed by a "^J" e.g.: ghci> 1 (press enter) 1^J1
16:28:38 <dmwit> koeien: Any postconditions? =)
16:28:40 <imphasing> If you're like me, an imperative kinda guy, I think you'll learn a lot from it.
16:28:40 <koeien> imphasing: i've learned haskell at my university
16:28:48 <imphasing> Ah, well then you're ahead of me :P
16:28:51 <FunctorSalad_> BMeph: among other things this breaks C-c C-t
16:28:57 <mmorrow> preflex: seen Heffalump
16:28:57 <preflex>  Heffalump was last seen on #haskell 26 minutes and 15 seconds ago, saying: yep
16:28:59 <koeien> and written a library, and done some more stuff
16:29:18 <koeien> imphasing: yes, i didn't understand what everything was about as well during that class
16:29:21 <mmorrow> Heffalump: i think i have a decent solution http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=717#a717
16:29:48 <koeien> imphasing: you create some "binary trees" and other nice things, and i thought "well, this is not for the Real World[tm]"
16:30:00 <imphasing> koeien, Hah, I heard that.
16:30:10 <koeien> but then i wrote a computer networks assignment in it, and i was pleasantly surprised
16:30:25 <imphasing> Sweet
16:30:26 <koeien> had to learn about monads of course, but no big deal
16:30:27 <mmorrow> one thing i have to check though is for that whole oleg "if you lie in a certain way in a Typeable instance, you can segfault via the unsafeCoerce in fromDynamic"
16:30:56 <mmorrow> but if that's the case, then i'll just ditch the Typeable (and Data) instances if they're unqorkable
16:31:01 <mmorrow> *unworkable
16:31:01 <Elly> unsafe* => "all bets are off", right?
16:31:12 <dmwit> right
16:31:15 <mmorrow> Elly: depends
16:31:26 <mmorrow> it means the correctness is up to you
16:31:29 <koeien> unsafePerformIO $ return 3    is perfectly safe right?
16:31:40 <mmorrow> just like pretty much everything in C with pointers
16:31:49 <dmwit> Yeah, mmorrow's characterization is much more accurate.
16:31:53 <mmorrow> koeien: sure, as a contrived example
16:32:14 <mmorrow> @src fromDynamic
16:32:14 <lambdabot> fromDynamic (Dynamic t v) = case unsafeCoerce v of
16:32:14 <lambdabot>     r | t == typeOf r -> Just r
16:32:14 <lambdabot>       | otherwise     -> Nothing
16:32:21 <rwbarton> What's the suggested way to install cabal-install globally?  Run the bootstrap.sh for a per-user install and then use that to install globally?
16:32:24 <Heffalump> mmorrow: what did you change?
16:32:37 <mmorrow> Heffalump: everything. check out that paste.
16:32:49 <dmwit> rwbarton: I think you can pass --global to bootstrap.sh; if not, it should be easy to see where to put it in the script.
16:32:50 <Heffalump> it's quite big so I'm getting a bit lost :-)
16:32:54 <Heffalump> what should I focus on?
16:33:07 <mmorrow> (and that module's export list is the important part)
16:33:17 <mmorrow> so pretty much it makes a type U
16:33:22 <dmwit> rwbarton: I'm not sure a "best practice" for that task has arisen yet.
16:33:25 <mmorrow> that is the uniq whatever generator
16:33:32 <mmorrow> and you create a U with newU
16:33:35 <mmorrow> IO a -> U a
16:33:55 <mmorrow> to get a value from a U, you do  oneU uSomething
16:34:02 <Heffalump> I'm worried that all you've done is confused the optimiser enough that it doesn't break stuff any more by chance.
16:34:14 <mmorrow> then, the instances for U lie as if U was newtype U a = U a
16:34:32 <mmorrow> but it's U a = U (() -> a) to delay the computation of the a
16:34:36 <mmorrow> which allows eg
16:34:42 <mmorrow> replicate 10 uInt
16:34:52 <mmorrow> to give all different values (when shown)
16:35:02 <Heffalump> but what's to stop a clever optimiser undoing all this?
16:35:35 <mmorrow> Heffalump: because the optimizer would have to evaluate a function on () to get a value
16:35:49 <mmorrow> the values don't actually exist until you call oneU (or show them)(
16:35:58 <Heffalump> so? A function on () is isomorphic to a value.
16:36:06 <mmorrow> exactly!
16:36:13 <Heffalump> but an optimiser could know that too
16:36:18 <mmorrow> hmm, ruhroh
16:36:46 <Heffalump> also, you still can't abstract in a referentially transparent way
16:36:48 <mmorrow> that'd be a pretty presumptuous optimizer. yes, in that case it'd break it.
16:36:53 <Heffalump> once you make the call to oneU, that's it
16:36:54 <blando> amazon is recommending me real world haskell for some reason.  as if...
16:37:00 <mmorrow> Heffalump: yes
16:37:07 <mmorrow> but that's the intended effect
16:37:24 <Heffalump> ok, but it doesn't help with my problem
16:37:32 <Heffalump> or rather the second of my two problems
16:37:44 <Heffalump> it does help with being able to compile the name supply module with optimisations
16:37:46 <mmorrow> how could it be done in a referentially transparent way? isn't it fundamentally not referentially transparent what we're trying to do?
16:37:53 <dmwit> But... () -> a isn't isomorphic to a in the presence of undefined.  I don't know if that's relevant, but it seems like the optimizer should be preserving that kind of thing.
16:38:02 <Heffalump> err, yes, sorry
16:38:09 <Heffalump> (to both mmorrow and dmwit(
16:38:16 <Heffalump> dmwit: it could figure out the strictness though
16:38:45 <Heffalump> mmorrow: the point I'm trying to make is that it doesn't help with my problem where a derived function call gets lifted out.
16:38:48 <mmorrow> hmm, that's interesting that ()->a ==> a could be optimized away
16:40:01 <mmorrow> Heffalump: hmm. so then messes up the uniqs somehow? could you give a short example of some code where that might happen, i'm having trouble picturing it.
16:40:37 <Heffalump> well, I'm not quite sure what the optimiser is doing
16:40:48 <mmorrow> heh, fair enough
16:41:07 <Heffalump> but I have some code that effectively has foo "x" as a subexpression, where foo indirectly calls the unsafe newVar.
16:41:26 <Heffalump> and I always get the same "unique" name in that place when I compile with optimisations
16:42:32 <mmorrow> i think (*think*) that if you delay the actual oneU until the last possible moment, that problem might be fixed
16:43:09 <Heffalump> sure, but that comes back to my thing about "no referential transparency". Putting oneU in derived code is really quite ugly.
16:43:26 <Heffalump> and I still won't be safe against a cleverer optimiser
16:43:44 <mmorrow> yes that's true (about ugly), but i don't see another way.
16:43:45 <Heffalump> I might as well just stick NOINLINE pragmas all over my code.
16:43:54 <mmorrow> i really want to read up on the optimizer now.
16:43:57 <Heffalump> well, I plan to return to the light instead :-)
16:44:02 <mmorrow> heh
16:45:21 * Heffalump goes to bed
16:45:27 <mmorrow> night
16:46:05 <naturalethic> i'm having a hard time finding a consistent style in block indents in the RWH book
16:46:16 <cjb> naturalethic: in the C code sections, or Haskell?
16:46:30 <naturalethic> haskell
16:46:36 <cjb> (the C code is mis-indented, a bug)
16:46:39 <cjb> oh, huh
16:47:19 <naturalethic> they seem to switch between 2 and 4 spaces for some block, like do or case ..
16:47:27 <mmorrow> naturalethic: there're probably three distinct styles in there ;) it seems like everyone has their own.
16:48:05 <naturalethic> yeah guess i'll pick up an ideal standard as I read more haskell code out there
16:48:12 <mmorrow> naturalethic: oh, i see what you mean. yeah, also it seems like everyone has 2 or 3 diff variations that they might use depending on where the do/case is
16:49:00 <mux> ugh, Data.Trie has bugs
16:52:31 <imphasing> It seems like a lot of the Data.List functions are extremely simple.. I can re-write most of them quite easily. Am I overlooking something? Are there lots of checks in the functions, or are they really that simple?
16:53:15 <enticingjelly> imphasing, they are really that simple
16:53:24 <imphasing> Sweet :)
16:53:25 <luite> they are simple, but that's not a reason to duplicate the code, right? :)
16:53:30 <imphasing> Well yeah.
16:53:38 <naturalethic> when working with exceptions, what is the reason for passing the second function with $ ... ?
16:54:03 <naturalethic> which i take to mean it is evaluated before passing
16:54:10 <pumpkin> imphasing: most of them you can see the source of in here :)
16:54:11 <ski_> no
16:54:15 <pumpkin> @src foldl'
16:54:15 <lambdabot> foldl' f a []     = a
16:54:15 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
16:54:16 <ski_> @src ($)
16:54:16 <lambdabot> f $ x = f x
16:54:28 <koeien> ($) is just function application with another precedence
16:54:28 <jonaskoelker> what's allowed inside ``?  Only names and not expressions?
16:54:31 <enticingjelly> naturalethic, it just saves you from adding parantheses
16:54:32 <imphasing> pumpkin, Oooh, cool
16:54:46 <imphasing> jonaskoelker, Only names
16:54:49 <koeien> jonaskoelker: :t (`mod` 37)
16:54:50 <naturalethic> oh, around do - got it
16:54:51 <ski_> naturalethic : `$' is just a low-precedence operator for application
16:54:54 <geezusfreeek> man, we keep getting a lot of new people in here :)
16:55:30 <imphasing> jonaskoelker, If I'm understanding the question.
16:55:34 <naturalethic> maybe this is haskell's year
16:55:36 <imphasing> You're talking about infix notation?
16:55:52 <naturalethic> as others have mentioned :)
16:55:59 <jonaskoelker> imphasing: you are :)
16:55:59 <koeien> 2009 . The year of haskell on the desktop?
16:56:02 <jeffwheeler> rwbarton: couldn't you just define then = id; else = id?
16:56:19 <enticingjelly> great. now I have to walk around telling people that I did haskell before it was cool.
16:56:25 <enticingjelly> (kidding ;) )
16:56:27 <geezusfreeek> jonaskoelker, yes, only identifiers
16:56:31 <koeien> jeffwheeler: no, precedence (if we are still talking about the same thing)
16:56:36 <imphasing> I was into dinosaurs when they were still underground. :D
16:56:45 <jeffwheeler> koeien: ah, funky; oh well
16:56:50 * mux wonders if Wren Thornton comes around here
16:57:09 <geezusfreeek> enticingjelly, haskell was cool way before you :P
16:57:15 <naturalethic> anyone worked with the Cocoa <-> Haskell binding?
16:57:35 <rwbarton> jeffwheeler: depends on where you want to put parentheses
16:57:48 <rwbarton> jeffwheeler: I don't think you can avoid parentheses completely, but I'm not sure about that
16:58:12 <jeffwheeler> naturalethic: search HOC
16:58:56 <naturalethic> jeffwheeler: yeah i took a quick search to see what was there -- no releases, just SCM access -- was wondering if anyone here has worked with it
16:59:12 <jeffwheeler> naturalethic: I know; it's a real pain in the ass
16:59:35 <jeffwheeler> Yi uses it for the Cocoa interface.
17:00:45 <jonaskoelker> in "class A a => B a where [...]", what's the name of the relationship A has to B (and vice versa)?
17:00:57 <geezusfreeek> i didn't even know HOC was still maintained
17:01:25 <BONUS_> i'd say B is a subclass of A
17:01:25 <ski_> jonaskoelker : sometimes we say `A' is a superclass of `B'
17:01:38 <jonaskoelker> as I thought...
17:01:58 <geezusfreeek> which just adds to the confusing with OO classes
17:02:01 <BONUS_> @pl \xs -> zip3 xs (tail xs) (tail . tail $ xs)
17:02:02 <lambdabot> ap (ap zip3 tail) (tail . tail)
17:02:02 <geezusfreeek> *confusion
17:03:10 <koeien> i don't think that is a big problem though
17:03:15 <koeien> "confusion"
17:03:28 <koeien> "constructors" are also different
17:03:28 <BONUS_> ugh why isnt \n -> unfoldr (\xs -> if null xs then Nothing else Just (splitAt n xs)) in the standard libs yet
17:03:29 <BONUS_> :[
17:04:05 <koeien> everything is different in Java
17:04:46 <geezusfreeek> :t  \n -> unfoldr (\xs -> if null xs then Nothing else Just (splitAt n xs))
17:04:48 <lambdabot> forall a. Int -> [a] -> [[a]]
17:05:02 <BONUS_> > (\n -> unfoldr (\xs -> if null xs then Nothing else Just (splitAt n xs))) 3 "hello there"
17:05:04 <lambdabot>   ["hel","lo ","the","re"]
17:05:39 <yitz> BONUS_: \n -> map (take n) . takeWhile (not . null) . iterate (drop n)
17:05:41 * mux thinks he fixed Data.Trie.submap
17:06:03 <BONUS_> thats also one way of doing it yeah
17:07:15 <yitz> BONUS_: I call it "groupsOf", other people call it other things.
17:07:34 <yitz> BONUS_: it's in my .ghci, and repeats itself all over the place in my code.
17:08:14 <BONUS_> yeah mine too
17:08:18 <koeien> i've never used such a thing
17:08:21 <BONUS_> i call it chunk
17:08:23 <dmwit> chunk
17:08:23 <BONUS_> chunks
17:08:30 <koeien> well all kinds of "splits"
17:08:36 <BONUS_> groupsOf is a nice name though
17:08:37 <koeien> s/well/i did
17:08:46 <BONUS_> groupsOf 3 reads nicely as a partially applied function
17:09:01 <yitz> which is how I usually use it
17:09:21 <rwbarton> BONUS_: It's in the new Data.List.Split at least
17:09:54 <yitz> rwbarton: package name?
17:10:12 <dmwit_> yitz: split
17:10:16 <ddarius> BONUS_: cabal install split
17:10:32 <ludwigvan> Hi, i'm writing a function that returns IO Bool (for example) and does some printing to the console but when I use that function with map it doesn't print anything, anybody knows why?
17:10:35 <BONUS_> ah, cheerio
17:10:36 <yitz> rwbarton: ok, thanks.
17:10:43 <dmwit> ludwigvan: mapM_
17:10:59 <dmwit> :t mapM
17:11:00 <dmwit> :t mapM_
17:11:01 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
17:11:03 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
17:11:13 <BONUS_> when you map a function that returns an IO action (like IO Bool), you get back a type of [IO Bool]
17:11:22 <BONUS_> which is in itself not an IO action
17:11:26 <BONUS_> so yeah use mapM_ instead
17:11:47 <ludwigvan> oh i see
17:11:53 <ludwigvan> thank you :)
17:12:04 <BONUS_> but it depends if you use those IO Bools later
17:12:10 <BONUS_> you might wanna use mapM instead of mapM_
17:13:55 <rwbarton> I should probably know this from recent haskell-cafe traffic, but what's the easiest way to talk to a MySQL database from Haskell?
17:13:59 <rwbarton> I don't need anything fancy
17:14:02 <imphasing> What's the name of the function that applies a function to each element of a list?
17:14:09 <imphasing> It's almost impossible to google that without some kind of name..
17:14:15 <yitz> @type map
17:14:16 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:14:20 <rwbarton> imphasing: wrong!
17:14:26 <rwbarton> @hoogle (a -> b) -> [a] -> [b]
17:14:27 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
17:14:27 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
17:14:27 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
17:14:34 <imphasing> Sweeet
17:14:36 <imphasing> Thanks :)
17:14:42 <rwbarton> @where hoogle
17:14:42 <lambdabot> http://haskell.org/hoogle
17:14:47 <rwbarton> That's a web interface
17:16:12 <imphasing> rwbarton, Thanks :)
17:16:16 <imphasing> That's a pretty handy site.
17:16:49 <yitz> @seen bos
17:16:50 <lambdabot> bos is in #ghc and #haskell. I last heard bos speak 1d 4h 44m 26s ago.
17:17:16 <yitz> @go haskell mysql
17:17:22 <lambdabot> http://www.serpentine.com/blog/2007/09/05/pure-haskell-mysql-bindings-in-the-works/
17:17:22 <lambdabot> Title: teideal glic deisbhéalach » Blog Archive » Pure Haskell MySQL bindings in the ...
17:17:56 <yitz> rwbarton: but that was over a year ago, and the darcs link is now 404 :(
17:18:01 <mux> koninkje_away: I sent you a mail with patches for bytestring-trie - and I just realized you're in here (although away for now)
17:18:40 <luite> you can use lambdabot to notify him as soon as hey says something
17:19:13 <yitz> rwbarton: in the past i've seen people saying - mysql sucks so i didn't write a backend but you can go ahead and then send me a patch
17:19:19 <mux> yup I know, but I think the email + maybe irc hilighting will be enough for now
17:19:41 <rwbarton> yitz: yeah, it's hard to tell what's working and up to date
17:20:25 <yitz> rwbarton: there's always odbc in the meantime
17:21:54 <rwbarton> yitz: ah, thanks
17:22:15 <rwbarton> yitz: there are too many acronyms what with hsql and hdbc and odbc and so on
17:22:51 <yitz> rwbarton: yeah. lucky thing w3c isn't involved yet.
17:24:58 <bos> yitz: ?
17:25:21 <yitz> bos: hi. rwbarton wants to know what's current with mysql.
17:25:37 <bos> ah. that's pretty much orphaned for now.
17:27:04 <yitz> bos: too bad. the darcs repo also went 404.
17:27:29 <yitz> rwbarton: is gpl ok?
17:28:20 <bos> yitz: i'll dig it out if i can.
17:28:44 <rwbarton> yitz: Yeah.  But really anything is OK, this is a very short-term project and I have no particular attachment to MySQL
17:28:59 <rwbarton> yitz: I'm trying HDBC and HDBC-odbc now
17:29:02 <yitz> bos: do you know if the hsql binding still works? or is there something for hdbc?
17:29:11 <sclv> then why not use sqlite?
17:29:30 <Axman6> sqlite++
17:29:48 <bos> yitz: no idea
17:29:49 <rwbarton> I have a pre-existing system that uses MySQL
17:30:30 <sclv> ah, nevermind then.
17:30:54 <sclv> legacy is probably the only reason i would ever uses mysql these days.
17:31:15 <dibblego> sclv, would you instead use postgresql?
17:31:23 <yitz> even tho we'll all agree mysql sux0rs, it's important that we have pretty good support for it.
17:31:29 <sclv> dibblego: you bet.
17:31:53 <sclv> yitz: agreed. and odbc on unix to interface with it is certainly quite the drag.
17:32:06 <yitz> sclv: indeed.
17:32:14 <rwbarton> Yeah, in the long term I think I'll try to move to Postgresql
17:34:26 * sclv ponders again if there would be any real call for a haskell mnesia, or if a haskell qdb would be more useful.
17:34:36 <sclv> or if one could combine the two.
17:35:43 * yitz googles and finds out that mnesia is erlang stuff
17:36:03 <sclv> it would be a classic haskell high-abstraction/low-level one-two punch
17:40:28 <mreh> does anyone know of any ideal solutions to the RWH book?
17:40:40 * yitz googles qdb and finds a db of stupid irc quotes on bash.org
17:40:44 <mreh> mine work, but some discussion would be nice
17:40:51 <crutcher> mreh: you may want to be more specific?
17:41:05 <mreh> the exercises at the end of certain chapters have solutions
17:41:11 <crutcher> mreh: are you asking if there's a complete set of idealized answers?
17:41:16 <mreh> i would like to see how other people may have presented theirs
17:41:42 <crutcher> Well, there's the RWH Google Group, and there's some discussion along those lines there
17:41:43 <mreh> that is what i wrote isn't it
17:41:47 <mreh> okay
17:41:49 <mreh> ta
17:41:59 <EmielRegis> anyone saw and does like to share about Zeitgeist II movie?
17:42:14 <yitz> hmm are unis using rwh already?
17:42:15 <roconnor> oh god, there is a sequel?
17:42:16 <dmwit> EmielRegis: Maybe in -blah
17:42:26 <EmielRegis> hah
17:42:55 <sclv> oops, kdb
17:42:56 <yitz> roconnor: RWH II?
17:43:04 <roconnor> :D
17:43:30 <Axman6> sclv: well i out a proposal on reddit_proposals for a purely haskell database
17:43:58 <sclv> yeah, but a typical database is no fun -- the point is what would be particularly useful for an embedded language database.
17:44:10 <crutcher> Axman6: what do you mean?
17:44:11 <sclv> kdb and mnesia each hit a different sweet spot in that regard.
17:44:14 * yitz googles kdb and finds a classical music radio station in Santa Barbara
17:44:34 <yitz> 93.7 FM
17:44:49 <crutcher> Axman6: implemented in haskell, implemented as a haskell library, providing haskell type query interfaces, or something else?
17:45:03 <sclv> http://kx.com/products/database.php
17:45:29 <Axman6> crutcher: i don't have anything more specific than a database written entirely in haskell, not using some other db backend
17:46:38 <sclv> mnesia is all about networked replication -- kdb is all about mmaping
17:46:49 <crutcher> Axman6: okay. Can I ask why? What advantage do seek? Or is this just a "Imagine a Beowulf Cluster of X" style suggestion?
17:47:00 <crutcher> s/do seek/do you seek/
17:47:40 <sclv> so kdb makes sense as a language embedded thing because you want speed, scalability, speed, scalability, speed.
17:47:54 <geezusfreeek> i would be insterested in seeing a relational database on top of happs or something
17:48:13 <mreh> isPalindrome []         = True
17:48:13 <mreh> isPalindrome [a]        = True
17:48:13 <mreh> isPalindrome (x:xs)     = (x == last xs) && isPalindrome (init xs)?
17:48:14 <geezusfreeek> happs-state, that is
17:48:26 <mreh> what do you make of that?
17:48:31 <dmwit> mreh: Looks good, but you can do a lot better.
17:48:32 <mreh> nicely laid out?
17:48:43 <Cale> mreh: Seems much slower than the obvious solution.
17:48:55 <Axman6> mreh: ans doesn't work i think
17:48:59 <Cale> But yeah, the layout is fine
17:49:00 <mreh> i am a n00b
17:49:04 <Axman6> since last xs never changes
17:49:07 <mreh> it bloody does work
17:49:09 <dmwit> Axman6: wrong
17:49:12 <ddarius> > ap (==) reverse "abcdcba"
17:49:13 <Cale> mreh: You know about the reverse function, yeah?
17:49:13 <lambdabot>   True
17:49:16 <Axman6> oh init, my bad
17:49:17 <ddarius> > ap (==) reverse "abcdcbax"
17:49:18 <lambdabot>   False
17:49:30 <dmwit> There goes ddarius with the spoilers.
17:49:42 <mreh> @define ap
17:49:44 <sclv> and such idiomatic ones at that!
17:49:46 <mreh> gah
17:49:53 <mreh> @type ap
17:49:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:49:58 <dmwit> ap f g x = f x (g x)
17:49:58 <sclv> @src ap
17:49:58 <lambdabot> ap = liftM2 id
17:50:10 <dmwit> (For the Reader monad.)
17:50:16 <Cale> ap is a monadic thing, he's using it in the (->) e monad, in which the type is just (e -> a -> b) -> (e -> a) -> (e -> b)
17:50:29 <mreh> i haven't gotten onto higher order functions quite yet, im on chapter 3
17:50:35 <mreh> i've definately seen them
17:50:43 <mreh> or monads
17:50:49 <Cale> It's the same as writing  (\xs -> xs == reverse xs)
17:50:59 <sclv> isAlmostPalindrome x = True
17:51:10 <Asztal> @djinn (e -> a -> b) -> (e -> a) -> (e -> b)
17:51:11 <lambdabot> f a b c = a c (b c)
17:51:32 <sjanssen> @yow
17:51:33 <lambdabot> I feel better about world problems now!
17:51:36 <sjanssen> @users
17:51:36 <lambdabot> Maximum users seen in #haskell: 637, currently: 583 (91.5%), active: 20 (3.4%)
17:51:40 <sjanssen> :(
17:51:41 <sclv> almost palindromes are cooler. give you way more variety!
17:51:50 <Cale> > isPalindrome xs = xs == reverse xs in isPalindrome "abcdcba"
17:51:51 <lambdabot>   <no location info>: parse error on input `='
17:51:59 <Cale> > let isPalindrome xs = xs == reverse xs in isPalindrome "abcdcba"
17:52:00 <lambdabot>   True
17:52:03 <sclv> cale for example is a great name -- its almost a palendrome!
17:52:19 <Cale> sclv: how so?
17:52:23 <dibblego> eh?
17:52:28 <sclv> its halfway there :-)
17:52:33 <Axman6> ha
17:52:44 <dmwit> > ap (==) reverse "CalelaC" -- more than half-way!
17:52:45 <Axman6> just missing the elaC
17:52:46 <lambdabot>   True
17:53:20 <sjanssen> aren't all words more than half way to a palindrome?
17:53:23 <Cale> mreh: It's important to note that last xs takes O(length xs) steps
17:53:29 <dmwit> sjanssen: Yes.
17:53:54 <sjanssen> mkPalindrome xs = xs ++ reverse (init xs)
17:54:14 <Cale> mreh: as does init xs, if fully evaluated
17:54:15 <dmwit> xs ++ tail (reverse xs)
17:54:40 <Cale> mreh: This is because  last [x] = x; last (x:xs) = last xs
17:54:55 <mreh> sure
17:54:59 <Cale> mreh: so the reduction looks like:  last [1,2,3] -> last [2,3] -> last [3] -> 3
17:55:15 <mreh> anyway, i dont know where i got the idea that doing it that way would be better
17:55:24 <Cale> So you don't want to use that on every iteration, or you'll end up taking quadratic time.
17:55:28 <mreh> probably because i've been programming imperative code for along time
17:55:36 <sjanssen> init xs ++ reverse xs
17:55:36 <mreh> yeah
17:56:06 <dmwit> sjanssen: Going for the least efficient version? ;-)
17:56:13 <sjanssen> dmwit: yes :)
17:56:36 <saml> > init "abc"
17:56:37 <lambdabot>   "ab"
17:56:46 <saml> > init == tail
17:56:47 <lambdabot>       No instance for (Eq ([a] -> [a]))
17:56:47 <lambdabot>        arising from a use of `==' at ...
17:56:48 <sjanssen> reverse . reverse . reverse . reverse . reverse . reverse . reverse $ init xs ++ reverse xs -- better
17:57:01 <ozy`> Axman6: say... what about implementing an SQL server in haskell?
17:57:06 <saml> can lambdabot check equality of two functions?
17:57:07 <dmwit> saml: init ~= reverse . tail . reverse
17:57:22 <dmwit> ?check liftM2 (==) init tail :: [Int] -> Bool
17:57:24 <lambdabot>   Couldn't match expected type `[Int] -> Bool'
17:57:24 <mreh> how would it do that
17:57:26 <sjanssen> @src init
17:57:26 <lambdabot> init [x]    = []
17:57:26 <Axman6> init should totally be defined like that
17:57:26 <lambdabot> init (x:xs) = x : init xs
17:57:26 <lambdabot> init []     = undefined
17:57:40 <sjanssen> Axman6: nah, the real defn. is lazier and more efficient
17:57:45 <ziman> saml, it's undecidable
17:57:49 <Axman6> sjanssen: i should hope so :P
17:57:57 <dmwit> ?check liftM2 (==) init tail
17:57:58 <yitz> @check \x -> ap (==) reverse x == (x == reverse x)
17:57:59 <lambdabot>   "* Exception: Prelude.init: empty list
17:58:00 <lambdabot>   "OK, passed 500 tests."
17:58:03 <dmwit> :t liftM2 (==) init tail
17:58:05 <lambdabot> forall a. (Eq a) => [a] -> Bool
17:58:19 <dmwit> Why couldn't it match [Int] -> Bool, then?
17:58:39 <dmwit> ?check (liftM2 (==) init tail) :: [Int] -> Bool
17:58:41 <dmwit> ?botsnack
17:58:51 <saml> oh init just drops the last item
17:58:54 <dmwit> Whooo boy, now I've really done it.
17:58:56 <lambdabot>   Couldn't match expected type `[Int] -> Bool'
17:58:56 <lambdabot> :)
17:59:06 <dmwit> hmm
17:59:15 <dmwit> ?check (liftM2 (==) init tail :: [Int] -> Bool)
17:59:17 <lambdabot>   "Falsifiable, after 0 tests:\n[1,-1]\n"
17:59:20 <dmwit> sigh
17:59:42 <sjanssen> dmwit: misssing reverse
17:59:44 <dmwit> Pasting arbitrary code into the middle of an expression is so hard to get right.
17:59:59 <dmwit> sjanssen: Oh, no, I wanted it to be falsifiable.
18:00:11 <mreh> Cale: is the better solution linear?
18:00:17 <dmwit> Somebody asked if lambdabot could check if the functions were equal...
18:00:19 <Cale> mreh: yeah
18:00:27 <sjanssen> ah
18:00:41 <Cale> reverse xs takes around n steps to finish
18:00:49 <Cale> and == takes around n steps as well
18:01:15 <mreh> isBetterPalindrome a = a == reverse a --this could do with some brackets though
18:01:19 <mreh> isBetterPalindrome a = (a == reverse a)
18:01:37 <geezusfreeek> to be fair, the less efficient version of init is also linear, just with a larger constant
18:01:38 <dmwit> mreh: Right, perfect!
18:01:49 <dmwit> mreh: I would prefer it with no parentheses, but that's a matter of taste.
18:02:00 <geezusfreeek> well, if it is evaluated fully anyway
18:02:02 <sjanssen> geezusfreeek: it is only the same efficiency in a strict language
18:02:04 <mreh> let isBetterPalindrome a = (a == reverse a) in isBetterPalindrome "hannah"
18:02:04 <dmwit> (Since conflating = and == in Haskell is basically a non-issue.)
18:02:06 <geezusfreeek> right
18:02:13 <geezusfreeek> i realized that after i said it
18:02:24 <mreh> > let isBetterPalindrome a = (a == reverse a) in isBetterPalindrome "hannah"
18:02:25 <lambdabot>   True
18:02:30 <Cale> mreh: Of course, there's an algorithm which takes half as many steps on strings where you have fast access to both ends, but for lists, you can't do much better.
18:02:34 <tromp_> @pl isBetterPalindrome a = (a == reverse a)
18:02:34 <lambdabot> isBetterPalindrome = ap (==) reverse
18:02:45 <dmwit> wut
18:02:52 <mreh> what what
18:03:04 <dmwit> lambdabot knows that (==) is symmetric?
18:03:18 <sjanssen> dmwit: @pl does, yes
18:03:22 <sjanssen> (or assumes it is)
18:03:22 <mreh> @src ap
18:03:22 <dmwit> ?pl flip (==)
18:03:22 <lambdabot> ap = liftM2 id
18:03:23 <lambdabot> (==)
18:03:25 <dmwit> wow
18:03:34 <sjanssen> @pl \x -> x + 1
18:03:34 <lambdabot> (1 +)
18:03:42 <dmwit> O_o
18:03:46 <sjanssen> @pl \x -> x == x
18:03:46 <lambdabot> join (==)
18:03:51 <sjanssen> aww :(
18:03:56 <dmwit> heh
18:04:04 <ddarius> sjanssen: You were hoping for True?
18:04:19 <mreh> Cale: my version is perfect for random access
18:04:34 <mreh> does haskell have to sacrifice that?
18:04:46 <Cale> mreh: Lists don't have random access
18:04:51 <ddarius> in any language
18:04:53 <sjanssen> ddarius: const True, yes
18:04:57 <mreh> of course
18:05:00 <Cale> Right, in any language.
18:05:07 <Cale> If they were arrays, you'd be fine.
18:05:19 <Cale> (Haskell does have arrays as well)
18:05:48 <mreh> but haskell couldn't match the n/2 time algorithm?
18:06:15 <ddarius> Of course it can, just use an array.
18:06:17 <Cale> Sure it could. It's just that the n/2 time algorithm needs as input a data structure with fast random access.
18:06:25 <mreh> okay
18:06:27 <Cale> (and a list is not that)
18:06:49 <mreh> i wrote java in haskell :D
18:08:38 <mreh> right, so 1/8 of the book down... 7/8 to go
18:10:01 <mreh> when this arrived the other day, i had visions that i might be coding some complex shit by the end of the week
18:10:42 <mreh> anyway, thanks
18:11:18 <crutcher> mreh: the more you learn about Haskell, the simpler your programs will become, until they disappear in a flash of mathematical abstraction
18:12:10 * ozy` suddenly explodes
18:12:17 <ozy`> I KNOW HASKELL!
18:12:44 <dmwit> I am going to COLLEGE!
18:12:46 <dmwit> ?yow!
18:12:46 <lambdabot> does your DRESSING ROOM have enough ASPARAGUS?
18:15:34 <Tobsan> lol what was that?
18:15:57 <dmwit> That's what happens when you touch a gas sphere.
18:16:09 <yitz> @. vixen yow!
18:16:09 <lambdabot> Plugin `compose' failed with: Unknown command: "yow!"
18:16:11 <dmwit> *Especially* if you've been eating spoiled fruit.
18:16:14 <yitz> @. vixen yow
18:16:14 <lambdabot> clarify...
18:16:24 <Plouj> hi
18:16:29 <Tobsan> hi Plouj
18:16:29 <Plouj> when a book writes "data Maybe a = Just a
18:16:32 <Plouj> doh
18:16:36 <dmwit> Hiya, Plouj!
18:16:53 <Plouj> when a book writes "data Maybe a = Just a | Nothing", does it defined the type Maybe or does it use the Prelude's type Maybe?
18:17:06 <dmwit> That is the Prelude's definition of Maybe a.
18:17:25 <yitz> @src Maybe
18:17:26 <lambdabot> data Maybe a = Nothing | Just a
18:17:27 <Plouj> and if I write that in a file, I'm essentially definining my own Maybe a?
18:17:31 <dmwit> Probably the book is demonstrating the syntax, and defining it again.
18:17:35 <dmwit> Plouj: Yes.
18:17:47 <dmwit> Plouj: You'd likely get errors about ambiguity if you ever tried to use it, though.
18:17:54 <Plouj> I'm just not sure what the first code example is trying to show in the "Parameterised types" @ http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html
18:18:18 <dmwit> Plouj: "Nothing" would be ambiguous: you'd have to write "Prelude.Nothing" or "Foo.Nothing" (where Foo is the name of the module you're writing) to disambiguate.
18:18:24 <Plouj> more specifially, is 'a' a type variable because it appears before the '='?
18:18:36 <dmwit> Yes.
18:18:37 <Tobsan> Plouj: yes
18:18:42 <Plouj> I see
18:18:54 <ddarius> 'a' is a type variable regardless of where it occurs in a type...
18:18:55 <Plouj> that explains a lot
18:19:03 <Plouj> oh?
18:19:12 <juturnas> so will head $ filter predicate list be lazy? stop filtering once it finds the first element that satisfies pred?
18:19:13 <Plouj> what if I do data Maybe = a
18:19:23 <ddarius> It's a parameter to Maybe because it appears before the =
18:19:29 <dmwit> Plouj: You can only use bound type variables on the right of the '='.
18:19:35 <ddarius> Plouj: Then 'a' is not in scope, but it is still a type variable.
18:19:39 <dmwit> Plouj: You bind type variables by letting them appear on the left of the '='.
18:19:43 <yitz> juturnas: yes
18:19:43 <dmwit> Plouj: So,
18:19:55 <juturnas> yitz: thanks
18:19:59 <dmwit> data Maybe a {- this binds a -} = Nothing | Just a {- this uses the bound occurrence of a -}
18:20:22 <yitz> > head $ filter even [1,3,5,7,8,9]
18:20:23 <lambdabot>   8
18:20:36 <dmwit> > find even [1,3,5,7,8,9]
18:20:37 <yitz> > head $ filter even [1..]
18:20:49 <dmwit> *poke*
18:20:54 <lambdabot>   Just 8
18:20:54 <lambdabot>   2
18:21:16 <Plouj> :info Main.Maybe
18:21:16 <Plouj> data Main.Maybe a = Main.Just a | Main.Nothing -- Defined at Nullable.hs:1:5-9
18:21:17 <Plouj> heh
18:21:19 <wy> phew... finished learning "design patterns" in one day
18:21:31 <Plouj> and I didn't have to specify the Main.* in the source file :)
18:21:41 <Tobsan> Plouj: so the definition of Maybe means that maybe something is either Nothing, or Just something
18:21:53 <Plouj> Tobsan: I understand that
18:21:55 <crutcher> wy: what do you mean?
18:21:59 <Tobsan> great!
18:22:14 <wy> crutcher: The design patterns of GoF, of OOP... :P
18:22:15 <crutcher> wy: I've been learning design patterns for about 6 years now
18:22:34 <crutcher> you mean, you read the book in a day?
18:22:39 <wy> crutcher: my god... how long have you been on haskell channel?
18:22:54 <wy> yeah... actually wikipedia pages. I don't have the book
18:23:15 <crutcher> okay. design patterns predate the GoF to some extent
18:23:43 <crutcher> you may be interested in reading "A Pattern Language", though its about archetecture (the building stuff with stuff kind, not computers)
18:23:52 <wy> well. my conclusion of my 7 hours of reading is that they are all nonsense :p
18:24:23 <ozy`> > [ () .. ]
18:24:23 <crutcher> well, you are certainly entitled to your well researched and informed opinion
18:24:24 <lambdabot>   [()]
18:24:30 <ozy`> !!!
18:24:42 <crutcher> 7 hours is a very long time, after all
18:24:44 <yitz> > [()..()]
18:24:45 <lambdabot>   [()]
18:25:08 <crutcher> I've got 10 minutes, could you explain category theory to me?
18:25:09 <ozy`> > [ [] .. ]
18:25:10 <lambdabot>       No instance for (Enum [a])
18:25:10 <lambdabot>        arising from the arithmetic sequence ...
18:25:11 <yitz> > [1..1]
18:25:12 <lambdabot>   [1]
18:25:35 <wy> I found for each pattern a functional programming correspondence that would make them trivial
18:26:53 <crutcher> "design patterns" are collections of recurrent solutions in a given domain. they represent a know 'good' way to balance a collection of design 'forces'.
18:27:03 * shapr boings
18:27:05 <shapr> @users
18:27:07 <lambdabot> Maximum users seen in #haskell: 637, currently: 580 (91.1%), active: 21 (3.6%)
18:27:11 <crutcher> all complex domains where people get real work done end up having them
18:27:13 <yitz> > [(),()..()]
18:27:14 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
18:27:24 <crutcher> but they don't necessarily translate to other domains
18:27:25 <rwbarton> > [1,1..1]
18:27:27 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:28:14 <crutcher> so, a collection of patterns designed to solve recurrent problems in imperative OO languages probably won't make much sense in a pure FP language
18:28:15 <yitz> shapr: you've been credited with this channel's success. congrats!
18:28:47 <wy> crutcher: That's why OO sucks :)
18:29:22 <wy> I didn't realize why most FP people hate OO until I learned design patterns ... wow
18:29:42 <crutcher> Once again, I must bow to your extensive research, and stunning command of rhetoric
18:30:03 <Plouj> man, I feel the pain for various people commenting in RWH online
18:30:16 <ozy`> Plouj: oh?
18:30:20 <Plouj> "The errors are extremely distracting. I don't know what this example is trying to communicate. I'm a reader who doesn't know Haskell and who is using this book as an introduction."
18:30:41 <ozy`> oops
18:30:45 <Plouj> that's a result of the author not including "deriving (Show)" at the end of the type
18:30:54 <wy> Plouj: what is RWH
18:31:00 <Plouj> Real World Haskell
18:31:08 <Plouj> wy: see topic :)
18:31:40 <yitz> @where rwh
18:31:40 <lambdabot> is http://www.realworldhaskell.org/blog/
18:31:57 <wy> Plouj: I like the words "real world" :)
18:32:05 <Plouj> wy: me too!
18:32:37 <ozy`> @src (>.>)
18:32:37 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
18:33:03 <ozy`> @src (>.)
18:33:03 <lambdabot> Source not found. Maybe you made a typo?
18:33:06 <ozy`> @src (.>)
18:33:07 <lambdabot> Source not found. Maybe you made a typo?
18:33:27 <Plouj> "Too bad I'm totally lost here, because you haven't told me what "Just" is."
18:33:40 <yitz> @hoogle (>.>)
18:33:40 <lambdabot> No results found
18:33:45 <yitz> @hoogle (>.)
18:33:46 <lambdabot> No results found
18:35:03 <ozy`> hoogle doesn't search (common) hackage APIs, does it?
18:35:16 <shapr> yitz: yay!
18:35:55 <shapr> yitz: In reality, dons has been the primary contributor to #haskell's success the past few years.
18:36:23 <yitz> shapr: I'd say Cale's pretty big as well.
18:36:51 <rwbarton> ozy`: I think that feature was recently added.
18:37:21 <yitz> shapr: it's a great community. the claim is that you set the tone though, and I think that is indeed important.
18:37:48 <shapr> yitz: Yeah, I agree.
18:38:46 <rwbarton> How am I supposed to convert a string like "2009-01-01 16:45:05" into a CalendarTime?
18:39:29 <shapr> bringert's ParseDate?
18:39:34 <shapr> matt_estes: y0
18:39:53 <shapr> rwbarton: Have you tried ParseDate?
18:39:58 <matt_estes> shapr: What's y0?
18:40:12 <rwbarton> shapr: Taking a look at it now, thanks.
18:40:15 <shapr> matt_estes: It's the customary greeting on the streets of Birmingham, I do believe.
18:40:21 <shapr> y0, w4ssup?
18:40:42 <matt_estes> shapr: Oh wait. Nevermind. I'm illiterate tonight :). Wasn't expecting l33t speak in the Haskell channel off the bat :)
18:40:44 <yitz> > Data.Time.Format.readTime "2009-01-01 16:45:05" :: Data.Time.TimeOfDay
18:40:45 <lambdabot>   Couldn't match expected type `System.Locale.TimeLocale'
18:40:55 <yitz> > Data.Time.Format.readTime "2009-01-01 16:45:05"
18:40:56 <lambdabot>   Couldn't match expected type `System.Locale.TimeLocale'
18:41:04 <sbahra> @hoogle readTime
18:41:05 <lambdabot> Data.Time.Format readTime :: ParseTime t => TimeLocale -> String -> String -> t
18:41:21 <sbahra> :i TimeLocale
18:41:27 <sbahra> @info TimeLocale
18:41:27 <lambdabot> TimeLocale
18:41:33 <sbahra> nice
18:41:38 <sbahra> @src TimeLocale
18:41:38 <lambdabot> Source not found.
18:44:10 <yitz> > Data.Time.Format.readTime defaultTimeLocale "2009-01-01 16:45:05"
18:44:12 <lambdabot>   Not in scope: `defaultTimeLocale'
18:44:22 <yitz> > Data.Time.Format.readTime System.Locale.defaultTimeLocale "2009-01-01 16:45:05"
18:44:23 <lambdabot>       Overlapping instances for Show (String -> t)
18:44:24 <lambdabot>        arising from a use ...
18:44:44 <yitz> > Data.Time.Format.readTime System.Locale.defaultTimeLocale "2009-01-01 16:45:05" :: Data.Time.TimeOfDay
18:44:45 <lambdabot>   Couldn't match expected type `time-1.1.2.1:Data.Time.LocalTime.TimeOfDay.Ti...
18:45:36 <yitz> > Data.Time.Format.readTime System.Locale.defaultTimeLocale "2009-01-01 16:45:05" :: Data.Time.LocalTime
18:45:37 <lambdabot>   Couldn't match expected type `time-1.1.2.1:Data.Time.LocalTime.LocalTime.Lo...
18:46:11 <yitz> > Data.Time.Format.readTime System.Locale.defaultTimeLocale "2009-01-01 16:45:05" :: Data.Time.LocalTime.LocalTIme
18:46:12 <lambdabot>       Not in scope:
18:46:12 <lambdabot>        type constructor or class `Data.Time.LocalTime.Loc...
18:46:16 <yitz> > Data.Time.Format.readTime System.Locale.defaultTimeLocale "2009-01-01 16:45:05" :: Data.Time.LocalTime.LocalTime
18:46:17 <lambdabot>   Couldn't match expected type `time-1.1.2.1:Data.Time.LocalTime.LocalTime.Lo...
18:46:41 <rwbarton> shapr: Hmm, that code does the same as my little parsec parser, namely choose a fixed day of week and day of year
18:46:48 <rwbarton> shapr: Which doesn't actually matter to me, but seems kind of ugly
18:48:15 <rwbarton> Actually, I guess it does kind of matter
18:59:59 <shapr> rwbarton: I'm pretty sure ParseDate can parse just about any sort of date format.
19:01:13 <rwbarton> shapr: The part I was missing was how to fill in, say, the day of the week correctly
19:01:31 <rwbarton> shapr: Which my cursory examination of the ParseDate source indicated it didn't do.
19:01:44 <rwbarton> shapr: But, I solved that using toUTCTime . toClockTime
19:30:22 <eyeris> Running `cabal update` gives no error, but running `cabal list` results in this error: cabal: Couldn't read cabal file "./arff/0.1.0/arff.cabal"
19:30:45 <eyeris> Is this a problem with my cabal installation or with the Hackage files?
19:31:29 <eyeris> nvm, this is version 0.4.3
19:32:19 <Twey> @pl \a b -> a == ' ' && b == ' '
19:32:19 <lambdabot> (. (' ' ==)) . (&&) . (' ' ==)
19:33:15 <eyeris> I can never understand the rules for application with pointless code
19:33:55 <fnord123> when i run cabal list, I'm given a list of available pkgs until the G's told: cabal: Couldn't read cabal file ".Glob/0.1/Glob.cabal". I'm not sure why it cares about Glob 0.1 when the current version is 0.3.2
19:34:16 <eyeris> fnord123 what version is printed by `cabal -V`?
19:34:45 <fnord123> 0.5.2, using cabal lib 1.4.2
19:34:57 <eyeris> 0.6 is the current
19:35:08 <eyeris> I don't think Hackage promises any backward compat
19:35:14 <eyeris> Not sure though
19:35:41 <fnord123> well i can't update cabal because it can't figure out how to get syb version >= 0.4
19:36:21 * fnord123 goes to hand install an update
19:37:15 <BMeph> fnord123: try 'cabal install cabal-install' :)
19:40:37 <eyeris> I get a GHC panic building Cabal 1.6.0.1
19:41:09 <eyeris> with GHC 6.8.2
19:45:02 <tehgeekmeister> is there any way to have a personal hoogle offline?
19:45:24 <eyeris> tehgeekmeister yeah, look up hoogle on hackage
19:45:39 <mmorrow> tehgeekmeister: i build my haddocks with these options:
19:45:42 <eyeris> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hoogle
19:45:44 <mmorrow> (one sec)
19:46:08 <eyeris> There's even an interface to communicate with hoogle from emacs, IIRC
19:46:08 <mmorrow> ./Setup haddock --hyperlink-source --hoogle --haddock-options=--html
19:46:25 <tehgeekmeister> nice!  thanks very much.
19:46:33 <mmorrow> which sticks the docs + hscoloured code + <pkgname>.txt in dist/doc/html/<pkgname>
19:46:45 <fnord123> thanks, that brought me up to date so I can list packages, but I can't upgrade as I still require syb with base >= 4.0. Interestingly, If I try to manually install xmonad-utils I get: cabal: cannot configure xmonad-utils-0.1. It requires ghc >=6.8 && >=6.8 && >=6.8 && >=6.8 && >=6.8 && >=6.8
19:46:46 <mmorrow> so then you just use hoogle to "convert"
19:46:53 <rwbarton> I couldn't get the emacs hoogle interface to work, so I rolled my own (but hardly ever use it)
19:47:08 <mmorrow> dist/doc/html/<pkgname>/<pkgname>.txt to a .hoo
19:47:46 <mmorrow> i only use it on occasion (from the command line), but the times that i do it's very useful
19:48:17 <rwbarton> mostly I just type "h foo" into my browser :)
19:48:53 <mmorrow> i forget their nick, but someone has this sweet Makefile that puts a custom frame-based overlay on haddock docs which has a searchable-via-textbox hoogle hookup
19:49:05 * mmorrow tries to find the url
19:49:19 <mmorrow> i keep meaning to start using that (or similar)
19:49:23 <mmorrow> it's pretty slick
19:49:41 <scodil> hey can someone take a look at http://hpaste.org/13595 and tell me why it doesn't run faster with multiple threads? It doesn't even use the second cpu
19:49:54 <roconnor> scodil: what ghc options are you using?
19:50:10 <scodil> -O2 -threaded
19:50:16 <mmorrow> sweet i found it (it's the author of hledger). here's a sample http://joyful.com/repos/darcs-unstable/api-doc/
19:50:20 <rwbarton> eyeris: Really?  I did the cabal-install bootstrap.sh thing just a few hours (on a new debian machine) with no problems (once I installed various extralibs)
19:50:22 * mmorrow fins the Makefile
19:51:18 <geezusfreeek> scodil, you using +RTS -N<threads> when you run it?
19:51:27 <scodil> geezusfreeek: yeah
19:51:52 <mmorrow> the goods: http://joyful.com/repos/hledger/Makefile
19:52:00 * roconnor wonders if it should be par a $ pseq b $ Map.union a b  or if seq is good enough.
19:52:09 <mmorrow> looks like it's
19:52:11 <mmorrow> make hoogleweb
19:52:14 <scodil> it should be nearly 2x speedup, cause the two maps don't overlap.
19:52:38 <scodil> so i'm not using par right or something
19:53:19 <roconnor> scodil: I'm not a multitreaded expert, but I see the par pseq comination a lot
19:53:24 <roconnor> combination
19:53:28 <rwbarton> scodil: how much of the runtime does it take to do theMap = let ... in seq b Map.empty ?
19:53:30 <scodil> pseq?
19:53:39 <roconnor> parrell sequence?
19:53:41 <roconnor> um
19:53:44 <roconnor> ...
19:53:50 <roconnor> I forget what it does
19:53:53 <scodil> @hoogle pseq
19:53:53 <lambdabot> Control.Parallel pseq :: a -> b -> b
19:54:00 <roconnor> but it is like seq, but for parallel stuff
19:54:08 <roconnor> ... not sure that quite makes sense
19:54:31 <roconnor> you can tell that I'm not an expert :)
19:54:42 <scodil> no change using pseq
19:55:15 <scodil> rwbarton: lemme find out. What are you getting at?
19:55:23 <mmorrow> scodil: i think this should work http://hpaste.org/13595#a1
19:55:30 <rwbarton> scodil: Well I'm not sure how much evaluation 'par' causes.
19:55:30 <roconnor> oh, does seq actually normalize a Map?
19:55:43 <rwbarton> scodil: If it's only to WHNF, then maybe that's not much of your computation.
19:55:54 <scodil> rwbarton: it takes half the time, which I'd expect
19:55:57 <dmwit> roconnor: seq calculates the (entire) spine of a Map
19:56:07 <mmorrow> scodil: at least, that's the pattern used in the canonical "mean" prog
19:56:19 <mmorrow> which has a massive speedup
19:56:28 <roconnor> dmwit: okay, that sounds pretty good for flattening out union calls
19:56:29 <scodil> rwbarton: IntMap's are strict, that is, they have a strict tree structure. The stored values are lazy
19:56:46 <rwbarton> OK, so it sounds like enough of your computation is in the spine
19:56:51 <rwbarton> (and also not in query)
19:57:13 <roconnor> mmorrow: which way do par and pseq associate?
19:57:51 <mmorrow> , src 'par
19:57:53 <mmorrow> , src 'pseq
19:58:04 <roconnor> par = const
19:58:04 <mmorrow> scodil: i got >100%, but not much
19:58:05 <lunabot>  par :: forall a b . a -> b -> b
19:58:07 <mmorrow> real    0m5.131s
19:58:07 <mmorrow> user    0m5.411s
19:58:10 <roconnor> pseq = const
19:58:10 <lunabot>  pseq :: forall a b . a -> b -> b
19:58:23 <scodil> mmorrow: how is that different? I don't see any speedup, and I'd think it should be identical in every way
19:58:32 <scodil> you only changed $ to infix?
19:58:33 <mmorrow> roconnor: oh oops, i thought that would've return the fixities
19:58:38 <roconnor> :)
19:58:49 <mmorrow> scodil: i added pseq instead of seq
19:58:50 <rwbarton> roconnor can only do one thing at a time
19:59:16 <scodil> can someone else run it? You know, sanity check?
19:59:16 <mmorrow> scodil: i'm about to see if that improves over seq
19:59:17 <eyeris> Can anyone here build Cabal 1.6.0.1 with GHC 6.8.2?
19:59:42 <eyeris> (on x86_64)
20:00:33 <rwbarton> scodil: I get a speedup with your original code
20:00:39 <scodil> how much?
20:00:49 <mmorrow> scodil: actually, seq is faster than pseq and is more parallel on my box
20:01:08 <rwbarton> scodil: http://hpaste.org/13595#a2
20:01:13 <mmorrow> (faster my .05 seconds)
20:01:18 <mmorrow> *by
20:05:25 <scodil> http://hpaste.org/13595#a3
20:05:29 <roconnor> @type liftM2 (&&)
20:05:31 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
20:05:43 <scodil> using forkIO I get _some_ speedup, but its lame
20:05:51 <scodil> I would think it would be more
20:06:14 <JasonFelice> How do you import a data constructor?
20:06:28 <roconnor> same way you import a function, or
20:06:48 <scodil> 10 seconds to 8 seconds
20:06:48 <roconnor> if you want to import all data constructors you can import  Foo (DataType(..))
20:07:05 <roconnor> the (..) will give you all constructors
20:07:13 <scodil> where is the sequential bottleneck there? Garbage collection?
20:07:28 <rwbarton> scodil: could be memory bandwidth
20:07:32 <rwbarton> scodil: there is a lot of GC going on
20:07:46 <JasonFelice> roconnor: I can "import Network" and use PortNumber, I can't "import Network (PortNumber)" and use PortNumber.
20:08:11 <rwbarton> JasonFelice: I'm pretty sure you're not supposed to use the PortNumber constructor, but instead the Num instance
20:08:18 <roconnor> @src PortNumber
20:08:19 <lambdabot> Source not found. I am sorry.
20:08:24 <roconnor> @hoogle PortNumber
20:08:25 <lambdabot> No results found
20:08:49 <ddarius> listenOn (PortNumber 80)
20:08:49 <roconnor> JasonFelice: oh sorry, my bad
20:09:04 <BMeph> JasonFelice: Not in GHCi, only in a file. :)
20:09:08 <rwbarton> JasonFelice: Or, maybe I am confusing it with something else
20:09:48 <BMeph> (In case that was how you were trying to use it; if not, then just ognore me, everyone does. Just ask my wife! ;p)
20:09:50 <JasonFelice> eh, there's a PortNumber type and a PortID constructor "PortNumber" ...
20:09:55 <BMeph> *ignore
20:10:49 <rwbarton> Oh, right.  It's the constructor for the PortNumber type you don't want to use, I think.
20:10:54 <dmwit> JasonFelice: Yes, I've gotten caught by that, too.
20:10:56 <JasonFelice> That is how I was trying to use it, thanks.  import Network (PortID(PortNumber))
20:11:01 <scodil> rwbarton: you're right. I bumped the heap size way up and I get 2x speedup, but only using forkIO, not with par. Why not both?
20:11:10 <roconnor> JasonFelice: ya that's right
20:11:17 <roconnor> JasonFelice: I was totally wrong before. Sorry
20:12:08 <rwbarton> scodil: if you run the original with +RTS -sstderr -N2, does it show that the task ran on multiple threads?
20:13:28 <JasonFelice> roconnor: np
20:14:04 <scodil> rwbarton: yes, but I can see on top that its not using both cores
20:14:16 <scodil> forkIO uses both
20:14:25 <roconnor> ironically this PortNumber thing shows exactly why consturctors must be imported with their datatypes.
20:15:05 <rwbarton> scodil: so the status shows 4 tasks or something, but only one has MUT time, or something
20:15:14 <rwbarton> scodil: hmm that was pretty vague :P
20:16:04 <scodil> no, they all do work
20:16:10 <scodil> 4 workers
20:16:15 <scodil> er, tasks
20:16:30 <scodil> oh wait maybe I'm looking at the parallel gc stats
20:16:43 <scodil> I don't know how to read this
20:16:56 <rwbarton> what ghc version?
20:17:01 <rwbarton> I am running 6.8.2
20:17:01 <scodil> 6.10
20:17:06 <Osah_> need professional haskell help -- will trade my kidney or baseball trade cards in xchange
20:17:27 <dmwit> Go ahead and ask your question.
20:17:39 <dmwit> If somebody has time and knows the answer, they'll reply.
20:17:40 <rwbarton> scodil: Hmm, I guess it could be a regression.  par can be unpredictable
20:17:42 <roconnor> Osah_: which baseball cards?
20:17:48 <ddarius> http://www.well-typed.com/who_we_are
20:19:36 <roconnor> ``Whether you have a new team member with no Haskell experience who needs to learn the basics, or experienced Haskellers who need to master some advanced topics, they can provide a training program tailored to your needs.
20:20:32 * roconnor wonders if Ian Lynagh needs a kidney
20:20:56 <scodil> rwbarton: 6.8.3 gets my 1.5x speedup with par, and 2x with forkIO
20:21:00 <scodil> gets me
20:21:14 <scodil> 6.10 has no speedup with par, and 2x with forkIO
20:21:43 <mmorrow> weird. i'm not sure if this has anything to do with it, but System.Random sucks
20:21:50 <scodil> mmorrow: me?
20:21:55 <mmorrow> yes
20:22:02 <roconnor> dmwit: does looking up in a Map for the (entire) spine?
20:22:04 * mmorrow is getting an inexplicable stack overflow
20:22:05 <scodil> I tried mersenne twister, that didn't help
20:22:23 <rwbarton> scodil: I get basically the same results with par and forkIO: about 1.5x in either case
20:22:29 <dmwit> roconnor: Maps are spine-strict; anything that inspects a Map in any way forces the entire spine.
20:22:39 <mmorrow> scodil: i'm experimenting with ways to make it more parallel and i think Sys.Rand is biting me
20:22:51 * mmorrow is just ranting
20:22:56 <rwbarton> scodil: the fact that it's not 2x looks to be exactly attributable to the non-parallel GC
20:23:10 <rwbarton> scodil: (again this is on 6.8.2)
20:23:10 <mmorrow> ooh, interesting.
20:23:30 <scodil> rwbarton: yeah, and on 6.10 the GC tells me that its parallelizing nicely, 1.9 out of 2
20:23:40 <scodil> which is why with forkIO I get 2x
20:23:44 <scodil> or, like, 1.9
20:23:52 <rwbarton> so it sounds like the parallel GC is a win, and there's something wrong with par
20:24:05 <scodil> ugh
20:25:19 <JasonFelice> Hmm, while I'm here, someone want to see if they can figure out a constant-time speed improvement to a programming contest problem I can't get accepted using Haskell?
20:25:31 <rwbarton> odd that not even the GC is being parallelized with the par version
20:25:41 <scodil> I think it is
20:26:11 <rwbarton> oh, then you should see about a 15% speedup I guess
20:26:24 <scodil> you'd think
20:26:34 <rwbarton> unless there is some overhead difference between -N1 and -N2
20:26:42 <scodil> yeah with par GC is doing 1.95
20:26:47 <scodil> work balance, whatever that means
20:26:59 <mmorrow> scodil: heh, my attempt sucked anyways (just tested with a static list)
20:27:23 <rwbarton> JasonFelice: Sure.  Is it for SPOJ?
20:28:04 <JasonFelice> rwbarton: yes, PRIME1.
20:28:27 <JasonFelice> I know there's more elegant solutions, but I'm trying to get the "standard" solution accepted w/Haskell.
20:28:30 <rwbarton> Ah, someone was talking about that recently
20:28:55 <JasonFelice> Me = eraserhd on TopCoder.  I think I vaguely recognizer your name .... maybe??
20:29:15 <JasonFelice> or not.
20:29:16 <rwbarton> rwbarton = reid
20:29:35 <rwbarton> I haven't done TopCoder in some time
20:29:47 <mauke> you know what's fun in haskell?  http://www.spoj.pl/problems/FOOL/
20:33:55 <JasonFelice> My TLE attempt at PRIME1: http://paste.lisp.org/display/73040
20:36:13 <rwbarton> JasonFelice: It doesn't look substantially different from mine.  One thing you can do is use rem instead of mod, it's a little faster.
20:36:25 <rwbarton> JasonFelice: But maybe you just need to put {-# OPTIONS_GHC -O2 #-} at the top
20:36:47 <scodil> why is rem faster than mod?
20:36:55 <JasonFelice> I tried with {-# OPTIONS -O2 #-}, is {-# OPTIONS_GHC different?
20:37:07 <rwbarton> scodil: Because hardware implements rem, not mod
20:37:17 <rwbarton> JasonFelice: I doubt it
20:37:24 <rwbarton> but it might be worth a try
20:37:36 <roconnor> hardware is stupid
20:37:38 <roconnor> and evil
20:37:46 <mauke> I thought -O2 was the default
20:38:12 <rwbarton> on SPOJ? maybe
20:39:22 <rwbarton> JasonFelice: Oh, duh
20:39:28 <rwbarton> JasonFelice: All your numbers are defaulting to Integer
20:39:34 <rwbarton> JasonFelice: Maybe?
20:39:37 <mauke> no, they aren't
20:39:45 <mauke> line 2
20:39:48 <scodil> rwbarton, mmorrow: http://hackage.haskell.org/trac/ghc/ticket/2868
20:39:49 <rwbarton> Well, maybe isPrime isn't getting specialized?
20:39:59 <Saizan> All your numbers are belong to Integer ?
20:40:05 <scodil> I've got "microbenchmarkitis"
20:40:10 <scodil> apparently
20:40:17 <rwbarton> I don't trust programs without top-level type declarations :)
20:40:18 <mauke> it should be
20:40:26 <mauke> smallPrimes should be monomorphic
20:40:52 <JasonFelice> OK, you need to define "monomorphic".  That's a term I'm going to have to use to sound smart at work.
20:41:09 <mauke> no type variables
20:41:12 <roconnor> Int -> Int is monomorphic
20:41:19 <roconnor> a -> a is polymorphic
20:41:30 <mauke> [Int] instead of (Num a) => [a]
20:42:39 <JasonFelice> Anyway, isn't Int 31 bits?  The limits are 10**9.
20:42:41 <rwbarton> Maybe the massive [Int] literal is the problem.  My program computed that at run-time.
20:42:51 <rwbarton> Right, you should be using Int.
20:43:00 <rwbarton> I just didn't spot the two places where you wrote :: Int right away.
20:43:02 <ddarius> > (minBound, maxBound) :: (Int, Int)
20:43:03 <lambdabot>   (-9223372036854775808,9223372036854775807)
20:43:20 <centrinia> I thought (maxBound :: Int) is platform dependent.
20:43:25 <ddarius> It is.
20:43:29 <ddarius> You are only guaranteed 29 bits.
20:43:33 <roconnor> , maxBound :: Int
20:43:39 <lunabot>  2147483647
20:43:43 <rwbarton> But the platform is fixed in this case :)
20:43:49 <ddarius> For GHC, it is the machine word size.
20:44:05 <mauke> forall platform. (Sane platform) =>
20:44:28 <centrinia> Can I implement a Haskell runtime that defines Int as being a signed 36 bit integer?
20:44:37 <ddarius> centrinia: Yes.
20:44:43 <roconnor> ?faq Can I implement a Haskell runtime that defines Int as being a signed 36 bit integer?
20:44:44 <lambdabot> The answer is: Yes! Haskell can do that.
20:44:54 <roconnor> it's in the faq
20:49:51 <JasonFelice> PRIME1 AC - All I did was add "smallPrimes :: [Int]"
20:51:04 <rwbarton> Hah!
20:51:30 <JasonFelice> ALthough, they did just upgrade the system... Hmm, lemme try without again.
20:52:00 <centrinia> Is there a function (f) where { primes = 2:3:zipWith f primes (tail primes); } ?
20:52:16 <ddarius> Integers are a lot slower than Ints.
20:52:57 <roconnor> centrinia: yes
20:53:31 <mmorrow> scodil: oh interesting (re: the ticket)
20:53:34 <Axman6> centrinia: i can't see how that'd produce a list of primes
20:53:38 <roconnor> centrinia: technically
20:53:44 <centrinia> @faq Can Haskell define a function (f) where { primes = 2:3:zipWith f primes (tail primes); } ?
20:53:45 <lambdabot> The answer is: Yes! Haskell can do that.
20:53:46 <rwbarton> does -fglasgow-exts turn off the monomorphism restriction (in 6.6.1)?  They could have that on I guess...
20:53:55 <ddarius> rwbarton: It shouldn't.
20:54:12 <centrinia> roconnor, what is this function?
20:54:57 <rwbarton> f _ p = head . filter isPrime $ [p+1..]
20:54:58 <roconnor> centrinia: f _ x = (dropWhile (/=) other_primes_definition)!!2
20:55:17 <roconnor> er
20:55:18 <centrinia> Oh.
20:55:19 <roconnor> (/=x)
20:55:27 <roconnor> but rwbarton's is better
20:56:28 <JasonFelice> Hmm, I can't get it to TLE, and I'm back to my original submission.
20:56:32 <roconnor> centrinia: perhaps you would be intrested in http://r6.ca/blog/20081116T213644Z.html
20:57:03 <roconnor> I wonder that post is a koan?
20:57:09 <roconnor> wonder if
20:57:27 <roconnor> I guess not
20:58:01 <naturalethic> well i've been searching around for an hour with no luck, so here goes, what do I have to do to get the RWH exceptions to work with GHC 6.10
20:58:08 <naturalethic> compiler wants more type info
21:00:51 <rwbarton> JasonFelice: As in, you downloaded your TLE solution and reuploaded it and it now works?
21:01:56 <mauke> naturalethic: hmm, try Control.OldException?
21:02:49 <naturalethic> mauke: yup that's it
21:06:48 <rwbarton> JasonFelice, mauke: Apparently SPOJ compiles with -O --make.
21:07:06 <mauke> sux
21:07:48 <JasonFelice> I'm getting TLE if I reupload my old solutions.  I was trusting that I got TLE with this one, since someone on TopCoder said they couldn't get it to pass.  (It was mine, very slightly tweaked).
21:09:40 <rwbarton> JasonFelice: Sounds like time for binary search :)
21:10:54 <JasonFelice> And the exact text "jthread" posted as not being able to pass, passes.
21:14:09 <JasonFelice> Here's the actual TLE code, then: http://paste.lisp.org/display/73043
21:16:13 <JasonFelice> Ahg.  I see the problem.  It's my fault.
21:22:19 <crutcher> JasonFelice: maybe you want to change p >= n = True to p >= n ^ (2 :: Int) = True
21:22:53 <crutcher> gah, got that backwards
21:22:55 <JasonFelice> crutcher: Close.  Change "p >= n" to "p * p > n"
21:23:10 <JasonFelice> Heh.
21:23:23 <crutcher> I just can't stay awake today
21:23:48 <crutcher> also, don't scan over even numbers
21:24:27 <JasonFelice> How?  The method I had took slightly longer when special casing evens.
21:25:03 <crutcher> how were you special casing them?
21:26:27 <crutcher> consider replacing [m..n] with (primeCandidates m n), and then generating a suitable def for primeCandidates
21:26:55 <JasonFelice> I had made the [m..n] in findPrimes some kind of list comprehension that returned only odds.
21:27:25 <mauke> let m' = m + fromEnum (even m) in [m', m' + 2 .. n]
21:27:34 <mm_freak> damn, it happens to me often that i write ">>= less" instead of "| less" on the shell
21:27:37 <crutcher> JasonFelice: did it _test_ to see if they were odd, or did it generate only odds?
21:27:57 <mm_freak> i even found myself writing "filename <- cmd" instead of "cmd > filename"
21:28:08 <JasonFelice> crutcher: I think it probably tested.
21:28:19 <jsn> mm_freak: well, that should give us some ideas
21:28:30 <JasonFelice> crutcher: But now I can think of a better way...
21:28:40 <mm_freak> jsn: yeah, the shell session can be interpreted as one large do block =)
21:29:07 <geezusfreeek> the bash monad
21:29:15 <mm_freak> zsh in my case
21:29:27 <jsn> the monad it it's in has some streams as part of the state
21:29:28 <geezusfreeek> ricer shell
21:29:30 <geezusfreeek> :P
21:29:56 <jsn> all the individual shell monads are transformers on the `sh` monad
21:30:00 * geezusfreeek likes zsh too, but never really bothered to learn it well enough to justify using it a lot
21:30:14 <rwbarton> Ba Sh ()
21:30:22 <jsn> LOLz
21:30:23 <geezusfreeek> ha!
21:30:26 <mauke> BadumT Sh
21:30:32 <shapr> zsh r0xx
21:30:41 <jsn> mauke: you win the internet
21:30:49 <mm_freak> @let isPrime n = and $ map (\x -> n `rem` x /= 0) $ takeWhile (\x -> x*x <= n) primes
21:30:51 <lambdabot>  <local>:1:74: Not in scope: `primes'
21:31:00 <mm_freak> d'oh
21:31:07 <crutcher> JasonFelice: I've not looked at this in a while, but here's my solution: http://hpaste.org/13596
21:31:40 <mm_freak> > let isPrime n = and $ map (\x -> n `rem` x /= 0) $ takeWhile (\x -> x*x <= n) primes; primes = 2 : filter isPrime [3..] in primes
21:31:42 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
21:32:31 <mm_freak> jsn: i think, the IO monad is fully sufficient =)
21:32:36 <mm_freak> no need for a shell monad
21:32:47 <jsn> mm_freak: well, you need to tie the streams together
21:33:06 <crutcher> mm_freak: primes = 2 : 3 : 5 : filter isPrime [k + i | k <- [6,12..], i <- [1,5]]
21:33:14 <mm_freak> ah yeah
21:33:25 <jsn> all valid values in the shell monad should have some knowledge of stdin, stdout and stderr
21:33:51 <mm_freak> crutcher: then you could just as well implement a real wheel
21:34:18 <crutcher> I can't believe that there's no standard prime library for haskell
21:34:38 <geezusfreeek> crutcher, and ruin all the fun?
21:34:39 <BMeph> > nubBy (((>1).).gcd) [2..]
21:34:41 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
21:35:03 <mauke> preflex: ? primes
21:35:03 <preflex>  factoid not found
21:35:06 <crutcher> I mean, most of these 'simple' fp prime generators have horrible horrible problems as they scale up
21:35:10 <BMeph> I like that one, for the golficity of it... ;p
21:35:19 <mauke> preflex: store primes nubBy(((>1).).gcd)[2..]
21:35:32 <mm_freak> crutcher: do you know a language (other than algebra systems), where a prime number library is in the standard library? ;)
21:35:38 <mm_freak> BMeph: sloooooow
21:35:43 <ddarius> mm_freak: J
21:35:58 <mm_freak> ddarius: never heard of that
21:36:00 <BMeph> mm_freak: Well, yeah - but it's shoooooooooooooort! ;p
21:36:17 <zachk> mm_freak a basic sieve in haskell is like 2 lines of code
21:36:22 <Saizan> J is supposed to be general purpouse?
21:36:36 <crutcher> zachk: a crappy sieve in haskell is 2 lines of code
21:36:47 <zachk> basic crappy :D
21:37:41 <BMeph> crutcher: What are you talking about? That crappy prime sieve above is one line, and under 25 chars! ;p
21:37:55 <mm_freak> zachk: a non-basic fast sieve is like 4 lines =)
21:38:02 <crutcher> mm_freak: well, it gets written frequently, and badly, and its a small amount of code.
21:38:24 <byorgey_> Saizan: depends what you mean by 'general purpose'...
21:38:33 <mm_freak> crutcher: go ahead, write it and propose adding it to the base library =)
21:39:25 <mm_freak> someone here is written a prime number library together with prime sieves, tests and more
21:39:30 <mm_freak> but he never cabalized it
21:39:34 <crutcher> mm_freak: I'm pretty sure I'm _not_ the one to write it.
21:39:36 <ddarius> http://www.jsoftware.com/help/dictionary/dpco.htm
21:39:42 <crutcher> http://www.cs.hmc.edu/~oneill/code/haskell-primes.zip
21:40:01 <crutcher> that collection is sure to make your head hurt
21:40:02 <crutcher> :)
21:41:01 <ddarius> Another good one: http://www.jsoftware.com/help/dictionary/dqco.htm
21:41:03 <crutcher> but in general, haskell has a much closer relationship to mathematics than most languages, and I can only imagine that a solid collection of number theory libs would be helpful.
21:41:17 <bos> hmm, ghci doesn't do type defaulting when overloaded strings are in use.
21:41:25 <bos> at least, it doesn't do it on strings.
21:41:27 <bos> shame, that.
21:41:34 <bos> makes for yucky type errors.
21:42:35 <rwbarton> ddarius: Wow.  "Rather than give things names, we'll just make a list of different things we might want and assign them small positive or negative numbers"
21:43:19 <ddarius> rwbarton: Are you looking at the primitives... or the circle functions... or something else.
21:43:21 <ddarius> ?
21:43:21 <mm_freak> crutcher: it may sound paradoxical, but haskell shows its strength most, when it comes to safe concurrent code, for example in network applications
21:43:34 <rwbarton> ddarius: The top right of that link you posted
21:43:52 <ddarius> rwbarton: You ain't seen nothing yet.
21:44:05 <crutcher> mm_freak: I'm really excited by the FRP developments, and looking forward to some bastard mix of FRP and erlang style distribution
21:44:19 <crutcher> as soon as someone works out the semantics :)
21:44:29 <geezusfreeek> crutcher, we're trying!
21:44:43 <crutcher> yeah, I know :) That's why I care
21:46:39 <mm_freak> =)
21:46:51 <mm_freak> btw, is there an FRP package for erlang?
21:47:32 <ddarius> rwbarton: http://www.jsoftware.com/help/dictionary/d310n.htm http://www.jsoftware.com/help/dictionary/dodot.htm
21:47:54 <crutcher> mm_freak: would that make much sense? I mean, without infinite lazy lists and the monad restrictions?
21:48:27 <ddarius> rwbarton: http://www.jsoftware.com/help/dictionary/dx001.htm
21:49:38 <mm_freak> crutcher: you don't strictly need them to do it
21:49:58 <mm_freak> and i don't know erlang's typesystem
21:50:28 <sclv> there is no typesystem
21:50:47 <sclv> or not much of one.
21:51:02 <geezusfreeek> there is a difference between atoms and other literals
21:51:31 <rwbarton> ddarius: It would be easier to write a Haskell program by specifying a list of numeric ASCII codes.
21:51:38 <geezusfreeek> but you can't define new types, just compose things into records and pattern match on them generically. there is either a match or there isn't
21:52:00 <geezusfreeek> i personally think that approach works wonderfully for erlang
21:52:11 <ddarius> rwbarton: J is actually rather fun to program in, just so long as you play to it's strengths.
21:52:16 <geezusfreeek> since the idea is you can patch running systems and stuff
21:52:46 <mm_freak> indeed, but i'm sure you can somehow do that with a sophisticated type system as well
21:53:16 <geezusfreeek> would require synchronous analysis across however many nodes there are in the system
21:53:21 <geezusfreeek> at runtime
21:53:41 <rwbarton> ddarius: Is there some fundamental language reason why the file operations, say, can't have names like 'read', 'write', ...?
21:54:07 <ddarius> rwbarton: No.
21:54:18 <mm_freak> > let read = readFile in 0
21:54:20 <lambdabot>   0
21:54:22 <Zao> rwbarton: Apart from read already being take, and them saying little?
21:54:27 <zachk> readfile and writefile are tight but descriptive enough to not need comments
21:54:35 <ddarius> It's possible that there is a benefit of having the !: verb, but I don't see why the standard library doesn't define aliases which you can readily do.
21:55:00 <rwbarton> ddarius: Oh also, does the interpreter really produce like output shown in http://www.jsoftware.com/help/dictionary/dx005.htm?
21:55:09 <ddarius> Yes.
21:55:15 <alatter> folks: is there a standard function for getting the system byte-ordering?  If not, would anyone else be interested in me putting one up on hackage?
21:55:21 <ddarius> Actually, it uses nicer ascii lines.
21:55:51 <dmwit> ?hoogle endian
21:55:51 <lambdabot> No results found
21:56:01 <dmwit> I think there is one.
21:56:08 <dmwit> I just can't remember the name right now.
21:56:33 <johnnowak> rwbarton: the J interpreter will even use the boxes to show you how things parse
21:57:01 <pumpkin> you could do a Data.Binary.Get and compare getHost with getBE/LE
21:57:04 <pumpkin> but that's kinda ugly
21:57:26 <dmwit> Well, I'll be darned.  There isn't one, according to this thread: http://groups.google.com/group/fa.haskell/browse_thread/thread/8267cd733b578cca
21:57:35 <alatter> pumpkin:  my plan is to poke a word32 and peekArray a list of Word8s
21:57:49 <mauke> I can do it in pure Haskell
21:57:56 <mauke> :t PortNum
21:57:57 <lambdabot> Not in scope: data constructor `PortNum'
21:58:00 <mauke> :-/
21:58:09 <johnnowak> rwbarton: example: http://johnnowak.com/heap/j
21:58:15 <alatter> mauke: hah.
21:58:33 <pumpkin> alatter: that should work too, but you could just do getWord16host on "ab" or something
21:58:55 <mauke> import Network.Socket;  isBigEndian = PortNum 1 == 1
21:58:57 <rwbarton> johnnowak: ah, I see.
21:59:40 <ray> i can do it in a castle, i can do it in pure haskell
22:01:11 <alatter> whichever way.  System.ByteOrder it is.
22:02:57 <geezusfreeek> :t Network.Socket.PortNum
22:02:58 <lambdabot> Word16 -> Network.Socket.PortNumber
22:14:43 <dmwit> Sooooo many logos.
22:15:03 <Cale> Oh, where do we vote?
22:15:30 <dmwit> I'm not sure the voting process has been finalized. =/
22:18:05 <pumpkin> erikc: no mach-o!! but I like the other libs you're releasing!
22:18:51 <erikc> mach-o is almost done :), just have symbol table and relocation parsing left
22:19:03 <pumpkin> yay!
22:19:37 <alatter> well, that was fun: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/byteorder-1.0.0
22:19:47 <pumpkin> that was fast :P
22:20:14 <pumpkin> omg!
22:20:14 <pumpkin> byteOrder = unsafePerformIO $ byteOrderIO
22:20:19 <pumpkin> what if you byte order changes on the fly!!
22:20:27 <pumpkin> ;)
22:21:53 <Saizan> what if your process is relocated on a different machine?
22:21:56 <pumpkin> some ARM processors support big and little endian!
22:22:18 <alatter> pumpkin:  well, that would be a bummer
22:22:26 <shapr> :-)
22:22:59 <erikc> pumpkin: same with powerpc/cell (although im not aware of a powerpc system that uses little endian)
22:23:30 * shapr still hasn't gotten his cell system running...
22:24:00 <erikc> doh, did you wind up getting your own chassis? or find hosting?
22:24:37 <shapr> Yeah, both...
22:24:43 <shapr> I just can't quite find power cords...
22:25:46 <int80_h> lemmih: you awake?
22:26:05 <int80_h> how do I get lambdabot to leave a message for someone?
22:26:44 <BMeph> @help tell
22:26:44 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
22:27:39 <int80_h> tell lemmih did I e-mail you the right file?
22:27:51 <rwbarton> Needs more @
22:28:30 <int80_h> I didn't do it right?
22:28:35 <rwbarton> @tell int80_h use @tell
22:28:35 <lambdabot> Consider it noted.
22:29:04 <sclv> byte order should be determined at compile time, not runtime.
22:29:25 <int80_h> @tell lemmih did I e-mail you the right file?
22:29:26 <lambdabot> Consider it noted.
22:29:38 <alatter> sclv: hmm?
22:29:42 <alatter> sclv: why?
22:30:04 <sclv> just seems appropriate. it certainly can be.
22:30:27 <sclv> the other system properties calls, as i recall, are mainly implemented that way, where possible.
22:31:08 <int80_h> I read somewhere that haskell isn't good for embedded applications. Is this due to something inherent in the language, or due to the development of ghc not going in that direction yet.
22:31:08 <lambdabot> int80_h: You have 1 new message. '/msg lambdabot @messages' to read it.
22:31:47 <int80_h> eee
22:31:50 <rwbarton> int80_h: interesting that your @tell didn't trigger the delivery of my @tell :)
22:31:50 <int80_h> hmmm
22:32:07 <pumpkin> int80_h: I doubt GC works well when your memory is counted in kilobytes or bytes
22:32:18 <alatter> sclv:  G3s and G4s can set endianness on a per-process basis, I think.  Probably other processors can as well.
22:32:28 <int80_h> I've seem ARM machines with 512mb ram
22:32:32 <sclv> well, i stand corrected then.
22:32:40 <pumpkin> int80_h: yeah, but that's not what I'd call "embedded"
22:32:46 <pumpkin> I guess I'd be wrong :)
22:32:48 <pumpkin> but still
22:33:52 <sclv> although i suspect that flipping the endianness of a compiled haskell binary wouldn't go down very well anyway...
22:34:46 <rwbarton> if flipping endianness also flips the endianness of a long encoded in an opcode, then it won't be detected :)
22:35:15 <rwbarton> In general it's hard to imagine an executable being able to cope with the endianness not being what it expects
22:36:07 * sclv imagines some sort of clever hack to defeat trusted code verification that involves switching endianness.
22:36:53 <Tordek> I'm trying to learn haskell, but I keep getting stuck on some things that'd be easy in other languages...
22:37:16 <sclv> with one endianness this binary is a calculator... with the other, it gives you root.
22:37:17 <ddarius> sclv: All you need is a candle.
22:37:38 <sclv> ddarius: ?
22:37:41 <Tordek> I'm trying to make a simple genetic algorithm: finding an array whose sum equals 200
22:38:15 <ddarius> http://www.cs.princeton.edu/~appel/papers/memerr.pdf
22:38:22 <rwbarton> @check \xs -> sum xs /= 200
22:38:23 <lambdabot>   "OK, passed 500 tests."
22:38:28 <Tordek> the fitness function, and mating are easy... but I don't get how i'd do mutation, since that's not a function (it's not the same value for a certain input)
22:39:05 <rwbarton> Because it's random?
22:39:17 <Tordek> (or, even, the starting step: generating a random initial pop)
22:39:23 <Tordek> rwbarton: yup
22:43:16 <rwbarton> You can make it into a function by threading a random number generator through your program.
22:44:41 <geezusfreeek> Tordek, check out the MonadRandom package
22:44:47 <rwbarton> Using a monad makes this particularly easy.
22:44:59 <rwbarton> It's just that the monad you need is essentially the one you're always in in an imperative language.
22:45:36 <ddarius> rwbarton: It's -way- more restricted than the conceptual one underlying imperative languages.
22:45:52 <rwbarton> Well, I'm thinking of State s and monads like it
22:46:01 <geezusfreeek> State is nothing like an imperative language
22:46:13 <rwbarton> There are many imperative languages
22:46:33 <rwbarton> Also,
22:46:37 <rwbarton> , src ''IO
22:46:46 <lunabot>  newtype IO a = IO ((State# RealWorld) ->
22:46:46 <lunabot>                     (#,#) (State# RealWorld) a)
22:46:56 <ddarius> rwbarton: And none have a single piece of mutable state and no IO or control operators etc.
22:47:06 <ddarius> Brainfuck perhaps comes closest.
22:47:29 <ddarius> rwbarton: Also that IO implementation is pretty much meaningless.
22:47:38 <ddarius> It's mostly a hack.
22:47:55 <geezusfreeek> yeah that abstraction dies on forkIO, for example
22:48:04 <mauke> @src forkIO
22:48:04 <lambdabot> forkIO action = IO $ \ s -> case (fork# action_plus s) of (# s1, id #) -> (# s1, ThreadId id #)
22:48:04 <lambdabot>     where action_plus = catchException action childHandler
22:50:11 <sclv> ddarius: that paper is awesome. thanks.
22:51:39 <geezusfreeek> anyway the point is that a state monad over a seed is not going to be breaking purity in any way
22:55:24 <ddarius> sclv: Similar things include breaking electronic locks and such by analyzing the power usage.
22:56:12 <sclv> I've seen some of that before. It's the taking advantage of and inducing randomized faults element that's particularly cool here.
22:58:14 <ddarius> I imagine an attack like Appel describes could be used, with some patience, on some unwary Trusted Computing-type systems.
23:06:52 <blackdog> hey, did any of those hash functions on ByteStrings in RWH get into Hackage?
23:10:13 <gnuvince> Quick question about QuickCheck: in a presentation by SPJ, he seemed to be using a slightly different version than the one shipped with GHC 6.8.  I recall that it had statistics.  Is that in QuickCheck on 6.10?
23:11:36 <blackdog> aw, jeez. why on earth would lookup in HashTable be in the IO monad?
23:11:45 <blackdog> that just makes no sense
23:11:54 <dmwit> Ain't it great?
23:12:08 <blackdog> (and before anyone jumps on me: yes, i know it's not idiomatic haskell, i'm trying to benchmark a bunch of Map implementations...)
23:12:33 <blackdog> dmwit: i can cope with building it being stateful, although ST would make more sense. but lookup?
23:12:38 <ddarius> Why -wouldn't- lookup be in the IO monad?
23:13:03 <blackdog> i suppose i'm conceptualising it as freezing the array
23:13:09 <blackdog> so at that point it could be pure
23:13:19 <blackdog> but of course if it's a mutable array, it has to be in IO, i take your point
23:19:11 <sbahra> Why "IO" though?
23:19:35 <sbahra> Bikeshed, nm. :-p
23:19:40 <dmwit> Seriously, people, Hashtable hasn't had any love in like ten years...
23:20:10 <ddarius> sbahra: There's no good reason it is IO instead of ST.  It does indeed probably mostly have to do with history.
23:20:48 <eyeris> I'm trying to install the Vty package via cabal-install so that I can build Yi. I'm getting a strange error though: http://hpaste.org/13598
23:22:01 <mauke> Error parsing config file /root/.cabal/config
23:22:23 <blackdog> dmwit: yeah. what i really want is something that has a two-phase build - i can guarantee that i won't add anything new to it after that phase, and i'm hoping that i can then use it in a pure and fast way.
23:22:23 <mauke> but the problem seems to be that vty has a broken .cabal file
23:22:26 <Elly> wow, that quote is unnecessarily censored
23:22:39 <eyeris> That is the default config file
23:22:41 <blackdog> dmwit: thinking of wrapping CMPH or something
23:22:59 <dmwit> blackdog: Kind of like freezeArray for MArrays, I guess, yeah.
23:23:07 <eyeris> mauke so I am not doing something incorrectly?
23:23:15 <blackdog> dmwit: exactly
23:23:35 <mauke> eyeris: I don't think so
23:35:53 <blackdog> wow. HashTable is really, really slow :)
23:37:09 <ddarius> That's what everyone says.
23:37:34 <ddarius> It would probably be trivial to make a much faster one as well as one that let you move between immutable and mutable interfaces.
23:39:36 <ozy`> aauuughhh
23:40:46 <blackdog> ddarius: yeah. well, at least i did due diligence in showing that the existing one was inadequate :)
23:41:02 <blackdog> (not that that was probably all that unclear anyway)
23:42:14 <Nafai> Is there a utility out there that will convert something in do notation to something that uses >> and >>=?  I'm trying to work through a more complex example and am not sure if I'm doing it right
23:43:02 <jonaskoelker> how does haskell solve the problem of exp -> exp - exp | -exp | exp exp being ambiguous?  I note that "(+) 1 - 2" parses as "(+) (1 -) 2".  Is it tokenization magic?
23:43:11 <sclv> ?redo x >>= \y -> return (y + 1)
23:43:11 <lambdabot> do { y <- x; return (y + 1)}
23:43:24 <sclv> ?undo do { y <- x; return (y + 1)}
23:43:24 <lambdabot> x >>= \ y -> return (y + 1)
23:43:33 <jonaskoelker> @where redo
23:43:34 <lambdabot> I know nothing about redo.
23:43:38 <jonaskoelker> @where ?undo
23:43:38 <lambdabot> I know nothing about ?undo.
23:43:42 <mm_freak> > (+1) 1 - 2  -- i'm expecting 0
23:43:44 <lambdabot>   0
23:43:58 <mm_freak> (+1) 1 - 2 = ((+1) 1) - 2
23:43:58 <sclv> dunno if they're available in a handy form outside lambdabot -- but you can always test it in privmsg.
23:44:05 <jonaskoelker> mm_freak: that's not what I wrote
23:44:07 <Nafai> sclv: Thanks
23:44:14 <mm_freak> uhm
23:44:15 <mm_freak> sorry
23:44:24 <sjanssen> Nafai: IIRC, there is also a flag to make GHC desugar code
23:44:51 <Nafai> -E, perhaps?
23:44:57 <ddarius> (+) 1 - 2 does -not- parse ase (+) (1 -) 2.  It parses as ((+) 1) - 2
23:45:01 <mm_freak> jonaskoelker: as far as i see, you're trying to subtract 2 from a function
23:45:17 <Nafai> Nope, not that
23:45:17 <jonaskoelker> *oh*
23:45:26 <sjanssen> Nafai: -ddump-ds
23:46:07 <Nafai> Wow :)
23:48:26 <Nafai> Ah
23:48:30 <Nafai>  ?undo helped
23:49:11 <ddarius> @undo do (x:xs) <- xs; return x
23:49:11 <lambdabot> xs >>= \ a -> case a of { (x : xs) -> return x; _ -> fail ""}
23:49:31 <ddarius> @undo [x | (x:xs) <- xs]
23:49:31 <lambdabot> concatMap (\ a -> case a of { (x : xs) -> [x]; _ -> []}) xs
23:49:50 <Nafai> I admit, when I saw the example on page 175 of RWH, when I saw the two pos <- ... lines, I said, "Can you do that?!"
23:50:08 <Nafai> It took desugaring it to make me see how that worked
23:51:20 <Nafai> I like it when things click :)
23:54:49 <sclv> haha wow eclipse is a monster. it's installed ~200 identical license.html files in my system.
23:55:06 <mm_freak> many OpenGL libraries use GLUT instead of, say, SDL
23:55:11 <mm_freak> isn't GLUT quite limiting?
