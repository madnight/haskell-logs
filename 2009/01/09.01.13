00:00:43 <BMeph> vixey: I guess type safety gives you the warning, but purity makes it sdo you know where to look. And that your looking isn't a waste of time. :)
00:00:53 <BMeph> *so
00:00:55 <ddarius> BMeph: Side effects don't give you core dumps.
00:01:21 * ddarius was too slow.
00:01:29 <BMeph> ddarius: Side effects don't give YOU core dumps. They give me heartburn. ;p
00:04:54 <rbe> thx cale
00:05:12 <rbe> does anybobdy know "jaskell"?
00:05:56 <vixey> jaskell not heard of it
00:06:10 <rbe> jaskell.codehaus.org ... it's a haskell for the JVM
00:06:26 <rbe> but the syntax differs 'slightly'...
00:06:27 <BMeph> I thought that was CAL? ;p
00:06:31 <vixey> it's not actually haskell though is it
00:06:44 <Olathe> It's Haskell in Spanish.
00:06:46 <vixey> "Jaskell is designed not to be a better language" o_o
00:06:48 <vixey> llol
00:07:14 <vixey> Now assume we want to try "javax.swing.JOptionPane.showInputDialog()", we can type in:
00:07:14 <vixey> > javax.swing.JOptionPane.showInputDialog["your age?"]
00:07:14 <vixey> >
00:07:15 <lambdabot>   Not in scope: `javax'Not in scope: `swing'    Failed to load interface for ...
00:08:15 <int80_h> I'm using ghci to run "runInGhci", the start up script for happs tutorial. I need to pass three parameters to a Main.hs. Any clues?
00:09:34 <rbe> i am looking for functional languages that are combineable with java... like erlang/jinterface or clojure... but for haskell there's 'only' that ???-looking jaskell
00:10:16 <vixey> lol
00:10:26 <vixey> rbe, for what purpose?
00:10:54 <int80_h> to sneak haskell into work perhaps?
00:10:55 <vixey> @remember rbe (on java interoperability) there's 'only' that ???-looking jaskell
00:10:55 <lambdabot> Done.
00:11:06 <rbe> i have a huge java-background (being a trainer for sun e.g.) and i like the platform... and i want to use the benefits of FP
00:11:09 <rbe> yes, int80
00:11:28 <int80_h> hahaha...I'm a clever monkey
00:11:29 <rbe> i like clojure (clojure.org) but i like type safety too ;)
00:11:48 <vixey> I think Scala can use java libs... I don't know of any haskell that has java interop. though.....
00:11:57 <rbe> after years of "imperative live" i am scared of side-effects and so on
00:12:10 <vixey> rbe, but you still want to use libraries design in that fashion.
00:12:13 <rbe> also looked at scala, but not so deep
00:12:24 <vixey> Scala has subkinding
00:12:31 <int80_h> well gents, I'll see you later. must sleep
00:12:40 <rbe> good night int
00:12:41 <vixey> it's like subclassing except at kind level.. a
00:15:10 <rbe> until now i didn't look too much at groovy, scala because of their syntax ;)
00:15:30 <rbe> i really like erlang's haskell's ...
00:15:45 <vixey> you _like_ erlangs syntax??
00:16:10 * Saizan is shocked too
00:16:20 <rbe> yeah ok erlang is a bit "scary" when adding too many , ; and so on....
00:16:45 <vixey> how come I did cabal install haskell-src-meta and it worked, but this thing still says:  Could not find module `Language.Haskell.Meta':
00:16:59 <vixey> (this thing being: ghc -O2 -fglasgow-exts --make Main.hs)
00:17:16 <vixey> erlang is like Prolog without user defined operators :/
00:17:35 <Saizan> is it the same ghc?
00:17:56 <vixey> probably not but I don't even know what that means
00:18:20 <rbe> but for my work distributed and parallel computing is needed.... and thats "relatively" easy in erlang
00:18:43 <vixey> so I've got two GHC versions and it happens that cabal is pointed at the wrong one
00:18:47 <rbe> is there any erlang-like framework for haskell?
00:19:20 <vegai> Concurrent.Channel :)
00:19:28 <Saizan> vixey: you can tell it which one to use with the --with-compiler flag
00:19:30 <sbahra> rbe, http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html
00:19:33 <vegai> Control.Concurrent.Chan, that is
00:19:49 <vegai> rbe: also, CHP
00:19:56 <vegai> if you want the whole shebang
00:19:56 <Saizan> vixey: like cabal install foo --with-compiler=/usr/local/bin/ghc-6.10.1
00:20:51 <vixey> that seems to do something.......
00:20:56 <vixey> but I get this really weird message:
00:21:02 <vixey>     Could not find module `Data.Generics':
00:21:02 <vixey>       it was found in multiple packages: base-3.0.3.0 syb
00:21:15 <vixey> it can't seem to decide if it found Data.Generics in 0 or 2 places..
00:21:15 <vixey> .
00:21:45 <Saizan> yeah, the .cabal file is a bit too generic
00:22:07 <rbe> thanks for all... i have to move my location... maybe come back later
00:22:33 <rbe> bye
00:22:39 <aircastle> by 'find' it probalby meant 'use' and since the last line is indented more it must be the more specific error message that lead to that one, where in most cases 'find' would have made more sense
00:22:54 <vixey> I give up, Cabal doesn't work or I don't work... I'll never know which
00:23:16 <vegai> vixey: is the thing you're trying to build cabalized or just that Main.hs?
00:23:38 <vixey> I was trying to install some library using cabal I have no idea why I thought using cabal would be a good idea for it
00:23:57 <vegai> you might try runghc Setup.hs configure --user
00:24:06 <Saizan> vixey: it's just that mmorrow have written a non-accurate .cabal file
00:27:27 <Saizan> vixey: i've edited it, this installs fine for me with ghc-6.10.1 http://code.haskell.org/~Saizan/haskell-src-meta-0.0.3.1.tar.gz
00:31:24 <Saizan> @tell mmorrow i've fixed haskell-src-mete.cabal so that it works on ghc-6.10.1 http://code.haskell.org/~Saizan/haskell-src-meta.cabal
00:31:25 <lambdabot> Consider it noted.
00:32:09 <Saizan> hackage should probably have a "distro" maintainer
00:33:21 <vixey> Saizan, do you think cabal lacks a type system?
00:33:40 <vixey> so i.e. when you try to upload it could automatically say: non-accurate .cabal
00:33:47 <Saizan> well, we lack a type system for interfaces of packages
00:33:56 <vixey> thanks also, I will try it
00:34:29 <Saizan> np
00:35:53 <Saizan> many problems can be avoided if we force dependencies to have an upper bound
00:36:15 <Saizan> but in this case what was really lacking is the lower bound on base
00:41:14 <vixey> uniq !a = unsafePerformIO
00:41:15 <vixey>   (do n <- takeMVar global
00:41:15 <vixey>       putMVar global (n+1)
00:41:15 <vixey>       return n)
00:41:20 <vixey> global = unsafePerformIO (newMVar 0)
00:41:24 <vixey> weird ... :p
00:41:56 * vixey wonders.. what does this achieve..
00:42:45 <Saizan> everyone seems to need unique ids lately :)
00:43:02 <vixey> it's weird yeah
00:44:20 <vegai> that's safe, right?
00:44:27 <Workybob> not very, no
00:44:31 <Workybob> it's my code in fact
00:44:39 <Workybob> but it's not safe – it's not refferentially transparent
00:44:46 <vixey> and what did you achieve with it?
00:44:58 <Workybob> it's used inside a graph module
00:45:11 <Saizan> well, you get different ids depending on the evaluation order, but they are different indeed
00:45:23 <Workybob> I needed it to support union on graphs where two nodes containing the same thing really were different nodes
00:45:24 * vixey points out it's not _only_ used in a graph module anymore
00:45:40 <Workybob> vixey: oh? where are you using it?
00:45:46 <vixey> I am not!
00:45:55 <Workybob> oh, who is using it?
00:45:56 <vixey> it's in mmorrows voom thing
00:46:02 <vixey> http://moonpatio.com/repos/voom/
00:46:09 <vixey> I'm just looking through it now
00:46:21 * Workybob wonders what it does
00:46:35 <vixey> but that's interesting because frisby claims to need unsafeCoerce or something for a similar kind of graph thing
00:46:46 <Workybob> oh, that's interesting
00:46:49 <vixey> But I am _sure_ this is not a limitation of purity ...
00:47:00 <vixey> you could easily rewrite your code without using uniq couldn't you?
00:47:19 <vixey> actually I want to see it also.. is it somewhere online?
00:47:20 <Saizan> what's voom? a virtual machine?
00:47:44 <vixey> Saizan, yeah it looks like a LVM implementation which used haskell-src-meta to parse haskell
00:49:45 <sioraiocht> what's hte best way to go about learning Coq?
00:51:14 * vixey feels it slightly a shame taht suff like global variables and unsafePerformIO would become idioms
00:52:00 <vixey> but also it is a shame those that eschew SET! in Scheme..
00:52:59 <vixey> sioraiocht: http://www.cs.harvard.edu/~adamc/cpdt/book/html/toc.html
00:53:08 <sioraiocht> cheers, vixey
00:53:09 <mlesniak> What does a ! mean in a data definition, e.g. data Sequence = Seq !SeqData !SeqData !(Maybe QualData)
00:53:21 <mlesniak> (Quite difficult to search for this in google ;-))
00:53:29 <vixey> mlesniak, it forces the SeqData and the Maybe into WHNF
00:53:38 <mlesniak> vixey: Ah, thanks
00:53:49 <vixey> I'm not sure when it does that though
00:54:09 <vixey> I suppose any time you pattern match on the (Seq x y z) it will force the SeqData and Maybe
00:54:30 <vixey> (is that accurate?)
00:54:38 * Trafalgard is baffled
00:54:54 * Trafalgard can't get scanl, scanr, scanl1, or scanr1 to do anything other than error in ghci
00:54:58 <Trafalgard> > scanl1 (+) [0 1 2 3 4]
00:54:59 <lambdabot>       No instance for (Num (t -> t1 -> t2 -> t3 -> a))
00:55:00 <lambdabot>        arising from th...
00:55:12 <vixey> Trafalgard, first look at the types
00:55:15 <Trafalgard> scanr1 (++) ["foo" "bar" "zort"]
00:55:20 <Trafalgard> Why wouldn't that work?
00:55:20 <vixey> :t scanl
00:55:21 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
00:55:27 <Trafalgard> no
00:55:29 <Trafalgard> :t scanl1
00:55:30 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
00:55:31 <vixey> do you understand what the type means?
00:55:34 <vixey> :t scanl
00:55:36 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
00:55:38 <vixey> this one ^
00:55:43 <Trafalgard> look, I did scanl1, not scanl
00:55:55 <vixey> that doesn't matter
00:55:59 <Trafalgard> okay...
00:56:02 <vixey> just consider the type of scanl
00:56:04 <Trafalgard> but yes, I know what the types mean
00:56:18 <vixey> ok so lets take (+) :: Integer -> Integer -> Integer
00:56:25 <Saizan> > scanl1 (+) [0, 1, 2, 3, 4]
00:56:27 <lambdabot>   [0,1,3,6,10]
00:56:34 <Saizan> lists need commas
00:56:51 <vixey> Trafalgard, now scanl (+) :: Integer -> [Integer] -> [Integer]
00:56:53 <Trafalgard> ... meh
00:57:13 * Trafalgard thought only tuples needed commas
00:57:17 <Trafalgard> nevermind then!
00:57:51 * Trafalgard looks at the code I wrote yesterday... which has lists with commas in it
00:57:58 * Trafalgard must be overly tired
00:58:18 <vixey> Trafalgard, if you think about the types of things more carefully you will understand type errors
00:58:36 <Trafalgard> It's not a type error, it's an I forgot the commas error :|
00:58:45 <newsham> [0 1 2 3 4] isnt a list
00:58:45 <vixey> Trafalgard, it is a type error.
00:59:04 <vixey> Trafalgard, I know what a type error is :p
00:59:07 <vixey> I've had a lot
00:59:40 <newsham> sequence.complete.org down?
01:00:22 <vixey> clearly everyone wants to programming in Fresh-Haskell
01:00:41 <Trafalgard> I'd like error messages that tell you what you did wrong
01:00:42 * vixey is just seeing code like  lamE args e = (newGblId "f", Bind args e)
01:00:58 <Trafalgard> :P
01:01:01 <vixey> Trafalgard: ok I guess you rather arguing with me than trying to understand my advice
01:01:13 <Trafalgard> no, I'm listening
01:01:48 <vixey> FreshML seemed kind of ad-hoc though
01:01:59 <Trafalgard> If it's going to make life easier in the long run, I want to hear it :P
01:02:19 <vixey> what do people think about Fresh-Haskell?  (which doesn't exist but it should be obvious what it is if you know FreshML)
01:02:30 <Trafalgard> I don't know what freshML is
01:04:00 <Trafalgard> But the language I like best, despite the fact that I'm learning haskell and thinking that haskell might actually be better, is C#
01:05:26 <Trafalgard> other languages I know well are java and python, and I have a decent amount of experience with C++ and C except that I avoided anything to do with its templates, STL, or object-oriented stuff beyond structs
01:05:33 <Trafalgard> so basically, very much an imperative background
01:05:42 <blackh> Trafalgard: My preference order is: Haskell (favourite), Java, Python, C++, C (yecch).
01:05:48 <Workybob> vixey: sorry, got stolen by my boss
01:05:55 <newsham> if its anything like fresh-mex i say "pass"
01:05:57 <SubStack> java ahead of python? interesting
01:06:11 <blackh> SubStack: I hate dynamic typing.
01:06:29 <Workybob> I'm fine with unsafePerformIO, is fine – as long as it's used in an implementation of something pure, to add a primitive to GHC
01:06:37 <Workybob> in this case it's the "uniquely identified node" primitive
01:06:52 <Workybob> in other cases it may be the "contents of a file litteral" primitive
01:07:03 <Trafalgard> but I did learn a bit of lisp and ML, years ago, and liked some of the features in ML (things that haskell has too)
01:07:23 <blackh> SubStack & Trafalgard: Obviously there's a big gap between Haskell and the next one down. :)
01:07:27 <mmorrow> vixey: those unsafeCoerces are in there on account of the GADT type inference apparently unsable to infer the (which was clearly to me (a human) the case (and it was late..)) type, and i was at the end of my rope at that point
01:07:27 <Trafalgard> didn't particularly like lisp, functions with nonsensical names and way too many parens
01:07:28 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
01:08:16 <mmorrow> and the unsafePerformIOs to get uniqs totally sucked in that particular instance, and are slated for deletion :)
01:08:26 <newsham> that sounds like a rather shallow criticism (syntax and names of functions)
01:08:36 * Trafalgard shrugs
01:09:05 <Trafalgard> I can't give it any deeper criticism since it was for a course where I only used it for a couple weeks :P
01:09:07 <newsham> after using a language for a while syntax fades a bit into the background
01:09:11 <newsham> and you can always use other names
01:09:18 <Trafalgard> I had trouble using lisp
01:09:20 * SubStack never liked the c/c++ java sorts of languages so much
01:09:24 <Trafalgard> I didn't have nearly as much trouble using ML
01:09:31 <SubStack> too stuffy and verbose
01:09:37 <Trafalgard> I figure the reason is because the function names made sense in ML
01:09:56 <mmorrow> Saizan: ah yeah, thx on the src-meta .cabal. i've been meaning to fix that and slacking..
01:09:58 <Trafalgard> and because I didn't keep screwing up the formatting
01:10:08 <SubStack> array processing languages look neat
01:10:20 <SubStack> crazy terse
01:10:37 <Trafalgard> but I did learn lisp first and that may have primed my brain for learning future functional languages somewhat
01:10:43 <Trafalgard> so who knows.
01:10:58 <Trafalgard> I did ML right after, though
01:11:04 * mmorrow passes out
01:11:10 <vixey> mmorrow, !!!
01:11:12 <newsham> 'morrow mmorrow
01:11:21 <Japsu> jerome morrow
01:11:40 <Japsu> (there's gattaca on viasat today)
01:12:04 <newsham> gattaca's on hulu i believe
01:12:23 <vixey> what's hulu
01:12:29 <newsham> www.hulu.com
01:12:43 <vixey>  Sorry, currently our video library can only be streamed from within the United States
01:12:50 <vixey> this happens all the time now with the internet
01:13:20 <vixey> I wish US had their own internet
01:13:21 <newsham> you're not from one of the patriotic countries, are you?
01:13:35 <SubStack> o_O
01:13:51 <Saizan_> there's no way to make an empty Array ?
01:14:06 <SubStack> []?
01:14:08 <vixey> SubStack, i.e. instead of something that doesn't send messages saying "Sorry this isn't available to you" to me
01:14:12 <vixey> SubStack, makes sense?
01:14:14 <SubStack> oh array
01:15:05 <SubStack> location-based filters are really lame sauce
01:15:25 <SubStack> geographic correspondence should be much more difficult
01:15:29 <vixey> It would be nice if I could just not use any .com websites and the problem would be solved but it doesn't work like that
01:15:36 <SubStack> given a domain
01:15:38 <vixey> (or if they used .us only)
01:17:41 <newsham> > array (0,0) []
01:17:43 <lambdabot>   array (0,0) [(0,* Exception: (Array.!): undefined array element
01:17:52 <newsham> > array (0,-1) []
01:17:53 <lambdabot>   array (0,-1) []
01:18:02 <vixey> this is good though,  flatten . rewrite . resolve . compile
01:18:10 <vixey> oops missed:  pipeline =
01:18:17 <vixey> anyway that is how a compiler in haskell should look :p
01:18:19 <Saizan_> newsham: do you think that's intentional?:)
01:18:38 <vixey> and in Prolog,  pipeline --> compile, resolve, rewrite, flatten.
01:18:40 <newsham> saizan: thats empty, no?
01:18:53 <vixey> in SML probably flatten o rewrite o resolve o compile
01:19:23 <vixey> > array (0,0) [()]
01:19:24 <lambdabot>   Couldn't match expected type `(t, e)' against inferred type `()'
01:19:32 <vixey> > array (0,0) [((0,0),())]
01:19:33 <lambdabot>       No instance for (Num (t, t1))
01:19:33 <lambdabot>        arising from the literal `0' at <i...
01:19:38 <vixey> > array (0,0) [(0,())]
01:19:39 <lambdabot>   array (0,0) [(0,())]
01:19:52 <vixey> > array (0,1) [(0,())]
01:19:53 <lambdabot>   array (0,1) [(0,()),(1,* Exception: (Array.!): undefined array element
01:20:03 <vixey> :t array
01:20:04 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
01:20:05 <newsham> > listArray (0,1) [1,2]
01:20:07 <lambdabot>   array (0,1) [(0,1),(1,2)]
01:20:10 <vixey> yuck
01:20:26 <vixey> it's just a hack to get around not having the length of the list dependable -- but also not wanting to use Maybe
01:20:32 <vixey> or (Error or MonadPlus)
01:21:17 <newsham> foldl (flip (.)) id   ?
01:22:27 * vixey wonders if  voom: Prelude.undefined  is a problem or my own fault.
01:22:48 <vixey> blech. what's the point in type safety if nobody uses
01:22:48 <newsham> oh, you're complaining about the undefined values?
01:23:23 <newsham> > let x = listArray (0,1) [] in x `seq` 1
01:23:25 <lambdabot>   1
01:23:35 <newsham> > let x = listArray (0,1) [1] in x ! 0
01:23:37 <lambdabot>   1
01:23:39 <newsham> > let x = listArray (0,1) [1] in x ! 1
01:23:40 <lambdabot>   * Exception: (Array.!): undefined array element
01:23:51 <newsham> you can make it empty, you just get errors when you use the undefined els
01:24:31 <Saizan_> yeah, i wouldn't have notice if i didn't have a bug elsewhere
01:30:53 <pozic> With what versions is cabal-install compatible? I would like to get a version that compiles with 6.8.*
01:31:29 <pozic> The script on ghcmutters causes all kinds of dependency problems.
01:32:00 <pozic> In particular it requires a version of Cabal which doesn't ship with 6.8.
01:32:32 <ejt> morning, I've recently upgraded to ghc 6.10, but 'cabal install' has stopped working - it gives an error message suggesting that if I'm using 6.9 (which I'm not) then it's because I've an empty cabal package db.
01:32:33 <KoenigGunther> hi! i have to give a proof that Tempo r1 . Tempo r2 equals Tempo r2 . Tempo r1
01:32:33 <KoenigGunther> I found http://darcs.haskell.org/haskore/docs/Tutorial.pdf and they use "Pf.fromMusic" to give this proof. I am wondering where this "Pf.fromMusic" is defined
01:32:56 <Saizan_> pozic: Cabal-1.6 and cabal-install-0.6 support ghc-6.4+
01:33:20 <Saizan_> pozic: but yeah, you've to install that version of Cabal on your ghc-6.8.x
01:33:29 <dcoutts> which is not a problem
01:33:47 <ejt> can anyone confirm this is my problem, and if so how I manually add a package to the db please ?
01:34:02 <pozic> Saizan_: ok, I was under the impression that the script completely installed cabal install. Thanks
01:34:08 <Martijn> @pl \x xs -> (:) <$> x <*> xs
01:34:08 <lambdabot> (((:) <$>) .) . (<*>)
01:34:15 <vixey> ejt, I heard that but doing it didn't fix the problem for me
01:34:20 <Saizan_> ejt: yes, the same problem applies to ghc-6.10.1
01:34:28 <Martijn> @hoogle Applicative f => [f a] -> f [a]
01:34:29 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
01:34:29 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
01:34:29 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
01:34:31 <Saizan_> ejt: however, you should upgrade your cabal-install
01:35:11 <Saizan_> pozic: assuming you've the so called extralibs installed you can use the bootstrap.sh script in the cabal-install tarball
01:36:34 <pozic> Saizan_: these are packaged by Ubuntu, AFAIK.
01:36:52 <ejt> vixey, Saizan_ : thanks, I'll start by upgrading cabal install
01:37:05 <Saizan_> pozic: yeah, you just have to install them from apt
01:37:41 <Saizan_> pozic: and -dev for zlib
01:40:28 <vixey> Hutton has a paper called "What is the meaning of these constant interruptions?"
01:43:39 <ejt> y, upgrading cabal-install fixed things.  I'd forgotten it was a separate package from cabal
01:56:13 <pozic> Saizan_: I keep getting cannot find package zlib-0.5.0.0, even though ghc-pkg list shows it.
01:56:35 <hugo___> hi
01:56:56 <Martijn> Hello hugo___
01:57:33 <hugo___> hello Martijn, 'sup ?
01:57:45 <pozic> Is there a way to deinstall a binary release?
01:58:09 <Martijn> hugo___: working on the thesis =)
01:58:33 <hugo___> phd ?
01:58:39 <Martijn> masters
01:58:45 <hugo___> ah nice
01:58:52 <hugo___> whats it about ?
01:59:00 <hugo___> pozic: ? in linux ?
01:59:06 <Martijn> about parsers
01:59:19 <pozic> hugo___: one of the GHC releases, not releases by distros.
01:59:30 <pozic> hugo___: yes, on Linux.
02:01:29 <Saizan_> pozic: remove /usr/local/lib/ghc-$ver, and the relative binaries in /usr/local/bin
02:01:48 <Martijn> @hoogle Alternative f => [f a] -> f a
02:01:48 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
02:01:48 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
02:01:48 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
02:02:05 <Saizan_> pozic: assuming you installed in the defualt location
02:02:19 <Saizan_> pozic: however, do you think cabal is picking the wrong ghc?
02:05:19 <pozic> Saizan_: I already did what you suggested and I even removed 6.8 in the package manager. Now, I am reinstall 6.8 to see whether it will work.
02:06:53 <Saizan_> pozic: there's also ~/.ghc
02:08:29 <Martijn> @pl \(tok, syn) -> const tok <$> token syn
02:08:30 <lambdabot> uncurry ((. token) . (<$>) . const)
02:09:51 <vixey> @pl \toksy -> const (fst toksy) <$> token (snd toksy)
02:09:52 <lambdabot> ap ((<$>) . const . fst) (token . snd)
02:10:02 <quicksilver> Martijn: tok $> token syn
02:10:12 <quicksilver> Martijn: $> is "const ... <$> ..."
02:10:15 <vixey> :t ($>)
02:10:16 <lambdabot> Not in scope: `$>'
02:10:26 * quicksilver peers at lambdabot 
02:10:35 <quicksilver> lunabot: @type ($>)
02:10:48 <vixey> , $>
02:10:52 <vixey> , ($>)
02:10:54 <lunabot>  luna: Not in scope: `$>'
02:10:56 <lunabot>  luna: Not in scope: `$>'
02:11:26 <quicksilver> hmm
02:11:31 <quicksilver> looks like it's <$
02:11:32 <Martijn> @hoogle ($>)
02:11:32 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
02:11:32 <lambdabot> Text.ParserCombinators.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
02:11:32 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
02:11:37 <quicksilver> sorry ;)
02:11:41 <quicksilver> :t (<$)
02:11:41 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
02:11:46 <quicksilver> there we go.
02:11:51 <Martijn> Mmhm
02:12:47 <Martijn> @pl \(tok, syn) -> tok <$ token syn
02:12:47 <lambdabot> uncurry ((. token) . (<$))
02:13:04 <Martijn> Nah, I still prefer the lambda
02:13:16 <Martijn> And thanks, quicksilver
02:14:03 <Martijn> I often use @pl to see if I'm missing some obvious way of writing it point-free, but usually I discover that I like the pointful version better.
02:14:30 <quicksilver> lambdas are a very concise notation :)
02:14:34 <quicksilver> it's often hard to do better.
02:14:39 <Martijn> Yeah
02:15:00 <Martijn> Sometimes the pointfree versions are prettier but I usually catch those myself
02:15:17 <pozic> Saizan_: yes, I also deleted that one. Somehow I got it to work now when I just the bootstrap.sh script.
02:15:22 <BONUS> usually if you can't think of a pointfree version by yourself, the pointfree version is too strange
02:15:33 <pozic> Saizan_: just used*
02:15:34 <Martijn> Exactly
02:15:37 <BONUS> although i tend to use zip`ap`tail a lot
02:15:46 <BONUS> but that's kind of an idiom i guess
02:15:57 <Martijn> Sounds like a Klingon name ;-)
02:15:58 <vixey> I don't think I ever used zip`ap`tail
02:16:33 <BONUS> i used it for some euler problems where you had to examine pairs of subsequent numbers
02:16:41 <Martijn> Is there a good reason type synonyms cannot be partially applied while newtype/datas can?
02:17:11 <quicksilver> yes.
02:17:18 <quicksilver> it would lead to unrestricted type lambdas!
02:17:38 <quicksilver> type Flip f a b = f b a
02:17:41 <Martijn> Why is that bad? :-)
02:17:49 <Martijn> That's exactly what I want sometimes.
02:17:58 <quicksilver> because your type system becomes too powerful.
02:18:10 <Martijn> too powerful as in not implementable anymore?
02:18:29 <Martijn> or too powerful as in too powerful for us puny programmers? :-P
02:18:38 <BONUS> i guess if the type system is too powerful it all just kind of becomes too meta
02:20:45 <quicksilver> Martijn: haskell's type system requires types to always be in normal form, at compile time.
02:20:54 <quicksilver> unrestricted type lambdas would break various things
02:21:03 * Martijn nods.
02:21:13 <quicksilver> unification becomes undecidable
02:21:35 <Martijn> Sounds nasty
02:23:03 <Martijn> Hmm, haddock doesn't show a distinction between newtypes and datas
02:23:43 <quicksilver> not sure what you mean
02:23:48 <quicksilver> it shows "newtype" for newtypes :P
02:23:55 <quicksilver> newtype State s a = State {
02:24:01 <quicksilver> (from the haddock for control.monad.state)
02:24:15 <Martijn> Maybe I'm using an old version then. The docs I generate for a newtype show up as a data
02:24:33 <Martijn> Ah, 2.3.0
02:24:36 <quicksilver> thats most peculiar.
02:25:03 <Martijn> Where does "cabal haddock" get its haddock from?
02:25:55 <Saizan_> $PATH
02:26:02 <Martijn> Ah
02:26:12 <Martijn> So I should just update my version of haddock then.
02:26:29 <Martijn> I wonder how I installed it, since mine is in /usr/bin
02:29:44 <Martijn> Nope, 2.4.1 renders newtype SucParser s a = SucParser (S.StateT [s] [] a) as data SucParser s a
02:29:50 <Martijn> That's odd
02:29:58 <SubStack> Is it just me or are the regex libraries missing replace once?
02:31:15 <quicksilver> Martijn: is the constructor not exported?
02:32:20 <Martijn> That is correct
02:33:28 <quicksilver> Martijn: yeah, that's probably it.
02:33:40 <quicksilver> if the constructor is not exported, you can't tell the difference between newtype and data
02:33:45 <quicksilver> it's not part of the interface.
02:33:48 <Martijn> *nods*
02:34:00 <Martijn> I imagine the compiler still needs to tell the difference, right?
02:35:18 <quicksilver> not when compiling other modules, no.
02:35:25 <quicksilver> only when compiling that module itself.
02:36:30 <Martijn> Ah, true
02:59:17 <hugo___> i can do a "data T = String", but i can't do a "data T = (String, String)" why ?
02:59:47 <hugo___> why do i need the constructor ?
02:59:57 <quicksilver> because, that's how it works.
02:59:57 <vegai> data always does
02:59:57 <BONUS> all data declarations need a constructor
03:00:04 <vegai> if you want a type synonym, use "type"
03:00:08 <BONUS> when you do data T = String, it's not actually a string
03:00:10 <quicksilver> otherwise how could it tell the difference between (String,String) and T ?
03:00:23 <BONUS> the only value it can be is String
03:00:29 <BONUS> which is not much of a string, really
03:00:35 <Saizan> hugo___: data T = String means that you're defining a constructor String :: T
03:00:48 <Saizan> just like Nothing in Maybe
03:00:51 <Saizan> @src Maybe
03:00:51 <lambdabot> data Maybe a = Nothing | Just a
03:00:55 <hugo___> ok
03:01:13 <hugo___> so what if i do a data T = T Maybe String ?
03:01:39 <hugo___> i could use func :: T -> T
03:01:49 <hugo___> and it would like func :: Maybe String -> Maybe String
03:01:50 <hugo___> right ?
03:02:05 <BONUS> no, use type synonyms for that
03:02:06 <quicksilver> "like" ?
03:02:14 <quicksilver> it would be a bit "like" it, yes.
03:02:17 <quicksilver> but it woudln't be teh same.
03:02:23 <quicksilver> you'd need to wrap and unwrap the 'T's
03:02:25 <BONUS> what are you trying to accomplish
03:02:37 <quicksilver> (btw it would be data T = T (Maybe String))
03:02:53 <hugo___> i was just mingling with data types
03:03:40 <BONUS> data is data TypeConstructor = Constructor1 <type of field> <type of field> ... | Constructor2 <type of field> ...
03:03:42 <hugo___> so i should do "type T = Maybe String" for that
03:03:56 <hugo___> okey
03:03:58 <BONUS> but it's still nothing useful
03:04:04 <BONUS> wait hm
03:04:05 <BONUS> yeah
03:04:08 <BONUS> you can do that
03:04:24 <hugo___> and for tuples... what if i do a data T = T (String, String) ?
03:04:35 <hugo___> is it a constructor that takes a tuple as argument ?
03:04:38 <BONUS> yeah
03:04:38 <quicksilver> yes.
03:04:46 <hugo___> ok
03:04:47 <quicksilver> you could also do "data T = T String String"
03:04:53 <quicksilver> which is a constructor that takes two arguments
03:04:55 <hugo___> noisy parenthesis :/
03:04:59 <quicksilver> for a very similar effect.
03:05:11 <hugo___> hmm ok
03:05:51 <hugo___> so, "data T = T (String, [String])" works much like "data T = T String [String]"
03:05:53 <hugo___> right ?
03:06:19 <quicksilver> yes, very similar.
03:06:28 <hugo___> what about data T = T (Maybe String) [String] ?
03:06:39 <quicksilver> that's fine
03:06:41 <hugo___> than i can have like T Nothing [String] ?
03:06:41 <quicksilver> (what about it?)
03:06:48 <hugo___> okey
03:06:51 <quicksilver> well, T Nothing ["foo"]
03:06:54 <hugo___> yes
03:06:56 <hugo___> that
03:06:57 <hugo___> sorry
03:06:59 <hugo___> oh ok
03:07:00 <hugo___> fine
03:07:27 <hugo___> i was just wondering about hash tables, and data types :/ or whatever something like that
03:07:36 <hugo___> thanks
03:12:13 <adrian_> is there an easy way to use quickcheck to generate testdata with exactly the size I want?
03:12:30 <adrian_> :t generate
03:12:31 <lambdabot> Not in scope: `generate'
03:12:45 <quicksilver> you should be able to call gen directly
03:12:49 <quicksilver> and give it the size you want
03:14:40 <adrian_> "not in scope `gen'"
03:14:56 <adrian_> is there some internals module I have to import?
03:16:29 <quicksilver> adrian_: it's "resize" you use perhaps?
03:16:31 <quicksilver> I forget.
03:16:58 <quicksilver> or is it just the first argument to 'generate'
03:17:43 <adrian_> the first argument to generate is just the maximum size
03:17:48 <adrian_> but resize looks good
03:18:49 <adrian_> yes, it works
03:18:51 <adrian_> thank you
03:35:47 <chrisdone> I've noticed that emacs seems to make me keep my finger on control keys for a long time
03:36:22 <chrisdone> e.g. C-x-f, C-c C-l, start to feel the burn
03:36:29 <adrian_> be careful or you get an emacs-pinky
03:37:07 <chrisdone> maybe I'm just not typing fast enough.
03:37:09 <asgaroth> chrisdone: you could remap caps lock to control
03:37:18 <asgaroth> might be less straining
03:37:45 <chrisdone> well, for those above examples I use the control on the right hand side of   my keyboard!
03:38:08 <chrisdone> oh, well, I use both for C-c C-l
03:38:36 <chrisdone> asgaroth: does that actually work?
03:38:43 <asgaroth> chrisdone: yes
03:38:51 <asgaroth> you can rebind it with xmodmap
03:39:19 <chrisdone> I mean does it keep your finger pressing on the control key for a shorter amount of time?
03:39:48 <asgaroth> No, I meant that it lets you use the caps lock key instead of control which is a bit more reachable
03:40:10 <chrisdone> okay
03:42:23 <chrisdone> asgaroth: hey, I think I spoke to you once in ##c about doing a sign language course. last year I did a ten week BSL course, which was fun! of course, I don't actually have any deafie friends (other than online) so it was pretty hard to practise ;-)
03:43:04 <asgaroth> chrisdone: I think you're confusing me with someone unless I have major memory failures
03:43:47 <chrisdone> asgaroth: well, it was about two years ago and I had a different nickname. nevermind :P
03:44:05 * chrisdone disappears back into obscurity
04:25:48 <PeakerWork> I'm trying to formulate a useful example of using "mfix" on the list MonadFix instance
04:25:51 <PeakerWork> any idea of one?
04:26:50 <vegai> We should have an accomplishment system
04:27:03 <vegai> Accomplishment unlocked: First use of mapAccumL in real code
04:28:50 <jeltsch> Hello, is it possible to include non-ASCII characters in the Copyright section of .cabal files? If yes, how?
04:31:42 <adrian_> vegai: that's a great idea
04:31:48 <dcoutts> jeltsch: yes, it's UTF8
04:32:14 <adrian_> vegai: we should add that to HLint
04:32:21 <dcoutts> jeltsch: so make sure you save the .cabal file in utf-8 encoding, not latin-1 or something
04:33:17 <jeltsch> dcoutts: I’m using UTF-8 anyway but remembered that some time ago only ASCII was interpreted correctly by Hackage.  Does Hackage render the UTF-8 correctly meanwhile?
04:35:53 <Saizan> jeltsch: it's been fixed, yeah
04:36:03 <Martijn> Anyone ever seen this before?
04:36:03 <Martijn> SimpleExpr.hs:30:0:
04:36:03 <Martijn>     Couldn't match expected type `Input p ~ ExprToken'
04:36:03 <Martijn>            against inferred type `Input p ~ ExprToken'
04:36:10 <dcoutts> jeltsch: yes
04:37:40 <Martijn> That error messages makes no sense to me. :-(
04:38:42 <nanothief_> Martijn: whats the code?
04:40:14 <Martijn> type ExprParser = forall p. (Parser p, Input p ~ E.ExprToken) => TreeParser p Expr Expr
04:40:24 <Martijn> I think it has to do with the quantified p
04:41:43 <Martijn> Given that type synonym it's now impossible to write x :: ExprParser; x = y; y :: ExprParser; y = x
04:46:33 <Martijn> Here's a minimal example:
04:46:34 <Martijn> class C a where
04:46:34 <Martijn>   type T a :: *
04:46:34 <Martijn> f1 :: T a ~ () => a
04:46:34 <Martijn> f1 = f2
04:46:34 <Martijn> f2 :: T a ~ () => a
04:46:36 <Martijn> f2 = f1
04:47:06 <Martijn> It makes the compiler go:
04:47:07 <Martijn>     Couldn't match expected type `T a ~ ()'
04:47:07 <Martijn>            against inferred type `T a1 ~ ()'
04:47:07 <Martijn>     When matching the contexts of the signatures for
04:47:07 <Martijn>       f1 :: forall a. (T a ~ ()) => a
04:47:07 <Martijn>       f2 :: forall a. (T a ~ ()) => a
04:47:09 <Martijn>     The signature contexts in a mutually recursive group should all be identical
04:47:11 <Martijn>     When generalising the type(s) for f1, f2
04:47:38 * chessguy_work is tempted to @remember byorgey Monads are Like Burritos
04:50:18 <chessguy_work> byorgey_, ^^
04:52:03 <Saizan> Martijn: try RelaxedPolyRec
04:54:06 <BONUS> just reading http://haskell.org/haskellwiki/Zipper , pretty interesting. although it seems like a location in this manner has a lot of duplicate information
04:55:03 <BONUS> wouldn't it be better to define a location as type Loc a = (Tree a, [Step]) where step is LeftStep | RightStep, going from the top
04:55:19 <Saizan> that would defeat the point
04:55:24 <opqdonut> yep
04:55:27 <BONUS> how so
04:55:27 <Martijn> Saizan: thanks, that works. :-) It's funny, I was just reading http://haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html
04:55:39 <Saizan> which is fast access to said location
04:55:43 <opqdonut> BONUS: accessing the "pointed" element would be O(n)
04:55:44 <Saizan> and O(1) update
04:55:48 <opqdonut> not O(1)
04:55:51 <opqdonut> update too, yes
04:55:53 <BONUS> aaaah i see
04:56:08 <BONUS> yeah you'd have to traverse all the way to the element
04:56:20 <BONUS> if you do (Tree a, Cxt a), the element is in the first component
04:56:20 <BONUS> i get it
04:56:25 <BONUS> nice
04:56:26 <Saizan> Martijn: heh :)
04:56:40 <BONUS> but it would still be correct, right?
04:56:42 <BONUS> just not as efficient
04:56:57 <opqdonut> yeah, sure
04:57:20 <BONUS> what if we had data Tree a = Leaf | Node (Tree a) a (Tree a)
04:57:25 <Martijn> Saizan: still not sure what is wrong with my original example though.
04:57:35 <BONUS> so that a value can go anywhere, not just in the leaves
04:57:58 <BONUS> would the context for that still be Cxt a = Top | L (Cxt a) (Tree a) | R (Tree a) (Cxt a)
04:58:17 <Saizan> Martijn: yeah, it may be a bug in the context checker
04:58:39 <opqdonut> BONUS: no
04:58:48 <BONUS> yeah cause with that i have trouble going upwards
04:58:49 <opqdonut>  L (Cxt a) a (Tree a) and so on
04:59:06 <BONUS> a is the value at the parent element, right?
04:59:42 <BONUS> (the second field)
05:05:09 <BONUS> wow, zippers are cool
05:06:18 <adrian_> HLint won't parse my sourcecode although ghci has no complaints
05:06:29 <adrian_> does anyone know why that can be?
05:07:56 <Saizan_> HLint uses haskell-src-exts for parsing
05:08:20 <Saizan_> o you might be using a syntactic extension that's not supported or there may be a bug
05:09:18 <Saizan_> also some syntactic extesions supported by haskell-src-exts are not backwards compatible with haskell98
05:09:44 <adrian_> ah I see
05:09:51 <adrian_> it doesn't like bang patterns
05:15:24 <chessguy_work> @seen wchogg
05:15:24 <lambdabot> Last time I saw wchogg was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #ghc, #
05:15:25 <lambdabot> haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #
05:15:25 <lambdabot> haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosxdev, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 13d 16h 22m 8s ago, and .
06:07:45 <cads> good morning friends
06:12:07 <BONUS> mornin
06:12:09 * ksf is unsure whether or not he should compile with -XScopedTypeVariables just to enable
06:12:15 <ksf> main :: IO ()
06:12:15 <ksf>     = putStrLn "foo"
06:12:57 <Botje> ksf: no, the type declaration is different from the definition. you need to do "main = putStrLn foo" as well
06:13:01 <dcoutts_> ksf: the answer is undoubtedly now :-)
06:13:07 <dcoutts_> now/no
06:13:09 <dcoutts_> oops
06:13:19 <Botje> doh
06:13:27 <Botje> once again i'm bitten by mis-reading
06:13:28 <Botje> silly me :p
06:13:46 <dmead> :t zipwith
06:13:47 <lambdabot> Not in scope: `zipwith'
06:13:49 <ddarius> What is so bad about: main :: IO (); main = putStrLn "foo" ?
06:13:54 <dmead> @hoogle zipwith
06:13:54 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
06:13:54 <lambdabot> Data.ByteString zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
06:13:54 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
06:14:07 <Martijn> ddarius: nothing?
06:14:13 <ksf> worksOnlyWithShortFunctionNames
06:14:18 <dcoutts_> ksf: Botje is right though, don't try to turn it into a different language where the type and definition are mixed together, that's not the haskell style, don't try to subvert it :-)
06:14:36 <Botje> ksf: let your editor do the typing for you
06:14:42 <Botje> hold down ctrl-e for a while in vim
06:14:49 <BONUS> is this an essentially correct zipper for a list: http://hpaste.org/13887
06:14:59 <Botje> or "yypf D"
06:15:38 <dmead> ?src zipWith
06:15:38 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
06:15:38 <lambdabot> zipWith _ _      _      = []
06:15:41 <Martijn> BONUS: it's not clear what the current focus is in your implementation
06:16:16 <BONUS> just applying a zipper to a list, kind of like the zippers here http://haskell.org/haskellwiki/Zipper
06:16:41 <BONUS> ListLoc a = ([a], [a]), the first component is the list at the position, the second one is the context
06:16:46 <ksf> why would I want to scroll down?
06:16:59 <Saizan_> BONUS: i usually have it swapped, so that you've (prefix,suffix)
06:17:20 <BONUS> ah
06:18:00 <BONUS> also i've noticed that the modify function to modify a location with a function is basically "flip first" for all zippers where the location is (current element, context)
06:18:10 <BONUS> guess that's kind of obvious though hehe
06:18:22 <pejo> dcoutts, drifted away from my monitor yesterday; did you intend to quantify the cost of higher order functions vs specialised first order ones?
06:18:37 <dcoutts_> pejo: no :-)
06:18:53 <pejo> dcoutts, bummer. :-)
06:19:05 <dcoutts_> pejo: but I'd be interested to know the answer if someone else tested it :-)
06:19:49 <pejo> dcoutts, ghc specifically, or would other compilers/languages be of interest too?
06:19:57 <dcoutts_> pejo: ghc specifically
06:22:13 <ksf> anyway, I've got no idea how to specify parameters with that style.
06:23:33 <ksf> OTOH, the reason I even thought of it was
06:23:37 <ksf> foo :: Int -> Int
06:23:37 <ksf>     = foo
06:23:37 <ksf>     . foo
06:25:04 <Saizan_> you use lambdas for paramters :)
06:25:56 <ksf> If I'm ever going to be lynched in #haskell, it'll be for the schemeification of Haskell.
06:26:35 <BONUS> @pl \((x:xs), c) -> (xs, x:c)
06:26:35 <lambdabot> uncurry (ap (flip ((.) . (,)) . (:) . head) tail)
06:26:38 <BONUS> gah!
06:26:57 <ksf> like, a sexpr syntax, including an even mightier syntax-define would be great, that'll enable all the current sugar on top of our lambdas.
06:27:41 <ksf> mhhhhh... defining infix functions by instancing the Infix class...
06:28:07 <Saizan_> ksf: seen liskell?
06:28:12 <ksf> did.
06:28:34 <idnar> BONUS: nice :P
06:29:19 <rbe> hi all
06:29:39 <BONUS> aloha
06:29:43 <rbe> how can i convert a list of ints into a single int? [1,2,3,4] --> 1234 :: Int ... is there any library function?
06:29:47 <rbe> i wrote this:
06:29:55 <rbe> intListToInt = foldr (+) 0 . map (\(x,y) -> y * (10 ^ x `div` 10)) . zip [1..] . reverse
06:29:58 <opqdonut> :t intToDigit
06:29:59 <lambdabot> Int -> Char
06:30:08 <opqdonut> > map intToDigit [1,2,3]
06:30:09 <lambdabot>   "123"
06:30:15 <opqdonut> ah, sorry, misread you
06:30:18 <rbe> no [Int,Int,Int] -> Int
06:30:20 <rbe> ;)
06:30:30 <opqdonut> but you could read that
06:30:31 <adrian_> :t mapAccumL
06:30:32 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
06:30:51 <Saizan_> > foldl (\a x -> x + a * 10) 0 [1,2,3,4]
06:30:52 <lambdabot>   1234
06:31:34 <rbe> thx op, Saizan
06:31:35 <opqdonut> your solution is a bit nicer as
06:32:05 <BONUS> or in pointless style: foldl ((+).(*10)) 0
06:32:40 <opqdonut> > let f = sum . zipwith (*) (map (10^) [1..]) . reverse in f [1,2,3]
06:32:40 <pumpkin> > foldl ((+).(*10)) 0 [1..4]
06:32:41 <lambdabot>   Not in scope: `zipwith'
06:32:42 <lambdabot>   1234
06:32:47 <opqdonut> > let f = sum . zipWith (*) (map (10^) [1..]) . reverse in f [1,2,3]
06:32:48 <opqdonut> gah
06:32:48 <lambdabot>   1230
06:32:50 <dmead> With
06:32:58 <opqdonut> and 0..
06:32:59 <opqdonut> but anyways
06:33:04 <opqdonut> the foldl is neatest
06:33:13 <opqdonut> in terms of requiring only Num etc
06:33:18 <dnul_> how can i write foldr (+.ord) (chr 0) "asd"
06:33:24 <BONUS> although you might wanna use foldl'
06:33:24 <dnul_> ?
06:33:36 <dmead> [Int] -> [Char] -> Int
06:33:39 <dmead> is what you want right?
06:33:42 <BONUS> you just did :)
06:33:52 <pumpkin> > foldl1 ((+).(*10).digitToInt) "1234"
06:33:53 <lambdabot>   Couldn't match expected type `Char' against inferred type `Int'
06:33:57 <opqdonut> > foldr ((+).ord) (chr 0) "asd"
06:33:57 <pumpkin> boo
06:33:58 <lambdabot>   Couldn't match expected type `Int' against inferred type `Char'
06:34:08 <dnul_> opqdonut: thx
06:34:08 <opqdonut> > foldl ((+).ord) (chr 0) "asd"
06:34:09 <lambdabot>   Couldn't match expected type `Char' against inferred type `Int'
06:34:12 <opqdonut> gah
06:34:15 <pumpkin> do you really want ord?
06:34:19 <opqdonut> types don't match
06:34:20 <pumpkin> digitToInt sounds more like it
06:34:25 <Gilly> rbe: (read.(map digitToInt)) :P
06:34:39 <mercury^> > let f 0 = Nothing; f n = (rem n 10, quot n 10) in reverse $ unfoldr f 1234
06:34:40 <lambdabot>   Couldn't match expected type `Maybe a'
06:34:43 <mercury^> argh
06:34:45 <opqdonut> yeah i'd map first
06:34:48 <pumpkin> > foldl ((+).(*10).digitToInt) '0' "1234"
06:34:49 <dnul_> opqdonut: infix operator?
06:34:49 <lambdabot>   Couldn't match expected type `Char' against inferred type `Int'
06:34:50 <adrian_> > foldr (\ a b -> b + ord a) 0 "aoeu"
06:34:52 <lambdabot>   426
06:34:53 <mercury^> > let f 0 = Nothing; f n = Just (rem n 10, quot n 10) in reverse $ unfoldr f 1234
06:34:54 <lambdabot>   [1,2,3,4]
06:34:55 <pumpkin> oh duh
06:35:06 <Gilly> err, not quite
06:35:23 <adrian_> @pl (\a b -> b + ord a)
06:35:24 <lambdabot> (+) . ord
06:35:28 <Gilly> > (read.(map intToDigit)) [1,2,3] :: Integer
06:35:29 <lambdabot>   123
06:35:49 <Gilly> very stupid, of course :)
06:36:02 <adrian_> > foldr ((+).ord) 0 "aoeu"
06:36:04 <lambdabot>   426
06:36:14 <rbe> gilly: digitToInt is hex-based... doesn't help
06:36:20 <dnul_> adrian_: thx
06:36:37 <adrian_> @pl (\a b -> a + ord b)
06:36:37 <lambdabot> (. ord) . (+)
06:36:52 <rbe> > foldr (+) 0 [1,2,3,4]
06:36:53 <adrian_> > foldl ((. ord) . (+)) 0 "aoeu"
06:36:54 <lambdabot>   10
06:36:54 <lambdabot>   426
06:37:04 <adrian_> left fold. much cooler :D
06:38:51 <Gilly> rbe: well (read.(map intToDigit)) works as demonstrated :P
06:39:22 <ddarius> > const 1234 [1,2,3,4]
06:39:23 <lambdabot>   1234
06:39:29 <pumpkin> nice!
06:39:42 <pumpkin> > const 1234 "1234" --reads strings too!
06:39:43 <lambdabot>   1234
06:41:56 <adrian_> could one use template haskell to generate a function that pattern matches on all [Int] < n?
06:42:47 <pumpkin> you don't want to make your program too large or ghc will refuse to compile it
06:43:01 <pumpkin> or rather, it'll be impossible to compile in ghc
06:43:04 <vincenz> I fail to see the point
06:43:12 <vincenz> foo list | length list < n = ...
06:43:32 <pumpkin> or all (<n) list
06:43:37 <pumpkin> or whatever it is you mean by that :P
06:43:45 <Martijn> adrian_: I guess you mean pattern match on [], [x1], [x1,x2], ...
06:43:47 <Martijn> In that case: sure
06:44:04 <vincenz> It wouldn't be very useful since you could hardly use those pattern-variables
06:44:11 <vincenz> At which point, if you want to simply limit list length, use guards
06:45:39 <ejt> could someone give me a hint what 'Inferred type is less polymorphic than expected' means please ?
06:46:23 <Martijn> :t True :: a
06:46:24 <lambdabot>     Couldn't match expected type `a' against inferred type `Bool'
06:46:24 <lambdabot>       `a' is a rigid type variable bound by
06:46:24 <lambdabot>           the polymorphic type `forall a. a' at <interactive>:1:0
06:48:54 <Martijn> ejt: I think it's something like that: the parser expects something polymorphic such as [a] but you're actually giving it something more specific, such as a [Bool]
06:50:03 <ejt> Martijn: ok, thx
06:50:06 <SamB_XP> ejt: what was the expression?
06:50:07 <lambdabot> SamB_XP: You have 1 new message. '/msg lambdabot @messages' to read it.
06:50:11 <SamB_XP> @message
06:50:12 <lambdabot> Maybe you meant: messages messages?
06:50:14 <SamB_XP> @messages
06:50:14 <lambdabot> gwern said 2d 16h 26m 34s ago: re long filenames in errors - with ghc 6.10 hint, the temp files aren't used at all (it was just a hack around a 6.8 bug) so I regard it as a moot issue not worth
06:50:14 <lambdabot> fixing
06:50:33 <SamB_XP> hey, I read that one already, silly bot ...
06:50:45 <SamB_XP> well, it might have been to a different SamB ...
06:50:47 <ejt> SamB_XP: I was playing with Data.Generics: everywhereM . mkM $ <expr>
06:50:50 <lilac> @botsmack
06:50:51 <lambdabot> :)
06:50:51 <lunabot>  :)
06:50:57 <SamB_XP> heh
06:51:02 <ejt> <expr> was getting the polymorphism error
06:51:24 <Martijn> ejt: yes, your expression has to be polymorphic
06:51:40 <lilac> ejt: you need one of the "Data b => f a -> f b" style combinators
06:51:53 <lilac> "(Data a, Data b) => ..." rather
06:52:20 <lilac> i forget the name but it's in the SYB paper
06:52:51 <ejt> I've just got it building - I think I was being stupid and providing too many arguments.  Confusing error message in that situation though
06:53:52 <lilac> > Hey GHC, can you provide me with readable error messages?
06:53:54 <lambdabot>   <no location info>: parse error on input `,'
06:54:26 <Igloo> lilac: Please file a ticket, including a small example
06:54:59 <cknapp> Your ticket will be placed in the queue.
06:56:43 <boegel> and the queue will be placed on a stack?
06:57:17 <lilac> the stack will be added to the end of an infinite lazy list
06:57:30 <cknapp> haha
06:58:16 <cknapp> Unfortunately, I think Haskell will throw an error if you do that...
06:59:47 <SamB_XP> there isn't a real queue, unless it's a secret of the Haskell Cabal
07:00:16 <lilac> > fix (reverse . take 8 . tail . reverse $ getChannelContents #haskell)
07:00:17 <lambdabot>   Not in scope: `getChannelContents'Not in scope: `#'Not in scope: `haskell'
07:01:25 <Martijn> > putStrLn "hi!"
07:01:26 <lambdabot>   * Exception: "<IO ()>"
07:01:58 <Martijn> > let unsafePerformIO x = "hi!" in unsafePerformIO (return ())
07:01:59 <lambdabot>   Add a type signature
07:02:25 <lilac> > fix (const . fix)
07:02:27 <lambdabot>       Overlapping instances for Show (b -> b)
07:02:27 <lambdabot>        arising from a use of `s...
07:02:49 <lilac> > fix (const . fix) 42
07:02:50 <lambdabot>   * Exception: stack overflow
07:03:11 <cknapp> Are yout rying to piss off the the lambdabot, or does it just hate you all?
07:07:18 <lucca> cknapp: there'd only be an error if you... force the issue
07:08:27 <cknapp> ...
07:08:38 <cknapp> Well said.
07:23:53 <chrisdon`> @hoogle Applicative f => [f a] -> f [a]
07:23:54 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
07:23:54 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
07:23:54 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
07:27:21 <chrisdon`> nice way to make a formlet for a list of things =)
07:31:02 <iago_> hi, someone knows some paper/blog-post or haskell code that applies decorator/proxy/composite design patterns ?
07:31:32 <quicksilver> iago_: certainly not. such patterns are an aberration. :P
07:32:01 <iago_> quicksilver, uhm?
07:32:20 <quicksilver> people don't write about applying patterns to haskell
07:32:29 <quicksilver> it's trendy to say that patterns don't exist in haskell
07:32:39 <quicksilver> they just work around deficiencies in other programming languages.
07:32:50 <quicksilver> (this is not entirely true, of course)
07:32:56 <quicksilver> but it has a grain of truth to it.
07:33:11 <quicksilver> using an abstract type is rather like proxy.
07:33:33 <iago_> quicksilver, well, not just like that
07:33:47 <quicksilver> decorator is pretty obvious.
07:33:50 <iago_> you want to make no difference
07:34:17 <iago_> if you funcion is A -> A, you want that the same function could work with ProxiedA -> ProxiedA
07:34:27 <quicksilver> that's very concrete.
07:34:28 <iago_> and it is not always trivial with type-classes
07:34:36 <quicksilver> no real program has such concrete requirements.
07:34:44 <quicksilver> program requirements are not about the exact types of functions
07:34:52 <quicksilver> they're about writing code to solve problems.
07:34:58 <sw17ch> is there a good description of how Haskell (GHC)'s stack works?
07:35:15 <iago_> quicksilver, I means that the same function should work for A, and for any decorator version of A, and for any proxied version of A
07:35:15 <iago_> etc
07:35:21 <quicksilver> if you want a function to work over a variety of types, you have various choices.
07:35:32 <quicksilver> typeclasses, sum types, parametric polymorphism.
07:35:35 <iago_> and I can do a type data A = A | ProxiedA | DecoratedA
07:35:41 <iago_> I can't*
07:35:56 <iago_> it is too static
07:36:09 <iago_> or non-flexible
07:36:23 <pejo> Why do people in general want a proxy pattern in the first place?
07:36:25 <quicksilver> you could pass around a tuple which is the operations you can do on A
07:36:33 <quicksilver> you could use an existential
07:36:45 <iago_> pejo, for add a cache transparently for example
07:37:28 <cknapp> I have no idea what I'm talking about, but couldn't you make your proxy a functor or moand or something?
07:37:32 <cknapp> monad*
07:38:31 <iago_> I don't see the way
07:39:34 <quicksilver> design your type right in the first place.
07:39:36 <iago_> quicksilver, an existential? can you put a small example?
07:39:54 <quicksilver> have a type which represents "data handle", for example
07:40:03 <quicksilver> which might or might not have layers of translation + caching
07:40:15 <quicksilver> and then you can write nice combinators to combine them.
07:40:33 <quicksilver> handle may be a bad choice of word.
07:40:51 <iago_> if you have a Handler ok
07:41:22 <iago_> for example, for a I/O abstraction
07:41:32 <iago_> you may want a buffered version
07:41:36 <quicksilver> yes.
07:41:41 <quicksilver> Proxy is a solution to a non-problem.
07:41:47 <quicksilver> it's a solution to the problem "I got my data types wrong"
07:41:55 <quicksilver> well, re-engineer and get the types right.
07:42:05 <quicksilver> Decorator too, in a weaker sense.
07:42:05 <iago_> quicksilver, ok, so what is your right solution
07:42:19 <quicksilver> Define your types, the operations on them, and the combinators that produce them.
07:42:34 <ordnungswidrig> quicksilver: what about proxies / decorators to adapt a third party API?
07:42:56 <quicksilver> ordnungswidrig: you end up with having to define a new type.
07:43:03 <quicksilver> ordnungswidrig: you can't alter a third-party type, after all.
07:43:13 <quicksilver> unless they designed their type with the adaptations in mind.
07:43:17 <quicksilver> having said that, it's not hard to do.
07:43:35 <iago_> quicksilver, ?
07:43:50 <quicksilver> iago_: do you want to give a more specific example?
07:43:55 <iago_> buffered :: Handler -> Handler ?
07:44:08 <iago_> being Handler a data-type?
07:44:13 <quicksilver> yes.
07:44:25 <quicksilver> or buffered :: Int -> Handler -> Handler
07:44:31 <quicksilver> (let's you specify buffer size)
07:44:32 <quicksilver> for example.
07:44:39 <int80_h> good morning #haskell :)
07:44:47 <quicksilver> translated :: (Char -> Char) -> Handler -> Handler
07:44:55 <quicksilver> lets you add a filter.
07:45:00 <quicksilver> well, a map I should say :)
07:45:10 <iago_> quicksilver, I have some things where I take this approach, but is not always possible
07:45:11 <ehird> I wonder why there's so much fuss about monads. I never had a problem understanding them, really.
07:45:28 <quicksilver> iago_: and why is it not always possible?
07:45:38 <SamB_XP> my only problem was that I was trying to figure out how to say what they are
07:45:39 <iago_> possible, but sometimes too restrictive no?
07:45:46 <ordnungswidrig> ehird: there is a lot of fuzz why the recent tutorials to monads are creating such a confusion
07:45:49 <iago_> you can't redesign all when you need some new feature
07:46:00 <iago_> you should be able of extend functionality without have to change all
07:46:39 <adrian_> iago_ you could always wrap it all in a newtype
07:46:55 <adrian_> and decide on a by function basis what you want to do
07:46:58 <iago_> adrian_, so you start with the problem of can reuse all your existing code
07:47:07 <quicksilver> wrapping in a new type and adding passthrough functions is the natural equivalent to a decorator.
07:47:17 <iago_> adrian_, bad idea
07:47:24 <cknapp> ehird: there's such a fuss because people try to jump right into them without knowing haskell, and then "finally figure them out" so they post a tutorial... that just confuses the issue
07:47:39 <ehird> :)
07:47:56 <iago_> adrian_, if I undersand you well, perhaps not ;P
07:48:14 <ehird> yeah, I think it's that I took in all of haskell in pieces, I guess, so when you come to monads it's not much of a step up from everything else
07:48:16 <adrian_> I don't really see the difference between Blah b = new DecorateMyStuff(new UndecoratedStuff); and newtype DecoratedStuff = D UndecoratedStuff
07:48:24 <SamB_XP> I think I never really had trouble with 'em, just thought I did because I couldn't say what they were ;-P
07:48:40 <SamB_XP> (I said that already, didn't I ?)
07:48:48 <SamB_XP> (I should probably shut up now ...)
07:49:18 <ehird> SamB_XP: don't think you did :P
07:49:19 <int80_h> w/b al-maisan
07:49:27 <int80_h> yeah, he did
07:49:30 <ehird> oh, ok.
07:49:31 <ehird> @quote warm fluffy things
07:49:31 <lambdabot> No quotes for this person. And you call yourself a Rocket Scientist!
07:49:33 <iago_> adrian_, subtypes
07:49:40 <al-maisan> int80_h: thanks :)
07:49:51 <iago_> all you have done with UndecoratedStuff now works with DecoratedStuff
07:50:05 <adrian_> ah well, but such things are handled by typeclasses no?
07:50:07 <iago_> you can add features without change no line of existing code
07:50:13 <adrian_> class Stuff where
07:50:23 <ehird> adrian_: going that route you make everything a class
07:50:24 <adrian_> instance DecoratedStuff
07:50:30 <ehird> because you never know when you'll have a subtype
07:50:47 <adrian_> and what's so bad about that?
07:51:07 <ehird> you're advocating making every type into a class with one instance? um, ok.
07:51:16 <adrian_> it's just a layer of abstraction from the actual datatypes
07:51:36 <cknapp> But if there's one instance, there isn't really a class...
07:51:37 <quicksilver> iago_: subtypes are a well-known cause of bugs :)
07:51:41 <adrian_> when you can expect people to want subtypes
07:51:46 <int80_h> @seen lemmih
07:51:46 <lambdabot> lemmih is in #haskell. I don't know when lemmih last spoke.
07:51:56 <quicksilver> iago_: however, I agree with the following:
07:51:57 <Lemmih> int80_h: Hi.
07:52:02 <int80_h> hi Lemmih :)
07:52:02 * ehird would like subtypes & a decent record system, that's about it
07:52:08 <iago_> ehird, is not a bad idea, you should work with interfaces ;P in general
07:52:14 <int80_h> lemmih: Hi (I mean)
07:52:16 <ehird> subtypes _should_ be used sparingly
07:52:23 <quicksilver> "Since haskell does not permit subtyping of arbitrary types, you need to decide which things are going to be subtypable up-front"
07:52:27 <ehird> as they're not the correct solution nearly as often as claimed
07:52:32 <quicksilver> personally I think that's a *good* thing
07:52:33 <ehird> but when you need them, it's a huge pain
07:52:39 <quicksilver> because overuse of subtypes is bad.
07:52:41 <quicksilver> but YMMV.
07:52:47 <ehird> if you can tell the future, sure.
07:52:49 <ehird> can you?
07:52:56 <quicksilver> that's a ridiculous straw man
07:53:01 <quicksilver> do you really want me to respond to it?
07:53:07 <ehird> perhaps
07:53:20 <pejo> ehird, O'Haskell. ;)
07:53:23 * sw17ch wonders what is considered sub-typing
07:53:23 <quicksilver> Software design is an human, and therfore imperfect process
07:53:32 <quicksilver> we never correctly guess the future entirely. We do our best.
07:53:36 <rickasaurus1> the only thing I don't like about haskell is the int rollover
07:53:43 <rickasaurus1> for such a safe language it's a terribly unsafe thing
07:53:44 <quicksilver> Some future requirements require larger code changes than others.
07:53:45 <quicksilver> That's life.
07:53:46 <ehird> sw17ch: a type B that works as an A in every case an A does, but also has B-specific things
07:53:47 <int80_h> lemmih : I'll brb, but I had some questions for you
07:53:51 <pejo> quicksilver, overuse of type classes is bad too. And overuse of any other feature.
07:54:02 <SamB_XP> rickasaurus1: if you want an integer ... you know where to find it
07:54:02 <ehird> pejo: ew :)
07:54:05 <Ferdirand> Hi everyone, question: is there a well-known algorithm for splitting a graph into the least number of fully-connected (maybe overlapping) subgraphs ?
07:54:08 <rickasaurus1> yea, but it's slow
07:54:13 <sw17ch> ehird: is that like using a Char as a type, but specializing on 'a', and 'b'?
07:54:15 <cknapp> int80_h: you can probably address them to the peanut gallery, as soon as they quite down. :)
07:54:16 <quicksilver> pejo: True. But what I meant is that overuse of subtyping is not only harmful, but actually common :)
07:54:17 <iago_> quicksilver, I'm not argue that Haskell need subtypes, I'm looking for the way that Haskell address the problem
07:54:18 <rickasaurus1> I just want to be able to check for the rollover flag
07:54:23 <ehird> sw17ch: um, I'm not sure I follow
07:54:31 <quicksilver> rickasaurus1: ++ on that
07:54:34 <pejo> ehird, why ew, except that it's a dead end?
07:54:37 <quicksilver> rickasaurus1: that's my number one complaint about C.
07:54:42 <ehird> pejo: I don't think it's needed.
07:54:54 <ehird> Just a more flexible record system + subtypes would do everything I want
07:54:54 <SamB_XP> how would that work anyway ?
07:54:56 <quicksilver> rickasaurus1: it claims to be a low level language, but it doesn't even expose overflow and carry bits.
07:55:04 <ehird> quicksilver: you can check for overflow, no?
07:55:07 <pejo> quicksilver, when all you have is a hammer ..
07:55:07 <rickasaurus1> I agree, overflow and carry are key
07:55:08 <sw17ch> ehird: umm... using a range in a Char type as an enumerated data type in two diffeernt places
07:55:09 <ehird> (a+b)<a || (a+b)<b
07:55:10 <ehird> or whatever
07:55:18 <SamB_XP> quicksilver: it never claimed to be a low-level language
07:55:19 <rickasaurus1> but it's less jarring to see inline asm in C than in haskell :)
07:55:23 <ehird> sw17ch: i don't follow, sorry.
07:55:23 <SamB_XP> it just IS
07:55:24 <sw17ch> i guessi 'd need to see an example of sub-typing
07:55:27 <rickasaurus1> can you even do inline asm in haskell :)
07:55:27 <sw17ch> ehird: ^^
07:55:28 <SamB_XP> it's just not quite that lowlevel
07:55:28 <quicksilver> ehird: I want to be able to express that in one opcode
07:55:29 <pejo> ehird, um, and what other than that does O'Haskell provide?
07:55:31 <quicksilver> ehird: not in 40.
07:55:48 <ehird> quicksilver: well, sure.  pejo: it completely overhauls all of that
07:55:48 <sw17ch> rickasaurus1: perhaps the alex project?
07:55:52 <sw17ch> no, that's not right
07:55:55 <quicksilver> SamB_XP: maybe not. Other people claim that of it.
07:55:56 <ziman> using harpy :)
07:55:56 <sw17ch> rickasaurus1: the harpy project
07:56:04 <rickasaurus1> i'll check that out
07:56:13 <sw17ch> rickasaurus1: also the LLVM project
07:56:16 <sw17ch> :)
07:56:18 <SamB_XP> quicksilver: well, properly it's "slightly higher level than ASM"
07:57:16 <SamB_XP> also, CPUs have a nasty habbit of having ever-so-slightly different handling of these issues, don't they ?
07:57:39 <rickasaurus1> sure, an x86 extension library would be fine
07:57:56 <SamB_XP> rickasaurus1: it can't be an extension ...
07:58:09 <rickasaurus1> well, you could have a new implementation of int
07:58:11 <SamB_XP> the flag has to be checked immediately after the op
07:58:34 <SamB_XP> (well, with no intervening flag-setting ops ...)
07:58:42 <rickasaurus1> for sure
07:58:47 <SamB_XP> also, that wouldn't really fit Num at all well
07:59:06 <rickasaurus1> i'm just saying, the int rollover thing is completely unsafe :)
07:59:13 <rickasaurus1> I love haskell
07:59:27 <SamB_XP> it's perfectly safe as long as you were expecting mod-unknown arithmatic
07:59:28 <rickasaurus1> it's just something I wish I could workaround
08:00:07 <Voltaplein> Hi -- I'm trying to learn Haskell in order to understand a paper I'm studying on the sieve of eratosthenes.  I'm trying to run some code from the paper but it won't compile. Could anyone take a look and tell me what the problem is?  I pasted the code here: http://pastebin.com/d1c49b686.  The error message I get is: http://pastebin.com/d1c49b686
08:00:11 <rickasaurus1> maybe safe versions of operators
08:00:21 <SamB_XP> (that said, yes, there have been serious low-level bugs due to it ...)
08:00:31 <SamB_XP> (but a heck of a lot less than in C, I'll wager!)
08:00:31 <Voltaplein> Sorry -- error message is sieve1.hs:6:14: Parse error in pattern
08:00:43 <rickasaurus1> for sure, C is a nightmare :)
08:01:02 <quicksilver> SamB_XP: sure. My gripe is this: given an efficient (presumably hardware) "n-bit" integer, it should be *trivial* to implement a "2n-bit" integer reasonably efficiently.
08:01:02 <rickasaurus1> the spec is completely ambiguious in a ton of ways
08:01:09 <rickasaurus1> ambiguous even
08:01:12 <adrian_> Voltaplein: what's that: &#8722;
08:01:18 <quicksilver> SamB_XP: to my mind, that's minimum functionality for a useful low-level language.
08:01:18 <SamB_XP> I mean, in C there are a ton of places where you have malloc(n*sizeof foo)
08:01:24 <arw> Voltaplein: the &#<number>; is a html-leftover.
08:01:27 <SamB_XP> each one of those could wrap around
08:01:29 <quicksilver> SamB_XP: none of the standard ones provide that.
08:01:33 <Saizan_> Voltaplein: &#8722; should be a
08:01:36 <Saizan_> -
08:01:38 <arw> Voltaplein: that should be a -> in the source i think.
08:01:39 <adrian_> Voltaplain: ->
08:02:00 <SamB_XP> (That's basically the same serious bug that happened in Haskell due to it ... but it was in library code, so much easier to eliminate)
08:02:16 <ehird> http://hpaste.org/13890 Hypothetical subtyping example
08:02:23 <SamB_XP> quicksilver: well, C was pretty good for what it was made for
08:02:31 <ehird> a rather trite & cliched one, admittedly
08:02:33 <ehird> but there you go
08:02:57 <SamB_XP> which is, as far as I can tell, making it possible to port unix without rewriting the entire codebase in a new assembly language
08:02:57 <ehird> of course, it'd be better if Square added more fields, but meh
08:03:18 <sw17ch> ehird: thanks
08:03:18 <ehird> SamB_XP: i think they just didn't want to use assembly :-)
08:03:27 <ehird> sw17ch: :)
08:03:34 <Voltaplein> Saizan_: could be because I copied it from a PDF.  lemme check
08:03:43 <quicksilver> SamB_XP: true, yes. It was admirable at that.
08:03:45 <SamB_XP> ehird: well, yeah, that too
08:03:55 <int80_h> lemmih: you there still?
08:04:02 <quicksilver> SamB_XP: and I'm not trying to take away from that either :)
08:04:06 <SamB_XP> ehird: but this was after they'd already written it once in ASM
08:04:16 <Lemmih> int80_h: Yes.
08:04:22 <ehird> SamB_XP: "Jesus christ I am _never_ doing that again"
08:04:26 <quicksilver> SamB_XP: but there is definitely a niche for a language whose goal is "effficient machine code for multiple platforms"
08:04:36 <ehird> quicksilver: um... C--?
08:04:45 <ehird> LLVM? ec
08:04:46 <ehird> *etc
08:04:49 <quicksilver> not sure C-- has the kind of efficiency in mind that I'm talking about.
08:04:49 <sw17ch> ehird: i think i'd much rather have data Rectangle be a typeclass with a proper Rectangle and a Square both implementing the interface
08:05:05 <Voltaplein> Saizan_: yeah, that was it.  Now I've got a bunch of "not in scope" messages for Map.empty, Map.lookup etc.  How do I cure that?
08:05:05 <quicksilver> dont' think C-- gives you access to (e.g.) FPU vectorisation or ALU flags.
08:05:11 <quicksilver> LLVM a bit more perhaps?
08:05:16 <ehird> sw17ch: that's awkward, though, and breaks down if your system was just doing rectangles, but now we want to do squares too
08:05:28 <Saizan> Voltaplein: import qualified Data.Map as Map
08:05:28 <cknapp> import Data.Map
08:05:37 <cknapp> right... what he said
08:05:38 <Saizan> Voltaplein: put that at the top of the file
08:05:43 <ehird> although tbh, (makeRectangle 5 5) should be a Square anyway
08:05:43 <Voltaplein> thkx
08:05:49 <int80_h> lemmih: I've got happs tutorial installed. But I can't pass parameters to Main.hs. I can run the script "runInGhci" but it fails because I don't know how to tell it to start on port 8080. Can you help with that?
08:05:51 <ehird> so it's a bad example :)
08:06:13 <int80_h> lemmih: I need to pass the parameters 8080 True True
08:06:19 <sw17ch> ehird: hmm... i'm writing a bunch of Data.Binary instances for different packet types
08:06:45 <Lemmih> int80_h: ':set args 8080 True True' or ':main 8080 True True'.
08:06:47 <sw17ch> ehird: so, i parse the ethernet packet, and then i check the type field, and generate IP, or IPC, or ICMP... whatever types underneath,... and on down
08:06:55 <ehird> mmhmm?
08:07:00 <sw17ch> i think i might be able to see an application there
08:07:01 <int80_h> Lemmih: Thanks :)
08:07:05 <Voltaplein> Saizan: I still get the "not in scope messages'" even after importing Data.Map
08:07:08 <ehird> sw17ch: yes, seems likely
08:07:12 <ehird> although in that case
08:07:15 <sw17ch> but i think that my packet parser is still better as an algebraic alternative
08:07:17 <ehird> I'd probably use some encapsulation, like:
08:07:22 <Voltaplein> oh, forgot the qualified
08:07:22 <Saizan> Voltaplein: the same ones?
08:07:26 <vixey> hello
08:07:35 <cknapp> Hello, vixey
08:07:46 <ehird> sw17ch: EthernetPacket has a body field which is :: (PacketBody a) => a
08:07:52 <ehird> i guess
08:07:59 <ehird> then have stuff be instances of that
08:08:03 <ehird> because it's not really subtyping
08:08:05 <sw17ch> data Ethernet = Ethernet SrcMAC DstMAC EthType EthPayload
08:08:06 <ehird> an ethernet packet contains its body
08:08:17 <sw17ch> where EthPayload is something that corresponds to the EthType
08:08:19 <sw17ch> and so on...
08:08:24 <Voltaplein> Saizan: yep, the same ones,  I inserted import qualified Data.Map before the first call
08:08:25 <ehird> oh. ew.
08:08:30 <ehird> sw17ch: replace that with a typeclass, stat.
08:08:43 <sw17ch> ehird: :) it was in the plan
08:09:04 <Saizan> Voltaplein: weird, can you paste the whole file?
08:09:09 <sw17ch> ehird: though the EthPayLoad is explicitly determined by the EthType field
08:09:17 <Voltaplein> Saizan: I got it. Forgot the "as Map"  Thanks for the help!
08:09:22 <ehird> sw17ch: that's not compile-time enforced is it?
08:09:37 <sw17ch> ehird: when generating packets, i'd like it to be :)
08:09:42 <ehird> yes
08:09:47 <ehird> so typeclasses! :)
08:09:48 <sw17ch> when reading them, no, it wouldn't be
08:09:52 <sw17ch> hehe
08:09:54 <sw17ch> oh fine
08:10:24 <sw17ch> yeah, okay, i can see how that would be better now :)
08:10:43 <ehird> in general tho I'm happy with haskell
08:10:45 <kpreid> Voltaplein: fyi "qualified" means that the symbols can only be used with prefix (Foo.bar, not bar) and "as Map" locally renames the module (Map.lookup, not Data.Map.lookup)
08:10:50 <ehird> _except_ for the fact that I have to use emacs.
08:10:55 <ehird> which is why I'm going to try building yi now ->
08:11:14 <cknapp> Have to use emacs?
08:11:26 <ehird> cknapp: editing haskell with vi is painful
08:11:31 <cknapp> ?
08:11:35 <ehird> IMo
08:11:37 <ehird> IMO
08:11:38 <cknapp> Why?
08:11:43 <ehird> just is :-)
08:11:50 <cknapp> Alright...
08:12:05 <ehird> to me, anyway
08:12:13 <quicksilver> kuribas' haskell indentation is nice; I would enjoy haskell less without that.
08:12:24 <ehird> you mean from haskell_mode?
08:12:29 <ehird> yes, it is nice
08:12:31 <quicksilver> no, it's a separate .el file
08:12:35 <quicksilver> better than the haskell-mode one
08:12:38 <ehird> yes
08:12:38 <ehird> I have it
08:12:40 * quicksilver nods
08:12:47 <ehird> although it unfortunately reminds me that haskell indentation has too many choices at any given point
08:12:50 <quicksilver> @where kuribas-indentation
08:12:50 <lambdabot> http://kuribas.hcoop.net/haskell-indentation.el
08:12:52 <ehird> my tab key is worn out
08:12:54 <quicksilver> that one :)
08:13:00 <ehird> hope haskell prime fixes that a bit
08:13:09 <pejo> quicksilver, do you run it together with haskell-mode.el or instead of?
08:13:10 <quicksilver> ehird: you are free to use { ; } everywhere, and then have no choices
08:13:15 <ehird> quicksilver: ye
08:13:16 <ehird> *ew
08:13:21 <quicksilver> (or, rather, no semanticallys significant choices)
08:13:35 <quicksilver> pejo: together with. It only replaces the indentation part. The other bits of haskell-mode are useful.
08:21:35 <ehird> % darcs get --lazy http://code.haskell.org/yi/
08:21:55 <athos> hi all
08:22:20 * ehird waits 7 hours
08:23:25 <cknapp> Hi athos
08:24:43 <BONUS> w00t, learnin about zippers today
08:24:50 <BONUS> this look alright for a zipper? http://hpaste.org/13891
08:24:55 <vixey> yay BONUS
08:25:00 <BONUS> zippers own
08:25:10 <vixey> me too
08:25:19 <BONUS> i was literally grinning today when reading about them and implementing some zippers
08:25:26 <vixey> hehe
08:26:34 <BONUS> interesting thing i found out: the context for a list is just another list, and a location is ([a],[a])
08:27:25 <vixey> yeah something like "abcoxyz" you can have the context ("cba","xyz")
08:27:32 <nj32> I wrote a function to count the frequency of alphabets in a string, could someone tell me an elegant way to do it: http://hpaste.org/13892
08:27:33 <vixey> if you are focused on 'o' right?
08:27:48 <BONUS> yeah.
08:28:11 <vixey> nj32, I think what you wrote there is just fine
08:28:23 <nj32> vixey: okay
08:28:28 <BONUS> although i did it like if oyu have "abcoxyz" and you're focused on 'o', then the location of 'o' is ("oxyz","cba")
08:28:32 <vixey> nj32, a different way would be to sort the list though
08:28:41 <vixey> then you can generate the table as you scan through the sorted list
08:28:51 <acidjnk> nj32, there is an example for this in "Programming in Haskell" in the context of cracking the caesar cipher.
08:29:12 <nj32> acidjnk: hmm
08:29:18 <BONUS> where "cba" is the context and "oxyz" is the list we're focusing on
08:29:22 <idnar> mmm, zippers
08:29:42 <mperillo> hi
08:29:46 <BONUS> aloha
08:29:55 <mperillo> i'm having problems with the IO monad and pattern guards
08:30:03 <vixey> what about the zipper for: data Tree a = Leaf a | Branch (Tree a) (Tree a)
08:30:06 <mperillo> I have a function isdir :: FilePath -> IO Bool
08:30:17 <ehird> what do most people do for Yi on os x? gtk with x11, quartz gtk, or vty?
08:30:18 <nj32> vixey: when i map a function to a list, does it not create a new list in memory?
08:30:18 <mperillo> how can I use it in a pattern guard?
08:30:19 <Saizan> nj32: freq cipher = foldl' (flip incrFreq) initList
08:30:31 <vixey> nj32, depends on the context
08:31:06 <BONUS> vixey: that's then Ctx a = Top | L (Ctx a) (Tree a) | R (Tree a) (Ctx a)
08:31:11 <BONUS> i think
08:31:28 <dons> hey guys. a treat: haskell podcast on the intel multicore radio/blog: http://www.reddit.com/r/haskell/comments/7pezv/intel_parallel_programming_podcast_real_world/
08:31:45 <dons> aka /me gets interviewed about haskell, #haskell, and parallel programming
08:32:02 <BONUS> w00t, upvoting and then reading
08:32:04 <cjb> neat
08:32:11 <BONUS> i mean listening
08:33:27 <dons> fairly high level discussion. 15 mins.
08:33:32 <vixey> why Top and not Top a?
08:33:42 <nj32> Saizan: what function is foldl' ?
08:33:50 * sw17ch curses his broken headphones
08:34:36 <BONUS> vixey: well if you have (some_tree, Top), that tells you everything about the data and the location imho
08:35:01 <Saizan> nj32: it's from Data.List
08:35:10 <nj32> Saizan: ok
08:35:19 <quicksilver> it's a matter of taste if you put the actual element under focus "in" the zipper or not.
08:35:32 <Saizan> > foldl' f z [1..4]
08:35:34 <lambdabot>   f (f (f (f z 1) 2) 3) 4
08:36:40 <vixey> with the simpler case, "abc[[o]]xyz" ~> ("oxyz","cba")
08:36:56 <vixey> what happens if you start with the empty list?
08:37:18 <athos> > foldl f z [1..4]
08:37:20 <lambdabot>   f (f (f (f z 1) 2) 3) 4
08:37:37 <BONUS> well if you're focusing at the end of the list ([]), then i guess it's ([], "zyxocba")
08:38:01 <vixey> but what about focusing on a nil?
08:38:33 <Olathe> > foldr f z [1..8]
08:38:34 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 z)))))))
08:38:45 <BONUS> hmm well i think of it like if it's a tree, you're always focusing on a subtree
08:38:51 <Olathe> > foldb f z [1..8]
08:38:52 <lambdabot>   f z (f (f (f 1 2) (f 3 4)) (f (f 5 6) (f 7 8)))
08:39:07 <BONUS> and if it's a list, then you focus on a sublist
08:39:18 <Olathe> @type Tree
08:39:19 <lambdabot> Not in scope: data constructor `Tree'
08:39:30 <Olathe> @type Leaf
08:39:32 <lambdabot> Not in scope: data constructor `Leaf'
08:39:48 <BONUS> data Tree a = Branch (Tree a) (Tree a) | Leaf a
08:39:57 <vixey> so for the data type F :: * -> * you get the context C :: * -> *, and the zipper Z a = (F a, C a)?
08:40:01 <Olathe> @type f
08:40:02 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
08:40:23 <vixey> (and the context C can be computed from the data type F)
08:40:24 <BONUS> yeah
08:40:24 <Olathe> > fun "f" :: FromExpr a
08:40:26 <lambdabot>       Not in scope: type constructor or class `FromExpr'
08:40:31 <BONUS> exactly
08:40:32 <Olathe> > fun "f" :: a
08:40:33 <lambdabot>       Could not deduce (SimpleReflect.FromExpr a) from the context ()
08:40:33 <lambdabot>        ...
08:40:42 <Olathe> > fun "f"
08:40:44 <lambdabot>   Add a type signature
08:40:51 <vixey> I think for every zipper you can write Z a -> F a
08:41:07 <vixey> but what I don't really get is functions: Z a -> Z a
08:41:09 <Olathe> > let f :: (SimpleReflect.FromExpr a) => a; f = fun "f" in f
08:41:11 <lambdabot>       Not in scope: type constructor or class `SimpleReflect.FromExpr'
08:41:17 <BONUS> vixey: well i prefer to do
08:41:19 <vixey> maybe it needs to be something like  Z a -> Direction -> Z a?
08:41:22 <BONUS> type Location a = (F a, C a)
08:41:32 <vixey> but the directions available are contextual isn't it?
08:41:34 <BONUS> so that it represents a location within the data structure
08:41:52 <BONUS> an example Z a -> Z a if you have a binary tree is moveLeft :: Z a -> Z a
08:41:52 <vixey> oh so which bit is the zipper?
08:42:20 <BONUS> idk, i just learned this today from the haskell wiki but i'd say that the zipper is the general idiom
08:42:26 <vixey> is it Location + all the operations you can use on it then?
08:42:58 <BONUS> yeah
08:43:32 <nj32> Saizan: thank you
08:43:50 <cognominal> haskell graffiti : http://picasaweb.google.com/cognominal/NewAlbum1301091732#5290819711165334578 :)
08:44:23 <BONUS> i think that with the type Location = (F a, C a), the thing is that it represents the whole data structure that you can build from it, plus info about the focus
08:45:12 <BONUS> and Location a -> Location a is just moving the focus
08:45:14 <vixey> say instead of Tree
08:45:26 <nj32> vixey: can you give some example, where a map will create a new list, and where it'll not?
08:45:36 <vixey> data Tree a = Leaf a | Branch (Bool -> Tree a)
08:45:48 <vixey> I wonder hat happens with that
08:46:08 <BONUS> is that even a tree?
08:46:11 <BONUS> looks sort of like a list
08:46:26 <vixey> I think it's the equivalent thing to the previous Tree, except that it's written different
08:46:32 <vixey> i.e.  (a, a) ~ (Bool -> a)
08:46:35 <BONUS> ah of course
08:46:36 <idnar> it's isomorphic to data Tree a = Leaf a | Branch (Tree a) (Tree a) afaict
08:46:46 <ehird> I have gtk in a non-standard location, how can I compile gtk2hs with cabal(1) using that one?
08:46:49 <BONUS> True gives one side, False the other
08:47:05 <BONUS> i think you can use the same context over it
08:47:08 <BONUS> although i'm not sure
08:47:37 <dcoutts_> ehird: gtk2hs does not use cabal, you need to run the ./configure
08:47:44 <ehird> ah.
08:47:53 <ehird> well, that makse things easier :P
08:47:56 <dcoutts_> ehird: the ./configure will be able to find your gtk if pkg-config can
08:48:02 <ehird> will yi build both vty and gtk backends btw?
08:48:03 <BONUS> yeah i think you can, you just move around a bit differently
08:48:09 <ehird> dcoutts_: no, non-standard location
08:48:22 <dcoutts_> ehird: there is an environment var to tell pkg-config where to look
08:48:25 <ehird> ah, OK
08:48:37 <ehird> dcoutts_: also needs particular cflags...
08:49:15 <dcoutts_> ehird: but you had better make sure that with that set, that pkg-config --cflags gtk+-2.0  reports the right stuff.
08:49:19 <vixey> data Context a = Top | Climb (Bool -> (Tree a, Context a)) ?
08:49:27 <ehird> alright. this will be difficult :)
08:49:29 <vixey> no that couldn't be it
08:49:50 <dcoutts_> ehird: if it does not then you will not be able to build anything using gtk, gtk2hs or any other C progs. They all rely on pkg-config telling us the right info.
08:49:56 <ehird> yes
08:50:03 <ehird> i know :)
08:50:44 <dcoutts_> ehird: as I understand it it's quite possible to configure a pkg-config pkg to give the flags necessary to use it from a non-standard location, but I've never done it myself
08:50:50 <BONUS> i think you can just do Context a = Top | NotTop (Context a) (Bool -> Tree a)
08:51:11 <BONUS> the second field of NotTop is the upper context
08:51:13 <BONUS> hmm wait no
08:51:22 <vixey> BONUS, but given, NotTop k f,   one of (f True) and (f False) should be missing
08:51:24 <BONUS> the context has to identify if we're in the right or left branch
08:51:32 <BONUS> yeah exactly
08:51:49 <vixey> BONUS, ideally, whatever works for Bool -> Tree a, should work for Nat -> Tree a too
08:51:50 <ski_> NotTop (Context a) Bool (Tree a)
08:52:07 <BONUS> yeah that should work
08:52:27 <BONUS> because it's isomorphic to Tree a = Leaf | Branch (Leaf a) (Leaf a), you can use the same context
08:52:36 <vixey> needs to be like  WalkTrue (Context a) (Bool\{True} -> Tree a) | WalkFalse (Context a) (Bool\{False} -> Tree a)
08:52:53 <ski_> vixey : so you need to differentiate `(Nat ->)', then, i think ..
08:53:03 <vixey> hm
08:53:12 <vixey> well d/dx e^x  = e^x
08:53:15 <BONUS> the nurse is here, i gotta take my medicine and go to the tv room!
08:53:22 <BONUS> talk to ya guys later about this
08:53:24 <vixey> bye
08:53:40 <ski_> d/da a^Nat = Nat * a^Nat
08:54:01 <vixey> why is it still a^Nat and not a^(Nat-1)
08:54:26 <ski_> they are the same
08:54:27 <vixey> not sure what '1' would even mean here
08:54:30 <quicksilver> BONUS, vixey : there is a choice between Z a = (F a, C a) and Z a = (a, C a), too.
08:54:39 <quicksilver> I thought a 'zipper' was the latter, not the former.
08:54:40 <ski_> if you remove one element from a stream, you're left with a stream
08:54:51 <ski_> (plus the position, but that's `Nat *')
08:54:52 <quicksilver> I.e. you focus on a single element, not a substructure.
08:55:23 <ski_> quicksilver : what is the `F' ?
08:55:24 <vixey> ski_, so to differentiate (a ->) it matters if a is finite or not?
08:55:37 <Saizan> quicksilver: depends what you consider as context
08:55:43 <quicksilver> ski_: the functor we started with.
08:55:45 <quicksilver> ski_: e.g. Tree
08:56:21 <Saizan> quicksilver: e.g. for lists: only the prefix or also the suffix
08:57:20 <quicksilver> Saizan: yes.
08:57:27 <Saizan> in the former Z a = (a,F a,C a) though
08:57:35 <ski_> (vixey : i think it's easier to see if you rewrite like `d/da a^(1 + k) = a * a^k' where `1' is `()' and `(+)' is `Either')
08:58:09 <lilac> Nat = fix (\x -> () + x). Nat + 1 = () + Nat = () + fix (\x -> () + x) = fix (\x -> () + x) = Nat
08:58:17 <ski_> (vixey : and `Nat' is isomorphic to `Either () Nat')
08:58:24 <ehird> % PKG_CONFIG_PATH=/Library/Frameworks/Gtk.framework/Resources/dev/lib/pkgconfig:/Library/Frameworks/GLib.framework/Resources/dev/lib/pkgconfig:/Library/Frameworks/Cairo.framework/Resources/dev/lib/pkgconfig ./configure
08:58:26 <ehird> my lord
08:58:34 <dcoutts_> heh heh
08:59:02 <lilac> i love how pkg-config makes things simpler ;-)
08:59:08 <dcoutts_> ehird: I guess it's because you've got them all installed under different prefixes
08:59:20 <ehird> dcoutts_: I have a disease, it's called OS X :-)
08:59:22 <lilac> no more telling your configure script where things are with --with-foo=...
08:59:29 <dcoutts_> ehird: eg with the gtk+ bundle we use to build on windows, we have all the packages under one prefix
08:59:44 <dcoutts_> ehird: aye
09:00:03 <lilac> what's the type-level fixed-point operator usually called?
09:00:26 <quicksilver> mu ?
09:00:27 <ehird> well, it looks like it's building
09:00:29 <ehird> that's a good start
09:00:33 <ehird> whoa, it built
09:00:35 <ski_> `Mu' or `Fix' (or `Nu')
09:00:41 <ehird> that was _worryingly_ fast
09:00:55 <dcoutts_> lilac: aye, it would be nice if pkg-config could interact slightly better with the framework style of file system layout. It works nicely for other layouts that put stuff under one prefix.
09:01:11 <dons> and more haskell on the radio, http://www.realworldhaskell.org/blog/2009/01/13/intel-parallel-programming-podcast-real-world-haskell/
09:01:37 <andyjgill> @see bos
09:01:37 <lambdabot> bos is in #ghc and #haskell. I don't know when bos last spoke.
09:02:08 <ehird> * gnomevfs      : no               * sourceview    : no             * gconf         : no                  * glade         : no               * gnomevfs      : no
09:02:14 <ehird> lack of those will be a problem, won't it
09:02:43 <ski_> D f a * a = f a * E f a
09:04:54 <dcoutts_> ehird: depends what you want, glade is often useful
09:05:18 <ehird> i don't really plan on writing my own gtk stuff (not really my thing), but more using other haskell+gtk programs
09:05:32 <ehird> and a lot of gtk programs use those, it seems
09:09:10 <vixey> Mu for LFP, Nu for GFP
09:10:17 <Olathe> @type (?)
09:10:18 <lambdabot> Not in scope: `?'
09:11:09 <vixey> but yeah basically thits doesn't make sense
09:11:29 <vixey> you need to subtract and element from a type
09:11:43 <lilac> vixey: least and greatest under which ordering? subset?
09:12:22 <quicksilver> yes
09:12:27 <vixey> lilac, like [a,b,c] :: Mu a. 1 + Expr * a,  but   ones = 1 : ones :: Nu a, 1 + Integer * a
09:12:56 <lilac> so Mu (Either Int) is all /finite/ lists of Ints? Or is the Mu \b knows actually Nu?
09:13:17 <quicksilver> actually Nu
09:13:22 <quicksilver> haskell can't do lfps, really.
09:13:30 <quicksilver> we just sometimes prefer to think about them.
09:13:50 <lilac> yeah, they're handy for total FP
09:14:10 <vixey> not Either Int
09:14:12 <Saizan> lilac: type ListF l = Either () (Int,l), Mu ListF
09:14:16 <lilac> is Haskell's Mu actually GFP? i suppose it's indistinguishable anyway
09:14:25 <vixey> in haskell Mu = Nu yeah
09:14:33 <ski_> vixey : instead of subtracting, you rewrite it so that it is an addition (with `1')
09:15:08 <lilac> by 'Haskell's Mu' I mean 'data Mu f = X (f (Mu f))'
09:15:28 <vixey> ski_, but then Bool = 1 + () ?
09:15:36 <ski_> e.g. yes
09:15:40 <vixey> Void = 1 + ?
09:15:47 <ski_> no
09:15:54 <vixey> lilac, usually X is In though
09:16:08 <ski_> `Void' is not inhabited
09:16:08 <lilac> d/dx (Void -> X) is 0
09:16:20 <lilac> because Void -> X is 0
09:16:36 <lilac> umm
09:16:41 <lilac> i mean it's constant rather
09:16:54 <ski_> @djinn Void -> x
09:16:55 <lambdabot> f = void
09:17:07 <lilac> ^^ that's the only inhabitant
09:17:17 <quicksilver> Void -> X is unique, perhaps you mean?
09:17:28 <quicksilver> it's not really constant, it doesn't take any value at all :|)
09:17:32 <lilac> it's constant, and in fact isomorphic to 1
09:17:36 <noZone> "I want an error message." Maybe replies, "You'll get Nothing and like it!"
09:17:38 <lilac> quicksilver: constant as a type not as a function
09:17:54 <quicksilver> what's a constant type?
09:18:00 <vixey> Void ~ 0
09:18:02 <lilac> that is, \x -> (Void -> x) is a constant function
09:18:06 <vixey> Void -> a ~ 1
09:18:58 * ski_ would love to stay and chat ..
09:18:58 <lilac> quicksilver: i think i'm just elaborately and inaccurately saying it has exactly one inhabitant ;-)
09:19:38 * vixey checks d for data how did they handle (->) in there
09:20:00 <ski_> ("unique among types, `Void -> X' has its own charm. tourists should definitly pay a visit")
09:20:36 <ehird>     Could not find module `Graphics.UI.Gtk':
09:20:37 <ehird> :(
09:20:40 <quicksilver> lilac: ;)
09:20:52 <lilac> @remember ski_ "unique among types, `Void -> X' has its own charm. tourists should definitly pay a visit"
09:20:53 <lambdabot> Done.
09:20:59 <ehird> make install fails with ghc2hs...
09:21:01 <Saizan> well, Void -> X in haskell is comparalbe to 1 -> X in a total language, which is isomorphic to X
09:21:01 <ehird> it just compiles again
09:21:02 <vixey> can not remember which is terminal and which is initial
09:21:10 <vixey> Void is terminal object?
09:21:30 <quicksilver> initial
09:21:38 <quicksilver> Void -> X
09:21:45 <quicksilver> it's at the start of the arrow
09:21:49 <quicksilver> () is terminal
09:21:52 <quicksilver> X -> ()
09:21:54 <vixey> you can write X -> Void too though
09:21:56 <ddarius> vixey:  Void = 0 which, for a poset, would clearly be the "initial" object
09:22:01 <quicksilver> well of course ;)
09:22:11 <quicksilver> but X -> Void doesn't have a unique inhabitant
09:22:13 <ddarius> vixey: You couldn't implement it in a total language though.
09:22:14 <quicksilver> (it has no inhabitants)
09:22:17 <ski_> (Saizan : i thought we were ignoring partial values, here ..)
09:22:58 <lilac> Saizan: Void -> X in Haskell is comparable to 1 -> (X + 1) in a total language, no?
09:23:16 <vixey> um..
09:23:18 <Saizan> (ski_: that would make more sense, but i didn't think so)
09:23:22 <quicksilver> I don't think talking about inhabitants of types is very interesting in a partial language
09:23:30 <vixey> I don't think you can compare  T in total with (T + 1) in haskell
09:23:34 <quicksilver> but you may find other things interesting :)
09:23:42 <vixey> that CPO stuff about _|_ is all lost in translation
09:23:54 <Saizan> yeah, what vixey said
09:24:08 <quicksilver> for me the word 'inhabitant' is all about a total semantics
09:24:10 <Saizan> also you can't pattern match on Right undefined in haskell :)
09:24:52 <lilac> Partiality is basically just Maybe without the ability to pattern match on Nothing
09:25:08 <quicksilver> or observe 'Nothing' in any way at all.
09:25:11 <lilac> indeed
09:25:15 <gwern> anyone here familiar with 'xml'? I'm looking at http://hackage.haskell.org/packages/archive/xml/1.3.3/doc/html/Text-XML-Light-Proc.html and it's unclear to me - given a stream which contains '<created_as original_name='./New resource.txt'>...</created_as>', how can I filter it and everything it contains out of my [Element] stream?
09:25:20 <lilac> you pretty much get a Monad instance
09:25:36 <quicksilver> @go monads for partiality
09:25:46 <lambdabot> http://www.informatik.uni-bonn.de/~ralf/WG2.8/22/slides/tarmo.pdf
09:25:46 <lambdabot> Title: Partiality is an Effect
09:26:00 <lilac> Hooray
09:26:01 <gwern> the filterChildren functions are almost right, but the sig is wrong - Element -> [Element], when I need [Element -> [Element]
09:26:14 * lilac 's functional language will have a partiality monad :)
09:26:37 <lilac> gwern: mismatched []s
09:26:38 <Saizan> Agda beat you to that :)
09:26:54 <ehird> ?
09:26:58 * vixey wonders if partiality is the same as computation
09:27:06 <lilac> Saizan: indeed, but what's wrong with reinventing the wheel? :)
09:27:14 <vixey> I use data Computation a = Now a | Later (Computation a) in Haskell
09:27:18 <mattam> vixey: you can only treat nontermination by using a coinductive type.
09:27:26 <gwern> lilac: pardon?
09:27:32 <mattam> vixey: same stuff.
09:27:41 <vixey> yeah it has to be coinductive
09:27:52 <mattam> It's (not) codata really.
09:27:58 <mattam> :)
09:28:02 <vixey> what do you mean with (not)?
09:28:03 <lilac> gwern: your last line had three '[' but two ']', rendering your meaning quite ambiguous :)
09:28:15 <gwern> lilac: har har
09:28:43 <mattam> Well, we don't really know how to handle coinductives yet...
09:29:04 <mattam> I mean in Type Theory
09:29:06 <vixey> hm.. I thought other people than me know about it :p
09:29:18 <lilac> gwern: [Element -> Element], [Element -> [Element]] and [Element] -> [Element] are all one typo away.
09:30:50 <ddarius> vixey: Partiality is just the Maybe monad.
09:30:52 <Saizan> gwern: why do you need [Element] -> [Element] ?
09:31:00 <ehird> @hoogle [a -> a] -> a -> a
09:31:00 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
09:31:00 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
09:31:00 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
09:31:05 <cknapp> @t punctuate
09:31:06 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
09:31:24 <ziman> :t punctuate
09:31:27 <lambdabot> Doc -> [Doc] -> [Doc]
09:31:34 <cknapp> Ah...
09:32:25 <vixey> mattam, I think I understood NbE almost :)
09:32:51 <gwern> Saizan: my issue is that for the darcs backend for gitit, I use the hashs as unique IDs for patches/edits. to get the hashs, I parse the output of 'darcs changes --xmloutput', but the bastard output gives me *two* 'patch' types with the same hash! so then the identical hashs later get passed to 'darcs diff' whose --match options refuse to diff the same patch against itself
09:32:58 <vixey> but it seems like NbE is slighty different to what an actual implementation would be
09:33:11 <gwern> so I need to filter out the unwanted doubled patch entry
09:33:28 <gwern> which comes wrapped in 'created_as', fortunately
09:33:57 <lilac> gwern: filter ((/="created_as").qName.elName) ?
09:33:57 <rwbarton> gwern: Isn't that entire '<created_as original_name='./New resource.txt'>...</created_as>' a single Element?
09:33:59 <Saizan> so you can detect which one you've to exclude just by looking at it?
09:34:00 <gwern> I *could* probably just call 'head' but I'm not sure the created_as entry is guaranteed to be the first entry in the xml output
09:34:18 <Saizan> you just have to return [] when you get that
09:34:28 <Saizan> and return [x] for any other child x
09:34:39 <gwern> I only just started using xml today so I don't really understand it
09:34:52 <vixey> gwern by why XML?
09:34:57 <Saizan> (return is not the monad method in there)
09:35:16 <gwern> vixey: why? it's the only way to get the hash from darcs
09:35:20 <Saizan> gwern: filterChildren works like the list monad
09:35:25 <newbie> ciao
09:35:36 <newbie> !list
09:36:00 <newbie> ciao
09:36:23 <vixey> newbie, what did you want a list of?
09:36:34 <ehird> vixey: DCC files.
09:36:42 <rwbarton> vixey: fibonacci numbers perhaps :)
09:36:43 <ehird> Just ignore them.
09:37:07 <vixey> @oies 1 1 2 3
09:37:08 <lambdabot>  Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
09:37:08 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
09:37:10 <quicksilver> (1) LINDA_LOVELACE.MP4 (74678421)
09:37:35 <ehird> (2) FISH.HS
09:37:53 <gwern>  /msg ehird xdcc send 2
09:38:15 <lilac> > fix $ (0 :) . (1 :) . (zipWith (+) =<< tail)
09:38:17 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
09:38:19 <ehird> dcc send sirikindlywishtocrashyourrouter
09:38:37 <gwern> ehird: better watch out there, freenode auto-klines for 2 weeks for that
09:38:47 <ehird> oops :)
09:41:56 <dlocpuwons> Hey, I have a hopefully pretty basic question about writing a simple selection sort
09:42:44 <gwern> selection sort? whoa now don't get all computer sciency on us
09:42:50 <gwern> we're just simple folks here in #haskell
09:42:55 <cknapp> Is there a functio that filters a list and separates it into a Pair? eg. filterOut odd [1,2,3,4] = ([1,3],[2,4])
09:42:55 <dlocpuwons> haha
09:43:03 <gwern> we don't hold with that sort of academic stuff
09:43:06 <ddarius> :t partition
09:43:07 <rwbarton> > partition odd [1,2,3,4]
09:43:07 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
09:43:09 <lambdabot>   ([1,3],[2,4])
09:43:09 <cknapp> gwern: hahaha. We only talk about Abstract Algbera and category theory...
09:43:11 <cknapp> Oh..
09:43:13 <cknapp> Thanks
09:43:15 <Olathe> @hoogle (a -> Bool) -> [a] -> ([a], [a])
09:43:15 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
09:43:15 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
09:43:15 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
09:43:25 <cknapp> Oh...
09:43:26 <gwern> cknapp: the salt o' the earth!
09:43:36 <cknapp> I'll remember that; thanks Olathe.
09:43:39 <dlocpuwons> I'm just starting to learn haskell and I thought it might be a good thing to look at
09:43:42 <BMeph> cknapp: Obviously from above, the answer is "Yes." I hope that answers your question. ;)
09:43:45 <Olathe> Hoogle++
09:43:51 <vixey> so I figure bidirectional typechecking gives you a really good setup for type directed programming
09:44:09 <vixey> checkable terms = holes that need filled in
09:44:13 <cknapp> I knew it existed, but I wasn't quite sure what it was.
09:44:35 <BMeph> dlocpuwons: So, what's your question? :)
09:45:25 <ddarius> cknapp: Hoogle would have told you.
09:45:29 <Olathe> @djinn (a -> Bool) -> [a] -> ([a], [a])
09:45:29 <lambdabot> Error: Undefined type []
09:45:33 <cknapp> I know that now. :D
09:45:34 <Olathe> Lies !
09:45:48 <lilac> Olathe: djinn doesn't do recursive types AIUI
09:45:53 <Olathe> @djinn (a -> Bool) -> a -> Maybe a
09:45:53 <lambdabot> f a b =
09:45:53 <lambdabot>     case a b of
09:45:53 <lambdabot>     False -> Nothing
09:45:53 <lambdabot>     True -> Just b
09:46:05 <dlocpuwons> So I've been looking at list comprehensions and trying to make it work but I can't seem to hack it together. I'm trying to use the minimum function to always just return the smallest value, and then pass what's left to call minimum again, and build up the sorted list like that
09:46:23 <quicksilver> dlocpuwons: the problem is that minimum doesn't really help you find what's left.
09:46:32 <quicksilver> dlocpuwons: you might find \\ helpful in that regard, though
09:46:41 <quicksilver> > [2,1,3,4,1,5] \\ [1]
09:46:43 <lambdabot>   [2,3,4,1,5]
09:46:45 <cknapp> :t \\
09:46:46 <lambdabot> parse error on input `\\'
09:46:46 <BMeph> > @djinn (a -> Bool) -> a -> Either a a
09:46:48 <lambdabot>   <no location info>: parse error on input `@'
09:46:51 <Olathe> @src (\\)
09:46:51 <lambdabot> (\\) = foldl (flip delete)
09:46:52 <cknapp> :t (\\)
09:46:53 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
09:46:59 <BMeph> @djinn (a -> Bool) -> a -> Either a a
09:46:59 <lambdabot> f a b =
09:46:59 <lambdabot>     case a b of
09:46:59 <lambdabot>     False -> Left b
09:46:59 <lambdabot>     True -> Right b
09:47:05 <quicksilver> that's not going to be very efficient but you may not be too worried about that.
09:48:03 <Olathe> Hmm...
09:48:04 <dlocpuwons> ok let me try that...
09:48:31 <lilac> > uncurry (++) . fmap tail $ break (==1) [2,4,1,2,1,5,3]
09:48:33 <lambdabot>   [2,4,2,1,5,3]
09:49:28 <Voltaplein> HI again, Still trying to learn Haskell.  In http://pastebin.com/d51e3f002, I want to display my data map after the insert, delete and insertwith functions.  How can I best do that?
09:49:34 <dlocpuwons> cool, thanks!
09:49:46 <PeakerWork> > break (==1) [2,4,1,5]
09:49:47 <lambdabot>   ([2,4],[1,5])
09:49:59 <PeakerWork> why not splitAtBy? :)
09:50:06 <PeakerWork> or splitBy?
09:50:12 <PeakerWork> @hoogle splitBy
09:50:12 <lambdabot> No results found
09:50:21 <PeakerWork> (consistency with splitAt)
09:52:23 <rwbarton> Voltaplein: In a pure function, there is not really a notion of "after".
09:52:38 <rwbarton> Voltaplein: However, you might like something like this:   import Debug.Trace; traceValue x = trace (show x) x
09:52:51 <rwbarton> Voltaplein: and then insert calls to traceValue around values you want to display
09:54:16 <dpratt71> I'm sorry, I just have to ask: What's with the Lambdabot logo?
09:54:32 <dons> it was a competitoin
09:54:34 <dpratt71> she has a halo and she's...drooling?
09:54:39 <dons> since she's so busy
09:54:47 <Voltaplein> rwbarton thx. will try that
09:55:19 <dpratt71> huh
09:56:42 <Olathe> > let takeOutBy f xs@(x:_) = g x xs where g best [] = (best, []); g best (x:xs) = (y, if x == y then ys else (x:ys)) where (y, ys) = g (f best x) xs in takeOutBy min [4,3,2,5,1]
09:56:43 <lambdabot>   (1,[4,3,2,5])
09:56:52 <Olathe> > let takeOutBy f xs@(x:_) = g x xs where g best [] = (best, []); g best (x:xs) = (y, if x == y then ys else (x:ys)) where (y, ys) = g (f best x) xs in takeOutBy min [4,3,2,0,5,1]
09:56:53 <lambdabot>   (0,[4,3,2,5,1])
09:57:19 <Olathe> > let takeOutBy f xs@(x:_) = g x xs where g best [] = (best, []); g best (x:xs) = (y, if x == y then ys else (x:ys)) where (y, ys) = g (f best x) xs in takeOutBy min [4,3,2,0,5,0,1]
09:57:20 <lambdabot>   (0,[4,3,2,5,1])
09:57:23 <Olathe> Hmm...
09:57:35 <Olathe> Maybe needs a modification.
09:58:52 <gwern> argh. I need a better testing setup
09:59:11 <gwern> it took me this long to figure out that  'let patches = filter ((≠ "created_as") · qName · elName) duppatches ' doesn't work
10:03:01 <dons> ?users
10:03:01 <lambdabot> Maximum users seen in #haskell: 630, currently: 618 (98.1%), active: 23 (3.7%)
10:03:35 <vixey> gwern, how do you type ≠, if you don't mind me asking
10:03:53 <gwern>  /=
10:04:06 <ddarius> You press the ≠ key.
10:04:08 <vixey> and Liskah or whatever converts it automatically?
10:04:11 <dons> hehe
10:04:11 <gwern> (let's use xml, john sez. it'll be easy, he sez. it'll be more reliable...)
10:04:20 <gwern> vixey: yi, specifically
10:04:25 <vixey> ok
10:04:27 <ddarius> dons: How'd the interview go?  I'll probably listen to it this afternoon.
10:04:31 <Voltaplein> rwbarton: OK not getting too far with this trace thing.  Could you have a look at my pastebin and show me how you would display the variable "table" after modification by one of the Map.xxx frunctions?
10:05:19 <dons> ddarius: pretty good. 15 mins is fast. the 60 second mini-interview is later today sometime
10:06:32 <ddarius> dons: Cool.
10:06:36 * ddarius heads back to work.
10:06:49 <Olathe> > let takeOutBy f xs@(x:_) = (\(_, min, ys) -> (min, ys)) $ g x xs where g best [] = (True, best, []); g best (x:xs) = if still && x == y then (False, y, ys) else (still, y, (x:ys)) where (still, y, ys) = g (f best x) xs in takeOutBy min [4,3,0,2,0,5,1]
10:06:51 <lambdabot>   (0,[4,3,0,2,5,1])
10:07:08 <Olathe> > let takeOutBy f xs@(x:_) = (\(_, min, ys) -> (min, ys)) $ g x xs where g best [] = (True, best, []); g best (x:xs) = if still && x == y then (False, y, ys) else (still, y, (x:ys)) where (still, y, ys) = g (f best x) xs in takeOutBy max [4,3,0,5,2,0,5,1]
10:07:09 <cknapp> Olathe: wouldn't that be easier in GHCi?
10:07:10 <lambdabot>   (5,[4,3,0,5,2,0,1])
10:10:21 <bauchus> hello. any Network.CGI expert here?
10:10:59 <pumpkin_> "The xmonad window manager is about 500 lines of code."
10:11:01 <pumpkin_> ???
10:11:08 <pumpkin_> (from http://cdsmith.wordpress.com/2007/07/29/37-reasons-to-love-haskell-playing-off-the-ruby-article/)
10:11:09 <Deewiant> > takeOutBy (==) [True,False,True,False]
10:11:10 <lambdabot>   (True,[True,False,False])
10:11:36 <gwern> whoo, my darcs backend is now down to 3 failures on the testcases
10:11:46 <gwern> (only 2 of them likely my fault)
10:14:04 <athos> pumpkin_:
10:14:05 <athos> 27.7.2007
10:14:08 <pumpkin_> yeah, I know
10:14:17 <Olathe> > takeOutBy (==) [False, False, False]
10:14:18 <pumpkin_> but how much has it changed? that seems tiny
10:14:18 <lambdabot>   (True,[False,False,False])
10:14:20 <athos> and it *was* about 500 LoC
10:14:21 <Olathe> Heh
10:16:55 <vixey> :t takeOutBy
10:16:57 <lambdabot> forall a. (Eq a) => (a -> a -> a) -> [a] -> (a, [a])
10:18:23 <Raevel> okay, this is obviously wrong, but doesn't lambdabot allow something similar?
10:18:27 <Raevel> @src [] (>)
10:18:27 <lambdabot> Source not found. You type like i drive.
10:18:58 <pumpkin_> @src [] compare
10:18:58 <lambdabot> Source not found. Just what do you think you're doing Dave?
10:19:13 <gnuvince_> :t foldM
10:19:15 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
10:19:27 <gnuvince_> :t filterM
10:19:28 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
10:21:13 * wli would expect something like takeOutBy :: Ord metric => (t -> t -> metric) -> [t] -> (t, [t])
10:22:30 <Toxaris> > takeOutBy f [a, b, c] -- whats the point?
10:22:32 <lambdabot>   (f (f (f a a) b) c,[a,b,c])
10:22:39 <athos> byorgey: heya :)
10:23:25 <athos> byorgey: nice post about monads..which made me wondering if you have written an own tutorial on monads yet?
10:26:03 * wli thinks someone should write a tutorial on writing monadic monad tutorial authoring combinator libraries.
10:28:55 <newsham> hmm.. monad tutorial combinators.
10:29:07 <lament> someone should write a tutorial on writing itself.
10:29:15 <wli> There's a canonical projection from tutorials on writing monadic monad tutorial authoring combinator libraries and writing monad tutorials. ;)
10:29:20 <ehird> lament:
10:29:32 <cknapp> Or... someone should write a monad tutorial writing program!
10:29:44 <cknapp> It would save so much time...
10:29:47 <lament> ehird:
10:30:13 <newsham> gentleIntroduction `mix` monadsAsContainers
10:30:23 <cknapp> haha
10:30:23 <wli> cknapp: You could just keep randomly generating more monad tutorials until one comes up that works for you. ;)
10:30:29 <ehird> To write this tutorial, write "To write this tutorial, write ", followed by the same in double quotes, followed by ", followed by the same in double quotes, followed by ", followed by the same in double quotes, ...
10:30:51 <lament> :D
10:30:58 <wli> ehird: Eventually you'll have to quine it.
10:31:02 <dcoutts_> it's like a factory factory factory
10:31:05 <ehird> wli: no duh :D
10:31:08 <lament> Just Quine It (tm)
10:31:22 <ehird> dcoutts_: http://ws.apache.org/xmlrpc/apidocs/org/apache/xmlrpc/server/RequestProcessorFactoryFactory.html?rel=html
10:31:25 <lament> ehird: ok, now make it about monads!
10:31:28 <dcoutts_> ehird: yep :-)
10:31:34 <int80_h> okay now y'all are just being silly
10:31:34 <proq> yes, that's right.  read byorgey's blog and start over!
10:31:41 <dcoutts_> ehird: reminds me slightly of partial evaluators, mix (mix mix)
10:31:50 <vixey> What is the name of this book?
10:31:52 <ehird> To understand monads, write this tutorial. To write this tutorial, ...
10:32:05 <ehird> wait no
10:32:07 <cknapp> int80_h: We weren't fromt he beginning?
10:32:17 <wli> module Epimenides where ...
10:32:19 <cknapp> from the*
10:32:28 <ehird> To understand monads, follow the instructions in this tutorial. First, write this tutorial down. Then, follow the instructions in the written-down tutorial. To write this tutorial, ...
10:32:57 <lament> now we're getting somewhere
10:33:18 <lament> a gentle introduction to gentle introductions
10:33:43 <lament> or: the haskell report report report report report ...
10:34:04 <proq> if you need a gentle introduction to a gentle introduction, something is wrong
10:34:21 <cknapp> proq: have you *read* A gentle introduction?
10:34:24 <lament> the gentle introduction could actually use a gentle introduction, so something probably is wrong
10:34:24 <int80_h> a gentle introduction on how to write gentle introductions.
10:34:26 <proq> cknapp: yes
10:34:40 <newsham> file under "if you have to call it `gentle' it probably isn't"
10:34:50 <lament> "this won't hurt a bit"
10:34:58 <int80_h> maybe the author has a wicked appreciation of irony?
10:35:05 <cknapp> Perhaps it hurt him more than it hurt us?
10:35:16 <lament> us, collectively?
10:35:23 <newsham> honest joe's cars and joe's quality steaks
10:35:24 <cknapp> On average...
10:35:39 <proq> e.g. it isn't gentle enough
10:35:41 <wli> For any topic X, any mapping from topic X to topic Y maps gentle introductions to X to gentle introductions to Y, there's a gentle introduction to X and a canonical projection from gentle introductions to gentle introductions to X to gentle introductions to X.
10:35:43 <dpratt71> my (admittedly brief) experience is: To understand Monads, ask Cale...
10:35:45 <cknapp> newsham: what's that a reference to?
10:36:01 <newsham> cknapp: if you have to call it "honest" "quality" or "gentle" it probably aint
10:36:03 <dpratt71> ...he won't give up until you "get it"
10:36:05 <cknapp> wli: Oh, dear...
10:36:33 <newsham> wli's gentle introduction to the gentle introduction to haskell
10:37:02 <cknapp> I was talking about "honest joe..."
10:37:14 <cknapp> Ah...
10:37:17 <cknapp> getting names confused
10:37:29 <lament> wli: now consider the topic of gentle introductions....
10:37:42 <dpratt71> 'course Cale may be a "she" for all I know
10:37:44 * cknapp has a malfunctioning brain. >reboot
10:37:48 <wli> lament: Some diagram is bound to commute.
10:38:03 <int80_h> I'm going to go out on a limb and say Cale is male.
10:38:22 <dpratt71> it rhymes, at least
10:38:28 <int80_h> I have statistics on my side in tyhis guesswork.
10:38:31 <lilac> > (\(x,y,_) -> (x,y [])) . (\s -> foldl' (\(y, n, f) x -> if x < y then (x, f, f.(x:)) else (y, n.(x:), f.(x:))) (head s, id, (head s:)) (tail s)) $ "Hello world"
10:38:31 <cknapp> Then it must be so!
10:38:33 <lambdabot>   (' ',"Helloworld")
10:38:53 <cknapp> lilac: why?!?!?
10:38:59 <rwbarton> @quote hour
10:39:00 <lambdabot> jamesbritt says: Writing Haskell, for example, involves an hour of meditation followed by the emission of a fold expression.
10:39:44 <lilac> cknapp: why not?
10:39:57 <int80_h> lilac wins the obfuscated haskell contest
10:39:58 <lilac> cknapp: wrote that a while ago then got distracted before trying it
10:40:02 <cknapp> Brain...
10:40:29 <cknapp> int80_h: there are better haskell obfuscations... Ones which make significant use of monads...
10:40:36 <lilac> @let extractMin = (\(x,y,_) -> (x,y [])) . (\s -> foldl' (\(y, n, f) x -> if x < y then (x, f, f.(x:)) else (y, n.(x:), f.(x:))) (head s, id, (head s:)) (tail s))
10:40:38 <lambdabot>  Defined.
10:40:39 <lilac> @type extractMin
10:40:41 <lambdabot> forall a. (Ord a) => [a] -> (a, [a])
10:41:59 <lilac> > unfoldr (\xs -> if null xs then Nothing else Just (extractMin xs)) "Hello world"
10:42:01 <lambdabot>   " Hdellloorw"
10:42:23 <lilac> possibly the worst sorting algorithm ever.
10:42:47 <cknapp>  At least it works?
10:43:17 <rwbarton> , let isSorted xs = and $ zipWith (<=) xs (tail xs) in filter isSorted $ permutations [1,5,2,4,3]
10:43:24 <lunabot>  [[1,2,3,4,5]]
10:43:33 <ehird> damn that was slow
10:44:20 <Olathe> , let isSorted xs = and $ zipWith (<=) xs (tail xs) in head.filter isSorted $ permutations [1,5,2,4,3]
10:44:21 <lunabot>  [1,2,3,4,5]
10:44:48 <Olathe> > permutations [1, 1]
10:44:50 <lambdabot>   Not in scope: `permutations'
10:44:54 <Olathe> , permutations [1, 1]
10:44:56 <lunabot>  [[1,1],[1,1]]
10:48:17 <Toxaris> slowsort: to sort a list of values with slowsort, create all permutations, sort by their sortedness with slowsort, and return the most-sorted
10:48:51 * wli realizes that takeOutBy was intended for use in a selection sort.
10:49:03 <vixey> Toxaris, I can't decide if that diverges or not
10:49:10 <cknapp> I think it diverges...
10:49:26 <cknapp> You're calling it on an ever-growing list
10:49:38 <vixey> aha
10:49:38 <cknapp> Rather, each call is on a longer list
10:49:46 <vixey> how to rectify that?
10:49:55 <cknapp> Don't use slowsort?
10:50:01 <vixey> (but keep the spirit of the algorithm)
10:50:09 <Toxaris> would be nice if it would be arbitrary slow, but terminating
10:50:28 <Toxaris> e.g. complexity n ^ n ^ n ^ n ... ^ n with n ns
10:51:01 <cknapp> Could you use a heuristic to ignore most of the (obviously not going to win) permutations?
10:51:39 <elbar> @hoogle permut
10:51:39 <lambdabot> package permutation
10:51:39 <lambdabot> System.Console.GetOpt Permute :: ArgOrder a
10:51:39 <lambdabot> Text.Parsec.Perm permute :: Stream s Identity tok => StreamPermParser s st a -> Parsec s st a
10:52:31 * rwbarton wants a sorting algorithm whose termination cannot be proved by Peano arithmetic
10:52:49 <cknapp> One that needs transfinite induction to prove?
10:53:11 * cknapp likes the way rwbarton thinks
10:54:31 <vixey> @go hydra battle transfinite
10:54:46 <cknapp> There's something horribly wrong with the discussions we have on this channel...
10:54:54 <vixey> well, You couldn't prove termination of ReadP without transfinite induction could you?
10:54:59 <lambdabot> Plugin `search' failed with: thread killed
10:55:36 <cknapp> I don't actually know what REadP is...
10:55:50 <cknapp> /s/E/e
10:56:12 <vixey>   Look f     `mplus` Look g     = Look (\s -> f s `mplus` g s)
10:56:18 <vixey> it uses that kind of recursion
10:56:53 <cknapp> Ah...
10:57:07 <cknapp> I'm not sure... Not a recursion theorist. :)
10:59:35 <vixey> maybe it doesn't take transfinite induction, because s :: String rather than s :: ReadP
11:00:01 <cknapp> That would make sense... maybe (I don't know)
11:05:00 <gwern> 'hists ←  darcsLog repo [] (TimeRange Nothing Nothing) \n let hist = filter (λx →  revId x == hash) hist'
11:05:03 <gwern> ^^ d'oh!
11:06:20 <gwern> sometimes I wish ghc would tell me when I accidentally write bottom
11:08:53 <cknapp> gwern: Isn't there a compiler option for that... There's one for everything else you could possibly want it to do...
11:09:04 <dpratt71> I just googled "transfinite induction"...
11:09:13 <gwern> not one I've ever heard of
11:09:25 <dpratt71> ...it amazes me that so few words can produce so much confusion
11:09:29 <pumpkin_> lol
11:09:39 <cknapp> dpratt71: I'm sorry; you should have taken the *red* pill
11:09:52 <pumpkin_> Zygohistomorphic prepromorphisms
11:10:12 <cknapp> pumpik_: is that bio-something?
11:10:18 <dpratt71> cknapp: now I'll never know
11:10:42 <Lemmih> gwern: GHC could tell you that the first 'hists' was never used.
11:10:55 <cknapp> transfinite induction isn't to bad... it's *using* it that gets confusing.
11:11:04 <pumpkin_> cknapp: http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
11:11:37 <cknapp> That's disgsuting.
11:11:40 <pumpkin> :P
11:11:45 <cknapp> And... incredible.
11:11:54 <cknapp> Things like that are why I like this language...
11:11:57 <hydo> whew.... I think I'll finish congealing monads in my head before I attempt Zygocrazyshit Brainblenders...
11:12:11 <pumpkin> I still think we need a hydomorphism
11:12:18 <hydo> seconded.
11:13:11 <dpratt71> is it saying that if x + 1 having some "property" means that x also has that property, then all "x" has that property?
11:13:57 <gwern> Lemmih: I guess so. pity my file is so littered with unused things
11:14:06 <dpratt71> forgive my very non-math-ish notation
11:14:13 <vixey> dpratt71: You know induction like  P(0) and (P(n) --> P(n+1)) ---> forall n, P(n) ?
11:14:22 <cknapp> dpratt71: Assuming you have a base case somewhere; yes
11:14:38 <vixey> transfinite just adds another case
11:15:04 <lilac> is transfinite induction just a special case of well-ordered induction?
11:15:09 <Olathe> You prove that if x has the property, then x + 1 also has it.
11:15:10 <vixey> instead of dealing with data Nat = Zero | Succ Nat, you are doing induction on data Ordinal = Zero | Succ Ordinal | Limit (Ordinal -> Ordinal)
11:15:20 <opqdonut> lilac: er, I think those are the same
11:15:33 <opqdonut> lilac: transfinite induction is induction over an ordinal
11:15:38 <vixey> lilac, I think that every Ordinal is isomorphic to a well ordering, so they should really be equivalent (but this might be baloney)
11:15:41 <opqdonut> which is also a well-ordering
11:15:52 <lilac> vixey: that sounds familiar
11:16:19 <cknapp> lilac: I think vixey is correct.
11:16:21 <vixey> I really don't know what goes on after infinite very well :)
11:16:33 <pumpkin> after infinite, your head explodes
11:16:36 <cknapp> After which infinite?
11:16:42 <opqdonut> ;)
11:16:44 <Maddas> vixey: More of the same :-)
11:16:45 <eu-prleu-peupeu> hello
11:16:47 <_dolio> The first one.
11:16:49 <eu-prleu-peupeu> haskl3z0rs
11:16:53 <lilac> vixey: after infinity, mathematicians make stuff up to keep the set theory consistent
11:16:58 <vixey> I read about Mahlo cardinals too
11:17:07 <vixey> lol lilac
11:17:10 <cknapp> lilac: that's called "discovering theorems"
11:17:14 <cknapp> :)
11:17:28 <lilac> cknapp: heh :)
11:18:10 <pumpkin> eu-prleu-peupeu: hey, how's it going 3u-pr13u-p3up3u
11:18:14 <lilac> cknapp: had the axioms been different, the theorems about transfinite stuff would be too; it's interesting stuff, but it's not necessarily concrete in the way the naturals are
11:18:27 <pumpkin> eu-prleu-peupeu: it's called haskell btw, not haskle :)
11:18:48 <peachi> does anyone know of any sites that have some graph algorithms implemented in haskell?
11:18:52 <lilac> pumpkin: it got renamed to hasklez while you were away
11:18:53 <vixey> this proof theory stuff is really incredible but very difficult.
11:19:02 <pumpkin> lilac: !
11:19:11 <pumpkin> peachi: there are a couple of hackage packages with graph stuff
11:19:15 <pumpkin> fgl, Data.Graph
11:19:32 <eu-prleu-peupeu> :D
11:19:36 <eu-prleu-peupeu> thanks pumpkin
11:19:56 <peachi> can I ask what some of the most common graph algorithms are?
11:20:08 <pumpkin> DFS/BFS, diameter, shortest path?
11:20:11 <pumpkin> stuff like that?
11:20:26 <lilac> topological sort, connected components, dijkstra
11:20:33 <peachi> basically I just started learning haskell and we got introduced to graphs today and they seem really cool so i wondered if anyone knew of a site or two that discussed/exained/implemented some
11:20:35 <lilac> (added to pumpkin's list)
11:20:36 <pumpkin> that too :P
11:20:43 <pumpkin> probably above diameter :P
11:20:51 <lilac> subset cover? :)
11:20:57 <cknapp> peachi: ah...  You're entering a whole new world. :)
11:21:03 <rwbarton> dijkstra, dijkstra, dijkstra, matching :)
11:21:04 <peachi> can any of those be implemented in only 5 to 10 lines?
11:21:07 <dolio> Minimum spanning tree.
11:21:13 <rwbarton> dolio: See dijkstra :)
11:21:18 <dolio> Yeah, yeah.
11:21:19 <peachi> i want some smallish ones to do
11:21:22 <dolio> :)
11:21:24 <cknapp> pechi: DFS, BFS, toposort...
11:21:25 <peachi> rwbarton, we did that today already
11:21:33 <peachi> cknapp, they are small-ish?
11:21:35 <pumpkin> peachi: you should take graph theory!
11:21:42 <peachi> dijkstra = really cool :)
11:21:43 <cknapp> Yes! Take Graph Theory!
11:21:43 <pumpkin> I can show you the world
11:21:44 <lilac> peachi: longest path?
11:21:51 <cknapp> lilac: Ah!!!!
11:22:19 <cknapp> lognest path algorithms make me sad. :'(
11:22:26 <cknapp> longest*
11:22:28 <peachi> so DFS, BFS, longest path, shortest path are some ones to google then?
11:22:39 <mux> A* !
11:22:52 <cknapp> A* isn't exactly a "one liner"
11:23:09 <pumpkin> longest path in a graph with cycles
11:23:10 <rwbarton> I guess my list does need to have DFS on it somewhere
11:23:15 <mux> I missed the part where people were talking about one liner then
11:23:16 <pumpkin> you can implement that in one line
11:23:20 <vixey> Cale wrote up A* I think it's on hackage
11:23:24 <cknapp> not one-liner, but short
11:23:30 <lilac> peachi: look for a good solution to vertex cover, chromatic number, hamiltonian path or subgraph isomorphism ;-)
11:23:36 <cknapp> hahahahahha
11:23:38 <mux> I don't expect A* to be big in haskell though
11:23:55 <pumpkin> clique search
11:23:55 <pumpkin> :P
11:24:04 <cknapp> But he's just learning graphs and just learning haskell...
11:24:08 <dolio> A* is like a 10-liner.
11:24:17 <peachi> well, my haskell is actually relatively good now to be fair
11:24:24 <lilac> cknapp: sounds like the perfect time to prove P == NP to me
11:24:25 <cknapp> Ah.
11:24:31 <pumpkin> http://search.cpan.org/src/EWIJAYA/Graph-Clique-0.02/README
11:24:37 <cknapp> Well, then you may give A* a try...
11:24:38 <dolio> As long as you already have a priority queue and stuff.
11:24:43 <cknapp> lilac: of course!
11:24:49 <cknapp> Any time is a good time!
11:24:59 <gwern> instead of debating A* just look at the hackage package and answer the question already
11:25:05 <pumpkin> omg erikc is being really prolific with his file formats! <3
11:25:05 <peachi> my tutor said that there's a graph algorithm that seems quite hard but can be written in 5 or so lines and that i should try and find that one to look at
11:25:13 <peachi> but i have no idea what she's referring to
11:25:27 <pumpkin> peachi: you could probably describe quite a few of them like that :P
11:25:38 <peachi> heh
11:25:46 <peachi> she said it was to do with DAGs?
11:25:55 <peachi> i think that's directed acyclical graphs?
11:25:56 <pumpkin> finding SCCs is pretty elegant, but looks scary if you don't know how to at first
11:26:06 <pumpkin> yeah
11:26:23 <lilac> peachi: in a weighted graph (with negative weights), find the path (with no repeated nodes) which has the maximum sum
11:26:25 * gwern contemplates suicide. this code shelling out to darcs looks perfect but it just doesn't work!
11:26:39 <cknapp> lilac: http://geomblog.blogspot.com/2004/04/meta-proof.html
11:26:39 <vixey> pumpkin, how?
11:26:42 <pumpkin> gwern: don't commit suicide!
11:26:46 <pumpkin> vixey: how what?
11:26:53 <vixey> do you compute SCCs
11:26:54 <lilac> cknapp: is that the 'nature can do it' one?
11:27:01 <cknapp> No...
11:27:10 <gwern> despair! despair! this world of IO has left me in despair!
11:27:12 <peachi> http://en.wikipedia.org/wiki/Category:Graph_algorithms
11:27:14 * gwern goes and hangs self
11:27:17 <peachi> suppose I should look through here heh
11:27:23 <cknapp> likely
11:27:34 <peachi> loads of the examples are really procedural though
11:27:43 <peachi> and now i am in love with functional programming hehe
11:28:18 <pumpkin> vixey: the one where you deal with the graph and its transpose (can't remember what it's called) is pretty simple and elegant (and not too bad performance wise)
11:28:19 <cknapp> peachi: everyone who get's bpast the "wtf is this?" does. :)
11:28:28 <peachi> when we first started haskell I thought I was going to hate it and that it would annoying
11:28:32 <vixey> what's the transpose of a graph?
11:28:33 <peachi> but now I absolutely love it heh
11:28:36 <peachi> :)
11:28:45 <pumpkin> vixey: graph with all the edges inverted?
11:28:55 <vixey> don't ask me
11:29:01 <vixey> I am interested in this algorithm you mentioned
11:29:10 <vixey> I  don't know it
11:29:19 <pumpkin> let me look it up
11:29:32 <pumpkin> it's basically a DFS on original and on transpose
11:29:44 <cknapp> ?
11:29:48 <pumpkin> http://en.wikipedia.org/wiki/Kosaraju%27s_algorithm
11:29:49 <cknapp> Sounds fun
11:30:02 <vixey> thanks
11:30:06 <pumpkin> there are apparently better ones though
11:30:10 <lilac> pumpkin: transpose sounds plausible. it's the transpose of the edge matrix
11:30:15 <dolio> Wikipedia says no one uses that because it requires two depth first searches. :)
11:30:16 <cknapp> Oh... that is obvious enough, I guess
11:30:17 <pumpkin> lilac: yeah
11:30:30 <lilac> pumpkin: my first thought was that you meant dual, but that's something else.
11:30:40 <pumpkin> but there's an implementation of tarjan on hackage though
11:31:02 <pumpkin> lilac: what would that be? I know the complement of a graph
11:31:03 * vixey has got to implement this now :)
11:31:21 <pumpkin> vixey: also, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/GraphSCC
11:31:34 <pumpkin> tarjan is a better algorithm, but not as elegant :P
11:33:38 <vixey> is there an algorithm that gives SCCs and a toposort simultaneously?
11:33:46 <cknapp> It's teh middle of winter in Chicago, and I'm too warm in my apartment... stupid oven...
11:33:47 <vixey> probably most of these SCC ones do..
11:34:29 <pumpkin> hmm
11:35:39 <pumpkin> vixey: that hackage package I linked to gives you the SCCs themselves in topological order, apparently
11:36:13 <pumpkin> I haven't used it myself though
11:43:09 <dmead> dons
11:43:14 <dmead> you're famous!
11:43:39 <dmead> http://software.intel.com/en-us/blogs/2009/01/13/parallel-programming-talk-haskell-guru-don-stewart/
11:43:48 <dmead> audio stream seems to be dead
11:44:04 <erikc> its available through itunes
11:46:02 <Olathe> You can get it from the link right below the streamer.
11:46:13 <Olathe> I couldn't get the streamer to work either.
11:49:50 <erikc> the stream almost blew my ear drum
11:50:17 <pumpkin> :o
11:50:25 <pumpkin> it isn't doing anything on mine :/
11:52:01 <erikc> it was super loud static on mine :)
11:52:42 <erikc> thought it was an intel trick to strike the haskell community deaf, ITS A TRAP
11:52:42 <gnuvince_> http://www.reddit.com/r/haskell/comments/7pgrz/interview_with_world_renowned_expert_dons_on/
11:52:44 <eu-prleu-peupeu> one day i'm also going to be a haskle guru!
11:53:03 <gnuvince_> ah fuck
11:53:06 <jberg> hm, so when i call functions from main which has signature main :: IO () does all the functions has to have IO () as well? And the function they're calling etc..
11:53:07 <gnuvince_> I messed the title
11:53:07 <Pellwurst> is there a haskell function, that compares to strings ignoring upper-/lower-case
11:53:09 <gnuvince_> Sorry dons :(
11:53:16 <Pellwurst> is there a haskell function, that compares two strings ignoring upper-/lower-case
11:53:25 <tromp__> :t toLower
11:53:28 <lambdabot> Char -> Char
11:53:36 <pumpkin> eu-prleu-peupeu: I thought we'd concluded it was haskell and not haskle?
11:53:42 <Olathe> > compare "A" "B"
11:53:43 <lambdabot>   LT
11:53:57 <olsner_> > ((==) `on` map toLower) "AAA" "aaa"
11:53:58 <pumpkin> > zipWith compare "ohai" "obai"
11:54:00 <lambdabot>   True
11:54:00 <lambdabot>   [EQ,GT,EQ,EQ]
11:54:06 <rwbarton> erikc: I get about 75% static and 25% people talking
11:54:09 <Olathe> @pl \f x y -> compare (f x) (f y)
11:54:09 <lambdabot> flip =<< (((.) . compare) .)
11:54:19 <Olathe> Hmm...
11:54:29 <eu-prleu-peupeu> pumpkin: im still working on it
11:55:25 <dolio> @type comparing
11:55:27 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
11:55:49 <Olathe> @hoogle String -> String -> Ordering
11:55:50 <lambdabot> Distribution.Simple.Command CommandHelp :: String -> String -> CommandParse flags
11:55:50 <lambdabot> Foreign.C.Error throwErrnoPath :: String -> FilePath -> IO a
11:55:50 <lambdabot> Data.Time.Format readTime :: ParseTime t => TimeLocale -> String -> String -> t
11:56:13 <dolio> > ((g :: Expr -> Expr -> Expr) `on` f) x y
11:56:15 <lambdabot>   g (f x) (f y)
11:56:30 <pumpkin> Olathe: compare?
11:56:46 <pumpkin> :t compare
11:56:47 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
11:56:52 <pumpkin> @instances Ord
11:56:53 <gwern> '* Ban ghc-options: --make I dunno, some people...
11:56:53 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
11:56:59 <gwern> (hee hee)
11:57:15 <pumpkin> @index Product
11:57:15 <lambdabot> bzzt
11:57:21 <pumpkin> bzzt to you
11:57:25 <Olathe> pumpkin: I was wondering if there was a compareIgnoringCase or something.
11:57:34 <dolio> gwern: What?
11:57:35 <pumpkin> Olathe: oh, no, I don't think so
11:57:44 <gwern> dolio: a recent cabal patch
11:57:50 <gwern> using --make with cabal is indeed silly
11:57:51 <dolio> Ah.
11:57:54 <dolio> Yes.
11:58:21 <pumpkin> Olathe: in a unicode system it's hard to define "compare ignoring case" nicely
11:58:44 <dolio> @type comparing toUpper
11:58:45 <pumpkin> many people approximate it by just lower/uppercasing everything then comparing
11:58:45 <lambdabot> Char -> Char -> Ordering
11:58:51 <dolio> @type comparing (map toUpper)
11:58:53 <pumpkin> but that breaks for some greek stuff
11:58:53 <lambdabot> [Char] -> [Char] -> Ordering
11:59:51 <Olathe> @type comparing
11:59:52 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
12:00:03 <Olathe> Ahh.
12:00:13 <Olathe> @src comparing
12:00:14 <lambdabot> Source not found. Maybe you made a typo?
12:01:23 <gwern> whew, down to two failing tests and no runtime error!
12:01:40 <pumpkin> gwern: this is the darcs API you're working on?
12:01:59 <gwern> pumpkin: a darcs backend for orchid/gitit
12:02:05 <pumpkin> ah cool
12:02:06 <gwern> it's been pretty hellacious
12:02:23 <gwern> if you had asked before I started how hard it'd be...
12:04:09 <pumpkin> what's painful about it?
12:04:22 <pumpkin> are you popening the darcs executable?
12:05:11 <gwern> pumpkin: it's just there's so much that needs to be written and getting every single detail right is difficult
12:05:19 <pumpkin> ah :/
12:05:28 <gwern> it's not like the darcs manual tells you how to do history operations using not patch names but hashs
12:05:49 <gwern> nor does it mention little gotchas like redundant patches in the xml output
12:07:02 <jberg> if i have str <- hGetContents file, how can i "lift" out the string from the IO monad so it can be used in a function which takes a string? Is lifting the right word here?
12:07:12 <Peaker> @type comparing fst
12:07:13 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
12:07:21 <Peaker> @type (fst ~> fst ~> id) compare
12:07:22 <pumpkin> jberg: that's already doing it
12:07:23 <lambdabot> Not in scope: `~>'
12:07:23 <lambdabot> Not in scope: `~>'
12:07:27 <Peaker> @type result
12:07:29 <lambdabot> Not in scope: `result'
12:07:29 <Olathe> jberg: Just use str.
12:07:41 <wli> select (x : xs) = foldr \z (y, ys) -> if z < y then (z, y : ys) else (y, z : ys)) (x, []) xs
12:08:12 <jberg> Olathe, i can use str without anything else? doesn't str have type IO String?
12:08:12 <Olathe> @type hGetContents
12:08:13 <lambdabot> Not in scope: `hGetContents'
12:08:20 <Olathe> jberg: Not in that do block.
12:08:27 <gwern> like 'darcsMove' turns out to be really difficult to write, since you need to check that you aren't moving outside the repo, that you've added the directory, etc.
12:08:30 <Olathe> jberg: In the do block, it's a String.
12:08:44 <pumpkin> jberg: if you'd done let str = hGetContents file, then str would've been an IO String
12:08:55 <pumpkin> but the x <- is pulling the string out :)
12:09:09 <jberg> Olathe, hm right.. i remember reading about that, can't remember where though
12:09:11 <Peaker> @let result = (<<<) ; argument = (>>>) ; infixr 2 ~> ; f ~> g = result g . argument f
12:09:14 <lambdabot>  Defined.
12:09:18 <jberg> should be in rwh, no?
12:09:19 <Peaker> @type (fst ~> fst ~> id) compare
12:09:20 <lambdabot> forall b a b1. (Ord a) => (a, b) -> (a, b1) -> Ordering
12:09:35 <Demettry> Hello every1!
12:09:46 <athos> @type (fst ~> fst)
12:09:48 <lambdabot> forall a b a1 b1. (a -> (a1, b1)) -> (a, b) -> a1
12:09:54 <Peaker> @type (fst ~> fst ~> id)
12:09:56 <lambdabot> forall a b a1 b1 d1. (a -> a1 -> d1) -> (a, b) -> (a1, b1) -> d1
12:10:03 <rwbarton> @type (~>)
12:10:04 <lambdabot> forall (a :: * -> * -> *) b c d1 d. (Arrow a) => a b c -> a d1 d -> a c d1 -> a b d
12:10:36 <Demettry> Need some help!
12:11:20 * Olathe hands Demettry some help.
12:11:48 <wli> let select (x : xs) = foldr (\z (y, ys) -> if z < y then (z, y : ys) else (y, z : ys)) (x, []) xs in unfoldr (\xs -> case xs of [] -> Nothing ; _:_ -> Just $ select xs)
12:13:20 <Demettry> I have datatype declaration
12:13:20 <Demettry> data Formula = TRUE | FALSE | (LogOp,[Formula])
12:13:20 <Demettry> But GHC doesn't like it, says parse error in data/newtype declaration
12:13:37 <Demettry> It says it on (LogOp, [Formula])
12:13:55 <Demettry> does type declaration support tuples?
12:13:59 <pumpkin> we should add haskell_proposals to redditbot :)
12:14:05 <rwbarton> Demettry: You need a data constructor in each alternative
12:14:24 <rwbarton> e.g.  data Formula = TRUE | FALSE | Application (LogOp,[Formula])
12:14:59 <Demettry> What does "Application" mean?
12:15:03 <Demettry> in this case?
12:15:12 <rwbarton> Just some name I chose, just like you chose the names TRUE and FALSE.
12:15:13 <Toxaris> Demettry: its just a name, like TRUE and FALSE
12:15:51 <FunctorSalad> I'm having trouble understanding the IArray class. why are the things in Data.Array.IArray not methods? the only official method is "bounds", though ghci also reveals some "unsafe" methods
12:16:28 <Demettry> Ok, it's just a name of constructor, right?
12:16:54 <Olathe> Yes.
12:17:06 <Demettry> Ok, great! Thanx!
12:17:24 <rwbarton> Peaker: I guess array is implemented in terms of the class methods unsafeArray and so on
12:17:28 <rwbarton> oops
12:17:30 <rwbarton> FunctorSalad: ^^
12:17:35 <FunctorSalad> I figured ;)
12:18:00 <Toxaris> Demettry: you don't need the tuple there, so you can (and probably should) just use data Formula = TRUE | FALSE | Application LogOp [Formula]
12:18:05 <pumpkin> FunctorSalad: http://www.haskell.org/ghc/docs/latest/html/libraries/array/Data-Array-IArray.html here?
12:18:13 <enticingjelly> is head normal form equivalent to beta normal form?
12:18:26 <FunctorSalad> rwbarton: probably, but that would mean one is not supposed to define one's own instances (since the unsafe methods are not even documented)
12:18:46 <pumpkin> oh I see
12:19:03 <FunctorSalad> pumpkin: yep that one
12:19:09 * wli guesses selectionSort = unfoldr (\xxs -> case xxs of [] -> Nothing ; x:xs -> Just $ foldr (\z (y, ys) -> if z < y then (z, y:ys) else (y, z:ys)) (x, []) xs) -- this must be what takeOutBy was about.
12:19:12 <rwbarton> FunctorSalad: worse, not exported, right?
12:19:16 <mux> enticingjelly: no, but beta normal form implied head normal form
12:19:28 <mux> implies
12:19:36 <rwbarton> FunctorSalad: is it even possible to write an instance?
12:19:39 <pumpkin> how active is the work on numericprelude?
12:19:49 <enticingjelly> mux, ah, I see.
12:19:53 <Toxaris> enticingjelly: (\a -> (\b -> b) a) is in head normal form, but not in beta normal form
12:19:57 <enticingjelly> mux, and if I take weak head normal form into it?
12:20:13 <mux> I don't know what WHNF really means, I wish I did :-)
12:20:18 <FunctorSalad> rwbarton: yes, not exported. ghci says they're part of "Data.Array.Base"
12:20:28 <enticingjelly> Toxaris, hmm, no, it isn't, it's in weak head normal form, no?
12:20:56 <Toxaris> enticingjelly: it is in whnf, but I think it is also in hnf
12:21:05 <gwern> > intersperse 'a' "foo"
12:21:06 <lambdabot>   "faoao"
12:21:26 <gwern> > intersperse "a" ["foo", "bar", "baz"]
12:21:28 <lambdabot>   ["foo","a","bar","a","baz"]
12:21:33 <gwern> > concat $ intersperse "a" ["foo", "bar", "baz"]
12:21:34 <Toxaris> enticingjelly: (Just ((\x -> x) 42)) is in whnf, but not in hnf
12:21:35 <lambdabot>   "fooabarabaz"
12:21:49 <mux> > intercalate 'a' ["foo","baz","baz"]
12:21:50 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
12:21:54 <Olathe> > intercalate "a" ["foo", "bar", "baz"]
12:21:56 <lambdabot>   "fooabarabaz"
12:21:56 <mux> > intercalate "a" ["foo","baz","baz"]
12:21:58 <lambdabot>   "fooabazabaz"
12:22:03 <mux> Olathe beats me to it
12:22:07 <Toxaris> enticingjelly: so nf means to reduce all redexes, hnf means not to reduce under \, and whnf means not to reduce under \ or constructor applications
12:22:07 <enticingjelly> Toxaris, ok, so to be in bnf, a term must be in whnf and hnf?
12:22:23 <FunctorSalad> rwbarton: I wasn't going to write my own array, but still I think it would be less confusing if "array" and so on were methods with default implementations via the unsafe methods ;)
12:23:08 <mux> pulling all you can out of the type class definition usually buys you more flexibility
12:23:46 <Toxaris> enticingjelly: the beta in beta normal form just says we are talking about beta reduction here
12:23:53 <FunctorSalad> mux, how so?
12:24:21 <Toxaris> enticingjelly: just as we do with hnf and whnf, which are really head beta normal form and weak head beta normal form
12:25:05 <Toxaris> enticingjelly: consider eta reduction as a different example, that is: (\x -> f x) can be reduced to f. Now, (\x -> f x) is not in eta normal form, but in beta normal form
12:25:06 <enticingjelly> Toxaris, but I want to reach "normal form". i'm trying it with standard reduction now, which is weak head reduction with app, xi and var
12:25:23 <mux> FunctorSalad: if you can pull a function out of the type class definition, it makes instances easier to write; of course you can also have default definitions
12:25:34 <vixey> eta reduction is useless
12:26:08 <mattam> Toxaris: (\x -> f x) in beta eta-long normal form :)
12:26:15 <gwern> eta reduction is as awesome as narwhals!
12:26:18 <Toxaris> vixey: even for examples?
12:26:39 <vixey> oh maybe it is ok for examples but in real world afaict eta reduction has no use
12:26:52 <gio123> why haskel has more users then prolog?
12:26:55 <Olathe> ETA reduction is awesome for airlines.
12:27:15 <Toxaris> mattam: never heard of that. why not \y x -> f x y?
12:27:34 <mattam> gio123: Because you can have Prolog in Haskell?
12:27:46 <gio123> no
12:27:50 <vixey> the real reason is because #prolog is full of disgusting scum
12:27:57 <pumpkin> is wikipedia failing for anyone else? http://en.wikipedia.org/wiki/Beta_normal_form
12:28:02 <wli> \y x -> f x y ~> flip f
12:28:12 <ehird> gio123: is this a joke?
12:28:17 <vixey> whereas #haskell has got channel ops and they don't put up with certain things
12:28:17 <Olathe> pumpkin: Failed to parse (Cannot write to or create math output directory): ((\mathbf{\lambda} x . A(x)) t)
12:28:25 <FunctorSalad> what is the narwhal rule?
12:28:29 <ehird> vixey: certain things! neener neener, can't get me
12:28:33 <pumpkin> Olathe: looks like someone broke wikipedia's TeX :P
12:28:50 <Toxaris> pumpkin: works fine for me
12:28:53 <vixey> Toxaris, the types are important for eta-long form
12:29:06 <mattam> Toxaris: precisely, it is type-dependent.
12:29:09 <pumpkin> Toxaris: weird, for me all their formulas are replaced by big red lettering saying the LaTeX failed
12:29:18 <Toxaris> vixey, mattam: ok, so assume f = id.
12:29:24 <vixey> i.e. f :: () -> () is in \x -> f x, but for f :: (() -> ()) -> (), its  (\x -> f (\e -> x e))
12:29:44 <FunctorSalad> maybe you two have different wikipedia tex settings, pumpkin / Toxaris
12:30:01 <Toxaris> there *are* wp tex settings?
12:30:08 <FunctorSalad> yes :)
12:30:28 <FunctorSalad> everything as png vs. try to use unicode, and some others
12:30:31 <pumpkin> is there exactly one f :: () -> () ?
12:30:41 <FunctorSalad> (the mysterious "good for modern browsers" option...)
12:30:52 <pumpkin> Seems like it should be possible to define Eq on simple functions involving ()
12:31:03 <pumpkin> (not that it'd be any use)
12:31:03 <vixey> pumpkin,
12:31:11 <vixey> you can define Eq for anything finite
12:31:11 * wli recommends everything as png.
12:31:16 <pumpkin> vixey: yeah :)
12:31:16 <Toxaris> well, I have png formulas
12:31:25 <pumpkin> vixey: makes sense
12:31:37 <Toxaris> (maybe selected at some time, but surely displayed fine just now)
12:31:37 <vixey> fun fact, f :: Bool -> Bool = f . f . f
12:31:54 <gio123> can one tell me adventage of haskel using then prolog?
12:32:02 <pumpkin> vixey: interesting, but understandable :)
12:32:05 <pumpkin> gio123: o.O
12:32:33 <vixey> Haskell has support for regular expressions LOL
12:33:08 <Olathe> @djinn () -> Maybe ()
12:33:08 <lambdabot> f _ = Nothing
12:33:26 <Toxaris>  in prolog, you have to use parentheses with predicates all the time, while in haskell, you can use (.) and ($) to avoid them, much better
12:33:44 <wli> instance (Eq domain, Bounded domain, Enum domain, Eq range) => Eq (domain -> range) where f == g = all (uncurry (==)) [(f x, g x) | x <- [minBound .. maxBound]]
12:33:50 <vixey> lambda prolog has MLish syntax
12:33:54 <gio123> can one tell me adventage of haskel using then prolog?
12:34:01 <FunctorSalad> vixey: in fact, confusingly many supports for regexes ;)
12:34:04 <ksf> in Haskell, "This is a lie" doesn't typecheck.
12:34:05 <Elly> they are different languages for different problem domains
12:34:21 <pumpkin> wli: nice
12:34:24 <Elly> "Can anyone tell me the advantage of using hammers over screwdrivers?"
12:34:26 <mapreduce> Mercury seems a midpoint.
12:34:27 <mattam> Toxaris: id -> \x -> id x. The rule is to add an \x -> _ x if the f is not a lambda itself. How it does interact with local definitions is an interesting question.
12:34:28 * vixey disagrees with ksf
12:34:58 <wli> f == g = and [f x == g x | x <- [minBound .. maxBound]] -- maybe this is nicer
12:35:21 <pumpkin> yeah :)
12:35:21 * pumpkin tries it on an Int on a 64-bit machine
12:35:21 <Olathe> pumpkin: http://en.wikipedia.org/w/index.php?title=Beta_normal_form&action=purge
12:35:25 <Olathe> pumpkin: That clears their cache.
12:35:30 <pumpkin> wli: actually
12:35:40 * ksf knows vixey is right and not driving at the same point as him
12:35:44 <Toxaris> mattam: my question was: since you said it is type directed, I expected \x y -> id x y, given that id :: (a -> b) -> a -> b takes two arguments
12:35:47 <pumpkin> wli: that could break on Double/Float because of its sketchy Enum instance
12:35:56 <ksf> drive to?
12:35:57 <FunctorSalad> wli: wouldn't that instance definition suffer from the same problem as Monad => Functor? (that you won't be able to define other Eq instances for function types)
12:35:59 <ksf> point to?
12:36:02 <ksf> something like that.
12:36:04 <mattam> id :: a -> a in my book
12:36:17 <jberg> err, what do you write in ghci so i can use toUpper? and where do you check that on net, where toUpper belongs?
12:36:25 <Toxaris> @type id :: (a -> b) -> a -> b -- mattam
12:36:26 <wli> pumpkin: It's a bad idea in reality, but conceptually it "holds true."
12:36:27 <lambdabot> forall a b. (a -> b) -> a -> b
12:36:31 <vixey> Toxaris, the algorithm to compute eta normal forms is quite incredible btw
12:36:33 <pumpkin> wli: yeah :)
12:36:46 <wli> FunctorSalad: It's a bad idea for a number of other reasons.
12:36:47 <mattam> @type id
12:36:50 <Olathe> This is a lie: fix not
12:36:52 <pumpkin> now we need Float/Double to have real Enum instances... maybe I'll do that for the fun of it
12:36:53 <vixey> or at least the one I know
12:36:55 <Olathe> > fix not
12:36:55 <lambdabot> forall a. a -> a
12:36:56 <lambdabot>   * Exception: stack overflow
12:37:01 <Olathe> @type fix not
12:37:02 <lambdabot> Bool
12:37:08 <mattam> > id
12:37:09 <lambdabot>       Overlapping instances for Show (a -> a)
12:37:09 <lambdabot>        arising from a use of `s...
12:37:29 <wli> pumpkin: Enum isn't quite what it should be in the first place.
12:37:39 <rwbarton> jberg: http://www.haskell.org/hoogle/?q=toupper
12:37:56 <mattam> Toxaris: The cast modifies the type.
12:37:57 <vixey> Toxaris, but the principle type of id is a -> a
12:38:04 <FunctorSalad> *nod*, "enumerations" are surjective in my book...
12:38:05 <vixey> if you have an identity functions which because fo the context, has type (a -> b) -> (a -> b), then you will get that other expansion
12:38:07 <dmwit> jberg: It's in Data.Char, and there's a few ways to find that out.
12:38:09 <dmwit> ?hoogle toUpper
12:38:10 <lambdabot> Data.Char toUpper :: Char -> Char
12:38:15 <dmwit> ?index toUpper
12:38:15 <lambdabot> Data.Char
12:38:18 <pumpkin> wli: yeah
12:38:33 <Toxaris> vixey: yeah makes sense a little bit
12:38:45 <Toxaris> vixey, mattam: what do you do with this eta-long nf
12:38:45 <pumpkin> wli: maybe I'll make a new typeclass called Countable
12:38:56 <vixey> Toxaris, prove the monad laws for Cont :)
12:39:01 <wli> toEnum/fromEnum are the deadly ones.
12:39:01 <pumpkin> wli: and implement good instances for Int/Rational/Float/Double
12:39:08 <pumpkin> wli: yeah
12:39:14 <pumpkin> I've ranted about those before :/
12:39:16 <jberg> dmwit, okay thanks. but my internet connection is halting at the moment, can barely be on irc and can't google or go to websites, so could you tell me how to load Data.Char?
12:39:16 <mattam> You should look at the explicitly typed version of this: id :: forall a. a -> a and we can instantiate a with a or a -> b or anything. @id a and @id (a -> b) are different terms having different normal forms.
12:39:28 <pumpkin> jberg: omg you've encounterd the halting problem!
12:39:31 <enticingjelly> anyone having a really complicated lambda term with a simple normal form?
12:39:41 <dmwit> jberg: ":m + Data.Char" in ghci; "import Data.Char" in a file
12:39:48 <jberg> well whatever it is, it's fucking slow
12:39:52 <jberg> thanks dmwit!
12:40:00 <Demettry> Yet another question, guys! Help appreciated!
12:40:01 <Demettry> I have
12:40:01 <Demettry> data Operand = Var | Formula
12:40:01 <Demettry> type Formula = (LogOp,[Operand])
12:40:01 <Demettry> And I try to write some function of signature ruv :: Var -> Operand -> Operand
12:40:01 * dmwit bows
12:40:02 <Demettry> But when I write: func x (AND, operands) = blahblahblah
12:40:04 <Demettry> it says     Couldn't match expected type 'Operand'  against inferred type '(a, b)'
12:40:06 <Demettry> How can I now deal with that Operand type??
12:40:07 <wli> And where are the arbitrary-precision natural numbers, anyway?
12:40:26 <vixey> Demettry, before you do anything I would suggest changing Formula into a 'data' instead of a 'type'
12:40:39 <Demettry> ok
12:41:00 <rwbarton> Demettry: data Operand = Var | Formula  doesn't do what you seem to think it does
12:41:01 <dmwit> wli: Integer? or did I miss part of the conversation...
12:41:03 <vixey> Demettry, (because it will make programming easier)
12:41:06 <dmwit> Demettry: Var is not a type.
12:41:12 <tromp__> > 2^100
12:41:13 <pumpkin> dmwit: that's got twice as many!
12:41:13 <rwbarton> Demettry: that creates a new type Operand with two values called Var and Formula
12:41:14 <wli> dmwit: Integer is signed.
12:41:14 <lambdabot>   1267650600228229401496703205376
12:41:14 <mattam> Toxaris: you can compare these eta-long normal forms for α-equivalence to decide if two terms are "definitionaly" equal.
12:41:23 <FunctorSalad> @src Positive
12:41:24 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
12:41:25 <tromp__> > 2^100 :: Int
12:41:27 <lambdabot>   0
12:41:30 <Olathe> Demettry: In data Operand, Formula is a constructor, not a type.
12:41:30 <dmwit> pumpkin, wli: Ah.
12:41:31 <FunctorSalad> I thought quickCheck had Positive ;)
12:41:39 <dmwit> wli: There's Nat, but that's Peano numerals... =/
12:42:01 * wli has written buttloads of natural number libs.
12:42:06 <Olathe> Demettry: data Name = Constructor | Constructor Type | Constructor Type
12:42:17 <mattam> Toxaris: that's what people do in Type Theory at least. Not sure it's got any use in Haskell.
12:42:25 <wli> None of which were Peano/unary/etc.; they were all [Word32] etc.
12:42:46 <wli> [Word] might be even better.
12:42:47 <dmwit> Nice!
12:42:50 <FunctorSalad> coq has binary natural numbers as inductive datatypes :)
12:42:51 <mattam> It is however useful at least to reason on Haskell programs.
12:42:52 <dmwit> Did you put any of them on hackage?
12:43:02 <Demettry> Ok. Then can I somehow describe a formula that can have variables and formulas inside like operands?
12:43:06 <wli> dmwit: I didn't consider them so noteworthy.
12:43:11 <Olathe> > let fakePeano 0 = "Zero"; fakePeano n = "Succ(" ++ fakePeano (n - 1) ++ ")" in fakePeano 2
12:43:13 <lambdabot>   "Succ(Succ(Zero))"
12:43:15 <dmwit> wli: If not, just tell gwern where he can get your source and he'll do the honors. ;-)
12:43:18 <Toxaris> mattam: whats the benefit over eta normal form?
12:43:18 <dolio> @type infinity
12:43:19 <Demettry> variables = x, y,z....
12:43:20 <lambdabot> Natural
12:43:29 <rwbarton> > 2^100 > infinity
12:43:31 <Demettry> formulas = x and y and z
12:43:42 <lambdabot>   mueval: Prelude.read: no parse
12:43:54 <rwbarton> > 2^100 > 3
12:43:59 <lambdabot>   True
12:43:59 <dmwit> Demettry: data Formula = And Formula Formula | Variable String -- one reasonable way
12:44:08 <Toxaris> Demettry: you can use the newly created name of your data type on the right hand side of the equals sign, as dmwit just did
12:44:26 <jberg> im wondering what this does from rwh: main = interact (map toUpper . (++) "Your data, in uppercase, is:\n\n") and i type in map toUpper . (++) "foo bar" in ghci but it says no instance for Show ([Char] -> [Char]) and i dont know what that means :X
12:44:28 <dolio> > 3 > infinity
12:44:29 <lambdabot>   False
12:44:33 <Toxaris> Demettry: but maybe you should use NotAnd instead of And, for semantic reasons :)
12:44:55 <dmwit> jberg: (map toUpper . (++) "foo") is a function.
12:44:59 <rwbarton> jberg: It means what you typed was a function (of type [Char] -> [Char]), so how is going to show it?
12:45:06 <dmwit> jberg: It takes a String as input and gives a String as output.
12:45:13 <hydo> Is there a way to pattern match as an expression like in Erlang?  I'm sure my terminology is off... what I'd like to do is if x = Just "a string", say something like Just xx = x so that xx is now "a string"?
12:45:27 <jberg> i see.. so interact takes a function?
12:45:28 <vixey> mattam, afaict no type theory implemented this though
12:45:30 <dmwit> jberg: "interact" takes exactly that kind of function as its first argument...
12:45:32 <rwbarton> > let x = Just "a string" in let Just xx = x in xx
12:45:34 <lambdabot>   "a string"
12:45:35 <dmwit> jberg: yep!
12:45:43 <jberg> dmwit, okay cool
12:45:43 <vixey> mattam, well maybe Plastic does... but they are squandering the implementation so I can't check
12:45:45 <dmwit> jberg: Try this:
12:45:51 <hydo> let / in... of course.  Thanks rwbarton!
12:45:59 <dmwit> > (map toUpper . (++) "foo bar") "baz quux"
12:46:00 <vixey> (I mean no intensional one)
12:46:00 <lambdabot>   "FOO BARBAZ QUUX"
12:46:06 <Olathe> @karma str
12:46:06 <lambdabot> str has a karma of 0
12:46:10 <dmwit> jberg: Do you see how that works?
12:46:11 <rwbarton> hydo: Also case, function bindings, etc., etc. :)
12:46:45 <dmwit> jberg: (Have you been introduced to function composition via (.), string concatenation via (++), and list operations like map yet?)
12:46:47 <FunctorSalad> > (\(Just a) -> a) (Just "foo")
12:46:49 <lambdabot>   "foo"
12:46:54 <FunctorSalad> ;)
12:46:59 <hydo> oooooo
12:47:00 <dmwit> > fromJust (Just "foo")
12:47:02 <jberg> dmwit, ah
12:47:02 <lambdabot>   "foo"
12:47:05 <jberg> dmwit, yes i know of them
12:47:13 <rwbarton> > do { Just xx <- return (Just "foo"); return xx } :: [String]
12:47:15 <lambdabot>   ["foo"]
12:47:16 <jberg> dmwit, i just thought the function composition looked weird
12:47:25 <FunctorSalad> hydo: don't actually do that in a real program, it will throw a uninformative error if Nothing is passed
12:47:26 <pumpkin> ?users
12:47:26 <lambdabot> Maximum users seen in #haskell: 646, currently: 645 (99.8%), active: 36 (5.6%)
12:47:30 <dmwit> jberg: =)
12:47:36 <FunctorSalad> > (\(Just a) -> a) Nothing
12:47:38 <lambdabot>   * Exception: /tmp/4469963026428175341:71:33-46: Non-exhaustive patterns in ...
12:47:42 <pumpkin> lambdabot has such bad memory
12:47:45 <hydo> FunctorSalad: correct, which is what I'm trying to avoid.  Still looks cool though :)
12:48:09 <dmwit> jberg: Hang around here and play with ?pl -- you will find such weird-looking function composition that your example will become totally tame in comparison. ;-)
12:48:42 <FunctorSalad> > case (Just "foo") of { (Just a) -> a ; Nothing -> "hmm, nothing :-(" } -- hydo
12:48:44 <lambdabot>   "foo"
12:48:51 <dmwit> ?pl shout x = map toUpper ("I said: " ++ x) -- like this, jberg
12:48:52 <lambdabot> shout = map toUpper . ("I said: " ++)
12:48:53 <FunctorSalad> (that way you can handle Nothing too)
12:49:12 <blackh1> > fromMaybe (error "oh no!") Nothing
12:49:13 <lambdabot>   * Exception: oh no!
12:49:33 <dmwit> ?pl shout = \x -> map toUpper ("I said: " ++ x) -- hmm, what does ?pl do with this?
12:49:33 <lambdabot> shout = map toUpper . ("I said: " ++)
12:49:39 <dmwit> nice!
12:49:40 <hydo> Oh yea, exceptions... I need to read up on catching them.
12:49:41 <jberg> dmwit, hehe yeah i've seen some of them. but i just need to learn precedense and infixr/infixl so i can read it without a lot of extra parentes
12:49:47 <eu-prleu-peupeu> i like applicative functors
12:49:54 <mattam> Toxaris: the confluence proof works on well typed terms only, which is cumbersome. Otherwise it complicates metatheory I think.
12:50:05 <Demettry> I wanted to make such a thing (AND, [list of operands in this AND]) That could make analysis easier, shouldn't it ? Like (AND, [x,y,z]) or more complicated (AND, [x,y, (OR, [z,w])]) = x && y && (z || w)
12:50:05 <Demettry> If I use "data Formula = And Formula Formula" formalization will look longer = AND x (AND y (OR z w))
12:50:05 <Demettry> Or what you'd say - my idea doesn't make sense? Or impossible to formalize?
12:50:05 <dmwit> jberg: Right.  So, the main thing is that function application binds tighter than anything else.
12:50:09 <pumpkin> eu-prleu-peupeu: you should use them to do awesome things then!
12:50:16 <eu-prleu-peupeu> its much better than to lift around :P
12:50:27 <dmwit> Demettry: Sure, you can do that.
12:50:34 <dmwit> Demettry: See if you can figure out how without our help.
12:50:56 <mattam> Toxaris: it's been a long time I looked at it. Maybe vixey has a better understanding of the problem.
12:51:18 <dmwit> Demettry: As a hint, you can have any type you like be arguments to the "And" constructor.
12:51:26 <rwbarton> Demettry: It's much better not to use tuples in this case
12:51:43 <jberg> dmwit, mm. and by bound tighter you mean..?
12:51:46 <dmwit> Demettry: Feel free to think out loud here, too; we love guiding people. =)
12:52:02 <Demettry> Yes, that's the problem - I don't know how to formalize this view - (AND, [x,y, (OR, [z,w])]) ((( But thanx for the hint, I will try
12:52:16 <rwbarton> Demettry: (In fact, it's not even really possible)
12:52:32 <Demettry> rwbarton: what's not possible?
12:52:49 <rwbarton> Demettry: I mean, in the end, the syntax to create the value will look like   AND [x, y, OR [z, w]]
12:52:51 <dmwit> jberg: I mean, function application happens before any operators are applied.  So (f x y . g z . h w) parses first as ((f x y) . (g z) . (h w)), then the order of the composition gets worked out after that.
12:53:11 <vixey> Demettry, well I recommand against using (,) like that
12:53:12 <Toxaris> Demettry: two hints. first, your idea with the lists is fine and can be implemented. second, you should not use any tuples to do so.
12:53:30 <jberg> dmwit, ah right
12:53:30 <dmwit> jberg: Likewise for all other operators.  Function application first, then operator precedence.
12:53:39 <jberg> yes
12:54:04 <Demettry> ok, I forgot the tuples. rwbarton: thanx for hint
12:54:28 <Demettry> Toxaris: thanx
12:55:30 <jberg> man, i don't think theres another language like haskell where you can do so much with so little. and make writing meaningless codesamples fun just because you're amazed it actually worked this time too
12:56:02 <dmwit> hehehe
12:56:05 <dmwit> Yay!
12:56:05 <jberg> just toying around is fun
13:02:05 <olsner_> > let (:=) = (+) in 1 := 3
13:02:06 <lambdabot>       No instance for (Show (Assoc t t1))
13:02:06 <lambdabot>        arising from a use of `show'...
13:02:18 <blackh1> jberg: When I program in Haskell, I call it "the incredible disappearing code" because when I start re-factoring after my first attempt, I get left with almost nothing!
13:02:35 <rwbarton> > let Just = (+) in 1
13:02:37 <lambdabot>       Constructor `Just' should have 1 argument, but has been given 0
13:02:37 <lambdabot>      In...
13:02:43 <rwbarton> :t (:=)
13:02:46 <lambdabot> forall a b. a -> b -> Assoc a b
13:03:01 <rwbarton> > let (:=) = (+) in 1
13:03:02 <lambdabot>       Constructor `:=' should have 2 arguments, but has been given 0
13:03:02 <lambdabot>      In ...
13:03:03 <olsner_> so, ':' is reserved for type names and constructors? *great*
13:03:18 <rwbarton> Yeah, it's like the punctuation version of a capital letter
13:03:21 <rwbarton> And it is great.
13:03:43 <olsner_> only when you want to use it as a type... I guess I'll call it $= or something instead
13:04:27 <baaba> if you want some kind of destructive assignment thingy i've seen .= used somewhere at least
13:04:37 <vartos> hmm, what text editors(winxp) do u guys use for haskell?
13:05:14 <olsner_> $= is used by the OpenGL bindings at least
13:05:50 <jberg> blackh1, hehe me too. i started with openFile hClose etc. then readFile "foo" etc etc. and now just interact myfunc :)
13:08:32 <dmwit> vartos: gvim
13:09:44 <vartos> thanks ;)
13:09:58 <pumpkin> Got Very Important Message?
13:10:08 <SamB> does anyone know what the CATALYST pragma in JHC/LHC is for ?
13:10:13 <jberg> vartos, emacs. i think it's much better than vim for haskell actually
13:10:19 <blackh1> jberg: I recently wrote a two-player game of "connect 4" entirely as an arg to interact. I was very pleased with that!  I'll paste it if you're interested.
13:10:24 <jberg> i usually use gvim though. just not for lisp or haskell
13:10:35 <jberg> blackh1, yeah sure!
13:11:16 <dmwit> I love interact.  Especially the fact that it turns off buffering for you...
13:11:24 <dmwit> Ah elegance, why must you be so inefficient??
13:12:14 <olsner_> pumpkin: yes! vim really is a Very Important Message!
13:12:45 <Cale> dmwit: Doesn't it leave things line buffered?
13:12:51 <vartos> i didnt do well with emacs :S
13:13:08 <blackh1> jberg: http://blacksapphire.com/~blackh/haskell/connect4.hs      (it won't fit on hpaste.org)
13:13:10 <Cale> (at least... the input appears line buffered here)
13:13:28 <pao> jberg: what are the advantages of emacs over vim for haskell?
13:13:43 <blackh1> jberg: I was experimenting with TDD (test driven development)
13:13:46 <Debugger> pao: Better integration with ghc
13:13:56 <Debugger> pao: That's the only one imo
13:14:14 <pao> Debugger: have you tried vim plugin for haskell?
13:14:16 <jberg> blackh1, cool ill check it out
13:14:30 <Peaker> blackh1: Haskell has better: PDD (Proof driven development) :-)  You write the types and then you prove your program has those types...
13:14:39 <pao> Debugger: by the way... I haven't yet done it
13:14:51 <Debugger> pao: I did, not too bad
13:14:52 <Cale> Emacs also has "smart" indenting for Haskell, but I found that difficult to get used to, since it often requires you to type the start of a line, and *then* hit tab to indent it properly.
13:14:53 <vixey> that is not how haskell works Peaker
13:15:03 <blackh1> jberg: Another interesting thing in this code is this idea of composable board transmutations... I only check for a winning position (4 counters in a row) in a column... then I permute the board four different ways and apply the same function to find horizontal, vertical and diagonal wins.
13:15:14 <Peaker> vixey: s/you prove/the type inference engine proves, oops :)
13:16:07 <blackh1> Peaker: I've been seeing lots of mention about this, and want to investigate. Can you point me at some mind-expanding reading material?
13:17:20 <Peaker> blackh1: if you successfully compile Haskell programs you're already getting your program proved to be of a certain type. Must of the task (but not all of it) of TDD is done better by the types..
13:17:25 <dmwit> Cale: Ah, apparently, when compiled, it's line-buffered.  My bad.
13:17:30 <blackh1> Peaker: I have been teaching my brother Haskell and he's been teaching me TDD.  He was showing me how Eclipse practically writes Java for you.  (But it's still Java when it's written!)
13:17:41 <Cale> dmwit: In ghci too, for me.
13:17:49 <Peaker> blackh1: does Eclipse also maintain the Java code for you?
13:18:01 <Cale> dmwit: I can never quite work out the strange behaviour of terminals though.
13:18:02 <dmwit> Cale: In ghci, it's NoBuffered here.
13:18:03 <jberg> blackh1, hm neat. don't understand it quit yet. what is this test driven development and what kind of game is this?
13:18:09 <Cale> dmwit: 6.10.1?
13:18:10 <Peaker> blackh1: if you edit a variable name used in the auto-generated code, does Eclipse fix all of the code automatically?
13:18:15 <dmwit> 6.8.3
13:18:17 <Cale> ah
13:18:34 <rwbarton> Cale: Try in a fresh terminal just to be sure
13:18:36 <blackh1> Peaker: I've discovered that. I'm writing big complex programs, and when re-factoring, I can feel that Haskell is doing a lot of the job that TDD is meant for.
13:18:43 <Peaker> jberg: the game is: Write a bunch of tests assuming some API has some semantics -- then repeatedly run the test, and create/edit the API until the test passes
13:18:46 <gwern> > "John MacFarlane <jgm@berkeley.edu>" =~ ".*<" :: (String,String,String
13:18:47 <lambdabot>   <no location info>: parse error on input `;'
13:18:49 <gwern> > "John MacFarlane <jgm@berkeley.edu>" =~ ".*<" :: (String,String,String)
13:18:50 <lambdabot>   ("","John MacFarlane <","jgm@berkeley.edu>")
13:18:57 <thoughtpolice> blackh1: there is a direct correspondance between types and theorems in your code, and programs and proofs. generally speaking, when you say a function is of a certain type, you are making a proposition, and if you can write a function of that type, it is a 'proof' of that type.
13:19:14 <gwern> > "John MacFarlane <jgm@berkeley.edu>" =~ ".*<.*$" :: (String,String,String)
13:19:16 <lambdabot>   ("","John MacFarlane <jgm@berkeley.edu>","")
13:19:20 <gwern> bah
13:19:23 <thoughtpolice> blackh1: see 'curry-howard correspondance'
13:19:43 <vixey> curry-howard isn't relevant for haskell
13:19:43 <gwern> > "John MacFarlane <jgm@berkeley.edu>" =~ ".*<.*>" :: (String,String,String)
13:19:43 <Cale> rwbarton: Definitely line-buffered input, in either case.
13:19:45 <lambdabot>   ("","John MacFarlane <jgm@berkeley.edu>","")
13:19:51 <olsner_> hmm, I think I'd like to write a monad transformer that allows to lift more than one way, like combining two Readers and doing liftLeft and liftRight to select the right one
13:19:52 <thoughtpolice> i'm not saying it is relevant
13:19:53 <Cale> rwbarton: Or, well, I can edit my line, and it only prints a response after I hit enter.
13:19:56 <olsner_> I wonder if it's possible
13:19:59 <thoughtpolice> i'm not saying you need to understand it either
13:20:08 <thoughtpolice> i'm just giving a pointer as to what you might want to look into
13:20:20 <gwern> now why doesn't that split into two, since there are two matching regions...
13:20:21 <blackh1> jberg: TDD is part of "Extreme Programming" a.k.a. "Agile methodology", and it doesn't pertain to any particular language.  It is a very good thing.  In my not-very-extensive experience, Haskell removes most of the need for it, but not all.
13:20:37 <gwern> > "John MacFarlane <jgm@berkeley.edu>" =~ ".*<.*" :: (String,String,String)
13:20:39 <lambdabot>   ("","John MacFarlane <jgm@berkeley.edu>","")
13:20:42 <rwbarton> gwern: because the entire string matched your expression
13:20:48 <ehird> 21:14 <Peaker> blackh1: Haskell has better: PDD (Proof driven development) :-)  You write the types and then you prove your program has those types...
13:20:49 <olsner_> then rewriting a Writer [Either a b] into an EitherT (Writer [a]) (Writer [b]) or something equally funky
13:20:50 <ehird> sorry, but no.
13:21:04 <ehird> enforcing even trivial constraints like "Integer less than 3" is painful to the max with haskell's type system.
13:21:08 <gwern> > "John MacFarlane <jgm@berkeley.edu>" =~ "[^<]*" :: (String,String,String)
13:21:09 <lambdabot>   ("","John MacFarlane ","<jgm@berkeley.edu>")
13:21:13 <pejo> gwern, do you really want to plaster the email of John MacFarlane in all the logs of this channel? :-)
13:21:16 <gwern> ah, there we go
13:21:30 <Peaker> pejo: too late!
13:21:39 <Peaker> the logger could be a good netizen and filter things that look like emails
13:21:41 <blackh1> jberg: The idea is quite simple: Instead of "writing code", you write a test that says what you want the code to do, and make sure it fails. Then you write *only* the code necessary to make the test pass.  This is "coding without a brain".  Then "design" magically disappears.  Also re-factoring becomes much easier.  It's quite interesting.
13:21:42 <gwern> pejo: shh! you'll cause a streisand effect!
13:21:56 <SamB> Peaker: that would be just as much of a pain
13:22:14 <Peaker> SamB: regexp replace?
13:22:19 <SamB> gwern: spammers don't write code sophisticated enough for such an effect to exist
13:22:26 <SamB> Peaker: no, munging IRC logs
13:22:43 <Peaker> SamB: spammers surely do regexp lookups of email addresses in spider'd web pages
13:22:49 <TML> Getting to a working ghc is enough to bring a grown man to tears :)
13:22:51 <SamB> Peaker: hmm ?
13:23:01 <gwern> > let (x,y,(reverse . drop 1 . reverse $ drop 1 z)) = ("John MacFarlane <jgm@berkeley.edu>" =~ "[^<]*" :: (String,String,String))
13:23:02 <lambdabot>   <no location info>: Parse error in pattern
13:23:07 <SamB> Peaker: I meant it would be a pain if they had all email addresses munged out
13:23:09 <Peaker> SamB: they look for email addresses whereever they can find them.. lists of email addresses are worth money
13:23:14 <blackh1> jberg: This is a game that you can buy in the shops - at least here in NZ. It's basically tic-tac-toe on a 6x7 grid, with the restriction that the counters are subject to gravity.
13:23:19 <ehird> blackh1: no, the design _is_ the test
13:23:24 <gwern> macfarlane's email is all over the place
13:23:27 <ehird> it's just a codified design
13:23:27 <Peaker> SamB: a pain for who?
13:23:35 <gwern> heck that's not even his private fiddolospher gmail address
13:23:43 <Peaker> gwern: why do you use $ there and not after drop 1 ?
13:23:53 <gwern> (turns out in his spare time macfarlane is a philosophy prof, so the name makes sense)
13:23:54 <Peaker> reverse . drop 1 . reverse . drop 1 $
13:24:23 <vixey> can't you define something = reverse . drop 1 . reverse . drop 1
13:24:30 <SamB> Peaker: people who would be scouring them for information that was discussed in the past
13:24:54 <gwern> @hoogle init
13:24:54 <lambdabot> Prelude init :: [a] -> [a]
13:24:54 <lambdabot> Data.ByteString init :: ByteString -> ByteString
13:24:54 <lambdabot> Data.List init :: [a] -> [a]
13:25:03 <gwern> > init [1..10]
13:25:04 <lambdabot>   [1,2,3,4,5,6,7,8,9]
13:25:18 <gwern> > tail $ init [1..10]
13:25:19 <lambdabot>   [2,3,4,5,6,7,8,9]
13:25:40 <Peaker> > tail . init $ [1..10]
13:25:42 <lambdabot>   [2,3,4,5,6,7,8,9]
13:26:43 <dpratt71> Am I correct to assume that Haskell does not have an analog to "cast"?
13:26:59 <Cale> :t cast
13:26:59 <gwern> @faq can Haskell do an analogue to cast?
13:27:00 <lambdabot> The answer is: Yes! Haskell can do that.
13:27:00 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
13:27:03 <tromp__> it has specific casts
13:27:11 <tromp__> like fromIntegral
13:27:22 <Cale> Depends on what you mean by "cast" :)
13:27:24 <dpratt71> never a simple answer with you folks, is it ;)
13:27:27 <blackh1> dpratt71: There is another analogue to cast in Data.Dynamic
13:27:39 <rwbarton> dpratt71: It wasn't a simple question :)
13:27:49 <dpratt71> rwbarton: touche
13:28:18 <dpratt71> alright, here's the context of the question: ...
13:28:20 <tromp__> > cast 3 :: Bool
13:28:22 <lambdabot>   Couldn't match expected type `Bool' against inferred type `Maybe b'
13:28:24 <Cale> > cast (45 :: Integer) :: Double -- it gives Nothing when the types don't actually match
13:28:26 <lambdabot>   Couldn't match expected type `Double'
13:28:28 <tromp__> > cast 3 :: Maybe Bool
13:28:29 <Cale> er...
13:28:30 <lambdabot>   Nothing
13:28:33 <Cale> > cast (45 :: Integer) :: Maybe Double -- it gives Nothing when the types don't actually match
13:28:34 <lambdabot>   Nothing
13:28:53 <Cale> > cast (45 :: Integer) :: Maybe Integer -- but will give the original value when they do happen to match
13:28:55 <lambdabot>   Just 45
13:28:55 <tromp__> > cast 3 :: Maybe Int
13:28:57 <lambdabot>   Nothing
13:29:02 <dpratt71> some recent comments reminded me of a "paper" I came across recently outlining what could be "proved" about a function based on its type...
13:29:06 <tromp__> > cast 3 :: Maybe Integer
13:29:07 <lambdabot>   Just 3
13:29:10 <Peaker> > maybe "" (++"lala") $ cast "Hello"
13:29:13 <lambdabot>   "Hellolala"
13:29:15 <vixey> hm cast is weird
13:29:48 <dpratt71> of course, in OO imperative languages, parameter type is not such a strong contract
13:29:49 <Cale> It's not actually possible to write cast without cheating.
13:30:06 <vixey> Cale, icheating means unsafeCoerce?
13:30:14 <dpratt71> Haskell never lets you cheat, does it ? ;)
13:30:25 <Cale> vixey: yeah...
13:30:36 <Cale> dpratt71: GHC has ways to let you cheat.
13:30:37 <vixey> Cale, You can do something similar without cheating though
13:30:41 <dpratt71> oh, maybe I mis-interpreted what you said..
13:30:54 <Cale> dpratt71: Of course, you can treat cast as a primitive.
13:31:10 <Cale> Though the whole Typeable thing is a bit screwed up.
13:31:23 <Cale> It shouldn't be possible to write instances of Typeable by hand, but it is.
13:31:42 <vixey> Cale, (but my way has a closed universe of types which is the biggest difference with the typeclass approach)
13:31:46 <Cale> And by writing bad instances of Typeable, you can break the type system.
13:32:43 <gwern> yay, down to one failing test!
13:32:44 <rwbarton> dpratt71: cast has a type context, so those theorems don't apply
13:32:52 <rwbarton> :t cast
13:32:54 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
13:33:07 <rwbarton> dpratt71: or rather, you can't use cast to write a function of type a -> a
13:33:09 <dpratt71> makes sense
13:33:18 <pejo> Cale, are the derived ones guaranteed safe?
13:33:26 <Cale> pejo: More or less.
13:33:40 <vixey> pejo, I wonder what kind of guarantee you /could/ give
13:34:32 <ehird> I wonder how TDD can be facilitated with quickcheck
13:34:38 <vixey> I mean the deriver thing is basically just something someone hacked in a day right?
13:34:39 <Cale> The important thing is that distinct types don't have the same TypeRep, and that you don't have stupid instances like  instance Typeable a
13:35:00 <vixey> if we had open GADTs.. you could do cast in a type safe way
13:35:10 <vixey> except open GADTs doesn't really make sense I think
13:35:19 <dpratt71> GADTs?
13:35:35 <dmwit> Generalized Abstract Data Types.
13:35:35 <Olathe> @where gadt
13:35:35 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html
13:35:44 <vixey> dpratt71, have you seen definitions like   data Pair x y = Both x y  ?
13:35:54 <dpratt71> Olathe: 404
13:36:01 <dmwit> You might want to wait a month or two before tackling them, they're even more mind-bending than most Haskell features... =)
13:36:12 <Olathe> @where+ gadt http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt
13:36:12 <lambdabot> I will remember.
13:36:17 <Olathe> @where gadt
13:36:17 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt
13:36:26 <pao> Is existential quantification considered good practice or should I try to get rid of it?
13:36:31 <dmwit> Who has ?flush privileges?
13:36:31 <dpratt71> ah! enlightenment :)
13:36:38 <vixey> pao, I have nothing against it..
13:36:47 <pao> vixey: thanks
13:37:01 <vixey> pao, if you think it would be better if it was not there then by all means remove it though
13:37:55 <dmwit> dpratt71: Notice that the type variables in the constructors are allowed to be *more refined* than the type variables in the data declaration...
13:38:09 <dpratt71> so noticed
13:38:12 <vixey> :/
13:38:41 <pao> vixey: well ... I'm a newbie and my critical view of the code is not yet as good as it could be ... I'd be able to judge by myself of this case only after trying for 24h to get rid of it :-)
13:39:22 <Peaker> :info on operators shows their infix precdence, but :info on `blah` does not show its precedence, even though it may have one
13:39:43 <dpratt71> are GADTs being considered for a future version of Haskell?
13:40:12 <vixey> dpratt71, uh.. GADTs are already implemented
13:40:18 <pao> Peaker: I think the report specify precedence 9 for unspecified `foo` precedence priority
13:40:23 <thoughtpolice> I think he means are they going to be standardized
13:40:31 <dpratt71> oh...
13:40:35 <vixey> what's the standardize about them?
13:40:40 <dmwit> Peaker: That's annoying.
13:41:05 <dpratt71> I think I need to ask what is an "open" GADT?
13:41:11 <thoughtpolice> vixey: ?
13:41:11 <pao> Peaker: ... but I agree :info should report it...
13:41:15 <vixey> that's what I want to know
13:41:26 <dmwit> Peaker: Hmm, it works for me.
13:41:51 <dmwit> Peaker: "infixr 6 `foo`; foo x y = id x y", then ":i foo" in ghci shows infixr 6 `foo` as part of its output.
13:41:52 <Peaker> dmwit: I tested it on functions I defined in ghci, with precedence
13:42:32 <dmwit> Peaker: Ah, yep, that's annoying.
13:42:36 <dmwit> Peaker: File a bug.
13:42:36 <ehird> anyone used quickcheck for tdd?
13:42:55 <dmwit> Peaker: Make sure to say that it applies only to functions defined interactively.
13:43:23 <dmwit> ehird: Lots of people use quickcheck; xmonad is a great example if you're looking for code.
13:43:26 <thoughtpolice> ehird: yes. quickcheck is great. :)
13:43:29 <blackh1> ehird: I think it would work better than the usual HUnit.  I did one tiny bit of it in my connect4.hs program.
13:43:29 <thoughtpolice> xmonad is an example
13:43:40 <dpratt71> hmm...googling "open GADT" returns a lot of noise
13:43:42 <ehird> dmwit: "for TDD" was the relevant part there.
13:43:52 <dmwit> mmm
13:44:14 <dpratt71> is the idea that an "open" GADT is not "baked", but can later be extended?
13:44:40 <thoughtpolice> ehird: i don't even know what TDD really 'means', but xmonad has been using quickcheck pretty intensively and it's helped in major code rewrites as well as catching bugs before they really manifest
13:44:51 <rwbarton> dpratt71: Yes
13:44:58 <pejo> vixey, the deriver thing was probably implemented by GHC HQ, the SYB papers mentions auto-deriving iirc.
13:45:02 <SamB> but xmonad's tests weren't written as things which ought to fail to begin with
13:45:20 <ehird> thoughtpolice: Test Driven Development is that you start with a design in the form of a test: this is how everything should behave.
13:45:20 <filcab42> hi all
13:45:27 <ehird> Then, you write just enough code to make that test work.
13:45:27 <SamB> they were written as algebraic identities that should be satisfied
13:45:32 <ehird> When that is done, you have implemented your design.
13:45:34 <dpratt71> rwbarton: kthx...I just found another "paper" with which to melt my brain
13:46:25 <kerlo> @hoogle IO a -> IO ()
13:46:25 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
13:46:25 <lambdabot> Control.Exception block :: IO a -> IO a
13:46:25 <lambdabot> Control.Concurrent runInBoundThread :: IO a -> IO a
13:46:33 <vixey> dpratt71, link?
13:46:44 <dpratt71> http://people.cs.uu.nl/andres/OpenDatatypes.pdf
13:46:48 <kerlo> I think what I'm looking for is sequence . repeat.
13:47:05 <blackh1> ehird: I am trying to understand how TDD is applicable to Haskell, too.  Perhaps we can talk about this again as we learn more.  My brother (the TDD expert) says "You *only* test logic". So in Haskell-land I would translate that to "You *only* test what Haskell doesn't guarantee for you."
13:47:19 <dmwit> kerlo: forever
13:47:31 <ehird> blackh1: Well...
13:47:33 <psnively> blackh1: With Typeful Programming, that's still not quite right.
13:47:34 <lambdabot> psnively: You have 1 new message. '/msg lambdabot @messages' to read it.
13:47:38 <ehird> blackh1: Haskell can't enforce that you wrote your program right ;-)
13:47:42 <Peaker> dmwit: its not only not reported, its not using the infix decl. at all
13:47:48 <ehird> It can enforce you have no type errors, yes, but you can easily have an error in your algorithm.
13:47:55 <dmwit> Peaker: Even better. =P
13:47:57 <psnively> ehird: No, but you can encode more constraints as types than is commonly understood.
13:47:59 <ehird> Also, you can't type-enforce things like "X must be less than 5" without _severely_ painful type trickery.
13:48:05 <ehird> psnively: yes, naturally
13:48:09 <ehird> but certainly not everything
13:48:15 <kerlo> dmwit: sounds good.
13:48:19 <ehird> dependent types are the only way you're gonna get that
13:48:22 <dmwit> filcab42: Hiya!
13:48:23 <ehird> anything less, you still need tests
13:48:26 <ehird> plus, dependent types _are_ tests
13:48:30 <psnively> No, not unless you want to be like the C++ template metaprogram for the factorial function and have the compiler just spit out the answer... ;-)
13:48:56 <blackh1> ehird: I think it would make sense to use TDD for only those things that Haskell doesn't give you for free... but this breaks the TDD paradigm a bit because you don't know what that is until you've started writing your code... but you're meant to do your test first!
13:48:57 <dmwit> You can do that in Haskell, with a few extensions.
13:49:04 <Peaker> dmwit: http://hackage.haskell.org/trac/ghc/ticket/2947
13:49:05 <ehird> [[I think it would make sense to use TDD for only those things that Haskell doesn't give you for free]]
13:49:12 <ehird> blackh1: thing is, that's _a lot_ more than you seem to think
13:49:21 <ehird> haskell don't make your code magically perfect
13:49:30 <ehird> blackh1: btw, i'd say a functions type is part of the test
13:49:39 <ehird> function's type first, then the test, then the implementation
13:49:44 <Peaker> ehird: You can write the quick-check invariants before-hand...
13:49:49 <blackh1> ehird: I do C++ in my day job. From my point of view, Haskell makes your code magically perfect!
13:49:50 <ehird> Peaker: umm, yes
13:49:52 <ehird> that's the whole _idea_
13:49:54 <ehird> of tdd
13:50:00 <psnively> blackh1: ==
13:50:12 <Peaker> ehird: but I don't think its a big deal whether you write it before or after
13:50:20 <ehird> it is
13:50:21 <psnively> Moving to Haskell or OCaml or Scala from the popular languages is like: holy CRAP!
13:50:24 <ehird> it's about design vs testing
13:50:33 <blackh1> Peaker: It is a big deal, because the test drives the design, so the theory goes.
13:50:38 <Peaker> ehird: why?
13:50:38 <Peaker> ehird: Why "vs"?
13:50:42 * vixey thinks haskell and ocaml are popular...
13:50:49 <vixey> that probably just shows how confused I am
13:50:54 <ehird> Peaker: I'm not a library :D
13:51:11 <ehird> vixey: not outside of reddit ;-)
13:51:39 <Peaker> popularity is relative
13:51:53 <kerlo> Is "import Network" supposed to work in Hugs?
13:51:54 <orbitz> haskell is popular with haskell programmers
13:52:01 <Peaker> blackh1: I don't think it does, as small things are easy to design and big things are hard to test
13:52:05 <Badger> @src forever
13:52:05 <ehird> orbitz: o rly
13:52:05 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
13:52:12 <Badger> @index forever
13:52:13 <lambdabot> bzzt
13:52:13 <Peaker> forever x = x >> forever x
13:52:16 <ehird> Peaker: test driven development codifies your design into tests
13:52:20 <ehird> writing a test after, you don't get that
13:52:20 <Peaker> @pl forever x = x >> forever x
13:52:21 <int-e> orbitz: heh. you can't say that of many programming languages ;)
13:52:21 <lambdabot> forever = fix (ap (>>))
13:52:31 <ehird> your design/test guides your code to correctness as you go
13:52:45 <ehird> whereas testing after is just "ok, I spat out some code, now let's see if it works"
13:52:50 <Badger> Peaker: well yes, but it's in some module right? :P
13:52:54 <rwbarton> Shouldn't it be  forever x = let y = x >> y in y?
13:52:56 <Badger> @hoogle forever
13:52:57 <lambdabot> Control.Monad forever :: Monad m => m a -> m ()
13:52:59 <Badger> ah
13:53:05 <blackh1> Peaker: I personally believe that TDD is largely aimed at the inadequacies of OO languages. I am searching for the parts of it that work for Haskell, and I think it does have a contribution to Haskell programming.
13:53:30 <Peaker> blackh1: I don't have enough experience writing larger "real world" Haskell stuff, just tiny toys so far
13:53:34 <ehird> blackh1: I think you're being a bit clouded by the awesomeosity of haskell :-)
13:53:34 <Olathe> > forever "A"
13:53:36 <lambdabot>   * Exception: stack overflow
13:53:37 <pumpkin> is there an easy way to interleave two lists? so pick one element from one, one from the other, and so on?
13:53:48 <mm_freak_> > forever ""
13:53:50 <ehird> We're still humans, we're still fallable, we still make mistakes
13:53:50 <lambdabot>   []
13:53:56 <mm_freak_> > forever Nothing
13:53:56 <Peaker> blackh1: hundreds of lines or so
13:53:57 <lambdabot>   Nothing
13:54:09 <Olathe> > forever forever
13:54:10 <lambdabot>       Overlapping instances for Show (m a -> ())
13:54:10 <lambdabot>        arising from a use of...
13:54:42 <dmwit> pumpkin: The function to do it manually is pretty short.
13:54:42 <ehird> Peaker: I remember when you ranted in here about AST editing. :-)
13:54:49 <pumpkin> dmwit: yeah :)
13:54:52 <dmwit> pumpkin: There's also something in LogicT for that, I think.
13:55:01 <pumpkin> on that `interleave` function?
13:55:06 <kerlo> interleave (x:xs) (y:ys) = x:y:interleave xs ys; interleave [] [] = []
13:55:08 <pumpkin> I guess I can just do it with a concat zipWith
13:55:10 <pumpkin> or that
13:55:20 <mm_freak_> dmwit, pumpkin: yes, LogicT implements this
13:55:25 <blackh1> ehird: I still think I'm right: If you apply TDD straight out of the book to Haskell, you're making a lot of unnecessary work for yourself. I've found the design just "fall out of" Haskell in the same way that it's supposed to do with TDD, so I still think TDD has to be modified somehow to make it applicable to Haskell.
13:55:44 <ehird> blackh1: i think that's a bit optimistic, personally
13:55:45 <blackh1> ehird: I am far more experienced in Haskell than in TDD.
13:55:51 <rwbarton> , interleave "abcde" "xyz"
13:55:51 <SamB> well, first of all
13:55:53 <gwern> wow, I can't believe 'λ(QName {qName = x}) ' actually works
13:55:53 <mm_freak_> Control.Monad.Logic> take 10 $ [1..] `interleave` [10..]
13:55:53 <lunabot>  "axbyczde"
13:55:53 <mm_freak_> [1,10,2,11,3,12,4,13,5,14]
13:55:56 <vixey> @vera TDD
13:56:00 <SamB> half of your tests are types in Haskell
13:56:05 <ehird> yes
13:56:06 * vixey wonders what are they talking about..
13:56:07 <lambdabot> *** "tdd" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
13:56:07 <lambdabot> TDD
13:56:07 <lambdabot>      Telecommunications Device for Deaf
13:56:07 <lambdabot>  
13:56:07 <lambdabot> *** "tdd" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
13:56:08 <ehird> but not all of them
13:56:09 <lambdabot> [3 @more lines]
13:56:14 <ehird> vixey: Test driven development
13:56:16 <SamB> (well, that's a rough figure)
13:56:21 <blackh1> ehird: I am basing this partly on experience with a large Haskell project, and partly on prejudice!
13:56:36 <dmwit> pumpkin: How about concat . transpose?
13:56:38 <blackh1> Peaker: I'll give you some Haskell coding to do!
13:56:46 <gwern> blackh1: sure there's no pride in there?
13:56:49 <dmwit> > concat . transpose $ ["abcd", "xyz"]
13:56:50 <pumpkin> dmwit: ah, good idea
13:56:51 <lambdabot>   "axbyczd"
13:57:05 <dmwit> pumpkin: Then you're not limited to only two arguments. =)
13:57:09 <Peaker> ehird: I remember I had you on /ignore, in fact, I just /unignore'd you after seeing a lot of "ehird:" stuff :)
13:57:17 <ehird> LOL :)
13:57:23 <kerlo> ERROR "ircbot" - Can't find imported module "Network"
13:57:26 <blackh1> gwern: What am I being proud about? (I ask in the spirit of inquiry.)
13:57:28 <Badger> @index concat
13:57:29 <lambdabot> Data.List, Prelude
13:57:30 <Peaker> ehird: I still intend to do the AST stuff, I hope to do it with Reactive, but its still buggy
13:57:34 <Badger> hm?
13:57:36 <ehird> Peaker: My damn opposing opinions are unacceptable!
13:57:37 <ehird> :D
13:57:39 <Zao> kerlo: I could see some slight complications arising from that error :)
13:57:40 <Badger> oh.
13:57:42 <mm_freak_> , [1..] `interleave` [10..] `interleave` [100..]
13:57:44 <lunabot>  [1,100,10,101,2,102,11,103,3,104,12,105,4,106,13,107,5,108,14,109,6,110,1...
13:57:50 <ehird> oh... you haven't recovered yet?
13:57:52 <ehird> i feel for you :(
13:57:54 <Peaker> ehird: I think it was not about the opposing opinions, but the way those opinions were being presented
13:58:07 <dmwit> > concat . transpose $ [[1..], [10..], [100..]]
13:58:09 <lambdabot>   [1,10,100,2,11,101,3,12,102,4,13,103,5,14,104,6,15,105,7,16,106,8,17,107,9,...
13:58:12 <dmwit> fairer!
13:58:12 <ehird> um i think you were more hostile than me at the time...
13:58:40 <kerlo> Zao: any idea what's wrong here?
13:59:49 <Olathe> @pl \a b c -> [a, b, c]
13:59:49 <lambdabot> (. ((. return) . (:))) . (.) . (:)
14:00:40 <Olathe> > zipWith3 ((:).(:).(:[])) [100..] [10..] [1..]
14:00:41 <lambdabot>   Couldn't match expected type `c -> d'
14:00:44 <mm_freak_> @src transpose
14:00:44 <lambdabot> transpose []             = []
14:00:44 <lambdabot> transpose ([]   : xss)   = transpose xss
14:00:44 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
14:01:01 <ehird> > transpose [1,2,3,4]
14:01:03 <lambdabot>       No instance for (Num [a])
14:01:03 <lambdabot>        arising from the literal `1' at <inter...
14:01:09 <ehird> > transpose [[1,2],[3,4]]
14:01:11 <lambdabot>   [[1,3],[2,4]]
14:01:14 <mm_freak_> i'm sure, LogicT's 'interleave' is much faster than transpose =)
14:02:05 <mm_freak_> however, i've never actually needed it
14:03:06 <vixey> not just faster but interleave is a better name
14:05:46 <pumpkin> so I'm trying to make a typeclass called Countable with a method called enumerate. I've done instance (Integral a) => Countable a which needs flexible/undecidable instances apparently
14:06:11 <pumpkin> is there some way I can have both that and (Bounded a) => Countable a? and if so, what if something is both Bounded and Integral?
14:06:42 * olsner_ likes recursive monads
14:07:10 <dolio> Like list?
14:07:49 <Martijn> Could someone please help me with this? I've installed readline from hackage but System.Console.Readline.readline still gives me an editline prompt.
14:08:02 <dolio> Where can I get this "monads as burritos" tutorial?
14:08:14 <pumpkin> byorgey knows
14:08:47 <Apocalisp> Something about seven layers
14:09:14 <olsner> more in general, I just worked through roconnor's article on the assembly monad and have a definite feeling it'll be awesome as soon as I figure out what I can do with it
14:09:20 <dolio> Maybe it's monad transformers that are like burritos.
14:09:39 <Olathe> Monad transformers are like Taco Bell workers.
14:10:22 <pumpkin> anyone know what to do about my duplicate instances?
14:10:30 <Saya> olsner: wher eis that article you talk about? i tried doing something similar as an exercise ( a simple version) and failed miserably :)
14:10:36 <vixey> "it'll be awesome as soon as I figure out what I can do with it" heheh
14:10:40 <byorgey> pumpkin: you need some newtype wrappers.
14:10:46 <vixey> this is the predicament
14:10:52 <orbitz> http://philosecurity.org/2009/01/12/interview-with-an-adware-author scheme shows up in the darndist places
14:10:52 <pumpkin> byorgey: how would those work?
14:11:07 <byorgey> pumpkin: if you say  newtype Foo a = Foo a
14:11:11 <olsner> Saya: the article was in The Monad Reader, issue 6
14:11:15 <byorgey> then you can say  instance (Integral a) => Countable (Foo a)
14:11:25 <Saya> thanks
14:11:35 <byorgey> pumpkin: of course, that means you'll need to add a bunch of Foo constructors in your code.
14:11:36 <pumpkin> byorgey: but then I can't do enumerate :: [Int], right?
14:11:37 <pumpkin> ah
14:11:48 <olsner> Saya: http://www.haskell.org/sitewiki/images/1/14/TMR-Issue6.pdf
14:11:50 <pumpkin> hmm
14:11:52 <Peaker> does anyone here use Reactive?
14:11:59 <byorgey> it isn't a perfect solution, but it's the best we've got.
14:12:04 <pumpkin> byorgey: thanks :)
14:12:06 <Peaker> snapshot_ seems broken still/again?
14:12:17 <blackh1> pumpkin: Paste some code and I'll take a look if you like. I have some experience with typeclass masochism.
14:12:18 <byorgey> pumpkin: the problem is that the instance checking code doesn't to backtracking search.
14:12:24 <byorgey> doesn't *do
14:12:38 <vixey> oh
14:12:38 <Peaker> oh wait, its not snapshot_   integral itself is broken
14:12:46 <vixey> do you know where the idea about typeclasses being similar to Prolog comes from?
14:12:52 <vixey> I've never understood this...
14:12:58 <wli> byorgey: No LogicT for instance checking? :(
14:13:13 <Peaker> vixey: the "unifying types" vs "unifying values" thing?
14:13:22 <pumpkin> blackh1: http://hpaste.org/13898 is the basic idea, but I'd need some way to resolve what to do if something is both bounded and integral
14:13:28 <olsner> vixey: right now I'm thinking about how to take the code generated by the monad and construct a CFG from it
14:13:32 <vixey> no clue I just heard it often
14:13:38 <Apocalisp> @go Haskell adjunctions tutorial
14:13:41 <lambdabot> http://www.haskell.org/haskellwiki/Video_presentations
14:13:41 <lambdabot> Title: Video presentations - HaskellWiki
14:14:00 <byorgey> vixey: well, instance declarations are still very much a sort of goal-oriented logic programming language
14:14:00 <vixey> olsner so it would be a realyl really concise notation for CFGs?
14:14:28 <olsner> then comes trying to do something smart with variables and e.g. transform my mutating-style program into SSA
14:14:28 <byorgey> vixey: it's just that the operational semantics doesn't include backtracking.
14:14:39 <byorgey> at least, not currently.
14:14:48 <byorgey> wli: nope =(
14:15:14 <ehird> so for the people saying tests are obsoleted by haskell ... do show your way to enforce that a function only takes integer arguments in the range 2..5
14:15:20 <olsner> but byorgey and augustss will probably implement the same thing for their LLVM binding before I'm done with my experiments
14:15:24 <ehird> without inventing your own integer type ala church numerals in the type system
14:15:33 <pumpkin> ehird: who says that?
14:15:38 <vixey> hum..
14:15:38 <ehird> people, way up there ;-)
14:15:49 <byorgey> olsner: hm?
14:15:54 <pumpkin> ehird: haskell makes a lot of the basic tests that you test for in other (dynamic) languages obsolete
14:15:58 <pumpkin> but tests are still useful :P
14:16:16 <blackh1> pumpkin: I can see what you're wanting to do but I am not quite enough of a Haskell genius to see how you would do it.  The problem here is that instances pertain to *types* and can't be made to pertain to *type classes*.
14:16:31 <ehird> blackh1: how bot you :)
14:16:34 <ehird> *bout
14:16:39 <pumpkin> blackh1: I can make one of those work with {-# OPTIONS_GHC -XFlexibleInstances -XUndecidableInstances #-}
14:16:45 <pumpkin> but that doesn't make both work :)
14:16:59 <vixey> tip {-# LANGUAGE FlexibleInstances, UndecidableInstances #-}
14:17:02 <pumpkin> ooh
14:17:04 <pumpkin> thanks :)
14:17:30 <sjanssen> ehird: data TwoThroughFive = One | Two | Three | Four | Five
14:17:38 <ehird> sjanssen: fail
14:17:41 <ehird> "without inventing your own integer type ala church numerals in the type system"
14:18:00 <byorgey> also fail because of the One ;)
14:18:00 <jeffwheeler> What does RWS stand for, and when is it used? I can find the documentation, but the link to the website is just a personal page that doesn't talk about RWS.
14:18:01 <sjanssen> ehird: those are not church numerals, and they're not in the type system
14:18:04 <wli> byorgey: Is there any reason why backtracking search would be unsound?
14:18:05 <sjanssen> byorgey: damn
14:18:20 <olsner> byorgey: something like a recursive monad that does SSA transformation for you
14:18:21 <Peaker> ok, Reactivesnapshot is broken, and that's probably why integral is broken too :-(
14:18:23 <ehird> sjanssen: "without inventing your own integer type"
14:18:25 <Peaker> Reactive's snapshot that is
14:18:31 <ehird> next :)
14:18:38 <byorgey> wli: good question. I don't really know.
14:18:43 <blackh1> ehird: I'm not saying tests are obsoleted by Haskell. I'm just saying that a large proportion of them aren't necessary any more.  I've got some code where one user does something to another user.  Since I've defined "user" as only one type (and it doesn't make much sense to get fancy with the types, since the operations all work on any user), Haskell can't stop me from mixing them up.
14:18:48 <SamanthaDega> let fn 2..5 = foo
14:18:54 <SamanthaDega> let fn _ = bar
14:19:03 <ehird> blackh1: sure. but that's structural stuff
14:19:06 <ehird> testing the logic is imporatnt
14:19:21 <sjanssen> fn n | n >= 2 || n <= 5 = ...; | otherwise = error "blah" -- no need for tests
14:19:24 <wli> byorgey: I'd be surprised if there were a problem.
14:19:32 <SamB> thoughtpolice: so are you registering, or is Lemmih doing it, or ?
14:19:39 <jeffwheeler> What happens when you _derive_ Monad, rather than writing the interface?
14:19:43 <jeffwheeler> err, instance
14:19:43 <byorgey> wli: me too.
14:19:48 <blackh1> ehird: Looks like my brother was right when he said "Only test logic!"
14:19:50 <sjanssen> jeffwheeler: you usually can't derive Monad
14:19:51 <thoughtpolice> SamB: I'll do it
14:19:57 <ehird> sjanssen: yes, beacuse that's a compile-time constraint
14:19:58 <thoughtpolice> I /cycle'd and have oper now
14:20:00 <dibblego> jeffwheeler, you can't without a GHC extension
14:20:01 <ehird> err, wait, no it isn't
14:20:03 <jeffwheeler> sjanssen: I'm writing Yi source code that does :-/
14:20:04 <dons> fwiw guys, new company using haskell, http://www.galois.com/blog/2009/01/13/signali-a-custom-ip-design-company/ (press release speak, sorry)
14:20:09 <jeffwheeler> err, reading
14:20:16 <byorgey> jeffwheeler: the only time you can derive Monad is for a newtype which is a wrapper around something which is already a Monad.
14:20:20 <jeffwheeler> It has a bunch of extensions, though.
14:20:30 <sjanssen> jeffwheeler: in that case you're seeing what is called "generalized newtype deriving"
14:20:30 <wli> newtype MyList t = MyList [t] deriving (Functor, Monad)
14:20:31 <Peaker> dons: I used Haskell for some tools at my workplace, if that means anything :-)
14:20:39 <jeffwheeler> sjanssen: ah hmm.
14:20:40 <dons> Peaker: you should come to CUFP!
14:20:41 <byorgey> jeffwheeler: in which case the compiler will generate an instance which wraps & unwraps the newtype constructor appropriately.
14:20:56 <jeffwheeler> byorgey: that seems useful. Are there any docs on that?
14:20:57 <Peaker> looking up CUFP
14:21:06 <thoughtpolice> SamB Lemmih Saizan done
14:21:19 <Peaker> dons: is that a conference?
14:21:25 <sjanssen> ehird: anyway, I don't think anyone actually claims testing isn't necessary in Haskell
14:21:37 <ehird> mm
14:21:38 <dons> yeah.
14:21:46 <byorgey> jeffwheeler: http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#newtype-deriving
14:21:47 <dons> testing is very necessary.
14:21:54 <dons> and we have quickcheck, which makes it fun.
14:21:59 <pumpkin> boo, I guess I'll give up on doing typeclasses for countable
14:22:04 <jeffwheeler> byorgey: great, thanks :
14:22:06 <jeffwheeler> * :)
14:22:07 <thoughtpolice> Saizan: you can rejoin
14:22:08 <Peaker> dons: where is it physically?
14:22:09 <jeffwheeler> (I can't type today.)
14:22:16 <dons> Peaker: it'll be in Edinburgh this year
14:22:20 <ehird> dons: i'm talking about TDD
14:22:44 <Peaker> dons: I don't think my workplace will fund such a flight
14:22:59 <byorgey> Peaker: maybe they will fund a boat instead
14:23:02 <wli> One could actually examine the structure of types in more detail and derive Monad and Functor from that.
14:23:09 <ddarius> dons: "world reknown", isn't globalization and the internet great
14:23:31 <dons> hehe
14:23:51 <dons> as seen on #haskell!
14:24:07 <pumpkin> @instances Integral
14:24:08 <lambdabot> Int, Integer
14:24:39 <sw17ch> dons: regarding the podcast, did #haskell really have that big of an influence?
14:24:41 <blackh1> ehird: If you do any TDD in Haskell, tell me what your experiences are.
14:24:51 <ehird> blackh1: I intend to :)
14:25:13 <wli> data AlgType t = Injection t | Aggregation (SomeAggregate (AlgType t)), return = Injection, etc.
14:25:18 <sjanssen> TDD seems like extreme programming wankery
14:25:18 <dons> sw17ch: in what sense?
14:25:33 <wli> Basically by checking out the details of the algebraic data type.
14:25:36 <dons> man we wrote a lot of tests for xmonad.
14:25:44 <ehird> sjanssen: ... which is an excellent way to dismiss things you don't like the sound of...
14:25:48 <sw17ch> dons: i guess i hadn't realized the amount of impact #haskell has had on the overall Haskell community
14:25:49 <Peaker> I think I'm going to try to sell functional programming to my coworkers with some lecture or so. IMO Haskell's best seller is Reactive and the amazing things you can build with it in no time, but I wonder if I can directly show Reactive code to people who've never seen functional programming
14:25:50 <dons> sjanssen loves tests.
14:25:59 <sjanssen> dons: yeah, but we didn't follow TDD
14:26:03 <dons> sw17ch: i think its been important to help foster collaboration
14:26:07 <sjanssen> code came first, then tests to make sure the code makes sense
14:26:11 <dons> yeah.
14:26:13 <SamB> DDT is a better idea
14:26:30 <SamB> no, not the horrible poluttant
14:26:34 <blackh1> sjanssen: I'll eat worms if it makes my programs work better.
14:26:36 <SamB> Design Driven Testing
14:27:00 <Peaker> ehird: TDD is nice, but not that much of a big deal, IMO.  In dynamic languages, its much more important
14:27:01 <SamanthaDega> Learn I a Haskell for Great Good, and have syntax question for personal good. (less hair loss)
14:27:25 <Peaker> SamanthaDega: Have answer only for questions asked, not questions in future monad
14:27:26 <sw17ch> TDD replaces a TypeChecker in Ruby
14:27:40 <sw17ch> (or that's how i understand it)
14:27:48 <ehird> sw17ch: not IMO.
14:27:52 <ehird> also, tdd didn't originate in ruby.
14:27:58 <SamanthaDega> Well, er.
14:28:16 <byorgey> SamanthaDega: i.e., ask away =)
14:28:26 <blackh1> Peaker: I am not so sure. I think TDD would have value even in the mighty Haskell but I don't have the experience yet to evaluate that claim.
14:28:31 <sjanssen> sw17ch: the implication that TDD is a sufficient replacement for a proper type checker is erroneous :)
14:28:37 <byorgey> SamanthaDega: if you have a question about some specific code you can paste it on hpaste.org
14:28:41 <ehird> The implication of the reverse is too.
14:28:43 <sw17ch> sjanssen: agreed, i appologize
14:29:04 <sw17ch> the fact that my long-running ruby processes have the tendancy to explode in corner cases infuriates me to no end
14:29:12 <sjanssen> it is true that in dynamic languages, you'll need to test certain things that are statically assured by the type system
14:29:16 * loadquo searches on hoogle for functions of type Future s -> s
14:29:21 <sw17ch> the amount of tests needed to replace a proper typechecker is huge
14:29:39 <sjanssen> sw17ch: possibly infinite?
14:29:49 <sw17ch> very likely
14:29:54 <Peaker> blackh1: I am not saying it has no value, just much less of a value. Haskell kind of forces you to think before you type, and most TDD stuff wouldn't even compile before you finish writing the whole unit you're testing, so I don't think it matters if you first satisfy the types, and then write the tests, or vice versa
14:29:56 <SamanthaDega> I defined a fn that takes two arguments, and want to pass the result of another function, but the compiler assumes that I want to pass the other function to the first function instead of it's result. How I explain Great Good to compiler?
14:30:24 <byorgey> SamanthaDega: use parentheses!
14:30:26 <loadquo> Enclose the other function in brackets ()
14:30:28 <ehird> [[and most TDD stuff wouldn't even compile before you finish writing the whole unit you're testing]]
14:30:33 <ehird> that's a failing test :-)
14:30:34 <byorgey> firstFunction (otherFunction blah) foo
14:30:51 <wli> What's TDD vs. DDT?
14:30:54 <sw17ch> i usually stop paying attention to testers when they start asking me to write mock functions
14:31:03 <sw17ch> perhaps i need to pay attention again?
14:31:19 <ehird> testers: almost as bad an epidemic as jews. :-|
14:31:28 <byorgey> sjanssen, sw17ch: TDD replaces a type checker in Ruby in the same way that a strong drink replaces sorrows.
14:31:40 <Peaker> ehird: tactful
14:31:42 <blackh1> Peaker: 'undefined' is brilliant for writing stubs (thanks RWH!). I think Haskell squeezes the design out of you in the same way that TDD does. The question is - how do you synergizeify the two together, rather than just using tests after the fact to plug the gaps? That is, get some real advantage from TDD.
14:31:45 <sjanssen> byorgey: heh.  Be sure to put that in the next HWN
14:31:49 <ehird> Peaker: tactful would be my middle name
14:31:52 <byorgey> ok, I will =)
14:31:56 <idnar> blackh1: "synergizeify"?!?
14:32:06 <sjanssen> @remember byorgey TDD replaces a type checker in Ruby in the same way that a strong drink replaces sorrows.
14:32:06 <lambdabot> Good to know.
14:32:07 <blackh1> blackh1: I spent 8 months in the USA. :)
14:32:11 <blackh1> idnar:
14:32:15 <ehird> ehird: Hi!
14:32:15 <blackh1> I am talking to myself again
14:32:15 <sw17ch> byorgey: if you use enough "strong drink" you can erase the reference to the sorrows, so they get GC'ed
14:32:49 <Peaker> blackh1: I think its hard to know what the gaps are until its fully typed, which probably usually means its fully designed
14:33:01 <SamanthaDega> And. Use the right function call :p Feel silly, thx
14:33:14 <byorgey> sw17ch: the problem is you usually end up with some null pointer dereferences too.
14:34:48 <sw17ch> byorgey: yes, that would explain the fact you can't remember everything after too many strong drinks
14:34:55 <blackh1> Peaker: I think you are right.  TDD and Haskell types are doing the same kind of thing for you.  Haskell types do it better but less completely.  My question is - is it possible to start with logic tests (as per TDD) and then think about types?
14:35:00 <kerlo> @index PortNumber
14:35:00 <lambdabot> Network, Network.Socket, Network.BSD, Network
14:35:07 <ehird> dcoutts_: how come "make install" doesn't work with gtk2hs?
14:35:21 <ehird> blackh1: no
14:35:30 <ehird> type, then test/design, then implementation
14:35:38 <Peaker> blackh1: yes, but then you might find some of the logic tests are redundant because you found a way to model that test as type proof, and you will have to re-factor/fix the test code when the api changes due to the design/types
14:35:42 <ehird> type is the high-level design of the function, the test the smaller parts
14:35:52 <ehird> and the implementation...
14:35:53 <ehird> the implementation.
14:36:51 <SamanthaDega> er
14:36:57 <kerlo> I have a feeling Hugs' modules come separately from Hugs itself when you apt-get it.
14:37:30 <ehird> i have a feeling using hugs is grounds for the death penalty
14:37:44 <ehird> :D
14:37:49 <kerlo> I have a feeling using GHC on normish.org is nearly impossible.
14:37:59 <kerlo> I've tried and failed; therefore, it's nearly impossible.
14:38:04 <ehird> kerlo: Just apt-get it...
14:38:10 <ehird> There's nothing to do with xen that would break it.
14:38:24 <kerlo> I did apt-get ghc. It doesn't work.
14:38:35 <ehird> Then you did something wrong.
14:39:00 <Peaker> kerlo: what about ghc specifically failed?
14:39:03 <kerlo> Well, I don't want to fix it.
14:39:14 <ehird> great. I don't want to fix your haskell problem :D
14:39:20 <ehird> [I know kerlo from another channel]
14:39:32 <ehird> kerlo: The package is ghc6
14:39:33 <ehird> Not ghc.
14:39:36 <kerlo> ghc-6.8.2: internal error: R_X86_64_32S relocation out of range: (noname) = 0x7fce360e54f8
14:39:41 <sjanssen> kerlo: there are all sorts of extra libraries you can install, see libhugs*
14:39:57 <blackh1> Peaker: Is it possible to 1. anticipate what Haskell can't check - because you know that it isn't type-checkable, then 2. write tests for that, then 3. code the Haskell?  I think this must be possible.
14:39:58 <kerlo> sjanssen: do you think "apt-get install libhugs*" would get them all?
14:40:13 <ehird> kerlo: That would be dumb.
14:40:14 <SamanthaDega> it is always safe to assume that other programmers are both more stupid and more daring than you, and write code accordindly. Speaking of which I have a "div_vector foo bar =" prototype. Is the proper way to protect it "div_vector foo 0 = error"?
14:40:25 <kerlo> ehird: elucidate.
14:40:33 <sjanssen> kerlo: I don't know that much about apt.  Just "apt-cache search hugs", then install the ones you might use
14:40:35 <ehird> kerlo: do you install all python libraries when setting up python?
14:40:39 <ehird> Well, don't answer that.
14:40:41 <Peaker> blackh1: I don't know - I think there are very creative things you can do with Haskell types, and its not clear exactly what kind of properties you will be able to verify with the type system
14:40:56 <Peaker> blackh1: (before hand)
14:41:19 <ehird> kerlo: A better idea would be to get ghc working.
14:41:21 <sjanssen> blackh1: you can know exactly what Haskell will check -- that all values are members of their type
14:41:46 <kerlo> These all look good. I think I'll get them all. :-P
14:41:46 <Peaker> kerlo: what's your apt-get repo, Debian or Ubuntu or ?
14:42:17 <kerlo> Peaker: Debian, I guess.
14:42:27 <kerlo> I assume that a Debian machine would use Debian.
14:42:33 <blackh1> Peaker & sjanssen: In my connect4 program, I've got some logic that searches for winning counter positions. This is a good example of something that you can anticipate Haskell will not check for you.  So if you can conceive of that, that would make a good TDD-style test.
14:43:08 <blackh1> Peaker & sjanssen: "Board" is a type and "counter" is a type, but the relationship between one counter and another is NOT a type.
14:43:15 <ehird> kerlo: umm
14:43:16 <Peaker> kerlo: their ghc package must be broken then. ghc from Ubuntu worked for me, though I've since removed all the Haskell-related packages and installed ghc/etc manually into /usr/local to get newer stuff.  Its not hard - you can install the ghc-6.10 binaries with "configure --prefix=/usr/local ; make install"
14:43:18 <ehird> normish is on ubuntu
14:43:20 <ehird> last I checked
14:43:29 <kerlo> Really?
14:43:29 <ehird> Peaker: he's on a 256MB of ram vps
14:43:33 <ehird> with not much cpu.
14:43:39 <ehird> compiling ghc tops the list of Dumb Ideas
14:43:53 <SamanthaDega> kerlo: which dist are you using? testing is frequently broke
14:44:01 <rwbarton> looks like this bug: http://hackage.haskell.org/trac/ghc/ticket/2512
14:44:03 <ehird> he's using ubuntu.
14:44:17 <ehird> I know this because $ apt-cache show ubuntu-minimal returned a package.
14:44:35 <blackh1> ehird: I have a virtual server and I had to compile ghc on it.  It was very annoying because I ran out of disk space.  I want to change to a Debian server.
14:44:43 <kerlo> Linux version 2.6.24-19-xen (buildd@king) (gcc version 4.2.3 (Ubuntu 4.2.3-2ubuntu7)) #1 SMP Wed Aug 20 21:08:51 UTC 2008
14:45:17 <sjanssen> rwbarton: good call
14:45:24 <ehird> kerlo: only ghci is broken
14:45:25 <ehird> ghc works
14:45:31 <ehird> ehird@normish:~$ cat>test.hs
14:45:31 <ehird> main = print "hi"
14:45:32 <ehird> ehird@normish:~$ ghc test.hs
14:45:34 <ehird> ehird@normish:~$ ./a.out
14:45:36 <ehird> "hi"
14:45:43 <kerlo> Good to know.
14:45:51 <ehird> so. probably easily fixable.
14:46:13 <ehird> kerlo: try apt-get update or whatever
14:46:17 <ehird> there might be a new package fixing it
14:46:30 <kerlo> I think this isn't fixed until GHC 6.11.
14:46:52 <ehird> i beg to differ, because a patch has been committed.
14:46:56 <ehird> and the milestone was 6.10.2.
14:46:58 <rwbarton> this seems to have been fixed in Nov 2008, so not in 6.10.1
14:46:59 <SamanthaDega> apt-get update;apt-get upgrade
14:47:03 <rwbarton> ehird: which isn't released yet
14:47:08 <ehird> rwbarton: sure.
14:47:12 <sjanssen> ehird: ubuntu is still stuck at 6.8.2, anyway
14:47:13 <ehird> but it might be in ubuntu's version.
14:47:26 <ehird> since package-breaking bugs are presumably fixed
14:47:28 * kerlo tries plain old GHC
14:47:37 * rwbarton is entertained by that notion
14:48:23 <ehird> So. I need an infinite efficient mutable sparse array in N dimensions (settable at runtime), that I can use as a lahey space
14:48:28 * kerlo does a chmod -x `which ghc`
14:48:30 <ehird> suggestions welcome >:D
14:48:53 <kerlo> Oh, that doesn't actually make bash not want to run that.
14:50:48 * sw17ch always finds that he wants somethign similar to undefined in C
14:51:00 <ehird> i guess nobody knows about such wizardry :)
14:51:02 <gwern> :t undefined
14:51:03 <sjanssen> *NULL?
14:51:03 <lambdabot> forall a. a
14:51:27 <gwern> I always wonder how ghc decides on typesig format
14:51:28 <sw17ch> sjanssen: yes, but without the burdon of having to allocate memory to store in there when it finally becomes valid :)
14:51:38 <gwern> especially the ones that include the package-name in the type sig
14:51:48 * sw17ch doesn't have the luxury of malloc on his micro...
14:52:07 * sw17ch has to use a bunch of static-length buffers for his interrupt vector....
14:52:16 * SamanthaDega deep thought ++gin infinite, efficient and sparse, and hoovered from data source at runtime.
14:52:17 <thomashartman1> I'm getting this error: GHCi runtime linker: fatal error: I found a duplicate definition for symbol
14:52:17 <thomashartman1>    waitForProcess
14:52:18 <thomashartman1> whilst processing object file
14:52:22 <thomashartman1> ... hsprocess.
14:52:25 <erikc> sw17ch: i have a maybe<T> template class for that which contains enough storage for T :)
14:52:31 <dcoutts> ehird: in what way does "make install" not work for gtk2hs? release version or darcs version?
14:52:41 <ehird> dcoutts: release. It just does exactly what "make" does
14:52:47 <erikc> i guess thats c++ tho
14:52:51 <sw17ch> erikc: i'm not sure if even that could tempt me to play with C++ :P
14:52:57 <erikc> haha
14:52:57 <sw17ch> no, i'm kidding
14:53:03 <sw17ch> C++ is a fine tool when properly used
14:53:06 <pumpkin> there should be an IEEE754 typeclass
14:53:11 <blackh1> sw17ch: Bollocks!
14:53:16 <dcoutts> ehird: 0.9.13? it works for other people, any more details?
14:53:26 <ehird> dcoutts: none i am afraid :-) it looks ok in the MAkefile
14:53:31 <orbitz> C++ is the devils illegitimate step child
14:53:33 <thomashartman1> Seems like a case for ghc-pkg unregister but then there are dependencies and I keep having to unregister more and more things.
14:53:55 <pumpkin> orbitz: don't forget, it's red-headed too
14:53:56 <SamanthaDega> C++ is C with extra fun added retardation
14:53:56 <sw17ch> orbitz: if that bastard child can make my program better, i have no problem making deals with his father
14:54:00 <sjanssen> thomashartman1: sounds like you're trying to use multiple versions of the process library simultaneously
14:54:01 <thomashartman1> I'd lik to just do mv .cabal .cabal.bak and start over with a clean blank slate, but that gives me error, missing cabal dir.
14:54:03 <dcoutts> ehird: I've no idea, check the gtk2hs users archives
14:54:08 <ehird> dcoutts: OK :)
14:54:15 <orbitz> pumpkin: oh god, red headed!!!!
14:54:30 <ddarius> blackh1: It's not a matter of what Haskell's type system -can- check, it's a matter of economics.  What is cheaper/easier to check using the type system and what isn't.
14:54:42 <erikc> sw17ch: where M and N are static upper bounds :), template <typename T, int M, int N> fixed_list<T, M+N> concat(fixed_list<T, M>, fixed_list<T, N>);
14:54:43 <pumpkin> does anyone know a good way of fully enumerating an IEEE 754 float without just iterating over the 32-bit number behind it?
14:54:43 * sbahra firmly slaps orbitz on his right butt cheek 
14:55:13 <sw17ch> erikc: and this is for maybe?
14:55:15 <orbitz> sbahra: don't forge tmy left tootz
14:55:18 <thomashartman1> sjannsen, seems you're right.
14:55:25 <gwern> red-headed? no wonder so many people have the hots for it
14:55:33 <thomashartman1> Any way out of this than just keep unregistering till things are clean?
14:55:42 <ddarius> > [minBound .. maxBound] :: Double
14:55:43 <lambdabot>   Couldn't match expected type `Double' against inferred type `[a]'
14:55:47 <erikc> sw17ch: nah, another part of my library of static bounded memory types + functions
14:55:51 <ddarius> > [minBound .. maxBound] :: [Double]
14:55:52 <lambdabot>       No instance for (Bounded Double)
14:55:52 <lambdabot>        arising from a use of `minBound...
14:55:56 <sjanssen> thomashartman1: so you just need to find out which things depend on the obsolete versions of process, and rebuild them against the newer process
14:55:57 <blackh1> ddarius: I wonder if experience might show that TDD is good at the things Haskell is bad at, and vice versa.  I have done some simple but clever things with Haskell types, and when I think about them, it would be hopeless to test these things with unit testing.
14:56:29 <Peaker> ddarius: that won't enumerate all possibilities though
14:56:31 <thomashartman1> sjannsen, quite a lot: ghc-pkg unregister process-1.0.1.0
14:56:31 <thomashartman1> ghc-pkg: unregistering process-1.0.1.0 would break the following packages: haddock-2.3.0 Cabal-1.6.0.1 haskell98-1.0.1.0 h\
14:56:31 <thomashartman1> askell-src-1.0.1.3 ghc-6.10.1 HaXml-1.13.3 hscolour-1.10.1 polyparse-1.1 HaXml-1.19.4 xml-parsec-1.0.3 DarcsHelpers-0.1 Mi\
14:56:31 <thomashartman1> ssingH-1.0.2.1 HAppS-Data-0.9.3 HAppS-State-0.9.3 HAppS-IxSet-0.9.3 PBKDF2-0.2 PBKDF2-0.3 HStringTemplateHelpers-0.0.7 HSH\
14:56:32 <ddarius> blackh1: They overlap, but testing (though not necessarily TDD) is certainly necessary and useful.
14:56:34 <thomashartman1> Helpers-0.18 MissingH-1.0.3 HSH-1.2.6 HStringTemplateHelpers-0.0.10 HAppS-Server-0.9.3.1 HAppSHelpers-0.10 (use --force to\
14:56:38 <thomashartman1>  override)
14:56:38 <ddarius> Peaker: You'd be surprised...
14:57:00 <thomashartman1> sorry, should have pasted.
14:57:01 <Peaker> ddarius: I thought [..] on Doubles defaulted to a step of 1?
14:57:17 <thomashartman1> So for each of these packages, ghc-pkg unregister and cabal install?
14:57:25 <ehird> thomashartman1: er, no
14:57:28 <ehird> because that includes cabal
14:57:29 <ehird> :^)
14:57:52 <rwbarton> just cabal install --reinstall, I think
14:57:54 <blackh1> ddarius: The best thing about TDD (as explained to me by my guru brother) is that when followed, it makes it really difficult to forget to test something.  That's what I'm concerned about.  If you add the tests later, you don't get this advantage.
14:57:57 <rwbarton> that's my usual approach
14:58:12 <ehird> nobody likes helping my crazy array needs :D
14:58:15 <ddarius> > [1,2] :: [Double]
14:58:17 <lambdabot>   [1.0,2.0]
14:58:23 <thomashartman1> rwbarton: cabal install --reinstall each package that depends on the outdated process?
14:58:41 <ddarius> Maybe it was Fixed, but I could have sworn it was a standard type.
14:58:43 <rwbarton> thomashartman1: yeah, that's what I usually do... but that is a *lot* of packages
14:58:52 <Peaker> ddarius: so its skipping the various values between 1.0 and 2.0 that Double can represent?
14:59:09 <thomashartman1> yes. Hence my desire to just start from scratch.
14:59:17 <ddarius> > [1,2] :: [Fixed E12]
14:59:18 <dcoutts> thomashartman1: if you unregister process and then cabal install all of the broken packages then it should do it all, in one command.
14:59:18 <lambdabot>       Ambiguous occurrence `Fixed'
14:59:18 <lambdabot>      It could refer to either `Data.Fixed....
14:59:23 <ddarius> > [1,2] :: [Data.Fixed E12]
14:59:25 <lambdabot>       Failed to load interface for `Data':
14:59:25 <lambdabot>        Use -v to see a list of the...
14:59:28 <ddarius> > [1,2] :: [Data.Fixed.Fixed E12]
14:59:29 <lambdabot>   [1.000000000000,2.000000000000]
14:59:32 <ddarius> Hmm.
14:59:42 <rwbarton> > [1..2] :: [Data.Fixed.Fixed E12]
14:59:44 <lambdabot>   [1.000000000000,1.000000000001,1.000000000002,1.000000000003,1.000000000004...
14:59:45 <thomashartman1> dcoutts, won't let me unregister unless I force. should I force?
14:59:53 <ddarius> Oh, duh.
15:00:10 <ddarius> > [1..2] :: [Double]
15:00:11 <lambdabot>   [1.0,2.0]
15:00:12 <dcoutts> thomashartman1: if you really think that package was registered in error, and if it's in your user package db then it probably was in error.
15:00:18 <Peaker> blackh1: if you're serious about testing, you should keep a good matrix of functionality and tests, and see that it has no holes _over time_.  Having all the tests in the first place is not nearly enough.. Code changes are not theoretic, and they are the ones that carry the true risks of bugs, moreso than the initial code
15:00:52 <Peaker> ddarius: what's Data.Fixed and what's E12? :)
15:01:01 <dcoutts> thomashartman1: then ghc-pkg list  will show you all the broken packages in {}'s, then cabal install --dry-run that list, no need to use --reinstall because cabal can see that they're broken and need re-installing.
15:01:17 <baaba> fixed point numbers?
15:01:24 * SamanthaDega over thought that, was thinking array of scalable m by scalable n. And no unused heap. Which would be ideal for you circumstances but still theoretical.
15:01:29 <baaba> i take it E12 is 20.12
15:01:38 <dpratt71> installing GHC for the first time...
15:01:51 <baaba> er no wait, that wouldn't have so many digits of precision
15:02:02 <dpratt71> ...will I regret changing the install path?
15:02:08 <dpratt71> this is on Windows
15:02:21 <thomashartman1> dcoutts, thx, I'm did ghc-pkg unregister --force process-1.whatever (the old version) and reinstalling everything I need
15:02:28 <SamanthaDega> you have enough regrets already...
15:02:33 <SamanthaDega> Windows...
15:02:38 <dpratt71> :P
15:03:54 * SamanthaDega hugs dpratt71
15:04:08 <dpratt71> :)
15:05:01 <rwbarton> Peaker: E12 is a phantom type that represents "12 digits of precision"
15:05:36 <ehird> doo doo
15:05:48 <vixey> why not E Twelve
15:06:50 <Peaker> vixey: the digit system is probably nicer than english names of numbers
15:08:55 <dpratt71> Prelude> "I am drunk with power!"
15:09:34 <kerlo> Use the lojban digit system. "E Pare"
15:10:18 <SamanthaDega> Kewl... dpratt71 & power cocktail. Makes a change from a martini
15:10:51 <dpratt71> :)
15:10:54 <kerlo> 0-9 are no, pa, re, ci, vo, mu, xa, zu, bi, so.
15:11:16 <dublpaws> ghc compiler messages have an English accent.
15:11:20 <lament> do, re, mi, fa, sol, la, ti, do
15:12:22 <ehird> i think I'll ask it again in case some more evil geniuses turned up since last time
15:12:25 <Peaker> lilac: ping
15:12:25 <ehird> I need an infinite efficient mutable sparse array in N dimensions (settable at runtime), that I can use as a lahey space. :D
15:12:37 <dons> it is an interesting exercise to work out how many of these are type errors: http://www.sans.org/top25errors//?cat=top25#cat1
15:12:42 <SamanthaDega> You know, I'm surrounded by Glaswegian that might tke offense if they had a clue about Haskell
15:12:44 <dons> top 25 security errors, identified by NSA et al.
15:13:01 <kerlo> And if you feel like going farther than the decimal digits, 10-15 are dau, fei, gai, jau, rei, vai.
15:13:11 <dmwit> ehird: Map?
15:13:41 <ehird> dmwit: Fails at: efficient (for heavy mutation, thus mutation too), N dimensions at runtime, lahey space
15:13:57 <ddarius> dons: I suspect many would be adequately handled by memory-safety.
15:14:00 <dmwit> It doesn't fail at N dimensions: use a list as your key.
15:14:17 <lispy> ehird: a function built at run-time?
15:14:29 <dmwit> I have no idea what lahey space means; can you specify a bit more what you need there?
15:14:53 <ehird> dmwit: True;  lispy: That does worse :-);  dmwit: You don't _want_ to know... http://quadium.net/funge/spec98.html#Lahey
15:15:03 <ehird> Of course, you'll have to read the rest of the spec to have the faintest idea what that's talking about.
15:15:07 <ehird> And then you'll go insane.
15:15:28 <sjanssen> ehird: what does the CS literature recommend?
15:15:52 <ehird> sjanssen: You know what, the day someone writes CS literature about Funge-98 is the day I will become a hermit
15:15:57 <ehird> ;-)
15:16:06 <Badger> heh
15:16:17 <Adamant> dons: the whole idea of types is to catch as many errors as possible, so it's not surprising that some errors are also type errors
15:16:38 <ehird> dmwit: Basically, Lahey space is both infinite and wrapped.
15:16:57 <dons> Adamant: indeed. it isn't surprising, and good to see these identified
15:17:10 <dmwit> ehird: So, a torus, then.
15:17:16 <ehird> dmwit: nope
15:17:17 <sjanssen> ehird: have you actually tested Data.Map and determined that it is not suitable?
15:17:20 <Peaker> Adamant: its interesting to explore what real-world errors could be prevented, though
15:17:25 <ehird> Befunge-93 was a torus, I believe.
15:17:27 <Adamant> dons: if it will actually get any real world action it would be good
15:17:45 <ehird> sjanssen: no, I'm planning, which is why I asked
15:17:55 <ddarius> ehird: I would actually be surprised if there wasn't a paper somewhere about it or a closely related language.
15:17:57 <ehird> but the mutation _will_ be heavy
15:18:01 <Adamant> this particular Karnak sez that only the legislative requirement will get any official pickup
15:18:17 <ehird> ddarius: Heh, I'd like to hear of it...
15:18:23 <rwbarton> from that page: "Lahey-Space is a mathematical model of the space used in Funge-98" <-- that is a lie
15:18:30 <ehird> rwbarton: is it now
15:18:31 <sjanssen> ehird: Data.Map can do dimensions chosen at run time, you just have to be clever about it
15:18:33 <rwbarton> Yes
15:18:41 <ehird> rwbarton: I see
15:18:49 <rwbarton> There is no math in the subsequent section
15:19:05 <ehird> ..
15:19:14 <Adamant> anything related to code injection can be done as a type error, I think
15:19:48 * dmwit feels inclined to agree with rwbarton
15:19:49 <Adamant> either allowing too large input or allowing input in another language
15:19:52 <dmwit> as usual
15:20:10 <dpratt71> maybe I need a break from this Haskell stuff...
15:20:13 <thomashartman1> dcoutts, I think you need reinstall after all: http://hpaste.org/13900
15:20:41 <SamanthaDega> aww
15:20:58 <dpratt71> ...I'm reading about Lahey spaces and thinking "this sounds like a Monad"
15:21:15 * SamanthaDega hugz dpratt71 again while he's still here
15:21:22 <dpratt71> :)
15:22:14 <dcoutts> thomashartman1: but note that there are non-broken versions of those packages installed
15:22:32 <dcoutts> thomashartman1: so to rebuild the broken versions you can use specific versions when you ask cabal to install
15:22:49 <dcoutts> thomashartman1: that is if you need those particular versions, otherwise just unregister them
15:23:57 <thomashartman1> ah
15:25:48 <SamanthaDega> ehird: take your array and fill it with #    Wheeeee!
15:26:09 <ehird> 35	#	Trampoline	 	 	pos <- pos + delta
15:26:10 <ehird> :-P
15:26:55 <jeffwheeler> Implementing Monoid (a -> a) is clever.
15:27:18 <vixey> is it?
15:27:23 <augustss> is it?
15:27:23 <vixey> why
15:27:25 <jeffwheeler> Probably useless, but neat. :P
15:27:36 <vixey> mzero = id ; mplus = (.) ?
15:27:38 <jeffwheeler> I saw it in a paper; id and (.) for mempty and mappend
15:27:56 <vixey> hey aren't mempty and mappend weird names?
15:28:04 <jeffwheeler> They are!
15:28:15 <vixey> I guess zero and plus are arbitrary though, because one and product would make sense too
15:28:36 <jeffwheeler> I am trying to figure out about RWS; I've seen it used, but I have no idea what it does.
15:28:43 <SamanthaDega> ehird: I totally see your problem. If you put in any kind of limit, then with this programming langauge someone will hit the limit and try toi keep going
15:28:48 <jeffwheeler> So . . . I'm reading the paper about it, which moves _really_ slowly.
15:29:15 <ehird> SamanthaDega: Clearly you have never read a funge-98 program :-)
15:29:24 <SamB> jeffwheeler: well, unfortunately there's another claimant for Monoid on (->) ...
15:29:33 <ehird> In case you hate yourself: http://users.tkk.fi/~mniemenm/files/befunge/mycology/mycology.zip
15:29:41 <jeffwheeler> SamB: What?
15:30:02 <ddarius> @instances Monoid
15:30:03 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
15:30:16 <SamB> Monoid b => Monoid (a -> b)
15:30:27 <erikc> i thought RWS was just a stack of reader, writer, state monads
15:30:33 <SamB> which is in fact quite usefull
15:30:40 <jeffwheeler> erikc: Could very well be. I'm in over my head.
15:30:41 <vixey> Monoid a => Monoid (a -> b)
15:30:55 <sjanssen>  vixey Monoid b => Monoid (a -> b)
15:31:08 <SamB> erikc: jeffwheeler: I believe it is more-or-less equivalent to such a stack
15:31:13 <SamB> but I'm not sure which one
15:31:25 <ddarius> erikc: It is essentially.
15:31:26 <SamB> (or doesn't it matter ?)
15:31:39 <dmwit> It's all three.
15:31:48 * ddarius has never used RWS and doesn't intend to change that.
15:31:52 <dmwit> Oh, which stack.
15:32:05 <dmwit> It shouldn't matter which order you stack them in.
15:33:24 <SamanthaDega> ehird: is this your code?
15:33:33 <ehird> SamanthaDega: Nah... Deewiant's (he's in here)
15:33:50 <ehird> It's a program that tests befunge-98 interpreters.
15:34:01 <ehird> (mycology.b98 is the main file)
15:34:54 <SamanthaDega> and my terminal ain't wide enough so it looks like even more spaghetti.
15:35:03 * gwern sighs. 3 steps forward, 2 back. I've risen to two failing tests now by fixing all those errors
15:35:12 <ehird> SamanthaDega: It looks like spaghetti anyway.
15:35:38 <SamanthaDega> I had assumed that :)
15:35:48 <ehird> SamanthaDega: in case you're alive after looking at that, here's a befunge-98 irc bot that interprets brainfuck code: http://zem.fi/~fis/fungot.b98.txt
15:36:36 <gwern> @bf ++--
15:36:36 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
15:36:41 <gwern> hm
15:36:53 * SamanthaDega glurks
15:36:58 <ehird> Yeah I don't think writing one in Haskell quite matches gwern ;-)
15:37:20 <SamanthaDega> If I'm alive after forgetting to mix my gin, your code can't harm me!
15:37:41 <gwern> well, haskell *does* have a bf impl, just for the record
15:38:18 <gwern> whew, dcoutts has been busy today
15:38:53 * SamanthaDega likes the use of double facing trampolines in the third line
15:38:56 <lament> ehird: that's some ridiculously sparse code
15:39:07 <lament> it looks more like lisp than befunge!
15:39:09 <ehird> lament: I never said fungot was idiomatic :D
15:39:14 <dcoutts> gwern: mm :-)
15:39:16 <ehird> (not my code)
15:39:26 <Holle_> after importing a record data type into a modul i can't use the get methods of the fields.
15:39:52 * ehird wonders if there's something like IOMap
15:40:48 <Axman6> dons: you around by any chance? i was wondering you might be able to give me a hand later with that n-body thing (mainly trying to figure out STArrays, and getting my data into them etc.)
15:40:54 <gwern> @seen dons
15:40:55 <lambdabot> dons is in #concatenative, #arch-haskell, #novalang, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 23m 57s ago.
15:41:24 <ehird> i mean, surely somebody's needed an iomap? :)
15:41:57 <Holle_> ehird: do you mean me?
15:42:06 <ehird> err.  maybe?
15:42:33 <Holle_> what is iomap and why i can't use the predefined functions?
15:42:38 <ehird> oh.
15:42:41 <ehird> I was not talking to you.
15:42:42 <dons> Axman6: i'll look at code if you send it over.
15:42:43 <ehird> :)
15:42:55 <dons> though am kinda tired today.
15:43:14 <dmwit> Holle_: Maybe you should paste.
15:43:16 <dmwit> ?hpaste
15:43:16 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:43:17 <Axman6> thats fine, so am i. and it's a hot day here in canberra, 37C -_-
15:43:28 <int80_h> qqq
15:43:33 <dons> nice.
15:43:37 <int80_h> wierd
15:43:46 <SamanthaDega> hey, the double trampoline I spotted isn't nearly as complicated as I thought. I'm sure this code could be compressed somewhat and made even more unreadable.
15:43:46 <dmwit> Holle_: Note that, if you are explicitly importing the type, you can import types, constructors, and accessor functions separately.
15:43:53 <dons> it is 10C here.
15:44:02 <dcoutts> dons: I need marketing help with getting more cabal, hackage, platform hackers. There are not enough of us.
15:44:10 <dons> yeah :/
15:44:18 <ehird> SamanthaDega: yeah, fizzie says fungot is made more to work than to be nice befunge :-)
15:44:22 <rwbarton> Holle_: You can also export those things separately
15:44:26 <Axman6> http://hpaste.org/13902
15:44:26 <ehird> it's in #esoteric if you're interested
15:44:28 <Holle_> http://hpaste.org/13901
15:44:28 <jeffwheeler> Either this is really obvious, or not possible: I'm running into cyclical imports where I need a Config type from Config.hs, and another A from A.hs; but both use the other.
15:44:32 <dcoutts> dons: I improved the developer starter info list on the wiki a bit
15:44:34 <dons> i think as with most things, we need to do the hard stuff, and the devs will follow
15:44:43 <jeffwheeler> If I put everything in the same file, it'd work, but be really ugly.
15:44:48 <Holle_> i want to use Area in module Game.Map
15:44:54 <dcoutts> dons: yes, though there are lots of relatively independent bits
15:44:55 <dons> that, or  invent cloning devices
15:44:59 <dcoutts> heh heh
15:45:10 <jeffwheeler> How can I avoid cyclical imports like in that case?
15:45:15 <int80_h> what's the platform reference?
15:45:16 <cknapp> It's -12C here...
15:45:17 <dcoutts> Saizan: what are you doing with your spare Haskell hacking time? :-)
15:45:25 <rwbarton> Holle_: If you want to export everything that the data Area declaration defines, then in your export list, write  Area(..)  instead of  Area
15:45:36 <dcoutts> Saizan: want to help with the new happs-based hackage-server?
15:46:04 <Holle_> rwbarton: great. thanks :)
15:46:05 <Axman6> dons: as you can see, i've nicked a bit of your code. i just don't know enough about ST and STArrays to do very much
15:46:10 <dons> ok. great.
15:46:13 <ehird> hmm
15:46:14 <dons> does it compute the right answer
15:46:15 <dons> ?
15:46:37 <Axman6> at the moment, it doesn't compute anything really :\
15:46:56 <dcoutts> Saizan: btw, it turns out that unpack is a very neat solution to our problem with fetch, much appreciated.
15:47:21 <Axman6> actually, maybe it'd be better if i came back to you tomorrow or something, once i've read more docs about ST etc.
15:47:41 <Axman6> i'll see what i can figure out for myself
15:48:05 <erikc> dcoutts: im available
15:48:22 <dons> gee. we really should bind to the entire posix api at some point.
15:48:25 <dcoutts> erikc: great! what can I interest you in...
15:48:55 <dcoutts> erikc: we've got things to do with getting out a Cabal and cabal-install point release
15:49:14 <dcoutts> erikc: we've got the platform release and there's the new hackage-server
15:49:52 <dcoutts> erikc: if you want something more like building components or cool libs then there are several interestign component in cabal and cabal-install that need either writing or redesigning
15:50:57 <dcoutts> there's also http://hackage.haskell.org/trac/hackage/#StartingpointsfornewCabalhackers
15:51:11 <erikc> i think ill read that first, get an idea of what the State of Cabal is
15:51:21 <dcoutts> ok, great
15:51:23 <jeffwheeler> Yi's source seems to avoid the cyclical imports by using import {-# source #-} . . . and *-boot files; is that really the best solution?
15:51:51 <dmwit> That's the current solution to get GHC to do cyclical imports.
15:51:53 <dcoutts> erikc: I'm always happy to dispense advice on which bits to look at given what you find interesting.
15:52:04 <erikc> i need something fun to work on after meddling in actionscript at work :)
15:52:14 <jeffwheeler> dmwit: :-/ Ah well; thanks.
15:52:18 <dcoutts> erikc: :-)
15:52:26 <dmwit> Technically, no compiler implements H98, because H98 requires you to support cyclical imports.
15:52:29 * sw17ch dangles is P2P VPN project in front of erikc
15:52:45 <Peaker> why are cyclical dependencies between modules a good idea?
15:53:03 <dcoutts> sw17ch: but cabal work benefits the entire community, loads of users! :-)
15:53:30 * sw17ch works out a time sharing model with which dcoutts and sw17ch can share erikc
15:53:30 <erikc> and i have an 8-way machine that i want cabal to use effectively, so i gotta get the done or free up other ppl's dev cycles to get it done ;)
15:53:39 <dcoutts> sw17ch: hah hah :-)
15:53:52 <sw17ch> also, my VPN is missing the "P"
15:53:58 <SamanthaDega> referencing http://haskell.org/pipermail/haskell-cafe/2008-September/047406.htmlI have a non-Haskell Code Monkey compadre who is also into writing music. Any objections to us making an mp3 out of this text file?
15:53:58 <dcoutts> erikc: ah, parallel builds, yes now there's an interesting story there
15:54:07 <sw17ch> it's a VnoencryptionwhatsoeverN
15:54:17 <wli> It's not that big a deal. Compile to interfaces, check vs. interfaces at a different time.
15:54:18 <dcoutts> erikc: I can tell you our current thinking on that issue if you like, it's a cabal-2.x feature.
15:54:42 <dcoutts> erikc: you know we've got a 64 thread machine, sparky.haskell.org
15:54:47 <erikc> you mentioned it in #ghc, that there were some other issues which, when addressed, would enable parallel building
15:54:54 <dmwit> I like the name sparky.
15:54:55 <dcoutts> that's going to take some work to saturate
15:55:04 <dmwit> It fits with 'par'. =)
15:55:09 <cknapp> That song is great.
15:55:18 <dcoutts> dmead: mm, good point, I'd not thought of that
15:55:23 <ehird> hrm.
15:55:27 <dcoutts> oope dmwit, not dmead
15:55:46 <dcoutts> dmwit: we just called it sparky because it's a sparc :-)
15:56:01 <dmwit> Even better!
15:56:03 <dmwit> =D
15:56:05 <dcoutts> but we do hope that it'll work nicely with par style parallelism
15:56:40 <dcoutts> erikc: yes, basically we have to make the build system component of cabal use a dependency framework like make, only better.
15:56:49 <dcoutts> which is easier said than done
15:57:06 <kmeyer> dcoutts: well, 64 hardware threads iirc
15:57:08 <erikc> hehe
15:57:17 <dcoutts> kmeyer: yes
15:57:26 <dcoutts> 8 cores, 8 threads per core
15:57:47 <kmeyer> so that's also 64 threads max, no?
15:57:58 <dcoutts> erikc: Saizan started working on that for his SoC project, it needs more work to become practical.
15:58:16 <dcoutts> kmeyer: yes, 64 threads
15:58:49 * dcoutts has the feeling he's missed the point kmeyer was trying to make
15:59:03 <kmeyer> nevermind, I was just confusing myself
15:59:13 <dons> hardware threads rock
15:59:16 <dcoutts> it's a very nice box
15:59:21 <erikc> i assume hackage-server is a happs implementation of the hackage site?
15:59:27 <dcoutts> erikc: yes
15:59:27 * wli liked SPARC.
15:59:42 <dcoutts> however I'v only managed once to get it over 50% cpu utilisation
15:59:52 <dcoutts> and that was running 4 builds of gcc with gmake -j lots
15:59:56 <RayNbow> hmm, anyone ever tried making an NFA in Haskell?
16:00:10 <Axman6> i'm hoping i get to play with some SPARC stuff this semester, after SUN gave ANU a nice new T2
16:00:12 <wli> RayNbow: And succeeded, too.
16:00:14 <sjanssen> dcoutts: yes > /dev/null & # 64 times :)
16:00:15 <dons> dcoutts: huh. nice challenge.
16:00:16 <dmwit> RayNbow: Yes.
16:00:20 <RayNbow> I made a toy example ( http://hpaste.org/13903 ), but I have no idea how to deal with epsilon transitions
16:00:21 <dcoutts> sjanssen: heh heh
16:00:26 <dons> "get this machine to 100% cpu"
16:00:39 <dcoutts> Axman6: yes, that's what Sun gave haskell.org
16:00:49 <RayNbow> wli, dmwit: out of curiousity... did you make one out of boredom? :p
16:00:53 <dcoutts> benl23 is currently working on it to get the Sparc native code gen working
16:00:56 <RayNbow> (because I just did :p)
16:01:06 <dcoutts> http://ghcsparc.blogspot.com/
16:01:09 <Axman6> dcoutts: i may be lectured by Ben L. this semester too :)
16:01:15 <dcoutts> Axman6: heh, cool
16:01:27 <wli> RayNbow: I only ever did deterministic stuff. Others have repeatedly done the nondeterministic.
16:01:46 <Axman6> he's my first comp lecturer's PhD student, and from what i hear, Clem likes to let Ben help out
16:02:23 <dcoutts> ben has done some pretty cool work, combination of theory and hacking
16:02:30 <RayNbow> wli: determinism is boring! ;)
16:02:53 <ehird> http://www.dcs.gla.ac.uk/~partain/haskerl/partain-1.html <- Syntax for monadic IO: wow, they invented do-blocks. :-)
16:02:55 <dmwit> nondeterminism is boring, too, but less predictably so
16:03:08 <Axman6> yeah, we've put some of his work to use in our course so far too. the ANUPlot stuff he wrote you used for out first comp assignment
16:03:17 <RayNbow> dmwit: nondeterminism keeps people employed for the debugging sessions :p
16:03:20 <Axman6> that was the assignment that got me hooked on haskell
16:03:53 <wli> RayNbow: Not really. There is some challenge to dealing with the potentially vast state space arising from anticipating all the nondeterministic possibilities in advance.
16:04:06 <sw17ch> if determinism is boring, and my job consists almost entirely of making things as deterministic as possible, does that mean that the end goal of my job is to produce the most boring thing possible?
16:04:48 <intoverflow> sw17ch: not necessarily; it just means your job is to make things as boring as possible.  slightly different.
16:04:53 <sjanssen> boring is good
16:05:00 <Peaker> conal: thanks for the reply
16:05:02 <erikc> no surprises is good
16:05:04 <vininim> ^
16:05:17 <ehird> oh and the "(Polymorphic) Regular expressions" part
16:05:17 <Peaker> conal: I didn't realize snapshot being broken was related to the unamb/ghc bug
16:05:23 <ehird> that's been done :-)
16:06:57 <RayNbow> wli: ah yeah, the vast state space... :)  (suddenly I remember some horrible model checking experiences)
16:07:27 <lowki> how do i get the last element of a list?
16:07:36 <Heffalump> @type last
16:07:38 <lambdabot> forall a. [a] -> a
16:07:42 <lowki> kk
16:08:01 <dons> :)
16:08:13 <lowki> yay :) thanks
16:08:16 <dons> the experts agree. 'last' is the appropriate function.
16:08:35 <pumpkin> does anyone know of a good way to enumerate IEEE 754 floats such that I cover all of them?
16:08:36 <RayNbow> > (head . reverse) [1..10]  -- a better solution if you get paid per character of code
16:08:38 <lambdabot>   10
16:08:38 <thoughtpolice> dons: ORLY?
16:08:40 <dmwit> :t take 1 . reverse
16:08:42 <lambdabot> forall a. [a] -> [a]
16:08:43 <wli> RayNbow: A fair number of coding problems involve doing math-type stuff up-front so the program avoids doing a lot of work.
16:08:44 <dons> FOR REAL
16:09:21 <dmwit> pumpkin: Enumerate all the possible bits and use encodeFloat.
16:09:29 <sjanssen> > foldr (\x xs -> const (xs x)) id [1 .. 10] (error "last: empty list") -- nope, this is better than last
16:09:30 <lambdabot>   10
16:09:49 <sw17ch> > (\x -> let l = (length x) in x !! (l - 1)) [1..10]
16:09:51 <lambdabot>   10
16:10:07 <sjanssen> @pl \x xs -> const (xs x)
16:10:07 <lambdabot> (const .) . flip id
16:10:08 <wli> last = foldr1 $ flip const
16:10:15 <pumpkin> dmwit: hmm, maybe
16:10:29 <sw17ch> RayNbow: i propose my implementation for those paid-by-character ^^
16:10:38 <RayNbow> :p
16:10:49 <dmwit> sw17ch: That has terrible GC characteristics, though. =/
16:11:00 <dmwit> sjanssen's is longer, and can do GC better. =)
16:11:14 <sjanssen> dmwit: it also fails on lists longer than maxBound :: Int
16:11:16 <sw17ch> sjanssen also has more Haskell-Foo than I
16:11:19 <sw17ch> :)
16:11:41 <dmwit> Yeah!  What if you have enough memory to hold a list longer than maxBound :: Int!!!
16:11:57 <dmwit> Well, the spine of such a list, anyway.
16:12:06 <sw17ch> what's the overhead for a cons cell?
16:12:13 <sjanssen> dmwit: Haskell is lazy, last [0 :: Int ..] takes constant memory
16:12:20 <pumpkin> if you had enough memory to hold a list longer than maxBound :: Int, wouldn't Int be 64 bits, which would mean you had a lot more memory?
16:12:27 <pumpkin> oh
16:12:30 <dmwit> sjanssen: Not in sw17ch's version.
16:12:33 <wli> dmwit: fix (\f -> 0 : 1 : zipWith (+) f (tail f))?
16:13:05 <kpreid> > last ['\0'..]
16:13:06 <lambdabot>   '\1114111'
16:13:08 <sjanssen> dmwit: but even if *did* have enough memory to hold a list longer than maxBound :: Int, sw17ch's function would fail for another reason
16:13:25 <sw17ch> sjanssen: namely, the end of the universe
16:13:34 <RayNbow> > (head . head . reverse . init . tails) [1..10]   -- an alternative, if you get paid per dot :p
16:13:36 <lambdabot>   10
16:13:46 <wli> sjanssen: Is 16TB enough?
16:13:51 <sjanssen> sw17ch: nah, it doesn't take all that long to count to 2^31-1
16:13:51 <Axman6> anyone know of a good ST turorial>?
16:14:04 <sw17ch> > (head . reverse . reverse . reverse) [1..10]
16:14:05 <lambdabot>   10
16:14:11 <sjanssen> wli: the problem is addressing the memory.  In GHC, Int is the same size as a pointer
16:14:15 <sw17ch> > (head . reverse . reverse . reverse . reverse . reverse . reverse . reverse . reverse . reverse . reverse . reverse . reverse . reverse) [1..10]
16:14:16 <Heffalump> dmwit: encodeFloat + enumerating all the bit patterns  won't work too well
16:14:17 <lambdabot>   10
16:14:45 <Heffalump> encodeFloat doesn't really explain what the limits are or when you've hit the denorms, or let you get at Nan, Infinity, or negativeZero
16:14:48 <dmwit> Heffalump: Bummer.  What goes wrong?
16:14:59 <Axman6> > fromIntegral (maxBound :: Int) :: Double
16:15:00 <lambdabot>   9.223372036854776e18
16:15:05 <dmwit> hmph
16:15:07 <Heffalump> I would enumerate all the Word64s and use unsafeCoerce#
16:15:08 <kmeyer> ?type encodeFloat
16:15:09 <lambdabot> forall a. (RealFloat a) => Integer -> Int -> a
16:15:21 <pumpkin> Heffalump: I was tempted to, but that felt awfully ugly :)
16:15:23 <wli> sjanssen: If it's proportional to your address space, then it's a logical impossibility.
16:15:27 <kmeyer> > encodeFloat 0 0
16:15:27 <pumpkin> Heffalump: I'll try it though
16:15:28 <lambdabot>   0.0
16:15:31 <kmeyer> > encodeFloat 0 1
16:15:33 <lambdabot>   0.0
16:15:35 <thoughtpolice> Axman6: if you haven't read it the paper 'lazy functional state threads' paper is probably of interest
16:15:36 <kmeyer> > encodeFloat 0 200
16:15:38 <lambdabot>   0.0
16:15:41 <kmeyer> > encodeFloat 0 20000
16:15:43 <lambdabot>   0.0
16:15:44 <sw17ch> :t length
16:15:46 <lambdabot> forall a. [a] -> Int
16:15:46 <kmeyer> > encodeFloat 200000 0
16:15:46 * thoughtpolice can't type today
16:15:47 <lambdabot>   200000.0
16:15:52 <Axman6> thoughtpolice: got a link?
16:15:56 <sjanssen> wli: yes, we'd need to use some implementation other than GHC
16:16:01 <kmeyer> > encodeFloat 2000243 -23
16:16:02 <lambdabot>       No instance for (Num (Int -> a))
16:16:02 <lambdabot>        arising from the literal `23' a...
16:16:07 <kmeyer> > encodeFloat 2000243 (-23)
16:16:09 <lambdabot>   0.23844754695892334
16:16:17 <Heffalump> so you can enumerate from the min exponent to the max exponent, and the min mantissa to the max mantissa
16:16:18 <dmwit> wli: Unless the proportion is unusually small... ;-)
16:16:23 <thoughtpolice> @go Lazy functional state threads
16:16:25 <lambdabot> http://www.dcs.gla.ac.uk/fp/papers/lazy-functional-state-threads.ps.Z
16:16:30 <thoughtpolice> Axman6: ^^
16:16:34 <thoughtpolice> Axman6: also, http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-ST.html :)
16:16:36 <Heffalump> but that won't deal with denorms properly (I think it'll leave them out, though it might cover them repeatedly)
16:16:39 <kmeyer> Heffalump: what you want ca be done in C rather easily... :(
16:16:44 <kmeyer> s/ca/can/
16:16:46 <Axman6> cheers
16:16:51 <Heffalump> kmeyer: it can be done in Haskell rather easily too using exactly the same unsafe casts
16:16:58 <kmeyer> ah.
16:17:19 <Heffalump> > case 1 of W64# n -> D# (unsafeCoerce# n)
16:17:21 <lambdabot>   Not in scope: data constructor `W64#'Not in scope: data constructor `D#'Not...
16:17:27 <wli> But can the space be traversed in an order-respecting fashion?
16:17:36 <Heffalump> (try that in ghci with -XMagicHash on and GHC.Exts and GHC.Word imported)
16:17:51 <Heffalump> wli: yes, the bitpatterns are in the right order
16:17:51 <kmeyer> wli: they are defined to be ordered the same as the integers
16:17:55 <wli> Dare I ask what -XMagicHash is?
16:17:57 <kmeyer> at least IEEE754
16:18:04 <Heffalump> it allows you to use the # character in identifiers
16:18:06 <Heffalump> otherwise it's an operator
16:18:48 <pumpkin> well, I'm getting something for my enumerat function on floats :P
16:19:03 <pumpkin> not sure how correct it is, but I see no reason for it not to be
16:19:53 <pumpkin> *Set.Countable> enumerate :: [Float]
16:19:53 <pumpkin> [0.0,1.0e-45,3.0e-45,4.0e-45,6.0e-45,7.0e-45,8.0e-45,1.0e-44,1.1e-44,1.3e-44,
16:19:55 * sw17ch wishes C had type inference
16:19:57 <Heffalump> actually, the jump from positive to negative 0 is non trivial
16:20:09 <Heffalump> and won't respect ordering (there'll be some NaNs in the way, at least)
16:21:04 <pumpkin> hmm, my enumerator for floats is running in O(n) memory :/
16:21:28 <Heffalump> in ghci?
16:21:38 <pumpkin> yeah
16:21:40 <Heffalump> if so, ghci will be retaining the list
16:21:43 <dcoutts> straw poll: does the 'category' output in cabal list justify the space it takes?
16:21:48 <Heffalump> assuming you defined it at top-level as you imply above
16:21:57 <pumpkin> well, it's defined top level in a file I wrote
16:22:11 <pumpkin> but yeah, the file isn't compiled
16:22:11 <dcoutts> as in $ cabal list foo  reports "Category: Game" along with a description
16:22:11 <Heffalump> well, then it's a CAF and will be retained
16:22:19 <pumpkin> Heffalump: even with -O2?
16:22:19 <Heffalump> even if you compile it you'll have the problem
16:22:23 <pumpkin> boo
16:22:26 <pumpkin> any way to get around it?
16:22:30 <Heffalump> umm, I think so. Wouldn't swear to it.
16:22:34 <Heffalump> Don't make it a CAF?
16:22:46 <Heffalump> i.e. don't define it at top-level, or add a dummy () parameter
16:22:47 <pumpkin> but they don't take any arguments
16:22:57 <Heffalump> s/CAF/top-level CAF/ above
16:23:04 <pumpkin> how would I avoid defining it as top level?
16:23:15 <Heffalump> make it a local definition in the thing that consumes it, for example
16:23:22 <erikc> dcoutts: imo no, it'd be more interesting to be able to also list categories and list by categories
16:23:34 <RayNbow> > let f () = [1..] in f undefined
16:23:35 <dcoutts> erikc: yes, that would be useful
16:23:36 <lambdabot>   * Exception: Prelude.undefined
16:23:38 <pumpkin> Heffalump: this is just a random exercise in defining a "good enum" typeclass I called Countable
16:23:40 <Heffalump> you can only expect it to run in O(1) time if it is in a good relationship with its consumer
16:23:48 <pumpkin> my typeclass has one method, enumerate
16:24:09 <pumpkin> and it takes no arguments... it just outputs a list of the elements of that type
16:24:17 <Heffalump> I don't know how to stop typeclass members being top-level CAFs without changing their types.
16:24:23 <pumpkin> :/
16:24:38 <Heffalump> Ironically I have something I'm working on atm where I really want to be sure they'll be top-level CAFs, even in classes with superclasses.
16:24:53 <dcoutts> erikc: to do that efficiently we need to transform the hackage index into a cached form that allows quicker searches and less parsing. That's an useful project on it's own. We have problems with how slow the indexes are at the moment.
16:24:56 <Heffalump> anyway, I must go to bed.
16:25:08 <pumpkin> Heffalump: thanks for the help :)
16:25:37 <Heffalump> if you're just playing around, add a () parameter to your method.
16:25:38 <dcoutts> erikc: eg when we download the index we would read it, do some checking and save a binary file that allows quick lookups later without having to re-parse 1000+ .cabal files
16:26:01 <dmwit> dcoutts: Like, use a real database?
16:26:11 <dcoutts> dmwit: that's probably going a bit far
16:26:35 <dcoutts> dmwit: portability and few dependencies are relatively important qualities in packaging tools
16:26:36 <dmwit> Yeah, probably.
16:26:54 <dcoutts> eg that's why we use the pure Haskell HTTP package rather than a curl binding
16:26:56 * wli usually likes using databases.
16:27:15 * dcoutts usually like Haskell data structures
16:27:40 <dcoutts> list comprehensions make fine database queries :-)
16:28:03 <sw17ch> the lack of an 's' on "likes" had me parse that phrase such that it seemed like there was a herd of creatures known as a dcoutt
16:28:16 <dcoutts> sw17ch: hah hah ha
16:28:17 <pumpkin> hmm, would it make more sense to call my typeclass Enumerable, rather than Countable? I was trying to stay away from Enumerable cause it looked too much like Enum
16:28:17 <pumpkin> Heffalump: hmm, but that feels inelegant :/
16:28:35 <wli> Usually the whole advantage of databases is that they're faster/smarter/etc. data structures than lists.
16:28:45 <sw17ch> if i ever discover a species, i'm going to name it that
16:28:47 <dcoutts> sw17ch: it's true, the herd of dcoutts all like Haskell data structures :-)
16:29:03 <wli> Not to mention multiply-indexed data etc.
16:29:12 <sw17ch> dcoutts: do you identify yourself as a herd? a threadpool with 1 threads? :)
16:29:45 <wli> It'd be nice to do all that natively in Haskell, but the data structures are hard.
16:30:00 <dcoutts> sw17ch: hmm, the nearest I've come is being a herder, gentoo packaging people look after 'herds' of packages, as if they were cows
16:30:45 <dcoutts> wli: you're right of course. Most of the time the range of queries we need to do is slightly below the pain threshold of switching to a database.
16:30:47 <wli> (No, B+ trees etc. are easy. It's the R^* trees and the like that are hard.)
16:31:02 <pumpkin> wli: not if you have samet's huge book!
16:31:25 <wli> dcoutts: In part because people limit the tasks/etc. to what can be done without them.
16:31:27 <dcoutts> I thought it was the typing of relations in HM systems that made DBs hard
16:31:32 <dcoutts> wli: true enough
16:31:49 <pumpkin> http://www.amazon.com/review/product/0123694469?ie=UTF8&tag=hompagofhansa-20&linkCode=am2&camp=1789&creative=9325&creativeASIN=0123694469
16:35:09 <pumpkin> whee http://hpaste.org/13904
16:37:54 <erikc> relations are dynamically typed, the 'impedance mismatch' between oo and relational dbs is just a static type system butting heads with a dynamic one
16:38:04 <erikc> its funny how its created a whole cottage industry of object relational mappers
16:40:26 <pumpkin> minBound :: Float
16:40:30 <pumpkin> > minBound :: Float
16:40:32 <lambdabot>       No instance for (Bounded Float)
16:40:32 <lambdabot>        arising from a use of `minBound'...
16:40:33 <pumpkin> good
16:40:49 <dcoutts> erikc: relations can be statically typed
16:41:55 <pumpkin> anyone else have any suggestions about my CAF issues? are there any other options other than making my enumerate function take an argument?
16:42:11 <pumpkin> is there some way of tagging a CAF and saying "don't keep this around! I don't need it!"
16:42:22 <pumpkin> a top-level one
16:44:36 <erikc> dcoutts: even if the set of queries isnt known at compile time?
16:45:04 <erikc> i should have added that caveat
16:45:24 <dcoutts> erikc: in a statically typed language all the code is known at compile time
16:45:26 <dcoutts> generally
16:45:48 <dcoutts> otherwise it requires some runtime type check at code loading time
16:45:54 <dcoutts> eg like what hsplugins or clean do
16:46:04 <erikc> right
16:46:07 <dcoutts> note, not at runtime
16:46:07 <mmorrow> clean does this?
16:46:44 <dcoutts> mmorrow: it's got some clever code loading feature where it can load compiled code and do a few type checks, not full blown type checking
16:47:02 <dcoutts> they say it's safe and fast
16:47:11 <mmorrow> interesting, is it checking the object file against an interface file or some such?
16:47:22 <mmorrow> or, what exactly is it checking?
16:47:45 <dcoutts> as I recall it's somewhere between a simple interface equality check and full HM type checking
16:47:54 <mmorrow> cool, i'll have to check it out
16:47:54 <dcoutts> see their papers for details
16:48:15 <dcoutts> mmorrow: if it's as good as it's cracked up to be then we need it in ghc :-)
16:48:24 <mmorrow> totally! :)
16:48:58 <pumpkin> maybe I should make my enumerate take a parameter of the same type, and do nothing?
16:50:44 <pumpkin> (do nothing with the parameter)
16:51:37 <mmorrow> wow, i didn't know clean has been around since 1987
16:53:38 <wli> Actually, Haskell implementations of relatively basic stuff could be built upon at some point. Single-key queries via B+ trees and hoping the API is enough despite inefficiency could go some distance.
16:55:17 <pumpkin> wli: you mean for specific SQL queries?
16:55:49 <wli> pumpkin: No, for general direct access database stuff.
16:55:52 <pumpkin> ah
16:56:00 <mmorrow> i think one way to go would be to implem a parser + type inference for SQL, then wrap this up into a quasiquoter (which can capture haskell vars from the enclosing scope)
16:56:20 <pumpkin> mmorrow: :D
16:57:11 * wli had nothing more specific in mind than "grossly inefficient direct access database."
16:57:40 <mmorrow> wli: heh
16:59:15 <mmorrow> wli: iirc there's a haskelldb (experimental) backend in haskell which used Maps/etc (by bjorn bringert i think) in the haskelldb pkg somewhere
17:00:10 <mmorrow> wli: also, i've used this for sql-ish queries http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=747
17:00:27 <dolio> dcoutts: I know Put is *a* writer monad. But are you sure that GHC optimizes Writer Builder as well as it optimizes PairS? Because off the top of my head, I'd say it likely doesn't.
17:00:42 * sw17ch goes home
17:00:51 <dolio> Unless Builder isn't actually unpacked, despite the annotation, for instance.
17:00:56 <erikc> it'd be interesting to marry STM and a quasiquoter for Tutorial D to create a pure haskell in-memory implementation of D
17:01:18 <mmorrow> erikc: what's Tutorial D?
17:01:27 <erikc> http://en.wikipedia.org/wiki/D_(data_language_specification)
17:01:28 <gwern> whoo, down to one error! that date stuff wasn't as bad as I thought it'd be :)
17:02:05 <mmorrow> erikc: interesting
17:02:50 <mmorrow> erikc: this project looks interesting (see the paper) http://progtools.comlab.ox.ac.uk/projects/codequest
17:03:14 <mmorrow> implementing an optimizing Datalog -> SQL compiler for source code queries (on the AST)
17:03:19 <dcoutts> dolio: sorry, I'd not quite realised what you were saying, I posted a follow up. You're quite right.
17:04:19 <wli> mmorrow: It looks interesting for other reasons, too.
17:04:32 <mmorrow> wli: :) totally
17:07:28 <gwern> @src isSpace
17:07:29 <lambdabot> Source not found. stty: unknown mode: doofus
17:08:57 <Axman6> anyone have much experience with ST? i keep getting errors like: http://hpaste.org/13906
17:10:42 <gwern> is (`elem` " \t\n\r") equivalent to isSpace ?
17:10:58 <dmwit> ?src isSpace
17:10:59 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
17:11:12 <dmwit> ?source Data.Char
17:11:12 <lambdabot> http://darcs.haskell.org/packages/base/Data/Char.hs
17:11:51 <int80_h> has lambdabot gone insane again?
17:12:00 <pumpkin> why?
17:12:21 <int80_h> "This mission is too important for me to  allow you to jeopardize it.
17:12:25 <gwern> dmwit: it doesn't say :(
17:12:29 <dmwit> ?src GHC.Unicode
17:12:29 <lambdabot> Source not found. Maybe you made a typo?
17:12:33 <int80_h> He's quoting HAL 2000
17:12:37 <dmwit> ?source GHC.Unicode
17:12:37 <lambdabot> GHC.Unicode not available
17:12:49 <dmwit> gwern: No, it doesn't.
17:12:55 <dmwit> > filter isSpace ['\0'..]
17:12:57 <lambdabot>   "\t\n\v\f\r \160\5760\6158\8192\8193\8194\8195\8196\8197\8198\8199\8200\820...
17:12:57 <mmorrow> wli: here's that haskelldb code i was thinking of http://code.haskell.org/haskelldb/driver-flat/Database/HaskellDB/FlatDB.hs
17:13:07 <gwern> nm, grep found it in _darcs/pristine/utils/ext-core/lib/GHC_ExtCore/Unicode.hs
17:13:09 <dmwit> gwern: I'd say the answer to your question is "no". =P
17:13:27 <pumpkin> is there a set of isSpace-alikes for other unicode classes?
17:13:29 <dmwit> Axman6: It sounds like you're trying to return an STRef or some such thing.
17:13:32 <mmorrow> , text . utf8enc . filter isSpace $ ['\0'..]
17:13:35 <lunabot>     ᠎             　
17:13:39 <mmorrow> heh
17:13:41 <dmwit> Axman6: Care to paste the rest of your code?
17:13:44 <dmwit> pumpkin: Yes.
17:13:48 <gwern> pumpkin: isSpace hardwires it
17:13:54 <Axman6> dmwit: yeah i think so. i'll paste it soon, see if i can fix that first
17:14:15 <dmwit> :t generalCategory
17:14:16 <lambdabot> Char -> GeneralCategory
17:14:55 <dmwit> > [minBound..maxBound] :: GeneralCategory
17:14:55 <mmorrow> , text . utf8enc $ "\x2200"
17:14:56 <lambdabot>   Couldn't match expected type `GeneralCategory'
17:14:57 <lunabot>  ∀
17:15:07 <mmorrow> , generalCategory '\x2200'
17:15:08 <lunabot>  MathSymbol
17:15:12 <mmorrow> hah
17:15:14 <mmorrow> sweet
17:15:17 <pumpkin> oh nice
17:15:21 <dmwit> > [minBound .. maxBound] :: GeneralCategory
17:15:22 <lambdabot>   Couldn't match expected type `GeneralCategory'
17:15:24 <pumpkin> @index GeneralCategory
17:15:25 <lambdabot> bzzt
17:15:28 <dmwit> huh
17:15:31 <pumpkin> @hoogle GeneralCategory
17:15:31 <lambdabot> Data.Char data GeneralCategory
17:15:31 <lambdabot> Data.Char generalCategory :: Char -> GeneralCategory
17:15:32 <dmwit> Data.Char
17:15:34 <mmorrow> , 'generalCategory
17:15:37 <lunabot>  Data.Char.generalCategory
17:15:53 <mmorrow> , src ''GeneralCategory
17:15:54 <pumpkin> oh wow
17:16:05 <lunabot>  data GeneralCategory = UppercaseLetter
17:16:05 <lunabot>                       | LowercaseLetter
17:16:05 <lunabot>                       | TitlecaseLetter
17:16:13 <pumpkin> nice
17:16:15 <baaba> > [minBound .. maxBound] :: [GeneralCategory]
17:16:17 <lambdabot>   [UppercaseLetter,LowercaseLetter,TitlecaseLetter,ModifierLetter,OtherLetter...
17:16:39 <pumpkin> > generalCategory '肛'
17:16:41 <lambdabot>   OtherLetter
17:16:49 <pumpkin> Letter :o
17:17:44 <pumpkin> > generalCategory 'か'
17:17:46 <lambdabot>   OtherLetter
17:17:55 <pumpkin> > generalCategory '一'
17:17:57 <lambdabot>   OtherLetter
17:18:06 <pumpkin> not sure I'd call that one a Letter
17:18:08 <int80_h> Hey, I'm playing around with the data type Tree from ch. 3 from RWH. Here's an hpaste of a problem I'm having.
17:18:15 <int80_h> http://hpaste.org/13907
17:18:23 <dmwit> baaba: oh, of course
17:18:50 <pumpkin> filter ((==OtherNumber) . generalCategory) ['\0'..]
17:18:52 <pumpkin> > filter ((==OtherNumber) . generalCategory) ['\0'..]
17:18:54 <lambdabot>   "\178\179\185\188\189\190\2548\2549\2550\2551\2552\2553\3056\3057\3058\3882...
17:19:13 <pumpkin> > filter ((==DecimalNumber) . generalCategory) ['\0'..]
17:19:15 <lambdabot>   "0123456789\1632\1633\1634\1635\1636\1637\1638\1639\1640\1641\1776\1777\177...
17:19:26 <pumpkin> heh
17:19:29 <dmwit> int80_h: Those two patterns both match all Nodes.
17:20:19 <dmwit> int80_h: Note that the RHS of your two equations have different types... unless you declare a Num instance for lists!
17:20:27 <dmwit> int80_h: (Which isn't so likely.)
17:20:55 <dmwit> int80_h: You likely want your two patterns to be Empty and (Node _ tl tr), just at a guess.
17:22:06 <BMeph> int80_h: Thus the "Pattern match(es) are overlapped" message. :)
17:22:19 <int80_h> got it, thanks :)
17:23:48 <wli> instance Num t => Num (t' -> t) where (+) = liftM2 (+) ; (*) = liftM2 (*) ; (-) = liftM2 (-) ; ... lists could be done in like fashion.
17:24:44 <dmwit> [(+), (-), (*), (/)] = map liftM2 [(+), (-), (*), (/)]
17:24:58 <dmwit> [abs, negate] = map liftM [abs, negate]
17:25:00 <wli> Pretty much.
17:26:01 <pumpkin> would it be dumb to submit that countable typeclass to hackage? :P
17:29:37 <mmorrow> , text . utf8enc $ filter ((==DecimalNumber) . generalCategory) ['\0'..]
17:29:43 <mmorrow> um
17:29:57 <pumpkin> aw
17:30:04 <pumpkin> poor lunabot, you're always abusing it
17:31:50 <wli> > let cantor (x:xs) = head x : cantor (zipWith (:) (tail x) xs) in take 10 $ cantor [[(i, j) | i <- [0..]] | j <- [0..]]
17:31:52 <lambdabot>   [(0,0),(1,0),(0,1),(2,0),(1,1),(0,2),(3,0),(2,1),(1,2),(0,3)]
17:32:22 <mmorrow> , text . utf8enc $ filter ((==DecimalNumber) . generalCategory) ['\0'..]
17:32:27 <mmorrow> wtf!
17:32:55 <pumpkin> aw!
17:32:55 <wli> This suggests an Enum instance for (Enum left, Enum right) => (left, right)
17:32:57 <mmorrow> maybe it's because Doc isn't lazy and it's flooding?
17:33:10 <pumpkin> try without text
17:34:05 <mmorrow> the _bot_ (not the evaluator) crashes with this:
17:34:07 <mmorrow> bot: Prelude.chr: bad argument
17:34:10 <mmorrow> weird
17:34:20 <mmorrow> > chr 9
17:34:22 <lambdabot>   '\t'
17:34:27 <mmorrow> > maxBound :: Char
17:34:29 <lambdabot>   '\1114111'
17:34:42 <mmorrow> > chr (ord (maxBound :: Char) + 1)
17:34:44 <lambdabot>   * Exception: Prelude.chr: bad argument
17:34:48 <mmorrow> ah
17:35:04 <mmorrow> i don't get why the bot would die though
17:35:22 <conal> Peaker: (snapshot/unamb/ghc-rts-bug) np.  i'm glad i got to explain, for others to see.  i'm concerned about people giving up on unamb & reactive, not realizing that the ghc rts bug is holding it up for now.
17:38:14 <kmeyer> can the type of [0..] be [Float]?
17:38:23 <pumpkin> yeah
17:38:29 <pumpkin> > [0..] :: [Float]
17:38:29 <mmorrow> if Float is an instance of Enum
17:38:31 <lambdabot>   [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0...
17:38:38 <kmeyer> oh, lame :(
17:38:38 <mmorrow> @type [0..]
17:38:39 <lambdabot> forall t. (Enum t, Num t) => [t]
17:38:48 <pumpkin> or you can use > enumerate :: [Float] from the module I just created
17:38:50 <kmeyer> I want to enumerate over small numbers
17:38:53 <pumpkin> which gives you all the floats
17:39:04 <kmeyer> ah
17:39:05 <mmorrow> , iterate (+0.0001) 0
17:39:07 <pumpkin> but is ugly and memory choping these days
17:39:08 <lunabot>  [0.0,1.0e-4,2.0e-4,3.0000000000000003e-4,4.0e-4,5.0e-4,6.000000000000001e...
17:39:14 <kmeyer> mmorrow: looks good
17:39:15 <wli> pumpkin: enumFromTo ?
17:39:36 <pumpkin> wli: unsafeCoerce :P it checks isIEEE and if so, uses unsafeCoerce, otherwise insults you
17:39:53 <pumpkin> I pasted the code a while ago
17:40:03 <mmorrow> haha
17:40:17 <pumpkin> http://hpaste.org/13908
17:40:29 <wli> unsafeCoerce () :: Int anyone?
17:41:15 <mmorrow> one way to segfault (if you're into that kinda thing) is to unsafeCoerce a function type to a data type (w/ a constructor)
17:41:40 <pumpkin> mmorrow: why do that when I can just use my UArr code to segfault purely? :P
17:41:43 <wli> Well, not quite what I meant.
17:42:12 <mmorrow> oops, i meant the other way around
17:42:22 <pumpkin> that makes more sense :)
17:42:24 <mmorrow> ghci> (unsafeCoerce () :: a->a) 42
17:42:24 <mmorrow> Segmentation fault
17:42:34 <mmorrow> pumpkin: heh
17:42:35 <wli> Enumerating rationals in order is another matter entirely. :(
17:42:51 <pumpkin> wli: it can't be done?
17:43:36 <pumpkin> 0, 1/infinity, 1/(infinity - 1), 1/(infinity - 2)
17:43:41 <pumpkin> just keep going
17:43:42 <wli> pumpkin: Assume r_n is the n-th rational in an in-order enumeration of the rationals.
17:43:46 <sutats> Is there a simple one-liner for picking the smallest integer out of an unsorted list?
17:43:56 <pumpkin> wli: that was more of a questioning statement than a question :)
17:44:02 <pumpkin> sutats: minimum
17:44:10 <Axman6> sutats: minimum?
17:44:13 <pumpkin> > minimum [6] ++ [1..5]
17:44:14 <lambdabot>       No instance for (Num [a])
17:44:14 <lambdabot>        arising from the literal `6' at <inter...
17:44:18 <pumpkin> > minimum $ [6] ++ [1..5]
17:44:20 <lambdabot>   1
17:44:20 <wli> pumpkin: r_n < (r_{n+1} + r_n)/2 < r_{n+1}
17:44:24 <Axman6> > minimum [1,5,2,5,7,2,6,4,1,6,8]
17:44:26 <lambdabot>   1
17:45:09 <sutats> pumpkin, Axman6: Thanks, that's what I'm looking for. I'm guessing maximum exists as well?
17:45:14 <pumpkin> yup :)
17:45:16 <Axman6> yep
17:45:22 <pumpkin> there's also minimumBy
17:45:25 <pumpkin> and maximumBy
17:45:25 <jonathanturner> I'm working my way through RWH.  I see integers, even arbitrarily long integers are of type Integer.  Does that mean that ghc is doing arbitrary precision math behind the scenes when doing something like 1+1 (as opposed to using the native 32-bit/64-bit integer)
17:45:36 <pumpkin> :t 1
17:45:38 <lambdabot> forall t. (Num t) => t
17:45:40 <Axman6> there's also (maximum|minimum)By which you can specify how to find the max/min
17:45:49 <jonathanturner> (sorry for the newbie question, but figured you guys would be a great place to ask)
17:45:57 <pumpkin> jonathanturner: there is arbitrary precision arithmetic
17:46:02 <Axman6> god damn you pumpkin, beelsebob'd me again
17:46:05 <pumpkin> :)
17:46:09 <wli> jonathanturner: There is an Int, which is 32/64, and Integer, which is arbitrary-precision.
17:46:28 <jonathanturner> wli: when is Int used?  I noticed that the type of 1+1 is still Integer
17:46:35 <int80_h> hmm, having new troubles.
17:46:38 <int80_h> http://hpaste.org/13907#a2
17:46:39 <Axman6> jonathanturner: there are both Int and Integer. Int is a machine int
17:46:42 <bd_> jonathanturner: when the type resolves to Integer
17:46:44 <BONUS_> 1+1 has a polimorphc type
17:46:44 <bd_> er
17:46:45 <wli> jonathanturner: defaulting chooses Integer before Int.
17:46:45 <bd_> to Int
17:46:48 <mmorrow> jonathanturner: when you say that it's of type Integer
17:46:51 <BONUS_> which means that it can act as many types
17:46:56 <BONUS_> you can tell haskell which one to use though
17:47:00 <BONUS_> > 1 + 1 :: Int
17:47:01 <lambdabot>   2
17:47:02 <wli> jonathanturner: 1 + 1 :: Num t => t
17:47:04 <BONUS_> > 1 + 1 :: Double
17:47:06 <lambdabot>   2.0
17:47:07 <mmorrow> > return 42 :: [Int]
17:47:09 <lambdabot>   [42]
17:47:11 <mmorrow> > return 42 :: Maybe Float
17:47:12 <BONUS_> > 1 + 1 :: Integer
17:47:13 <lambdabot>   Just 42.0
17:47:14 <lambdabot>   2
17:47:15 <wli> @type 1 + 1
17:47:16 <lambdabot> forall t. (Num t) => t
17:47:16 <mmorrow> > return 42 :: IO Double
17:47:18 <lambdabot>   * Exception: "<IO Double>"
17:47:27 <jonathanturner> ahhh, so that way you can force it to be a machine int instead, I see
17:47:42 <wli> jonathanturner: Int and Integer are both instances of Num.
17:47:59 <mmorrow> , 100^100 :: Int
17:48:01 <lunabot>  0
17:48:04 <mmorrow> , 100^100 :: Integer
17:48:06 <lunabot>  1000000000000000000000000000000000000000000000000000000000000000000000000...
17:48:33 <jonathanturner> mmorrow: yup, got it, thanks
17:48:38 <mmorrow> hmm, (^) must be doing bounds checking or something
17:48:49 <mmorrow> jonathanturner: :)
17:48:54 <mmorrow> @src (^)
17:48:54 <lambdabot> x ^ 0            =  1
17:48:54 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
17:48:54 <lambdabot>   where f _ 0 y = y
17:48:54 <lambdabot>         f x n y = g x n
17:48:54 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
17:48:56 <lambdabot>                       | otherwise = f x (n-1) (x*y)
17:48:58 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
17:49:03 <pumpkin> > 100^100 :: Expr
17:49:05 <lambdabot>   100 * 100 * (100 * 100) * (100 * 100 * (100 * 100)) * (100 * 100 * (100 * 1...
17:49:12 <Axman6> > 1000^10 :: Int
17:49:13 <lambdabot>   5076944270305263616
17:49:19 <Axman6> > 100^50 :: Int
17:49:20 <lambdabot>   0
17:49:24 <Axman6> > 100^40 :: Int
17:49:25 <lambdabot>   0
17:49:29 <Axman6> > 100^30 :: Int
17:49:30 <lambdabot>   1152921504606846976
17:49:33 <bd_> mmorrow: er, 100^100  isn't going to be representable in an integer
17:49:44 <mmorrow> i would've thought it would wrap
17:49:49 <bd_> 100^100 = 5^100*2^100
17:49:54 <bd_> 2^100 mod 2^32 = 0
17:50:01 <mmorrow> ahh
17:50:06 <jonathanturner> can you do that :: Expr trick in ghci somehow?  that's cool
17:50:16 <bd_> jonathanturner: yes, it's just normal haskell syntax
17:50:27 <bd_> although you'd usually annnotate the types of functions instead
17:50:27 <mmorrow> jonathanturner: there's a hackage pkg for it
17:50:31 <bd_> and let the compiler figure it out
17:50:38 <mmorrow> SimpleReflect iirc
17:50:49 <bd_> oh, :: Expr
17:51:01 <jonathanturner> mmorrow: thx, now to figure out how to install hackage packages.  Did I mention I'm new to Haskell yet?
17:51:07 <mmorrow> heh
17:51:21 <Axman6> yes :P
17:51:26 <BMeph> bd_: if you edit "in an integer" to "in an Int", I'd agree. :)
17:51:37 <mmorrow> there's cabal-install, or you can download the tarball, unpack, and in the dir run
17:51:42 <Axman6> jonathanturner: you want cabal-install. google it, you should find instructions of installing it
17:51:56 <Axman6> or mmorrow coud be extra helpful
17:51:58 <Axman6> could*
17:52:13 <bd_> BMeph: in a machine integer on most machines :)
17:52:13 <mmorrow> ghc --make Setup.*hs; ./Setup configure && ./Setup build && sudo ./Setup install
17:52:33 <mmorrow> > maxBound :: Int
17:52:34 <lambdabot>   9223372036854775807
17:52:35 <mmorrow> , maxBound :: Int
17:52:37 <lunabot>  2147483647
17:52:39 <mmorrow> :(
17:52:45 <Axman6> hmm... cabal installable ghc...
17:53:22 <BMeph> bd_: If you'd just said "in an Int", you could have said generally the same thing, with fewer words.
17:53:38 <BMeph> mmorrow: You don't have a 64-bit machine for lunabot? :)
17:53:52 <pumpkin> aw poor lunabot
17:54:11 <mmorrow> BMeph: i have the world's suckiest hosted server pkg and i'm running lunabot in that :(
17:54:29 <mmorrow> running ld on anything takes at least 10 seconds
17:54:53 <Axman6> heh
17:54:55 <mmorrow> it took me 4 hours to build ghc
17:56:32 <joma> would Dijkstra have liked Haskell? did he ever say anything about it?
17:56:39 * BMeph sends in a nomination for mmorrow in the category of "Stubornest Programmer in a Haskell field"...
17:56:57 <mmorrow> aw shucks
17:57:12 <Axman6> i'm used to ghc taking forever to compile these days :\
17:57:14 <joma> anyway, anyone working on computer games in Haskell? is Frag compileable without special packages?
18:02:20 <lispy> Anyone know of research papers that go with this library? http://code.google.com/p/dimensional/
18:02:53 <lispy> joma: if you install cabal-install then any haskell program is easy to build
18:03:02 <lispy> joma: but, I don't think Frag needs anything exotic
18:03:21 <lispy> joma: the 2-3 times I've built it, it was a quick and simple for me
18:04:47 <mmorrow> C-- has a wikipedia page http://en.wikipedia.org/wiki/C--_(intermediate_language)
18:07:50 <Adamant> there are multiple C--'s IIRC
18:11:44 <mmorrow> here's the relevant stuff re Clean/Dynamics/typechecking/Dynamic linking http://clean.cs.ru.nl/CleanExtra/report20/chapter8/index.html
18:12:14 <mmorrow> Adamant: it says "The name "C--" was also used for an earlier programming language developed in the 1990s by Peter Cellik for x86 computers. Sphinx C-- mixes C with x86 assembly language."
18:12:59 <Adamant> I've also seen it used to describe small C-derived languages in various CS texts
18:13:11 <gwern> I doubt djikstra would've liked haskell. afaik he never went near FP langs
18:13:21 <gwern> he seemed to really like imperative programming
18:13:34 <roconnor> Still, I wonder what he'd think of Epigram and Agda
18:14:00 <roconnor> He'd probably complain that the implementations are buggy beca
18:14:08 <gwern> he'd probably have wittily insulting expressions ready for non-turing complete langs
18:14:12 <roconnor> because they are not written in themselves
18:14:19 <roconnor> oh?
18:14:29 <roconnor> I'm not sure of that
18:14:41 <roconnor> I'd be intresting if he did
18:14:57 <roconnor> because he certainly never worked in a complete proof system
18:15:05 <gwern> 'The authors of Epigram and Agda were not satisfied with current languages which can do anything; so they decided to create languages which can do nothing.'
18:15:15 <roconnor> so to complain about not being turing complete seems kinda like a double standard
18:15:29 <Axman6> anyone know why http://hpaste.org/13909 wouldn't print out anything when run in ghci? (haven't tried compiled)
18:15:41 <gwern> ~from the writings of Pseudjikstra
18:16:29 <diltsman> Does anybody know how to open a second file in yi?  I have two windows on the same file and I would like them to be to different files.
18:17:03 <gwern> wouldn't you just C-x f or C-x b in one window?
18:17:14 <gwern> it acts just lik emacs/vi
18:18:00 <Axman6> anyone? :\
18:18:23 <diltsman> gwern: I try :split file.hs but it keeps opening new windows onthe same file.
18:18:40 <gwern> oh, vim mode. i don't know about that
18:19:01 <diltsman> I can get it to work in Vim, but the commands aren't all available in yi.
18:19:07 <gwern> but in emacs. when you split the window with C-x 2, it's supposed to keep both buffers on the file until you movve on somewhere else
18:19:25 <mmorrow> in vim mode you can do
18:19:30 <mmorrow> :new filename
18:19:36 <int80_h> anyonhe want to check out my hpaste?
18:19:44 <int80_h> http://hpaste.org/13907#a2
18:20:08 <diltsman> mmorrow: That is still opening a new window to the same file.
18:20:33 <mmorrow> Axman6: http://hpaste.org/13909#a1
18:20:33 <diltsman> I've tried :badd and :buffers but those don't appear to be implemented.
18:21:03 <gwern> int80_h: scrap the type sig
18:21:19 <llayland> you have "Tree" instead of "Tree a"
18:21:23 <int80_h> gwern: okay, then the problem becomes something else. I'll post it
18:21:28 <mmorrow> diltsman: hmm, ":new asdf" works for me. (maybe i added that myself though, i don't remember)
18:21:37 <gwern> (hm, compiles here with the type sig removed)
18:21:38 <Axman6_> mmorrow: Couldn't match expected type `IO t' against inferred type `()'
18:22:16 <int80_h> gwern: it compiles, but then dies when I feed it data
18:22:21 <BMeph> int80_h:  http://hpaste.org/13907#a3
18:22:22 <mmorrow> Axman6: umm, i don't know how that could be
18:23:04 <mmorrow> ohh, i guess the fixity of seq is to blame here
18:23:31 <diltsman> mmorrow: finally managed to find my Vim manual.  You can :split and then :edit to open a new file.
18:23:31 <mmorrow> http://hpaste.org/13909#a2  ?
18:23:43 <mmorrow> diltsman: ah nice
18:24:18 <diltsman> mmorrow: I'm so used to having a full set of Vim commands.  You forget the standard way to do things because you have so many shortcuts available.
18:24:20 <joma> roconnor: actually he has said that he dismissed Lisp the first time around because it was written in itself
18:24:34 <int80_h> BMeph: nice, it works
18:24:50 <mmorrow> diltsman: totally
18:25:12 <BMeph> int80_h: Especially when new to a lanuage, I find it helpful to point out the obvious... ;p
18:25:17 <BMeph> *language
18:25:23 <joma> he has also said in an interview that the industry had impressed him in some instance becuase at some meeting they were talking about higherorder functions like it was the easiest thing in the world whereas it is still a hard concept for pure mathematicians
18:25:28 <roconnor> joma: hmm, ok.  But Epigram in itself or Agda in itself is a different sort of beast.
18:26:21 <roconnor> Perhaps not surprisingly a language written in itself doesn't always tell it's semantics.
18:26:25 <mmorrow> roconnor: i'm not so sure if i'd want to _program_ in a non-turing complete language.
18:26:40 <roconnor> Where is that lambda calculus implemenation in itself that is strict if it is strict and lazy if it is lazy.
18:26:50 <roconnor> mmorrow: you do
18:26:53 <mmorrow> i.e. write a webserver, or an interpreter
18:27:37 <roconnor> mmorrow: you want each requestion to your webserver to provably terminate.
18:27:41 <mmorrow> perhaps an interpreter that dynamically links machine code into itself and jumps to it
18:27:48 <joma> how is HaPPs to work with nowadays?
18:28:30 <int80_h> joma: google happs tutorial. it's awesome
18:29:03 <int80_h> joma: it's a web site built with happs, explaining how it was built, and supplies it's own source.
18:29:14 <roconnor> I'd only be inclined to use a turning complete languages for those algorithms that I cannot prove things about.  The only potential example I can think of is some genetic programming
18:29:17 <gwern> joma: well, people seem to be using it, so it can't be too bad
18:29:22 <int80_h> joma: I'm running it right now
18:29:36 <gwern> joma: for example, gitit is a nice little wiki written in happs - eg. http://lhc.seize.it/
18:29:46 <mmorrow> also, yes it would be wonderful to have a guarantee of termination, but not so wonderful if the code to prove that it will terminate is longer than the code which implements the functionality that needs to work for tomorrow 8am
18:30:04 <mmorrow> bbl
18:30:36 <roconnor> mmorrow: the code to prove it will terminate is simply a reflection of the pseudo proof  that you already have in your head.
18:30:45 <roconnor> mmorrow: but ya, 8amm.
18:30:46 <roconnor> am
18:31:14 <roconnor> no time for proofs then
18:31:56 <llayland> In the MonadsAsContainers tutorial they give the excersize of defining an instance of monad for a "data T a = L a | B (T a) (T b)".  Is there any use for a monad instance there? I can't see it without adding an Empty constructor and using MonadPlus
18:32:04 <Axman6__> dons: i don't suppose you're still around are you? i think i have a working version now, but my test results are slightly off, and i'm not sure why
18:32:19 <roconnor>  B (T a) (T a) ?
18:32:38 <llayland> ah, yes
18:32:54 <roconnor> yes that there is a useful monad for that datatype
18:33:26 <roconnor> start with defining fmap and return
18:33:42 <llayland> got those
18:33:49 <roconnor> then I'm not sure which is more intuative to define next, bind or join.
18:33:50 <ski_> then define `join'
18:34:04 <roconnor> I'd be inclined to define join next
18:34:11 <ski_> `join' is conceptually simpler there, imo
18:34:17 <roconnor> probably
18:34:36 <roconnor> It is so obvious to me, but I'm used to this thing.  I don't know what is obvious to beginners anymore
18:34:39 <roconnor> :)
18:34:45 <llayland> not much :)
18:35:08 <roconnor> llayland: Can you figure out how to write join :: T (T a) -> T a ?
18:35:17 <roconnor> in a natural way
18:35:48 <llayland> jn (Leaf a) = a; jn (Branch l r) = Branch (jn l) (jn r)  ?
18:36:04 <ski_> yes
18:36:08 <roconnor> llayland: bingo
18:36:19 <roconnor> now you are homefree
18:36:34 <roconnor> x >>= f = join (fmap f x)
18:36:34 <ski_> now you may derive `(>>=)' if you're interested to see what it'll do
18:36:40 <llayland> Okay, but what is that good for ?
18:37:13 <Axman6> urgh, ST is so frustrating!
18:37:18 <roconnor> llayland: subsituting expresions for variables in expressions
18:37:36 <roconnor> llayland: has a structure almost idential to that datatype
18:37:39 <llayland> aha
18:37:49 <ski_> Axman6 ?
18:37:52 <roconnor> think of leaves as holding variables of type A
18:38:00 <harovali1> are functions part of the Eq class ?
18:38:09 <roconnor> and then the nodes hold arithemetic operation names
18:39:05 <roconnor> Someone once told me that all monads can be though of like this substituion example
18:39:05 <roconnor> but I didn't quite get that
18:39:23 <Axman6> ski_: http://hpaste.org/13910 this runs fine in ghci, but doen't print anything when compiled
18:39:32 <harovali1> here I found what I think is a contradiction, one of the two must be wrong, but I don't know which one: "All standard Haskell types except for IO (the type for dealing with input and output) and functions are a part of the Eq typeclass" and "All the types we mentioned previously except for functions are part of Eq, so they can be tested for equality."
18:39:42 <Axman6> and also seemingly doesn't run
18:39:45 <roconnor> llayland: btw "x >>= f = join (fmap f x)" is true for every monad, not just your example here.
18:40:10 <roconnor> llayland: so if you ever find a functor (fmap) and a join and return operations, you probably have a monad.
18:40:17 <roconnor> they are more common than you might think
18:40:37 <llayland> rconnor yes the tutorial did a good job explaining that.  Seems like there everywhere
18:40:47 <roconnor> although sometime you need to abstact something to see the functor
18:41:12 <roconnor> I had rational step functions.  Once I abstracted out the rational numbers, I had a functor that was also a monad.
18:41:49 <roconnor> I find it easier to "see" the join function than the bind function, usually
18:41:49 <ski_> Axman6 : it compiles into an executable ?
18:41:54 <Axman6> ski_: yes
18:42:01 <roconnor> but the bind function tends to be useful in programming
18:42:13 <ski_> Axman6 : it looks like you're not forcing the value you get from `runST'
18:42:31 <pumpkin> Axman6: you're returning a number from main?
18:42:32 <ski_> i would recommend against using `unsafeIOToST' together with `runST'
18:42:34 <Axman6> ah, that could be it, probably need to seq it
18:42:56 <Axman6> pumpkin: it get it to execute properly
18:43:05 <ski_> @hoogle stToIO
18:43:06 <lambdabot> Control.Monad.ST stToIO :: ST RealWorld a -> IO a
18:43:06 <lambdabot> Control.Monad.ST.Lazy stToIO :: ST RealWorld a -> IO a
18:43:06 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
18:43:15 <pumpkin> Axman6: why not just do it all in IO?
18:43:18 <llayland> the step function bit was a little beyond me, but the rest was helpful. thanks.  now back to practice
18:43:20 <pumpkin> or is this just a test
18:43:20 <roconnor> for example, t >>= f in your tree example. you start with a tree t with leaves of type A and a function f from A to trees, and you subsitute the leaves with new trees given by the function f.
18:43:21 <ski_> Axman6 : possibly you could using that instead of `return . runST' ?
18:43:32 <roconnor> llayland: have fun
18:43:47 <dpratt71> whither MonadsAsContainers?
18:44:00 <ski_> @wiki MonadsAsContainers
18:44:00 <lambdabot> http://www.haskell.org/haskellwiki/MonadsAsContainers
18:44:16 <ski_> hm
18:44:19 <dpratt71> thanks ski_ nee lambdabot
18:44:25 <ski_> it's not there
18:44:40 <dpratt71> I retract my thanks then
18:44:45 <dpratt71> ;)
18:44:55 <ski_> <http://www.haskell.org/haskellwiki/Monads_as_containers>
18:45:06 <ski_> @wiki Monads_as_containers
18:45:06 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_containers
18:45:07 <ski_> if you will
18:45:13 <dpratt71> thanks...for reals this time
18:45:20 <pumpkin> there's also http://www.haskell.org/haskellwiki/Monads_as_Computation if you want the counterpart
18:45:24 <ski_> (`wiki' is just a dumb command, it appears)
18:45:27 <pumpkin> and byorgey's monads as burritos
18:45:41 <roconnor> is there Monads as Sequencing?
18:45:53 <roconnor> anyhow
18:45:59 * roconnor votes for Monads as Computatoin
18:46:08 <pumpkin> I prefer burritos myself
18:46:32 <roconnor> If you wrap a burrito inside a burrito, do they fuse?
18:46:43 <pumpkin> yeah, it's awesome
18:46:58 <pumpkin> from burrito + burrito to burrito to nothing at all!
18:47:05 <pumpkin> (beacuse I ate it)
18:47:10 <lispy> > let burito = (+1) in join burrito 1
18:47:11 <ski_> `Burrito a -> Void' ?
18:47:11 <lambdabot>   Not in scope: `burrito'
18:47:13 <roconnor> I return wraps refried beans or whatever inside a tortia?
18:47:17 <lispy> > let burrito = (+1) in join burrito 1
18:47:18 <roconnor> And return ...
18:47:18 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a1
18:47:18 <lambdabot>      Prob...
18:47:21 <pumpkin> lol
18:47:28 <lispy> > let burrito = (+) in join burrito 1
18:47:29 <lambdabot>   2
18:47:32 <lispy> there we go :)
18:47:37 <pumpkin> :)
18:49:33 <BMeph> roconnor: I noticed that you said you had a better mental map on "join" vice "bind." Have you considered the Kleisli version? :)
18:50:02 <Axman6> hmm, ow i need to figure out why i'm getting errors in the results...
18:50:20 <roconnor> BMeph: I just mean that I find it easier to spot a join function
18:50:45 <roconnor> for example, that is how I noticed that the Completion operation for metric spaces is a monad
18:50:50 <pumpkin> > forever burritos
18:50:53 <lambdabot>   Nothing
18:50:57 <pumpkin> :(
18:50:59 <pumpkin> meanie
18:51:16 <roconnor> twice completing a metric space is the same as completing it once.
18:51:42 <roconnor> (some people think the fact that  C (C X) is isomorphic to C X makes this operation a stupid monad)
18:53:38 <lispy> There are no stupid monads, just inqusitive functors!
18:53:42 <Axman6> hmm, this thing has terible performance -_-
18:56:12 <BMeph> pumpkin: I made you a burrito...
18:56:23 <BMeph> pumpkin: ...but I eated it. ;p
18:56:30 <ski_> (roconnor : isn't closure operations always monads ?)
19:00:05 <BMeph> roconnor: Have you pointed "some people" in the direction of strings-as-monads? ;)
19:00:29 <int80_h> okay I'm starting ex. 9 Chapter 3 RWH. Here's where I'm at right now
19:00:34 <int80_h> http://hpaste.org/13907#a4
19:01:38 <Axman6> int80_h: you might find the max function useful for calcHeight
19:02:00 <int80_h> Axman6: not sure if I can use max. I'll check
19:02:32 <Axman6> calcHeight (Node _ tl tr) = max tlh trh where ...
19:02:48 <Axman6> your problem is when tlh and trh are equal
19:02:57 <Axman6> > max 1 2
19:02:59 <lambdabot>   2
19:03:00 <Axman6> > max 2 2
19:03:03 <lambdabot>   2
19:03:03 <Axman6> > max 3 2
19:03:05 <lambdabot>   3
19:03:15 <int80_h> Axman6: oh, I can just add an "otherwise" clause
19:03:23 <Axman6> :\
19:03:28 <Axman6> why not use max?
19:03:39 <Axman6> it's clearer and less error prone
19:04:01 <int80_h> axman6: Well, I'm working from a book, RWH. If I use things not introduced yet, I'll be cheating and missing the point
19:04:28 <Axman6> bah, max isn't cheating, ask dons or bos, i'm sure they'll agree :P
19:04:37 <int80_h> axman6: there are many, easier ways to do these exercises, but that misses the point, if I don't stick to just using what's been introduced.
19:04:49 <int80_h> @last dons
19:04:50 <lambdabot> No module "dons" loaded
19:05:05 <int80_h> @when dons
19:05:05 <lambdabot> Maybe you meant: seen what where wn
19:05:14 <int80_h> @seen dons
19:05:14 <lambdabot> dons is in #concatenative, #arch-haskell, #novalang, #darcs, #xmonad, #ghc and #haskell. I last heard dons speak 2h 56m 30s ago.
19:05:16 <Axman6> plus, you probably want something like | tlh > trh = tlh | otherwise = trh
19:05:24 <Pseudonym> There should be a dons module.
19:05:43 <adu_> lol
19:05:45 <Axman6> urgh, it's too hot!
19:06:13 <Pseudonym> Axman, how hot?
19:06:30 <Pseudonym> Cool change has recently hit here.
19:07:41 <Axman6> Pseudonym: 35.1 apparently
19:07:43 <Axman6> C
19:08:23 * Axman6 sticks an ice brick under his arm
19:08:38 <Pseudonym> Right, it's down to 27C or so outside now.
19:08:54 <Axman6> where're you again?
19:08:56 <Pseudonym> The high temperature was at 9am.
19:08:58 <Pseudonym> Melbourne
19:09:05 <Axman6> ah right, i'm up in canberra
19:09:10 <Pseudonym> Right.
19:09:18 <Pseudonym> Had a horrible night, but it's been a pleasant afternoon.
19:09:44 <Axman6> urgh, supposed to be 21 - 36 tomorrow
19:10:41 <Pseudonym> People in other countries don't understand everything that is implied by the term "cool change".
19:13:58 <jberg> @hoogle find
19:13:59 <lambdabot> Data.ByteString find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
19:13:59 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
19:13:59 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
19:14:14 <jberg> @hoogle isAlphaNum
19:14:31 <jberg> @hoogle isNumeric
19:14:52 <lambdabot> Data.Char isAlphaNum :: Char -> Bool
19:14:53 <lambdabot> No results found
19:15:20 <intoverflow> What's the difference between hoogle and hayoo?
19:16:59 <gwern> > "φ"
19:17:01 <lambdabot>   "\966"
19:17:07 <gwern> hm
19:17:17 <gwern> > encodeString "\966"
19:17:19 <lambdabot>   Not in scope: `encodeString'
19:19:09 <dolio> , text "\966"
19:19:11 <lunabot>  
19:19:15 <Axman6> argh, my planets are gaining energy!
19:19:36 <Axman6> well, getting less negative...
19:19:45 <gwern> Axman6: do a slingshot around to rob them of angular momentum!
19:19:58 <Axman6> good idea!
19:20:08 * Axman6 figures out how to do that in haskell...
19:32:24 <gwern> > [1..10] `intersect` [10..20]
19:32:26 <lambdabot>   [10]
19:33:04 <gwern> > foldr [] (intersect) [[1..10], [1], [5..10]
19:33:05 <lambdabot>   <no location info>: parse error on input `;'
19:33:24 <gwern> > foldr [] (intersect) [[1..10], [1], [5..10]]
19:33:25 <lambdabot>   Couldn't match expected type `a -> b -> b'
19:33:31 <gwern> bah. hm.
19:33:45 <Japsu> > foldr intersect [] [[1..10], [1], [5..10]]
19:33:47 <lambdabot>   []
19:34:02 <Axman6> hmm, i can;t for the life of me figure out what i've done wrong in this program. it seems to do things correctly, but the numerical answers are slightly off
19:34:16 <gwern> Japsu: well that's not right :)
19:34:21 <Japsu> gwern: well obviously ;)
19:34:23 <gwern> or, wait, nm
19:34:27 <Japsu> but it typechecks, so let's ship it!
19:34:40 <gwern> > foldr intersect [] [[1..10], [1], [1..10]]
19:34:42 <lambdabot>   []
19:34:44 <Japsu> umm
19:34:52 <Japsu> gwern: intersect [] _ = []
19:35:02 <Axman6> @src intersect
19:35:03 <lambdabot> intersect = intersectBy (==)
19:35:07 <Axman6> @src intersectBy
19:35:07 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
19:35:11 <gwern> > foldr intersect [1..10] [[1..10], [1], [1..10]]
19:35:13 <lambdabot>   [1]
19:35:27 <gwern> hm. I guess I could call head on my list...
19:35:41 <Axman6> foldr1?
19:35:56 <Axman6> > foldr1 intersect [[1..10], [1], [1..10]]
19:35:58 <lambdabot>   [1]
19:35:59 <gwern> let foo = [[1..10], [1..20], [1..20], [1]] in foldr intersect (head foo) (tail foo)
19:36:02 <Axman6> > foldr1 intersect [[1..10], [1..5], [1..10]]
19:36:03 <lambdabot>   [1,2,3,4,5]
19:36:08 <gwern> > let foo = [[1..10], [1..20], [1..20], [1]] in foldr intersect (head foo) (tail foo)
19:36:10 <lambdabot>   [1]
19:36:27 <dublpaws> it's -2C here, not nearly as bad as midwest US at -20C, people in towns nearby lost power for weeks because of iced trees breaking onto power lines. One guy died because his battery backup failed on his medical contraption.  When I was a kid we didn't have heat, only candles made of ear wax which we used to cook rock soup and dirt cookies.
19:36:30 <gwern> well I like the looks of foldr1 anyways
19:36:51 <gwern> dublpaws: mmm.. I hear they make mean dirt cookiees in haiti
19:36:59 <Japsu> hmm
19:37:00 <Axman6> dublpaws: i coule give you 10C if you like, i've got too much C here -_-
19:37:03 <Japsu> :t foldr_
19:37:05 <lambdabot> Not in scope: `foldr_'
19:37:14 <dublpaws> sad truth to those dirt cookies..
19:37:29 <Japsu> isn't there a foldr that simply uses the head of the list as the initial value
19:37:30 <Japsu> :t fold
19:37:30 <Pseudonym> Cue Four Yorkshiremen sketch in 3... 2...
19:37:31 <lambdabot> Not in scope: `fold'
19:37:37 <Axman6> Japsu: foldr1
19:37:42 <dibblego> Japsu, foldr1
19:37:46 <Japsu> yeah, that
19:37:50 <Japsu> :t foldr1
19:37:51 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
19:38:09 <Japsu> > foldr1 intersect [[1..10], [10..20]]
19:38:10 <lambdabot>   [10]
19:38:12 <Axman6> hmmm
19:38:19 <Japsu> bah
19:38:25 <Axman6> > foldr1 ((++).return) [1..10]
19:38:25 <Japsu> ..nvm
19:38:26 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
19:38:26 <lambdabot>        Expect...
19:38:34 <Axman6> > foldr1 (flip ((++).return)) [1..10]
19:38:35 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
19:38:35 <lambdabot>        Expect...
19:38:37 * Japsu fails at reading
19:38:38 <Axman6> bah
19:38:58 <Japsu> why did you have to involve the list monad in such a simple task >_>
19:39:24 <Japsu> ..oh well
19:42:46 <mmorrow> gaH, what the Clean code is doing is cool and all, but the code itself is hideous! (e.g.) http://moonpatio.com/repos/Clean/dynamic/linkers/shared/DynamicLinkerOffsets.icl
19:43:28 <Axman6> urgh, why oh why does hpaste have such a small limit on the ammmount you can paste?
19:43:46 <mmorrow> Axman6: use hpaste2 on moonpatio, it has a massive size limit
19:43:57 <mmorrow> http://moonpatio.com:8080
19:44:20 <mmorrow> and it's the newer version of hpaste by glguy
19:44:24 <mmorrow> with search!
19:45:10 <Axman6> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=760#a760 my new n-bodies program (shootout) it's not very fast though
19:45:42 <Axman6> and from what i can tell, not easily parallelised (the problem, more than the program)
19:46:00 <gwern> 'res ←  liftM (join·join) $ mapM (λfile →  mapM (go' repo file) regexps) filesMatchingAllPatte
19:46:06 <gwern> ^^ bwa ha ha
19:46:29 <kmeyer> gwern: do you have some editor that does that to the syntax?
19:46:35 <gwern> kmeyer: yes, yi
19:46:41 * gwern thinks its totally leet
19:46:43 <kmeyer> yi?
19:47:05 <gwern> yes, yi
19:47:08 <gwern> @where yi
19:47:08 <lambdabot> http://www.haskell.org/haskellwiki/Yi
19:47:16 <Axman6> tezt editor written in haskell kmeyer
19:47:19 <Axman6> x*
19:48:03 * mmorrow too thinks it is totally leet
19:48:09 <gwern> oh ignazz yore sinful tzourceware has korrupted me
19:49:48 <Axman6> now i need to figure out why this damn program is giving the wrong results -_-
19:49:52 <sleven> gah
19:50:23 <sleven> i think the Dijkstra-quote about Cobol is perfectly applicable to Java. It cripples the mind.
19:50:26 * jeffwheeler loves Yi, too
19:50:35 <gwern> I need to figure out why my darcsSearch function is so epically fucked up :(
19:50:39 <sleven> is Yi something like Proog General?
19:50:52 <jeffwheeler> sleven: what's Proog General?
19:50:54 <jeffwheeler> Prolog?
19:51:02 <gwern> if Proog General were a text editor written in haskell, then yes!
19:51:41 <mmorrow> , generalCategory 'λ'
19:51:43 <lunabot>  LowercaseLetter
19:51:59 <mmorrow> , show (isSymbol 'λ') ++ "!!"
19:52:01 <lunabot>  "False!!"
19:52:02 <gwern> if Proog General were a text editor written in haskell, then yes!
19:52:05 <gwern> er.
19:52:11 <jeffwheeler> Still.
19:52:44 <jeffwheeler> I just got Yi running on my Linux box, and it feels so much more friendly than on my small Mac terminal.
19:53:09 <jeffwheeler> Plus, I'm not using a painful keyboard layout. It's much better altogether, now.
19:53:09 <gwern> it works better?
19:53:15 <thoughtpolice> sleven: you mean proof general?
19:53:26 <thoughtpolice> sleven: if so, then no. it's not. :)
19:53:28 <jeffwheeler> gwern: no, just more fun to use with a full-sized keyboard and the nicer Tango colors from gnome-terminal
19:53:31 <hydo> What's the functional equivalent to perldoc / rdoc / etc. for cabal err.. or haskell?  Is there a way to read formatted code docs locally?
19:53:42 <gwern> @where haddock
19:53:42 <lambdabot> http://www.haskell.org/haddock/
19:53:49 <hydo> thanks, gwern!
19:54:02 * jeffwheeler thinks the 'k' on the end is odd
19:54:23 <gwern> not familiar with the fish I see
19:54:41 <jeffwheeler> Nope, but Wikipedia is.
19:54:44 <gwern> @wn haddock
19:54:45 <lambdabot> *** "haddock" wn "WordNet (r) 2.0"
19:54:45 <lambdabot> haddock
19:54:45 <lambdabot>      n 1: lean white flesh of fish similar to but smaller than cod;
19:54:45 <lambdabot>           usually baked or poached or as fillets sauteed or fried
19:54:45 <lambdabot>      2: important food fish on both sides of the Atlantic; related
19:54:47 <lambdabot>         to cod but usually smaller [syn: {Melanogrammus aeglefinus}]
19:55:59 <gwern> screw it. this is just not working. time to start over
19:58:21 <mmorrow> haha, don't you just at the same time love it and hate it when that happens
19:59:02 <mmorrow> clean slate!! one week with nothing to show but the knowledge of what not to do!!
19:59:05 <gwern> no. I hate it very much. darcsSearch is the last function that's buggy, and that's 2 hours work
19:59:50 <Axman6> could someone have a look at http://hpaste.org/13912 and tell me if i'm correct that the two functions are equivilent?
20:00:08 * BMeph finds that staying out late isn't as fun when the wife isn't at home to complain about it...
20:00:45 <Axman6> mainly that i can call move on the i'th element of the list while in the first forM_ loop because it won't be modified again?
20:01:01 <gwern> BMeph: WHAT ARE YOU DOING GO TO BED ALREADY HONEY YOU'LL WAKE UP THE KIDS, THINK ABOUT YOUR JOB
20:01:28 <mmorrow> oh shit yesh! /me just found something he's been looking for http://moonpatio.com/repos/Clean/tools/elf_linker/
20:01:57 <kmeyer> mmorrow: ld in haskell?
20:02:05 <int80_h> that would rock
20:02:08 <int80_h> is it?
20:02:16 <Axman6> uh, apart from the p <- readArray ps i being in the wrong place
20:04:16 <Axman6> pumpkin! you're smart and awesome at haskell, you'd be able to tell me if these functions are equivilent for sure! http://hpaste.org/13912#a1 :P
20:04:24 <pumpkin> o.O
20:04:26 <mmorrow> gah, java verbosity + underscores + non-80-col-max-code == vomit-a-little-in-mouth hellishness
20:04:27 <mmorrow> relocate_text n_relocations virtual_address real_module_offset virtual_module_offset first_symbol_n relocations xcoff_a marked_offset_a0 module_offset_a  symbol_a text_a0
20:04:30 <mmorrow> sweet!
20:04:36 <mmorrow> kmeyer: yes!
20:05:07 <mmorrow> well, not ld, but code that can dynamically link code into a running process (it's own!)
20:05:17 <pumpkin> Axman6: so the only difference is that you're doing two loops vs one
20:05:19 <Axman6> :o
20:05:20 <pumpkin> over the same range?
20:05:25 <Axman6> pumpkin: yeah
20:05:46 <pumpkin> hmm
20:05:52 <Axman6> the OCaml version  i'm using as a reference uses a second loop, which i'm pretty sure isn't necessary
20:05:58 <pumpkin> have you tried it for simple inputs? :P
20:06:06 <pumpkin> quickcheck them for equality :P
20:06:31 <Axman6> heh, i would, but it's all ST and STArrays and yuck stuff i don't want to mess with
20:06:33 <ddarius> Write an instance of Eq for functions and then check if they are equal.
20:06:39 <pumpkin> hah
20:06:50 <pumpkin> Axman6: make it pure!
20:07:05 * hydo reads up on quickcheck...
20:07:15 <Axman6> if i made it pure, it'd overflow the stack and/or my RAM very quickly
20:07:21 <pumpkin> why?
20:07:30 <Axman6> hydo: the RWH chapter on techint nd QA is excellent imo
20:07:31 <mmorrow> instance Eq (a -> b) where _ == _ = unsafePerformIO (peek nullPtr :: IO Bool)
20:07:39 <pumpkin> pure doesn't have to be lazy/inefficient
20:07:42 <Axman6> pumpkin: because that's how i started, and that's what it did :P
20:07:46 <pumpkin> lol
20:08:00 <sleven> when you do a singular value decomposition what do you really get out? like I know it is used in machine elarning for example but I don't understnad uite what it does. people use it for the netflix prize for example. could I make a matrix of movies and users and their grade and then gues the zeros with the help of SVD?
20:08:05 <hydo> Axman6: oh nice, I didn't even think to check rw.
20:08:07 <sleven> since math is a buncha trolls
20:08:09 <Axman6> this is my third iteration of the program
20:08:10 <hydo> err.. rwh
20:08:36 <zkincaid> Hey - if I have something like "class Fst a b | a -> b, class Snd a b | a -> b", does anyone know why I can't write "data (Fst x a, Snd x b) => Pair x = Pair a b"?
20:08:49 <thoughtpolice> hydo: http://realworldhaskell.org
20:09:04 <mmorrow> because "| a -> b" means that `a` uniquely determines `b`
20:09:23 <mmorrow> oh, oops
20:09:24 <hydo> thoughtpolice: oh yea :)  I had it mapped to a hotkey for a while.  Thanks just the same though :)
20:09:26 <sjanssen> zkincaid: because GHC isn't that smart
20:09:32 <mmorrow> i didn't see that they're two classes
20:09:41 <sjanssen> zkincaid: that can be done with associated types, however
20:10:06 <zkincaid> ok cool - I'll look them up.  Thanks
20:10:46 <zkincaid> ghc lets me construct the type I want using a type synonym, I was just wondering why it wouldn't let me right in the data type declaration
20:11:50 <Ralith> why does [1..2] + [2..1] == [1..2]?
20:12:06 <Axman6> eh?
20:12:07 <dolio> > [2..1]
20:12:09 <lambdabot>   []
20:12:16 <Axman6> ++?
20:12:19 <Ralith> ++, yes
20:12:21 <Ralith> dolio: ah.
20:12:32 <Ralith> oooh
20:12:38 <Axman6> > [3,2..0]
20:12:39 <lambdabot>   [3,2,1,0]
20:12:39 <mmorrow> zkincaid: also you could use a GADT
20:12:40 <Ralith> I have to do [x,x-1..y]
20:12:40 <kmeyer> mmorrow: oh god
20:12:43 <chessguy> @src enumFromTo
20:12:43 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
20:12:45 <Ralith> forgot about that
20:12:53 <mmorrow> class Fst a b | a -> b          class Snd a b | a -> b
20:12:54 <cjs> Do Data.Maps rebalance themselves automatically as one inserts? If one's creating a map one's going to use a lot, is there a way to generate an optimally balanced copy? or should one even care? Should I be using a map for only twenty-five values, or just an assoc list?
20:13:01 <cjs> Oh, and did I miss any questions? :-)
20:13:05 <mmorrow> data Pair x where Pair :: (Fst x a, Snd x b) =>  a -> b -> Pair x
20:13:09 <mmorrow> kmeyer: hehe
20:13:30 <Axman6> cjs: i think they do, pretty sure i read that
20:13:30 <chessguy> @source Map
20:13:30 <lambdabot> Map not available
20:13:35 <chessguy> @source Data.Map
20:13:35 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
20:13:45 <chessguy> @docs
20:13:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
20:13:52 <zkincaid> mmorrow: ahh yeah that's a good idea - thanks
20:13:55 <dolio> If you already have a list of sorted keys you can do fromAscList or something, which is probably more efficient than inserting one at a time.
20:14:02 <Axman6> "The implementation of Map is based on size balanced binary trees (or trees of bounded balance) as described by:" ?
20:14:04 <mmorrow> foo :: (Fst x a) => Pair x -> a; foo (Pair a b) = a
20:14:12 <mmorrow> (i think that'd work)
20:14:15 <chessguy> cjs:  check out the paper on http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html
20:14:16 <cjs> Ah, yes, I've found the paper.
20:14:17 <sjanssen> cjs: hmm, Data.Map probably is faster for 25 elements
20:14:27 <sjanssen> cjs: what is your key type?
20:14:35 <cjs> Errr. Double. :-(
20:14:38 <mmorrow> (the GADT would work, "i think" being @ that function)
20:14:49 <cjs> (That needs to be fixed. I can scale it and make it an Int.)
20:15:07 <mmorrow> oh no, that function wouldn't work
20:15:23 <sjanssen> Data.Map Double is scary -- == on Doubles is almost always wrong
20:15:27 <mmorrow> well, it should, but it doesn't :(
20:15:44 <cjs> Yeah, well it works for me only because I never do calculations on these particular values. (They're strike prices of options.)
20:15:48 <mmorrow> unsafeCoerce to the rescue?
20:15:55 <cjs> But it still scares me, too.
20:16:11 <chessguy> cjs:  yeah, but you still have to use == to retrieve the values
20:16:23 <Axman6> > (minBound :: Double)
20:16:24 <lambdabot>       No instance for (Bounded Double)
20:16:24 <lambdabot>        arising from a use of `minBound...
20:16:26 <Axman6> hmm
20:16:38 <cjs> Actually, for Data.Map you need Ord, not just Eq. I expect it uses compare or whatever it's called.
20:16:56 <chessguy> > 2 :: Double == (2 :: Double)
20:16:57 <lambdabot>   <no location info>: parse error on input `Double'
20:16:59 <cjs> Oh, wait, Ord implies Eq, doesn't it. Or does it?
20:17:11 <dolio> Eq is a precondition.
20:17:16 <chessguy> @src Ord
20:17:16 <lambdabot> class  (Eq a) => Ord a  where
20:17:16 <lambdabot>     compare      :: a -> a -> Ordering
20:17:16 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
20:17:16 <lambdabot>     max, min         :: a -> a -> a
20:17:17 <dolio> They probably use compare, though.
20:17:25 <dolio> That's what I'd do.
20:17:36 <sjanssen> cjs: Data.Map uses compare, yes
20:17:41 <cjs> Oh, of course, they have to so that they know which side of the tree to branch down if the key isn't equal.
20:17:57 <sjanssen> but compare still has a notion of equality, which is still dangerous with Double (but probably safe in your usage)
20:19:05 <crutcher> We just took a shot at running a RWH book club at work. It seemed to go well, but there was a very large spread of haskell knowledge in the room.
20:19:19 <mmorrow> type inference fail: http://hpaste.org/13913
20:19:27 <Axman6> what's wrong with that crutcher?
20:19:32 <cjs> crutcher: That's pretty typical, these days, to have a large spread.
20:19:33 <mmorrow> (and unsafeCoerce to the rescue)
20:19:45 <chessguy> crutcher:  yeah, we're finding that in the RWH book club here too
20:19:59 <crutcher> I'm not sure if there's anything wrong with it.
20:19:59 <BMeph> cjs: Used the Fixed type, vice Doubles. :)
20:20:04 <BMeph> *Use
20:21:29 <mmorrow> type families get it correct though
20:21:49 <chessguy> mmorrow:  is this a failure of GADTs?
20:21:55 <cjs> BMeph: Mmm, I've glanced at that a couple of times. Seemed a bit more work than really necessary, though perhaps because I don't completely understand it.
20:22:06 <mmorrow> http://hpaste.org/13913#a1
20:22:26 <mmorrow> chessguy: i believe it's a failure of functional dependencies
20:23:07 <chessguy> mmorrow:  so why the GADT then?
20:23:38 <cjs> BMeph: Hm. so if it's fixed to two digits, I'd just create an E2 data type with instance HasResolution E2 where resolution _ = 100?
20:23:46 <mmorrow> chessguy: to ensure that a Pair x contains an `a' and `b' s.t. Fst x ~ a and Snd x ~ b
20:23:53 <BMeph> cjs: Well, there's always CReal... >;)
20:24:01 <Trafalgard> Gah.
20:24:12 <Trafalgard> I wish 'Either' and 'Maybe' were named something else
20:24:24 <Trafalgard> just because it's making googling a pain in the ass :P
20:24:44 <cjs> What are you looking for? Maybe you want hoogle instead?
20:24:56 <Trafalgard> I just gave up on hoogle and went to google
20:25:04 <BMeph> Trafalgard: Really, I thought "x girls y cups" made googling a PITA... ;p
20:25:28 <Trafalgard> it's actually something fairly simple
20:25:28 <BMeph> cjs: Sounds right (RE: the Fixed instance). :)
20:25:58 <thoughtpolice> mmorrow: type families == uberwin
20:26:17 <mmorrow> thoughtpolice: totally.
20:26:19 <ddarius> Trafalgard: A lot of useful functions are instances of much more general functions so googling for a specific type name isn't as useful as it could be.
20:26:40 <Trafalgard> I want a safe version of readInt - e.g. it wouldn't error, it would be Maybe Int
20:26:49 <mmorrow> @type reads
20:26:50 <lambdabot> forall a. (Read a) => String -> [(a, String)]
20:26:53 <Trafalgard> but I can't find anything like that
20:27:19 <mmorrow> @type \s -> case reads s of [(n,_)] -> Just n; _ -> Nothing
20:27:20 <lambdabot> forall a. (Read a) => String -> Maybe a
20:27:41 <mmorrow> @let readM s = case reads s of [(n,_)] -> Just n; _ -> Nothing
20:27:43 <lambdabot>  Defined.
20:27:51 <mmorrow> > readM "42"
20:27:52 <lambdabot>   Nothing
20:27:57 <mmorrow> > readM "42" :: Just Int
20:27:59 <lambdabot>   Not in scope: type constructor or class `Just'
20:28:03 <mmorrow> > readM "42" :: Maybe Int
20:28:04 <mmorrow> heh
20:28:04 <lambdabot>   Just 42
20:28:06 <Trafalgard> I have no idea what you just did
20:28:18 <mmorrow> > reads "42" :: [(Int,String)]
20:28:20 <lambdabot>   [(42,"")]
20:28:21 <Trafalgard> I typed @type in ghci and it went "WTF is this @ doing in this line"
20:28:37 <mmorrow> heh, that's just for lambdabot
20:28:46 <thoughtpolice> Trafalgard: yeah these are lambdabot commands, in ghci you want the ':type' command (try ':help' for more)
20:28:48 <ddarius> :t fmap fst . listToMaybe . reads
20:28:50 <lambdabot> forall a. (Read a) => String -> Maybe a
20:29:07 * Trafalgard reads what you did slowly to figure out what the anonymous functions are doing
20:29:15 <Trafalgard> and stuff.
20:29:16 <ddarius> Explicit case is for the uncouth.
20:29:18 <mmorrow> @let list n _ [] = n; list _ c (x:xs) = c x xs
20:29:21 <lambdabot>  Defined.
20:29:30 <thoughtpolice> but I'm pretty sure the solution mmorrow just showed is uh, basically the solution most everybody uses
20:29:32 <Cale> mmorrow: I'm pretty sure there's almost no interaction between GADTs and functional dependencies.
20:29:38 <thoughtpolice> when they want a version of read that works over maybe
20:29:55 <thoughtpolice> except ddarius obviously
20:30:00 <mmorrow> Cale: yeah, i think that must be the case by what i've seen lately
20:30:14 <Axman6> huh.. modified my program to make it more efficient, and got rid of the mathematical error i was getting
20:30:34 <mmorrow> i wonder if that'll ever be fixed since it works fine with type families
20:31:35 <cjs> BMeph: I guess the one thing about using Fixed is that it uses Integer internally, rather than Int, so it wouldn't be as efficient as rolling my own with Int.
20:32:11 <cjs> Especially given the very limited number of operations I need.
20:32:13 <Cale> mmorrow: I have a solution, yes, type families work.
20:32:27 <mmorrow> heh, sounds good to me
20:32:30 <Cale> http://hpaste.org/13913#a2
20:32:42 <mmorrow> ah /me looks
20:32:49 <Cale> The types are more readable too.
20:33:08 <mmorrow> heh, look at the paste right above yours :)
20:33:15 <crutcher> if I want to wait on a lock, should I use something other than an MVar?
20:33:19 <Cale> er, yeah.
20:33:24 <mmorrow> hehe
20:33:41 <crutcher> okay, what should I use?
20:33:50 <thoughtpolice> as I said, type families == uberwin!
20:33:57 <Cale> mmorrow: (sorry, I hadn't noticed :)
20:33:58 <cjs> crutcher: No, I think an MVar is exactly what you want. (I think Cale was responding to someone else.)
20:34:03 <mmorrow> Cale: :)
20:34:07 <crutcher> ok :)
20:34:17 <thoughtpolice> resistance is futile
20:35:13 <mmorrow> Cale: interesting though how we chose to convey the types in the "Pair :: ..." def in the GADT
20:35:26 <cjs> crutcher: Oh, wait, I forgot about Control.Concurrent.QSem.
20:35:46 <cjs> Though it's probably built on MVar (). :-)
20:35:50 <Cale> Yeah, I didn't use explicit type equalities.
20:35:53 <mmorrow> Cale: it didn't cross my mind to do it that way
20:35:55 <mmorrow> yeah
20:36:05 <Cale> I think of type families as just being arbitrary type functions.
20:36:26 <Cale> (Or fairly arbitrary anyway)
20:36:30 <mmorrow> it'd be cool if
20:36:31 <mmorrow> yeah
20:36:38 <mmorrow> "fairly" being the key word
20:36:42 <mmorrow> :(
20:36:45 <crutcher> cjs: actually, its probably more complex, because a semaphore can have more than one 'key' attached to it.
20:36:59 <cjs> crutcher: Yes, it is. newtype QSem = QSem (MVar (Int, [MVar ()]))
20:37:03 <crutcher> cjs: they are more like a bucket full of rocks, or a key peg full of keys
20:37:23 <crutcher> okay, I'll keep using my MVar ()
20:37:31 <cjs> crutcher: But not because of quantities; it's always one for a QSem. QSemN is the variable-quantity one.
20:37:59 <Cale> mmorrow: The differences between the type level and value level in Haskell are a bit funny.
20:38:03 <cjs> Oh, wait, that's available quantities. I'm on crack. Never mind. Yeah, just stick with the MVar.
20:38:29 <cjs> crutcher: Though if you're using multiple locks, you probably want to consider TVars.
20:38:45 <crutcher> cjs: each lock will be used exactly once.
20:39:10 <cjs> Yes, but will you be holding multiple locks at the same time?
20:39:18 <mmorrow> Cale: they are. i've been reading about Pure Type Systems/other deptype misc recently and i've started to see that there doesn't need to be (assuming a suitable type system) any distinction
20:39:23 <int80_h> see ya later guys
20:39:35 <crutcher> cjs: but I want 'readMVar' to block.
20:40:07 <Cale> I think maybe termination of the typechecker is a bit overrated, but type inference is certainly not.
20:40:11 <cjs> Oh, right. Never mind. I'll just sit here amongst my crack vials....
20:40:41 <dolio> Agda doesn't strike too poor a balance.
20:40:50 <dolio> Considering I annotate all my Haskell functions at the top level.
20:41:01 <dolio> And that's all you have to do there.
20:41:07 <mmorrow> and the parts that are statically computable, are statically computed (and if that exp is of type Type it's erased), and if not, the types are _computed_ at runtime along with other values (ie a type is a value)
20:41:08 <pumpkin> the undecidable instances language option... does anyone have any simple examples of an undecidable one?
20:41:12 <Cale> I don't want to be *forced* to annotate all top-level bindings though.
20:41:14 <dolio> The only thing I wouldn't normally do is give types for stuff in where clauses.
20:41:22 <gwern> it passed!
20:41:25 <gwern> IT PASSED
20:41:27 <pumpkin> gwern: yay
20:41:28 <gwern> wooooooooooooooooooooooooo
20:41:34 <gwern> finally, my darcs backend is done!
20:41:35 <Axman6> what;s 'it'?
20:41:41 <gwern> holy shit, I've been working on this for weeks
20:41:43 <Cale> If something has an HM type, and the HM type is the one I want for it, then that type should be inferred.
20:41:48 <gwern> and now it passes all 15 tests
20:41:54 <gwern> one stupid trivial change
20:41:56 <mmorrow> Cale: totally
20:42:08 <Trafalgard> does this require any language extensions? --> <mmorrow> @let readM s = case reads s of [(n,_)] -> Just n; _ -> Nothing
20:42:15 <mmorrow> this paper is really interesting for the different viewpoint it gives http://web.cecs.pdx.edu/~sheard/papers/FossacsErasure08.pdf
20:42:20 <pumpkin> Trafalgard: don't think so
20:42:24 <Trafalgard> hrm
20:42:26 <mmorrow> Trafalgard: no
20:42:33 <gwern> I feel like a rat whose intermittent reinforcement schedule has just decreed a heroin reward!
20:42:35 <thoughtpolice> gwern: for what?
20:42:35 <thoughtpolice> gwern: gitit?
20:42:36 <mmorrow> but the "@type" is a _lambdabot_ command
20:42:37 <Trafalgard> I put this into ghci: let readM s = case reads s of [(n,_)] -> Just n; _ -> Nothing
20:42:42 <Trafalgard> and then did readM "6"
20:42:49 <mmorrow> add "let " to the front of that
20:42:52 <Trafalgard> and it said Ambiguous type variable `a' in the constraint:
20:42:53 <sutats> What's the difference between an MVar and an IORef?
20:42:55 <mmorrow> oh
20:42:59 <pumpkin> Trafalgard: you haven't specified the type
20:43:00 <Trafalgard> add a second let ? O_o
20:43:00 <pumpkin> for read
20:43:03 <thoughtpolice> Trafalgard: no
20:43:07 <sjanssen> pumpkin: data T a; class C a; instance C (T (T a)) => C (T a)
20:43:08 <mmorrow> Trafalgard: you have to tell it /which/ type you want it to read
20:43:12 <pumpkin> Trafalgard: it can't figure out what you give it based on the string
20:43:22 <mmorrow> > read "42" :: Double
20:43:23 <lambdabot>   42.0
20:43:25 <mmorrow> > read "42" :: Int
20:43:27 <lambdabot>   42
20:43:33 <pumpkin> sjanssen: ooh
20:43:38 <pumpkin> sjanssen: what will GHC do there?
20:43:43 <pumpkin> not decide?
20:43:49 <pumpkin> :P
20:43:51 <mmorrow> > [read "42", pi]
20:43:52 <lambdabot>   [42.0,3.141592653589793]
20:43:54 <Trafalgard> When you did readM "42" it said Nothing instead of erroring
20:44:01 <mmorrow> > [read "42", gcd 2 3]
20:44:03 <lambdabot>   [42,1]
20:44:04 <Trafalgard> when you didn't specify a type
20:44:05 * crutcher must resist telling couple at next table that their knowledge of implant medicine is wrongity wrong wrong.
20:44:14 <gwern> thoughtpolice: gitit and orchid if sebaastian ever switchs it to filestore
20:44:28 <gwern> and whatever other program makes use of the filestore package
20:44:32 <Cale> mmorrow: I wonder how well the results of that paper mesh with separate compilation.
20:44:32 <Trafalgard> but hmm, yeah, I missed that
20:44:39 <sjanssen> pumpkin: GHC has a stack depth limit when resolving instances, so it will just give an error
20:45:09 <mmorrow> Cale: that's a good question
20:45:13 <gwern> my promise to reddit is fulfilled!
20:45:16 <Trafalgard> Ah nice, works now, thanks
20:45:33 <pumpkin> sjanssen: boo, it'd be more fun if it just didn't terminate :)
20:45:35 <mmorrow> Cale: it'd probably require a completely different system for that than the one we use now
20:45:39 <ddarius> crutcher: Why must you resist?
20:45:45 <gwern> on a sidenote, I'm amused that the darcs tests run faster than the git ones
20:45:55 <TML> Can I bootstrap ghc using hugs?
20:45:59 <Cale> TML: no
20:46:10 <crutcher> ddarius: I'm experimenting with being less of a nosey blowhard. Also, they're on a date.
20:46:10 <TML> GAH!
20:46:28 <Cale> TML: What platform are you on?
20:46:51 <Cale> It's usually best to avoid compiling GHC altogether if you can.
20:46:59 * ddarius couldn't imagine what it would be like to build GHC with Hugs.
20:47:10 <TML> Cale: SuSE Linux Desktop x86_64. The ghc binaries segfault.
20:47:12 <thoughtpolice> pumpkin: http://hpaste.org/13914
20:47:21 <thoughtpolice> pumpkin: that's an example
20:47:24 <Cale> You have the x86 linux binaries?
20:47:37 <TML> I have tried both the 32 bit and 64 bit binaries
20:47:41 <Cale> okay...
20:47:46 <TML> 32 bit won't start because I don't have a 32 bit libedit0
20:48:03 <TML> 64 bit segfaults with a "Floating point exception"
20:48:10 <Cale> The first one sounds more easily surmountable than bootstrapping GHC.
20:48:29 <sjanssen> possibly  not
20:48:44 <sjanssen> TML will probably end up having to chase down 32 bit versions of many libraries
20:48:51 <Cale> mmm...
20:48:58 <thoughtpolice> pumpkin: reason it's undecidable is because the typechecker sees that to be an instance of Test2, the *exact* same type needs to be an instance of Test1, but for Test1, the exact same instance needs to be an instance of Test2
20:49:02 <TML> Cale: I tried to install 32 bit libedit0 and spent a day and a half chasing dependencies that never resolved.
20:49:02 * bos tries to decide whether his incremental parser should allow the yielding of partial results.
20:49:28 <sjanssen> TML: does SuSE offer binary packages of GHC?  What version do they have?
20:49:36 <TML> sjanssen: They do not
20:49:49 <sjanssen> really?  That's crap, use a better distro :)
20:49:50 <thoughtpolice> pumpkin: if you take away the 'UndecidableInstances' pragma, look at the error GHC gives - the constraint is not 'smaller' than the instance head.
20:50:09 <TML> I found a 3rd part binary of hugs for it, but that's clearly not going to get me any further.
20:50:43 <sjanssen> TML: is your version of SuSE really old?
20:50:44 <TML> sjanssen: I'm trying to *produce* a binary so that I can feed it back to SuSE's openbuild system so that there will be one.
20:50:49 <TML> sjanssen: No, it's the latest
20:50:52 <pumpkin> thoughtpolice: oh I've seen that before
20:50:56 <pumpkin> thoughtpolice: thanks, that's interesting
20:51:00 <sjanssen> with a really old kernel/glibc/etc. ?
20:51:09 <mmorrow> bos: if it would'nt be a performance loss or anything, partial results would be great for online stuff
20:51:17 <sjanssen> TML: which version of GHC binaries did you try?
20:51:18 <pumpkin> does anyone want to try my new Countable module? :D
20:51:51 <TML> sjanssen: http://www.haskell.org/ghc/download_ghc_6_10_1.html#binaries - the libedit0 versions for x86 and x86_64
20:52:13 <TML> Is there an older/newer one that might have more mojo?
20:52:16 <Cale> http://download.opensuse.org/repositories/devel:/languages:/haskell/openSUSE_11.1/x86_64/ghc-6.10.1-2.9.x86_64.rpm
20:52:22 <Cale> Is that relevant?
20:52:28 <pumpkin> Axman6: I bet you want to try it!
20:52:41 <TML> Cale: No, that's openSuSE. Different distro.
20:52:45 <Cale> ah
20:52:55 <TML> Cale: Again, I'd end up chasing the dependency dragon.
20:53:09 <sjanssen> TML: you might try GHC 6.8.3 instead
20:53:15 <TML> Cale: This is the commercial distro they sell as a corporate desktop
20:53:34 <sclv> oh god suse's haskell support is awful.
20:53:43 <bos> mmorrow: the problem with yielding partial results is that it causes problems with backtracking
20:54:02 <TML> sjanssen: That's at least something to try
20:54:05 <sclv> in general the way the split out 64 bit binaries breaks tons of stuff.
20:54:11 <sclv> s/the/they/
20:54:17 <bos> mmorrow: as in, what if you yield a result, then your parse fails, and another branch yields a result? how do you report that to your caller?
20:54:23 <TML> If I can get a working ghc, I'd be happy to push a newer one into openBuild...I just have to get there first.
20:54:28 <sjanssen> sclv: what do they do with 64 bit?
20:55:24 <mmorrow> bos: yeah, i guess you need to be going it breadth-first for partial results (and the error messages aren't that great)
20:55:44 <sclv> they put them in a nonstandard location, separate from the standard location for the 32 bit stuff -- if everyone obeyed/prepared for their convention it would be fine, but it eventually and inevitably causes messes.
20:56:12 <TML> And I couldn't get the first step at http://hackage.haskell.org/trac/ghc/wiki/Building/Porting to work, either. "./configure --enable-hc-boot --enable-hc-boot-unregisterised" seems to require a functioning GHC on the target machine, which is just.... o.O
20:56:20 <vinicius> mmm regex-dna haskell is broken on alioth benchmark
20:56:35 <sjanssen> TML: don't even bother trying to bootstrap, I don't think it works any more
20:56:46 <TML> sjanssen: I concur with your assesment :)
20:57:08 <thoughtpolice> gwern: what filestore package?
20:57:30 <sclv> i'd be shocked if the opensuse rpms didn't work with the commercial distro, however.
20:57:41 <TML> sclv: They do not
20:57:46 <sclv> oh dear.
20:57:51 <TML> Massive dependency issues
20:58:25 <sclv> oh, right. makes sense.
20:58:26 <TML> Most of the 'open' RPMs have what I can only classify as 'extra version information'
20:58:41 <thoughtpolice> bootstrapping works with ghc 6.4 or ghc 6.6 iirc
20:59:11 <TML> sjanssen: Thank you, 6.8.3 works
20:59:24 <thoughtpolice> the problem is compiling older releases by *newer* ghc's isn't supported
20:59:39 <sjanssen> TML: 6.8.3 should be fully capable of building 6.10, assuming there isn't some underlying compatibility issue with SuSE
20:59:41 <thoughtpolice> so you need a version of GHC older than the version you're trying to bootstrap, on the computer that already has ghc on there!
20:59:59 <thoughtpolice> quite problematic, really. :/
21:00:02 <TML> sjanssen: Makes perfect sense, and that's where I'm headed next. Thank you again.
21:00:06 <thoughtpolice> here's to hoping ghc 6.12 is better
21:00:32 <sjanssen> thoughtpolice: maintaining backwards compatibility indefinitely isn't really possible, though
21:01:09 <pizza_> of course it is
21:01:40 <sjanssen> pizza_: not under a reasonable amount of effort, while also improving the program
21:02:16 <sclv> oh well, if you're going to be *arbitrary* about it :-)
21:03:09 <crutcher> Okay, I've got a basic test for the first variant of my parMapIO / parForIO pair. Does this seem reasonable? http://hpaste.org/13915
21:03:58 <TML> The thing that really confused me was utils/pwd/pwd
21:04:20 <TML> Creates an excellent chicken/egg situation when that doesn't exist :)
21:04:38 <skorpan> so use prolog to find out which came first!
21:05:03 <pizza_> sjanssen: depends on your priorities and your resources
21:10:13 <TML> I realize I'm just showing my ignorance here, but what is it that GHC can do that hugs can't that prevents me from using hugs to build GHC?
21:10:38 <thoughtpolice> compile to native code?
21:11:10 <sjanssen> it is also missing tons and tons of extensions that GHC has
21:11:32 <crutcher> isn't hugs also missing some things actually in the Haskell 98 report?
21:11:49 <thoughtpolice> and probably about 9,000,000 other things; the GHC code base does use quite a few of its own extensions afaics (although normally any GHC release can be compiled by a GHC a few releases backwards - the newest features aren't immediately used in the compiler itself)
21:11:53 <sjanssen> crutcher: possibly, but GHC has a few infidelities as well
21:12:50 <crutcher> sjanssen: yeah, but they probably don't line up
21:13:01 <crutcher> not that I actually know
21:14:30 <crutcher> I need something I can send in an MVar, that I can detect if it has been evaluated or is still a thunk
21:14:33 <crutcher> :(
21:14:59 <crutcher> I'm trying to test parMapIO' in the hpaste I just put up, and I'm not sure how to do that.
21:15:10 <sclv> crutcher: use Debug.Trace
21:15:26 <crutcher> is that acceptable in a unittest?
21:15:54 <sclv> well, it just prints to stderr so it doesn't work very well for a unittest
21:16:25 <sclv> all solutions will involve unsafePerformIO, as far as I know
21:16:42 <sclv> there's probably some stuff on hackage that's related for evaluating strictness.
21:17:03 <thoughtpolice> there's lennart's "traced" package
21:17:10 <crutcher> I guess I could use something like 'unsafePerformIO (putMVar var ())'
21:17:36 <crutcher> that should give me a testable bit using tryReadMVar var
21:17:55 <TML> sjanssen: stage1 seems to have built, so it looks good. Thank you again.
21:18:57 * sclv is surprised that strictcheck isn't on hackage.
21:24:27 <crutcher> grr. The genius at the next table is now talking about how not speaking before your second birthday isn't a problem.
21:48:57 <bos> ddarius: parsec3 doesn't have a test suite?
21:49:50 <ddarius> No more than parsec2 did.
21:49:59 <bos> Fair enough.
21:50:03 <ddarius> I have some stuff, but not much.
21:50:11 <bos> Not in the darcs tree, though?
21:50:32 <ddarius> No.
21:50:56 <gwern> thoughtpolice: http://johnmacfarlane.net/repos/filestore
21:54:19 <cjs> crutcher: Well, you can confirm it's a thunk if you put undefined in it.
21:54:36 <mmorrow> looks like he just quit
22:25:06 <sjanssen> "except the type safety" :) http://www.reddit.com/r/haskell/comments/7pk8l/a_surprisingly_short_library_which_allows_you_to/
22:29:51 <pumpkin> lol
22:30:01 <pumpkin> that's a ridiculous headline, regardless of the content of the article
22:32:26 <ddarius> Argh, Ken Shan's advice was not taken.
22:35:31 <sjanssen> ddarius: hmm?
22:35:43 <ddarius> sjanssen: I'm pretty sure the author of that seriously underestimates even basic type classes, let alone constructor classes, multi-parameter classes, etc. and even ignoring type safety.
22:35:55 <ddarius> sjanssen: "type class" v. "typeclass"
22:36:18 <ddarius> The very first comment on this page: http://book.realworldhaskell.org/read/using-typeclasses.html
22:37:05 <sjanssen> ddarius: hmm
22:37:09 <sjanssen> I'm not even sure which I use
22:37:53 <lament> i like typeclass
22:37:58 <dibblego> I use type-class
22:38:02 <ddarius> The Report uses two words as did the paper introducing them.
22:38:03 <lament> a word for a concept
22:38:19 <ddarius> lament: 'gonna start saying constructorclass?
22:38:41 <lament> strunk and white has a point on this, btw
22:39:46 <sjanssen> ddarius: I ask the questions, because I suspect the answer is "no" -- hopefully being informative in the process
22:40:15 <lament> ddarius: no.
22:43:43 <pumpkin> he says "not in the least" instead of "not least"
22:43:45 <pumpkin> :)
22:50:15 <ddarius> sjanssen: I'm not sure how detailed the reflected information is, but does it even support things like Read or instance Monoid (a -> a) or instance Monoid (a,a) if function types cause problems?
22:52:22 <pumpkin> how does monoid on a -> a work?
22:52:32 <pumpkin> mappend is composition?
22:52:33 <dolio> id and composition.
22:52:40 <pumpkin> neat :)
22:52:48 <dolio> That's not a valid H98 instance, though.
22:52:52 <pumpkin> ah
22:52:54 <ddarius> pumpkin: The Endo instance does that now, but that used to be the monoid instance for functions.
22:52:56 <dolio> Due to the a appearing twice.
22:53:16 <pumpkin> @type Endo
22:53:18 <lambdabot> forall a. (a -> a) -> Endo a
22:53:34 <ddarius> I had some Prolog AST pretty printing code that broke rather nastily when the changed the instances.
22:54:23 <pumpkin> > appEndo (Endo (+1) `mappend` Endo (*4)) 5
22:54:24 <lambdabot>   21
22:54:31 <pumpkin> interesting :)
22:55:21 <ddarius> Both natural instances of Monoid for functions are theoretically extremely important.
22:55:36 <sjanssen> ddarius: hmm, yes.  I note that the examples only include instances with concrete types
22:56:15 <sjanssen> ddarius: though it seems that instances are resolved at the last possible moment, so the concrete type should always be known
22:56:48 <ddarius> Well for the Monoid examples, there would also need to be code somewhere to check that the two types are the same.
22:57:00 <pumpkin> > appEndo (mconcat . map (Endo . (+)) $ [1..9]) 5
22:57:02 <lambdabot>   50
22:57:33 <ddarius> @let showE = Endo . shows
22:57:35 <lambdabot>  Defined.
22:58:06 <sjanssen> I don't even see evidence that something as simple as "instance Monoid [a]" will work
22:58:18 <ddarius> sjanssen: Indeed.
22:58:53 <pumpkin> it looks like although he claims that typeclasses aren't abstract superclasses, he's treating them pretty much like them
22:59:02 <pumpkin> lots of pronounes there
23:00:05 <byorgey> ddarius: what's the other natural instance of Monoid for functions?  the one with  Monoid a => Monoid (e -> a) ?
23:00:33 <ddarius> byorgey: Yes, which is the current instance.
23:00:41 <byorgey> ah, ok, right.
23:01:05 <mornfall> Hm. Where did Adam Langley and his networking packages go? : - |
23:01:40 <pumpkin> what percentage of this room is grad students, I wonder
23:02:35 <byorgey> > mappend (map (Sum.) [(*2), (+5), (`mod` 3)]) 7
23:02:36 <lambdabot>       No instance for (Num [a -> Sum a])
23:02:36 <lambdabot>        arising from the literal `7' ...
23:02:39 <ddarius> pumpkin: Not as nearly high as you probably think, but probably higher than most other programming language channels.
23:02:46 <sjanssen> ddarius: all I can glean from the code is that there is a separate path for "instance.IsGenericType -> //exact type is not known, try the generic type
23:03:10 <bos> mornfall: which ones are you looking for?
23:03:11 <byorgey> > mconcat (map (Sum.) [(*2), (+5), (`mod` 3)]) 7
23:03:12 <lambdabot>   Sum {getSum = 27}
23:03:23 <byorgey> =D
23:03:25 <pumpkin> ddarius: everything feels so academic in here that sometimes it feels like everyone is :) but yeah, I'm sure it's higher than average
23:04:03 <pumpkin> byorgey: what does the monoid get you in that case?
23:04:06 <ddarius> pumpkin: Appearances can be deceiving.  I, for example, have only a high school diploma.
23:04:51 <byorgey> pumpkin: for one example, see http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx
23:05:17 <mornfall> bos: Well, it's not like I can't get the sources, it's more like they don't seem to be very maintained.
23:05:43 <bos> mornfall: he got swallowed up by google.
23:06:05 <mornfall> Ahw.
23:06:07 <pumpkin> ddarius: interesting. I would've guessed you were a hardcore academic (in the best possible sense!)
23:07:15 <mornfall> pumpkin: Hey, the *real* academics wouldn't touch a programming language with a three-foot pole.
23:07:21 <pumpkin> :)
23:07:21 <mornfall> *wink*
23:07:35 <pumpkin> but it's so fun!
23:07:41 <pumpkin> how could anyone not want to touch it!
23:08:04 <mornfall> Am I the only one to find the last sentence a little kinky?
23:08:31 <ddarius> In the spirit of that article on monoids, we should drop the term "tree" and replace it with the term "free pointed magma"
23:09:42 <mornfall> Anyone know how much is HTTP 4000 compatible with HTTP 3000?
23:09:44 <byorgey> @remember ddarius In the spirit of that article on monoids, we should drop the term "tree" and replace it with the term "free pointed magma"
23:09:44 <lambdabot> Done.
23:09:53 <pumpkin> byorgey: that's an interesting post
23:10:27 <byorgey> pumpkin: indeed.
23:10:35 <byorgey> takes a bit to wrap your head around it.
23:13:12 <pumpkin> yeah :)
23:13:53 <crutcher> mornfall: um, what?
23:14:11 <crutcher> mornfall: are you talking about a library or a protocol?
23:14:20 <mornfall> crutcher: HTTP-4000.0.1, to be exact.
23:14:25 <dolio> They're version numbers for the HTTP package.
23:14:33 <crutcher> okay. carry on :)
23:14:34 <dolio> Can't say I understand them.
23:31:51 <crutcher> I've got my ParIO library to a place I'm pretty happy with it, with unit tests: http://hpaste.org/13916
23:32:16 <crutcher> Now I need to turn that into a proper module, and put it in darcs
23:33:01 <crutcher> I'd appreciate any criticism of the code, if anyone has time
23:34:33 <mornfall> crutcher: Have you done some benchmarking on that?
23:34:56 <crutcher> mornfall: nope. Don't really know how yet.
23:35:01 <mornfall> (I'm wondering how big the single task needs to see actual speedup...)
23:35:15 <mornfall> s/to see/to be to see/ : - )
23:35:33 <crutcher> well, you shouldn't use this just anywhere, obviously.
23:36:10 <crutcher> but when you want to map over IO actions, I didn't seem to find anything useful
23:36:23 <bos> it doesn't seem terribly useful, to be honest.
23:36:48 <crutcher> bos: if those actions are parsing files, I think you would notice.
23:37:42 <crutcher> or doing builds, or running a collection of external jobs
23:38:08 <crutcher> there are many situations where you'd like to be able to perform IO actions in parallel
23:38:17 <bos> perhaps, but they're fairly trivial combinators.
23:39:20 <crutcher> bos: most combinators are fairly trivial. The win is having multiple users of the same combinator, so you can say : oh, they're using X, I know how that works.
23:39:34 <crutcher> also, there's the trickyness with the strictness variants
23:40:06 <crutcher> I mean hell, most of Parsec is extremely trivial.
23:40:10 <bos> crutcher: my contention would be that if you're working in the IO monad, you'll often want code that is more complex than those combinators.
23:40:43 <bos> don't get me wrong, the code is fine.
23:42:19 <crutcher> bos: I can clearly see many situations where this wouldn't be useful. But I can also see lots where it would. Most places in a bash script where you have a "for f in ...; do ...; done" expression could probably be run in parallel, and I wanted a construct for doing something similar.
23:45:06 * ddarius suspects that instance (Functor f, Functor g) => Functor (f :. g) and instance (CoFunctor f, CoFunctor g) => Functor (f :. g) will not make the type checker happy...
23:46:22 <crutcher> bos:  thank you for looking
23:52:07 <mornfall> cabal-install:
23:52:18 <mornfall> [snip]
23:52:21 <mornfall> ("/usr/bin/pkg-config",["--cflags"])
23:52:39 <mornfall> And dies since pkg-config expects package name.
23:52:45 <mornfall> Ideas?
23:55:04 <mornfall> (Well, it's not cabal-install but Cabal the library that screws up, of course...)
23:57:55 <MechaBlue> Urg...  I'm beginning to see why people started moving away from darcs
23:59:32 <mornfall> Part of the darcs problem is missing or crappy haskell libs, unfortunately.
