00:00:00 <pumpkin> lol
00:00:06 * pumpkin looks embarrassed
00:00:09 <etate> (I read somewhere that they were "experimental" and not necessarily supported)
00:00:22 <dfjoerg> no idea
00:00:37 <mornfall> int80_h: Do you have a solution? :))
00:00:39 <etate> but they seem invaluable, esp wrt to vector / matrix mult style ops
00:00:45 <dfjoerg> Saizan: but shouldn't it collect the values of zeroes incrementally?
00:00:51 <int80_h> mornfall: coming up with it right now
00:01:27 <dfjoerg> in fact, does the program work with ghc?
00:02:41 <Saizan> in ghc zeroes will be compiled to a ciclic structure
00:02:59 <Saizan> consisting of only one cons cell that points to itself
00:04:04 <dfjoerg> makes sense, that is what I would have expected here as well
00:05:05 <pumpkin> dfjoerg: hugs is relatively out of date
00:05:09 <pumpkin> compared to ghc's activity
00:05:37 <Saizan> i guess he knows by now :)
00:06:00 <dfjoerg> pumpkin: I know; it is still far less messy to build
00:07:39 <emptnr_> does programming qualify as art
00:07:41 <emptnr_> or craft
00:07:49 <dfjoerg> emptnr_: it can be both
00:07:52 <mornfall> int80_h: (Then try something like take 20 $ splitWith (\x -> x < 10) [x `mod` 50 | x <- [1..]])
00:08:30 <mornfall> emptnr_: Craft would work more often than art. Unfortunately, in the mainstream, it probably qualifies more like dirty work.
00:08:41 <emptnr_> that sounds about right
00:08:44 <int80_h> mornfall: $ hasn't been introduced yet. I'm taking the language in chunks
00:09:00 <emptnr_> people like larry wall and uh, jimmy wales
00:09:05 <emptnr_> i would call them artists
00:14:47 <mornfall> int80_h: But the rest is OK? You can just say take 20 (...) instead.
00:14:47 <dfjoerg> it is like working with wood -- most people just use wood to light a fire, the rest can create marvelous things though
00:14:47 <emptnr_> in that they propose an idea and see the idea replicated, imitated, explored
00:14:47 <int80_h> mornfall: looks fine but I'm trying to write the thing at the moment
00:14:47 <mornfall> int80_h: $ is just a low-priority function application
00:14:47 <emptnr_> dfjoerg: i make totem poles ;)
00:14:47 <mornfall> int80_h: Aye. :)
00:14:47 <emptnr_> HFCP is a great tut
00:14:47 <mornfall> int80_h: I wish our students would show as much enthusiasm...
00:14:47 <dfjoerg> heh
00:14:47 <int80_h> mornfall: well, if I waited for my school to teach me what I want to know, I'd never learn it
00:14:47 <emptnr_> what's int80 doing?
00:14:47 <mornfall> We have an Introduction to FP in the first semester. Year by year, it's more of a catastrophy.
00:14:47 <int80_h> I would just learn how to be a java monkey, which is what they want
00:14:47 <dfjoerg> mornfall: no surprise
00:14:47 <mornfall> emptnr_: Learning from RWH.
00:14:47 <emptnr_> google "haskell for c programmers"
00:14:47 <emptnr_> screw dons ;)
00:14:48 <int80_h> I went to a commuinity college where one of the best teachers I have ever met (worte an advanced C book) decided he would no longer teach C. He said the caliber of student had just diminished too much.
00:14:48 <emptnr_> that's not bad, you know
00:14:48 <emptnr_> the good students migrate to more advanced languages ;)
00:14:48 <dfjoerg> emptnr_: I wouldn't say that
00:14:48 <emptnr_> then what are you doing in #haskell? ;)
00:14:48 <dfjoerg> emptnr_: the good students know that a language is a tool and should be choosen based on the task at hand
00:14:48 <int80_h> mornfall: I fantasize of bringing haskell to the CC around here the way Perl was brought in years ago. Maybe call it an honors track or something
00:14:48 <emptnr_> dfjoerg: well
00:14:48 <emptnr_> pick between this flathead screwdriver
00:14:48 <mornfall> Dunno.
00:14:48 <emptnr_> and a coin from this jar here...
00:14:48 <emptnr_> and they're all nickels
00:14:48 <int80_h> with the screwdriver I could rob someone and buy a decent CS book. I'll take the screwdriver.
00:14:48 <mornfall> The problem at hand is, the students we get don't understand *any* kind of programming.
00:14:51 <mornfall> Recursion? Oh dear.
00:15:05 <mornfall> We are trying to teach them how to prove correctness by induction.
00:15:13 <mornfall> I guess that's a lost cause.
00:15:14 <emptnr_> it's easier to explain through math then looping back through procedural programming and punchcards
00:15:33 <dfjoerg> emptnr_: C has its uses. I am a kernel programmer -- most other languages are simple not fit for the task
00:15:40 <int80_h> mornfall: I got by on my pattern recognition as far as recusion went. For a long time. Wasn't until I learned induction in maths that I "got it". And even now it's a leap of faith and cross my fingers type deal.
00:15:58 <emptnr_> C's best use is in the lowest-level situations, i don't contest that
00:16:16 <mornfall> dfjoerg: I still hold that kernels would be much better off with C++ kind of language.
00:16:18 <emptnr_> haskell is great when you're not extremely bound by
00:16:24 <dfjoerg> mornfall: C++ is a mess
00:16:26 <emptnr_> well...speed, mostly
00:16:40 <mornfall> dfjoerg: So is C. Pick the right subset.
00:16:51 <emptnr_> rather IO or something
00:16:55 <mornfall> dfjoerg: You get typechecker in C++. Unlike C, most of the time.
00:16:58 <dfjoerg> mornfall: you can't really enforce the subset, which makes it useless
00:17:08 <dfjoerg> you can get a lot of typechecking with proper use of C as well
00:17:22 <emptnr_> i always liked perl
00:17:28 <mornfall> dfjoerg: Dunno, never seemed to me. Even simple things like linked lists generally cast away any type info.
00:17:30 <emptnr_> somewhere between haskell and bash
00:17:31 <dfjoerg> Perl == Write Only Language
00:17:48 <nikki93> Perl == Cartoon character swearing.
00:17:51 <dfjoerg> mornfall: look at the way linked lists and the like are done in the BSD sys/queue.h
00:17:55 <emptnr_> hehe
00:18:07 <emptnr_> conciseness, right? don't haskell programmers like that
00:18:39 <mornfall> dfjoerg: Like this? http://fxr.watson.org/fxr/source/sys/queue.h?v=OPENBSD
00:18:53 <somnolence> how do I convert an Integer to a list of each digit?
00:19:10 <emptnr_> somnolence: show
00:19:11 <somnolence> to a list containing each digit.
00:19:13 <dfjoerg> mornfall: yes
00:19:18 <emptnr_> although at that point
00:19:21 <somnolence> emptnr_ : show?!??!
00:19:22 <emptnr_> it'll be a list of Char
00:19:29 <emptnr_> aka...a string
00:19:30 <mornfall> dfjoerg: It's indeed better than the Linux versions.
00:19:36 <somnolence> nty is there a better way?
00:19:38 <emptnr_> > show 32059283
00:19:39 <lambdabot>   "32059283"
00:19:40 <dfjoerg> emptnr_: bash, from the guys that brought us a different test than GNU coreutils?
00:19:41 <somnolence> an erlang function like split?
00:19:48 <somnolence> err
00:19:51 <somnolence> haskell sorry sleepy
00:19:59 <emptnr_> > map (\x->x:x) (show 34634634)
00:20:00 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
00:20:00 <lambdabot>        Expect...
00:20:06 <emptnr_> you're an infinite type
00:20:14 <mornfall> emptnr_: It is an infinite type.
00:20:31 <emptnr_> > map (\x->[x]) (show 34634634)
00:20:32 <lambdabot>   ["3","4","6","3","4","6","3","4"]
00:20:32 <mornfall> emptnr_: [[[...[[[a]]]...]]] : - )
00:20:47 <somnolence> thanks
00:21:02 <emptnr_> is there a better solution than that?
00:21:06 <int80_h> @hoogle odd
00:21:06 <lambdabot> Prelude odd :: Integral a => a -> Bool
00:21:06 <lambdabot> package hpodder
00:21:10 <emptnr_> well i suppose
00:21:16 <emptnr_> you could make a recursive function
00:21:31 <emptnr_> divide by ten, round down, multiply by ten and subtract that from the first result
00:21:35 <mornfall> dfjoerg: Still, you would be able to do a lot better with generic programming. Interestingly, it generally doesn't cost you anything on runtime.
00:21:36 <emptnr_> divide by ten, repeat
00:21:49 <somnolence> not doing that =P
00:21:50 <somnolence> map (\x->[x]) (show 34634634)
00:21:51 <somnolence> works fine
00:21:53 <emptnr_> aka, x-(x mod 10)
00:22:05 <mornfall> dfranke: And whenever I see a hand-written runtime dispatch in Linux, I wince.
00:22:07 <emptnr_> aka, (x-(x mod 10))/10
00:22:12 <emptnr_> etc
00:22:14 <mornfall> dfranke: Sorry, bad <tab>.
00:22:26 <emptnr_> and accumulate the result with :/++
00:22:28 <mornfall> Oh. He left.
00:22:29 <mornfall> Bummer.
00:22:32 <emptnr_> which, by the way
00:22:37 <emptnr_> looks like a guy in a flannel shirt
00:23:14 <emptnr_> i don't ever want to write that function
00:24:00 <somnolence> no I'm not doing that emptnr
00:24:00 <somnolence> never
00:24:01 <somnolence> lol
00:24:08 <somnolence> might have to later but I don't want to
00:24:14 <emptnr_> what do you have to do this for
00:24:33 <emptnr_> are you parsing each digit as an integer
00:24:57 <somnolence> emptnr_
00:25:00 <jeltsch> Hello, does anyone know what the fixity of -> is?
00:25:02 <somnolence> map (\x->[x]) (show n)
00:25:03 <somnolence> is fine
00:25:03 <somnolence> thanks
00:25:05 <somnolence> =P
00:25:06 <emptnr_> somnolence
00:25:23 <jeltsch> GHC allows me to define operators with fixity 0.
00:25:33 <jeltsch> Does -> also have fixity 0 or something like -1?
00:26:55 <etate> fixity?
00:28:14 <jeltsch> etate: http://haskell.org/onlinereport/decls.html#sect4.4.2
00:28:36 <etate> jeltsch: thanks
00:28:40 <Workybob> somnolence: you missed an oportunity to use the robotic monkey combinator
00:29:06 <pumpkin> etate: operator precedence and associativity
00:29:22 <nikki93> Does real world haskell mention about comments anywhere?
00:29:30 <jeltsch> To be more precise: I meant not fixity in general but precedence in particular.
00:29:36 <nikki93> (-- .*) and ({- .* -})
00:29:51 <pumpkin> nikki93: what about them?
00:30:01 <ziman> jeltsch, when not used in types, -> is syntax, not an operator, afaik
00:30:04 <pumpkin> nikki93: as far as I can tell, RWH isn't meant to really be your first book about haskell
00:30:17 <pumpkin> nikki93: it's telling real-world ways of using it
00:30:21 <pumpkin> as the title implies
00:30:27 <pumpkin> it might assume you know about comments
00:30:41 <ziman> use only in lambdas and case expressions; i might be forgetting something though...
00:30:45 <ziman> *used
00:30:54 <etate> does haskell have something akin to lisp macros, or ocamls quotations?
00:31:08 <pumpkin> etate: template haskell
00:31:12 <dfranke> etate: sort of.
00:31:30 <somnolence> Workybob: that's too bad hey how do I extract both values from a touple?
00:31:35 <dfranke> etate: there's template haskell, or if you're feeling really brave, GHC-as-a-library.
00:31:56 <Workybob> somnolence: you pattern match on it
00:32:04 <pumpkin> TH allows you to generate arbitrary haskell AST in haskell
00:32:05 <Workybob> let (x,y) = someTuple in f x y
00:32:34 <etate> dfranke: template haskell answers my curiosity very adequately, thank you & pumpkin
00:33:01 <mornfall> Ouch?
00:33:06 <Workybob> K-lined?
00:33:09 <jeltsch> ziman: I meant -> in types, of course. (I have nine years experience in Haskell, by the way. ;-) )
00:33:16 <pumpkin> that's odd
00:33:26 <somnolence> thanks Worky
00:33:35 <pumpkin> oh, they k-lined all of mibbit it looks like
00:33:36 <jeltsch> And I should have told myself: "RTFM".
00:33:59 <jeltsch> http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#infix-tycons has the answer.
00:34:15 <jeltsch> "Function arrow is infixr with fixity 0.  (This might change; I'm not sure what it should be.)"
00:34:28 <ziman> jeltsch, i see. ;)
00:34:41 <emptnr_> why did like 15 people just get k-lined
00:34:51 <emptnr_> did i miss something good
00:34:51 <pumpkin> emptnr_: they banned mibbit
00:34:57 <emptnr_> garbage
00:35:00 <jeffz``> pumpkin: yay.
00:35:04 <emptnr_> freenode seems to hate anonymity
00:35:11 <jeltsch> Hmm, so it doesn’t seem to be wise to give precedence 0 to an own type operator.
00:35:15 <jeffz``> emptnr_: mibbit is non-free software, probably not in the spirit of the network
00:35:17 <pumpkin> emptnr_: because it gets abused a lot
00:35:23 <emptnr_> "abused"
00:35:24 <pumpkin> tor is a tough on
00:35:24 <pumpkin> e
00:35:42 <pumpkin> emptnr_: we had a big issue with random people joining advertising #ubuntu-tr the other day
00:35:50 <emptnr_> i was there, remember?
00:35:54 <pumpkin> fair enough
00:36:07 <emptnr_> that was funny when it happened ;)
00:36:35 <pumpkin> can someone explain how the strategies I pass to parMap work?
00:38:19 <emptnr_> i cannot explain that
00:38:26 <emptnr_> but i can explain why anarchy is the best form of non-government
00:40:08 <emptnr_> goodnight
00:42:18 <Saizan> pumpkin: in which sense?
00:42:25 <pumpkin> I think I sort of get it now
00:42:28 <pumpkin> just experimenting
00:50:07 <wolverian> I can't get http://www.haskell.org/haskellwiki/Literate_programming/Vim quite to work; after replacing a regex in a cluster definition, which vim7 doesn't seem to like, I still can't get it to highlight code blocks as haskell. any hints?
00:51:02 <wolverian> actually, the same happens with the lhaskell.vim file shipped with vim7
00:51:23 <wolverian> code between "\begin{code} ... \end{code}" is not syntax highlighted at all.
00:52:14 <pumpkin> Saizan: so parListChunk n means that each "thread" is given n elements to work on?
00:54:27 <Saizan> pumpkin: yup, each spark
00:55:04 <pumpkin> so say I knew I was going to call with +RTS -N4 and that the workload for each element of the list I'm parMapping over is approximately equal
00:55:17 <pumpkin> would it make sense then to take parListChunk (length xs `div` 4) ?
00:55:45 <pumpkin> I'd like to use all four cores as much as possible
00:56:45 <Saizan> if forcing the spine of the list doesn't evaluate the elements, yes
00:57:41 <pumpkin> well I'm doing it with rnf
00:57:47 <pumpkin> is that bad?
00:58:25 <Saizan> rnf as the strategy of parListChunk? that's not what i was talking about
00:58:25 <pumpkin> I figured that if I did r0 or rwhnf each spark wouldn't do much
00:58:40 <pumpkin> hmm
00:58:44 <Saizan> yeah, true
01:00:14 <Saizan> the point is that if evaluating the length already must do most of the work relative to the full evaluation of the list, then the sparks won't have much to do left
01:00:46 <pumpkin> oh, no
01:00:47 <nikki93> I'm finding YAHT a pretty cool book.
01:00:50 <Saizan> s/the/my/
01:00:57 <pumpkin> the list should already be evaluated
01:01:02 <pumpkin> the only work left is the computation on top of it
01:01:26 <Saizan> on top?
01:01:44 <pumpkin> well, mapping an expensive function to the list that's already evaluated
01:04:00 <pumpkin> hmm, interesting
01:04:06 <pumpkin> getting around ~170% utilization
01:04:09 <pumpkin> I'd expect more
01:04:29 <pumpkin> I must be doing something wrong :)
01:21:12 <Axman6m> whoot, just taught my girlfriend Monoids (just)
01:21:39 <dfranke> but Just isn't a Monoid :-)
01:21:49 <Axman6m> -_-
01:23:29 <Axman6m> @instances Monoid
01:23:30 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
01:24:04 <Axman6m> dfranke: Maybe is though :)
01:24:17 <jacobian2> In hugs, If you have a file with a module in it, and you load it,  then how do you load another file that requires that module?
01:24:17 <blathijs> Is there some way to get at the nth element of a list? I thought this was the ! operator, but it seems to be defined for arrays in the Array module only...
01:24:29 <Axman6m> !!
01:24:41 <Axman6m> [0..] !! 1000
01:24:46 <Axman6m> > [0..] !! 1000
01:24:48 <lambdabot>   1000
01:25:47 <blathijs> Ah, right. Thanks!
01:26:05 <jacobian2> I get "Error file.hs - Can't find imported module X"
01:26:25 <jacobian2> even thought the prompt that I'm at actually is the module X
01:27:29 <Saizan> jacobian2: maybe you have to set the include path?
01:29:14 <quicksilver> jacobian2: the prompt is not relevant AFAIK
01:29:38 <quicksilver> jacobian2: when you load a new file, it is a self-contained thing
01:29:49 <quicksilver> jacobian2: so file.hs and X.hs need to both be visible in the right places.
01:30:01 <quicksilver> jacobian2: I could give you more precise help with ghci since I don't really understand hugs :)
01:32:33 <Saizan> > 308 - 130
01:32:35 <lambdabot>   178
01:32:53 <trez> @src intersperse
01:32:54 <lambdabot> intersperse _   []     = []
01:32:54 <lambdabot> intersperse _   [x]    = [x]
01:32:54 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
01:33:01 <jacobian2> thanks quicksilver
01:34:41 <somnolence> how can you test if all the elements in a list are the same or all True
01:35:22 <sbahra> > and [True, False, False, True]
01:35:24 <lambdabot>   False
01:35:31 <sbahra> > and [True, True]
01:35:32 <lambdabot>   True
01:35:36 <zMarcWeber> somnolence: more generall: all (== True)
01:35:52 <zMarcWeber> > all (== True) [True, True]
01:35:53 <lambdabot>   True
01:36:01 <somnolence> thanks
01:36:27 <somnolence> so I would do
01:36:35 <somnolence> if all (== True) == list
01:36:36 <somnolence> in that case
01:36:37 <somnolence> right?
01:36:47 <sbahra> Huh?
01:37:00 <sbahra> What case, somnolence?
01:37:03 <Peaker> somnolence: all (==True) = and
01:37:44 <somnolence> Sorry
01:37:46 <somnolence> would
01:37:49 <ivanm> Peaker: how do you know it isn't (True==) ?
01:37:51 <ivanm> ;-)
01:37:56 <somnolence> if all (== True) == [True, True]
01:37:57 <somnolence> return true?
01:38:04 <somnolence> returns true?*
01:38:20 <zMarcWeber> > :t (== True)
01:38:21 <lambdabot>   <no location info>: parse error on input `:'
01:38:24 <somnolence> nvm lol >_<
01:38:24 <ivanm> > all (== True) [True, True]
01:38:25 <lambdabot>   True
01:38:28 <zMarcWeber> >:t (== True)
01:38:37 <ivanm> @type (== True)
01:38:38 <lambdabot> Bool -> Bool
01:38:39 <ivanm> zMarcWeber: ^^
01:38:44 <zMarcWeber> >:t (True ==)
01:38:52 <quicksilver> somnolence: no.
01:38:55 <ivanm> zMarcWeber: can't do that
01:38:57 <quicksilver> somnolence: you don't want to use == like that
01:39:04 <ivanm> zMarcWeber: use @type
01:39:11 <sbahra> :t (== True)
01:39:12 <lambdabot> Bool -> Bool
01:39:14 <quicksilver> " if all (== True) == [True, True]" is comparing "all (== True)" to "[True,True]"
01:39:15 <kaol> @type id::(Bool->Bool)
01:39:17 <lambdabot> Bool -> Bool
01:39:18 <quicksilver> somnolence: that's not what you mean.
01:39:26 <sbahra> :t id:: (Bool -> Bool)
01:39:27 <lambdabot> Bool -> Bool
01:39:33 <zMarcWeber> ivanm: Ah.. :-)
01:39:37 <quicksilver> somnolence: "all (== True)" is a function
01:39:45 <quicksilver> somnolence: you *apply* it to [True,True], which is a list
01:39:46 <zMarcWeber> :t all
01:39:47 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
01:39:53 <quicksilver> > all (== True) [True,True]
01:39:54 <lambdabot>   True
01:40:08 <zMarcWeber> > all ("foo" `isPrefixOf`) ["fooBar", "fooBanana"]
01:40:09 <lambdabot>   True
01:40:24 <somnolence> and [True, True]
01:40:31 <somnolence> it doesn't like me
01:40:32 <somnolence> ic
01:40:49 <somnolence> > and [True, True]
01:40:51 <lambdabot>   True
01:40:52 <somnolence> heh
01:41:18 <somnolence> > all (== True) == [True, True]
01:41:20 <lambdabot>   Couldn't match expected type `[Bool] -> Bool'
01:41:29 <somnolence> > (all (== True)) == [True, True]
01:41:30 <lambdabot>   Couldn't match expected type `[Bool] -> Bool'
01:41:32 <somnolence> i c
01:41:34 <somnolence> yeah thats sux
01:42:01 <somnolence> > and [True, True, False]
01:42:03 <lambdabot>   False
01:42:29 <pumpkin> > (all (== True)) [True, True]
01:42:30 <lambdabot>   True
01:42:35 <pumpkin> > (all id) [True, True]
01:42:36 <lambdabot>   True
01:43:06 <pumpkin> and obviously does the same thing too :P
01:44:01 <quicksilver> the nice thing about "all (==True)" is it is obvious how to use that with other things than booleans
01:44:05 <quicksilver> > all (==5) [1,2,3,4,5]
01:44:06 <lambdabot>   False
01:44:07 <quicksilver> and so on.
01:45:00 <somnolence> Does anyone see what's causing this code to have a stack overflow: http://rafb.net/p/herTRd56.html
01:45:00 <somnolence> ?
01:46:57 <quicksilver> somnolence: yes.
01:46:58 <quicksilver> test5 i+1
01:47:02 <quicksilver> maybe you meant
01:47:03 <quicksilver> test5 i+1
01:47:07 <quicksilver> test5 (i+1)
01:47:09 <quicksilver> ;)
01:47:14 <somnolence> lol
01:47:21 <quicksilver> test5 i+1 is "(test5 i) + 1"
01:47:25 <quicksilver> so that's infinite recursion
01:47:29 <somnolence> irony
01:47:30 <somnolence> the one time
01:47:40 <somnolence> I don't put parenthesis =P thanks
01:48:33 <doserj> an please delete the "== True" ...
01:50:34 <ivanm> doserj: don't you like redundant code? :p
01:52:24 <doserj> if isTrue (and (divisor i) == True) .... where isTrue x = x == True
01:54:57 <stingeraj> hello there
01:55:58 <stingeraj> I have a question about the break-command in combination with fst in haskell. can somebody please help me with this?
01:57:39 <stingeraj> I want to break a list of 2-tuples [(String,Value)] at the position fst=="$ObjectList". How do I do this?
01:58:29 <quicksilver> :t break ((=="$ObjectList).fst)
01:58:30 <lambdabot> lexical error in string/character literal at end of input
01:58:35 <quicksilver> :t break ((=="$ObjectList").fst)
01:58:36 <lambdabot> forall b. [([Char], b)] -> ([([Char], b)], [([Char], b)])
01:58:59 <stingeraj> if i try this: break (fst=="$ObjectList") store      then i get a type error.
01:59:04 <stingeraj> quicksilver is this the solution?
01:59:07 <quicksilver> stingeraj: yes.
01:59:13 <stingeraj> cool, thx!
01:59:14 <quicksilver> fst is a function.
01:59:19 <quicksilver> you can't compare fst to a string.
01:59:59 <stingeraj> quicksilver and ((=="$ObjectList).fst) ist a function composition?
02:00:09 <Stinger> hmm hpaste down ey
02:00:20 <Stinger> @paste
02:00:20 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:01:09 <quicksilver> stingeraj: right.
02:01:12 <Stinger> any other pastebins recommended for haskell?
02:01:12 <quicksilver> :t fst
02:01:13 <lambdabot> forall a b. (a, b) -> a
02:01:21 <quicksilver> :t (=="$ObjectList")
02:01:22 <lambdabot> [Char] -> Bool
02:01:25 <quicksilver> :t (=="$ObjectList") . fst
02:01:26 <lambdabot> forall b. ([Char], b) -> Bool
02:01:30 <andun> Stinger: codepad.org
02:01:52 <quicksilver> stingeraj: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/new
02:02:23 <mofmog1> that's interesting, irc works but nothing else
02:02:48 <stingeraj> ok thx, quicksilver!
02:03:20 <mofmog1> how is it that irc can work when nothing else works
02:03:33 <Stinger> http://codepad.org/FR8TLA60 this should be tail recursive right?
02:04:01 <quicksilver> yes.
02:04:21 <quicksilver> it will probably still stack overflow
02:04:26 <quicksilver> but maybe you don't care about that.
02:05:02 <Stinger> I'm just testing graph recursion
02:06:03 <Stinger> there's no way to embed my graph inside of its elements so I don't have to pass around two things when I refer to a single node is there
02:06:42 <quicksilver> sure.
02:06:49 <quicksilver> define a type which is a graph together with an element :P
02:07:00 <quicksilver> you can do anything by changing your types.
02:07:08 <quicksilver> its not necessarily a good idea though
02:07:14 <Stinger> yeah I can't guarantee that it wont explode in space though through traversal
02:10:26 <Workybob> ARGH!
02:10:36 <Workybob> why is it so hard to get a working system with gtk2hs on >.<
02:10:54 <quicksilver> because you're using a mac, perhaps? ;)
02:11:14 <Workybob> well, it doesn't compile on OS X (I think the version of gtk is too new, and the types of some functions have changed)
02:11:21 <Workybob> there's no package in ubuntu
02:11:27 <Workybob> arch doesn't install in the VM
02:11:40 <Workybob> so now I'm starting on gentoo, and that's gonna waste the entire bloody day
02:11:46 <Workybob> >.<
02:11:49 <Twey> yaourt -S gtk2hs
02:11:52 <Twey> = win
02:11:56 <Workybob> what system?
02:12:00 <Twey> Arch :-P
02:12:02 <Twey> No Ubuntu package at all?
02:12:03 <Workybob> >.<
02:12:06 <Workybob> Twey: nope
02:12:09 <Twey> I'd imagine there would be one
02:12:14 <Twey> Searched all the non-standard repos?
02:12:27 <Workybob> nope, and it's not listed on the gtk2hs website
02:12:42 <Twey> Build it?
02:12:45 <somnolence> how can I sum all the elements in a list?
02:12:53 <Workybob> somnolence: sum
02:12:53 <quicksilver> somnolence: "sum"
02:12:55 <Twey> somnolence: sum myList
02:12:57 <somnolence> :)
02:12:59 <Workybob> > sum [1,2,3,4,5,6,78]
02:13:00 <lambdabot>   99
02:13:02 <Workybob> @src sum
02:13:03 <lambdabot> sum = foldl (+) 0
02:13:03 <ivanm> Workybob: gtk2hs installs on gentoo! ;-)
02:13:08 <ivanm> but not with ghc-6.10 :(
02:13:13 <Workybob> ivanm: well, that's good news at least
02:13:22 <Workybob> so hopefully today's gentoo expadition won't be wasted
02:13:28 <Workybob> even if it'll take fricking ages to install ghc
02:13:31 <ivanm> (and we don't have the latest version, as there was an issue with getting documentation built and we never actually got around to it tbh)
02:13:33 <Twey> Workybob: https://launchpad.net/ubuntu/+source/gtk2hs/0.9.13-5ubuntu1
02:13:38 <ivanm> Workybob: 1) have you considered gentoo-prefix?
02:13:48 <Twey> There's definitely an Ubuntu package
02:14:00 <Workybob> Twey: what do I do with that?
02:14:08 <ivanm> 2) you can do USE=binary emerge ghc to use a gentoo-specific precompiled binary if you're not really concerned with efficiency, etc.
02:14:26 <ivanm> Workybob: but IIRC, at the very least there's a manual gtk2hs package
02:14:27 <Workybob> ivanm: oh, neat
02:14:31 <ivanm> or you can always build it by hand
02:14:44 <Twey> ... how weird
02:14:51 <Workybob> ivanm: that's what I'm trying to avoid, since it seems to be very gtk version dependant
02:14:53 <Twey> There's gtk2hs-doc in universe
02:15:02 <ivanm> Workybob: generally, USE=binary isn't that recommended, as it can be a source of bugs
02:15:07 <Twey> But not gtk2hs itself
02:15:13 <ivanm> Twey: lol
02:15:19 <Workybob> >.< that's genious Twey
02:15:45 <Twey> Oh no, I was looking at the wrong page
02:15:48 <Twey> *continues searching*
02:15:55 <ivanm> lol
02:16:05 <ivanm> Twey: you don't have a search tool for ubuntu? :o
02:16:47 <Workybob> Twey: that link you posted – what's meant to be done with the contents of the page?
02:16:49 <Twey> Have you asked #ubuntu?
02:16:58 <Twey> ivanm: Of course I don't
02:17:03 <Twey> What would I want with one of those?
02:17:05 <Workybob> noting that I only installed ubuntu because gtk2hs fails to compile on OS X
02:17:29 <Twey> Workybob: Er, which page was that?  *scrolls up*
02:17:38 <Twey> Oh, this one
02:17:42 <Workybob> Twey: https://launchpad.net/ubuntu/+source/gtk2hs/0.9.13-5ubuntu1 <-- this one
02:17:53 <Twey> I haven't the foggiest
02:17:58 <Workybob> :(
02:18:06 <Twey> I'm sure someone here must use Ubuntu
02:18:10 <Twey> Cale
02:18:12 <Twey> Cale uses Ubuntu
02:19:21 * Workybob ponders sending Axel Simon an email – I know he uses a mac
02:19:22 <Twey> Hmn, it's quite early in Canada.
02:19:32 <Workybob> dunno what OS he runs on it though
02:19:36 <Twey> Heh
02:19:48 <quicksilver> Workybob: that page (that twey posted) demonstrates that gtk2hs is in ubuntu
02:19:58 <Workybob> quicksilver: yes, but how do I get at it?
02:20:22 <quicksilver> make sure your apt is pointing to the right version of ubunut
02:20:24 <quicksilver> (jaunty)
02:20:33 <quicksilver> and that it includes the universe repo
02:21:04 <quicksilver> and then apt-get install libghc6-gtk-dev
02:21:04 * Workybob runs off to install ubuntu again
02:21:09 <quicksilver> (and any others you fancy)
02:23:59 <Workybob> ubuntu does win prizes for being the second linux I've ever succeeded in installing, and the first one without reading the documentation
02:24:19 <Twey> Eh, give me a good bit o' documentation any day
02:24:19 <Workybob> gentoo is the only other distro I've suceeded in getting to work, and only because their docs are fricking awesome
02:24:24 <Twey> They are
02:24:26 <Twey> Arch's are similar
02:24:52 <Twey> (possibly better now GentooWiki got wiped)
02:25:06 <Workybob> as far as I found, archs docs were pretty awful, right from the point at which they didn't tell you ever which iso to download
02:25:11 * quicksilver thinks that source-based package systems are not fit for purpose.
02:25:19 <quicksilver> (At least not the purpose I have in mind for a package system)
02:25:24 <Workybob> quicksilver: I mostly agree with you there
02:25:29 <quicksilver> but, I will not rant about that here.
02:25:32 <Workybob> it's a shame that fink is not getting as much love as it should do
02:25:36 <Workybob> because MacPorts is fail
02:25:39 <Twey> Heh
02:25:54 <quicksilver> it's a shame apple didn't just incorporate dpkg into OSX
02:25:59 <quicksilver> as they once planned to do.
02:25:59 <paulvisschers> I'm trying to use haddock right now on one of my libraries, but I get an error that it can't find the link locations to a bunch of libraries I'm using
02:26:00 <quicksilver> Apple fail.
02:26:08 <pumpkin> phapple
02:26:08 <Workybob> quicksilver: yeh, that too
02:26:09 <Twey> Huh... there's a sticker on this tankard
02:26:19 <paulvisschers> Is there a simple way to link those to hoogle's files or something?
02:26:22 <Twey> I've had it for years, and never noticed that to take it off *shakes head*
02:26:24 <quicksilver> Twey: that sounds like a line from a text adventure game.
02:26:25 <pumpkin> luckily the iphone has it
02:26:31 <Twey> Haha, quicksilver
02:26:34 <pumpkin> (dpkg that is)
02:26:58 <quicksilver> pumpkin: it does? cute.
02:27:05 <pumpkin> yup :)
02:27:17 <paulvisschers> anyone?
02:27:25 * Twey sadly checks the OpenMoko page again.
02:27:29 <Saizan> paulvisschers: you are referring to the warning, right?
02:27:56 <paulvisschers> ok right it's only a warning :)
02:28:19 <paulvisschers> Saizan: Yes I was referring to the warning
02:28:23 <Saizan> paulvisschers: you've to build and install the haddock documentation for those libraries too
02:28:43 <quicksilver> pumpkin: only if you install cydia, according to my smart apple friends
02:28:52 <pumpkin> quicksilver: well, of course :P
02:29:00 <Saizan> paulvisschers: you can set documentation: True in your ~/.cabal/config file if you want haddock docs to be built by default
02:29:01 <pumpkin> apple doesn't even give you a command line :P
02:29:04 <quicksilver> pumpkin: ok, well the OSX uses dpkg in that sense.
02:29:16 <quicksilver> pumpkin: and so does every other operating system I know.
02:29:21 <pumpkin> quicksilver: well, it's the primary way of getting stuff on the jailbroken iphone
02:29:24 <quicksilver> since dpkg ports of one kind or another exist to everything.
02:29:30 <Saizan> paulvisschers: assuming you're using cabal-install
02:29:33 <pumpkin> everything is distributed through it
02:29:36 <paulvisschers> Saizan: Ok thanks
02:29:39 <pumpkin> including the 3g unlock etc.
02:30:03 * Workybob doesn't really see the point of jailbraking an iPhone these days
02:30:29 <pumpkin> Workybob: cycorder, backgrounder, data tethering, unlocks
02:30:38 <pumpkin> theming, if you're into that kind of stuff
02:30:43 <paulvisschers> Saizan: It's pretty cool to see documentation for your own library :)
02:31:09 <SKuhn1> is there a map which gives precessors and successors additional to the list element?
02:31:18 <Workybob> pumpkin: yeh, cycorder would be nice to have as an app store app (or rather built in)
02:31:18 <pumpkin> SKuhn1: nope, but you could build one
02:31:31 <Saizan> paulvisschers: heh, yeah :)
02:31:32 <Workybob> other than that, the tethering and unlocks are non-issues if you buy in belgium
02:31:34 <pumpkin> Workybob: I know the guy who made it, and he tried to submit it to the app store when it first opened
02:31:40 <Workybob> pumpkin: oh/
02:31:42 <pumpkin> they just rejected it
02:31:49 <Workybob> he should try again
02:31:51 <pumpkin> because it uses undocumented APIs
02:31:54 <Workybob> oh, I see
02:32:02 <pumpkin> because they don't provide any low-level APIs ot the camera or the encoding hardware
02:32:07 <pumpkin> so it's a bit of a catch 22
02:32:13 <Workybob> yep
02:32:14 <pumpkin> I don't see why they don't just do it themselves though
02:32:40 <pumpkin> Workybob: but for many people not in belgium, tethering and unlocks are handy :) being able to send apps to background is also nice
02:32:42 <Workybob> and I guess their view on recording with it is that the framerate is too low, and they don't do stuff that low quality :/
02:32:55 <Workybob> pumpkin: they're perfectly capable of ordering from belgium :)
02:32:57 <pumpkin> yeah, but it's their fault for putting a shitty cam in there, it's the best
02:33:03 <Workybob> true true
02:33:13 <pumpkin> Workybob: you seen how much legit unlocked phones cost on ebay??
02:33:21 <pumpkin> :P
02:33:26 <Workybob> pumpkin: less than a contract costs ;)
02:33:39 <Workybob> it's €525 IIRC to buy one new
02:33:42 <pumpkin> well, many people still have to pay the rest of the contract
02:33:54 <pumpkin> anyway, I have an interest in promoting the jailbreak :P
02:34:00 <Workybob> hehe
02:34:03 * pumpkin gets defensive etc.
02:34:09 <SKuhn1> hmm, if you have a tic tac toe board, like that: type Board = [Row];type Row = [Field];data Field = B | X | O and you need a function which returns all possible moves a a player (moves           :: Field -> Board -> [Board]) ... what would be an elegant solution? (mine is really ugly)
02:34:58 <pumpkin> Workybob: also, the possibility of full bluetooth support is another advantage </spiel>
02:34:59 <somnolence> How do I select an element from a list given it's index?
02:35:03 <pumpkin> although none of us has had time to look at it
02:35:17 <Workybob> somnolence: !! -- but you're probably using the wrong type if you want to use it
02:35:36 <Saizan> > [1..5] !! 4
02:35:38 <lambdabot>   5
02:35:38 <pumpkin> if you're going to do it once or twice on a smallish list, it's fine
02:35:41 <somnolence> thanks
02:35:47 <somnolence> no
02:35:55 <somnolence> I'm going to select
02:35:55 <pumpkin> somnolence: ?
02:36:00 <somnolence> the 10001 index
02:36:06 <somnolence> ist hat fine?
02:36:08 <somnolence> ish?
02:36:08 <somnolence> lol
02:36:14 <pumpkin> you're doing it once, I assume
02:36:15 <sbahra> > [1 .. 5] !! undefined
02:36:16 <Workybob> somnolence: it's O(n) in the index you select
02:36:16 <lambdabot>   * Exception: Prelude.undefined
02:36:17 <somnolence> ye
02:36:19 <pumpkin> if so, it should be fine
02:36:24 <pumpkin> sbahra: you're up late/early
02:36:25 <Workybob> so you decide
02:36:32 <sbahra> On my GHC, result is: Prelude> Segmentation fault: 11 (core dumped)
02:36:38 <sbahra> pumpkin, yes, woke up ~4:30AM EST.
02:36:41 <pumpkin> sbahra: whoa
02:36:45 <pumpkin> sbahra: I'm still up :(
02:36:48 <sbahra> And now I can't fall back to sleep. :(
02:36:50 <pumpkin> I hate ghc segfaults
02:36:59 <sbahra> pumpkin, inauguration was exhausting.
02:37:08 <sbahra> pumpkin, so I was able to pass out ~9PM.
02:37:14 <pumpkin> ah
02:37:15 <somnolence> how do I get an item
02:37:20 <somnolence> from an infinite list
02:37:22 <pumpkin> somnolence: ?
02:37:28 <pumpkin> somnolence: same way you get one from a finite one
02:37:30 <sbahra> somnolence, [1 ..] !! 1000
02:37:33 <somnolence> lets say I have the sieve of erasthemus and I want the 10000 item
02:37:35 <pumpkin> somnolence: unless you want the inifty + 1th item
02:37:37 <somnolence> hmm rlly?
02:37:37 <sbahra> > [1 ..] !! 1000
02:37:38 <lambdabot>   1001
02:37:42 <sbahra> > [1 ..]
02:37:43 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
02:37:44 <somnolence> odd
02:37:58 <sbahra> somnolence, why?
02:39:12 <SKuhn1> someone has a not so crappy solution for moves? http://pastebin.com/m2cc89ff5
02:39:56 <pumpkin> I hate fucked up terminals
02:40:06 <somnolence> > let sieve (p : xs) = p : sieve [x | x <− xs, x `mod` p > 0]
02:40:07 <lambdabot>   <no location info>: parse error on input `;'
02:40:22 <somnolence> >_<
02:41:15 <somnolence> pumpkin : am I missing something? that haskell statement is straight from the wikipedia entry
02:41:16 <Workybob> SKuhn1: moves board = filter (isValid board) allMoves; allMoves = [(x,y) | x <- [0..2], y <- [0..2]]; isValid b (x,y) = b !! x !! y == B
02:41:21 <Workybob> SKuhn1: does that work for you?
02:41:23 <hugo___> hi
02:41:34 <pumpkin> yes
02:41:41 <pumpkin> > let sieve (p : xs) = p : sieve [x | x <− xs, x `mod` p > 0] in sieve
02:41:42 <lambdabot>   Not in scope: `<−'
02:41:53 <pumpkin> > let sieve (p : xs) = p : sieve [x | x <− xs, x `mod` p > 0] in sieve [1..]
02:41:54 <lambdabot>   Not in scope: `<−'
02:42:05 <somnolence> that's what I'm getting in my compiler as well -.-
02:42:10 <pumpkin> @let sieve (p : xs) = p : sieve [x | x <− xs, x `mod` p > 0]
02:42:11 <lambdabot>  <local>:6:34: Not in scope: `<'
02:42:18 <Saizan> pumpkin: the dash is wrong
02:42:19 <hugo___> if i want to define an instance of show for a datatype D, i only need to specify the show function that gets an A and returns a String, right ?
02:42:21 <pumpkin> bah
02:42:23 <pumpkin> ridiculous
02:42:29 <somnolence> lol
02:42:31 <pumpkin> > let sieve (p : xs) = p : sieve [x | x <- xs, x `mod` p > 0] in sieve [1..]
02:42:41 <pumpkin> lol
02:42:42 <pumpkin> nice
02:42:46 <lambdabot>   thread killed
02:42:48 <somnolence> nice one there pumpkin
02:42:50 <somnolence> that bot
02:42:51 <SKuhn1> Workybob:     Couldn't match expected type `[[Field]]'   against inferred type `Field'
02:42:51 <somnolence> is pro
02:43:04 <pumpkin> > let sieve (p : xs) = p : sieve [x | x <- xs, x `mod` p > 0] in sieve [1..10]
02:43:06 <lambdabot>   [1* Exception: /tmp/2661952085397061924:71:52-106: Non-exhaustive patterns ...
02:43:13 <pumpkin> somnolence: your code sucks
02:43:16 <Workybob> SKuhn1: mine didn't have the same type as yours
02:43:25 <Workybob> quite
02:43:25 <somnolence> pumpkin: not my code :: found on wikipedia lol
02:43:34 <pumpkin> yeah yeah that's what they all say
02:43:35 <somnolence> http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes
02:43:37 <somnolence> !
02:43:43 <somnolence> I have evidence though.
02:44:00 <SKuhn1> Workybob: that's the complete program http://pastebin.com/m7b2b2322
02:44:00 <pumpkin> nope
02:44:01 <somnolence> I wrote isPrime functions and the like but I'd rather just use the sieve and do it proper like...
02:44:05 <somnolence> nope?
02:44:06 <pumpkin> wikipedia is not evidence because you might've changed it
02:44:12 <somnolence> well
02:44:19 <pumpkin> I don't know which IP/username you are!
02:44:20 <somnolence> no
02:44:21 <somnolence> ti is
02:44:21 <SKuhn1> Workybob: have to think a bit longer about what you gave me
02:44:23 <somnolence> !
02:44:26 <somnolence> freenode hostmast
02:44:30 <somnolence> hostmask + check edits
02:44:30 <somnolence> go
02:44:36 <pumpkin> somnolence: that's not proof
02:44:40 <pumpkin> you might have infinite IPs at your disposal
02:44:41 <pumpkin> ;)
02:44:46 <pumpkin> and usernames
02:44:48 <somnolence> pumpkin: damn you fix the code
02:44:49 <pumpkin> who knows!
02:44:50 * pumpkin shrugs
02:45:07 <Saizan> SKuhn1: why do you use accumulators like that?
02:45:19 <somnolence> someone should fix the wikipedia entry if that sieve doesn't work -.-
02:45:54 <pumpkin> wikipedia's open source
02:45:58 <pumpkin> that someone should be YOU!
02:46:01 * pumpkin laughs evilly
02:46:07 * pumpkin has been up for way too long
02:46:19 <SKuhn1> Saizan: like what?
02:46:45 <somnolence> pumpkin : like I know how to fix it it's my 2nd day of haskell
02:47:05 <pumpkin> my second day of haskell I was teaching SPJ about GHC!
02:47:13 <somnolence> A piece of programing art in a PURELY functional language?
02:47:23 <mstr> > last [1..]
02:47:35 <sbahra> pumpkin, I've a presentation to the CS student body about Haskell :-p
02:47:35 <pumpkin> > 1/0
02:47:38 <ivanm> pumpkin: for some reason, I have trouble believing you...
02:47:50 <pumpkin> sbahra: nice :) show them how awesome it is!
02:47:53 <lambdabot>   thread killed
02:47:54 <sbahra> I think my presentation is pretty boring so far. ;-p
02:47:55 <pumpkin> ivanm: orly? :(
02:47:58 <lambdabot>   Infinity
02:48:03 <daf> on my second day of Haskell, my true love gave to me... eratosthenes
02:48:04 <pumpkin> sbahra: you gotta be bouncy like spj
02:48:24 <somnolence> what happens if you try to do local IO with the bot?
02:48:30 <pumpkin> somnolence: try it
02:48:36 <somnolence> pumpkin: no idea how
02:48:36 <ivanm> pumpkin: unless you were teaching him how to download and install it, which he wouldn't know because he always runs it from HEAD...
02:48:46 <Workybob> sbahra: pumpkin's not wrong – bouncy presenters really do help get the message across
02:48:52 <daf> > readFile "/etc/passwd"
02:48:53 <pumpkin> ivanm: :( you don't believe me
02:48:54 <lambdabot>   * Exception: "<IO [Char]>"
02:49:13 <somnolence> > readFile "~/.bashrc"
02:49:15 <lambdabot>   * Exception: "<IO [Char]>"
02:49:17 <somnolence> lol
02:49:28 <pumpkin> somnolence: it categorically disallows any kind of obvious IO
02:49:35 <somnolence> I c
02:49:35 <sbahra> Workybob, pumpkin: Sure. :-) I agree.
02:49:38 <pumpkin> and does its best to avoid anything that unsafePerformsIO
02:49:44 <daf> > exitFailure
02:49:46 <lambdabot>   Not in scope: `exitFailure'
02:49:56 <pumpkin> @hoogle exitFailure
02:49:56 <lambdabot> System.Exit exitFailure :: IO a
02:49:56 <lambdabot> System.Exit ExitFailure :: Int -> ExitCode
02:50:07 <sbahra> Workybob, pumpkin: The issue is being able to convey the beauty of Haskell to both scientists and engineers.
02:50:10 <mmorrow> hehe, lunabot has a function `randE' :: () -> Doc that generates a random haskell expression via QuickCheck (code snaked from HERA)
02:50:13 <mmorrow> , randE()
02:50:15 <lunabot>  x27 [] (\ x23 (- 26) _ -> x23) (17 x21 () ((- 25) 13 x3)) x1
02:50:16 <mmorrow> , randE()
02:50:18 <lunabot>  ()
02:50:20 <mmorrow> , randE()
02:50:22 <lunabot>  (x4 :: x1) ["This " "Thi"]
02:50:22 <pumpkin> wow, at least mmorrow's still up too
02:50:30 * mmorrow is working
02:50:44 <pumpkin> mmorrow: random expression? :o
02:50:45 <mmorrow> meth labs are hard work you know
02:50:51 <mmorrow> i mean..
02:50:51 <sbahra> I could imagine.
02:50:53 <pumpkin> , randE()
02:50:55 <ivanm> pumpkin: seeing as how SPJ is chief architect or whatever his title is of GHC...
02:50:55 <lunabot>  x6 (x5 x8, x6 x7) :: (,,,)
02:51:02 <Workybob> sbahra: what I would do is start by saying "I'm gonna show you a really cool real world application of Haskell, then I'm gonna let the engineers leave, and show anyone interested some things about the mathematical beauty of the language"
02:51:07 <pumpkin> ivanm: fine, you win! I was lying!!
02:51:07 <sbahra> ivanm, I think pumpkin was being sarcastic :-P
02:51:19 <mmorrow> , randE()
02:51:21 <lunabot>  ()
02:51:41 <sbahra> Workybob, yes, I should've requested more time. 1 hour does make that a bit difficult.
02:51:42 <mmorrow> half of them aren't even type-correct (the Arbitrary instances were for a parser)
02:51:47 <pumpkin> mmorrow: how do you get a uniform distribution across all expressios?
02:51:50 <pumpkin> expressions
02:51:53 <pumpkin> of course not uniform
02:51:57 <pumpkin> but a meaningful one
02:52:02 <mmorrow> pumpkin: i stole the code from HERA
02:52:07 <mmorrow> it looks pretty hairy :)
02:52:11 <mmorrow> i'll paste it
02:52:12 <pumpkin> , randE()
02:52:14 <lunabot>  (\ x9 -> x8, x12 :: x4, if x2 then x9 else x12, x12, x10, [], x7 x0, x4 x9)
02:52:19 <pumpkin> , randE ()
02:52:22 <lunabot>  (x8) (if 17 then "This is" :: x10 (->) (forall x13 . (->)) else [])
02:52:25 <pumpkin> lol
02:52:27 <pumpkin> wonderful
02:52:29 <mmorrow> (and i'm constraining the size of the exp with `gsize')
02:52:35 <pumpkin> why the unit?
02:52:36 <mmorrow> , [$ty| gsize |]
02:52:38 <lunabot>  forall a . Data a => a -> Int
02:52:50 <pumpkin> , gsize ()
02:52:51 <lunabot>  1
02:52:53 <pumpkin> , gsize 4
02:52:54 <lunabot>  1
02:52:58 <pumpkin> , gsize 4.25
02:53:00 <lunabot>  1
02:53:00 <mmorrow> the unit is when it fails after a given number of attempts to generate one that my prettyprinter can parse even
02:53:06 <sbahra> Workybob, do you know of exceptionally cool "real world" applications that are also compact?
02:53:08 <pumpkin> lol
02:53:20 <mmorrow> (it's using unsafePerformIO for the IO, hence the `()' arg)
02:53:27 <mmorrow> IO for the random
02:53:34 <pumpkin> :o
02:53:41 * sbahra writes one
02:53:50 <sbahra> Haskell ircd?
02:53:52 <sbahra> ;-p
02:53:52 <Saizan> SKuhn1: here's how i'd write it: http://pastebin.com/m7383af39
02:54:44 <hugo___> can i do something like "instance Show [D] where ..." for a given datatype D ? will it work ?
02:55:07 <Workybob> sbahra: perhaps something like writing a lambdabot plugin, and then move on to what the internals of such a bot might look like if you have time
02:55:46 <somnolence> how can I find the length of a list?
02:55:53 <pumpkin> somnolence: guess
02:56:00 <somnolence> len?
02:56:05 <pumpkin> > guess [1..5]
02:56:05 <hugo___> :P
02:56:07 <lambdabot>   5
02:56:07 <somnolence> >len [1, 2]
02:56:07 <pumpkin> ;)
02:56:08 <somnolence> llol
02:56:09 <somnolence> oolol
02:56:15 <pumpkin> yeah, it's length
02:56:15 <ivanm> sbahra: no, really? :p
02:56:18 <hugo___> lenght [1..10] :P
02:56:43 <Saizan> > length [1..10]
02:56:45 <lambdabot>   10
02:56:51 <sbahra> ivanm, ;-p
02:56:53 <hugo___> yeh that :P
02:57:09 <hugo___> what about show for list of datatypes ?
02:57:31 <ivanm> @src [] show
02:57:31 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
02:57:31 <quicksilver> hugo___: No.
02:57:35 <vixey> mmorrow, pretty wild (Archon), nice to have a proper name for that style of encoding too -- interesting the way they present values (that can have stuck "neutral" applications left over) in the paper is actually exactly how e.g. simply easy does
02:57:46 <quicksilver> hugo___: there is already a predefined instance for Show [a] , which applies to all types a.
02:57:57 <hugo___> quicksilver: how do i overwrite it ?
02:58:05 <quicksilver> hugo___: You don't. That's a bad idea.
02:58:12 <quicksilver> however, showList exists for this purpose.
02:58:21 <quicksilver> it should never be used though.
02:58:22 <hugo___> quicksilver: but i want it to print out something different for a list :(
02:58:22 <ivanm> quicksilver: well, only to types that are instances of Show...
02:58:30 <quicksilver> hugo___: no you don't.
02:58:33 <hugo___> yes i do
02:58:41 <ivanm> hugo___: use a custom function or wrap it in a newtype?
02:58:46 <quicksilver> hugo___: "show" should never print out something different.
02:58:53 <quicksilver> hugo___: if you want to print something different, that's not show.
02:58:56 <hugo___> hmm
02:58:56 <quicksilver> it's "pretty_print"
02:59:00 <hugo___> ahah
02:59:04 <quicksilver> or "my_cool_string_output_code"
02:59:06 <hugo___> yes
02:59:11 <vixey> mmorrow, (first time I saw the Mogensen-Scott encoding was in  self-applicable partial evaluator,  but I don't think they named it there)
02:59:15 <quicksilver> show is designed to print valid haskell syntax
02:59:18 <mmorrow> vixey: yeah, that paper is way cool
02:59:20 <hugo___> but i want pretty_print to work out for different data types
02:59:23 <quicksilver> > show [(1,2),(3,4)]
02:59:25 <lambdabot>   "[(1,2),(3,4)]"
02:59:29 <somnolence> > [1..5] !! 4
02:59:31 <lambdabot>   5
02:59:35 <quicksilver> hugo___: then design your own class PrettyPrint.
02:59:42 <quicksilver> (or call it what you like, obviously)
02:59:53 <hugo___> calling pretty_print_D, pretty_print_C, pretty_print_B, depending on whether its getting B, C, or D datatypes
03:00:07 <mmorrow> vixey: i haven't finished reading it through closely yet, but it's very high on my list
03:00:10 <quicksilver> I normally just have ppB, ppC and ppD, personally.
03:00:15 <hugo___> and i wouldn't like to have the overhead of defining another datatype that wraps those :/
03:00:16 <hugo___> yes
03:00:21 <quicksilver> but you certainly can define your own class if you choose to.
03:00:23 <hugo___> but i want to use only a single function for printing
03:00:26 <quicksilver> just don't abuse Show.
03:00:41 <mmorrow> vixey: i'm up to the point where he starts describing the details of his lang
03:00:47 <ivanm> hugo___: IIRC, it is possible to use ghc extensions to automatically make all non-assigned types use their show instance for a custom prettyprint typeclass
03:01:29 <mmorrow> here's lunabot's random haskell expression code: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=832
03:01:31 <hugo___> ok
03:01:31 <mmorrow> , randE()
03:01:32 <mmorrow> , randE()
03:01:33 <lunabot>  if x1 then [] else () ("This" :: (->))
03:01:34 <lunabot>  ()
03:01:37 <hugo___> ill think of something
03:01:40 <mmorrow> haha
03:01:43 <mmorrow> ("This" :: (->))
03:01:55 <mmorrow> @pl ("This" :: (->))
03:01:55 <quicksilver> mmorrow: that's amusing.
03:01:55 <lambdabot> (line 1, column 13):
03:01:55 <lambdabot> unexpected "-"
03:01:55 <lambdabot> expecting lambda abstraction or expression
03:02:04 <quicksilver> mmorrow: how come it had a free variable x1?
03:02:10 <vixey> , randE()
03:02:12 <lunabot>  ()
03:02:14 <vixey> , randE()
03:02:16 <lunabot>  ()
03:02:17 <vixey> , randE()
03:02:18 <mmorrow> quicksilver: very. i want to polish that ArbTH module a bit (i stole it from HERA)
03:02:19 <lunabot>  (let { x5 = x7} in "Th" :: [(->)]) x2 :: x8
03:02:32 <mmorrow> quicksilver: check out that paste to see how bootleg it really is :)
03:02:44 <mmorrow> QuickCheck FTW!~
03:03:52 <yitz> > if x1 then [] else () ("This" :: (->))
03:03:54 <lambdabot>   Not in scope: `x1'
03:04:04 <yitz> > \x1 -> if x1 then [] else () ("This" :: (->))
03:04:06 <lambdabot>       `(->)' is not applied to enough type arguments
03:04:06 <lambdabot>      Expected kind `?', ...
03:04:23 <vixey> , randE()
03:04:23 <Guest26031> N00b question, seems like one for the wiki: my add function returns an Int, I want to putStr/show/putStrNl the thing, but how do I typecast the Int to String?
03:04:25 <lunabot>  (x6 x0, x1) (x5 ("This " x2))
03:04:41 <yitz> Guest26031: show
03:04:42 <ivanm> Guest26031: show
03:04:44 <quicksilver> Guest26031: show
03:04:54 <quicksilver> triphonic sound!
03:04:56 <mmorrow> i imagine with a little work, those Arbitrary instances could be made to generate way more interesting stuff
03:04:58 <ivanm> come on, someone else has to tell him!
03:05:07 <ziman> Guest26031, show
03:05:13 <SKuhn1> Saizan: looks good
03:05:33 <ziman> Guest26031, `putStrLn . show' is also known as `print'
03:05:41 <yitz> ivanm: what ghc extension? why not H98 default method?
03:06:15 <quicksilver> yitz: ivanm was surely thinking of overlapping instances but I agree for this simple case a default method would be enough.
03:06:20 <ivanm> yitz: *shrug* I can't recall, I know that some people here helped me write such a typeclass (for me, I didn't want quotes around strings or chars), but then I decided not to use it
03:06:20 <mmorrow> vixey: whoa, that's weird that lunabot just didn't respond to two of those
03:06:26 <mmorrow> , randE()
03:06:26 <mmorrow> , randE()
03:06:27 <mmorrow> , randE()
03:06:28 <lunabot>  ()
03:06:29 <lunabot>  if \ [] (~x2) _ (~2) -> x8 then x8 else [] ((- 7) x3 :: x0)
03:06:29 <lunabot>  x0 (let { x11 x9 = x2} in x13 x2) "This is a s"
03:06:29 <ivanm> quicksilver: yeah, that's the one
03:06:32 <quicksilver> yitz: but you still have to write the instance (for a default method)
03:06:35 <mmorrow> odd
03:06:36 <vixey> This is a string lol
03:06:40 <quicksilver> yitz: you don't automatically get instances for everything.
03:06:48 <mmorrow> oh n/m, i'm blind
03:06:54 <mmorrow> vixey: yeah, lol
03:07:04 * ivanm gives mmorrow some glasses
03:07:08 <ivanm> can you see now? :p
03:08:10 <mmorrow> you shouldn't have given me sunglasses
03:08:14 <mmorrow> because it's night
03:08:23 <Guest26031> I have: let x = add 2 2, and then show x.  I want to put this in a main function.  It gives me " Couldn't match expected type `IO ()' against inferred type `String'"
03:08:25 * mmorrow cues the song
03:08:51 <quicksilver> Guest26031: show x just turns it into a string
03:08:52 <Guest26031> It seems I need main :: IO () for the .hs to compile, under GHC
03:08:58 <quicksilver> Guest26031: (wich is what we thought you were asking)
03:09:06 <quicksilver> Guest26031: to print it, you'd do putStrLn (show x)
03:10:08 <Guest26031> quicksilver: thanks.  This is one of those that seems like it should be on the wiki.
03:10:16 <somnolence> pumpkin: any guess as to why I would be getting a Not in scope error when I try to call guess?
03:10:21 <mmorrow> vixey: re: the various encodings: yeah, one thing i really liked about that paper was how it clarified/classified/explained various encodings
03:10:30 <mmorrow> s/liked/like/
03:10:31 <ivanm> mmorrow: which song?
03:10:40 <mmorrow> i wear my sunglasses at night!
03:11:02 * ivanm has never heard of it
03:11:06 <somnolence> > guess [1..5]
03:11:07 <mmorrow> heh
03:11:07 <lambdabot>   5
03:11:13 <ivanm> I was thinking more along the lines of "I can see clearly now..." ;-)
03:11:30 <somnolence> Hey can anyone *guess* why I get a not in scope error when I try to use guess?
03:11:37 <mmorrow> ivanm: :)
03:11:40 <somnolence> is it part of QuickCheck or something?
03:12:02 <Saizan> somnolence: "guess" was only pumpkin being funny, if i'm not mistaken
03:12:03 <mmorrow> @hoogle guess
03:12:03 <lambdabot> No results found
03:12:12 <somnolence> >_<
03:12:14 <mmorrow> @type guess
03:12:15 <lambdabot> forall a. [a] -> Int
03:12:18 <somnolence> length [1..5]
03:12:20 <pumpkin> Saizan: sorry, yes
03:12:21 <mmorrow> > guess [0..]
03:12:24 <somnolence> >length [1..5]
03:12:28 <somnolence> damnit mmorrow
03:12:28 <somnolence> -.-
03:12:33 <Saizan> > length [1..5]
03:12:36 <pumpkin> [05:56:14] <pumpkin> yeah, it's length
03:12:37 <lambdabot>   mueval: Prelude.read: no parse
03:12:40 <ivanm> Guest26031: I would say it isn't in the wiki because its covered in enough tutorials... >_>
03:12:41 <lambdabot>   5
03:12:49 <Saizan> somnolence: you need a space between the ">" and the code
03:12:57 <somnolence> > length [1..5]
03:12:59 <lambdabot>   5
03:13:00 <ivanm> pumpkin: is guess a synonym for the dwim function? ;-)
03:14:24 <Guest26031> quicksilver: Is there a Haskell equivalent to the if __name__=="__main__": you do at the bottom of a python script to make it execute when invoked directly, or just provide objects otherwise?
03:14:36 <ivanm> Guest26031: no objects ;-)
03:14:55 <Peaker> Guest26031: a module either is an importable module or its Main, it can't be both
03:14:55 <ivanm> and in Haskell, you typically separate your libraries from your programs
03:14:59 <Guest26031> ivanm: the idea seems un-Haskellian, if that word compiles.
03:15:12 <ivanm> Guest26031: what, not having objects?
03:15:19 <ivanm> how is that "un-Haskellian"?
03:15:26 <Peaker> Actually I think it would be useful if modules had mains and you could "run" modules and that would execute their quickCheck suite or so
03:15:31 <ivanm> Haskell is a FP, not an OOP ;-)
03:15:47 <Guest26031> ivan: no, having the .hs file do stuff on its own, or provide functions and such.
03:15:51 <Saizan> Guest26031: the standard says the entry point is Main.main
03:15:51 <ivanm> Peaker: just call it something else?
03:16:03 <Peaker> ivanm: yeah but its just a tiny unit-testing main
03:16:13 <Saizan> Guest26031: ghc has a -main-is flag to set your own
03:16:16 <Peaker> ivanm: I'd have to have a little main wrapper for dozens of modules right next to them
03:16:18 <ivanm> Guest26031: what's wrong with a .hs file being just a library file?
03:16:26 <ivanm> Peaker: hmmmm..... true
03:16:26 <Peaker> oh right I forgot about -main-is :)
03:16:28 <ivanm> maybe CPP?
03:16:38 <Peaker> ivanm: yeah you can just -main-is to run a module's main
03:16:58 <quicksilver> Guest26031: well the short answer is no.
03:17:09 <quicksilver> "main" as entry point is defined by the standard.
03:17:13 <ivanm> quicksilver: and the long answer is "Hell No!"? ;-)
03:17:18 <Guest26031> ivanm: I'm not saying it's wrong, just that, compared to python, haskell is raising "explicit is better than implicit" to a higher, functional level.
03:17:30 * ivanm likes explicit stuff
03:17:41 * pumpkin has some good web sites for ivanm
03:17:43 <ivanm> I always use type sigs, for example ;-)
03:17:47 <Saizan> ivanm, Guest26031: you are violently agreeing
03:17:49 <ivanm> @slap pumpkin
03:17:50 * lambdabot will count to five...
03:17:58 <ivanm> Saizan: heh
03:18:14 <ivanm> Guest26031: How dare you say I'm right?!?!?!? :@
03:18:14 <ivanm> ;-)
03:18:20 * Guest26031 finds that explicit adds a little to the learning curve, but "it feels better when it quits hurting" ;)
03:18:23 <somnolence> how can I convert
03:18:27 <somnolence> [Char] -> [Integer]
03:18:32 <Peaker> Guest26031: Haskell has a lot of implicitness too, "explicit is better than implicit" is a bit .. subject/empty of real content :)
03:18:37 <ivanm> somnolence: map read
03:18:46 <daf> map ord?
03:18:49 <Peaker> Guest26031: for example, implicit laziness
03:18:49 <ivanm> > map read ['1', '2', '3'] :: [Integer]
03:18:50 <lambdabot>   Couldn't match expected type `String' against inferred type `Char'
03:18:55 <ivanm> oh, duh
03:18:57 <daf> > map fromEnum "foo"
03:18:59 <Peaker> Guest26031: subjective, that was
03:18:59 <lambdabot>   [102,111,111]
03:19:03 <ivanm> > map (read . (:) []) ['1', '2', '3'] :: [Integer]
03:19:04 <lambdabot>   Couldn't match expected type `Char' against inferred type `[a]'
03:19:04 <znutar> is the opposing argument just "implicit is better"?
03:19:08 <somnolence> !
03:19:12 <Guest26031> Peaker: OK, the destructuring bind is a bit magical. ;)
03:19:17 <ivanm> grrrrr.......
03:19:19 <Saizan>  > map digitToInt ['1', '2', '3']
03:19:22 <Saizan> > map digitToInt ['1', '2', '3']
03:19:23 <lambdabot>   [1,2,3]
03:19:26 <ivanm> > map (read . flip (:) []) ['1', '2', '3'] :: [Integer]
03:19:27 <lambdabot>   [1,2,3]
03:19:32 <Peaker> znutar: of course implicit is not "better" in the general sense -- "explicitness" is not even well defined
03:19:36 <ivanm> Saizan: there's such a function? :o
03:19:38 <somnolence> thnx
03:19:40 <ivanm> @hoogle digitToInt
03:19:41 <lambdabot> Data.Char digitToInt :: Char -> Int
03:19:42 <daf> > digitToInt 'X'
03:19:48 <lambdabot>   * Exception: Char.digitToInt: not a digit 'X'
03:19:49 <ivanm> waddaya know
03:19:51 <Peaker> > digitToInt 'F'
03:19:53 <lambdabot>   15
03:19:57 <Peaker> > digitToInt 'G'
03:19:59 <ivanm> ahhhh, good old hex?
03:19:59 <lambdabot>   * Exception: Char.digitToInt: not a digit 'G'
03:20:06 <daf> heh
03:20:07 <Peaker> Why is it not "hexDigitToInt"?
03:20:18 <pumpkin> cuz itz dumb!
03:20:20 <ivanm> Peaker: because it still works for decimal, etc.?
03:20:32 <Albana> Enter text here...hiiii can anybody help me please?
03:20:44 <Peaker> ivanm: if you write a toDecimal with it - you'll be surprised at how it *doesn't* error on hex numbers, but instead gives wrong reuslts
03:20:50 <ivanm> hmmmmm..... why don't we ever see 32-decimal numbers? ;-)
03:20:51 <pumpkin> Albana: I've entered text here, now what?
03:20:54 <Twey> Enter text here...probably :-P
03:21:07 <Peaker> hehehe
03:21:13 <ivanm> Peaker: what do you mean by wrong results?
03:21:24 <yitz> > read ['2','4']
03:21:25 <lambdabot>   * Exception: Prelude.read: no parse
03:21:30 <Albana> uh so i've got this thing to do,i've got to implement the get time methodd in a java program but it keeps on making errors
03:21:39 <Peaker> ivanm: "a1" will be 101
03:21:40 <yitz> > read ['2','4'] :: Int
03:21:42 <lambdabot>   24
03:22:01 <Albana> it's a school project that i have to present today
03:22:02 <daf> Albana: this is the wrong place to ask Java questions
03:22:02 <Albana> :(
03:22:05 <ivanm> Peaker: *shrug* you have to use a fold to combine them after mapping, that's all
03:22:09 <Albana> where should i ask?
03:22:16 <pozic> I want to restrict the type of a value f to be at most as general as the third parameter of a function g. How can I do that?
03:22:17 <Saizan> Albana: #java
03:22:24 <daf> the clue is in the name
03:22:33 <pumpkin> Albana: java?
03:22:33 <Peaker> > let readDecimal xs = sum $ zipWith (*) (iterate (*10) 1) (reverse (map digitToInt xs)) in readDecimal "a1"
03:22:35 <lambdabot>   101
03:22:43 <Twey> Albana: And since it's making errors, you want to reimplement it in Haskell, right?  :)
03:22:44 <ivanm> hmmmmm..... this is the second person I recall coming here asking about general programming help...
03:22:56 <Peaker> ivanm: I guess catching pure exceptions sucks anyhow, so digitToInt really should return a Maybe
03:22:57 <pumpkin> Albana: you might want to try ##politics if you have a java question, might be more relevant than here
03:22:58 <daf> Albana: how did you find this channel?
03:23:01 <ivanm> it's all because we're the number 3 lang channel, right? ;-)
03:23:05 <yitz> ivanm: it wasn't general programming help. it was java.
03:23:12 <ivanm> pumpkin: lol
03:23:14 <Peaker> ivanm: not number 1?
03:23:20 <ivanm> yitz: s/general//
03:23:24 <Albana> i just typed chat for programmers that's all
03:23:31 <ivanm> Peaker: IIRC, python and php are larger
03:23:34 <Albana> but i cannot find the java room here :S
03:23:37 <pumpkin> Albana: type /join #java
03:23:38 <ivanm> dons did a blog post recently...
03:23:44 <Twey> Albana: You need to register, then join ##java
03:23:45 <ivanm> Albana: without the space
03:23:52 <Peaker> ivanm: oh, we passed #python only temporarily :)
03:23:59 <Albana> join #java
03:24:02 <ivanm> ahhh
03:24:13 <Albana> join#java
03:24:13 <pumpkin> Albana: you need the slash
03:24:14 <Albana> ??
03:24:14 <Peaker> ivanm: because we were bigger than #Python the other day
03:24:15 <Saizan> pozic: can you elaborate?
03:24:16 <Twey> It's ##java now
03:24:20 <Albana> ok
03:24:24 <Albana> join##java
03:24:25 <daf> because freenode
03:24:28 <Twey> Albana: /msg nickserv help register
03:24:30 <pumpkin> Albana: also, you need to register
03:24:32 <Twey> Follow the instructions
03:24:35 <Twey> Then /join ##java
03:24:41 <ivanm> Peaker: well, we're the 7th largest on freenode altogether...
03:24:43 <Albana> aha oook
03:24:49 <Albana> so where is the link to register?
03:24:55 <ivanm> according to the wiki, anyway
03:25:00 <somnolence> ivanm: I tried your suggestion but there's an odd type mismatch mind taking a look : http://rafb.net/paste/?
03:25:04 <pumpkin> Albana: in a private message to a bot on this network
03:25:13 <pumpkin> Albana: not on the web
03:25:14 <yottis> i'm afraid people on irc vs. popularity of the language are two very different things :)
03:25:20 <ivanm> somnolence: not much text in that link ;-)
03:25:26 <pumpkin> yottis: no bubble bursting, k?
03:25:30 <ivanm> and if you mean my suggestion about "map read"... I was wrong
03:25:45 <Albana> but where should i register then??
03:25:50 <somnolence> Lets look at it as I didn't supply enough information :O
03:25:52 <ivanm> use digitToInt as suggested by Saizan
03:25:54 <jeffz``> Albana: this isn't the right channel to ask about how to use irc
03:26:00 <ivanm> Albana: your IRC client should have told you
03:26:09 <Albana> uuuhhh!!!
03:26:12 <pumpkin> [06:24:29] <Twey> Albana: /msg nickserv help register
03:26:23 <Axman6m> Albana: google it. that's not something often said in here, but you need to do it
03:26:24 <ivanm> @go freenode register
03:26:25 <ivanm> Albana: ^^
03:26:26 <lambdabot> http://freenode.net/faq.shtml
03:26:26 <lambdabot> Title: 69a freenode: frequently-asked questions
03:26:32 <ivanm> Albana: ^^ that link, actually
03:26:39 <ivanm> lambdabot was slower than usual
03:27:01 <ivanm> Axman6m: are you copying pumpkin and turning yourself into a monad? :p
03:27:15 * pumpkin looks smug
03:27:33 <Albana> thankkksss!!^_^
03:27:35 <pumpkin> or rather liftM smug pumpkin
03:27:38 <ivanm> pumpkin: so you performed unsafePerformPumpkin on yourself, did you?
03:27:55 <pumpkin> nope, unsafePerformFellatio
03:27:56 <yitz> we seem to have reached a certain critical mass where our popularity increases without bound as people join only because of our popularity
03:27:58 <pumpkin> sorry :P
03:27:59 <ivanm> since you're sans your suffix
03:28:02 <ivanm> @slap pumpkin
03:28:02 * lambdabot would never hurt pumpkin!
03:28:13 <Axman6m> ivanm: trying to. my physical bind implementation is still rather paionful though
03:28:14 <ivanm> grrr...
03:28:19 <ivanm> Axman6m: heh
03:28:26 <ivanm> read much of RWH yet?
03:28:54 * ivanm wants a real-life darcs to apply the (hopefully) upcoming errata patches
03:29:21 <Guest26031> OK, I couldn't open an account on the Haskell wiki, but if somebody with more personality than me could copy the content of http://swik.net/User:smitty1e to the FAQ page, it might be a helpful addition.
03:29:36 <somnolence> euler.hs:120:25: Not in scope: `digitToInt'
03:29:36 <somnolence> ?
03:29:42 <Axman6m> quite a bit, i stopped for a while though. need to get back into it. i got bored by some of it :\
03:29:49 <ivanm> somnolence: import Data.Char
03:29:49 <pumpkin> somnolence: Data.Char
03:29:52 <somnolence> k
03:29:58 <ivanm> Guest26031: there's nothing there ;-)
03:30:11 <pumpkin> bbl :)
03:30:13 <Axman6m> @hoogle digitToInt
03:30:13 <lambdabot> Data.Char digitToInt :: Char -> Int
03:30:59 <Guest26031> ivanm: Gack.  Is there a better haskell paste site, then?
03:31:13 <yitz> @paste
03:31:14 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:31:15 <Axman6m> hpaste
03:32:09 <Guest26031> No joy on hpaste
03:32:09 <Twey> Haha, webdevs: http://dynamicdrive.com/forums/showpost.php?p=180455
03:32:23 <quicksilver> @where hpaste2
03:32:23 <lambdabot> http://moonpatio.com:8080/
03:32:26 <pozic> Saizan: I have a similar thing as yesterday: I have a value which is too generic, I know that the second argument of g has a type that is less generic than the currently derived type of f, so I want to use that restriction, without specifying the type again. Copying types everywhere is bad for maintenance.
03:32:30 <Albana> ##java
03:32:38 <Albana> #java
03:32:43 <pozic> Saizan: I did switch to the simple design already.
03:32:50 <ivanm> Albana: you want to do "/join ##java"
03:32:53 <ivanm> (without the quotes)
03:33:07 <Albana> join ##java
03:33:17 <Albana> uhuuuu this is reallly pissing me oofffff :@:@@:@:
03:33:24 * Twey headdesks repeatedly.
03:33:29 <ivanm> Albana: see the / at the start of the line?
03:33:31 <vixey> Albana, give up or something
03:33:33 <pozic> Saizan: ah, I got it.
03:33:41 <vixey> Albana, probably easier to juts learn haskell
03:33:46 * Twey laughs.
03:33:48 <Axman6m> heh
03:33:52 <ivanm> vixey: sounds like a java class
03:33:58 <Twey> That's OK
03:34:01 <Albana> i don;t even know what haskell is
03:34:03 <Albana> :S
03:34:10 <Axman6m> then why are you here?
03:34:13 <vixey> Albana, you're in #haskell so you might as well know
03:34:20 <pozic> Saizan: I just added a where clause where _ = g f -- where f is the function we are defining.
03:34:20 <daf> Axman6m: confusion
03:34:26 <ivanm> /join ##java
03:34:29 <Axman6m> apparently
03:34:32 <ivanm> Albana: ^^ use that line
03:34:33 <vixey> Albana, ... it's another programming language but it's very unlike java
03:34:36 <Guest26031> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=834#a834
03:34:36 <Albana> yes i see but what i wanted was java
03:34:39 <Twey> Once Albana is done learning Haskell, Albana can use Haskell to implement a Java runtime system, and then implement a Haskell compiler for the Java VM in it
03:34:44 <vixey> Albana, why?
03:35:17 <ivanm> Twey: I thought having FP on the JVM was non-trivial...
03:35:17 <Saizan> pozic: yeah, that works, asTypeOf is also useful
03:35:17 <Albana> it doesen't work
03:35:27 <vixey> Albana, you wanted java because it doesn't work?
03:35:29 <Albana> i wanted to join java cause i needed some help
03:35:39 <Guest26031> Twey: that recalls the Steven Wright joke about doing a self-portrait of an artist writing his autobiography.
03:35:41 <yitz> Twey: using the new Java VM, Albana can then write an IRC program that switches into ##java.
03:35:44 <Albana> in a java program :(
03:35:50 <daf> vixey: Albana has a Java assignment
03:35:51 <somnolence> digitToInt is creating a type mismatch and I can't do a statement like map (\x -> digitToInt 'x') list
03:35:53 * Twey grins.
03:35:56 <Axman6m> Albana, it's probably in another tab
03:35:59 <Peaker> Albana: Does your IRC client not join a channel when you type "/join ##java" or do you fail to type that?
03:36:01 <somnolence> because then x is treated as literal, code:http://rafb.net/p/8bR71v20.html
03:36:02 <Twey> ivanm: Having FP anywhere is non-trivial, since current popular CPUs are mostly imperative
03:36:10 <Twey> It's certainly possible: there're Clojure and Scala already
03:36:12 <Axman6m> albana, what are you using to chat to us, what program?
03:36:15 <Albana> no it doesn't join anything :(
03:36:22 <ivanm> Twey: true
03:36:25 <Albana> listen i have no idea i just googled
03:36:29 <Albana> and entered here
03:36:31 <ivanm> Twey: so would it be easier to do FP on a lisp machine?
03:36:39 <daf> Albana: which URL are you at?
03:36:42 <Twey> I imagine it would be vastly so, yes
03:36:43 <vixey> Albana, but you have a vague idea what this (here) is now?
03:36:48 * ivanm guesses mibbit
03:36:50 <somnolence> ivanm: http://rafb.net/p/8bR71v20.html any idea how to get digitToInt working with a map like this?
03:36:51 <Albana> listen i don't understand all this language about computer science
03:36:57 <Twey> Not Mibbit
03:36:57 <Peaker> Twey: compiling high-level imperative code to low-level imperative code is not necessarily easier than compiling high-level functional code to the same
03:36:59 <vixey> lol
03:36:59 <Albana> nooooooooo i have noo idea
03:37:07 <Twey> Peaker: That's true
03:37:09 <Axman6m> urgh!
03:37:10 <vixey> Albana, Haskell is another programming language but it's very unlike java
03:37:11 <Guest26031> ivanm: did the moonpatio link show up?
03:37:14 <Twey> But doesn't contradict what I said :)
03:37:21 <mikem`> Albana: close your browser tab and try again
03:37:21 <daf> heh, Albana is using a Java applet
03:37:23 <Albana> aah didn't know that
03:37:24 <Axman6m> never seen anyone so clueless in my life >_<
03:37:26 <ivanm> somnolence: you only have one Char there, so you don't need the map
03:37:29 * Twey laughs.
03:37:29 <yitz> Twey: current platforms are so complex that it's non-trivial having anything. The fact the there is von Neumann hardware deep inside is not so relevant anymore.
03:37:33 <ivanm> (AFAICT, anyway)
03:37:40 <daf> Axman6m: don't be mean
03:37:45 <Guest26031> the server actually numbers the lines nicely.  something like that would go well on the wiki.
03:37:49 <somnolence> ivanm: ? n is a huge list
03:37:49 <Twey> yitz: I'm not sure I'd agree with that
03:37:49 <ivanm> Guest26031: don't think so...
03:37:50 <Peaker> Axman6m: Most people on Earth have no idea what "IRC" means. Probably most programmers too
03:37:56 <Guest26031> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=834#a834
03:37:56 <Saizan> somnolence: just use "map digitToInt (show longnumber)"
03:38:00 <somnolence> oh
03:38:01 <somnolence> lol
03:38:01 <somnolence> ok
03:38:10 <Albana> yes i have idea of whatt IRC is
03:38:13 <Peaker> Axman6m: surely when one of them gets on IRC by accident from the web, or so, it can be a funny sight :)
03:38:22 <daf> Albana: what's the address in your web browser?
03:38:22 <Albana> maybe i'm having soe problems on understanding your language soo
03:38:24 <ivanm> somnolence: first of all, you can replace "\x -> digitToInt x" with just digitToInt
03:38:24 <Axman6m> Peaker, they don't deserve the name if they don't know what IRC is imo :)
03:38:34 <Albana> http://www.gogloom.com/client2/index2?mainCHAT=1&network=FreeNode&channel=%23haskell     that's the adress here
03:38:37 <Guest26031> Have to go to work.  Thank you gentlemen and ladies(?).
03:38:45 <somnolence> saizan:thanks , ivanm:thanks
03:39:01 <Peaker> Albana: what's the search query you used to get to that page?
03:39:02 <hugo___> if i have a [(a,b)], how do i build a [b] ?
03:39:02 <Twey> yitz: It certainly is non-trivial to develop a fully-featured 'modern' programming language of any species, but I think the VNA still has quite a lot of relevance, unless one compiles to some intermediate language of course
03:39:04 <ivanm> why did Guest* want that put on the wiki?
03:39:12 <yitz> Albana: in the address bar, change %23haskell to %23%23java and hit enter
03:39:13 <Axman6m> hugo: mak snd
03:39:15 <Axman6m> map*
03:39:15 <ivanm> surely its better suited for a tutorial, most of which would already do so...
03:39:17 <daf> Albana: try http://www.gogloom.com/client2/index2?mainCHAT=1&network=FreeNode&channel=%23%23java
03:39:19 <hugo___> heheh
03:39:25 <hugo___> good, thanks Axman6m
03:39:39 <vixey> mIRC Chat -- Expert Mode
03:39:39 <vixey> lol
03:39:47 <Twey> Axman6m: I keep reading your name as Cyrillic
03:39:47 <ivanm> hugo___: or else snd . unzip ;-)
03:40:06 <Axman6m> Twey, eh?
03:40:17 <ivanm> Twey: how is his name coming up as Cyrillic?
03:40:27 <Twey> Ахмапбш
03:40:36 <Axman6m> o.O
03:40:38 <Twey> ivanm: It isn't, it's just my brain playing tricks on me
03:40:39 <yitz> Twey: of course it has relevance. but not necessarily because the deep hardware is VNA. sometimes, but usually for other reasons.
03:40:42 <ivanm> that's not even pronounceable...
03:40:46 <Twey> True
03:40:49 <Twey> Hm
03:40:53 <ivanm> ah-map-bsh
03:40:58 <Twey> Not without a sprained epiglottis, anyway :-P
03:41:02 <ivanm> heh
03:41:02 <Twey> Yeah :-P
03:41:12 <daf> Peaker:  <Albana> i just typed chat for programmers that's all
03:41:14 <ivanm> well, bsh is the java beanshell IIRC...
03:41:23 <Twey> Axman6m: You have a new nickname: Akhmapbsh.
03:41:24 <ivanm> daf: :o
03:41:26 <Peaker> daf: Google "chat for programmers" doesn't lead there
03:41:33 <ivanm> @go chat for programmers
03:41:35 <lambdabot> http://www.livetechtalk.com/
03:41:36 <lambdabot> Title: Live Tech Talk
03:41:42 <ivanm> :/
03:41:44 <yitz> Twey: akhtapbt
03:41:49 <daf> Peaker: Google search is an impure function
03:41:57 <ivanm> yitz: no, ш is sh
03:42:00 <Peaker> daf: heh
03:42:03 <ivanm> not t
03:42:10 <yitz> m is a lower-case t
03:42:13 <ivanm> daf: damn IO...
03:42:23 <Twey> Damn cursive scripts :-P
03:42:28 <ivanm> yitz: but Twey typed ш, not т
03:42:36 <Twey> ivanm: Yes, but that's upside-down :)
03:42:41 <ivanm> heh
03:42:43 <ivanm> true
03:42:50 <Twey> (it's what I read, anyway)
03:43:07 <ivanm> Twey: so are you using typed or hand-written cyrillic when dodgily parsing Axman6m's nick? ;-)
03:43:41 <Twey> ivanm: Printed, I'm not very familiar with the cursive forms :)  (they confused the heck out of me when I first saw them)
03:43:41 <yitz> upside-down it would forall khshpu9sh
03:43:51 <yitz> reverse that actually
03:43:53 <Twey> Haha
03:43:57 <ivanm> heh
03:44:16 <ivanm> yitz: how do you get к from an upside down A?
03:44:18 <Peaker> heh "chat for programmers gogloom" does lead to Haskell very high up
03:44:28 <yitz> no that's the forall
03:44:32 <ivanm> Peaker: wtf is gogloom meant to be?
03:44:47 <blip> is happs hard to learn?
03:44:48 <Peaker> ivanm: maybe some kind of web-irc bridge
03:44:50 <ivanm> yitz: oh, did you just skip it?
03:44:51 <Twey> ∀
03:45:57 <Peaker> Twey: your cone is half full
03:46:12 <ivanm> Peaker: or else he has twice as much cone as he actually needs...
03:46:15 <ivanm> ;-)
03:46:23 * Twey grins.
03:46:32 <Twey> The cone is half-empty of air.
03:46:49 <SamB> how do you half-fill a cone anyway?
03:47:00 <yitz> yeah, I typed programming into the search box at gogloom and #haskell came up number one!
03:47:00 <Peaker> SamB: (forall a. ..)
03:47:01 <Twey> SamB: With careful measuring
03:47:15 <Axman6m> http://www.haskell.org/pipermail/haskell-cafe/2009-January/054072.html
03:47:18 <ivanm> @go gogloom
03:47:21 <Twey> Cone -> cup -> tip half away -> cone
03:47:21 <lambdabot> http://www.gogloom.com/
03:47:21 <lambdabot> Title: Chat Rooms - IRC Search Engine - Gogloom
03:47:27 <SamB> what if you had only a precise ruler to do the measuring with?
03:47:36 <Peaker> SamB: ah, mathematics
03:47:42 <Twey> Then you'd have to use the formula for the volume of a cone
03:47:46 <Twey> Which is... uhm...
03:47:58 <Twey> It's basically just a triangle standing up from a circle
03:48:06 <yitz> hint: there's a 1/3 in it
03:48:08 <Peaker> well, the volume should be an integration of the contents of a growing circle
03:48:17 <SamB> Twey: aren't you thinking of surface area ?
03:48:28 <yitz> instead of the usual 1/2 for area of a triangle
03:48:47 <Peaker> so   integrate (pi*(r^2)) for r=0..(height*growth_of_radius_per_height)
03:48:50 <Twey> Ah!  πr²h/3
03:49:02 <Peaker> or for height=0..()  where r there is height*growth..
03:51:07 <vixey> nice hint lol
03:53:34 <quicksilver> the n-volume of the shape formed by joining an (n-1)-volume to a point is (1/n) * ((n-1)-vol) * perpendicular height.
03:53:37 <quicksilver> maybe.
03:53:40 * quicksilver generalises blindly.
03:54:43 * Axman6m makes it so!
03:54:57 <Axman6m> it is so, update your textbooks
03:55:00 <SamB_XP_> but can you make it sew ?
03:55:49 <Axman6m> isn't it obvious?
03:56:08 <Axman6m> if you can't see it, then i'm sorry, you don't deserve to be using haskell
03:57:02 <SamB_XP_> I can't even imagine how it would look sewing
03:58:16 <Peaker> you guys and your mathematics.. you can't program with mathematics!
03:58:57 <SamB_XP_> Peaker: than what is all this stuff we've written ?
03:59:10 <Peaker> SamB_XP_: blasphemy
04:00:22 <Axman6m> > let x = if x < 0 then 1-x else x in x
04:00:38 <lambdabot>   thread killed
04:01:01 <SamB_XP_> yay least fixed point!
04:01:08 <lilac> > let x = case x of x -> x in x
04:01:24 <lambdabot>   thread killed
04:02:46 <yitz> > let x = if x > 0 then x / 2 in x
04:02:47 <lambdabot>   <no location info>: parse error on input `in'
04:02:56 <yitz> > let x = if x > 0 then x / 2 else x in x
04:03:11 <lambdabot>   thread killed
04:03:21 * yitz smells smoke coming out of \bot
04:03:44 <Axman6m> > let x = if x > x then x/2 else x in x
04:03:50 <lilac> lambdabot: murderer! they were innocent processes!
04:03:53 <killerboy> hi
04:03:54 <blathijs> Is there an easy way to identify tuple construction in a CoreExpr? So far I've manually matched application to some var, where I match the name of the var as "GHC.Tuple.(,)", but that's not very generic (only works for two-tuples) and leaves me to manually separate the type arguments from the real arguments. Any suggestions?
04:04:00 <lambdabot>   thread killed
04:04:12 <yitz> hi killerboy
04:04:34 <Axman6m> ? lex x = 1/x in x
04:04:35 <killerboy> i'd like to contribute to lambdabot some very simple patch, is there something i should be aware of?
04:04:39 <Axman6m> > lex x = 1/x in x
04:04:40 <lambdabot>   <no location info>: parse error on input `='
04:06:01 <blathijs> Hmm, I'll ask this in #ghc I guess
04:06:29 <Axman6m> > let b ? (t,f) = if b then t else f in True ? (1,0)
04:06:30 <yitz> killerboy: the \bot code is starting to get old. people are working on various candidates for a replacement.
04:06:31 <lambdabot>   1
04:06:40 <yitz> killerboy: but in the meantime nothing beats lambdabot
04:06:50 <Axman6m> zomg, almost 600 people again
04:06:57 <killerboy> ok, so i can contribute it right?
04:07:02 <lilac> there's nothing like the cool refreshing taste of lambdabot
04:07:03 <SamB_XP_> yitz: except various and sundry crashes
04:07:28 <SamB_XP_> and her habbit of forgetting all kinds of stuff every time
04:07:35 <yitz> last I heard Cale was in charge, is that still true?
04:07:47 <SamB_XP_> yeah
04:07:53 <yitz> SamB_XP_: that happens with age. happens to me too.
04:08:27 <SamB_XP_> @quote
04:08:28 <lambdabot> BillWood says: it became obvious that when a Prolog program is tuned by removing non-determinism it moves towards a functional program.
04:08:35 <yitz> killerboy: Cale is in eastern N. America, so look for him in an hour or two.
04:08:54 * SamB_XP_ is too
04:09:14 <killerboy> in two hour i won't be here :-(
04:09:39 <wolverian> can I use lhs2TeX with the tt layout and T1 fontenc somehow? using T1 messes up the code blocks for me
04:09:40 <yitz> killerboy: leave him a message using the command @tell Cale <stuff>
04:10:01 <killerboy> ok
04:10:21 <SamB_XP_> and just hope \bot doesn't crash in the meantime, thus forgetting all about your message ;-P
04:10:33 <yitz> @tell killerboy I've left you a message.
04:10:34 <lambdabot> Consider it noted.
04:10:57 <killerboy> ok
04:10:57 <lambdabot> killerboy: You have 1 new message. '/msg lambdabot @messages' to read it.
04:11:04 <killerboy> i can use lambdabot
04:11:43 <dublpaws> :i CoreExpr
04:12:30 <killerboy> thanks
04:13:48 <hugo___> can i define "instance XPTO A where" if i have the type class XPTO but dont have the datatype A ?
04:13:53 <hugo___> will it automatically generate that datatype ?
04:14:12 <killerboy> thanks, bye
04:15:35 <Axman6m> hugo: sounds unlikely
04:17:48 <hugo___> hmm
04:17:55 <quicksilver> @remember SPJ [This is] clearly not a bug in GHC; but it would be more felicitous if it gave you a warning...
04:17:55 <lambdabot> It is stored.
04:18:03 <quicksilver> SPJ++ # great use of word felicitous.
04:18:18 <SamB> a felicitious morning to you as well
04:18:23 <SamB> er.
04:18:28 <SamB> minus that extra i
04:18:52 <hugo___> i have two data types A and B, that use the same functions signature for manipulation, but the inner functions are quite different, how do i abstract that ?
04:19:23 <Axman6m> make a class
04:19:42 <quicksilver> hugo___: (a) make a class (b) embed them in an ADT data C = A A | B B
04:19:52 <quicksilver> whichever feels more appropriate.
04:20:01 <quicksilver> I'm more likely to do (b) than (a) personally.
04:20:11 <quicksilver> But my hatred of typeclasses is well-documented.
04:20:17 <hugo___> i have made a class
04:20:21 <SamB> what are you doing here then ?
04:21:33 <Axman6m> one more person...
04:23:52 <Axman6m> lame zeno
04:24:13 <SamB> I bet he's why the other person didn't get here, too
04:24:15 <SamB> damn paradox
04:24:18 <idnar> the problem with (b) is that it's not externally extensible
04:24:31 <idnar> is there a solution to that problem that doesn't involve typeclasses?
04:24:37 <RayNbow> @google quicksilver's hatred typeclasses
04:24:39 <lambdabot> No Result Found.
04:24:44 <idnar> haha
04:25:56 <Maddas> Clearly we need to reduce the time it takes for channel logs to be picked up by Google.
04:26:35 <quicksilver> @google loquacracy
04:26:37 <lambdabot> No Result Found.
04:26:42 <ivanm> Maddas: so google needs to start indexing IRC?
04:26:43 <RayNbow> the channel logs also need some extra metadata, so you could look up past conversation about certain topics :p
04:26:47 <ivanm> @quote loquacracy
04:26:48 <lambdabot> No quotes match. You untyped fool!
04:26:54 <RayNbow> *conversations
04:26:55 <ivanm> looks like lambdabot forgot... AGAIN!!!
04:27:02 <quicksilver> erm.
04:27:09 <quicksilver> there are google results for that word
04:27:13 <quicksilver> and they are this channel.
04:27:22 <quicksilver> "Results 1 - 10 of about 57 for loquacracy"
04:27:26 <quicksilver> odd.
04:27:42 <idnar> google searches aren't stable
04:27:43 <RayNbow> @google test
04:27:45 <lambdabot> http://www.test.com/
04:27:45 <lambdabot> Title: Test.com Web Based Testing and Certification Software v2.0
04:28:05 <idnar> (and also tend to vary depending on location / logged-in-or-out / etc.)
04:28:10 <quicksilver> idnar: not stable, sure. But 57 results to zero results is weird.
04:28:15 <quicksilver> @google loquacracy
04:28:17 <lambdabot> No Result Found.
04:28:44 <quicksilver> I think there must be a bug in @google personally.
04:29:28 <ivanm> quicksilver: I thought @google _was_ one big bug that happened to work occasionally...
04:29:41 <quicksilver> that could be it.
04:29:46 <quicksilver> @users
04:29:47 <lambdabot> Maximum users seen in #haskell: 642, currently: 599 (93.3%), active: 16 (2.7%)
04:29:52 <BONUS> if you have an associated type synonym somewhere inside a class declaration, like type F :: * -> * and then do data D a = D (F a) somewhere else
04:29:59 <BONUS> what does that data declaration really mean
04:30:09 <Gabbie> 599?
04:30:16 <Axman6m> rawr!
04:30:16 <znutar> I bet it's that loquzcracy is only used at one or two sites in the world and only one machine has spidered them and the changes haven't propagated
04:31:31 <Axman6m> hooray!
04:31:55 <Axman6m> congratulations abbe, you're thre 600th visitor to #haskell today!
04:32:09 <quicksilver> znutar: nah, it's been in the google index for weeks or months.
04:32:23 <abbe> Axman6m: :)
04:32:23 <lambdabot> abbe: You have 1 new message. '/msg lambdabot @messages' to read it.
04:34:50 <vixey> BONUS, I think it's just like F is a function * -> *
04:34:58 <vixey> might not be accurate but..
04:35:19 <BONUS> yeah i get that but how would you make a value of that data type
04:35:33 <vixey> it depends on F I guess
04:35:40 <quicksilver> you'd write D (...however you would make a value of that F...)
04:35:46 <vixey> if F was []  vs Maybe
04:35:58 <vixey> (or whatever else it might be)
04:36:10 <BONUS> ah i see
04:36:13 <quicksilver> having said that, I wonder what the principle type of the constructor "D" would be.
04:36:14 <mmorrow> , randE()
04:36:17 <lunabot>  [x22 11 (- 24)] "This is a" "Thi" :: (->)
04:36:20 <BONUS> it depends on the instances
04:36:38 <mmorrow> gah, it seems to only give type sig as "(->)"
04:36:38 <quicksilver> C a => F a -> D a
04:36:40 <quicksilver> I suppose.
04:37:16 <BONUS> i see you have to give explicit type annotations when making values of D
04:37:31 <BONUS> cause associated type synonyms don't seem to be injective
04:37:56 <vixey> isn't the reqiurement surjectivity
04:38:02 <vixey> ?
04:38:09 <BONUS> hmm
04:38:41 <abbe> testing 1 2 3
04:38:47 <BONUS> could be
04:39:23 <quicksilver> no, I think BONUS is right.
04:39:40 <quicksilver> You could have two different types a,b both members of the class, and have F a = F b = []
04:39:54 <quicksilver> so then "D []" would be a valid term of type D a and also of D b
04:39:55 <BONUS> yeah
04:40:03 <BONUS> that's what i was thinking
04:40:07 <vixey> not injective doesn't mean not surjective..
04:40:19 <quicksilver> this is the key different between assoc. synonym and assoc. data
04:40:22 <quicksilver> vixey: I know that.
04:40:52 <quicksilver> I'm just saying, BONUS framed the problem clearly. F can fail to be injective, so you will need annotations.
04:41:02 <quicksilver> if F was assoc. data then its injective by construction.
04:41:06 <quicksilver> which saves on annotation.
04:41:22 <SamB> mmorrow: odd!
04:41:26 <SamB> (->) is no type
04:41:34 <SamB> it's a tycon, sure ...
04:41:46 <vixey> :k (->)
04:41:47 <lambdabot> ?? -> ? -> *
04:46:03 <hugo___> hmm
04:46:18 <dublpaws> > concat [map ((12*x)+) [0, 2, 4, 5, 7, 9, 11 ] | x <- [0..5] ]
04:46:20 <lambdabot>   [0,2,4,5,7,9,11,12,14,16,17,19,21,23,24,26,28,29,31,33,35,36,38,40,41,43,45...
04:47:44 <Peaker> dublpaws: that's a weird combo of concat, map, and list compr.
04:47:51 <dublpaws> succinct :: CrappyCode -> NiceCode
04:48:09 <hugo___> i have this data type "A { x :: X, y :: Y, z :: Z}" and im defining an instance like "instance W A where operation = ..." and operation :: Int, how do i access the values of x y z inside my instance declaration ?
04:48:17 <Peaker> > [(12*x)+y | x <- [0..5], y <- [0, 2, 4, 5, 7, 9, 11 ]]
04:48:18 <lambdabot>   [0,2,4,5,7,9,11,12,14,16,17,19,21,23,24,26,28,29,31,33,35,36,38,40,41,43,45...
04:49:30 <hugo___> do i need to specify it like "instance W A{x=x, y=y, z=z} where ..." ?
04:49:55 <dublpaws> Peaker: that's nicer, thanks.
04:50:41 <Peaker> dublpaws: concat . map is concatMap is roughly a list comprehension
04:51:06 <Twey> An LC is more like concatFilterMap :-P
04:51:18 <mmorrow> SamB: random haskell expression with QuickCheck http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=832
04:51:30 <mmorrow> (see second paste)
04:51:42 <mmorrow> , randE()
04:51:44 <lunabot>  ()
04:51:46 <mmorrow> , randE()
04:51:48 <lunabot>  ()
04:51:50 <mmorrow> , randE()
04:51:50 <vixey> , randE()
04:51:52 <lunabot>  [x9, \ "Thi" -> x1 :: x4, case "Th" of { 21 -> x14}, x0, x15]
04:51:52 <lunabot>  x21 x10 ([] (if "This is a " then x12 else x13 :: x1 x3)) x14
04:52:28 <quicksilver> hugo___: and operations :: Int ?
04:52:37 <Twey> hugo___: You're mixing up types and constructors
04:52:37 <quicksilver> hugo___: there is no value of type A in operation :: Int
04:52:46 <quicksilver> hugo___: what do you want the "x" value of?
04:52:59 <quicksilver> hugo___: did you mean operation :: A -> Int ?
04:53:15 <hugo___> yes
04:53:18 <hugo___> operation :: Int
04:53:22 <hugo___> it is correct
04:53:26 <Twey> instance W A where operation (A {x=x, y=y. z=z}) = x + y + z
04:53:30 <quicksilver> well tehre is no "A" in Int.
04:53:41 <quicksilver> so that cannot be right.
04:53:47 <quicksilver> surely operation :: A -> Int
04:53:48 <hugo___> then what is the point on having type classes ?!
04:53:48 <quicksilver> is what you want
04:53:51 <Saizan> "class W a where operation :: Int" makes no sense
04:53:54 <Twey> (in which case class W a where operation :: a -> Int)
04:54:01 <quicksilver> hugo___: overloading.
04:54:07 <hugo___> yes, that is what im doing
04:54:09 <hugo___> okey
04:54:17 <quicksilver> the point of typeclasses is to overload (one or more) operations over a class of types.
04:54:41 <quicksilver> I don't recommend { x = x } myself.
04:54:42 <hugo___> in the class declaration i have "class W where operation :: Int" and on the instance i want to define this operation accordingly to the data type it is receiving
04:54:44 <hugo___> how do i do this ?
04:54:57 <quicksilver> for the 4th time
04:54:59 <hugo___> its just an example :/
04:55:03 <SamB> mmorrow: it needs work!
04:55:04 <quicksilver> you DONT want "operation :: Int"
04:55:10 <quicksilver> that doesn't make sense.
04:55:10 <hugo___> but
04:55:18 <hugo___> for me it does
04:55:23 <quicksilver> class W a where operation :: a -> Int
04:55:30 <quicksilver> seems likely to be what you mean.
04:55:31 <Twey> @info Bounded
04:55:31 <lambdabot> Bounded
04:55:35 <hugo___> operation can return 5 if it is an instance of A, or it can return 6 if it is na instance of B
04:55:36 <Twey> @src Bounded
04:55:37 <lambdabot> class  Bounded a  where
04:55:37 <lambdabot>     minBound, maxBound :: a
04:55:40 <Saizan> hugo___: i think you're confusing typeclasses with OO classes
04:55:43 <hugo___> how do i do such an operation ?
04:55:58 <quicksilver> hugo___: "operation :: Int" would be a top-level constant
04:56:08 <Twey> hugo___: If *what* is an instance of A?
04:56:09 <quicksilver> how could it know whether to use the 'A' version or the 'B' version?
04:56:13 <Twey> You're not passing anything to it
04:56:17 <Ferdirand> so you want operation :: A -> Int, and operation = const something ?
04:56:38 <quicksilver> you have to have the type of the member appearing somewhere in the type of the method
04:56:43 <quicksilver> to allow the type-check to choose the right one.
04:56:43 <hugo___> yes, it is simple... see :/
04:56:54 <quicksilver> for example, consider the type of (+)
04:56:55 <hugo___> hmm
04:57:00 <quicksilver> Num a => a -> a -> a
04:57:03 <quicksilver> "a" appears in it
04:57:06 <quicksilver> (three times, as it happens)
04:57:12 <quicksilver> that's how it picks the correct one.
04:57:33 <hugo___> ... i dont think you guys are getting it... because haskell should be able to work this out :/
04:57:40 <quicksilver> hugo___: How.
04:57:46 <quicksilver> hugo___: consider this expression:
04:57:49 <Twey> hugo___: Write some code that uses it.
04:57:50 <quicksilver> (4 * operation) + 1
04:58:04 <quicksilver> hugo___: how could you expect haskell to know which version of 'operation' that refers to ?
04:58:08 <Twey> Don't worry about defining it for now: write some code that demonstrates how it would be used if it were magically defined.
04:58:11 <hugo___> "class W where op :: Int" and then "instance W (A x y z) where op = x + y" isn't this possible ?
04:58:13 <Twey> Then you'll see your error.
04:58:23 <Saizan> hugo___: no
04:58:29 <quicksilver> hugo___: for the 5th time, NO.
04:58:32 <Twey> It's nonsensical.
04:58:40 <hugo___> bahh
04:58:43 <quicksilver> hugo___: the type of the methods must mention the type parameter of the class.
04:58:44 <quicksilver> as I keep saying.
04:58:46 <Saizan> hugo___: first of all, a typeclass without a type parameter doesn't make sense
04:58:46 <BONUS> you could do op :: a -> Int
04:58:49 <quicksilver> hugo___: please answer one of my questions.
04:58:53 <quicksilver> (4 * operation) + 1
04:58:53 <BONUS> so that you call op with your A
04:58:55 <quicksilver> hugo___: how could you expect haskell to know which version of 'operation' that refers to ?
04:59:07 <Saizan> hugo___: you're thinking about OO classes and subtyping, typeclasses are something different
05:00:13 <vixey> lol
05:00:20 <sereven> ideas to refactor this case of case of fn, or different approach? http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=835#a835
05:00:24 <hugo___> quicksilver: you are correct
05:00:31 <hugo___> there is no way haskell could know it :/
05:00:45 <vixey> sereven, how about not using case?
05:00:52 <quicksilver> hugo___: right.
05:01:05 <vixey> nextUnfocused (Stack t [] []) = ...
05:01:10 <vixey> nextUnfocused (Stack t [] (x:ys)) = ...
05:01:10 <quicksilver> hugo___: so, the purpose of type classes is to allow the type inference engine to choose which instance applies.
05:01:29 <quicksilver> hugo___: for that idea to work, the type of the class member must appear somewhere in the type of each method.
05:01:33 <sereven> just use multiple definitions, yah..
05:01:52 <hugo___> so i will define a class like "class W a where op :: a -> Int" and then "instance W B where op (B x y z) = x +y" is this possible ?
05:01:53 <quicksilver> hugo___: (it doesn't have to be an argument, it can be the result, or it can be embedded in a type constructor, or anything, as long as its there somewhere)
05:02:06 <vixey> hugo__, lol
05:02:10 <hugo___> :P
05:02:12 <quicksilver> hugo___: yes, that looks good.
05:02:19 <hugo___> damn im stuborn
05:02:26 <Saizan> vixey: ?
05:02:39 <hugo___> ok, thanks you :)
05:02:40 <BONUS> basically think of a typeclass as some behaviour that a type has. it can behave like something
05:02:44 <quicksilver> op :: a -> Int is, OK, so is op :: Int -> a, op :: a -> b -> a, op :: Int -> [a], and so on
05:02:54 <BONUS> if you want it to be able to behave like something that you can print to a string, make it an instance of Show
05:02:54 <quicksilver> any kind of complex or simple type which mentions a somewhere
05:03:02 <quicksilver> for the type engine to 'latch onto'
05:03:14 <BONUS> if you want it to be able to behave like something that can be equated, then make it Eq, etc.
05:04:45 <hugo___> BONUS: i think im trying to work something a bit complex for my brain to reason like that over it :/
05:05:34 <quicksilver> hugo___: remember my first rule of haskell programming
05:05:42 <quicksilver> (1) If you think you want a typeclass, you don't. Sorry. Think again.
05:05:48 <BONUS> lol
05:05:58 <vixey> hugo___, maybe this example will help:  class Size a where size :: a -> Int
05:06:09 <hugo___> quicksilver: yes, i didn't think i would want one, until i got stuck with that other problem of "show"
05:06:11 <hugo___> :(
05:06:18 <quicksilver> ah, right.
05:06:21 <pejo> quicksilver, quite strict rule.
05:06:26 <vixey> hugo___, instance Size [a] where size = length;  instance Size (Tree a) where size (Leaf a) = 1 ; size (Brach l r) = size l + size r
05:06:28 <quicksilver> class PrettyPrint a where pp :: a -> String
05:06:37 <hugo___> yes, its something like that
05:06:40 <BONUS> quicksilver: i'm interested to hear more about your criticism of typeclasses, but you're probably sick of telling it to people over and over again, is it written down somewhere so that i can read it?
05:06:45 <sereven> vixey: yeah, thanks, I will, that would have given me double wheres as it was really being used, but will shift that around a bit too.
05:06:49 <quicksilver> BONUS: No, I should write up my rant.
05:07:00 <quicksilver> BONUS: basically it just boils down to people using them for something they're not.
05:07:05 <vixey> sereven, or yu could put the main definition in a where clause
05:07:06 <BONUS> ah, well if/when you do, forward me the link
05:07:14 <quicksilver> BONUS: because they think they're something like OO classes.
05:07:18 <hugo___> :)
05:07:23 <quicksilver> or some kind of general abstraction mechanism.
05:07:32 <BONUS> ah, hmm
05:07:34 <hugo___> yes... my mind is still stuck with all those years of c++ :/
05:07:41 <quicksilver> When they're not really an abstraction mechanism at all, they're an overloading/polymorphism mechanism.
05:07:43 <vixey> afaict typeclasses are so you can write (+) instead of (+.)
05:07:49 <vixey> and do ... instead of do Maybe ...
05:07:49 <quicksilver> exactly.
05:08:05 <jnaimard> does the monad instance of either depend on the left type?
05:08:21 <daf> there isn't a monad instance of Either, I think
05:08:29 <Saizan> unfortunately yes, it depends on it being an instance of Error
05:08:30 <jnaimard> oh that's
05:08:32 <jnaimard> why
05:08:32 <daf> only instances of Either a for specific as
05:08:48 <BONUS> > Left "haha" >> Right "w00t
05:08:49 <lambdabot>   <no location info>:
05:08:49 <lambdabot>      lexical error in string/character literal at chara...
05:08:52 <jnaimard> ok, so that would be a yes to my question
05:08:54 <jnaimard> thanks
05:09:06 <Saizan> there's instance Error e => Monad (Either e) in Control.Monad.Error
05:09:15 <daf> > Left "haha" >> Right "woot"
05:09:17 <lambdabot>   Left "haha"
05:10:07 <jnaimard> that's the one i was seeing and not understanding
05:10:13 <quicksilver> (along with an Error instance for String)
05:10:21 <quicksilver> jnaimard: the purpose is to write the method "fail"
05:10:21 <jnaimard> but i don't see what's the point of Error in that case
05:10:30 <quicksilver> fail x = Left (fromString x)
05:10:39 <quicksilver> where 'fromString' is a method of the Error class
05:10:47 <quicksilver> so you need the Left-y bit to be a member of Error
05:10:49 <quicksilver> to suport that
05:10:53 <quicksilver> it's rather ugly.
05:11:15 <quicksilver> in fact, you could, the problem is made of fail.
05:11:18 <hugo___> is there any work being developed on haskell web services ?
05:11:30 <quicksilver> sure
05:11:41 <quicksilver> there some CGI stuff, some fastCGI stuff, there's happs, there's turbinado
05:11:43 <daf> fail²
05:11:45 <jnaimard> so having fail in monad is not only ugly, it's also painful
05:11:45 <vixey> :t Nothing >>= ?x
05:11:47 <lambdabot> forall a b. (?x::a -> Maybe b) => Maybe b
05:11:50 <quicksilver> there's WASH
05:11:53 <hugo___> i really dislike the java approach of wsdl/soap :/
05:11:56 <hugo___> oh nice
05:11:57 <quicksilver> there's some other stuff I've forgotten ;)
05:12:00 <hugo___> i've been developing with happs
05:12:12 <hugo___> ill write a post about it
05:12:22 <quicksilver> I've not seen anything which is "like" wsdl/xmlrpc/corba if that's what you mean
05:12:31 <quicksilver> automatic/semiautomatic API presentation.
05:12:48 <daf> jnaimard: I was a bit surprised that I couldn't use Either like Maybe monadically too
05:13:20 <quicksilver> well, you can.
05:13:22 <hugo___> okey
05:13:28 <quicksilver> just write a bogus Error instance
05:13:31 <quicksilver> it doesn't matter ;)
05:13:35 <daf> eww
05:14:20 <quicksilver> instance Error MyType where strMsg = error "This is stupid"; noMsg = error "No, really, I hate this class"
05:14:31 <Saizan> or use a different monad library
05:15:11 <daf> Saizan: such as?
05:15:28 <dolio> All monad libraries have to deal with the fact that the prelude contains the Monad class, and therefore Monads include fail.
05:15:39 <idnar> so basically, all monads fail
05:15:41 * idnar ducks
05:16:06 <daf> dons said it best
05:16:33 <jnaimard> yes, but they could use quicksilver's definition to get instance Monad (Either a)
05:16:35 <daf> http://cgi.cse.unsw.edu.au/~dons/blog/2008/05/24#monad_fail
05:17:30 <quicksilver> I really can't say the Error class bothers me much.
05:17:52 <quicksilver> there is normally a sensible or reasonable way to embed that kind of unknown error in.
05:18:37 <idnar> well, it would be nice if there were a non-Error Monad (Either a) instance
05:19:01 <idnar> without resorting to that instance :P
05:19:18 <dolio> Yeah, sometimes return/bind would be handy to have for any Either.
05:19:46 <jnaimard> in particular if Left is early success rather than failure
05:19:48 <dolio> And having to import Control.Monad.Error and define a bogus Error instance makes it no longer particularly attractive.
05:20:10 <daf> indeed
05:20:19 <daf> it kills the atmosphere
05:20:29 <daf> you're no longer in the mood
05:20:32 <idnar> heh
05:22:59 <lilac> another problem that would be solved by one-member-per-typeclass :) *ducks*
05:23:37 <Toxaris> dolio: a monad library could provide a bogus Monad instance, instead of forcing the users to write bogus Error instances, e.g. instance Monad (Either a) where fail = error
05:24:11 <quicksilver> Toxaris: but it would be unsafe to use that in the same progrm as any other library that used the MTL instance
05:24:15 <dolio> It could. But then you lose the ability to use pattern match failure in Either when you want it.
05:24:16 <quicksilver> Toxaris: in principle, at least.
05:24:18 * vixey implemented every lambda equality check under the sun :/
05:24:23 <quicksilver> in practice I expect it would be fine.
05:25:05 <Saizan> fail s = Left (error s) -- a bit better
05:26:08 <dolio> And one-member-per-typeclass doesn't make things peachy either, because then you have to write "(Bind m, Return m) => " because someone defined "class (Bind m, Return m, Fail m) => Monad m where" in the prelude.
05:26:14 <dolio> So everyone gets to type extra.
05:26:51 <Toxaris> Saizan: not sure that is better. what if I don't want the Left = error semantics, but want to do something non-strict with the Left's (e.g. count them)?
05:27:27 <mattam> vixey: and what's the recap?
05:27:35 <Toxaris> scala has a more symmetric treatment of Either, where you explicitly select whether you want the map & co. to work over the Left or the Right elements
05:27:43 <vixey> mattam, what do you mean by recap?
05:28:03 <mattam> Your conclusions.
05:28:36 <dolio> Or alternately, most things will show up as "a pointed functor with bind" instead of "a monad", despite the fact that the former is a definition of the latter.
05:29:02 <dolio> So it doesn't prevent you from writing crappy libraries.
05:29:17 <quicksilver> dolio: one method-per-typeclass proabbly needs something like class aliases to ease the pain.
05:29:28 <quicksilver> arguably nothing prevents you from writing crappy libraries.
05:29:34 <quicksilver> except #haskell.
05:29:38 <vixey> mattam, It took me all this work (and a lot of scribbling on paper) to just understand the method from Abel, Coquand and Dybjer.. but it also seems /the/ correct way
05:30:08 <vixey> mattam, every other method seems to make an unbreakable loop so you have to define conv. checking and inference mutually
05:30:24 <dolio> That doesn't change anything but how much typing you have to do to write an instance.
05:30:33 <dolio> The Monad alias would still include fail.
05:30:43 <dolio> Assuming we're making the same mistakes.
05:31:21 <Baughn> Binary's nice, but is there any library around that will generate the reading, writing code and datatypes from some sort of spec?
05:31:49 <Saizan> Baughn: there's a derivation in Data.Derive
05:31:59 <jway> what does "map . zip" mean
05:32:02 <jway> the dot
05:32:04 <Saizan> Baughn: but nothing where you can specify the format
05:32:10 <daf> jway: function composition
05:32:12 <daf> @src (.)
05:32:13 <lambdabot> (f . g) x = f (g x)
05:32:20 <Baughn> Saizan: Well, I don't really need to specify the format, so long as it's freezable
05:32:40 <Baughn> Eg. I can generate it once and then make the generated source part of the package
05:32:41 <jway> thanks
05:33:31 <mattam> vixey: interesting. That's my current opinion as well but I don't get all the technical details of NbE yet.
05:33:32 <Saizan> Baughn: then you can use the derive tool, or copy/paste the code generated with TH
05:34:00 <Saizan> Baughn: it'll still depend on the instances for the types of the fields though
05:34:00 <Baughn> Saizan: Yay. My goal, of course, is to create a Coda-beating filesystem in less than a thousand lines of code. ^_^
05:34:03 <Baughn> ..probably not, but
05:34:20 * Baughn disappears into the world of anime
05:36:04 <h0tzenpl0tz> hello, why does foldr (flip (&&)) True (repeat False) result in a stack-overflow?
05:36:16 <vixey> mattam, well I don't really understand the proofs.. I have not got much domain theory/topology background
05:36:50 <mattam> I mean even the implementation I've not tried to do it myself yet.
05:36:55 <vixey> > foldr (&&) True (repeat False)
05:36:56 <lambdabot>   False
05:37:02 <Arda> hello
05:37:25 <h0tzenpl0tz> >  foldr (flip (&&)) True (repeat False)
05:37:27 <lambdabot>   * Exception: stack overflow
05:37:44 <h0tzenpl0tz> why ... ?
05:37:47 <baaba> @src (&&)
05:37:47 <lambdabot> True  && x = x
05:37:47 <lambdabot> False && _ = False
05:38:10 <h0tzenpl0tz> because the first is True so it will recurse into infinity?
05:38:21 <mattam> @src foldr
05:38:22 <lambdabot> foldr f z []     = z
05:38:22 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:38:49 <h0tzenpl0tz> the laziness is somewhat psycho :(
05:38:52 <baaba> > let False && _ = False; _ && False = False; _ && _ = True in foldr (flip (&&)) True (repeat False)
05:38:54 <doserj> && is strict in the first argument, non-strict in the second
05:38:54 <lambdabot>   * Exception: stack overflow
05:39:17 <h0tzenpl0tz> makes sense ....
05:39:21 <doserj> for flip && it is the other way round
05:39:58 <vixey> mattam, well my view (it might not be 100% accurate) is that you have got syntax  S ::= #i | Lam(S) | S S, (every term in S is alpha normal form) for example, and then a semantic domain D ::= DLam(D) | Neutral N; N ::= N D | #i,  so D holds lambda terms also but they are always in beta normal form, so if you have a function ($) :: D -> D -> D,  then folding from S into D is evaluation, and quoting back out gets beta normal forms
05:40:00 <h0tzenpl0tz> so the flipped && will get the neutral-element True first instead of second....
05:40:02 <h0tzenpl0tz> thanks
05:40:29 <vixey> mattam, (and if for every: Neutral N,  N has not got a function type, then it's eta nf too)
05:40:49 <mattam> ok
05:41:39 <mattam> I still think I'll have to do it by myself just to be sure :)
05:42:06 <vixey> there is also this reify/reflect thing which it seems is not used -- but the idea about type directed evaluation is.. reify/reflect is a bit confusing because to me it seems reify = reflect
05:42:09 <h0tzenpl0tz> @src Monad
05:42:09 <lambdabot> class  Monad m  where
05:42:10 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
05:42:10 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
05:42:10 <lambdabot>     return      :: a -> m a
05:42:10 <lambdabot>     fail        :: String -> m a
05:42:54 <mattam> reify/reflect is not evaluation/quote?
05:42:56 <h0tzenpl0tz> @src Arrow
05:42:57 <lambdabot> class Arrow a where
05:42:57 <lambdabot>     arr, pure   :: (b -> c) -> a b c
05:42:57 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
05:42:57 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
05:42:57 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
05:42:59 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
05:43:01 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
05:43:04 <vixey> mattam, oops I made a mistak,  it should have been   D ::= DLam(D -> D) | Neutral N;
05:43:59 <vixey> mattam, I can get beta-eta normal forms using:  quote . r type $ eval term,   where r = reify = reflect
05:44:12 <vixey> but only for STLC, I didn't see it scaling up well to dependent types
05:44:18 <mattam> Yeah, that's what bugs me the most. You have to solve this domain equation here and I don't understand it :)
05:44:31 <vixey> D ~= D^D ? :)
05:44:32 <h0tzenpl0tz> > foldr (flip (&&)) undefined (repeat False)
05:44:33 <lambdabot>   * Exception: stack overflow
05:44:37 <h0tzenpl0tz> doh
05:44:41 <h0tzenpl0tz> i dont getit
05:44:42 <Axman6> @instances Arrow
05:44:43 <lambdabot> (->), Kleisli m
05:44:48 <Axman6> >_<
05:44:50 <doserj> @src foldr
05:44:50 <lambdabot> foldr f z []     = z
05:44:51 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:45:04 <doserj> look at the second line
05:45:16 <h0tzenpl0tz> yeah, undefined is no first element to &&
05:45:21 <h0tzenpl0tz> and isnt && strict to the first?
05:45:29 <h0tzenpl0tz> is NOW first element ...
05:45:33 <doserj> if f is strict in the second argument, it has to recurse
05:45:39 <h0tzenpl0tz> > undefined && True
05:45:40 <lambdabot>   * Exception: Prelude.undefined
05:45:58 <h0tzenpl0tz> > undefined && False
05:46:00 <lambdabot>   * Exception: Prelude.undefined
05:47:23 <lilac> > foldr (&&) undefined (repeat False)
05:47:25 <lambdabot>   False
05:47:26 <h0tzenpl0tz> but f gets x as first argument. if flipped it gets x as snd argument. so e && x => undefined && False should be undefined and stopping immediately...
05:47:27 <h0tzenpl0tz> not?
05:47:28 <Axman6> > flip const 1 undefined
05:47:30 <lambdabot>   * Exception: Prelude.undefined
05:47:36 <lilac> h0tzenpl0tz: no.
05:47:46 <lilac> h0tzenpl0tz: (&&) gets a call ot (&&) as its first argument
05:48:03 <lilac> > foldr (flip f) undefined (repeat False)
05:48:04 <lambdabot>   Add a type signature
05:48:07 <lilac> > foldr (flip f) undefined (repeat False) :: Expr
05:48:09 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
05:48:38 <Axman6> > foldr (flip f) undefined $ replicate 10 undefined
05:48:40 <lambdabot>   Add a type signature
05:48:46 <Axman6> > foldr (flip f) undefined $ replicate 10 undefined :: Expr
05:48:48 <lambdabot>   f (f (f (f (f (f (f (f (f (f * Exception: Prelude.undefined
05:49:04 <lilac> > foldr (flip f) a $ replicate 10 b :: Expr
05:49:06 <lambdabot>   f (f (f (f (f (f (f (f (f (f a b) b) b) b) b) b) b) b) b) b
05:49:25 <doserj> h0tzenpl0tz: the undefined never enters the picture
05:49:38 <lilac> ^^ all the 'False' values are the /second/ argument of the (&&) if you flip it
05:49:53 <vixey> @let fab = foldr (flip f) a $ replicate 10 b :: Expr
05:49:54 <lambdabot>  Defined.
05:50:11 <lilac> vixey: thunderbirds are go?
05:50:29 <h0tzenpl0tz> this is psycho
05:50:29 <SKuhn> h0tzenpl0tz: skype
05:50:32 <h0tzenpl0tz> gotta think about it
05:50:33 <h0tzenpl0tz> thanks
05:50:57 <lilac> h0tzenpl0tz: in a right fold, the values in the list are the left-hand argument to the operator
05:51:10 <lilac> > foldr (*) a $ replicate 10 b :: Expr
05:51:12 <lambdabot>   b * (b * (b * (b * (b * (b * (b * (b * (b * (b * a)))))))))
05:51:18 <h0tzenpl0tz> yes
05:51:24 <lilac> h0tzenpl0tz: that's what you want, so don't flip the (&&)
05:51:32 <lilac> (since (&&) is left-strict)
05:51:38 <h0tzenpl0tz> yes
05:52:35 <Axman6> > show fab
05:52:37 <h0tzenpl0tz> > foldr (flip (&&)) undefined (repeat False) :: Expr
05:52:37 <lambdabot>   "f (f (f (f (f (f (f (f (f (f a b) b) b) b) b) b) b) b) b) b"
05:52:38 <lambdabot>   Couldn't match expected type `Expr' against inferred type `Bool'
05:53:14 <lilac> "foldr f a xs" is _|_ if xs is infinite and f is right-strict
05:53:24 <lilac> (&&) is left-strict, so flip (&&) is right-strict
05:54:32 <Axman6> seems i've started a wordpress haskell blog trend in the last day or two
05:54:44 <drdozer> are there commands in ghci to explore indexed types?
05:54:44 <Axman6> first me, then Workybob, then dons
05:54:59 <Workybob> hehe
05:55:04 <Workybob> where's dons'?
05:55:11 <drdozer>     Couldn't match expected type `i -> m (SelfId i)'
05:55:12 <drdozer>            against inferred type `NodeGen
05:55:12 <drdozer>                                     (Node (BaseNet (SelfId Int) (SelfId (Int, Int))))'
05:55:29 <Axman6> Workybob: donsbot.wordpress.com
05:55:40 <drdozer> I'd like something like :t that lets me reduce that NodeGen expression step by step
05:55:55 <drdozer> to see exactly why it doesn't match what I expect it to
05:59:42 <Axman6> i need a better name for my blog :(
05:59:59 <Twey> What is it?
06:00:08 <Axman6> unsafeReadAxman’sBlog
06:00:15 <Twey> Yeah
06:00:18 <Twey> Needs work :)
06:00:21 <Axman6> indeed
06:00:27 <Axman6> it's just a place holder for now
06:00:34 <earthy> unsafeWriteDrivel? :P
06:00:37 <Twey> Haha
06:00:47 <Axman6> heh, sounds appropriate :P
06:01:00 <Twey> You're competing against the Monad.Reader and (Bloggable a) => a -> IO ()
06:01:16 <Twey> Going to have to up your game a bit :-P
06:02:23 <vixey> but one thing is not clear to me
06:02:41 <vixey> is  Z, S, Nothing, Just, etc... /values/ or are they neutral terms?
06:03:16 <vixey> and what about Nat, Maybe, ?
06:03:30 <Cale> vixey: Context? I would normally think of data constructors as values.
06:03:30 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:03:55 <vixey> Cale, in this semantic representation
06:04:02 <vixey> for just lambda it can be like
06:04:09 <vixey> data D = Lam (D -> D) | Neutral N
06:04:19 <vixey> data N = NApp N D | Var Int
06:05:11 <Cale> hmm...
06:06:12 <Philippa_> vixey: what do you mean by "neutral value"?
06:06:27 <Philippa_> oh, my bad, you wrote "neutral term"
06:06:41 * Axman6 is wondering htf http://conal.net/blog/posts/lazier-function-definitions-by-merging-partial-values/ ended up being a referring site to his blog
06:06:42 <vixey> N is stuck applications or unknown values basically
06:06:59 <h0tzenpl0tz> lilac: foldr flippedF z (x:xs) f (foldr flippedF z xs) x
06:07:00 <vixey> so something like  case x of ...   would be neutral as well, because you don't know which constructor 'x' is yet
06:07:07 <h0tzenpl0tz> thats the cause for infinity?
06:07:16 <vixey> (and function application is basically projection out of a infinite case)
06:07:20 <mattam> vixey: They're neutral. They don't involve redexes.
06:07:46 <Philippa_> OTOH, a fully-applied constructor should be a value if you have any such concept
06:08:03 <mattam> I don't think case would be.
06:08:12 <Philippa_> "fully-applied" being the result of reducing all of those applications
06:08:37 <vixey> case Nothing of Nothing -> x; Just y -> z  in the semantic domain is equal to  x
06:08:56 <Philippa_> strictly speaking you don't lose any expressive power by insisting that constructors always be fully-applied at the call site
06:09:33 <quicksilver>  /me wonders what GHC does
06:09:35 <vixey> Philippa_, yes infact I really want everything fully applied, so that I get eta long normal
06:09:52 * Axman6 resists patronising quicksilver 
06:10:03 <Philippa_> quicksilver: at which level?
06:10:23 <Philippa_> IIRC, STG does the fully-applied constructor thing. I forget whether Core does
06:10:30 <quicksilver> Philippa_: I wonder if it turns a constructor into a simple thunk like it would a normal function, or if it full-applies at the call site
06:10:33 * quicksilver nods
06:11:01 <quicksilver> I don't think you can tell the difference in Core
06:11:08 <quicksilver> I think you'd see (f a b) and (F a b)
06:11:45 <vixey> .. forms
06:11:48 <h0tzenpl0tz> @src foldl
06:11:48 <lambdabot> foldl f z []     = z
06:11:48 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:11:53 <mattam> Hmm, vixey you're right case is neutral. Nat, Maybe and constructors are normal forms. Probably data D = .. | Constr c [D]
06:12:38 <vixey> mattam, ok so Pi, Type, Prop also go in D (rather than N), I think that all works out pretty much fine
06:13:51 <mattam> Yes? Well good for us :)
06:14:12 <vixey> I usually think that until I try writing the actual  program out ..
06:14:32 <mattam> Hehe, that's my crap test too.
06:14:49 <dublpaws> is (++)  O(n)?
06:15:00 <Workybob> dublpaws: in the left hand argument, yes
06:15:12 <dublpaws> thanks Workybob
06:15:14 <vixey> dublpaws, head (xs ++ ys) is O(1)
06:15:33 <vixey> oops that's a lie I guess
06:15:41 <vixey> but head ((x:xs) ++ ys) is O(1)
06:16:00 <Workybob> no, it's not a lie – it's just that the application of ++ is never actually evaluated
06:16:20 <Workybob> complexity is hard to see in a lazy language
06:19:57 <vixey> actually is there a very quick way to find the kind of a type?
06:20:03 <vixey> (as opposed to the type of a term)
06:20:23 <quicksilver> simple case of the same algorithm
06:20:36 <Workybob> vixey: :kind in ghci
06:20:39 <quicksilver> very simple case in the case of STLC
06:20:47 <Workybob> Prelude> :kind Maybe
06:20:47 <Workybob> Maybe :: * -> *
06:20:49 <quicksilver> not quite so simple in more complex setups.
06:22:09 <vixey> if you have some big long type constructor application  F a b c d e ...,  there may be a change it's got stuck?
06:22:11 <Workybob> "we will restore science to its rightful place"
06:22:14 <Workybob> that sounds encouraging
06:22:19 <vixey> so you can't tell if it's * or [] or anything
06:24:53 <vixey> (\t -> case t of Z -> True ; S _ -> Bool) x
06:25:20 <Axman6> Bool?
06:25:28 <vixey> :k Bool
06:25:29 <lambdabot> *
06:25:32 <vixey> where as True :: []
06:25:33 <vixey> as an example
06:25:44 <Axman6> ah\
06:25:54 * Axman6 hasn't been following along
06:26:33 <vixey> how do you check like
06:26:36 * ksf wants to pass a newtype constructor to a default class definition so he dosen't have to repeat code
06:26:40 <vixey> True :: (\t -> case t of Z -> True ; S _ -> Bool) x
06:26:50 <vixey> it seems impossible
06:27:49 <vixey> it's a bad example.
06:29:29 <drdozer> are there some unfortunate interactions between type synonyms and indexed types?
06:29:38 <Surma> Hey guys, one quick question. If I write a faculty-function, will haskell recalculate the result everytime or will it be cached somehow (for the sake of functional programming)?
06:29:59 <Axman6> what do you mean?
06:30:01 <int-e> it's "factorial" in english
06:30:13 <drdozer> Surma: it depends on the context
06:30:47 <Surma> int-e: damn, so I guess that gave away that I'm german ;-)
06:30:56 <drdozer> Surma: the compiler will only avoid re-calculations in the same scope, so if you call it via different execution paths, it probably won't realise the function is being invoked with the same values
06:31:08 <mattam> vixey: it's impossible to distinguish statically if you have cumulativity. If you witness it or simply disallow it.
06:31:18 <mattam> ... it works.
06:31:48 <Surma> drdozer: so, I know the function will only be called with a argument within [0..9], how could I prevent from recalculating all the time (besides from hardcoding the results)?
06:32:16 <drdozer> Surma: build a list of (i, f i) pairs and use a lookup?
06:32:16 <vixey> mattam, disallow any neutral types?
06:32:18 <mattam> There's not only True/Bool but also type variables which could be instantiated with True or Bool.
06:33:03 <drdozer> Surma: each 'f i' will be lazy in the list, so will get calculated on the first time it is accessed
06:33:14 <mattam> I mean disallow the possibility of having two sorts having the same sort as in Prop/Set and Type.
06:33:19 <quicksilver> drdozer: there are some bad interactions between type synonyms and good error messages. Or did you mean something more profound?
06:33:52 <drdozer> quicksilver: I keep finding myself with type synonyms which are over indexed type expressions where they don't unify and I really think they shuold
06:34:21 <quicksilver> drdozer: associated type synonyms often need manual annotation.
06:34:35 <Axman6> ?users
06:34:36 <lambdabot> Maximum users seen in #haskell: 642, currently: 608 (94.7%), active: 18 (3.0%)
06:34:42 <quicksilver> drdozer: because the compiler realy can't tell which instance you're trying to use.
06:34:56 <mattam> vixey: In Agda's setting for example, I expect it is easy to find out the kind of a type.
06:34:57 <vixey> mattam, ah, Coq says could not "match two with 0 => Prop | S _ => Set end" which should be Set, Prop or Type, in that case
06:35:00 <Peaker> is the maximum stored persistently?
06:35:05 <Peaker> or does lambdabot forget it each time?
06:35:09 <drdozer> quicksilver: I can't find anything in ghci to let me manually 'unwrap'  type synonyms, to get a better idea what is going on
06:35:15 <quicksilver> drdozer: suppose class C a where type F a.
06:35:15 <Axman6> think it forgets it
06:35:35 <quicksilver> drdozer: and suppose instance C A where F = []; instance C D where F = [];
06:35:55 <quicksilver> drdozer: if the compiler finds [] in a context where it is expecting something of the form "F a"
06:36:04 <quicksilver> drdozer: it has no way of knowing which instance to choose.
06:36:08 <quicksilver> drdozer: did that make sense?
06:36:08 <mattam> vixey: Check (fun x : bool => if x then Prop else Set).
06:36:28 <vixey> bool -> Type
06:36:29 <quicksilver> drdozer: you'd have to manually annotate ([] :: C A), I believe.
06:36:47 <quicksilver> drdozer: this is all just my understanding of the theory, I've never actually used it, so apologies if I'm mistaken.
06:37:00 <vixey> this is strong-strong elimination?
06:37:21 <drdozer> quicksilver: yeah, it does, and it looks similar to my problem
06:37:48 <quicksilver> drdozer: even if you know there is only one instance possible, the compiler doesn't (classes are open etc)
06:37:51 <drdozer> quicksilver: but I really think it /should/ have enough info to hand in my particular case
06:38:02 <drdozer> e.g. it knows the 'A' in play
06:38:22 <quicksilver> drdozer: post to glasgow-haskell-users for true enlightenment :)
06:38:25 <drdozer> haha
06:38:33 <mattam> vixey: You'd use such a definition in a strong elimination I think.
06:38:38 <drdozer> anyway, is there a command that will let me resolve String to [Char]?
06:38:53 <Axman6> it is [Char]
06:39:33 <drdozer> sure - but in ghci, I want to type something like :t String and have it print out [Char]
06:39:36 <quicksilver> drdozer: (:i String)
06:39:41 <int-e> Surma: There are many ways to achieve memoization; see http://haskell.org/haskellwiki/Memoization for examples. The basic idea is to turn construct from a function (a -> b) a suitable lookup table, like  Map a b, Array a b, or a suitable Trie data structure which contains the results, and then replace calls to f by lookups into that "table".
06:39:53 <mattam> Check (fun x : bool => if x return if x then Prop else Set then True else Empty_set).
06:39:59 <Axman6> @hoogle showChar
06:40:00 <lambdabot> Prelude showChar :: Char -> ShowS
06:40:00 <lambdabot> Text.Show showChar :: Char -> ShowS
06:40:16 <Axman6> > show . map showChar $ "hello"
06:40:17 <lambdabot>       Overlapping instances for Show (String -> String)
06:40:17 <lambdabot>        arising from a...
06:40:32 <Axman6> > map showChar $ "hello"
06:40:33 <lambdabot>       Overlapping instances for Show (String -> String)
06:40:33 <lambdabot>        arising from a...
06:40:46 <mattam> vixey: Funny syntactical ambiguity here :)
06:40:48 <Axman6> > map showChar "hello" $ "
06:40:49 <Axman6> > map showChar "hello" $ ""
06:40:49 <lambdabot>   <no location info>:
06:40:49 <lambdabot>      lexical error in string/character literal at chara...
06:40:50 <lambdabot>   Couldn't match expected type `a -> b'
06:40:58 <Axman6> bah
06:41:07 <vixey> mattam, it's interesting.. it seems that it doesn't really cause a problem
06:41:28 <vixey> one just has to be careful of course
06:41:57 <Axman6> :t flip showChar ""
06:41:59 <lambdabot> Char -> String
06:42:18 <Axman6> > map (flip showChar "") $ "hello"
06:42:19 <lambdabot>   ["h","e","l","l","o"]
06:42:42 <Axman6> > map show "hello"
06:42:44 <lambdabot>   ["'h'","'e'","'l'","'l'","'o'"]
06:42:47 <SKuhn> whats the difference between newtype and class in haskell?
06:43:03 <mattam> vixey: you mean the sort hierarchy doesn't cause a problem?
06:43:05 <drdozer> quicksilver, not quite what I meant :)
06:43:07 <Zao> One defines a distinct alternate name for a type while a class is a type class.
06:43:08 <Axman6> > concatMap show "hello"
06:43:09 <lambdabot>   "'h''e''l''l''o'"
06:43:20 <vixey> mattam, it doesn't seem to.. but does it?
06:43:49 <SKuhn> Zao: I thought an alternative name is done by type
06:43:56 <vixey> I would implement Type:Type first, then add a gensym to the monad and see if it breaks
06:44:11 <vixey> (to go from Type:Type to Type[i]:Type[j] (i<j)
06:44:39 <Zao> SKuhn: It's the same type, but can't be matched with the old name.
06:44:53 <Zao> SKuhn: Or something like that. I defer a proper explanation to someone who actually knows what they're talking about.
06:45:02 <drdozer> quicksilver, I have a 'problem' type NodeGen (Node (SelfId (Int, Int)))
06:45:05 <quicksilver> drdozer: did you consider using associated data instead of associated synonym?
06:45:13 <quicksilver> drdozer: that removes some of the problem. Sometimes.
06:45:44 <drdozer> NodeGen is a type synonym, Node is an associated synonym and SelfID is a data type
06:46:21 <drdozer> so I really want to be able to re-write this expanding NodeGen out
06:46:22 <SKuhn> hmm, is strict (!) against lazy eval the same strict for a f bottom = bottom ?
06:46:39 <SKuhn> are they related?
06:46:40 <drdozer> and resolving Node to a type, if it can do that
06:47:47 <quicksilver> drdozer: hmm. Well :i NodeGen will help you expand NodeGen
06:47:57 <mattam> vixey: seems alright indeed. But your question was if one could determine the sort of a times any more easily than the type of a term and I think the answer is that it is as difficult.
06:48:00 <quicksilver> but I'm not sure about the others.
06:48:11 <quicksilver> it's easier to work with the terms.
06:48:11 <drdozer> quicksilver, yeah - but I would have to expand it in my head rather than have ghci re-write it for me
06:48:39 <vixey> mattam, aw.. that makes proof irrelevance a bit tricky to do (my way)
06:48:53 <quicksilver> drdozer: do you have terms you can work with?
06:49:00 <quicksilver> drdozer: subterms of the expression that won't check, for example.
06:49:26 <vixey> I was thinking about a rule like, G |- T : [] ==> G |- n = n' : T,  (n and n' being neutral terms)
06:49:55 <mattam> Yes.
06:51:02 <vixey> grmble
06:51:09 <vixey> :)
06:51:14 <vixey> I don't know how to do pi
06:52:22 <mattam> My idea was that it was possible during evaluation to replace any subterm of sort Prop by an ε.
06:53:14 <drdozer> quicksilver, well not really - the problem is buried in a larger function
06:53:40 <mattam> vixey: we are way OT here :)
06:53:45 <vixey> yeah
06:53:47 <drdozer> quicksilver, I'm now trying to make an expression of type (NodeGen (SelfId Int)) directly
06:54:31 <vixey> I like this idea with ε but I can't really see it yet
06:54:33 <Surma> guys, I'm trying to add the sum of the factorials of each digit of a number, I used this:  sum $ map (fac.read) (show n)
06:54:33 <Surma> however, read fails, because it somehow needs a type. How can I solve this
06:54:54 <vixey> Surma, just don't use read
06:55:11 <vixey> Surma, instead something that takes a digit Char, into a Integer or whatever fac took
06:55:23 <vixey> > digitToInt '3'
06:55:24 <lambdabot>   3
06:56:44 <vixey> mattam, maybe extraction like that could work with some flow analysis
06:56:51 <vixey> (for the full CIC)
06:57:13 <fasta> Hi, why does getStdGen return the same when called over and over again in ghci?
06:57:16 <vixey> it would be an approximation though..
06:57:34 <fasta> When I reload the current module I get a different value, so it seems broken behaviour.
06:58:09 <Axman6> fasta: i believe ghci caches results
06:58:32 <fasta> Axman6: it should not cache launchNuclearMissile
06:58:35 <cnwdup> How to round to e.g. 3 digits after the comma?
06:58:38 <pk> @type newStdGen
06:58:39 <lambdabot> IO StdGen
06:58:43 <Axman6> sure it should
06:58:48 <pk> that will do the tricks
06:58:52 <quicksilver> Axman6: you are wrong.
06:58:58 <fasta> pk: thanks
06:58:58 <quicksilver> fasta: why would it not return the same result?
06:59:07 <Axman6> quicksilver: that was harsh :(
06:59:10 <Axman6> jokes
06:59:16 <quicksilver> if you use randomIO or a related funciton
06:59:19 <Axman6> :t genStdGen
06:59:21 <lambdabot> Not in scope: `genStdGen'
06:59:27 <quicksilver> then next time you call getStdGen you'll find it's different
06:59:37 <quicksilver> since randomIO uses this 'global' generator.
06:59:37 <mattam> vixey: Coquand claims that their NbE technique allows to deal with pi and more generaly any singleton types. Don't they discuss that in the paper?
06:59:47 <quicksilver> Axman6: you can take it :)
07:00:05 <vixey> mattam, I don't think so (other than saying it extends easily to pi), even in the extended version
07:00:11 <quicksilver> Axman6: sometimes its better to quash misinformation quickly, and I assume a regular can cope with the punishment :)
07:00:26 <quicksilver> ghci would be pretty useful for IO if it cached the results of IO actions.
07:00:28 <Axman6> aye
07:00:32 <quicksilver> useless :)
07:00:47 <mattam> vixey: ok.
07:00:49 <vixey> mattam, but I'm not sure which method they intend to use for pi actually
07:00:55 <fasta> quicksilver: because I was expecting that it did new*.
07:01:10 <quicksilver> fasta: ah, right
07:01:21 <quicksilver> fasta: no, getStdGen is a window into the "global" stdGen
07:01:30 <quicksilver> fasta: which is used for the randomIO family of functions.
07:01:38 <Axman6> ah, learn something new every day :)
07:01:39 <quicksilver> it's seeded at startup
07:02:17 <dolio> fasta: Use newStdGen, instead.
07:02:28 <dolio> If you want it to change the global generator.
07:02:31 <fasta> dolio: I already did, since pk told me :)
07:02:37 <dolio> Ah, missed it.
07:03:12 <Axman6> hmm, should consequtive calls to newStdGen produce very similar ... first values? (for lack of a better word)
07:03:33 <Axman6> 1622192704, 1622232718, 1622272732...
07:03:54 <Itkovian> A long time ago, we had a chat on this channel about Haskell benchmarks. Now that the adoption is growing, maybe it is time to ask that question again. Given the impending arrivel of the Haskell platform, I think the community has need of decent (read: also large) benchmarks (that run for over 1 minute on current platforms) for both serial and parallel executions. I am wondering if any of you agree with me on this.
07:03:57 <quicksilver> Axman6: the builtin generator is not very good :(
07:04:02 <Axman6> > 1622192704 - 1622232718 -- 1622272732...
07:04:03 <lambdabot>   -40014
07:04:05 <dolio> newStdGen is just do g <- getStdGen ; let (g',g'') = split g ; setStdGen g' ; return g''
07:04:32 <dolio> Or something along those lines. I'm not sure about the names.
07:04:57 <daf> I thought the problem was the split is not very good
07:05:06 <quicksilver> I think so, yes.
07:05:27 <drdozer> quicksilver, I found the error in the end - in the instance declaration for SelfId (i, i)
07:06:00 <Axman6> quicksilver: is dons' Mersenne twister much better?
07:06:03 <quicksilver> drdozer: yay :)
07:06:06 <quicksilver> Axman6: I believe it is.
07:06:12 <Axman6> supposed to me somehing like hindreds of times faster...
07:06:18 <Axman6> bleh, typing fail
07:06:24 <quicksilver> and a far far bigger state space, too
07:06:28 <dolio> > let (g, g') = split (mkStdGen 5) in (random g, random g') :: (Int, Int)
07:06:29 <lambdabot>   Couldn't match expected type `Int'
07:06:47 <drdozer> quicksilver, but could have found it much faster if I could have asked ghci to reduce indexed type synonyms automatically :(
07:06:49 <dolio> > let (g, g') = split (mkStdGen 5) in (fst $ random g, fst $ random g') :: (Int, Int)
07:06:50 <lambdabot>   (6370373534070567458,-8557902930446107603)
07:07:00 <quicksilver> drdozer: make an enhancement proposal to g-h-u
07:07:06 <drdozer> kk, will do
07:07:08 <quicksilver> drdozer: or as a track ticket
07:07:57 <dolio> > let (g, g') = split (mkStdGen 5) in (fst $ random g, fst $ random g') :: (Int32, Int32)
07:07:58 <lambdabot>       No instance for (Random Int32)
07:07:58 <lambdabot>        arising from a use of `random' at...
07:08:03 <maltem> Axman6: btw I've been convinced by now that writing randomizing code in MonadRandom is superior to using System.Random because MonadRandom code is easier to adapt to different random libraries
07:08:20 * quicksilver agrees with maltem.
07:08:33 <quicksilver> although MonadRandom doesn't expose its use of a RandomGen
07:08:39 <quicksilver> which is annoying for some algorithms.
07:08:42 <Axman6> i'm not really familliar with MonadRandom (yet)
07:08:46 <dolio> System.Random is extremely slow, as well.
07:19:11 <hugo___> ohh
07:20:25 <hugo___> i have two data types "data A = S String" and "data B = S String", why does haskell complain about having hambiguous constructor ? shouldn't it understand how to desambiguate from the function signature ?
07:21:05 <pk> given a hipmunk joint, is there a way to retrieve the bodies attached to it ?
07:21:08 <vixey> hugo___, what's the type of f in  f (S x) = x ?
07:21:15 <Baughn> Ah, does HsOpenSSL compile on 10.1? Hackage says it does, but it's failing here..
07:21:28 <hugo___> vixey: according to the signature is f :: A -> String
07:21:39 <vixey> hugo___, what signature?
07:21:45 <hugo___> the one i specified :P
07:22:00 <hugo___> for some reason i specify signatures
07:22:05 <rwbarton> hugo___: no, it doesn't work that way
07:22:08 <vixey> hugo___, I don't
07:22:20 <rwbarton> hugo___: just give your constructors different names
07:22:22 <hugo___> well, im starting to think that i shouldn't too
07:22:38 <hugo___> argghh :(
07:22:49 <vixey> or  type B = A
07:22:57 <maltem> hugo: writing type signatures is a good thing in general
07:22:57 <hugo___> i feel the need to file a bug report in ghc
07:23:05 <vixey> this isn't a bug
07:23:10 <hugo___> isn't it ?!
07:23:11 <vixey> maltem, I don't really agree
07:23:13 <hugo___> how come it isn't ?
07:23:16 <vixey> but most people do it
07:23:21 <rwbarton> hugo___: this makes about as much sense as "I can't use an Int as a Double"
07:23:35 <rwbarton> hugo___: it is seriously very clearly a feature and not a bug
07:23:52 <hugo___> rwbarton, a feature ? like a "handicap feature" ?
07:24:23 <rwbarton> hugo___: no, you just haven't considered the ramifications of what you suggest
07:24:29 <hugo___> i'm finding it really hard to understand :/
07:24:36 <maltem> vixey: I suppose that's because most people find it useful, too
07:25:03 <hugo___> data A = S String, and data B = S String should be used, and i'm finding it very hard to find a reason not to...
07:25:13 <hugo___> specially since signatures are involved
07:25:25 <hugo___> offcourse, if you dont want to write down the sigs, then just use diff constructors
07:25:48 <hugo___> but my case is that i want to write them in order to help the compiler in these situations
07:25:55 <rwbarton> hugo___: you can do something like what you want using type classes
07:26:04 <hugo___> bahh
07:26:05 <fasta> What's the name of a program to render a piece of text in ASCII?
07:26:12 <maltem> hugo: the point is that Haskell doesn't allow one function (S) with different types (String -> A, String -> B)
07:26:16 <rwbarton> hugo___: but otherwise every expression has to have a principle type
07:26:24 <rwbarton> hugo___: like S, for example, or vixey's f (S x) = x
07:26:33 <dolio> Agda actually lets you use the same name for constructors of multiple types. But that only works (I imagine) since you absolutely have to give top-level type annotations anyway.
07:26:49 <hugo___> okey
07:26:50 <ksf> http://picfront.de/d/UNfMt2xeXq/agar.png
07:27:00 <hugo___> in my mind i'm totally not convinced
07:27:07 <hugo___> ...but i will swallow it
07:27:35 <hugo___> because im a noob at this, but it clearly doesn't make any sense...
07:27:38 <rwbarton> type classes exist, if you want to do this kind of ad-hoc overloading
07:27:59 <maltem> With type classes it wouldn't be ad-hoc anymore :)
07:28:02 <rwbarton> I'm as puzzled that you think it should be possible as you are that it isn't possible. :)
07:28:02 <hugo___> but this isn't overloading, it is just desambiguation
07:28:05 <vixey> maltem, I think it's just a habit people get into because tutorials and that tell you to do it
07:28:45 <rwbarton> hugo___: it is precisely overloading, you have one name S that you want to give to two different values of different types (the constructors of A and B)
07:29:05 <cnwdup> > printf "%.2f\n" pi
07:29:07 <lambdabot>   Add a type signature
07:29:14 <cnwdup> > (printf "%.2f\n" pi) :: IO ()
07:29:16 <lambdabot>   * Exception: "<IO ()>"
07:29:18 <vixey> > ""++ printf "%.2f\n" pi
07:29:19 <lambdabot>   "3.14\n"
07:29:23 <quicksilver> hugo___: terms in haskell shoud, in general, have principle types.
07:29:24 <vixey> > printf "%.2f\n" pi :: String
07:29:25 <lambdabot>   "3.14\n"
07:29:31 <quicksilver> hugo___: what would be the type of "S" in your example?
07:29:32 <maltem> hugo: you also have the option of putting A and B into different modules
07:29:36 <quicksilver> (constructors are functions)
07:29:38 <hugo___> quicksilver: you said it right "in general"
07:29:40 <cnwdup> > printf "%.2f\n" (1 % 10) :: String
07:29:41 <lambdabot>       No instance for (PrintfArg (Ratio t))
07:29:41 <lambdabot>        arising from a use of `pri...
07:29:54 <cnwdup> How to convert Ratio Int to Floating a => a?
07:29:57 <cnwdup> :t pi
07:29:58 <lambdabot> forall a. (Floating a) => a
07:30:01 <hugo___> quicksilver: it would depend on the function signature
07:30:05 <dolio> @type fromRational
07:30:06 <lambdabot> forall a. (Fractional a) => Rational -> a
07:30:06 <hugo___> oh well, back to code...
07:30:14 <quicksilver> hugo___: there is no function signature here.
07:30:15 <vixey> hugo___, what if you don't have a signature
07:30:16 <cnwdup> > printf "%.2f\n" (fromRational $ 1 % 10) :: String
07:30:17 <lambdabot>   "0.10\n"
07:30:18 <quicksilver> hugo___: "S" is a term
07:30:23 <quicksilver> hugo___: no signature in sight.
07:30:29 <Axman6> cnwdup: toFloating (a % b) = a / fromIntegral b?
07:30:38 <cnwdup> dolio: Thanks. Now I just have to find out why it's not working in actual code. (-:
07:30:39 <quicksilver> hugo___: it may be buried deeply within a function and used multiple times.
07:30:45 <maltem> vixey: ok then it's the tutorial writers who agree that it's useful :P
07:30:47 <quicksilver> cnwdup: realToFrac
07:31:01 <quicksilver> cnwdup: doesn't quite have the type you asked for but it's probably what you want.
07:31:16 <cnwdup> I'll check that. Thanks. (-:
07:31:22 <quicksilver> > realToFrac (3%5)
07:31:23 <lambdabot>   0.6
07:31:26 <hugo___> but if im calling S inside a function that is expecting datatype A, then it should be easy to see...
07:31:34 <vixey> hugo___, repeat:  what if you don't have a signature
07:31:43 <quicksilver> hugo___: that's what type classes are for.
07:31:48 <sw17ch> has any one tried to generate C code for a Linux kernel module with Haskell?
07:31:53 <sw17ch> DSL style or similar?
07:31:55 <hugo___> vixey: then an error is produce, just like it normaly is for these kind of situations
07:31:56 <cnwdup> > realToFrac 7129%25200
07:31:57 <lambdabot>   Add a type signature
07:31:57 <quicksilver> hugo___: to choose from a variety of possible types based on the type of the context.
07:32:17 <cnwdup> > realToFrac (7129%25200)
07:32:17 <vixey> hugo___, you just invented type classes
07:32:17 <gwern> moore's law is every 18 months, right?
07:32:17 <ztirF> does there exist a tutorial for syb?  kind of a gentler introduction than the hackage page?
07:32:17 <rwbarton> > realToFrac (7129%25200)
07:32:21 <lambdabot>   0.2828968253968254
07:32:21 <lambdabot>   0.2828968253968254
07:32:23 <gwern> > (8 * 12) / 18
07:32:24 <lambdabot>   5.333333333333333
07:32:25 <rwbarton> cnwdup: Ratio Int is a pretty bad type
07:32:38 <rwbarton> cnwdup: in that the Int can overflow very easily
07:32:40 <hugo___> quicksilver: then why can i, in general, leave out the functions signatures ?
07:33:09 <hugo___> it doesn't make much sense, it it works one way, why doesn't it work the other way if its plainly possible to ?
07:33:11 <cnwdup> rwbarton: Yep. Its just a throw away program for testing. So I guess it's okay. (-: I should never exceed 10! max.
07:33:43 <rwbarton> > (1%3000000) + (7%3000000) :: Ratio Int
07:33:44 <lambdabot>   1%375000
07:33:54 <rwbarton> , (1%3000000) + (7%3000000) :: Ratio Int
07:33:55 <lunabot>  luna: Not in scope: type constructor or class `Ratio'
07:34:08 <dolio> You can get overflows without having large numbers.
07:34:15 <quicksilver> hugo___: because that's what they decided to do.
07:34:25 <cnwdup> dolio: How's that? Oo
07:34:26 <quicksilver> hugo___: because terms having a principle type is a desirable property.
07:34:30 <dolio> Because asking for precise numbers can lead to overflows, as well.
07:34:43 <hugo___> and it has a principle type
07:34:47 <hugo___> that is not in question
07:34:51 <quicksilver> hugo___: no, it doesn't.
07:34:57 <dolio> > 1.1 :: Ratio Int
07:34:57 <lambdabot>   11%10
07:34:57 <quicksilver> hugo___: what is the principle type of "S" in your exmaple ?
07:35:01 <hugo___> the principle type is dependeble on the function signature, thats just it
07:35:02 <dolio> > 1.000000000000000000001 :: Ratio Int
07:35:03 <lambdabot>   3875820019684212737%3875820019684212736
07:35:09 <dolio> > 1.000000000000000000000000000000001 :: Ratio Int
07:35:10 <lambdabot>   4089650035136921601%4089650035136921600
07:35:15 <Saizan> ztirF: the Scrap Your Boilerplate papers
07:35:18 <quicksilver> hugo___: that's not what principal means.
07:35:20 <hugo___> quicksilver: it depends on the function signature
07:35:22 <dolio> > 1.000000000000000000000000000000001 :: Rational
07:35:23 <lambdabot>   1000000000000000000000000000000001%1000000000000000000000000000000000
07:35:25 <quicksilver> hugo___: principal type is a property of the term "S"
07:35:28 <quicksilver> hugo___: REGARDLESS of context.
07:35:34 <quicksilver> hugo___: that is what the terminology means
07:35:44 <ztirF> Saizan: k, thanks, I'll look them up
07:35:48 <quicksilver> hugo___: it is the answer you get if you type ":t S" in ghci
07:35:57 <quicksilver> there is no context and no signature.
07:36:01 <hugo___> ok
07:36:04 <hugo___> i get it
07:36:26 <quicksilver> with apologies for my persistent mis-spelling of principal ;)
07:36:29 <hugo___> what if i import the module where the type is defined as a qualified import ?
07:36:41 * rwbarton thinks he started the misspelling
07:36:44 <quicksilver> then the term "Foo.S" has a principal type.
07:36:51 <hugo___> ok
07:36:58 <quicksilver> and "S" is simply a symbol-not-in-scope error.
07:37:03 <quicksilver> (unless you have another S from somewhere else)
07:37:11 <rwbarton> > (4999999%10000000) + (5000001%10000000) :: Ratio Int32
07:37:13 <lambdabot>   1%1
07:37:14 <hugo___> ok
07:37:17 <hugo___> thanks
07:37:17 <rwbarton> argh
07:37:24 <quicksilver> it's not necessary to have the principal type property.
07:37:27 <dolio> :)
07:37:31 <quicksilver> but there are non-trival reasons to like it.
07:37:51 <quicksilver> haskell doesn't have it, in fact, but it delegates all the parts which don't have it into the bin called 'type classes'
07:38:04 <rwbarton> > (2999999%10000000) + (3000001%10000000) :: Ratio Int32
07:38:06 <lambdabot>   (-42305)%16873
07:38:11 <rwbarton> there. Should be 3%5
07:38:35 <hugo___> ok
07:39:23 <hugo___> i really must use this more, so i can clearly sense when to use a type class, or when to use constructors with diff names
07:40:16 <quicksilver> always use constructors with different names.
07:40:20 <hugo___> btw, i know this is not haskell related, but i recently found out this presentation that paul graham did: http://itc.conversationsnetwork.org/shows/detail188.html
07:40:22 <dolio> > 1%2 + 2%3 + 3%5 + 5%7 + 7%11 + 11%13 + 13%17 + 17%19 + 19%23 + 23%29 :: Ratio Int32
07:40:23 <lambdabot>   (-390455553)%(-2120241362)
07:40:27 <quicksilver> never use type classes.
07:40:30 <quicksilver> easy :)
07:40:34 <hugo___> okey
07:40:35 <hugo___> :D
07:40:42 <rwbarton> > (-3)%(-5)
07:40:43 <lambdabot>   3%5
07:40:55 <ksf> hugo___, if in doubt, use an ADT.
07:41:01 <hugo___> ADT ?
07:41:03 <ksf> if it doesn't work, think harder.
07:41:12 <ksf> failing that, try to avoid typeclasses.
07:41:16 <ksf> failing that, give in.
07:41:20 <hugo___> hehe
07:41:30 <rwbarton> > (-390455553)%(-2120241362) == (1%2 + 2%3 + 3%5 + 5%7 + 7%11 + 11%13 + 13%17 + 17%19 + 19%23 + 23%29 :: Ratio Int32)
07:41:31 <lambdabot>   False
07:41:38 <rwbarton> Ratio Int is just evil
07:41:48 <hugo___> my usual approach is: try what i think is logical, failing that, go bother the guys at #haskell :P
07:42:07 <ksf> abstract data type. it's a haskellism for an enum on steroid, that is, a data declaration.
07:42:20 <hugo___> ah
07:42:21 <dolio> Oh, that's another thing you can get overflows from, equality.
07:42:23 <hugo___> allright :)
07:42:41 <hugo___> i ordered the okasaki book from amazon
07:42:51 <hugo___> i think it might help me, along with a lot of experimentation
07:42:53 <dolio> Since I imagine (a%b) == (c%d) = a*d == b*c
07:43:03 <ksf> @where rwh
07:43:04 <lambdabot> is http://www.realworldhaskell.org/blog/
07:43:36 <hugo___> :)
07:43:37 <rwbarton> dolio: <=, certainly, it might try to keep the :% constructor arguments reduced
07:43:48 <hugo___> i also ordered rwh
07:44:00 <rwbarton> dolio: yeah, "data Ratio = ... deriving (Eq)"
07:44:36 <dolio> Oh, that's true.
07:44:38 <quicksilver> Ratio does try to keep itself reduce, I believe.
07:44:56 <rwbarton> I wonder if (+) on Ratio Int is even associative
07:44:59 <dolio> I guess the problem is that normalization isn't happening after overflow. :)
07:45:03 <rwbarton> right
07:45:10 <h0tzenpl0tz> would this be a correct-impl for a Stree ?
07:45:11 <h0tzenpl0tz> mapTree _ Null = Null
07:45:11 <h0tzenpl0tz> mapTree f (Fork l i r) = Fork (mapTree f l) (f i) (mapTree f r)
07:45:26 <h0tzenpl0tz> are maps always structure-preserving?
07:45:35 <vixey> h0tzenpl0tz, yes & yes
07:45:41 <h0tzenpl0tz> vixey: thank you
07:45:51 <dolio> rwbarton: At a guess, I'd say it isn't.
07:47:12 <rwbarton> Oh, it's not associative just because of the overflow/reduction interaction
07:47:25 <dolio> > (2^30 + 1%2) - 1%2 :: Ratio Int32
07:47:26 <lambdabot>   0%1
07:47:34 <dolio> > 2^30 + (1%2 - 1%2) :: Ratio Int32
07:47:35 <lambdabot>   1073741824%1
07:47:42 <rwbarton> QuickCheck told me "*** Failed! Falsifiable (after 2 tests):" :)
07:51:08 <hydo> Hrm... QuickCheck + flymake = dynamic duo...
07:51:20 <sw17ch_> flymake?
07:52:04 <hydo> on the fly syntax checker for emacs.
07:52:27 <hydo> checks syntax by compiling the file, in haskell's case.
07:52:45 <hydo> ugh... more coffee, less apostrophes
07:53:00 <sw17ch_> :)
07:54:35 <roconnor> @seen mattam
07:54:36 <lambdabot> mattam is in #haskell and ##logic. I last heard mattam speak 53m 49s ago.
07:55:17 <mattam> roconnor: ping
07:55:28 <roconnor> mattam: you got my message about my thesis?
07:55:54 <mattam> Yes. I stopped reading it when I was in Nijmegen though :)
07:56:00 <roconnor> no problem
07:56:07 <roconnor> just wanted to make sure you got it
07:56:32 <mattam> I expect to read it this week.
07:57:08 <BMeph> hydo: QuickFly? :)
07:57:53 <sw17ch_> is there a howto for installing GHC 6.10.1 on ubuntu 8.10?
07:58:46 <fasta> sw17ch_: just download the distribution, read the README or INSTALL and done.
07:59:23 <drdozer> :) my program just produced a stack overflow - what's the best way to figure out why?
07:59:38 <drdozer> it should be running in something approximating constant memory
07:59:55 <sw17ch_> alright ;)
08:00:11 <h0tzenpl0tz> what characteristic must two functions have to allow the principle of extensionality?
08:00:13 * sw17ch_ has been spoiled by the gentoo-haskell overlay
08:00:27 <Saizan> drdozer: do you use foldl or equivalently tail recursion with an accumulating parameter?
08:01:06 * roconnor discovered recently that foldl is tail recursion with an accumulating parameter
08:01:20 <roconnor> it was a very exciting discovery
08:01:26 <h0tzenpl0tz> ;))
08:01:59 <Saizan> a common example of it :)
08:02:25 <roconnor> Saizan: I then realized I could write reverse using a foldl
08:02:32 <roconnor> @src foldl
08:02:32 <lambdabot> foldl f z []     = z
08:02:33 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:02:37 <roconnor> @src reverse
08:02:37 <lambdabot> reverse = foldl (flip (:)) []
08:02:46 <roconnor> and lo, it was how it is done
08:03:59 <Saizan> the only known case where foldl is appropriate instead of foldl' ;)
08:04:45 <roconnor> Saizan: oh wow.  I've used it in other places.
08:05:04 <roconnor> hmm
08:05:24 <roconnor> but really only in places where I want to reverse a list
08:05:53 <Saizan> if 'f' is a constructor then it's fine
08:06:06 <gwern> @seen Cale
08:06:07 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 2h 54s ago.
08:06:22 <roconnor> oh hpaste is gone
08:06:24 <drdozer> Saizan: can't see any foldl in play
08:06:38 <Pellwurst> i need a function string->string->bool, which is true only if the first string is a substring of the second....does such a function already exist or do i need to write my own one?
08:06:41 <gwern> @ask Cale any thoughts on converting the lb repo to darcs-2? I'd like hashed patches because the repo is too big to comfortably get
08:06:41 <lambdabot> Consider it noted.
08:06:48 <gwern> Pellwurst: isInfixOf?
08:06:53 <roconnor> Saizan: I had an interesting example with jeffwheeler's pointedList implementation
08:06:55 <gwern> @hoogle String -> String -> Bool
08:06:56 <lambdabot> Distribution.Simple.Utils isInfixOf :: String -> String -> Bool
08:06:56 <lambdabot> System.FilePath.Posix equalFilePath :: FilePath -> FilePath -> Bool
08:06:56 <lambdabot> System.FilePath.Windows equalFilePath :: FilePath -> FilePath -> Bool
08:07:09 <Saizan> @wiki Stack overflow
08:07:10 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
08:07:13 <roconnor> data PointedList a = PointedList [a] a [a]
08:07:20 <gwern> hm, that shouldn't be recommending Distribution.Simple.Utils :)
08:07:27 <gwern> should be Data.List
08:07:29 <Saizan> drdozer: that page is a must to read when dealing with such problems ^^^^
08:07:53 <Saizan> drdozer: then you can also use the ghci debugger to tell where is the problem
08:07:57 <roconnor> Saizan: we defined foldr f z (PointedList ls x rs) = foldl (flip f) (foldr f z (x:rs)) ls
08:08:01 <Pellwurst> gwern: which module contains that function?
08:08:05 <Saizan> @google ghc manual ghi debugger
08:08:08 <lambdabot> No Result Found.
08:08:12 <Saizan> @google ghc manual ghci debugger
08:08:19 <roconnor> Saizan: here f is generic, so I guess foldl' is appropriate
08:08:24 <roconnor> er
08:08:25 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
08:08:25 <lambdabot> Title: 3.5.�The GHCi Debugger
08:08:29 <roconnor> I man I guess foldl is approriate
08:08:36 <roconnor> mean
08:08:40 <gwern> Pellwurst: you probably want 'Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
08:09:04 <gwern> (oh, that's why cabal popped up before data.list - specialized to String)
08:10:22 <Pellwurst> gwern: i can only find the isPrefixOf ant the isSuffixOf functions
08:10:36 <gwern> maybe you're on an old ghc then
08:11:29 <Saizan> roconnor: well if ls is long you're going to create a big thunk, but 'f' should be somewhat lazy to be used in a foldr, so it's probably ok
08:11:59 <roconnor> yep
08:13:48 <roconnor> hmm
08:14:04 <roconnor> @hoogle foldr
08:14:04 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
08:14:04 <lambdabot> Data.ByteString foldr :: (Word8 -> a -> a) -> a -> ByteString -> a
08:14:04 <lambdabot> Data.Foldable foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
08:14:10 <roconnor> ok
08:14:36 <Saizan> using the obvious toList and foldr over it might be better if it gets fused
08:15:50 * Saizan should read the fusion papers one day
08:17:25 <roconnor> Saizan: this foldr is actually Data.Foldable.foldr
08:17:37 <multiholle> hpase doesn't work. where i could paste code?
08:17:39 <roconnor> Saizan: the Data.Foldable.toList is derived from this
08:18:03 <Saizan> @where hpaste2
08:18:04 <lambdabot> http://moonpatio.com:8080/
08:18:09 <Saizan> multiholle ^^
08:18:37 <multiholle> thanks ^^
08:18:44 <roconnor> Saizan: actually I derived this function by simplifying foldr f z (reverse ls ++ [x]++rs) by hand
08:18:59 <roconnor> Saizan: do you think I may have made things works by simplfying by hand?
08:19:13 <multiholle> i want to generate random numbers. why this doesn't work? http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=837#a837
08:19:33 <roconnor> foldr f z (reverse ls ++ x:rs)
08:19:50 <roconnor> foldr f z (foldl (flip (:)) [] ls ++ x:rs)
08:19:58 <roconnor> foldr f z (foldl (flip (:)) (x:rs) ls )
08:20:10 <roconnor> (foldl (flip (f)) (foldr f z (x:rs)) ls )
08:22:01 <Saizan> roconnor: not sure, i was worring that a thunk made with an application of 'f' might use more space than one with (:)
08:22:20 <roconnor> right
08:22:25 <roconnor> hopefully not
08:22:31 <roconnor> or at least not much
08:23:38 <Saizan> ?type randomR
08:23:40 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
08:24:04 <Saizan> multiholle: randomR takes a tuple of the bounds as first parameter
08:24:25 <Saizan> multiholle: btw, there's also randomRs
08:24:52 <Saizan> > let g = (mkStdGen 42) in randomRs (1,6) g
08:24:53 <lambdabot>   [6,4,2,5,3,2,1,6,1,4,4,4,1,3,3,2,6,2,4,1,3,1,1,5,5,5,1,3,6,1,5,6,1,3,5,4,1,...
08:24:55 <mmorrow> dcoutts: just got hackage-server running on my laptop, pretty cool
08:25:23 <multiholle> saizan: how to use newStdGen instead of 42?
08:26:02 <Saizan> multiholle: like you do in ran
08:26:09 <dcoutts_> mmorrow: great! :-)
08:26:21 <rwbarton> can ghc optimize seq a b to b when a is a constructor application?
08:26:27 <h0tzenpl0tz> @src Monad
08:26:28 <lambdabot> class  Monad m  where
08:26:28 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
08:26:28 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
08:26:28 <lambdabot>     return      :: a -> m a
08:26:28 <lambdabot>     fail        :: String -> m a
08:26:32 <dcoutts_> mmorrow: do you have any plans? try out the cabal-install build reporting.
08:27:06 <mmorrow> dcoutts_: i'm totally gonna put it on a server of mine and use it for my "production packages"
08:27:14 <mmorrow> dcoutts_: cool, i'll check that out
08:27:40 <dcoutts_> mmorrow: ok, let me know how that goes, what stuff is missing, eg I think the logging currently isn't great
08:27:51 <dcoutts_> mmorrow: I should get an instance running on code.haskell.org
08:28:09 <mmorrow> dcoutts_: i think has huge potential :)
08:28:36 <mmorrow> *this
08:28:58 <mmorrow> especially with the combo of cabal-install
08:29:02 <Saizan> what's missing wrt the current scripts on hackage.haskell.org?
08:29:25 <rwbarton> or more correctly and generally, optimize seq (C x y z ...) a to seq x . seq z . ... a where x and z are strict fields of C
08:29:27 <mmorrow> replicateM 20 ghc_setup `in` minutes!
08:29:36 <maltem> er... What does $ mean in ghc core? I don't find it mentioned in the paper; is it just part of a name?
08:29:47 <abyss88> hello to all
08:29:49 <abyss88> !!!!
08:29:57 <drdozer> is there a way to run :trace main?
08:30:05 <drdozer> and get command-line args in?
08:30:17 <rwbarton> maltem: yes, I think so.  There seems to be some pattern to which names tend to contain $, but I don't know what it is
08:30:26 <abyss88> could anyuone help me with a transport sales man problem?
08:30:28 <Saizan> drdozer: there's :set args iirc, see :help
08:30:55 <maltem> rwbarton: aha :)
08:31:51 <quicksilver> maltem: there is a longstanding tradition in compiler writers to use $ in generated names
08:31:58 <rwbarton> maltem: dictionaries often get names like $f1, for example
08:32:00 <quicksilver> maltem: I have no idea if there is any history behidn it.
08:32:12 <multiholle> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=838#a838 says: No instance for (Control.Monad.Trans.MonadIO [])
08:32:14 <quicksilver> any interesting history, I mean.
08:32:30 <rwbarton> multiholle: the type of ran is wrong, it should be Int -> IO [Int]
08:33:10 <multiholle> but i want to return a [Int]
08:33:16 <maltem> maybe compiler writers go like, this is generated, it will be ugly, so let's make it look like a shell script :)
08:33:18 <multiholle> i don't want to use IO
08:33:33 <rwbarton> multiholle: but you want random numbers, where do you expect them to come from :)
08:33:48 <multiholle> i thought liftIO will work
08:34:14 <rwbarton> liftIO will work in some other monad that can do IO
08:34:53 <rwbarton> Yeah, so actually the type of ran should be   (MonadIO m) => Int -> m [Int]
08:34:56 <racko> multiholle: Getting Random Numbors from IO means that your function just isn't pure ... the IO [Int] type reflects that
08:34:57 <quicksilver> you don't have to use IO for random numbers.
08:35:04 <quicksilver> just pass in a generator
08:35:21 <quicksilver> StdGen -> Int -> [Int]
08:35:28 <quicksilver> (and pass it back out if you want to use it again)
08:35:44 <multiholle> quicksilver: what do you mean?
08:36:28 <ksf> hmmm... I could try to dlopen() agar multiple times and justle objects around.
08:36:33 <Pellwurst> i have a list of boolean values... how can i check if every value of the list is True....is there a better way than: null (filter (==True) [a])?
08:36:34 <ksf> oops wrong channel
08:36:45 <rwbarton> :t and
08:36:46 <lambdabot> [Bool] -> Bool
08:37:03 <BONUS> also its cool to use any
08:37:07 <BONUS> i mean all
08:37:11 <BONUS> > all (==4) [4,4,4,4,4]
08:37:13 <lambdabot>   True
08:37:35 <Pellwurst> rwbarton: and is perfect, thx
08:38:19 <mmorrow> Saizan: what are your plans for hbuild?
08:39:03 <quicksilver> multiholle: erm. Just what I said. You don't have to use IO for random numbers.
08:39:10 <quicksilver> multiholle: you can use a random number generator instead.
08:39:36 <multiholle> don't i need an initial value?
08:40:05 <drdozer> I'm running :trace main, with the arguments set
08:40:38 <drdozer> it reaches the stack-overflow, but when I type :history, it complains "Empty history. Perhaps you forgot to use :trace?"
08:40:40 <quicksilver> multiholle: yes, you will need to pass in the initial value of the generator
08:40:52 <multiholle> how?
08:40:54 <quicksilver> multiholle: so your type becomes (StdGen -> Int -> [Int])
08:41:04 <Ferdirand> 6
08:41:04 <loadquo> @src (+)
08:41:04 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
08:41:08 <quicksilver> or (StdGen -> Int -> ([Int],StdGen)) if you want to get it back out
08:41:27 <Saizan> drdozer: is the code interpreted? and did you :set -fbreak-on-exception ?
08:41:28 <multiholle> but how to generate the StdGen?
08:42:01 <rwbarton> multiholle: that's the question for you to answer
08:42:22 <multiholle> i used newStdGen, but that's IO :/
08:42:23 <rwbarton> multiholle: either this function will generate its own StdGen, possible a fixed one, or using IO,
08:42:32 <rwbarton> multiholle: or it will be provided by the caller of the function
08:42:40 <doserj> @type mkStdGen
08:42:41 <lambdabot> Int -> StdGen
08:42:51 <quicksilver> multiholle: I normally use "mkStdGen 42"
08:42:57 <quicksilver> but you can choose another number.
08:43:02 <multiholle> usinga fixed value returns always the same numbers :/
08:43:07 <quicksilver> of course this means that every run of my program has the same "Random" numbers
08:43:12 <quicksilver> which is very handy for debugging.
08:43:20 <quicksilver> then when you no longer want that, you get a stdgen from IO
08:43:22 <quicksilver> (in your toplevel)
08:43:23 <dolio> You should choose a truly random seed when you write your program by rolling some dice or something.
08:43:27 <quicksilver> and pass it into the pure code.
08:43:44 <rwbarton> dolio: Roll Nd6, in this case
08:43:57 <quicksilver> main = do g <- newStdGen; print (call pure code using "g")
08:44:35 <drdozer> Saizan: just a minute - I will make a clean session and dump to pastebin
08:44:48 <multiholle> ok thanks, i will try it this way.
08:44:49 <loadquo> @src (***)
08:44:49 <lambdabot> f *** g = first f >>> second g
08:46:43 <drdozer> http://pastebin.com/m57c19875
08:48:45 <Saizan> drdozer: did you touch your Main.hs or removed the .hi/.o files in the directory? the debugger doesn't give information when you run compiled code
08:49:46 <ksf> zomg unix is dead
08:49:49 <ksf> http://www.useit.com/papers/filedeath.html
08:50:46 <drdozer> Saizan: ah - so if I had compiled it with ghc from the command-line, I should nuke those extra files first?
08:52:17 <Saizan> drdozer: yes
08:52:46 <drdozer> :) what a lovely gotcha
08:53:40 <quicksilver> drdozer: there is a way to force it to interpret in recent GHCi
08:53:44 <quicksilver> (but I don't remember what it is)
08:54:30 <hugo___> hmm
08:54:40 <hugo___> im sorry, but, why can't i use a type class as a type ?
08:55:04 <Lemmih> Because they aren't types.
08:55:23 <hugo___> then what does the "type" in "type class" means ?
08:55:51 <elly> it means that it is a class which types are members of
08:55:52 <rwbarton> A type class is not a type just like a dog house is not a dog.
08:55:53 <ksf> you can use them as a constraint though, and crash against a rock made of you trying to be smarter than the type system.
08:56:04 <hugo___> ahah
08:56:05 <hugo___> ok
08:56:48 <hugo___> what if i want a function to get type A and type B ?
08:56:50 <newsham> a class of types is not a type.  a list of ints is not an int.
08:56:57 <hugo___> do i need to create type C to wrap them ?
08:56:59 <elly> hugo___: f :: a -> b
08:57:00 <ksf> that is, Num a => [a] does not allow you to mix Floats and Ints, a is disambigued before Num a is enforced.
08:57:03 <elly> oh, you mean that
08:57:08 <elly> f :: (a, b) -> c
08:57:30 <hugo___> bah
08:57:34 <hugo___> that is so ugly
08:57:37 <quicksilver> @remember rwbarton A type class is not a type just like a dog house is not a dog.
08:57:38 <drdozer> haha, it's running very much slower now - I guess it really is in interpreted mode
08:57:38 <lambdabot> Done.
08:57:38 <rwbarton> hugo___: my guess is you've written something like f :: Foo -> String, where Foo is a type class, and you want f :: Foo a => a -> String?
08:57:39 <hugo___> there goes extensibility
08:57:42 <ksf> i guess he meant a -> (b, c)
08:57:43 <elly> er... what?
08:57:52 <dolio> A list of mixed floats and ints has type [exists a. Num a => a].
08:57:52 <elly> those are all type variables
08:57:55 <hugo___> ah yes rwbarton
08:58:10 <hugo___> thanks you
08:58:11 * elly vanishes in a puff of smoke
08:58:25 <rwbarton> hugo___: You're welcome
08:58:38 <ksf> there are existential quantifications in the haskell type system?!
08:58:49 <dolio> No. But you can pretend.
08:58:59 <ksf> phew.
08:59:08 * quicksilver is great at pretending.
08:59:15 <quicksilver> Hey look, I'm Superman!
08:59:15 <dolio> To actually make such a list in GHC would require an existential wrapper, which makes it no longer particularly attractive.
08:59:49 <ksf> well, you could use unsafeCoerce, and to make it sane again, agda.
08:59:49 <dolio> Apparently there was one some investigation into first-class existentials, though.
09:00:09 <dolio> @quote simonpj existentials
09:00:09 <lambdabot> simonpj says: My brain is too small to figure out the consequences of adding first-class existentials to Haskell
09:01:40 <ksf> anyway, (a,b) -> c and a -> b -> c are isomorph up to currying.
09:02:14 <ksf> a -> b -> c and a -> (b, c), too, in teh other direction (uhm...)
09:03:12 * ksf is not shure whether he just blew his mind or haskell's semantics.
09:03:24 * quicksilver slaps ksf 
09:03:43 <dolio> There are some discrepancies, actually.
09:03:50 <newsham> a -> (b,c) gives a single (b,c) mapping where a -> (b -> c) gives an infnite number of (b,c) mappings
09:03:55 <fasta> Is there a program/library which displays a matrix nicely?
09:04:01 <dolio> Since _|_ and (_|_,_|_) are distinct values for (a,b).
09:04:08 <quicksilver> dolio: the substantiative point that SPJ made is that it would appear to require a serious change to core.
09:04:21 <quicksilver> dolio: and he didn't want to do that without understanding the implications of that.
09:04:26 <fasta> In this case just a [[Double]] for example.
09:04:36 <dolio> Yeah. I don't blame him.
09:04:45 <ozy`> is there a channel around here specifically for the purpose of bickering about language design?
09:05:04 <ksf> there's ltu.
09:05:04 <fasta> ozy`: oasis
09:05:08 <quicksilver> dolio: there is also a more trivial syntactic point about principal types : the current setup with explicit constructors 'delineates' the point where free type variables are created and discarded.
09:05:30 <dolio> However, going through uncurry . curry either makes certain functions stricter, or certain other functions lazier.
09:05:32 <quicksilver> dolio: it's nice to have a clear syntactic boundary scoping these 'behind the scenes' variables.
09:05:52 <quicksilver> you'd probably need a new keyword to 'unwrap' firstclass existentials
09:06:01 <quicksilver> (and is that any better than the current setup, then?)
09:06:53 <dolio> Well, I forget how exactly that all gets handled in, for instance, Daan Leijen's papers on such type systems.
09:06:59 <drdozer> mm, compiled code runs quite a lot faster
09:07:15 <dolio> I think things "just work" when you apply universally quantified things to existentially quantified things.
09:07:17 <ozy`> fasta: awesome, exactly what I was looking for
09:07:19 * ksf thinks he overlooked an important implication of pointfree style
09:07:41 <dolio> But there are also some ways to 'open' existentials in a particular scope, I think.
09:07:48 <ksf> that is, there's some code of mine that curries more than necessary.
09:09:56 <quicksilver> dolio: yes, if you have a first class universal you should be able to 'just apply' it to a first class existential.
09:10:06 <quicksilver> dolio: but note that haskell98 doesn't have first class universals, either.
09:10:11 <dolio> Anyhow, those papers make them look pretty nice, but I recall SPJ saying that it adds a lot of complexity to the type system, in his opinion.
09:10:18 <dolio> And I can't say I actually use existentials much.
09:10:42 <dolio> Right, but GHC does.
09:11:08 <dolio> Haskell98 barely has anything interesting. :)
09:12:13 <quicksilver> dolio: existentials are useful and I use them occasionally. I don't use them often and certainly not often enough that the syntactic overhead of an extra constructor annoys me.
09:12:25 * ksf wouldn't be surprised to see something like inline agda to enable people who are not oleg to do the oleg.
09:12:39 <quicksilver> dolio: what annoys me more is the way they poke holes in equational rewrite
09:12:58 <quicksilver> [S 1, S 'a', S "foo"]
09:13:09 <quicksilver> where 'S' is some kind of polymorphic constructor
09:13:20 <quicksilver> can't be abstracted to map S [1,'a',"foo"]
09:13:23 <quicksilver> (well, obviously)
09:13:25 <dolio> Yeah.
09:13:29 <loadquo> @src ([])
09:13:29 <lambdabot> Source not found.
09:13:37 <quicksilver> but in more complex examples it looks like annoying boilerplate.
09:13:41 <hallongrottan> @src List
09:13:42 <lambdabot> Source not found. You type like i drive.
09:13:43 <ksf> @src (:)
09:13:43 <lambdabot> Source not found. Maybe you made a typo?
09:13:48 <hallongrottan> lol
09:13:58 <quicksilver> @src []
09:13:58 <lambdabot> data [] a = [] | a : [a]
09:14:26 <dolio> Someone was in here the other day wanting "map show [1, 'a', "foo"]"
09:14:57 <dolio> Or, he had "map show [Left 5, Left 6, Right 'a', Right 'b']" and didn't want the "Left" and "Right".
09:15:08 <ksf> just a sec... [] is neither a valid typename or constructor.
09:15:18 <roconnor> @kind []
09:15:20 <lambdabot> * -> *
09:15:23 <quicksilver> ksf: yes, it's cheating magic syntax.
09:15:29 <quicksilver> ksf: [] is a special case syntactically
09:15:31 <andun> is it possible to create an "empty" typeclass that just depends on other typeclasses?
09:15:33 <roconnor> > [1] :: [] Int
09:15:34 <lambdabot>   [1]
09:15:39 <quicksilver> (although there is nothing special about its implementation or semantics)
09:15:45 <roconnor> > 1:[] :: [] Int
09:15:46 <quicksilver> andun: definitely.
09:15:47 <lambdabot>   [1]
09:15:48 <andun> (i'm tired of writing (Ord a, Fractional a))
09:16:07 <roconnor> andun: add a macro to your editor? :)
09:16:08 <byorgey> quicksilver: that has nothing in particular to do with existentials, does it?  you can't rewrite '[const 3 'x', const 3 5]' either.
09:16:23 <quicksilver> byorgey: no, it's just you notice it more often with existentials.
09:16:29 <andun> roconnor: actually, i'm more tired of having it in my code
09:16:34 <byorgey> fair enough.
09:16:41 <quicksilver> byorgey: it's more to do with polymorphism not being first class , in a sense.
09:16:42 <dolio> And I was about to talk about how in a sufficiently fancy language, you could do "map (show :: forall a. Show a => a -> String) ([5, 6, 'a', 'b'] :: [exists a. Show a => a])", when it occurred to me that that isn't any better than writing [show 5, show 6, show 'a', show 'b']. :)
09:16:51 <roconnor> actually can andun make a class (Ord a, Fractional a) => Andun a  with no methods?
09:16:56 <roconnor> does that work?
09:17:01 <quicksilver> byorgey: although it's also to do with lists not being polymorphic.
09:17:08 <ozy`> it'd be neat if we could do "constructor[l|r] +" or whatever
09:17:14 <byorgey> sure.
09:17:15 <quicksilver> roconnor: yes, he can.
09:17:16 <dolio> And actually the latter is shorter than "map show [Left ..." anyhow. :)
09:17:17 <quicksilver> and I think it works.
09:17:33 <roconnor> andun: that might work
09:17:40 <quicksilver> and add a general instance too, instance (Ord a, Franctional a) => Andun a
09:17:47 <roconnor> oh right
09:17:57 <roconnor> hmm
09:18:06 <roconnor> that instance probably requires a GHC extension
09:18:07 <andun> oh, thanks. that was easy :)
09:18:21 * ksf has a "don't-use-any-macros-exept-."-policy
09:18:53 <quicksilver> roconnor: only FlexibleInstances
09:19:05 <quicksilver> roconnor: which is fairly harmless.
09:19:20 <roconnor> well, I guess andun can decide if andun is willing to accept that price
09:19:41 <andun> yeah, np :)
09:19:45 <andun> thanks
09:20:19 <rwbarton> I was under the impression that most things FlexibleInstances lets you do were also possible in Haskell 98, using auxiliary type classes
09:20:26 <rwbarton> (or methods)
09:20:56 <rwbarton> but that doesn't seem to be true in this case.  Maybe my impression is false, or maybe this is a special case
09:22:25 <mattam> roconnor: how many elements in the period table?
09:22:37 <islon_s> why this doesnt work? sort . map (\s -> map toUpper s) list
09:22:52 <roconnor> mattan: 200 plus IIRC
09:22:55 <roconnor> mattam
09:23:01 <ddarius> :t map (\s -> map toUpper s) []
09:23:02 <lambdabot> [[Char]]
09:23:03 <ddarius> :t (.)
09:23:04 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
09:23:06 <quicksilver> islon_s: because "." composes two functions.
09:23:16 <roconnor> oh crap
09:23:16 <quicksilver> islon_s: and " map (\s -> map toUpper s) list" isn't a function.
09:23:26 <roconnor> mattam: only 100 something
09:23:33 <mattam> roconnor: :)
09:23:33 <quicksilver> islon_s: probably you wanted (sort . map (\s -> map toUpper s)) list
09:23:44 <mattam> I'll make a big patch.
09:23:52 <islon_s> yeah! thanks =D
09:24:05 <loadquo> Or sort . map (\s -> map toUpper s) $ list perhaps.
09:24:07 <quicksilver> which is often written "sort . map (\s -> map toUpper s) $ list"
09:24:33 <roconnor> mattam: if I get to revison Lawrencium I am screwed
09:24:41 <islon_s> it worked
09:25:13 <andun> quicksilver: it complains about undecidable instances...
09:25:15 <roconnor> mattam: it would be fun to end on revision Platinum, but I don't think I'll make it that far
09:25:30 <mattam> hehe
09:25:53 <quicksilver> andun: hmm. damn!
09:34:57 <asgaroth> What would be the most elegant way to write a brainfuck interpreter? Currently I have a bunch of actions inside a state monad and map the input characters to them. Is there a better way?
09:35:34 <ddarius> asgaroth: Yes
09:36:54 <Saizan> @where hpaste2
09:36:54 <lambdabot> http://moonpatio.com:8080/
09:38:37 <asgaroth> ddarius: Could you give me some keywords?
09:38:41 <byorgey> ddarius: really? what is it?
09:38:46 * byorgey is curious
09:39:04 <byorgey> (having once written a bf interpreter in exactly the way asgaroth describes)
09:39:11 <ddarius> Why would you use a state monad rather than just making functios State -> State
09:39:12 <rwbarton> byorgey: LLVM :)
09:39:19 <byorgey> hahaha
09:39:51 <Saizan> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=839#a839
09:39:51 <byorgey> ddarius: well, there's IO involved too
09:40:09 <ddarius> Okay, State -> IO State and compose with >=>
09:40:48 <drdozer> what's the interpreted-code slow-down factor usually like? This takes a minute or so to crash when compiled and I've been waiting for it to crash for nearly an hour now in interpreted mode
09:42:02 <byorgey> drdozer: I think it can differ by many orders of magnitude depending on the code.
09:42:32 <drdozer> byorgey: well, if it doesn't finish soon I will have to go home
09:44:22 <byorgey> if it's been running for an hour, the likelihood that it will crash in the next few minutes is probably small.  And there's no estimate of the slow-down factor accurate enough that would be able to tell you whether you should wait for it or not.
09:44:36 <arjanb> drdozer: as far as i have seen it's around 50 times slower
09:52:03 <gwern> http://www.xsharp.org/samples/ <-- the mind boggles
09:52:57 <ddarius> gwern: "Code is Poetry"
09:53:26 <lucca> gwern: not okay to paste links like that right after people have eaten
09:53:51 <gwern> lucca: #haskell is worldwide. someone's always eating
09:53:59 <lucca> exactly
09:54:10 * ddarius is eating right now.
09:54:21 <islon_s> here is 3:51 pm
09:54:26 <gwern> so, by definition, I am not posting it right after somone has eaten.
09:54:34 <rwbarton> ddarius: "Oh freddled gruntbuggly, thy micturations are to me..."
09:54:37 <byorgey> please tell me that page is a joke.
09:54:39 <gwern> I can prove this by setting someone to equal ddarius
09:54:53 <lucca> i think your existentials are confused
09:54:56 * byorgey is eating too
09:54:57 <gwern> ddarious is currently eating as I post it. he is not 'has eaten'
09:55:10 <ddarius> XML oriented is the new paradigm.
09:55:35 <gwern> ddarius: now all we need is some sort of abstraction mechanism which will create new xml expressions...
09:56:01 <byorgey> "In X# everything is represented as an XML tree and instead of using functions to manipulate information or perform actions, all possible operations you can think of are done by adding, removing or changing nodes from this tree."
09:56:12 <byorgey> Why not go all the way and just use Peano numerals for everything?
09:56:16 <byorgey> Trees are too complex.
09:56:28 <islon_s> "code as data" even more than lisp xD
09:56:37 <idnar> it's like someone decided to make XSLT worse
09:57:54 * ksf wants a tar command that can figure out whether to use z or j by itself.
09:57:57 <ozy`> I am now going to ask for collaboration on QCXJ#, which concatenates the semantics of XSLT and SQL and serves it in a syntax based on J and brainfuck
09:58:28 <ozy`> by the way, it's object-oriented
10:00:31 <Saizan> and everytime you use it, god kills a kitten?
10:01:04 <islon_s> no, everytime you use it java throws a NullPointerException
10:01:31 <drdozer> wow, if functional programming languages used to produce code that ran like interpreted haskell, no wonder they had a steryotype of being slow
10:01:34 <ozy`> islon_s: actually we will subclass that as the DeadKittenException. best of both worlds!
10:02:44 <islon_s> ozy`: don't forget to catch the dead kitten
10:02:50 <ozy`> drdozer: that + "recursion is bad" + "GC considered harmful" + "languages without FOR loops are primitive" + etc.
10:02:51 <ddarius> I've now read that XML oriented Programming Introduction and have lost all hope for humanity.
10:03:27 <drdozer> ddarius: and yet I can imagine it catching on among certain groups of people
10:03:33 * RayNbow found a reason why he should always compile with -O2... http://i296.photobucket.com/albums/mm178/ShinNoNoir85/StackOverflow.png :p
10:03:42 <ozy`> ddarius: every generation has a class of people who are doomed to wander broken and lost, and die in the street.
10:03:47 <ozy`> ddarius: with any luck.....
10:03:55 <islon_s> "we had a problem and tried to use XML... now we have two problems"
10:05:11 <Saizan> ".. now we have a verbose tree of problems"
10:05:17 <Saya_> god you use a green on black console O.O
10:05:22 <drdozer> xml does what it is designed for very well - representing data-structures isomorphic with infinitely-many different colored brackets with some level of specification of nesting patterns
10:05:47 <drdozer> what amazes me is all the other things people try to do with it
10:06:25 <gwern> @seen mmorrow
10:06:26 <lambdabot> mmorrow is in #ghc and #haskell. I last heard mmorrow speak 1h 28m 6s ago.
10:06:51 <gwern> @ask mmorrow you seen the [Haskell-cafe] haskell-src-meta Package thread complaining about you being a bad maintainer?
10:06:52 <lambdabot> Consider it noted.
10:07:04 <Saya_> Why would anyone want to program with xml syntax :s
10:07:34 <ksf> http://eaglemode.sourceforge.net/index.html <-- you have to try this
10:09:06 <chessguy_work> > union [[1,2],[2,2,3]]
10:09:07 <lambdabot>       Overlapping instances for Show ([[t]] -> [[t]])
10:09:08 <lambdabot>        arising from a u...
10:09:37 <chessguy_work> @hoogle [[a]] -> [[a]] -> [a]
10:09:37 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
10:09:37 <lambdabot> Distribution.Simple.Utils intercalate :: [a] -> [[a]] -> [a]
10:09:37 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
10:10:04 <chessguy_work> @type foldr union []
10:10:05 <lambdabot> forall a. (Eq a) => [[a]] -> [a]
10:10:34 <chessguy_work> @type union
10:10:35 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
10:11:12 <ksf> ...you can zoom / to bin to a binary and see its textdump...
10:11:32 <vixey> what's data mining?
10:11:41 <vixey> it seems to be the new 'web framework'
10:11:54 <chessguy_work> eh?
10:12:00 <maltem> eh? I thought data mining was statistical methods
10:12:12 <chessguy_work> http://en.wikipedia.org/wiki/Data_mining
10:12:25 <chessguy_work> analyzing large data sets for significant patterns, essentially
10:12:48 <maltem> oh, so not exactly statistical :-/
10:13:16 <int80_h> test
10:13:20 <chessguy_work> well, not _only_ statistical anyway
10:16:10 <mmorrow> gwern: i haven't
10:16:10 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
10:16:42 <ozy`> maltem: well statistics would be a necessary tool for data mining.... in the sense that robotics is a necessary tool for modern manufacturing
10:16:50 <mmorrow> gwern: i have been a bad maintainer though
10:18:21 <dolio> You just flagrantly ignore bug reports?
10:19:44 <int80_h> good morning #haskell
10:20:32 <dolio> Morning?
10:20:45 <facedown> good night
10:20:57 <mmorrow> love when graphviz spits out a graph after 10 minutes which then proceeds to crash you X server upon attempting to view it
10:20:57 <int80_h> it's more of a greeting than a literal interpretation of time in your locality
10:25:07 <mmorrow> <dolio> You just flagrantly ignore bug reports?
10:25:18 <mmorrow> heh, i haven't gotten any :)
10:25:31 <mmorrow> well, i need to update it for the new haskell-src-exts if that counts
10:25:39 <mmorrow> :/
10:25:42 <dolio> Evidently you have. :)
10:25:47 <mmorrow> wuh
10:25:50 <dolio> Did you use a fake e-mail address on hackage? :)
10:26:01 <dolio> mmorrow@spam-email.net
10:26:21 <mmorrow> semi, but i thought i would have seen any emails
10:26:24 * mmorrow checks
10:27:10 <asgaroth> Is ((->) a) an instance of Functor? Or why else does liftA2 lookup foo bar, work where foo and bar are both of type a -> ..?
10:27:17 <gwern> mmorrow: you naughty person
10:27:35 <mmorrow> apparently someone has already written a patch and sent it to me a month ago :(
10:27:43 <Saizan> asgaroth: it is an instance of functor
10:27:50 <asgaroth> Saizan: ok, thanks
10:27:53 <Saizan> asgaroth: with fmap = (.)
10:27:54 <CosmicRay> so I'm using CPP extension for a file.  It's in {-# LANGUAGE CPPP #-} at the top of the file.  cabal builds it with GHC just fine, but ./setup haddock crashes because it doesn't preprocess that out for Haddock
10:27:59 <gwern> I say off with mmorrow's head for negligence!
10:28:00 * mmorrow feels bad now
10:28:16 <gwern> CosmicRay: CPPP? Is that the advanced edition? :)
10:28:21 <CosmicRay> heh
10:28:28 <CosmicRay> it was spelled correctly in my source file ;-)
10:28:32 <gwern> 'k
10:28:42 <dcoutts_> CosmicRay: what haddock version is that? 0.x ?
10:28:50 <CosmicRay> dcoutts: 0.8
10:28:51 <waterman_> vixey:  data mining is a loose term for finding significant patterns in large piles of data...
10:28:58 <Saizan> CosmicRay: two workarounds: 1) use haddock >= 2; 2) put CPP in the extensions field in .cabal
10:29:06 <CosmicRay> dcoutts: this is what is shipping in Debian, alongside GHC 6.8
10:29:08 <dcoutts_> CosmicRay: ok, you need to list the extension in the .cabal file, otherwise Cabal does not know
10:29:09 <waterman_> where 'significant' has various interpretations.
10:29:11 <vixey> it sounds illegal to me
10:29:22 <vixey> just the name 'data mining' makes me think, they must be up to no good
10:29:25 <gwern> but yeah, a lot of haddocks dont do CPP. this was a problem with xmc as well
10:29:31 <CosmicRay> dcoutts_, Saizan: trying that, thanks.
10:29:33 <gwern> fortunately modern haddocks do :)
10:29:34 <ozy`> vixey: when the FBI does it, it's not illegal (to paraphrase Nixon)
10:29:42 <vixey> @nixon
10:29:43 <lambdabot> Certainly in the next 50 years we shall see a woman president, perhaps sooner than you think. A woman can and should be able to do any political job that a man can do.
10:29:58 <CosmicRay> @nixon
10:29:58 <lambdabot> You know, it's a funny thing, every one of the bastards that are out for legalizing marijuana is Jewish. What the Christ is the matter with the Jews, Bob? What is the matter with them? I suppose it
10:29:58 <lambdabot> is because most of them are psychiatrists.
10:30:03 <gwern> well, clinton did have a good shot at the presidency
10:30:04 <kiris> a <$> x <*> y <*> z  -- can I make this into [x,y,z] somehow?
10:30:12 <vixey> nixon is great :p
10:30:35 <vixey> @nixon
10:30:35 <lambdabot> This is a great day for France!
10:30:39 <waterman_> it covers everything from "grep | uniq -c" to looking for bad credit card transactions to trying to find correlations in DNA expression levels
10:30:41 <byorgey> kiris: no.  in general x,y,z may not have the same types.
10:30:41 <int80_h> @src takeWhile
10:30:41 <lambdabot> takeWhile _ []                 =  []
10:30:42 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
10:30:42 <lambdabot>                    | otherwise =  []
10:30:43 <kiris> preflex: be poppavic
10:30:44 <preflex>  you need to be aware of C before you screw with commo/net and THEN you need to consider the funnels/rules. Why is this remotely an issue?
10:31:00 <dolio> b52s needs more quotes.
10:31:03 <idnar> > liftA3 (\x, y, z -> [x, y, z]) <$> x <*> y <*> z :: [Expr]
10:31:04 <lambdabot>   <no location info>: parse error on input `,'
10:31:11 <rwbarton> @type sequenceA
10:31:12 <lambdabot> Not in scope: `sequenceA'
10:31:14 <idnar> > liftA3 (\x y z -> [x, y, z]) <$> x <*> y <*> z :: [Expr]
10:31:16 <lambdabot>   Couldn't match expected type `Expr' against inferred type `f [c]'
10:31:18 <idnar> erf
10:31:25 <rwbarton> @type traverse
10:31:26 <lambdabot> Not in scope: `traverse'
10:31:35 <kiris> @type Data.Traversable.traverse
10:31:35 <rwbarton> @type Data.Traverse.traverse
10:31:36 <dolio> @type T.traverse
10:31:36 <lambdabot> Couldn't find qualified module.
10:31:37 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Applicative f, Data.Traversable.Traversable t) => (a -> f b) -> t a -> f (t b)
10:31:38 <lambdabot> Couldn't find qualified module.
10:31:47 <rwbarton> @type Data.Traversable.sequence
10:31:48 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => t (m a) -> m (t a)
10:32:09 <rwbarton> @type Data.Traverse.sequenceA
10:32:11 <lambdabot> Couldn't find qualified module.
10:32:13 <rwbarton> @type Data.Traversable.sequenceA
10:32:14 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Applicative f, Data.Traversable.Traversable t) => t (f a) -> f (t a)
10:32:38 <gwern> hm. this new version of firegpg has both good features and bad features. damn I hate when that happens
10:32:40 <int80_h> @src takeWhile
10:32:40 <lambdabot> takeWhile _ []                 =  []
10:32:40 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
10:32:40 <lambdabot>                    | otherwise =  []
10:32:52 <rwbarton> @hoogle (Applicate f) => [f a] -> f [a]
10:32:52 <lambdabot> Warning: Unknown class Applicate
10:32:52 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
10:32:52 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
10:32:54 <rwbarton> @hoogle (Applicative f) => [f a] -> f [a]
10:32:55 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
10:32:55 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
10:32:55 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
10:33:08 <rwbarton> why can't I type today?  Too cold I guess
10:33:36 <kiris> getOrder :: Statement -> IO Order
10:33:36 <kiris> getOrder s = let f = flip field s; f :: SqlBind a => String -> IO a
10:33:36 <kiris>              in  Order <$> f "id" <*> f "name" <*> f "items"
10:33:36 <kiris>                        <*> f "created" <*> f "card" <*> f "billto"
10:33:39 <kiris>                        <*> f "shipto" <*> f "total"
10:33:43 <kiris> ahhh dun' like this
10:34:07 <asgaroth> The docs for 6.8.2 also included these "| Source" links for viewing the source of a function, but they are gone in the docs for ghc-6.10, how can I rebuild them to include those links?
10:34:22 <kiris> maybe an infix operator that does both <*> and f?
10:34:48 <Igloo> asgaroth: Make sure HsColour is installed
10:35:48 <asgaroth> Igloo: And how would I rebuild them? (I'm currently using the .tar.gz from haskell.org)
10:38:12 <dons> HackageDB statistics
10:38:12 <dons> 274 users have uploaded 3161 versions of 1000 packages.
10:38:17 <dons> *WELL DONE*)
10:38:35 <int80_h> takeWhile p (x:xs) | p x = x : takeWhile p xs says that "if the result of p(x) is true, then do x : takeWhile p xs". How do I do the converse "p(x) is not true"
10:38:44 <vixey> one of them was not me :(
10:39:16 <Saizan> int80_h: | otherwise = ...
10:39:30 <Saizan> > otherwise
10:39:31 <lambdabot>   True
10:39:39 <int80_h> Saizan: well, I was going to replace the p(x) statement
10:39:42 <idnar> or maybe (not (p x))
10:40:19 <ozy`> @let takeUntil p = takeWhile . not p
10:40:20 <lambdabot>  Couldn't match expected type `a -> a1 -> Bool'
10:40:32 <ozy`> >:|
10:40:43 <int80_h> wouldn't it be nice if I could do that
10:40:47 <Saizan> s/./$/
10:40:49 <ozy`> @let takeUntil p xs = takeWhile (not p) xs
10:40:50 <lambdabot>  Couldn't match expected type `a -> Bool'
10:41:12 <int80_h> yeah I tried using not with takeWhile, couldn't get past the type errors
10:41:17 <Saizan> @let takeUntil = takeWhile . not
10:41:18 <lambdabot>  Couldn't match expected type `a -> Bool'
10:41:26 <rwbarton> @let takeUntil p = takeWhile (not . p)
10:41:28 <lambdabot>  Defined.
10:41:29 <Saizan> @let takeUntil p = takeWhile (not . p
10:41:29 <lambdabot>   Parse error
10:41:30 <int80_h> so I figure I need to write the converse of takeWhile myself
10:41:38 <ozy`> oh duh
10:41:38 <rwbarton> > takeUntil (> 3) [0,2,4,6]
10:41:40 <lambdabot>   [0,2]
10:41:42 * ozy` headdesks
10:41:57 * vixey headrests
10:42:06 <Saizan> ok, pl style it's: takeWhile . (not .)
10:42:24 * h0tzenpl0tz afr
10:42:58 <tromp__> > let takeUntil  = takeWhile.not in takeUntil (> 3) [0,2,4,6]
10:42:59 <lambdabot>   Couldn't match expected type `a -> Bool'
10:43:28 <Saizan> > let takeUntil  = takeWhile . (not .) in takeUntil (> 3) [0,2,4,6]
10:43:29 <lambdabot>   [0,2]
10:47:20 <dons> bos interviewed for oreilly, http://www.reddit.com/r/programming/comments/7revl/bryan_osullivan_on_the_power_of_haskell/
10:50:15 <dons> eelco: any chance of redoing that bubble graph of libraries now we've reached 1000?
10:50:20 <dons> maybe a big version?
10:51:45 <int80_h> @src words
10:51:45 <lambdabot> words s = case dropWhile isSpace s of
10:51:45 <lambdabot>     "" -> []
10:51:45 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
10:52:32 <vixey> @pl \s' -> w : words s'' where (w, s'') = break isSpace s'
10:52:32 <lambdabot> (line 1, column 37):
10:52:32 <lambdabot> unexpected "="
10:52:32 <lambdabot> expecting variable, "(", operator, ":", "++", "<+>" or end of input
10:52:42 <vixey> @pl \s' ->  let (w, s'') = break isSpace s' in w : words s''
10:52:43 <lambdabot> (line 1, column 13):
10:52:43 <lambdabot> unexpected "("
10:52:43 <lambdabot> expecting "()", natural, identifier or "in"
10:52:44 <mmorrow> , randE()
10:52:46 <lunabot>  ()
10:52:47 <mmorrow> , randE()
10:52:49 <lunabot>  (x0 :: x4) (x2 "This i") (() :: x4)
10:53:01 <vixey> @pl \s' -> case break isSpace s' of (w, s'') -> w : words s''
10:53:02 <lambdabot> (line 1, column 42):
10:53:02 <lambdabot> unexpected ">" or "-"
10:53:02 <lambdabot> expecting variable, "(", operator or end of input
10:53:04 <vixey> omg
10:53:10 <mmorrow> omg omg
10:53:33 <vixey> , randE
10:53:34 <lunabot>  luna: No instance for (GHC.Show.Show
10:53:36 <vixey> , randE$
10:53:37 <lunabot>  luna: No instance for (GHC.Show.Show
10:53:39 <dons> hey vixey, we just got the 1000th haskell package release on hackage! woowoo. used cabal-install yet?
10:53:40 <vixey> , )$randE
10:53:41 <lunabot>  luna: parse error on input `)'
10:53:52 <mmorrow> heh, clever
10:53:59 <Holle_> how to generate an infinit list like [1,2,3,1,2,3,1,2,3,...]?
10:54:03 <vixey> I think so dons
10:54:12 <vixey> but it's just called 'cabal' right?
10:54:13 <dons> awesome.
10:54:15 <dons> yep
10:54:32 <vixey> Holle_, it's  [1,2,3] ++ the whole thing
10:54:33 <koeien> Holle_: cycle [1,2,3]
10:54:37 <nikki93> In which module is 'Expr' found?
10:54:41 <nikki93> @hoogle Expr
10:54:41 <lambdabot> module Text.Parsec.Expr
10:54:41 <lambdabot> module Text.ParserCombinators.Parsec.Expr
10:54:41 <lambdabot> Distribution.Simple.Program alexProgram :: Program
10:54:45 <vixey> Holle_, so you can write   let wholeThing = [1,2,3] ++ wholeThing
10:54:45 <mmorrow> , ) `seq` $(parseExp . render $ randE (
10:54:46 <lunabot>  luna: parse error (possibly incorrect indentation)
10:54:58 <Holle_> cycle works great :)
10:54:59 <mmorrow> , ) `seq` $(parseExp . render $ randE ()
10:55:00 <int80_h> nikki93: hi!
10:55:00 <lunabot>  luna: Not in scope: `parseExp'
10:55:08 <nikki93> int80_h: Sup?
10:55:16 <koeien> @src cycle
10:55:16 <lambdabot> cycle [] = undefined
10:55:16 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
10:55:22 <int80_h> nikki93: still on chapter 4
10:55:43 <int80_h> having fun with predicates
10:56:08 <rwbarton> , $( randE )
10:56:09 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Lib.ExpQ'
10:56:19 <rwbarton> , [$ty| randE |]
10:56:22 <lunabot>  () -> Doc
10:56:22 <int80_h> @type words
10:56:24 <lambdabot> String -> [String]
10:56:24 <mmorrow> yeah, it should gen syntax instead of Doc
10:56:25 <rwbarton> , $( randE () )
10:56:26 <nikki93> int80_h: Ha.
10:56:26 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Lib.ExpQ'
10:56:33 <mmorrow> , parseExp
10:56:34 <lunabot>  luna: Not in scope: `parseExp'
10:56:39 <mmorrow> gr
10:56:43 <nikki93> How do I use 'Expr' in ghci? It says Text.Parsec.Expr not found. :(
10:56:51 <BMeph> int80_h: "Sup dawg, we herd u liek predicates..." ;p
10:56:57 <int80_h> +m moduke name
10:57:00 <int80_h> module
10:57:36 <vixey> BMeph, so we encoded a predicate in your predicate so you can diagonalize logic and prove it's essential incompleteness..?
10:57:50 <int80_h> BMeph: you remember being 15, right?
10:58:13 <BMeph> vixey: "...while you prove its essential incompleteness." ;p
10:58:14 <vixey> (while you drive)
10:58:33 <BMeph> int80_h: Like it was last August. Oh, wait... ;p
10:58:49 <vixey> lol
10:58:52 <int80_h> BMeph hah, you're really 16?
10:59:00 <nikki93> int80_h: I'm 15. :\
10:59:13 <int80_h> nikki93: I'd guessed that already
10:59:17 <BMeph> int80_h: I am "on the Inside." ;p
10:59:19 <nikki93> int80_h: Ah.
10:59:22 * koeien wished that he knew Haskell at 15
10:59:40 <int80_h> haskell wasn't even invented when I was 15. But Lisp was. Wished I had learned lisp
10:59:55 <nikki93> int80_h: I learnt C++ first.
10:59:57 <int80_h> I'm not sure anyone ever wrote a lisp for the atari
11:00:04 <Gracenotes> I'd be interested to see the age distribution of the Haskell community :x
11:00:05 <nikki93> int80_h: Did you see www.grall.freejoomlas.com?
11:00:05 <koeien> i'm 22. started with basic, logo and then C++
11:00:23 <ray> nothing stopping you from writing a lisp for the atari now
11:00:51 <BMeph> dons: How about a cabal list --latest, which lists packages put up since the last time you did an update? :)
11:00:55 <Gracenotes> a lot of people in here are in their 20s, I've gathered
11:01:04 * nikki93 started with QBasic, then Game Maker (:P) then C++, uses Squirrel and Python for scirpting, now uses C++ for most projects and is messing around with Haskell
11:01:08 <int80_h> ray: oooh, turn the atari into a lisp machine. that's intriguing
11:01:17 <nikki93> s/scirp/scrip
11:01:20 <ray> recycling
11:01:23 <Plouj> so, can haskell directly call C libraries?
11:01:31 * skorpan never really learned C++
11:01:35 <lilac> Plouj: yes, via the FFI
11:01:37 <daf> @faq
11:01:37 <lambdabot> The answer is: Yes! Haskell can do that.
11:01:38 <koeien> @faq Can Haskell directly call C libraries?
11:01:39 <lambdabot> The answer is: Yes! Haskell can do that.
11:01:43 <int80_h> Plouj: you need the FFI
11:01:51 <daf> @quote sterero
11:01:52 <lambdabot> No quotes match. My brain just exploded
11:01:55 <daf> @quote stereo
11:01:56 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
11:01:57 * BMeph started with BASIC on Radio Shack computers. BMeph is Reeeeeeeeeeeeally old... ;\
11:01:58 <lilac> @quote glorious
11:01:58 <lambdabot> piroko says: Powerbook + external monitor + xmonad = glorious
11:02:02 <mmorrow> , genExp
11:02:03 <Plouj> aaaaaaaaaaahhhhhhhhh
11:02:04 <lunabot>  AppE (AppE (CaseE (VarE x2) [Match (LitP (IntegerL (-4))) (NormalB (VarE ...
11:02:06 <Plouj> Whaaaaaaaaaaatttt?
11:02:09 <mmorrow> , ppDoc `fmap` genExp
11:02:09 <Gracenotes> Plouj: here's a RWH chapter... http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html
11:02:10 <Plouj> so much noise!
11:02:11 <lunabot>  ([] :: x1) 10 ("This", x6)
11:02:14 <mmorrow> , ppDoc `fmap` genExp
11:02:15 * BMeph isn't as old as Lennart, though.
11:02:16 <lunabot>  "This is a strin"
11:02:22 <trofi> [:
11:02:25 <vixey> , "This is a string"
11:02:26 <lunabot>  "This is a string"
11:02:31 <idnar> wait, what
11:02:34 <Gracenotes> Plouj: I've never done it, but RWH should be a good reference :)
11:02:38 <ray> @google atari interlisp
11:02:39 <mmorrow> , $genExp
11:02:40 <lambdabot> No Result Found.
11:02:41 <lunabot>  luna: Illegal data constructor name: `x5'
11:02:43 <mmorrow> , $genExp
11:02:45 <lunabot>  luna: Illegal data constructor name: `x8'
11:02:46 <repnop> what's different between lunabot and lambdabot?
11:02:46 <vixey> , $(genExp)
11:02:48 <lunabot>  luna: Illegal data constructor name: `x2'
11:02:50 <vixey> , $genExp
11:02:52 <lunabot>  luna: Illegal data constructor name: `x8'
11:02:53 <int80_h> BMeph: we had TRS-80s at my high school. scriptset almost repelled me from computers forever. Then I found the macintosh.
11:02:53 <vixey> , $genExp
11:02:53 <trofi> luna is better
11:02:54 <trofi> :]
11:02:55 <lunabot>  luna: Illegal data constructor name: `x3'
11:02:56 <Plouj> Gracenotes: I'm up to chapter 3 in RWH.
11:02:57 <repnop> besides the command prefix :p
11:03:00 <Gracenotes> hey now, stop raping lunabot y'all >_>
11:03:13 <Plouj> so, what should I look for in a 3D library/engine when trying to pick one to be used in Haskell?
11:03:14 <Gracenotes> :>
11:03:20 <mmorrow> repnop: lunabot has some different imports/language features
11:03:29 <repnop> ah
11:03:42 * trofi still waits for darcs update of lunabot :]
11:03:43 <koeien> Plouj: make sure it's C, not C++. linking to C++ is a pain
11:03:58 <BMeph> I got to see Ralph (SNOBOL/Icon) in person, though, so it's Good to be Old(R). :)
11:04:02 <mmorrow> repnop: in particular, template-haskell and it imports some libraries from hackage
11:04:05 <int80_h> Plouj: I keep hearing that interfacing with c++ is especially a pain in the ass. So I would guess, avoid c++ libraries.
11:04:15 <BMeph> *Ralph Griswold, that is. :)
11:04:16 <Gracenotes> ah, yes, I have yet to learn template-haskell
11:04:21 <trofi> , -<
11:04:22 <lunabot>  luna: Not in scope: `-<'
11:04:25 <nikki93> Plouj: I use Ogre 3D with C++.
11:04:31 <mmorrow> trofi: ah yes, it was you!
11:04:36 <nikki93> Plouj: It is the ultimate best C++ 3d engine ever. Preiod. Full stop. End
11:04:37 <BMeph> Plouj: How about a Blender binding? ;)
11:04:41 <ray> i would learn template haskell but i should learn haskell first
11:04:44 <Plouj> nikki93: oh yeah? Do you have a project that I can look at?
11:04:50 <ozy`> int80_h: interfacing with C++ is a pain in the ass from any language.
11:04:55 <nikki93> Plouj: I have www.grall.freejoomlas.com
11:04:56 <trofi> mmorrow: YES! :]
11:04:57 <mmorrow> trofi: i might as well do that today too while i'm on the "fix all my broken packages" train :)
11:05:03 <Plouj> BMeph: blender is just an editor though.
11:05:16 <ray> interfacing with c++ is a pain in the ass from c++
11:05:18 <nikki93> Plouj: I'd also written a GameObject management framework, and a Bullet-physics Ogre connection.
11:05:24 <ray> in the degenerate case
11:05:26 <trofi> mmorrow: great! :]
11:05:36 <dolio> It certainly is.
11:05:41 <nikki93> Plouj: Blender also has a simple game engine within it.
11:05:49 <Plouj> written in python...
11:06:03 <nikki93> Plouj: Nope, its written in C++, you script it with python.
11:06:06 <lilac> I fail to see why C++ causes problems, unless you're trying to call something templated
11:06:12 <Plouj> oh, ok
11:06:17 <trofi> virtual methods
11:06:23 <nikki93> lilac: Its because everyone here thinks C++ sucks for some reason. :P
11:06:25 <trofi> overloaded functions
11:06:28 <dolio> Name mangling.
11:06:36 <trofi> and C++ name mnglng
11:06:37 <lilac> all three are not hard to solve
11:06:38 <ozy`> lilac: namespaces -> name mangling -> incompatible name mangling schemes
11:06:38 <koeien> nikki93: it sucksfor a shitload of reasons
11:06:41 <dolio> Unless you export a C interface.
11:06:48 <ray> is there any documentation on template haskell that isn't a paper (not that i have anything against papers)
11:06:48 <nikki93> koeien: Boo. :)
11:06:55 <repnop> you get to decide on the export symbol names anyways ;)
11:07:12 <koeien> nikki93: although it's probably one of the best OO languages out there IMO. which says a lot about the other languages
11:07:16 <Saizan> ray: there's something on the old wiki
11:07:28 <lilac> the FFI could trivially generate a C interface for the C++ function being used
11:07:34 <ray> ooh, archaeology
11:07:35 <lilac> this is hardly rocket science
11:07:40 <int80_h> koeien: now that just gives me unhappy making feelings.
11:07:57 <nikki93> koeien: Well may be you don't know how C++ should be used then. :P
11:08:03 <yip> a long time ago i started working on a c interface to ogre with the intention of using it with haskell
11:08:03 <mmorrow> , parseExp "\\x->x"
11:08:04 <lunabot>  Right (LamE [VarP x] (VarE x))
11:08:11 <rwbarton> , parseType "a"
11:08:11 <lunabot>  luna: Not in scope: `parseType'
11:08:18 <int80_h> yip: and what happened?
11:08:22 <Gracenotes> C++, a good OO language? >:-
11:08:26 <mmorrow> , parsePat "a@(x:_)"
11:08:27 <trofi> yep
11:08:27 <rwbarton> , parseExp "()::a"
11:08:27 <lunabot>  luna: Ambiguous occurrence `parsePat'
11:08:28 <lunabot>  Right (SigE (ConE GHC.Unit.()) (VarT a))
11:08:40 <mmorrow> , RandExp.parsePat "a@(x:_)"
11:08:41 <lunabot>  luna: Not in scope: `RandExp.parsePat'
11:08:43 <yip> int80_h: it was too much work, it needs to be automated
11:08:48 <mmorrow> , Luna.RandExp.parsePat "a@(x:_)"
11:08:49 <rwbarton> , parseExp "()::forall a. (Monad a) => a Int"
11:08:50 <lunabot>  Right (AsP a (InfixP (VarP x) GHC.Types.: WildP))
11:08:50 <BONUS_> what's the "official" for the part before the dot when calling functions from qualified imports
11:08:50 <lunabot>  Right (SigE (ConE GHC.Unit.()) (ForallT [a] [AppT (ConT Monad) (VarT a)] ...
11:08:52 <koeien> i like some features of C++. but i'll stop my rant now.
11:08:55 <int80_h> I thought I hated OO, then I met python. Then I realized I just hated C++
11:09:00 <nikki93> koeien: Well done. :)
11:09:01 <lament> heh
11:09:06 <dolio> Of course, there are exceptions.
11:09:19 <dolio> Felix is a functional-ish language that supposedly has good C++ interoperability.
11:09:32 * repnop likes C++ for private projects
11:09:32 * nikki93 checks out Felix
11:09:33 <Plouj> nikki93: so, grall is written in c++ not haskell....
11:09:34 <Gracenotes> BONUS_: the official name?
11:09:49 <dolio> Because it compiles through C++.
11:09:53 <lilac> if you want an OO language with a weak static type system and compilation to fast machine code, there's not many languages which beat C++
11:09:54 <nikki93> Plouj: Ehm yes. :)
11:10:08 <sm> come on folks.. you haven't done OO until you've spent time in smalltalk
11:10:08 <BONUS> umm like
11:10:13 <BONUS> the official terminology for it
11:10:16 <yip> lilac: D is a good competitor
11:10:19 <Plouj> nikki93: well, that's no use to me! I don't know c++, and I'm currently spending time learning Haskell!
11:10:19 <nikki93> Plouj: I was saying Ogre is a good C++ engine.
11:10:28 <rwbarton> It saddens me that the top result for hayoo is for someone who lost their "hayoo mail"
11:10:31 <lilac> yip: agreed. especially if you want compile-time metaprogramming, from what i hear
11:10:32 <repnop> lilac: and some simple template metaprogramming can go a long way to increasing performance
11:10:34 <nikki93> Plouj: Oh. Pure GL is the way to go then.
11:10:53 <ray> rwbarton: SEO!
11:11:00 <lilac> the thing is, most people /here/ don't want a weak static type system.
11:11:11 <Plouj> nikki93: I'm not sure I want to spend my time writing yet-another-3d-engine
11:11:15 <lilac> (arguably, most people /anywhere/ don't..)
11:11:16 <daf> Haskell has a good OpenGL binding
11:11:18 <Gracenotes> weak meaning permissive, here?
11:11:34 <koeien> yes, i suppose
11:11:37 <lilac> weak meaning provides-no-guarantees
11:11:45 <nikki93> Plouj: You mean you want something higher level than pure GL, in Haskell?
11:11:50 <yip> lilac: proper c++ should require unsafe casts only in very rare cases
11:12:15 <Plouj> nikki93: possibly, I don't know yet, but I suspect that would save a lot of time for me
11:12:31 <koeien> yip: true, you should almost never need them. however there are a shitload of other problems like "auto-converting"
11:12:34 <BMeph> BONUS: You mean "module"? :)
11:12:49 <nikki93> Plouj: Wait...
11:12:51 <BONUS> haha yeah well
11:12:53 <nikki93> Plouj: WHAT do you want to do?
11:12:57 <BONUS> maybe
11:13:01 <BONUS> module namespace resolution?
11:13:02 <BONUS> ugh
11:13:06 <Gracenotes> BONUS: The form "module M" names the set of all entities that are in scope with both an unqualified name "e" and a qualified name "M.e".
11:13:16 <Gracenotes> says Haskell 98, anyway.. :/
11:13:24 <lilac> yip: right. however, i mean much more than casts -- pointer arithmetic for one thing
11:13:26 <Plouj> nikki93: my goal is to end up with a simple Descent-like game written in Haskell.
11:13:33 <nikki93> Plouj: Any reason you want to stick with haskell? If its because you like haskell then you shouldn't have a problem writing the engine.
11:13:53 <yip> lilac: proper c++ should require use of pointers only in very rare cases :)
11:14:13 <vixey> yip, that can't be serious
11:14:16 <Plouj> nikki93: Right now, I choose Haskell because that's what I'm learning and I don't know anything well enough other than C. However, I don't want to waste time with memory management but focus on the game.
11:14:22 <koeien> no. it's true IMO
11:14:33 <lilac> yip: i agree. and i like that c++ lets me do that when i want to.
11:14:50 <yip> vixey: no, i am serious. instead of pointers you use references or containers or smart pointers
11:14:50 <Gracenotes> BONUS: also, "A qualified name is written as modid.name"
11:14:53 <koeien> exception handling almost always requires it.
11:15:08 <koeien> it's far too easy to get a memory leak otherwise
11:15:11 <ozy`> yip: proper C++ should be... well.... C.
11:15:23 <Gracenotes> BONUS: however, modid is also a word defined in the EBNF... and I don't think anyone uses it?
11:15:28 <Gracenotes> http://www.haskell.org/onlinereport/modules.html#qualifiers anyway
11:15:36 <ozy`> Plouj: on a similar note, don't say C if you mean C++....
11:15:40 <yip> ozy`: well that depends on what you mean by proper c++. i am talking about "modern" c++ which is pretty much anti c
11:15:44 <Plouj> ozy`: I didn't.
11:15:54 <ozy`> Plouj: all right. :)
11:16:02 <Gracenotes> 5.3.2 is about qualified import, as well. :\
11:16:03 <lilac> ozy`: that's a quite subjective version of "should" you used there ;)
11:16:04 <Plouj> I don't really know C++ other than the part that's similar to C.
11:16:10 <koeien> C++'s main problem is "backwards compatibility" with C
11:16:29 <koeien> Plouj: then you are missing the main point of C++ :)
11:16:35 <yip> koeien: i agree, but it is also the reason for the success of c++
11:16:40 <koeien> yip: indeed.
11:16:50 <int80_h> yeah AT&T through it's marketing strength behind it
11:16:54 <int80_h> threw
11:16:57 <lilac> i don't think C compatibility is so bad. C wasn't a terrible language given its design goals.
11:17:10 <mauke> oooh, is this a flamewar?
11:17:12 <yip> koeien: if c++ didn't care about c compatibility and was designed with elegance in mind then they would have ended up with D :)
11:17:18 <ozy`> lilac: eight-legged tables and dogs are both great. just don't try to combine the two....
11:17:24 <lilac> mauke: we all seem to be agreeing, so i guess not :)
11:17:33 <koeien> ozy`: 100% agreed
11:17:34 <mauke> I can change that!
11:17:36 <lilac> ozy`: except that C++'s design goals are mostly a superset of C's...
11:17:49 * int80_h disagrees on the agreement.
11:17:52 <dolio> mauke: You're completely wrong about everything.
11:17:57 <mauke> NO U
11:18:01 <int80_h> you are
11:18:05 <ozy`> lilac: except in the cases where they directly contradict each other, yes ;)
11:18:22 <nikanj> As someone said, C++ is the english of programming languages. Stealing bits from all over the place, most of the people who use, it use it poorly..
11:18:33 <mauke> that sounds more like perl
11:18:40 <lilac> ozy`: i think most of the problem comes from the details rather than the goals.
11:18:44 <koeien> no! perl is great!!!!!!!!!!!!!!!!!!!!!
11:18:45 <vixey> perl is a superset of C
11:18:49 <vixey> :)))
11:18:52 <lilac> ozy`: things like C's arrays not quite fitting in with C++.
11:18:57 <int80_h> perl is a superset of your mom
11:19:01 <ozy`> nikanj: C++ is more like the Volapük of programming languages, I'd say
11:19:10 <ray> haskell is a subset of FORTRAN
11:19:16 <Gracenotes> -.-
11:19:16 <mauke> your mom is a superset of c++ (i.e. fat)
11:19:24 <lilac> Haskell is a subset of befunge
11:19:36 <koeien> haskell is just assembler with some high-level constructs around it
11:19:44 <vixey> #haskell is a topology of programming languages
11:19:54 <mauke> my friends, different languages can coexist peacefully
11:19:58 <mauke> even in the same file :-)
11:19:59 <trofi> :]
11:20:08 <ray> #haskell is a subset of ##c
11:20:16 <koeien> vixey: that shouldn't be 'topology'. that should be 'nice-space-of-things'
11:20:19 <Gracenotes> malbolge does not exist in ZF interpretation of programming languages
11:20:33 <ozy`> mauke: you demonstrated that nicely in hax.pl
11:20:50 * mauke bows
11:20:54 <lilac> #haskell forms a monoid under disagreement
11:20:55 <vixey> koeien, oh good point, I will call it a  finite-intersectable family-unionable  from now on
11:21:04 <koeien> lol
11:21:12 <Gracenotes> mauke: you made a polyglot? :)
11:21:15 <int80_h> koeien: 'nice-space-of-things-that-like-you-alot'
11:21:22 <nikki93> Perl == cartoon character swearing
11:21:25 <vixey> mauke wrote the sickest polyglot I have ever seen
11:21:46 <ray> haskell = doctoral candidate swearing
11:21:48 <Gracenotes> neat. Could I take a peek?
11:22:07 <nikanj> perl, the only language that enables to be productive on a broken keyboard
11:22:15 <nikanj> +you
11:22:34 <lament> have they released the decoder ring for perl yet?
11:22:37 <mauke> perl: because no ASCII character should go unused
11:22:43 <yip> koeien: why do you need to use pointers with exceptions?
11:22:52 <mauke> Gracenotes: http://mauke.ath.cx/stuff/poly.poly
11:23:03 <ray> perl/APL: because no Unicode character should go unused
11:23:07 <Gracenotes> oh, neat. As featured on reddit :)
11:23:17 <ozy`> mauke: shit, that was you too?!
11:23:26 <Gracenotes> awesome
11:23:35 <mauke> er. my name's in the url :-)
11:23:56 <lilac> mauke: haskell unicode prelude: because no unicode character should go unused?
11:24:40 <Gracenotes> what does #\ do?
11:24:43 <ozy`> mauke: I have a bad habit of not looking at the URL of a page
11:25:06 <mauke> Gracenotes: in what context?
11:25:49 <mauke> hmm, I think perl doesn't use ^@ and ^?, actually
11:25:59 <lament> file a bug
11:26:10 <Gracenotes> hm, never mind... figuring it out :)
11:26:39 <lilac> perl bug#1532: first 1000 characters of /dev/random did not form a legal perl program
11:26:43 <mauke> useful command of the day: :set ff=<language>
11:26:55 <ozy`> mauke: honestly, J puts perl to shame in that regard, from what I've seen. the source code manages to be less comprehensible than malbolge
11:27:17 <Gracenotes> J is stack based, iirc
11:27:27 <ozy`> (about half of the esoteric questions I've asked in here related to attempting to understand J in terms of haskell)
11:27:29 <lilac> ozy`: my favourite part about J is that it takes itself seriously
11:27:35 <ozy`> Gracenotes: like forth? not that I know of....
11:27:54 <lament> Joy is a language that starts with "J" and is stack-based.
11:28:09 <Gracenotes> It seemed to have concatenative-esque syntax... I must be confusing it with something else
11:28:47 <lament> yes
11:28:50 <lament> http://en.wikipedia.org/wiki/Tacit_programming
11:30:53 <int80_h> @type words
11:30:54 <lambdabot> String -> [String]
11:30:58 <blip> how do you do html in Happs ?
11:31:00 <ozy`> Gracenotes: J has a LOT of implicit shortcuts for writing in point-free style... for example, given functions f1 and f2, "f1 + f2" is equivalent to (in haskell) "liftA2 (+) f1 f2"
11:31:39 <Gracenotes> @src liftA3
11:31:39 <lambdabot> Source not found. Just try something else.
11:31:42 <Gracenotes> :>
11:31:46 <Gracenotes> :t liftA3
11:31:47 <lambdabot> forall a b c d (f :: * -> *). (Applicative f) => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
11:32:02 <Gracenotes> :t liftA2
11:32:04 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
11:32:26 <Gracenotes> hm, something to do with arity..
11:32:59 <ozy`> Gracenotes: liftA2 op lhs rhs = \x -> lhs x `op` rhs x
11:33:03 <dolio> You could actually do that in haskell, too, for (+).
11:33:17 <ozy`> dolio: yeah, with instances on Num
11:33:40 <mauke> sounds like fun
11:33:46 <Gracenotes> > liftA2 (+) (*2) (/2) 12
11:33:47 <lambdabot>   30.0
11:34:09 <dolio> Yeah. Who wouldn't love "@check sin^2 + cos^2 == 1"?
11:34:10 <Gracenotes> > liftA2 (+) id id 12
11:34:11 <lambdabot>   24
11:34:55 <dolio> I suppose that wouldn't quite work.
11:34:58 <dolio> Due to (==).
11:35:03 <dolio> But nevertheless.
11:35:34 <Gracenotes> is liftA? generally useful?
11:35:43 <mmorrow> @let pair (<>) f g = \x -> f x <> g x
11:35:44 <lambdabot>  Defined.
11:36:25 <ozy`> @src pair
11:36:25 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
11:36:39 <vixey>   @check sin^2 + cos^2 == 1 -- succeeded, used 1 theorem (pythagoras)
11:36:53 <dolio> :)
11:37:00 <int80_h> @src takeUntil
11:37:01 <lambdabot> Source not found. Take a stress pill and think things over.
11:37:09 <int80_h> @hoogle takeUntil
11:37:09 <lambdabot> No results found
11:37:22 <int80_h> @type takeUntil
11:37:22 <dolio> @check \x -> sin x * sin x + cos x * cos x == 1
11:37:23 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
11:37:24 <lambdabot>   "Falsifiable, after 8 tests:\n-4.166666666666667\n"
11:37:36 <int80_h> @type takeUntil
11:37:37 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
11:37:45 <Gracenotes> hm. is there an approx-equal for QuickCheck?
11:38:07 <mmorrow> @let (&&&&) f g = \(<>) -> (\x -> f x <> g x)
11:38:07 <dolio> @check \x -> sin x * sin x + cos x * cos x - 1 < 0.000001
11:38:08 <lambdabot>  Defined.
11:38:09 <lambdabot>   "OK, passed 500 tests."
11:38:35 <trofi> @check \_ -> 0 == 1
11:38:37 <lambdabot>   "Falsifiable, after 0 tests:\n()\n"
11:38:45 <dolio> That should probably have an abs in there, too.
11:38:47 <int80_h> how can I find which module takeUntil is located in?
11:38:56 <Gracenotes> yeah
11:39:05 <Gracenotes> :i takeUntil
11:39:09 <dolio> takeUntil isn't in a module.
11:39:14 <trofi> @hoogle takeUntil
11:39:14 <lambdabot> No results found
11:39:15 <mmorrow> @let (****) f g = \(><) -> \(p1,p2) -> (\a -> (f . p1) x >< (g . p2) y)
11:39:16 <lambdabot>  Defined.
11:39:18 <dolio> It's something someone @let.
11:39:28 <vixey> :t (****)
11:39:29 <lambdabot> forall b c b1 c1 t1 t. (b -> c) -> (b1 -> c1) -> (c -> c1 -> t1) -> (Expr -> b, Expr -> b1) -> t -> t1
11:39:31 <int80_h> dolio: crap
11:39:44 <mmorrow> aww crap
11:39:45 <dolio> takeUntil p = takeWhile (not . p)
11:40:16 <int80_h> is (not . p) the same as (not(p))?
11:40:16 <ozy`> int80_h: we just defined it earlier, dude
11:40:30 <mmorrow> @let f >< g = \(.><.) -> \(p1,p2) -> (\a -> (f . p1) a .><. (g . p2) a)
11:40:30 <lambdabot>  Defined.
11:40:36 <dolio> not . p = \x -> not (p x)
11:40:36 <ozy`> no, (not . p) is the same as \x -> not (p x)
11:40:36 <int80_h> ozy`: I remember talking about it, I thought it was from a module
11:41:29 <ozy`> int80_h: lucky haskell lets you define functions so easily, no? ;)
11:41:53 <mmorrow> @let f <> g = \(.<>.) -> \(i1,i2) -> (\a -> (i1 . f) a .<>. (i2 . g) a)
11:41:54 <lambdabot>  Defined.
11:42:00 <mmorrow> @type (<>)
11:42:01 <lambdabot>     Ambiguous occurrence `<>'
11:42:01 <lambdabot>     It could refer to either `L.<>', defined at <local>:13:2
11:42:01 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<>', imported from Text.PrettyPrint.HughesPJ at /home/cale/.lambdabot/State/L.hs:55:0-46
11:42:07 <mmorrow> death!
11:42:21 <Gracenotes> L.<>
11:42:22 <int80_h> ozy' one of the many reasons haskell is teh awesome.
11:42:25 <mmorrow> @let f <.> g = \(.<>.) -> \(i1,i2) -> (\a -> (i1 . f) a .<>. (i2 . g) a)
11:42:26 <lambdabot>  Defined.
11:42:27 <Gracenotes> hm.
11:42:33 <mmorrow> @let f >.< g = \(.><.) -> \(p1,p2) -> (\a -> (f . p1) a .><. (g . p2) a)
11:42:34 <lambdabot>  Defined.
11:42:41 <mmorrow> @type (<.>)
11:42:42 <lambdabot> forall a b b1 c c1 t. (a -> b) -> (a -> b1) -> (c -> c1 -> t) -> (b -> c, b1 -> c1) -> a -> t
11:42:51 <mmorrow> @type (>.<)
11:42:52 <lambdabot> forall b c b1 c1 t a. (b -> c) -> (b1 -> c1) -> (c -> c1 -> t) -> (a -> b, a -> b1) -> a -> t
11:45:18 <mmorrow> @type (((^2) .) <.> ((^2) .)) (+) cos sin
11:45:19 <lambdabot>     Couldn't match expected type `((a -> b) -> c1, (a -> b) -> c1)'
11:45:19 <lambdabot>            against inferred type `a1 -> a1'
11:45:19 <lambdabot>     In the second argument of `(((^ 2) .) <.> ((^ 2) .))', namely `cos'
11:46:25 <kiris> sweeeet. a readert monad did the trick
11:46:28 <kiris> getOrderItem :: Statement -> IO OrderItem
11:46:28 <kiris> getOrderItem s = getFields $
11:46:28 <kiris>   OrderItem ← "id" · "name" · "added" · "price" · "quantity" · "size" · "metric"
11:46:34 <mmorrow> @type (cos <.> sin) (+) ((^2),(^2))
11:46:36 <lambdabot> forall a. (Floating a) => a -> a
11:46:47 <mmorrow> > (cos <.> sin) (+) ((^2),(^2)) pi
11:46:48 <lambdabot>   1.0
11:47:04 <kiris> uh, s/s//
11:47:44 <kiris> hm
11:47:50 <kiris> @where paste
11:47:50 <lambdabot> http://hpaste.org/new
11:47:54 <kiris> @where hpaste2
11:47:55 <lambdabot> http://moonpatio.com:8080/
11:48:01 <Gracenotes> > (length <.> head) (flip (:)) (show, head) ["yes", "no", "maybe"]
11:48:02 <lambdabot>   "y3"
11:48:32 <mmorrow> > fmap ((cos <.> sin) (+) ((^2),(^2))) ((randoms . mkStdGen) 98284 :: [Double])
11:48:33 <lambdabot>   [1.0,1.0,1.0,1.0,1.0,0.9999999999999998,1.0,1.0000000000000002,0.9999999999...
11:48:55 <Gracenotes> intresting
11:49:06 <Gracenotes> e, even
11:49:17 <tromp__> > [1.0,2.0 .. 2.51]
11:49:18 <lambdabot>   [1.0,2.0,3.0]
11:49:25 <tromp__> > [1.0,2.0 .. 2.49]
11:49:26 <lambdabot>   [1.0,2.0]
11:49:42 <augustss> :t <.>
11:49:43 <lambdabot> parse error on input `<.>'
11:49:50 <tromp__> > [1.0,1.5 .. 2.51]
11:49:51 <lambdabot>   [1.0,1.5,2.0,2.5]
11:49:51 <augustss> :t (<.>)
11:49:52 <lambdabot> forall a b b1 c c1 t. (a -> b) -> (a -> b1) -> (c -> c1 -> t) -> (b -> c, b1 -> c1) -> a -> t
11:49:56 <mmorrow>  @let f <.> g = \(.<>.) -> \(i1,i2) -> (\a -> (i1 . f) a .<>. (i2 . g) a)
11:49:56 <kiris> mmorrow: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=840#a840
11:50:06 <mmorrow>  @let f >.< g = \(.><.) -> \(p1,p2) -> (\a -> (f . p1) a .><. (g . p2) a)
11:50:06 <tromp__> > [1.0,1.5 .. 2.49]
11:50:06 <kiris> mmorrow: any chance of changing to something not red?
11:50:08 <lambdabot>   [1.0,1.5,2.0,2.5]
11:50:15 <mmorrow> kiris: red?
11:50:25 <augustss> @djinn  (a -> b) -> (a -> b1) -> (c -> c1 -> t) -> (b -> c, b1 -> c1) -> a -> t
11:50:25 <lambdabot> f a b c (d, e) f = c (d (a f)) (e (b f))
11:50:27 <kiris> well, pink background on the operators
11:50:33 <tromp__> > [1.0,1.5 .. 2.26]
11:50:34 <augustss> oh, ok
11:50:34 <lambdabot>   [1.0,1.5,2.0,2.5]
11:50:38 <mmorrow> kiris: ugh
11:50:38 <tromp__> > [1.0,1.5 .. 2.24]
11:50:40 <lambdabot>   [1.0,1.5,2.0]
11:51:02 <mmorrow> kiris: i'll try to find it
11:51:18 <kiris> mmorrow: cheers ears
11:51:57 <Gracenotes> so <.> is like a double liftA2
11:52:24 <int80_h> @type takeUntil
11:52:25 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
11:52:53 <mmorrow> Gracenotes: something like that
11:54:45 <int80_h> @paste
11:54:45 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:54:59 <int80_h> that's not the url for hpaste anymore
11:55:23 <ski_> @where paste2
11:55:23 <lambdabot> I know nothing about paste2.
11:55:27 <ski_> @where hpaste2
11:55:27 <lambdabot> http://moonpatio.com:8080/
11:55:33 <int80_h> that's it
11:55:34 <ski_> ?
11:55:45 <vixey> ?where moonpaste
11:55:45 <lambdabot> http://moonpatio.com:8080/
11:57:04 <roconnor> http://en.wikipedia.org/wiki/Type_soundness -- FIX ME!!
11:57:23 <dolio> Hehehehe.
11:57:59 <dolio> A type system is sound if programs without type errors don't have type errors.
11:58:08 <mmorrow> Saizan: that brainfuck interpreter is pretty cool
11:58:27 <mmorrow> i've gotta learn about Control.Monad.Prompt
11:58:58 <dolio> Of course, I don't have a good definition myself.
11:59:06 <ozy`> dolio: yeah but "does the program have type errors?" is unanswerable in many languages unless you actually run the program
11:59:50 <ozy`> so phrased another way: "type soundness is the property of a language where the type system does not provide ways to circumvent itself."
12:00:07 <ozy`> or not.
12:00:09 * ozy` shrugs
12:00:15 <dolio> That's pretty good, I suppose.
12:01:02 <dolio> Or, I suppose it's not the type system that allows circumventing itself, but language constructs that allow you to circumvent the type system.
12:01:13 <dolio> Or primitives, or whatever.
12:04:20 <Saizan> like undefined?
12:05:00 <dolio> Like unsafeCoerce.
12:05:29 <roconnor> seq--
12:05:39 <dolio> undefined is merely a value that belongs to every type.
12:05:50 <roconnor> dolio: I wouldn't say that
12:05:59 <dolio> unsafeCoerce lets you, for example, pass an integer to a function that expects a list.
12:06:11 <roconnor> undefined is a polymorphic function that returns a value for every type
12:06:24 <mauke> undefined is not a function :(
12:06:25 <roconnor> but you know, tomato tomato
12:06:35 <roconnor> ... that doesn't really translate to IRC
12:06:50 <mmorrow> @check "tomato" == "tomato"
12:06:51 <lambdabot>   "OK, passed 500 tests."
12:06:53 <mauke> tomato oʇɐɯoʇ ｔｏｍａｔｏ
12:07:06 <mmorrow> @check "tomato" == "oʇɐɯoʇ"
12:07:07 <lambdabot>   "Falsifiable, after 0 tests:\n"
12:07:25 <mauke> :/to2/ma3/tog
12:07:37 <roconnor> mauke: it depends on your system
12:07:44 <roconnor> undefined is certainly a function in System F
12:08:06 <mauke> does it take a type?
12:08:21 <vixey> undefined : forall P, P  -- I guess ?
12:08:46 <roconnor> @type undefined
12:08:47 <lambdabot> forall a. a
12:09:01 <dolio> Well, whatever you want to call it, it's not a violation of soundness.
12:09:01 <int80_h> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=841#a841
12:09:22 <int80_h> could someone take a peek at my code?
12:09:35 <vixey> but in haskell instantiation is implicit
12:09:35 <int80_h> it's an attempt at exercise 2, chapter 4 RWH
12:10:07 <roconnor> I think it is a violation of soundness. because it violates logical soundness
12:10:34 <dolio> But that's not the kind of soundness that article is about.
12:10:37 <trofi> takeWhile (not. ...) ?
12:10:47 <trofi> :t not
12:10:48 <lambdabot> Bool -> Bool
12:11:14 <vixey> definition of "soundness"?
12:11:15 <augustss> int80_h: takeWhile (not . p')
12:11:49 <vixey> oh it's a definition you are looking for
12:11:49 <dolio> Not that it's much of an article, currently.
12:11:50 <augustss> vixey: in logic?  you can't derive the false statement
12:12:13 <vixey> but in type systems
12:12:14 <int80_h> augustss: trying to not use notation yet to be introduced in the material.
12:12:30 <vixey> type soundness I thought means, you can never interpret an object of one type as on object of another type
12:12:33 <roconnor> soundness is a synax to semantics connection
12:12:38 <roconnor> maybe it is logical sound
12:12:43 <roconnor> given Haskell's inconsistent semantics
12:12:44 <int-e> int80_h: well the 'x' you use there isn't the one you want
12:12:47 <vixey> (but I don't meant uniqueness of types here)
12:15:09 <int80_h> int-e: it's not?
12:16:21 <gr00ber> sup
12:17:32 <roconnor> what's down with hpaste.org?
12:17:46 <roconnor> memory leak?
12:18:27 <Saizan> maybe harddisk space on the server
12:18:54 <ozy`> @src pure
12:18:54 <lambdabot> Source not found. Take a stress pill and think things over.
12:18:56 <int80_h> int-e : If the x from "case takeUntil p x ..." isn't the one I want, I don't know which one is.
12:19:01 <ozy`> @hoogle pure
12:19:01 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
12:19:01 <lambdabot> Control.Arrow pure :: Arrow a => (b -> c) -> a b c
12:19:01 <lambdabot> package pureMD5
12:19:28 <omegaman> could anyone provide a use-case for multiple nesting-levels for functions (with closure semantics)? I'm implementing something Haskell-like, but want a simple closure implementation
12:19:33 <omegaman> don't see the need
12:21:18 <int-e> @src (.)
12:21:19 <lambdabot> (f . g) x = f (g x)
12:21:20 <int-e> int80_h: You need to give it a name.  takeWhile (\z -> not (p z)), say, which is what augustss suggested.
12:22:04 <gwern> ....threadPool was the 1000th package
12:22:09 <gwern> the irony, it's killing me!
12:22:22 <gwern> *I* was thinking about cabalizing and uploading threadPool
12:22:41 <Gracenotes> hooray, powers of 10
12:22:58 <int-e> > 2^10
12:23:00 <lambdabot>   1024
12:23:05 <ozy`> omegaman: to be clear... are you saying you'd allow toplevel functions to have their own local functions, but local functions can't have other local functions within them?
12:23:18 <augustss> Damn!  I missed with only a couple of hours. :)
12:23:23 <omegaman> ozy`, that was the suggestion
12:23:24 <Gracenotes> int-e: I don't have 2 fingers, do you? :P
12:23:32 <int-e> Gracenotes: I have 2, and then some.
12:23:52 <augustss> Gracenotes: 10 fingers, just enough to count to 1023
12:24:00 <int-e> Gracenotes: 8 total, and 2 thumbs ;)
12:24:07 <omegaman> ozy`, this is an imperative language, but with closures and nested functions
12:24:26 <Gracenotes> augustss: that's quite true, if you allow orderings
12:24:41 <augustss> Gracenotes: my fingers are ordered!
12:24:47 <int80_h> int-e : I've found it very educational to restrict myself to only parts of the language that have been introduced. If I can't use lambda functions, and I can't use . notation, how can I express this correctly?
12:24:55 <int-e> > 0o2000
12:24:57 <lambdabot>   1024
12:25:06 <Gracenotes> augustss: you might think something is 1, but someone else knows it's 1024 :)
12:25:11 <int-e> int80_h: takeWhile p' where p' x = not (p x)
12:25:24 <int-e> int80_h: but you're really making this uneccessarily hard for yourself, IMHO.
12:25:30 <Gracenotes> or is that 512. (argh)
12:25:41 <int-e> *unnecessarily
12:26:27 <Gracenotes> indeed, it is 512. Off-by-one errors are so much more difficult to think about in base 2...
12:27:25 <int80_h> int-e : I've already had a pay-off. Being forced to pay attention to certain details reveals otherwise hard to see details of the language.
12:27:54 <omegaman> ozy`, so... is it crazy? :)
12:27:54 <int80_h> int-e: I mean, being forced to adhear to certain restrictions ...
12:28:04 <int80_h> adhere
12:28:09 <int80_h> ugh, you get my point.
12:28:16 <ozy`> omegaman: yeah, it sounds crazy to me. I can't imagine such functions being very useful :p
12:28:23 <omegaman> huh?
12:28:24 <Gracenotes> anyway, I'm not so sure we'd think about the 1000th package unless we used base 10 >_> yeah...
12:28:27 <ozy`> how would it help the implementation anyway?
12:28:35 <int80_h> int-e: so you want me to redefine takeWhile?
12:28:36 <omegaman> ozy`, maybe we talk about different things
12:28:57 <int80_h> int-e: or was that supposed to be takeUntil?
12:29:29 <int-e> int80_h: that was the body of takeUntil
12:29:52 <omegaman> ozy`, see http://lambda-the-ultimate.org/node/3184 :)
12:30:36 <omegaman> with that i could do times5 = func(5);   times5(4);  => 20
12:30:41 <omegaman> very useful closure mechanism
12:30:46 <omegaman> using only one nesting level
12:31:18 <ozy`> omegaman: yeah that's what I thought you meant. and I meant they wouldn't be nearly as useful as in haskell
12:31:42 <omegaman> could you elaborate on why?
12:31:58 <omegaman> i don't dispute you, just don't understand why yet ;)
12:32:44 <RayNbow> hmm, anyone here familiar with LINQ?
12:32:55 <ozy`> omegaman: well for one thing, it prohibits curried functions. in haskell, the lambda syntax (\x y -> x * y) is syntactic sugar for (\x -> \y -> x * y)
12:33:16 <omegaman> hm, didn't realize currying required multiple nesting levels
12:33:23 <islon_s``> i tried to make a linq-like dsl in haskell but without success
12:33:24 * RayNbow is trying to find the unit function in LINQ...
12:33:43 <RayNbow> but the closest thing I can find so far is IEnumerable.Select
12:33:55 <RayNbow> which is somewhite like a combination of bind and unit
12:34:02 <RayNbow> *somewhat
12:34:18 <ski_> instead of `\x y -> x * y' you could have `\(x,y) -> x * y' and partially apply on use
12:35:58 <ski_> (omegaman,ozy` : ^)
12:36:18 <omegaman> hm, not sure what that means
12:36:34 <omegaman> you'd need some kind of memoization for that?
12:36:37 <Gracenotes> :t curry
12:36:39 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
12:36:51 <ozy`> ski_: true :p not quite as convenient as currying, sadly...
12:36:53 <Gracenotes> a.k.a. ((a, b) -> c) -> (a -> b -> c)
12:36:56 <ski_> you don't need to represent "multiple-argument" functions in the curried fashion
12:37:22 <idnar> Python has partial() for partial application, without currying
12:37:56 <ski_> ozy` : e.g. if `f' is bound to `\(x,y) -> x * y', then to partially apply it on `5', you do `\y -> f (5,y)', which seems to obey your "only one nesting level" criterion
12:38:10 <ski_> er s/ozy`/omegaman/
12:38:20 <ski_> (stop having the same initial letter !)
12:38:26 <omegaman> heh
12:38:30 <omegaman> ski_, ok, i think i get it
12:38:32 <idnar> uhm, so, "times5 = func(5);   times5(4);  => 20" -- Haskell already works like that
12:38:44 <omegaman> idnar, i know
12:38:54 <omegaman> idnar, my idea was that one nesting level was useful :)
12:38:55 <ski_> omegaman : and, you might introduce a syntactive shorthand to `\y -> f (5,y)' in your language, too
12:39:04 <omegaman> ski_, yeah
12:39:19 <omegaman> ski_, just don't want to scare off the bracket dudes
12:39:34 <ski_> (who are they ?)
12:39:45 <omegaman> (imperative dudes like me) :)
12:40:06 <\ozy`> omegaman: anyway, how would the "only one nested level" restriction soften the problems involved in implementing closures? (especially if you're allowing modification of closed-over variables... which you haven't said you are, but still)
12:40:54 * ski_ wonders how complicated a multi-level to one-level transformation would be ? (e.g. would it be local ?)
12:40:56 <omegaman> \ozy`, i currently use a heap allocated structure for the closed-over variables. Another nesting level would imply a (static?) link to the upper level
12:41:14 <vixey> closure conversion? non local
12:41:15 <omegaman> i've seen both flat structures and structures with links
12:41:47 <ski_> vixey : omegaman wants to allow one nesting level of closure, but no more
12:41:59 <vixey> like C?
12:42:00 <\ozy`> omegaman: what happens when you return a function that modifies a variable in the parent function's stack?
12:42:09 <omegaman> vixey, you can't nest in C
12:42:25 <ski_> vixey : in C, you can't define a local function inside a top-level one
12:42:25 <omegaman> \ozy`, you update the variables in the heap allocated structure
12:43:05 <vixey> oh gcc accepts int f() { int g() { int h() { return 1; }; return h(); }; return g(); }
12:43:10 <ski_> i.e. `foo(x,xs) = map((\y -> x*y),xs)' is o-k to omegaman
12:43:12 <omegaman> \ozy`, since every variable that escapes is heap allocated, you don't access the parent stack
12:43:29 <ski_> vixey : yes, gcc accepts any nesting level :)
12:43:40 <omegaman> gcc'ism...
12:43:51 <\ozy`> gcc is a little odd for a C compiler....
12:43:52 <idnar> vixey: I don't think the nested function(s) close over the outer function(s), though
12:43:57 <omegaman> apple even has a closure patch for gcc
12:43:57 <idnar> ie. it's just a namespace nesting
12:44:00 <idnar> although ICBW
12:44:01 <killerboy> hi
12:44:01 <ski_> (but won't guarantee nonlocals are live at later calls)
12:44:18 <killerboy> Cale: hi
12:44:19 <\ozy`> omegaman: you mean for clang?
12:44:33 <ski_> idnar : i think the inner functions can refer to locals in the outer ones, yes
12:44:34 <omegaman> \ozy`, no, for gcc
12:44:38 <omegaman> gcc-llvm, maybe
12:44:46 <omegaman> ^(...) syntax
12:44:53 <\ozy`> that's in clang.
12:44:59 <islon_s``> where can i see the source for Prelude?
12:45:13 <omegaman> \ozy`, clang is the new frontend
12:45:17 <athos_> @hoogle alpha
12:45:17 <lambdabot> Language.Haskell.TH.Lib alpha :: [(Name, Name)] -> Name -> ExpQ
12:45:17 <lambdabot> Test.QuickCheck.Poly type ALPHA = Poly ALPHA_
12:45:17 <lambdabot> Distribution.System Alpha :: Arch
12:45:23 <athos_> :_
12:45:29 <\ozy`> omegaman: yep.
12:45:46 <vixey> :t \(`ozy`) -> ozy
12:45:47 <lambdabot> parse error on input `)'
12:46:04 <tromp__> google for Prelude.hs
12:46:07 <vixey> :t let ozy (`ozy`) = ozy in ozy
12:46:08 <lambdabot> parse error on input `)'
12:46:13 <vixey> why is this not allowed
12:46:43 <\ozy`> :t \ozy -> (`ozy`)
12:46:44 <lambdabot> parse error on input `)'
12:46:47 <\ozy`> huh
12:46:59 <tromp__> :t `mod`
12:47:00 <lambdabot> parse error on input ``'
12:47:19 <trofi> :t (`mod`)
12:47:19 <ski_> @type \ozy x -> (x `ozy`)
12:47:21 <lambdabot> forall t t1. (t -> t1) -> t -> t1
12:47:21 <lambdabot> parse error on input `)'
12:47:39 <tromp__> prolly because you're not using it as infix
12:47:42 <Deewiant> vixey: it's redundant
12:47:57 <vixey> :t \(ozy`ozy`ozy) -> ozy
12:47:58 <lambdabot> Parse error in pattern
12:48:02 <ski_> @type \ozy x -> (`ozy` x)
12:48:03 <lambdabot> forall t t1 t2. (t1 -> t -> t2) -> t -> t1 -> t2
12:48:06 <vixey> :t let ozy (ozy`ozy`ozy) = ozy in ozy
12:48:07 <lambdabot> Parse error in pattern
12:48:10 <trofi> , let f a = show a int 5 `a`
12:48:11 <lunabot>  luna: parse error on input `)'
12:48:14 <trofi> > let f a = show a int 5 `a`
12:48:16 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:48:16 <Deewiant> vixey: you can't pattern match against functions
12:48:26 <trofi> > let f a = show a in 5 `f`
12:48:28 <lambdabot>   <no location info>: parse error on input `;'
12:48:39 <trofi> , let f a = show a in 5 `f`
12:48:40 <Deewiant> trofi: sections must be in parentheses
12:48:40 <lunabot>  luna: parse error on input `)'
12:48:45 <\ozy`> omegaman: http://lists.cs.uiuc.edu/pipermail/cfe-dev/2008-August/002670.html <== is this what you mean?
12:49:02 <trofi> Deewiant: which sections?
12:49:06 <int80_h> int-e: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=841#a842
12:49:06 <ski_> vixey : apparently  (`foo`)  is not allowed. only  (+)  and  (x `foo`)  and  (`foo` y)
12:49:11 <tromp__> :t (1 `ozy`)
12:49:12 <lambdabot> Not in scope: `ozy'
12:49:13 <\ozy`> I guess it's in both gcc and clang
12:49:20 <vixey> :t \(`ozy`ozy) -> ozy
12:49:21 <lambdabot> Parse error in pattern
12:49:21 <Deewiant> trofi: (1 +), (`foo` 1) are examples of sections
12:49:28 <blip> how do you do html in Happs ?
12:49:37 <trofi> ah
12:49:41 <trofi> , let f a = show a in (5 `f`)
12:49:42 <lunabot>  luna: Couldn't match expected type `t1 -> t'
12:49:43 <ski_> @type \(x +) -> ()
12:49:43 <int80_h> int-e: that was my attempt at adding your lines. Not sure where I hosed it. I'm hoping it's just indentation, and I can just fine tune once it's right
12:49:43 <\ozy`> :t \ozy -> (ozy` ozy`)
12:49:44 <lambdabot> Parse error in pattern
12:49:44 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
12:49:44 <lambdabot>     Probable cause: `ozy' is applied to too many arguments
12:49:44 <lambdabot>     In the expression: (ozy `ozy`)
12:49:47 <ski_> @type \(x *) -> ()
12:49:47 <omegaman> \ozy`, i'm aware of the work on Blocks, yes. But GCC already has closures in the Apple tree. never got backported to GCC
12:49:48 <lambdabot> Parse error in pattern
12:49:51 <trofi> > let f a = show a in (5 `f`)
12:49:53 <lambdabot>   "5"
12:49:57 <ski_> @type \(*) -> ((),(*))
12:49:58 <lambdabot> forall t. t -> ((), t)
12:50:06 <trofi> is it ghc-6.10 bug?
12:50:16 <Deewiant> trofi: no, it's a feature, since it's not allowed in H98
12:50:27 <trofi> ah
12:50:29 <Deewiant> trofi: there's a -X flag to make it work again, I forget what it's called
12:50:51 <trofi> since it needs parens - not very useful
12:51:13 <int80_h> @seen int-e
12:51:13 <lambdabot> int-e is in #ghc, #haskell-overflow and #haskell. I last heard int-e speak 21m 42s ago.
12:51:23 <Deewiant> trofi: it was used somewhere for stuff like (5 `seconds`)
12:51:42 <trofi> yeah :] xmonad-contrib-0.8
12:51:57 <int80_h> does anyone else want to take a look?
12:51:59 <\ozy`> :t \(?) -> (?)
12:51:59 <int80_h> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=841#a842
12:52:00 <lambdabot> forall t. t -> t
12:52:11 <\ozy`> @pl \(?) -> (?)
12:52:12 <lambdabot> (line 1, column 3):
12:52:12 <lambdabot> unexpected "?"
12:52:12 <lambdabot> expecting pattern
12:52:16 <\ozy`> damn
12:52:46 <dolio> @pl \(*) x y -> x * y
12:52:46 <lambdabot> (line 1, column 3):
12:52:47 <lambdabot> unexpected "*"
12:52:47 <lambdabot> expecting pattern
12:53:14 <islon_s``> what this means? "infixl 6 +"
12:53:14 <dolio> Huh. Guess it doesn't do operator parameters at all.
12:53:31 <\ozy`> guess it doesn't grok operators as variable names
12:54:14 <dolio> It means the + operator has precedence 6, and associates left (so 1 + 2 + 3 = (1 + 2) + 3)
12:54:14 <Deewiant> islon_s``: it means + is left associative (infixl as opposed to infixr or just infix) and has precedence 6
12:56:02 <islon_s``> so i can set myFunction infix and its precedence?
12:56:31 <dolio> `myFunction` is the operator version of myFunction.
12:56:45 <dolio> But you can set its fixity and precedence.
12:56:53 <islon_s``> yeah but i can do "infixl myFunction 3"?
12:56:56 <ski_>   infixr 5 `myFunction`
12:57:10 <\ozy`> oh shit you can do that for individual functions?
12:57:23 <dolio> Yes.
12:57:31 <idnar> :)
12:57:32 <islon_s``> cool
12:57:41 <\ozy`> the default is 4, right?
12:57:42 <ski_>   infix 4 `elem`
12:57:44 <dolio> > let infixr 5 cons ; cons = (:) in 5 `cons` 6 `cons` 7 `cons` []
12:57:45 <lambdabot>   <no location info>: parse error on input `cons'
12:57:49 <ski_> is in the prelude, i think
12:57:57 <dolio> > let infixr 5 `cons` ; cons = (:) in 5 `cons` 6 `cons` 7 `cons` []
12:57:58 <lambdabot>   [5,6,7]
12:58:05 <dolio> > let cons = (:) in 5 `cons` 6 `cons` 7 `cons` []
12:58:06 <lambdabot>       No instance for (Num [t])
12:58:06 <lambdabot>        arising from the literal `6' at <inter...
12:58:12 <int80_h> I had to leave for a sec, did I get any response?
12:58:16 <\ozy`> @src car
12:58:17 <lambdabot> Source not found. Just what do you think you're doing Dave?
12:58:38 <ski_> istr recall the default is `infixl' .. not sure about the level .. maybe `0'
12:59:08 <dolio> 9, I believe.
12:59:09 <ski_> > let snoc = flip (:) in [] `snoc` 7 `snoc` 6 `snoc` 5
12:59:10 <lambdabot>   [5,6,7]
12:59:50 <Holle_> what is the simplest way to change the n-th value of a list? [1,2,4] -> [1,7,4]
12:59:56 <ski_> @src elem
12:59:56 <lambdabot> elem x    =  any (== x)
13:00:04 <ski_> that ought to include
13:00:07 <ski_>   infix 4 `elem`
13:00:08 <ski_> imo
13:00:40 <ski_> Holle_ : `splitAt', maybe ?
13:01:02 <ski_> Holle_ : why do you want this ?
13:01:25 <vixey> Holle_, not worrying about simple but if you just wrote a function do it then you could use that
13:01:32 <dolio> Wanting to set a particular element of a list usually isn't a good sign.
13:01:42 <Holle_> yes. splitAt is a good idea!
13:01:47 * ski_ grins
13:01:50 <islon_s``> infix doesnt remove the ` need
13:01:57 <ski_> islon_s`` : correct
13:03:01 <mmorrow> kiris: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=840
13:03:23 <mmorrow> kiris: bueno?
13:03:41 <islon_s``> what if i have a "Player" data wich hold some player attributes (statefull data)? i have to use some state monad? IO?
13:03:57 <Holle_> dolio: i have got a list I =[0,1,2,1,4,2,1,3] and a list L = [(2,0),(4,0),(1,0)...] and want to increase the second element of a tupel out of L when an element of I is the index of L
13:04:59 * thoughtpolice waves to #haskell
13:05:26 <ski_> islon_s`` : is you prefer, you can just pass it around in arguments and results
13:05:40 <augustss> Holle_: Maybe you should consider accumArray
13:05:41 <ski_> islon_s`` : it might be nicer to use some state monad, though
13:06:12 <Holle_> i don't know what accumArray is so i take splitAt ^^
13:06:44 <ski_> @hoogle accumArray
13:06:45 <lambdabot> Data.Array.Base accumArray :: (IArray a e, Ix i) => e -> e' -> e -> e -> (i, i) -> [(i, e')] -> a i e
13:06:45 <lambdabot> Data.Array.IArray accumArray :: (IArray a e, Ix i) => e -> e' -> e -> e -> (i, i) -> [(i, e')] -> a i e
13:06:45 <lambdabot> Data.Array.Base unsafeAccumArray :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(Int, e')] -> a i e
13:06:47 <islon_s``> it's hard to stop thinking in OO
13:06:51 <drdozer> right, my program finally crashed
13:07:05 <drdozer> :D
13:07:07 <vixey> islon_s``, it's even harder to stop thinking all together
13:07:18 <kiris> ~Zen~
13:07:24 <islon_s``> budhism
13:07:57 <kiris> > length $ filter (=='d') $ "buddhism"
13:07:59 <lambdabot>   2
13:08:53 <islon_s``> ¬¬
13:09:20 <pumpkin> bah bah bah
13:09:22 <pumpkin> minimal: internal error: freeGroup: block size is zero
13:09:24 <pumpkin>     (GHC version 6.10.1 for x86_64_unknown_linux)
13:09:26 <pumpkin>     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
13:09:28 <pumpkin> :(
13:10:54 <drdozer> http://pastebin.com/m4d5799fe
13:10:58 <vixey> "Now, to simplify the closure implementation, I only allow one nesting level. Is this overly restrictive? What does other languages do?"
13:11:05 <vixey> How on earth does this make it simpler?
13:11:22 <drdozer> can anyone see what in that block of code could be leading to my program dieing with a stack overflow?
13:11:49 <pmurias> hi, what's a good introduction to FRP?
13:12:44 <yip> pmurias: i would start by reading this: http://conal.net/fran/tutorial.htm
13:18:19 <Gracenotes> @check \x y -> x/y == (1/y)/(1/x)
13:18:20 <lambdabot>   "Falsifiable, after 1 tests:\n0.0\n0.0\n"
13:18:34 <Gracenotes> -_-
13:19:10 <dolio> > 0/0 == 0/0
13:19:12 <lambdabot>   False
13:19:25 <trofi> :t NaN
13:19:25 <Gracenotes> @check \x y -> if x == 0 || y == 0 then True else x/y == (1/y)/(1/x)
13:19:26 <lambdabot>   "Falsifiable, after 10 tests:\n2.5\n4.333333333333333\n"
13:19:26 <lambdabot> Not in scope: data constructor `NaN'
13:20:39 <Gracenotes> hm
13:20:44 <Gracenotes> @check \x y -> if x == 0 || y == 0 then True else x/y == (1/y)/(1/x)
13:20:44 <lambdabot>   "Falsifiable, after 3 tests:\n1.5\n-2.75\n"
13:20:58 <pmurias> yip: and after that?
13:21:14 <\ozy`> drdozer: is there a reason the type signature doesn't seem to match the function declaration?
13:22:04 <cytzol> Hi #haskell! I have a function that takes a string like "size<12" and returns a tuple like ("size", (<12)). What's the best way to test the tuple in quickcheck or hunit or similar?
13:22:11 <drdozer> \ozy`, type NetGen n m = NodeGen (Node n) m -> EdgeGen (Edge n) m -> m n
13:22:22 <cytzol> Functions aren't Eq-able, and it doesn't feel right throwing values at the function to see what it is.
13:22:24 <\ozy`> drdozer: that's what I thought
13:22:31 <drdozer> \ozy`, :D
13:22:49 <Heffalump> cytzol: test it for what?
13:23:09 <cytzol> Test it to see what the function is
13:23:23 <Heffalump> sorry, I don't follow what you mean
13:24:03 <cytzol> ok
13:25:19 <Gracenotes> :t (<.>)
13:25:20 <cytzol> If the function were to take "size<12" and return ("size", '<', 12), I could test its correctness using quickcheck
13:25:20 <lambdabot> forall a b b1 c c1 t. (a -> b) -> (a -> b1) -> (c -> c1 -> t) -> (b -> c, b1 -> c1) -> a -> t
13:25:35 <islon_s``> you can derive classes instances and data or only classes?
13:25:36 <\ozy`> drdozer: anyway, without the rest of the code (or knowing what exactly it's supposed to do) I'd make a wild guess that the n*n edge generation is your issue... try playing around with strictness?
13:26:29 <drdozer> \ozy`, it does seem to be the n*n that is the parameter that makes it crash
13:26:53 <drdozer> forM = flip mapM, yes?
13:26:57 <\ozy`> drdozer: yep
13:28:01 <\ozy`> what kind of values of n are we looking at here?
13:28:15 <\ozy`> 100? 1000? 10,000?
13:28:27 <Gracenotes> @instances Applicative
13:28:28 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
13:28:43 <drdozer> \ozy`, it bombs out for 1000
13:28:50 <drdozer> it runs for 100
13:29:06 <CakeProphet> I don't really get the examples for GADTs. for example, how do the constructors return meaningful values when they're only defined by type signature?
13:29:23 <\ozy`> drdozer: so it can't handle a list of a million (i,j) pairs....
13:29:55 <augustss> CakeProphet: constructors don't return any values, except themselves.
13:30:10 <CakeProphet> right but what does
13:30:25 <drdozer> \ozy`, no - but it only passes that list on to a mapM (putStr.show) further down, so I would expect that the pairs would be made lazily
13:30:33 <CakeProphet> data Term where Pair :: Term a -> Term a -> Term (a,a)
13:30:35 <CakeProphet> produce
13:30:47 <CakeProphet> (that's not the type signature, but what if it was)
13:31:22 <Gracenotes> is (-> t) an instance of Applicative?
13:31:23 <augustss> That gives you a Pair constructor, just like data Term a = Pair a a
13:31:25 <Cale> CakeProphet: "produce"? You mean if you apply the Pair constructor to two other appropriate terms?
13:31:25 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
13:31:30 <byorgey> that means that Pair is a function of type  Term a -> Term a -> Term (a,a), i.e. you can use 'Pair' to construct a value of type  Term (a,a)  out of two values of type  Term a.
13:31:33 <CakeProphet> Cale:  yes.
13:31:48 <vixey> CakePhohpet, most the stuff I use GADTs for is completely unrelated to these silly examples
13:31:53 <CakeProphet> Cale:  (in this case it would never terminate, but I omitted other constructors for brevity)
13:31:55 <Cale> CakeProphet: It produces the application of that constructor to those terms.
13:32:18 <CakeProphet> right... but how does it know which operand goes where.
13:32:21 <CakeProphet> in terms of order
13:32:24 <Cale> Huh?
13:32:25 <CakeProphet> if they have the same type, for instance.
13:32:30 <Cale> I don't understand.
13:32:31 <byorgey> it's the order in which they're declared.
13:32:36 <augustss> CakeProphet: writing 'data T a = C a' and 'data T a where C :: a -> T a' is exactly the same
13:32:52 <CakeProphet> I understand... but what if the type signature is ambiguous
13:33:00 <Cale> How is it ever ambiguous?
13:33:23 <byorgey> CakeProphet: if you write  'Pair x y', then the x is the first  Term a,  and the y is the second.
13:33:23 <CakeProphet> Pair :: a -> a -> (a, a)
13:33:23 <CakeProphet> Pair :: a -> a -> Pair (a, a)
13:33:23 <CakeProphet> rather
13:33:23 <CakeProphet> what then
13:33:28 <CakeProphet> does Pair 1 2 produce?
13:33:35 <augustss> CakeProphet: Pair 1 2
13:33:35 <Cale> Pair 1 2
13:33:37 <vixey> CakeProphet: Pair 1 2 = Pair 1 2
13:33:40 <Cale> That's already fully evaluated.
13:33:59 <CakeProphet> that violates the type signature...
13:34:00 <Cale> It's a value of type Pair (Integer, Integer)
13:34:03 <augustss> No
13:34:15 <vixey> Pair :: a -> a -> Pair (a, a)
13:34:22 <vixey> Pair 1 :: Integer -> Pair (Integer, Integer)
13:34:26 <vixey> Pair 1 2 :: Pair (Integer, Integer)
13:34:42 <CakeProphet> hmmm... what use is that?
13:34:44 <augustss> You should regard the type parameter as a phantom type
13:34:48 <\ozy`> drdozer: hmm, "rnf [(i,j) | i <- [1..1000], j <- [1..1000]]" runs quickly and cleanly on my machine (which is a bucket of bolts, less than a gig of ram)
13:34:51 <vixey> CakeProphet, this Pair thing is useless..
13:34:55 <int80_h> @seen int-e
13:34:56 <lambdabot> int-e is in #ghc, #haskell-overflow and #haskell. I last heard int-e speak 1h 5m 25s ago.
13:35:01 <int80_h> esh
13:35:18 <\ozy`> wait, I'm doing it wrong
13:35:20 <CakeProphet> right... but what is the use of constructing arbitrary types from multiple fields.
13:35:21 <int-e> hmm?
13:35:23 <nomeata> Hi. On hackage resp. cabal, is there a value where I would name the darcs repository (similar to Vcs-Darcs: in Debian packages)?
13:35:28 <Holle_> how to get the index of an element in a list?
13:35:31 <Cale> vixey: why? He said he left out other constructors.
13:35:41 <nomeata> If not, is there a name-space for inofficial fields? X-Darcs-Repos?
13:35:41 <augustss> CakeProphet: you should look at some examples
13:35:43 <CakeProphet> and what would happen if I did something like Pair :: a -> a -> Pair String
13:35:45 <int80_h> int-e: hi, I just wanted to talk to you about my code. Let me bring it up on moonpatio
13:35:47 <CakeProphet> I did, they confuse me
13:35:53 <vixey> CakeProphet, one other thing you should know (which is the real reason GADTs are useful), is when you pattern match the type is specialized
13:35:53 <int80_h> @where hpaste2
13:35:53 <lambdabot> http://moonpatio.com:8080/
13:35:56 <Cale> CakeProphet: The type parameter can be used for whatever purposes you want.
13:36:13 <drdozer> this runs quickly: mapM (putStr.show) [(i, j) | i <- [1..1000], j <- [1..1000]]
13:36:16 <augustss> CakeProphet: Pair String is fine.  If you can use it in a meaningful way is another matter.  It's up to you
13:36:22 <Cale> CakeProphet: For example, it might be the type of the result of evaluating some expression in an embedded language.
13:36:28 <nomeata> nevermind, it’s even documented: http://www.haskell.org/ghc/docs/latest/html/Cabal/authors.html#source-repos
13:36:36 <drdozer> this runs out of stack: mapM (\(i, j) -> do { (r::Double) <- getRandom ; return (i, j, r) }) [(i, j) | i <- [1..1000], j <- [1..1000]]
13:36:58 <int80_h> I don't know why it's taking this long to load
13:37:16 <vixey> CakeProphet, data Pill a where Stop :: Pill Integer ; O :: Pill (Pill a -> a)
13:37:23 <int80_h> int-e: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=841#a841
13:37:26 <vixey> collect :: Integer -> Pill a -> a ; collect i Stop = i ; collect i O = collect (i+1)
13:37:39 <gwern> nomeata: oh, so that field made it into a released cabal? neat, I'll have to remember that
13:37:40 <int80_h> int-e: I'm hoping I've just screwed up some intendation
13:37:43 <\ozy`> drdozer: try (r `seq` return (i, j, r))
13:37:54 <vixey> CakeProphet, now if you let,  start = collect 0  then start O O O Stop ~> 3, and start O O O O Stop ~> 4
13:37:55 * \ozy` shrugs
13:38:24 <augustss> vixey: nifty!
13:38:29 <drdozer> \ozy`, that overflows as well
13:38:35 <vixey> CakeProphet, (It's a silly example but once you understand how it works then you might see a /lot/ more potential with GADTs)
13:38:44 <CakeProphet> :t collect
13:38:45 <lambdabot> forall a prop. (Testable prop, Show a) => a -> prop -> Property
13:39:03 <int-e> int80_h: takeUntil p' = takeWhile p'
13:39:08 <Cale> One of my favourite example uses of GADTs is alongside MonadPrompt
13:39:10 <CakeProphet> ...what is ~> ?
13:39:16 <int-e> int80_h: --> takeUntil p' = takeWhile q where q x = not (p' x)
13:39:20 <CakeProphet> just an equivalence thing?
13:39:23 <vixey> ~> is my meta notation for 'evaluates to'
13:39:28 <CakeProphet> -nod- alright.
13:39:48 <CakeProphet> what does collect do?
13:40:17 <olsner> @karma moritz
13:40:17 <lambdabot> moritz has a karma of 362
13:40:18 <CakeProphet> > collect 1 2
13:40:19 <lambdabot>       No instance for (Show Property)
13:40:19 <lambdabot>        arising from a use of `show' at ...
13:40:22 <olsner> @seen moritz
13:40:23 <lambdabot> I saw moritz leaving #perl6 1m 19d 3h 57m 5s ago, and .
13:40:23 <int-e> int80_h: you have to use the local version of the predicate (namely, p'), not the one from splitWith' (namely, p).
13:40:26 <CakeProphet> @src Property
13:40:26 <lambdabot> Source not found. Maybe you made a typo?
13:40:28 <Cale> CakeProphet: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=247
13:40:37 <vixey> CakeProhpet, and a more involved example if you like http://rafb.net/p/sA0hWo50.html
13:40:51 <int80_h> int-e: thanks, I'm connecting to lemmih's server so I can fix things
13:40:52 <vixey> but that second one shows a limitation of haskell too
13:40:54 <olsner> hmm, wonder what happened to him
13:41:09 <int80_h> int-e: I'm running netbsd-current and my machine gets unstable from time to time.
13:41:44 <somnolence> can haskell handle binary data in pure functions or only IO stuff?
13:41:57 <\ozy`> somnolence: ...what?
13:41:57 <mornfall> somnolence: Data.Binary (yes, pure).
13:41:58 <dons> with pure functions, yes.
13:42:04 <somnolence> k
13:42:04 <dons> ?hoogle decode
13:42:04 <lambdabot> Prelude decodeFloat :: RealFloat a => a -> (Integer, Int)
13:42:08 <blackh> @faq can haskell handle binary data in pure functions or only IO stuff?
13:42:09 <lambdabot> The answer is: Yes! Haskell can do that.
13:42:12 <dons> ?hoogle Data.Binary.decode
13:42:12 <lambdabot> No results found
13:42:12 <CakeProphet> Cale:  hmmm... that's hard for me to understand, but it certainly looks like the arbitrary type constructors create less boilerplate.
13:42:16 <CakeProphet> Cale:  not sure why though
13:42:16 <dons> :t Data.Binary.decode
13:42:17 <lambdabot> forall a. (Data.Binary.Binary a) => BSLC.ByteString -> a
13:42:22 <BONUS> also, Data.ByteString for efficient sequences of bytes
13:42:33 <Cale> CakeProphet: Well, it would be just impossible to give them the right types otherwise...
13:42:33 <int80_h> @faq can haskell make a homework doer?
13:42:34 <lambdabot> The answer is: Yes! Haskell can do that.
13:42:34 <dons>  IO is entirel orthogonal and unrelated.
13:42:45 <int80_h> well, if haskell can do my homework, why would I want anything else
13:42:58 <int80_h> > do my calculus!
13:43:00 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
13:43:03 <int80_h> hmm
13:43:09 <int80_h> didn't work
13:43:09 <Cale> CakeProphet: The Prompt monad basically lets you have a monad with an arbitrary set of abstract operations given by the values of some type
13:43:17 <roconnor> > deriv (\x -> x^2 + x -1) x
13:43:19 <lambdabot>   1 * x + x * 1 + 1
13:43:29 <CakeProphet> :t deriv
13:43:30 <lambdabot> forall a b. (Num b, Num a) => (Dif a -> Dif b) -> a -> b
13:43:39 <CakeProphet> ...deriv is magic right?
13:43:47 <CakeProphet> I hope it is, otherwise Haskell is scary.
13:43:49 <roconnor> It's part of numbers
13:43:50 <vixey> > deriv (\x -> sin x) x
13:43:51 <lambdabot>   1 * cos x
13:43:53 <vixey> nice!!
13:43:54 <roconnor> @hackage numbers
13:43:55 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
13:44:03 <vixey> I'm annoyed because I already know how it works
13:44:09 <vixey> > deriv (\x -> sqrt (sin x)) x
13:44:10 <Gracenotes> zipper-based?
13:44:10 <lambdabot>   1 * cos x * recip (2 * sqrt (sin x))
13:44:26 <CakeProphet> ah... it's not actually numbers.
13:44:26 <vixey> Gracenotes, they key is that derivatives are compositional
13:44:29 <Cale> Gracenotes: It's a special instance of Num
13:44:29 <CakeProphet> that makes sense.
13:44:35 <asgaroth> How does lambdabot do that? When I use it from ghci, I can't get the symbolic representation of it, just the function itself
13:44:42 <Gracenotes> > deriv 4
13:44:43 <lambdabot>       Overlapping instances for Show (a -> b)
13:44:43 <lambdabot>        arising from a use of `s...
13:44:57 <Gracenotes> > deriv (\x -> 4) x
13:44:58 <lambdabot>   0
13:45:03 <roconnor> asgaroth: lambdabot has the numbers package installed
13:45:33 <Gracenotes> derivatives are compositions, indeed -- but does it also simplify the expressions?
13:45:33 <asgaroth> roconnor: Yes, so do I, but when I use deriv, it just returns the function itself, not how it is defined
13:45:34 <Cale> CakeProphet: In this case, the type PromptState s a gives operations Get and Put with the same types as the normal State s monad operations.
13:45:50 <jeffwheeler> The deriv src: http://hackage.haskell.org/packages/archive/numbers/2008.4.20.1/doc/html/src/Data-Number-Dif.html#deriv
13:46:11 <roconnor> asgaroth: lambdabot also has simpleReflect installed, but you can also use Data.Number.Symbolic which is similar
13:46:11 <vixey> > deriv (\x -> f . g) x
13:46:13 <lambdabot>   Couldn't match expected type `Dif b' against inferred type `a -> c'
13:46:14 <CakeProphet> Cale:  right. Is there a tangible benefit from doing that?
13:46:16 <Gracenotes> > deriv (\x -> x^2 / x) x
13:46:18 <lambdabot>   (1 * x + x * 1) * recip x + x * x * negate (1 * recip x * recip x)
13:46:19 <asgaroth> roconnor: Ah ok, thanks
13:46:19 <vixey> > deriv (sin . cos) x
13:46:21 <lambdabot>   1 * negate (sin x) * cos (cos x)
13:46:22 <Gracenotes> haha
13:46:29 <Gracenotes> I guess not ;)
13:46:32 <vixey> > deriv (sin . cos . sin . cos) x
13:46:33 <Cale> CakeProphet: Well, we get to interpret those operations after the fact in any way we want.
13:46:34 <lambdabot>   1 * negate (sin x) * cos (cos x) * negate (sin (sin (cos x))) * cos (cos (s...
13:46:40 <Cale> CakeProphet: Which is kind of cool...
13:47:02 <Cale> CakeProphet: So first, you see runState, which is just like runState for the normal State monad.
13:47:11 <vixey> > deriv (fix (\f x -> sin x + f (1 / x))) x
13:47:17 <Gracenotes> > deriv log x
13:47:17 <lambdabot>   * Exception: stack overflow
13:47:18 <lambdabot>   1 * recip x
13:47:37 <Cale> and then in the second paste there, I have runStateUser which asks the user for input on each 'Get' and prints something for the user on each 'Put'
13:47:39 <roconnor> @faq can Haskell do int80_h's calculus homework?
13:47:40 <lambdabot> The answer is: Yes! Haskell can do that.
13:47:48 <CakeProphet> Cale:  so where do the tangible /values/ of the Get constructor come from?
13:47:50 <Cale> and then runStateIORef, which uses an IORef to hold the state
13:47:53 <int80_h> int-e: okay my code compiles but the logic is broken. But I can understand what is written well enough to suss out what is wrong. Thanks :)
13:48:09 <Cale> CakeProphet: There's only one tangible value. Get itself.
13:48:17 <Cale> CakeProphet: Or one for each type s, anyway.
13:48:25 <vixey> CakeProphet, just imagine  data S a = X | Y
13:48:32 <Cale> CakeProphet: The Get constructor doesn't have any parameters.
13:48:44 <vixey> CakeProphet, you have   X :: S Integer,  Y :: S Bool,  X :: Maybe (Either String ()),  right?
13:48:47 <CakeProphet> I see that, which is why I'm confused.
13:48:50 <CakeProphet> as to how it can... do anything.
13:50:00 <augustss> CakeProphet: phantom types takes a little getting used to
13:50:19 <vixey> being able to 1) put type indices down  2) compute new types by connecting up values   just means you can make some new programs type errors which didn't before and also some new programs type check which didn't before
13:50:31 <CakeProphet> is Get in this case purely there to be pattern matched against?
13:51:06 <Gracenotes> hm.. is it possible to write (\x y -> x == 0 || y == 0) using liftA2? Doesn't seem so.
13:51:13 <vixey> :t liftA2
13:51:15 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
13:51:28 <vixey> :t liftA2 ((==)`on`(||))
13:51:29 <lambdabot>     No instance for (Eq (Bool -> Bool))
13:51:29 <lambdabot>       arising from a use of `==' at <interactive>:1:8-11
13:51:29 <lambdabot>     Possible fix: add an instance declaration for (Eq (Bool -> Bool))
13:51:34 <vixey> :t liftA2 ((||)`on`(==))
13:51:35 <lambdabot>     Couldn't match expected type `Bool'
13:51:35 <lambdabot>            against inferred type `a -> Bool'
13:51:35 <lambdabot>     Probable cause: `==' is applied to too few arguments
13:51:43 <Gracenotes> hm, it might possible to have (\(x, y) -> x == 0 || y == 0)...
13:51:45 <augustss> @pl (\x y -> x == 0 || y == 0)
13:51:46 <lambdabot> (. (0 ==)) . (||) . (0 ==)
13:51:48 <CakeProphet> and if so... what is the type of just Get by itself. What becomes s?
13:51:52 <vixey> oh
13:51:57 <vixey> :t liftA2 ((==0)`on`(||))
13:51:58 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `Bool'
13:51:58 <lambdabot>     In the first argument of `on', namely `(== 0)'
13:51:58 <lambdabot>     In the first argument of `liftA2', namely `((== 0) `on` (||))'
13:52:11 <vixey> :t liftA2 ((||)`on`(0==))
13:52:12 <lambdabot> forall t (f :: * -> *). (Applicative f, Num t) => f t -> f t -> f Bool
13:52:15 <CakeProphet> is it like polymorphic constants. similar to maxBound and minBound?
13:52:36 <Gracenotes> > liftA2 (||) ((==0) . fst) ((==0) . snd) (1,0)
13:52:38 <lambdabot>   True
13:52:51 <Gracenotes> > curry (liftA2 (||) ((==0) . fst) ((==0) . snd)) 1 0
13:52:52 <int80_h> oh jeez, I locked up ghci
13:52:52 <lambdabot>   True
13:52:52 <Cale> CakeProphet: Get :: PromptState s s, just like it says
13:52:58 <Cale> CakeProphet: It's polymorphic.
13:53:00 <somnolence> anyone see what's wrong with this sieve? sieve (p : xs) = p : sieve [x | x <− xs, x `mod` p > 0]
13:53:01 <Gracenotes> hm.
13:53:08 <Gracenotes> feels a bit hacky ;)
13:53:14 <vixey> what's hacky/
13:53:15 <vixey> ?
13:53:25 <Cale> CakeProphet: So it could be  Get :: PromptState Integer Integer, or Get :: PromptState String String
13:53:26 <int80_h> hacky as in wacky?
13:53:41 <Gracenotes> er. Not 'natural' to FP style, I guess, in this case
13:53:42 <Cale> somnolence: that's not a - in your <-
13:53:53 <Cale> It's some other unicode character
13:53:58 <CakeProphet> Cale:  right. But at what point does s become "concrete".
13:54:01 <somnolence> Cale: I'm affraid I don't understand
13:54:05 <Gracenotes> it seems weird bundling something in a tuple just to unbundle it again
13:54:11 <Cale> somnolence: Re-type the - character there
13:54:12 <somnolence> oh
13:54:15 <somnolence> k
13:54:26 <vixey> CakeProphet, (what do you mean by concrete?  why is say  Integer  concrete?)
13:54:37 <conal> pmurias: after the tutorial, follow links on the haskell wiki's FRP page.
13:54:46 <somnolence> > sieve (p : xs) = p : sieve [x | x - xs, x `mod` p > 0] in sieve [2..]
13:54:47 <lambdabot>   <no location info>: parse error on input `='
13:54:52 <Cale> CakeProphet: I suppose when you choose a state type... perhaps when you combine it with a Put operation, or perhaps when you call runState
13:54:57 <somnolence> > sieve (p : xs) = p : sieve [x | x - xs, x `mod` p > 0]
13:54:58 <lambdabot>   <no location info>: parse error on input `='
13:55:04 <somnolence> !?
13:55:04 <vixey> CakeProphet,  in   Left 3 :: Either Integer Bool   is 'Bool' not concrete?
13:55:07 <Cale> CakeProphet: Or perhaps later, when the thing which calls runState is called.
13:55:17 <mux> > nubBy (\x y -> gcd x y > 0) [2..]
13:55:23 <somnolence> Cale: that doesn't seem to be the issue -.-
13:55:33 <lambdabot>   thread killed
13:55:45 <Cale> somnolence: now you just have x - xs, instead of x <- xs
13:55:59 <somnolence> ok?
13:56:06 <somnolence> O_o
13:56:09 <Cale> > let sieve (p : xs) = p : sieve [x | x <- xs, x `mod` p > 0] in sieve [2..]
13:56:11 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
13:56:14 <somnolence> nice
13:56:19 <somnolence> ic
13:56:39 <CakeProphet> :k IO String
13:56:40 <lambdabot> *
13:56:47 <CakeProphet> vixey:  that is what makes a type concrete.
13:57:00 <vixey> huh?
13:57:04 <asgaroth> How would I use simple-reflect to "deconstruct" a function(returned by deriv)?
13:57:17 <vixey> the kind of PromptState Integer Integer is *
13:57:30 <vixey> (and the kind of Mu Maybe is *)
13:57:56 <CakeProphet> so if your function deals constructs of Put of type PromptState String Integer
13:57:59 <asgaroth> @src deriv
13:58:00 <lambdabot> Source not found.
13:58:06 <CakeProphet> then the Get's type will be PromptState String String?
13:58:07 <Holle_> why elem (1,_) [(1,2),(3,2)] doesn't work?
13:58:14 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p^2 <= n) primes) in primes
13:58:16 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
13:58:35 <Cale> CakeProphet: yeah.
13:58:38 <vixey> CakeProphet, (did you see my paste also?)
13:59:00 <CakeProphet> vixey:  don' t believe so. :(
13:59:09 <Cale> CakeProphet: Or if a Get occurs inside a Prompt (PromptState String) computation, then it will have type PromptState String String
13:59:15 <Gracenotes> Why does the typeclass of a in "floor a" have to be RealFrac?
13:59:22 <vixey> CakeProhpet, so if you are still curious about GADTs then: http://rafb.net/p/sA0hWo50.html
13:59:50 <roconnor> Holle_: you need to pass a real object to elem
13:59:52 <Gracenotes> > floor (3::Int)
13:59:54 <lambdabot>       No instance for (RealFrac Int)
13:59:54 <lambdabot>        arising from a use of `floor' at ...
13:59:58 <Cale> Gracenotes: Because it needs something similar to an ordered field.
14:00:09 <Holle_> but i don't know the _ object.
14:00:19 <roconnor> _ isn't an object, it is a pattern
14:00:31 <Gracenotes> Cale: hm.. why?
14:00:39 <Holle_> i don't know, which obeject stands for _
14:00:41 <asgaroth> How can I show functions like lambdabot does for deriv?
14:00:56 <roconnor> Holle_: it isn't any object, it is a pattern used it case expressions and function definitions
14:00:59 <Cale> Gracenotes: Well, for example, what does floor do for complex numbers?
14:01:18 <roconnor> @type any
14:01:20 <Cale> Gracenotes: you can invent something, but it's not terribly meaningful..
14:01:20 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
14:01:36 <Gracenotes> okay, but floor definitely does something for Integral types
14:01:47 <Cale> Gracenotes: Nothing at all?
14:01:51 <roconnor> Holle_: you want "any (\x -> fst x == 1) [(1,2),(2,3)]"
14:01:59 <Gracenotes> yes. So it should accept Integrals and be an identity
14:02:00 <roconnor> > any (\x -> fst x == 1) [(1,2),(2,3)]
14:02:02 <lambdabot>   True
14:02:03 <Gracenotes> it's perfectly valid
14:02:10 <Holle_> great :)
14:02:11 <roconnor> or
14:02:26 <Cale> Gracenotes: If you know the type is integral, why apply floor in the first place?
14:02:28 <roconnor> Holle_:  any (\(x,_) -> x == 1) [(1,2),(2,3)]
14:02:35 <roconnor> > any (\(x,_) -> x == 1) [(1,2),(2,3)]
14:02:36 <milton13_> can you only write Strings to files with
14:02:37 <lambdabot>   True
14:02:39 <milton13_> "writeFile?"
14:02:42 <asgaroth> or any ((==1) . fst) [..]
14:02:43 <Gracenotes> Cale: the problem is that it's forcing the input to be RealFrac, which causes type inference complications
14:02:48 <Cale> milton13_: No, there are other ways.
14:02:59 <Cale> milton13_: But what's wrong with writeFile?
14:03:15 <Cale> Gracenotes: hm?
14:03:17 <Gracenotes> > liftA2 (==) floor id (4::Int)
14:03:19 <asgaroth> Gracenotes: If you end up with passing an Integral to it, there's something else that's wrong probably
14:03:19 <lambdabot>       No instance for (RealFrac Int)
14:03:19 <lambdabot>        arising from a use of `floor' at ...
14:03:19 <roconnor> Holle_: in this case _ is being used as a pattern, because it is used to define the (anonymous) function (\(x,_) -> ...)
14:03:21 <Gracenotes> > liftA2 (==) floor id (4::Float)
14:03:22 <lambdabot>       No instance for (Integral Float)
14:03:23 <lambdabot>        arising from a use of `floor' a...
14:03:40 <milton13_> Cale: well i can't go: "writeFile "myfile.txt" [1,2,3,24]
14:04:09 <Gracenotes> any idea how to go about solving that, so that both accept (and output) the same type?
14:04:11 <Cale> milton13_: Oh, you could writeFile "myfile.txt" (show [1,2,3,24]) though
14:04:13 <asgaroth> milton13_: It needs a string as second parameter, so you need to `show' it
14:04:28 <Cale> Gracenotes: The result of floor is never the same type as its input.
14:04:31 <milton13_> Cale: oh right, good ol `show'
14:04:34 <Cale> :t floor
14:04:36 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
14:04:46 <Cale> There's no type which is both Integral and RealFrac
14:04:51 <Cale> (or there shouldn't be anyway)
14:04:59 <milton13_> asgaroth: Cale: thanks
14:05:01 <Gracenotes> yes, I know. So how would you rewrite liftA2 (==) floor id?
14:05:10 <Gracenotes> using liftA2, still
14:05:11 <Cale> liftA2 (==) id id
14:05:21 <\ozy`> if I wanted to write a function that could get either the head of a list, or the first element of a pair....
14:05:24 <asgaroth> I still don't get why floor for Integrals would be useful though
14:05:25 <Gracenotes> the idea is to determine with a number is equal to its floor
14:05:28 <Gracenotes> *whether
14:05:37 <Gracenotes> not if it's equal to itself
14:05:41 <Cale> Gracenotes: ah, okay
14:05:46 <CakeProphet> \oxy`, you'd have to use Either.
14:05:54 <roconnor> (\x -> snd (properFraction x) == 0) ?
14:06:08 <Cale> Gracenotes: liftA2 (==) (fromIntegral . floor) id
14:06:15 <\ozy`> CakeProphet: I suppose that would work...? I was hoping to do it with typeclasses.
14:06:46 <Gracenotes> Cale: eesh. looks like it works, though; thanks
14:06:50 <roconnor> Cale: better have a good Defaulting for that
14:06:57 <CakeProphet> \ozy`:  hmmm... that could work. If you made a typeclass that defined a getFirst and then made instances for both [] and ().
14:06:59 <asgaroth> \ozy`: f (Left (a,_)) = a
14:07:02 <Cale> roconnor: Integer is good enough :)
14:07:03 <Gracenotes> seems a bit beating-around-the-bush, though
14:07:04 <somnolence> Is there anyway map can handle infinite lists?
14:07:07 <asgaroth> \ozy`: f (Right (x:_)) = x
14:07:08 <roconnor> Cale: how about fromInteger instead?
14:07:15 <vixey> There's an example of it using GADTs :p
14:07:16 <Cale> roconnor: Sure, that works too.
14:07:19 <Gracenotes> :t fromInteger
14:07:20 <lambdabot> forall a. (Num a) => Integer -> a
14:07:28 <vixey> projection and modification on a (small) universe of structures
14:07:30 <idnar> @type liftA2 (==) (fromIntegral . floor) id
14:07:31 <lambdabot> forall a. (RealFrac a) => a -> Bool
14:07:43 <roconnor> @type (\x -> snd (properFraction x) == 0) ?
14:07:44 <lambdabot> parse error (possibly incorrect indentation)
14:07:51 <vixey> hm it's on hpaste but hpaste is down
14:07:56 <roconnor> @type (\x -> snd (properFraction x) == 0)
14:07:58 <lambdabot> forall b. (RealFrac b) => b -> Bool
14:08:03 <vixey> well you can do it with GADTs alone so I will just leave it as a problem if anyone wants a puzzle
14:08:29 <CakeProphet> \ozy`: class hasFirst a where getFirst :: a x -> x
14:08:34 <vixey> (typeclasses work too but I think you need fundeps)
14:08:35 <CakeProphet> I think?
14:08:36 <Cale> CakeProphet: Hey, sorry about that, is the example sort of making sense?
14:08:57 <CakeProphet> Cale:  vaguely. I'll need to use it with something to figure it out, I'm guessing.
14:09:10 <Cale> CakeProphet: It's important to realise that types are erased by compilation.
14:09:19 <h0tzenpl0tz> could somebody tell me what arrows can in contrast to monads?
14:09:50 <Cale> CakeProphet: Data constructors are represented at runtime as essentially integer tags along with zero or more pointers corresponding to their parameters.
14:09:59 <Gracenotes> still, the type of floor seems a bit odd. I'd think that typeclasses would provide a better solution than automatic coercion that's often found in other languages...
14:10:21 <idnar> Gracenotes: what's odd about the type?
14:10:26 <CakeProphet> Cale:  right.
14:10:32 <roconnor> Gracenotes: what's wrong with using properFraction?
14:10:48 <milton13_> is there something like writeFile, but its type signature is "Handle -> String -> IO ()" instead of " FilePath -> String -> IO ()"??
14:11:02 <asgaroth> milton13_: hPutStr
14:11:05 <Gracenotes> properFraction seems like a good solution.
14:11:09 <asgaroth> @type hPutStr
14:11:10 <lambdabot> Not in scope: `hPutStr'
14:11:12 <asgaroth> @type hPutStrLn
14:11:14 <lambdabot> Not in scope: `hPutStrLn'
14:11:17 <Gracenotes> but nonetheless, it seems like floor (3::Int) should be able to work
14:11:21 <milton13_> @hoogle Handle -> String -> IO ()
14:11:21 <lambdabot> System.IO hPutStr :: Handle -> String -> IO ()
14:11:21 <lambdabot> System.IO hPutStrLn :: Handle -> String -> IO ()
14:11:21 <lambdabot> System.IO hPutChar :: Handle -> Char -> IO ()
14:11:23 <Debugger> Haskell doesn't like the word "cast" ?
14:11:30 <milton13_> coo!
14:11:35 <Badger> > cast
14:11:36 <lambdabot>       Overlapping instances for Show (a -> Maybe b)
14:11:36 <lambdabot>        arising from a use...
14:11:42 <Badger> :t cast
14:11:44 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
14:11:54 <Gracenotes> > (if False then floor x else x) 4
14:11:55 <lambdabot>   Couldn't match expected type `t -> t1' against inferred type `Expr'
14:12:02 <roconnor> Gracenotes: floor for integers almost makes no sense
14:12:02 <Gracenotes> > (\x -> if False then floor x else x) 4
14:12:03 <lambdabot>   Add a type signature
14:12:04 <Debugger> So, it has a different meaning then
14:12:08 <Cale> CakeProphet: So at runtime,  Put (3+4)  is just represented by something like 0,<pointer to the expression 3+4>, and Get is represented by 1, perhaps.
14:12:15 <Gracenotes> > (\x -> if False then floor x else x) 4.5
14:12:16 <lambdabot>   Add a type signature
14:12:27 <CakeProphet> Cale:  I suppose it's just weird to imagine a type where the parameters of the constructor don't necessarily correlate to the result type.
14:12:31 <Gracenotes> > (\x -> if False then floor x else x) (4::Double)
14:12:32 <lambdabot>       No instance for (Integral Double)
14:12:32 <lambdabot>        arising from a use of `floor' ...
14:12:37 <Gracenotes> > (\x -> if False then floor x else x) (4::Integer)
14:12:38 <lambdabot>       No instance for (RealFrac Integer)
14:12:38 <lambdabot>        arising from a use of `floor'...
14:12:50 <idnar> @type if False then floor ?x else ?x
14:12:51 <lambdabot> forall b. (RealFrac b, Integral b, ?x::b) => b
14:12:57 <Gracenotes> imho, it's not the type itself that's weird, it's the type inference consequences...
14:12:59 <idnar> ^^^ those type constraints can't be satisfied
14:13:03 <Gracenotes> I know.
14:13:09 <\ozy`> hmmmm
14:13:29 <\ozy`> "class Car a ... instance Car (a, b)" doesn't work
14:13:32 <Deewiant> idnar: sure they can, just define such a type :-P
14:13:37 <idnar> Deewiant: heh
14:14:03 * \ozy` is so terrible with typeclasses x_x
14:14:27 <Gracenotes> or define Integer to be an instance of RealFrac
14:14:35 <CakeProphet> what on earth is ?x::b
14:15:05 <Cale> CakeProphet: Implicit parameter
14:15:05 <asgaroth> somelambdabot magic I guess
14:15:10 <roconnor> @src RealFrac
14:15:10 <int-e> h0tzenpl0tz: Every monad defines an arrow, the Kleisly arrow (see the Kleisli constructor from Control.Arrow). Arrows are more limited than monads though: arrows do not support conditional execution as in  do x <- foo; if x then bar else baz  ... only a fixed pipeline. ArrowChoice provides part of the missing functionality; the full monad power is given by ArrowApply.
14:15:10 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
14:15:10 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
14:15:10 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
14:15:18 <Gracenotes> all of RealFrac's functions are well-defined for Integral types, after all
14:15:23 <roconnor> @src Real
14:15:23 <idnar> asgaroth: it's not lambdabot-specific
14:15:23 <Cale> You can read about implicit parameters in the GHC user's guide.
14:15:23 <lambdabot> class  (Num a, Ord a) => Real a  where
14:15:23 <lambdabot>     toRational      ::  a -> Rational
14:15:30 <roconnor> @src Fractional
14:15:30 <lambdabot> class  (Num a) => Fractional a  where
14:15:30 <lambdabot>     (/)             :: a -> a -> a
14:15:30 <lambdabot>     recip           :: a -> a
14:15:30 <lambdabot>     fromRational    :: Rational -> a
14:15:35 <asgaroth> idnar: Ok, then ignore my statement
14:15:42 <roconnor> Gracenotes: except frational
14:15:42 <Gracenotes> well... hm, maybe not (/).
14:15:46 <Gracenotes> yeah.
14:15:59 <Gracenotes> without doing int division (i.e. division ignoring remainders)
14:16:15 <Gracenotes> oh, what a tangled web of typeclasses we weave
14:16:17 <idnar> well, you can define them all
14:16:19 <CakeProphet> :t ?x
14:16:21 <lambdabot> forall t. (?x::t) => t
14:16:22 <idnar> it's just a question of whether it's a good idea or not
14:16:29 <SKuhn> how do I see that map is a functor? :i map doesn't work
14:16:50 <CakeProphet> @instances Functor
14:16:51 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
14:16:52 <nomeata> dons: you got me so far. I just uploaded a cabal package with darcswatch :-) (http://hackage.haskell.org/cgi-bin/hackage-scripts/package/darcswatch)
14:17:04 <idnar> SKuhn: what do you mean by "map is a functor"?
14:17:17 <asgaroth> :i Data.Map.Map
14:17:18 <milton13_> @hoogle show
14:17:18 <lambdabot> package show
14:17:18 <lambdabot> Prelude show :: Show a => a -> String
14:17:18 <lambdabot> Text.Show show :: Show a => a -> String
14:17:27 <idnar> SKuhn: oh, did you mean Map?
14:17:28 <asgaroth> @info Data.Map.Map
14:17:28 <lambdabot> Data.Map.Map
14:17:30 <somnolence> in this sieve function: sieve (p : xs) = p : sieve [x | x <- xs, x `mod` p > 0]    how can I specify a non infinite list, when I specify a non-infinite list I get a "Non-exhaustive patterns in function sieve" error
14:17:33 <Gracenotes> of course, you could use the type classes in Fractional to help define floor methods
14:17:36 <idnar> @instances-importing Functor Data.Map
14:17:36 <lambdabot> Couldn't find class `Data.Map'. Try @instances-importing
14:17:37 <somnolence> Is there some way to ignore the error?
14:17:42 <idnar> @instances-importing Data.Map Functor
14:17:43 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Map k, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
14:17:44 <Gracenotes> but you don't need them, if it's an Integral type
14:17:48 <Cale> somnolence: You're missing a base case.
14:17:57 <Cale> somnolence: So it doesn't work if the list is finite.
14:17:58 <somnolence> Cale: rightt
14:18:02 <Gracenotes> hm. No more thinking about this :X
14:18:18 <Cale> somnolence: sieve [] = [] will work though
14:18:22 <CakeProphet> somnolence:  include a pattern for []
14:18:24 <CakeProphet> yeah
14:18:31 <somnolence> ?
14:18:45 <SKuhn> idnar: map id = id and map (f.g) = map f . map g
14:18:51 <SKuhn> thats a functor
14:19:00 <CakeProphet> somnolence:  your sieve functions keep calling until it gets sieve []... but (p:xs) doesn't match [] because [] has neither a head nor a tail.
14:19:05 <Cale> > let sieve [] = []; sieve (p : xs) = p : sieve [x | x <- xs, x `mod` p > 0] in sieve [2..10]
14:19:05 <CakeProphet> *keeps
14:19:07 <lambdabot>   [2,3,5,7]
14:19:11 <SKuhn> and I read functor somewhere in ghci
14:19:17 <somnolence> thnx
14:19:23 <SKuhn> but I don't remember how I did that ;)
14:19:25 <Gracenotes> > snd (properFraction 3.1) == 0.1
14:19:26 <lambdabot>   False
14:19:27 <Cale> SKuhn: Those are the functor laws...
14:19:39 <CakeProphet> somnolence:  so you need to add a pattern that matches [] and returns some non-recursive result to terminate the function.
14:19:40 <Gracenotes> > snd (properFraction 3.1) == (0.1::CReal)
14:19:42 <lambdabot>   True
14:19:49 <asgaroth> SKuhn: functions can't be Functors in Haskell, just data types can
14:20:01 <somnolence> Thanks that makes sense =P
14:20:10 <SKuhn> oh, ok :)
14:20:14 <Cale> SKuhn: functors (or more correctly, endofunctors on the category of Haskell types) are represented in Haskell by instances of the typeclass Functor
14:20:27 <Debugger> :)
14:20:28 <Cale> SKuhn: There's an instance Functor [] where fmap = map
14:20:33 <tromp__> i cant believe the beetle on the cover of RWH can lift 24kg :-(
14:20:52 <milton13_> lol
14:21:01 <CakeProphet> > (+3) `fmap` (Just 10)
14:21:02 <tromp__> yet that is what http://en.wikipedia.org/wiki/Hercules_beetle claims
14:21:03 <lambdabot>   Just 13
14:21:13 <Gracenotes> tromp__: unfortunately, it can't lift two piles if one is a RealFrac a and the other is Integral a
14:21:42 <CakeProphet> Cale:  is there something like Functor but with zip-like functions?
14:21:49 <SKuhn> but do I need to use fmap in order to ensure that map follows these axioms?
14:21:58 <CakeProphet> > zip (+) [10..20] [1..10]
14:22:00 <lambdabot>   Couldn't match expected type `[a]'
14:22:00 <Cale> CakeProphet: Some people have defined a Zippable class before.
14:22:12 <Cale> CakeProphet: There's nothing in the libraries which come with GHC.
14:22:19 <CakeProphet> -nod- alright.
14:22:25 <Gracenotes> > zipWith (+) [10..20] [1..10] -- ?
14:22:26 <lambdabot>   [11,13,15,17,19,21,23,25,27,29]
14:22:33 <CakeProphet> oh... right.
14:22:36 <CakeProphet> :t zip
14:22:37 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
14:22:41 <asgaroth> CakeProphet: I think this has been done in some Monad.Reader issue
14:22:41 <CakeProphet> zup is just zipWith (,)
14:22:57 <idnar> zipWith is only for lists, though
14:23:01 <idnar> @type zipWith
14:23:02 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
14:23:10 <CakeProphet> idnar:  ...okay?
14:23:13 <Cale> It has a type which agrees with liftA2 though
14:23:18 <Cale> :t liftA2
14:23:20 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
14:23:36 <Cale> The default applicative instance for lists doesn't zip though.
14:23:36 <somnolence> how can I convert a string consisting of numbers 00 -> 99 and seperated by spaces into a list containing each 2digit number as a seperate element.
14:24:00 <Gracenotes> hm
14:24:01 <Cale> > map read . words $ "4 54 23 6 0"
14:24:03 <lambdabot>   [* Exception: Prelude.read: no parse
14:24:06 <Cale> > map read . words $ "4 54 23 6 0" :: [Integer]
14:24:08 <lambdabot>   [4,54,23,6,0]
14:24:34 <Gracenotes> > liftA2 (+) [1..10] [11..20]
14:24:35 <lambdabot>   [12,13,14,15,16,17,18,19,20,21,13,14,15,16,17,18,19,20,21,22,14,15,16,17,18...
14:24:47 <idnar> > liftA2 (+) (ZipList [1..10]) (ZipList [11..20])
14:24:48 <lambdabot>       No instance for (Show (ZipList a))
14:24:48 <lambdabot>        arising from a use of `show' ...
14:24:59 <idnar> > getZipList $ liftA2 (+) (ZipList [1..10]) (ZipList [11..20])
14:25:00 <lambdabot>   [12,14,16,18,20,22,24,26,28,30]
14:25:02 <CakeProphet> ...ZipList should have a show instance.
14:25:04 <Holle_> exists a function like: count 1 [1,2,1,1,2] = 3
14:25:05 <CakeProphet> by default.
14:25:05 <asgaroth> > [1..10] <^(+)^> [11..20]
14:25:07 <lambdabot>   Not in scope: `<^'Not in scope: `^>'
14:25:07 <idnar> CakeProphet: yeah :/
14:25:10 <dolio> > unfoldr (listToMaybe . reads) "4 654 38 13 7" :: [Integer]
14:25:11 <lambdabot>   [4,654,38,13,7]
14:25:17 <dolio> > unfoldr (listToMaybe . reads) "4 654 38 13 7  " :: [Integer]
14:25:18 <lambdabot>   [4,654,38,13,7]
14:25:19 <Gracenotes> > liftA2 (,) [1..3] [4..6]
14:25:20 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
14:25:33 <Gracenotes> ah, insta-cartesian-product
14:25:44 <somnolence> Cale : thanks
14:25:45 <Gracenotes> > liftM2 (,) [1..3] [4..6]
14:25:47 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
14:25:53 <CakeProphet> > unzip [(1,2), (2,3)]
14:25:54 <lambdabot>   ([1,2],[2,3])
14:26:10 <CakeProphet> > unzipWith (+) [(1,2), (2,3)]
14:26:11 <lambdabot>   Not in scope: `unzipWith'
14:26:13 <CakeProphet> ...
14:26:16 <CakeProphet> what is this nonsense.
14:26:20 <CakeProphet> oh
14:26:22 <CakeProphet> right.
14:26:23 <idnar> @type unzip
14:26:24 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
14:26:44 <\ozy`> :t uncurry . zipWith (+)
14:26:44 <CakeProphet> unzipWith would be fairly impossible for anything other than constructors
14:26:45 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `[a]'
14:26:45 <lambdabot>     Probable cause: `zipWith' is applied to too many arguments
14:26:45 <lambdabot>     In the second argument of `(.)', namely `zipWith (+)'
14:27:33 <idnar> @type \f xs -> uncurry f $ unzip xs
14:27:34 <lambdabot> forall c a b. ([a] -> [b] -> c) -> [(a, b)] -> c
14:27:40 <idnar> @pl \f xs -> uncurry f $ unzip xs
14:27:41 <lambdabot> (. unzip) . uncurry
14:27:54 <Gracenotes> unzipWith would work for anything where \a -> (b,b) is defined
14:28:03 <Gracenotes> or even b,c
14:28:11 <CakeProphet> :t (:)
14:28:12 <lambdabot> forall a. a -> [a] -> [a]
14:28:29 <Holle_> exists a function like: count 1 [1,2,1,1,2] = 3
14:28:35 <Gracenotes> hm, so you could use unzipWith with properFraction
14:29:07 <ski_> > length . filter (== 1) $ [1,2,1,1,2]
14:29:07 <Holle_> i would write length [x | x <- [1,2,1,1,2], x == 1]
14:29:08 <lambdabot>   3
14:29:18 <Gracenotes> unzipWith :: (a -> (b, c)) -> [a] -> ([b], [c])
14:30:00 <Cale> or length . filter (== 1), of course.
14:30:08 <dolio> @type \f -> foldr (f >>> (:) *** (:)) ([],[])
14:30:09 <lambdabot>     Couldn't match expected type `b -> b'
14:30:09 <lambdabot>            against inferred type `([b1] -> [b1], [b'] -> [b'])'
14:30:09 <lambdabot>     Probable cause: `***' is applied to too many arguments
14:30:41 <dolio> Ah, right.
14:31:52 <dolio> @type \f -> foldr (f >>> (:) *** (:) >>> uncurry (***)) ([],[])
14:31:53 <lambdabot> forall a b b'. (a -> (b, b')) -> [a] -> ([b], [b'])
14:32:29 <Gracenotes> > let unzipWith f xs = unzip $ map f xs in unzipWith properFraction [1,2.5,3.3]
14:32:30 <lambdabot>   ([1,2,3],[0.0,0.5,0.2999999999999998])
14:32:35 <Gracenotes> ^ CakeProphet
14:32:52 <CakeProphet> Gracenotes:  aw... you beat me.
14:32:52 <\ozy`> @src (++)
14:32:52 <lambdabot> []     ++ ys = ys
14:32:52 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:32:52 <lambdabot> -- OR
14:32:52 <lambdabot> xs ++ ys = foldr (:) ys xs
14:33:15 <Gracenotes> hm, the arrow solution, though... *tries to comprehend*
14:34:08 <Gracenotes> lemme see.. infix of *** is 3, infix of >>> is 1
14:34:25 <Holle_> exists a function to get element 4 to 7 out of a list, or do i have to use splitAt
14:34:26 <drdozer> mm - still can't find a way to write this so it doesn't overflow
14:34:30 <drdozer> mapM (\(i, j) -> do { (r::Double) <- getRandom ; return  $ Strategies.rnf (i, j, r) }) [(i, j) | i <- [1..1000], j <- [1..1000]]
14:35:04 <dolio> drdozer: I suspect it's overflowing due to the lazy state monad.
14:35:26 <drdozer> dolio: I was running it in IO
14:35:27 <CakeProphet> Gracenotes:  arrows are still beyond me
14:35:39 <dolio> Oh, hmm.
14:37:21 <Gracenotes> CakeProphet: something that's kind of confusing about arrows is that although . and >>> are both infix right, they apply in different orders
14:37:41 <SubStack> Wed Jan 21 13:37:35 AKST 2009
14:37:47 <SubStack> \o/
14:38:26 <drdozer> it is definitely the 'r' in (i, j, r) that is the problem. Changing 'return (i, j, r)' to 'putStr . show $ (i, j, r)' makes it print "(1,1," before the stack overflow
14:38:30 <Gracenotes> > (\f -> foldr (f >>> (:) *** (:) >>> uncurry (***)) ([],[])) id [(1,2),(3,4)]
14:38:31 <lambdabot>   ([1,3],[2,4])
14:39:11 <somnolence> Cale: if you are there another question, how can I take a list full of two digit representations of Ints and remove all the leading 0's from numbers such as 08 so I can convert it to to an actual [Int]
14:39:24 <CakeProphet> :t Map
14:39:25 <lambdabot> Not in scope: data constructor `Map'
14:39:28 <CakeProphet> :t Data.Map
14:39:29 <lambdabot> Couldn't find qualified module.
14:39:31 <CakeProphet> ...
14:39:35 <Cale> somnolence: The leading 0's won't bother the parser.
14:39:38 <CakeProphet> :t Data.Map.Map
14:39:40 <lambdabot> Not in scope: data constructor `Data.Map.Map'
14:39:44 <Cale> somnolence: Just 'read' them as normal.
14:39:53 <Cale> > read "08"
14:39:55 <lambdabot>   * Exception: Prelude.read: no parse
14:39:56 <idnar> @kind Data.Map.Map
14:39:57 <Cale> > read "08" :: Integer
14:39:58 <lambdabot> * -> * -> *
14:39:58 <CakeProphet> ah, so just fromList, but Map has no constructor.
14:39:59 <lambdabot>   8
14:40:03 <somnolence> :O!
14:40:08 <CakeProphet> :t singleton
14:40:09 <lambdabot> Not in scope: `singleton'
14:40:15 <CakeProphet> :t Data.Map.singleton
14:40:16 <lambdabot> forall k a. k -> a -> M.Map k a
14:40:17 <idnar> CakeProphet: no /exported/ constructor :P
14:40:20 <Gracenotes> :t Map.singleton
14:40:21 <lambdabot> Couldn't find qualified module.
14:40:23 <Gracenotes> ah.
14:40:40 <CakeProphet> :t Data.Map.fromList [("lol", "rofl")]
14:40:41 <lambdabot> M.Map [Char] [Char]
14:40:49 <CakeProphet> > Data.Map.fromList [("lol", "rofl")]
14:40:50 <lambdabot>   /tmp/1423005214518341549:70:32: Not in scope: `Data.Map.fromList'
14:40:58 <CakeProphet> hmmm?
14:41:02 <Cale> somnolence: Of course, the explicit type annotation will probably be unnecessary, because the type you want will probably be determined by what you do with the results of reading.
14:41:07 <asgaroth> looks like a bug
14:41:17 <idnar> > M.fromList [("lol", "rofl")]
14:41:18 <lambdabot>   /tmp/4184673022668835384:70:32: Not in scope: `M.fromList'
14:41:28 <Gracenotes> > Map.fromList [("lol", "rofl")]
14:41:29 <lambdabot>   fromList [("lol","rofl")]
14:41:32 <CakeProphet> ah
14:41:44 <somnolence> yes, thanks
14:42:12 <asgaroth> :t Map.fromList [("foo","bar")]
14:42:13 <lambdabot> Couldn't find qualified module.
14:42:24 <asgaroth> Is that sort of inconsistency intentional?
14:42:28 <CakeProphet> :t (+)
14:42:29 <lambdabot> forall a. (Num a) => a -> a -> a
14:42:42 <Gracenotes> @type M.singleton
14:42:43 <lambdabot> forall k a. k -> a -> M.Map k a
14:42:50 <Gracenotes> :t M.singleton
14:42:52 <lambdabot> forall k a. k -> a -> M.Map k a
14:43:10 <drdozer> this runs: mapM (\(i, j) -> do { (r::Double) <- getRandom ; putStr . show $  (i, j) }) [(i, j) | i <- [1..1000], j <- [1..1000]]
14:43:15 <Gracenotes> odd.
14:43:28 <drdozer> this doesn't: mapM (\(i, j) -> do { (r::Double) <- getRandom ; putStr . show $  (i, j, r) }) [(i, j) | i <- [1..1000], j <- [1..1000]]
14:44:11 <CosmicRay> Velociraptors: now there's a nick.
14:44:12 <lambdabot> CosmicRay: You have 2 new messages. '/msg lambdabot @messages' to read them.
14:44:23 <dolio> The problem is randomIO and such functions.
14:44:37 <dolio> mapM (\_ -> randomIO) [1..1000000] overflows.
14:44:50 <Badger> CosmicRay: look out!
14:45:03 <drdozer> that seems ... odd
14:45:07 <Badger> they're right behind you.
14:45:07 <blip> can i write my own literals for Data.Map with template haskell?
14:45:09 <CosmicRay> sereven: go ahead with the tutorial thing
14:45:47 <idnar> @type randomIO
14:45:48 <lambdabot> forall a. (Random a) => IO a
14:46:04 <sereven> CosmicRay: cool, thanks. And thanks for writing it. Has filled a large need methinks.
14:46:08 <somnolence> Cale: if I have a string how can I select every two characters?
14:46:23 <CosmicRay> sereven: I hope so
14:46:31 <CosmicRay> sereven: I personally detest comma-first style but if everyone else is doing it, might as well.  thanks for checking.
14:46:31 <idnar> drdozer: what about mapM_?
14:46:38 <dolio> I'm wrong, actually, the problem is mapM.
14:46:47 <dolio> That's too large a list for it.
14:46:50 <idnar> oh, you wanted return originally
14:46:59 <CosmicRay> well detest is too strong.  dislike.
14:47:06 <sereven> heh, it's so much easier to read and edit! :( style warz ;)
14:47:12 <somnolence> wait nvm
14:47:21 <Cale> somnolence: Something like  map (take 2) . takeWhile (not . null) . iterate (drop 2), but if the terms are separated with spaces like you said, you can just use the 'words' function to separate them.
14:47:26 <drdozer> idnar: mapM_ overflows in the same way
14:47:39 <blip> can i write my own literals for Data.Map with template haskell?
14:47:41 <drdozer> dolio: Oh?
14:47:42 <Cale> map (take 2) . takeWhile (not . null) . iterate (drop 2) $ "hello, world!"
14:47:43 <dolio> > mapM (\_ -> return 5) [1..1000000]
14:47:44 <Cale> > map (take 2) . takeWhile (not . null) . iterate (drop 2) $ "hello, world!"
14:47:44 <lambdabot>       No instance for (Show (m [t]))
14:47:44 <lambdabot>        arising from a use of `show' at <...
14:47:45 <lambdabot>   ["he","ll","o,"," w","or","ld","!"]
14:47:57 <CosmicRay> sereven: heh.  don't get us started on spaces vs. tabs
14:48:12 <Cale> blip: Perhaps with a quasiquoter.
14:48:27 <Cale> blip: Personally, I just use fromList
14:48:34 <dolio> > flip runState 2 $ mapM (\_ -> return 5) [1..1000000]
14:48:35 <lambdabot>   ([5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
14:49:00 <dolio> In any case, mapM (\_ -> return 5) [1..1000000] overflows in ghci for me.
14:49:09 <sereven> CosmicRay: aiiiiiiii!
14:49:16 <drdozer> dolio: it does for me too, where as [1..1000000] is fine
14:49:34 <idnar> @src mapM
14:49:34 <lambdabot> mapM f as = sequence (map f as)
14:49:40 <idnar> @src sequence
14:49:41 <lambdabot> sequence []     = return []
14:49:41 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:49:41 <lambdabot> --OR
14:49:41 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
14:51:04 <dolio> drdozer: mapM and company aren't tail recursive.
14:51:47 <dolio> So that'll cause problems in certain monads.
14:52:05 <drdozer> right, so I need something with the same functionality as mapM but tail-recursive?
14:52:26 <BONUS> the problem with mapM is that its sequence . map f
14:52:51 <drdozer> @seq Sequence
14:52:52 <lambdabot> Maybe you meant: faq let seen src
14:52:53 <CakeProphet> > case True of {True -> "lol test"; False -> "lol test"}
14:52:54 <lambdabot>   "lol test"
14:52:56 <BONUS> and you can't sequence infinite lists
14:53:08 <drdozer> @src sequence
14:53:08 <lambdabot> sequence []     = return []
14:53:08 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:53:08 <lambdabot> --OR
14:53:08 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
14:53:11 <BONUS> > sequence [Just 3, Just 9, Just 2]
14:53:12 <lambdabot>   Just [3,9,2]
14:53:27 <Deewiant> depends on the monad I guess?
14:53:41 <Gracenotes> > sequence $ map Just [1..]
14:53:44 <lambdabot>   * Exception: stack overflow
14:54:05 <BONUS> haskell can't know that there isn't some sort of Nothing somewhere
14:54:22 <dolio> In fact, the exact opposite of my original guess was correct. Lazy state works, strict state doesn't (because it causes the recursive calls to be made in sequence).
14:54:56 <vixey> You can sequence and infinite list of  print "SPAM"
14:55:30 <BONUS> you can, but like the other, it will never really produce a result
14:55:34 <vixey> try it  sequence (repeat (print "SPAM")) :P
14:55:40 <BONUS> just keep producing side effects :)
14:56:05 <CakeProphet> > let ops = Map.fromList [("+", (+)), ("-", (-)), ("*", (*)), ("/", (/)), ("^", (^))]; rpn = head . foldl calc [] . words where calc (x:y:ls) term = case (Map.lookup term ops) of {Just op -> op x y : ls; Nothing -> read term :: Double}
14:56:06 <lambdabot>   <no location info>: parse error on input `;'
14:56:40 <CakeProphet> > let ops = Map.fromList [("+", (+)), ("-", (-)), ("*", (*)), ("/", (/)), ("^", (^))]; rpn = head . foldl calc [] . words where calc (x:y:ls) term = case (Map.lookup term ops) of {Just op -> op x y : ls; Nothing -> read term :: Double} in rpn "2 2 +"
14:56:41 <lambdabot>   Add a type signature
14:56:45 <CakeProphet> :(
14:57:05 <CakeProphet> I was expecting it to work first try, -goes to overflow-
14:58:18 <drdozer> so ...
15:00:20 <dolio> > runST (sequence (replicate 1000000 (return 5)))
15:00:21 <lambdabot>   /tmp/4668758455803834807:70:64: Not in scope: `runST'
15:00:30 <dolio> , runST (sequence (replicate 1000000 (return 5)))
15:00:36 <lunabot>  Killed.
15:00:49 <tibbe__> @seen dcoutts
15:00:49 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc and #darcs. I last heard dcoutts speak 11h 56m 19s ago.
15:01:12 <drdozer> map (\_ -> 5) [1..1000000]
15:01:38 <drdozer> that runs just fine
15:01:51 <dolio> , let sequence' = foldM (liftM . flip (:)) [] in runST (sequence' (replicate 1000000 (return 5)))
15:01:52 <lunabot>  luna: Inferred type is less polymorphic than expected
15:02:17 <dolio> , let sequence' :: Monad m => [m a] -> m [a] ; sequence' = foldM (liftM . flip (:)) [] in runST (sequence' (replicate 1000000 (return 5)))
15:02:18 <lunabot>  [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
15:03:08 <dolio> That's tail recursive, but it the result list is in the opposite order of the side effects.
15:03:13 <thaldyron> \join #haskell-overflow
15:03:31 <Badger> \/
15:03:32 <dolio> You could fix that, of course.
15:04:03 <tibbe__> is it possible to depend on both base and extensible-exceptions in a cabal file or will that fail if base == 4.x?
15:04:39 <dolio> , let sequence' :: Monad m => [m a] -> m [a] ; sequence' = foldM (liftM . flip (:)) [] ; mapM' f = sequence' . map f in runST (mapM' return [1..1000000])
15:04:41 <lunabot>  [1000000,999999,999998,999997,999996,999995,999994,999993,999992,999991,9...
15:04:44 <drdozer> , let sequence' :: Monad m => [m a] -> m [a] ; sequence' = foldM (liftM . flip (:)) [] in runST (sequence'  (map return [1..1000000]))
15:04:46 <lunabot>  [1000000,999999,999998,999997,999996,999995,999994,999993,999992,999991,9...
15:05:15 <drdozer> oh, so that returns the list of results 'backwards'
15:05:23 <dolio> Yes.
15:06:12 <drdozer> but lazily?
15:06:29 <drdozer> obviously, since it ran
15:06:38 <dolio> No, it's not lazy. But it's tail recursive, so it doesn't eat stack space.
15:07:54 <drdozer> , let sequence' :: Monad m => [m a] -> m [a] ; sequence' = foldM (liftM . (:)) [] in runST (sequence'  (map return [1..1000000]))
15:07:55 <lunabot>  luna: Occurs check: cannot construct the infinite type: a = [[a]]
15:10:06 <dolio> , let sequence' :: Monad m => [m a] -> m [a] ; sequence' = liftM ($[]) . foldM (\l -> liftM (\e -> l . (e:))) id in runST (sequence' . map return $ [1..1000000])
15:10:10 <lunabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
15:10:44 <jeffwheeler> I would like a Hackage account, but it suggests I email a specific person. Can anybody here do it for me now?
15:10:44 <jeffwheeler> (http://hackage.haskell.org/packages/accounts.html)
15:11:13 <jeffwheeler> Or, I guess I should just email that person and wait?
15:11:46 <dancor> we should make lbot able to do, and vixen grills you first to make sure you are legit
15:11:52 <hugo___> hello haskl3z0rs!
15:13:10 <drdozer> @source mapM
15:13:10 <lambdabot> mapM not available
15:13:46 <Gracenotes> @check (\x -> reverse (reverse x) == x)
15:13:47 <lambdabot>   "OK, passed 500 tests."
15:14:04 <Gracenotes> hm. Is there a reason this is causing a stack overflow in my ghci?
15:14:54 <jeffwheeler> What type of data does it generate for that type of test? [Int]?
15:15:00 <vixey> > reverse (reverse [1..]) == [1..]
15:15:16 <lambdabot>   thread killed
15:15:21 <vixey> @ check \x -> x == head x : tail x
15:15:34 <vixey> @check \x -> reverse x == head x : tail x
15:15:42 <lambdabot>   "Falsifiable, after 1 tests:\n[]\n"
15:16:09 <asgaroth> @check \x -> not (null x) ==> x == head x : tail x
15:16:10 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
15:16:10 <lambdabot>           ...
15:16:24 <CakeProphet> :t toIntegral
15:16:27 <lambdabot> Not in scope: `toIntegral'
15:16:28 <Gracenotes> but, it seems that @check is doing everything just fine, and ghci is spitting a stack overflow error at me)
15:16:59 <asgaroth> Gracenotes: It's working fine for me(ghc 6.10.1)
15:17:04 <Gracenotes> hm.
15:17:20 <Gracenotes> eek, 6.8.2
15:17:24 <Gracenotes> how did that happen
15:18:51 <CakeProphet> is there a standard lib function that checks multiple maps in order for a lookup?
15:18:52 <drdozer> dolio: I've derived a mapM' and forM' from your sequence' and am re-running my problem app
15:19:31 <newsham> ?check \x -> null x || x == head x : tail x
15:19:32 <lambdabot>   "OK, passed 500 tests."
15:21:12 <emptnr_> :t 2
15:21:13 <lambdabot> forall t. (Num t) => t
15:21:31 <emptnr_> works
15:21:41 <Plouj> I'm curious, how do you run check in ghci?
15:21:44 <vixey> ?check \x -> null x || reverse x == head x : tail x
15:21:45 <lambdabot>   "OK, passed 500 tests."
15:22:23 <vixey> ?check \x -> 13*7 /= x
15:22:24 <lambdabot>   "OK, passed 500 tests."
15:22:30 <CakeProphet> where is euler's constant in Haskell?
15:22:35 <newsham> > exp 1
15:22:37 <lambdabot>   2.718281828459045
15:22:47 <CakeProphet> oh ho.
15:22:47 <emptnr_> > e
15:22:48 <drdozer> dolio: wonderful - now, what do we have to do to put these functions into Control.Monad :D
15:22:49 <lambdabot>   e
15:22:56 <emptnr_> hmm
15:23:14 <emptnr_> well, how do you calculate limits in haskell
15:23:26 <drdozer> dolio: thanks for your help - I would have been stuck for days on that
15:23:50 <sbahra> > maxBound :: Int
15:23:51 <lambdabot>   9223372036854775807
15:24:15 <ziman> > 2^64 - 1
15:24:16 <lambdabot>   18446744073709551615
15:24:21 <ziman> > 2^63 - 1
15:24:22 <lambdabot>   9223372036854775807
15:24:32 <smitty1e> N00b:  trying to calculate sol = (sqrt( mu epsilon ))^-1 and then print it, but I need to make something of an instance declaration for putStrLn( show( sol ))  to work.  Is there a URL for this?  No joy on the wiki.
15:24:47 <emptnr_> > (1+1/(98))^98
15:24:49 <lambdabot>   2.704541517488729
15:24:57 <emptnr_> > (1+1/(99))^99
15:24:59 <lambdabot>   2.704679036164759
15:25:08 * emptnr_ coughs
15:25:14 <sbahra> smitty1e, main = putStrLn $ show sol
15:25:21 <CakeProphet> what's the function that returns the right argument if its a Just x value otherwise the left one?
15:25:25 <sbahra> smitty1e, or show us your code on hpaste or codepad?
15:25:34 <sbahra> :t maybe
15:25:35 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:25:36 <emptnr_> or...
15:25:48 <smitty1e> shahra: Couldn't match expected type `Float' against inferred type `a -> c'
15:25:48 <smitty1e>  
15:26:11 <CakeProphet> > maybe (+3) Nothing 5
15:26:12 <lambdabot>   Couldn't match expected type `a -> a1 -> a1'
15:26:26 <smitty1e> Blows my mind.  There is just the one type...
15:26:26 <drdozer> :t fromJust
15:26:28 <lambdabot> forall a. Maybe a -> a
15:26:30 <emptnr_> @let fac 0 = 1; fac (n+1) = (n+1)*fac n
15:26:31 <lambdabot>   Parse error in pattern:
15:26:38 <emptnr_> ...
15:26:39 <drdozer> , fromJust $ Just "bob"
15:26:40 <lunabot>  "bob"
15:26:43 <CakeProphet> ...I don't think maybe is what I want.
15:26:44 <newsham> ?src fromMaybe
15:26:45 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
15:26:48 <newsham> ?src maybe
15:26:49 <lambdabot> maybe n _ Nothing  = n
15:26:49 <lambdabot> maybe _ f (Just x) = f x
15:26:49 <emptnr_> @let fac n = foldr (*) 1 [1..n]
15:26:51 <lambdabot>  Defined.
15:27:05 <sbahra> Don't use fromJust.
15:27:17 <koeien> how can i compile, with cabal, a package for profiling?
15:27:26 <newsham> > fromMaybe 3 (Just 5)
15:27:26 <emptnr_> > sum map (1/fac n) [1..]
15:27:28 <lambdabot>   5
15:27:28 <lambdabot>   Couldn't match expected type `[a]'
15:27:32 <sbahra> @let fac n = scanl (*) 1 [1 ..] !! n
15:27:32 <newsham> > fromMaybe 3 Nothing
15:27:33 <lambdabot>  <local>:17:0:
15:27:33 <lambdabot>      Warning: Pattern match(es) are overlapped
15:27:33 <lambdabot>               I...
15:27:33 <lambdabot>   3
15:27:36 <drdozer> CakeProphet, was fromJust what you wanted?
15:27:39 <emptnr_> i'm too tired for this
15:27:45 <emptnr_> how do you define e with haskell
15:27:57 <dcoutts> koeien: install/configure it with -p
15:28:00 <newsham> > let e = exp 1 in e
15:28:01 <lambdabot>   2.718281828459045
15:28:04 <CakeProphet> drdozer:  basically I want to take three maps, apply a lookup to each, and return the first value that isn't Nothing
15:28:08 <emptnr_> ah
15:28:12 <koeien> dcoutts: ok, thanks
15:28:19 <BONUS> CakeProphet: Maybe monad?
15:28:30 <koeien> dcoutts: there is no option for `cabal install' ?
15:28:32 <BONUS> with mplus
15:28:41 <CakeProphet> > mplus Nothing (Just 5)
15:28:42 <drdozer> CakeProphet, lookup a m1 `mplus` lookup b m2 `mplus` lookup c m3
15:28:42 <lambdabot>   Just 5
15:28:43 <emptnr_> how do i calculate the limit (e) where 99 increases from (1+1/(99))^99
15:28:50 <emptnr_> aka, smoothing
15:28:56 <newsham> > catMaybes [Nothing, Nothing, Just 3, Nothing, Just 5]
15:28:57 <lambdabot>   [3,5]
15:29:26 <emptnr_> is there a limit calculation function
15:29:27 <vixey> emptr_, I don' tthink you can really compute limits like that
15:29:33 <emptnr_> that sucks
15:29:35 <vixey> emptr_, but you can just plug in huge numbers
15:29:37 <CakeProphet> > foldl (mplus) [Nothing, Nothing, Just 4, Nothing]
15:29:38 <lambdabot>       Overlapping instances for Show ([[Maybe a]] -> [Maybe a])
15:29:38 <lambdabot>        arisin...
15:29:45 <vixey> emptr_, .... or implement an algebra system/thereom prover
15:29:46 <drdozer> Nothing `mplus` Just "Rod" `mplus` Just "Jane"
15:29:50 <drdozer> ,Nothing `mplus` Just "Rod" `mplus` Just "Jane"
15:29:52 <lunabot>  Just "Rod"
15:29:58 <newsham> > map (\n -> (1+1/n)^n) [99..]
15:29:59 <lambdabot>   Add a type signature
15:30:02 <CakeProphet> > foldl (mplus) Nothing [Nothing, Nothing, Just 4, Nothing]
15:30:03 <lambdabot>   Just 4
15:30:08 <newsham> > map (\n -> (1+1/n)^n) [99..] :: [Double]
15:30:08 <CakeProphet> > foldl (mplus) Nothing [Nothing, Nothing, Just 4, Nothing, Just 5]
15:30:09 <emptnr_> > (1+1/(9999999999))^9999999999
15:30:10 <lambdabot>       No instance for (Integral Double)
15:30:10 <lambdabot>        arising from a use of `^' at <...
15:30:10 <CakeProphet> there we go
15:30:10 <lambdabot>   Just 4
15:30:11 <lambdabot>   2.7182820432034203
15:30:16 <emptnr_> > exp 1
15:30:18 <lambdabot>   2.718281828459045
15:30:23 <newsham> > map (\n -> (1+1/n)**n) [99..] :: [Double]
15:30:24 <emptnr_> eh..pretty close
15:30:25 <lambdabot>   [2.704679036164753,2.7048138294215285,2.7049459774851603,2.705075557463504,...
15:30:31 <dcoutts> koeien: yes, the same.
15:30:43 <dcoutts> koeien: all the configure flags can be passed to install
15:30:57 <drdozer> > foldl (mplus) Nothing [Nothing, Nothing, Just 4, Nothing, Just undefined]
15:30:58 <lambdabot>   Just 4
15:31:07 <BONUS> although idk if i'd use mplus or mappend
15:31:18 <koeien> dcoutts: then it doesn't work for me. ``cabal install hmatrix -p'' ?
15:31:18 <newsham> > mconcat . map First $ [Nothing, Nothing, Just 3, Nothing, Just 5]
15:31:20 <lambdabot>   First {getFirst = Just 3}
15:31:24 <CakeProphet> what's the module for monadplus?
15:31:31 <sbahra> :i First
15:31:31 <emptnr_> i opted out of a intro to CS class today by blabbering on about monads for a while
15:31:32 <dcoutts> koeien: try --reinstall
15:31:37 <drdozer> I think it's just Control.Monad
15:31:39 <dolio> > foldl mplus Nothing $ cycle [Nothing, Just 4]
15:31:40 <BONUS> lol
15:31:43 <sbahra> @hoogle First
15:31:47 <BONUS> you can also use Data.Monoid.mappend
15:31:49 <sbahra> @src First
15:31:51 <koeien> dcoutts: that'll be it, thanks
15:31:52 <lambdabot> Data.Monoid newtype First a
15:31:52 <lambdabot> Data.Monoid First :: Maybe a -> First a
15:31:52 <lambdabot>   mueval: Prelude.read: no parse
15:31:52 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
15:31:52 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
15:31:57 <sbahra> wooops
15:32:43 <CakeProphet> @pl multilookup s ms = foldl (mplus) Nothing (map (lookup s) ms)
15:32:44 <lambdabot> multilookup = (foldl mplus Nothing .) . map . lookup
15:32:53 <CakeProphet> ...heh
15:33:45 <koeien> dcoutts: yep, my program compiles now, with profiling support. thanks a lot
15:34:16 <BONUS> > map <$> (Just (+1)) <*> (Just [2,3,4,5])
15:34:19 <lambdabot>   Just [3,4,5,6]
15:34:41 <emptnr_> lue -> Value)
15:35:04 <sbahra> :t (<*>)
15:35:07 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
15:35:13 <sbahra> :t (<$>)
15:35:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:35:17 <emptnr_>   mail -s "Hello, world." bob@b12
15:35:17 <emptnr_>   Bob, could you please write me a program that prints "Hello, world."?
15:35:17 <emptnr_>   I need it by tomorrow.
15:37:56 <int80_h> @words
15:37:56 <lambdabot> Unknown command, try @list
15:37:58 <emptnr_> this language is 90% jargon and 10% heart-wrenching beauty
15:38:01 <int80_h> @src words
15:38:01 <lambdabot> words s = case dropWhile isSpace s of
15:38:02 <lambdabot>     "" -> []
15:38:02 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
15:38:15 <emptnr_> and 15% teddy bears
15:38:40 <sbahra> @yow
15:38:40 <lambdabot> I'm having an EMOTIONAL OUTBURST!!  But, uh, WHY is there a WAFFLE in
15:38:41 <lambdabot> my PAJAMA POCKET??
15:38:44 <int80_h> emptnr: are you saying your prof let you leave your class to get you to stop talking about monads?
15:38:57 <emptnr_> lambabot sounds like fortune
15:39:04 <lupsyn> hi all
15:39:10 <emptnr_> no, int80_h
15:39:27 <int80_h> so how did you get to leave early then?
15:39:39 <lupsyn> foldt :: (Show a, Ord a) => (a -> t -> t -> t) -> t -> BST a -> t
15:39:40 <lupsyn> foldt _ z Void = z
15:39:40 <lupsyn> foldt f z ( Node x l r ) = f x ( foldt f z l ) ( foldt f z r )
15:39:40 <lupsyn> heightbst :: BST a -> a1
15:39:40 <lupsyn> heightbst = foldt f 0
15:39:40 <lupsyn> 	    where
15:39:42 <lupsyn> 		f _ ml mr = 1 + (max mr ml)
15:39:49 <lupsyn>   No instances for (Show a, Ord a)
15:39:49 <lupsyn>       arising from use of `foldt' at /Users/lupsyn/Desktop/homeworks.hs:354:14-18
15:39:49 <sbahra> lupsyn, please use a paste service.
15:39:50 <lupsyn>     Probable fix: add (Show a, Ord a) to the type signature(s) for `annotedBST1'
15:39:52 <lupsyn>     In the definition of `annotedBST1':
15:39:54 <lupsyn> 	annotedBST1 = foldt f 0
15:39:56 <lupsyn> 		    where
15:39:58 <lupsyn> 			f _ ml mr = 1 + (max mr ml)
15:40:00 <emptnr_> it's much funnier when people don't bother
15:40:00 <lupsyn> excuse me
15:40:14 <newsham> emptnr_: this language is weird.  its like they have a different word for everything.
15:40:23 <emptnr_> hehe
15:40:33 <emptnr_> int80_h: no, we had a long talk about programming
15:40:42 <emptnr_> i haven't gone to her class yet
15:40:55 <int80_h> oh I get it
15:41:05 <int80_h> she figured out you don't need to go to class
15:41:08 <lupsyn> hpaste don't work
15:41:15 <emptnr_> i'm trying to do as little work as possible for my CS minor
15:41:16 <int80_h> @where hpaste2
15:41:17 <lambdabot> http://moonpatio.com:8080/
15:41:21 <smitty1e> N00b note: you can't just randomly drop the symbol 'pi' into things without all yadda-yadda breaking loose.
15:41:24 <int80_h> lupsyn: use that instead
15:41:30 <emptnr_> > pi
15:41:32 <lambdabot>   3.141592653589793
15:41:33 <vixey> lupsyn, I suggest not using type signatures
15:41:42 <vixey> lupsyn, i.e. remove:  foldt :: (Show a, Ord a) => (a -> t -> t -> t) -> t -> BST a -> t
15:41:49 <dolio> Class is totally overrated.
15:42:18 <emptnr_> i prefer docs and source, dolio
15:42:29 <emptnr_> less agoraphobic, etc
15:42:41 <pumpkin> I should really stop using UArr in stuff I really need
15:42:50 <pumpkin> I keep encountering bugs
15:43:02 <smitty1e> dolio: Motörhead had a track "No Class" a while back...
15:44:58 <pumpkin> about sigfpe's point on mapreduce and monoids, would the reduce step be mconcat?
15:45:57 <CakeProphet> >maybe id (Just 5) 3
15:46:01 <CakeProphet> > maybe id (Just 5) 3
15:46:02 <dolio> It's a parallelized mconcat.
15:46:02 <lambdabot>   Couldn't match expected type `a -> a1 -> a1'
15:46:07 <dolio> Or something like that.
15:46:11 <CakeProphet> :t maybe
15:46:12 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:46:19 <sbahra> Anyone here using GHC on Solaris 10 x86? Specifically, using Maeder's binary distribution?
15:46:31 <CakeProphet> I don't understand how maybe works.
15:46:42 <pumpkin> dolio: is the reduce step typically parallel?
15:46:47 <sbahra> @src maybe
15:46:47 <lambdabot> maybe n _ Nothing  = n
15:46:47 <lambdabot> maybe _ f (Just x) = f x
15:46:52 <sbahra> :t maybe
15:46:53 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:47:12 <sbahra> > maybe 0 (+ 1) (Just 4)
15:47:13 <lambdabot>   5
15:47:14 <dolio> @type foldMap
15:47:15 <lambdabot> Not in scope: `foldMap'
15:47:26 <dolio> @type Data.Foldable.foldMap
15:47:26 <lambdabot> forall a m (t :: * -> *). (Monoid m, Data.Foldable.Foldable t) => (a -> m) -> t a -> m
15:47:26 <sbahra> > maybe 0 (+ 1) Nothing
15:47:30 <lambdabot>   0
15:47:34 <sbahra> CakeProphet, see?
15:47:51 <CakeProphet> oh...
15:47:55 <CakeProphet> I missed the b
15:48:01 <CakeProphet> at the front of the type signature.
15:48:27 <pumpkin> does this mean anything to anyone? minimal: internal error: freeGroup: block size is zero
15:48:34 <pumpkin> minimal being the name of my program
15:48:51 <newsham> cakeprophet: when applicable, fromMaybe is simpler.
15:49:29 <dolio> pumpkin: You can map elements in parallel and combine chunks of the list in parallel.
15:49:34 <pumpkin> fair enough
15:50:00 <lupsyn> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=846#a846
15:50:49 <int80_h> @words
15:50:49 * dolio disappears.
15:50:49 <lambdabot> Unknown command, try @list
15:50:53 <int80_h> @src words
15:50:54 <lambdabot> words s = case dropWhile isSpace s of
15:50:54 <lambdabot>     "" -> []
15:50:54 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
15:53:09 <CakeProphet> :t reads
15:53:10 <lambdabot> forall a. (Read a) => String -> [(a, String)]
15:53:29 <CakeProphet> > reads "1" :: [(Int, String)]
15:53:30 <lambdabot>   [(1,"")]
15:53:35 <CakeProphet> > reads "1" :: [(IO, String)]
15:53:36 <lambdabot>       `IO' is not applied to enough type arguments
15:53:37 <lambdabot>      Expected kind `*', bu...
15:53:43 <newsham> pumpkin: because of associativity you are free to reorder the reduce step so that you can do lots of reductions on differen tmachines in parallel before reducing their results together
15:53:54 <CakeProphet> > reads "1" :: [(IO (Maybe (Either Bool Expr))), String)]
15:53:55 <pumpkin> yeah
15:53:55 <lambdabot>   <no location info>: parse error on input `,'
15:53:57 <CakeProphet> :P
15:54:04 <CakeProphet> > reads "1" :: [(Bool, String)]
15:54:06 <lambdabot>   []
15:54:14 <ski_> > (reads :: ReadS Int) "1"
15:54:15 <lambdabot>   [(1,"")]
15:54:31 <CakeProphet> > reads "1 3" :: [(Bool, String)]
15:54:32 <lambdabot>   []
15:54:35 <ski_> @src ReadS
15:54:35 <lambdabot> Source not found. Wrong!  You cheating scum!
15:54:40 <CakeProphet> > reads "1 3" :: [(Int, String)]
15:54:41 <lambdabot>   [(1," 3")]
15:54:44 <CakeProphet> ah
15:54:46 <newsham> http://www.cs.vu.nl/~ralf/MapReduce/ <- analyzes the model of map reduce and sawzall.  good paper
15:54:50 <ski_>   type ReadS a = String -> [(a,String)]
15:55:11 <emptnr_> you haskellers and your papers
15:55:13 <pumpkin> newsham: thanks :)
15:55:19 <CakeProphet> > (reads :: ReadS Int) "1 2 3"
15:55:20 <lambdabot>   [(1," 2 3")]
15:55:21 <pumpkin> emptnr_: papers are fun
15:57:06 <Gracenotes> hm... Ubuntu's packaging system seems to think 6.8.2 is the latest version of ghc6
15:57:10 * mapreduce coughs.
15:57:15 <Gracenotes> apparently this is not so?
15:57:32 <pumpkin> Gracenotes: no one's packaged it up
15:57:41 <Gracenotes> ..ah.
15:57:50 <Gracenotes> should someone?
15:57:52 <CakeProphet> is there a quick way to get a [Either Int Double] from reads... where Right is the case that the number can be parsed as just an int, and Double the case where it can't be parsed as an Int.
15:58:08 <pumpkin> Gracenotes: certainly
15:58:09 <CakeProphet> or something similar.
16:01:58 <conal> @tell mmorrow: thanks for the highlighting-kate pointer.  do you think it could be used with a wordpress blog?  also, i wonder if there's a way to autolink from id/symbols to their documentation (cross library).
16:01:58 <lambdabot> Consider it noted.
16:02:09 <newsham> > let f x = case (reads :: ReadS Double) x of [(n,"")] -> Left n; _ -> Right ((reads :: ReadS Int) x) in f "3.1415"
16:02:11 <lambdabot>   Left 3.1415
16:02:13 <ski_> CakeProphet : you have a string which only contains the printed representation of an `Int' or a `Double' ?
16:02:17 <newsham> > let f x = case (reads :: ReadS Double) x of [(n,"")] -> Left n; _ -> Right ((reads :: ReadS Int) x) in f "3"
16:02:18 <lambdabot>   Left 3.0
16:02:22 <newsham> oops :)
16:02:27 <pumpkin> Axman6: got me another beautiful crash :P
16:02:34 <CakeProphet> ski_ yeah, but I've got a different solution now. findWithDefault. :D
16:02:36 <newsham> > let f x = case (reads :: ReadS Int) x of [(n,"")] -> Left n; _ -> Right ((reads :: ReadS Double) x) in f "3"
16:02:37 <lambdabot>   Left 3
16:02:41 <newsham> > let f x = case (reads :: ReadS Int) x of [(n,"")] -> Left n; _ -> Right ((reads :: ReadS Double) x) in f "3.1415"
16:02:43 <lambdabot>   Right [(3.1415,"")]
16:02:47 <ski_> @hoogle findWithDefault
16:02:47 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
16:02:48 <lambdabot> Data.Map findWithDefault :: Ord k => a -> k -> Map k a -> a
16:03:17 <newsham> > let f x = case (reads :: ReadS Int) x of [(n,"")] -> Left n; _ -> Right (fst . head . (reads :: ReadS Double) $ x) in f "3.1415"
16:03:18 <lambdabot>   Right 3.1415
16:03:22 <newsham> > let f x = case (reads :: ReadS Int) x of [(n,"")] -> Left n; _ -> Right (fst . head . (reads :: ReadS Double) $ x) in f "3"
16:03:24 <lambdabot>   Left 3
16:03:46 <ski_> > let f x = case (reads :: ReadS Int) x of [(n,"")] -> Left n; _ -> Right (fst . head . (reads :: ReadS Double) $ x) in f ""
16:03:46 <newsham> ?type let f x = case (reads :: ReadS Int) x of [(n,"")] -> Left n; _ -> Right (fst . head . (reads :: ReadS Double) $ x) in f
16:03:47 <lambdabot>   Right * Exception: Prelude.head: empty list
16:03:48 <lambdabot> String -> Either Int Double
16:05:24 <jeffwheeler1> @pl c f z = fmap f $ func z
16:05:24 <lambdabot> c = (. func) . fmap
16:07:46 <pumpkin> what's the easiest way to move away from UArrs to something almost as efficient but less buggy? :P
16:11:04 <jeffwheeler1> How can I get my documentation to show up on Hackage? Does Hackage automatically try to run haddock, or should it have been packaged with my sdist?
16:11:15 <jeffwheeler1> Here's the package I'm looking at: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pointedlist
16:11:58 <gwern> jeffwheeler1: hackage runs haddock in batchs
16:12:06 <jeffwheeler1> gwern: great, thanks :)
16:12:21 <gwern> personally, I think it shouldn't be a batch but immediately after so people would stop asking these questions already
16:12:22 <CakeProphet> foldl f [a..z]
16:12:25 <CakeProphet> > foldl f [a..z]
16:12:27 <lambdabot>       Overlapping instances for Show ([b] -> [Expr])
16:12:27 <lambdabot>        arising from a us...
16:12:34 <jeffwheeler1> gwern: or if it said that somewhere :P
16:12:37 <CakeProphet> > foldl f [a..g]
16:12:39 <lambdabot>       Overlapping instances for Show ([b] -> [Expr])
16:12:39 <lambdabot>        arising from a us...
16:12:47 <CakeProphet> > foldl f [a..e]
16:12:48 <lambdabot>       Overlapping instances for Show ([b] -> [Expr])
16:12:48 <lambdabot>        arising from a us...
16:12:51 <CakeProphet> ...
16:13:02 <CakeProphet> > foldl f ['a'..'z']
16:13:03 <lambdabot>       Overlapping instances for Show ([b] -> [Char])
16:13:03 <lambdabot>        arising from a us...
16:13:05 <gwern> jeffwheeler1: it does I'm sure
16:13:09 <CakeProphet> :t foldl
16:13:10 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:13:17 <jeffwheeler1> gwern: hmm, I couldn't find it, but I guess I didn't look that hard
16:13:17 <CakeProphet> -facepalm-
16:13:25 <kiris> mauke: http://www.imageput.com/hosted/7058snake.jpg
16:13:31 <CakeProphet> is there a Expr that takes two arguments?
16:13:45 <gwern> jeffwheeler1: sure it's on one of the upload pages
16:13:56 <newsham> > foldl f [a,b,c] z
16:13:58 <lambdabot>   Couldn't match expected type `[b]' against inferred type `Expr'
16:14:01 <jeffwheeler1> gwern: ah, I just used cabal; didn't even see those :P
16:14:04 <Gracenotes> kiris: oh dear >_>
16:14:11 <newsham> > foldl f z [a,b,c]
16:14:13 <lambdabot>   f (f (f z a) b) c
16:14:17 <newsham> > foldr f z [a,b,c]
16:14:19 <lambdabot>   f a (f b (f c z))
16:14:36 <CakeProphet> ah... foldr is what I want
16:14:37 <Gracenotes> > scanl f z [a,b,c]
16:14:40 <lambdabot>   [z,f z a,f (f z a) b,f (f (f z a) b) c]
16:14:48 <newsham> > foldr (+) z [a,b,c]
16:14:50 <lambdabot>   a + (b + (c + z))
16:16:24 <jeffwheeler1> > :t d
16:16:25 <lambdabot>   <no location info>: parse error on input `:'
16:16:31 <jeffwheeler1> @type d
16:16:33 <lambdabot> Expr
16:16:41 <jeffwheeler1> @type ab
16:16:42 <lambdabot> Not in scope: `ab'
16:16:51 <CakeProphet> tokenize (w:ws) = foldr lookupElse [binops,unops,constants, Number w] where lookupElse m elsecase = findWithDefault elsecase w m
16:16:53 <CakeProphet> beautiful
16:16:57 <newsham> > foldr (:) [] [a,b,c]
16:16:59 <lambdabot>   [a,b,c]
16:17:00 <CakeProphet> now.
16:17:04 <CakeProphet> er...
16:17:07 <CakeProphet> forgot to recurse.
16:17:22 <Gracenotes> lookupElse?
16:17:28 <jeffwheeler1> @src a
16:17:28 <Gracenotes> oh, I see
16:17:28 <lambdabot> Source not found. The more you drive -- the dumber you get.
16:17:35 <jeffwheeler1> Is it from that numbers pkg?
16:17:42 <CakeProphet> Gracenotes:  made it up so that it looked nice.
16:18:06 <Gracenotes> don't forget to add an initial value for foldr
16:18:09 <CakeProphet> Gracenotes:  (I'm making a reverse polish notation calculator)
16:18:10 <CakeProphet> ah... right
16:18:17 <Gracenotes> else use foldr1
16:18:19 <CakeProphet> I guess that would be (Number w)
16:18:23 <gwern> @pl foo f = Data.ByteString.Lazy.fromChunks [fromString f]
16:18:23 <lambdabot> foo = Data.ByteString.Lazy.fromChunks . return . fromString
16:18:32 * jeffwheeler1 wonders why RPN isn't taught in school
16:19:11 <newsham> you didnt go to a backwards polish school did you?
16:19:19 <jeffwheeler1> newsham: nope :(
16:19:22 <Gracenotes> I had to interpret prefix notation in high school
16:19:29 <Gracenotes> not RPN though
16:19:42 <jeffwheeler1> I've never, fortunately, seen prefix used.
16:19:48 <newsham> why would you recommend teaching rpn?
16:20:03 <Gracenotes> Lisp called, it wants its parentheses back ;)
16:20:11 <jeffwheeler1> newsham: because I prefer it. ;) Actually, the calculator-nerd teachers teach it.
16:20:12 <CakeProphet> Gracenotes:  well... I guess it's not as simple as some example RPN calculators I've seen
16:20:14 <newsham> why not just teach expression trees
16:20:21 <CakeProphet> since it can parse different n-ary operations.
16:20:31 <lament> so postfix is wonderful and prefix is crap?
16:20:34 <jeffwheeler1> I mean, the calculator-competition people use RPN. That's about it.
16:20:44 <Gracenotes> a fun assignment is parsing RPN into expression trees, then evaluating the trees
16:20:49 <jeffwheeler1> lament: It seems like it . . . prefi would be pain.
16:20:50 <lament> "fun"
16:20:53 <jeffwheeler1> * prefix
16:20:59 <Gracenotes> stack-based languages use RPN-like notation
16:21:04 <newsham> prefix > prefast
16:21:14 <lament> jeffwheeler1: postfix is pain too...
16:21:21 <Gracenotes> Factor, for instance. albeit with extra stack-reordering words, quotations, etc.
16:21:22 <jeffwheeler1> Gracenotes: ever used usr-rpl for HPs?
16:21:30 <jeffwheeler1> lament: :P
16:21:39 <Gracenotes> not sure what you're talking about :)
16:21:45 <newsham> http://www.thenewsh.com/~newsham/x/postfix.hs
16:21:55 <jeffwheeler1> UserRPL (forget how they write it) is the high-level language for HP calculators . . . kicks butt. :D
16:22:03 <Gracenotes> it took a couple of hours, but writing in RPN seems natural-ish to me
16:22:07 <jeffwheeler1> Actually, I can't imagine using it for more than five lines. But for those, it's awesome.
16:22:20 <Gracenotes> you just have to think of the stack in your head (or write it down on paper)
16:22:28 <jeffwheeler1> Or run your program a lot. :P
16:22:57 <newsham> rpn is just a serialization of the expression tree.
16:23:00 <Gracenotes> CakeProphet: how is it not as simple?
16:23:00 <newsham> why not go to the real thing?
16:23:14 <jeffwheeler1> newsham: because postfix is faster?
16:23:23 <newsham> faster than making a tree?
16:23:25 <CakeProphet> Gracenotes:  -shrug- I'm just using maps so I can add more operators to it.
16:23:31 <newsham> I write  "3 5" and a plus above it,  pretty simple
16:23:32 <jeffwheeler1> newsham: I mean the typing of it
16:23:33 <newsham> and fast
16:23:58 <jeffwheeler1> newsham: I'm merely talking about the simple typing-in of instructions to a calc; not parsing
16:24:24 <newsham> and i'm merely talking about the simpel writing down of an expression
16:24:31 <CakeProphet> Gracenotes:  if I got crazy with it I could allow new operator definitions and conditional syntax
16:24:58 <newsham> should elementary school teach you mechanisms for entering expressions into calculators?
16:25:07 <newsham> we didnt do that at all in our school and I dont miss it.
16:25:12 <Gracenotes> CakeProphet: I have an RPN-esque interpreter that does just that
16:25:26 <Gracenotes> if you're interested in entire languages based on stacks you should look into Factor
16:25:37 <jeffwheeler1> newsham: they teach you how to enter expressions in one manner, why not teach it in a faster manner?
16:25:57 <Gracenotes> CakeProphet: but, yeah. I do something like ">a 0? a 2 ?" meaning, if a is equal to zero, a, else 2
16:25:59 <newsham> jw: they didnt teach me how to enter any expressions into calculators
16:26:20 <jeffwheeler1> newsham: they taught you how to "1 + (3 / 7)" at some point, right?
16:26:28 <jeffwheeler1> newsham: probably not in elementary school, but at some point.
16:26:31 <newsham> on paper, yup.
16:26:35 <falseep> > let a = listArray ((1,1),(4,4)) [1..] in a ! (1,5)
16:26:36 <lambdabot>   5
16:26:43 <CakeProphet> Gracenotes:  if it were lazy you could just have a ternary cond operator.
16:26:45 <jeffwheeler1> newsham: and they didn't teach you how to do that on a calculator?
16:26:49 <newsham> nope.
16:26:54 * repnop loved his ti-89 in highschool
16:26:55 <jeffwheeler1> newsham: then your school was wonky. ;)
16:27:07 <jeffwheeler1> I love both my 89 and my HP 50g.
16:27:17 <Gracenotes> CakeProphet: how so? What if you start a cond and never finish it? :)
16:27:23 * whee still uses a HP 32sii
16:27:24 <jeffwheeler1> The RPN is god-awful when doing calculus. ;)
16:27:43 <Cale> jeffwheeler1: Here, calculators were mostly forbidden until grade 11 or so, at which point it was your own responsibility to learn to use one if you wanted.
16:27:52 <falseep> I'm surprised that (1,5) is a valid index for 'listArray ((1,1),(4,4)) ...', is it standard?
16:27:53 <newsham> 1 3 x / + 5 =    solve for x
16:28:11 <jeffwheeler1> Cale: funky. We have a totally different experience here (in Texas).
16:28:15 <int80_h> someone gave me the idea to write an assembler for the ti-* in haskell
16:28:26 <newsham> cale: that was more or less what it was like in my school too
16:28:39 <jeffwheeler1> newsham: that's why Infix notation is frequently called Algebraic. :)
16:28:45 <int80_h> we weren't allowed to use calculators at all in high school
16:28:46 <Gracenotes> we got to use calculators in high school, but our teachers always said "All you youngsters, over-dependent on calculators", etc.
16:29:09 <Cale> I used a calculator in highschool, but gave mine away after the first week of university.
16:29:20 <Gracenotes> for some tests we used them; for others we didn't. Some tests had calculator and non-calculator sections.
16:29:22 <Cale> (once it became clear that it was useless)
16:29:24 <pumpkin> it's pretty useless in most college math courses
16:29:59 <int80_h> yeah no one let me use a calculator on a test, so what's the point in having one?
16:30:10 <Gracenotes> :t local id
16:30:17 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => m a -> m a
16:30:41 <newsham> i'm the operator of my pocket calculator
16:30:54 <Cale> I'm glad I gave it up. There have been a few times when I came to a test where I was expected to have a calculator, but didn't end up needing one, since I can compute logarithms and such on paper anyway.
16:30:56 <newsham> cale: was pretty useful in engineering.
16:31:34 <int80_h> Cale: Well, I suspect they put more work on a test where they expect the students to have calculators.
16:31:37 <Gracenotes> logs on paper? Not to any great precision, I should hope
16:31:51 <Cale> Gracenotes: It's not hard to get a few digits.
16:32:39 <Gracenotes> huh. I'm not really one for arithmetic... even long division doesn't come easily.
16:32:43 <joma> falseep: yes i noticed that too when using listarrays for my matrix lib, veyr confusing, kind of a bug but supposedly is meant to be like that
16:32:50 <Gracenotes> without looking at the algorithm, that is
16:33:04 <Gracenotes> or deriving it myself
16:33:09 <Cale> I can't really do it in my head, of course...
16:33:28 <Cale> But on paper, it's not so bad.
16:33:29 <int80_h> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=841#a847
16:33:44 <int80_h> could someone help me out with this RWH exercise?
16:35:30 <chessguy_work> hiya int80_h
16:35:41 <int80_h> chessguy_work: hey hey :)
16:37:33 <chessguy_work> int80_h, hmm, i think you're over-complicating it
16:37:48 <chessguy_work> but i'm not sure
16:38:06 <int80_h> chessguy_work: can't use lambdas or . notation (composition)
16:38:36 <chessguy_work> geez, why don't you just use java while you're at it
16:38:45 <int80_h> chessguy_work: I used words as a model. looks the same, as far as the structure goes.
16:38:57 <chessguy_work> @src wors
16:38:58 <lambdabot> Source not found. My mind is going. I can feel it.
16:38:59 <chessguy_work> @src words
16:39:00 <lambdabot> words s = case dropWhile isSpace s of
16:39:00 <lambdabot>     "" -> []
16:39:00 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
16:40:54 <chessguy_work> xhm, i think i would have to write this from scratch to figure it out :)
16:41:24 <dublpaws> int80_h: the last splitWith example makes ghci on my machine behave strangely
16:41:26 <int80_h> chessguy_work: no worries. thanks for looking at it.
16:41:40 <dublpaws> after hitting enter after "splitWith' odd [2,2,1,4,4,3,6,6,5]
16:42:00 <int80_h> dublpaws: let me make sure I copy/pasted right
16:42:08 <chessguy_work> wait, are you not allowing yourself to use takeWhile either?
16:42:16 <chessguy_work> err, dropWhile i mean
16:42:25 <dublpaws> ghci emits a left bracket    [      and then just fails to respond.
16:42:33 <int80_h> chessguy_work: I can use dropWhile, but I don't think it does what I want.
16:42:53 <int80_h> dublpaws: oh yeah that's a broken version, hold on
16:43:07 <chessguy_work> oh
16:43:19 <chessguy_work> it does, but not without a lambda or function composition
16:43:40 <chessguy_work> have they really not covered function composition yet?
16:44:01 <int80_h> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=841#a848
16:44:13 <chessguy_work> yes, they have
16:44:16 <chessguy_work> page 105
16:44:21 <int80_h> chessguy_work: later on in the chapter they cover both lambdas and function composition
16:44:32 <cads> I have this dream of programs which are formalized proofs where the program can be extracted from the successful proof.. but in discussions about this, people bring up the halting problem and deem what I say impossible, which it is in general.
16:44:40 <int80_h> chessguy_work: but my problem is on pg 84
16:44:55 <chessguy_work> oh
16:45:05 <sbahra> lambdabot needs a unicode lookup function
16:45:13 <sbahra> anyone have _|_ handy?
16:45:14 <cads> I'm trying to think of a compelling example of a real program which we would formalize and prove correct
16:45:14 <BONUS> maybe groupBy ((==) `on` odd) and then get rid of the even ones
16:45:17 <BONUS> or w/e
16:46:47 <CakeProphet> is there a version of getArgs that doesn't split the command input into a list?
16:46:53 <int80_h> dublepaws: I reposted, try it now if you like
16:46:57 <cads> or a mental experiment to show that even though the halting (and other) problem(s) are undecidable, we can still write useful and provably correct programs by restricting our language to sentences where statements of the properties we desire are decidable.
16:47:08 <newsham> cads: the halting problem doesnt say you cant prove your programs correct.
16:47:42 <dublpaws> int80_h: it works fine here, though I don't have my haskell license yet, so can't be of much help ;)
16:47:57 <newsham> cads: how complex an example are you looking for?
16:48:03 <int80_h> dublepaws: I'm coding w/out a license too. Dangerous.
16:48:09 <Gracenotes> CakeProphet: unwords getArgs? :|
16:48:18 <newsham> for a simple program, you might prove that your sort function always returns a list having the same elements, but ordered
16:48:21 <cads> course not... the logic applied by the other party seems to be "halting problem" => not possible
16:48:23 <CakeProphet> Gracenotes:  I suppose.
16:48:32 <Gracenotes> lifting it into the IO monad, tho
16:48:58 <CakeProphet> interact f = getContents >>= return.f  right?
16:49:10 <chessguy_work> @src interact f
16:49:11 <lambdabot> Source not found. Do you think like you type?
16:49:13 <chessguy_work> @src interact
16:49:14 <lambdabot> interact f = do s <- getContents; putStr (f s)
16:49:28 <newsham> for a much more complicated examle you might try to prove that your microkernel does not let one process alter the memory used by another process without having access to a capability
16:49:54 <chessguy_work> or you could prove that the universe is expanding
16:50:09 <int80_h> it's easier to prove your mom is expanding.
16:50:15 <int80_h> ooh buuuurn.
16:50:33 * int80_h giggles
16:50:43 * chessguy_work harumphs
16:51:07 <int80_h> i'm going to send this code to haskell_cafe
16:52:00 <chessguy_work> int80_h,  might be a good one to copy -beginner on too
16:52:26 <int80_h> not familiar with that list...haskell-beginner@haskell.org?
16:52:34 <chessguy_work> err, beginners@
16:53:04 <int80_h> I figured haskell cafe was for beginners
16:53:04 <int80_h> okay I'll subscribe to that as well
16:53:04 <chessguy_work> well, they're welcome there too, it's just not dedicated to them
16:53:04 <chessguy_work> @users
16:55:57 --- mode: irc.freenode.net set +o ChanServ
16:56:10 <chessguy_work> @users
16:56:26 <chessguy_work> hm
16:56:30 <CakeProphet> @pl rpn x = either show id (eval.(map tokenize).words) x
16:56:32 <lambdabot> rpn = either show id (eval . map tokenize . words)
16:56:33 <lambdabot> Maximum users seen in #haskell: 646, currently: 566 (87.6%), active: 3 (0.5%)
16:56:52 <CakeProphet> :t either
16:56:53 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
16:57:07 <pumpkin> this is a pretty epic netsplit
16:57:22 <newsham> or-elimination
16:58:15 <newsham> > map (either ("str:"++) show) [Left "test", Right 3, Left "this", Right 5]
16:58:16 <lambdabot>   ["str:test","3","str:this","5"]
17:02:23 <pumpkin> is there a good way of getting detailed info on where all my memory is going?
17:03:06 <dons> yes.
17:03:11 <dons> RWH sez: profile!
17:03:41 <pumpkin> well the -p output seems to give me a % alloc
17:04:05 <pumpkin> is there anything more detailed?
17:04:51 <dons> yeah, check the profiling chapter of RWH for the full detail on time, space, heap , lag, retainer etc profiling
17:05:21 <pumpkin> alright, thanks :)
17:05:34 <CakeProphet> :t Map.findWithDefault
17:05:35 <lambdabot> Couldn't find qualified module.
17:05:43 <CakeProphet> :t Data.Map.findWithDefault
17:05:45 <lambdabot> forall a k. (Ord k) => a -> k -> M.Map k a -> a
17:07:08 <CakeProphet> :t round
17:07:09 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
17:07:36 <pumpkin> dons: this is really good, thanks :)
17:07:41 <dons> yay
17:07:42 <int80_h> dons: would you care to take a peek at an attempt at one of the RWH exercises? http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=841#a848
17:08:02 <CakeProphet> :t fromEnumTo
17:08:04 <lambdabot> Not in scope: `fromEnumTo'
17:08:04 <pumpkin> and it's nice because I'm not at home so I don't have my copy of RWH, but can still check it online
17:08:10 <pumpkin> enumFromTo?
17:08:12 <CakeProphet> :t enumFromTo
17:08:13 <lambdabot> forall a. (Enum a) => a -> a -> [a]
17:08:14 <CakeProphet> ...
17:08:15 <CakeProphet> yeah
17:08:36 <CakeProphet> so why doesn't.
17:08:43 <shapr> @users
17:08:43 <lambdabot> Maximum users seen in #haskell: 646, currently: 585 (90.6%), active: 14 (2.4%)
17:08:53 <CakeProphet> why doesn't product.(enumFromTo 0).round work?
17:09:16 <pumpkin> dons: I got me another crash :) I really look forward to getting past this deadline so I can track the bugs down and (help) fix them
17:09:35 <monochrom> Science has already located the center of the universe, and the center is everywhere, and everyone is in it.
17:10:06 <pumpkin> f**k
17:10:22 * pumpkin cries
17:10:41 <idnar> infinite centre
17:10:54 <pumpkin> Raw 299 :*: (((-1.0 :*: NaN) :*: 44) :*: -1.07847064612204e-12)
17:12:52 * pumpkin resolves to never use code marked as "experimental" in stuff he needs again
17:13:30 * gwern is terribly pleased with gitit performance when gzip is enabled
17:13:34 * elly frowns
17:13:50 <elly> I can't load hunit... ghci can't seem to find the package
17:15:21 <elly> it is definitely present in ~/.cabal/lib/ though
17:18:12 <yip> anyone know the name of the theorem that goes something like if f'(x)/g'(x) = 0 then the limit of f(x)/g(x) approaching 0 is also 0?
17:19:33 <dcoutts> elly: ghc-pkg list  tells you which ones are registered
17:19:38 <CakeProphet> import qualified Data.Map as M (lookup, fromList, findWithDefault)
17:19:42 <CakeProphet> ...is there a way to do... that.
17:19:56 <dcoutts> elly: the files are kept in ~/.cabal/lib, but it does not mean it's registered for any particular version of ghc
17:19:57 <SubStack> l'Hôspital?
17:20:07 <yip> SubStack: yes! thanks!
17:20:09 <dcoutts> elly: you can unregister and forget to delete the files for example
17:20:23 <elly> dcoutts: I just asked cabal to install it though
17:20:31 <elly> dcoutts: reinstall it, rather
17:20:32 <dolio> CakeProphet: Why? There isn't.
17:20:35 <monochrom> l'Hôpital
17:20:58 <monochrom> l'Hospital if you don't use ô
17:21:09 <CakeProphet> dolio:  because I use some things in Data.Map frequently, but only one thing that I use (the map function) conflicts with existing functions.
17:21:31 <pumpkin> CakeProphet: why would you only import a few of them though?
17:21:32 <dolio> It conflicts with other functions you're importing into M?
17:21:42 <pumpkin> if they're in a different namespace, why worry about sticking more in?
17:21:48 <yip> monochrom: thanks, SubStack beat you to it though
17:22:07 <pumpkin> yip: he might have been correcting SubStack's spelling :P
17:22:07 <monochrom> No, I'm correcting SubStack.
17:22:13 <yip> oh, ok sorry my bad then
17:22:23 <monochrom> I never beat up people. I correct them.
17:22:34 <dcoutts> elly: does ghc-pkg list say it's there?
17:22:37 <monochrom> "He who strikes last strikes fast" :)
17:22:45 <CakeProphet> pumpkin:  I don't understand what you mean. I want things like findWithDefault to not require a qualifier, but map to require one... is that not possible?
17:23:03 <Japsu> wasn't l'Hospital the one that states that if lim f(x)/g(x) appears 0/0 or inf/inf and f(x) and g(x) are both continuous and twice derivable, lim f(x)/g(x) = lim f'(x)/g'(x)
17:23:12 <dcoutts> elly: are you by any chance using "runghc Setup.hs configure" rather than "cabal configure"?
17:23:24 <elly> dcoutts: I was just using 'cabal install hunit'
17:23:40 <monochrom> Japsu is more right.
17:23:46 <dolio> CakeProphet: Then you need two import lines.
17:23:50 <dcoutts> elly: yes, but after that you said it could not be found, what did you run that said it could not be found?
17:23:51 <CakeProphet> ah okay.
17:24:00 <CakeProphet> dolio:  that's what I needed to know. thanks.
17:24:04 <dolio> One that imports the module qualified, and another that imports the specific functions unqualified.
17:24:08 <elly> dcoutts: ghci, then ":m +HUnit"
17:24:10 <yip> now i just need to figure out if l'Hospital is actually helpful for this problem :|
17:24:23 <dcoutts> elly: ohh, ok. You need to use the right module name, that's all.
17:24:54 <elly> what's the right module name?
17:25:01 <dcoutts> elly: check the HUnit documentation for the module names
17:25:10 <elly> the HUnit documentation tells me to "import HUnit"
17:25:28 <dcoutts> you must have found a very very old version
17:25:36 <dcoutts> where did you see that btw?
17:25:41 <dcoutts> @hackage HUnit
17:25:42 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HUnit
17:26:00 <dcoutts> elly: the latest version and documentation is always on hackage ^^
17:26:22 <elly> aha, Test.HUnit
17:26:23 <elly> thanks :)
17:26:27 <dcoutts> elly: ah, yes the sourceforge homepage looks very old :-(
17:26:41 <dcoutts> 2002 apparently
17:27:27 <blackh> elly: Here's an example of me using HUnit http://blacksapphire.com/~blackh/haskell/connect4.hs
17:39:21 <CakeProphet> > product.(enumFromTo 0).round 5.1932
17:39:22 <lambdabot>       No instance for (Integral (a1 -> a))
17:39:22 <lambdabot>        arising from a use of `roun...
17:39:35 <CakeProphet> o rite
17:39:41 <CakeProphet> > (product.(enumFromTo 0).round) 5.1932
17:39:42 <lambdabot>   0
17:39:51 <CakeProphet> > (product.(enumFromTo 1).round) 5.1932
17:39:52 <lambdabot>   120
17:40:03 <dolio> > product . enumFromTo 1 . round $ 5.1932
17:40:04 <CakeProphet> > (product.(enumFromTo 1).round) (5.1932::Double)
17:40:04 <lambdabot>   120
17:40:05 <lambdabot>   120
17:40:12 <CakeProphet> hmmm... then why isn't it working in my code.
17:40:35 <CakeProphet> :t (product.(enumFromTo 1).round)
17:40:36 <lambdabot> forall a a1. (RealFrac a1, Integral a) => a1 -> a
17:40:49 <CakeProphet> @src RealFrac
17:40:49 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
17:40:49 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
17:40:49 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
17:40:55 <chessguy_work> int80_h,  ok, i figured out what's wrong with your code
17:41:13 <int80_h> chessguy_work: hah, I just submitted to beginners too...okay, let me have it
17:41:33 <CakeProphet>     No instance for (Integral Double) arising from a use of `round' at lol.hs:23:37-41
17:41:41 <chessguy_work> what does subset evaluate to, in the first pass?
17:41:54 <CakeProphet> ...why is round complaining about its input not being an Integral?
17:42:11 <dolio> It's complaining about the result.
17:42:26 <dolio> Which is probably required to be Double for some reason.
17:42:39 <int80_h> chessguy_work: I hope you used the updated version. The one you looked at first broke ghci
17:42:53 <chessguy_work> it's ok, i'm parsing it with my brain :)
17:43:03 <CakeProphet> oh ho... fromIntegral to the rescue.
17:43:25 <chessguy_work> @quote fromIntegral
17:43:26 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
17:43:39 <dolio> > product . enumFromTo 1 $ 5.1932
17:43:41 <lambdabot>   120.0
17:43:54 <CakeProphet> O'
17:44:02 <dolio> > product . enumFromTo 1 $ 5.99999
17:44:03 <lambdabot>   720.0
17:44:11 <CakeProphet> I'm sure this question gets asked all the time, but how do you clip out the .- from the end if it's a whole number?
17:44:14 <int80_h> chessguy_work: so where is it broken?
17:44:18 <CakeProphet> .0 I mean
17:44:41 <dolio> I don't know if there's any way to do that.
17:44:53 <CakeProphet> I suppose you could do it manually.
17:45:13 <chessguy_work> int80_h, i'm trying the socratic method here, bear with me
17:45:18 <dolio> @type showFFloat
17:45:18 <CakeProphet> for large numbers that's very inefficient though
17:45:19 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
17:45:27 <int80_h> chessguy_work: I can dig that. go for it
17:45:28 <chessguy_work> int80_h, better yet, what does x' evaluate to, start with that
17:45:34 <dolio> > showFFloat (Just 0) 720 ""
17:45:35 <lambdabot>   "720"
17:45:39 <dolio> > showFFloat (Just 0) 720.1 ""
17:45:40 <lambdabot>   "720"
17:45:41 <CakeProphet> > showFFloat (show 5 :: Double)
17:45:42 <lambdabot>   Couldn't match expected type `Double'
17:45:42 <chessguy_work> int80_h, (in the first pass)
17:45:50 <CakeProphet> > showFFloat (show (5 :: Double))
17:45:51 <lambdabot>   Couldn't match expected type `Maybe Int'
17:46:03 <CakeProphet> ...what does the Maybe Int do?
17:46:14 <dolio> > showFFloat (Just 7) 720.1 ""
17:46:15 <lambdabot>   "720.1000000"
17:46:23 <necroforest> Hi, I have a function thats like this:  f x = filter g (map h x)
17:46:30 <CakeProphet> hmmm... that'll cut off not-whole-number floats though.
17:46:32 <necroforest> Can I get rid of the 'x' ?
17:46:40 <dolio> Right.
17:46:45 <chessguy_work> @pl \x -> filter g (map h x)
17:46:45 <lambdabot> filter g . map h
17:46:51 <necroforest> ah
17:46:53 <necroforest> thanks
17:46:58 <necroforest> what does @pl stand for?
17:47:08 <dolio> pointless
17:47:13 <chessguy_work> necroforest, "pointless". it removes the "point" in the code
17:47:18 <chessguy_work> @help pl
17:47:18 <necroforest> got it
17:47:19 <lambdabot> pointless <expr>. Play with pointfree code.
17:47:25 <necroforest> i forgot the term for that
17:47:27 <CakeProphet> ...I've never figured out what "point means"/
17:47:30 <chessguy_work> i think you can also do:
17:47:32 <int80_h> chessguy_work x` binds to .. hold on, I'm confused trying to work it out
17:47:35 <CakeProphet> ... "point"
17:47:36 <chessguy_work> @pl f x = filter g (map h x)
17:47:36 <lambdabot> f = filter g . map h
17:47:52 <pumpkin> CakeProphet: http://www.haskell.org/haskellwiki/Pointfree goes over it a bit
17:48:15 <pumpkin> " The term originated in topology, a branch of mathematics which works with spaces composed of points, and functions between those spaces. So a 'points-free' definition of a function is one which does not explicitly mention the points (values) of the space on which the function acts. In Haskell, our 'space' is some type, and 'points' are values."
17:49:33 <int80_h> chessguy_work: I think x' binds to the result of "break odd x"
17:49:36 <gwern> an interesting day in haskell. patch-tag, happstack (gzipp'd gitit) and so on
17:49:53 <chessguy_work> err, no
17:49:55 <int80_h> chessguy_work: I mean "break odd x'"
17:50:01 <gwern> poor byorgey will have a lot to write about this hwn!
17:50:03 <chessguy_work> still no :)
17:50:17 <int80_h> chessguy_work: okay hold on
17:50:35 <chessguy_work> int80_h, ok, start with the takeUntil p x
17:50:50 <chessguy_work> int80_h, what's the value of that (strictly speaking)
17:53:20 <necroforest> @pl f x y = g x (f x y)
17:53:20 <lambdabot> f = fix (liftM2 (.) g)
17:53:21 <int80_h> chessguy_work: it would be "takeUntil odd [2,2,1,4,4,3,6,6,5]"
17:53:37 <chessguy_work> int80_h, yes
17:53:38 <necroforest> @pl f x y = g x (h x y)
17:53:38 <lambdabot> f = liftM2 (.) g h
17:53:40 <chessguy_work> int80_h, which is?
17:54:04 <gwern> > 31818 + 46007 + 896
17:54:05 <lambdabot>   78721
17:54:27 <sw17ch> is there a library that parses command line arguments on hackage anywhere?
17:54:32 <sw17ch> a cursory glance turned up nothing
17:54:33 <necroforest> where did liftM2 come from in there? there's no monads involved
17:54:37 <int80_h> chessguy_work: [2,2]
17:55:10 <chessguy_work> int80_h, yes
17:55:15 <chessguy_work> then what happens to that?
17:55:23 <sw17ch> :t f x y = g x (f x y)
17:55:24 <lambdabot> parse error on input `='
17:55:24 <blackh> sw17ch: System.Console.GetOpt comes with ghc 6.10.1
17:55:29 <chessguy_work> int80_h, (in the case)
17:55:31 <sw17ch> orly...
17:56:11 <sw17ch> thanks blackh
17:56:16 <int80_h> it get's evalutaed here "x' -> subset : splitWith' p x''
17:56:28 <int80_h> chessguy_work: which is what you were asking...
17:56:40 <chessguy_work> int80_h, yes, so x' = ?
17:56:42 <int80_h> okay hold on let me think about this. This is new notation for me
17:57:04 * pumpkin screams at his segfault
17:57:04 <chessguy_work> oh, ok
17:57:12 <chessguy_work> int80_h, i can just explain it to you
17:57:16 <necroforest> sw17ch, it should bet :t f = (:t x) -> (:t y) -> (return :t of g)
17:57:32 <chessguy_work> int80_h, it's just like pattern matching
17:57:47 <int80_h> chessguy_work: okay...I admit I took the pattern from the function words and tried to use it for this exercise, without understanding it.
17:57:52 <chessguy_work> int80_h, the [2,2] just gets bound to x'
17:58:04 <sw17ch> :t \x y -> g x (f x y)
17:58:05 <lambdabot> forall t t1 t2 t3. (SimpleReflect.FromExpr (t -> t2 -> t3), SimpleReflect.FromExpr (t -> t1 -> t2)) => t -> t1 -> t3
17:58:11 <chessguy_work> so you can substitute [2,2] into the right-hand side where you see x'
17:58:20 <int80_h> chessguy_work: what about the recursive part?
17:58:40 <chessguy_work> int80_h, you haven't gotten to that yet
17:59:16 <int80_h> chessguy_work: okay I see that where (subset, x'') = break p x' doesn't do what I want, if x' is [2,2]
17:59:19 <chessguy_work> now you need to evaluate "subset : splitWith' p x where (subset, x'') = break p [2,2]
17:59:22 <ac> so back when I used oss, I could do stuff like "cat foo > /dev/dsp" and crap would play. How do I do that with alsa?
17:59:22 <chessguy_work> "
17:59:27 <ac> oops, wrong channel
17:59:32 <chessguy_work> int80_h, yes, good
18:00:07 <chessguy_work> int80_h, you don't want takeUntil there
18:00:19 <chessguy_work> int80_h, you want dropUntil
18:00:28 <necroforest> @pl f x = (g x) . (h x)
18:00:28 <lambdabot> f = liftM2 (.) g h
18:00:37 <necroforest> urghhh!
18:00:46 <necroforest> :t .
18:00:47 <lambdabot> parse error on input `.'
18:00:50 <chessguy_work> @type (.)
18:00:51 <necroforest> :t (.)
18:00:52 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
18:00:52 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
18:00:55 <int80_h> chessguy_work: that was my first thought, but I decided that was the wrong function
18:01:10 <int80_h> chessguy_work: okay I'll re-write
18:01:52 <pjdelport> necroforest: that's the (r ->), or reader monad
18:02:05 <CakeProphet> @unpl g = liftM2 (n) g h
18:02:05 <lambdabot> g = g >>= \ b -> h >>= \ a -> return (n b a)
18:02:14 <CakeProphet> @unpl g = liftM2 (.) g h
18:02:14 <lambdabot> g = g >>= \ b -> h >>= \ a -> return (\ j -> b (a j))
18:02:19 <CakeProphet> ...
18:02:29 <int80_h> chessguy_work: oh I see why I thought it was the wrong function initially. I mis-understood the spec. By the time I understood it, I was already working with my current code, trying to fix it
18:02:35 <chessguy_work> CakeProphet, what are you trying to so?
18:02:36 <necroforest> reader monad?
18:02:53 <CakeProphet> chessguy_work:  I was seeing how good @unpl worked.
18:03:00 <CakeProphet> *well
18:03:12 <chessguy_work> int80_h, you might do well to try to get at least the overall flow of how "words" works
18:03:13 <monochrom> monadus readetatis
18:03:17 <chessguy_work> @src words
18:03:17 <lambdabot> words s = case dropWhile isSpace s of
18:03:17 <lambdabot>     "" -> []
18:03:17 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
18:03:39 <chessguy_work> int80_h, do you want me to explain that to you a bit?
18:04:00 <int80_h> chessguy_work: let me try
18:04:04 <chessguy_work> k
18:05:05 <int80_h> chessguy_work: I'm going to fire up ghci hold on
18:06:05 <Gracenotes> @hoogle m a -> (a -> m a) -> m a
18:06:05 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
18:06:05 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
18:06:05 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
18:06:11 <Gracenotes> hrm
18:06:30 <pjdelport> necroforest: functions are instances of Functor, Monad, etc.
18:06:44 <necroforest> Oh, ok
18:06:51 <pjdelport> necroforest: fmap is composition
18:06:59 <pjdelport> > (+1) . (*2) $ 5
18:07:01 <lambdabot>   11
18:07:06 <pjdelport> > (+1) `fmap` (*2) $ 5
18:07:07 <lambdabot>   11
18:07:32 <pumpkin> > (+1) <$> (*2) $ 5
18:07:33 <necroforest> Is there a function like `mod` that has the property that x `mod` n is in the range [0,n) ?
18:07:33 <lambdabot>   11
18:07:44 <necroforest> (specifically,k when x is negative)
18:07:59 <pumpkin> > -5 `rem` 3
18:07:59 <necroforest> s/k//
18:08:01 <lambdabot>   -2
18:08:04 <pumpkin> > -5 `mod` 3
18:08:06 <lambdabot>   -2
18:08:08 <pumpkin> hmm
18:08:27 <int80_h> chessguy_work: this is what I have
18:08:29 <ddarius> > -5 `mod` -3
18:08:30 <lambdabot>       precedence parsing error
18:08:30 <lambdabot>          cannot mix `mod' [infixl 7] and prefi...
18:08:33 <mjb> necroforest: Remainder?
18:08:35 <ddarius> > -5 `mod` (-3)
18:08:37 <lambdabot>   mueval: Prelude.read: no parse
18:08:37 <lambdabot>  mueval: GhcException mkTopLevEnv: not a hom...
18:08:38 <int80_h> chessguy_work: words "the quick brown fox"
18:08:46 <int80_h> chessguy_work: s' -> ["the"]: words "quick brown fox"
18:08:57 <necroforest> mjb, doesn't work
18:09:03 <ddarius> > -5 `rem` (-3)
18:09:04 <lambdabot>   -2
18:09:05 <necroforest> > (-33) `mod` 12
18:09:07 <lambdabot>   3
18:09:08 <chessguy_work> int80_h, no
18:09:15 <necroforest> orly
18:09:21 <int80_h> chessguy_work: explain?
18:09:27 <milton13_> what is this () called?
18:09:30 <chessguy_work> > dropoWhile even [2,3,4]
18:09:30 <pumpkin> unit
18:09:31 <lambdabot>   Not in scope: `dropoWhile'
18:09:33 <necroforest> > (-33) `rem` 12
18:09:34 <lambdabot>   -9
18:09:37 <chessguy_work> > dropWhile even [2,3,4]
18:09:38 <ddarius> milton131: It's read as "unit"
18:09:39 <lambdabot>   [3,4]
18:09:53 <pjdelport> necroforest: yeah, the - doesn't bind tightly
18:09:53 <chessguy_work> int80_h, oh wait, maybe i'm misunderstanding you
18:10:07 <int80_h> chessguy_work: I was trying to do a first pass
18:10:21 <chessguy_work> int80_h, what are you saying ["the"] is?
18:10:29 <pjdelport> necroforest: so -5 `rem` (-3) parses as -(5 `rem` (-3))
18:10:54 <int80_h> chessguy_work: "the" binds to s'
18:11:09 <ddarius> pjdelport: Good call.  I knew something was wrong.
18:11:11 <necroforest> pjdelport, yeah i wasn't having issues with that, that was ddarius
18:11:22 <int80_h> I mean ["the']
18:11:26 <chessguy_work> int80_h, ok, then i was right the first time, you're wrong :)
18:11:29 <int80_h> ["the"]
18:11:36 <pjdelport> necroforest: sorry, same applies to your example, i mean
18:11:40 <pjdelport> > -5 `mod` 3
18:11:42 <lambdabot>   -2
18:11:44 <pjdelport> > (-5) `mod` 3
18:11:45 <lambdabot>   1
18:11:51 <int80_h> chessguy_work: okay could you explain how it works then?
18:12:04 <necroforest> pjdelport, oh, i missed that
18:12:09 <chessguy_work> int80_h, ok, first, the dropWhile isSpace gets rid of any leading whitespace
18:12:14 <chessguy_work> int80_h, in your case, there is none
18:12:17 <sjanssen> @yow
18:12:17 <lambdabot> My mind is a potato field ...
18:12:26 <pumpkin> this is wonderful... so I run my program that does lots of number crunching for ages, and it spits out a bunch of NaNs! so I double check and indeed there's no way for me to be generating NaNs in my code, so I write a simple function to sanity check each of my steps and Debug.Traces a message if there's a NaN in it. If I call this function in the first place I can think of, it segfaults my program :(
18:12:32 <necroforest> > (-5) `rem` 3
18:12:33 <lambdabot>   -2
18:12:37 <necroforest> > (-5) `mod` 3
18:12:39 <lambdabot>   1
18:12:46 <necroforest> I guess that's what I need then?
18:12:47 <chessguy_work> int80_h, so the _whole_ rest of the string, after the (in this case non-existent) whitespace, gets bound to s'
18:12:51 <pjdelport> necroforest: yup
18:12:56 <necroforest> (Doing arithmetic in Z_n)
18:13:00 <Gracenotes> what's a good way to represent a heterogeneous stack in Haskell?
18:13:02 <pjdelport> necroforest: there's also divMod, which is commonly useful
18:13:13 <int80_h> chessguy_work: so what does the recursive part look like?
18:13:19 <ski_> (and `quotRem')
18:13:20 <pumpkin> Gracenotes: existential types, I guess? what for?
18:13:25 <pjdelport> Gracenotes: how heterogeneous?
18:13:46 <Gracenotes> possibly strings, integers, lists
18:13:54 <pumpkin> you could represent each with its own constructor
18:13:59 <pumpkin> in a datatype you store in the stack
18:14:01 <pjdelport> Gracenotes: what operations do they share?
18:14:02 <chessguy_work> int80_h, so you get w : words s'' where (w,s'') = break isSpace "the quick brown fox"
18:14:21 <pumpkin> Gracenotes: if you just want to store arbitrary stuff with no constraints on it, it's not very useful
18:14:29 <Gracenotes> none, really. There are only operations specific to certain types
18:14:31 <pumpkin> because you can't do anything to what you pull out of it
18:14:51 <pumpkin> (unless you unsafeCoerce it and cross your fingers :P)
18:14:55 <chessguy_work> int80_h, so you have to evaluate the break isSpace "...", in order to get the w and s'' to plug into the result
18:15:08 <chessguy_work> well, to plug into the recursive part
18:15:13 <dolio> (Almost) Everything shares one thing in common: Typeable.
18:15:35 <Gracenotes> it's kind of inconvenient, because some functions won't work for some types, so errors may have to be thrown left and right (npi)
18:15:42 <ddarius> Tony is such a great computer scientist: http://lambda-the-ultimate.org/node/3186
18:16:04 <chessguy_work> int80_h, break isSpace "the quick brown fox" evaluates to ("the"," quick brown fox")
18:16:36 <pumpkin> it must be unfortunate to have a surname like that
18:16:42 <chessguy_work> int80_h, so your recursion winds up being "the" : words "quick brown fox"
18:17:00 <ddarius> pumpkin: I doubt he has any problems with it.
18:17:11 <dolio> Everyone knows who he is, though, so it's probably not a problem.
18:17:12 <pumpkin> not now, but in middle school maybe :P
18:17:31 <chessguy_work> int80_h, which i thought you might have been saying to begin with
18:17:46 <chessguy_work> int80_h, but that doesn't get bound to s'
18:17:54 <newsham> chessguy: unfold with break isSpace
18:18:09 <chessguy_work> newsham, huh?
18:18:16 <int80_h> chessguy_work: oh, see I thought it did
18:18:37 <chessguy_work> int80_h, no, you bind to s' to figure out what gets plugged into the right side, not the other way around
18:18:48 <newsham> ?let unfoldUntil p f = unfoldr (\x -> guard (not (p x)) >> return (f x))
18:18:49 <lambdabot>  Defined.
18:19:05 <chessguy_work> int80_h, once you know s', substitute into the right side to get the final result
18:19:17 <newsham> > unfoldUntil null (second (drop 1) . span (/= ' ')) "test this out"
18:19:18 <lambdabot>   ["test","this","out"]
18:19:34 <chessguy_work> newsham, i'm trying to explain to him how words works
18:19:43 <Gracenotes> @seen EvilTerran
18:19:43 <lambdabot> I saw EvilTerran leaving #haskell 1d 2h 45m 14s ago, and .
18:20:00 <newsham> sorry i missed the earlier context
18:20:01 <newsham> :(
18:20:26 <dolio> chessguy_work: Just tell him about terminal coalgebras. That'll clear everything up.
18:20:34 * chessguy_work grins
18:20:45 * chessguy_work starts drawing categorical diagrams
18:20:58 <chessguy_work> (as if i know what they are)
18:21:10 <int80_h> don't call them terminal coalgebras. that's morbid. call them "fuzzy cute math things"
18:21:16 <ddarius> The theory of initial algebras/terminal coalgebras is simple, basic, and fun to work through.
18:21:44 <ddarius> int80_h: Goguen has an awkward situation in that regard in "What is unification?"
18:21:50 <chessguy_work> int80_h,  starting to make sense?
18:21:57 <int80_h> chessguy_work : yes
18:22:38 <Gracenotes> hm. EvilTerran mentioned that he had written an RPN monad, and I'm trying to do the same thing... except I'm having a bit of trouble using newtype RPN a = RPN ([a] -> [a]). Am I going about it the right way?
18:23:09 <Gracenotes> for instance, with unop op = RPN $ \(x:xs) -> (op x):xs
18:23:16 <dino-> Just upgrading now to 6.10. I have to say, everything is really absurdly easy with cabal-install. Fantastic work you guys.
18:23:21 <ddarius> Gracenotes: That's not even a functor.
18:23:29 <Gracenotes> yeah, I thought so.
18:23:39 <int80_h> chessguy_work: I'll need to get the copy our dialogue when it makes it into the archives
18:23:42 <Gracenotes> well, it works, but it's not a monad.
18:23:53 <Gracenotes> So how would you suggest writing something that *is* an RPN monad?
18:24:13 <ddarius> Gracenotes: I would suggest not trying to make an RPN monad.
18:24:25 <pumpkin> Gracenotes: what would make it monadic?
18:24:31 <pumpkin> Gracenotes: return/bind etc.?
18:25:08 <Gracenotes> the code he presented was "runRPN $ do push 1; push 2; binop (+); ..."
18:25:25 <chessguy_work> so...RPN = State Int
18:25:26 <Gracenotes> as far as I know, only using >>, not >>=. But nonetheless, he did say he wrote one, somehow.
18:25:29 <pumpkin> oh, so you're just storing the stack
18:25:37 <pumpkin> as state
18:25:41 <chessguy_work> err, State [Int]
18:25:55 <Gracenotes> it seemed suspiciously similar to state :|
18:25:57 <pumpkin> Gracenotes: then push can simply cons something onto the front
18:26:28 <ddarius> Gracenotes: http://www.eecs.usma.edu/webs/people/okasaki/pubs.html#hw02
18:26:46 <Gracenotes> in my not-terribly-monadic interpretation, push a = RPN $ \xs -> a:xs
18:26:48 <ddarius> Gracenotes: There's a more involved paper in that vein by Ralf Hinze.
18:26:50 <defun> how would one convert an Int to a [Int]? i.e. 123456789 -> [1,2,3,4,5,6,7,8,9]
18:27:08 <ddarius> > map digitToInt . show $ 123456789
18:27:09 <lambdabot>   [1,2,3,4,5,6,7,8,9]
18:27:10 <pumpkin> defun: map digitToInt . show
18:27:17 <defun> thanks
18:27:21 <chessguy_work> aww, that's cheating
18:27:25 <pumpkin> lol
18:27:33 <pumpkin> repeatedly divmod by 10 then
18:27:36 <Gracenotes> ddarius: hm. That's disappointing; I'll have to ask EvilTerran about it
18:27:39 <chessguy_work> that's more like it!
18:27:42 <islon_s> if i declare a data MyData and put "deriving (Eq)" on it do i need to declare an "instance Eq MyData" and implement the methods?
18:27:45 <Gracenotes> any other monads doing useful things you'd suggest writing?
18:27:51 <chessguy_work> islon_s, no
18:28:00 <Gracenotes> the only reason I tried to do it was because it seem he pulled it off :)
18:28:06 <pumpkin> Gracenotes: make a Bool monad!
18:28:08 <pumpkin> :P
18:28:10 <chessguy_work> Gracenotes, it would be instructive to do
18:28:30 <chessguy_work> Gracenotes, unless you're familiar with the innards of State
18:28:34 <ddarius> Gracenotes: Most of the monads worth writing are already written or are combinations of basic monad transformers.
18:28:49 <Gracenotes> I'm familiar with State, yeah.
18:28:56 * pumpkin feels helpless
18:28:57 <Gracenotes> I could writing RPN using State, maybe.
18:29:34 <ddarius> Gracenotes: You could, but even that's kind of pointless.
18:29:54 <chessguy_work> Gracenotes, then you would just need to write push :: Int -> Stack (), binop :: (Int -> Int -> Int) -> Stack (), etc.
18:29:56 <Gracenotes> *write
18:29:56 <newsham> > runState (do { rpush 3; rpush 5; rpush 2; rop (*); rop (+) }) []
18:29:58 <lambdabot>   (13,[13])
18:29:58 <pumpkin> Gracenotes: I did the lazy version of that... just went and looked at the source to the various Monad instances
18:29:59 <ddarius> I think the reason EvilTerran did it was to get do notation.
18:30:21 <Gracenotes> do notation is rather convenient.
18:30:23 <islon_s> how do i know if i can derive the class or i have to make an instance?
18:30:33 <ddarius> Gracenotes: Simply using [Int] -> [Int] functions directly (or whatever type of values on the stack) is more sensical.
18:30:50 <ddarius> You'd write something like push 1 >>> push 2 >>> add
18:31:08 <ddarius> Gracenotes: If you want to minimize that syntactic overhead, read the paper I referenced above.
18:31:27 <Gracenotes> @instances Monoid
18:31:29 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
18:31:39 <pumpkin> which was the Endo one again?
18:31:46 <ddarius> @src Endo
18:31:47 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
18:31:48 <Gracenotes> Endo is an (a -> a) wrapper
18:31:50 <Gracenotes> iirc
18:31:55 <pumpkin> oh yeah
18:32:19 <Gracenotes> which would work with [Int] -> [Int], probably.
18:32:32 <Gracenotes> but... I'll take a look at the paper
18:32:45 <ddarius> Yes it would, but push 1 `mappend` push 2 `mappend` add is much uglier.
18:33:03 <ddarius> (and would require adding extra Endo/appEndo wrappers/unwrappers.
18:33:06 <Gracenotes> mconcat would look nicer
18:33:08 <pumpkin> if they'd just made <> into the operator for monoid
18:33:21 <Gracenotes> if you knew everything in advance
18:33:28 <Gracenotes> @type rpush
18:33:29 <lambdabot> forall a (m :: * -> *). (MonadState [a] m) => a -> m ()
18:33:36 <Gracenotes> hm.
18:34:35 <Gracenotes> all right, there goes my suspension of disbelief about the RPN monad. Okay then :) *reads*
18:36:20 <dino-> islon_s: I'm not sure how to judge it. If your type is "simple enough", it can auto derive.
18:36:54 <dino-> If the compiler can see already that the types your type is composed are instances of the class you'd like to derive.
18:37:21 <dolio> > let postfix0 f s k = k (f s) ; postfix1 f s x k = k (f x s) ; postfix2 f s x1 x2 k = k (f x1 x2 s) ; push = postfix1 (\x s -> (x,s)) ; bin = postfix1 (\f (x,(y,s)) -> (f x y, s)) ; start k = k () ; end s = s in start push 1 push 2 bin (+) end
18:37:22 <lambdabot>   (3,())
18:37:37 <dolio> > let postfix0 f s k = k (f s) ; postfix1 f s x k = k (f x s) ; postfix2 f s x1 x2 k = k (f x1 x2 s) ; push = postfix1 (\x s -> (x,s)) ; bin = postfix1 (\f (x,(y,s)) -> (f x y, s)) ; start k = k () ; end s = s in start push 1 push 2 push 3 bin (-) bin (+) end
18:37:39 <lambdabot>   (2,())
18:37:47 <dino-> er, composed of
18:37:56 <somnolence> why is this always returning 0
18:37:57 <somnolence> let func n tot = if n == 21 then func (n+1) (tot+2*n) else tot
18:37:58 <somnolence> ?
18:38:13 <Gracenotes> dolio: looks suspiciously like continuations, but not quite.
18:38:15 <islon_s> dino-: thanks =)
18:38:51 <dino-> islon_s: In some cases, you may need to explicity step in and say "No, THIS is how you compare these things" or whatever it is.
18:39:18 <islon_s> dino-: got it
18:39:31 * ddarius is wondering if he has every read all of the paper he referenced.
18:39:31 <dino-> And there's machinery for things like Show to basically "serialize" your type by default so you get text that should Read back in unless you instance the Show differently.
18:40:21 <somnolence> > let func n tot = if n == 21 then func (n+1) (tot+2*n) else tot in func 1 0
18:40:23 <lambdabot>   0
18:40:27 <somnolence> why is that
18:40:29 <somnolence> returning 0 =.=
18:40:43 <ddarius> somnolence: Evaluated it by hand.  It's quite obvious.
18:40:44 <somnolence> oh right
18:40:44 <somnolence> lol
18:40:47 <somnolence> sorry sleepy
18:40:48 <somnolence> 0.0
18:41:19 <Gracenotes> @check \x -> x == read (show x)
18:41:20 <ddarius> somnolence: Your nick would suggest that.
18:41:21 <lambdabot>   "OK, passed 500 tests."
18:41:36 <Gracenotes> @type \x -> x == read (show x)
18:41:37 <lambdabot> forall a. (Eq a, Read a, Show a) => a -> Bool
18:41:49 <islon_s> what @check do?
18:41:53 <dv_> hello
18:41:59 <somnolence> ddarius: lolz
18:42:03 <ddarius> @help @check
18:42:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:42:06 <ddarius> @help check
18:42:07 <lambdabot> check <expr>
18:42:07 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
18:42:10 <dv_> IIRC, it is possible to embed haskell inside C via hs-plugs
18:42:15 <dobblego> islon_s, it invokes QuickCheck for testing properties
18:42:22 <dobblego> @check \a b -> a + b == b + a
18:42:23 <lambdabot>   "OK, passed 500 tests."
18:42:29 <dobblego> @check \a b -> a - b == b - a
18:42:30 <lambdabot>   "Falsifiable, after 0 tests:\n0\n-2\n"
18:42:32 <dolio> > let postfix0 f s k = k (f s) ; postfix1 f s x k = k (f x s) ; apply = postfix0 (\(f,(a,s)) -> (f a,s)) ; push = postfix1 (\x s -> (x,s)) ; start k = k () ; end s = s in start push 1 push 2 push 3 push (+) apply push (+) apply end
18:42:33 <lambdabot>       Overlapping instances for Show ((a -> a) -> a -> a)
18:42:33 <lambdabot>        arising from...
18:42:40 <dv_> is there something similar for c++? of course I can use the c interface, but I wonder if there is some additional stuff for c++
18:42:43 <dolio> Oops.
18:42:53 <dolio> > let postfix0 f s k = k (f s) ; postfix1 f s x k = k (f x s) ; apply = postfix0 (\(f,(a,s)) -> (f a,s)) ; push = postfix1 (\x s -> (x,s)) ; start k = k () ; end s = s in start push 1 push 2 push 3 push (+) apply apply push (+) apply apply end
18:42:54 <lambdabot>   (6,())
18:43:00 <islon_s> nice, is there a way to use the bot without print the result to the whole channel?
18:43:27 <necroforest> message it
18:43:32 <ddarius> islon_s: Private message her.  /msg lambdabot @run 1+1
18:44:28 <islon_s> thanks
18:45:26 <pumpkin> is @run the same as > ?
18:45:45 <ddarius> @help run
18:45:45 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
18:45:52 <pumpkin> lol, I guess so
18:46:00 <necroforest> > putStrLn "liar"
18:46:02 <lambdabot>   * Exception: "<IO ()>"
18:46:06 <necroforest> woot?
18:46:14 <pumpkin> [21:45:45] <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
18:46:18 <pumpkin> note the last bit
18:47:23 <inforichland> haskell does have the propensity to make you go nuts
18:47:35 <pumpkin> yeah, especially when it's buggy :(
18:47:38 * pumpkin sulks some more
18:47:58 <inforichland> =-O how dare you claim the Glorious Haskell is buggy !
18:48:02 * inforichland shames pumpkin
18:48:05 <pumpkin> lol
18:48:31 <pumpkin> everything has bugs, but they're more disturbing when you aren't used to segfaults
18:48:47 <inforichland> oh
18:48:50 <inforichland> yeah
18:48:51 <inforichland> :(
18:48:54 <inforichland> segfaults
18:49:21 <gweiqi> haskell has segfaults?
18:49:22 <gweiqi> nice
18:49:27 <pumpkin> yup
18:49:29 <pumpkin> it's awesome
18:49:32 <pumpkin> makes me feel at home
18:49:33 <gweiqi> how do you get them?
18:49:37 <inforichland> hA!
18:49:42 <byorgey> gweiqi: haskell, being a specification, has nothing of the sort.
18:49:50 <gweiqi> byorgey: fine, ghc
18:49:51 <byorgey> now, GHC on the other hand... =)
18:49:52 <yip> byorgey: FFI is part of the haskell spec
18:50:11 <yip> and segfaults are part of the c spec =]
18:50:12 <islon_s> FFI -> Final Fantasy Interface
18:50:19 <inforichland> ^_^
18:50:20 <byorgey> hehe, yip raises a good point.
18:50:25 <pumpkin> gweiqi: try doing enormous amounts of calculations on UArrs and if you're super lucky, it'll crash on you or give you uninitialized memory
18:50:27 <jeffz`> yip: I don't think segfaults are part of the c spec
18:50:42 <gweiqi> pumpkin: so unboxed arrays are broken in some way?
18:50:59 <gweiqi> pumpkin: or are you doing questionable things somehow?
18:51:07 <Gracenotes> a UArr?
18:51:09 <pumpkin> gweiqi: in some way, yes :) when I'm under less deadline pressure I intend to track this shit down, but in the mean time I'm just frustrated
18:51:11 <ddarius> byorgey: We should change the FFI to be a Haskell to Haskell FFI.
18:51:11 <pumpkin> gweiqi: nothing questionable, pure code
18:51:12 <Gracenotes> hm, really :|
18:51:17 <dolio> pumpkin: Compile with bounds checking turned on.
18:51:21 <pumpkin> gweiqi: not a UArray though, just UArr
18:51:23 <byorgey> ddarius: hehe
18:51:23 <defun> What does this mean? (Stack space overflow: current size 8388608 bytes. Use `+RTS -Ksize' to increase it.)
18:51:31 <byorgey> ddarius: isn't that called 'import' ?
18:51:33 * yip refers to the c spec article (13.6) segfaults put hair on your chest
18:51:35 <pumpkin> dolio: I've tried running with +RTS -DS, does that do the same thing?
18:51:57 <dolio> I'm not sure what that does.
18:51:57 <pumpkin> dolio: -DS just made my program a bajillion times slower, and then it crashed anyway, if that means anything
18:51:57 <gweiqi> pumpkin: is UArr the data parallel version?
18:52:13 <pumpkin> dolio: it's in the -debug runtime, and apparently turns on all sanity checks
18:52:18 <pumpkin> gweiqi: it's the fused one
18:52:18 <dolio> uvector has a flag to build with range checking, though.
18:52:25 <byorgey> defun: it means your program caused a stack overflow.  it is often caused by something being too lazy, and building up a giant thunk, which, when finally evaluated, blows the stack.
18:52:26 <sjanssen> hmm, I wonder if segfault capability in the FFI addendum is a feature?  Feature parity with C, as it were
18:52:35 <byorgey> defun: (although there are other possible causes as well.)
18:52:44 <pumpkin> dolio: that would be very helpful, where can I find info on it? I didn't think there were any options on it
18:52:48 <byorgey> defun: if you hpaste your code I could take a look at it.
18:52:52 <inforichland> from #concatenative:
18:52:52 <inforichland> 20:50:59 <schme> See I can't stand #haskell. Every time one asks a question in there one gets 15 really good high quality answers.
18:52:52 <inforichland> 20:51:04 <schme> and not a single RTFM, dolt.
18:52:52 <inforichland> 20:51:20 <inforichland> yeah, what a shame
18:52:52 <inforichland> 20:51:22 <schme> And everyone is just nice and friendly.
18:52:53 <inforichland> 20:51:24 <schme> It's wrong, man!
18:52:55 <inforichland> 20:51:26 <inforichland> i know !
18:52:57 <inforichland> 20:51:30 <inforichland> it's just not irc
18:53:00 <sjanssen> @type Foreign.Storable.peek Foreign.Ptr.nullPtr
18:53:01 <defun> Yay! my first stack overflow. I'll paste it...
18:53:02 <lambdabot> forall a. (Foreign.Storable.Storable a) => IO a
18:53:07 <inforichland> excellent praise from other communities :)
18:53:15 <gweiqi> pumpkin: ahh, that's awkward... "look at all these correct transformations we can do to eliminate intermediate data construction" segfault
18:53:28 <byorgey> defun: congrats!
18:53:33 <gwern> so that's why they called it house.
18:53:34 <pumpkin> gweiqi: granted, it's marked as experimental
18:53:38 <dolio> pumpkin: The flag is named "safe".
18:53:46 <gwern> 'You are more secure in a House... than if you only have Windows.'
18:53:46 * byorgey hands defun a Golden Stack Overflow trophy
18:53:47 * sjanssen makes a mental note to always respond "RTFM" to schme's questions
18:53:48 <gweiqi> pumpkin: ah ok
18:53:49 * gwern groans
18:54:16 <defun> hpaste is unavailable...
18:54:19 <pumpkin> dolio: how do I pass cabal-install flags like safe?
18:54:25 <pumpkin> I've never come across flags like that before
18:54:27 <inforichland> defun: hpaste has been
18:54:28 <pumpkin> but I see it in the .cabal file
18:54:30 <byorgey> @where hpaste2
18:54:30 <lambdabot> http://moonpatio.com:8080/
18:54:31 <inforichland> pastebin is up
18:54:39 <byorgey> defun: try that ^^^
18:54:41 <inforichland> oh
18:54:43 <defun> 1 sex
18:54:46 <defun> oops
18:54:49 <dolio> Not sure. It might be as easy as "cabal install uvector --safe".
18:54:50 <defun> one sec
18:55:00 <pumpkin> dolio: I'll try that, thanks
18:55:06 <dolio> Nope, that's not it...
18:55:06 <inforichland> defun: rofl
18:55:12 <byorgey> so what's the deal with hpaste vs. hpaste2 ?
18:55:59 <defun> http://pastebin.com/m3a260148
18:56:00 <sjanssen> byorgey: hpaste uses happs, hpaste2 is a rewrite that uses CGI
18:56:01 <Cale> hpaste2 is better, but it doesn't have the same domain
18:56:03 <dolio> pumpkin: maybe 'cabal install --configure-option=safe uvector'
18:56:51 <byorgey> sjanssen: right, but I mean, why are they both still around?  just inertia?
18:56:55 <sereven> the hpaste2 urls are nasty, too. needs a tinyurl button or something.
18:57:00 <byorgey> if hpaste2 is better then we should encourage its use.
18:57:57 <lpjhjdh> where is hpaste2?
18:58:12 <dino-> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/
18:58:16 <dino-> lpjhjdh: ^^
18:58:19 <lpjhjdh> thanks
18:58:26 <byorgey> defun: that's the code that causes a stack overflow?
18:58:34 <defun> yes
18:59:08 <monochrom> should I use hpaste or should I use hpaste2?
18:59:13 <monochrom> should I be pure or impure?
18:59:16 <byorgey> ah, ok, I get a stack overflow too.
18:59:32 <byorgey> defun: oh, wait, I see.  you need a base case for your fac function.
18:59:41 <defun> ?
18:59:49 <byorgey> defun: right now it just goes off constructing an infinite thunk of multiplications
18:59:58 <monochrom> yeah, fac 0 = ? :)
19:00:00 <defun> until 0?
19:00:07 <CakeProphet> > let foo_bar = 2 in foo_bar
19:00:08 <lambdabot>   2
19:00:10 <chessguy_work> @where moonpaste
19:00:11 <lambdabot> http://moonpatio.com:8080/
19:00:11 <CakeProphet> ...bah
19:00:14 <chessguy_work> monochrom, ^^
19:00:14 <defun> oh, so it goes into negative numbers
19:00:18 <CakeProphet> I was hoping _ wouldn't work in identifiers.
19:00:18 <byorgey> fac 100 = 100 * 99 * 99 * 98 * 98 * 97 * 97 * ... it will never stop.
19:00:21 <byorgey> defun: right.
19:00:24 <defun> thanks.
19:00:27 <monochrom> I don't mind nasty urls.
19:00:30 * CakeProphet hates underscored variable names. Is glad he rarely sees them in haskell.
19:00:48 <chessguy_work> CakeProphet, you mean like var_name or _varName or both?
19:01:04 <CakeProphet> var_name is more annoying, but sometimes _varName can be an eyesore.
19:01:33 <pumpkin> dolio: same ol' segfault
19:01:35 <pumpkin> :(
19:01:43 <dolio> pumpkin: Oh, I think it's --flags (recompiling now).
19:01:47 <pumpkin> oh
19:01:55 <pumpkin> so --flags=safe
19:02:32 <pumpkin> will that enable nice ASSERT(i < length) c-style macros throughout the code? :D
19:04:14 <dolio> newU 3 (\a -> readMU a 5 >> writeMU a 5 5) ==> toU *** Exception: Arr.BUArr.readMBU[Double]: Out of bounds (size = 3; index = 5)
19:04:37 <pumpkin> beautiful, /me crosses his fingers that he'll find something similar
19:04:58 <pumpkin> yay, minimal: lengthU: lengths of zipped arrays differ (first = 13705; second = 13690)
19:05:01 <pumpkin> looks like a start
19:05:12 <pumpkin> thanks :)
19:05:21 <dolio> No problem.
19:05:40 <dolio> I actually didn't know about that until after I figured out all my segfaults in uvector-algorithms by hand.
19:06:05 <pumpkin> aw :)
19:06:09 <pumpkin> yeah, I've been getting plenty of them
19:06:24 <pumpkin> and I assumed it just behaved like list for differently-sized zips
19:06:30 <pumpkin> I should pay more attention
19:07:01 <dolio> zipU is something like "zipU a b = PairArr a b"
19:08:03 <dolio> Because an array of pairs is just a pair of arrays.
19:08:13 <pumpkin> yeah
19:08:36 <CakeProphet> so then is a pair of an array of pairs just an array of pairs of pairs?
19:08:39 <pumpkin> I really do look forward to delving into that code and making the library faster
19:08:41 <pumpkin> and better
19:08:46 <pumpkin> and most of all, better documented :P
19:09:00 <pumpkin> CakeProphet: this is only with UArrs btw
19:09:39 <pumpkin> but I doubt it :)
19:09:40 <dolio> I doubt you'll succeed in making it much faster.
19:09:44 <pumpkin> and they're special unboxed pairs
19:09:56 <pumpkin> dolio: I mostly mean faster for operations it doesn't support natively
19:10:19 <dolio> MUArr is already as fast as MutableByteArr#.
19:10:20 <pumpkin> like providing other (finite) list functions that aren't offered in the current implementation
19:10:30 <dolio> For instance.
19:10:36 <pumpkin> yeah
19:12:52 <pumpkin> it's an awesome lib, but if nothing else, I'm going to improve the documentation :)
19:13:37 <thoughtpolice> ? uvector?
19:14:31 <pumpkin> yup
19:20:04 <islon_s> "class Monad m => MonadState s m | m -> s where" what the | means in this class declaration?
19:20:18 <dobblego> islon_s, functional dependency (it is addressed in that chapter)
19:22:47 <Gracenotes> I've heard of s-expressions a fair amount; what are they in Haskell? one-liners, basically?
19:23:32 <Adamant> Liskell
19:24:19 <Gracenotes> so plain Haskell does not 'have' them?
19:25:06 <Plouj> hi
19:25:26 <Plouj> I can do linesFromPoints [(a1,a2), (b1,b2), (c1,c2)] = [(b1-a1, b2-a2), (c1-b1, c2-b2)], but howcome I can't define a function which returns two tuples without using a list?
19:25:47 <mjrosenb> Plouj: what do you mean by two tuples?
19:25:54 <mjrosenb> Plouj: you can return a tuple of tuples
19:26:09 <CakeProphet> Gracenotes, I don't really think s-expressions have any definition other than (f x y ...) where f is a function and everything else in the list is an s-expression or a literal.
19:26:14 <CakeProphet> or variable, I guess.
19:26:36 <Gracenotes> ah.
19:26:39 <Plouj> mjrosenb: I mean linesFromPoints (a1,a2) (b1,b2) (c1,c2) = (b1-a1, b2-a2) (c1-b1, c2-b2)
19:27:05 <mjrosenb> Plouj: and how would you want to use this function?
19:27:38 <Plouj> mjrosenb: I want to pass its output to another function which takes two tuples!
19:28:29 <CakeProphet> Gracenotes:  the main syntatic difference between Lisp and Haskell is that the parentheses are mandatory for anything that isn't a variable or a literal. (the semantics, of course, are entirely different. Lisp has strong, dynamic typing and side-effects.
19:28:29 <mjrosenb> Plouj: right, but functions can only take one argument
19:28:57 <islon_s> how i read this type? "next :: Supply s (Maybe s)"
19:29:04 <Gracenotes> @type uncurry
19:29:06 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
19:29:09 <Plouj> mjrosenb: huh?
19:29:15 <Plouj> mjrosenb: that's not true
19:29:22 <mjrosenb> Plouj: guarantee it is
19:29:22 <pumpkin> Plouj: it is
19:29:28 <Gracenotes> CakeProphet: ah. Do you know some Lisp dialect, by chance?
19:29:37 <pumpkin> Plouj: each function returns a function with one less arity
19:29:40 <pumpkin> "arity"
19:29:52 <CakeProphet> Gracenotes:  not one in particular. I've n ever actually programmed in any of them, but I have seen a fair amount of Scheme from textbooks.
19:29:53 <Plouj> I can define a function which takes two arguments
19:30:01 <mjrosenb> Plouj: foo bar baz = quue is syntatic sugar for foo = \bar -> (\baz -> quux)
19:30:07 <Gracenotes> ah.
19:30:09 <pumpkin> Plouj: its type will be a -> b -> c, which means a -> (b -> c)
19:30:26 <Plouj> yeah...
19:30:43 <pumpkin> that is, it takes one parameter a, and returns a function of type b -> c
19:30:45 <mjrosenb> Plouj: and in the de-sugared form, it's obvious that all functions take one argument
19:30:51 <Gracenotes> Plouj: there's uncurry for feeding two-element tuples to functions
19:31:19 <Gracenotes> > uncurry (\x y -> x+y) (2,3)
19:31:20 <lambdabot>   5
19:31:28 <Gracenotes> (or just (+))
19:31:36 <mjrosenb> Plouj: so you can either use uncurry, or you can do a cps-style hack
19:32:19 <CakeProphet> > (+) 5 5
19:32:21 <lambdabot>   10
19:32:24 <CakeProphet> wooo prefix form
19:32:40 <mjrosenb> so if you have *want* to have linesFromPoints a b c = d e; stuffWithLines (linesFromPoints x y z)
19:32:45 <mjrosenb> you could instead say
19:33:34 <mjrosenb> linesFromPoints f a b c = f d e; linesFromPoints stuffWithLines x y z
19:33:45 <CakeProphet> > map (subtract 5) [1,2,3,4,5,6]
19:33:46 <lambdabot>   [-4,-3,-2,-1,0,1]
19:34:06 <Gracenotes> mjrosenb: isn't the f the last argument to the function..? I forget
19:34:10 <mjrosenb> CakeProphet: "wooo prefix"? are you a scheme hacker
19:34:21 <CakeProphet> hardly ever touched Scheme, actually.
19:34:25 <mjrosenb> Gracenotes: it doesn't really matter
19:34:31 <Nafai> I've got an idea for what might be a straight-forward project, but I need some library support
19:34:55 <Gracenotes> mjrosenb: just so that you could partially apply the first three arguments, and actually 'run' the continuation later
19:35:13 <CakeProphet> I'm a Pythoneer-to-Haskeller convert, though I dabble in many black arts.
19:35:14 <pumpkin> Nafai: put it on haskell proposals reddit! :P
19:35:20 <Gracenotes> or something like that. I'm not really familiar with CPS, having not used languages that feature it
19:35:28 <Nafai> I want to write something that keeps pulling the rss feed of a given tag on delicious and removes the entries for URLs I've already seen in the feed
19:35:33 <Nafai> pumpkin: But I want to write it.
19:35:48 <CakeProphet> Gracenotes:  from what I can gather, CPS is very very similar to >>=.
19:36:09 <Nafai> So I need: 1) something to parse RSS, 2) something to generate it OR 3) a decent XML parser, some kind of DB, and some kind of simple HTTP server
19:36:11 <Gracenotes> esp. for the (->) t monad, iirc...
19:36:24 <CakeProphet> Gracenotes:  I forgot what the function monad does.
19:36:29 <Nafai> Though, actually, I can just write it to disk
19:36:37 <chipdude> an operator named (->)?  can't imagine that causing any confusion
19:36:38 <mjrosenb> Gracenotes: cps isn't a "language feature".  it's a style of writing code, and can be done in any language where functions are first class
19:36:50 <CakeProphet> chipdude:  not an operator. a type.
19:37:08 <chessguy_work> Nafai,  IIRC, there's a hackage specifically for delicious
19:37:14 <Gracenotes> I mean, as opposed to languages like Lisp, which apparently have built-in callcc, etc.
19:37:17 <mjrosenb> chipdude: i don't think it's even possible to have an operator called ->
19:37:21 <chipdude> CakeProphet: oh.  entirely beyond my current knowledge, then.  :-,
19:37:22 <Nafai> chessguy_work: /me looks
19:37:41 <CakeProphet> > let (->) = (+) in 2 -> 3
19:37:43 <lambdabot>   <no location info>: parse error on input `->'
19:37:45 <CakeProphet> noep
19:37:58 <chipdude> ghci agrees
19:37:59 <dolio> (Common) Lisp doesn't have callcc, actually (I think that's right). Scheme does.
19:38:12 <chipdude> IIRC CL doesn't have continuations
19:38:15 <CakeProphet> it would be a nice operator, had it not already had prior engagements with a certain type constructor for functions.
19:38:24 <mjrosenb> Gracenotes: call/cc and cps are entirely unrelated.  they can do similar things, but are unrelated
19:38:25 <Gracenotes> ah, I see.
19:38:28 <Nafai> chessguy_work: That's nice, but I still want RSS so I can subscribe with my feed reader
19:38:31 <chipdude> CakeProphet: well, there's always =>.    D'oh!
19:38:41 <chessguy_work> Nafai, cool. just figured i'd make you aware
19:39:10 <CakeProphet> chipdude:  I can just define a binary  ==> operator on numbers... I'm sure you can imagine the fun that could be had with that.
19:39:11 <monochrom> "first-class continuation" is a language feature. It is not needed for CPS. It speeds things up.
19:39:19 <Nafai> chessguy_work: Thanks though
19:39:31 <mjrosenb> CakeProphet: isn't it not defined as a type constructor in the haskell spec?
19:39:36 <Gracenotes> in that case, I could probably implement CPS in, say, JavaScript?
19:39:52 <CakeProphet> mjrosenb:  ->?
19:39:57 <mjrosenb> monochrom: most of the time, it wouldn't speed up cps
19:39:59 <mjrosenb> CakeProphet: yeah
19:40:16 <Gracenotes> :k (->)
19:40:17 <lambdabot> ?? -> ? -> *
19:40:22 <pumpkin> dolio: so without that safe flag, for bad zips, it happily reads off the end of the UArr into potentially uninitializd memory, I assume?
19:40:34 <mjrosenb> CakeProphet: isn't it only available with -XOhGodMakeEverythingAConstructor?
19:40:38 <CakeProphet> mjrosenb:  I actually don't read the Haskell 98 Report often... but I think it's considered a type constructor since it has instances as typeclasses and such
19:40:44 <mjrosenb> Gracenotes: lambdabot is made of magic
19:40:45 <dolio> pumpkin: It must, if you're getting segfaults.
19:41:07 <chipdude> CakeProphet: newb factor perhaps, but I can't find any existing meaning for ==> .   Are you alluding to visual confusion only?  If so, <agreement>
19:41:16 <Gracenotes> mjrosenb: hehe. Actually, I think people use CPS in JavaScript a fair amount; they're called callbacks
19:41:29 <pumpkin> dolio: guess so :) anyway, your help has saved me hours of hair-pulling, thanks :)
19:41:33 <Gracenotes> now if only there were a nice way to chain them...
19:41:36 <CakeProphet> chipdude:  I'm actually alluding to body parts, but I thought it would be more tactful to be inplicit about it. :3
19:41:53 <CakeProphet> *implicit
19:42:00 <mjrosenb> Gracenotes: callbacks are slightly different
19:42:09 * chipdude chalks up one for CakeProphet 
19:42:30 <CakeProphet> Gracenotes:  callbacks are fun.
19:42:36 <Gracenotes> mjrosenb: hm... in what sense?
19:42:38 <intrados> everyone is voting for the gnarly narwhal, right?
19:43:05 <chipdude> well, there is always the Turing sense, but without continuations I'd think that CPS would be ... well, awkward enough that you'd need automated help to write the code
19:43:21 <chipdude> breaking up natural functions into little subfunctions
19:43:32 <Gracenotes> it still would be possible to implement CPS in JS, since it has first class functions, through, right?
19:43:35 <mjrosenb> Gracenotes: cps is generally used to make things tail-recursive that are not normally recursive, and are used to modify the control flow
19:43:37 <CakeProphet> chipdude:  you make it sound so adorable.
19:43:40 <mjrosenb> Gracenotes: yes
19:43:43 * CakeProphet wants a little pet subfunction.
19:44:06 <chipdude> I will hug it and pet it and name it `george`
19:44:12 <mjrosenb> chipdude: wait, what? that makes no sense whatsoever
19:44:14 <pumpkin> my dog's called george
19:44:29 <elly> I want a subfunction too
19:45:02 <Gracenotes> mjrosenb: er, so what would they look like in JavaScript, if you know JavaScript?
19:45:08 <CakeProphet> @src any
19:45:09 <lambdabot> any p =  or . map p
19:45:11 <chipdude> mjrosenb: no?  Then I have greatly misunderstood the situation.  But without first-class continuations the only entry point into a function is the top, so CPS would require each pseudo-continuation to be expressed as the entry to some function, which would tend to break up the functions
19:45:12 <Gracenotes> *ECMAScript, even
19:45:18 <CakeProphet> @src or
19:45:18 <lambdabot> or    =  foldr (||) False
19:45:23 <CakeProphet> thought so.
19:46:14 <CakeProphet> are there any functional programming languages out there with even crazier type magic possibilities than Haskell?
19:46:25 <mjrosenb> CakeProphet: yes
19:46:35 <mjrosenb> CakeProphet: curry and...
19:46:43 * Gracenotes googles CPS in JS...
19:46:46 <mjrosenb> CakeProphet: blast
19:46:54 <thoughtpolice> agda; coq if you want to count it.
19:46:58 <mjrosenb> CakeProphet: i can't remember the really interesting one
19:47:03 <thoughtpolice> ATS too
19:47:11 <thoughtpolice> http://www.ats-lang.org
19:47:14 <lpjhjdh> cayenne
19:47:25 <thoughtpolice> not much documentation but it's really fast and interfaces to C really well
19:47:26 <lpjhjdh> epigram
19:48:01 <mjrosenb> agda
19:48:06 <mjrosenb> that's the other one
19:48:08 <thoughtpolice> the author also wrote dependent ml but it's now defunct (and it only allowed integers in types, didn't have full-blown dependent types.)
19:48:08 <mjrosenb> agda2
19:48:24 <Nafai> Other than a db like sqlite, is there a serialization library for haskell that is useful?
19:48:32 <Gracenotes> JS CPS would apparently be like squareCC(num, f) { return f(num*num) }
19:48:35 <thoughtpolice> i personally think ATS is really really cool, it just needs more time to be polished up.
19:48:44 <thoughtpolice> Nafai: data.binary
19:48:58 <pumpkin> what's special about ATS? I see it a lot on the top of the shootout, but don't know much about what sets it apart
19:49:03 <pumpkin> linear typing or something?
19:49:13 <mjrosenb> chipdude: how is having "\ foo ->" littered throughout your code any easier than "letcc foo in" ...?
19:49:16 <pumpkin> I glanced at the site but didn't really get it
19:49:17 <dolio> It has linear types and dependent types.
19:49:21 <dolio> And it's quite fast.
19:49:32 <dolio> And inline C, if you're into that.
19:49:39 <dolio> That gets used a lot in the shootout.
19:49:40 <mjrosenb> chipdude: with the additional benefit of being able to use regular function application rather than needing to call callcc
19:49:46 <thoughtpolice> it has full blown linear and dependent types
19:50:28 <thoughtpolice> linear types can be used to make really efficient code, the dependent type side has it's own full blown total programming language for writing proofs i think
19:50:31 <Nafai> thoughtpolice: Awesome, thanks.  That should do exactly what I want
19:50:33 <thoughtpolice> it has super-easy interfacing to C
19:50:37 <thoughtpolice> it's really fast
19:50:37 <monochrom> Some Scheme implementations have type magic. Here is what I mean. I let x=2 ask "what is the type of x" and it is integer. Then I let y=sqrt x and ask "what is the type of y" and it is some floating point or real number thingie. Then finally I ask "what is the type of y^2" and it is integer!
19:50:40 <pumpkin> what exactly are linear types?
19:51:22 <rwbarton> monochrom: O_o
19:51:29 <rwbarton> monochrom: did you ask it "are you sure?" :)
19:51:34 * Nafai <3 cabal install
19:51:56 <monochrom> After all these years of wrongly asking "what exactly are monads" "what exactly are arrows" "what exactly is haskell" you still don't know better than asking "what exactly are linear types"? :)
19:51:57 <thoughtpolice> pumpkin: might want to see here for its reference - http://www.ats-lang.org/TUTORIAL/contents/dataviewtypes.html
19:51:59 <thoughtpolice> kind of shody
19:52:00 <Axioplase> pumpkin: types of objects used one time only (basically)
19:52:11 <pumpkin> so it's like the uniqueness typing of clean?
19:52:19 <thoughtpolice> you might also like wadler's "linear typing can change the world"
19:52:24 <Axioplase> pumpkin: it's the type theory following Linear Logic
19:52:31 <monochrom> linear types can change the world
19:52:46 <dolio> Linear is one time exactly.
19:52:51 <dolio> You can't throw them away, either.
19:53:01 <dolio> Unlike uniqueness types, I believe.
19:53:03 * pumpkin checks out the paper
19:53:32 <Axioplase> then there are variations, where you can use a rational number of times, or at least n times…
19:53:46 <edwardk> @seen psykotic
19:53:46 <lambdabot> I haven't seen psykotic.
19:53:47 <pumpkin> how do you have a rational number of times? :o
19:53:54 <thoughtpolice> pumpkin: there're also some papers on linear lisps and stuff
19:54:10 <monochrom> can you use -3 times?
19:54:10 <thoughtpolice> http://home.pipeline.com/~hbaker1/LinearLisp.html
19:54:13 <dolio> There are several different directions you can go, depending on which of contraction and weakening you include/exclude.
19:54:14 <thoughtpolice> http://home.pipeline.com/~hbaker1/Use1Var.html
19:54:27 <Axioplase> pumpkin: if foo then x else 42    <= x is used 1/2 times in the program
19:54:34 <dolio> And something else which I forget exactly. edwardk can explain them better.
19:55:07 <edwardk> dolio: substructural logic?
19:55:11 <dolio> Yes.
19:55:13 <Axioplase> monochrom: not that I know. But that could make sense for some contexts.
19:55:53 <edwardk> who is looking for info?
19:55:55 <dolio> The other axis is 'has been used' vs. 'will be used' no?
19:56:34 <dolio> pumpkin, I guess.
19:56:34 <Gracenotes> > let leng xs f = f (length xs); add a b f = f (a+b) in leng "no" add 4 id
19:56:36 <lambdabot>   6
19:56:39 <edwardk> dolio: yeah i've been known to break linearity and uniqueness apart by using backwards and forward facing temporal modalities like that, but its hard to find references. you have to back into the idea
19:56:47 <pumpkin> hmm
19:57:05 <mriou> hi, is anyone aware of an STMap just like there's STArray?
19:57:07 <CakeProphet> thoughtpolice:  hmmm... it's cool that new "sorts" can be defined by adding constraints to existing sorts.
19:57:23 <mriou> not that it would be super hard to come up with but in case it exists already...
19:57:42 <ddarius> edwardk: I'm looking for info on substructural logic on your blog...
19:58:33 <edwardk> ddarius: i think the only thing was that one post about how you can use it with cardelli's object calculus to remove an index or maybe that was continuation only semantics
19:58:49 <edwardk> i drifted off into category theory land shortly after i put up the subscript
19:58:59 <dolio> edwardk: Does uniqueness disallow weakening?
19:59:14 <edwardk> dolio: no, you can weaken, just not contract.
19:59:20 <dolio> Okay.
19:59:24 <edwardk> dolio: uniqueness can still be lazy
19:59:48 <chipdude> mjrosenb: we crossed the streams.  I was still talking about cps in JS or some equally deficient language
19:59:53 <ddarius> "affine" is usually used for weakening but no contraction
20:00:01 <edwardk> now, you can have 'relevant uniqueness' which does disallow weakening
20:00:13 <Axioplase> ddarius: http://www.kb.ecei.tohoku.ac.jp/%7Ekoba/slides/FLOPS2008.pdf  <- substructural. (slides. nice and clear. By Naoki Kobayashi)
20:00:19 <chipdude> mjrosenb: I'm prepared to believe that in Haskell it's a mere change in convention, as you suggest
20:01:03 <ddarius> Axioplase: That's not edwardk's blog.
20:01:04 <edwardk> ddarius: slight simplification. uniqueness is a backwards facing modality that indicates you haven't contracted yet, but may still. affinity is a contract that you will never contract.
20:01:30 <edwardk> er heh maybe i shouldn't have called it a contract ;)
20:01:57 <ddarius> edwardk: So when will you have a blog post titled "A Judgemental Reconstruction of Uniqueness Typing" ?
20:02:33 <chipdude> is it a good thing or a bad thing when programming language commentary is indistinguishable from literary criticism?
20:02:44 <edwardk> uniqueness and linearity are comparable in that uniqueness is the contract that you haven't contracted (or weakened, which is kinda pointless for the intuitionistic fragment) yet, while linearity is a contract that you can't contract or weaken in the future.
20:02:45 <Axioplase> ddarius: it's not. but you seemed to be looking for something to read about this kind of stuff
20:02:50 * chipdude judgmentally reconstructs his unique typing
20:03:53 <ddarius> Axioplase: I was quite explicitly looking for substructural stuff on edwardk's blog.
20:04:06 <Gracenotes> the field here is type theory, right?
20:04:26 <edwardk> ddarius: i usually use a 6 point lattice. uniqueness, relevant uniqueness, unrestricted, relevant, affine, and linear. if you look at say the step indexed model of substructural state they explore all but the uniqueness based members of that model.
20:05:05 <ddarius> Yeah, usually linearity, affine, relevant and unrestricted are the explored ones.
20:05:25 <ddarius> It's unheard of (as far as I can tell) to look at say ordered relevant or some such.
20:05:47 <Axioplase> ddarius: my bad then
20:06:06 <edwardk> you can break that into a 2x3 lattice. the 2 side indicates safety to evaluate strictly (relevance) in a functional setting, the 3 side offers other guarantees for evaluation.
20:06:34 <SamB> chipdude: give examples!
20:06:58 <ddarius> One thing I'd like to explore whenever I get my linear logic language off the ground is having arbitrarily many, user-definable contexts.
20:07:06 <edwardk> ddarius: i worked up some semantics from the perspective of 'ordered' because you can abuse the notion of ordered to retain the use of a stack for processing a lot of this stuff. an ordered linear continuation becomes a stack frame
20:07:15 <ddarius> I suspect that that may be equivalent to adding a modality (or rather several of them)
20:07:36 <SamB> I hate modality
20:07:37 <edwardk> ordered affinity lets you jump over stack frames setjmp/longjmp style, etc.
20:07:51 <SamB> I always want to click on something in a box that isn't in front!
20:07:53 <ddarius> Yeah, the ordered context is basically a double ended queue (hence me being interested in having multiple contexts)
20:07:54 <edwardk> they all basically map onto an operational interpretation
20:08:13 <pumpkin> dons is quite the beer connoisseur
20:08:30 <ddarius> edwardk: Yeah, I tend to view linear and ordered in a very "data-structure" oriented perspective.
20:08:40 <edwardk> gracenotes: the field on this channel in general or that we are discussing right now?
20:08:53 <Gracenotes> the one which you are currently discussing.
20:09:11 <ddarius> Gracenotes: Type theory is one possibility.  (Formal) logic is probably most appropriate.
20:09:21 <SamB> this channel, in general, is about ... lets see, was it sex and violence?
20:09:21 <edwardk> gracenotes: its about equal parts type theory, substructural logic and modal logic.
20:09:29 <ddarius> I'm not sure these ideas are localized to a particular domain.
20:09:39 <Gracenotes> ah. thanks
20:09:42 <ddarius> SamB: And drugs.
20:10:01 <edwardk> gracenotes: the curry howard correspondence basically says you can borrow tools from logic for type systems and vice versa. ;)
20:10:02 <SamB> no, wait, that's #haskell-blah I'm thinking of though
20:10:18 <Gracenotes> yes. I didn't know you went that far with it, though :)
20:11:00 <thoughtpolice> @seen augustss
20:11:01 <lambdabot> augustss is in #haskell. I don't know when augustss last spoke.
20:11:04 <edwardk> gracenotes: if you work in a different logic, you get a new type system. modal logics typically remove some of the rules of logic and then add them back in the form of modalities so you can tell when they will be used. mapped to types these give you stronger guarantees about what you do with objects of those types
20:11:09 <thoughtpolice> augustss: ping?
20:12:29 <edwardk> you can then modify the hindley milner type system to propagate these modalities, which gives a less adhoc derivation for a lot of this stuff than say, using an attribute grammar
20:13:09 <dons> pumpkin: oregon does that to you.
20:13:23 <pumpkin> :)
20:13:29 <Gracenotes> hm
20:13:39 <SamB> what is an attribute grammar, anyway ? a cross between Prolog and a time machine ?
20:14:01 <ddarius> SamB: It's a combination of a state monad and a backward state monad.
20:14:02 <edwardk> http://en.wikipedia.org/wiki/Attribute_grammar
20:14:08 <edwardk> ddarius: well said
20:14:08 <pumpkin> dons: the safe flag on uvector has saved me from many (all?) of those bugs I was getting... mostly because I misunderstood the behavior of zipU
20:15:31 <edwardk> basically you can inherit attributes down the parse tree and synthesize them back up. nothing scary, very generic, useful as hell ;)
20:15:32 <pumpkin> what does ARR_WORDS mean on my heap profile graph?
20:15:42 <mjonsson> category theory newbie question: is id_A : A -> A unique or can there be multiple distinct identity morphisms?
20:15:43 <pumpkin> that's just hte memory allocated to my UArrs?
20:16:49 <rwbarton> mjonsson: There can be only one identity (easy exercise using the definition of identity)
20:16:55 <Nafai> Any examples of how to use Text.Feed out there?
20:16:55 <dons> pumpkin: ah ha!
20:17:03 <dons> pumpkin: unboxed array
20:17:12 <SamB> rwbarton: I can't remember any of those definitions :-(
20:17:15 <dons> yay for the safe flag. i should remember that :)
20:17:30 <SamB> what is this "safe flag"?
20:17:35 <rwbarton> SamB: just if f : A -> B, then id_B f = f = f id_A
20:17:38 <pumpkin> dons: yeah, it really helped me, instead of segfaults I started getting messages telling me "your zipped arrays are of different sizes fix it kthx"
20:17:45 <mjonsson> rwbarton: for example, f(x) : [0..1] -> [0..1] and g(x) : [0..1] -> [0..1] both look like id_A but you can imagine that they have different semantics
20:17:54 <pumpkin> SamB: on the uvector package
20:18:04 <Nafai> dons: Hi dons!
20:18:04 <pumpkin> SamB: enables some sanity checks within the UArrs
20:18:10 <edwardk> mjonsson: you are only required to have one such morphism, but if you had multiple such morphisms you couldn't tell them apart.
20:18:37 <rwbarton> mjonsson: I don't know what you mean by "semantics".  (Regular 1-)Category theory only talks about whether two morphisms are equal or different.
20:19:29 <mjonsson> rwbarton, more concretely, f(x) = x and g(x) = x^2, these are clearly different and it is easy to see that they are different
20:19:55 <mjonsson> but they have the same domain and codomain.
20:19:59 <rwbarton> mjonsson: if they're different, then one of them isn't the identity.  Probably g, I guess? :)
20:20:32 <rwbarton> mjonsson: I guess what I meant by that was I'm not sure exactly what category you're considering there
20:20:44 <edwardk> over the subset of integers {0,1} they are indistinguishable, is how i presume you mean?
20:20:48 <ddarius> mjonsson: Select what you think and prove (or disprove) it!
20:20:52 <mjonsson> edwardk, yes
20:22:04 <edwardk> then f . h = h = g . h. you can't tell them apart.
20:22:07 <mjonsson> rwbarton, I guess I am looking at the category of sets
20:22:18 <rwbarton> mjonsson: in that case, f and g are equal
20:23:15 <edwardk> if you look at them they have the same map from their domain to their codomain, in Set, they can't be distinguished.
20:23:29 <Cale> hm?
20:23:35 <rwbarton> mjonsson: You might be able to find some higher-categorical framework in which you can express your intuition that they are distinct, but the category of sets isn't it.
20:23:47 <mjonsson> aha
20:23:55 <ddarius> rwbarton: Start from the axioms of category theory.
20:23:56 <Cale> You mean f(x) = x and g(x) = x^2 as functions [0,1] -> [0,1] ?
20:24:03 <mjonsson> Cale, yes
20:24:04 <ddarius> The answer is a theorem of category theory.
20:24:07 <Cale> Those are distinguishable in Set.
20:24:09 <pumpkin> ooh patch-tag!
20:24:33 <Cale> f is the identity, and g sends 1/2 to 1/4, so it's not.
20:24:45 <rwbarton> Cale: mjonsson means {0,1} -> {0,1}
20:24:49 <Cale> ah
20:24:55 <edwardk> cale: the subset of _integers_ containing 0 and 1.
20:24:58 <mjonsson> what is {0,1}?
20:25:06 <Cale> The set consisting of just 0 and 1
20:25:11 <mjonsson> oh, duh :)
20:25:11 <edwardk> yeah
20:25:21 <Cale> [0,1] is the interval of real numbers x such that 0 <= x <= 1
20:25:23 <mjonsson> I indtended reals
20:25:27 <Cale> okay
20:25:35 <Cale> Then what I said is relevant.
20:25:36 <edwardk> mjonsson: then g isn't an identity ;)
20:26:14 <edwardk> mjonsson: so i have no idea how to parse about half of what you said earlier =)
20:26:15 <Cale> Consider the map q: {*} -> [0,1] from a one-pointed set {*}, such that q(*) = 1/2
20:26:21 <mjonsson> so the equality in the law h * id_A = id_A * h is at the level "below" the category view?
20:26:30 <Cale> Then f . q = q
20:26:34 <Cale> but g . q is not
20:26:35 <mjonsson> ie not comparison of domain/codomain
20:26:47 <rwbarton> mjonsson: anyways, when you define the category Set you have to say what the morphisms are from a set X to a set Y
20:27:02 <rwbarton> mjonsson: and in Set that set of morphisms is the set of all functions from X to Y
20:27:16 <Cale> Statements about where functions send elements can be treated as statements about composition of functions, by considering the maps from a one-element set.
20:27:17 <kmeyer|lappy> ls
20:27:17 <kmeyer|lappy> oops
20:27:20 <rwbarton> mjonsson: Two functions f and g are equal iff f(x) = g(x) for all x in X.  (That's what a function is.)
20:28:05 <rwbarton> mjonsson: So, if 1/2 is an element of [0..1], then f and g aren't equal because f(1/2) /= g(1/2)...
20:28:14 <mjonsson> I think my original question is answered, thanks
20:29:21 <Cale> In fact, you can *define* the elements of a set X to be the set of functions 1 -> X
20:29:26 <ddarius> mjonsson: Equality is part of the information you provide when defining a category.
20:29:36 <rwbarton> mjonsson: oh, I see, yeah.  Whether two morphisms are equal is information you have to put in when you're defining a category.
20:29:40 <Cale> (if you go about defining the functions in a clever way which avoids discussing elements)
20:30:25 <dolio> The answer is: id_A . f = f = f . id_A is required of identities, so if id_A and id'_A are both identities, then id_A = id_A . id'_A = id'_A.
20:30:25 <mjonsson> so a category should be a quadruple, not a triple then :)
20:30:33 <Cale> mjonsson: hm?
20:30:34 <pumpkin> are f(x) = x and g(x) = x + 1 distinguishable over the integers if you only consider their domains and ranges?
20:31:03 <dolio> So there is only one identity.
20:31:13 <dolio> (For each object.)
20:31:13 <mmorrow> new haskell-src-meta that works with new haskell-src-exts ++ some TH utils and other misc  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskell-src-meta-0.0.3.1
20:31:14 <lambdabot> mmorrow: You have 2 new messages. '/msg lambdabot @messages' to read them.
20:31:40 <mjonsson> Cale, as ddarius said equality is part of the information you provide when defining a category
20:31:52 <mmorrow> , randE()
20:31:55 <lunabot>  ()
20:31:57 <mmorrow> , randE()
20:31:59 <lunabot>  ["This is a string. " 3, "This is" 6]
20:32:00 <pejo> Cale, do you ever sleep?
20:32:09 <pumpkin> mmorrow: cheater!
20:32:13 <Cale> mjonsson: Oh, actually equality is usually treated as something at an even lower-level of description.
20:32:23 <rwbarton> mjonsson: It's implicit in the fact that you give a set of morphisms between each pair of objects.
20:32:30 <pumpkin> mmorrow: that's not a random expression, unless you happened to be very lucky and generate a random string that happened to be english
20:32:53 <mmorrow> pumpkin: i'm just lucky like that. you should see me play dice!
20:32:54 <pumpkin> OMG we have a haskell IDE now
20:32:54 <Cale> mjonsson: That is, it's not part of the information included with the category -- the equality symbol is actually usually included as a primitive relation symbol in the logic.
20:33:06 <pumpkin> mmorrow: you land on a corner every time?
20:33:12 <mmorrow> rwbarton: i added a `parseType'
20:33:19 <rwbarton> mmorrow: Sweet.
20:33:20 <mmorrow> pumpkin: among other things, yes.
20:33:25 <rwbarton> , parseType "a"
20:33:26 <lunabot>  luna: Not in scope: `parseType'
20:33:32 <mmorrow> oh, not to lunabot yet..
20:33:36 * rwbarton plans to use it in oldtype some day
20:33:50 <mjonsson> Cale, I see. thanks.
20:33:50 <pumpkin> ooh, I love augustss's timeit wrapper
20:33:53 <Cale> mjonsson: and its properties apart from substitution, and the fact that it's an equivalence relation, are defined axiomatically, usually via some bunch of set theory axioms
20:34:09 <edwardk> btw- does anyone actually use all the bifunctor combinators that are in category-extras?
20:34:10 <mmorrow> rwbarton: nice.
20:34:30 <edwardk> i originally concocted them so i could do a generic bifunctor derivative, but never got around to it
20:34:54 <rwbarton> mmorrow: it'll be good because I couldn't figure out a way to make [t| ... |] handle type variables
20:35:06 <Cale> For example, there's an axiom in ZFC which says that x = y if and only if (for all u, u is in x if and only if u is in y)
20:35:41 <Cale> (the relation 'is in' is also a basic relation symbol here)
20:36:02 <Cale> http://en.wikipedia.org/wiki/Axiom_of_extensionality
20:36:39 <Cale> So we usually tend to assume throughout mathematics that any two objects can be compared for equality, because they're all sets.
20:38:34 <Cale> If you feel like imposing an additional type theory on it, and require that only objects of the same type are compared, that's fine, but to some extent, set theory can act as its own type theory.
20:39:15 <ddarius> Cale: If you have a set theory with ur-elements, you (presumably) need an equality on them.
20:39:17 <Cale> (because you have an element of predicate which you can use to restrict conditions however you like)
20:39:28 <Cale> Yeah, but ur-elements are strange.
20:39:40 <mmorrow> rwbarton: yeah, being able to parse to TH open up so many more possibilities
20:39:51 <ddarius> For the way set theory is typically presented (when it is not the object of study itself), I tend to also take the view that the equality is information you provide as well.
20:39:57 <rwbarton> Morally speaking, sets can be characterized as those things whose elements can be compared for equality
20:40:30 <mmorrow> , 42 `reallyUnsafePtrEquality` 42
20:40:32 <lunabot>  False
20:40:39 <rwbarton> (As opposed to categories, say, where you wouldn't want to compare two objects for equality.)
20:40:50 <Cale> rwbarton: You wouldn't?
20:40:57 <Cale> (why not?)
20:41:06 <rwbarton> No, you want to see whether they're isomorphic
20:41:15 <rwbarton> Or you want to see whether two morphisms are equal
20:41:25 <Cale> mm... isomorphic isn't really the same as equal though...
20:41:34 <Cale> Sometimes you really do mean equal.
20:41:43 <rwbarton> It's not that you can't do so in the standard presentation of category theory, but just that it's "evil" to do so.
20:41:54 <intrados> would it be horrible of me to think that type classes are roughly equivalent to interfaces in java?
20:42:01 <Cale> Though I'll admit for the "big" applications of category theory, isomorphism is more important.
20:42:05 <rwbarton> Well, yes, you usually want to specify the isomorphism
20:42:09 <monochrom> Not horrible. Just misguided.
20:42:25 <Cale> I tend to think of a category as something of a cross between a preorder and a monoid.
20:42:30 <intrados> monochrom: how is it misguided?
20:42:32 <sjanssen> intrados: there are similarities
20:42:46 <monochrom> They are superficially similarly. You can pretend it at the beginning. Be prepared to demolish it later.
20:42:55 <intrados> okay
20:43:04 <ddarius> monochrom: If by "later" you mean "immediately", then I agree.
20:43:52 <monochrom> I move for "day 4 of learning haskell"
20:44:06 <Gracenotes> perhaps: if you drew a chart of how interfaces are applied, and a chart of how type classes are applied, the structure of the charts might look similar-ish from a very very long way off
20:44:12 <intrados> as I understand it, they both define some methods that constituents must implement
20:44:14 <Cale> Consider a topological space X, and form a category whose objects are the points of X, and where the arrows x -> y in the category are continuous maps f:[0,1] -> X such that f(0) = x, f(1) = y
20:44:32 <Cale> and the composition is basically the "concatenation" of those continuous maps
20:45:01 <rwbarton> intrados: One big difference is that in Java, the implementations of those interface methods are bundled into the objects, whereas in Haskell they're passed separately, or indeed possibly determined statically at compile time
20:45:13 <ddarius> monochrom: If you even start using type classes like interfaces, everything will break.
20:45:17 <Cale> This is a nice category, but you wouldn't usually want to identify isomorphic objects right away.
20:45:33 <Cale> (they're distinct points of your topological space, after all)
20:45:37 <monochrom> Parameteric polymorphism causes the biggest difference between typeclasses and interfaces.
20:45:52 <ddarius> monochrom: Dynamic dispatch does.
20:45:56 <ddarius> (in my opinion)
20:45:56 <mjonsson> Cale, in this topological category, what does category theory give us that monoids don't give us?
20:46:24 <Gracenotes> type-based dispatch...
20:46:33 <Cale> mjonsson: Well, what happens when your topological space has more than one path-connected component?
20:46:34 <mmorrow> a monoid can be though of as a category
20:46:37 <rwbarton> intrados: that means for example you can have a class 'Foo a' with methods with more than one argument of type a, or indeed even zero
20:46:45 <monochrom> OK, parametric polymorphism on one side and ad hoc polymorphism on the other side. takes two hands to clap.
20:46:48 <ddarius> Cale: I have an introduction I'm working on that starts like that.  My biggest problem finishing it is trying to come up with a good excuse to stop the regress to an omega category.
20:46:49 <mmorrow> while not necessarily vice-versa
20:46:50 <Cale> mjonsson: There might not be a path from x to y for any given x and y.
20:47:18 <Cale> mjonsson: A category with just one object is a monoid.
20:47:41 <ddarius> Cale: In fact there won't be if x /= y.
20:47:51 <Cale> ddarius: hm?
20:48:10 <Cale> ddarius: Did I mess up part of my definition?
20:48:22 <ddarius> Er sorry, I have something I meant to say, but that was not it.
20:48:48 <Cale> ddarius: There will be an arrow from x to y if x and y are points connected by a path.
20:49:04 <ddarius> Cale: I understand, I just said something totally different from what I intended.
20:49:08 <Cale> ah
20:49:31 <Cale> oh, right, as it stands, all my objects are not isomorphic yet
20:50:02 <rwbarton> You probably want homotopy classes of maps
20:50:04 <rwbarton> *paths
20:50:05 <ddarius> Anyway, the upshot of my statement was to be that a monoid would be -very- trivial.
20:50:24 <Cale> yeah, that's the next step
20:50:41 <rwbarton> (Technically you don't even have a category the way you described it)
20:50:42 <ddarius> rwbarton: This leads to that, except when to quotient is rather arbitrary.
20:51:37 <Cale> We mod out by an equivalence of paths, saying that two paths f,g: x -> y are equivalent if there is a continuous map F:[0,1]x[0,1] -> X such that F(0,t) = f(t), F(1,t) = g(t), F(u,0) = x, F(u,1) = y, for all t and u
20:51:40 <ddarius> rwbarton: You do have to quotient the class of "paths".  I simply defined the path as the -image- of such a continuous function.
20:51:55 <Cale> (that is, that one path can be continuously deformed into the other)
20:52:27 <Cale> and this will make all the points in the same path-connected component of the space isomorphic
20:53:01 <mjonsson> Cale, it makes sense to me now that a monoid is a category with one object, thanks
20:53:36 <Cale> (because you can take any path and flip it around to get an inverse -- it's easy to see that this composite is isomorphic to the constant path, basically by "pulling the string in")
20:55:19 <Cale> mjonsson: do you know what a preorder is?
20:55:38 <mjonsson> mjonsson, like <= or    subset= ?
20:55:46 <Cale> Those are examples
20:56:20 <Cale> A preorder on a set S is a relation <= such that a <= a for any a in S, and if a <= b and b <= c, then a <= c for any a,b,c in S.
20:56:52 <Cale> Note that it's still possible for a <= b and b <= a at the same time
20:57:03 <mjonsson> reflexive and transitive but not necessarily symmetric
20:57:05 <Cale> (so this is weaker than a normal partial order)
20:57:07 <Cale> yeah
20:57:20 <Cale> not necessarily antisymmetric
20:57:28 <mjonsson> ah yes
20:57:33 <Cale> But a partial order is a kind of preorder, so those will work for us too.
20:57:52 <rwbarton> Of course, you don't really "need" preorders, since they are all equivalent to partial orders. :)
20:57:52 <Cale> So if we have a preordered set, we can turn it into a category
20:58:10 <Cale> rwbarton: uhhh...
20:58:41 <Cale> We put a single arrow from a to b if a <= b
20:58:48 <rwbarton> Cale: "a <= b and b <= a" is an equivalence relation and modding out by it doesn't change the category up to equivalence
20:58:54 <mjonsson> Cale, <= becomes the morphisms and the sets become the objects?
20:58:54 <Cale> the identity arrows come from the fact that a <= a
20:59:23 <Cale> mjonsson: The elements of the preordered set are the objects
20:59:35 <Cale> and there's a unique arrow x -> y if and only if x <= y.
20:59:45 <mjonsson> that makes more sense yeah
21:00:20 <Cale> Any category with at most one arrow between any two objects is obviously one of these preorder categories.
21:00:46 <Gracenotes> <= isn't actually less-than-or-equal-to, but some kind of probably-non-numerical ordering?
21:01:07 <Cale> Gracenotes: yes, we're only requiring that it's reflexive and transitive
21:01:16 <mjonsson> Gracenotes, it doesn't define an ordering because a <= b could be simulatenously true with b <= a
21:01:27 <mjonsson> for different a and b
21:01:43 <Gracenotes> ah, so a <= b and b <= a iff a = b isn't true
21:01:52 <Cale> right
21:01:58 <Gracenotes> hm.
21:01:59 <Cale> <= is a preorder here
21:02:25 <Cale> Preorders are actually still pretty nice -- it's not all that often that you need antisymmetry.
21:03:05 <ddarius> Antisymmetry is pretty nice too though.
21:03:09 <Cale> yes :)
21:03:20 <Cale> So we have that a category with one object is a monoid.
21:03:34 <Cale> And a category with at most one arrow between any pair of objects is a preorder.
21:03:46 <Cale> So those are sort of the two dimensions along which categories can grow.
21:03:53 <Gracenotes> s/isn't true/isn't necessarily true/
21:04:04 <Cale> Gracenotes: right.
21:04:04 <Gracenotes> so it's possible to have, but not needed
21:04:11 <Gracenotes> okay
21:04:26 <Cale> We could form the category of real numbers under <= for instance.
21:04:32 <Cale> and that would be a total order
21:05:07 <Gracenotes> the set theory/relation part makes sense :) the category theory part, not so clear, but that's just basic unfamiliarity...
21:05:46 <Cale> Gracenotes: did you miss the part when I explained how a preorder becomes a category, or did I not provide enough detail there?
21:06:06 <Gracenotes> I believe I did miss it. *scrolls up*
21:06:08 <Cale> (I'd be happy to go over the definition of a category more carefully if you want)
21:06:52 <Gracenotes> so a category is a sort of set, then? I had the impression that a set was a sort of category...
21:07:28 <sw17ch> @index fromJust
21:07:28 <lambdabot> Data.Maybe
21:07:41 <SamB> Gracenotes: it is not a sort of set
21:07:45 <ddarius> Gracenotes: For small categories, both of those are true.
21:07:48 <SamB> it's apparantly more general
21:08:07 <Cale> A category is a collection of objects, and for each pair of objects, a collection of arrows, together with an operation called composition, such that for any three objects A,B,C, and arrows f: A -> B, and g: B -> C, there is an arrow g . f: A -> C
21:08:17 <ddarius> Gracenotes: A small category is just a monad in the bicategory of spans of Set.
21:08:24 <SamB> ddarius: mathemeticians always have such tricky definitions of words like "small"
21:08:30 <Cale> ddarius: I'm sure that's useful to him ;)
21:08:34 <ddarius> Gracenotes: A set is essentially the same as a disrcete category.
21:08:38 <ddarius> Cale: It's pretty though.
21:08:44 <Cale> ddarius: I know :)
21:08:46 <Gracenotes> Cale: and a zero element, right?
21:08:48 <ddarius> SamB: Small = is a set
21:08:58 <SamB> ddarius: a finite set, you mean ?
21:09:00 <ddarius> (or specifically the collection of arrows is a set (usually))
21:09:02 <Cale> Gracenotes: and identity arrows id_A: A -> A for each object A
21:09:12 <ddarius> SamB: No, that would be a finite category.
21:09:15 <SamB> er, well, discrete ?
21:09:24 <Cale> such that id . f = f and f . id = f whenever those composites make sense
21:09:34 <ddarius> SamB: A discrete category has no non-identity arrows (i.e. it effectively only has objects)
21:09:36 <Cale> and such that (f . g) . h = f . (g . h) whenever the composites make sense
21:10:24 <ddarius> The full subcategory of Cat of discrete categories and functors between them is isomorphic to the category of sets.
21:10:27 <SamB> ddarius: that sounds sadder than a git-svn repository!
21:10:40 <Cale> Gracenotes: So if we take a category with only one object, and just a collection of morphisms, we have what is essentially a monoid (perhaps we'd like that collection to be a set)
21:10:59 <Gracenotes> a book I have here defines a preorder as a category in which there's at most one arrow between objects. Is this true as well?
21:11:04 <Cale> The unique identity arrow is the identity of the monoid, and composition is the monoid operation
21:11:10 <Cale> Gracenotes: yes
21:11:16 <Cale> And that's what I was saying :)
21:11:32 <ddarius> In fact, if you make a functor Ob : Cat -> Set, it's left adjoint is D : Set -> Cat which makes discrete categories from sets.
21:11:35 <monochrom> We need an obfuscation contest for mathematics. "A square is just .... <three pages of adjectives and conditions that start from some very general homotopy and apply group theory, geometry, analysis, and number theory that finally happens to narrow down to squares, no more no less>"
21:11:57 <Cale> A (small) category with at most one arrow between any two objects is basically the same thing as a preordered set.
21:12:45 <ddarius> monochrom: To be honest, I am actually purposely being accurate but overly technical.
21:12:52 <Gracenotes> it's something like a possibly-cyclic directed graph, right?
21:13:10 <Gracenotes> (if the relations are drawn out as a graph)
21:13:38 <SamB> monochrom: that doesn't sound very obfuscated ...
21:13:39 <Cale> Heh, I wonder if there's a category whose objects are R^2 and such that any square which commutes must have the vertices of an actual square as objects.
21:13:48 <Cale> mm, seems unlikely.
21:13:52 <Cale> Yes, impossible.
21:14:23 <monochrom> It doesn't sound obfuscated because I can't actually do it. When someone does it, it will be fun.
21:14:45 <Gracenotes> I should probably keep reading the book
21:14:53 <Cale> Gracenotes: a preorder?
21:15:09 <ozy`>  hmmm
21:15:17 <Cale> Gracenotes: It's a digraph where if there's a path between two objects, there's a path between them of length 1.
21:15:30 <Cale> Gracenotes: and such that there's always a path from an object to itself
21:15:45 <mjonsson> Gracenotes: the graph must have loops on every vertex and it must be transitive
21:15:47 <ozy`> is it possible to overload numeric literals so as to make (1 2 3) return [1, 2, 3]?
21:15:50 <Gracenotes> it's a general book about category theory... so far I've only read about set theory, the definition of a category and basic examples (which happen to be preorders)
21:16:04 <ddarius> Gracenotes: Which book?
21:16:06 <ozy`> I'd guess you could do something with fromIntegral....
21:16:22 <snowcomb> I want to define a function that uses pattern matching. I want the first TWO elements of a list, though.
21:16:24 <Cale> mjonsson: mm... the word 'transitive' is appropriate there, but it conjured up the wrong definition of transitive for me when you said it :)
21:16:27 <ddarius> ozy`: Probably not in any sane way.
21:16:37 <snowcomb> I tried f(x,y:r) but that does not work.
21:16:53 <snowcomb> Any ideas?
21:16:59 <Gracenotes> ddarius: uh, called "Topoi: The Categorial Analysis of Logic". I'm mainly interested in the introduction to category theory; the rest may not be as relevant to my interests
21:17:00 <ddarius> snowcomb: If you were going to add two elements onto a list, how would you do it?
21:17:02 <monochrom> f (x:y:r) = ...
21:17:16 <ddarius> Gracenotes: Who is/are the author(s)?
21:17:18 <pumpkin> can I have a rank-3 type?
21:17:23 <ddarius> I guess I could find out myself.
21:17:26 <ddarius> pumpkin: Sure.
21:17:36 <Gracenotes> name, Robert Goldblatt
21:17:38 <pumpkin> not sure what I'd use it for
21:17:39 <snowcomb> Doesn't that make y a list though?
21:17:47 <snowcomb> You can't cons an atom onto another atom
21:17:51 <monochrom> (forall y. (forall x. x) -> y) -> z
21:17:53 <Cale> Gracenotes: Did I send you Awodey's book?
21:17:58 <ozy`> snowcomb: no. it's the same as (x:(y:r))
21:18:02 <Gracenotes> Cale: I don't think so
21:18:07 <ddarius> pumpkin: That's because you haven't built up a tolerance for higher order polymorphism.  Once you do, you'll need a bigger and bigger fix.
21:18:22 <monochrom> Just trust me! :)
21:18:22 <snowcomb> I see.
21:18:24 <snowcomb> I shall try this.
21:18:54 <ozy`> snowcomb: by the way, consider using the (x:xs) convention to remind yourself which values are lists
21:19:05 <ozy`> (or in this case, (x:y:ys), I suppose)
21:19:27 <monochrom> x2:x3:xs
21:19:37 <snowcomb> It worked, thank you.
21:19:38 <monochrom> 2 because ancient Greeks started from 2.
21:19:42 <SamB> what the ?
21:19:52 <snowcomb> My problem was that I was doing [x:y:z] instead of x:y:z
21:19:57 <snowcomb> Adios.
21:21:44 * ddarius hopes all the people that do that have a Prolog background.
21:21:59 <Gracenotes> [x,y,z] can be used, at least
21:22:01 <SamB> ddarius: hmm?
21:22:06 <mjonsson> is there an alternative to hpaste? (it is down)
21:22:14 <monochrom> @hpaste2
21:22:14 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:22:15 <Gracenotes> although with ==3 elements, no-more-no-less
21:22:21 <monochrom> Oh darn.
21:22:46 <monochrom> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/  is hpaste2
21:23:06 <ddarius> SamB: In Prolog you pattern match/construct lists with [X|Xs]
21:23:35 <ddarius> And actually you do write [X,Y|Xs]
21:24:14 <monochrom> I hate that kind of inconsistent syntax.
21:24:41 <koninkje> Prolog's lists are typeless evil
21:26:21 <monochrom> The biggest inconsistency is in [x|[y|[a|[bs]]]]. Four levels of brackets do not imply four levels of list nesting.
21:28:53 <monochrom> wouldn't it be cool if the sequel to Real World Haskell were named: Complex World Haskell? :)
21:29:28 <SamB> you know, both of those have too many typeclass arguments ;-P
21:29:40 <SamB> no, wait, Complex is just a tycon
21:30:43 <monochrom> Oh, you want a Floating World Haskell.... ;)
21:31:22 <Gracenotes> RealFrac, perhaps
21:31:39 <Gracenotes> Real World Haskell, with all the benefits of fractionality
21:32:37 <mjonsson> monochrom, thanks
21:32:39 <mjonsson> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=849#a849
21:32:56 <mjonsson> that's a summary of what I learned today from Cale, in a form that maybe only I understand
21:33:20 <sw17ch> Fake World Haskell :: All about Simulation and Modeling
21:33:54 <monochrom> That's also neat.
21:34:20 <sw17ch> System.Console.GetOpt is very nice
21:42:11 <tseg> In Hugs, I can write functions like "f(x::Int)::Int = .." is there a way to do this in GHC?
21:42:42 <Heffalump> does -XPatternSignatures let you do that?
21:42:54 <Heffalump> it certainly lets you put a signature on x, not sure about on the result
21:44:09 <tseg> Heffalum, yes it does.  Thank you very much!
21:50:48 <Facedown2> Wow, what's up with http://learnyouahaskell.com/give
21:50:57 <Facedown2> using php huh.. ;(
21:51:07 <ozy`> guess they shoulda written it in happs
21:53:59 <pumpkin> SOMEONE SET UP US THE BOMB
21:55:02 <flippo> Yow!
22:11:07 <tseg> Is there a way to make GHCi automatically :reload each time I type a command?
22:11:37 <ddarius> Uh, why?
22:11:48 <pumpkin> (not that I know of)
22:12:08 <SamB> you could make a new command which reloaded and then performed another command
22:13:36 <ddarius> pumpkin: The :def command is pretty powerful though can involve crazy contortions to get a desired effect.
22:16:09 <pumpkin> ah
22:18:18 <tseg> I'm looking a the :def docs. What I really want to define is something like ":run expr", equivalent to ":reload" and then executing the expression in the command line. But the expression changes each time.
22:18:40 <m3ga> in ghci, I have loaded a module. now how do I find out what functions it contains?
22:18:56 <tseg> I use this approach frequently for iterative development in Hugs, which automatically does a :reload whenever my file changes.
22:19:02 <SamB> m3ga: use :b
22:19:11 <pumpkin> :browse isn't it?
22:19:16 <koninkje> m3ga: or :brouse
22:19:19 <SamB> oh, yeah
22:19:24 <SamB> darn them changing it on us
22:19:36 <koninkje> (just :b usually infers you mean :break instead)
22:19:40 <ddarius> tseg: That's easy to do wiht :def.
22:19:55 <SamB> I put this in my .ghci for that very reason:
22:19:58 <Gracenotes> @pl \a b c -> a == b && b == c
22:19:58 <lambdabot> (`ap` (==)) . (((.) . (&&)) .) . (==)
22:19:59 <m3ga> thanks all
22:20:02 <Gracenotes> eek
22:20:03 <SamB> :def b (return . (":browse "++))
22:20:38 <Gracenotes> @pl \a b c -> map (a==) [b,c]
22:20:38 <lambdabot> (. ((. return) . (:))) . (.) . map . (==)
22:20:42 <Gracenotes> o-o
22:20:52 <SamB> @pl (return . (":browse "++))
22:20:52 <lambdabot> return . (":browse " ++)
22:21:08 <pumpkin> Gracenotes: what's that for?
22:21:27 <Gracenotes> testing the equality of three things (transitivity is assumed)
22:21:56 <Gracenotes> it's for a QuickCheck function
22:22:10 <pumpkin> @pl \a b c -> a == b && c == b
22:22:10 <lambdabot> (`ap` (==)) . (((.) . (&&)) .) . (==)
22:22:18 <m3ga> hmm, i'm using ghc/ghci 6.8.2 and looking at System.Process. hoogle lists functions like readProcess and readProcessWithExitCode but they don't seem to exist. is 6.8.2 too early?
22:22:26 <Gracenotes> order probably matters, as well
22:22:31 <Gracenotes> @pl \a b c -> a == b && a == c
22:22:31 <lambdabot> ap (flip . (((.) . (&&)) .) . (==)) (==)
22:22:42 <koninkje> Gracenotes: points-free programming can be pointless for certain functions. Just use the lambda
22:23:14 <pumpkin> seems like you'd want an all instead of a map
22:23:18 <Gracenotes> yeah. I was hoping for an elegant solution, which pl sometimes gives
22:23:25 <dobblego> @type all (a==) [b, c]
22:23:26 <lambdabot> Bool
22:23:28 <Gracenotes> pumpkin: yeah, but pl doesn't know that, so it doesn't matter
22:23:33 <pumpkin> yeah, I know
22:23:35 <pumpkin> just sayin' :P
22:23:50 <Gracenotes> yep
22:25:00 <Gracenotes> @pl \b c -> f b && f c
22:25:00 <lambdabot> (. f) . (&&) . f
22:25:21 <jeffz`> m3ga: looks like the case, doesn't appear in 6.8.3 either
22:25:23 <Gracenotes> oh, that's nice
22:25:28 <pumpkin> @pl \f ->  (. f) . (&&) . f
22:25:29 <lambdabot> ap ((.) . flip (.)) ((&&) .)
22:25:31 <pumpkin> :P
22:25:46 <intrados> what's the benefit of cps?
22:25:46 <pumpkin> DRY
22:25:48 <ddarius> @pl \(&&) (==) a b c -> a == b && c == b
22:25:49 <lambdabot> (line 1, column 3):
22:25:49 <lambdabot> unexpected "&"
22:25:49 <lambdabot> expecting pattern
22:26:05 <ddarius> intrados: There isn't one.  There's no reason to CPS just for the heck of it.
22:26:17 <Gracenotes> pumpkin: by the way, f is actually (==f)
22:26:29 <pumpkin> I guessed as much :)
22:26:31 <Gracenotes> @pl \f -> (. (==f)) . (&&) . (==f)
22:26:31 <lambdabot> ap ((.) . flip (.) . (==)) (((&&) .) . (==))
22:26:43 <Gracenotes> hooray, the same inelegant solution as above
22:26:46 <ddarius> > (\(==) -> 3 == 4)
22:26:47 <lambdabot>       Overlapping instances for Show ((t -> t1 -> t2) -> t2)
22:26:47 <lambdabot>        arising f...
22:26:48 <intrados> ddarius: but there are specific circumstances where it might be more appropriate?
22:26:51 <ddarius> > (\(==) -> 3 == 4) (+)
22:26:52 <lambdabot>   7
22:27:01 <pumpkin> lol
22:27:03 <m3ga> jeffz`: thanks and :-(
22:27:06 <ddarius> intrados: It's a means to and end, not an end of itself.
22:27:41 <Gracenotes> @unpl (.f).g.h
22:27:42 <lambdabot> (\ d m -> g (h d) (f m))
22:27:56 <ddarius> @pl \and eq a b c -> (a `eq` b) `and` (c `eq` b)
22:27:56 <lambdabot> (`ap` flip) . ((flip . (liftM2 (.) .)) .) . (.) . (.)
22:28:01 <rwbarton> @pl \(x+1) -> x
22:28:02 <lambdabot> (line 1, column 4):
22:28:02 <lambdabot> unexpected "+"
22:28:02 <lambdabot> expecting letter or digit, operator or ")"
22:28:06 <ddarius> @pl \eq and a b c -> (a `eq` b) `and` (c `eq` b)
22:28:06 <lambdabot> ap (flip . ((flip . (liftM2 (.) .)) .) . flip ((.) . (.))) flip
22:28:18 <ddarius> @pl \eq a b c -> (a `eq` b) && (c `eq` b)
22:28:18 <lambdabot> liftM2 flip (liftM2 ((.) . (&&)) .) flip
22:29:42 <tseg> Thanks for the ":reload" help. Solution: :def p \args->return(":reload\n "++args)
22:31:24 <tseg> XScopedTypeVariables doesn't seem to work in GHC 6.10.1: It doesn't support "f(x::Int)::Int=3"
22:32:04 <ddarius> tseg: ScopedTypeVariables has nothing to do with that.
22:32:12 <ddarius> There are no type variables in that declaration.
22:36:37 <bos> I accidentally a type signature.
22:36:52 <bos> is this bad?
22:37:03 <bos> ahem, i shouldn't do that.
22:37:06 <kmeyer|lappy> bno
22:37:14 <newsham> eparse
22:37:52 <mauke> accidentally what?
22:38:03 <bos> follow this nsfw link to understand the context: http://i-fleshlight.blogspot.com/
22:38:21 <newsham> you had me at "nsfw"
22:38:40 <bos> it's only very slightly nsfw
22:39:04 <mauke> I'm reasonably sure that's not the original appearance
22:39:43 <bos> it's not, but it's a handy link.
22:40:13 <newsham> ?farber
22:40:14 <lambdabot> There were foot-high puddles.
22:41:23 <tseg> How to make "f(x::Int)::Int=3" work?  It works in Hugs98, and GHC docs suggest it should work: http://www.haskell.org/ghc/staging/docs/5.02/set/scoped-type-variables.html#AEN8758
22:42:43 <newsham> -XPatternSignatures ?
22:42:52 <mauke> er
22:42:57 <Saizan> tseg: you're looking at the documentation for ghc-5.02
22:42:58 <mauke> are those the docs for ghc 5.02?
22:43:05 <elly> when I try it in ghci, ghci tells me to use -XScopedTypeVariables to allow things like (x :: Int) in patterns
22:43:13 <newsham> this works for me in ghci -XPatternSignatures:   let f(x::Int) = 3 :: Int
22:44:36 <ddarius> This is indeed exactly what Heffalump told tseg (and tseg claimed worked) an hour ago.
22:44:58 <elly> it works with the :: Int afterward and -XPatternSignatures with ghc 6.10.1
22:47:05 <tseg> It seemed to work once, but hasn't worked subsequently. Investigating...
22:49:36 <tseg> It works with "f(x::Int)=3::Int", of course, but that's not as pretty if you replace 3 with a large multi-line function.
22:51:23 <rwbarton> tseg: you can also just write  f :: Int -> Int; f x = 3
22:52:04 <Gracenotes> interesting-ish result..
22:52:06 <Gracenotes> @djinn (Eq c) => (a -> c) -> a -> Maybe c -> Bool
22:52:06 <lambdabot> f a b c =
22:52:06 <lambdabot>     case a b == a b of
22:52:06 <lambdabot>     False -> False
22:52:06 <lambdabot>     True -> case c of
22:52:06 <lambdabot>             Nothing -> False
22:52:14 <lambdabot>             Just _ -> True
22:52:54 <Gracenotes> not terribly useful. But interesting, and works :)
22:54:24 <tseg> rwbarton: Thanks.  But the f::t->t; f(x)=3 version doesn't seem to allow types defined on the first line to be referenced inside the second line.  I find that type scoping helpful when fixing type errors in complex code.  I'll often write error("")::t, or expr::t to verify my assumptions about types, or fill in parts of a program incrementally.
22:55:17 <rwbarton> tseg: -XScopedTypeVariables
22:55:41 <rwbarton> tseg: I don't think you can use -XPatternSignatures to get the effect of -XScopedTypeVariables
22:55:48 <newsham> grace: are you trying to make it derive "maybe" or something?
22:58:04 <newsham> tseg: like this?   f :: forall a . a -> a -> [a]; f x y = [x :: a, y :: a]
22:58:25 <Gracenotes> ...that did not strike me as a possible type, but it would work. I just wanted to see if Djinn would come up with something where it's True if the third parameter isn't Nothing and is equal to (f :: a -> c) a, else False
22:58:34 <rwbarton> > let f :: forall a . a -> a -> [a]; f x y = [x :: a, y :: a] in f 1 28
22:58:35 <lambdabot>   [1,28]
22:58:53 <rwbarton> > let f :: a -> a -> [a]; f x y = [x :: a, y :: a] in f 1 28
22:58:55 <lambdabot>   Couldn't match expected type `a1' against inferred type `a'
22:59:11 <Gracenotes> lemme feed it maybe's type signature
22:59:12 <rwbarton> I wish it would just say "type variable a not in scope"
22:59:28 <Gracenotes> @djinn c -> (a -> c) -> Maybe a -> c
22:59:28 <lambdabot> f a b c =
22:59:28 <lambdabot>     case c of
22:59:28 <lambdabot>     Nothing -> a
22:59:28 <lambdabot>     Just d -> b d
22:59:36 <newsham> rwbarton: its both confusing and amusing :)
22:59:40 <rwbarton> or is it implicitly forall a. a there. hmm
23:00:33 <newsham> i think its using the name "x :: a" to pull out the "a" and then renaming the a -> a -> [a] as   a1 -> a1 -> [a1] to avoid conflict?
23:00:38 <rwbarton> > let f :: (forall a. a) -> [Int] ; f x = [x :: a] in f 38
23:00:39 <lambdabot>       Could not deduce (Num a) from the context ()
23:00:39 <lambdabot>        arising from the li...
23:01:22 <tseg> rwbarton, that gives me an error.  I think the "a" after the ";" is a different "a" than the "a" before the ";".
23:01:42 <rwbarton> tseg: I forgot to mention originally, you have to use forall to bind type variables
23:01:50 <newsham> tseg: you need to have a "forall a" in the type signature and -XScopedTypeVariables
23:02:03 <rwbarton> > let f (x :: Int) :: Int = 3 in f 9
23:02:04 <lambdabot>   <no location info>: Parse error in pattern
23:02:10 <rwbarton> > let f (x :: Int) = 3 in f 9
23:02:11 <lambdabot>   3
23:02:13 <newsham> that way the "a" will refer to the same "a"
23:02:41 <tseg> rbarton, you're right. That works with -XScopedTypeVariables.
23:02:55 <rwbarton> I guess it's a bit of a pain though.
23:03:10 <tseg> That solves my technical problem, but the syntax is still painful.
23:03:23 <rwbarton> BTW ghc has -XImplicitParams which can be used in its own ways to find out what the type inference engine is doing.
23:03:37 <newsham> -fglasgow-exts ftw
23:03:51 <rwbarton> > let (f :: Int -> Int) x = 3 in f 9
23:03:52 <lambdabot>   <no location info>: Parse error in pattern
23:04:49 <tseg> My real problem seems to be Karma. I'm using Haskell to build a compiler for a language that will compete with Haskell!
23:05:17 <newsham> ?faq can haskell be used to write a language that is more powerful than haskell?
23:05:18 <lambdabot> The answer is: Yes! Haskell can do that.
23:06:19 <rwbarton> > let f :: Int -> Int = \x -> 3 in f 9
23:06:21 <lambdabot>   3
23:07:08 <tseg> > let f :: z->Int = \x->3 in f 9
23:07:09 <Facedown2> ?faq CAN
23:07:09 <lambdabot> The answer is: Yes! Haskell can do that.
23:07:09 <lambdabot>   Not in scope: type variable `z'
23:07:17 <dons> ?users
23:07:17 <lambdabot> Maximum users seen in #haskell: 646, currently: 567 (87.8%), active: 12 (2.1%)
23:07:27 <Facedown2> ?help
23:07:27 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:07:32 <Facedown2> ?help interpreter
23:07:32 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:07:34 <Facedown2> ?help list
23:07:35 <lambdabot> list [module|command]
23:07:35 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
23:08:35 <rwbarton> > let f (x :: a) = [x, undefined :: a] in f "blah"
23:08:36 <lambdabot>       A pattern type signature cannot bind scoped type variables `a'
23:08:36 <lambdabot>        u...
23:08:39 <tseg> There are lots of viable and expressive solutions, they're just not as pretty as "f(x::Int)::Int=x".  I guess I can live without pretty, though! Thanks for all the help.
23:09:11 <newsham> why dont you just annotate the full type on the previous line?
23:09:17 <newsham> in the "normal" way?
23:09:21 * Saizan finds f(x::Int)::Int = x quite ugly
23:10:02 <newsham> looks like someone trying to make haskell syntax more C-like
23:11:37 <goalieca> faster to append to front of list or end of list in haskell by default?
23:11:39 <tseg> The two-line version works. It's just less convenient for the lots-of-parameters case: In f :: (A,B,C,D)->E; f(a,b,c,d)=.., it's hard to find the type of "c" at a glance.
23:12:15 <newsham> goalieca:  doing  't':"est"  is very fast.
23:12:25 <newsham> vs.  "tes" ++ "t"
23:12:40 <goalieca> okay.
23:13:06 <Saizan> tseg: why do you use tuples, btw?
23:13:21 <tseg> My ideal is a C-Pascal hybrid: f(x:int):int=x, g(h:int->int)(v:Int)=g(v), etc. Single-expression definitions, combining types, variables, and code.
23:14:11 <elly> tseg: that is exactly how Standard ML does them
23:14:32 <goalieca> how about reversing a list.
23:14:34 <Saizan> i.e. f a b c d = ... is much more natural to use
23:14:59 <newsham> goalieca: can you be more specific?
23:15:04 <newsham> > reverse "test"
23:15:06 <lambdabot>   "tset"
23:15:13 <newsham> the library has a predefined function for that
23:15:37 <goalieca> i mean performance wise. is reversing a large list slow?
23:15:40 <tseg> With tuples, error messages are more proximate to the cause.  In f(a,b,c)+1, you get an obvious error if f expected 4 parameters instead of 3.  With currying, you're trying to add a function to an integer, and the error is harder to comprehend.  Especially if deeply nested in complex code the uses the result non-locally.
23:15:59 <newsham> goalieca: I believe its linear in the length of the list in the lib implementation
23:16:13 <Saizan> ?src reverse
23:16:13 <lambdabot> reverse = foldl (flip (:)) []
23:16:31 <goalieca> hmm. so it iterates the entire list.
23:16:48 <pumpkin> it has to
23:16:50 <newsham> to get the head of the reversed list you have to iterate the entire input list
23:16:53 <Gracenotes> > reverse [1..10^7]
23:16:57 <goalieca> ya. its not double ended
23:17:01 <tseg> Standard ML + recursion (using lazy or lenient evaluation) + monad comprehensions would be a nice starting point.
23:17:06 <lambdabot>   mueval: Prelude.read: no parse
23:17:28 <newsham> right.  lists are built by cons of the first element and the tail list.  so the only way to get at the end of the list is to walk the entire thing
23:17:36 <newsham> there's no tail pointer
23:17:51 <Gracenotes> > reverse [1..10^5]
23:17:55 <lambdabot>   [100000,99999,99998,99997,99996,99995,99994,99993,99992,99991,99990,99989,9...
23:18:00 <Gracenotes> > reverse [1..10^6]
23:18:02 <lambdabot>   [1000000,999999,999998,999997,999996,999995,999994,999993,999992,999991,999...
23:18:22 * goalieca is trying to relearn/refresh/improve haskell skills by solving the project euler problems.. one per day till i get to the end
23:19:21 <Facedown2> good luck
23:20:13 <Gracenotes> what's an example of a homomorphism in Haskell?
23:20:22 <Gracenotes> if one exists
23:20:23 <Facedown2> LOL.
23:20:27 <newsham> Data.Sequence has a data structure for a sequence of data that you can access the tail of much more quickly.  but reverse is still O(n) for it (hey, you gotta build an n-length result)
23:20:36 <Facedown2> You have got to be kidding, Gracenotes
23:21:04 <Gracenotes> I'm studying the theory... no kid :<
23:21:26 <Gracenotes> i.e., maybe ([String],String) and ([Int],Int)
23:21:59 <newsham> gracenote: fmap?
23:22:26 <Gracenotes> ah! That seems about right
23:22:44 <Gracenotes> :)
23:22:50 <Saizan> Gracenotes: length is a monoid homomorphism from [a] to Int
23:23:12 <Gracenotes> "A “homomorphism of categories” is called a functor."
23:23:23 <pumpkin> Gracenotes: reading awodey?
23:23:26 <Gracenotes> Saizan: how is it a monoid?
23:23:29 <Gracenotes> pumpkin: yeah
23:23:37 <tseg> I don't think the notion of homomorphisms is defined in Haskell.  An isomorphism between two types t and u is a pair consisting of a functions f:t->u and its inverse g:u->t.
23:23:38 <pumpkin> it's associative and has an identity :o
23:23:53 <Saizan> the monoids are ([a],++,[]) and (Int,+,0)
23:24:10 <Gracenotes> ah... yes
23:24:13 <Saizan> length [] = 0; length (xs ++ ys) = length xs
23:24:20 <Gracenotes> yeah
23:24:24 <Saizan>                                 + length ys
23:24:41 <tseg> Category theory concepts don't map uniquely into Haskell.  You have to pick a particular category (such as the category of sets), and then you can define its operations uniquely in Haskell.
23:25:23 <Gracenotes> tseg: yes. I read (on IRC or on the web) that learning Haskell through category theory is probably easier than the reverse
23:25:51 <Saizan> tseg: homorphism is a concept from abstract algebra, and even there you've to specify the structure
23:26:03 <Saizan> "homomorphism"
23:26:03 <Gracenotes> still, one can kinda-try.
23:26:18 <Facedown2> You've caused quite a stir, Gracenotes
23:26:28 <goalieca> ?max
23:26:29 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
23:26:33 <goalieca> ?src max
23:26:33 <lambdabot> max x y = if x <= y then y else x
23:26:47 <Gracenotes> yeesh
23:26:57 <newsham> > let "" + ys = ys; (x:xs) + ys = xs + (x:ys); "" * ys = ""; (x:xs) * ys = ys + (xs * ys); xs^"" = "I"; xs^(y:ys) = xs * (xs^ys) in "III"^"II"
23:26:59 <lambdabot>   "IIIIIIIII"
23:27:04 <Facedown2> ...
23:27:08 <goalieca> ?src maximum
23:27:08 <lambdabot> maximum [] = undefined
23:27:08 <lambdabot> maximum xs = foldl1 max xs
23:27:11 <goalieca> aah :-)
23:27:17 <tseg> I recommend learning Haskell first (particularly, functors and monads) and then using that knowledge as a starting point for understanding category theory.  It's like learning arithmetic before field theory. :-)
23:28:25 <Gracenotes> heh. Yeah, I have a working knowledge of functors/monads... applicative not so much
23:28:45 <pumpkin> is there an easy list function to partition a list into three bits, the elements before matching a predicate, the first element that matches, and the elements after the match?
23:29:02 <newsham> hmm.. Data.Monoid doesnt have a Max monoid?
23:29:11 <pumpkin> there is one somewhere
23:29:16 <pumpkin> @index Max
23:29:16 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT
23:29:18 <pumpkin> lol
23:29:46 <chipdude> pumpkin: break, head, and tail don't serve?
23:29:51 <pumpkin> http://www.mail-archive.com/glasgow-haskell-bugs@haskell.org/msg14932.html
23:30:04 <Raevel> pumpkin: splitAt with tail . snd ?
23:30:16 <Raevel> oh wait, not splitAt
23:30:32 <pumpkin> I guess I can use break :)
23:30:53 <Gracenotes> hm, wontfix
23:30:54 <chipdude> foo a xs = let (bef, aft) = break a xs  in  (bef, head aft, tail aft)
23:30:59 <Raevel> i take it back! i meant break too
23:31:31 <newsham> > let (pre, (ch:post)) = span (/= 'X') "testXthis" in (pre,[ch],post)
23:31:32 <lambdabot>   ("test","X","this")
23:32:13 <newsham> (with care for when snd == "")
23:32:52 <chipdude> > let (pre, (ch:post)) = break (== 'X') "testXthis" in (pre,[ch],post)
23:32:53 <lambdabot>   ("test","X","this")
23:34:22 <newsham> cat break (=='X') inp of (pre, (ch:post)) -> (pre,ch,post); (pre,[]) -> (pre,[],[])
23:34:22 <Gracenotes> how's Const used?
23:35:05 <pumpkin> , sliceU (toU [1..10]) 0 3
23:35:08 <lunabot>  toU [1.0,2.0,3.0]
23:35:54 <Gracenotes> > getConst $ fmap show (Const 4)
23:35:56 <lambdabot>   4
23:36:17 <newsham> > getConst $ liftA2 (+) (Const 5) (Const 3)
23:36:19 <lambdabot>   Add a type signature
23:36:33 <newsham> > getConst $ liftA2 (+) (Const 5) (Const 3) :: Int
23:36:35 <lambdabot>       No instance for (Monoid Int)
23:36:35 <lambdabot>        arising from a use of `liftA2' at <...
23:37:00 <Gracenotes> > getConst $ liftA2 mappend (Const (Sum 5)) (Const (Sum 3)) :: Int
23:37:02 <lambdabot>   Couldn't match expected type `Int' against inferred type `Sum t'
23:37:05 <Gracenotes> eek
23:37:08 <Gracenotes> > getConst $ liftA2 mappend (Const (Sum 5)) (Const (Sum 3)) :: Sum Int
23:37:10 <lambdabot>   Add a type signature
23:37:12 <Gracenotes> :/
23:37:23 <Gracenotes> oh... other way around
23:38:00 <Gracenotes> :t getConst $ liftA2 mappend (Sum (Const 5)) (Const (Sum 3))
23:38:01 <lambdabot>     Couldn't match expected type `Const a a1'
23:38:02 <lambdabot>            against inferred type `Sum (Const t b)'
23:38:02 <lambdabot>     In the second argument of `liftA2', namely `(Sum (Const 5))'
23:38:03 <pumpkin> , let sliceU' us s l = sliceU us 0 s `appendU` sliceU us (s + l) (lengthU us - s - l) in sliceU' (toU [1..10]) 3 3
23:38:04 <lunabot>  toU [1.0,2.0,3.0,7.0,8.0,9.0,10.0]
23:38:23 <pumpkin> , sliceU (toU [1..10]) 3 3
23:38:24 <lunabot>  toU [4.0,5.0,6.0]
23:38:53 <pumpkin> , zipU (toU [1..10000]) (toU [1..10])
23:38:54 <lunabot>  toU [1.0 :*: 1.0,2.0 :*: 2.0,3.0 :*: 3.0,4.0 :*: 4.0,5.0 :*: 5.0,6.0 :*: ...
23:39:04 <pumpkin> , lengthU $ zipU (toU [1..10000]) (toU [1..10])
23:39:06 <lunabot>  10000
23:39:16 <pumpkin> , dropU 10 $ zipU (toU [1..10000]) (toU [1..10])
23:39:17 <lunabot>  toU [11.0 :*: -1.3368900179511313e-54,12.0 :*: 1.390714330400594e-309,13....
23:39:23 <pumpkin> mmorrow: you might want to fix that
23:39:36 <pumpkin> , dropU 10 $ zipU (toU [1..100000]) (toU [1..10])
23:39:38 <lunabot>  toU [11.0 :*: -2.123637775427696e-43,12.0 :*: -2.1230864099448037e-43,13....
23:39:45 <Workybob> Hmm, that's an interesting comment in haskell-cafe that associativity of monoids can lead to optimisations – does ghc actually do any optimisations that rely on the laws for each class?
23:39:55 <pumpkin> , dropU 10 $ zipU (toU [1..1000000]) (toU [1..2])
23:39:59 <lunabot>  toU [11.0 :*: -4.72251853898112e-43,12.0 :*: -2.7070244860439136e-62,13.0...
23:40:01 <Workybob> I can see that doing so would be rather contentious
23:40:35 <pumpkin> mmorrow: I'd recommend recompiling the uvector package with the safe flag :) it can probably be segfaulted in the current state
23:40:47 <mmorrow> pumpkin: interesting
23:40:48 <Gracenotes> well, that's not very useful.
23:41:05 <newsham> workybob: I think mathematical laws of some other classes are used during optimizations.
23:41:11 <mmorrow> (it actually wouldn't matter much if it segfaulted, since the evaluator's in another proc over a pipe)
23:41:13 <pumpkin> mmorrow: for speed, it doesn't check bounds, and it's what's been killing my program unpredictably for days
23:41:16 <newsham> I dont know if thats the case for monoids
23:41:22 <Gracenotes> you have to declare the second, never-used type of Const to be a monoid if you want to the Const itself as a monoid wrapper
23:41:23 <Workybob> newsham: interesting, and also shiny
23:41:31 <mmorrow> pumpkin: thx for the heads up. will do
23:41:33 <pumpkin> mmorrow: been getting segfaults and uninitialized memory because I assumed UArr's zip behavior was like list's
23:41:37 <Gracenotes> *to us
23:41:38 <pumpkin> alright :)
23:41:38 <Gracenotes> e
23:41:54 * Workybob wonders if there's a nicer way to specify the laws to the compiler when you create a class, rather than hand code them into the compiler
23:42:05 <mmorrow> pumpkin: ooh, that _is_ interesting. so it zips to the end of the /longer/ one?
23:42:08 <dobblego> Workybob, type system
23:42:20 <pumpkin> mmorrow: yup :) and keeps reading memory past the end of the shorter one :P
23:42:25 <mmorrow> yay!
23:42:31 <pumpkin> which is either uninitialized, or may not even belong to you
23:42:36 <pumpkin> giving two nice elusive bugs
23:42:39 <Workybob> dobblego: yeh, but then you get into haskell's type system not being powerful enough – try expressing all the arrow laws in the type system
23:42:56 <mmorrow> reminds me of C debugging hell
23:43:15 <pumpkin> yeah :) been getting very frustrated until dolio told me about the safe flag
23:43:16 <dobblego> Workybob, then there's your answer - have you used a total language?
23:43:22 <pumpkin> and in that case, you get a nice   lengthU (UAProd l r)     = checkEq "lengthU" "lengths of zipped arrays differ" (lengthU l) (lengthU r)
23:43:37 <newsham> workybob: even if it was powerful enough, might be rather hairy for normal programmers to have to build up proofs when using the libs
23:43:47 <pumpkin> which is a lot nicer than having it silently read random crap into your workflow
23:43:51 <mmorrow> pumpkin: what's the flag?
23:44:06 <pumpkin> cabal install --flags=safe uvector --reinstall is what I did
23:44:15 <Workybob> newsham: indeed – but I was actually pondering that it might be rather hairy for new programmers who got their instance subtly wrong, and got their code optimised into garbage
23:44:27 <pumpkin> but the flag is just called safe, you can see it in the .cabal file
23:44:36 <mmorrow> cool
23:45:29 <erikc> mmorrow: i get a Constructor `Hs.PatBind' should have 4 arguments, but has been given 5 error compiling the new haskell-src-meta
23:45:32 <newsham> *nod* but the common case is new programmers not writing instances of abstract classes they dont understand well and wanting their simple programs to be simple.
23:45:53 <newsham> (imo)
23:45:57 <mmorrow> erikc: you probably need the newest newest haskell-src-exts
23:46:13 <mmorrow> (didn't mean to write newest twice, but that works nicely actually ;)
23:46:36 <erikc> ah ... k... trying
23:46:45 <newsham> i guess it wouldnt reqiure any extra work until someone actually did try to implement a class instance
23:46:47 <Workybob> newsham: yeh – it's nice that checkers can automatically verify the non-classyness of your instances now, but it would be pretty nice to get proofs of that too
23:46:54 <newsham> which is when they'd have to actually do the hard proofs
23:47:08 <Workybob> yep
23:47:18 <Workybob> because normally they'd just be working with more guarentees
23:47:25 <Workybob> so in theory easier proofs
23:48:11 <erikc> mmorrow: sweet, worked. interpolatedstring-qq now cabal installs cleanly :)
23:48:51 <mmorrow> erikc: woohoo! nice to hear.
23:50:05 <newsham> honestly though every time i've seen someone do these in something like agda or coq and blog about it, i've been just barely able to wade through the complicated multi-blog articles and know for sure that none of my coworkers who are currently afraid of haskell would ever be convinced to try these out.  (ie. http://sequence.complete.org/node/358)
23:50:24 <Workybob> newsham: heh, I see
23:51:43 <cads> newsham: the difference between you and your coworkers is that they'd work desperately with the human resistance force, while you'll have long been converted into an awesome cyborg
23:51:53 <cads> I think.
23:52:03 <Workybob> rofl
23:52:13 <Workybob> so true
23:52:34 <Workybob> I don't wanna be a borg?  Why not, they're cool, and better than humans in almost every way
23:52:47 <Workybob> plus... they can prove that their implementation of a list monad really is one
23:52:48 <Workybob> >.>
23:53:47 <dobblego> newsham, what are some the reasons you here from your co-workers that lead you to think they are afraid of Haskell?
23:54:29 <cads> dobblego, from what standpoint do you ask?
23:54:38 <dobblego> my house
23:54:52 <dobblego> s/here/hear
23:54:55 <newsham> dobblego: from what I can divine, I think its mostly the major shift from languages they know.
23:55:23 <newsham> thats not exactly what I hear from them, but when I filter out the noise, that seems to be the general gist
23:55:40 <mmorrow> yay, just got lunabot to work with the new src-exts/src-meta
23:55:42 <mmorrow> , parseType "forall a.a"
23:55:43 <lunabot>  Right (ForallT [a] [] (VarT a))
23:55:52 <newsham> (noise including things like 'why do haskell programmers use single letter variables all the time' which I just phase out)
23:55:57 <dobblego> newsham, do you think they would admit that if asked directly?
23:55:59 <mmorrow> , parseExp "() :: forall a.a"
23:56:00 <lunabot>  Right (SigE (ConE GHC.Unit.()) (ForallT [a] [] (VarT a)))
23:56:10 <mmorrow> , parseDecs "data A = A"
23:56:11 <lunabot>  luna: toDec: Language.Haskell.Exts.Syntax.Decl not (yet?) implemented
23:56:14 <mmorrow> oops
23:56:25 <mmorrow> , parsePat "a@(_,x)"
23:56:26 <lunabot>  luna: Ambiguous occurrence `parsePat'
23:56:29 <newsham> dobblego: perhaps.  I think probably, though they might also give some other reasons which I didnt mention or cant think of now
23:56:33 <Workybob> newsham: in all fairness, I think that's one of the biggest flaws I can find in Haskell – it grows horizontally, not vertically, so we try to do everything we can to save horizontal space
23:56:42 <Workybob> including naming things x, snth,obrc, and oe
23:57:09 <cads> friends of mine are afraid of the functional programming theory they feel they'd have to learn to use haskell
23:57:26 <newsham> workybob; i dont think its endemic of the language.  i think its the result of the mathematical approach and borrowing from mathematical style of using short names like "x"
23:57:36 <Workybob> possible
23:57:43 <newsham> i'm also from the school of short variable names for unimportant variables, so I feel right at home with it
23:57:45 <cads> I always liked the single variable style
23:57:51 <Workybob> but you try writing a 3 argument function with "real" variable names
23:58:01 <cads> single letter variable, pardon
23:58:06 <newsham> (after having read lots of ken thompson code, I find lots of haskell code has *long* variable names ;-)
23:58:17 <Workybob> heh
23:59:23 <cads> don't you guys feel like programming in haskell is a lot more formal and feels more like the act of deriving an equation than the classic act of knocking together an object oriented program?
23:59:37 <newsham> dobblego: i think a lot of them probably just cant be bothered with the large initial investment to get into a useful part of the learning curve
23:59:51 <pumpkin> cads: yeah
23:59:56 <cads> I think many programmers are scared of substantial maths and formalisms
23:59:59 <newsham> cads: definitely.  thats the point of functional programming.
